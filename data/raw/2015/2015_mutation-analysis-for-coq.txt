Mutation Analysis for Coq
Ahmet Celik‚àó, Karl Palmskog‚àó, Marinela Parovic‚àó, Emilio Jes¬¥ us Gallego Arias‚Ä†and Milos Gligoric‚àó
‚àóThe University of Texas at Austin‚Ä†MINES ParisTech
ahmetcelik@utexas.edu, palmskog@acm.org, marinelaparo vic@gmail.com, e@x80.org, gligoric@utexas.edu
Abstract ‚ÄîMutation analysis, which introduces artiÔ¨Åcial defects
into software systems, is the basis of mutation testing, a technique
widely applied to evaluate and enhance the quality of test
suites. However, despite the deep analogy between tests andformal proofs, mutation analysis has seldom been consideredin the context of deductive veriÔ¨Åcation. We propose mutationproving, a technique for analyzing veriÔ¨Åcation projects thatuse proof assistants. We implemented our technique for the
Coq proof assistant in a tool dubbed
MCOQ.MCOQ applies
a set of mutation operators to Coq deÔ¨Ånitions of functions
and datatypes, inspired by operators previously proposed for
functional programming languages. MCOQ then checks proofs of
lemmas affected by operator application. To make our technique
feasible in practice, we implemented several optimizations in
MCOQ such as parallel proof checking. We applied MCOQ to
several medium and large scale Coq projects, and recorded
whether proofs passed or failed when applying different mutation
operators. We then qualitatively analyzed the mutants, Ô¨Åndingmany instances of incomplete speciÔ¨Åcations. For our evaluation,we made several improvements to serialization of Coq Ô¨Åles andeven discovered a notable bug in Coq itself, all acknowledgedby developers. We believe
MCOQ can be useful both to proof
engineers for improving the quality of their veriÔ¨Åcation projects
and to researchers for evaluating proof engineering techniques.
I. I NTRODUCTION
Mutation analysis introdu ces small-scale modiÔ¨Åcations to a
software system, with each modiÔ¨Åed system version called
amutant . Mutation analysis is widely applied to software
systems to perform mutation testing [1], where test suites
are evaluated on mutants of a system that represent faults
introduced by programmers, or are designed to give rise to
fault-like behavior. If a sp eciÔ¨Åc mutant induces test failures,
the mutant is said to be killed ; otherwise it is said to be
live. However, if a mutant survives all tests, this may indicate
an inadequate test suite or present avenues to improve tests.
Mutants of a system can be produced in a variety of ways;
a common approach implemented for many programming
languages, including functional languages such as Haskell, is
to apply mutation operators at a level near the source code
syntax, e.g., changing +to-. An operator may intuitively
represent a particular Ô¨Çaw that programmers are prone tomake, such as getting the sign of an integer variable wrong.
Formal veriÔ¨Åcation can offer guarantees about program
behavior and other properties beyond those of testing. In
particular, deductive veriÔ¨Åcation using proof assistants is in-
creasingly used for development of trustworthy large-scale
software systems [2]‚Äì[5]. Nevertheless, just as test suites may
be inadequate, formal speciÔ¨Åcations can fail to account for
unwanted program behavior [6], [7], potentially compromising
the ability of formal veriÔ¨Åcation to r ule out bugs and leading
to lower trust in veriÔ¨Åed code.Although it is regularly applied to unveriÔ¨Åed software and
during lightweight veriÔ¨Åcation [8], [9], mutation analysis has
only rarely been considered for proof assistants [10], and to
our knowledge, never with formal proofs in place of tests.
We propose mutation proving , a technique for mutation
analysis of veriÔ¨Åcation projects u sing proof assistants, suitable
for evaluating the adequacy of collections of formally proven
properties of programs. Our technique adapts and extends
mutation operators previously used to mutate Haskell pro-grams [11], [12]. We implemented our technique for the Coq
proof assistant [13] in a tool dubbed
MCOQ. Given a mutation
operator and a Coq project, MCOQapplies an instance of the
operator to a deÔ¨Ånition in Coq‚Äôs Gallina language, and then
checks all proofs that could be affected by the change.
A serious obstacle to operator-based mutation analysis in
proof assistants is the extensibility and Ô¨Çexibility of the
syntax used to express functions, datatypes, and properties. In
particular, Coq supports deÔ¨Åning powerful custom notations
over existing speciÔ¨Åcations [14], and Coq‚Äôs parser can be
extended with large grammars at any point in a source Ô¨Åle
by loading plugins [15]. These facilities are convenient for
expressing mathematical concepts, but pose a great challengefor processing of Coq Ô¨Åles. Moreover, deÔ¨Ånitions of functions
and datatypes, analogous to classes and methods in Java-like
languages, tend to be highly interspersed with proofs, whichare analogous to tests [16]. This precludes simple mutation
based on text replacement in source Ô¨Åles [17].
We overcome these challenges by leveraging the OCaml-
based S
ERAPI serialization library [18], which is integrated
with Coq‚Äôs parser and inte rnal data structures. We extended
Coq and S ERAPI to support full serialization of all Coq Ô¨Åles
used in large-scale projects to S-expressions (sexps) [19]. We
apply our mutation operators to the sexps we obtain, and
then deserialize and proof-check the results. To make mutation
proving feasible in practice for large-scale Coq projects, we
optimized MCOQin several ways, e.g., to leverage multi-
core hardware for fast parallel checking of proofs affected by
changes after applying a mutation operator.
To evaluate our technique, we applied MCOQto several
open source Coq projects, from medium to large scale. We
recorded whether a mu tant was live or killed based on proofs
passing or failing, and then qualitatively analyzed a subset of
mutants, unveiling several incomplete speciÔ¨Åcations. For our
evaluation, we enhanced S ERAPI and Ô¨Åxed several serializa-
tion issues, signiÔ¨Åcantly increasing its robustness in processing
large Coq projects. We also found a notable bug in Coq related
to proof processing when applying MCOQ[20], acknowledged
and subsequently Ô¨Åxed by the developers [21].
UI*&&&"$.*OUFSOBUJPOBM$POGFSFODFPO"VUPNBUFE4PGUXB SF&OHJOFFSJOH	"4&
¬•*&&&
%0*"4&
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Our technique and tool can be useful both to proof en-
gineers for directly analyzing their veriÔ¨Åcation projects and
to researchers for evaluating p roof engineering techniques,
analogously to how mutation testing is used to evaluate testing
techniques for functional programs [12].
We believe mutation proving is largely orthogonal to, and
complements, many other analysis techniques for proof assis-
tants, such as bounded testing [22], dependency analysis [16],
[23], counter-example generation [24], [25], property-basedtesting [26], [27], and theory exploration [28]. SpeciÔ¨Åcally,
these techniques do not consider ‚Äúalternative worlds‚Äù, where
deÔ¨Ånitions are different from the present ones [8].
We make the following contributions:
‚Ä¢Technique : We propose mutation proving for veriÔ¨Åcation
projects using proof assistants. We deÔ¨Åne a set of mutationoperators on deÔ¨Ånitions of functi ons and datatypes, inspired
by operators deÔ¨Åned previously for functional and impera-
tive programming languages.
‚Ä¢T ool: We implemented mutation proving in a tool, dubbed
MCOQ, which supports Coq projects. Our tool brings sig-
niÔ¨Åcant extensions to Coq and the S ERAPI library for seri-
alization and deserialization of Coq syntax; these extensionspave the way for other transformations of Coq code.
‚Ä¢Optimizations : To make mutation proving of large projects
feasible in practice, we optimized MCOQto make it run
faster. In particular, we implemented several novel forms ofselective and parallel checking of proofs for mutants.
‚Ä¢Evaluation : We performed an empirical study using MCOQ
on 12 large and medium-sized open source Coq projects.
For each project, we recorded the number of generated and
killed mutants and the execution time. We qualitatively ana-
lyzed a subset of the mutants, and found several incomplete
speciÔ¨Åcations manifested as live mutants.
‚Ä¢Impact : Our work resulted in many improvements and
bugÔ¨Åxes to S ERAPI, enhancing its robustness when applied
to large-scale projects and showing that complex, extensible
Coq Ô¨Åles can be manipulated in a lightweight way. We made
several modiÔ¨Åcations to Coq itself, and these changes have
been accepted by Coq developers.
We provide supplementary mater ial and artifacts related to
MCOQat: http://cozy.ece.utexas.edu/mcoq
II. B ACKGROUND
This section provides some brief background on the Coq
proof assistant, the S ERAPI library, and mutation testing.
A. The Coq Proof Assistant
Coq is a proof assistant based on type theory [13], imple-
mented in the OCaml programming language. The speciÔ¨Åca-
tion language of Coq, Gallina, is a small and purely functional
programming language. Proofs about Gallina speciÔ¨Åcations
are typically performed using sequences of expressions (tacticcalls) in Coq‚Äôs proof tactic language, Ltac [29]. Source Ô¨Åles
processed by Coq are sequences of vernacular commands ,
1Require Import Arith.
2
3Definition update {A} (st : nat ‚ÜíA) h (v : A) :=
4fun n‚áíifNat.eq_dec n h then velse st n.
5
6Lemma update_nop : ‚àÄA (st : nat ‚ÜíA) y v,
7st y = v ‚Üíupdate st y v y = st y.
8Proof .
9intros ;unfold update; case Nat.eq_dec; auto .
10Qed.
11
12Lemma update_diff : ‚àÄA (st : nat ‚ÜíA) x v y,
13x/negationslash=y‚Üíupdate st x v y = st y.
14Proof .
15intros ;unfold update.
16case Nat.eq_dec; congruence .
17Qed.
Update.v
Fig. 1: Example Coq source Ô¨Åle.
each of which can contain both Gallina and Ltac expressions.
Figure 1 shows an example Coq source Ô¨Åle which contains
a function update and two lemmas about the function. The
intended meaning of update , deÔ¨Åned on lines 3‚Äì4, is that
it returns a new version of a given function stfrom natural
numbers to some type A, and this returned function maps h
tovbut otherwise behaves as st.
Vernacular syntax is extensible by the user in almost ar-
bitrary ways by (1) deÔ¨Åning notations inside Coq, e.g., []
or[::] for the empty list constructor nil, and (2) loading
plugins in Coq that extend syntax. In particular, the Ltac
language and basic decision procedures for proof automation
are implemented as a collectio n of plugins. Since plugins can
generally be loaded at any time when interacting with Coq,the permitted syntax can grow dynamically as a vernacular
Ô¨Åle is processed. Hence, writing a robust stand-alone parser
for vernacular is difÔ¨Åcult, and will break easily as Coq evolves.
Even though Coq provides a logic of total, terminating func-
tions, Ltac allows nontermination, e.g., of proof search. Hence,
modifying a Gallina datatype or function may result in inÔ¨Ånite
loops, in analogy with the frequent inÔ¨Ånite loops that arise in
tests during mutation testing [1]. The mitigating practice in
mutation testing is to assign execution time thresholds for test
execution. Similarly, we set thresholds to the proof checking
time for each mutant.
Thecoqc tool compiles source .vÔ¨Åles to binary .vo Ô¨Åles
and checks all proofs. Such binary Ô¨Åles are then loaded by Coq
when processing Require commands in .vÔ¨Åles.
B.S
ERAPI and Serialization to S-expressions
SERAPI is an OCaml library and toolchain for machine
interaction with Coq [18]. S ERAPI has two principal com-
ponents: (1) an interface for serialization and deserialization
of Coq syntax and internal data structures to and from S-
expressions (sexps) [19] built on OCaml‚Äôs PPX metapro-
gramming facilities [30], and (2) a protocol for building and
querying Coq Ô¨Åles that abstracts over vernacular commands.
In effect, S ERAPI overcomes the problem of robustly parsing
vernacular by directly integrating with Coq‚Äôs parsing toolchain

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. CIf
CApp CRef CApp
Qualid
Path vCRef
Qualid
Path
Nat eq_decCRef CRef
Qualid
Path nQualid
Path hCRef
Qualid
n PathCRef
Qualid
Path st
Fig. 2: Sexp of if-subexpression on line 4 in Figure 1.
and internal datatypes. Since the serialization routines are
automatically generated from Coq‚Äôs own deÔ¨Ånitions usingmetaprogramming, S
ERAPI is expected to require only mod-
est maintenance as Coq evolves. Before our work, the principal
application of S ERAPI was for user interfaces for Coq, e.g.,
web-based interfaces [31].
When mutating Coq projects, we use the S ERAPI sexp-
based serialization facilities, avoiding heavyweight OCamllibrary development. Intuitively, a S
ERAPI sexp is either
an atom, representing a constant or variable name, or a
list delimited by parentheses. For example, the sexp for the
command on the Ô¨Årst line in Figure 1 is as follows:
(VernacExpr()(VernacRequire()
(false)(((Qualid(Path)(Arith))))))
A more readable but less compact representation of sexps
is graphically as trees. For example, the tree in Figure 2
provides a simpliÔ¨Åed illustration of the S ERAPI sexp for the
if-subexpression on line 4 in Figure 1.
C. Mutation Testing and Proving
We follow Papadakis et al. [1] in using mutation analysis for
the process of generating code variants, and mutation testing
for the application of this process to support software testing
and test suite improvement. In analogy with the latter, we
refer to the application of mutation analysis to support proof
development using proof assistants and improving collections
of formally proven properties as mutation proving .
Mutation analysis was propos ed by Lipton, then formalized
by DeMillo et al. [32], and Ô¨Årst applied in practice in the con-
text of software testing by Budd et al. [33]. In mutation testing,
test suites that distinguish between a mutant and the original
program, e.g., by reporting an assertion violation, leaving the
mutant killed , are judged to meet objectives. In contrast, test
suites that do not report assertion violations or other errors for
a mutant, leaving the mutant live, could be judged not to meet
objectives and may require revision. A test suite‚Äôs mutation
score is deÔ¨Åned as the percentage of killed mutants out of
all mutants that are distinct under functional equivalence [34].
Intuitively, mutants may be viewed as containing buggy code,
and the mutation score as a measure of how well the test suite
rules out the presence of buggy code [35], [36].
How to interpret killed and live mutants in mutation proving
is less clear than for mutation testing. While there may be deÔ¨Å-
nitions of functions and datatypes that are nonsensical for mostpurposes, a failing proof of a lemma using such deÔ¨Ånitions
does not unambiguously indicate an error or mistake (bug) in
the deÔ¨Ånitions. Coq proof scripts are often brittle [37] and fail
to produce proofs when associated deÔ¨Ånitions are changed in
trivial ways that preserve all their properties. In addition, the
goal of a proof assistant veriÔ¨Åcation project may be to prove
some lemma unrelated to any speciÔ¨Åc program.
Nevertheless, live mutants may still indicate the inadequacy
of the veriÔ¨Åcation harness [8] to fully meet reasonable objec-
tives. In particular, live mutants can go far beyond Ô¨Çagging up
completely unused deÔ¨Ånitions as in dependency analysis [23]:
they can pinpoint that certain fragments of key deÔ¨Ånitions
vacuously satisfy behavioral speciÔ¨Åcations [9], e.g., that an
ostensibly strong and complete lemma about a function can be
proven regardless of what the returned value is for a certain
range of inputs to that function. Many live mutants could
indicate the presence of such underspeciÔ¨Åcation in a Coqproject, which may eventually manifest as bugs in executable
systems [6] and lead to lower trust in formally veriÔ¨Åed code.
III. T
ECHNIQUE
In this section, we describe our mutation approach, mutation
operators, and optimizations to mutation proving.
A. Mutation Approach
Our approach to mutation proving follows the classical
approach of deÔ¨Åning a set of mutation operators (operator
for short) which describe cl asses of changes to a project.
Intuitively, an operator captures a common mistake made by
a proof engineer. When an operator is successfully applied to
a project, it generates a mutant. When the mutant has been
successfully checked, i.e., all related proofs have passed, it isdeclared live. Otherwise, if proof checking fails or times out,
the mutant is considered killed . Since the notion of functional
equivalence is not applicable to many veriÔ¨Åcation projects, we
use a broader deÔ¨Ånition of mutation score as the percentage
of killed mutants out of all mutants that are distinct undersyntactical equivalence .
We deÔ¨Åne operators for mutation proving as transformations
on Coq vernacular sexps. For any transformation and sexp,
it must be unambiguous and easily checkable whether the
transformation can be successfully applied or not to the sexp.
For example, if the transformation pertains to particular Coq
constants, it is applicable preci sely when those constants occur
in a speciÔ¨Åc way in the sexp. Note that checking syntactical
equivalence of a target and result sexp (modulo non-essentialauxiliary data such as Ô¨Åle line numbers) is simple and fast.
The initial step for applying any operator to a Coq veriÔ¨Åca-
tion project is to convert all .vsource Ô¨Åles to lists of sexps.
For a speciÔ¨Åc operator opand sexp list, the steps are then
to (1) apply opsequentially to all list elements until a non-
equivalent mutant is generated, (2) check the mutated list of
sexps, (3) check all proofs in Ô¨Åles that transitively depend on
the source Ô¨Åle that was (indirectly) mutated. The latter threesteps are repeated for all lists of sexps until no additional
mutants can be generated using op.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE I: List of Mutation Operators.
Category Name Description
GeneralGIB Reorder branches in if-else expression
GIC Reverse the order of the constructors in the deÔ¨Ånition
of an inductive type
GME Replace expression in the second match case with
the expression from the Ô¨Årst match case
ListsLRH Replace list with head singleton list
LRT Replace list with its tail
LRE Replace list with empty list
LAR Reorder arguments to the list append operator
LAF Replace list append expression with Ô¨Årst argument
LAS Replace list append expression with second argument
NumbersNPM Replace plus with minus
NZO Replace zero with one
NSZ Replace successor constructor with zeroNSA Replace successor constructor with its argument
BooleansBFT Replace false withtrue
BTF Replace true withfalse
1Require Import List. Import ListNotations.
2
3Fixpoint ftmap {A B} (f:A ‚Üíoption B) l:list B :=
4match lwith
5|[ ]‚áí[] | a :: xs ‚áí
6match fa with
7| None ‚áíftmap f xs
8| Some b ‚áíb :: ftmap f xs
9end
10end.
11
12Lemma ftmap_app : ‚àÄA B (f: A ‚Üíoption B) xs ys,
13ftmap f (xs ++ys) = ftmap f xs ++ftmap f ys.
14Proof .
15induction xs; intros ;simpl in*;auto .
16case (f a) eqn:?; simpl ;auto using f_equal.
17Qed.
18
19Lemma ftmap_in : ‚àÄAB( f :A ‚Üíoption B) a b xs,
20f a = Some b ‚ÜíIn a xs ‚ÜíIn b (ftmap f xs).
21Proof .
22induction xs; simpl ;auto .
23case (f a0) eqn:?; simpl ;intuition congruence .
24Qed.
Ftmap.v
Fig. 3: Example Coq source Ô¨Åle using lists.
B. Mutation Operators
Our inspiration for Coq mutation operators came from two
sources. Primarily, we were inspired by the operators deÔ¨Åned
by Le et al. for Haskell [11]. Secondarily, we took inspiration
from the operators in mutation frameworks for Java such as
PIT [38] and the Major framework [39], [40]. We considered
these operators through the lens of our experience from usingCoq for over 17 years (cumulative).
Table I lists our operators. For each operator, we give a
category, a short name which we will use in the rest of text, and
a short description. The G eneral category includes operators
which are applicable regardles s of whether a project uses a
speciÔ¨Åc datatype from the Coq standard library. The Listscategory includes operators which pertain to the ubiquitous
list datatype in the standard library. The Numbers categoryincludes operators which appl y to natural numbers in their
standard linear-size Peano encoding (e.g., 2is deÔ¨Åned as the
successor constructor applied two times to the zero construc-
tor). Similarly, the Booleans category applies to booleans as
deÔ¨Åned in the standard library.
In contrast to imperative languages such as Java, where
numeric datatypes are typically built-in, Gallina has only a fewnative constructs, which is reÔ¨Çected in the limited number of
operators in the General category . Other operators require a
project to use the corresponding notations and constants fromthe standard library; the associated categories therefore pertain
to the most elementary and widely used parts of the library.
To illustrate how our operators work, we give a few ex-
amples using the Coq code in Figure 1 and Figure 3. For amore intuitive presentation, we describe the effect of operators
mostly in terms of the source code rather than sexps.
General mutation example . Applying the operator GIB to
the Ô¨Åle in Figure 1 results in one mutant where update has
the expressions vandst n swapped on line 4. The proof of
update_nop goes through for the mutant, indicating that the
lemma does not express any fundamental property of update .
However, the proof of update_diff fails (speciÔ¨Åcally,
congruence on line 16 fails), killing the mutant. Note that
the mutation can be performed at the sexp level by swapping
the two rightmost subtrees below CIf in Figure 2.
Lists mutation examples . The source Ô¨Åle in Figure 3 contains
a recursive function ftmap (lines 3‚Äì10) that applies a given
partial function fto a list. The two accompanying lemmas
express some basic properties about the function; in particu-
lar,ftmap_app establishes that ftmap distributes over list
append. Applying the operator LRH results in a mutant wherethe singleton list [b] has replaced b :: ftmap f xs on
line 8. This mutant is killed by ftmap_app , since this
property no longer holds. Applying the operator LRT resultsin a mutant where the (tail) list expression ftmap f xs has
replaced b :: ftmap f xs on line 8. This mutant survives
ftmap_app , but is killed by ftmap_in .
C. Mutation Optimizations
Mutation analysis is generally acknowledged to be a costly
process [41], [42], and this also holds true for mutation
proving. In this section, we describe several optimizations to
our basic mutation proving approach.
In mutation testing, optimizations are generally about gen-
erating faster, smarter, or fewer mutants [43], [44]. We focus
on accomplishing faster mutation, and the insight we build on
is that proof checking for mutation proving can be viewed as
a particular instance of regression proving , i.e., to check an
existing Coq project after a change has been made; similar
insights are found in regression testing [45].
Proof selection . A proof selection technique uses knowledge
ofmodi Ô¨ÅedÔ¨Åles (or proofs) in a project to only check impacted
Ô¨Åles (or proofs) [16]. Since a successful application of a
mutation operator means that a sexp Ô¨Åle was modiÔ¨Åed, we canuse change impact analysis to perform selective proof checking
during mutation proving.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. QMutatorsexp parser
transformer.vÔ¨Åle
sexp Ô¨ÅleCoq SERAPIsercomp
compser
431
52
Fig. 4: MCOQimplementation architecture.
Proof checking parallelization . Unlike test execution in Java-
like languages, proof checking in proof assistants is determin-istic, which increases the potential for parallelization on multi-
core hardware. In particular, Coq proof checking is routinely
parallelized at the Ô¨Åle level, where the main restriction on the
degree of parallelism is the Ô¨Åle dependency graph [46].
Mutation operator parallelization . Since we only perform
Ô¨Årst-order mutation [47], app lication of one mutation operator
to a project can be performed completely independently of the
application of another operator. Hence, when the goal is to ap-
ply several operators to the same project, the outcomes can be
computed in parallel, as in mutatio n testing of software [43].
Mutant parallelization . Application of one mutant can be
performed completely independently of application of another
mutant. We thus also introduce a parallel mode where each
mutant is checked as a separate task.
IV . I
MPLEMENTATION
In this section, we describe the components of our muta-
tion proving implementation, deÔ¨Åne and discuss our mutation
modes and procedure which use the components, and outline
the impact of our tool development on other projects.
A. T ool Architecture and Components
Our tool for mutation proving, dubbed MCOQ,i si m p l e -
mented in OCaml, Java, and bash. Figure 4 shows an overview
of the architecture of MCOQ, and highlights how the main
components interact. During mutation proving, Coq source
Ô¨Åles to be mutated are Ô¨Årst given as input to our sercomp
program integrated with S ERAPI 1, which produces corre-
sponding Ô¨Åles with lists of sexps 2. The sexps are then handed
to our QMutator program 3, which performs parsing and
applies the transformations corresponding to a speciÔ¨Åed mu-
tation operator. Ultimately, QMutator outputs mutated sexps
4which become input to our compser program integrated
with S ERAPI 5. We next describe each main component of
MCOQin detail.
sercomp :We implemented a command-line program called
sercomp on top of S ERAPI which takes a regular Coq .v
source Ô¨Åle as input and outputs the corresponding lists of
sexps. The program is now included as part of S ERAPI [48].
compser :We implemented a command-line program called
compser on top of S ERAPI, meant to be the inverse ofsercomp .compser takes a Ô¨Åle with a list of sexps as input
and either produces a .vo Ô¨Åle or simply checks every sexp.
The program is now included as part of S ERAPI [48].
Coq fork: We forked the v8.9 branch of the Coq GitHub
repository corresponding to Coq version 8.9 and modiÔ¨Åed it
to expose internal data structures relevant for mutation proving
to S ERAPI. We submitted our proposed changes to the Coq
repository, and the developers eventually merged them.
SERAPI: We extended S ERAPI to provide serialization and
deserialization of all Coq internal data structures required to
support large projects. In particular, we added support for
serialization of Ltac syntax extensions added by the SSReÔ¨Çect
proof language [49] used in many projects. All of our changes
have been added to the S ERAPI codebase.
QMutator: We implemented a library for transformation of
sexps produced by sercomp , and mutation operators that use
this library, in Java. We used an existing library, jsexp [50],
to parse and encode sexps. Based on our experience, imple-
menting new operators on top of our library is quick and
straightforward. On top of our library, we implemented a
program dubbed QMutator that takes sexps and an operator
name as input, and produces mutated sexps.
Runner: We implemented a program in Java and bash that
uses the above components to perform mutation proving on a
given Coq project, and then computes its mutation score.
B. Mutation Modes and Procedure
Based on the approach and optimizations in Section III, we
deÔ¨Åne four basic mutation proving execution modes :
Default: A simple mode which checks every Ô¨Åle in a project
after a mutant is gene rated, by compiling .vÔ¨Åles to .vo Ô¨Åles
in topological order according to the Ô¨Åle dependency graph.
RDeps: An advanced mode which checks only .vÔ¨Åles
affected by a mutation, and caches and reverts to unmodiÔ¨Åed
.vo Ô¨Åles to avoid the cost of generating them more than once.
Skip: An advanced mode which checks only .vÔ¨Åles affected
by a mutation, and additionally avoids reverting .vo Ô¨Åles.
Noleaves: A variant of Default which checks proofs in leaf
nodes in the Ô¨Åle dependency graph but does not generate .vo
Ô¨Åles for those Ô¨Åles. We added this mode to explore if there
were any notable speedups gained by avoiding to write .vo
Ô¨Åles with compser .
To realize these modes, we implemented the parameterized
mutation procedure CHECK OPshown in Figure 5 in our
Runner program. In the subprocedures called by CHECK OP,
there are several auxiliary proce dures that behave differently
depending on the mode:
revertFile : For the Default and Skip modes, the Ô¨Åle vF
is always reverted. For RDeps, vFis never reverted. For
Noleaves, vFis reverted only if it is not a leaf node in rG.
getOtherFiles : For the Default and Noleaves modes, this
procedure returns rG.topologicalSort (sV F s ‚àív), whereas
for the RDeps and Skip modes, the procedure instead returns
rG.topologicalSort (rG.closure ({vF})‚àív).

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Algorithm 1 Pseudocode of CHECK OP.
Require: op‚Äì Mutation operator
Require: P‚Äì Coq Project
1:procedure CHECK OP(op,P)
2:
 vFs‚ÜêP.vFiles ()
3:
 G‚ÜêP.dependencyGraph ()
4:
 rG‚ÜêG.reverse ()
5:
 sVFs‚ÜêrG.topologicalSort (vFs)
6:
 v‚Üê‚àÖ
7:
 for vF‚ààsV F s do
8:
 v.add(vF)
9:
 CHECK OPVFILE(G ,r G ,o p ,s VFs ,v ,v F )
10:
 end for
11: end procedure
Algorithm 2 Pseudocode of CHECK OPVFILE.
Require: G‚Äì Dependency Graph
Require: rG‚Äì Reverse Dependency Graph
Require: op‚Äì Mutation operator
Require: sVFs ‚Äì Topologically sorted .vÔ¨Åles
Require: v‚Äì Set of visited .vÔ¨Åles
Require: vF‚Äì.vÔ¨Åle
1:procedure CHECK OPVFILE(G,rG,op,sVFs ,v,vF)
2:
 sF‚Üêsercomp (vF)
3:
 mc‚ÜêcountMutationLocations (sF, op )
4:
 mi‚Üê0
5:
 while mi < mc do
6:
 mSF‚Üêmutate (sF, op, mi )
7:
 CHECK OPSEXPFILE(G, rG, sV Fs, v, vF, mSF )
8:
 mi‚Üêmi+1
9:
 end while
10:
 revertFile (vF)
11: end procedure
Algorithm 3 Pseudocode of CHECK OPSEXPFILE.
Require: G‚Äì Dependency Graph
Require: rG‚Äì Reverse Dependency Graph
Require: sVFs ‚Äì Topologically sorted .vÔ¨Åles
Require: v‚Äì Set of visited .vÔ¨Åles
Require: vF‚Äì.vÔ¨Åle
Require: mSF ‚Äì Mutated sexp Ô¨Åle
1:procedure CHECK OPSEXPFILE(G,rG,sVFs ,v,vF,mSF )
2:
 ifcompser (mSF )/negationslash=0 then
3:
 Global.killed [op]‚ÜêGlobal.killed [op]+1
4:
 return
5:
 end if
6:
 oVFs‚ÜêgetOtherFiles (G, rG, sV Fs,v, vF )
7:
 revertOtherFilesBefore (vF, oV Fs )
8:
 foroF‚ààoV F s do
9:
 ifcoqc (oF)/negationslash=0 then
10:
 Global.killed [op]‚ÜêGlobal.killed [op]+1
11:
 break
12:
 end if
13:
 end for
14:
 revertOtherFilesAfter (vF, oV Fs )
15: end procedure
Fig. 5: Mutation procedure pseudocode.
revertOtherFilesBefore : For all modes except Skip, this
procedure does nothing. For the Skip mode, it reverts all Ô¨Åles
inG.closure (oV F s )‚àíoV F s ‚àí{vF}, with oV F s deÔ¨Åned on
line 6 in CHECK OPSEXPFILE.
revertOtherFilesAfter : For all modes except RDeps, it
does nothing. For RDeps, it reverts all Ô¨Åles in oV F s .On top of the basic modes, we deÔ¨Åne four parallel modes,
which we believed could lead to signiÔ¨Åcant speedups:
ParFile: This mode builds on Skip and parallelizes the for
loop in the CHECK OPSEXPFILEprocedure (lines 8 to 13).
Parallelization is at the coarse-grained Ô¨Åle level.
ParQuick: Like ParFile, this mode builds on Skip and par-
allelizes the for loop in the CHECK OPSEXPFILEprocedure
(lines 8 to 13). However, parallelization is at the Ô¨Åne-grained
level of proofs [46], [51].
ParMutant: This mode builds on RDeps, and checks each
mutant in parallel, i.e., we parallelize the while loop in the
CHECK OPVFILEprocedure (lines 5 to 9).
6-RDeps: In this mode, we organize the operators into groups
of six or less, and run groups in parallel using the RDeps
mode. We limit to six groups to match the number of cores
available in our evaluation machine.
C. Impact of T ool Development
Work on our tool implementation resulted in more than 10
merged code contributions to S ERAPI. SpeciÔ¨Åcally, we found
over 30 failing test cases that were all Ô¨Åxed. Our enhancements
to Coq itself have been merged and are set to be included in
the upcoming Coq version 8.10.0 release.
When applying mutation provi ng to a project (StructTact)
during our evaluation, we generated a mutant which we
checked with both coqc andcompser ; the mutant was killed
according to the former but not the latter. The discrepancy was
due to a serious bug in Coq related to proof processing [20],
acknowledged and subsequently Ô¨Åxed by the developers [21].This shows that mutation proving development has signiÔ¨Å-
cantly improved general Coq tooling.
V. E
VA L UAT I O N
We evaluate MCOQby answering four research questions:
RQ1: What is the number of mutants created for large and
medium sized projects and what are their mutation scores?
RQ2: What is the cost of mutation proving in terms of the
execution time and what are the beneÔ¨Åts of our optimizations?
RQ3: Why are some mutants (not) killed?
RQ4: How does mutation proving compare to dependency
analysis for Ô¨Ånding incomplete and missing speciÔ¨Åcations?
We run all experiments on a 6-core Intel Core i7-8700 CPU
@ 3.20GHz machine with 64GB of RAM, running Ubuntu
18.04.1 LTS. We limit the number of parallel processes to
be at or below the number of physical CPU cores. We next
describe the studied projects, our independent and dependent
variables, and our results.
A. V eriÔ¨Åcation Projects Under Study
Table II lists the Coq projects used in our evaluation; all
are publicly available. For each project, we show the project
name, the latest SHA at the time of our experiments, number
of.vÔ¨Åles, total lines of code (LOC), speciÔ¨Åcation LOC, and
proof script LOC. All LOCs are computed using the coqwc

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE II: Projects Used in the Evaluation.
Project SHA #Files LOC Spec. LOC Pr . LOC
ATBR 366ac237 42 9705 4123 5567
FCSL PCM b34fce32 12 5747 2939 2851Flocq 7ec13200 29 24000 5955 18044Huffman 50687911 26 5889 1878 4011
MathComp 91fa7b57 89 82323 37520 46040
PrettyParsing 189a2625 14 1907 1221 705Bin. Rat. Numbers 7b9cc06d 37 35041 5500 29541Quicksort Compl. 0a6eed8b 36 8809 2617 6202
Stalmarck 6932ed8a 38 11266 3552 7698
Coq-std++ 005887ee 43 13715 6882 6852
StructTact 82a85b7e 19 4341 2008 2333
TLC 4babc16c 49 23494 13217 7802
Avg. n/a 36.16 18853.08 7284.33 11470.50
Total n/a 434 226237 87412 137646
tool, which is bundled with Coq. The last two rows of the
table show the average and total values across all projects.
We selected the projects based on (1) compatibility with
Coq version 8.9, (2) their size and popularity in terms of, e.g.,
GitHub stars and usage in other Coq projects, and (3) their
inclusion of functions and da tatypes that can be mutated.
B. V ariables
Independent variables . We manipulate two independent vari-
ables in our experiments: operator and execution mode. For
the former, we use the 15 operators deÔ¨Åned in Table I. For the
latter, we use the 8 execution modes described in Section IV-B.
Dependent variables . We compute three dependent variables:
mutation score, execution cost, and cost reduction. Mutation
score provides an estimate of the adequacy of formal speci-
Ô¨Åcations; this metric is computed as the percentage of killed
mutants out of the total number of mutants minus the numberof syntactically equivalent mutants. Mutation score is either
computed per mutation operator or for all mutants at once.
Execution cost is the time needed to pe rform mutation proving;
this metric can also be reported per mutation operator or for
all mutants at once. Cost reduction is the percentage of time
saved using various execution modes compared to the time
needed to perform mutation proving using the Default mode.
C. Results
1) RQ1: Number of Mutants and Mutation Score: Table III
shows the total number of generated mutants for each pair of
project (row) and mutation operator (column). Additionally,
the last column shows the tota l number of mutants per project,
and the last two rows show the average and total number ofmutants per mutation operator. We can observe that GME
generates the most mutants, followed by NZO and NPM. On
the other hand, NSZ generates the smallest number of mutants,followed by NSA. This indicates that explicit uses of the
natural number successor construct or were few for the projects
we used in our evaluation. Table IV shows the number of killed
mutants for each pair of project and mutation operator.
Table V shows the mutation score for all pairs of projects
and mutation operators; n/a indi cates mutation score value thatcannot be computed because the number of generated mutants
is zero. The last column shows the mutation score for all
mutants in a given project, which is the metric traditionally
reported in mutation testing research; these mutation scores
vary from 76.88% (for TLC) to 99.18% (for Huffman).
Recall that mutation scores exclude (syntactically) equiv-
alent mutants. However, including equivalent mutants would
affect mutation scores only marginally: all but three projects
(ATBR, Flocq, and Bin. Rat. Numbers) had two equivalentmutants or less. The GME operator accounted for all 24
equivalent mutants, which were due to pattern matching cases
returning the same expression.
It is important to note that mutation scores are much
higher than traditionally seen in mutation testing research.
We expected such high scores for several reasons. First, as
mentioned in Section II-C, many Coq proof scripts are brittle
and fail after only trivial changes are made to speciÔ¨Åcations.Second, even robust proofs tend to be tightly coupled to
functions and datatypes, in effect exploring them symbolically
rather than relying only on externally observable properties
such as outputs. This is what enables proofs to, e.g., establish
properties about all members of inÔ¨Ånite sets of datatypeinstances, which is impossible for traditional unit tests. Two
projects are outliers in terms o f mutation score (PrettyParsing
and TLC) and we come back to this below.
Finally, we analyzed the logs of our runs, which record the
reason for each mutant being killed, and found that only 2
mutants were killed due to timeout. These two mutants were
generated by GME and LRT.
2) RQ2: Performance: Table VI shows the proof checking
and mutation proving time (in seconds) for various execution
modes. SpeciÔ¨Åcally, the second column shows time to check
the project by running the default build commands ( coqc
viamake ) for each project. The third column shows time to
process all Ô¨Åles in a project with sercomp . Recall that we
mutate a Ô¨Åle by Ô¨Årst obtaining the corresponding sexps via
sercomp , produce a mutant, and then use compser to write
a.vo Ô¨Åle back to disk. Clearly, it would be costly to use both
sercomp andcompser
to proof check all the Ô¨Åles in any
given project, so we use this combination only on the Ô¨Åle being
mutated. The fourth column sh ows time to perform mutation
proving using the Default mode. The remaining columns show
execution time for mutation proving for optimized modes.
Due to performing unnecessary proof processing, the De-
fault and Noleaves modes are consistently the slowest, typ-
ically by a wide margin. Reasonably, RDeps and Skip give
consistent speedups, sometimes substantial, over the basic
modes (on average 23% over Default). Nevertheless, some
projects such as Huffman show only marginal improvement.
We expected parallel modes to perform better than the ad-
vanced sequential modes. However, ParFile and ParQuick were
only substantially faster than Skip for some large projects, such
as MathComp. This may be due to many mutants being killed
quickly before realizing the beneÔ¨Åts of parallel checking. Fornearly all projects, ParMutant is a clear winner over 6-RDeps
and others; its average speedup over Default is 70%.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE III: Total Number of Mutants for each Mutation Operator per Project.
Project GIB GIC GME LRH LRT LRE LAR LAF LAS NPM NZO NSZ NSA BFT BTF
 Total
ATBR 33 21 74 7 7 7 1 1 1 87 43 19 19 17 18
 355
FCSL PCM 0 8 13 8 8 8 0 0 0 2 5 0 0 35 28
 115
F l o c q 3 9 1 4 9 3000000 7 1 5 422 4 5 6 2
 382
H u f f m a n 0 1 5 4 5 7 2 7 2 7 2 1 5 1 5 1 5 1 955577
 369
MathComp 0 10 73 58 58 58 12 12 12 114 385 0 0 136 109
 1037
PrettyParsing 30 8 68 17 17 17 28 28 28 13 16 3 3 3 3
 282
Bin. Rat. Numbers 2 10 52 0 0 0 0 0 0 203 79 4 4 5 6
 365
Quicksort Compl. 12 15 77 104 104 104 49 49 49 27 18 30 30 6 7
 681
Stalmarck 0 25 129 101 101 101 3 3 3 42 6 1 1 25 24
 565
Coq-std++ 12 31 149 68 68 68 13 13 13 23 20 22 22 28 14
 564
S t r u c t T a c t 73 3 0999222 1 255522
 104
T L C 43 6 7 13 83 83 8 5 5 5 2 33 83 33 32 01 3
 400
Avg. 11.58 16.33 72.83 40.16 40.16 40.16 10.66 10.66 10.66 53.00 56.16 10.33 10.33 27.41 24.41
 434.91
Total 139 196 874 482 482 482 128 128 128 636 674 124 124 329 293
 5219
TABLE IV: Total Number of Killed Mutant s for each Mutation Operator per Project.
Project GIB GIC GME LRH LRT LRE LAR LAF LAS NPM NZO NSZ NSA BFT BTF
 Total
ATBR 32 15 67 7 7 7 1 1 1 84 40 19 19 17 18
 335
FCSL PCM 0 8 11 8 8 8 0 0 0 2 5 0 0 34 28
 112
Flocq 37 14 77 0 0 0 0 0 0 68 54 2 2 37 58
 349
H u f f m a n 01 3 4 57 27 27 21 51 51 5 1 9 4 5 5 7 7
 366
MathComp 0 8 73 58 56 58 11 12 12 113 381 0 0 135 108
 1025
PrettyParsing 24 2 62 15 15 15 25 28 28 9 6 2 2 1 1
 235
Bin. Rat. Numbers 2 10 47 0 0 0 0 0 0 199 75 4 4 5 6
 352
Quicksort Compl. 11 11 73 96 84 104 49 49 49 26 14 29 29 6 7
 637
Stalmarck 0 20 124 101 83 101 2 3 3 42 2 1 1 23 20
 526
Coq-std++ 11 15 139 63 63 64 12 12 12 23 17 22 22 27 13
 515
S t r u c t T a c t 72 2 9999222 1 25 5511
 100
TLC 4 16 62 38 31 38 5 5 5 12 22 22 17 18 11
 306
Avg. 10.66 11.16 67.41 38.91 35.66 39.66 10.16 10.58 10.58 50.75 52.08 9.25 8.83 25.91 23.16
 404.83
Total 128 134 809 467 428 476 122 127 127 609 625 111 106 311 278
 4858
3) RQ3: Qualitative Analysis: To qualitatively analyze why
mutants are killed or live, we sampled live mutants to inspect
manually. To ensure diversity among inspected mutants, we
set a requirement of inspecting 10% or more of all livemutants for each operator, and 10% of all live mutants for
each project. Due to our familiarity with the project, we also
decided to inspect alllive mutants in MathComp. Initially, we
randomly chose mutants to inspect from the set of all live
mutants. When we had inspected 5% of total, we Ô¨Ånished
the remaining MathComp mutants and used the distribution
among operators and projects for inspected mutants to sample
from underrepresented subsets.
In total, we inspected 74 live mutants, which we labeled
with precisely one of the following labels:
‚Ä¢UnderspeciÔ¨ÅedDef: The live mutant pinpoints a deÔ¨Ånitionwhich lacks lemmas for certain cases (33 mutants).
‚Ä¢DanglingDef: The live mutant pinpoints a deÔ¨Ånition thathas no associated lemma (30 mutants).
‚Ä¢SemanticallyEq: The live mutant is semantically equiva-
lent to the original project (11 mutants).
A detailed description of each live mutant with links to
their locations in the original source code repositories can be
found in the supplementary material at the MCOQwebsite.
Here, we Ô¨Årst highlight some notable live mutants labeled withUnderspeciÔ¨ÅedDef, and then discuss our general experience
from the analysis.
GIB mutant in Flocq: A mutant swapped the branches in
the if-else expression of the following function for addition ofbinary IEEE 754 Ô¨Çoating-point numbers:
Definition Bplus op_nan m x y := match x,y with
| B754_infinity sx, B754_infinity sy ‚áí
ifBool.eqb sx sy then x
else build_nan (plus_nan x y)
The mutant reveals that a particular case of binary addition,
namely for numbers represen ting inÔ¨Ånities, is not considered
by any lemma. Another live GIB mutant showed the same
problem for the analogous deÔ¨Ånition for subtraction, Bminus .
BFT mutant in StructT act: A mutant which changed false
totrue in a function named before_func on lists high-
lighted that the function was weakly speciÔ¨Åed in the library:
Fixpoint before_func {A} (f : A ‚Üíbool) g l :=
match lwith |[ ]‚áí‚ä• | a :: l‚Äô ‚áí
f a = true ‚à®(g a = false ‚àßbefore_func f g l‚Äô)
end.
Further investigation revealed Ô¨Åve general lemmas about
before_func in Verdi Raft [4]; four of these lemmas kill
the mutant. Our changes to factor out all Ô¨Åve lemmas to
StructTact have been merged in both projects.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE V: Mutation Score for each Mutation Operator per Project.
Project GIB GIC GME LRH LRT LRE LAR LAF LAS NPM NZO NSZ NSA BFT BTF
 Total
ATBR 96.96 71.42 95.71 100.00 100.00 100.00 100.00 100.00 100.00 96.55 93.02 100.00 100.00 100.00 100.00
 95.44
FCSL PCM n/a 100.00 100.00 100.00 100.00 100.00 n/a n/a n/a 100.00 100.00 n/a n/a 97.14 100.00
 99.11
Flocq 94.87 100.00 90.58 n/a n/a n/a n/a n/a n/a 95.77 100.00 100.00 100.00 82.22 93.54
 93.31
Huffman n/a 86.66 100.00 100.00 100.00 100.00 100.00 100.00 100.00 100.00 80.00 100.00 100.00 100.00 100.00
 99.18
MathComp n/a 80.00 100.00 100.00 96.55 100.00 91.66 100.00 100.00 99.12 98.96 n/a n/a 99.26 99.08
 98.84
PrettyParsing 80.00 25.00 91.17 88.23 88.23 88.23 89.28 100.00 100.00 69.23 37.50 66.66 66.66 33.33 33.33
 83.33
Bin. Rat. Numbers 100.00 100.00 95.91 n/a n/a n/a n/a n/a n/a 98.02 94.93 100.00 100.00 100.00 100.00
 97.23
Quicksort Compl. 91.66 73.33 97.33 92.30 80.76 100.00 100.00 100.00 100.00 96.29 77.77 96.66 96.66 100.00 100.00
 93.81
Stalmarck n/a 80.00 96.87 100.00 82.17 100.00 66.66 100.00 100.00 100.00 33.33 100.00 100.00 92.00 83.33
 93.26
Coq-std++ 91.66 48.38 94.55 92.64 92.64 94.11 92.30 92.30 92.30 100.00 85.00 100.00 100.00 96.42 92.85
 91.63
StructTact 100.00 66.66 96.66 100.00 100.00 100.00 100.00 100.00 100.00 100.00 100.00 100.00 100.00 50.00 50.00
 96.15
TLC 100.00 44.44 89.85 100.00 81.57 100.00 100.00 100.00 100.00 52.17 57.89 66.66 51.51 90.00 84.61
 76.88
Avg. 94.39 72.99 95.71 97.31 92.19 98.23 93.32 99.14 99.14 92.26 79.86 92.99 91.48 86.69 86.39
 93.18
TABLE VI: Proof Checking and Mutation Time in Seconds for Various Modes.
Project Checking Sercomp Default RDeps Skip N oleaves ParFile ParQuick ParMutant 6-RDeps
ATBR 45.39 131.33 2157.68 1760.27 1761.59 2155.00 1342.52 1523.21 596.21 755.40
FCSL PCM 11.75 21.95 153.22 150.88 151.12 153.47 152.02 150.79 53.33 109.51Flocq 17.25 37.38 725.82 547.06 547.47 726.71 544.10 543.79 156.63 199.02Huffman 7.75 11.58 188.64 185.70 186.19 188.13 181.66 207.94 62.46 72.38
MathComp 341.33 593.19 9962.99 8480.79 8482.90 9967.52 6886.28 6763.25 4053.67 3943.05
PrettyParsing 4.37 5.57 278.56 216.98 217.24 278.67 214.50 268.35 66.06 90.21Bin. Rat. Numbers 26.29 16.95 1022.61 925.50 925.80 1022.19 894.52 889.60 264.85 578.94Quicksort Compl. 17.66 34.33 1594.66 1064.64 1062.81 1596.87 914.65 928.41 362.38 553.53
Stalmarck 9.21 16.55 805.84 498.01 499.00 803.52 469.42 571.76 192.78 230.62
Coq-std++ 30.94 57.01 3187.80 2597.54 2597.34 3186.81 2194.68 2403.13 776.77 1137.16
StructTact 3.40 7.27 55.90 41.62 40.98 55.93 39.72 40.20 18.84 19.35
TLC 21.82 44.77 3128.85 1739.27 1738.99 3126.18 1467.15 1542.01 519.59 693.88
Avg. 44.76 81.49 1938.54 1517.35 1517.61 1938.41 1275.10 1319.37 593.63 698.58
Total 537.16 977.88 23262.57 18208.26 18211.43 23261.00 15301.22 15832.44 7123.57 8383.05
LRT mutant in MathComp: In this mutant, the last empty
list[::] is removed from an auxiliary function used by an
implementation of the merge sort algorithm:
Fixpoint merge_sort_push s1 ss :=
match sswith
| [::] :: ss‚Äô | [::] asss‚Äô‚áís1 :: ss‚Äô
|s 2: :s s ‚Äô ‚áí
[::] :: merge_sort_push (merge s1 s2) ss‚Äô
end.
In essence, mutation preserves the functional correctness of
sorting. However, the complexity of the sort function changes
from O(nlogn)toO(n2). According to the author of the
function (in personal communication), Georges Gonthier, ‚Äúthe
key but unstated invariant of ssis that its ith item has size 2i
if it is not empty, so that merge_sort_push only performs
perfectly balanced merges.‚Äù He concluded that ‚Äúwithout the
[::] placeholder the MathComp sort becomes two element-
wise insertion sort.‚Äù
BFT in Flocq: In this mutant, false is changed to true
in the following function:
Definition shr_1 mrs :=
let ‚Äô(Build_shr_record m r s) := mrs in
let s := orb r s in
match mwith
| Zneg (xO p) ‚áí
Build_shr_record (Zneg p) false sAlthough there are several lemmas about shr_1 below the
deÔ¨Ånition, none of them touch this particular match case. Infact, there are no lemmas at all about Zneg (negative integer)
cases of shr_1 . This indicates that Zneg cases in shr_1
are unused elsewhere, and we found that they are actually
assumed away implicitly by guards in lemmas.
Discussion . In addition to the live mutants, we also analyzed
two killed mutants from every pr oject by sampling uniformly
at random; all were killed by a nearby proof (same Ô¨Åle).PrettyParsing and TLC have the lowest mutation scores of
all projects; 83.33% and 76.88%, respectively. We expected
the utility libraries (Coq-std++, TLC, and StructTact) to have
relatively low scores, due to the greater number of functions
and datatypes than in more focused projects.
The relatively high score of Coq-std++, despite its size
in terms of LOC, may indicate that most deÔ¨Ånitions are
extensively speciÔ¨Åed. To corroborate this, the main author
of Coq-std++ emphasized in personal communication that he
consistently proves several lemmas about each new deÔ¨Ånition
added to the library. The main author of TLC explained in
personal communication that, in contrast to Coq-std++, key
lemmas about TLC deÔ¨Ånitions are sometimes placed in other
projects for reasons of convenience. The relatively low score
of PrettyParsing likely stems from that its main theorem, that
deserializing serialized ‚ÄúprettiÔ¨Åed‚Äù data gives correct results,

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE VII: Number of DeÔ¨Ånitions Found by Dependency
Tools With Various Parameters.
Project
grep
 defusage
Total
=1>1
=0‚â§5‚â§10
ATBR
 115 1662
 443 2266 2544
 2760
FCSL PCM
 42 527
 82 464 532
 585
Flocq
 26 221
 32 187 229
 257
Huffman
 48 2
 76 3 8 0
 90
MathComp
 1054 4946
 804 4616 5397
 6051
PrettyParsing
 3 138
 16 120 139
 151
Bin. Rat. Numbers
 21 234
 43 290 329
 379
Quicksort Compl.
 11 255
 30 243 275
 296
Stalmarck
 6 264
 37 229 271
 304
Coq-std++
 193 645
 134 664 789
 869
StructTact
 24 5
 15 32 44
 47
TLC
 41 863
 94 765 850
 956
does not take into account most details on how prettiÔ¨Åcation
is done (through functions modiÔ¨Åed by live mutants).
4) RQ4: Comparison to Dependency Analysis: As men-
tioned in Section II-C, dependency analysis is used by proof
engineers to analyze their veriÔ¨Åcation projects, and may high-
light some unused deÔ¨Ånitions similar to those we labeled
DanglingDef. To enable comparing mutation proving with
dependency analysis, we used the Coq dpdgraph plugin [23]
to obtain, for each project, (1) a dependency graph of all
deÔ¨Ånitions and lemmas, and (2) a list of the names of all
deÔ¨Ånitions. We also extended dpdgraph to produce a tool
dubbed defusage that counts edges todeÔ¨Ånitions in graphs.
As a simple baseline, we used grep to record the number
of matches for each deÔ¨Ånition in each project‚Äôs .vÔ¨Åles. The
Ô¨Årst three columns in Table VII show the project name and
number of deÔ¨Ånitions that had exactly one and more than one
match, respectively, with grep . These can be compared to
those in the last column, which show the total number of
deÔ¨Ånitions. As a more robust alternative, we used defusage
on the dependency graph of each project, with three thresholds
in terms of number of incoming edges: 0 (unused), 5, and
10. Columns four to six in Table VII show the number of
deÔ¨Ånitions at or below each threshold for all projects.
The large discrepancies between the second and fourth
columns of Table VII indicate that the grep baseline is
both unsound and incomplete; for some projects such as
ATBR, it Ô¨Ånds only a fraction of all unused deÔ¨Ånitions, while
for, e.g., MathComp, it Ô¨Ånds too many unused deÔ¨Ånitions.
More importantly, none of the deÔ¨Ånitions changed by the
live mutants we manually analyzed were included among the
deÔ¨Ånitions in the second column ( grep =1). We conclude
that the grep baseline is unusable for Ô¨Ånding incompletely
speciÔ¨Åed functions and datatypes.
While defusage produces sound and complete lists of
unused deÔ¨Ånitions, the lists are typically long, and contain
a large percentage of all deÔ¨Ånitions even with threshold 0
(e.g., for MathComp), making it hard to apply in practice.
Among deÔ¨Ånitions changed by the l ive mutants we labeled
with UnderspeciÔ¨ÅedDef and DanglingDef, only 12 out of 63,
all labeled DanglingDef, are found among those in columnfour ( =0). We conclude that mutation proving Ô¨Ånds many
more fundamental Ô¨Çaws in Coq veriÔ¨Åcation projects than
dependency analysis, and does so in a more informative,
systematic, and less noisy way.
VI. T HREATS TO VALIDITY
External . Our results may not generalize to all Coq projects.
To mitigate this threat, we chose popular projects that differ
in size, number of proofs, and proof checking time. As our
infrastructure builds on Coq 8.9, we could only use projects
that work with this Coq version. We report results for a single
hardware platform, and results may differ if experiments are
run elsewhere. We ran all our experiments on two platforms,
but we reported results only for one of them (more modern)due to space limitations. Although absolute numbers differ
across platforms, our conclusions remain unchanged. We only
analyzed a subset of killed and live mutants in our qualitative
study. Our Ô¨Åndings could differ if we had inspected a different
set or more mutants. We mitigate this threat by systematically
sampling mutants for inspection.
Internal . Our implementation of the tool and/or scripts may
have bugs. To mitigate this th reat, we performed extensive
unit testing of our code. We also checked that results were thesame across modes and that execution time differences were
negligible across several runs. Finally, during our qualitative
analysis, we validated the outcome of each mutant we studied.
Construct . Our work targets only Coq. Nevertheless, many
mutation operators described in Section III-B, e.g., all opera-
tors in the Lists category, are applicable to projects using otherproof assistants such as Lean [52] and Isabelle/HOL [53].
However, more research is needed to develop an extensive
set of mutation operators and evaluate mutation proving for
other proof assistants and deductive veriÔ¨Åcation tools.
VII. L
IMITATIONS AND FUTURE WORK
Mutation operator design . We implemented and exper-
imented with a mutation operator for changing the or-
der of cases in a pattern matching expression, inspired by
Le et al. [11]. However, mutants generated by this operator
were nearly always killed immediately (stillborn), since Coq
pattern matching branches tend to be completely unambigu-
ous, and the strong type system does not permit leaving
out matching cases. This illustrates the problem of deÔ¨Åning
general operators for Gallina, as opposed to operators using the
standard library, e.g., additio n for Peano arithmetic. A highly
idiomatic Coq project may beneÔ¨Åt from using specialized
operators for the libraries it depends on.
Scope of mutation . We do not consider mutation of lemma
statements or of Ltac proof scripts. The main reason is that we
then would largely lose the analogy between mutation proving
and mutation testing, since mutation of test code is not per-
formed in the latter. Inductive predicates, which are a special
form of inductive datatypes, are arguably borderline cases,
but we included them for mutation based on their established
interpretation as cut-free higher-order Prolog programs [13].

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Equivalence and mutation scores . Mutation testing tradition-
ally uses functional equivalence of programs in its deÔ¨Ånition
of mutation score, which makes score calculation undecidable
in general and usually necessitates using heuristics to Ô¨Ålter
out equivalent mutants [54]. In contrast, this equivalence is
only one of many that may be considered when deÔ¨Åning
mutation score for Coq projects. We implemented checking
of syntactical equality at the vernacular level, which preserves
proofs but is highly discriminating. It is also possible todeÔ¨Åne and compute scores using Coq‚Äôs least discriminating
decidable notion of equivalence that always preserves proofs,
convertibility [55], or using a project-speciÔ¨Åc equivalence.
However, checking convertibility is costly, and only two of
the live mutants we labeled SemanticallyEq were convertible.
Alternative mutation approaches . While our operators are
deÔ¨Åned and applied at the level of vernacular syntax, S
ERAPI
also supports serialization of data added during the elaboration
phase [56] of type checking in Coq. Additional operators
can potentially use this information to perform sophisticated
type-preserving changes to Coq deÔ¨Ånitions. However, such
operators may intuitively no longer capture mistakes that are
made by proof engineers, which our operators aim at doing.
VIII. R ELATED WORK
Since, to our knowledge, ours is the Ô¨Årst evaluation of mu-
tation analysis for proof assistants, we contrast with mutationanalysis in similar settings and other analysis techniques.
Mutation testing of functional programs .L ee ta l .[ 1 1 ] ,[ 5 7 ]
implemented a mutation t esting framework for Haskell called
MuCheck, which applies mutation operators nondeterministi-
cally at the level of abstract syntax trees. Cheng et al. [12]
used MuCheck to evaluate different types of test coverage
for Haskell programs. DuregÀö ard [58] proposed a black-box
approach to mutation testing of Haskell code, on top of
the QuickCheck framework. The function under test must
be an instance of a speciÔ¨Åc type class that allows it to
be mutated (without modifying it in-place). Braquehais and
Runciman [59] presented a Haskell framework, FitSpec, that
uses mutation testing to measure adequacy of sets of properties
speciÔ¨Åed in property-testing frameworks such as QuickCheck.
FitSpec takes a black-box view of mutations, and uses instanceenumeration to produce mutants.
On one hand, black-box mutation can be applied in a
wider context than operator-bas ed mutation, e.g., to functions
associated with native code. On the other hand, black-box
mutation sometimes requires deÔ¨Åning explicit functions that
return mutants. While black-box mutation can be implemented
in Coq, we believe the purity of Gallina makes its advantages
modest compared to operator-based mutation.
Mutation of speciÔ¨Åcations . We took inspiration from Groce
et al. [8], who use mutation analysis to improve the process of
veriÔ¨Åcation based on model checking. Ball and Kupferman [9]
consider the concept of vacuity in veriÔ¨Åcation and testing,
which can be established through mutation of systems and
their speciÔ¨Åcations. Mutation proving is intuitively similar to,
but more general than, their notion of vacuity in softwarechecking. Efremidis et al. [60] p resented a mutation framework
for Prolog with operators reminiscent of ours.
Analysis and testing in proof assistants . Berghofer and
Nipkow [61] Ô¨Årst considered random testing to assist users ofIsabelle/HOL to specify and verify programs. Bulwahn [22]
subsequently improved the Isabelle testing facilities. A testing
framework for Coq, dubbed QuickChick, was proposed by
Paraskevopoulou et al. [26], and Lampropoulos and Pierce [10]
describe mutation testing in that framework. Blanchette and
Nipkow [24] presented a count erexample generator for Is-
abelle/HOL. Cruanes and Blanch ette [25] later presented a
general tool, Nunchaku, for counterexample generation, and
showed how to adapt it to dependent type theories like Coq‚Äôs.
Johansson [28] proposed a tool for theory exploration in Is-
abelle/HOL called Hipster, which attempts to prove interesting
facts from a given set of deÔ¨Ånitions.
Testing and generation as in QuickChick and Nunchaku can
analyze speciÔ¨Åc functions and datatypes to Ô¨Ånd problematic
inputs, but lack the connection to proofs that
MCOQhas. More-
over, the above techniques do not consider alternative ‚Äúworlds‚Äù
with different deÔ¨Ånitions, and are thus largely complementary
to mutation proving. For example, Hipster could be appliedto mutants to reveal facts that are consequences of alternative
deÔ¨Ånitions generated by
MCOQ.
IX. C ONCLUSION
We proposed mutation proving, a technique for analyzing
veriÔ¨Åcation projects that use proof assistants. We implemented
our technique for the Coq proof assistant in a tool dubbed
MCOQ.MCOQapplies a set of mutation operators to Coq def-
initions of functions and datat ypes, inspired by our experience
and operators previously deÔ¨Åned for functional programming
languages. MCOQthen checks proofs of lemmas affected by
operator application. To mak e our technique feasible in prac-
tice, we implemented several optimizations in MCOQsuch as
parallel proof checking. We applied MCOQto 12 medium and
large scale Coq projects, and recorded whether proofs passed
or failed when applying different mutation operators. We
then qualitatively analyzed the failed proofs, Ô¨Ånding several
examples of incomplete speciÔ¨Åcations. Moreover, our work
has already had signiÔ¨Åcant impact on Coq tooling, and our
tool helped to uncover a bug in Coq itself. We believe that
MCOQcan be extended in a number of ways and already be
useful for many practical tasks. We are looking forward to
see MCOQused by proof engineers for improving the quality
of their veriÔ¨Åcation projects and by researchers for evaluating
new proof engineering techniques.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their comments and
Ina Schaefer for shepherding this paper; Arthur Chargu¬¥ eraud,
Georges Gonthier, Farah Hariri , Kush Jain, Robbert Krebbers,
Pengyu Nie, Zachary Tatlock, James R. Wilcox, and Th¬¥ eo
Zimmermann for their feedback. This work was partiallysupported by the US National Science Foundation under Grant
Nos. CCF-1652517 and CCF-1704790.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] M. Papadakis, M. Kintis, J. Zhang, Y . Jia, Y . Le Traon, and M. Harman,
‚ÄúMutation testing advances: An analysis and survey,‚Äù Advances in
Computers , vol. 112, pp. 275‚Äì378, 2019.
[2] X. Leroy, ‚ÄúFormal veriÔ¨Åcation of a realistic compiler,‚Äù Commun. ACM ,
vol. 52, no. 7, pp. 107‚Äì115, 2009.
[3] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P. Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish, T. Sewell,
H. Tuch, and S. Winwood, ‚ÄúseL4: Formal veriÔ¨Åcation of an OS kernel,‚Äù
inSymposium on Operating Systems Principles , 2009, pp. 207‚Äì220.
[4] D. Woos, J. R. Wilcox, S. Anton, Z. Tatlock, M. D. Ernst, and
T. Anderson, ‚ÄúPlanning for change in a formal veriÔ¨Åcation of the Raft
consensus protocol,‚Äù in CertiÔ¨Åed Programs and Proofs , 2016, pp. 154‚Äì
165.
[5] T. Ringer, K. Palmskog, I. Sergey, M. Gligoric, and Z. Tatlock, ‚ÄúQED
at large: A survey of engineering of formally veriÔ¨Åed software,‚Äù Foun-
dations and Trends in Programming Languages , vol. 5, no. 2-3, pp.
102‚Äì281, 2019.
[6] P. Fonseca, K. Zhang, X. Wang, and A. Krishnamurthy, ‚ÄúAn empirical
study on the correctness of formally veriÔ¨Åed distributed systems,‚Äù in
European Conference on Computer Systems , 2017, pp. 328‚Äì343.
[7] X. Yang, Y . Chen, E. Eide, and J. Regehr, ‚ÄúFinding and understanding
bugs in C compilers,‚Äù in Conference on Programming Language Design
and Implementation , 2011, pp. 283‚Äì294.
[8] A. Groce, I. Ahmed, C. Jensen, P. E. McKenney, and J. Holmes, ‚ÄúHow
veriÔ¨Åed (or tested) is my code? FalsiÔ¨Åcation-driven veriÔ¨Åcation and
testing,‚Äù Automated Software Engineering , vol. 25, no. 4, pp. 917‚Äì960,
2018.
[9] T. Ball and O. Kupferman, ‚ÄúVacuity in testing,‚Äù in Tests and Proofs ,
2008, pp. 4‚Äì17.
[10] L. Lampropoulos and B. C. Pierce, ‚ÄúQuickChick Interface,‚Äù
2018. [Online]. Available: https://softwarefoundations.cis.upenn.edu/
qc-current/QuickChickInterface.html
[11] D. Le, M. A. Alipour, R. Gopinath, and A. Groce, ‚ÄúMuCheck: An ex-
tensible tool for mutation testing of Haskell programs,‚Äù in International
Symposium on Software Testing and Analysis , 2014, pp. 429‚Äì432.
[12] Y . Cheng, M. Wang, Y . Xiong, D. Hao, and L. Zhang, ‚ÄúEmpirical
evaluation of test coverage for functional programs,‚Äù in International
Conference on Software Testing, VeriÔ¨Åcation, and Validation , 2016, pp.
255‚Äì265.
[13] Y . Bertot and P. Cast¬¥ eran, Interactive Theorem Proving and Program De-
velopment: Coq‚ÄôArt: The Calculus of Inductive Constructions . Springer,
2004.
[14] Coq Team, ‚ÄúCoq manual: Syntax extensions and interpretation scopes,‚Äù
2019. [Online]. Available: https://coq.inria.fr/distrib/V8.9.0/refman/user-
extensions/syntax-extensions.html
[15] ‚Äî‚Äî, ‚ÄúCoq manual: Utilities,‚Äù 2019. [Online]. Available: https://coq.
inria.fr/distrib/V8.9.0/refman/practical-tools/utilities.html
[16] A. Celik, K. Palmskog, and M. Gligoric, ‚ÄúiCoq: Regression proof se-
lection for large-scale veriÔ¨Åcation projects,‚Äù in International Conference
on Automated Software Engineering , 2017, pp. 171‚Äì182.
[17] A. Groce, J. Holmes, D. Marinov, A. Shi, and L. Zhang, ‚ÄúAn extensible,
regular-expression-based tool for multi-language mutant generation,‚Äù in
International Conference on Software Engineering, Demo , 2018, pp. 25‚Äì
28.
[18] E. J. Gallego Arias, ‚ÄúSerAPI: Machine-Friendly, Data-Centric
Serialization for Coq,‚Äù MINES ParisTech, Tech. Rep., 2016.
[Online]. Available: https://hal-mines-paristech.archives-ouvertes.fr/hal-01384408
[19] J. McCarthy, ‚ÄúRecursive functions of symbolic expressions and their
computation by machine, part I,‚Äù Commun. ACM , vol. 3, no. 4, pp.
184‚Äì195, 1960.
[20] E. J. Gallego Arias, ‚ÄúCoq issue #9204,‚Äù 2018. [Online]. Available:
https://github.com/coq/coq/issues/9204
[21] E. Tassi, ‚ÄúCoq pull request #9206,‚Äù 2018. [Online]. Available: https://
github.com/coq/coq/pull/9206
[22] L. Bulwahn, ‚ÄúThe new Quickcheck for Isabelle: Random, exhaustive
and symbolic testing under one roof,‚Äù in CertiÔ¨Åed Programs and Proofs ,
2012, pp. 92‚Äì108.
[23] A. Pacelet and Y . Bertot, ‚Äúcoq-dpdgraph,‚Äù 2019. [Online]. Available:
https://github.com/Karmaki/coq-dpdgraph[24] J. C. Blanchette and T. Nipkow, ‚ÄúNitpick: A counterexample generator
for higher-order logic based on a relational model Ô¨Ånder,‚Äù in Interna-
tional Conference on Interactive Theorem Proving , 2010, pp. 131‚Äì146.
[25] S. Cruanes and J. C. Blanchette, ‚ÄúExtending Nunchaku to dependent
type theory,‚Äù in International Workshop on Hammers for Type Theories ,
vol. 210, 2016, pp. 3‚Äì12.
[26] Z. Paraskevopoulou, C. Hritc ¬∏u, M. D¬¥ en`es, L. Lampropoulos, and B. C.
Pierce, ‚ÄúFoundational property-based testing,‚Äù in International Confer-
ence on Interactive Theorem Proving , 2015, pp. 325‚Äì343.
[27] Z. Chen, L. O‚ÄôConnor, G. Keller, G. Klein, and G. Heiser, ‚ÄúThe
Cogent case for property-based testing,‚Äù in Workshop on Programming
Languages and Operating Systems , 2017, pp. 1‚Äì7.
[28] M. Johansson, ‚ÄúAutomated theory exploration for interactive theorem
proving,‚Äù in International Conference on Interactive Theorem Proving ,
2017, pp. 1‚Äì11.
[29] D. Delahaye, ‚ÄúA tactic language for the system Coq,‚Äù in Logic for
Programming and Automated Reasoning , 2000, pp. 85‚Äì95.
[30] OCaml Labs, ‚ÄúPPX,‚Äù 2017. [Online]. Available: http://ocamllabs.io/
doc/ppx.html
[31] E. J. Gallego Arias, B. Pin, and P. Jouvelot, ‚ÄújsCoq: Towards hybrid the-
orem proving interfaces,‚Äù in Workshop on User Interfaces for Theorem
Provers , 2017, pp. 15‚Äì27.
[32] R. A. DeMillo, R. J. Lipton, and F. G. Sayward, ‚ÄúHints on test data
selection: Help for the practicing programmer,‚Äù Computer , vol. 11, no. 4,
pp. 34‚Äì41, 1978.
[33] T. A. Budd, R. A. DeMillo, R. J. Lipton, and F. G. Sayward, ‚ÄúTheoretical
and empirical studies on using program mutation to test the functional
correctness of programs,‚Äù in Symposium on Principles of Programming
Languages , 1980, pp. 220‚Äì233.
[34] Y . Jia and M. Harman, ‚ÄúAn analysis and survey of the development of
mutation testing,‚Äù Transactions on Software Engineering , vol. 37, no. 5,
pp. 649‚Äì678, 2011.
[35] R. Just, D. Jalali, L. Inozemtseva, M. D. Ernst, R. Holmes, and G. Fraser,
‚ÄúAre mutants a valid substitute for real faults in software testing?‚Äù in
International Symposium on Foundations of Software Engineering , 2014,
pp. 654‚Äì665.
[36] M. Papadakis, D. Shin, S. Yoo, and D.-H. Bae, ‚ÄúAre mutation scores
correlated with real fault detection?: A large scale empirical study
on the relationship between mutants and real faults,‚Äù in International
Conference on Software Engineering , 2018, pp. 537‚Äì548.
[37] A. Chlipala, ‚ÄúLtac anti-patterns,‚Äù 2019. [Online]. Available: http://
adam.chlipala.net/cpdt/html/Large.html
[38] H. Coles, ‚ÄúPIT mutation testing,‚Äù 2010. [Online]. Available: http://
pitest.org
[39] R. Just, ‚ÄúThe Major mutation framework: EfÔ¨Åcient and scalable mutation
analysis for Java,‚Äù in International Symposium on Software Testing and
Analysis , 2014, pp. 433‚Äì436.
[40] R. Just, M. D. Ernst, and G. Fraser, ‚ÄúEfÔ¨Åcient mutation analysis by
propagating and partitioning infected execution states,‚Äù in International
Symposium on Software Testing and Analysis , 2014, pp. 315‚Äì326.
[41] R. Gopinath, I. Ahmed, M. A. Alipour, C. Jensen, and A. Groce,
‚ÄúMutation reduction strategies considered harmful,‚Äù Transactions on
Reliability , vol. 66, no. 3, pp. 854‚Äì874, 2017.
[42] J. Zhang, L. Zhang, M. Harman, D. Hao, Y . Jia, and L. Zhang,
‚ÄúPredictive mutation testing,‚Äù Transactions on Software Engineering ,
2018.
[43] R. Gopinath, C. Jensen, and A. Groce, ‚ÄúTopsy-Turvy: A smarter and
faster parallelization of mutation analysis,‚Äù in International Conference
on Software Engineering, Demo , 2016, pp. 740‚Äì743.
[44] B. Wang, Y . Xiong, Y . Shi, L. Zhang, and D. Hao, ‚ÄúFaster mutation
analysis via equivalence modulo states,‚Äù in International Symposium on
Software Testing and Analysis , 2017, pp. 295‚Äì306.
[45] L. Chen and L. Zhang, ‚ÄúSpeeding up mutation testing via regression test
selection: An extensive study,‚Äù in International Conference on Software
Testing, VeriÔ¨Åcation, and Validation , 2018, pp. 58‚Äì69.
[46] K. Palmskog, A. Celik, and M. Gligoric, ‚ÄúpiCoq: Parallel regression
proving for large-scale veriÔ¨Åcation projects,‚Äù in International Symposium
on Software Testing and Analysis , 2018, pp. 344‚Äì355.
[47] Y . Jia and M. Harman, ‚ÄúConstructing subtle faults using higher order
mutation testing,‚Äù in International Working Conference on Source Code
Analysis and Manipulation , 2008, pp. 249‚Äì258.
[48] E. J. Gallego Arias, ‚ÄúSerAPI: The Coq Se(xp)rialized Protocol,‚Äù 2019.
[Online]. Available: https://github.com/ejgallego/coq-serapi

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. [49] G. Gonthier and A. Mahboubi, ‚ÄúAn introduction to small scale reÔ¨Çection
in Coq,‚Äù Journal of Formalized Reasoning , vol. 3, no. 2, pp. 95‚Äì152,
2010.
[50] J. Mendez, ‚Äújsexp,‚Äù 2019. [Online]. Available: https://github.com/
julianmendez/jsexp
[51] B. Barras, C. Tankink, and E. Tassi, ‚ÄúAsynchronous processing of Coq
documents: From the kernel up to the user interface,‚Äù in International
Conference on Interactive Theorem Proving , 2015, pp. 51‚Äì66.
[52] L. de Moura, S. Kong, J. Avigad, F. van Doorn, and J. von Raumer, ‚ÄúThe
Lean theorem prover (system description),‚Äù in International Conference
on Automated Deduction , 2015, pp. 378‚Äì388.
[53] T. Nipkow, L. C. Paulson, and M. Wenzel, Isabelle/HOL ‚Äî A Proof
Assistant for Higher-Order Logic . Springer, 2002.
[54] M. Papadakis, M. Delamaro, and Y . Le Traon, ‚ÄúMitigating the effects
of equivalent mutants with mutant classiÔ¨Åcation strategies,‚Äù Science of
Computer Programming , vol. 95, pp. 298‚Äì319, 2014.
[55] Coq Team, ‚ÄúCoq manual: Conversion rules,‚Äù 2019. [Online].Available: https://coq.inria.fr/distrib/V8.9.0/refman/language/cic.html#
conversion-rules
[56] L. de Moura, J. Avigad, S. Kong, and C. Roux, ‚ÄúElaboration in
dependent type theory,‚Äù CoRR , vol. abs/1505.04324, 2015.
[57] D. Le, M. A. Alipour, R. Gopinath, and A. Groce, ‚ÄúMutation testing
of functional programming languages,‚Äù Oregon State University, Tech.
Rep., 2014.
[58] J. DuregÀö ard, ‚ÄúAutomating black-box property based testing,‚Äù Ph.D.
dissertation, Chalmers University of Technology, 2016.
[59] R. Braquehais and C. Runciman, ‚ÄúFitSpec: ReÔ¨Åning property sets for
functional testing,‚Äù in Haskell Symposium , 2016, pp. 1‚Äì12.
[60] A. Efremidis, J. Schmidt, S. Krings, and P. K¬® orner, ‚ÄúMeasuring cov-
erage of Prolog programs using mutation testing,‚Äù in Functional and
Constraint Logic Programming , 2019, pp. 39‚Äì55.
[61] S. Berghofer and T. Nipkow, ‚ÄúRandom testing in Isabelle/HOL,‚Äù in
International Conference on Software Engineering and Formal Methods ,
2004, pp. 230‚Äì239.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. 