  
 
 
 Adaptively Generat ing High Quality Fixes for Atomicity Violations  
Yan Cai † 
State Key Laboratory of Computer 
Science, Institute of Software, Chinese 
Acad emy of Sciences, Beijing, China  
ycai.mail@gmail.com  Lingwei Cao  
State Key Laboratory of Computer Science, Institute of 
Software, Chinese Academy of Sciences, and  
University of Chinese Academy of Sciences,  
Beijing, China  
lingweicao@gmail.com  Jing Zhao  
School of Computer Science and 
Technology, Harbin Engineering 
University, Harbin, China  
jingzhao.duke @gmail.com  
 
ABSTRACT  
It is difficult to fix a tomicity violations  correctly . Existing gate 
lock algorithm  (GLA) simply inserts gate locks to serializ e execu-
tions , which may introduce performance bugs and deadlocks . 
Synthesized c ontext -aware gate locks (by Grail ) require complex 
source code synthesis . We propose Fixer  to adaptive ly fix ato-
micity violations. It firstly analyses  the lock acquisitions of a n 
atomicity violation . Then  it either adjust s the existing lock scope 
or insert s a gate lock.  The former addresses cases where some 
locks are used but fail to provide atomic  accesses . For the latter, it 
infers the visibility  (being global or a field of a class/struct)  of the 
gate lock such that the lock only protects related accesses. For 
both cases, Fixer  further eliminates new lock orders to avoid 
introducing deadlocks . Of course, Fixer  can produce both kinds 
of fix es on atomicity violations with locks. The experimental re-
sults  on 15 previously used atomicity violations  show that : Fixer  
correctly  fixed all 15 atomicity violations with out introducing 
deadlocks.  However, GLA and Grail  both introduced 5 deadlocks . 
HFix  (that only targets on fixing certain types of atomicity viola-
tions) only fixed 2 atomicity violations  and introduced 4 dead-
locks . Fixer  also provide s an alternative way to insert gate locks 
(by inserting gate locks with proper  visibility) considering  fix 
acceptance .  
CCS CONCEPTS  
• Software and its engineering ➝ Software testing and de-
bugging • Theory of computation ➝Program verification.  
KEYWORDS  
Atomicity violations, fix, repair, concurrency bugs, deadlock , 
multithreaded program, lock order  
ACM Reference format:  
Yan Cai, L ingwei  Cao, and J ing Zhao . 2017. Adaptively Generat-
ing High Quality Fixes for Atomicity Violations . In Proceedings of 
11th Joint Meeting of the European Software Engineering Confer-
ence and the A CM SIGSOFT  Symposium on the Foundations of 
Software Engineering , Paderborn, Germany , September  4-8 2017 (ESEC/FSE'17 ), 12 pages.  http://dx.doi.org/10.1145/3106237.3106239  
1. INTRODUCTION  
Concurrency bugs widely exist in multithreaded programs [3][10] 
[19][22][25][30][32][38][48][57]. They are difficult to detect  and 
to reproduce [8][47][53][60], as well as  to correctly fix  [29].  
Manual bug fixing not only takes a long time [22] but also is 
error -prone [58]. Recently, automated  bug fixing  becomes  popu-
lar [9][14][15][16][28][36][40][43]. However,  almost all existing 
techniques on fixing concurrency bugs insert new locks (known 
as gate locks)  statically or dynamically  to serialize all executions 
of thread s involved in a concurrency bug , including AFix  [22][23], 
Axis [34], Grail  [37], Gadara  [51], and [41]. As the i nserted gate 
locks prevent two or more threads from executing  concurrently , 
the original  incorrect thread interleaving is eliminated.  We refer 
to the techniques that insert  gate locks as Gate Lock Algorithms  
(GLA). However, introducing gate locks may intro duce perfor-
mance bugs [21] as they always serialize threads of the targeted 
concurrency bugs. To solve it, Grail  inserts synthesized gate locks: 
it maps  the hash values of the variables from the concurrency 
bugs to unique gate locks. However, the synthesized gate locks 
may sometimes reduce fix acceptance .  
Besides , introducing gate locks  (e.g., GLA) or modifying lock 
scopes (e.g., HFix  [35]) may introduce various deadlocks [34] 
[37][41]. This is common  even for manual bug fixing (e.g.,  16.4% 
incorrect fix es indeed introduce d new deadlocks  [58]). If dead-
locks are introduced,  Axis [34] further iteratively fixes these in-
troduced deadlock s by inserting  more gate locks . Grail  [37] im-
proves AFix  and Axis by adopt ing Petri -net analysis to avoid 
introduc ing deadlocks [51]. However,  Grail  is limited to analyse  
two threads  only [37]. Hence, Grail  fails to avoid introducing 
deadlocks involving other threads out of the targeted concurrency 
bugs [6]. HFix  [35] targets on fixing a subset of atomicity viola-
tions by modifying lock scopes. It may also introduce perfor-
mance issues.  
A recent  work named  DFixer  [6] introduces lo ck pre -
acquisitions to fix deadlocks. As deadlocks involve  high-level lock 
acquisitions, it is possible to avoid introducing deadlocks by elim-
inating new lock orders [6]. However, atomicity violations in-
volve low l evel memory accesses.  They may involve lock acquisi-
tions  protecting some of their accesses  or may involve no lock. In 
the latter case, gate locks might be necessary; however, in the 
former case, gate locks together with existing lock acquisitions  
may form  deadlocks. Hence, it is more difficult to correctly fix 
atomicity violations.  Hence , many existing techniques  differenti-
ate concurrency bugs as deadlock and non -deadlock bugs 
[38][42][49][61] as they require different techniques to detect and 
to fix.  † Corresponding author.  
Permission to make digital or hard copies of all or part of this work for personal or 
classroom use is granted without fee provided that  copies are not made or distributed 
for profit or commercial advantage and that copies bear this notice and the full 
citation on the first page. Copyrights for components of this work owned by others 
than the author(s) must be honored. Abstracting with cre dit is permitted. To copy 
otherwise, or republish, to post on servers or to redistribute to lists, requires prior 
specific permission and/or a fee. Request permissions from Permissions@acm.org.  
ESEC/FSE'17, September 04 -08, 2017, Paderborn, Germany  
© 2017 Copyright is held by the owner/author(s). Publication rights licensed to ACM.  
ACM ISBN 978 -1-4503-5105-8/17/09…$15.00  
http://dx.doi.org/10.1145/3106237.3106239  
303 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
In this paper, we focus on atomicity violations. An atomicity 
violation occurs if an expected atomic  set of memory accesses 
fails to be atomic [38][52]. For example , Figure 1(a) shows an 
atomicity violation: two accesses  to a pointer p from thread t1 can 
be interleaved by a write access from thread t2 (as indicated by 
two solid arrows) , resulting in a NPE error ( NULL Pointer Excep-
tion). To fix such atomicity violation s, existing works may intro-
duce various problems ( as discussed above, also see Section 2).  
We propose an ad aptive approach to fix atomicity violations , 
known as AlphaFixer  or Fixer  for short.  Given an atomicity v io-
lation, Fixer  firstly identif ies all involved lock acquisitions  in it. 
If most of the accesses of the atomicity violation are protected by 
the same lock, Fixer  then tries to fix it by either extending an 
existing lock scope or combining two existing lock scopes  to pro-
vide an atomic region to put all accesses under the protection of 
the same lock. Otherwise, Fixer  inserts a gate lock to fix it. In 
the latter  case, Fixer  further infer s the visibility1 of the gate lock 
in order to exactly protect the related accesses that may be in-
volved  in the atomicity violations. To guarantee a deadlock -free 
fix, Fixer  conservatively restricts its lock scope extension or 
combi nation into three cases (see Section 3). If necessary, Fixer  
adopts multiple lock acquisitions (i.e., to acquire multiple locks) at 
a time to eliminate new lock orders.   
We have implemented Fixer  for C/C++ programs and evalu-
ated it on 15 atomicity violations. We compared Fixer  with 
GLA, Grail , and HFix  where HFix  is designed to fix certain types 
of concurrency bugs.  The evaluation is on the following three 
aspects: correctness2, performance  and code readability. For per-
formance, we followed the approach [37] for comparison purpose . 
The experiment result s show that : (1) Fixer  fixed all 15 atomicity 
violations correctly without introducing any deadlock . However, 
both GLA  and Grail  introduced 5 deadlocks ; HFix  was only ap-
plicable to fix 6 atomicity violations but introduced 4 deadlocks . 
(2) Fixer  only incurred 21.1 % overhead  on average ; however,  
GLA , Grail , and HFix  incurred a significantly larger overhead : 
120.2%, 82.9%  and 32.5% , respectively . (3) Fixer  also provided a 
new way to insert gate lock considering the visibility of the vari-
ables in the given atomicity violation, which is an alternative way 
to improve fix acceptance . The main contributions of this paper 
are as follows:  
 It proposes a  new strategy Fixer  to adap tively fix atomici-
ty violations  by producing  more effective and  efficien t fix-
es. Fixer  can insert gate locks to fix atomicity violation s. 
However, it is able to infer the visibility of the gate  lock to 
provide an alternative way to improve the acceptance of 
fixes.  
 We have implemented a prototype tool to evaluate Fixer  
(http://l cs.ios.ac.cn/~yancai/alphafixer ). The experiment re-
sults demonstrate  the effectiveness and efficiency  of Fixer  
compar ed with existing works .  
                                                                 1 In this paper, the visibility of a variable means that whether it is a global  
variable or a class/struct field. For the latter case, a variable is accessed 
based on an instance of its class/struct . 
2 To fix concurrency bugs, thread inter leaving space is usually reduced to 
be a subset of that before fixing if no deadlock is introduc ed. Therefore, 
the correctness here refers to whether any deadlock is introduced.  2. BACKGROUND  AND MOTIVATIONS  
2.1 Preliminaries  
We focus on two kinds of events in multithreaded programs: 
Memory accesses  and Lock operations . The later include s lock ac-
quisition s acq(m), tryAc q(m), acq(m, n) and lock release rel(m). 
Note that (1) acq(m) blocks its executing thread if  lock m is ac-
quired by another thread;  but tryAcq (m) does not; (2) acq(m, n) 
indicates that a thread tries to acquire two lock s at the same time.  
If a thread firstly acquires a lock m and then acquires a nother 
lock n before releasing lock m, there is a lock order  from lock m to 
lock n, denoted by m ↝ n. If another lock order  exists  n ↝ m (or n 
↝ … ↝  m for multiple threads), we say it is a reversed lock order  of 
the lock order m ↝ n. There is a special case that, if a thread ac-
quires two locks m and n at the same time via acq(m, n), then 
there is no lock order produ ced between the two locks . This is 
because a thread performing acq(m, n) immediately releases any 
acquired  lock if one of them cannot be acquired [6]. 
A (resource)  deadlock  occurs if a lock order and its reversed 
lock order occurs at the same time [7][25]. But, the absence of a 
lock order  and its reversed lock order indicates no deadlock on 
these lo cks.  
2.2 Motivations  
GLA fixes an atomicity violation  by inserting a gate lock  to seri-
alize the executions of the involved threads . It could reduce the 
parallelism of executions from different threads  due to over syn-
chronization  (known as performance bugs [21]) and may also 
introduce deadlocks . Grail  may improve performance but may 
produce fixes with low acceptance  due to  its lock synthesis . 
Overall , these works focus on th e correctness of their fixes but 
seldom  consider the q uality (e.g.,  whether the fix code is 
acceptable  and understandable  to developers ) of their fixes . This 
point is extremely  important when a program is developed by 
many developers and is developed continually to produce 
different versions (e.g., MySQL). We show these limitations in the 
next two subsections  with examples . 
2.2.1 Performance and Acceptance  of Fixes . Atomicity vi ola-
tion AV 1: Figure 2 shows an atomicity violation AV1. It involves 
two threads (t1 and t2) and  two variables  (buf->output and buf-
>outcnt). The variable buf->output  is a fix ed size buffer and the 
variable buf->outcnt  points to the end of buf->output . Please ig-
nore the four highlighted lines starting with "+" (i.e., lines 3, 7, 11, 
and 15) for now. The function ap_bufferred_log_writer () buffer s 
characters  into buf->output  and then increments buf->outcnt . 
However, these two operations are not protected by any lock. As 
a result, if two or more threads concurrently call the function and 
the executions of two threads could be interleaved  as what the 
(a)Thread t2
p=NULL;Thread t1
p = new Obj();
p.test ();
(b)Thread t2
+ acq(G)
p=NULL ;
+ rel(G)Thread t1
+ acq(G)
p = new Obj();
p.test ();
+ rel(G) 
Figure 1. An atomicity violation (a) and its fix by GLA  (b). 
304  
 
Adaptively Generating High Quality Fixes for Atomicity Violations  ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  
 
 two solid arrows indicate, an atomicity violation will occur, cor-
rupting both buf->output  and buf->outcnt .  
Atomicity violation AV 2: Figure 3 shows an atomicity viola-
tion AV2, involving one variable gCur rScript . The atomicity viola-
tion occurs when thread t2 writes a NULL value to gCurrScript  in 
between the write to gCurrScript  (at line 4) and the invocation of 
compile () on gCurrScript  (at line 10) by thread t1, as indicated by 
the two solid arrows. Although t he original program contains a 
lock l (at lines 1, 6, 8, 13, 14, 20) to protect accesses to gCurrScript , 
this protection is only on the individual access. It fails to provide 
an atomic region for two accesses to gCurrScript  from th read t1.  
To fix AV1, GLA inserts a lock G to serialize two threads. This 
fix is shown in lines starting with " +" (i.e., lines 3, 7, 11, and 15). 
To fix AV2, GLA inserts a lock G (at lines 3, 11, 16, and 18) to 
prevent the write to gCurrScript  (at line 17) from occurring in 
between the two accesses by thread t1.  
GLA may introduce high runtime overhead. For example, on 
AV1, if the variable bufs of two threads are different, then the two 
variables buf->output  of two threads are also different . Hence, no 
atomicity violation may occur  and the two threads  can be execut-
ed concurrently . However, after fixed by GLA, the two threads 
always execute sequentially due to the unique global gate lock  G, 
incurring runtime overhead.  
The latest work Grail  [37] follows GLA, but synthesizes a 
context -aware gate lock G according to all variables of the target-
ed atomicity violation as follows:  
G = contextL (hash(v1), hash (v2) …), where v1, v2, … are variables 
from  the atomicity violation and the function contextL (…) returns 
a unique lock corresponding to the inputs (i.e., the hash values of 
all variables). Thus, if the actual variables of two threads are dif-
ferent, Grail  computes two different gate locks. Hence, the two 
threads are able to execute concurrently. In this way, Grail  does 
not reduce parallelism if no atomicity violation may occur. Figure 
4 shows the two gate locks generated by Grail  to fix AV1 and AV2, 
respectively. However, there are three main limitations of Grail .  
Firstly, the readability of fix by Grail  might be  worse than that 
by GLA. For example, on fixing AV1 and AV2, the inserted lock 
acquisition by GLA is simply " acq(G)" where the lock G is global-
ly defined once. Whereas , the gate lock inserted by Grail  are: "G = 
contexL (hash(&(buf->outcnt )), hash (&(buf->output ))); acq(G);" and 
"G = contextL (hash(&(gCurrScript ))); acq(G);", respectively. These  
fixes may be difficult for developers to understand.  
Secondly, a synthesized context -aware lock may not be always 
required. If an atomicity violation involves only glo bal variables (e.g., on AV2), a global lock is enough. In this case, even if the gate 
lock is produced by Grail , the produced gate locks will always be 
the same. Otherwise, if an a tomicity violation involves class ( in-
cluding  struct ) level variables, a  gate lock of the same class level 
will be  enough (e.g., on AV1).  
Thirdly, the implementation of contextL (…) might be  complex. 
For example, the original implementation [37] uses String .intern () 
function provided by native code of JDK. This implementation 
maintains a HashTable  structure and a lock to protect operations 
on it. On each call to String .intern (), the HashTable  is iterated to 
search for a unique String object (which is taken as a lock in Java, 
see the function JVM_InternString  in jvm.cpp ). For C/C++, a simi-
lar pair of map/table and lock is also require d.   
Considering above discussions, the fix es generated by Grail  
may have a low acceptan ce to developers. Of course, different 
developers may hold differ ent views on what kind of fix es they 
may prefer to accept.   
2.2.2 Introduc ing Deadlocks . On AV1, GLA inserts a lock G to 
serialize two threads. This is a correct fix. However, on AV2, after 
GLA inserts a lock, it also introduces three  new lock orders:  two l 
↝ G (i.e., from line 14 to line 16 and from line 1 to line 3) and  one 
G ↝ l (from line 3 to line 8), as shown in three dotted arrows . The 
two lock orders  l ↝ G (i.e., from line 14 to line 16) and G ↝ l (from 
line 3 to line 8)  form  a deadlock. (Actually, another deadlock is 
introduced from two locks orders l ↝ G (from line 1 to line 3) and 
G ↝ l (from line 3 to line 8) if they can be formed by multiple 
threads  at the same time .) 
Grail  further relies on Petri -net analysis to prevent introduc-
ing deadlocks , which is  limited to two threads only [37].  
For some special atomicity violations like AV2 where the same  
lock (e.g., lock l) is used to protect part of accesses, a recent work 
HFix  [35] suggests a fix : mov e either an acquisition or a release 
Thread t1
1.ap_buffered_log_writer (...) 
2.{
3.+acq(G);
4. idx= buf->outcnt ;
5. s = &buf->output [idx];
6. buf->outcnt += len;
7.+rel(G);
8.} Thread t2
9.ap_buffered_log_writer (...) 
10.{
11.+acq(G);
12. idx= buf->outcnt ;
13. s= &buf->output [idx];
14. buf->outcnt += len;
15.+rel(G);
16.} struct buffered_log {
apr_size_t outcnt ;    
char outbuf […];
}; 
Figure 2. An atomicity violation AV 1 from apache  with 
bugID=25520, and a fix to it by GLA . 
Thread t1
1. acq(l);
2. …
3.+acq(G);
4. gCurrScript = …;
5. …
6. rel(l);
7. …
8. acq(l);
9. …
10. gCurrScript ->compile ();
11.+rel(G);
12. …
13. rel(l);Thread t2
14. acq(l);
15. …
16.+acq(G);
17. gCurrScript = NULL ;
18.+rel(G);
19. …
20. rel(l); 
Figure 3. An atomicity violation AV 2 from mozilla  [59] and its 
fix by GLA . 
Thread t2
acq(l);
…
+G = contextL (
hash (&(gCurrScript )));
+acq(G);
gCurrScript = NULL ;
+  rel(G);
…
rel(l);Thread t2
ap_buffered_log_writer (...) {
+G = contextL (
hash (&(buf->outcnt )),
hash (&(buf->output )));
+acq(G);
idx= buf->outcnt ;
s= &buf->output [idx];
buf->outcnt += len;
+rel(G);
} (a) (b)
 
Figure 4. The two gate locks genearted by Grail  to fix AV 1 (a) 
and AV 2 (b). 
305 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
statement to protect all other accesses not protected by the same 
lock. On AV2, HFix  may either move rel(l) at line 6 to a location 
right after line 10 or move acq(l) at line 8 right before line 4. 
However, t his fix actually introduces a self -deadlock as thread t1 
will acquire lock l twice where the second acquisition is blocked.  
Besides , it may still introduce other deadlocks. For example, if 
there is  a lock acquisition acq(m) between line s 4 and 1 0, a new 
lock order l ↝ m will be  introduce d. Then a deadlock is intro-
duced if another thread form s a lock order m ↝ l.  
3. OUR APPROACH   
3.1 Rationale  and Overview  
An atomicity violation involves at least three accesses to a set of 
shared variables. It is possible that these accesses are protected by 
some locks (e.g., on AV2). But it is also possible  that no lock pro-
tects the involved  accesses  (e.g., on AV1).  
Therefore, our insight is: it is not always necessary to intro-
duce new loc ks to serialize threads to fix  atomicity violation s. If 
there are already some locks protecting most of  the involved ac-
cesses, the locks could  be slightly adjusted to fix these atomicity 
violations. For example, in Figure 3, AV2 could be fixed by com-
bining the two separated locking regions (i.e., removing "rel(l);" at 
line 6 and " acq(l);" at line 8 ). By doing so, the two accesses to 
gCurrScript  from  thread t1 are fully protected by lock l; hence, the 
access at line 17 by thread t2 cannot be interleaved in between the 
two accesses. And AV2 is fixed.  
On the other hand, no lock may protect any access  from  an 
atomicity violation. In this case, a new lock is necessary. Howev-
er, when introducing a new lock, the introduced lock orders (if 
any) must be carefully handled  to avoid introducing deadlocks.  
Besides, if a new lock is required, the visibility of the l ock 
should also be carefully determined . Unlike Grail  that synthesize s 
a gate lock,  it would be better if  we could insert a lock with the 
same visibility as that of the involved variables.  
Although the first step is to adjust any existing lock protec-
tion, a gate lock  can also be inserted to fix an atomicity violation. 
It is difficult to say which fix is better. For example, if the two 
accesses of an atomicity violation are far away to each other and 
if the same lock protects the two accesses separately, th en adjust-
ing the two lock scopes may incur high runtime overhead. There-fore, if an atomicity violation can be fixed by adjusting its lock 
scopes, Fixer  further produces a second fix by inserting a gate 
lock. The second fix can also be an option to developers.  
Overall, as shown in Figure 5, Fixer firstly analyses  the given 
atomicity violation to identify all involved lock acquisitions and 
then de termine s whether to adjust the lock scope or to insert a 
gate lock.  For the latter , as a new lock is required , Fixer  infers 
the visibility of the involved variables to determine whether the 
new lock should be a global one or a class field one. Next , Fixer 
analyses  the involved locks to avoid introducing deadlocks.  
3.2 Adjust Lock Scopes to Fix Atomicity Viola-
tions 
For atomicity violations  that already involve some locks protect-
ing the accesses , they might be fixed by slightly adjusting the lock 
scope s. In this paper , we only focus on three scenarios as shown 
in Figure 6 (where a box with a lock indicates  a pair of lock acqui-
sition and release) :  
 Case A:  all accesses  (e.g., a1, a2, and a3) are separately pro-
tected by the same lock . In this case, the atomicit y violation 
could be fixed via Combination : Comb ine two separated lock 
scopes of the same lock of the corresponding thread  (i.e., 
thread t1 in Case A).  
 Case B and Case C: only part of accesses from a thread is 
protected by a lock  and other accesses from the second 
thread are all protected by the same lock. Then, the atomici-
ty violation could be fixed via Extension : Extend  the lock 
scope of the first thread to also protect the remaining access-
es from this thread  (i.e., thread t1 in Cases B and C).  
There might be other cases where the lock scope s can be 
changed  to fix atomicity violations. Our criterion is  that there  
must be the same lock protect ing at least one access of each 
thread. Hence, for other cases , we fix them by inserting gate locks 
(see the next subsection). Note  that, HFix  [35] has a similar sug-
gestion as Case B and Case C. However, HFix  does not distinguish 
Case A from Cases B  and C. Hence, on Case A , HFix  can introduce 
self-deadlocks as discussed in Section 0 (also see  our experiment 
in Section 5.3).  
Adjust lock 
scope
Generate a patchInsert a new 
lock G
Infer lock visibility: 
Avoid introducing 
deadlockYes
YesNoNo
Global, or
Class fieldAny lock 
already?
Any other 
acquisition?An atomicity 
violation 
Figure 5. An overview of our Fixer . 
Case A
Case B
Case Ca3a1
a2
a3a1
a2
a3a1
a2Thread t1 Thread t2
a3a1
a2
a3a1
a2
a3a1
a2Thread t1 Thread t2Legend      a: original lock scope
Combination
Extension
Extensiona: changed lock scope 
Figure 6. The three cases to fix certain atomicity violations 
(where the arrows also indicate the error interleaving).  
306  
 
Adaptively Generating High Quality Fixes for Atomicity Violations  ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  
 
 3.3 Introduce New Locks to Fix Atomicity Vio-
lations  
A new lock is necessary to fix an atomicity violation  via gate lock 
strategy . Unlike GLA that introduce s a global gate  lock, Fixer  
tries to introduce a context -aware  gate lock. Unlike Grail  that 
introduces a synthesized lock , Fixer  automatically infers the lock 
visibility  of the new  locks  to avoid synthesizing gate locks . As a 
result, Fixer  provides an alternative way to insert gate locks .  
3.3.1  Infer Visibility of Gate Locks . We found that, for an ato-
micity violation, the visibility of the involved variables is usually 
determined : either global variables or class field variables. Here, 
the fields refe r to the variable member of class in object -oriented 
languages (e.g., C++) or struct (e.g., C). For example, the variables 
outcnt  and output in Figure 2 are two fields of the struct buff-
ered_log ; and the variable gCurSc ript in Figure 3 is a global varia-
ble.  
Hence,  given an atomicity violation, if all its variables are 
global , an explicit global lock is enough; otherwise, if all involved  
variables are fields of the same class instance , a field lock within  
the same class  is also enough. In these two cases, even if we fol-
low Grail  to synthesize gate locks, the synthesized gate lock s are 
always the same  global lock (for the former case) or are always 
the same lock of the same class instance . Hence, there is no need 
to additionally synthesiz e gate locks  dynamically ; a unique global 
gate lock or a class level gate lock is enough.   
For single -variable atomicity violation  [38], the involved vari-
able is  deterministically a global one or a class  field. However, for 
multi -variable atomicity violations  [38], the involved variables 
may contain :  
(1) Global variables only, or 
(2) Field variables of the same class  instances, or 
(3) Both global ones and class  fields , or 
(4) Multiple fields of different class , or 
(5) Fields of the same class but differe nt class  instances.  
The first two cases can be handled in the same way as han-
dling  single -variable atomicity violations  because  all involved 
variables are either global ones or fields  of the same class in-
stance . However, t he last three cases  are more complex. To fix 
them, Fixer  simply insert s a global lock to serialize two threads. 
Admittedly , the synthesized gate locks by Grail  may perform 
better  than the global lock s theoretically . Note that, the fields of a 
class /struct  may also be global  (e.g., declared to be static ). Such 
cases can be easily handled  and hence are not discussed in this 
paper.  
3.3. 2  Insert Gate Locks . Once the visibility of a gate lock is de-
termined, it is straightforward to insert th e gate lock to serialize 
the two threads of the given atomicity violation. This step is the 
same as what GLA performs (see Figure 1(b) where the gate lock 
is the lock G).  
3.4 Avoid Intro ducing  Deadlocks  
3.4.1 Why can deadlocks be introduced?  Fixer  fixes an atomicity 
violation by either  adjusting lock scope of an existing lock or 
inserting a gate lock.  In both cases, deadlocks may be introduced. 
We discuss the two cases below.  Deadlocks may be introduced by adjusting lock scope s. Recall 
that adjusting lock scopes  consist s of either  combination  or ex-
tension. The c ombination of two separated lock scopes may in-
troduce new lock orders if, in between the two separated scopes, 
there are other l ock acquisitions. Consider the example in Figure 
7(a) where a pair of acquisition and release on lock  m exists in 
between two lock scopes on  lock l. After combining the two lock 
scopes  on lock l into one, a new lock order l ↝ m is introduced . 
Similarly, the extension of a lock scope to protect more accesses 
may also introduce new lock orders , as shown in Figure 7(b). 
Then,  for above two scenarios , deadlock s are introduced if a dif-
ferent thread  has the lock order m ↝ l, as shown in Figure 7(c).  
If a gate lock is introduced, deadlocks may also be introduced. 
We have demonstrated  this in Figure 3(b).  
To ease the presentation, w e refer to locks that are nested in 
combined or extended lock scopes  or inserted gate lock scopes  as 
inner locks  (i.e., lock m in Figure 7 and lock l at line 8 in Figure 
3); and we refer to the corresponding new lock orders a s inner 
lock orders  (i.e., l ↝ m in Figure 7 and G ↝ l in Figure 3). Similar-
ly, we refer to new lock orders from other existing locks to ad-
justed locks  or to insert ed gate locks as outer lock orders  (l ↝ G 
in Figure 3); and we refer to the former  existing  locks as outer 
locks  (lock l at line 1 in Figure 3).  
3.4.2 How to Avoid Introducing Deadlocks . For the inner lock 
orders  (e.g.,  l ↝ m or G ↝ m), if the inner locks (i.e., lock m) can 
be identified, then these lock orders can be eliminated by acquir-
ing two locks together  (i.e., acq(l, m) or acq(G, m)). This is because 
the inner locks, if any, exist in between the two accesses of one 
thread; and the two accesses usually have a short distance in term 
of source code lines. Otherw ise, if the inner locks cannot be ac-
quired together with the adjusted locks or the inserted gate locks, 
Fixer  gives up  fixing the atomicity violation .  
When  an inner lock m is acquired together with the adjusted  
lock l, it is possible that th is lock m is actually the lock l. In this 
case, a self -deadlock is introduced as the  lock will be  acquired 
twice.  However, it is difficult to statically know whether the two 
locks l and m are the same one , especially when the class/struct 
instances are involved . To solve this challenge, we change the 
property of lock m to be reentrant  (i.e., recursive  lock) because  a 
reentrant lock can be acquired and released multiple times in a 
nested manner  by the same thread . For the inserted gate lock G, 
we also set both lock G and any inner lock m to be a reentrant 
lock considering recursive function calls.  
If an inner lock (e.g., lock m in Figure 7) is acquired together 
with adjusted locks or inserted gate locks (e.g., acq(l, m) or acq(G, 
m)), to avoid introducing new lock orders, we do not remove the 
original lock acquisition (e.g., acq(m)) on inner locks. Because the 
(a)Thread t2
acq(l);
a1
acq(m);
rel(m);
a2
rel(l);Thread t1
acq(l);
a1
rel(l);
acq(m)
rel(m);
acq(l);
a2
rel(l);Thread t2
acq(l);
a1
acq(m);
rel(m);
a2
rel(l);Thread t1
acq(l);
a1
rel(l);
acq(m)
rel(m);
a2
(b)Thread t3
acq(m);
acq(l);
⋮
(c) 
Figure 7. New lock orders are introduced if lock scopes are 
adjusted.  
307 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
original lock acquisition may exist in a different function which 
can be called from a different control branch. (Otherwise, we 
have to adopt ad -hoc synchronization to fix program control as 
adopted in DFixer  to fix deadlocks, which is usual ly harmful [56].)  
For the second type of outer lock orders introduced due to in-
serted  gate locks  (i.e., k ↝ G where lock k is acquired before the 
acquisition on lock G), if all inner lock orders  are elimina ted (i.e., 
G ↝ m), no deadlock will be introduced. This is because outer 
lock orders alone without their reversed lock orders cannot form 
any deadlock s.  
However, for the second type of outer lock orders  introduced 
by lock adjusting  (i.e., k ↝ l where lock k is acquired before the 
acquisition on lock l), even if we eliminate their reversed lock 
order  l ↝ k, a third thread may still form their reversed lock or-
ders l ↝ k. This is because, unlike inserted gate locks, these locks 
already  exist before  fixing. In this case, we give up fixing such  
atomicity violation s by adjusting locks; instead, we try to fix it by 
introducing a gate lock, as shown in Figure 5. Of course, in this 
case, the fix ing approach via adjusting locks can be a suggestion.   
Besides  lock acquisitions and releases, other additional lock 
synchronizations (e.g., wait(l) and notify (l)) may be involved in 
one or more threads of atomicity violations. Such cases are com-
plicated . Therefore, we only consider one case where a lock is 
adjusted  to fix an atomicity violation,  and the additional synchro-
nization (s) is with in the lock scope  (protected r egion)  of the ad-
justed lock before and  after adjusting . In this case, no new lock 
order is introduced. For other cases, Fixer  gives up its fixing.  
Limitations . Fixer  may fail to fix an atomicity violation  in 
two cases: (1) there is other inner lock in between the two access-
es of a thread and such lock(s) cannot be acquired together with 
the inserted  gate lock or the adjusted lock; and (2) synchroniza-
tions except lock acquisitions and releases will be contained  with-
in the adjusted lock scope or the sc ope of the inserted gate locks  
except the case discussed in the last paragraph . To guarantee a 
theoretical correctness, Fixer  gives up fixing such atomicity 
violation s.  
3.4.3 Guarantee of Fixer . Fixer  does not guarantee to fix all 
atomicity violations as discus sed in the last subsection. However, 
if it generates a fix, it guarantees to fix the atomicity violation 
without introducing deadlocks  as Theorem 1 .  
Theorem 1.  Given an atomicity violation AV, if Fixer  generates a 
fix, it does not introduce  any deadlock.  
Proof Sketch.  We prove the theorem via three cases showing 
that the fix does not introduce resource deadlocks, communica-
tion deadlocks, and self -deadlocks , respectively . And we mainly 
prove the scenarios  where a gate lock is inserted . The scenarios  
where a lock is adjusted can be proved similarly.   
A) Suppose that Fixer  introduced a gate lock G to fix AV. If 
no new lock order is introduced , there is no way for Fixer  to 
introduce a resource dead lock. Now, s uppose that there are other 
locks within the scope of gate lock acquisitions, these locks are 
acquired together with the gate lock G by following Fixer  ap-
proach (see the first paragraph of Section 0). (Note, if any inner 
lock cannot be acquired together with gate lock, Fixer  does not 
produce any fix, see the last paragraph of Section 0.) Hence, any 
potential inner lock orders are eliminat ed. Next, s uppose that 
some outer  lock orders from an outer lock is introduced, say k ↝ G where k is an outer lock. However, as no any inner lock order 
(e.g., G ↝l where the lock l may be the lock k) is introduced. 
Hence , no reversed lock order of the  introduced outer lock order  
k ↝G is introduced. Therefore, no resource deadlock is intro-
duced by Fixer .  
B) If there are  other synchronizations (e.g., wait() and notify )), 
by following  Fixer  approach (see the 6th paragraph of Section 0), 
Fixer  only adjusts lock scope if : before and after adjusting, the 
synchronizations are always  within the original scope . That is, 
after adjusting , the lock orders remain the same as that before 
adjusting the lock scope. Hence, Fixer  does not block any  com-
munication (i.e., not in troduce communication deadlocks ).  
C) If any lock is inserted or adjusted, Fixer  changes it to be 
re-entrant lock (see the 1st paragraph of Section 0). This enables a 
thread to acquire the same lock multiple time s without blocking 
itself. Hence, Fixer  does not introduce self -deadlocks.  
Based on the above analysis , Theorem 1 is proved. □ 
3.5 Our Approach on Examples   
The fix to AV1 by Fixer  is shown in Figure 8(a) (where we only 
show one thread as two threads share the same code lines). On 
AV1, no lock is found . Then,  Fixer  introduces a gate lock G to fix 
it. This fix is the same as GLA. However, Fixer  firstly inserts a 
lock G to the struct buffered_log  before insert ing lock acquisition 
and release acq(buf->G) and rel(buf->G). This brings an alterna-
tive fix code lines besides that by Grail  (see Figure 4).  
To fix AV2, Fixer  combines the two lock scopes of lock l for 
thread t1 as shown in Figure 8(b). This fix is obviously  simple and 
different from that by GLA and Grail . Besides, on AV2, no dead-
lock is introduced by Fixer ; whereas, HFix  introduces a self -
deadlock (see the last paragraph of Section  0).  
3.6 Fix Program Control  Flow  
Like other  approaches, Fixer  also needs to fix program cont rol 
flows, which is similar to existing works [6][22][23]. For example, 
when an acquisition acq(G) is inserted, its corresponding release 
rel(G) should be inserted at each exit branch  containing the in-
serted acq(G).  
ap_buffered_log_writer (...){
+  acq(buf->G);
idx= buf->outcnt ;
s= &buf->output [idx];
buf->outcnt += len;
+  rel(buf->G);
} struct buffered_log {
apr_size_t outcnt ;    
char outbuf […];
+Lock G ;
}
(b) How Fixer fixes AV2. (a) How Fixer fixes AV1.Thread t1
acq(l);
…
gCurrScript = aspt;
…
-rel(l);  
…
-acq(l);
…
gCurrScript
->compile ();  
…
rel(l);Thread t2
acq(l);
…
gCurrScript
= NULL ;
…
rel(l); 
Figure 8. One way to fix AV 1 and AV 2 by Fixer . (On AV 1, we 
only show one thread as two threads share the same code lines. 
On AV 2, the fix is to combine two separated lock scope, 
corresponding to Case A  in Figure 6. The second fix to AV 2 by 
Fixer  (i.e., inserting a gate lock ) is omitted.)  
308  
 
Adaptively Generating High Quality Fixes for Atomicity Violations  ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  
 
 4. USER STUDY OF GRAIL AND FIXER  
This section presents our user study on the fix es to the atomicity 
violations AV1 and AV2. We decided to conduct the user studies 
on these two atomicity violations as they are representatives 
among all benchmarks in our experiment (see Section 5). The 
questionnaire firstly offered a brief introduction to atomicity 
violation s. The second part s were the two original pieces of code 
with two atomicity violations and two short description s on how 
they could occur, as well as the two fixe s of Grail  and Fixer  
(which were referred to as Tool1  and Tool2 , respectively). We 
designed four selection -questions: between Tool1  and Tool2, (1) 
which fix is more understandable (Unders tandabil ity), (2) which 
fix is more readable (Readability), (3) which fix may incur larger 
overhead; and (4) which fix do you prefer ? For each question, we 
offered an " Any" option to indicat e an equal or an unclear prefer-
ence. We also requested  participants to fill their occupations and 
any additional comments. Our questionnaire  was distributed via 
the social network community WeChat  (see our tool website) . 
There was no time limit  for participants to answer the questions 
before we collected the results at the paper submitting time . 
Totally, there were  40 participants : 3 from Mathematics, 4 
from Finance , 33 from IT companies. Table 1 presents the results. 
From the table, it shows  that, more than 85%  participants held a 
preference  on Fixer  other than on Grail  in terms of und er-
standability and readability. On overhead, more than 67% partici-
pants regarded that Grail  incurs larger overhead . Finally , Fixer  
was well accepted  (preferred ) by more than 80% participants .  
Among the 40 participants , only 8  of them filled their com-
ments; and 7 comments obviously pointed out that Tool2  (i.e., 
Fixer ) should  be more readable, straightforward,  adaptive and 
simpler, (e.g., different fix for different variable visibility ). The 
remaining one did not point ou t whic h one is better .  
5. EXPERIMENT  
5.1 Benchmarks  
We selected a set of  real-world  benchmark s [2][59] including 20 
benchmarks. w e excluded 6 of them: 1 deadlock , 1 duplicated bug 
(i.e., cherokee ), 3 order violations, and 1 atomicity violation in-
volving  Java code . Including our  two motivating examples ( where 
AV1 is from apache 25520), there are 15 benchmarks.  Some bench-
marks can not be correctly compiled in our experiment environ-
ment . We follow ed an existing work  [28] to extract the source 
code containing atomicity violations. All these atomicity viola-
tions are listed  in Table 3 including whether we used the original 
benchmarks or the extracted one s (under the column "Original") .  
5.2 Implementation and Experimental  Setup  
We have implemented Fixer , GLA (i.e., the AFix [22] algorithm)  
Grail , and HFix  within  LLVM 3.6 framework  [1][31]. LLVM IR 
does not support class /struct information . We modified  Clang 
frontend to generate the information  for Fixer  to infer lock visi-
bility . Grail  synthesizes context -aware gate locks  which is based 
on String.intern () from Java library [37]. We extracted the 
OpenJDK impleme ntation of String.intern (). After applying the four  techniques to all benchmarks, we ran 
each fixed p rogram by each technique  for 1 ,000 times and collect-
ed th e results . During this 1 ,000 runs, we inserted a set of random 
sleep before and after each lock acquisition of the fixed programs  
to amplify the probabilities for any introduced deadlock to occur . 
We also ran them for 1 ,000 additional times without sleep t o col-
lect their execution time  except on those where deadlocks fre-
quently occurred  after fixing .  
To evaluate  the performance scalability of the fixed programs , 
we followed [37] to amplify the overhead introduced by each 
technique for comparison purpose . We configure d the number of 
threads  to be 2, 4, 8, 16, 32, 64, and 128.  Note that, this amplifica-
tion only applies  to execution of the code lines involved in ato-
micity violations. This is the same as the previous work  [37]. 
Our experiments were  conducted on a ThinkPad workstati on 
with a processor  i7-4710MQ , installed with Ubuntu 14.04.   
5.3 Result Analys es 
In this section, we firstly present the summary of fixing results . 
Next, we  separately compare Fixer  with HFix first, and then  
compare Fixer  with  GLA and Grail . This is because HFix  is only 
applicable to atomicity violations with some lock s by merg ing 
two lock scopes.  Among our benchmarks, only 6 out of 15 
benchmarks can be handled by HFix.  
 
5.3.1 Fixing Summary . Table 2 summarizes the fixing results 
by all four techniques on all 15 atomicity violations. Overall, both 
GLA and Grail  correctly fixed 10 (i.e., 67%) atomicity violations. 
HFix  only correctly fixed  2 (i.e., 13%) atomicity violations. Our 
Fixer  correctly fixed all 15 (i.e., 100%) atomicity violations.  
Besides, on performance  scalability testing with 128 threads, 
GLA incurred the largest  overhead : 120.2% on average , followed 
by Grail  incurring 82.9% average overhead. HFix  incurred an 
average overhead  of 32.5% . Fixer  only incurred an average over-
head of 21.1%. From the summary, Fixer  outperforms all other 
techniques  considering  both effectiveness and efficiency .  
5.3.2 Comparisons  on Effectiveness. Table 3 (A) and ( B) show  
the fixing result s. The first three columns show the benchmark 
information.  The fourth  major column  show s the fix es by Fixer . 
The table also  shows the results of Fixer  and HFix  on the 6 ato-
micity violations involving locks . In the table , "AdjL -A" means 
that Fixer  fixed the benchmark by adjusting an existing lock Table 2. Fixing summary of all techniques.  
# 
Total  #of fixed atom. violations  Avg.  overhead  
GLA Grail  HFix  Fixer  GLA  Grail HFix  Fixer  
15 10 (67%)  10 (67%)  2 (13%)  15 (100%)  120.2%  82.9%  32.5%  21.1%    Table 1. Statistics on user studies.  
  Tool1  (Grail ) Tool 2 (Fixer ) Any 
AV 1 Understandability  2.5%  87.5%  10.0%  
Readability  0.0%  90.0%  10.0%  
Larger Overhead  67.5%  12.5%  20.0%  
Preferred  Fix 5.0%  95.0%  0.0%  
AV 2 Understandability  7.5%  92.5%  0.0%  
Readability  2.5%  85.0%  12.5%  
Larger Overhead  75.0%  10.0%  15.0%  
Preferred  Fix 10.0%  82.5%  7.5%    
309 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
(AdjL ) according to Case A (as shown in Figure 6). The sub -
column " L-type" shows the lock visibility ( Global  or Field ) that 
Fixer  adjusted  or inserted. The remaining columns of Table 3 (A) 
show  (1) the number of new lock orders introduced by each tech-
nique  (in form of "outer/inner "), (2) the number of deadloc ks in-
troduced by each technique, (3) the average overhead of each 
technique at the number of threads to be 128. In the last row, we 
also show the sum mation  values or the average values for the last 
three major columns.  Table 3 (B) shows the results of Fixer , 
GLA, and Grail  on fixing all atomicity violations. Table 3 (B) can 
be read in the same way as Table 3 (A) except the fourth column 
which shows whether Fixer  inserts a Global  or a Field  gate lock. 
In Table 3, the mark s "-" under the last major column  ("Average 
overhead ") indicate that no data was collected because , for GLA, 
Grail , and HFix , after fixing, deadlock s frequently occurred  (ex-
plained below) . Note that, both kinds of fix es by Fixer  were 
listed in Table 3 for comparison purpose.  
HFix  was only applicable to 6 atomicity violations. Among 
these 6 atomicity violations, three of them fall into Case A , one of 
them falls into Case B, and the remaini ng two fall into Case C. 
From Table 3 (A), it is observe d that HFix  introduced 4 inner lock 
orders and they formed 4 self -deadlocks.    
From Table 3 (B), we observe d that both GLA and Grail  intro-
duced 20 new lock orders on 11 benchmarks; Fixer  introduced 7 
new lock orders on 5 benchmarks. However, Fixer  only intro-
duced out er lock orders but no inner lock orders ; and it  did not 
introduce any deadlock s. This is consistent with its guarantee. 
But both GLA and Grail  introduced 5 deadlocks , respectively .  
Subsection 5.3.4 will discuss  why HFix , GLA, and Grail  intro-
duced deadlocks .  5.3.3 Comparisons on  Efficiency . From Table 3 (A), we ob-
serve d that, on the only two benchmarks that HFix  was able to fix 
correctly, both  HFix  and Fixer  introduced almost the same over-
head (i.e., 26.80% vs 25.80% and 38.20% vs 37 .80%). This is because 
the two techniques produced the same fix except some fix code 
by Fixer  to avoid introduce deadlocks.  
From Table 3 (B), it is observe d that, Fixer  incurred signifi-
cantly lower overhead than that by GLA and Grail , even on 
benchmarks that all the three  techniques  handled correctly. Com-
pared with GLA, Grail  incurred lower overhead. This is because  
Fixer  is able to infer the lock visibility and can insert a class field 
gate lock; however, GLA always inserts global locks and Grail  
always inserts synthesized locks wh ich may take effect but may 
introduce additional overhead on maintaining the map from a 
hash value to a unique lock .  
Figure 9 show s the performance scalability of all techniques 
with increasing number of threads. The x-axis of each sub -figure 
shows the number of threads from 2 to 128; and the y-axis shows 
the time (in microsecond µs). Particularly, Figure 9(A) shows the 
scalability comparison of HFix  and Fixer ; and Figure 9(B) shows 
the scalability comparison of GLA, Grail , and Fixer . Note : if 
HFix , GLA, or Grail  failed to correctly fix an atomicity violation 
(and no data was collected), the time of Fixer  is still shown for 
comparison with that f rom the original runs.   
The advantage of Fixer  on inferring lock visibility is clearly 
reflected in Figure 9, where we highlight  the sub -figures in gray 
background if a Field lock was adjusted or inserted by Fixer .  
Figure 9(A) shows  that, on two benchmarks that HFix  were 
able to fix correctly, both HFix  and  Fixer  intro duced almost the Table 3.  
(A) Detailed comparisons of adjusting lock fixes by HFix  and Fixer . 
Benchmark  Original?  Loc Fixer  # of new (out er/inner) lock orders  # of Deadlocks  Average overhead  
Case  L-type HFix  Fixer  HFix  Fixer  HFix  Fixer
mozilla   106 AdjL -A Global  0/1 0/0 1 0 - 12.80%  
apache 21285  45.34K  AdjL -A Field  0/1 0/0 1 0 - 36.50%  
apache 45605  43.86K  AdjL -B Field  0/0 0/0 0 0 26.80%  25.80%  
mysql 12228  122 AdjL -A Global  0/1 0/0 1 0 - 15.40%  
mysql 12848  181 AdjL -C Field  0/1 0/0 1 0 - 7.10%  
mysql 169  145 AdjL -C Field  0/0 0/0 0 0 38.20%  37.80%  
   Sum:  0/4 0/0 4 0   Avg.  32.50%  22.57%  
(B) Detailed comparisons of gate lock fixes by GLA , Grail , and Fixer . 
Benchmark  Original?  Loc Fixer  # of new (out er/inner) lock orders  # of Deadlocks  Average overhead  
L-type GLA Grail  Fixer GLA Grail  FixerGLA Grail  Fixer
mozilla   106 Global  1/1 1/1 0/0 1 1 0 - - 14.70%  
aget 0.4  0.32K  Global  1/0 1/0 1/0 0 0 0 5.70%  16.00%  8.06%  
apache 21285  45.34K  Field  1/1 1/1 0/0 1 1 0 - - 44.36%  
apache 21287  45.61K  Field  0/1 0/1 0/0 0 0 0 133.20%  72.70%  3.35%  
apache 25520  45.61K  Field  0/0 0/0 0/0 0 0 0 163.00%  50.80%  25.63%  
apache 45605  43.86K  Field  0/0 0/0 0/0 1 1 0 - - 31.66%  
cherokee 0.9.2  12.76K  Field  1/0 1/0 1/0 0 0 0 198.00%  108.60%  25.33%  
memcached 127  1.27K  Global  0/2 0/2 0/0 0 0 0 100.70%  118.30%  100.89%  
mysql 12228  122 Global  1/1 1/1 0/0 1 1 0 - - 17.70%  
mysql 12848  181 Field  1/1 1/1 0/0 1 1 0 - - 7.21%  
mysql 169  145 Field  1/1 1/1 0/0 0 0 0 211.70%  288.10%  77.53%  
mysql 2011  126 Field  3/0 3/0 3/0 0 0 0 54.90%  22.90%  5.63%  
mysql 3596  122 Field  0/0 0/0 0/0 0 0 0 90.40%  31.60%  9.52%  
mysql 644  118 Field  0/0 0/0 0/0 0 0 0 124.40%  95.40%  1.00%  
mysql 791  125 Field  2/0 2/0 2/0 0 0 0 120.40%  24.50%  1.59%  
     Sum:  12/8 12/8 7/0 5 5 0  Avg.  120.20%  82.90%  24.90%  
 
310  
 
Adaptively Generating High Quality Fixes for Atomicity Violations  ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  
 
 same overhead . Figure 9(B) shows that  Fixer  obviously incurred 
the least overhead compared with that by GLA and Grail . On 2 
sub-figures not highlighted (i.e ., Figure 9 (B.b)  and (B.h)), all tech-
niques incurred  the similar overhead.  On 2 remaining sub -figures 
not highlighted (i.e ., Figure 9 (B.a) and ( B.i)), all techniques except 
Fixer  failed to fix the 2 atomicity violations, and no data was 
collected  for GLA and Grail.  
On the other hand, from Figure 9 (B), among most of sub -
figures, GLA incurred the largest overhead; and Grail  incurred 
less overhead than that by GLA. This is consistent with  the pre-
vious experimental result [37]. However, on three atomicity vio-
lation s aget 0.4, memcached 127, and mysql 169 (i.e., Figure 9 (B.b), 
(B.h), and (B.k)), GLA incurred less overhead than that by Grail . 
We have  identified that, on the first two, the involved variables 
are global ones . Hence, Grail  always synthesized the same gate 
locks. On the last one, although the variables are class fields, 
there is a global lock ( named LOCK_OPEN ) that is firstly acquired 
by both threads. Hence, Grail  gained  no advantage by synthesiz-
ing a gate lock. Instead,  its synthesizing  process increased its 
overhead.   5.3.4 Case Studies  and Discussions . One of the main contribu-
tions of Fixer  is, if a gate lock is inserted, the  ability to infer lock 
visibility to reduce potential fixing overhead . We have presented 
how our Fixer  inserted a class/ struct field gate lock to fix AV1 
from apache 25520. The case on mysql 791 is almost the same as AV1, 
where an atomicity violation  occurs between two writes to 
log_type  from a thread and a read to it from a different thread. 
And this variable log_type  is from a class MYSQL_LOG .  
To fix this atomicity violation, Grail  also inserted a synthe-
sized hash lock: " G = contextL (hash(&(this->log_type ))); acq(G);", 
which unintentionally indicates that the lock G has nothing to do 
with the c lass MYSQL_LOG . However, Fixer  identified that 
log_type  is a member of class MYSQL_LOG  and then inserted a 
lock G as a member of this class. Finally, it only inserted an acqui-
sition " acq(this->G);" (and " acq(mysql_log ->G);" in another 
thread). This fix might be more understandable as it is clearly 
reflected that the lock G is used to protect its neighbor  member 
lock_type  of the same class MYSQL_LOG . Hence, such kind of 
fixes provides an alternative way to improve fix acceptance to 
developers.    
(A) Performance scalability of HFix and Fixer.   
 
(B) Performance scalability of GLA, Grail , and Fixer. 
   
Figure 9. Performance scalability where the x-axis shows the increasing number of threads from 2 to 128 and y-axis shows the 
execution time ( µs). 
0500100015002000250030003500
248163264128
(f) mysql169aFixer
Orig
HFix
02004006008001000
248163264128
(a) mozillaaFixer
Orig
02004006008001000
248163264128
(b) apache21285 aFixer
Orig
0200400600800100012001400
248163264128
(c) apache45605aFixer
Orig
HFix
020040060080010001200
248163264128
(d) mysql12228aFixer
Orig
020040060080010001200
248163264128
(e) mysql12848aFixer
Orig
0500100015002000250030003500
248163264128
(k) mysql 169aFixer
GLA
Grail
Orig
030060090012001500
248163264128
(l) mysql 2011aFixer
GLA
Grail
Orig
0500100015002000
248163264128
(m) mysql 3596aFixer
GLA
Grail
Orig
0500100015002000
248163264128
(n) mysql 644aFixer
GLA
Grail
Orig
0500100015002000
248163264128
(o) mysql 791 aFixer
GLA
Grail
Orig0600120018002400
248163264128
(g) cherokee 0.9.2aFixer
GLA
Grail
Orig
0600120018002400
248163264128
(h) memcached 127aFixer
GLA
Grail
Orig
0200400600800100012001400
248163264128
(f) apache 45605aFixer
Orig
020040060080010001200
248163264128
(i) mysql 12228aFixer
Orig
020040060080010001200
248163264128
(j) mysql 12848aFixer
Orig02004006008001000
248163264128
(b) aget 0.4aFixer
GLA
Grail
Orig
05001000150020002500
248163264128
(d) apache 21287aFixer
GLA
Grail
Orig
05001000150020002500
248163264128
(e) apache 25520aFixer
GLA
Grail
Orig
02004006008001000
248163264128
(a) mozillaaFixer
Orig
02004006008001000
248163264128
(c) apache 21285 aFixer
Orig
311 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
Study on Deadlock Introduction.  From Table 3, GLA and 
Grail  both introduced 5 deadlocks.  On mozilla , the introduced 
deadlock is shown in Figure 3 and w e have analysed  the reason.  
The other 4 deadlocks (on apache 21285, apache 45605, mysql 12228, and 
mysql 12848) are similar to that on mozilla .  
Among our benchma rks, HFix  is only applicable to fix 6 ato-
micity violations  but introduced 4 deadlocks  (see Table 3 (A)). 
These deadlocks  are self -deadlocks.  We have analysed  the intro-
duced deadlock on mozilla .  
Figure 10 shows  another case from  mysql 12848. In Figure 10, the 
atomicity violation  occurs if, in between line 4 and line 8 (two 
writes to qSize), a second thread reads the value of qSize. This 
program  contains a lock gMutex protect ing the two accesses (at 
lines 4 and 14); hence, HFix  is applicable to fix it by enlarg ing the 
lock scope of gMutex (between line s 2 and 6) to protect the write 
to qSize at line 8. That is, HFix  moves the lock release rel(gMutex) 
to line 9 (i.e., "+ rel(gMutex)"). Then, all three accesses to qSize are 
protected by lock gMutex. However, at line 8, there is a call to 
function init_cache () which also contains a pair of lock acquisition 
and release on lock gMutex. Hence , thread t1 is blocked when it 
enters function init_cache () to acquire lock gMutex as which  has 
been acquired by itself at line 2. Thus, a  self-deadlock occurs.  
Fixer  is able to correctly fix this atomicity violation. Accord-
ing to Figure 6, this  atomi city violation falls into Case C. Hence, 
Fixer  also tries to fix it by extending the lock scope of gMutex, 
which is the same as HFix . Next, Fixer  has to ensure that no 
new (inner ) lock order is introduced from lock gMutex  to other 
locks in between line 6 and line 9 . Then , Fixer  found a pair of 
lock acquisition and release on the same lock gMutex after lock 
scope extension . Finally,  Fixer  put this lock acquisition together 
with lock acquisition at line 2 (i.e.,  in form of  acq(gMutex , gMutex ) 
and modified the property of  this lock to be reentrant. In this 
way, this potential self -deadlock is avoided.  
Discussion on  HFix . HFix  can also be adapted to change the 
locks to be re-entran t locks  to avoid introducing self -deadlock. 
However, it still cannot avoid introducing other deadlocks as it 
may introduce new lock orders (see Section 0). Besides , HFix  only 
targets on fixing atomicity violations involving locks. From our 
benchmarks, we see t hat there are still many atomicity violations 
(e.g., 9 out of 15) not involv ing locks ; HFix  fails to fix these ato-
micity violations . What's more, in some cases, even if an atomici-
ty violation can be fixed by adjusting a lock, gate lock strategy 
might be better. For example, on mysql 169, a global lock 
LOCK_open  is used to protect a class field variable . In such cases, 
a field lock under the same clas s might be better. It is difficult to 
say which fix is better  without deep ly understanding the source 
code. However, Fixer  can produce  both kinds of fixes.  6. RELATED  WORK  
Concurrency bugs widely exist in multithreaded programs [4][5] 
[44]. Many techniques  [11][39][18][22][23][34][37][50][52][54] 
[62] have been proposed to fix them automatically . Many of  these 
techniques insert gate locks to serialize executions of threads  
involved in the bug . The inserted gate lock may introduce  
performance bugs  and deadlocks , as already noticed [22][23][41]. 
Although deadlocks could be theor etically detected via 
reachab ility analysis  [27] or model checking [20], they cannot 
scale up to la rge-scale programs .  
We have extensively discussed  GLA, Grail , and HFix . DFixer  
[6] adopts lock pre -acquisiton to fix deadlocks by eliminating the 
hold-and-wait condition  that is a necessary condition for a 
deadlock to occur . However, DFixer  is not applicable to fix 
concurre ncy bugs involv ing memory accesses. Fixer  is specially 
designed to fix atomicity violations.  
Flint [36] tries to fix linearizability violation in concurrent 
compositions (i.e., Map data structure) . ConcBugAssist [28] au-
tomatically infers wrong interleaving and then applies constraint s 
(i.e., gate locks,  wait and notify  operations ) to fix concurrency 
bugs . Unlike Fixer , ConcBugAssist  may introduce deadlocks.  
Concurrency bugs can also be prevented  or avoi ded [12][13] 
[17][26][51]. Gadara  [51] and Dimmunity  [26] prevent previous ly 
occurred deadlock s by invoking gate locks depending on whether 
a deadlock may occur based on execution context matching . Fix-
er could be adopted into these techniques to infer the visibility of 
gate locks to be inserted to improve runtime overhead.  
Recovery techniques coul d be considered once a  concurrency 
bug occur s. ConAir  [61] tries to recover most concurrency bugs  
with low overhead . Sammati  [45] and [46] aim to provide dead-
lock recovery by rolli ng back executions . Lin et al. [33] propose to 
change lock acquisition primitives (i.e., from acq() to tryAcq ()). 
However , recovery might be infeasible as discussed in  [33] con-
sidering unrecoverable operations  (e.g., file IO operations ).  
7. CONCLUSION   
Concurrency bugs are difficult to be fixed correctly . We present ed 
Fixer  to fix atomicity violations  adaptively . It analyses  the lock 
acquisitions involved in a given atomicity violation to determine 
whether to adjust existing lock acquisitions or to insert gate lock s 
to fix atomicity violation s. For the latter  case, u nlike existing 
approaches  that insert global or synthesized gate locks, Fixer  
tries to insert either global lock s or class/struct field lock s to gen-
erate fixes that are more efficient . Besides, Fixer  guarantees 
deadlocks -free fixes . We demonstrat ed the effectiveness and the 
efficiency of Fixer  over a set of 15 real -world benchmarks.   
ACKNOWLEDGEMENT  
We thank anonymous reviewers for their invaluable comments  
and suggestions on improving this work. This work is supported 
in part by National Natural Science Foundation of  China ( NSFC) 
(grant No. 61502465  and 61572150 ), National 973 program of Chi-
na (2014CB340702) , and the Youth Innovation Promotion Associa-
tion of the Chinese Academy of Sciences (YICAS) ( 2017151 ). 
Thread t1
1.resize (…){
2. acq(gMutex );
3.…
4. qSize = 0;
5.…
6.-rel(gMutex );
7.…
8. qSize = init_cache ();
9.+ rel(gMutex );
10.}Thread t2
11.…
12.acq(gMutex );
13.…
14.if(qSize == 0)…
15.…
16.rel(gMutex );
init_cache (){
acq(gMutex );…
rel(gMutex ); … } 
Figure 10. The atomicity violation from mysql 12848. 
312  
 
Adaptively Generating High Quality Fixes for Atomicity Violations  ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  
 
 REFERENCES  
[1] LLVM  Compiler Infras tructure , version 3.6 , http://llvm.org .   
[2] Concurrency Bugs,  https://github.com/jieyu/concurrency -bugs.  
[3] R. Agarwal, S. Bensalem, E. Farchi, K. Havelund, Y. Nir -
Buchbinder, S. D. Stoller, S. Ur, and L. Wang. Detection of deadlock 
potentials in multithreaded programs. IBM Journal of Research and 
Development, Vol. 54 (5), 520 –534, 2010.   
[4] E. Bodden and K. Havelund. Aspect -oriented race detection in Java. 
IEEE Transactions on Software Engineering (TSE), 36(4), 509–527, 
2010.  
[5] E. Bodden and K. Havelund . Racer: effective race detection using 
aspectj. In Proceedings of the 2008 I nternational Symposium on 
Software Testing and A nalysis (ISSTA'08) , 155 –166, 2008.  
[6] Y. Cai and L.W. Cao. Fixing deadlocks via lock pre -acquisitions. In 
Proceedings of the 38th Inte rnational Conference on Software 
Engineering (ICSE'16) , 1109 –1120, 2016.   
[7] Y. Cai and W.K. Chan. MagicFuzzer: scalable deadlock detection for 
large -scale applications. In Proceedings of the 34th International 
Conference on Software Engineering (ICSE'12) , 606−616, 2012.   
[8] Y. Cai, S. Wu, and W.K. Chan. ConLock: A constraint -based 
approach to dynamic checking on deadlocks in multithreaded 
programs. In Proceedings of the 36th International Conference on 
Software Engineering (ICSE'14) , 491 –502, 2014.  
[9] B. Cornu, T . Durieux, L. Seinturier, and M. Monperrus. NPEFix: 
Automatic Runtime Repair of Null Pointer Excep tions in Java. 
Technical Report  1512.07423 , Arxiv, 2015 . 
[10] C. Flanagan and S. N. Freund. FastTrack: efficient and precise 
dynamic race detection. In Proceedings  of the 30th ACM SIGPLAN 
Conference on Programming Language Design and Implementation 
(PLDI'09) , 121 –133, 2009.  
[11] Q. Gao, Y.F. Xiong, Y.Q. Mi, L. Zhang, W.K. Yang, Z.P. Zhou, B. 
Xie, and H. Mei. Safe memory -leak fixing for C programs. In 
Proceedings of the 37th International Conference on Software 
Engineering (ICSE'15) , 459 –470, 2015.  
[12] P. Gerakios, N. Papaspyrou, and K. Sagonas. A type and effect 
system for deadlock avoidance in low -level languages. In Proceedings 
of the 7th AC M SIGPLAN Workshop on Types in L anguage Design 
and I mplementation (TLDI'11) , 15–28, 2011.  
[13] P. Gerakios, N. Papaspyrou, K. Sagonas, and P. Vekris. Dynamic 
deadlock avoidance in systems code using statically inferred effects. 
In Proceedings of the 6th Workshop on Programming Languages and 
Operating Systems ( PLOS '11), Article No. 5, 2011.  
[14] C. Le Goues, M. Dewey -Vogt, S. Forrest, and W. Weimer. A 
systematic study of automated program repair: fixing 55 out of 105 
bugs for $8 each. In Proceedings of the 34th International Conference 
on Software E ngineering ( ICSE '12), 3–13, 2012.  
[15] C. Le Goues, S. Forrest, and W. Weimer. Current challenges in 
automatic software repair. Software Quality Journal, 21(3): 421 –443, 
2013.  
[16] C. Le Goues, T. Nguyen, S. Forrest and W. Weimer. GenProg: A 
generic method for autom ated software repair. IEEE Transactions on 
Software Engineering (TSE), 38(1): 54 -72, 2012.  
[17] M. Grechanik, B.M. M. Hossain, U. Buy, and H. Wang. Preventing 
database deadlocks in applications. In Proceedings of the 2013 9th 
Joint Meeting on Foundations of Sof tware Engineering  
(ESEC/FSE '13), 356 –366, 2013.  
[18] M. Grechanik, B.M. M. Hossain, and U. Buy. Testing database -
centric applications for causes of database deadlocks. In Proceedings 
of the 2013 IEEE 6 th International Conference on Software Testing, 
Verificatio n and Validation (ICST'13) , 174 –183, 2013.  
[19] C. Hammer, J. Dolby, M. Vaziri, and F. Tip. Dynamic detection of 
atomic -set-serializability violations. In Proceedings of the 30th 
International Conference on Software E ngineering ( ICSE '08), 231 –
240, 2008.  [20] K. Havelund . Using runtime analysis to guide model checking of java 
programs. In Proceedings of the 7th International SPIN Workshop on 
SPIN Model Checking and Software Verification  (SPIN '00), 245 –
264, 2000.  
[21] G. Jin, L. Song, X. Shi, J. Scherpelz, and S. Lu. Un derstanding and 
detecting real -world performance bugs. In Proceedings of the 33rd 
ACM SIGPLAN Conference on Programming Language Design and 
Implementation ( PLDI '12), 77–88, 2012.  
[22] G. Jin, L.H, Song, W. Zhang, S. Lu, B. Liblit. Automated atomicity -
violation fixing. In Proceedings of the 32nd ACM SIGPLAN 
Conference on Programming Language Design and Implementation  
(PLDI '11), 389–400, 2011.  
[23] G. Jin, W. Zhang, D. Deng, B. Liblit, S. Lu. Automated concurrency -
bug fixing. In Proceedings of the 10th USENIX C onferenc e on 
Operating Systems Design and Implementation  (OSDI '12), 221 –236, 
2012.  
[24] P. Joshi, M. Naik, K, Sen, and D. Gay. An effective dynamic analysis 
for detecting generalized deadlocks. In Proceedings of the 18th ACM 
SIGSOFT International S ymposium on Foundatio ns o f Software 
Engineering ( FSE'10), 327 –336, 2010.  
[25] P. Joshi, C.S. Park, K. Sen, amd M. Naik. A randomized dynamic 
program analysis technique for detecting real deadlocks. In 
Proceedings of the 30th ACM SIGPLAN Conference on 
Programming Language Design and  Implementation  (PLDI '09), 110 –
120, 2009.  
[26] H. Jula, D. Tralamazza, C. Zamfir, and G.e Candea. Deadlock 
immunity: enabling systems to defend against deadlocks. In 
Proceedings of the 8th USENIX Conference on Operating Systems 
Design and I mplementation  (OSDI '08), 295 –308, 2008.  
[27] V. Kahlon, F. Ivančić, and A. Gupta. Reasoning about threads 
communicating via locks. In Proc eedings of the 17th International 
Conference on Computer Aided Verification  (CAV '05), 505 –518, 
2005.  
[28] S. Khoshnood, M. Kusano, and C. Wang. ConcB ugAssist: Constraint 
solving for diagnosis and repair of concurrency bugs. In Proceedings 
of the 2015 International Symposium on Software Testing and 
Analysis ( ISSTA '15), 165 –176, 2015.  
[29] M. Kim, S. Sinha, C. Gö rg, H. Shah, M. J. Harrold and M. G. Nanda. 
Automated bug neighborhood analysis for identifying incomplete bug 
fixes. In Proceedings of the 2010 Third International Conference on 
Software Testing, Verification and Validation  (ICST '10), 383 –392, 
2010.  
[30] Z. Lai, S. C. Cheung and W. K. Chan. Detecting atomi c-set 
serializability violations in multithreaded programs through active 
randomized testing. In Proceedings of the 32nd ACM/IEEE 
International Conference on Software Engineering ( ICSE '10), 235 –
244, 2010.  
[31] C. Lattner and B. Adve. LLVM: a compilation framewo rk for lifelong 
program analysis & transformation. In Proceedings of the 
International Symposium on Code Generation and O ptimization:  
Feedback -directed and Runtime O ptimization  (CGO '04), 75 –86, 
2004.  
[32] D. Li, W. Srisa -an, and M. B. Dwyer. SOS: saving time in dynamic 
race detection with stationary analysis. In Proceedings of the 2011 
ACM International Conference on Object Oriented Programming 
Systems Languages and A pplications  (OOPSLA '11), 35–50, 2011.  
[33] Y. Lin and S. S. Kulkarni. Automatic repair for multi -threaded 
programs with Deadlock/Livelock using maximum satisfiability. In 
Proceedings of the 2014 International Symposium on Software 
Testing and Analysis  (ISSTA '14), 237 –247, 2014.  
[34] P. Liu and C. Zhang. A xis: automatically fixing atomicity violations 
through solving control constraints. In Proceedings of the 34th 
International Conference on Software Engineering  (ICSE '12), 299 –
309, 2012.  
[35] H.P. Liu, Y. Chen, and S. Lu. Understanding and generating high 
qualit y patches for concurrency bugs. In Proceedings of the 2016 24th 
313 
 
ESEC/FSE'17, September 4 -8 2017, Paderborn, Germany  Y. Cai, L. Cao, and J. Zhao  
 
ACM SIGSOFT International Symposium on Foundations of 
Software Engineering  (FSE'16 ), 715–726, 2016 .  
[36] P. Liu, O. Tripp, and X.Y. Zhang. Flint: fixing linearizability 
violations. In Proceedings of the 2014 ACM International Conference 
on Object Oriented Programming Systems Languages & Applications  
(OOPSLA '14), 543 –560, 2014.  
[37] P. Liu, O. Tripp, and C. Zhang. Grail: context -aware fixing of 
concurrency bugs. In Proceedings of the 22nd ACM SIGSOFT 
International Symposium on Foundations of Software Engineering  
(FSE'14), 318 –329, 2014.  
[38] S. Lu , S. Park , E. Seo , Y.Y. Zhou. Learning from mistakes: a 
comprehensive study on real world concurrency bug characteristics. 
In Proceedings of the 13th International  Conference on Architectural 
Support for Programming Languages and O peratin g S ystems  
(ASPLOS '08), 329 –339, 2008.  
[39] D. Marino, C. Hammer, J. Dolby, M. Vaziri, F. Tip, and J. Vitek. 
Detecting deadlock in programs with data -centric synchronization. In 
Proceedin gs of the 2013 International Conference on Software 
Engineering  (ICSE '13), 322 –331, 2013.  
[40] M. Martinez and M. Monperrus. Mining repair actions for guiding 
automated program fixing. Technical report 1311.3414, Arxiv, 2012.  
[41] Y. Nir -Buchbinder, R. Tzoref, and S . Ur. Deadlocks: from exhibiting 
to healing. In Proceedings of 8th Workshop on Runtime Verification 
(RV'08), 104 –118, 2008.  
[42] S. Park. Debugging non -deadlock concurrency bugs. In Proceedings 
of the 2013 International Symposium on Software Testing and 
Analysi s (ISSTA '13), 358 –361, 2013.  
[43] Y. Pei, C. A. Furia, M. Nordio, and B. Meyer. Automatic program 
repair by fixing contracts. In Proceedings of the 17th International 
Conference on Fundamental Approaches to Software Engineering 
(FASE '14), 8411:246 –260, 2014.  
[44] M. Pradel and T. R. Gross. Fully automatic and precise detection of 
thread safety violations. In Proceedings of the 33rd ACM SIGPLAN 
Conference on Programming Language Design and Implementation  
(PLDI '12), 521 –530, 2012.  
[45] H. K. Pyla and S. Varadarajan. Avoid ing deadlock avoidance. In 
Proceedings of the 19th International C onference o n Parallel 
Architectures and Compilation T echniques  (PACT '10), 75–86, 2010.  
[46] F. Qin, J. Tucek, J. Sundaresan, and Y. Zhou. Rx: treating bugs as 
allergies ---a safe method to survive software failures. In Proceedings 
of the 20th ACM S ymposium on Operatin g Systems P rinciples  
(SOSP '05), 235 –248, 2005.  
[47] F. Sorrentino, A. Farzan, and P. M adhusudan. PENELOPE: weaving 
threads to expose atomicity violations. In Proceedings of the 18th 
ACM SIGSOFT International Symposium on Foundations of 
Software E ngineering  (FSE'10), 37–46, 2010.  
[48] R.E.K. Stirewalt, R. Behrends, and L. K. Dillon. Safe and reliable use 
of concurrency in multi-threaded shared -memory systems. In 
Proceedings of the 29th Annual IEEE/NASA on Software 
Engineering  (SEW '05), 201 –210, 2005.  
[49] R. Surendran, R. Raman, S. Chaudhuri, J. Mellor -Crummey, and V. 
Sarkar. Test -driven repair of data  races in structured parallel 
programs. In Proceedings of the 35th ACM SIGPLAN Conference on 
Programming Language Design and Implementation ( PLDI '14), 15–
25, 2014.  [50] S.H. Tian and A. Roychoudhury. relifix: automated repair of software 
regressions. In Proceed ings of the 37th International Conference on 
Software Engineering  (ICSE '15), 417 –482, 2015.  
[51] Y. Wang, T. Kelly, M. Kudlur, S. Lafortune, and S. Mahlke. Gadara: 
dynamic deadlock avoidance for multithreaded programs. In 
Proceedings of the 8th USENIX Conference on Operating Systems 
Design and I mplementation ( OSDI '08), 281 –294, 2008.  
[52] D. Weeratunge, X. Y. Zhang, and S. Jaganathan. Accentuating the 
positive: atomicity inference and enforcement using correct 
executions. In Proceedings of the 2011 ACM Intern ational 
Conference on Object Oriented Programming Systems Languages and 
Applications  (OOPSLA '11), 19–34, 2011.  
[53] D. Weeratunge, X.Y. Zhang, and S. Jagannathan. Analyzing 
multicore dumps to facilitate concurrency bug reproduction. In 
Proceedings of the 15 th edition of ASPLOS on Architectural Support 
for Programming Languages and Operating S ystems  (ASPLOS '10), 
155–166, 2010.  
[54] W. Weimer, S. Forrest, C. L. Goues, and T. Nguyen. Automatic 
program repair with evolutionary computation . Communication s of 
the ACM (CACM ), 53(5): 109 –116, 2010.  
[55] A. Williams, W. Thies, and M.D. Ernst. Static deadlock detection for 
java libraries. In Proceedings of the 19th European C onference on 
Object -Oriented Programming  (ECOOP '05), 602 –629, 2005.  
[56] W. Xiong, S. Park, J. Zhang, Y. Zhou, and  Z. Ma. Ad hoc 
synchronization considered harmful. In Proceedings of the 9th 
USENIX Conference on Operating Systems Design and 
Implementation  (OSDI '10), 163–176, 2010.  
[57] C.Y. Ye, S.C. Cheung, W.K. Chan, and C. Xu. Detection and 
resolution of atomicity violat ion in service composition. In 
Proceedings of the 6th joint meeting of the European Software 
Engineering Conference and the ACM SIGSOFT symposium on The 
Foundations of Software Engineering  (ESEC/FSE '07), 235 –244, 
2007.  
[58] Z. Yin, D. Yuan, Y. Zhou, S. Pasupathy, and L. Bairavasundaram. 
How do fixes become bugs? In Proce edings of the 19th ACM 
SIGSOFT Symposium and the 13th European C onference on 
Foundations of  Software E ngineering (ESEC/FSE'11),  26–36, 2011.   
[59] J. Yu and S. Nar ayanasamy. A case for an interleaving constrained 
shared -memory multi -processor. In Proceedings of the 36th annual 
International Symposium on Computer A rchitecture  (ISCA '09), 325 –
336, 2009.  
[60] C. Zamfir and G. Candea. Execution synthesis: a technique for 
automated software debugging. In Proceedings of the 5th European 
Conference on Computer S ystems  (EuroSys '10), 321 –334, 2010.  
[61] W. Zhang, M. de Kruijf, A. Li, S. Lu, and K. Sankaralingam. ConAir: 
featherweight concurrency bug recovery via single -threaded 
idempote nt execution. In Proceedings of the 18th International 
Conference on Architectural Support for Programming Languages 
and Operating S ystems  (ASPLOS '13), 113 –126, 2013.  
[62] J. Zhou, H. Zhang, and D. Lo. Where should the bugs be fixed? - 
More accurate information -retrieval -based bug localization based on 
bug reports. In Proceedings of the 34th International Conference on 
Software Engineering  (ICSE '12), 14–24, 2012.  
 
 
314