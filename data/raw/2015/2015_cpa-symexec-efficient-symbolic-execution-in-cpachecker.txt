CPA-SymExec: Efficient Symbolic Execution in CPAchecker
Dirk Beyer
LMU Munich
GermanyThomas Lemberger
LMU Munich
Germany
ABSTRACT
We present CPA-SymExec , a tool for symbolic execution that is im-
plementedintheopen-source,configurableverificationframework
CPAchecker . Our implementation automatically detects which sym-
bolicfactstotrack,inordertoobtainasmallsetofconstraintsthat
arenecessarytodecidereachabilityofaprogramareaofinterest.
CPA-SymExec isbasedonabstractionandcounterexample-guidedab-
straction refinement ( CEGAR), and uses a constraint-interpolation
approachtodetectsymbolicfacts.Weshowthatourimplementa-
tion can better mitigate the path-explosion problem than symbolic
executionwithoutabstraction,bycomparingtheperformanceto
the state-of-the-art Klee-based symbolic-execution engine Symbi-
oticand toKleeitself. For the experiments we use two kinds of
analysis tasks: one for finding an executable path to a specific
location of interest (e.g., if a test vector is desired to show thata certain behavior occurs), and one for confirming that no exe-
cutablepathtoaspecificlocationexists(e.g.,ifitisdesiredtoshow
that a certain behavior never occurs). CPA-SymExec is released un-
der the Apache 2 license and available (inclusive source code) at
https://cpachecker.sosy-lab.org. A demonstration video is available
athttps://youtu.be/qoBHtvPKtnw.
CCS CONCEPTS
•Generalandreference →Verification ;•Softwareanditsen-
gineering →Formalmethods ;Formalsoftwareverification ;
KEYWORDS
SymbolicExecution,ProgramAnalysis,Test-CaseGeneration
ACM Reference Format:
Dirk Beyer and Thomas Lemberger. 2018. CPA-SymExec: Efficient Sym-
bolicExecutioninCPAchecker.In Proceedings of the 2018 33rd ACM/IEEE
International Conference on Automated Software Engineering (ASE ’18), Sep-
tember 3–7, 2018, Montpellier, France. ACM, New York, NY, USA, 4pages.
https://doi.org/10.1145/3238147.3240478
1 INTRODUCTION
Symbolic execution [18]hasimportantapplicationsintheareaof
softwareverificationandtesting.Manytechniquesrelyongenerat-
ing(symbolic)pathsthroughtheexecutiontreeofaprogram,for
example, test-casegeneration [ 9], faultlocalization [ 13], program
repair [19,20],and equivalencechecking[ 17].Evenforsoftware
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240478verification, approaches using symbolic execution are able to show
remarkable results at the competition on software verification (SV-
COMP)[1]1.Symbolic executionisa staticprogramanalysisthat
stores explicit values for variables whenever possible, and if an ex-
plicitvalueisnotavailable,anewsymbolicvalueisassignedtothe
variableandusedasitsvalueinfurthercomputations.Thisway,the
symbolicvalueispropagatedtootherprogramvariablesdepending
ontheundeterminablevariable.Wheneverasymbolicvalueoccurs
in an assumption, this assumption describes a constraint on the
symbolicvaluefortheremainingprogrampath.Symbolicexecution
trackstheseconstraintsalongsidevariableassignmentstoreason
aboutthefeasibilityofaprogrampathandtodeterminepossible
concrete values for symbolic variable assignments. Additionally,using symbolic values, relationships between program variablescan be observed in a clear manner. Because of its high precision,
symbolic execution suffers in its original form from path explosion.
Our symbolic-execution engine, CPA-SymExec , is able to mitigate
pathexplosionthrough abstraction withCEGAR[11].CEGARcom-
putesthe precision thatisnecessaryforananalysis:itstartswith
an initial, coarse precision and then iteratively refines the preci-
sion based on infeasible target paths that are found during the
analysis. The precision of CPA-SymExec , in particular, specifies for
which variables the analysis tracks (symbolic) values and which
constraintsareimportant. CPA-SymExec computesaspecialinstan-
tiation of Craig interpolants [ 12] from infeasible target paths that
allows us to derive program variables and constraints that must be
tracked[7].Through this,weoften findanabstractmodel forthe
programthatisdetailedenoughtoreasonabouttheexecutability
ofprogrampaths,butstillcoarseenoughtoavoidpathexplosion.
CPA-SymExec is implemented in thesoftware-verificationframe-
workCPAchecker ,whichoffersmanyabstractdomainsandverifica-
tion algorithms, is developed and maintained by over 20 active, in-
ternational contributors from different institutions, and is releasedunder the open-source license Apache 2. Modular design is a main
objective of the project. The framework provides many utilities
that are useful for performing software-analysis tasks: After a run,
itprovidesdetailedstatisticsaboutitsdifferentmodules,andtarget
paths are made available in JSON and as XML witnesses [ 4,5]. For
presentation purposes, visualizations are available for: the control-
flow automaton (CFA), the abstract reachability graph (ARG), and
the target paths [ 3]. For a found target, CPA-SymExec also returns
the symbolic execution path to that target in a text file for further
parsing in other tools, as well as an exemplary concrete execution
path. In addition to this, CPA-SymExec can also be used for test-case
generation based on condition coverage. In addition to CEGAR,
CPA-SymExec uses several optimizations to speed up state explo-
ration. For example, after every satisfiability check (SAT check) of
pathconstraints,itstoresamodelfortheconstraintsandchecks
1https://sv-comp.sosy-lab.org/2018/results/results-verified
900
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dirk Beyer and Thomas Lemberger
1unsigned char a=˚;
2unsigned char b=˚;
3unsigned char c=b+1 ;
4unsigned char i=0 ;
5while (a < 100) {
6 if(˚)
7 a++;
8 else
9 i++;
10}
11if(c <= b)
12 error();tu
tu
tb“b1,c“b1`1u
tu
tb“b1,c“b1`1u
tutb“b1,c“b1`1u
tu
tb“b1,c“b1`1u
tu
tb“b1,c“b1`1u
tutb“b1,c“b1`1u
tu
tb“b1,c“b1`1u
tutb“b1,c“b1`1u
tb1`1ďb1u
tb“b1,c“b1`1u
tb1`1ďb1ua“˚;b“˚;c“b+1 ;i“ 0
raă100s r/visualspacepaă100qs
r˚s
a++r/visualspacep˚qs
i++rcďbs
error()
Figure1:Exampleprogramwithsymbolicexecutiontreeof
CPA-SymExec to illustrate the effect of abstraction
whetheritstillholdsforsuccessivepathconstraints(toavoidex-
pensive SAT checks), and it also uses that model to check whether
anysymbolicvalueisconstrainedtoasingleconcretevalue.Ifso,itpermanently storesthe corresponding assignment andreplaces the
symbolic value with the concrete value. Through this, the number
ofsymbolicvaluesinSATcheckscanbeminimized.Asafurtherad-
vancement, CPA-SymExec usesarandom-weightedtraversalstrategy
for state-space exploration that is inspired by Klee[9].
To show the maturity of our implementation, we performed
experiments on thousands of C programs from the largest avail-
able repository of C verification tasks2. The results show that CPA-
SymExeccancompetewithbothstate-of-the-arttoolsforsymbolic
execution of C programs, KleeandSymbiotic.
Example. Figure1shows the effect of using symbolic execution
withCEGAR. The special symbol ˚in the C program (top left in
Fig.1)representsanon-deterministicvalue.TheARGofthepro-
gram (bottom Fig. 1) illustrates the explored state space. Every
rectangle represents an abstract state, with the first line contain-ing the variable assignments and the second line containing the
tracked constraints. Assume we want to check whether the call to
functionerrorcan be reached. Instead of tracking all assumptions
and assignments that occur in the program and analyzing an expo-
nentiallygrowing(andeveninfinite)numberofpathsduetothe
non-deterministic value of variable aand the if-condition in the
loop, symbolic execution with CEGARonly tracks the values of
those variables that are necessary to prove the property; namely b
andc. Using this level of abstraction, all possible program states of
thelooparerepresentedbytheabstractstatesthatarecomputed
duringthefirstiterationoftheloop.Thedottedrectanglesrepresent
abstract states at which the analysis stops because they are already
covered by the computed state space. The red, bold rectangle in
2https://github.com/sosy-lab/sv-benchmarkstrue
a“a1^b“b1^c“b1`1
a1ě100
b1`1ďb1a“˚;b“˚;
c“b+1 ;i“ 0
r/visualspacepaă100qs
rcďbs
error()
(a) Symbolic pathtrue
a“100^b“255^c“0a“˚;b“˚;
c“b+1 ;i“ 0
r/visualspacepaă100qs;
rcďbs;
error()
(b) Concrete path
Figure 2: Symbolic and concrete paths to the target
thelowerrightisanabstractstatethatrepresentsafoundtarget
(due to overflow, cf. Fig. 2b).
IfCPA-SymExec findsatarget,itcreatesthesymbolicpath(Fig. 2a)
andaconcretepath(Fig. 2b)thatleadtothattarget.Thesepaths
canbeusedforfurtheranalysistasks,e.g.,validationofverification
results or program repair. In addition, CPA-SymExec can create a
compilable test to check reachability through execution.
Contributions. Thetool CPA-SymExec contributesthefollowing:
‚Support for the combination of abstraction refinement with
symbolicexecutionbyextendingthepreviousimplementa-
tion [7] to a mature symbolic-execution engine.
‚Availability of all configuration options existing in the
CPAchecker framework,includingcombinationswithother
abstract domains and analysis algorithms (e.g., pointer anal-
ysis or memory graphs).
‚Optimizations(e.g.,subset-supersetcaching)thatareconsid-
ered state-of-the-art and offered in Klee[9].
‚Violation witnesses and executable tests [6].
‚Automatic test-case generation [ 2] (also implemented in
Klee) for condition coverage.
‚Symbolictargetpathstosupportcomprehensionofprogram
paths and for further use.
‚HTML-basedreportstoviewandanalyzecontrol-flowau-tomata, abstract reachability graphs, and target paths in-dependent from specific tools (requires a standard web
browser).
We show that our implementation is competitive against the state-
of-the-art( Klee,Symbiotic)inathoroughexperimentalevaluation.
Supplementary Artifact and Webpage. All experimental data,
additional evaluation of mentioned features, and further examples
are available as supplement [ 8]3.
Related Work. Klee[9] is a symbolic-execution tool that uses
search heuristics to mitigate the path-explosion problem. It is able
to symbolically and dynamically handle system calls in a program,
while our implementation always handles them symbolically. Han-
dlingasystemcalldynamicallyexecutesitandusestheconcrete
valuereturnedbytheoperatingsystemforfurtheranalysis.This
allows faster execution, but may not cover all possible program
3https://sosy-lab.org/research/cpa-symexec-tool
901
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. CPA-SymExec ASE ’18, September 3–7, 2018, Montpellier, France
states.Handlingasystemcallsymbolicallyusesasymbolicvalue
that represents all possible values the operating system could re-
turn for the system call. The advantages and disadvantages are the
opposite of dynamic handling. Kleecan also provide a test case for
everyexploredprogrampathduringtheanalysisofaprogram.
Symbiotic [10] is a symbolic-execution-based verifier that uses
program-slicingwithextendedpointeranalysistomitigatepathex-
plosion. Symbiotic has been participating in SV-COMP successfully
forseveralyears.Ituses Kleeasasymbolic-executionback-end.
Tracer[14] computes (a) loop invariants using counterexample-
guidedloopunrollingtotackletheproblemofunboundedloopsand
(b)weakest-preconditioninterpolantsderivedfrominfeasibletarget
pathstoweakentheprecisionofitssymbolicexecution.Thisisthe
oppositetoouruseof CEGAR.Whilewestartwithalowprecision
andrefineitbasedonstrongest-postconditioninterpolants(preci-
sionincrease), Tracerstartswithahighprecisionandabstractsit
basedonweakest-preconditioninterpolants(precisiondecrease).
To make bug reports more readable, path projection [16] (see
also[15])takesanXMLbugreportandpresentsthecorresponding
programcodeafterperformingmethodinliningandcodefolding
onit.Thisway,itcreatesoneconsecutive,readablestreamofthe
executed program code that only shows information that is nec-essary to understand the bug without the need to jump betweenlines and files. The HTML interface of the target-path report of
CPAchecker issimilartothis,butdisplaysaconcretetargetpath.
2 ARCHITECTURE OF CPA-SYMEXEC
A run of CPA-SymExec consists of three main phases: The front-end
module (Parser and CFA Builder) first creates an internal represen-
tation of the program under analysis as CFA, then the symbolic
execution with CEGARruns on that CFA and tries to find a target
path for a provided specification. When the analysis terminates,statisticsandotherinformationarewrittenfortheusertobetterunderstand the result. Figure 3shows this main architecture of
CPA-SymExec .
Front-end. CPA-SymExec isabletobuildCFAsforprogramswritten
inC, Java,and LLVMbitcode.First, thefront-end parsesthepro-gram under analysis. From the resulting parse tree, it constructs
the initial CFA and performs several optimizations to simplify the
structureof theCFA.Then,the front-endderives additionalinfor-
mationabouttheprogrambasedonsyntacticalinformation.This
includes a live-variables analysis to determine which variables are
active in the current scope, a classification of variables based on
theirusage,andananalysisoftheloopstructureoftheprogram.
ThecreatedCFAandtheadditionalinformationcollectedisthen
passed to the symbolic execution.
Symbolic Execution. CPA-SymExec runssymbolicexecutionwith
anadjustableprecisionontheCFA.Initially,thisprecisionisempty,
i.e., symbolic execution does not track any variable assignments
or path constraints. Whenever the symbolic execution finds a path
thatviolatesthegivenspecification,thattargetpathissymbolically
executed with full precision. If this shows that the path is actually
infeasible, the precision is refined by the precision-refinement pro-
cedure.Theprecisionrefinementextracts(byinterpolation)from
an infeasible target path which variables and constraints shouldbe tracked. This information is used to increase the adjustable pre-
cision, such that the infeasible target path is not re-encountered
by any successive symbolic execution, and the symbolic execution
restartswith thenewprecision. Ifthesymbolic executionfinishes
withoutfindingatargetpath, CPA-SymExec terminatesandthespec-
ificationholds.Ifsymbolicexecutionwithfullprecisionshowsthat
afoundtargetpathisactuallyfeasible, CPA-SymExec terminatesand
returns the target path with additional data to the user.
AnalysisOutput. Afteranalysis,anHTMLreport4canbecreated
tovisualizetheCFA,theexploredstatespaceand,ifexisting,target
paths. The CFA is displayed in graph representation, the exploredstate space is displayed as an ARG, and target paths are displayed
in two variants: (1) A concrete target path shows relevant concrete
variableassignmentsateverystepalongthepath,and(2)asymbolic
target path shows the full symbolic state at every step along the
path. If CPA-SymExec is used for test-case generation, a test harness
iscreatedforeachreachableconditionintheprogramassoonas
itisreached.Thistestharnesscanbecompiledtogetherwiththe
program under analysis to create an executable test.
Test-Case Generation. Fortest-casegeneration,an algorithmin
CPAchecker is used that (a) defines every condition in the program
asatarget,and(b)onlystopsafter,foreachtarget,apathtoitisfound, or it is proven unreachable. For each target path, it then
creates a compilable harness based on the work of execution-based
result validation [ 6].
3 USING CPA-SYMEXEC
Installation. Allstepsforinstalling CPAchecker areexplainedonour
supplementarywebpage.5CPAchecker canbedownloadedasbinary
release, or as source code using Subversion or Git.6
Execution. To runCPAchecker on the command line, execute cpa.sh,
which can be found in directory scripts/of the installation, with
the intended parameters followed by the file to analyze. To use
CPA-SymExec , runCPAchecker with parameter -symbolicExecution-
Cegar. If a C file is not yet pre-processed, CPAchecker can do that
with option -preprocess .
Constraintsofsymbolicexecutionareresolvedusinganexternal
SMT solver. Currently, CPAchecker supports SMTInterpol7,Math-
SAT58,Z39,andPrincess10.Thesolvercanbeselectedbyusingpa-
rameter -setprop solver.solver=SOLVER with the intended solver;
the default solver is MathSAT5 . By default, CPA-SymExec uses bit-
preciseencodingofbothbit-vectorsandfloating-pointnumbers.
A fullline to execute an example program test.clookslike:
cpa.sh -symbolicExecution-Cegar -preprocess test.c
CPAchecker will create a set of files (in directory output/) for the
user to better understand all findings (cf. Sect. 2). To perform
test-case generation with CPA-SymExec , run it with configuration
-testCaseGeneration-symbolicExecution-Cegar .
4cf.https://sosy-lab.org/research/cpa-symexec-tool for an example report
5https://sosy-lab.org/research/cpa-symexec-tool
6http://cpachecker.sosy-lab.org/download.php
7http://ultimate.informatik.uni-freiburg.de/smtinterpol/
8http://mathsat.fbk.eu/
9https://github.com/Z3Prover/z3
10http://www.philipp.ruemmer.org/princess.shtml
902
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dirk Beyer and Thomas Lemberger
C Program
SpecificationParser &
CFA BuilderSymbolic Execution
with
Adjustable Full
Precision PrecisionPrecision
Refinement
safe
+ additional dataunsafe
+ additional dataCFATarget PathInfeasible Path Precision Increment
No Target Path Feasible Target Path
Figure 3: Architecture of CPA-SymExec
Table 1: Comparison of CPA-SymExec with the other state-of-
the-art tools KleeandSymbiotic ; best value highlighted
Tool correct correct incorrect incorrect unsolved
true false true false
CPA-SymExec 2137 545 0 222865
Klee 446899 6 33 4206
Symbiotic 1201 848 3 9 3529
4 COMPARISON
To illustrate the competitiveness of CPA-SymExec , we performed
a thorough comparison with KleeandSymbiotic on5590tasks of
the largest available benchmark set for verification tasks in C11.
Table1reportsforeachoftheapproachesthenumberof(1)correct
answersthatnopathexists,(2)correctanswersthatapathisfound,
(3) missed paths (i.e., a path exists but the tool did not find it),
(4) wrong paths (i.e., paths that cannot be executed in the program
semantics), and (5) unsolved tasks. The different approaches of the
threetoolsshowintheresults: Kleeisthestrongesttoolforfinding
pathsforauserquery; Symbiotic isthemostaccuratetool:itreports
the lowest numberof wrong paths, i.e., pathsthat are actually not
pathsforwhichtheuserwasquerying;and CPA-SymExec isthebest
toolforexhaustivelyexploringthestatespace:thetoolcorrectly
reports2137programsthatdonotcontainapathforwhichtheuser
was querying, and it did not miss any such path. This outperforms
bothKleeandSymbiotic.
5 CONCLUSION
We explained the architecture and basic concepts of CPA-SymExec ,
aswellastheprocessofrunning CPA-SymExec forverificationand
test-case generation. A more detailed tutorial video on YouTube
supports these explanations. CPA-SymExec inCPAchecker is a com-
petitive symbolic-execution engine that allows users to combine
symbolicexecutionwithabstractionand CEGAR.Inaddition,the
matureness of CPAchecker and the multitude of different abstract
domains,algorithms,andutilitiesthatareimplementedintheframe-
workallowanefficientimplementationofnewideasandaquick
adaptionofexistingtechniquesthatrelyonsymbolicexecution.
Acknowledgment. Wethankthecontributorsofthe CPAchecker
project(http://cpachecker.sosy-lab.org/acknow.php );CPA-SymExec
is based on many standard components of this framework.
11https://github.com/sosy-lab/sv-benchmarksREFERENCES
[1]D.Beyer.2017. SoftwareVerificationwithValidationofResults(ReportonSV-
COMP2017).In Proc. TACAS (LNCS 10206).Springer,331–349. https://doi.org/
10.1007/978-3-662-54580-5_20
[2]D. Beyer, A. J. Chlipala, T. A. Henzinger, R. Jhala, and R. Majumdar. 2004.
Generating Tests from Counterexamples. In Proc. ICSE . IEEE, 326–335. https:
//doi.org/10.1109/ICSE.2004.1317455
[3]D.BeyerandM.Dangl.2016. Verification-AidedDebugging:AnInteractiveWeb-
Service for Exploring Error Witnesses. In Proc. CAV (2) (LNCS 9780). Springer,
502–509. https://doi.org/10.1007/978-3-319-41540-6_28
[4]D. Beyer, M. Dangl, D. Dietsch, and M. Heizmann. 2016. Correctness Witnesses:
ExchangingVerificationResultsBetweenVerifiers.In Proc. FSE.ACM,326–337.
https://doi.org/10.1145/2950290.2950351
[5]D. Beyer,M. Dangl, D.Dietsch, M. Heizmann,and A. Stahlbauer.2015. Witness
ValidationandStepwiseTestificationacrossSoftwareVerifiers.In Proc. FSE.ACM,
721–733. https://doi.org/10.1145/2786805.2786867
[6]D.Beyer,M.Dangl,T.Lemberger,andM.Tautschnig.2018. TestsfromWitnesses:
Execution-Based Validation of Verification Results. In Proc. TAP (LNCS 10889).
Springer, 3–23. https://doi.org/10.1007/978-3-319-92994-1_1
[7]D.BeyerandT.Lemberger.2016. SymbolicExecutionwithCEGAR.In Proc. ISoLA
(LNCS 9952). Springer, 195–211. https://doi.org/10.1007/978-3-319-47166-2_14
[8]D.BeyerandT.Lemberger.2018. ReplicationPackageforArticle“CPA-SymExec:
EfficientSymbolicExecutioninCPAchecker”inProc.ASE’18. https://doi.org/
10.5281/zenodo.1321181
[9]C. Cadar, D. Dunbar, and D. R. Engler. 2009. KLEE: Unassisted and Automatic
GenerationofHigh-CoverageTestsforComplexSystemsPrograms.In Proc. OSDI.
USENIX Association, 209–224. http://www.usenix.org/events/osdi08/tech/full_
papers/cadar/cadar.pdf
[10]M.Chalupa,M.Vitovská,andJ.Strejcek.2018. SYMBIOTIC5:BoostedInstru-
mentation - (Competition Contribution). In Proc. TACAS (LNCS 10806). Springer,
442–446. https://doi.org/10.1007/978-3-319-89963-3_29
[11]E. M. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. 2003. Counterexample-
guided abstraction refinement for symbolic model checking. J. ACM50, 5 (2003),
752–794. https://doi.org/10.1145/876638.876643
[12]W.Craig.1957.LinearReasoning.ANewFormoftheHerbrand-GentzenTheorem.
J. Symb. Log. 22, 3 (1957), 250–268. https://doi.org/10.2307/2963593
[13]E. Ermis, M. Schäf, and T. Wies. 2012. Error Invariants. In Proc. FM (LNCS 7436).
Springer, 187–201. https://doi.org/10.1007/978-3-642-32759-9_17
[14]J. Jaffar, V. Murali, J. A. Navas, and A. E. Santosa. 2012. TRACER: A SymbolicExecution Tool for Verification. In Proc. CAV (LNCS 7358). Springer, 758–766.
https://doi.org/10.1007/978-3-642-31424-7_61
[15]R. Jhala and R. Majumdar. 2005. Path Slicing. In Proc. PLDI. ACM, 38–47. https:
//doi.org/10.1145/1065010.1065016
[16]Y. P. Khoo, J. S. Foster, M. Hicks, and V. Sazawal. 2008. Path projection for user-
centered static analysis tools. In Proc. PASTE . ACM, 57–63. https://doi.org/10.
1145/1512475.1512488
[17]D.Kim,YonghwiKwon,P.Liu,I.L.Kim,D.M.Perry,X.Zhang,andG.Rodriguez-
Rivera.2016. Apex:automaticprogrammingassignmenterrorexplanation.In
Proc. OOPSLA. ACM, 311–327. https://doi.org/10.1145/2983990.2984031
[18]J. C. King. 1976. Symbolic Execution and Program Testing. Commun. ACM 19, 7
(1976), 385–394. https://doi.org/10.1145/360248.360252
[19]H.D.T.Nguyen,D.Qi,A.Roychoudhury,andS.Chandra.2013. SemFix:program
repair via semantic analysis. In Proc. ICSE. IEEE, 772–781. https://doi.org/10.
1109/ICSE.2013.6606623
[20]A.Roychoudhury.2016. SemFixandbeyond:semantic techniquesforprogram
repair. In Proc. ForMABS. ACM, 2. https://doi.org/10.1145/2975941.2990288
903
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. 