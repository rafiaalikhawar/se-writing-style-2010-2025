A Unified Lattice Model and Framework for Purity Analyses
Dominik Helm
TU Darmstadt
Germany
helm@cs.tu-darmstadt.deFlorian Kübler
TU Darmstadt
Germany
kuebler@cs.tu-darmstadt.deMichael Eichberg
TU Darmstadt
Germany
eichberg@cs.tu-darmstadt.de
Michael Reif
TU Darmstadt
Germany
reif@cs.tu-darmstadt.deMira Mezini
TU Darmstadt
Germany
mezini@cs.tu-darmstadt.de
ABSTRACT
Analyzingmethodsinobject-orientedprogramswhethertheyare
side-effectfreeandalsodeterministic,i.e., mathematicallypure,has
been the target of extensive research. Identifying such methods
helps to find code smells and security related issues, and also helps
analysesdetectingconcurrencybugs. Puremethodsarealsoused
by formal verification approaches as the foundations for specifi-
cations and proving the pureness is necessary to ensure correct
specifications.
However, so far no common terminology exists which describes
the purity of methods. Furthermore, some terms (e.g., pureorside-
effect free ) are also used inconsistently. Further, all current ap-
proaches only report selected purity information making them
only suitable for a smaller subset of the potential use cases.
In this paper, we present a fine-grained unified lattice model
which puts the purity levels found in the literature into relation
and which adds a new level that generalizes existing definitions.
We have also implemented a scalable, modularized purity analysis
which produces significantly more precise results for real-world
programs than the best-performing related work. The analysis
shows that all defined levels are found in real-world projects.
CCS CONCEPTS
•Theory of computation →Program analysis ;•Software
and its engineering →Automated static analysis;
KEYWORDS
Purity, side-effects, static analysis, lattice, Java.
ACM Reference Format:
DominikHelm,FlorianKübler,MichaelEichberg,MichaelReif,andMira
Mezini.2018.AUnifiedLatticeModelandFrameworkforPurityAnalyses.In
Proceedingsofthe201833rdACM/IEEEInternationalConferenceonAutomated
Software Engineering (ASE ’18), September 3–7, 2018, Montpellier, France.
ACM,NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.3238226
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382261 INTRODUCTION
Static analyses that identify side-effect free and also deterministic,
i.e.,mathematicallypure,methodsinobject-orientedprogramshave
been the target of extensive research [ 25,35,37,38]. Identifying
such methods helps to improve analyses detecting concurrency
bugs [20] and to find security-related issues [ 20,37]. Pure methods
written in programming languages such as Java are also used by
formal verification approaches as the foundation for the respective
specifications [ 6,15,16]. In that case, it is necessary to prove a
method’s purity to ensure that the formal specifications are cor-
rect. The identification of (mostly) pure methods further facilitates
program comprehension [ 7,18], provides opportunities for code
optimizations[ 11,28,43],andsupportstestingaswellasautomated
verification [ 41]. Recent trends towards a more functional style of
programmingrelyingonpuremethods[ 1],alsodemonstratethe
overall relevance.
However, no common terminology exists which describes the
purityofmethods[ 34]andsometerms(e.g., pureorside-effectfree )
arealsousedinconsistently.Further,allcurrentapproachesonly
report selected purity information andare thus only suitable for a
small subset of potential use cases. Identifying side-effect free and
deterministicmethodsenablescompilerstoperformcompiletime
evaluations.Formalverificationapproachesneedtheinformation
to ensure correctness. Detecting concurrency bugs and code smells
requiresjustside-effect free methods while code comprehension
can benefit from all levels and also weakened forms of purity.
In this paper, we present a fine-grained unified lattice model for
specifying a method’s purity. In the model, each of the 13 lattice
elementshasawell-definedsemanticsandisputintorelationtothe
purity levels found in the literature. The model is extended by the
level(ContextualPurity )whichgeneralizestheso-called External
Purity[7]. Being able to ignore specific operations in specific con-
texts[37],e.g.,logginginbusinessapplications,isalsosupported
andgeneralizedto Domain-specificPurity.Theproposedmodelis
sufficiently detailed for all identified use cases. Furthermore, the
purity levels (External andContextual Purity) support purity analy-
ses to rate methods as pure if the called methods have side-effects
thatarelimitedtothecaller.Therefore,thelatticemodelisalsoa
suitable target for modular purity analyses that reason about each
methodinisolation.Additionally,wepresentascalable,purityanal-
ysis that produces more precise results ( >4%) for real-world code
thanthestate-of-the-art.Theanalysisinferspurityforindividual
methodsinisolationandreliesontheresultsofseveralindependent
340
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dominik Helm, Florian Kübler, Michael Eichberg, Michael Reif, and Mira Mezini
analyses. Using the analysis, we will show that all defined levels
are relevant when analyzing real-world projects.
InSection 2wewilldiscussthestate-of-the-art.Afterthat,we
will present the Unified Lattice Model in Section 3. The implemen-
tation of the proposed analysis (OPIUM1) is discussed in Section 4
and evaluated in Section 5. Section 6concludes the paper.
2 RELATED WORK
Inthefollowing,wediscusspreviousresearchonpurity.Wewill
presentthepuritydefinitionsfoundintheliteraturealongsidewith
the proposed analyses. We will start with those approaches that
focus on identifying side-effect free methods – independent of the
question whether the methods are also deterministic or not. After
that,wewilldiscussthoseapproachesthatrelyonstricter purity
definitions [5, 13,23,25,26,32,33,38,39].
2.1 Side-Effect Free Methods
One of the most commonly used definitions of method purity is
given by Sălcianu and Rinard [ 38,39] where a method is pure if
“it does not mutate any object that exists in the pre-state, i.e.,the
program state right before the method invocation ". This definition
does not capture deterministic behavior, but it ensures the absence
ofside-effects.Theiranalysisiscombinedwithapointeranalysis
([24]) and also supports the identification of individual parameters
that areread-only orsafe. Read-only parameters are parameters
of a method where no object transitively reachable through this
parameter is mutated by the method. Safe parameters additionally
require that no new externally visible paths to objects reachable
throughthemarecreated.Toclassifytheparameters,theiranalysisisabletodeterminewhichmemorylocationsmaybemodifiedbya
method. The analysisis used in the Korat [ 8,31] tool to checkthe
purity of methods specifying the behavior of data structures.
The same definition of purity is used by Huang et al. [ 25,26].
They propose to extend the Java type system and present a type
inferencealgorithmtoannotatereferencesas read-only.Inthetype
system, pure methods are those that do not modify global state
through static fields and that do not have any parameters inferred
as mutable. The authors suggest to use the approach to find errors
or to do optimizations in concurrent programs.
Pearce [33] uses a similar definition. His JPure system checks
that methods annotated as puredo not modify previously existing
program state. It is also capable of inferring purity annotations for
code that is not annotated.
GenaimandSpoto[ 23]againrefertoamethodaspure,ifitdoes
notmodifytheheapstructuresreachablefromanyofitsparameters.
Theirconstancyanalysisidentifiestheparameterswhicharenot
used to modify the reachable heap. The analysis uses alias relation-
ships between the parameters expressed as boolean formulas.
Inthe approach proposedby Ierusalimschyand Rodriguez[27]
side-effect free methods are allowed to allocate new objects and
returnthemaslongasthepre-stateisnotmodified.Theyrelyon
manual annotations that mark methods as side-effect free. Theirgoal is to extend the type system and to automatically check the
respective methods for conformance at compile-time.
1OPAL Purity Inference based on a U nified lattice M odel.Incontrast,adynamicanalysistofind puremethodsisdescribed
byDallmeier[ 13].Theanalysisexplicitlydealswithmultithreading
and especially the fact that constructors, while they may assign to
fieldsofthecurrentlyinitializedobject,canbepure.Hisanalysis
results are used for ADABU, a tool for mining object behavior that
requires information about side-effect free methods for classifying
methods as observers and mutators [14].
The definition of side-effect free methods used by Rountev [ 35]
is stricter than the previous ones. While it does allow allocation of
newobjects,thesemaynotescapetothecaller.Theproposedmodel
assumessingle-threadedexecutionasthepre-stateofthemethod
couldbemodifiedbyconcurrentlyexecutingmethodsotherwise.
They describe two analyses based on RTA ([ 3]) and a points-to
analysis to identify side-effect free methods in partial programs.
Naumann [ 32] andBarnett et al.[ 5,6] introducethe idea of ob-
servationalpurity.Suchmethodsareallowedtohaveside-effects
thatarenotobservablebytheircallers.Thisdefinitionespecially
allowsforcaching(intermediate)results,asisdoneinmemoization.Itisonlyvalidinlanguageswithoutunrestrictedpointerarithmetic
where noninterference properties can be proven [ 4]. Methods that
areobservationally pure could be used in program specifications
written in, e.g., ESC/Java [ 21] and JML [ 29]. Traditionally, these
languages requiredstronger restrictions(no useof methods inES-
C/JavaatallandonlyprovablypuremethodsinJML).Theanalysis
they propose to determine observational purity is built upon an
information-flow analysis [36].
ESC/Java2[ 12]usesside-effectfreemethodsforspecifications,
but relieson programmer specified annotations toidentify them.
The authors also recognize that determinism is required for specifi-
cations,butdonotprovideawayofidentifyingmethodsthatare
deterministic and side-effect free.
Table1summarizesthedifferentapproachestodetectingside-
effect free methods and the terminology used by the authors.
2.2 Deterministic Purity
Aside from not performing side-effects, deterministic behavior (i.e.,
producingthesameoutputswheneverinvokedwiththesamepa-
rameters)isanecessaryconditionformethodstobereferentially
transparent. This is required for compiler optimizations as well as
formal specifications.
The term functionally pure for methods that are deterministic
and side-effect free is introduced by Finifter et al. [ 20]. They use a
subsetoftheJavalanguagecalledJoe-Ethatrestrictssomefeatures
ofJavathatarenon-deterministicorcauseside-effects,including,
mutablestaticstateandaccesstothestacktraceofexceptions.Pure
methods are automatically thread-safe, as they can never interfere
withotherthreads,andnosynchronizationisrequired.Thisallows
for verifying security properties such as the correct behavior ofencoding and decoding methods. They also suggest using side-
effect free methods for assertions and specifications. Similar to the
concept of Huang et al. [ 26], methods that only have immutable
parameters can never cause side-effects or be non-deterministic, so
pure methods can be easily identified.
Intheirworkondynamicpurityanalysis,Xuetal.[ 42]define
several levels of purity. Strongly pure methods must be side-effect
341
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. A Unified Lattice Model and Framework for Purity Analyses ASE ’18, September 3–7, 2018, Montpellier, France
Table 1: Summary of analyses for side-effect free methods
Authors Analysis type Purity levels (as named by authors)
Sălcianu/Rinard [38, 39] pointer analysis pure
Huang et al. [25, 26] type system extension pure
Pearce [33] annotations pure
Genaim/Spoto [23] parameter mutability pure
Ierusalimschy/Rodriguez [27] type system extension side-effect free
Dallmeier [13] dynamic purity analysis pure
Rountev [35] static purity analysis side-effect free
Barnett et al. [6] information flow analysis strongly pure, observationally pure
Table 2: Summary of analyses for deterministic pure methods
Authors Analysis type Purity levels (as named by authors)
Finifter et al. [20] type system/restricted language side-effect free, functionally pure
Xu et al. [42] static & dynamic purity analysis strong, moderate, weak, once-impure
Zhao et al. [43] static purity analysis pure
Benton/Fischer [7] type-and-effect system pure, read-only, externally pure, externally read-only
Stewart et al. [37] type system extension strict, strong, weak, externally pure
freeanddeterministicandareonlyallowedtohaveprimitivepa-
rameters, thereby excluding reference type parameters completely.
They may also not create any new objects or call impure methods,
eveniftheeffectsofbotharenotvisibletothecaller. Moderately
puremethodsaresimilarintheconstraintsontheirinputs,butmay
create new objects as long as they don’t escape the method execu-
tion context,similar tothe definition ofRountev [ 35] above.They
may also call impure methods if their effects are not observable by
the caller. The restriction on reference types is partially lifted in
weaklypure methodsthatmayaccessfieldsofobjecttypeparam-
eters. A rather unique concept is once-impure purity that allows
methods to be impure on their first, but not on subsequent invo-
cations. The authors do not detail the uses cases, but it seems that
they want to support lazy initialization patterns. While their work
focuses on dynamic analysis, they also present a static analysis for
strongpurity.Theanalysisdividesthebytecodeinstructionsexe-
cuted bya methodinto impure andpure instructions. Forweaker
purity levels, some instructions are considered pure only when
they are performed on locally allocated, non-escaping objects. The
analysis results are used to support automated memorization of
methodresults.Thisispossiblebecausetheresultsofpuremethods
are the same when invoked again with the same parameters.
Zhaoetal.[ 43]exploredifferentapproachestofindpuremeth-
ods: automated checking of programmer supplied annotations and
two static analyses based on a method’s bytecode. The purity in-
formationisthenusedinsidetheJikesVM[ 2]tosupportfurther
analyses and optimizations such as the elision of method calls. Un-
necessarysynchronizationcanberemovedaspuremethodsdonot
require synchronization with another thread.
Externalpurity isintroducedbyBentonandFischer[ 7].Exter-
nallypuremethodsareallowedtoreadandmodifymutablestate,
but only on the receiver object of a call. Constructors that leak the
reference to currently initialized objects are ignored as the authors
considerthistoberare.Theweakerpuritylevel externallyread-onlyallows methods to modify the state of the receiver object as above
andtoreadanymutablestate.Theyshowthatalargepercentage
of methods in object-oriented programs fulfills these conditions
using a type-and-effect system [30].
Stewart et al. [ 37] extend ReImInfer [ 25] by combining previous
definitionsofpurityintofivelevelsofside-effects.Fortwoofthe
proposed levels strict purity (no local variable assignments are
allowed) and strong purity (no allocation of objects are allowed) no
use cases were identified and – as the authors admit – both are of
nopracticalrelevance.Theyalsodiscussthreepropertiesrelatedto
Input,OutputandDeterminism,buttreatthemasorthogonaltothe
puritylevels.Acoherentlatticemodelisnotdefined.Lastly,thetool
is not available rendering an empirical evaluation of it impossible.
A summary of approaches identifying deterministic pure meth-
ods and the terminology used by the authors is given in Table 2.
3 MODEL
Inthefollowing,wediscusstheunifiedlatticemodelbydefiningthe
differentpuritylevelsandtheirrelationsaswellasbycomparing
them to the levels defined in the literature. The presented modelis generic and can be used for any object-oriented programming
language. Examples in the following sections are in Java.
3.1 Purity Levels
Wefirstintroduce side-effectfree asitbuildsthefoundationforother
levels. We will then proceed to discuss purity, before we finally
present weaker purity levels.
3.1.1 Side-effect Free Methods.
Definition 1. A method is side-effect free if all object-graph
manipulations, which are performed by the method or its callees, are
only visible to the method while it is executed, i.e.,all manipulations
are invisible to a method’s client.
342
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dominik Helm, Florian Kübler, Michael Eichberg, Michael Reif, and Mira Mezini
Here, the object graph is considered to also include the system’s
resources, e.g. the file system, network etc. and therefore methods
manipulating these resources are not side-effect free.
Thisdefinitionrefinesdefinitionsfoundinpreviousworkwhich
are based on pre-state manipulations. In a multi-threaded environ-
ment,amethodinvocations’exactpre-stateandwhetherchanges
toobjectsallocatedonconcurrentthreadsconstituteaside-effect,
is unclear. A particularly problematic definition is that of Roun-
tev[35],wheretheobjectgraphmustbeequivalentbeforeandafter
the method invocation. With concurrently executing threads, even
atemporarychangeoftheobjectgraphcanaffecttheresultsofthe
program. The proposed definition can be applied in multi-threaded
environments, as it explicitly refers to the visibility of side-effects,
i.e.,itdoesnotmatterwhetherthemethod’spre-stateismodified
or not.
This definition also allows side-effect free methods to return
newly allocated objects, as the modification of the object graph
only become visible to the direct caller after the method execution.
Side-effectfree methodsmayinvokemethodsthatarenot side-
effect free themselves, iff the caused side-effects are confined to the
calling method, i.e.,the side-effect is invisible to callers of the side-
effect free method. An example is shown in the following Listing 1:
1classCounterValue {
2public static int counter;
3private int value;
4public static CounterValue getCurrentValue(){
5CounterValue current = newCounterValue();
6current.setToCounter();
7returncurrent;
8}
9private void setToCounter(){
10value = counter;
11}
12}
Listing 1: A side-effect free method.
As the method setToCounter modifies its receiver object, it
has a side-effect. However, when setToCounter is invoked by
getCurrentValue ,thisside-effectisconfinedtothemethod’sscope,
i.e., the side-effect occurs on a newly allocated object that is in-
visible to other methods than getCurrentValue until it finishes
execution. Thus, getCurrentValue isside-effect free.
java.lang.System.currentMillis() is a Java example of a
side-effect free method.
Further,methodsthatperformsynchronization–exceptlocking
of objects inaccessible by other threads – are not side-effect free
astheychangethemonitor’s statecausingchangestoanobject’s
objectgraph.Hence,concurrentlyexecuted side-effectfree methods
can not cause deadlocks, livelocks, or race conditions since they do
not modify any state that is visible outside their execution scope.
Side-effect freeness is the foundation of further purity definitions
and many authors refer to side-effect free methods as pure(e.g. [26,
33,38]).Inordernottoconfuseside-effectfreenesswithfunctional
purity–thatalsorequiresdeterministicbehavior–,wewillrefer
tonon-deterministicmethodswithoutside-effectsas side-effectfree
as in [27].3.1.2 Pure Methods.
Definition 2. A method is pureif it isside-effect free and addi-
tionally produces a structurally equal, deterministic result each time
themethodisinvokedwithidenticalparametersduringoneexecutionofaprogram.Tworeferenceparametersareidenticaliftheyreference
the same object. The results are structurally equal if the returned ob-
ject graphs are isomorphic; ignoring aliasing relationships. Primitive
parameters are identical and structurally equal if both values are the
same.
This definition is similar to that of weak purity as described
by [37]o r[42] andensures referential transparency, i.e.the possi-
bility of replacing the method’s invocation by its result.
1final static double PI = 3.1415;
2static double getArea(double radius){returnradius∗radius∗PI; }
Listing 2: A pure method.
Themethod getArea,showninListing 2,ispurebyourdefini-
tion. It deterministically computes the circle’s area with the givenradius and is free from side-effects.
Deterministicbehaviorcanbeachievedwhenneithermutable
globalstateisusednornon-deterministicmethodsarecalled.Please
note that determinism is not influenced by immutable global state
likethemathematicalconstant PIinListing 2and,therefore,use
of immutable global state is allowed.
In multi-threaded programs, fields of reference-type parameters
may change during the execution of the method due to concur-
rent threads. We therefore restrict accesses to immutable fields.
Others have opted for more restrictive approaches, e.g.,Xu et al.
onlyallowvalue-typeparametersfortheirdefinitionsof strongly
andmoderately puremethods[ 42].Alternatively,onlyimmutable
reference-type parameters can be allowed [20].
We do not apply special treatment to data that is immutable
duringtheexecutionofaprogram,butmaybeinitializeddifferentlyinanotherprogramexecution. Puremethodsmayusesuchdataand
mayreturndifferentresultsacrossdifferentprogramexecutions.As
long as the results are identical during a single program execution,
those methods are considered pure.
Duetotheexistenceofaliasing,itisnecessarytodefinewhen
parameters of different invocations are considered equal. We re-quirepuremethods to return the same result when objects with
the same identity are passed as parameters, i.e.,objects at the same
memory location. This restriction eases the implementation, asit allows to treat comparisons for reference (in)equality as deter-ministic. As mutable state from objects may not be accessed bypuremethods, it is not necessary that all objects reachable via a
parameter or primitive fields of a parameter object are identical
too. If the parameter object itself has the same identity, different
field values can only arise for mutable fields that can not be ac-
cessed by puremethods anyway. For a method’s result, we require
structurally equal object graphs, i.e.,isomorphic graphs without
respectofaliasingrelationships.Therefore,methodsareallowedto
return a newly allocatedobject for every execution. A potentially
counterintuitiveconsequenceisthatitisunsoundtoreusea pure
method’sresultinsteadofreevaluatingitwhentheresultmaybe
subject to a reference equality test as in Listing 3:
343
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. A Unified Lattice Model and Framework for Purity Analyses ASE ’18, September 3–7, 2018, Montpellier, France
1Object a = pureMethod();
2Object b = pureMethod();
3if(a == b) [...]
Listing 3: A problematic reference equality check.
Withoutfurtheranalysis,thismayneitherbereducedtoasingle
call, nor may the calls be compile-time evaluated to a single or two
distinct result objects.
One important limitation of this definition is that puremethods
canonlyreturnthosemutableobjectsforwhichtheobjectgraph
is guaranteed to be structurally equal across method calls with
identical parameters. For example, getArray , depicted in Listing 4,
is notpure, as the content of the array may change in between
methodinvocations.Whileitisdifficulttoprovestructuralequality
oftheobjectgraphingeneral,manypracticalcasesareeasytofind,
e.g.allocationanddeterministicinitializationofamutableobject
will yield deterministic results if the object does not escape the
method’s execution context before being returned.
1final static int[] array = new int[ ] {1} ;
2static int[] getArray(){
3returnarray;
4}
Listing 4: A method that is not pure.
3.1.3 External Purity.
Definition3. Amethodis externallypure (externallyside-effect
free) if its invocation may lead to a modification of its receiver, but is
pure(side-effect free) otherwise.
Externallypure methodscanbeusedtoidentifyadditionalmeth-
odsaseither pureorside-effectfree whencallersofrespectivemeth-
ods know, that the receiver object is confined to their context,
i.e.,the receiver of the externally pure method does not escape the
methodsscope.Furthermore,aclientanalysiscanusethispurity
level to trivially identify methods that break abstractions bound-
ariesby,e.g.,mutatingglobalstate.AsrecognizedbyBentonand
Fischer [7], it is beneficial to identify such methods to improve
program comprehension.
1public class A{
2public int f;
3public void setField(int value){
4f = value;
5}
6}
Listing 5: A field’s setter that is externally pure.
Listing5gives an example of an externally pure method. It is de-
terministic and its only side-effect is the write to the field fwhich
belongs to the same receiver object as the method.
Finding methods that are externally pure is essentially a special-
ized form of side-effect analysis.
External purity also applies to methods that use synchroniza-
tion on the receiver object. This includes methods that have the
synchronized modifieraswellasmethodswithexplicitsynchro-
nizationonthereceiverobject.Thisfollowsdirectlyfromtheabovedefinition, as the monitor, that is used to perform the synchroniza-
tion, is modeled as a property of the object.
In contrast to Benton and Fischer, we treat methods reading the
receiver’s mutable state as side-effect free instead of externally pure.
This enables us to classify methods with calls on non-confined
receiverobjectsas side-effectfree ratherthan impure.Thedrawback
is that a caller that invokes such methods on a confined receiver
object can not be pureanymore.
3.1.4 Contextually Pure.
Definition4. Amethodis contextuallypure (contextuallyside-
effectfree)ifitsinvocationmayleadtoamodificationofatleastone
of its parameters, but is pure(side-effect free) otherwise.
We define contextual purity as an extension of external purity.I t
captures methods that potentially modify any of their parameters
instead of only their receiver. While contextually pure methods
breakabstractionboundaries,theyarestilllessproblematicthan
methodswithside-effectson(static)globalstate.Also,theyallow
identifyingmoreside-effectsasconfinedifitisknownthatnoneof
their actual parameters are visible outside of their caller.
1public class A{
2public int f;
3public static void modifyA(A a, intvalue){
4a.f = value;
5}
6}
Listing 6: A contextually pure field setter
Consider modifyAinListing 6.Itsonlyside-effectistomodify
parameter a’sstatedeterministically.Thus,itis contextuallypure.
Anexampleofaveryfrequentlyused contextuallypure Javamethod
isSystem.arraycopy() .Itmodifiesthegiventargetarrayandis
used in implementations of many core data structures.
3.1.5 Domain-specific Purity.
Definition5. Amethodis domain-specificpure (domain-specific
side-effect free)i fi ti s pure(side-effect free) when the effects of cer-
tain instructions – belonging to a certain domain – are ignored. Here,
two parameterized instructions with different parameterizations are
considereddifferent instructions,e.g., twofield accessinstructions on
different fields.
Sometimes,methodsperformside-effectcausingoperationsthat
neithercanbeclassified purenorside-effectfree byusingthepro-
poseddefinitions.However,whenhavingacloserlook,thoseop-
erations neither influence the method’s result nor lead to effects
on other methods. For instance, a method that writes a log file
admittedly causes a side-effect but this kind of side effect can be
toleratedbecauseithasnodirectinfluenceonanyothermethod.
This property kind was previously identified by Steward et al. [ 37].
1static final double PI = 3.1415;
2static double getArea(double radius){
3System.out.println("called getArea");
4returnradius∗radius∗PI;
5}
Listing 7: A domain-specific pure method performing
logging.
344
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dominik Helm, Florian Kübler, Michael Eichberg, Michael Reif, and Mira Mezini
ImpureDomain-specific contextually side-effect freeDomain-specific externally side-effect-free Contextually side-effect free Domain-specific contextually pureDomain-specific side-effect free Externally side-effect free Domain-specific externally pure Contextually pureSide-effect free Domain-specific pure Externally purePure
Figure 1: The unified lattice for purity information
Consider the method getArea in Listing 7: Usually, the pro-
gram’s execution will not depend on the output from the println
statement. Thus, themethod can be considered as domain-specific
pure. The possibility of classifying logging as pure is important for
theanalysisofenterpriseapplicationsthatincludelogginginmany
methods.
Anotherexampleofdomain-specificbehaviorisraisingexcep-
tions.Thisisnotpure,asnewlyconstructedexceptionscontainthe
currentstacktraceandthatisnotdeterministicw.r.t.parameters
of the method invocation. For example, two method invocations
withidenticalparametersmaynotleadtoexceptionswiththesame
stack trace. However, as the stack trace is usually not inspected by
theprogram,treatingitas domain-specificpure allowstoclassify
further methods as effectively deterministic.
Incontrasttopreviouswork(e.g.[ 42])whichonlytreatsexplicit
exceptionsandignoresimplicitones(e.g. NullPointerException s
raised by the JVM), our handling allows to consistently treat im-
plicitly and explicitly thrown exceptions.
3.1.6 Orthogonal Purity Properties. The previously defined purity
levelscapturefourdifferentproperties:(1)deterministicandnon-
deterministic behavior (pure vs.side-effect free ), (2) modification
ofthereceiverobject(externalpurity ),(3)modificationofformal
methodparameters(contextualpurity ),and(4)non-deterministicor
impureactionsthatmaybeconsideredpureinsomecircumstances
(domain-specificpurity ).Thesepropertiesareorthogonaltoeach
other,i.e.,everypropertycombinationispossibleexceptfor external
andcontextual purity, as the latter subsumes the first.
We define the combinations of externally pure andcontextual
purewithdomain-specificpure togetthebenefitsof externaland
contextualpurity.Thisallowstoapplytheconceptof domain-specific
purityto methods that modify their receiver or parameters.
Definition 6. A method is domain-specific externally pure
(domain-specificexternally side-effectfree)ifitis externallypure
(externally side-effect free) and ignores the effects of specific instruc-
tions.
Definition7. Amethodis domain-specificcontextuallypure
(domain-specificcontextuallyside-effectfree)ifitis contextually
pure(contextually side-effect free) and ignores the effects of specific
instructions.3.1.7 Impurity. When a method does not have any of the previ-
ously described properties and, therefore, no previous purity level
can be assigned, we refer to it as Impure.
3.2 Purity Lattice
We arrange the purity levels defined above into a single, unified
latticethatcapturestheir relationships. Thelatticeenablesamono-
tone framework for increasingly precise purity analyses that are
able to refine previous analyses’ results.
The purity lattice is depicted in Figure 1. Its top element is
pure,thestrictestpuritylevel.Eachstepdownthelatticeloosens
exactly one restriction on the method: Side-effect free allows for
non-deterministicbehavior, domain-specific allowsdomain-specific
side-effects like logging, and externally allows modifications on
theimplicit thisparameter. Contextually loosensfurtherrestric-
tions,allowingmodificationallformalmethodparameter(including
this).Impurerepresentsbottomvaluethatplacesnorestrictions
on the method.
4 PURITY ANALYSIS
The purity analysis’ implementation is based on the fix-point com-
putations framework (FPCF) provided by OPAL [ 19]. The frame-
work supports a decoupled implementation of mutually dependent
analysesandautomaticallyresolvescyclicdependenciesinasound
manner. Using this framework enabled us to factor out analyses
that provide generally useful information into separate modules
to facilitate the comprehension of the purity analysis. Figure 2
provides an overview of the analyses that are used by the purityanalysis and their dependencies. We used independent analysesfor determining a class’ (im)mutability, the locality of fields, the
freshness of return values, and to enable inference of escape infor-
mationforlocalvariables.Inthefollowing,whenwetalkabout the
analysis, we are always referring to the purity analysis OPIUM.
All createdanalyses use OPAL’sthree-address code representa-
tion of Java bytecode. The latter is based upon an intra-procedural
data- and control-flow analysis and natively provides def-use in-
formationaswellasrefinedlocaltypeinformation.Furthermore,
lambdaexpressionbased invokedynamic callsareresolvedusing
standard virtual methods calls and objects.
345
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. A Unified Lattice Model and Framework for Purity Analyses ASE ’18, September 3–7, 2018, Montpellier, France
Field Locality
Class Immutability
Type ImmutabilityEscape
Virtual Method Escape Return Value Freshness
Virtual Method
Return Value FreshnessField Mutability
Purity
Virtual Method Purity
Figure 2: Dependencies between analyses used for purity analysis
4.1 Analysis Workflow
Our analysis ( Purityin Figure 2) determines the purity level (cf.
Figure1) for each non-abstract method. It works as follows: When
westartanalyzingamethodweassumethatitis pure–thelattice’s
topvalue.Wethencheckeachstatementofthemethodifitviolates
thecurrentlyassumedpurityleveland–ifso–reducethepurity
leveltothenextbeststatethatisnotviolated.E.g.,whenthecur-
rently assumed level is pureand an exception object is created the
level is decreased to side-effect free . Statements that access fields
or other methods are initially ignored; instead a dependency on
themisrecorded.Afteranalyzingallstatements,theinitialresult,
which consists of the currently assumed purity level and all depen-
dencies, is passed to the framework. The information about the
dependencies is used by the framework to call back the analysis
when the required information regarding dependencies is updated.
Theanalysesthenupdatesitsassumedpuritylevelaccordinglyand
also the set of (still) relevant dependencies and passes both back
to the framework. The analysis of a method has completed if there
arenomoredependenciesthatmayaffecttheassumedpuritylevel;
the later is then the final purity level. If a cycle is found by theframework, it is automatically resolved by assuming the currentderived purity level for the methods within the cycle. The latter
is correct as it is the best solution that takes all dependencies into
account.
4.2 Effect of Instructions
In the following, we discuss the instructions that may affect a
method’spurity.Instructionsrelatedtomathematicaloperations
andconstants,typechecksandcasts,ortothecontrolflow(e.g., add,
if,o rgoto) never affect a method’s purity and thus are ignored.
FieldAccesses :Fieldreads( GetField orGetStatic )introduce
non-determinismwhenthereadfields’valuescanchange;i.e.,when
the fields are not (effectively) final. Therefore, the best possiblepurity level will be
side-effect free unless the receiver object of
thefieldaccessislocaltothemethod.Forexample,accessestoa
field of a newly created, non-escaping object are ignored. A field’s
mutability is determined by the respective analysis.
Notethatitissufficienttorequirethatfieldsthatareaccessedare
(effectively) final, this ensures that the read value is never changed.
While the read value may be a reference to a mutable object or
array,thatmutabilitycanonlybeobservedifanotherfield/array
access is performed on the acquired reference.
Writingstaticfields( PutStatic )alwaysreducesthemethod’s
purity to impure. Instance field writes ( PutField ) effect the purity
if the written object is not local (cf. Locality). If the receiver of thefieldaccessistheselfreference( this)ofthemethod,thebestpurity
levelwillbe externalpurity .Ifthereceiverisaformalparameterof
the method, the method is at most contextually pure.
Array Accesses : We consider arrays as being objects where all
fields(arrayentries)aremutable. ArrayLoad andArrayStore in-
structionsarehencehandledequivalentlytoinstancefieldaccesses.
Synchronization :Wetreatexplicitacquisitionsandreleasesof
monitors( Monitorenter ,Monitorexit )aswritesofan(implicit)
field monitor.
Return fromMethod :Amethodwhichreturnsareferenceis
deterministic only if the returned object graph is guaranteed to be
structurally equal (cf. Section 3) across method invocations. Other-
wise, the best possible level is side-effect free . Structural equality is
guaranteedifthereturnedreferenceisfreshandnon-escapingor
ifthereturnedobjectisimmutable.Thelatterpropertyisderived
by an independent class- and type immutability analysis.
MethodCalls :Thepurityofthecalledmethod–independent
of the underlying instruction (e.g. StaticCall, VirtualCall )–
determines the purity of the caller as follows: If the callee’s pu-
rityispure,side-effectfree ,domain-specificpure orimpure,thebest
possiblepurity levelforthecallerwill bethatofthe callee.Foranexternallypure
callee, the best possible level for the caller depends
on the receiver object of the call. The caller can be pureif it is
local and non-escaping. If it is the receiver object of the caller or
oneofitsformalparameters,thecaller’spuritycannotbebetter
thanexternally pure orcontextually pure ,respectively.Inallother
cases,thecallermustbe impure.Contextuallypure callee’sarehan-
dled in the same way, except that all of their parameters, including
theirreceiverobject,mustmatchthegivencondition.Callerswithacombinedpuritylevelarehandledlikeseparatecalleeswiththeindi-
vidual levels; e.g. a callee that is
domain-specificexternalside-effect
freerequiresthatthecallerisnotbetterthaneachof side-effectfree ,
domain-specific pure andthepuritylevelthatwouldbetheresult
of anexternally pure call on the same receiver object.
In case of a virtual method call, the callees are identified using a
Class Hierarchy Analysis -based call graph. Results by Rountev [ 35]
showthattheuseofamorecomplexcall-graphalgorithmhasonly
minor impact on purity results.
We manually assigned purity levels to some native methods
(e.g., StrictMath.sqrt ,System.arraycopy )toimprovethepreci-
sion of the analysis. As other purity analyses [ 26,39], we also
use this mechanism to specify the following methods as pure:
hashCode ,equals, and compareTo . However, we do not handle
toString specially (as others) since assigning correct purity lev-
elsfor StringBuilder andStringBuffer ’sappendandtoString
methods suffices to correctly classify most toString methods.
346
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dominik Helm, Florian Kübler, Michael Eichberg, Michael Reif, and Mira Mezini
Calls that are part of logging or console output are treated
asdomain-specific ,i.e., domain-specific pure is used instead of the
callee’s actual purity level.
Allocation of Objects Allocations of objects in general do
not influence a method’s purity, besides the effect that invoking
their constructor has according to the rules for method calls asabove. The constructor of
Throwable – the superclass of all ex-
ceptions – is, however, impureby definition because it invokes
fillInStackTrace which might be impurely overridden by a sub-
class. This is a problem as exceptions occur frequently and should
not in general result in impurity. Wetherefore treat Throwable ’s
constructor as side-effect free2and individually examine all sub-
classesof Throwable thatoverride fillInStackTrace .Call-sites
of exception constructors are treated as domain-specific pure.
4.3 Special Cases
Besides explicit statements, there are implicit effects on a methods
purity that are also checked by the analysis.
SynchronizedMethods :Ifamethodis synchronized assuch,
the purity level will be at most externally pure ; it is equivalent to
writing an (implicit) field monitor on the method’s receiver object.
Implicit Exceptions Exceptions may not only be allocated ex-
plicitly,buttheJavaVMalsoraisesexceptionsonseveraloccasions,
e.g.,aNullPointerException is raised when a method call’s re-
ceiver is null. We recognize these implicit exceptions by exam-
ination of the control-flow graph (for exceptions that terminate
themethod’sexecution)aswellas CaughtException statements.
Thoseareagaintreatedas domain-specificpure ,astheconstructors
ofallexceptiontypesthatarepotentiallycreatedbytheJavaVirtual
Machine knowingly do not have any side-effects.
4.4 Locality
Modifications of objects that are constrained to the scope of a
specificmethodcanbeignoredwhencomputingthepurityofsuch
methods;insuchcasestheside-effectisconfinedandthemethod
canstillbepure.Suchobjectsarecalled Localandinordertoidentify
them, we implemented an escape analysis. The analysis derives
three different escape values, namely NoEscape ,EscapeViaReturn ,
andGlobalEscape (cf.[10]).Objectswithalifetimethatisbounded
tothecreatingmethod’sscopehavetheproperty NoEscape .Ifsuch
an object is returned by a method, the escape value is Escape Via
Return.Global Escape is used for all other objects.
Theescapeanalysiscomputestherespectivepropertyforeach
intra-proceduraldefinitionsite.Thatis,forallformalmethodpa-
rameters,everyobjectandarrayallocationsite,allcallsofmethods
that return an object and all field reads. The def-use information
providedbyOPALisusedtoidentifyeveryusesiteandtopropagatetheeffectoftheusesitebacktothedef-site.Forexample,iftheonly
use-site is a return statement, the escape state of the respectiveobject is
Escape Via Return . The analysis is field-insensitive, i.e.,
whenever an object is stored in a field it assumes a Global Escape.
Usingtheresultsofthebasicescapeanalysis,weidentifylocal
objectsbyexaminingalltheirdefinitionsites.Areferenceisconsid-
eredlocalifitis:(1)freshlyallocated,(2)a fresh return value [22],
2Themethodisnot pureastheincludedstacktracedependsonthecurrentlyexecuted
method’s context and not only on its parametersor (3) alocal field [33]. Whereas the locality for new allocations
is trivially computed, we designed separate analyses – both de-
pending on the escape analysis’ results – that identify fresh return
values and local fields. A method’s return value is considered fresh
if it is a newly allocated object or the result of a call to a method
with a fresh return value. Furthermore, it must have the escape
propertyEscapeViaReturn .Whenretrievingthereturnvaluefresh-
ness information for virtual calls, where the precise type of the
receiverisnotknown,weaggregatetheresultsforallpotentialcall
targets.Afieldisconsideredlocal[ 33]whenitsowninginstance
is local, all objects stored in the field are local, and no read value
escapes(NoEscape ).Thelatteranalysisrequiresspecialhandlingof
java.lang.Object ’sclonemethod which creates a shallow copy
of an object – including all private fields of the object. Hence, a
fieldmightescapeevenifno GetField instructionispresent.As
mitigation, the analysis determines whether the object’s class –
whose field is under examination – overrides cloneand stores a
local object into the field of the new object. For classes that neither
override clonenor implement the Cloneable interface, we can as-
sume that the field is local if the class is final. In case of a non-finalclass,wheretheruntimetypeispreciselyknown,thefieldmayalso
be considered to be local.
Furthermore, we have extended the field and return value analy-
ses in order to deal with getter methods, i.e. instance methods that
retrieve and return a field with thisas receiver.
4.5 Threats to Soundness
Ouranalysisconsidersmethodsforwhichtheimplementationis
not available, this in particular includes native methods, as impure
unless explicitly specified differently. Therefore, it is sound even in
thepresence oflocal useofreflection or sun.misc.Unsafe which
leadstotheinvocationofnativemethods.Non-localeffectsofsuch
callsaswellasreflectivefieldwrite-accessesmayhoweverbreak
theanalysis’assumptions,andthereforeresultinunsoundresults.
5 EVALUATION
Our evaluation focuses on answering three research questions:
RQ1Arethepuritylevels(cf.Figure 1)–inparticularthenew
levelcontextually pure – found in real-world applications?
RQ2Isananalysisthatsupportstheidentificationsofallpurity
levelscompetitivew.r.t.precisionandrecallwiththestate-
of-the-art which supports only specific level?
RQ3Does the analysis scale to large applications?
For RQ1, we evaluated our analysis on the Oracle JDK 8 up-
date 151, Scala 2.12.4, and the XCorpus [ 17]. The latter contains
76 programs: 70 programs from the Qualitas Corpus [ 40] and six
additional ones that make use of modern dynamic language fea-
turesoftheJavaVM.Wehadtoexclude jasperreports-1.1.0 dueto
invalidbytecode.ForRQ2,wecomparedouranalysisresultsagainst
JPPA [38,39], JPure [33], and ReIm [ 25,26]. For this comparison
we use the JOlden [ 9] benchmark. It consists of ten small Java pro-
gramsfromdifferentdomainsthatalltoolswereabletoanalyze.To
answerRQ3,wereportanalysisandperformanceresultsfortworeal-worldapplications–
batik-1.7 andxalan-2.7.1 fromXCorpus
– and compare them to ReIm. We chose these two applications,
347
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. A Unified Lattice Model and Framework for Purity Analyses ASE ’18, September 3–7, 2018, Montpellier, France
Table 3: Purity results on XCorpus, JDK, and Scala
Application XCorpus JDK Scala
Total methods 469727 253282 174881
Pure 73701(15.69%) 44378 (17.52%) 28502(16.23%)
Domain-specific pure 9628(2.05%) 8250 (3.26%) 6625(3.79%)
Side-effect free 45268(9.64%) 18234 (7.20%) 10793(6.17%)
Domain-specific side-effect free 22056(4.70%) 14717 (5.81%) 15690(8.97%)
Externally pure 19467(4.14%) 4229 (1.67%) 2519(1.44%)
Externally side-effect free 2380(0.51%) 3414 (1.35%) 82(0.05%)
Domain-specific externally pure 639(0.14%) 354 (0.14%) 11(0.01%)
Domain-specific externally side-effect-free 2467(0.53%) 1738 (0.69%) 2339(1.34%)
Contextually pure 4(0.00%) 7 (0.00%) 0(0.00%)
Contextually side-effect free 7(0.00%) 48 (0.02%) 1(0.00%)
Domain-specific contextually pure 522(0.11%) 547 (0.22%) 31(0.02%)
Domain-specific contextually side-effect free 1523(0.32%) 1277 (0.50%) 80(0.05%)
Impure 292065(62.18%) 156089 (61.63%) 108208(61.87%)
becausewewereabletoanalyzethemwithReIm.NeitherJPPAnor
JPure were able to analyze these applications.
5.1 RQ1 - Quantitative Results
ThefirstcolumnofTable 3showsthedifferentpuritylevelsgrouped
bysimilar expressiveness.The lastline liststheremaining impure
methods. Columns two to four show (cf. Table 3) the total number
of methods as well as the percentage of methods that were derived
per purity level for XCorpus, JDK, and Scala.
The analysis shows that pureandside-effect free methods are
commonplace.Inallthreecases ≈25%ofallmethodsareinthese
twocategories.Additionally,upto12.76%ofthemethodsare domain-
specific pure orside-effect free . The analysis also identifies between
1.49% to 4.65% of all methods as being externally pure/side-effect
freemethods. In this case, we only found 82 externally side-effect
free methods in Scala but a higher number of domain-specific ex-
ternally side-effect free methods when compared to Java projects.
This deviation is at least partly due to the different treatment of
exceptions in these programming languages. In Scala exceptions
neverneedtobecaughtandthereforelessexceptionsareexplicitly
caught. Hence, many more instructions may cause an abnormal
returnfrom amethod. Thesameeffect, albeitsmaller,can beseen
for(domain-specific) side-effect free methods in Scala.
Furthermore,wefoundmultiple contextuallypure/side-effectfree
methods.Ifwealsotakethe domain-specific levelsintoaccount,we
found 1879 methods in the JDK with this property, which is about
0.74%ofallmethods.Giventhatonly0.43%ofallmethodsinthe
XCorpusandlessthan0.1% inScalahavetherespectivelevel,the
prevalenceofthesepuritylevelsseemstobestronglydependent
ontheanalyzedtarget.Ingeneral,theeffectsof contextual purity
may improve when better contextual information is provided by
supporting analyses. Based on the results, we conclude that all
defined puritylevels areactually foundin real-worldapplications.5.2 RQ2 - Comparative Analysis
Wecomparedouranalysis( OPIUM)againstJPPA[ 38,39],JPure[33]
and ReIm [ 25,26]. ReIm is the most recent one; representing the
state-of-the-art.Allthreetoolsidentify side-effectfree methodsand
were downloaded from the authors’ websites.
Thesetsofallmethodsthatareanalyzedbythetoolshavesmall
differences. JPPA only analyzes methods transitively invoked by
themainmethod,JPureandReImanalyzeallmethodspresentin
the source code and our approach analyzes all methods present in
the class files which in particular includes static initializers andautomatically generated default constructors. Furthermore, the
reportsofJPureandReImalsoincludeaggregatedpurityresultsforabstractmethods.Aggregatedinformationisinourcaseprovidedby
theVirtual Method Purity analysis, not by the base purity analysis.
AllproducedanalysisresultsareshowninTable 4.Itlistsforeach
of the JOlden projects the number of methods that each systemidentified as
side-effect free (including puremethods for OPIUM)
andthenumberof methods thesystemhasanalyzed.JPurefailed
toanalyzeTSP.For OPIUM,thetableadditionallygivesthenumber
ofpure(including domain-specific pure ) methods identified by our
analysisandthenumberofmethodswithadditionalpuritylevels
(i.e.externalandcontextual purity and variants thereof).
For this comparison, we treat the levels: pureandside-effect
freeas well as their domain-specific variants as side-effect free . Our
analysis’resultsarecompetitivewithReImandsignificantlyout-
performsJPPAandJPure.Hence,ouranalysisiscompetitivewith
state-of-the-artanalysesfor side-effect free methods.Additionally,
our analysis identifies puremethods and a significant number of
externally andcontextually pure/side-effect free methods which are
not found by the other projects including ReIm.
ThedifferencesbetweenJPPAandJPurewhencomparedtoReIm
and our analysis in programs like PowerandTreeAddis due to a
high number of constructors. These are not identified as side-effect
freebyJPPA’savailableimplementationandJPure.For TSP,JPPA
classifies several methods using java.util.Random asside-effect
348
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Dominik Helm, Florian Kübler, Michael Eichberg, Michael Reif, and Mira Mezini
Table 4: At least side-effect free (SEF) methods in JOlden
Program BH BiSort Em3d Health MST Perimeter Power TreeAdd TSP Voronoi
JPPA#Analyzed methods 59 13 20 26 31 36 29 5 14 60
At least Side-Effect Free methods 24 4 56 15 27 41 44 0
JPure#Analyzed methods 69 13 19 26 33 42 29 10 07 1
At least Side-Effect Free methods 10 3 12 12 31 21 –3 0
ReIm#Analyzed methods 69 13 19 26 33 42 29 10 14 71
At least Side-Effect Free methods 33 5 81 1 16 38 10 6 14 7
OPIUM#Analyzed methods 70 15 23 29 36 45 32 12 16 73
At least SEF methods 33 7 81 3 19 38 11 7 44 9
Pure methods 11 6 59 82 1 76 31 2
Ext./Context. Pure/SEF methods +18 +2 +3 +4 +6 +1 +13 +1 +0 +5
Table 5: At least side-effect free methods in Batik/Xalan
Program Batik Xalan
ReIm#Analyzed methods 16029 10386
AtleastSide-EffectFreeMethods 6072(37.88%) 3942 (37.95%)
Execution time 103s 140s
OPIUM#Analyzed methods 15911 10763
AtleastSide-EffectFreeMethods 6780(42.61%) 4390 (40.79%)
Pure methods 4009(25.20%) 2492 (23.15%)
Ext./Context. Pure/SEF methods +987(6.20%) +748 (6.95%)
Execution time 197s 187s
free,eventhoughtheyarenot– Randommodifiesglobalstatewhen
an instance is created – while ReIm fails to identify a pure con-
structor. We manually verified that all classifications performed by
OPIUM were sound and identified further potential for improve-
mentswherewewouldbeabletoidentifymethodsaspureifthe
supporting analyses would be more precise.
To foster an understanding of our analysis on real code, we
compareditwithReImon BatikandXalan.Theresultsarelisted
in Table5. It again presents the number of methods identified as
side-effectfree(oreven pure)byReImandouranalysisalongside
thenumberofanalyzedmethods.Thenumberof puremethodsand
thenumberofadditional, externally orcontextuallypure/side-effect
freemethods is given for OPIUM. The table also lists the execution
time for both systems when analyzing BatikandXalan.
On these applications, our analysis outperforms ReIm: We iden-
tify up to 5% more side-effect free methods and up to 7% of all
methodsasbeingexternallyorcontextuallypure/side-effectfree
methods.Wecanconcludethatouranalysisiscompetitiveandalso
identifies all the defined purity levels
5.3 RQ3 - Performance Evaluation
The evaluation was performed on a Mac Pro with an Intel Xeon
E5 processor (3 GHz) and 32 GB RAM running Lubuntu 17.10 with
OracleJDK8update161;TheJavaVMwasgiven24GBheapspace.TheexecutiontimeforourandReIm’spurityanalysisislistedin
Table5. It shows, that our (sequential) analysis, with 197 sfor Batik
and187 sforXalan,isslowerthanReIm,whichneeds103 sand140 s
toexecute.Theincreaseinruntimehasmultiplereasons:First,it
alsoanalyzestheJDKandalllibrariesrequiredbytheapplication
whereasReImreliesonapre-annotatedJDK.Second,thegeneration
ofthree-addresscode–thateasestheimplementationandprovides
moreprecisetypeinformation–takesmorethan45%oftheoverall
executiontime.However,ouranalysisderivesmorefine-grained
resultsandidentifiesasignificantlyhighernumberofside-effect
free methods than ReIm (cf. Table 5).
We can conclude, that the proposed analysis scales to large
projects: The execution time is less than four minutes for ≈170000
methods – including the JDK and library dependencies.
6 CONCLUSION
In this paper, we proposed a fine-grained unified lattice model for
purity,coveringallusecasesfromtheliterature.Wealsoprovide
precisedefinitionsforeachlatticeelementtoestablishacommon
terminology.Furthermore,weimplementedascalablepurityanaly-siswhichderivesallpropertiesofthelatticeandwhichoutperforms
state-of-the-art purity analyses.
In future work, we will explore the use of the purity analysis
asasupportinganalysisforupstreamones.Additionally,wewill
leveragethemodularityoftheanalysestoexchangethesupportinganalysesagainstmorepowerfulonestoassesstheeffectofthelatter
when identifying pure methods.
OPIUMis available at www.opal-project.de/Opium.html.
ACKNOWLEDGMENTS
This work was funded by the Hessian LOEWE initiative within the
Software-Factory4.0project.ThisworkwassupportedbytheDFG
aspartofCRC1119CROSSING,bytheGermanFederalMinistry
ofEducationandResearch(BMBF)aswellasbytheHessenState
Ministry for Higher Education, Research and the Arts (HMWK)
within CRISP.
349
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. A Unified Lattice Model and Framework for Purity Analyses ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Dotty documentation overview – Effect capabilities, 2018. Retrieved 2018-04-21.
[2] B. Alpern,S. Augart, S.M. Blackburn,M. Butrico,A. Cocchi,P. Cheng,J. Dolby,
S. Fink, D. Grove, M. Hind, K. S. McKinley, M. Mergen, J. E. B. Moss, T. Ngo,
V. Sarkar, and M. Trapp. The jikes research virtual machine project: Building an
open-source research community. IBM Systems Journal, 44(2):399–417, 2005.
[3]D.F.BaconandP.F.Sweeney. FaststaticanalysisofC++virtualfunctioncalls.
ACM Sigplan Notices, 31(10):324–341, 1996.
[4]A.BanerjeeandD.A.Naumann. Secureinformationflowandpointerconfine-
ment in a Java-like language. In CSFW, volume 2, page 253, 2002.
[5]M. Barnett, D. A. Naumann, W. Schulte, and Q. Sun. 99.44% pure: Useful abstrac-
tionsinspecifications. In ECOOPworkshoponFormalTechniquesforJava-like
Programs (FTfJP), 2004.
[6]M.Barnett,D.A.Naumann,W.Schulte,andQ.Sun. Allowingstatechangesin
specifications. ETRICS, 3995:321–336, 2006.
[7]W. C.BentonandC. N.Fischer. Mostly-functional behaviorin Javaprograms. In
InternationalWorkshoponVerification,ModelChecking,andAbstractInterpreta-
tion, pages 29–43. Springer, 2009.
[8]C. Boyapati, S. Khurshid, and D. Marinov. Korat: Automated testing based on
Javapredicates. In ACMSIGSOFTSoftwareEngineeringNotes,volume27,pages
123–133. ACM, 2002.
[9]B.CahoonandK.S.McKinley. Dataflowanalysisforsoftwareprefetchinglinked
datastructuresinJava. In ParallelArchitecturesandCompilationTechniques,2001.
Proceedings. 2001 International Conference on, pages 280–291. IEEE, 2001.
[10]J.-D. Choi, M. Gupta, M. Serrano, V. C. Sreedhar, and S. Midkiff. Escape analysis
for Java.Acm Sigplan Notices, 34(10):1–19, 1999.
[11]L. R. Clausen. A Java bytecode optimizer using side-effect analysis. Concurrency
and Computation: Practice and Experience, 9(11):1031–1045, 1997.
[12]D. R. Cok. Reasoning with specifications containing method calls and model
fields.Journal of Object Technology, 4(8):77–103, 2005.
[13]V. Dallmeier. Static vs. dynamic purity analysis. Dept. Comput. Sci., Saarland
Univ., Saarbrucken, Germany, Tech. Rep. SU-CS-2013-012, 2007.
[14]V. Dallmeier,C.Lindig,A.Wasylkowski,andA.Zeller. Miningobjectbehavior
with ADABU. In Proceedings of the 2006 international workshop on Dynamic
systems analysis, pages 17–24. ACM, 2006.
[15]Á.DarvasandK.R.M.Leino. Practicalreasoningaboutinvocationsandimple-
mentations of pure methods. In FASE, volume 4422, pages 336–351. Springer,
2007.
[16]Á.DarvasandP.Müller. Reasoningaboutmethodcallsininterfacespecifications.
Journal of Object Technology, 5(5):59–85, 2006.
[17]J. Dietrich, H. Schole, L. Sui, and E. Tempero. XCorpus–an executable corpus of
Java programs. The Journal of Object Technology, 16(4), 2017.
[18]J.J.Dolado,M.Harman,M.C.Otero,andL.Hu. Anempiricalinvestigationofthe
influence of a type of side effects on program comprehension. IEEE Transactions
on Software Engineering, 29(7):665–670, 2003.
[19]M. Eichberg, F. Kübler, D. Helm, M. Reif, G. Salvaneschi, and M. Mezini. Lattice
based modularization of static analyses. SOAP 2018, 2018.
[20]M. Finifter, A. Mettler, N. Sastry, and D. Wagner. Verifiable functional purity in
Java. InProceedingsofthe15thACMconferenceonComputerandcommunications
security, pages 161–174. ACM, 2008.
[21]C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata.
PLDI 2002: Extended static checking for Java. ACM Sigplan Notices, 48(4S):22–33,
2013.
[22]D.GayandB. Steensgaard. Fastescapeanalysisand stackallocationforobject-
based programs. In International Conference on Compiler Construction, pages82–93. Springer, 2000.
[23]S. Genaim and F. Spoto. Constancy analysis. Formal Techniques for Java-like
Programs (FTfJP), page 100, 2008.
[24]M. Hind and A. Pioli. Which pointer analysis should I use? In ACM SIGSOFT
Software Engineering Notes, volume 25, pages 113–123. ACM, 2000.
[25]W. Huang and A. Milanova. ReImInfer: Method purity inference for Java. In
ProceedingsoftheACMSIGSOFT20thInternationalSymposiumontheFoundations
of Software Engineering, page 38. ACM, 2012.
[26]W. Huang, A. Milanova, W. Dietl, and M. D. Ernst. ReIm & ReImInfer: Checking
andinferenceofreferenceimmutabilityandmethodpurity. In ACMSIGPLAN
Notices, volume 47, pages 879–896. ACM, 2012.
[27]R. Ierusalimschy and N. Rodriguez. Side-effect free functions in object-oriented
languages. Computer languages, 21(3):129–146, 1995.
[28]A.Le,O.Lhoták,andL.J.Hendren.Usinginter-proceduralside-effectinformation
in JIT optimizations. In CC, pages 287–304. Springer, 2005.
[29] G. T. Leavens and Y. Cheon. Design by contract with JML, 2006.[30]
J.M.LucassenandD.K.Gifford. Polymorphiceffectsystems. In Proceedingsofthe
15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages,
pages 47–57. ACM, 1988.
[31]D. Marinov,A. Andoni,D. Daniliuc, S.Khurshid, andM. Rinard. An evaluation
of exhaustive testing for data structures. Technical report, Technical Report
MIT-LCS-TR-921, MIT CSAIL, Cambridge, MA, 2003.[32]D. A. Naumann. Observational purity and encapsulation. In FASE, volume 3442,
pages 190–204. Springer, 2005.
[33]D. Pearce. JPure: a modular purity system for Java. In Compiler construction,
pages 104–123. Springer, 2011.
[34]A. Potanin, J. Östlund, Y. Zibin, and M. D. Ernst. Immutability. In Aliasing in
Object-Oriented Programming. Types, Analysis and Verification, pages 233–269.
Springer, 2013.
[35]A.Rountev. Preciseidentificationofside-effect-freemethodsinJava. In Software
Maintenance,2004.Proceedings.20thIEEEInternationalConferenceon,pages82–91.
IEEE, 2004.
[36]A.SabelfeldandA.C.Myers. Language-basedinformation-flowsecurity. IEEE
Journal on selected areas in communications, 21(1):5–19, 2003.
[37]A.Stewart,R.Cardell-Oliver,andR.Davies. Fine-grainedclassificationofside-
effect free methods in real-world Java code and applications to software security.
InProceedingsoftheAustralasianComputerScienceWeekMulticonference,page37.
ACM, 2016.
[38]A. Sălcianu and M. Rinard. A combined pointer and purity analysis for Java
programs. 2004.
[39]A. SălcianuandM. C.Rinard. Purity andside effectanalysis forJava programs.
InVMCAI, volume 5, pages 199–215. Springer, 2005.
[40]E.Tempero,C.Anslow,J.Dietrich,T.Han,J.Li,M.Lumpe,H.Melton,andJ.Noble.
TheQualitascorpus: AcuratedcollectionofJavacodefor empiricalstudies. In
SoftwareEngineering Conference(APSEC),2010 17thAsiaPacific,pages 336–345.
IEEE, 2010.
[41]O. Tkachuk and M. B. Dwyer. Adapting side effects analysis for modular program
model checking, volume 28. ACM, 2003.
[42]H.Xu,C.J.Pickett,andC.Verbrugge. DynamicpurityanalysisforJavaprograms.
InProceedings of the 7th ACM SIGPLAN-SIGSOFT workshop on Program analysis
for software tools and engineering, pages 75–82. ACM, 2007.
[43]J. Zhao, I. Rogers, C. Kirkham, and I. Watson. Pure method analysis within Jikes
RVM.Proc. ICOOOLPS, 2008.
350
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:49:42 UTC from IEEE Xplore.  Restrictions apply. 