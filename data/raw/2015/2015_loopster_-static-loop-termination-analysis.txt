Singapor e Management Univ ersity Singapor e Management Univ ersity 
Institutional K nowledge at Singapor e Management Univ ersity Institutional K nowledge at Singapor e Management Univ ersity 
Resear ch Collection School Of Computing and 
Information Systems School of Computing and Information Systems 
9-2017 
Loopster: Static loop termination analysis Loopster: Static loop termination analysis 
Xiaof ei XIE 
Singapor e Management Univ ersity , xfxie@smu.edu.sg 
Bihuan CHEN 
Liang Z OU 
Shang-W ei LIN 
Yang LIU 
See next page for additional authors 
Follow this and additional works at: https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch 
 Part of the Programming Languages and Compilers Commons , and the Softwar e Engineering 
Commons 
Citation Citation 
XIE, Xiaof ei; CHEN, Bihuan; Z OU, Liang; LIN, Shang-W ei; LIU, Y ang; and LI, Xiaohong. Loopster: Static loop 
termination analysis. (2017). Proceedings of the 2017 11th Joint Meeting on F oundations of Softwar e 
Engineering, P aderborn, Germany , September 4-8 . 84-94. 
Available at:Available at:  https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/7104 
This Conf erence Pr oceeding Ar ticle is br ought t o you for fr ee and open access b y the School of Computing and 
Information Systems at Institutional K nowledge at Singapor e Management Univ ersity . It has been accepted for 
inclusion in Resear ch Collection School Of Computing and Information Systems b y an authoriz ed administr ator of 
Institutional K nowledge at Singapor e Management Univ ersity . For mor e information, please email 
cher ylds@smu.edu.sg . Author Author 
Xiaof ei XIE, Bihuan CHEN, Liang Z OU, Shang-W ei LIN, Y ang LIU, and Xiaohong LI 
This conf erence pr oceeding ar ticle is a vailable at Institutional K nowledge at Singapor e Management Univ ersity: 
https:/ /ink.libr ary.smu.edu.sg/sis_r esear ch/7104 Loopster: Static Loop Termination Analysis
Xiaofei Xieâˆ—
Tianjin Key Laboratory of Advanced
Networking
TianjinUniversity, China
xiexiaofei@tju.edu.cnBihuan Chen
Nanyang Technological University
Singapore
bhchen@ntu.edu.sgLiang Zou
Nanyang Technological University
Singapore
zouliang@ntu.edu.sg
Shang-Wei Linâ€ 
Nanyang Technological University
Singapore
shang-wei.lin@ntu.edu.sgYang Liu
Nanyang Technological University
Singapore
yangliu@ntu.edu.sgXiaohong Liâ€¡
TianjinKey Laboratory of Advanced
Networking
TianjinUniversity, China
xiaohongli@tju.edu.cn
ABSTRACT
Loop termination is an important problem for proving the cor-
rectness of a system and ensuring that the system always reacts.Existingloopterminationanalysistechniquesmainlydependonthe synthesis of ranking functions, which is often expensive. Inthis paper, we present a novel approach, named Loopster, which
performsanefficientstaticanalysistodecidetheterminationfor
loops based on path termination analysis and path dependency
reasoning. Loopster adopts a divide-and-conquer approach: (1) weextract individual paths from a target multi-path loop and analyze
theterminationofeachpath,(2)analyzethedependenciesbetween
eachtwopaths,andthen(3)determinetheoverallterminationof
the target loop based on the relations among paths. We evaluate
Loopsterbyapplyingitontheloopterminationcompetitionbench-markandthreereal-worldprojects.TheresultsshowthatLoopster
is effective in a majority of loops with better accuracy and 20 Ã—+
performance improvement compared to the state-of-the-art tools.
CCSCONCEPTS
â€¢Theory of computation â†’Program analysis ;â€¢Software
and its engineering â†’Automated static analysis ;
KEYWORDS
Loop Termination, Reachability, Path Dependency Automaton
ACM Reference format:
XiaofeiXie,BihuanChen,LiangZou,Shang-WeiLin,YangLiu,andXiao-
hongLi.2017.Loopster:StaticLoopTerminationAnalysis.In Proceedingsof
201711thJointMeetingoftheEuropeanSoftwareEngineeringConferenceand
âˆ—Also with Nanyang Technological University, Singapore.
â€ Shang-Wei Lin and Yang Liu have equal contribution in this work.
â€¡XiaohongLiisthecorrespondingauthor,SchoolofComputerScienceandTechnology,
Tianjin University.
Permissionto make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
Â© 2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09 ...$15.00
https://doi.org/10.1145/3106237.3106260theACMSIGSOFTSymposiumontheFoundationsofSoftwareEngineering,
Paderborn, Germany, September 04-08, 2017 (ESEC/FSEâ€™17), 11 pages.
https://doi.org/10.1145/3106237.3106260
1 INTRODUCTION
Programterminationanalysisisanimportantprogramanalysistask
toguaranteethecorrectnessandreliabilityofsystems.Nontermi-
nationbugs can causeperformance problems or denial-of-service
attacks [14]. Furthermore, termination proving techniques [ 17,21]
canbeusedtoprovelivenessproperties.Loops,asthebasicprogram
structure, are the key challenge in program termination analysis.
Programterminationanalysishasreceivedconsiderableatten-
tion,andalotofadvances[ 7,9â€“11,15,20,22,28,32,40,41,43]have
beenmade.Thegeneralapproachistosynthesizeterminationar-
guments, which requires solving two problems [ 12]: the search for
ranking functionsand thevalidityofthe rankingfunctions. How-
ever,terminationprovinghasbeenprovedtobeundecidable[ 21],
anditisnotalwayspossibletofindsuitablerankingfunctions.Thus,
theexisting techniques can only handle certain restricted types of
programs.Forexample,thetechniquesin[ 9,10,43]arecomplete
only for linear arithmetic loops. Besides, the search for ranking
functions can be very expensive, especially for complex lexico-
graphic rankingfunctions. Forexample, the techniques in [ 11,28]
maynotterminatewhenprovingtheterminationofsomeprograms.Inprinciple,enumerationcanprovideacompletemethodbutisnot
practical[ 11].Moreover,the validityof rankingfunctions usually
depends on a safety checker to search for invariants on demand,
which is known to be the bottleneck of ranking function-based
techniques[ 32].Insteadoffindingnon-triviallexicographicrank-
ingfunctions,severaltechniques[ 20,22,32]attempttofindsimple
terminationargumentsbasedonRamseyâ€™stheorem.However,these
techniquesstillhavetomaketrade-offsbetweenthetimeoverhead
for thesearch and validity of ranking functions.
Therefore,themainlimitationofrankingfunction-basedtech-
niquesisthesubstantialtimeoverheadforsearchingandvalidat-
ing ranking functions. From our study on loops, there are many
loopswhoseterminationcanbequicklydeterminedbyanalyzing
the termination in each path and the dependencies between the
paths.Inthispaper,weproposeLoopster,arelativelylightweight
static analysis-based approach to proving termination and non-
termination for such loops, which does not depend on ranking
84ESEC/FSEâ€™17,September 04-08, 2017, Paderborn, Germany X. Xie, B. Chen, L. Zou, S. Lin, Y. Liu and X. Li
1int n:= âˆ—;
2int x:= âˆ—;
3int z:= âˆ—;
4while (x<n)
5 if(z>x)
6 x++;
7 else
8 z++;
(a) LoopQ 
[ ] 
7a
b
cd[! Q[Q
[]![
]] [7
7
ef
(b) CFG
1
 2
3
(c) PDAx
Figure 1: Unnested Loop from [26] with CFG and PDA x
functions. Our key idea is to use a divide-and-conquer approach
at the path level to: 1) extract paths in a target loop and analyze
the termination of each path, 2) analyze the dependencies between
each pair of paths, and 3) determine the overall termination of the
targetloop based on the dependencies between paths.
Technically, to formally analyze multiple paths in a loop, we
firstextendthepathdependencyautomaton(PDA x)inourprior
work[47]tocapturethedependenciesamongthepaths(Section2.2).
BasedonthePDA x,Loopsterperformstheterminationanalysisfor
a multi-path loop in three steps (Section 3). In the first step, it uses
exit conditions as the slicing criteria to perform a program slicing
on the target loop and obtains the control flow graph (CFG) of the
loop. In the second step, it first extracts paths and analyzes the
terminationofeach pathby astatic monotonicityanalysis [ 39]o r
temporal-logicproving[ 18,31].Analyzingmonotonicityofacer-
tainfunctionineachpathisusuallyeasierthaninferringaranking
functioninamulti-pathloop.Apathcanbe terminating ornontermi-
nating.Then,itconstructsthePDA xofthelooptocapturethepath
dependencies.Ifthereisanypaththatcannotbedeterminedaster-
minating or nonterminating in the second step, a context-sensitive
depth-firstsearchonthePDA xisperformedtorefinethe unknown
pathsinthelaststep.Duringthetraversal,ifonepathmarkedas
nonterminating is reachable, Loopster finds a nonterminating trace.
Ifallthepathsalongthetracearemarkedas terminating andthe
traversal ends with an accepting state, Loopster concludes that the
traceterminates.Ifthereexistsonepaththatismarkedas unknown
and cannotbe refined, Loopster returns unknown.
We implemented Loopster and evaluated its effectiveness and
performance(Section4)byapplyingitontheloopsfromthetermi-
nation analysis benchmark [ 1] and three open-source projects. For
the 101 loop programs taken from the benchmark, Loopster can
correctlyhandle93(92.08%)oftheprogramswithonly7.76seconds,
whilethebeststate-of-the-arttoolUAutomizer[ 29]inourexperi-
mentscancorrectlyhandle92of themwith2246seconds.Forthe
total6820loopsfromreal-worldprojects,Loopstercanhandle2655
(39%)with91seconds.TheresultsshowthatLoopsterisscalableand
effective,andthebiggestadvantageisthatourstaticanalysiscan
make a dramatic performance improvement (20 Ã—+) for most loops.
In summary, the contributions of our paper are threefold:
(1)Weextendthepathdependencyautomaton(PDA x)toi)support
nestedloopsandii)computetransitionsforthepathswithnon-
inductionvariables.int x:=âˆ—;
int y:=âˆ—;
int z:=âˆ—;
while (y>=1)
xâˆ’âˆ’ ;
while (y<z)
x++;
zâˆ’âˆ’ ;
y:=x + y;
(a) Loop[ 
\ 
] 
7
[\\! 
[
]\ [\7
\]\! ]77a
b
cd
e
fg
(b) CFG
1
2
(c) PDAx
Figure 2: Nested Loop from [34] with CFG and PDA x
(2)BasedonthePDA x,weproposeanefficientstaticanalysistoi)
prove termination of multi-path loops and ii) detect nontermi-
nation through finding nonterminating state with reachability
analysisonthePDA x,andprove thesoundnessofourapproach.
(3)We implement our approach in Loopster, and conducted an
evaluationtodemonstratetheeffectivenessandscalabilityof
Loopster on benchmarks and real-world projects.
2 LOOP MODELING
In this section, we define the scope of this work and extend the
path dependency automaton(PDA x).
2.1 Scope of the Work
We focus on multi-path loops in which the variables are over in-
tegers and the operations are standard integer operations (addi-tion, subtraction, multiplication, and division). Let
Dbe a finite
integer domain and X={x1,x2,...,xn}be a finite set of vari-
ables ranging over D. An atomic predicate over Xis of the form
f(x1,x2,...,xn)âˆ¼b, wheref:Dn/mapstoâ†’Dis a function that repre-
sentsthestandardintegeroperationson X,âˆ¼âˆˆ {=,<,â‰¤,>,â‰¥},and
bâˆˆD.ApredicateisaBooleancombinationofatomicpredicates
overX.PXis to denote the set of all possible predicates over X.
Loops containing data structures and function calls are not sup-
ported in this work. However, we can perform a program slicing if
they donot affectthe termination ofthe loop.The possible exten-
sionsfor some unsupported loops is discussed in Section 4.4.
2.2 PathDependencyAutomaton
The loop we considered can be modeled by a control flow graph
(CFG), as formulated in Definition 2.1.
Definition 2.1. A control flow graph (CFG) of a loop is a tuple
G=(L,E,lpre,Lh,Le), where (1) Lis a set of basic blocks, each
ofwhichcontainsasequenceofassignmentinstructions.(2) EâŠ†
LÃ—PXÃ—Lisasetofdirectededgesconnectingthebasicblocks.(3)
lpreâˆˆListhepre-headerafterwhichtheentryblockoftheloop
will execute. (4) LhâŠ‚Lis a set of header blocks. Given two blocks
l,l/primeâˆˆL, we sayldominates l/prime(ld o ml/prime), if every path from lpre
tol/primepasses through l.Lh={lâˆˆL|âˆƒ(l/prime,p,l)âˆˆEâˆ§ld o ml/prime}. (5)
Le={lâˆˆL|âˆ€l/primeâˆˆL,pâˆˆPX,(l,p,l/prime)/nelementE}is a set of exit blocks.
Forsimplicity,weuse l1pâˆ’âˆ’â†’l2todenoteanedge (l1,p,l2)âˆˆE,
which means that in the basic block l1, if the condition pholds,
85Loopster: Static Loop Termination Analysis ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
3'$[EDVHG7HUPLQDWLRQ$QDO\VLV 3'$[FRQVWUXFWLRQ 7HUPLQDWLQJ
1RQWHUPLQDWLQJ
8QNQRZQ",QLWLDO6WDWHV3DWK7HUPLQDWLRQ
$QDO\VLV,QWHU3DWK
$QDO\VLV/RRS
3URJUDP6OLFLQJDQG&)*
&RQVWUXFWLRQ5HILQHPHQW &)* 3'$[2YHUDOO7HUPLQDWLRQ
$QDO\VLV 
Figure 3: Flow Diagram of Loopster
then the (loop) program goes to the basic block l2. In this work, we
considertheweakestpreconditionoperator wpandthestrongest
postcondition operator sp, based on Hoare Logic [30].
Definition 2.2. Given a CFG G=(L,E,lpre,Lh,Le), a path (de-
notedasÏƒ)isasequence l0p0âˆ’âˆ’â†’l1p1âˆ’âˆ’â†’...pkâˆ’1âˆ’âˆ’âˆ’âˆ’â†’lk,wherel0âˆˆLh
is the head of Ïƒ, denoted by head(Ïƒ);lkâˆˆ(LhâˆªLe)is the tail
ofÏƒ, denoted by tail(Ïƒ);âˆ€1â‰¤i<k,li/nelement(LhâˆªLe). The weak-
esttriggeringconditionofpath Ïƒ(denotedas Î¸Ïƒ)iscomputedas
wp(l0,p0)âˆ§wp(l0;l1,p1)âˆ§...âˆ§wp(l0;...;lkâˆ’1,pkâˆ’1), where the
liinwprepresents the instructions in the basic block.
Forsimplicity,wewilluse pathcondition torepresenttheweakest
triggeringconditionofapathinthefollowingsections.Forexample,
the path condition for while(y>0){x++;if(x<0)z++;}isy>
0âˆ§x<âˆ’1 ratherthan y>0âˆ§x<0.
Thepath Ïƒisfeasibleonlywhen Î¸Ïƒissatisfiable.Otherwise,itis
aninfeasible path. We use Î¹(Ïƒ)to denote a sequence of assignment
instructions in Ïƒ, andÏƒkto denote the consecutive repetition of
pathÏƒwithktimes.Î¹(Ïƒk)iskrepetitionof Î¹(Ïƒ)(i.e.,Î¹(Ïƒ);...;Î¹(Ïƒ)).
For example, if Î¹(Ïƒ)isx++, thenÎ¹(Ïƒ2)isx++;x++.
The precondition of the loop is a predicate Pre(G)which con-
strains the possible valuations for the variables before executingthe loop
G. We assume that the loop precondition is known. We
usePre(Ïƒ)andPos(Ïƒk)to denote the precondition of the path Ïƒ
and the postcondition after kexecutions of Ïƒ, respectively. Pre(Ïƒ)
andPos(Ïƒk)arepredicateswhichconstrainthepossiblevaluations
forthevariablesbeforeexecutingthepath Ïƒandafterexecuting
thepathÏƒforktimes.Givenapathwithitsprecondition Pre(Ïƒ),
wecaninferitspostcondition Pos(Ïƒk)assp(Î¹(Ïƒk),Pre(Ïƒ)),which
gives the strongest condition after executing Ïƒkw.r.t.Pre(Ïƒ).
Example 2.3. Fig. 1(b) gives the CFG of the unnested loop in
Fig.1(a),wheretherearesixbasicblocksnamedfrom atofand
seven edges. The basic block ais the pre-header from which the
program enters the loop. bis the header block and dis the exit
block. There is one predicate on each edge. For example, bx>nâˆ’âˆ’âˆ’âˆ’â†’c
is feasible if the predicate x>nholds.Trepresents truewhich
means the predicate always holds. There are three paths in the
CFG:Ïƒ1=bx<nâˆ’âˆ’âˆ’âˆ’â†’cz>xâˆ’âˆ’âˆ’âˆ’â†’etrueâˆ’âˆ’âˆ’âˆ’â†’b,Ïƒ2=bx<nâˆ’âˆ’âˆ’âˆ’â†’cz<=xâˆ’âˆ’âˆ’âˆ’âˆ’â†’
ftrueâˆ’âˆ’âˆ’âˆ’â†’b,Ïƒ3=bx>=nâˆ’âˆ’âˆ’âˆ’âˆ’â†’d.Forthepath Ïƒ1,itspathconditionis
Î¸Ïƒ1=x<nâˆ§z>x. The loop precondition is truesincex,n,z
can be any value before the loop. Suppose Pre(Ïƒ1)=x>0, then
we can infer Pos(Ïƒ1)=sp(x++,x>0)=x>1 andPos(Ïƒ12)=
sp(x++;x++ ,x>0)=x>2.
Different from Fig. 1(b), there are two header blocks ( bande)i n
Fig.2(b)sincetheloopsarenested.InFig.2(b),therearefourpaths:
Ïƒ1=by>=1âˆ’âˆ’âˆ’âˆ’âˆ’â†’ctrueâˆ’âˆ’âˆ’âˆ’â†’e,Ïƒ2=ey<zâˆ’âˆ’âˆ’âˆ’â†’ftrueâˆ’âˆ’âˆ’âˆ’â†’e,Ïƒ3=ey>=zâˆ’âˆ’âˆ’âˆ’âˆ’â†’
Ğ´trueâˆ’âˆ’âˆ’âˆ’â†’b,Ïƒ4=by<1âˆ’âˆ’âˆ’âˆ’â†’d.Intuitively,oneloopexecutioncontainsmultipleiterations,which
are the interleaving of the feasible paths in the CFG. To model the
dependencies between different paths in a loop, we propose the
path dependency automaton,as formulated in Definition 2.4.
Definition2.4. GivenaloopwiththeCFG G=(L,E,lpre,Lh,Le),
apathdependency automaton (PDAx)i sA=(S,I,T,F)where:
â€¢S={Ïƒ|Ïƒis a feasible path in G}is a set of states.
â€¢I={ÏƒâˆˆS|( (lpre,true,head(Ïƒ)âˆˆE)âˆ§Pre(G)âˆ§Î¸Ïƒis satisfiable }
is a set of initial states.
â€¢T={(Ïƒ,Ïƒ/prime)âˆˆSÃ—S|(tail(Ïƒ)=head(Ïƒ/prime))âˆ§(Ïƒ/nequalÏƒ/prime)âˆ§(âˆƒi:Î¸Ïƒâˆ§
(/logicalandtext.1
1â‰¤kâ‰¤isp(Î¹(Ïƒk),Î¸Ïƒ))âˆ§Î¸Ïƒ/primeis satisfiable )}isasetoftransitions.
â€¢F={ÏƒâˆˆS|âˆ€Ïƒ/primeâˆˆS:(Ïƒ,Ïƒ/prime)/nelementT}is a set of accepting states.
Intuitively,astatein Acorrespondstoapathin G.Astateisan
initialstateifitscorrespondingpathcanbethefirstiterationundertheloopprecondition.Thetransition
(Ïƒ,Ïƒ/prime)âˆˆTrepresentsthat Ïƒ/prime
can be executed (i.e., Î¸Ïƒ/primeis satisfiable) after some ( i) repetitions of
Ïƒ. A state is an accepting state if it has no successors. A run of the
PDAx, denoted as Ï„, is a sequence of states Ï„=(Ïƒ1,Ïƒ2,...)where
Ïƒ1âˆˆIandâˆ€iâ‰¥1:(Ïƒi,Ïƒi+1)âˆˆT. The sequence can be infinite.
Thesemanticsof Ï„canberepresentedbytheloopexecutionwhich
is the interleaving of the paths. With different loop preconditions,
aP D Axhas different runs. We use RAto represent the set of all
runsofAundertheloopprecondition Pre(G).Theconstruction
ofTwill be described in Section 3.2.
Iftail(Ïƒ)is an exit block, then path Ïƒ(called exit path) will end
theloop.Hence, ifeachrunoftheloopcan endwithanexitpath,
theloopwillterminate.Ifthereisanyrunwhichisinfinite,theloop
is nonterminating (e.g., while(x<11)if(x<10)x++;else x--;). Or
ifarunisfinitebutthelastpathisnotanexitpath,theloopenters
onestuckstate which has no successors and the loop does not
terminate(e.g., while(x>1)x++;).
Example 2.5. Fig. 1(c) shows the PDA xof the loop in Fig. 1(a),
whereS={Ïƒ1,Ïƒ2,Ïƒ3},I={Ïƒ1,Ïƒ2,Ïƒ3},F={Ïƒ3}andT={(Ïƒ1,Ïƒ2),
(Ïƒ2,Ïƒ1),(Ïƒ1,Ïƒ3)}. The states Ïƒ1,Ïƒ2andÏƒ3represent the paths in
the CFG. The precondition of the loop is true.Ïƒ1,Ïƒ2andÏƒ3can
be initial states as they can be firstly executed under the precon-dition. For example, by Definition 2.4, we check whether
Ïƒ1can
beinitialstatebysolvingthecondition trueâˆ§x<nâˆ§z>x.The
conditionissatisfiable,hence Ïƒ1canbeaninitialstate.Thereisa
transitionfrom Ïƒ1toÏƒ2becausethepathcondition Î¸Ïƒ2canbesatis-
fiable after some execution of Ïƒ1. The details about computing the
transitionin this examplewill be described in Example 3.2. There
are four patterns which represent all possible runs of the PDA x:
Ï„1=(Ïƒ3),Ï„2=(Ïƒ1,Ïƒ3),Ï„3=((Ïƒ1,Ïƒ2)+,Ïƒ1,Ïƒ3),Ï„4=((Ïƒ2,Ïƒ1)+,Ïƒ3).
Fig. 2(c) is the PDA xof the nested loop in Fig.2(a).
86ESEC/FSEâ€™17,September 04-08, 2017, Paderborn, Germany X. Xie, B. Chen, L. Zou, S. Lin, Y. Liu and X. Li
3 LOOP TERMINATION ANALYSIS
We propose a static method for loop termination analysis. The
keyideaistoadoptthedivide-and-conquerstrategy:weanalyze
the termination of each path in the target loop, and determine the
overallterminationofthetargetloopbasedonthedependencies
among the paths. Fig. 3 shows the overall flow of our approach.
Given a loop as the input, our approach determines whether the
loop terminates through the following three steps:Step1.
We use the program slicing technique [ 38] to remove irrel-
evant statements from the loop program. Based on the sliced loop,
we construct its CFG to extract paths in the loop. The details of
slicingare omitted and can be found in [38].
Step 2.We construct the PDA xw.r.t. the control flow graph gener-
ated inStep 2.We firstidentify the initialstates, thenperform the
termination analysisof each path based on monotonicity analysis
or prover (see Section 3.1). At last, the dependency analysis among
paths(see Section 3.2) is performed.
Step 3.With the PDA xconstructed, we perform a reachability
analysisonPDA xtodeterminetheoverallterminationofthetarget
loop (c.f. Section 3.3). If the information is not sufficient to have
aconclusiveresult,weperformarefinementsteptoobtainmore
informationto determine the overall termination (c.f. Section 3.4).
3.1 PathTermination Analysis
A path is nonterminating if it can be executed infinitely before
executingotherpaths;otherwise,itisterminating.Todetermine
whetheronepathisterminatingornot,weadoptasufficientcon-
ditionchecking,i.e.,wecomputethesufficientconditionsofnon-
termination and termination for each path, respectively. For a path
Ïƒ, if the sufficient condition of nontermination is true(i.e., it does
notterminateinanycase),thenwecanconcludethatitdoesnot
terminate. Similarly, if the sufficient condition of termination is
true, then we can conclude thatitterminates. Otherwise, we can-
not conclude anything from the sufficient conditions. Based on the
three cases above, we can identify each path as terminating (T),
nonterminating (NT), orunknown (UN).
Obviously,apathisalwaysterminatingifitsheadandtailnodes
are different. Thus, its sufficient terminating condition is trueand
nonterminating condition is false. In the following, we explain
how to compute the nonterminating sufficient condition Ï•and the
terminating sufficient condition Ïˆfor the path whose head node
andtailnodearethesamebasicblock.Considerapath Ïƒwithpath
condition Î¸Ïƒ=p/prime
1âˆ§p/prime
2âˆ§Â·Â·Â·âˆ§p/prime
kwherep/prime
iisapredicateoftheform
fi(x1,x2,...,xn)âˆ¼bifor 1â‰¤iâ‰¤k. To simplify the notation, we
useEito denote the function fi(x1,x2,...,xn). For each predicate
p/prime
i, we define its sufficient conditions Ï•iandÏˆiusing the following
monotonicityanalysis:
(1)For a predicate of the form Ei>biorEiâ‰¥bi, its nonterminat-
ing sufficient condition Ï•ishould make Eiincrease monotoni-
cally or not change in each iteration; the terminating sufficient
condition Ïˆishouldmake Eidecreasemonotonically ineach
iteration.
(2)For the predicate of the form Ei<biandEiâ‰¤bi, its non-
terminating sufficient condition Ï•ishould make Eidecrease
monotonically or not change in each iteration; the terminating
sufficient condition Ïˆishould make Eiincrease monotonically.intx=âˆ—;
while(x>0)
x++;
(a) NTintx=âˆ—,y=âˆ—;
while(x<0 & & y>0)
x=x+y; y++;
(b) Tintx=âˆ—, a=âˆ—;
while(x>0)
x=x+a;
(c) UN
Figure 4: Path Examples
(3)For the predicate of the form Ei=bi, its nonterminating suffi-
cient condition Ï•ishould make Eikeep the same value in each
iteration;theterminatingsufficientcondition Ïˆishouldmake
Eichange the value in some iterations.
Withthesufficient conditionsforeachpredicate pi,theoverall
sufficientconditionsfor the path Ïƒare defined as:
Ï•=/logicalanddisplay.1
1â‰¤iâ‰¤kÏ•iandÏˆ=/logicalordisplay.1
1â‰¤iâ‰¤kÏˆi
IfÏ•istrue, we conclude that Ïƒdoes not terminate. If Ïˆistrue,
we conclude that Ïƒterminates. Otherwise, we mark Ïƒas unknown.
Tocompute each Ï•iandÏˆimentionedabove, weneed todeter-
minethemonotonicityof Ei.Themonotonicityofonevariablecan
beanalyzedbythestatictechniquein[ 39],whichsupportsthree
types: basic monotonic statements, dependent monotonic state-
ments,andcyclicallymonotonicstatements.Weextenditintwo
aspects:1)checkthemonotonicityforabasicexpressionsuchas
addition and subtraction on multiple variables. For example, when
xisincreasingand yisdecreasing,then xâˆ’yisincreasing, yâˆ’x
is decreasing and x+yis unknown. 2) a backward reasoning to
computethe sufficient conditionswhich can makethe variable or
expressionincreasemonotonically,decreasemonotonicallyorbe
constant (i.e., does not change). For example, in the basic mono-
tonic statement x=x+a, the sufficient condition, which makes
xmonotonic increasing, is a>0, monotonic decreasing is a<0
and constant is a=0. In the dependent monotonic statements
x=x+y;y=y+a,thesufficientcondition,whichmakes xstrictly
monotonic increasing, is y0>0âˆ§aâ‰¥0, where y0is the initial
value for variable ybefore executing the path.
Forthosecasesinwhichthemonotonicitycannotbedetected
by [39] or the sufficient condition cannot be computed by our
extension, we leverage temporal-logic proving techniques [ 18,31].
We generate one dummy loop which only contains one path Ïƒ
and prove the CTL property AG[Î¸Ïƒ]in the loop. If the result is
true, it means that the path condition Î¸Ïƒalways holds during the
execution of Ïƒ, i.e., the path Ïƒdoes not terminate. If the result is
false, we check the CTL property AF[Â¬Î¸Ïƒ]. If the result of the
secondpropertyis true,itmeansthatthepathcondition Î¸Ïƒwill
notholdeventually,i.e.,thepath Ïƒterminates.Iftheresultsofboth
properties are falseor the CTL checking is unable to produce a
conclusiveresult,wemark thepath Ïƒasunknownandset both Ï•
andÏˆto be falsesince we cannot compute the nonterminating
and terminatingsufficient conditions.
Lemma 1. If an accepting state ÏƒâˆˆFis marked as terminating,
thentail(Ïƒ)must be an exit block.
Example3.1. InFig.4(a),thereisaloopconsistingofonlyone
path,whosepathconditionis x>0.Wethencomputethecondition
(as the nonterminating sufficient condition) which can make x
increasing monotonically. Obviously, xis always increasing and
thusÏ•istrue. Hence the path is marked as NT. In Fig. 4(b), we
87Loopster: Static Loop Termination Analysis ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
knowxandyareincreasingmonotonically,where ycanbechecked
bybasic monotonic statements andxcan be checked by dependent
monotonicstatements .Thus,Ï•isfalseandÏˆistrue.Hence,the
path is marked as T. For the loop in Fig. 4(c), our extended strategy
can compute the sufficient nonterminating condition aâ‰¥0, under
whichxwillincreasemonotonicallyordoesnotchange,andthe
sufficientterminatingcondition a<0,underwhich xwilldecrease
monotonically.Theterminationofthepathdependsontheinput
ofa. Thus we mark the path as UN.
3.2 Inter-PathAnalysis
Afteranalyzingwhethereachpathisterminating,weneedtofur-
ther analyze the dependency between each two paths, i.e., whether
a path is able to transit to another. Algorithm 1 shows how to con-
structthetransitionsinaPDA x.TheinputistheCFG Goftheloop
and we use/producttext.1
Gto represent the set of all feasible paths in G. Note
thatÏƒican only transit to the path Ïƒjwhose head node is equal
to the tail of Ïƒi(i.e.,tail(Ïƒi)=head(Ïƒj)at Line 2). A variable is an
inductionvariable(IV)whenitischangedbyaconstantvalueor
assigned by constant values in each iteration of the path. A condi-
tioneâˆ¼0 is an IV condition [ 47] if the expression e(regarded as
avariable)isanIV.Ifallvariablesin ÏƒiareIVsandallconditions
inÎ¸ÏƒiandÎ¸Ïƒjare IV conditions, we introduce kijto represent the
numberofiterationsof Ïƒibeforetransitingto Ïƒj.Withthevariable
kij,wecancalculatetheeffectaftersomeexecutionsof Ïƒiforall
the IVs. For example, if x=x+1 in each iteration of Ïƒi, then
we can calculate x=x+kafterkexecutions of Ïƒi. We compute
the value of IVs after kijâˆ’1 andkijexecution of Ïƒi, denoted by
Xkijâˆ’1andXkij, respectively (Line 5â€“6). Î¸[X/prime/X]represents that
thevariables XinÎ¸aresubstitutedwith X/prime.AtLine7,wecompute
theweakestprecondition Ï‰ijfortriggeringthetransition (Ïƒi,Ïƒj).
head(Ïƒi)=tail(Ïƒi)?kijâ‰¥1:kij=1 means if the head node and
tailnodearethesamenode,then Ïƒicanbeexecutedmorethanone
timebefore executing Ïƒj. Otherwise, itcan only execute onetime.
IfÏ‰ijissatisfiable,then Ïƒjcanbeexecutedafter kijiterationsof
Ïƒi(Line 8) and we add the transition to T(Line 9). Note that the
introduced variable kijcan be bounded in the predicate Ï‰ij.
If there are some non-IVs or non-IV conditions, we cannot com-
putethetransitionwith kij.Weusethetemporal-logicproverto
check whether the transition is feasible (Line 10â€“13). We create
one dummy loop Lwhich only contains the path Ïƒiand check the
CTL property EF[Î¸Ïƒj]during the loop execution (Line 12). If the
property is satisfied, Ïƒimaytransit to Ïƒjin some cases. If it is not
satisfied, there is no transition from ÏƒitoÏƒj.
Example3.2. InFig.1,allvariablesareIVsandalltheconditions
are IV conditions. For example, x<nis an IV condition because
xâˆ’nischangedbyaconstant.Wecanusethefirststeptocompute
the transition. To check whether Ïƒ1can transit to Ïƒ2, we compute:
Xk12âˆ’1:(x=x+k12âˆ’1)âˆ§(n=n)âˆ§(z=z)
Xk12:(x=x+k12)âˆ§(n=n)âˆ§(z=z)
Ï‰12=(x<n)âˆ§(z>x)âˆ§(x+k12âˆ’1<n)âˆ§(z>x+k12âˆ’1)
âˆ§(x+k12<n)âˆ§(x+k12â‰¥z)âˆ§(k12â‰¥1)
Hence,thereisatransitionfrom Ïƒ1toÏƒ2becauseÏ‰12issatisfi-
able.k12is bounded by k12â‰¥1âˆ§z>x+k12âˆ’1âˆ§x+k12â‰¥z.
Let us see how the second step works. In Fig. 4(b), to check
whetherthereisatransitionfromthestate Ïƒ1(Î¸Ïƒ1isx<0âˆ§y>0)Algorithm1: ComputeTran (G)
input :G: CFG
1Let/producttext.1
Gbe the set of all feasible paths in G;
2foreach(Ïƒi,Ïƒj)âˆˆ{ (Ïƒm,Ïƒn)|Ïƒmâˆˆ/producttext.1
Gâˆ§Ïƒnâˆˆ/producttext.1
Gâˆ§tail(Ïƒm)=
head(Ïƒn)âˆ§m/nequaln}do
3ifAll variables XinÏƒiare IVs, and all conditions in Î¸ÏƒiandÎ¸Ïƒj
are IV conditions then
4 Letkijrepresent the iteration count of Ïƒi;
5 Xkijâˆ’1:=F(X,kijâˆ’1)computes the value after kij-1
iterations of Ïƒi;
6 Xkij:=F(X,kij)computes the value after kijiterations of
Ïƒi;
7 Ï‰ij:=Î¸Ïƒiâˆ§Î¸Ïƒi[Xkijâˆ’1/X]âˆ§Î¸Ïƒj[Xkij/X]âˆ§(head(Ïƒi)=
tail(Ïƒi)?kijâ‰¥1:kij=1);
8 ifÏ‰ijis satisfiable then
9 T:=T/uniontext.1{(Ïƒi,Ïƒj)};
10else
11 Create loop Lwhich only contains path Ïƒi;
12 ifEF[Î¸Ïƒj] holds for Lthen
13 T:=T/uniontext.1{(Ïƒi,Ïƒj)};
totheacceptingstate Ïƒ2(Î¸Ïƒ2isxâ‰¥0âˆ¨yâ‰¤0),wecannotusethe
firststepasthevaluechangeof xisnotconstant.Inthiscase,we
checkEF[Î¸Ïƒ2], and it is true. Thus we know Ïƒ1can transitto Ïƒ2.
3.3 Loop Termination Analysis
With the PDA xconstructed, we can determine the overall termina-
tionofthetargetloop.Theorem1andTheorem2belowgivethe
sufficientconditionsonaPDA xforitscorrespondingtargetloop
being terminating or nonterminating, respectively. Based on the
twotheorems,adepth-firstsearchcanbeusedtocheckwhetherthe target loop terminates. If there are some unknown states or
cyclesinthePDA x,wewillperformarefinement(Section3.4)or
reduce cycles from the PDA x(Section3.5).
Theorem 1. If aPDA xsatisfiesthe two conditionsbelow, itscor-
respondingloopterminates:1)itisacyclic,and2)itsstates(reachable
from initial states) are all marked as terminating.
Theorem2. IfaPDA xhasareachablestatewhichismarkedas
nonterminating,its correspondingloop does not terminate.
3.4 Refinement
So far, our approach is presented in a way such that each path
is analyzed independently, i.e., the effects from other paths arenot considered. For example, a path
Ïƒ, if analyzed alone, may be
marked asunknown. However, it couldbe actuallyterminating or
nonterminatingunderthe precondition Pre(Ïƒ).
To be more accurate for determining the termination of each
path, we need to refine the states that are marked as unknownaccording to the execution of the loop. Algorithm 2 gives a DFS-
basedalgorithmtorefinethestatesthataremarkedasunknown
in an acyclic PDA x. Given a state Ïƒand its precondition Pre(Ïƒ),
Algorithm2refinesthenonterminatingorterminatingsufficient
conditionsofthestate ÏƒandvisitsitssuccessorstatesinaDFS-style.
isspisabooleanvaluewhichdenoteswhether Pre(Ïƒ)isastrongest
postcondition of the previous state.
88ESEC/FSEâ€™17,September 04-08, 2017, Paderborn, Germany X. Xie, B. Chen, L. Zou, S. Lin, Y. Liu and X. Li
Algorithm2: RefineState (A,Ïƒ,Pre(Ïƒ),issp)
input :A:P D Ax;Ïƒ: a state of A;
Pre(Ïƒ): the precondition of Ïƒ;
issp: boolean value;
output:A refined PDA x
1ifPre(Ïƒ)âˆ§Î¸Ïƒis satisfiable then
2ifÏƒis marked as UN then
3 ifissp=trueâˆ§Pre(Ïƒ)=â‡’Ï•Ïƒthen
4 markÏƒas NT;
5 return;
6 ifPre(Ïƒ)=â‡’ÏˆÏƒthen
7 Ïƒ.list.append (T);
8LetÎ£be the set of successors of Ïƒ;
9foreachÏƒ/primeâˆˆÎ£do
10ifAll variables XinÏƒare IVs and all conditions in Î¸ÏƒandÎ¸Ïƒ/primeare
IV conditions then
11 Pre(Ïƒ/prime):=sp(X:=F(X,kij),Pre(Ïƒ)âˆ§Ï‰(Ïƒ,Ïƒ/prime));
12else
13 Pre(Ïƒ/prime):=Î¸Ïƒ/prime;
14 issp:=false;
15 RefineState (A,Ïƒ/prime,Pre(Ïƒ/prime),issp);
Givenastate Ïƒanditsprecondition Pre(Ïƒ),weonlyrefinethe
terminationstatusof Ïƒinthecasewhere(1) Ïƒisreachableunder
its precondition, i.e., Pre(Ïƒ)âˆ§Î¸Ïƒis satisfiable (Line 1), and (2) Ïƒis
marked as unknown (Line 2). Note that if Pre(Ïƒ)is the strongest
postconditionofthetraversedpathand Pre(Ïƒ)âˆ§Î¸Ïƒissatisfiable,
thenÏƒmust be reachable. The refinement is performed for the
followingcases:
â€¢If the condition Pre(Ïƒ)=â‡’Ï•Ïƒholds, it means that the non-
terminating sufficient condition of Ïƒis satisfiable under the pre-
condition of Ïƒ. Then we can conclude that Ïƒdoes not terminate
(Line 3â€“5). In this case, we can conclude that the overall loop
does not terminate by Theorem 3.4.
â€¢Ifthecondition Pre(Ïƒ)=â‡’ÏˆÏƒholds,theterminatingsufficient
conditionof Ïƒissatisfiableunderthepreconditionof Ïƒ.Inthis
case,weappendT,whichrepresentsthatthestate Ïƒisrefinedas
terminatingalongthecurrenttrace,tothelist Ïƒ.list(Line6â€“7).
Tocontinuetherefinementoneverysuccessorof Ïƒ,wecompute
the postcondition after some execution of Ïƒ, which is also the pre-
condition of Ïƒ/prime. At Line 11, we infer the strongest postcondition
Pre(Ïƒ/prime),wherePre(Ïƒ)isfrominputand Ï‰(Ïƒ,Ïƒ/prime)hasbeencomputed
at Line 7 of Algorithm 1. X:=F(X,kij)is a sequence of assign-
ment instructions and is computed at Line 6 of Algorithm 1. If the
conjunction of Pre(Ïƒ/prime)andÎ¸Ïƒ/primeis satisfiable (i.e., the next traversal
atLine1),thenthereexistsavariable kijthatmakes Ïƒ/primereachable
becausePre(Ïƒ/prime)isthestrongestpostconditionofthepreviousstate
Ïƒ.Otherwise, weuseaconservative andsoundcondition,i.e., the
pathconditionof Ïƒ/prime,asthepostconditionof Ïƒ,whichalsoservesas
thepreconditionof Ïƒ/prime(Line13). Î¸Ïƒ/primeisnotastrongestpostcondition
andisspis assigned false(Line 14).
Algorithm3refinesthewholePDA xbyinvokingAlgorithm2
for all initial states, and returns a set of refined PDA xbased on
different initial states. We assume the precondition of the loop is a
strongestpostconditionand isspisassigned true.Algorithm3aims
to check whether a state Ïƒoriginally marked as unknown couldAlgorithm3: RefinePDA (A,Pre(A))
input :A=(S,I,F,T):aP D Ax;
Pre(A): the precondition of A
output:A set of refined PDA x
1Î©â†âˆ’ âˆ…;
2foreachÏƒâˆˆIdo
3A/prime=RefineState (A,Ïƒ,Pre(A),true);
4foreachstateÏƒinA/primemarked as UN do
5 ifeach element eâˆˆÏƒ.listis Tthen
6 markÏƒas T;
7 Î©â†âˆ’Î©âˆª{A/prime};
be refined as terminating (Line 4â€“6). Notice that we can do so only
when all the markings in the list Ïƒ.listare T, which means Ïƒis
terminating in all paths. Note that Algorithm 3 assumes that the
inputPDA xisacyclicsuchthattheterminationofAlgorithm2is
guaranteed, and the cyclic PDA xwill be described in Section 3.5.
To sum up, given a target loop represented by a PDA xA,i fw e
cannotdirectlydecideitsterminationbyTheorem1andTheorem2,
wecanapplyAlgorithm3on Atorefineeachstatethatisoriginally
marked as unknown. Let Î©be the set of refined PDA xobtained
by invoking RefinePDA (A,Pre(A)). We can further analyze the
targetloopbasedon Î©byCorollaries3.3and3.4.Ifbothofthem
do not hold, we mark the loop as unknown.
Corollary 3.3. IfA/primesatisfies Theorem 1 for all A/primeâˆˆÎ©, then
thetarget loop terminates.
Corollary 3.4. IfA/primesatisfies Theorem 2 for some A/primeâˆˆÎ©, then
thetarget loop does not terminate.
Notice that the refinement can only be used in acyclic PDA x
currently.IncyclicPDA x,theexecutioncountofthecyclemightbe
unknown.Thus,Algorithm2maynotterminateforcyclicPDA x;
and we leave the refinment of cyclic PDA xin the future work.
3.5 Cyclic-PDA xAnalysis
Theorem1requiresthePDA xtobeacyclic.Givenacyclic-PDA x,
even though all of its states are marked as terminating, we cannot
conclude that the loop terminates since it may have an infinite
execution between the states in the cycle. For example, in the loop
while(x<11){if(x<10) x++; else x- -;} . All the three paths are marked
as terminating, however the loop does not terminate since there is
an infinite execution in the cycle. To determine the termination of
a cyclic-PDA x, we need further analysis on cycles.
We firstly detect the strongly connected components (SCCs)
fromthePDA x.NoticethatweonlyconsidertheSCCwithmore
thanonestate(i.e.,thecycleinthePDA x)here.Ourmainideaof
terminationanalysis on cycles is as follows:
(1)Trytoprovetheterminationbyreducingthecyclic-PDA xto
acyclic-PDA x(c.f. Section 3.5.1).
(2)Try to prove the nontermination by finding one reachable non-
terminatingstate in the SCC (c.f. Section 3.5.2).
3.5.1 Proving Termination. Akeyobservationisthatsomestates
willnotbeexecutedaftersomeiterationsoftheSCC,thentheSCC
can be reduced to a simple structure. The main idea of proving
termination is to reduce the cyclic-PDA xto an acyclic-PDA xby
89Loopster: Static Loop Termination Analysis ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
finding the pivot states which will not be executed eventually. For
example, in the cyclic-PDA xFig. 1(c), the SCC is {Ïƒ1,Ïƒ2}.T od e -
termine whether the SCC can terminate, we find the pivot state Ïƒ1
whichwillnotbeexecutedafter xincreasestobe n.Hence,theSCC
is reduced (after Ïƒ1terminates) and becomes acyclic. We formulate
the conceptas follows.
Inspired by ranking functions, we check whether each state can
be a pivot state as formulated in Definition 3.5.
Definition3.5. LetÏƒmâˆˆSbeastatein A=(S,I,F,T).Thestate
Ïƒmis apivotstate if we can find a function f(X)suchthat:
â€¢Î¸Ïƒm=â‡’f(X)â‰¥c, wherecis a constant value.
â€¢f(X)will be monotonic decreasing after some execution of Ïƒm.
â€¢f(X)is decreasing or not changed in any other state ÏƒâˆˆS.
Intuitively,apivotstatecanbeexecutedforafinitenumberof
iterations.Thus,wecanbreaktheSCCbyremovingthetransitions
whichend with a pivot state, as formulated in Definition 3.6.
Definition 3.6. LetA=(S,I,F,T)be a PDA xwith all states
markedasterminating.If AhasanSCC,denotedby C,wesayAis
safetobe reducedas AÏƒm=(S,I,F,T/prime)ifwecanfind a pivotstate
ÏƒmâˆˆC,wherethetransition T/primeisdefinedas T/prime=T\{(Ïƒ1,Ïƒ2)âˆˆ
T|(Ïƒ2=Ïƒmâˆ§Ïƒ1âˆˆC ) }.
Lemma 2. LetAbe a cyclicPDA xsuch that Ahas oneSCC and
allstatesof Aaremarkedasterminating.If Acanbesafelyreduced
by a pivot state ÏƒmandAÏƒmis acyclic, then Aterminates.
NoticethatifthereducedPDA xisacyclic,thenwecanconclude
that the loop terminates. If the reduced PDA xis still cyclic, we
recursively apply Lemma 2 (if possible) on the reduced PDA xuntil
thereducedPDA xisacyclic.Otherwise,wemarkthetermination
of the loop as unknown .
Example3.7. InFig.1(c),wecaninferthat nâˆ’xismonotonically
decreasingin Ïƒ1,nâˆ’x>0,andnâˆ’xdoesnotchangein Ïƒ2.Hence
Ïƒ1isapivotstate,anditisterminatingafterremovingthetransition
(Ïƒ2,Ïƒ1).InFig.2(c),from z>yâ‰¥1andzdecreasesin Ïƒ2,w ecan
first find one pivot state Ïƒ2. After removing ( Ïƒ1,Ïƒ2) from the SCC,
itisacyclicPDA xandthecycleinthenewPDA xis(Ïƒ1,Ïƒ3).Inthe
cycle, from xâˆ’âˆ’âˆ§y=y+x, we know ywill decrease eventually.
Then we find another pivot state Ïƒ3. Finally, the PDA xbecomes
acyclic and we prove it can terminate.
3.5.2 Proving Nontermination. Toprovethenonterminationof
a cyclic-PDA x, which contains the nonterminating or unknown
states,weunrolltheSCCforseveraltimestorefinetheunknown
state and check whether any nonterminating state can be reached.
Tomakethecheckingefficient,weonlytraverseeachcycleonce
(the number of unrolling can be adjusted). If we cannot find the
reachable nonterminating state after a certain number of iterations
of the cycle, then we conclude the loop is unknown.
4 IMPLEMENTATION AND EVALUATION
We implemented Loopster based on LLVM 3.7 [ 35] and the SMT
solverZ3[ 24].TheinputisaloopprograminClanguage,whichis
compiledintoLLVMIR.Weusetheslicingtechnique[ 42]toreduce
irrelevant pathsin the constructed control flow graph.Thegoalofourevaluationistodemonstrate(1)theeffectiveness
andperformanceimprovementofourstaticapproachbycompar-
ing with the state-of-the-art tools on the loops in a benchmark
(Section 4.1 and 4.2) and (2) the effectiveness and scalability of our
static approach on the loops in real-world projects (Section 4.3).
Note thatwe use wall time in the experimental results.
4.1 ExperimentalResults on Loop Benchmarks
To evaluate the performance of Loopster, we selected 69 difficult
loop programs from the termination-crafted benchmark and 32 pro-
grams with numeric nested loops from the termination category
in Competition on Software Verification 2016 (SV-COMP 16) [ 1].
Thetermination-crafted benchmarkconsistsof85non-trivialpro-
grams,and70ofthemcontainloops.Weusedthe70programsin
the experiments, where 38 programs areknown to be termination
and31programsareknowntobenon-termination.Oneprogram
Collatz_unknown-termination.c is known to be unknown and we
omitthiscaseforavoidingambiguity.Forthe32nestedloops,27of
them are terminating, and 5 of them are nonterminating. All these
programsaredesignedtobesimplifiedprogramswhichdonotneed
slicing.Hence,slicingdoesnotaffectthefairnessofthecomparison.
We compared Loopster against three termination analysis tools.
AProVE and UAutomizer respectively won the first and second
prize for the termination category in SV-COMP 16 [ 1]. T2 is an
advancedverificationtool,whichhasmuchbetterperformanceand
effectivenessthanothertoolsorconfigurations(e.g.,ARMC[ 44],
Size-change/MCNP [ 16], and KITTeL [ 25]), as empirically demon-
strated in [ 12]. Thus, the selected three tools represent the state
of the art. Specifically, AProve and UAutomizer we used are the
provided versions for SV-COMP 16 and T2 is the version 2016. We
ran allthe tools with the timeout being 900 seconds.
Table1reportstheresultsofthesetoolsonthebenchmarks.The
second column reports the numbers of terminating ( T) and nonter-
minating ( NT) loop programs in unnested and nested benchmarks;
CRrepresentsthenumberofprogramsthatcanbecorrectlyana-
lyzed,CTrepresentsthetimeoverheadforthecorrectlyanalyzed
programs,and TTrepresentsthetimeoverheadforalltheprograms
(including those that time out). For Loopster, CTLrepresents the
number of programs which used the temporal-logic prover.
From Table 1, we can see that Loopster can correctly handle
93 (92.08%) programs (including 61 (92.85%) terminating programs
and 32 (88.89%) nonterminating programs) in 7.76 seconds. For the
othertools,AProVEcan correctlyhandle84(83.17%)programsin
11964.95seconds;UAutomizercancorrectlyhandle92(90.10%)pro-
grams in 2246.62 seconds; and T2 can correctly handle 80 (79.21%)
programs in 1620.19 seconds. This indicates that the time overhead
of these three tools is very expensive (some programs may time
out); and the performance improvement of Loopster over these
tools is dramatic. Note that even only considering the time over-
head of the correctly analyzed programs (ignoring the programsthat time out), Loopster is still much more efficient: it took 7.36seconds for 93 programs; but AProVE took 174.30 seconds for 84
programs,UAutomizertook315.18secondsfor92programs,and
T2 took 249.09 seconds for 80 programs.
For the monotonicity analysis in Loopster, 89 (88.12%) programs
can be handled by our extended static technique; and 12 programs
90ESEC/FSEâ€™17,September 04-08, 2017, Paderborn, Germany X. Xie, B. Chen, L. Zou, S. Lin, Y. Liu and X. Li
Table 1: Experimental Results on the Benchmark
ProgramLoopster AProVE UAutomizer T2
CRCT(s)TT(s) CTLCRCT (s) TT(s) CRCT (s) TT(s) CRCT (s) TT(s)
UnnestedT (38) 353.74 4.03 43294.06 3739.13 34137.09 1104.93 2580.161439.76
NT (31) 281.48 1.51 42130.20 7274.47 2756.40 120.00 23150.28 161.78
NestedT (27) 261.76 1.79 42641.42 942.73 26105.17 1005.17 2714.93 14.93
NT (5) 40.38 0.43 058.62 8.62 516.52 16.52 53.72 3.72
Total (101) 937.36 7.76 1284174.30 11964.95 92315.18 2246.62 80249.09 1620.19
Table 2: Detailed Results of Comparison
Program Loopster AP.UA.T2
93 programsâˆš788575
McCarthy91_Iteration_true-termination.c Cycleâˆšâˆšâˆš
NO_03_false-termination.c Cycleâˆšâˆšâˆš
TelAviv-Amir-Minimum_true-termination.c Cycle Ã—âˆšÃ—
Piecewise_true-termination.c CycleâˆšâˆšÃ—
LogAG_true-termination.c Monâˆšâˆšâˆš
NonTermination2_false-termination.c MonâˆšâˆšÃ—
Division_false-termination.c Monâˆšâˆšâˆš
LexIndexValue-Pointer_false-valid-deref.c MEM-N Ã—Ã—âˆš
cannotbehandled,andthustheproverisusedfortheirpathtermi-
nationanalysis.Itindicatesthatthemonotonicitycanbesuccess-
fullydetectedinmostprograms,anditisausefulpropertythatcan
be used for loop termination analysis. The average time used with
prover and monotonicity are similar ( <0.1s) in the benchmarks.
Further, we provide a detailed analysis of how often different
analysismethodsinourapproachareneededtoprove(non)termination
forthebenchmark.Forthe93handledprograms,36(39%)programs
can be proved with Theorem 1 and 2 after we construct the PDA x.
27(29%)programscontaintheunknownstatesintheconstructed
PDAx, and we first perform refinement analysis and then conclude
the result with Theorem 1 and 2. 30 (32%) programs contain cycles
intheconstructedPDA x,andthusweperformthePDA xreduction
analysis. The results show that the refinement and cycle reduction
are very important and effective to prove loop termination.
In summary, Loopster can handle more programs correctly with
much less time overhead (20 Ã—+performance improvement even
if only considering those correctly analyzed programs), which
shows the effectiveness and performance improvement of Loop-
sterover the state of the art. The biggest advantage of Loopster
owestoourstaticanalysis,whileothertoolsneedexpensivetime
overhead to infer and validate ranking functions on demand.
4.2 Detailed Comparison with State-of-the-Art
TodiscusstheadvantagesanddisadvantagesofLoopsteroverthe
ranking function-based approaches, we give the detailed results of
the programs that can/cannot be handled by Loopster but cannot/-
can be handled by AProVE, UAutomizer and T2 in Table 2.
Thefirstrowindicatesthat,amongthe93programsthatLoopster
can handled, AProVE, UAutomizer and T2 can respectively handle
78, 85 and 75. After analyzing the programs that cannot be handle
by other tools, we summarize our advantages as follows.
â€¢Using Monotonicity . Monotonicity [ 39] is a common and use-
ful property in the loop iteration. By using the monotonicity,
wecanoftenconcludeterminationornonterminationquickly.
For example, all the other three tools failed to handle the pro-gramHanoi_plus_false-termination.c , but Loopster proved its
nontermination in about 0.04 seconds. Specifically, Loopster cancomputeanonterminatingsufficientconditionafteranalyzing
the monotonicity of x. In this program, the monotonicity of x,y
andzbelong to cyclic monotonicity, and Loopster computes the
nonterminating sufficient condition as x0>0âˆ§y0>0âˆ§z0>0.
â€¢Considering the Precondition . We can handle programs whose
terminationdependsonthepreconditionoftheloopwhilethe
other tools may fail. For example, all the other three tools failed
tohandle Gothenburg_v2_true-termination.c asitsresultdepends
on the precondition a==b+1âˆ§x<0. However, our refine-
ment analysis refines the termination status of each state by
consideringthe precondition.
â€¢Reducing Complexity . With our divide-and-conquer strategy (i.e.,
theterminationanalysisineachpath,andthentheoveralltermi-nation of the loop), we can reduce the complexity when proving
the termination of some programs that need complex ranking
functions.Forexample,provingtheterminationof Pure3Phase_true-
termination.c needs a 3-phase ranking function, and T2 spent
45 seconds and UAutomizer timed out. Proving the termination
ofaaron3_true-termination.c needs a multi-dimensional rank-
ing function, and UAutomizer spent 17 seconds and AProVE
timed out. Instead, Loopster correctly handled them in less than
one second without computing complex ranking function.
Ontheotherhand,thereareeightprogramsthatLoopsterfailed
tohandlecorrectly,asshowninTable2.Thesecondcolumnreportsthefailurereasons,including1)thecyclecannotbereduced(marked
asCycle), 2) the monotonicity cannot be detected (marked as Mon),
and3)thenonterminationoftheprogramiscausedbyamemory
vulnerabilitywhichinterferes themonotonicity(markedas MEM-
N). Hence, the main disadvantages of our approach are as follows.
â€¢Monotonicitycannotbedetected .Insuchcases,wecannotcom-
pute the (non)terminating sufficient condition, and thus the
refinement may fail. For example, for NonTermination2_false-
termination.c , we cannot compute the nonterminating sufficient
conditionas the monotonicity of x/oldxcannotbe detected.
â€¢The cycle in a cyclic-PDA xmay not be reduced . In such cases,
we cannot 1) prove the termination, or 2) detect the nontermi-
nation that is caused by the cycle. For example, all the paths
inNO_03_false-termination.c are terminating, but Loopster re-
turnsunknownaswecannotfindthepivotstatetoreducethe
cyclic-PDA xfor proving its termination.
In summary, Loopster and the ranking function-based ap-
proachesarecomplementarytoeachother.Fortheloopsthat
AProVE, UAutomizer and T2 cannot handle, Loopster can be
used by them to reduce the complexity and improve the effi-
ciencyforinferringcomplexrankingfunctions.Fortheloops
wecannothandle,wecanextendLoopstertoprovideadvanced
monotonicityanalysis based on ranking functions.
91Loopster: Static Loop Termination Analysis ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
Table 3: Experimental Results on Real Projects
Project Loops Sliced Handled Time (s) NT
gmp 1545 376 (24%) 1188 (77%) 13.07 13
libxml 38472218 (58%) 1081 (28%) 42.73 8
httpd 1428 803 (56%) 386 (27%) 35.57 2
Total 68203397 (50%) 2655 (39%) 91.37 23
4.3 ExperimentalResultson Real Projects
To evaluate the effectiveness and scalability of our static approach,
we ran Loopster on the loops in three open source real-world
projects, including the arithmetic library gmp-6.0.0 , the XML C
parser and toolkit libxml2-2.9.3 , and the Apache HTTP Server
projecthttpd-2.4.18 . We extracted the loops in these projects by
llvm looppass [4]. Theprecondition of each loopis determined by
theinitializationofthevariablesbeforetheloop.Iftheinitialvalue
dependsonthecomputationbeforetheloop,weassumethatitis
nondeterministic,whichmaycauseinaccurateresultbutdoesnot
affect the soundness of our approach.
Table 3 shows the results of our analysis on these projects.
The column Loopsshows the number of extracted loops in each
project. The column Slicedlists the number of loops that can be
sliced by our slicing technique. The columns HandledandTime
give the number of loops we can handle correctly and the timerequired for the analysis. The column NTreports the number of
nonterminatingloops we identified.
Among the total 6820 loops, 3397 (50%) loops can be sliced to
reduceirrelevantpathsandimprovetheeffectivenessandperfor-
mance of our static approach. For example, one program from
httpd-2.4.18 contains more than 10 paths. After slicing, the loop
becomes for(c=0;c <256;++c)andhas onlyonepath,makingiteasy
to analyze its termination. Therefore, slicing is necessary to termi-
nation analysis, especially for complex loops in real-world projects.
On one hand, 2655 (39%) loops can be correctly handled in 91.37
seconds. There are 23 nonterminating loops since we set their pre-
condition to be nondeterministic for simplicity and cause an over-
approximationtotheirrealprecondition.Forexample,inFig.5,the
value ofchunk_nbitsdepends on the computation before this loop,
but we set it to be nondeterministic. Thus, the loop is terminating
whenchunk_nbitsisgreaterthan zero,andnonterminatingwhen
chunk_nbitsis less than or equal to zero.
Ontheotherhand,Loopstercannothandle4165(61%)loopsdue
to two main reasons: 1) the loops contain complex data structures
(e.g., arrays, heaps) and function calls, 2) the variables are updated
by complex computation (e.g., bitwise calculator), which makes
the monotonicity calculation difficult. Actually, the two challenges
are orthogonal to our research and the possible solutions will be
discussed in Section 4.4.
Inparticular, gmpisanarithmeticlibrary,whichhasmanyin-
teger or simple pointer calculation related loops. Thus, Loopster
canhandle77%oftheloops. libxmlandhttpdcontainmanycom-
plex data structures (e.g., XML parser in libxmland HTTP protocol
handlingin httpd),andthuswecanonlyhandle27%oftheloops.
Hence, except for the challenging loops described above, which
are orthogonal to our approach and also non-trivial to be handled
by the state-of-the-art tools, a large part of the loops in real-world
projects can be analyzed by the static approach efficiently.intrbitpos=__VERIFIER_nondet_int();
intchunk_nbits=__VERIFIER_nondet_int();
intnbits=__VERIFIER_nondet_int()
while(rbitpos + chunk _nbits <= nbits)
rbitpos += c hunk_nbits;
Figure 5: A Simplified Loop from gmp
WealsoattemptedtocompareLoopsterwiththestate-of-the-art
tools on the loops from these r eal-world projects. However, the
state-of-the-arttoolscannotdirectlyworkontheserealloopswith-
out modification. Therefore, we manually modified a set of loop
programs based on the loops in these real-world projects by the
following three steps: 1) remove the simple loops that are trivial to
checkaswellastheloopsthatarenotsupportedbyLoopsterand
thestate-of-the-arttools(e.g.,loopsthatcontaindatastructuresand
function calls that affect the loop termination), 2) randomly select
10 loops for each project from the remaining loops, and 3) adapt
the selected loops by putting the loops in a main function, adding
initializationforthevariablesintheloopsandsimplifyingcomplexstatements and function dependencies that are not relevant to loop
termination to make them executable. These modified programs
canbefoundin[ 5],asabenchmarkforfutureresearchonloopter-
minationanalysis.Noticethat,wecomparedLoopsterwithAProVE
and UAutomizer but not T2 because llvm2KITTeL [ 3] failed to con-
vert most of the real-world loops into T2â€™s input format. Instead,
weranthetool2LS[ 2](verion0.3.0)sinceithasbeenempirically
demonstrated that 2LS can check larger programs with thousands
of lines of code [14]. Here we set the timeout to 300 seconds.
Table 4 shows the comparison results on the modified loop pro-
grams.Thecolumn CRliststhenumberofcorrectlyhandledpro-
grams, and the column Treports the time overhead. Among the
total30modifiedloopprograms(underthecolumn Modified),Loop-
ster can check all of them correctly in 1.39 seconds, while AProVE
can onlycheck 3 programs in 356 seconds, UAutomizer can check
16 programs in 423 seconds, and 2LS can check 13 programs in
332 seconds. The results show that the three tools can only handle
a small part of the loops but need much time since the loops in
real projects contain some complex statements (e.g., array com-
parisonanddatastructure)thatareirrelevanttothetermination.
Loopstercanhandlesuchloopswellsinceweperformaprogram
slicing to reduce the irrelevant statements. To ensure a fair com-
parisonacrossthesetools,weslicedtheloopprogramsmanually
andalsoran thestate-of-the-arttoolsonthe slicedversion(under
the column Sliced). With the sliced programs, all the three tools
cancheckmoreprogramswithmuchlesstime.Still,Loopstercan
handlemuchmoreprogramswithmuchlesstimethanothertools.
Insummary,Loopstercanhandlesomeloops(39%)inreal-world
projectsefficiently,whichindicatestheeffectivenessandscalabil-ityofourtoolonreal-worldloops.Inaddition,thestate-of-the-art
tools often have limitations to analyze real-world loops, and slic-
ing is a useful preprocessing step for termination analysis.
4.4 Discussion on the Unsupported Loops
Advancedmonotonicityanalysiscanbedevelopedtosupportthe
loops with data structures. For example, by modeling the contents
ofheapsorabstractingpointeroperatorsasarithmeticprograms.
Slicingcan alsohelp toremovethe structuresthatdo notaffect the
92ESEC/FSEâ€™17,September 04-08, 2017, Paderborn, Germany X. Xie, B. Chen, L. Zou, S. Lin, Y. Liu and X. Li
Table 4: Experimental Results on the Real-world Loop Programs
ProjectLoopsterAProVE UAutomizer 2LS
Modified Sliced Modified Sliced Modified Sliced
CRT( s )CRT( s )CRT( s ) CRT( s )CRT( s ) CRT( s )CRT( s )
gmp (10) 100.51 119.19 113.42 5257.47 7125.39 69.32 64.88
libxml (10) 100.50 011.99 218.09 649.11 645.37 42.74 42.21
httpd (10) 100.40 3320.31 618.75 5114.01 789.42 3319.83 65.60
Total (30) 301.39 3356.90 9118.36 16423.49 20270.34 13332.05 1613.05
termination. In addition, we also plan to investigate the possibility
to integrate the existing techniques for handling heaps [ 8] and
bitvectors [ 14,19,23]. For multi-thread loop programs, we can try
totranslate suchprogramsinto sequentialprograms[ 6]and then
apply our approach. On the other hand, if we cannot handle the
cycleinaPDA x,the(non)terminationoftheloopcannotbedecided.
In this case, we can perform more specific analysis on the whole
effect of the cycle, e.g., unrolling the cycle for some times to get
more information or computing ranking functions.
5 RELATED WORK
Inthissection,wediscusstherelatedworkonterminationproving
and non-terminationproving.
5.1 Termination Proving
Existingresearchonterminationprovingmainlyfocusesonthesyn-
thesis of termination arguments. Michael and Henny [ 40,41] first
introduce the automatic synthesis of one-dimensional linear rank-
ingfunctionsoverlinearloops.ThenPodelskiandRybalchenko[ 43]
propose a complete method to synthesize linear ranking functions.
However, it is only used for single-path linear loops.
For complex programs, multi-dimensional and lexicographic
ranking functions are needed [ 7,9,10,15]. Christophe et al. [ 15]
propose a complete approach to compute multi-dimensional rank-
ing functions. Bradley et al. [ 9] generalize the method in [ 43]t o
multi-path loops and synthesize lexicographic linear ranking func-
tions based on inductive linear invariants. Then, this method isextended with template trees [
10]. Ben-Amram and Genaim [ 7]
studythecomplexityofthesearchforrankingfunctionsandprove
it to be a coNP-complete problem. Rybalchenko [ 45] proves pro-
gram termination and safety by ranking functions, interpolants,invariants, resource bounds, and recurrence sets with a series ofillustrating examples. Leike and Heizmann [
37] introduce some
linear ranking templates, such as multiphase, nested, piecewise,
paralleland lexicographical ranking templates.
In general, the main difficulties of termination proving based on
rankingfunctionsaretwo-fold.First,thesearchforefficientrankingfunctionsisnon-trivial.Lexicographicrankingfunctionsareneeded
for complex programs, while linear ranking functions can be only
usedincertaintypesofloops(e.g.,[ 40,43]).Unfortunately,itisdiffi-
cultandexpensivetofindlexicographicrankingfunctions[ 22].For
someprogramssuchasnon-terminationloops,thesearchmayevennotterminate.Second,thevalidityoftherankingfunctionsmaybe
expensive [ 22]. The validity of constraint-based ranking functions
oftendependsoninvariantsthatmustbestrongenough[ 12],oran
iterative approach [ 20]. Thus, such techniques are often expensive,
especially for complex multi-path loops.
Tomitigatethedifficultyinconstraint-basedsynthesisforlexi-
cographic ranking functions, several techniques [ 20,22,32,36]a r eproposedbasedonRamseyâ€™stheorem.Thebasicideaistofindaset
ofsimplelinearrankingfunctionsratherthanfindingnon-trivial
lexicographic ranking functions [ 22]. However, the validity of the
terminationargumentis still difficult.
Comparedwiththeabovetechniques,ourstaticapproachavoids
searchingrankingfunctions.Hence,Loopsterismuchfasterthan
ranking function-based techniques, as shown in the evaluation.
The limitation is that Loopster fails when monotonicity cannot be
detected or some SCC cannot be reduced by the static analysis.
Besides, several advances have been made to support division
and modulo arithmetic [ 11], bitvectors [ 14,19,23] and heaps [ 8],
which are not yet supported in Loopster.
5.2 Nontermination Proving
The approaches based on ranking function usually cannot decting
nontermination.Severaltechniques[ 6,13,27,28,33,46]havebeen
proposed to prove non-termination. Gupta et al. [ 27] propose to
generateallpossiblelassosbyexecutingtheprogramuntilsomecontrol location is re-visited, then check whether each lasso isfeasible by template-based constraint solving. Invel [
46] proves
non-termination by the combination of theorem proving and in-
variant generation. TREX[ 28] and T2[ 13] check non-termination
by searching and refining an under-approximation of the loop
thatcanmaketheloopneverterminate.CppInv[ 33]provesnon-
terminationwithaMAX-SMT-basedinvariantgeneration.Atiget
al. [6] propose to detect non-termination in multi-threaded pro-
gramsby a systematic translation to sequential programs.
Compared with the above techniques, Loopster reduces the non-
terminating proving to the reachability problem. The disadvantage
is that we currently consider the nonterminating path, the nonter-
minatingSCCis not considered yet, which is our future work.
6 CONCLUSION
In this paper, we have proposed a novel approach for loop ter-
mination analysis based on path termination analysis and path
dependency reasoning. We implemented the approach in Loop-
ster and demonstrated the capability of Loopster on a competition
benchmark and three real-world projects. The results have demon-
stratedtheeffectiveness,performanceandscalabilityofLoopster
over the state-of-the-art tools. In the future, we plan to extend
Loopsterbysupportingrecursiveprogramsandcomplexstructures,
and handlingmore loops with unsupported SCC.
ACKNOWLEDGMENTS
This research is supported by the National Research Foundation,
Singapore under its National Cybersecurity R&D Program (Award
No.NRF2014NCR-NCR001-30),theprojectM4081588.020.500000,
andtheNationalScienceFoundationofChina(No.61572349and
61272106).
93Loopster: Static Loop Termination Analysis ESEC/FSEâ€™17, September 04-08, 2017, Paderborn, Germany
REFERENCES
[1]2016. CompetitiononSoftwareVerification2016. http://sv-comp.sosy-lab.org/
2016. (2016).
[2]2017. 2LS for Program Analysis. http://www.cprover.org/wiki/doku.php?id=2ls_
for_program_analysis. (2017).
[3] 2017. llvm2kittel. (2017). https://github.com/s-falke/llvm2kittel.[4]
2017. LLVMâ€™s Analysis and Transform Passes. http://llvm.org/docs/Passes.html.
(2017).
[5] 2017. Loopster. https://sites.google.com/site/looptermination. (2017).
[6]MohamedFaouziAtig,AhmedBouajjani,MichaelEmmi,andAkashLal.2012.
Detecting Fair Non-termination in Multithreaded Programs. In CAV. 210â€“226.
[7]AmirM.Ben-AmramandSamirGenaim.2014. RankingFunctionsforLinear-
Constraint Loops. J. ACM61, 4 (2014), 26:1â€“26:55.
[8]Josh Berdine, Byron Cook, Dino Distefano, and Peter W. Oâ€™Hearn. 2006. Au-tomatic Termination Proofs for Programs with Shape-shifting Heaps. In CAV.
386â€“400.
[9]AaronR.Bradley,ZoharManna,andHennyB.Sipma.2005. Linearrankingwith
reachability. In CAV. 491â€“504.
[10]AaronR.Bradley,ZoharManna,andHennyB.Sipma.2005. Thepolyranking
principle. In ICALP. 1349â€“1361.
[11]AaronR.Bradley,ZoharManna,andHennyB.Sipma.2005.TerminationAnalysis
of Integer Linear Loops. In CONCUR 2005 - Concurrency Theory . 488â€“502.
[12]Marc Brockschmidt, Byron Cook, and Carsten Fuhs. 2013. Better termination
proving through cooperation. In CAV. 413â€“429.
[13]Hong-YiChen,ByronCook,CarstenFuhs,KaustubhNimkar,andPeterOâ€™Hearn.
2014. Proving nontermination via safety. In TACAS. 156â€“171.
[14]Hong-Yi Chen, Daniel Kroening, Peter Schrammel, and Bjoern Wachter. 2015.
Synthesising Interprocedural Bit-Precise Termination Proofs. In ASE. 53â€“64.
[15]Alias Christophe, Darte Alain, Feautrier Paul, and Gonnord Laure. 2010. Multi-
dimensionalRankings,ProgramTermination,andComplexityBoundsofFlow-chart Programs. In SAS. 117â€“133.
[16]
Michael Codish, Igor Gonopolskiy, Amir M. Ben-Amram, Carsten Fuhs, and
JÃ¼rgen Giesl.2011. SAT-Based Termination Analysis UsingMonotonicity Con-
straints over the Integers. CoRR(2011).
[17]Byron Cook, Alexey Gotsman, Andreas Podelski, Andrey Rybalchenko, and
MosheY.Vardi.2007. ProvingThatProgramsEventuallyDoSomethingGood.
InPOPL. 265â€“276.
[18]Byron Cook, Eric Koskinen, and Moshe Vardi. 2011. Temporal property verifica-
tion as a program analysis task. In CAV. 333â€“348.
[19]ByronCook,DanielKroening,PhilippRÃ¼mmer,andChristophM.Wintersteiger.
2010. Ranking Function Synthesis for Bit-vector Relations. In TACAS. 236â€“250.
[20]Byron Cook, Andreas Podelski, and Andrey Rybalchenko. 2006. Termination
Proofs for Systems Code. In PLDI. 415â€“426.
[21]ByronCook,AndreasPodelski,andAndreyRybalchenko.2011. Provingprogram
termination (Review article). In Communications of the ACM . 88â€“98.
[22]ByronCook,AbigailSee,andFlorianZuleger.2013. Ramseyvs.lexicographic
termination proving. In TACAS. 47â€“61.
[23]CristinaDavid,DanielKroening,andMattLewis.2015. UnrestrictedTermination
and Non-termination Arguments for Bit-Vector Programs. In ESOP. 183â€“204.
[24]LeonardodeMouraandNikolajBjÃ¸rner.2008. Z3:AnEfficientSMTSolver.In
TACAS. 337â€“340.[25]Stephan Falke, Deepak Kapur, and Carsten Sinz. 2011. Termination analysis of C
programsusingcompilerintermediatelanguages . TechnicalReport.41â€“50pages.
[26]SumitGulwaniandFlorianZuleger.2010. TheReachability-BoundProblem. In
PLDI. 292â€“304.
[27]Ashutosh Gupta, Thomas A. Henzinger, Rupak Majumdar, Andrey Rybalchenko,
and Ru-Gang Xu. 2008. Proving Non-termination. In POPL. 147â€“158.
[28]William R. Harris, Akash Lal, Aditya V. Nori, and Sriram K. Rajamani. 2010.
Alternation for Termination. In SAS. 304â€“319.
[29]MatthiasHeizmann,Daniel Dietsch,MariusGreitschus,Jan Leike,BetimMusa,
ClausSchatzle,andAndreasPodelski.2016. UltimateAutomizerwithTwo-track
Proofs (Competition Contribution). In TACAS.
[30]C.A.R.Hoare.1969. AnAxiomaticBasisforComputerProgramming. Commun.
ACM(1969), 576â€“580.
[31]Eric Koskinen. 2012. Temporal verification of programs . Ph.D. Dissertation.
Universityof Cambridge.
[32]Daniel Kroening, Natasha Sharygina, Aliaksei Tsitovich, and Christoph M. Win-
tersteiger. 2010. Termination analysis with compositional transition invariants.
InCAV. 89â€“103.
[33]Daniel Larraz, Kaustubh Nimkar, Albert Oliveras, Enric RodrÃ­guez-Carbonell,and Albert Rubio. 2014. Proving Non-termination Using Max-SMT. In CAV.
779â€“796.
[34]Daniel Larraz, Albert Oliveras, Enric RodrÃ­guez-Carbonell, and Albert Rubio.
2013. Proving termination of imperative programsusing Max-SMT. In FMCAD.
218â€“225.
[35]Chris Lattner and Vikram Adve. 2004. LLVM: A compilation framework for
lifelong program analysis &transformation. In CGO. 75â€“88.
[36]ChinSoon Lee, Neil D. Jones, and Amir M. Ben-Amram. 2001. The Size-change
Principle for Program Termination. In POPL. 81â€“92.
[37]JanLeikeandMatthiasHeizmann.2014. RankingTemplatesforLinearLoops.
InTACAS. 172â€“186.
[38]Paul Lokuciejewski, Daniel Cordes, Heiko Falk, and Peter Marwedel. 2009. A
Fast and Precise Static Loop Analysis based on Abstract. In CGO. 136â€“146.
[39] Spezialetti Madalene and Gupta Rajiv. 1995. Loop Monotonic Statements. IEEE
Trans. Softw. Eng. 21, 6 (1995), 497â€“505.
[40]ColÃ³n Michael and Sipma Henny. 2001. Synthesis of Linear Ranking Functions.
InTACAS. 67â€“81.
[41]ColÃ³n Michael and Sipma Henny. 2002. Practical Methods for Proving Program
Termination. In CAV. 442â€“454.
[42]Karl J. Ottenstein and Linda M. Ottenstein. 1984. The Program Dependence
Graph in a Software Development Environment. In SDE. 177â€“184.
[43]AndreasPodelskiandAndreyRybalchenko.2004. Acompletemethodforthe
synthesis of linear ranking functions. In VMCAI. 239â€“251.
[44]Andreas Podelski and Andrey Rybalchenko. 2007. ARMC: the logical choice for
software model checking with abstraction refinement. In PADL. 245â€“259.
[45]AndreyRybalchenko.2010. ConstraintSolvingforProgramVerification:Theory
and Practice by Example. In CAV. 57â€“71.
[46]Helga Velroyen and Philipp RÃ¼mmer. 2008. Non-termination Checking for
Imperative Programs. In TAP. 154â€“170.
[47]Xiaofei Xie, Bihuan Chen, Yang Liu, Wei Le, and Xiaohong Li. 2016. Proteus:
ComputingDisjunctiveLoopSummaryviaPathDependencyAnalysis.In FSE.
61â€“72.
94