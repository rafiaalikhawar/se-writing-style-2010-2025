Automated Model Repair for Alloy
KaiyuanWang
University ofTexas at Austin, USA
kaiyuanw@utexas.eduAllison Sullivan∗
University ofTexas at Austin, USA
allisonksullivan@utexas.eduSarfrazKhurshid
University ofTexas at Austin, USA
khurshid@utexas.edu
ABSTRACT
Automated program repair is an active research area. However,
existing research focuses mostly on imperative code, e.g. in Java.
In this paper, we study the problem of repairing declarative mod-els in Alloy – a first order relational logic with transitive closure.
WeintroduceARepair,thefirsttechniqueforrepairingAlloymod-
els. ARepair follows the spirit of traditional automated programrepair techniques. Specifically, ARepair takes as input a faulty Al-
loy modeland atest suitethat contains somefailing test,and out-
putsarepairedmodelthatiscorrectwithrespecttothegiventests.
ARepair integrates ideas from mutation testing and program syn-
thesis to provide an effective solution for repairing Alloy models.
The experimental results show that ARepair can fix 28 out of 38
real-world faultymodelswe collected.
CCS CONCEPTS
•Softwareand itsengineering →Error handlingand recovery ;
KEYWORDS
Modelrepair, first-orderlogic, ARepair
ACM Reference Format:
Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid. 2018. Automated
Model Repair for Alloy. In Proceedings of the 2018 33rd ACM/IEEE Interna-
tional Conference on Automated Software Engineering (ASE ’18), September3–7, 2018, Montpellier, France. ACM, New York, NY, USA, 12pages.
https://doi.org/10.1145/3238147.3238162
1 INTRODUCTION
Automatic program repair techniques significantly reduce the hu-
maneffortrequiredtodiagnose,debug,andrepairfaultyprograms[ 2,
7,17,21,24,30,35,38,39,43,59,63,66,79].Thestandard generate-
and-validate approach [ 14,19,29,34,62,80,81,83,84]startswi th
afaultyprogramandatestsuitethatrevealsthedefect.Itexplores
candidate programs in the search space, and validates each can-
didate program against the given test suite until a program that
passes all tests is found. Some repair techniques infer specs of
theprogramandtranslatetherepairproblemintoconstraints,andthen use SAT/SMT solvers to synthesize patches that conform to
thespecs[ 33,44,55,64].
∗Nowat North CarolinaA&T State University.
Permission to make digital or hard copies of all or part of this work for personal or
classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributedfor profit or commercialadvantage and that copies bear this notice and the full cita-
tion on thefirstpage. Copyrightsfor components of thiswork owned byothers than
ACMmustbehonored.Abstractingwithcreditispermitted. Tocopyotherwise,orre-
publish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or afee. Requestpermissionsfrompermissions@acm.org.
ASE ’18,September 3–7,2018,Montpellier, France
© 2018 Associationfor Computing Machinery.
ACM ISBN978-1-4503-5937-5/18/09 ...$15.00
https://doi.org/10.1145/3238147.3238162Existingprogramrepairtechniquesmainlyfocusonimperative
languages like Java. Our focus in this paper is declarative models
w r i t t e ni nA l l o y[ 22] – a first-order relational logic with transi-
tive closure. The Alloy language and its back-end analyzer have
been explored within the software engineering community. Alloy
is used in various domains, including UML analysis [ 31,41,42],
security [ 40,52], networking [ 61], and feature modeling [ 20]. Ad-
ditionally, theAlloy analyzer has been extended to provide betterscenario finding experiences [ 6,28,47,49,54]. Alloy users write
models that describe the properties of the system of interest. The
Alloy analyzer translates Alloy models into Kodkod [73 ]f o r m u -
las and invokes off-the-shelf SAT solvers to search for solutions.
The analyzer performs scope-bounded analysis, which checks the
properties within a given scope,i . e .b o u n do nt h eu n i v e r s eo fd i s -
course.AUnit[ 69]definesthenotionoftestinginAlloyfollowing
thespirit of traditional testing frameworks, e.g. JUnit. Developers
writetestpredicatesandinvoke commandstoasserttheexistence
ornon-existence of solutions.
Inthispaper,wepresentARepair,anovelgenerate-and-validate
program repair technique for Alloy, which is able to handle Al-loy models with multiple faults. ARepair has three main compo-
nents: (1) a mutation-based fault localization technique [ 48,56],
AlloyFL [ 77] that locates faults at the AST node granularity; (2)
a generator that systematically generates Alloy expressions (withequivalencepruningrulesforrelationalalgebra[ 75]);and(3)asyn-
thesizerthatexplores the search space untilamodelwithallpass-
ing tests is found. ARepair starts by invoking AlloyFL to locate
faults. Each time AlloyFL is invoked, ARepair checks if the mostsuspiciousnodecanbefixedbymutationandappliesthechangeif
thatisthecase.Otherwise,foreachsuspiciousASTnodereturned,
ARepair creates holes fordescendant nodes in the suspiciousAST
andenumeratescandidatefragme nts(generatedbytheexpression
generator) of corresponding holes until some failing test passesandtheresultsofpassingtestsarepreserved.ARepairimplements
two strategies to explore the search space: all-combinations and
base-choice . The all-combinations strategy explores all combina-
tions of candidate fragments for all holes until some failing testpasses and no passing testfails. The base-choice strategy enumer-
atescandidatefragments foroneholeatatime, whilekeeping the
candidate fragments of the other holes constant. After enumerat-
ing all the fragments for one hole, the base-choice strategy fills
t h eh o l ew i t ht h ef r a g m e n tt h a tm a kes the most failing tests pass
and no passing test fails. Both strategies are inspired by textbook
input space criteria for test coverage [ 4]. ARepair avoids running
AUnit test predicates with expensive SAT solver calls by building
formula dependency graphs and leveraging Alloy’s built-in eval-
uator to evaluate a minimal number of affected formulas that de-termine a test’s satisfiability. A hierarchical cache further reduces
thesizesofinputstotheevaluator.ARepairrepeatedlyfixesfaults
untilalltestspassoritexhausts theboundedsearch space.
577
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
We evaluate ARepair using modelscollectedfrom thestandard
Alloy4.1 distributionand Amalgam [ 53].Wealso collectAlloyas-
signment solutions from graduate students. With the default set-
ting, ARepair is able to repair 28 out of 38 real faulty models .W e
make the following contributions:
•Alloy Model Repair. ARepair is the first repair technique for
Alloy, which uses both mutations and synthesis to repair faulty
models. The experimental results show that the combined ap-
proach works well and many faulty models require both muta-tionsandsynthesis foracompletefix.ARepairdoesnotrequire
isolated faults. It can fix models with multiple faults or faults
involving multiplelocations.
•OptimizationsforPracticalModelRepair. ARepairdoesnot
search forfaultpatternsand applyrepair templatestofixfaults.Instead, it tries to repair a faulty AST in a bottom-up fashion,so it is more likely to repair faults with unseen patterns. The
absence of repair templates results in an immense search space
andweimplementthefollowingoptimizationstomakethetech-nique tractable and reduce end-to-end time. (1) The expression
generator prunes equivalent expressions based on equivalence
pruningrules[ 75]and modulotestinputs[32 ].(2) The enumer-
ation based approach explores the search space without expen-sive constraint solving [ 3]. (3) The construction of dependency
graphsforconstraintformulase nables asmallnumberofevalu-
atorcallsduringtheenumeration basedapproach.(4)Thebase-choicesearch strategyreducest heexplorationspace.(5)Thehi-
erarchical caching reduces sizes of the inputstoevaluator calls.
•Evaluation. WeevaluateARepaironrealfaultsandshowthatit
isabletofix28outof38faultymodels.Wequalitativelycompare
patches generated by ARepair and human written patches, and
show thatthequalityofthegenerated patchesisgood.
•Open Source. We release 38 real-world Alloy models with an-
notated fault locations and human-written patches, and opensource ARepair so researchers can use them in the future. Therepois available at https://github.com/kaiyuanw/ARepair.
2 EXAMPLE
Thissectionpresentsareal-worldfaultyAlloymodeltointroduce
thebasicsofAlloyandAUnit.Then,wedescribehowAlloyFL[ 77]
and ARepair fixthe model.
Figure1ashows the “Farmer River Crossing” puzzlewhere the
goalistoallowafarmertotransportafox,chickenandgrainfromone river bank to the other. The farmer uses a boat and can only
carryoneitematatime.Ifleftunattended,thefoxeatsthechicken
and the chicken eats the grain. The model contains a fault whichprevents the “eating” from happening while the farmer is away.
Instead, the faulty model enforces the “eating” to happen when
thefarmer comesback.
Lines 2-4declarethebasic typesintheproblem:anotionofob-
ject(line 2;
sigdenotesa set andintroducesa type),fourconcrete
objects(line3),andasetofstates(line4)thatmodeltheobjectsinboththe
nearandfarbanks afterevery farmer’s rivercrossing ac-
tion (line 4). The abstract keyword enforces that an object is one
of its concrete subtypes: Farmer,Fox,ChickenandGrain.T h eone
keyword constrains each concrete object type to contain a single,
distinctobjectatom.The eatsfielddeclaresthateachobjectcaneatasetofobjectsandthefactonline5restrictsthatthefoxcaneatthe
chicken and the chicken can eat the grain. The initialState fact
onlines6-7constrainsthatinitiallyeverything isonthenearbank
and nothing is on the far bank. The crossRiver predicate on lines
8-13definestherivercrossingaction.Ittakesfourparameters:thesetofobjectsonthebankwherethefarmerstartsat(pre-state:
from
andpost-state: from’)andthesetofobjectsonthebankthefarmer
willcrossto(pre-state: toandpost-state: to’).Thepredicatestates
that either the farmer takes nothing or the farmer takes one itemtotheothersideoftheriver.The
stateTransition factonlines14-
19 states that for every two consecutive states, if the farmer is on
thenearbankinthepre-state,thenhewouldcrosstherivertothefar bankin thepost-state,and vice versa. The
solvePuzzle online
20 restricts that everything should be on the far bank of the riverinthelaststate.
Thefaultis in the
crossRiver predicate (highlighted in orange).
Thepredicateenforceseatingtohappenonlyafterthefarmercomes
back and not immediately after the farmer leaves the bank. Thismeans if the farmer takes the grain from the near bank to the far
bank,thefoxwillnoteatthechicken. Butwhen thefarmercomes
backtothenearbank,thefoxeatsthechicken.Thismodelingerror
was in Alloy release 4.1and wasfixedin release 4.2.
An AUnit test [ 69] that reveals the fault is shown in Figure 1b.
Predicate
test1encodesthevaluationsofeach signature typeand
fieldrelationinthefaultyfarmermodel.Theinvocationof crossRiver
predicateonline18statesthateverythingisononebankandnoth-ingisontheotherbankinthepre-state.Inthepost-state(afterthefarmer crosses the river with the fox), only the chicken is left onthe one bank (because the chicken eats the grain) and both the
farmerandthefox areontheotherbank. Thecommandin line19
runsthetestwithatmost4atomsforeachsigtypeandexpectstheexistenceofasolution.However,thetestpredicateisunsatisfiable
becauseofthemodelingerror,resulting inatestfailure.
ARepair invokes AlloyFL tolocatefaultsat the AST nodegran-
ularity. The most suspicious node AlloyFL returns is shown in
Figure2.ARepaircreates holes toreplace eachlevel ofAST nodes
inabottom-upfashion.Forexample,itfirstcreatesholesfor
toand
eats(highlighted in red). Then, ARepair generates a set of candi-
dateexpressions foreachholeusing allsignatures/fields/variables
inscope,e.g. Farmer,fromanditem,etc.Next,ARepairenumerates
thecandidate expressions for each holeand runs all affected tests
to see if any test result changes from failing to passing. ARepair
keeps the candidate values that make some failing tests pass andpreservestheresultsofpassingtests.Inthiscase,ARepairreplaces
towithnoneand now one failing test passes (and no passing test
fails).Next, ARepairrerunsAlloyFL and findsthatthemostsuspi-ciousnodeisstillthesame.Inthisiteration,ARepaircreatesholes
for
toand the relational join operator " ·" (highlighted in yellow).
ARepair keeps synthesizing expressions/formulas under each sus-
picious node to make failing tests pass. If ARepair cannot makeany failing test pass for the suspicious node, then it repeats the
same process for the next suspicious node. Note that AlloyFL is
a mutation-based technique and it can also repair the model with
mutations.EachtimeAlloyFLisinvoked,wecheckifthereisamu-
tation over the most suspicious node AlloyFL reports that makes
some failing tests pass and no passing test fails. If such mutation
578
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. Automated Model Repair for Alloy ASE ’18, September 3–7, 2018, Montpellier, France
1.openutil/ordering[State] asord
2.abstract sig Object { eats: setObject }
3.one sig Farmer, Fox, Chicken, Grain extends Object {}
4.sigState { near,far: setObject }
5.facteating { eats = Fox->Chicken + Chicken->Grain }
6.factinitialState {
7. lets0 = ord/first | s0.near = Object && nos0.far }
8.predcrossRiver[from,from',to,to': setObject] {
9. (from' = from - Farmer
10. && to' = to - to.eats + Farmer ) ||
11. (some item: from - Farmer {
12. from' = from - Farmer - item
13. && to' = to - to.eats + Farmer + item })}
14. factstateTransition {
15. alls: State, s': ord/next[s] {
16. Farmer ins.near =>
17. crossRiver[s.near, s'.near, s.far, s'.far]
18. elsecrossRiver[s.far, s'.far, s.near, s'.near]
19. }}
20. predsolvePuzzle { ord/last.far = Object }
(a)Faultyfarmerriver crossing model.1.predtest1 {
2. some disj F0: Farmer | some disj X0: Fox |
3. some disj C0: Chicken | some disj G0: Grain |
4. some disj F0, X0, C0, G0: Object |
5. some disj S0, S1, S2, S3: State {
6. Farmer = F0
7. Fox = X08. Chicken = C09. Grain = G0
10. Object = F0 + X0 + C0 + G0
11. eats = X0->C0 + C0->G0
12. State = S0 + S1 + S2 + S313. near = S0->F0 + S0->X0 + S0->C0 + S0->G014. + S1->X0 + S2->F0 + S2->X0 + S3->X0
15. far = S1->F0 + S1->G0 + S2->G0 + S3->F0 + S3->G0
16. ord/first = S0
17. ord/next = S0->S1 + S1->S2 + S2->S318. crossRiver[F0+X0+C0+G0, C0, none, F0+X0] } }
19. runtest1 for 4expect 1
20. // More tests ...
(b) Afailing test of the farmer river crossing model [ 77].
Figure1: FaultyFarmerExampleandTests.
&&
==
from' − to' +
− item + item
from Farmer − Farmer
to·
to eats Level7Level6Level1
Figure 2: FirstSuspiciousNodefor FaultyFarmerExample.
(A)Ahuman-written patch.
1. predcrossRiver[from,from',to,to': setObject] {
2.- (from' = from - Farmer
3.+ (from' = from - Farmer - from'.eats
4.- && to' = to - to.eats + Farmer ) ||
5.+ && to' = to + Farmer ) ||
6. (some item: from - Farmer {
7.- from' = from - Farmer - item
8.+ from' = from - Farmer - item - from'.eats
9.- && to' = to - to.eats + Farmer + item })}
10.+ && to' = to + Farmer + item })}
(B)A patch generated byARepair.
1. predcrossRiver[from,from',to,to': setObject] {
2.- (from' = from - Farmer
3.- && to' = to - to.eats + Farmer ) ||
4.- (some item: from - Farmer {
5.+ (some item: from + Farmer {
6.- from' = from - Farmer - item
7.+ from' = from - (Farmer + from'.eats) - item
8.- && to' = to - to.eats + Farmer + item })}
9.+ && to' = to + Farmer + item })}
Figure3:Patchesfor thefaultyfarmermodel.
exists, then we mutate the model and start the next iteration. Fi-
nally, if ARepair can fix thefaulty model,i.e. alltests pass, then itpost-processes the fixed model to remove redundant code, e.g. re-
place"
to-none.eats "w i t h"to", and returnsthemodeltotheuser.
Figure3showsthehumanwrittenpatch(A)and thefirstpatch
generatedbyARepair(B).Wecanseethatthehumanwrittenpatchfixes the “eating” action both when the farmer crosses the riverwith(lines7-10)orwithout(lines2-5)anitem.ThepatchARepair
generates deletes the formula that models the farmer’s crossing-
riverwithoutanitem(lines2-3),andfixesthe“eating”actionwhen
the farmer crosses the river with an item (lines 6-9). The interest-
ing part is that the patch also changes the domain of a variable
declaration(lines4-5),whicha ctuallymergesbothcaseswhenthe
farmer crosses the river with/without an item. The new domain
(line 5) allowsthe
itemto bethe farmer himself and it modelsthe
correctsemantics correspondingtothedeletedformulaonlines2-
3.In thiscase, we validatethe equivalenceofgenerated patchand
thehuman-written patchwitha scope-bounded analysis using the
Alloy analyzer and find that the generated patch is semantically
equivalenttothehumanwrittenpatch.
3 BACKGROUND: FAULT LOCALIZATION
In this section, we describe AlloyFL [ 77], which is the fault local-
izationtechnique usedby ARepair.
AlloyFL follows the traditional mutation-based fault localiza-
tiontechniques [ 48,56] and implements avariety of mutationop-
erators as shown in Figure 4.MORmutates signature multiplicity,
e.g. "lone sig"t o"one sig".QORmutates quantifiers, e.g. " all"t o
"some".UOR,BORandLORdefine operatorreplacement for unary,
binary and formulalist operators,respectively. For example, UOR
mutates " a.∗b"t o"a.ˆb";BORmutates " a=>b"t o"a<=>b"; andLOR
mutates" a&&b"t o"a||b".UOIinserts an unary operatorbefore ex-
pressions, e.g. " a.b"t o"a.∼b".UODdeletes an unary operator,e.g.
"a.∗∼b"to"a.∗b".LODdeletesanoperandofalogicaloperator,e.g.
"a||b"to"b".PBDdeletes the bodyof anAlloyparagraph. BOEex-
changes operands fora binary operator,e.g. " a=>b"t o"b=>a".IEOE
exchangestheoperandsof imply-else operation,e.g." a= >be l s e
c"t o"a => c else b ". These operators are well defined such that
AlloyFLisabletoaccuratelylocatefaultsandevenfixthefaultsin
some cases. For example, to fix the faulty farmer example in Fig-
ure1a,AlloyFL fixespartsofthefaultsbyapplying BOR(Figure3
(B)lines4-5)and LOD(Figure3(B)lines 2-3).
The input of AlloyFL is a faulty Alloy model and a set of Alloy
commandswiththe expectkeyword.Thesecommandscaninvoke
Alloypredicates,functionorassertions. " expect 1"meansthatthe
correspondingcommandisexpectedtobesatisfiablewhile" expect
579
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
MutationDescription
Operator
MOR Multiplicity Operator Replacement
QOR Quantifier Operator Replacement
UOR Unary Operator Replacement
BOR Binary Operator Replacement
LOR Formula ListOperator Replacement
UOI Unary Operator Insertion
UOD Unary Operator Deletion
LOD Logical OperandDeletion
PBD Paragraph Body Deletion
BOE Binary Operand Exchange
IEOE Imply-Else OperandExchange
Figure4: MutationOperators
0"means thatthecommand isexpectedtobeunsatisfiable. Inthis
paper,eachcommandinvokes anAUnit[ 69]testpredicateandwe
sayanAUnittestfailsifthecorrespondingcommandissatisfiable
butisexpectedtobeunsatisfiable,orviceversa. TheoutputofAl-
loyFLisalistofASTnodesindescendingorderoftheirsuspicious-ness given a formula.In thispaper,we use theOchiai [ 1]f o r m u l a
failed (e)
√
totalfailed×(failed (e)+passed (e)),w h e r efailed(e) andpassed(e)
are the number of tests that failed and passed (with respect tothe
original faulty model) that kill the mutant e,a n dtotalfailed is the
total number of failed tests for the faulty model. AlloyFL system-
atically mutates the faulty Alloy model using mutation operators
in Figure 4and runs the test suite against each mutant. A suspi-
ciousness score computed from th e Ochiai formula is assigned to
eachmutatedASTnode.Incasemorethanonemutationoperatoris applicable to an AST node, the maximum suspiciousness score
computed for the node is used. Finally, AlloyFL ranks all nodesin the descending order of suspiciousness and returns the ranked
list. We modify AlloyFL to also return the mutation operator cor-
responding to themost suspiciousAST nodeso later ARepair candetermine if that mutationshouldbeappliedas a potentialfix.
4 TECHNIQUE
In this section, we first describe how we create holes (Section 4.1)
andhowwegenerateexpressionstofillinholes(Section 4.2).Next,
we describe the search strategies (Section 4.3). Then, we describe
how we run tests withoutinvoking a SAT solver (Section 4.4)a n d
thehierarchicalcachingweusetoimproveperformance(Section 4.5).
Finally, we describe the enumeration-based repair approach as a
whole(Section 4.6).
4.1 CreateHoles
ForeachsuspiciousASTnodereturnedbyAlloyFL,wecreateholesateachlevelofthecorrespondingASTinabottom-upfashion.For
example, themostsuspiciousnodeinthefaultyfarmermodel(Fig-
ure2) has 7 levels. We first create holes at level 7 (shown in red)
and synthesize new expressions at that level without modifying
nodesofotherlevels.Werepeatthisprocessfromlevel7tolevel1
(root level) until some failing test passes and no passing test fails.
TheintuitionisthatAlloyFLisdesigned tomutateupper-levelop-
erator nodes and if the fault cannot be fixed by AlloyFL, then theissueislikelyatthelowerlevelsoftheAST.Thisapproachalsopri-
oritizes patches with smaller perturbations to the original model,
whichisconsistentwiththeinsight:patchesthatintroducesmaller
perturbations to the original program are more likely to be cor-rect [10,33].
Creating a single hole for each node in a given level may not
result in valid models. For example, replacing the
&&node with a
holeatlevel1inFigure 2doesnotmakethenewprogramcompile.
Consequently, the schema to create holes for different AST nodes
may vary. ARepair introduces different types of holes, i.e. quanti-
fier holes (denoted by qh), logical operatorholes (denoted by loh),
comparisonoperatorholes(denotedby coh),implicationholes(de-
noted by ih), cardinality holes (denoted by ch), boolean holes (de-
noted by bh) and expression holes (denoted by eh). The value of
qhcanbeoneof" all", "no", "some", "lone"or"one". The value of loh
can be either " &&"o r"||". The value of cohcan be one of " =", "in",
"!="o r"!in". The value of ihcan be either " =>"o r"<=>". The value
ofchcanbeoneof" no", "lone", "one"or"some". The value of bhcan
beeither empty ϵor"!". The value of ehcan be any expression.
Figure5showsthemeaningofdifferenttypesofASTnodesand
thecorrespondingschemastocreateholes.Eachschemaisdenoted
by"¯h(x): =H", where¯h(x)meanstheholescreatedfromASTnode
typexandHshows the way to compute holes. For example, the
most suspicious node returned by AlloyFL is a conjunction node
("&&"a ss h o w ni nF i g u r e 2). To create holes for the root node, we
can apply the schema for the conjunction node, which states thattheholesweshouldcreateincludealogicaloperatorhole loh,holes
createdfromtheleftchildandholescreatedfromtherightchild.Inthis case, boththe left and right children of the conjunction node
aresetequalitynodes("
="),sowerecursivelyapplyschemasinFig-
ure5until no more holes are created. In the end, we wouldcreate
4expressionholes,2comparisonoperatorholesandalogicaloper-
atorhole. This step guarantees that if we fill holes with candidate
operators/expressions, then the resulting expression/formula willalways compile.
4.2 GeneratingExpressions
Thespaceofcandidatefragmentsforoperatorholes,e.g.quantifier
holes and cardinality holes, are fixed, but the space of candidate
fragmentsforexpression holesdependsontheexpression genera-
tor.Togeneratevalidcandidatefragmentsforexpressionholes,we
need to find all atomic expressions in the model that can be used.
ARepair has a static analyzer which finds all atomic expressions,
i.e. sigs, fields, predicate/function parameters, quantifier variablesand let variables, in scope of each expression hole. The holes thatshare the same set of atomic expressions in scope have the same
set of generated candidate fragments.
ARepairimplementsanexpressiongeneratorthatgenerates ex-
pressionsfollowingthegrammarsinFigure 6.Thegeneratorimple-
ments two pruning strategies. First, the generator prunes seman-
ticallyequivalent expressions using equivalence pruning rulesforrelationalalgebradescribedinRexGen[ 75].Second,thegenerator
implements a modulo test checker that prunes equivalent expres-sionswithrespecttothegiventests.Theequivalencepruningrulesandthemodulotestcheckersignificantlyreducethenumberofex-
pressions toconsider and maketherepair problem tractable.
580
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. Automated Model Repair for Alloy ASE ’18, September 3–7, 2018, Montpellier, France
Meaning Schema Meaning Schema
Cartesianproduct ¯h(ϕ×ψ): =e h Relational join ¯h(ϕ⊿/triangleleftψ): =e h
Union ¯h(ϕ∪ψ): =e h Intersection ¯h(ϕ∩ψ): =e h
Set difference ¯h(ϕ\ψ): =e h Overridingunion ¯h(ϕ++ψ):=eh
Domainrestriction ¯h(ϕ<:ψ): =e h Range restriction ¯h(ϕ:>ψ): =e h
Transitiveclosure ¯h(ˆϕ): =e h Reflexivetransitiveclosure ¯h(∗ϕ):=eh
Inverserelational join ¯h(ϕ[ψ]):=eh Relational transpose ¯h(~ϕ): =e h
Cardinality ¯h(#ϕ): =e h Set comprehension ¯h({¯t:ϕ|α(¯t)}): =e h
Identity relation (binary) ¯h(iden) :=eh Universe(unary) ¯h(univ) :=eh
Conjunction ¯h(α∧β): =¯h(α)l o h¯h(β) Disjunction ¯h(α∨β): =¯h(α)l o h¯h(β)
Implication ¯h(α⇒β): =¯h(α)i h¯h(β) Bi-implication ¯h(α⇔β): =¯h(α)i h¯h(β)
If-then-else ¯h(α?β:γ): =¯h(α)¯h(β)¯h(γ) Negation ¯h(¬α): =b h¯h(α)
Relational equality ¯h(ϕ=ψ): =¯h(ϕ)co h¯h(ψ) Relationalcontainment ¯h(ϕi nψ): =¯h(ϕ)co h¯h(ψ)
Universalquantification ¯h(∀¯t:ϕ|α(¯t)): =qh¯h(ϕ)¯h(α(¯t)) Existentialquantification ¯h(∃¯t:ϕ|α(¯t)): =qh¯h(ϕ)¯h(α(¯t))
|ϕ|=1 ¯h(oneϕ): =ch¯h(ϕ) |ϕ|≤1 ¯h(loneϕ): =ch¯h(ϕ)
|ϕ|≥1 ¯h(someϕ): =ch¯h(ϕ) |ϕ|=0 ¯h(noϕ): =ch¯h(ϕ)
Figure 5: Hole creation schemas for Alloy Surface Syntax. ¯h(x)computes the holes for syntax x.α,βandγdenote formulas
which evaluatetotrueor false. ϕandψdenoteexpressions whichevaluateto relations. ¯t:ϕdenotetuplemembership ¯t∈ϕ.
expression e:=uope|ebo pe|atom e|const
unary op uop:=∗|ˆ|˜
binaryop bop:=+|&|−|·
atomic expr atom e:=siдe|field e|param e|vare
constant const:=none|iden|univ|Int|0|1
Figure6: Expression generationsyntax.
Next, we describe the modulo test pruning technique with an
example. Consider the modelshown below:
sigNode { link: loneNode } predp{some n: Node | no??}
predt1 { some disj N0: Node | Node=N0 && link=N0->N0 }
predt2 { some disj N0,N1: Node {
Node=N0+N1 && link=N0->N1+N1->N0 && p[] } }
The modelhas asignature Node,ab i n a ryfi e l d linkand a quan-
tifiervariable n.I mpli ci tly ," n"i softy pe Nodeandhas acardinality
of 1. The model contains two AUnit tests t1andt2.S u p p o s ew e
wanttogenerate expressions oftype Nodeinthebody(denotedby
??) oftheexistential quantification,andwe can use" n", "link"a n d
"Node"astheatomicexpressions.Thefollowingtableshowstheval-
uationsoffoursyntacticallydifferentexpressions, i.e." n", "n.link",
"link.(Node-n) "a n d"(link.Node)&n ", with respect to t1andt2.
test n
 n n.link link.(Node-n) (link.Node) &n
t1 N0
 {N0} {N0} ∅ {N0}
t2N0
{N0} {N1} {N0} {N0}
N1
{N1} {N0} {N1} {N1}
For test t1,ncan only be N0andlinkisN0->N0.I ti se a s yt o
see that" n", "n.link"a n d"(link.Node)&n " evaluate to the same set
{N0} and thus are equivalent with respect to t1.F o rt e s t t2,ncan
beN0orN1,a n dlinkis {N0->N1,N1->N0}. "n", "link.(Node-n) "a n d
"(link.Node)&n " are equivalent with respect to t2bothwhen n=N0
andn=N1.S o"n"a n d"(link.Node)&n " are equivalent with respect
to the test suite and the modulo test checker can prune either " n"
or "(link.Node)&n ". In practice, we keep expressions with smaller
sizes,so" (link.Node)&n "willbepruned.Iftheexpressiondoesnot
contain any free variable, its valuation does not change based on
the valuations of free variables. If the expression contains more
thanonefreevariable,thenweneedtoenumerateallcombinations
ofpossiblevaluations ofthefree variables toget thevaluations ofthe expression. If the free variable’s cardinality is greater than 1,then its valuation can be any subset ofits declaring type. Two ex-
pressionsareequivalentwithrespecttoatestiftheirvaluationsare
thesameacrossallcombinationsofpossiblevaluationsoffreevari-
ables in the scope. The expression generator prunes expressions
that are equivalent to any existing expression with respect to the
entire testsuite.
Inthispaper,thesizeofanexpressionisdefinedasthenumber
of descendant nodes in the AST representation of the expression.
Theexpressiongeneratorisabletogenerateexpressionsofagiven
typeand size.
4.3 Search Strategies
Given a level of nodes in a suspicious node and the correspond-ing holes created, ARepair implements two search strategies: all
combinations andbase choice [4].
All combinations . Under this search strategy, ARepair tries all
combinations of candidate fragments for all holes until it finds
some failing test passed and no passing test failed. This strategyis typically impractical as the number of holes and the number
of candidate fragments for each hole grow. For example, with 4
holes and 100candidate fragments foreach hole, the search spaceis 10
8. In our implementation, we limit the maximum number of
combinations to explore (per level of holes) for this search strat-
egy. Typically, the limit we set is still large, so we stop exploring
more combinations the first time a combination of candidate frag-
mentsmakessomefailingtestpassandnopassingtestfails.Ifsuch
a combination is found, we fill the holes with the corresponding
fragmentsand savethechanges beforestartingthenext iteration.
Intuitively, we want to first explore combinations of candidate
fragments of expression holes with smaller expression sizes, be-cause we assume small-sized expressions are more natural to de-
velopers,e.g."
n"vs"(Node-∗link.n)". Figure7showshowwepriori-
tizeexploringcombinationsofcandidateexpressionswithsmaller
sizes. Suppose we have nholes (hole1toholen)a n dholeihasSi
number of candidate fragments. Then we can partition the candi-datefragments of hole
iintokiparts(Pi
1toPi
ki)ofequalsize.Next,
we create size- ntuplesU={(x1,x2,...,xn)|n/logicalandtext
i=1xi∈[1,ki]}and
581
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
hole1P1
1P1
2...P1
k1S1
hole2P2
1P2
2...P2
k2S2
...
hole nPn
1Pn
2...Pn
knSn
Figure7: All combinations partitions.
sort the tuples first byn/summationtext
i=1xiand then by|max
∀i∈[1,n]xi−min
∀i∈[1,n]xi|
togetsarankedlistoftuples L.Forexample,if n=2,k1=2,k2=3,
thentherankedtuplelist L=[(1,1),(1,2),(2,1),(2,2),(1,3),(2,3)].
Finally,weiterateeachtuple (x1,...,xn)inLandexploreallcom-
binations of candidate fragments C={(f1,...,fn)|n/logicalandtext
i=1fi∈Pixi}.
Since expressions are generated in a bottom-up fashion, expres-
sions with smaller sizes are generated first, which means expres-
sion sizes in Px
iare smaller than expression sizes in Px
jifi<j.
Therefore, the exploration strategy guarantees that combinations
of smallerexpressions areexplored first.Base Choice .Under thissearchstrategy,ARepairholdscandidate
fragments of all holes constant except one hole (base choice). Itenumerates candidate fragments of hole
iwith the candidate frag-
ments of the rest holes unchanged. For each holei,A R e p a i re x -
plores all candidate fragments and picks the one ( fi)t h a tm a k e s
themaximumnumberoffailingtestspassandnopassingtestfails.
Then,ARepairenumeratescandidatefragmentsof holei+1withthe
fragment of holeiset tofi. ARepair uses this exploration strategy
fromhole1toholenandsavesthefinalchanges asthepotentialfix.
For example, with 4 holes and 100 candidate fragments for each
hole, thesearch spaceis400.In practice,thenumber ofgenerated
candidatefragmentsforanexpressionholecanbelarge,soweset
alimit onthenumber ofcandidatefragments toexploreperhole.
4.4 Running Tests
ARepairinvokestestsintheexpressiongenerationphase(toprune
expressions), the fault localization phase (to locate faults) and the
repairphase(tovalidatecandidatepatches).Sincethesearchspaceis large and each repair problemcontains many tests, invoking all
tests at the repair phase takes a majority of the time. Moreover,
invoking eachtestpredicatewithaSATsolverisexpensive. Wein-troduceatechniquethatdeterminestestsatisfiabilityusingAlloy’s
built-in evaluator (without sat solving) and builds a dependency
graphfor eachtesttoreducethenumber ofevaluator calls.
For a given faulty Alloy model, ARepair normalizes the signa-
turemultiplicityconstraints, thefield multiplicityconstraintsandthesignaturefacts,andcreatesaformulaforeachconstraint.Inthefaultyfarmerexample(Figure 1a),the
Objectsignature isdeclared
tobeanarbitrarysetofatoms,soitdoesnotneedtobenormalizedand we create an empty formula (denoted by
Object mult)w h i c h
evaluates to true bydefault. Similarly, the field eatsis declared to
relate an object to a set of objects, so we simply create an emptyformula (denoted by
eats mult). "one sig Farmer "i sd e c l a r e dt otest1Object mult
Farmer mult
Foxmult
Chicken mult
Grain multState multeats multnear mult
farmulteating
initialStatestateTransition
crossRiver
Figure8: Dependencygraph for test1in Figure 1b.
be a singleton set so we normalize it as " sig Farmer "( r e m o v es i g -
nature multiplicity constraint) and create a formula " one Farmer "
(denotedby Farmer mult).Thus,ARepaircreatesaformulaforeach
signature and field.Since the farmer modeldoesnot have any sig-nature facts, we do not need to create any formula for signature
facts.Foreachfactparagraph,ARepaircreatesaformula(denoted
bythe factname) thatis identical tothe factbody.
ForeachAUnittest,wecreatea dependencygraphthatencodes
the formulas the test depends on. For example, Figure 8shows
the dependency graph for
test1in Figure 1b.test1depends on
all signature/field multiplicity constraints and all fact constraints,becausethoseconstraintsareenforcedbytheAlloyanalyzerwhen
we invoke the test. Since both
test1andstateTransition directly
invoke the crossRiver predicate, they both depend on crossRiver .
Once we build the dependency graph for each AUnit test, it is
easy to compute a test’s satisfiability from the formulas the testdepends on. Initially, ARepair evaluates each formula the test de-pends on and stores the satisfiability of each formula. When ARe-
pair enumerates candidate fragments for holes, it only evaluates
the affected formulas to determine the satisfiability of the test. Inthe faulty farmer example, when A Repair enumerates candidate
fragmentsforholesunderthemostsuspiciousASTnode(Figure 2),
theonlyaffectedpredicateis
crossRiver andtheaffectedformulas
arestateTransition andtest1. To determine the satisfiability of
test1,w eo n l yn e e dt oe v a l u a t et h eb o d yo f stateTransition and
thebodyof test1.Moreover,ifanyunaffectedformulaisunsatisfi-
able,thenweknowthetestisunsatisfiableeven withoutinvoking
theevaluator.Inpractice,thetechniqueimprovestheperformance
ofARepairbecauseitdoesnotinvolve any expensive SATsolvingandisabletodetermine thetestsatisfiabilitywithaminimalnum-
berofevaluatorcalls.
4.5 Hierarchical Caching
The evaluator-based approach to determine the test satisfiability
can be further improved by our hierarchical caching algorithm.
The idea is that we can reuse the previously evaluated result (i.e.
valuation) of a formula if its subformulasevaluate tothe same set
ofvaluesassomesubformulasweevaluatedbefore.Weexplainhi-
erarchical caching through thefarmer example.Supposewe want
to determine the satisfiability of test1(Figure1b)b ye v a l u a t i n g
the fact formula stateTransition , and the created holes that cor-
respond to nodes at level 7 of the most suspicious AST node, i.e.
"to"a n d"eats"i nF i g u r e 2highlighted in red. Also assume that
hole¯h(to)is first replaced by fragment " none"a n dh o l e ¯h(eats)
is unchanged. We create a hierarchical cache for test1as follows.
First,weinvoke theevaluator forthefragments ofbothholesandfind that "
none"e v a l u a t e st o ∅and "eats"e v a l u a t e st o{ X 0→C0,
582
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. Automated Model Repair for Alloy ASE ’18, September 3–7, 2018, Montpellier, France
Algorithm 1: ARepair algorithm.
Input:FaultyAlloymodel M,t e s ts u i t e T.
Output: Fullyfixed model or partially fixed model.
1canFix=True
2whilecanFixdo
3res=runTests( M)
4ifallTestsPassed(res) then return M// Full fix.
5L= locateFaults( M,res)
6ifisEmpty(L) then return M// Partial fix.
7canFix=False
8ifisFixed(M, L[0]) then
9 M= applyChange( M,L[0])
10 canFix=True
11else
12 foreachn∈Ldo
13 patch=synthesize( M,n)
14 ifisFixed(M, patch) then
15 M= applyChange( M,patch)
16 canFix=True
17 break
18returnM// Partial fix.
C0→G0}.Sowecreatemappings<"none",[∅ ]>for¯h(to)and<"eats",
[{X0→C0,C0→G0}]>for ¯h(eats).Sincethejoinoperator" ·"inlevel
6isthelowestcommonancestorofbothholesinlevel7,amapping
<"∅.{X0→C0,C0→G0}",[ ∅]>iscreatedforthejoinoperator.Note
that the key of the join operator is its string representation with
alldescendantholesreplacedbytheirvaluationsunder test1.The
value of the mapping is obtained by evaluating the string repre-
sentationofthejoinoperator,i.e." none.eats ", which is ∅.W ethen
create a mapping for the body of the declaring crossRiver pred-
icate. But because the body has parameters (" from", "from’", "to",
"to’"), weneedtoassignpossiblevaluestoallparametersandcre-
ateamappingforthebody<" A1A2...An",[{B1},{B2},...,{Bn}]>,where
Aimeans the string representation of the body (with the join op-
erator "·" replaced with its actual valuation) given ith possible as-
signment of parameters, and Biis the corresponding boolean re-
sult of the body formula in this case. We finally maps the cached
valueof crossRiver ,i.e.[{B1},{B2},...,{Bn}],tothesatisfiabilityofthe
stateTransition fact.
If the next fragment ofhole ¯h(to)is "item-Object "w h i c he v a l u -
ates to ∅(¯h(eats)is unchanged), then weimmediately know that
stateTransition evaluates to the same result as when hole ¯h(to)
is "none". Because the new keys we computedfor other nodes, e.g.
thejoinoperatorinlevel6,arealreadyinthecache.Therefore,weonly invoke the evaluator once to evaluate "
item-Object "i n s t e a d
ofevaluatingthebig stateTransition bodytodetermineitssatisfi-
ability. In general, the hierarchical cache reduces the input size ofevaluator calls butincrease the number of evaluator calls. In prac-
tice, we observe speed-ups for a majority of repairing problemsand few repair problems suffer from aslow-down.
4.6 Repair Algorithm
Algorithm 1showsthe algorithmofARepair.The algorithmtakes
asinputafaultyAlloymodel Mand a testsuite Tthatreveals thefault. The output is either a fully fixed model if all tests pass or a
partially fixed model otherwise. In the worst scenario, ARepair is
not able to fix any fault, in which case the partially fixed modelis the original faultymodel. Initially, we set canFixtotrue(line 1)
and enter the loop (line 2). For each iteration in the loop, we firstrunalltests against M(line 3). If all tests pass, Mis returned (line
4). Otherwise, we run AlloyFL to return a ranked list ( L)o fs u s p i -
cious AST nodes (line 5). If Lis empty, then the algorithm cannot
fixthefaultymodelanditreturnsthelateststateof M(line6).Oth-
erwise, we set canFixtofalse(line 7) and tryto fix the faults.The
algorithm checks if the mostsuspicious AST node ( L[0])h a sapo-
tential fix (line 8). The isFixedcheck determines if we want to use
the mutation or the synthesizer to fix the model. In general, the
isFixedmethod returns true if the mutation makes Xfailing tests
pass and Ypassing tests fail, where X>0a n dY=0. In prac-
tice,XandYcan be arbitrary numbers as long as X>Yholds,
becausewewanttomakesurethealgorithmterminates. Sinceini-
tially we have a finite number of failing tests and X>Ymakes
sure that fewer tests are failing at each iteration. The total num-
ber of iterations is bounded by the number of initial failing tests.
IfisFixed(line 8) returns true, then we apply the mutation to M
(line 9) and set canFixtotrue(line 10). Otherwise, we iterate over
the ranked suspicious nodes (line 12) and try to fix the model us-ing the synthesizer. For each suspicious node in L,w ei n v o k et h e
synthesizer tocreate holes,gener ate candidatefragments, explore
thesearch spaces andfind apotential patch(line 13).Then, theal-gorithm checks if the patch is a potential fix (line 14). The isFixed
methodinline14issimilartothemethodinline8.Ifthepatchisafix,then we apply the patch tothe model(line 15)with canFixset
totrueand exit the inner loop (line 12-17). Otherwise, we invoke
thesynthesizeronthenextsuspiciousnodein L.Ifthesynthesizer
cannotfindafixafterexploringallsuspiciousnodes,thealgorithm
exitstheouterloop(line2)and returnsthelateststateof M.
I
f the resulting model passes all tests, ARepair simplifies the
model to make it look more natural to the developer. For exam-ple,ARepairreplaces"
to-none.eats "with"to"because" none.eats "
alwaysevaluatestoan emptyset.
5 EVALUATION
WeevaluateARepairon38realfaultscollectedfromAlloyrelease
4.1, Amalgam [ 53] and Alloy homework solutions from graduate
students. These faulty models contain various types of faults, i.e.
overconstraints,underconstraintsandamixtureofboth.Wedefine
the number of faults as the number of incorrectly modeled Alloy
paragraphs, e.g. signatures, predicates, functions and facts.
W ea ddr e s sth ef ollo wi n gr e s e a r c hque s ti on si nth i ss ec ti on :
•RQ1.What is the repair efficacy ofARepair?
•RQ2.How does the quality of ARepair generated patches com-
pared tohuman-written patches?
•RQ3.Why is ARepair unabletofixsomemodels?
5.1 Experiment Setting
Unlikeexistingdatasetsthatisolatefaultsfortherepairtechniques,e.g. Defects4J [ 25], we use the exact human-written faulty Alloy
models as an input to ARepair. We use the Ochiai [ 1]f o r m u l a
583
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
all-combinationssearchstrategy
 base-choice search strategy
Model #Ast #Test #Flt
 #Fix Status Types
 SS ES
 FL(s) EG(s) EE(s)
 #Fix Status Types
 SS ES
 FL(s) EG(s) EE(s)
addr1
 124
 30
 1
 1
#
 M
 1
 1
41.0
 0.0
45.3
 1
#
 M
 1
 1
7.3
 0.0
 8.3
arr1
 64
 37
 1
 0
 
 –
 1.7e5
 1.3e5
 36.0
 13.5
291.4
 1
#
 S
 4e4
 88
 1.8
 1.9
 6.7
arr2
 80
 37
 1
 1
#
M+S
 3.4e7
 5e6
 11.6
 1.9
3.4e3
 1
#
M+S
 3.4e7
 178
 11.4
 1.9
16.9
bst1
 186
 124
 1
 1

 M
 1
 1
67.6
 0.0
74.2
 1

 M
 1
 1
46.4
 0.0
48.8
bst2
 161
 124
 3
 –
∞
 –
 –
 –
 –
 –
 –
 0
 
 –
 2e17
 1.6e5
 678.6
 597.2
 4.8e3
bst3
 165
 124
 2
 –
∞
 –
 –
 –
 –
 –
 –
 2

M+S
 2e8
 4e3
241.3
 1174
 1.5e3
bempl1
 51
 25
 1
 0
 
 –
 325
 325
 2.6
 0.4
 5.3
 0
 
 –
 325
 67
 2.6
 0.3
 5.3
cd1
 59
 31
 2
 1
 
 M
 1e4
 993
 5.9
 1.3
10.6
 2

M+S
 1.9e5
 688
 6.0
 3.9
12.7
cd2
 50
 31
 1
 1

 S
 966
 350
 2.3
 0.6
 6.4
 1

 S
 2.4e5
 810
 2.2
 4.7
11.2
ctree1
 71
 22
 1
 1

 M
 1
 1
5.6
 0.0
 6.5
 1

 M
 1
 1
5.5
 0.0
 6.4
dll1
 109
 50
 2
 2

 S
 4.9e4
 8522
 19.5
 2.3
42.1
 2

 S
 6.7e4
 239
 19.0
 8.3
34.1
dll2
 105
 50
 2
 2

M+S
 4.9e4
 8521
 26.7
 1.7
46.9
 2

M+S
 6.6e4
 192
 27.3
 7.7
39.8
dll3
 101
 50
 3
 –
∞
 –
 –
 –
 –
 –
 –
 0
 
 –
 1.7e9
 2.1e4
 31.3
 30.4
 94.7
dll4
 109
 50
 1
 1

M+S
 4.9e4
 8384
 16.3
 1.7
36.2
 1

M+S
 6.6e4
 191
 16.5
 7.7
28.8
farmer1
 180
 76
 1
 –
∞
 –
 –
 –
 –
 –
 –
 1

M+S
 7.6e13
 4556
 140.7
 1.6e4
 4.5e4
fsm1
 116
 15
 2
 2
#
 M
 2
 2
7.0
 0.0
 7.7
 2
#
 M
 2
 2
6.9
 0.0
 7.7
fsm2
 93
 15
 1
 1
#
 M
 1
 1
3.8
 0.0
 4.7
 1
#
 M
 1
 1
3.9
 0.0
 4.7
grade1
 71
 42
 1
 –
∞
 –
 –
 –
 –
 –
 –
 1

 S
 1.5e9
 1e3
 5.2
 9.5
739.6
other1
 68
 22
 1
 1
#
 S
 7593
 586
 2.4
 0.7
 8.3
 0
 
 –
 1.7e4
 387
 2.4
 0.7
 8.4
stu1
 213
 98
 1
 1

 S
 9.3e4
 836
 52.6
 6.7
85.1
 1

 S
 1.7e6
 186
 26.3
 1.8
46.6
stu2
 195
 98
 2
 –
∞
 –
 –
 –
 –
 –
 –
 1
 
 S
9.6e12
 9905
 141.7
 40.0
453.5
stu3
 237
 98
 2
 –
∞
 –
 –
 –
 –
 –
 –
 0
 
 –
1.7e15
 3.5e4
 347.9
 355.9
 2.8e3
stu4
 190
 98
 1
 1

 S
 9.3e4
 836
 53.6
 6.6
85.6
 1

 S
 1.7e6
 186
 26.8
 1.9
46.9
stu5
 235
 98
 1
 1

 S
 9.3e4
 836
 55.0
 6.7
87.9
 1

 S
 1.7e6
 186
 27.5
 1.9
48.4
stu6
 191
 98
 3
 –
∞
 –
 –
 –
 –
 –
 –
 2
 
M+S
 3.8e8
 4e3
120.2
 22.4
282.4
stu7
 174
 98
 2
 2

M+S
 5.4e5
 1e4
188.9
 15.4
265.7
 1
 
 S
9.3e10
 2.5e4
 213.7
 291.6
 1.7e3
stu8
 213
 98
 1
 1

 S
 1.4e4
 1e4
 33.4
 7.9
78.7
 1

 S
 1.4e4
 120
 33.4
 7.5
54.7
stu9
 198
 98
 1
 1
#
 M
 1
 1
49.0
 0.0
51.0
 1
#
 M
 1
 1
49.9
 0.0
51.9
stu10
 200
 98
 1
 1

 S
 9.3e4
 836
 63.7
 6.4
95.9
 1

 S
 1.7e6
 186
 30.4
 1.9
50.5
stu11
 221
 98
 1
 1

 S
 1.4e7
 4317
 97.6
 20.7
174.5
 1

 S
 1.4e7
 571
 65.3
 16.4
131.5
stu12
 201
 98
 2
 2

M+S
 9.3e4
 887
179.8
 8.1
224.6
 2

M+S
 1.7e6
 264
152.9
 3.5
186.9
stu13
 221
 98
 1
 1
#
 M
 1
 1
64.3
 0.0
66.4
 1
#
 M
 1
 1
64.5
 0.0
66.5
stu14
 183
 98
 3
 –
∞
 –
 –
 –
 –
 –
 –
 2
 
M+S
 3.8e8
 4e3
105.5
 23.4
266.2
stu15
 207
 98
 1
 1

 S
 9.3e4
 836
 68.6
 6.8
100.7
 1

 S
 1.7e6
 186
 33.7
 2.0
53.6
stu16
 113
 98
 4
 –
∞
 –
 –
 –
 –
 –
 –
 0
 
 –
 5.9e5
 6901
 43.0
 67.9
250.3
stu17
 190
 98
 2
 –
∞
 –
 –
 –
 –
 –
 –
 1
 
 S
 3.5e8
 3741
 61.0
 22.5
205.5
stu18
 207
 98
 3
 3

M+S
 2.9e9
 3.7e5
 160.6
 6.8
1.1e3
 3

M+S
 2.9e9
 409
115.4
 7.4
152.1
stu19
 216
 98
 2
 –
∞
 –
 –
 –
 –
 –
 –
 1
 
 S
 1e13
 8221
 194.1
 9e3
9596
Figure9: ARepair Results.Timesarein seconds.– denotesnot applicable.
to rank suspicious AST nodes in AlloyFL, because existing stud-
ies [68,85] show that Ochiai is effective. The expression genera-
tor generates different sizes of expressions based on the level ofthe holes in the suspicious AST. We set the expression size to 3for the deepest level of holes in each suspicious AST. The expres-
sion size increases by 1forholes atdepth D
i−1comparedtoholes
at depthDiwhereDi−Di−1=1, up to a maximum expression
size of 6. For the all-combinations search strategy, we partitionthe candidate fragments for each hole into 10 parts (i.e. k
i=10
in Figure 7), and we set the maximum number of combinations of
candidatefragmentstoexploreto10000(perlevelofholes).Forthebase-choice search strategy, we set the maximum number of can-
didatefragmentstoexploreforeachholeto1000.TheAUnittests
we use to validate the patches are automatically generated using
MuAlloy[ 74]sothattheyareabletodetectallnon-equivalentmu-
tant models [ 71]. Additionally, the authors manually inspect the
generated tests and add some new tests to cover different cornercases.Themanuallywrittentestsaccountfor<7%ofthetotaltests.
Wevalidatethecorrectnessofageneratedpatchbybothinspect-
ingthemmanuallyandusingtheAlloyanalyzertoperformascopeboundedequivalence check. The human-written patches are writ-
ten with the intention of introducing small perturbationsthat are
sufficient to fix the faults. We terminate ARepair once it finds apatch thatpasses all tests.AllexperimentsareperformedonUbuntu16.04LTSwith2.4GHz
Intel XeonCPU and 16GB memory. To save space, we denotethe
all-combinationssearchstrategyas ACandthebase-choicesearch
strategy as BCin thefollowing sections.
5.2 Repair Efficacy
Figure9shows the detailed results for ARepair. Model,#Ast,#Test
and#Fltshowthename, thenumberofASTnodes,thenumberof
testsandthenumberoffaults,respectively,foreachsubjectmodel.farmer1 is from Alloy release 4.1. addr1,bempl1,grade1and
other1arefromAmalgam[ 53].Therestmodelsarefromgraduate
student solutions. Student solutions for the same question share
thesametestsuite . #Fixshowsthenumberoffaultsasearch strat-
egy is abletofix. Statusshows therepair status. #means the gen-
eratedpatchissyntacticallyidentical tothehuman-writtenpatch.means the generated patch is synt actically different but seman-
ticallyequivalenttothehuman-writtenpath. meansthepatchis
plausible (incorrect but passes all tests). means ARepair fails to
generate a patch that pass all tests. ∞means the repair times out
after15hours. Typesshowswhetherthefixrequiresmutations(M)
orsynthesis(S). SSshowsthesearchspacesize,whichisdefinedas
thesumofthenumberofcombinationsofcandidatefragments(in-
cluding applied mutations for fixes) to consider in each iteration.
ESis the actual number of combinations (or mutations) ARepair
584
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. Automated Model Repair for Alloy ASE ’18, September 3–7, 2018, Montpellier, France
tried.FListhefaultlocalizationtime. EGistheexpressiongenera-
tiontime. EEis the end-to-end time. Alltimes are in seconds.
Theentireexperimentscontain38faultymodelsand62individ-
ualfaults.ACisabletofix24modelsand31faults.BCisabletofix
26 modelsand 42faults.Additionally,ACtimes out( ≥15h)for 12
modelswhileBCfinishesallmodelsin15h.ACisabletofix2mod-
elsthatBCisnotabletofix,e .g. other1andstu7.BCisabletofix
5 modelsthatACisnot abletofix(including 1plausiblepatchforcd1), e.g.arr1,bst3,cd1,farmer1 andgrade1. Many models re-
quirebothmutationsandsynthesisforacompletefix,e.g. arr2and
dll2. AC’s search space ranges from 1 to 2.9e9 and the maximum
size of the explored space is 5e6. BC’s search space ranges from 1to 2e17 and the maximum size of the explored space is 1.6e5. We
can see that BC explores less of its search space than AC, though
BC typically has a much larger search space. In general, BC runs
faster than AC, withthe exceptions of cd1,cd2andstu7.F orA C ,
thefaultlocalizationtimeranges from 2.3sec to188.9sec and themaximum expression generation time is 20.7 sec, excluding time-
outcases.ForBC,thefaultlocalizationtimerangesfrom1.8secto
678.6secandthemaximumexpressiongenerationtimeis1.6e4sec.
Typically, AC times out for models whose expression generation
time is large (≥1000s) under BC. A large expression generation
timeisareflectionofARepairproducingalargenumberofexpres-
sions,resultinginlargesearchspaces.Thismeansthatwhenthereare somany combinations ofcandidate fragments toconsider, AC
typicallytimesout.Incomparison,despitethelargenumberofex-
pressionsproduced,BCexploresmuchlessspaceandthusisfaster.However, BC can run into its local optimum. For example, the ex-plored space for other1is less than 600 for both BC and AC, but
BC cannot fix the model. Overall, AC and BC are complementaryand BC is superior in the sense that it takes less time to run andfixes morefaults.
5.3 PatchQuality
To answer RQ2,wefindthatBCgenerates26patchesthatpassall
tests (all patches are correct and 7 patches exactly match human-
written patches). AC generates 24 patches that pass all tests (23
patchesarecorrect;7patchesexactlymatchhuman-writtenpatches;and 1 patchisplausiblebutincorrect). We comparethegeneratedpatchesthataresyntacticallydifferentbutsemanticallyequivalent
to human-written patches. In addition to patches for the faulty
farmer model (Figure 3), Figure 10compares ARepair generated
patchesandhuman-writtenpatchesfor bst1(AandB), cd2(Cand
D)andstu8(EandF).The
Sortedpredicatein bst1modelsthatthe
valueofthecurrentnodeshouldbegreaterthanvaluesofitsleftde-
scendants and less than valuesofits rightdescendants. Thedevel-
operincorrectlyuse" n.^left"torepresentthedomainof n’sleftde-
scendants. The correct domain should be " n.left.*(left+right) "
as shown in the human-written patch. The generated patch re-stricts the domain to be "
n.^left.*right "w h i c hm e a n sa l ln o d e s
thatcanbereachablefrom nbyfirstfollowingoneormore leftre-
lationandthenzeroormore rightrelation.The Acyclicpredicate
incd2models that a class does not transitively extend itself. The
faultymodeldoesnotconsiderthetransitivityrequirement,which
is fixedinthehuman-writtenpatchbyreplacing " c = c.ext "w i th
"c in c.^ext ". The generated patch uses " c = c & c.^ext "w h i c h
(A)Human-written patchfor bst1.
1. predSorted() { alln: Node {
2.- alln2: n.^left | n2.elem < n.elem
3.+ alln2: n.left.*(left+right) | n2.elem < n.elem
4.- alln2: n.^right | n2.elem > n.elem}}
5.+ alln2: n.right.*(left+right) | n2.elem > n.elem}}
(B)ARepair generatedpatchfor bst1.
1. predSorted() { alln: Node {
2.- alln2: n.^left | n2.elem < n.elem
3.+ alln2: n.^left.*right | n2.elem < n.elem
4.- alln2: n.^right | n2.elem > n.elem}}
5.+ alln2: n.^right.*left | n2.elem > n.elem}}
(C)Human-written patchfor cd2.
1. predAcyclic() {
2.- noc: Class | c = c.ext }
3.+ noc: Class | c inc.^ext }
(D)ARepair generatedpatchfor cd2.
1. predAcyclic() {
2.- noc: Class | c = c.ext }
3.+ noc: Class | c = c & c.^ext }
(E)Human-written patchforstu8.
1. predSorted(This: List) {
2.- alln: Node | n.elem<=n.link.elem }
3.+ alln: Node | somen.link => n.elem<=n.link.elem }
(F) ARepairgenerated patchforstu8.
1. predSorted(This: List) {
2.- alln: Node | n.elem<=n.link.elem }
3.+ alln: link.Node | n.elem<=n.link.elem }
Figure 10: Comparison of ARepair generated patches and
human-writtenpatches.
states that no class is equal to the intersection of the class and all
its subclasses, transitively. The Sortedpredicate in stu8models a
linkedlistsortedindescendingorderofthenodevalues.Thefaultymodel does not allow the existence of any list with a single node
(withoutany
link).Thehuman-writtenpatchallowssuchcasesby
stating that if a node nhas a subsequent node following the link,
then its value should be less than or equal to the value of its sub-sequentnode.Thegeneratedpatchinsteadmodifiesthedomainto
restrictthelessthanorequalrelationonlyapplying tonodesthat
have asubsequent node.
The authors check correct patches that are syntactically differ-
ent from human-written patches and find that these patches areeasy to understand in general. There are rare cases that ARepairgenerates some complex expressions that can be further simpli-
fied throughsemantic reasoning. Additionally, ARepair generates
a patch which fixes a fact instead of the predicate the developer
would fix for ctree1.
5.4 Limitation
To answer RQ3, we manually inspect all faulty models that ARe-
pairisunabletofix.Thereasons arecategorizedasfollow:
(1) The repair requires synthesizing predicate and function calls.
For example, one ofthepropertyto fixin bst2requires invok-
ing predicates and functions.
(2) Therepair requires moving afielddeclarationfromone signa-
turetoanother,e.g. bempl1.
(3) The repair requires creation of new syntactic structures. For
example, dll3m od e l sap r o pe r t yu s i n gas i n g l eq u a n t i fi e r ,b u t
the model needs two. stu2has a formula with the structure
(α⇒β)||γ, but the correct fix requires α⇒βelseγ,w h e r eα,β
andγareformulas. stu6isoverconstrainedandthefixrequires
585
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
creatingadisjunctionofanewformulaandanexistingformula.
dll3andstu16have empty predicates and require ARepair to
synthesize formulasfrom scratch.
(4) BothACandBCsearchstrategiesaregreedyandmayruninto
a local optimum. For example, a correct patch of other1re-
quires changing two formulas at the same time and BC runs
into a local optimum that leads to a repair failure. Similarly,
AC runsinto alocaloptimumfor arr1.
We find that the majority of the faults ARepair is unable to fix
fall under category 3, followed by category 4. To handle faults incategory3,wecanaddrepairtemplatesthatintroducenewsyntac-
tic structures if the current version of ARepair is not able to find
a correct patch. New search strategies can be designed to addressfaults under category 4. From our experiment, ARepair is able to
handle a majority of the faulty models (28 out of 38) and we plan
tohandle the limitationsin futureworks.
6 THREATS TO VALIDITY
There exists several threats to the validity of our results. Many
of the parameters in the implementation and experimental setup
were chosen by heuristics. They may not represent the optimum
setofparametervalues.Moreover,theseparametervaluesmaynot
generalize to other unseen faulty models. ARepair’s ability to fix
faulty models depends on the fault localizationtechnique and the
AUnittestsuite.Ourexperimentresultsmayvaryifweuseadiffer-
entfaultlocalizationtechnique,e.g.Tarantula[ 23].Ifthetestsuite
is tooweak to capturethe desired modelproperties,ARepair may
givetoomanyplausiblebutincorrectpatches.Therealfaultymod-
els we use in the experiment are limited in the sense that most ofthem are written by graduate students. So the experiment results
maynotgeneralizetofaultymodelswrittenbyexperienceddevel-
opers. However, we collected our set of subject faulty models tothe best ofourability.
The AUnit tests (e.g., the test in Figure 1b), when written man-
ually ,canrequiresomeeffort.Inthispaper ,amajorityofthetests
(> 93%) are generated by MuAlloy [ 74] in which case the manual
effortissubstantiallyreduced.Ingeneral,themanualeffortcanbereduced by writing partialtests that provide valuations for a sub-
set ofthe relations declared in the model.For example, thetest in
Figure1bcanomittheconstraintsonvariousrelations(e.g.,
State,
near,a n dfar) becausetheseconstraintsare irrelevant totheprop-
erty the test is intended to check.
7 RELATED WORK
ARepairisa generate-and-validate repairtechniquefordeclarative
models written in Alloy. The technique is able to fix models withmultiple faults or faults that require fixes at multiple locations.
ARepairdoesnothaveanyrepairtemplates,insteaditcreatesholes
in suspicious AST nodes level by level and can fix different kindsof bugs. Theidea ofcombining mutations(from MBFL) and a syn-
thesizer to repair faulty programs is new. The base-choice searchstrategyreducestheexplorationspaceandisdifferentfromsearch
strategies of existing repair techniques. The hierarchical caching
reduces the input sizes of evaluator calls and is different from ex-isting memoization techniques. Next, we highlight the main areas
ofworkrelated toARepair.Generate-and-Validate Repair .Thegenerate-and-validate repair
techniques apply a set of code transformations to generate pro-
gram candidates and validate eac h candidate under the given test
suite. These techniques implement different search strategies, e.g.
genetic algorithms [ 81], semantic search [ 27],random search [ 59]
and adaptive search [ 80], to explore the immense search space
of repair candidates. Researchers also proposed other repair tech-niques that remove program functionalities [ 60], create program
variants [ 8,11], leverage dynamic program state [ 18,19,86], or
focuson improving performance by removing bottlenecks in con-current programs [ 87].Astor[43] is a repair library that imple-
ments existing techniques to fix Java code. Techniques that pri-
oritize patches are built based on human-written code [ 29,37,66,
83], historical data [ 14,34], document analysis [ 36,62,84], anti-
patterns[ 72] and test generation [ 82].
Constraint-Solving Repair .T h econstraint-solving repair tech-
niques use the semantics of the faulty program and translate therepair problem into a constraint solving problem. Then, the con-straint solving problem is solved by an off-the-shelf solver to find
a repair that satisfies all inferred specifications. The constraints
canbeinferred fromtestexecutions[ 12,38,64]orsemanticanaly-
sis [10,26,33,55]. Other techniques use formal specifications [ 17,
30,67,79]o
ri n f e ri n v a r i a n t s[ 13,24,58,63]tofixpr og rams.
Declarative Debugging . The fundamental idea of declarative de-
bugging is that the programmer (or some oracle) has an intended
interpretation of the program and debuggers can query the pro-
grammer to obtain this information. The debugger compares theintended interpretation of a (buggy) program with its (incorrect)actualbehavioron somecomputation.Thecause ofthedifference
is isolated to a small section of code which must contain a bug.
DeclarativedebuggingwasfirstintroducedinProlog[ 65]andthen
extendedforfunctionalandlogicprograms[ 50,51,57].Researchers
alsodeveloped programrepair techniquefor SQL [ 5,16].
Alloy. Over the past years, many extensions have been built for
Alloy [9,15,45,46,70,75]. Aluminum [ 54] generates minimal
instancestomakeiteasyforuserstoinspect.Amalgam[ 53]allows
userstoaskwhyandwhynotarelationexistinanAlloyinstance.
ASketch [ 76,78]provides a sketching framework forAlloy.
8 CONCLUSION
Thispaperintroducesa generate-and-validate repairtechnique,ARe-
pair,tofixfaultyAlloymodels.ARepairleveragesamutation-basedfault localization technique, an expression generator and a syn-thesizer to repair various kinds of faults. ARepair is enumeration-
basedanditenbodiestwosearchstrategies,i.e.theall-combination
strategy and the base-choice str ategy. ARepair implements vari-
ousoptimizations, including the useofmodulotest input pruningtoremove equivalentexpressions, theconstructionofdependency
graphtoreduceevaluatorcalls,andtheemploymentofahierarchi-
cal cache to reduce evaluator input size. The experimental resultsshow thatARepair workswell in fixing real faultymodels.
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheircomments.Thiswork
waspartiallysupportedbytheUSNationalScienceFoundationun-
derGrantsNos. CCF-1718903.
586
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. Automated Model Repair for Alloy ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1] RuiAbreu,PeterZoeteweij,andArjanJ.C.vanGemund.2007. OntheAccuracy
of Spectrum-basedFaultLocalization. In TAICPART-MUTATION .
[2] Christoffer Quist Adamsen, Anders Møller, Rezwana Karim, Manu Sridharan,
Frank Tip, and Koushik Sen. 2017. Repairing event race errors by controlling
nondeterminism. In ICSE.
[3] RajeevAlur,ArjunRadhakrishna,andAbhishekUdupa.2017. Scalingenumera-
tiveprogramsynthesis viadivide andconquer.In TACAS.
[4] Paul Ammannand JeffOffutt. 2008. Introduction toSoftware Testing .
[5] Marcelo Arenas, Leopoldo Bertossi, and Jan Chomicki. 2001. Specifying and
querying database repairs using logic programs with exceptions. In Flexible
Query AnsweringSystems .
[6] Hamid Bagheri and Sam Malek. 2016. Titanium: Efficient Analysis of Evolving
Alloy Specifications. In FSE.
[7] YanCai,LingweiCao,andJingZhao.2017. AdaptivelyGeneratingHighQuality
Fixes forAtomicity Violations. In FSE.
[8] Antonio Carzaniga, Alessandra Gorla, Andrea Mattavelli, Nicolò Perino, and
MauroPezzè.2013. Automatic RecoveryfromRuntime Failures.In ICSE.
[9] Alcino Cunha and Nuno Macedo. 2018. Validating the Hybrid ERTMS/ETCS
Level3 Conceptwith Electrum. In ABZ.
[10] Loris D’Antoni, Roopsha Samanta, and Rishabh Singh. 2016. Qlose: Program
Repair with QuantitativeObjectives.In CAV.
[11] VidrohaDebroyandW.EricWong. 2010. UsingMutationtoAutomaticallySug-
gest Fixes for FaultyPrograms.In ICST.
[12] FavioDemarco,JifengXuan,DanielLeBerre,andMartinMonperrus.2014. Au-
tomatic repair of buggy if conditions and missing preconditions with SMT. InCSTVA.
[13] Brian Demsky, Michael D. Ernst, Philip J. Guo, Stephen McCamant, Jeff H.
Perkins,andMartinC.Rinard.2006.Inferenceandenforcementofdatastructureconsistency specifications. In ISSTA.
[14] Fan Long and Martin Rinard. 2016. Automatic patch generation by learning
correctcode. In POPL.
[15] MRFrias,JuanPGaleotti,CarlosGLópezPombo,andNazarenoMAguirre.2005.
DynAlloy: upgradingalloy with actions. In ICSE.
[16] DivyaGopinath, SarfrazKhurshid,DiptikalyanSaha,andSatish Chandra.2014.
Data-guidedrepairof selectionstatements. In ICSE.
[17] Divya Gopinath, Muhammad Zubair Malik, and Sarfraz Khurshid. 2011.
Specification-Based ProgramRepairUsing SAT. In TACAS.
[18] JinruHua,MengshiZhang,KaiyuanWang,and SarfrazKhurshid.2018. Sketch-
Fix:AToolforAutomatedProgramRepairApproachUsingLazyCandidateGen-eration.In FSE.
[19] JinruHua,MengshiZhang,KaiyuanWang,andSarfrazKhurshid.2018.Towards
PracticalProgramRepairwithOn-DemandCandidate Generation.In ICSE.
[20] ChangyunHuang,YasutakaKamei,KazuhiroYamashita,andNaoyasuUbayashi.
2013. Using Alloy to Support Feature-basedDSL Construction for Mining Soft-
wareRepositories. In SPLC.
[21] SiHuang, MyraB.Cohen, andAtif M.Memon.2010. RepairingGUITest Suites
Using aGenetic Algorithm. In ICST.
[22] DanielJackson.2002. Alloy: ALightweightObjectModelling Notation. TOSEM
(2002).
[23] J. A. Jones, M. J. Harrold, and J. Stasko. 2002. Visualization of test information
toassistfaultlocalization. In ICSE.
[24] Frolin S. OcarizaJr., Karthik Pattabiraman, and Ali Mesbah. 2014. Vejovis: sug-
gesting fixesforJavaScriptfaults.In ICSE.
[25] René Just, DarioushJalali, and Michael D. Ernst. 2014. Defects4J: a databaseof
existing faults to enable controlled testing studies for Javaprograms.In ISSTA.
[
26] ShaliniKaleeswaran,VarunTulsian,AdityaKanade,andAlessandroOrso.2014.
MintHint: automated synthesis of repairhints. In ICSE.
[27] Yalin Ke, Kathryn T. Stolee, Claire Le Goues, and Yuriy Brun. 2015. Repairing
Programswith Semantic Code Search.In ASE.
[28] SarfrazKhurshid, DarkoMarinov,Ilya Shlyakhter,and Daniel Jackson.2003. A
Casefor EfficientSolution Enumeration. In SAT.
[29] DongsunKim,JaechangNam,JaewooSong,andSunghunKim.2013. Automatic
patch generationlearned fromhuman-writtenpatches.In ICSE.
[30] Etienne Kneuss, Manos Koukoutos, and Viktor Kuncak. 2015. Deductive Pro-
gramRepair.In CAV.
[31] YoannLaurent,RedaBendraou, SouheibBaarir,and Marie-PierreGervais.2014.
Alloy4SPV: AFormalFrameworkforSoftware ProcessVerification.In ECMFA.
[32] VuLe,MehrdadAfshari,andZhendong Su.2014. Compilervalidationviaequiv-
alence modulo inputs.In PLDI.
[33] Xuan-BachD.Le,Duc-HiepChu,DavidLo,ClaireLeGoues,andWillemVisser.
2017. S3: syntax- and semantic-guided repair synthesis via programming byexamples.In FSE.
[34] Xuan-BachD.Le,DavidLo,andClaireLeGoues.2016. HistoryDrivenProgram
Repair.In SANER.
[35] ClaireLe Goues, Michael Dewey-Vogt, Stephanie Forrest, and Westley Weimer.
2012. Asystematicstudyofautomatedprogramrepair:Fixing55outof105bugsfor $8each.In ICSE.
[36] ChenLiu,JinqiuYang,LinTan,andMunawarHafiz.2013. R2Fix:Automatically
Generating Bug Fixes fromBug Reports. In ICST.
[37] FanLong,PeterAmidon, andMartinRinard.2017. Automaticinferenceofcode
transformsforpatchgeneration. In FSE.
[38] Fan Long and Martin Rinard. 2015. Staged program repairwith condition syn-
thesis. In FSE.
[39] SonalMahajan,AbdulmajeedAlameer,PhilMcMinn,andWilliamG.J.Halfond.
2017. Automated repairoflayout crossbrowserissuesusing search-basedtech-
niques. In ISSTA.
[40] Ferney A. Maldonado-Lopez, Jaime Chavarriaga, and Yezid Donoso. 2014. De-
tecting NetworkPolicy Conflicts Using Alloy. In ABZ.
[41] Shahar Maoz, JanOliver Ringert, and Bernhard Rumpe. 2011. CD2Alloy: Class
DiagramsAnalysisUsing Alloy Revisited. In MODELS.
[42] ShaharMaoz,JanOliverRingert,andBernhardRumpe.2011. CDDiff:Semantic
DifferencingforClassDiagrams.In ECOOP.
[43] MatiasMartinezandMartinMonperrus.2016. ASTOR:aprogramrepairlibrary
for Java(demo). In ISSTA.
[44] SergeyMechtaev,Jooyong Yi, and Abh ikRoychoudhury.2015. DirectFix:Look-
ing for SimpleProgramRepairs.In ICSE.
[45] Aleksandar Milicevic, Joseph P. Near, Eunsuk Kang, and Daniel Jackson. 2015.
Alloy*: A General-purposeHigher-order Relational Constraint Solver.In ICSE.
[46] FacundoMolina, CésarCornejo,RenzoDegiovanni,GermánRegis,PabloFCas-
tro,NazarenoAguirre,andMarceloFFrias.2016. AnEvolutionaryApproachto
TranslateOperational Specifications into DeclarativeSpecifications. In BSFM.
[47] Vajih Montaghami and Derek Rayside. 2012. Extending Alloy with Partial In-
stances.In ABZ.
[48] S. Moon, Y. Kim, M. Kim, and S. Yoo. 2014. Ask the Mutants: Mutating Faulty
Programsfor Fault Localization. In ICST.
[49] Mariano M. Moscato, Carlos G. Lopez Pombo, and Marcelo F. Frias. 2014. Dy-
namite: A Tool for the Verification of Alloy Models Based on PVS. ACM Trans.
Softw. Eng.Methodol. (
 2014).
[50] Lee Naish. 1997. A Declarative Debugging Scheme. Journal of Functional and
LogicProgramming (1997).
[51] Lee Naish. 2000. A three-valued declarative debugging scheme. In Computer
Science Conference .
[52] TimothyNelson,ChristopherBarratt,DanielJ.Dougherty,KathiFisler,andShri-
ramKrishnamurthi.2010. The MargraveTool forFirewallAnalysis.In LISA.
[53] Tim Nelson, Natasha Danas, Daniel J. Dougherty, and Shriram Krishnamurthi.
2017. ThePowerof"Why"and"WhyNot":EnrichingScenarioExplorationwith
Provenance. In FSE.
[54] TimNelson,SalmanSaghafi,DanielJDougherty,KathiFisler,andShriramKrish-
namurthi.2013. Aluminum:principledscenarioexplorationthroughminimality.InICSE.
[55] HoangDuongThienNguyen,DaweiQi,AbhikRoychoudhury,andSatishChan-
dra.2013. Semfix:Programrepairviasemanticanalysis.In ICSE.
[56] Mike Papadakis and Yves Le Traon. 2015. Metallaxis-FL: Mutation-based Fault
Localization. STVR(2015).
[57] LuísMonizPereira.1986. Rational debugging inlogic programming.In ICLP.
[58] JeffH.Perkins,SunghunKim,SamuelLarsen,SamanP.Amarasinghe,Jonathan
Bachrach, Michael Carbin,Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
GregSullivan, Weng-Fai Wong, Yoav Zibin, MichaelD. Ernst, and Martin C. Ri-
nard.2009. Automatically patching errorsindeployed software.In SOSP.
[59] YuhuaQi,XiaoguangMao,YanLei,ZiyingDai,andChengsongWang.2014.The
strength of random searchon automated programrepair.In ICSE.
[60] Zichao Qi, Fan Long, Sara Achour, and Martin C. Rinard. 2015. An analysis of
patch plausibility and correctness for generate-and-validate patch generationsystems.In ISSTA.
[61] NataliRuchansky and DavideProserpio. 2013. A (Not) NICE Wayto Verifythe
OpenflowSwitchSpecification:FormalModellingoftheOpenflowSwitchUsing
Alloy.SIGCOMM (2013).
[62] RiponKSaha,YingjunLyu,HiroakiYoshida,andMukulRPrasad.2017. ELIXIR:
effectiveobject oriented programrepair.In ASE.
[63] HesamSamimi,MaxSchäfer,ShayArtzi,Todd D.Millstein,FrankTip,andLau-
rie J. Hendren. 2012. Automated repair of HTML generation errors in PHP ap-
plications usingstring constraintsolving. In ICSE.
[64] SergeyMechtaev,JooyongYi,andAbhikRoychoudhury.2016. Angelix:Scalable
Multiline ProgramPatchSynthesis viaSymbolicAnalysis.In ICSE.
[65] Ehud Y. Shapiro.1983. AlgorithmicProgramDeBugging . MITPress.
[66] Stelios Sidiroglou-Douskos, Eric Lahtinen, Fan Long, and Martin Rinard. 2015.
Automaticerroreliminationbyhorizontalcodetransferacrossmultipleapplica-
tions. InPLDI.
[67] Rishabh Singh, Sumit Gulwani, and Armando Solar-Lezama. 2013. Automated
feedback generation for introductory programmingassignments. In PLDI.
[68] Friedrich Steimann, MarcusFrenkel, and Rui Abreu.2013. Threatsto the valid-
ity and value of empirical assessments of the accuracy of coverage-basedfault
locators. In ISSTA.
587
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Kaiyuan Wang, Allison Sullivan, and Sarfraz Khurshid
[69] Allison Sullivan, Kaiyuan Wang, and Sarfraz Khurshid. 2018. AUnit: A Test
Automation Tool for Alloy. In ICST.
[70] Allison Sullivan, Kaiyuan Wang, Sarfraz Khurshid, and Darko Marinov. 2017.
Evaluating State Modeling Techniques inAlloy.In SQAMIA.
[71] AllisonSullivan,KaiyuanWang,RaziehNokhbehZaeem,andSarfrazKhurshid.
2017. Automated TestGeneration and Mutation Testing for Alloy.In ICST.
[72] Shin Hwei Tan, Hiroaki Yoshida, Mukul R. Prasad, and Abhik Roychoudhury.
2016. Anti-patterns in search-basedprogramrepair.In FSE.
[73] Emina Torlakand DanielJackson.2007. Kodkod: A Relational Model Finder. In
TACAS.
[74] KaiyuanWang,AllisonSullivan,andSarfrazKhurshid.2018. MuAlloy:AMuta-
tion Testing Frameworkfor Alloy. In ICSE.
[75] KaiyuanWang,AllisonSullivan,ManosKoukoutos,DarkoMarinov,andSarfraz
Khurshid.2018. SystematicGenerationofNon-EquivalentExpressionsforRela-
tionalAlgebra.In ABZ.
[76] Kaiyuan Wang, Allison Sullivan, Darko Marinov, and Sarfraz Khurshid. 2018.
ASketch: ASketching Frameworkfor Alloy.In FSE.
[77] Kaiyuan Wang, Allison Sullivan, Darko Marinov, and Sarfraz Khurshid. 2018.
FaultLocalizationfor DeclarativeModels inAlloy. In eprint arXiv:1807.08707.
[78] Kaiyuan Wang, Allison Sullivan, Darko Marinov, and Sarfraz Khurshid. 2018.
Solver-basedSketching Alloy Models usingTest Valuations.In ABZ.[79] Yi Wei, Yu Pei, Carlo A. Furia, Lucas Serpa Silva, Stefan Buchholz, Bertrand
Meyer,and AndreasZeller.2010. Automated fixing of programswith contracts.InISSTA.
[80] Westley Weimer, Zachary P. Fry, and Stephanie Forrest. 2013. Leveraging pro-
gramequivalenceforadaptiveprogramrepair:Modelsandfirstresults.In ASE.
[81] Westley Weimer, ThanhVu Nguyen, Claire Le Goues, and Stephanie Forrest.
2009. Automatically finding patches usinggenetic programming.In ICSE.
[82] Qi Xin and Steven P. Reiss. 2017. Identifying test-suite-overfitted patches
through test casegeneration.In ISSTA.
[83] QiXinand StevenP Reiss.2017. Leveragingsyntax-relatedcode forautomated
programrepair.In ASE.
[84] Yingfei Xiong, JieWang, Runfa Yan, JiachenZhang, Shi Han, GangHuang, and
LuZhang. 2017. Precisecondition synthesisfor programrepair.In ICSE.
[85] Jifeng Xuanand MartinMonperrus. 2014. Learningto Combine Multiple Rank-
ing MetricsforFaultLocalization.In ICSME.
[86] Zijiang Yang, Jinru Hua, Kaiyuan Wa ng, and Sarfraz Khurshid. 2018. EdSynth:
Synthesizing API Sequences with Conditionals and Loops. In ICST.
[87] Tingting Yu and Michael Pradel. 2017. Pinpointing and repairing performance
bottlenecks inconcurrent programs. ESE(2017).
588
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:53 UTC from IEEE Xplore.  Restrictions apply. 