  
   
General Rights  
Copyright and moral rights for the publications made accessible in the public portal are retained by the authors and/or other  copyright owners 
and it is a condition of accessing publications that users recogniz e and abide by the legal requirements associat ed with these rights.  
 • Users may download and print one copy of any publication from the public portal for the purpose of private study or researc h. 
 • You may not further distribute the material or use it for any profit -making activity or commercial gai n  
• You may freely distribute the URL identifying the publication in the public portal  
If you believe that this document breaches copyright please contact us providing details, and we will remove access to the wo rk immediately and 
investigate your claim.  
 
If the document is published under a Creative Commons license, this applies instead of  the general right s. 
This coversheet template is made available by AU Library  
Version 2.0, December 2017 
 
Coversheet  
 
This is the accepted manuscript (post -print  version) of the  article.  
Contentwise , the accepted manuscript version is identical to the final published version, but there may  
be differ ences  in typography and layout .  
 How to cite this publication  
Please cite the final published version:  
 
Anders Møller and Martin Toldam Torp. 2019. Model -based testing of breaking changes in Node.js 
libraries. In Proceedings of the 2019 27th ACM  Joint Meeting on European Software Engineering 
Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2019). Association 
for Computing Machinery, New York, NY, USA, 409– 419. DOI:https://doi.org/10.1145/3338906.3338940  
 
Publication metadata  
 
Title:  Model -based testing of breaking changes in Node.js libraries  
Author(s):  Anders Møller and Martin Toldam Torp  
Journal:  Proceedings of the 2019 27th ACM Joint Meeting on European Software 
Engineering Conference and Symposium on the Foundations of Software 
Engineering (ESEC/FSE 2019 ) 
DOI/Link : https://doi.org/10.1145/3338906.3338940  
Document version:  
 Accepted manuscript (post -print)  
 
 
 Model-Based Testing of
Breaking Changes in Node.js Libraries
Anders Møller
Aarhus University, Denmark
amoeller@cs.au.dkMartin Toldam Torp
Aarhus University, Denmark
torp@cs.au.dk
ABSTRACT
Semantic versioning is widely used by library developers to indicate
whether updates contain changes that may break existing clients.
Especially for dynamic languages like JavaScript, using semantic
versioning correctly is known to be difficult, which often causes
program failures and makes client developers reluctant to switch
to new library versions.
The concept of type regression testing has recently been intro-
duced as an automated mechanism to assist the JavaScript library
developers. That mechanism is effective for detecting breaking
changes in widely used libraries, but it suffers from scalability limi-
tations that make it slow and also less useful for libraries that do
not have many available clients.
This paper presents a model-based variant of type regression
testing. Instead of comparing API models of a library before and
after an update, it finds breaking changes by automatically gener-
ating tests from a reusable API model. Experiments show that this
new approach significantly improves scalability: it runs faster, and
it can find breaking changes in more libraries.
CCS CONCEPTS
•Software and its engineering →Software maintenance tools ;
Software testing and debugging .
KEYWORDS
semantic versioning, JavaScript
ACM Reference Format:
Anders Møller and Martin Toldam Torp. 2019. Model-Based Testing of
Breaking Changes in Node.js Libraries. In Proceedings of the 27th ACM Joint
European Software Engineering Conference and Symposium on the Founda-
tions of Software Engineering (ESEC/FSE ’19), August 26–30, 2019, Tallinn,
Estonia. ACM, New York, NY, USA, 11 pages. https://doi.org/10.1145/
3338906.3338940
1 INTRODUCTION
An important challenge in software maintenance is how library
developers can make updates without unintentionally breaking the
existing clients of the libraries. Library developers commonly use
the semantic versioning scheme to indicate if an update contains
backward incompatible changes, also called breaking changes. With
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
©2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5572-8/19/08. . . $15.00
https://doi.org/10.1145/3338906.3338940semantic versioning, updates are marked as major when they are
backward incompatible and minor or patch otherwise. Generally,
library developers should strive toward creating backward compat-
ible updates since clients often apply such updates automatically,
and instant rollout of updates can be critical for security fixes.
A considerable weakness of semantic versioning is that library
developers mostly rely on their own estimates when deciding which
semantic versioning category an update belongs to. Previous work
has shown that developers often incorrectly classify updates as
minor or patch despite breaking changes [ 3,6,9,15,17]. This
is especially problematic for dynamically typed languages, like
JavaScript, where mismatches between the library and the client
code are not detected until run-time. JavaScript application pro-
grammers use libraries extensively; the npm1repository contains
more than 750 000 modules, mostly libraries, many of which have
thousands of daily downloads and are frequently updated.
A few tools exist for helping developers detect breaking changes
before an update is released to the clients. Examples include APIDiff ,
Clirr , and Revapi for Java [ 8], the elm diff tool2for elm, and
NoRegrets [15] and dont-break3for JavaScript. A common prop-
erty of these tools is that they compute the changes to the types of
the public API of the library for a given update, and then identify
the changes that may break clients. Although this approach can
only detect type-related breaking changes, not semantic changes
that affect the library functionality but preserve the types, previous
work has shown that it is strong enough to catch most breaking
changes in practice [4, 15].
The existing techniques NoRegrets anddont-break for JavaScript
require running the test suites of a library’s clients to detect break-
ing changes when the library has been updated. That approach has
several disadvantages. First, installing the client test suites may
consume a considerable amount of storage, and running them of-
ten takes significant time, although typically only a small part of
those test suites is relevant for the library. The dont-break tool
simply reports breaking changes whenever a client test fails with
the updated version of the library. In contrast, NoRegrets uses
a technique called type regression testing. It performs a dynamic
analysis of the client test executions to infer models of the library
API before and after the library update, which leads to more er-
rors being detected and to more actionable error reports for the
library developer. However, an important limitation of NoRegrets
is that it can only use those clients whose dependencies include
the current version of the library. For example, after a new major
release of the library, the clients cannot be used by NoRegrets
until they have been updated to the new version. (We explain this
1https://www.npmjs.com
2https://package.elm-lang.org/
3https://www.npmjs.com/package/dont-breakESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia Anders Møller and Martin Toldam Torp
technical limitations of NoRegrets in more detail in Section 7.)
As a consequence, we find that NoRegrets does not work well on
libraries that only have few available clients.
In this paper, we present a new technique for finding breaking
changes in Node.js library updates, which does not suffer from these
limitations of existing tools and yet finds more breaking changes.
The new technique is implemented in the tool NoRegrets +. It bor-
rows the concept of dynamically computed API models introduced
byNoRegrets , however, NoRegrets +does not need to re-run all
the client tests at every new release candidate of a library. Instead,
from a single execution of the client tests it computes an API model
that can be used for checking multiple subsequent updates of the li-
brary. It does so by using the model to guide a dynamic exploration
of the library, while checking that the types of the values that flow
between the library and the clients are compatible with the model.
Since NoRegrets +only uses the client tests to generate the
initial model, it avoids running the irrelevant code of the client
tests in the checking phase, which makes it considerably faster than
NoRegrets . The models are typically not very large, so they are
also more easily stored than the whole set of clients. Additionally,
this new approach is less sensitive to the versioning constraints in
the client dependencies, which makes it useful even for libraries
with relatively few clients.
In summary, this work makes the following contributions:
•We present a new model-based approach to type regression
testing, designed to overcome the main practical limitations of
theNoRegrets technique.
•We demonstrate by an experimental evaluation of our imple-
mentation NoRegrets +that it is able to find more breaking
changes than NoRegrets , an order of magnitude faster and
requiring less space, and that the new approach works better
for libraries where relatively few clients are available. Specifi-
cally, applying NoRegrets +to a total of 1 914 minor or patch
updates of 25Node.js libraries with varying numbers of clients
detects 84breaking changes, where NoRegrets in comparison
only finds 28.
The tool NoRegrets +is available at https://brics.dk/noregrets/ .
2 MOTIVATING EXAMPLE
To illustrate the practical limitations of the existing techniques
for detecting breaking changes in JavaScript libraries, consider the
big-integer library for arbitrary precision integer arithmetic.4
Example 1 The patch update of big-integer from version 1.4.6
to version 1.4.7 introduced a new representation of integers that
are small enough to fit in a primitive number, based on a new con-
structor named SmallInteger . The library internally uses a function
parseValue to create a representation of a big integer from some
user-supplied input, for example, a string representation of the in-
teger in decimal form. The update contains the following changes:
1//big-integer 1.4.6
2function parseValue (v) {
3 ...
4 return new BigInteger(...);
5}
4https://www.npmjs.com/package/big-integer6//big-integer 1.4.7
7function parseValue (v) {
8 if (isPrecise(v)) {
9 return new SmallInteger(v);
10 }
11 ...
12 return new BigInteger(...);
13}
The new SmallInteger constructor is used instead of BigInteger
when the user-supplied value is small enough (lines 8–10). The
SmallInteger constructor internally uses a primitive number to rep-
resent its value, which makes it more efficient than the array of
numbers used by BigInteger . To make the underlying represen-
tation transparent to the users, the update also includes opera-
tions on SmallInteger objects mirroring the existing functionality
ofBigInteger . All the operations performed on these types are
overloaded, for example, it is possible to seamlessly multiply a
SmallInteger with a BigInteger . With this optimization, the big-
integer library became much faster at processing smaller integers
with the release of version 1.4.7.
However, the valueOf method behaves differently. On BigInteger
it returns a best-effort conversion to a primitive number, while on
SmallInteger it instead returns a reference to the SmallInteger ob-
ject itself. Because of this difference, the update contains a breaking
change that should not have been introduced in a patch update. The
severity of this breaking change is demonstrated by the fact that the
big-integer developers released a patch of this issue (version 1.4.12)
even after version 1.5.0 was released to also accommodate clients
that automatically apply patch updates but not minor updates.
As mentioned in Section 1, the dont-break tool works by running
the test suites of clients of the library before and after the update.
One such client is the deposit-iban5library, which contains the
following code:
14const bigInt = require( 'big-integer ');
15export function isValidIban(iban) {
16 ...
17 const bban = ... // '620000000202102329006182700 ';
18 const checkDigitBigInt = bigInt(bban);
19 let checkDigitNumber =
20 String(98 - checkDigitBigInt.mod(bigInt( '97')));
21 ...
22}
Before the upgrade of big-integer , in line 20 the modmethod re-
turns a BigInteger object whose valueOf method is invoked implic-
itly at the ‘ -’ operator. After the upgrade, modinstead returns a
SmallInteger object with the different valueOf method, which re-
turns the SmallInteger object instead of a primitive number. This
means that at the ‘ -’ operator, JavaScript implicitly now also in-
vokes SmallInteger ’stoString method, which returns a string that
in turn is coerced into a primitive number. The test suite of deposit-
iban does reach the isValidIban function and the different behavior
in line 20. Nevertheless, all the tests still succeed with the broken
version 1.4.7 of big-integer because the JavaScript runtime coerces
the result of the modcall to the same primitive number as in ver-
sion 1.4.6, even though the behavior of valueOf has changed. As a
consequence, dont-break misses the breaking change.
5https://www.npmjs.com/package/deposit-ibanModel-Based Testing of Breaking Changes in Node.js Libraries ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
In contrast, the NoRegrets tool can detect this breaking change
using deposit-iban ’s test suite. The API model produced by NoRegrets
forbig-integer version 1.4.6 will state that valueOf returns a number ,
whereas the model of version 1.4.7 will state that valueOf returns
anobject . Clearly, these two types are not interchangeable, so a
breaking change is reported. However, NoRegrets still runs all of
deposit-iban ’s test suite, which consists of 45 separate tests where
only some use big-integer . That test suite was naturally developed
to test the logic of deposit-iban rather than that of big-integer , so
even for those tests that do use big-integer , most of the work is
irrelevant from the perspective of determining whether the API of
thebig-integer library has changed.
With our new approach, NoRegrets +, the test suites of the
clients are still required to infer the initial API model of big-integer .
However, once this initial model has been constructed, NoRegrets +
checks the types of the library’s API by dynamically exploring it
based on the information in the model. Specifically, for the afore-
mentioned breaking change, all NoRegrets +needs to do is to load
thebig-integer library, call the modfunction with the right argu-
ments, call valueOf on the result, and assert that the type is com-
patible with the type in the model. Expressed as JavaScript code,
this corresponds to executing the following test:
23const bigInt = require( 'big-integer ');
24assert(typeof(bigInt( '620000000202102329006182700 ')
25 .mod(bigInt( '97')).valueOf())
26 === "number")
With this approach there is no need for storing the entire deposit-
iban client and its test suite (and similarly for all the other clients
ofbig-integer ), and the breaking change detection phase is much
faster since the irrelevant work is avoided.
3 OVERVIEW
The purpose of NoRegrets +is to help Node.js library developers
determine if a modification of a library results in breaking changes
in the types of the library’s API.
The intended usage is as follows. First, the library developer
uses the model generation phase ofNoRegrets +that automatically
fetches publicly available clients and their tests from GitHub, and
then runs the tests and simultaneously records the interactions with
the library to form a model of the library’s API. When the library
developer is later ready to release an update, NoRegrets +is run in
thetype regression testing phase6on the updated version of the li-
brary code, and a set of non-backward-compatible differences in the
API types is reported. If the set is empty, then the library developer
can confidently mark the update as either minor or patch, since
the API types of the library probably did not change. On the other
hand, a nonempty set indicates changes to the API. If a manual
inspection of the causes of the warnings produced by NoRegrets +
shows that the differences are unlikely to cause problems in prac-
tice, then the developer can go ahead and release the new code
as a minor or patch update. If instead the warnings reveal more
serious breaking changes, then the developer can either release
the changes as a major update (and appropriately document the
6Using the terminology introduced by Mezzetti et al . [15] , atype regression is a change in
the type signatures of the library API that is incompatible with the mutual expectations
of the client and the library developers.breaking changes), or, if the changes were unintended, choose to
fix the library code and rerun the checking phase of NoRegrets +
to check that the type regressions are gone and that no new type
regressions were introduced in the process. The checking phase is
fast enough to be integrated into the library’s integration test suite,
such that NoRegrets +can be used continuously to check for type
regressions during the development cycle.
Because of the dynamic nature of JavaScript, the API models
produced by NoRegrets +are of course not perfect, so the tool
should be used as a supplement, not a substitute for the developer’s
understanding of the library code. However, as shown in previous
work [ 15] and in the experimental evaluation of NoRegrets +(Sec-
tion 6), library developers often overlook breaking changes, and
NoRegrets +can catch many of them.
Example 2 Continuing Example 1, NoRegrets +will first gener-
ate an API model for version 1.4.6ofbig-integer , by running the test
suite of deposit-iban while dynamically analyzing the interactions
between the client and the library. The main constituent of an API
model is a map from dynamic access paths totypes , which we define
formally in Section 4. Intuitively, a dynamic access path (or path,
for short) refers to the value that appears as result of performing
a sequence of operations, for example, a call from the client to a
library function, or a write within the library to an object originat-
ing from the client. Types include the ordinary JavaScript types,
such as string and number , and also concrete primitive values. For
example, the following paths expose the problem from Example 1:
p1:require(big-integer)a→arg0
p2:require(big-integer)b→arg0
p3:require(big-integer)()b
p4:require(big-integer)()a.modc→arg0
p5:require(big-integer)()a.mod()c.valueOf()d
A model that includes these paths (and many others) is generated
when using the client test code shown in lines 14–22. For line 18
when the client calls bigInt , the path p1refers to the value being
read by the library function when accessing argument number 0, in
this case the string '620000000202102329006182700 '. For the second
call to bigInt in line 20, p2similarly refers to the string '97', and p3
refers to the return value. The path p4refers to the value read by the
modlibrary function when it reads its argument number 0. Finally, p5
refers to the value returned by the implicit call to valueOf at the ‘ -’
operator in line 20 as the type number . The labels a,b, and cuniquely
identify the function calls involved; specifically, we see that p1,p4,
andp5involve the same call to require( 'big-integer '), and p4and
p5involve the same call to mod. An API model additionally contains
information about the order in which the paths have been observed
and how values flow between paths, which we describe in Section 4.
Such a model contains enough information to enable NoRegrets +
to automatically produce type regression tests like the one shown in
lines 23–26. For example, when NoRegrets +is run in the checking
phase on version 1.4.7ofbig-integer , it simulates the individual
actions of the path p5and observes that valueOf returns an object
instead of a number, and therefore issues a type regression warning.
To reproduce the actions of p5,NoRegrets +obtains arguments
for the calls to modand the main function of big-integer simply by
inspecting the model at p1,p2, and p4. This process of generating
tests from the model is described in more detail in Section 5.ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia Anders Møller and Martin Toldam Torp
4 PHASE I: MODEL GENERATION
We obtain realistic executions of the library of interest by leveraging
the publicly available test suites of clients of the library. Running
the test suites using program instrumentation with ES6 proxies,
NoRegrets +can monitor the flow of values between the clients
and the library, which makes it possible to build a model of the
public API of the library. Although this phase of NoRegrets +is
conceptually very close to NoRegrets , for completeness we briefly
explain NoRegrets +’s notion of API models, and we point out the
important differences.
API models An API model is a triple(π,σ,ρ). We first explain
π, which is map of the form π:Path→Type that associates types
with elements of a library API. The set Path consists of dynamic
access paths , each being a sequence of actions , as described in the
following grammar by pandα, respectively.
p::=ε|require(n)|pα
α::=.n|()κ|new()κ|κ→argj| ·n→
Dynamic access paths can be thought of as references to elements
of the library’s API. Each kind of action corresponds to a JavaScript
operation, and a path corresponds to a sequence of operations. All
paths begin with a require(n)action, where nis the name of a Node.js
module.7The require(n)action can be followed by a sequence of
property reads (denoted .nwhere nis a property name), function
and constructor applications (denoted ()κand new()κwhereκis
explained below) and argument reads (denotedκ→argjwhere j
indicates the zero-indexed position of the argument). We refer to
Mezzetti et al . [15] for further description of these different kinds
of actions that also appear in NoRegrets .
InNoRegrets +, paths can additionally contain write actions
(denoted·n→, where nis the property being written), for modeling
side-effects of the client and library functions in the API models.
Theκlabel in the actions is used to distinguish calls to the same
function.8In an argument read action,κ→argj, the labelκidentifies
the function call for which the argument is being read. The purpose
of these modifications to the Path mechanism becomes clear when
we explain the type regression testing phase in Section 5.
As an example, the qs9library has a method named parse that
in version 2.2.1 unintentionally writes to the value property of the
object given as argument (this error is described in more detail in
Section 6.2). We can refer to the value being written using the path
require(qs).parsea→arg0·value→. This path describes the follow-
ing actions: load the library using require( 'qs'), invoke its parse
method (with an argument obtained via another part of the model),
and then write to the value property of its argument. (The action
label ais not relevant in this example.) The position of an action in
the path shows whether it appears in client code or in library code:
every argument read or write action corresponds to switching side,
as indicated by the →symbols. For this specific path, invoking
require( 'qs')and accessing its parse method happens in client
7Node.js libraries are loaded via the built-in require function, as shown in Section 1.
8Because of the introduction of the κlabels, NoRegrets +does not need to track the
number of arguments at calls as done by NoRegrets . The array access abstraction,
which is used in NoRegrets to model reads of array indices, is also not needed in
NoRegrets +. Instead the property read action .nis used where nis the array position
being read.
9https://www.npmjs.com/package/qscode, but reading the method argument and writing to its value
property happens in library code. Since the property write happens
on an object that comes from the client code, the value being writ-
ten by the library is visible on the client side, as indicated by the
last→symbol. We say that a path is covariant if the value described
by the path flows from library to client, corresponding to an even
number of→symbols, and contravariant in the opposite case.
A type t∈Type can be a standard JavaScript runtime type
(number ,boolean ,object , etc.), a Node.js specific type like stream
orevent-emitter , or the default type ◦which we use for paths that
do not belong to the library’s public API.
t::=◦|undefined|string|boolean|number|object|function
|array|set|map|event-emitter|stream|throws|prim
Unlike in NoRegrets , a type can also be a JavaScript primitive
value (denoted prim ), similar to how primitive values can be used as
types in TypeScript.10This extension is made because NoRegrets +
needs to reconstruct arguments for library functions in the type
regression testing phase.11We do not need traditional record types
or function types, because the different properties of an object or
parameters of a function are represented by different paths.
The second and third components of the model triple, σand
ρ, are new to NoRegrets +. The second component, σ, is a partial
mapσ:Path ,→Nthat associates a unique number with each
path pwhereπ(p),◦. It has the following property: for any two
paths pandp′,σ(p)<σ(p′)if and only if pis encountered before
p′in the model generation phase described below. This information
is needed by the testing phase to be able to invoke the library
functions in the same order as the client on which the model is
based, which we will later demonstrate in Example 4. For paths
that are encountered multiple times during the model generation,
we always use the observations from the first one.
The third component, ρ, is a binary relation ρof the form ρ⊆
Path×Path. This relation is used to track how values flow from
one path into another; for example, if a value returned by a library
function call, represented by the path p, is later passed back to the
library as an argument to a library function, where the argument
is represented by the path p′, then(p,p′)∈ρ.
Model generation To generate an API model (π,σ,ρ)of a given
library based on a collection of client test suites, NoRegrets +in-
struments the loaded module with ES6 proxies, runs the client test
suites, and records the interactions between the library and the
clients. The details of how this instrumentation works are explained
by Mezzetti et al . [15] , except for some straightforward adjustments
to accommodate our new variant of API models.
One of the adjustments involves extending the πcomponent
with a new path p. The type associated with pnow depends on the
variance of p: ifpis contravariant and the value vobserved at pis of
a primitive type t, thenvis used as the type instead of t. For example,
if the value is the string 'foo'andpis contravariant then the type
10https://www.typescriptlang.org/docs/handbook/advanced-types.html
11For readers who are familiar with NoRegrets :NoRegrets +does not use intersec-
tion types nor union types. NoRegrets uses intersection types to model JavaScript
prototype chains, however, for NoRegrets +to reconstruct the client arguments in
tests, it must know exactly on which object in a prototype chain a property resides,
so extended paths such as p.prototype are used instead to refer to the prototype of a
path p. Union types are used by NoRegrets to model polymorphic functions, but are
not needed in NoRegrets +since different calls are distinguished using the κlabels.Model-Based Testing of Breaking Changes in Node.js Libraries ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
p∈Path π(p)σ(p)
require(lib) object 1
require(lib).f function 2
require(lib).fa→arg0 true 3
require(lib).f()aobject 4
require(lib).fb→arg0 false 5
require(lib).f()bobject 6
require(lib).f()a.p number 7
require(lib).g function 8
require(lib).gc→arg0 object 9
require(lib).g()cnumber 10
other paths ◦ undefined
ρ={(require(lib).f()b,require(lib).gc→arg0)}
Figure 1: API model for Example 3.
is’foo’ , otherwise it is string . Thereby we ensure that the type
regression testing phase of NoRegrets +has values available for
library function arguments, and the model compression mechanism,
which we will describe shortly, is not restricted by too specific types.
Another adjustment involves extending the ρrelation whenever
a value flows from one path to another. In Example 2, the value
created by the bigInt call in line 20 represented by the path p3
flows into the argument of the modcall represented by the path p4,
resulting in(p3,p4)being added to ρ.
Example 3 For the following simplistic library and client,
NoRegrets +constructs the model shown in Figure 1.
27//library 'lib '
28module.exports.f = function (flag) {
29 if (flag) { return { p : 42}; }
30 else { return {}; }
31}
32module.exports.g = function (x) {
33 return 87;
34}
35//client test suite
36const lib = require( 'lib');
37const o1 = lib.f(true);
38const o2 = lib.f(false);
39assert(o1.p === 42);
40assert(lib.g(o2) === 87);
The client code loads the library lib, calls the fmethod with the
argument true and stores the result in o1, then it calls fwith the
argument false and stores the result in o2. Finally it checks that
o1.p is42and that lib.g called with o2as argument returns 87.
The paths and types of every operation taking place at the bound-
ary of the client and the library are recorded in π: the read of the f,
p, and gproperties, the two calls to f, the call to g, and finally the
argument reads at the three calls. Notice how the two calls to fare
distinguished using the labels aandbin the paths. If we were to
abstractly refer to both calls using just one path, then there would
be no way to determine if the pproperty should be present on the
return value only when fis called with the argument true, when it
is called with the argument false , or in both cases. The fact that
the argument passed to gis the value returned by the call to fin
line 38 is indicated by the single entry in ρ.
Model compression The action label κis used to distinguish
different calls to the same library function, as mentioned above.
Because of these labels, models may become much larger thaninNoRegrets if the same library function is called many times.
To mitigate this model size explosion problem, we add a simple
compression mechanism. The idea is to only include one call of a
polymorphic function for each of its possible return types since
that suffices for full coverage of the types. We first identify pairs
of paths q=p()aandq′=p()a′where qandq′are covariant
paths representing two calls to the same function only separated
by different labels, a,a′. If all paths s=qrands′=q′r, where r
is a sequence of actions that does not begin with an argument read
action, the types are equal, i.e. π(s)=π(s′), and sands′do not
appear inρ, then we remove qfrom the model and all paths that
have qas a prefix. Paths with an argument read action are skipped
because they are only used to synthesize arguments in the type
regression testing phase, so covering all argument types does not
increase the recall of NoRegrets +. Paths appearing in ρare not
removed since they may be needed as arguments to other functions.
5 PHASE II: TYPE REGRESSION TESTING
The key novelty of NoRegrets +is the use of model-based testing,
based on the automatically generated models. When the library
developer has obtained an API model of one version of a library and
later wishes to release an update, NoRegrets +uses the model to
perform a dynamic exploration of the updated library while testing
for type regressions relative to the model.
The dynamic exploration consists of two primary steps:
(1)For covariant paths pwhereπ(p),◦,NoRegrets +executes the
actions described by pand checks that the type of the resulting
value is compatible with the type π(p)as explained below.
(2)For contravariant paths pwhose actions happen to be executed
as a consequence of step 1, NoRegrets +checks that π(p),◦.
Intuitively, the first step corresponds to checking the types of
the values that are passed by the library to its client. For example, a
library method call that returned a string before the update should
not return a number after the update. The second step corresponds
to checking that the requirements of the values supplied by the
client to the library are not strengthened in the update. For example,
after the update, a library function should not read more properties
of an object that has been supplied by the client.
If any of the checks performed in these two steps fail, then it is
an indicator that the API of the library has changed in a way that
could be breaking clients.
API exploration In the type regression testing phase,
NoRegrets +mimics clients by performing the computations corre-
sponding to the actions of the covariant paths in the model. These
computations sometimes require values from other paths, which is
handled by a synthesis procedure described below.
Example 4 To call gin line 40 in Example 3, we first need to call
fas done in line 38 since its return value is used as argument to g.
It is common for paths to have shared prefixes, for example, all
paths in Figure 1 have require(lib)as a prefix. For such paths, the
value obtained for the prefix is reused for all of them, to ensure that
potential side-effects in the library functions are handled correctly.
To accommodate these requirements, NoRegrets +represents a
modelπas a treeτ. Every node xinτis a triple x=(px,Cx,vx)
consisting of a path px∈Path, a set Cxof child nodes, and aESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia Anders Møller and Martin Toldam Torp
JavaScript value vxthat is assigned when xhas been processed
as explained below. The tree has one node for each path pwhere
π(p),◦. A node xis child of x′ifpx=px′αfor some action α. In
the exploration of the API, NoRegrets +traversesτstarting at the
root, and when a node xhas been processed, the resulting value is
stored in the tree as vx. A child is never processed until its parent
has been processed. When NoRegrets +has to choose between
two nodes xandx′to process next, it picks xifσ(px)<σ(px′).
Thereby the nodes are processed in the same order as they were
added toπin the model generation phase.
In the process of exploring the API, NoRegrets +needs to con-
vert actions into their corresponding JavaScript operations. To pro-
cess a node xwhose parent is x′,NoRegrets +performs a pattern
match of pxand executes the associated operations:
require(n):Load the module by calling require( n).
p.n:Fetch the value vx′(corresponding to p) and read its nproperty.
p()κ:First, fetch the value vx′, which is the function to be called.
Next, construct the arguments. Each argument has its own node
xiwhose path is pxi=pκ→argi, which is a child of x′. The
argument at position iis constructed by invoking the synthesis
procedure described below for the node xi. Finally, invoke vx′
with the synthesized arguments to obtain the result value.
pnew()κ:Constructor call actions are processed exactly like call ac-
tions, apart from the function value being invoked as a con-
structor (with new).
p·n→:Invoke the synthesis procedure for xto produce a value,
and then write that value to the property nofvx′.
Paths ending in argument read actions are handled by the synthesis
procedure described next.
Synthesis of values The synthesis procedure is used above to
construct arguments for library function calls and to construct
values for writes to library objects. The procedure is invoked with a
node xas argument. If there exists a node x′such that(px′,px)∈ρ
then the desired value originates from an earlier interaction with
the library represented by a path px′, so the value vx′is returned.
Otherwise, we proceed according to the type π(px)ofx:
•If the type is a primitive value then that value is returned.
•If the type is object or one of the Node.js-specific types, then
NoRegrets +creates a new empty object and wraps it in a proxy
object, which is then returned. The purpose of the proxy is
twofold. If the proxy is later used as an argument to a function,
then that function might read one of its properties, q, in which
case the proxy looks for a node x′where px′=px.qamong the
children of x. Ifx′is found, then the proxy recursively invokes
the synthesis procedure with argument x′. Thereby, the prop-
erties of object arguments are constructed by need. If no node
is found, then the proxy reports a type regression indicating
that the library is now trying to read a property that it did not
previously read, cf. step 2. Writes by the library to the proxy are
handled similarly to calls from the library to client functions, as
described next.
•If the type is function then NoRegrets +creates a new function
fthat behaves as follows when called. If xhas a child x′in
τsuch that px′=px()a, i.e., that path ends in a call action,
then a value vx′forx′is obtained by a recursive call to the
synthesis procedure. This value is then used as the return valueoff. Furthermore, the API exploration mechanism described
above is invoked recursively on each argument passed to f. For
each argument at position i, the API exploration checks that
it recursively satisfies the type of xiwhere pxi=pxa→argi.
On the other hand, if no child of xwith a call action is found,
then NoRegrets +reports a type regression to indicate that a
previously uncalled callback is now being called, cf. step 2. The f
function is also wrapped in a proxy since functions can also have
properties, which may later be read if fis used as an argument.
Type checking During the API exploration, NoRegrets +checks
type compatibility of the values obtained for the covariant paths,
as mentioned above for step 1. If vis the value obtained through
the application of the actions of the covariant path p, thenvmust
satisfy type(v)<:π(p)where type(v)denotes the type of v. A vio-
lation of this property indicates a breaking change in the library’s
API at p. The subtyping relation <:expresses which type changes
are permitted. In particular, functions are subtypes of objects, i.e.
function <:object , since JavaScript functions are basically callable
objects. We also define t<:◦, meaning that everything is a sub-
type of◦, thereby permitting clients to read additional properties
of library supplied objects. The subtype relation additionally in-
cludes a few rules stating that some of the Node.js specific types
are subtypes of object and/or function .
For the contravariant paths in step 2, we do not use <:but simply
checkπ(p),◦as explained above, because the values represented
by such paths are generated by NoRegrets +, not by the library.
6 EVALUATION
As explained in Section 1, the overall goal of NoRegrets +is to
mitigate the scalability issues of NoRegrets . To assess how well
NoRegrets +reaches this goal, we conducted an experiment de-
signed to answer the following research questions.
RQ1 How many breaking changes does NoRegrets +detect com-
pared to NoRegrets in widely used Node.js libraries, specifically
those used in the evaluation of NoRegrets [15, Section 7]?
RQ2 How much faster is NoRegrets +, and how much space does
it require compared to NoRegrets when testing for breaking
changes in a library update?
RQ3 CanNoRegrets +find breaking changes in libraries with
fewer clients compared to NoRegrets ?
We omit a direct comparison with dont-break as it finds strictly
fewer breaking changes than NoRegrets [15].
6.1 Experimental Setup
We sampled 25npm packages from three segments of the npm
repository as listed in Table 1. The first five packages are among
the top 10 most depended upon npm packages and are also the
packages used in the evaluation of NoRegrets . Then we have a set
of 10 packages sampled around the top 100 most depended upon
packages, and a set of 10 packages sampled around the top 1000 most
depended upon package. The less depended upon packages have
fewer available clients with test suites, which both NoRegrets
andNoRegrets +need for API model generation, but all of the
packages are widely used. Most of them have more than 100 000
weekly downloads, so breaking changes in non-major updates canModel-Based Testing of Breaking Changes in Node.js Libraries ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
Table 1: Experimental comparison of NoRegrets+ vs.NoRegrets .
Benchmark NoRegrets+ NoRegrets
Name LOC Dependents Updates Clients Model size Coverage BC Clients Client size Coverage BC Speed-up
debug 2.0.0 154 26 146 19 504 46kB 50% 1 85 17 842 kB 47% 1 37.99x
async 2.0.0 1 682 26 699 5 398 1 247 kB 61% 7 70 28 365 kB 37% 3 6.34x
lodash 3.0.0 3 962 83 992 16 287 1 859 kB 65% 6 47 17 555 kB 29% 2 1.46x
moment 2.0.0 1 041 28 591 31 273 185kB 80% 7 4 10 591 kB 44% 2 5.45x
express 3.0.0 1 011 30 561 95 183 1 245 kB 41% 11 5 42 188 kB 43% 18 3.62x
mime 1.0.0 289 3 854 33 23 4kB 85% 0 4 25 950 kB 38% 1 3.85x
aws-sdk 2.0.1 4 821 9 223 606 27 7kB 26% 2 2 29 766 kB 20% 0 13.92x
mysql 2.0.0 3 476 4 052 34 111 184kB 55% 7 2 41 201 kB 49% 0 166.84x
joi9.0.0 3 724 5 606 35 409 1 611 kB 70% 6 1 94 296 kB 5% 0 17.44x
minimatch 1.0.0 660 3 239 13 415 167kB 73% 0 15 12 906 kb 43% 0 21.10x
autoprefixer 1.2.0 2 668 5 109 95 64 513kB 75% 10 1 12 026 kB 77% 1 5.92x
qs1.0.0 220 4 110 43 237 84kB 93% 14 0 N/A N/A 0 N/A
immutable 1.0.0 115 5 326 60 2 3kB 26% 2 0 N/A N/A 0 N/A
ora1.0.0 103 4 623 5 179 19kB 48% 0 0 N/A N/A 0 N/A
mongoose 1.0.0 2 105 6 137 474 52 19kB 30% 2 0 N/A N/A 0 N/A
big-integer 1.0.0 312 357 89 20 183kB 67% 1 0 N/A N/A 0 N/A
boxen 1.0.0 111 634 6 43 15kB 80% 0 0 N/A N/A 0 N/A
react-onclickoutside 4.0 69 516 46 11 0kB 0% 0 0 N/A N/A 0 N/A
d3-shape 1.0.0 1 528 449 11 38 739kB 26% 0 0 N/A N/A 0 N/A
webpack-stream 2.0.0 138 302 14 23 259kB 70% 1 0 N/A N/A 0 N/A
qiniu 1.2.0 219 254 38 14 3kB 28% 1 0 N/A N/A 0 N/A
koa-send 1.0.0 63 306 22 25 1kB 24% 2 0 N/A N/A 0 N/A
twilio 1.0.0 530 506 89 24 45kB 53% 1 0 N/A N/A 0 N/A
wreck 2.0.0 413 375 18 44 446kB 42% 0 0 N/A N/A 0 N/A
node-rest-client 1.0.0 354 316 17 29 289kB 39% 3 0 N/A N/A 0 N/A
Total 84 28
Arithmetic mean 367kB 52% 30 244 kB 25.8x
have severe consequences. We skipped packages whose newest
version was less than 1.0.0 since such packages are not required to
follow semantic versioning. We also skipped very small packages
with trivial APIs, such as is-stream andmake-dir , since their update
rate is low and their APIs are unlikely to change.
We selected the first major version of every package and applied
NoRegrets +andNoRegrets to every patch and minor update up
to the newest version (as of January 2019). For reasons discussed in
Section 7, NoRegrets +is able to use more clients than NoRegrets
when generating API models, however, when comparing the exe-
cution times of the two tools, we constrained NoRegrets +to use
the same set of clients as NoRegrets to ensure a fair comparison.
Because finding clients for many libraries is a time consuming pro-
cess, we limited the client retrieval phase to consider at most 2 000
packages. For NoRegrets , we built the API model only for the first
version, and then reused this model in the test of every update. The
execution time of NoRegrets +is measured as the time it takes to
execute the type regression testing phase, whereas for NoRegrets
it is the time it takes to generate the post-update model and com-
pare it with the pre-update model. In both cases, this reflects the
work done when testing a new update of a library for breaking
changes. The time required to generate a model is the same for the
two tools.
For every type regression reported by the two tools at minor
or patch updates, we manually inspected the type regression to
identify its cause and determine if it is an actual breaking change
(meaning that the type of some element of the library API has
changed) or a false positive. It is common for one breaking change
to result in multiple type regression warnings, for example, if the
return type changes for a function with many call actions then atype regression is reported for every call. Such related regressions
are easy to identify by their common structure, so we group them
and only count them as one breaking change.
6.2 Results and Discussion
We present the results of running NoRegrets andNoRegrets +on
the25benchmarks in Table 1. The columns contain left to right:
the benchmark name and the major version on which the testing
was started, lines of code in the initial version excluding tests, to-
tal number of direct dependents in npm, numbers of minor and
patch updates, the number of clients found by the client detec-
tion phase of NoRegrets +, the average NoRegrets +model size
per client, the statement coverage of NoRegrets +in the initial
benchmark version, the number of breaking changes (BC) found by
NoRegrets +, the number of clients found by the client detection
phase of NoRegrets , the average NoRegrets client size, the state-
ment coverage of NoRegrets in the initial benchmark version, the
number of breaking changes found by NoRegrets , and the average
speed-up ratio of NoRegrets +compared to NoRegrets . For both
tools, the reported numbers of breaking changes are only counting
true positives, and excluding duplicates with same root cause as
explained above.
RQ 1 Looking at the first 11rows, which are the benchmarks
where NoRegrets has a non-empty set of usable clients, we see that
NoRegrets +finds at least as many breaking changes as NoRegrets
for all benchmarks apart from mime andexpress .NoRegrets +de-
tects 84breaking changes, whereas NoRegrets only detects 28.
The breaking changes found by NoRegrets +include 11of those
found by NoRegrets . There are two reasons why the NoRegrets
breaking changes sometimes go undetected by NoRegrets +. First,ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia Anders Møller and Martin Toldam Torp
the clients used by NoRegrets are not necessarily a subset of the
clients used by NoRegrets +. The reason is that NoRegrets +will
always use the newest version of a client that has the library as
a dependency since it is more likely to utilize more of the library
than earlier versions, however, for reasons we describe in Section 7,
NoRegrets will always pick a version of the client that satisfies
the pre-update version constraint. Second, for some benchmarks
NoRegrets +is not able to synthesize values with enough preci-
sion to faithfully reconstruct the library-client interaction on which
the model is based. In our experiments, this situation occurs be-
cause the model generation phase of NoRegrets +uses ES6 prox-
ies to monitor the interaction between the client and the library,
but some values do not tolerate proxification well. For example,
ServerResponse objects, which are commonly used with the HTTP
library of Node.js, will crash Node.js if they are wrapped in proxies
at certain places in the HTTP library. Therefore, NoRegrets +must
avoid using proxies on such objects, which means that their exact
structure cannot by synthesized by NoRegrets +in the checking
phase, so NoRegrets +has to use default values instead. This prob-
lem is especially prevalent in the express benchmark since it uses
the HTTP library of Node.js extensively. (With a further implemen-
tation effort it might be possible to mitigate such problems; we plan
to investigate this in future work.)
In addition to the 84breaking changes detected by NoRegrets +,
the tool emitted 4false positives (not shown in the table). False
positives may appear due to, for example, the issues with the proxy
mechanism described earlier. Some of the correctly detected break-
ing changes are of course more serious than others; we show some
examples as case studies below.
In summary, NoRegrets +successfully detects more than twice
as many breaking changes compared to NoRegrets .
RQ 2 Looking at the speed-up column of Table 1, we see that
NoRegrets +on average runs the type regression testing phase 25x
faster than NoRegrets generates and checks the post-update model.
For some libraries, for example the debug library, NoRegrets +is
38x faster than NoRegrets , whereas for lodash the speed-up is only
1.46x. The relatively large difference in the speed-ups is explained
by various factors, for example, how much irrelevant code (non-
library code) is run by the client tests.
The actual time it takes to check an update for type regressions
naturally depends on the size of the generated model and the com-
plexity of the client test suites. The mean time it takes NoRegrets
to check an update on the 11benchmarks where clients are avail-
able is 96 seconds, compared to only 15 seconds for NoRegrets +.
Excluding the outliers lodash andasync ,NoRegrets +checks each
update in less than 6 seconds.
The numbers also show that NoRegrets +requires substantially
less space than NoRegrets . The average size of a library model
produced by NoRegrets +is367kB per client used for the model
construction, whereas NoRegrets requires 82x as much space.
In summary, NoRegrets +is more than an order of magnitude
faster than NoRegrets when testing a library update for breaking
changes, and it requires substantially less space to run, which makes
it feasible to use NoRegrets +in library integration test suites.
RQ 3 For the second segment of the benchmarks (i.e., the libraries
sampled around top 100), NoRegrets +finds breaking changes in 7out of 10 benchmarks, and for the third segment (i.e., the libraries
sampled around top 1000) it finds breaking changes in 6 out of
10 benchmarks. In comparison, NoRegrets only finds breaking
changes in 2 of the benchmarks from the second segment and in
none of the benchmarks in the third segment. This shows that
NoRegrets +scales much better for libraries with fewer clients.
For most libraries where NoRegrets +finds no type regressions,
the generated tests cover on average 50% of the statements in the
library, which provides some indication that those updates are in
fact non-breaking. One exception is react-onclickoutside where all
of the models generated by NoRegrets +are empty. That package
is a plugin for the browser UI library react , which means that it is
unlikely that any clients have automated tests that use it.
Case studies To give the some insight into the nature of the
breaking changes that NoRegrets +can detect, we describe some
representative examples.
Example 5 The qspackage is a library for parsing query strings.
As an example, qs.parse("p=foo") returns the object {p : "foo"} .
A special feature of the package is that it supports parsing of objects
where some on the properties are query strings that are parsed re-
cursively, for example, qs.parse({ 'a[b] ':'c'})returns the nested
objects {a : {b : "c"}} .
In the update of qsto version 2.2.1, a mistake was introduced
that resulted in the parse function sometimes overwriting exist-
ing properties on object arguments. This mistake is revealed by
NoRegrets +through a type regression on the path
p=require(qs).parsea→arg0·value→
whereπ(p)=◦but a value of type string is written in version 2.2.1.
For most cases this overwrite in benign because parse overwrites
the property with its existing value, however, specifically for buffers,
parse writes the result of calling toString on the buffer.
A well-known problem with semantic versioning is that it re-
quires a specification of the library’s API,12typically in the form of
documentation, such that a client knows exactly what the library
expects and what it produces, and this is often an unrealistic require-
ment [ 1]. Without such a specification, any change to the library
that breaks a client might as well be classified as the client not using
the library as the library developer intended. With NoRegrets +,
we assume that the clients used in the model generation phase
adhere to the library’s specification. For clients where this is not
the case, NoRegrets +may produce type regressions, which the
library developer could rightly classify as caused by incorrect usage
of the library. Nevertheless, we still believe that such warnings can
be beneficial, since they may point to ambiguities and underspeci-
fied points in the documentation; each such warning reveals that a
client developer has misunderstood the specification.
Example 6 The async package is a widely used library that pro-
vides a large set of utility functions for working with asynchronous
functions. One of these functions is each, which takes a collec-
tion (typically an array), an asynchronous iterator function, and a
callback function as arguments. It then asynchronously runs the
iterator on every element in the collection, eventually calling the
12“Software using Semantic Versioning MUST declare a public API” — rule 1 of the
SemVer specification, https://semver.org/ .Model-Based Testing of Breaking Changes in Node.js Libraries ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
callback when the iteration is done. The iterator function also takes
a callback, which it can call with any argument to signal an error,
which in turn calls the callback of each with the error value. A
typical use of the each function is demonstrated by the following
example where the client asynchronously performs some computa-
tion on an array of files.
41async.each([ 'file1.txt ','file2.txt '],
42 function(file, cb) {
43 var err = ... //async operation
44 if (err) { cb(err) }
45 cb();
46 },
47 function(err) {
48 console.log("error processing files");
49 });
In the update of async from version 2.0.0 to 2.0.1, the each func-
tion was changed slightly to improve its performance when the
collection is an array. While this update is non-breaking when the
iterator function is asynchronous, it unfortunately changed the
behavior of each when the iterator is synchronous. In version 2.0.0
when a synchronous iterator function calls its callback with an
error value, the each call is directly terminated potentially leaving
some elements in the array uniterated. However, in version 2.0.1 the
iteration is not terminated on an error, so all elements will always
be processed. This breaking change is detected by NoRegrets +as
a type regression on the path
require(async).eacha→arg0.1
which refers to the element at index 1 in the array passed to the
each call. The model states that this path is not read, nevertheless,
NoRegrets +detects a read of this path in version 2.0.1 resulting
in a type regression being reported. Upon inspection of this type
regression, we find that the iterator function fails when processing
the first element of the array, but that does not stop each from
also beginning the processing of the second element and thereby
causing the unexpected read.
Notice that this can only break clients that use each with syn-
chronous functions, which is not allowed according to the async
specification. However, due to either a misunderstanding of the
specification or a general lack of knowledge of how asynchrony
works in Node.js, many clients use async with synchronous func-
tions. A search for “ RangeError: Maximum call stack size exceeded ”,
which is an error caused by the incorrect use of synchronous func-
tions, on async ’s issue tracker results in no less than 22results.
Furthermore, the first point in the “Common pitfalls” section of
theasync documentation page mentions the use of synchronous
functions as a pitfall.13
This example demonstrates that library developers may benefit
from warnings reported by NoRegrets +even in situations where
the changed library behavior is intended by the library developer,
because many clients fail to follow the library specification and are
thereby affected by the change.
While most type regressions reported by NoRegrets +are true
positives, some of them are unlikely to cause problems in practice if
the library developer is cautious, as demonstrated by the following
example.
13https://caolan.github.io/async/Example 7 The joipackage is a schema validation library, which
can be used to validate that objects and strings have a certain struc-
ture. Specifically, joihas a method urithat returns a schema object
for validating that strings are valid RFC3986 URIs. The urimethod
takes a configuration object argument, specifying for example that
only URIs of certain schemes are allowed:
50var v = joi.string().uri({ scheme : 'http '})
51v.validate( 'http://foo.bar ').error // => null
52v.validate( 'https://foo.bar ').error // => ValidationError
In version 13.5.0, a new optional property allowQuerySquareBrackets
was introduced. Setting this property to true configures the schema
object such that URIs with square brackets in query variables are
allowed. NoRegrets +reports a type regressions for this change,
because joireads the path
require(joi).string()a.urib→arg0.allowQuerySquareBrackets
in version 13.5.0, although the model states that no read should
occur on it. However, the developers of joiwere careful enough to
introduce this change such that no existing clients were impacted.
If a client does not supply the allowQuerySquareBrackets property,
then joiwill automatically assume it is false to preserve the old
behavior for existing clients. This means that although the library
API has changed in a way that could in principle break clients, the
type regression is most likely benign.
Even for type regressions that are benign as in Example 7, the
library developers may benefit from the warnings provided by
NoRegrets +. The warnings point the library developers to parts
of the API where extra care must be taken to ensure backward
compatibility and communicate to the client developers that the
newly added properties like allowQuerySquareBrackets may conflict
with existing properties in the client objects.
7 RELATED WORK
Our approach builds on the recent work by Mezzetti et al . [15] , but
the challenge of detecting breaking changes in libraries also appears
with other programming languages, and there are also connections
to other testing techniques, in particular model-based testing.
Studies of breaking changes in library updates Breaking
changes are common across languages and ecosystems [ 15,17,19].
According to Mezzetti et al . [15] , at least 5% of JavaScript packages
they studied have experienced a breaking change in a non-major
update, and that the majority of the breaking changes are due
to type-related issues. Brito et al . [3] conducted a study on why
and how Java developers intentionally break APIs, concluding that
the primary reasons are to add new features (32%), simplify the
API (29%), and improve maintainability (24%). Zerouali et al . [20]
showed that using strict version number constraint results in slow
adoption of security critical updates. Many developers want to
adopt semantic versioning, but do not trust that their dependencies
adhere to the guidelines [1].
The study by Gyori et al . [7]used client test suites to detect break-
ing changes in library updates, similar to the dont-break methodol-
ogy mentioned in Section 1 but for Java. They note that it is common
practice in industry to use this form of testing, but also that apply-
ing certain test case selection criteria could yield a considerable
speed-up while preserving coverage, similar to how NoRegrets +
avoids running all the client test suites at every library update.ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia Anders Møller and Martin Toldam Torp
Tools for JavaScript To our knowledge, only the two tools
NoRegrets anddont-break exist for detecting breaking changes in
JavaScript libraries; the relations between NoRegrets +and those
tools are explained in detail in the preceding sections.
Like NoRegrets +,NoRegrets also looks for type regressions
in Node.js library updates, but it instead generates models for both
the pre-update and the post-update version of the library, and then
compares the models to identify type regressions [ 15]. Because
NoRegrets needs to compute a model twice to check an update, it
is important that the clients’ dependency constraints on the library
is within the same major number as the pre-update version of the
library. As an example of why this is important, consider the case
where a library lis at version 2.0.0and the library developer wants
to check some changes for type regressions before releasing 2.1.0.
IfNoRegrets now picks a client cthat depends specifically on
version 1.0.0ofl, then cexpects lto expose an API that might
be considerably different from the API in 2.0.0. Ifldeprecated a
functionдin version 2.0.0and the developer now plans to remove
it entirely in version 2.1.0, then if the client uses this function, it
will crash with version 2.1.0, which will result in a quite differ-
ent model and therefore also many type regressions. One of these
type regressions will correctly state that дwent from function to
undefined , but the rest of them are false positives caused by the
premature termination of the client. In contrast, NoRegrets +is
able to continue testing of the library even if a type regression that
would have crashed the client is detected. This difference allows
NoRegrets +to use a larger set of clients and thereby produce
better API models.
Tools for other programming languages For other languages
than JavaScript, there are numerous tools that help library develop-
ers detect breaking changes. Common to all these tools is that they
work for statically typed languages and rely on explicitly typed
library APIs, which make it much easier to detect type-related
breaking changes than for dynamically typed languages. For Java
there is APIDiff [ 2], Clirr,14japicmp,15SigTest,16and Revapi.17
The Elm package manager (elm-package) promises to automatically
enforce semantic versioning, although it is also limited to detecting
type-related breaking changes.
For a dynamically typed language like JavaScript, the public
API of a library is not easily identifiable statically, which is why
we resort to the use of dynamic analysis for the model generation
phase. JavaScript library developers can choose to write TypeScript
declarations that define the public APIs of their libraries. However,
declaration files are often full of errors and rarely kept up-to-date
making them unsuitable for breaking change detection [12].
A problem related to breaking change detection is how to update
clients when their libraries evolve, also called collateral evolution.
As an example, the Coccinelle tool [ 16] has been designed to support
Linux developers in this respect, but it does not help the developers
determine if and where breaking changes are introduced.
14http://clirr.sourceforge.net/
15http://siom79.github.io/japicmp/
16http://wiki.netbeans.org/SigTest
17https://revapi.org/Model-based testing and related techniques Our approach
can be seen as a form of model-based testing [ 18]. InNoRegrets +,
the models are inferred automatically based on dynamic analysis
of client usage.
The SCARPE tool by Joshi and Orso [10] uses a capture phase
that generates a model of a software component based on live
executions, and a replay phase that can produce regression tests
from the model. This is reminiscent of how Krikava and Vitek [11]
produce tests for CRAN packages written in R, based on executing
the small snippets of executable example code that is often included
in the documentation of such packages. In comparison with those
techniques, we use the test suites of the client packages to obtain
realistic executions of the library.
The techniques by McCamant and Ernst [ 13,14] construct log-
ical models of software components written in C by dynamically
inferring likely invariants. Incompatibilities at component upgrades
can then be detected by comparing the models using an automatic
theorem prover.
The idea of extracting new tests from existing tests also appears
in the test carving technique by Elbaum et al . [5], which aims to
generate effective differential unit tests from existing system tests.
In comparison, NoRegrets +exploits the fact that the test suite of
a client of a library often indirectly functions as a system test of
the library, which makes it possible to generate useful regression
tests from existing client test suites.
8 CONCLUSION
Breaking changes in libraries are a major concern for JavaScript
developers. For Java, the static type checker helps detecting such
issues when building an application with a new version of a library,
but due to the dynamic nature of JavaScript, breaking changes are
rarely discovered before failures appear at run-time. Type regres-
sions are a kind of breaking changes that manifest as incompatible
changes in the types of the method parameters, return values, and
object properties that constitute the API of a library. Previous work
has shown that type regressions account for many breaking changes
in widely used JavaScript libraries. The NoRegrets tool introduced
the concept of type regression testing for detecting such issues
automatically, but it is inefficient and inadequate for libraries with
relatively few clients.
By taking a model-based testing approach, our tool NoRegrets +
creates tests from a model of the library API, all fully automatically.
As shown in our experimental evaluation, this new approach is sig-
nificantly more efficient and capable of finding many more breaking
changes, especially in libraries with fewer available clients.
With such tool support, it is our hope that JavaScript library
developers can make more informed decisions when releasing up-
dates and using semantic versioning. The experiments have also
demonstrated that there is room for improvement of the technique,
especially concerning the use of proxies in the model generation
phase, which we plan to pursue in future work.
ACKNOWLEDGMENTS
This work was supported by the European Research Council (ERC)
under the European Union’s Horizon 2020 research and innovation
program (grant agreement No 647544).Model-Based Testing of Breaking Changes in Node.js Libraries ESEC/FSE ’19, August 26–30, 2019, Tallinn, Estonia
REFERENCES
[1]Christopher Bogart, Christian Kästner, and James D. Herbsleb. 2015. When
It Breaks, It Breaks: How Ecosystem Developers Reason about the Stability of
Dependencies. In 30th IEEE/ACM International Conference on Automated Software
Engineering Workshops, ASE Workshops 2015, Lincoln, NE, USA, November 9-13,
2015. IEEE Computer Society, 86–89.
[2]Aline Brito, Laerte Xavier, André C. Hora, and Marco Tulio Valente. 2018. APIDiff:
Detecting API breaking changes. In 25th International Conference on Software
Analysis, Evolution and Reengineering, SANER 2018, Campobasso, Italy, March 20-
23, 2018 . IEEE Computer Society, 507–511.
[3]Aline Brito, Laerte Xavier, André C. Hora, and Marco Tulio Valente. 2018. Why
and how Java developers break APIs. In 25th International Conference on Software
Analysis, Evolution and Reengineering, SANER 2018, Campobasso, Italy, March 20-
23, 2018 . IEEE Computer Society, 255–265.
[4]Danny Dig and Ralph E. Johnson. 2006. How do APIs evolve? A story of refac-
toring. Journal of Software Maintenance 18, 2 (2006), 83–107.
[5]Sebastian G. Elbaum, Hui Nee Chin, Matthew B. Dwyer, and Jonathan Dokulil.
2006. Carving differential unit test cases from system test cases. In Proceedings
of the 14th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, FSE 2006, Portland, Oregon, USA, November 5-11, 2006 . ACM, 253–
264.
[6]Darius Foo, Hendy Chua, Jason Yeo, Ming Yi Ang, and Asankhaya Sharma.
2018. Efficient static checking of library updates. In Proceedings of the 2018 ACM
Joint Meeting on European Software Engineering Conference and Symposium on
the Foundations of Software Engineering, ESEC/SIGSOFT FSE 2018, Lake Buena
Vista, FL, USA, November 04-09, 2018 . ACM, 791–796.
[7]Alex Gyori, Owolabi Legunsen, Farah Hariri, and Darko Marinov. 2018. Eval-
uating Regression Test Selection Opportunities in a Very Large Open-Source
Ecosystem. In 29th IEEE International Symposium on Software Reliability Engi-
neering, ISSRE 2018, Memphis, TN, USA, October 15-18, 2018 . IEEE, 112–122.
[8]Kamil Jezek and Jens Dietrich. 2017. API Evolution and Compatibility: A Data
Corpus and Tool Evaluation. Journal of Object Technology 16, 4 (2017), 2:1–23.
[9]Kamil Jezek, Jens Dietrich, and Premek Brada. 2015. How Java APIs break - An
empirical study. Information & Software Technology 65 (2015), 129–146.
[10] Shrinivas Joshi and Alessandro Orso. 2007. SCARPE: A Technique and Tool for
Selective Capture and Replay of Program Executions. In 23rd IEEE International
Conference on Software Maintenance (ICSM 2007), October 2-5, 2007, Paris, France .
IEEE, 234–243.[11] Filip Krikava and Jan Vitek. 2018. Tests from traces: automated unit test ex-
traction for R. In Proceedings of the 27th ACM SIGSOFT International Symposium
on Software Testing and Analysis, ISSTA 2018, Amsterdam, The Netherlands, July
16-21, 2018 . ACM, 232–241.
[12] Erik Krogh Kristensen and Anders Møller. 2017. Type test scripts for TypeScript
testing. PACMPL 1, OOPSLA (2017), 90:1–90:25.
[13] Stephen McCamant and Michael D. Ernst. 2003. Predicting problems caused
by component upgrades. In Proceedings of the 11th ACM SIGSOFT Symposium
on Foundations of Software Engineering 2003 held jointly with 9th European Soft-
ware Engineering Conference, ESEC/FSE 2003, Helsinki, Finland, September 1-5,
2003. ACM, 287–296.
[14] Stephen McCamant and Michael D. Ernst. 2004. Early Identification of Incom-
patibilities in Multi-component Upgrades. In ECOOP 2004 - Object-Oriented Pro-
gramming, 18th European Conference, Oslo, Norway, June 14-18, 2004, Proceedings
(Lecture Notes in Computer Science) , Vol. 3086. Springer, 440–464.
[15] Gianluca Mezzetti, Anders Møller, and Martin Toldam Torp. 2018. Type Regres-
sion Testing to Detect Breaking Changes in Node.js Libraries. In 32nd European
Conference on Object-Oriented Programming, ECOOP 2018, July 16-21, 2018, Am-
sterdam, The Netherlands (LIPIcs) , Vol. 109. Schloss Dagstuhl - Leibniz-Zentrum
fuer Informatik, 7:1–7:24.
[16] Yoann Padioleau, Julia L. Lawall, René Rydhof Hansen, and Gilles Muller. 2008.
Documenting and automating collateral evolutions in Linux device drivers. In
Proceedings of the 2008 EuroSys Conference, Glasgow, Scotland, UK, April 1-4, 2008 ,
Joseph S. Sventek and Steven Hand (Eds.). ACM, 247–260.
[17] Steven Raemaekers, Arie van Deursen, and Joost Visser. 2017. Semantic versioning
and impact of breaking changes in the Maven repository. Journal of Systems and
Software 129 (2017), 140–158.
[18] Mark Utting, Alexander Pretschner, and Bruno Legeard. 2012. A taxonomy of
model-based testing approaches. Softw. Test., Verif. Reliab. 22, 5 (2012), 297–312.
[19] Laerte Xavier, Aline Brito, André C. Hora, and Marco Tulio Valente. 2017. His-
torical and impact analysis of API breaking changes: A large-scale study. In IEEE
24th International Conference on Software Analysis, Evolution and Reengineering,
SANER 2017, Klagenfurt, Austria, February 20-24, 2017 . IEEE Computer Society,
138–147.
[20] Ahmed Zerouali, Eleni Constantinou, Tom Mens, Gregorio Robles, and Jesús M.
González-Barahona. 2018. An Empirical Analysis of Technical Lag in npm Pack-
age Dependencies. In New Opportunities for Software Reuse - 17th International
Conference, ICSR 2018, Madrid, Spain, May 21-23, 2018, Proceedings (Lecture Notes
in Computer Science) , Vol. 10826. Springer, 95–110.