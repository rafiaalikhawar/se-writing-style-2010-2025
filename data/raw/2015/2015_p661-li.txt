String Analysis for Java and Android Applications
Ding Li, Yingjun Lyu, Mian Wan, William G. J. Halfond
University of Southern California
Los Angeles, California, USA
{dingli, yingjunl, mianwan, halfond}@usc.edu
ABSTRACT
String analysis is critical for many verication techniques.
However, accurately modeling string variables is a challeng-
ing problem. Current approaches are generally customized
for certain problem domains or have critical limitations in
handling loops, providing context-sensitive inter-procedural
analysis, and performing ecient analysis on complicated
apps. To address these limitations, we propose a general
framework, Violist, for string analysis that allows researchers
to more exibly choose how they will address each of these
challenges by separating the representation and interpreta-
tion of string operations. In our evaluation, we show that
our approach can achieve high accuracy on both Java and
Android apps in a reasonable amount of time. We also com-
pared our approach with a popular and widely used string
analyzer and found that our approach has higher precision
and shorter execution time while maintaining the same level
of recall.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging
General Terms
Algorithms
Keywords
String analysis, mobile apps
1. INTRODUCTION
Strings play an important role in modern software. The
server side of modern web applications may use strings to
output HTML content and make SQL queries to databases,
while the client side may process string-based user input
and send it to the server-side via various string-based pro-
tocols. Mobile apps may generate string-based HTTP re-
quests to cloud-based servers, and even large scale systems,such as Distributed Event-Based (DEB) systems, may pass
messages whose attributes are represented as strings. By
analyzing these strings and determining their possible val-
ues, engineers can better understand an application's po-
tential runtime behaviors. For example, string analysis has
been used to detect SQL injection attacks [19, 38, 39, 14],
prevent Cross-Site Scripting attacks [24, 40], detect errors
in HTML output [29, 21], optimize energy consumption of
mobile web apps [26], improve penetration testing [22], and
understand the runtime behavior of DEB systems [15, 30].
Inaccurate string analysis can reduce the eectiveness of
these approaches. For example, an imprecise string analy-
sis can lead to the identication of less energy-ecient color
schemes (i.e., [26]); and an unsafe string analysis could miss
possible vulnerabilities (e.g., [40]).
Despite their widespread use and importance, accurately
analyzing strings remains a signicant challenge due to sev-
eral issues: (1) how to analyze string values generated in
(possibly nested) loops that may include loop carried data
dependencies, (2) context-sensitivity for strings manipulated
and composed inter-procedurally, (3) exibility to attach
dierent semantics to string operations, and (4) scalability
to handle long strings or strings manipulated using a com-
plex series of operations. Existing techniques that use string
analysis have mainly side-stepped these challenges by clev-
erly leveraging aspects of their problem domain to simplify
the required string analysis. The result is these key chal-
lenges for the analysis of strings have not been adequately
addressed.
Existing work related to string analysis can be broadly
described as either performing string analysis in support
of another software engineering goal or directly providing
a string analysis technique. Approaches that fall into the
rst category include those for approximating HTML out-
put (e.g., [29, 21]), computing possible SQL queries (e.g., [19,
38, 39, 14]), and identifying messages passed in DEB sys-
tems [15]. These approaches have often not needed to ad-
dress key challenges in string analysis due to aspects of
their problem domains. For example, to optimize display
energy [26], it was sucient to assume that loops were un-
raveled once. The result of leveraging these domain-specic
insights is that the developed techniques are not generaliz-
able, since assumptions that work for one problem domain
may not be appropriate for others. This has implications
for the research community as each group that wants to de-
velop techniques that need string analysis must essentially
start from scratch.
More generalizable techniques have also been proposed
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE‚Äô15 , August 30 ‚Äì September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...$15.00
http://dx.doi.org/10.1145/2786805.2786879
661(e.g., [9, 41]). However, these have trade-os in how they
handle the four challenges, which makes them less broadly
applicable. For example, JSA [9] uses global alias analysis to
model inter-procedural manipulation of strings, which, as we
show in Section 4, leads to scalability problems when analyz-
ing Android applications that include extensive invocations
of framework APIs. Yu and colleagues [41] proposed a Fi-
nite State Automata (FSA) based Widen operation, which
can partially solve the rst challenge, but is not able to han-
dle nested loops. Symbolic execution based techniques can
more precisely address challenges 1, 2, and 3. However, these
techniques may not scale for large programs and may make
simplifying assumptions about the strings under analysis.
The goal of the work presented in this paper is to present a
general framework for string analysis that allows researchers
to more exibly choose how they will address each of the
four challenges. Our key insight into how to do this is to
separate the representation and interpretation of string op-
erations. Our string analysis framework, Violist, denes an
Intermediate Representation (IR) that faithfully represents
the string operations performed on an application's string
variables. Violist's IR is designed to accurately capture com-
plex data-ow dependencies in loops and context-sensitive
call site information. Violist also allows for the straight-
forward integration of IR interpreters that can implement
the user's necessary interpretation of the string construc-
tion semantics. For example, it is straightforward to write
an interpreter that will unravel loops once, ntimes, or ap-
proximate an upper bound for innite unraveling. Finally,
Violist can easily scale up and analyze large programs.
To evaluate the usefulness and eectiveness of our frame-
work, we carried out an extensive empirical evaluation. For
the evaluation, we implemented two dierent IR interpreters
and used these to compare the accuracy and scalability of
Violist against the popular Java String Analyzer (JSA) [9].
For this evaluation, we used a mixture of publicly available
benchmarks, systematically created test cases to mimic dif-
ferent data and control ows, and real-world Java and An-
droid applications. Our results showed that Violist is able to
generate results that, on average, are more precise than JSA
while maintaining the same level of recall. Furthermore, Vi-
olist was able to generate these results for a wider range of
applications and to do this faster than JSA.
2. MOTIVATION
In this section, we provide a motivating example (Pro-
gram 1) to illustrate the four challenges mentioned in Sec-
tion 1.
2.1 Loops
Consider a string analysis that targets the variable cat
line 19 (c19). This variable is redened in each iteration of
the loop at lines 17{21. Although the upper bound on the
loop can be trivially identied via inspection, in general, it is
challenging for a static string analysis to accurately account
for the loop's upper bound. Therefore, many techniques
(e.g., [9]) simply assume the loop will be executed an in-
nite number of times or unrolled only once (e.g., [29, 26]).
Even techniques that do model loops are generally unable to
model the relationship of nested loops, an example of which
is shown at lines 27{35. Nested loops are more challenging
to analyze, because it is necessary to model the relationship
of the strings in the inner and outer loops (e.g., dande).1class Examplef
2public static String addA(String v)
3f
4 return v+"A";
5g
6public static String replaceA(String v)
7f
8 return v.replaceAll( "A","B");
9g
10 public static void main(String[] args)f
11 String a= "a";
12 String b=addA(a);
13 b=addA( "b");
14 System.out.println(b);
15 String c= "A";
16 String f= "";
17 for(inti=0;i<3;i++)
18f
19 c=c+ "A";
20 f=f+c;
21g
22 c=replaceA(c);
23 c=replaceA( "AAAA" );
24 System.out.println(c);
25 String d= "";
26 String e= "";
27 for(inti=0;i<3;i++)
28f
29 d=d+e;
30 System.out.println(d);
31 for(intj=0;j<1;j++)
32f
33 e=e+ "b";
34g
35g
36g
37g
Program 1: Example program
Techniques based on the Widen approach for approximating
loops ([41, 8, 5]) would not be able to handle this scenario.
Many ow-based techniques would simply model this as one
large loop, which is safe, but reduces precision.
2.2 Context-Sensitivity
Next, consider a string analysis that includes string ma-
nipulations that are carried out inter-procedurally. An ex-
ample of this is in method main at lines 12 and 13, which
calls the method addA. Many string analyses handle this sort
of invocations without any call site context sensitivity (e.g.,
[41, 9]). This means that when analyzing the values at lines
12 and 13, these analyses will assume that the return value
can be based on the arguments provided at any call sites
toaddA. Using the example, this means that the value of b
at lines 12 and13 would be approximated as f\aA";\bA"g
instead of \ aA" for line 12 and \ bA" for line 13. As with
handling of loops, this approach is safe, but loses precision
as extra possible string values would be returned as a possi-
ble value of the variable b. The reason this occurs is that the
analyses use a global data ow analysis, which is, in turn,
based on the call graph of the application. This representa-
tion of the inter-procedural control-ow results in a lack of
context-sensitivity. Techniques that use symbolic execution
do not face this problem, but may require SMT problem
solving and need to analyze all possible paths of a program,
which can make it dicult to scale the techniques for large
programs.
2.3 Flexible Semantics
A general limitation of many string based approaches is
that they are tightly tied to one specic method of inter-
preting string values. For example, JSA [9] approximates
loops as having an innite upper bound, both D-model [29]
and the string analysis underpinning Nyx [26] assume loops
are unraveled once. Beyond that many string analyses are
highly customized to make approximations in ways that are
appropriate for their problem domains, but that limit their
662general applicability. For researchers and software engineers
who are attempting to leverage string analysis, it is gener-
ally necessary to develop their own string analysis to be used
for their project. This can be a signicant barrier to entry
and to the success of the project.
2.4 Scalability
Lastly, symbolic execution techniques could be used to
address the context-sensitive problem. However, these tech-
niques may not scale easily for large programs. To im-
prove scalability, symbolic execution techniques may assume
strings are bounded in length (e.g., no longer than 8 charac-
ters), which limits the techniques' general applicability, or
model strings as sequences of characters, which cannot ade-
quately represent the semantics of certain string operations,
such as replaceAll .
3. APPROACH
Our approach provides a general framework for string
analysis. This framework allows for the development of
customized string analyses that vary in terms of recall and
precision in how they handle loops, context sensitivity, and
string operation semantics. To build this framework, we
designed an approach that separates the representation of
the string operations from their interpretation. This separa-
tion allows all string analyses to share a common underlying
string model, yet attaches dierent semantics to the mod-
eled instructions. Our approach can be dened as having
two general phases. In the rst, the approach builds a model
of the string operations in the Program Under Test (PUT),
and then in the second, applies a custom interpreter to the
model that implements the desired string operation seman-
tics.
To model the string operations, we dene an IR that cap-
tures the data ow dependencies between string variables
and string operations. The IR can be computed for any code
that can be represented in a Static Single Assignment (SSA)
form, for which translations exist for most mainstream lan-
guage (e.g., Java, Dalvik, and PHP). In addition, the IR
also includes operations that allow it to represent strings
dened externally to the block of code (e.g., method param-
eters) and data dependencies caused by loops. We dene
the details of the IR in more depth in Section 3.1.
In the rst phase, our approach analyzes the PUT and
computes an IR-based summary for each of its methods.
Within each method, the approach uses a region-based anal-
ysis to identify code enclosed by (possibly nested) loops
and then specially models the data dependencies caused by
loops. In the second phase, our approach translates the IR-
based summaries into a string representation. To do this,
our framework allows a user to supply an interpreter of their
choice that implements the desired semantics with respect
to string operations, loops, and context sensitivity. As part
of the evaluation, we implemented two such interpreters, one
that models the strings as FSAs (as is done in JSA [9]) and
the second that carries out an n-bounded loop unraveling
for all loops in the PUT. The interpreters also allow the
users to leverage additional analyses, such as alias analysis,
that can more precisely identify loop upper bounds, include
domain-specic knowledge, or resolve other constraints.
3.1 The Intermediate Representation
We dene an IR that represents the control and data owrelationships among the string variables and string opera-
tions in a program. The goal of the IR is to precisely model
these relationships while deferring any sort of interpreta-
tion or approximation of these relationships until the sec-
ond phase. Our IR specically targets control and data ow
relationships that have traditionally complicated the mod-
eling and interpretation of strings. Namely, strings dened
external to the analysis scope, strings constructed within
(possibly nested) loops, and inter-procedural string manip-
ulation.
Our IR is structured as a tree with the leaf nodes den-
ing either string constants or placeholders for unknown vari-
ables. The internal nodes in the IR tree are string expres-
sions that represent the values of string variables in the PUT.
For explanatory purposes in the paper, we will represent ex-
pressions in the IR tree as ( op a 1;a2;:::::), whereopis the
operation of the expression and airepresents the various ar-
guments to op. We write the denition of a variable in the
form ofvl, wherevis the source-code based name of the vari-
able andlis the line number of the denition. To illustrate,
line 13 of Program 1 is represented as b13= (addA \b").
In cases where a variable is dened outside of the scope of
the analysis (e.g., method parameters), our approach leaves
placeholders in the IR. A placeholder variable is denoted by
the subscript notation of \ Xn" whereXis a xed symbol
andnis a number, unique within the analysis scope, iden-
tifying the external variable. For example, consider line 4
of Program 1, the IR for this line is (+ vX4\A"). These
placeholders are preserved until they can be resolved. For
example, in this case the IR of line 4 becomes the method
summary for addA . Whenever a call site for addA is encoun-
tered, say at line 13, the argument can be provided for the
placeholders. Placeholders also allow additional analysis to
be employed by the interpreters to resolve strings that may
originate from les or database queries.
Our approach denes several IR operators to model the
eects of loops. The rst of these is , which is used to
represent string variables whose values are partly dened via
a loop carried data dependency. The form of this operator
is (T
v:r(exp)). Herevis the name of the variable dened
in the loop; ris the ID of the loop (our approach numbers
each loop region, as explained in Section 3.3); Trepresents
the number of the loop iterations, with T= 0 denoting the
initial value of a variable in a loop and T= 1 denoting the
value of a variable after one iteration; and expis the IR
expression that contains vin the loop. Note that expmay
contain additional expressions, which enables nested loops
to be easily modeled. Within exp, the dened variable vis
represented using the symbol T0
v:r.
To illustrate, consider the variable e33in Program 1. Equa-
tion (1) shows the value of e33for thekthiteration.
(k
e33:R2(+k 1
e33:R2\b")) (1)
This equation shows that the value of eat line 33 is equal
to the concatenation of its value from the previous iteration
and the constant string " b". Here, the identier \ R2" refers
to the loop region ID, which we will explain in more detail
in Section 3.3.
The nal loop related operator is . Theexpression
has the same format as the expression, but denotes a de-
pendency between self-referring variables in the same loop
instead of a nested loop dependency. Here, we dene \self-
663referring variable" as a variable that denes itself, at least
in part, via a loop carried dependency. The expressions
are always sub-expressions of the expressions. When a 
expression is used, it represents that the variable of the 
expression depends on the variable of the expression and
both of them are from the same loop.
To make this clear, we take the example at line 19 and
line 20 in Program 1. In our example, both c19andf20
are self-referring variables from the same loop and c19is
used to dene f20. The IR of f20is shown in Equation (2),
where the underlined portion refers to the value of c19, which
shows how the value of f20depends on the value of c19. In
this expression, the superscript of 0 means the value of the
variable in the current iteration and  nmeans the value n
iterations prior.
f20= (0
f20:R3(+ 1
f20:R3(+ ( 1
c19:R3(+ 2
c19:R3\A"))\A")))
(2)
We introduce the symbol because the dependency be-
tween self-referring variables in the same loop is dierent
from the dependency due to nested loops. We compare the
value off20in Equation (2) to the IR of d29in Equation (3).
In the IR of d29, the underlined portion refers to the value of
e33, which is generated in a loop dierent from that of d29.
On the contrary, in the IR of f20, the underlined portion
refers toc19, which is a variable from the same loop of f20.
d29= (0
d29:R1(+ 1
d29:R1( 1
e33:R2(+ 2
e33:R2\e")))) (3)
3.2 Interpretation of the Intermediate Repre-
sentation
The interpretation step converts the IR of string variables
into a representation of strings. Our framework allows users
to provide an interpreter that translates the IR as needed
for dierent analysis problem. To do this, a user would
need to implement two things: (1) the string model for each
string operation (e.g., append and trim); And (2) a Widen
andConverge function for the expressions. Here, Widen
is used to generalize the expression on each iteration to
make the string values converge quicker. For example, one
instance of Widen proposed by Yu and colleagues [41] can
generalize string set f\a";\aa";\aaa"gto the regular ex-
pressiona+.Converge is used to judge when the approach
should terminate iterating over the expression.
The general process for IR interpretation is as follows.
First, our approach uses the target string models to repre-
sent all leaf nodes in the IR that are string constants and
external inputs. Second, our approach calculates the value
of each non-leaf node using a postorder traversal of the IR
tree. During this calculation, our approach uses the specied
string operation semantics to calculate the value of each IR
operation. Third, when the approach encounters a expres-
sion, it iterates over the expression to calculate the resulting
string value. We will describe this process in more detail in
the next paragraph. After each iteration, our approach calls
theWiden expression to generalize the string model created
in the current iteration, and then the Converge method to
check if it should stop iterating over the expression.
Our approach may iterate several times over each ex-
pression, depending on the Widen andConverge opera-
tions. In each iteration while interpreting the expression
(T
v:r(exp)), whereexpcontains at least one k
v:r, our ap-proach rst increases the counter Tfor theexpression and
allv:r. After this, our approach sets the value of k
v:ras the
value of (k
v:r(exp)) generated in the kthiteration. Then,
it calculates the value of exp, calls theWiden operation to
calculate the result of current iteration. This value will be
recorded as the value of in future iterations.
During each iteration, if our approach encounters a nested
expression, it will iterate over this expression until the
value converges using the processes we described in the prior
paragraph. If it encounters a expression, the approach up-
dates the counters for and its, and calculates the value
with a process similar to that of interpreting the expres-
sion. The only dierence is that our approach does not iter-
ate over the operation several times. It only calculates the
value ofonce without calling the Widen andConverge .
We do this because represents another variable in the same
loop so its value can only be calculated once in each itera-
tion. The resulting values of the expression will also be
recorded as the values of future corresponding operators.
3.3 Getting the Intermediate Representation
In this section, we describe how our approach generates
the IR for a given PUT. As inputs, our approach requires the
Call Graph (CG) of the PUT and the SSA representation of
each method in the PUT. In general, most mainstream lan-
guages (e.g., Java, Dalvik, and PHP) have analyses available
that can provide both of these elements. Given these inputs,
our approach analyzes each method in reverse topological or-
der with respect to the PUT's CG. For each method, the
approach then identies the Region Tree (RT) and builds
the IR for each region in this tree in a bottom up fashion.
After the approach nishes analyzing a method, the result-
ing IR serves as its summary and is reused whenever another
method calls the summarized method.
3.3.1 Intra-procedural Analysis
The approach begins with an intra-procedural analysis to
calculate the IR based summary for each method in the
PUT. The rst step of this analysis is to identify the bodies
of loops and their relationship to other loops. This informa-
tion is needed in order to use the loop modeling operands
dened by the IR. To identify loops, our approach uses
a standard analysis to identify regions in the method's
Control-Flow Graph (CFG) [4].
The regions of a method can be represented as a RT in
which nested regions are shown as children of their parent
regions and the root node of the tree is the method body.
Figure 1 shows the RT for an excerpt of the code of Pro-
gram 1. In this gure, R0 represents the method body of
main andR1{R3 are loops in the method.
After the approach builds the RT, the next step is to gen-
erate the IR for each region. The approach analyzes the
RT using a post-order traversal (i.e., starting with the leaf
nodes) so that the results of analyzing nested regions can
be incorporated into the analysis of the parent regions. In
general, there are two types of regions that the approach
analyzes. The rst type is Method Body Regions (MBRs),
which represent the main body of a method (e.g., R0), and
the second type is Loop Body Regions (LBRs), which are the
regions that represent the bodies of loops (e.g., R1  R3).
We now explain how the approach analyzes each of these
region types.
664Figure 1: The Region Tree for Program 1
Algorithm 1 Getting the intra-procedural intermediate
representation
Input: A regionR
Output: The IR of string variables in R
1:External all External Variables
2:for all Instruction SinRin topological order do
3: ifSdenes a variable vthen
4: Represent S in the form of the IR as v= (op a 1a2:::)
5: for allai2Par(S)do
6: ifaihas been solved and ai62External then
7: Replace aiwith its IR
8: end if
9: end for
10: end if
11:end for
3.3.2 General Region Processing
Regardless of their types, all regions are rst processed by
Algorithm 1. The input to Algorithm 1 is the SSA represen-
tation of the code in a region R. The output of Algorithm 1
is a basic IR transformation of Rthat does not consider the
eect of loops.
The rst step of Algorithm 1 is to identify variables whose
denitions occur outside of the region (line 1). These vari-
ables can be identied in a straightforward way, since the
code is in SSA form, by checking if they are dened in the
current region. All other variables are considered to be in-
ternal variables. The approach will leave placeholders for
external variables until their denitions are located in a con-
taining region. An example of an external variable is the use
ofcon the righthand side of line 19 in R3.
After nding all external variables, the approach then it-
erates over each instruction in Rin topological order with
respect toR's CFG. For each instruction iin which the
left hand side denes an internal variable v, the approach
convertsiinto an IR operand of the form ( op a 1a2:::) as
shown in Section 3.1. Then the approach iterates over all
arguments for op, which isPar(S) . If any argument aihas
previously been dened on the lefthand side of an instruc-
tion in the region, then the righthand side of that denition
is substituted for the ai. This process is continued until
there are no more such previously dened internal variables
present in the IR form of i. Then the approach repeats this
for each of the remaining i2R. Note that since the eects of
loops are not considered at this time and the instructions areprocessed in topological order, the transformation converges
on a xed point after one iteration over the instructions in
R.
Example: To illustrate Algorithm 1, rst consider line
19 of R3 in Figure 1. The IR for this line is (+ c19\A").
Note that due to the SSA transformation, (+ c15\A") could
also be a denition here. However, we omit these SSA based
denitions from the explanation for simplicity, since our code
example is not shown in SSA form. Following with this, the
IR for line 20 in R3, would be (+ f20(+c19\A")).
3.3.3 Processing Loop Regions
The next step is to analyze all LBRs and more precisely
model the eects of loops in the region. This is performed
by the algorithm shown as Algorithm 2. The input to Algo-
rithm 2 is the IR of an LBR that has already been processed
by Algorithm 1. The output is an IR representation of the
LBR that has been adjusted to model the eects of loops.
The IR of an LBR can be incorporated into its parent loop
or a MBR.
Algorithm 2 can be thought of as having three general
phases. The rst of these (lines 1{10) rewrites all string vari-
ables within the LBR so that they have counters attached to
them. These counters are then used in the second phase to
identify dependencies between loop iterations. The second
phase (lines 11{39) iterates over the instructions in the LBR
and replaces string variables dened in the loop with values
updated for each iteration. Loop-carried data dependencies
are identied and replaced with the andoperators so
that the denitions of the string variables can converge on
a xed point. Finally, in the third phase (lines 40{48), the
analysis replaces certain operators with the operators.
We now explain these three phases in more detail below.
In the rst phase (lines 1{10), our approach assigns and
initializes a counter to all region-internal string variables.
The analysis iterates over each instruction i2LBR and if it
is of the form v= (op a 1a2::: am::: an) (i.e., a denition)
andvis an internal variable then the analysis performs the
following transformations. The variable vis rewritten to be
v0and each of the arguments akis rewritten as a 1
k. The
intuition behind this transformation is that the superscripts
show that the variable on the lefthand side is dened by
the values of the righthand side variables that come from
the previous (i.e.,-1) iteration. Note that since Algorithm 1
has already propagated all values forward, all righthand side
variables were dened in the previous iteration or, in the
base case, external to the LBR.
To illustrate the rst phase we will build on the example
from Section 3.3.2. Here for line 20 of Program 1, the IR
isf20= (+f20(+c19\A")). The transformed version of
this IR with counters inserted and initialized would be f0
20=
(+f 1
20(+c 1
19\A")). Note that, after the transformation
done by Algorithm 1, the f20on the righthand side refers to
the value of ffrom the previous loop's iteration (or in the
base case, the value provided at line 16.)
In the second phase (lines 11{39), the approach iterates
over each instruction, propagating values and updating coun-
ters until the IR of the instructions converges on a xed
point. The approach begins this phase by iterating over
each instruction that is of the form v0= (op a 1a2::: an)
(i.e., a denition). At lines 15{19, the approach adds all
variables on the righthand side that are region-internal vari-
ables to a worklist Q. Then at lines 20{36, the approach will
665iterate over all variables in the worklist, replacing them with
updated values and introduce andnotions so that vari-
ables dened in the loop will converge to a xed point. In
the loop beginning at line 20, the approach dequeues the rst
argument in the worklist and determines if it refers to v(i.e.,
if it is a self reference.) If it is, then the approach replaces
the self reference with the notation and puts a notation
around the expression, as described in Section 3.1. If the
argument is not a self reference, then the approach replaces
it with the most up-to-date IR representation and decreases
all counters in the replaced expressions by the counter value
for the replaced argument. (This maintains the correspon-
dence between loop iterations.) All arguments present in
the replaced argument that are self-references are then also
added to the worklist. This process repeats until there are
no more arguments to be resolved in the worklist.
To illustrate the second phase, consider again the example
from above. For line 19 in R3, Our approach will add the 
expression and change c19toc19:R3. Therefore the IR for
line 19 is as shown in Equation (4).
c19= (0
c19:R3(+ 1
c19:R3\A")) (4)
Similarly, for line 20 in R3, we replace the reference c 1
19
with Equation (4) and the IR for line 20 will be as shown in
Equation (5). Here, the underlined portion is the part that
came from Equation (4).
f0
20= (0
f20:R3(+ 1
f20:R3(+ ( 1
c19:R3(+ 2
c19:R3\A"))\A")))
(5)
The third phase of the approach (lines 40{48) introduces
theoperator that denotes the data-dependency between
variables in the same loop region. This enables the inter-
preters to distinguish region-internal variables from the same
loop and nested loops. To do this, our approach iterates over
allexpressions and checks their region IDs. If it nds that
there is aexpressiona:Rembedded by another expres-
sionsb:Rwith the same region ID, the approach changes
a:Rtoa:R. This is because if two expressions have the
same region ID, they are generated in the same loop.
To illustrate, consider again line 20 in R3. After the third
phase, its IR will be as shown in Equation (2). Here, the
symbol 1
c19:R3is the changed portion.
3.3.4 Inter-procedural Analysis
Once the IR has been calculated for each method's MBR,
then analysis of the method is complete. The IR for the
MBR is used as the method's summary to enable inter-
procedural analysis. When an invocation to the summarized
method is encountered during the analysis of Algorithm 1,
the IR of the summarized method's return variable is in-
serted into the current method body and placeholder vari-
ables in the IR are replaced with the arguments provided at
the invocation call site. Note that methods are processed in
reverse topological order with respect to the PUT's CG so
that a method's summary is computed before that of any
calling method. In the case that there are Strongly Con-
nected Components (SCC) in the CG, our approach builds
a global CFG for the SCC and then uses the intra-procedural
analysis to generate the IR for this connected method.Algorithm 2 Solving the loop region
Input: A loop region R
Output: The IR of string variables in R
1:for all Instruction SinRin topological order do
2: ifSdenes a variable vthen
3:v!v0
4: for allai2Par(v)do
5: ifai62External then
6: v!a 1
i
7: end if
8: end for
9: end if
10:end for
11:while the IR for all variables are not converged do
12: for all Instruction SinRin topological order do
13: ifSdenes a variable vthen
14: Q EmptyQueue
15: for alla k
i2Par(v)do
16: ifai62External then
17: Add a k
ito the tail of Q
18: end if
19: end for
20: whileQis not empty do
21: ai Q:poll ()
22: ifaiequals tovthen
23: Replace a k
iwith k
v:rid
24: ifThere is no 0
v:rid in the IR of vthen
25: Put 0
v:rid around the IR of v
26: end if
27: else
28: Replace a k
iwith its IR
29: Decrease all counters in aiby k
30: for allb j
i2Par(a k
i)do
31: ifb j
irefers tovthen
32: Add b j
ito the tail of Q
33: end if
34: end for
35: end if
36: end while
37: end if
38: end for
39:end while
40:for all variablevin the Region do
41: ifvcontains aexpressionv:RID then
42: for allx:rid contained by v:RID do
43: ifridequals toRID then
44: x:rid!x:rid
45: end if
46: end for
47: end if
48:end for
3.4 Illustrative Example of the Analysis
We walk through our algorithm using Program 1 as an
example. Our approach rst builds the summary for each
region in a bottom-up order. The approach rst analyzes the
leaf regions, R3 and R2. R3 is a LBR that denes two vari-
ables,c19andf20. As we described earlier in Section 3.3.2,
we initially represent their values as c19= (+c19\A") and
f20= (+f20c19). Then the approach replaces the sym-
bolc19inf20with its denition so that we have f20=
(+f20(+c19\A")). After this, the approach marks the
iteration from which the value of a variable comes from as
a superscript of each variable. After this step, we will have
c0
19= (+c 1
19\A") andf0
20= (+f 1
20(+c 1
19\A")).
The approach continues iterating over the code in R3. c19
does not contain any other variables that need to be re-
placed, but it does contain a self-reference, so the approach
adds aexpression and changes c19in the expression to
. The result after this step is shown in Equation (4). For
f20, the approach replaces c19with its denition shown in
Equation (4). Since c19is in the expression of f20with a
666-1 superscript, the approach decreases the superscript of all
variables in the expression of c19by 1. So, after the replace-
ment, we have:
f0
20= (+f 1
20(+ ( 1
c19:R3(+ 2
c19:R3\A")) \A"))
Then the approach determines that f20also has a self-
reference (underlined), so the approach changes it to a , as
is shown in Equation (5).
Finally, the approach checks the expression of f20and
nds that it contains two expressions, the rst one is
0
f20:R3, and the second one is  1
c19:R3. However, these two 
expressions do not represent dierent loops, they are gener-
ated in the same region and represent two related variables
in the same loop. So the approach replaces  1
c19:R3with
 1
c19:R3. After the replacement, we have the IR of f20as
shown in Equation (2). For the other leaf region, R2, its
body only denes one variable, e33. The approach repre-
sents its IR as shown in Equation (1).
After the approach solves all leaf regions, it solves re-
gion R1, which is the parent of R2. R1 is also the body
of a loop, it directly denes a variable d29and indirectly
denes the variable e33in R2. Similar to R3, in the rst
step, the approach rst replaces all variables with the known
representations. Since the approach knows the IR of e33
in R2, it directly uses the IR as the expression of e33in
R1. Thus, in R1, the approach will have the value of e33
the same as in R2, because e33is not changed in R1 and
d29= (+d29(0
e33:R2(+ 1
e33:R2\e"))). Then the approach
adds superscripts to the internal variable, which is d29, so
we have
d0
29= (+d 1
29( 1
e33:R2(+ 2
e33:R2\e")))
Finally, the approach adds a expression to d29and we have
d29= (0
d29:R1(+ 1
d29:R1( 1
e33:R2(+ 2
e33:R2\e"))))
The expression of d29also contains two expressions, but
they are from dierent region and represent dierent loops.
Finally, the approach analyzes the region R0, which is
an MBR. Since it is not a loop body, the approach only
replaces the variables with their corresponding expressions.
In R0, the approach nds that c15,f16,d25, ande26are also
constants and therefore uses their values in the expressions
ofc19,f20,d29, ande44.
4. EVALUATION
We evaluated our approach by measuring its performance
in terms of accuracy and runtime on a mixture of benchmark
test cases and real-world Java and Android applications. To
provide a baseline for our measurements, we compared our
approach against the popular and widely used JSA [9]. Our
evaluation addressed the following four research questions:
RQ 1: How accurate is our approach in analyzing strings
constructed with various data ows?
RQ 2: How accurate is our approach in handling basic
string operations?
RQ 3: How accurate is our approach on real-world appli-
cations?
RQ 4: What is the runtime of our approach?4.1 Implementation
The implementation of our approach, Violist, is written
in Java. To extract SSA based representations of an appli-
cation's code, CGs, and CFGs, we use the Soot [33] analysis
framework. We also implemented two string interpreters,
described below, that mimic two of the most common ap-
proaches to string analysis. For most users of the framework,
these two interpreters subsume most string analysis we saw
in the literature. Our approach is not limited to these two
interpreters though, as the approach can be easily extended
to include new interpreters that implement dierent string
operation semantics. In its current state of implementation,
Violist can perform string analysis on apps for which either
Java or Dalvik bytecode is available. It can be extended to
other languages for which it is possible to represent their
code in SSA form and generate CGs and CFGs.
Our rst interpreter is the String Set Interpreter (SSI).
This interpreter is provided a value nthat represents the
number of times a loop (i.e., a ) will be unraveled in the
IR. Note that this approach is not safe unless nis larger
than the maximum loop unraveling or there are no loops in
the IR. However, this mimics simple string analyses that
do not need loop semantics (e.g., [26]). The output of the
SSI interpreter is a set of concrete strings. For example, to
interpret the IR for c19, which is shown in Equation (4),
withnequal to 3, we would get the set of concrete strings
f\AA";\AAA ";\AAAA "g.
Our second interpreter is the FSA Interpreter (FSAI).
This interpreter approximates the values of strings in the
form of FSAs. In general, most of the interpretation seman-
tics for the FSAI are similar to those of the SSI. However,
the key dierence is that values are not converted to con-
crete strings, but instead FSAs, and loops are not unraveled.
For loops, the FSAI does not unravel expressions using an
n-bound, instead the FSAI uses the Widen operation pro-
posed by Yu and colleagues [41] to generate a safe model
for innite string values in a loop. In our implementation of
FSAI, we leveraged the Automaton library used by JSA to
model the string outputs. The output of the FSAI is safe
due to the approximation process dened by the Yu and
colleagues' technique.
4.2 Experiment Protocol
To evaluate the performance of our approach, we mea-
sured Violist's accuracy and runtime and compared the re-
sults with the publicly available implementation of JSA. For
both analyses, we treated all public methods as possible en-
try points. To measure accuracy, we computed precision and
recall of the two analyses against the ground truth. Below,
we explain how we identied the ground truth for the dif-
ferent types of applications used in our study and how we
compared the ground truth against the models generated by
the analyses. All of our experiments were conducted on a
Dell XPS-8300 desktop with an Intel i7 processor at 3.4 GHz
and 8 GB of memory.
Building Ground Truth: In our evaluation, we used
three dierent types of subjects: the JSA benchmarks, hand-
crafted test cases, and real-world Android and Java appli-
cations. For the rst two types, we were able to identify
the ground truth by manual analysis of the code, because it
was provided as part of the benchmark. However, it was not
possible to identify the ground truth for the Android mar-
ket apps because of their size and the lack of source code.
667For these apps, we used a proling technique to identify a
subset of the values that string variables in the apps could
assume. To do this, we rst randomly selected a set of non-
constant string variables in each app that did not include
external strings (e.g., user input). We then inserted probes
to record the values of these string variables when they were
executed. Then we created workloads that traversed all of
the discoverable User Interfaces (UIs) and recorded the val-
ues of the string variables via the probes. We used these
collected values as the ground truth for the string variables.
For these apps, the collected values represent a subset of
the real ground truth. The implication of this is that there
may be less false positives and more false negatives than re-
ported by our results. Thus, by using the proled subset of
the ground truth, we will get a lower bound on the precision
and an upper bound on the recall. For both approaches, it
is important to note that they provide safe approximations,
so we would expect 100% recall. For precision, we do not ex-
pect that this calculation of the ground truth would impact
one approach more than the other.
Calculation: To calculate precision and recall, we com-
pared the ground truth to the set of strings reported by the
two approaches, JSA and Violist. For the JSA and FSAI
interpreters, additional steps are needed to compute these
values because their string representations may contain cy-
cles, which represent strings of innite length. For this situ-
ation, we followed the Sound and Most Precise (SMP) policy
in which we set an upper bound to the length of strings or
maximum loop iterations that maintained 100% recall but
had the largest precision. For the FSA models generated by
JSA and FSAI, we generated strings with length smaller or
equal tok, wherekis the length of the longest string in the
ground truth. For the SSI interpreter, we iterated over the
expressions for jtimes, where jis the smallest number of
iterations needed by any loop to generate all of the strings
in the ground truth.
4.3 RQ 1: Accuracy on Various Types of Data
Flow
One of the goals of our approach is to develop a framework
that would allow for more accurate modeling and handling of
complex data ows, such as inter-procedural manipulation
of strings and loops. To evaluate the success of our approach
with respect to these goals, we created a test suite that in-
cluded string value computations based on dierent types
of data ows. In particular, we considered four such types:
Branch, Single Loop, Nested Loop, and Inter-procedural.
We also dened a fth type called Circle Loop, which is a
single loop containing three variables that depend on each
other in a cycle. We combined these ve variants to cre-
ate a mixture of test cases, removing those that did not
make sense to combine (i.e., Single Loop, Nested Loop, and
Circle Loop). In total, we have eight more types of data
ows, which are Branch and Inter-procedural, Single Loop
and Branch, Single Loop and Inter-procedural, Nested Loop
and Branch, Nested Loop and Inter-procedural, Circle Loop
and Branch, Nested and Inter-procedural, and Mix up all.
This in total gave us 13 dierent types of data ow.
Next, we inserted string operations into the dierent data
ows. We broadly categorized all of the string operations
into one of three categories and used one function from each
as a representative. The rst category is Concatenation
(Concat), which included all APIs that joined two or morestrings. Its representative is StringBuer.append. The sec-
ond category is Manipulation (Manip), which include APIs
that manipulate a substring of the original string, such as
replaceAll, replaceFirst, and substring. Its representative
is String.replaceAll. The third category is Converge, which
include the APIs that the result will converge after one in-
vocation to the APIs. Its representative is String.trim. For
each of the types of data ows, we created one test case for
each of the three categories of string operations and one test
case that contains all three categories. This gave us 52 total
cases.
Figure 2: Precision of the three analyses on varied data
ows.
Using the process described in Section 4.2, we calculated
the precision and recall for each test case for each of the
three string analyses. In all cases, the recall for the anal-
yses was 100%, which was expected given our use of the
SMP policy. The precision of the three analyses is shown in
Figure 2. In this gure, the x-axis shows the names of the
four categories of string operations and the individual string
analysis. The y-axis shows the average precision for each op-
eration over the dierent data ows. The average precision
of SSI was 70%, FSAI was 64%, and JSA was 7%. From
the results, we can see that both of Violist's interpreters
achieved precision that was, at least, nine times higher than
that of JSA. When we examined the FSAs generated by
JSA, this gap was clearly attributable to the increased pre-
cision available due to improved loop modeling and context
sensitivity. Overall, these results show that our method of
handling these types of data ows can result in signicant
improvements in precision as compared to the popular and
widely used JSA.
4.4 RQ 2: Accuracy for Basic String Opera-
tions
For the second research question, we looked at the accu-
racy of Violist and JSA in computing models of the basic
string operations without the eect of more complex data
ows. In other words, the accuracy of computing string
values for a standalone invocation of a string operator. To
address this question, we leveraged a set of string analysis
benchmarks that were made available as part of the JSA
distribution [3]. These test cases cover most of the basic
string operations and their usages (e.g., simple branches and
loops). To have a meaningful comparison, we removed those
test cases that contained operations that were not supported
by JSA. We identied these as operations that were imple-
668mented by simply modeling them as any string (i.e., \.*").
In total, we had 80 viable test cases. We then ran the three
analyses on the test cases and computed their precision and
recall.
Both JSA and the two interpreters of Violist achieved
100% recall, which again was expected since they are safe
analyses and we used the SMP policy. On average, JSA
achieved 76% precision and Violist achieved 71% precision.
Both the SSI and FSAI had the same level of precision be-
cause the data ow in the test cases was simple enough that
theWiden operation did not make any dierence. Among
the 80 test cases, JSA and Violist achieved the same preci-
sion in 60 test cases. JSA had a higher precision than Violist
in 15 cases while Violist had a higher precision in ve cases.
To understand the results better, we inspected the 15 test
cases for which JSA had a higher precision in more detail. It
turns out that besides string analysis, JSA also performs ba-
sic string constraint solving for string constants. For exam-
ple, if there is a branch statement that contains a constraint
on a string, JSA can augment its results with this informa-
tion. Our approach does not rene the results in this way, so
it had lower precision for these test cases. We also inspected
the test cases for which Violist had a higher precision. We
found that Violist had a higher precision for these because of
its ability to more precisely model inter-procedural analysis.
Overall, we believe that the results of this research ques-
tion are neutral. For most of the implemented string oper-
ations, our approach and JSA were equivalent in terms of
precision. For those in which JSA was better, we found that
the reason for this was that JSA also performed basic anal-
ysis of string constraints in branches. Although our analysis
could not handle these, the architecture of our approach
would allow a user to incorporate these semantics into an
interpreter. For example, by attaching string constraints to
each region of the Region Based Techniques (RBT) and then
using a string constraint solver to account for their seman-
tics. Additionally, these results discount a threat to validity
of RQ1; namely that the observed increase in precision was
due to dierences in the implementation of the basic string
operations used in the various data ows.
4.5 RQ 3: Accuracy on Realistic Apps
In the third research question, we looked at the perfor-
mance of the string analyses on realistic string variables
and programs. We selected ve realistic apps from dier-
ent sources. The name, description, and size of the apps
are listed in Table 1. The unit of size is the number of
bytecode instructions. Among our apps, Reection is one
of JSA's benchmark apps [2]; BookStore is from our pre-
vious testbed [1]; and apps a2z, add.me.fast, and pipelter
are three mobile apps randomly chosen from the Android
Play Market. We only used one of the JSA benchmarks be-
cause we were not able to locate older versions of libraries
required for their compilation. In total, over these ve apps,
we recorded 133 dierent string variables.
We ran all three analyses on the subject apps and com-
puted the precision and recall as described in Section 4.2.
As with the previous experiment, the recall was 100% for all
analyses for all apps. For the three mobile apps, JSA did not
terminate before running out of memory, so we were unable
to compute its accuracy. We investigated this issue further
and believe the reason is due to the fact that JSA uses a
variable-pair-based method to do the global inter-proceduralTable 1: Description of subject apps
App Description Size
Reection Java reection benchmark in JSA 7,156
BookStore A JSP web app 24,305
a2z An Android conference app 74,700
add.me.fast A social network app 39,330
pipelter An information checking app 16,626
Figure 3: The precision of market apps
aliasing analysis. This method has an O(n2) memory com-
plexity, where nis the number of variables across the whole
application. In our experiments, Android applications gen-
erally have more than 100,000 variables. Thus, we hypoth-
esize that the failure is due to the increased expense of the
global alias analysis when running over an app that makes
extensive use of a large framework (i.e., the Android API).
Figure 3 shows the precision measured in the experiment.
Both SSI and FSAI had the same precision results, so they
are shown together. For the two apps measured, Violist was
either equal to or higher in terms of precision. Across all
apps, Violist had an average precision of 86% while JSA
had an average precision of 68% on its two working apps.
Overall, these are positive results for Violist. It was able
to achieve, on average, a higher level of precision than JSA,
thus showing that its results from RQ1 and RQ2 carry over
to real world applications. Furthermore, the results high-
light the general applicability of Violist, as it was able to
accurately analyze apps written for Android as well.
4.6 RQ 4: Analysis Runtime
To answer this question, we compared the execution time
of Violist's two interpreters against JSA. For each of the
experiments we reported in RQ 1{3, we repeated the exper-
iment ten times and recorded the execution time for each.
The results of these timing measurements are shown, in mil-
liseconds, in Table 2. Due to the large number of test cases
in RQ 1 and RQ 2, we only reported the average time cost
for each of their test cases. In our results, we subtracted out
the time consumed by the Soot APIs (for generating call
graphs and control ow graphs) from the timing measure-
ments, since this was strictly time consumed by Soot and
was the same for both.
The results show that for all categories of tests, Violist
was signicantly faster. The FSAI interpreter averaged a
75% decrease in runtime versus JSA and the SSI interpreter
averaged a 94% decrease versus JSA. As with the previous
RQ, we hypothesize that the cost of performing the global
alias analysis is responsible for the high runtime. Within
669Table 2: Time cost of Violist vs. JSA
Case Name SSI (ms) FI (ms) JSA (ms)
RQ 1 test cases 13 22 119
RQ 2 test cases 35 306 401
Reection 101 147 54,762
BookStore 56,607 202,257 7,371,030
a2z 455,772 457,248 N/A
add.me.fast 34 174 N/A
pipelter 16,913 17,083 N/A
the results for Violist, the SSI interpreter was clearly faster.
The reason for this is that the Widen operation for FSAs is
a relatively expensive operation. Overall, these are positive
results for our approach and show that our approach can
signicantly outperform JSA in terms of analysis runtime.
5. RELATED WORK
The most similar work to ours is Nguyen and colleagues'
D-model [29], which denes a tree-based representation for
symbolic, string-based values originating from symbolic ex-
ecution of PHP expressions. Our approach is dierent from
this model in the following aspects. First, their approach ad-
dresses the problem of estimating multiple outputs of client-
side pages while our approach targets a more general prob-
lem, which is estimating the possible values of a string vari-
able at a given program point. Second, their model only
handles string concatenation, while ours supports all of the
string operations in the Java API. Third, their model only
unravels loops once, while our approach can unravel loops
either a set nnumber of times or based on additional code
analyses.
Another closely related work is JSA [9], which uses ow
graphs to produce FSAs that represented the possible string
values of Java string variables. Compared with the ow
graphs of JSA, the IR of Violist has two main advantages.
The rst advantage is that it allows users to specify the it-
eration bound for loops while JSA assumes the bound is
innite. The second advantage is that it uses a summary
based technique so that it can provide context sensitive
inter-procedural analysis and avoid expensive global alias-
ing analysis.
Other approaches also exploit symbolic execution to per-
form string analysis for Java [32] and Javascript [31]. Since
these techniques use symbolic execution, they may not be
readily scalable to complex programs (e.g., those containing
thousands of branches). Other research related to symbolic
execution based string analysis uses a constraint solver [10,
34, 35, 42, 13, 7] or a decision procedure [23, 25] to decide
whether the string constraints are satisable or not. These
approaches are generally concerned with string constraint
solving as part of a symbolic execution based approach to
string analysis, as opposed to our more general focus of a
static string analysis framework.
The automaton-based method is also widely used to per-
form string analysis. Minamide [28] used transducers (i.e.,
multi-track automata) to do PHP string output analysis.
Other techniques [41, 8, 5] introduced the widening operator
for loops to guarantee the convergence of symbolic reacha-
bility analysis. A drawback of these automaton-based ap-
proaches is that they overestimate the iteration bound for
loops; generally assuming it is innite. Our approach cando this as well, but also oers a exible way to incorpo-
rate user provided information (e.g., via additional program
analyses) to more accurately model loop bounds, which can
help increase the precision of the estimated string values.
Based on string analysis, researchers have made great
progress in many verication areas. For example, locat-
ing buer overow errors due to string manipulations [36,
11, 12], detecting SQL query type errors [18, 17, 37], SQL
injection attacks [38, 39, 19, 14], cross-site scripting vulner-
abilities [24, 40], HTML errors [29, 21], identifying incorrect
or incomplete sanitization [6], characterizing database inter-
actions [27], improving test case generation [20], performing
permission analysis [16], and understanding runtime behav-
ior of DEB systems [15]. All of these techniques exploit ex-
isting string analysis directly or indirectly to attain dierent
research goals. Our work proposes a exible string analy-
sis framework, which could be used by these approaches to
improve their results.
6. THREATS TO VALIDITY
To ensure that we can have a fair comparison to JSA, we
selected our benchmarks from three dierent sources. These
included apps from JSA's benchmarks or that had been an-
alyzed by JSA in prior work [19] as well as test cases we had
created. Although test cases created by our group could
introduce bias, there were no benchmarks available that in-
cluded the more complex data ows we wanted to test.
A general threat to the validity of RQ3 is our mechanism
for establishing ground truth. If we were incomplete, we
would have an upper bound on recall and a lower bound on
precision. As we expect both analyses to have 100% recall,
this primarily would aect precision. A change in precision
would aect one of our conclusions from RQ3, but would
not change our larger nding that Violist could more easily
scale up for larger applications than JSA.
7. CONCLUSION
String analysis is a fundamental technique for many veri-
cation techniques, such as HTML output analysis and SQL
injection detection. In this paper, we propose a general
framework, Violist, for string analysis that allows for mod-
eling string variables with high accuracy. In particular, Vi-
olist allows for more precise modeling of loops and inter-
procedural string manipulations; while providing users with
an easy way to use custom string semantics and scale up
for large applications. In our evaluation, Violist achieved
high precision and recall in complex market apps. Com-
pared to JSA, the state-of-the-art alternative solution, Vi-
olist achieved over nine times higher precision on complex
data ows with the same recall and a runtime speed sev-
eral orders of magnitude faster. These results show that our
approach can potentially improve the performance of other
verication techniques that are built based on string analysis
techniques.
8. ACKNOWLEDGMENTS
This work was supported by NSF grant CCF-1321141.
9. REFERENCES
[1] http://www-bcf.usc.edu/ halfond/testbed.html.
[2] http://www.brics.dk/JSA/dist/jsa-benchmarks.tar.gz.
670[3] http://www.brics.dk/JSA/dist/string-test.tar.gz.
[4] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman.
Compilers: Principles, Techniques, and Tools (2nd
Edition) . Addison-Wesley Longman Publishing Co.,
Inc., Boston, MA, USA, 2006.
[5] M. Alkhalaf, T. Bultan, and J. L. Gallegos. Verifying
Client-side Input Validation Functions Using String
Analysis. In Proceedings of the 34th International
Conference on Software Engineering , ICSE '12, pages
947{957, Piscataway, NJ, USA, 2012. IEEE Press.
[6] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic,
E. Kirda, C. Kruegel, and G. Vigna. Saner:
Composing Static and Dynamic Analysis to Validate
Sanitization in Web Applications. In Security and
Privacy, 2008. SP 2008. IEEE Symposium on , pages
387{401, May 2008.
[7] N. Bjrner, N. Tillmann, and A. Voronkov. Path
Feasibility Analysis for String-Manipulating Programs.
InProceedings of the 15th International Conference on
Tools and Algorithms for the Construction and
Analysis of Systems: Held As Part of the Joint
European Conferences on Theory and Practice of
Software, ETAPS 2009, , TACAS '09, pages 307{321.
Springer-Verlag, Berlin, Heidelberg, 2009.
[8] T.-H. Choi, O. Lee, H. Kim, and K.-G. Doh. A
Practical String Analyzer by the Widening Approach.
In N. Kobayashi, editor, Programming Languages and
Systems , volume 4279 of Lecture Notes in Computer
Science , pages 374{388. Springer Berlin Heidelberg,
2006.
[9] A. S. Christensen, A. Mller, and M. I. Schwartzbach.
Precise Analysis of String Expressions. In Proceedings
of the 10th International Conference on Static
Analysis , SAS'03, pages 1{18, Berlin, Heidelberg,
2003. Springer-Verlag.
[10] L. De Moura and N. Bjrner. Z3: An Ecient SMT
Solver. In Proceedings of the Theory and Practice of
Software, 14th International Conference on Tools and
Algorithms for the Construction and Analysis of
Systems , TACAS'08/ETAPS'08, pages 337{340,
Berlin, Heidelberg, 2008. Springer-Verlag.
[11] N. Dor, M. Rodeh, and M. Sagiv. Cleanness Checking
of String Manipulations in C Programs via Integer
Analysis. In P. Cousot, editor, Static Analysis , volume
2126 of Lecture Notes in Computer Science , pages
194{212. Springer Berlin Heidelberg, 2001.
[12] N. Dor, M. Rodeh, and M. Sagiv. CSSV: Towards a
Realistic Tool for Statically Detecting All Buer
Overows in C. SIGPLAN Not. , 38(5):155{167, May
2003.
[13] X. Fu and C.-C. Li. A String Constraint Solver for
Detecting Web Application Vulnerability. In SEKE ,
pages 535{542, 2010.
[14] X. Fu, X. Lu, B. Peltsverger, S. Chen, K. Qian, and
L. Tao. A Static Analysis Framework For Detecting
SQL Injection Vulnerabilities. In Computer Software
and Applications Conference, 2007. COMPSAC 2007.
31st Annual International , volume 1, pages 87{96,
July 2007.
[15] J. Garcia, D. Popescu, G. Sa, W. G. Halfond, and
N. Medvidovic. Identifying message ow in distributed
event-based systems. In Proceedings of the Symposiumon the Foundations of Software Engineering (FSE) ,
August 2013.
[16] E. Geay, M. Pistoia, T. Tateishi, B. Ryder, and
J. Dolby. Modular string-sensitive permission analysis
with demand-driven precision. In Software
Engineering, 2009. ICSE 2009. IEEE 31st
International Conference on , pages 177{187, May
2009.
[17] C. Gould, Z. Su, and P. Devanbu. JDBC checker: a
static analysis tool for SQL/JDBC applications. In
Software Engineering, 2004. ICSE 2004. Proceedings.
26th International Conference on , pages 697{698, May
2004.
[18] C. Gould, Z. Su, and P. Devanbu. Static checking of
dynamically generated queries in database
applications. In Software Engineering, 2004. ICSE
2004. Proceedings. 26th International Conference on ,
pages 645{654, May 2004.
[19] W. G. Halfond and A. Orso. AMNESIA: Analysis and
Monitoring for NEutralizing SQL-Injection Attacks. In
Proceedings of the International Conference on
Automated Software Engineering , pages 174{183, Long
Beach, California, USA, November 2005.
[20] W. G. Halfond and A. Orso. Improving Test Case
Generation for Web Applications Using Automated
Interface Discovery. In Proceedings of the Symposium
on the Foundations of Software Engineering ,
Dubrovnik, Croatia, September 2007.
[21] W. G. Halfond and A. Orso. Automated Identication
of Parameter Mismatches in Web Applications. In
Proceedings of the Symposium on the Foundations of
Software Engineering , November 2008.
[22] W. G. J. Halfond, S. R. Choudhary, and A. Orso.
Penetration Testing with Improved Input Vector
Identication. In Proceedings of the International
Conference on Software Testing, Verication, and
Validation , pages 346{355, Denver, Colorado, USA,
Apr. 2009.
[23] P. Hooimeijer and W. Weimer. A Decision Procedure
for Subset Constraints over Regular Languages. In
Proceedings of the 2009 ACM SIGPLAN Conference
on Programming Language Design and
Implementation , PLDI '09, pages 188{198, New York,
NY, USA, 2009. ACM.
[24] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: a static
analysis tool for detecting Web application
vulnerabilities. In Security and Privacy, 2006 IEEE
Symposium on , pages 6 pp.{263, May 2006.
[25] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and
M. D. Ernst. HAMPI: A Solver for String Constraints.
InProceedings of the Eighteenth International
Symposium on Software Testing and Analysis , ISSTA
'09, pages 105{116, New York, NY, USA, 2009. ACM.
[26] D. Li, A. H. Tran, and W. G. J. Halfond. Making Web
Applications More Energy Ecient for OLED
Smartphones. In Proceedings of the International
Conference on Software Engineering (ICSE) , June
2014.
[27] E. Martin and T. Xie. Understanding Software
Application Interfaces via String Analysis. In
Proceedings of the 28th International Conference on
Software Engineering , ICSE '06, pages 901{904, New
671York, NY, USA, 2006. ACM.
[28] Y. Minamide. Static Approximation of Dynamically
Generated Web Pages. In Proceedings of the 14th
International Conference on World Wide Web , WWW
'05, pages 432{441, New York, NY, USA, 2005. ACM.
[29] H. V. Nguyen, H. A. Nguyen, T. T. Nguyen, and
T. N. Nguyen. Auto-locating and Fix-propagating for
HTML Validation Errors to PHP Server-side Code. In
Proceedings of the 2011 26th IEEE/ACM
International Conference on Automated Software
Engineering , ASE '11, pages 13{22, Washington, DC,
USA, 2011. IEEE Computer Society.
[30] G. Sa, A. Shahbazian, W. G. Halfond, and
N. Medvidovic. Detecting event anomalies in
event-based systems. In Proceedings of the 10th Joint
Meeting of the European Software Engineering
Conference and the ACM SIGSOFT Symposium on
the Foundations of Software Engineering
(ESEC/FSE) , September 2015. To Appear.
[31] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
S. McCamant, and D. Song. A Symbolic Execution
Framework for JavaScript. In Proceedings of the 2010
IEEE Symposium on Security and Privacy , SP '10,
pages 513{528, Washington, DC, USA, 2010. IEEE
Computer Society.
[32] D. Shannon, S. Hajra, A. Lee, D. Zhan, and
S. Khurshid. Abstracting Symbolic Execution with
String Analysis. In Testing: Academic and Industrial
Conference Practice and Research Techniques -
MUTATION, 2007. TAICPART-MUTATION 2007 ,
pages 13{22, Sept 2007.
[33] R. Vall ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam,
and V. Sundaresan. Soot - a java bytecode
optimization framework. In Proceedings of the 1999
Conference of the Centre for Advanced Studies on
Collaborative Research , CASCON '99, pages 13{. IBM
Press, 1999.
[34] M. Veanes, N. Bj ~Ayrner, and L. de Moura. Symbolic
Automata Constraint Solving. In C. Ferm ~Aijller and
A. Voronkov, editors, Logic for Programming,
Articial Intelligence, and Reasoning , volume 6397 of
Lecture Notes in Computer Science , pages 640{654.Springer Berlin Heidelberg, 2010.
[35] M. Veanes, P. d. Halleux, and N. Tillmann. Rex:
Symbolic Regular Expression Explorer. In Proceedings
of the 2010 Third International Conference on
Software Testing, Verication and Validation , ICST
'10, pages 498{507, Washington, DC, USA, 2010.
IEEE Computer Society.
[36] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken.
A rst step towards automated detection of buer
overrun vulnerabilities. In In Network and Distributed
System Security Symposium , pages 3{17, 2000.
[37] G. Wassermann, C. Gould, Z. Su, and P. Devanbu.
Static Checking of Dynamically Generated Queries in
Database Applications. ACM Trans. Softw. Eng.
Methodol. , 16(4), Sept. 2007.
[38] G. Wassermann and Z. Su. An analysis framework for
security in Web applications. In In Proceedings of the
FSE Workshop on Specication and Verication of
Component-Based Systems (SAVCBS 2004 , pages
70{78, 2004.
[39] G. Wassermann and Z. Su. Sound and Precise
Analysis of Web Applications for Injection
Vulnerabilities. In Proceedings of the 2007 ACM
SIGPLAN Conference on Programming Language
Design and Implementation , PLDI '07, pages 32{41,
New York, NY, USA, 2007. ACM.
[40] G. Wassermann and Z. Su. Static Detection of
Cross-site Scripting Vulnerabilities. In Proceedings of
the 30th International Conference on Software
Engineering , ICSE '08, pages 171{180, New York, NY,
USA, 2008. ACM.
[41] F. Yu, T. Bultan, M. Cova, and O. Ibarra. Symbolic
String Verication: An Automata-Based Approach. In
K. Havelund, R. Majumdar, and J. Palsberg, editors,
Model Checking Software , volume 5156 of Lecture
Notes in Computer Science , pages 306{324. Springer
Berlin Heidelberg, 2008.
[42] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A
Z3-based String Solver for Web Application Analysis.
InProceedings of the 2013 9th Joint Meeting on
Foundations of Software Engineering , ESEC/FSE
2013, pages 114{124, New York, NY, USA, 2013.
ACM.
672