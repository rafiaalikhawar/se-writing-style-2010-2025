Root Cause Localization for Unreproducible Builds
via Causality Analysis over System Call Tracing
Zhilei Ren
Key Laboratory for Ubiquitous Network
and Service Software of Liaoning Province;
School of Software, Dalian University of Technology
zren@dlut.edu.cnChanglin Liu
Department of Computer and Data Sciences,
Case Western Reserve University
cxl1029@case.edu
Xusheng Xiao
Department of Computer and Data Sciences,
Case Western Reserve University
xusheng.xiao@case.eduHe Jiang
School of Software,
Dalian University of Technology
jianghe@dlut.edu.cnTao Xie
Department of Computer Science
and Technology, Peking University
taoxie@pku.edu.cn
Abstract ‚ÄîLocalization of the root causes for unreproducible
builds during software maintenance is an important yet chal-lenging task, primarily due to limited runtime traces frombuild processes and high diversity of build environments. Toaddress these challenges, in this paper, we propose R
EPTRACE ,
a framework that leverages the uniform interfaces of system call
tracing for monitoring executed build commands in diverse build
environments and identiÔ¨Åes the root causes for unreproduciblebuilds by analyzing the system call traces of the executed buildcommands. SpeciÔ¨Åcally, from the collected system call traces,
R
EPTRACE performs causality analysis to build a dependency
graph starting from an inconsistent build artifact (across two
builds) via two types of dependencies: read/write dependenciesamong processes and parent/child process dependencies, andsearches the graph to Ô¨Ånd the processes that result in the inconsis-tencies. To address the challenges of massive noisy dependenciesand uncertain parent/child dependencies, R
EPTRACE includes
two novel techniques: (1) using differential analysis on multiplebuilds to reduce the search space of read/write dependencies,and (2) computing similarity of the runtime values to Ô¨Ålter outnoisy parent/child process dependencies. The evaluation results of
R
EPTRACE over a set of real-world software packages show that
REPTRACE effectively Ô¨Ånds not only the root cause commands
responsible for the unreproducible builds, but also the Ô¨Åles topatch for addressing the unreproducible issues. Among its Top-10 identiÔ¨Åed commands and Ô¨Åles, R
EPTRACE achieves high
accuracy rate of 90.00% and 90.56% in identifying the root
causes, respectively.
Index T erms ‚ÄîUnreproducible builds, localization, system call
tracing
I. I NTRODUCTION
A software build is reproducible if given the same source
code, build environment, and build instructions, any user cangenerate bit-by-bit identical copies of all speciÔ¨Åed artifacts [1].In this deÔ¨Ånition, the source code refers to a copy of thecode checked out from the source code repository, and thebuild artifacts include executables, distribution packages, and
Ô¨Åle system images. Note that relevant attributes of the build
environment (including build dependencies, build conÔ¨Ågu-ration, and environment variables) are kept as part of theTABLE I
SNIPPET OF V ARIA TIONS ,ACCORDING TO THE reprotest TOOL CHAIN
V ariation First build Second build
env TZ ‚ÄúGMT+12‚Äù ‚ÄúGMT-14‚Äù
env LANG ‚ÄúC.UTF-8‚Äù one of ‚Äúfr CH.UTF-8‚Äù, ‚Äúzh CN‚Äù, ‚Äúes ES‚Äù,
‚Äúru RU.CP1251‚Äù, ‚Äúkk KZ.RK1048‚Äù
umask 0022 0002
Ô¨Ålesystem default Ô¨Åle system disorderfs... ... ...
input for building the artifacts. A reproducible software build
plays a critical role in various important applications, such as
build-environment safety, software debugging, and continuousdelivery [2], [3].
Reproducible-build validation has emerged in recent years
as one important software development practice, which aimsto construct an independently-veriÔ¨Åable bridge between thesource code and the build artifacts. Many open-source softwareprojects have initiated their validation processes, such as De-
bian [4], Guix [5], and F-Droid [6]. In particular, to validate the
reproducibility of software packages in different build environ-ments, variations aside from the speciÔ¨Åed build environmentcould be introduced deliberately. For example, disorderfs ,a
userspace Ô¨Åle system that introduces non-determinism intometadata
1, is used to validate whether the issue of Ô¨Åle ordering
affects the reproducibility of the build. Table I illustratesexample variations introduced by the validation tool chainnamed reprotest
2of the Debian distribution.
Once a build is identiÔ¨Åed as unreproducible (i.e., there
exists any artifact with different checksum values over buildenvironments with variations), it is critical yet challengingto perform causality analysis that identiÔ¨Åes the root causes
(usually one or more build commands) for the unreproduciblebuilds, since build processes usually produce insufÔ¨Åcient run-time traces for locating root causes. As shown in a previousstudy [7], the main source of runtime traces available for
1https://tracker.debian.org/pkg/disorderfs
2https://tracker.debian.org/pkg/reprotest
UI*&&&"$.*OUFSOBUJPOBM$POGFSFODFPO"VUPNBUFE4PGUXB SF&OHJOFFSJOH	"4&
¬•*&&&
%0*"4&
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. locating problematic Ô¨Åles that result in unreproducible builds
is the build log, being the verbose output of the make build
system. However, the build log contains only high-level buildcommands and cannot capture the low-level build commandsinvoked by the high-level build commands; these low-levelbuild commands can play a critical role in causality analysis.For instance, consider a POSIX Shell script invoked in aMakeÔ¨Åle. From the build log, the execution of the scriptcould be reÔ¨Çected, but we cannot know what underlying buildcommands have been invoked inside the script. Also, the buildlog often contains a lot of noises for causality analysis, such asgreeting information, progress indicator, and test case output.Such irrelevant information makes it difÔ¨Åcult to extract usefulinformation.
Another major challenge for causality analysis is to deal
with the high diversity of build environments. Indeed, it ispossible to instrument the build commands for tracing thedependencies between the inconsistent artifacts and the build
commands for some speciÔ¨Åc build systems. However, such an
intrusive approach is not practical in many industrial softwareprojects, because modern software projects such as Linuxdistributions often use different types of build systems (such asAutomake
3and CMake4) for different components. Addition-
ally, these projects use many build-maintaining scripts written
in POSIX Shell, Python, Perl, etc [8], [9]. It is difÔ¨Åcult to
instrument all these scripts for tracing the executed commands.
To address these challenges, in this paper, we propose a
framework, R EPTRACE , that collects the system call traces
of the executed build commands (i.e., the processes spawnfrom the commands) and performs causality analysis overthe traces for identifying the root causes for unreproduciblebuilds. Our work is inspired by the recent successes of systemcall tracing in monitoring executed commands for variousresearch Ô¨Åelds, such as intrusion detection [10], computationalreproducibility [11], and system proÔ¨Åling [12]. In particular,
system call tracing provides two unique beneÔ¨Åts. First, system
call tracing provides a uniform interface for monitoring theoperating system, such as process control, Ô¨Åle management,and communications. Hence, it is possible to capture more ac-curate information of the build process. Second, since systemcall tracing does not rely on certain types of build systems, it
can be used in different build environments.
To conduct causality analysis with system call tracing,
R
EPTRACE builds a dependency graph of inconsistent arti-
facts based on two types of dependencies, and searches the
graph to identify the process that causes the inconsistencies.
SpeciÔ¨Åcally, R EPTRACE deÔ¨Ånes two types of dependencies:
(1)read/write dependency : two processes p1andp2are said
to have the read/write dependency if p1writes to a Ô¨Åle and then
p2reads from the Ô¨Åle; (2) parent/child process dependency :
two processes p1andp2are said to have the parent/child
dependency if p1spawnsp2. Based on these dependencies,
REPTRACE starts from the inconsistent artifact, and then iden-
3https://www.gnu.org/software/automake/
4https://cmake.org/tiÔ¨Åes the responsible processes based on the dependencies ofthe artifact. If there are other processes that have dependencieson the identiÔ¨Åed process, and these processes also produceinconsistent artifacts or generate inconsistent runtime values,
R
EPTRACE continues to trace back from these processes. This
tracing process stops if there are no more dependencies, andthen reports the last found processes as the root causes of theunreproducible build.
However, in order to effectively identify root causes, causal-
ity analysis over system call traces needs to address two majortechnical challenges:
‚Ä¢Massive noisy dependencies . The raw data of system
calls are noisy and of a huge volume [13]. Even onlyconsidering the read/write dependencies, the number ofsystem call traces per package could be up to tens ofthousands in our work. However, most of the system calltraces are irrelevant to the root causes for unreproduciblebuilds. For example, on average only 8.59% of the write
system calls generate different data between different
rounds of build.
‚Ä¢Uncertain parent/child dependencies . When a com-
mand spawns a new process (as commonly seen inthe build process), the dependencies may or may notbe carried over to the child process. Simply discarding
all parent/child dependencies might fail to capture thepropagation trajectories toward the inconsistent artifacts.
In contrast, establishing dependencies for all parent/childprocesses can produce many false warnings.
To tackle these two technical challenges, R
EPTRACE in-
cludes two novel techniques to capture the essential dependen-
cies relevant to unreproducible builds. To address the Ô¨Årst chal-
lenge, R EPTRACE narrows down the search scope by applying
differential analysis over system call traces of multiple builds.More speciÔ¨Åcally, R
EPTRACE identiÔ¨Åes the write system calls
that output different data between different builds, and traceshow these differences propagate to the inconsistent artifacts.
To address the second challenge, R
EPTRACE computes the
similarity of the runtime values (extracted from the system
call arguments, see Section II) passed between parent andchild processes to determine whether a dependency should beestablished.
To assess the effectiveness of R
EPTRACE , we conduct an
evaluation over 180 real-world packages from the Debian
repository. For the task of build-command localization, R EP-
TRACE accomplishes accuracy rate of 66.11% for the topmost-
ranked build command. If we further consider the Top-10
ranked build commands, the accuracy rate reaches 90.00%.Furthermore, R
EPTRACE is effective in locating the Ô¨Åles to
patch for unreproducible builds; compared with a relatedstate-of-the-art approach [7], R
EPTRACE achieves 10.56%
percentage improvement, considering the accuracy rate for the
topmost retrieved results.
This paper makes the following main contributions:
‚Ä¢The R EPTRACE framework, being the Ô¨Årst to conduct
system call tracing and causality analysis on the collected

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. traces for locating root causes of unreproducible builds.
‚Ä¢The deÔ¨Ånition of two types of dependencies (read/write
dependencies among processes and parent/child processdependencies) for causality analysis.
‚Ä¢Two novel techniques (differential analysis on multiplebuilds and similarity computation of runtime values)to address massive noisy dependencies and uncertainparent/child dependencies.
‚Ä¢Comprehensive evaluation on 180 real-world packagesto demonstrate high effectiveness of R
EPTRACE and its
superiority over a related state-of-the-art approach [7].
II. B ACKGROUND AND MOTIV A TING EXAMPLE
In this section, we Ô¨Årst describe the background of system
call tracing and our representation of the captured system
calls. Then, we provide a motivating example to illustrate the
causality analysis based on system call tracing. The exampleuses a real-world package, i.e., airstrike (0.99+1.0pre6a-7), a
game packaged by the Debian repository.
A. Background and DeÔ¨Ånitions
To identify the root cause of unreproducibility, we Ô¨Årst apply
system call tracing on both rounds of reproducibility validationand collect the traces. A typical system call trace snippet ofthe Ô¨Årst round of build is presented in Fig. 1. From each lineof system call snippet, we can obtain the process identiÔ¨Åer(PID ), the parent process identiÔ¨Åer ( PPID ), the system call
name, and the arguments. We can also obtain each system
call‚Äôs start and end time, which is not illustrated in the Ô¨Ågure.In this work, we are interested in the Ô¨Åle manipulation (suchasread ,write , and rename ) and the process-control-related
system calls (such as execve ). With these system calls, we
could gain more insights into the build process. For instance,
Table II shows the processes that have the last access time tothe inconsistent artifacts, as well as typical build commands.Also, with the PID and PPID information, we are able to
restore the process tree structure of the build.
To model the reproducibility validation, two rounds of
build are introduced as B
1andB2, respectively. Each
round of build comprises a sequence of processes, e.g.,{P
1,P2,P3,...}. SpeciÔ¨Åcally, a process is represented as a
tuple/angbracketleftPID,PPID,slist/angbracketright, where the Ô¨Årst two Ô¨Åelds are self-
explanatory, and the slist Ô¨Åeld indicates a list of system
call traces. Each system call s‚ààslist is represented by a
tuple/angbracketlefttype,start-time ,end-time,source,target,data/angbracketright. For the
type Ô¨Åeld, we are interested in a subset of system calls related
to Ô¨Åle manipulation and process control, including read ,write ,
rename ,execve ,open , and fcntl . The start-time and the end-
time Ô¨Åelds represent the starting and end time of the system
call. The remaining Ô¨Åelds are system call speciÔ¨Åc:
1)read represents the read system call and its variants, such
asreadv and preadv . The source Ô¨Åeld speciÔ¨Åes the Ô¨Åle to
read, and the data indicates the bytes read from source .
2)write represents the write system call and its variants,
such as writev and pwritev . The target Ô¨Åeld speciÔ¨Åes the14213 4212 execve("/usr/bin/ld", ["/usr/bin/ld", [...] "-o", "airstrike" ...
24212 4211 execve("/usr/bin/cc", ["cc", "-o", "airstrike", "-g", "-O2" ...
34000 3999 execve("/usr/bin/make", ["make", "-C", "src" ...
44000 3999 write(1<[...].log>, "cc -o airstrike [...] ./players.o ./airstrike.o ...
54028 4000 execve("/bin/sh", ["/bin/sh", "-c", "cc -o airstrike ...
64000 3999 read(8<pipe:[31387067]>, "./players.c\n./airstrike.c\n ...
74002 4000 write(1<pipe:[31387067]>, "./players.c\n./airstrike.c\n ...
Fig. 1. System call trace snippet for airstrike
Ô¨Åle to write, and the data indicates the bytes written to
target .
3)rename represents the system calls of rename ,renameat ,
renameat2 , and linkat . The source and target Ô¨Åelds are
used to specify the Ô¨Åle names for renaming (changing
from source totarget ).
4)execve represents the family exec system calls, i.e., ex-
ecve and execveat . The data Ô¨Åeld represents the build
command invoked, including both the executable and thearguments.
5)open represents the system calls of open ,openat , and
creat . The source and data Ô¨Åelds indicate the Ô¨Åle and the
corresponding Ô¨Çags assigned to the Ô¨Åle.
6)fcntl manipulates a Ô¨Åle descriptor. The source and the
data Ô¨Åelds indicate the Ô¨Åle and the corresponding Ô¨Çags
assigned to the Ô¨Åle.
Note that we use an underscore (
) to denote that a speciÔ¨Åc
Ô¨Åeld of a system call is ignored. For example, for the rename
system call, only the source and target Ô¨Åelds are used, and the
data Ô¨Åeld is ignored.
DeÔ¨Ånition 1 (runtime value) : Given a process P, its runtime
value is deÔ¨Åned as a set V={s.data|s‚ààP.slist,s.type =
read,write,orexecve}. The underlying motivation of runtime
value is that the data of the read ,write , and execve system
calls play an important role during the propagation of the
inconsistencies.
DeÔ¨Ånition 2 (read/write dependency) : Given two pro-
cesses/angbracketleftPID 1,PPID 1,slist 1/angbracketright,/angbracketleftPID 2,PPID 2,slist 2/angbracketrightof the
same build, a read/write dependency ( PID 1f‚àí‚Üí PID 2)
is established if (1) ‚àÉ/angbracketleftread,st1,et1,f,,data 1/angbracketright‚àà slist 1,
/angbracketleftwrite,st2,et2,,f,data 2/angbracketright‚àà slist 2, such that et1>
et2,o ri f( 2 ) ‚àÉ/angbracketleftread,st1,et1,f1,,data 1/angbracketright‚àà slist 1,
/angbracketleftwrite,st2,et2,,f,data 2/angbracketright‚àà slist 2, and another system call
/angbracketleftrename,st3,et3,f,f1,/angbracketrightfrom any process of the same build,
such that et1>e t 3>e t 25.
DeÔ¨Ånition 3 (parent/child process dependency) : Given two
processes P1andP2with PID sp1andp2, respectively, of
the same round of build, if P1.PPID =P2.PID , there exists
a parent/child process dependency between the two processes,denoted as p
1‚áíp2.
B. Motivating Example
Based on these notations and deÔ¨Ånitions, we next present a
running example to motivate R EPTRACE . With the captured
5In this deÔ¨Ånition, only single rename is considered in this type of
dependency. It is straightforward to extend to the case of multiple renames.In this work, no signiÔ¨Åcant difference is observed between the two variants.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. Dependency graph for airstrike
TABLE II
INCONSISTENT ARTIFACTS AND TYPICAL BUILD COMMANDS FOR THE
DEPENDENCY GRAPH OF airstrike
PID Artifact
4420 ./usr/games/airstrike
PID Build command
4420 objcopy [ ...] debian/airstrike/usr/games/airstrike‚Äù
4419 strip [ ...] debian/airstrike/usr/games/airstrike‚Äù
4242 cp ‚ÄìreÔ¨Çink=auto -a, debian/tmp/usr/games, debian/airstrike//usr/4240 install airstrike [ . . . ]/usr/games/airstrike
4213 ld [ ...] - o airstrike [ ...] ./players.o ./airstrike.o [ ...]
4021 as -I [ ...] - o players.o /tmp/cc3wloBL.s
4142 as -I [ ...] - o airstrike.o /tmp/ccLbhlnX.s
4212 collect2 [ ...] - o airstrike [ ...] ./players.o ./airstrike.o [ ...]
4208 sh -c cc -o airstrike [ ...] ./players.o ./airstrike.o [ ...]
4000 make -C src airstrike
4002 Ô¨Ånd . -name *.c
system call traces, we are able to capture the dependencies
between the processes within the same build. The depen-dency graph for airstrike contains in total 380 nodes. Each
of node represents a process. Starting from the process in
which the inconsistent artifact ./usr/games/airstrike is last
accessed (process with PID 4420), we are interested in how
the inconsistency is introduced by the root cause, and how itis propagated.
Fig. 2 shows part of the dependencies between the pro-
cesses for airstrike . In the Ô¨Ågure, the solid arrows and the
dashed arrows indicate the read/write dependencies and the
parent/child process dependencies, respectively. By traversingthe dependency graph, we can locate the root cause for the
unreproducibility. However, there may exist many irrelevantdependencies in the graph. The reason is that the criterionfor establishing dependencies between process is loose, anddoes not take the read/written data into consideration. We
should note that not all these processes in the graph introduce
inconsistencies between the two builds. For example, considerthe build command ldin the process with PID 4213, which
is the GNU linker to create an executable from object Ô¨Åles.With the dependency rule described in DeÔ¨Ånition 2 ,w eh a v et o
further investigate all the processes that write to the associated
object Ô¨Åles. There are 42 object Ô¨Åles during the link stage,leading to 42 edges in the dependency graph. However, inthis case, all the object Ô¨Åles are actually consistent betweendifferent builds, implying that the corresponding edges allrepresent irrelevant dependencies.
In fact, the inconsistency for airstrike results from the
order of the linker arguments; the order is propagated fromits parent process (with PID 4212). The corresponding build
command is collect2 ,a GCC utility to arrange to call various
initialization functions, and invoke the linker. By carefullyinspecting the traces, we Ô¨Ånd that the dependency between thispair of processes could be revealed from the text similarity
between their build command arguments (4213 ‚áí 4212).
Following this clue, we could traverse to the process with
PID 4208 ( cc). At this point, the hint for further traversal
(4208‚áí4000) comes from the data Ô¨Åeld of the write system
call for the make command (see Table II). Finally, we can
discover a dependency toward a Ô¨Ånd command (4000
f‚àí‚Üí
4002), where f=pipe:[31387067], indicating that the make
command reads the output of Ô¨Ånd through a pipeline. To this
end, we could gain better understanding for the root cause ofthe inconsistent artifact, i.e., the Ô¨Åle traversal order of Ô¨Ånd is
not guaranteed to be deterministic. Consequently, because the
link order relies on the output of Ô¨Ånd , the build artifact turns
out to be unreproducible.
Based on these observations, R
EPTRACE Ô¨Ålters out the build
commands that write identical data between the two builds
of the validation; this Ô¨Åltering can effectively simplify the
dependency graph. Second, to identify the parent/child processdependencies, we calculate the similarity of the runtime valuesof the parent process and the child process, and establishdependencies only for those parent/child processes that share
similar runtime values. In this way, we could identify the
relevant dependencies without introducing too many irrelevantdependencies.
III. O
URREPTRACE FRAMEWORK
In this section, we describe the design and implementation
of the proposed R EPTRACE framework. As illustrated in
Fig. 3, given the source package, we Ô¨Årst adopt the toolchain of reproducibility validation to build the source codeunder the build environments with variations. During thebuild process, we collect the system call traces of the twobuilds using strace [14], a popular diagnosis utility. Then, we
construct the dependency graph based on the sliced, abstractedsystem call traces, which are produced by applying differentialanalysis over the two sets of system call traces. After that,
we intend to augment the dependency graph by detecting
the parent/child process dependencies with runtime values.By improving the dependency graph with the runtime-value-induced dependencies, the root causes could be better locatedwith the traversal over the improved dependency graph.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Fig. 3. The R EPTRACE framework
A. Dependency Graph Generation and Augmentation
As mentioned in Section I, a major challenge of analyzing
system call traces lies in the massive volume of the gathereddata. To extract the useful information, meanwhile reducingthe noises, our key idea is to perform differential analysis ofthe system call traces. In this work, because we are interestedin how the inconsistencies are generated between multiplebuilds, and how these inconsistencies are propagated to thebuild artifacts, we construct the dependency graph basedon the differences extracted from the system call traces. In
particular, in the dependency graph produced by R
EPTRACE ,
the read/write dependencies are replaced with the difference-induced dependencies, as deÔ¨Åned below:
DeÔ¨Ånition 4 (difference-induced dependency) : For the
two builds B
1andB2of the reproducibility validation,
write-diff is denoted as a set/uniontext
P‚ààB1/uniontext
s‚ààP.slist
s.type =writemd5(s.data )‚àí
/uniontext
P‚ààB2/uniontext
s‚ààP.slist
s.type =writemd5(s.data ). Given two processes
/angbracketleftPID 1,PPID 1,slist 1/angbracketright‚ààB1,/angbracketleftPID 2,PPID 2,slist 2/angbracketright‚ààB1,
a difference-induced dependency (DID, denoted as
PID 1f/arrowhookleft‚àí‚Üí PID 2) is established, if PID 1f‚àí‚Üí PID 2,
and‚àÉ/angbracketleft write,st,et,,f,data/angbracketright‚àà slist 2, such that
md5(data) ‚ààwrite-diff .
Algo. 1 shows the pseudo code of the dependency graph
construction based on difference-induced dependencies. The
proposed algorithm comprises two phases. First, the set write-
diff is calculated, based on the data Ô¨Åeld of each write system
call. The unique feature of our graph construction is that, toreduce the noises within the system calls, the dependencypropagation focuses on the inconsistencies generated by thewrite system calls between builds. Then, each pair of write and
read system calls are examined whether a difference-induced
dependency should be established between the correspondingprocesses. In particular, for each write system call s
1with
respect to write-diff (Line 6), we examine whether there exists
aread system call reading from s1.dest after time s1.et. If so,
a dependency is established (Lines 8‚Äì12). Similarly, if the Ô¨Åles
1.dest is renamed by a rename system call s3tos3.dest , and
later read by a read system call, a dependency should also be
established (Lines 13‚Äì18).Algorithm 1: Difference-based dependency graph generation
Input: System call traces for read ,write , and rename
1begin
2 G‚Üêemptygraph
3 write-hash 1‚Üê/uniontext
P‚ààB1/uniontext
s‚ààP.slist
s.type =writemd5(s.data )
4 write-hash 2‚Üê/uniontext
P‚ààB2/uniontext
s‚ààP.slist
s.type =writemd5(s.data )
5 write-diff ‚Üêwrite-hash 1‚àíwrite-hash 2
6 for write system call s1where md5( s1.data )‚ààwrite-diff do
7 pid-write ‚Üêpid-of (s1)
8 for read system call s2do
9 ifs2.src =s1.dest ands2.et > s 1.et then
10 pid-read‚Üêpid-of (s2)
11 add-edge (G,pid-read ,pid-write )
12 end
13 for rename system call s3do
14 ifs3.src=s1.dest ands3.dest =s2.src and
s2.et>s 3.et>s 1.etthen
15 pid-read‚Üêpid-of (s2)
16 add-edge (G,pid-read ,pid-write )
17 end
18 end
19 end
20 end
21 return G
22end
Furthermore, to tackle the challenge of the uncertain par-
ent/child process dependency, R EPTRACE utilizes the text
similarity of the runtime values. As discussed in Section II,the runtime values passed between the processes can be usedto reveal the dependencies. In particular, for script-based buildsystems, the runtime values are mostly in the format of plaintext. Consequently, we could leverage text similarity to make
decisions on whether dependencies should be established.
SpeciÔ¨Åcally, the relevance value is calculated as follows.
DeÔ¨Ånition 5 (relevance value): Given two processes with
PID sp
1andp2, each with a sequence of runtime values
V1={v11,v12,...v 1m}andV2={v21,v22,...v 2n}, the
relevance between the two processes is calculated as
relevance (p1,p2) = max
v1‚ààV1,v2‚ààV2
{max{cosSim (v1,v2),lcsSim (v1,v2)}},(1)
wherecosSim andlcsSim represent the cosine-based [15]
and the longest-common-substring-based [16] similarity, re-spectively. Note that for lcsSim , we consider the longest
common substring percentage, with the value ranging within[0,1]. The motivation behind the similarity measurement is
that the length of the runtime values might be of arbitrary
length. Hence, using only one type of similarity might notbe effective for various cases. Specially, we skip the pairs ofruntime values when the runtime values contain binary data byassigning 0 to the similarity value. With the relevance value,the runtime-value-induced dependency is deÔ¨Åned as follows.
DeÔ¨Ånition 6 (runtime-value-induced dependency) :G i v e n
two processes with PID sp
1andp2of the same round of
build, there exists a runtime-value-induced dependency (RID,
denoted as p1I=‚áíp2)i fp1‚áíp2, and the relevance value
between the processes is larger than the pre-deÔ¨Åned threshold.
Based on DeÔ¨Ånition 6 , the dependency graph constructed
with Algo. 1 can be further improved based on Algo. 2. For

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Algorithm 2: Dependency graph augmentation
Input: Dependency graph G, relevance threshold THRESHOLD
1begin
2 G/prime‚ÜêG
3 for node‚ààG/primedo
4 PID‚Üêpid-of (node )
5 parent-pid ‚Üêparent-of (node )
6 Calculate relevance with Eq. 1.
7 ifrelevance >THRESHOLD then
8 add-edge (G/prime,PID,parent-pid )
9 end
10 end
11 return G/prime
12end
each node that represents a process, we calculate its relevance
value with its parent process. If the relevance value is greaterthan the given threshold, a runtime-value-induced dependencyshould be established.
Running example : Using the package airstrike , we explain
how the two mechanisms work. First, when evaluating theprocess with PID 4213 (the ldcommand), for those input
Ô¨Åles (of the ldcommand) that are consistent between builds,
it is obvious that their corresponding write system calls are
associated with the same hash values. Hence, these processes
could be neglected. Second, similarly, to demonstrate that theparent/child process dependency works, consider the child pro-cess (with PID 4213) and the parent process (with PID 4212).
The relevance value calculated by Eq. 1 is 0.9993, whichprovides strong evidence that there should be a dependency
between the two processes.
B. Graph-Traversal-based Causality Analysis
After constructing and augmenting the dependency graph,
R
EPTRACE traverses the graph, searching for the root causes
for the unreproducible builds. As shown in Algo. 3, R EP-
TRACE starts the traversal from the nodes that represent the
processes directly accessing the inconsistent artifacts. From
these nodes, R EPTRACE performs a breadth-Ô¨Årst search, and
obtains a set of nodes without outgoing edges to other un-visited nodes in the graph (Line 2). Since the edges in thedependency graph indicate the trajectories of the inconsis-tency propagation, these nodes indicate that the inconsistencypropagation stops at these nodes, i.e., no more inconsistenciespropagated to other processes. With these nodes obtained,
R
EPTRACE then ranks them based on their relevance values
among other nodes in the dependency graph (Lines 6‚Äì11).
The higher the accumulated relevance value is, the higherprobability the corresponding nodes would be the root causes.
Finally, to realize the Ô¨Åle-level localization, we start from
the ranked list of build commands retrieved by Algo. 3, insearch of the most relevant Ô¨Åles. More speciÔ¨Åcally, based
on the preliminary investigation, two different paradigms of
patches are identiÔ¨Åed.
‚Ä¢Case 1 : for those packages in which scripts are re-
sponsible for the unreproducibility, such as the wildcardfunction of MakeÔ¨Åles and the hash-table traversal of Perlscripts, the scripts are to be patched, being opened in
the same process as the one where the root causes are
identiÔ¨Åed.Algorithm 3: Graph-traversal-based root-cause localization
Input: Improved dependency graph G
1begin
2 node-set‚Üêbreadth-Ô¨Årst-search (G)
3 for node m‚àànode-set do
4 PID m‚Üêpid-of (m)
5 node-weight [PID m]‚Üê0
6 for node n‚ààGdo
7 PID n‚Üêpid-of (n)
8 node-weight [PID m]‚Üê
node-weight [PID m]+relevance (PID m,PID n)
9 end
10 end
11 ranked-list ‚Üêsort (node-set ,node-weight )
12 return ranked-list
13end
Algorithm 4: File-level localization
Input: Node set node-set , Weights for the nodes node-weights , File set Ô¨Åle-set
1begin
2 for Ô¨Ålef‚ààÔ¨Åle-set do Ô¨Åle-weight [f]‚Üê0
3 for node m‚àànode-set do
4 PID m‚Üêpid-of (m)
5 switch typeof (m)do
6 case 1: search in the current process do
7 for Ô¨Ålefopened with CLOEXEC Ô¨Çags do
8 Ô¨Åle-weight [f]‚Üê
Ô¨Åle-weight [f]+ node-weight [PID m]
9 end
10 end
11 case 2: search in the parent process do
12 PPID m‚Üêparent-of (m)
13 t1‚Üêget-execve-text (m)
14 for Ô¨Ålefopened with CLOEXEC in process PPID mdo
15 t2‚Üêget-text (f)
16 sim‚Üêmax{cosSim (t1,t2),lcsSim (t1,t2)}
17 Ô¨Åle-weight [f]‚Üê
Ô¨Åle-weight [f]+ node-weight [PPID m]√ósim
18 end
19 end
20 end
21 end
22 ranked-Ô¨Åle-list ‚Üêsort (Ô¨Åle-set ,Ô¨Åle-weight )
23 return ranked-Ô¨Åle-list
24end
‚Ä¢Case 2 : for the build commands that may introduce in-
consistencies, such as the gzip and the date commands. In
this case, the scripts to be patched are typically opened inthe parent process of the identiÔ¨Åed process. For example,
in the motivating example airstrike , the inconsistency is
introduced by the Ô¨Ånd command. However, the Ô¨Åle to
be patched is the MakeÔ¨Åle in which Ô¨Ånd is invoked (see
Fig. 4).
To distinguish the two cases, we adopt a heuristic rule
based on the Ô¨Çags associated to each opened Ô¨Åle. In particular,the scripts are typically opened with the CLOEXEC Ô¨Çags(FD
CLOEXEC or O CLOEXEC), indicating that the Ô¨Åles
are to be closed automatically after successful execve system
calls. During our preliminary experimentation, we observethat the CLOEXEC Ô¨Çags are generally effective in classifyingthe scripts and the other Ô¨Åles, with two exceptions, i.e., theprocesses invoking Python scripts or the tar compressing
utility, which are processed in a specialized way. With the
heuristic classifying rule, the process of localization for the
Ô¨Åle to patch is described in Algo. 3.
Running example : For the package airstrike , after obtaining
the dependency graph, the root cause for the unreproduciblebuild can be found by traversing the graph. As shown in Fig. 2,

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. --- a/src/Makefile
+++ b/src/Makefile
@@ -2,7 +2,7 @@
#
CFLAGS += $(shell sdl-config --cflags) -Isprite -I. -Isupport -DINLINE=inline
CFLAGS += ‚Äòdpkg-buildflags --get CFLAGS‚Äò
-CFILES:= $(shell find . -name ‚Äô *.c‚Äô)
+CFILES:= $(sort $(shell find . -name ‚Äô *.c‚Äô))
OBJECTS:= $(CFILES:.c=.o)
Fig. 4. Patch snippet for airstrike
we can observe that the node with zero outgoing unvisited edge
(process with PID 4002, the Ô¨Ånd command) is the root cause.
Furthermore, since no Ô¨Åle is opened with the CLOEXEC Ô¨Çags
in the process with PID 4002, R EPTRACE checks its parent
process, and locates the Ô¨Åle to be patched ( src/MakeÔ¨Åle ), which
is shown in Fig. 4.
IV . E V ALUA TION
In this section, we apply R EPTRACE on real-world software
packages and evaluate the effectiveness of R EPTRACE .W e
seek to investigate the following research questions (RQs):
1)RQ1 :I sR EPTRACE effective in locating the root causes
for unreproducible builds?
2)RQ2 : How effectively can the DID and RID mechanisms
improve the construction of dependency graphs?
3)RQ3 :I sR EPTRACE sensitive to the parameter in the
runtime-value-induced dependency?
4)RQ4 :I sR EPTRACE helpful in locating the problematic
Ô¨Åles to patch?
Among these RQs, RQ1 evaluates the ability to accurately
identify the root causes for unreproducible builds, becausethe command-level localization is the unique feature of R
EP-
TRACE . In particular, by comparing various variants of R EP-
TRACE , we intend to examine how each component con-
tributes to R EPTRACE . RQ2 evaluates the impact of the two
mechanisms on the search space. By comparing the statisticsof the dependency graphs induced by the different variants of
R
EPTRACE , we could gain more insights into both the DID
and RID mechanisms. RQ3 evaluates the sensitivity of the
parameter on R EPTRACE . Finally, RQ4 evaluates the ability
of Ô¨Åle-level localization of R EPTRACE by comparing with the
best known results.
A. Evaluation Setup
REPTRACE is implemented in Java 1.8, and the evaluation
is conducted on an Intel Xeon 2.5 GHz server with 16 GBmemory, running Debian 9.6.
Metrics . To evaluate the effectiveness of R
EPTRACE , we mea-
sure the accuracy rate, precision, recall, F-1 score, and MeanReciprocal Rank (MRR) in identifying root causes for unre-producible builds. The metrics are computed by examining theranked build commands (RQ1) and Ô¨Åles (RQ4) returned by
R
EPTRACE . The Top- Nbuild commands/Ô¨Åles in the ranked
list are called the retrieved list, and are compared with the
relevance list to compute the precision, recall, and F-1 score(represented using P@N ,R@N , and F-1@N , respectively). In
particular, Top- Naccuracy rate, e.g., A@N , is used to measure
the percentage of packages for which the Top- Nlist provides
(a) Box-plot statistics
 (b) Comparison of build time
Fig. 5. Comparison of build time statistics
at least one problematic command/Ô¨Åle [17]. Besides, MRR is
an aggregate metric to evaluate the quality of the retrievedresults.
Tools under comparison . In our evaluation, we compare
R
EPTRACE with a set of variants. First, a set of three
variants of R EPTRACE are chosen, each considering part
of the mechanisms of R EPTRACE . For example, we denote
REPTRACE (¬¨DID) as the variant of R EPTRACE in which the
difference-induced dependency is not employed. There are also
two other variants denoted as R EPTRACE (¬¨RID) and R EP-
TRACE (¬¨DID,¬¨RID), in which parent/child dependencies are
not considered. With these variants, we investigate how theproposed mechanisms collaborate as an integrated framework.Second, we compare R
EPTRACE with R EPLOC, the state-of-
the-art tool for Ô¨Åle-level localization [7].
Dataset . We use a set of 180 packages from the Debian repos-
itory, following previous work [7] as our evaluation dataset.The reasons that the scale of the dataset is relatively small areas follows. First, due to the evolution of the Debian repository,
especially the build tool chain and the build dependencies,
some old packages used in the previous work could not be builtfrom source. Second, due to the necessity of manual annotationfor the root causes, to evaluate the ability of causality analysis,we do not consider all the packages as in the previous work.Besides, since we focus on the identiÔ¨Åcation of the root causes,which are represented as build commands, we do not considerthe packages for which the patches are within source code.
In the dataset, the root causes cover the following cate-
gories: timestamp (such as gzip ,date , and tarthat capture the
current date and/or time), randomness (such as dict/hash-table
traversal of Python and Perl scripts), Ô¨Åle ordering (such as Ô¨Ånd
inÔ¨Åndutils and the wildcard issue of make ), locale (such as
sort and lynx without setting the locale environment variable),
uname and hostname ( uname and hostname that capture the
system information).
To construct the ground truth for evaluating causality anal-
ysis, we check the execve system call traces that match the
patches obtained from the bug-tracking system of Debian.For each package, we check not only according to the build
command line text, but also the context indicated by the path
from the root of the process tree to the problematic build

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE III
RESULTS OF REPTRACE AND OTHER APPROACHES FOR THE COMMAND -LEVEL LOCALIZA TION TASK
Approach A@1 A@5 A@10 P@1 P@5 P@10 R@1 R@5 R@10 F-1@1 F-1@5 F-1@10 MRR
REPTRACE (¬¨DID,¬¨RID) 0.0944 0.1056 0.1500 0.0944 0.0300 0.0200 0.0824 0.1014 0.1444 0.0850 0.0431 0.0336 0.1042
REPTRACE (¬¨DID) 0.0389 0.0833 0.1333 0.0389 0.0278 0.0200 0.0280 0.0787 0.1259 0.0306 0.0366 0.0322 0.0663
REPTRACE (¬¨RID) 0.6056 0.6556 0.6556 0.6056 0.2533 0.1461 0.3916 0.5841 0.5912 0.4401 0.3040 0.1921 0.6306
REPTRACE 0.6611 0.8944 0.9000 0.6611 0.3156 0.1839 0.4524 0.8129 0.8319 0.4993 0.3960 0.2510 0.7672
TABLE IV
RESULTS OF WILCOXON SIGNED RANK TEST FOR THE COMMAND -LEVEL
LOCALIZA TION TASK
Metrics R EPTRACE vs. p -value Effect size
P@1REPTRACE (¬¨DID,¬¨RID) <0.0001 0.9808
REPTRACE (¬¨DID) <0.0001 0.9333
REPTRACE (¬¨RID) 0.1228 0.2381
R@1REPTRACE (¬¨DID,¬¨RID) <0.0001 0.9707
REPTRACE (¬¨DID) <0.0001 0.9236
REPTRACE (¬¨RID) 0.0372 0.3555
command. Meanwhile, for the Ô¨Åle-level localization, we adopt
an approach in the literature [7], i.e., we extract the Ô¨Åle namesfrom the patches as the ground truth.
Overhead of system call tracing .A sR
EPTRACE is built
upon system call tracing, we measure to what extent systemcall tracing slows down the build process. We compare thestatistics of the build time under two circumstances, i.e., withor without system call tracing. In Fig. 5, the box-plots andthe scatter plot represent the distribution of build time overall the packages. From the Ô¨Ågure, we observe that whenusing system call tracing, build time increases accordingly.For the two cases, the median build time is 4.77s and 8.84s,respectively. Meanwhile, the maximum build time for the twocircumstances is of the same order of magnitude. Such resultsindicate that the overhead of system call tracing is acceptablefor industrial-level builds.
B. RQ1: Command-Level Localization
As discussed in Section III, a unique feature of R
EPTRACE
lies in its ability to locate the root causes for unreproducible
builds. Prior to this work, the localization task realized by
REPLOC [7] is mainly at the Ô¨Åle level. Hence, the guidance
toward the patch of the unreproducible builds tend to be
limited. In contrast, with the system call tracing, especially thedata provided by the execve system call, R
EPTRACE is able
to identify the potential build commands that are responsiblefor the unreproducible issues.
In this RQ, we compare the results of causality analysis
in Table III. The table is organized as follows. The Ô¨Årst
column represents the names of the approaches in comparison,including R
EPTRACE and its three variants. Then, Columns
2‚Äì14 indicate the measurements employed to evaluate eachapproach, i.e., the accuracy rate, precision, recall, F-1 score,
and MRR.
From the table, we could observe that R
EPTRACE is able to
effectively locate the root causes responsible for the unrepro-ducibility. Especially, when considering the topmost retrievedbuild command, R
EPTRACE is able to achieve an accuracy
rate of 0.6611. The accuracy rate increases to 0.9000 if we
consider the Top-10 results, implying that for 90.00% of thepackages, we can obtain at least one build command that isamong the root causes by traversing the Top-10 results. In
contrast, the results for the variants of R
EPTRACE are not so
promising. We should note that, from the table, we observethat the precision and F-1 score values are not very high.The reason for the low values of precision and F-1 scoremight be that, for the unreproducible packages, the numberof processes that construct the root causes is relatively small.
Within the dataset, there are 99 packages for which there
is single build command that causes unreproducibility, andthe average number of root causes is 3.41. Consequently, theprecision value for the Top-10 results tends to be low, alsoinÔ¨Çuencing the F-1 score. Under such circumstance, the MRR
metric reÔ¨Çects the ability to rank root causes to the top of
results. From the table, we observe that R
EPTRACE is able to
achieve the best MRR.
To gain higher conÔ¨Ådent on drawing conclusion from the
comparison results, we employ the nonparametric Wilcoxon
signed rank test. For the null hypothesis, we assume that
there exists no signiÔ¨Åcant difference with respect to the resultsobtained by the approaches under comparison. Table IV showsthe comparison results, organized as follows. The Ô¨Årst columnindicates the metrics over which the comparison is conducted.The second column speciÔ¨Åes the approaches against which
R
EPTRACE is compared. The third and fourth columns present
the p-value and effect size (also known as the rank-biserial
correlation) [18], respectively. From the comparison results,we observe that under each comparison scenario except whencomparing R
EPTRACE with R EPTRACE (¬¨RID) over the P@1
metric, the null hypothesis is rejected, with p-value<0.05.
This observation conÔ¨Årms that the DID mechanism contributesmore to the performance.
Fig. 6 shows the results obtained by R
EPTRACE and its
variants, against the length of the retrieved list. We con-sider the precision and recall as the measurements. Whenwe compare the behavior of the variants, we could measurethe improvement brought by each mechanism. For exam-
ple, when we compare R
EPTRACE (¬¨DID,¬¨RID) with R EP-
TRACE (¬¨RID), we could see that for both the measurements,
the curves for R EPTRACE (¬¨DID,¬¨RID) are always below
those of R EPTRACE (¬¨RID). This observation conÔ¨Årms the
contribution of the DID mechanism, which not only providesa smaller dependency graph (see RQ2 for more discussion),but also helps locate the root cause more accurately. A
similar observation could be made when we compare R
EP-
TRACE (¬¨DID) and R EPTRACE . Furthermore, to understand
whether the RID mechanism works, we compare R EPTRACE
with R EPTRACE (¬¨RID). From Fig. 6, we could see that
REPTRACE outperforms R EPTRACE (¬¨RID).
Answer to RQ1: REPTRACE is able to effectively identify

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. (a) Trend for precision
(b) Trend for recall
Fig. 6. Comparison of R EPTRACE and its variants
the root causes that are responsible for unreproducible builds,
and these root causes are helpful in understanding why repro-
ducibility validation fails.
C. RQ2: Impacts on Dependency Graph Construction
In R EPTRACE , there are two main mechanisms, i.e., the
reduction based on differential analysis, which intends toshrink the scale of search space, and the runtime-value-baseddependency identiÔ¨Åcation, which may enlarge the dependencygraph. Hence, in this RQ, we analyze the statistics of thedependency graphs constructed by R
EPTRACE and its variants,
to explore whether the DID mechanism is able to achieve thereduction of search space and yet preserve the precision incausality analysis.
To gain an intuitive understanding of the inÔ¨Çuence of
the two proposed mechanisms, in Fig. 7, we present thecomparison of the graph statistics of the dependency graphgenerated by the variants of R
EPTRACE , respectively. For each
variant, we report the statistics of the dependency graph for allthe packages, to reÔ¨Çect the inÔ¨Çuence of each mechanism. Foreach sub-Ô¨Ågure, we plot the distribution of typical properties inlog scale, including the number of nodes ( num
nodes ), number
of edges ( num edges ), average node degree ( avg degree ), and
maximum node degree ( max degree ). All the statistics are
illustrated as box-plot.
From the Ô¨Ågure, we could observe the following two inter-
esting phenomena. On one hand, when comparing Fig. 7(a)and Fig. 7(b), we could see the reduction effect of the DID
mechanism. Without the DID-based reduction mechanism,
there are on average 169.37 nodes in the dependency graph.Meanwhile, with the reduction, there are on average 15.64nodes in the dependency graph, being of a much smaller scale.Also, for other graph attributes, similar phenomena could beobserved. For instance, the maximum node degree of the graphfor R
EPTRACE (¬¨DID,¬¨RID) is larger than that for R EP-
TRACE (¬¨RID), implying that without the DID mechanism,
there may exist nodes with more dependencies. Consequently,the possibility of incorporating irrelevant dependencies mayalso increase. This observation to some extent explains whythe results of the variants without DID are not satisfying inRQ1.
On the other hand, when comparing Fig. 7(b) and Fig. 7(d),
we could observe that if the RID mechanism is consideredover the DID-reduced dependency graph, there are not manynodes and edges introduced by the runtime-value-induceddependency mechanism. Hence, the overhead caused by the
runtime-value-induced dependencies is in general acceptable.
In contrast, when comparing Fig. 7(a) and Fig. 7(c), weobserve a drastic increase in attribute values of dependencygraph, implying that if the RID mechanism is considered overthe dependency graph without reduction, the correspondinggraph would be much more complex. This observation to someextent explains why R
EPTRACE (¬¨DID) performs the worst
among the variants.
Furthermore, Fig. 8 shows the distribution of the execution
time in log scale for R EPTRACE and its variants. From the
Ô¨Ågure, we could observe that R EPTRACE (¬¨RID) is the fastest
variant, with median execution time of 5.88s. The reason is
that the scale of the dependency graphs for this variant issmaller than other variants. R
EPTRACE is slower, with median
execution time of 9.51s, but is within the same order ofmagnitude. In contrast, the two variants without DID are muchslower. In particular, R
EPTRACE (¬¨DID) is the least efÔ¨Åcient
variant in comparison, due to the lack of reduction realized bythe DID mechanism, and the extra dependencies introducedby the RID mechanism. This observation also conforms withFig. 7(c), which presents the statistics of the most complex
dependency graph.
Answer to RQ2: In this RQ, we conÔ¨Årm that the DID
mechanism is able to effectively reduce the search scope ofthe localization task. Also, the extra edges introduced by the
RID mechanism is acceptable when the DID mechanism is
applied. With the dependencies induced by the differences ofthe write system call and the runtime values, R
EPTRACE is
able to achieve median execution time of 9.51s.
D. RQ3: Parameter Sensitivity Analysis
As mentioned in Section III-A, we introduce a threshold
in the RID mechanism, to detect the potential dependenciesbetween parent processes and child processes. Hence, we shallevaluate R
EPTRACE ‚Äôs sensitivity to the threshold. Fig. 9 shows
the results of the sensitivity analysis over a subset of the40 randomly selected packages. The Ô¨Ågure is organized asfollows. The x-axis represents the value of the parameter,
which ranges from 0 to 1, with the step of 0.10. The y-axis
indicates the quality measurement, i.e., the precision and recallconsidering the Top-1 result.
From the Ô¨Ågure, we could observe that, R
EPTRACE is not
very sensitive to the threshold, in terms of both measurements.For example, for all the parameter values, the precision value

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. (a) R EPTRACE (¬¨DID,¬¨RID)
 (b) R EPTRACE (¬¨RID)
(c) R EPTRACE (¬¨DID)
 (d) R EPTRACE
Fig. 7. Dependency graph statistics for variants of R EPTRACE
Fig. 8. Comparison of execution time for variants of R EPTRACE
is always above 70.00%. Also, both the recall and accuracy
rate reach the best results around [0.30,0.70].
Answer to RQ3: REPTRACE is not very sensitive to the pa-
rameter, and generalizes well over different packages. Hence,for the other parts of the evaluation, the parameter value isassigned with 0.50.
E. RQ4: File-Level Localization
In this RQ, we evaluate whether R
EPTRACE is effective
in locating the problematic Ô¨Åle, in which the unreproducibleissues should be patched. SpeciÔ¨Åcally, we report the resultsobtained by R
EPTRACE and other approaches under compar-
ison in Table V. The table is organized similarly as Table III,except that R
EPLOCis also considered.
From the table, we can observe that R EPTRACE is able
to rank the relevant Ô¨Åles at the top of the retrieved list.Compared with R
EPLOC, the Top-1 accuracy rate is 0.6667,
which is much higher than the results achieved by R EPLOC.
The underlying reason might be that with the system-call-based dependency graph, R
EPTRACE is able to accurately
locate the build commands for which there exists at leastone path in the dependency graph leading to the inconsistentartifacts. Consequently, the Ô¨Åle ranking based on these buildcommands could provide valuable hints toward the problem-
atic Ô¨Åles to be patched. In contrast, R
EPLOC relies on the
Fig. 9. Results of parameter sensitivity
build-log-based query augmentation, which is based on the
text similarity between the inconsistent artifact names and thebuild commands, and using this text similarity tends to be lessaccurate.
In addiction, an interesting observation is over the variants
without the DID mechanism. For example, despite not per-forming well in RQ1, R
EPTRACE (¬¨DID) achieves an R@10
of 0.7029 in this RQ. A similar phenomenon could be foundfor R
EPTRACE (¬¨DID,¬¨RID) as well. The reason might be
that the retrieved build commands by these two variants maystill be relevant to the inconsistent artifacts, even when they arenot the root causes for unreproducibility. Hence, these buildcommands may be helpful in Ô¨Åle-level localization.
Similar to RQ1, we present the results of hypothesis testing
in Table VI. The table is organized the same way as RQ1. Fromthe table, similar phenomena could be observed. Moreover,when comparing the topmost retrieved Ô¨Åles by R
EPTRACE
with R EPLOC, we Ô¨Ånd that R EPTRACE outperforms R EPLOC,
except that the p-value is slightly larger than 0.05 when the
recall metric is considered.
Answer to RQ4: REPTRACE is able to accurately locate the
problematic Ô¨Åles that are responsible for the unreproduciblebuilds. From the comparisons with both the state-of-the-art
approach and the variants of R
EPTRACE ,R EPTRACE demon-
strates the superiority over these approaches.
V. T HREA TS TO VALIDITY
In our evaluation, there are two major threats to validity.
First, an important threat to validity is that we assume
the completeness of the necessary system call traces, whichmay introduce inconsistencies during the build process. Forexample, in our evaluation, all the builds are conducted underan isolated environment, and do not need to communicatewith external systems once the build dependencies are met.
Hence, we do not capture the network-related system calls.
In real-world environments, inconsistencies could originatefrom various sources. Hence, the linkage from the inconsistentartifacts toward the root cause may be broken. During theconstruction of the dataset, we have mitigated this issue bymanually inspecting the patches and the build scripts, to ensurethat the unreproducible issues are caused within the package.
Second, in our evaluation we adopt the off-the-shelf di-
agnosis tool strace to capture the system call traces. strace
is based on ptrace , and is available under GNU/Linux. To
generalize R
EPTRACE to other platforms, adaptations have to

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE V
RESULTS OF REPTRACE AND OTHER APPROACHES FOR THE FILE -LEVEL LOCALIZA TION TASK
Approach A@1 A@5 A@10 P@1 P@5 P@10 R@1 R@5 R@10 F-1@1 F-1@5 F-1@10 MRR
REPTRACE (¬¨DID,¬¨RID) 0.3889 0.7222 0.8000 0.3889 0.1667 0.0933 0.3403 0.6765 0.7598 0.3559 0.2606 0.1634 0.5143
REPTRACE (¬¨DID) 0.2556 0.6778 0.7333 0.2556 0.1567 0.0856 0.2139 0.6445 0.7029 0.2278 0.2462 0.1501 0.4316
REPTRACE (¬¨RID) 0.6444 0.8556 0.8611 0.6444 0.1967 0.1011 0.5727 0.8149 0.8251 0.5957 0.3098 0.1772 0.7320
REPLOC 0.5611 0.8333 0.8722 0.5611 0.1878 0.1017 0.5006 0.7839 0.8343 0.5189 0.2958 0.1780 0.6815
REPTRACE 0.6667 0.8778 0.9056 0.6667 0.2000 0.1067 0.5835 0.8311 0.8695 0.6091 0.3152 0.1868 0.7583
TABLE VI
RESULTS OF WILCOXON SIGNED RANK TEST FOR THE FILE -LEVEL
LOCALIZA TION TASK
Metrics R EPTRACE vs. p -value Effect size
P@1REPTRACE (¬¨DID,¬¨RID) <0.0001 0.7353
REPTRACE (¬¨DID) <0.0001 0.8222
REPTRACE (¬¨RID) 0.3711 0.2000
REPLOC 0.0184 0.2923
R@1REPTRACE (¬¨DID,¬¨RID) <0.0001 0.7131
REPTRACE (¬¨DID) <0.0001 0.8139
REPTRACE (¬¨RID) 0.7168 0.0857
REPLOC 0.0655 0.2485
be made. To mitigate this issue, we model the system calls
in a uniform way (see Section II-B), so that porting to other
platforms would be straightforward. The adaptation could be
realized by replacing strace with a platform-speciÔ¨Åc tracing
system, e.g., DTrace [19] for BSD-like OS and ETW [20] for
Windows.
VI. R ELA TED WORK
A. System Calls
Recent years have witnessed the growing research interests
of leveraging system call traces as a high-quality source ofsystem-wide information, to help boost the performance ofvarious tasks. For instance, Gao et al. [21] propose to usesystem calls to capture the trajectories of malware behav-iors [22], which could be further used to detect intrusion, or
conduct forensic analysis. Licker and Rice [23] address the
challenge of discovering the hidden dependency in the buildscripts, and detect bugs in the build process. Neves et al. [24]develop a system-call-tracing-based diagnosis framework, Fal-con, to achieve trouble-shooting functionality under distributed
environments. Pasquier et al. [25] propose a whole-system
provenance system that leverage system call to capture mean-ingful provenance without modifying existing applications.V an Der Burg et al. [26] address the license compatibilityproblem, and devise a system-call-based approach to detectpotential license conÔ¨Çict. Liu et al. [27] systematically review
the studies focusing on host-based intrusion detection with
system calls.
Unlike the existing system-call-based research, in this work,
we focus on a novel problem domain, i.e., the localization taskof the root causes for unreproducible builds.
B. Reproducibility
As a new research problem, there are relatively few ap-
proaches focusing on the localization task for unreproducible
builds. The most relevant work is the work by Ren et al. [7], inwhich the localization task is modeled as a task of informationretrieval, aiming to search for the problematic Ô¨Åles that areresponsible for the unreproducibility. Also, in their work, thelocalization is realized at the Ô¨Åle level, unlike the level of build
command achieved in this work.
Besides the localization task for unreproducible builds, there
exist a series of closely related research directions. Amongthese directions, a typical example is reproducible research.For example, Guo [28] proposes a system-call-based frame-
work, CDE, which realizes the functionality of packagingthe program-execution environment. Following the idea, there
exist several related approaches, such as ReproZip [11] andProvToolbox [29]. Ivie and Thain [30] make a systematicsurvey for the research topic. Compared with these previousapproaches, which emphasize the success of re-executing the
programs in diverse environments, in this work we are more
interested in tracing back along the system calls, to locate theroot cause for inconsistencies.
VII. C
ONCLUSION
In this paper, we have presented the R EPTRACE framework
to identify the root causes for unreproducible builds. Theframework leverages system call tracing‚Äôs uniform interfacesfor monitoring executed build commands in diverse build
environments. To tackle the challenges of leveraging system-call-tracing-based information, R
EPTRACE Ô¨Ålters irrelevant
dependencies among processes by using the differences of thewrite data and the runtime values. Our extensive evaluationover real-world packages demonstrates that R
EPTRACE is able
to achieve promising solutions for unreproducible builds.
In future work, as R EPTRACE relies on the heuristic detec-
tion of the dependencies between parent processes and childprocesses, we plan to explore more accurate techniques fordependency identiÔ¨Åcation. Also, it would be interesting to ex-
plore the possibility of automatically patching unreproducible
builds.
A
CKNOWLEDGMENTS
Tao Xie is also afÔ¨Åliated with the Key Laboratory of
High ConÔ¨Ådence Software Technologies (Peking University),Ministry of Education. This work is supported in part bythe National Key Research and Development Program of
China under grant no. 2018YF-B1003900, the National Nat-
ural Science Foundation of China under grant no. 61772107,61722202, 61529201, and NSF under grant no. CNS-1564274,CCF-1816615, CNS-1755772.
R
EFERENCES
[1] Reproducible builds team, ‚ÄúDeÔ¨Ånition of reproducible builds,‚Äù https://
reproducible-builds.org/docs/deÔ¨Ånition/, 2018, accessed: 2019-03-04.
[2] M. Perry, ‚ÄúDeterministic builds part one: Cyberwar and global
compromise,‚Äù https://blog.torproject.org/deterministic-builds-part-one-
cyberwar-and-global-compromise, 2013, accessed: 2019-03-04.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. [3] B. Bzeznik, O. Henriot, V . Reis, O. Richard, and L. Tavard, ‚ÄúNix
as HPC package management system,‚Äù in Proceedings of the F ourth
International Workshop on HPC User Support Tools . ACM, 2017, pp.
4:1‚Äì4:6.
[4] ‚ÄúDebian,‚Äù https://www.debian.org/, accessed: 2019-03-04.[5] ‚ÄúGuix,‚Äù https://www.gnu.org/software/guix/, accessed: 2019-03-04.[6] ‚ÄúF-Droid,‚Äù 2019, https://f-droid.org/.[7] Z. Ren, H. Jiang, J. Xuan, and Z. Yang, ‚ÄúAutomated localization
for unreproducible builds,‚Äù in Proceedings of the 40th International
Conference on Software Engineering . ACM, 2018, pp. 71‚Äì81.
[8] S. McIntosh, M. Nagappan, B. Adams, A. Mockus, and A. E. Hassan, ‚ÄúA
large-scale empirical study of the relationship between build technologyand build maintenance,‚Äù Empirical Software Engineering , vol. 20, no. 6,
pp. 1587‚Äì1633, 2015.
[9] Y . R ¬¥egis-Gianas, N. Jeannerod, and R. Treinen, ‚ÄúMorbig: A static
parser for POSIX shell,‚Äù in Proceedings of the 11th ACM SIGPLAN
International Conference on Software Language Engineering . ACM,
2018, pp. 29‚Äì41.
[10] Y . Tang, D. Li, Z. Li, M. Zhang, K. Jee, X. Xiao, Z. Wu, J. Rhee, F. Xu,
and Q. Li, ‚ÄúNodeMerge: Template based efÔ¨Åcient data reduction forbig-data causality analysis,‚Äù in Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security . ACM, 2018,
pp. 1324‚Äì1337.
[11] F. Chirigati, D. Shasha, and J. Freire, ‚ÄúReproZip: Using provenance
to support computational reproducibility,‚Äù in Proceedings of the 5th
USENIX Workshop on the Theory and Practice of Provenance , 2013.
[12] C. Curtsinger and E. D. Berger, ‚ÄúCoz: Finding code that counts with
causal proÔ¨Åling,‚Äù in Proceedings of the 25th ACM Symposium on
Operating Systems Principles . ACM, 2015, pp. 184‚Äì197.
[13] B. Zong, X. Xiao, Z. Li, Z. Wu, Z. Qian, X. Yan, A. K. Singh,
and G. Jiang, ‚ÄúBehavior query discovery in system-generated temporalgraphs,‚Äù Proceedings of the VLDB Endowment , vol. 9, no. 4, pp. 240‚Äì
251, Dec. 2015.
[14] ‚ÄúStrace,‚Äù https://strace.io, accessed: 2019-03-04.[15] ‚ÄúCosine similarity,‚Äù https://commons.apache.org/proper/commons-text/
apidocs/org/apache/commons/text/similarity/CosineSimilarity.html, ac-cessed: 2019-03-04.
[16] ‚ÄúLongest common substring percentage,‚Äù https://www.oracle.com/
webfolder/technetwork/data-quality/edqhelp/Content/processor
library/
matching/comparisons/longest common substring percentage.htm,
accessed: 2019-03-04.
[17] X. Ye, R. Bunescu, and C. Liu, ‚ÄúLearning to rank relevant Ô¨Åles for
bug reports using domain knowledge,‚Äù in Proceedings of the 22nd
ACM SIGSOFT International Symposium on F oundations of SoftwareEngineering . ACM, 2014, pp. 689‚Äì699.[18] D. S. Kerby, ‚ÄúThe simple difference formula: An approach to teach-
ing nonparametric correlation,‚Äù Comprehensive Psychology , vol. 3, p.
11.IT.3.1, 2014.
[19] ‚ÄúDTrace,‚Äù https://dtrace.org, accessed: 2019-03-04.[20] M. Jacobs and M. Satran, ‚ÄúAbout event tracing,‚Äù https://docs.microsoft.
com/en-us/windows/desktop/etw/about-event-tracing, accessed: 2019-03-04.
[21] P . Gao, X. Xiao, Z. Li, F. Xu, S. R. Kulkarni, and P . Mittal, ‚ÄúAIQL:
Enabling efÔ¨Åcient attack investigation from system monitoring data,‚Äù inProceedings of 2018 USENIX Annual Technical Conference . USENIX
Association, 2018, pp. 113‚Äì126.
[22] P . Gao, X. Xiao, D. Li, Z. Li, K. Jee, Z. Wu, C. H. Kim, S. R.
Kulkarni, and P . Mittal, ‚ÄúSAQL: A stream-based query system for real-
time abnormal system behavior detection,‚Äù in Proceedings of the 27th
USENIX Conference on Security Symposium . USENIX Association,
2018, pp. 639‚Äì656.
[23] N. Licker and A. Rice, ‚ÄúDetecting incorrect build rules,‚Äù in
41st ACM/IEEE International Conference on Software Engineering .
ACM/IEEE, 2019, pp. 1234‚Äì1244.
[24] F. Neves, N. Machado, and J. Pereira, ‚ÄúFalcon: A practical log-based
analysis tool for distributed systems,‚Äù in Proceedings of the 48th
Annual IEEE/IFIP International Conference on Dependable Systems andNetworks . IEEE/IFIP , 2018, pp. 534‚Äì541.
[25] T. Pasquier, X. Han, M. Goldstein, T. Moyer, D. Eyers, M. Seltzer, and
J. Bacon, ‚ÄúPractical whole-system provenance capture,‚Äù in Proceedings
of the 2017 Symposium on Cloud Computing . ACM, 2017, pp. 405‚Äì
418.
[26] S. V an Der Burg, E. Dolstra, S. McIntosh, J. Davies, D. M. German, and
A. Hemel, ‚ÄúTracing software build processes to uncover license com-
pliance inconsistencies,‚Äù in Proceedings of the 29th ACM/IEEE Inter-
national Conference on Automated Software Engineering . ACM/IEEE,
2014, pp. 731‚Äì742.
[27] M. Liu, Z. Xue, X. Xu, C. Zhong, and J. Chen, ‚ÄúHost-based intrusion
detection system with system calls: Review and future trends,‚Äù ACM
Computing Surveys , vol. 51, no. 5, p. 98, 2018.
[28] P . J. Guo, ‚ÄúCDE: Run any linux application on-demand without installa-
tion,‚Äù in Proceedings of the 25th USENIX International Conference on
Large Installation System Administration . USENIX Association, 2011,
pp. 2‚Äì2.
[29] L. Moreau, B. V . Batlajery, T. D. Huynh, D. Michaelides, and H. Packer,
‚ÄúA templating system to generate provenance,‚Äù IEEE Transactions on
Software Engineering , vol. 44, no. 2, pp. 103‚Äì121, 2018.
[30] P . Ivie and D. Thain, ‚ÄúReproducibility in scientiÔ¨Åc computing,‚Äù ACM
Computing Surveys , vol. 51, no. 3, p. 63, 2018.

Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. 