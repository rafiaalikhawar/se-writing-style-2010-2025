SPAIN: Security Patch Analysis for Binaries
Towards Understanding the Pain and Pills
Zhengzi Xu∗, Bihuan Chen∗‡, Mahinthan Chandramohan∗, Yang Liu∗and Fu Song†
∗School of Computer Science and Engineering, Nanyang Technological University, Singapore
†School of Information Science and Technology, ShanghaiTech University, China
‡Corresponding Author
Abstract —Software vulnerability is one of the major threats to
software security. Once discovered, vulnerabilities are often ﬁxed
by applying security patches. In that sense, security patches carry
valuable information about vulnerabilities, which could be used
to discover, understand and ﬁx (similar) vulnerabilities. However,
most existing patch analysis approaches work at the source code
level, while binary-level patch analysis often heavily relies on a lot
of human efforts and expertise. Even worse, some vulnerabilities
may be secretly patched without applying CVE numbers, or only
the patched binary programs are available while the patches are
not publicly released. These practices greatly hinder patch anal-
ysis and vulnerability analysis.
In this paper, we propose a scalable binary-level patch analysis
framework, named SPAIN, which can automatically identify se-
curity patches and summarize patch patterns and their corre-
sponding vulnerability patterns. Speciﬁcally, given the original
and patched versions of a binary program, we locate the patched
functions and identify the changed traces (i.e., a sequence of basic
blocks) that may contain security or non-security patches. Then
we identify security patches through a semantic analysis of these
traces and summarize the patterns through a taint analysis on
the patched functions. The summarized patterns can be used to
search similar patches or vulnerabilities in binary programs.
Our experimental results on several real-world projects have
shown that: i) SPAIN identiﬁed security patches with high accu-
racy and high scalability; ii) SPAIN summarized 5 patch patterns
and their corresponding vulnerability patterns for 5 vulnerability
types; and iii) SPAIN discovered security patches that were not
documented, and discovered 3 zero-day vulnerabilities.
I. I NTRODUCTION
Program vulnerability is one of the major threats to software
security. However, it is almost impossible to avoid vulnerabili-
ties at the development stage; and it is even difﬁcult to discover
vulnerabilities at the production stage. Security experts usually
leverage dynamic fuzzing (e.g., [ 1,2]), symbolic execution (e.g.,
[3,4]) or static code auditing (e.g., [ 5,6]) to ﬁnd vulnerabilities.
However, none of these techniques can provide a complete
solution to win the war against vulnerabilities. Dynamic fuzzing
suffers from the code coverage problem and the initial seeds
problem [ 7]. Symbolic execution cannot scale well to real-
world programs, due to path explosion and constraint solving
problems. Static code auditing often requires human expertise,
and cannot scale well when the program complexity increases.
Vulnerabilities, once discovered, are often ﬁxed by applying
security patches. In that sense, security patches carry important
information about vulnerabilities. By focusing on the remedy of
vulnerabilities instead of the vulnerabilities themselves, patchanalysis has been proposed to discover n-day vulnerabilities,
whose patches have been released but not deployed to every
instance of the software in the world. Since patch analysis
is relatively accurate to ﬁnd vulnerabilities, it has gained the
popularity in both industry and academia. Also, security patches
are good entry points to understanding the program weaknesses
and how the vulnerabilities work inside the program, especially
for security participants who do not have access to the source
code. Moreover, the underlying information of patches has
been used to build automatic bug-ﬁxing tools [ 8,9,10],
generating valid patches for similar vulnerabilities. However,
up till today, most existing researches on patch analysis work
at the source code level [ 11,12], but very few works have
been done to tackle this problem at the binary-level.
Binary-level patch analysis can only be performed on ma-
chine instructions for closed source programs without symbol
tables, which often requires a signiﬁcant amount of human
efforts and expertise to understand the semantics of instructions.
Due to this complex nature, the existing techniques [ 13,14] of-
ten heavily rely on manual or heavy program analysis, which be-
comes infeasible for real-world programs.
On the other hand, software companies may tend to patch the
vulnerabilities they ﬁnd themselves in a secret way instead of
making them public and applying Common Vulnerabilities and
Exposures (CVE) numbers due to their security regulations or
policies. As a result, security analysts cannot know the existence
of particular vulnerabilities, which hinders the understanding
and analysis of vulnerabilities. Even worse, in some cases,
only the patched binary programs are available; while the
patches themselves may not be publicly released, which hinders
the existing patch analysis techniques that often rely on the
availability of patches. Moreover, due to the application of patch
obfuscation and patch modiﬁcation techniques such as honey-
patching [ 15], the patch patterns in open source binaries may
differ greatly from close source ones.
To address these problems, we propose a scalable binary-
level patch analysis framework, named SPAIN, to automatically
identify security patches and summarize patch patterns and
their corresponding vulnerability patterns. In particular, given
the original and patched versions of a binary program, SPAIN
locates the functions that have been changed from the original
binary to the patched binary. Then, it detects the changed traces
(i.e., a sequence of basic blocks) for each patched function to
capture the function-level changes. These traces may contain
2017 IEEE/ACM 39th International Conference on Software Engineering
 
DOI 10.1109/ICSE.2017.49460
2017 IEEE/ACM 39th International Conference on Software Engineering
1558-1225/17 $31.00 © 2017 IEEE
DOI 10.1109/ICSE.2017.49462
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. security or non-security patches. Finally, it identiﬁes security
patches through a semantic analysis of these traces and sum-
marizes the patterns through a taint analysis on the patched
functions. As we run more binary programs, we can maintain
a database of patterns that will be continuously enriched to
embrace the evolving and emerging of various vulnerabilities.
There are many impactful applications of the learned patterns
in binary security like patch detection, vulnerability detection,
automatic patch synthesis, and even patch/vulnerability trend
analysis with the help of data analytic techniques. A more
detailed discussion can be found in Section III-E .
We evaluated SPAIN on several real-world projects. The ex-
perimental results demonstrated that SPAIN can identify
security patches with high accuracy and high scalability, and
summarize 5 security patch patterns and their corresponding
vulnerability patterns for 5 types of vulnerabilities. Moreover,
we discovered undocumented security patches and found 3
zero-day vulnerabilities in Adobe PDF Reader.
In summary, our work makes the following contributions.
•We proposed a scalable binary-level patch analysis frame-
work SPAIN, which can identify security patches and
summarize patch patterns and their corresponding vulner-
ability patterns.
•We implemented SPAIN in a prototype and conducted
experiments to demonstrate the accuracy, scalability, and
application of SPAIN.
•We discovered undocumented security patches and found
3 zero-day vulnerabilities in Adobe PDF Reader.
II. P RELIMINARIES AND OVERVIEW
A. Preliminaries
In this work, we assume that binary programs are in the
X86 32bit format. Each binary program contains a number of
functions with an entry point (starting function). This section
introduces several basic concepts in binaries, i.e., basic block,
control ﬂow graph and partial trace.
Deﬁnition 1: Abasic block in a binary function is a straight-
line sequence of X86 instructions with no branches in except
to the entry and no branches out except at the exit.
Deﬁnition 2: Given a binary function, the control ﬂow
graph (CFG) of the function is a tuple G=(N, E, N s,N t,ι),
whereNis a ﬁnite set of nodes, and each node represents a
basic block in the function, E:N×Nis a set of edges that
connect two nodes and represent the control ﬂow from one basic
block to the another, Ns,N t⊂Nare respectively the sets
of start and end points of the function, and ιis a function
associating every node n∈Nwith the basic block ι(n).
Notice that there might be more than one start point for a
function, because it is hard to precisely identify the boundary
of a function at the binary level [ 16].
Deﬁnition 3: Given a CFG G=(N, E, N s,N t,ι)of a
function, a partial trace tinGis a ﬁnite sequence of nodes
/angbracketleftn1,n 2, ..., n k/angbracketrightfor some k≥1, where(ni,n i+1)∈E,
for every i:1≤i<k .call BNnew
mov edi, eax
...
cmp eax, [edi+8]
...BB 1
call BNnew
test eax, eax
mov edi, eax
jz errorBB 1
...
cmp eax, [edi+8]
...BB 2error:
...BB 3
Patched version Original version1:
2:a:
b:
c:
Fig. 1: Running Example: NULL Pointer Dereference Vulner-
ability and its Patch from OpenSSL 1.0.1l.
B. Running Example
Figure 1lists the partial X86 assembly code of one NULL
pointer dereference vulnerability abstracted from the OpenSSL
1.0.1l that consists of the original version and patched version.
In the original version, the program ﬁrst calls the function
NB_new by which the return value is stored in the register
eax . Then, it assigns the return value to the register edi at the
location1. Later, the return value is directly used to dereference
the memory [edi+8] at the location 2. This vulnerability is
patched in OpenSSL 1.0.1m by checking whether the return
value of the function call NB_new isNULL or not. This
checking is implemented in the patched version by adding
two instructions: test eax, eax andjz error . It ﬁrst
tests the return value at the location abytest eax, eax
which performs a bitwise AND operation on the operand eax .
The test operation sets the carry ﬂag cf and overﬂow ﬂag
ofto0. The sign ﬂag sfis set to the most signiﬁcant bit of
the result of the bitwise AND operation. The zero ﬂag zfis
set to1if the result of AND operation is 0,0otherwise. The
parity ﬂag pfis set to1if the number of ones in that byte is
even,0otherwise. The value of the adjust ﬂag afis undeﬁned.
After assigning the return value to the register edi , it checks
whether the zero ﬂag zfis1or not (i.e., the value of eax is
Null or not) at the location b.I fi ti s1(i.e.,eax isNULL ),
the control ﬂow will jump to the location error for error
handling. Otherwise, the return value is used to dereference
the memory [edi+8] at the location c.
In this running example, there are one basic block BB1
and three basic blocks BB1,B B 2andBB3respectively in
the original version and patched version. The CFG of the
original version is Go=({n1},∅,{n1},{n1},ι), where
ι(ni)=BB1. The CFG of the patched version is Gp=
({n1,n2,n3},{(n1,n2),(n1,n3)},{n1},{n2,n3},ι),
whereι(ni)=BBifor every i:1≤i≤3. There are two
partial traces /angbracketleftn1,n 2/angbracketrightand/angbracketleftn1,n 3/angbracketrightinGp, which corresponds
to two possible execution traces of the patched program. While
there is only one partial trace /angbracketleftn1/angbracketrightinGo.
C. Framework Overview
Figure 2presents the overview of SPAIN, which consists of
four components. Taking the original and patched versions of
a binary program as inputs, SPAIN ﬁrst locates the functions
that have been changed from the original version to the patched
version and detects the changed traces in each patched function
to capture the function-level changes. Then SPAIN determines
whether such changes are caused by security or non-security
461
463
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. /g50/g85/g76/g74/g76/g81/g68/g79/g3
/g37/g76/g81/g68/g85/g92
/g51/g68/g87/g70/g75/g72/g71/g3
/g37/g76/g81/g68/g85/g92/g47/g82/g70/g68/g87/g76/g81/g74/g3
/g51/g68/g87/g70/g75/g72/g71/g3/g41/g88/g81/g70/g87/g76/g82/g81/g86/g44/g71/g72/g81/g87/g76/g73/g92/g76/g81/g74
/g51/g68/g87/g70/g75/g72/g71/g3/g37/g68/g86/g76/g70/g3/g37/g79/g82/g70/g78/g86/g44/g71/g72/g81/g87/g76/g73/g92/g76/g81/g74/g3
/g54/g72/g70/g88/g85/g76/g87/g92/g3/g51/g68/g87/g70/g75/g72/g86/g54/g88/g80/g80/g68/g85/g76/g93/g76/g81/g74
/g51/g68/g87/g70/g75/g18/g57/g88/g79/g17/g3/g51/g68/g87/g87/g72/g85/g81/g86/g51/g68/g87/g70/g75/g18/g57/g88/g79/g17/g3
/g51/g68/g87/g87/g72/g85/g81/g86
Fig. 2: Framework Overview of SPAIN
patches through semantic analysis and then summarizes the
patterns of security patches and their corresponding vulnerabil-
ities through taint analysis. As we run more binary programs,
SPAIN has the capability to continuously learn and accumulate
the knowledge of security patches to embrace the evolving and
emerging of various vulnerabilities.
Locating Patched Functions. Given the original and patched
versions of a binary program, this component ﬁrst uses the
disassembler tool IDA Pro [ 17] and the binary comparison tool
BinDiff [ 18] to obtain matched function pairs in the original
and patched versions. Such pairs are called candidate pairs that
may contain security or non-security patches. To reduce the size
of pairs for further analysis and hence improve the scalability,
this component removes the pairs from the candidate pairs,
in which the functions have no changes or only compiler-
introduced changes.
Identifying Patched Basic Blocks. For each function pair in
the candidate pairs (i.e., the patched and the original functions),
this component ﬁrst leverages the pairwise basic block matching
to identify the patched basic blocks within the patched function,
identiﬁes the relationships among these patched basic blocks in
terms of patched partial traces (see Deﬁnition 3) that capture
the locality of a patch, and ﬁnally determines the original partial
traces in the original function that are relevant to each patched
partial trace.
Identifying Security Patches. For a patched partial trace and
its corresponding original partial traces, this component decides
whether the changes are caused by a security or non-security
patch. It is realized by a semantic analysis to compute the se-
mantic difference between the patched partial trace and each
of the original partial trace. We use small semantic difference
as the indicator for security patches based on the heuristic that
security patches are less likely to introduce new semantics than
non-security patches (e.g., feature upgrades).
Example 1: Recalling the running example in Figure 1,
the difference between the original and patched versions is
the sanity check, namely test eax, eax andjz error
in the patched version. The semantic difference between the
patched and original versions is very minimal (e.g. <0.2in
our experiments) and hence, we can safely conclude that it is
a security patch (see Section III-C for details).
Summarizing Patch and Vulnerability Patterns. Once a se-
curity patch is identiﬁed, this component summarizes the patch
pattern and the corresponding vulnerability pattern through a
taint analysis from security-sensitive instructions in the patched
function. The patterns capture the security-critical sources, sinks
and sanity checks. One potential application of the summarized
patterns is to search for similar patches or vulnerabilities in
binary programs.Example 2: Consider the running example, the function
NB_new is an external unknown function. The return value of
NB_new is therefore regarded as the taint source/input. This
taint source is directly used to perform the security-sensitive
operation, memory dereferencing [edi+8] , which is regarded
as the taint sink. There is no checking of the tainted source
between the source and sink points. From this vulnerability, the
vulnerability pattern summarized by SPAIN is shown in the
4th row (NULL Pointer Dereference) of Table IV. Intuitively,
this pattern speciﬁes that there is an untrusted function call
whose return value is directly used to dereference memory
without any sanity checking on them.
While in the patched version of the running example, the
return value from the external unknown function NB_new is
checked for NULL value. If it is NULL , the program jumps to
an error handler. Otherwise, the return value is used to perform
the security-sensitive operation, that is memory dereferencing.
The patch pattern learned by SPAIN is shown in the 4th
row (NULL Pointer Dereference) of Table IV. Intuitively, this
patch pattern expresses that before using the return value of
an untrusted function call to dereference memory, there must
be a sanity checking of the return value.
D. Assumptions
SPAIN has a few underlying assumptions, which may limit
its application and threat its validity. First, we focus on patches
in which only one function is modiﬁed for one patch, but
do not support patches where multiple functions are changed
for one patch. Second, we assume that the function matching
results generated by IDA Pro [ 17] and BinDiff [ 18] are correct,
although no tools can reach 100% accuracy [ 19]. Third, we
cannot identify every type of patches since some patches,
especially for logical vulnerability patches, may behave like the
normal code. Currently, we cover the patches for most common
vulnerabilities such as buffer overﬂows, integer overﬂows, and
double-free/use-after-free. Fourth, we focus on the X86 32bit
binary format. We will discuss these assumptions in Section V.
III. M ETHODOLOGY
A. Locating Patched Functions
SPAIN starts with locating the matched pairs of functions
F={/angbracketleftfp,fo/angbracketright|fis a function in a binary program }, where
fo(i.e., the original function) is changed to fp(i.e., the patched
function) during the patching process. Fis a set of candidate
pairs that may contain security or non-security patches.
1) Function Matching: In the ﬁrst step, we leverage the disas-
sembler tool IDA Pro [ 17] and the binary comparison tool Bin-
Diff [ 18] to match functions in the original and patched versions
of a binary program. In particular, we use IDA Pro to extract the
assembly instructions and construct the CFG for each function.
462
464
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. /g76/g81/g86/g87/g66/g20
/g76/g81/g86/g87/g66/g21
/g76/g81/g86/g87/g66/g22
/g76/g81/g86/g87/g66/g23/g76/g81/g86/g87/g66/g20
/g76/g81/g86/g87/g66/g21
/g77/g80/g83/g3/g79/g68/g69/g72/g79/g79/g68/g69/g72/g79/g29
/g76/g81/g86/g87/g66/g22
/g76/g81/g86/g87/g66/g23
/g11/g68/g12 /g11/g69/g12
Fig. 3: An Example of Compiler-Introduced Changes
Then, for open source binaries (i.e., with the symbol table), we
directly use function names to perform the matching. While for
closed source binaries (i.e., without the symbol table), we lever-
age BinDiff’s function matching functionality. Finally, we get
the initial candidate pairs, where each function is represented by
its CFG. Note that this step is not one of our contributions, and
we brieﬂy introduce it to make our methodology complete.
2) Function Filtering: Patches usually change a small part of
the whole binary program and many functions remain the same.
Therefore, in the second step, we remove the function pairs with
no changes from the candidate pairs to reduce the size of pairs
for further analysis and thus improve the scalability. To this end,
we apply the 3D-CFG-based hashing technique [ 20] to compute
the hash value for fpandfo, and then remove /angbracketleftfp,fo/angbracketrightfrom the
candidate pairs Fiffpandfohave the same hash value.
Further, some changes are introduced by compilers due to the
compilation context or optimization level [ 21]. One common
case is that the compiler may split one basic block into two
basic blocks, as illustrated in Figure 3. The basic block in
Figure 3(a) becomes two basic blocks connected by a jmp
instruction in Figure 3(b) in the second run of a compiler. How-
ever, these two versions are semantically equivalent to each
other. Therefore, for any basic block, which has only one
successor and its successor has only one predecessor, we merge
it with its successor and remove the additional jmp instruction.
Another common case is that the compiler might change
the operands of the instruction in different runs. For exam-
ple, the memory addresses are associated with the function
position in the binary program and they will change if the
function position is changed, which always happens in different
runs of a compiler. To account for such changes introduced
by compilers, we normalize each basic block, as shown in
Algorithm 1. It takes a basic block as an input and returns
the normalized basic block. It iteratively normalizes each
assembly instruction in the basic block (Line 2). An assembly
instruction consists of a mnemonic and up to 3 operands, where
a mnemonic represents the speciﬁc operation that an instruction
performs while an operand is a variable-length sequence of
elements (cf. IA-32 [ 22]). Thus, it gets the mnemonic (Line 3)
and normalizes the operands of each instruction according
to their operand types (Lines 6–9). An operand can be a
register, an immediate value, or a memory, which is respectively
normalized to its type reg ,imm ,o rmem . For example, mov
eax, 0x40 is normalized to mov reg, imm .
After the merging and normalization of basic blocks for each
functions in F, we use the same hashing technique to fur-
ther remove the pairs that only have some compiler-introduced
changes. Our ﬁltering step is designed to be conservative such
that security changes are kept.Algorithm 1: Normalize A Basic Block
Input : basic block b
Output : normalized basic block b/prime
1b/prime:=/angbracketleft/angbracketright// sequence of normalized inst.
2foreach instruction iinbdo
3 m:= GetMnemonic( i)
4 ifm/negationslash=’nop’ then
5 op/prime:=/angbracketleft/angbracketright// sequence of operand type
6 foreach operand oinoperands(i) do
7 t:= GetOperandType( o)
//t∈{mem, reg, imm }
8 op/prime:=op/prime⊕t
9 end
10 i/prime:=/angbracketleftm, op/prime/angbracketright// normalized inst.
11 b/prime:=b/prime⊕i/prime
12 end
13end
14return b/prime
B. Identifying Patched Basic Blocks
Both security and non-security patches can lead to the mod-
iﬁcations of various basic blocks and, in the worst case, such
modiﬁed basic blocks can lie scattered all over a function. Thus,
SPAIN proceeds to investigate the candidate pairs Fto identify
the basic blocks that are modiﬁed (i.e., patched basic blocks)
in the patch, identify the relationships among these patched
basic blocks in terms of partial traces (see Deﬁnition 3), and
identify their relations to the original function. Algorithm 2
gives this procedure, which computes the matched trace pairs
T={/angbracketlefttp,{t1
o,...,tn
o}/angbracketright |tis a partial trace in a function }
for each function pair /angbracketleftfp,fo/angbracketrightinF, wheretpinfpmight be
relevant to {t1
o,...,tn
o}info.
In detail, we leverage the pairwise basic block matching to
identify the patched basic blocks within the patched function
(Lines 2–13). In particular, for each basic block bpin the
patched function fp, we search for an equivalent basic block
boin the original function fo. If there is no such a matching
basic block boinfo,bpis identiﬁed as a patched basic block.
Once the patched basic blocks are identiﬁed, we proceed to
determine the relationships among these basic blocks (Line 14),
i.e., to connect the patched basic blocks to infer the effect of
a patch. To this end, for each patched basic block, we
leverage the predecessor/successor information to connect
related patched blocks; i.e., b1
pandb2
pare connected when
there is a predecessor/successor relationship between them. In
such a manner, patched partial traces (i.e., {tp}) are constructed.
To get a clear understanding of how a patched partial trace
tpis related to the original function, we extract the unmodiﬁed
ﬁrst-degree neighbors of the patched partial trace (Line 16).
Speciﬁcally, for each basic block in the patched partial trace, we
identify the ﬁrst-degree neighboring blocks that are unmodiﬁed
from the original function. These unmodiﬁed neighboring basic
blocks capture the locality of the patch and help to locate the
corresponding basic blocks in the original function (Line 17).
In this fashion, for each patched partial trace, we identify the
corresponding basic blocks of interest in the original function,
and construct the original partial traces {t1
o,...,tn
o}in the same
463
465
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. Algorithm 2: Identify Partial Traces
Input : patched function fp, original function fo
Output : set of matched partial trace pairs T
1T:=∅
2Bp:=∅// set of patched blocks
3foreach basic block bpinfpdo
4 foreach basic block boinfodo
5 ifbp==bothen
6 F oundMatch =Tru e
7 break
8 end
9 end
10 ifnotF oundMatch then
11 Bp:=Bp∪{bp}
12 end
13end
14Tp:= LinearConnectedComponents( Bp)
15foreach patched partial trace tpinTpdo
16 neighbors := GetFirstDegreeNeighbors( tp,fp)
17Bo:= GetRelevantOriginalBlocks( neighbors ,fo)
18To:= LinearConnectedComponents( Bo)
19T:=T∪ { /angbracketleft tp,To/angbracketright}
20end
21returnT
way to construct patched partial traces (Line 18).
Example 3: Consider the original and patched functions
in Figure 4, where each letter represents a basic block. We
can see that in the patched function, the basic block bin the
original function is modiﬁed to b/primeand a new basic block g/prime
is added. From the patched function, only one patched partial
trace can be extracted, i.e., /angbracketleftb/prime,g/prime/angbracketright, where its unmodiﬁed ﬁrst-
degree neighbors are {a,c,d}. By looking at the ﬁrst-degree
neighbors of the patched partial trace, we can infer that only
the basic block bis the corresponding basic block of interest
in the original function, and only one original partial trace can
be constructed, i.e., /angbracketleftb/angbracketright. Hence, in this case, the patched partial
trace/angbracketleftb/prime,g/prime/angbracketrightis only related to one original partial trace /angbracketleftb/angbracketright.
C. Identifying Security Patches
Once the patched partial traces and their related partial traces
in the original function are identiﬁed, we proceed to determine
for each pair /angbracketlefttp,{t1
o,...,tn
o}/angbracketrightinTwhether the changes are
caused by a security patch or non-security patch. To this end,
we perform a semantic analysis on both the patched partial
tracetpand the set of original partial traces {t1
o,...,tn
o}.
The idea underlying our semantic analysis is that “a
security patch is less likely to change the semantics of the
underlying function, while a non-security patch is more likely to
introduce new semantics” . Therefore, we compare the semantic
summaries generated for the patched partial trace and each of
the original partial traces by Equation 1.
δd=Sp−S o (1)
δdis the semantic difference between the semantic summary Sp
of the patched partial trace tpand the semantic summary So
of the original partial trace toin{t1
o,...,tn
o}. If there exists
one original partial trace such that the semantic difference is/g68
/g69
/g70/g71
/g72/g68
/g69/g182
/g70/g71
/g72/g74/g182
/g11/g68/g12/g3/g50/g85/g76/g74/g76/g81/g68/g79/g3/g41/g88/g81/g70/g87/g76/g82/g81 /g11 /g69/g12/g3/g51/g68/g87/g70/g75/g72/g71/g3/g41/g88/g81/g70/g87/g76/g82/g81
Fig. 4: An Example of the Original and Patched Functions
small, we mark the patch as a security patch. Otherwise, we
mark the patch as a non-security patch.
In detail, we leverage the technique in our previous work [ 23]
to generate the semantic summary from a partial code segment
(i.e., a partial trace). Here semantics are expressed as the
effects of executing the partial code segment on the ma-
chine state. The machine state sis characterized by a 3-tuple
/angbracketleftMem, Reg, Flag /angbracketright, denoting the memory Mem , the general-
purpose registers Reg, and the condition-code ﬂags Flag . The
machine state before and after executing the partial code
segment is referred to as pre-state and post-state , respectively.
For example, one possible pre-state before executing the code
segment in Figure 5(a) is given in Figure 5(b), where all
registers ,flags , and memory are assigned by the value
0; and in the corresponding post-state, the registers eax and
ebx hold the values 0x04 and-0x04 , respectively, while
the sign ﬂag sfholds the value 1due to the negative result
inebx .
Then, the semantic summary is the difference between the
pre-state and post-state, as shown in Equation 2.
S=spost−spre (2)
For example, the semantic summary of the code segment shown
in Figure 5(a) is eax/prime= 0x04 andebx/prime= eax-0x04 ,
where primed variables denote ﬁnal values and non-primed
variables denote initial values.
In our semantic analysis, for both patched and original partial
traces, we ﬁrst generate various conﬁgurations of pre-state and
run the partial traces and measure the corresponding post-state
values. Then, we compute the semantic summary for patched
and original partial traces, and compare them following the
techniques in [ 24,23]. Finally, if the semantic difference is
below a pre-deﬁned threshold value (i.e., <Δd). We determine
that the patch is a security patch. Otherwise, it is a non-security
patch. In our experiment, we empirically ﬁx Δdto be 0.20.
Example 4: Let us consider the running example in Fig-
ure 1. There are in total 17 machine artifacts involved in the
semantic summary computation that are 8 register, 8 status
ﬂags and one memory location [edi+8] , among which only
three status ﬂags ( sf,zfandcf) are inﬂuenced by the newly
added instruction test eax, eax in the patched partial
trace. Given a ﬁxed pre-state in which all values of artifacts
are set to 0but ebx to 4, as shown in Figure 5(b), the post-state
can be computed easily. In the post-state, only the zero ﬂag
zfis set to1, while all the other 16 artifacts keep same as
the original trace. From the pre-state and post-state, we get
464
466
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. mov eax ,0x04
sub ebx ,eax
(a) Sample Code Segment
Pre-state:
Reg={eax=0,ebx=4,. .}
Flag ={zf=0,sf=0,. .}
Mem={0,0...0}Post-state:
Reg/prime={eax/prime=0x4,ebx/prime=0x0,. .}
Flag/prime={zf/prime=1,sf/prime=0,. .}
Mem/prime={0,0...0}
(b) Pre- and Post-State before and after Executing the Code Segment
Fig. 5: An Example of Pre-State and Post-State
that the semantic difference between the patched and original
partial trace is equal to 0.058 (<Δd), which implies that the
patch in Figure 1is a security patch.
D. Summarizing Patch and Vulnerability Patterns
Once the security patches are identiﬁed, SPAIN proceeds to
summarize patch patterns and the corresponding vulnerability
patterns from the original and patched partial traces. To this end,
we introduce a light-weight program analysis technique. Specif-
ically, given a patched partial trace tpand the relevant original
partial traces {t1
o,...,tn
o}, SPAIN identiﬁes the newly-added
and security-sensitive instructions in tp. In general, newly-
added control transfer instructions, especially the ones that
depend on comparison instructions such as cmp andtest ,
are of the interest for security analysts, which are more likely
to reﬂect the newly-introduced sanity checks in the patch.
In the next step, we pass the source and destination operands
of those interesting instructions to the taint engine [ 25]
to track their sources and sinks that are key indicators of
vulnerabilities. For example, in the instruction cmp eax ,ebx ,
register ebx is the source operand and register eax is the
destination operand. In particular, non-immediate source and
destination operands are passed to the taint engine to track
their origins (or sources ) using backward taint analysis, while
the non-immediate destination operand is passed to the taint
engine to track its destinations (or sinks ) using forward taint
analysis. It is important to note that taint analysis is performed
within the patched function, i.e., intra-procedural taint analysis.
Finally, the tracked sources and sinks are combined to
summarize the vulnerability and security patch patterns. In
Figure 6, we show the abstract vulnerability and patch patterns,
where source ,sink and sanity check are deﬁned as follows.
Deﬁnition 4 (Sources): Taint sources are the user/external
inputs (i.e., tainted inputs) that can reach the patched function
and are used by those interesting instructions.
For example, external function parameters or return values
of security-sensitive system APIs (e.g., scanf ) are considered
as taint sources.
Deﬁnition 5 (Sinks): Taint sinks are the security-critical op-
erations that involve the tainted inputs.
For example, memory dereference operations (e.g., mov eax ,
[taint-source] ) or arithmetic subtraction operations (e.g.,
mov eax ,[taint-source] ;sub ebx ,eax ) that involves
taint sources are considered as taint sinks./g55/g68/g76/g81/g87/g72/g71/g3/g44/g81 /g83/g88/g87/g3
/g11/g54/g82/g88/g85/g70/g72/g12
/g54/g72/g70/g88/g85/g76/g87/g92/g16/g54/g72/g81/g86/g76/g87/g76/g89/g72/g3
/g50/g83/g72/g85/g68/g87/g76/g82/g81/g3/g11/g54/g76/g81/g78/g12/g55/g68/g76/g81/g87/g72/g71/g3/g44/g81 /g83/g88/g87/g3
/g11/g54/g82/g88/g85/g70/g72/g12
/g54/g72/g70/g88/g85/g76/g87/g92/g16/g54/g72/g81/g86/g76/g87/g76/g89/g72/g3
/g50/g83/g72/g85/g68/g87/g76/g82/g81/g3/g11/g54/g76/g81/g78/g12/g54/g68/g81/g76/g87/g92/g3/g38/g75/g72/g70/g78 /g71/g68/g87/g68/g3/g71/g72 /g83/g72/g81/g71/g72/g81/g70/g72/g71/g68/g87/g68/g3/g71/g72 /g83/g72/g81/g71/g72/g81/g70/g72
/g71/g68/g87/g68/g3/g71/g72 /g83/g72/g81/g71/g72/g81/g70/g72
/g11/g68/g12/g3/g57/g88/g79/g81/g72/g85/g68 /g69/g76/g79/g76/g87/g92/g3/g51/g68/g87/g87/g72/g85/g81 /g11 /g69/g12/g3/g51/g68/g87/g70/g75/g3/g51/g68/g87/g87/g72/g85/g81
Fig. 6: Abstract Vulnerability and Security Patch Pattern
Deﬁnition 6 (Sanity Checks): Sanity checks are operations
performed on the tainted inputs before they are involved in
security-critical operations.
E. Applications of Patterns
The patch patterns can be used in many applications. One
main application is to search for the similar patches and
corresponding vulnerabilities in the binaries. Besides, SPAIN
is orthogonal to several patch analysis tools, and hence
can provide patch patterns as input for them. For example,
Prophet [ 8] can learn a probabilistic model from the correct
code to automatically generate patches. SPAIN can provide
possible locations where a patch is needed. TEDEM [ 26]c a n
identify binary code regions that are similar to code regions
containing vulnerabilities. SPAIN can provide such vulnerable
regions through pattern matching so that TEDEM may have
more candidates to search for. Honey patch [ 15] was proposed
as a trap to monitor attack information and misinform the
attacker through redirecting the attack to an unpatched decoy.
SPAIN can help to identify the patches that can be converted
into honey patches, making the whole process fully automatic.
A survey on repeated patches [ 27] has been conducted to show
the general trend of bug ﬁxes. SPAIN can enable the trend
analysis on a large number of programs to gain a complete
understanding of how programmers ﬁx bugs.
IV . E V ALUA TION
In this section, we conduct an experimental study on several
real-world projects to answer the following research questions.
•RQ1 : What is the accuracy and scalability of SPAIN to
identify security patches?
•RQ2 : What are the security patch patterns and their cor-
responding vulnerability patterns summarized by SPAIN?
•RQ3 : What are the potential application scenarios of the
summarized patterns of SPAIN?
The experiments were conducted on an HP z420 workstation
with 32GB RAM and Intel Xeon CPU E5-1620 v2 3.70GHz.
All the experimental data is available at our website [ 28]. We
used the following real-world software in our evaluation:
•OpenSSL is an open source software with around 446,747
number of locations (LOC) and developed since 1998.
•Linux Kernel is an open source software with around
18,963,973 LOC and developed since 2002.
465
467
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. TABLE I: Accuracy and Performance on OpenSSL
Ve r. CVESec. Pat. Non-Sec. Pat.T.P. F.P. T. (s)G.T. Iden. G.T. Iden.
0–a 1 7 4 11 0 0.57 0 11
a–b 0 0 0 5 0 – 0 13
b–c 1 3 2 0 0 0.67 – 7
c–d 3 19 8 27 0 0.42 0 60
d–e 0 0 0 6 1 – 0.17 8
e–f 3 12 9 17 10 0.75 0.59 14
f–g 2 10 8 6 1 0.8 0.17 11
g–h 8 29 18 4 1 0.62 0.25 20
h– i 9 37 24 23 8 0.65 0.35 54
i–j 4 23 11 5 2 0.48 0.4 35
j–k 7 25 19 15 5 0.76 0.33 39
k–l 0 0 0 1 0 – 0 7
l–m 8 34 25 7 3 0.74 0.43 95
m–n 5 60 49 38 5 0.82 0.13 76
n–o 1 0 0 6 0 0 0 9
o–p 2 2 1 1 0 0.5 0 9
p–q 2 39 31 40 11 0.79 0.28 48
q–r 1 10 9 3 0 0.9 0 18
r–s 6 13 11 2 0 0.85 0 36
Sum. 63 323 229 217 47 0.71 0.22 –
•Adobe PDF Reader is a closed source software. We
use two of its libraries, 3difr.x3d andAXSLE.dll ,
which have around 1,293 and 4,874 functions respectively.
A. Accuracy and Scalability (RQ1)
1) Accuracy: To evaluate the accuracy of SPAIN on
identifying security patches, we manually identiﬁed all the
security and non-security patches of all the 20 versions of
OpenSSL 1.0.1 by analyzing its commits on GitHub. They
were used as the ground truth to evaluate the true positive
and false positive of SPAIN. For each security patch, we also
manually analyzed the type of the patched vulnerability.
Table Ireports the detailed results of our accuracy evaluation
on OpenSSL. The ﬁrst column lists the version numbers of two
consecutive versions of OpenSSL, which are respectively served
as the original and patched binaries. The second column reports
the number of CVEs that are documented. The third and ﬁfth
columns respectively show the number of security and non-
security patches we manually identiﬁed. The fourth column
reports the true security patches SPAIN successfully identiﬁed,
and the sixth column gives the false security patches SPAIN
incorrectly identiﬁed. Note that SPAIN only reports security
patches, here the sixth column gives the false positive cases
generated by SPAIN. The last three columns compute the true
positive, false positive and execution time of SPAIN.
From Table Iit can be seen that among the 323 security
patches, SPAIN successfully identiﬁed 229 of them, while it
incorrectly identiﬁed 47 of the 217 non-security patches as
security patches. It achieved the true positive rate of 71% and
the false positive rate of 22%, which indicated that SPAIN can
identify security patches with high accuracy. Besides, compared
with the number of identiﬁed security patches, only a small
number of CVEs are documented, which demonstrates that
SPAIN can discover undocumented patches. Moreover, SPAIN
took around 32 seconds on average to analyze the binaries. In
addition, Table IIshows the accuracy of SPAIN with respect toTABLE II: Accuracy on OpenSSL w.r.t Vulnerability Types
Vulnerability Type G.T. SPAIN Accuracy
Buffer Overﬂow 54 37 0.69
NULL Pointer Dereference 65 61 0.94
Memory Leak 51 30 0.59
Double-Free 14 7 0.5
Integer Overﬂow 8 7 0.88
Initialization 16 11 0.69
Off-by-One 3 2 0.67
Side Channels 2 1 0.5
Use-After-Free 1 1 1
Others 109 72 0.66
Sum. 323 229 0.71
nine vulnerability types. Note that 109 of the security patches
patched some tricky vulnerabilities that do not belong to these
nine common types. The results indicate that SPAIN can
identify security patches for different types of vulnerabilities
with high accuracy.
By closely looking into the security patches SPAIN failed to
identify, we ﬁnd two main causes for the false negatives. First,
a patch is so simple that our function ﬁltering step may fail to
detect the changes. For example, one unidentiﬁed security patch
in OpenSSL simply increased the buffer size in a function by a
constant value. As a result, the patched function is the same to
the original one, except for that particular constant. After the
basic block normalization, they become the same and will
not be further analyzed. Second, a patch is so complicated
that our semantic analysis may identify it as a non-security
patch due to the large amount of newly-introduced semantics.
For example, developers may rewrite part of a function to ﬁx
a vulnerability; or some different patches happen to patch the
same function. In such cases, our semantic analysis may detect
signiﬁcant semantic difference between the patched function
and the original one, failing to identify the security patch.
Similarly, we investigated the causes of the false positives.
One main reason is that some non-security patches only slightly
modify the program, especially for ﬁxing some performance
bugs [ 29] or adding the consideration for some missed corner
cases. For example, a patch added a simple conditional state-
ment that would be executed only when certain criteria have
been met. It follows the similar pattern of security patches since
most security patches can be seen as a conditional functionality,
which redirects the execution to safe places if some variables
have unexpected values. Therefore, such kinds of non-security
patches are difﬁcult to be distinguished. We argue that false
positives only have a small impact on our analysis as the number
of false positive is small, and a simple manual validation can
identify them.
Summary. Based on these observations, we can positively an-
swer RQ1 that SPAIN can identify security patches for different
types of vulnerabilities with a high true positive rate as well
as acceptable false positive rate. Further, SPAIN can discover
security patches that are not documented.
2) Scalability: To evaluate the scalability of SPAIN to ana-
lyze large binaries, we ran SPAIN on both open source Linux
Kernel and closed source Adobe PDF Reader. In particular, we
used versions 3.16.2 and 3.16.3 of Linux Kernel, and compiled
466
468
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. TABLE III: Performance on Linux and Adobe PDF Reader
V ersion Total Func. Sec. Patched T. (s)
Linux: 3.16.2 – 3.16.3 249341 1221 807
difr.x3d: 11.0.08 – 11.0.09 1293 12 21
difr.x3d: 11.0.13 – 11.0.14 1293 13 23
difr.x3d: 11.0.15 – 11.0.16 1293 11 20
AXSLE.dll: 11.0.15 – 11.0.17 4875 27 84
them using the -o2 optimization level (i.e., the most common
commercial setting) with all the functions included. For Adobe
PDF Reader, we analyzed the library 3difr.x3d of versions
11.0.08, 11.0.09, 11.0.13, 11.0.14, 11.0.15 and 11.0.16 as well
as the library AXSLE.dll of versions 11.0.15 and 11.0.17.
Table IIIpresents the performance of SPAIN on Linux kernel
and Adobe PDF Reader. The ﬁrst column gives the versions of
the original and patched binaries, and the second column reports
the average number of functions in them. The third and fourth
columns list the identiﬁed security patches by SPAIN and the
corresponding time overhead. We can see that SPAIN analyzed
the whole Linux Kernel in 807 seconds, and analyzed the two
Adobe libraries in 23 seconds. Note that, because we do not
have the ground truth for security patches, we did not show
the accuracy of SPAIN on them but reported the identiﬁed
security patches.
Summary. Based on the results from Table III, we can posi-
tively answer RQ1 that SPAIN scales well to large binaries.
B. Patch and Vulnerability Patterns (RQ2)
Table IVpresents the vulnerability and patch patterns sum-
marized for the key vulnerability types patched in the 20
versions of OpenSSL. Among them, one of most common
ones is double-free vulnerability, i.e., an error that occurs when
free() is called more than once with the same memory
address as an argument. It is summarized in the ﬁrst row, where
the memory address is obtained from an untrusted function as
a return value, and it is freed more than once, which leads to
the vulnerability. To patch this, one needs to sanity check for
validity of the memory address and remove all the occurrences
where it is freed for more than once.
The integer overﬂow/underﬂow is summarized in the second
row, where it occurs when an arithmetic calculation produces
a result that is greater (or smaller) in magnitude than that a
given register or storage location can store or represent. In
general, arithmetic operations are vulnerable to integer overﬂow
or underﬂow when they take the inputs from untrusted sources
and perform some security-sensitive operation such as memory
dereferencing and memory indexing on the calculated results.
To patch such vulnerable cases, one needs to perform a sanity
check on the untrusted inputs before allowing for any security-
sensitive arithmetic operation.
The third row summarizes the use-after-free vulnerability
pattern, where the obtained pointer (from an untrusted source)
to the memory object is freed without checking for liveness
property of the pointer. For patching such vulnerabilities, one
needs to check whether the object is in use, if so, the pointer
to it should not be freed. The fourth row summarizes NULL
pointer dereference vulnerability, the most frequently occurredvulnerability in OpenSSL. As discussed in Section II,i ti sv e r y
common to obtain a pointer from an untrusted source; hence,
before involving it in any security-sensitive operation, such
as memory dereferencing, it needs to be checked whether the
pointer is NULL or valid. Finally, the ﬁfth row summarizes the
other most commonly observed vulnerability, buffer overﬂow
or underﬂow, where the patch suggests that any pointer to
a memory object should be properly bounds-checked before
involving it in any security-sensitive operation.
Apart from the vulnerability types summarized in Table IV,
we observed other class of vulnerabilities/patches that cannot
be generalized for pattern matching. Such vulnerability types
include, side-channel information leakage, memory leakage
and uninitialized variables whose patterns are particular to the
OpenSSL binaries. However, summarizing these pattern will
enable us to identify clone or copy-paste type vulnerabilities
that are very commonly observed in the wild [ 30,24]. Due to
the space limitation, we provide the vulnerability and patch
patterns for such class of vulnerabilities and the patterns for
Linux and Adobe in our website [ 28].
C. Application of Patterns (RQ3)
Using SPAIN and the summarized patterns, we used pattern
matching techniques [ 23] to discover three zero-day vulnerabil-
ities (CVE-2016-0933, CVE-2016-1037 and CVE-2016-4198)
in the two libraries in Adobe PDF Reader.
We start the experiment with an Adobe Reader vulnerability,
CVE-2014-0565, which has already been patched in 2014. It
is a vulnerability that reads the memory out of bound, due to
the insufﬁcient check on the string length of Line Set block.
Our tool successfully identiﬁes the patch by difﬁng the two
versions of Adobe Reader, 11.0.8 and 11.0.9, i.e., ﬁnding the
place where two additional checks have been added to the
function. After the checks, the program returns to the normal
execution. Therefore, our tool identiﬁes security patches with
high conﬁdence. It is a very typical patch pattern, which is the
buffer overﬂow pattern in the ﬁfth row of Table IV.
Then, we use the corresponding vulnerability pattern to
search for similar vulnerabilities in different versions of Adobe
Reader. Speciﬁcally, we ﬁnd CVE-2016-0933 and CVE-2016-
1037, having the same vulnerability pattern, which, later, have
been conﬁrmed by manual analysis. CVE-2016-0933 is a
vulnerability in Adobe Reader 3difr.x3d before version 11.0.14.
CVE-2016-1037 also resides in 3difr.x3d, while it is in version
11.0.16. We also ﬁnd CVE-2016-4198, which shares the similar
pattern with the previous vulnerability, although it is indeed
an integer overﬂow vulnerability in Adobe XSLT library. Once
triggered, it will cause an out of bound write to the memory
and remote code execution.
After Adobe Reader had patched the aforementioned vul-
nerabilities, we used SPAIN to diff the patched version with
the original vulnerable version. We successfully located the
three vulnerability patches using the tool, as shown in Table III,
which demonstrates that our tool has the capability to capture
patches in closed source binaries. A more detailed explanation
of the patterns can be found at our website [ 28].
467
469
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. TABLE IV: Patch Patterns vs. Vulnerability Patterns, where TNT denotes taint, IN denotes input, and SSTV denotes sensitive.
Vul. Concrete Vulnerability Concrete Patch
type Vulnerability Pattern Patch Pattern
Double Freecall BN toASN1 INTEGER
test eax ,eax
mov esi ,eax
...
mov [esp+4Ch+var 4C],esi
call ASN1 STRING clear free
...
mov [esp+4Ch+var 4C],esi
call ASN1 STRING clear freecall/angbracketleftuntrusted func/angbracketright
/angbracketleftsanitycheck /angbracketright:/angbracketleftreturn value/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftreturn value/angbracketright
call/angbracketleftfree/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftreturn value/angbracketright
call/angbracketleftfree/angbracketrightcall BN toASN1 INTEGER
test eax ,eax
mov esi ,eax
...
mov [esp+4Ch+var 4C],esi
call ASN1 STRING clear free
...call/angbracketleftuntrusted func/angbracketright
/angbracketleftsanity check /angbracketright:/angbracketleftreturn value/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftreturn value/angbracketright
call/angbracketleftfree/angbracketright
...
Underflow OverflowInteger
mov eax ,[esp+4Ch+arg 4]
...
mov ecx ,eax
sub ecx ,[esp+4Ch+var 2C]
add [esp+4Ch+var 24],ecx
...
mov esi ,[esp+4Ch+24]
mov ecx ,[esp+4Ch+arg 8]
mov [ecx],esimov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
...
/angbracketleftarith op/angbracketright/angbracketleftTNT result/angbracketright,/angbracketleftTNT IN/angbracketright
...
mov/angbracketleftsec SSTV sink/angbracketright,/angbracketleftTNT result/angbracketrightmov eax ,[esp+4Ch+arg 4]
...
mov edi ,[esp+4Ch+var 2C]
cmp eax ,edi
jl error
mov ecx ,eax
sub ecx ,[esp+4Ch+var 2C]
add [esp+4Ch+var 24],ecx
...
mov esi ,[esp+4Ch+24]
mov ecx ,[esp+4Ch+arg 8]
mov [ecx],esimov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
/angbracketleftsanity check /angbracketright:/angbracketleftTNT IN/angbracketright
...
/angbracketleftarith op/angbracketright/angbracketleftTNT result/angbracketright,/angbracketleftTNT IN/angbracketright
...
mov/angbracketleftsec SSTV sink/angbracketright,/angbracketleftTNT result/angbracketright
Use After Free
mov ebp ,[esp+0ECh +arg 0]
...
mov [esp+0ECh +dest ],ebp
call ssl3 release readmov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftTNT pointer/angbracketright
call/angbracketleftfree/angbracketrightmov ebp ,[esp+0ECh +arg 0]
...
mov eax ,[ebp+58h]
mov eax ,[eax+0F8h ]
test eax ,eax
jnz/angbracketleftdo not release /angbracketright
...
mov [esp+0ECh +dest ],ebp
call ssl3 release readmov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
/angbracketleftsanity check /angbracketright:/angbracketleftTNT pointer/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftTNT pointer/angbracketright
call/angbracketleftfree/angbracketright
DereferenceNULL Pointer
callBN new
mov edi ,eax
...
cmp eax ,[edi+8]call/angbracketleftuntrusted func/angbracketright
...
/angbracketleftmem deref/angbracketright:/angbracketleftreturn value/angbracketrightcall BN new
test eax ,eax
mov edi ,eax
jz error
...
cmp eax ,[edi+8]call/angbracketleftuntrusted func/angbracketright
/angbracketleftsanity check /angbracketright:/angbracketleftreturn value/angbracketright
...
/angbracketleftmem deref/angbracketright:/angbracketleftreturn value/angbracketright
OverflowBuffer
mov ebx ,[esp+3Ch+arg 8]
...
mov [esp+3Ch+n],ebx
call eaxmov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
mov/angbracketleftfunc param/angbracketright,/angbracketleftTNT IN/angbracketright
...
call/angbracketleftuntrusted func/angbracketrightmov ebx ,[esp+3Ch+arg 8]
cmp ebx ,[esp+3Ch+arg 4]
jl error
...
mov [esp+3Ch+n],ebx
call eaxmov/angbracketleftTNT IN/angbracketright,/angbracketleftuntrusted src/angbracketright
/angbracketleftsanity check /angbracketright:/angbracketleftTNT IN/angbracketright
...
mov/angbracketleftfunc param/angbracketright,/angbracketleftTNT IN/angbracketright
call/angbracketleftuntrusted func/angbracketright
V. D ISCUSSION
Our framework has the following limitations. First, our frame-
work tries to look for patches and vulnerabilities with patterns.
However, some real-world vulnerabilities are actually the corner
cases, which have unique signatures and patches may ﬁx bugs in
unusual ways. SPAIN may not be able to achieve high accuracy
when dealing with these special cases, in which almost all the
patches are usually complex.
Second, vulnerabilities may be patched in some places other
than the places where they are triggered. Therefore, trying
to hunt them from patches may not be straightforward. Our
current tool can only look for vulnerabilities that are patched
within the one function where the patch has been found. In
future, we plan to adopt some other techniques such as function
summarization, more advanced slicing and symbolic execution
to handle the vulnerabilities that are patched across functions.
Third, building a general solution for all kinds of binary
architectures requires lifting the instruction into intermediate
representation. We did not do that because we want to obtain
the exact patterns of the patches and vulnerabilities. Binary
lifting may result in loss of a certain amount of information
or inaccuracy [ 31], which may be critical for our pattern
summarization. Therefore, throughout this work, all the binaries
used are in X86 32bit format. It is worth mentioning that our
approach is general and can be adapted to other binary formats.
Fourth, the framework shares the common drawback of static
vulnerability searching approaches. Although we can identify
the location of the vulnerability, we cannot reproduce it inreal world if the program is too complicated. The user input
may travel through many functions and be transformed several
times until it reaches the location that triggers the vulnerability.
Hence, we may not have a concrete proof-of-concept (POC) to
validate the vulnerability whether it has a real impact on the
program’s security. However, unlike other searching methods,
since we are searching the vulnerability based on its patch, we
have a relatively high conﬁdence to say that it is a severe bug,
which is needed to be patched.
VI. R ELA TED WORK
Our work attempts to understand patches and the correspond-
ing vulnerabilities, and summarize their patterns for discovering
similar patches or vulnerabilities. Hence, we discuss the related
work in the areas of patch analysis and vulnerability modeling.
A. Patch Analysis and Difﬁng
PVDF [ 32] computes the semantic of patches for privilege el-
evation vulnerabilities. The patch semantic is then used to guide
fuzzy testing to discover new vulnerabilities in binary programs.
It takes the vulnerable binary and the corresponding patch as
the inputs, and leverages forward and backward taint analysis
to extract the semantics. This work is similar to ours; but it
assumes the availability of patches, and only focuses on one
particular vulnerability type. Differently, SPAIN attempts to
summarize patterns for different vulnerability types, and only
requires the binary programs but not the patches.
468
470
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. BISSAM [ 14] uses binary patch difﬁng information to de-
velop signatures for the security update. Then it executes
the binary with malicious inputs under dynamic monitoring
to obtain the execution paths. It identiﬁes the vulnerability by
determining whether the path includes one of the signatures.
Its effectiveness heavily relies on the malicious inputs and
assumes the availability of security patches. Differently, we
can automatically identify the security patches in a static way.
BinHunt [ 13] can automatically ﬁnd the semantic differences
in binary programs. It lifts the binary instructions to Interme-
diate Representation (IR), and constructs CFGs at the IR level.
Then it uses graph isomorphism to ﬁnd the differences and
performs symbolic execution on them to obtain the semantics
for theorem proving. Unlike it, SPAIN is much more scalable,
since we apply function-level ﬁltering, which enables us to
search for patches in real-world programs.
Apart from these binary-level patch analysis, there are
many source-level approaches. Tian et al. [ 11] attempt to
identify Linux patches based on the commit messages and the
source code difﬁng analysis. They extract features and leverage
machine learning techniques to predict whether a commit is a
bug ﬁx or not. Soto et al. [ 33] investigate Java projects
to get a deeper understanding of each patch’s signature
to guide automatic program repairing. BugTrace [ 12] aims
at building the link between the bug and the ﬁx through patch
analysis. Kim and Notkin [ 34] build a difﬁng tool to infer the
structural differences between codes, which helps programmers
to discover bugs by comparing two versions of a program.
These works all use patch analysis to gain the understanding
at the source code level, which may not work if the source
code is not available. Instead, SPAIN directly works at the
binary level.
B. Vulnerability Modeling and Searching
INDIO [ 35] leverages symbolic execution to analyze bi-
naries and detects integer overﬂow vulnerabilities. It uses
some heuristic patterns to ﬁnd the potential vulnerability
candidates. Then it ranks the vulnerable possibility for the
candidates. Finally, it selectively executes symbolic execution
to remove the false positives further. It discovered known
CVEs as well as unknown integer overﬂow vulnerabilities in
real world Window binaries. Similarly, IntScope [ 36] employs
symbolic execution to detect integer overﬂow vulnerabilities
in X86 binaries, and Firmalice [ 37] uses symbolic execution
to detect authentication bypass vulnerabilities in ﬁrmware.
Brumley et al. [ 38] showed that automatic patch-based ex-
ploit generation (APEG) was possible. They combine dynamic
symbolic execution and static control ﬂow graph analysis to
summarize the constraint formulae of the vulnerabilities, which
were successfully used to generate exploits for 5 real-world
vulnerabilities.
GUEB [ 39] searches for use-after-free vulnerability patterns
in the binary programs. It builds an abstract memory model for
the binary functions. Then it uses value set analysis to reason
each variable in the assignment and free instructions. If a
variable is used after the free instruction, GUEB reports it as avulnerability. It found one real-world use-after-free vulnerability
in ProFTPD program. LoongChecker [ 40] also uses value set
analysis to statically detect potential vulnerabilities in binaries.
The aforementioned works leverage program analysis meth-
ods to extract semantics of the binary program, and compare
them with certain models to discover potential vulnerabilities.
They require expertise to build such models speciﬁcally for a
speciﬁc type of vulnerabilities. Differently, our work aims at
automatically summarizing the patterns for different types of
vulnerabilities and using them to search for vulnerabilities.
Apart from these binary-level vulnerability modeling and
searching approaches, there are many works targeting vulnera-
bility modeling at the source code level. Yamaguchi et al. [ 41]
use a taint-style pattern to search vulnerabilities and ﬁlter out
irrelevant code. It can reduce the code base by 94.9% on average
to improve the code audit efﬁciency. Wagner et al. [ 42] reduce
the searching of the buffer overﬂow vulnerabilities to an integer
range analysis problem, which discovered vulnerabilities in the
Sendmail software. Averinos et al. [ 43] proposed an automatic
exploit generation tool and analyzed 20 open source programs.
They use preconditioned symbolic execution to generate control
ﬂow hijack attacks and discovered 2 unknown vulnerabilities.
However, those approaches work on the source code level;
but they fail to analyze binary-level patches. Moreover, more
attention has been paid to address the gap between the
source code and the compiled binaries [ 44]. The compiler will
introduce bugs even if the source code is correct. Therefore,
we choose to work on binary level to be closer to the
machine so that, ideally, the framework can capture all possible
vulnerabilities.
VII. C ONCLUSION
In this paper, we proposed a patch analysis framework
SPAIN to automatically learn the security patch patterns and
vulnerability patterns, and identify them from the program
binary executables. It has built the bridge from the binary
difﬁng to the automatic patch understanding. The experiments
have shown that SPAIN can correctly locate more than half
of the vulnerability patches in the binaries and ﬁnd n-day
vulnerabilities in major commercial software. SPAIN can be
useful in vulnerability and patch understanding, similar bug
hunting, binary code auditing, and, eventually, the program
security enhancement. In the future, we plan to extend the
framework to generate more detail and precise report of each
patch and vulnerability through program slicing and symbolic
execution, as well as to make it capable of analyzing binaries
with other instruction sets, like ARM. Also, we would like to
set up binary vulnerability databases with the help of the tool.
VIII. A CKNOWLEDGEMENTS
This research has been supported in part by the National Re-
search Foundation, Singapore under its National Cybersecurity
R&D Program (Award No. NRF2014NCR-NCR001-30), and
partially been sponsored by the National Science Foundation
of China (No. 61572349, 61272106, 61402179).
469
471
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] V . Ganesh, T. Leek, and M. Rinard, “Taint-based directed
whitebox fuzzing,” in ICSE , 2009, pp. 474–484.
[2] S. K. Cha, M. Woo, and D. Brumley, “Program-adaptive
mutational fuzzing,” in S&P , 2015, pp. 725–741.
[3] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Cor-
betta, Y . Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller:
Augmenting fuzzing through selective symbolic execution,” in
NDSS , 2016.
[4] C. Hu, Z. Li, J. Ma, T. Guo, and Z. Shi, “File parsing
vulnerability detection with symbolic execution,” in TASE , 2012,
pp. 135–142.
[5] J. Viega, J. T. Bloch, Y . Kohno, and G. McGraw, “Its4: a static
vulnerability scanner for c and c++ code,” in ACSAC , 2000, pp.
257–267.
[6] J. Hefﬂey and P . Meunier, “Can source code auditing software
identify common vulnerabilities and be used to evaluate software
security?” in HICSS , 2004, pp. 90 277–.
[7] J. Wang, B. Chen, L. Wei, and Y . Liu, “Skyﬁre: Data-driven
seed generation for fuzzing,” in S&P , 2017.
[8] F. Long and M. Rinard, “Automatic patch generation by learning
correct code,” in POPL , 2016, pp. 298–312.
[9] D. Kim, J. Nam, J. Song, and S. Kim, “Automatic patch
generation learned from human-written patches,” in ICSE , 2013,
pp. 802–811.
[10] S. Mechtaev, J. Yi, and A. Roychoudhury, “Directﬁx: Looking
for simple program repairs,” in ICSE , 2015, pp. 448–458.
[11] Y . Tian, J. Lawall, and D. Lo, “Identifying linux bug ﬁxing
patches,” in ICSE , 2012, pp. 386–396.
[12] C. S. Corley, N. A. Kraft, L. H. Etzkorn, and S. K. Lukins,
“Recovering traceability links between source code and ﬁxed
bugs via patch analysis,” in TEFSE , 2011, pp. 31–37.
[13] D. Gao, M. K. Reiter, and D. Song, “Binhunt: Automatically
ﬁnding semantic differences in binary programs,” in ICICS , 2008,
pp. 238–255.
[14] T. Schreck, S. Berger, and J. G ¨obel, “Bissam: Automatic
vulnerability identiﬁcation of ofﬁce documents,” in DIMVA ,
2013, pp. 204–213.
[15] F. Araujo, K. W. Hamlen, S. Biedermann, and S. Katzenbeisser,
“From patches to honey-patches: Lightweight attacker misdirec-
tion, deception, and disinformation,” in CCS , 2014, pp. 942–953.
[16] E. C. R. Shin, D. Song, and R. Moazzezi, “Recognizing functions
in binaries with neural networks,” in USENIX Security , 2015,
pp. 611–626.
[17] Hex-Rayd, “IDA Pro,” http://www.datarescue.com/idabase, Last
2016: Aug. 2016.
[18] H. Flake, “Structural comparison of executable objects,” in
DIMVA , 2004, pp. 161–173.
[19] D. Andriesse, X. Chen, V . van der V een, A. Slowinska, and
H. Bos, “An in-depth analysis of disassembly on full-scale
x86/x64 binaries,” in USENIX Security , 2016, pp. 583–600.
[20] K. Chen, P . Liu, and Y . Zhang, “Achieving accuracy and
scalability simultaneously in detecting application clones on
android markets,” in ICSE , 2014, pp. 175–186.
[21] L. Luo, J. Ming, D. Wu, P . Liu, and S. Zhu, “Semantics-based
obfuscation-resilient binary code similarity comparison with
applications to software plagiarism detection,” in FSE , 2014, pp.
389–400.
[22] Intel, “Intel 64 and ia-32 architec-
tures software developer’s manual,”
http://www.intel.com/content/www/us/en/processors/architectures-
software-developer-manuals.html, Last 2016: Aug. 2016.
[23] M. Chandramohan, Y . Xue, Z. Xu, Y . Liu, C. Y . Cho, and
H. B. K. Tan, “Bingo: cross-architecture cross-os binary search,”
inFSE , 2016, pp. 678–689.
[24] J. Pewny, B. Garmany, R. Gawlik, C. Rossow, and T. Holz,“Cross-architecture bug search in binary executables,” in S&P ,
2015, pp. 709–724.
[25] M. Cova, V . Felmetsger, G. Banks, and G. Vigna, “Static
detection of vulnerabilities in x86 executables,” in ACSAC , 2006,
pp. 269–278.
[26] J. Pewny, F. Schuster, L. Bernhard, T. Holz, and C. Rossow,
“Leveraging semantic signatures for bug search in binary pro-
grams,” in ACSAC , 2014, pp. 406–415.
[27] J. Park, M. Kim, B. Ray, and D. H. Bae, “An empirical study
of supplementary bug ﬁxes,” in MSR , 2012, pp. 40–49.
[28] SPAIN, http://pat.scse.ntu.edu.sg/spain/.
[29] A. Nistor, P .-C. Chang, C. Radoi, and S. Lu, “Caramel: Detecting
and ﬁxing performance problems that have non-intrusive ﬁxes,”
inICSE , 2015, pp. 902–912.
[30] F. Yamaguchi, M. Lottmann, and K. Rieck, “Generalized vulner-
ability extrapolation using abstract syntax trees,” in Proceedings
of the 28th Annual Computer Security Applications Conference .
ACM, 2012, pp. 359–368.
[31] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, BAP: A
Binary Analysis Platform , 2011, pp. 463–469.
[32] S. Letian, F. Jianming, C. Jing, and P . Guojun, “PVDF: An
automatic Patch-based Vulnerability Description and Fuzzing
method,” in CSC , 2014, pp. 1–8.
[33] M. Soto, F. Thung, C.-P . Wong, C. Le Goues, and D. Lo, “A
deeper look into bug ﬁxes: Patterns, replacements, deletions, and
additions,” in MSR , 2016, pp. 512–515.
[34] M. Kim and D. Notkin, “Discovering and representing systematic
code changes,” in ICSE , 2009, pp. 309–319.
[35] Y . Zhang, X. Sun, Y . Deng, L. Cheng, S. Zeng, Y . Fu, and
D. Feng, “Improving accuracy of static integer overﬂow detection
in binary,” in RAID , 2015, pp. 247–269.
[36] T. Wang, T. Wei, Z. Lin, and W. Zou, “Intscope: Automatically
detecting integer overﬂow vulnerability in X86 binary using
symbolic execution,” in NDSS , 2009.
[37] Y . Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and
G. Vigna, “Firmalice - automatic detection of authentication
bypass vulnerabilities in binary ﬁrmware,” in NDSS , 2015.
[38] D. Brumley, P . Poosankam, D. X. Song, and J. Zheng, “Automatic
patch-based exploit generation is possible: Techniques and
implications,” in S&P , 2008, pp. 143–157.
[39] J. Feist, L. Mounier, and M. Potet, “Statically detecting use
after free on binary code,” J. Computer Virology and Hacking
Techniques , vol. 10, no. 3, pp. 211–217, 2014.
[40] S. Cheng, J. Yang, J. Wang, J. Wang, and F. Jiang,
“Loongchecker: Practical summary-based semi-simulation to
detect vulnerability in binary code,” in TrustCom , 2011, pp.
150–159.
[41] F. Yamaguchi, A. Maier, H. Gascon, and K. Rieck, “Automatic
inference of search patterns for taint-style vulnerabilities,” in
S&P , 2015, pp. 797–812.
[42] D. Wagner, J. S. Foster, E. A. Brewer, and A. Aiken, “A ﬁrst step
towards automated detection of buffer overrun vulnerabilities,”
inNDSS , 2000.
[43] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley, “AEG:
automatic exploit generation,” in NDSS , 2011.
[44] V . D’Silva, M. Payer, and D. X. Song, “The correctness-security
gap in compiler optimization,” in SPW , 2015, pp. 73–87.
470
472
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:33:16 UTC from IEEE Xplore.  Restrictions apply. 