Debugging with Intelligence via Probabilistic Inference
Zhaogui Xu1, Shiqing Ma2, Xiangyu Zhang2*, Shuofei Zhu1and Baowen Xu1*
1State Key Laboratory of Novel Software Technology, Nanjing University, China
2Department of Computer Science, Purdue University, USA
ABSTRACT
Weaimtodebugasinglefailingexecutionwithouttheassistance
from other passing/failing runs. In our context, debugging is a pro-
cess with substantial uncertainty â€“ lots of decisions have to be
madesuchaswhatvariablesshallbeinspectedfirst.Todealwith
suchuncertainty,weproposetoequip machineswithhuman-like
intelligence.Specifically,wedevelopahighlyautomateddebugging
techniquethataimstocouplehuman-likereasoning(e.g.,dealing
withuncertaintyandfusingknowledge)withprogramsemantics
based analysis, to achieve benefits from the two and mitigate their
limitations. We model debugging as a probabilistic inference prob-
lem,inwhichthelikelihoodofeachexecutedstatementinstance
and variable being correct/faulty is modeled by a random variable.
Human knowledge, human-like reasoning rules and program se-
manticsaremodeledasconditionalprobabilitydistributions,also
called probabilistic constraints. Solving these constraints identi-
fies the most likely faulty statements. Our results show that the
techniqueishighlyeffective.Itcanpreciselyidentifyrootcauses
for a set of real-world bugs in a very small number of interactions
withdevelopers,muchsmallerthanarecentproposalthatdoesnot
encode human intelligence. Our user study also confirms that it
substantially improves human productivity.
CCS CONCEPTS
â€¢Software and its engineering â†’Software testing and de-
bugging;
KEYWORDS
Debugging, Probabilistic Inference, Python
ACM Reference Format:
ZhaoguiXu,ShiqingMa,XiangyuZhang,ShuofeiZhuandBaowenXu.2018.
DebuggingwithIntelligenceviaProbabilisticInference.In Proceedingsof
ICSEâ€™18:40thInternationalConferenceonSoftwareEngineering,Gothenburg,
Sweden, May 27-June 3, 2018 (ICSE â€™18), 11 pages.
https://doi.org/10.1145/3180155.3180237
1 INTRODUCTION
In this paper, we aim to tackle the traditional debugging prob-
lem â€“ given a faulty program and a single failing run, identify the
*Corresponding authors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180237root cause of the failure. In our target scenario, an oracle to tell
the intended behavior for each step of execution is not available.
As such, debugging becomes an uncertain procedure, in which a
lot of decisions have to be made, such as which statements aremorelikelyfaulty,whichvariablesshouldbeinspectedfirst,and
whether a function execution shall be stepped into. Algorithmic
debugging techniques tend to avoid making decisions by conserva-
tivelyincludingallthepossibilities.Forexampleindynamicslicing,givenafaultyoutput,alltheexecutedstatementinstancesthathavecontributedtotheoutputareincludedintheslice.Whilethesetech-
niquescanpreciselymodelandreasonaboutprogramsemantics,
they lack the capabilities of making appropriate predictions in the
presence of uncertainty. The onus is hence on the developers toinspect the large volume of analysis results. In contrast, duringhuman debugging, an experienced developer may not even start
fromthevicinityofthefaultyoutput.Instead,shemayspeculate
someplacesinthemiddleofexecutionthatcontainstatescritical
to the failure and inspect the corresponding variables. She decides
if a variable has a faulty value based on her experience and do-
main knowledge. In many cases, she can quickly identify the root
cause because she excels at collecting and fusing debugging hints
tomakethecorrectdecisions.Ononehand,manyofthesehintsare
highly uncertain (e.g., the variable name correlations between the
faulty output variable and the root cause) and hence can hardly be
leveragedbyalgorithmicdebuggingtechniques.Ontheotherhand,
humans do not have the capacity and stamina to reason about the
low level program semantics at a scale close to machines.
Human feedback driven debugging was hence proposed to in-
tegrate human reasoning and machine analysis [ 24,26,32]. For
instance, in a very recent proposal of interactiveslicing [ 24], the
toolreportsstatementinstancesinadynamicslicetothedeveloper,
oneatatimebasedontheirdistancetothefaultyoutput.Thede-
velopercanindicateifareportedinstanceisfaulty;andifnot,what
operands ofthe instanceare faulty. The toolthen recomputesthe
dynamicslicefromthefaultyoperands,precludingstatementin-
stances that led to the correct operands (in the instance). However,
inmostexistingtechniquesincluding[ 24],thecouplingbetween
machines and humans is very primitive: the machine analysis is
incapableofhandlinguncertaintyandhumansstillhavetomakeallthedecisions.Asaresult,theysufferfromlimitationssuchasexces-
sive requests for human intervention and false positives/negatives
due to human mistakes.
Wedevelopatechniquethatallowsmachinestotakeoveralarge
partofthehumanreasoningofuncertainty,andcouplesuchuncer-
taintyreasoningwithprecisemodelingoflowlevelprogramsemantics
such that we can achieve the benefits of both human and machine
reasoningsandmitigatetheirlimitations.Inparticular,wemodel
debuggingasaprobabilisticinferenceprocedure.Randomvariables
are introduced to denote the likelihood of statement instances and
11712018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Z. Xu, S. Ma, X. Zhang, S. Zhu and B. Xu
variablesbeingcorrect/faulty.Thesemanticsofeachexecutedstate-
ment is modeled as a conditional probability distribution, which is
also called probabilistic constraint in this paper (e.g., given â€œ x=yâ€, if
xislikelycorrect,then yislikelycorrect).Theoutputsaremodeled
as observations, e.g., the correct outputs are associated with proba-
bility 1.0 (of being correct) and the faulty outputs with probability
0.0.Humandomainknowledgeandfeedbackarealsoencodedas
probabilisticconstraints(e.g.,thelikelihoodofbeingbuggyfora
variable with a name correlated to the name of the faulty output
variableishigherthanothers).Theseconstraintscanberesolved
by a probabilistic inference engine [ 1]. The inference procedure is
similar to solving SMT/SAT constraints. The difference lies in that
ourinferenceresultsareposteriormarginalprobabilities(instead
ofsatisfyingvalueassignments)thatindicatethelikelihoodofeach
statement instance and variable being correct/faulty (given the ob-
servationsandthehumanfeedback).Theprocedureisanalogousto
applyingforcestoanelasticmesh,inwhichtheobservationsand
humanfeedbackareanalogoustotheforcesandthecorrelations
between statements/variables derived from program semantics are
analogous to the mesh. When the mesh finally stabilizes, the state
of each node on the mesh reflects the effect of the joint force.
Comparedtotheaforementionedexistingfeedbackdrivendebug-
ging,(1)developersâ€™intervention/feedbackissubstantiallyreduced
asthetechniquecanperformhuman-likereasoningindealingwith
uncertainty; (2) our technique allows developers to be uncertain
abouttheirfeedbackandhumanmistakescanbedilutedandeventu-allyover-poweredbyotherevidences;and(3)ithasthefullcapacity
of machine analysis by faithfully encoding program semantics.
Our contributions are summarized as follows.
â€¢We propose the idea of modeling debugging (a single failing
run) as a probabilistic inference problem such that our tech-
niquecanautomaticallyperformbothhuman-likereasoning
thatfeaturesuncertaintyhandlingandprogramsemantics
based reasoning that features precision.
â€¢We devise a comprehensive set of rules to encode both pro-
gramsemantics,observations,domainknowledge,andhu-
man feedback as conditional probability distributions.
â€¢We develop a prototype for debugging Python programs.
Our evaluation on real world bugs shows that on average
our tool can locate a root cause in 3 steps of interaction
with the developer for large projects, and 5 steps for smaller
programsfromstackoverflow.Incontrast,[ 24]requiresmore
than 10 steps and may miss the root causes. Our user study
shows that our tool can reduce debugging time by 34% on
average. The analysis time is within seconds for most cases.
2 MOTIVATION
MotivatingExample. Fig.1showsasimplifiedcodesnippetfrom
a popular Python HTTP library Requests [2]. Line 18 invokes func-
tionpath_url() definedinlines1-12.Insidethefunction,thepro-
gramfirstsplitstheinput urlintopathandquery(line2).Withthe
failure inducing input, the resulted values of pathandqueryare
"/t%20c" and"x=1", respectively. Line 3 encodes the path segment
of the url by replacing special characters with their encodings (e.g.,spacetoâ€˜%20â€™andâ€˜%â€™toâ€˜%25â€™)totranslateittothestandardHTML1: def path_url(url):
2: path, query = urlsplit(url)
3: path = encode(path)
4: if not path:
5: path = "/"
6: purl = []
7: purl.append(path)8: ifquery:
9: purl.append("?")
10: purl.append(query)11: purl_str = make_str(purl)12: return purl_str
13: def make_str(lst):
14: s = ""
15: for iinlst:
1 6 : s=s+i
17: return s
18: url=path_url("http://x.org/t%20c?x=1")19: print url
Figure 1: Motivating example.
URI format.Hence, the encoded pathhas thevalue "/t%2520c" (af-
ter replacing â€˜%â€™withâ€˜%25â€™). Lines 4-5 validate that pathis not
empty.Line6appends pathtoalistpurl.Lines8-10furtherappend
aseparatorsymbolâ€˜ ?â€™andquerytothelist.Line11callsthefunc-
tionmake_str() to transform purlto a string. Inside make_str() ,
lines13-17concatenateeachitemin purlandreturnthefinalvalue
"/t%2520c?x=1" . This code snippet is buggy at line 3 because the
pathisdoubleencoded,andthecorrectversionshouldcheckifit
has already been encoded before executing line 3. The expected
output should be "t%20c?x=1" withâ€˜%20â€™the encoding of space.
ExistingMethods. Inmanualdebugging,developersusepdb[ 3]
andPyCharm [ 4]debugger (i.e.,thePythonversionofgdb)to set
breakpoints at places that are considered suspicious and inspect
variablevaluesatthosepoints.Inthisprocedure,developershaveto
makealotofdecisionstodealwiththeinherentuncertainty.Many
ofthedecisionsaremadebasedontheirexperience.Forexample,
the library function append() is unlikely to be buggy so that the
developers do not need to step into its execution. However, the
effectivenessofmanualdebuggingheavilyhingesontheexperience
ofdevelopers.Moreover,humanshavelimitedcapacityofreasoning
aboutlowlevelprogramsemantics.Forexample,itisdifficultfor
humans to use debuggers to follow a lengthy data flow path.
Many automated debugging techniques, such as delta debug-
ging [8â€“11] andfault localization [ 15â€“18,20], arehighly effective.
But they often require a passing run that closely resembles the
failingrun,oralargesetofpassingandfailingruns,toserveasthe
referenceto suppressuncertainty.However inpractice,reference
run(s) with high quality may not be available.
Dynamic slicing identifies a subset of executed statements that
contributed to an observed faulty output based on program depen-
dencies. It makes very conservative assumptions in dealing withuncertainty. For instance, line 16 concatenates two substrings â€“
right-hand-side (rhs) sandi, toproduce theleft-hand-side (lhs) s.
If the lhs sis observed faulty, it assumes both the rhs sandiare
potentially faulty and includes both in the slice. In our example,the dynamic slice of the printed value of variable
urlat line 19
includes all the statements presented in this example, and also the
bodies of functions urlsplit() andencode() that are omitted. It
hence requires a lot of manualefforts to go through statements in
the slice in order to identify the root cause.
1172
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Debugging with Intelligence via Probabilistic Inference ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Recently,aninteractiveapproach[ 24]wasproposed.Itgradually
presents statement instances in a dynamic slice to the developer,
who provides feedback such as whether an instance itself is faulty.
Ifnot,thedevelopershallindicatewhichoperandoftheinstanceis
faulty.The techniquethen computesa newslice startingfrom the
faultyoperand.Itessentiallyprunespartoftheoriginalslicerelated
to thecorrect operand(s). Considerour example, it firstcomputes
the slice of line 19. The slice includes all the executed statement
instances. It first presents lines 19, 18 and 17 to the developer, one
atatime.Thedeveloperindicatesthatthosestatementsthemselves
are not faulty but rather their operands are faulty. It then presents
line 16 to the developer, who indicates that the rhs sis faulty but i
isnot.Assuch,thetechniquecomputesanewsliceon s,precluding
iand its dependencies. Although the technique does improve over
slicing, its integration between machines and humans is primitive.
Thealgorithmisfullydeterministicanddoesnothandleuncertainty,
and the developer merely serves as an oracle. As such, the number
of human interactions required can be large. In our example, it
requires 7 interactions until the root cause is identified. Moreover,
it does not handle/tolerate human mistakes. For example, if the
developer mistakenly determines iat line 16 is faulty and the rhs s
is correct, the root cause can never be reached.
OurIdea. Weproposeanautomatedtechniquethatcoupleshuman-
likereasoning(e.g.,handlinguncertainty,leveragingdomainknowl-edge,andfusingdebugginghintsfromvarioussources)withprecise
lowlevelprogramsemanticsbasedanalysis.Assuch,alargepart
of the human workload can be shifted to machines. The idea isto formulate debugging as a probabilistic inference problem. We
introduce randomvariables todenotethelikelihoodofindividual
statement instances and variables being correct/faulty, encode pro-
gram semantics, human reasoning rules as probabilistic constraints ,
andinputs,(faulty)outputs,humanfeedbackas observations that
aredenotedas priorprobabilities (i.e.,probabilitiesbeforeinference).
Thepriorprobabilitiesandconstraintsarefedtotheprobabilistic
inferenceenginetocomputethe posteriorprobabilities ofindivid-
ual statement instances and variables being correct/faulty. The
posteriorprobabilityofavariableisoftendifferentfromitsprior
probability,denotingabetterassessmentafterfusinginformation
from other related variables.
Next, we will walk through the example to intuitively explain
howourtechniqueidentifiestherootcause.Beforeinference, urlat
line19isassociatedwithaconstantpriorprobability LOW=0.05to
indicateitisfaultyand urlatline1isassociatedwith HIGH=0.95
to indicate that it is correct. It is standard in probabilistic inference
not to use 0.0 or 1.0, but rather values very close to them [ 50].
Sincewehavenoobservationsonotherprogramvariables,their
prior probabilities are set to a constant UNCERTAIN =0.5. The
inference engine takes the prior probabilities and the probabilistic
constraints derived from program semantics, and computes the
posterior probabilities. Next, we present some of the computed
posterior probabilities and explain their intuition.
From the program semantics constraints, urlis faulty at line
19suggeststhat urlat18and purl_str atline12are likelyfaulty,
withposteriorprobabilities(ofbeingcorrect)computedas0.0441
and0.0832afterinference.Theprocedureofcomputingposterior
probabilities from prior probabilities will be explained in later sec-
tions. The posterior probabilities model the following. There aretwopossiblereasonsleadingtothefaultyvalueof url.Oneisthe
executedstatementatline12isbuggy(buttheoperand purl_str
is correct)and the other isthe value of operand purl_str is faulty.
Since there is no other observation indicating the simple return
statementisfaulty,thecomputedposteriorprobabilitiesindicate
that it is more likely that purl_str has an incorrect value. Note
that a variable being faulty does not mean our tool reports it tothe developer as all the variables along the failure propagationpath (i.e., the dependence path from the root cause to the faultyoutput) are faulty but we are interested in the root cause, which
is a statement instance. Leveraging data flow constraints, our tool
further infers that variable purl_str being likely faulty at line 12
entails that sat line 17 is likely faulty and hence sat line 16 likely
faulty (with probability being 0.1176). Line 16 is executed three
times, producing three svalues, namely, "/t%2520c" ,"/t%2520c?"
and"/t%2520c?x=1" .Whencomparingthegeneratedoutputwith
theexpectedoutput,ourtoolalsomarkedthecorrectnessofindivid-
ual bytes. Hence, at this point, it can factor in the observation that
the output substring "20c?x=1" created by the last two instances
of line 16 is correct. This suggests that the root cause is unlikely
atline16,reflectedbythecomputedposteriorprobability0.6902.
Instead, the first instance of iat line 16 is likely faulty.
Our tool also encodes various human domain knowledge as
probabilisticconstraints.Forexample,thenameofthefaultyoutput
variableandthenameofafunctionthatcontainstherootcausetend
tohavesomecorrelationintermsofnaturallanguagesemantics.As
such,function path_url() isconsideredmorerelevantthanfunction
make_str() , reflected by larger prior probabilities for statements in
theformer.Thefirstinstanceof iatline16beingfaultysuggests
that the resulted purlat line 7 (inside path_url() ) is likely faulty
(i.e., posterior probability 0.2892 being correct). Again, there are
two possible sources that lead to the faulty state of purlat 7: (1)
theappend() functionisfaultyand(2) pathisfaulty.Ourtoolhas
encodedthedomainknowledgethatanexternallibraryfunction
is less likely faulty than user code. This leads to (2) out-weighting
(1) during inference. Note that it is not a problem for our tool even
if the heuristics do not apply (e.g., the root cause does reside in
library instead of user code) as our technique is probability based.
Theeffectofaheuristiccanbeout-weightedbyevidencescollected
from other sources.
Variable pathat line 7 being faulty suggests either (A) the rhs
pathat line 3 is faultyor (B) line 3 itself is faulty. The observation
that input urlat line 1being correct (as itis from the input)leads
topathandqueryat line 2 are likely correct because they are iden-
tical to parts of url. This further suggests the rhs pathat line 3
islikelycorrect.Assuch,(B)islikelytrueandhenceline3isthe
statement instance with the lowest posterior probability (0.1075)
being correct. Note that statement instance probabilities are dif-ferent from variable probabilities as the former indicates wherethe root cause is. Although we describe the procedure step-by-step,
our tool encodes everything as prior probabilities and probabilistic
constraints that are automatically resolved. In other words, the entire
aforementioned procedure is conducted internally by our tool and
invisible to the developer. Also observe that the inference procedure
is bidirectional, e.g., the backward reasoning from the output atline 19 and the forward reasoning from the input at line 1. It is
iterativeaswellandterminateswhenafixedpointisreached. These
1173
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Z. Xu, S. Ma, X. Zhang, S. Zhu and B. Xu
	
 	
 	

   		
 
 	  		 
 	 	
Figure 2: System Framework.
features distinguish our technique from iterative slicing (e.g., [ 24])
ortechniquesthatpresentadynamicslicetothedeveloperthrough
interactions(e.g.,[ 32]),asslicingdoesnotconductanybidirectional
or fixed-point (probabilistic) reasoning, but rather traverses program
dependencies.Thestatementinstancewiththelargestprobability
to be faulty is reported to the developer. If the developer disagrees,
shecanfurtherprovideherassessmentaboutthe likelihood thatthe
operandsinthereportedstatementinstancearefaulty.Thefeed-
backisencodedasanewobservation,i.e.,newpriorprobabilities
that can be propagated backward and forward, and another round
of inference is performed to identify the new root cause candidate.
Note that human mistakes in feedback can be tolerated as they do
notleadtotheexclusionoftherootcausebutratherjustafewmore
extra rounds before locating the root cause. This faithfully mimics
howhumanmistakesaretoleratedinrealworldmanualdebugging.
Inourexample,ourtoolcorrectlyreportsthetruepositiveinthe
first round, which is much more effective than [24].
3 OVERVIEW
In this section, we give an overview of our system.
Framework. Fig. 2 presents the system architecture of our tool.
It consists of four components: the tracing component, the prob-abilistic constraint encoding component, the probabilistic infer-
ence engine and the feedback component. The tracing component
takesthebuggyprogramandatestinputandgeneratesthetrace
ofafailingexecution.Theprobabilisticconstraintencodingcom-
ponentautomaticallyencodespriorprobabilitiesandconstraints
from various resources. It consists of two subcomponents: variable
correctness/faultiness probabilistic constraint encoder andstatement
instancecorrectness/faultinessencoder.Theformergeneratesprior
probabilitiestoindicateinitialobservationsofvariablecorrectness/-faultiness.Suchpriorprobabilitieshavethreepossibleconstantval-
ues:HIGH=0.95 to denote a variable having a correct value (e.g.,
an input variable or an output variable holding a correct value),
LOW=1âˆ’HIGH=0.05 to denote a variable having a faulty
value (e.g., a faulty output variable), and UNCERTAIN =0.5t o
denotewehavenoobservation/prior-knowledgeaboutavariable
(mostvariablesfallintothiscategory).Itisstandardtousethese
constant values as prior probabilities [ 50]. We will study the effect
ofhavingdifferent HIGHconfigurationsinSection6.Besidesprior
probabilities, it also generates constraints that correlate probabili-
ties according to program semantics (e.g., x=ydictates the strong
correlation between xandyâ€™s probabilities).The inferenceengine
takesthepriorprobabilitiesandtheconstraints,performsproba-
bilityinferencetocomputeposteriorprobabilities.Theinference
procedurecanbeintuitivelyconsideredasaprocessoffusinghintsxâˆˆRuntimeVariableSet inst âˆˆExecutedStatementInstanceSet
P(x/inst )asserts a variable xor a statement instance instis correct.
S(inst )asserts a statement instance instis correct from the program structure.
N(inst )asserts a statement instance instis correct from the naming convention.
C:apâˆ’ â†’brepresents a probabilistic constraint denoting predicate ahas a
propagation probability pimplying predicate b.
Figure 3: Basic Definitions.
from various observations (i.e., HIGH/LOWprior probabilities)
throughthepropagationchannelsdictatedbytheconstraints.At
the end, many variables that had UNCERTAIN prior probabili-
ties now have posterior probabilities different from UNCERTAIN ,
indicating their likelihood of being correct/faulty.
The secondsubcomponent, the statement instanceencoder, au-
tomatically generates constraints to infer if individual statement
instances are correct/faulty from variable probabilities and domain
knowledge.Theearlierinferenceresultsofvariablecorrectness/-
faultiness are provided as prior probabilities to the statement in-
stanceinferenceprocedure.Eventually,thestatementinstancesare
ranked by their posterior probabilities. The one with the largest
probabilityofbeingfaultyisreportedastherootcausecandidate.If
the developer disagrees, she provides feedback to indicate whether
the reported statementinstance containsfaulty variable(s),which
may trigger another round of encoding and inference. The process
is iterative till the root cause is identified.
MotivationExampleWalk-through. Wesimplifytheexecution
traceofthemotivatingexampleinFig.1asthefollowingtoillustrate
the workflow of our technique.
e1:url2=url1(L1)
e2:p1=url2[0](L2)
e3:path1=m1[p1](L3)e4:s1=path1+"?"(L16)
e5:s2=s1+query1(L16)
e6:url3=s2(L17)
Table1:SimplifiedTraceoftheMotivatingExampleinFig.1.
All the runtime variables in the trace are transformed to the
Static Single Assignment (SSA) form so that each of them is defined
exactlyonce.Thesubscriptofavariableisusedtoidentifyaspecific
instance of the variable. The line numbers of these trace events
arealsoshownontheirright(e.g.,L2meansline2).Thevalueof
variableurl3is faulty whereas url1andquery1are correct.
Phase I: Inferring Variable Correctness/Faultiness Probabilities. With
the execution trace, our encoding component first performs dy-
namicslicingfromthefaultyoutputvariable(s)andthenencodes
thesemanticsofeacheventintheslice.Withthesimplifiedtracein
Table 1, the faulty output is url3, whose dynamic slice contains all
theevents.Takeevent e5asanexample.Giventhebasicdefinitions
shown in Fig. 3, the variable constraints are encoded as follows.
P(s1)âˆ§P (query1)0.95âˆ’âˆ’âˆ’â†’P (s2) (1)
P(s2)âˆ§P (query1)0.95âˆ’âˆ’âˆ’â†’P (s1) (2)
P(s1)âˆ§P (s2)0.95âˆ’âˆ’âˆ’â†’P (query1) (3)
Since we do not know which step executes a faulty statement in
thisphase,weinitiallyassumeeveryexecutedstatementinstance
is likely correct. Therefore, given the assumption that the addition
statement is correct in event e5, constraint (1) represents if both
operandsarecorrect,theproducedvalueisalsocorrectwithahigh
probability( HIGH=0.95).Thisprobabilityisassociatedwiththe
constraint(insteadofavariable)andcalledthe propagationprobabil-
ity. Intuitively, it can be considered as an information flow throttle
1174
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Debugging with Intelligence via Probabilistic Inference ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
during inference, controlling how much s2â€™s probability is affected
bythoseof s1andquery1.Notethatthepowerofprobabilisticin-
ferenceliesinautomaticallycorrecting initialbeliefs/assumptions
byfusinginformation.Forinstance,observationsabout s2orvalues
computedfrom s2(inotherstatementinstances)wouldallowthe
enginetoadjusttheprobabilityof s2ine5andpotentiallythebelief
about the correctness of e5.
Constraints(2)and(3)representiftheresultaswellaseitherone
of the two operands are correct, the other operand is likely correct.
Intuitively, since it is a one-to-one mapping between the operands
and the result value for an addition, the propagation probability is
HIGH.Thepropagationprobabilityislowerforotherstatements
that denote many-to-one mapping. For instance, for the statement
executedatevent e3,ifweknowboth path1andm1arecorrect,the
likelihood of the index p1being correct is dependent on if there
exist multiple indexes whose corresponding array values are the
same as the value of path1. If there are no other array elements
thathavethevalueof path1,p1iscorrect.Iftherearemanysuch
elements, we essentially get no hints about p1â€™s correctness. The
detailed computation rules of the propagation probability for each
kindofstatementarepresentedinSection5.1. Besidesencoding
constraints,ourtoolalsoencodespriorprobabilities(forinputsand
outputs). For example, we have the following prior probabilities in
the parentheses for the trace in Table 1.
P(url3)=1(0.05)P(url1)=1(0.95)
P(query1)=1(0.95)(4)
We send the encodings to a probabilistic inference engine to
computetheposteriorprobabilityofeachpredicate P(x)beingtrue.
Duringprobabilisticinference,arandomvariableisassociatedwitheachpredicatetoindicatethelikelihoodofthepredicatebeingtrue.
Theinferenceenginetransformsconstraintsandpriorprobabilities
toafactorgraph andthenusesthe Sum-Product [30]algorithmto
computethe posteriorprobabilities. We willdisclose moredetails
about probabilistic inference in the next section. For this example,
theposteriorprobabilitiesofpredicates P(s1),P(query1)andP(s2)
being true are 0.1302, 0.9197 and 0.0741, respectively.
PhaseII:InferringStatementInstanceCorrectness/FaultinessProba-bilities.Inthisphase,weleveragethevariableprobabilities(from
PhaseI)anddomainknowledgetodeterminethelikelihoodofeach
executedstatementinstancebeingcorrect/faulty.Particularly,we
generatethreekindsofconstraints.First,wegenerateconstraints
correlating variable probabilities and statement instance probabili-
ties. For event e5, we generate the following constraints.
Pe5(s2)âˆ§(Pe5(s1)âˆ§Pe5(query1))0.95âˆ’âˆ’âˆ’â†’P (inste5)(5)
Â¬Pe5(s2)âˆ§(Pe5(s1)âˆ§Pe5(query1))0.95âˆ’âˆ’âˆ’â†’Â¬P (inste5)(6)
Â¬Pe5(s2)âˆ§(Â¬Pe5(s1)âˆ¨Â¬Pe5(query1))0.95âˆ’âˆ’âˆ’â†’P (inste5)(7)
Intuitively, constraint (5) represents if all the involved values
at event e5are correct, the addition operation is likely correct.
Constraint (6) represents if the resulted value is faulty and bothoperandsarecorrect,theadditionoperationislikelyfaulty.Con-straint (7) denotes if the resulted value is faulty and at least one
operandisfaulty,theadditionoperationislikelycorrect.According
to constraint (7), since the probabilities of both P(s2)(0.0741) andP(s1)(0.1302) are low, the statement instance e5is likely correct
and the root cause is likely before e5.
Second,itgeneratesconstraintsfromprogramstructure.Inprac-
tice, programs often have modular design to achieve functional
coherence.Therefore,ifafunctionincludesalargenumberofstate-
mentsthatareexecutedandincludedintheslice,thefunctionis
likely to include the faulty statement (i.e., root cause). In our exam-
ple, more statements from function path_url() are included in the
slicethanfrom make_str() ,hencestatementinstancesintheformer
function are given priority over those in thelatter.The constraint
related to e5is shown in the following.
S(inste5)0.95â†âˆ’âˆ’â†’P (inste5)S(inste5)=1(0.70)(8)
PredicateS(inste5)anditspriorprobability0.70representthe
prediction of e5being correct based on its structure. Here, since e5
is inside make_str() , itsprior probability(of correctness)is higher
than those in path_url() . The prior probability 0.70 is derived
through program analysis (see Section 5.2). During inference, it
adds weight to the posterior probability of P(inste5).
Third, our technique generates constraints from the naming
convention.Weassumethatfunctionnamesandvariablenames,
including those of the observed faulty variables, follow certainnaming conventions and these names suggest functionalities tosome extent. If two variable names are correlated in the natural
language perspective, their functionalities are possibly related too.
Forour example,the function name "path_url" ismore similarto
the name of the observed faulty variable "url"than the function
name"make_str" .It suggeststhat statementinstances infunction
path_url() havestrongercorrelationswiththefailurethanthose
infunction make_str() andhenceshallbegivenhigherpriority.For
example, the naming constraints of e3are shown as follows.
N(inste3)0.95â†âˆ’âˆ’â†’P (inste3)N(inste3)=1(0.275 )(9)
PredicateN(inste3)denotes if e3is predicted to be fault related
by naming convention. The prior probability 0.275 is derived from
NLP analysis (see Section 5.2).
Finally,wesendtheseconstraintsandpriorprobabilitiesagain
to the inference engine to compute the posterior probabilities of
statementinstances.Wereportthemostlikelyfaultyinstance.In
this example, event e3has the smallest probability of being correct.
It is indeed the true root cause.
4 PROBABILISTIC INFERENCE
In this section, we illustrate how probabilistic inference is con-ducted. First of all, we present some basic notations. We denoteeach involved predicate
Pby an individual random variable x.
Givenasetofprobabilisticconstraints C1,C2,...,andCm,w euse
asetofcorrespondingprobabilisticfunctions f1,f2,...,andfmto
describethevaluationoftheseconstraints.Formally,aprobabilistic
function fican be presented as the following.
fi(x1,x2,...,xk)=/braceleftBiggpif the constraint Ciis true.
1âˆ’potherwise(10)
wherex1,x2,...,xkdenotetherandomvariablesassociatedwiththe
constraint Ciandprepresentsthepriorprobabilityoftheconstraint
yielding true. Probabilistic inference is essentially to satisfy all the
1175
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Z. Xu, S. Ma, X. Zhang, S. Zhu and B. Xu
Table 2: Boolean Constraints with Probabilities.
x1x2x3f1(x1,x2,x3)f2(x1,x2,x3)f3(x2)f4(x3)
000 0.95 0.95 0.05 0.95
001 0.95 0.95 0.05 0.05
010 0.95 0.95 0.95 0.95
011 0.95 0.05 0.95 0.05
100 0.95 0.95 0.05 0.95
101 0.95 0.95 0.05 0.05
110 0.05 0.95 0.95 0.95
111 0.95 0.95 0.95 0.05
constraints. In this context, the conjunction of the constraints can
be denoted as the product of all the corresponding probabilistic
functions, as shown in the following.
f(x1,x2,...,xn)=f1Ã—f2Ã—...Ã—fm (11)
Thejointprobabilityfunction[ 30],whichisessentiallythenormal-
ized version of f(x1,x2,...,xn), is defined as follows.
p(x1,x2,...,xn)=f1Ã—f2Ã—...Ã—fm/summationtext
x1,... ,xn(f1Ã—f2Ã—...Ã—fm)(12)
The posterior(marginal) probabilityof xi, denotedas p(xi), isthe
sum over all variables other than xi[30].
p(xi)=/summationdisplay
x1/summationdisplay
x2.../summationdisplay
xiâˆ’1/summationdisplay
xi+1.../summationdisplay
xnp(x1,x2,...,xn)(13)
Example. WeusetheexampleinSection3toillustratemoredetails.
For simplicity, we only consider the inference for constraints (1)
and (2) in phase I for the event e5. Let random variables x1,x2and
x3denotethepredicate P(s1),P(query1)andP(s2),respectively.
Hence, we have the following formula for constraints (1) and (2).
C1:x1âˆ§x20.95âˆ’âˆ’âˆ’â†’x3C2:x3âˆ§x20.95âˆ’âˆ’âˆ’â†’x1(14)
We assume the prior probabilities of x2andx3are 0.05 and 0.95,
respectively. They are denoted as follows.
C3:x2=1(0.95)C4:x3=1(0.05) (15)
Wethentransformeachconstrainttoaprobabilityfunction,e.g.,
theprobabilityfunction f1forconstraint C1ispresentedasfollows.
f1(x1,x2,x3)=/braceleftBigg0.95 if (x1âˆ§x2â†’x3)=1
0.05 otherwise(16)
Others are transformed similarly. Table 2 presents the values of
theprobabilityfunctions.Assumewewanttocomputetheposterior
marginalprobability p(x1=1),whichmeanstheprobabilityof s1
being correct. The computation is as follows.
p(x1=1)=/summationtext
x2,x3f1(1,x2,x3)Ã—f2(1,x2,x3)Ã—f3(x2)Ã—f4(x3)
/summationtext
x1,x2,x3f1(x1,x2,x3)Ã—f2(x1,x2,x3)Ã—f3(x2)Ã—f4(x3)
=0.95Ã—0.95Ã—0.05Ã—0.95+...+0.95Ã—0.95Ã—0.95Ã—0.05
0.95Ã—0.95Ã—0.05Ã—0.95+...+0.95Ã—0.95Ã—0.95Ã—0.05
=0.1309
0.9927=0.1319(17)
Itisthesumoftheproductofvaluationswith x1=1(e.g.,thefirst
item0.95Ã—0.95Ã—0.05Ã—0.95istheproductof f1(x1=1,x2=0,x3=
0)=0.95,f2(1,0,0)=0.95,f3(1,0,0)=0.05 andf4(1,0,0)=0.95)
divided by the sum of the product of all valuations.
Implementation. Inpractice,thecomputationofposteriormar-
ginal probabilities is very expensive. In our implementation, we
representalltheprobabilisticconstraintswithagraphicalmodel
calledfactor graph [30], which supports efficient computation. WeA.VariableConstraints
P(pred )âˆ§/logicalandtext
uâˆˆUses (e)P(u)HIGHâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’P (def ) [1]
foreachuâˆˆUses (e)â‡’
P(pred )âˆ§P (def )âˆ§/logicalanddisplay
xâˆˆUses (e)/uP(x)puâˆ’âˆ’âˆ’â†’P (u) [2]
P(def )âˆ§/logicalandtext
xâˆˆUses (e)P(x)HIGHâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’P (pred ) [3]
B.ComputationRulesof p uin[2]
s:z=Ï…|x|x bopy bopâˆˆ{+,âˆ’,Ã—,/}
pu=HIGH[1TO1]
s:z=xmody
px=UNCERTAIN[MOD]
s:y=x.fV a l u e s (y)=vV a l u e s (x)=o
px=Ïˆ(|objsWithAttrVal (â€œfâ€,v)|)âˆ§po.f=HIGH[AR]
s:y=x[i]Values (x)=oV a l u e s (i)=viValues (y)=v
px=Ïˆ(|cltsWithIdxVal (vi,v)|)âˆ§
pi=Ïˆ(|idxesWithVal (v,o)|)âˆ§po[vi]=HIGH[SR]
s:ifx==ythens1elses2Values (x)=Values (y)
px=HIGHâˆ§py=HIGH[EQ]
s:ifx/nequalythens1elses2Values (x)/nequalValues (y)
px=0.5âˆ§py=0.5[NEQ]
Function Definitions:
Ïˆ(n)=0.5+0.5Ã—(2Ã—HIGHâˆ’1)Ã—1
nValues (x)the value of xobserved during execution
objsWithAttrVal (a,v)returns objects having attribute awith value v
objsWithAttr (a)returns the objects having attribute a
cltsWithIdxVal (i,v)returns collections having value vat indexi
idxesWithVal (v,c)returns indexes containing value vin collection c
Figure 4: Variable Constraints.
compute marginal probabilities based on the Sum-Product algo-
rithm [30]. The algorithm is essentially a procedure of message
passing(alsocalled beliefpropagation),inwhichprobabilitiesare
only propagated between adjacent nodes. In a message passing
round, each node first updates its probability by integrating all the
messagesitreceivesandthensendstheupdatedprobabilitytoits
downstream receivers. The algorithm is iterative and terminates
when the probabilities of all nodes converge. Our implementation
is based upon libDAI[1], a widely used open-sourced probabilistic
graphical model library.
5 CONSTRAINT GENERATION
Inthissection,wepresenthowtogenerateprobabilisticconstraints.
As discussed in Section 3, our analysis consists of two phases. In
the first phase, we generate variable constraints and in the second,
we generate statement instance constraints.
5.1 Variable Constraint Generation
Inthefirstphase,constraintsareconstructedfromtheexecution
tracetomodeltheprobabilitiesofvariablesandbranchpredicate
states. Note that in this phase we only reason about the correct-
ness/faultinessofvariables,whichwillbeusedtoinferstatement
instancecorrectness/faultinessinthenextphase.Intuitively,our
design can be understood as first finding the correctness/faultiness
ofvariables,thenthestatementinstancesthathaveoperandslikely
correct but the result variable likely faulty are likely buggy.Encoding Rules.
Fig. 4A presents the encoding rules. Rule [1] en-
codes the forward causality of a statement instance e, denoting the
1176
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Debugging with Intelligence via Probabilistic Inference ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
propagationofthelikelihoods(ofbeingcorrect)fromthecontrol
dependence predicate pred(i.e.,econtrol depends on pred), the
uses (i.e., rhs operands of e) to the definition (i.e., lhs variable def).
Intuitively,iftheusesandthecontroldependencearecorrect,there
isgoodchancethelhsvariablehasacorrectstate.Rule[2]encodes
the backward causality, denoting the propagation of correctness
likelihood from the lhs variable to oneof the used variables. In-
tuitively, if the lhs variable, the control dependence, and all the
otherrhsoperandsarecorrect,theremainingrhsoperand uhaspu
(notHIGH) probability to be correct. Different kinds of statements
have different puvalues. Details will be explained later. Rule [3]
representsthecausalityforpredicates.Ifalltherelatedvariablesin
a statement instance ehave correct states, the control dependence
predis likely correct (i.e., the correct branch has been taken).
Computation Rules of the Backward Propagation Probabil-ityp
u.Fig.4Bpresentspartofthecomputingrulesof pu(inRule
[2]).Theessenceoftheserulesistodetermine pubasedonwhether
the computation is a one-to-one or many-to-one mapping. Rule
[1TO1]specifiesthecomputationruleforstatementsdenotingone-
to-onemappings.Inthiscase, puisHIGHtoindicateifthelhsis
correct,arhsoperandisdeterminedtobecorrectwhenallother
rhsoperandsarecorrect(e.g.,when z=x+y,zandxlikelycorrect
indicates ylikelycorrect).[MOD]specifiesforamodoperation z
=xmody,zandybeing correct does not hint xis correct. This
is reflected by px=UNCERTAIN (0.5), which means there is no
evidenceindicatingthecorrectnessof x.Intuitively,givenaspecific
yvalue (e.g., y=10), there are many possible values of xthat yield
thesame zvalue(e.g., z=1)byz=xmody(e.g.,x=11,21,31,...).
Hence,xâ€™s correctness is unknown.
[AR] is for an attribute read. It means that yandxcorrect in-
dicates the attribute read o.fis likely correct (i.e., po.f=HIGH)
withotheobjectin x.Ontheotherhand,if yando.fcorrect,the
likelihoodof xbeingcorrectdependsonthenumber nofobjects
thathavethesame ffieldandthesamefieldvalue v.Itiscomputed
asÏˆ(n). Particularly, when n=1, the probability is HIGH.I fnis
large, theprobability tends to be0.5 (i.e., correctness isunknown).
The rule for attribute write is similar and hence elided.
[SR] specifies the rule for an element read of a collection, which
includes three uses, i,x, andx[i] and one definition y. The rule
means when y,i, andx[i] are correct, the likelihood of xcorrect,
px, depends on the number of collection objects that have value v
atindexvi;wheny,x[i],andxarecorrect,thelikelihoodof ibeing
correct,pi, depends on the number of indexes in the collection
objectothat store the same value v; wheny,x, andiare correct,
the array element is likely correct. We use po[vi]instead of px[i]
becauseduringinference,therandomvariableisassociatedwith
the collection element o[vi] instead of the symbol x[i].
[EQ]istheruleforequivalencecheck,whichhastwouses xand
yandadefinition,namely,thebranchoutcome.Itmeansthatif x
andyare equivalent, the branch outcome and xcorrect indicates y
correct (i.e., py=HIGH), and similarly the branch outcome and y
correctindicates xcorrect.Intuitively,equivalencerelationdenotes
a one-to-one mapping. For instance, assume x==10 yielding true
is correct and 10 is correct, a faulty xcannot yield the correct
branch outcome. In contrast, [NEQ] indicates that if xandyare
inequivalent, the branch outcome and xbeing correct does not
suggestycorrect.Intuitively,inequivalenceindicatesamany-to-oneA.Variableâˆ’toâˆ’Statement Constraints
Pe(pred )âˆ§Pe(def )âˆ§/logicalandtext
uâˆˆUses (e)Pe(u)HIGHâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’P (inste) [1]
Pe(pred )âˆ§Â¬Pe(def )âˆ§/logicalortext
uâˆˆUses (e)Â¬Pe(u)HIGHâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’P (inste) [2]
Pe(pred )âˆ§Â¬Pe(def )âˆ§/logicalandtext
uâˆˆUses (e)Pe(u)HIGHâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’Â¬P (inste) [3]
B.Program Structure Constraints
S(inste)HIGHâ†âˆ’âˆ’âˆ’âˆ’â†’P (inste)S(inste)=1(spe) [4]
spe=1
2Ã—[Ï•1(|sliceInFunc (e)|
|fullSlice ()|)
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright
1+Ï•2(|instsNotInSlice (e)|
|allInsts (e)|)
/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext /bracehtipupright
2]
C.Naming Convention Constraints
N(inste)HIGHâ†âˆ’âˆ’âˆ’âˆ’â†’P (inste)N(inste)=1(npe) [5]
npe=1
2Ã—[Ï•1(simFunc (e))/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipupright
1+Ï•1(simStmt (e))/bracehtipupleft/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipdownright/bracehtipdownleft /bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehext/bracehtipupright
2]
Function Definitions:
Ï•1(x)=0.5âˆ’0.5Ã—(2Ã—HIGHâˆ’1)Ã—x
Ï•2(y)=0.5+0.5Ã—(2Ã—HIGHâˆ’1)Ã—y
sliceInFunc (e)returns the instances in slice that belong to the function of e.
fullSlice ()returns all the instances in the slice.
instsNotInSlice (e)returns instances of the statement of ethat are not in the slice.
allInsts (e)returns all the instances of the statement of e.
simFunc (e)calculates the similarity between the function name of eâ€™s statement
and the faulty output variableâ€™s name.
simStmt (e)returns the average similarity between each involved variable name
inewith the faulty output variableâ€™s name.
Figure 5: Statement Instance Constraints.
mapping.Forinstance,assume x/nequal10yieldingtrueiscorrectand
10 is correct,there aremany values of xthat canyield thecorrect
branchoutcomeandhencewecannotgainanyconfidenceabout
the correctness of x. The rules for other comparative operations
(e.g.,>and<) are similarly defined.
5.2 Statement Instance Constraint Generation
We generate three kinds of constraints for statement instances: (1)
variable-to-statementconstraints modelingthecausalitybetween
variable probabilities and statement instance probabilities; (2) pro-
gram structure constraints modeling hints from program structure;
(3)namingconventionconstraints modelinghintsfromnames.We
reason about statement instances instead of statements because
aninstanceofafaultystatementmaynotinduceanyfaultystate
atall,forexample,â€˜ x>10â€™beingmistakenasâ€˜ x>=10â€™doesnot
induce any faulty states for any x/nequal10. In this case, we consider
the instance as correct. Hence in this paper, we do not allow the
likelihood of an instance being correct/faulty to directly affect the
likelihood of another instance of the same statement.
Variable-to-Statement Constraints. Constraint [1] in Fig. 5A
denotes that if all the variables involved in a statement instance e,
includingthecontroldependence,thedefinitionandalltheusesarecorrect,theinstanceislikelycorrect.Constraint[2]representsthat
if the control dependence is correct, but the definition and at least
oneusearefaulty,theinstanceislikelycorrect.Thisisbecausethe
root cause must happen before the current instance. Constraint [3]
denotesthatwhenallusesarecorrectbutthedefinitionisfaulty,
the statement instance is likely faulty (i.e., the root cause). We use
theposteriorvariable probabilitiesfromthepreviousphase asthe
prior probabilities of variables in this phase.Program Structure Constraints.
From program structure, we
can extract hints to enhance inference. Given an instance eof
statement s, we consider the following two kinds of hints from
program structure. First, at the function level, we focus on how
1177
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Z. Xu, S. Ma, X. Zhang, S. Zhu and B. Xu
manyinstancesintheslicebelongtothefunctionof s.Thelargerthe
number,themoresuspicious eis,becausethefaultyoutputismore
likelycomposedinthefunction. Second,atthestatementlevel,we
considerhowmanyotherexecutedinstancesofstatement sarenot
intheslice.Specifically,if sisexecutedmanytimesbutonlyafewof
them are included in the slice of the failure, the statement instance
islesslikelyfaulty.Forexample,somelow-levelutilityfunctions
(e.g.,make_str() in the Fig. 1) are called many times at different
points and only a few of them are related to the failure. Statement
instances in these low level functions are unlikely suspicious.
Fig.5Bpresentstheprogramstructureconstraintswhere S(inste)
asserts that instance eis correct from the program structure per-
spective. The prior probability speofS(inste)is computed by the
average of twoparts. Part 1computes the probabilityat the func-
tionlevel.Ifmanyinstancesinthefunctionof eareincludedinthe
slice,theprobabilitytendstobe LOW,denotingtheyaresuspicious.
Otherwise,ittendstobe0.5.Part 2computestheprobabilityatthe
statement level.If manyinstances of thestatement of eare notin
the slice, the probability tends to be HIGH, suggesting correctness.
Otherwise, it tends to be 0 .5.
NamingConventionConstraints. Givenafaultyvariable xand
aninstance eofstatement s,wecollecttwokindsofnamingcon-
vention hints. First, we measure how similar the function name of
statement sistothenameoffaultyoutputvariable x.Thehigher
the similarity, the more suspicious eis. Second, at the statement
level, we consider the similarity between the name of the faultyoutput variable
xwith variable names in the statement s. When
theaveragesimilarityishigh,thesuspiciousnessof eishigh.For
example, in the example of Fig. 1, instances of line 16 are consid-
eredlesssuspiciousthaninstancesofline11because "url"ismore
similar to { "purl_str", "purl" } than to { "s", "i"}.
Fig.5Cpresentsthenamingconventionconstraintswhere N(inste)
asserts that instance eis correct from the naming convention per-
spective. The computation of the prior probability npeofN(inste)
consists of two parts. Part 1computes the probability from the
function level naming convention. Intuitively, if the similarity ishigh,theprobabilityapproaches1
âˆ’HIGH.Otherwise,theprob-
abilityapproaches0.5.Part 2computestheprobabilityfromthe
statement level naming convention.
Thecomputationoflexicalsimilaritiesbetweenstringsissimilar
totheoneillustratedinSection5.4inourpriorwork[ 51].Weomit
the details due to the space limitation.
6 EVALUATION
We implement a prototype in Python for debugging Python pro-
grams.WechoosePythonasithasbecomeoneofthemostpopular
programming languages [ 7]. We aim to address the following re-
search questions in the evaluation.
RQ1:How effective and efficient is our approach in assisting
debugging real-world bugs?
RQ2:How does our tool compare to a recent interactive debug-
ging technique [24] that does not encode human intelligence?
RQ3:What is the impact of the threshold HIGH, which is the
only tunable parameter in our tool.
RQ4:What is the impact of the different kinds of statement
instance constraints?RQ5:Howcanourtoolimprovehumanproductivityinpractice?
To answer RQ1-RQ4, we apply our technique to a set of real-
world bugs, as shown in Table 3 (columns 1-4). Our benchmarks
consist of two kinds of bugs. The first kind (I) includes 25 bugs
from10popularPythonprojectsonGitHubandthesecondkind(II)
includes 10 algorithmic bugs postedon Stack Overflow. As shown
in column 3 of Table 3, some of the projects are among the largest
Python projects one can find on GitHub, with the largest having
over54KLOC.Thecollectedprojectbugs(I)alsodenotethetypical
complexity level. We use the failure inducing inputs in the bug
reports.Whencollectingthesebugs,weconsideredthediversityof
projects. They mainly fall into the following categories.
Fabricâ€“ remote deployment and administration application.
Requests andurllib3- very popular HTTP libraries.
Simplejson - a widely used JSON encoding/decoding library.
Bottle,flaskandweb2py-widelyusedwebapplicationsystem
development frameworks.
Werkzeug - a popular WSGI utility library for Python.
Dateutil - an extension to the datetime module of Python.
Scrapy- a well known web crawler.
Foralgorithmicbugs(II),theprogramsmainlyimplementvarious
algorithms from Project Euler [ 5] and LeetCode [ 6]. Their issue
numbers on stackoverflow.com are shown in column 4.
Table3showsthesummaryofourexperimentalresults.Columns
5-6presentthenumbersofeventsandslicedevents.Observethat
many slices are so large that manual inspection would be difficult.
Theevents forprojectbugsare smallerthanweexpected because
the failure inducing inputs in bug reports tend to be small as they
havegonethroughinputreduction(e.g.,usingdelta-debugging[ 8]).
This is very typical for Python bugs reported on GitHub. Columns
7-9 report the number of solved constraints by our tool. Columns 7
(Variable) and 8 ( StmtInst) represent the numbers of solved vari-
ableconstraintsandstatementinstanceconstraints,respectively.
Column 9 reports their total number.Effectiveness and Efficiency (RQ1).
To evaluate the effective-
ness of our tool, we set the threshold HIGH=0.95 and debug the
benchmarkprogramsfollowingtherecommendationssuggested
byourtool.Wecounttheinteractionswiththetool(i.e.,therecom-
mended instances that we have to inspect and provide feedback)
till the root causes are located. Column 13 ( PD) reports the number
ofinteractions,includingthefinalrootcausestep.Theresultsshow
that our approach is highly effective. We only need to inspect asmall number of steps (on average 3 steps for project bugs and5 for algorithmic bugs). For a few cases (e.g., fabric#166 and re-
quests#1462), our tool can directly report the root cause. Note that
thisdoesnotsuggestthealgorithmicbugsaremorecomplex.Infact,
they are mostly loop intensive and hence their failure propagation
paths often involve many iterative steps. As a result, our tool may
requiretheusertoprovidefeedbackformultipleinstancesofthe
same statement in different iterations.
Columns10-12presentthetracingtime,solvingtimeandtotal
time, respectively. The solving time is the sum of all the inspection
rounds. The results show that our approach is highly efficient.
Especially,ourtoolcancompleteinferencesinasecondformost
cases. Note that tracing time is a one time cost for each failure.Comparisonwith Microbat [24](RQ2).
Since[24]doesnotsup-
portPython,were-implementeditinPythonforthecomparison.
1178
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Debugging with Intelligence via Probabilistic Inference ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Table 3: Summary of the Experiment Results
Benchmarks Trace Solved Constraints Time (sec) Inspected Steps
Projects/Algs. SLOC Issue# Events Sliced Events Variable StmtInst All Tracing Solving Total PD FD
IFabric 3061882 6219 88 599 189 788 3.36 0.1 3.46 2 4
166 120 42 153 56 209 0.98 0.03 1.01 1 6
610 345 39 254 126 380 1.12 0.09 1.21 2 5
898 6199 80 271 126 397 3.34 0.06 3.4 1 10
Requests 105951462 4549 128 266 70 336 2.67 0.04 2.71 1 6
1711 4922 12 167 42 209 2.83 0.1 2.93 2 1
2613 8084 886 1009 406 1415 10.85 0.25 11.1 2 17
2638 7509 876 363 147 510 11.03 0.21 11.24 5 14
395 1912 49 509 182 691 1.26 0.23 1.49 2 6
1767 2047 652 7975 2303 10278 0.76 0.22 0.98 5 21
2638 7509 876 356 126 482 28.91 0.14 29.05 5 15
3017 895 32 220 56 276 0.76 0.12 0.88 3 2
simplejson 410481 434 164 633 189 822 0.16 0.17 0.33 3 5
85 683 174 1472 511 1983 0.25 0.34 0.59 5 10
Flask 2658 857 1684 23 36 21 57 0.81 0.03 0.84 1 2
bottle 2569595 1138 481 3048 2457 5505 0.65 0.83 1.48 3 20
633 708 321 1020 742 1762 0.64 0.21 0.85 2 21
werkzeug 11009 99 2605 50 269 147 416 1.43 0.12 1.55 4 12
dateutil 3647234 2093 152 240 70 310 0.95 0.12 1.07 4 8
229 1306 144 293 105 398 0.44 0.13 0.57 4 10
scrapy 11145861 4211 861 7452 2128 9580 8.61 1.58 10.19 8 12
24 3970 1008 8190 3136 11326 9.61 2.14 11.75 5 14
web2py 54479742 4030 34 102 56 158 17.77 0.08 17.85 3 7
1570 5531 94 145 77 222 21.89 0.04 21.93 2 8
urllib3 11659 143 997 126 1403 168 1571 4.63 0.06 4.69 4 9
Average 11493 - 3188 296 1440 533 1973 5.43 0.37 5.80 3 10
IIlcsubstr 19 41623560 400 236 255 77 332 0.08 0.07 0.15 2 5
happynum 17 30247583 112 68 198 105 303 0.04 0.16 0.2 5 7
quadratic 26 17681021 249968 2237 592 574 1166 43.14 0.19 43.33 4 20
primesum 17 17681021 8007 6883 1290 623 1913 1.75 0.4 2.15 3 40
triangular 21 9182462 7949 4540 2172 1687 3859 1.4 0.6 2 7 X
fibonaci 18 18794190 284 151 2521 2926 5447 0.07 0.88 0.95 11 X
lcollatzseq 15 20597369 56625 54192 2711 3080 5791 9.34 0.95 10.29 3 2
amicable 27 19318000 49780 4265 1241 245 1486 11.22 0.24 11.46 6 6
mergesort 30 18808105 1046 286 557 91 648 0.24 0.3 0.54 5 5
euclid 10 16567505 26 9 107 84 191 0.01 0.12 0.13 3 X
Average 20 - 37420 7287 1164 949 2114 6.73 0.39 7.12 5 -
WecallthePythonversionof MicrobatthePyMicrobat.Wecompare
theperformanceofthetwobycountingthenumberofinspected
stepsbefore locatingtherootcause. Tosuppress noise(i.e.,differ-
ences in human feedback), four of the authors debugged each case
using both tools independently. We then take the average of the
interaction numbers. To achieve fair comparison, our tool requests
thesamekindoffeedbackfromthedeveloperas Microbat,whichis
to determine whether operands in a statement instance are correct.
Column14( FD)inTable3presentstheresultsof PyMicrobat.The
resultsshowthatformostcases,thenumberofinteractionsneeded
by our tool is much smaller than that by PyMicrobat. Observe that
PyMicrobat failed to locate three algorithmic bugs. The reason is
thatPyMicrobat is strictly based on dynamic slicing, which may
miss root causes due to execution omission [ 31]. In contrast, our
tool can fuse additional debugging hints from multiple sources.
Inrequests#1711andlcollatzseq,ourtoolrequiresonemorestep.
Furtherinspectionshowsthatthetwobugshavesimplecausality
so that uncertainty reasoning is not needed.
Impact of Threshold HIGH(RQ3).We study the impact of the
threshold HIGHusing three settings, namely, 0.85, 0.90 and 0.95.
Fig. 6 presentsthe variation of theneeded steps. Observe thatthe
impact of HIGHis small in most cases.
ImpactofConstraints(RQ4). Weonlychoosebugsofkind(I)as
our subjects as kind (II) bugs mostly do not have function struc-
turesandtheirvariablenamesarealmostmeaningless.Weevalu-
ate the impact of each kind of statement instance constraints bythree additional settings, namely, only variable-to-statement in-
stance constraints, variable-to-statement instance constraints withprogram structure constraints, and variable-to-statement instance
constraintswithnamingconventionconstraints.Notethatvariable-
to-statement instance constraints are the basis in our model. Fig. 7
shows the variation of the needed steps. Observe that each kind
haspositivecontributionformostcases.Theimpactsofprogram
structure constraints and naming convention constraints on some
cases (e.g., fabric#610 and scrapy#861) are prominent.User Study (RQ5).
Weconducted a user study. We selected four
well-known algorithmic problems from our benchmark and asked
the participants to debug the buggy programs. Table 4 presents the
descriptions of the selected bugs. We invited 16 graduate students
fromtheauthorsâ€™institutetoparticipatethestudy.Toavoidbias
caused by programming experience variation, for each program,
werandomlypartitionthestudentstotwogroups,oneusingour
tool and the other using the standard Python debugger pdb[3].
Table5presentsthe(human)debuggingtimecomparison.The
shaded columns present the time of using our tool. Observe that
ourtool achieves34.03% speedupon average.To validatetheper-
formancedifferenceofthetwogroups,weintroducethenulland
alternative hypotheses as follows.
H0:There is no significant performance difference between the
two groups.
H1:The performancedifference between thetwo is significant.
We use the Wilcoxon signed rank test to evaluate the null hy-
pothesesandifthep-valueislessthan0.05,wewillrejectit.Thelast
row in Table 5 reports the p-value of each task. Observe that all of
themarelessthan0.05,whichmeanstheperformanceimprovement
is significant.
1179
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden Z. Xu, S. Ma, X. Zhang, S. Zhu and B. Xu
Figure 6: Impact of the Threshold HIGH.
Figure 7: Impact of Each Kind of Constraints.
7 RELATED WORK
Automated debugging and fault localization techniques have been
extensively studied. Delta debugging [ 8â€“14] leverages a passing
execution closely resembling the failing execution as the reference,
andusesasophisticatedsearchalgorithmtoidentifytheminimal
state differences that trigger the failure. Despite its success, it may
be difficult to find a reference execution of high quality in practice.
Spectrum based fault localization [ 15â€“21] compares program spec-
tra(e.g.,codecoverage)betweenthefailingandpassingexecutions
to identify the most likely root cause. It is highly effective when
many runs are available. Statistical fault localization [ 22,23] iso-
lates bugs by contrasting the instrumented predicates at particular
points.Therearealsovariousproposalsonimprovingfaultlocal-
izationandapplyingfaultlocalizationindifferentareas[ 33â€“44,49].
Our approach is different. First, we assume that only a failing run
is available for debugging. Second, these techniques are mostly
deterministic and do not handle uncertainty like we do. We shift a
lot of decision makings from humans to machines.
Debugging techniques using a single run [ 24â€“29,32] have been
proposedaswell.Forexample,Linetat.[ 24]developedafeedback-
based technique that prunes the search space. But the technique
doesnotreasonaboutuncertaintyandhencecannotmakeuseof
uncertainhints,whichareveryusefulaccordingtoourexperiment.
Zhang et al. [ 29] prune dynamic slice with confidence. However,
theirmethodofcomputingconfidenceisad-hocandtheydonot
support probabilistic inference. Many other techniques leverage
execution trace for debugging [ 26â€“28]. However, most of them do
not support human-like reasoning.
There are also techniques leveraging machine learning to locate
bugs [45â€“47]. Dietz et al. [ 45] trains a graphical model called the
Bernoulli graph model using passing traces to determine the most
likely faulty code position. Baah et al. [ 46] proposed probabilis-
tic dependence graph which estimates variable states and learnsTable 4: Debugging Tasks for User Study.
Algorithm Description Bug Causality
lcsubstr Identifythelongestincreasingsub-
string of a given string.Indexes incorrectly computed.
quadratic Find the maximum number of
primes satisfying a quadratic for-
mula (Euler problem 27).Some intermediate results are
not updated in iterations.
fibonaci Find thesum ofthe eventerms of
thefibonaciseriesuptoacertain
number.Loop condition is incorrect.
mergesort Implement the merge sort for a
given number sequence.The comparison operator is
wrong.
Table 5: Results of the User Study (Min).
Person\Task lcsubstr quadratic fibonaci mergesort
N1/Y1 11.566.3733.116.3215.0314.5510.5412.5
N2/Y2 30.068.210.1411.22 2716.1118.1312.23
N3/Y3 10.35.2921.510.5813.3111.8115.0414.32
N4/Y4 5.85.519.3117.7617.2418.3318.3313.9
N5/Y5 2.856.9610.4514.412.4514.7820.7815.61
N6/Y6 21.114.8912.810.3325.6915.620.513.8
N7/Y7 23.117.3627.45 1434.4613.2830.511.44
N8/Y8 12.718.1120.4515.418.5118.4414.3314.49
Avgerage14.696.5919.4013.7520.4615.3618.5213.54
55.17% 29.12% 24.92% 26.91%
Overall 34.03%
P-Value 0.006 0.037 0.049 0.014
conditional dependencies from both passing and failing runs to
facilitate fault localization.Deng et al. [ 47] encodes thefrequency
ofexecutioninahybridgraphicalmodelnamedweightedsystem
dependency graph to prioritize heavily trafficked flows to facilitate
faultlocalization.Ourtechniqueisdifferent.First,theyrequirea
numberoffailing/passingrunstobuildthemodelwhileourtech-
niqueonlyneedsasinglefailingrun.Second,thesetechniques learn
probabilities from multiple executions whereas our technique infer
posterior probabilities from prior distributions. Third, their model
is static, denoting a program, whereas our model is dynamic, de-
noting an execution. Fourth, our technique can leverage uncertain
hints such as those from structure and names.
8 CONCLUSION
We propose a probabilistic inference based debugging technique.
We model the debugging problem as two phases of probabilistic
inference: (1) inferring variable correctness/faultiness probabilities
and(2)inferringstatementinstancecorrectness/faultinessproba-
bilities. Our technique allows us to debug by leveraging various
hints from execution trace, program structure, variable names and
human feedback. The results show that our technique can identify
rootcausesofasetofreal-worldbugsinafewsteps,muchfaster
than a recent proposal that does not encode human intelligence. It
also substantially improves human productivity.
ACKNOWLEDGMENTS
This research was supported by DARPA under contract FA8650-
15-C-7562, NSF under awards 1748764, 1409668 and 1320444, ONR
under contracts N000141410468 and N000141712947, Sandia Na-
tional Lab under award 1701331, National Basic Research Program
ofChinaNo.2014CB340702,NationalNaturalScienceFoundation
ofChinaNo.61472175,61472178and61772263,andNaturalScience
Foundation of Jiangsu Province of China BK20140611. Any opin-
ions,findings,andconclusionsinthispaperarethoseoftheauthors
only and do not necessarily reflect the views of our sponsors.
1180
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. Debugging with Intelligence via Probabilistic Inference ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1] libdai. https://staff.fnwi.uva.nl/j.m.mooij/libDAI/
[2] requests. http://docs.python-requests.org/en/master/[3] pdb. https://docs.python.org/2/library/pdb.html[4] Pycharm. https://www.jetbrains.com/pycharm/[5] Project Euler. https://projecteuler.net/[6] Leetcode. https://leetcode.com/[7]
IEEE Spectrum http://spectrum.ieee.org/computing/software/
the-2017-top-programming-languages
[8]A. Zeller. Yesterday, my program worked. today, it does not. why? In Proceedings
of the 7th European Software Engineering Conference Held Jointly with the 7th
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(ESEC/FSE), pages 253â€“267, 1999.
[9]A.Zeller.Isolatingcause-effectchainsfromcomputerprogramsIn Proceedingsof
the 10th ACM SIGSOFT Symposium on the Foundations of Software Engineering
(FSE), pages 1-10, 2002.
[10]A. Zeller and R. Hildebrandt. Simplifying and isolating failure-inducing input. In
IEEE Transaction on Software Engineering (TSE), 28(2):183â€“200, 2002.
[11]H. Cleve and A. Zeller. Locating causes of program failures. In Proceedings of
the 27th International Conference on Software Engineering (ICSE), pages 342â€“351,
2005.
[12]G. Misherghi and Z. Su. Hdd: Hierarchical delta debugging. In Proceedings of
the 28th International Conference on Software Engineering (ICSE), pages 142â€“151,
2006.
[13]D. Qi, A. Roychoudhury, Z. Liang, and K. Vaswani. Darwin: An approach for
debuggingevolvingprograms.In Proceedingsofthethe7thJointMeetingofthe
European Software Engineering Conference and the ACM SIGSOFT Symposium on
The Foundations of Software Engineering (ESEC/FSE), pages 33â€“42, 2009.
[14]W.N.Sumner,Y.Zheng,D.WeeratungeandX.Zhang.Precisecallingcontexten-coding.In Proceedingsofthe32ndACM/IEEEInternationalConferenceonSoftware
Engineering (ICSE), pages 525-534, 2010.
[15]R. Abreu, P. Zoeteweij, and A. J. C. v. Gemund. Spectrum-based multiple fault
localization. In Proceedings of the 2009 IEEE/ACM International Conference on
Automated Software Engineering (ASE), pages 88â€“99, 2009.
[16]M.RenierisandS.P.Reiss.Faultlocalizationwithnearestneighborqueries.In
Proceedings of International Conference on Automated Software Engineering (ASE),
pages 30â€“39, 2003.
[17]T.Reps,T.Ball,M.Das,andJ.Larus.Theuseofprogramprofilingforsoftware
maintenancewith applicationsto theyear 2000problem.In Proceedingsof the
6th European SOFTWARE ENGINEERING Conference Held Jointly with the 5th
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(ESEC/FSE), pages 432â€“449, 1997.
[18]X. Wang, S. C. Cheung, W. K. Chan, and Z. Zhang. Taming coincidental correct-
ness:Coveragerefinementwithcontextpatternstoimprovefaultlocalization.In
Proceedingsofthe31stInternationalConferenceonSoftwareEngineering(ICSE) ,
pages 45â€“55, 2009.
[19]L.Gong,D.Lo,L.Jiang,andH.Zhang.Interactivefaultlocalizationleveraging
simple user feedback. In IEEE International Conferenceon Software Maintenance
(ICSM), pages 67â€“76, 2012.
[20]R.Abreu,P.Zoeteweij,R.Golsteijn,andA.J.vanGemund.Apracticalevaluation
of spectrum-based fault localization. In Journal of Systems and Software (JSS),
82(11):1780 â€“ 1792, 2009.
[21]D.Gopinath,R.N.ZaeemandS.Khurshid.Improvingtheeffectivenessofspectra-
based fault localization using specifications. In Proceedings of the 27th IEEE/ACM
InternationalConferenceonAutomatedSoftwareEngineering(ASE).pages40-49,
2012.
[22]B.Liblit,M.Naik,A.X.Zheng,A.Aiken,andM.I.Jordan.ScalableStatisticalBug
Isolation.In Proceedingsofthe2005ACMSIGPLANConferenceonProgramming
Language Design and Implementation (PLDI), pages 15-26, 2005.
[23]C.Liu,L.Fei,X.Yan,J.Han,andS.P.Midkiff.StatisticalDebugging:AHypothesis
Testing-basedApproach.In IEEETransactionsonSoftwareEngineering,32(10):831-
848, 2006.
[24]Y.Lin,J.Sun,Y.Xue,Y.LiuandJ.Dong.Feedback-BasedDebugging.In Proceedings
ofthe39thInternationalConferenceonSoftwareEngineering(ICSE),(toappear),
2017.
[25]A.J.KoandB.A.Myers.Designingthewhyline:Adebugginginterfaceforasking
questionsaboutprogrambehavior.In ProceedingsoftheSIGCHIConferenceon
Human Factors in Computing Systems, pages 151â€“158, 2004.
[26]A. J. Ko and B. A.Myers. Debugging reinvented: Asking and answering whyand
whynotquestionsaboutprogrambehavior.In Proceedingsofthe30thInternational
Conference on Software Engineering (ICSE), pages 301â€“310, 2008.
[27]G.Pothierand.Tanter.Backtothefuture:Omniscientdebugging. IEEESoftware ,
26(6):78â€“85, 2009.[28]J.Ressia,A.Bergel,andO.Nierstrasz.Object-centricdebugging.In Proceedingsof
the 34th International Conference on Software Engineering (ICSE), pages 485â€“495,
2012.
[29]X.Zhang,N.GuptaandR.Gupta.In Proceedingsofthe27thACMSIGPLANConfer-
enceonProgrammingLanguageDesignandImplementation(PLDI),pages169-180,
2006.
[30]J. S. Yedidia, W. T. Freeman, and Y. Weiss. Understanding belief propagation and
its generalizations, Exploring articial intelligence in the new millennium 8, 2003.
[31]X.Zhang,S.Tallam,N.GuptaandR.CuptaTowardslocatingexecutionomission
errors. In Proceedings of the 28th ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), pages 415-424, 2007.
[32]Tao Wang and Abhik Roychoudhury Hierarchical dynamic slicing In Proceedings
ofthe2007internationalsymposiumonSoftwaretestingandanalysis(ISSTA),pages
228-238, 2007
[33]B.Baudry,F.FleureyandY.L.Traon.Improvingtestsuitesforefficientfaultlocal-
ization In Proceedings of the 28th international conference on Software engineering
(ICSE), pages 82-91, 2006
[34]B.Liu,Lucia,S.Nejati,L.C.BriandandT.Bruckmann.Simulinkfaultlocalization:
an iterative statistical debugging approach. Software Testing, Verification and
Reliability, 26(6): 431-459, 2016.
[35]D. Hao, T. Xie, L. Zhang, X. Wang, J. Sun and H. Mei. Test input reduction for
resultinspectiontofacilitatefaultlocalization. Automatedsoftwareengineering,
17(1): 5-31, 2010.
[36]X. Li, M. Amorim and A. Orso. Iterative User-Driven Fault Localization. In Haifa
Verification Conference, pages 82-98, 2016.
[37]W. Jin and A. Orso. F3: Fault localization for Field Failures. In Proceedings of the
2013 International Symposium on Software Testing and Analysis (ISSTA), pages
213-223, 2013.
[38]L. Zhang, L. Zhang and S. Khurshid. Injecting mechanical faults to localize
developer faults for evolving software. In Proceedings of the 2013 ACM SIGPLAN
international conference on Object oriented programming systems languages &
applications (OOPSLA), pages 765-784, 2013.
[39]F. S. Ocariza, G. Li, K. Pattabiraman and A. Mesbah. Automatic fault localization
forclient-sideJavaScript.In SoftwareTesting,VerificationandReliability,26(1):
69-88, 2016.
[40]S. Wang, D. Lo, L. Jiang, Lucia and H. C. Lau: Search-based fault localization. In
Proceedings of the 2011 26th IEEE/ACM International Conference on Automated
Software Engineering (ASE), pages 556-559, 2011.
[41]G.Birch,B.FischerandM.Poppleton.UsingFastModel-BasedFaultLocalisation
toAidStudentsinSelf-GuidedProgramRepairandtoImproveAssessment.In
Proceedingsofthe2016ACMConferenceonInnovationandTechnologyinComputer
Science Education (ITiCSE), pages 168-173, 2016.
[42]X. Xia, L. Gong, T. B. Le, D. Lo, L. Jiang and H. Zhang. Diversity maximiza-
tion speedup for localizing faults in single-fault and multi-fault programs. In
Automated Software Engineering (ASE), 23(1): 43-75, 2016.
[43]C.Zhang,D.Yan,J.Zhao,Y.ChenandS.Yang.BPGen:AnAutomatedBreakpoint
Generator for Debugging. In Proceedings of the 32nd ACM/IEEE International
Conference on Software Engineering (ICSE), pages 271-274, 2010.
[44]J. Al-Kofahi, H. V. Nguyen and T. N. Nguyen. Fault Localization for Make-Based
Build Crashes. In roceedings of the 30th International Conference on Software
Maintenance and Evolution (ICSME), pages 526-530, 2014
[45]L.Dietz,V.Dallmeier,A.Zeller,andT.Scheer.Localizingbugsinprogramexe-
cutionswithgraphicalmodels.In NeuralInformationProcessingSystems(NIPS),
2009.
[46]G.K.Baah,, A.Podgurski andM. J.,Harrold. Theprobabilistic programdepen-
dence graph and its application to fault diagnosis. IEEE Transactions on Software
Engineering (TSE, 36(4): 528-545, 2010.
[47]F. Deng and J.A. Jones. Weighted system dependence graph. In Proceedings of
the Fifth International Conference on Software Testing, Verification and Validation
(ICST), pages 380â€“389, 2012.
[48]S. Zhang and C. Zhang. Software bug localization with markov logic. In Proceed-
ings of the 36th International Conference on Software Engineering (ICSE14), pages
424â€“427, 2014.
[49]T. B. Le, D. Lo, C. L. Goues and L. Grunske. A learning-to-rank based fault local-
ization approachusing likelyinvariants. In Proceedings ofthe 25thInternational
Symposium on Software Testing and Analysis (ISSTA), pages 177-188, 2016.
[50]N.E.BeckmanandA.V.Nori.Probabilistic,modularandscalableinferenceof
typestate specifications. In Proceedings of the 32nd ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), pages:211-221, 2011.
[51]Z.Xu,X.Zhang,L.Chen,K.PeiandB.XuPythonProbabilistictypeinference
with natural language support. In Proceedings of the 2016 24th ACM SIGSOFT
InternationalSymposiumonFoundationsofSoftwareEngineering(FSE),pages:607-
618, 2016.
1181
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:59 UTC from IEEE Xplore.  Restrictions apply. 