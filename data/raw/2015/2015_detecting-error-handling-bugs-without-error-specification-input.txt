Detecting Error-Handling Bugs without
Error SpeciÔ¨Åcation Input
Zhouyang Jia‚àó‚Ä†, Shanshan Li‚àó, Tingting Yu‚Ä†, Xiangke Liao‚àó,J iW a n g‚àó, Xiaodong Liu‚àó, and Yunhuai Liu‚Ä°
‚àóCollege of Computer Science
National University of Defense Technology
Changsha, China
{jiazhouyang, shanshanli, xkliao, wj,
liuxiaodong }@nudt.edu.cn‚Ä†Department of Computer Science
University of Kentucky
Lexington, USA
tyu@cs.uky.edu‚Ä°Big Data Research Center
Peking University
Beijing, China
yunhuai.liu@pku.edu.cn
Abstract ‚ÄîMost software systems frequently encounter errors
when interacting with their environments. When errors occur,
error-handling code must execute Ô¨Çawlessly to facilitate system
recovery. Implementing correct error handling is repetitive but
non-trivial, and developers often inadvertently introduce bugs
into error-handling code. Existing tools require correct error
speciÔ¨Åcations to detect error-handling bugs. Manually generating
error speciÔ¨Åcations is error-prone and tedious, while automati-
cally mining error speciÔ¨Åcations is hard to achieve a satisfying
accuracy. In this paper, we propose EH-Miner ,an o v e la n d
practical tool that can automatically detect error-handling bugs
without the need for error speciÔ¨Åcations. Given a function,
EH-Miner mines its error-handling rules when the function is
frequently checked by an equivalent condition, and handled by
the same action. We applied EH-Miner to 117 applications across
15 software domains. EH-Miner mined error-handling rules with
the precision of 91.1% and the recall of 46.9%. We reported 142
bugs to developers, and 106 bugs had been conÔ¨Årmed and Ô¨Åxed
at the time of writing. We further applied EH-Miner to Linux
kernel, and reported 68 bugs for kernel-4.17, of which 42 had
been conÔ¨Årmed or Ô¨Åxed.
Index T erms ‚ÄîError handling, Library function, SpeciÔ¨Åcation
I. I NTRODUCTION
Most software applications interact with their environments
through libraries. These libraries provide various Application
Programming Interface (API) functions for applications. A
reliable application must be designed to behave gracefully
even under API function failure conditions such as network
packet loss, malformed input, memory allocation failure etc.
When any error occurs, the failing API function usually
notiÔ¨Åes its caller about the error, after which the caller decides
how the error should be handled. Incorrect handling of errors
can lead to serious problems, e.g., system crashes or data loss,
and software developers often make mistakes and inadvertently
introduce bugs into error-handling code [1], [2]. Incorrect error
handling had been identiÔ¨Åed as one of the top ten sources of
security issues [3].
This work was supported in part by National Key R&D Program of China
No. 2017YFB1001802; NSFC No. 61872373 and 61872375; NSF grant CCF-
1652149 and CCF-1909085; High-End Generic Chips and Basic Software
under grants No. 2017ZX01038104-002; China Scholarship Council.Many researchers have proposed tools to detect error-
handling bugs. Some of them use static analysis to check
whether failures are properly handled in error paths [2], [4]‚Äì
[7]. The process of these tools can be roughly split into
two steps. The Ô¨Årst step is to manually input or mine error
speciÔ¨Åcations that indicate whether or not an API function
may fail, and if so, how the function communicates with its
caller. Second, they check whether or not the error is properly
handled in the caller; if not, they report a bug. On the other
hand, some tools use dynamic fault injection to check whether
the program handles API failures correctly [8]‚Äì[11]. These
works also require the error speciÔ¨Åcations as input initially.
They simulate API failures according to the error speciÔ¨Åcations
and check the response of the program.
The bug-detection abilities of both static and dynamic tools
depend heavily on the accuracy of error speciÔ¨Åcations. Manu-
ally generating error speciÔ¨Åcations is error-prone and tedious,
especially for low-level languages such as C/C++. C does not
provide exception-handling mechanisms, while C++ contains
far fewer try blocks than projects developed in the other
languages [12]. To remedy this situation, previous works tried
to automate the process of error speciÔ¨Åcation mining [13]‚Äì
[15]. Among these, Kang et al . [13] studied the characteristics
of error paths and proposed APEx, which collects error paths
and infers error speciÔ¨Åcations with precision of 77% and recall
of 47%. This precision is not accurate enough, since inferring
error speciÔ¨Åcations is only the Ô¨Årst step to detect error-
handling bugs. Incorrect error speciÔ¨Åcations will negatively
affect the following analysis. Acharya et al . [14] designed
a tool that mines error speciÔ¨Åcations automatically. This tool
achieves 90% precision, but the recall is very limited ‚Äî it
only mined error speciÔ¨Åcations of 28 library functions from
both POSIX and X11 libraries.
In light of the above, we propose EH-Miner ,an o v e l
and practical tool to automatically detect error-handling bugs
without the need for error speciÔ¨Åcation input. Given an API
function, EH-Miner mines its error-handling rules when the
function is frequently checked by an equivalent condition,
and handled by the same action. To achieve this, we propose
a Potential Error Handling (PEH) model, which describes
2132019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ¬©2019 IEEE
DOI 10.1109/ASE.2019.00029
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. the potential error-handling behaviors in programs. In the
PEH model, an error-handling behavior contains three basic
elements: a library-function call, a check condition and a
handling-function call. EH-Miner extracts PEH instances from
a code repository, then normalizes these instances for ease
of comparison. Finally, EH-Miner mines error-handling rules
from the normalized instances.
Taking chroot as an example, developers frequently check
whether or not the return value of chroot is -1; if it is, an error
message is printed. The existing tools need the knowledge that
‚Äúchroot returns 0 on success and -1 on error‚Äù, then check
whether the error is well handled in the error path, i.e., the
path after the branch condition that the return value is -1.
By contrast, EH-Miner can mine the error-handling rule that
‚Äúchroot should be logged when returning -1‚Äù without inferring
the semantics of -1. In EH-Miner , the rule is recorded as
a PEH instance: <chroot (...),chroot (...)== -1, log(...)>.
There are three advantages for mining error-handling rules
compared with mining error speciÔ¨Åcations in existing tools:
‚Ä¢Higher accuracy. EH-Miner does not have to infer the
semantics of API return values. This feature enables EH-
Miner to improve 17% precision based on the state-of-
the-art tool.
‚Ä¢Better scalability. EH-Miner uses light-weighted con-
straint solving instead of heavy analysis such as symbolic
execution. The experiment shows that EH-Miner is about
20 times faster than the state-of-the-art tool.
‚Ä¢Easier to repair. EH-Miner can obtain error-handling
actions besides error speciÔ¨Åcations, which helps to repair
the detected bugs. With the assistance of this knowledge,
we manually generate and report 210 patches.
To evaluate EH-Miner , we select 15 software domains that
are widely used in the open source community, and choose
117 C/C++ applications from these domains. We Ô¨Årst use
the cross-validation technique to tune the parameters in EH-
Miner , then evaluate the precision and recall under the optimal
thresholds. Second, we evaluate the effectiveness of EH-Miner
for detecting real-world bugs. EH-Miner reports 2266 bugs,
and the precision is 88.16% at the 95% conÔ¨Ådence level. We
report 142 bugs, and 106 of them are conÔ¨Årmed by developers.
We further apply EH-Miner to Linux kernel, and report 68
kernel bugs, of which 42 are conÔ¨Årmed. Finally, we compare
EH-Miner with the state-of-the-art tools, and Ô¨Ånd EH-Miner
outperforms the existing tools in terms of precision, recall and
efÔ¨Åciency.
In summary, the contributions of this paper are as follows:
‚Ä¢We design and implement EH-Miner , a tool that can
automatically detect error-handling bugs without error
speciÔ¨Åcation input. We conduct an empirical study on
check conditions and error-handling actions, which guide
the design of EH-Miner .
‚Ä¢InEH-Miner , we propose several novel techniques in-
cluding using the PEH model to describe error-handling
behaviors, converting the judgment of check-condition
equivalence into a satisÔ¨Åability problem, automatically/* Example 1: mysql-5.7.16/sql/mysqld.cc:1586:7 */  
if (chroot(path) == - 1) { 
 sql_print_error( "chroot: %s" , strerror(errno)); 
 unireg_abort(MYSQLD_ABORT_EXIT); 
}
/* Example 2: opensmtpd-6.0.2p1/smtpd/ca.c:101:6 */  
if (chroot(PATH_CHROOT) == - 1) 
 fatal( "ca: chroot" );
/* Example 3: httpd-2.4.25/modules/arch/unix/mod_unixd.c:162:13 */  
if (chroot(ap_unixd_config.chroot_dir) != 0) { 
 rv = errno; 
 ap_log_error(... "Can't chroot to %s" , ...); 
 return rv; 
}
/* Example 4: postfix-3.2.2/src/util/chroot_uid.c:68:6 */  
if (chroot(root_dir)) 
 msg_fatal( "chroot(%s): %m" , root_dir); 
/* Example 5: cherokee-1.2.103/cherokee/source_interpreter.c:633:9 */  
re = chroot(src->chroot.buf); 
if (re < 0) { 
 LOG_ERROR (..., src->chroot.buf); 
 exit( 1); 
} 
Fig. 1. Error handling examples of chroot .
recognizing error-handling actions, and a two-step mining
method to mine error-handling rules.
‚Ä¢We apply EH-Miner to 117 applications across 15 soft-
ware domains. EH-Miner mines error-handling rules with
precision of 91.1% and recall of 46.9%. We reported 142
bugs, and 106 of them were conÔ¨Årmed by developers. We
further applied EH-Miner to Linux kernel, and reported
68 kernel bugs, of which 42 were conÔ¨Årmed.
II. M OTIV ATION AND DEFINITION
In this section, we present a real-world example that moti-
vated us to design and implement EH-Miner . Figure 1 shows
Ô¨Åve different applications invoking the API function chroot .
According to the man page documentation for chroot ,w e
know that upon successful completion, a value of 0 is returned;
otherwise, a value of -1 is returned. Guided by the man
document, all these Ô¨Åve applications handle errors in a similar
way ‚Äî checking whether the return value is -1, and if so,
printing error messages.
To Ô¨Ånd error-handling bugs of chroot , the existing solutions
Ô¨Årst need to either input (e.g., ErrDoc [4], EPEx [5]) or
mine (e.g., APEx [13], LFI [11]) the error speciÔ¨Åcation that
‚Äú0 means success and -1 means error‚Äù. Only after this is
accomplished can they check whether the error is properly
handled when -1 is returned. However, manually inputting
error speciÔ¨Åcations is tedious, and sometimes even error-prone
for libraries with limited domain knowledge. On the other
hand, mining error speciÔ¨Åcations automatically is hard to get
a satisfying accuracy even in the state-of-the-art tool.
In this paper, we propose a novel approach that does not
require error speciÔ¨Åcations as input. Given an API function,
if developers frequently use an equivalent check condition
and the same error-handling action, we consider this to be
an error-handling rule for this API function. This insight is
naturally useful for mining error-handling rules, as developers
usually perform similar actions in error paths ( e.g., printing
error messages or exiting the program), whereas in normal
214
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. paths, developers perform different actions according to the
program-speciÔ¨Åc functionalities. As illustrated in Figure 1,
all the check conditions are equivalent (checking whether the
return value is -1) and followed by the same action (printing
an error message). Thus, we obtain the rule that chroot should
be logged when returning -1.
Challenges. There are two main challenges for mining
error-handling rules. First, to determine the check conditions
that appear frequently ( e.g., whether the return value is -1),
we need to judge the equivalence of check conditions. This
is a difÔ¨Åcult task, as two check conditions can be written in
various forms but still have the same meaning. For example,
‚Äúif(chroot() == -1)‚Äù and ‚Äúif(chroot() != 0)‚Äù are equivalent
‚Äî both check whether the return value of chroot is -1,
since chroot can only return -1 or 0 ‚Äî but semantically
different. Second, we need to recognize error-handling actions
(e.g., printing an error message) after the check conditions.
Achieving this is non-trivial since the implementations of an
error-handling action may take various forms across different
applications. Taking the print action as an example, when
printing an error message, most applications implement cus-
tom logging functions instead of using the library function
printf directly. For example, all applications in Figure 1 use
custom logging functions.
To overcome these challenges, we study the source code of
real-world projects and summarize the characteristics of equiv-
alence between check conditions, as well as the characteristics
of error-handling actions. Guided by these characteristics, we
employ two normalization methods to judge the equivalence
of check conditions and recognize error-handling actions.
DeÔ¨Ånition. To clearly describe error-handling behaviors like
the examples in Figure 1, we summarize the following three
elements, and combine these elements into the Potential Error
Handling model.
‚Ä¢Library-function Call ( LC): A call statement that invokes
a library function.
‚Ä¢Check Condition ( CC): A Boolean expression that is the
condition of a branch statement ( e.g.,iforswitch ), and
the branch statement is Ô¨Çow-dependent [16] on an LC.
‚Ä¢Handling-function Call ( HC): A call statement that is
control-dependent [16] on a branch statement, and the
branch statement is Ô¨Çow-dependent on an LC.
‚Ä¢Potential Error Handling model ( PEH ): A 3-tuple
M=<LC ,CC,HC> .
III. C HARACTERISTICS STUDY
As outlined in Section II, there are two main challenges
in obtaining error-handling rules. One is the judgment of
equivalence between check conditions; the other is the recog-
nition of error-handling actions. We studied the real-world
applications and summarized some characteristics that help
to overcome these challenges. We select Ô¨Åve mature open-
source applications from different software domains in order to
provide sufÔ¨Åcient generality for our investigations. All target
applications are active and widely used, written in C/C++,
and have long development history. The applications include19%36%28%22%26%26%10%
52%47%44%64%55%52%55%
22%9%16%9%16%14%28%
7%8%12%5%3%7%7%
0% 20% 40% 60% 80% 100%MySQLGitEmacsXBMCWiresharkTotalCross-appl.Syntax Semantics Pragmatics Not equivalent
Fig. 2. Distribution of different equivalence levels.
MySQL-5.7.16 (database), Git-2.9.3 (version control), Emacs-
25.2 (text editor), XBMC-17.3 (video player) and Wireshark-
2.2.7 (packet analyzer).
A. Characteristics of equivalence between check conditions
Developers can use various forms to implement check
conditions that perform exactly the same behavior. It is non-
trivial to determine whether two check conditions are equiv-
alent. To study the equivalence between check conditions,
we manually selected 100 pairs of check conditions in each
of the Ô¨Åve applications ( i.e., 500 pairs in total). For each
pair, we Ô¨Årst randomly selected a library function used in
the studied application, then randomly selected two call-sites
of this function. To study the equivalence across different
applications, we further selected 100 pairs of cross-application
check conditions ( i.e., the two call-sites are from different
applications).
To judge the equivalence between check conditions, the
most intuitive method is to compare conditions as strings.
This method requires the conditions to be equivalent at the
syntactic level. Most equivalent conditions, however, do not
meet this requirement. A practical tool should be capable
of judging the equivalence at the semantic level. Moreover,
the conditions with different semantics might still have the
same behavior in certain contexts. We regard this level of
equivalence as pragmatic level. Therefore, we classify the
condition equivalence into three levels and investigate their
distributions:
Syntactic Level . Two check conditions are exactly the same
except for some blanks and comments, e.g., ‚Äúfoo()==-1‚Äù and
‚Äúfoo() == -1‚Äù are equivalent in syntax.
Semantic Level . Given the same input, two check condi-
tions will choose the same branch, e.g., both ‚Äúfoo()!=0‚Äù and
‚Äúfoo()‚Äù will choose true branch when foo returns non-zero.
Pragmatic Level . Two check conditions have different
semantics, e.g., ‚Äúfoo()==-1‚Äù and ‚Äúfoo()!=0‚Äù. But they are still
equivalent under the speciÔ¨Åc context, e.g., the return value of
foo is limited to {-1, 0}.
For example, in Figure 1, the check conditions of chroot
in Example 1 and 2 are equivalent at the syntactic level.
Example 3 and 4 are equivalent at the semantic level, while
Example 2 and 3 are equivalent at the pragmatic level. We
studied the distribution of these equivalence levels. The results
are illustrated in Figure 2. Taking MySQL as an example,
19%, 52% and 22% of check conditions are equivalent at
the syntactic, semantic, and pragmatic levels respectively,
215
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. 37%26%19%49%52%37%
27%34%44%22%22%30%
6%24%13%0%2%9%
5%3%5%9%8%6%
13%6%6%0%7%6%
3%2%6%15%4%6%
7%3%2%3%3%4%
0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%MySQLGitEmacsXBMCWireshark Totalreturn log exit goto close break free continue delete
Fig. 3. Distribution of different error-handling actions.
while 7% of them are not equivalent. The average distribution
across the Ô¨Åve applications is 26.2%, 52.4%, 14.4% and 7%.
Moreover, in cross-application samples, the percentage of
pragmatic equivalence increases from 14.4% to 28%.
The percentages of semantic and pragmatic equivalence are
55% and 28% in cross-application samples. It is important to
judge the equivalence beyond the syntactic level.
B. Characteristics of error-handling actions
As developers usually use custom functions to handle errors,
it is difÔ¨Åcult to directly compare error-handling actions across
different applications. All projects shown in Figure 1 use
custom logging functions, e.g.,sqlprint error in MySQL
andaplogerror in Httpd. To study the existing actions,
we randomly selected 100 error-handling code snippets in
each of the Ô¨Åve applications ( i.e., 500 in total) and found
nine kinds of error-handling actions via manual analysis.
According to how the actions are implemented, these actions
can be classiÔ¨Åed into two categories: unconditional branch
statements and custom error-handling functions. The former
is implemented by keywords in C/C++ language, while the
latter is implemented by custom functions.
Unconditional branch statements. Four kinds of actions
are implemented by unconditional branch statements: return ,
break ,continue andgoto. Among these, the return action
is most frequently used in the error-handling code snippets.
As outlined in Figure 3, on average, 37% of error-handling
code snippets use return statements. The goto action is another
important error-handling mechanism in C/C++ applications,
which is used in 6% of snippets on average. In addition,
thebreak (6%) and continue (1%) actions are used to
handle errors in loops such as for statements and while
statements. In general, these kinds of error-handling actions
can be recognized by simply searching the keywords.
Custom error-handling functions. Five kinds of actions
are implemented by custom error-handling functions: log,
exit,close ,delete andfree . Among these, the logaction
prints error messages to any target, including console, Ô¨Åle
or socket. The exit action exits the application immediately
by wrapping the functions such as exit orabort . Figure 3
shows 30% and 9% of error-handling code snippets on average
perform logandexit actions, respectively. In addition, the
close anddelete actions refer to closing or deleting a Ô¨Åle or
directory. These two actions are found in 6% and 1% of total
snippets respectively. The Ô¨Ånal action, free , is used to free
memory and appears in 4% error-handling code snippets.PEH 
instancesNormalized PEH 
instances
Error handling rulesStep 2: Judge 
check-condition 
equivalence Step 4: 
Mine 
frequent 
instancesStep 3: 
Recognize error 
handling actionsStep 1: 
Extract 
PEH 
instances
Bug reports Code repository EH-Miner Tool
Fig. 4. Overview of EH-Miner .
There are nine common used error-handling actions, which can
be classiÔ¨Åed as unconditional branch statements ( return ,goto ,
break ,continue ) and custom error-handling functions ( log,
exit,close ,delete ,free ).
IV . EH-Miner DESIGN
In this section, we present the detailed design of EH-Miner .
As shown in Figure 4, EH-Miner takes source code as input
and generates error-handling rules for library functions. It then
detects violations of these rules and identiÔ¨Åes them as error-
handling bugs. In EH-Miner , the Ô¨Årst step is to extract PEH
instances, which transfer the source code into structured data.
EH-Miner then judges the equivalence of check conditions
across PEH instances, and recognizes error-handling actions of
each instance. For ease of comparison, EH-Miner normalizes
these instances according to the equivalence of check condi-
tions and the type of error-handling actions. Finally, EH-Miner
mines error-handling rules from the normalized PEH instances.
A. Extracting PEH Instances
EH-Miner extracts PEH instances according to the algo-
rithm described in Algorithm 1. For each function deÔ¨Ånition,
EH-Miner scans its source code and collects all call statements
(line 2). For each call statement, EH-Miner checks whether
or not it is calling a library function(line 4), and if so,
regards the call statement as an lc(library-function call)
(line 5). From the lc, EH-Miner searches forwards to collect
all branch statements (line 7), and chooses the ones that
are Ô¨Çow-dependent on lc. Conditions of the chosen branch
statements will be regarded as cc(check condition) (line 8
and 9). EH-Miner then explores all branch paths of the chosen
branch statements to Ô¨Ånd call statements and unconditional
branch statements (line 10). For each call statement, EH-Miner
records the statement as an hc(handling-function call) (line
12), and adds a new PEH instance <lc,cc,hc> toM(line 13
and 14). For each unconditional branch statement, EH-Miner
regards it as a special handling-function call, and adds a new
PEH instance <lc,cc, return/goto/break/continue >toM(line
17 and 18). Finally, EH-Miner returns M, which is the set of
PEH instances of the input function deÔ¨Ånition (line 24).
For example, the Ô¨Årst code snippet in Figure 5 calls a
library function foo, followed by two check conditions: one
216
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. Algorithm 1 PEH Instances Extraction Algorithm.
Require: Function deÔ¨Ånition F
Ensure: Instances set M={m|m=< lc, cc, hc > }
1:M=Œ¶
2:Scan F‚Äôs source code, and get all call statements
3:foreach call statement finFdo
4: iffcalls a library function then
5: Letlc=f
6: From lc, scan forwards, and get all branch statements
7: foreach branch statements bsafter lcdo
8: ifbsis Ô¨Çow dependent on lcthen
9: Letcc= condition of bs
10: Search paths of bs, and get calls and
unconditional branches.
11: foreach call statement f/primedo
12: Lethc=f/prime
13: Letm=< lc, cc, hc >
14: Add mtoM
15: end for
16: foreach unconditional branch statement do
17: Letm=<lc,cc,return/goto/break/continue >
18: Add mtoM
19: end for
20: end if
21: end for
22: end if
23: end for
24:Return M
is checking for a return value, while the other is check-
ing for a pointer argument. Each check condition has one
handling-function call. Therefore, EH-Miner extracts two PEH
instances, m1andm2. In addition to the above, EH-Miner
also needs to properly deal with the following situations: (a)
Else branch : When a function is called in the else branch of
anifstatement, EH-Miner negates the check condition; for
example, the second code snippet in Figure 5 generates m3.
Forswitch statements, EH-Miner records the switch case label
together with the conditional expression. (b) Non-reaching
deÔ¨Ånition : A library-function call will be ignored when its
return value is reassigned. For example, in the third code
snippet in Figure 5, Since the return value of foois reassigned
by ‚Äúrv = a‚Äù; accordingly, ‚Äúrv = foo(ptr)‚Äù is considered a non-
reaching deÔ¨Ånition [17] for rvin ‚Äúif(rv == 0)‚Äù, and will be
ignored. (c) Nested branches : Two check conditions will be
jointed when their branch statements are nested. For the fourth
code snippet in Figure 5, ‚Äúif(rv != 0)‚Äù is located in the else
branch of ‚Äúif(rv == -1)‚Äú; thus, the check condition of ‚Äúexit()‚Äù
will be ‚Äú!(rv == -1) && (rv != 0)‚Äù. This code snippet Ô¨Ånally
generates m4andm5.
B. Judging Equivalence of Check Conditions
For each pair of identiÔ¨Åed PEH instances, EH-Miner judges
the equivalence of their check conditions. According to Sec-
tion III-A, there are three levels of equivalence between
check conditions: syntactic level, semantic level and pragmatic
level. In this part, we will outline the procedure for judging
equivalence of these levels. rv = foo(ptr); 
 if(rv == - 1) 
    log(); 
 if(ptr == NULL) 
    return; rv = foo(ptr); 
 if(rv == 0) 
    ... 
 else 
    log(); rv = foo(ptr); 
rv = a; 
if(rv == 0) 
    exit();  rv = foo(ptr); 
 if(rv == - 1) 
    log(); 
 else if(rv != 0) 
    exit(); 



	rv=foo(ptr), rv==- 1, log()> 
	rv=foo(ptr), ptr== NULL, return>
	rv=foo(ptr), !(rv== 0), return>
	rv=foo(ptr), rv==- 1, log()> 
	rv=foo(ptr), !(rv==- 1)&&(rv!= 0), exit()>
Fig. 5. Mapping of code snippets and PEH instances.
Syntactic equivalence. It is easy to judge the syntactic
equivalence between check conditions. The most intuitive
approach is to compare two check conditions as strings.
Semantic equivalence. Compared with the syntactic level,
this equivalence level is much more powerful. We convert the
judgment of this equivalence into a satisÔ¨Åability problem, as
described in the following theorem.
Theorem 1. Given two check conditions XandY,Xand
Yare semantically equivalent if the expression (X‚àß¬¨Y)‚à®
(¬¨X‚àßY)is not satisÔ¨Åable.
Proof. If(X‚àß¬¨Y)‚à®(¬¨X‚àßY)is not satisÔ¨Åable, then both
(X‚àß¬¨Y)and(¬¨X‚àßY)are not satisÔ¨Åable.
If(X‚àß¬¨Y)is not satisÔ¨Åable, then there is no case that
satisÔ¨Åes Xbut does not satisfy Y. That is to say, every case
that satisÔ¨Åes Xwill also satisfy Y, namely, Y‚ÜíX.
Similarly, if (¬¨X‚àßY)is not satisÔ¨Åable, then X‚ÜíY.
IfY‚ÜíXandX‚ÜíY, then XandYare equivalent.
For example, suppose there are two equivalent check con-
ditions XandY, where Xis ‚Äúrv != 0‚Äù and Yis ‚Äúrv >0||rv
<0‚Äù.EH-Miner calculates the satisÔ¨Åability of (¬¨X‚àßY)and
(X‚àß¬¨Y)through a SatisÔ¨Åability Modulo Theories (SMT)
[18] solver, and Ô¨Ånds that both of them are not satisÔ¨Åable;
thus, (X‚àß¬¨Y)‚à®(¬¨X‚àßY)is not satisÔ¨Åable. Therefore, X
andYare equivalent.
Pragmatic equivalence. Given two check conditions ‚Äúrv
== -1‚Äù and ‚Äúrv != 0‚Äù, they are not equivalent according
to Theorem 1, but have the same behavior when rvis the
return value of chroot (i.e., belongs to {-1, 0}). To solve this
problem, we have to obtain the return-value ranges of library
functions. EH-Miner only analyzes constant error returns.
According to [10], in the libraries on standard Linux systems,
the non-constant return values are used only to indicate success
conditions (e.g., the number of bytes read).
For each library function, we Ô¨Årst Ô¨Ånd all its return state-
ments; from each return statement, we recursively search back-
wards along the use-deÔ¨Åne chain [19] to Ô¨Ånd the deÔ¨Ånitions of
the returned variables, then record all the integer deÔ¨Ånitions
as the return-value range. Taking chroot as an example, the
range expression of its return value will be ‚Äùret == -1 ||ret
== 0‚Äù. With the return-value ranges Ravailable, we have the
following theorem.
Theorem 2. Given two check conditions XandY,XandY
are pragmatically equivalent if the expression ((X‚àß¬¨Y)‚à®
(¬¨X‚àßY))‚àßR(rv1)‚àßR(rv2)‚àß...‚àßR(rvn)is not satisÔ¨Åable,
217
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. where rv1,r v2, ..., rv nare return-value variables in Xand
Y, and R(rvi)(i‚àà[1,n])is the range expression of rvi.
Proof. If the above expression is not satisÔ¨Åable, then both (i)
and(ii)below are not satisÔ¨Åable.
X‚àß¬¨Y‚àßR(rv1)‚àßR(rv2)‚àß...‚àßR(rvn)( i)
¬¨X‚àßY‚àßR(rv1)‚àßR(rv2)‚àß...‚àßR(rvn)( ii)
If(i)is not satisÔ¨Åable, the satisÔ¨Åability of (X‚àß¬¨Y)has two
cases: (a) (X‚àß¬¨Y)is not satisÔ¨Åable, in which case Y‚ÜíX
(Theorem 1); (b) (X‚àß¬¨Y)is satisÔ¨Åable, in which case, let
Sdenote the cases that satisfy Xbut do not satisfy Y. Since
(i)is not satisÔ¨Åable, S‚àßR(rv1)‚àßR(rv2)‚àß...‚àßR(rvn)must
not be satisÔ¨Åable (S is a subset of (X‚àß¬¨Y)). That is to say,
the cases in Sare impossible, since they are contradictory to
the ranges of return values. Thus, Sis empty, and every case
that satisÔ¨Åes Xwill also satisfy Y; in short, Y‚ÜíX.
Similarly, if (ii)is not satisÔ¨Åable, then X‚ÜíY.
IfY‚ÜíXandX‚ÜíY, then XandYare equivalent.
Name normalization. When the check conditions have
different variables, we can apply neither Theorem 1 nor 2
directly to judge their equivalence. For example, given two
check conditions XandY, where Xis ‚Äúrc==-1‚Äù and Yis
‚Äúerr!=0‚Äù, the satisÔ¨Åability of rcanderrcan not be judged. To
solve this problem, EH-Miner normalizes the variables.
Besides the exception-handling mechanism, there are three
common ways for library functions to communicate errors
with their callers. The Ô¨Årst is return values, e.g.,chroot returns
-1 when failing. The second is global variables, e.g.,errno in
libcis widely used to record the error code. The third is pointer
arguments; for example, in glib, many functions use pointer
arguments to pass errors, e.g.,‚Äú g xxx(..., GError **error)‚Äù
communicates errors with its caller through the argument
error . In light of the above, we only analyze three kinds
of variables, i.e., return values, global variables and pointer
arguments, while other variables will be ignored.
InEH-Miner , global variables are used directly, since their
names are the same even in different applications. Return
values are renamed to the function names with a 0 attached;
for example, rvwill be renamed to chroot 0when ‚Äúrv =
chroot()‚Äù. Pointer arguments are renamed to the function name
with an index attached; for example, for function call ‚Äúfoo(x,
y)‚Äù,xandywill be renamed to foo 1andfoo 2respectively.
Moreover, when a check condition contains a function call, the
call will be regarded as a return value, e.g., ‚Äúchroot()==-1‚Äù
will be normalized to ‚Äúchroot 0==-1‚Äù.
After name normalization, EH-Miner applies Theorem 2 or
Theorem 1 (if the library source code is not available) to
judge the equivalence of the check conditions. For ease of
comparison, all check conditions are partitioned into clusters,
and check conditions in the same cluster are equivalent. EH-
Miner normalizes the PEH instances by replacing their check
conditions with the cluster IDs.C. Recognizing Error-Handling Actions
EH-Miner needs to recognize the error-handling action from
each identiÔ¨Åed PEH instance. In solving this problem, existing
tools [5] only deal with three most common error-handling
actions: log,return andexit, and require users to input
logging functions. We propose a more practical technique that
can not only deal with more error-handling actions, but also
automate the recognition process.
Recalling the characteristics outlined in Section III-B, there
are nine error-handling actions that can be classiÔ¨Åed into
two categories. For actions in the Ô¨Årst category, i.e., un-
conditional branch statements, we search those statements
mechanically. For actions in the second category, i.e., cus-
tom error-handling functions, we use two heuristic rules:
(a) The custom error-handling function always wraps cer-
tain library functions. Taking action log as an example,
its custom error-handling functions always wrap functions
such as printf ,write andsend . This is not surprising
since the custom function has to implement the functionality
of the action eventually. (b) There is a call chain from
the custom error-handling function to the wrapped library
function, and each function in the call chain contains cer-
tain keywords. For example, in MySQL, the custom log-
ging function sqlprint error calls library function fprintf
through the call chain sqlprint error ,error logprint ,
print buffer tofile,fprintf . Each function in the chain
contains keywords such as ‚Äúprint‚Äù, ‚Äúerror‚Äù or ‚Äúlog‚Äù that refer
to printing error messages.
For each action act, we empirically deÔ¨Åne its wrapped
standard-library function set SFact(e.g.,{printf, write, send
...}for action log) and its keyword set KW act(e.g.,{print,
log, fatal ... }for action log). Given an error-handling function,
EH-Miner builds its call graph, then applies depth Ô¨Årst search
on the call graph. (If the function invokes a third-part library,
EH-Miner also builds the call graph of the third-part library
function.) Each path pof the call graph may perform one error-
handling action. EH-Miner determines that pperforms actif:
(a)pends up with a standard-library function in SFact; (b)
every node in pcontains at least one keyword in KW act.EH-
Miner collects the actions of all paths.
For ease of comparison, EH-Miner normalizes the PEH
instances by replacing their handling-function calls with error-
handling actions (if any). When a handling-function call per-
forms multiple actions, EH-Miner will split the instance into
multiple separated ones that share the same library-function
call and check condition, but have different actions.
D. Mining Error-Handling Rules
EH-Miner mines error-handling rules by using the nor-
malized PEH instances. Each rule contains three elements:
a library function, a check condition and an error-handling
action. For a library function, EH-Miner Ô¨Årst selects its check
conditions that appear frequently, then determines the corre-
sponding error-handling actions for each check condition.
Mining check conditions. In some applications, developers
use wrapper functions that wrap library functions and add
218
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. certain error-handling code. While other applications may use
the wrapped library functions directly. Mixing the usage of
library functions and wrapper functions may cause inaccuracy
in cross-application mining. To avoid this, we propose a two-
step method to mine the check conditions:
‚Ä¢Intra-application mining step. For a library function f,
we refer to the number of its invocations in application
pasN(p, f). For a check condition coff, we refer to
the number of its appearance in pasM(p, f, c ).W es a y
an application psupports cifM(p, f, c )/N (p, f)>
TH intra , where TH intra is a pre-deÔ¨Åned threshold. This
formula indicates that the application psupports cwhen
cfrequently appears after f.
‚Ä¢Inter-application mining step. LetP(f)denote the num-
ber of applications that invoke f, and Q(f,c)denote
the number of applications that support c. A check
condition cwill be chosen if Q(f,c)/P(f)>TH inter ,
where TH inter is a pre-deÔ¨Åned threshold. This formula
indicates that a check condition will be selected if most
applications support it.
Mining error-handling actions. In this step, EH-Miner
determines the error-handling actions. EH-Miner counts the
number of every action used after above check conditions,
and chooses the actions satisfying both the following rules:
(a) the number of the action is the largest among all actions;
(b) the number of the action is at least one standard deviation
larger than the average number of all actions.
With reference to the error-handling rules available, EH-
Miner scans the source code again to detect violations of these
rules. EH-Miner , however, may report tens of thousands of
violations when applying the rules directly. In this regard, EH-
Miner further ranks the violations. For a library function f,w e
refer to the number of its total call sites as Cfand the number
of its violations as Vf. Let Rfdenote Vf/Cf. Violations of
fwith smaller Rfare more likely to be true positives.
V. I MPLEMENTATION
We implement EH-Miner using Clang [20] (front-end anal-
ysis), LLVM IR [21] (data Ô¨Çow analysis), Z3 [22] (SMT
solving) and SQLite3 [23] (data management). To extract PEH
instances, we implement a standalone Clang tool and leverage
the use-deÔ¨Åne chain in LLVM IR. The extracting step of EH-
Miner is written in C++, while all other steps are written in
Python. To judge the equivalence of the check conditions, we
apply Z3 to solve the satisÔ¨Åability problem. The intermediate
results across different steps are stored in a SQLite3 database.
To build the code repository, we carefully select 15 software
domains that are widely used in the open source community.
For each software domain, we choose the mature applications
that are open source, written in C/C++, and have a long
development history. Most of these applications are conÔ¨Åg-
urable and have a range of optional features. To analyze the
libraries used by the optional features, we enable as many
features as possible rather than using the default conÔ¨Åguration
when building. In total, we choose 117 applications that are
successfully built, which include 26.2M lines of code (LOC)and 51,264 source Ô¨Åles. We get the data by using cloc [24]
tool; the LOC number excludes the lines of blank, comment or
code in header Ô¨Åles. These applications depend on hundreds of
libraries, which are all automatically analyzed by EH-Miner .
In the interests of saving space, the applications and libraries
will not be listed here1.
All our analysis was conducted on 64-bit Ubuntu 16.04,
with 2.7 GHz Intel i5 and 4 GB DDR3. EH-Miner spent ten
hours in total and generated 536K PEH instances.
VI. E XPERIMENTAL RESULTS
In this section, we evaluate EH-Miner by answering the
following research questions (RQs).
RQ1: What are the precision and recall of EH-Miner ?
RQ2: Can EH-Miner Ô¨Ånd real-world bugs effectively?
RQ3: Does EH-Miner outperform the state-of-the-art tools?
A. Precision and Recall of EH-Miner
EH-Miner requires two parameters to be pre-deÔ¨Åned, i.e.,
TH intra andTH inter . These parameters may obviously affect
the precision ( P) and the recall ( R)o f EH-Miner . In this part,
we Ô¨Årst tune the parameters, then evaluate PandRunder the
optimal parameters.
Experiment setup. We use cross-validation to tune the
parameters so that the parameters can generalize well to any
dataset. Each of the 117 applications is randomly assigned to
one of the two sets: a training set and a test set. This process
is independently repeated 20 times, so we have 20 training
sets and 20 corresponding test sets. We carefully tune the
parameters to Ô¨Åt the training sets, then evaluate the averaged P
andRin the test sets. It is hard to evaluate PandRof error-
handling bugs due to lack of the ground truth. Being similar
to the existing works [13], [14], we evaluate PandRof the
reported error-handling rules. We studied all POSIX functions
used by all applications, and manually generated their error
speciÔ¨Åcations (recorded in Z3 format), serving as oracles for
conÔ¨Årming the reported rules. A rule will be regarded as
correct if its check condition is equivalent to (or is a subset of)
the error condition of the error speciÔ¨Åcation. The equivalence
judgement is performed by the Z3 solver, similar to the process
in Section IV-B.
Suppose the expected number of error-handling rules is N.
LetMdenote the number of reported rules, and M/primedenote the
number of correct rules. The precision is the ratio of |M/prime|to
|M|, while the recall is the ratio of |M/prime|to|N|.F o r EH-Miner ,
the expected number of rules is the number of correct rules
which appear at least one time in any application. Moreover,
we prefer an overall metric that considers both PandRfor the
ease of comparison. The most common practice is to calculate
Fscore , which is the harmonic mean of PandR. For static
tools of bug detection, however, Pis much more important
than R. Brittany et al . [26] conducted interviews with 20
developers to ascertain why software developers do not use
1Please refer to our project homepage [25] for the target applications, source
code and bug reports involved in this paper.
219
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply.  
Fig. 6. Different metrics of reported error-handling rules.
static analysis tools to Ô¨Ånd bugs and found that false positives
constitute the most signiÔ¨Åcant barrier. With this in mind, we
used the weighted harmonic mean of PandR:
F/prime
score =w1+w2
w1
P recision+w2
Recall,
where w1andw2are the weights of PandR, respectively.
The weights of precision and recall are subjective for different
users, thus EH-Miner provides user interfaces to change these
parameters, while the default values of w1andw2are 0.7 and
0.3, respectively.
Optimal thresholds. We apply EH-Miner to the training
sets, and evaluate the rules that are related to POSIX functions.
We iterate the parameters TH intra andTH inter from 0 to
1 with a step length of 0.05. The results of averaged P
andRare shown in Figure 6. It is clear that Pincreases
with the corresponding increase in the thresholds, while R
is reduced as the thresholds increase. The averaged Pranges
from 0.45 to 1, while the averaged Rranges from 0.83 to 0. We
normalize both PandRby using min-max normalization [27]
so that each metric contributes approximately proportionately
toF/prime
score . As the two thresholds are increased, F/prime
score initially
increases and subsequently decreases. When TH intra equals
to 0.35 and TH inter equals to 0.15, EH-Miner achieves its
highest averaged F/prime
score in the training sets, while the averaged
PandRare 90.2% and 48.3%, respectively.
The precision and recall. We apply EH-Miner to the
test sets by using (0.35, 0.15) as the optimal parameters.
The averaged PandRof the 20 test sets are 91.1% and
46.9%, while the standard deviation of PandRare 1.5%
and 4.0%. The results indicate that EH-Miner can achieve a
higher precision compared with [13], and a much higher recall
compared with [14]. Meanwhile, the recall and the precision
are similar to [13] and [14], respectively. In Section VI-C, we
will compare these tools in detail.
B. Real-World Bugs Reported by EH-Miner
In this part, we evaluate the effectiveness of EH-Miner
through its ability of detecting real-world bugs.
Bugs in applications. We apply EH-Miner to all 117 appli-
cations. EH-Miner found 1036 error-handling rules (180 for
POSIX functions and 856 for other third-party libraries). With
these rules available, EH-Miner found 2266 violations, which
are from 189 library functions. We sampled and analyzed the
violations until the conÔ¨Ådence interval is less than or equal
to 3 at 95% conÔ¨Ådence level. We skipped the violations that
we can not determine the correctness, and Ô¨Ånally sampled 380TABLE I
NUMBER OF CONFIRMED OR FIXED BUGS .
Application Bug Application Bug Application Bug
Amarok‚àó2 Ayttm 2 Balsa 1
Bftpd 12 BitKeeper‚àó3 BlueÔ¨Åsh 4
Citadel‚àó6 Claws-mail‚àó7 Cubrid 10
Darktable‚àó4 Ettercap‚àó6 Fossil 3
GFTP 3 GIMP‚àó4 Httpd‚àó4
LFTP 3 Mariadb‚àó2 MonetDB‚àó5
MPlayer‚àó2 Mutt 1 Netsniff-ng 7
Pidgin‚àó3 VLC‚àó1 W3M 5
XBMC‚àó3 Xplico 3
‚àóThe application is regularly checked by Coverity or Fortify.
violations, of which 335 are true positives, and 45 are false
positives. At 95% conÔ¨Ådence level, the precision is 88.16%
with a conÔ¨Ådence interval of 2.96, i.e., [85.20%, 91.12%].
We found the true positive violations can be classiÔ¨Åed into
two types. Type A(248 violations) indicates that the library
functions are not checked at all. Violations in this type are
deÔ¨Ånitely bugs which may cause serious results like crash
or data loss. Type B(87 violations) means developers have
checked the library functions and performed normal actions in
normal paths, while the error paths are ignored. This type of
violation may not lead to a crash in most test cases, but we
still believe these violations should be Ô¨Åxed conservatively to
make the program more robust.
The false positive cases are mainly caused by the following
reasons: (i) The error-handling rule is wrong. For example, the
function ferror should not fail, but EH-Miner reports error-
handling bugs for ferror . (ii) The library function is checked
by another way. For example, the return value of notify init
(in library Libnotify ) is normally checked before calling
other Libnotify functions (e.g., notify notification new).
TheBalsa program, however, calls notify isinitted before
calling other Libnotify functions to make sure notify init
is successfully initialized. In this situation, EH-Miner reports a
false positive about notify init. (iii) The error-handling code
is located in complex context, and EH-Miner fails to detect.
We are now in the process of reporting the Type Abugs
to the developers due to their importance. So far, we have
submitted patches for 142 bugs according to the ranking Rf
(deÔ¨Åned in Section IV-D), and patches for 106 bugs have been
conÔ¨Årmed or Ô¨Åxed by developers at the time of writing. On
the other hand, seven patches were rejected. Among them, Ô¨Åve
were regarded as unnecessary, since developers believe that the
bugs will never happen. One patch was rejected since it will
result in another bug. For the last rejected patch, the developer
believes the whole system will down when the bug happens,
and it is useless to Ô¨Åx the bug in an application. In Table I,
we list all the bugs which have been conÔ¨Årmed or Ô¨Åxed by
developers.
Case study. In this part, we study a real-world bug detected
by EH-Miner ‚Äî the MonetDB Database Server daemon,
monetdbd , will crash if a wrong host was set to the con-
Ô¨Åguration item listenaddr . If a user set a wrong host to
listenaddr and started the server, the host will be sent directly
220
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. to the library function gethostbyname . In this situation,
gethostbyname will fail and return a NULL pointer. Further
use of the return value will cause a NULL pointer dereference.
Monetdbd will abort if this bug is triggered; thus, developers
Ô¨Åxed the bug once it was reported and labelled it as a critical
bug.
To detect this bug, EH-Miner found that gethostbyname is
used in 37 different applications, 23 of which have checked
whether or not its return value is NULL; if so, performed the
return action. Therefore, EH-Miner got the error-handling
rule that ‚ÄúWhen gethostbyname returns NULL, its caller
function should return‚Äù. Finally, EH-Miner scanned the source
code again to detect violations of this rule.
Bugs in Linux kernel. We further apply EH-Miner to
Linux kernel to evaluate the effectiveness of EH-Miner on
a different dataset. The error-handling rules of API functions
can not be used since kernel does not use any library. As EH-
Miner performs cross-project mining, each kernel subsystem
will be regarded as a separated project, e.g., fs/ext4, and
we have 395 projects in the kernel dataset. EH-Miner gets
1590 error-handling rules and 2069 violations of the rules for
298 kernel functions. We randomly inspect 460 violations, of
which 386 are true positives, while 74 are false positives.
At 95% conÔ¨Ådence level, the precision is 83.91% with a
conÔ¨Ådence interval of 2.96, i.e., [80.95%, 86.87%].
As before, we are now in the process of reporting the Type
Akernel bugs to developers. So far, we had reported 68 bugs
(from 30 kernel functions and each function may have multiple
bug instances), and 42 bugs had been conÔ¨Årmed or Ô¨Åxed
by developers at the time of writing. Among these, 28 bugs
were Ô¨Åxed by using our patches; 6 bugs are under discussing
about how to improve the patches; 8 patches are rejected even
though the bugs are conÔ¨Årmed, since developers believe the
whole functions are buggy, while our patches do not help.
On the other hand, 22 bugs are rejected. One reason is that
there is no serious consequence even the function fails. For
example, developers ignore the errors of i2cnew dummy
(6 instances), since i2c devices are not really used. Another
reason is that the error has been well handled in other way.
For example, when kmem cache create fails (9 instances),
kernel panic happens if the function is invoked with argument
SLAB PANIC.
C. Comparison of Different Methods
In this section, we compare EH-Miner with the existing
tools of detecting error-handling bugs. LFI [11] is a dynamic
analyzing tool, while EH-Miner is a static one. Dynamic tools
can achieve much higher accuracy compared with static tools,
but they are unable to Ô¨Ånd bugs that have not been executed.
Therefore, EH-Miner is complementary to LFI. EPEx [5] and
ErrDoc [4] are static tools but require users to provide error
speciÔ¨Åcations as input, while EH-Miner requires no such input.
Some commercial tools are widely used in practice, e.g.,
Coverity [28] and Fortify [29]. EH-Miner reported 106 bugs
that were Ô¨Åxed by developers at the Ô¨Årst time. These bugs
are from 26 projects, while 14 projects (containing 52 bugs)have been regularly checked by Coverity or Fortify as shown
in Table I. The fact that none of these bugs were detected by
these tools demonstrates that EH-Miner can detect bugs that
the state-of-the-art tools miss. The closest works to EH-Miner
is APEx [13] and Acharya et al . [14], which are static tools
and mine error speciÔ¨Åcations automatically. We choose [13]
and [14] as the baseline methods.
Experiment setup. We compare these tools through three
metrics: the precision, the recall and the efÔ¨Åciency. APEx [13]
and Acharya et al . [14] manually evaluated both the precision
of bugs and the precision of error speciÔ¨Åcations. The precision
of bugs, however, might be biased, since the authors might
have limited domain knowledge and simply regard violations
of correct rules as true positives. This assumption will lead to
overestimation. For example, all rejected bugs in Section VI-B
are violations of correct rules, but they are not true positives.
In this regard, we use PandRof error speciÔ¨Åcations, since
the standard of the library functions can serve as an oracle.
EH-Miner mines error-handling rules instead of error speci-
Ô¨Åcations. For the ease of comparison, let Idenote the expected
number of functions covered by error speciÔ¨Åcations or error-
handling rules. Let Jdenote the number of functions that
covered by reported error speciÔ¨Åcations or error-handling
rules, and J/primedenote the number of functions that covered
by correct error speciÔ¨Åcations or correct error-handling rules.
The precision is the ratio of |J/prime|to|J|, while the recall is the
ratio of|J/prime|to|I|. For functions covered by multiple rules,
we calculate the proportion of correct rules. For example, if
a function is covered by three rules ‚Äî one correct rule and
two wrong rules ‚Äî the number of function covered by correct
rules is 0.33.
Comparing above metrics directly may also cause bias since
EH-Miner learns from more applications. To remedy this, we
apply EH-Miner to 28 applications which are used by APEx
[13]. For space reason, we do not list these applications. As
for Acharya et al . [14], the authors did not provide their
application list, and the tool is not available, so it is hard
to compare [14] with EH-Miner by using the same dataset.
Comparison with [14]. Under optimal parameters, EH-
Miner mines 120 error-handling rules for POSIX library
covering 109 functions. Among them, rules of 98.58 functions
are correct (some functions are covered by both correct and
wrong rules), while the expected number of functions is 138
(POSIX functions that appear in any of the 28 programs). Thus
the precision and recall are 90% and 71%, respectively. As
shown in Table II, EH-Miner learns from fewer applications,
while the precision is similar to [14]. Acharya et al . reported
that their tool spent one hour on PostÔ¨Åx, which has 111K lines
of code. The efÔ¨Åciency is about nine hours per million lines
of code (MLOC). According to Section V, the efÔ¨Åciency of
EH-Miner is 0.38 hours per MLOC.
Acharya et al . mine API-Error Check from error traces
when the check conditions are equivalent in the syntactic level.
In our study, the syntactically equivalent cases only account
for 26% (Figure 2). Additionally, they assume that there is
an explicit return/exit statement in an error trace. Our study
221
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. TABLE II
COMPARISON OF DIFFERENT TOOLS .
#Appl. Precision Recall EfÔ¨Åciency
Acharya et al . 83 90% 28‚àó9 H/MLOC
APEx 28 77% 47% 7.7 H/MLOC
EH-Miner 28 90% 71% 0.38 H/MLOC
‚àóThe authors did not report the recall.
shows that these two statements only account for 46% (Figure
3). As a result, [14] found error speciÔ¨Åcations of 28 functions
for both POSIX and X11 libraries. While EH-Miner found
rules of 98.58 functions for POSIX library only, in spite of
learning from fewer applications.
Comparison with [13]. Acharya et al . [14] is the prior
work of APEx [13], which claims that APEx outperforms [14],
thus we regard APEx as the state-of-the-art tool. The precision
and recall of APEx are 77% and 47%, respectively. APEx
spent 11.5 hours on Ô¨Åve applications: ClamA V , Pidgin, Grep,
GnuTLS and Coreutils, which have 1.5M lines of code in total.
The efÔ¨Åciency is about 7.7 hours per MLOC. EH-Miner is
about 20 times faster than APEx. Though EH-Miner uses a
constraint solver, the number of variables in each constraint is
very limited (only from two check conditions), and EH-Miner
will not suffer the path explosion problem.
APEx Ô¨Årst distinguishes error paths and non-error paths,
then analyzes the conditions of error paths and mines error
speciÔ¨Åcations like ‚Äúfor foo(), -1 is an error return value‚Äù. In
contrast to APEx, EH-Miner does not need to know whether -1
means error or not, but directly mines rules like ‚Äúfoo() should
be logged when returning -1‚Äù. This feature enables EH-Miner
to improve the precision by (90%-77%) / 77%, i.e., 17%. On
the other hand, the features of judging equivalence of check
conditions and recognizing error-handling actions improve the
recall from 47% to 71%.
VII. D ISCUSSION
Exception-handling mechanism. There are two common
practices to handle errors in software. The Ô¨Årst practice is
to use explicit exception handling mechanism, i.e., try-catch
block, which are built-in features in many languages like Java
and Python. This mechanism has Ô¨Åxed syntax structure, and
has been well studied by many existing works. While EH-
Miner is designed as a complement tool to the existing works.
EH-Miner focuses on the second practice, i.e., function-return-
check, which is wide-used in low-level languages such as
C/C++. C does not provide exception-handling mechanisms,
while C++ projects contain far fewer try blocks than projects
developed in the other languages.
Alternative error-handling method. Sometimes, develop-
ers may can use an alternative method to handle an error
of an API. For example, in Balsa, developers do not check
the return value of the API notify init. Instead, they use
notify isinitted to ensure Libnotify is successfully ini-
tialized by notify init. Another example is open andstat.
The developers use stat to check the state of a Ô¨Åle that is
going to be opened by open . When stat returns success, openwill succeed in most cases. EH-Miner , however, can not cope
with this relationship, and reports two false-positive cases. To
remedy this situation, we will need to study the relationship
between API functions further.
Impact-oriented bug detection. EH-Miner can Ô¨Ånd bugs
that cause severe results like crash or abort. These results,
however, have different impacts. For example, in MonetDB,
an error-handling bug of gethostbyname causes a crash, and
the bug is classiÔ¨Åed as a critical bug. On the other hand, in
Fossil, a bug of fopen crashes a component mkversion . The
developer, however, believes this bug is not important, since
mkversion is a one-off utility used during the build process,
and is called only by MakeÔ¨Åle. EH-Miner can not avoid the
low impact bugs as yet.
VIII. T HREATS TO VALIDITY
Threats to external validity. The Ô¨Årst threat to external
validity is the representativeness of the programs. In the
implementation of EH-Miner, we choose as many as possible
software domains, and representative programs from those
domains to build dataset. The programs use APIs from various
libraries, thus EH-Miner can mine error-handling rules of
the APIs. The dataset, however, may not be generalized to
other datasets, e.g., the Linux kernel do not use libraries.
To control this threat, we evaluate EH-Miner on a different
dataset ‚Äì Linux kernel. The second threat to external validity
is the limitations of error-handling actions. In Section III, we
summarize nine actions from Ô¨Åve programs. There might be
another action that is not used by any of the Ô¨Åve programs,
thus our action set may not be generalized to other programs.
The impact the this threat is limited. We mine error-handling
rules from frequent actions; others will be ignored anyway.
Threats to internal validity. Beyond the factors in PEH
model, there are two other factors that can impact error-
handling rules: context and argument, which pose threats to
internal validity. (a) The context of error-handling actions is
the Ô¨Årst threat. The choice of error-handling actions might
be determined by some application-speciÔ¨Åc contexts besides
check conditions. For example, the break andcontinue
actions should be only used in loops; the delete andclose
actions should be used when dealing with Ô¨Åles or directories;
thereturn action usually will not be used when the caller
function returns void. (b) The second threat is argument.
Taking fopen as an example, fopen has two arguments: Ô¨Åle
name and operation mode. Whenever the Ô¨Åle name is tainted
by any form of input, fopen becomes more likely to fail. For
example, the invocation fopen (input file, ‚Äòr/prime)is more likely
to fail than fopen (‚Äú/etc/passwd ‚Äù,‚Äòr/prime), since the input file
may be a Ô¨Åle that does not exist. As for the second argument,
‚Äòr‚Äô is more likely to fail than ‚Äòw‚Äô. Given a non-existent Ô¨Åle,
fopen fails when reading, and creates a new Ô¨Åle when writing.
We leave the contexts and arguments in future work.
Threats to construct validity. A common practice to
evaluate static tools is using precision and recall. For EH-
Miner, however, it is hard to measure its recall, since lack
of ground truth of false negative. Measuring precision is also
222
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. non-trivial, since the results should be inspected by developers
manually. In this regard, we use the precision and recall of
error-handling rules instead of the precision and recall of error-
handling bugs to evaluate EH-Miner. A violation of a right
error-handling rule does not have to be a bug, e.g., developers
may use an alternative way to handling the error.
IX. R ELATED WORKS
Error-handling bugs. Existing works of detecting error-
handling bugs can be classiÔ¨Åed into two kinds, i.e., static
approaches and dynamic approaches. Many works use static
analysis techniques for detecting bugs. Tian et al. [4] con-
ducted empirical study on error-handling bugs, and proposed
ErrDoc, a tool that can automatically detect, categorize, and
Ô¨Åx error-handling bugs. Jana et al. [5] designed EPEx, which
uses under-constrained symbolic execution to explore error
paths and detect error handling bugs. Lawall et al. [7] built
a static bug Ô¨Ånding tool for Ô¨Ånding error-handling bugs in
SSL. Rubio-Gonzlez et al. [2] proposed an inter-procedural
static analysis that tracks errors as they propagate through Ô¨Åle
system code. Gunawi et al. [6] developed a static analysis
technique that analyzes how Ô¨Åle systems and storage device
drivers propagate error codes. As error conditions rarely hold
feeding regular input, thus the error-handling code rarely gets
to run and error-handling bugs are hard to test. To Ô¨Åll this
gap, researchers have used dynamic fault injection to execute
error-handling code by simulating failures. Marinescu et al.
[9]‚Äì[11] proposed a dynamic analysis technique and developed
a fault injection tool. They simulate API failures according
to the error speciÔ¨Åcations and check the response of the test
program. Jia et al. [30] designed and implemented SmartLog,
an intention-aware log automation tool to place log statements
for error-prone functions.
Both static and dynamic works depend heavily on correct
error speciÔ¨Åcations, while EH-Miner can detect error-handling
bugs without error speciÔ¨Åcations.
Exception-handling bugs. There is a long line of research
focuses on exception-handling mechanisms, which are built-
in features in many languages like Java and Python. Many
researchers study the characteristics of exception-handling
bugs. Ebert et al . [31] conducted a survey of 154 devel-
opers and an analysis of 220 exception handling bugs from
the repositories of Eclipse and Tomcat. Oliveira et al . [32]
presented an empirical study on the relationship between the
usage of Android abstractions and uncaught exceptions. Filho
et al . [33] presented an in-depth study of the adequacy of
the AspectJ language for modularizing exception handling
code. Jakobus et al . [12] contrasted exception handling code
across languages from 50 open source projects. Some works
are aimed to detect and repair exception-handling bugs. Bar-
bosa et al . [34] presented a tool to recommend repairs of
exception handling violations with aware of the global context.
Guet al . [35] expanded the intrinsic capability of runtime
error resilience in software systems to recovery unexpected
errors at runtime. Yan et al . [36], [37] proposed a slice-
based statistical fault localization approach to improve faultlocalization effectiveness. Weimer et al . [38], [39] presented
a data-Ô¨Çow analysis for Ô¨Ånding a certain class of exception-
handling bugs in Java programs. Jia et al . [40] designed a tool
that can automatically detect and pinpoint the root causes of
the problems caused by ungraceful exits.
These works focus on exception-handling mechanisms like
try-catch statements. While EH-Miner detects bugs for error
handling of function return, which is widely used in languages
like C/C++.
API speciÔ¨Åcations. Another line of research related to EH-
Miner is API speciÔ¨Åcations mining. Some works are aimed
to automatically mine error speciÔ¨Åcations. DeFreez et al .
[41] proposed a path-based embedding method to determine
function synonyms, and predicted the functions that should
be executed when an error occurs. This method, however,
can not predict error conditions. Kang et al . [13] studied the
characteristics of error paths and proposed APEx, which can
automatically infer error speciÔ¨Åcations for C API functions.
Acharya et al . [14] automatically inferred error handling
speciÔ¨Åcations of APIs by mining static traces of their run-
time behaviors. Rubio-Gonzlez et al . [15] examined mis-
matches between documented and actual error codes, and
revealed undocumented error-code instances. Magiel et al .
[42] focused on a speciÔ¨Åed embedded system, and presented
a fault model accompanied by an analysis tool. Several prior
research projects have mined different types of speciÔ¨Åcations
from source code to help software developers. Nguyen et al .
[43] mined large-scale repositories of existing open-source
software to derive potential preconditions for API methods.
Zhong etal. [44] and Tan et al . [45] tried to infer API
speciÔ¨Åcations from user manuals and comments. Acharya
et al . [46] proposed a framework to automatically extract
usage scenarios among user-speciÔ¨Åed APIs as partial orders.
Engler et al . [47] demonstrated techniques that automatically
extract programing rules from the source code.
EH-Miner is closer to works of mining error speciÔ¨Åcations:
[13] and [14]. Compared with these works, EH-Miner has
three advantages: higher accuracy, better scalability and easier
to repair.
X. C ONCLUSIONS
The existing methods of detecting error-handling bugs are
limited by the need for correct error speciÔ¨Åcations input. This
prerequisite is hard to satisfy, since manually generating error
speciÔ¨Åcations is error-prone and tedious, while mining error
speciÔ¨Åcations automatically is often inaccurate. To Ô¨Åll the
gap, we designed and implemented EH-Miner , a tool that
can automatically detect error-handling bugs without requiring
error speciÔ¨Åcations as input. We applied EH-Miner to 117
mature applications. It was found that EH-Miner mined error-
handling rules with precision of 91.1% and recall of 46.9%.
We reported 142 bugs mined by EH-Miner ; of these, 106 had
been conÔ¨Årmed and Ô¨Åxed by developers. We also reported 68
bugs Linux kernel-4.17, of which 42 were conÔ¨Årmed or Ô¨Åxed
by developers.
223
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] M. P. Robillard and G. C. Murphy, ‚ÄúDesigning robust java
programs with exceptions,‚Äù in Proceedings of the 8th ACM SIGSOFT
International Symposium on F oundations of Software Engineering:
Twenty-Ô¨Årst Century Applications , ser. SIGSOFT ‚Äô00/FSE-8. New
York, NY , USA: ACM, 2000, pp. 2‚Äì10. [Online]. Available:
http://doi.acm.org/10.1145/355045.355046
[2] C. Rubio-Gonz ¬¥alez, H. S. Gunawi, B. Liblit, R. H. Arpaci-Dusseau,
and A. C. Arpaci-Dusseau, ‚ÄúError propagation analysis for Ô¨Åle
systems,‚Äù in Proceedings of the 30th ACM SIGPLAN Conference on
Programming Language Design and Implementation , ser. PLDI ‚Äô09.
New York, NY , USA: ACM, 2009, pp. 270‚Äì280. [Online]. Available:
http://doi.acm.org/10.1145/1542476.1542506
[3] ‚ÄúOwasp,‚Äù https://www.owasp.org/images/e/e8/OWASP Top 102007.
pdf, 2018.
[4] Y . Tian and B. Ray, ‚ÄúAutomatically diagnosing and repairing error
handling bugs in c,‚Äù in Proceedings of the 2017 11th Joint Meeting
on F oundations of Software Engineering , ser. ESEC/FSE 2017. New
York, NY , USA: ACM, 2017, pp. 752‚Äì762. [Online]. Available:
http://doi.acm.org/10.1145/3106237.3106300
[5] S. Jana, Y . J. Kang, S. Roth, and B. Ray, ‚ÄúAutomatically detecting
error handling bugs using error speciÔ¨Åcations.‚Äù in USENIX Security
Symposium , 2016, pp. 345‚Äì362.
[6] H. S. Gunawi, C. Rubio-Gonz ¬¥alez, A. C. Arpaci-Dusseau, R. H. Arpaci-
Dusseau, and B. Liblit, ‚ÄúEio: Error handling is occasionally correct.‚Äù in
F AST , vol. 8, 2008, pp. 1‚Äì16.
[7] J. Lawall, B. Laurie, R. R. Hansen, N. Palix, and G. Muller, ‚ÄúFinding
error handling bugs in openssl using coccinelle,‚Äù in Dependable Com-
puting Conference (EDCC), 2010 European . IEEE, 2010, pp. 191‚Äì196.
[8] P. Broadwell, N. Sastry, and J. Traupman, ‚ÄúFig: A prototype tool
for online veriÔ¨Åcation of recovery mechanisms,‚Äù in Workshop on Self-
Healing, Adaptive and Self-Managed Systems , 2002.
[9] P. Marinescu, R. Banabic, and G. Candea, ‚ÄúAn extensible technique for
high-precision testing of recovery code,‚Äù in Proceedings of the USENIX
annual technical conference , no. EPFL-CONF-147244, 2010.
[10] P. Marinescu and G. Candea, ‚ÄúEfÔ¨Åcient testing of recovery code
using fault injection,‚Äù ACM Trans. Comput. Syst. , vol. 29, no. 4, pp.
11:1‚Äì11:38, Dec. 2011. [Online]. Available: http://doi.acm.org/10.1145/
2063509.2063511
[11] P. D. Marinescu and G. Candea, ‚ÄúLÔ¨Å: A practical and general library-
level fault injector,‚Äù in Dependable Systems & Networks, 2009. DSN‚Äô09.
IEEE/IFIP International Conference on . IEEE, 2009, pp. 379‚Äì388.
[12] B. Jakobus, E. A. Barbosa, A. Garcia, and C. J. P. de Lucena, ‚ÄúCon-
trasting exception handling code across languages: An experience report
involving 50 open source projects,‚Äù in 2015 IEEE 26th International
Symposium on Software Reliability Engineering (ISSRE) , Nov 2015, pp.
183‚Äì193.
[13] Y . Kang, B. Ray, and S. Jana, ‚ÄúApex: Automated inference of error
speciÔ¨Åcations for c apis,‚Äù in Proceedings of the 31st IEEE/ACM
International Conference on Automated Software Engineering , ser. ASE
2016. New York, NY , USA: ACM, 2016, pp. 472‚Äì482. [Online].
Available: http://doi.acm.org/10.1145/2970276.2970354
[14] M. Acharya and T. Xie, ‚ÄúMining api error-handling speciÔ¨Åcations from
source code,‚Äù in Fundamental Approaches to Software Engineering ,
M. Chechik and M. Wirsing, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2009, pp. 370‚Äì384.
[15] C. Rubio-Gonz ¬¥alez and B. Liblit, ‚ÄúExpect the unexpected: Error
code mismatches between documentation and the real world,‚Äù in
Proceedings of the 9th ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools and Engineering , ser. PASTE ‚Äô10.
New York, NY , USA: ACM, 2010, pp. 73‚Äì80. [Online]. Available:
http://doi.acm.org/10.1145/1806672.1806687
[16] D. analysis, https://en.wikipedia.org/wiki/Dependence analysis, 2018.
[17] ‚ÄúReaching deÔ¨Ånition,‚Äù https://en.wikipedia.org/wiki/Reaching
deÔ¨Ånition, 2018.
[18] L. De Moura and N. Bj√∏rner, ‚ÄúSatisÔ¨Åability modulo theories:
Introduction and applications,‚Äù Commun. ACM , vol. 54, no. 9, pp.
69‚Äì77, Sep. 2011. [Online]. Available: http://doi.acm.org/10.1145/
1995376.1995394
[19] ‚ÄúUse deÔ¨Åne chain,‚Äù https://en.wikipedia.org/wiki/Use-deÔ¨Åne chain,
2018.
[20] ‚ÄúClang,‚Äù https://clang.llvm.org, 2018.
[21] ‚ÄúLlvm,‚Äù https://www.llvm.org, 2018.[22] ‚ÄúZ3,‚Äù https://github.com/Z3Prover/z3, 2018.
[23] ‚ÄúSqlite3,‚Äù https://www.sqlite.org, 2018.
[24] ‚ÄúCloc,‚Äù http://cloc.sourceforge.net, 2018.
[25] ‚ÄúEh-miner,‚Äù https://github.com/ZhouyangJia/EH-Miner, 2019.
[26] B. Johnson, Y . Song, E. Murphy-Hill, and R. Bowdidge, ‚ÄúWhy
don‚Äôt software developers use static analysis tools to Ô¨Ånd bugs?‚Äù
inProceedings of the 2013 International Conference on Software
Engineering , ser. ICSE ‚Äô13. Piscataway, NJ, USA: IEEE Press,
2013, pp. 672‚Äì681. [Online]. Available: http://dl.acm.org/citation.cfm?
id=2486788.2486877
[27] F. scaling, https://en.wikipedia.org/wiki/Feature scaling, 2018.
[28] Coverity, https://scan.coverity.com, 2018.
[29] Fortify, https://software.microfocus.com/en-us/solutions/
application-security, 2018.
[30] Z. Jia, S. Li, X. Liu, X. Liao, and Y . Liu, ‚ÄúSmartlog: Place error
log statement by deep understanding of log intention,‚Äù in 2018 IEEE
25th International Conference on Software Analysis, Evolution and
Reengineering (SANER) , March 2018, pp. 61‚Äì71.
[31] F. Ebert, F. Castor, and A. Serebrenik, ‚ÄúAn exploratory study on
exception handling bugs in java programs,‚Äù Journal of Systems
and Software , vol. 106, pp. 82 ‚Äì 101, 2015. [Online]. Available:
http://www.sciencedirect.com/science/article/pii/S0164121215000862
[32] J. Oliveira, D. Borges, T. Silva, N. Cacho, and F. Castor, ‚ÄúDo
android developers neglect error handling? a maintenance-centric
study on the relationship between android abstractions and uncaught
exceptions,‚Äù Journal of Systems and Software , vol. 136, pp. 1 ‚Äì 18,
2018. [Online]. Available: http://www.sciencedirect.com/science/article/
pii/S0164121217302558
[33] F. C. Filho, N. Cacho, E. Figueiredo, R. Maranh Àúao, A. Garcia, and
C. M. F. Rubira, ‚ÄúExceptions and aspects: the devil is in the details,‚Äù
inProceedings of the 14th ACM SIGSOFT International Symposium
on F oundations of Software Engineering, SIGSOFT‚Äô06/FSE-14 .A C M
New York, NY , USA, 2006, pp. 152‚Äì162.
[34] E. A. Barbosa and A. Garcia, ‚ÄúGlobal-aware recommendations for
repairing violations in exception handling,‚Äù in Proceedings of the 40th
International Conference on Software Engineering , ser. ICSE ‚Äô18.
New York, NY , USA: ACM, 2018, pp. 858‚Äì858. [Online]. Available:
http://doi.acm.org/10.1145/3180155.3182539
[35] T. Gu, C. Sun, X. Ma, J. L, and Z. Su, ‚ÄúAutomatic runtime recovery
via error handler synthesis,‚Äù in 2016 31st IEEE/ACM International
Conference on Automated Software Engineering (ASE) , Sep. 2016, pp.
684‚Äì695.
[36] X. Mao, Y . Lei, Z. Dai, Y . Qi, and C. Wang, ‚ÄúSlice-based statistical
fault localization,‚Äù J. Syst. Softw. , vol. 89, no. C, pp. 51‚Äì62, Mar. 2014.
[Online]. Available: http://dx.doi.org/10.1016/j.jss.2013.08.031
[37] Y . Lei, C. Sun, X. Mao, and Z. Su, ‚ÄúHow test suites impact fault
localisation starting from the size,‚Äù IET Software , vol. 12, no. 3, pp.
190‚Äì205, 2018.
[38] W. Weimer and G. C. Necula, ‚ÄúExceptional situations and program
reliability,‚Äù ACM Trans. Program. Lang. Syst. , vol. 30, no. 2, pp.
8:1‚Äì8:51, Mar. 2008. [Online]. Available: http://doi.acm.org/10.1145/
1330017.1330019
[39] W. Weimer and G. C. Necula, ‚ÄúFinding and preventing run-time
error handling mistakes,‚Äù in Proceedings of the 19th Annual ACM
SIGPLAN Conference on Object-oriented Programming, Systems,
Languages, and Applications , ser. OOPSLA ‚Äô04. New York,
NY , USA: ACM, 2004, pp. 419‚Äì431. [Online]. Available: http:
//doi.acm.org/10.1145/1028976.1029011
[40] Z. Jia, S. Li, T. Yu, X. Liao, and J. Wang, ‚ÄúAutomatically detecting
missing cleanup for ungraceful exits,‚Äù in Proceedings of the 2019 27th
ACM Joint Meeting on European Software Engineering Conference
and Symposium on the F oundations of Software Engineering , ser.
ESEC/FSE 2019. New York, NY , USA: ACM, 2019, pp. 751‚Äì762.
[Online]. Available: http://doi.acm.org/10.1145/3338906.3338938
[41] D. DeFreez, A. V . Thakur, and C. Rubio-Gonz ¬¥alez, ‚ÄúPath-based
function embedding and its application to error-handling speciÔ¨Åcation
mining,‚Äù in Proceedings of the 2018 26th ACM Joint Meeting on
European Software Engineering Conference and Symposium on the
F oundations of Software Engineering , ser. ESEC/FSE 2018. New
York, NY , USA: ACM, 2018, pp. 423‚Äì433. [Online]. Available:
http://doi.acm.org/10.1145/3236024.3236059
[42] M. Bruntink, A. van Deursen, and T. Tourw ¬¥e, ‚ÄúDiscovering faults
in idiom-based exception handling,‚Äù in Proceedings of the 28th
International Conference on Software Engineering , ser. ICSE ‚Äô06.
224
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. New York, NY , USA: ACM, 2006, pp. 242‚Äì251. [Online]. Available:
http://doi.acm.org/10.1145/1134285.1134320
[43] H. A. Nguyen, R. Dyer, T. N. Nguyen, and H. Rajan, ‚ÄúMining
preconditions of apis in large-scale code corpus,‚Äù in Proceedings of
the 22Nd ACM SIGSOFT International Symposium on F oundations of
Software Engineering , ser. FSE 2014. New York, NY , USA: ACM,
2014, pp. 166‚Äì177. [Online]. Available: http://doi.acm.org/10.1145/
2635868.2635924
[44] H. Zhong, L. Zhang, T. Xie, and H. Mei, ‚ÄúInferring resource
speciÔ¨Åcations from natural language api documentation,‚Äù in Proceedings
of the 2009 IEEE/ACM International Conference on Automated
Software Engineering , ser. ASE ‚Äô09. Washington, DC, USA:
IEEE Computer Society, 2009, pp. 307‚Äì318. [Online]. Available:
http://dx.doi.org/10.1109/ASE.2009.94
[45] L. Tan, D. Yuan, G. Krishna, and Y . Zhou, ‚Äú/*icomment: Bugs
or bad comments?*/,‚Äù in Proceedings of Twenty-Ô¨Årst ACM SIGOPS
Symposium on Operating Systems Principles , ser. SOSP ‚Äô07. NewYork, NY , USA: ACM, 2007, pp. 145‚Äì158. [Online]. Available:
http://doi.acm.org/10.1145/1294261.1294276
[46] M. Acharya, T. Xie, J. Pei, and J. Xu, ‚ÄúMining api patterns as partial
orders from source code: From usage scenarios to speciÔ¨Åcations,‚Äù
in Proceedings of the the 6th Joint Meeting of the European
Software Engineering Conference and the ACM SIGSOFT Symposium
on The F oundations of Software Engineering , ser. ESEC-FSE ‚Äô07.
New York, NY , USA: ACM, 2007, pp. 25‚Äì34. [Online]. Available:
http://doi.acm.org/10.1145/1287624.1287630
[47] D. Engler, D. Y . Chen, S. Hallem, A. Chou, and B. Chelf,
‚ÄúBugs as deviant behavior: A general approach to inferring
errors in systems code,‚Äù in Proceedings of the Eighteenth ACM
Symposium on Operating Systems Principles , ser. SOSP ‚Äô01. New
York, NY , USA: ACM, 2001, pp. 57‚Äì72. [Online]. Available:
http://doi.acm.org/10.1145/502034.502041
225
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:48:24 UTC from IEEE Xplore.  Restrictions apply. 