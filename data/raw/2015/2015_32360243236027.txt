TheImpact ofRegularExpression DenialofService(ReDoS) in
Practice: An Empirical Study at the EcosystemScale
James C. Davis
VirginiaTech,USA
davisjam@vt.eduChristyA.Coghlan∗
VirginiaTech,USA
ccogs@vt.edu
FranciscoServant
VirginiaTech,USA
fservant@vt.eduDongyoonLee
VirginiaTech,USA
dongyoon@vt.edu
ABSTRACT
Regularexpressions(regexes)areapopularandpowerfulmeans
of automatically manipulating text. Regexes are also an understud-
ied denial of service vector (ReDoS). If a regex has super-linear
worst-case complexity, an attacker may be able to trigger this com-
plexity,exhaustingthevictim’sCPUresourcesandcausingdenial
ofservice.Existing researchhas shown how to detect thesesuper-
linear regexes, and practitioners have identified super-linear regex
anti-patternheuristics that mayleadto such complexity.
Inthispaper,weempiricallystudythreemajoraspectsofReDoS
thathavehithertobeenunexplored:theincidenceofsuper-linear
regexesinpractice,howtheycanbeprevented,andhowtheycanbe
repaired.Intheecosystemsoftwoofthemostpopularprogramming
languages Ð JavaScript and Python ś we detected thousands of
super-linearregexesaffectingover10,000modulesacrossdiverse
application domains. We also found that the conventional wisdom
for super-linear regex anti-patterns has few false negatives but
many false positives; these anti-patterns appear to be necessary,
butnotsufficient,signalsofsuper-linearbehavior.Finally,wefound
thatwhenfacedwithasuper-linearregex,developersfavorrevising
itovertruncatinginputordevelopingacustomparser, regardless
ofwhethertheyhadbeenshownexamplesofallthreefixstrategies.
ThesefindingsmotivatefurtherresearchintoReDoS,sincemany
modulesarevulnerabletoitandexistingmechanismstoavoidit
are insufficient. We believe that ReDoSvulnerabilities are a larger
threatinpracticethanmighthave been guessed.
łSome people, when confronted with a problem, think ‘I know, I’ll
use regularexpressions.’Now theyhavetwo problems.ž
śJamieZawinski
CCS CONCEPTS
·Softwareanditsengineering →Empiricalsoftwarevalida-
tion;Software libraries and repositories ;·Security and privacy
→Denial-of-service attacks ;
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
https://doi.org/10.1145/3236024.3236027KEYWORDS
Regular expressions,ReDoS, catastrophicbacktracking,empirical
software engineering,miningsoftware repositories
ACMReference Format:
James C. Davis, Christy A. Coghlan, Francisco Servant, and Dongyoon
Lee.2018.TheImpactofRegularExpressionDenialofService(ReDoS)in
Practice:AnEmpiricalStudyat theEcosystemScale.In Proceedingsofthe
26th ACM Joint European Software Engineering Conference and Symposium
on the Foundations of Software Engineering (ESEC/FSE ’18), November 4ś
9, 2018, Lake Buena Vista, FL, USA. ACM, New York, NY, USA, 11pages.
https://doi.org/10.1145/3236024.3236027
1 INTRODUCTION
Regularexpressions(regexes)areapopularandpowerfulmeansof
automatically manipulating text. They have been applied in a large
variety of application domains, e.g.,data validation, data scraping,
andsyntaxhighlighting[ 54],andareastandardtopicinpractical
programming texts[ 16,28,39].
Unfortunately,inmostpopularprogramminglanguages,regexes
also form an understudied denial of service vector: regular expres-
siondenialofservice(ReDoS)[ 23,24].Forexample,in2016ReDoS
led to an outage at StackOverflow [ 27] and rendered vulnerable
any websites built with the popular Express.js framework [ 17].
ReDoS attacks are possible because many popular languages, in-
cluding JavaScript-V8 (Node.js), Python, Java, C++-11, C#-Mono,
PHP, Perl, and Ruby, rely on a regex engine with worst-case super-
linearbehavior (SLbehavior).Whentheseregexenginesevaluate
super-linear regexes (SL regexes) against malign input , the evalu-
ation takes polynomial or exponential time in the length of the
input,andthehigh-complexityevaluationoverloadstheserverand
denies service to otherclients.
ReDoS attacks were first proposed by Crosby in 2003 [ 23]. In
the 15 years since then we have seen advances in detecting SL
regexes[34,37,38,47,51,55]aswellastheintroductionoflanguage-
level [3] and engine-level [ 11,14] defenses against SL behavior.
Others have provided conventional wisdom about SL regex anti-
patterns,i.e.,heuristicstoidentifyformsofaregexthatareexpected
tobeparticularlyrisky[ 30,32,33].Missing,however,isanempirical
assessmentoftheincidenceofSLregexesinpractice.Simplyput,
we do not know whether ReDoS is a parlour trick or a security
vulnerabilitycommon enough to meritfurther research.
*Christy A. Coghlan isnowemployed by Google, Inc.
246
ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA J.C.Davis,C.A.Coghlan,F.Servant, andD.Lee
In this paper, we perform the first large-scale empirical study
to understand the extent of SL regexes in practice as well as the
mechanisms that could be used to identify and repair them. We
analyzetheecosystemsoftwoofthemostpopularprogramming
languages to understand the incidence of SL regexes. Our study
coverstheNode.js(JavaScript)andPythoncorelibraries,aswell
as 448,402 (over 50%) of the modules in the npm[12] andpypi[13]
moduleregistries.WealsostudyreportsofReDoSintheseregistries
to understandthe fixes that developers providefor SL regexes.
We found that SL regexes are rather common: they appear in
the core Node.js and Python libraries as well as in thousands of
modules in the npm and pypi registries, including popular mod-
uleswithmillionsofdownloadspermonth.Wefoundover4,000
uniqueSLregexesacrossnpmandpypi,coveringawiderangeof
application domains. Furthermore, nearly 300 of these regexes are
high-risk because they have exponential complexity. We disclosed
tomaintainersthepresenceofSLregexesin284modules,ofwhich
48 have been repaired so far. We found that developers repair SL
regexesusingoneofthreetechniques:trimmingtheinput,revis-
ing the regex, or replacing it with alternate logic. Among these
techniques, revising the regex was the most common, regardless of
whether developers were previously aware ofthe others.
This paper providesthe following contributions:
•We provide an empirical understanding of the extent (ğ 4.1), seri-
ousness (ğ 4.2), and distribution across application domains (ğ 4.3)
oftheincidenceofSLregexesintwoprominentsoftwareecosys-
temsÐNode.js andPython.
•We provide an empirical understanding of the effectiveness of
the conventional wisdom regarding SL regex anti-patterns (ğ 5.1).
•We provide an empirical understanding of the strategies that
developers use to fixSL regexes(ğ 6).
2 BACKGROUND
In this section, we review the behavior of SL regexes, their applica-
tionto ReDoS,andexisting techniques to addressthem.
2.1 Super-Linear (SL)RegexEngines
Regex enginesaccept a regexdescribinga language,andan input
tobetestedformembershipinthislanguage.Atthecoreofmost
regexenginesisabacktracking-basedsearchalgorithmliketheone
describedbySpencer[ 44].Abacktrackingregexengine constructs
a non-deterministic finite automaton (NFA) from the regex and
thensimulatestheNFAontheinput[ 42].ThestateoftheNFAis
represented by a 2-tuple: its current vertex in the graph, and its
currentoffsetintheinput.Tosimulatenon-determinism,whenever
theenginemakesachoiceitpushesthecurrentNFAstateontoa
stackofdecisionpoints.Ifamismatchoccurs,theenginebacktracks
to a previous decision point to try another choice. This process
continues until the engine finds a match or exhausts the set of
decisionpoints.SinceeachstepofanNFAevaluationtakesconstant
time,thecomplexityofanevaluationcorrespondstothenumber
ofstates that are explored.
A backtracking regex engine may have large worst-case com-
plexityifitdoesnottakecaretoavoidredundantstateexploration1.
1SLfeatureslikebackreferencesareanothersourceofSLworst-casecomplexity.SL
behavioras a result of these featuresis out of the scopeof thiswork.
(a)Railroaddiagram [ 4].<WS -2, O-1>
1path
N-1 states below
<WS -2, O-2>
1 + 1 paths
N-2 states below<WS-1, O-1>
<WS -1, O-2>
<WS -2, O-3>
1 + 2 paths
N-3 states below<WS -1, O-3>
(b) NFA execution diagram (ex-
cerpt).
Figure 1:Diagramsfor/\s*#?\s*$/ on maligninput.
To illustrate, suppose that two choices from a decision point reach
thesameNFAstate.Sincefromthisstateafixedsetofstateswill
be explored, this mutual state need be explored only once [ 31].
However,ifnomatchisfoundthenanincautiousenginewillex-
ploreittwice,oncefromeachpathfromthedecisionpointtothe
mutual state. In the extreme, this canlead to super-linear behavior
(SLbehavior)whentheevaluationcomplexity, i.e.,thetotalnumber
of explored states, is polynomial or exponential in the input length.
SL behaviorisalsoknownas catastrophic backtracking.
SLbehaviorwillonlyoccurwhenabacktrackingregexengine
evaluates an SL regexonamalign input .Amaligninput hasthree
components:aprefixstring,apumpstring,andasuffixstring2.The
prefixbringstheNFAtoasetofstatesfromwhichredundantexplo-
ration becomes possible ( ambiguous states [18]). Each repetition of
thepumpyields a decision point whose complete exploration con-
tainsredundantstates.Afinal suffixensuresthattheregexwillnot
matchthe input, forcing the regexengine to explore polynomially
orexponentially manyredundant states duringbacktracking.
2.2 Example:AnSLRegexin Python Core
For a detailed example of an SL regex, consider the regex repre-
sented in Figure 1a. We discovered this regex in the Python core
librarydifflib(CVE-2018-1061).Maligninputforthisregexcon-
sists of: the empty prefix, a pump of łany whitespacež, and a suffix
ofłany non-whitespacež.
Onthis maligninput, abacktracking regexengine willperform
anO(n2)doubly-nested traversal of the input [ 51], as illustrated
inFigure 1b.WheninthefirstwhitespacevertexWS-1,eachofthe
Npumpsisadecisionpoint:theNFAchooseswhethertoremainor
to advance to the second whitespace vertex WS-2 by skipping the
optional‘#’vertex.Whenthesuffixcausesamismatch,theregex
engine tries the other choice. As a result, the NFA will reach the
WS-2 vertex Ntimes,and each move willoccur ata different NFA
state (same vertex, different offset). When the NFA advances at
offseti>1, it willredundantly explore states <WS-2, O- i>through
<WS-2, O- N>since these are also explored after the NFA advances
at earlier offsets. Thus the engine will visit each of the <WS-1, O- i>
statesonce,andeachofthe <WS-2,O- j>statesjtimes,foratotal
of(N) +(1+2+...+ N) =O(N2)visitedstates.
2.3 UsingSLBehavior forReDoS
Backtracking regex engines can be used as a denial of service vec-
tor. Regular expression denial of service (ReDoS) attacks use an SL
2Malign input maycontainmultiple pairs of prefixes and pumps.
247The ImpactofReDoSin Practice ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
regexquerytoconsumetheCPUofaserver,reducingthenumberof
clientsitcanservice[ 23,40].ReDoSattackshavefourrequirements.
First, the victim must use a backtracking regex engine. Second,
thevictimmustuseanSLregex. Third,thevictimmustevaluate
(malign) user input against this regex without any resource lim-
itations (e.g.,a timeout). Fourth, the victim must be running on
the server-side. If all four conditions are met, an attacker carries
out a ReDoS exploit by sending malign input to the victim to be
evaluatedagainstitsSLregex,triggeringSLbehaviorthatwastes
server resources,reducing the CPUavailable to otherclients.
2.4 Mechanisms to PreventSLBehavior
The practitioner community has explored three approaches to pre-
venting SL behavior: abortive backtracking, disallowing backtrack-
ingaltogether,andavoidingSL regex anti-patterns.
Abortive Backtracking. Somemainstreamlanguagesdefendde-
velopers against SL regex engine behavior. The .NET framework
addedoptionalregextimeoutsin2012[ 3,53],andthePHPandPerl
enginesthrowexceptions if they perceive toomuchbacktracking.
Non-backtracking engines. A more radical approach is to use
thelinear-timeregexevaluationalgorithmdevelopedbyThomp-
son[48],thoughthisrequiresdeviatingfromthePerl-Compatible
Regularexpressions(PCRE)standardsupportedbymanylanguages3.
Thisapproach waspopularizedbyCoxin2007[ 22]andhas since
been adoptedbyRust [ 14]andGo [ 11].
Avoidinganti-patterns. Severaloftheprofessionalreferencetexts
on regexes suggest łSL regex anti-patternsž: developers should
avoid nested quantifiers (łstar heightž) [ 30,32], and more gener-
allyshouldłwatchoutwhen...[different]partsofthe[regex]can
match the same textž [ 33]. Although this advice is vague, avoid-
ing SL regexes is the only cross-language technique available to
practitioners. Timeouts and linear-time engines are luxuries not
availableeverywhere,sopractitionersmustbereadytoaddressthe
worst-case behaviorofthe regexesintheircodebases.
3 RESEARCH QUESTIONS
Our goal in this study is to understand ReDoS vulnerabilities in
practice across three themes: their incidence in practice, how they
canbeprevented,andhowtheycanbefixed.Inparticular,wefocus
ourinvestigationonstudyingSLregexes,whichcanbeexploitedto
cause ReDoS. We ask seven research questions along these themes.
First, we study the incidence of SL regexes in practice to under-
standtowhatextentReDoSisaseriousvulnerabilityaffectingmany
differentkindsofsoftwareprojects.Theanswertothisinvestigation
willhelpusunderstandthe importanceofReDoSvulnerabilities.
Second, we study whether SL regex anti-patterns do in fact
signal SL regexes. As we discussed in ğ 2.4, avoiding SL regex anti-
patterns is the only cross-language mechanism used in practice to
prevent ReDoS, but this approach is not yet evidence-based. In this
investigation we checkthe validity ofthis conventional wisdom.
Third,westudyhowReDoSvulnerabilitiesarefixedinpractice.
AlackofunderstandingoftherightstrategiestofixSLregexesisa
seriousgapintheresearchliterature.Webridgethisgapbystudying
3Inparticular,alinear-timeengineprecludesgeneralsupportforfundamentallysuper-
linearfeatureslike backreferences and lookaround assertions.howdevelopersarefixingReDoSvulnerabilitiesinpractice.This
empiricalunderstandingwillallowotherdeveloperstoreusethe
wisdomoftheexpertsthatarealreadyfixingReDoSvulnerabilities.
Theme1: UnderstandingtheincidenceofReDoSinpractice.
RQ1:Howprevalentare SL regexesinpractice?
RQ2:Howstrongly vulnerable are the SL regexes?
RQ3:Whichapplicationdomainsdo SL regexesaffect?
Theme2: PreventingReDoS.
RQ4:DoSL regex anti-patternssignal SL regexes?
Theme3: Fixing ReDoS.
RQ5:Howhave developers fixedReDoSvulnerabilities?
RQ6:HowwoulddevelopersfixReDoSvulnerabilitiesiftheyknew
allofthe currently-appliedapproaches?
RQ7:Howeffective are the fixes that developers adopt?
4 THEME1: UNDERSTANDINGTHE
INCIDENCEOFREDOSINPRACTICE
4.1 RQ1: HowPrevalent areSLRegexesin
Practice?
To date there have been a small number of reports of SL regexes
leadingtoReDoSinthewild,whichwediscussindepthinğ 6.How
many more remain undiscovered? In this section we present the
firstsystematic study ofthe incidence of SL regexesinpractice.
4.1.1 Methodology. Inbrief,thisishow wemeasuredtheinci-
denceofSLregexesinthewild.Weusedstaticanalysistoextract
all the regexes used in the Node.js and Python core libraries as
well as more thanhalf of the modules in the npm (JavaScript) and
pypi (Python) registries. We applied SL regex detectors to filter for
potentially-SLregexes,andconcludedwithadynamicvalidation
phaseto prove that aregex wasactually vulnerable.
Software. Wechose JavaScript asourprimarylanguageofinterest
for two reasons. First, as others have observed [ 21,25,36], Re-
DoSvulnerabilities inJavaScript are particularly impactful because
JavaScript frameworks use a single-threaded event-based archi-
tecture.AReDoSattackonaNode.jsserverimmediatelyreduces
the throughput to zero. Second, JavaScript has a huge developer
base Ð there are more open-source libraries for JavaScript than
any otherlanguage. The registryof JavaScriptmodules, npm[12],
has over 590,000 modules [ 26], more than double the size of the
next-closestregistry(Java/Maven).Togaugethegenerality ofour
results,wealsostudied Python,anotherpopularscriptinglanguage
whosepypi[13]registry contains 130,000 modules.
The source code in software ecosystems can be divided into the
languagecore(łplatformž),3rd-partylibraries,andapplications[ 35].
Whileapplicationsaredifficulttoenumerate,inmodernecosystems
thelanguagecoreand3rd-partylibrariesaregenerallyopen-source,
and3rd-partylibrariesareconvenientlyorganizedinaregistrythat
tracksmetadatalikewhere tofindthemodule’s sourcecode. As a
result,westudiedtheincidenceofSLregexesineachlanguage’s
core libraries and3rd-partymoduleslistedinthe registries.
For each language’s core, we tested each supported version. For
3rd-partylibraries,weexaminedthemasterbranchofeverymodule
listedinthenpmandpypiregistriesthathadaURLonwhichwe
could run git clone . We chose not to use the packaged version of
248ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA J.C.Davis,C.A.Coghlan,F.Servant, andD.Lee
modules provided by the registries because these are sometimes
packed, minified, or otherwise obfuscated in ways that complicate
analysis,attribution,andvulnerabilityreporting.
Extractingregexes. Aftercloningeachmodule,westaticallyex-
tracted its regexes. We cloned the latest master branch, with no
historytominimizetheimpactontheVCShostingservice.Then
we scanned it for source code based on file extensions ( .jsor.py).
We built an abstract syntax tree (AST) from each source file, using
babylon[6] for JavaScript files and the Python AST API for Python
files. Walking the ASTs, we identified every regex declaration and
extractedthepattern,skippinganyusesofdynamicpatterns.Ex-
cluding these dynamic patterns means our results provide lower
bounds onthe number ofSL regexes.
IdentifyingSLregexes. Afterextractingtheregexesusedineach
moduleunderstudy,wecreatedamappingfromuniquepatternsto
the modulesusing them.We then analyzedtheseunique patterns.
Our SL regex identification process has a static detection phase
andadynamic validationphase.Forthe static detection phase,we
queried all three of the SL regex detectors developed in previous
work:rxxr2[38],regex-static-analysis [51],andrexploiter [55].
These detectors use different algorithms to report whether or not a
regex may exhibit super-linear behavior, and if so will recommend
malign input to trigger it. Our static phase collects each detector’s
opinionand producesasummary. Thedetectors,mostfrequently
regex-static-analysis ,mayconsumeexcessivetimeormemoryin
makingtheirdecision,sowelimitedthedetectorsto5minutesand
1GBofmemoryoneachregexanddiscardedunansweredqueries.
TheseSL regexdetectorsare researchprototypes,so theydonot
support allregex features norguarantee correctness.
Our dynamic validation phase uses this summary to test the
accuracyofeachdetector’spredictionfortheregexengineofthe
languageofinterest.Thedetectorsfollowdifferentalgorithmsbased
on assumptions about the implementation of the regex engine, and
theseassumptionsmayormaynotholdineachlanguageofinterest.
To validate a detector’s predicted malign input, our validator tests
this malign input on the possibly-SL regex in small Node.js and
Pythonapplicationswe created.
Thisishowweidentified SLregexes .Topermitdifferentiating
regexesbytheirdegreeofvulnerability(ğ 4.2),wemeasuredhow
long each regex took to match a sequence of malign inputs with
varyingnumbersofpumps.Webeganwithonepumpandfollowed
ageometricsequencewithafactorof1.1,roundingup.Wetested
100inputs,thelastwith85,615pumps,andmarkedtheregexsuper-
linear if the regex match took more than 10 seconds on a match,
as this is far longer than a linear-time regex match would take.
We stopped at 85,615 pumps for two reasons. First, this number
wassufficienttocausesuper-linearcomplexitytomanifestwithout
beingattributabletotheoverheadsofenormousstrings.Second,this
manypumpsresultsinmaligninputs100K-1Mcharacterslong,long
enoughtobecomepotentiallyexpensiveforattackerstoexploit.We
distributed this analysis and ran multiple tests on each machine in
parallel,dedicatingonecoretoeachtestwith taskset[1]toremove
computationalinterference between co-locatedtests.Table1:ResultsofoursearchforSLregexesinthenpmand
pypi module registries. Troublingly, 1% of unique regexes
were SL regexes,affecting over10,000 modules.
Registry Total
ModulesScanned
ModulesUnique
RegexesSL
RegexesAffected
Modules
npm 565,219 375,652
(66%)349,852 3,589
(1%)13,018
(3%)
pypi 126,304 72,750
(58%)63,352 704
(1%)705
(1%)
4.1.2 Results. WefoundthatSLregexesaresurprisinglycom-
mon inpractice. The Node.js and Python core libraries bothcon-
tained SL regexes, and about 1% of all unique regexes in both npm
andpypiwereSLregexes.Inall,3%ofnpmmodulesand1%ofpypi
modulescontainedat leastone SL regex.
Language Core. We found one SL regex in the core libraries of
Node.js(server-sideJavaScript).Thecurrentlysupportedversions
of Node.js are v4, v6, v8, and v9. We scanned the core libraries
(lib/)ofeachoftheseversions.Inv4weidentifiedanddisclosed
two SL regexes used to parse UNIX and Windows file paths. These
regexes had been removed for performance reasons in v6 so the
other versions of Node were not affected. This vulnerability was
publishedas CVE-2018-7158 andfixedbythe Node.js core team.
WefoundthreeSLregexesinthecorelibrariesofPython.The
currently supported versions of Python are v2 and v3. We scanned
the core libraries ( Libs/)ofeach oftheseversions. Bothversions
shared two SL regexes, one in popliband one in difflib. We iden-
tified an additional vulnerability in the v2.7.14 fpformat library.
ThesevulnerabilitieswerepublishedasCVE-2018-1060andCVE-
2018-1061; we authoredthe patches.
Third-party modules. Table1summarizes the results of our reg-
istry analysis. We were able to clone 66% of npm (375,652 modules)
and58%ofpypi(72,750modules).Inthissampleofeachregistrywe
foundthatabout1% ofthe uniqueregexeswereSLregexes(3,589
innpm,and704inpypi).
Figure2summarizes two different distributions in the npm and
pypidatasetsusingCumulativeDistributionFunctions(CDFs).The
dotted lines show the distribution of the number of unique regexes
ineachmodule.Wecanseethatmorethan30%ofnpmandpypi
modules use at least one regex, and that npm modules tend to con-
tain more unique regexes than pypi modules do. The solid lines
show the distribution of the number of modules each SL regex
appears in: in the npm registry some SL regexes appear in hun-
dreds or thousands of modules, while in the pypi registry the most
ubiquitous SL regexesare only usedinabout50 modules.
To give a sense of how impactful these SL regexes might be, for
eachmoduleweobtainedthepopularity(registrydownloads/month)
andcomputedtheprojectsizebasedonthesourcefileswescanned
(usingcloc[9]). Modules with SL regexes are indicated in black
in Figure 3(npm) and Figure 4(pypi). In both registries, larger
modules are more likely to contain SL regexes, and SL regexes are
slightly more common inmoduleswithlower download rates.
249The ImpactofReDoSin Practice ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
Figure2:ThisfigureshowstwoCDFs.Thedottedlinesindi-
cate the distribution of the number of unique regexes used
in modules, while the solid lines show the distribution of
the number of modules affected by SL regexes. Note the log
scaleon thex-axis.
Figure3:npmmodulesbysizeandpopularity(log-log).The
13,018moduleswithSLregexesareinblack.Notethełtrivial
packagesž on theleft side [ 15].
Figure4:pypimodulesbysizeandpopularity(log-log).The
705 moduleswith SL regexes are inblack.
4.2 RQ2: HowStrongly Vulnerable aretheSL
Regexes?
From a developer perspective,SL regexeswhose super-linear be-
haviormanifestsonshortermaligninputsareofgreaterconcern
thanthoseonlyaffectedbylongermaligninputs.Longermalign
inputs could be prevented by other parts of the software stack ( e.g.,Table 2: This table shows the degree of vulnerabilities in
the npm and pypi datasets. The polynomial vulnerabilities
are further broken down by the degree of the polynomial,
b, which we rounded to the nearest integer. This excluded
someregexeswhosepolynomialdegreeroundeddownto1.
Degree of vulnera-
bilitynpm (3,589vulns) pypi(704 vulns)
Exponential O(2n)245(7%) 41 (6%)
Polynomial O(n2)2,638 (74%) 534(76%)
Polynomial O(n3)535(15%) 107(15%)
Polynomial O(n4)44 (1%) 5(1%)
Polynomial O(nb>4)100(3%) 15 (2%)
limitsonHTTPheaders),whileshortmaligninputsmayonlybe
preventedbymodificationsto the vulnerable software itself.
In thissectionwe refineour definition ofSL regexes, differenti-
ating between exponential andpolynomial vulnerabilities.
4.2.1 Methodology. WhilethedegreeofvulnerabilityofanSL
regexmight be predictedbystaticanalysis,weare notconfident
of the accuracy of such a prediction since it is not tied to a par-
ticularregexengineimplementation.Thus,weusedcurvefitting
to differentiate between exponential and polynomial SL regexes.
Asdiscussedinğ 4.1,ourdynamicvalidationstepteststhematch
time of the appropriate regex engine (JavaScript-V8 or Python) on
a sequence of malign inputs with a geometrically increasing num-
berofpumps. We measuredthetimethat it took tocomputeeach
match.Wethenfitthetimetakenfordifferentnumbersofpumps
against both exponential ( f(x)=abx) and polynomial (power-law:
f(x)=axb)curvesandwechosethecurvethatprovidedthebetter
fit byr2value. When the malign inputs from the different SL regex
detectorsresultedindifferentcurves,weusedthesteepest,dead-
liest curve. As in ğ 4.1.1, we distributed the work across multiple
machines. As result, the multiplicative factors of the curves ( a) are
not comparable,but the basesorexponents( b) are.
Thisanalysisallowsustocreateahierarchyofvulnerabilities.
Exponential SL regexes are more vulnerable than polynomial SL
regexes, because the number of pumps (length of malign input)
requiredtoachievenoticeabledelaysissmaller.Forthesamereason,
among polynomial SL regexes, those with larger bvalues are more
vulnerable than those with smaller bvalues. The curve type and
thebvalues influence the degree of vulnerability more strongly
thantheavalues.
4.2.2 Results. A breakdown of the regexes by their degree of
vulnerability is in Table 2. Exponential SL regexes were rare in
both registries: only 7% of the SL regexes from npm and 6% of
thosefrompypiwereexponential.ThemajorityoftheSLregexes
in both registries were polynomial, tending to O(n2)andO(n3).
ThisfindinghasimplicationsforSLregexdetectorsaswellasfor
software developers.
For detecting SL regexes. Therxxr2REDOS [ 38] detector only
looksforexponentialSLregexes.SotoodotwooftheSLregexanti-
patterns of conventional wisdom, Star Height and QAD (discussed
inğ5.1).TheseapproachestodetectingSLregexeswillthusmiss
about90%ofSL regexes.
250ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA J.C.Davis,C.A.Coghlan,F.Servant, andD.Lee
Table 3: Proposed common semantic meanings for regexes.
The examples are automatically-labeled (SL) regexes from
our npm dataset. The last two columns are the number of
regexeslabeledwitheachsemanticmeaninginournpmand
pypidatasets.
Meaning Example npm pypi
Errormessages /no such file '.+[/\\](.+)'/ 22,197 881
File names* /[a-zA-Z-0-9_\/-]+\.json/ 10,151 497
HTML /href="(.+\.css)(\?v=.+?)?"/ 8,786 2,504
URL* /^.+:\/\/[^\n\\]+$/ 6,986 2,048
Naming convention /^[$_a-z]+[$_a-z0-9-]*$/ 4,096 1,056
Source code /function.*?\(.*?\)\s*\{\s*/ 3,941 105
User-agentstrings* /Chrome\/([\w\W]*?)\./ 3,135 124
Whitespace* /(\n\s*)+$/ 2,016 441
Number* /^(\d+|(\d*\.\d+))+$/ 762 238
Email* /^\S+@\S+\.\w+$/ 444 97
Classificationrate Ð 18% 13%
Forworkingwithregexes. Thesuper-linearbehaviorofpolyno-
mialregexestypicallymanifestsformaligninputsontheorderof
manyhundredsorthousandsofcharacterslong.Suchstringsare
oftenlongerthananylegitimatestrings,asisthecaseforstrings
withmany ofthe semantic meanings listedin Table 3(ğ4.3). Thus,
rejectingtoo-longstringsbeforetestingthemagainstaregexwould
beacheapandeffectivedefenseapproachandshouldbeconsidered
as abestpracticewhen writing regexes.
4.3 RQ3: Which ApplicationDomains do SL
RegexesAffect?
Regexesareusedinavarietyofapplicationdomains.Fromourown
experienceinwritingregexes,andfromamanualanalysisof400
regexusesinnpmmodules,wepositthatdevelopersoftenwrite
regexes with one of the semantic meanings listed in Table 3. These
semanticmeaningsmaybeofinterestinsomeapplicationdomains
but not others. For example, we imagine that identifying source
codeornamingconventionsisthedomainoflintersandcompilers,
thatwebserversaremoreinterestedinidentifyingHTMLanduser-
agentstrings,andthatserversorscriptsmaybepreparedtochange
theirbehaviorbasedonthe errormessagesthat they encounter.
4.3.1 Methodology. In this section, we describe our techniques
toautomaticallycategorizeregexesintothesesemanticgroups.We
began by manually labeling the semantic meaning of 400 regex
usage examples based on inspection of the regex itself as well as
howitwasusedintheproject(s)inwhichwefoundit.Although
someoftheregexesweencounteredwereobscureandtheirpurpose
couldonlybeidentifiedbylookingforcommentsandotherclues
in the surrounding source code, it became clear to us that many
regexes with the semantic meanings listed in Table 3could be
automatically classified. There were 200 unique regexes among
these400examples,andwefoundthattheduplicatedregexeswere
always used with the same semantic meaning in different modules.
We developed an automatic labeling scheme that uses a com-
binationofparsingandłmeta-regexesžtolabelregexesbasedon
the proposed semantic meanings. For example, here is a simplified
versionofourmeta-regextolabelregexesasdescribingwhitespace:/^\^?(\\s|\\n|\\t| |[\|\*\+\[\]\(\)]|)+\$?$/
Thissimplifiedregexlooksforastring(regexpattern)containing
only whitespace characters, as well as meta-characters that might
be used to anchor the pattern (‘ˆ’ and ‘$’) or to encode varying
quantitiesofwhitespace (‘+’,‘*’,etc.).
We iteratively improved our regex labeler. In each iteration, we
labeledarandomlyselectedsubsetof10,000-30,000regexesfrom
our npm regex dataset. We manually examined 100 of the regexes
assignedtoeachsemanticmeaning.Oneormorerepresentativesof
anymis-labeledregexeswereaddedtoatestsuite,andtheiteration
was complete once the regex labeler correctly identified all the
regexesinthe suite.
Thisprocessresultedinapreciseregexlabelerforregexesthat
are reasonably specific. As you might expect based on how we
derived it, our labeler works well for łeasy to classifyž regexes that
restrict the inputto something close to the expectedlanguage.
Werefinedourlabelerthrough17iterations.Attheconclusion
ofthisprocessourtestsuitecontained358regexes,andwewere
reasonably confident in its precision. We then applied it to our
npm and pypi datasets. Irrespective of whether our list of semantic
meaningsforregexesiscomplete,itservesthegoalofstudyinghow
differentdomainsmaybeaffectedbyReDoS. Weleavethesearch
for acomplete listofregex semantic meaningsto future work.
4.3.2 Results. First,assummarizedinTable 3,wefoundregexes
inallofthesedomainsinbothnpmandpypi.Second,somesemantic
meanings are more prone to being expressed with SL regexes than
others.AscanbeseeninFigure 5,developersshouldbecautious
whenwritingregexesforemails,user-agentstrings,sourcecode,
andHTML.
Figure 5: Percent of SL regexes from the npm and pypi
datasets,within eachsemantic meaning.
5 THEME2: PREVENTING REDOS
Though we used detectors to identify SL regexes in ğ 4.1.1, these
detectors are academic prototypes not ready for use in production.
On the other hand, software developers already have conventional
wisdomaboutwhatmakesaregexsuper-linear.Ifthisconventional
wisdom is accurate, then publicizing it may be an effective path to
preventing ReDoSbyidentifying andeliminating SL regexes.
251The ImpactofReDoSin Practice ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
5.1 RQ4: DoSLRegexAnti-Patterns Signal SL
Regexes?
In ğ2we mentioned several SL regex anti-patterns: avoid nested
quantifiers,andavoidregexeswithambiguity.Inthissectionwe
testtwoaspectsofthisconventionalwisdom.First,weevaluatethe
extenttowhichtheseSLregexanti-patternsappear inSLregexes
Ð are these anti-patterns a necessary condition for SL behavior?
Second, we measure the extent to which these anti-patterns also
appearinsaferegexes,todeterminewhethertheseanti-patterns
are asufficient condition for SL behavior.
5.1.1 Methodology. Three SL regex anti-patterns. We know
ofthreeSLregexanti-patterns.Inğ 2.4weintroducedthetwoSL
regexanti-patternsdiscussedinreferencetextsonregexes.Thefirst,
star height, isdiscussedin many places including[ 30,32,46].The
second is rather more vague: łwatch out when...[different] parts
of the [regex] can match the same textž [ 33]. We identified two
distinct ways that such ambiguity arose in our SL regex corpora,
yielding three totalanti-patterns.
The first anti-pattern is star height > 1 ,i.e.,nested quantifiers.
ThisleadstoSLbehaviorwhenthesamestringcanbeconsumedby
an inner quantifier or the outer one, as is the case for the string łaž
in the regex /(a+)+/. In this case, the star height of two results in
two choices for each pump, with worst-case exponential behavior
on a mismatch. This anti-pattern is commonly used in practice
throughthe safe-regex tool[46].
The second anti-pattern is a form of ambiguity that we call
Quantified Overlapping Disjunction (QOD). An example of this
anti-pattern is /(\w|\d)+/ . Here we have a quantified disjunc-
tion (/(...|...)+/ ), whose two nodes overlap in the digits, 0-9.
Onapumpstringofadigittherearetwochoicesofwhichgroup
to use,withworst-case exponential behavioronamismatch.
The third anti-pattern is another form of ambiguity that we
callQuantifiedOverlappingAdjacency (QOA).Wegaveadetailed
example of this anti-pattern in ğ 2.2:/\s*\.#\s*$/ . The two quan-
tified\s*nodes overlap, and are adjacent because one can be
reachedfromtheotherbyskippingtheoptionaloctothorpe.This
anti-patternhas worst-case polynomialbehavioronamismatch.
Testingfortheanti-patterns. Weimplementedtestsforthepres-
enceoftheseanti-patternsusingthe regexp-tree regexASTgener-
ator[8]4.Tomeasure starheight wetraversetheASTandmaintain
acounterforeachlayerofnestedquantifier:+,*,andrangeswhere
theupper boundis atleast 255. To detect QODwe search the AST
for quantified disjunctions. When we find them we enumerate the
unicoderangesofeachmemberofthedisjunctionandtestforover-
lap.Todetect QOAwesearchtheASTforquantifiednodes.From
eachnodewewalkforwardlookingforareachablequantifiedad-
jacent node withan overlapping set ofcharacters,stopping at the
earliestof:aquantifiedoverlappingnode(QOA),anon-overlapping
non-optionalnode(noQOA),ortheendofthenodes(noQOA).For
QODandQOAourprototypeonlyconsidersnodescontainingindi-
vidualquantifiedcharacters( e.g.,/\d+/or/.*/,not/(ab)+/).In
4Thesafe-regex tool [46] is implemented incorrectly, so we used our own implementa-
tion. Wehaveprovided a patchto the authorof safe-regex .
5Groupswith lower quantifications do not readilyexhibitsuper-linear behavior.Table 4: Utility of the SL regex anti-patterns, as measured
by our tools. For each anti-pattern, we present the number
of SL regexes that had this pattern in each ecosystem, and
then the false positive rate. For the false positive rate we
rely on the SL regex detectors (ğ 4.1.1) as ground truth. For
example, in npm 12% of the SL regexes had star height > 1,
but94%oftheregexeswithstarheight>1werelinear-time.
As some regexes have multiple anti-patterns, the final row
eliminates double-counting.
Anti-
patternNumber of SL regexes False positiverate
npm pypi npm pypi
Starheight > 1 443 (12%) 62(2%) 94% 98%
QOD 40(1%) 6(1%) 97% 95%
QOA 2,548(71%) 555 (79%) 90% 94%
Totals 2,901(81%) 604 (86%) 91% 95%
keeping with the conventional wisdom,none ofour tests includes
acheckfor amismatch-triggering suffix.
5.1.2 Results. The resultsofapplying our anti-pattern teststo
ournpmandpypiregexdatasetsareshowninTable 4.Whilewe
found at least one anti-patternin most of the SL regexes (81-86%),
we also found many false positives Ð anti-patterns in safe regexes.
Columns2and3showthattheconventionalwisdomofSLregex
anti-patterns appears to supply the necessary conditions for SL
behavior. Our tools found these anti-patterns in over 80% of the SL
regexesinbothecosystems.AmongtheSLregexes,the(polynomial)
QOAanti-patternwasmorecommonthanthe(exponential)others,
agreeing with our earlier finding that polynomial SL regexes are
more common than exponential SL regexes (Table 2). Not all SL
regexeswere labeled.Wemanuallyinspected arandomsampleof
70 of the unlabeled npm SL regexes and confirmed that 65 of them
containedoneor more ofthese anti-patterns,using constructions
toocomplex for our currentanti-patterntest toolsto detect.
However,theseanti-patternsareclearlynotsufficienttomake
an SL regex. Our tools exhibit high false positive rates; as columns
4and5show,onlyasmallfractionoftheregexeswiththeseanti-
patterns were SL regexesineitherecosystem.
6 THEME3: FIXING REDOS
6.1 RQ5: HowHaveDevelopersFixedReDoS
Vulnerabilities?
Here we provide the first characterization of the fix approaches
developershavetakenwhenaddressingReDoSvulnerabilities.This
study tells us which fix strategies developers currently use, setting
thestageforafollow-upstudy(ğ 6.2)ofwhichfixstrategiesdevelop-
ersprefer.Inaddition,understandingthefixapproachesdevelopers
generally take is a first step towards several promising research
directions. For example, researchers interested in automatically
repairingReDoSvulnerabilitieswillbenefitfromknowingwhich
types ofpatchesdevelopers mightbe willing to apply.
6.1.1 Methodology. We were interested in thorough reports
describing SL regexes and how developers fixed them. We thus
searched for ReDoS in security databases using the keywords łCat-
astrophic backtrackingž, łREDOSž, and łRegular expression denial
252ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA J.C.Davis,C.A.Coghlan,F.Servant, andD.Lee
Table 5: Examples of the fix strategies for an SL regex we
reported in Django [ 2] (CVE-2018-7536). This regex detects
an email, according to both the source code and our regex
labeler(ğ 4.3).ThedeveloperschosetofixthisReDoSvulner-
ability usingthealgorithm described inłReplacež.
Example
Original /^\S+@\S+\.\S+$/
Trim if 1000 <input.length:throwerror
else:test withexisting regex
Revise /^[^@]+@([^\.@]+\.)+$/
Replace* Custom parser: (1) Exactly one @ must occur, at
neitherendofthestring;(2)theremustbea‘.’to
the right ofthe @,but not immediately so.
ofservicež.WesearchedboththeCVEdatabase[ 10]andtheSnyk.io
database [ 43]6. We used any reports with two properties: (1) the
reportusedthedefinitionofReDoSgiveninğ 2.3;and(2)thevul-
nerability wasfixedandthe report includedalink.
Foreachvulnerabilityreport,wemanuallycategorizedthefix
strategythedeveloperstook.Ifafixusedmorethanonestrategy
(e.g.,bothTrimandRevise),wecounteditundereachoftheused
strategies.
6.1.2 Results. ReDoS Reports. We identified 45 unique his-
toric ReDoS reports (condition 1) across the CVE and Snyk.io
databases.Theearliestreportwasfrom2007andthemostrecent
from2018.37 ofthesereportsincludedfixes (condition 2).Threeof
these reports were unique to the CVE database, 27 were unique to
the Snyk.iodatabase,and7appearedinboth databases.
Fix strategies. Three fixstrategies were typicalinthesereports.
(1)Trim: Leave the regex alone, but limit the size of the input to
bound the amount ofbacktracking.
(2)Revise: Changethe regex.
(3)Replace: Replace the regex with an alternative strategy, e.g.,
writing acustomparser orusing alibrary.
Table5gives an example of each fix strategy. Only the Revise
strategy was discussed in any of the reference texts on regexes we
reviewed[ 29,30,32,33].
Table6summarizes the results from this study, as well as the
subsequentstudiesonnewfixes(ğ 6.2)and onfixcorrectness(ğ 6.3).
Inthefirstrow,wecanseethatdevelopersinthehistoricdataset
commonly Trimmed, Revised,or Replaced, each more than20% of
the time.
6.2 RQ6: HowWould DevelopersFix ReDoS
Vulnerabilities if TheyKnewAll ofthe
Currently-AppliedApproaches?
In ğ6.1we described the three common fix strategies developers
used in the historic ReDoS reports. However, we do not know
whetherthesedeveloperskneweverystrategy,andthuswecannot
be sure that they preferred one strategy over another. Next, we
describethefixstrategiestakenbydeveloperswhowerefullyaware
ofallofthe strategies.
6Snyk.io’s database tracks vulnerabilities in popular module registries, including npm
and pypi.Table6:FixapproachestakentoaddressSLregexes,inboth
the historic and new datasets. Examples of each approach
are given in Table 5. Some of the new fixes used more than
onestrategy.
Trim Revise Replace Total
HistoricFix approach 8 18 11 37
Unsafe fixes 1 2 0 3
NewFix approach 3 35 15 48
Unsafe fixes 0 0 0 0
6.2.1 Methodology. Tolearnwhatfixstrategiesdeveloperswould
take ifthey knew alloftheoptions,we neededtoconvince asiz-
able group of developers to fix SL regexes. Because we felt that
the maintainers of popular modules would be more likely to fix
problems therein, we examined the use of SL regexes in all npm
and pypi modules downloaded more than 1000 times per month
(cf. Figures 3and4for the effect of this filter). We filtered these
modules for those whose SL regex(es) were clearly a ReDoS vector
based on a manual inspection, and contacted the maintainers of
thosemodulesbyemail.
Inourdisclosures,weincludedadescriptionofthevulnerability:
(1)theSLregex(es)andthefilesinwhichtheylay;(2)thedegreeof
vulnerability(ğ 4.2)foreachregex;(3)eachmaligninput,withprefix,
pump,andsuffix;and(4)thelengthofanattackstringleadingto
a10-secondtimeoutonadesktop-classmachine.Tofacilitateour
experiment, we also included: (5) a description of the three fix
strategiesweobservedinthehistoricdata(Table 5),withlinksto
twopatchesfor each.
6.2.2 Results. After applying our two-stage filter, we disclosed
284 vulnerabilities across both ecosystems to the module main-
tainers. 48 (17%) of our disclosures have resulted in fixes so far.
Prominentprojects that applied fixesbased onour reportsinclude
the Hapi and Django web frameworks and the MongoDB database.
The fix strategies the maintainers chose are shown in Table 6.
Comparedtothehistoricfixstrategies,developersexposedtoex-
amples of all three fix strategies still preferred Revise to Trim. The
use of Revise rose from 49% to 73%, while the use of Trim fell from
22% to 6%. The use of Replace remained around 30%. Clearly these
developerspreferredRevisewhentheyconsideredallthreechoices.
6.3 RQ7: HowEffectivearetheFixesthat
DevelopersAdopt?
Any one of fixstrategies inTable 5can go awry. To Trim, develop-
ersmustsolveaGoldilocksproblem:trimtooshortandvalidinput
will be rejected, trim too long and the vulnerability will remain. To
Revise,developersmustcraftalinear-timeregexthatmatchesa
languagecloseenoughtotheoriginalthattheirAPIscontinueto
work. Lastly, to Replace, developers must write a parser for the
inputthat matches an equivalentorrelatedlanguage.
In this study we examine the correctness of developers’ fixes.
6.3.1 Methodology. Here is our fix safety classification scheme.
We called a Trimfix unsafe if the maximum allowed input length
can still trigger a noticeable slowdown. We compared the input
limit to the lengths of malign inputs derived using the SL regex
identification procedure fromğ 4.1. We calleda Revisefixunsafeif
253The ImpactofReDoSin Practice ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
it was labeled vulnerable by our SL regex identification procedure.
We called a Replace fix unsafe if the replacement logic was super-
linearincomplexitybasedonmanual inspection.
6.3.2 Results. Our findings forthe effectivenessof the historic
and new fixes are summarized in Table 6. Several of the historic
fixes were incorrect. The new fixes were uniformly correct (nearly
alldevelopersaskedus to reviewtheir fixes before publishingtheir
changes).
Trim.1ofthe8historicTrimfixeswasunsafe.Theinitialchoiceof
lengthlimitwastoogenerousandtheregexremainedvulnerablefor
two years before this was discovered and the length limit lowered.
Revise.2ofthe18historicfixesresultedinarevised,butstillSL,
regex. One ofthese was replaced before our study. As a testament
totheeffectivenessofourapproach,wediscoveredtheotherinğ 4.1
and disclosed it in ğ 6.2before performing this portion of our study.
Replace. We manually inspected the fixes that used the Replace
strategy to gauge their complexity. All appeared sound, relying on
one ormore linearscans ofthe input.
Testing their fixes. Regardlessofthefixstrategy,developersdid
not usually include test cases for their changes. In the historic
dataset, 8 of the 37 fixes included tests. In the new dataset, 18 of
the 48 fixes includedtests.
7 DISCUSSION AND RECOMMENDATIONS
WebelieveitisclearfromourfindingsthatReDoSisnotaniche
concern but a potentially common security vulnerability. Given
the number, variety, and ubiquity of SL regexes that we found, we
believe that developers should not be left to theirowndevices.
MakeregexengineslesspronetoSLbehavior. Wesuggestthat
languagedevelopersworkwithregexenginedeveloperstoprovide
applicationdeveloperswithreasonableguaranteesabouttheworst-
case performance of their regexes. This guarantee might be on
the computational complexity of the operation, as Rust and Go
offer,thoughdoingsorestrictstherangeofregexfeaturestowhich
developers have access7. The guarantee might instead be about the
total amount of backtracking experienced (as in Perl and PHP), or
aboutthetotalamountoftimethatmightbespentinaregexquery
(as the .NETframework optionallysupports).
Degrees of vulnerability. Differentiating between exponential
andpolynomialSLregexesgivesdevelopersinsightintovalidfix
approaches. Trimming is a possible fix strategy for polynomial
SL regexes, but not for exponential ones. But make no mistake,
polynomialvulnerabilitiescanbejustasdisastrous.Thereislittle
difference in the cost for attackers to send malign inputs of 100
charactersor10,000,solongastheyaccomplishtheiraimofdenying
service to legitimate users.
Experiences fixing SL regexes. In addition to the 48 fixes from
module maintainers, we submitted 9 fixes when maintainers asked
usforhelp.Ourownexperiencesmayilluminatesomeofthefactors
that developers will consider when selecting a fix strategy, though
we believe this tooisapromisingdirection for future research.
7In our npm and pypi datasets, however, these features are rarely used. 338,065 of
theuniquenpmregexes(97%)and58,800oftheuniquepypiregexes(93%)useonly
linear-timefeatures.The fix strategy we selected (1 Trim, 9 Revise, 2 Replace, with 3
overlaps) depended on both whether the SL regex was exponential
or polynomial, and how identifiable the language of the regex was.
When a regex was exponential or was polynomial with a large
degree,thevulnerabilitywouldmanifestonshortmaligninput.We
fixedthesebyRevising,aidedbyvisualizationsfromthe regexper
tool[4]tounderstandtheoriginallanguageandstudythesource
of the SL behavior. When the SL behavior was less severe ( e.g.,
quadratic),weconsideredbothReviseandTrim.Whenwecould
discern the language described by the regex, we favored Revise,
but whentheregex’slanguage was unclearor many regexes were
appliedtothesameinput( e.g.,parsingauseragentstring),Trim
wasanattractivealternative.WefeltanaversiontoReplacebecause
itfelt overly verbose.
Libraries. Weweresurprisedbythevarietyofregexeswefound
withthesamesemanticmeaning(ğ 4.3).Surelywedonotneed6,986
different regexesto parse URLs, nor 444 different regexesto parse
emails, especially not when hundreds of these variations exhibit
SL behavior. We therefore recommend developers make greater
use of libraries for parsingcommon constructs like those with the
semanticmeaningsindicatedwitha‘*’inTable 3.Alongtheselines,
it would also be helpful if RFCs included linear-time regexes to
parse key fields andprotocols.
ConventionalWisdom. Ourfindingsinğ 5.1(Table4)givenuance
totheconventionalwisdomonSLregexanti-patterns.ThoughStar
Height,QOD,andQOAwerepresentinnearlyallSLregexesinour
datasets,theywerealsopresentintentimesasmanylinear-time
regexes as measured by our tools. This finding speaks to the value
of using SL regex detectors. However, the anti-patterns do give
insightintotherootcauseofanSLregex,andcanbeusedwiththe
Revise fixstrategy.
Why might SL regexes be more pollutive in npm than in
pypi?We thought the difference between the npm and pypi łSL
regex module appearancesž curves (solid lines in Figure 2) was
striking.WhymightthemostubiquitousSLregexespolluteonly50
modules in pypi but hundreds in npm? We think the multi-module
appearancesofSLregexesinnpmcanbeattributedtothreecauses.
(1)Copy/pasting useful regexes from places like StackOverflow. We
foundseveralexamplesofSLemailregexesoriginatingonStack-
Overflow.SeeforexampletheexponentialSLregexof[ 7],which
has1900upvotes.AstudyoftheregexesonStackOverflowandtheir
intersectionwithourecosystem-scaledatasetswouldbeinteresting
follow-up work. (2) Software bundling , because of disincentives in
theJavaScriptcommunitytohavingmanyexplicitdependencies.In
one case, we identified 43 modules whose npm artifacts contained
thesourceofanothermodulewithanSLregex.(3)ManyJavaScript
libraries wish to be context-agnostic , and excerpt core Node.js li-
braries toensure thatthey arealways available.Forexample,one
oftheSLpath-parsingregexesfromNodev4appearedinover2,000
npmmodules.
8 THREATS TO VALIDITY
ConstructValidity. OnethreatisthatweusedautomatedSLregex
detectors to identify SL regexes. Our study may thus be affected by
254ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA J.C.Davis,C.A.Coghlan,F.Servant, andD.Lee
incorrectly-labeledregexes.Weaddressfalsepositivesbydynam-
ically confirming the report from the SL regex detectors (ğ 4.1.1).
Falsenegativesarealsopossible:wereportonlytheSLregexesthat
canbedetectedbyexistingtechniques( e.g.,noneofthemconsiders
theuseofinherentlysuper-linearfeatureslikebackreferences).This
meansthattheSLregexesweidentifiedrepresenta lowerbound on
the number ofsuch regexesinpractice.
Another threat is that we do not identify all the possible ap-
plicationdomainsinwhichregexescouldbeapplied.Ourgoalin
studyingRQ3wastounderstandwhetherSLregexesappearacross
applicationdomains,andwhetherdifferentapplicationdomainsare
affected differently bythem. Our precise but otherwise potentially
incomplete set of application domains still allowed us to answer
thesequestionsinthe affirmative.
Finally,anSLregexisonlyoneofthecriteriaforaReDoSattack
(ğ2.3).WefocusedonidentifyingReDoSvulnerabilities,anddidnot
confirmthattheyareexploitable;wedidnotperformtaintanalysis
to confirm that malign input could reach these regexes, nor did we
attempttodifferentiatebetweenmodulesintendedfortheserver
sidevs. the clientside.
InternalValidity. Wedevelopedseveralnovelanalysestoanswer
our research questions. Incorrect implementations of the regex
semantic meaning labeler (ğ 4.3) and the anti-pattern tests (ğ 5.1)
wouldskewourfindings.Toaddressthethreattoourregexlabeler,
we validated its precision over 17 iterations. Our anti-pattern tests
identified the use of anti-patterns in over 80% of the SL regexes,
indicating agreement with the SL regex detectors in our ensemble,
andagreeingwiththeintuitionthatanti-patternsareanecessary
condition for super-linear behavior.
External Validity. A threat to external validity concerns whether
ourfindingswillholdforotherecosystemsandscenarios.Wead-
dressed this threat by studying two popular programming lan-
guageswithlargeecosystems.Asthegeneralthemeofourfindings
was consistent across these ecosystems, we expect our results to
generalize to otherecosystems as well.
9 RELATED WORK
HereisabriefhistoryofReDoS.Crosbyfirstsuggestedthatregexes
with large complexity could be a denial of service vector [ 23], as a
precursor to his influential work with Wallach on algorithmic com-
plexityattacks[ 24].ThefirstCVEreportofReDoSappearedin2007
(CVE-2007-2026),and thenotionwas popularizedbyOWASP and
Checkmarx in 2009 [ 40]. Two primitive SL regex detectors were re-
leasedintheearly2010s:Microsoft’s SDL Regex Fuzzer toolusedin-
putfuzzingtotrytotriggersuper-linearbehavior,whilesubstack’s
safe-regex usedthestarheightanti-pattern[ 46].Thesedetectors
were followed by a succession of more rigorous academic works
on SL regex detection: Kirrage, Rathnayake, and Thielecke [ 34]
andRathnayakeandThielecke[ 38]developed rxxr2in2013-2014,
Weideman et al. released regex-static-analysis in 2016 [51,52]
andWustholzetal.published rexploiter in2017[55]8.Ourwork
takes the logical next step: we measured the extent to which SL
regexesoccurinreal-worldsoftwareandexaminedtheadoption
andeffectiveness ofrepairs.
8ConcurrentworkfromShenetal.demonstratesanSLregexdetectorbasedongenetic
searchalgorithms [ 41].In terms of ecosystem-scale ReDoS analyses, the closest work to
oursisindustrial,notacademic.In2014,Liftsecurity.ioperformed
an ecosystem-scale study of SL regexes in npm [ 5]. They relied
onsafe-regex to scan 100,000 modules and only identified 56 SL
regexesaffecting120modules.Theirmuchsmallerincidencerateis
notsurprisingÐ safe-regex ’sStarHeightheuristicwillnotcapture
thousandsofpolynomialSL regexes(Table 4).
Staicu and Pradel recently demonstrated mappings from SL
regexes innpm modulesto ReDoSvulnerabilities inhundreds of
popular websites [ 45], suggestingthat the myriad SL regexes we
foundindicatemanyotherReDoSvulnerabilities.
AninterestinglineofworkfromvanderMerwe,Weideman,and
Berglund proposes automatic regex revising techniques to replace
SL regexes with equivalent safe ones [ 49]. This work is not yet
fullydevelopedbutpromisestoprovidedeveloperswithauseful
tool to address SL regexes. We note that these authors restricted
themselves to revisions that would match the exact same language,
whiledevelopersrarelydidsointhefixeswestudied.Wesuggest
combiningthisautomaticrevisionapproachwithanunderstanding
of semantic meanings (ğ 4.3) and anti-patterns (ğ 5.1) as a promising
direction for future research.
Moregenerally,thestudyofregexesfromasoftwareengineering
perspectivewaspioneeredbyChapmanandStolee.Theystudied
theuseofregexesinasmallsampleofPythonapplications[ 19],and
ourstudyofmodulesandcorelibrariescomplementstheirwork.
WithWang,theyhavealsoexploredpossiblefactorsaffectingregex
comprehension[ 20].Lastly,WangandStoleerecentlyfoundthat
regexesexhibitpoortestcoverage[ 50],whichmaycontributeto
the incidence ofSL regexeswe report.
10 REPRODUCIBILITY
Anartifactcontainingourregexdatasetsandouranalysiscodeis
available at https://doi.org/10.5281/zenodo.1294300 .
11 CONCLUSION
We believe nearly every practicing software developer has used
regularexpressions.Asitturnsout,manydevelopershavealsowrit-
tensuper-linearregexesandintroducedperformanceorsecurity
concerns in doingso.We foundthousands of super-linearregexes
in our analyses of the Node.js (JavaScript) and Python ecosystems,
affectingover10,000modulesaswellasthecorelibrariesofNode.js
andPython.
WehavefoundthatReDoSisnotanicheconcern,butrathera
commonsecurityvulnerability.Assuch,itmeritssignificantaddi-
tional investment from researchersand practitioners.Muchwork
remains:intheshortterm,togaugedeveloperawarenessandim-
prove educational resources, and in the long term to implement
andevaluate effective prevention andresolutionmechanisms.
ACKNOWLEDGMENTS
WethanktheESEC/FSEreviewersfortheirfeedback.K.Yavineand
D. Grander of Snyk.io did yeoman’s work assisting us in disclosing
ReDoS vulnerabilities. E.R. Williamson, A. Kazerouni, J. Phillips,
and the VT Systems Reading Group gave helpful feedback on ideas
and versions of this paper. This work was supported in part by
the NationalScience Foundation,undergrantCNS-1814430, and a
Google Faculty ResearchAward.
255The ImpactofReDoSin Practice ESEC/FSE’18,November4–9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1]2004. tasksetśsetorretrieveaprocess’sCPUaffinity. https://web.archive.org/
web/20180801003855/https://linux.die.net/man/1/taskset .
[2]2005. Django: The web framework for perfectionists with deadlines. https:
//web.archive.org/web/20180801003925/https://www.djangoproject.com .
[3]2012. What’s new in the .NET Framework 4.5. https://web.archive.org/
web/20180801003332/https://docs.microsoft.com/en-us/dotnet/framework/
whats-new/index .
[4]2014. Regexper. https://web.archive.org/web/20180801004409/https://regexper.
com/.
[5]2014. Regular Expression DoS and Node.js. https://web.archive.
org/web/20170131192028/https://blog.liftsecurity.io/2014/11/03/
regular-expression-dos-and-node.js .
[6]2017. Babylon: Babylon is a JavaScript parser used in Babel.
http://web.archive.org/web/20171231170138/https://github.com/babel/babel/
tree/master/packages/babylon .
[7]2017. How to validate an email address using a regular expression? https:
//web.archive.org/web/20180801004019/https://stackoverflow.com/questions/
201323/how-to-validate-an-email-address-using-a-regular-expression .
[8]2017. regexp-tree: Regular expressions processor in JavaScript. https:
//web.archive.org/web/20180801004201/https://github.com/DmitrySoshnikov/
regexp-tree .
[9]2018. cloc:CountLinesofCode. https://web.archive.org/web/20180801003246/
https://github.com/AlDanial/cloc .
[10] 2018. Common Vulnerabilitiesand Exposures. https://cve.mitre.org .
[11]2018. Go documentation:regexp. https://web.archive.org/web/20180801003600/
https://golang.org/pkg/regexp/ .
[12]2018. npm. https://web.archive.org/web/20180801003712/https://www.npmjs.
com.
[13]2018. PyPI ś the Python Package Index. https://web.archive.org/web/
20180801003833/https://pypi.org/ .
[14]2018. Rust documentation: regex. https://web.archive.org/web/20180801003203/
https://docs.rs/regex/1.0.2/regex/ .
[15]Rabe Abdalkareem, Olivier Nourry, Sultan Wehaibi, Suhaib Mujahid, and Emad
Shihab. 2017. Why Do Developers Use Trivial Packages? An Empirical Case
Study onnpm.In Foundations ofSoftware Engineering(FSE) .https://doi.org/10.
1145/3106237.3106267
[16]AlasdairAllan.2012. LearningiOSProgramming:FromXcodetoAppStore .O’Reilly
Media.
[17]Adam Baldwin. 2016. Regular Expression Denial of
Service affecting Express.js. http://web.archive.org/
web/20170116160113/https://medium.com/node-security/
regular-expression-denial-of-service-affecting-express-js-9c397c164c43 .
[18]Martin Berglund, Frank Drewes, and Brink Van Der Merwe. 2014. Analyzing
CatastrophicBacktracking BehaviorinPracticalRegularExpressionMatching.
EPTCS:AutomataandFormalLanguages2014 151(2014),109ś123. https://doi.
org/10.4204/EPTCS.151.7
[19]Carl Chapman and Kathryn T Stolee. 2016. Exploring regular expression us-
ageandcontextinPython.In InternationalSymposiumonSoftwareTestingand
Analysis(ISSTA) .https://doi.org/10.1145/2931037.2931073
[20]Carl Chapman, Peipei Wang, and Kathryn T Stolee. 2017. Exploring Regular
ExpressionComprehension. In AutomatedSoftwareEngineering (ASE) .
[21]Checkmarx.2016. TheNode.jsHighway-AttacksareatFullThrottle.In BlackHat
USA.https://www.youtube.com/watch?v=-HzCUZDLXTc
[22]RussCox.2007.RegularExpressionMatchingCanBeSimpleAndFast(butisslow
inJava,Perl,PHP,Python,Ruby,...). https://swtch.com/~rsc/regexp/regexp1.html
[23]Scott Crosby. 2003. Denial of service through regular expressions. USENIX
Securitywork inprogressreport (2003).
[24]Scott A Crosby and Dan S Wallach. 2003. Denial of Service via Algorithmic
ComplexityAttacks. In USENIXSecurity .
[25]James C Davis, Eric R Williamson, and Dongyoon Lee. 2018. A Sense of Time
for JavaScript and Node.js: First-Class Timeouts as a Cure for Event Handler
Poisoning.In USENIXSecuritySymposium(USENIXSecurity) .
[26]Erik DeBill. 2010. Module Counts. http://web.archive.org/web/20180114183225/
http://www.modulecounts.com/ .
[27]Stack Exchange. 2016. Outage Postmortem. http://web.archive.
org/web/20180801005940/http://stackstatus.net/post/147710624694/
outage-postmortem-july-20-2016 .
[28]Maximiliano Firtman. 2013. Programming the Mobile Web: Reaching Users on
iPhone,Android, BlackBerry, WindowsPhone, and more . O’ReillyMedia.[29] MichaelFitzgerald.2012. Introducing regularexpressions . O’ReillyMedia,Inc.
[30] JeffreyEF Friedl. 2002. Mastering regularexpressions . O’ReillyMedia,Inc.
[31]Patrice Godefroid. 1995. Partial-Order Methods for the Verification of Concur-
rentSystems . Ph.D.Dissertation.UniversityofLiege. https://doi.org/10.1007/
3-540-60761-7
[32] Jan Goyvaerts.2006. Regular Expressions: The Complete Tutorial . Lulu Press.
[33]Jan Goyvaerts and Steven Levithan. 2012. Regular expressions cookbook . O’Reilly
Media,Inc.
[34] James Kirrage, Asiri Rathnayake, and Hayo Thielecke. 2013. Static Analysis for
Regular Expression Denial-of-Service Attacks. In International Conference on
Network and SystemSecurity(NSS) . 35ś148.
[35]Konstantinos Manikas and Klaus Marius Hansen. 2013. Software ecosystems-
A systematic literature review. Journal of Systems and Software 86, 5 (2013),
1294ś1306. https://doi.org/10.1016/j.jss.2012.12.026
[36]A Ojamaa and K Duuna. 2012. Assessing the security of Node.js platform. In
7th International Conference for Internet Technology and Secured Transactions
(ICITST).
[37]Theoolos Petsios, Jason Zhao, Angelos D Keromytis, and Suman Jana. 2017.
SlowFuzz:AutomatedDomain-IndependentDetectionofAlgorithmicComplexity
Vulnerabilities.In ComputerandCommunicationsSecurity(CCS) .https://doi.org/
10.1145/3133956.3134073
[38]AsiriRathnayakeandHayoThielecke.2014. StaticAnalysisforRegularExpression
Exponential Runtime via SubstructuralLogics . Technical Report.
[39]RandyJ.RayandPavelKulchenko.2002. ProgrammingWebServiceswithPerl .
O’ReillyMedia.
[40]Alex Roichman and Adar Weidman. 2009. VAC - ReDoS: Regular Expression
Denial OfService. OpenWeb ApplicationSecurityProject (OWASP) (2009).
[41]YujuShen,YanyanJiang,ChangXu,PingYu,XiaoxingMa,andJianLu.2018. ReS-
cue:CraftingRegularExpressionDoSAttacks.In AutomatedSoftwareEngineering
(ASE).
[42]Michael Sipser. 2006. Introduction to the Theory of Computation . Vol. 2. Thomson
CourseTechnologyBoston.
[43]Snyk.io. 2018. Vulnerability DB. http://web.archive.org/web/20180801010155/
https://snyk.io/vuln .
[44]HenrySpencer.1994. Aregular-expressionmatcher. In SoftwaresolutionsinC .
35ś71.
[45]Cristian-Alexandru Staicu and Michael Pradel. 2018. Freezing the Web: A Study
ofReDoSVulnerabilitiesinJavaScript-basedWebServers.In USENIXSecurity
Symposium (USENIX Security) .https://www.npmjs.com/package/safe-regexhttp:
//mp.binaervarianz.de/ReDoS_TR_Dec2017.pdf
[46]substack.2013. safe-regex. https://web.archive.org/web/20180801003748/https:
//github.com/substack/safe-regex .
[47]BryanSullivan.2010. SecurityBriefs-RegularExpressionDenialofServiceAttacks
andDefenses . TechnicalReport. https://msdn.microsoft.com/en-us/magazine/
ff646973.aspx
[48]Ken Thompson. 1968. Regular Expression Search Algorithm. Communications of
theACM(CACM) (1968).https://www.fing.edu.uy/inco/cursos/intropln/material/
p419-thompson.pdf
[49]Brink Van Der Merwe, Nicolaas Weideman, and Martin Berglund. 2017. Turning
Evil RegexesHarmless.In SAICSIT.https://doi.org/10.1145/3129416.3129440
[50]PeipeiWangandKathrynTStolee.2018. Howwellareregularexpressionstested
in the wild?. In FoundationsofSoftwareEngineering (FSE) .
[51]Nicolaas Weideman, Brink van der Merwe, Martin Berglund, and Bruce Wat-
son. 2016. Analyzing matching time behavior of backtracking regular expres-
sion matchers byusing ambiguityof NFA. In LectureNotes inComputer Science
(including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in
Bioinformatics) , Vol. 9705.322ś334.
[52]Nicolaas Hendrik Weideman. 2017. Static Analysis of Regular Expressions . MS.
Stellenbosch University.
[53]Wikipedia contributors. 2018. .NET Framework version history Ð Wikipedia,
The Free Encyclopedia. https://en.wikipedia.org/w/index.php?title=.NET_
Framework_version_history&oldid=851937435 . [Online; accessed 1-August-
2018].
[54]Wikipedia contributors. 2018. Regular expression Ð Wikipedia, The Free En-
cyclopedia. https://en.wikipedia.org/w/index.php?title=Regular_expression&
oldid=852858998 . [Online;accessed 1-August-2018].
[55]Valentin Wustholz, Oswaldo Olivo, Marijn J H Heule, and Isil Dillig. 2017. Static
DetectionofDoSVulnerabilitiesinProgramsthatuseRegularExpressions.In
InternationalConferenceonToolsandAlgorithmsfortheConstructionandAnalysis
ofSystems(TACAS) .
256