arXiv:1903.12113v1  [cs.SE]  28 Mar 2019Counterexample-GuidedApproachtoFinding
NumericalInvariants
/T_hanhVuNguyen
University ofNebraska-Lincoln,USATimos Antonopoulos
Yale University, USA
Andrew Ruef
University ofMaryland,USAMichaelHicks
University of Maryland,USA
ABSTRACT
Numericalinvariants,e.g.,relationshipsamongnumerica lvariables
inaprogram,represent a usefulclassofpropertiestoanaly zepro-
grams. Generalpolynomialinvariantsrepresentmorecompl exnu-
merical relations, but they are o/f_ten required in many scient iﬁc
and engineering applications. We present NumInv, a toolthat im-
plements a counterexample-guided invariant generation (C EGIR)
technique to automatically discover numerical invariants , which
are polynomial equality and inequality relations among num eri-
cal variables. /T_his CEGIR technique infers candidate invari ants
from program traces and then checks them against the program
source code using the KLEE test-input generation tool. If th e in-
variants areincorrectKLEEreturnscounterexampletraces ,which
help the dynamic inference obtain be/t_ter results. Existing C EGIR
approaches o/f_ten require sound invariants, however NumInvsac-
riﬁces soundness and produces results that KLEE cannot refu te
within certain time bounds. /T_his design and the use of KLEE as
a veriﬁer allow NumInvto discover useful and important numeri-
cal invariants formany challenging programs.
Preliminary results show that NumInvgenerates required in-
variants for understanding and verifying correctness of pr ograms
involving complex arithmetic. We also show that NumInvdiscov-
ers polynomial invariants thatcaptureprecisecomplexity bounds
ofprogramsusedtobenchmarkexistingstaticcomplexityan alysis
techniques. Finally,weshowthat NumInvperformscompetitively
comparingtostateof theart numerical invariant analysis t ools.
CCS CONCEPTS
•So/f_tware and its engineering →So/f_tware veriﬁcation and
validation;So/f_tware veriﬁcation;Automatedstaticanalys is;
Dynamicanalysis;
KEYWORDS
Dynamic and Static Invariant Analyses, Counterexample-gu ided
Algorithms, Numerical Domains, Program and Correctness An al-
yses, Test-inputGeneration
ACMReference format:
/T_hanhVuNguyen,TimosAntonopoulos, AndrewRuef,andMichaelHicks.
2017. Counterexample-Guided Approach toFinding
Numerical Invariants . In Proceedings of 2017 11th Joint Meeting of the Eu-
ropean So/f_twareEngineering Conferenceandthe ACMSIGSOFT S ymposium
ontheFoundationsofSo/f_twareEngineering,Paderborn,Germ any,September
4–8, 2017 (ESEC/FSE’17), 12 pages.
ESEC/FSE’17,Paderborn,Germany
2017. 978-1-4503-5105-8/17/09...$15.00
DOI:10.1145/3106237.3106281DOI:10.1145/3106237.3106281
1 INTRODUCTION
/T_he automated discovery of program invariants —relations among
variablesthatareguaranteedtoholdatcertainlocationso faprogram—
isanimportantresearchareainprogramanalysisandveriﬁc ation.
Generated invariants can be used to prove correctness asser tions,
reasonaboutresourceusage,establishsecuritypropertie s,provide
formaldocumentation,and more[2,15,16,21,29,31].
A particularly useful class of invariants are numerical invari-
ants,whichinvolve relations amongnumerical programvariable s.
Withinthisclassofinvariants, nonlinearpolynomial relations,e.g.,
x≤/y.alt2,x=q/y.alt+r, arise in many scientiﬁc, engineering, and
safety- and security-critical applications.1For example, the com-
mercial analyzer Astr ´ee, which has been applied to verify the ab-
sence of errors in the Airbus A340/A380 avionic systems [5, 1 3],
implementstheellipsoidabstractdomain[22]torepresent andan-
alyze a class of quadratic inequality invariants. Complexi ty anal-
ysis, which aims to determine a program’s performance chara c-
teristics [25, 26, 30], perhaps to identify possible securi ty prob-
lems [1, 33], alsomakes use ofpolynomial invariants, e.g., O(n2+
2m)wheren,mare some program inputs. In addition, such poly-
nomialinvariantshavebeenfoundusefulintheanalysisofh ybrid
systems [40, 41], and in fact are required for implementatio ns of
common mathematical functions such as mult, div, square, sqrt
andmod.
Numerical invariants can be discovered via static and dynam ic
program analyses. A static analysis can reason about all pro gram
pathssoundly,butdoingsoiso/f_tenexpensiveandisonlyposs ible
for relatively simple forms of invariants [34]. Dynamic ana lyses
limit their a/t_tention to only some of a program’s paths, and as a
resultcano/f_tenbemoreeﬃcient and producemoreexpressive i n-
variants, but provide no guarantee that those invariants ar e cor-
rect [21, 36]. Recently, several systems (such as PIE [37], I CE [23]
andGuess-and-Check [42]) have been developed that take a hy-
brid approach: use a dynamic analysis to infer candidate invari-
antsbut then conﬁrm these invariants are correct for all inputs
usingastaticveriﬁer . Wheninvariantsareincorrecttheveriﬁerre-
turns counterexample traces which the dynamic inference en gine
canusetoinfer moreaccurateinvariants. /T_his iterative pro cessis
calledCounterExampleGuidedInvariantgeneRation (CEGIR).
While the CEGIR approach is promising, existing tools have
some practical limitations. One limitation is that they ﬁnd invari-
ants strong enough to prove a particular (programmer-provi ded)
1We refer to nonlinear polynomial relations such as x=q/y.alt+r,x≤/y.alt2simply as
polynomial relations .ESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
intcohendiv( intx,inty){
assert(x>0 && y>0);
intq=0;intr=x;
while(r≥y){
inta=1;intb=y;
while[L1](r≥2*b){
a = 2*a; b = 2*b;
}
r=r-b; q=q+a;
}
[L2]
return q;
}Traces:
x /y.alt a b q r
15 2 1 2 0 15
15 2 2 4 0 15
15 2 1 2 4 7
...
4 1 1 1 0 4
4 1 2 2 0 4
...
Figure1: Anintegerdivisionprogramandexampletraceval-
ues at location L1on inputs(x=15,/y.alt=2)and(x=4,/y.alt=1).
Amongotherinvariants,twokeyloopinvariantsdiscovered
atL1areb=/y.altaandx=q/y.alt+r, with the latter also found as
the postconditionat L2.
postcondition where the quality of the generated invariant s de-
pends on the strength of the postcondition. As such, they are not
well suited for automated analyses on code that lacks such fo r-
mal speciﬁcations. Another limitation is that these tools e mploy
asoundstatic veriﬁer, which aims todeﬁnitively prove that an in-
variant holds. Whilethisisagoodgoal,itturnsouttobeasi gniﬁ-
cantrestrictiononthequalityoftheinvariantsthatcanul timately
beinferred—it can bequitechallenging todo when invariant s are
nonlinear polynomials and involve many program variables. For
example, consider theprograminFigure 1,which implements Co-
hen’s algorithm for integer division [10]. Two important lo op in-
variants (at L1) areb=/y.altaandx=q/y.alt+r, as they both point
directly to the correctness of the algorithm.2Neither PIE nor ICE
can infer these invariants (bothtoolstimeout).
InthispaperwepresentanewCEGIRalgorithmcalled NumInv
that overcomes these limitations. It has two main component s.
First, it uses algorithms from DIG [35, 36] to dynamically in fer
expressivepolynomialequalityinvariantsandlinearineq ualityre-
lations from traces at speciﬁed program locations. Second, it uses
KLEE [6], a symbolic executor, to check candidate invariant s and
producecounterexampleswhentheyfailtohold. Tochecktha tan
invariant pholds at location L,NumInvtransforms the input pro-
gramsothat Lisguardedbytheconditional ¬p. IfKLEEisableto
reachLthenpmust not be an invariant, and so it outputsa coun-
terexampleconsistingoftherelevant inputvaluesatthatl ocation.
Ontheotherhand,ifKLEEneverreachesthatlocationpriort otim-
ing out, then NumInvaccepts the invariant as correct. Although
thistechniqueisunsound,KLEE,byitsnatureasasymbolice xecu-
tor, turns out to be very eﬀective in discovering counterexa mples
torefuteinvalid candidates.
For the example in Figure 1, NumInvis able to ﬁnd the critical
equalitiesmentionedabove,alongwithmanyotherusefulin equal-
ities. /T_hese invariants help understand the precise semanti cs of
2x=q/y.alt+rdescribes the intended behavior of integer division: the di videndx
equals the divisor /y.alttimes the quotient qplusthe remainder r.the program and verify its correctness properties. Moreove r, by
instrumenting the program with a counter variable, NumInvcan
even infer program running times as a function of the inputs. For
example, NumInvis able to infer the precise running time of the
programinFigure5(page7)whichhasatricky,triple-neste dloop.
We evaluated NumInvby using it to infer invariants on more
than90benchmarkprogramstakenfromtheNLA[35]andHOLA[1 7]
suitesforprogramveriﬁcationandfromexamplesinthelite rature
on complexity bound analysis [25–27]. Our results show that Nu-
mInvgenerates suﬃcientlystronginvariants toverifycorrectn ess
and to understand the semantics of 23/27 NLA programs contai n-
ing nontrivial arithmetic and polynomial relations. We als o ﬁnd
thatNumInvdiscovers highly precise invariants describing non-
trivial complexity bounds for 18/19 programs used to benchm ark
static complexityanalysis techniques (in fact, for 4 progr ams,Nu-
mInvobtains more informative bounds than what were given in
the literature). We note that both ICE and PIE cannot ﬁnd any
oftheseinvariants producedby NumInv,even when weexplicitly
tellthese toolsthatthey shoulda/t_tempt toverify theseinva riants.
Finally, on the 46 HOLA programs, we compare NumInvdirectly
with PIE. We ﬁnd it performs competitively: in 36/46 cases it s in-
ferredinvariantsmatchPIE’s,arestronger,oraremoredes criptive.
/T_hus, although NumInvcan potentially return unsound invari-
ants, our experience shows that it is practical and eﬀective in re-
movinginvalidcandidatesandinhandlingdiﬃcultprograms with
complex invariants. We believe that NumInvstrikes a practical
balance between correctness and expressive power, allowin g it to
discover complex, yet interesting and useful invariants ou t of the
reach of thecurrentstateof theart.
2 OVERVIEW
NumInvgeneratesinvariantsusingthetechniqueof counterexample-
guided invariant generation (CEGIR). At a high level, CEGIR con-
sists of two components: a dynamicanalysis that infers candidate
invariants fromexecutiontraces,anda staticveriﬁer tocheckcan-
didatesagainsttheprogramcode. Ifacandidateinvariant i sspuri-
ous,theveriﬁeralsoprovidescounterexamples( cexs). Tracesfrom
thesecexs arerecycled torepeat theprocess,hopefullypro ducing
accurateresults. /T_hesestepsofinferringandcheckingrepe atuntil
no new cexs or (true) invariants are found. /T_he CEGIR approach
is basically exploiting the observationthat inferring a so und solu-
tion directly is o/f_ten harder than checking a (cheaply genera ted)
candidatesolution.
OtherpromisingCEGIRalgorithms,e.g.,theICE,PIEand Guess-
and-Check tools,havebeendevelopedinrecentyearsthattakethe
same approach [23, 37, 42], though they refer to it diﬀerentl y. In
particular they refer to CEGIR as a data driven orblack-box ap-
proach,wherethedynamicanalysisiscalledthe studentorlearner,
and the static veriﬁer is called the teacherororacle./T_hese ap-
proaches have been able to prove correctness of speciﬁcatio ns by
inferringinductiveloopinvariants,orsuﬃcientandneces sarypre-
conditions. Someoftheseworks(ICEandPIE)areveriﬁcatio nori-
ented, i.e. they infer invariants to speciﬁcallyprove a giv en asser-
tion. Inthisapproach,thecomputationofthese“helper”in variantsCounterexample-GuidedApproach toFinding
Numerical Invariants ESEC/FSE’17,September4–8,2017,Paderborn,Germany
strictlydependsonthegiven assertions,e.g., iftheinten dedasser-
tionisTruethentheinferredinvariantcanbejust True. Wereview
these worksin moredetail inSection6.
NumInvhasdiﬀerent goalsandtakes adiﬀerent approach. Our
goals are both discovery and veriﬁcation, and our approach i s to
ﬁnd the strongest possible invariant at any arbitrarily giv en loca-
tion. When given an undocumented program, NumInvcan dis-
coverinterestingpropertiesandprovideformalspeciﬁcat ions. For
example, NumInvcanrevealastrongerpostconditionthantheuser
might think to write down, and the user doesn’t have to write
down any postconditions at all. Moreover, when given a speci ﬁc
assertion, the resulting invariant from NumInvcan help prove it
(e.g.,iftheinvariantmatchesorisstrongerthantheasser tion). Em-
pirically, NumInvcan frequently infer invariants that are at least
as strongas thepostcondition,and frequently,stronger.
2.1NumInv
NumInvinferscandidateinvariantsusingthealgorithmsfromDIG[ 35,
36], which produce equality and inequality relations from t races.
Tocheck invariants, NumInvinvokes KLEE[6],a symbolic execu-
torthatis abletosynthesize testcases forfailing tests.
KLEE as a “veriﬁer”. NumInvgenerates candidate invariants at
program location Lof interest (e.g., at the start of loops or at the
end of functions). To check whether a property pholds at a lo-
cationL,NumInvasks KLEE to determine the reachability of the
locationLwhen guarded by¬p. For example, to check whether
therelation x=q/y.alt+ris aninvariant at somelocation L,NumInv
modiﬁes theprogramas follows
...
if(!(x==qy+r)){
[L]
save(x,y,q,r); //cex traces
abort();
}
...
KLEE then runs this program, systematically exploring the s pace
of possible inputs. If, during this process, location Lis reached,
then the relation does not hold, so a cex consisting of the val ues
of the relevant input variables is saved for subsequent infe rence.
Ontheotherhand,KLEEmaybeabletoexploreallprogrampath s
and thus verify that indeed that invariant pholds. Or, if this is
infeasible, NumInvterminates KLEEa/f_tersometimeout.
/T_he use of KLEE as the veriﬁer is a key feature of NumInv.
Because programs o/f_ten contain a very large number of possibl e
paths, KLEE rarely explores all of them. However, in our expe ri-
ence (Section 5), if it does not quickly ﬁnd a counterexample for
pthenpvery likely holds. /T_his is true even when pis a nonlin-
ear polynomial relation. As such, KLEE serves as a practical im-
provement over existing theorem provers and constraint sol vers,
for which reasoning over general polynomial arithmetic is a sig-
niﬁcant challenge.
Inferring polynomial equalities and linear inequalities. NumInv
uses two CEGIR algorithms to ﬁnd candidate numerical relati ons
pat program locations of interest. /T_he ﬁrst algorithm ﬁnds poly-
nomialequalities . Todothis,foreachprogramlocation L,NumInvproduces a template equation c1t1+c2t2···cntn=0. /T_his equa-
tion contains nunknown coeﬃcients ciandntermsti, with one
termfor each possiblecombinationof relevant program vari ables,
up to some degree d.NumInvcalls KLEE on the program to sys-
tematically obtain many possible valuations of relevant va riables
atL.Eachdistinctobservedvaluation,whichwecalla trace,issub-
stituted into the template to form an instantiated equation . A/f_ter
obtainingatleast ntraces,NumInvsolvesthe ciusingtheresulting
setofequations. Substitutingthesolutionsbackintothet emplate,
we canextract candidate invariants. At this point, NumInventers
a CEGIR loop that tests the candidate invariants by using KLE E
as described above. Any spurious invariants are dropped,an d the
corresponding cex traces are used to infer new candidates, a s de-
scribedabove, untilno additional trueinvariants are foun d.
NumInv’s second algorithm tries to infer linear inequalities in
the form of octagons, which are inequalities over two variables,
containing eight edges. It reﬁnes the bounds on the candidat e in-
variants using a divide-and-conquer algorithm. Once again ,Nu-
mInvestimates and obtains an initial set of traces. It enumerate s
allpossibleoctagonalinequalityformsinvolvingoneandt wovari-
ables and uses KLEE to check inequalities under these forms a re
within certain ranges [minV,maxV]. It then narrows this range,
iteratively seeking tighter lower and upperbounds.
Finally, from the obtained equality and inequality invaria nts,
NumInvremoves any invariants that are logical implications of
other invariants. For instance, we suppress the invariant x2=/y.alt2
if another invariant x=/y.altis also found because the la/t_ter implies
the former. We check possible implications using an SMT solv er
(checkingwhetherthenegationoftheimplicationisunsati sﬁable).
2.2 Example
Recalltheprogram cohendiv inFigure1,whichtakesasinputtwo
integersx,/y.altand returns the integer qas the quotient of xand/y.alt.
Given this program and locations of interest L1andL2,NumInv
automaticallydiscovers thefollowing(loop)invariants a tL1:
x=q/y.alt+r b=/y.alta
/y.alt≤b b≤r
r≤x a≤b2≤a+/y.alt
and thefollowing(postcondition)invariants at L2:
x=q/y.alt+r1≤q+r
r≤x r≤/y.alt−1 0≤r
/T_hese equality and inequality relations are suﬃciently stro ng
tounderstand the function’s semantics and verify thecorre ctness
ofcohendiv. Morespeciﬁcally, the nonlinear equation x=q/y.alt+r
describes the precise behavior of integer division: the div idendx
equalsthedivisor /y.alttimesthequotient qplustheremainder r. /T_he
other inequalities also provide useful information for deb ugging.
Forexample,theseinvariantsreveal several requiredprop ertiesof
the remainder rsuch asris non-negative ( r≥0), is at most the
dividend ( r≤x), but is strictly less than the divisor ( r≤/y.alt−1).
Inaddition,theseinvariantscanhelpproveassertionsift heyexist
in the program. For example, if we want to assert and prove the
postcondition stating that the returned quotient is non-ne gativeESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
(q≥0),thenwecaneasilydosobecausethediscoveredinvariant s
atL2implyq≥0.3
As mentioned above, ICE and PIE generate invariants to prove
speciﬁc assertions. /T_hus, given a program with no speciﬁc ass er-
tion, they will not provide anything useful. Even when asked to
verify a speciﬁc assertion, e.g., x=q/y.alt+ror other simpler invari-
ants above found by NumInv, these tools fail to prove them (PIE
doesnotconvergeandICEfailstogenerateinvariantstopro vethe
givenassertions). Wedonothavetheimplementationofthe Guess-
and-Check algorithm in [42] to runon this example, however this
work does not support inequalities and thus would not genera te
theinequalityinvariants shown.
3 INFERRING POLYNOMIAL EQUALITIES
We now discuss NumInv’s CEGIR algorithm for generating poly-
nomial equalities among program variables. /T_his algorithm i nte-
grates the equation solving technique in DIG with KLEE to ﬁnd
invariants.
3.1 Terms, Templates, and Equation Solving
NumInvinfers polynomial equalities by searching for solutions
to instantiations of a template equation having the form c1t1+
c2t2···+cntn=0,whereciarereal-valuedand tiareterms. Terms
consist of monomials over program variables. More speciﬁca lly,
given a set Vof variables and a degree d,NumInvcreates a set of
nterms consisting of monomials up to degree dfromV. For in-
stance, the n=10 terms{1,r,/y.alt,a,r/y.alt,ra,/y.alta,r2,/y.alt2,a2}consist of
all monomialsup todegree 2 over thevariables {r,/y.alt,a}.
NumInvseekstosolvethe ciinthetemplateequationby instan-
tiatingthetiwith values observed from traces. For our example,
instantiating thetemplatewith thetrace r=3,/y.alt=2,a=6would
yield the equation c1+3c2···+36cn=0. If there are nterms,
we need at least ndistinct valuations of the variables in V. Given
the (at least) nequations that result a/f_ter instantiation, we solve
fortheci,substitutingtheirsolutionsintothetemplatetoproduce
equationsover the(combinations of) variables in V.
3.2 Algorithm
Figure2showstheCEGIRalgorithmforﬁndingpolynomialequ al-
ities. Given a program P, location L, and a degree d,NumInvau-
tomatically computes all equalities with degree up to dover the
numerical variables at L. (InSection5,wediscuss ouruseofa sin-
gle parameter that automatically adjusts the degree ddepending
ontheprogram).
/T_he ﬁrst steps are to identify the variables at the program lo-
cation of interest, and then to construct the terms and templ ate
as described above. /T_hen, in the ﬁrst loop, we use KLEE to ob-
tain traces to instantiate the template and thereby produce equa-
tionsoverthecoeﬃcientsassociatedwiththegeneratedter ms. To
obtain traces, we simply ask KLEE to ﬁnd cexs producing trace s
reaching L(morespeciﬁcally,thelocationguardedby ¬FalseatL).
To avoid ge/t_ting old inputs, weexplicitly ask KLEEto returno nly
new inputs (by adding assertions that the input variables ar e not
any of theobserved ones). A/f_terproducingenough equations, we
3NumInvalsofoundthisassertionandotherpostconditions at L2,butdiscardedthem
becausethey areimplied byother discoveredinvariantsand arethus redundant.input :a program P,a location L,a degree d
output:polynomial equalities overthevariablesat Luptodegree d
vars←extractVars(P,L)
terms←createTerms(vars,d)
template←createTemplate(terms)
inps,traces,eqts,invs←∅,∅,∅,∅
while|eqts|<|terms|do
cexInps←verify(P,L,False,inps)
ifcexInps≡∅then
ifinps≡∅then return{False}//unreachable
else return NotEnoughTraces
inps←inps∪cexInps
traces←exec(P,L,cexInps)
eqts←eqts∪instantiate(template,traces)
sols←solve(eqts)
candidates←extractEqts(sols,terms)
whilecandidates/nequal∅do
cexInps←verify(P,L,candidates ,inps)
foreachcandidate∈candidates do
ifcandidate .stat/nequalFalsetheninvs.add(candidate )
ifcexInps≡∅thenbreak
inps←inps∪cexInps
traces←exec(P,L,cexInps)
eqts←eqts∪instantiate(template,traces)
sols←solve(eqts)
candidates←extractEqts(sols,terms)
candidates←candidates−invs
returninvs
Figure2: CEGIRalgorithmfor ﬁndingequalities.
solvethemusinganoﬀ-the-shelflinearequationsolverand extract
resultsrepresenting candidateequalityrelations among t erms.
Next,thealgorithmentersasecondloopthatiterativelyve riﬁes
candidateinvariantsandobtainscextraces,allowingthei nference
algorithmtodiscardspuriousresultsandgeneratenew inva riants.
NumInvacceptsacandidateinvariantaslongasKLEEcannotﬁnd
acexforitwithinthetimeoutperiod. Werepeatthestepsofv erify-
ingcandidateinvariants,obtainingcexs,andinferringne wresults
untilwecan no longer ﬁndcexs ornew results.
Note that unlike the popular CEGAR (counterexample-guided
abstract reﬁnement) technique in static analysis [9] that u sually
startswithaweakinvariantandgraduallystrengthensit, NumInv’s
CEGIR algorithm starts with a strong invariant (i.e., False) and it-
eratively weakens it. /T_his is because the algorithm dynamica lly
infers invariants using observed traces. We start with few t races
andthuslikelygeneratetoostrongorspuriousinvariants. Wethen
accumulatemoretracestorefutespuriousresultsandcreat emore
general invariants thatsatisfy allobtainedtraces.
We also note that an interesting property of nonlinear polyn o-
mial equalities is that they can represent a form of disjunctive in-
variants. For example, x2=4 indicates that x=2∨x=−2. In
Section 5.2 we exploit this useful property to ﬁnd multiple c om-
plexityboundsofa program.Counterexample-GuidedApproach toFinding
Numerical Invariants ESEC/FSE’17,September4–8,2017,Paderborn,Germany
3.3 Example
We demonstrate this technique by ﬁnding the equalities b=/y.alta
andx=q/y.alt+ratlocation L1inthecohendiv program inFigure1,
when using degree d=2.
For the six variables {a,b,q,r,x,/y.alt}atL1, together with d=2,
wecreate28terms {1,a,...,/y.alt2}.NumInvusesthesetermstoform
thetemplate c1+c2a+...c28/y.alt2=0with28unknowncoeﬃcients ci.
Next,intheﬁrstloop, NumInvusesKLEEtoobtaintracessuchas
thosegiveninFigure1toform(atleast)28equations. Fromt hisset
of initial equations, NumInvsolves and extractsseven equalities.
NowNumInventersthesecondloop. Initeration#1,KLEEcan-
notﬁndcexsfortwoofthesecandidates x=q/y.alt+r,b=/y.alta(which
are actually true invariants) and save these as invariants. KLEE
ﬁnds cexs for the other ﬁve,4andNumInvforms new equations
fromthecexs. Next, NumInvcombinestheoldandnew equations
to obtain another seven candidates, two of which are the alre ady
savedones(becausewealsousetheoldequations). Initerat ion#2,
KLEE obtains cexs for the other ﬁve candidates. With the help of
the new cex equations, NumInvnow infers three candidates, two
of which are the saved ones. In iteration #3, NumInvuses KLEE
toﬁndcexsdisprovingtheremainingcandidateandagainuse sthe
newcexstoinfernewcandidates. /T_histime NumInvonlyﬁndsthe
twosaved invariants x=q/y.alt+r,b=/y.altaand thusstops.
4 INFERRING OCTAGONAL INEQUALITIES
a b c d e
Figure 3: (a) A set of points in 2D and its approximation us-
ingthe(b)polyhedral,(c)octagonal,(d)zone,and(e)inte rval
regions. /T_hese shapes are represented by the conjunctions
of inequalities of the forms c1/v.alt1+c2/v.alt2≥c,±/v.alt1±/v.alt2≥c,
/v.alt1−/v.alt2≥c, and±/v.alt≥c,respectively.
NumInv’ssecondalgorithmaimstoinferlinearinequalitiesamong
programvariables,essentiallybya/t_temptingtoﬁndaconvex poly-
hedron in a multi-dimensional space that contains all obser ved
trace points. Figure 3 illustrates several examples of poly gons in
two-dimensional space. Figure 3a shows a set of points creat ed
from input traces. Figures 3b, 3c, 3d, and 3e approximatethe area
enclosingthesepointsusingthepolygonal,octagonal,zon e,andin-
terval shapes that are represented by conjunctions of inequalities
of diﬀerent forms as shown in Figure 3. /T_hese forms of relation s
are sorted in decreasing order of expressive power and compu ta-
tional cost. For example, interval inequalities are less ex pressive
than zone inequalities, and computing an interval, i.e., th e upper
andlowerboundofavariable,costsmuchlessthancomputing the
convex hullof azone.
NumInvinfers octagonal inequalities. /T_hese can be computed
eﬃciently (linear time complexity) and are also relatively expres-
sive (e.g. represent zone and interval inequalities as illu strated in
4/T_hesespuriousresultso/f_tenhavemanytermsandlargecoeﬃcie nts,e.g.,thesimplest
of these sevenis r/y.alt2−x/y.alt2−72r/y.alt+72x/y.alt+8190q+1397r−1397x=0.Function findUpperBound( term,minV,maxV,P,L)
ifminV≡maxVthenreturn maxV
else ifmaxV−minV≡1then
cexInps←verify(P,L,{term≤minV},{})
ifcexInps≡∅then return minV
else return maxV
else
midV←⌈maxV+minV
2⌉
cexInps←verify(P,L,{term≤midV},{})
ifcexInps≡∅then
maxV=midV
else
//disproved
traces←exec(P,L,cexInps)
minV=max(instantiate (term,traces))
returnfindUpperBound( term,minV,maxV,P,L)
Figure4: CEGIRalgorithmfor ﬁnding inequalities.
Figure3). /T_hus,thecomputationofoctagonalinequalitiesa lsopro-
duceszoneandinterval inequalitiesforfree. Bybalancing compu-
tational cost with expressive power, octagonal relations a re espe-
cially useful in practice for detecting bugs in ﬂight-contr ol so/f_t-
ware, and performing array bound and memory leak checks [13,
32].
4.1 Terms
/T_heedgesofaninferredoctagonarerepresentedbyaconjunct ion
ofeight inequalities oftheform a1/v.alt1+a2/v.alt2≥k,where/v.alt1,/v.alt2are
variables, a1,a2∈{−1,0,1}arecoeﬃcients,and kis a real-valued
constant. For example, from the traces in Figure 1, we could i nfer
octagonal inequalities such as 4 ≤r≤15 and 3≤r−/y.alt≤13 at
locationL1.
NumInvinfers octagonalinequalities bytrying to prove invari-
antst≤kfor some constant k. Here,tis a term involving two
variables so that t≤kis an octagonal constraint, e.g., tcould be
x−/y.altorx+/y.alt. Moreprecisely,weconsiderallpossibletermsfor n
variables: wecreate n2variablepairs from aset of nvariables and
obtain8octagonalterms {±/v.alt1,±/v.alt2,±/v.alt1±/v.alt2}foreach pair /v.alt1,/v.alt2.
For each such term we a/t_tempt to prove its upper bound k1and
lower bound k2,if they exist,using thealgorithmdescribed next.
4.2 Algorithm
One idea for inferring inequalities would be to iteratively reﬁne
conjectured bounds using cexs, but this can take a long time. For
example,toﬁndtheinvariant x≤100,wecanﬁrstinfer x≤1from
tracessuchas x∈{0,1}. Wecanthendisprovethiscandidatewith
cexs such as x∈{2,3}and weaken the relation to x≤3, which
canalsobedisprovedandweakened. /T_hiskeepsgoinguntilweg et
thecexx=100,whichwouldallowustoobtainandprove x≤100.
Evenworsethantakingalongtimetoreachthebound k,thisbrute-
forceapproachdoesnotterminatewhen xhasnoconstant bound.
As such,weusea divide-and-conquer-style search instead.
FindingUpperand Lower Bounds. We use the CEGIR algorithm
showninFigure4tocomputeapreciseintegralupperbound kofaESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
termt. Similartoabinarysearch, thisalgorithmcomputes kfrom
agivenintervalbyrepeatedlydividinganintervalintohal vesthat
could contain k. We start with the interval [minV,maxV]where
maxV=−minV; our experience is that inequalities are most use-
ful with small constants, so by default we set maxV=10. Next
we check t≤midVwheremidV=⌈maxV+minV
2⌉. If this in-
equality is true, then kis at most midVand thus we reduce the
search to the interval [minV,midV]. Otherwise, we obtain coun-
terexample traces showing that t>midVand reduce the search
to[minV′,maxV],whereminV′isthelargesttracevalueobserved
fort. /T_hus this approach gradually strengthens the guess of kby
repeatedlyreducingtheinterval containing it.
Wealsousethesameapproachtoﬁndthelowerboundofaterm
tbycomputingtheupperboundof −t. /T_hisispossiblebecausethe
semantics and results of all computations are reversed when we
consider−t. For example, the max over the traces t∈{2,3}with
respect to−tis−2 and−t≤midVindicates the lower bound of t
is at least−midV.
/T_healgorithmterminatesandgivesapreciseupperboundvalu e
whentranges over the integers. /T_he algorithm stops when minV
andmaxVare the same (because we no longer can reduce the in-
tervals) or when their diﬀerence is one (because we cannot co m-
pute the exact midV). Currently NumInvdoes not support real-
valued bounds. However, we believe that this algorithm can b e
extended to handle the case when tranges over the reals. More
speciﬁcally, we can approximate the results by using only wh ole
numbersorvaluesuptocertaindecimalplaces. /T_hissacriﬁce spre-
cisionbutpreservessoundnessandtermination,e.g.,thei nvariant
isx≤4.123butweobtain x≤4.2,which is alsoan invariant, but
less precise.
4.3 Example
Recalltheprogram cohendiv fromFigure1. Suppose NumInvwishes
to ﬁnd inequality invariants at L1(within[−10,10]). It ﬁrst uses
KLEEtocheckcandidaterelations r≤10,/y.alt≤10,r+/y.alt≤10,r−/y.alt≤
10,...and removes those that KLEE refutes. /T_he remaining rela-
tions have upperboundsless thanorequalto10.
For each remaining inequality candidate, NumInviterates to
ﬁnd tighter upper bounds. For example, suppose we wish to ﬁnd
ksuch that r−/y.alt≤k. Sincer−/y.alt≤10, the algorithm sets
midV=(10+−10)÷2whichis0andthustriestocheck r−/y.alt≤0.
/T_his succeeds. However, this turns out to be weaker than nec-
essary. In the next iteration #2, NumInvtightens the bound to
(0−10)÷2=−5 and checks r−/y.alt≤−5. /T_his time KLEE returns
a cex showing that r−/y.alt=−3. In iteration #3, NumInvrelaxes
the boundto(0−3)÷2=−1 and KLEEcannot refute r−/y.alt≤−1.
In iteration #4, NumInvguesses and checks (−1−3)÷2=−2, in
whichcaseKLEEcanﬁndcexsstatingthat r−/y.alt=−1. Atthispoint
NumInvaccepts the tightest bound r−/y.alt≤−1 found in iteration
#3. /T_heprocessforﬁndingthelowerboundsissimilarasdescr ibed
above.
5 EXPERIMENTAL RESULTS
NumInvis implemented in Python and uses the linear equation
solverintheSAGEmathematicalenvironment[43]. NumInvtakes
asinputsaCprogram,alistoflocations,andinterestednum ericalvariables at these locations, and it returns relations amon g these
variables attheconsidered locations. As mentioned, NumInvuses
DIG’s algorithms to infer invariants and calls the symbolic execu-
tion tool KLEE to check results and obtain counterexamples f or
reﬁnement. /T_heﬁnal stepthatremoves redundant invariants u ses
theZ3solver [16]tocheck SMT formulas.
Wegeneratenumericalinvariantsoftwoforms: nonlinearpo ly-
nomialequationsandoctagonalinequalities. Foroctagona linvari-
ants,NumInvby default considers the bounds within the range
[−10,10]. For equalities, NumInvby default sets a single param-
eterα=200 so that it can generate invariants without a priori
knowledge of speciﬁc degrees. NumInvautomatically adjusts the
maximum degree so thatthe number of generated terms does not
exceedα. Forexample, NumInvconsidersequalitiesuptodegree5
foraprogramwithfourvariablesandequalitiesuptodegree 2for
a program with twelve variables. We acknowledge that inferr ing
theseparameterconstantsrobustlyandautomaticallyisim portant
future work. /T_hese constants can be chosen by the NumInvuser;
wechosevaluesbasedonourexperience. Notethatthedivide and
conquerapproachtoinferringinequalities inFigure4is qu iteuse-
ful if the user decides to increase the bounds; for range [−10,10]
the number of iterations is log(20)≈5 rather than 20 (if we use a
brute force algorithm) but for range [−100,100]it islog(200)≈8,
not200(using bruteforce).
Experiments. Weevaluateandcompare NumInvtootherinvari-
ant analysis systems by considering three experiments. /T_he ﬁ rst
experiment in Section 5.1 determines if NumInvcan discover in-
variantsrepresentingprecisesemanticsandcorrectnessp roperties
ofprogramshavingcomplexarithmetic. /T_hesecondexperimen tin
Section 5.2 explores the use of NumInv’s invariants to represent
precise program complexity bounds. /T_he last experiment in Se c-
tion5.3 compares NumInv’s performancewith thestateof theart
CEGIR toolPIE. /T_he experiments reportedbelow were performe d
ona Linux system witha 10-coreIntel i7 CPUand 32GB of RAM.
5.1 AnalyzingProgram Correctness
Programs. In this experiment, we focus on generating invari-
antsthatcapturesemanticsandcorrectnesspropertiesofp rograms
with nonlinear polynomial invariants. For this task, we eva luate
NumInvontheNLA [35] testsuiteconsisting ofprograms involv-
ingcomplexarithmetic. /T_hesuite,showninTable1,consists of27
programsfromvarioussourcescollectedpreviouslybyRodr ´ıguez-
CarbonellandKapur[7,8,39]. /T_heseprogramsarerelatively small,
onaveragetwoloopsof20linesofcodeeach. However,theyim ple-
ment nontrivial mathematical algorithms involving genera l poly-
nomial properties and are o/f_ten used to benchmark numerical i n-
variant analysis methods [7]. To the best of our knowledge, N LA
contains the largest number of numerical algorithms with no nlin-
ear polynomialinvariants.
EachprograminNLAcomeswithdocumentedorannotatedcor-
rectness assertions requiring polynomial invariants, mos tly loop
invariants having nonlinear polynomialequalities. Forev aluation
purposes, we consider invariants at the annotated location s and
comparethem tothedocumentedinvariants.Counterexample-GuidedApproach toFinding
Numerical Invariants ESEC/FSE’17,September4–8,2017,Paderborn,Germany
Table1: Resultsfor27NLAprograms. /check:NumInv generates
suﬃcientlystrong resultstoprove known invariants.
Prog Desc Locs V, T, D Invs Time (s) Correct
cohendiv div 2 6,3,2 11 24.57 /check
divbin div 2 5,3,2 12 116.83 /check
manna intdiv 1 5,4,2 5 30.86 /check
hard intdiv 2 6,3,2 13 71.47 /check
sqrt1 sqrroot 1 4,4,2 5 19.35 /check
dijkstra sqrroot 2 5,7,3 14 89.32 /check
freire1 sqrroot 1 - - - -
freire2 cubicroot 1 - - - -
cohencu cubicsum 1 5,5,3 5 22.56 /check
egcd1 gcd 1 8,3,2 9 284.52 /check
egcd2 gcd 2 - - - -
egcd3 gcd 3 - - - -
prodbin gcd,lcm 1 5,3,2 7 45.13 /check
prod4br gcd,lcm 1 6,3,3 11 87.37 /check
knuth product 1 8,6,3 9 84.69 /check
fermat1 product 3 5,6,2 26 185.36 /check
fermat2 divisor 1 5,6,2 8 101.83 /check
lcm1 divisor 3 6,3,2 22 175.29 /check
lcm2 divisor 1 6,3,2 7 163.86 /check
geo1 geoseries 1 4,4,2 7 24.41 /check
geo2 geoseries 1 4,4,2 9 24.33 /check
geo3 geoseries 1 5,4,3 7 32.38 /check
ps2 pow sum 1 3,3,2 3 17.08 /check
ps3 pow sum 1 3,4,3 4 17.86 /check
ps4 pow sum 1 3,4,4 4 18.55 /check
ps5 pow sum 1 3,5,5 4 19.36 /check
ps6 pow sum 1 3,5,6 3 21.09 /check
Results.Table 1 summarizes the results and reports the medi-
ans across 11 runs. Column Locsgives the number of locations
in the programs where we consider invariants. Column Invsre-
portsthenumberof equalityand inequalityinvariants disc overed
byNumInv. Column V, T, Dshows the number of distinct vari-
ables,terms,andthehighestpolynomialdegreeinthoseinv ariants.
ColumnTimereportsthetimeinsecondstogeneratetheseresults,
including thetime toremove redundant results. Column Correct
indicateswhethertheseinvariantsmatchedorwerestronge nough
toprove (imply) thedocumentedinvariants.
NumInvfoundinvariantsthatmatchedorweresuﬃcientlystrong
toprovethedocumentedinvariantsof23/27programsinNLA. For
theseprograms,wediscoveredresultsmatchedthedocument edin-
variantsexactlyaswri/t_teninmostcases. NumInvalsoachievedin-
variants thatarelogicallyequivalenttothedocumentedon es. For
example, sqrt1hastwodocumentedequalities2 a+1=t,(a+1)2=
s; our results gave 2 a+1=t,t2+2t+1=4s, which is equiva-
lent to(a+1)2=sby substituting twith 2a+1. In many cases,
NumInv also found undocumented invariants, e.g., most of the
discovered octagonal inequalities in the cohendiv program in Fig-
ure 1 are undocumented. For dijkstra,NumInv found the doc-
umented invariant describing the semantics of a loop comput a-
tion, but also discovered an undocumented loop invariant h3=
12hnq−16npq+hq2+4pq2−12hqr+16pqr. Manual analysis
shows that this strange relation is correct and captures det ailed
dependencies amongvariablesintheloop. /T_hus, NumInv’sstrongvoidtriple( intn,intm,intN){
assert (0 <= n && 0 <= m && 0 <= N);
inti = 0, j = 0, k = 0; intt= 0;
while(i < n){ //loop 1
j = 0; t++;
while(j<m){//loop 2
j++; k=i; t++;
while(k<N){k++; t++;}// loop 3
i=k;
}
i++;
}
[L]
}
Figure5: Anexampleprogramthathasmuliplepolynomial
complexitybounds.
invariants can help with understanding both whatthe program
does and also howthe program works. In Section 5.2, we further
exploitsuchcomplex invariants toanalyze programcomplex ity.
Fortheseprograms,theruntimeforﬁndingequalityinvaria nts
is dominated by solving equations because we are solving hun -
dredsofequationswithhundredsofunknownseachtime. /T_heru n
time signiﬁcantly improves if we restrict the search to inva riants
uptoa certaingiven degree. Forexample, NumInvtook2stoﬁnd
the invariants in sqrt1using degree 2, but it took 20s to ﬁnd the
same invariants using the parameter α=200, which queries Nu-
mInvfor all invariants up to degree 5 in this program. For egcd1,
therunning timeis also cutbymorethanhalf if weonlyfocuso n
quadratic invariants. For inequality invariants, the runn ing time
isdominatedbycheckingbecausewerapidlyguesstheboundv al-
uesandcheckthemwithKLEE.Moreover, NumInvhastoperform
this“guessandcheck”computationforoctagonalconstrain tsover
allpossiblepairs ofvariables.
Wewerenotabletoﬁndinvariants for4/27programs. NumInv
was able to infer results matching the documented invariant s for
freire1andfreire2, but KLEE cannot run on these programs be-
causetheycontainﬂoatingpointoperations. For egcd2andegcd3,
theunderlyingSAGEequationsolverstoppedrespondingfor more
thanhalfofthe11runs(thoughweobservedallcorrectresul tsfor
the runs during which the solver worked). /T_hese problems migh t
occur because the solver has to consider hundreds of equatio ns
withvery largecoeﬃcients forhundreds of unknowns. Wearei n-
vestigating and reportingthese problemstotheSAGE develo pers.
5.2 AnalyzingComputational Complexity
WeuseNumInvtodiscoverinvariantscapturingaprogram’scom-
putationalcomplexity, e.g., O(n3)wherenis some input. Figure 5
shows the program triplewith three nested loops, adapted from
the program in Figure 2 of Gulwani et al.[26]. /T_he complexity of
thisprogram,i.e.,thetotalnumberofiterationsofallthr eeloopsat
locationL, appears to be O(nmN)at ﬁrst glance. Additional anal-
ysis yields a more precise bound of O(n+mn+N)because theESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
number of iterations of the innermost loop is bounded by Nin-
stead ofnmNand it furthermoredirectlyaﬀects the running time
of theoutermostloop[26].
Whengiventhisprogram, NumInvdiscoversaninterestingand
unexpectedpostconditionatlocation Laboutthecountervariable
t, which is a ghost variableintroducedtocountloopiteratio ns:
N2mt+Nm2t−Nmnt−m2nt−Nmt2+mnt2+Nmt
−Nnt−2mnt+Nt2+mt2+nt2−t3−nt+t2=0.
At ﬁrst glance, this quartic (degree 4) equality with 15 term s
looksincomprehensibleandquitediﬀerentthantheexpecte dbound
O(n+mn+N)orevenO(mnN).However,solvingthisequationfor
t,i.e., ﬁndingtheroots,yieldsthreesolutions t=0,t=N+m+1,
andt=n−m(N−n). Careful analysis reveals that these results
actuallydescribe threedistinctand exactboundsof this pr ogram:
t=0 when n=0,
t=N+m+1 when n≤N,
t=n−m(N−n)whenn>N.
/T_hus,NumInvcanﬁndnumerical invariants thatrepresent pre-
ciseprogramcomplexity. Moreimportantly,theobtainedre lations
candescribeexpressiveandnontrivial disjunctive invariants,which
capturediﬀerent possiblecomplexityboundsofa program.
Programs. We apply NumInvto ﬁnd complexity invariants on
programs adapted from [25–27].5/T_hese programs, shown in Ta-
ble2,aresmall,buttheyhave nontrivialstructuressuchas nested
loopsand represent examples drawnfrom Microso/f_t’s product ion
code [26]. For these programs, we introduce the counter vari able
tandobtainrelations among tand othervariables,suchasinputs,
at theprogramexit locations.
Results.Table2showsthemedianresultsacross11runsandhas
similarformatasthatofTable1. Forcolumn Bound,acheckmark
denotes that NumInvgenerates invariants representing a similar
boundtotheonereportedintherespectivepaper. Adoublech eck-
mark(/check/check)denotesthat NumInvobtainsmoreinformativebounds
than reportedresults. A checkmark with anasterisk ( /check∗) denotes
that theprogram was modiﬁedslightly toassist theanalysis .
As can be seen, NumInvproduced very promising results that
capture the precise complexity bounds for these programs. F or
18/19 programs, NumInvdiscovered expected or even more infor-
mative bounds than reported results in the respective paper s. For
many programs, NumInvgenerated equalityinvariants represent-
ing tight bounds, which can be combined with the discovered o c-
tagonalinequalitiestoproduceexpectedbounds. Forexamp le,for
popl09fig34,NumInvobtained that the number of iterations tis
eithernorm. In addition, NumInvﬁnds inequalities expressing
thattis larger than both nandm, suggesting that tis equal to
max(n,m),whichistheboundalsoobtainedin[27]. /T_hus,inequal-
ities, though appearing much weaker compared to the obtaine d
equalities,playanimportantroletoachieve preciseprogr amanal-
ysis.
Interestingly, in some cases, NumInvproduced results that are
more informative than the ones given in the respective paper s.
5Wedisablenondeterministicfunctionsintheseprogramsbe causecurrently NumInv
assumesdeterministic programs.Table 2: Results for computing programs’ complexities. /check:
NumInv generates the expected bounds. /check/check:NumInv ob-
tains more informative bounds than reported results. /check∗:
program wasslightly modiﬁedtoassistthe analysis.
Prog V, T, D Invs Time (s) Bound
cav09ﬁg1a 2,5,2 1 14.35 /check
cav09ﬁg1d 2,5,2 1 14.24 /check
cav09ﬁg2d 3,2,2 3 36.09 /check
cav09ﬁg3a 2,2,2 3 14.24 /check
cav09ﬁg5b 3,5,2 5 46.88 /check∗
pldi09ex6 3,8,3 7 54.18 /check
pldi09ﬁg2 (triple) 3,15,4 6 93.55 /check/check
pldi09ﬁg41 2,3,1 3 44.26 /check
pldi09ﬁg42 4,4,2 5 43.72 /check
pldi09ﬁg43 3,3,2 3 37.54 /check
pldi09ﬁg44 5,4,2 4 56.60 -
pldi09ﬁg45 3,4,2 3 31.60 /check∗
popl09ﬁg21 5,12,3 2 211.73 /check/check
popl09ﬁg22 4,9,3 2 65.17 /check/check
popl09ﬁg34 3,4,3 4 54.70 /check
popl09ﬁg41 3,3,2 2 42.76 /check∗
popl09ﬁg42 5,12,3 2 158.3 /check/check
popl09ﬁg43 3,3,2 5 39.28 /check
popl09ﬁg44 3,3,2 3 34.28 /check
/T_hisisparticularlythecasefortheprogram tripleanalyzedearlier
becausethethreedistinctboundsproducedby NumInvarestrictly
lessthanthebound n+mn+Ngivenin[26]. Wenotethatinmost
othercaseswhere NumInvobtainedabe/t_terbound,thediﬀerences
were notas apparent as they were for triple.
We performed some adaptations in certain programs to assist
the bound analysis. For cav09fig5b, we considered the invariant
obtained as one close to the expected bound. For popl09fig41,
weinsertedanassertstatementthat m≥0atthebeginning ofthe
program. Finally, for pldi09fig45, for the number of iterations t
we obtained the three solutions t=n−m,t=m, ort=0, which
implythecorrectupperbound max(0,n−m,m).
Finally,NumInvobtainedinvariantsthatarenotstrongenough
toshowtheexpectedboundfor pldi09fig44. However,wewould
haveobtainedthisboundifwehadintroducedavariable(ora term)
representing thequotientfromthedivisionof twoothervar iables
in the program. In our experiments, when inserting such a var i-
able,weobtainedboundsthatweretighterthantheonespres ented
in[26]. Suchcasessuggestapossibleextensionto NumInvforpre-
dictinguseful terms.
5.3 Comparing toPIE
NumInvautomaticallygeneratesinvariantsforaprogramlocation
withoutanygivenassertionsorpostconditions. Otherstat e-of-the-
artCEGIRtoolssuch as PIE generate invariants ina goal-dir ected
manner, driven by supplied postconditions. In this experim ent,
we compare NumInvwith PIE’s guided inference with postcondi-
tions. /T_his experiment used the HOLA benchmark programs [17]
(adapted by the developers of PIE). /T_hese programs, shown in T a-
ble 3, are short (10-40 LoC each) C programs already annotate d
withpostconditions.Counterexample-GuidedApproach toFinding
Numerical Invariants ESEC/FSE’17,September4–8,2017,Paderborn,Germany
Table 3: Results for the HOLA benchmarks [17]. /check: Made
invariantsfromPIE. /check/check: MadestrongerinvariantsthanPIE.
Anasterisk∗indicatesthatverifyingtheinvariantrequired
additional investigation. ◦: Failed to make any invariants,
no running timereportedinthat case.
Benchmark PIEtime (s) NumInv time (s) Correct
01 21.88 8.75 /check/check
02 36.12 10.35 /check
03 56.28 108.20 /check/check
04 19.11 NA◦
05 25.19 13.20 /check/check
06 61.98 14.67 /check*
07 NA 16.83 /check
08 19.02 31.49 /check/check*
09 NA 30.19 /check
10 24.6 NA◦
11 27.95 NA◦
12 44.52 NA◦
13 NA 19.33 /check
14 25.98 11.65 /check/check
15 48.30 7.7 /check
16 33.19 29.07 /check
17 53.36 10.33 /check/check
18 21.70 7.7 /check/check
19 NA 25.79 /check
20 331.93 104.40 /check/check
21 25.65 11.60 /check*
22 25.40 10.90 /check
23 23.40 9.07 /check/check
24 51.22 NA◦
25 NA 16.76 /check
26 87.64 13.50 /check
27 55.41 376.80 /check
28 22.16 NA◦
29 58.82 NA◦
30 33.92 NA◦
31 88.10 20.39 /check
32 226.73 NA◦
33 NA 48.04 /check*
34 121.87 12.20 /check/check
35 20.07 13.23 /check
36 NA 14.98 /check
37 NA 14.23 /check/check∗
38 37.37 10.83 /check
39 24.68 2.39 /check
40 60.71 17.07 /check*
41 34.10 15.47 /check /check*
42 54.93 13.13 /check /check*
43 21.16 11.3 /check
44 31.92 12.3 /check
45 84.00 15.3 /check
46 27.56 NA◦
We ﬁrst ran PIE on each program and recorded PIE’s running
timeinseconds. /T_hen, weremoved thepostconditionand ran Nu-
mInv, asking it to generate invariants at the location in the pro-
gram where the postcondition was. If NumInvwas able to gen-
erate invariants, we compared those invariants to the postc ondi-
tion. Iftheinvariants that NumInvgenerated wereatleastpreciseenough toestablish thegiven postcondition,then NumInvearned
a checkmark ( /check). If the invariants were more precise, then Nu-
mInvearnedadoublecheckmark( /check/check). Fortheprogramsthat Nu-
mInvcould not generate invariants, then the analysis is assigne d
thesymbol◦. /T_he resultsare inTable3.
For36/46programs, NumInvfoundinvariantsthatwereatleast
as strong as the postconditions in the PIE programs. For the r e-
maining 10/46 programs, NumInvfailed to producethe necessary
invariants. For 13 of the 36 programs where NumInvproduced
invariants, NumInvwas able to generate stronger invariants. For
example,forprogram17,thetargetpostconditionwas k≥ngiven
a precondition n≥0, andNumInvproduced,among other invari-
ants, that k=(n3−n+6)/6, which implies that for all n≥0,
k≥n.
For programs having the /check∗or/check/check∗,NumInvfound stronger
invariants that imply the given postcondition, but require addi-
tional human eﬀort to reason about. For program 42, the given
postconditionis a% 2=1, i.e.,ais odd.NumInvfound theinvari-
antsx/y.alt=x+/y.alt−1,u1−a≤−2,a=x+/y.alt−1,and2u1=x+/y.alt−2.
/T_hissetofconstraintsimpliesthat x+/y.alt=2(u1+1)anda=x+/y.alt−1,
which indicates that ais indeed odd. Buttheﬁrstinvariant inthis
set produced by NumInv, also points to another relation among
those variables, namely that at least one of xand/y.altis equal to 1,
and thus we marked this example with a double checkmark and
additionallyannotated it withanasterisk.
Anotherinterestingcaseiswithprogram8thatcontainsapo st-
condition x<4∨/y.alt>2, which has a disjunctive form of strict
inequalities that NumInvdoes not support. Instead of generating
this,NumInvreturns astronger relation x≤/y.alt,which impliesthis
postconditionand therefore proves it.
Summary. /T_hese experiments show that NumInvis eﬀective in
producing expressive and useful invariants. /T_he NLA experim ent
in Section 5.1 shows that NumInvdiscovers necessary invariants
to understand the semantics and check correctness properti es of
23/27 NLA programs containing nontrivial arithmetic. /T_he Co m-
plexityexperiment inSection5.2 indicates that NumInvdiscovers
useful invariants that capture challenging complexity bou nds for
18/19programsusedtobenchmarkstaticcomplexityanalyse s. We
alsonotethattherecent CEGIRtoolsICEandPIEcannot ﬁndan y
of these nonlinear polynomial invariants produced by NumInvin
these experiments, even when we explicitly tell these tools that
they should a/t_tempt to verify these invariants. Finally, the HOLA
experiment inSection5.3 showsthat NumInvcompeteswell with
PIE and in 36/46 programs discovers invariants that match or are
moreinformative thanPIE’s.
5.4 /T_hreats to Validity
Asmentionedearlier, NumInvcanreturn unsoundresultsbecause
KLEEcannotfullyverifyprogramswithcomplexpolynomialp rop-
erties. We can recover soundness by using a true veriﬁer inst ead,
e.g., weareconsidering theveriﬁcationtoolsCPAChecker [ 4]and
Ultimate Automizer [28], which performed well in the recent SV-
COMP2017[3]. However,ourexperienceshowsthatKLEEiseﬀe c-
tiveinﬁndingcounterexamplesdisprovinginvalidresults andthus
results that KLEE cannot disprove have high likelihood of be ingESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
correct. KLEEisalsopracticalbecauseitcanconsiderchal lenging
invariants that arenot understandabletomany soundveriﬁe rs.
KLEE does not fullysupportﬂoating point arithmetic and thu s
NumInvislimitedtoﬁndinginvariantsoverintegralvariables. KL EE
is also language dependent, thus NumInvconsiders only C pro-
grams. Weareextending NumInvwithadditionalveriﬁcationback-
ends that supportricher semantics (e.g., arithmetic over t hereals)
and other languages (e.g., JPF [24] forJava programs).
DIG’s algorithms focus on specialized classes of numerical in-
variants, thus NumInvis unlikelytoﬁndinvariants ofother,unre-
latedforms. However,ourresultsshowthat NumInvcano/f_tengen-
erateinvariants thatarelogicallyequivalentorsuﬃcient lystrong
toprove otherforms ofcomplex invariants, e.g., disjuncti ve ones.
Although our benchmark programs have nontrivial structure s
(e.g.,nestedloops)withcomplexarithmeticandhavebeenu sedto
evaluatemoderninvariantgenerationsystems,theseprogr amsare
smallanddonotrepresentreal-worldapplicationscontain inghun-
dreds of thousands of lines of code. Nonetheless, we believe that
CEGIR is a promising approach to build invariant analysis to ols
thatcanscaleandhandlelargerandmorecomplexcodebases. /T_his
isbecausedynamic analysis allowsforinferring expressiv e invari-
ants eﬃciently fromtraces andstaticcheckers such asKLEEh ave
becomemorepowerfuland practicalinrecent years.
6 RELATED WORK
Wereviewrelatedinvariantgenerationtechniquesusingpu restatic
analysis, dynamic analysis, and CEGIRapproaches.
Static invariant generation. Abstract interpretation [11, 12, 14]
computesaninvariant thatover-approximates reachablepr ogram
states. /T_his method starts from a weak invariant representin g an
initial approximation and iteratively strengthens the inv ariant by
analyzingthestructureoftheprogramuntilreachingaﬁxed point.
Over-approximation can lead to imprecise information and p ro-
duce false positive errors. /T_hus, major research directions in this
area focusonﬁnding abstractdomains thataresuﬃcientlyexpres-
sivetoretainimportantinformationfromtheprograms. For exam-
ple,theworkin[13,32]focusonthesix-edged zonerelation s and
theeight-edge octagonrelations shownin Figure 3.
Rodr´ıguez-Carbonell et al.[7, 8, 39] use abstract interpretation
to generate nonlinear polynomial equalities. /T_hey ﬁrst obse rve
that a set of polynomial invariants forms the algebraic stru cture
of an ideal, then compute the invariants using Gr ¨obner basis and
operations over the ideals, based on the structure of the pro gram
until reaching a ﬁxed point. /T_he work only analyzes programs
with assignments and loop guards that are expressible as pol yno-
mial equalities. In addition, this technique does not ﬁnd in equali-
ties and doesnotsupportprograms withnested loops.
Dynamicinvariantgeneration. /T_hepopulartoolDaikon[18–21,
38]infers candidate invariants from traces and templates. Daikon
comeswithalargelistofinvarianttemplatesandteststhem against
programtraces. Templatesthatareviolatedinanyofthetes truns
are removed and the remainders are presented as the possible in-
variants. For numerical relations, Daikon can ﬁnd linear re lationsover at most three variables and has a small number of ﬁxed non -
linear polynomial templates such as x=/y.alt2. In general, the tool
has limitedsupportforinequalities and disjunctive invar iants.
CEGIRApproaches. Sharmaetal.[42]presenta Guess-and-Check
technique for inferring equality invariants. /T_his techniqu e is the
standardCEGIRapproach,andthe“guess”componentinferse qual-
itiesusingthesimilarequationsolvingtechniqueinDIG./T_h usfor
equality,thistechniquehasthesametheoreticalpoweras NumInv.
/T_he “check” component uses the Z3 SMT solver, and in this con-
text,itisinterestingtonotethevariousdiﬀerencesinrun ningtime
caused by the diﬀerent choices made in the la/t_ter and our imple -
mentation, and speciﬁcally the use of KLEE instead of Z3. /T_his
Guess-and-Check approach is limited to equality relations and, as
mentioned in Section 4.2, it is not trivial to extend to ﬁndin g in-
equalityinvariants.
/T_he PIE (Precondition Inference Engine) tool [37] can gener-
atebothpreconditionsandloopinvariants toautomaticall yverify
given assertions. Given an assertion Q, the goal is to produce a
predicate formula suﬃciently strong to ensure the assertio n. To
do this, PIE iteratively learns and reﬁnes a set of features ( pred-
icates over inputs such as x>0) that are suﬃciently strong to
separate“good” traces satisfying Qand “bad” traces violating Q.
/T_hese predicates form the required precondition that proves the
assertion. /T_henoveltyofPIEisthatitdoesnotrelyonaﬁxedc lass
ofpredicatesandcanconstructnecessarypredicatesdurin gthein-
ference process. Nonetheless, the tool cannot provide inva riants
for arbitrary locations in the program, especially if no add itional
assertions are given. More speciﬁcally, on the cohendiv example
inFigure 1,PIE didnot converge toaninvariant.
/T_he ICE (implication counter-example) learning model [23] i s
alsoaCEGIRapproachthatgeneratesinductiveinvariantst oprove
given assertions. /T_he“student”usesadecisionlearning alg orithm
toguesscandidateinvariantsexpressedoverpredicates,w hichsep-
arate the good and bad traces. /T_he “teacher” uses the Boogie ve r-
iﬁer to check and provide good, bad, and novel implication co un-
terexamplestohelpthestudentinfermorepreciseinductiv einvari-
ants. For eﬃciency, they restrict a/t_tention to the octagon do main
andsearch onlyforpredicatesthatarearbitrarybooleanco mbina-
tionsofoctagonalinequalities. SimilartoPIE,ICEinfers onlynec-
essary invariants to prove assertions. Even when provided w ith
assertions such as the postconditions of the program cohendiv in
Figure 1, ICE fails to prove them. We note that part of the reas on
mightbebecauseICEdoesnotsupportarithmeticoperations such
as divisionand modulo.
7 CONCLUSION
Wepresent NumInv,a CEGIR-basedtoolthatdiscovers numerical
invariantsatarbitraryprogramlocations. NumInvusesadynamic
analysistoinferinvariantsandthetest-inputgeneration toolKLEE
toverify them. For invalid invariants, KLEEreturns counte rexam-
ple traces that are then used to help the inference algorithm dis-
cardinvalidresultsandtoﬁndnewinvariants. /T_heuseofKLEE al-
lowsNumInvtoworkonprogramswithnontrivialarithmeticand
discover useful and complex invariants. Preliminary exper imentsCounterexample-GuidedApproach toFinding
Numerical Invariants ESEC/FSE’17,September4–8,2017,Paderborn,Germany
show that NumInvo/f_ten outperforms state-of-the-art CEGIR sys-
temsindiscoveringinvariantsrequiredtounderstandanda nalyze
semantics, correctness,and complexitypropertiesof prog rams.
ACKNOWLEDGMENTS
Wethanktheanonymousreviewersfortheirdetailedfeedbac kand
helpful comments. /T_his research was supportedbyDARPA under
contractsFA8750-15-2-0104and FA8750-16-C-0022.REFERENCES
[1] Timos Antonopoulos, Paul Gazzillo, Michael Hicks, Eric Koskinen, Tachio Ter-
auchi,andShiyiWei.2017. Decompositioninsteadofself-c ompositionforprov-
ingthe absenceof timing channels. In PLDI. 362–375.
[2] /T_homasBallandSriramK.Rajamani.2001. Automatically V alidatingTemporal
Safety Properties of Interfaces. In SPIN Symposium on Model Checking of So/f_t-
ware.Springer,103–122.
[3] Dirk Beyer. 2017. So/f_tware Veriﬁcation with Validation o f Results. In TACAS.
Springer,331–349.
[4] Dirk Beyer and M. Erkan Keremoglu. 2011. CPAchecker: A To ol for Conﬁg-
urableSo/f_twareVeriﬁcation.In CAV.Springer,184–190.
[5] Bruno Blanchet, Patrick Cousot, Radhia Cousot, Jerome F eret, Laurent
Mauborgne, Antoine Min´ e, David Monniaux, and Xavier Rival . 2003. A Static
AnalyzerforLargeSafety-CriticalSo/f_tware.In PLDI. 196–207.
[6] CristianCadar, Daniel Dunbar, and Dawson R Engler. 2008 . KLEE: Unassisted
and Automatic Generation of High-Coverage Tests for Comple x Systems Pro-
grams..In OSDI,Vol. 8.USENIX Association, 209–224.
[7] EnricRodr´ ıguezCarbonell.2006. Automaticgenerationofpolynomialinvariants
for system veriﬁcation . Ph.D. Dissertation. Technical University of Catalonia,
Barcelona,Spain.
[8] EnricRodr´ ıguezCarbonellandDeepakKapur.2007. Gene ratingallpolynomial
invariants in simple loops. Journal of Symbolic Computation 42, 4 (2007), 443–
476.
[9] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. 2000. C ounterexample-
guided abstractionreﬁnement.In CAV.Springer,154–169.
[10] Edward Cohen. 1990. Programmingin the 1990s: An introduction to the calcula-
tionof programs . Springer.
[11] P. Cousot and R. Cousot. 1976. Static Determination of D ynamic Properties of
Programs.In International Symposiumon Programming .106–130.
[12] PatrickCousot and Radhia Cousot. 1977. Abstract inter pretation: a uniﬁed lat-
tice model for static analysisof programsby construction o r approximationof
ﬁxpoints. In POPL. ACM,238–252.
[13] Patrick Cousot, Radhia Cousot, Jerˆ ome Feret, Laurent Mauborgne, Antoine
Min´ e, David Monniaux, and Xavier Rival. 2005. /T_he Astr´ ee an alyzer. In ESOP.
Springer,21–30.
[14] Patrick Cousot and Nicolas Halbwachs. 1978. Automatic discovery of linear
restraintsamong variablesof aprogram.In POPL. ACM,84–96.
[15] ManuvirDas,SorinLerner,andMarkSeigle.2002. ESP:p ath-sensitiveprogram
veriﬁcationinpolynomial time. In PLDI. 57–68.
[16] Leonardo DeMouraand NikolajBjørner.2008. Z3: Aneﬃci ent SMTsolver. In
TACAS.Springer,337–340.
[17] IsilDillig,/T_homasDillig,Boyang Li,and KenMcMillan. 2013. Inductive Invari-
ant GenerationviaAbductiveInference. In OOPSLA.443–456.
[18] Michael D. Ernst. 2000. Dynamically detecting likely program invariants . Ph.D.
Dissertation.Universityof Washington.
[19] Michael D Ernst, Jake Cockrell, William G Griswold, and David Notkin. 2001.
Dynamically discovering likely program invariants to supp ort program evolu-
tion.TSE27,2 (2001), 99–123.
[20] MichaelD.Ernst,Adam Czeisler,WilliamG.Griswold,a ndDavidNotkin.2000.
/Q_uicklydetecting relevantprograminvariants.In ICSE.ACM,449–458.
[21] Michael D. Ernst, Jeﬀ H. Perkins, Philip J. Guo, Stephen McCamant, Carlos
Pacheco, Ma/t_thew S. Tschantz, and Chen Xiao. 2007. /T_he Daikon s ystem for
dynamicdetectionoflikelyinvariants. ScienceofComputerProgramming (2007),
35–45.
[22] J´ erˆ omeFeret.2004. Static analysisof digital ﬁlter s. InESOP.Springer,33–48.
[23] PranavGarg, Daniel Neider,P. Madhusudan, and DanRoth . 2016. Learning In-
variantsUsingDecisionTreesandImplicationCounterexam ples.InPOPL.499–
512.
[24] /T_he Java Pathﬁnder group. 2017. JPF: Java PathFinder. (2 017).
h/t_tp://babelﬁsh.arc.nasa.gov/trac/jpf/.
[25] Sumit Gulwani. 2009. SPEED: Symbolic Complexity Bound Analysis. In CAV.
51–62.
[26] Sumit Gulwani, Sagar Jain, and Eric Koskinen. 2009. Con trol-ﬂow Reﬁnement
and ProgressInvariants forBound Analysis.In PLDI. 375–385.
[27] Sumit Gulwani, Krishna K. Mehra, and Trishul M. Chilimb i.2009. SPEED: pre-
cise and eﬃcient static estimation of program computationa l complexity. In
POPL.127–139.
[28] Ma/t_thiasHeizmann, Jochen Hoenicke, and Andreas Podels ki. 2010. Nested in-
terpolants. In POPL. ACM,471–482.
[29] /T_homasA. Henzinger,Ranjit Jhala,RupakMajumdar,and G regoireSutre.2002.
LazyAbstraction.In POPL.ACM,58–70.
[30] JanHoﬀmann, Klaus Aehlig, and MartinHofmann. 2012. Re source Aware ML.
InCAV.781–786.
[31] Xavier Leroy. 2006. Formal certiﬁcation of a compiler b ack-end or: program-
mingacompiler with aproof assistant.In POPL.ACM,42–54.
[32] Antoine Min´ e. 2004. Weakly relational numerical abstract domains . Ph.D. Dis-
sertation. ´Ecole Polytechnique, France.ESEC/FSE’17,September4–8,2017,Paderborn,Germany Than hVu Nguyen, Timos Antonopoulos, Andrew Ruef,and Michael Hick s
[33] VanChanNgo,MarioDehesa-Azuara,Ma/t_thewFredrikson, and JanHoﬀmann.
2017. Verifying and Synthesizing Constant-Resource Imple mentations with
Types.In 2017IEEESymposium on Security and Privacy . 710–728.
[34] /T_hanhVu Nguyen. 2014. Automating Program Veriﬁcation and Repair Using In-
variant Analysis and Test-input Generation . Ph.D. Dissertation. University of
NewMexico.
[35] /T_hanhVuNguyen,DeepakKapur,WestleyWeimer,andSteph anieForrest.2012.
UsingDynamicAnalysistoDiscoverPolynomial andArrayInv ariants.In ICSE.
IEEE, 683–693.
[36] /T_hanhVuNguyen,DeepakKapur,WestleyWeimer,andSteph anieForrest.2014.
DIG: A Dynamic Invariant Generator for Polynomial and Array Invariants.
TOSEM23,4 (2014), 30:1–30:30.
[37] Saswat Padhi, Rahul Sharma, and Todd Millstein. 2016. D ata-driven Precondi-
tion Inferencewith LearnedFeatures.In PLDI.42–56.
[38] JeﬀH.PerkinsandMichaelD.Ernst.2004. EﬃcientIncre mentalAlgorithmsfor
DynamicDetectionof LikelyInvariants.In FSE.23–32.[39] E. Rodr´ ıguez-Carbonell and D. Kapur. 2007. Automatic Generation of Polyno-
mial Invariants of Bounded Degree Using Abstract Interpret ation.Science of
ComputerProgramming 64,1(Jan. 2007), 54–75.
[40] MardavijRoozbehani,EricFeron,andAlexandreMegres tki.2005.Modeling,Op-
timizationand ComputationforSo/f_twareVeriﬁcation.In HybridSystems: Com-
putation and Control .ACM,606–622.
[41] Sriram Sankaranarayanan, Henny B. Sipma, and Zohar Man na. 2005. Scal-
able analysis of linear systems using mathematical program ming. In VMCAI.
Springer,25–41.
[42] Rahul Sharma, Saurabh Gupta, Bharath Hariharan, Alex A iken, Percy Liang,
and Aditya V Nori. 2013. A data drivenapproach for algebraic loop invariants.
InESOP.Springer,574–592.
[43] W. A. Stein and others. 2017. Sage Mathematics So/f_tware. (2017).
h/t_tp://www.sagemath.org.