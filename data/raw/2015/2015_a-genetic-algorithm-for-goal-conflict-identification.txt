A Genetic Algorithm for Goal-Conflict Identification
Renzo Degiovanni
Universidad Nacional de Río Cuarto
Argentina
rdegiovanni@dc.exa.unrc.edu.arFacundo Molina
Universidad Nacional de Río Cuarto
and CONICET, Argentina
fmolina@dc.exa.unrc.edu.ar
Germán Regis
Universidad Nacional de Río Cuarto
Argentina
gregis@dc.exa.unrc.edu.arNazareno Aguirre
Universidad Nacional de Río Cuarto
and CONICET, Argentina
naguirre@dc.exa.unrc.edu.ar
ABSTRACT
Goal-conflictanalysishasbeenwidelyusedasanabstractionfor
riskanalysisingoal-orientedrequirementsengineeringapproaches.
In this context, where the expected behaviour of the system-to-be
is captured in terms of domain properties and goals, identifying
combinations of circumstances that may make the goals diverge,
i.e., not to be satisfied as a whole, is of most importance.
Variousapproacheshavebeenproposedinordertoautomatically
identifyboundaryconditions,i.e.,formulascapturinggoal-divergent
situations, but they either apply only to some specific goal expres-
sions,orareaffectedbyscalabilityissuesthatmakethemapplicable
onlytorelativelysmallspecifications.Inthispaper,wepresenta
novel approach to automatically identify boundary conditions, us-
ingevolutionarycomputation.Moreprecisely,wedevelopagenetic
algorithmthat,giventheLTLformulationofthedomainproperties
and the goals, it searches for formulas that capture divergences in
the specification. We exploit a modern LTL satisfiability checker
to successfully guide our genetic algorithm to the solutions. Weassess our technique on a set of case studies, and show that our
geneticalgorithmisabletofindboundaryconditionsthatcannot
be generated by related approaches, and is able to efficiently scale
toLTLspecificationsthatotherapproachesareunabletodealwith.
CCS CONCEPTS
•Software and its engineering →Requirements analysis ;
Risk management ;Search-based software engineering ;•Theory of
computation →Modal and temporal logics ;
KEYWORDS
Goal Conflicts, Genetic Algorithms, LTL Satisfiability
ACM Reference Format:
Renzo Degiovanni, Facundo Molina, Germán Regis, and Nazareno Aguirre.
2018.AGeneticAlgorithmforGoal-ConflictIdentification.In Proceedings
of the 2018 33rd ACM/IEEE International Conference on Automated Software
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238220Engineering(ASE’18),September3–7,2018,Montpellier,France. ACM,New
York, NY, USA, 12pages.https://doi.org/10.1145/3238147.3238220
1 INTRODUCTION
The requirements process is a key stage in many software develop-
mentprocesses,whosemainconcernsarethecorrectunderstand-
ing of the problem to be solved by the system-to-be (as well as
the corresponding problem domain), and its detailed specification
[20,27,52]. In general, understanding the objectives of a system to
be developed is not straightforward, and demands comprehensive
elicitation activities, to arrive to an explicit requirements specifica-
tion.Andarrivingtoarequirementsspecificationisanimportant
milestone in the requirements process, that enables a number of
furtheranalysistasksthatcanbeperformedonthespecification,
to understand the interactions between different system goals, po-
tential contradictions and obstacles to requirements fulfilment, etc.
[52].
When requirements are expressed using some formallanguage,
specificationscanoftenbesubjecttocertainautomatedanalyses,
tofindflawsandimprecisions.Forinstance,checkingforrequire-
ments satisfiability corresponds to ascertaining the absence of con-
tradictions in requirements. But such an analysis is only able to
find the simplest kinds of problems in requirements satisfaction;many times requirements are indeed satisfiable as a whole, but
admit situations where goals diverge, i.e., where the satisfaction of
some system goals inhibits the satisfaction of others. Identifyingthese circumstances early in the development process is of mostimportance, since it enables one to improve specifications, take
countermeasures tothese situations, and moredeeply understandthe roots for potential system goal unsatisfiability.
Variousapproacheshavebeenproposedinordertoautomatically
identifygoal-divergentsituationsinthecontextofgoal-orientedrequirements engineering. These divergences, known as bound-
aryconditions,havesomeparticularities,thatmakethemdifficult
to detect. Firstly, they capture goal divergences through formu-
las, not simple specification states, that are consistent with thedomain properties, but imply the violation of the system goals.
Secondly, they characterise subtlegoal violations, in the sense that
they cannot be simple negations of goals, and they only lead tothe unfulfilment of the goals when these are jointly considered,
i.e.,ifasinglegoalisremoved,thewholesituationbecomessatis-
fiable. Existing techniques to identify boundary conditions havelimitations. Some techniques follow a pattern-based mechanism
520
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
forboundaryconditionidentification[ 53],andthusonlyapplyto
somespecificgoalexpressions,whenthesearespecifiedinacertain
syntacticway.Otherapproachesarebasedonmoresophisticated
logical mechanisms, that process certain semantic constructions
generatedfromgoalsanddomainproperties,inordertoidentify
boundary conditions [ 13]; these, on the other hand, are affected by
scalabilitylimitationsoftheunderlyinglogicalmechanisms,that
make them applicable only to relatively small specifications.
Inthispaper,wepresentanovelapproachtoautomaticallyiden-
tify boundary conditions, using evolutionary computation. This
approachoutperformsrelatedtechniquesthroughthedevelopment
of a genetic algorithm that, given the LTL formulation of the do-
mainpropertiesandthegoals,searchesforformulasthatcapture
divergences in the specification. This algorithm exploits a mod-ern LTL satisfiability checker to successfully guide the genetic
search toward suitable solutions. Our evaluation, based on various
case studies taken from the literature, shows that this evolutionary
mechanism is able to find boundary conditions that cannot be gen-
erated by related approaches, and is able to efficiently scale to LTL
specifications that other approaches are unable to deal with.
The remainderof thepaper isorganised asfollow.Section 2in-
troduces preliminary concepts about Goal-Oriented Requirements,
Linear-Time Temporal Logic and Genetic Algorithms, necessary
in the paper. Section 3 presents an illustrating example, used to
motivatetheapproach.Section4describestheapproachindetail.In
Section 5 we validate our technique, by applying it to various case
studies, as well as comparing the approach with related techniques
in terms of efficiency and effectiveness. Finally, we discuss related
workinSection6,anddrawsomeconclusionsanddescribelines
of further work in Section 7.
2 BACKGROUND
2.1 Goal-Oriented Requirements
Goal-OrientedRequirementsEngineering(GORE)[ 52]drivesthe
requirements process in software development from the definition
of high-level goals, that state how the system to be developed
shouldbehave.Goalsareprescriptivestatementsthatthesystem
must achieve through the collaboration of cooperating agents, that
mightincludehumans,hardwaredevicesandofcoursethesoftware
system,withinagivendomain.Thisdomainmustalsobeexplicitly
characterised,via descriptive statementsabouttheproblemworld,
suchasnaturallaws,collectivelyreferredtoas domainproperties.
Within this context, a goal model consists of a decomposition of
goals via refinements, capturing how a goal can be fulfilled in
terms of simpler ones. Goal refinement terminates when every leaf
subgoal can be assigned to a single agent, that will be in charge of
guaranteeingitsachievement(agentsfeatureoperations,through
which they must fulfil the goals).
Generally, the description of software requirements can be inad-
equateforvariousreasons.Forinstance,assuminganunrealistic
benevolentbehaviouroftheenvironmentcanmakethegoalstoo
ideal to be met.Also, some unanticipated casescan make a require-
ments specification incomplete. Even the goals themselves may be
inconsistent as a whole, i.e., they may not be jointly satisfiable.
In GORE methodologies, dealing with the above-cited kind of
problems,asearlyaspossible,isofmostimportance.The conflictanalysis phase [52,54] deals with these issues, through three main
stages:(1)theidentification stage, which consists of identifying
conflictsbetweengoals(i.e.,conditionsthat,whenpresent,make
the goals inconsistent); (2)theassessment stage, consisting of as-
sessingandprioritisingtheidentifiedconflictsaccordingtotheir
likelihoodandseverity;and (3),theresolution stage,whereconflicts
areresolvedbyprovidingappropriatecountermeasuresand,con-
sequently, transforming the goal model, guided by the criticality
level obtained during assessment.
Thispaperfocusesonthe identification stage,withtheprovision
ofanautomatedmechanismforgoalconflictdiscovery.A conflict
essentially represents a condition whose occurrence results in the
loss of satisfaction of the goals, i.e., that makes the goals diverge
[53]. More formally, given a set G1,...,Gnof goals and a set Dom
ofdomainproperties,thesearesaidtobe divergent ifandonlyif
there exists an expression BC, called a boundary condition, such
that the following conditions hold:
{Dom,BC,/logicalandtext
1≤i≤nGi}|=false, (logical inconsistency )
{Dom,BC,/logicalandtext
j/nequaliGj}/negationslash|=false,for each 1≤i≤n(minimality )
BC/nequal¬(G1∧...∧Gn) (non-triviality )
Intuitively,aboundaryconditioncapturesaparticularcombination
of circumstances in which the goals cannot be satisfied as a whole.
Thefirstconditionestablishesthat,when BCholds,theconjunction
of goalsG1,...,Gnbecomes inconsistent. The second condition
states that, if any of the goals is disregarded, then consistency is
recovered.Thethirdconditionprohibitsaboundaryconditionto
be simply the negation of the goals. Also, due to the minimality
condition, it cannot be false(it has to be consistent with the do-
mainDom). Section 3provides an illustrating example, that further
explains the intuition behind boundary conditions.
Typically,formalrequirementsengineeringmethodologiesadopt
alogicalformalismtopreciselycapturethedesiredsystemgoals
anddomainproperties.Forinstance,theKAOSmethod[ 52]uses
Linear-Time Temporal Logic [ 38] for formally specifying software
requirements. Employing a formal language to specify software
requirementsenablestheuseof(semi-)automatedanalysismech-
anisms,toassessspecifications.Forinstance,ifLTLformulasare
used to specify requirements, one may use automated LTL satis-fiability solvers to check for the feasibility of the corresponding
requirements. As we will describe in detail later on, we will exploit
efficientLTLsatisfiabilitysolverstoautomaticallycheckwhether
generated candidate formulas satisfy or not the conditions to be
valid boundary conditions.
2.2 Linear-Time Temporal Logic
Linear-Time Temporal Logic (LTL) [ 38] is a logical formalism that
hasbeenextensivelyemployedtostatepropertiesofreactivesys-
tems, and more recently, for specifying software requirements [ 52].
LTLassumesthatthestructureoftimeislinear,i.e.,eachinstantof
timeisfollowedbyauniquefutureinstant.ThesyntaxofLTLformu-
las is inductively defined using a set APof propositional variables,
the standard logical connectives and temporal operators /circlecopyrtandU,
as follows: (i)b∈Bis an LTL formula, where B={true,false};(ii)
everyproposition p∈APisanLTLformula,and (iii)ifφ1andφ2
521
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. A Genetic Algorithm for Goal-Conflict Identification ASE ’18, September 3–7, 2018, Montpellier, France
areLTLformulas,thensoare ¬φ1,φ1∨φ2,φ1∧φ2,/circlecopyrtφ1andφ1Uφ2.
We consider the usual definition for the operators 2(always), 3
(eventually),R(release)andW(weak-until)intermsof /circlecopyrt,U,and
logical connectives.
LTLformulasareinterpretedoverinfinitetracesofpropositional
valuations.Let σbeaninfinitetrace.Formulaswithnotemporal
operators are evaluated in the first state of σ. On the other hand,
/circlecopyrtφis true in σif and only if φis true in σ[1..] (the trace obtained
byremovingthefirststate from σ),andφ1Uφ2istruein σifand
only if there exists a position isuch that φ2holds inσ[i..], and for
all 0≤j<i,φ1holds inσ[j..].
The satisfiability problem for LTL consists of checking, given
anLTLformula φ,ifthereexistsatleastonetrace σthatmakes φ
hold,i.e., φevaluatestotruein σ.LTLsatisfiabilityisa decidable
problem [ 46], and there exist various tools that implement LTL
satisfiability checking, so called LTL SAT solvers. As we explain
later on in the paper, such tools are central to our evolutionary
computation approach, since LTL SAT solving is employed as part
of the fitness computation in the search for boundary conditions.
We refer the reader to [ 37] for further details on linear-time
temporal logic.
2.3 Genetic Algorithms
Geneticalgorithms[ 23]areheuristicsearchalgorithms,inspired
innaturalevolution.Asopposedtomoretraditionalsearchalgo-
rithms, that maintain a single “current” candidate solution during
the search space traversal, a genetic algorithm operates on a popu-
lationof candidate solutions to a given problem. These candidates
are called individuals orchromosomes, and are often represented as
sequencesof genes(characteristics)thatcapturetheirfeatures.A
geneticalgorithmstartswithaninitialpopulationofindividuals,
whose individuals are produced in some arbitrary way, e.g., ran-
domly, and explores the search space by iteratively evolvingthe
population,tryingtogenerateapopulationcontaininganindividual
that represents a solution to the problem. At each iteration of this
evolution process, members of the current population are selected
to make the population evolve, by producing further individuals
using two genetic operators: crossover, that produces new individu-
als by combining parts of existing ones, and mutation, that creates
new individuals by randomly producing changes on existing ones.
The selection of individuals to which the genetic operators will be
applied, as well as the selection of individuals to be discarded after
each iteration, are guided by a fitness function. A fitness function is
a heuristic function that measures how “fit” a particular individual
is, i.e., how close a given candidate is to being an actual solution
to the problem being solved. The evolution process is usually per-
formedadefinednumberofiterations(knownas generations ofthe
population), or until some termination criterion is met.
As it will be described in later sections, we will employ genetic
algorithmstosearchforboundaryconditionsofgoal-orientedre-
quirements specifications. Thus, individuals will in our case rep-
resentLTLformulas,thegeneticoperatorswillproduceformulas
from other formulas, and the fitness function should attempt to
evaluate how “close” a formula is to being a boundary condition.
For further details on genetic algorithms, we refer the reader
to [40].3 MOTIVATION
Inthissection,wewillillustratethrougharunningexampleboth
the problem we tackle in this paper, and the main ideas behind our
approach based on a genetic algorithm. The example we will use is
asimplerailroadcrossingsystem(RRCS)[ 6].Inthismodel,atrain
mayapproachandenteracrossing;theseeventsarecapturedby
two propositions, taandtc, respectively. A car may also approach
and enter the crossing, and these events are captured by caandcc,
respectively. The crossing gate may be opened ( дo) or closed (¬дo).
Whenever the train is approaching, the gate should be closed, and
itwillbereopenedafterthetrainhasleftthecrossing.Ontheother
hand, whenever a car approaches the crossing, it will be able to
cross only if the gate is open. Let us assume that from the analysis
oftheabovestatements,thefollowinggoalsanddomainproperties
have been elicited:
Domain property: TrainsDoNotStop
FormalDef :2(/circlecopyrt(tc)↔ta)
Domain property: CarsCrossWhenGateIsOpened
FormalDef :2(/circlecopyrt(cc)→ca∧дo)
Goal: Avoid[Collision ]
FormalDef :2¬ (tc∧cc)
Goal: Maintain[ClosedGateWhenTrainApproaching ]
FormalDef :2(ta→¬дo)
Notice that the specification is consistent, i.e., all goals can simulta-
neouslybesatisfied,forinstancewhennotrainandnocarapproach
the crossing. However, this specification can exhibit some conflicts,
inparticularwhenthecontrolleropensthegateatthesametime
that the train is crossing (i.e., дo∧tc), enabling an approaching car
tocrossaswell,andconsequentlytocollisionwiththetrain(i.e.,
cc∧tc). This conflicting situation can be characterised by a bound-
arycondition,inthiscase (дo∧tc)W (cc∧tc).Boundaryconditions
generaliseconflictingsituations,bycapturingsimilarcontending
scenariosbyformulasinthesamelanguageusedtoexpressgoals
and domain properties. Both identifying conflicting situations and
devising corresponding boundary conditions are non-trivial tasks
(recall in particular the conditions that formulas must satisfy to
be boundary conditions). In this work, we propose using a genetic
algorithm to automatically discover boundary conditions from a
formal goal model, with goals and domain properties expressed in
LTL. The algorithm deals with a very large search space of LTL
formulas,builtthrougha syntactic manipulationoftheformaldo-
mainpropertiesandgoals.Letusprovidesomeintuitiononhow
our approach works.
Intuitively,achromosomeinourgeneticalgorithmrepresents
anLTLformula φ,insuchawaythateachgeneofthechromosome
characterises a sub-formula of φ. We consider as the initial popula-
tion of our genetic algorithm the set of all sub-formulas that can
be built from the domain properties and the goals, and their corre-
spondingnegations.Forinstance,fromthegoal ClosedGateWhen-
TrainApproaching ofourrunningexample,thechromosomesthat
characterisethefollowing5sub-formulasarecreated: 2(ta→¬дo),
ta→¬дo,ta,¬дoandдo;aswellastheircorrespondingnegations:
¬2 (ta→¬дo),¬(ta→¬дo)and¬ta(noticethat, дoand¬дohave
already been considered).
522
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
Inordertoobtainnewindividualstomakethepopulationevolve,
some chromosomes are selected at each iteration, and some ge-
netic operators are applied to these. In particular, our genetic algo-
rithmimplementsthetwomostcommongeneticoperators,namely,
crossover andmutation operators. Given two chromosomes c1and
c2,thecrossoveroperatorwillproduceanewchromosome c3using
parts ofc1andc2. For instance, if chromosomes c1andc2char-
acterise the LTL formulas дoandtc, respectively, our crossover
operatorcanproduceanewchromosomebycombiningbothfor-
mulas using some binaryoperator, such that дo∧tc. On the other
hand,givenachromosome c1,themutationoperatorwillcreatea
newchromosome c2byrandomlychangingsomegenesof c1.Forin-
stance,ifchromosome c1characterisestheLTLformula 2¬ (tc∧cc),
a particular mutation can be performed, that removes the 2opera-
tor, obtaining the formula ¬(tc∧cc).
In a genetic algorithm, the population iteratively evolves guided
byafitnessfunction,whoseaimistoevaluateindividuals,giving
higher scores to “better” individuals, i.e., those closer to sought for
solutions.Thishastheaimofguidingthegeneticalgorithmtogen-
eratinganindividualthatrepresentsasolutiontotheproblembeing
solved. In our case, the fitness function performs a number of SAT
calls, to an LTL SAT solver, in order to check, given a chromosome,
whether it meets all the conditions to be a boundary condition for
the requirements specification or not. At the end of each iteration,
those chromosomes with best fitness are selected to move to the
next iteration.
Let us consider a specific example, to show how our genetic
operatorsmayleadtoboundaryconditions.Considertheboundary
condition (дo∧tc)W (cc∧tc)for the specification of the rail-
road crossing system. The following trace of the genetic algorithm
exemplifies how this particular formula may be generated:
(1)Initializethepopulationwiththesetofallsub-formulasof
the specification, and their negations. In particular, proposi-
tionsдoandtcwill be characterised by some chromosomes
c1andc2, respectively.
(2)Then, assume that our algorithm selects both chromosomes
c1andc2toapplythecrossoveroperator,producinganew
chromosome c3; in this particular combination, the ∧opera-
tor is employed, obtaining the LTL formula (дo∧tc).
(3)Now assume that chromosome c/prime
1characterising the goal
2¬ (tc∧cc )(itwillcertainlybeintheinitialpopulation),isse-
lectedfortheapplicationofamutation,inparticularonethat
acts by removing the temporal operator 2; we then obtain a
new chromosome c/prime
2that characterises formula ¬(tc∧cc).
(4)Nowthealgorithmselectschromosome c/prime
2andappliesamu-
tationoperatorsimilartothepreviouslymentioned,butthis
time it removes the ¬logical operator, leading to chromo-
somec/prime
3, that characterises the formula (tc∧cc).
(5)Finally,thealgorithmselectschromosomes c3andc/prime
3toapply
the crossover operator that combines them with the W
operator, obtaining a new chromosome c4representing our
target boundary condition: (дo∧tc)W (cc∧tc).
Ofcourse,theabove“trace”isoneveryspecific,ofthemanythat
the genetic algorithm may involve. The same boundary condition
may be produced with other different paths, and more importantly,
manymorepathswillneverproducetheboundarycondition.Toguideittoourdesiredformulas,thefitnessfunctionplaysavery
important role (as well as the crossover and mutation operators in
thedefinitionofthesearchspace),aswellasotherparametersofthe
algorithm,likethemutationandcrossoverrates,populationsize,
individualselectionapproach,numberofgenerationstoconsider,
etc.Thefollowingsectionwillprovidefurtherdetailsonallthese
aspects of our genetic algorithm for boundary condition discovery.
4 A GENETIC ALGORITHM FOR
IDENTIFYING BOUNDARY CONDITIONS
As we mentioned in previous sections, the objective of our genetic
algorithm is to find situations that capture divergences in the LTL
formulationoftherequirementsspecification.Inordertoexpress
such situations in the same formalism, the search space of our
algorithm is composed of LTL formulas. The next sub-subsections
detailtherepresentationofthecandidateLTLformulasassequences
of genes as well as the main components of the algorithm.
4.1 Chromosome Representation
To represent an LTL formula as a chromosome, i.e., a vector of
genes, we first translate the formula to its definitional conjunctive
normal form (dCNF) [ 47]. This gives us a simple and intuitive way
ofsplittingLTLformulasintosub-formulas,inordertogenerate
their corresponding chromosomes.
Given an LTL formula φ, whereAPis the set of propositional
variables used in φ, letX={x0,x1,...}be a set of fresh proposi-
tional variables, such that, AP∩X=∅. Then, according to [ 47],
dCNFaux (φ)isasetofconjuncts,definedover AP∪X,suchthat
eachconjunctrepresentsofasub-formula ψofφ.dCNFaux (φ)is
definedinductivelyonthestructureofthesub-formula ψasfollows:
ψ Conjunct in dCNFaux (φ)
bwithb∈B xψ↔b
pwithp∈AP x ψ↔p
o1ψ/primewitho1∈{¬,/circlecopyrt,3,2} xψ↔o1xψ/prime
ψ/primeo2ψ/prime/primewitho2∈{∨,∧,U,R,W}xψ↔xψ/primeo2xψ/prime/prime
Thus,the definitionalconjunctivenormalform ofφcanbedefined
in the following way:
dCNF (φ)≡xφ∧2/logicalandtext
c∈dCNF aux (φ)c
Given the dCNFrepresentation of φ, we can directlybuild the
chromosome representing φas follows:
[c1,c2,...,ck] where each ci∈dCNFaux (φ)
Noticethat,asopposedtowhatiscommoningeneticalgorithms,
thesechromosomes havevaryinglengths, sincedifferent LTLfor-
mulascanhaveadifferentamountofconjunctsintheircorrespond-
ing dCNF representations.
4.2 Initial Population
Since the initial population is a sample of the search space, the
routineusedforgeneratingitplaysanimportantrole.Takingad-
vantageoftheformulaspresentinthedomainpropertiesaswellas
thegoalsofthegivenspecification,wedefinethesetofformulas
S=Dom∪Gand calculate the set of sub-formulas SF (ψ), for each
ψ∈S, using the following recursive definition:
523
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. A Genetic Algorithm for Goal-Conflict Identification ASE ’18, September 3–7, 2018, Montpellier, France
ψ=borpwithb∈B,p∈AP :SF (ψ)={ψ}
ψ=o1ψ/primewitho1∈{¬,/circlecopyrt,3,2}:SF (ψ)={ψ}∪SF (ψ/prime)
ψ=ψ/primeo2ψ/primewitho2∈{∨,∧,U,R,W}:SF (ψ)={ψ}∪SF (ψ/prime)∪SF (ψ/prime/prime)
Havingtheset SF (S)ofallsub-formulasofeach ψ∈S,theinitial
population of individuals is defined to be the following set IP:
IP=SF (S)∪{¬s|s∈SF (S)}
Basically, the initial population is the set of all the sub-formulas,
as well as their negations, that can be obtained from the domain
properties and the goals of the specification.
4.3 Fitness Function
SinceeachchromosomeinthepopulationrepresentsanLTLfor-
mula that is a candidate boundary condition for the current specifi-
cation, the purpose of our fitness function is to evaluate how close
is the formula to being an actual boundary condition. By using the
definition in Section 2.1, we can exactly determine when a formula
is a boundary condition or not. Given a chromosome cof length lc
representingtheLTLformula φc,thefitnessvaluefor ciscomputed
by the following function f:
f(c)=li(φc)+|G|/summationtext
i=1min (φc,Gi)+nt(φc)+1
lc
where the functions li,minandntare defined as follows:
li(φc)=⎧⎪⎪⎨⎪⎪⎩1i f{Dom,φc,/logicalandtext
1≤i≤nGi}|=false
0 otherwise
min (φc,Gi)=⎧⎪⎪⎪⎨⎪⎪⎪⎩1
|G|if{Dom,φc,/logicalandtext
j/nequaliGj}/negationslash|=false
0 otherwise
nt(φc)=⎧⎪⎨⎪⎩0.5i fφc/nequal¬(G1∧...∧Gn)
0 otherwise
Intuitively,thefirstthreetermsofthefunction fcapturetheproper-
tiesthataformulamustsatisfyinordertobeaboundarycondition,
namely the logical inconsistency ( li), the minimality ( min) and the
non-triviality( nt).Withtheaimofimprovingthereadabilityofthe
producedboundaryconditions,thelasttermofthefunctionapplies
a penalty related to the formula length, that makes the genetic
algorithm to tend to produce smaller formulas. Of course, this isa secondary issue, and this is why it only contributes a fractionto the fitness value, as opposed to the actual driving acceptance
criterion,namely,theclosenessoftheformulatothesatisfaction
of the properties to be a valid boundary condition.
4.4 Genetic Operators
Inordertoexplorethesearchspace,ourgeneticalgorithmimple-
mentsacrossoveroperator andamutationoperator ,bothadaptedto
our chosen chromosome representation.
Giventworandomlyselectedchromosomes c1andc2,represent-
ingtheLTLformulas φ1andφ2,respectively,our crossoveroperator
creates a new chromosome cn, whose corresponding LTL formula
φnis calculated by applying one of the following operations:
(1)φn=φ1o2φ2, whereo2∈{∨,∧,U,R,W};
(2)φn=φ1[s2/s1], wheres1∈SF (φ1)ands2∈SF (φ2).Basically,case(1)correspondstorandomlytakingabinaryoperator
o2∈{∨,∧,U,RW},tocreateanewLTLformula φ1o2φ2,interms
offormulas φ1andφ2.Ontheotherhand,case(2)correspondsto
randomly taking a sub-formula s1ofφ1and a sub-formula s2of
φ2,andcreatinganewformula φn,basedon φ1,butreplacingits
sub-formula s1bys2(i.e.,φ1[s2/s1]).OncethenewLTLformula φn
has beenbuilt, the newchromosome cnis created,as described in
Section4.1.
In contrast to the crossover operator, that applies at the chro-
mosome level, the mutation operation applies to randomly selected
genesofachromosome,i.e.,itworksatthegenelevel.Recallthat
each gene of a chromosome characterises a formula φ, that is a
particularconjunctofthedCNFrepresentationof φ.Then,genes
have the generic form xψ↔ψ. In order to apply a mutation and
maintainavaliddCNFrepresentation,ourmutationoperationonly
alterstheformula ψofthegene,obtaininganewformula ψ/prime.Let
дbe a gene representing the conjunct xψ↔ψ. Our mutation
operation is defined inductively on the shape of ψ, as follows:
•ifψ=borψ=p, whereb∈Bandp∈AP, then:
(1)ψ/prime=b/prime, whereb/prime∈B
(2)ψ/prime=r, wherer∈APandr/nequalp
(3)ψ/prime=¬ψ
•ifψ=o1xψ1, whereo1∈{¬,/circlecopyrt,3,2}, then:
(1)ψ/prime=xψ1
(2)ψ/prime=o/prime
1xψ1whereo/prime
1∈{¬,/circlecopyrt,3,2}ando/prime
1/nequalo1
(3)ψ/prime=¬ψ
•ifψ=xψ1o2xψ2, whereo2∈{∨,∧,U,R,W}, then:
(1)ψ/prime=xψrwherexψr∈{xψ1,xψ2}
(2)ψ/prime=xψ1o/prime
2xψ2whereo/prime
2∈{∨,∧,U,R,W}ando/prime
2/nequalo2
(3)ψ/prime=¬ψ
It is important to note that, for each case of ψ, all the mutations
have the same probability to be chosen. In the case that ψis equal
to a boolean value or a proposition, the possible mutations to be
appliedconsistofreplacing ψbytrue,false,orbyitsnegation,or
byadifferentproposition.Incasethat ψisaunaryformula,then
thepossiblemutationstobeappliedarethedeletionoftheunary
operator from the formula, the replacement of the unary operator
byadifferentone,orjustthenegationof ψ.Similarly,if ψisabinary
formula,thepossiblemutationstobeappliedconsistofremoving
the binary operator, and in this case, one of the operands shouldbe chosen as the new
ψ/prime, or replacing the binary operator by a
different one, or just negating ψ.
Typically, how many crossovers are applied per generation, and
with which probability a gene is mutated, are parameters that one
is allowed to configure in a genetic algorithm, to improve effec-
tiveness and efficiency. Our genetic algorithm considers the %10 of
the population size to be the number of times that the crossover
operatorisappliedpergeneration.Forinstance,ifthepredefined
populationsizeis100,thenourgeneticalgorithmwillperform10
crossoverspergeneration.Ontheotherhand,givenachromosome
c, withlcbeing the number of genes of c, our genetic algorithm
considers1 /lcastheprobabilitywithwhichagenewillbemutated.
Thismeansthat,inthelongterm,onegeneperchromosomewill
be mutated.
Finally, after applying the fitness function on each chromosome
in the population, some of them should be selected to survive to
524
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
the next generation. Our algorithm uses a very simple selection
operator,basedonsortingtheindividualsofthecurrentpopulation
by its fitness values in decreasing order, and selecting as many
individuals as the set maximum population size. We also experi-
mented with the use of other known selection algorithms, such
asthetournamentselector,butinourcasestudieswealwaysgot
betterresultswiththe“bestfitness”selector.Inthefollowingsec-
tion, we assess the performance of our algorithm in case studies
of varying complexities, as well as its effectiveness in relation to
other techniques.
4.5 Correctness and (In)completeness
Let us now discuss the correctness and (in)completeness of our
approach.Regardingcorrectness,ourapproachresultstobe correct,
i.e.,ifthegeneticalgorithmfindsaformulathatissolutionofthe
problem,thenthisisindeedavalidboundarycondition.Noticethat,asitwasexplainedinSection 4.3,thefitnessfunctionofthegenetic
algorithm performs, for each candidate solution, a number of SAT
checksinordertodetermineifthecandidateformulasatisfiesor
not all the properties to be a boundary condition. Then, by relying
onthecorrectnessofthesatisfiabilitysolverforLTLusedforthis
task, Aalta [34] in our case, our genetic algorithm is correct.
Regardingcompleteness,sinceourgeneticalgorithmimplements
anon-exhaustive search, our approach results to be incomplete, i.e.,
there may exist some boundary conditions that are not be vis-
ited/considered by our genetic algorithm. Ho wever, it is important
to remark that our genetic operators are complete, in the sensethat, given two formulas
φandψover the same set APof propo-
sitions,ψcanbeproducedfrom φbytheapplicationofcrossover
and mutation, provided a sufficiently large chromosome size. Thus,
allformulasover thesamevocabulary,that fitintothepredefined
chromosome size, can theoretically be produced by our genetic
algorithm.
5 VALIDATION
Inthissectionweevaluateourgeneticalgorithmwiththeaimof
answering the following research questions:
RQ1Howeffectiveandefficientisourapproachtoidentifyboundary
conditions in requirement specifications?
RQ2Is our approach able to identify boundary conditions that can-
not be derived by related techniques?
In order to answer RQ1, we consider various requirement speci-
ficationstakenfromtheliteratureanddifferentbenchmarks,that
feature both safety and liveness goals, and evaluate our geneticalgorithmforidentifyingboundaryconditions.InSection 5.1we
presentthe experimentalevaluation onseveralcase studiestaken
from[5,13,53],previouslyusedforassessingarelatedtechniquefor
computingboundaryconditionsbasedonatableauxsatisfiability
checking algorithm. In addition, we take several case studies used
intheReactiveSynthesisCompetition(SYNTCOMP)[ 2],publicly
availableat[ 3],whichareconsiderablelargerspecificationsthan
those taken from the literature that we mentioned before. These
largerspecificationswillbeusedforassessingthescalabilityofour
genetic algorithm.
ToanswerRQ2,inSection 5.2webrieflyintroducetwopreviously
developed techniques for identifying boundary conditions, namely,a pattern-based approach [ 53] and a tableaux-based approach [ 13],
and compare the boundary conditions computed by our genetic
algorithm against those obtained by the previous techniques.
We analyse the obtained results in Sections 5.3and5.4, and
discuss the scalability and applicability of our genetic algorithm.In particular, we argue about the different options that one canconfigure to run the genetic algorithm and how they may affectits efficiencyand effectiveness.Wealso discuss somecontexts in
which the computed boundary conditions can be used, in addition
tothe mostcommonone,duringthe identify-assess-controlcycle
intheriskanalysisofrequirementsspecifications.Inparticular,we
studythepossibilityofusingboundaryconditionsforexplaining
thecauseofunrealisablespecifications,inthecontextofautomated
synthesis.
Toperformtheexperimentalevaluation,weimplementedour
geneticalgorithmusingtheJavaGeneticAlgorithmsPackageLi-
brary (JGAP) [ 1], and integrating the LTL2Büchi library [ 21]t o
parse LTL requirements specifications, and the LTL satisfiability
checkerAalta[ 34],toperformalltheSATchecksrequiredbythe
fitnessfunction.Thetool,thespecificationsforallcasestudies,and
a description of how to reproduce the experiments can be found in
the replication package1. All the experiments were run on an Intel
Corei73.2Ghz,with16GbofRAM,runningGNU/Linux(Ubuntu
16.04).
5.1 Case Studies
We evaluate our genetic algorithm on the following case studies:
the Rail Road Crossing System [ 6], the Mine Pump Controller [ 32],
anelevatorcontroller[ 15],theATM[ 51],theTCPnetworkproto-
col, the London Ambulance Service (LAS) [ 19], the Telephone [ 18],
and the three patterns for deriving boundary conditions presented
in [53] (Achieve, Retraction1, and Retraction2). Moreover, we con-
sider the specification of a lift controller taken from [ 5], and some
specifications of the SYNTCOMP Repository [ 3], namely, three
variants ofthe arbitersynchronization protocol(simple,prioritized
and round-robin), the ARM’s Advanced Microcontroller Bus Archi-tecture (AMBA), and a load balancer protocol for mutual exclusion.
Table1summarisestheresultsoftheexperimentalevaluationof
our genetic algorithm. First, we report the size of the specification,
i.e., the number of goals and domain properties, and the size of
the initial population (I.P.) generated from such a specification. For
each case study, we ran the algorithm 10 times, with a limit of50 generations, i.e., 50 evolutions of the genetic algorithm popu-
lation.Noticethatwedistinguishbetweenthenumberofrunsin
which the genetic algorithm succeeded by identifying at least one
boundarycondition,andthenumberofrunsinwhichthealgorithm
didnotidentifyanyboundarycondition.Forallofthesuccessful
runs,wereporttheminimum,maximumandaveragenumberof
generations,andthecorrespondingtimeinseconds,requiredfor
learningtheboundarycondition.Inparticular,wefocusonthecostofcomputingthefirstsolution(thenumberofgenerationsandtime
– inseconds – requiredto get asuitable boundary condition),and
thecostofcomputingthe“best”solution:noticethatthealgorithmcontinuesrunningfor50iterations,tryingtooptimisetheboundary
conditions collected so far, e.g., by making them more compact.
1https://dc.exa.unrc.edu.ar/staff/rdegiovanni/ASE2018.html
525
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. A Genetic Algorithm for Goal-Conflict Identification ASE ’18, September 3–7, 2018, Montpellier, France
Table 1: Evaluation of our Genetic Algorithm for Identifying Boundary Conditions
BCs successfully found No BC found
Case Study First Solution Best Solution –
min max avg min max avg –
Spec. Name #Dom#Goals I.P.#RunsGen time Gen time Gen time Gen time Gen time Gen time #Runsavg time
RRCS 2 240872 11 4 92 92 50 20 36 17 2 28
MinePump 1 2341031 17 12 62 31 38 24 18 7 0 0
ATM 1 232910 18 8 62 20 48 16 20 7 1 27
Elevator 1 1221010 10 10 10 10 10 0 0
TCP 0 224951 39 9 13 3 14 4 50 18 30 10 1 3
Telephone 3 242344 28 29 14 14 21 29 78 86 30 53 7 44
LAS 0 552318 599 37 2355 26 1551 38 3431 47 18403 44 8491 74202
AchieveAvoidPattern 1 2321010 82 41 30 26 11 13 5 0 0
RetractionPattern1 0 2181041 38 14 12 4 51 50 29 25 17 0 0
RetractionPattern2 0 222810 25 9 72 61 39 28 24 16 2 38
Round Robin Arbiter 6 394911 32 45 71 22 83 26 32 46 275 38 152 1170
Simple Arbiter 4 3128 811 245 43 386 28 383 11 245 43 386 29 406 21007
Prioritized Arbiter 6 184415 257 42 523 30 7428 31 512 50 33687 43 8770 61582
Load Balancer 3 8102 315 185 44 9215 34 5253 44 6359 48 11262 46 6578 712595
AMBA 621362 624 3162 43 16342 30 7100 26 3162 49 7128 33 7541 411216
LiftController 712160 518 765 47 9690 34 2716 18 2126 47 9690 34 2853 522397
As our experiments show, our genetic algorithm can effectively
compute boundary conditions for all of the case studies we consid-
ered. In the case of small specifications, like the RRCC, Minepump,
etc., it can be very efficient, finding the first solution (i.e., a bound-
ary condition) in a few generations. Of course, as the specification
becomes more complex, the genetic algorithm needs more itera-
tions tobuild richerformulas that leadus toboundary conditions,
and consequently, it requires much more time. For instance, the
worstcasewereportedisforcomputingthebestsolutionforthe
Prioritized Arbiter protocol: our genetic algorithm required 33687
seconds, i.e., more than 9 hours. However, in average the perfor-
manceofthealgorithmisacceptable,consideringthatitcanhandle
specificationswithtensofformulas,thatnootherrelatedtechnique
can analyse.
5.2 Comparison with Related Techniques
ToanswerRQ2,wenowcompareourapproachwithtworelated
techniquesforcomputinggoalconflicts.Thefirstoneisaformal
approach [ 53] that requires matching goals against a set of pre-
defined divergence patterns, for which boundary conditions are
provided. It provides three different patterns, namely, the Achieve-
Avoid pattern, and two versions of the Retraction pattern. The first
differencearisesfromthenumberofboundaryconditionsprovided
by each technique. Table 2summarises the number of boundary
conditions learnt by our genetic algorithm. While patterns are de-
signedtoprovideonlyoneboundaryconditionpereachdivergence
pattern, notice that our approach identifies several boundary con-
ditions,thatevidencemultipledivergencesituationsthatarenot
contemplated by the patterns. However, it is important to mention
thatinthecaseoftheAchieve-AvoidandRetraction2patterns,one
boundaryconditioncomputedbyourapproachisequivalenttothat
providedbythepatterns.Ontheotherhand,despitethefactthat
our approach computes a large number of boundary conditions for
theRetraction1pattern,noneoftheseiscomparable(intermsof
implication, i.e.,either implied by or implying)with that providedby this pattern. This indicates that both techniques complement
each other. In fact, one should always apply the patterns when
possible, as these provide readable valid boundary conditions, and
search for further boundary conditions with other techniques.
The second technique that we consider in the comparison is an
automated approach to compute boundary conditions, introduced
in [13]. This technique performs a complex logical manipulation of
thespecification,byusinga tableaux-basedsatisfiabilitychecking
algorithm, to identify boundary conditions. It applies to safety and
livenessgoals,aslongastheycanbeexpressedasreachabilityor
responsepatterns[ 37].Table2summarisestheexperimentalresults
of applying this tool to the case studies considered here. The most
notabledifferenceisthatthetableaux-basedtechniqueisnotable
toanalyseallthespecificationsthatourgeneticalgorithmsupports.
Basically, the generation of the tableau structure is very expensive,
whichbecomesmorenoticeableinspecificationscontainingvarious
LTLformulas(inourcasestudieswithlargersetsofformulas,mostarelivenessproperties).Inthesecases,thetableaux-basedtechnique
exceeded the timeout, set to 3 hours. The second difference resides
again in the number of boundary conditions identified by each
approach.Whilethetableaux-basedtechniquecancomputemul-
tiple boundary conditions, our genetic algorithm has consistently
provided a larger set of divergence situations, that might not have
been identified before. As it can be noticed in Table 2, some of the
boundaryconditionsidentifiedbythetableaux-basedtechniqueare
implied (→) by some one computed by our genetic algorithm. Oth-
ersresulttobeequivalenttosomeboundaryconditioncomputed
by our approach. And others resulted to be incomparable, evidenc-
ing different kinds of divergences identified by the two approaches.
This,again,indicatesthatthetableaux-basedtechniquecanbeused,
as far as it is able to scale, for complementing the boundary con-
ditionslearntwithourapproach.Thelastdifferencewehighlight
here is that the tableaux-based approach only applies to safety and
liveness goals expressed with the reachability or response patterns,
and computes boundary conditions with the general shape 3φ.I n
526
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
contrast, our genetic algorithm does not impose any restriction
on the LTL formulation of the domain properties and goals, and
itdoes notrestrictthe shapeof theboundaryconditionslearnt to
any particular pattern.
5.3 Scalability and Sensitivity
Basically, a genetic algorithm is a search-based algorithm that is
guidedtosolutionsbyafitnessfunction.Therearemanyparametersthatmayconsiderablyaffecttheperformanceofageneticalgorithm:
the maximum number of iterations (generations), the size of the
population,themaximumsizeforthechromosomes(inourcasethat
chromosomes have varying lengths), the probability with which
certain genetic operator is applied (mutation and crossover rates),
etc.Anincorrectsettingoftheseparametersmaynotonlyaffectthe
performance of the algorithm, it may also affect its effectiveness.
In our algorithm, the maximum number of genes per chromo-
some is a parameter to which the algorithm is very sensitive. If we
select a relatively small size for the chromosomes, the algorithmmaybelimitedtofindingboundaryconditionsthatwouldother-
wise be discovered with larger chromosomes, or not discovered
atall,ifnotexpressiblewith suchsmallnumberofgenes.So,this
parameter needs to be adapted depending on the specificationsinvolved on each case study. In the case of small specifications,like the MinePump and ATM, 20 genes per chromosome proved
tobeenoughforidentifyingvariousboundaryconditions.Butin
the case of larger specifications, as the AMBA or the LiftController
casestudies,thegeneticalgorithmrequiredlargerchromosomes
(e.g.,50genesperchromosome)tocharacterisethecomplexLTL
propertiesinvolvedinthekindofspecificationsusedtoexpressthe
domain properties and goals.
In order to assess the sensitivity of the genetic algorithm to
other parameters, westudied how the effectivenessand efficiency
of the algorithm is affected by the progressive variation of these,
as it is customary in the context of genetic algorithms. We focused
ontwoparameters,namely,thesizeofthepopulationmaintained
per iteration, and the probability with which the genetic operators
are applied. On one hand, as it was expected, as the size of thepopulation is increased, we notice that the effectiveness of our
geneticalgorithmisincreasedaswell.Ofcourse,theefficiencyis
affectedtoo,sincethealgorithmhasmorecandidatesolutionsto
whichapplythegeneticoperatorsandevaluatethefitnessfunction.
On the other hand, we observed that the effectiveness and the
efficiencyofthealgorithmdonotseemtobeaffectedbytherateofthecrossoveroperator.Itisnotthesameforthemutationoperator;
as we vary the mutation rate, the effectiveness of the algorithmis affected, but not its efficiency. For instance, in the Telephonecase study, with a mutation rate set in 10%, the algorithm was
able to find boundary conditions in 5 runs out of 10, i.e., it had
aneffectivenessof50%,a20%morethanthatreportedinTable 1.
Thus,despitethefactthatourcasestudiesshowthatourgenetic
algorithmscalestospecificationsthatcannotbehandledbyrelated
approaches, we believe that the performance of the algorithm can
still be significantly improved by appropriate parameter setting.
A more exhaustive experimental evaluation is required to try to
identify different classes of problems, and establish well suited
configurations of our genetic algorithm in these classes.5.4 Applicability and Usability
Goal-conflict analysis is typically driven by the identify-assess-
controlcycle,aimedatidentifying,assessingandresolvingconflicts
that may obstruct the satisfaction of the goals. In particular, the
assessmentstepisconcernedwithevaluatinghowlikelytheidenti-
fiedconflictsare,andhowlikelyandseverearetheirconsequences.
The identified conflicts whose likelihood deems them critical, have
toberesolvedbyprovidingappropriatecountermeasures.Notice
that for some of the case studies, e.g., the LAS and the round robin
arbiter, our genetic algorithm identifies more than one hundred
boundaryconditionsinsomeruns.Situationslikethismaymake
the assessment and control steps very expensive, and even imprac-
tical.Inordertoprovidetheengineerwithanacceptablenumber
of conflicts to be analysed, once the genetic algorithm finished,
weperformanumberofSATchecks,toattempttoreducetheset
of boundary conditions to a smaller set of “more general” ones.
Formally,if BC1impliesBC2,wesaythat BC2ismoregeneral,or
weaker, than BC2. This implication can be checked by using the
LTLSATsolver: BC1∧¬BC2isunsatisfiablewhen BC1impliesBC2.
Table3reports, for each case study, the number of more general
BCs. Notice that the number of BCs to be analysed by the engineer
can be considerably reduced.
Letusnowargueabouttheusefulnessofthecomputedbound-
aryconditions.ConsidertheMinePumpexample,thesystemthat
controls a pump in a mine, whose main goal is to avoid a flooding
inthemine.Thesystemcandetectwhenthelevelofthewateris
high(hw)andwhenthereismethaneintheenvironment( m),since
switchingonthepumpinthepresenceofmethanemayproducean
explosion.Theproposition poisusedtoindicatethatthepumpis
on.Assume nowthat thewewould liketo synthesiseacontroller
that satisfies the following specification:
Domain: PumpEffect
InformalDef : If the pump is on, the level of water decreases in at
most two time units.
FormalDef :2(2≤2(po)→3≤2(¬hw ))
Goal:NoExplosion
InformalDef : The pump should be off when methane is detected.
FormalDef :2(m→/circlecopyrt (¬po))
Goal:NoFlooding
InformalDef : The pump should be on when the water level is
above the high threshold.FormalDef :2(hw→/circlecopyrt (po))
One of the boundary conditions identified by our approach is
BC1:3(m∧hw ), which coincides with the one manually identi-
fi e di n[33], and automatically discovered by the tableaux-based
approach[ 13].Inordertogetridofthisconflict,[ 33]proposesto
refine the goal NoFlooding , by weakening it, requiring to switch on
thepumpwhenthelevelofwaterishighandnomethaneispresentintheenvironment.Thus, NoFlooding’ :
2(hw∧¬m→/circlecopyrt (po)).De-
spite the fact that this refinement removes the boundary condition
BC1, our genetic algorithm still computes 43 additional bound-
ary conditions on the refined specification (3 of them are “moregeneral”), that would demand further attention and subsequent
527
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. A Genetic Algorithm for Goal-Conflict Identification ASE ’18, September 3–7, 2018, Montpellier, France
Table 2: Comparison between our Genetic Algorithm and the Tableaux-based technique
Genetic Approach - #BCs Tableaux Approach Relation
Case Study mintime maxtime avgtime#BCs time→←≡/nequivalence
RRCS 51421231622 1 1 1000
MinePump 5453181892 9 0011
ATM 4920171010 4 0 0004
Elevator 33175731 0 1000
TCP 4161220815 2 1 0002
Telephone 94048862466 1 5 0001
LAS 46372912920370 849349 1 5 1000
AchieveAvoidPattern 12838112110 4 2 2002
RetractionPattern1 183039422739 1 0 1000
RetractionPattern2 111438442236 1 0 0010
Round Robin Arbiter 44110322637174 TIMEOUT
Simple Arbiter 116544892151704 TIMEOUT
Prioritized Arbiter 96871933751 138893 TIMEOUT
Load Balancer 26885 413410 37565 TIMEOUT
AMBA 138999 712286 213404 TIMEOUT
LiftController 19302 714963 315531 TIMEOUT
Table 3: Number of weakest boundary conditions
Case Study #BCs#weakest BCs
MinePump 53 9
ATM 20 5
Elevator 17 3
RRCS 21 3
TCP 12 4
Telephone 48 7
LAS 129 8
AchievePattern 38 9
RetractionPattern1 39 2
RetractionPattern2 38 1
Round Robin Arbiter Unreal 1 103 10
AMBA Unreal 1 7 6
LiftController 7 5
Simple Arbiter Unreal 1 44 6
Load Balancer Unreal 1 4 2
Prioritized Arbiter Unreal 1 19 4
refinements. On the other hand, the tableaux-based approach does
not identify any conflict in the refined specification.
In addition to the mentioned use of boundary conditions, other
application contexts may be explored, e.g., in synthesis settings.
Theproblemofsynthesisconsistsofautomaticallyproducing,from
a given specification, an operational model, usually called the con-
troller, that by interacting with the environment in which it is
executed,itallowsittosatisfyacorrespondingspecification.LTL
hasbeenwidelyusedasthespecificationlanguageinthecontext
of automated synthesis [ 14,31,39]; both the environment and the
properties to be satisfied by the controller are captured in many
casesintermsofLTLassertions.Typically,asynthesistoolhastwo
possibleoutputs:thatthespecificationis realisable,andacontroller
isreturned;orthatthespecificationis unrealisable,meaningthat
it is not possible to build a controller to guarantee the goals (i.e.,the environment always has an strategy to violate them). Unfortu-
nately,whenthespecificationisnotrealisable,synthesistoolsin
general do not provide useful feedback to help the user understand
why his/her specification is unrealisable. Boundary conditions can
be used as declarative sentences useful for diagnosing unrealisable
specifications.
For instance, if we consider our previous specification for the
MinePumpController,andweasksomesynthesistool,likeRatsy[ 7],
ifitispossibletobuildacontrollerthatsatisfiesthespecifiedgoals,
wewillgetasananswerthatthespecificationisunrealisable.Recall
that two boundary conditions computed for this specification were
BC1:3(m∧hw )andBC2:3(hw∧¬m∧po∧/circlecopyrt (¬hw∧¬po∨hw∧
(m∨¬po))).Theseformulasgiveusinformationofsomeadmissible
behaviours of the system, that lead us to violating the goals. So,if the controller is able to avoid reaching a boundary condition,
thensuchconditionisnotthereasonoftheunrealisabilityofthe
specification.But,ifthecontrollercannotavoidreachingthebound-
arycondition,thenitmeansthattheenvironmentalwayshavea
winning strategy to force the controller to reach the boundary con-
dition.Inthatcase,suchaBCcouldbethoughtofasanexplanationofwhythecontrollercannotsatisfythegoals,i.e.,anexplanationof
unrealisability of the specification. Returning to the example, if we
use Ratsy to check if it is possible to build acontroller that avoids
boundary condition BC2(i.e., we try to synthesize a controller for
thegoal¬BC2),thenRatsywillanswerthatsuchagoalisrealisable.
However, if we try to synthesise a controller for goal ¬BC1, Ratsy
will answer that such a goal is unrealisable, meaning that it is not
possible for the controller to avoid reaching BC1. Thus,BC1can
be used to explain why the controller cannot guarantee both goals
NoExplosion andNoFlooding at the same time.
This is a promising application of boundary conditions as ex-
planationsofsynthesisunrealisability,whichneedstobefurther
investigated, and opens a line of future work.
528
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
6 RELATED WORK
Inconsistency management has been the focus of many recent
works,mostofthemontheinformalorsemi-formalside[ 25,26,29,
30].Howtodealwithinconsistenciesinrequirementsspecifications
has also been the focus of several studies on the formal side [ 16,
17,24,43]. From the point of view of qualitative analyses, some
worksfocusonidentifyingcontradictorylow-levelrequirements
and computing the degree to which goals are satisfied or denied
by them, e.g., [ 22,42]. In general, these approaches incorporate
thenotionofnon-functionalrequirements,andstudytheirrelation
with the behavioural requirements.
Thetechniquepresentedin[ 44]usesabductionforgenerating
explanations for strong inconsistencies, i.e., specifications that are
unsatisfiable.Ourapproachfocusesonidentifyingdivergences,thatare a weaker form of inconsistency. The technique in [
24] searches
for inconsistencies between conditional scenarios that describe de-
siredbehavioursofthesystemtobesynthesised.Conflictsbetween
non-functionalrequirementshavealsobeenstudied,forinstance,
in [28,35,36]. For the resolution of conflicts, [ 41] makes use of
argumentation patterns to elicit, compose and relate stakehold-ers beliefs. However, it assumes that conflicts have already been
elicited,incontrasttoourapproachthatconcentratesinidentifying
goal conflicts. In [ 49] a methodology is proposed to guarantee that
specifications are consistent by construction, eliminating the need
for detecting inconsistencies.
As we mentioned in Section 5.4, the problem of detecting in-
consistencies in requirements specifications is related to that ofrealisability of specifications [
11,45]. We believe that discovered
boundary conditions can be used for diagnosing unrealisable speci-
fications, providing usefulinformation for theuser to understand
thecauseoftheunrealisability.Thisopensalineoffuturework,asa deeper exploration of this use of boundary conditions is required.
Moreover,itisalsosomewhatrelatedtotheproblemofdetecting
overconstrained specifications [ 48,50], e.g., by extracting a core
set of assertions that cause an inconsistency in an Alloy model, or
byprovidingsometestthatidentifiesamissingbehaviourinthe
model.Ourmethodhoweverattemptstofindanexplanation(i.e.,a
boundary condition) that would lead to such inconsistencies.
In the context of the goal-oriented requirements engineering
methodologies, obstacles [ 55] and conflicts [ 53] have been pre-
sented as an abstraction of risks in requirements specifications.
Recently, various works [ 4,8–10,55] have been proposed to assist
the engineers during the different phases of obstacle analysis. The
technique presented in [ 4] combines model checking and machine
learningtoautomaticallygenerateasetofobstacleconditionswith
respecttoasetofgoalsanddomainpropertiesexpressedinLTL.
However, obstacles are a particular kind of goal conflict; these are
conditionsthatonlyaffectthesatisfactionofonegoal.Then,one
importantlimitationoftheseapproachesisthattheyareineffective
in situations that arise when multiple goals are conflicting.
Variousworkshavealsobeenproposedinordertoassistengi-
neers in other phases of the identify-assess-control cycle of con-flict analysis, the assessment phase in particular. Some of these
techniques,[
12]inparticular,applytoformalLTLspecifications,
as in our case, and apply SAT-based mechanisms as well. How-
ever, therein the focus in the estimation of goal conflict likelihood,contrary to the aim of the current paper, on boundary condition
discovery. Our comparison in Section 5.2has been limited to tech-
niques specifically targeting goal conflict identification. As already
mentioned, [ 53] introduces the concept of goal conflict, and the
pattern-basedtechniqueforgoalconflictidentification.Thistech-
nique imposes syntactical restrictions on the goal specifications,
that seriously limits its applicability; moreover, the patterns are
designedtoprovideonlyoneboundarycondition,incaseswhere
more than one boundary condition may exist. Section 5.2shows
thatourgeneticalgorithmismoregeneral,inthesensethatitdoesnotimposeanyrestrictionoftheLTLrequirements,andincontrast
tothepatterns,isabletocomputemultipleboundaryconditions.Moreover, we showed that both approaches might be simultane-
ously used, when patterns apply, as some boundary conditions are
identified by one of the approaches, but not the other.
Another related work is that presented in [ 13], where boundary
conditions are automatically computed using a tableaux-based LTL
satisfiability procedure. It applies to safety and liveness goals, as
longasthesecanbecapturedastheprogressandresponsepatterns.
This approach is strongly tied to a complex logical algorithm to
generatethetableauforthespecification(itisanessentialpartofthe
approach), which may exhibit scaliability issues. Section 5.2shows
that, for various specifications with larger number of goals and
domain properties, the tableau-based mechanism has performance
issues.Thismakesthetechniqueapplicableonlytorelativelysmall
specifications.Ontheotherhand,thegeneticalgorithmpresentedin
thispaperdoesnotimposeanyrestrictionontheLTLformulationofthedomainpropertiesandthegoals,asshowsasignificantlybetter
performancethanthetableaux-basedapproach;itincorporatesa
modern LTL satisfiability checker, and is able to efficiently scale to
LTL specifications that other approaches are unable to deal with.
7 CONCLUSION AND FUTURE WORK
The identification of inconsistencies during the early phases of re-
quirements engineering is of most importance. It helps in avoiding
costly software repairs, and also supports systematic requirements
elicitation and verification activities. In this paper we presented a
novelapproachforidentifyinggoalconflictsingoalorientedLTL
requirements specifications, and is based on a genetic algorithm
thatautomaticallydiscoversboundaryconditions.Thegeneticalgo-rithmwasdesignedinawaythatallowsittoconsiderarbitraryLTL
formulas as boundary condition candidates, and attempts to pro-
duce generaland compact boundary conditions.Our experiments,
based on a large set of case studies, showed that our approach out-
performs related techniques, by producing boundary conditions
thatpreviousapproacheswereunabletoidentify,andbeingcapa-
bleofanalysingspecificationsthatarebeyondthescopeofother
techniques for boundary condition computation.
Ourapproachopensvariouslinesforfuturework.Weplanto
explore how different parameters affecting the technique’s effec-tiveness can be appropriately set based on characteristics of the
analysed specification. We are also exploring the use of alternative
fitness functions, based on other logical mechanisms like model
counting, to guide the search. Finally, we are studying applications
of computed boundary conditions, in particular for unrealisability
diagnosis in the context of automated synthesis.
529
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. A Genetic Algorithm for Goal-Conflict Identification ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1] Java genetic algorithms package (jgap). http://jgap.sourceforge.net.
[2] The reactive synthesis competition. www.syntcomp.org.
[3] Synthesis competition repository. https://bitbucket.org/swenjacobs/syntcomp/.
[4]Dalal Alrajeh, Jeff Kramer, Axel van Lamsweerde, Alessandra Russo, and Se-
bastián Uchitel. Generating obstacle conditions for requirementscompleteness.
In34thInternationalConferenceonSoftwareEngineering,ICSE2012,June2-9,2012,
Zurich, Switzerland, pages 705–715, 2012.
[5]RajeevAlur,SalarMoarref,andUfukTopcu. Counter-strategyguidedrefinement
of GR(1) temporal logic specifications. CoRR, abs/1308.4113, 2013.
[6]Adrian Beer, Stephan Heidinger, Uwe Kühne, Florian Leitner-Fischer, and Stefan
Leue. Symboliccausalitycheckingusingboundedmodelchecking. In Proc.of
the 22nd Intl. Sym. on Model Checking Software, pages 203–221, 2015.
[7]Roderick Bloem, Alessandro Cimatti, Karin Greimel, Georg Hofferek, Robert
Könighofer,MarcoRoveri,ViktorSchuppan,andRichardSeeber. RATSY-Anew
requirements analysis tool with synthesis. In CAV, volume 6174 of Lecture Notes
in Computer Science, pages 425–429. Springer, 2010.
[8]Antoine Cailliau and Axel van Lamsweerde. A probabilistic framework for goal-
oriented risk analysis. In 2012 20th IEEE International Requirements Engineering
Conference (RE), Chicago, IL, USA, September 24-28, 2012, pages 201–210, 2012.
[9]AntoineCailliau andAxelvanLamsweerde. Integratingexceptionhandlingin
goal models. In IEEE 22nd International Requirements Engineering Conference, RE
2014, Karlskrona, Sweden, August 25-29, 2014, pages 43–52, 2014.
[10]Antoine Cailliau and Axel vanLamsweerde. Handling knowledgeuncertainty in
risk-based requirements engineering. In 23rd IEEE International Requirements
Engineering Conference, RE 2015, Ottawa, ON, Canada, August 24-28, 2015, pages
106–115, 2015.
[11]A. Cimatti, M. Roveri, V. Schuppan, and A. Tchaltsev. Diagnostic information
for realizability. In Proc. of the 9th Intl. Conf. on Verification, Model Checking, and
Abstract Interpretation, pages 52–67, 2008.
[12]Renzo Degiovanni, Pablo F. Castro, Marcelo Arroyo, Marcelo Ruiz, Nazareno
Aguirre, and Marcelo F. Frias. Goal-conflict likelihood assessment based on
model counting. In Proceedings of the 40thInternational Conference on Software
Engineering, ICSE 2018, Gothenburg, Sweden, May 27 - June 03, 2018, pages 1125–
1135, 2018.
[13]RenzoDegiovanni,NicolásRicci,DalalAlrajeh,PabloF.Castro,andNazareno
Aguirre. Goal-conflict detection based on temporal satisfiability checking. In
Proceedingsofthe31stIEEE/ACMInternationalConferenceonAutomatedSoftware
Engineering, ASE 2016, Singapore, September 3-7, 2016, pages 507–518, 2016.
[14]NicolásRoqueD’Ippolito,VictorBraberman,NirPiterman,andSebastiánUchitel.
Synthesisoflivebehaviourmodels. In ProceedingsoftheEighteenthACMSIGSOFT
International Symposium on Foundations of Software Engineering, FSE ’10, pages
77–86, New York, NY, USA, 2010. ACM.
[15]MatthewB.Dwyer,GeorgeS.Avrunin,andJamesC.Corbett. Patternsinproperty
specifications for finite-state verification. In ICSE, pages 411–420, 1999.
[16]ChristianEllen,SvenSieverding,andHardiHungar. Detectingconsistenciesand
inconsistencies of pattern-based functional requirements. In Proc. of the 19th
Intl. Conf. on Formal Methods for Industrial Critical Systems, pages 155–169, 2014.
[17]Neil A. Ernst, Alexander Borgida, John Mylopoulos, and Ivan J. Jureta. Ag-ile requirements evolution via paraconsistent reasoning. In Proc. of the 24th
Intl. Conf. on Advanced Information Systems Engineering, pages 382–397, 2012.
[18]AmyP.FeltyandKedarS.Namjoshi. Featurespecificationandautomatedconflict
detection. ACM TOSEM, 12(1):3–27, 2003.
[19]A. Finkelstein and J. Dowell. A comedy of errors: The london ambulance service
case study. In Proceedings of the 8th International Workshop on Software Spec-
ification and Design , IWSSD ’96, pages 2–, Washington, DC, USA, 1996. IEEE
Computer Society.
[20]Carlo Ghezzi, Mehdi Jazayeri, and Dino Mandrioli. Fundamentals of Software
Engineering. Prentice Hall PTR, Upper Saddle River, NJ, USA, 2nd edition, 2002.
[21]DimitraGiannakopoulouandFlavioLerda. Fromstatestotransitions:Improv-
ing translation of LTL formulae to büchi automata. In Formal Techniques for
Networked and Distributed Systems - FORTE 2002, 22nd IFIP WG 6.1 International
ConferenceHouston,Texas,USA,November11-14,2002,Proceedings,pages308–326,
2002.
[22]Paolo Giorgini, John Mylopoulos, and Roberto Sebastiani. Goal-oriented require-
mentsanalysisandreasoninginthetroposmethodology. EngineeringApplications
of Artificial Intelligence, 18(2):159 – 171, 2005.
[23]D. Goldberg. Genetic Algorithmsin Search,Optimization andMachine Learning.
Addison-Wesley, 1989.
[24]David Harel, Hillel Kugler, and Amir Pnueli. Synthesis revisited: Generatingstatechart models from scenario-based requirements. In Formal Methods in
SoftwareandSystemsModeling:EssaysDedicatedtoHartmutEhrigontheOccasion
of His 60th Birthday, pages 309–324, 2005.
[25]J.H. Hausmann,R.Heckel, andG. Taentzer. Detectionof conflictingfunctional
requirements in a use case-driven approach. In ICSE, pages 105–115, 2002.
[26]Sebastian J.I. Herzig and Christiaan J.J. Paredis. A conceptual basis for inconsis-
tency management in model-based systems engineering. Procedia CIRP, 21:52 –57, 2014.
[27]PankajJalote. AnIntegratedApproachtoSoftwareEngineering. TextsinComputer
Science. Springer, 2005.
[28]I.J.Jureta,A.Borgida,N.A.Ernst,andJ.Mylopoulos. Techne:Towardsanew
generation of requirements modeling languages with goals, preferences, andinconsistency handling. In Proc. of the 18th IEEE International Requirements
Engineering Conference, pages 115–124, 2010.
[29]M.Kamalrudin. Automatedsoftwaretoolsupportforcheckingtheinconsistency
of requirements. In ASE, pages 693–697, 2009.
[30]Massila Kamalrudin, John Hosking, and John Grundy. Improving requirements
quality using essential use case interaction patterns. In ICSE, pages 531–540,
2011.
[31]UriKlein,NirPiterman,andAmirPnueli. Effectivesynthesisofasynchronous
systems from GR(1) specifications. In Verification, Model Checking, and Abstract
Interpretation - 13th International Conference, VMCAI 2012, Philadelphia, PA, USA,
January 22-24, 2012. Proceedings, pages 283–298, 2012.
[32]J.Kramer,J.Magee,M.Sloman,andA.Lister. CONIC:anintegratedapproach
to distributed computer control systems. Computers and Digital Techniques, IEE
Proceedings E, 130(1):1+, 1983.
[33]EmmanuelLetier. Reasoningaboutagentsingoal-orientedrequirementsengi-
neering, 2001.
[34]JianwenLi,ShufangZhu,GeguangPu,andMosheY.Vardi. Sat-basedexplicit
LTL reasoning. CoRR, abs/1507.02519, 2015.
[35]C. L. Liu. Ontology-based conflict analysis method in non-functional require-
ments. In Proc. of the 9th IEEE/ACIS Intl. Conf. on Computer and Information
Science, pages 491–496, 2010.
[36]DewiMairizaandDidarZowghi.Constructingacatalogueofconflictsamongnon-
functionalrequirements. In Proc.oftheIntl.Conf.EvaluationofNovelApproaches
to Software Engineering, pages 31–44, 2011.
[37]ZoharMannaandAmirPnueli. TheTemporalLogicofReactiveandConcurrent
Systems. Springer-Verlag New York, Inc., New York, NY, USA, 1992.
[38]Zohar Mannaand Amir Pnueli. Temporal verification ofreactive systems: safety.
Springer-Verlag New York, Inc., New York, NY, USA, 1995.
[39]ZoharMannaandPierreWolper. Synthesisofcommunicatingprocessesfrom
temporal logic specifications. In Dexter Kozen, editor, Logics of Programs, pages
253–281, Berlin, Heidelberg, 1982. Springer Berlin Heidelberg.
[40]Z. Michalewicz. Genetic Algorithms + Data Structures = Evolution Programs.
Springer, 1996.
[41]P.K. Murukannaiah, A.K. Kalia, P.R. Telangy, and M.P. Singh. Resolving goal
conflictsviaargumentation-basedanalysisofcompetinghypotheses. In Proc.23rd
IEEE Int. Requirements Engineering Conf., pages 156–165, 2015.
[42]J.Mylopoulos,L.Chung,andB.Nixon. Representingandusingnonfunctional
requirements:Aprocess-orientedapproach. IEEETrans.Softw.Eng.,18(6):483–
497, June 1992.
[43]Tuong Huan Nguyen, Bao Quoc Vo, Markus Lumpe, and John Grundy. KBRE:
a framework for knowledge-based requirements engineering. Software Quality
Journal, 22(1):87–119, 2013.
[44]Bashar Nuseibeh and Alessandra Russo. Using abduction to evolve inconsistent
requirements specification. Australasian Journal of Information Systems, 6(2),
1999.
[45]Suchismita Roy, Sayantan Das, Prasenjit Basu, Pallab Dasgupta, and P. P.
Chakrabarti. Sat based solutions for consistency problems in formal property
specifications for open systems. In CAD, pages 885–888, 2005.
[46]KristinY.RozierandMosheY.Vardi. LTLsatisfiabilitychecking. STTT,12(2):123–
137, 2010.
[47]ViktorSchuppan. Towardsanotionofunsatisfiableandunrealizablecoresforltl.
Sci. Comput. Program., 77(7-8):908–939, July 2012.
[48]Ilya Shlyakhter, Robert Seater, Daniel Jackson, Manu Sridharan, and Mana
Taghdiri. Debugging overconstrained declarative models using unsatisfiable
cores. In ASE, pages 94–105, 2003.
[49]Monique Snoeck, Cindy Michiels, and Guido Dedene. Consistency by construc-
tion: The case of merode. In Proc. of the ER Workshop on Conceptual Modeling for
Novel Application Domains, pages 105–117, 2003.
[50]Allison Sullivan, Kaiyuan Wang, Razieh Nokhbeh Zaeem, and Sarfraz Khurshid.
Automated test generation and mutation testing for alloy. In 2017 IEEE Inter-
national Conference on Software Testing, Verification and Validation, ICST 2017,
Tokyo, Japan, March 13-17, 2017, pages 264–275, 2017.
[51]SebastiánUchitel,JeffKramer,andJeffMagee. Synthesisofbehavioralmodels
from scenarios. IEEE Trans. Software Eng., 29(2):99–115, 2003.
[52]Axel van Lamsweerde. Requirements Engineering - From System Goals to UML
Models to Software Specifications. Wiley, 2009.
[53]Axel van Lamsweerde, Robert Darimont, and Emmanuel Letier. Managing
conflicts in goal-driven requirements engineering. IEEE Trans. Software Eng.,
24(11):908–926, 1998.
[54]AxelvanLamsweerdeandEmmanuelLetier. Integratingobstaclesingoal-driven
requirements engineering. In Proceedings of the 20th International Conference on
Software Engineering, ICSE ’98, pages53–62, Washington,DC, USA, 1998. IEEE
Computer Society.
530
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Degiovanni, F. Molina, G. Regis, and N. Aguirre
[55]AxelvanLamsweerdeandEmmanuelLetier. Handlingobstaclesingoal-oriented
requirements engineering. IEEE Trans. Softw. Eng., 26(10):978–1005, October2000.
531
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 