EventFlowSlicer: A Tool for Generating Realistic
Goal-Driven GUI Tests
Jonathan A. Saddler, Myra B. Cohen
Department of Computer Science & Engineering
University of Nebraska-Lincoln
Lincoln, NE 68588-0115, USA
saddler@huskers.unl.edu, myra@cse.unl.edu
Abstract ‚ÄîMost automated testing techniques for graphical
user interfaces (GUIs) produce test cases that are only concerned
with covering the elements (widgets, menus, etc.) on the interface,
or the underlying program code, with little consideration of test
case semantics. This is effective for functional testing where theaim is to Ô¨Ånd as many faults as possible. However, when one
wants to mimic a real user for evaluating usability, or when
it is necessary to extensively test important end-user tasks ofa system, or to generate examples of how to use an interface,
this generation approach fails. Capture and replay techniques
can be used, however there are often multiple ways to achievea particular goal, and capturing all of these is usually too time
consuming and unrealistic. Prior work on human performance
regression testing introduced a constraint based method to Ô¨Åltertest cases created by a functional test case generator, however that
work did not capture the speciÔ¨Åcations, or directly generate only
the required tests and considered only a single type of test goal.
In this paper we present EventFlowSlicer, a tool that allows the
GUI tester to specify and generate all realistic test cases relevantto achieve a stated goal. The user Ô¨Årst captures relevant events
on the interface, then adds constraints to provide restrictions
on the task. An event Ô¨Çow graph is extracted containing onlythe widgets of interest for that goal. Next all test cases are
generated for edges in the graph which respect the constraints.
The test cases can then be replayed using a modiÔ¨Åed versionof GUITAR. A video demonstration of EventFlowSlicer can be
found at https://youtu.be/hw7WYz8WYVU.
Index T erms‚ÄîSoftware test generation, graphical user inter-
faces, goal-based testing
I. I NTRODUCTION
Automated test generation for Graphical User Interfaces
(GUIs) has been the subject of a large body of research [1]‚Äì[8].
Approaches include model-based techniques, which have ledto tools such as GUITAR [9], random techniques, or search-based techniques that systematically explore the applicationevent-space to increase code coverage [3], [6]. However,all of these methods for test generation, focus primarily onfunctionality with the aim of exercising as many events (andevent sequences) on the interface as possible. While this iseffective for some types of testing, it fails to mimic real tasksthat a user might perform. Recent work on usability testing,Human Performance Regression Testing (HPRT), proposed atechnique to automate test case generation that mimics thevarious ways an expert user can perform some task based ona stated goal [10]. This allows the interface designer to Ô¨Åndproblematic paths in the interface. In HPRT, a set of widgetson the interface that participate in the given task are Ô¨Årstenumerated and a set of constraints are added to ensure thatthe task is realistic (i.e. it doesn‚Äôt open and close a windowbefore a useful action is performed). That work, however, hasseveral limitations. First, the types of tasks allowed are limitedto those which can be performed on the interface in differentways, but with only minor structural differences (e.g. menusversus buttons). Second, the user has to specify widgets andconstraints manually in a text Ô¨Åle (with no tool support). Third,the tests are not directly generated, but rather, are Ô¨Åltered fromthe set of all possible functional tests on an event Ô¨Çow graphwhich limits scalability.
Other approaches for realistic user testing include pattern
based testing [4], [11], however, that work differs in that ituses a template for a speciÔ¨Åc goal and does not provide theÔ¨Çexibility of generating tests for any type of test goal. Memonet al. [12] used AI planning, however they generate a single
test case and require the user to specify the exact orders of
sequences of actions in the path. Zhang et al. [13] use staticanalysis to extract the set of actions to perform a workÔ¨Çowon the interface, but they do not generate replayable tests andrequire access to the source code. There has also been some
work on generation of realistic test cases for web applications[14]‚Äì[16], however they do not generate event sequences for
desktop GUI applications.
In this paper we present our tool, EventFlowSlicer (EFS for
short), that solves the stated challenges of HPRT. EFS was Ô¨Årstdescribed in [17], [18]. It allows users to specify and generatetest cases for a variety of goal types. The Ô¨Årst type of test goalis the most stringent and expects that the test cases differ onlyin slight structural ways (such as by using a menu versus akeyboard, or by switching the order of a task). Our exampletask in this paper is structural. EFS also supports goals thatare functionally different. These types of goals have at leasttwo different ways to perform the same task that use verydifferent methods (such as using entirely different menus andsteps). An example of such a task used in our prior work is thatof search and replace in DrJava. The third type of goal that issupported is an abstract goal. A user might specify a generalgoal ‚Äì that they want to change the look of some text. Thismight include making the text a different font, or a differentcolor, or italicizing, etc. We can deÔ¨Åne such a test goal usingEventFlowSlicer and generate all of the test cases constrained
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations955
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Required 
Order 
Repeat Exclude Atomic 
Requi red 
Order  
Repeat 
Exclude  
Atomic 
1. Capture Widgets 2. Constrain 3. Model Setup 
4. Generate Tests 5. Replay Tests 
RMI: remote method        
         invocation 
 
GUITAR : built on 
      GUITAR 




ic 
E
A

user input 
automated 
Fig. 1. Overview of EventFlowSlicer
by a set of user deÔ¨Åned rules. The task used in our running
example can be made into an abstract goal, by removing someof our constraints. We used an abstract version of this goalwhich generated 200 test cases in our prior work [17].
In EventFlowSlicer, the user is provided both with a capture
mechanism and a graphical constraint interface that walks
them through each part of the process. They then push abutton to extract a small event Ô¨Çow graph relevant only to theirtask and to generate tests that satisfy their goal. Once gener-ated, the tests can be replayed from within EventFlowSlicer.EventFlowSlicer can also read inputs from prior steps, sothat the process can be started at any point and artifactsreused. EventFlowSlicer utilizes the model-based approach ofthe GUITAR framework for its ripping process and replay [9].
We begin next with an overview of the tool architecture and
discuss the targeted users. We then present a running exampleof the use of each of the modules of the tool in Section III.We follow with a discussion of our validation of EFS (SectionIV). Then we conclude and present future work in Section V.
II. S
YSTEM ARCHITECTURE
Figure 1 shows an overview of EventFlowSlicer. It has Ô¨Åve
primary modules labeled 1 to 5. The Ô¨Årst module allows theuser to provide input via a capture tool that creates an initialpart of the goal speciÔ¨Åcation. This part of the process usesJava remote method invocation (RMI) to allow the applicationto open and close in a separate process. Once the widgets are
captured, the second module provides a graphical interface for
the user that walks them through the process of deÔ¨Åning thesets of constraints for the given goal. There are Ô¨Åve types ofconstraints (described later), Requires, Order, Repeat, Exclude
and Atomic. Once the constraints are deÔ¨Åned, the next phase is
to perform the model setup which creates an event Ô¨Çow graph
(a graph model of the events and their follows edges which aredynamically extracted from an interface [19]). containing onlythose widgets that are captured. This module is built on topof the GUITAR ripper [9]. Once the model has been created,
the next step is to generate tests. The event Ô¨Çow graph isexplored in a depth-Ô¨Årst manner, pruning edges that violate
constraints, and recording paths. All paths that satisfy all theconstraints are output as the set of tests. Last, the tests can bereplayed using a modiÔ¨Åed version of the GUITAR relayer. We
have retroÔ¨Åtted this module to use RMI. We will discuss eachmodule in more detail in the next section.
Envisioned Users EventFlowSlicer is developed both for
experienced testers who can use the command-line input
and directly modify the constraints Ô¨Åles, as well as for lessexperienced testers such as user interface designers, who wantto explore different ways to perform the same task on theinterface. We expect that the output of the test case replaycan be used in some existing performance prediction tools aswas done in HPRT [10]. We also envision that EFS can beused to help discover ways to perform actions on a task fora tester who iteratively interacts with the tool, relaxing andadding constraints in the process.
III. E
XAMPLE TOOL WALKTHROUGH
We use a small task (modiÔ¨Åed from [17]) based on a
Stack OverÔ¨Çow question. The user asked how to change thestylization (speciÔ¨Åcally background color) of text typed into aJava source Ô¨Åle as a comment [20].
We have deÔ¨Åned our task to satisfy a speciÔ¨Åc (non-trivial)
goal that can be achieved many ways. The user wants to makethe text of the Java comment in jEdit to be bold and italic,and to have a new background color. As part of our goal wewill allow the user to make these changes in any order and touse both the mouse and keyboard to achieve the backgroundcolor changes. Each valid test case must have all three changesmade. Our task in [17] called Commented Text (BG) is similarto this one, however it is abstract in that it did not require thatall three changes happen, but only at least one (hence therewere more ways to perform the task). More formally our goalin this demonstration will be to enumerate all possible ways
the jEdit Style Editor can be opened and used to change thecommented text so that it is italicized, bold, and has a graybackground color. There are 12 ways to achieve the goal wehave stated. This task will be run on jEdit V ersion 5.1.0.
In order to make this task realistic when creating test cases,
we follow a few principles.
‚Ä¢The test case must not repeat any states or move to
unnecessary states leading to the goal state.
‚Ä¢The tester is always actively exploring new states of the
editor when they click the OK button.
‚Ä¢The test case must always make forward progress towards
achieving the goal.
To begin, we start EventFlowSlicer. We show the main
screen in Figure 2. Notice that some of the text Ô¨Åelds areÔ¨Ålled in already for demonstration. At startup these are empty,but can be auto-Ô¨Ålled by using command line arguments andpassing the -gui Ô¨Çag. EventFlowSlicer has Ô¨Åve steps (#1-5,
circled in red) that are performed in order. Most of these stepscan be skipped by providing input Ô¨Åles such as a constraintsÔ¨Åle which will skip step #1 and #2, or a set of tests which
will allow one to move directly to step #5. As input to start
the application, the tester provides an output directory andlocation of the application. This can be a .jar Ô¨Åle (shown inthe Ô¨Ågure) or can be a class Ô¨Åle. Optional virtual machine and
956
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. EventFlowSlicer main screen
application speciÔ¨Åc arguments can be provided as input Ô¨Åles.
No other input is needed to begin step #1.
A. Capture
Once the initial information is provided to EFS, the capture
button is clicked and the application under test will open. We
show jEdit open during the capture phase in Figure 3. ThejEdit Style Editor is not initially visible to the tester fromthe main editor window ‚Äî it must be revealed by clicking amenu item in the main window‚Äôs [Utilities] menu. The testeropens this window via the menu (which is being captured byEFS) and upon entering this window they click on each of thewidgets that are involved in the task. In this case they willclick on the Italics, Bold and Background color checkboxes.This can be done in any order. They will ignore the text colorpicker, since this is not needed for the task and should notbe captured. Once the background color checkbox is selected,another color picker becomes accessible. They will click onthat and they are taken to a color window where they canselect the background color either by clicking on a cell withthe mouse or by using the keyboard. The tester will captureboth actions (again in either order). The following widgets willbe captured by EventFlowSlicer:
‚Ä¢‚ÄúUtilities‚Äù menu
‚Ä¢‚ÄúQuick Settings‚Äù submenu
‚Ä¢‚ÄúEdit syntax style‚Äù menu item
‚Ä¢‚ÄúItalics‚Äù check box
‚Ä¢‚ÄúBold‚Äù check box
‚Ä¢‚ÄúBackground color‚Äù check box and push button
‚Ä¢the ‚ÄúLight-gray ‚Äù swatch button using mouse
‚Ä¢the ‚ÄúLight-gray ‚Äù swatch button using the arrow keys +space bar
Fig. 3. The JEdit Style Editor Window, Nothing Selected
‚Ä¢Pick a Color ‚ÄúOK‚Äù button
‚Ä¢Style Editor ‚ÄúOK‚Äù button
During capture the tester visually selects the widgets and
the labels are printed to the console to help identify whatactions EFS is capturing. When done, he or she hits the StopCapture button and the widgets are recorded to a Ô¨Åle. TheÔ¨Åle containing all these widgets is automatically used in thenext phase (and added to the interface in the Ô¨Åeld labeledConstraints Ô¨Åle). The tester can manually edit this XML Ô¨Åleif some incorrect widgets were selected.
B. Constrain
This step speciÔ¨Åes how these widgets work together to
achieve the goal. It will add constraints related to the captured
widgets. During this phase a GUI walks the tester througheach constraint in order, and provides a list of the possible
widgets which can participate in this rule to make the tester‚Äôsjob easier. Any of the captured widgets are allowed to be addedinto constraints groups, and test case generation will enforcethat the test cases adhere to these rules.
To brieÔ¨Çy review from our previous work [17], the Ô¨Åve con-
straints the tester can work with in the currently implementedversion of EventFlowSlicer are shown below. We assume thatW={w
1,w2, ..., w n}is the set of captured widgets.
‚Ä¢Requires: Given a set R‚äÜW,‚àÉwi‚ààRappearing in
each generated test case.
‚Ä¢Exclusion: Given the set E‚äÜW,‚àÄ{wi,wj}‚ààE,w i/negationslash=
wj, at most one of wiandwjcan appear in any generated
test case.
‚Ä¢Repeat: Given a set P‚äÜW and a minBound and
maxBound, ‚àÄwi‚ààP,wimay occur up to rtimes
in a generated test case where minBound ‚â§r‚â§
maxBound1.
‚Ä¢Order: Given a sequence, of nsetsS=<O 1,O2, ..O n>,
Oi‚äÇWand‚àÄ{Oi,Oj},O i‚à©Oj=‚àÖ, and i<j ,‚àÄwi‚àà
Oi,wiappears before all wj‚ààOjin every test case. This
is a partial order on widgets.
1Without specifying any constraint, minBound =0 ,maxBound =1
957
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. ‚Ä¢Atomic: A sequence, S=<w i,wj, ..w n>where wi‚àà
W. This is an exact order of widgets.
Each of these rules can be used repeatedly. For instance, we
can require three separate groups of widgets by adding 3 re-
quires rules. In our running example, the following constraintswere employed:
1) Three Requires constraints, one for each of the ‚ÄúItalics‚Äù,
‚ÄúBold‚Äù, and ‚ÄúBackground Color‚Äù checkboxes. This willforce all three to appear in a test case for it to be valid.(Note: We can also add all three to a single requiresconstraint, meaning that at least one must be present ina test case ‚Äî creating a more abstract goal.)
2) One Exclusion constraint containing both the keystroke
and click option for selecting a color. This means testcases will only use one of these methods to change thebackground color.
3) An Atomic constraint that states that the ‚ÄùBackground
color checkbox‚Äù is clicked before its selector button isclicked. If we were to change this to an order constraintstating the ‚Äúcheckbox‚Äù appear only at some time prior
to selecting a color, we would more than double thenumber of test cases generated. We bind these two ac-tions together for the sake of an understandable workingexample. EFS supports both options.
An example constraint tool window is show in Figure 4. The
possible widgets are on the left, the current constraint in thedisplay is the Requires constraint. As each widget is selected
for this rule it will be added on the right. We require only a few
Requires rules to obtain a suite that is focused on just the three
formatting widgets we mentioned. In the jEdit application, the
‚ÄúItalics‚Äù, ‚ÄúBold‚Äù, and ‚ÄúBackground color‚Äù buttons can only befound in the Style Editor window, shown in Figure 3, and they
are also among the few widgets we captured in the Ô¨Årst step.Thus, having required that each test case use one of thesewidgets, we force every test case to Ô¨Årst navigate down themenu path to the Style editor (the one denoted by ‚ÄúUtilities‚Äù,
‚ÄúQuick Settings‚Äù, and ‚ÄúEdit Syntax Style‚Äù.
The space of test cases generated is limited to realistic,
expert-user test cases, based on global constraints (see [10])which will hold as long as constraints speciÔ¨Åed in the Con-
straints Tool don‚Äôt override them. Test cases will not open a
window, or click to enter a tab in a tabbed selection panel,and then immediately close the window or panel to performactions elsewhere. Each event will be used only once in eachtest case (in absence of overriding Repeat rules), and all tasks
will end and begin in the main window the application opened
when launched. Without global constraints, the test case mightcontinually check and uncheck the italic or bold option, orleave the Style Editor without changing the state at all.
We are now done specifying our test suite to the genera-
tor. EventFlowSlicer allows us to immediately transition into
letting the program handle the rest of the work.
C. Model Setup
The next step is to create the models from which to derive
test cases. The generator takes the captured output and the
Fig. 4. The EventFlowSlicer Constraints Tool
output of the constraints selection, both combined into one Ô¨Åle,
and gathers necessary data from the interface using a GUITARrip operation and creates an event Ô¨Çow graph (EFG), a graph
where nodes represent the events in the application and edgesindicate a node can follow another one. The rip operation is
explained in detail in [19]. The resulting EFG does not provide
a complete graph of the interface, but instead only rips thewidgets that were captured and are contained in the constraintsÔ¨Åle [19]. We show the full EFG for jEdit in Figure 5(a). Thishas hundreds of nodes and thousands of edges. By contrast, the
EFG that is ripped using EventFlowSlicer is shown in Figure
5(b). This is further reduced in the Ô¨Årst part of test generation(Shown as Figure 5(c)).
EventFlowSlicer uses a GUITAR Ô¨Ålter to prune widgets that
are not captured. If a widget sits under a menu item that wasn‚Äôtexplicitly captured, the path to it is left in the EFG to ensureproper test cases can be generated. The result of ‚Äúextra hidden‚Äù
widgets is reported by EventFlowSlicer at the end of the ModelSetup step.
D. Generation
Once the model is created, the tester can select Generate
Test Cases. The Ô¨Årst step makes sure that the Constraints
Ô¨Åle and EFG Ô¨Åle were generated for the same application.Each main element in the constraints Ô¨Åle is checked for aunique mapping to an event in the EFG. The second step isto reduce the EFG to remove some edges based on the globalrules (see [10], [17] for more information). In particular theNoRepeats rule implies that widgets should by default notbe repeated in test cases, so the reduction removes any selfedges from the EFG (and other edges which traversing wouldautomatically imply illegal breaking of global rules in a testcase). There are three such reductions we make, RepeatSelf,WindowOpencloseCannotHappen, and ExpandToChild. Theyare described in [17], [18]. We have experimented with variousorderings of these three reductions (since the last reduction isimpacted by the former) and have found that the different
958
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. e3365297604:menu_Utilities_CLICK
e2640108148:menu_UtilitiesQuick_settings_CLICK
e3469068240:menu_item_UtilitiesQuick_settingsEdit_syntax_style_of_token_under_caret_CLICK
e519002124:check_box_Italics_CLICK
e3876132034:check_box_Bold_CLICK
e2524057168:check_box_Background_color:_CLICK
e227488950:push_button_Background_color:_CLICK
e2403448090:push_button_OK_CLICKe3845132384:page_tab_list_Swatches_SELECT
e581799926:push_button_OK_CLICKe3003664316_0:mouse_panel_Swatches_CLICK
e3003664316_1:typing_panel_Swatches_SELECTe3365297604:menu_Utilities_CLICK
e2640108148:menu_UtilitiesQuick_settings_CLICK
e3469068240:menu_item_UtilitiesQuick_settingsEdit_syntax_style_of_token_under_caret_CLICK
e519002124:check_box_Italics_CLICK
e3876132034:check_box_Bold_CLICK
e2524057168:check_box_Background_color:_CLICK
e227488950:push_button_Background_color:_CLICK
e2403448090:push_button_OK_CLICKe3845132384:page_tab_list_Swatches_SELECT
e3003664316_0:mouse_panel_Swatches_CLICK
e3003664316_1:typing_panel_Swatches_SELECT
e581799926:push_button_OK_CLICK
 	 

Fig. 5. 3 phases of the EFG reduction. Unconstrained ripping to obtain jEdit‚Äôs
full EFG is shown in (a). EventFlowSlicer will produce a reduced EFG from
its rip shown in (b). The test generation phase will reduce the EFG furtherby removing edges for the global rules, just before generation (c)
orderings of reductions have an insigniÔ¨Åcant effect, but that
reductions overall are useful in reducing graphs to nearly halftheir size on average, which reduces test generation time. Theresulting event Ô¨Çow graph after the global rules are removedin our example is shown in Figure 5(c).
Once these reductions and mappings are made, the generator
then starts systematically traversing the EFG from the widgetsthat exist on the main window. When a test case containingallRequires widgets is found, (and that does not violate other
constraints) it is returned as a test case. The traversal then
continues, avoiding branches that violate constraints as it goes.In the end, all speciÔ¨Åed test cases are generated.
E. Test Cases
Our working example will result in 12 test cases. There are
six different tests that account for each of the possible orders
for Italic, Bold and Background Color, and for each of these,there are two ways to change the background color (mouse orkeyboard).
We have veriÔ¨Åed that the test cases generated from Event-
FlowSlicer for this instance achieve the desired result, by
manually examining each test case. We present examples of
two test cases in Figure 6. The left side lists the steps forboth of the test cases while the right side shows a portion ofthe actual test case XML for the Ô¨Årst test case which is ina modiÔ¨Åed GUITAR format. The GUITAR generator creates
widget IDs using a 10-digit hash value. As a design decision,EventFlowSlicer test cases are relabeled with English languagedescriptions of the widgets, so that the tester can readily see
what the test cases are doing, before having to replay the testcase. This is useful for a number of reasons:
‚Ä¢The tester need not run the test cases in order to under-stand what it is doing.
‚Ä¢Scripts can utilize this information to mine data about thewidgets in each test case.
‚Ä¢Reasoning about the validity of each test case to achievethe desired goal is possible by looking at a visualization
of the EFG relabeled in the same manner and studyingpaths taken to achieve the generated test cases.
F . Replay
The last phase of EventFlowSlicer is test case replay. The
tester can replay all tests in the test suite, or select a subset byTest Case One  
1.   menu_Utilities_CLICK 
2.   menu_Utilities|Quick settings_CLICK 
3.‚ÄØ menu item_Utilities|Quick settings|Edit    
      syntax style of 
      token under caret_CLICK 4.   check box_Italics_CLICK 5.   check box_Bold_CLICK 6.   check box_Background color:_CLICK 
7.   push button_Background color:_CLICK 
8.   page tab list_Swatches_SELECT[0] 
9.   mouse panel_Swatches_CLICK[Click_19_4] 
10. push button_OK_CLICK 11. push button_OK_CLICK 
 
Test Case Two  
1.   menu_Utilities_CLICK 
2.   menu_Utilities|Quick settings_CLICK 
3.‚ÄØmenu item_Utilities|Quick settings|Edit syntax  
      style of        token under caret_CLICK 4.   check box_Bold_CLICK 
5.   check box_Background color:_CLICK 
6.   push button_Background color:_CLICK 
7.   page tab list_Swatches_SELECT[0] 8.   typing panel_Swatches_SELECT[Cursor_0_0] 
9.‚ÄØtyping 
panel_Swatches_SELECT[Command_[Right]: 
      [Space]_0_0] 
10.  push button_OK_CLICK 
11.  check box_Italics_CLICK 
12.  push button_OK_CLICK 



Example Test Case XML  
(Test Case One) 
Fig. 6. Our running example produces test cases that bold, italicize, and
change the background color of text, in any order. The atomic constraint
ensures that the background color activation checkbox is checked immediatelyprior to the color selection window being opened in every test case. On the
left we show two abstract test cases consisting of just the steps. On the right
we show the partial XML for the Ô¨Årst test case.
number. The output from the generation step is a set of test
case Ô¨Åles that can be executed on the application. In this step,the application is opened by EFS, and sent events mapping tothe descriptions given in the test case Ô¨Åle. Some Java Swingapplications are intolerant to ‚Äúsoft closing‚Äù of an application‚Äôswindows by test automators. (Applications may block the userfrom doing so at certain stages where other forms of input liketext input are required, or the app may hold up the system inorder to write Ô¨Åles to the Ô¨Åle system). Choi et al. [21] point thisout as a problem when testing GUI‚Äôs. We use remote methodinvocation (RMI) to avoid this problem. Since EFS opens theapplication in a subprocess, it has control over restarting theapplication for the next test case, and prevents the underlyingsystem under test from interfering with this process.
The output from this operation is a set of snapshots that
demonstrate all of EventFlowSlicer‚Äôs actions. Borrowing fromtechniques used in [10], EFS executes an action, and thentakes a visual snapshot to provide a graphical story of whathappened during the test case. Images from a variant of ourrunning example, jEdit Commented Text, were used to helpverify the over 200 test cases we got back from one of ourtasks [17].
IV . V
ALIDA TION
In our initial work [17] we validated EventFlowSlicer on
a set of tasks comprising 21 user goals on four differentapplications. These include both structural only goals, aswell as those which have functional differences and whichare abstract. The Ô¨Årst twelve (structural) were taken fromprior work on human performance regression testing [10] forLibreOfÔ¨Åce. There were four core tasks (two on Writer, one
959
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. for Calc and one for Impress). Each of these was performed
on three different versions of the system, one that had onlymenus, one that had menus and keyboard shortcuts, and onewith menus, keyboard shortcuts and toolbar buttons). Usingthis study, we were able to conÔ¨Årm that we generated theexact same test cases that the HPRT generator would producewhen fed similar inputs.
Furthermore, we evaluated the generation of nine newer
goal-based test suites (six that were based on Stack OverÔ¨Çow
questions and three that we created for other applications).We used three applications: jEdit, DrJava and TerpWord.For each of these tasks we performed the full workÔ¨Çow ofEventFlowSlicer, beginning with capture. The test case count
of these test suites ranged from 3 to 200 (average of 38).Test generation times (after capture and constraints) rangedfrom 5 seconds (4 test cases) to 19.6 seconds (200 test cases).For this study, we validated each test case against the test
cases generated via the HPRT technique (in the 12 instances
where we mimicked their goal). For the other test cases
we manually examined the test cases. The runtime for testgeneration of EventFlowSlicer showed a 63.1% reduction overthe HPRT test generation technique. The goal used in therunning example here is a restricted version of the CommentedText, BG task
2.
V. C ONCLUSIONS AND FUTURE WORK
This paper has presented EventFlowSlicer, a goal-based
tool for test speciÔ¨Åcation and generation. EventFlowSlicer
allows the tester to capture relevant widgets for a task, specifyconstraints and then automatically extract a model, generate
tests and replay them. All intermediate artifacts are saved sothe tester can start at any point in the process, and/or edit themmanually. We have examined the use of EventFlowSlicer, inhelping with the task of exploring the space of all possibilities
in a goal (changing commented text‚Äôs background color, andmaking it bold and italic in jEdit). The user performs themanual steps of capture and deÔ¨Åning constraints as input to
the generator, which then creates a test suite of 12 test cases
covering all intended manners of accomplishing our goal.
In future work we will make EventFlowSlicer available
for others to use and extend. We also plan to develop amethod to construct a graph of the outcome of a test suitereplay operation. One use of this graph is to help interfacedesigners weed out pathologically long scenarios that userswould have trouble executing. A second use when paired with
our snapshots, would be to visualize where bugs appear in aninterface, and to help localize faults to certain usage scenarios.
We also intend to evaluate the usability of the tool and evaluatethe difÔ¨Åculty of deÔ¨Åning constraints.
A
CKNOWLEDGMENTS
This work was supported in part by National Science
Foundation grants CCF-1161767, CNS-1205472 and CCF-1745775.
2Artifacts from our validation study [17] can be found at: http://cse.unl.
edu/‚àºmyra/artifacts/EventFlowSlicer/REFERENCES
[1] A. M. Memon and Q. Xie, ‚ÄúStudying the fault-detection effectiveness
of GUI test cases for rapidly evolving software,‚Äù IEEE Transactions on
Software Engineering, vol. 31, no. 10, pp. 884‚Äì896, Oct. 2005.
[2] G. Bae, G. Rothermel, and D.-H. Bae, ‚ÄúOn the Relative Strengths of
Model-Based and Dynamic Event Extraction-Based GUI Testing Tech-
niques: An Empirical Study,‚Äù in International Symposium on Software
Reliability Engineering (ISSRE), Nov. 2012, pp. 181‚Äì190.
[3] F. Gross, G. Fraser, and A. Zeller, ‚ÄúSearch-based system testing: High
coverage no false alarms,‚Äù International Symposium on Software Testing
and Analysis (ISSTA), pp. 67‚Äì77, 2012.
[4] T. Monteiro and A. C. R. Paiva, ‚ÄúPattern Based GUI Testing Modeling
Environment,‚Äù in International Conference on Software Testing, V eriÔ¨Å-
cation and V alidation Workshops (ICSTW), Mar. 2013, pp. 140‚Äì143.
[5] X. Y uan, M. Cohen, and A. Memon, ‚ÄúGUI interaction testing: Incor-
porating event context,‚Äù IEEE Transactions on Software Engineering,
vol. 37, no. 4, pp. 559 ‚Äì574, 2011.
[6] S. Carino and J. H. Andrews, ‚ÄúDynamically Testing GUIs Using
Ant Colony Optimization,‚Äù in International Conference on Automated
Software Engineering (ASE), Nov. 2015, pp. 138‚Äì148.
[7] L. Mariani, M. Pezze, O. Riganelli, and M. Santoro, ‚ÄúAutoBlackTest:
Automatic Black-Box Testing of Interactive Applications,‚Äù in Interna-
tional Conference on Software Testing, V eriÔ¨Åcation and V alidation, Apr.
2012, pp. 81‚Äì90.
[8] S. Bauersfeld and T. E. J. V os, ‚ÄúGUITest: A Java Library for Fully
Automated GUI Robustness Testing,‚Äù in International Conference on
Automated Software Engineering (ASE), 2012, pp. 330‚Äì333.
[9] B. N. Nguyen, B. Robbins, I. Banerjee, and A. Memon, ‚ÄúGUITAR:
an innovative tool for automated testing of GUI-driven software,‚ÄùAutomated Software Engineering, vol. 21, pp. 65‚Äì105, 2013.
[10] A. Swearngin, M. B. Cohen, B. E. John, and R. K. Bellamy, ‚ÄúHuman
performance regression testing,‚Äù International Conference on Software
Engineering (ICSE), pp. 152‚Äì161, 2013.
[11] R. M. L. M. Moreira and A. C. R. Paiva, ‚ÄúPBGT Tool: An integrated
modeling and testing environment for pattern-based GUI testing,‚Äù in
International Conference on Automated Software Engineering (ASE),
2014, pp. 863‚Äì866.
[12] A. M. Memon, M. E. Pollack, and M. L. Soffa, ‚ÄúHierarchical GUI
test case generation using automated planning,‚Äù IEEE Transactions on
Software Engineering, vol. 27, no. 2, pp. 144‚Äì155, Feb. 2001.
[13] S. Zhang, H. L ¬®u, and M. D. Ernst, ‚ÄúAutomatically Repairing Broken
WorkÔ¨Çows for Evolving GUI Applications,‚Äù in International Symposium
on Software Testing and Analysis (ISSTA), 2013, pp. 45‚Äì55.
[14] M. Bozkurt and M. Harman, ‚ÄúAutomatically generating realistic test in-
put from web services,‚Äù in International Symposium on Service Oriented
System (SOSE), Dec. 2011, pp. 13‚Äì24.
[15] P . McMinn, M. Shahbaz, and M. Stevenson, ‚ÄúSearch-Based Test Input
Generation for String Data Types Using the Results of Web Queries,‚Äù
inInternational Conference on Software Testing, V eriÔ¨Åcation and V ali-
dation, Apr. 2012, pp. 141‚Äì150.
[16] L. Mariani, M. Pezz `e, O. Riganelli, and M. Santoro, ‚ÄúLink: Exploiting
the Web of Data to Generate Test Inputs,‚Äù in International Symposium
on Software Testing and Analysis (ISSTA), New Y ork, NY , USA, 2014,
pp. 373‚Äì384.
[17] J. Saddler and M. B. Cohen, ‚ÄúEventFlowSlicer: Goal based test gen-
eration for graphical user interfaces,‚Äù in International Workshop on
Automating Test Case Design, Selection, and Evaluation (A-TEST),2016, pp. 8‚Äì15.
[18] J. A. Saddler, ‚ÄúEventFlowSlicer, a goal-based test case generation
strategy for graphical user interfaces,‚Äù Master‚Äôs thesis, University ofNebraska, Lincoln, 2016.
[19] A. M. Memon, ‚ÄúAn event-Ô¨Çow model of GUI-based applications for
testing,‚Äù Journal of Software Testing, V eriÔ¨Åcation and Reliability, vol. 17,
pp. 137‚Äì157, 2007.
[20] (2014, April) Highlight comments background in Jedit.
[Online].
Available: https://stackoverÔ¨Çow.com/questions/27180136/
highlight-comments-background-in-jedit
[21] W. Choi, G. Necula, and K. Sen, ‚ÄúGuided GUI Testing of Android
Apps with Minimal Restart and Approximate Learning,‚Äù SIGPLAN Not.,
vol. 48, no. 10, pp. 623‚Äì640, Oct. 2013.
960
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:30:50 UTC from IEEE Xplore.  Restrictions apply. 