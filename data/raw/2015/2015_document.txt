A Programming Model for Sustainable Software
Haitao Steve Zhu Chaoren Lin Yu David Liu
ySUNY Binghamton, Binghamton, NY 13902, USA, Email: fhzhu1,clin18,davidL g@binghamton.edu
Abstract ‚ÄîThis paper presents a novel energy-aware and
temperature-aware programming model with Ô¨Årst-class support
forsustainability . A program written in the new language, named
Eco, may adaptively adjusts its own behaviors to stay on a
given (energy or temperature) budget, avoiding both deÔ¨Åcit that
would lead to battery drain or CPU overheating, and surplus
that could have been used to improve the quality of results.
Sustainability management in Eco is captured as a form of supply
and demand matching, and the language runtime consistently
maintains the equilibrium between supply and demand. Among
the efforts of energy-adaptive and temperature-adaptive systems,
Eco is distinctive in its role in bridging the programmer and the
underlying system, and in particular, bringing both programmer
knowledge and application-speciÔ¨Åc traits into energy optimiza-
tion. Through a number of intuitive programming abstractions,
Eco reduces challenging issues in this domain ‚Äî such as
workload characterization and decision making in adaptation ‚Äî
to simple programming tasks, ultimately offering Ô¨Åne-grained,
programmable, and declarative sustainability to energy-efÔ¨Åcient
computing. Eco is an minimal extension to Java, and has
been implemented as an open-source compiler. We validate the
usefulness of Eco by upgrading real-world Java applications with
energy awareness and temperature awareness.
I. I NTRODUCTION
Two trajectories appear to shape up the evolution of modern
computing platforms: they become increasingly ‚Äúnimble,‚Äù or
increasingly ‚Äúmighty.‚Äù ‚ÄúNimble‚Äù computers‚Äîsuch as RFIDs,
wearable electronics, smartphones, tablets, and laptops‚Äî
often operate on battery with a limited budget. ‚ÄúMighty‚Äù
computers‚Äîrepresented by data centers, cloud servers, and
many-core clusters‚Äînot only consume a large amount of
energy, but also face grave reliability concerns due to excessive
heat dissipation, with cooling taking up to 35% of their op-
erational costs [3]. Effective energy and thermal management
is a critical goal demanding solutions from all layers of the
compute stack. In recent years, there is a growing interest in
addressing these challenges from the perspective of application
software ( e.g., [16], [5], [21], [35], [25], [17], [33], [34], [29],
[32], [20], [39], [4], [36], [10], where energy and thermal
efÔ¨Åciency is pursued and achieved throughout the software
lifecycle.
In this paper, we focus on an essential design goal in
energy and thermal management: sustainability . A sustainable
program is able to ‚Äústay on budget,‚Äù neither yielding deÔ¨Åcit
nor surplus. In the context where ‚Äúbudget‚Äù refers to available
battery ‚Äî e..g., 20% battery of a smartphone ‚Äî sustainability
entails energy awareness : the sustainable program makes the
best effort to not exceed 20% of battery usage (no deÔ¨Åcit),
*The Ô¨Årst and second authors have recently joined Google Inc. after completing the
work at SUNY Binghamton.
Fig. 1. A Sustainable Program Runtime
while at the same time producing as high-quality results as
possible (no surplus). In the context where ‚Äúbudget‚Äù refers to
the allowance of temperature increase ‚Äî e.g., 10C ‚Äî sustain-
ability entails temperature awareness : avoiding overheating
while producing the best results. In essence, sustainability
captures a recurring theme in energy and thermal management:
balancing the trade-off between energy/thermal budget and the
quality of computational results.
A.Eco for Sustainable Programming
Our concrete proposal is Eco, a novel and simple program-
ming model to help developers construct sustainable software
by design. As we look forward, we believe programmers
have a unique role in application-level energy and thermal
management, and the future of software on ‚Äúnimble‚Äù and
‚Äúmighty‚Äù computing platforms belongs to applications that
neither ‚Äúsquander‚Äù nor ‚Äúskimp‚Äù on resources.
The key insight of the Eco design is that sustainability
can be achieved through the negotiation between supply and
demand , ultimately maintaining the equilibrium of the two in
a fashion similar to market economics. Syntactically, Eco is a
minimal extension to Java, with two important programming
abstractions:
Demand/Supply Characterization : anEco programmer
may associate a Ô¨Åne-grained program component of inter-
est (the ‚Äúdemand‚Äù) with a budget (the ‚Äúsupply‚Äù), through
a new construct called sustainable blocks
Adaptability Support : anEco programmer may deÔ¨Åne
alternative application behaviors which may achieve the
same application-speciÔ¨Åc goal but with different quality
levels, through a principled and Ô¨Åne-grained construct
called Ô¨Årst-class mode cases
Throughout the execution of the code enclosed in the
sustainable block, the Eco program runtime continuously
monitors the change in demand and supply. As demonstrated in
Figure 1, the sustainable execution should have the remaining
demand (the solid line) closely matches the remaining supply
(the dotted line). If demand far exceeds supply at a snapshot ofthe execution, the program adapts to program behaviors that
may produce results in lower quality. If supply far exceeds
demand, adaptation in the opposite fashion happens.
In a nutshell, the design scope of Eco subsumes pro-
gramming abstractions to capture the essence of sustainable
programming, compiler inference algorithms to automatically
identify program points for monitoring and adaptation, and
language runtime support to efÔ¨Åciently maintain the balance
between demand and supply.
B. Contributions
To the best of our knowledge, Eco is the Ô¨Årst program-
ming model to provide Ô¨Årst-class support for characterizing,
negotiating, and maintaining budget in energy-aware and
temperature-aware applications. This is also the Ô¨Årst time
fundamental concepts in market economics ‚Äî supply and
demand ‚Äî are crystalized as programming abstractions. In
the context of existing energy/thermal budget management
systems [12], [38], [40], [9], [11], [13], [27]‚Äîmost from
VLSI, architecture, and OS communities‚Äî Eco is distinctive
in its attempt to bridge application software with underlying
systems, for at least three distinct reasons:
1) it elevates predominately system-level concepts such as
energy budgeting and temperature control to the fore-
front of application software development, through supply
characterization.
2) it taps the knowledge and insight of programmers to
automate Ô¨Åne-grained energy and thermal management,
through demand characterization.
3) it brings green-conscious programmers into the equation
of energy and thermal optimization, through principled
programmer-deÔ¨Åned adaptability support.
Eco is a rigorously deÔ¨Åned language [41], but more impor-
tantly, it is also a practical and expressive programming model
for developing sustainable real-world applications. This paper
places emphasis in highlighting Eco‚Äôs role in green software
engineering: how it empowers programmers with battery and
temperature awareness, how it helps balance the trade-off
between energy/thermal efÔ¨Åciency and quality of service,
and what the recurring programming patterns in sustainable
software are. Eco is developed as an open-source compiler:
https://github.com/pl-eco/ECO
In summary, this paper makes the following contributions:
It introduces a simple programming model to provide
Ô¨Åne-grained sustainability through supply/demand char-
acterization, program transformations to automate and op-
timize sustainability management, and a program runtime
design to allow for supply/demand negotiation.
It provides Ô¨Årst-class support to adaptive software. The
design considers the consistency in adaptation, and seam-
lessly integrates adaptability and sustainability through
compiler-directed automatic calibration and adaptation.
It describes a set of common programming idioms, which
may serve as a Ô¨Årst-step toward understanding program-1modefl o<: midg;
2modefmid<: h ig;
3
4c l a s s R a y t r a c e rf
5 mcase<Res>r e s =f
6 l o : new Res ( 6 4 0 , 4 8 0 ) ;
7 mid : new Res ( 8 0 0 , 6 0 0 ) ;
8 h i : new Res ( 1 0 2 4 , 7 6 8 ) ;
9g;
10
11 mcase<i n t>d e p t h =f
12 l o : 1 0 ;
13 mid : 2 0 ;
14 h i : 3 0 ;
15g;
16
17 Ray [ ] [ ] getView ( Camera camera , Res r e s ) f. . .g
18
19 Image [ ] run ( Camera camera , Model [ ] models ) f
20 Image [ ] images ;
21 i n t num , IMAX, JMAX, IMGS = 1 00 ;
22 s u s t a i n a b l ef
23 f o r ( num = 0 ; num <IMGS ; num++)f
24 uniformf
25 Ray [ ] [ ] view = getView ( camera , r e s ) ;
26 Image image = new Image ( r e s ) ;
27 IMAX = r e s . y ;
28 JMAX = r e s . x ;
29g
30 f o r (i n t i = 0 ; i<IMAX; i ++)f
31 f o r (i n t j = 0 ; j<JMAX; j ++)f
32 image . s e t C o l o r ( i , j ,
33 view [ i ] [ j ] . t r a c e ( models [ num ] , d e p t h )
34 ) ;
35g
36g
37 images [ num ] = image ;
38g
39g
40 bsupply ( 0 . 2b a t t e r y )
41 demand (IMGS) >(IMGS num ) ;
42 return images ;
43g
44g
45c l a s s Modelf. . .g / / model t o be r e n d e r e d
46c l a s s Cameraf. . .g / / camera f o r r e n d e r i n g
47c l a s s Imagef. . .g / / 2D a r r a y o f c o l o r p i x e l s
48c l a s s Rayf. . .g / / ray
49c l a s s Resf. . .g / / r e s o l u t i o n
Fig. 2. A Battery-Aware Raytracing Application
ming patterns in sustainable programming and construct-
ing energy-aware and temperature-aware software.
It demonstrates the feasibility and effectiveness of sus-
tainable programming through extending real-world ap-
plications with the ability of battery awareness and tem-
perature awareness, enabled by an open-source compiler.
II. S USTAINABLE PROGRAMMING BY EXAMPLE
We use a simple raytracing example in Figure 2 to demon-
strate the basic ideas of sustainable programming. Raytracing
is a technique in rendering where an object in the form of a
Model is rendered into an Image ‚Äîa 2D array of colored
pixels‚Äîbased on the Rays cast from the Camera to the
object. Eco is an extension to Java, with several notable
features we highlight next.
a) Sustainable blocks: An energy-conscious programmer
may declare the most expensive part of her program in
sustainable blocks . In this example, the block encloses theray tracing for IMGS number of images, as shown between
Line 22 and Line 41. The programmer can set a budget for
executing this code fragment through supply characterization :
in Line 40, the budget (also known as supply sum ) is set at
20% of the remaining battery. To help the language runtime
correlate the change in battery over time and the progress of
the program execution, Eco programmers are asked to provide
a ‚Äúprogress indicator‚Äù through demand characterization . In
this simpliÔ¨Åed example, the programmer just says that the
demand sum ‚Äîi.e., the overall number of units of work‚Äî
isIMGS (the number of images), and at a given moment
during the sustainable block execution, the demand gauge ‚Äî
the indicator for the remaining number of units of work‚Äî
is dependent on the loop index num,i.e., through expression
IMGS - num . Based on supply characterization and demand
characterization, Eco introspects
the proportion of remaining demand, i.e., demand gauge
relative to demand sum and
the proportion of remaining supply, i.e., remaining battery
supply relative to overall battery supply
at various automatically determined ‚Äúcheckpoints‚Äù during the
execution of the sustainable block, and deem the execution:
(i) sustainable if the two are on similar levels; (ii) deÔ¨Åcit if
the former signiÔ¨Åcantly exceeds the latter; (iii) surplus if the
latter signiÔ¨Åcantly exceeds the former.
b) Modes and First-Class Mode Cases: Whenever deÔ¨Åcit
or surplus happens, the program adjusts itself, guided by
speciÔ¨Åcations of modes and Ô¨Årst-class mode cases.
Borrowed from a previous work [10], modes are a discrete
characterization of energy adaptation states. In Line 1 and
Line 2, the program deÔ¨Ånes three modes, lo,mid, and hi,
indicating the program may function under three different
states of adaption. In Eco, modes form a total order, with
lo/mid/hiin the example aligned with the intuition that the
resulting code is likely to consume the least/average/most en-
ergy and produce results of the lowest/average/highest quality,
respectively.
Modes matter in Eco because they play a central role in the
design of mode cases . In a nutshell, a mode case is a data-
centric way to deÔ¨Åne alternative behaviors in the presence of
energy adaption. In the example, two mode cases are deÔ¨Åned
as Ô¨Åelds: (i) the res Ô¨Åeld in Line 5 that says the Raytracer
may use the resolution of 640480when program is executing
thelomode, 800600 in the mid mode, and 1024768
in the himode; (ii) the depth Ô¨Åeld in Line 11 that says the
depth of Raytracer ‚Äîa key parameter to control the quality
of raytracing‚Äîmay be either 10, 20, or 30, depending on the
mode of the executing program. Mode cases in Eco areÔ¨Årst-
class values : they can be assigned to variables, passed around
as method parameters, or stored in Ô¨Åelds.
To tie everything together, the executing sustainable block
‚Äúdowngrades‚Äù the mode of its execution whenever deÔ¨Åcit
happens‚Äîpicking a precedent in the total order‚Äîand the
mode case used in that block can be intuitively viewed as
automatically reduced to the value associated with the new
mode, a step we call mode case selection . For example, the
Fig. 3. Potentially Inconsistent Results (This image was produced by
executing a variation of our sunflow benchmark ‚Äî a real-world raytracing
application detailed in Section VI ‚Äî where the uniform block enclosing the
image rendering is removed.)
mode case of depth under the execution of mid mode would
be selected into 20. The scenario for surplus is similar, except
that the sustainable block ‚Äúupgrades‚Äù its mode. The described
behavior here is aligned with our intuition of sustainability: the
program adapts to the less energy-consuming behavior when it
runs into a deÔ¨Åcit and to the more energy-consuming behavior
when it runs into a surplus.
c) Uniform Blocks: Coming with the Ô¨Çexibility of Ô¨Årst-
class mode cases is a design challenge: allowing for mode
case selection at arbitrary time may yield results unacceptable
to programmers. For instance, had we allowed the image
resolution to change half way through raytracing an image,
the program may produce a picture such as Figure 3, whose
uneven rendering may unsettle (some) programmers.
AnEco programmer may choose to declare a block of
code as uniform , as in Line 24 to Line 29. This precludes
mode change from happening during the execution of said
block. This consistency-preserving construct is reminiscent of
the property of atomicity [15], [22], [19].
d) Battery-Awareness and Temperature Awareness: The
example here is an instance of battery-aware programming.
With minimal changes, the same program can turn into
a temperature-aware one: by simply changing Line 40 to
tsupply (10), the same sustainable block is to be executed
with a (temperature) budget of 10C,i.e.not raising CPU
temperatures by more than 10C. The similarity and sym-
metry of battery-aware programming and temperature-aware
programming in Eco do not come as a surprise. They are
uniÔ¨Åed under the same philosophy: just like the allowance of
battery usage during a program execution can be viewed as a
‚Äúbudget,‚Äù the allowance of temperature raise during a program
execution can also be viewed as a ‚Äúbudget.‚Äù As a consequence,
demand/supply-style characterization and programming are
applicable to both goals, and the uniÔ¨Åed programmer view
is an attractive trait to improve programmer productivity.
Indeed, the uniÔ¨Åcation of battery-aware programming and
temperature-aware programming goes deeper than syntactical
similarities. As we shall see in the next section, the bsupply
andtsupply constructs are both syntactical sugars of a more
general programming abstraction, and the two hence share the
same semantic deÔ¨Ånition.batterydef= b:getB ()
sustainablefegbsupply (e1)demand (e2) >(e0
2)def= num x=b:getB ();
sustainablefegsupply (e1) >(e1 x+b:getB ())demand (e2) >(e0
2)
temperaturedef= t:getT ()
sustainablefegtsupply (e1)demand (e2) >(e0
2)def= num x=t:getT ();
sustainablefegsupply (e1) >(e1 x+t:getT ())demand (e2) >(e0
2)
Fig. 4. Syntax Desugaring for Battery/Temperature-Aware Sustainable Programming (Let bandtvariables of BatteryManager andTempManager
types respectively. The BatteryManager class encapsulates the program logic for interacting with battery hardware, with one method getB to query the
current battery level. The TempManager class encapsulates the program logic for interacting with temperature sensors , with one method getT to query
the current temperature)
III. T HEECODESIGN : SYNTAX AND RUNTIME SUPPORT
A. Syntax Overview
Just like Java, an Eco program consists of a sequence
of classes, with one containing the entry method main . In
addition, an Eco program allows for top-level mode decla-
rations in the form of mode m<:m. We require the <:
relation deÔ¨Åned through these declarations forms a total order.
We further call the least element and greatest element in the
total order the least mode and greatest mode respectively.
Implicitly parameterized by these top-level mode declarations,
unary operators"and#are standard successive and precedent
operators over total order. Furthermore, we deÔ¨Åne "masmif
mis the greatest mode and #masmifmis the least mode.
The core expressions of Eco are deÔ¨Åned as follows:
e::= uniformfeg expression
j f m1:e1;:::mn;eng
jsustainablefeg(c)
jselecte
jcalibe
jJava expressions
c::=he;e;e;ei characterizer
::= numjXjmcasehi type
For simplicity, we treat statements as expressions. Expres-
sion uniformfegdeÔ¨Ånes a uniform block whose body is e. We
explain the rest of the syntax shortly. A type in Eco may take
three forms: 1) a primitive type ( e.g., integer, Ô¨Çoat), which is
abstractly represented as num for simplicity here; 2) an object
type X, where Xis the name of a class; 3) a type for the mode
case value mcasehi, which says that the mode case has case
members whose types are .
B. Runtime Behavior Overview
The unique runtime features of Eco center around the
execution of a sustainable block. There, the (sum and re-
maining) supply and the (sum and remaining) demand are
monitored through checkpoints, each of which we call a step
ofsupply/demand calibration , or calibration for short. This
leads to four interconnected questions at the center of Eco
design:
Q1: How to calibrate?
Q2: How should the program adapt based on calibration
(through mode case selection)?Q3: When to calibrate?
Q4: When to select mode cases?
We answer Q1in Section III-C3 and Q2in Section III-D.
To decouple Q3from Q1, and Q4from Q2for presen-
tation purposes, we introduce two convenience expressions
to make calibration point and mode case selection point
explicit, calibe, and selecte. The Ô¨Årst expression says that
calibration should be triggered after the evaluation of e, and
the second expression says that the mode case represented by
eshould be selected. In other words, when we answer Q1
and Q2, we circumvent the ‚Äúwhen‚Äù questions by assuming
they are explicitly ‚Äúmarked‚Äù in the program. In Section IV,
we will introduce several program transformations to answer
Q3andQ4,i.e., automatically inserting calibeandselecte
expressions to the Eco source program.
C. Syntactical and Runtime Support for Sustainability
1) Syntax and Encodings: The general form of a sustain-
able block in Eco is as follows:
s u s t a i n a b l ef
::: / / code i n t h e s u s t a i n a b l e b l o c k
g
supply (e1) >(e2)
demand (e3) >(e4)
wheree1,e3,e4are the expressions for representing the supply
sum,demand sum ,demand gauge we informally introduced in
Sec. II, respectively. The additional expression e2is called the
supply gauge , an expression to indicate the remaining supply.
In this presentation, we also abbreviate the sustainable block
above as sustainablef:::g(he1;e2;e3;e4i), and further call
he1;e2;e3;e4ithecharacterizer of the sustainable block.
Indeed, the sustainable blocks with bsupply and tsupply
keywords introduced earlier are syntactic sugars, which can
be encoded as in Fig. 4. As we shall see in Sec. V, Eco pro-
grammers can account for Ô¨Çexible forms of supply variability
through supply gauge programming.
2) Sustainable Stack: AEco program runtime maintains a
key data structure called a sustainability stack (represented by
S), or S-stack for short. The S-stack maintains the contexts of
sustainable/uniform blocks: at a runtime state, each entry of
this stack intuitively says that the current encountered program
point is dynamically scoped in the sustainable/uniform block
represented by the entry, with the top entry representing themost recently encountered scope. There are two important
features to highlight from this design:
Eco supports sustainability management across lexical
scopes.
Eco supports nested sustainable blocks, and nesting be-
tween sustainable blocks and uniform blocks.
The Ô¨Årst support is a necessity for object-oriented lan-
guages: object references can escape lexical scope, and as a
result, the program point of calibration may not be lexically
enclosed in the sustainable/uniform blocks. In the technical
report [41], we provide a detailed example to illustrate this
technicality. The S-stack design Ô¨Çexibly enables sustainability
management for all program points reachable from a sustain-
able/uniform block.
The support of nested blocks is important for two reasons.
First, this facilitates modular programming, e.g., in a scenario
where the designer of a library API declares a sustainable
block within the API method, and at the same time the client
program using the API may declares its own (nesting) sus-
tainable block. More importantly, nesting support also enables
Ô¨Çexible sustainable programming where battery awareness and
temperature awareness is required at the same time.
Structurally, each S-stack entry can take one of the two
forms (1) a two-element tuple in the form of (e:m), wheree
is the characterizer expression of the sustainable block, and m
is the mode of the current sustainable block execution, called
theoperational mode . (2) a constant element ?, indicating the
entry representing a uniform block.
When the program bootstraps, we place an initial entry to
the S-stack, whose operational mode is the greatest mode in
the mode speciÔ¨Åcation (a total order). This default treatment is
aligned with our intuition that an expression not reached from
any programmer-declared sustainable block should not subject
to sustainability management, so the mode that represents
the highest quality of service is used. Upon the entry of a
programmer-declared sustainable block, an entry (e:m)is
pushed to the stack, where eis the characterizer, and mis
initially the same as the ‚Äúcurrent‚Äù operational mode before
the block is entered, where the notion of ‚Äúcurrent‚Äù is deÔ¨Åned
by the following function:
MNOW (S)def= m ifS=S0;(e:m)
MNOW (S)def= MNOW (S0)ifS=S0;?
This design is useful in the presence of nested sustainable
blocks, where the inner block starts operating at a mode
sustainable for the outer block.
3) Sustainability Management as Supply/Demand Match-
ing: Upon the evaluation of the calib expression, there are
two possibilities:
If any entry in the S-stack is ?, the calibration is a no-op.
Otherwise, supply/demand matching will be performed
for all S-stack entries, with the top item being performed
Ô¨Årst. The detailed matching process will be explained
next. The deÔ¨Ånition supports nesting, where sustainabilitymanagement applies to all blocks, with the most imme-
diate (inner) block Ô¨Årst.
For each instance of supply/demand matching, the supply
sum expression, the supply gauge expression, the demand sum
expression, and the demand gauge expression will in turn be
evaluated to a numerical value. Let us denote them as n1,
n0
1,n2,n0
2respectively. The matching between supply and
demand is captured by the following predicate, where is a
small positive numeric constant close to 0:
MATCH (hn1;n0
1;n2;n0
2i)def=jn0
1
n1 n0
2
n2j
SURPLUS (hn1;n0
1;n2;n0
2i)def=n0
1
n1 n0
2
n2>
DEFICIT (hn1;n0
1;n2;n0
2i)def=n0
2
n2 n0
1
n1>
Eco language implementation selects = 0:1by default:
the program is considered ‚Äúsustainable‚Äù if the remaining pro-
portions of supply and demand are within 10% difference.
D. First-Class Mode Cases
Expressionfm1:e1;:::mn;engrepresents a mode case,
where each element mk:ek(for1kn) in the sequence
is called a case member . At run time, the expression associated
with each case member is evaluated at mode case deÔ¨Ånition
time. As a result, each case member of a mode case holds a
value at runtime.
First-class mode cases at run time are selected based on the
operational mode. For now, to circumvent Q4, let us assume all
mode case selection points are explicitly identiÔ¨Åed, through the
select expression. The expression selecteat run time evaluates
tovifollowing this deÔ¨Ånition:
fm1:v1;:::; mn:vng=mdef=vi
whereeevaluates tofm1:v1;:::; mn:vng,mis the oper-
ational mode, and miis the least mode among fm1;:::; mng
that is equal to or greater than maccording to the total order
deÔ¨Åned by the program.
Recall that the program bootstraps with the greatest mode.
This implies when a select expression appears outside of any
sustainable block, the greatest mode is used. This aligns with
our intuition that code not subject to sustainability manage-
ment should not be approximated.
IV. T HEECODESIGN : COMPILER SUPPORT
In this section, we describe compiler support, primarily
answering Q3andQ4.
A. Automated Calibration Insertion
We now deÔ¨Åne a compiler transformation to automatically
identify and insert calib expressions. Several design choices
are possible: (1) check periodically; (2) check whenever the
supply gauge changes; (3) check whenever the demand gauge
changes. Route (1) is ad hoc , especially when selecting a Ô¨Åxed
‚Äúperiod‚Äù that Ô¨Åts all programs. For (2), the supply gauge in
energy-aware programming is often associated with system-
level variables (such as remaining battery) whose updates are
often performed outside the program runtime and out of thecontrol of programmers. This may lead to platform-dependent
behaviors: the same program may calibrate at different rates
on two computers with different battery drivers.
Eco follows route (3). Demand gauge is typically an ex-
pression formed with program variables, such as loop index
in the example in Figure 2. The state change of these variables
is visible and predictable to the programmer. For application-
level energy management strategies‚Äîa family that Eco be-
longs to‚Äîwe believe the programmer should have control on
program behaviors related to energy awareness.
We now deÔ¨Åne the transformation process. The transforma-
tion is isomorphic except that expression eis transformed to
calibeiff:P0(e)^(P1(e)_P2(e)), where:
P0(e):ecan only be reached from uniform blocks
P1(e):eis assignment, and the left-hand side variable
appears in the demand gauge of lexically enclosing
sustainable blocks
P2(e):eis a Ô¨Åeld write expression, and said Ô¨Åeld is read in
the demand gauge of any sustainable block that may
reache
The implementation of the three predicates has little novelty.
P1is a trivial local analysis. Our Eco implemented P0and
P2through a standard context-sensitive reachability analysis.
Furthermore, observe that when eis reachable from both
uniform blocks and non-uniform blocks, calib will be inserted.
This is sound because its evaluation will become a no-op when
reached from a uniform block ( ?is in the S-stack).
B. Automated Mode Selection Insertion
The syntax we introduced earlier requires programmers to
select mode cases explicitly through the select expression.
For example, to assign a variable yofmcasehintitype to
variable xofinttype, programmers need to write x=select y.
This can be an onerous task for programmers, especially for
incremental programming, where programmers start with a
program written in an existing language, and incrementally
‚Äútry out‚Äù new language abstractions. An Eco programmer
may start with a Java program, and alter a variable from, say,
holding a Res(1024, 768) object to the mode case we
used in Figure 2. If explicit select is needed, the programmer
would have to manually insert a select expression for every
occurrence of such variables in a sustainable block where the
mode case is meant to be selected.
We deÔ¨Åne a simple compiler transformation to relieve the
programmers of the burden of explicitly declaring select
expressions. The key insight is that Eco as a strongly typed
language provides sufÔ¨Åcient type information to compare both
the sending and the receiving ends of a data Ô¨Çow. For example,
if a programmer writes x=yin the program, and variable yis
ofmcasehintitype and variable xis of inttype, our compiler
transformation algorithm will transform it into x=select y.
More generally, the transformation is hinged upon the
deÔ¨Ånition of predicate (%0)#(e%e0), which says an
expressioneof typeshould be transformed to e0if it appears
at a program point expecting an expression of type 0. The
predicate holds iff either of the two holds: <<0
 <<0does not hold, and =mcaseh00i, and (00%
0)#(e%e0).
where the<< relation is reÔ¨Çexive and transitive, with two
additional rules.  << 0iff (i)is a subclass of 0; (ii)
=mcaseh0iand0=mcaseh0
0iand0<<0
0.
Some examples should be sufÔ¨Åcient to illustrate the ideas
here:
(mcasehnumi% num)#(e%selecte)
(mcasehmcasehnumii% num)#(e%select (selecte))
(mcasehXi%Y)#(e%selecte)where Xis a subclass of Y
Finally, the transformation is isomorphic, except that:
R1: For every expression where (sub-)expression eÔ¨Çows
to (sub-)expression e0, where the type of eande0are
and0respectively, we transform the aforementioned
expression to one the same as before, except that eis
replaced with e00, and (%0)#(e%e00). Here, the
‚ÄúÔ¨Çows-to‚Äù relation is the standard notion in data Ô¨Çow
analysis.
R2: For every expression where the (sub-)expression e
appears in a program point that serves as an object
target (such as the receiver of the method inovcation,
or Ô¨Åeld read or write), we transform the aforementioned
expression to one the same as before, except that e
is replaced with e00, and (%X)#(e%e00), and
ATOM (0) =X.
where ATOM ()is deÔ¨Åned as , except that it is deÔ¨Åned as
ATOM (0)if=mcaseh0i.
C. Type Checking
Type checking is deÔ¨Åned over the post-translation programs
where calib andselect expressions are explicit. It is largely
standard. The subtyping relation is deÔ¨Åned to be identical as
the<<relation. Forfm1:e1;:::mn;eng, we require the type
ofeifor1inbe a subtype of the declared type .
V. P ROGRAMMING IDIOMS
We now summarize common idioms we encountered while
programming in Eco. Broadly, the summary may serve as
a Ô¨Årst step toward understanding design patterns and micro-
patterns of sustainable software.
A. Abstract Supply Units
The sugared syntax bsupply use battery capacity ( mwh )
as the unit of supply, and syntax tsupply uses temperature
in Celsius. These units are not hardcoded in Eco. More
generally, an Eco programmer may choose any unit intuitive
and accurate for her sustainability management, as long as
such values can be obtained from underlying OS and hardware.
For example, popular battery-powered consumer computers
(laptops and smartphones) typically come with power man-
agement modules that can report the remaining operating time
(or remaining percentage). A sustainable block that should
consume no longer than 20% of the remaining operating time
can be programmed as:1double b u d g e t = M A X;
2o l d = b a t t e r y ;
3s u s t a i n a b l ef
4 f o r (i n t num = 0 ; num <IMGS ; num++)f
5 i f( num == 0.1IMGS)f
6 b u d g e t = ( b a t t e r y o l d )9 ;
7g
8 . . .
9g
10g
11bsupply ( b u d g e t )
12demand ( . . . ) >( . . . ) ;
Fig. 5. Revisable Budget
1s u s t a i n a b l ef
2 double startROT = 0 . 2 getROT ( ) ;
3 . . .
4g
5(<startROT ; startROT  getROT ( ) ; . . . ; . . . >)
where getROT queries the system battery management mod-
ule for the remaining operating time.
In the real world, the suitable unit to report battery State-
of-Charge (SoC) [14] is dependent on many factors, such as
(i) the characteristics of batteries, e.g.lithium-based or nickel-
based; (ii) the support of OS, e.g. ACPI-compliant systems
and different vendor extensions (such as BatteryService1
in Android); (iii) the estimation algorithms. The more user-
friendly metrics‚Äîremaining percentage, or remaining operat-
ing time‚Äîare in fact derived metrics from lower-level battery
status data e.g., voltage level, current level, and coulomb
counts [14]. Under the backdrop of this diverse and fast-
changing landscape, the abstraction provided by Eco main-
tains a level of stability in the presence of technology changes.
B. Fixed Supply Characterization
Various forms of Ô¨Åxed battery budget characterization can
be directly supported:
Ô¨Åxed absolute battery budget ,e.g.,bsupply (20000) says
the execution can consume up to 20000mwh of battery.
Ô¨Åxed relative battery budget ,e.g.,bsupply (0:2battery )
says the execution can consume up to 20% of the remain-
ing battery.
maximum battery budget :e.g.,bsupply (battery )says the
execution can as much as the entire remaining battery.
Analogously, simple forms of temperature budget charac-
terization are supported:
Ô¨Åxed temperature threshold ,e.g., the use of tsupply (70 
temperature )says the execution should not increase the
CPU temperature to more than 70C.
Ô¨Åxed temperature increase ,e.g.,tsupply (20) says the
execution should not increase the CPU temperature by
more than 20C.
Ô¨Åxed temperature increase ratio ,e.g.,tsupply (1:1
temperature )says the execution should not increase the
CPU temperature by more than 10%.
1http://developer.android.com1i n t workdone = 0 ;
2i n t w o r k l e f t = IMGS r e s . xr e s . y ;
3s u s t a i n a b l ef
4 f o r (i n t num = 0 ; num <IMGS ; num++)f
5 . . .
6 f o r (i n t i = 0 ; i<IMAX; i ++)f
7 f o r (i n t j = 0 ; j<JMAX; j ++)f
8 . . .
9gg
10 workdone+= IMAX JMAX;
11 w o r k l e f t = (IMGS  num )IMAX; JMAX;
12 images [ num ] = image ;
13g
14g
15bsupply ( PERBUDGET)
16demand ( workdone + w o r k l e f t )  >( w o r k l e f t ) ;
Fig. 6. Adaptive Demand Characterization
C. Revisable Budget
InEco, both supply sum and supply gauge are expressions
reevaluated every time a calibration is performed. This implies
thebudget (the value of what the supply sum expression
evaluates to) does not need to remain constant throughout the
execution of the sustainable block. This feature can be useful
to adaptively set the budget. For example, a programmer may
not know at the beginning what a ‚Äúfair‚Äù budget would be, and
she can ‚Äútest run‚Äù a portion of the program to Ô¨Ånd out and
reset the supply budget. Consider the example in Figure 5.
Here, the program decides to executes 10% of the images,
and calculate the budget for the remaining 90% of the image
processing accordingly.
More broadly, revisable budget programming pattern may
also be useful in (1) energy-aware systems relying on renew-
able energy ( e.g., solar), where supply change is not monotone
as the sustainable block executes; (2) systems with adaptive
cooling devices, where temperature change may also follow
complex patterns.
D. Adaptive Demand Characterization
Just like supply, demand sum and demand gauge are also
expressions that are reevaluated upon calibration. This allows
programmers to adaptively adjust the demand during the
sustainable block execution. For instance, Figure 6 shows a
reÔ¨Åned version of Figure 2, where both the size of the overall
demand ( i.e., what the demand sum evaluates to) and the
size of the remaining demand ( i.e., what the demand gauge
evaluates to) may be adjusted. Here, we not only consider
the number of images as demand indicators, but also the
number of pixels in the images. In the new scheme, the
change of resolution would alter both the size of the overall
demand and the size of the remaining demand, because the
adoption of a lower resolution in rendering an image resulted
in both the slower-than-expected growth for completed work
(workdone ), and the reduction of the projected work ahead
(workleft ).
E. Non-Linear Behaviors
Battery-powered computer users often observe that the same
program execution that reduces battery from 80% to 78%0102030405060708090100
1 101 201 301 401 501 601 701 801 901 1001 1101 1201 1301 1401 1501 1601 1701%
 
Time(second)  normalized remaining supply normalized remaining demandFig. 7. sunflow (PER = 0.9)
0102030405060708090100
11 111 211 311 411 511 611 711 811 911 1011 1111 1211 1311%
 
Time(second)  normalized remaining supply normalized remaining demandFig. 8. sunflow (PER = 0.7)
0102030405060708090100
1 101 201 301 401 501 601 701 801 901 1001%
 
Time(second)  normalized remaining supply normalized remaining demand Fig. 9. sunflow (PER = 0.5)
may reduces the same battery from 5% to 1%. Such non-
linear battery behaviors are generally minimized by built-
in OS/Ô¨Årmware estimators for new batteries, but they may
become more pronounced as batteries age. If high precision on
battery supply is needed, such variations should not be ignored
and can be modeled in Eco as:
1s u s t a i n a b l ef
2 double s t a r t B = 0.2getB ( ) ;
3 . . .
4g
5supply ( s t a r t B ) ( s t a r t B  r e d r e s s ( getB ( ) ) )
6demand ( . . . ) ( . . . )
where redress is a custom-deÔ¨Åned function mapping read-
ings from getBP to the ‚Äúcompensated‚Äù values. For example,
one simplistic redress function would be to map value
btobifb0:2andbto0:9botherwise. As energy-
aware programming becomes more prevalent, we envision
such ‚Äúredress‚Äù functions would be part of the ‚Äúbattery proÔ¨Åle‚Äù
available to end programmers as library APIs.
A similar programming idiom can be applied for non-linear
thermal behaviors. According to solid matter physics, the
energy to increase the temperature from 30C to 35C and
that from 300C to 305C signiÔ¨Åcantly differ. (The range of
operating temperatures for CPUs is usually much narrower, so
the non-linear effect in this area is relatively small.)
The same idea can be applied to demand characterization.
Non-linear behaviors can be supported when redress is not
a linear function.
VI. I MPLEMENTATION AND EVALUATION
A. Implementation
Eco is implemented on top of the Polyglot compiler frame-
work 2.5 [28], as an extension to Java. The battery data was
queried through Advanced ConÔ¨Åguration and Power Interface
(ACPI) [1] and read by the program. The CPU temperature
was queried with the CoreTemp2API, in Celsius. CoreTemp
collects data directly from a Digital Thermal Sensor (DTS)
located in each individual processing core. There is no need
for external measuring devices or external circuit located on
the motherboard to report temperature.
B. Benchmarks
We selected the following Java benchmarks and modiÔ¨Åed
them into Eco: (1) sunflow ,3a rendering system that uses
raytracing, (2) jspider ,4a web crawler, (3) montecarlo ,5
2http://www.alcpu.com/CoreTemp
3http://sunÔ¨Çow.sourceforge.net/
4http://j-spider.sourceforge.net/
5http://www.javagrande.org/a Ô¨Ånancial simulation from the Java Grande benchmark suite,
(4)xalan ,6an XSLT processor that converts XML docu-
ments, and (5) rasterizer , from the batik7distribution,
that rasterizes SVG Ô¨Åles. Our main selection criterion is
diversity, covering domains such as graphics, web, statis-
tics, program transformation, and data transformation. These
benchmarks cover a diverse range of applications to support
variability in program behaviors, such as image resolution in
sunflow , URL request intervals in jspider , sampling size
inmontecarlo , and rasterization quality in batik . Several
selected benchmarks appeared in Dacapo8benchmark suite.
All experiments were performed on a Intel 2.53GHz Duo
core CPU laptop with 8GB RAM.
C. Battery-Aware Programming
We modiÔ¨Åed the Java sunflow benchmark with Eco
syntax. The rendering logic in sunflow resembles the code
snippet in Figure 6. Our benchmarking execution renders 9
images ( IMGS=9 ), and the resolution and depth are imple-
mented as Ô¨Årst-class mode cases with identical deÔ¨Ånitions as
in Figure 2.
We Ô¨Årst execute the unmodiÔ¨Åed Java program and use its
battery consumption as the baseline supply. This number is
used for setting the BUDGET constant in Figure 6. In our exper-
iment, BUDGET = 20970mWh. We execute the Eco program
with 90%, 70%, 50% of the BUDGET . It is worth pointing
out that the experiment process described here is only meant
for inducing ‚Äúthreshold behaviors‚Äù, e.g., the program running
with ‚Äújust enough‚Äù battery, or ‚Äúslightly inadequate‚Äù battery, or
‚ÄúsigniÔ¨Åcantly inadequate‚Äù battery. An Eco programmer does
not need to proÔ¨Åle in this manner (or worse, plugging 20970
into the source code). The more intuitive programming idioms
were described in Section V.
The time series of supply gauage (blue lines) and demand
gauge (red lines) for the sunflow executions with 90%, 70%,
50% of the BUDGET were shown in Figure 7, Figure 8, Fig-
ure 9, respectively. All data are normalized. All experiments
are started with the same battery level. At any given time, if
the demand curve is (signiÔ¨Åcantly) above the supply curve,
the program runs in a ‚ÄúdeÔ¨Åcit.‚Äù A mode change will happen
after the processing of the current task, in the hope that the
demand for the next task will go below the supply change.
As one can see, battery supply change is near linear. The
change in demand happens at discrete time, since workdone
andworkleft are not updated until an image is processed.
6http://xalan.apache.org/
7http://xmlgraphics.apache.org/batik/
8http://www.dacapobench.org/0102030405060708090100
1 101 201 301 401 501 601%
 
Time(second)  supply(5.6wh) demandFig. 10. batik : supply/demand (70% budget)
700080009000100001100012000
1 101 201 301 401 501 601Image height  
(pixel)  
Time(second)  
Fig. 11. batik : image height (70% budget)
0102030405060708090100
1 21 41 61 81 101 121 141 161%
 
Time(second)  supply(1.6wh)
demand
Fig. 12. montecarlo : supply/demand (80% budget)
050000100000150000200000250000300000
1 21 41 61 81 101 121 141 161Time(second)  data size  
Fig. 13. montecarlo : sample size (80% budget)
Therefore, each ‚Äúplateau‚Äù in the demand curve represents the
processing of one image. As high-resolution rendering takes
signiÔ¨Åcantly longer time, the ‚Äúwidth‚Äù of each ‚Äúplateau‚Äù is
indicative of the operational mode.
Sustainability‚Äîthe scenario where the supply consistently
meets the demand‚Äîis maintained in all three scenarios: ob-
serve the supply curve and the demand curve in all three
Ô¨Ågures follow similar patterns of decline. The following table
reports the statistics of our experiments:
PER supply set supply used #hi #mid #lo
0.9 188.6wh 186.0wh 5 4 0
0.7 147.0wh 142.1wh 1 7 1
0.5 104.8wh 103.3wh 1 2 6
Observe that in all cases, Eco runtime is capable of meeting
the budget ( i.e., the ‚Äúsupply used‚Äù is less than the ‚Äúsupply
set‚Äù). The #hi,#mid ,#lo columns in the table list the
number of images rendered with high/mid/low resolutions.
Predictably, more images are rendered with lower resolutions
as the supply is set lower.
Next, we designed a battery-aware variant of batik , pro-
cessing 27 SVG Ô¨Åles with the supply of 8050 mwh70%.
Similar to the fashion the sunflow experiment was con-
structed, we Ô¨Årst executed the unmodiÔ¨Åed Java program and
obtained the battery usage of 8050mwh, which we informally
call ‚Äúthe budget.‚Äù The battery-aware variant thus runs on 70%
of that budget. The adaptive behaviors are deÔ¨Åned by a mode
case value for target image height. Since the image resolution
is adjusted by ratio, this value is strongly correlated with thequality of rasterization, as a larger height means a larger width
and therefore higher resolution. The mode case is deÔ¨Åned by
height pixel asfhi: 12000; mid : 10000; lo: 8000g,
where 12000 is used for the original Java execution. As
Figure 10 suggests, Eco achieves the goal of sustainability
by matching supply and demand closely. Figure 11 shows the
adaptively selected resolutions based on the changes of supply
and demand.
Last, we modiÔ¨Åed montecarlo , where a mode case is
deÔ¨Åned to adjust the sample size. SpeciÔ¨Åcally, the value in each
case member is the difference between the ‚Äúperfect‚Äù sample
size (280,000) and the sample size being used for that mode.
The larger sample size, the higher quality the output will be.
We use a syntactic sugar to deÔ¨Åne this mode case (with a
large number of cases whose mode names are implicit), in
the same effect of deÔ¨Åning fm0: 0;:::mi:i;:::mn:
ngwhere  = 10;000. In other words, our benchmark
adjusts the sample size by the increment/decrement of . The
execution of the unmodiÔ¨Åed Java code (for Monte Carlo core
algorithm) consumes 2060mwh of battery (‚Äúthe budget‚Äù). The
Eco execution operates on of 80% of that budget, with results
shown in Figure 12 and Figure 13. As Figure 12 suggests, Eco
again matches supply and demand closely. Figure 13 shows
the change of sample size over time.
D. Temperature-Aware Programming
To demonstrate temperature-aware programming, we use
xalan to transform 17 XML Ô¨Åles with 8000 iterations. We
modify the original Java program as follows. First, we set
a Ô¨Åxed temperature threshold to 60C. This is expressed as
tsupply (60 temperature ). Second, in between every other
Ô¨Åle transformation, we allow the CPU to sleep at a Ô¨Åxed
interval. A mode case is used for this sleep interval, set with
two case members: when the mode is hi, the interval is set
at 4 milliseconds, whereas when the mode is lo, the interval
is set at 10 milliseconds.
Figure 14 demonstrates the temperature changes of xalan ,
both in the Java execution and the Eco execution. As a bench-
mark, xalan involves intensive CPU-bound computations.
Without any sustainability management, the Java execution
drives the temperature over 60Cwithin one minute (a rise
of about 15C). The Eco execution on the other hand suc-
cessfully maintains the CPU temeperature within the threshold.
Figure 15 may explain the fundamental difference between the
two executions, showing different levels of CPU utilization
(Y-axis, plotted with OS performance monitor). During the
Java execution, the CPU utilization is mostly 100%. The Eco
execution however regulates the CPU utilization at a much
lower adaptive level.
The Ô¨Ågures here also demonstrate the trade-off between
temperature regulation and performance. Without any sleep,
the Java execution is able to complete the transformation
within about half the time of the Eco execution (terminates
after around 301 seconds). This comes with no surprise: the
latter execution intentionally slows down itself frequently.
Figure 16 demonstrates the change of sleep intervals over time.455055606570
151101 151 201 251 301 351 401 451 501 551 601 651 ÃäC 
Time(second)  JAVA
ECOFig. 14. xalan : CPU temperature
0102030405060708090100
151101 151 201 251 301 351 401 451 501 551 601 651%
 
Time(second)  JAVA
ECO Fig. 15. xalan : CPU utilization
024681012
1 51 101 151 201 251 301 351 401 451 501 551 601 651millisecond  
Time(second)  Fig. 16. xalan : sleep interval
40455055606570
1 76 151 226 301 376 451 526 601 676 751 ÃäC 
Time(second)  JAVA
ECO
Fig. 17. jspider : temperature
0102030405060708090100
1 76 151 226 301 376 451 526 601 676 751%
 
Time(second)  JAVA
ECOFig. 18. jspider : CPU utilization
05001000150020002500
1 76 151 226 301 376 451 526 601 676 751Interval(millisecond)  
Time(second)  JAVA
ECO Fig. 19. jspider : sleep interval
We also constructed a temperature-aware execution of
jspider inEco. Similar to xalan , the temperature is also
set at the Ô¨Åxed threshold of 60C. We employ a similar
strategy for temperature control, by allowing the crawler to
sleep at Ô¨Åxed intervals. Unlike xalan where each XML
Ô¨Åle is processed in a relatively short period of time, each
step in crawling‚Äîinvolving requesting a URL, parsing the
webpage, and analyzing the links contained in the page‚Äî
takes signiÔ¨Åcantly longer. This allows us to design with longer
intervals of sleeps (but much less frequent than xalan ). The
interval is implemented as a mode case, with himapping to
0.5 second, mid to 1 second, and hito 2 seconds. Figure 17
shows the temperature results. Figure 18 shows the CPU
utilization, and Figure 19 shows the interval change. Typical
for a web crawler, there is no ‚Äúcompletion‚Äù time unless the
user stops the execution. Our demand is set (and reset) at
Ô¨Åxed time intervals. As a result, all time series shown here
forjspider can be viewed as the Ô¨Årst 800 seconds of an
(almost inÔ¨Ånitely running) execution.
E. Programming Efforts
The programming effort for Eco is mild, and the LOCs that
involve Eco-speciÔ¨Åc changes are relatively small:
LOCs sunflow jspider montecarlo xalan batik
original 30984 13986 3128 347801 325238
Eco changes 46 56 23 32 27
Despite some benchmarks have high LOCs in their Java
versions, the changes involved for sustainable programming
concentrate on a small number of Ô¨Åles, typically the entry
points of core algorithms, and the variables representing the
adjustable parameters. The majority of development time was
used in understanding existing benchmarks, and Ô¨Ånding appro-
priate procedures/algorithms to support adaptive sustainable
programming. Once the algorithm of interest is identiÔ¨Åed, the
programming effort itself for developing the benchmarks we
experimented with ‚Äî adding Eco-speciÔ¨Åc expressions into
programs, and debugging ‚Äî is small, usually in hours.
VII. R ELATED WORK
Sustainable computing is an emerging topic in computer sci-
ence. Within software engineering, support for sustainability
has appeared in requirements engineering [34], [29], [32] and
software architecture [18], [20]. Modeling computer systemswith supply and demand is mostly known in OS research.
Examples include resource management and scheduling for
grid environment [6], device energy management [40], utility
computing in clouds [7], energy distribution among users [27].
Recently, the supply/demand model is also used for perfor-
mance tuning [26]. Eco enriches the landscape of sustainable
computing by empowering programmers .
A number of programming models exist for developing
energy-aware software, such as Green [4], EnerJ [36], and
ET [10]. They do not offer Ô¨Åne-grained energy/temperature
budgeting to programmers, and do not focus on maintaining
sustainability through programmer supply/demand characteri-
zation. Beyond energy-aware computing, programming models
for self-adaptive systems ( e.g., [8]) share a high-level design
goal of Eco: promoting adaptiveness in the presence of
dynamic variations of software/system environments.
Broadly, application-level energy management and opti-
mization is an active area, with recent results diversely ranging
from program analysis and optimization ( e.g., [16], [5]), test-
ing and debugging ( e.g., [21], [2]), design patterns ( e.g., [35],
[24]), decision framework ( e.g., [25]), measurement and esti-
mation support ( e.g., [37], [17]), runtime support ( e.g., [33]),
and empirical studies ( e.g., [30], [31], [23]).
More broadly, there is a long history in VLSI, architec-
ture, and OS research to design and implement battery-aware
(e.g.[12]) or temperature-aware ( e.g.[38]) computer systems.
A fundamental challenge is the need to ‚Äúpredict the future,‚Äù
with solutions ranging from proÔ¨Åling and monitoring [11],
machine learning [9], to agent-based modeling [13]. Eco com-
plements existing systems by bringing programmer knowledge
into the design space.
VIII. C ONCLUSION
This paper describes Eco, a sustainable programming model
for developing Java-like applications. With novel abstractions
for supply and demand shaping, Eco brings programmers into
the loop of sustainability management and promotes energy-
aware programming and temperature-aware programming.
IX. A CKNOWLEDGMENTS
We thank the anonymous reviewers for their useful com-
ments, and Anthony Canino for his help improving the com-
piler and the benchmarks. This work is partially supported by
US NSF CCF-1054515.REFERENCES
[1] Advanced conÔ¨Åguration and power interface, http://www.acpi.info.
[2] Carat, http://carat.cs.berkeley.edu.
[3] Data centers look for lower-emission cooling, http://www.nytimes.com/
2011/06/20/business/global/20green.html.
[4] B AEK, W., AND CHILIMBI , T. M. Green: a framework for supporting
energy-conscious programming using controlled approximation. In
PLDI‚Äô10 (2010), pp. 198‚Äì209.
[5] B ARTENSTEIN , T., AND LIU, Y. D. Green streams for data-intensive
software. In ICSE‚Äô13 (May 2013).
[6] B UYYA , R., A BRAMSON , D., G IDDY , J., AND STOCKINGER , H. Eco-
nomic models for resource management and scheduling in grid comput-
ing. Concurrency and computation: practice and experience 14 , 13-15
(2002), 1507‚Äì1542.
[7] B UYYA , R., Y EO, C. S., AND VENUGOPAL , S. Market-oriented
cloud computing: Vision, hype, and reality for delivering it services as
computing utilities. In Proceedings of the 2008 10th IEEE International
Conference on High Performance Computing and Communications
(2008), HPCC ‚Äô08, pp. 5‚Äì13.
[8] C HENG , S.-W., AND GARLAN , D. Stitch: A language for architecture-
based self-adaptation. J. Syst. Softw. 85 , 12 (Dec. 2012), 2860‚Äì2875.
[9] C HUNG , E.-Y., B ENINI , L., AND DEMICHELI , G. Dynamic power
management using adaptive learning tree. In Proceedings of the 1999
IEEE/ACM international conference on Computer-aided design (1999),
ICCAD ‚Äô99, pp. 274‚Äì279.
[10] C OHEN , M., Z HU, H. S., E MGIN , S. E., AND LIU, Y. D. Energy types.
InOOPSLA ‚Äô12 (October 2012).
[11] C ONTRERAS , G., AND MARTONOSI , M. Power prediction for Intel
XScale processors using performance monitoring unit events. In Pro-
ceedings of the 2005 international symposium on Low power electronics
and design (2005), ISLPED ‚Äô05, pp. 221‚Äì226.
[12] F LINN , J., AND SATYANARAYANAN , M. Managing battery lifetime with
energy-aware adaptation. ACM Trans. Comput. Syst. 22 , 2 (May 2004),
137‚Äì179.
[13] G E, Y., Q IU, Q., AND WU, Q. A multi-agent framework for thermal
aware task migration in many-core systems. IEEE Trans. Very Large
Scale Integr. Syst. 20 , 10 (Oct. 2012), 1758‚Äì1771.
[14] G LOVER , J. D. D., AND SARMA , M. S. Power System Analysis and
Design , 3rd ed. Brooks/Cole Publishing Co., PaciÔ¨Åc Grove, CA, USA,
2001.
[15] G RAY, J. The transaction concept: virtues and limitations (invited paper).
InProceedings of the seventh international conference on Very Large
Data Bases - Volume 7 (1981), VLDB ‚Äô81, pp. 144‚Äì154.
[16] H AO, S., L I, D., H ALFOND , W. G. J., AND GOVINDAN , R. Estimating
mobile application energy consumption using program analysis. In ICSE
‚Äô13(2013), pp. 92‚Äì101.
[17] H INDLE , A., W ILSON , A., R ASMUSSEN , K., B ARLOW , E. J., C AMP -
BELL , J. C., AND ROMANSKY , S. Greenminer: A hardware based
mining software repositories software energy consumption framework.
InMSR 2014 (2014), pp. 12‚Äì21.
[18] K OZIOLEK , H. Sustainability evaluation of software architectures:
A systematic review. In Proceedings of the Joint ACM SIGSOFT
Conference ‚Äì QoSA and ACM SIGSOFT Symposium ‚Äì ISARCS on
Quality of Software Architectures ‚Äì QoSA and Architecting Critical
Systems ‚Äì ISARCS (2011), QoSA-ISARCS ‚Äô11, pp. 3‚Äì12.
[19] K ULKARNI , A., L IU, Y. D., AND SMITH , S. F. Task types for pervasive
atomicity. In OOPSLA‚Äô10 (October 2010).
[20] L AGO, P., J ANSEN , T., AND JANSEN , M. The service greenery-
integrating sustainability in service oriented software. In International
Workshop on Software Research and Climate Change (WSRCC), co-
located with ICSE (2010), vol. 2.[21] L I, D., J IN, Y., S AHIN , C., C LAUSE , J., AND HALFOND , W. G. J.
Integrated energy-directed test suite optimization. In ISSTA‚Äô14 (2014),
pp. 339‚Äì350.
[22] L ISKOV , B. Distributed programming in argus. Commun. ACM 31 , 3
(1988), 300‚Äì312.
[23] L IU, K., P INTO , G., AND LIU, Y. D. Data-oriented characterization of
application-level energy optimization. In FASE 2015 (Apr. 2015).
[24] L IU, Y. D. Energy-efÔ¨Åcient synchronization through program patterns.
InFirst International Workshop on Green and Sustainable Software,
(GREENS 2012) (2012), pp. 35‚Äì40.
[25] M ANOTAS , I., P OLLOCK , L., AND CLAUSE , J. Seeds: A software
engineer‚Äôs energy-optimization decision support framework. In ICSE‚Äô14
(2014), pp. 503‚Äì514.
[26] M ITCHELL , N., AND SWEENEY , P. F. On the Ô¨Çy capacity planning. In
OOPSLA ‚Äô13 (October 2013).
[27] N ARASIMHAN , S., M CINTYRE , D. R., W OLFF , F. G., Z HOU , Y.,
WEYER , D. J., AND BHUNIA , S. A supply-demand model based
scalable energy management system for improved energy utilization
efÔ¨Åciency. In International Conference on Green Computing (2010),
IEEE, pp. 97‚Äì105.
[28] N YSTROM , N., C LARKSON , M. R., AND MYERS , A. C. Polyglot: An
extensible compiler framework for java. In International Conference on
Compiler Construction (Apr. 2003), pp. 138‚Äì152.
[29] P ENZENSTADLER , B., AND FEMMER , H. A generic model for sustain-
ability with process- and product-speciÔ¨Åc instances. In Proceedings of
the 2013 Workshop on Green in/by Software Engineering (2013), GIBSE
‚Äô13, pp. 3‚Äì8.
[30] P INTO , G., C ASTOR , F., AND LIU, Y. D. Mining questions about
software energy consumption. In MSR‚Äô14 (2014), pp. 22‚Äì31.
[31] P INTO , G., C ASTOR , F., AND LIU, Y. D. Understanding energy
behaviors of thread management constructs. In OOPSLA‚Äô14 (2014).
[32] R ATURI , A., P ENZENSTADLER , B., T OMLINSON , B., AND RICHARD -
SON, D. Developing a sustainability non-functional requirements frame-
work. In GREENS 2014 (2014), pp. 1‚Äì8.
[33] R IBIC, H., AND LIU, Y. D. Energy-efÔ¨Åcient work-stealing language
runtimes. In ASPLOS (2014), pp. 513‚Äì528.
[34] R OHER , K., AND RICHARDSON , D. Sustainability requirement patterns.
InRequirements Patterns (RePa), 2013 IEEE Third International Work-
shop on (July 2013), pp. 8‚Äì11.
[35] S AHIN , C., C AYCI , F., G UTI¬¥ERREZ , I. L. M., C LAUSE , J., K IAMILEV ,
F. E., P OLLOCK , L. L., AND WINBLADH , K. Initial explorations on
design pattern energy usage. In First International Workshop on Green
and Sustainable Software, (GREENS 2012) (2012), pp. 55‚Äì61.
[36] S AMPSON , A., D IETL , W., F ORTUNA , E., G NANAPRAGASAM , D.,
CEZE, L., AND GROSSMAN , D. EnerJ: Approximate data types for
safe and general low-power computation. In PLDI‚Äô11 (June 2011).
[37] S EO, C., M ALEK , S., AND MEDVIDOVIC , N. An energy consumption
framework for distributed java-based systems. In ASE ‚Äô07 (2007),
pp. 421‚Äì424.
[38] S KADRON , K., S TAN, M. R., H UANG , W., V ELUSAMY , S., S ANKARA -
NARAYANAN , K., AND TARJAN , D. Temperature-aware microarchitec-
ture. In ISCA ‚Äô03 (2003), pp. 2‚Äì13.
[39] S ORBER , J., K OSTADINOV , A., G ARBER , M., B RENNAN , M., C OR-
NER, M. D., AND BERGER , E. D. Eon: a language and runtime system
for perpetual systems. In SenSys , pp. 161‚Äì174.
[40] Z ENG, H., E LLIS , C. S., L EBECK , A. R., AND VAHDAT , A. Ecosystem:
managing energy as a Ô¨Årst class operating system resource. In ASPLOS
(2002), pp. 123‚Äì132.
[41] Z HU, H. S., L IN, C., AND LIU, Y. D. A programming
model for sustainable software (technical report), available online at
https://github.com/pl-eco/ECO , 2015.