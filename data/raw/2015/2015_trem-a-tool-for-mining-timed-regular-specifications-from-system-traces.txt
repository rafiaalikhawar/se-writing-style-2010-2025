TREM: A Tool for Mining Timed Regular
Speciﬁcations from System Traces
Lukas Schmidt
Department of Electrical and
Computer Engineering
University of Waterloo
Waterloo, ON N2L 3G1, Canada
lfschmid@uwaterloo.caApurva Narayan
Department of Electrical and
Computer Engineering
University of Waterloo
Waterloo, ON N2L 3G1, Canada
apurva.narayan@uwaterloo.caSebastian Fischmeister
Department of Electrical and
Computer Engineering
University of Waterloo
Waterloo, ON N2L 3G1, Canada
sﬁschme@uwaterloo.ca
Abstract —Software speciﬁcations are useful for software vali-
dation, model checking, runtime veriﬁcation, debugging, monitor-
ing, etc. In context of safety-critical real-time systems, temporalproperties play an important role. However, temporal properties
are rarely present due to the complexity and evolutionary nature
of software systems.
We propose Timed Regular Expression Mining (TREM) a
hosted tool for speciﬁcation mining using timed regular ex-
pressions (TREs). It is designed for easy and robust mining of
dominant temporal properties. TREM uses an abstract structureof the property; the framework constructs a ﬁnite state machine
to serve as an acceptor . TREM is scalable, easy to access/use,
and platform independent speciﬁcation mining framework. The
tool is tested on industrial strength software system traces such
as the QNX real-time operating system using traces with morethan 1.5 Million entries. The tool demonstration video can be
accessed here: youtu.be/cSd_aj3_LH8
Index T erms—Speciﬁcation Mining, Timed Regular Expres-
sions, Real-time systems
I. I NTRODUCTION
Temporal behavior of programs is an extensively studied
topic [1], [2]. Recently, the idea of mining likely temporal
properties of programs from system traces has become pop-ular [1]. Many programs lack formal temporal speciﬁcations,and mined speciﬁcations are therefore valuable since they can
be used for a wide variety of activities in the software develop-ment life cycle (SDLC) [3]. These activities include softwaretesting [4], automated program veriﬁcation [5], anomaly de-tection [6], debugging [7], etc.
Critical and commonly occurring behavioral patterns are
typically provided to the mining frameworks, which then mine
system speciﬁcations of that form. The mining techniquesidentify a set of speciﬁcations that are satisﬁed by traces w.r.t.certain criteria. Further, mined speciﬁcations can assist auto-mated veriﬁcation techniques because they provide an easyand user-friendly way to describe a programs’ speciﬁcations.
II. R
ELA TED WORK
Speciﬁcation mining has gained signiﬁcant attention in
recent times. Different techniques have been developed formining speciﬁcations from templates expressed using regular
expressions, L TL [8], STL [9], and other custom formats.There are numerous temporal property mining tools [10],[11], [12], [13], [14], [15], [16]. As argued by Ammons et.
al. [10], automated veriﬁcation techniques are unlikely to bewidely adopted unless cheaper and easier ways of formulating
speciﬁcations are developed.
A vast majority of tools for mining of temporal properties
infer properties in the form of state machines. These tools
learn a single complex state machine instantly and extractsimpler properties from it. In [10] they learn a state machinewhich captures both temporal properties and data depen-dencies. These ﬁnd utility in identifying errors and reﬁningspeciﬁcations. These also ﬁnd use in automatic veriﬁcationtools to ﬁnd bugs in the program execution.
These approaches suffer from one main drawbacks. Mining
of a single state machine from system traces is a NP-hard
problem [17].
Another work based on the intuition that frequently occur-
ring behavior that matches temporal patterns are likely to be
true is the foundation of Peracotta [18], [12], [13].
Speciﬁcations refer to properties of systems, for example, a
speciﬁcation of a typical smart phone might be ’within 5 sec-onds of pushing the power button the screen should turn on’.Such speciﬁcations ﬁnd applications in various domains, forexample, anomaly detection in networks [19], speciﬁcation-based testing in software development, and formal veriﬁcationin hardware [20]. The work on timed regular expression (TRE)mining by Cutulenco et. al. [21] is the backbone of this tool.The work is similar to other temporal mining frameworks suchas MONTRE [22].
This paper presents TREM a hosted speciﬁcation mining
platform designed for easy and robust mining of temporalproperties. The automatic generation of properties is useful forﬁnding missing program speciﬁcations, debugging during thesoftware development life-cycle, exploration/understanding oflegacy or undocumented software, and anomaly detection.
Section III discusses the design and work-ﬂow of TREM.
Section IV provides an overview of the implied methodology
of TREM through an industrial strength case study. Finally,Section V concludes the paper by evaluating TREM.
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations901
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. III. W ORKFLOW AND DESIGN
A. Overview of the Speciﬁcation Mining Process Used
TREM mines speciﬁcations of systems by analyzing the
sequence of events emitted by the system. These sequences
of events are called Traces. Traces must take the form of anevent series with time stamps. The alphabet of a trace is theset of all events that the trace contains.
Deﬁnition 1 (Trace, Event, and Alphabet): An event is a
string. A trace is a sequence of events with a time stamp for
each event. The alphabet of a trace is the set of all events inthe trace.
For example, a trace of a smart phone may look like
the trace displayed in Table I. In this case, the alphabetisPower_Button, Graphics_Loaded, Screen_On.
The elements of the alphabet are referred to as events.
T ABLE I
SAMPLE TRACE
Time (seconds) Event
0 Power_Button
2 Graphics_Loaded3 Screen_On
Speciﬁcations are mined using behavioural pattern tem-
plates. TREM uses Timed Regular Expressions (TREs) [23]
to encode speciﬁcations and Timed Regular Expression Tem-
plate (TRET) to encode behavioural patterns. Both TREs andTRETs are deﬁned below.
Deﬁnition 2 (Timed Regular Expression): Timed regular
expressions (TREs) over an alphabet Σ(also referred to as Σ
expressions) are deﬁned using the following families of rules:
•afor every event a ∈Σand the special symbol /epsilon1are
expressions.
•Ifϕ,ϕ1andϕ2areΣ-expressions and Iis an integer
bound interval then /angbracketleftϕ/angbracketrightI,ϕ1.ϕ2,ϕ1|ϕ2,ϕ∗, andˆϕare
Σ-expressions.
Here.represents the concatenation operator, ˆis the negation
operator, |is the disjunction or OR operator, and∗denotes
the Kleene-∗. These operators only allow for speciﬁcations
on the order of occurrence of events without considering thetime at which these events occur. The /angbracketleftφ/angbracketright
Ioperator allows for
the creation of temporal properties; this operator restricts themetric length of the time-event sequences in [φ ]t ob ei nt h e
intervalI. It is important to note that we use TREs, as deﬁned
above, to provide speciﬁcations.
Deﬁnition 3 (Event V ariables): An event variable is an
atomic proposition in a TRET that can take any event valuefrom the trace alphabet Σ.
Deﬁnition 4 (TRE Template (TRET)): A TRE template is a
TRE in which all of the atomic propositions are either eventvariables or events.
We use the term event variable to denote a placeholder
for an event. For example, the TRE template <0.1>[x,y]
represents “0 is always followed by 1 within the time interval
[x,y]”, where 0 and 1 are event variables and where x≤y
are ﬁxed doubles used in the time interval. We use pto denotethe number of event variables present in a TRE template. In
the given example pis 2. Any expression within <and>has
to be followed by a time interval that is speciﬁed within [and
]. The values xandyare separated by ,(comma).
Deﬁnition 5 (Binding): LetΣbe an alphabet of events and
letVbe a ﬁnite set of event variables. Then, a binding is a
functionb:V→Σ
A TRE instance corresponds to a TRE template with an
identical structure. Applying a binding to the event variablesin a TRE template creates a TRE instance corresponding tothat binding. The binding is thus a map used to replace
event variables with events from the given alphabet. We mine
all occurrences of TRE instances generated by the bindingfunction on the alphabet of the input trace.
The mining framework TREM uses timed automaton for
mining properties. Timed automata [24] have been investigated
quite rigorously in the recent past. The main motivationfor using timed automata is their suitability for modelingtime dependent behavior, and the ability to monitor their
reachability [25]. Timed automata are equipped with clocks,
making them perfect for modelling and veriﬁcation of real-time systems’ behavior [24]. Classical models like ﬁniteautomata, Petri-nets, etc., are not suitable since they cannotexpress such explicit timing constraints naturally present inreal-life systems. Another important property of the timedautomata is that the reachability properties are decidable [24],even though the timed automata have an inﬁnite numberof conﬁgurations. The main idea behind this result is theconstruction of a region-automaton, which ﬁnitely abstracts thebehavior of timed automata in a way that checking reachabilityin a timed automaton reduces to checking reachability in a
ﬁnite automaton. More details on the implementation can be
found in [21].
The TRE instances generated by the binding contain every
permutation of events in the alphabet within the TRET. There
is thus a total of Σ
ppossible TRE instances. Generally, we are
interested in mining all of the valid TRE instances. However,these instances contain both interesting and frequently occur-ring patterns, as well as those that might have been present justa few times in the trace. We thus use a ranking component toreduce the mined set to contain only the dominant instances orspeciﬁcations. We consider properties that are both frequentlyoccurring and interesting as dominant properties. We use theconcepts of support and conﬁdence from [1][26] for ﬁndingdominant properties.
Deﬁnition 6 (Support): The support of a TRE instance πon
a tracetis the number of time points of trace twhich do not
falsifyπ.
Deﬁnition 7 (Conﬁdence): The conﬁdence of TRE instance
πon a trace tis the ratio of trace support to trace number of
total instances.
The ranking component we use is a combination of support
and conﬁdence. The effectiveness of selecting a meaningful
subset of speciﬁcations depends on picking a good set ofthresholds.
902
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. Since the total number of mined TRE instances is often very
large in real systems, we would ideally keep the conﬁdence
value at100%. However, the motivation to reduce this thresh-
old slightly is due to the presence of imperfect traces. Traces
can be imperfect as a result of dropped events or executionof faulty programs. In such cases, dominant properties maynot be perfectly satisﬁed in the collected traces. Reducing the
threshold will thus include dominant properties from imperfect
traces.
Fig. 1. TRE Mining workﬂow [21]
Figure 1 provides a high level overview of the technique
we use for mining temporal properties from system traces.
The binding function accepts a set of Ntraces and a TRE
template. We use execution traces collected during system runtime. The time-event traces are generated using instrumenta-tion already present in the system and may include networktrafﬁc logs, operating system logs, program instrumentationlogs, etc. The binding function accepts a set of Nlogs, where
N≥1. From these logs, the function extracts an alphabet Σ
of unique events. The TRE template is an abstraction of thedesired temporal property, a temporal relationship of interestfor the system. The TRE template uses a set V of event
variables, where the variables range from 0top. The binding
function binds the set Vto the alphabet of events Σto generate
a set of TRE instances.
The timed FSM evaluates the TRE instances on the same
set ofNtraces. The Σ
pTRE instances are encoded in the p
dimensional incidence matrix that is used by the timed FSMto keep track of state, clocks, and evaluation results. As thetimed automaton evaluates each TRE instance on the trace, itupdates the success and failure values in a matrix. When theautomaton is ﬁnished evaluating the TREs on all the traces, itpasses the results matrix to the ranker.
The ranker uses the results matrix generated by the timed
FSM to calculate the conﬁdence and support values for eachTRE instance. The rank criteria are the threshold valuesfor conﬁdence and support that are used to select only the
dominant TRE instances. The ranker uses these criteria to ﬁlter
out any of the instances with conﬁdence and support valuesbelow the speciﬁed thresholds. Thus, we are left with onlythe dominant instances, which are the dominant properties orspeciﬁcations for the system being analyzed.
Let us demonstrate the above work-ﬂow through an ex-
ample. Consider the TRE template (<1.0>[2,5])+, which isa simpliﬁed template for the response pattern. The ‘.’ is the
concatenation operator and the ‘+’ is the operator for one ormore instances of the expression. The template speciﬁes thatsome log event 1is followed by another log event 0within
2 to 5 time units, and this pattern occurs at least once in the
execution trace. The property contains two event variables 0
and1, meaning that the value of pis 2. The binding function
will bind the events in Σto the template and generate an
adjacency matrix for the TRE instances.
The timed ﬁnite state machine (FSM) iterates over the time
event pairs in a trace and at each new event evaluates therelevant TRE instances. Lets assume the matrix contains anentry where 0is bound to an event “send" and 1is bound to
an event “receive". The FSM reads in the event “send" in thetrace at time 0. According to the property, if the next eventin the trace is not “receive", the FSM will enter an error state
and will increase the failure count for this TRE instance to 1in the matrix. Similarly, if the next event is“receive", but the
time stamp is 6, the failure count would increase. If the nextevent is “receive" and the time stamp is 3, which is within the2 to 5 interval, then the automaton will enter a ﬁnal state andwill increase the success count for the TRE instance.
Once the entire trace has been processed, the ranker will
iterate over the matrix to calculate the conﬁdence and supportvalues for each TRE instance. The ranker will report only theproperties that meet the deﬁned thresholds for these metrics.
B. Interface Design Overview
TREM is a web application. The front end is responsible for
providing an interface to work with TREs, set up experiments,
view documentation, and display results.
The back end is responsible for speciﬁcation mining and
trace storage. This allows the front end to be light and delegatethe computationally intensive processes to the server (Figure2).
Fig. 2. Overview of interface
C. Frontend Design
The front end of TREM provides multiple ways to create
TRETs, select or upload traces, and display results (Figure 3).
To create a TRET we provide 3 options:
•Visual TRET creation using Blockly: We use Google’slibrary Blockly to create a visual interface to enterTRETs. There is a Blockly block equivalent for everyrule in the syntax required to write TRET’s. Therefore,
the Blockly interface has the full expressive power over
903
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. Fig. 3. Overview of front end interface
TRETs. Figure 4 shows a sample Blockly expression. It
is read from top to bottom, for example in Figure 4, the
equivalent TRET is <0.1>[0,3].
Fig. 4. Simple Blockly expression for a TRE
•Pre-deﬁned TRETs: There is also a list of commonlyused pre-deﬁned TRETs based on [2] with accompanyingdocumentation. Figure 5 shows a sample pre-deﬁnedTRET with its explanation.
Fig. 5. Pre-deﬁned TRET with its explanation
•Direct TRET Creation: Finally, there is also a ﬁeld whichallows the user to directly enter their own TRETs.Blockly TRET models may be converted to and from text
TRETs. This is encouraged to make the user comfortable with
the syntax of TRETs over time.
There are three ways to provide the traces for evaluation to
the tool as outlined below:
•Database Connection: The tool provides option to connect
any Postgres database. A list of traces are shown foreach database connected to TREM, any number of thesemay be selected. Each comes with the option to limit thelength of the traces.
•Custom Trace: A ﬁeld is provided into which a shortcustom trace may be written. A pattern is mined on allthe selected traces and the custom trace if present.
•CSV File: Traces can also be uploaded in a csv ﬁleformat.
The results are displayed in three different ways for ease of
visualization and understanding of the end user (Figure 6).
•Histogram: For immediate visual feedback, a histogram isgenerated that displays the event combinations resultingin the largest success values. The histogram displays theevent combination, success and reset values.
•Tables: There are 2 tables displayed per trace, the ﬁrst ta-ble is the equivalent of the histogram. It displays the eventcombination, success and reset values in the decreasingorder of successes. The second table displays all eventcombinations that have sufﬁcient support and conﬁdencevalues when compared to the respective threshold values.
•CSV ﬁle: Finally, a CSV ﬁle is generated with the entireset of results. The results take the form of matrices.The ﬁrst one contains the success values, the secondone contains the reset values, and a list of the eventcombinations that passed the support and conﬁdencethreshold.
D. Interface Backend Description
The back end is made up of a demo_database, connections
to external databases, and the interface with the TRE mining
framework.
During execution, the relevant traces are loaded, the TRET
is parsed, and the traces are then mined by the TRE mining
framework [21]. The results are processed and returned to thegraphical user interface.
IV . I
NDUSTRIAL CASE STUDY
A. Performance Evaluation using Real QNX Traces
The QNX real time operating system (RTOS) is used in
many safety critical systems, such as medical devices, nuclear
monitoring systems, vehicles, etc. The QNX RTOS has a very
advanced logging facility, tracelogger . Tracelogger facilitates
detailed tracing of the kernel and user process activity onany system. More speciﬁcally, it can log interrupt activity,various states of processes and threads, communication withinthe system, kernel calls, custom user events, and much more.The logged events give a detailed view into the behavior ofthe system, but due to the large quantity of the produced
904
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. Fig. 6. TRE mining results of QNX trace from hexacopter using the alternating TRET
information are often difﬁcult to make use of by developers
and system designers. These traces are thus a perfect resourcefor dynamic mining of system properties and speciﬁcations.
For the evaluation, we used a set of traces collected from an
operational hexacopter loaded with the QNX Neutrino 6.4 and
a user control process. The vehicle is a commercially avail-able gyro-stabilized Mikrokopter hexacopter equipped with 6
electric motors and a 6200 mAh lithium polymer battery. Thehexacopter can be seen in Figure 7. The trace length for ourexpriments have 1.6 million event entries.
Fig. 7. The hexacopter in ﬂight
The trace is uploaded into a database and then connected to
TREM via the ’Connect Database’ option. For evaluation weuse the pre-deﬁned TRET, the “alternating" pattern [2] as it isquite common in real-time embedded systems. The intuition
for using an alternating pattern arises from the fact that a vastmajority of tasks in real-time systems are periodic.
One can either select from our pop-up screen or customize
it as per the system under consideration either in text or
Blockly interface. For example, the time constraint for eachsystem would be unique and depend on the time units of
the system trace. In our case, we modify the time constraintfrom [0, 1000] to [0, 4000] since that is a desirable value forinter-event time lapse for QNX traces from hexacopter. The
histogram view of the results is presented in Figure 6. Theresults presented here are for support = 1 and conﬁdence =
0.9. These parameters can be changed to reﬁne the results forbetter understanding of the system under evaluation.B. Result Analysis
The properties mined by TREM under speciﬁed thresholds
for support and conﬁdence are analyzed for understanding the
system. The CSV ﬁle contains all the mined speciﬁcation thattake the form of the alternating pattern. Our goal is to identifydominant and interesting properties of the system. Therefore,
we sort the TRE instances that obey the thresholds of support
and conﬁdence based on their frequency of occurrence in thesystem trace.
In Figure 6, the mined properties from the hexacopter trace
are evaluated, each bar represents a unique instance of aTRE. In this case, the most dominant property is where, theplaceholder 0is associated with the event APS_NAME and the
placeholder 1is associated with APS_NEW_BUDGET. These
events are associated with QNX and ensure that there is suf-
ﬁcient memory available all the time for the application. The
event APS_NAME creates a new partition to ensure sufﬁcient
memory is available. The event APS_NEW_BUDGET is emitted
automatically when the adaptive partitioning scheduler clearsa critical budget as part of handling a bankruptcy situation.
The timing constraint ensure the timely response to a memory
request, which is extremely critical in real-time systems. Thisis just one of the dominant properties and is very importantas it ensures that in a safety critical real-time application suchas a hexacopter, there is always sufﬁcient memory available.
The signiﬁcance of such properties is better understood
in case of system failure. If the system prohibits memoryprovisioning for the application, it may lead to catastrophicconsequences. For example, in case of hexacopter, the auto-
pilot module tries to obtain direction information from gy-roscope to send a control signal to the elevation controller.
The inertial measurement unit (IMU) requires memory to storeand process this information in real-time. For a faulty system(the fault can be in IMU or memory management system), itis predicted that TREM results would reveal that either the
property described above is completely missing or has moreresets. This indicates that the system is trying to clear memory
but unable to do so. Not only does this allow us to monitoranomalous behavior of the system, but also helps in post-mortem analysis.
V. D
ISCUSSIONS AND CONCLUSIONS
A. Evaluation and Scalability
TREM’s server side is written in python using the micro-
web framework Flask [27]. TREM delegates all of the memory
905
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. and processor intensive tasks such as trace storage and mining
to the server.
TREM requires minimal resources on the client device.
This allows TREM to scale to handle large system traces.
We have tested the framework on industrial strength systemtraces from QNX, Controller Area Network (CAN) bus, andRobotics Operating System (ROS) messages of length more
than 2 million event entries.
The space and time complexity of our framework depends
on the complexity of the TRET. It is exponential w.r.t the
number of variables or placeholders in the TRET whereaslinear w.r.t to the length of the trace. Generally, most prop-erties in systems are simple with only 2 or 3 variables. Thedetailed derivation of the space and time requirements of ourframework has been presented in [21].
B. Conclusion
Since TREM is a web app, the client is platform indepen-
dent and lightweight. This allows it to be run on most modern
terminal devices with a web browser. TREM is containerized
through Docker, and can be deployed on most existing servers.
TREM allows for fast iteration of speciﬁcation mining
patterns or TRETs due to the following:
•Processor intensive tasks are done on the server
•Traces may be shortened quickly and easily to allow for
testing
•Short custom traces may be entered to quickly testdifferent variants of your TRETs
TREM provisions for mining of TRETs combined with thevisual interface and a visual summary of results. This enableslearning and rapid development of speciﬁcations for complexsoftware, embedded software, legacy systems, and evolutionof software systems.
R
EFERENCES
[1] Caroline Lemieux, Dennis Park, and Ivan Beschastnikh. General L TL
Speciﬁcation Mining. In Proceedings of the 2015 30th IEEE/ACM
International Conference on Automated Software Engineering (ASE),
ASE ’15, pages 81–92, Washington, DC, USA, 2015. IEEE Computer
Society.
[2] Matthew B Dwyer, George S Avrunin, and James C Corbett. Patterns
in Property Speciﬁcations for Finite-State V eriﬁcation. In Software
Engineering, 1999. Proceedings of the 1999 International Conference
on, pages 411–420, New Y ork, NY , USA, 1999. IEEE.
[3] Manuvir Das. F ormal Speciﬁcations on Industrial-Strength Code—
From Myth to Reality, pages 1–1. Springer Berlin Heidelberg, Berlin,Heidelberg, 2006.
[4] V alentin Dallmeier, Nikolai Knopp, Christoph Mallon, Sebastian Hack,
and Andreas Zeller. Generating test cases for speciﬁcation mining. In
Proceedings of the 19th international symposium on Software testing
and analysis, pages 85–96, New Y ork, NY , USA, 2010. ACM. 594101.
[5] Zachary Kincaid and Andreas Podelski. Automated Program V eri-
ﬁcation. In Language and Automata Theory and Applications: 9th
International Conference, LATA 2015, Nice, France, March 2-6, 2015,Proceedings, volume 8977, page 25, Nice, France, 2015. Springer.
[6] Mihai Christodorescu, Somesh Jha, and Christopher Kruegel. Mining
speciﬁcations of malicious behavior. In Proceedings of the 1st India
software engineering conference, pages 5–14, New Y ork, NY , USA,2008. ACM.
[7] Mark Gabel and Zhendong Su. Online inference and enforcement of
temporal properties. In Proceedings of the 32nd ACM/IEEE Interna-
tional Conference on Software Engineering-V olume 1, pages 15–24, NewY ork, NY , USA, 2010. ACM.[8] Marco Bonato, Giuseppe Di Guglielmo, Masahiro Fujita, Franco Fummi,
and Graziano Pravadelli. Dynamic property mining for embedded
software. In Proceedings of the eighth IEEE/ACM/IFIP international
conference on Hardware/software codesign and system synthesis , pages
187–196, New Y ork, NY , USA, 2012. ACM. 100104.
[9] Xiaoqing Jin, Alexandre Donzé, Jyotirmoy V Deshmukh, and Sanjit A
Seshia. Mining requirements from closed-loop control models. IEEE
Transactions on Computer-Aided Design of Integrated Circuits and
Systems, 34(11):1704–1717, 2015.
[10] Glenn Ammons, Rastislav Bodík, and James R Larus. Mining speciﬁ-
cations. ACM Sigplan Notices, 37(1):4–16, 2002.
[11] Dawson Engler, David Y u Chen, Seth Hallem, Andy Chou, and Ben-
jamin Chelf. Bugs as deviant behavior: A general approach to inferring
errors in systems code. SIGOPS Oper . Syst. Rev., 35:57–72, October
2001.
[12] Jinlin Y ang, David Evans, Deepali Bhardwaj, Thirumalesh Bhat, and
Manuvir Das. Perracotta: mining temporal API rules from imperfect
traces. In Proceedings of the 28th international conference on Software
engineering, pages 282–291, New Y ork, NY , USA, 2006. ACM. 592060.
[13] Jinlin Y ang and David Evans. Automatically inferring temporal proper-
ties for program evolution. In Software Reliability Engineering, 2004.
ISSRE 2004. 15th International Symposium on , pages 340–351, Saint-
Malo, Bretagne, France, 2004. IEEE.
[14] Fabrizio Pastore, Daniela Micucci, and Leonardo Mariani. Timed k-tail:
Automatic inference of timed automata. CoRR, abs/1705.08399, 2017.
[15] Tony Ohmann, Michael Herzberg, Sebastian Fiss, Armand Halbert, Marc
Palyart, Ivan Beschastnikh, and Y uriy Brun. Behavioral resource-awaremodel inference. In Proceedings of the 29th ACM/IEEE International
Conference on Automated Software Engineering, ASE ’14, pages 19–30,
New Y ork, NY , USA, 2014. ACM.
[16] Marc Brünink and David S. Rosenblum. Mining performance speciﬁ-
cations. In Proceedings of the 2016 24th ACM SIGSOFT International
Symposium on F oundations of Software Engineering, FSE 2016, pages
39–49, New Y ork, NY , USA, 2016. ACM.
[17] E Mark Gold. Complexity of automaton identiﬁcation from given data.
Information and control, 37(3):302–320, 1978.
[18] Jinlin Y ang and David Evans. Dynamically Inferring Temporal Prop-
erties. In Proceedings of the 5th ACM SIGPLAN-SIGSOFT Workshop
on Program Analysis for Software Tools and Engineering, P ASTE ’04,pages 23–28, New Y ork, NY , USA, 2004. ACM.
[19] R. Sekar, A. Gupta, J. Frullo, T. Shanbhag, A. Tiwari, H. Y ang, and
S. Zhou. Speciﬁcation-based anomaly detection: A new approach for
detecting
network intrusions. In Proceedings of the 9th ACM Conference
on Computer and Communications Security, CCS ’02, pages 265–274,
New Y ork, NY , USA, 2002. ACM.
[20] Zerksis D. Umrigar and Vijay Pitchumani. Formal veriﬁcation of a real-
time hardware design. In Proceedings of the 20th Design Automation
Conference, DAC ’83, pages 221–227, Piscataway, NJ, USA, 1983.
IEEE Press.
[21] Greta Cutulenco, Y ogi Joshi, Apurva Narayan, and Sebastian Fischmeis-
ter. Mining timed regular expressions from system traces. In Proceedings
of the 5th International Workshop on Software Mining, pages 3 – 10,
Singapore, 2016.
[22] Dogan Ulus. Montre: A tool for monitoring timed regular expressions.
arXiv preprint arXiv:1605.05963, 2016.
[23] Paul Caspi Eugene Asarin and Oded Maler. Timed regular expressions.
J. ACM , 49(2):172–206, March 2002.
[24] Rajeev Alur and David L Dill. A theory of timed automata. Theoretical
computer science, 126(2):183–235, 1994.
[25] Kim G. Larsen, Paul Pettersson, and Wang Yi. UPP AAL in a Nutshell,
1997.
[26] Tuan-Anh Doan, David Lo, Shahar Maoz, and Siau-Cheng Khoo. Lm:
A miner for scenario-based speciﬁcations. In Proceedings of the 32Nd
ACM/IEEE International Conference on Software Engineering - V olume
2, ICSE ’10, pages 319–320, New Y ork, NY , USA, 2010. ACM.
[27] Miguel Grinberg. Flask Web Development: Developing Web Applica-
tions with Python. O’Reilly Media, Inc., 1st edition, 2014.
906
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. 