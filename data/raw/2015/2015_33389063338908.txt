ConcolicTesting forModels ofState-BasedSystems
Reza Ahmadi
Queen’s University
Kingston, Ontario, Canada
ahmadi@cs.queensu.caJuergen Dingel
Queen’s University
Kingston, Ontario, Canada
dingel@cs.queensu.ca
ABSTRACT
Testingmodelsofmoderncyber-physicalsystemsisnotstraight-
forwardduetotimingconstraints,numerousifnotinfinitepossi-
ble behaviors, and complex communications between components.
Software testing tools and approaches that can generate test cases
to test these systems are therefore important. Many of the existing
automatic approaches support testing at the implementation level
only.Theexistingmodel-leveltestingtoolseithertreatthemodel
asablackbox(e.g.,randomtestingapproaches)orhavelimitations
whenitcomestogeneratingcomplextestsequences(e.g.,symbolic
execution). This paper presents a novel approach and tool support
forautomaticunittestingofmodelsofreal-timeembeddedsystems
by conducting concolictesting, a hybrid testing technique based
onconcreteandsymbolicexecution.Ourtechniqueconductsau-
tomatic concolic testing in two phases. In the first phase, model is
isolatedfromitsenvironment,istransformedtoatestablemodel
and is integrated with a test harness. In the second phase, the har-
ness tests the model concolically and reports the test execution
results. We describe an implementation of our approach in the
context of Papyrus-RT, an open source Model Driven Engineering
(MDE)toolbasedonthemodelinglanguageUML-RT,andreport
the results of applying our concolic testing approach to a set of
standardbenchmarkmodels to validate our approach.
CCS CONCEPTS
·Software and its engineering →Software testing and debug-
ging.
KEYWORDS
ConcolicTesting, Model-driven Engineering,StateMachine
ACMReference Format:
Reza Ahmadi and Juergen Dingel. 2019. Concolic Testing for Models of
State-Based Systems. In Proceedings of the 27th ACM Joint European Soft-
ware Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE ’19), August 26ś30, 2019, Tallinn, Estonia. ACM, New
York, NY, USA, 12pages.https://doi.org/10.1145/3338906.3338908
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ESEC/FSE ’19, August 26ś30,2019, Tallinn,Estonia
©2019 Associationfor Computing Machinery.
ACM ISBN 978-1-4503-5572-8/19/08...$15.00
https://doi.org/10.1145/3338906.33389081 INTRODUCTION
Modern Real-Time Embedded software (RTE) plays a fundamental
role in controlling many products and devices found in telecom-
municationsystems,automobiles,aircraftandmanyothercyber-
physical systems. In such complex systems, the behavior of the
system depends on real-time constraints as well as on complex
communications with the environment using various protocols.
Usingcode-centric-onlyapproachesfordevelopingcomplexRTE
systems is very challenging. MDEtechniques tackle this challenge
by raising the level of abstraction on which the developers con-
struct software. If a software model contains faults, these faults
willpropagateto anyrefinementofthatmodelorthecodethatis
generatedfromthemodel.Therefore,findingandresolvingfaults
atthemodelleveliscriticalfordevelopinghighqualitysoftware.
Although MDEprinciplesincludingabstraction,automation,and
analysis[ 55]canhelpdealwiththecomplexityofsoftware,models
ofmodernindustrialsystemsstilloftenarelargeandcanbecome
overwhelming. Thus testing of such models is challenging without
automatictoolsupport.
Symbolic execution [ 19,20] is able to automatically generate
test cases for a program that achieve high coverage of the pro-
gram executions. However, symbolic execution typically results in
pathexplosion[ 20]whenexecutinglargesystems.Thesituation
can be worse in analysing concurrent systems, where the state
spaceislarger.Thescalabilityissuehasbeenpartiallyaddressed,
e.g., by distributing the computations on a cloud [ 15,26] or by
conductingselectivesymbolicexecution[ 22].Buttherearesome
other issues, e.g., since symbolic execution is typically static, it
may not be precise in some situations, e.g., when there are state-
ments in the program that call library functions that are hard to
reasonabout(e.g. callsto operating systemlibraries)orwhen the
programincludes pointer manipulationsorpointer aliases[ 32].In
addition,symbolicallyexecutingprogramsormodelswithcomplex
constraints or data structures is challenging [ 19,60], e.g., symbolic
executionwillbestuckifitfacesnon-lineararithmeticpathcon-
straints [33]. Besides, symbolic execution typically constructs and
maintainsaSymbolicExecutionTree(SET)tokeeptrackofpath
constraints for executions, where for complex systems it is compu-
tationally intractableto precisely maintainand solve constraints
for test generationdueto numerous executionpaths[ 60].
Concolictesting,ontheotherhand,executesaprogrambothcon-
cretelyandsymbolically.Inthistechnique,aprogramisexecuted
on some random inputs and symbolic constraints are collected dur-
ing the course of that execution. Then, the collected constraints
are negated and solved again to execute alternative branches in
the program. This process is run in a loop until all branches are
executedorauser-specifiedcoveragecriterionismet.Thefactthat
symbolicconstraintsarecollectedduringaconcreteexecutionof
the program allows the generation of test inputs that will force
4
ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
theprogramalongtheexactsameexecution.Therefore,everyer-
rorcaughtbytakinganexecutionpathbytheconcolictestingis
guaranteedtobesound[ 33].Inaddition,aprogramthatincludes
function calls to external libraries will prevent the symbolic execu-
tionfromcollectingpathconstraints,sincetheprogramincludes
statements that involve constraints that are outside the scope of
thesymbolicexecutionengine.Concolictestingengines,suchas
DART[33],typicallysolvethisproblembyrandomlygenerating
inputsandrunningthefunctioncallstoreasonaboutthepredicates
andto collectconstraints[ 32,33].
MDEis becoming more prevalent, and software models tend to
becomelargeandcomplex.Forinstance,ModelsofRTEsystemsin
automotive and aerospace domains may encompass many interact-
ing state machines that communicate using various protocols with
complex action code on the transitions of the state machines. In
suchmodels,testingsomebranchesonastatemachinecanbevery
challenging since the execution of such branches may need a se-
quence of events where these events are highly constrained by the
inputparameters.Itbecomesmorechallengingwhentheexecution
of an eventis guarded by aconditionalwhere that conditionalde-
pends on previous event parameters. Observe that in complex RTE
systems, event parameters are often of complex data types (rather
thanprimitivetypes).Concolictestingcanbeaneffectivetechnique
fortestingthesesystems.However,asopposedtoconcolicprogram
testing, model-level concolic testing has not been addressed in the
literature. One may propose using the current code-centric con-
colictesting enginesfor testing thebehavior of modelsby testing
the code generated from the models. However, there are currently
concolic testing engines for only a few languages, so it may not be
possibletotestprogramsgenerated(inanarbitrarytargetlanguage)
frommodels.Inaddition,theinformationcollectedduringtesting
the programs is not easily traceable to the models. Therefore, more
work is needed to leverage concolic testing for software models, in
particularfor models ofreactive andreal-timesystems.
In this paper, we present a novel approach and prototype tool
for automatic concolic testing models of RTE systems. To this end,
we automatically generate a harness for a model to simulate its
environment.Theharnessisintegratedwithamodel-levelconcolic
enginetodynamicallygeneratetestinputsforthemodelandstimu-
lateitwiththegeneratedinputs.Wehavebuiltourconcolicengine
on UML-RT [ 52], a domain specific language, whose constructs
come from standard UML constructs [ 56]. UML-RT is a popular
industrialmodelinglanguagethatisusedformodelingindustrial
systemsandissupportedbyseveralopen-sourceandcommercial
tools(EclipsePapyrus-RT[ 14],EclipseeTrice[ 5],IBMRSA-RTE[ 3],
HCL RTist [ 7] and IBM RoseRT [ 6]). Our prototype implementa-
tionusestheopensource MDEtoolPapyrus-RT.Toevaluateour
approach,weuseanindustrialcasestudyprovidedbyoneofour
industrialpartnersaswellasasetofotheracademiccasestudies
ofdifferentsizesandcomplexities.
In the next section, we briefly introduce UML-RT with an ex-
ample model and an overview of the current state of the art in
theprogram-andmodel-levelconcolictesting.Then,weexplain
our approach. Next, the implementation of our concolic testing
approach is presented. We then briefly describe our prototype tool
alongwithan evaluation ofthe approach andthe tool.2 BACKGROUND
Developing Executable Models in UML-RT. Constructing com-
plex, often distributed real-time systems needs powerful, well-
defined modeling constructs, as well as strongtool support. These
constructs and tools can be used to design a well-defined architec-
tureforsuchcomplexsystems,whicheasesnotonlythedevelop-
ment of the initial system but also facilitates maintenance and evo-
lution [56]. UML for Real-Time (UML-RT) [ 56] is a domain-specific
languagededicatedformodelingreal-timesystems.UML-RTisa
UMLprofile(similarto,e.g.,MARTE[ 30]andSySML[ 31]).Since
UML-RT focuses on modeling real-time systems, it is, compared to
UML,asmall languagewithlight notation.
The main concepts of UML-RT are capsules,ports, andconnec-
tors[52]. A capsule is an independent active class with its own
controlflow.Capsulesownports,allowingthemtocommunicate
viamessagepassing.Statemachinesmodelthebehaviourofcap-
sules. A UML-RT state machine is an extension of a Mealy state
machine[ 46]augmentedwithextrafeatures,includingstateactions,
composite states, anddeep-history.
UML-RT code generators generate complete executable code for
the structural and behavioral aspects of a model. Since UML-RT
is both a specification and implementation language, the action
codewritteninthemodelisintegratedaspartofthecodegener-
atedfromamodel.Fig. 1presentssomebehavioralandstructural
aspects(state machine,sample action code,and capsules)of a Col-
lisionAvoidance(CA)system.Thissystempreventsormitigates
collisions by continuously monitoring the road ahead and parts of
the side-fronts of the vehicle. Whenever an obstacle is detected, it
notifiesthedriverbyaudibleorvisualalerts.Inaddition,thesystem
automatically brakes, vibrates or steers the wheels in the opposite
directionifitdetectsanimminentcollision.Basedonthefigure,the
CA_Controller capsulecommunicateswith four othercapsulesvia
theports lidar,panel,brake,andsteer(observetheactioncodeon
transitionsinFig. 1).Thefirstportreceivesthreatmeasurements
from four lidarcomponents. Lidar uses the laser to estimate the
distance between objects and the direction of the potential colli-
sionswithobjects.Thecontrollersendserrororwarningsignalsto
theuserpanelcomponentviatheport paneltoinformthedriver
usingaudibleandvisualalerts.Thecontrolleralsocommunicates
withthe brake and steeringwheel systems by sendingcommands
to the ports brakeandsteerto apply the brake, and to vibrate or
to steer the steering wheel based on the threats measured. This
samplemodelwillbeusedinthefollowingsectionstodemonstrate
our approach for model-level concolictesting.
ProgramSymbolicandConcolicExecution. The key idea be-
hindsymbolicexecutionistousesymbolicvaluesinsteadofcon-
cretedatavaluesforprograminputsandmaintainacollectionof
symbolic expressions over the symbolic values to represent the
programvariablesthroughouttheprogramexecution[ 20,43].Sym-
bolic execution maintains a path constraint Φ, which consists of
quantifier-freefirst-orderformulasoverthesymbolicexpressions,
and asymbolic state σ, which maps each program variable to a
symbolic expression. At execution time, initially Φistrueandσ
is an empty map. These two variables are updated throughout the
program execution. For instance, if at a location in the program
inputisreadusing v=input(),thenv/mapsto→sisaddedto σ,wheres
5Concolic TestingforModelsof State-BasedSystems ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
Figure 1:The structure oftheCA controllermodelandits environment:left.The statemachineofCA:right
isafreshsymbolicvalue.Theexpressionmeansafreshsymbolic
variableisallocatedforeachinputvariable.Duringexecution,at
every assignment statement v=e, symbolic execution updates
σby mapping vtoσ(e), whereσ(e)is the symbolic expression
obtainedbyevaluating einσ.Ataconditionalstatement if(e)then
S0elseS1,thepathconstraint Φisupdatedto Φ∧eandanewpath
constraint Φ′isconstructedandupdatedto Φ∧¬e.Atthispoint
of execution, if Φ∧eis satisfiable, then a new symbolic execution
branch is created and the execution proceeds from the thenbranch.
Similarly,if Φ∧¬eissatisfiable,anewbranchisconstructedand
the executionis continuedfrom the elsebranch.Observe that this
kind of execution gives rise to a tree of symbolic executions which
iscalledSymbolicExecutionTree(SET) .
Attheendoftheexecutionorwhenanerrorhappens,e.g.,atan
assertionviolationorprogramcrash, Φ(thecurrentpathconstraint
intheSET)issolvedusingaconstraintsolver,andtestinputsare
generated.Byexecutingtheprogramusingthegeneratedinputs,
theprogram follows thesamepath asthesymbolicexecution. For
more details aboutsymbolic execution,pleaserefer to [ 19,20,43].
Concolictestingexecutesaprogrambothconcretelyandsym-
bolically [ 16,33,58ś60]. In this technique, symbolic execution is
conducted dynamically, which means the program under test is
executedandduringthatexecution,symbolicexpressionsandpath
constraintsarecollected.Concolicexecutionmaintainstwomaps
of program variables: the symbolic state that maps the variables to
symbolicexpressionsandtheconcretestatethatmapsthevariables
toconcretevalues.Thistechniqueneedssomeinitialprograminput,
whichisgeneratedrandomlytoinitiatetheexecution.Attheend
ofeachexecution,aconstraintinthecollectedpathconstraintsis
negated(theconstrainttonegateiseitherselectedrandomly,sys-
tematicallyorbasedonsomeotherheuristics[ 58]),andtheprogram
is executed again using the newly generated inputs (by solving the
negated constraint) to steer the program along a new execution
path.Theconcolictestingconductsthistaskeithersystematically
untilallfeasibledistinctexecutionpathshavebeenvisitedorthe
testing budget runs out. Observe that in concolic testing, a SET
isnotgenerated,ratheralistofpathconstraintsisgeneratedand
updated throughout the whole execution and thus there is not the
issueofsavingandupdatingthe SET.
Program concolic testing has already proved its potential for
achievinghighcodecoverage[ 16,33ś35,60]forcatchingbugsinprograms that are otherwise very hard to catch using other ap-
proachesincludingstaticanalysistoolsandrandomtesting.One
examplesuccessfulapplicationofconcolictestingintheindustry
is SAGE [ 34] that has been used by Microsoft for catching many
vulnerabilitybugsinlargeprojectsincludingWindows7[ 34].How-
ever,concolictestingofmodelshasnotbeenstudiedbeforeeven
thoughMDEisbecomingmoreprevalentandmodelstendtobe-
come larger and more complex. For instance, the simple model
shown in Fig. 1specifies the behavior of a reactive system that
executes by frequent communications with its environment. These
types of models have action code on their transitions to conduct
various computations including to process incoming messages, up-
date attributes, and produce outgoing messages. These systems
execute only when they are in their appropriate environment (e.g.,
are connected todevices) thatsends them the required stimuli. To
test these systems during development, one needs to mock the
environment for the system, for instance through a test harness,
such that the harness sends a sequence of messages in a specific
orderwithappropriateinputparameters.Itischallengingandlabor
intensive to manually craft a test harness for each model (this task
includescreatingacapsuleasthetestharness,ports,andconnectors
as well as the behavior of the test harness). Therefore to automate
testing, one may need to generate the structure and behavior of
the test harness dedicated to each model under test. To archive
highcoverage,theharnessshouldintensivelytestthemodeland
monitor and report the test coverage information. In the following
sections we explain our approach for concolic testing such models.
3 APPROACH
Given a state machine under test and a test budget (can be the
allotted time for testing or the maximum number of consecutive
transitions to execute) as input, the objective of our approach is to
automatically test the state machine to exhibit as many executions
asthe testbudgetpermits,to increase the chance for findingbugs
in the state machine. In this section we start with a motivating
example and an overview of our approach before we elaborate
different steps of our technique for model-level concolic testing.
Throughoutthissection,wecallthestatemachineundertest the
model,wherethetest harness isresponsible for testingthis model.
6ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
3.1 Motivating Example
The simple model presented in Fig. 1has three bugs, two of which
canbedetectedifthelines8and16ontheactioncodeofthetransi-
tiont5(incoming transition to the state Mitigate) are executed. For
instance,toexecuteline8,thestatemachinemustreceivethefollow-
ingmessagesandparametersvaluesmustsatisfytheconstraintsin
parenthesis: lidarMsg(threat 0==1)to executethetransition Idle→
Warn,andlidarMsg(threat 1>1,computeDirection(cd 0)==true)toex-
ecute the transition Warn→Mitigateand execute the second
ifstatement. So, in this case, solving the path constraints (PCs)
(threat0==1∧threat1>1∧computeDirection(cd0)==true)allowsgen-
erating test inputs that will force the state machine to reach and
executeline8.Toexecutethecorresponding elsebranch(line10),
theconcolicenginenegatesthelastconstrainttoendupthePCs
(threat0==1∧threat1>1∧¬(computeDirection(cd0)==true)), so by
solvingitthe elsebranchisexecuted.Observethatthethird ifstate-
ment(line 14) executes if and only if hviEnabled has been enabled
in previous transitions, where this predicate gets enabled if the
transition t1executesatleastthreetimes,suchthatthepredicate
Warnings>=3 holds (Warnings is a global variable). Therefore, as
shown,theexecutionofabranchonatransitionisdependenton
the valuation of a global variable in a specific way. This system
shouldnotvibrateandsteerthewheelatthesametime[ 1,39].That
is, it vibrates the steering wheel if it detects a forward collision,
andsteersthecarintheoppositedirectionifitdetectsamerging
collision(thetypeofthecollisioniscomputedbyalibraryusing
thecdinputparameter).Astransition t5shows,iftheflag merging-
Colholds and vibrate is enabled (by a message from the user), this
requirementisviolated.Sothislastbugissubtleandcanbecaught
byanalyzingtheexecutiontracesonly,ashasbeenproposedin[ 8].
3.2 Approach Overview
In our approach, a test harness is responsible for constructing mes-
sages and parameters and sending them to the model to trigger
transitions on the model and hence execute the action code on the
model. A transition might be executed several times to exercise
all possible executions on the transition action code. To this end,
beforeconductingtesting,themodelistransformedbyaugment-
ingit bynew modelelementsto enabletheharness tocontrol the
executionofthemodelandtosteerthemodelalongitsdifferentex-
ecutions.Moreover,asmentioned,inconcolicexecution,themodel
isexecutedbothconcretely,executingthestatemachinethrough
thegeneratedinputparameters,andsymbolicallytocollectpath
constraints on values at symbolic variables constructed in terms of
inputparameters.Toenablethesesidebysideexecutions,during
themodeltransformations,weconductasetofinstrumentationson
the actioncode ofthe statemachine undertestbyaddingnew ac-
tioncodebesidetheexistingone,whichisresponsibleforcollecting
symbolic path constraints. Once the model is transformed, we gen-
eratetheharnessaswellastheextraelementsrequiredtointegrate
the harness and the model. Finally, we rely on the standard code
generatortogeneratecodefromboththeharnessandthemodel,as
wellasthegluecodeforintegratingthetwo.Thecodegenerated
is executed, so harness and the model execute concurrently. In the
following sections, we present all the steps mentioned above indetail. We first explain the steps of our model transformations and
the rationalebehindthem.
3.3 Model Transformations
Model-HarnessSynchronization. Theharnessandthemodelunder
test execute concurrently and asynchronously. The harness should
testamodelwithasequenceoftestinputsandaftertheprocessing
of each input the model should send an acknowledgment to the
harness.Tothisend,duringinstrumentation,newactioncodestate-
mentsareaddedtothestatessuchthatuponcompleteexecution
of each transition on the model, the model informs the harness, so
the harness can send the next test input. For instance, if a model
has transitions that are enabled by timers, the harness is not aware
of the exact timeout of a timer on the model, so sending messages
from the model to the harness upon execution of a transition helps
tosynchronizetheharnessandthemodel.Themessage newState
added on the instrumented model in Fig. 3informs the harness
about a newly visited state, so the harness can prepare and send
the nextappropriate messageto the modelundertest.
Path Constraint Collection. We instrument the action code on
the transitions by inserting extra commands on the action code
(Table1). The instrumented transition executes as the original one,
but also invokes the symbolic execution engine for collecting path
constraints(PCs).Theinstrumentationsshowninthelastrowof
Table1serveasanotherpurpose(thancollectingPCs)whichare
explained later. Given the fact that a transition may be guarded by
an expression (a transition is enabled iff it receives the required
messagetriggerandthetransitionguardexpressionholds)anda
statemachinemayinclude choicepoints (statesthathavemultiple
outgoingbrancheswherethedecisiononwhichbranchisexecuted
is based on the guard on that branch), before the instrumentations,
we first conduct the following small transformations on the model.
(1)Transformingchoicepoints :ifthetargetstateofatransition t
isachoicepoint,foreachguardexpressiononthechoicepoint’s
outgoingtransitionsweaddnewcorrespondingifstatementblocks
on the action code of t. Therefore, the corresponding path con-
straints are collected for each outgoing transition, so proper test
inputisgeneratedtocoveralltheoutgoingtransitions.Forinstance,
asshowninFig. 3,łThreat?ž isachoicepointwithtwooutgoing
transitions. The guards on these two outgoings give rise to two
newifstatements onthe transformedtransition t3.
(2)Transformingguards :asmentioned,anytransitionisinitially
executed by receiving random data, and hence the concolic engine
may not be able to execute guarded transitions initially (since it is
very likely that random data does not satisfy the guard predicates).
Therefore, such transitions need some transformations that by pre-
servingtheoriginalbehavior,enablethetooltoexecutethemby
some random data. To this end, if there is a transition t0:S0→S1
(as shown in Fig. 2), two new transitions t1andt2and a choice
pointcare created.The transition t1is theincoming transitionto
c, andt0andt2are its outgoing transitions. As shown in the figure,
t0now connects the choice point to the state S1. In addition, the
actioncodeof t1nowforcestheconcolicenginetocollecttwonew
constraintsthatcangiverisetogeneratinginputsthatsatisfythe
guardoft0andcausetheexecutionoftheactioncodeof t0.More
examples ofthis transformation are inFig. 3.
7Concolic TestingforModelsof State-BasedSystems ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
Figure2:TransformingGuards.Left:OriginalModel,Right:
Transformed One.
Table 1:Action codeInstrumentations
TransitionAction code Transition
Type BeforeInstru. AfterInstru.
//reading input
v←input();σ←σ+(v/mapsto→s);
v←input();others
//assignment
v←e;m0←v/mapsto→eval_sym(e,σ);
σ←σ+[m0];v←e;others
//conditional
if (e) thenS0;
elseS1;e←eval_sym(e,σ);
if (e) then{ Φ←Φ∧e;S0;}
else{Φ←Φ∧¬e;S1;}others
reset_vars();save_pcs();iteration
Action CodeFullCoverage. Traditionally thenotionofcoverage
in testing state machines includes transitions/states or predicate
coverage [ 48], so to test a state machine completely one should
generate as many as test cases as necessary to trigger all transi-
tions on the state machine or satisfy all guard expressions on all
transitions.Inourapproach,weconsiderexploringallthebranch
pointsonthetransitionactioncodeaswell,whichmeansweshould
notonlyconsiderexploringallthetransitions,butalsotheaction
codeonthosetransitions.Theactioncodeonatransitionmayhave
multiple branch points (e.g., due to if statements), and hence the
transition should be executed multiple timeswith different inputs
in order to exercise all possible executions. Since after each exe-
cution the state of the system changes (either by transiting to a
new state or by updating some global variables), the model should
be able to restore its original state after each execution. To this
end,duringthetransformations,themodelisaugmentedbynew
instructions such that after each execution, the test harness can
movethemodelundertestbacktoastartingpoint,suchthatthe
variable values are restored so the execution can be conducted on
the original global variable values. To this end, a transition from
each state to the initial state is created (to form a loop) and we
callthenewtransitionan iteration.Wecallthetransitionsinthis
loopatransitionset .Aniterationallowstheharnesstoexecutea
transitionsetmultipletimes.Forinstance,thetransitions iterate1
anditerate2in Fig.3represent two iterations. As shown in the last
rowoftheTable 1,thetwolinesofactioncodethatareexecuted
on an iteration are reset_vars()andsave_pcs(). The former one
restores the state machine’s variable values and the later one saves
the collected path constraints of a transition set into a file. The
harnesssendsnewinputstothemodelineachiteration,andthat
happensbyrestoringtheconstraintscollectedbythemodel,and
negatingandsolvingthemuponcompletionof the executionofa
transitionset.We willelaboratethis inthe following sections.
3.4 ConcolicTestingoftheState Machine
In ourapproach, atestharnessis generatedfor eachmodel under
testandisintegratedwiththemodelautomatically(Fig. 4).Based
Figure 3: A simplified version of the CA model shown in
Fig.1before (top) and after (bottom) the model transfor-
mations. Model elements dashed are the elements that are
newlyadded/updated duringthe transformations.
Figure 4:Integrating amodelwith atestharness
onthefigure,themodeloriginallycommunicateswithfourother
models through their ports (Fig. 4, on the left). The harness mocks
theexternalenvironmentforthemodel(Fig. 4,ontheright),sothe
modelcan be testedas aunitinisolation.
Oncethestatemachineisinstrumentedandisintegratedwith
a test harness, the state machine can be tested. In the remainder
ofthissectionweelaborateonhowthetestharnessconductsthe
concolictestingusing the example modelshowninFig. 3.
Fig.5presentsanabstractbehaviorofthetestharnessviaastate
machineandFig. 6presentssomeofthefunctionsandattributes
of the test harness. As shown in Fig. 5, the test harness starts by
readingatestconfigurationfile(tospecifytestbudget,suchastotal
iterations),andthenentersthestate MsgSending .Whenentering
this state, the harness calls the function SendMessage (shown in
Fig.6) to select the next transition for execution (the candidate
transition )andtosendamessagetoenablethattransition.Inthe
functionSendMessage ,selectTransition (line12)selectsthecandidate
transition from the outgoing transitions of the current state. Since
a transition set is executed iExectimes, the candidate transition
is selected based on the following rules: in an iteration i, where
i<=iExec, if none of the outgoing transitions has been executed
before, then selectTransition chooses one of them randomly, oth-
erwisethetransitionthathasbeenexecutedintheiteration i-1is
selected,where 1<=i-1<=iExec .Thisisbecausetheinputsgenerated
from path constraints collected during execution of a transition set
executethesametransitionset(sametransitionsandsameorder
of execution), but forces a different execution pathin transitions
8ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
actioncode.Ifatransitionsetisexecuted iExectimes,startingfrom
theinitialstate,theharnesspicksanoutgoingtransitionthathas
not been executed before or a random transition if all the outgoing
transitions have been executed iExectimes. Observe that if in a
statemachinethereisaself-transition st(atransitionwhosesource
and destination states are identical), stcan be selected tsLen(the
transitionsetlength)timessothenexttransitionsneverexecute.
Tohandlethis issue, the harnesstakes as inputa loopbound( tExec
inFig.6),so inan iteration,the harness does not select any tran-
sition more than tExectimes collectively. In line 13, the harness
readsinputseitherfromfileifalreadyexistsinputgeneratedbythe
symbolic execution engine, otherwise it generates random data for
a candidate transition. Then, the harness constructs a message and
sends itto the modelundertest (lines14-15).
Since the transitions on the model are instrumented (observe
Fig.3),uponreceptionofthemessagebythecandidatetransition,
theactioncodeonthetransitionisexecuted,whichleadstocollect-
ing(orupdating)pathconstraints,andthemodelsends newState to
the harness,which causes the harness to move to the state MsgRe-
ceived(Fig.5),wheretheharnesscallsitsfunction NextStep(shown
inFig.6).Thisfunctionfirstupdatesthecoverageinformation(line
2),anddecideswhether theharnessmustrestartthemodel under
testforcingittomovetoitsinitialstate,ortocontinueexecuting
the next transitions. This decisionis basedonwhether ornot tsLen
(transitionsetlength)numberoftransitionshavebeenalreadyexe-
cuted(lines3-9).Iftheharnessdecidestocontinue,thenitsetsa
timer (line 4) so once the timer times out (after some milliseconds)
the harness ends up in the state MsgSending , so it can prepare and
sendthenextmessage.Ifnot,theharnesssendsthemessage iterate
to the model, which causes the model to move to its initial state
and send a new newState message which causes the harness to
movetothechoicepoint łIterate?ž.Inthisstate,ifthetotalnumber
of executed iterations equals totalIter(Fig.6) or there is no more
branchestoexecute,thenthestatemachinemovestothestate End,
otherwise it moves back to the state MsgSending and the function
Negate_Solve isexecuted.Observethatifthetestingtimebudget
(execTime)runsout,theharnessalways automaticallyterminates.
We have not shownthat functionalityhere dueto spacelimits.
As shown in Fig. 3, after each iteration, the model stores the
SymbolicExecution(SE)objectintoafile(bycallingthefunction
save_sym). So, the function Negate_Solve in the harness restores
this SE (line 18) and based on the selected heuristic (either ran-
dom or systematic, which we will elaborate later in this section)
aconstraintintheSEisnegated(lines19-23).Notethatthepath
constraintscollectedforatransitionsetistheconjunctionofallthe
constraints collected for each transition, so the test harness always
maintains only one path constraint throughout the execution of
the whole model (as opposed to symbolic execution that maintains
a tree of path constraints for all paths in the system). The harness,
then,solvestheresultingnegatedconstraintsandwritestheinputs
generatedtoafile(lines24-25)soitcanlater(inthestate MsgSend-
ing) send themto the model.
Example. Assuming transition set length is 3, the sequence dia-
gram shown in Fig. 7presents the communication between the
harness, the instrumented model shown in Fig. 3and the sym-
bolicexecution engine.Based onFig. 3,thestate Idlehas only one
Figure 5:Asimplified statemachineofthe testharness
Input: astate machine sm, and a testconfigurationobject testConf with these
attributes: heuristic h, total iterations totalIter, execution time execTime, transition set
lengthtsLen, iterationexecutions iExec, and transition executions tExec.
Harness attributes :_Executed_Transitions ,_Sym_Ex_Obj .
Output: The branch, transition and state coverageresults.
1:procedure NextStep ()
2: updateCoverage();
3:if(_Executed_Transitions <testConf.tsLen)then
4: timer.set();
5: let_Executed_Transitions = _Executed_Transitions +1;
6:else
7: iterate.send();
8: let_Executed_Transitions =0;
9:endif
10:endprocedure
11:procedure SendMessage ()
12:letcandidate =selectTransition( sm.currState .outgoingTransitions);
13:letinputs=readInputs( candidate );
14:letmessage=getMsg(candidate, inputs);
15:message.send();
16:endprocedure
17:procedure Negate_Solve ()
18:let_Sym_Ex_Obj=readSymExObjFromFile();
19:if(h==0)then//random branch selection
20: negate_rand(_Sym_Ex_Obj);
21:else//systematic branch selection
22: negate_sys(_Sym_Ex_Obj);
23:endif
24:letinputs=solveSymExObj(_Sym_Ex_Obj);
25: writeInputsToFile(inputs);
26:endprocedure
Figure 6:The behavior ofthe testharness
outgoing transition t1, so the test harness sends the message li-
darMsg(1) (parameter is randomly generated), so t1is executed
and executing its action code gives rise to constructing the path
constraints ( threat0==1). Now, the model informs the harness
with anewState message, so the harness sends the next message
(againwithsomerandomparameters) lidarMsg(20) ,whichexecutes
t3as well as t5(since the t5guard holds) and the resulting PCs
will be (threat0==1∧threat1>1). Now the number of executed
transitions is 3, and hence the harness sends the message iterate,
whichresultsin restartingthemodel, negatingthelast part ofthe
constraints (resulting in PCs threat0==1∧threat1<=1), and
generating new inputs (e.g., threat0=1andthreat1=0), which
this time will execute the transitions t1andt3, andt4, respectively.
DFS vs. BFS Transition Execution. In our approach, we can test a
model by choosing a value for the parameter iteration length large
enough to execute all the transitionsstarting from theinitial state
all the way through to some final state (a state with no outgoing
transitions), so the execution and testing of transitions will be
basedontheDepthFirstSearch(DFS)traversal.Conversely,taking
9Concolic TestingforModelsof State-BasedSystems ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
Figure 7: Communication of the harness, the model under
test(MUT) andthesymbolicexecution engine
smallernumbersastheiterationlengthandincreasingthatnumber
iterativelycansimulatetheBreathFirstSearch(BFS)traversalfor
testingthe transitions.
HeuristicsforBranchSelection. Weimplementedtwodifferenttech-
niques for selecting the next branch for execution from the next
executablebranches:randomandsystematic.Assumingthenumber
ofconstraintscollectedthroughexecutingatransitionsetis n,then,
intheformercase,arandomnumber xisgeneratedsuchthat x<=n
toselectthe xthbranchforexecution.Inthiscase,itispossiblethat
abranchonanyofthetransitionsonthecurrenttransitionsetgets
executed. In the later case, the harness systematically executes the
branches on the transitions and in the order that the transitions
have been executed. For instance, if in a transition set the transi-
tionst1,t2,..tnareexecutedandtheconstraints tc1
1,tc2
1,tc1
2,...,tc1nare
collectedinitially,thenthenextpathconstraintsareconstructedby
negating the constraints in the same order. We note that executing
abranchonatransitionmaygiverisetocollectingnewconstraints
due to nested conditionals. Therefore, always constraints on the
sametransitionareselectedfornegationuntilallthebrancheson
thattransitionare executed.We refertothesetechniques Random
Concolic(RC) andSystematic Concolic(SC) ,respectively.
3.5 Behavior Preservation
The instrumentation in our approach preserves the original be-
haviorofthemodelandonlyenablescollectingpathconstraints,
similar to other tools [ 16,33,60]. Since collecting and solving com-
plex constraintstake some time,we needed to consider this factor
formodelswithtimerstopreventimpactonthebehaviorofsuch
models. To this end, as mentioned, in our approach, solving the
constraints is always carried out during the execution of an iter-
ationtransition,ratherthanateachstatewherethesolvingtime
may be long enough such that some timer on the next outgoing
transitions may fire before the constraint solver generates the data.
Usingthistechnique,wedidnotobserveanyimpact(introducedby
the overhead of constraint solving) on the timed systems based on
ourexperimentsonseveralcasestudymodels(thatwewillpresent
later).Asanotherobservation,solvingtheconstraintsisfairlyquick
(intheorderofmilliseconds),whichisconsiderablylessthanthe
timervaluesthatweobservedonthecasestudymodels.Hencethe
tool(evenwithoutthetechniqueabove)wouldnotinterferewith
the behaviorofthe models.
Figure 8:The overview ofour prototype tool
4 EXPERIMENTALEVALUATION
4.1 ToolImplementation
We have implemented a prototype tool called mCUTE(Model-level
ConcolicUnitTestingEngine)toconcolicallyexecutestate-based
models using the approach that we presented. We have conducted
severalexperimentsusingourtoolonanumberofindustrialand
academic models with different sizes and complexities. mCUTE
(whichisopensource)wasimplementedpartlyinJava(staticparts
relatedto,e.g.,modelprocessingandmodeltransformations)and
C++ (the core libraries for concolic testing). We have integrated
ourtoolinPapyrus-RT[ 14],whichisanEclipse-basedopensource
software modeling IDE with an active user community. Our tool
can be integrated to otherEclipse-based IDEs,including RSA-RTE
andRhapsody.Theschematicdesignofourprototypetoolisshown
inFig.8andvariouscomponentsofourdesignareexplainedbelow.
ModelTransformer implementsasetoflibrariesontopofEclipse
Modeling Framework (EMF) [ 61] to connect to a model and collect
information on model elements, such as transitions, states, and
action code. This information is collected statically and is stored in
some vectors before testing the model. This module then uses this
informationtoconfigurethetestharnessbytakingthestructure
of the model into account. This module is also responsible for
transforming the model and instrumenting its action code. The
transformation is done using EMF libraries, and the action code
instrumentationisconductedusing CIL [ 47].
Model-level Concolic Engine module contains a test harness (con-
figuredbythemodeltransformermodule)integratedwithoursym-
bolic execution engine (which was built by extending CREST [ 16]).
The harness implements algorithms for concolic testing, some li-
braries for measuring themodelcoverage (including states, transi-
tion,andactioncodecoverage)aswellasheuristicsfortransition
andbranchselections.Thismoduleinitializestheharnesswithuser-
provided test configurations, keeps track of the path constraints
collected, and feeds the harness with newly generated test cases.
Themodule storesthe coverageinformationforeachtransition in
anobject.Thecoverageinformationisupdatedaftereachiteration,
so the module chooses the candidate branches for negation for a
transition from its coverage object. Observe that to initiate testing,
wegeneratecodefromboththemodelundertestanditsharness
andwe executethe generatedcode. Thecodegenerated fromtest
harnesses varies slightly for each model, but a test harness was on
averagearound 3K linesof C++code.
10ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
Table 2:Our Case Study Models
ModelModel Complexity
Total#
TransitionsTotal#
StatesTotal#
Action codeTotal#
BranchesLOCof the
Generated
Code
AR 25 20 80 30 2.3K
FDM 55 55 144 34 6.2K
ACC 49 35 105 60 4.5K
CA 50 50 104 84 2.5K
PBX 291 284 1,715 196 11K
RSM 100 100 4,283 1,600 15.5K
4.2 The Benchmark Models
Our criteria for selecting the candidate case study models include:
(i)thecasestudiesshouldhavealargenumberoftransitions,action
code, and complex branches in their action code, (ii) the case stud-
iesshouldincludetransitionsthathavedependenciesoverglobal
variables.Thefirstcriterionaboveservestoevaluatethescalability
ofourtoolandapproach,sinceinthesecasestudies,thetoolmay
need to collect and solve large and complex path constraints. In
addition, the large number of branches may give rise to numer-
ousexecutions(whatinsymbolicexecutionmayleadtothepath
explosion problem). The second criterion evaluates our tool and
approachforitseffectivenessinexploringbrancheswhosepredi-
cate is highly dependent on previous constraints and consequently
the effectiveness of the approach in finding bugs that may only
be revealed if certain branches are executed. Below we will briefly
introduce our casestudiesfor this experiment.
CollisionAvoidance(CA) thatwasexplainedinprevioussections. Au-
tonomousRover(AR) [9]isasystemthatcontrolsavehicleequipped
withfourwheelsdrivenbytwoenginesandsensorstocollectin-
formation from the environment and to detect obstacles. Fabric
DyeingMachine(FDM) [10]isasystemtocontrolafabricdyeing
machine.ItwasdesignedinitiallyinROOM[ 57].Wemanuallycon-
verted it to a behaviorally equivalentsystem inUML-RT. Adaptive
Cruise Control (ACC) is a system that adjusts the vehicle speed and
distancetothatofatargetvehicleandwasoriginallydesignedin
AutoFOCUS[ 2,37].PBX(PrivateBrancheXchange) isasystemthat
models theinteraction of auserwith aprivatetelephonenetwork
used within an organization. Randomly Synthesized Model (RSM)
wealsochallengedourtoolonalargemodelgeneratedrandomly.
Themodelgeneratorgenerateswell-formedexecutablemodels,i.e.,
allthetransitionshaveatrigger,andallstatesarereachablefrom
the initial state. The tool generates well-formed executable pieces
of C code as action code (similar to the program generator tool
Csmith [44] that generates C code fragments for testing compilers)
withmultiplebranchpointsoverthetransitioninputparameters.It
took just more than 5 minutes for our model generator to generate
thismodel (afully instrumentedand transformedmodel, whichis
ready for testing), and around 2minutes for the codegenerator to
generatecodefromthemodel.Moreinformationaboutallofour
models can be foundinTable 2.
4.3 The Experiment Setup
Coverage Methodology. We used state, transition, and branch cover-
age as widely understoodanduncontroversialmetrics to evaluate
theeffectivenessofmCUTE.Thetoolmeasuresthecoverageduringtestingandfinallyreportsthecoverage.Regardingbranchcoverage,
weonlyconsiderfeasiblereachablebranches(i.e.,thebranchesthat
areindeedexecutable)andwedonotcountthenumberofbranches
in the library code. Even though mCUTE needs to successfully
executethe library code inorder to executethe modelitself.
DifferentTypes ofBugsonthe Models. Models of RTE systemsmay
define a tricky execution space that is built from many pointer op-
erations,includingcasting,andnumerousnestedconditionals.This
code must often process inputs received from other programs that
mayincludenetworkpacketsorsystemcallparameters,whichmay
cause run-time errors. We refer to these bugs as Model Crashing
Bugs. On the other hand, some bugs do not crash the system but
cause the system to generate wrong outputs, which are referred to
asOperation Bugs [25]. These types of bugs are detected by ana-
lyzing the model’s execution tracesonly. Prior work has proposed
propertymonitors tocatchthesebugs[ 8].Finally,mCUTEcancatch
codegenerator bugs, sincemCUTE runsthecodegeneratedfrom
the models. Some examples of these bugs caught by mCUTE are
describedinSection 4.4.
The Baseline for Comparison. We compare our approach for test-
ingstatemachineswiththetwotechniquespresentedin[ 8].The
first one ( Random Testing ) is a black box random test generation
technique for state machines, that generates a large volume of test
casesrandomlyandmerelybasedonthecombinationsofvarious
possiblemessagesthatastatemachinecanreceive.Thesecondone
(SimpleExploration) isawhiteboxtechnique,thatgeneratesthetest
cases by systematically exploring transitions of a state machine. In
thistechnique,startingfromtheinitialstate,outgoingtransitions
in each state are explored, and the trigger for each transition is col-
lectedandisaddedasatestinputtoavector.Theprocesscontinues
untilthetestcaselengthcriterionismet,orthecurrentstatehasno
more outgoing transitions.Bothofthese two techniquesgenerate
random data for input parameters bounded by user-defined ranges.
Theauthorshaveshownthattheactioncodecoverageusingthe
abovetwotechniquesisverylow.Inthatexperiment,thesetech-
niquesaregivenaconsiderableamountofresources(intermsof
thetestgenerationtimeandthenumberofgeneratedtestcases),
andyettheyfailtodiscoversomebugsintheactioncode.Themain
reasonisthatRandomTestingblindlygeneratestestsequencesand
both techniques generate random data for messages. Therefore,
actioncodethatisinnestedconditionalsorisontransitionsthat
need a long sequence of messages in a specific order to execute, as
wellastransitionsthatareguardedbycomplexpredicates,arechal-
lenging to execute. We will show how our approach using concolic
testingcanimprovethestatemachinetestcoverageconsiderably.
In the current experiment, we define a time frame as the testing
budget.Thatis,allthethreetechniques(ourconcolicengineaswell
as the other two techniques) are executed during the allotted time
budget and their performance is measured in terms of coverage
and thediscoveredbugs. Weperformedourexperiments using a
computer equippedwitha3.0 GHz CPUand8GB of RAM.
4.4 Results
4.4.1 Testing Coverage. Fig.9presents the performance of each
technique in branch coverage. Based on the graph on the left, af-
ter around 17 minutes, Systematic Concolic (SC) covers nearly all
11Concolic TestingforModelsof State-BasedSystems ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
Figure9:Left:BranchcoverageforRSMmodel,right:cover-
ageforothercasestudies.SC:SystematicConcolic,RC:Ran-
domConcolic,SE:SimpleExploration,RT:RandomTesting
thebranchesinRSM model (1,600branches).Besides,asthe num-
berof branches increasesto around 1,000, SC starts to outperform
Random Concolic(RC) considerably,eventhoughboth techniques
are concolic. The reason is that in RSM there are a large number
of transitions and branches, which gives rise to large transition
sets and consequently collecting a large set of constraints. Now, as
opposedtoSC,RCnegatesbranchesrandomly,andconsequently
many branches are executedmultipletimes. The plots alsoshow
thattheperformanceof RandomTesting(RT) andSimpleExploration
(SE)isconsiderably lower thanthe othertechniques,even though
the results of SE as a random technique is promising. The graph
ontherightshowstheresultsoftestingothersystemsexceptfor
RSM(performanceforthenon-RSMsystemswassimilarandaggre-
gatedbecauseofthepagelimit),whereinthis casethenumberof
branches are around 400, collectively. As the graph shows, SC and
RCshowalmostthesameperformance.Observethatinthiscase
thetechniquesdonotcollectlargenumberofconstraintsduring
theexecutionofindividualsystemsduetorelativelylessnumber
of branches (as opposed to the case for RSM, where hundreds of
constraints are collected during an execution from the initial state
to afinal state).
Therewasaninterestingobservationregardingthestatesand
transitionscoverage.TheSEandRTtechniqueswereabletoachieve
thesamecoverageastheconcolictesting,butonlyinsomemodels.
For instance, in some cases, they were not successful in generating
therequireddatatosatisfythetransitionsguards,andhencethe
generatedtestcasescouldonlyexecuteinitialstatesandtransitions.
That is, final states were not reachedinthesecases.
Note that, given the fact that a state machine may encompass
a large set of states, transitions and consequently action code, in
practice, it might be hard to cover all possible executions of the
state machine using concolic execution, due to numerous possible
executions,whichmightaffectthecompletenessofourapproach
or the approach may not be scalable to larger models. However,
the action code in state machines is usually relatively small, but,
asexplained,muchofthecomplexityofconcolictestingstatema-
chines lies in the dependencies between action code of different
transitions and therefore constructing path constraints that can
exhibittheirexecutions.
4.4.2 Bugs Found. We foundseveral bugsin our case studiesthat
are shown in Table 3(the message parameters with curly braces
represent non-primitive data, i.e., each value is a field in a structure
data type). Concolic testing (both SC and RC) could catch theseTable 3:BugsFoundby mCUTE
BugDescriptionSampleinputsto
reproduce the bug
bug#1:generated incorrect #define macros (FDM) setup({1,100}), status(10)
bug#2:indexout of bounds (FDM)create({2069,1204669}),
create({37742,737742})
bug#3:wrong output generated by state machine(CA)lidarMsg(1,0),
lidarMsg(949366,100)
bugs(afterfewminutes),SEcouldonlycatchthebug#2(whichdid
notneedcomplexinputmessagesanddata)afteraround10minutes.
RT could not catch any of these bugs. The bugs were confirmed by
running the test cases generated by mCUTE on a raw version of
the models (modelisneither instrumentednortransformed).
ModelCrashingBugs. We foundabugintheFDMsystem. This
systemconsistsofseveralconcurrentstatemachines,including Dye-
ingSystem thatdynamicallyinstantiatesnew dyeingunits ,where
each is dedicated to a dyeing task. The transition action code be-
lowisexecutedinaloopuntil totalTasks numberofdyeingunits
arecreated(thetransition’sguardchecksthis). DyeingUnits isan
array and its size is equal to totalTasks . The attribute idxis always
incremented, whetherthe method createDyeingUnit createsan ob-
ject or not (this method fails due to, e.g., type incompatibility or
ifthereisnotenoughroominthecapsuleforanewinstance[ 4]).
Consequently,eventhoughthe DyeinUnits arrayhasstillroom,the
systemcrasheswithan index outof bound errorat line7.
1 DyeingTask dyeingTask = ( ∗( DyeingTask ∗)) msg−>getParam (0);
2boolvalid = false;
3if( dyeingTask−>temprature >0 && dyeingTask −>runTime >0){
4void∗du = createDyeingUnit ( valid );
5 idx++;
6if( valid ){
7 DyeingUnits[ idx ] = du;
8 }
9 }
Operation Bugs. An example of this bug was explained in previous
sectionsintheCAsystem.Asexplained,theCAmustnotgenerate
avibratemessageand reversesteering messagesatthesametime
(sinceitmaydistractthedriver).AsshowninTable 3,mCUTEcould
generate inputs for the system such that an execution violated this
requirement. On this case the DFS strategy helped us to find the
bugquicker.Tothisend,wechoseaniterationlengthlargeenough
(7 in this case) such that mCUTE could always reach transition
t5and execute it (so no iteration before executing t5) and finally
mCUTEcould hit the bug.
Bugs in the Code Generator. If a state Shas some incoming tran-
sitions, each with some parameters, the code generator should
generate a macro using #definestatement for each parameter (as
shownbelow)suchthatallthetransitionsparametersarevisible
atthestate S.Inthe FDMcontroller,we detectedabug:thecode
generatorgeneratedonlyone definestatement(insteadoftwo)at
the state Setupthat has two incoming transitions, one to receive
other component’s status and one to initiate a dying task using the
parameter RunningData :
231voidCapsule_DyeingRunController ::
232 entryaction_____Setup ( constUMLRTMessage ∗msg ){
233 #define data ( ∗(constRunningData ∗) msg−>getParam (0))
234/∗ UMLRTGEN−USERREGION−BEGIN ∗/
12ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
235 cout << "temp: " << data . temprature −>value << endl ;
The harness triggers both incoming transitions to the state Run-
ning(in two iterations), once by sending a status (an integervalue)
to trigger the first transition and once by sending a dying task
information (an instance of the struct RunningData ) to trigger the
secondone.Inbothcases,theinputparameterswerecasttointeger,
whichinthe latercasecausedarun-time errorat line235.
5 RELATED WORKAND DISCUSSION
Program ConcolicTesting Approaches .Mostof the work inthe
literature address the development of concolic testing for pro-
grams [11,12,16,24,29,32ś35,44,58ś60,66]. Program concolic
testing was originally implemented in DART [ 33] to automate con-
colic testing C programs with high coverage. Later CUTE [ 60] was
introduced to support pointers as input parameters. CREST [ 16]
was later developed with a set of heuristics to improve path cover-
age. There are also multiple research works on generating optimal
searchheuristicsforagivenprogram[ 21].EXE[18]andKLEE[ 17]
implemented the Execution-Generated Testing (EGT) [ 20] tech-
nique, which again mixes concrete and symbolic execution, but in
a slightly different manner. The tool pre-processes the program
tocheckwhethertherearefunctionswithconstantinputs,sothe
tool runs thosefunctionsconcretely. This avoids unnecessary over-
headsthatcouldotherwisebeintroducedbythesymbolicexecu-
tion [17,20]. Other program concolic tools include Pex [ 63], where
thetesterwritesparametrizedunittests(PUT)[ 64],andPexgener-
atestestinputsforallfeasiblepathsinthePUT.Then,theinputs
are used to instantiate the PUTs in order to gain a set of unit tests
that exhaustively test the program. In [ 44], the authors introduce a
hybrid concolic testingtechnique that benefitsfromboth random
andconcolictesting,whererandomtestingisusedtoquicklyput
the system under test into particular states, which are otherwise
expensivetoperformusingconcolictesting(duetomassivenumber
of execution paths). When random testing saturates, the algorithm
automatically switches back to concolic testing to perform exhaus-
tive searching to find anewcoveragepoint.
ConcolicTestingofModels .Theresultsofapplyingthetoolsmen-
tioned above are promising in terms of increasing branch coverage
and the chance of finding bugs in programs. However, the tech-
niques and tools above are not enough to conduct testing on state
machines that compared with programs have a different execution
semanticsandmodel,anddifferentstructure.Concolicallytesting
the code generated from the models might seem like an option.
However, for model-level testing and tracing the executions to
modelelements,theactualmodelisrequired.Moreover,tothebest
ourknowledge,notoolforconcolicexecutionofC++(thelanguage
of the generated code) exists. Our approach leverages model in-
formation such that only the action code on transitions, which
we assume to be in C, needs to be executed concolically. There
aresometechniquesandtoolsfortestingandanalysingstatema-
chinesthatuseeitherin-house[ 27,53,67]oroff-the-shelfsymbolic
execution engines (such as Klee) [ 13,40]. However, observe that,
withsymbolicexecution,itisdifficulttodealwith,e.g.,heap-based
data,pointers,callstolibraryfunctions,andtimers(inourconcolic
approach, the engine has access to runtime information such as
timer status). Polyglot [ 13], for instance, translates the structureandbehaviorofthestatemachines(modeledindifferentsemantics)
intoJavaandteststhemusingJavaPathfinder[ 36,65].Theauthors
in[51]proposeasemi-automaticapproach(sinceitrequiresaman-
ual user annotation) for symbolic execution of concurrent process.
However, concolic execution and testing models to generate test
casesdynamicallyandautomaticallyhasnotbeenstudiedbefore,
and we think our technique and tool is the first of this kind. For
instance, the technique proposed in [ 38] extracts event handlers
fromaJavaapplication,takesasinputatargetlineforexecutionin
aneventhandler,andgeneratesasetofinputmessagesanddatato
reach thattarget. Thistechnique isnotautomatic sinceone needs
tospecifyastatemachinethatrepresentstheimplementations.The
tool presented in [ 23] also extracts a state machine from programs,
butforguidingtheconcolicexecutiontogainbettercoverage.Simi-
larly,thetechniquepresentedin[ 45]extractsastatemachinefrom
awebapplicationandtestcasesarederivedfromthestatemachine,
butdoesnotusesymbolicorconcolicexecution.Thetechniquepre-
sentedin[ 28],proposesanalyzingdependenciesbetweentransition
guards, input parameters, and global variables to assign weights
to each transition, such that transitions with greater weights have
higherpriorityforexecution,sothetechniqueseemstoimprove
coverageforstatemachineswithhighdependencybetweentran-
sitions only. The work in [ 54] presents a technique for concolic
testing Simulink (which is mostly used in automatic control and
digital signal processing domain than for modeling real-time appli-
cations)models.Inboththerecentlymentionedtechniques[ 28,54],
theauthorsdidnotconsideractioncodeontransitionsandthecom-
plex data structures used as input parameters between interacting
components.Modelsofreal-timeembeddedsystemmayhaveafair
amountofactioncodetocontrolthebehaviorofamodelandoften
include complex data structures for messageexchanges.
OtherTechniques .There are test generation techniques for state
machines [ 25,41,42,49,50,62] that work basedondifferent cover-
agecriteria.Comparedtoours,thesetechniquesdonotusesymbolic
executionanddonotconsidertheactioncodeonthestatemachine,
whichcan be the sourceof bugsinthe system.
6 CONCLUSION AND FUTUREWORK
In this paper, we have described and implemented an approach for
concolic testing of state machines. We demonstrated our approach
andtoolforexhaustivetestingbyconductinganempiricalevalu-
ation on a set of UML-RT models. Based on our results, concolic
testing could increase the branch coverage and could find more
bugs compared to other techniques including random testing. Our
approachhassomelimitations.Forinstance,inthecurrentimple-
mentation, we only support systematic testing of the transitions
leaving a state, which means we execute all the outgoing transi-
tionsofastateinorder.Moreover,we use randomanddepth-first
techniques for action code branch negation and execution. Using a
diversesetofheuristicsfortransitionandbranchselectionmight
helptogainbettercoverageinmodelstesting.Forinstance,thecon-
colic engine might be able to rely, e.g., on the structure of the state
machineorthedependencies betweenthemodelelements[ 10] to
prioritizethetransitionsandthebranchpointsandchoosetheones
with the highest priority. We intend to address these features in
future work.
13Concolic TestingforModelsof State-BasedSystems ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
REFERENCES
[1]Model-based systems engineering design of an automobile collision avoid-
ance system. https://www.isr.umd.edu/~austin/enes489p/projects2011a/
CollisionAvoidance-FinalReport.pdf , 2011. Accessed:2018-01-06.
[2] Autofocus. https://af3.fortiss.org/en/ , 2016. Accessed:2017-12-15.
[3]Rational Software Architect Realtime Edition. http://www-01.ibm.com/support/
docview.wss?uid=swg24034299 , 2016. Accessed:2016-8-10.
[4]Modeling real-time applications in rsarte. https://www.ibm.com/
developerworks/community/blogs/a8b06f94-c701-42e5-a15f-e86cf8a8f62e/
resource/Documents/RSARTEConcepts.pdf , 2017. Accessed:2018-03-06.
[5] eTrice. https://www.eclipse.org/etrice/ , 2018. Accessed:2019-01-10.
[6]RoseRT.https://www.ibm.com/support/knowledgecenter/en/SSSHUF_8.0.1/com.
ibm.rational.testrt.studio.doc/topics/troseworking.htm ,2018. Accessed:2019-01-
10.
[7]RTist.https://www.hcltech.com/products-and-platforms/rtist ,2018. Accessed:
2019-01-10.
[8]RezaAhmadi,NicolasHili,andJuergenDingel. Property-awareunittestingof
UML-RT models in the context of MDE. In European Conference on Modelling
Foundationsand Applications , pages147ś163. Springer, 2018.
[9]RezaAhmadi,Nicolas Hili,LeoJweda,Nondini Das,SuchitaGanesan,andJuer-
gen Dingel. Run-time monitoring of a rover: MDE research with open source
softwareandlow-costhardware. In OpenSourceforModel-DrivenEngineering
(OSS4MDE’16) , 2016.
[10]Reza Ahmadi, Ernesto Posse, and Juergen Dingel. Slicing UML-based Models
of Real-time Embedded Systems. In International Conference on Model Driven
Engineering Languages and Systems(MODELS’18) , 2018.
[11]SaswatAnand,MayurNaik,MaryJeanHarrold,andHongseokYang. Automated
concolic testing of smartphone apps. In Proceedings of the ACM SIGSOFT 20th
International Symposium on the Foundations of Software Engineering , page 59.
ACM,2012.
[12]ShayArtzi,AdamKiezun,JulianDolby,FrankTip,DanielDig,AmitParadkar,and
MichaelDErnst. Findingbugsinwebapplicationsusingdynamictestgeneration
and explicit-state model checking. IEEE Transactions on Software Engineering ,
36(4):474ś494,2010.
[13]Daniel Balasubramanian, Corina S Pasareanu, Michael W Whalen, Gábor Karsai,
and Michael Lowry. Polyglot: modeling and analysis for multiple statechart
formalisms. In Proceedings of the 2011 International Symposium on Software
Testingand Analysis , pages45ś55. ACM,2011.
[14]FrancisBordeleauandEdgardFiallos. Model-basedengineering:Anewerabased
onPapyrusand open source tooling. In OSS4MDE@ MoDELS , pages2ś8, 2014.
[15]StefanBucur,VladUreche,CristianZamfir,andGeorgeCandea. Parallelsymbolic
executionforautomatedreal-worldsoftwaretesting. In Proceedingsofthesixth
Conference onComputer Systems , pages183ś198. ACM,2011.
[16]Jacob Burnim and Koushik Sen. Heuristics for scalable dynamic test generation.
In23rdIEEE/ACMInternationalConferenceonAutomatedSoftwareEngineering,
2008. ASE 2008. , pages443ś446. IEEE,2008.
[17]Cristian Cadar, Daniel Dunbar, Dawson R Engler, et al. Klee: Unassisted and
automaticgenerationof high-coverage tests for complex systems programs. In
OSDI, volume8,pages209ś224, 2008.
[18]CristianCadar,VijayGanesh,PeterMPawlowski,DavidLDill,andDawsonR
Engler. Exe: automatically generating inputs of death. ACM Transactions on
Informationand SystemSecurity(TISSEC) , 12(2):10, 2008.
[19]CristianCadar,PatriceGodefroid,SarfrazKhurshid,CorinaSPasareanu,Koushik
Sen, Nikolai Tillmann, and Willem Visser. Symbolic execution for software
testing in practice: preliminary assessment. In Software Engineering (ICSE), 2011
33rdInternationalConference on , pages1066ś1071.IEEE,2011.
[20]Cristian Cadar and Koushik Sen. Symbolic execution for software testing: three
decades later. Communications ofthe ACM , 56(2):82ś90,2013.
[21]Sooyoung Cha, Seongjoon Hong, Junhee Lee, and Hakjoo Oh. Automatically
generating search heuristics for concolic testing. In Proceedings of the 40th
InternationalConferenceonSoftwareEngineering,ICSE,Gothenburg,Sweden ,2018.
[22]VitalyChipounov,VladGeorgescu,CristianZamfir,andGeorgeCandea.Selective
symbolicexecution. In Proceedingsofthe5thWorkshoponHotTopicsinSystem
Dependability (HotDep) , number CONF, 2009.
[23]Chia Yuan Cho, Domagoj Babic, Pongsin Poosankam, Kevin Zhijie Chen, Ed-
ward XueJun Wu, and DawnSong. MACE: Model-inference-assisted concolic
exploration for protocol and vulnerability discovery. In USENIX Security Sympo-
sium, volume139, 2011.
[24]ShauvikRoyChoudhary,AlessandraGorla,andAlessandroOrso. Automatedtest
input generation for android: Are we there yet? arXiv preprint arXiv:1503.07217 ,
2015.
[25]Tsun S. Chow. Testing Software Design Modeled by Finite-State Machines. IEEE
Transactions onSoftwareEngineering , (3):178ś187,1978.
[26]Liviu Ciortea, Cristian Zamfir, Stefan Bucur, Vitaly Chipounov, and George
Candea. Cloud9: A software testing service. ACM SIGOPS Operating Systems
Review, 43(4):5ś10, 2010.[27]DuncanClarke,ThierryJéron,VladRusu,andElenaZinovieva. STG:Asymbolic
testgenerationtool. In TACAS, volume2280,pages470ś475. Springer, 2002.
[28]Giuseppe Di Guglielmo, Masahiro Fujita, Franco Fummi, Graziano Pravadelli,
and Stefano Soffia. Efsm-based model-driven approach to concolic testing of
system-leveldesign. In 9thIEEE/ACMInternationalConferenceonFormalMethods
and Modelsfor Codesign(MEMOCODE), 2011 , pages201ś209. IEEE,2011.
[29]AzadehFarzan,AndreasHolzer,NiloofarRazavi,andHelmutVeith. Con2colic
testing. In Proceedingsofthe20139thJointMeetingonFoundationsofSoftware
Engineering , pages37ś47. ACM,2013.
[30]Madeleine Faugere, Thimothee Bourbeau, Robert De Simone, and Sebastien
Gerard. Marte:Alsoanumlprofileformodelingaadlapplications. In Engineering
Complex Computer Systems, 2007.12thIEEE International Conference on , pages
359ś364. IEEE,2007.
[31]SanfordFriedenthal,AlanMoore,andRickSteiner. ApracticalguidetoSysML:
the systemsmodelinglanguage . Morgan Kaufmann,2014.
[32]Patrice Godefroid. Compositional dynamic test generation. In ACM Sigplan
Notices, volume42,pages47ś54. ACM,2007.
[33]Patrice Godefroid, Nils Klarlund, and Koushik Sen. Dart: directed automated
random testing. In ACM SigplanNotices ,volume 40,pages 213ś223. ACM, 2005.
[34]PatriceGodefroid,MichaelYLevin,andDavidMolnar. Sage:whiteboxfuzzing
for securitytesting. Queue, 10(1):20, 2012.
[35]Patrice Godefroid, Michael Y Levin, David A Molnar, et al. Automated whitebox
fuzz testing. In NDSS, volume8,pages151ś166, 2008.
[36]Klaus Havelund and Thomas Pressburger. Model checking java programs using
javapathfinder. InternationalJournalonSoftwareToolsforTechnologyTransfer ,
2(4):366ś381, 2000.
[37]FlorianHölzlandMartinFeilkas. 13AutoFocus3-AScientificToolPrototypefor
Model-Based Development of Component-Based, Reactive, Distributed Systems.
InDagstuhlWorkshoponModel-BasedEngineeringofEmbeddedReal-TimeSystems ,
pages317ś322. Springer, 2007.
[38]CasperSJensen,MukulRPrasad,andAndersMùller. Automatedtestingwith
targeted event sequence generation. In Proceedings of the 2013 International
SymposiumonSoftwareTestingand Analysis , pages67ś77. ACM,2013.
[39]Alma L JuarezDominguez. Detectionoffeature interactionsin automotiveactive
safety features . PhD thesis, Universityof Waterloo, 2012.
[40]Amal Khalil and Juergen Dingel. Incremental symbolic execution of evolving
statemachines. In ModelDrivenEngineeringLanguagesandSystems(MODELS),
2015ACM/IEEE18thInternationalConference on , pages14ś23. IEEE,2015.
[41]Young Gon Kim, Hyoung Seok Hong, Doo-Hwan Bae, and Sung Deok Cha. Test
cases generation from uml state diagrams. IEE Proceedings-Software , 146(4):187ś
192, 1999.
[42]Young Gon Kim, Hyoung Seok Hong, Doo-Hwan Bae, and Sung Deok Cha. Test
cases generation from uml state diagrams. IEE Proceedings-Software , 146(4):187ś
192, 1999.
[43]JamesCKing. Symbolicexecutionandprogramtesting. Communications ofthe
ACM, 19(7):385ś394,1976.
[44]Rupak Majumdarand KoushikSen. Hybridconcolic testing. In Proceedingsof
the29thinternationalconferenceonSoftwareEngineering ,pages416ś426.IEEE
Computer Society, 2007.
[45]AlessandroMarchetto,PaoloTonella,andFilippoRicca. State-basedtestingof
ajaxwebapplications. In SoftwareTesting,Verification,andValidation,20081st
InternationalConference on , pages121ś130. IEEE,2008.
[46]George H Mealy. A method for synthesizing sequential circuits. Bell Labs
TechnicalJournal , 34(5):1045ś1079, 1955.
[47]George C Necula, Scott McPeak, Shree P Rahul, and Westley Weimer. CIL:
Intermediate language and tools for analysis and transformation of C programs.
InInternationalConferenceonCompilerConstruction ,pages213ś228.Springer,
2002.
[48]Jeff Offutt and Aynur Abdurazik. Generating tests from UML specifications.
InInternational Conference on the Unified Modeling Language , pages 416ś429.
Springer, 1999.
[49]Jeff Offutt, Shaoying Liu, Aynur Abdurazik, and Paul Ammann. Generating test
data from state-based specifications. Software testing, verification and reliability ,
13(1):25ś53,2003.
[50]Jeff Offutt, Shaoying Liu, Aynur Abdurazik, and Paul Ammann. Generating test
data from state-based specifications. Software testing, verification and reliability ,
13(1):25ś53,2003.
[51] Luis Pedrosa, Ari Fogel,Nupur Kothari, Ramesh Govindan, Ratul Mahajan, and
Todd Millstein. Analyzing protocol implementations for interoperability. In 12th
{USENIX}SymposiumonNetworkedSystemsDesignandImplementation( {NSDI}
15), pages485ś498, 2015.
[52]ErnestoPosseandJuergenDingel. Anexecutableformalsemanticsforuml-rt.
Software& SystemsModeling , 15(1):179ś217,2016.
[53]Eric James Rapos and Juergen Dingel. Incremental test case generation for UML-
RTmodelsusingsymbolicexecution. In IEEEFifthInternationalConferenceon
Software Testing, Verification and Validation (ICST), 2012 , pages 962ś963. IEEE,
2012.
14ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia RezaAhmadiandJuergenDingel
[54]Manoranjan Satpathy, Anand Yeolekar, and S Ramesh. Randomized directed
testing (REDIRECT) for Simulink/Stateflow models. In Proceedings of the 8th
ACM International Conference on Embedded Software , pages 217ś226. ACM, 2008.
[55]DouglasCSchmidt. Model-drivenengineering. Computer-IEEEComputerSociety ,
39(2):25, 2006.
[56]BranSelic. UsingUMLformodelingcomplexreal-timesystems. In Languages,
compilers, and toolsfor embeddedsystems , pages250ś260. Springer, 1998.
[57]BranSelic,GarthGullekson,andPaulTWard. Real-timeObject-OrientedModeling ,
volume2. John Wiley& Sons NewYork, 1994.
[58]Koushik Sen. Concolic testing. In Proceedings of the twenty-second IEEE/ACM
internationalconferenceonAutomatedsoftwareengineering ,pages571ś572.ACM,
2007.
[59]KoushikSenandGulAgha. Cuteandjcute:Concolicunittestingandexplicitpath
model-checkingtools. In InternationalConferenceonComputerAidedVerification ,
pages419ś423. Springer, 2006.
[60]KoushikSen,DarkoMarinov,andGulAgha. CUTE:aconcolicunittestingengine
forC. In ACMSIGSOFTSoftwareEngineeringNotes ,volume30,pages263ś272.
ACM,2005.[61]DaveSteinberg,FrankBudinsky,EdMerks,andMarceloPaternostro. EMF:Eclipse
ModelingFramework . Pearson Education,2008.
[62] Generating tests from UML specifications. Generating tests from uml specifica-
tions.The UnifiedModelingLanguage , pages76ś76, 1999.
[63]NikolaiTillmannandJonathanDeHalleux. Pexśwhiteboxtestgenerationfor
.net. InInternational Conference on Tests and Proofs , pages 134ś153. Springer,
2008.
[64]NikolaiTillmannandWolframSchulte.Parameterizedunittests.In ACMSIGSOFT
SoftwareEngineering Notes , volume30,pages253ś262. ACM,2005.
[65]Willem Visser, Corina S Pasareanu, and Sarfraz Khurshid. Test input generation
with java pathfinder. ACM SIGSOFT Software Engineering Notes , 29(4):97ś107,
2004.
[66]GaryWassermann,DachuanYu,AjayChander,DinakarDhurjati,HiroshiIna-
mura, and Zhendong Su. Dynamic test input generation for web applications. In
Proceedings of the 2008 International Symposium on Software Testing and Analysis ,
pages249ś260. ACM,2008.
[67]KarolinaZurowskaandJuergenDingel. SymbolicexecutionofUML-RTstatema-
chines. In Proceedingsofthe27thAnnualACMSymposiumonAppliedComputing ,
pages1292ś1299.ACM,2012.
15