CCAligner: a token based large-gap clone detector
Pengcheng Wangâˆ—
University of Science and Technology
of China
School of Computer Science
wpc520@mail.ustc.edu.cnJeffrey Svajlenko
University of Saskatchewan
Department of Computer Science
Canada
jeff.svajlenko@gmail.comYanzhao Wu
University of Science and Technology
of China
School of Computer Science
wuyanzha@mail.ustc.edu.cn
Yun Xuâˆ—â€ 
University of Science and Technology
of China
School of Computer Science
xuyun@ustc.edu.cnChanchal K. Roy
University of Saskatchewan
Department of Computer Science
Canada
croy@cs.usask.ca
ABSTRACT
Copying code and then pasting with large number of edits is a
common activity in software development, and the pasted code is
akindofcomplicatedType-3clone.Duetolargenumberofedits,
we consider the clone as a large-gap clone. Large-gap clone can
reflect the extension of code, such as change and improvement.
The existing state-of-the-art clone detectors suffer from several
limitations in detecting large-gap clones. In this paper, we propose
a tool, CCAligner, using code window that considers eedit dis-
tanceformatchingtodetectlarge-gapclones.Inourapproach,a
novele-mismatch index is designed and the asymmetric similarity
coefficient is used for similarity measure. We thoroughly evalu-
ate CCAligner bothfor large-gap clone detection,and for general
Type-1, Type-2 and Type-3 clone detection. The results show that
CCAlignerperformsbetterthanothercompetingtoolsinlarge-gap
clonedetection,and hasthebestexecution timefor 10MLOCinput
withgoodprecisionandrecallingeneralType-1toType-3clone
detection.Comparedwithexistingstate-of-the-arttools,CCAligner
is the best performing large-gap clone detection tool, and remains
competitivewiththebestclonedetectorsingeneralType-1,Type-2
and Type-3 clone detection.
CCS CONCEPTS
â€¢Softwareanditsengineering â†’Softwaremaintenancetools ;
KEYWORDS
Clone Detection, Large-gap Clone, Evaluation
âˆ—Also with Key Laboratory on High Performance Computing, Anhui Province.
â€ Yun Xu is the corresponding author.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180179ACM Reference Format:
PengchengWang,JeffreySvajlenko,YanzhaoWu,YunXu,andChanchal
K. Roy. 2018. CCAligner: a token based large-gap clone detector. In ICSE
â€™18: ICSE â€™18: 40th International Conference on Software Engineering , May
27-June3,2018,Gothenburg,Sweden. ACM,NewYork,NY,USA,12pages.
https://doi.org/10.1145/3180155.3180179
1 INTRODUCTION
Reusing code via copying and pasting is a frequent activity in
softwaredevelopment.Thecopiedcodeisknownasa codeclone.
Code clones may lead to software maintenance problems [ 29,32,
51] and bug propagation [21, 37, 57]. Therefore, clone detection is
useful for a variety of tasks (e.g., refactoring [ 31,52], debugging
[17,19],softwareevolutionstudy[ 5,22],andsoftwaremanagement
[34,44]).Copied code withfurthermodifications likestatements
insertion/deletion in addition to changes in identifiers is called
Type-3 clone. Ueda et al. [ 54] call such clones as gapped code clones,
andthuswefurthercallType-3cloneswithalargenumberofedits
(i.e., statements insertion/deletion) as large-gap clones.W ef o c u s
onthestudyoflarge-gapclonesdetectionaswellasallType-1to
Type-3 clones detection in large code bases.
Large-gapclonescanreflectdifferencebetweentwosimilarcode,
corresponding to the extension (e.g., change or improvement) of
code.Copyingcodewithmanystatementsinsertion/deletionisa
common behavior in software development. Fig. 1 shows an ex-ample of large-gap clones found in project Ant 1.10.1. Nearly the
same size of the original statements are inserted (10/12), and lines
4-13 in Fig. 1b are large gaps which reflect the extension from the
previous runprogramtothenew runprogram.Inadditiontointra-
projectclones,inter-projectclonesmaycontainlarge-gapclones,
likeclonesindifferentversionsofthesoftwareordifferentsoftware
developed for similar applications. Hence, it is important to find
the large-gap clones.
Numerous tools have been developed for clone detection [ 38].
Accordingtodifferentsourcerepresentations,mostclonedetectors
can be classified into six classes: text based [ 18,40], token based
[8,27],treebased[ 16,56],PDGbased[ 24,26],metricsbased[ 30,36],
andhybridapproaches[ 11,15].However, majorityoftextandtoken
based detectors cannot detect Type-3 clones. Although tree and
PDG basedtechniques can support thedetection of Type-3clones,
tools based on these approaches suffer from large execution times.
10662018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy

9:2>*<.27<:=7866*7-527.,6-B
<:AB@.,=<..@.7.?@.,=<.7.?80$<:.*6*7-5.:<12;
":83.,<$) !":83.,<$)&# 2/;.:>.:"*<17=55B
$<:270'(.7>.@.0.<7>2:876.7<
2/.7>7=55B.7>7.?$<:270'	(C$<:270'(7.?7>7.?$<:270'.7>5.70<1 
(

	$A;<.6*::*A,89A.7>	7.?7>	.7>5.70<1


7.?7>'.7>5.70<1($$#;.:>.:"*<1

.@.;.<7>2:876.7<7.?7>

C
.@.;.<7<#=70.<":83.,<
.@.;.<&8:42702:.,<8:A0.<":83.,<0.<*;.2:

.@.;.<866*7-527.,6-0.<866*7-527.

.@.;.<%*=7,1.:/*5;.

:.<=:7.@..@.,=<.
C,*<,1!@,.9<287.B	<1:8?7.?=25-@,.9<287.0.<8,*<287

C
C
+587.?2<16*7A;<*<.6.7<;27;.:<287
9:8<.,<.-27<:=7866*7-527.,6-B
<:AB@.,=<..@.7.?@.,=<.7.?80$<:.*6*7-5.:<12;
":83.,<$) !":83.,<$)&# .@.;.<7<#=70.<":83.,<
.@.;.<&8:42702:.,<8:A0.<":83.,<0.<*;.2:
.@.;.<866*7-527.,6-0.<866*7-527.
.@.;.<%*=7,1.:/*5;.
:.<=:7.@..@.,=<.C,*<,13*>*28!@,.9<287.B

	<1:8?7.?=25-@,.9<287.0.<8,*<287

C
C
*!:2027*5,8-.
Figure 1: Example of Large-gap Clone in Project Ant 1.10.1.
Existing studieshave shown thatthere are moreType-3clones
inthesoftwaresystemsthanothertypes[ 42,46].Therefore,Type-3
clonescanbethemostneededincodeclonedetection.Moreover,
large-gapclonesarecomplicatedType-3clones,andthestate-of-the-
arttoolssufferfromseverallimitations.Forexample,CCFinderX
[20]hasgoodscalabilityandexecutiontime,butitonlysupports
Type1-2clonedetection.iClones[ 14]canonlydetectType-3clones
with small gaps and the method is not very scalable. Although
Deckard [ 16] can detect Type-3 clones, its precision and recall are
poor [45]. NiCad [ 40] can detect Type-3 clones effectively, but it
islimitedbylargeexecutiontimesandfailstodetectwhenscales
to large code bases. SourcererCC [45] measures overlap similarity
of pairs of code blocks at token-level granularity to detect Type-
3 clones, but the similarity of large-gap clones that have largedifference in token is low. Therefore, SourcererCC needs to set a
verylowsimilaritythresholdforlarge-gapclonedetection,which
could extremely hurt precision.
In order to support fast and accurate detection of Type-3 clones,
especially the large-gap clones, we propose a technique and im-plement it as a tool, named CCAligner. Token based detectiontechniques have good scalability and execution time, and thus
CCAligner uses tokenization to normalize for Type-1/Type-2 vari-
ations. In particular, CCAligner considers sliding code windows
(i.e., continuous code fragments), instead of tokens, as basic unit
formatching.Comparedtoasingletoken,codewindowcaptures
thelocal sequence characteristicsofsource code(i.e.,localnessof
software[ 53])andcanimprovematchingaccuracy.Tofurtheren-
hancethedetectioncapabilityofclonegaps,weconsiderpairsof
codewindowsmatchwith e-mismatch,insteadofexactlymatch-
ing.Furthermore,CCAlignerusesasymmetricsimilaritycoefficient
as similarity function, which is more suitable for measuring the
clone with largegaps, since this similarity measure isrobust even
if two code blocks have large difference in size. Our tool is needed
to detect/evaluate the large-gap clones previously missed in clone
studies.Withoutsuchtools,developerscannotmitigatetherisks
caused by them.
OurexperimentsshowthatCCAlignerperformsbestinthede-
tectionoflarge-gapclones,andhasagoodperformanceindetectionof all Type-1, Type-2 and Type-3 clones. To evaluate the ability of
large-gapclonedetection,weconductanempiricalstudywitheight
subject systems and also compare with NiCad and SourcererCC,the best performing gapped clone detectors from the literature[
45]. Furthermore, to see the extent of large-gap clone detection
performance of CCAligner, we make use of the mutation-injection
basedapproach,where weadaptanestablishedbenchmark(Roy
and Cordy [ 41], and Svajlenko et al [ 50]) for syntactically creating
gappedcloneofdifferentsizes,toevaluateandcompareCCAligner
with state-of-the-art gapped clone detection tools including NiCad
[40], SourcererCC [ 45], iClones [ 14] and Deckard [ 16] for recall.
Our study shows that CCAligner is the best performing large-gap
clonedetectiontooltodate.Moreover,wecompareCCAlignerwith
different state-of-the-art tools for Type-1, Type-2 and Type-3 clone
detection,andtheresultsshowthatCCAlignerisfastandcanscale
to 10MLOC inputs with good precision and recall.
The major contributions of this paper include:
(1)Weshowthatusingcodewindowsthatconsider eeditdis-
tance for matching is effective to detect large-gap clones.
We design a novel e-mismatch index and use asymmetric
similarity function in implementation. We experimentally
demonstrate the best parameterization to detect clones.
(2)Weimplementtheproposedtechniquesasatool,CCAligner.
We show the effectiveness of the proposed techniques by
comprehensively evaluating CCAligner.
(3)The evaluations demonstrate that CCAligner is the best per-
forminglarge-gapclonedetectiontool,andremainscompet-itive with the best clone detectors in general Type-1, Type-2
and Type-3 clone detection.
Theremainderofthispaperisstructuredasfollows.Section2
describessomeconceptsaboutcodeclone,andgivesdefinitionof
large-gapclones.Section3presentsthedetailedprocessofclone
detection. Section 4 evaluates our tool both for detection of clones
with large gaps, and for general clone detection. Section 5 surveys
related work and Section 6 discusses our limitations. The paper
concludes with discussion and future work in Section 7.
1067
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. CCAligner: a token based large-gap clone detector ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
2 PRELIMINARY DEFINITION
Inthissection,wefirstintroduceconceptsanddefinitionregarding
code clones. We then propose the definition of Type-3 clones with
edit distance measure. Furthermore, we present a formal definition
of large-gap clones.
Code fragment is a continuous segment of source code, and code
blockcan bea functionor asequence ofstatements withinbraces.
Clonesare code pairs or groups that have the same or similar frag-
ment.Let uk
i=(i,sk,ek)beacodefragment,where iisthefileid,
skandekrepresentingthestartandendlineofthe kthfragment
inthisfile,respectively.Todefinemoreprecisely,a clonepair isa
triple(uk
i,ul
j,t)where code fragments uk
iandul
jare two similar
codefragmentsand tistheclonetype(Type-1,2,3or4).A clone
group(orclone class ) is a set of similar fragments, defined as the
tuple(uk
i,ul
j,...,uÐ´
h,t)whereeachpairofcodefragmentsisaclone
pair.Inaddition, Minclonesize istheminimumlinesortokensin
length that could be seen as clone. Generally, 6 lines and 50 tokens
in length or greater are the standard size for detecting [7, 39].
Royetal.[ 39]andBellonetal.[ 7]classifyclonesintofourtypes:
Type-1clones are identical code fragments except for variations in
whitespace,commentsandlayout. Type-2clonesareidenticalcode
fragments except for variations in identifiers, literals, and variable
types, in addition to Type-1 clone variations. Type-3clones are
copiedfragmentswithfurthermodificationssuchasadded,deleted
orchangedstatements,inadditiontoType-2clonevariations. Type-
4clones are code fragments that perform similar functionality but
are implemented by different syntactic variants.
While Type-1 and Type-2 clones are precisely defined and form
an equivalence relationship, there is no consensus on a suitable
similaritymeasureforType-3clones.Type-3clonesaretypically
defined with respect to line/statement-level edits, and thus we
applywidely-adoptededitdistance[ 33]measuretoType-3clone
definition.
Definition 2.1. Edit Distance: The edit distance between two
code fragments uk
iandul
j, denoted by dist(uk
i,ul
j), is the minimum
number of single-line insertion, deletion, and substitution that are
needed to transform uk
itoul
j.
As an example, two code blocks in Fig. 1 are Type-3 clones with
e=10, corresponding to 10 lines insertion (lines 4-13 in Fig. 1b).
Unmapped statements within the clone fragments are known as
clone gaps (e.g., lines 4-13 in Fig. 1b). When the proportion of clone
gaps is large, we consider such clones as large-gap clones. In other
words, pairs of code fragments are large-gap clones if satisfy: (1)
they are Type-3 clones and (2) they have large difference in size.
The quantitative definition of large-gap clones are as follows.
Definition 2.2. Large-gap clones: Given two code blocks uk
iand
ul
j,assumetheirnumberofpretty-printedlinesare LiandLj(as-
sumeLiâ‰¤Lj), respectively. Let Î»=Li/Lj, whereÎ»is the ratio
of code length, in terms of pretty-printed lines. If uk
iandul
jare
Type-3 clones and Î»â‰¤0.7, then they are large-gap clones.
Weidentifylarge-gapclonesviaascale-differencevalue Î»,and
we next explain why selecting the lower bound as 0.7 for quantita-
tive definition.LetB1be the original code block whose code length is Î±andB2
be the large-gap clone of B1withÎ±/2 lines insertion (i.e., the code
length of B2is 3Î±/2). It means when clone gaps are half size of the
original code, Î»=2/3â‰ˆ0.7, accordingto our definition. Therefore,
we identify large-gap clones if the clone gaps are nearly half the
size of the original code ( Î»=0.7) or larger ( Î»<0.7). According to
Definition 2.2,two codeblocksin Fig.1 are large-gapclones since
(1) they are Type-3 clones and (2) Î»=12/22â‰ˆ0.55 falls in the
range of 0-0.7.
3 APPROACH
TheentireprocessofourapproachissummarizedinFig.2.Itcan
beconsideredintwophases:lexicalanalysisandclonedetection.
The following subsections describe the design of each phase.
3.1 Lexical Analysis
In the lexical analysis phase, code blocks are first extracted from
thesourcefiles.Pretty-printingisusedtolayoutthetokensforone
statement per line. Tokenization is used to normalize for Type-1
and Type-2 variations.
In order to reduce the redundancy of code and constitute the
objectofclonedetection,codeblocksarefirstextractedfromsource
filesandthenpretty-printedusingTXL[ 10],asofmanystate-of-
the-art approaches (e.g., SourcererCC [ 45]). After this step, a set of
pretty-printedcodeblocksisproduced.Wethentokenizeeachcode
blockbyconvertingeachitem(suchaskeywords,operators,etc)
inthecodeblocktothecorrespondingtoken.Inordertotolerate
identifier renaming (i.e., Type-2), identifiers (e.g., variables and
functions) are mapped into the same token id. Our lexical analyzer
is mainly based on a scanner generated by Flex [35]. This scanner
can parse a single code block to ordered elements. The original
codeblocksaretransformedintonormalizedandtokenizedcode
blocks, as the input of following clone detection.
3.2 Clone Detection
Givenasetoftokenizedcodeblocks,whereType-1/Type-2varia-
tionshavebeeneliminated,wethenimplementslidingwindows
whichtolerate eeditdistanceacrosstheseblocks.Weevaluatepairs
of code blocks are clones by measuring their ratio of matched win-
dows (considering edit distance e), and report those satisfying the
similarity threshold.
Algorithm 1 describes the steps in detail. It works in two stages:
(1) Matching via index and generating candidate set (lines 1-30);
and (2) Verifying the candidate and reporting clone pairs (lines
32-40). Each step is described as follows.
3.2.1 Index and Match. Compared to a single token, code win-
dow can capture the local sequence characteristics of source code.
Hence,CCAlignerconsiderscodewindows(i.e.,continuouscode
fragments)asbasicunitformatching.Itusesslidingwindowsto
break the blocks. Since the windows are overlapping, all code frag-
ments of the window size must be located in a window.
To further enhance the detection capability of clone gaps, we
consider pairs of code windows match with e-mismatch, instead of
exactly matching. For example, assume the window size is 6 and
e=1,giventwocodewindows Wa=w(3,8)andWb=w/prime(13,18)
inFig.1,where w(3,8)meansthecodewindowcontaininglines3-8
1068
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy

  
 

	




 
Figure 2: The Overview of Our Approach.
Algorithm 1: Clone detection
Input:Fis set of tokenized code blocks {f1,f2, ...,fn},qis the window size, eis edit
distance threshold, and Î¸is the similarity threshold; q,eandÎ¸are specified by the
user
Output:All clone pairs
1candMap =Ï•;
2hashSet =Ï•;
3foreach blockfinFdo
4L=Num of lines in block f;
5numWin id=L-q+1;
6fori=1â†’L-q+1do
7 Ti= token statement of ith line;
8 forj=1â†’Ceqdo
9 h=diffCombination (Ti,Ti+1, ...,Ti+qâˆ’1);//his different
(q-e)-grams;
10 k=Hash(h);
11 v=fid;
12 hashSubSet .insert(k,i);
13 ifcandMap .find(k)then
14 candMap (k).value=candMap (k).valueâˆªv;
15 else
16 candMap .insert(k,v);
17 end
18 end
19 end
20hashSet (fid).insert(hashSubSet );
21hashSubSet =Ï•;
22end
23candPair =Ï•;
24foreach map in candMap do
25 ifNumOfValue >=2then
26 candMap .value=sort(candMap .value ,fid);
27 candPair =candPair âˆªeach pair in candMap .value;
28 end
29end
30Remove duplicate element in candPair ;
31
32foreach pair(fm,fn)incandPair do
33 setIntersection (hashSet (fm),hashSet (fn));
34numMatch 1=matched num of windows in fm;
35numMatch 2=matched num of windows in fn;
36 ifnumMatch 1>=Î¸Â·numWin mornumMatch 2>=Î¸Â·numWin nthen
37 clonePair =clonePair âˆª(fm,fn);
38 end
39end
40returnclonePair ;
codeinFig.1aand w/prime(13,18)meansthecodewindowcontaining
lines 13-18 code in Fig. 1b, we consider WaandWbare matched
with 1-mismatch.
Assumeqis the window size (i.e., there are qlines code in a
window) and eis edit distance threshold. We further use an ef-
fective method to guarantee that each window just needs to be
processedoncebydesigningthe e-mismatchindex,whichavoids
using time-consuming dynamic programming to verify the edit
distance between each pair of windows. When CCAligner scans
awindow,itgeneratesall (q-e)-grams1ofthiswindow andbuilds
1Assume code window W1=(a,b,c,d), whereq=4. When we set e=1, its all
3-grams are bcd,acd,abdandabc.an index mapping each (q-e)-gram to corresponding code block
and window. Next, for each sliding window, its (q-e)-grams are
generated and the index is updated dynamically.
Detailed steps are shown in Algorithm 1. Assume the number
of lines in block fisL, then there will be L-q+1code windows
(line 5),where qisthe window size. Eachcodewindow isasetof q
lines token statements {Ti,Ti+1,...,Ti+qâˆ’1}, whereTiis the token
statementof ithline.Defineeachcodewindowasa q-gram,then
CCAlignerbuilds e-mismatchindexandfinishesmatching(lines
8-18).Whentwocodewindows(q -grams)canbematchedunder
eedit-distance,their (q-e)-gramsshouldbematchedintheindex.
Formally, it can be stated in the form of the following theorem (Its
proof is available online2, due to limited space):
Theorem 3.1. Given code windows A and B consisting of q token
statements (the length of A and B is q), if A and B can be matchedwith maximum edit distance of e, then A and B must have at least
one matching subsequence with minimum length of q-e.
Tounderstandthistheorem,wegiveanexampleinFig.3.Assume
the window size is 6 ( q=6), and let edit distance be specified as
e=1, then two code windows W1andW2could be seen as two
6-grams.Afterthe W1isprocessed,allits5-gramsareupdatedto
theindex. W2isthecodewindow (Ð´,b,c,d,e,f),andwhenitsall
5-grams are updated to the index, we can find a match with W1by
bcdef.
&RGHZLQGRZ : DEFGHI : JEFGHI
,QGH[H  EFGHI EFGHIPDWFKHG
DFGHI JFGHI
DEGHI JEGHI
DEFHI JEFHI
DEFGI JEFGI
DEFGH JEFGH
Figure 3: Example for Theorem 3.1.
AccordingtotheTheorem,inordertofindoutifcodewindows A
andBare matched, weonly needto check if their (q-e)-grams have
at least one match. Therefore, for each sliding window, CCAligner
extractsallthedifferent (q-e)-gramsofthe q-grams,anditbuilds
an inverted index (k,v)mapping (q-e)-grams to the code blocks
containing them (lines 13-17). Then the code blocks containing
similar code windows will be grouped (line 14).
To improve efficiency, a hash value is computed on (q-e)-grams
sequenceusingtheMurmurHashhashfunction[ 2],chosenforits
lowcollisionrate.Besides,CCAlignersavesasetoftuples /angbracketlefthashVal,
winId/angbracketrightfor each code block (line 20), which is used for the next
2https://goo.gl/qDduYQ
1069
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. CCAligner: a token based large-gap clone detector ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
step to verify the candidates. Overall, when the cutting window is
sliding,CCAlignerbuildstheindexalongwithmatching.Thewhole
process finishes when the sliding window scans all code blocks.
Since the code blocks containing similar code windows have been
merged in the valueofcandMap(k), each pair in candMap(k).value
is a clone candidate (lines 24-30 in Algorithm1).
3.2.2 Verify. Thisstepistoverifywhetherthecandidatesare
clones.Foreachpair /angbracketleftfn,fm/angbracketrightincandPair,codeblocks fnandfm
contain at least one matched code window with eedit distance.
Inordertofurthermeasurethesimilarityoftwocodeblocks,we
useasymmetric Dice similarity coefficient [3] as similarity function,
defined as follows:
Definition 3.2. Asymmetric Dice similarity coefficient:
sim(fm,fn)=|Wfmâˆ©Wfn|
min(|Wfm|,|Wfn|),
whereWfmis the set of code windows contained in the code block
fm,Wfnis the set of code windows contained in the code block fn
and the min function normalizes the similarity score with respect
to the number of windows contained in the smaller code block.
By calculating an intersection between hashSet(fn) andhash-
Set(fm), then the number of matched code windows (considering e
edit distance) is obtained. If the sim (fm,fn)satisfiesÎ¸specified by
user, then CCAligner reports /angbracketleftfn,fm/angbracketrightas a clone pair (lines 32-40).
WeusetheasymmetricDicecoefficientinsteadofothersimilarity
measures (e.g., the Jaccard coefficient) because large-gap clones
havealargedifferenceinsize.Therefore,consideringtheminimum
cardinalityofthesetsofcodewindowsatthedenominatorofthe
formula allows to weigh the similarity between code blocks better.
ConsiderthecodeinFig.1asanexampletoshowhowCCAligner
enableslarge-gapclonedetection.Thesetwocodeblockshavebeen
prettyprinted,andwecoulddirectlytakealookatthesourcecode,sincetheircorrespondingtokensarethesameifthecodeblocksarethesame.Inclonedetectionphase,assumethewindowsizeis6and
eachwindowtolerates1mismatch(i.e., q=6ande=1),thenfor
eachwindowitwillproducesix5-gramsformatching.Ifthereexists
one 5-grams match between two windows, these two windows are
considered as a match. Code block in Fig. 1a will produce 7 sliding
codewindowseachcontaining6linesofcode,andcodeblockinFig.
1bwillproduce17slidingcodewindows.Consider WinSet(fa)=
{w(1,6),w(2,7),...w(7,12)}forcodeblockinFig.1a,where w(1,6)
meansthethefirstcodewindowcontainingfirst6linesofcode,and
WinSet(fb)={w/prime(1,6),w/prime(2,7),...w/prime(17,22)}for code block in
Fig. 1b. Finally, 5 windows in WinSet(fa)match with the windows
inWinSet(fb). Note that w(3,8)can match with w/prime(13,18), due
toour1-mismatchstrategy.Accordingtooursimilaritymeasure,
sim(fa,fb)=5/7â‰ˆ0.71, so this pair of large-gap clones can be
detected setting similarity threshold as 70%.
However, some existing state-of-the-art tools suffer from sev-
eral limitations in detection of the large-gap clone in Fig. 1. For
example, NiCad [ 40] will miss this clone since it uses LCS similar-
ity for Type-3 and the LCS similarity of these two blocks is very
low. SourcererCC [ 45] will miss such clone unless a low similarity
threshold(50%)isset,whichcouldextremelyhurttheperformance.
Besides,werunline-baseddetectoriClones[ 14],anditevenfails
to report the similar regions before and after the gap.Table 1: Recall per Clone Type and Precision Measured for
BigCloneBench with Different Parameterization
qeRecallPrecision
T1 T2 VST3 ST3 MT3
60 100 99 89 31 1 93
1 100 99 97 70 10 802 100 99 99 80 24 61
70 100 99 82 15 1 941 100 99 97 59 6 822 100 99 98 77 16 77
80 100 99 78 9 1 961 100 99 97 51 4 832 100 99 98 71 11 82
4 EVALUATION
InthissectionwethoroughlyevaluateCCAlignerbothforlarge-
gap clone detection, and for general Type-1, Type-2 and Type-3clone detection. We begin by demonstrating experimentally that
q=6 ande=1 work best for clone detection which balance recall
with precision and performance.
4.1 Parameter Setting
CCAlignerimplementsslidingwindowswhichtolerate eeditdis-
tance across code blocks, and evaluates pairs of code blocks areclones by measuring their ratio of matched windows (consider-ing edit distance e). Hence, the choice of window size
qand edit
distance threshold ewill affect the performance of clone detection.
To find the most suitable parameterization for detecting, we
try various combinations of q,eto evaluate CCAligner with Big-
CloneBench [ 46,48] using the BigCloneEval [ 49] framework for
minimum clone size of 6 lines, and a similarity threshold of 60%.
BigCloneBench is a large benchmark of manually validated clones
in a large inter-project Java repository. BigCloneEval allows theuser to conduct custom recall measurement experiments on top
of BigCloneBench, and automatically handles aspects such as tool
execution and recall analysis [49].
Since 6 lines in length orgreater are the standard size fordetect-
ing[7,39],andwhen eislarge,theaccuracyofthematchwould
below.Hence,weselect qâ‰¥6andeasasmallnumber.Inourex-
periments,wetryvariouscombinationsof q=6,7,8ande=0,1,2.
Whene=0, pairs of code windows are exactly matched. Recall
is summarized per clone type, as per the BigCloneBench defini-
tions[48].Specifically,BigCloneBenchsplitstheType-3clonesinto
multiplecategorizesbytheirsyntacticalsimilarity.Very-Strongly
Type-3 (VST3) clones are those that are 90-100% similar by syntax,
StronglyType-3(ST3)clonesare70-90%similar,andModerately
Type-3(MT3)clonesare50-70%similar.Wemeasureprecisionby
manually validating a random sample of the clones detected by
CCAlignerduringtheBigCloneBenchexperiments.Werandomly
select 200 clones for each parameterization to validate (1,800 clone
pairs in total). The recall is reported by the BigCloneEval frame-
work.
Detailed results are summarized in Table 1. We can see that
CCAligner has perfect or near-perfect Type-1 and Type-2 recall
evene=0,sincetheType-1/Type-2variationshasbeennormalized
intokenization.Forthesame q,wheneislarger,therecallofType-3
1070
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy
(i.e., VST3, ST3, and MT3) gets better but the precision gets worse,
because allowing more mismatch in windows will enhance the
detection capability of clone gaps but cause more false positive.
Although the recall is the best when q=6 ande=2, the precision
is rather poor. We can see that /angbracketleftq=6,e=1/angbracketright,/angbracketleftq=7,e=2/angbracketright, and
/angbracketleftq=8,e=2/angbracketrightwork better for clone detection which balance recall
with precision.
Table 2: Execution Time and Memory Space with Different
Parameterization for Linux 4.8.12
Configuration q,e 6,1 7,2 8,2
PerformanceTime 13m 2s 32m 37s 28m 16s
Space 3.4 GB 12.2 GB 11.5 GB
We next evaluate the execution time of CCAligner with these
three configurations to justify the best choice for detection. To ob-
viously show the difference of performance, we use large codebase,
Linux kernel 4.8.12, as our target. The source code contains 23424
code files with 11,505,767LOC (i.e., line of code), measured by tool
cloc[9].TheresultsareinTable2.WecanseethatCCAlignerneeds
less time and memory space for detection when q=6 ande=1.
Therefore, q=6 ande=1 are the most suitable configurations for
detectingwhichbalancerecallwithprecisionandperformance.We
thus setq=6 ande=1 for the next clone detection evaluation.
4.2 Large-gap Clone Detection
After experimentally determining the parameters (i.e., qande)
used for clone detection, we now demonstrate the ability of our
CCAlignerforlarge-gapclonedetection.Wefirstconductanem-
pirical study with eight subject systems and compare with state-
of-the-artgappedclonedetectorsintermsofprecision,recalland
F1-score.Furthermore,toseetheextentoflarge-gapclonedetection
performance of CCAligner, we develop a variant of an establishedsyntactic benchmarking framework, the Mutation-Injection based
framework[ 41,50],toevaluateandcomparetherecallofCCAligner
for different gap sizes.
4.2.1 Empirical Study .WeselectatotalofeightCandJava
open source projects as our dataset for evaluation. The size of
thesourcecodeoftheprojectsvariesfrom43KLOCto138KLOC.
The detailed statistics of subject systems can be seen in Table 3,
measured by tool cloc [9].
Table 3: Subject Systemâ€™s Statistics
System Language Files LOC
Cook 2.34 C 296 43,900
Redis 4.0.0 C 213 85,664
PostgreSQL 6.0 C 339 94,087
Linux 1.0 C 282 103,677
JDK 1.2.2 Java 115 17,140
OpenNLP 1.8.1 Java 903 66,291Maven 3.5.0 Java 952 79,840Ant 1.10.1 Java 1223 138,505
From the literature [ 45], NiCad and SourcererCC are the best
performinggappedclonedetectors.Hence,wecompareCCAligneragainsthigh-recalltoolsNiCadandSourcererCCtodemonstrate
that CCAligner can detect large-gap clones that the best of the
competing tools are missing.
We first detect code clones in these projects using CCAligner,
NiCad and SourcererCC, all with the configurations of min length
10 lines, min similarity 70%. We define
Recall=LGâˆ’FP
Union of TP,
whereLG-FPis the true positive large-gap clones reported by one
tool,anddenominatoristheunionoftruepositivelarge-gapclones
(removing duplicate elements) reported by different tools. We also
define
F1-score =2Â·Precision Â·Recall
Precision +Recall.
After the clone results are obtained, we measure precision by
manually validating a random sample of the clones detected by
different tools (100 for each). To measure the recall of large-gap
detection, we choose the union of true positive large-gap clones
reported by different tools as the reference corpus. To create the
large-gaprecallbenchmark,weselecttheclonessatisfyingourDef-inition2.2(i.e.,large-gapclones)bycalculatingthescale-difference
valueÎ».I fÎ»â‰¤0.7, we consider this clone pair as a large-gap clone.
Furthermore,wemanuallyvalidatealldetectedlarge-gapclones,
and remove the false positive clones.
Table 4 shows the detailed values of precision, recall, and F1-
score for each tool in detection of C projects. LGin Table 4 is
thenumberofdetectedlarge-gapclones,and FPisthenumberof
falsepositiveclonesamongtheselarge-gapclones.ComparedtoNiCad and SourcererCC, our CCAligner has the best recall and
F1-score in each project. SourcererCC and NiCad miss many large-
gapclonesthatCCAlignerdetects,reflectedasmuchlowerrecall.
The total recall and F1-score of CCAligner in C projects are the
best, whereas the other tools are much lower. Finally, a manual
validationidentifies377truepositivelarge-gapclonesintheseC
projects.
Table 4: Large-gap Clone Evaluation Results for C.
System Tool LG FP Precision Recall F1-Score
Cook 2.34NiCad 0 0 84 0 0
SourcererCC 14 0 89 19 31
CCAligner 63 2 86 81 83
Redis 4.0.0NiCad 1 0 87 4 8
SourcererCC 7 0 90 27 42
CCAligner 22 2 88 77 82
PostgreSQL 6.0NiCad 0 0 82 0 0
SourcererCC 38 0 84 16 27
CCAligner 219 13 83 85 84
Linux 1.0NiCad 1 0 82 3 6
SourcererCC 12 1 87 32 47
CCAligner 27 1 85 76 80
TotalNiCad 2 0 84 0.5 1
SourcererCC 71 1 88 19 31
CCAligner 331 18 86 83 84
Table5showsthedetailedresultsforJavaprojects.Compared
to NiCad and SourcererCC, CCAligner also has the best recall and
F1-scoreinallprojects.Forexample,CCAlignergetsthebestrecall
1071
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. CCAligner: a token based large-gap clone detector ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
of 93% and best F1-score of 87% among all the tools in Maven 3.5.0
project. NiCad fails to detect large-gap clone in these projects, and
SourcererCC still has much lower recall and F1-score althoughits precision is a little better than CCAligner. Finally, a manual
validationidentifies525truepositivelarge-gapclonesintheseJava
projects.
Table 5: Large-gap Clone Evaluation Results for Java.
System Tool LG FP Precision Recall F1-Score
JDK 1.2.2NiCad 0 0 87 0 0
SourcererCC 4 0 88 24 38
CCAligner 15 1 86 78 82
OpenNLP 1.8.1NiCad 0 0 81 0 0
SourcererCC 5 0 85 2 4
CCAligner 221 7 83 99 90
Maven 3.5.0NiCad 0 0 80 0 0
SourcererCC 38 1 83 18 30
CCAligner 217 30 82 93 87
Ant 1.10.1NiCad 0 0 80 0 0
SourcererCC 13 0 84 15 25CCAligner 87 10 83 88 85
TotalNiCad 0 0 82 0 0
SourcererCC 60 1 85 11 19
CCAligner 540 48 84 94 89
SinceSourcererCCandNiCadonlydetectafewlarge-gapclones
in our reference corpus containing 377 C and 525 Java true posi-
tive large-gap clones. We further run NiCad and SourcererCC with
allowingmoresimilaritythresholdstoseehowtheprecisionand
recall vary. We run NiCad and SourcererCC all with min similarity
threshold as 60% and 50%. We measure precision by manually vali-
datingarandomsampleoftheclonesreportedbySourcererCCand
NiCad(400foreachlanguage,sameasCCAligner),andtherecall
reflectshowmanylarge-gapclonescanbedetectedinourreference
corpus.ThedetailedresultsforNiCadareinFig.4,andthedetailed
resultsforSourcererCCareinFig.5.Theprecision,recallandF1-
score of CCAligner for the reference corpus are summarized in the
totaliteminTable4andTable5.Theresultsshowthattherecall
of the tools in both C and Java projects only increases a bit, but
the precision becomes worse. For example, even setting similarity
as50%,SourcererCConlydetects135large-gapclonesoutof377
large-gap clones (36%) contained in the C reference corpus with
62% precision, whereas CCAligner can detect 313 large-gap clones
(83%)with86%precision.Hence,theexperimentsdemonstratethat
CCAligner is able to detect large-gap clones that the best of the
competing tools are missing without harming the precision.
To further show empirically the large-gap clones we detect, we
summarize the number of different types of clones detected byCCAligner in these C and Java projects in Table 6. Since
Î»is the
ratio of code length in terms of pretty-printed lines, given pairs of
clones,weapproximatelyconsiderthemasType-1orType-2clones
ifÎ»=1,andwhen Î»isnotequalto1,weapproximatelyconsider
them as Type-3 clones. We also summarize the proportion of large-
gapclonesinType-3clonesandallclones.Wecanseethatthere
are more Type-3 clones than other types in most projects, which is
consistentwithexistingstudies[ 42,46].AmongType-3clones,the
proportion of large-gap clones varies from 11% to 37%, and among
all clones, the proportion of large-gap clones varies from 3% to 
 	  
 	
 


  	    

 
   	 	 	    
  

 
      
 	
Figure 4: Performance of NiCad with Different Similarity
Thresholds.
 
 	  
 	
 


    	  

 
  
   
	 
 
 
 	
  

 
      
 	
Figure 5: Performance of SourcererCC with Different Simi-
larity Thresholds.
22%. For example, there are 22% of clones (37% of Type-3 clones) inPostgreSQL 6.0 are large-gap clones. It shows that large-gap clones
are common and exist in real software systems.
Table 6: Proportion of Large-gap Clones Detected by
CCAligner
System Type-1&2 Type-3 All LG/Type-3 LG/All
Cook 2.34 551 413 964 15% 7%
Redis 4.0.0 107 118 225 19% 10%PostgreSQL 6.0 395 593 988 37% 22%Linux 1.0 217 253 470 11% 6%
JDK 1.2.2 89 43 132 35% 11%
OpenNLP 1.8.1 661 723 1384 31% 16%Maven 3.5.0 5432 917 6349 24% 3%Ant 1.10.1 309 375 684 23% 13%
Our comparison (Section 4.3) with the state-of-the-art tools will
also show that CCAligner is also competitive with SourcererCC
and NiCad in Type 1-3 clone detection in terms of execution time,
precision and recall.
4.2.2 Gapped Clone Evaluation .Since precision could be
approximated with randomly validating a significant samples of
the detected clones, our way of reporting the precision above isaligned with the state of the art [
7,41,43,45,47]. However, for
measuringrecall,oneneedstohaveanoracle[ 43,50].Wehavebuilt
theoraclebyunioningthegappedclonesdetectedbythesubject
tools from our subject systems and then manually validating from
them. While this gives an approximate and relative comparison of
recall among the competing tools, it does not guarantee [ 4,41,47]
1072
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy
the recall values we reportedabove. We thus wanted to examine
the extent of large-gap clone detection performance of CCAligner
for different gap sizes using an established procedure borrowed
from Mutation [ 1] analysis community. In particular, we adapt
an established mutation-injection based benchmarking framework
[41,50]forsyntacticallycreatinggappedclonesofdifferentsizes,
and evaluate and compare CCAligner with the state of the artgapped clone detection tools including NiCad [
40], SourcererCC
[45], iClones [14] and Deckard [16] for recall.
Mutation-based approach can automatically and efficiently mea-
sure (and compare) the recall of clone detection tools for different
types of clones. By using code mutation operators to generate and
track a large number of artificial clones, we can then automati-
callymeasurehowefficiently(i.e.,recall)theseknownclonesare
detected by group of tools for comparing different tools.
We designed a clone-producing mutation operator that copies a
code fragmentand inserts a singlegap of a certainlength into the
copiedversion.Weusedtheframeworkwithourmutationoperator
to generate 200 synthetic gapped clones per gap length rangingfrom one source line to 20 source lines. In total, our referencecorpus contains 2,000 synthetic gapped clones. We constrainedthe clone synthesis to clones that are 15 source lines or greater
before insertion of the gaps. We selected the code fragments from
a large repository of Java source code (JDK and various Apache
commonslibraries),andinjectedthegappedsyntheticclonesone
at a time into the subject system. We use the same 200 original
code fragments andinjection locations for eachgap length, so we
can compare recallacross the gap lengths withoutbias due to the
original source code used and injection locations.
We measured CCAlignerâ€™s recall for the clones per inserted gap
length. We configured NiCad for a 70% threshold, with identifier
andliteralvaluenormalizationsenabled.WeconfiguredCCAligner,
Deckard and SourcererCC also with a 70% threshold. We executed
iClonesforaminimumclonelengthof50tokensandaminimum
block length of 20 tokens.
 
   

 
  
 
   	  
  
        
      	                  	 	     

 
     
     
     
     
 
    
     
     
     
     
	     

     
	
			
	
	

	
                  	  
  	 

	
	
Figure 6: Recall For Gapped Clones by Gap Length
WeshowtherecallofCCAlignerandthecompetingtoolsacross
the gap lengths in Figure 6. As can be seen, while all the tools can
detectcloneswithsmallgaps,CCAligneristheonlytoolthatcan
detectcloneswithlargergaps.SourcererCChasgoodrecallforgapsof one of two source lines, but recall quickly diminishes after three
sourcelines.NiCad,duetopowerfulnormalization,maintainshigh
recall until gaps of length five, where its recall begins to diminish.
WeseethatiClonesandDeckardperformmuchworseinthegapped
clone detection.
CCAlignerhassimilarrecalltoNiCadandSourcererCCforsingle
line gaps.Due to more conservativeconfiguration, CCAligner has
lower recall for clones with the smaller gaps. However, it is able to
maintainthisrecallevenforthecloneswithlargegaps.Therecallof
the other tools drops off because with larger gaps it becomes more
likelytheclonescanbeclassifiedaslarge-gapclones,andcannot
be detected with a standard threshold (70%) by the other tools.
While NiCad and SourcererCC could detect these large-gap clones
by lowering their threshold, this would result in poor precision.
In contrast, CCAligner can detect these large-gap clones while
maintaining precision.
4.3 General Clone Detection
To evaluate the ability of CCAligner to detect general-purpose
clones (i.e., Type-1, Type-2 and Type-3 clones), we extend the tool
evaluation experiment in the SourcererCC publication by Sajnani
et al. [45]. We execute these evaluations for our CCAligner, under
the same conditions used by them, and directly compare against
thepreviousresultsintheliterature[ 45,47,48].Forexperiments
on execution time, recall and precision, we execute CCAligner for
minimum clone size of 6 lines, window size q=6, an edit distance
e=1, anda similaritythreshold of60%. Theconfigurations ofthe
competing tools from the experiment we extend can be found in
Sajnani et al.â€™s work [45].
4.3.1 Execution Performance .Weusethesameinputasused
bySajnanietal.[ 45]intheirexperimentwithSourcererCC.Weexe-
cuteonacomparablemachinewithaquad-coreCPU,12GBofmem-
oryand a solidstate drive.Execution performancefor CCAligner
and the competing tools is shown in Table 7.
We find that CCAligner has fast execution performance with
scalabilityuptotenmillionlinesofcode.CCAlignerfailsforthe
100MLOC input with an out of memory error. Specifically the e-
mismatch index, which is kept in memory to enable fast detection,
exceeds the available memory (12GB). Still, this is very good scala-
bility, and most software systems do not reach even 10MLOC.
Compared to the state of the art, CCAligner shares the best
execution time, while achieving the second best scalability. Execu-
tion time is very similar to CCFinderX and SourcererCC. However,
CCFinderX only detects Type-1 and Type-2 clones, and Sourcer-
erCC misses many large-gap clones which can be detected by
CCAligner, as we showed previously. CCAlignerâ€™s scalability falls
behind CCFinderX and SourcererCC. However, both of these tools
stillrequiredaysofexecutiontimetoscaleto100MLOC.Sourcer-
erCCspecificallywasdesignedtoenablelarge-scaleclonedetection,
whilewefocusonthedetectionoflarge-gapcloneswithCCAligner.
WhileCCFinderXscaleswell,itsclonedetectionismuchsimpler,
focusing only on Type-1 and Type-2 clones.
4.3.2 Recall .We measure clone detection recall using Sva-
jlenko et al.â€™s two proven benchmarks: (1) The Mutation and Injec-
tion Framework [41, 50] and (2) BigCloneBench [46, 48, 49].
1073
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. CCAligner: a token based large-gap clone detector ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
Table 7: Execution Time for Varying Input Sizes
LOC CCAligner CCFinderX Deckard iClones NiCad SourcererCC
1K 1s 3s 2s 1s 1s 3s
10K 1s 4s 9s 1s 4s 6s
100K 7s 21s 1m 34s 2s 21s 15s
1M 1m 13s 2m 18s 1hr 12m 3s â€” 4m 1s 1m 30s
10M 24m 56s 28m 51s â€” â€” 11hr 42m 47s 32m 11s
100M â€” 3d 5hr 49m â€” â€” â€” 1d 12h 54m
Table 8: Recall Measured by The Mutation Framework
Language Clone Type CCAligner CCFinderX Deckard iClones NiCad SourcererCC
Java1 100 99 39 100 100 100
2 100 70 39 92 100 100
3 99 0 37 96 100 100
C1 100 100 73 99 99 100
2 100 77 72 96 99 100
3 100 0 69 99 99 100
C#1 100 100 - - 98 100
2 100 78 - - 98 100
3 98 0 - - 98 100
Table 9: Recall Per Clone Type and Precision Measured for BigCloneBench
Tool CCAligner CCFinderX Deckard iClones NiCad SourcererCC
Type-1 100 100 60 100 100 100
Type-2 99 93 58 82 100 98
Very Strongly Type-3 97 62 62 82 100 93
Strongly Type-3 70 15 31 24 95 61
Moderately Type-3 10 1 12 0 1 5
Precision 80 72 28 91 56 83
Precision (10LOC) 83 79 30 93 80 86
FortheMutationandInjectionFramework,recallissummarized
per clone type in Table 8. We also include the results of the com-
peting tools as measured in the previous work [ 45]. CCAligner
has perfect or near-perfect recall for clones of the first three types
in all three of the tested languages. NiCad and SourcererCC per-
form similarly. CCAligner performs better than iClones for Type-2
clones, and performs much better than CCFinderX and Deckard.
CCAlignerrecallissignificantlybetterthanthatofCCFinderXand
Deckard.
For BigCloneBench, recall is summarized in Table 9. We also
show the recall of the competing tools as measured in the previous
work [45]. Recall is summarized per clone type, as we described
in Section 4.1. CCAligner and most of the competing tools have
prefect or near-perfect Type-1 and Type-2 recall. More interesting
is the comparison of Type-3 recall. CCAligner has near-perfect
recallforthevery-stronglyType-3clones,fallingbetweenNiCad
andSourcererCC.CCAlignerhasthesecondbeststronglyType-3
recall, falling behind NiCad but ahead of SourcererCC. CCAligner
alsohasthesecondbestmoderatelyType-3recall,althoughnone
of the tools have a significant recall for this category. These results
showthatCCAlignerisastrongType-3clonedetector.Overallit
has the second best recall, second only to that of NiCad.
4.3.3 Precision .We measured precision by manually validat-
ingarandomandstatisticallysignificantsampleoftheclonesde-
tected by CCAligner during the BigCloneBench experiment. We
randomly selected 400 clones to validate, a statistically significantsample. Precision is summarized in Table 9. The results for theother tools were taken from the previous work [
45]. CCAligner
has the 3rd best precision at 80%, just slightly behind SourcererCC.
The previous work [ 45] suggests that tools that target high Type-3
recall can have low precision for small clone sizes. While 6 lines
isacommonminimumclonesizeinbenchmarking[ 7,45,47,48],
many modern Type-3 clone detectors recommend a larger min-imum clone size in the range 10-15 lines or equivalent [
14,40].
Therefore,asdoneintheexperiment[ 45],wealsomeasurepreci-
sion for just those clones that are 10 lines in length or larger. In
this case, precision increases for CCAligner to 83%.
4.3.4 Summary .We summarize our results of the extension
of Sajnani et al.â€™s [45] experiment with our CCAligner in Table 10.
We show recall for all clone types and for just Type-3 clones (both
consideringjusttheVeryStronglyandStronglyType-3categoriesin
BigCloneBench).Weshowprecisionmeasuredforaminimumclone
size of 6 lines and 10 lines of code. We also show the maximum
scalability of each tool, as well as their execution time for the
10MLOC input (the max scalability of CCAligner). Using these
results we can demonstrate the position of CCAligner amongst the
state of the art.
CCAlignerhasthesecondbestrecall,bothoverallandspecifi-
cally for Type-3 clones, behind only NiCad, but ahead of tools like
SourcererCC and iClones. While NiCad has very high recall, itsexecution time is much longer than CCAligner for 10MLOC in-
puts. As well, NiCadâ€™s precision suffers for small clones (6-9 lines),
1074
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy
Table 10: Recall and Precision Summary
Tool CCAligner CCFinderX Deckard iClones NiCad SourcererCC
Recall192 75 53 78 99 90
Recall (T3)275 26 38 38 96 68
Precision (6LOC+) 80 72 28 91 56 83
Precision (10LOC+) 83 79 30 93 80 86
Scalability 10MLOC 100MLOC+ 1MLOC 100KLOC 10MLOC 100MLOC+
Time (10MLOC) 24m56s 28m51s - - 11hr24m 32m11s
1Including T1, T2, VST3 and ST3 categories.2Including VST3 and ST3 categories.
whichCCAlignercandetectthesesmallcloneswithgoodprecision.
CCAlignerhas similarprecisionto SourcererCC,but betterrecall,
specificallyfortheType-3clones.CCAlignerhasthebestexecution
time for the 10MLOC input. CCAligner has competitive scalability
amongst the tools. Only SourcererCC (designed for scalability) and
CCFinderX (does not detect Type-3 clones) can scale to 100MLOC.
While Deckard and iClones detect Type-3 clones, their recall is
lowerthanCCAlignerandtheycannotscaletoeven10MLOCon
our standard workstation.
Our CCAligner is well situated amongst the competing tools,
with excellent execution time, and good recall and precision. Be-
sides,CCAligneristhebestperforminglarge-gapclonedetection
tool.
5 RELATED WORK
There have been numerous clone detectors in the literature, and
Rattan et al. [38] summarized most of the tools in their research.
Amongthetextbasedtools[ 12,18,40],Johnson[ 18]appliedafin-
gerprinting technique for comparison of source code, and Ducasse
etal.[12]useddynamicpatternmatchingforlinebasedcomparison.
However, both techniques do not support Type-3 clones detection.
NiCad[40]isatextbasedhybridtool,whichusedlongestcommon
subsequencealgorithmforcodecomparison,andcandetectType-3
cloneseffectively.Ho wever,this methodwillfailtodetectlarge-gap
clones since the clones have large difference in LCS similarity.
Among the token based tools [ 14,20,45], SourcererCC [ 45] and
iClones [ 14] support Type-3 clone detection. Sajnani et al. [ 45]
measuredoverlap similarityofpairs ofcodeblocksat token-level
granularity to identify clones, which will miss many large-gapclones since the similarity measure is not robust to large gaps.iClones[
14]usessuffixtreebasedtokenbytokencomparisonto
detect Type-1/Type-2 clones and then merges neighboring Type-1
and Type-2 clones to form Type-3 clones. However, iClones can
only detect Type-3 clones with small gaps.
Tree and Program Dependency Graph (PDG) based tools can
supportthe detectionofType-3 cloneswell,such asCloneDR[ 6],
Deckard [ 16], Duplix [ 26] and GPLAG [ 28], where CloneDR and
Deckard are tree based, and Duplix and GPLAG are PDG based.
However,large-gapclonesmayaffectthetreeandPDGstructure
due to the extension of the code, and thus these tools will fail to
detect large-gap clones.
Amongthemetricsbasedtools[ 23,25,30],Kodhaietal.[ 23]only
support Type-1 and Type-2 clones detection. Mayrand et al. [ 30]
andKontogiannisetal.[ 25]detectedclonesusingmetricsextracted
from AST of source code. However, like tree based tools, they will
fail todetect large-gapclones sincelarge gaps mayaffect theASTstructure and further affect the metrics.There exists some other techniques for clone detection, such as
MeCC [21]. MeCC detects code clones by comparing programsâ€™
abstractmemorystates.WhiletheyhaveaverygoodrecallinType-
3 even Type-4 clones, their methods will miss the large-gap clones
where large gaps affect the memory states. Besides, MeCC also
suffers from large execution time.
6 LIMITATIONS
One limitation of the current implementation of CCAligner is that
it cannot scale to detect clones in 100MLOC input on a standard
workstation with 12GB of memory, since CCAligner stores thewholee-mismatchindexinmemoryduringtheprocessofgener-
ating clone candidates. Another limitation is the evaluation work.
The configurations of the tools affect the performance of clone de-
tection[55].Toreducethislimitation,wefollowtheconfigurations
of previous literature work [45] which seemed to be standard.
7 CONCLUSION AND FUTURE WORK
In this paper, we have presented a novel clone detecting technique,
and implemented the proposed technique as a tool, CCAligner. We
havedemonstratedthecorrectnessofourtechnique,andshowed
theeffectivenessoftheproposedtechniquebyexperimentallyeval-uatingit.Weconductanempiricalstudyforlarge-gapclonesdetec-
tion with eight systemsto demonstrate that CCAligner can detect
large-gapclonesthatthebestofthecompetingtoolsaremissing,
shown as the best recall and F1-score in all selected open source
projects. Moreover, we develop a variant of the Mutation-Injection
frameworktoevaluateandcomparetherecallofCCAlignerfordif-ferentgapsizes.TheresultsfurthershowthatCCAligneristhebestperforming large-gap clone detection tool. We further demonstrate
that CCAligner remains competitive with thebest clone detectors
in general Type-1, Type-2 and Type-3 clone detection, shown as
thebestexecutiontimefor10MLOCinputwithgoodprecisionand
recall. We offer CCAligner as a large-gap clone detector, and other
clonerelatedresearchcouldbenefitfromthedetectionoflarge-gap
clones, such as clone refactoring [52].
Inthefuturework,weareplanningonimprovingthescalability
ofourproposedapproach.Thedatastructureofouralgorithmis
organized as /angbracketleftkey, value /angbracketright, so it is especially suitable for distributed
computing, like Hadoop [13].
ACKNOWLEDGMENTS
This work was supported in part by the National Nature Science
Foundation of China under grant No. 61672480, Canada First Re-
search Excellence Fund (CFREF) and Natural Sciences and Engi-
neering Research Council of Canada (NSERC).
1075
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. CCAligner: a token based large-gap clone detector ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]James H Andrews, Lionel C Briand, and Yvan Labiche. 2005. Is mutation an
appropriate tool for testing experiments?. In Proceedings of the 27th international
conference on Software engineering. ACM, 402â€“411.
[2]Austin Appleby. 2016. Murmurhash hash functions. (2016). https://github.com/
aappleby/smhasher/
[3]RicardoBaeza-YatesandBerthierRibeiro-Neto.1999. Moderninformationretrieval.
Vol. 463. ACM press New York.
[4]Brenda S Baker. 2007. Finding clones with dup: Analysis of an experiment. IEEE
Transactions on Software Engineering 33, 9 (2007).
[5]TiborBakota,RudolfFerenc,andTiborGyimothy.2007. Clonesmellsinsoftware
evolution.In IEEEInternationalConferenceonSoftwareMaintenance .IEEE,24â€“33.
[6]Ira D Baxter, Andrew Yahin, Leonardo Moura, Marcelo Santâ€™Anna, and Lorraine
Bier. 1998. Clone detection using abstract syntax trees. In Proceedings of the
International Conference on Software Maintenance. IEEE, 368â€“377.
[7]StefanBellon,RainerKoschke,GiulioAntoniol,JensKrinke,andEttoreMerlo.
2007. Comparison and evaluation of clone detection tools. IEEE Transactions on
software engineering, 33, 9 (2007).
[8]Xiao Cheng,Lingxiao Jiang,Hao Zhong,Haibo Yu,and JianjunZhao. 2016. On
the feasibility of detecting cross-platform code clones via identifier similarity. In
Proceedings of the 5th International Workshop on Software Mining. ACM, 39â€“42.
[9] Cloc. 2015. Count lines of code. (2015). http://cloc.sourceforge.net/
[10]JamesRCordy.2016. TheTXLProgrammingLanguage. (2016). https://www.txl.
ca/
[11]Yingnong Dang, Dongmei Zhang, Song Ge, Chengyun Chu, Yingjun Qiu, and
Tao Xie. 2012. XIAO: Tuning code clones at hands of engineers in practice. In
Proceedings of the 28th Annual Computer Security Applications Conference. ACM,
369â€“378.
[12]StÃ©phane Ducasse, Matthias Rieger, and Serge Demeyer. 1999. A language in-
dependent approach for detecting duplicated code. In Software Maintenance,
1999.(ICSMâ€™99) Proceedings. IEEE International Conference on. IEEE, 109â€“118.
[13]The Apache Software Foundation. 2017. Apache Hadoop. (2017). http://hadoop.
apache.org/
[14]Nils GÃ¶de and Rainer Koschke. 2009. Incremental clone detection. In Proceedings
of the European Conference on Software Maintenance and Reengineering. IEEE,
219â€“228.
[15]Yue Jia, David Binkley, Mark Harman, Jens Krinke, and Makoto Matsushita.
2009. KClone: a proposed approach to fast precise code clone detection. In Third
International Workshop on Detection of Software Clones (IWSC).
[16]LingxiaoJiang,GhassanMisherghi,ZhendongSu,andStephaneGlondu.2007.
Deckard:Scalableandaccuratetree-baseddetectionofcodeclones.In Proceedings
of the 29th International Conference on Software Engineering. IEEE Computer
Society, 96â€“105.
[17]Lingxiao Jiang, Zhendong Su, and Edwin Chiu. 2007. Context-based detection of
clone-relatedbugs.In Proceedingsofthe6thjointmeetingoftheEuropeansoftware
engineeringconferenceandtheACMSIGSOFTsymposiumonThefoundationsof
software engineering. ACM, 55â€“64.
[18]JHowardJohnson.1994. SubstringMatchingforCloneDetectionandChange
Tracking..In ProceedingsoftheInternationalConferenceonSoftwareMaintenance,
Vol. 94. 120â€“126.
[19]ElmarJuergens,FlorianDeissenboeck,BenjaminHummel,andStefanWagner.
2009. Do code clones matter?. In Proceedings of the 31st International Conference
on Software Engineering. IEEE, 485â€“495.
[20]ToshihiroKamiya.2016. TheofficialCCFinderXwebsite. (2016). http://www.
ccfinder.net/
[21]Heejung Kim, Yungbum Jung, Sunghun Kim, and Kwankeun Yi. 2011. MeCC:
memory comparison-based clone detector. In 2011 33rd International Conference
on Software Engineering. IEEE, 301â€“310.
[22]MiryungKim,VibhaSazawal,DavidNotkin,andGailMurphy.2005. Anempirical
study of code clone genealogies. In ACM SIGSOFT Software Engineering Notes,
Vol. 30. ACM, 187â€“196.
[23]EKodhai,SKanmani,AKamatchi,RRadhika,andBVijayaSaranya.2010. Detec-
tionoftype-1andtype-2codeclonesusingtextualanalysisandmetrics.In Recent
TrendsinInformation,TelecommunicationandComputing(ITC),2010International
Conference on. IEEE, 241â€“243.
[24]Raghavan Komondoor and Susan Horwitz. 2001. Using slicing to identify du-
plication in source code. In International Static Analysis Symposium. Springer,
40â€“56.
[25]KostasAKontogiannis,RenatorDeMori,EttoreMerlo,MichaelGaller,andMorris
Bernstein.1996. Patternmatchingforcloneandconceptdetection. Automated
Software Engineering 3, 1-2 (1996), 77â€“108.
[26]Jens Krinke. 2001. Identifying similar code with program dependence graphs. In
Proceedings of Eighth Working Conference on Reverse Engineering. IEEE, 301â€“309.
[27]Zhenmin Li, Shan Lu, Suvda Myagmar, and Yuanyuan Zhou. 2006. CP-Miner:
Finding copy-paste and related bugs in large-scale software code. IEEE Transac-
tions on software Engineering 32, 3 (2006), 176â€“192.[28]ChaoLiu,ChenChen,JiaweiHan,andPhilipSYu.2006. GPLAG:detectionof
software plagiarism by program dependence graph analysis. In Proceedings of
the 12th ACM SIGKDD international conference on Knowledge discovery and data
mining. ACM, 872â€“881.
[29]Angela Lozano and Michel Wermelinger. 2008. Assessing the effect of clones on
changeability.In IEEEInternationalConferenceonSoftwareMaintenance.IEEE,
227â€“236.
[30]Jean Mayrand, Claude Leblanc, and Ettore Merlo. 1996. Experiment on the
Automatic Detection of Function Clones in a Software System Using Metrics.. In
ProceedingsoftheInternationalConferenceonSoftwareMaintenance,Vol.96.244.
[31]Shane McIntosh, Martin Poehlmann, Elmar Juergens, Audris Mockus, Bram
Adams,AhmedEHassan,BrigitteHaupt,andChristianWagner.2014. Collecting
and leveraging a benchmark of build system clones to aid in quality assess-
ments. In Companion Proceedings of the 36th International Conference on Software
Engineering. ACM, 145â€“154.
[32]Manishankar Mondal,Md SaidurRahman, RiponK Saha, ChanchalK Roy,Jens
Krinke, and Kevin A Schneider. 2011. An empirical study of the impacts ofclones in software maintenance. In Program Comprehension (ICPC), 2011 IEEE
19th International Conference on. IEEE, 242â€“245.
[33]Gonzalo Navarro. 2001. A guided tour to approximate string matching. ACM
computing surveys (CSUR) 33, 1 (2001), 31â€“88.
[34]Hoan Anh Nguyen, Tung Thanh Nguyen, Nam H Pham, Jafar Al-Kofahi, and
TienNNguyen.2012. Clonemanagementforevolvingsoftware. IEEEtransactions
on software engineering 38, 5 (2012), 1008â€“1026.
[35]VernPaxson.2016. Flexâ€“fastlexicalanalyzergenerator. (2016). https://github.
com/westes/flex/
[36]A Perumal, S Kanmani, and E Kodhai. 2010. Extracting the similarity in detected
softwareclonesusingmetrics.In ProceedingsoftheInternationalConferenceon
Computer and Communication Technology. IEEE, 575â€“579.
[37]FoyzurRahman,ChristianBird,andPremkumarDevanbu.2012. Clones:Whatis
that smell? Empirical Software Engineering 17, 4-5 (2012), 503â€“530.
[38]Dhavleesh Rattan, Rajesh Bhatia, and Maninder Singh. 2013. Software clone
detection:Asystematicreview. InformationandSoftwareTechnology 55,7(2013),
1165â€“1199.
[39]Chanchal Kumar Roy and James R Cordy. 2007. A survey on software clone
detection research. Queenâ€™s School of Computing TR 541, 115 (2007), 64â€“68.
[40]ChanchalKRoyandJamesRCordy.2008. NICAD:Accuratedetectionofnear-
miss intentional clones using flexible pretty-printing and code normalization. In
Proceedings of the IEEE 16th International Conference on Program Comprehension.
IEEE, 172â€“181.
[41]ChanchalKRoyandJamesRCordy.2009. Amutation/injection-basedautomatic
framework for evaluating code clone detection tools. In Proceedings of the Inter-
national Conference on Software Testing, Verification and Validation Workshops.
IEEE, 157â€“166.
[42]Chanchal K Roy and James R Cordy. 2010. Near-miss function clones in open
sourcesoftware:anempiricalstudy. JournalofSoftware:EvolutionandProcess
22, 3 (2010), 165â€“189.
[43]Chanchal K Roy, Minhaz F Zibran, and Rainer Koschke. 2014. The vision of
softwareclonemanagement:Past,present,andfuture(keynotepaper).In Pro-
ceedingsoftheSoftwareEvolutionWeek-IEEEConferenceonSoftwareMaintenance,
Reengineering and Reverse Engineering. IEEE, 18â€“33.
[44]Julia Rubin and Marsha Chechik. 2013. A framework for managing cloned
product variants. In Proceedings of the 2013 International Conference on Software
Engineering. IEEE Press, 1233â€“1236.
[45]Hitesh Sajnani, Vaibhav Saini, Jeffrey Svajlenko, Chanchal K Roy, and Cristina V
Lopes.2016. SourcererCC:scalingcodeclonedetectiontobig-code.In Proceedings
of the 38th International Conference on Software Engineering. ACM, 1157â€“1168.
[46]Jeffrey Svajlenko, Judith F Islam, Iman Keivanloo, Chanchal K Roy, and Moham-
mad Mamun Mia. 2014. Towards a big data curated benchmark of inter-project
code clones. In Proceedings of the International Conference on Software Mainte-
nance and Evolution. IEEE, 476â€“480.
[47]JeffreySvajlenkoandChanchalK.Roy.2014. EvaluatingModernCloneDetec-
tionTools.In Proceedingsofthe2014IEEEInternationalConferenceonSoftware
Maintenance and Evolution (ICSME â€™14). IEEE Computer Society, Washington,
DC, USA, 321â€“330.
[48]Jeffrey Svajlenko and Chanchal K Roy. 2015. Evaluating clone detection tools
with bigclonebench. In Proceedings of the International Conference on Software
Maintenance and Evolution. IEEE, 131â€“140.
[49]J. Svajlenko and C. K. Roy. 2016. BigCloneEval: A Clone Detection Tool Evalua-
tionFrameworkwithBigCloneBench.In 2016IEEEInternationalConferenceon
Software Maintenance and Evolution (ICSME). 596â€“600.
[50]JeffreySvajlenko,ChanchalKRoy,andJamesRCordy.2013. Amutationanalysis
based benchmarking framework for clone detectors. In Proceedings of the 7th
International Workshop on Software Clones. IEEE, 8â€“9.
[51]Suresh Thummalapenta, Luigi Cerulo, Lerina Aversano, and Massimiliano
Di Penta.2010. Anempirical study onthe maintenanceof source codeclones.
Empirical Software Engineering 15, 1 (2010), 1â€“34.
1076
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. ICSE â€™18, May 27-June 3, 2018, Gothenburg, Sweden P. Wang, J. Svajlenko, Y. Wu, Y. Xu, and C. K. Roy
[52]Nikolaos Tsantalis, Davood Mazinanian, and Shahriar Rostami. 2017. Clone
refactoring with lambda expressions. In Proceedings of the 39th International
Conference on Software Engineering. IEEE Press, 60â€“70.
[53]ZhaopengTu,ZhendongSu,andPremkumarDevanbu.2014. Onthelocalness
ofsoftware.In Proceedingsofthe22ndACMSIGSOFTInternationalSymposiumon
Foundations of Software Engineering. ACM, 269â€“280.
[54]Yasushi Ueda, Toshihiro Kamiya, Shinji Kusumoto, and Katsuro Inoue. 2002. On
detection of gapped code clones using gap locations. In Software Engineering
Conference Ninth Asia-Pacific. IEEE, 327â€“336.
[55]Tiantian Wang, Mark Harman, Yue Jia, and Jens Krinke. 2013. Searching for
better configurations: a rigorous approach to clone evaluation. In Proceedings of
the20139thJointMeetingonFoundationsofSoftwareEngineering.ACM,455â€“465.
[56]MartinWhite,MicheleTufano,ChristopherVendome,andDenysPoshyvanyk.
2016. Deeplearningcodefragmentsforcodeclonedetection.In Proceedingsof
the 31st IEEE/ACM International Conference on Automated SoftwareEngineering.
ACM, 87â€“98.
[57]TianyiZhangandMiryungKim.2017.Automatedtransplantationanddifferential
testing for clones. In Proceedings of the 39th International Conference on Software
Engineering. IEEE Press, 665â€“676.
1077
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:57:25 UTC from IEEE Xplore.  Restrictions apply. 