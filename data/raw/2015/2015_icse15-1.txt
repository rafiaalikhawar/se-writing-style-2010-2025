DirectFix: Looking for Simple Program Repairs
Sergey Mechtaev, Jooyong Yi and Abhik Roychoudhury
National University of Singapore
{mechtaev,jooyong,abhik}@comp.nus.edu.sg
Abstract ‚ÄîRecent advances in program repair techniques have
raised the possibility of patching bugs automatically. For an
automatically generated patch to be accepted by developers, it
should not only resolve the bug but also satisfy certain human-
related factors including readability and comprehensibility. In
this paper, we focus on the simplicity of patches (the size of
changes). We present a novel semantics-based repair method that
generates the simplest patch such that the program structure of
the buggy program is maximally preserved. To take into account
the simplicity of repairs in an efÔ¨Åcient way ( i.e., without explicitly
enumerating each repair candidate for each fault location),
our method fuses fault localization and repair generation into
one step. We do so by leveraging partial MaxSAT constraint
solving and component-based program synthesis. We compare
our prototype implementation, DirectFix, with the state-of-the-
art semantics-based repair tool SemFix, that performs fault
localization before repair generation. In our experiments with
SIR programs and GNU Coreutils, DirectFix generates repairs
that are simpler than those generated by SemFix. Since both
DirectFix and SemFix are test-driven repair tools, they can
introduce regressions for other tests which do not drive the repair.
We found that DirectFix causes substantially less regression
errors than SemFix.
I. I NTRODUCTION
Simple is better! When repairing a program, it is preferable
to construct patches which are simple and readable. This is
because responsible software maintainers would not blindly
accept a suggested patch; rather, they would review and inspect
a patch carefully before accepting it [1], [2] ‚Äì which occurs
only if they judge that the patch is correct (i.e., the bug
is resolved) and safe (i.e., no new bug is induced). They
would also modify the patch and add more tests, if necessary.
Thus, simple and small patches would be more easily accepted
by maintainers than more complex alternatives. The ease of
acceptance, as well as abundance of small/simple patches are
conÔ¨Årmed by the studies of [3], [4]. Hence it is instructive
to have program repair tools produce small patches. To the
best of our knowledge, existing automatic repair tools such
as GenProg [5], SemFix [6] and PAR [7] do not explicitly
take into account of the simplicity of a patch while generating
patches, although more general issues about patch quality
(e.g., patch maintainability [8] and users‚Äô willingness to accept
patches [7]) have been raised and studied in recent years.
Finding a simple repair (we use ‚Äúrepair‚Äù and ‚Äúpatch‚Äù inter-
changeably) is not necessarily simple. In fact, it is challenging
to Ô¨Ånd the simplest (or a simple enough) repair among many
possible repairs, without enumerating each repair. Note that
even for Ô¨Ånding one repair, existing repair tools often take
substantial amount of time. We propose in this paper an
efÔ¨Åcient test-driven repair method (and its implementationDirectFix) that can Ô¨Ånd simple repairs. Our repair method is
test-driven as in GenProg, SemFix and many other existing
repair methods. Our key observation is that the simplicity of
a repair is inÔ¨Çuenced by the choice of the program location
that is modiÔ¨Åed in a repair. If unsuitable program locations
are chosen to be modiÔ¨Åed, the corresponding repair is also
likely to be suboptimal (meaning unduly complex repairs).
In the next section, we show examples of such unnecessarily
complex repairs.
Existing test-driven repair methods rely on statistical fault
localization [9]‚Äì[11] to choose program locations to modify
(often called fault locations in the literature [12]). In general,
fault locations are selected in proportion to their suspicious-
ness scores. High suspiciousness scores are assigned to the
program locations that execute more frequently in failing tests.
However, the simplicity of repairs is not a part of suspicious
score equations, and thus these scores have no direct relation-
ship with how simple a repair is. To include the simplicity of
repairs into the logic of choosing fault locations, we perform
fault localization and repair generation simultaneously in a
combined manner.
The main intuition behind our approach is to (a) fuse
the fault localization and repair steps into a single step via
partial MaxSAT solving, (b) ensure that the resultant fused
method still remains scalable by using the buggy program as
a reference - we choose repairs which will cause minimal
changes to the buggy program.
Themain technical contribution of this paper is to integrate
fault localization and repair generation in an efÔ¨Åcient way ‚Äì
without explicitly enumerating each repair candidate for each
fault location. We achieve this by reducing the problem of
program repair into an instance of the Maximum SatisÔ¨Åability
problem (more speciÔ¨Åcally, a Partial MaxSMT problem). For
a given buggy program and a test suite, we formulate a logical
formula in a way that a model (satisÔ¨Åable assignment) of this
formula is the simplest repair ‚Äì simplest in the sense that the
structure of the original buggy program is preserved as much
as possible. While the nature of MaxSMT allows removing
existing expressions of a buggy program (our simple repairs
are suggested at the expression level), we can replace those
removed expressions with new ones by using component-
based program synthesis [13]. We implement our approach
into a tool, DirectFix, that formulates a necessary formula and
solves it using our Partial MaxSMT solver implemented on top
of Z3 SMT solver [14]. We also evaluate our tool on in total
98 buggy versions of SIR programs and 9 real bugs of GNU
Coreutils, which exemplify the mistakes programmers can1x = E1; / / E1 represents an expression.
2y = E2; / / E2 represents an expression.
3S1; / / S1 represents a statement. Neither x nor y is redeÔ¨Åned by S1.
4 i f(x>y) / / FAULT: the conditional should be x >= y
5 return 0;
6else
7 return 1;
(a) A buggy program snippet; a bug is in line 4.
1x = E1; y = E2;
2if(x==y){S1;return 0;} / / This line is one possible repair.
3S1;
4 i f (x > y)
5 return 0;
6else
7 return 1;
(b) A repair that resembles a GenProg repair
1x = E1;
2y = E2;
3S1;
4 i f(x>=y) / / SIMPLE FIX: >=is substituted for >
5 return 0;
6else
7 return 1;
(c) An alternative simpler repair; an operator is replaced.
Fig. 1. The Ô¨Årst motivating example
often make. Despite the limited size of our subject programs
and tool limitations inherited from the underlying tools upon
which DirectFix is built ‚Äì most notably, VCC [15], which
transforms a C program into a logical formula, currently
cannot handle Ô¨Çoating point arithmetic; in such cases, we
designated the (transformable) suspicious functions, assuming
that developers have insight about potential buggy functions
‚Äì, the overall experimental results are promising. DirectFix
suggests repairs successfully 59% of the time. Moreover, 56%
of those repairs are equivalent to the ground truth repairs, and
89% of them alter the same program line(s) as the ground
truth versions. Such Ô¨Ågures are signiÔ¨Åcantly higher than when
SemFix [6] is applied to the same subjects with the same test
suites and the same information about suspicious functions
(i.e., more than 3 times of equivalent repairs and more than 2
times of same-line repairs). Recall that SemFix performs fault
localization and repair as separate steps, and does not consider
the simplicity of the repairs. We also found in our experiments
that DirectFix repairs cause regression errors (when checked
against the test universe and not just the test-suite driving the
repair) less frequently than SemFix repairs.
II. M OTIVATING EXAMPLES
We present three simple yet motivating examples in this
section (in Section VII, we also present our repairs for actual
programs). Consider the program snippet in Fig. 1(a). This
program is supposed to return 0ifx >= y holds at the end of the
program; otherwise, it should return 1. However, the developer
of this program made a small mistake of not considering a
case of x==y . Here, Fig. 1(b) and 1(c) show two different
valid repairs. Notice that the former repair is more complicated
than the latter one. Most developers would prefer the second
simpler repair. To the best of our knowledge, existing repair1 i f(x>y) / / FAULT 1: the conditional should be x >= z
2 i f(x>z) / / FAULT 2: the conditional should be x >= y
3 out = 10;
4 else
5 out = 20;
6else out = 30;
7 return out ;
(a) A buggy program snippet; bugs are in line 1 and 2.
1 i f (x > y)
2 i f (x > z)
3 out = 10;
4 else
5 out = 20;
6else out = 30;
7 return ((x>=z)? ((x>=y)? 10:20):30); / / This line is one possible repair.
(b) A repair that resembles a SemFix repair
1 i f(x>=z) / / SIMPLE FIX: >=zis substituted for >y
2 i f(x>=y) / / SIMPLE FIX: >=yis substituted for >z
3 out = 10;
4 else
5 out = 20;
6else out = 30;
7 return out ;
(c) An alternative simpler repair; operators and variables are replaced.
Fig. 2. The second motivating example
tools do not take account of how simple a repair is. They
stop looking for a repair once one is found, no matter how
complex that repair is. Indeed, a repair in Fig. 1(b) resembles
a repair generated by GenProg [5]. GenProg grafts existing
code onto a buggy program in an attempt of repair. As a
result, GenProg often generates repairs that look nonsensical
to human developers, as pointed out in [7].
Meanwhile, a more recent repair tool, SemFix [6], seems
to generate simpler repairs than GenProg (user-studies are
yet to be conducted to fully validate this, but intuitively this
is so because SemFix [6] performs repair at the expression
level, unlike GenProg that performs repair at the statement
level). However, SemFix still often generates repairs that are
more complex than necessary. Fig. 2 shows such an example.
Given a buggy program in Fig. 2(a) ‚Äì the Ô¨Årst two lines are
mistakenly swapped, and the equal signs (=) are omitted ‚Äì,
SemFix can generate a repair shown in Fig. 2(b). Compare
this repair with an alternative repair shown in Fig. 2(c). The
latter repair is simpler despite that it modiÔ¨Åes two lines of a
program (SemFix cannot modify multiple lines). These two
examples also show that a buggy program can be repaired in
multiple ways producing repairs of varying simplicity.
There is one more important reason for selecting a repair
carefully: the reliability of a repaired program (the likelihood
that the repaired program not only resolves bugs in the given
test-suite, but also does not introduce new bugs shown by tests
outside the test-suite) varies depending on a selected repair.
Consider a buggy program in Fig. 3(a) that checks whether the
character cis included in the string (character array) s. The
table in Fig. 3(b) shows the expected and actual input/output
relationship. The Ô¨Årst test fails because all the characters of
string sare not scanned while looking for the same character
as the one in c. Notice in the table that variable kdoes not1 / /FAULT: k is NOT equal to the length of array s.
2 for ( i =0; i<k; i ++)
3 i f (s[ i ] == c) return TRUE;
4 return FALSE;
(a) A buggy program that checks if the character cis included in string s.
Input Output
s c k expected actual
"ab?" ‚Äô?‚Äô 2 TRUE FALSE
"ab?c" ‚Äô?‚Äô 3 TRUE TRUE
"!ab" ‚Äô!‚Äô 2 TRUE TRUE
(b) Expected input and output
1 for ( i =0; i <k; i ++)
2 / /The following line is one possible repair.
3 i f(c==‚Äô?‚Äô ||c==‚Äô!‚Äô) return TRUE;
4 return FALSE;
(c) A (buggy) repair that passes the above tests
1 for ( i =0; i<=k; i ++) / / SIMPLE FIX: <=is substituted for <
2 i f (s[ i ] == c) return TRUE;
3 return FALSE;
(d) A more reliable repair
Fig. 3. The third motivating example
hold the value of the length of s, it holds a value one less
than the length. As before, more than one repair exist for this
buggy program. Fig. 3(c) and 3(d) show two possible repairs
‚Äì both repairs pass all the tests in Fig. 3(b). However, the Ô¨Årst
repair (Fig. 3(c)) looks hazardous. What if a character other
than‚Äô?‚Äô or‚Äô!‚Äô is searched for? While such potential hazard
of a repair can be diminished by choosing a right test suite,
what is a right test suite is another important research question
that has not been thoroughly addressed yet.
Meanwhile, the second simpler repair (Fig. 3(d)) preserves
the original correct behavior, as well as correcting the buggy
behavior. The contrast between these two repairs suggests the
following hypothesis. The rationale behind the hypothesis is
that simpler repairs are likely to modify the behavior of a
program in a more restricted fashion.
Hypothesis. Simple repairs are less likely to change the
correct behavior of the original version than more complex
repairs. Thus, simple repairs are likely to be less hazardous.
Existing test-driven program repair tools perform fault lo-
calization upfront, and search for a repair around the program
locations marked suspicious at the fault localization phase.
Therefore, a straightforward way to Ô¨Ånd the simplest repair
is to iteratively generate a repair at each combination of
suspicious program locations, and select the simplest repair.
However, it is apparent that this straightforward approach
would not scale, considering the fact that even Ô¨Ånding a single
repair often takes substantial amount of time. To Ô¨Ånd simple
repairs more efÔ¨Åciently (without explicitly enumerating each
repair candidate), we integrate the two phases of program
repair ‚Äì (i) fault localization and (ii) repair search ‚Äì into a
single step.III. B ACKGROUND
DirectFix is a semantics-based program repair approach that
exploits recent advances of SMT solvers. It reduces repair
problem to Maximum SatisÔ¨Åability problem. Particularly, this
approach constructs a logical formula, a solution to which
corresponds to a Ô¨Åx. Our encoding is based on Component-
based Synthesis [13] extended to produce syntactically mini-
mal changes as well as to improve scalability.
A. Preliminaries
The SatisÔ¨Åability problem in propositional logic (SAT) is
the problem of determining whether a given formula 'has a
model. Maximum SatisÔ¨Åability (MaxSAT) is a generalization
of SAT whose goal is to Ô¨Ånd the maximum number of clauses
of a given formula that can be satisÔ¨Åed. SatisÔ¨Åability Modulo
Theories (SMT) is a satisÔ¨Åability problem with respect to
given background theories. MaxSMT is a generalization of
MaxSAT on SMT. Partial Maximum SatisÔ¨Åability (pMaxSAT)
for a set of soft clause sand a set of hard clauses his a
problem of Ô¨Ånding the maximum subset smax of clausess
such thatsmax^his satisÔ¨Åable. pMaxSMT is a generalization
of pMaxSAT on SMT.
DirectFix utilizes program semantics expressed through a
logical formula called trace formula in the literature [16], [17].
DeÔ¨Ånition 1 (Trace Formula) .A trace formula TF of a
deterministic program Pis a logical formula that satisÔ¨Åes the
following property. Given the input Iof program P,
TF(I;O)is(
satisÔ¨Åable if the output of PisO
unsatisÔ¨Åable if the output of Pis notO
where TF(I;O)denotes the trace formula TFwhose input
variable is bound with I, and output variable with O.
B. Component-based Synthesis [13]
Expressions and, in general, programs that satisfy
given requirements can be generated automatically through
Component-based Synthesis [13] (CBS). Here we present the
original CBS technique, our extensions and optimizations are
given in Section V .
DeÔ¨Ånition 2. Letvbe a variable, Vbe a set of variables such
thatv =2V,Fbe a set of operators, Obe a constraint over
fvg[Vcalled oracle. Component-based Synthesis ( v,V,F,
O) is a problem of Ô¨Ånding an expression esuch that
eis constructed using a subset components C=V[F
and constants;
O^(v=e)is satisÔ¨Åable.
This approach constructs expressions by connecting primi-
tive building blocks called components with each other. Com-
ponents could be constants or variables or operators. The cor-
rect linkage between components is determined using an SMT
solver. SpeciÔ¨Åcally, semantics of components, semantics of the
connections between them as well as the oracle constraint are
used to construct an SMT formula which we call Component-
based Encoding (CBE).yout
xy>>in
2 >out
>in
1
0xout
1 2L(>out) = 2
L(>in
1) = 0
L(>in
2) = 1
L(xout) = 0
L(yout) = 1
L(vin) = 2
Fig. 4. The inputs and output of the components of expression x > y are
allocated in the interval [0;3). The output is bound by the variable v.
The idea of CBE is to consider expressions as circuits.
Each component has a set of inputs and an output. Then, to
synthesize desired expression, the solver needs to Ô¨Ånd the right
connections between components inputs and outputs. In order
to capture information about connections, for each input and
output, a numeric variable called location variable is deÔ¨Åned.
The meaning of location is straightforward: an input and an
output are connected iff they have the same location.
CBE deÔ¨Ånes relationship between values and locations of
components‚Äô inputs and outputs. For each input and output,
we introduce a variable that corresponds to its value. We use
the following notation: for component c, the variable cout
corresponds to the value of its output, the variable cin
kis the
value of its k-th input. We indicate the number of inputs of
casNI(c). We denote location variables using the function
L. For example, the location variable of the Ô¨Årst input of
the component cisL(cin
1). Fig. 4 demonstrates an example
of an assignment of locations variables. The components of
the expression x > y are allocated within the interval [0;3).
The output of the variable xhas location 0, the output of the
variableyhas location 1, and the output of the operator >is
located at 2. The Ô¨Årst input of >is linked tox, the second input
of>is linked to y. Assume that the output of the expression
is bound by the variable v, that isv=x > y . The output
of the circuit is marked by the bullet and is indicated by the
constraintL(vin) = 2 . The expression x>y can be trivially
reconstructed using the values of the location variables. We
assume that there is a function Lval2Prog that builds an
expression from an assignment of location variables.
CBE consists of three types of constraints: well-formedness
constraints ,semantics constraints andconnections constraints .
Well-formedness constraints ( wpf) restrict location variables
so that any satisfying assignment to these variables corre-
sponds to an expression of a valid structure. These constraints
include range constraints ( range) that allocate all components
inputs and outputs within a range, consistency constraints
(cons) that ensure that the output of each component has
unique location, and acyclicity constraints ( acyc) that forbid
cyclic connections.
wpfdef=range^cons^acyc
rangedef=^
c2fvg[C 
0L(cout)<jCj^^
k2[1::NI(c)]0L(cin
k)<jCjconsdef=^
(c;s)2CC;c6=sL(cout)6=L(sout)
acycdef=^
c2C;k2[1::NI(c)]L(cout)>L(cin
k)
Semantics constraints ( lib) are deÔ¨Åned for each compo-
nent. They specify the semantics of the component as the
relations between its inputs and output. For example, semantics
constraint for the component ccorresponding to the addition
operation is deÔ¨Åned as cout=cin
1+cin
2. Semantics constraints
for a component ccorresponding to a variable xis deÔ¨Åned as
cout=x. Similarly, the semantics constraint for a component
ccorresponding to a constant aiscout=a.
Connections constraints ( conn) capture the semantics of an
expression to be synthesized through the semantics of the
components and the connections between them.
conndef=^
(c;s)2Cfvg[C
k2[1::NI(s)]L(cout) =L(sin
k))cout=sin
k
Theorem 1. Letvbe a variable, Vbe a set of variables such
thatv =2V,Fbe a set of integer operators, Ois a constraint
overfvg[V.=wpf^lib^conn^O is a Component-
based Encoding, that is Lval2Prog produces a solution to
the Component-based Synthesis problem ( v,V,F,O) taking
as inputv,C=V[Fand any model of as an assignment
of the location variables.
Described CBE is only suitable for representing oracle
corresponding to a single test case. Indeed, if we conjoin
input-output constraints for different test cases, the formula
is trivially unsatisÔ¨Åable. To extend this encoding for several
test cases, we rename variables in the encoding formula so
that each test case uses unique variables names. Then, the
formula that captures all given input-output relationships is a
conjunction of renamed formulas for each test case.
IV. O VERVIEW OF OUR APPROACH
To Ô¨Ånd a repair, we Ô¨Årst translate a given buggy program
into a trace formula. For example, Fig. 5(b) demonstrates the
trace formula for the function fooshown in Fig. 5(a). This
function is buggy, and its test test_foo fails (we use a single
test in this example for simplicity). The given test is translated
into the following oracle constraint:
Odef= (x1= 0)^(y1= 0)^(result = 3)
The conjunction 'buggy^O is unsatisÔ¨Åable, reÔ¨Çecting the fact
that the test fails.1
Our goal is to Ô¨Ånd which expressions of 'buggy need to
be modiÔ¨Åed and how they should be modiÔ¨Åed, so that this
modiÔ¨Åed formula 'repair makes'repair^O satisÔ¨Åable. In our
example, the ground truth repair is as follows:
1If there are multiple tests, say two, we formulate Rename ('buggy^O1)^
Rename ('buggy^O 2), where function Rename returns the input formula
after replacing its variables with fresh variables.1 int foo( int x, int y) {
2 i f(x>y) / / FAULT: the conditional should be x >= y
3 y = y + 1;
4 else
5 y = y 1;
6 return y + 2;
7 }
8
9void test_foo () { assert (foo(0,0)==3); }
(a) A buggy function and its test
'buggy(if(x1>y1)then(y2=y1+1) else(y2=y1 1))
^(result =y2+ 2)
(b) The trace formula 'buggy forfoo; variables xiandyicorrespond to the
program variables x and y, respectively, and result to the return value of the
program
Fig. 5. A trace formula is constructed from a buggy program and its tests
'repairdef= (if(x1y1)then(y2=y1+1) else(y2=y1 1))
^(result =y2+ 2)
Essentially, our repair method views a program as a circuit.
To generate a Ô¨Åx, it (i) cuts some of the existing connections
and (ii) adds new components and connections. To obtain
the simplest (the least destructive) repair, we want to cut as
few connections as possible. We achieve this by reducing the
problem of program repair into an instance of the maximum
satisÔ¨Åability (MaxSAT) problem ‚Äì more speciÔ¨Åcally, a partial
MaxSMT (pMaxSMT) problem.
To generate a repair based on pMaxSMT, we construct a
formula that we call repair condition . Given a trace formula
'buggy, the repair condition 'rcis the following:
'rcdef= (ifv1then(y2=v2)else(y2=v3))^(result =v4)
^cmpnt (v1=x1>y1)^cmpnt (v2=y1+ 1)
^cmpnt (v3=y1 1)^cmpnt (v4=y2+ 2)
The above formula 'rcis semantically identical with 'buggy.
The only difference is that we substitute fresh variables vifor
the rvalue expressions of 'buggy, while keeping the equality
relationship between each viand the expression it represents
(e.g.,v1=x1>y1) inside the cmpnt function. This function
componentizes its parameter expression into a circuit form,
following the idea of Component-based Synthesis.
To obtain the simplest (the least destructive) repair, we use
a pMaxSMT solver. In pMaxSMT, a formula is split into
(i) hard clauses (clauses that must be satisÔ¨Åed) and (ii) soft
clauses (clauses that do not have to be satisÔ¨Åed). In hard
clauses, we include the clauses that express the semantics
of the component and the oracle data. Meanwhile, with soft
clauses, we constrain the structure of the program expressions.
For example, we construct the structure constraint for the
expression x>y as follows, which is essentially equivalent to
the circuit diagram in Fig. 4:
L(>in
1)=L(xout)^L(>in
2)=L(yout)^L(>out)=L(vin)
In the above constraint, we bind the output of the expression
with a fresh variable v, that isv=x > y . As shown, thisyout
xy>>in
2 >out
>in
1>in
2
out
in
1xout
0 1 2 3
Fig. 6. Repairing expression x > y by replacing >with.
constraint speciÔ¨Åes the connections between the components
of the expression as well as its output binding. After splitting
'rc^Ointo hard clauses and soft clauses as described above,
we feed'rc^O into a pMaxSMT solver. Then, the solver
removes some structure constraints (if necessary), and returns
a model corresponding to a Ô¨Åx.
Fig. 6 shows how a solver can modify the expression
x>y using an additional component in order to repair the
program. SpeciÔ¨Åcally, it removes one connection between the
outputs of>and the input of vcorresponding to the structure
constraintL(>out) =L(vin), and adds three new connections:
(i) between the output of xand the Ô¨Årst input of , (ii) between
the output of yand the second input of , and (iii) between the
output ofand the binding variable v. Such new connections
are obtained by using a model for the repair condition, namely,
the values of the location variables.
We note that by looking for a model that maximizes the
number of satisÔ¨Åed clauses of 'rc^O, we effectively cut and
add connections simultaneously. In other words, we perform
fault localization and repair generation at the same time.
V. M ETHODOLOGY
While automated program repair has been shown to be
effective, automatically generated patches can damage the
structure of the original program and introduce regressions.
To address this problem, we devise an approach that searches
for syntactically minimal Ô¨Åxes. Our approach combines fault
localization and correction into a single step, which is achieved
by reducing repair problem to Partial Maximum SatisÔ¨Åability
Problem. Our pMaxSMT encoding is based on Component-
based Synthesis encoding extended to capture the structure of
the original program as well as to tackle scalability problems.
A. Repair Problem and Repair Condition
Unlike in CBS, our goal is to modify the existing expres-
sions of a buggy program in a way that changed expressions
make all tests pass. For this reason, we modify the synthesis
problem (DeÔ¨Ånition 2) into the following repair problem.
DeÔ¨Ånition 3 (Repair Problem) .Letvbe a variable, Vbe
a set of variables such that v =2V,Fbe a set of integer
operators,Obe a constraint over fvg[Vcalled oracle. Let e
be a possibly faulty expression constructed using a subset of
components C=V[Fand constants such that O^(v=e)isnot satisÔ¨Åable. Repair problem (v;e;V;F;O)is a problem of
Ô¨Ånding a repaired expression e0such that
e0is constructed using a subset of components C=V[F
and constants.
O^(v=e0)is satisÔ¨Åable.
To solve a repair problem, we construct a logical formula
which we call repair condition that consists of two groups of
clauses: hard clauses and soft clauses. Algorithm 1 describes
how we generate a repair condition, given a test suite TSand
a trace formula TFas input. Our algorithm substitutes fresh
variablesvifor the rvalue expressions (the expressions of TF
that are originated from the conditionals or right-hand-side ex-
pressions of a given buggy program2) to construct the formula
TF[ei7!vi]. The formula TF[ei7!vi]^(V
ivi=ei)is seman-
tically equivalent to the initial trace formula TF. However,
expressions eithat we allow to modify are now distinguished
from the rest of the formula. Algorithm 1 applies CBE to all
the components of xi=eitogether with additional component,
and the formula (V
iCBE (vi=ei))^TF(I;O)[ei7!vi]is
returned as hard clauses of the repair condition for each test
case (I;O)2TS.
Meanwhile, we also extract the structure constraint struct
of each binding vi=ei, and classify structas a soft clause.
The structure constraint of vi=eiencodes the structure of
expression eiusing location variables. It also encodes the
binding of eitoviusing location variables. In the previous
section, we showed that expression x>y is encoded into the
following structure constraint struct:
structdef=L(>in
1)=L(xout)^L(>in
2)=L(yout)^L(>out)=L(vin);
wherevis a fresh binding variable. The structure con-
straint is obtained via the inverse function of Lval2Prog
(Lval2Prog is a bijective function [13]).
Once a repair condition is obtained through Algorithm 1,
we feed this repair condition to a pMaxSMT solver. If the
solver Ô¨Ånds a model, this model can be used to construct a
repair expression using Lval2Prog introduced in Section III.
Note that a pMaxSMT solver preserves as many original con-
nections as possible, which guarantees that DirectFix changes
the minimal number of program expressions, as formally
described below.
DeÔ¨Ånition 4 (Simplicity of repair) .LetPbe a program, TS
be a test suite with at least one failing test case, eibe a subset
of the expressions of P,Cbe a set of components. We call P0
asimple repair ofPif
P0passes TS;
P0can be obtained from Pby substituting some of the
subexpressions of eiwith expressions constructed from
the components C;
there is no program that passes TSand can be obtained
fromPusing a smaller number of such substitutions.
2The expressions of our TF are annotated with source code locations.Algorithm 1 Repair condition generation
Input: trace formula TF and test suite TS
Output: repair condition as a pair of hard and soft constraints
1:Hard;Soft True;True // Hard and soft clauses
2:Expr fejeis a rvalue expression of TFg
3:fortest case (I;O)2TSdo
4: fore2Expr do
5:v a fresh variable
6:C0 select additional component for e
7: TF(I;O) TF(I;O)[e7!v]// replaceewithv
8: CBE for components of eand components C0
9:struct structural constraints for v=e
10: Hard Hard^
11: Soft Soft^struct
12: end for
13: // To be able to bound a variable with a different value
14: // in each test, we call function R ENAME .
15: Hard RENAME (Hard^TF(I;O))
16: Soft RENAME (Soft)
17:end for
18:return Hard;Soft
B. Optimization
The use of soft constraints reduces synthesis time. Our
experiments demonstrate that a pMaxSMT solver implemented
on top of an SMT solver can Ô¨Ånd a solution for a formula with
soft constraints for some of the considered benchmarks, while
the SMT solver for the same formula without soft constraints
does not terminate within the timeout for all the benchmarks.
This fact suggests that the use of the structure of the previous
(buggy) versions improves synthesis performance.
For repairing some bugs, it is not sufÔ¨Åcient to use only
components that are already present in the buggy expres-
sions. For such cases, we select additional components for
each expression in the program. Selecting many additional
components makes this approach not scalable. To address this
limitation, we devise optimizations and heuristics that reduce
the negative effect of additional components.
1) Sharing components: Selecting additional components
for program expressions can signiÔ¨Åcantly increase the search
space for repair, which harms the scalability of the approach.
For instance, if there are 10 program expressions and 10
program variables that we consider as additional components,
then selecting each variable for each expression yields 100
variants to choose a single variable for repairing one of the
expressions. However, proceeding on the assumption that the
program is correct with the exception of a small part, we
do not consider each component for each of the program
expressions. Instead, additional components can be shared by
several expressions. For instance, a variable can be shared by
all the expressions from its scope.
The original CBE does not allow to share components
between several expressions; in the original CBE, each ex-
pression has a Ô¨Åxed interval for allocating components and,
consequently, a Ô¨Åxed set of available components. To alleviate
this limitation, we extend CBE so that components of all
the expressions are allocated in one big interval consisting
of Ô¨Çoating subintervals for each expression. in
1?
 in
2 
 out
xoutyoutaoutbout
xy>>in
2 >out
>in
1ab ++in
2 +out
+in
1
s0xout
s0+ 1s0+ 2s1aout
s1+ 1s1+ 2s1+ 3
Fig. 7. Allocating components of the expressions x > y anda+band
the additional component ‚Äú  ‚Äù on the same interval using Ô¨Çoating separators.
Cross-expression connections are forbidden.
Allocating component for all the program expressions in
one big interval requires introducing additional constraints to
prevent invalid connections between component of different
expressions. For this, we introduce a set of separator variables
fsigthat deÔ¨Åne subintervals for each expression. SpeciÔ¨Åcally,
all the components of the expression ejand the connections
between them are allowed only within the interval [sj 1;sj).
Fig. 7 shows how the expressions x > y anda+band the
additional component ‚Äú  ‚Äù can be placed using such encoding.
Note that the intervals for each expression are not Ô¨Åxed and
can be extended to add the component ‚Äú  ‚Äù. At the same time,
we forbid the connections of the component ‚Äú  ‚Äù to cross the
separator between x > y anda+bto prevent our tool from
generating expressions of invalid structure.
Assume that we generate encoding for a set of program
expressionsfeigfori2[1::N]. The following constraints
ensure that only valid connections are permitted:
rangedef=^
c2C
(i;j)=scope (c)
k2[1::NI(c)](siL(cout)<sj^siL(cin
k)<sj)
^^
i<m<j0
@(smL(cout)^^
k2[1::NI(c)]smL(cin
k))
_(L(cout)<sm^^
k2[1::NI(c)]L(cin
k)<sm)1
A
where function scope maps a component cto an interval
representing the range of program expressions where ccan be
used for repair. The Ô¨Årst line of this formula speciÔ¨Åes that each
component is allocated within the intervals of the expressions
from its scope. The second and third lines ensure that for
each separator, the inputs and the output of each component
are all placed either to the right of this separator or to the left,
implying that connections do not cross the borders between
expressions. cons,acycandconnare deÔ¨Åned in an analogous
manner to CBE, taking account of components‚Äô scopes.
Apart from components‚Äô constraints, we enforce the inter-
val consistency constraintintcons over separator variables to
ensure that the interval for each expression is well-deÔ¨Åned:
s0= 0^sN=jCj^^
[(i;j)ji;j2[0::N]; i<j ]si<sj
whereCis the set of all available components.Test suite

Buggy
C program//VCC,
Boogietrace formula//RC
generator
RC (repair condition)
pMaxSMT
solvermodel//Post
processor

Repair
Fig. 8. The workÔ¨Çow of DirectFix
2) Typed-based space reduction: If the program to be cor-
rected is statically typed, it is possible to use type information
to reduce the search space for repair. We implement heuristics
for the repair encoding that reduce the number of possible
connections, the number of components and the number of
candidate repair locations. In order to ensure that only well-
typed expression are considered for repair, we modify the
connection constraints so that inputs can be connected only
with outputs of the same type.
Selecting a large number of additional components for
repair yields considerable performance reduction. For this
reason, we group component by their types into several levels :
constants, boolean operators, arithmetical operators, compar-
ison operators and variables. For each level, we generate
and solve a separate repair condition. Grouping additional
components by type allows us to utilize the following two
heuristics. Firstly, we can prune program expression that
cannot be repaired using additional components due to their
type. For example, the statement v=a_bcannot be
repaired using integer arithmetics components. Secondly, we
can reduce the number of connections between components
in the original program expressions. SpeciÔ¨Åcally, we do not
split an expression into subexpressions if these subexpressions
have incompatible type with the additional components and
consider whole expression as one compound component. For
example, the expression a_x>y can be split into components
a,_andx>y if we consider only boolean operators.
C. Handling Loops
For a loop, we unroll it ktimes; our trace formula guar-
antees that there is no execution paths requiring more than
kunrolling. The consequence of loop unrolling is that the
trace formula includes multiple instances of the program
expressions that are executed several times inside loops. In
order to make it possible to apply the Ô¨Åx generated by our
tool to the original program, we need to ensure that all these
expressions are modiÔ¨Åed synchronously . This is achieved by
binding components‚Äô locations of these expression through
auxiliary components called phantom components . Phantom
components do not have semantics and are used only for
binding location variables.
VI. I MPLEMENTATION
We implement the repair methodology described earlier
into a prototype tool, DirectFix. The overall workÔ¨Çow ofTABLE I
SUBJECT PROGRAMS
Subject LOC #Versions Description
Tcas 135 41 Air trafÔ¨Åc control program
Replace 518 30 Text processor
Schedule 304 9 Process scheduler
Schedule2 262 9 Process scheduler
Coreutils 107 ‚Äì 2909 9 Collection of OS utilities
DirectFix is shown in Fig. 8. To obtain a trace formula from
a buggy program, we use two third-party tools, VCC [15]
and Boogie [18]. VCC translates a C program into a Boogie
program. Subsequently, the Boogie veriÔ¨Åer takes as input a
Boogie program, and generates a veriÔ¨Åcation condition ‚Äì a
formula used to prove the absence of an error. Both VCC and
Boogie can handle pointer arithmetics.
A veriÔ¨Åcation condition generated from Boogie is very
similar to a trace formula we need. The following shows the
veriÔ¨Åcation condition 'vcof function foowe earlier showed
in Fig. 5(a):
:((if(x1>y1)then(y2=y1+ 1) else(y2=y1 1))
)(result =y2+ 2))
Notice that the trace formula 'buggy we showed in Fig. 5(b)
can be obtained by negating 'vcand replacing)with^.
Due to these subtle differences, 'buggy^ testis unsatisÔ¨Åable
as needed, while 'vc^ testis satisÔ¨Åable. We modiÔ¨Åed the
Boogie veriÔ¨Åer in order to obtain a trace formula instead of
a veriÔ¨Åcation condition. Our trace formula is in SMT-LIB2
format [19] annotated with source code locations.
The trace formula of a buggy program and its test suite
are fed into the RC (repair condition) generator of DirectFix,
which is an implementation of Algorithm 1. Subsequently, the
generated repair condition is fed into our pMaxSMT (Partial
Maximum SatisÔ¨Åability) solver we implemented on top of
Z3 [14]. Our pMaxSMT implementation is the unsat-core-
guided algorithm of Fu and Malik [20].
Finally, a model (satisÔ¨Åable assignment) found by our
pMaxSMT solver is post-processed to construct a patch.
Currently, DirectFix shows which expressions are modiÔ¨Åed
and how they are modiÔ¨Åed.
VII. E XPERIMENTAL RESULTS
In this section we present the experimental evaluation of
DirectFix. We also compare the repairs generated by DirectFix
with those generated by SemFix [6]. We ran our experiments
on Intel Core i7-2600 CPU with Ubuntu 12.04 64-bit operating
system. Table I shows our subject programs comprised of
eighty nine buggy versions of four subject programs from SIR
(Software-artifact Infrastructure Repository) [21] (the number
of versions for each subject is shown in the #Versions column)
and nine buggy versions of Coreutils reported by Cadar et
al [22]. These subjects are the same as the ones used inTABLE II
EXPERIMENTAL RESULTS
SubjectRepairs
Total Equivalent (E) Same Loc (S) Diff (D)
Tcas 36 (87%) 19 (54%) 33 (91%) 2.28
Replace 11 (37%) 9 (81%) 10 (91%) 2.54
Schedule 4 (44%) 4 (100%) 4 (100%) 2.5
Schedule2 2 (22%) 1 (50%) 2 (100%) 2
Coreutils 5 (56%) 0 (0%) 3 (60%) 2
Overall 59% 56% 89% 2.26
the SemFix paper [6]. All our subjects come also with their
correct versions, and we compare each of our repairs with its
correct versions, if a repair is found. The timeout used in our
experiments is 106milliseconds (16 minutes and 40 seconds).
For the subjects larger than Tcas, we designated the sus-
picious functions to reduce the search scope, assuming that
developers have insight about which function might be buggy;
for example, if a test fails after creating or modifying a
function foo, then a bug is probably located in fooor its callees.
For a library function whose source code is not available, we
provided a model for it.
Table II shows the results of our experiments. Overall,
59% of buggy versions are repaired by DirectFix. More
interestingly, 56% of those repairs are equivalent to the code in
the correct versions. We take a repaired version as equivalent
to its correct version when (i) the same program location is
altered by the repair, and (ii) that alternative repair expression
is logically equivalently to the corresponding expression in the
correct version. Note that some expressions (e.g., x > 0 and x
>= 1) are logically equivalent to each other, even though they
are not syntactically identical.
Table II also exhibits that 89% of the repairs suggested
by DirectFix alter the same program locations as those that
differ from the correct versions (Equivalent repairs mentioned
above are included in this category by deÔ¨Ånition). For example,
DirectFix can suggest a new magic number instead of a buggy
constant used in a buggy version. Although it is difÔ¨Åcult to
suggest the ‚Äúcorrect‚Äù magic number in the absence of formal
speciÔ¨Åcation, the Ô¨Ånding that simple replacement of a constant
have all tests passing can be a good hint about where a bug
is and what a repair should be.
As intended, our repairs are simple in most cases. To
measure how simple our repairs are, we compare the original
buggy version and a repaired version, and see how much
they differ. More speciÔ¨Åcally, we compare the ASTs (Abstract
Syntax Trees) of those two versions, and count (i) the number
of AST nodes that are deleted from the buggy version and
(ii) the number of AST nodes that are added into the repaired
version. For example, if a buggy expression x > y is repaired
into x >= y , then the counted number is two, because operator
>is deleted from the buggy version, and >=is inserted into
the repaired version.TABLE III
COMPARISON WITH SEMFIX; ESTANDS FOR EQUIVALENT , SSTANDS FOR
SAME LOC, D STANDS FOR DIFF,AND RSTANDS FOR REGRESSION
Subject TotalDirectFix SemFix
E S D R E S D R
Tcas 30 16 29 2.26 12 3 11 4.1 17
Replace 5 5 5 2.8 0 3 4 10.2 2
Schedule 4 2 4 2.5 1 1 4 8.5 3
Schedule2 2 1 2 2 1 1 2 5 2
Coreutils 4 0 3 2 - 0 0 4 -
Overall 44 53% 95% 2.31 31% 17% 46% 6.36 54%
The Diff column of Table II shows how much original buggy
versions and their repaired versions differ in terms of AST
differences described earlier. Overall, the differences between
two versions are as low as 2.26, which is close to the optimal
number 2 (the optimal number cannot be obtained sometimes
when even the simplest repair requires changes of a few lines
of a program or complicated changes).
The majority (56%) of our repairs are equivalent to ground
truth repairs, and about 90% of our repairs alter the same
program locations as ground truth repairs alter.
a) Quantitative Comparison with SemFix: We compare
our repairs with those of SemFix [6]. Similar to DirectFix,
SemFix also searches for repairs by analyzing the logical
semantics of a program, and uses component-based synthesis
to generate repairs. Further comparison between DirectFix and
SemFix is given in Section IX. The core difference between
SemFix and DirectFix is that DirectFix can search for simple
conservative repairs whereas SemFix does not consider the
simplicity of repairs. Thus, the comparison with SemFix is
a good indicator about how effective our new approach is in
terms of Ô¨Ånding simple conservative repairs. We ran SemFix
for the same subjects with the same tests as used for the
DirectFix experiment. We also provided the same information
about suspicious functions, so that only those suspicious func-
tions and their callees can be modiÔ¨Åed. Table III compares the
repairs that could be generated by both DirectFix and SemFix.
Overall, the rates of equivalent repairs and same-location
repairs are signiÔ¨Åcantly higher in DirectFix than in SemFix
(53% vs 17% and 95% vs 46%, respectively). Also, DirectFix
repairs are simpler (less complex) than SemFix repairs as
shown with Diff numbers (2.31 vs 6.36). We also compare how
frequently regression errors are observed between DirectFix
and SemFix. This is to test our hypothesis that simpler repairs
are more likely to be safer. To observe regression errors, we
apply the entire tests of our SIR subjects to repaired versions.
SIR subjects have a huge number of tests, and we use no
more than 50 tests to generate repairs in our experiments. We
classify that there is a regression error if a repaired version
produces a different output from the correct version in one ofbool Non_Crossing_Biased_Climb() {
int upward_preferred;
int upward_crossing_situation ;
bool result ;
upward_preferred = Inhibit_Biased_Climb () > Down_Separation;
i f (upward_preferred)
result = !(Own_Below_Threat()) | | ((Own_Below_Threat()) &&
( ! (Down_Separation >= ALIM ( ) ) ) ) ;
else
result = Own_Above_Threat() &&
(Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM ( ) ) ;
return result ;
}
bool Own_Below_Threat() {
return (Own_Tracked_Alt <= Other_Tracked_Alt );
}
bool Own_Above_Threat() {
return (Other_Tracked_Alt <= Own_Tracked_Alt);
}
(a) Snippet of Tcas version 10
bool Own_Below_Threat() {
/* *DirectFix: replaced <= with <. * */
return ( Own_Tracked_Alt <Other_Tracked_Alt)
}
bool Own_Above_Threat() {
/* *DirectFix: replaced <= with <. * */
return ( Other_Tracked_Alt <Own_Tracked_Alt);
}
(b) A DirectFix repair (identical with the ground truth repair)
bool Non_Crossing_Biased_Climb() {
int upward_preferred;
int upward_crossing_situation ;
bool result ;
upward_preferred = Inhibit_Biased_Climb () > Down_Separation;
i f (upward_preferred)
result = !(Own_Below_Threat()) | | ((Own_Below_Threat()) &&
/* *SemFix: replaces !(Down_Separation >= ALIM ())) with the following. * */
(!(Other_RAC <Own_Tracked_Alt) ) ) ;
else
result = Own_Above_Threat() &&
(Cur_Vertical_Sep >= MINSEP) && (Up_Separation >= ALIM ( ) ) ;
return result ;
}
(c) A SemFix repair
Fig. 9. Comparison of repairs for Tcas version 10
the entire tests. As shown in column R of Table III, regression
errors are observed less frequently in DirectFix repairs than
in SemFix repairs (31% vs 54%). This results coincides with
the high rate of equivalent repairs of DirectFix ‚Äì equivalent
repairs by deÔ¨Ånition do not cause a regression error. However,
DirectFix is slower than SemFix. For Tcas, for which we do
not designate suspicious functions, DirectFix took an average
of 3 minutes 20 seconds, while SemFix took an average of
9 seconds. For other benchmarks subjects where only speciÔ¨Åc
functions are allowed to be modiÔ¨Åed, we perform repair on the
unit level by reducing programs to only these functions as well
as their dependencies. These reduced programs were given to
both tools for fair comparison, after which both DirectFix and
SemFix took less than a minute.
b) Qualitative Comparison with SemFix: Lastly, we pro-
vide a couple of concrete examples of repairs generated by
DirectFix and SemFix. Fig. 9(b) shows a DirectFix repair
from Tcas (buggy) version 10. Despite that two program
locations are modiÔ¨Åed, the overall repair is simple; only two
operators are replaced. This repair is identical with the groundbool locate(character c, char*pat , int offset ) {
int i ; bool flag = false ;
i = offset + pat [ offset ] ;
while ( i > offset )
i f (c == pat [ i ]) { flag = true ; i = offset ; }
else i = i 1;
return flag ;
}
bool omatch(char*lin , int*i , char*pat , int j ) {
. . .
i f (( lin [*i ] != NEWLINE) && (! locate( lin [*i ] , pat , j )))
. . .
}
(a) Snippet of Replace version 26
bool omatch(char*lin , int*i , char*pat , int j ) {
. . .
/* *DirectFix: replace parameter j with j+1. * */
i f (( lin [*i ] != NEWLINE) && (! locate( lin [*i ] , pat , j+1)))
. . .
}
(b) A DirectFix repair (identical with the ground truth repair)
bool locate(character c, char*pat , int offset ) {
int i ; bool flag = false ;
i = offset + pat [ offset ] ;
while ( i > offset )
/* *SemFix: replace c == pat[ i ] with i < 6. * */
i f (i<6) { flag = true ; i = offset ; }
else i = i 1;
return flag ;
}
(c) A SemFix repair
Fig. 10. Comparison on repairs for Replace version 26
truth repair. Meanwhile, Fig. 10 shows two different repairs
from DirectFix and SemFix for Replace (buggy) version 26.
DirectFix successfully found the simple ground truth repair;
it replaces a function parameter jwith j+1of function locate .
Meanwhile, SemFix repaired function locate itself by changing
an if-guard c==pat[i] toi<6. Although the repair is valid for
the given test suite, this destructive repair causes a regression.
As compared with SemFix, DirectFix repairs are simpler,
more frequently identical with the ground truth repairs, and
less frequently cause a regression error.
VIII. T HREATS TO VALIDITY
Our subject programs mostly require small changes for
repair. While software mining research shows that small Ô¨Åxes
are abundant in the Ô¨Åeld [4], [23], some Ô¨Åxes inevitably
require more sizable changes. In such situations, time would
be exhausted before DirectFix can Ô¨Ånd a repair. Our subject
programs do not represent such scenario.
In our experiments, we assumed that developers have insight
about which function might be buggy. If an incorrect function
is designated as buggy, DirectFix cannot generate the the
ground truth repair. Our conjecture is that our repair method is
better suited for Ô¨Åne-tuning a program and looking for a small
Ô¨Åx, whereas search-based methods such as GenProg have
advantage in their scalability. Combining these two contrasting
methods seems possible; for example, after a search-based
method aggressively narrows down the search space, DirectFix
should be able to Ô¨Ånd the smallest patch in that reduced search
space at a subsequent phase.IX. R ELATED WORK
A large volume of research has been conducted on au-
tomatic program repair. A number of them repair speciÔ¨Åc
defect types [24]‚Äì[30], while DirectFix is designed to be a
general purpose program repair tool. Unlike speciÔ¨Åcations-
based methods [31]‚Äì[36], DirectFix falls into the category
of the test-driven method whose goal is to Ô¨Ånd a patch that
makes all tests in the given test suite pass. GenProg [5] and
JAFF [37] use genetic programming (GP) to search for a patch.
Using GP, statements can be deleted or moved. The Ô¨Åtness
function of GP guides such mutations towards a patch. It was
empirically shown that this approach scales to large programs
such as PHP [12]. However, it often generates nonsensical
patches, as pointed out in [7], due to its inherent nature of
random mutation. To alleviate this problem, MUT-APR [38]
mutates only pre-selected binary operators thereby restricting
the defect types it can handle, and PAR [7] uses Ô¨Åx templates
mined from actual human patches, instead of GP.
Meanwhile, SemFix [6] synthesizes a patch by semantic
program analysis via dynamic symbolic execution, instead
of performing syntactic search. Similar to DirectFix, Sem-
Fix also synthesizes a patch at the expression level by us-
ing component-based program synthesis [13]. More recently,
Nopol [39] also took this semantic approach to Ô¨Åx control-
related bugs (e.g., buggy ifconditions). AutoFix [40] exploits
contracts such as pre/post-conditions to generate random tests,
localize faults, and generate a repair.
In all existing repair methods, fault localization is performed
upfront before looking for a patch. We in contrast combine
fault localization and repair generation, and as a result obtain
the unique capability to take into account the simplicity
of a patch. For this purpose, we exploit partial MaxSMT
(pMaxSMT). Similarly, BugAssist [16] exploits pMaxSAT for
fault localization. However, unlike in DirectFix, pMaxSAT is
not used for repair synthesis ‚Äì BugAssist does not fuse fault
localization and repair generation.
X. C ONCLUSION
In this paper, we have proposed DirectFix as a method that
generates the simplest repair, following the thesis that small
patches are easier to inspect and introduce less regressions
(hence safer). DirectFix is a semantic analysis based repair
method which differs from all existing repair methods in its
integration of fault localization with repair generation. We
have shown how those two phases can be integrated based
on partial MaxSMT and component-based program synthesis.
Patches produced by DirectFix are found to be simpler and
safer than those produced by SemFix, the state-of-the-art
semantic analysis based repair method.
ACKNOWLEDGEMENTS
This research is supported in part by the National Re-
search Foundation, Prime Minister‚Äôs OfÔ¨Åce, Singapore un-
der its National Cybersecurity R&D Program (Award No.
NRF2014NCR-NCR001-21) and administered by the National
Cybersecurity R&D Directorate.REFERENCES
[1] M. E. Fagan, ‚ÄúDesign and code inspections to reduce errors in program
development.‚Äù IBM Systems Journal , vol. 15, no. 3, pp. 182‚Äì211, 1976.
[2] J. Feller and B. Fitzgerald, Understanding Open Source Software De-
velopment . Addison-Wesley, 2001.
[3] P. Wei√ügerber, D. Neu, and S. Diehl, ‚ÄúSmall patches get in!‚Äù in MSR ,
2008, pp. 67‚Äì76.
[4] R. Purushothaman and D. E. Perry, ‚ÄúToward understanding the rhetoric
of small source code changes,‚Äù IEEE Trans. Software Eng. , vol. 31,
no. 6, pp. 511‚Äì526, 2005.
[5] W. Weimer, T. Nguyen, C. L. Goues, and S. Forrest, ‚ÄúAutomatically
Ô¨Ånding patches using genetic programming,‚Äù in ICSE , 2009, pp. 364‚Äì
374.
[6] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra, ‚ÄúSemÔ¨Åx:
program repair via semantic analysis,‚Äù in ICSE , 2013, pp. 772‚Äì781.
[7] D. Kim, J. Nam, J. Song, and S. Kim, ‚ÄúAutomatic patch generation
learned from human-written patches,‚Äù in ICSE , 2013, pp. 802‚Äì811.
[8] Z. P. Fry, B. Landau, and W. Weimer, ‚ÄúA human study of patch
maintainability,‚Äù in ISSTA , 2012, pp. 177‚Äì187.
[9] J. A. Jones, M. J. Harrold, and J. T. Stasko, ‚ÄúVisualization of test
information to assist fault localization,‚Äù in ICSE , 2002, pp. 467‚Äì477.
[10] B. Liblit, A. Aiken, A. X. Zheng, and M. I. Jordan, ‚ÄúBug isolation via
remote program sampling,‚Äù in PLDI , 2003, pp. 141‚Äì154.
[11] R. Abreu, P. Zoeteweij, and A. J. C. van Gemund, ‚ÄúAn evaluation
of similarity coefÔ¨Åcients for software fault localization,‚Äù in 12th IEEE
PaciÔ¨Åc Rim International Symposium on Dependable Computing (PRDC
2006) , 2006, pp. 39‚Äì46.
[12] C. L. Goues, M. Dewey-V ogt, S. Forrest, and W. Weimer, ‚ÄúA systematic
study of automated program repair: Fixing 55 out of 105 bugs for $8
each,‚Äù in ICSE , 2012, pp. 3‚Äì13.
[13] S. Jha, S. Gulwani, S. A. Seshia, and A. Tiwari, ‚ÄúOracle-guided
component-based program synthesis,‚Äù in ICSE , 2010, pp. 215‚Äì224.
[14] L. Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in TACAS ,
2008, pp. 337‚Äì340.
[15] E. Cohen, M. Dahlweid, M. A. Hillebrand, D. Leinenbach, M. Moskal,
T. Santen, W. Schulte, and S. Tobies, ‚ÄúVCC: A practical system for
verifying concurrent C,‚Äù in Theorem Proving in Higher Order Logics ,
2009, pp. 23‚Äì42.
[16] M. Jose and R. Majumdar, ‚ÄúCause clue clauses: error localization using
maximum satisÔ¨Åability,‚Äù in PLDI , 2011, pp. 437‚Äì446.
[17] E. Ermis, M. Sch√§f, and T. Wies, ‚ÄúError invariants,‚Äù in FM, 2012, pp.
187‚Äì201.
[18] M. Barnett, B.-Y . E. Chang, R. DeLine, B. Jacobs, and K. R. M. Leino,
‚ÄúBoogie: A modular reusable veriÔ¨Åer for object-oriented programs,‚Äù in
FMCO , 2005, pp. 364‚Äì387.
[19] C. Barrett, A. Stump, and C. Tinelli, ‚ÄúThe SMT-LIB standard version
2.0,‚Äù SMT-LIB, Tech. Rep., 2012.
[20] Z. Fu and S. Malik, ‚ÄúOn solving the partial max-sat problem,‚Äù in SAT,
2006, pp. 252‚Äì265.
[21] H. Do, S. G. Elbaum, and G. Rothermel, ‚ÄúSupporting controlled exper-
imentation with testing techniques: An infrastructure and its potentialimpact,‚Äù Empirical Software Engineering , vol. 10, no. 4, pp. 405‚Äì435,
2005.
[22] C. Cadar, D. Dunbar, and D. R. Engler, ‚ÄúKlee: Unassisted and automatic
generation of high-coverage tests for complex systems programs,‚Äù in
OSDI , 2008, pp. 209‚Äì224.
[23] V . Dallmeier and T. Zimmermann, ‚ÄúExtraction of bug localization
benchmarks from history,‚Äù in ASE, 2007, pp. 433‚Äì436.
[24] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach,
M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sullivan, W.-F.
Wong, Y . Zibin, M. D. Ernst, and M. Rinard, ‚ÄúAutomatically patching
errors in deployed software,‚Äù in SOSP , 2009, pp. 87‚Äì102.
[25] G. Jin, L. Song, W. Zhang, S. Lu, and B. Liblit, ‚ÄúAutomated atomicity-
violation Ô¨Åxing,‚Äù in PLDI , 2011, pp. 389‚Äì400.
[26] M. Carbin, S. Misailovic, M. Kling, and M. C. Rinard, ‚ÄúDetecting and
escaping inÔ¨Ånite loops with Jolt,‚Äù in ECOOP , 2011, pp. 609‚Äì633.
[27] B. Demsky, M. D. Ernst, P. J. Guo, S. McCamant, J. H. Perkins, and
M. Rinard, ‚ÄúInference and enforcement of data structure consistency
speciÔ¨Åcations,‚Äù in ISSTA , 2006, pp. 233‚Äì244.
[28] A. Smirnov and T. cker Chiueh, ‚ÄúDira: Automatic detection, identiÔ¨Åca-
tion and repair of control-hijacking attacks,‚Äù in Network and Distributed
System Security Symposium , 2005.
[29] S. Sidiroglou and A. D. Keromytis, ‚ÄúCountering network worms through
automatic patch generation,‚Äù IEEE Security and Privacy , vol. 3, no. 6,
pp. 41‚Äì49, Nov. 2005.
[30] G. Novark, E. D. Berger, and B. G. Zorn, ‚ÄúExterminator: Automati-
cally correcting memory errors with high probability,‚Äù Commun. ACM ,
vol. 51, no. 12, pp. 87‚Äì95, Dec. 2008.
[31] H. He and N. Gupta, ‚ÄúAutomated debugging using path-based weakest
preconditions,‚Äù in FASE , 2004, pp. 267‚Äì280.
[32] B. Jobstmann, A. Griesmayer, and R. Bloem, ‚ÄúProgram repair as a
game,‚Äù in CAV, 2005, pp. 226‚Äì238.
[33] D. Gopinath, M. Z. Malik, and S. Khurshid, ‚ÄúSpeciÔ¨Åcation-based
program repair using SAT,‚Äù in TACAS , 2011, pp. 173‚Äì188.
[34] R. K√∂nighofer and R. Bloem, ‚ÄúAutomated error localization and correc-
tion for imperative programs,‚Äù in FMCAD , 2011, pp. 91‚Äì100.
[35] H. Samimi, E. D. Aung, and T. Millstein, ‚ÄúFalling back on executable
speciÔ¨Åcations,‚Äù in ECOOP , 2010, pp. 552‚Äì576.
[36] B. Elkarablieh and S. Khurshid, ‚ÄúJuzi: a tool for repairing complex data
structures,‚Äù in ICSE , 2008, pp. 855‚Äì858.
[37] A. Arcuri, ‚ÄúEvolutionary repair of faulty software,‚Äù Appl. Soft Comput. ,
vol. 11, no. 4, pp. 3494‚Äì3514, 2011.
[38] F. Y . Assiri and J. M. Bieman, ‚ÄúAn assessment of the quality of
automated program operator repair,‚Äù in ICST , 2014, pp. 273‚Äì282.
[39] F. Demarco, J. Xuan, D. L. Berre, and M. Monperrus, ‚ÄúAutomatic
repair of buggy if conditions and missing preconditions with SMT,‚Äù
inProceedings of the 6th International Workshop on Constraints in
Software Testing, VeriÔ¨Åcation, and Analysis, CSTVA 2014 , 2014, pp.
30‚Äì39.
[40] Y . Pei, C. A. Furia, M. Nordio, Y . Wei, B. Meyer, and A. Zeller,
‚ÄúAutomated Ô¨Åxing of programs with contracts,‚Äù IEEE Trans. Software
Eng., vol. 40, no. 5, pp. 427‚Äì449, 2014.