Array Shadow State Compression for Precise
Dynamic Race Detection
Williams College Technical Report CSTR-201510, May, 2015
James Wilcox
University of WashingtonParker Finch
CogniusCormac Flanagan
University of California, Santa CruzStephen N. Freund
Williams College
Abstract —Precise dynamic race detectors incur signiﬁcant
time and space overheads, particularly for array-intensive pro-
grams, due to the need to store and manipulate analysis (or
shadow ) state for every element of every array.
This paper presents S LIMSTATE , a precise dynamic race
detector that uses an adaptive, online algorithm to optimize
array shadow state representations. S LIMSTATE is based on the
insight that common array access patterns lead to analogous
patterns in array shadow state, enabling optimized, space efﬁcient
representations of array shadow state with no loss in precision.
We have implemented S LIMSTATE for Java. Experiments on
a variety of benchmarks show that array shadow compression
reduces the space and time overhead of race detection by 27% and
9%, respectively. It is particularly effective for array-intensive
programs, reducing space and time overheads by 35% and 17%,
respectively, on these programs.
I. I NTRODUCTION
The widespread adoption of multi-core processors necessi-
tates a software infrastructure that can reliably exploit multiple
threads of control. Developing reliable multithreaded software
is extremely difﬁcult, however, due to problems caused by
unexpected thread interference, which are notoriously difﬁcult
to detect, reproduce, and eliminate.
Perhaps the most fundamental interference problem is a
race condition , which occurs when two threads concurrently
access the same location, where at least one access is a write.
Race conditions typically reﬂect synchronization errors, and
they cause highly unintuitive behavior under relaxed memory
models [1]. Moreover, reasoning about richer concurrency
properties, such as atomicity, serializability, determinism, co-
operability, functional correctness, etc., often requires ﬁrst
identifying or limiting where races may occur.
Much prior work has explored analyses for race detection.
Static analyses ( e.g.[2], [3], [4]) can offer strong guarantees,
but due to computability limitations either miss races or report
false alarms, and they may have trouble scaling to large
systems.
A complementary approach is to use dynamic analyses,
which can be precise for the observed trace, meaning that
they report errors if and only if there is a race condition in
the observed trace of the target program. A variety of imple-
mentation techniques have been developed for precise dynamic
race detection, including vector clocks [5], [6], epochs [7],
accordion clocks [8], and others [9]. However, the spaceand time overhead of precise dynamic race detectors is still
prohibitive for many applications.
For example, F ASTTRACK ’s epoch-based representation of
the happens-before relation [7] exhibits slowdowns of roughly
an order of magnitude and even greater increases in memory
usage, particularly for array-intensive programs. Thus, while
precise dynamic analyses are critical for detecting data races
and other interference problems in multithreaded systems, their
current performance limitations preclude their widespread use.
For many programs, much of this space overhead is due to
race detection for arrays. We focus on reducing that overhead.
To detect races on an array a, a dynamic race detector must
record sufﬁcient information about the access history of each
array element a[i]to determine if a subsequent access to a[i]
is in a race with any previous access to it. Access information
is typically stored in an array shadow S, where S[i]represents
the access history for a[i]. For example, in the common case
for the F ASTTRACK race detector, S[i]contains the epoch (the
thread identiﬁer and clock) of the last access to a[i].
Programs often access arrays by readily identiﬁable pat-
terns, and those patterns lead to analogous patterns in their
shadow arrays. We present a new race detection algorithm,
SLIMSTATE , that dynamically identiﬁes these patterns and uses
them to compress shadow arrays. For example, suppose a
synchronization-free region (SFR) of one thread traverses all
odd elements in a newly allocated array aof size nwhile a
concurrent SFR traverses all even elements. Once both SFRs
have completed, all odd elements in Swill be identical, as
will all even elements. In this case, rather than requiring n
shadow elements, S LIMSTATE represents Sas a two-element
array T, where the shadow state for a[i]is now T[imod 2] ,
thus reducing the number of shadow locations from n, which
could be very large, to 2.
This compressed representation enables a corresponding
reduction in the number of race checks. As the ﬁrst SFR
above traverses all odd elements of a, rather than performing
a separate race check on each access, S LIMSTATE builds a
footprint {1,3,5,...}of accesses to aby that thread without
yet verifying those accesses are race free. S LIMSTATE commits
that footprint to the shadow state and veriﬁes race freedom at
the thread’s next synchronization operation. Since all indices
in this footprint map to T[1],SLIMSTATE only needs to check
and update that single shadow location, in contrast to the n/2
checks and updates necessary with a traditional shadow array
representation.If a later SFR accesses a different footprint of the ar-
ray, S LIMSTATE appropriately reﬁnes the compressed shadow
representation Tto avoid any missed races or false alarms.
In contrast, prior techniques for compressing shadow state
(e.g.[10], [11], [6], [12]) are prone to false alarms, as discussed
in Section VII below.
As expected, our analysis is most effective on programs
that use arrays heavily. For a collection of array-intensive Java
benchmarks — those for which at least 50% of their data
belongs to arrays — S LIMSTATE reduces the heap footprint
by35% and improves speed by 17%.
SLIMSTATE is most effective on array-intensive programs
that closely adhere to the access patterns currently recognized.
For others, our analysis currently ﬁnds less opportunity for
compression. Thus, S LIMSTATE demonstrates the potential of
using access patterns to compress shadow state and also opens
the door to further exploration of more sophisticated pattern
matching, adaptive mechanisms to target compression where
it is most likely to pay off, and static analyses for computing
footprints and patterns ahead of time to reduce the need to
dynamically infer them. S LIMSTATE may also be adaptable to
shadow compression for objects, but the relatively small size
of objects when compared to arrays will necessitate different
strategies than those we have found effective for arrays.
The beneﬁts of compressed shadow arrays are not limited
to race detection. Many dynamic analyses for a variety of cor-
rectness properties, including atomicity [13], [14], [15], [16],
determinism [17], [18], and cooperability [19], also maintain a
shadow array for each array in the target program. We expect
that shadow array compression may yield comparable beneﬁts
for these analyses.
Contributions. The primary contributions of this paper are:
•We demonstrate that array shadow states contain redun-
dancy due to patterned accesses.
•We present the S LIMSTATE precise dynamic race de-
tection algorithm, which partitions arrays into groups of
indices with identical shadow states. S LIMSTATE infers
those partitions with a dynamic analysis that tracks the
footprint of array accesses within each synchronization-
free region. (Section III and Section IV).
•We explore the design space for representing partitions
and footprints, using techniques such as ranges, strided
ranges, and bit sets. (Section V-A).
•We develop an implementation of S LIMSTATE for Java,
and we report its performance on a variety of benchmark
suites. (Section V-B.)
•For array-intensive programs, S LIMSTATE reduces the
minimum heap size by 35% when compared to F AST-
TRACK . (Section VI.)
•SLIMSTATE also reduces the running time by 17% for
array-intensive programs.
•Furthermore, S LIMSTATE scales to larger numbers of
threads signiﬁcantly better than F ASTTRACK for some
benchmarks.
II. R EVIEW OF DYNAMIC RACEDETECTION
A race condition occurs when two threads concurrently
access a memory location, where at least one of those accessesThread AThread B x = 0          rel(m)          acq(m)x = 1x = 2A@1A@4A@4⟨4,0⟩      ⟨0,8⟩     ⟨0,0⟩⟨4,0⟩      ⟨0,8⟩     ⟨0,0⟩⟨5,0⟩      ⟨0,8⟩     ⟨4,0⟩⟨5,0⟩      ⟨4,8⟩     ⟨4,0⟩⟨5,0⟩      ⟨4,8⟩     ⟨4,0⟩      Race!A@4B@8A@5checkcheckCACBS checkLm
Fig. 1. Race detection using vector clocks and epochs.
is a write. Accesses are considered concurrent if there is
no “synchronization dependence” between them, such as the
dependence between a lock release by one thread and a sub-
sequent acquire by a different thread. These synchronization
dependencies form a partial order over the instructions in a
trace called the happens-before relation [20].
Precise race detectors typically use vector clocks (VCs)
[20], [5] to represent the happens-before relation. Given a
system in which each thread has a unique identiﬁer t2Tid,a
vector clock V:Tid!Nat records a clock for each thread
in the system. Vector clocks are partially ordered ( v) in a
point-wise manner, with an associated join operation ( t):
V1vV2iff8t.V1(t)V2(t)
V1tV2= t.max(V1(t),V2(t))
A dynamic analysis based on VCs maintains a vector clock
Ctfor each thread t. The clock entry Ct(t)records thread
t’s current time. For any other thread u, the clock entry Ct(u)
records the clock for the last operation of thread uthat happens
before the current operation of thread t. Figure 1 illustrates the
shadow state CAandCBfor a trace of operations performed
by threads AandB. The additional shadow state component
Lmrecords the vector clock of the last release of lock m. Thus,
when thread Aperforms rel(m) ,Lmis updated to CA=
h4,0i, and CAis incremented to h5,0ito reﬂect that later
steps of Ahappen after that release. When thread Bperforms
acq(m) ,CBis joined via twith Lm, reﬂecting that later steps
ofBhappen after the release by A.
Following the F ASTTRACK algorithm [7], the shadow state
component Sxcontains the epoch t@cto indicate that the last
access to xwas by thread twhen t’s clock was c. An epoch
t@chappens before a vector clock V(t@c V) if and only if
the clock of the epoch is less than or equal to the corresponding
clock in the vector.
t@c V iff cV(t)
A later access to xby thread uis race-free provided Sx Cu.1
For example, at the second access to xin Figure 1, Sx=A@4
andCB=h4,8i. Since 4CB(A)=4 , this access is race
free. At the third access to x,Sx=B@8andCA=h5,0i.
Since 86CA(B)=0 , a race condition exists.
1Due to space limitations, this discussion does not distinguish reads from
writes and assumes all accesses to a variable conﬂict. Our implementation
handles concurrent reads by tracking reads and writes in separate epochs and
by using F ASTTRACK ’s adaptive epoch/VC representation to record concurrent
reads when they are observed [7]. These extensions are straightforward and
pose no technical challenges. (See Section V.)
2Thread AThread B acq(m)          a[0]=0          a[1]=1          a[2]=2          a[3]=3          rel(m)          acq(m)a[0]=0a[1]=1a[2]=2a[3]=3rel(m)acq(m)a[0]=0a[1]=1rel(m)B@2B@2B@2B@2B@2B@2B@2B@2A@5B@2B@2B@2⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨5,3⟩ ⟨0,8⟩    ⟨0,0⟩⟨6,3⟩ ⟨0,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,8⟩    ⟨5,3⟩⟨6,3⟩ ⟨5,9⟩    ⟨5,8⟩⟨6,8⟩ ⟨5,9⟩    ⟨5,8⟩⟨6,8⟩ ⟨5,9⟩    ⟨5,8⟩⟨6,8⟩ ⟨5,9⟩    ⟨5,8⟩⟨6,8⟩ ⟨5,9⟩    ⟨5,8⟩A@5A@5B@2B@2A@5A@5A@5B@2A@5A@5A@5A@5A@5A@5A@5A@5A@5A@5A@5A@5B@8A@5A@5A@5B@8B@8A@5A@5B@8B@8B@8A@5B@8B@8B@8B@8B@8B@8B@8B@8B@2B@2B@2B@2B@2B@2A@5A@5A@5A@5A@5A@5B@8checkcheckcheckcheckcheckcheckcheckcheckcheck
check{ } { } { } { }{0} { }{0,1} { }{0,1,2} { }{0,1,2,3} { }{ } { }{ } { }{ } {0}{ } {0,1}{ } {0,1,2}{ } {0,1,2,3}{ } { }{ } { }{0} { }{0,1} { }{ } { }CACBS T FAFBLm 
B@8B@8B@8B@8A@6B@8B@8B@8A@6A@6B@8B@8checkA@6A@6B@8B@8B@8B@8B@8A@6B@8reﬁne,checkcheckFig. 2. Full and compressed shadow state for patterned accesses to an array.
III. S HADOW COMPRESSION &C HECK COALESCING
As discussed above, dynamic race detectors typically main-
tain shadow state for each memory location, which incurs
signiﬁcant overhead. F ASTTRACK ’s epochs are perhaps the
most lightweight representation for precise race detection but
can still lead to an order of magnitude or more increase in
memory footprint, particularly for array-intensive programs.
For example, a F ASTTRACK implementation for Java [7] that
supports concurrent reads maintains two epochs encoded as
integers, and a (possibly null) reference to a VC, for each
element in an array, even if those elements are one byte each.
SLIMSTATE signiﬁcantly reduces array shadow state over-
head by eliminating redundancy via state compression. Fig-
ure 2 provides a simple example of how array access patterns in
the target program induce corresponding patterns in the shadow
array. Two threads AandBiterate over elements in an array
aprotected by the lock m. We show the F ASTTRACK shadow
state CA,CB,Lm, and Sfor each step in the execution, where
S[i]records the epoch of the last access to a[i].
Note two key aspects of this trace: (1) at each synchro-
nization operation above the dashed line, all elements in the
shadow array Sareidentical ; and (2) within each of those
critical sections, the checker performs four identical checks,
namely the check B@2 h5,3ifor thread A’s writes, and
the check A@5 h5,8ifor thread B’s writes.
SLIMSTATE dynamically identiﬁes such patterns and uses
them to compress the array shadow Sinto a smaller represen-
tation T. Since S[0],...S [3]are identical at synchronization
operations, S LIMSTATE uses a single shadow location T[0]to
represent all of S[0],...S [3]. To do this, S LIMSTATE does not
immediately perform a separate race check on each access to
a; instead, for each thread t,SLIMSTATE builds a footprint Ft
ofa-indices that thread thas accessed since its last synchro-
nization operation. When each thread texits its ﬁrst criticalsection, the footprint Ft={0,1,2,3}contains all indices
corresponding to shadow state T[0]. In this case S LIMSTATE
performs one race check T[0] Ct, which veriﬁes all accesses
toa[0] ,..., a[3] are race-free; S LIMSTATE then updates
one shadow location T[0]tot@Ct(t), which simultaneously
records the epoch of the last access to all of a[0] ,..., a[3] .
We refer to this as committing the footprint.
Of course, threads may access arrays in more complex
patterns as well. For example, multiple threads may concur-
rently access disjoint blocks of elements, two threads may
concurrently access alternating elements, a thread may only
traverse some preﬁx of the array, and so on. S LIMSTATE is
designed to maintain full precision in all cases by dynamically
reﬁning its compressed shadow representation Tto precisely
represent the original shadow array Sregardless of how the
underlying array has been accessed.
For example, at the end of the third critical section in
Figure 2, footprint FA={0,1}does not cover all indices
corresponding to shadow location T[0]. Thus Tis reﬁned to
have two locations, where T[0]corresponds to indices 0 and
1, and T[1]corresponds to indices 2 and 3. The commit for
Aagain requires only one check and update to T[0]. If a
thread touched every array element within a critical section,
the subsequent commit would check and update T[0]andT[1].
SLIMSTATE initially uses the coarse representation of only
a single shadow state to represent all elements in an array,
and then reﬁnes that representation as necessary. In the worst
case, S LIMSTATE may need a ﬁnerepresentation where each
shadow location in Sis maintained separately, in which case
|T|=|S|. However, our experimental results show that
SLIMSTATE is often able to ﬁnd more compact yet fully
precise representations.
Since our algorithm defers a check until after the access,
a race may not be reported until the end of the current SFR.
3However, this is a reasonable tradeoff for better scalability and
performance in many situations, since identifying the memory
location and the enclosing SFR is often sufﬁcient to understand
and ﬁx the race. In a production environment, existing
mechanisms to recover from run-time faults like unintended
races, such as checkpointing, can also still be employed by, for
example, ensuring all pending footprints are processed prior to
recording checkpoints.
IV. S LIMSTATE ANALYSIS DETAILS
We now formalize the S LIMSTATE algorithm and prove
that its optimizations do not compromise precision.
A. Multithreaded Program Traces
An execution trace !captures the execution of a multi-
threaded program by listing the sequence of operations per-
formed by its threads. Each operation of a thread t2Tid
can acquire or release a lock m2Lock or access index
i2Index ={0,...,n  1}of a single global array:
!2Trace =Operation⇤
b2Operation =acc(t, i)|acq(t, m)|rel(t, m)
The simplicity of our execution model is for presentation
clarity only. The actual implementation, as described in Sec-
tion V, is signiﬁcantly more complex because it must handle
the full Java bytecode language and support arbitrarily many
arrays and objects, other synchronization mechanisms, and
non-conﬂicting concurrent reads. In this section, we elide these
nonessential details in order to clearly present the key ideas of
precise dynamic array shadow compression.
B.FASTTRACK Algorithm
Figure 3 summarizes the F ASTTRACK algorithm adapted
for our idealized trace language. Each F ASTTRACK analysis
state  =(C, L, S )includes the current vector clock Ctof
each thread t; the vector clock Lmfor the last release of each
lock m; and the epoch Sifor the last access to index iof the
global array. The initial analysis state is
 0=( t.inct(?V),  m. ?V,  i .?e)
where ?erefers to a minimal epoch 0@0,?Vis the minimal
VC( t.0), and
inct(V)=  u.ifu=tthen V(u)+1 else V(u)
The rule [FT A CCESS ]foracc(t, i)compares the epoch Si
with thread t’s vector clock Ct; if this check fails, the analysis
get stuck, reﬂecting a detected race condition. Otherwise
this rule updates Sito the epoch Etof thread t, where
Et=t@Ct(t). We use S[i:=Et]to denote the function
that is identical to S, except that it maps itoEt. The rule
[FT A CQUIRE ]foracq(t, m)simply joins Lm, the vector clock
of the last release of lock m, with the current thread’s clock
Ct. Conversely, rule [FT R ELEASE ]forrel(t, i)updates Lm
with Ctand increments the t-component of Ct.
A trace !=b1...b jisrace free under FASTTRACK if it
can be successfully analyzed by these rules without getting
stuck, i.e.there exist states  1,...,  jsuch that  0!b1
 1!b2··· !bj j, which we abbreviate  0!! j.C.SLIMSTATE Algorithm
The S LIMSTATE algorithm in Figure 3 represents the
shadow array Sin a more space efﬁcient manner as the map
T:P!Epoch . Here, Pis some partition ofIndex , which
means Pis a set of parts , where each part p2Pis a subset
ofIndex and each index i2Index is in exactly one part in
P. Thus, Tcontains an epoch Tpfor each part p2P.
In the ideal case, as in the ﬁrst two critical sections in Fig-
ure 2, the partition C OARSE ={Index }contains a single part
Index , and thus Tcontains a single epoch TIndex that applies
to all indices in the array. At the other extreme, Pis the trivial
partition F INE={{i}|i2Index }andTcontains a separate
epoch T{i}for each index i, meaning |dom(T)|=|dom(S)|=
|Index |. Various other partitions are of course possible. For
example, partition P={{0,2,4,...},{1,3,5,...}}divides
Tinto two epochs for the even and odd indices in the global
array, and {{0,1},{2,3}}characterizes the reﬁned partition at
the end of Figure 2.
SLIMSTATE also maintains a footprint Ft✓Index record-
ing all indices accessed during thread t’s current SFR. Each
array access extends this footprint via rule [SS A CCESS ].A
thread’s footprint must be committed into Tbefore it performs
any synchronization operation, as captured via antecedent
Ft=;in rules [SS A CQUIRE ]and [SS R ELEASE ].
SLIMSTATE ’s analysis state is represented as a ﬁve-tuple
(C, L, F, P, T ), as shown in Figure 3, and the relation )b
describes how the S LIMSTATE state is updated for each
observed event bof the target program.
Footprint commits are handled via the relation Vdeﬁned
via[SS R EFINE ]and [SS C OMMIT ]. Rule [SS R EFINE ]changes
the partition Pwhile still preserving the epoch for each index.
Here, '(P,i)denotes the part p2Pthat contains i. This rule
enables the partition Pto be reﬁned so that a footprint Ftis
exactly the union of some parts p1,...,p jinP. In this case,
we say that Pissufﬁciently precise for the footprint Ft.
Once the partition is sufﬁciently precise for a footprint Ft,
rule [SS C OMMIT ]can commit each part p✓Ft. The rule
checks that accesses to pare race-free ( Tp Ct), updates
each Tpfor these accesses, and removes pfrom Ft. If the
check Tp Ctfails, the analysis gets stuck, reﬂecting a race.
Finally, the rules [SS C HANGE 1]and [SS C HANGE 2]en-
able multiple Vsteps to be performed either before or after
each )bstep. The S LIMSTATE algorithm is nondeterministic
about when Vsteps occur; as described in Section V, our
implementation determinizes this algorithm by deferring com-
mits as long as possible to optimize representation efﬁciency
based on the largest footprints possible.
SLIMSTATE does not check for a race on an access to
an index iimmediately. Instead iis added to the accessing
thread’s footprint, and the race is detected later when that
footprint is committed. We say that state ⌧=(C, L, F, P, T )
has a latent race oniifiis in two footprints simultaneously
or if iis in a footprint that, when committed, will reveal a
race; that is, if:
1) 9t, u2Tid.t6=u^i2Ft\Fu, or
2) 9t2Tid.i2Ft^T'(P,i)6 Ct.
4FASTTRACK Analysis SLIMSTATE Analysis
 2FT-State =(C, L, S )where ⌧2SS-State =(C, L, F, P, T )where
C:Tid!VC
L:Lock !VC
S:Index !EpochC:Tid!VC
L:Lock !VC
F:Tid!2Index
P:partition of Index
T:P!Epoch
 !b 0⌧)b⌧0
[FT A CCESS ]
Si Ct S0=S[i:=Et]
(C, L, S )!acc(t,i)(C, L, S0)[SS A CCESS ]
F0=F[t:=F(t)[{i}]
(C, L, F, P, T ))acc(t,i)(C, L, F0,P ,T )
[FT A CQUIRE ]
C0=C[t:=CttLm]
(C, L, S )!acq(t,m)(C0,L ,S )[SS A CQUIRE ]
F(t)=;C0=C[t:=CttLm]
(C, L, F, P, T ))acq(t,m)(C0,L ,F ,P ,T )
[FT R ELEASE ]
L0=L[m:=Ct]
C0=C[t:=inc t(Ct)]
(C, L, S )!rel(t,m)(C0,L0,S)[SS R ELEASE ]
F(t)= ;L0=L[m:=Ct]
C0=C[t:=inc t(Ct)]
(C, L, F, P, T ))rel(t,m)(C0,L0,F ,P ,T )⌧V⌧0
[SS C OMMIT ]
p2P
p✓Ft
F0=F[t:=Ft\p]
Tp Ct
T0=T[p:=Et]
(C, L, F, P, T )V(C, L, F0,P ,T0)
[SS R EFINE ]
PandP0are partitions of Index
8i2Index .T'(P,i)=T0
'(P0,i)
(C, L, F, P, T )V(C, L, F, P0,T0)
⌧)!⌧0
[SS C HANGE 1]
⌧V⌧0)!⌧00
⌧)!⌧00[SS C HANGE 2]
⌧)!⌧0V⌧00
⌧)!⌧00
Fig. 3. F ASTTRACK and S LIMSTATE analysis states and transition rules, where Et=t@Ct(t).
The initial S LIMSTATE state is
⌧0=( t.inct(?V),  m. ?V,  t .;,COARSE ,?T)
where ?Tmaps Index to?e. A trace !israce free under
SLIMSTATE if there exists a state ⌧with no latent races such
that⌧0)!⌧.
D.SLIMSTATE Precision
We now prove that S LIMSTATE is a precise race detector
by showing that it behaves the same as F ASTTRACK , which
previous work has shown to be precise [7]. We begin by
introducing the following functions, ↵and  , which map
FASTTRACK states to S LIMSTATE states, and vice versa:
↵:FT-State !SS-State
↵(C, L, S )=( C, L,  t. ;,FINE,T)where T{i}=Si
 :SS-State !FT-State
 (C, L, F, P, V )=( C, L, S )where
Si=⇢
Et ifi2Ftfor some t
T'(P,i)if8t. i62Ft
Note that  is well deﬁned only for states with no latent races.
With these deﬁnitions, we demonstrate that each F ASTTRACK
transition corresponds to a S LIMSTATE transition. Below, we
assume the trace !is not empty, since the empty trace is
trivially race free.
Lemma 1. If !b 0then ↵( ))b↵( 0).
Proof is by case analysis on  !b 0.
Theorem 1. If a trace !is race free under FASTTRACK , then
!is race free under SLIMSTATE .
Proof: We have that  0!! for some  . By Lemma 1
and induction on !,↵( 0))!↵( ). Moreover, ⌧0V↵( 0).
This transition can be merged into the ﬁrst step of ↵( 0))!↵( ), yielding ⌧0)!↵( ). By the deﬁnition of ↵,↵( )has
no latent races, and thus !is race free under S LIMSTATE .
We now show the converse also holds. Each S LIMSTATE
transition corresponds to a F ASTTRACK transition provided
that the S LIMSTATE states have no latent races.
Lemma 2. If⌧)b⌧0, and ⌧and ⌧0have no latent races,
then  (⌧)!b (⌧0).
Proof is by case analysis on ⌧)b⌧0.
Theorem 2. If a trace !is race free under SLIMSTATE , then
!is race free under FASTTRACK .
Proof: We have that ⌧0)!⌧for some ⌧with no latent
races. Hence every intermediate state in this sequence has no
latent race, and thus  0= (⌧0)!! (⌧)by Lemma 2. Thus
!is race free under F ASTTRACK .
Since the S LIMSTATE relation )is non-deterministic, de-
termining that a trace !=b1...b jis racy under S LIMSTATE
in theory involves a search to show that there are no possible
states ⌧1,...,⌧ jsuch that ⌧0)b1⌧1)b2...)bj⌧jwhere
⌧jhas no latent races. However, this search is not necessary;
the following theorem shows that any reachable state with a
latent race is evidence of a racy trace.
Theorem 3. Suppose ⌧0)!⌧where ⌧has a latent race.
Then !is not race free under SLIMSTATE .
Proof: In the analysis sequence ⌧0)!⌧, consider the
ﬁrst transition into a state ⌧2with a latent race, so that ⌧0)!1
⌧1)b⌧2)!2⌧, where !=!1.b.! 2. By Lemma 2,  0=
 (⌧0)!!1 (⌧1)and by Lemma 3, there does not exist a
 0such that  (⌧)!b 0. Hence !is not race free under
FASTTRACK , and so by Theorem 2, !is not race free under
SLIMSTATE .
Lemma 3. Suppose ⌧)b⌧0where ⌧0has a latent race but
5⌧does not. Then there is no  0such that  (⌧)!b 0.
Proof is by case analysis on the type of latent race in ⌧0.
V. S LIMSTATE IMPLEMENTATION
We have implemented S LIMSTATE for Java and describe
the most salient aspects of this implementation below.
A. Representation of Footprints and Partitions
The idealized S LIMSTATE algorithm of the previous sec-
tion manipulates arbitrary partitions and footprints. An im-
plementation could support that full generality by, for exam-
ple, encoding those structures with bit sets, but a prototype
demonstrated that this is prohibitively expensive. Instead, the
SLIMSTATE implementation restricts the general algorithm to
footprints and partitions that have efﬁcient representations and
that reﬂect common array usage patterns.
Footprints. SLIMSTATE represents footprints as strided ranges
of the form hb:e:ki, with the following meaning:
hb:e:ki⌘{ b+ik|bb+ike}
Thus, h0:3:1 iencodes {0,1,2,3},h1 : 99 : 2 iencodes
{1,3,..., 99}, and E MPTY =h1:0:1 iencodes the empty
set. For all non-empty strided ranges hb:e:ki, we require that
0be,k 1, and kdivides e b. Strided ranges can
represent many footprints observed in practice. The following
algebraic rules describe how to extend a strided range with
another index (which occurs in the [SS A CCESS ]rule).
hb:e:ki[{ i} =hb:e:kiifi2hb:e:ki
EMPTY [{i} =hi:i:1i
hb:b:1i[{ b+k}=hb:b+k:ki
hb:b:1i[{ b k}=hb k:b:ki
hb:e:ki[{ e+k}=hb:e+k:ki
hb:e:ki[{ b k}=hb k:e:ki
If a strided range footprint cannot be extended with a new
index, S LIMSTATE commits the current footprint, and then
adds the index to the new empty footprint.
Partitions. The S LIMSTATE implementation supports the fol-
lowing partition modes , where ndenotes the length of the
corresponding program array, and dandsdivide n:
COARSE ⌘{ { 0,...,n  1}}
FINE ⌘{ { 0},..., {n 1}}
BLOCK (d)⌘{ { 0,...,d  1},{d, . . . , 2d 1},...,
{n d, . . . , n  1}}
STRIDE (s)⌘{ { 0,s ,2s, . . . , n  s},
{1,s+1,2s+1,...,n  s+1},...,
{s 1,2s 1,3s 1,...,n  1}}
SPLIT(i)⌘{ { 0,...,i  1},{i, . . . , n  1}}
PREFIX (i)⌘{ { 0},{1},...{i 1},{i, i+1,...,n  1}}
Below are several examples of how these modes divide the
Index space for an 8 element array into disjoint parts (labeled
A, B, . . . ) that each correspond to a single entry in the com-
pressed array shadow T.P f=hb:e:ki reﬁne (P, f)
COARSE f=h0:n 1:1i COARSE
COARSE f=h0:e:1i SPLIT(e+1)
COARSE f=hb:n 1:1i SPLIT(b)
COARSE d0=g c d ( n, b, e +1),1<d0,k=1 BLOCK (d0)
COARSE b<k, n  1<e+k,1<k, k |nSTRIDE (k)
COARSE e<n/ 4 PREFIX (e+1)
BLOCK (d)d0=g c d ( d, b, e +1),1<d0,k=1 BLOCK (d0)
SPLIT(i)f=h0:i 1:1i SPLIT(i)
SPLIT(i)f=hi:n 1:1i SPLIT(i)
SPLIT(i)f=h0:n 1:1i SPLIT(i)
SPLIT(i)d0=g c d ( n, i, b, e +1),1<d0,k=1 BLOCK (d0)
SPLIT(i)d=m a x ( i, e),d < n / 4 PREFIX (d+1)
STRIDE (s)✓
s0=l c m ( k, s),s0|n,1<s0
b<k, n  1<e+k◆
STRIDE (s0)
PREFIX (i)f=hi:n 1:1i PREFIX (i)
PREFIX (i)e<i PREFIX (i)
PREFIX (i)2e<n  1 PREFIX (2e)
Any Any FINE
TABLE I. P ARTITION REFINEMENT RULES ,WHERE f6=EMPTY .AAACoarseAAAAAAAABlock(4)BABBBABCStride(4)DDABCAAASplit(5)BAABBABCPreﬁx(3)DDDDDAABABCDABABCD P             Index Space                TPartition B LOCK (d)applies when SFRs accessing the array
always access one or more complete blocks of delements.
Partition S TRIDE (s)applies when SFRs follow a strided access
pattern with steps of size s. The C OARSE and F INEpartitions
described previously can be represented either as blocks or
strides:
COARSE ⌘BLOCK (n)⌘STRIDE (1) ⌘{ { 0,...,n  1}}
FINE ⌘BLOCK (1) ⌘STRIDE (n)⌘{ { 0},..., {n 1}}
Partition S PLIT(i)applies when elements 0,...,i  1are
accessed together, and similarly for i, . . . , n  1. Partition
PREFIX (i)maintains separate shadow locations for the ﬁrst
ielements. This is particularly useful when a program creates
a large buffer but only ever touches the ﬁrst few elements.
Each partition mode provides an efﬁcient mapping from an
array index i2Index to a corresponding index in the shadow
array T. Eg, for B LOCK (d), this mapping is simply (idivd).
Table I describes how a partition Pis reﬁned to a new par-
tition reﬁne (P,f)that is sufﬁciently precise for the footprint
f. (Recall Pis sufﬁciently precise for fiffis exactly the
union of some parts p1,...,p jinP.) Note that reﬁne (P,f)is
a reﬁnement of P: each part in Pbecomes the union of some
parts in reﬁne (P,f). The given rules are applied in the order
listed, and they attempt to minimize the number of parts in
the resulting partition. In particular, if Pis already sufﬁciently
precise for f, then P=reﬁne (P,f).
COARSE Rules. The ﬁrst three rules either preserve the
COARSE partition or convert it to S PLIT(d), if possible. The
fourth rule converts the partition to B LOCK (d0), iffexactly
covers one or more blocks in B LOCK (d0). (We require 1<d0
to avoid converting to F INE=BLOCK (1)before exploring
6other rules.) The ﬁfth rule converts C OARSE to S TRIDE (k)
when given an appropriate footprint. The last rule converts to
COARSE to preﬁx mode if the largest index in the footprint
is in the ﬁrst quartile of the array, a threshold heuristically
chosen to balance various implementation tradeoffs.
BLOCK (d) Rules. We reﬁne this partition to have a smaller
block size d0if we can ﬁnd a d0that evenly divides both the
original size dand the range end points of the footprint f.W e
choose the largest block size satisfying this requirement.
SPLIT(i) Rules. We remain in S PLIT(i)if the footprint matches
either or both parts. We may transition to B LOCK (d0)if we
can ﬁnd a d0that evenly divides the array size, the index i,
and the endpoints of the footprint f. We may also transition
to preﬁx mode if the original split and the endpoints of fare
all within the ﬁrst quartile of the array.
STRIDE (s) Rules. We reﬁne S TRIDE (s)to S TRIDE (s0)ifs0a
multiple of step size sandfis an appropriate strided range.
PREFIX (i) Rules. A preﬁx partition remains the same if the
footprint fis{i, . . . , n  1}, or if fonly contains indices in
the ﬁnely tracked preﬁx. Otherwise, we (at least) double the
size of the ﬁnely tracked preﬁx to appropriately amortize the
cost of initializing a new, larger shadow array.
If none of the above rules apply, the partition becomes F INE.
B. Java Implementation Details
We built our prototype in the R OADRUNNER analysis
framework [21]. R OADRUNNER takes as input a compiled Java
target program and inserts instrumentation code into the target
to generate an event stream of memory and synchronization
operations. Back-end checking tools process these events as
the target executes. Standard Java library classes are not
instrumented by R OADRUNNER , and so they are not checked
for races and are assumed to not perform synchronization
relevant to the target program. R OADRUNNER contains special
handling for Object andThread methods providing basic
synchronization operations, such as wait() andnotify() ,
as well as volatile variables. To facilitate comparisons,
SLIMSTATE reuses the F ASTTRACK reference implementation
wherever possible. Indeed, the only substantive difference is
in the treatment of arrays. Objects are tracked exactly as in
FASTTRACK . Both tools prevent races on their shadow state
via optimistic concurrency control mechanisms.
SLIMSTATE correctly handles concurrent reads by main-
taining separate 32-bit read and write epochs, RandW, in
each shadow location and imposing ordering requirements on
pairs of accesses only when at least one is a write. When
reads for a location are not totally ordered, the single epoch
Ris replaced with a vector clock, as in F ASTTRACK [7].
Array Shadows. For each array, S LIMSTATE creates an
ArrayShadow object encapsulating the corresponding partition
Pand shadow array T, where Tis stored as an array
of adaptive epoch pairs (R, W )described in the previous
paragraph. When Pis not sufﬁciently precise for a footprint
being committed, S LIMSTATE reﬁnes that P, as described
in the previous section, and similarly reﬁnes the shadow
array Tas necessary. ArrayShadow objects support concurrent
reﬁnements (which typically leave Punchanged) and commitsvia optimistic concurrency control. Each ArrayShadow also
maintains separate read and write footprints as strided ranges
for each thread that has touched its corresponding array.
Commit Buffers. For each thread t,SLIMSTATE maintains a
commit buffer recording all ArrayShadow s with non-empty
read or write footprints for t.SLIMSTATE ﬂushes that buffer
and commits the corresponding footprints whenever tperforms
a synchronization operation.
As mentioned earlier, if thread tperforms an array read (or
write) that cannot be merged into the ArrayShadow ’s read (or
write) footprint, the footprint is committed immediately, and
the access is recorded in the new empty footprint.
We limit the size of commit buffers to 2048 entries and
ﬂush them if they become full. This may lead to sub-optimal
commits for some arrays, but our experience indicates that this
does not occur often and that larger buffers lead to performance
degradation by preventing the shadow state for an array from
being garbage collected even if the array itself has been.
FINE and PREFIX Modes. Once the partition for an array
is in F INEor P REFIX (i)mode, S LIMSTATE stops building
footprints for that array and instead commits accesses to the
shadow array as they occur.
Small Arrays. The overhead of managing footprints and parti-
tions for small arrays can be higher than tracking those arrays
with F INE partitions from the start. S LIMSTATE treats all
arrays below a threshold size of 16 as having a F INEpartition.
VI. E VA L UAT I O N
We evaluate the effectiveness of S LIMSTATE on the bench-
marks listed in Figure 4. Each is labeled with its source: (1)
the Java Grande Benchmarks [22]; (2) the DaCapo Bench-
marks [23]; (3) jbb andmtrt [24]; (4) colt [25]; and (5)
raja [26]. The Java Grande benchmarks were conﬁgured with
4 worker threads and their largest data sets. R OADRUNNER
contains special provisions to compensate for bugs in the
barrier implementations in some of those programs [27]. We
separated the DaCapo programs from the DaCapo harness and
excluded the tradebeans benchmark to avoid limitations of
ROADRUNNER ’s instrumentation loading support. The code in
several speciﬁc class ﬁles in other programs was excluded from
analysis for similar reasons. These programs were conﬁgured
to use the default benchmark parameters. The jbbbenchmark
was modiﬁed to terminate after a ﬁxed number of transactions
rather than after a ﬁxed time.
All experiments were performed on an Apple Mac Pro
with a 2.7GHz 12-core Pentium Xeon processor with hyper-
threading and 64GB of memory. We used Sun’s Java HotSpot
64-bit Server VM version 1.7 with the default parallel garbage
collection conﬁguration.
Both F ASTTRACK and S LIMSTATE are precise and report
no spurious warnings or missed races. We manually veriﬁed
that both tools report the same races modulo variations due to
observed interleavings.
Array Shadow Compression. Figure 4 provides an overview
of the shadow compression achieved by S LIMSTATE ’s various
partition modes. These benchmarks are ordered according to
how well S LIMSTATE compresses array shadow state. The left
7Fig. 4. Left: Fraction of shadow array locations in each partitioning mode at their end of their life times. Right: How many shadow array locations are needed
for each partition mode as a fraction of the original number of locations.
SLIM Alternative Bit Set Representations
Program S TATE Footprint Partition Both
crypt 0.00000057 0.00000023 0.00000021 0.00000017
raytracer 0.000057 0.000057 0.000034 0.000034
montecarlo 0.0018 0.0018 0.0017 0.0017
lusearch 0.0019 0.0019 0.00064 0.00061
jbb 0.11 0.11 0.092 0.089
batik 0.19 0.11 0.11 0.028
colt 0.20 0.11 0.012 0.0099
xalan 0.27 0.25 0.043 0.041
pmd 0.35 0.31 0.12 0.042
tomcat 0.60 0.54 0.094 0.045
moldyn 0.63 0.63 0.63 0.0021
series 0.63 0.63 0.000014 0.000014
h2 0.64 0.61 0.26 0.21
jython 0.72 0.71 0.31 0.28
sunﬂow 0.76 0.68 0.42 0.35
mtrt 0.80 0.80 0.27 0.25
eclipse 0.86 0.62 – 0.054
avrora 0.90 0.89 0.38 0.37
luindex 0.91 0.88 0.68 0.45
fop 0.96 0.92 0.21 0.047
lufact 1.00 1.00 0.49 0.41
sor 1.00 1.00 1.00 0.004
sparse 1.00 0.53 – 0.0000041
raja 1.00 1.00 0.54 0.54
Average 0.56 0.51 0.26 0.13
TABLE II. A RRAY SHADOW FRACTIONS .side shows the aggregate array sizes for all arrays matching
each partition mode, relative to the aggregate size of all
allocated arrays. With no compression, the shadow state and
arrays will be equal in size. An array may go through multiple
reﬁnements over its lifetime, and this ﬁgure reﬂects only
its ﬁnal partition mode. The right half of Figure 4 shows
the compressed size of the shadow arrays for each partition
mode. For programs like sor andsparse , the number of
array shadows is identical to the number of array elements,
since F INEpartitions provide no compression. For crypt and
raytracer , on the other hand, the number of shadow locations
is well below 1% of the array sizes.
Table II provides a numeric view of this data. The second
column shows, for each benchmark, the shadow fraction ,
which is the number of array shadow locations as a fraction
of the number of array elements. S LIMSTATE achieves a
shadow fraction of 0.56, in comparison to 1 for F ASTTRACK .
SLIMSTATE also performs 30% fewer array race checks than
FASTTRACK for these programs.
Bit Set Representations. Columns 3–5 investigate how the
shadow fraction is inﬂuenced by S LIMSTATE ’s representations
for footprints and partitions. Column 3 shows that using
bit sets to represent arbitrary footprints reduces the average
shadow fraction to 0.51; Column 4 shows that using bit sets to
represent partitions reduces it to 0.26 (our prototype ran out of
memory on the entries marked ‘  ’.); and Column 5 shows that
using bit sets to represent both footprints and partitions reduces
it to 0.13. These bit set implementations are prohibitively
expensive for many programs, but their shadow fractions
8Array Elems Minimum Heap Space Time with No Space Limits
Program Count
(x106)% of
TotalShadow
FractionBase
(MB)FT
BaseSS
Base✓SS
FT◆
Base
(sec)FT
BaseSS
Base✓SS
FT◆
Array-Intesive Programs
crypt 150.0 100 0.00000057 193.6 27.67 1.00 (0.04) 0.62 87.71 15.06 (0.17)
lufact 4.0 100 1.00 32.1 7.00 7.00 (1.00) 0.81 40.55 36.70 (0.91)
series 2.0 100 0.63 22.2 3.86 3.04 (0.79) 218.51 1.03 1.03 (1.00)
sor 4.0 100 1.0 33.5 4.76 4.76 (1.00) 0.47 19.13 20.53 (1.07)
sparse 16.0 100 1.00 100.0 5.53 3.17 (0.57) 1.49 40.95 39.27 (0.96)
montecarlo 180.0 98 0.0018 619.1 3.55 1.09 (0.31) 3.90 5.92 3.09 (0.52)
lusearch 2,445.8 98 0.0019 1.5 32.25 21.50 (0.67) 2.26 13.09 7.14 (0.55)
xalan 102.1 90 0.27 11.3 10.17 8.50 (0.84) 3.00 6.06 6.56 (1.08)
eclipse 771.1 87 0.86 87.5 8.29 9.14 (1.10) 29.83 9.83 10.72 (1.09)
luindex 2.6 86 0.91 1.3 63.00 61.00 (0.97) 1.24 10.56 11.18 (1.06)
batik 6.3 80 0.19 22.7 5.09 4.14 (0.81) 6.44 2.15 2.23 (1.04)
tomcat 21.3 76 0.60 15.0 11.20 12.10 (1.08) 14.88 2.08 2.08 (1.00)
colt 0.4 76 0.20 0.6 73.05 48.03 (0.66) 15.98 1.10 1.13 (1.02)
jbb 35.0 72 0.11 96.0 3.97 3.09 (0.78) 1.92 11.63 11.48 (0.99)
avrora 0.7 55 0.90 1.3 23.00 21.43 (0.93) 4.28 3.69 3.71 (1.01)
Geo Mean (Array-Intensive) 11.1 7.1 (0.65) 7.9 6.5 (0.83)
Object-Intesive Programs
h2 72.8 37 0.64 272.1 4.46 4.79 (1.07) 12.44 12.58 14.07 (1.12)
fop 2.6 32 0.96 28.9 6.25 6.20 (0.99) 2.59 4.72 4.91 (1.04)
moldyn 0.2 30 0.63 1.4 22.78 21.44 (0.94) 3.68 15.94 18.54 (1.16)
mtrt 0.8 30 0.80 16.0 7.61 8.11 (1.07) 0.44 8.25 9.00 (1.09)
pmd 6.3 30 0.35 45.3 5.31 5.44 (1.02) 3.75 4.79 4.55 (0.95)
jython 27.3 20 0.72 25.6 16.11 11.11 (0.69) 12.02 6.62 7.06 (1.07)
sunﬂow 4.7 1 0.76 15.0 8.07 7.80 (0.97) 1.65 16.39 17.97 (1.10)
raytracer 1.0 0 0.000057 1.4 19.00 10.27 (0.54) 3.06 18.67 19.12 (1.02)
raja 0.0 0 1.00 1.3 13.60 13.60 (1.00) 0.25 9.76 10.04 (1.03)
Geo Mean (Object-Intensive) 9.8 8.9 (0.90) 9.7 10.0 (1.06)
Overall Geo Mean 10.6 7.7 (0.73) 8.5 7.8 (0.91)
TABLE III. A NALYSIS OVERHEAD FOR BENCHMARK PROGRAMS ,SORTED BY THE PERCENT OF MEMORY LOCATIONS (ARRAY ELEMENTS +OBJECT
FIELDS )THAT ARE ARRAY ELEMENTS .ARRAY -INTENSIVE PROGRAMS HA VE A PERCENTAGE OF ARRAY ELEMENTS OF AT LEAST 50%.
suggest that more expressive representations, particularly for
partitions, may further improve S LIMSTATE ’s space savings.
Reduced Race Detection Overhead. Table III shows the total
number of array elements allocated in each program, as well
as that count as a percentage of all locations — array elements
plus object ﬁelds — tracked during race detection. The table
also shows the running time and minimum heap size for
each benchmark under three conﬁgurations: Base (no race
detection), F ASTTRACK (FT), and S LIMSTATE (SS).
Since S LIMSTATE is designed to improve the performance
of race detection on arrays, we focus our attention on the
15array-intensive programs for which at least half of the
checked memory locations are array elements. For those pro-
grams, the running time under S LIMSTATE when memory is
unconstrained is 17%-109% the running time of F ASTTRACK ,
with a geometric mean of 83%. When memory is constrained,
SLIMSTATE is able to successfully check those programs in
heap spaces that are 4%-108% of the minimum heap required
to check them with F ASTTRACK , with a geometric mean of
65%. The most signiﬁcant improvements are achieved for
array-intensive programs whose access patterns match our
compression modes.
While our focus is primarily array-intensive programs, we
also show the object-intensive programs in Table III. Theseprograms, which use fewer arrays and typically exhibit large
array shadow fractions, offer less opportunity for compression.
Two notable exceptions are raytracer andjython , which
use a small number of arrays heavily and in a compressible
way. When all 24 programs are considered, the running time
under S LIMSTATE when memory is unconstrained is reduced
to 91% of the running time under F ASTTRACK . When memory
is constrained, S LIMSTATE is able to check those programs in
heap spaces that are on average only 73% of the minimum
heap size required to check them with F ASTTRACK .
These timing measurements are the average of 20 runs
when the JVM’s maximum heap size is set to the machine’s
physical memory size of 64G, which is roughly an order of
magnitude larger than the maximum space used by any bench-
mark under any checker. Minimum heap space is measured by
iteratively reducing the JVM’s maximum permitted heap size
until execution fails to terminate within ﬁve times the running
time of F ASTTRACK under no memory constraints. (Increasing
that time limit led to no discernible changes in the results.)
Some programs where all arrays ultimately have F INE
partitions, such as sparse , still exhibit space and time savings
because show arrays are still compressed for parts of their
lifetimes, including periods when memory pressure is greatest.
SLIMSTATE space savings drop from 35% to about 20% when
we do not by default use F INEpartitions for arrays with fewer
9●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●cryptlusearch
luindexsparse0x25x50x75x100x0x20x40x60x
0x5x10x15x20x25x0x10x20x30x40x0x10x20x30x0x20x40x60x80x
0x30x60x90x2x4x6xHeap Size Normalized to Base Min. Heap SizeRun Time Normalized to Base Run Time
●BaseFastTrackObjFastTrackSlimTrack●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●cryptlusearch
luindexsparse0x25x50x75x100x0x20x40x60x
0x5x10x15x20x25x0x10x20x30x40x0x10x20x30x0x20x40x60x80x
0x30x60x90x2x4x6xHeap Size Normalized to Base Min. Heap SizeRun Time Normalized to Base Run Time
●BaseFastTrackObjFastTrackSlimStateFig. 5. Run times for different heap sizes.
than 16 elements, due to the additional bookkeeping.
Repeating these experiments on a 2.4GHz 16-core AMD
Athlon processor yielded quite similar results for the array-
intensive programs, with mean savings in time and minimum
heap size of 22% and 36%, respectively.
Time vs. Space Graphs. Since Java is a garbage collected
language, the VM can reduce overall running time at the cost
of increased space usage for the heap, and vice-versa. Figure 5
provides a more complete view of this time/space tradeoff for
the checkers on representative array-intensive programs. (The
Appendix contains graphs for all programs studied.)
In these graphs, JVM heap size is normalized to Base
Minimum Heap Size from Table III, and run time is normal-
ized to Base Time with No Space Limits. We also include
FASTTRACK OBJ, a version of F ASTTRACK that only checks
for races on objects, as a proxy for “ideal” behavior if allarray
checking time and space overhead were eliminated.
The graphs for crypt , and lusearch show sizable im-
provements in both time and space. Other programs, such as
sparse show modest gains in speed but a sizable drop in
the minimum heap size. For luindex , limited opportunities
for compression combined with additional bookkeeping lead
SLIMSTATE to perform no better (or slightly worse) than
FASTTRACK . That pattern is repeated in several other pro-
grams. The high variability under different workloads indicates
that S LIMSTATE may be most effective when used in conjunc-
tion with adaptive feedback to target compression where it will
be most effective.
Scalability. SLIMSTATE has the potential to scale to large
numbers of threads better than F ASTTRACK . To measure this,
we examined eight array-intensive programs with conﬁgurable
levels of concurrency. We ran those programs on a system with
four 2.4GHz 16-core AMD Athlon processors and 256GB of
memory, selectively varying the number of active cores. Fig-
ure 6 shows the minimum heap space (top row) and run time
(bottom row) versus number of cores for ﬁve representative
programs. In that ﬁgure, crypt ,montecarlo ,lusearch , andxalan use one worker thread per core, and tomcat uses one
client thread and one server thread per core.
The results are promising. The minimum heap space for
crypt does not increase very much with the number of threads
because the program always uses the same ﬁxed-size data
arrays. However, F ASTTRACK ’s running time fails to scale. As
the number of threads increases, it suffers from greater garbage
collection overhead and bottlenecks on accesses to the shadow
state maintained by the race detector. S LIMSTATE scales much
better because of its smaller memory footprint and because it
updates shadow state for shared arrays much less frequently.
For montecarlo ,SLIMSTATE ’s compression uses sig-
niﬁcantly less memory than F ASTTRACK . The memory re-
quirements for lusearch andxalan both scale better with
SLIMSTATE , requiring less additional memory per thread than
FASTTRACK .
The tomcat program, which did not exhibit very good
compression in our earlier experiments, shows little difference
in scalability for the two checkers. The lufact ,sor, and
sparse benchmarks (not shown) show little deviation from
the relative performance under S LIMSTATE and F ASTTRACK
reported in Table III as the number of threads increases.
VII. R ELATED WORK
A common approach for shadow state compression in
earlier tools is using a single shadow state for each array
and object [10], [28], [11], [6], [7], [29]. Octet uses a similar
coarse-grained mechanism to enable efﬁcient tracking of cross-
thread dependences inside a JVM [29]. To determine if a
reported race is real, one approach is to re-run the program
with a more ﬁne grained shadow state for the offending array,
as in MultiRace [6]. Another is to switch to a ﬁne-grained
representation on-the-ﬂy and hope that a second race manifests
later if the ﬁrst had been a real race, as in RaceTrack [11].
Other recent work [12] on a F ASTTRACK -style race detector
for C/C++ uses a single shadow state for contiguous memory
locations if those locations are accessed within the same
critical sections. However, only the ﬁrst two critical sections
accessing those locations are considered, and the shadow state
is not reﬁned if later accesses are not correlated, resulting
in potential false alarms. In contrast, S LIMSTATE ’s adaptive
compression technique precisely tracks the happens-before
relation with no false alarms or missed races.
Several race checkers defer the processing of accesses until
later in the execution. RecPlay [30], for example, records all
memory locations accessed within each SFR and then uses this
information to verify that concurrent regions access disjoint
memory during replay. DRD [31] and ThreadSanitizer [32]
similarly buffer accesses but do not infer patterns or compress
the shadow state. Similar buffering is also common in trans-
actional memory systems [33].
Many other dynamic analyses improve space and time per-
formance by sacriﬁcing precision guarantees in various ways.
For example, Eraser’s lockset algorithm reasons about lock-
based synchronization, augmented with specialized handling
of thread-local and read-shared data [34]. Other approaches
extend that algorithm to be less prone to false alarms [28], [11],
[6], [35], [36]. Sampling techniques have also been explored,
10cryptmontecarlolusearchxalantomcat
      01000200030004000      0500100015002000      04080120      050100150      050100150200
116324864116324864116324864116324864116324864CoresMin. Heap (MB)BaseFastTrackSlimScalecryptmontecarlolusearchxalantomcat
      0100200300      04080120      0255075100      0255075      020406080
116324864116324864116324864116324864116324864CoresTime (sec)BaseFastTrackSlimScalecryptmontecarlolusearchxalantomcat
      0100200300      04080120      0255075100      0255075      020406080
116324864116324864116324864116324864116324864CoresTime (sec)BaseFastTrackSlimStateFig. 6. Min. Heap Size and Running Time with No Space Limits for workloads scaled to the number of available cores.
with some loss of precision [37], [38], [39]. RADISH [40]
checks race-freedom of most accesses in hardware at access
time, but defers some race checks into a queue processed
by another core asynchronously. The hardware waits for the
queue to empty at synchronization points, in the same way
that S LIMSTATE empties its access buffers at those points.
SLIMSTATE targets shared-memory concurrency. Other
programming models may support more efﬁcient race detec-
tion, e.g. structured parallelism in Cilk or X10 [17], [41],
partitioned global address space programs [42], or GPUs [43].
A number of static analyses reason about access patterns in
the context of race detection. DPJ, for example, uses source-
level type annotations to enforce access patterns guaranteed
to be race free [44]. R EDCARD uses a global analysis to
infer whether simple access patterns for arrays and objects
are followed within all synchronization-free code blocks on all
executions [45]. A dynamic analysis can partition shadow state
based on that information, but R EDCARD uses a very expen-
sive and somewhat brittle whole program analysis. S LIMSTATE
instead infers access patterns that are only required to hold for
the observed program trace, enabling compression based on
patterns that static analysis fails to identify or that are only
violated on rare or exceptional control ﬂow paths. R EDCARD
misses such opportunities. On the benchmarks in common with
that work, R EDCARD reduces the number of shadow locations
allocated for both arrays and objects by 27%. S LIMSTATE
reduces that number by 80%, despite not addressing objects.
VIII. C ONCLUSIONS AND FUTURE WORK
Dynamic race detectors incur signiﬁcant space overhead for
recording analysis shadow state, particularly for arrays. Prior
work compressed shadow state by compromising precision.
We show that, by recording footprints and adaptively reﬁn-
ing the compression strategy, S LIMSTATE achieves signiﬁcant
compression of array shadow state with no loss of precision.
Dynamic analyses for richer concurrency properties, such as
atomicity or determinism, often must ﬁrst reason about raceconditions in the observed trace, and the contributions of this
work also serves to potentially improve those analyses as well.
SLIMSTATE builds footprints dynamically, which involves
some run time overhead. A promising direction for future work
is to compute these footprints statically. Adapting S LIMSTATE
to access patterns and shadow compression for objects is
another avenue of future work, although it is likely that other
techniques will be required to achieve good performance, given
the size of most objects.
REFERENCES
[1] S. V. Adve and H.-J. Boehm, “Memory models: a case for rethinking
parallel languages and hardware,” Commun. ACM , vol. 53, no. 8, pp.
90–101, 2010.
[2] D. R. Engler and K. Ashcraft, “RacerX: Effective, static detection of
race conditions and deadlocks,” in SOSP , 2003.
[3] M. Naik, A. Aiken, and J. Whaley, “Effective static race detection for
Java,” in PLDI , 2006, pp. 308–319.
[4] M. Abadi, C. Flanagan, and S. N. Freund, “Types for safe locking:
Static race detection for Java,” TOPLAS , vol. 28, no. 2, pp. 207–255,
2006.
[5] F. Mattern, “Virtual time and global states of distributed systems,” in
Workshop on Parallel and Distributed Algorithms , 1988.
[6] E. Pozniansky and A. Schuster, “MultiRace: Efﬁcient on-the-ﬂy data
race detection in multithreaded C++ programs,” Concurrency and
Computation: Practice and Experience , vol. 19, no. 3, pp. 327–340,
2007.
[7] C. Flanagan and S. N. Freund, “FastTrack: Efﬁcient and precise
dynamic race detection,” in PLDI , 2009, pp. 121–133.
[8] M. Christiaens and K. D. Bosschere, “TRaDe: Data Race Detection for
Java,” in International Conference on Computational Science , 2001, pp.
761–770.
[9] T. Elmas, S. Qadeer, and S. Tasiran, “Goldilocks: A race and
transaction-aware Java runtime,” in PLDI , 2007, pp. 245–255.
[10] C. von Praun and T. Gross, “Object race detection,” in OOPSLA , 2001,
pp. 70–82.
[11] Y. Yu, T. Rodeheffer, and W. Chen, “RaceTrack: Efﬁcient detection of
data race conditions via adaptive tracking,” in SOSP , 2005, pp. 221–
234.
[12] Y. W. Song and Y. Lee, “Efﬁcient data race detection for C/C++
programs using dynamic granularity,” in 2014 IEEE 28th International
Parallel and Distributed Processing Symposium , 2014, pp. 679–688.
11[13] C. Flanagan and S. N. Freund, “Atomizer: A dynamic atomicity checker
for multithreaded programs,” in POPL , 2004, pp. 256–267.
[14] L. Wang and S. D. Stoller, “Runtime analysis of atomicity for mul-
tithreaded programs,” IEEE Trans. Software Eng. , vol. 32, no. 2, pp.
93–110, 2006.
[15] C. Flanagan, S. N. Freund, and J. Yi, “Velodrome: a sound and complete
dynamic atomicity checker for multithreaded programs,” in PLDI , 2008,
pp. 293–303.
[16] S. Biswas, J. Huang, A. Sengupta, and M. D. Bond, “DoubleChecker:
efﬁcient sound and precise atomicity checking,” in PLDI , 2014.
[17] G.-I. Cheng, M. Feng, C. E. Leiserson, K. H. Randall, and A. F. Stark,
“Detecting data races in Cilk programs that use locks,” in Proceedings
of the 10th Symposium on Parallel Algorithms and Architectures , 1998,
pp. 298–309.
[18] C. Sadowski, S. N. Freund, and C. Flanagan, “SingleTrack: A dynamic
determinism checker for multithreaded programs,” in ESOP , 2009, pp.
394–409.
[19] J. Yi, C. Sadowski, and C. Flanagan, “Cooperative reasoning for
preemptive execution,” in PPoPP , 2011.
[20] L. Lamport, “Time, clocks, and the ordering of events in a distributed
system,” Commun. ACM , vol. 21, no. 7, pp. 558–565, 1978.
[21] C. Flanagan and S. N. Freund, “The RoadRunner dynamic analysis
framework for concurrent programs,” in PASTE , 2010, pp. 1–8.
[22] Java Grande Forum, “Java Grande Forum benchmark suite,” Available
from http://www.javagrande.org/ , 2013.
[23] S. M. Blackburn, R. Garner, C. Hoffmann, A. M. Khan, K. S.
McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z.
Guyer, M. Hirzel, A. L. Hosking, M. Jump, H. B. Lee, J. E. B.
Moss, A. Phansalkar, D. Stefanovic, T. VanDrunen, D. von Dincklage,
and B. Wiedermann, “The DaCapo benchmarks: Java benchmarking
development and analysis,” in OOPSLA , 2006, pp. 169–190.
[24] Standard Performance Evaluation Corporation, “SPEC benchmarks,”
http://www.spec.org/ , 2003.
[25] CERN, “Colt 1.2.0,” http://dsd.lbl.gov/~hoschek/colt/ , 2004.
[26] E. Fleury and G. Sutre, “Raja, version 0.4.0-pre4,” Available at
http://raja.sourceforge.net/ , 2007.
[27] C. Flanagan and S. N. Freund, “Adversarial memory for detecting
destructive races,” in PLDI , 2010, pp. 244–254.
[28] R. O’Callahan and J.-D. Choi, “Hybrid dynamic data race detection,”
inPPoPP , 2003, pp. 167–178.
[29] M. D. Bond, M. Kulkarni, M. Cao, M. Zhang, M. F. Salmi, S. Biswas,
A. Sengupta, and J. Huang, “OCTET: capturing and controlling cross-
thread dependences efﬁciently,” in OOPSLA , 2013, pp. 693–712.
[30] M. Ronsse and K. D. Bosschere, “RecPlay: A fully integrated practical
record/replay system,” TOCS , vol. 17, no. 2, pp. 133–152, 1999.
[31] “DRD: a thread error detector,” http://valgrind.org/docs/manual/
drd-manual.html, 2014.
[32] K. Serebryany and T. Iskhodzhanov, “ThreadSanitizer: Data race detec-
tion in practice,” in Proceedings of the Workshop on Binary Instrumen-
tation and Applications , 2009, pp. 62–71.
[33] N. Shavit and D. Touitou, “Software transactional memory,” in ACM
Symposium on Principles of Distributed Computing , 1995, pp. 204–213.
[34] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and T. E. Anderson,
“Eraser: A dynamic data race detector for multi-threaded programs,”
TOCS , vol. 15, no. 4, pp. 391–411, 1997.
[35] K. Serebryany, A. Potapenko, T. Iskhodzhanov, and D. Vyukov, “Dy-
namic race detection with LLVM compiler - compile-time instrumen-
tation for ThreadSanitizer,” in RV, 2011, pp. 110–114.
[36] X. Xie and J. Xue, “Acculock: Accurate and efﬁcient detection of data
races,” in CGO , 2011, pp. 201–212.
[37] M. D. Bond, K. E. Coons, and K. S. McKinley, “PACER: proportional
detection of data races,” in PLDI , 2010, pp. 255–268.
[38] J. Erickson, M. Musuvathi, S. Burckhardt, and K. Olynyk, “Effective
data-race detection for the kernel,” in OSDI , 2010, pp. 151–162.
[39] L. Efﬁnger-Dean, B. Lucia, L. Ceze, D. Grossman, and H.-J. Boehm,
“IFRit: interference-free regions for dynamic data-race detection,” in
OOPSLA , 2012, pp. 467–484.[40] J. Devietti, B. P. Wood, K. Strauss, L. Ceze, D. Grossman, and
S. Qadeer, “Radish: Always-on sound and complete race detection in
software and hardware,” in ISCA , 2012, pp. 201–212.
[41] R. Raman, J. Zhao, V. Sarkar, M. T. Vechev, and E. Yahav, “Efﬁcient
data race detection for async-ﬁnish parallelism,” in RV, 2010, pp. 368–
383.
[42] C.-S. Park, K. Sen, and C. Iancu, “Scalable data race detection for
partitioned global address space programs,” in PPoPP , 2013, pp. 305–
306.
[43] M. Zheng, V. T. Ravi, F. Qin, and G. Agrawal, “GRace: a low-overhead
mechanism for detecting data races in GPU programs,” in PPoPP , 2011,
pp. 135–146.
[44] R. L. Bocchino, Jr., V. S. Adve, D. Dig, S. V. Adve, S. Heumann,
R. Komuravelli, J. Overbey, P. Simmons, H. Sung, and M. Vakilian,
“A type and effect system for deterministic parallel Java,” in OOPSLA ,
2009, pp. 97–116.
[45] C. Flanagan and S. N. Freund, “RedCard: Redundant check elimination
for dynamic race detectors,” in ECOOP , 2013, pp. 255–280.
12APPENDIX
Supplemental Material: Run Times for Different Heap Sizes. These graphs show the run times of each target program from
Table III when the JVM is conﬁgured with different limits on heap size. See Section VI for full details of these experiments.
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●cryptlufactseriessor
sparsemontecarlolusearchxalan
eclipseluindexbatikcolt
tomcatavrorajbb0x25x50x75x100x
0x20x40x60x
1x1.1x1.2x1.3x1.4x1.5x
0x5x10x15x20x25x
0x10x20x30x40x
2.5x5x7.5x10x12.5x
0x20x40x60x
0x10x20x30x
5x10x15x
0x5x10x15x20x25x
2x4x6x
1x1.1x1.2x1.3x1.4x1.5x
1x2x3x4x5x2x4x6x8x
0x20x40x0x10x20x30x5x10x1x2x3x4x4x8x12x
2x4x6x1x2x3x4x5x6x0x20x40x60x80x0x20x40x
0x10x20x30x40x0x30x60x90x5x10x15x0x100x200x300x
0x10x20x30x0x10x20x30x40x2.5x5x7.5x10xHeap Size Normalized to Base Min. Heap SizeRun Time Normalized to Base Run Time
●BaseFastTrackObjFastTrackSlimState
13●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
●●●●●●●●●●●●●●●●●●h2fopmoldynmtrt
pmdjythonsunflowraytracer
raja0x10x20x2.5x5x7.5x10x5x10x15x5x10x15x
2x4x6x3x6x9x0x20x40x60x80x
0x10x20x30x40x
5x10x15x3x6x9x4x8x12x16x0x10x20x30x5x10x15x
5x10x15x20x0x10x20x30x0x5x10x15x20x0x10x20x30x
0x20x40x60xHeap Size Normalized to Base Min. Heap SizeRun Time Normalized to Base Run Time
●BaseFastTrackObjFastTrackSlimState
14