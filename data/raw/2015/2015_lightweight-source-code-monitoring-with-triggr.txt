Lightweight Source Code Monitoring with Triggr
Alim Ozdemir
Faculty of Computer and Informatics Engineering
Istanbul Technical University
Istanbul, Turkey
ozdemirali@itu.edu.trAyse Tosun
Faculty of Computer and Informatics Engineering
Istanbul Technical University
Istanbul, Turkey
tosunay@itu.edu.tr
Hakan Erdogmus
Carnegie Mellon University
Silicon Valley, CA
hakan.erdogmus@sv.cmu.eduRui Abreu
INESC-ID, Instituto Superior Tecnico
University of Lisbon
Lisbon, Portugal
rui@computer.org
ABSTRACT
Existing tools for monitoring the quality of codebases modified
by multiple developers tend to be centralized and inflexible. These
tools increase the visibility of quality by producing effective re-
ports and visualizations when a change is made to the codebase
and triggeringalerts whenundesirable situations occur.However,
their configuration is invariably both (a) centrally managed in
that individual maintainers cannot define local rules to receivecustomized feedback when a change occurs in a specific part of
thecodeinwhichtheyareparticularlyinterested,and(b)coarse-
grained in that analyses cannot be turned on and off below thefile level. Triggr, the tool proposed in this paper, addresses these
limitationsbyallowingdistributed,customized,andfine-grained
monitoring. It is a lightweight re-implementation of our previ-oustool,CodeAware,whichadoptsthesameparadigm.Thetool
listens on a codebase’s shared repository using an event-based
approach, and can send alerts to subscribed developers based on
rulesdefinedlocallybythem.Triggrisopen-sourceandavailable
at https://github.com/lyzerk/Triggr. A demonstration video can be
found at https://youtu.be/qQs9aDwXJjY.
CCS CONCEPTS
•Software and its engineering →Maintaining software ;Soft-
ware evolution ;
KEYWORDS
Softwarequalityassurance,event-basedmonitoring,staticanalysis,
code evolution
ACM Reference Format:
Alim Ozdemir,Ayse Tosun, Hakan Erdogmus,and RuiAbreu. 2018. Light-
weight Source Code Monitoring with Triggr. In Proceedings of the 2018 33rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering(ASE
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240486’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY, USA,
4pages.https://doi.org/10.1145/3238147.3240486
1 INTRODUCTION
Existing tools for quality monitoring of shared codebases are in-
variably coupled to integrated development environments (IDE),
version control systems, continuous integration (CI) servers, or
cloud-basedqualityanalyzers.Suchtoolsoffermanyadvantagesto developers such as automated code inspections, extraction of
metrics, flagging potentially bug-prone parts, visualization of code-
leveltimetrends,andevencollaborationpatterns.Asanubiquitous
example, some of these tools/features are built into Github [ 7].
Other tools, typically static analyzers and metrics extractors for
various programming languages and frameworks, function as local
standalone systems (e.g., FindBugs [ 16], CodeLyzer [ 3]) and sup-
portmultipleprogramminglanguages(e.g.,pfff[ 6]andOOMeter
[14]).However,therealbenefitsmaterializewhentheyareprovided
eitherasalibrary[ 12],centrallyservedframework[ 4],orasathird
party service [ 2,22], and/orwhen they are connectedto another
team-leveltool,e.g.,aCIserveroracentralcoderepositoryrunning
a modern source code management system (SCM) (e.g., Github).
The common feature of team-based monitoring tools is their
adoption of a central management approach. Typically, the team
must collectively decide what the analysis configuration should be,
and individual developers cannot override this configurations to
meettheirspecificneeds,e.g.,tomonitorcriticalchangestoapartof
thecodebasethattheyareresponsibleformaintaining.Twocasesinpointarewhenanindividualdevelopercannotspecify“showmetheaverage cyclomatic complexity of the classes that I touched” or “letmeknowwhenthismethodhasbeenchangedbyanyone.”However,
just becauseanalyses are performedcentrally does notmean that
management and configuration must also be central. A tool thatcan be configured and managed in a distributed fashion permitslocal customization that caters to differing monitoring needs of
individual developers. Another common limitation of team-based
monitoringtoolstheircoarsegranularity:theyarenotconfigurable
below the module or file level. For instance, a developer cannot
specify “let me know if anyone touches this methodin this file.”
To overcome these limitations, we had previously implemented
a peripherally managed, fine-grained source code monitoring tool,
CodeAware,[ 13],whosedistinguishingparadigmisdiscussedinthe
864
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:51 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France A. Ozdemir et al.
nextsection.Inthispaper,wepresentaprototypicalspin-off,Triggr,
thatfollowsthesameparadigm,butadditionallyaddressessome
of CodeAware’s own caveats: complexity, non-portability, exten-
sibilitychallenges,andlackofsupportformultipleprogramming
languages.
2 COMPARISON TO RELATED WORK
Relevant approaches for monitoring and visualizing process and
code artifacts include process telemetry tools [ 20], code inspectors
[18], and customized IDEs that facilitate developer collaboration
and communication [ 21]. Unlike Triggr and CodeAware, these sys-
tems are monolithic and inflexible in that, in a team environment,
theyhavetocatertoagreatestcentralcommoninterest,andcannot
be specialized to individual developers’ needs who may need to
focus on different aspects and parts of a large codebase.
An early sensor-based process and code monitoring system is
Hackystat [ 20], which collects data locally from code artifacts (e.g.,
file-basedmetrics)anddeveloperactions(e.g.,incrementalcompi-
lationsandunit-testruns)throughsensorsaddedtoanIDE.The
sensors are activated periodically and indiscriminately to collectspecific types of data, to be sent to and processed by a central
server later. Triggr’s probes are analogous to Hackystat’s sensors,
but unlike Hackystat, they are added to code fragments locally,not the IDE, and activated centrally. A browser-based IDE called
Adinda[21],likeHackstat,collectsrichdevelopmentdatainclud-
ing communication and collaboration activities of developers, and
aggregates and stores the collected data originating from different
developersinacentralizeddatabaseforanalysis.Triggrdoesnot
collect any data locally.
Modern cloud-based code quality tools such as Better Code Hub
[2] operate similarly, but also rely on a central code repository
such as Github [ 7] to pull the source code for analysis when a
new commit happens. The whole codebase is re-cloned from therepository and analyzed centrally, and the results are stored and
madeavailabletoalldevelopers.Thecommit-triggered,event-based
analysis is similar to the way Triggr operates, but unlike Triggr,
theirconfigurationiscentralandlocalcustomizationisnotpossible.
Also, Triggr does not store any analysis results permanently.
ThepredecessorofTriggr,Codeaware[ 13,19]wasinspiredby
the sensor network metaphor. CodeAware’s approach is simple:
user-defined sensors called probesand locally attached to different
codefragmentsarespreadtothecodebasewhentheyarepushed
to the central code repository. Probes are passive until activated by
CodeAware’sengineinstalledontheCIserver’sbuildpipelineas
a plug-in. The push in turn triggers a build in the CI server. Theengine identifies the probes in the codebase and interprets them.User-defined actions, such as alerts to interested parties, can be
takenvia actuators whenaprobesisactivatedbytheengine.Probes
canbeattachedtoaspecificcodeabstraction,e.g.,aclass,afile,oramethod.LikeTriggr,CodeAware’sdesignisthusflexibleandprobes
aredefinedinadistributedfashion.Itsmajorlimitationisthatits
engine runs on the build pipeline of a specific CI server (Jenkins[
9] as a specialized, complex plug-in. This plug-in is difficult to
install,extend,maintain,anddebug.AlsoCodeAwaresupportsa
single programming language (Java) and it is challenging to add
new kinds of probes or actuators. Supporting a new programminglanguage requires a nearly complete rewrite. Triggr provides asimplified and more extensible and portable solution using the
same sensor-network paradigm of CodeAware.
3 ARCHITECTURE AND CONCEPTS
Triggrisdesignedasalightweight,robusttoolthatcaneasilybede-
ployedonacloud-basedserver.Amajormotivationwastominimizebothsystemrequirementsanduseofresources.Triggrcontinuously
monitorchangestothesharedcoderepository,processesandac-
tivates the probes, and actuates desired actions. The majority of
theseoperationscaneasilyrunasbackgroundtasks,whichTriggr’s
corecoordinates.Toinitiatethemonitoring process,Triggrneeds
toconnecttoasharedcoderepositorysuchasGithub.Thecode-base may contain components written in different programming
languages. When the repository changes, Triggr pulls the changes,
along with any existing, modified, or new probes, and performs
lexical analysis via language-specific parsers to identify and isolate
thehostcodefragmentstowhichtheprobesareattached.Itthen
performs change analysis, metric extraction, and static analysis on
thesefragmentsviaexternaltoolsandlibrariesdependingonthe
probetypeofthefragmentandtheprogramminglanguage.Aprobe
is activated if the conditions specified by the probe are satisfied,
andthecorrespondingactuatorisexecutedtotakesomepreventive
or alerting action defined by the user. Figure 1illustrates the high
levelarchitectureofTriggrwiththeactorsinvolved.Triggrrelies
on five main concepts, explained next.
3.1 Probes
Probes contain information about the type of analysis that a devel-
oper would like to perform on selected code fragments or abstrac-
tions,andwhetheranactionshouldbeperformedwhentheresults
are indicative of an issue that requires the developer’s attention. A
probeisspecifiedasasimpleJSONfilecomposedofmeta-datawith
theseattributes:(a)thehostcodefragment(e.g.,afileormethod)
via a source code path, (b) the probe type from among a set of
existing types, (b) where applicable, activation rules on the output
of the probe (e.g., certain threshold metric values) that warrant an
action,and(d)theactionsthemselvesintermsofatypeofactuator
to execute depending on the probe’s output.
Currently,Triggrsupportstwotypesofprobes: CodeChange and
Static Analysis. To execute a probe, Triggr uses a cached versionof the old code fragment (next to last commit) and compares it
with its most recent commit. The comparison is based on lexical
analysis[ 17]:thesourcefilecontainingthespecifiedcodefragment
(object) is first transformed into an abstract syntax tree (AST), and
then, the object of interest with its name and type is located on the
AST usingalinear searchalgorithm. Ifthe searchfinds theobject,
itreturnstheobject’stextualrepresentation;otherwiseitreturns
false.AnobjectcanbeanytokendefinedinanAST,suchasaclass,
a function, or an identifier. The objects vary from programminglanguage to programming language. For instance, JavaScript hasafunctionobject, which corresponds to a defobject in Python.
Triggrhandlesthesepre-definedtypesofobjectsthroughlanguage-
specific scripts. There could be other methods to compare the code
fragments,e.g.,parsingthecodeintoapartialASTuntilthecode
fragmenthasbeenfound.Unfortunately,ASTlibrariesinPython
865
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:51 UTC from IEEE Xplore.  Restrictions apply. Lightweight Source Code Monitoring with Triggr ASE ’18, September 3–7, 2018, Montpellier, France
andJavascriptdoesnotallowapartialsearchofamethodduring
the AST extraction. Therefore, we had to extract the full AST first,
and find the related object later using textual comparison.
3.1.1 Code Change. This probe type detects the changes be-
tweentwocommitsofanobject.OncetheASTscriptsareexecuted
to extract the object of interest (the probe’s host code fragment)
from the last two commits, Triggr’s scripts check for syntactic dif-
ferences. If a difference is found, the probe has a positive signal
and is activated. An alert can then be transmitted to the developer
usingthe channelspecifiedinthe Actuators attributeof theprobe.
Listing1shows an example of a Code Change probe for a copy-
FileSyncfunction in the utils.jsfile. If this function is modified in a
commit, an email is sent to john.doe.
3.1.2 Static Analysis. Thisprobe type executesspecifiedstatic
analysis tools on a given object. In addition to those of a Code
Changeprobe, it has two extra attributes: StrategyandArguments.
TheStrategyattribute defines under which condition the probe
willbe executed.Possible valuesare AlwaysandDiff.The Always
strategy does not require a change between the old and current
versionoftheobject;italwaysrunsstaticanalysisscriptsonthe
mostrecentversionoftheobject.The Diffstrategy,ontheother
hand,runsstaticanalysisscriptsifandonlyifasyntacticdifference
is detected between the two versions of the object. Different static
analysistoolsandstaticanalysistoolsfordifferentprogramming
languages have different output formats: this probe does not trans-
form the output, and instead forwards the results to the defined
actuators.
Static analysis tools can provide reports containing various met-
rics and code warnings. The Arguments attribute is used to specify
optionalparametersforthetools,e.g.,asubsetofmetricsextracted
by the tool and activation rules associatedwith those metrics. For
example, the argument “complexity: [error, 2]” asks the probe to
instructthestaticanalysistooltocalculatetheMcCabecomplex-
itymetric andactivate onlywhen thevalue ofthemetric exceeds
the given thresholdvalue of 2. This isan example of an argument
filteringthe output of a probe.
{
"Id": "A −unique −id−for−probe",
"ProbeType": "CodeChanges",
"Object": {"Name": "copyFileSync","Path": "packages/rekit/bin/utils .js","Type": "function"
},
"Actuators":[
{
"Type": "Email","Emails" : [ "john .doe@company.com" ]
}
],
"Modifiers": null
}
Listing 1: An example of a Code Change Probe3.2 Actuators
After a probe’s execution, if the probe is activated, Triggr executes
theactuatorsdefinedforthatprobe.Actuatorsarespecializedby
thenotificationchannelused.Thecurrentversiondefinestwotypes
of channels: EmailandIssue.
Emailistheusualchannel,whichwasalsosupportedinCodeAware
[13]. It simply forwards the probe results by email to the specified
addresses,whicharetypicallytheprobeownerswhohaddefined
theprobes.The Issuechannelautomaticallyopensanissueinan
issue tracker using the output of the probe as the issue description.
Currently only GitHub’s built-in issue tracker is supported.
Asanexample,supposeitisproblematicforthecomplexityof
an object to exceed a predefined threshold and a probed is defined
to monitorthis condition.When thecondition happens,using the
Issuechannel,theprobe’sactuatorcanautomaticallyopenanew
“code-review”issueinGitHub.Orusingthe Emailchannel,itcan
sendanemailtothedevelopersresponsibleforthelatestchangeto
that object.
Triggr’s actuator definitions are flexible and new actuators and
channels can easily be added.
3.3 Event-Based Monitoring with Webhooks
One approach for monitoring a shared code asset is to periodically
polltheassettoseeifanyinterestingevents,e.g.,commits,haveoc-
curred.However,thismethodiswasteful.Amorenaturalapproachistoemployanevent-drivenmodelsuchasWebhooks.Thisallows
thesystemtosubscribetospecificeventsonanasset,suchasshared
repository,externalissuetracker,orCIserver.Whenaneventof
interestoccursintheasset,therepositoryissuesanHTTPPOST
requesttothesubscribedURLs,notifyingthesubscribers.Triggr
uses this latter approach listen on a pushevent on the shared code
repository,signalinganewcommit.Whenthiseventoccurs,Triggr
pulls the changes from the repository, including all the probes and
actuators, and processes them as described above.
Figure 1: High-level Architecture of Triggr
3.4 Background Jobs
Background processing is central to the function of Triggr. Triggr
delegatesoperationsthatcanbeexecutedasynchronouslyorcon-
currently to a background job runner. These operations include
keyprocessingtasks suchasASTextraction,activationof probes,
866
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:51 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France A. Ozdemir et al.
and actuation when a probe is activated. Trigger pipelines such
operations on a background job runner upon a push event. Its pre-
decessor,CodeAware,usedaconcurrencyframeworktoaccomplish
the same, but this proved complicated and hard to debug and test.
A good background job runner allows observing the progress of
backgroundoperationsinreal-timeandeasilydiagnoseproblems.
We discuss the specific choice of the background job runner under
Section4.
3.5 Scripts
Triggr supports multiple programming languages by liberating its
core fromlanguage-specificdependencies andisolating language-
specific components as a set of shell scripts. The scripts accom-
plish such tasks as parsing the source code and extracting the
AST or running a static analyzer using language-specific tools
and libraries. The scripts are simple and can be defined for andexecuted on both Unix- and Windows-based operating systems.Supporting a new programming language involves adding new
scripts tothe appropriate foldersin the followingfolder structure:
Scripts/{Task}/{Language}/run.{sh/bat}.
Each leaf folder contains a main script file with an extension
specific to the operating system (.sh or .bat), providing portability.
For example, the Static Analysis probe uses the following script
path for a Python file if Triggr is running on a Linux server: Script-
s/StaticAnalysis/Python/run.sh.
4 TECHNOLOGIES AND IMPLEMENTATION
To implement Triggr, we chose .NET Core [ 10], which is open-
source, portable, and compatible withcommon operating systems.
It uses the cross-platform .NET Standard, which also inherits .NET
Framework 4.6.1features. It supports amodular architecture with
itsbuilt-independencyinjectionpattern.Anadministratorusesthe
web interface of Triggr to configure the tool, for example to add
newcoderepositories.ThisinterfaceisimplementedwithASP.NET
Core, which comes with .NET Core. As the background job run-
ner, we chose the open-source tool Hangfire [8], a popular library
for .NET applications. It has several benefits. It provides a simpler,
morereliable,andefficientmechanismforrunningserver-sideback-
ground jobs compared to, for instance, .NET’s thread pool class. It
is robust, permitting easy recovery from unexpected shutdowns. It
allows easy parallelization. Hangfire also has a web interface for
monitoring scheduled and running jobs, making what normally is
hidden in many concurrency frameworks visible for easier debug-
ging.
Triggr has a small footprint with 1673 lines of C# and .NET
code and half a dozen shell scripts. It supports two interpreted
programminglanguages:JavaScriptandPython.ForASTextraction,
the recast library [ 1] is used for JavaScript and the built-in library
astis used for Python. For static analysis, Triggr currently uses
open-source ESLint[5] for JavaScript and Pylint[11] for Python.
Bothstaticanalysistoolshaveacommand-lineinterfacewitharich
setofoptions,andcaneasilybecalledandconfiguredfromtheir
respective Triggr scripts. Triggr currently supports Git as the SCM
tool,butaddinganotherprovideriseasilyaccomplishedthrough
an interface.5 DISCUSSION AND FUTURE WORK
Triggr is more lightweight and extensible compared to its prede-
cessor, CodeAware. It can run on multiple server platforms and
support multiple programming languages. It is amenable to exten-
sionthroughadditionofnewprobetypesthatrelyonnewexternalsource code analysis tools. Its granularity can easily be adjusted bydefiningnewobjecttypesasprobehosts,forexample,identifiersinadditiontofilesandfunctions.Theimplementation,byrelyingonatransparentopen-sourcebackgroundjobrunner,makesmonitoring
and debugging Triggr’s operations much more convenient than
CodeAware.
Triggr is still a proof-of-concept in its preliminary stages. We
plan to extend its functionality by plugging in new probe types
(e.g., GZoltar’s visualizations [ 15] for automatic fault localization)
and adding new programming languages, with the priority of sup-
porting a compiled language such as Java or C#. We also plan to
benchmark the performance of the system for monitoring multiple
repositorieswithmultipleprobesandusers.Sofar,wehaveonly
benchmarkedthe lagbetween apush event ina monitored code-base and the tool reporting the change to a developer via a Code
Changeprobe(observedtobelessthan3seconds).Wedonotknow
howthiswillscaleupwithincreasedusage.Futureplansinclude
replicationofCodeAware’suserevaluation[ 13],firstwithexperi-
encedstudents,andthenonalargerscale.Finally,wewouldliketo
evaluate its ease of installation on different platforms and with dif-
ferent configurations, develop automated installation scripts, write
installationandusagemanuals,andcreateadeveloperroadmapto
encourage open-source contributions.
REFERENCES
[1] 2018. benjamn/recast. Online. https://github.com/benjamn/recast
[2] 2018. Better Code Hub. Online. http://bettercodehub.com
[3] 2018. CodeLyzer. online. http://codelyzer.com
[4] 2018. Continuous Code Quality. Online. https://www.sonarqube.org/
[5] 2018. ESLint - Pluggable JavaScript linter. Online. https://eslint.org/
[6] 2018. facebook/pfff. Online. https://github.com/facebook/pfff
[7] 2018. GitHub. Online. http://github.com
[8]2018. Hangfire:BackgroundJobsfor.NETand.NETCore. https://www.hangfire.
io
[9] 2018. Jenkins - Build great things at a scale. Online. https://jenkins.io/
[10]2018. .NET Core Guide. Online. https://docs.microsoft.com/en-us/dotnet/core/
[11] 2018. Pylint - code analysis for Python. Online. https://www.pylint.org/
[12] 2018. Roslyn. Online. https://github.com/dotnet/roslyn
[13]R. Abreu, H. Erdogmus, and A. Perez. 2015. CodeAware: Sensor-Based Fine-
Grained Monitoring and Management of Software Artifacts. In ICSE.
[14]J. S. Alghamdi, R. A. Rufai, and S. M. Khan. 2005. OOMeter: A Software Quality
Assurance Tool. In Eur. Conf. Soft. Maintenance and Reengineering.
[15]J. Campos,A. Riboira,A. Perez,and R. Abreu.2012. GZoltar:an eclipseplug-in
for testing and debugging. In ASE.
[16]B. Cole, D. Hakim, D. Hovemeyer, R. Lazarus, W. Pugh, and K. Stephens. 2006.
Improving Your Software Using Static Analysis to Find Bugs. In OOPSLA.
[17]B.Cui,J.Li,T.Guo,J.Wang,andD.Ma.2010. CodeComparisonSystembasedon
AbstractSyntaxTree.In Int.Conf.BroadbandNetworkandMultimediaTechnology.
[18]P. H. de Andrade Gomes, R. E. Garcia, G. Spadon, D. M. Eler, C. Olivete, and R. C.
Correia. 2017. Teaching software quality via source code inspection tool. In FIE.
[19]T.AlmeidaFernandes.2016. Sensor-BasedMonitoringandManagementofSoftware
Artifacts. Master’s thesis. University of Porto.
[20]P. M. Johnson, H. Kou, J. M. Agustin, Q. Zhang, A. Kagawa, and T. Yamashita.
2004. Practical automated process and product metric collection and analysis in
a classroom setting: Lessons learned from Hackystat-UH,. In ISESE.
[21]A.vanDeursen,A.Mesbah,B.Cornelissen,A.Zaidman,M.Pinzger,andA.Guzzi.
2010. Adinda: a knowledgeable, browser-based IDE. In ICSE.
[22] J. Visser. 2016. Building Maintainable Software. O’Reilly.
867
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:51 UTC from IEEE Xplore.  Restrictions apply. 