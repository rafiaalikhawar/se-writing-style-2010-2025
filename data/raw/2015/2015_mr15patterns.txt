 
 
 
 
  
 
 
 
 
 
 
 
 
  
 
 
 
 
 
  King‚Äôs Research Portal  
 
DOI:
10.1145/2786805.2786824
Document Version
Peer reviewed version
Link to publication record in King's Research Portal
Citation for published version (APA):
Maoz, S., & Ringert, J. O. (2015). GR(1) Synthesis for LTL Specification Patterns. ACM.
https://doi.org/10.1145/2786805.2786824
Citing this paper
Please note that where the full-text provided on King's Research Portal is the Author Accepted Manuscript or Post-Print version this may
differ from the final Published version. If citing, it is advised that you check and use the publisher's definitive version for pagination,
volume/issue, and date of publication details. And where the final published version is provided on the Research Portal, if citing you are
again advised to check the publisher's website for any subsequent corrections.
General rights
Copyright and moral rights for the publications made accessible in the Research Portal are retained by the authors and/or other copyright
owners and it is a condition of accessing publications that users recognize and abide by the legal requirements associated with these rights.
‚Ä¢Users may download and print one copy of any publication from the Research Portal for the purpose of private study or research.
‚Ä¢You may not further distribute the material or use it for any profit-making activity or commercial gain
‚Ä¢You may freely distribute the URL identifying the publication in the Research Portal
Take down policy
If you believe that this document breaches copyright please contact librarypure@kcl.ac.uk providing details, and we will remove access to
the work immediately and investigate your claim.
Download date: 11. Aug. 2025GR(1) Synthesis for LTL SpeciÔ¨Åcation Patterns
Shahar Maoz
School of Computer Science
Tel Aviv University, IsraelJan Oliver Ringert
School of Computer Science
Tel Aviv University, Israel
ABSTRACT
Reactive synthesis is an automated procedure to obtain a
correct-by-construction reactive system from its temporal
logic specication. Two of the main challenges in bringing
reactive synthesis to software engineering practice are its
very high worst-case complexity { for linear temporal logic
(LTL) it is double exponential in the length of the formula,
and the diculty of writing declarative specications using
basic LTL operators. To address the rst challenge, Piter-
man et al. have suggested the General Reactivity of Rank 1
(GR(1)) fragment of LTL, which has an ecient polynomial
time symbolic synthesis algorithm. To address the second
challenge, Dwyer et al. have identied 55 LTL specication
patterns, which are common in industrial specications and
make writing specications easier.
In this work we show that almost all of the 55 LTL speci-
cation patterns identied by Dwyer et al. can be expressed
as assumptions and guarantees in the GR(1) fragment of
LTL. Specically, we present an automated, sound and com-
plete translation of the patterns to the GR(1) form, which
eectively results in an ecient reactive synthesis procedure
for any specication that is written using the patterns.
We have validated the correctness of the catalog of GR(1)
templates we have created. The work is implemented in our
reactive synthesis environment. It provides positive, promis-
ing evidence, for the potential feasibility of using reactive
synthesis in practice.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques
General Terms
Languages, Design
Keywords
Linear temporal logic, synthesis, specication patterns1. INTRODUCTION
Reactive synthesis is an automated procedure to obtain
a correct-by-construction reactive system from its temporal
logic specication [35]. Rather than manually constructing
a system and using model checking to verify its compliance
with its specication, synthesis oers an approach where a
correct implementation of the system is automatically ob-
tained for a given specication, if such an implementation
exists. In the case of reactive synthesis, an implementation is
typically given as an automaton that accepts input from the
environment (e.g., from sensors) and produces the system's
output (e.g., on actuators). By construction the input and
output assignments of every innite run of the automaton
satisfy the specication it was synthesized from.
Two of the main challenges in bringing reactive synthesis
to software engineering practice are its very high worst-case
complexity { for linear temporal logic (LTL) it is double
exponential in the length of the formula, and the diculty of
writing declarative specications using basic LTL operators.
To address the rst challenge, Piterman et al. [7,34] have
suggested the General Reactivity of Rank 1 (GR(1)) frag-
ment of LTL, which has an ecient polynomial time sym-
bolic synthesis algorithm. GR(1) is a strict assume/guaran-
tee subset of LTL, comprised of constraints for initial states
, safety propositions over the current and successor state,
and justice constraints Ji(i.e., assertions about what should
hold innitely often). Intuitively, if the assumptions e,e,
andJe
iare satised by the environment the system has to
satisfy the guarantees s,s, andJs
i, i.e., valid runs satisfy
(e^Ge^^
0<ijGFJe
i)!(s^Gs^^
0<ikGFJs
i):
GR(1) synthesis has been used in various application do-
mains and contexts, including robotics [25], scenario-based
specications [32], aspect languages [31], and event-based
behavior models [12], to name a few.
To address the second challenge, Dwyer et al. [16] have
identied 55 LTL specication patterns, which are common
in industrial specications and make writing specications
easier. The patterns are organized by kind, e.g., absence
or existence of properties, and are ordered by scope, e.g.,
globally or before. Their semantics is dened by a mapping
to basic LTL formulas. An example pattern of kind existence
with scope between is
poccurs between qandr
wherep,q, andrare parameters of the pattern, which can be
instantiated with non-temporal propositions. This pattern is
This is the author‚Äôs version of the work. It is posted here for your personal use. Not for
redistribution. The deÔ¨Ånitive version was published in the following publication:
ESEC/FSE‚Äô15 , August 30 ‚Äì September 4, 2015, Bergamo, Italy
c2015 ACM. 978-1-4503-3675-8/15/08...
http://dx.doi.org/10.1145/2786805.2786824
96ForkliftController
boolean 
atStation 
Distance 
obstacle 
Distance 
cargo MotorCmd 
lMot
MotorCmd 
rMot
LiftCmd 
lift
Figure 1: A forklift and its controller component
ForkliftController
numbered P09 and its semantics expressed in LTL according
to [16] is
[](q & !r -> (!r W (p & !r))) :
In this work we show that almost all of the 55 LTL spec-
ication patterns identied by Dwyer et al. can be used as
assumptions and guarantees in the GR(1) fragment of LTL.
Specically, we present an automated, sound and complete
translation of the patterns to the GR(1) form, which eec-
tively results in an ecient reactive synthesis procedure for
any specication that is written using the patterns.
Technically, the translation starts from the LTL formula
of the pattern, translates it to a minimal deterministic B uchi
automaton (DBW), if one exists, and then translates the au-
tomaton to a GR(1) assumption or guarantee formula, while
possibly adding auxiliary variables to the GR(1) synthesis
problem. In case no DBW exists, the pattern is not sup-
ported.
Critical to the usefulness of our approach is that the costly
translation of LTL to DBW is done only once for every pat-
tern. In fact, we have already done it and saved the result as
a set of templates inside our synthesis tool. This works be-
cause patterns are instantiated only with propositions (not
with nested temporal operators). We further show that pat-
terns can even be instantiated with past LTL formulas, but
not with nested future temporal operators.
To summarize our contribution, our work answers the fol-
lowing three questions: (1) is GR(1) expressive enough to
support the Dwyer et al. patterns, which are well-recognized
as common in industrial specications?, (2) can the transla-
tion be done automatically (and correctly)?, and (3) what's
the extra cost of doing it (e.g., in number of auxiliary vari-
ables)?
To answer the rst two questions, we have implemented
and automated the translation, and our ndings show that
52 of the patterns from the original work of Dwyer et al. [16]
can be expressed as assumptions and guarantees in the GR(1)
fragment. Thus, we have indeed embedded the results of the
translation into our reactive synthesis environment. More-
over, as our translation is complete, our work shows that the
remaining 3 patterns are indeed not expressible as assump-
tions or guarantees in the GR(1) fragment by our approach.
To answer the third question, our pattern representation
in GR(1) requires at most 3 auxiliary variables per pattern
instance. This gives an upper bound for the complexity of
a GR(1) synthesis problem where patterns are used as as-
sumptions or guarantees. Note that this is a very satisfying
result, since based on the translation via a DBW, one could
enum 
MotorCmd 
FWD STP BWD enum 
LiftCmd 
LIFT DROP NIL enum 
Distance 
CLOSE FAR Figure 2: Enumeration datatypes of inputs and out-
puts of component ForkliftController
expect in the worst case an exponential number of auxiliary
variables per pattern.
The remainder of this paper is structured as follows. In
Sect. 2 we start with a running example. Sect. 3 provides
required formal background on LTL and GR(1). Sect. 4
presents the main technical contribution of our work, i.e.,
the translation from LTL specication patterns to equiva-
lent expressions in the GR(1) fragment. Sect. 5 describes
the implementation and Sect. 6 presents our results. The
paper concludes with a discussion in Sect. 7, related work in
Sect. 8, and future work in Sect. 9.
2. RUNNING EXAMPLE
We start o with a running example, adapted from our
specication of a Lego forklift, shown in Fig. 11, see [30].
The forklift has 3 sensors: one sensor to determine whether
it is at a station and two distance sensors to detect obstacles
and cargo. It also has 3 motors, to turn the left and right
wheels and to lift the fork. Values read by the sensors are
provided as inputs to component ForkliftController and
its outputs are commands controlling the motors. All inputs
and outputs are typed, e.g., the input obstacle has type
Distance . The datatypes are dened as enumerations in
Fig. 2.
An engineer species the behavior of the forklift controller
to synthesize an implementation. A simple safety guaran-
tee is that if the forklift detects an obstacle, both motors
are stopped (see ll. 1-2 in Listing 1). Another part of the
specication is the liveness guarantee to always eventually
deliver cargo (expressed as lift=DROP in ll. 4-5).
A property more complicated to express in pure LTL is
that the forklift has to leave its pick-up station between lift-
ing and dropping cargo. The engineer expresses this guar-
antee for the controller in ll. 7-9 using a higher-level speci-
cation pattern instantiated with values read by the sensors.
A second engineer assists in dening assumptions on the
environment of the forklift. One assumption is that going
forward with both motors will lead to reaching a station un-
less the motors are not going forward anymore (see pattern
used in ll. 11-13). It turns out that in order to satisfy this
assumption an adversary environment can prevent the fork-
lift from reaching a cargo station by presenting obstacles
forcing the forklift to stop (ll. 1-2). Hence, an additional
assumption for a well-behaved environment is added by the
engineers: in the given setting it is reasonable to expect
that between two stations, the forklift may be blocked by
obstacles at most twice. This assumption is expressed using
another specication pattern, shown in ll.15-17 of Listing 1.
The patterns used by the engineers in the forklift speci-
cation are LTL specication patterns as identied by Dwyer
et al. [16]. Their formal semantics, in LTL, taken from [16],
1Note that this is a real Lego robot that we have built. We
use our synthesis tool and code generation to run it.
97Specification
1GUARANTEE -- always stop if detect obstacle
2 G ( obstacle = CLOSE -> ( lMot = STP & rMot =STP ));
3
4GUARANTEE -- keep on delivering cargo
5 GF ( lift = DROP );
6
7GUARANTEE -- be not at station before delivery
8 (! atStation ) occurs between
9 ( lift = LIFT ) and ( lift = DROP ); --P09
10
11ASSUMPTION -- forwarding leads to station
12 Globally ( lMot =FWD & rMot = FWD ) leads to
13 ( atStation | !( lMot =FWD & rMot = FWD)); --P26
14
15ASSUMPTION -- at most blocked twice
16 After (! atStation ) have at most two
17 ( obstacle = CLOSE ) until ( atStation ); --P15
Listing 1: Excerpt of a specication for the forklift
controller
is given in Eqn. 1-3 below. However, most importantly for
our work, is that these LTL formulas are not written in the
syntactically restricted fragment of GR(1).
poccurs between qandr:=
[](q & !r -> (!r W (p & !r))) (1)
Globallypleads toq := [](p -> <>q) (2)
Afterqhave at most two puntilr:=
[](q -> ((!p & !r) U (r | ((p & !r) U
(r | ((!p & !r) U (r | ((p & !r) U
(r | (!p W r) | []p))))))))) (3)
The engineers are interested in using ecient GR(1) syn-
thesis to obtain a correct-by-construction controller for the
forklift robot, one which satises all guarantees if all assump-
tions are satised by the environment. Can a specication
including these patterns be written in a way that allows the
application of GR(1) synthesis?
Our work gives a positive answer to the above question.
Indeed, we show that all patterns used in the specication
of the forklift in Listing 1 (and actually almost all patterns
from [16], see Sect. 6), can be translated to the GR(1) frag-
ment. The translation is fully automated and requires the
addition of auxiliary Boolean variables to the synthesis prob-
lem, a total of 6 variables in our example. Although the
translation time may be double exponential in the length of
the formula, we have already done it, o line, so that the
patterns are added to our specication language and their
instantiation in a given specication takes constant time in
our tool.
As an example, the GR(1) representation of pattern P09
(Eqn. 1) requires two auxiliary variables to encode a new
variable sand is shown in Listing 2 in SMV-like syntax as
used by our implementation.
3. PRELIMINARIES
We repeat some of the standard denitions of B uchi au-
tomata and linear temporal logic (LTL), e.g., as found in [7,
26]. B uchi word automata are nite automata that accept
innite words over a nite alphabet.
Denition 1. A Buchi automaton is a tuple B= (Q;;;I;F )
where:SMV
1VAR -- auxiliary variables : states of DBW
2 s : {S1 , S2 , bot };
3INIT -- initial assignments : initial state
4 s=S1;
5TRANS -- safety this and next state
6((s=S1 & ( lift = DROP | atStation | lift != LIFT )
7 & X s=S1) |
8 (s=S1 & ( lift != DROP & ! atStation & lift = LIFT )
9 & X s=S2) |
10 (s=S2 & ( lift != DROP & ! atStation ) & X s=S2) |
11 (s=S2 & ( lift = DROP ) & X s=bot)|
12 (s=S2 & ( lift != DROP & atStation ) & X s=S1) |
13 (s=bot& ( TRUE ) & X s=bot));
14LTLSPEC -- justice part : accepting states
15 G F (s=S1 | s=S2);
Listing 2: The instance of LTL specication pattern
P09 from Listing 1, ll. 8-9, written in GR(1) SMV-
like syntax as used in our implementation
Qis the set of states
 is the alphabet
:QQis the transition relation
IQis the set of initial states
FQis the set of repeated states (B uchi condition)
A Buchi automaton is deterministic (a DBW) i jIj= 1
and8q;u:jfq0s.t. (q;u;q0)2gj 1. A B uchi automaton
is complete i8q;u9q0: (q;u;q0)2.
An accepting run of Bon a word u0u1::2!is a se-
quenceq0q1::of states from Qsuch thatq02I,8i0 :
(qi;ui;qi+1)2, and some q2Fappears innitely often in
the run. The set of words accepted by Bis denotedL(B).
We now repeat the denition of LTL, a modal temporal
logic with modalities referring to time. LTL allows engineers
to express properties of executions of reactive systems. The
syntax of LTL formulas is typically dened over a set of
atomic propositions APwith the future temporal operators
X(next) and U(until) and the past time temporal operators
Y(previous) and S(since).
Denition 2. The syntax of LTL formulas over APis
'::=pj:'j'_'jX'j'U'jY'j'S'forp2AP.
For  = 2APa computation u=u0u1::2!is a sequence
whereuiis the set of atomic propositions that hold at the
i-th position. For position iwe useu;ij='to denote that
'holds at position i, inductively dened as:
u;ij=pip2ui
u;ij=:iu;i6j=
u;ij='1_'2iu;ij='1oru;ij='2
u;ij=X'iu;i+1j='
u;ij='1U'2i9ki:u;kj='2and
8j;ij <k :u;jj='1
u;ij=Y'iu;i 1j='
u;ij='1S'2i9k;0ki:u;kj='2and
8j;k<ji:u;jj='1
We denote u;0j='byuj='. Additional LTL operators
are dened as abbreviations of the above:
F':=trueU'(nally)
G':=:F:'(globally)
'1W'2:= ('1U'2)_G'1(weak until)
H':=:(trueS:') (historically)
98LTL formulas can be used as specications of reactive sys-
tems where atomic propositions are interpreted as environ-
ment (input) and system (output) variables.
An LTL specication 'is realizable if a fairness-free au-
tomaton (B uchi automaton without acceptance condition)
exists such that all runs of the automaton are accepted by
'[7]. This automaton is called a controller. The goal of LTL
synthesis is, given an LTL specication, to nd a controller
that realizes it, if such a controller exists.
GR(1) synthesis [7] handles a fragment of LTL where spec-
ications contain assertions over initial states, safety con-
straints relating the current and next state, and justice goals
requiring that an assertion holds innitely many times dur-
ing a computation. A GR(1) synthesis problem is dened as
a game between a system player and an environment player,
with the following game structure [7]:
X input variables controlled by the environment
Youtput variables controlled by the system
eassertion overXcharacterizing initial states of the
environment
sassertion overX[Y characterizing initial states of
the system
e(X[Y;X) transition relation of the environment
s(X[Y;X[Y ) transition relation of the system
'=GFJe!GFJswinning condition as implication
between justice goals Jeof the environment and Jsof
the system.
The game has a winning strategy for the system, i.e., the
system player can always win following this strategy, i the
following LTL specication 'Gis realizable [7]:
'G= (e!s)^(e!G((He)!s))^(e^Ge!'):
Specications for GR(1) synthesis have to be expressible in
the above game structure and thus do not cover the complete
LTL. Ecient symbolic algorithms for GR(1) realizability
checking and controller synthesis have been presented in [7,
34].
4. FROM LTL SPECIFICATION PATTERNS
TO GR(1)
We are now ready to present the main technical contribu-
tion of our work, i.e., the translation from LTL specication
patterns to equivalent expressions in the GR(1) fragment, if
such an expression exists.
The main idea of our approach is to translate the LTL
formula of a specication pattern to a DBW, if such DBW
exists. We then translate the DBW to an LTL formula in the
GR(1) fragment. This translation may add auxiliary vari-
ables. This approach enables us to use existing algorithms
for GR(1) synthesis to solve the syntactically enriched syn-
thesis problem of specications containing LTL specication
patterns as assumptions and guarantees.
We show that our translation, if DBWs for all patterns
exist, is correct for the synthesis problem realizing the spec-
ication
(e^Ge^^
0<ijGFJe
i^^
j<im e
i)!
(s^Gs^^
0<ikGFJs
i^^
k<in s
i) (4)
S1 
S2 r  | p | !q
!r & ! p &q
!r &  !p!r &pS1 
S2 ‚ä•true 
rFigure 3: DBW for the LTL specication pattern
P09 in Eqn. 1
wheree,s,e, andsare in the GR(1) fragment, Je
iare
jjustice assumptions, Js
iarekjustice guarantees,  e
iare
m jLTL specication patterns used as assumptions, and
 s
iaren kpatterns used as guarantees.
In our running example, the specication shown in List-
ing 1 is represented in the above format where the rst guar-
antee (l. 2) is a conjunct of s, the second guarantee (l. 5)
is aJs
i, the pattern of the third guarantee (ll. 8-9) is a  s
i,
and the two patterns used as assumptions (ll. 11-17) appear
as two e
i.
We show the translation, prove its correctness, and dis-
cuss the time complexity for solving the synthesis problem
using existing algorithms, which depends on the auxiliary
variables added during our translation.
4.1 Translation
Our translation of the specication given in Eqn. 4 com-
bines two constructions from [7]: (a) for solving the GR(1)
implication specication, i.e., Eqn. 4 without LTL specica-
tion patterns  e
iand s
i, and (b) for solving the implication
specication between DBWs with additional variables rep-
resenting their states. Construction (a) adds two Boolean
monitor variables sfe(observing historical satisfaction of e
ande) and sfs(observingsands), the justice assump-
tion GFsfe, and the justice guarantee GFsfs[7, Sect. 5.1].
Intuitively this construction turns safety violations into jus-
tice violations. We apply (a) directly to Eqn. 4 without the
patterns e
iand s
i, which are handled by (b). Construction
(b) adds variables representing the states of each complete
DBW, its initial states, transitions, and acceptance condi-
tion to the game construction [7, Sect. 5.3].
To apply construction (b) we rst translate each LTL spec-
ication pattern into a corresponding DBW (if such a DBW
exists for the pattern), and then transform this DBW into
the initial, safety, and justice constraints for the construc-
tion of the GR(1) game. The problem of translating an
LTL formula into a DBW (if one exists) is well-studied and
algorithms and tools are available [2, 15]. As an example
the LTL specication pattern in Eqn. 1 has a corresponding
DBW with three states shown in Fig. 3. We now show how
to translate a DBW into the parts required for the GR(1)
construction.
4.1.1 DBW2GR1 Construction
Given a DBWB= (Q;;;fqIg;F) with alphabet  =
2X[Ywe obtain an LTL formula 'in the GR(1) fragment
over the alphabet 0= 2X[Y[VwhereXandYare sets
of Boolean input and output variables resp. and Vis a set
of auxiliary Boolean variables added by the translation to
encode the states of the DBW. Our translation creates '
using three subformulas where encodes the initial state,
99SMV
1VAR -- auxiliary variables : states of DBW
2 s : {S1 , S2 , bot };
3INIT -- initial assignments : initial state
4 s=S1;
5TRANS -- safety this and next state
6 ((s=S1 & ( r | p | !q) & X s=S1) |
7 (s=S1 & (!r & !p & q) & X s=S2) |
8 (s=S2 & (!r & !p ) & X s=S2) |
9 (s=S2 & ( r ) & X s= bot)|
10 (s=S2 & (!r & p ) & X s=S1) |
11 (s=bot & ( TRUE ) & X s= bot ));
12LTLSPEC -- justice part : accepting states
13 G F (s=S1 | s=S2);
Listing 3: Output of DBW2GR1, for the DBW of
the LTL specication pattern P09 in Eqn. 1, shown
in Fig. 3
encodes the transition relation as safety properties over
the current and next state, and Jencodes the acceptance
condition of the DBW as a justice constraint. The injective
function mapV:Q!2Vmaps states of the DBW to valua-
tions of the auxiliary variables introduced by the translation.
Formally:
VARVis set ofk=dlog2jQjefresh Boolean variables
INIT
:=mapV(qI)
TRANS
:=_
(q;u;q0)2(mapV(q)^u^X mapV(q0))
JUSTICE
J:=_
q2FmapV(q)
The LTL formula that characterizes the acceptance of the
DBWB
ifor2fe;sgresulting from the pattern  
i, is
the conjunction '
i=
i^G
i^GFJ
iobtained from the
translation above. Note that this translation, from DBW to
GR(1), is linear in the size of the DBW.
In our running example, the DBW shown in Fig. 3, which
represents the pattern P09, is translated to a formula with
the structure of '
iin the GR(1) fragment, as shown in List-
ing 3 in the SMV-like syntax used by our implementation.
The rst part of the translation creates a set of auxiliary
variables to represent the states of the DBW. In Listing 3
we use a single variable s(l. 2) for better readability instead
of two Boolean variables encoding the values of s. The trans-
lation part INIT sets the initial assignment of the auxiliary
variable (encoded in l. 4) to represent the initial state of
the DBW from Fig. 3. The part TRANS lists the tran-
sition relation as constraints over current state, current
input, and next state ( Gencoded in ll.6-11). Finally the
acceptance of the DBW is translated in part JUSTICE to
the disjunction of always eventually visiting one of the ac-
cepting states ( GFJencoded in l. 13).
Note that the result of DBW2GR1 as shown in Listing 3
is a template where variables p,q, and rcan be instantiated
with non-temporal assertions. This is the same instantiation
mechanism used for the original LTL patterns.4.1.2 Game Construction
The game for GR(1) synthesis based on this translation,
combining constructions (a) and (b), has the following struc-
ture for specications as shown in Eqn. 4:
X0=X
Y0=Y[f sfe;sfsg[S
j<imVe
i[S
k<inVs
i
e=true
s= (e$sfe)^(s$sfs)^V
j<ime
i^V
k<ins
i
e=true
s= ((e^sfe)$Xsfe)^((s^sfs)$Xsfs)^V
j<ime
i^V
k<ins
i
'= (GFsfe^GFJe^V
j<imGFJe
i)!
(GFsfs^GFJs^V
k<inGFJs
i):
We use the GR(1) synthesis algorithm of [7] to solve this
game. Theorem 1 (below) states that a winning strategy for
the system player in the above game indeed implements the
specication in Eqn. 4, and that such a strategy is found if
it exists.
Note that for each specication pattern, the translation
above depends on the existence of a DBW for the pattern.
Some LTL formulas cannot be expressed as a DBW [26]
and our translation thus handles only a subset of LTL. As
we show in Sect. 6, almost all LTL patterns from [16] do
have a corresponding DBW, and hence, are supported by
our translation.
4.2 Translation Correctness
For two words w2!andv2(2V)!we denote as wv2
([2V)!the word where ( wv)i=wi[vi.
Lemma 1 (DBW2GR1 is correct) .Given a complete DBW
B, the LTL formula '=^G^GFJresulting from the trans-
lation in Sect. 4.1 is in the GR(1) fragment and satises:
8w2!:w2L(B)$9v2(2V)!:wvj='.
Proof. By construction andJhave no temporal operators
anduses only the next operator, so 'is in the supported
GR(1) fragment. We show bidirectional acceptance:
"!":8w=w0w1::2!:w2L(B) the DBW has by
denition of determinism a unique run q=q0q1::2Q!with
qI=q0and8i: (qi;wi;qi+1)2. Forv2(2V)!with
8i:vi=mapV(qi) we have: wvj=by construction and
denition of v0. Analogously,8i: (qi;wi;qi+1)2yields
(wv);ij=, thus (wv)j=G. Since some qi2F
appears innitely often in the run qit is encoded innitely
often invand thuswvj=GFJ.
" ": Given8w=w0w1::2!:9v2(2V)!:wvj=':
fromwvj=we know that map 1
V(v0) =qIand from
8i: (wv);ij=we know that vmust encode an innite
runqofBwith8i:qi=map 1
v(vi) and (qi;wi;qi+1)2.
Due to determinism of Band injectiveness of mapVthe run
is unique and exists i ( wv)j=G. Since the run is unique
from (wv)j=GFJwe know that a state in FofBis visited
innitely often and Bacceptsw.
Theorem 1. Given a specication in the form of Eqn. 4
where e
iand s
ican be translated into DBWs our construc-
tion synthesizes a controller implementing the specication,
if one exists.
Proof. The correctness of construction (a) is shown in [7,
Thm. 5]. The correctness of construction (b) is shown in
100[7, Thm. 7]. The proof of (b) requires completeness and
determinism of the B uchi automata. The DBW we use are
complete and in Lemma 1 we showed that our translation
from Sect. 4.1 correctly represents the DBW in the GR(1)
fragment.
4.3 Complexity Analysis
It is known that the worst-case time complexity for the
synthesis of a controller for an open reactive system from
a general LTL specication 'is double exponential in the
length of the input formula, i.e., in O(22j'j) [35]. In contrast,
the worst-case time complexity of synthesizing a controller
for a GR(1) specication is in O(nmN2) wherenandmare
the number of justice goals of the environment and system
players respectively, and Nis the size of the state space.
Since we use GR(1) synthesis, the algorithm's complex-
ity is not changed. However, our construction increases the
state space for the algorithm. Instead of a state space N
of sizeO(2jXj+jYj), whereXandYare the sets of Boolean
environment and system variables, we have a state space of
sizeO(2jXj+jYj+jVj), wherejVjis the total number of addi-
tional, auxiliary variables.
Each supported pattern may add a justice goal to either m
orn, anddlog2jQjevariables where Qis the set of states of
the DBW corresponding to the pattern. In general, the size
of a DBW corresponding to an LTL formula, if one exists,
may be double exponential in the length of the formula [28].
Thus, the number of variables added per pattern, is in the
worst case exponential in the length of the pattern.
Most importantly however, this high worst-case
complexity does not apply to the LTL patterns of [16].
Our results, presented in Sect. 6, show that 52 of
these patterns have a corresponding DBW with at
most 8 states (the remaining 3 patterns do not have
a corresponding DBW at all), so only at most 3 vari-
ables need to be added for each of these patterns.
5. IMPLEMENTATION
5.1 Overview
We have implemented the translation DBW2GR1 and set up
a toolchain to (1) check for all patterns from [16] whether
they can be supported by our approach and at what cost in
terms of auxiliary variables, and (2) provide fully automated
support of patterns in our GR(1) synthesis environment.
The cost of supporting an LTL specication pattern  in
GR(1) synthesis, following the translation in Sect. 4.1, de-
pends on the size of the DBW found for  . Given a pattern
we are thus interested in a smallest DBW representing it.
However, the smallest DBW is not necessarily unique and
DBW minimization is NP-hard [38].
Given the high cost of obtaining a GR(1) representation
of an LTL pattern we decided to do this computation of-
ine, i.e., independent of the instantiation of a pattern and
the specication it is used in. This works because patterns
are only instantiated with non-temporal propositions (in
Sect. 7.3 we second this limitation and show that they can be
instantiated also with past LTL formulas), and their GR(1)
representations can thus be used as templates. Thus, the
output of applying our toolchain to the 55 patterns from [16]
is a catalog of GR(1) templates, available from [40], together
with the DBW2GR1 tool. When preparing a pattern-based
LTL3DRA DBAMinimizer DBW2GR1 
LTL 
Specification 
Pattern Template for 
GR(1) 
Synthesis DRA SPOT ltlfilt LTL DBW 
Support 
unknown Pattern not 
supported fail no 
checking correctness of toolchain output using NuSMVFigure 4: The toolchain we have used, per pattern,
to create the GR(1) templates (the dashed parts are
used for validation, see Sect. 6.2)
specication for synthesis, we do not need to recompute the
translation of each pattern to an equivalent GR(1) formula
but only to look up the GR(1) template that corresponds to
the pattern in the catalog.
Below we give additional details about the toolchain we
have used to create the catalog.
5.2 Toolchain
To decide whether an LTL specication pattern can be
supported and to nd the minimal DBW we use a combina-
tion of tools. Fig. 4 shows our toolchain. The input is an
LTL specication pattern and the output is either, a tem-
plate for synthesis in GR(1) format, a negative result that
no such template exists, or an indeterminate result that the
existence of such a template is unknown.
We start with the tool ltlfilt ofSPOT [15], to syntacti-
cally preprocess the LTL formula of the pattern to a format
readable by the next tool, LTL3DRA . We use LTL3DRA [2] to
compute a deterministic Rabin automaton (DRW) from an
LTL formula. LTL3DRA is a competitor of LTL2DSTAR [23]
that often yields smaller DRW for LTL formulas, e.g., when
trying the two tools, we saw that a DRW for pattern P45
found by LTL2DSTAR (version 0.5.1 with LTL3BA [3]) has 2184
states while a DRW for the same pattern found by LTL3DRA
has 40 states. Both tools rely on heuristics to create smaller
DRWs. Next, given a DRW, we use DBAMinimizer [17] to
determine whether a corresponding DBW exists and to nd
a minimal one. DBAMinimizer uses a SAT solver to nd a
minimal DBW. Finally, we feed the minimal DBW found by
DBAMinimizer to our tool DBW2GR1 , to obtain a template for
instantiating LTL specication patterns in GR(1) specica-
tions as described in Sect. 4.1.
6. RESULTS AND OBSERVATIONS
Table 1 presents our main result: 52 of the 55 patterns
of [16] are supported by our approach. The cost per
supported pattern instance is at most 3 auxiliary
variables. The remaining 3 patterns P23, P50, and
P55, do not have a corresponding DBW.
The table contains all LTL patterns from [16] grouped by
kind, e.g., absence or existence, and ordered by scope (sec-
ond column), e.g., globally or before, following the classica-
tion presented in [16]. For each pattern we report the length
(third column) of the LTL formula that denes the seman-
tics of the pattern (number of characters including spaces,
e.g., P01 dened as [](!p) has length 6). The fourth col-
umn of the table reports the number of states of a minimal
DBW for the pattern if one exists and n.a. otherwise; the
fth indicates whether the minimal DBW has a sink state (a
complete DBW without a sink state expresses a pure liveness
101Table 1: The 55 LTL specication patterns from [16], with
LTL formula length, number of states of minimal DBW,
whether DBW has a sink, and number of auxiliary variables
in GR(1) template.
LTL DBW DBW GR(1)
P# Scope j jmin jQjSink? jVj
Absence: p is false
P01 Globally 6 2 1 1
P02 Before r 15 4 1 2
P03 After q 15 3 1 2
P04 Between q and r 30 4 1 2
P05 After q until r 22 3 1 2
Existence: p becomes true
P06 Globally 5 2 0 1
P07 Before r 13 3 1 2
P08 After q 20 3 0 2
P09 Between q and r 29 3 1 2
P10 After q until r 29 3 1 2
Bounded Existence: p-states occur at most 2 times
P11 Globally 30 6 1 3
P12 Before r 93 8 1 3
P13 After q 50 7 1 3
P14 Between q and r 103 8 1 3
P15 After q until r 101 7 1 3
Universality: p is true
P16 Globally 5 2 1 1
P17 Before r 14 4 1 2
P18 After q 14 3 1 2
P19 Between q and r 29 4 1 2
P20 After q until r 21 3 1 2
Precedence: s precedes p
P21 Globally 6 3 1 2
P22 Before r 21 4 1 2
P23 After q 23 n.a. n.a. n.a.
P24 Between q and r 36 4 1 2
P25 After q until r 28 3 1 2
Response: s responds to p
P26 Globally 12 2 0 1
P27 Before r 33 4 1 2
P28 After q 21 3 0 2
P29 Between q and r 48 4 1 2
P30 After q until r 42 4 1 2
Precedence Chain: s, t precedes p
P31 Globally 34 4 1 2
P32 Before r 40 5 1 3
P33 After q 56 5 1 3
P34 Between q and r 50 5 1 3
P35 After q until r 51 4 1 2
Precedence Chain: p precedes s, t
P36 Globally 28 4 1 2
P37 Before r 51 5 1 3
P38 After q 54 5 1 3
P39 Between q and r 61 5 1 3
P40 After q until r 69 4 1 2
Response Chain: p responds to s, t
P41 Globally 33 4 1 2
P42 Before r 48 6 0 3
P43 After q 46 5 0 3
P44 Between q and r 59 8 0 3
P45 After q until r 96 6 0 3
Response Chain: s, t responds to p
P46 Globally 22 5 0 3
P47 Before r 45 5 1 3
P48 After q 31 5 1 3
P49 Between q and r 56 5 1 3
P50 After q until r 74 n.a. n.a. n.a.
Constrained Chain: s, t without z responds to p
P51 Globally 32 6 1 3
P52 Before r 57 5 1 3
P53 After q 40 5 1 3
P54 Between q and r 68 5 1 3
P55 After q until r 96 n.a. n.a. n.a.property). Finally, the last column reports on the number
of auxiliary variables necessary to support the pattern fol-
lowing our DBW2GR1 construction described in Sect. 4.
Some examples of the LTL patterns and the GR(1) tem-
plates we have computed for them are detailed in Table 2.
Based on this table, our synthesis tool accepts specications
with assumptions and guarantees written using patterns, as
shown in the second column of the table, and automatically
instantiate them in a form that allows GR(1) synthesis based
on the template in the fourth column. List. 1 is an example
of a specication handled by our environment.
6.1 Unsupported Patterns
The three LTL patterns where a DBW does not exist are
theprecedence pattern P23 with scope after q and LTL
semantics []!q | <>(q & (!p W s)) ,
theresponse chain pattern P50 with scope after q until
rand LTL semantics [] (q -> (p -> (!r U (s & !r
& X(!r U t)))) U (r | [] (p -> (s & X<> t)))) ,
and
theconstrained chain pattern P55 with scope after q
until r and LTL semantics [] (q -> (p -> (!r U (s
& !r & !z & X((!r & !z) U t)))) U (r || [] (p -
> (s & !z & X(!z U t))))) .
It is important to note, however, that these three patterns,
which we cannot support, are among the least frequent pat-
terns according to the survey reported in [16]. Specically,
out of 555 pattern instances examined in [16], only one was
in the form of P23. The other two patterns, P50 and P55, are
listed in [16] in order to make the matrix of pattern/scope
combinations complete, but in the survey of [16], were not
found at all. This further strengthens the positive, promis-
ing nature of our results.
6.2 Validation
The correctness of the GR(1) templates resulting from
LTL patterns relies on a toolchain with four tools of which
some are prototypical implementations and proofs of con-
cept. These may have bugs or we might have used them
incorrectly. It is thus advised to validate the correctness
of the generated GR(1) templates. To address this, we have
implemented a correctness check that takes the original LTL
pattern and the generated GR(1) template, augments it for
verication, and automatically checks correctness using the
model checker NuSMV [10].
We generate two checks for each generated GR(1) tem-
plate. The rst check asserts the equivalence of the satisfac-
tion of the generated JUSTICE formulaJand the satisfaction
of the original LTL semantics of the pattern  with GR(1)
representation ^G^GFJ. By construction of our transla-
tion (see, e.g., List. 3), this check relies on the assignments
to auxiliary variables in the blocks INIT (encoding) and
TRANS (encoding G). The construction of [7] for supporting
a DBW in GR(1) specications requires that the DBW is
complete, i.e., that the automaton has an enabled transi-
tion for every source state and input. We thus generate a
second check, which asserts that all combinations of values
assigned to variables representing the parameters of the pat-
tern are accepted in every state of the automaton dened in
the generated GR(1) template.
Initially, our validation reported incorrect templates for
three out of the 52 supported patterns and their 41 sup-
102ported negations (see Sect. 7.4), specically for pattern P51
and the negations of P15 and P42. Inspection revealed incor-
rect translation by LTL3DRA . For at least 3 out of the 110 pro-
vided LTL formulas, LTL3DRA produced an incorrect DRW!
This issue appears in version 0.1.1 (2013-09-09), used for our
experiments, and persists in version 0.2.1 (2015-02-08) of
LTL3DRA .2To bypass this bug in LTL3DRA , we reran all non-
validated LTL to DRW translations using LTL2DSTAR [23],
for the 3 incorrect DRWs and the 14 cases where an equiva-
lent DBW could not be found. This second experiment con-
rmed the non-existence of a DBW in all cases established
using LTL3DRA and produced correct DRWs, so we were -
nally able to successfully validate our GR(1) templates for
the three remaining cases.
Thus, we have successfully validated the nal output of
our toolchain for all templates produced and embedded in
our tool. The generated templates and checks used for
verication are available for inspection and reproduction
from [40].
6.3 Threats to Validity
We briey discuss threats to the internal and external
validity of our results.
First, the computation of the results that we present in Ta-
ble 1 relies on a toolchain with four tools of which some are
prototypical implementations and proofs of concept. These
may have bugs or we might have used them incorrectly. To
mitigate this and validate the correctness of our results and
generated catalog of GR(1) templates, we validated our re-
sults as described in Sect. 6.2 above.
Second, the origin of the specication patterns of Dwyer
et al. may be viewed as another threat to the validity of
our approach. These patterns were extracted from indus-
trial and academic specications used for model checking,
not for synthesis. It may be the case that specications
written for synthesis have (or should better have) dierent
characteristics, or use other patterns. We are unaware of
any comparable studies for synthesis or studies analyzing
the dierence between specications for verication and for
synthesis. Thus, we believe, using the Dwyer et al. patterns
in our context is reasonable.
7. DISCUSSION AND EXTENSIONS
We now discuss several important features as well as ex-
tensions of our work.
7.1 Completeness
We are interested in the completeness of results provided
by our toolchain, i.e., if a DBW for an LTL pattern exists,
is it found by our toolchain?
The rst tool in our toolchain, SPOT, performs purely syn-
tactic preprocessing and preserves completeness.
While a DRW can express any LTL formula [26], the sec-
ond tool in our toolchain, LTL3DRA , only supports the trans-
lation of a fragment of LTL to DRW [2]. Thus, in theory,
the second step is incomplete: if the translation fails it is
not known whether the pattern can be supported or not
(see Fig. 4). However, as our results show (see Sect. 6),
2A formula outside the LTL fragment supported by
LTL3DRA (see [2]) might result in an incorrect DRW. Start-
ing from version 0.2.2 (2015-06-15) the fragment is checked.for all patterns from [16] this case never happened; LTL3DRA
always produced a DRW.
In the third step in the toolchain, if a DBW exists for the
given DRW, it is found by DBAMinimizer . In case DBAMin-
imizer gives a negative result, no DBW exists and the pat-
tern cannot be supported. In our results, this negative result
was returned for only three of the patterns, as presented in
Sect. 6.
Finally, our own tool, DBW2GR1 , always computes a GR(1)
template for a DBW. Thus, overall, although the toolchain
is theoretically incomplete (due to the second tool LTL3DRA ),
on our data of 55 patterns it was complete.
Two more remarks are of interest. First, to address the
potential incompleteness of the analyses by LTL3DRA , e.g., if
using the toolchain with additional LTL formulas as input,
one can use general LTL synthesis tools such as Lily [21] or
Acacia+ [8] to synthesize a DBW directly. This DBW can
again be minimized using DBAMinimizer . In practice, we
did not need this alternative toolchain, because for all the
patterns from [16], our toolchain provided a denite result.
Second, from a practical point of view, if a DBW is found,
it might be too big for ecient analysis by DBAMinimizer .
We have encountered this problem for patterns P49 and P54,
where the SAT formula generated by DBAMinimizer in DI-
MACS CNF format was exceeding a size of 110GB. To solve
this problem, we modied the search strategy and DBW re-
construction of DBAMinimizer to handle these cases. Techni-
cally the modication allowed us to guess and check a small
size DBW resulting in smaller SAT problems, small enough
for ecient analysis by DBAMinimizer .
7.2 Generalized Rabin(1) Synthesis and Re-
maining Patterns
Ehlers [18] has extended GR(1) synthesis, where assump-
tions and guarantees can be expressed as DBWs, to General-
ized Rabin(1) synthesis, where assumptions and guarantees
can be expressed as DRWs with one acceptance pair. DRWs
with one acceptance pair are more expressive than DBWs.
We now discuss how our results from Sect. 6 directly transfer
to GRabin(1) synthesis.
The complexity of GRabin(1) synthesis depends on the
size of the DRWs used as assumptions and guarantees. For
52 of the 55 patterns from [16] we have computed minimal
DBWs, which directly translate to DRWs of the same struc-
ture and size by adapting their acceptance condition [26].
DRWs are DBW-type [27], i.e., given a DRW for language
L, if a DBW for Lexists, the DBW has the same structure
as the DRW. Thus, a minimal DBW has the size of a min-
imal DRW accepting the same language since the existence
of smaller DRW would contradict minimality of the DBW.
Thus, for the 52 supported patterns our approach provides
not only minimal DBWs but also minimal DRWs for GRa-
bin(1) synthesis.
7.3 Incorporating the Past
In [7] it was shown how to incorporate past LTL formulas
into the GR(1) fragment. Specically, this is done by trans-
lating each past LTL formula into a deterministic temporal
tester [7, Sect. 5.2]. This requires the addition of auxiliary
variables to encode the states of the temporal tester and
its acceptance, i.e., satisfaction of the past LTL formula.
The acceptance expression is a non-temporal formula that
replaces the past LTL subformula. The approach is compo-
103Table 2: Patterns P09, P15, and P26 used in the forklift specication shown in Listing 1, their LTL semantics (from [16]),
and the corresponding GR(1) templates we have generated for them.
Pattern English (kind and scope) LTL semantics  GR(1) template
P09poccurs between qandr [](q & !r -> (!r W (p & !r))) :=s=S1
:=((s=S1 & ( r | p | !q) & X s=S1) |
(s=S1 & (!r & !p & q) & X s=S2) | (s=S2
& (!r & !p) & X s=S2) | (s=S2 & (r) &
X s=bot)| (s=S2 & (!r & p) & X s=S1) |
(s=bot & (TRUE) & X s=bot))
J:=(s=S1 | s=S2)
P15 Afterqhave at most two p
untilr[](q -> ((!p & !r) U (r | ((p &
!r) U (r | ((!p & !r) U (r | ((p &
!r) U (r | (!p W r) | []p))))))))):=s=S1
:= ((s=S1 & (!q & !r | r) & X s=S1) |
(s=S1 & (q & !p & !r) & X s=S2) | (s=S1
& (q & p & !r) & X s=S3) | (s=S2 & (r) &
X s=S1) | (s=S2 & (!p & !r) & X s=S2) |
(s=S2 & (p & !r) & X s=S3) | (s=S3 & (r)
& X s=S1) | (s=S3 & (p & !r) & X s=S3)
| (s=S3 & (!p & !r) & X s=S4) | (s=S4
& (r) & X s=S1) | (s=S4 & (!p & !r) &
X s=S4) | (s=S4 & (p & !r) & X s=S5) |
(s=S5 & (r) & X s=S1) | (s=S5 & (p & !r)
& X s=S5) | (s=S5 & (!p & !r) & X s=S6)
| (s=S6 & (r) & X s=S1) | (s=S6 & (!p
& !r) & X s=S6) | (s=S6 & (p & !r) & X
s=bot) | (s=bot & (TRUE) & X s=bot))
J:=(s=S1 | s=S2 | s=S3 | s=S4 | s=S5 |
s=S6)
P26 Globallypleads toq [](p -> <>q) :=s=S1
:=((s=S1 & (p & q | !p) & X s=S1) |
(s=S1 & (p & !q) & X s=S2) | (s=S2 & !q
& X s=S2) | (s=S2 & q & X s=S1))
J:=s=S1
sitional as long as only past LTL operators are nested within
a GR(1) formula.
It is important to note that the incorporation of the past
extends into our support for patterns. Specically, one may
use past LTL formulas within patterns. As an example, con-
sider a specication that says that the forklift has loaded
cargo when it leaves a station and does not drop it until it
arrives at a station. Our specication expresses this guar-
antee using pattern P20, instantiated in the rst parameter
with the past LTL formula lift!=DROP S lift=LIFT :
Globally (lift!=DROP S lift=LIFT) after
(!atStation) until (atStation) --P20
The past subformula is satised i cargo has not been
dropped since it was last lifted. Technically, our construc-
tion shown in Sect. 4.1 is extended to support past by trans-
lating past formulas to temporal testers and then instantiat-
ing the pattern of each template with the expression denot-
ing the acceptance of the tester. We omit the details from
this version of the paper.
7.4 Pattern Negations and Boolean Combina-
tions
Our translation goes through a DBW, but DBWs are not
closed under complement [26], i.e., the existence of a DBW
for pattern  gives no information about the existence of a
DBW for its negation : . Thus, it is interesting to check
whether these DBWs exist and whether our framework may
support the negation of patterns.
We examined the negation of all 55 patterns using our
toolchain and found that 41 negated patterns have a DBW
and thus a GR(1) template representation. The maximalsize of the minimal DBW for all pattern negations is again
8 states and so at most 3 auxiliary variables are required
to support a negated pattern instantiation. Pattern P23,
without a corresponding DBW, is supported in its negated
form. For the two other unsupported patterns, P50 and P55,
the negation does not have a corresponding DBW. So, in our
synthesis tool, we support 41 pattern negations.
Finally, as DBWs are closed not only under intersection
(conjunction) but also under union (disjunction), our work
opens the way to support specications that include inter-
sections and unions over the 52 supported patterns and 41
supported pattern negations. We omit the details on how
this can be done from this version of the paper.
Conjunction, disjunction, and negation of patterns allow
for much exibility and expressiveness in writing the speci-
cation on the way to the symbolic GR(1) synthesis.
As an example consider an extended forklift with an emer-
gency o switch and the conditional guarantee to always
eventually get to a station if the emergency o switch is
never pressed between stations. The absence of the property
emgOff between stations can be expressed using pattern P04,
and the above guarantee can be written as an implication
between an instance of pattern P04 and pattern P26:
(emgOff) never occurs between
(!atStation) and (atStation) --P04
IMPLIES
Globally (!atStation) leads to (atStation) --P26
Note that the implication is supported by our approach
because it translates to a disjunction of the negation of pat-
tern P04, which has a corresponding GR(1) template, and
pattern P26.
1048. RELATED WORK
Specication patterns aim to assist engineers in the dif-
cult task of formally writing a specication. The work of
Dwyer et al. [16] on temporal property specications, which
we relate to in this paper, is the most well-known work in this
area. The patterns have been used and extended in many
tools and contexts, including, e.g., property elucidation and
natural language interfaces in Smith et al. work [39], run-
time verication in Bauer et al. work [4], and OCL in Dou
et al. work [13], to list a few. Related and extended patterns
have been investigated and proposed for service-based appli-
cations by Bianculli et al. [5], for real-time specications by
Konrad and Cheng [24], and for probabilistic specications
by Grunske [20]. A comprehensive framework for all of these
patterns have been recently suggested by Autili et al. [1].
Several LTL synthesis tools were presented in recent years,
e.g., Lily [21], Anzu [22], RATSY [6], Unbeast [19], and
Acacia+ [8]. Some of these tools handle general LTL spec-
ications while others focus on the GR(1) fragment. Our
own implementation of GR(1) synthesis is written on top
of JTLV [36], but the contribution of our present work does
not depend on a specic implementation of GR(1) synthesis.
Some of these tools support a combination of LTL formulas
and automata as input. To the best of our knowledge, none
of these synthesis tools and the works using them supports
high-level specication patterns as input.
GR(1) synthesis has been used and extended in dier-
ent contexts and for dierent application domains, including
robotics [25], scenario-based specications [32], aspect lan-
guages [31], and event-based behavior models [12], to name
a few.
Many works, including some by the rst listed author,
have presented case studies based on GR(1) or dealt with
unrealizability in the context of GR(1), e.g., [11, 22, 33, 37]
and some of the works listed in the previous paragraph. All
these works claimed that GR(1) is expressive enough to sup-
port most specications written in practice. To the best of
our knowledge, our work is the rst to examine this claim
against a concrete list of well-known patterns and thus to
strengthen it with evidence and practically integrate these
patterns into a synthesis tool.
9. CONCLUSION AND FUTURE WORK
In this paper we have showed that almost all of the LTL
specication patterns of Dwyer et al. [16] can be used as
assumptions and guarantees in GR(1) specications, which
have an ecient polynomial symbolic synthesis algorithm.
We have automated the process of translating the patterns
into corresponding GR(1) templates, and have integrated
them into our synthesis tool. We further proved that the
translation is correct, showed that it is complete for the
55 patterns of Dwyer et al., and validated its results us-
ing model-checking. The work provides evidence for the
strength of the GR(1) fragment.
We consider the following future work directions. First,
we plan to systematically examine possible support for addi-
tional specication patterns on top of the GR(1) fragment,
by reusing our toolchain and template generator and apply-
ing them to other forms of LTL specications. These in-
clude, for example, extensions of the Dwyer et al. patterns,
counting patterns (\after q,pbecomes true in at most / ex-
actly / at least ksteps / occurrences of r"), trigger patterns(which use regular expressions, as dened in Kupferman and
Vardi's trigger logic [29]), dierent variants of scenarios [32],
etc.
Furthermore, many recent works in the area of synthesis
deal with quantitative and probabilistic specications, see,
e.g., [9,14]. We plan to investigate if and how can quantita-
tive and probabilistic patterns, as identied, e.g., in [20,24],
be supported within the symbolic algorithm of GR(1).
Our work is part of a larger project on bridging the gap be-
tween the theory and algorithms of reactive synthesis on the
one hand and software engineering practice on the other. In
this project, we are building engineer-friendly tools around
reactive synthesis, for example to identify and x unrealiz-
ability (as in, e.g., [11, 33]) and to provide two-way trace-
ability between the assumptions and guarantees in the spec-
ication and the states and transitions of the synthesized
implementation. Both problems, dealing with unrealizabil-
ity and providing traceability, become more challenging in
the presence of patterns in the language used for specica-
tion.
The DBW2GR1 tool, the generated patterns catalog, and
the means to validate its correctness using model-checking,
all available from [40], have been successfully evaluated by
the Replication Packages Evaluation Committee and found
to meet expectations.
10. ACKNOWLEDGMENTS
We thank the anonymous reviewers for their helpful com-
ments. We thank Dafna Sadeh for her help with the im-
plementation of DBW2GR1. Jan O. Ringert acknowledges
support from a postdoctoral Minerva Fellowship, funded by
the German Federal Ministry for Education and Research.
This project has received funding from the European Re-
search Council (ERC) under the European Union's Horizon
2020 research and innovation programme (grant agreement
No 638049, SYNTECH).
11. REFERENCES
[1] M. Autili, L. Grunske, M. Lumpe, P. Pelliccione, and
A. Tang. Aligning Qualitative, Real-Time, and
Probabilistic Property Specication Patterns Using a
Structured English Grammar. IEEE Trans. Softw.
Eng., 2015.
[2] T. Babiak, F. Blahoudek, M. Kret nsk y, and
J. Strejcek. Eective Translation of LTL to
Deterministic Rabin Automata: Beyond the (F,
G)-Fragment. In ATVA , volume 8172 of LNCS , pages
24{39. Springer, 2013.
[3] T. Babiak, M. Kret nsk y, V. Reh ak, and J. Strejcek.
LTL to B uchi Automata Translation: Fast and More
Deterministic. In TACAS , volume 7214 of LNCS ,
pages 95{109. Springer, 2012.
[4] A. Bauer, M. Leucker, and C. Schallhart. Runtime
verication for LTL and TLTL. ACM Trans. Softw.
Eng. Methodol. , 20(4):14, 2011.
[5] D. Bianculli, C. Ghezzi, C. Pautasso, and P. Senti.
Specication patterns from research to industry: A
case study in service-based applications. In ICSE ,
pages 968{976. IEEE, 2012.
[6] R. Bloem, A. Cimatti, K. Greimel, G. Hoerek,
R. K onighofer, M. Roveri, V. Schuppan, and
105R. Seeber. RATSY - A new requirements analysis tool
with synthesis. In CAV , volume 6174 of LNCS , pages
425{429. Springer, 2010.
[7] R. Bloem, B. Jobstmann, N. Piterman, A. Pnueli, and
Y. Sa'ar. Synthesis of Reactive(1) Designs. J. Comput.
Syst. Sci. , 78(3):911{938, 2012.
[8] A. Bohy, V. Bruy ere, E. Filiot, N. Jin, and J. Raskin.
Acacia+, a tool for LTL synthesis. In CAV , volume
7358 of LNCS , pages 652{657. Springer, 2012.
[9] K. Chatterjee, T. A. Henzinger, B. Jobstmann, and
R. Singh. Measuring and synthesizing systems in
probabilistic environments. In CAV , volume 6174 of
LNCS , pages 380{395. Springer, 2010.
[10] A. Cimatti, E. M. Clarke, E. Giunchiglia,
F. Giunchiglia, M. Pistore, M. Roveri, R. Sebastiani,
and A. Tacchella. NuSMV 2: An OpenSource Tool for
Symbolic Model Checking. In CAV , volume 2404 of
LNCS , pages 359{364. Springer, 2002.
[11] A. Cimatti, M. Roveri, V. Schuppan, and
A. Tchaltsev. Diagnostic information for realizability.
InVMCAI , volume 4905 of LNCS , pages 52{67.
Springer, 2008.
[12] N. D'Ippolito, V. A. Braberman, N. Piterman, and
S. Uchitel. Synthesizing nonanomalous event-based
controllers for liveness goals. ACM Trans. Softw. Eng.
Methodol. , 22(1):9, 2013.
[13] W. Dou, D. Bianculli, and L. C. Briand. OCLR: A
more expressive, pattern-based temporal extension of
OCL. In ECMFA , volume 8569 of LNCS , pages 51{66.
Springer, 2014.
[14] K. Dr ager, V. Forejt, M. Z. Kwiatkowska, D. Parker,
and M. Ujma. Permissive controller synthesis for
probabilistic systems. In TACAS , volume 8413 of
LNCS , pages 531{546. Springer, 2014.
[15] A. Duret-Lutz and D. Poitrenaud. SPOT: an
extensible model checking library using
transition-based generalized b uchi automata. In
MASCOTS , pages 76{83. IEEE Comp. Soc., 2004.
[16] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett.
Patterns in property specications for nite-state
verication. In ICSE , pages 411{420. ACM, 1999.
[17] R. Ehlers. Minimising deterministic B uchi automata
precisely using SAT solving. In SAT, volume 6175 of
LNCS , pages 326{332. Springer-Verlag, 2010.
[18] R. Ehlers. Generalized Rabin(1) synthesis with
applications to robust system synthesis. In NASA
Formal Methods , volume 6617 of LNCS , pages
101{115. Springer, 2011.
[19] R. Ehlers. Unbeast: Symbolic bounded synthesis. In
TACAS , volume 6605 of LNCS , pages 272{275.
Springer, 2011.
[20] L. Grunske. Specication patterns for probabilistic
quality properties. In ICSE , pages 31{40. ACM, 2008.
[21] B. Jobstmann and R. Bloem. Optimizations for LTL
synthesis. In FMCAD , pages 117{124. IEEE, 2006.
[22] B. Jobstmann, S. J. Galler, M. Weiglhofer, and
R. Bloem. Anzu: A tool for property synthesis. In
CAV , volume 4590 of LNCS , pages 258{262. Springer,
2007.
[23] J. Klein and C. Baier. On-the-y stuttering in the
construction of deterministic omega -automata. InCIAA , volume 4783 of LNCS , pages 51{61. Springer,
2007.
[24] S. Konrad and B. H. C. Cheng. Real-time specication
patterns. In ICSE , pages 372{381. ACM, 2005.
[25] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas.
Temporal-logic-based reactive mission and motion
planning. IEEE Trans. Robotics , 25(6):1370{1381,
2009.
[26] O. Kupferman. Automata Theory and Model
Checking. In E. Clarke, T. A. Henzinger, and
H. Veith, editors, Handbook of Theoretical Computer
Science , chapter 7. Springer, 2015.
[27] O. Kupferman, G. Morgenstern, and A. Murano.
Typeness for omega-regular automata. Int. J. Found.
Comput. Sci. , 17(4):869{884, 2006.
[28] O. Kupferman and A. Rosenberg. The blowup in
translating LTL to deterministic automata. In 6th Int.
Work. on Model Checking and AI (MoChArt) , volume
6572 of LNCS , pages 85{94. Springer, 2010.
[29] O. Kupferman and M. Y. Vardi. Synthesis of trigger
properties. In LPAR , volume 6355 of LNCS , pages
312{331. Springer, 2010.
[30] S. Maoz and J. O. Ringert. Synthesizing a Lego
Forklift Controller in GR(1): A Case Study. In Proc.
4th Workshop on Synthesis (SYNT), co-located with
CAV , 2015. To appear.
[31] S. Maoz and Y. Sa'ar. AspectLTL: an aspect language
for LTL specications. In P. Borba and S. Chiba,
editors, AOSD , pages 19{30. ACM, 2011.
[32] S. Maoz and Y. Sa'ar. Assume-guarantee scenarios:
Semantics and synthesis. In MODELS , volume 7590 of
LNCS , pages 335{351. Springer, 2012.
[33] S. Maoz and Y. Sa'ar. Counter play-out: executing
unrealizable scenario-based specications. In ICSE ,
pages 242{251. IEEE / ACM, 2013.
[34] N. Piterman, A. Pnueli, and Y. Sa'ar. Synthesis of
reactive(1) designs. In VMCAI , volume 3855 of LNCS ,
pages 364{380. Springer, 2006.
[35] A. Pnueli and R. Rosner. On the Synthesis of a
Reactive Module. In POPL , pages 179{190. ACM
Press, 1989.
[36] A. Pnueli, Y. Sa'ar, and L. D. Zuck. JTLV: A
framework for developing verication algorithms. In
CAV , volume 6174 of LNCS , pages 171{174. Springer,
2010.
[37] V. Raman and H. Kress-Gazit. Explaining impossible
high-level robot behaviors. IEEE Trans. Robotics ,
29(1):94{104, 2013.
[38] S. Schewe. Beyond Hyper-Minimisation|Minimising
DBAs and DPAs is NP-Complete. In FSTTCS ,
volume 8 of LIPIcs , pages 400{411, 2010.
[39] R. L. Smith, G. S. Avrunin, L. A. Clarke, and L. J.
Osterweil. PROPEL: an approach supporting property
elucidation. In ICSE , pages 11{21. ACM, 2002.
[40] Supporting Materials Website.
http://smlab.cs.tau.ac.il/syntech/patterns/ .
106