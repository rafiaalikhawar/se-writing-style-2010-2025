RFC-Directed Differential Testing of Certificate Validation in
SSL/TLS Implementations
Chu Chen
ICTT and ISN Laboratory, Xidian University
Xi’an, 710071, P.R. ChinaCong Tian
ICTT and ISN Laboratory, Xidian University
Xi’an, 710071, P.R. China
ctian@mail.xidian.edu.cn
Zhenhua Duan
ICTT and ISN Laboratory, Xidian University
Xi’an, 710071, P.R. China
zhhduan@mail.xidian.edu.cnLiang Zhao
ICTT and ISN Laboratory, Xidian University
Xi’an, 710071, P.R. China
ABSTRACT
Certificate validation in Secure Socket Layer or Transport Layer
Security protocol (SSL/TLS) is critical to Internet security. Thus, it
issignificanttocheckwhethercertificatevalidationinSSL/TLSis
correctlyimplemented.Withthismotivation,weproposeanovel
differential testing approach which is directed by the standard Re-
quest For Comments (RFC). First, rules of certificates are extracted
automatically from RFCs. Second, low-level test cases are gener-
ated through dynamic symbolic execution. Third, high-level test
cases, i.e. certificates, are assembled automatically. Finally, with
the assembled certificates being test cases, certificate validations in
SSL/TLS implementations are tested to reveal latent vulnerabilities
or bugs. Our approach named RFCcert has the following advan-
tages:(1)certificatesofRFCcertarediscrepancy-targetedsincethey
are assembled according to standards instead of genetics; (2) with
the obtained certificates, RFCcert not only reveals the invalidity of
traditionaldifferentialtestingbutalsoisabletoconducttestingthat
traditional differential testing cannot do; and (3) the supporting
tool of RFCcert has been implemented and extensive experiments
show that the approach is effective in finding bugs of SSL/TLS
implementations.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;•Security and privacy →Security protocols ;
KEYWORDS
Differentialtesting,certificatevalidation,SSL/TLS,dynamicsym-
bolic execution, Request For Comments
ACM Reference Format:
Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao. 2018. RFC-Directed
DifferentialTestingofCertificateValidationinSSL/TLSImplementations.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180226InICSE ’18: 40th International Conference on Software Engineering , May
27-June3,2018,Gothenburg,Sweden. ACM,NewYork,NY,USA,12pages.
https://doi.org/10.1145/3180155.3180226
1 INTRODUCTION
SecurityofInternetservicesisanimportantissuesinceamalicious
attackcouldresultinunpredictableconsequences,evendisasters.
To provide trustworthy authentication and secure communication,
HypertextTransferProtocolSecure(HTTPS)[ 54],astheupgradeof
HTTP [19,20], adopts Secure Socket Layer [ 2,22,62] or Transport
Layer Security [ 4,7,18,24,34,35,46,53,55] protocol (SSL/TLS)
toguaranteesecurity.SSL/TLSauthenticatesaserverorclientby
validatingitscertificateinthephaseofhandshake.Asfortheau-
thenticationofaserver,theserversendsitsX.509certificatetoa
client and the client validates the received certificate to determine
whetheritisthegenuinecommunicationserver.Theauthentica-
tionofaclientcanbeconductedsimilarly.Onlyifaserver/client
isauthenticated,cansubsequentcommunicationcontinue.How-
ever,thecommunicationmaybedangerousiftheauthentication
falselyacceptsaninvalidcertificateprovidedbyamaliciousserver/-
client. Likewise, a reasonable requirement for communication may
be denied if the authentication falsely rejects a valid certificate
whichisownedbyabenignserver/client.Therefore,itiscriticalto
implement certificate validation correctly.
X.509 certificatevalidation is described in several Request For
Comments (RFC) including RFCs 2527, 5246, 5878, 5280, 6101, 6818,
and 6125 [ 7,14,15,18,22,56,65]. Developers’ misunderstanding
of these RFCs may bring in bugs during the implementations of
certificate validation, and these bugs may further result in attacks,
e.g.theman-in-the-middle(MITM)attack[ 32,49].So,tosecureSS-
L/TLS implementations, it is necessary to detect bugs in certificate
validation. Nevertheless, this task is a great challenge due to the
followingfacts:(1)anX.509certificatehasacomplexstructureand
intricate semanticconstraints, (2) manyhash and encryption/de-
cryptionalgorithmsaswellasprivate/publickeysareinvolvedin
the processes of signature and validation, and (3) certificate chains
which are common in SSL/TLS are more complicated than a single
certificate.
Researchers in the community have made great efforts to test
certificatevalidationinSSL/TLSimplementations.Brubakeretal.
putforwardthefirstmethodologynamedFrankencert[ 8],which
generates8,127,600newcertificatesbycombiningcomponentsof
8592018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
243,246certificatesselectedfromtheInternet.Theirtestingof15
differentSSL/TLSimplementationsyields208discrepancies,among
which only 9 are distinct discrepancies [ 11]. In order to improve
the efficiency of differential testing, Chen et al. propose a mutation
approachnamedMucert[ 11],whichisguidedbycodecoverageand
adopts the Markov Chain Monte Carlo (MCMC) sampling method.
Mucertemploys37mutatorstomutate1,005certificatesforacer-
tain number of times. After each round of mutation, a mutated
certificate selected byMCMC sampling isreserved. With mutated
certificates,27distinctdiscrepanciesarefoundwhentesting9SS-
L/TLS implementations.
Although differential testing has been successfully applied to
certificate validation of SSL/TLS implementations, there are still
problemswiththemethod.First,adiscrepancyfoundindifferential
testing shows neither why it occurs nor which implementations
go wrong. It is difficult for developers to fix bugs without such
explicit information. Second, some of the mutated certificates used
indifferentialtestingcannotbeopenedbytheutilitiesavailable.So,
itisdifficulttoanalyzetheirstructuresor contents.Third,itisan
open question whether differential testing of certificate validation
in SSL/TLS implementations is always valid.
To solve the problems above, we propose a novel differential
testing approach, namely RFCcert, to detect bugs in certificate
validationofSSL/TLSimplementations.Differentfromtraditional
differential testing, RFCcert starts from extracting rules directly
from RFCs. Then, a symbolic C program related to the rules is
generated and low-level test cases, each of which represents a few
requirementsforcomponentsofacertificate,areproducedthrough
Dynamic Symbolic Execution (DSE) approach. Subsequently, high-
leveltestcases,i.e.certificates,areassembledfromthelow-leveltest
casesautomatically.Finally,theassembledcertificatesareemployed
to test certificate validation in SSL/TLS implementations.
The advantages of our approach are summarized as follows.
(1)Certificates of RFCcert are assembled according to standards.
Wheneveradiscrepancyisfound,thecertificateshowswhich
implementationsmakemistakesandwhichruleisviolated.This
is helpful in fixing bugs of SSL/TLS implementations.
(2)RFCcert reveals the invalidity of certain discrepancies of tradi-
tionaldifferentialtesting.Moreover,whenasingleimplemen-
tation is tested, traditional differential testing does not work
butRFCcertstillworks.Thus,RFCcertsignificantlyimproves
traditional differential testing in a sense.
(3)Thesupportingtool,namelyRFCcertDT,hasbeenimplementedand 89 certificates have been generated. With these certificates,29bugsonaverageineachofthe14implementationshavebeen
found.Sofar, 9reportedbugshavebeen confirmedbyGoogle,
Microsoft, GnuTLS and wolfSSL.
Theremainderofthispaperisorganizedasfollows.Thenextsec-
tion briefly introduces X.509 certificates and certificate validation.
Section 3 presents the RFC-directed certificate generation process.
Subsequently, RFC-directed differential testing of certificate valida-
tion in SSL/TLS implementations is conducted in Section 4. Finally,
relatedworkisdiscussedinSection5andthepaperisconcluded
in Section 6.tbsCertificate 
    Version 
    Serial Number 
    Signature 
    Validity (notBefore, notAfter) 
    Issuer 
    Issuer Unique Identifier 
    Subject 
    Subject Unique Identifier 
    Subject Public Key Info 
    Extensions 
Signature Algorithm 
Signature Value 
(a) General structureStandard Extensions 
    Authority Key Identifier 
    Subject Key Identifier 
    Key Usage 
    Certificate Policies 
    Policy Mappings 
    Subject Alternative Name 
    Issuer Alternative Name 
    Subject Directory Attributes 
    Basic Constraints 
    Name Constraints 
    Policy Constraints 
    Extended Key Usage 
    CRL Distribution Points 
    Inhibit anyPolicy 
    Freshest CRL 
Private Internet Extensions 
    Authority Information Access 
    Subject Information Access 
(b) Extensions
Figure 1: Structure of an X.509 certificate
2 PRELIMINARIES
This section briefly introduces the structure of an X.509 certificate
and how certificates are validated.
2.1 X.509 Certificates
AnX.509certificateprovidesthecertificationofanentity’sidentity
andpublickey.Thecertificationinformationisstoredinacomplex
structure which is mainly defined in RFC 5280 [15].
AsFigure1(a)shows,anX.509certificateconsistsofthreeparts:
(1)tbsCertificate, (2) signature algorithm , and (3)signature value.
The first part tbsCertificate contains the following components: (a)
version,e.g. v3;(b)serialnumber,e.g.6;(c) signature includingiden-
tifierofthedeclaredsignaturealgorithm,e.g. SHA256WithRSAEn-
cryption;( d )validity specified by a notBefore requirement and a
notAfterrequirement; (e) issuerwhich refers to the Certification
Authority(CA)thatissuesthecertificate;(f) issueruniqueidentifier ;
(g)subjectwhich refers to a holder of the certificate; (h) subject
uniqueidentifier ;(i)subjectpublickeyinfo ;and(j)extensions.The
second part signature algorithm presents the identifier of the signa-
turealgorithmthatisactuallyused,e.g. SHA1WithRSAEncryption.
As the third part, the signature value is recorded if tbsCertificate is
signed by the signature algorithm.
As Figure 1 (b) shows, extensions oftbsCertificate contains 15
standardextensions and2privateInternetextensions.Theseexten-
sionsmainlyspecifysettingsofkeys,alternativenames,policies,
constraints, the Certificate Revocation List (CRL) and information
access.The extensions componenthasanintricaterelationshipwith
tbsCertificate.MoredetailsaboutthestructurecanbefoundinRFC
5280 [15].
2.2 Certificate Validation
Certificate validation is the key of authentication since it checks
the genuineness and validity of certificates.
To determine whether the certification information in an X.509
certificate is falsified, signature value is validated by a signature
860
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. RFC-Directed Differential Testing of Certificate Validation in SSL/TLS IMPLs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
tbsCertificate  
    Version 
    Serial Number 
    Signature 
    Validity (notBefore, notAfter) 
    Issuer: intermediate 
    Issuer Unique Identifier 
    Subject: end 
    Subject Unique Identifier 
    Subject Public Key Info 
    Extensions 
Signature Algorithm 
Signature Value  tbsCertificate  
    Version 
    Serial Number 
    Signature 
    Validity (notBefore, notAfter) 
    Issuer: root 
    Issuer Unique Identifier 
    Subject: intermediate 
    Subject Unique Identifier 
    Subject Public Key Info 
    Extensions 
Signature Algorithm 
Signature Value  tbsCertificate  
    Version 
    Serial Number 
    Signature 
    Validity (notBefore, notAfter) 
    Issuer: root 
    Issuer Unique Identifier 
    Subject: root 
    Subject Unique Identifier 
    Subject Public Key Info 
    Extensions 
Signature Algorithm 
Signature Value  
an end entity certificate an intermediate certificate a root CA certificate 
Figure 2: A certificate chain
algorithm such asDSAorSHA1WithRSAEncryption. For a trust-
worthycertificate,thevalidationcheckstheconcreteconstraints
suchasnotBeforesandnotAfters.Besides,thevalidationalsochecks
whetheracertificateisissuedbyavalidrootCAthroughinspecting
acertificatechain.Figure2showsasimplecertificatechain.The
validationcheckswhethereachissuerinthechainisavalidCAand
whether the chain ends at a valid root CA. If all these checks pass,
the current certificate is accepted, otherwise it is rejected. More
informationaboutcertificatevalidationcanbefoundinRFC5246
[18] and RFC 6125 [56].
3 RFC-DIRECTED CERTIFICATE
GENERATION
As Figure 3 shows, our approach RFCcert consists of four steps. At
the first step, rules are extracted from RFCs and then expressed
inasymbolicCprogram.Atthesecondstep,DynamicSymbolic
Execution (DSE) technique is employed, which produces low-level
testcases. Atthe thirdstep, thelow-level testcases areutilized to
assemblehigh-leveltest cases,i.e.certificates.Finally,theassem-
bled certificates are used to test certificate validation in SSL/TLS
implementations. This section presents the first three steps which
constitute the RFC-directed certificate generation. The fourth step,
i.e. differential testing of SSL/TLS implementations with the gener-
ated certificates, will be presented in Section 4.
3.1 Extracting and Expressing Rules
Togeneratecertificates,rulesareautomaticallyextractedfromRFCs
5280[15]and6818[ 65]accordingtothemodalkeywordsspecified
by RFC 2119 [6].
3.1.1 Rules in RFCs. InRFCs5280and6818,rulesareexpressed
in two ways. Specifically, most rules are written in Natural Lan-
guage (NL), while the rest are written in Abstract Syntax Notation
One(ASN.1).Forinstance,Example1showsaruleinNLandEx-
ample 2 illustrates a rule in ASN.1.
Example1. (NL) “ConformingCAs MUST NOT issuecertificates
where ‘policy constraints’ is an empty sequence. That is, either the
‘inhibitPolicyMapping’ field or the ‘requireExplicitPolicy’ field MUST
be present.”Request for Comments
extract and express rules
rules (.c file)
dynamic symbolic execution
low-level test cases
assemble 
high-level test cases
test SSL/TLS implementationsStep 1
Step 2
Step 3
Step 4
bugs
Figure 3: Overview of RFCcert
Example 2. (ASN.1) “PolicyConstraints ::= SEQUENCE{
requireExplicitPolicy [0] SkipCerts OPTIONAL ,
inhibitPolicyMapping [1] SkipCerts OPTIONAL }”
InbothNLandASN.1,rulesconformtothewritingstylespecified
by RFC 2119 [ 6], which remains unaltered for 20 years since its
release in 1997. In particular, rules must use modal key words to
indicate requirement levels. The modal key words include:
(1)absoluterequirementsorprohibitions ofspecifications:MUST,
REQUIRED, SHALL, MUST NOT, and SHALL NOT;
(2)requirements or prohibitions with flexibility: SHOULD, REC-
OMMENDED,SHOULDNOT,andNOTRECOMMENDED;and
(3) truly optional items: MAY and OPTIONAL.
TheusageofuppercasekeywordsisemphasizedbyRFC8174
[36] and it provides convenience for extracting rules from RFCs.
3.1.2 Extracting Rules from RFCs. A sentence or a structure
is a rule if and only if it includes at least one modal key word.
Algorithm 1 presents the method for extracting rules from RFC
5280 automatically. In Line 1, the mark “. \n” means that a sentence
ends at the end of a line, and the mark “.␣␣” indicates a sentence
861
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
ends in the middle of a line. In Line 2, the three marks of ASN.1
represent defined data structures without bracket, in the same line,
andindifferentlines,respectively.InLines5-22,rulesareextracted
and saved by sections, which provides convenience for updating
rules. Line 9 requires that the content of a title should not include
the content of its sub-titles. In Line 16, the title nearest to a rule is
used to indicate what a pronoun, e.g. “this field”, points to.
Algorithm 1: Extracting rules from RFC 5280
Input:rfc5280.txt, min s=4, maxs=8, mint=1, maxt=5
Output:text files of rules
1markNL={“ .\n”, “.␣␣” };
2markASN .1= { “::=”, “::={ ln...}ln”, “::={ln...}ln/prime”} ;
3modalKeywordSet = {“MUST”, ... , “OPTIONAL”};
4R = the input txt file−{page break, header, footer, blank line};
5R is split into sections by Level 1 titles;
6fortheith section (i∈N∧mins≤i≤maxs)do
7ruleSet=∅;
8ruleNum =0 ;
9foreachcontent of Level j title (mint≤j≤maxt)do
10 NL sentences are extracted by mark NL;
11 ASN.1 structures are extracted by mark ASN .1;
12 foreachs∈(NL sentence ∪ASN.1 structure) do
13 wordSet(s)={each word of s};
14 ifwordSet(s)∩modalKeywordSet /nequal∅then
15 ruleNum +=1;
16 s/prime=(ruleNum ,L e v e ljtitle,s);
17 ruleSet+={s/prime};
18 end
19 end
20end
21SaveruleSetas a text file named by the section number i;
22end
Algorithm1canalsobeappliedinautomaticruleextractionfrom
RFC6818bychangingtheinputas“rfc6818.txt,min s=2,maxs=8,
mint=1, maxt=2”.
Table 1 shows the number of rules automatically extracted from
each section of RFCs 5280 and 6818.
Table 1: The number of extracted rules
RFC Sec.2 Sec.3 Sec.4 Sec.5 Sec.6 Sec.7 Sec.8
5280 - - 227 98 19 26 13
6818 0806100
3.1.3 Updating Rules. As the update of RFC 5280, RFC 6818
cites the obsolete paragraphs and presents the updated paragraphs.
In order to adapt to this change, Algorithm 2 is formalized for
automaticallyupdatingrules.ItwillupdateSections4,7and8of
RFC5280withSections3,5and6ofRFC6818,respectively.InLine
1, the marks “...says:”, “...replaced with:”, and “add(ed)...” indicate
obsolete, updated, and additional paragraphs, respectively. In Line3, obsolete rules are distinguished from updated rules according to
theirpositionsrelativetothemarks.InLines4-10,thedifference
betweenwordsetsofeachpairofrules,iscalculatedandpresented
in a matrix. In Line 12, the updated rule, if any, which has the
minimum difference from an obsolete rule is identified. In Lines
13-14, the obsolete rule is discarded if no updated rule exists. In
Lines15-18,iftheobsoleteandupdatedrulesaresame,theobsolete
rule is kept without any changes; otherwise, it is replaced with the
updated rule.
Algorithm 2: Updating rules
Input:Sections 3, 5 and 6 of RFC 6818, rules of RFC 5280
Output:updated rules of RFC 5280
1markpos={“...says:”, “...replaced with:”, “add(ed)...:” };
2foreachsection of the input do
3Classify rules into obRuleSet andupRuleSet by mark pos;
4foreachr1∈(obRuleSet ∪upRuleSet) do
5 wordSet r1= {each word of r1};
6 foreachr2∈(obRuleSet ∪upRuleSet) do
7 wordSet r2= {each word of r2};
8 Matrix[r1,r2]=|wordSet r1−wordSet r2|;
9 end
10end
11foreacho∈obRuleSet do
12 Updateo=us.t.∀u/prime∈upRuleSet
Matrix[o,u]=min({Matrix[o,u/prime]});
13 if/nexistsMatrix[o,u] then
14 Updateo= discarded;
15 else ifMatrix[o,u] == Matrix[u,o] then
16 Updateo= unchanged;
17 else
18 Updateo=u;
19 end
20 Updateoof RFC 5280 according to Updateo;
21end
22end
Table2showsthenumbersoftheupdatedanddiscardedrules
in RFC 5280.
Table 2: Update in RFC 5280
Rules Sec.4 Sec.5 Sec.6 Sec.7 Sec.8
Updated 30010
Discarded 00001
3.1.4 Consumer and Producer Rules. Rules that CAs should fol-
low in issuing certificates are called producer rules, while rules
requiredtobeobeyedbycertificateusersduringthevalidationpro-
cessareconsumerrules.Note thatthere existrules whichare both
producerandconsumerrules.Theserulesarecalled sharedrules.
Certificate validation in SSL/TLS implementations should conform
to all the consumer-related rules. Thus, in our work, consumer
862
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. RFC-Directed Differential Testing of Certificate Validation in SSL/TLS IMPLs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
and shared rules are considered. Example 3 shows a consumer rule
while Example 4 presents a shared rule.
Example3. “Inaddition,applicationsconformingtothisprofile
SHOULD recognize the ‘authority’ and ‘subject key identifier’ and
‘policy mappings’ extensions.”
Example 4. “This field MUSTcontain the same algorithm identi-
fier as the ‘signature’ field in the sequence ‘tbsCertificate’.”
Algorithm3classifiesupdatedrulesintoproducer,consumerand
sharedrules.Inthisalgorithm,Lines2and3showexplicitpatterns
of producer and consumer rules, respectively. Lines 5-10 add a rule
tothecategoryofproducerrulesifitmatchesthecorresponding
pattern. Similarly, Lines 11-16 recognize a consumer rule. Rules
matchingbothpatternsarerecordedassharedrulesasshownin
Line 18. To prevent duplication, shared rules are removed from the
categories of consumer and producer rules as shown in Lines 19
and 20, respectively. Line 21 collects implicitly shared rules suchas the one in Example 4, as well as explicitly shared rules. The
classificationresultofalltherulesisshowninTable3.Notethat
the sum in each column is the difference between the number in
the first row of Table 1 and the number in the second row of Table
2.
Algorithm 3: Classifying rules into three categories
Input:a set of updated rules (updatedRuleSet)
Output:producer, consumer, and shared rules
1producerRuleSet =consumerRuleSet =sharedRuleSet =∅;
2markpr={“conforming CAs”, ... ,“issuing CA”};
3markcr={“implementations”, ... ,“relying parties”};
4foreachr∈updatedRuleSet do
5foreachm∈markprdo
6 ifr matches m then
7 producerRuleSet +={r};
8 break;
9 end
10end
11foreachm∈markcrdo
12 ifr matches m then
13 consumerRuleSet +={r};
14 break;
15 end
16end
17end
18sharedRuleSet =producerRuleSet ∩consumerRuleSet ;
19consumerRuleSet −=sharedRuleSet ;
20producerRuleSet −=sharedRuleSet ;
21sharedRuleSet =
updatedRuleSet −producerRuleSet −consumerRuleSet ;
3.1.5 Breakable and Unbreakable Rules. Consumer and shared
rulesarefurtherclassifiedintotwocategories:breakableandun-
breakablerules.Asanexample,Example5indicatesthattheobject
“explicitText withmorethan200characters”isusedtotestcertifi-
cate validation and we only observe the response from SSL/TLSTable 3: Classification result
Rules Sec.4 Sec.5 Sec.6 Sec.7 Sec.8
Producer 78 32 0 0 9Consumer 40 16 12 19 2Shared 109 50 7 7 1
implementations.Sucharuleisunbreakable.Incontrast,therule
showninExample4is breakable.Toviolatetherule,different sig-
natureandsignature algorithm could be set in a certificate, i.e., the
requirementcouldbebroken.Withthissetting,whetherSSL/TLS
implementationsconformtothisruleistested.Also,bugswhich
violate the rule can be found in this way.
Example 5. “Therefore, certificate users SHOULD gracefully han-
dle ‘explicitText’ with more than 200 characters.”
Algorithm4isusedforclassifyingconsumerandsharedrules
into breakable and unbreakable ones. The classification result is
given in Table 4.
Algorithm 4: Classifying consumer and shared rules
Input:consumer and shared rules (csrSet)
Output:breakable and unbreakable rule sets
1breakableRuleSet =unbreakableRuleSet =patternSet =∅;
2modalKeywordSet={“MUST”, ... , “OPTIONAL”};
3markub={“gracefully handle”, ... , “receive”};
4foreachm∈modalKeywordSet do
5foreachu∈markubdo
6 patternSet +={m+“␣”+u};
7end
8end
9foreachr∈csrSetdo
10foreachp∈patternSet do
11 ifr matches p then
12 unbreakableRuleSet +={r};
13 break;
14 end
15end
16end
17breakableRuleSet =csrSet−unbreakableRuleSet ;
Table 4: The number of breakable/unbreakable rules
Rules Sec.4 Sec.5 Sec.6 Sec.7 Sec.8
Breakable 90 46 5 7 1Unbreakable 59 20 14 19 2
3.1.6 Expressing Rules as Variables. Untilnow,thebreakable/un-
breakablerulesareexpressedinNL/ASN.1.Ontheonehand,itis
difficulttodirectlygeneratecertificatesautomaticallyfromthese
863
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
rules. On the other hand, it is error prone to manually obtain com-
binedrules.Toimprovethissituation,RFCcertconductsDSEatthe
secondsteptoautomatethecertificategenerationprocess.Todo
so, rules are expressed as variables.
Generally, breakable and unbreakable rules present two kinds
of requirements: (1) constraints on what values should be set to
components of certificates, and (2) specifications on how imple-
mentationsshouldrespondtothesettings.Constraintsareimposed
onconditionsandresultsofarule.InExample4,theconditional
constraint is “ tbsCertificate.signature presents” while the resulting
constraint is “signatureAlgorithm must contain the same algorithm
identifier”. The rule in Example 3 specifies that applications should
recognize the three identifiers under the conditional constraint
presented in these identifiers.
According to the constraints and specifications, these rules can
be transformed into variables. The transformation is fulfilled by
Algorithm 5 which consists of three steps. The first step, as shown
in Lines 2-12, gathers the reserved words which constitute the
backboneofrules.Then,thesecondsteputilizesthereservedwords
tosimplifyrulesaspresentedinLines13-16.Afterthat,thethird
step generates combined constraints for NL and ASN.1 rules as
shown in Lines 19-29 and 31-41, respectively. The number of cases
attained in Line 19 is determined by the syntax of a rule. In Line
32, the embedded constraint tis usually indicated by “- - If present,
...” in the original ASN.1 rules.
Accordingtothealgorithm,Examples3,4and5areexpressedas
variables“ authorityKeyIdentifier_present_subjectKeyIdentifier
_present_policyMappings_present__applications_SHOULDrecognize ”,
“tbsCertSignature_present__signatureAlgorithm_MUSTsame ”, and
“explicitText_Morethan200chars__certUsers_SHOULDhandle ”,respec-
tively. Due to the difficulty in natural language processing, human
assistance is required to fulfill Algorithms 3-5.
3.2 Generating Low-level Test Cases
DSEfulfillson-demandcombinationsofrulesbyexploringpathsofarule-relatedprogramwhichisdesignedinagreementwithtesting
goals.Asthebasisofassemblingcertificates,thecombinationsof
rulesarelow-leveltestcases.Withrulesexpressedasvariables,itispossibletoproducelow-leveltestcasesthroughtheDSEtechnique.Specifically,wemakeuseoftheDSEtoolKLEE[
9]toexplorepaths
ofasymbolicprogramandgeneratelow-leveltestcases.Algorithm
6 is formalized to automatically generate a symbolic C program
from a given set of rule variables.
ThestructureofsymbolicprogramthatAlgorithm6generatesis
shown in Figure 4. The embedded if-elsestatements avoid an ex-
ponentialexplosionsothatKLEEwillgenerateonly m+1low-level
test cases, of which mare meaningful. Among the meaningful low-
level test cases, ilow-level test cases conform to the iunbreakable
rules(Lines8-13),andtheother m−ilow-leveltestcasesviolate
them−ibreakable rules (Lines 15-20). For brevity, suppose x1,x2
andx3represent variables of Examples 3, 5 and 4, and 1 and −1
represent the bounds 2147483647 and −2147483648. Four low-level
test cases will be generated by KLEE: (1) x1=1,x2=0 andx3=0;
(2)x1=0,x2=1 andx3=0; (3)x1=0,x2=0 andx3=−1; and
(4)x1=0,x2=0 andx3=0. Due to the assignment mechanism of
KLEEandthedefinitionof(un)breakablerules,onlythevalues1Algorithm 5: Expressing rules as variables
Input:(un)breakable rules i.e. ubrSet and brSet
Output:variables
1responseSet =otherSet =varSet=∅;
2modalKeywordSet={“MUST”, ... , “OPTIONAL”};
3sentencePatterns={“if”, ... , “when”};
4logicPatterns={“and”, ... , “or”};
5responsePatterns={“also”, ... , “be prepared to”};
6otherPatterns={“ /angbracketleft.../angbracketright”, ... , digits};
7componentSet={components and their variants};
8foreachr∈(ubrSet∪brSet)do
9responseSet +={word after m+“␣”+rp,∀m∈
modalKeywordSet and rp∈responsePatterns};
10otherSet+={word matching p∈otherPatterns};
11end
12reservedSet=modalKeywordSet+sentencePatterns+logicPatterns
+componentSet+ responseSet +otherSet;
13Replace pronouns with corresponding titles.
14foreachr∈(ubrSet∪brSet)do
15Deletewfromr,∀w/nelementreservedSet;
16end
17foreachr∈(ubrSet∪brSet)/primedo
18ifr is a rule expressed in NL then
19 Obtain cases according to syntactic patterns;
20 foreachcase of rdo
21 condition =“c1,v1,...,ci,vi”,i∈N;
22 ifr∈ubrSetthen
23 response =“consumer ,actions” if any;
24 varSet+=condition [+“: ”+response];
25 else
26 result=“c1,v1,...,cj,vj”,j∈Nif any;
27 varSet+=condition [+“: ”+result];
28 end
29 end
30else
31 foreachOPTIONAL component c ∈rdo
32 ifa constraint t is embedded then
33 constraints c={“c,absent”,t};
34 else
35 constraints c={“c,absent”,“c,present”};
36 end
37 end
38 foreachnon-OPTIONAL component c ∈rdo
39 constraints c={“c,validValue ”};
40 end
41 varSet+=combined constraints for r;
42end
43end
44ForvarSet, replace “,”/“:” with “_”/“__”, respectively;
and−1 are meaningful. The first two low-level test cases conform
to the unbreakable rules in Examples 3 and 5, respectively. Thethirdlow-leveltestcaseviolatesthebreakableruleinExample4.
864
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. RFC-Directed Differential Testing of Certificate Validation in SSL/TLS IMPLs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Algorithm 6: Generating a symbolic C program
Input:a set of rule variables (varSet)
Output:a symbolic C program
1Generate “#include ...” and “int main(){”;
2Generate the variable declaration using varSet;
3Partition varSet into ubVarSet and bVarSet by (un)breakable
rules;
4Makevsymbolic, ∀v∈ubVarSet;
5Makevsymbolic, ∀v∈bVarSet;
6foreachv∈ubVarSet do
7Generate “if (v >0) printf(v >0) else”;
8end
9foreachv∈bVarSetdo
10Generate “if (v <0) printf(v <0) else”;
11end
12Delete the redundant “else” and add “}”;
13Save as a .c file;
1#include <stdio.h>
2#include <klee/klee.h>
3intmain() {
4intx1, x2, ... , x m;
5klee_make_symbolic(&x1, sizeof(x1),"x1");
6...
7klee_make_symbolic(&xm, sizeof(xm) , "xm");
8if(x1>0) //unbreakable rule
9 printf(x1>0);
10 else
11 ...
12 if(xi>0) //unbreakable rule
13 printf(xi>0);
14 else
15 if(xj<0) //breakable rule , j=i+1
16 printf(xj<0);
17 else
18 ...
19 if(xm<0) //breakable rule
20 printf(xm<0);
21}
Figure 4: Structure of a symbolic program
Thefourthlow-leveltestcaseismeaninglessandwillbeomitted.
From the first three low-level test cases, RFCcert will assemble
certificates at the next step. The structure as shown in Figure 4
meets the requirement that each low-level test case conforms to
orviolatesonlyonerule.Forcomplicatedtestinggoals,thestruc-
ture of symbolic programs can be designed differently to realize
complicatedcombinationsof rules.Thus,DSEtechniqueprovides
flexibility for generating low-level test cases to achieve different
testing goals.
3.3 Assembling High-level Test Cases
Algorithm 7 uses low-level test cases to assemble certificates, i.e.
high-leveltestcases.BasiccomponentsandtheirvalidvaluesaresavedinLine1.Then,Lines3and4extractcomponentsandvalues
from conditions and results of the low-level test cases, respectively.
For example, /angbracketlefttbsCertSignature,present /angbracketrightand/angbracketleftsignatureAlgorithm,
MUSTsame /angbracketrightcomefrom “tbsCertSignature_present __signatureAl-
gorithm_MUSTsame ”.InLines5-7,basiccomponentsaresettodefault
values. If a CA certificate is being assembled, Lines 8-10 set values
of corresponding components. After that, Lines 11-13 set values of
components according to the conditions of low-level test cases. By
contrast, Lines 14-16 set values against the requirements, which
actuallyrealizesthebreakingofbreakablerules. Forexample, sig-
nature algorithm is set toSHA1WithRSA whilesignature is set to
SHA256WithRSA.I f signature algorithm is not involved in the rule,
it will be set the same as the signature as shown in Lines 17-19.
Finally, the certificate is encoded and saved in Line 20.
Algorithm 7: Assembling certificates
Input:low-level test cases
Output:high-level test cases i.e. certificates
1basicMap ={/angbracketleftversion,defaultValue /angbracketright,...};
2foreachlow-level test case do
3conditionMap ={/angbracketleftcomponent i,valuei/angbracketright},i∈N;
4resultMap ={/angbracketleftcomponent j,valuej/angbracketright},j∈N;
5foreachc∈basicMap.componentSet do
6 Setc=basicMap .value(c);
7end
8ifa CA certificate is being assembled then
9 Set validbasicConstraints andkeyUsage ;
10end
11foreachc∈conditionMap.componentSet do
12 Setc=conditionMap .value(c);
13end
14foreachc∈resultMap.componentSet do
15 SetcagainstresultMap .value(c);
16end
17ifsignatureAlgorithm has not been set then
18 SigntbsCertificate with theSAIinsignature;
19end
20Encode the certificate and save as a file;
21end
4 RFC-DIRECTED DIFFERENTIAL TESTING
Inthissection,anempiricalstudyontestingcertificatevalidationin
SSL/TLS implementations is carried out. In total, 69 consumer and
sharedrulesareusedand89certificatesaregeneratedbyRFCcertDT.
These certificates act as test cases of RFC-directed differential test-
ing.
4.1 Setup
4.1.1 Configuration. We employ 6 popular SSL/TLS implemen-
tationsand3Webbrowsersfortesting.SomeSSL/TLSimplementa-
tionshaveindependentversionserieswhicharestillmaintained
bydevelopers.Thus,thefollowingindependentversionsaretested:
OpenSSL(v1.0.1u,v1.0.2jandv1.1.0b)[ 21],ARMmbedTLSv2.3.0
865
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
[37],GnuTLS(v3.3.25,v3.4.16andv3.5.5)[ 44],MozillaNSSv3.27
[48], wolfSSL v3.9.10 [ 63], matrixSSL v3.8.6 [ 57], Mozilla Firefox
v49.0.1 [47], Microsoft Internet Explorer v11.0.9600.18449IS [ 45]
and Google Chrome v54.0.2840.59 [ 28]. Note that mbedTLS and
wolfSSL are descendants of PolarSSL and CyaSSL, respectively. For
brevity, the version number of an implementation is omitted in the
rest of the paper, except as otherwise noted.
Experiments are conducted on two kinds of virtual machines,
both of which are configured with one core of an Intel Core i7-
4790CPU(3.60GHz)and1.5GBRAM.One’sOperatingSystem(OS)
is Canonical Ubuntu x64 v16.04-LTS and the other’s is Microsoft
Windows7x64withservicepack1(v6.1.7601).OpenSSL,mbedTLS,
GnuTLS,NSS,wolfSSL,matrixSSLandChromearetestedinUbuntu.
Internet Explorer is tested in Windows 7. Mozilla Firefox is tested
in both of the two OSs. For accuracy, each version of SSL/TLS
implementations and Web browsers is tested in a distinct virtual
machine.
4.1.2 Testing Modes. SSL/TLSimplementationsandWebbrowsers
provide 3 different modes for certificate validation: command-line,
certificate manager, and client/server. In our experiments, eachmode is adopted to perform certificate validation of a few imple-
mentations and/or browsers, in the following way.
(1)Command-line: OpenSSL, mbedTLS, GnuTLS, NSS, and ma-
trixSSL.
(2) Certificate manager: Firefox, Internet Explorer, and Chrome.
(3) Client/server: wolfSSL.
4.1.3 Metrics. Certificatesthataredirectlyusedtotestcertifi-
catevalidationarechiefcertificatesandcertificatesthatareneeded
bychiefcertificatesinthevalidationareauxiliarycertificates.To
analyze and evaluate testing results conveniently, we define an
(m+3)-dimension vector−−−−−−→RFCcertfor each chief certificate:
−−−−−−→RFCcert=/angbracketleftSN,RFCreason ,RFCresult ,ResultI1,...,ResultIm/angbracketright.
Here,SNistheserialnumberofacertificate,and RFCreason records
a rule which is violated or obeyed. If the rule is violated, the value
ofRFCresult is 0 (“Reject”); while if the rule is obeyed, RFCresult
is 1 (“Accept”). It is possible that both “Accept” and “Reject” are
reasonable, and in this case the value of RFCresult is 2. Besides,
ResultIi(1≤i≤m)indicatesthecertificatevalidationresultofthe
ithSSL/TLS implementation.
These vectors are used as metrics in the following ways.
(1)IfResultIi/nequalResultIj(1≤i,j≤m∧i/nequalj), a discrepancy is
found.
(2)For a vector /angbracketleftResultI1,...,ResultIm/angbracketrightx, if it is not equivalent
toany/angbracketleftResultI1,...,ResultIm/angbracketrightyamongkdiscrepancies(1 ≤
x,y≤k∧x/nequaly), a distinct discrepancy is found.
(3) IfRFCresult =2, the discrepancy, if any, is invalid.
(4)RFCreason presents an explanation for a discrepancy.
(5)IfResultIi(1≤i≤m)does not match RFCresult, one bug is
found and RFCreason provides the reason.
The total number of bugs found in the ithSSL/TLS implementa-
tion is calculated by the following formula.
Nb(i)=/summationdisplay.1
−−−−−−−−→RFCcert
s.t.RFCresult/nequal2|RFCresult −ResultIi| (1)We define the conformance ratio as a criterion for sorting SSL/TLS
implementations:
CR(i)=|RFCresult matchesResultIi|
|certs|×100% (2)
where|RFCresult matchesResultIi|isthenumberofexperimental
results in accordance with RFCs and |certs|is the number of chief
certificates.
4.2 Comparing Mucert with RFCcert
Frankencert [ 8] is the pioneering work in automated testing of
certificatevalidationinSSL/TLSimplementations.Asmentioned
previously, experiments in [ 11] show that Mucert is more efficient
thanFrankencertinfindingdistinctdiscrepancies.Therefore,we
compare RFCcert with Mucert.
Table5andFigure7of[ 11]showthat mucert-3 withparameters
β=−0.3andk=500findsmoredistinctdiscrepanciesthanothers.
Thus, the parameters are employed in the repetition of Mucert and
themutatedcertificatesareemployedinthecomparison.Thereare
twoschemesforcomparison.OneschemeistotestoldSSL/TLSim-
plementations adopted in [ 11]. However, neither obsolete versions,
e.g. matrixSSL v3.7.1, nor SHA256/SHA1/MD5 values are publicly
available,andexperimentsonnon-officialversionsarenotcredible.
TheotherschemeistotestnewversionsaslistedinSection4.1.1.
For this scheme, there exist two problems. First, new versions ofFirefox and Chrome require certificates in the format of .p12/pfx,
but certificates of Mucert cannot be converted to this format since
they do not match the private key. Second, the CA certificate of
Mucert cannot be loaded without modification of wolfSSL’s source
code. For the sake of fairness and usefulness in practice, Mucert
andRFCcertarecomparedonOpenSSL,mbedTLS,GnuTLS,NSS,
matrixSSL and Internet Explorer (10 versions in total). We have
conductedexperimentswith89certificatesonthese10implementa-tions. The results show that RFCcert finds 12 distinct discrepancies
while Mucert finds 8 with 2 in common. Therefore, RFCcert is a
significantsupplementtoMucertinfiningdistinctdiscrepancies.
Table 5 shows the comparison in detail.
Table 5: A comparison of RFCcert with Mucert
Item Mucert RFCcert
Distinct discrepancies 8 12
Number of Certificates (NC) 1005 89Time for certificate generation 10445 15NC for one distinct discrepancy 125.63 7.42
The following facts can be drawn from Table 5.
(a)RFCcert has found 12 distinct discrepancies by using just 89certificates while Mucert has found 8 distinct discrepanciesby using 1,005 certificates. Therefore, for Finding Ratio (FR),RFCcert is 12/89=13.48% while Mucert is 8/1005=0.796%. It is
clear that RFCcert is more effective than Mucert.
(b)RFCcertspends15secondsingenerating89certificateswhile
Mucert spends 10,445 seconds for generating 1,005 certificates.
For the average Speed of Finding (SF) a distinct discrepancy,
866
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. RFC-Directed Differential Testing of Certificate Validation in SSL/TLS IMPLs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
RFCcert is 12/15=0.8 while Mucert is 8/10445=0.000766. There-
fore, RFCcert is more efficient than Mucert.
4.3 Invalidity of Traditional Differential
Testing of Certificate Validation
NeitherFrankencertnorMucertshowsdirectlywhetheradis-
crepancy is valid. By contrast, RFCcert can determine whether a
discrepancyisvalid.Infact,ifthevalueof RFCresult is2,thedis-
crepancy is invalid. Example 6 presents a rule that “this extension”,
i.e.basicconstraints,maybe criticalornon-critical.Onecertificate
of RFCcertis assembled for thisrule and basic constraints is setto
critical. Our experiments find one discrepancy related to the certifi-
cate: wolfSSL and matrixSSL reject it while other implementations
accept it. Consequently, non-restricted “MAY/OPTIONAL” rules
indicate that differential testing of certificate validation in SSL/TLS
implementations may be invalid in some cases.
Example 6. “This extension MAYappear as a critical or non-
critical extension in end entity certificates.”
Inaddition,traditionaldifferentialtestingrequiresatleasttwo
SSL/TLSimplementations.Otherwiseitcannotfindanydiscrepancy.
In contrast, RFCcert is able to test a single implementation by
checking whether RFCresult xmatchesResultIi,xfor some i(1≤
i≤m)andforall x(1≤x≤|certs|).Ifthematchfails, RFCreason x
indicates which rule is violated in the implementation.
4.4 Finding and Reporting Bugs
4.4.1 Finding Bugs and Conformance Ratios. Fourteen versions
of implementations mentioned in Section 4.1.1 are tested individu-
ally by the 89 certificates produced by RFCcert and the numbers
ofthedetectedbugsareshowninFigure5.ItshowsthatRFCcert
finds 29 bugs on average in each of the 14 implementations.
34 34 33 
26 33 33 33 30 
26 
11 27 27 34 33 
0 5 10 15 20 25 30 35 40 number of bugs 
SSL/TLS implementations Number of bugs found by RFCcert 
Figure 5: Number of bugs found by RFCcert
BasedoncurrenttestcasesandFormula(2)wherethenumber
ofchiefcertificatesis79,SSL/TLSimplementationsaresortedby
theconformanceratiosinFigure6.Therankingis:(1)matrixSSL,
(2)wolfSSLandmbedTLS,(3)Firefox(inWindowsandUbuntu),(4)
NSS,(5)OpenSSLv1.1.0b,GnuTLSandIE,and(6)Chrome,OpenSSL
v1.0.1uand1.0.2j.TherankingprovidedbyRFCcertishelpfulfor
userstochooseappropriateSSL/TLSimplementationsintermsof
adherence to RFCs.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 conformance ratio 
SSL/TLS implementations Conformance ratios of SSL/TLS implementations 
Figure 6: Conformance ratios
4.4.2 Reporting Bugs and Feedback. We have been reporting
bugsfoundbyRFCcerttothecorrespondingdevelopers.Uptonow,
at least 9 bugs have been confirmed or fixed.
Googlehasconfirmedandfixedonereportedbug.Wehavereported
thesecuritybugtoGooglethatChromeinUbuntuacceptsacertifi-
catewhose tbsCertificate.signature andCertificate.signatureAlgorithm
are different. If a strong hash algorithm, e.g. SHA256, is declared in
tbsCertificate.signature whilea weakhashalgorithm, e.g. SHA1,is
actuallyusedin Certificate.signatureAlgorithm,policycheckspro-
hibiting weak signature will pass because they only care about
tbsCertificate.signature in the certificate. If an attacker obtains such
acertificatewhichhasaweaksignaturealgorithm,hemaycrack
it and generate a forged certificate at his will. The forged certifi-catewillbefalselyacceptedbyclients/servers,whichmayresultin security problems. Google Security Team has carried out ex-
periments on eight permutations of Certificate.signatureAlgorithm,
Certificate.signatureValue andtbsCertificate.signature andconfirmed
that it is a security bug. The team has fixed this security bug in
Chrome v58.0.3029.81 (CVE-2017-5066)1,2.
Microsoft has confirmed one reported bug. We have reported the
similarsecuritybugfoundinMicrosoftInternetExplorer.Microsoft
Edge Team has confirmed and appreciated our report3.
Although it has been fixed in the code of verifier of Chrome
v58.0.3029.81, this security bug still exists in the underlying plat-
form verifier in Ubuntu and Windows. That is, other untested Web
browsers and SSL/TLS implementations depending on the OS veri-
fier may have similar security bugs and their users are vulnerable
to attacks which exploit this bug.
GnuTLS has confirmed and fixed three bugs : (1) GnuTLS accepts
a version-1 certificate with issuer unique identifier4; (2) GnuTLS
acceptsaversion-1certificatewith subjectuniqueidentifier5;and
(3) GnuTLS accepts a certificate which has a fractional validity6.
wolfSSLhasconfirmedandfixedfourbugs3:(1)wolfSSLaccepts
a certificate with duplicate policy object identifier s; (2) wolfSSL
accepts a certificate with more than one instance of a particular
1https://chromereleases.googleblog.com/2017/04/stable-channel-update-for-
desktop.html
2https://nvd.nist.gov/vuln/detail/CVE-2017-5066
3Reports are not public and screen shots are provided upon request.
4https://gitlab.com/gnutls/gnutls/issues/167
5https://gitlab.com/gnutls/gnutls/issues/168
6https://gitlab.com/gnutls/gnutls/issues/169
867
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
extension;(3)wolfSSLacceptsacertificatewitharelativeURIin
subject alternative name ; and (4) wolfSSL accepts an end entity
certificate with name constraints.
To sum up, RFCcert is more cost-efficient than the state-of-the-
art approach Mucert [ 11], and traditional differential testing of
certificate validation in SSL/TLS implementations is sometimes
invalid.Moreimportantly,RFCcertiscapableofidentifyingbugs
inasingleSSL/TLSimplementationandprovidingRFC-basedex-
planations, while traditional differential testing cannot fulfill these
tasks.
5 RELATED WORK
Several vulnerabilities in certificate validation of SSL/TLS imple-
mentations have been reported in [ 39–42]. Kaminsky et al. show a
case of MITM attacks by exploiting a flaw in certificate validation
[32]. Georgiev et al. study bugs of APIs of SSL/TLS implementa-
tions andanalyze perilsand pitfalls ofcertificate validationbased
on these APIs [ 23]. These work shows that certificate validation
inSSL/TLSimplementationsisinsecureanditis necessarytotest
certificate validation.
Due to the intricate syntactic and semantic constraints of certifi-
cates,methodsthathavesucceededinotherfieldsaredifficultto
be employed in certificate validation. In [ 17], Daniel et al. generate
structurallycomplexJavaprogramsiterativelyandemploythemto
testrefactoringengines.H owever, this methodisnotsuitablefor
testingcertificatevalidationduetotheillegalstructuresformostofthetestcases.Fuzzing[
26,27,29,61]providesfewusefultestcases
forcertificatevalidationeither,sincemosttestcasesdonothavethe
complexstructuresrequiredbycertificates.Besides,geneticalgo-
rithmshavebeenadoptedtotestcertificatevalidation.Frankencert[
8]isthefirstautomateddifferentialtestingofcertificatevalidation
and it produces certificates by mutation. It finds 9 distinct discrep-
ancies [11] byusing 8,127,600 randomlymutated certificates. The
aimlessmutationleadstoFrankencert’slowefficiencyinfinding
discrepancies. Inspired by the idea of feedback-directed test case
generation[ 50–52],Mucertconsiderscodecoveragetoguidecertifi-
cate mutation. Thusthe mutated certificates arerelated to the code
ofcertificatevalidationinOpenSSL.MucertalsoemploysMCMC
samplingtodiversify themutatedcertificates.In [ 11],Mucertfinds
27 distinct discrepancies by using 1,005 mutated certificates. There-fore, Mucert significantly improves efficiency of differential testing
of certificate validation in SSL/TLS implementations.
However, there are limitations in genetic-algorithm-based ap-
proaches. The choice of seed certificates and mutation operators
hasagreateffectontheperformanceofFrankencertandMucert,
and it is time-consuming to choose appropriate seed certificates
and mutation operators. For a mutated certificate which leads to a
discrepancy,itsstructureandcontentarenotclearuntiltheyare
analyzed manually. Hence, neither Frankencert nor Mucert can di-
rectly pointout: whether orwhy a discrepancy is invalid;or which
implementations make mistakes. Moreover, to solve a discrepancy,
manualwork isrequiredfor analyzing intricateconstraintsof the
structureandcontentinamutatedcertificate.Inparticular,fora
single implementation, traditional differential testing using genetic
approaches does not work. Although the state-of-the-art approachMucertisguidedbythecodecoverageofOpenSSL,differentimple-mentationshavedifferentcodesandthecodecoverageofOpenSSL
cannotrepresentthatofothers.Itisstillanopenquestionhowto
obtainanoverallcodecoveragetoguidecertificatemutation.There-
fore,abetterwayistogeneratediscrepancy-targetedcertificates
directed by high-level specifications instead of the code coverage.
Specificationshavebeenusedforvariouspurposes.Grammar-
basedtestingtechniques[ 33,43,59,64]generateprogramsbasedon
grammars. For example, Csmith [ 64] employs generated programs
to find bugs in open-source C compilers. Korat [ 5] employs the
precondition ofa methodto generatetest casesand thenemploys
thepostconditionasatestoracletocheckthecorrectnessofoutputs.
TestEra[38]producesJavaprogramsascounterexamplestoviolated
correctness criteria. Hierons et al. have made a survey of using
formal specification to assist testing [30].
Inspired by the above specification-based methods, RFCcert
utilizes DSE [ 9,12,13,25,27,58,60] and assembling techniques
[1,10,16]toefficientlygeneratestandards-basedcertificatestoover-
come the disadvantages of traditional differential testing. With the
standards, certificates produced by RFCcert are more discrepancy-
targetedthanmutatedcertificatesgeneratedbygeneticapproaches
suchasFrankencertandMucert.ExperimentalresultsshowthatRFCcert significantly improves the differential testing of certifi-
catevalidationinSSL/TLSimplementations.Inaddition,RFCcert
can be extended to specification-based differentialtesting of other
implementations.
Sumanetal.employerrorspecificationstodetecterrorhandling
bugs [31]. RFCcert is different in that we employ standards to gen-
eratecertificateswithcomplexstructuresandthenemploythem
to find bugs in certificate validation. In [ 3], the approach proposed
by Bauer et al. is a model-based run-time verification technique
whichcompletelydependsontheopen-sourcecode.Bycontrast,
our approach is an RFC-directed testing technique where the code
is not required.
6 CONCLUSION AND FUTURE WORK
In this paper, we propose RFCcert, an RFC-directed approach to
thetestingcertificatevalidationinSSL/TLSimplementations.With
RFC-based certificates, RFCcert reveals bugs, identifies distinctdiscrepancies, and determines the validity of differential testing.Extensive experiments show that RFCcert is effective in finding
distinct discrepancies and bugs.
In the near future, we are going to apply our approach to all
the rules in RFCs 5280 and 6818 for detecting vulnerabilities orbugs. In addition, we plan to improve our tool RFCcertDT so as
to help developers enhance the security of certificate validation in
SSL/TLS implementations. We look forward to facilitating the stan-
dardization of certificate validation in SSL/TLS implementationsand making it convenient for users to choose suitable products
according to the conformance ratios.
ACKNOWLEDGMENTS
ThisresearchwassupportedbyNSFCwithGrantNos.61732013,
61420106004,61751207and61402347.CongTianandZhenhuaDuan
are the corresponding authors.
868
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. RFC-Directed Differential Testing of Certificate Validation in SSL/TLS IMPLs ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]A. Aliprandi, M. Mauro, and L. De Cola. 2016. Controlling and Imaging
Biomimetic Self-assembly. Nature Chemistry 8, 1 (2016), 10–15.
[2]R. Barnes, M. Thomson, A. Pironti, and A. Langley. 2015. Deprecating Secure
Sockets Layer Version 3.0. (June 2015). https://tools.ietf.org/html/rfc7568
[3]A.Bauer,J.Jürjens,andY.Yu.2011. Run-TimeSecurityTraceabilityforEvolving
Systems. Comput. J. 54, 1 (January 2011), 58–87.
[4]K.Bhargavan,A.Delignat-Lavaud,A.Pironti,A.Langley,andM.Ray.2015.Trans-
portLayerSecurity(TLS)SessionHashandExtendedMasterSecretExtension.
(September 2015). https://tools.ietf.org/html/rfc7627
[5]C. Boyapati, S. Khurshid, and D. Marinov. 2002. Korat: Automated Testing
Based on Java Predicates. In Proceedings of the 2002 ACM SIGSOFT International
Symposium on Software Testing and Analysis (ISSTA ’02). ACM, New York, NY,
USA, 123–133. http://doi.acm.org/10.1145/566172.566191
[6]S. Bradner. 1997. Key Words for Use in RFCs to Indicate Requirement Levels.
(March 1997). https://tools.ietf.org/html/rfc2119
[7]M.BrownandR.Housley.2010. TransportLayerSecurity(TLS)Authorization
Extensions. (May 2010). https://tools.ietf.org/html/rfc5878
[8]C. Brubaker, S. Jana, B. Ray, S. Khurshid, and V. Shmatikov. 2014. Using
Frankencerts for Automated Adversarial Testing of Certificate Validation in
SSL/TLSImplementations.In Proceedingsofthe2014IEEESymposiumonSecurity
and Privacy (SP ’14). IEEE Computer Society, Washington, DC, USA, 114–129.
https://doi.org/10.1109/SP.2014.15
[9]C. Cadar, D. Dunbar, and D. Engler. 2008. KLEE: Unassisted and Automatic
GenerationofHigh-coverageTestsforComplexSystemsPrograms.In Proceedings
ofthe8thUSENIXConferenceonOperatingSystemsDesignandImplementation
(OSDI’08). USENIX Association, Berkeley, CA, USA, 209–224. http://dl.acm.org/
citation.cfm?id=1855741.1855756
[10]A. Casini, M. Storch, G. S. Baldwin, and T. Ellis. 2015. Bricks and Blueprints:
MethodsandStandardsforDNAAssembly. NatureReviewsMolecularCellBiology
16, 9 (2015), 568–576.
[11]Y. Chen and Z. Su. 2015. Guided Differential Testing of Certificate Validation
in SSL/TLS Implementations. In Proceedings of the 2015 10th Joint Meeting on
Foundations of Software Engineering (ESEC/FSE 2015). ACM, New York, NY, USA,
793–804. https://doi.org/10.1145/2786805.2786835
[12]V. Chipounov, V. Kuznetsov, and G. Candea. 2011. S2E: A Platform for In-
vivo Multi-path Analysis of Software Systems. In Proceedings of the Sixteenth
International Conference on Architectural Support for Programming Languages
and Operating Systems (ASPLOS XVI). ACM, New York, NY, USA, 265–278.
https://doi.org/10.1145/1950365.1950396
[13]V. Chipounov, V. Kuznetsov, and G. Candea. 2012. The S2E Platform: Design,
Implementation,andApplications. ACMTrans.Comput.Syst. 30,1,Article2(Feb.
2012), 49 pages. https://doi.org/10.1145/2110356.2110358
[14]S. Chokhani and W. Ford. 1999. Internet X.509 Public Key Infrastructure Cer-tificate Policy and Certification Practices Framework. (March 1999). https:
//tools.ietf.org/html/rfc2527
[15]D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk. 2008.
InternetX.509PublicKeyInfrastructureCertificateandCertificateRevocation
List (CRL) Profile. (May 2008). https://tools.ietf.org/html/rfc5280
[16]J.R.Crandall,R.Ensafi,S.Forrest,J.Ladau,andB.Shebaro.2008. TheEcologyof
Malware. In Proceedings of the 2008 Workshop on New Security Paradigms (NSPW
’08).ACM,NewYork,NY,USA,99–106. https://doi.org/10.1145/1595676.1595692
[17]B. Daniel, D. Dig, K. Garcia, and D. Marinov. 2007. Automated Testing of Refac-
toringEngines.In Proceedingsofthe6th JointMeetingoftheEuropean Software
Engineering Conference and the ACM SIGSOFT Symposium on The Foundationsof Software Engineering (ESEC-FSE ’07). ACM, New York, NY, USA, 185–194.
https://doi.org/10.1145/1287624.1287651
[18]T. Dierks and E. Rescorla. 2008. The Transport Layer Security (TLS) Protocol
Version 1.2. (August 2008). https://tools.ietf.org/html/rfc5246
[19]R. Fielding, J. Gettys, J. Mogul, H. Frystyk, and T. Berners-Lee. 1997. Hypertext
TransferProtocol–HTTP/1.1. (January1997). https://tools.ietf.org/html/rfc2068
[20]R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, and T. Berners-
Lee.1999. HypertextTransferProtocol–HTTP/1.1. (June1999). https://tools.
ietf.org/html/rfc2616
[21]OpenSSLSoftwareFoundation.2016. OpenSSL. (2016). RetrievedOctober12,
2016 from https://www.openssl.org
[22]A.Freier,P.Karton,andP.Kocher.2011. TheSecureSocketsLayer(SSL)Protocol
Version 3.0. (August 2011). https://tools.ietf.org/html/rfc6101
[23]M.Georgiev,S.Iyengar,S.Jana,R.Anubhai,D.Boneh,andV.Shmatikov.2012.
The Most Dangerous Code in the World: Validating SSL Certificates in Non-
browserSoftware.In Proceedingsofthe2012ACMConferenceonComputerand
Communications Security (CCS ’12). ACM, New York, NY, USA, 38–49. https:
//doi.org/10.1145/2382196.2382204
[24]D.Gillmor.2016.NegotiatedFiniteFieldDiffie-HellmanEphemeralParametersfor
TransportLayerSecurity(TLS). (August2016). https://tools.ietf.org/html/rfc7919
[25]P.Godefroid,N.Klarlund,andK.Sen.2005. DART:DirectedAutomatedRandom
Testing. In Proceedings of the 2005 ACM SIGPLAN Conference on ProgrammingLanguage Design and Implementation (PLDI ’05). ACM, New York, NY, USA,
213–223. https://doi.org/10.1145/1065010.1065036
[26]P. Godefroid, M. Y. Levin, and D. Molnar. 2008. Automated Whitebox Fuzz
Testing. In Proceedings of the 16th Annual Network & Distributed System Security
Symposium. The Internet Society, San Diego, California, USA, 151–166.
[27]P. Godefroid, M. Y. Levin, and D. Molnar. 2012. SAGE: Whitebox Fuzzing for
Security Testing. Queue10, 1, Article 20 (Jan. 2012), 8 pages. https://doi.org/10.
1145/2090147.2094081
[28]Google. 2016. Chrome. (2016). Retrieved October12, 2016from https://www.
google.com/chrome/
[29]G. Grieco, M. Ceresa, and P. Buiras. 2016. QuickFuzz: An Automatic Random
Fuzzer for Common File Formats. In Proceedings of the 9th International Sym-
posium on Haskell (Haskell 2016). ACM, New York, NY, USA, 13–20. https:
//doi.org/10.1145/2976002.2976017
[30]R. Hierons, K. Bogdanov, J. Bowen, R. Cleaveland, J. Derrick, J. Dick, M. Ghe-
orghe, M. Harman, K. Kapoor, P. Krause, G. Lüttgen, A. Simons, S. Vilkomir,
M. Woodward, and H. Zedan. 2009. Using Formal Specifications to Support
Testing. ACM Comput. Surv. 41, 2, Article 9 (Feb. 2009), 76 pages. https:
//doi.org/10.1145/1459352.1459354
[31]S. Jana, Y. J. Kang, S. Roth, and B. Ray. 2016. Automatically Detecting Error
HandlingBugsUsingErrorSpecifications.In 25thUSENIXSecuritySymposium
(USENIX Security 16). USENIX Association, Austin, TX, 345–362.
[32]D. Kaminsky, M. L. Patterson, and L. Sassaman. 2010. PKI Layer Cake: New
Collision Attacks Against the Global X.509 Infrastructure. In Proceedings of
the 14th International Conference on Financial Cryptography and Data Security
(FC’10).Springer-Verlag,Berlin,Heidelberg,289–303. https://doi.org/10.1007/
978-3-642-14577-3_22
[33]R. Lämmel and W. Schulte. 2006. Controllable Combinatorial Coverage in
Grammar-based Testing. In Proceedings of the 18th IFIP TC6/WG6.1 International
ConferenceonTestingofCommunicatingSystems (TestCom’06).Springer-Verlag,
Berlin, Heidelberg, 19–38. https://doi.org/10.1007/11754008_2
[34]A.Langley.2015. ATransportLayerSecurity(TLS)ClientHelloPaddingExten-
sion. (October 2015). https://tools.ietf.org/html/rfc7685
[35]A. Langley, W. Chang, N. Mavrogiannopoulos, J. Strombergson, and S. Josefsson.
2016. ChaCha20-Poly1305 Cipher Suites for Transport Layer Security (TLS).
(June 2016). https://tools.ietf.org/html/rfc7905
[36]B.Leiba.2017. AmbiguityofUppercasevsLowercaseinRFC2119KeyWords.
(May 2017). https://tools.ietf.org/html/rfc8174
[37]ARMLimited.2016. mbedTLS. (2016). RetrievedOctober12,2016fromhttps:
//tls.mbed.org
[38]D. Marinov and S. Khurshid. 2001. TestEra: A Novel Framework for Automated
TestingofJavaPrograms.In Proceedingsofthe16thIEEEInternationalConference
on Automated Software Engineering (ASE ’01). IEEE Computer Society, Washing-
ton, DC, USA, 22–31. http://dl.acm.org/citation.cfm?id=872023.872551
[39]M Marlinspike. 2002. IE SSL Vulnerability. (2002). Retrieved October 1, 2016
from https://www.thoughtcrime.org/ie-ssl-chain.txt
[40]M. Marlinspike. 2009. More Tricks for Defeating SSL in Practice. (2009). Re-
trieved October 1, 2016 from https://www.blackhat.com/presentations/bh-dc-09/
Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf
[41]M. Marlinspike. 2009. New Tricks for Defeating SSL in Practice. (2009). Re-
trievedOctober1,2016fromhttps://www.blackhat.com/presentations/bh-usa-09/
Marlinspike/BHUSA09-Marlinspike-DefeatSSL-SLIDES.pdf
[42]M. Marlinspike. 2009. Null Prefix Attacks against SSL/TLS Certificates.
(2009). RetrievedOctober1,2016fromhttps://www.thoughtcrime.org/papers/
null-prefix-attackes.pdf
[43]P.M.Maurer.1990. GeneratingTestDatawithEnhancedContext-freeGrammars.
IEEE Software 7, 4 (July 1990), 50–55. https://doi.org/10.1109/52.56422
[44]N. Mavrogiannopoulos. 2016. GnuTLS. (2016). Retrieved October 12, 2016 from
https://www.gnutls.org
[45]Microsoft. 2016. Internet Explorer. (2016). Retrieved October 12, 2016 from
https://www.microsoft.com/en-us/download/internet-explorer.aspx
[46]B. Moeller and A. Langley. 2015. TLS Fallback Signaling Cipher Suite Value
(SCSV) for Preventing Protocol Downgrade Attacks. (April 2015). https://tools.
ietf.org/html/rfc7507
[47]Mozilla. 2016. Firefox. (2016). Retrieved October 12, 2016 from https://www.
mozilla.org/en-US/firefox/all/
[48]Mozilla.2016. NSS. (2016). RetrievedOctober12,2016fromhttps://developer.
mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_Releases
[49]NIST. 2017. CVE-2016-8495. (2017). Retrieved July 26, 2017 from https://nvd.
nist.gov/vuln/detail/CVE-2016-8495
[50]C. Pacheco and M. D. Ernst. 2007. Randoop: Feedback-directed Random Testing
for Java. In Companion to the 22nd ACM SIGPLAN Conference on Object-oriented
Programming Systems and Applications Companion (OOPSLA ’07). ACM, New
York, NY, USA, 815–816. https://doi.org/10.1145/1297846.1297902
[51]C. Pacheco, S. K. Lahiri, and T. Ball. 2008. Finding Errors in .Net with Feedback-
directed Random Testing. In Proceedings of the 2008 International Symposium
onSoftwareTestingandAnalysis (ISSTA’08) .ACM,NewYork,NY,USA,87–96.
https://doi.org/10.1145/1390630.1390643
869
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chu Chen, Cong Tian, Zhenhua Duan, and Liang Zhao
[52]C.Pacheco,S.K.Lahiri,M.D.Ernst,andT.Ball.2007. Feedback-DirectedRandom
TestGeneration. In Proceedingsofthe29thInternationalConferenceonSoftware
Engineering (ICSE ’07). IEEE Computer Society, Washington, DC, USA, 75–84.
https://doi.org/10.1109/ICSE.2007.37
[53]A.Popov.2015. ProhibitingRC4CipherSuites. (February2015). https://tools.
ietf.org/html/rfc7465
[54]E.Rescorla.2000.HTTPOverTLS.(May2000). https://tools.ietf.org/html/rfc2818
[55]E.Rescorla,M.Ray,S.Dispensa,andN.Oskov.2010. TransportLayerSecurity
(TLS)RenegotiationIndicationExtension. (February2010). https://tools.ietf.org/
html/rfc5746
[56]P. Saint-Andre and J. Hodges. 2011. Representation and Verification of Domain-
Based Application Service Identity within Internet Public Key Infrastructure
UsingX.509(PKIX)CertificatesintheContextofTransportLayerSecurity(TLS).
(March 2011). https://tools.ietf.org/html/rfc6125
[57]Inside Secure. 2016. matrixSSL. (2016). Retrieved October 12, 2016 from
http://www.matrixssl.org
[58]K. Sen and G. Agha. 2006. CUTE and jCUTE: Concolic Unit Testing and Explicit
PathModel-checkingTools.In Proceedingsofthe18thInternationalConference
on Computer Aided Verification (CAV’06) . Springer-Verlag, Berlin, Heidelberg,
419–423. https://doi.org/10.1007/11817963_38[59]E. G. Sirer and B. N. Bershad. 1999. Using Production Grammars in Software
Testing. In Proceedings of the 2nd Conference on Domain-specific Languages (DSL
’99). ACM, New York, NY, USA, 1–13. https://doi.org/10.1145/331960.331965
[60]D.Song,D.Brumley,H.Yin,J.Caballero,I.Jager,M.G.Kang,Z.Liang,J.Newsome,
P. Poosankam, and P. Saxena. 2008. BitBlaze: A New Approach to Computer
SecurityviaBinaryAnalysis.In Proceedingsofthe4thInternationalConference
onInformationSystemsSecurity (ICISS’08).Springer-Verlag,Berlin,Heidelberg,
1–25. https://doi.org/10.1007/978-3-540-89862-7_1
[61]M. Sutton, A. Greene, and P. Amini. 2007. Fuzzing: Brute Force Vulnerability
Discovery. Addison-Wesley Professional, Boston, Massachusetts, USA.
[62]S. Turnerand T.Polk. 2011. Prohibiting SecureSockets Layer(SSL) Version 2.0.
(March 2011). https://tools.ietf.org/html/rfc6176
[63]wolfSSL Inc. 2016. wolfSSL. (2016). Retrieved October 30, 2016 from https:
//www.wolfssl.com
[64]X. Yang, Y. Chen, E. Eide, and J. Regehr. 2011. Finding and Understanding
Bugs in C Compilers. In Proceedings of the 32nd ACM SIGPLAN Conference on
ProgrammingLanguageDesignandImplementation (PLDI’11).ACM,NewYork,
NY, USA, 283–294. https://doi.org/10.1145/1993498.1993532
[65]P. Yee. 2013. Updates to the Internet X.509Public Key Infrastructure Certificate
andCertificateRevocationList(CRL)Profile. (January2013). https://tools.ietf.
org/html/rfc6818
870
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:38:09 UTC from IEEE Xplore.  Restrictions apply. 