How notto structure your database-backed web applications:
a study of performance bugs in the wild‚àó
Junwen Yang
Pranav Subramaniam
Shan Lu
University of Chicago
{junwen, psubramaniam, shanlu}@uchicago.eduCong Yan
Alvin Cheung
University of Washington
{congy, akcheung}@cs.washington.edu
ABSTRACT
Manywebapplicationsusedatabasesforpersistentdatastorage,
and using Object Relational Mapping (ORM) frameworks is a com-
monwaytodevelopsuchdatabase-backedwebapplications.Un-
fortunately,developingefficientORMapplicationsischallenging,
astheORMframeworkhidestheunderlyingdatabasequerygen-
eration and execution. This problem is becoming more severe as
these applications need to process an increasingly large amount
of persistent data. Recent research has targeted specific aspects of
performanceproblemsinORMapplications.However,therehasnot
beenanysystematicstudytoidentifycommonperformanceanti-
patterns in real-world such applications, how they affect resulting
application performance, and remedies for them.
Inthispaper,wetrytoanswerthesequestionsthroughacompre-
hensivestudyof12representativereal-worldORMapplications.We
generalize9ORMperformanceanti-patternsfrommorethan200
performance issues that we obtain by studying their bug-tracking
systems andprofiling theirlatest versions. To prove ourpoint, we
manually fix 64 performance issues in their latest versions and ob-
tain amedian speedupof 2 √ó(and up to 39 √ómax) with fewer than
5 lines of code change in most cases. Many of the issues we found
have been confirmed by developers, and we have implemented
ways to identify other code fragments with similar issues as well.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware performance;
KEYWORDS
performanceanti-patterns,Object-RelationalMappingframeworks,
database-backed applications, bug study
1 INTRODUCTION
Modernwebapplicationsfacethechallengeofprocessingagrowing
amount of data while serving increasingly impatient users. On one
‚àóhttps://hyperloop.cs.uchicago.edu
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE‚Äô18, May 27-June 3, 2018, Gothenburg, Sweden
¬©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180194hand, popular web applications typically increase their user bases
by 5‚Äì7% per week in the first few years [ 32], with quickly growing
data that is produced or consumed by these users and is managed
by applications.On the otherhand, studies haveshown thatnearly
halfoftheusersexpectasitetoloadinlessthan2secondsandwillabandon a site if it is not loaded within 3 seconds [
24], while every
extra 0.5 second of latency reduces the overall traffic by 20% [35].
Tomanagelargeamountsofdata,modernwebapplicationsoften
follow a two-stack architecture, with a front-end application stack
fulfillingapplicationsemanticsandaback-enddatabasemanage-
mentsystem(DBMS)storingpersistentdataandprocessingdatare-trievalrequests.Tohelpdevelopersconstructsuchdatabase-backed
webapplications,ObjectRelationalMapping(ORM)frameworks
have become increasingly popular, with implementations in all
common general-purpose languages: the Ruby on Rails framework
(Rails)forRuby[ 22],DjangoforPython[ 9],andHibernateforJava
[14]. These ORM frameworks allow developers to program such
database-backed web applications in a DBMS oblivious way, as the
frameworks expose APIs for developers to operate persistent data
storedintheDBMSasiftheyareregularheapobjects,withregular-
looking method calls transparently translated to SQL queries by
frameworks when executed.
Unfortunately, ORM frameworks inevitably bring concerns to
theperformance andscalability ofweb applications, whosemulti-
stack nature demands cross-stack performance understanding and
optimization. On one hand, it is difficult for application compilers
or developers to optimize the interaction between the application
andtheunderlyingDBMS,astheyareunawareofhowtheircode
wouldtranslatetoqueriesbytheORM.Ontheotherhand,ORM
framework and the underlying DBMS are unaware of the high-level application semantics and hence cannot generate efficient
planstoexecutequeries.Makingthingsevenworse,data-related
performanceandscalabilityproblemsareparticularlydifficultto
exposeduringin-housetesting,astheymightonlyoccurwithlarge
amounts of data that only arises after the application is deployed.
Unlikeperformanceproblemsontheclientside,whichhavebeen
well studied in prior work [ 34,41], the cross-stack performance
problemsontheserversideareunder-studied,whichunfortunately
arethekeytothedata-processingefficiencyofORMapplications.
Although recent work [ 26,27,29,46] has looked at specific per-
formanceproblemsinORMapplications,therehasbeennocom-
prehensive study to understand the performance and scalability
of real-world ORM applications, the variety of performance issues
that prevail, and how such issues are addressed.
Giventheabove,wetargetthreekeyresearchquestionsabout
real-world ORM applications in this paper:
8002018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ‚Ä¢RQ1:Howwelldoreal-worlddatabase-backedwebapplica-
tions perform as the amount of application data increases?
‚Ä¢RQ 2: What are the common root causes of performance
and scalability issues in such applications?
‚Ä¢RQ 3: What are the potential solutions to such issues and
can they be applied automatically?
To answer these questions, we conduct a comprehensive two-
pronged empirical study on a set of 12 Rails applications represent-
ing 6 common categories that exercise a wide range of functionali-
ties provided by the ORM framework and DBMS. We choose Rails
as it is a popular ORM framework [ 11]. We carefully examine 140
fixed performance issues randomly sampled from the bug-tracking
systems of these 12 applications. This helps us understand how
well these applications performed on real-world data in the past,
and what types of performance and scalability problems have been
discovered and fixed by end-users and developers in past versions.
To complement the above study, we also conduct thorough pro-
filingandcodereviewofthelatestversionsofthese12applications.
This investigation helps us understand how these applications cur-
rentlyperformonourcarefullysynthesizeddata(tobeexplained
in Section 3), what types of performance and scalability problems
still exist in the latest versions, and how they can be fixed.
Intermsoffindings,for RQ1,ourprofilinginSection4shows
that, under workload that is no larger than today‚Äôs typical work-
load, 11 out of 12 studied applications contain pages in their latest
versions that take more than two seconds to load and also pages
thatscalesuper-linearly.Comparedtoclient-sidecomputation(e.g.,
executing JavaScript functions in the browser), server-side compu-
tation takes more time in most time-consuming pages and often
scalesmuchworse.Theseresultsmotivateresearchtotackleserver-
side performance problems in ORM applications.
ForRQ2, we generalize 9 ORM performance anti-patterns by
thoroughlystudyingabout200real-worldperformanceissues,with
140collected from12 bug-trackingsystems and64 manuallyiden-
tified by us based on profiling the same set of ORM applications
(Section5).Wegroupthese9patternsintothreemajorcategories‚Äî
ORM API misuses, database design problems, and trade-offs in
applicationdesign.Allbutoneofthesepatternsexistbothinpre-
vious versions (i.e., fixed and recorded in bug-tracking systems)
and the latest versions (i.e., discovered by us through profiling and
codereview)oftheseapplications.6oftheseanti-patternsappear
profuselyinmorethanhalfofthestudiedapplications.Whileafew
ofthemhavebeenidentifiedinpriorwork,themajorityofthese
anti-patterns have notbeen researched in the past.
Finally,for RQ3,wemanuallydesignandapplyfixestothe64
performance issues in the latest versions of these 12 ORM appli-
cations(Section6).Ourfixesachieve2 √ómedianspeedup(andup
to39√ó)inserver-sideperformanceimprovement,andreducethe
averageend-to-endlatencyof39problematicwebpagesin12appli-
cationsfrom4.17secondsto0.69seconds,makingtheminteractive.Mostoftheseoptimizationsfollowgenericpatternsthatwebelieve
can be automated in the future through static analysis and codetransformations. As a proof of concept, we implement a simple
static checker based on our findings and use it to find hundreds of
API misuse performance problems in the latest versions of these
applications (Section 7).FODVV0HVVDJHV&RQWUROOHU
GHILQGH[PHVVDJHV XVHUXQGHOHWHGBPHVVDJHVUHQGHULQGH[HQG
HQG
FODVV8VHU$FWLYH5HFRUG%DVH
KDVBPDQ\PHVVDJHVFODVVBQDPH !0HVVDJHIRUHLJQBNH\ !XVHUBLGGHIXQGHOHWHGBPHVVDJHV
PHVVDJHVZKHUHGHOHWHG !IDOVH
HQGHQG
FODVV0HVVDJH$FWLYH5HFRUG%DVHEHORQJVBWRXVHUFODVVBQDPH !8VHUIRUHLJQBNH\ !XVHUBLG
HQGPHVVDJHVHDFKGR_PHVVDJH_!
WU!PHVVDJHXVHUQDPHWU!
HQG!
PHVVDJHVBFRQWUROOHUUEPHVVDJHVLQGH[KWPOHUE
L5 G %XVHUUE
PHVVDJHUEP &RQWUROOHU9LHZ
O80RGHO '%06$SSOLFDWLRQ6HUYHU
5RXWLQJUXOHV 
JHWPHVVDJHVLQGH[ !PHVVDJHVLQGH[
LGLGXVHUBLGGGHOHWHG
LGQDPH
Figure 1: Structure of an example Rails application
Overall, our comprehensive study provides motivations and
guidelinesforfutureresearchtohelpavoid,detect,andfixcross-
stackperformanceissuesinORMapplications.Wehaveprepared
adetailedreplicationpackageforalltheperformance-issuestudy,
profiling, and program analysis conducted in this paper. This pack-
age is available on the webpage of our Hyperloop project [ 16], a
projectthat aimsto solvedatabase-related performanceproblems
in ORM applications.
2 BACKGROUND
Our study focuses on applications written in Ruby on Rails (Rails).
Ruby is among the top 3 popular languages on GitHub [ 38], and
Rails is among the top 3 popular web application frameworks
[11]. Many widely used applications are built upon Rails, such
ashulu[15],gitlab[13],airbnb[ 2],etc.Comparedtootherpopular
ORM frameworks such as Django [ 9] and Hibernate [ 14], Rails has
2√ómoreapplicationsongithubwith400morestarsthanDjango
andHibernatecombined.AsRailsprovidessimilarfunctionalities
as Django and Hibernate, we believe our findings can apply to
applications built on top of those frameworks as well.
LikeotherapplicationsbuiltontopofanORMframework,Rails
applications are structured based on the model-view-controller
(MVC) architecture. We illustrate this using an example shown
in Figure 1, which is abridged from a forum application that al-lows users to publish posts and comments. First, developers de-
signmodelclasses that inherit from a special ActiveRecord super
class, such as UserandMessage in Figure 1, where their corre-
sponding fields are stored persistently in the DBMS. The associ-ations between model classes, chosen from
has_many ,has_one,
andbelongs_to , need to be explicitly declared in modelclasses,
such as the ‚Äú has_many :messages ‚Äù specified in the Userclass and
the‚Äúbelongs_to :user ‚Äùspecifiedinthe Message class.Afterthat,
they design controllers, such as MessagesController.rb in Fig-
ure1thatcontainsmultiple actions,witheachactiondetermining
801
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Table 1: Details of the applications chosen in our study
Category Abbr. Name Stars Commits Contributors
ForumDs Discourse 21238 22501 568
Lo Lobster 1304 1000 48
CollaborationGi Gitlab 19255 49810 1276
Re Redmine 2399 13238 6
E-commerceSp Spree 8331 17197 709
Ro Ror_ecommerce 1109 1727 21
Task- Fu Fulcrum 1502 697 44
management Tr Tracks 835 3512 62
Social Da Diaspora 11183 18734 335
Network On Onebody 1592 1220 6
MapOS Openstreetmap 664 8000 112
FF Fallingfruit 41 1106 7
howtheapplicationrespondstoaspecificweb-pagerequest.Inside
an action there is code to retrieve database data through queries
transparently translatedby theORM. Finally,the retrieved datais
renderedvia viewsthatareoftenwritteninatemplatelanguage,as
shown in index.html.erb in Figure 1. Such views determine how
the retrieved data is displayed in a client‚Äôs browser.
The life cycle of a Rails application, and ORM applications in
general,isasfollows.WhenreceivingaclientHTTPrequestlike
‚Äúhttp://.../messages/index ‚Äù,theapplicationserverfirstlooks
up the routing rules, shown at the top of Figure 1, to map this
requesttothe indexactioninside MessagesController .Whenthe
indexactionexecutes,itinvokesthe @user.undeleted_messages
function, which calls messages.where(...) . The call to the Rails
APIwhereis dynamically translated to a SQL query by the Rails
framework to retrieve data from the DBMS. The query results are
then serialized into model objects and stored in @messages . The
indexaction then calls render "index" to render the retrieved
data in@messages using the index.html.erb template.
3 PROFILING & STUDY METHODOLOGY
ThissectionexplainshowweprofileORMapplicationsandstudy
theirbug-trackingsystems,withthegoaltounderstandhowthey
perform and scale in both their latest and previous versions.
3.1 Application Selection
As mentioned in Section 2, we focus on Rails applications. Since
itisimpracticaltostudyallopen-sourceRailsapplications(about
200 thousand of them on GitHub [ 12]), we focus on 6 popular
application categories1as shown in Table 1. These 6 categories
cover 90% of all Rails applications with more than 100 stars on
GitHub.Theyalsocoveravarietyofdatabase-usagecharacteristics,
suchas transaction-heavy(e.g., e-commerce),read-intensive (e.g.,
socialnetworking),andwrite-intensive(e.g.,forums).Furthermore,
they cover both graphical interfaces (e.g., maps) and traditional
text-based interfaces (e.g., forums).
We study the top 2 most popular applications in each category,
basedonthenumberof‚Äústars‚ÄùonGitHub.These12applications
showninTable1havebeendevelopedfor5to12years.Theyare
1We use the category information as provided by the application developers. For
example, Diaspora is explicitly labeled ‚Äòsocial-network‚Äô [8].Table 2: Some of Gitlab statistics for workload synthesis
#projects #users #commits #projects #branches #projects
‚â§1 74678 ‚â§1 115246 ‚â§1 224551
1 - 5 31009 1 - 5 51499 1 - 5 54171
5 -10 5063 5 -10 26429 5 -10 7097
10 - 20 2133 10 - 20 25797 10 - 20 4429
20 - 100 1116 20 - 100 41939 20 - 100 3996
100 - 1000 97 100 - 1000 23407 100 - 1000 3644
>1000 4 >1000 14098 >1000 527
Statistics about (1) the number of users who own certain number of projects; and the
number of projects that have certain number of (2) commits and (3) branches.
Table 3: Database sizes in MB
#records Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS
200 10 10 11 11 46 30 3 3 10 17 12 9
2000 25 100 135 35 83 98 10 16 39 53 14 1420000 182 982 764 224 340 233 68 62 200 259 32 62
all in active use and range from 7K lines of code (Lobsters [ 17]) to
145K lines of code (Gitlab [13]).
3.2 Profiling Methodology
Populatingdatabases. ToprofileanORMapplication,weneed
topopulateitsdatabase.Withoutaccesstothedatabasecontentsin
thedeployedapplications,wecollectreal-worldstatisticsofeachap-
plicationbasedonitspublicwebsite(e.g., https://gitlab.com/explore
for Gitlab [ 13]) or similar application‚Äôs website (e.g., amazon [ 3]
statistics for e-commerce type applications). We then synthesize
database contents based on these statistics along with application-
specific constraints. Specifically, we implement a crawler that fills
out forms on the application webpages hosted on our profiling
serverswithdataautomaticallygeneratedbasedonthedatatype
constraints.Ourcrawlercarefullycontrolshowmanytimeseach
form is filled following the real-world statistics collected above.
TakeGitlabasanexample,anapplicationthatallowsusertoman-
ageprojectsandgitrepositories.WerunacrawleronourownGitlab
installation.Undereachgenerateduseraccount,thecrawlerfirst
randomlydecideshowmanyprojectsthisusershouldownbasedonthereal-worldstatisticscollectedfrom
https://gitlab.com/explore
shown in Table 2, say N, and then fills the create project page
Ntimes. The crawler continues to create new project commits,
branches, tags, and others artifacts in this manner.
Otherapplicationsarepopulatedsimilarly,andweskipthede-
tails due to space constraints. Virtual-machine images that contain
alltheseapplicationsandoursyntheticdatabasecontent,aswell
as data-populating scripts, are available at our project website [ 16].
Scaling input data. Wesynthesizethreesetsofdatabasecon-
tentsforeachapplicationthatcontain200,2000,and20 ,000records
initsmaindatabasetable,whichistheoneusedinrenderinghome-page,suchasthe
projects tableforGitlabandRedmine,the posts
tableforsocialnetworkapplications,etc.Othertables‚Äôsizesscale
up accordingly following the data distribution statistics discussed
above.Thetotaldatabasesizes(inMB)underthesethreesettings
are shown in Table 3.
When we discuss an application‚Äôs scalability, we compare its
performance among the above three settings. When we discuss an
application‚Äôs performance,wefocusonthe20 ,000-recordsetting,
whichisa realisticsettingforalltheapplicationsunderstudy.In
fact, based on the statistics we collect, the number of main table
802
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Table 4: Numbers of sampled and total issue reports
Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS
1 77 2 2 2 22 8221 21 35 37
4607 220 18038 12117 4805 114 158 1470 3206 400 17 650
The upper row shows the number of reports sampled for our study; the lower row
shows the total number of reports in each application‚Äôs bug-tracking system.
records of every application under study is usually larger than
20 ,000 in public deployments of the applications. For example,
LobstersandTracks‚Äômaintablesholdthefewestrecords,25 ,000
and 26 ,000, respectively. Many applications contain more than
1 million records in their main tables ‚Äî Spree‚Äôs official website
contains almost 500 million products, Fallingfruit‚Äôs official website
contains more than 1 million locations on map, etc.
Identifying problematic actions. Next, we profile applica-
tions to identify actions with potential performance problems. We
deploy an application‚Äôs latest version under Rails production mode
on AWS m4.xlarge instance [ 5] with populated databases. We run
a Chrome-based crawler [ 6] on another AWS instance to visit links
repeatedly and randomly for 2 hours to collect performance pro-
files for every actionin an application.2We repeat this for all three
setsofdatabasesshowninTable3,andeachsetisrepeatedfor3
times. Wethen processthe logproduced byboth Chromeand the
Rails Active Support Instrumentation API [ 1] to obtain the average
end-to-endloadingtimeforevery page,thedetailedperformance
breakdown, as well as issued database queries.
For each application, we firstly identify the top 10 most time-
consuming controller actions, among which we further classify an
action Aasproblematic ifiteitherspendsmore thanonesecondon
theserverside,meaningthatthecorrespondingend-to-endloading
time would likely approach two seconds, making it undesirable
for most users [ 24]; or its performance grows super-linearly as the
databasesizeincreasesfrom200to2 ,000andthento20 ,000records.
Theidentifiedactionsarethetargetofourstudyonperformance
and scalability problems as we describe in Section 5 and 6.
3.3 Report-Study Methodology
Tocomplementtheaboveprofilingthatexaminesthelatestversion
ofanapplicationusingoursyntheticdatasets,wealsostudytheper-
formanceissues reportedby usersbased onreal-world workloads
andfixedbydevelopersforpastversionsoftheseORMapplications,
so that we can understand how well these deployed applications
performed in the past.
Todoso,weexamineeachapplication‚Äôsbug-trackingsystem.For
6applicationsthatcontainfewerthan1000bugreports,asshownin
Table4,wemanuallycheckeverybugreport.Forapplicationswith
1000to5000bugreports,werandomlysample100bugreportsthat
have been fixed and contain the keywords performance, slow,o r
optimization.ForRedmineandGitlab,whichhavemorethan10,000bugreports,wesample200fromtheminthesameway.Bymanually
checking each report‚Äôs discussion, source code, and patches, weidentifytheonesthattrulyreflectperformanceproblemsrelatedto data processing on the server side. Every bug report is cross-
checked by at least two authors. This results in 140 reports in total
from all 12 applications, as shown in Table 4.
2Thedatabasesizewillincreasealittlebitduringprofilingassomepagescontainforms,
but the overall increase is negligible and does not affect our scalability comparison.Figure 2: End-to-end page loading time
Measured for top 10 time-consuming pages per application. Box: 25 to 75 percentile;
Red line: median; PA: problematic actions from all 12 applications (see Section 3.2).
Figure 3: Percentage of server time among end-to-end time
Measured for top 10 most time-consuming pages per application. Red line: median;
PA: problematic actions from all 12 applications (see Section 3.2)
3.4 Threats to Validity
Threats to the validity of our study could come from multiple
sources.Applicationsbeyondthese12applicationsmaynotshare
the same problems as these 12 applications. The profiling work-
loadsynthesizedbyusmaynotaccuratelyrepresentthereal-world
workload. The machine and network settings of our profiling may
bedifferentfromrealusers‚Äôsetting.Ourstudyofeachapplication‚Äôsbug-trackingsystemdoesnotconsiderbugreportsthatarenotfixed
or not clearly explained. Despite these aspects, we have made our
best effort in conducting a comprehensive and unbiased study, and
we believe our results are general enough to guide future research
on improving performance of ORM applications.
4 PROFILING RESULTS
End-to-end loading time. Weidentify the 10 pageswith the
most loading time for every application under the 20,000-record
databaseconfigurationandplottheiraverageend-to-endpageload-
ing time in Figure 2. 11 out of 12 applications have pages whoseaverage end-to-end loading time (i.e., from browser sending the
URL request to page finishing loading) exceeds 2 seconds; 6 out of
12applicationshavepagesthattakemorethan3secondstoload.
Tracksperformstheworst:allofitstop10mosttime-consuming
pagestakemorethan2secondstoload.Notethat,ourworkloadissmalleror, for some applications, much smaller than today‚Äôs
real-worldworkload.Consideringhowthereal-worldworkload‚Äôs
size will continue growing, these results indicate that performance
problems are prevalent and critical for deployed Rails applications.
803
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Table 5: Number of problematic actions in each application
App Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS
slow 0 0 1 1 3 0 0 0 0 1 0 0
not-scalable 1 1 0 0 0 0 2 0 1 2 3 1
slow & not-scalable 0 5 1 2 0 2 1 10 1 0 1 0
Server vs. client. We break down the end-to-end loading time
ofthetop10pagesineachapplicationintoservertime(i.e.,time
for executing controller action, including view rendering and data
access,onRailsserver),clienttime(i.e.,timeforloadingtheDOMin
thebrowser),andnetworktime(i.e.,timefordatatransferbetween
server and browser). As shown in Figure 3, server time contributes
to at least40% of the end-to-end-latencyfor more than half ofthe
top 10 pages in all but 1 application.3Furthermore, over 50% of
problematic pages spend more than 80% of the loading time on
Railsserver,asshownbytherightmostbar(labeled PA)inFigure3.
Thisresultfurthermotivatesustostudytheperformanceproblems
on the server side of ORM applications.
Problematic server actions. Table 5 shows the number of
problematicactionsforeachapplicationidentifiedusingthemethod-
ology discussed in Section 3.2. In total, there are 40 problematicactions identified from the top 10 most time-consuming actionsof every application. Among them, 34 have scalability problemsand 28 take more than 1 second of server time. Half of the pagesthat correspond to these 40 problematic actions take more than2 seconds to load, as shown in the rightmost bar (labeled
PA)i n
Figure 2. In addition, we find 64 performance issues in these 40
problematicactions,andwewilldiscussthemindetailinSection5.
5 CAUSES OF INEFFICIENCIES
After studying the 64 performance issues in the 40 problematic ac-
tions and the 140 issues reported in the applications‚Äô bug-tracking
systems,wecategorizetheinefficiencycausesintothreecategories:
ORM API misuses, database design, and application design. In the
following we discuss these causes and how developers have ad-
dressedthem.Webelievethesecausesapplytoapplicationsbuilt
usingotherORMframeworksaswell,aswewilldiscussinSection8.
5.1 ORM API Misuses
Abouthalfoftheperformanceissuesthatwestudiedsufferfrom
APImisuses.Inthesecases,performancecanbeimprovedbychang-
ing how the Rails APIs are used without modifying program se-mantics or database design. While some of these misuses appear
simple, making the correct decision requires deep expertise in the
implementation of the ORM APIs and query processing.
5.1.1 Inefficient Computation (IC)
In these cases, the poorly performing code conducts useful com-
putation but inefficiently. Such cases comprise more than 10% of
theperformanceissuesinbothbugreportsandproblematicactions.
Inefficientqueries. Thesameoperationonpersistentdatacan
beimplementedviadifferentORMcalls.However,theperformance
of the generated queries can be drastically different. This problem
has not been well studied before for ORM applications.
Figure4showstwowaysthatanonlineshoppingsystemchecks
ifthereareproduct variants whoseinventoryarenottracked.The
3Partoftheservertimecouldoverlapwiththeclienttimeorthenetworktime.However,
our measurement shows that the overlap is negligible.Table 6: Inefficiency causes across 12 applications
DsLoGiReSpRoFuTrDaOnFFOSSum
ORM API Misuse
IC0000010122208
00365002200018
UC0300000000205
10344101210017
ID01003203230115
314511002120029
UD0010000000001
2031200000008
IR0310000100005
Database Design Problems
MF0001000000113
0200200000105
MI0100000000203
31463003511330
Application Design Tradeoffs
DT100202610010022
51100103100214
FT0200000000002
32401021211219
Sum181724253178271711109204
Data with white background shows 64 issues from 40 problematic actions
Data with gray background shows 140 issues from 12 bug-tracking systems
IC: Inefficient Computation MF: Missing Fields
UC: Unnecessary Computation MI: Missing Indexes
ID: Inefficient Data Accessing DT: Content Display Trade-offs
UD: Unnecessary Data Retrieval FT: Functionality Trade-offs
IR: Inefficient Rendering
Ruby code differs only in the use of any?vsexists?. However,
the performance of the generated queries differs substantially: the
generated query in Figure 4(a) scans all records in the variants
tabletocomputethecountifnoindexexists,butthatinFigure4(b)
onlyneedstoscanandlocatethefirst variantrecordwherethe
predicate evaluates to true. Spreedevelopers discovered and fixed
this problem in Spree-6720 .4Our profiling finds similar problems.
Forexample,simplyreplacing any?withexists? inaproblematic
actionof OneBody improvesservertimeby1.7 √ó.Ourstaticchecker
that will be discussed in Section 8 finds that this is a common
problemasitappearsinthelatestversionsof9outof12applications
under study.
AnothercommonproblemisdevelopersusingAPIcallsthatgen-
eratequerieswithunnecessaryorderingoftheresults.Forexample,
Ror, Diaspora, and Spree developers use Object.where(c).first
togetanobjectsatisfyingpredicate cinsteadof Object.find_by(c) ,
notrealizingthattheformerAPIorders Objectsbyprimarykey
after evaluating predicate c. As a fix, both Gitlab and Tracks devel-
opers explicitly add except(:order) in the patches to eliminate
4We useA-nto denote report number nin application A‚Äôs bug-tracking system.
804
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. (a) Inefficient
(b) Efficient
Figure 4: Different APIs cause huge performance difference
Figure 5: A loop-invariant query in Redmine
unnecessaryordering inthe queries,further showinghow simple
changes can lead to drastic performance difference.
Moving computation to the DBMS. As the ORM framework
hides thedetails ofquery generation,developers oftenwrite code
that results in multiple queries being generated. Doing so incurs
extranetworkround-trips,orrunningcomputationontheserver
rather than the DBMS, which leads to performance inefficiencies.
For example, the patch of Spree-6720 replaces if(exist?)
find; else create withfind_or_create_by , where the latter
combines two queries that are issued by existandfind/create
intoone.Thepatchof Spree-6950 replacespluck(:total).sum
withsum(:total) . The former uses pluckto issue aquery toload
thetotalcolumn of all corresponding records and then computes
the sum in memory, while the latter uses sumto issue a query
that directly performs the sum in the DBMS without returning
actual records to the server. The patch of Gitlab-3325 replaces
pluck(:id)+pluck(:id) , which replaces two queries and an in-
memoryunionvia +withoneSQL UNIONquery,ineffectmoving
the computation to the DBMS. Such API misuses are very common
and occur in many applications as we will discuss in Section 8.
Therearealsomorecomplicatedcaseswherealoopimplemented
in Ruby can be completely pushed down to DBMS, which has been
addressed in previous work using program synthesis [29].
Moving computation to the server. Interestingly, there are
caseswherethecomputationshouldbemovedtotheserverfrom
theDBMS.Asfarasweknow,thisissuehasnotbeenstudiedbefore.
For example, in the patch of Spree-6819 , developers replace
Objects.count withObjects.size in 17 different locations, as
countalwaysissuesa COUNTquerywhile sizecountsthe Objects
inmemoryiftheyhavealreadybeenretrievedfromthedatabasebyearliercomputation.Suchissuesarealsoreportedin
Gitlab-17960 .
Summary. Rails,likeotherORMframeworks,letsdevelopers
implement a given functionality in various ways. Unfortunately,
developers often struggle at picking the most efficient option. The
deceptivenamesofmanyRailsAPIslike countandsizemakethis
even more challenging. Yet, we believe many cases can be fixed
using simple static analyzers, as we will discuss in Section 8.
5.1.2 Unnecessary Computation (UC)
Morethan10%oftheperformanceissuesarecausedby(mis)using
ORM APIs that lead to unnecessary queries being issued. This type
of problems has not been studied before.
Figure 6: A query with known results in Tracks
Loop-invariant queries. Sometimes, queries are repeatedly
issuedtoloadthe samedatabasecontentsandhenceareunneces-
sary. For instance, Figure 5 shows the patch from redmine-23334 .
This code iterates through every custom field valueand retains
only those that userhas write access to. To conduct this access-
permission checking, in every iteration, read_only_attribute_
names(user) issuesaquerytogetthenamesofallread-onlyfields
ofuser,asshownbytheredhighlightedlineinthefigure.Then,
ifvaluebelongs to this read-only set, it will be excluded from the
return set of thisfunction (i.e., the rejectat the beginning ofthe
loop takes effect). Here, the read_only_attribute_names(user)
query returns exactly the same result during every iteration of
the loop and causes unnecessary slowdowns. As shown by thegreen lines in figure, Redmine developers hoist loop invariant
read_only_attribute_names(user) outsidetheloopandachieve
more than 20 √óspeedup for the corresponding function for their
workload. Similar issues also occur in Spree and Discourse.
Dead-store queries. In such cases, queries are repeatedly is-
sued to load differentdatabase contents into the same memory
object while the object has not been used between the reloads. For
example, in Spree, every shopping transaction has a correspond-ing
orderrecord in the orderstable. This table has a has_many
association relationship with the line_items table, meaning that
everyordercontainsmultiplelinesofitems.Whenevertheuserup-dateshis/hershoppingcart,the
line_items tablewouldchange,at
whichpointtheoldversionofSpreealwaysusesan order.reload
to make sure that the in-memory copy of orderand its associated
line_item s are up-to-date. Later on, developers realize that this
repeatedreloadisunnecessary,becausethecontentof orderisnot
usedbytheprogramuntilcheckout.Consequently,in Spree-6379 ,
developersremovemany order.reload frommodelclasses,and
instead add it in a few places in the before_payment action of the
checkout controller, where the orderobject is to be used.
Queries with known results. A number of issues are due to
issuingquerieswhoseresultsarealreadyknown,henceincurring
unnecessarynetworkroundtripsandqueryprocessingtime.An
exampleisin Tracks-63 .AsshowninFigure6,thecodeoriginally
issues a query to retrieve up to show_number_completed num-
ber of completed tasks. Clearly, when show_number_completed
is 0, the query always returns an empty set due to limitbeing
0. Developers later realize that 0 is a very common setting for
show_number_completed . Consequently, they applied the patch
shown in Figure 6 to only issue the query when needed.
Summary. Whilesimilarissuesingeneralpurposeprograms
canbeeliminatedusingclassiccompileroptimizationtechniques
(e.g.,loopinvariantmotion,dead-storeelimination),doingsofor
ORM applications is difficult as it involves understanding data-
basequeries. Weare unawareofany compilersthatperform such
transformations.
805
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Figure 7: Inefficient lazy loading in Lobsters
Figure 8: Inefficient eager loading in Spree
5.1.3 Inefficient Data Accessing (ID)
Problems under this category suffer from data transfer slow
downs, including not batching data transfers (e.g., the well-known
‚ÄúN+1‚Äù problem) or batching too much data into one transfer.
Inefficientlazyloading. AsdiscussedinSection2,whenaset
of objects Oin table T1are requested, objects stored in table T2
associated with T1andOcan be loaded together through eager
loading. If lazy loading is chosen instead, one query will be issued
to load Nobjects from T1, and then Nseparate queries have to
beissuedtoloadassociationsofeachsuchobjectfrom T2.Thisis
known as the ‚ÄúN+1‚Äù query problem. While prior work has studied
this problem [ 7,18,28], we find it still prevalent: it appears in 15
problematic actions and 9 performance issues in our study.
Figure 7shows an examplethat we findin thelatest version of
Lobsters,wherethedeletedcoderetrieves50 modsobjects.Then,
for each mod, a query is issued to retrieve its associated story.
Using eager loading in the added line, all 51 queries (and hence
51networkround-trips)willbecombinedtogether.Inourexperi-
ments, the optimization reduces the end-to-end loading time of the
corresponding page from 1.10 seconds to 0.34 seconds.
Inefficient eager loading. However, always loading data ea-
gerly can also cause problems. Specifically, when the associated
objects are too large, loading them all at once will create huge
memorypressureandevenmake theapplicationunresponsive.In
contrasttothe‚ÄúN+1‚Äùlazyloadingproblem,thereislittlesupport
for developers to detect eager loading problems.
InSpree-5063 , a Spree user complains that their installation
performsverypoorlyontheproductsearchpage.DevelopersfoundthattheproblemwasduetoeagerloadingshowninFigure8.Intheuser‚Äôsworkload,whileloading405
products todisplayonthepage,
eagerloading causes13811related variants productscontaining
276220option_values (i.e.,productinformationdata)tobeloaded
altogether,makingthepagefreeze.AsshowninFigure8,thepatch
delays the loading of option_values fields ofvariants products.
Notethatthese option_values areneededbylatercomputation,
and the patch delays but not eliminates their loading.
Inefficientupdating. Likethe‚ÄúN+1‚Äùproblem,developerswould
issueNqueriestoupdateNrecordsseparately(e.g., objects.each
|o| o.update end ) rather than merging them into one update
(e.g.,objects.update_all ).ThisisreportedinRedmineandSpree,
and our static checker (to be discussed in Section 8) finds this to becommoninthelatestversionsof6outofthe12studiedapplications.
5.1.4 Unnecessary Data Retrieval (UD)
Unnecessary data retrieval happens when software retrieves
persistent data that is not used later. Prior work has identifiedthis problem in applications built using both Hibernate [
27] and
Rails [46]. In our study, we find this continues to be a problem
in one problematic action in the latest version of Gitlab and 9
performanceissuereports.Particularly,fixingtheunnecessarydata
(a) Inefficient partial rendering
(b) Efficient partial rendering
Figure 9: Inefficient partial rendering in Gitlab
retrieval in the latest version of Gitlab can drop the end-to-endloading time of its
Dashboard/Milestones/index page from 3.0
to1.1secondsinourexperiments.Wealsoseesomeunnecessary
dataretrievalcausedbysimplemisusesofAPIsthathavesimilar
names‚Äî map(&:id) retrievesthewholerecordandthenreturns
theidfield, yet pluck(:id) only retrieves the idfield.
5.1.5 Inefficient Rendering (IR)
IRreflectsatrade-offbetweenreadabilityandperformancewhen
a view file renders a set of objects. It has not been studied before.
Givenalistofobjectstorender,developersoftenusealibrary
function,like link_to onLine4ofFigure9(a),torenderoneobject
andencapsulateitinapartialviewfilesuchas _milestone.html.haml
inFigure9(a).Then,themainviewfile index.html.haml simply
applies the partial view file repeatedly to render all objects. The
inefficiency is that a rendering function like link_to is repeatedly
invoked to generate very similar HTML code. Instead, the view file
could generate the HTML code for one object, and then use simple
string substitution, such as gsubin Figure 9(b), to quickly generate
theHTMLcodefortheremainingobjects,avoidingredundantcom-putation.Thelatterwayofrenderingdegradescodereadability,but
improves performance substantially when there are many objects
to render or with complex rendering functions.
Although slow rendering is complained, such transformation
hasnotyetbeenproposedbyissuereports.Ourprofilingfindssuch
optimization speedsup5pr oblematic actions by 2.5√ó on average.
5.2 Database Design Problems
Anotherimportantcauseofperformanceproblemsissuboptimal
database design. Fixing it requires changing the database schema.
5.2.1 Missing Fields (MF)
Decidingwhichobjectfieldtobephysicallystoredindatabaseis
a non-trivial part of database schema design. If a field can be easily
derived from other fields, storing it in database may waste storage
space and I/O time when loading an object; if it is expensive to
compute,notstoringitindatabasemayincurmuchcomputation
cost.Decidingwhenapropertyshouldbestoredpersistentlyisa
general problem that has not been studied in prior work.
Forexample,whenweprofilethelatestversionofOpenstreetmap[ 19],
a collaborative editable map system, we find that a lot of time is
spent on generating a location_name string for every diary based
onthediary‚Äôslongitude,latitude,andlanguagepropertiesstored
inthediary_entry table.Suchslowcomputationresultsinaprob-
lematicactiontaking1secondtoshowonly20diaries.However,the
806
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. location_name isusuallyashortstringandremainsthesamevalue
sincethelocationinformationforadiarychangesinfrequently.Stor-
ingthisstringphysicallyasadatabasecolumnavoidstheexpensive
computation. We evaluate this optimization and find it reducing
the action time to only 0.36 second.
WeobservesimilarproblemsinthebugreportsofLobster,Spree,
andFallingfruit,andinthelatestversionofRedmine,Fallingfruit,
and Openstreetmap. Clearly, developers need help on performance
estimationtodeterminewhichfieldstopersistentlystoreindata-
base tables.
5.2.2 Missing Database Indexes (MI)
Having the appropriate indexes on tables is important for query
processingandisawell-studiedproblem[ 42].AsshowninTable6,
missingindexisthemostcommonperformanceproblemreportedin
ORM application‚Äôs bug tracking systems. However, it only appears
in three out of the 40 problematic actions in latest versions. We
speculate that ORM developers often do not have the expertiseto pick the optimal indexes at the design phase and hence addtable indexes in an incremental way depending on which query
performance becomes a problem after deployment.
5.3 Application Design Trade-offs
Developers fix 33 out of the 140 issue reports by adjusting appli-
cationdisplayorremovingcostlyfunctionalities.Wefindsimilar
design problems in latest versions of 7 out of 12 ORM applications.
Itisimpracticaltocompletelyautomatedisplayandfunctionality
design. However, our study shows that ORM developers need tool
support,whichdoesnotexistyet,tobemoreinformedaboutthe
performance implication of their application design decisions.
5.3.1 Content Display Trade-offs (DT)
In our study, the most common cause for scalability problems
isthatacontrolleractiondisplays alldatabaserecordssatisfying
certainconditioninonepage.Whenthedatabasesizeincreases,the
correspondingpagetakesalotoftimetoloadduetotheincreasing
amount of data to retrieve and render. This problem contributes to
15 out of the 34 problematic actions that do not scale well in our
study. It also appears in 7 out of 140 issue reports, and is always
fixed bypagination, i.e., displayonly a fixednumber of recordsin
one page and allow users to navigate to remaining records.
Forexample,in Diaspora-5335 developersusedthe will_paginate
library[20]torender25contactsperpageandallowuserstosee
theremainingcontactsbyclickingthenavigationbaratthebottom
ofthepage,insteadofshowingallcontactswithinonepageasin
the old version. Clearly, good UI designs can both enhance user
experience and improve application performance.
Unfortunately, the lack of pagination still widely exists in latest
versionsofORMapplicationsinourstudy.ThisindicatesthatORM
developersneeddatabase-awareperformance-estimationsupport
to remind them of the need to use pagination in webpage design.
5.3.2 Application Functionality Trade-offs (FT)
It is often difficult for ORM developers to estimate performance
of a new application feature given that they need to know what
queries will be issued by the ORM, how long these queries will
execute, and how much data will be returned from the database. In
ourstudy,allbuttwoapplicationshaveperformanceissuesfixed
by developers through removing functionality.(a)Server-timespeedup( √ó) (b) Line of code changes
Figure 10: Performance fixes and LOC involved
Forexample, Tracks-870 madeatrade-offbetweenperformance
andfunctionalitybyremovingasidebarontheresultingpage.This
sidebarretrievesanddisplaysall theprojectsandcontextsofthe
currentuser,andcostsalotoftimeforuserswhohaveparticipated
in manyprojects. In theside-bar code, theonly data-related part
is simply a @sidebar.active_projects expression, which seems
like a trivial heap access but actually issues a SELECTquery and
retrieves a lot of data from the database.
As another example, our profiling finds that the story.edit ac-
tioninthelatestversionofLobsterstakes1.5secondsjusttoexecute
one query that determines whether to show the guidelines for
users when they edit stories, while the entire page takes 2 seconds
to load altogether. Since the guidelines object only takes very
small amount of space to show on the resulting page, removing
suchcheckinghasnegligibleimpacttotheapplicationfunctionality,
yetitwouldspeedupthe loading time of that page a lot.
Ingeneral,performanceestimationforapplicationsbuiltusing
ORMsisimportantyethasnotbeendonebefore.Itismoredifficult
as compared to traditional applications due to multiple layers of
abstraction. We believe combining static analysis with query scala-
bility estimation [ 25,31] will help developers estimate application
performance, as we will discuss in Section 8.
6 FIXING THE INEFFICIENCIES
After identifying the performance inefficiencies in the 40 problem-
aticactionsacrossthe12studiedapplications,wemanuallyfixeachofthemandmeasurehowmuchourfixesimprovetheperformance
of the corresponding application webpages. Our goal is to quantify
the importance of the anti-patterns discussed in Section 5.
6.1 Methodology
We use the same 20,000-record database configuration used in pro-
filing to measure performance improvement. For a problematic
action that contains multiple inefficiency problems, we fix one at a
time and report the speedup for each individual fix. To fix API-use
problems,wechangemodel/view/controlfilesthatarerelatedtothe
problematic APIuses; to add missingindexes or fields, wechange
corresponding Rails migration files; to apply pagination, we use
the standard will_paginate library [20]. We carefully apply fixes
to make sure we do not change the program semantics. Finally, for
two actions in Lobster, we eliminate the expensive checking about
whether to show user guidelines, as discussed in Section 5.3.2.
807
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. 6.2 Results
Intotal,64fixesareappliedacross39problematicactions5tosolve
the 64 problems listed in Table 6.
Speedupofthefixes. Figure10(a)showstheamountofserver-
time speedup and the sources of the speedup broken down into
different anti-patterns as discussed in Section 5.
Manyfixesareveryeffective.Aboutaquarterofthemachieve
morethan5 √óspeedup,andmorethan60%ofthemachievemore
than 2√óspeedup. Every type of fixes has at least one case where it
achievesmorethan2 √óspeedup.Thelargestspeed-upisaround39 √ó
achievedbyremovingunnecessaryfeaturein StoriesController.new
action in Lobsters, i.e., the example we discussed in Section 5.3.2.
There are 40 fixes that alter neither the display nor the function-
alityoftheoriginalapplication.Thatis,theyfixtheanti-patterns
discussed in Section 5.1 and 5.2. They achieve an average speedup
of 2.2√ó, with a maximum of 9.2 √óspeedup by adding missing fields
inGanttsController.show from Redmine.
Forall39problematicactions,manyofwhichbenefitfrommore
thanonefix,theiraverageservertimeisreducedfrom3.57seconds
to 0.49 seconds, and the corresponding end-to-end page loading
time is reduced from 4.17 seconds to 0.69 seconds, including client
rendering and network communication. In other words, by writing
codethatcontainstheanti-patternsdiscussedearlier,developers
degrade the performance of their applications by about 6√ó.
Wehavereportedthese64fixestocorrespondingdevelopers.So
far, we have received developers‚Äô feedback for 14 of them, all of
whichhavebeenconfirmedtobetrueperformanceproblemsand7
have already been fixed based on our report.
Simplicity of the fixes. Figure 10(b) shows the lines of code
changes required to implement the fixes. The biggest change takes
56linesofcodetofix(foraninefficientrendering(IR)anti-pattern),
whilethesmallestchangerequiresonly1lineofcodein27fixes.
Morethan78%offixesrequirefewerthan5lines.Inaddition,among
the fixes that improve performance by 3 √óor more, more than 90%
ofthemtakefewerthan10linesofcode.Around60%offixesare
intra-procedural, involving only one function.
Theseresultsquantitativelyshowthatthereisstillahugeamount
ofinefficiencyinreal-worldORMapplications.Muchinefficiency
can be removed through few lines of code changes. A lot of the
fixes can potentially be automated, as we will discuss in Section 8.
7 FINDING MORE API MISUSES
SomeproblemsdescribedinSection5.1areaboutsimpleAPImis-
uses.Weidentify9suchsimplemisusepatterns,aslistedinTable
7,andimplementastaticanalyzertosearchfortheirexistencein
latestversionsofthe12ORMapplications.Duetospaceconstraints,
we skip the implementation details. To recap, these 9 API patterns
cause performance losses due to ‚ÄúAn Inefficient Query‚Äù ( 1,2,
3), ‚ÄúMoving Computation to the DBMS‚Äù ( 7,8,9), ‚ÄúMoving
ComputationtotheServer‚Äù( 5),‚ÄúInefficientUpdating‚Äù( 4),and
‚ÄúUnnecessary Data Retrieval‚Äù ( 6), as discussed in Section 5.1.
As shown in Table 7, every API misuse pattern still exists in
at least one application‚Äôs latest version. Worse, 4 patterns each
5Amongthe40problematicactionsidentifiedbyourprofiling,1ofthem(fromGitLab)
spendsmostofitstimeinfile-systemoperationsandcannotbespedupunlessitscore
functionality is modified.Table 7: API misuses we found in the latest versions
App.123456789 SUM
D s 8 6 100663018 5
L o1 3 800051004 5
G i7301633002 3
R e3 3 201 1 670005 9
S p2 1 000007102 0
R o 0701102001 1
F u000020000 2
T r4 2 201300003 0
D a 5 4 211080005 7
O n 1 0 6 000600007 6
F F200200000 4
O S 0 1 200220001 6
SUM 42 287 1 7 42 31 16 1 1 428
1:any?‚áíexists? 2:where.first ‚áífind_by
3:*‚áí*.except(:order) 4:each.update ‚áíupdate_all
5:.count‚áí.size 6:.map‚áí.pluck
7:pluck.sum ‚áísum 8:pluck + pluck ‚áíSQL-UNION
9:if exists? find else create end ‚áífind_or_create_by
occurinover30placesacrossmorethan5applications.Wehave
checkedallthese428placesandconfirmedeachofthem.Forfurther
confirmation, we posted them to corresponding application‚Äôs bug-
trackingsystem,andeverycategoryhasissuesthathavealready
been confirmed by application developers. 53 API misuses have
been confirmed, and 29 already fixed in their code repositories
based on our bug reports. None of our reports has been denied.
Only 3 out of these 428 API misuses coincide with the 64 per-
formanceproblemslistedinTable6andfixedinSection6.Thisis
becausemostofthese428casesdonotresideinthe40problematic
actions that we have identified as top issues in our profiling. How-ever, they do cause unnecessary performance loss, which could be
severeunderworkloadsthatdifferfromthoseusedinourprofiling.
Insum,theaboveresultsconfirmourpreviouslyidentifiedissues,
and furthermore indicate that simple API misuses are pervasive
acrosseventhelatestversionsoftheseORMapplications.Yet,there
are many other types of API misuse problems discussed in Sec-
tion 5.1 that cannot be detected simply through regular expression
matching and will require future research to tackle.
8 DISCUSSION
Inthissection,wesummarizethelessonslearnedandhighlightthe
new research opportunities that are opened up by our study.
Improving ORM APIs. Our study shows that many misused
APIs have confusing names, as listed in Table 7, but are translated
todifferentqueriesandhaveverydifferentperformance.Renaming
someoftheseAPIscouldhelpalleviatetheproblem.Addingnew
APIs can also help developers write well-performing code without
hurting code readability. For example, if Rails provides native API
support for taking union of two queries‚Äô results like Django [ 9]
does,there willbefewer casesofinefficient computation,suchas
those discussed in Section 5.1.1. As another example, better ren-
dering API supports could help eliminate inefficient partial render
808
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. problemdiscussedinSection5.1.5.Toourbestknowledge,noORM
framework provides this type of rendering support.
SupportfordesignanddevelopmentofORMapplications.
Developersneedhelptobetterunderstandtheperformanceoftheir
code,especiallythepartsthatinvolveORMAPIs.TheyshouldfocusonnotonlyloopsbutORMlibrarycalls(e.g.,joins)inperformance
estimation, since these calls often execute database queries and
can be expensive in terms of performance. Building static analysis
toolsthatcanestimateperformanceandscalabilityofORMcode
snippets will alleviate some of the API misuses. More importantly,
thiscanhelpdevelopersdesignbetterapplicationfunctionalityand
interfaces, as discussed in Section 5.3.
Developers will also benefitfrom tools that can aid in database
design,suchassuggestingfieldstomakepersistent,asdiscussedinSection5.2.Whilepriorworkfocusesonindexdesign[
4],littlehas
been done on aiding developers to determine which fields to make
persistent.AstheORMapplicationalreadycontainsinformation
onhoweachobjectfieldiscomputedandused,thisprovidesagreat
opportunity for program analysis to further help in both aspects.
Compiler and runtime optimizations. While some perfor-
manceissuesarerelatedtodevelopers‚Äôdesigndecisions,webelieve
that others can be detected and fixed automatically. Previous work
hasalreadytackledsomeoftheissuessuchaspushingcomputation
down to database through query synthesis [ 29], query batching
[28,40], and avoiding unnecessary data retrieval [ 27]. There are
still many automatic optimization opportunities that remain un-
studied.ThisrangesfromcheckingforAPImisuses,aswediscussed
in Section 7, to more sophisticated database-aware optimization
techniques to remove unnecessary computation (Section 5.1.2) and
inefficient queries (Section 5.1.1).
Besides static compiler optimizations, runtime optimizations or
trace-based optimization for ORM frameworks are further possi-
bilities for future research, such as automatic pagination for ap-
plications that render many records, runtime decisions to move
computation between the server and the DBMS, runtime decisions
toswitchbetweenlazyandeagerloading,andruntimedecisions
aboutwhethertoremovecertainexpensivefunctionalitiesasdis-
cussed in Section 5.3.2. Automated tracing and trace-analysis tools
can help model workloads and workload changes, which can then
be used to adapt database and application designs automatically.Such tools will need to understand the ORM framework and the
interaction among the client, server, and DBMS.
Generalizing to other ORM frameworks. Ourfindingsand
lessonsapply tootherORM frameworksaswell. Thedatabase de-
sign (Section 5.2) and application design trade-offs (Section 5.3)
naturallyapplyacrossORMs.MostoftheAPIuseproblems(Sec-
tion 5.1), like unnecessary computation (UC), data accessing (ID,
UD), and rendering (IR), are not limited to specific APIs and hence
are general. While the API misuses listed in Table 7 may appear to
beRailsspecific,therearesimilarmisusesinapplicationsbuiltupon
Django ORM [ 9] as well: exists() is more efficient than count>0
(1);filter().get() is faster than filter().first (2);clear
_ordering(True) is likeexcept(:order) (3);all.update can
batchupdates( 4);len()isfasterthan count()withloadedarrays
(5);only()is likepluck()(6);aggregate (Sum) is likesumin
Rails(7);unionallowstwoqueryresultstobeunionedindatabase
(8);get_or_create islikefind_or_create_by inRails( 9).Wesampled15issuereportseachfromtop3popularDjangoapplica-
tions on GitHub. As shown below, these 45 performance issues fall
into the same 8 anti-patterns our 140 Rails issue reports fall into:
IC UC ID UD MF MI DT FT
Redash [21] 2 3 6 0 0 0 2 2
Zulip [23] 2 5 2 1 0 2 1 2Django-CMS [10] 0 9 3 0 1 0 1 1
9 RELATED WORK
Empiricalstudies. Previousworkconfirmedthatperformance
bugs are prevalent in open-source C/Java programs and often take
developerslongertimetofixthanothertypesofbugs[ 33,47].Prior
work[41]studiedtheperformanceissuesinJavaScriptprojects.We
target performance problems in ORM applications that are mostly
relatedtohowapplicationlogicinteractswithunderlyingdatabase
andareverydifferentfromthoseingeneralpurposeapplications.
Ourrecentwork[ 46]lookedintothedatabaseperformanceofORM
applicationsanddiscussedhowbetterdatabaseoptimizationand
querytranslationcanimproveORMapplicationperformance.No
issue report study or thorough profiling was done. In contrast, our
paperperformsacomprehensivestudyonalltypesofperformance
issuesreportedbydevelopersanddiscoveredusingprofiling.Un-
necessary data retrieval (UD), content display trade-offs (DT), and
part of the inefficient data accessing (ID) anti-patterns are the only
overlap between this study and our previous work [46] .
Inefficiencies in ORM applications. Previous work has ad-
dressedspecificperformanceproblemsinORMapplications,suchas
locatingunneededcolumndataretrieval[ 27],N+1query[ 26],push-
ingcomputationtotheDBMS[ 29],andquery batching[ 28,40,45].
While effective, these tools do nottouch on many anti-patternsdis-
cussed in our work, like unnecessary computation (UC), inefficient
rendering (IR), database designs (MF, MI), functionality trade-offs
(FT), and also do not completely address anti-patterns like ineffi-
cient computation (IC) and inefficient data accessing (ID).
Performance issues in other types of software. Much re-
searchwasdonetodetectandfixperformanceproblemsingeneral
purpose software [ 30,33,36,37,39,43,44]. Detecting and fixing
ORMperformanceanti-patternsrequireacompletelydifferentsetoftechniquesthatunderstandORMandunderlyingdatabasequeries.
10 CONCLUSION
Database-backed web applications are widely used and often built
using ORM frameworks. We conduct a comprehensive study to un-
derstandhowwellsuchapplicationsperformandscalewiththedata
theymanage.Byprofilingthelatestversionsof12representative
ORMapplicationsandstudyingtheirbug-trackingsystems,wefind
9 types of ORM performance anti-patterns and many performance
problemsinthelatestversionsoftheseapplications.Ourfindings
openupnewresearchopportunitiestodeveloptechniquesthatcan
help developers solve performance issues in ORM applications.
11 ACKNOWLEDGEMENTS
This work is supported in part by the National Science Founda-
tion through grants IIS-1546083, IIS-1651489, IIS-1546543, OAC-
1739419, CNS-1514256, CCF-1514189, and CNS-1563788; DARPA
award FA8750-16-2-0032; DOE award DE-SC0016260; gifts from
Adobe,Google,andtheCERESCenterforUnstoppableComputing.
809
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1]Active Support Instrumentation.
http://guides.rubyonrails.org/active_support_instrumentation.html/.
[2]Airbnb. An online marketplace and hospitality service application.
https://www.airbnb.com/.
[3]Amazon. An online e-commerce application.https://amazon.com/.
[4]AutoAdmin. For database systems self-tuning and self-administering.https://www.microsoft.com/en-us/research/project/autoadmin/.
[5]AWS instance types. https://aws.amazon.com/tw/ec2/instance-types/.
[6]Browser Ranking.
http://www.zdnet.com/article/chrome-is-the-most-popular-web-browser-of-all/.
[7]Bullet. A library used to solv eN+1query problem for Ruby on Rails.
https://github.com/flyerhzm/bullet/.
[8]Diaspora. A social-network application.
https://github.com/diaspora/diaspora/.
[9]Django. https://www.djangoproject.com/.
[10]Django-cms. An enterprise content management system.
https://github.com/divio/django-cms/.
[11]Find your new favorite web framework.
https://hotframeworks.com/.
[12]Github. https://github.com/.
[13]Gitlab. A software to collaborate on code.
https://github.com/gitlabhq/gitlabhq/.
[14]Hibernate. http://hibernate.org/.
[15]Hulu. A subscription video on demand service application.
https://www.hulu.com/.
[16]Hyperloop. http://hyperloop.cs.uchicago.edu.
[17]Lobsters. A forum application.
https://www.github.com/jcs/lobsters/.
[18]N + 1 query problem. https://www.sitepoint.com/silver-bullet-n1-problem/.
[19]OpenStreetMap. A map service application.https://github.com/openstreetmap/openstreetmap-website/.
[20]Pagination. A library used in webpage displaying.
https://github.com/mislav/will_paginate/.
[21]Redash. An application to connect your company‚Äôs data.
https://github.com/getredash/redash/.
[22]Ruby on Rails. http://rubyonrails.org/.
[23]Zulip. A powerful team chat system.
https://github.com/zulip/zulip/.
[24] Akamai and Gomez.com. How Loading Time Affects Your Bottom Line.
https://blog.kissmetrics.com/loading-time/.
[25]
MichaelArmbrust,EricLiang,TimKraska,ArmandoFox,MichaelJ.Franklin,and
David A. Patterson. 2013. Generalized Scale Independence Through Incremental
Precomputation. In SIGMOD. 625‚Äì636.
[26]Tse-Hsun Chen, Weiyi Shang, Zhen Ming Jiang, Ahmed E. Hassan, Mohamed
Nasser, and Parminder Flora. 2014. Detecting Performance Anti-patterns for
Applications Developed Using Object-relational Mapping. In ICSE. 1001‚Äì1012.[27]Tse-Hsun Chen, Weiyi Shang, Zhen Ming Jiang, Ahmed E. Hassan, Mohamed
Nasser, and Parminder Flora. 2016. Finding and evaluating the performance
impact of redundant data access for applications that are developed using object-
relational mapping frameworks.. In ICSE. 1148‚Äì1161.
[28]Alvin Cheung, Samuel Madden, and Armando Solar-Lezama. 2014. Sloth: Being
Lazy is a Virtue (when Issuing Database Queries). In SIGMOD. 931‚Äì942.
[29]AlvinCheung,ArmandoSolar-Lezama,andSamuelMadden.2013. Optimizing
database-backed applications with query synthesis. In PLDI. 3‚Äì14.
[30]Bruno Dufour, Barbara G. Ryder, and Gary Sevitsky. 2008. A Scalable Tech-
nique for Characterizing the Usage of Temporaries in Framework-intensive Java
Applications. In FSE. 59‚Äì70.
[31]WenfeiFan,FlorisGeerts,andLeonidLibkin.2014. OnScaleIndependencefor
Querying Big Data. In PODS. 51‚Äì62.
[32] Paul Graham. Startup = Growth. http://paulgraham.com/growth.html.
[33]LinhaiSongXiaomingShiJoelScherpelzJin,GuoliangandShanLu.2012. Un-
derstanding and detecting real-world performance bugs. In PLDI. 77‚Äì88.
[34]Emre Kiciman and Benjamin Livshits. 2007. AjaxScope: a platform for remotely
monitoring the client-side behavior of Web 2.0 applications. ACM SIGOPS Oper-
ating Systems Review. 41, 6 (2007), 17‚Äì30.
[35]GregLinden. MarissaMayeratWeb2.0. http://glinden.blogspot.com/2006/11/
marissa-mayer-at-web-20.html/.
[36]AdrianNistor,Po-ChunChang,CosminRadoi,andShanLu.2015. CARAMEL:
Detecting and Fixing Performance Problems That Have Non-Intrusive Fixes. In
ICSE. 902‚Äì912.
[37]AdrianNistor,LinhaiSong,DarkoMarinov,andShanLu.2013. Toddler:detecting
performance problems via similar memory-access patterns. In ICSE. 562‚Äì571.
[38]Stephen O‚ÄôGrady. The RedMonk Programming Language Rankings: June 2017.
http://redmonk.com/sogrady/2017/06/08/language-rankings-6-17/.
[39]OswaldoOlivo,IsilDillig,andCalvinLin.2015. Staticdetectionofasymptotic
performance bugs in collection traversals. In PLDI. 369‚Äì378.
[40]Karthik Ramachandra, Chavan Mahendra, Guravannavar Ravindra, and S Su-
darshan. 2015. Program Transformations for Asynchronous and Batched Query
Submission. In TKDE. 531‚Äì544.
[41]MarijaSelakovicandMichaelPradel.2016. Performanceissuesandoptimizations
in javascript: an empirical study. In ICSE. 61‚Äì72.
[42]Jeffrey D. Ullman and Jennifer Widom. 1997. A First Course in Database Systems.
Prentice-Hall, Inc., Upper Saddle River, NJ, USA.
[43]GuoqingXu,MatthewArnold,NickMitchell,AtanasRountev,andGarySevitsky.
2009. GowiththeFlow:ProfilingCopiestoFindRuntimeBloat.In PLDI.419‚Äì430.
[44]Guoqing Xu, Nick Mitchell, Matthew Arnold, Atanas Rountev, Edith Schonberg,
and Gary Sevitsky. 2010. Finding Low-utility Data Structures. In PLDI. 174‚Äì186.
[45]Cong Yan and Alvin Cheung. 2016. Leveraging Lock Contention to Improve
OLTP Application Performance. In VLDB. 444‚Äì455.
[46]Cong Yan, Junwen Yang, Alvin Cheung, and Shan Lu. 2017. Understanding
Database Performance Inefficiencies in Real-world Web Applications. In CIKM.
[47]BramAdamsZaman,ShahedandAhmedE.Hassan.2012. Aqualitativestudy
on performance bugs.. In MSR. 199‚Äì208.
810
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. 