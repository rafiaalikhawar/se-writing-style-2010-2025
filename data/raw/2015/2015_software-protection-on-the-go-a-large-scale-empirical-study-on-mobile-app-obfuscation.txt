SoftwareProtectionontheGo:ALarge-ScaleEmpiricalStudyon
Mobile App Obfuscation
Pei Wang∗
pxw172@ist.psu.edu
The Pennsylvania State
UniversityQinkun Bao
qub14@ist.psu.edu
The Pennsylvania State
UniversityLi Wang
lzw158@ist.psu.edu
The Pennsylvania State
UniversityShuai Wang
szw175@ist.psu.edu
The Pennsylvania State
University
Zhaofeng Chen
chenzhaofeng@baidu.com
Baidu X-LabTao Wei
lenx@baidu.com
Baidu X-LabDinghao Wu
dwu@ist.psu.edu
The Pennsylvania State
University
ABSTRACT
The prosperity of smartphone markets has raised new concerns
about software security on mobile platforms, leading to a grow-
ingdemandforeffectivesoftwareobfuscationtechniques.Dueto
variousdifferencesbetweenthemobileanddesktopecosystems,ob-
fuscation facesboth technical andnon-technical challengeswhen
appliedtomobilesoftware.Althoughtherehavebeenquiteafew
software security solution providers launching their mobile app
obfuscation services, it is yet unclear how real-world mobile devel-
opers perform obfuscation as part of their software engineering
practices.
Our research takes a first step to systematically studying the
deployment of software obfuscation techniques in mobile software
development. With the help of an automated but coarse-grained
method, we computed the likelihood of an app being obfuscated
for over a million app samples crawled from Apple App Store. We
then inspected the top 6600 instances and managed to identify
601 obfuscated versions of 539 iOS apps. By analyzing this sample
set with extensive manual effort, we made various observations
thatrevealthestatusquoofmobileobfuscationintherealworld,
providing insights into understanding and improving the situation
of software protection on mobile platforms.
CCS CONCEPTS
•Softwareanditsengineering →Softwarereverseengineer-
ing;•Securityandprivacy →Softwaresecurityengineering ;
Mobile and wireless security;
KEYWORDS
obfuscation, reverse engineering, mobile app, empirical study
∗Part of the research was done during an internship at Baidu X-Lab.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180169ACM Reference Format:
Pei Wang, Qinkun Bao, Li Wang, Shuai Wang, Zhaofeng Chen, Tao Wei,
andDinghaoWu.2018.SoftwareProtectionontheGo:ALarge-ScaleEm-
piricalStudyonMobileAppObfuscation.In ICSE’18:40thInternationalCon-
ference on Software Engineering , May 27–June 3, 2018, Gothenburg, Sweden.
ACM,NewYork,NY,USA,11pages.https://doi.org/10.1145/3180155.3180169
1 INTRODUCTION
Concerns on security breaches targeting mobile apps have kept
rising in past years. It was reported the piracy rates of popular
mobileappscanapproachto60–95%[ 7].ResearchbyGibleretal.
foundthatasurprisinglylargeportionofmobileapplicationsare
“copies”ofothers[ 19].Besidesthesetraditionalintellectualprop-
ertytheftproblems,theindustryisalsofacingnewsecuritythreatsastherearenowmanybusinessesheavilyrelyingonmobiledevices
tooperate,amongwhichthefraudulentandmaliciouscampaigns
conducted through automatically manipulating a massive number
ofmobiledevices[ 14]areparticularlyharmfultothemobileecosys-
tems.Fromatechnicalpointofview,reverseengineeringmobile
apps in generaltakes less effort than traditionaldesktop software,
due to the wide use of reflective programming languages like Java
andObjective-Candtheregulatedbinarystructuresrestrictedby
themobilehardwareandsoftwareenvironments.Thesoaringof
unprecedented security challenges and the lack of natural defenses
call have driven mobile developers to seek additional protections.
One of the most important software protection technologies
is software obfuscation, which is a kind of semantics-preservingprogram transformations that aim to make software code more
difficult for automated tools and humans to analyze. Although
obfuscation-relatedresearchtopicshavebeenintensivelystudied
fordecades,mostpreviousworkfocusesonin-labtechnicalanalysis
oftheeffectivenessofnewobfuscationtechniques[ 22,35,40,42,43]
or countermeasures against obfuscation when it is misused by
malwarewriters[ 13,45].Asfaraswehavelearned,littleemphasisis
putoninvestigatinghowbenignsoftwareauthorstakeobfuscation
as part of their development process in the real world, which is
criticalforsoftwareobfuscationtechniquestobepractical.Topush
this line of research forward, we aim to investigate the answers
to the following important research questions: RQ1:What are the
characteristics of obfuscated mobile apps? ;RQ2:In what patterns
are mobile apps typically obfuscated? ;RQ3:How does app review
262018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden P. Wang et al.
affecttheadoptionofobfuscation? ;andRQ4:Howresilientarethe
obfuscated apps to malicious reverse engineering?
Todevelopmeaningfulconclusions,itismostadequatetocon-
duct an empirical study on a reasonably large set of recently de-
veloped and supposedly benign mobile apps obfuscated by their
vendors.Unfortunately,thereisnosuchadatasetavailableforpub-
licaccess,sowedecidedtocollectsamplesindependently.Thereare
currentlytwomajorplatformsinmobilesoftwaremarkets,i.e.,iOS
andAndroid.Althoughtheysharemanycommoncharacteristics,
there are also notable differences. Some previous research has indi-
rectlyorimplicitlytouchedthetopicofmobileappobfuscation,butthefocusismostlyonAndroid.Forexample,thestudybyZhouand
Jiang on Android malware revealed some obfuscated samples [ 47].
Linares-Vásquez et al. [ 26] and Glanz et al. [ 20] investigated An-
droid app repacking, with the potential disturbance of obfuscation
considered. On theother hand, the iOS platformreceived notably
less attention which mismatches its share in the market. With over
abillioniOSmobiledevicessold,therearereportedlymillionsof
softwareprogrammersworkingoniOSappdevelopment.Inthis
study, we chose to work on iOS for a dual purpose of filling in the
blankofempiricalstudiesonmobileappobfuscationandenriching
scientific research on this important mobile platform.
To obtain a representative sample set, we crawled 1 ,145,582
freeiOS appinstances fromtheofficial AppleApp Store.We then
estimatedthelikelihoodofeachinstancebeingobfuscatedbased
on a variant of a statistical language model previously proposed
for studying software source code [ 21,27]. We picked the top 6600
most likely obfuscated samples and identified 539 that are truly
obfuscatedwithmanualverification.Foreachsample,wefurther
conductedin-depthinvestigationstounderstandhowobfuscation
was applied. In general, effectively analyzing a large amount of ob-
fuscated binary code can be extremely difficult, since most existing
program analysis techniques have either scalability or accuracyissues regarding obfuscated code. Moreover, analyzing iOS apps
has its own unique challenges, one of which is caused by the wide
use ofstatically linked third-party libraries [16]. To overcome these
obstaclesaltogether,ourstudycombinedautomatedanalysiswithaconsiderableamountofmanualeffortfromknowledgeablesoftwarereverseengineerswithindustryexperience.Afterexaminingallthesamples,weformulated8findingsregardingtheproposedresearch
questions.
In summary, we made the following contributions in this re-
search:
•We are the first to conduct a comprehensive empirical studytargeting mobile software obfuscation. Our research focuses
oniOS,aninfluentialmobileplatformthatdidnotreceive
enough attention from the academia in contrast to Android.
•We developed a scalable detection algorithm to estimate the
likelihoodofaniOSappbeingobfuscatedandappliedittoa
largequantityofappscrawledfromAppStore.Afterman-
ually analyzing the 6600 most likely obfuscated instances,
weidentified539trulyobfuscatediOSappswithatotalof
601 different versions. As far as we know, this is the first
scientificallycollectedsamplesetofobfuscatediOSmobile
apps.Weplantosharethesesampleswiththecommunity
in the future.•To overcome the limitations of existing automated software
analysisonobfuscatedbinaries,weinvestedover600man-
hoursinmanuallyexaminingtheobfuscatediOSapps,ex-
tracting detailed information about how these apps are pro-
tectedbydifferentobfuscationalgorithms.Thehumaneffort
assured the accuracy of our analysis and therefore the credi-
bility of our findings.
•Wemadevariousobservationsaboutthecharacteristicsof
obfuscated apps, the obfuscation patterns applied, and their
resiliencetoreverseengineering.Ourfindingscanshedlight
on future research on mobile software protection.
2 BACKGROUND
2.1 Significance of the Problem
Obfuscation is one of the most important software protection tech-
niques that prevent software from being reverse engineered ma-
liciously. The status of its application and presence among pub-lishedsoftwareiscloselyrelatedtothestateofsecurityinasoft-
ware ecosystem. Previous research on mobile software engineer-
ingrevealedthatobfuscationhasbeenacommonpracticeonAn-
droid [24, 26, 47], yet the figure for iOS is mostly missing.
Since iOS is typically considered a more secure system than An-
droid for being more closed, it may be susceptible that obfuscation
on iOS could be as prevalent as on Android. However, some recent
security incidents have shown that with the help of production-
qualitybinaryanalysistoolslikeIDAPro[ 2],iOSreverseengineer-
ingisnotasdifficultasitisgenerallyrecognized.Forexample,it
is foundthat iOS developers similarlysuffer from severesoftware
piracy issues like Android developers [ 7]. It is also reported that
therehavebeenpopulariOSappsbeingrepackagedwithmalicious
payloadforstealingsensitiveuserdata[ 17].TohelpiOSdevelop-
ers counter these threats, some reputed software security solution
providers have launched their iOS app obfuscation services [9].
For more secure iOS software engineering, it is imperative to
obtain a thorough understanding about the current practice of ap-
plyingobfuscationiniOSappdevelopment.Thebenefitsofsuchanunderstandingaretwo-fold:vendorsofobfuscationtoolscanbetter
tune their development based on the status quo, while researchers
interestedinanalyzingiOSapprepositoriescangraspasenseabout
when and how obfuscation may affect their analysis.
2.2 Technical Challenges of the Study
Despite both being mobile platforms, iOS and Android are dras-tically different in many technical aspects. As a result, our study
facesunprecedentedchallengesthatneednottobeconsideredby
similar work targeting Android.
2.2.1 Obfuscation Detection and Analysis. Detectingandanalyz-
ingobfuscatedbinarieshaslongbeenanopenresearchproblemand
isstillbeingactivelystudied[ 12,29,36].Todate,theaccuracyof
automated obfuscation detection is not satisfying enough to fit our
demand.Therefore,wedecidedtoundertakemanualanalysisasthe
majorresearch methodologyofthestudy, withsomelight-weight
automated methods as assistance. Unlike Android developers that
can use an app obfuscator embedded into the official development
toolchain[ 8],iOSdevelopersdonotgetanyreceiveofficialsupport,
27
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Empirical Study on Mobile App Obfuscation ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
thushavingtorelyonthird-partytoolsorself-madeobfuscators.
Consideringthelargenumberofobfuscationtechniquespotentially
available,itisimpracticalforanempiricalstudyrelyingonmanual
effort to cover all of them. This poses another challenge, requiring
us to identify a group of obfuscation techniques analyzable with
our limited labor yet representative enough.
2.2.2 Static Third-Party Libraries. Third-party libraries have
been an indispensable part of mobile apps. It is possible that an
app“accidentally”gotobfuscatedduetotheinclusionofobfuscated
libraries without the awareness of app developers. Our analysisneeds to capture such situations to avoid drawing biased conclu-sions.UnlikeAndroidappsthatarewritteninJava,iOSappsare
written in languages that are more static, e.g., C, C++, Objective-C,
and Swift. Due to Apple’s security policies, iOS apps cannot use
dynamiclibrariesfromothervendorsuntiliOS8,meaningallthird-partylibrarieshavetobestaticallylinkedintoappexecutables.The
consequence is that there is no clear boundary between library
code and an app’s own code, making library detection in iOS apps
auniquechallenge[ 16,33].Thisiscompletelydifferentfromthe
library identification problem on Android, where application code
is naturally assorted through the Java package hierarchy.
3 METHODOLOGY
We adopted a three-step process to conduct the empirical study.
The first step is to select a representative collection of obfuscation
techniques to consider, for reasons explained in Section 2.2.1. The
second step is to search for a reasonably large set of iOS apps that
areobfuscatedbeforerelease.Todate,thereisnosuchapublicly
availabledataset.MiningobfuscatedsamplesfrombenigniOSapps
is one of the major contributions of our work. For the third step,
weinspecteachobfuscatedappinmoredepthandaggregatethe
harvested information to deduce empirical findings.
3.1 Considered Obfuscations
Afterdecadesofdevelopment,therearenownumerousobfuscation
techniques available. A comprehensive review by Schrittwieser et
al. [37] included 22 classes of obfuscation methods proposed by
previous research. For this study, we would like to focus on obfus-
cations popular among mobile developers and therefore worthyofin-depthinvestigation.WeusedGoogletosearchforcommer-
cial and opensource tools that can obfuscateiOS applications. By
studyingthestatementsandtechnicalwhitepapersofthetop10
results, we identified four families of obfuscations that are most
widely supported, i.e., symbol renaming, exotic string encoding,
controlflowflattening,anddecompilationdisruption.Compared
toallknownobfuscationalgorithms,thisisarelativelysmallset,
withthemajorreasonbeingthattheuniquehardwareandsoftware
environment on iOS devices imposes strict restrictions on the form
of executable code. For example, iOS does not allow normal userapplications to dynamically generate executable code, rendering
self-modifying obfuscation technically impossible to implement. A
graphicalillustrationofthefourobfuscationalgorithmfamiliesis
given by Figure 1 while the technical details are briefly introduced
as follows.
SymbolRenaming. Itisrecommendedbycommonsoftwareen-
gineering practices that programmers should make sensible namesforfunctionsandvariablessymbols.Thepreferredprogramming
languages for developing iOS apps, i.e., Objective-C and Swift, are
reflectiveorpartiallyreflective.Therefore,namesofmanyglobal
symbolshavetoberetainedinthedistributedbinariestosupport
by-namefunctiondispatchingatruntime.Symbolrenamingscram-
bles these names to prevent information leakage.
ExoticString Encoding. String literals sometimes disclose im-
portant information about the software. Some obfuscation algo-
rithmsconvertstringliteralsintorepresentationsthatarenotun-
derstandable by humans. The converted strings are decoded before
use during run time.
DecompilationDisruption. Itiscommonforobfuscationsto
prevent the recovery of high-level program structures from binary
code.Typicalmethodsofthiskindincludeinterleavingcodeand
data to disturb disassembly, inserting opaque predicates to forge
invalidcontrolflows,andemployingcertainmachineinstruction
patterns in unconventional ways to confuse decompilers.
Control Flow Flattening. This technique “flattens” the orig-
inal control flow graph of a function by rewriting the procedure
into a huge switch-like structure [ 23]. This makes the logical links
between basic blocks obscure.
3.2 Mining Obfuscated iOS Apps
Toobtainareasonablylargesamplesetwithoutbeingbiased,our
collectionstartswiththeentireAppleAppStore.However,itshould
be noted that we do not aim to find all obfuscated apps in the store.
From February to October in 2016, we crawled 1 ,145,582 free
iOSapp instances, includingdifferent versionsof thesame app. We
then try to identify apps that are obfuscated by at least one of the
four families of algorithms in Section 3.1. Ideally, we could run
automateddetectionoverallthecrawledappsforeachobfuscation
technique subsumed by the four families. However, obfuscation
detection itself is a non-trivial task and is still being actively re-
searched [ 11,29,31,34]. For many obfuscation algorithms consid-
ered by our study, it is prohibitively expensive, if possible at all, to
automatically detect their presence in over a million instances.
Totacklethisproblem,weidentifya baselineobfuscationalgo-
rithmwhichissupposedtobethemostwidelyadoptedinmobile
development.Ifdevelopersindeedconsiderprotectingtheirprod-
ucts, it is very likely that more than one obfuscation algorithm
will be employed. In such cases, detecting the baseline obfuscation
can help us identify the heavily obfuscated samples. Based on this
insight, we developed an automated method to identify scrambled
symbol names, since symbol renaming is considered by a large vol-
umeofpreviousresearchthemostprevalentobfuscationmethod
onmobileplatforms[ 13,24,26].Inpractice,symbolnamescram-
blingimposeslittleexecutioncostwhilebeinghighlyeffectivein
disturbing manual analysis.
Details of the detection algorithm are presented in Section 4.
Afterrunningthealgorithmforallcrawledappinstances,weob-
tainedthelikelihoodofeachappbeingobfuscatedbysymbolnamescrambling.Basedontheavailableman-labor,weexaminedthetop
6600mostlikelyobfuscatedsamples,ofwhich601areconformed
tobetruepositivesbymanualverification.Thesesamples,which
can be further grouped into 539 applications identified by a unique
ID assigned by App Store, are taken as the data set for subsequent
28
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden P. Wang et al.
@interface Person: NSObject
@property NSString *name;
@property int age;
@property NSString *addr;
@end
@interface AlJi09: NSObject
@property NSString *KJihad;
@property int z9kmV;
@property NSString *Nm23d;
@end
(a) Symbol renamingconst char *str1 = "A plain string";
// string xor masked by 0xab
const char *str1 =
"\xea\x8b\xdb\xc7\xca\xc2\xc5\x8b""\xd8\xdf\xd9\xc2\xc5\xcc\x85";
void decode(const char *s,char *d)
{
while( *s)*d++ = *s++ ^ 0xab;
*d=0 ;
}
(b) Exotic string encoding
 (c) Decompilation disruption1
2 3
4
switch
23 1 4
(d) Control flow flattening
Figure 1: Illustration of obfuscation techniques considered in the study
Crawl Apps from App Store
1,145,582 instances
Automated Baseline Obfuscation Detection
pick top 6600 positives†Manual Verification
601 versions of 539 apps
†The6600cut off is based on the maximum labor available for manual verification
Figure 2: Workflow for sampling obfuscated iOS apps
study. This sampling process is illustrated by Figure 2. We again
emphasizethat these601samplesshouldnotberegardedasallthe
obfuscated apps among the 1,145,582crawled instances. We set the
cut off at 6600 to bound the manual work within a manageable
amount.
3.3 Per-App Inspection
In addition to symbol scrambling, we need to further confirm what
otherobfuscation techniqueswere appliedtothe apps.This step
needs to be conducted manually to achieve the highest possible
accuracy.Toassuretheconsistencyacrosstheresultsfromdifferentinspectors,wedevelopedasetofelaborateprotocolstostandardize
the inspection process.
3.3.1 Detecting Obfuscation. To detect the presence of anti-
decompilation obfuscation techniques, we use IDA Pro [ 2], a com-
mercial integrated reverse engineering environment that has been
widely regarded as the de facto industry standard for analyzing
binary code. IDA Pro can automatically dissect a binary executable
into functions and translate the assembly code of each function to
a high-level representation similar to C. We consider that a binary
isprotected byanti-decompilationtechniques ifIDAPro reports
too many failures. All results were manually validated.
To identify flattened control flows, we developed a binary analy-
sisframeworktodisassembleappbinariesandconstructthecontrolflow graph (CFG) of each function in a binary. If a CFG is flattened,mostofitsbasicblockswillbeincludedbyasingleloop,whichcan
be captured bya standard loop detection algorithm[ 30]. Also, the“diameter” of the loop, which is defined as maximum length of the
shortest path from the loop header to other basic blocks, should be
ofthelogarithmicorderofthetotalnumberofallbasicblocksin
the loop. Based on these two characteristics, we can find functions
with flattened control flows.
For exotic string encoding, it is hard to develop automatic de-
tection methods since there is no standard implementation of such
techniques.IniOSexecutablebinaries,stringliteralsarestoredin
dedicatedregions.Wescantheseregionsforcharactersequences
that cannot be decoded, or those that can be normally decoded but
do not seem to possess reasonable meanings. We then manually
investigate how these sequences are utilized in the code and see if
theyaretransformedbyanadhocdecodingprocedureatcertain
program points.
3.3.2 Identifying Obfuscated Third-Party Libraries. Asintroduced
in Section 2.2.2, we need additional manual effort to identify third-
partylibrariesintheexaminediOSappsifthelibrarycodecontains
any obfuscation by themselves. We decide if an obfuscated code
regionbelongstosomethird-partylibrarybyobservingwhether
therearesimilarcodepatternsappearinginmultiplesamplesde-
velopedbydifferentvendors.Typicalsignaturesofcodepatterns
include control flow graphs, special algorithms, and uncommondata structures. Once a library is detected, we try to identify itsorigin through public information searching, with clues such as
namesoflibraryAPIsandspecialstringliterals,e.g.,stringsused
for logging and generating crash reports. Some libraries do not
provideeventhe mostsubtle informationthatcan helprevealtheiridentities.Insuchcases,weextractedthesemanticsignaturesofob-fuscatedcode,e.g.,controlflowpatternsanduniquedatastructures,
and check if they appear in different apps.
3.4 Cross-Validation
To ensure the accuracy and consistency of manual analysis, the
two authors performing per-app inspections were first asked to
independentlyexaminethesame50appinstancesinthesamplesetandcomparetheirresults.Divergencesamongresultsfromdifferent
authorswerediscusseduntilanagreementwasreached.Thetwo
authors then independently analyzed another 25 apps, based on
theregulationsmadeinthepreviousdiscussions.Forthesecond
round,theinspectionresultswereconsistentforall25apps.Inthis
29
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Empirical Study on Mobile App Obfuscation ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
way,weestablishedahighlyaccurateandcross-validatedprotocols
for the manual analysis on obfuscated iOS apps.
4 DETECTING SYMBOL OBFUSCATION
Inpractice,obfuscationtendstoreplacehuman-madesymbolswith
randomly generated gibberish which can be detected by natural
languageprocessing(NLP)techniques.Previousresearchdiscov-
ered that human-written source code is “natural” in the sense that
it can be described by statistical language models [ 21]. Based on
this insight, “unnatural” symbol names are possibly obfuscated.
4.1 An NLP-Based Detection Model
InNLP,theperplexitymeasureisusedtoquantifyhow“surprising”
it is for a sequence of words to appear within a statistical language
model.Oftentimes,thelog-transformedversionofperplexity,called
cross-entropy, is more preferable in the literature. Given a word
sequence s=x1···xkof length kand a language model M, the
cross-entropy of swithinMis defined as
HM(s)=−1
kk/summationdisplay.1
i=1log2P(xi|x1,···,xi−1) (1)
We use cross-entropy to capture the naturalness of an identifier.
Intuitively, lower HM(s)means sis more natural within M.I n
particular, we adopt the n-gram language modelthat assumes the
wordsequencessuitan (n−1)-orderMarkovprocess.Historically, n-
gramhasbeenutilizedinvarioussoftwareengineeringapplications,
includingautomatedcodecompletion [ 21]andbugdetection [ 41].
Within an n-gram model, the definition of cross-entropy can be
further formulated as
Hn-gram(s)=−1
kk/summationdisplay.1
i=1log2P(xi|xi−(n−1),···,xi−1)(2)
A notable difference between our method and previous work is
thatourstatisticallanguagemodelisappliedtoindividualidenti-
fiers rather than sequences of terms. As a consequence, we need to
firstsegmentanidentifierintoseveralpartsbeforefittingittoan
n-gram model. Naturally, we adopt the segmentation that makes
most sensewithin the n-gram modelby enumerating allpossibili-
ties.Therefore,thelikelihoodof anidentifier Ibeing“surprising”,
or obfuscated, can be defined by the following formula
L(I)=min
s∈SIHn-gram(s) (3)
where SIis the set of all possible word sequences obtained by seg-
menting Iindifferentways.Givenanempiricallydecidedthreshold
H,w ed ee m Ias an obfuscated symbol name if L(I)>H.
4.2 Implementation
Considering that identifiers are usually not too lengthy, we can
efficiently compute L(I)in equation (3) using the Viterbi algorithm
with the complexity of O(nl2), where nis length of the identifier
andlisthelengthofthelongestpossiblewordinthelanguage[ 38].
In fact, the worst cases can often be avoided, since most normal
symbol names are already naturally segmented by programmers
withunderscoresorthecamelcasescheme.Wefirstcomputethe
cross-entropy of an identifier by assuming the symbol is naturallysegmented.Iftheentropycomputedthiswayisalreadylowenough,
we can skip the relatively expensive Viterbi segmentation.
Ourn-gram corpus contains two parts, i.e., the natural language
corpusandthesoftwaresourcecodecorpus.Mostidentifiersinthe
crawledappsarenamedinEnglish,buttherearealsomanywritten
in Chinese pinyin or even a mixture of English and Chinese. For
English,weuseaportionoftheGooglewebtrillionwordcorpus
introduced by Franz and Brants [ 18] and derived by Norvig [ 32].
ForChinese,weemploytheLancasterCorpusofMandarinChinese
(LCMC) [ 6]. As for the source code part, we crawled all identifiers
appearinginiOSofficialAPIs,whichareallnaturallysegmented.
Eachidentifieristhenturnedintoawordsequence,thusforminga
n-gram corpus.
The probability of occurrence for an n-gram is defined as the
average of its probabilities in three corpora. If an n-gram does not
appearinanycorpus,weassignitalowprobabilitypenalizedbyits
length. This is a necessary heuristic since there are a large number
of unlisted words in program identifiers. Formally, the occurrence
probability of an n-gram sis defined as
p(s)=⎧⎪⎪ ⎨
⎪⎪⎩pEN(s)+pCN(s)+pcode(s)
3pEN(s)+pCN(s)+pcode(s)>0
20−(|s|−1)·2−(H+1)pEN(s)+pCN(s)+pcode(s)=0
(4)
where|s|is the number of characters in the n-gram and His the
threshold defined earlier in this section.
Whendecidingthevalueof n,weobservedthatpatternsofword
sequences in different applications are quite unique and rarely
occur in the corpus. The consequence is that any ngreater than
oneleadstotoomanyfalsepositives.Therefore,thebestoptionfor
the problem is to set nto 1, namely to adopt the unigram model.
In this study, the threshold His set to 32 .5. With this config-
uration, a total of 6600 positives were reported. Potentially, we
could find more positivesby employing a larger H, but the results
thenwillexceedthemaximumnumberofsampleswecanafford
to verify. After manually examining symbols in the 6600 initial
positives, we confirmed that 601 of them are truly obfuscated. The
falsepositivesare mostlycausedbyuses ofnon-Englishlanguage
and out-of-vocabulary abbreviations.
5 FINDINGS
Inthissectionwepresent8findingsofourempiricalstudy,grouped
by their relevance to research questions raised in Section 1.
5.1 (RQ1) Characteristics of Obfuscated Apps
We first discuss what factors might lead to the adoption of obfusca-
tion in mobile app development.
Finding A.1. A considerable portion of apps containing obfus-
cationare“passively”obfuscatedduetotheinclusionofobfuscated
third-party libraries.
Aspreviouslymentioned,wepaidspecialattentiontothird-party
libraries when inspecting the obfuscated apps. The examination
shows that these libraries indeed make a major source of obfus-cation. In total, we captured 35 third-party libraries. The major
functionalityofeachlibrary,inferredbyanalyzingtheircodeand
retrieving publicly available information onthe Web, is presented
in Table 1.
30
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden P. Wang et al.
Table 1: Obfuscated Libraries Grouped by Functionality
Functionality Count Including Apps
Advertising & Promotion 9 259
Security & Authentication 7 17
Digital Right Management 6 53
Payment & Banking 5 101
Location 2 11
Visualization 2 11
Analytics 1 19
Fraud Detection 1 17
Peripheral Control 1 3
Speech-to-Text 1 8
App Only
Third-Party Libs Only
App and Third-Party Libs135
(25%)
344
(63.8%)60
(11.1%)
Figure 3: Origins of obfuscation in 539obfuscated apps
(a) Number of apps including each third-party library
(b)Distributionofappsregardingthenumberofobfuscatedlibrariesincluded
Figure 4: Popularity of obfuscated third-party libraries
Figure 3 shows the breakdown of the origins of obfuscated code
in the samples. Among the 539 apps employing obfuscation, 404
(75%) of them include at least one obfuscated third-party library.
Inparticular,for344(63 .8%)apps,theobfuscationissolelyintro-
duced by libraries. The popularity of these libraries can be further
demonstrated intwo aspects. Figure4a shows foreach library the
number of including apps and Figure 4b shows the distribution
of apps including obfuscated third-party libraries regarding the
number of libraries.Data for App Store from Statista [1]
Figure 5: Distributions of apps regarding their categories
Figure3indicatesthattheoccurrencesofobfuscationaremainly
caused by the practice of depending on third-party libraries rather
thanappdevelopersactivelyconsideringsoftwareprotection.Based
onthe observation,webelievethat itisimportantto considerthe
impactofthird-partylibrariesforempiricalsoftwareengineering
research whenever app obfuscation is involved. To distinguish dif-
ferent sources of obfuscation, we henceforth call an app is actively
obfuscated if its obfuscation is notentirely contributed by third-
party libraries; otherwise it is called passively obfuscated.
The most notable kind of third-party libraries is for advertising
purposeswithbothmetricsbeingthehighestinTable1.Ourprelim-inary analysis on some of these libraries shows that the obfuscated
parts are used for communicating with the back-end ad servers.
Itisknownthatmobileadvertisinghasbeenbotheredbyreverse
engineering,throughwhichamaliciouspartyinstrumentsadvertis-
ing libraries to forge fake advertisement display or user clicks and
tricksadprovidersintopayinginvain[ 25].Foradproviders,ob-
fuscating their libraries is a reasonable response to such malicious
attempts.
FindingA.2. Thelikelihoodofappsandlibrariesbeingobfuscated
is strongly correlated to their categories of functionality.
We found thatin contrast tothe distribution ofall apps in App
Storeregardingtheircategories,thedistributionofobfuscatedapps
has a vastly different pattern. This pattern varies further when the
impact of third-party libraries is considered. Figure 5 shows thedifferences between these distributions, leading to the following
key observations:
•The proportions of obfuscated apps in certain categories areexceptionallyhighcomparedtothesharesofallappsinthese
categories acrossApp Store, nomatter whether passiveob-
fuscationistakenintoaccount.ThesecategoriesareFinance
(20.00%/15.77% vs. 2 .23%), Utilities (13 .85%/8.35% vs. 4 .88%),
Music (6 .15%/4.27% vs. 2 .55%), and Medical (5 .13%/2.60% vs.
1.88%). According to our investigation, most of the obfus-
catedMusicappsprovidestreamingservicesforcopyrighted
31
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Empirical Study on Mobile App Obfuscation ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
musical contents. The inspected Utilities apps are mainly
toolkitsoftware providingassistance todailyactivities, the
majority of which regularly record user data that may be
closely tied to personal privacy or enterprise secrets.
•Forsomeother categories,thesituationisflipped,namely
the proportions of apps carrying obfuscated code are signifi-
cantlylowerthanthestore-wideratios.Categoriesofsuchin-
clude Education (1 .54%/3.53% vs. 8 .47%), Book (1 .03%/2.04%
vs. 3.04%), Food & Drink (0 .00%/0.37% vs. 2 .86%), and Refer-
ence (0.51%/0.56% vs. 2 .22%).
•The distributions of obfuscated apps in the Games, Finance,
and Utilities categories are heavily influenced by obfuscated
third-party libraries. Apps in the Games category are easily
passivelytaintedbylibraries.TheFinanceandUtilitiesapps,
on the other hand, have a relatively higher rate for being
actively obfuscated.
The first two points suggest that mobile apps related to health,
finance, privacy, and intellectual property safety are more likely
to get obfuscated, both actively or passively. Despite being a fairly
expectedphenomenon,itinformsusthatsoftwareobfuscationat
this point is still not a general interest to mobile development. We
mayinferthatalthoughdevelopersworkingonsecurity-sensitive
businesssectorsdoviewmaliciousreverseengineeringasanon-
neglectable threat, the obfuscation applied to their works is mostly
for protecting the information encapsulated in the apps rather than
the design and implementation of the software.
Regardingthethirdpoint,itturnsoutthatamongthe112Games
apps with obfuscation, 87 are passively obfuscated and 82 of them
are solely tainted by obfuscated advertising libraries. The statistics
fitthegeneralperceptionsofthemobilegamebusinessmodelin
whichpublishingthird-partyadvertisementsisthemajormonetiza-
tion method for free game apps. For Finance and Utilities apps, the
fractions of passively obfuscated ones are comparatively lower (46
outof85and18outof45,respectively),suggestingthatsoftware
protection is more seriously considered in these sectors.
5.2 (RQ2) Obfuscation Patterns
Before presenting our findings regarding RQ2, we first present an
overviewontheobfuscationpatternsextractedfromthesamples.
We studied the pattern of obfuscation in three aspects:
•How many and what kinds of obfuscation techniques are
found in the code;
•Inwhatscopestheobfuscationalgorithmsareappliedtothe
code, i.e., at the function level, class level, or module1level;
•Whether multiple obfuscation methods are applied to the
same code region to achieve a synergy effect, which we call
synergistic obfuscation.
Weperformedthispatternanalysisonactivelyobfuscatedappsand
obfuscatedthird-partylibrariesseparately.Theresultsarepresented
in Table 2 and Table 3, respectively.
Duetolimitedspace,weonlylistcategorieswithsignificantrele-
vancetothediscussionsinFindingA.2.Itmaycauseconfusionthat
asmallnumberofappsorlibrariesdonotemploysymbolrenaming
1A module is defined as functionality-related classes coupled through method calls.even though it is the baseline obfuscation method in sample collec-
tion. The reason is that we detect symbol scrambling in obfuscated
app instances as a whole. In some cases we “accidentally” detectobfuscated apps or libraries without scrambled symbols because
they are “mingled” with obfuscated parts developed by others that
indeedcontainsuchsymbols.Nevertheless,suchcasesarerarely
seen among actively obfuscated apps (9 out of 195).
Interestingly,allfivethird-partylibrariesthatdidnotscramble
theirsymbolsaredevelopedbyInternetgiantslikeGoogle,Amazon,
Yahoo, Tencent, and Alibaba, suggesting that large-scale enterprises
and smaller mobile development teams may favor quite different
obfuscation patterns, which is worth further investigation.
FindingB.1. Mobileappsaremostlyobfuscatedatalargescale,
suggesting a wide adoption of automated obfuscation tools.
Intheory,obfuscationcanbemanuallyconductedwithoutthe
aidfromautomatedtools[ 3].Nevertheless,webelievethisisnot
thecaseinmobiledevelopment.Foractivelyobfuscatedapps,the
proportion of those employing module-level obfuscation is 55 .90%
(109 out of 195). For third-party libraries, the rate is even higher,
reaching71 .43%(25outof35).Comparedtofunction-levelandclass-
level obfuscation, the workload of protecting one or more modules
issignificantlyheavier,implyingthat mostmobiledevelopersrely
on automated tools for obfuscation.
On the other hand, it is extremely rare that an entire app or
library is obfuscated. Throughout the inspection, we only identi-
fiedtwoactivelyprotectedappsthatarefullycoveredbysymbol
scrambling obfuscation. For all other apps and libraries, the obfus-
cationcoversonlyasmallportionofthecode.Thisphenomenon
shows that applying obfuscation to mobile software comes with
non-negligible cost even if the processcan be automated. Presum-
ably, the cost of obfuscation can include but not limited to,
•Increasedconfigurationeffort,increasedcompilationtime,
and run-time performance penalty,
•Additionalcostofsoftwarecrashforensicsduetoscrambled
symbol names and obscure control flows, and
•Risksofappsbeingrejectedbysoftwarepublisherforbloated
or unanalyzable code (see Finding C.1 for more discussions).
Althoughitishardtoconfirmtheseitemswithoutcontactingthe
developers,wecanstillgetsomehintsbyanalyzingotheraspectsof
the obfuscation patterns, as demonstrated by the following finding.
FindingB.2. Thepopularityofobfuscationmethodfamiliesde-
creases as the implementation and performance cost grows.
It ismade clear by Table2 and 3 thatthe popularity ofthe four
obfuscationfamiliesvastlydiffers.Thenumberofappsandlibraries
containing decompilation disruption and control flow flattening is
remarkablysmallerthanthenumberofappsandlibrariesprotected
with scrambled symbol names and exotic string encoding. Due
tooursamplingmethodology,symbolscramblingisnaturallythe
mostpopularobfuscationtechniqueacrossthedataset.However,evenwithoutsymbolscramblingconsidered,itisstilltrueforthe
other three families of techniques that, the more costly it is toimplement and deploy an obfuscation algorithm, the less widelyit is adopted. To elaborate on this trend, we roughly discuss the
difficultyofautomatingobfuscationeachmethodandtheirimpacts
on run-time performance, in an increasing order.
32
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden P. Wang et al.
Table 2: Numbers of Actively Obfuscated Apps Employing Different Obfuscation Patterns
Category TotalApplied Obfuscation Families # of Families Scope of Obfuscation Synergic
ObfuscationSymbol String Anti-Decomp. Flattening 1234 Function Class Module
Finance 39 39 17 12 0 19 11 9 0 4 10 25 18
Utilities 27 27 10 2 3 15 10 1 1 2 4 21 4
Games 25 22 7 6 0 15 10 0 0 2 3 20 3
Music 12 11 4 1 0 9210 10 1 1 3
Medical 10 9 2 0 0 9100 271 0
Others 82 78 18 6 2 66 11 4 1 16 35 31 9
All 195 186 58 27 5 133 45 15 2 27 59 109 37
Table 3: Numbers of Third-Party Libraries Employing Different Obfuscation Patterns
Category TotalApplied Obfuscation Families # of Families Scope of Obfuscation Synergic
ObfuscationSymbol String Anti-Decomp. Flattening 1 2 3 4 Function Class Module
Advertising 9 7 3 2 0 6 3 0 0 1 1 7 2
Security 7 6 5 1 2 2 3 2 0 0 0 7 3
DRM 6 6 2 1 1 4 1 0 1 1 2 3 1
Payment 5 4 3 1 0 2 3 0 0 1 1 3 1
Others 8 7 3 0 0 6 2 0 0 2 1 5 1
All 35 30 16 5 3 20 12 2 1 5 5 25 8
Automaticallyscramblingsymbolnamesisrelativelyeasyand
can be implemented through various options like preprocessor
macros, compiler instrumentation, and even binary rewriting. Re-
namingsymbolscanbeimplementedinawaythatitcausesalmost
no performance degradation during program execution.
Re-encoding string literals in an automated manner requires
moreeffortsinceitchangesprogramsemantics.However,theobfus-
cation only needs to operate on strings and therefore light-weight
programtransformationsaresufficient.Atruntime,theobfuscated
stringsneedtobedecodedbeforeuse,butitisone-timecostand
only manifests when programs launch.
Comparedwiththefirsttwofamiliesofobfuscation,decompi-
lation disruption is significantly more difficult to implement, for
obfuscatorwritersneedreverseengineeringexperience tounder-
standhowtodisruptadecompiler.Itishardtoanalyzetherun-time
costofthisobfuscationsincetechniquesinthisfamilycanvarya
lot. Nevertheless, the performance penalty is not constant and will
keep accumulating as programs run.
Implementingcontrolflowflatteningrequiresdeepcustomiza-
tionofthecompilerwhichfallsoutoftheskillsetsofmostcommon
mobiledevelopers.Same asdecompilationdisruption,eachexecu-
tionofflattenedcontrolflowstakesanadditionalamountoftime.
It is also worth noting that control flow flattening can increase the
size of obfuscated binaries significantly.
Currently, we are unable to confirm whether the difference of
popularity results from exact one of thetwo factors, i.e.,implemen-
tationcostandperformancepenalty,orbothofthem.Theoretically,
iftheobfuscationisconductedwiththird-partytools,thetechni-
cal challenges in implementing each obfuscation method should
notbeaproblem,leavingperformancetobetheprimaryconcern.
Otherwise, if the intention of apply software protection is really
blockedbytechnicalissues,therewillbemanyopportunitiesfor
obfuscation toolkit providers to improve their products and attractmoremobiledeveloperstoembedadvancedobfuscationtechniques
into their apps and libraries. It would be interesting future work to
investigate which is the case.
FindingB.3. Appsandlibrariesofcertaincategoriestendtoadopt
more complicated obfuscation patterns than others.
Finding A.2 shows that apps serving life-, money-, and privacy-
critical purposes are more likely to be obfuscated. It is further
suggestedbyTable2andTable3thatthesecuritystrengthofob-
fuscationappliedtoappsandlibrariesofthesekindsisalsonotablystronger.Ingeneral,theFinance,Utilities,Games,andMusicapps,ifobfuscated,aremorewillingtoemployexpensiveobfuscationtech-
niques,i.e.,decompilationdisruptionandcontrolflowflattening.
These apps also tend to employ more different families of obfusca-
tiontechniques.Forexample,overhalf(20outof39)oftheactively
obfuscated Finance apps contain plural kinds of obfuscation. More-
over, in many cases (18 out of 20), these different methods were
appliedtothesamepartofthecode,achievingsynergisticobfus-
cation. Also, the scope of obfuscation in these apps is often larger,mostly reaching module-level protection.
Theobservationaboveappliestoobfuscatedthird-partylibraries
aswell.Overall,theobfuscationpatternsfoundinlibrariesarevery
similar to those in actively obfuscated apps in most aspects. There-
fore,itcanbedifficulttodistinguishactivelyandpassivelyobfuscated
mobile apps by simply analyzing their obfuscation patterns.
FindingB.4. Anincreasingnumberofmobileappsstarttointe-
grate obfuscation into the development process.
As aforementioned, our sample crawling was continuous and
lastedforninemonths.Forappsgettingversionupdatesduringthe
crawlingperiod,wewereabletoanalyzethetemporalevolutionof their obfuscation patterns. With these historical versions andsome additional examinations, we confirmed that 27 of the 195
33
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Empirical Study on Mobile App Obfuscation ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
actively obfuscated apps were unobfuscated at the beginning of
the crawlingperiod. Itis verylikely thatdevelopers ofthese apps
were newly attracted by the benefits of software protection and
started to employ it as part of their software engineering routines.
Notethat27isapossiblyuntightlowerboundbecausetherecorded
versionhistoriesmaybeincompletebecauseofthelimitedworkload
capacity of our crawler.
Unfortunately, the same analysis does not apply to passively ob-
fuscatedapps,sincetheymayincludedifferentthird-partylibraries
indifferentversions.Thechangeofobfuscationstatusintheseapps
may not reflect the intention of their developers. The analysis is
alsonotapplicabletothird-partylibraries,becausewewereunabletoobtainthedevelopmentdatesofeachversionofthesamelibrary.
5.3 (RQ3) Impact of Distributor Code Review
Centralizedsoftwaredistributionusuallyfeaturesavettingprocessinwhichanappmustbereviewedbythedistributorbeforeallowed
for publication. Through this vetting process, software publishers
aimtofilteroutmaliciousormisbehavingapplicationsthatcanhurt
user experience or security, thus affecting the healthiness of the
ecosystem. Both iOS and Android employ this centralized model.
Hypothetically, this mandatory app review process can affect
developer incentive to obfuscate their products in two opposite
ways. Firstly, although software obfuscation is a legit approach
toprotectingappsfromundesiredreverseengineering,ithinders
distributor reviews as well. If the reviewer acts conservatively and
considersunanalyzablecodemalicious,theobfuscatedappsmaybe
constantlyrejected,makingdevelopersreluctanttoadoptheavy-
weightobfuscationalgorithms.Ontheotherhand,somedevelopers
maybestimulatedto obfuscatetheircodesothatthey areableto
circumvent certain checks, allowing their apps to possess features
forbidden by publisher policies. We have encountered two cases
supportingbothpossibilities,respectively.Althoughnotqualified
as solid evidence to validate our hypotheses, these case studies can
indeed provide valuable insight on the problem.
FindingC.1. Codereviewsenforcedbymobilesoftwarepublishers
may influence the adoption of obfuscation in different directions.
Thefirstcaseisaheavilyobfuscatedappdevelopedbyareputed
commercial iOS security service provider, which only published
that single app in App Store. Judged from the simplicity of its func-
tionality, this app is merely a minimal working example of iOSdevelopment, whereas it is protected by all four kinds of obfus-cation techniques considered by our study. Only two among the
195 actively obfuscated apps are obfuscated in this pattern. We
speculate that the security solution provider submitted this app to
addresstheconcernsthattheirobfuscation algorithms maycause
distributor review alarms, to the detriment of the sales of theirservices. It is known that App Store have various constraints onsubmitted apps, some of which may not be clearly documented.
Forexample,eachsliceofanexecutablefileiniOSappsmustnot
exceed 60 MB [ 5] if the app is to be compatible with older versions
ofiOS,limitingtheuseofcodetransformationsthatbloatbinary
size too much. These constraints intrigue obfuscator writers to
test the boundaries of acceptable obfuscation techniques. This case
suggeststhat developingnewmobileobfuscationalgorithmshasto
take the app vetting process into account to be practical.In the second case, we found that a third-party advertising li-
brarycontainscodeforcallingprivateiOSAPIs,whichisstrictly
forbiddenbyAppleAppStoresecuritypolicies.Tocircumventstore
reviews,thelibrarywriterusesthe dlopen systemcalltoavoid
directlinkagetointernaliOSframeworksprovidingprivateAPIs.
Thelibrarythenusesexoticstringencodingtoobfuscatethestring
literals provided to dlopen as parameters. In this way, Apple’s
vetting analysis failed to detect this violation. By searching related
information on the Internet, we learned that this library was once
caughtusingprivateiOSAPIsin2015[ 4],longbeforewestarted
crawlingsamplesfromAppStore.Shortlyaftertheincidentwasre-ported,Appleannouncedthatithadremovedallappscontaminated
by this library from App Store. Yet our findings show that either
authorsofthelibrarymanagedtobypasstheappreviewprocess
for another time or Apple failed to detect all apps including this
library. Whichever is the case, this finding serves as empirical evi-
dencethat obfuscationisnotonlyemployedtorepelmaliciousreverse
engineeringbutalsoforinfiltratingpublisherinspection,eventhough
this practice is previously regarded as a signature of malware.
By nature, ad providers are impelled to collect as much client
dataaspossiblefordevelopingmoreeffectiveaddistributingstrate-
gies, potentially placing themselves on the verge of infringing user
privacy.Consideringthelargequantityofobfuscatedthird-party
advertising libraries and their wide spread in the sample set, we
areconcernedbythepossibilitythatabusingobfuscationtobypass
publishersecuritypolicyenforcementisbecomingacommonprac-
ticeforaggressiveadwareonthemobile.Mobileappsfallingwithin
a “gray area” that are controversially benign or malicious, aka.
“grayware,” has drawn attention from the security community [ 10].
5.4 (RQ4) Effectiveness of Obfuscation
We now present our findings regarding the effectiveness of real-
world obfuscation for mobile apps. It should be emphasized that
ourgoal isnotto accessthesecurity strengthofobfuscation tech-
niques themselves like previous literature review did [ 37] but to
investigatewhetheriOSdevelopersareabletoappropriatelyutilize
these techniques and optimize the protection effects.
With limited labor, we cannot afford to conduct comprehensive
penetration tests for all apps in our sample set. Even though, we
foundthatamodestamountofreverseengineeringeffortisenoughto reveal some information that possibly leads to security breaches.
Weinspectedtheactivelyobfuscatedappsintwoaspects.Firstly,
wescannedallsymbolnames,searchingforcommonkeyphrases
related to security, such as “private key” and “secret”. Secondly,
during the detection of exotic string encoding, we payed attention
to string literals that are not obfuscated and seem to leak sensitive
information.
FindingD.1. Aconsiderableportionofobfuscatedappsremain
vulnerabletolow-effortreverseengineering,whichcouldhavebeen
avoided if the obfuscation was performed more appropriately.
With preliminary reverse engineering effort, we found that
among the 195 actively obfuscated apps, there are 33 that may
leave certain sensitive information unprotected due to lack of cer-
tain obfuscation techniques or insufficient coverage by the right
techniques. There are mainly three kinds of such information:
34
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden P. Wang et al.
•Tokensassignedtoappsforaccessingthird-partyservices.
Some enterprise entities provide APIs for mobile apps to re-
trieve proprietary information or upload app usage data for
analytics,usuallyataprice.Requestsforaccessingtheseser-
vices has to be sent with tokens issued by service providers
toprovetheidentitiesofrequestingclients.Wefoundthat
someappsstorethesetokensasplaintextinvariableswhose
names are not scrambled.
•In-app secrets. Apps may encrypt their private data suchas execution logs and intermediate results before storing
them on mobile devices. Some poorly obfuscated apps store
encryption keys in plaintext as string literals.
•Informationaboutback-endserversconnectedwiththeapps
andthe correspondingcommunication protocols. Inpartic-
ular, we found 4apps, which are the mobile clients of some
financial institutions, leaking the URLs or IP addresses of theirback-endtestinginfrastructures. Surprisingly,accessingthese
infrastructures does not require any authentication. The
communicationprotocolsandeveninternaldocumentations
are exposed to anyone knowing the URLs or IPs.
Itistruethatinformationleakedabovedoesnotnecessarilyleadto
exploitable security vulnerabilities. Per common software security
principles, however, such information should not be exposed to
unauthorizedpartiesinthefirstplace.Althoughleakagesdiscov-
ered by our study were caused by series of inappropriate software
engineering practices, the problem will be less severe if the apps
are more properly obfuscated. In our opinion, the current status of
software protection on mobile platforms is far from satisfactory.
6 IMPLICATIONS OF THE RESULTS
Through this empirical study, we learned that third-party libraries
playasignificantroleiniOSappobfuscation,whichisconsistent
with the situation on Android [ 24]. Being a major source of ob-
fuscated code, third-party libraries affect software attributes in
various aspects without app developers being aware. We urge that
future studies on iOS app repositories to take obfuscated third-partylibrariesintoconsiderationanddevelopdedicatedanalysis
techniques to handle them.
Wehavefoundaposteriorievidenceindicatingthecorrelation
betweenthelikelihoodofmobileappsbeingobfuscatedandtheir
functionality. Particularly, apps related to finance, privacy, intellec-
tual properties, and monetization are more likely to be obfuscated.
Itmay beworthwhilefor obfuscationserviceproviders totakean
in-depthstudyonthecharacteristicsoftheseappsandspecialize
their products to better fit the demands of their vendors.
Ourstudysuggeststhattheadoptionofobfuscationonmobile
platformsmaybeaffectedbymandatorycodereviewsfromappdis-tributors.Sinceobfuscationisinherentlyunfriendlytocodereviewsand may causes disapproval from the reviewer, app developers will
likely face the dilemma between improved security and shorter
timetomarketoftheirproducts.Thisfactorneedstobeconsidered
when developing or advocating new obfuscation techniques for
mobileplatforms, particularlyiOS whosevetting processismuch
more strict that Android.
We noticed an increasing trend in the number of mobile apps
getting obfuscated. For a notable portion of these apps, however,theobfuscationwasnotappropriatelyconducted,leavingthemstill
vulnerable to certain lo w-effort reverse engineering techniques. As
such,webelievethatfutureeffortsonsoftwareprotectionshould
not only focus on developing new obfuscation techniques but also
proposingaccessiblepoliciesandstrategiesthatcanguidemobile
developers to maximize the efficacy of existing techniques.
7 RELATED WORK
To the best of our knowledge, most historical work on mobile
appanalysistargetstheAndroidplatform.TheAndroidMalware
Genome project is among the earliest research efforts that perform
large-scale analysis on mobile app repositories [ 47]. By working
onover1200samples,theauthorsmanagedtopresentasystematic
characterizationonexistingAndroidmalware.Accordingtothisresearch,mobilemalwareauthorsbythenhadalreadystartedto
applyobfuscationtobypassanti-virusanalysis.Besidesmalware
thatharmsusers,mobileapprepackagingthatharmstheinterestofdevelopershasalsodrawnattention.Varioustoolsandsystemshave
beendevelopedtodetectandanalyzeclonedmobileapplications
withbothaccuracyandscalability[ 15,19,39,46].Researchershave
also worked on examining third-party libraries used by mobile
developers. Tools like LibRadar [ 28] and LibD [ 24] were developed
to detect third-party libraries in Android apps and classify them.
ResearchbyChenatal.[ 16]detectslibrariespotentiallyharmfulto
user security and privacy for both Android and iOS.
Despite the progress in mobile app analysis, most studies of this
kindeitherignoredorspentverylimitedeffortinhandlingthepres-
ence and influence of software obfuscation. One of the few studies
thatsystematicallyinvestigatedtheimpactofobfuscationonmobile
developmentisfromLinares-Vásquezetal.,whoresearchedhow
obfuscationcanaffectthedetectionofAndroidcodecloning[ 26].
Similar to our work, Linares-Vásquez et al. spent extensive manual
workinidentifyingobfuscatedcode,buttheiranalysisonlycovered
120appsanddidnotconsiderobfuscationmethodsotherthaniden-
tifier scrambling. CodeMatch is a similar project that focuses on
obfuscation-resilient Android library detection [ 20]. Xue et al. [ 44]
proposed adaptive unpacking of Android apps to recover dex code,
which can potentially enable obfuscation-resilient clone or library
detection.
8 CONCLUSION
In this work, we empirically investigated the status of software ob-
fuscation in the mobile software industry. We collected a large set
of obfuscated iOS applications in the real world and performed in-
depth analysis on these samples. With the information gathered in
the study, we revealed factors potentially affecting the deployment
ofobfuscationtechniquesinmobileappsandtypicalobfuscation
patternsadoptedbymobiledevelopers.Webelievethatfindingsde-
velopedinthisresearchwillshedlightonfutureresearchthataims
to understand and improve the state of art of software protection.
ACKNOWLEDGMENTS
This research was supported in part by the National Science Foun-
dation (NSF) under grant CNS-1652790, and the Office of Naval
Research(ONR)undergrantsN00014-16-1-2912,N00014-16-1-2265,
and N00014-17-1-2894.
35
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. Empirical Study on Mobile App Obfuscation ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Apple:mostpopularappstorecategories2017|Statistic. https://www.statista.
com/statistics/270291/popular-categories-in-the-app-store/.
[2] IDA: About. https://www.hex-rays.com/products/ida/.
[3] The International Obfuscated C Code Contest. http://www.ioccc.org.[4]
iOS Apps Caught Using Private APIs. http://sourcedna.com/blog/20151018/
ios-apps-using-private-apis.html.
[5]iTunes Connect Developer Guide. https://developer.apple.com/library/
content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide/
Chapters/About.html.
[6]The Lancaster Corpus of Mandarin Chinese. http://www.lancaster.ac.uk/fass/
projects/corpus/LCMC/.
[7]Monument Valley apparently has a 95% piracy rate on Android, 60% on iOS.
https://goo.gl/TkfCIK.
[8]ShrinkYourCodeandResources|AndroidStudio-AndroidDevelopers. https:
//developer.android.com/studio/build/shrink-code.html.
[9]Smart Obfuscation for iOS Apps | PreEmptive Protection. https://www.
preemptive.com/products/ppios.
[10]BenjaminAndow,AdwaitNadkarni,BlakeBassett,WilliamEnck,andTaoXie.
2016. A Study of Grayware on Google Play. In Proceedings of the 2016 IEEE
Workshop on Mobile Security Technologies (MoST ’16).
[11]DanielArp,MichaelSpreitzenbarth,MalteHubner,HugoGascon,andKonrad
Rieck.2014. DREBIN:EffectiveandExplainableDetectionofAndroidMalwarein
Your Pocket.. In Proceedings of the 2014 Network and Distributed System Security
Symposium (NDSS ’14).
[12]Sébastien Bardin, Robin David, and Jean-Yves Marion. 2017. Backward-Bounded
DSE:TargetingInfeasibilityQuestionsonObfuscatedCodes.In Proceedingsof
the 38th IEEE Symposium on Security and Privacy (SP ’17). 633–651.
[13]Benjamin Bichsel, Veselin Raychev, Petar Tsankov, and Martin Vechev. 2016.
Statistical Deobfuscation of Android Applications. In Proceedings of the 23rd
ACM SIGSAC Conference on Computer and Communications Security (CCS ’16).
343–355.
[14]HaoChen,DaojingHe,SencunZhu,andJingshunYang.2017. TowardDetectingCollusiveRankingManipulationAttackersinMobileAppMarkets.In Proceedings
ofthe2017ACMonAsiaConferenceonComputerandCommunicationsSecurity
(AsiaCCS ’17). 58–70.
[15]KaiChen,PengLiu,andYingjunZhang.2014. AchievingAccuracyandScalabilitySimultaneouslyinDetectingApplicationClonesonAndroidMarkets.In Proceed-
ings of the 36th ACM/IEEE International Conference on Software Engineering (ICSE
’14). 175–186.
[16]Kai Chen, Xueqiang Wang, Yi Chen, Peng Wang, Yeonjoon Lee, XiaoFeng Wang,
Bin Ma, Aohui Wang, Yingjun Zhang, and Wei Zou. 2016. Following Devil’s
Footprints:Cross-PlatformAnalysisofPotentiallyHarmfulLibrariesonAndroid
and iOS. In Proceedings of the 37th IEEE Symposium on Security and Privacy (S&P
’16). 357–376.
[17]Zhaofeng Chen. iOS Masque Attack Weaponized: A Real World Look. https:
//www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html.
[18]Alex Franz and Thorsten Brants. All Our N-gram are Belong to You. https:
//research.googleblog.com/2006/08/all-our-n-gram-are-belong-to-you.html.
[19]ClintGibler,RyanStevens,JonathanCrussell,HaoChen,HuiZang,andHeesook
Choi. AdRob: Examining the Landscape and Impact of Android Application
Plagiarism.In Proceedingofthe11thAnnualInternationalConferenceonMobile
Systems, Applications, and Services (MobiSys ’13). 431–444.
[20]Leonid Glanz, Sven Amann, Michael Eichberg, Michael Reif, Ben Hermann,
Johannes Lerch, and Mira Mezini. 2017. CodeMatch: Obfuscation Won’t Conceal
Your Repackaged App. In Proceedings of the 11th Joint Meeting on Foundations of
Software Engineering (ESEC/FSE ’17). 638–648.
[21]AbramHindle,EarlT.Barr,ZhendongSu,MarkGabel,andPremkumarDevanbu.
2012. On the Naturalness of Software. In Proceedings of the 34th ACM/IEEE
International Conference on Software Engineering (ICSE ’12). 837–847.
[22]Pengwei Lan, Pei Wang, Shuai Wang, and Dinghao Wu. 2017. Lambda Obfus-cation. In Proceedings of the 13th EAI International Conference on Security and
Privacy in Communication Networks (SecureComm ’17).
[23]Tımea László and Ákos Kiss. 2009. Obfuscating C++ Programs via Control Flow
Flattening. AnnalesUniversitatisScientarumBudapestinensisdeRolandoEötvös
Nominatae, Sectio Computatorica 30 (2009), 3–19.
[24]Menghao Li, Wei Wang, Pei Wang, Shuai Wang, Dinghao Wu, Jian Liu, Rui Xue,
and Wei Huo. 2017. LibD: Scalable and Precise Third-party Library Detection in
AndroidMarkets.In Proceedingsofthe39thACM/IEEEInternationalConference
on Software Engineering (ICSE ’17).
[25]Wenhao Li, Haibo Li, Haibo Chen, and Yubin Xia. 2015. AdAttester: Secure
Online Mobile Advertisement Attestation Using TrustZone. In Proceedings of the
13thAnnualInternationalConferenceonMobileSystems,Applications,andServices
(MobiSys ’15). 75–88.
[26]Mario Linares-Vásquez, Andrew Holtzhauer, Carlos Bernal-Cárdenas, and Denys
Poshyvanyk. 2014. Revisiting Android Reuse Studies in the Context of Code
ObfuscationandLibraryUsages.In Proceedingsofthe11thWorkingConferenceon Mining Software Repositories (MSR ’14).
[27]HanLiu,ChengnianSun,ZhendongSu,YuJiang,MingGu,andJiaguangSun.
2017. Stochastic Optimization of Program Obfuscation. In Proceedings of the 39th
International Conference on Software Engineering (ICSE ’17). 221–231.
[28]Ziang Ma, Haoyu Wang, Yao Guo, and Xiangqun Chen. 2016. LibRadar: Fast and
Accurate Detection ofThird-party Libraries in Android Apps.In Proceedings of
the38thInternationalConferenceonSoftwareEngineeringCompanion(ICSE’16
Companion). 653–656.
[29]Jiang Ming, Dongpeng Xu, Li Wang, and Dinghao Wu. 2015. LOOP: Logic-
Oriented Opaque Predicate Detection in Obfuscated Binary Code. In Proceedings
of the 22nd ACM SIGSAC Conference onComputerand Communications Security
(CCS ’15). 757–768.
[30]StevenS.Muchnick.1997. AdvancedCompilerDesignImplementation. Morgan
Kaufmann.
[31]Minh Ngoc Ngo and Hee Beng Kuan Tan. 2007. Detecting Large Number of
InfeasiblePathsThroughRecognizingTheirPatterns.In Proceedingsofthethe
6th Joint Meeting of the European Software Engineering Conference and the ACM
SIGSOFT Symposium on The Foundations of Software Engineering (ESEC-FSE ’07).
215–224.
[32]PeterNorvig. NaturalLanguageCorpusData:BeautifulData. http://norvig.com/
ngrams/.
[33]DamilolaOrikogbo,MatthiasBüchler,andManuelEgele.2016. CRiOS:Toward
Large-Scale iOS Application Analysis. In Proceedings of the 6th Workshop on
Security and Privacy in Smartphones and Mobile Devices (SPSM ’16). 33–42.
[34]RobertoPaleari,LorenzoMartignoni,GiampaoloFresiRoglia,andDaniloBruschi.
2009. A Fistful of Red-Pills: How to Automatically Generate Procedures to
DetectCPU Emulators.In Proceedingsof the3rd USENIXWorkshop onOffensive
Technologies (WOOT ’09).
[35]AndrePawlowski,MoritzContag,andThorstenHolz.2016. Probfuscation:An
ObfuscationApproachusingProbabilisticControlFlows.In DetectionofIntrusions
and Malware, and Vulnerability Assessment. Springer, 165–185.
[36]Siegfried Rasthofer, Steven Arzt, Marc Miltenberger, and Eric Bodden. 2016. Har-
vesting Runtime Values in Android Applications That Feature Anti-Analysis
Techniques.. In Proceedings of 23rd Network and Distributed System Security Sym-
posium (NDSS ’16).
[37]Sebastian Schrittwieser, Stefan Katzenbeisser, Johannes Kinder, Georg Merz-
dovnik, and Edgar Weippl. 2016. Protecting Software Through Obfuscation: Can
ItKeepPacewithProgressinCodeAnalysis? ACMComput.Surv. 49,1(2016),
4:1–4:37.
[38]Toby Segaran and Jeff Hammerbacher. 2009. Beautiful data: the stories behind
elegant data solutions. "O’Reilly Media, Inc.".
[39]Haoyu Wang, Yao Guo, Ziang Ma, and Xiangqun Chen. 2015. WuKong: A
Scalable and Accurate Two-phase Approach to Android App Clone Detection. In
Proceedings of the 2015 International Symposium on Software Testing and Analysis
(ISSTA ’15). 71–82.
[40]PeiWang,ShuaiWang,JiangMing,YufeiJiang,andDinghaoWu.2016. Translin-
gual Obfuscation. In Proceedings of the 1st IEEE European Symposium on Security
and Privacy (EuroS&P ’16).
[41]SongWang,DevinChollak,DanaMovshovitz-Attias,andLinTan.2016. Bugram:
Bugdetectionwithn-gramlanguagemodels.In Proceedingsofthe31stIEEE/ACM
International Conference on Automated Software Engineering (ASE ’16). 708–719.
[42]Yan Wang,Shuai Wang, PeiWang, and Dinghao Wu.2017. TuringObfuscation.
InProceedings of the 13th EAI International Conference on Security and Privacy in
Communication Networks (SecureComm ’17).
[43]DongpengXu,JiangMing,andDinghaoWu.2016. GeneralizedDynamicOpaque
Predicates: A NewControl Flow Obfuscation Method. In Proceedings of the19th
Information Security Conference (ISC ’16). 323–342.
[44]Lei Xue, Xiapu Luo, Le Yu, Shuai Wang, and Dinghao Wu. 2017. Adaptive
UnpackingofAndroidApps.In Proceedingsofthe39thInternationalConference
on Software Engineering (ICSE ’17). 358–369.
[45]Babak Yadegari, BrianJohannesmeyer,Benjamin Whitely, andSaumya Debray.
2015. AGenericApproachtoAutomaticDeobfuscationofExecutableCode.In
Proceedings of the 36th IEEE Symposium on Security and Privacy (S&P ’15).
[46]Fangfang Zhang, Heqing Huang, Sencun Zhu, Dinghao Wu, and Peng Liu. 2014.
ViewDroid: Towards Obfuscation-resilient Mobile Application Repackaging De-
tection. In Proceedings of the 2014 ACM Conference on Security and Privacy in
Wireless &#38; Mobile Networks (WiSec ’14). 25–36.
[47]Yajin Zhou and Xuxian Jiang. 2012. Dissecting Android Malware: Characteriza-
tionandEvolution.In Proceedingsofthe33rdIEEESymposiumonSecurityand
Privacy (S&P ’12). 95–109.
36
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:49:35 UTC from IEEE Xplore.  Restrictions apply. 