Static DOM Event Dependency Analysis for Testing
Web Applications
Chungha Sung, Markus Kusano
Virginia Tech
Blacksburg, VA, USANishant Sinha
IBM Research
Bangalore, IndiaChao Wang
Univ. of Southern California
Los Angeles, CA, USA
ABSTRACT
The number and complexity of JavaScript-based web applicat ions
are rapidly increasing, but methods and tools for automatic ally test-
ing them are lagging behind, primarily due to the difﬁculty i n an-
alyzing the subtle interactions between the applications a nd the
event-driven execution environment. Although static anal ysis tech-
niques have been routinely used on software written in tradi tional
programming languages, such as Java and C++, adapting them t o
handle JavaScript code and the HTML DOM is difﬁcult. In this
work, we propose the ﬁrst constraint-based declarative pro gram
analysis procedure for computing dependencies over progra m vari-
ables as well as event-handler functions of the various DOM e le-
ments, which is crucial for analyzing the behavior of a clien t-side
web application. We implemented the method in a software too l
named JS DEP and evaluated it in A RTEMIS , a platform for auto-
mated web application testing. Our experiments on a large se t of
web applications show the new method can signiﬁcantly reduc e the
number of redundant test sequences and signiﬁcantly increa se test
coverage with minimal overhead.
CCS Concepts
•Software and its engineering →Automated static analysis; Soft-
ware testing and debugging;
Keywords
JavaScript, Static analysis, Automated testing, Event dep endency,
Partial order reduction
1. INTRODUCTION
Static analysis of client-side JavaScript web application s is dif-
ﬁcult not only due to the language’s dynamic features [19, 35 ] but
also due to the subtle interactions between JavaScript code and the
event-driven execution environment. At the center of this e xecu-
tion environment is the HTML Document Object Model (DOM).
The DOM stores the buttons, images, text-boxes, and other vi sible
objects on the web page, together with a large number of event -
handler functions attached to these DOM objects. Prior work on
statically analyzing JavaScript focused primarily on mode ling theSource Code
(HTML, JavaScript)
Normalized 
Code (CFG)
Datalog FactsDatalog Rules
1. Alias Analysis
2. Control/Data Dependency
3. DOM Event Dependency
µZ Datalog Engine in Z3
DOM Event DependenciesAutomated 
Testing T ool
(Artemis)
Figure 1: Overall ﬂow of DOM-event dependency analysis.
language [3, 8, 14–16, 31, 39] as opposed to the language’s in ter-
action with the DOM. For example, existing methods do not ro-
bustly handle dependencies between DOM event handlers, e.g ., the
various functions responding to the user’s actions, timers , AJAX re-
quests, or their callbacks, despite that such dependencies are crucial
in reasoning about client-side web applications.
We propose the ﬁrst constraint-based static analysis metho d for
computing dependencies both across event-handlers and bet ween
HTML DOM elements. Such DOM event dependencies fundamen-
tally differ from traditional control and data dependencie s over pro-
gram variables because they are tied to the event-driven exe cution
environment. Speciﬁcally, a modern JavaScript web applica tion
stores various data inside the DOM while simultaneously usi ng
JavaScript code to read and manipulate this data in response to
various, often user-triggered, events such as onclick ,onload , and
timeout . If executing the handler mAof eventAcauses the han-
dlermBof eventBto be registered, triggered, or removed, we say
that event Bdepends on event A, denoted A→DOMB. This dif-
fers from the traditional notion of control dependencies ( →ctrl) and
data dependencies ( →data) over program variables. Furthermore,
statically reasoning about DOM event dependencies is chall enging:
it requires proper handling of the aliasing between DOM elem ents,
and modeling the effects of APIs provided by the web browser a nd
popular frameworks such as jQuery .
Figure 1 shows the ﬂow of our DOM event dependency analysis,
which follows the declarative program analysis framework [ 25, 28,
32, 42]. Given the HTML and JavaScript source ﬁle(s) of a clie nt-
This is the author’s version of the work. It is posted here for your personal use. Not for
redistribution. The deﬁnitive version was published in the following publication:
FSE’16 , November 13–18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...
http://dx.doi.org/10.1145/2950290.2950292
Artifact evaluated by FSE✓
447side web application, we ﬁrst extract the JavaScript code an d gener-
ate its control ﬂow graph (CFG). We traverse the CFG to encode its
control and data ﬂows in a set of logical constraints called D atalog
facts . Next, we specify our static dependency analysis in a set of
Datalog inference rules . Finally, we use an off-the-shelf Datalog
engine [17] in Z3 [10] to solve the Datalog program. Internal ly, the
Datalog engine repeatedly applies the set of inference rule s to the
set of facts until they reach a ﬁx-point. The ﬁx-point result s in a
new relation→DOM over DOM events. This relation allows the
user to query for dependency information through Z3’s API.
Our method for statically computing DOM event dependencies
differs from the prior work. First, it differs from the decla rative
methods [6, 25, 28, 32, 42] for analyzing programs written in stan-
dard programming languages such as Java: we analyze JavaScr ipt
web applications. Additionally, the static analysis of Gua rnieri
and Livshits [14], while targeting JavaScript, focused on t ype infer-
ence as opposed to inter-event-handler dependencies in the HTML
DOM. Our method also differs from the dynamic change impact
analysis of Alimadadi et al. [2], which analyzed concrete ex ecu-
tions to identify the interplay between JavaScript code cha nges and
the content of the DOM: since it is dynamic, their analysis is valid
only for the given executions; ours, based on static analysi s, is valid
for all executions. Madsen et al. [29, 30] proposed several s tatic
analysis methods for JavaScript, but they targeted applica tions us-
ingNode.js [30] or Windows 8 APIs [29]. The static analysis tool
of Jensen et al. [20] modeled some aspects of the HTML DOM and
browser APIs, but its focus was on type inference as opposed t o a
dependency analysis.
We implemented our new method in a static analysis tool named
JSDEP, building upon E SPRIMA for parsing the JavaScript source
code, JS-W ALA for generating the control-ﬂow graph, and Z3 for
solving the Datalog program. We evaluated JS DEP on a large set
of client-side web applications. Overall, we analyzed 21 pr ograms
totaling 18,559 lines of JavaScript code. Our experiments s how that
our static analysis method can quickly process the JavaScri pt code
of these applications and compute the DOM event dependencie s
with reasonable accuracy.
To demonstrate our technique’s usefulness, we leveraged it s re-
sults to improve the performance of a popular automated web a p-
plication testing tool named A RTEMIS [5]. A RTEMIS traverses the
application’s execution space by systematically triggeri ng handlers
of various DOM events. However, since A RTEMIS cannot statically
compute DOM event dependencies, it relies on heuristics for gener-
ating sequences of event-handler executions. We show empir ically
that these heuristics are largely random and introduce many redun-
dant tests. But, our DOM event dependency analysis can provably
prune redundant test sequences and thus direct A RTEMIS to explore
truly useful tests. In particular, the default A RTEMIS stuck at 67%
statement coverage even after running for 3.5 hours, wherea s our
new method enabled A RTEMIS to quickly reach 80% coverage.
Besides A RTEMIS , our static DOM event dependency analysis
may beneﬁt other dynamic analysis or symbolic execution too ls
such as Kudzu [37], SymJS [26], and Jalangi [38]. A problem th at
is common to these tools is that they lack the capability of co nduct-
ing a whole-program static analysis; in this sense, our new m ethod
is complementary. In a broader sense, our dependency analys is
method is useful in many other software engineering applica tions,
e.g., to improve program understanding, software maintena nce, au-
tomated debugging, and program repair.
In summary, the main contributions of our work are:
•We propose the ﬁrst constraint-based static dependency ana l-
ysis for client-side web applications, taking into conside ra-
tion not only traditional control and data dependencies but
also the new DOM-event dependencies.•We propose a new method for leveraging our static depen-
dency analysis results in an automated web application test -
ing tool, A RTEMIS , to eliminate redundant tests and improve
test coverage.
•We implement these new methods and evaluate them on a
large set of web applications to demonstrate the efﬁciency o f
the static analysis method and its effectiveness in improvi ng
automated testing.
The remainder of this paper is organized as follows. We ﬁrst
motivate the main ideas of our new methods through examples i n
Section 2. We establish notation in Section 3, and formalize our
static dependency analysis in Section 4. We present the inte gra-
tion of our dependency analysis with A RTEMIS in Section 5. We
evaluate our approach empirically in Section 6. Finally, we review
related work and conclude in Sections 7 and 8.
2. MOTIV ATION
In this section, we show what DOM event dependencies are and
how they can improve the automated testing of web applicatio ns.
2.1 DOM Event Dependency
Consider the example in Figure 2. An HTML ﬁle deﬁnes the
DOM elements including four buttons, and a JavaScript ﬁle de -
ﬁnes the functions manipulating these elements. The four bu ttons,
namedtest1 –test4 , are referenced in the JavaScript using the vari-
ablesa,b,c, andd, respectively. The onclick event handler of a, i.e.,
the function executed if the button test1 is clicked, registers the
onclick event handler of cto the function makeSomeNoise() . The
onclick event handler of bincrements the value of x. Sincexis
used inmakeSomeNoise() to control the branch conditions, the han-
dler ofbaffects, in some sense, the behavior of the event handler
ofc. Finally, the event handler of dprints a message to the console.
From the JavaScript code, we identify the following depende ncies:
•Clicking test1 registers an event handler to test3 .
•Clicking test2 increments the value of x, which in turn af-
fects the same handler of test2 .
•Clicking test3 traverses the program paths of the handler
function makeSomeNoise() based on the value of x.
We say that the onclick event of test3 depends on the onclick
event of test1 since the handler of test3 is registered only when
the handler of test1 is executed. Also, the onclick event of test3
depends on the onclick event of test2 since the handler of test2
modiﬁes the value of xread by the handler of test3 . Similarly, the
onclick event of test2 depends on itself due to the reads/writes to
x. In contrast, the handler of test4 does not depend on any DOM
event. These DOM event dependencies are shown in Figure 3.
There are two types of dependencies in Figure 3: one relying
on traditional control and data dependencies, and another r elying
on the new DOM event dependency relation. Speciﬁcally, test2
depends on test2 because the read and write of variable xin the
handler of test2 changes the program state, which also affects the
behavior of makeSomeNoise() fortest3 . In contrast, test3 depends
ontest1 because the handler of test1 installs the handler of test3
– this type of dependency arises only from the speciﬁc event- driven
execution environment of the web browser; it cannot be expre ssed
using the traditional control and data dependency relation s.
To the best of our knowledge, the only work somewhat related
to our new dependency analysis is the change impact analysis pro-
cedure developed by Alimadadi et al. [2]. It monitors the int erplay
between JavaScript code changes and their impact on the DOM.
However, it relies on a trace-based dynamic analysis, and is there-
fore only valid for the given execution traces. Our method, i n con-
trast, is solely static and valid over all possible executio ns. In addi-
tion, the modeling of dependencies between event handlers i n Ali-
4481<html>
2<head>
3<pClick example of three buttons </ P>
4<script type ="text/javascript" src="ex.js"></
script>
5</head>
6<body>
7<div id="content" > ... </ div>
8<div id="buttons" >
9<button id ="test1" type="button" > b1 </button>
10 <button id ="test2" type="button" > b2 </button>
11 <button id ="test3" type="button" > b3 </button>
12 <button id ="test4" type="button" > b4 </button>
13</div>
14</body>
15</html>
1vara = document.getElementById( ’test1’);
2varb = document.getElementById( ’test2’);
3varc = document.getElementById( ’test3’);
4vard = document.getElementById( ’test4’);
5varx = 0;
6function makeSomeNoise() {
7if(x<2) {console.log( "x is lower than 2" );}
8else if (x<4) {console.log( "x is lower than 4" );}
9else if (x<6) {console.log( "x is lower than 6" );}
10else if (x<8) {console.log( "x is lower than 8" );}
11else{console.log( "x is higher than 8" );
12 some error codes;}
13}
14a.addEventListener( "click",function () {
15c.onclick = makeSomeNoise; });
16b.addEventListener( "click",function () {
17x = x + 1; });
18d. addEventListener( "click",function () {
19console.log( "test4 is clicked!" ); });
Figure 2: Example HTML page and associated JavaScript ﬁle.
madadi et al. [2] is not as accurate as our method. In particul ar, they
assume that function gdepends on function f(Deﬁnition 9 in [2])
iffinvokesgand either (1) the signature of gindicates that it takes
parameters or (2) the deﬁnition of fincludes a return value. This
is a much coarser deﬁnition than ours: we model the actual imp act
of the statements in a function during our dependency analys is.
2.2 Web Application Testing
Next we show how DOM event dependencies can help improve
automated web application testing tools like A RTEMIS . Such tools
generate test sequences by systematically triggering user events up
to a ﬁxed depth. The search tree of our running example (Figur e 2)
up to depth three can be seen in Figure 4 (a). Each edge repre-
sents the execution of an event handler, and each path repres ents a
test sequence. The default algorithm in A RTEMIS inefﬁciently ex-
plores the search space since many of its randomly generated test
sequences are actually redundant. For example, the onclick event
Click of
test 1Registration
test 3
Click of
test 2Click of
test 2
Click of
test 2Click of
test 3
Figure 3: DOM event dependencies for the example in Figure 2.Artemis Search Tree 
test 1test4test2
test 1
test 2 test 3test 4 test 1
test 2test 4 test 1
test 2test 4
(a) The default algorithm with no pruning.
Artemis Search Tree 
test 1test4test2
test 1
test 2 test 3test 4 test 1
test 2test 4 test 1
test 2test 4
(b) With DOM event dependency based pruning.
Figure 4: Event sequences explored by A RTEMIS for Figure 2.
oftest4 does not have a DOM event dependency with any DOM
event. Any permutation of events involving test4 is redundant,
e.g.:test1→test4→test3 leads to the same behavior as test1
→test3→test4 and therefore only one needs to be tested.
Using newly computed DOM event dependencies in A RTEMIS
allows redundant test sequences to be pruned away. We will ex plain
the detailed redundancy-pruning algorithm in Section 5, bu t for
now, it sufﬁces to say that permutations involving two indep endent
event handlers can safely be ignored without affecting the e xplo-
ration capability of the tool. After such reduction, the new search
tree, shown in Figure 4 (b), is signiﬁcantly smaller. Here, g rayed-
out edges are those deemed redundant and therefore are skipp ed.
For example, the onclick event oftest1 is not dependent with itself
as seen in the dependency relation in Figure 3. So, executing the
onclick event of test1 after another onclick event of test1 does
not alter the program’s state and therefore can be skipped. S imi-
larly,test1→test4→test3 is skipped because an equivalent
sequence, test1→test3→test4 , has already been tested.
Also note that exploring all test sequences up to the depth 3 d oes
not guarantee to cover all statements in this program. Indee d, only
the ﬁrst branch of the function makeSomeNoise() in Figure 2 (Line
9) can be executed; sequences of only length three are not lon g
enough to increment xabove 2 while also registering and executing
the handler associated with test3 . Fully covering all the statements,
in this case, requires at least a sequence of length 15: That i s,test1
→test3→test2→test2→test3→test2→test2→test3→
test2→test2→test3→test2→test2→test3→test4 .
Since we need to test up to depth 15 for full statement coverag e,
the default search algorithm in A RTEMIS may explore more than
31+···+315= 21,523,359sequences. In contrast, with our new
pruning technique, complete statement coverage can be achi eved
by exploring at most60sequences. We ran A RTEMIS with our new
improvement on this example and reached 100% coverage in onl y
0.37 seconds. The original version of A RTEMIS could not reach
100% coverage after 10 minutes.
In the remainder of this paper, we present the detailed algor ithm
of our new DOM event dependency analysis.
4493. PRELIMINARIES
In this section, we introduce the fundamental concepts and n ota-
tions for our work.
3.1 Web Applications
Client-side web applications are executed by the web browse r,
which loads and parses the HTML/JavaScript ﬁles, represent s them
as a DOM tree, and then executes the JavaScript code. Each nod e in
the DOM tree represents an object on the web page, or a JavaScr ipt
code block to be executed immediately after parsing. Each ob ject
may also be associated with a set of events initiated either b y the
user or by the browser, such as onload andonclick . These events
are responded to by a set of JavaScript functions called even t han-
dlers. For example, when a user clicks a button, the callback func-
tion associated with the onclick event will be executed. Callback
functions may be registered statically inside the HTML ﬁle o r dy-
namically inside the JavaScript code. Although the browser ensures
that each callback function is executed atomically, i.e., i n a single-
threaded fashion, the execution of multiple callback funct ions may
interleave; this makes the execution of the entire web appli cation
nondeterministic.
3.2 JavaScript Statements
LetStbe the set of JavaScript statements. Following the nota-
tion of Guarnieri and Livshits [14], we deﬁne the syntax of ea ch
statement st∈Stas follows.
st::=ǫ |[empty]
st1;st2 |[sequence]
v=newv0(v1,...,v n)|[constructor]
v1=v2 |[assignment]
v1=v2.f |[load]
v1.f=v2 |[store]
m=function (v1,...,v n){st;} | [functionDecl]
v=m(v1,...,v n) |[functionCall]
returnv |[return]
Each statement stis either empty, an elementary statement, or a
sequence of statements of the form st1;st2. An elementary state-
ment can be an object construction, where v0is a constructor and
v1,...,v nare its arguments; an assignment; a load of the object
ﬁeldv2.f; a store to the object ﬁeld v1.f; a deﬁnition of a function;
a call to a function; or a return from a function. Other comple x
statements may be transformed into a sequence of equivalent state-
ments through preprocessing prior to applying our analysis .
3.3 Points-to Analysis
Points-to analysis is the process of determining whether a r efer-
ence variable v∈Vcan point to o∈O, a JavaScript object or
HTML DOM element. As in the literature [36], we use Vto de-
note the set of all reference variables deﬁned in the program ,Oto
denote the set of objects created at the set Lof allocation sites, and
Fto denote the set of object ﬁelds. For each site li∈L, we map
all objects created at lito a single abstract object oi∈O. The
points-to relation, denoted TptsTo , consists of a set of pairs of the
form(v,oi), meaning the reference variable v∈Vpoints to the
objectoi∈O, and of the form (oi.f,oj), meaning the ﬁeld f∈F
of the object oi∈Opoints to the object oj∈O.
We deﬁne an abstract transformer for each st∈Stas a function
fptsTo:TptsTo×St→TptsTo , which takes a points-to relation
T⊆TptsTo as input and returns a new points-to relation T′⊆
TptsTo as output. For brevity, we provide deﬁnitions only for the
following statements:
•Allocation: l = new c
•Assignment: l = r
•Store:l.f = r
•Load:l = r.fFor each of the above statements, the new points-to relation T′is
deﬁned with respect to the old points-to relation Tas follows:
•Allocation: T′=T∪{(l,oi)}
•Assignment: T′=T∪{(l,oi)|(r,oi)∈T}
•Store:T′=T∪{(oi.f,oj)|(l,oi)∈Tand(r,oj)∈T}
•Load:T′=T∪{(l,oi)|(r,oj)∈Tand(oj.f,oi)∈T}
For an allocation, we add (l,oi)to the points-to relation. For an
assignment, if the pair (r,oi)is already in the points-to relation, we
add(l,oi)as well. For a store and a load, the abstract transformers
are deﬁned similarly.
3.4 Call-graph Construction
Although many of the function calls in JavaScript code can be
resolved to a unique target function at the time of the static analysis,
there are cases where the resolution has to be carried out at r un time.
In such cases, our analysis over-approximates the set of fun ctions
that may be called. We leverage the result of our points-to an alysis
to determine which function may be invoked. Speciﬁcally, co nsider
the statement l = v 0.m(v1,...,v n), wherev0∈Ris a reference
variable, m∈Fis the ﬁeld name, and v1,...,v n∈Vare the
actual parameters of the function call.
Letmi(p0,p1,...,p n,retj)be a function that v0.mmay point
to, where p0refers back to the object, retjrefers to the return value,
andp1,...,p nare the formal parameters. For each object that v0
may point to, denoted (v0,o0)∈T, and for each function that
o0.mmay point to, denoted (o0.m,m i)∈T, we transform the
function call to the following statements:
•p1= v1,..., pn= vn;
•executing the code in mi(); and
•l =retj.
The abstract transformer for the function call is deﬁned as f ollows:
T′=T∪{(p0,o0),(p1,o1),...,(pn,on),(l,oj)}, such that
(v1,o1)∈T,...,(vn,on)∈T, and(retj,oj)∈T.
3.5 Dependency Relations
For each statement st∈St, letVRD(st)be the set of memory
locations read by st, andVWR(st)be the set of memory locations
written to by st. We deﬁne the traditional control and data depen-
dency relations [12] as follows: a data dependency, →data, exists
betweenst1,st2∈Stifst1is a write to some variable xandst2is
a read ofx. That is,(st1,st2)∈→dataifVWR(st1)∩VRD(st2)/ne}ationslash=
∅. A control dependency, →ctrl, exists between st1,st2∈Stifst1
is a branch statement, st2is another statement, and the evaluation
of the predicate pinst1determines the execution of st2.
Since each JavaScript code block is executed atomically, we are
concerned with the dependency relations between code block s as
opposed to individual statements. Let m1andm2be two JavaScript
functions. We say (m1,m2)∈→ctrlif executing m1may affect
the control ﬂow of m2; that is, there exists st1∈m1andst2∈m2
such that (st1,st2)∈→ctrl. Similarly, we say (m1,m2)∈→data
if(st1,st2)∈→data.
The DOM event dependency relation, in contrast, is deﬁned di -
rectly over events. Intuitively, if the execution of some ca llback
functionm1of the event ev1affects the execution of some call-
back function m2of the event ev2, there is a DOM event depen-
dency between ev1andev2. More so, m1may affect m2through
control/data dependencies; or, m1may affect m2by registering, re-
moving, or modifying the callback functions of event ev2, which
includesm2. This effect is unique to the event driven environment
of client-side web applications. Formally:
DEFINITION 1.Two events ev1,ev2∈EV are in the DOM
event dependency relation, (ev1,ev2)∈→DOM , if there exists a
callback function m1ofev1and a callback function m2ofev2
such that,
4501DomA.onclick( function () {
2c =true;
3});
4DomB.onclick( function () {
5if(c) {
6statement1;
7}else{
8statement2;
9}
10});
Figure 5: Example: data/control dependencies in the DOM.
•either(m1,m2)∈(→data∪→ctrl)∗, or
•executing m1registers, removes, or modiﬁes the handler m2.
Here,T∗denotes the transitive closure of a relation T.
Consider the code in Figure 5 as an example. There are two
functions registered as the onclick event handlers of DomA andDomB;
cis a global variable used in the two event handlers. Inside th e
handler of DomA, there is an assignment to c. The value of cis
used as the predicate of a branch in the event handler of DomB. So,
clicking DomA affects the reachability of the statements guarded by
the branch if (c) . Thus,DomB is DOM-event dependent on DomA.
4. CONSTRAINT-BASED DEPENDENCY
ANALYSIS
In this section, we present our static analysis algorithm fo r com-
puting DOM event dependencies.
4.1 Datalog-based Program Analysis
We follow the declarative program analysis framework pione ered
by Whaley, Livshits, and Lam [25,28,42], where the analysis is rep-
resented by a Datalog program consisting of a set of facts and a set
ofrules . The facts are relations that hold in the program, and the
rules specify the algorithm for deriving new relations from existing
relations. For example, the ﬁrst two lines below show the two facts
describing a graph where n1is the parent of n2, andn2is the par-
ent ofn3. The next two lines deﬁne the rules to infer the ancestor
relation: if Xis the parent of Y,Xis the ancestor of Y. Or ifXis
the parent of ZandZis the ancestor of Y,Xis the ancestor of Y.
parent(n 1,n2)
parent(n 2,n3)
ancestor(X,Y) ←parent(X,Y)
ancestor(X,Y) ←parent(X,Z),ancestor(Z,Y)
A Datalog engine takes the program above as input and compute s
theancestor relation. Internally, it repeatedly applies the rules over
the facts until reaching a ﬁx-point. Then, one may query the D ata-
log engine to check, for example, if ancestor(n 1,n3)holds.
4.2 Generating the Datalog Facts
We ﬁrst normalize the JavaScript code to break down complex
statements into series of simpler statements by adding auxi liary
variables. Figure 6 shows an example of this. Then, we traver se
the control ﬂow graph (CFG) of the simpliﬁed code and, for eac h
statement, generate its Datalog facts. Later on, these Data log facts
are merged with a predeﬁned set of Datalog rules that specify our
dependency analysis algorithm. Finally, we use a Datalog en gine
to solve the program to obtain the analysis results.
The Datalog facts generated from the input program populate the
relations shown in Figure 7. The domains used in these relati ons
are as follows: V, the set of variables; St, the set of statement
IDs;O, the set of objects; F, the set of object ﬁelds; and E=
{load,mouse,keyboard ,timeout,ajax,other}, the set of event
handler types. Next, we provide examples on this process.Chained statement Normalized form
vara =
document.images.length;vartemp0 = document.images;
vartemp1 = temp0.length;
vara = temp1;
Figure 6: Example for JavaScript code normalization.
ASSIGN (v1:V,v2:V,st:St) Variable Assignment: v1=v2with IDst
LOAD(v1:V,v2:V,f:F,st:St) Object ﬁeld load: v1=v2.fwith IDst
STORE (v1:V,f:F,v2:V,st:St) Object ﬁeld store: v1.f=v2with IDst
FUNCDECL(v:V,o:O) vassigned function o:v =function(){ ...}
FORMAL (o:O,n:N,v:V) vis thenthformal argument of function o
ACTUAL (st:St,n:N,v:V) vis thenthargument in call-site at st
METHOD RET(o:O,v:V) vis the return value of function o
CALLRET(st:St,v:V) Return into variable vat call-site st
STMT(st:St,o:O) stis a statement in function o
HEAP(v:V,o:O) Allocation of heap object ointo variable v
PTSTO(v:V,o:O) Variable vpoints-to object o
DOM(o:O) ois a DOM object
DOM-M ODIFY (o:O,e:E,f:O,st:St) Attach function fto objecto’s evente
Figure 7: The relations deﬁned to specify our analysis.
Largely, the relations in Figure 7 correspond to various sta te-
ments in the program, e.g., assignments, loads, and stores. Each
statement then, for the most part, generates a correspondin g input
fact. Speciﬁcally, every statement in the program is identi ﬁed with
a unique ID st∈St. The formal arguments of a function are those
used within the function itself, e.g., for function f(a, b){...} ,a
andbare the formal arguments. Given this function declaration,
ifa,b∈Vrepresent variables aandbandf∈Orepresents the
function f()then F ORMAL(f,1,a)and F ORMAL(f,2,b). At a
call-site, v = f(a1, b2) ,a1anda2are the actual arguments, e.g.,
ACTUAL(s,1,a1)wheresis the statement ID of the call-site and
a1∈Vrepresents the variable a1. The0thactual argument is the
function object performing the call, e.g., A CTUAL(s,0,f).
Continuing the example, assume the statement return r is the
return statement of the function f(). Letr∈Vrepresent rthen
METHOD RET(f,r). Each call-site similarly has its own return
value from a function. Using the previous call-site and let v∈V
represent the variable v, then we have C ALLRET(s,v).
Next, we present examples for generating facts about DOM ele -
ments and operations.
DOM References We model DOM elements as heap objects and
operations modifying DOM elements as those on heap objects. For
a DOM element od∈O, we add an implicit heap allocation and
the corresponding fact D OM(od) indicating that odis a DOM ob-
ject. We treat alternate methods to access the same DOM eleme nt
in a uniﬁed manner, e.g., a = document.getElementById(“model”)
anda = $("#model")[0] can be used to access the same element.
Letom∈Obe the DOM element with ID “model” ,vg∈V
be an auxiliary variable representing the value returned fr om the
getElementById() call at the call-site. Then, we have D OM(om),
and P TSTO(vg,om)indicating that the result of the call points-to
DOM object om. Furthermore, let a∈Vbe the variable storing the
returned value; we have A SSIGN(a,vg,s)wheresis the statement
ID of the call. The use of $("#model")[0] can be handled similarly
with an auxiliary variable.
We also handle the various ways of accessing attributes of DO M
elements in the same way as reads/writes to objects. For exam ple,
usinga.setAttribute("value",x); y=a.getAttribute("value")
results in the facts: S TORE (a,value ,x) and L OAD(y,a,value ).
DOM Listeners Prior works on statically analyzing JavaScript of-
ten do not accurately model the dynamic registration, trigg ering,
and removal of event handlers. For example, Jensen et al. [20 ] ab-
451stract away the information on where in the DOM tree an event
handler is registered. Furthermore, they assumed that load han-
dlers always executed before other kinds of handlers; this m ay not
be true. In contrast, we model such information more accurat ely.
We distinguish the different event categories: load, keyboard,
mouse, timeout, ajax , and other . These correspond to event at-
tributes such as onkeydown andonclick . We model both the static
and the dynamic methods for registering and removing event h an-
dlers. For example, <obj id="a1" onclick=”scrpt”> statically in-
stalls the callback function scrpt to the onclick event of the DOM
objecta1. In contrast, one may dynamically modify a callback func-
tion using an explicit store, tmp.onclick = scrpt , or using an API,
tmp.addEventListener(“click”, scrpt) . In all three cases, we
generate the same fact: DOM-M ODIFY (oe,mouse ,os,st) where
oe∈Ois the DOM element a1,mouse∈Ethe type of event,
os∈Othescrpt function, and stthe ID of the statement.
Timer related DOM APIs call functions after durations of tim e,
e.g.,setTimeOut(func, t) callsfunc after time t. We model timers
with a DOM element ot∈Owith event type timeout . The pre-
vioussetTimeOut() becomes DOM-M ODIFY(ot,timeout,of,st)
whereofis the object representing func, andstthe statement ID.
Removing DOM event handers also uses D OM-MODIFY . Con-
sidero.removeEventListener("click",f) , which removes ffrom
o’s"click" event. We model it as D OM-MODIFY(o,mouse,f,s)
whereo∈Ois the object representing o,frepresenting f, and
srepresenting the statement ID. Essentially, the act of remo ving
an event handler fmay effect any of the event handlers which f
may effect; this is the same as if fwere installed, or removed. We
provide more examples shortly in the next sub-section.
As seen in the previous examples, generating the input set of
Datalog facts amounts to traversing each statement in the CF G and
generating its corresponding fact. Thus, it is a linear-tim e process.
Our modeling of global objects, and the DOM elements in parti c-
ular, is analogous to using a single global object and then modeling
all reads/writes to JavaScript globals as loads and stores o f ﬁelds of
this global object.
DOM Aliasing There are three ways of handling DOM node alias-
ing: over-approximation, under-approximation, and preci se mod-
eling. Since precise modeling is expensive, we omit it from t he
discussion. Below is a summary of the other two approaches:
•To over-approximate aliasing, the simplest approach is to t reat
all elements in the DOM as a single abstract object [14, 15]. T hat
is, reading from or writing to one DOM element will be regarde d
as potentially reading from or writing to any DOM element. A
more accurate over-approximation is to group all DOM elemen ts
of the same type as a single abstract object [20]. That is, rea ding
from or writing to an integer variable will be regarded as pot entially
reading from or writing to any integer variable. However, it will be
distinguished from a non-integer variable.
•To under-approximate aliasing, the simplest approach is to as-
sume that each access (read/write) is on a separate object [2 ]. That
is, one can pretend that dependencies through the DOM don’t e xist.
These approaches represent two extreme cases, and therefor e
may not be accurate enough, but have the advantage of being sc al-
able in practice. In this work, we focus on a conservative sta tic
analysis that uses the over-approximation.
4.3 Generating the Datalog Rules
Next, we introduce the rules that specify our DOM dependency
analysis. They use the existing facts to infer new relations hips. For
ease of understanding, we divide these rules into two subset s. The
ﬁrst subset is for the points-to analysis, and the second sub set is
for the dependency analysis. These analyses are interleave d in our
implementation.4.3.1 Rules for the Points-To Analysis
Our rules for the points-to analysis are shown in Figure 8. Th ey
implement a ﬂow-insensitive and context-insensitive anal ysis fol-
lowing Guarnieri and Livshits [14]. The main difference is t hat we
encode the locations of assign, store, and load operations, which
will be crucial in computing the DOM event dependencies.
PTSTO(v1,o1)← HEAP(v1,o1)
PTSTO(v1,o1)← FUNCDECL(v1,o1)
PTSTO(v1,o1)← PTSTO(v2,o1),ASSIGN (v1,v2,st)
HEAPPTSTO(o1,f,o2)← STORE (v1,f,v2,st), PTSTO(v1,o1), PTSTO(v2,o2)
PTSTO(v1,o1)← LOAD(v1,v2,f,st), PTSTO(v2,o2), H EAPPTSTO(o2,f,o1)
CALLS (o,st)← ACTUAL (st,0,v1), PTSTO(v1,o)
ASSIGN (v1,v2,st1)← CALLS (o1,st1), FORMAL (o1,n1,v1), A CTUAL (st1,n1,v2)
ASSIGN (v1,v2,st1)← CALLS (o1,st1), M ETHOD RET(o1,v2), C ALLRET(st1,v1)
Figure 8: Datalog rules for specifying the points-to analys is.
Based on the points-to analysis, we can proceed to compute th e
dependency relations between operations on the DOM element s,
including DOM reference, DOM read, and DOM write operations .
4.3.2 Rules for the Dependency Analysis
First, we compute the traditional data dependency relation as in
Figure 9. Here, v1,v2∈Vare reference variables, st1,st2∈St
are statement IDs, and o1,o2,o3,f∈Oare heap objects.
WRITE 1(v1,st1)← ASSIGN (v1,v2,st1)
WRITE 1(v1,st1)← LOAD(v1,v2,f,st1)
WRITE 2(v1,f,st1)← STORE (v1,f,v2,st1)
READ1(v2,st1)← ASSIGN (v1,v2,st1)
READ1(v2,st1)← STORE (v1,f,v2,st1)
READ2(v2,f,st1)← LOAD(v1,v2,f,st1)
DATA-DEP(st1,st2)← READ1(v1,st2), W RITE 1(v1,st1)
DATA-DEP(st1,st2)← READ2(v1,f,st2), W RITE 1(v1,st1)
DATA-DEP(st1,st2)← READ1(v1,st2), W RITE 2(v2,f,st1)
PTSTO(v1,o1), PTSTO(v2,o1)
DATA-DEP(st1,st2)← READ2(v1,f,st2), W RITE 2(v2,f,st1)
PTSTO(v1,o1), PTSTO(v2,o1)
DATA-DEP(st1,st3)← DATA-DEP(st1,st2), D ATA-DEP(st2,st3)
CALL-EDGE(o2,o1)← CALLS(o1,st1),STMT(st1,o2)
CALL-EDGE(o1,o3)← CALL-EDGE(o1,o2), C ALL-EDGE(o2,o3)
Figure 9: Datalog rules for the data dependency analysis.
To model the D ATA-DEPrelation, we use auxiliary relations
WRITE 1, W RITE 2, R EAD1, R EAD2 to represent the writes and
reads of variables/ﬁelds of objects. They correspond to the ﬁrst six
rules of Figure 9. Given the auxiliary read and write relatio ns, we
consider two statements to be data dependent, D ATA-DEP(st1,st2),
if there is a read at st2and a write to the same variable(s) at st1.
The ﬁrst two rules are for data dependencies through variabl es; the
next two rules are for data-dependencies through aliasing o bjects;
and the ﬁfth rule is for the transitivity of data-dependenci es.
For two functions o1,o2∈O, CALL-EDGE(o2,o1) if the func-
tiono1is called in function o2; this is speciﬁed in the second to last
rule in Figure 9. The last rule says that the relation is trans itive – it
represents edges in the call-graph.
To compute the control dependencies, we implement the algo-
rithm of Cytron et al. [9] on the JavaScript CFG to generate th e
CTRL-DEP(st1,st2) relation, meaning that st2is control-dependent
onst1. The corresponding Datalog rules are omitted for brevity.
Figure 10 shows the rules for computing the DOM event de-
pendency relation. Here, m1,m2,m3∈Oare function objects,
o1,o2∈Oare DOM objects, st1,st2∈Stare statement IDs, and
e1,e2∈Eare DOM event types. First, we create the program-
dependence relation [12], P ROG-DEP, i.e., the transitive closure of
the control- and data-dependencies. Then, we leverage P ROG-DEP
to create the F UNC-DEPrelation representing dependencies across
452PROG-DEP(st1,st2)← DATA-DEP(st1,st2)
PROG-DEP(st1,st2)← CTRL-DEP(st1,st2)
PROG-DEP(st1,st3)← PROG-DEP(st1,st2)
PROG-DEP(st2,st3)
FUNC-DEP(m1,m2)← PROG-DEP(st1,st2)
STMT(st1,m1)
STMT(st2,m2)
DOM-PROG-DEP(o1,e1,o2,e2)← DOM-M ODIFY (o1,e1,m1,st1)
DOM-M ODIFY (o2,e2,m2,st2)
FUNC-DEP(m1,m2)
DOM-M ODIFY -DEP(o1,e1,o2,e2)← DOM-M ODIFY (o1,e1,m1,st1)
DOM-M ODIFY (o2,e2,m2,st2)
STMT(st2,m1)
DOM-M ODIFY -DEP(o1,e1,o2,e2)← DOM-M ODIFY (o1,e1,m1,st1)
CALL-EDGE(m1,m3)
DOM-M ODIFY (o2,e2,m2,st2)
STMT(st2,m3)
DOM-DEP(o1,e1,o2,e2)← DOM-M ODIFY -DEP(o1,e1,o2,e2)
DOM-DEP(o1,e1,o2,e2)← DOM-PROG-DEP(o1,e1,o2,e2)
Figure 10: Datalog rules for the DOM dependency analysis.
functions. Finally, we consider the two cases for DOM event d epen-
dencies: those through program dependencies, and those inv olving
event handler modiﬁcations.
The relation D OM-PROG-DEPcaptures the ﬁrst case, where a
program-dependency exists between two functions called fr om the
DOM event handlers. Speciﬁcally, let two DOM objects o1,o2∈
Ohave event handlers m1andm2attached to their events of type
e1ande2, respectively. If m2is dependent on m1, we say that
DOM-PROG-DEP(o1,e1,o2,e1), i.e., there is a DOM event depen-
dency between o2’s handler of type e2ando1’s handler of type e1.
The relation DOM-M ODIFY -DEPcaptures the second case, when
the event handler of one DOM object installs/removes/modiﬁ es the
event handler of another DOM object. The ﬁrst DOM-M ODIFY -
DEPrule captures the simplest case: there is a function m1which
is an associated event handler of DOM object o1’s event of type
e1. Also, there is a DOM event handler add/remove/modiﬁcation
at statement st2wherest2is in function m1. Because there is a
DOM modiﬁcation of o2’s evente2inm1(at statement st2) we say
thato2’s evente2is dependent on o1’s evente1: DOM-M ODIFY -
DEP(o1,e1,o2,e2).
The next DOM-M ODIFY -DEPrule is similar but captures the
case where a DOM event handler calls a function that modiﬁes
a DOM object’s event handler. Speciﬁcally, there is a functi on
m1registered to DOM object o1’s evente1, and there is a call
fromm1to some function m3, which has a DOM modiﬁcation
of object o2’s evente2at statement st2. Sincem1transitively
affects DOM object o2’s evente2throughm3, we say: DOM-
MODIFY -DEP(o1,e1,o2,e2). Recall that C ALL-EDGE is deﬁned
as the transitive closure of function calls; it captures som e DOM
event-handler calling an arbitrary sequence of function ca lls lead-
ing to a DOM modiﬁcation.
Finally, the DOM event dependency relation, D OM-DEP, is the
combination of D OM-PROG-DEPand DOM-M ODIFY -DEP.
Since we focus on the over-approximated analysis, we deal wi th
event propagations (capturing and bubbling) and AJAX callb acks
conservatively. Recall that how the web browser propagate e vents
through the HTML DOM tree may affect the control ﬂow of the
JavaScript code in a web application. When capturing is enabled,
the parent element captures the event ﬁrst and then passes it down
to the children. In contrast, when bubbling is enabled, the target
element captures the event ﬁrst before passing it up to the pa rent el-
ements. For efﬁciency reasons, distinguishing these two ca ses in a
static analysis is difﬁcult. Therefore, we conservatively assume that
all JavaScript functions in the application may be executed in any
order. This approximation also works for modeling the execu tion
of asynchronous callbacks of the AJAX requests.5. IMPROVING AUTOMATED TESTING
In this section, we leverage the static DOM event dependency
analysis to improve A RTEMIS [5], a popular automated tester of
client-side web applications. Since A RTEMIS generates event se-
quences randomly (like R ANDOOP [34]), it often lacks the abil-
ity to reach high statement coverage. During our experiment s, for
example, the default algorithm in A RTEMIS could not reach more
than 65% coverage even after 500 iterations. In contrast, le verag-
ing our static DOM event dependency analysis enabled A RTEMIS
to quickly reach 80% coverage.
5.1 The Default Algorithm of Artemis
Algorithm 1 shows the default test input generation procedu re in
ARTEMIS . It takes the initial test /an}bracketle{tu0,S0,ρ0/an}bracketri}htas input and returns a
setResults of explored tests as output. Here, a test input is deﬁned
as a tuple/an}bracketle{tu,S0,ρ/an}bracketri}htwhereuis the URL of the web page, S0is the
initial state of the application, and ρ=ev1...evnis a sequence
of events. An eventev=/an}bracketle{tparam,state,env/an}bracketri}htcaptures not only
activities performed by the user, but also timer responses a nd AJAX
callbacks. Here, param denotes the values of the event parameters,
state denotes the values of the HTML form ﬁelds, and envdenotes
the values of environment parameters, such as the window siz e and
time of day. Line 18 shows our new pruning method: leveraging
the DOM event dependencies to skip redundant sequences.
Algorithm 1 Test sequence generation algorithm in A RTEMIS .
Initially: Worklist :={}; run A RTEMIS (u0,S0,ρ0).
1:ARTEMIS (URLu0, StateS0, Sequence ρ0) {
2:Results :={};
3:Worklist :={/an}bracketle{tu0,S0,ρ0/an}bracketri}ht};
4: while (Worklist/ne}ationslash=∅and¬timeout and¬maxruns )
5: c=/an}bracketle{tu,S,ρ/an}bracketri}ht=Worklist.removeNext ();
6: S′:=EXECUTE APPLICATION (c);
7: Results :=Results∪{(c,S′)};
8: //make test inputs by modifying the last event in ρ
9: foreach (variantev′
nofevninρ=ev1...evn) {
10: ρ′:=ev1...evn−1·ev′
n;
11: Worklist :=Worklist∪{/an}bracketle{tu,S,ρ′/an}bracketri}ht}
12: }
13: //make test inputs by extending ρwith a new event
14: if(S′/ne}ationslash∈V isitedStates ) {
15: VisitedStates.add (S′);
16: foreach (ev′
n+1enabled at S′) {
17: ρ′′:=ρ·ev′
n+1;
18: if(¬ISREDUNDANT (u, S,ρ′′))
19: Worklist :=Worklist∪{/an}bracketle{tu,S,ρ′′/an}bracketri}ht}
20: }
21: }
22: }
23: returnResults ;
24: }
ARTEMIS starts with an empty set Results of tests and a work-
list consisting of only /an}bracketle{tu0,S0,ρ0/an}bracketri}ht. Then, it loads the web page
fromu0with initial state S0and executes the sequence ρ0of events.
LetS′be the application state after applying these events. Next, it
generates new event sequences using one of the following met hods.
The ﬁrst method is to generate a variant ev′
nof the last event evn
in the sequence ρ=ev1...evn; this creates a new sequence ρ′=
ev1...evn−1ev′
n(Lines 8–12). In this case, ev′
n=/an}bracketle{tparam′,
state′,env′/an}bracketri}htwill have the same event type as evnbut different
values for the event parameters, form ﬁelds, and environmen tal pa-
rameters; meaning ρ′may lead to a different program state.
The second method for generating a new event sequence is to ap -
pend a new event evn+1to the end of ρto create the new sequence
ρ′′(Lines 13–21). In this case, the main problem is that the de-
fault algorithm in A RTEMIS never checks whether ρ′′is redundant,
i.e., whether ρ′′is equivalent to some event sequence(s) that have
453already been explored. In contrast, our new method will perf orm
such a check. As shown in Line 18, if ρ′′is proved to be redundant
by this newly added check, it will not be added to Worklist .
5.2 Pruning Redundant Event Sequences
Algorithm 2 shows the pseudocode of I SREDUNDANT () used at
Line 18 in Algorithm 1. Inside I SREDUNDANT (), the theoretical
foundation for deciding whether ρ′′is redundant is partial order
reduction (POR [13,23,43]). We say that two sequences ρ1andρ2
are equivalent if we can transform one sequence into the othe r by
repeatedly swapping adjacent andindependent events. Two events
ev1andev2are adjacent if they occur consecutively. They are
dependent if the two events access the same object and at least one
of them is a write (modifying the content of the object); we sa y they
areindependent if the two events are not dependent on each other.
Algorithm 2 Checking if the sequence ρis redundant.
1:ISREDUNDANT (URLu, StateS, Sequence ρ) {//Default in Artemis
2: return false ;
3:}
4:ISREDUNDANT (URLu, StateS, Sequence ρ) {//Our New Method
5: Letρ=ev1...evn·evn+1;
6: if(evn/ne}ationslash→DOMevn+1∧evn+1/ne}ationslash→DOMevn∧evn/ne}ationslash≤lexevn+1)
7: return true;
8: return false ;
9:}
Consider ρ1=ev1...evievj...evn, whereeviandevjare
independent. Since swapping the order of eviandevjdoes not
change the behavior of the application (they are commutativ e), we
knowρ2=ev1...evjevi...evntriggers the same behavior as
ρ1. Therefore, ρ1andρ2are equivalent. During testing, if A RTE-
MIShas already explored ρ1, then we can safely skip ρ2, since it
sufﬁces to test one representative from each equivalence cl ass of
sequences.
In Algorithm 2, the pruning of equivalent sequences is imple -
mented using a form of the sleep-set based reduction [21, 40] . To-
ward this end, we assign the events of the application a lexic al order,
<lex. When two adjacent events evnandevn+1satisfy the follow-
ing conditions:
•(1)(evn/ne}ationslash→DOMevn+1)∧(evn+1/ne}ationslash→DOMevn), meaning
they are independent with each other, and
•(2)evn<lexevn+1,
we choose to explore the sequence ...evn+1evn...while skip-
ping the sequence ...evnevn+1.... As shown in Line 6 of Algo-
rithm 2, we use the result of our DOM event dependency analysi s
to check whether the two events are independent from each oth er.
5.3 The Running Example
Consider the application in Figure 2, whose DOM event depen-
dencies are shown in Figure 3. Since the click event of test1 is
independent with itself, we skip the test sequence test1→test1
...as shown by the gray path on the left side of Figure 4 (b). Also,
since the click event oftest1 is independent with the click oftest2 ,
we explore test1→test2 but skiptest2→test1 ; we also skip
the subsequence test2→test1→test2 . Similarly, we skip all
the other gray sequences in Figure 4 (b). Therefore, up to dep th
3, our new method can reduce the total number of test sequence s
generated by A RTEMIS from 49 down to 14.
6. EXPERIMENTS
We implemented the new dependency analysis in a software too l
named JS DEP. It uses E SPRIMA for parsing and normalizing the
JavaScript code, JS-W ALA for constructing the control ﬂow graph,
and theµZﬁx-point engine [17] in Z3 [10] for solving the DatalogTable 1: Results of the static DOM-event dependency analysi s.
Name LOC Total Deps. Calculated Deps. Constraints Time (s)
case1 59 16 2 166 0.11
case2 72 16 3 187 0.11
case3 165 36 6 517 0.15
case4 196 64 8 618 0.16
frog 567 361 264 2,398 4.34
cosmos 363 169 144 1,000 0.20
hanoi 246 576 324 1,026 0.23
ﬂipﬂop 525 36 25 2,445 0.34
sokoban 3,056 361 256 2,116 0.35
wormy 570 81 64 3,683 0.42
chinabox 338 49 16 1,281 0.63
3dmodel 5,414 25 19 3,813 13.83
cubuild 1,014 36 25 5,684 6.83
pearlski 960 144 100 4,129 7.17
speedyeater 784 361 64 4,170 0.61
gallony 300 196 72 1,372 0.25
fullhouse 528 64 49 1,007 0.20
ball_pool 1,745 81 30 1,709 0.28
lady 820 121 81 4,564 7.88
harehound 468 529 168 1,976 1.53
match 369 576 400 6,385 4.49
Total 18,559 3,898 2,120 50,246 50.11
program. To demonstrate the usefulness of the analysis we ap plied
it to improve the performance of A RTEMIS [5], a state-of-the-art
web application testing tool.
Our experiments were designed to answer two questions:
•Can JS DEP compute the DOM event dependency relations
with reasonable accuracy at negligible run-time cost?
•Can JS DEP help A RTEMIS reach a higher testing coverage
than the default algorithm?
We evaluated JS DEPon a number of client-side web applications.
Our benchmarks fall into two groups. The ﬁrst are four varian ts of
Figure 2, case1 to case4, with four to eight buttons. The seco nd are
seventeen real web applications, ranging from hundreds to t hou-
sands of lines of code. Two are from A RTEMIS ’s benchmarks [5]
(ball_pool and 3dmodel). The rest are JavaScript-based gam es [1].
In total, there are 21 benchmark applications with 18,559 li nes of
code total. We ran all experiments on a computer with an Intel
Quad-Core i5-4440 3.10 GHz CPU with 12 GB of RAM.
6.1 Results: Dependency Analysis
Table 1 shows the result of the static DOM event dependency
analysis. Columns 1–2 show the name of the benchmark program
and the number of lines of code. Column 3 shows the maximum
number of possible DOM event dependencies, i.e., N2whereNis
the number of DOM events in the application. Conceptually, t his is
the dependency relation used by default in A RTEMIS : every DOM
event is dependent on every DOM event. Column 4, in contrast,
shows the number of DOM event dependencies found by our analy -
sis. Columns 5–6 show the statistics of our analysis: the siz e of the
Datalog program, and the time spent on the analysis. The time in-
cludes parsing, normalizing, and transforming the code, ge nerating
the Datalog program, and calling µZto solve the program.
Overall, our analysis can very quickly generate DOM event de -
pendency results: the time ranges from 0.5 to 13 seconds. The total
time spent on analyzing the 21 benchmarks is less than 1 minut e.
Also, the results are much better than the theoretical worst case.
Next, we show our analysis results are useful: they can signi ﬁcantly
improve the performance of A RTEMIS .
6.2 Results: Improving Artemis
Table 2 shows the results of running A RTEMIS with and with-
out leveraging JS DEP. Column 1 shows the benchmark’s name.
Columns 2–4 show statement coverage after running A RTEMIS and
454ARTEMIS +JS DEP for 100 iterations. Columns 5–7, 8–10, 11–13,
and 14–16 show the statement coverages achieved by running t hem
up to 200, 300, 400, and 500 iterations, respectively. A RTEMIS
is the algorithm as described by Artzi et al. [5] with their be st pri-
oritization technique enabled. Each iteration executes on e test se-
quence, i.e., an iteration of the loop in Figure 1.
Overall, the statement coverage of A RTEMIS +JS DEPis 10–16%
higher than A RTEMIS . For case1 and case2, in particular, the de-
fault A RTEMIS algorithm cannot reach 100% coverage even after
500 iterations. A RTEMIS +JS DEPcan reach 100% coverage within
only 100 iterations. Furthermore, as the number of iteratio ns in-
creases the average coverage of A RTEMIS remains stuck at 65%.
But, the average coverage of A RTEMIS +JS DEP keeps increasing.
This is because the default algorithm of A RTEMIS explores many
redundant test sequences. Our static analysis results are a ccurate
enough to skip many of these sequences and focus on useful tes ts.
There are some cases where A RTEMIS +JS DEPtemporarily had
lower coverage than A RTEMIS (e.g., match at 100 iterations). We
believe this is mainly due to the inherent randomness of sele cting
items from the worklist. However, as the number of iteration s in-
creases, A RTEMIS +JS DEPbecomes much better.
6.3 Results: Redundancy Removal
Next, we investigated how many sequences A RTEMIS +JS DEP
deemed redundant. Table 3 summarizes the results. We ran eac h
benchmark for 500 iterations and counted both the number of s e-
quences generated (Column 3) and the number of sequences we
found redundant (Column 4). Without using our method, all th e
redundant sequences would have been added to the worklist. O ver-
all, we reduce the number of sequences added to the worklist b y
36% on average. Examining the dependency results (Table 1), we
can see our analysis actually ﬁnds 46% of the DOM events inde-
pendent on average. The difference in the number of reduced s e-
quences and the actual number of independent DOM events come s
from the sleep-set approach of Algorithm 2: it does not guara ntee
to test only one sequences from each equivalence class. This is a
limitation of our POR implementation and not the static anal ysis.
Note: Column 3 counts the total number of sequences added to t he
worklist; only 500 of these were actually executed.
In addition to running A RTEMIS and A RTEMIS +JS DEP for a
ﬁxed number of iterations we also ran them for a ﬁxed amount
of time. Table 4 shows the result. Here, Columns 1–2 show the
benchmark name and execution time. Columns 3–4 show the num-
ber of iterations and statement coverage obtained by A RTEMIS .
Columns 5–6 show the number of iterations and statement cove r-
age obtained by A RTEMIS +JS DEP.
The runtime here, and in all tests, includes the static analy sis
overhead and the overhead in A RTEMIS to perform the dependency
check. So, A RTEMIS +JS DEP explores slightly fewer (92%) itera-
tions on average within the 10 minute bound. Also, the number
of iterations explored within the bound depends on the lengt h of
the tested sequences; this depends on the length of the seque nces
skipped. But, we still see a signiﬁcant increase in the avera ge of
the statement coverage: from 67% achieved by A RTEMIS to 80%
achieved by A RTEMIS +JS DEP. Overall, this indicates the default
ARTEMIS search strategy spends much time on redundant tests.
Threat to Validity. Although our static dependency analysis is de-
signed to be sound in the absence of JavaScript’s reﬂexive fe atures,
there is no theoretical guarantee of its soundness. However , this
is consistent with the norm of the research ﬁeld. As the autho rs
of [19, 35] have argued, due to the impact of JavaScript’s dyn amic
features, it is impossible to develop a truly sound and, at th e same
time, practically useful static analysis framework. Thus, in prac-
tice, software tools strive for achieving soundiness [27] as opposedto achieving soundness . The goal is being as sound as possible with-
out signiﬁcantly compromising precision and scalability. Since we
focus on improving the test coverage of A RTEMIS , as opposed to
proving properties, achieving soundiness is sufﬁcient.
7. RELATED WORK
Datalog-based program analysis was pioneered by Whaley and
Lam [42]. They introduced a framework for implementing poin ts-
to analyses as database queries [25]. Livshits and Lam [28] a nd
Naik et al. [32] used similar techniques in detecting securi ty errors
and data-races. Bravenboer and Smaragdakis [6] also formul ated a
points-to analysis as database queries. Kusano and Wang [24 ] used
Datalog engines to analyze interference in multithreaded p rograms.
However, these existing methods were all designed for analy zing
programs written in more static languages such as Java and C+ +.
Although there are works on applying Datalog-based program
analysis to JavaScript, none of them can handle DOM event dep en-
dencies that are crucial for client-side web applications. Specif-
ically, Guarnieri and Livshits [14] implemented a Datalog- based
analysis procedure in the GATEKEEPER tool; but, the goal was
statically enforcing security policies. Zheng et al. [44] d eveloped
a method for modeling AJAX APIs to check possible bugs when
there are asynchronous requests. Meyerovich and Livshits [ 31] also
developed a method for enforcing security policies in the br owser.
Jensen et al. [20] proposed a type inference algorithm for Ja vaScript
based web applications, which tracks DOM elements and brows er
APIs based on their IDs and types but did not compute the depen -
dency relations. Feldthaus et al. [11] proposed a method for con-
structing approximate call graphs but completely ignored t heir in-
teractions with the DOM. Madsen et al. [29] proposed a static anal-
ysis procedure that can infer the behavior of framework APIs but
it targeted JavaScript-based applications in Windows 8 onl y. Mad-
sen et al. [30] developed a static analysis procedure for the event-
driven Node.js applications but they were server-side applications
as opposed to client-side applications.
The methods proposed by Arlt et al. [4] and Cheng et al. [7] for
testing Java-based GUI applications are signiﬁcantly diff erent in
that they do not model the registration, modiﬁcation, and re moval
of event handlers (the focus of our work). Instead, they assu mes
that all event handlers are pre-installed, and thus focuses on analyz-
ing only data dependencies between these handlers. This ass ump-
tion may be reasonable for some Java-based GUI frameworks, b ut
is not valid for JavaScript-based web applications.
There is also a large body of work on pointer analysis, ﬂow ana l-
ysis, and type inference for JavaScript, which are not based on Dat-
alog and are not designed speciﬁcally for analyzing interac tions
with the HTML DOM. For example, Chugh et al. [8] proposed a
staged information ﬂow analysis for JavaScript to detect ce rtain se-
curity violations in client-side code. Sridharan et al. [39 ] proposed
a technique called correlation tracking to improve points- to analy-
sis. Guha et al. [15, 16] proposed a static ﬂow analysis for de tect-
ing AJAX intrusions, and typing local control and state. Wei and
Ryder [41] developed a set of blended analysis tools, using b oth
dynamic and static analyses to improve the points-to analys is. An-
dreasen and Møller [3] extended the TAJS analysis framework by
adding a static dataﬂow analysis to infer and exploit determ inacy
information; this improves the type inference and call-gra ph con-
struction for JavaScript programs using jQuery .TAJS itself builds
upon the classic monotone framework of Kam and Ullman [22] us -
ing a specialized analysis lattice structure. Alimadadi et al. [2] de-
veloped a change impact analysis capturing the interplay be tween
the JavaScript code changes and the HTML DOM, but their metho d
is valid only for the given dynamic execution, whereas our me thod
is static and therefore valid for all possible executions.
455Table 2: Results of comparing A RTEMIS and A RTEMIS +JS DEP with a ﬁxed number of iterations.
Artemis Art.+JSdep Artemis Artemis+JSdep Artemis Art.+JS dep Artemis Art.+JSdep Artemis Art.+JSdep
Name Iter. Cov.(%) Cov.(%) Iter. Cov.(%) Cov.(%) Iter. Cov. (%) Cov.(%) Iter. Cov.(%) Cov.(%) Iter. Cov.(%) Cov.(%)
case1 100 70.59 100 200 70.59 100 300 70.59 100 400 70.59 100 50 0 70.59 100
case2 100 43.90 100 200 43.90 100 300 43.90 100 400 43.90 100 50 0 43.90 100
case3 100 38.10 62.86 200 38.10 74.29 300 38.10 74.29 400 38.1 0 95.24 500 38.10 95.24
case4 100 47.12 59.62 200 47.12 72.12 300 47.12 72.12 400 47.1 2 72.12 500 47.12 72.12
frog 100 86.79 89.29 200 88.93 96.43 300 88.93 96.43 400 88.93 96.79 500 88.93 97.86
cosmos 100 57.48 72.44 200 57.48 77.17 300 57.48 77.17 400 57. 48 77.95 500 57.48 77.95
hanoi 100 77.19 76.32 200 77.19 76.32 300 77.19 82.46 400 77.1 9 82.46 500 77.19 82.46
ﬂipﬂop 100 97.05 95.94 200 97.05 97.05 300 97.05 97.05 400 97. 05 97.05 500 97.05 97.05
sokoban 100 73.09 76.46 200 73.09 76.46 300 73.09 76.46 400 73 .09 76.46 500 73.09 76.46
wormy 100 39.76 40.95 200 39.76 40.95 300 39.76 40.95 400 39.7 6 40.95 500 39.76 40.95
chinabox 100 79.88 82.32 200 79.88 83.54 300 79.88 84.15 400 7 9.88 84.15 500 79.88 84.15
3dmodel 100 64.01 71.50 200 64.01 71.50 300 64.01 71.50 400 64 .01 71.98 500 64.01 71.98
cubuild 100 61.30 68.15 200 61.30 73.46 300 61.30 78.42 400 61 .30 85.79 500 61.30 85.79
pearlski 100 52.52 52.72 200 52.52 53.72 300 52.52 53.72 400 5 2.52 53.92 500 52.52 56.54
speedyeater 100 45.93 46.41 200 45.93 53.11 300 45.93 53.35 4 00 45.93 53.35 500 45.93 54.78
gallony 100 69.86 93.15 200 69.86 94.52 300 69.86 94.52 400 69 .86 94.52 500 69.86 94.52
fullhouse 100 77.38 83.33 200 77.38 83.33 300 77.38 83.33 400 77.38 87.50 500 77.38 87.50
ball_pool 100 71.43 89.75 200 73.16 91.24 300 73.16 93.09 400 73.16 93.43 500 73.16 93.43
lady 100 76.13 77.25 200 76.13 79.50 300 76.13 79.50 400 76.13 79.50 500 76.13 79.50
harehound 100 80.28 88.07 200 80.28 91.28 300 80.28 91.28 400 80.28 92.20 500 80.28 92.20
match 100 61.45 50.28 200 61.45 62.01 300 61.45 73.18 400 61.4 5 73.18 500 61.45 73.18
Average 100 65.29 75.08 200 65.48 78.47 300 65.48 79.66 400 65.48 81.3 5 500 65.48 81.60
Table 3: Results of blocked sequence ratio (step 500).
Name Iter. Redundancy Checked Redundancy Found Ratio (%)
case1 500 1,001 499 49.85
case2 500 1,832 1,326 72.38
case3 500 4,436 3,232 72.86
case4 500 4,009 2,976 74.23
frog 500 9,501 1,895 19.95
cosmos 500 6,501 500 7.69
hanoi 500 11,501 2,015 17.52
ﬂipﬂop 500 9,001 8,145 90.49
sokoban 500 9,501 1,830 19.26
wormy 500 3,033 443 14.61
chinabox 500 3,501 1,709 48.81
3dmodel 500 2,949 708 24.01
cubuild 500 3,001 768 25.59
pearlski 500 6,001 749 12.48
speedyeater 500 12,501 1,848 14.78
gallony 500 7,001 3,393 48.46
fullhouse 500 14,001 499 3.56
ball_pool 500 4,501 2,206 49.01
lady 500 5,001 290 5.80
harehound 500 11,501 4,771 41.48
match 500 12,384 5,502 44.43
Average 6,793 2,157 36.05
In addition to improving the performance of A RTEMIS , the re-
sult of our static DOM event dependency analysis may be used
to improve a wide range of dynamic analysis tools. For exam-
ple, the S YMJS tool of Li et al. [26] relies on symbolic execution
to generate test inputs for JavaScript based web applicatio ns, but
does not leverage the result of any static dependency analys is pro-
cedure. The K UDZU tool of Saxena et al. [37] uses a virtual ma-
chine based symbolic execution procedure to analyze client -side
JavaScript code injection. The J ALANGI tool developed by Sen et
al. [38] provides a generic framework for implementing dyna mic
analysis techniques for JavaScript, e.g., concolic testin g, but lacks
the capability of conducting static program analysis. Nguy en et
al. [33] proposed a delta-debugging based method for reduci ng the
redundant parts of a test case generated by a symbolic execut ion
tool. Jensen et al. [18] developed a stateless model checkin g tool
for systematic testing of event-driven applications with a ﬁxed data
input. However, these methods focus on dynamic analysis, wh ereas
our work focuses on static analysis and therefore is complem entary.Table 4: Comparing A RTEMIS with A RTEMIS +JS DEP.
Artemis Artemis+JSdep
Name Time (s) Iter. Coverage (%) Iter. Coverage (%)
case1 600 5,819 70.59 1,972 100
case2 600 5,018 43.90 4,208 100
case3 600 4,292 38.10 7,090 100
case4 600 3,995 47.12 4,532 72.12
frog 600 1,656 88.21 96 84.64
cosmos 600 1,663 57.48 1,123 78.74
hanoi 600 2,782 77.19 1,884 82.46
ﬂipﬂop 600 771 97.05 459 97.05
sokoban 600 1,225 73.09 264 76.68
wormy 600 1,179 52.23 538 40.95
chinabox 600 736 79.88 174 84.15
3dmodel 600 137 64.01 132 71.98
cubuild 600 661 61.30 242 75.51
pearlski 600 1,257 53.32 322 53.72
speedyeater 600 2,688 77.27 2,735 78.47
gallony 600 3,756 69.86 4,596 94.52
fullhouse 600 2,372 77.38 1,107 88.10
ball_pool 600 36 71.43 34 74.19
lady 600 64 75.90 55 76.58
harehound 600 2,383 80.28 2,305 94.50
match 600 2,462 62.01 7,444 73.18
Average 600 2,140 67.50 1,967 80.83
8. CONCLUSIONS
We have presented a constraint-based method for statically com-
puting DOM event dependencies in client-side web applicati ons
by formulating the static analysis as a Datalog program. We h ave
also presented a method for leveraging the result of our depe ndency
analysis to improve the performance of a popular web applica tion
testing tool named A RTEMIS . We have implemented our meth-
ods and evaluated them on real web applications. Our experim ents
show that the new methods can compute DOM event dependencies
with reasonable accuracy and at a negligible cost. Furtherm ore,
they allow A RTEMIS to signiﬁcantly reduce test sequence redun-
dancies and therefore improve the test coverage.
9. ACKNOWLEDGMENTS
This work was primarily supported by the NSF under grants
CCF-1149454, CCF-1405697, and CCF-1500024. Partial suppo rt
was provided by the ONR under grant N00014-13-1-0527.
45610. ARTIFACT DESCRIPTION
Our artifact includes two parts: JS DEP, the new tool for static
DOM event dependency analysis, and the modiﬁed A RTEMIS for
automated testing of client-side web applications.
•The performance of JS DEP can be evaluated by applying it
to the JavaScript benchmarks included in the artifact. The
results have been shown in Table 1.
•The performance of A RTEMIS , with and without the perfor-
mance improvement provided by JS DEP, can be evaluated on
the web application benchmarks included in the artifact. Th e
results have been shown in Tables 2, 3 and 4.
•The artifact includes scripts for running the individual an aly-
sis procedures provided by JS DEP and A RTEMIS , as well as
generating the experimental result tables.
•The artifact also includes the raw data of experiments that w e
conducted to produce the result tables used in this paper.
The overall structure of the artifact is shown in Figure 11. H ere, the
block labeled DOM Analysis refers to the static analysis performed
by JS DEP, and the block labeled Modiﬁed Artemis refers to the web
application testing tool.
Figure 11: Structure of the artifact.
The tools, benchmarks, and experimental data are publicly a vail-
able. The URL is https://github.com/sch8906/JSdep .
10.1 Installation
JSDEP has been developed and tested on a popular Linux plat-
form: Ubuntu 12.04 Desktop 64-bit. Internally, JS DEPbuilds upon
Node.js and the Z3SMT solver [10]. Therefore, prior to running
JSDEP, both Node.js andZ3must be installed.
•To install Node.js in Ubuntu Linux, run sudo apt-get
install nodejs .
•To install the Z3SMT solver, visit its ofﬁcial website and
follow the directions from there.To install our modiﬁed version of A RTEMIS , please
•install all dependencies that A RTEMIS needs, based on the
README ﬁle provided, and then
•follow the directions provided in the INSTALL ﬁle under the
artemis-modified directory.
10.2 Evaluating the DOM Analysis
The JavaScript benchmarks included in the artifact are stor ed in a
set of subdirectories, one benchmark program per subdirect ory. To
evaluate the DOM event dependency analysis on all benchmark s,
run the following script:
$ make build-dep-all
Alternatively, the dependency analysis may be evaluated on each
individual benchmark. Assume that the name of the benchmark is
prog ; you may run the following script:
$ make build-dep prog
The result of our new dependency analysis tool, JS DEP, will be
stored in three ﬁles under the info subdirectory for each bench-
mark:
•dep.txt , which stores the dependency relations;
•numConstraints.txt , which stores the total number of
constraints, and
•z3.time , which stores the execution time.
10.3 Evaluating the Modiﬁed Artemis
To evaluate the modiﬁed A RTEMIS tool on all benchmarks, run
the following script:
$ make-run-artemis-all
Alternatively, A RTEMIS may be evaluated on each individual bench-
mark. Assume that the name of the benchmark is prog ; you may
run the following script:
$ make-run-artemis prog
Internally, A RTEMIS uses thedep.txt ﬁle computed by JS DEP
for each benchmark to improve the testing performance. It st ores
the ﬁnal results in two plaintext ﬁles under the artemis-result
directory for each benchmark:
•old_artemis.stdout : output of the original A RTEMIS ,
and
•new_artemis.stdout : output of the modiﬁed A RTEMIS .
10.4 Experimental Data
Our raw experimental data are stored in the directory named
raw-data . The data may be used to generate the result tables
used in this paper, by running the following three commands:
$ make table1
$ make table2
$ make table3
The above commands print the result tables in the L ATEX format.
After obtaining new experimental data by re-running our too ls,
the command make fetch-data may be used to move the newly
created experimental data from the current benchmark direc tory to
theraw-data directory.
After that, the three aforementioned commands, make table1 ,
make table2 andmake table3 , may be used to process the
updated data and generate the new result tables.
45711. REFERENCES
[1] 100 Online JavaScript Games. URL:
http://www.lutanho.net/stroke/online.html.
[2] S. Alimadadi, A. Mesbah, and K. Pattabiraman. Hybrid
dom-sensitive change impact analysis for javascript. In 29th
European Conference on Object-Oriented Programming,
ECOOP 2015, July 5-10, 2015, Prague, Czech Republic ,
pages 321–345, 2015.
[3] E. Andreasen and A. Møller. Determinacy in static analys is
for jQuery. In ACM SIGPLAN Conference on Object
Oriented Programming, Systems, Languages, and
Applications , pages 17–31, 2014.
[4] S. Arlt, A. Podelski, and M. Wehrle. Reducing GUI test
suites via program slicing. In International Symposium on
Software Testing and Analysis , pages 270–281, 2014.
[5] S. Artzi, J. Dolby, S. H. Jensen, A. Moller, and F. Tip. A
framework for automated testing of JavaScript web
applications. In International Conference on Software
Engineering , pages 571–580, 2011.
[6] M. Bravenboer and Y . Smaragdakis. Strictly declarative
speciﬁcation of sophisticated points-to analyses. In ACM
SIGPLAN Conference on Object Oriented Programming,
Systems, Languages, and Applications , pages 243–262, 2009.
[7] L. Cheng, J. Chang, Z. Yang, and C. Wang. GUICat: GUI
testing as a service. In IEEE/ACM International Conference
On Automated Software Engineering , 2016.
[8] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner. Staged
information ﬂow for javascript. In ACM SIGPLAN
Conference on Programming Language Design and
Implementation , pages 50–62, 2009.
[9] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and
F. K. Zadeck. Efﬁciently computing static single assignmen t
form and the control dependence graph. ACM Trans.
Program. Lang. Syst. , 13(4):451–490, 1991.
[10] L. De Moura and N. Bjørner. Z3: An efﬁcient smt solver. In
Proceedings of the Theory and Practice of Software, 14th
International Conference on Tools and Algorithms for the
Construction and Analysis of Systems , pages 337–340,
Berlin, Heidelberg, 2008. Springer-Verlag.
[11] A. Feldthaus, M. Schäfer, M. Sridharan, J. Dolby, and F. Tip.
Efﬁcient construction of approximate call graphs for
JavaScript IDE services. In International Conference on
Software Engineering , pages 752–761, 2013.
[12] J. Ferrante, K. J. Ottenstein, and J. D. Warren. The prog ram
dependence graph and its use in optimization. ACM Trans.
Program. Lang. Syst. , 9(3):319–349, July 1987.
[13] P. Godefroid. Partial-Order Methods for the Veriﬁcation of
Concurrent Systems - An Approach to the State-Explosion
Problem . Springer, 1996.
[14] S. Guarnieri and V . B. Livshits. GATEKEEPER: mostly
static enforcement of security and reliability policies fo r
JavaScript code. In USENIX Security Symposium , pages
151–168, 2009.
[15] A. Guha, S. Krishnamurthi, and T. Jim. Using static anal ysis
for Ajax intrusion detection. In International Conference on
World Wide Web , pages 561–570, 2009.
[16] A. Guha, C. Saftoiu, and S. Krishnamurthi. Typing local
control and state using ﬂow analysis. In European
Symposium on Programming , pages 256–275, 2011.
[17] K. Hoder, N. Bjørner, and L. de Moura. muZ - an efﬁcient
engine for ﬁxed points with constraints. In International
Conference on Computer Aided Veriﬁcation , pages 457–462,
2011.[18] C. S. Jensen, A. Møller, V . Raychev, D. Dimitrov, and M. T .
Vechev. Stateless model checking of event-driven
applications. In ACM SIGPLAN Conference on Object
Oriented Programming, Systems, Languages, and
Applications , pages 57–73, 2015.
[19] S. H. Jensen, P. A. Jonsson, and A. Møller. Remedying the
eval that men do. In International Symposium on Software
Testing and Analysis , pages 34–44, 2012.
[20] S. H. Jensen, M. Madsen, and A. Møller. Modeling the
HTML DOM and browser API in static analysis of javascript
web applications. In ACM SIGSOFT Symposium on
Foundations of Software Engineering , pages 59–69, 2011.
[21] V . Kahlon, C. Wang, and A. Gupta. Monotonic partial orde r
reduction: An optimal symbolic partial order reduction
technique. In International Conference on Computer Aided
Veriﬁcation , pages 398–413, 2009.
[22] J. B. Kam and J. D. Ullman. Monotone data ﬂow analysis
frameworks. Acta Inf. , 7:305–317, 1977.
[23] M. Kusano and C. Wang. Assertion guided abstraction: a
cooperative optimization for dynamic partial order reduct ion.
InIEEE/ACM International Conference On Automated
Software Engineering , pages 175–186, 2014.
[24] M. Kusano and C. Wang. Flow-sensitive composition of
thread-modular abstract interpretation. In ACM SIGSOFT
Symposium on Foundations of Software Engineering , 2016.
[25] M. S. Lam, J. Whaley, V . B. Livshits, M. C. Martin, D. Avot s,
M. Carbin, and C. Unkel. Context-sensitive program analysi s
as database queries. In ACM SIGACT-SIGMOD-SIGART
Symposium on Principles of Database Systems , pages 1–12,
2005.
[26] G. Li, E. Andreasen, and I. Ghosh. SymJS: automatic
symbolic testing of JavaScript web applications. In ACM
SIGSOFT Symposium on Foundations of Software
Engineering , pages 449–459, 2014.
[27] B. Livshits, M. Sridharan, Y . Smaragdakis, O. Lhoták, J . N.
Amaral, B. E. Chang, S. Z. Guyer, U. P. Khedker, A. Møller,
and D. Vardoulakis. In defense of soundiness: a manifesto.
Commun. ACM , 58(2):44–46, 2015.
[28] V . B. Livshits and M. S. Lam. Finding security
vulnerabilities in Java applications with static analysis . In
USENIX Security Symposium , 2005.
[29] M. Madsen, B. Livshits, and M. Fanning. Practical stati c
analysis of JavaScript applications in the presence of
frameworks and libraries. In ACM SIGSOFT Symposium on
Foundations of Software Engineering , pages 499–509, 2013.
[30] M. Madsen, F. Tip, and O. Lhoták. Static analysis of
event-driven Node.js JavaScript applications. In ACM
SIGPLAN Conference on Object Oriented Programming,
Systems, Languages, and Applications , pages 505–519, 2015.
[31] L. A. Meyerovich and V . B. Livshits. ConScript: Specify ing
and enforcing ﬁne-grained security policies for JavaScrip t in
the browser. In IEEE Symposium on Security and Privacy ,
pages 481–496, 2010.
[32] M. Naik, A. Aiken, and J. Whaley. Effective static race
detection for Java. In ACM SIGPLAN Conference on
Programming Language Design and Implementation , pages
308–319, 2006.
[33] C. Nguyen, H. Yoshida, M. R. Prasad, I. Ghosh, and K. Sen.
Generating succinct test cases using don’t care analysis. I n
IEEE International Conference on Software Testing,
Veriﬁcation and Validation , pages 1–10, 2015.
[34] C. Pacheco and M. D. Ernst. Randoop: feedback-directed
random testing for Java. In ACM SIGPLAN Conference on
458Object Oriented Programming, Systems, Languages, and
Applications , pages 815–816, 2007.
[35] G. Richards, C. Hammer, B. Burg, and J. Vitek. The eval th at
men do - A large-scale study of the use of eval in javascript
applications. In European Conference on Object-Oriented
Programming , pages 52–78, 2011.
[36] A. Rountev, A. Milanova, and B. G. Ryder. Points-to
analysis for java using annotated constraints. In ACM
SIGPLAN Conference on Object Oriented Programming,
Systems, Languages, and Applications , pages 43–55, 2001.
[37] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A symbolic execution framework for javascript. In
IEEE Symposium on Security and Privacy , pages 513–528,
2010.
[38] K. Sen, S. Kalasapur, T. G. Brutch, and S. Gibbs. Jalangi : a
selective record-replay and dynamic analysis framework fo r
JavaScript. In ACM SIGSOFT Symposium on Foundations of
Software Engineering , pages 488–498, 2013.
[39] M. Sridharan, J. Dolby, S. Chandra, M. Schäfer, and F. Ti p.
Correlation tracking for points-to analysis of JavaScript . In
European Conference on Object-Oriented Programming ,
pages 435–458, 2012.[40] C. Wang, Z. Yang, V . Kahlon, and A. Gupta. Peephole parti al
order reduction. In International Conference on Tools and
Algorithms for Construction and Analysis of Systems , pages
382–396, 2008.
[41] S. Wei and B. G. Ryder. State-sensitive points-to analy sis for
the dynamic behavior of JavaScript objects. In European
Conference on Object-Oriented Programming , pages 1–26,
2014.
[42] J. Whaley and M. S. Lam. Cloning-based context-sensiti ve
pointer alias analysis using binary decision diagrams. In
ACM SIGPLAN Conference on Programming Language
Design and Implementation , pages 131–144, 2004.
[43] N. Zhang, M. Kusano, and C. Wang. Dynamic partial order
reduction for relaxed memory models. In ACM SIGPLAN
Conference on Programming Language Design and
Implementation , pages 250–259, 2015.
[44] Y . Zheng, T. Bao, and X. Zhang. Statically locating web
application bugs caused by asynchronous calls. In
International Conference on World Wide Web , pages
805–814, 2011.
459