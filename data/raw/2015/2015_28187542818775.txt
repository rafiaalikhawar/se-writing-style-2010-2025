Data-Delineation in Software Binaries and its
Application to Buffer-Overrun Discovery
Denis Gopan, Evan Driscoll, Ducson Nguyeny, Dimitri Naydichy, Alexey Loginovyand David Melskiy
GrammaTech, Inc.
Madison, WI, USAyIthaca, NY , USA
fgopan,edriscoll,dnguyen,dnaydich,alexey,melskig@grammatech.com
Abstract ‚ÄîDetecting memory-safety violations in binaries is
complicated by the lack of knowledge of the intended data
layout, i.e., the locations and sizes of objects. We present
lightweight, static, heuristic analyses for recovering the intended
layout of data in a stripped binary. Comparison against DWARF
debugging information shows high precision and recall rates
for inferring source-level object boundaries. On a collection of
benchmarks, our analysis eliminates a third to a half of incorrect
object boundaries identiÔ¨Åed by an IDA Pro-inspired heuristic,
while retaining nearly all valid object boundaries.
In addition to measuring their accuracy directly, we evaluate
the effect of using the recovered data for improving the precision
of static buffer-overrun detection in the defect-detection tool
CodeSonar/x86. We demonstrate that CodeSonar‚Äôs false-positive
rate drops by about 80% across our internal evaluation suite
for the tool, while our approximation of CodeSonar‚Äôs recall only
degrades about 25%.
I. I NTRODUCTION
Despite signiÔ¨Åcant efforts by the research community, buffer
overruns still constitute one of the most serious threats to
software security. Many techniques for securing the execution
of arbitrary executables have been advanced, for example, stack
canaries [ 1], ASLR [ 2,3], DEP [ 4], shadow stacks [ 5,6], and
control-Ô¨Çow integrity [ 7‚Äì10]. These techniques provide coarse-
grained protections that are reasonably effective against attacks
that attempt to hijack or alter the control Ô¨Çow of a program.
However, some attacks are much harder to detect and
remediate. For instance, non-control-data attacks modify critical
data without directly affecting control Ô¨Çow [ 11], and buffer
overread s can expose sensitive data without having a detectable
effect on the program‚Äôs execution. Against these kinds of
attacks, the techniques mentioned in the previous paragraph
offer little to no protection.
If the positions and sizes of buffers in a program are known,
then more powerful protection techniques can be applied, for
example Ô¨Åne-grained stack-layout transformation (SLX, [ 12]) or
insertion of explicit memory-safety checks [ 13‚Äì16]. In addition,
static analysis tools can use information about buffers to identify
potential buffer overruns.
Unfortunately, information about buffer sizes and locations
is not readily available for stripped binaries. A means of
inferring this information would enable such use cases as
This material is based upon work supported by the United States Air Force
under Contract No. FA8650-10-C-7025. Any opinions, Ô¨Åndings and conclusions
or recommendations expressed in this material are those of the author(s) and
do not necessarily reÔ¨Çect the views of the United States Air Force.vetting COTS programs for vulnerabilities prior to deployment,
improving the analysis of source code that calls third-party
binary-only libraries, and applying protections such as SLX to
COTS programs.
Existing techniques for inferring object boundaries tend to
fall short in one of two ways. Some heuristic-based approaches,
e.g., IDA Pro [ 17], often break large objects into pieces.
The boundaries inferred by such approaches will cause false
alarms if used for bounds checking, and may even disrupt
program functionality if used for program transformation.
Other approaches, e.g., [ 18,19], assume that a program is
memory safe, and thus derive bounds that include the potential
overruns. The resulting information is unhelpful for buffer-
overrun detection.
In this paper, we present a heuristic approach that addresses
the following question:
Given an arbitrary stripped executable,
infer locations and sizes of objects suitable
for buffer-overrun detection and protection.
We call our approach Data-Delineation Analysis (DDA). We
use the term object to refer to any top-level datum, such as
an array, structure, or variable, regardless of whether or not
the binary was created from an object-oriented language. DDA
starts with a set of object boundaries that is largely a superset
of the desired result. Such set can be obtained with the use IDA
Pro or an IDA-Pro-like heuristic (Sect. III-A ). This superset of
object boundaries is then reÔ¨Åned systematically by eliminating
boundaries that fall within larger objects, such as structure
instances. Insofar as the initial set of boundaries provides an
overapproximation to the ground truth, our goal is to eliminate
as many spurious object boundaries as we can; at the same
time, we want to retain the true boundaries that enable the
detection of actual buffer overruns.
At the heart of DDA is a novel technique that we call
Parameter-Offset Analysis (POA). POA operates by identifying
and symbolically propagating possible ‚Äúbase‚Äù pointers to
objects. For each base pointer, the set of constant offsets used
in memory dereferences is collected to estimate the extent of
the object pointed to by the base pointer. That is, if POA sees
an instruction ‚Äú mov eax, [ebx + 128] ‚Äù and the value of
ebx is recognized as the base pointer Pbase, the analysis infers
that the instruction is performing a Ô¨Åeld access and concludes
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 ¬© 2015 IEEE
DOI 10.1109/ICSE.2015.36145
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 ¬© 2015 IEEE
DOI 10.1109/ICSE.2015.36145
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 ¬© 2015 IEEE
DOI 10.1109/ICSE.2015.36145
2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
978-1-4799-1934-5/15 $31.00 ¬© 2015 IEEE
DOI 10.1109/ICSE.2015.36145
ICSE 2015, Florence, Italy
that the object pointed to by Pbase is at least 132bytes long
(because four bytes are accessed).
To avoid the pitfall of over-approximating object extent based
on unsafe memory accesses, we rely on the intuition that buffer
overruns are more likely to be in loops where the address or
offset changes on each iteration, or in calls to functions like
strcpy that operate on unbounded buffers. Therefore, our
analysis only makes use of offsets that appear as syntactic
constants (that is, literal values) in the program text.
We implemented our approach for 32-bit x86 binaries1and
evaluated the analysis prototype on a number of real-world
benchmarks ‚Äì binaries compiled from C and C++ code with
both GNU GCC and the Microsoft Visual C++ compiler. To
evaluate our analysis we conducted two types of experiments:
We compared the boundaries inferred by our analysis with
debug information (DWARF2). The evaluation showed that
our approach yields a low number of both false positives
and false negatives for unoptimized builds. However, the
analysis precision somewhat decreases at more aggressive
optimization levels. We present a detailed analysis of false
positives and false negatives in our experiments.
We used object boundaries derived by our analysis to
improve precision of CodeSonar/x86 [20], a commercial
heuristic static-analysis tool for detecting defects in x86
binaries. Our experiments showed that the use of object
boundaries found using parameter-offset analysis reduced
our approximation of the number of false-positive warn-
ings by about 80% while only reducing our approximation
of the number of true positives by slightly more than
25% (the latter corresponds to increasing false negatives).
Interestingly, optimized programs saw more beneÔ¨Åt from
DDA on both measures.
Contributions. This paper makes the following contributions:
We present an approach for recovering data layout in an
arbitrary, stripped binary.
We describe a scalable implementation of our approach
We present an extensive evaluation of our prototype
implementation based on comparison of the recovered
layout data with debug information.
We evaluate the usefulness of the improved data bound-
aries when used for static buffer-overrun detection, using
CodeSonar/x86.
II. O VERVIEW
This section provides a high-level, intuitive overview of the
operation of Parameter Offset Analysis (POA). Figure 1 shows
a code snippet extracted from PuTTy [ 21], a popular SSH-
client utility. Our static analysis tool, CodeSonar/x86, reports
two spurious buffer overruns on Lines 20 and 21 when run
without POA. Below, we explain the root causes of the two
false positives and show how POA derives the correct object
boundaries, allowing CodeSonar to eliminate the warnings.
1There is nothing in our approach that is speciÔ¨Åc to x86 or 32 bits, and it
could be easily extended to x64 and other processor architectures.Motivation. Without POA, CodeSonar/x86 uses object bound-
aries largely as they are found by IDA Pro. IDA Pro determines
what boundaries exist based in part on the constant offsets
from the stack and frame pointers that appear explicitly in the
program text (see Sect. III-A).
As shown in Fig. 1, des3_decrypt_pubkey_ossh
dereferences addresses esp,esp+128 , and esp+132 ; IDA
Pro reports these as object boundaries, and CodeSonar/x86
inherits that information from IDA Pro. These boundaries
split the object ourkeys into three separate chunks, causing
CodeSonar to think that the size of var4 (whose address is
passed to des_cbc3_decrypt ) is 128 bytes as opposed to
136 bytes (the true size of ourkeys).
When analyzing des_cbc3_decrypt , CodeSonar Ô¨Ånds
memory accesses at offsets 128‚Äì131 (Line 20) and 132‚Äì135
(Line 21) from the formal parameter corresponding to scheds .
However, CodeSonar also sees that &var4 is passed as an
actual parameter to that function, and because the accesses
to offsets 128‚Äì135 are beyond what it thinks var4 ‚Äôs size is,
CodeSonar emits buffer-overrun warnings for Lines 20 and 21.
Parameter-Offset Analysis. POA aims to learn the layout of
objects by observing the memory access patterns that appear in
a program. To derive accurate bounds, POA must only consider
safe memory accesses and ignore the accesses that are out of
bounds. This presents a-chicken-and-an-egg problem because
accurate bounds are needed to judge which memory accesses
are safe. We rely on the insights described below to resolve
this issue.
Accesses to Ô¨Åelds of structured data are often compiled into
instructions that add a constant offset to the base address for the
data and then dereference it, e.g., those instructions in Lines 20
and 21 of Fig. 1. In that example, the base address is passed in
as the parameter to des_cbc3_decrypt and is then loaded
intoeax on Line 19. Syntactic-constant offsets 128 and 132
from that base pointer are then dereferenced to access the
corresponding Ô¨Åelds.
Meanwhile, the most likely buffer overruns occur either in
calls to library functions (e.g., the infamous gets ) or inside
loops; neither one of these constructs causes access patterns
with syntactic constants.
These two observations led us to our guiding principle:
Memory accesses that use syntactically constant
offsets have a good chance of being safe.
Applied to our running example, this principle indicates that
the memory accesses on Lines 20 and 21, because they use
constant offsets from the base address, are much more likely
to be safe than unsafe. As a result, POA can conclude that
var4 (which is referenced by those accesses) is at least 136
bytes and remove the false object boundaries that IDA Pro
inferred at offsets 128 and 132.
POA operates by identifying potential base addresses for
the objects in a program and collecting, for each identiÔ¨Åed
base address, the set of constant offsets that are used in its
dereferences. These sets of offsets are used to determine the
extent of the objects referenced by each of the base pointers.
146
146
146
146
ICSE 2015, Florence, Italy1 typedef struct {
2 word32 k0246[16], k1357[16];
3 word32 iv0; // offset 128
4 word32 iv1; // offset 132
5 } DESContext;
6 void des3_decrypt_pubkey_ossh() sub_427270:
7 { sub esp, 408
8 DESContext ourkeys;
9 ourkeys.iv0 = ...; mov dword [esp + 128], ...
10 ourkeys.iv1 = ...; mov dword [esp + 132], ...
11 des_cbc3_decrypt(&ourkeys); lea ecx, [esp]
12 ... push ecx
13 ... call sub_426C10
14 }
15 static void des_cbc3_decrypt(
16 DESContext *scheds) sub_426C10:
17 {
18 word32 iv0, iv1; ...
19 .... mov eax, dword [ebp + 8]
20 scheds->iv0 = iv0; mov dword [eax + 128], ebx
21 scheds->iv1 = iv1; mov dword [eax + 132], edx
22 }sourceIDA Pro andCodeSonar/x86without DDADDAesp+408
esp+140
esp+136
esp+132
esp+128
esp... var1 var1ourkeys
.k0246 .k1357.iv0.iv1
var4var3var2
var4_struct
Fig. 1: Running example, extracted from PuTTy. Source excerpts are shown on the left, the corresponding machine code is in the middle, and a diagram of the
stack under different views is on the right. The dotted lines in the source diagram indicate subobject boundaries. The vertical axis is not to scale; each element
ofourkeys.k0246 andourkeys.k1357 is four bytes as well. The object var1 is included because of an access to esp+110 that is omitted from the
excerpt.
POA is compositional: it works bottom-up over the call graph,
computing a summary for each procedure. The summary
consists of a map from a parameter ordinal to a set of offsets
that are added to the parameter in an address computation and
then dereferenced. At call sites, POA looks at the summaries for
the called procedure, and if there is a non-empty set of offsets
associated with a parameter, then POA treats the parameter
value as a base address and extends its associated set of offsets
with the offsets from the summary.
For the running example (Fig. 1), POA Ô¨Årst examines
des_cbc3_decrypt . Using symbolic execution, it tracks
the Ô¨Çow of the Ô¨Årst parameter (represented by a sym-
bolic constant p1) into eax on Line 19. On Line 20,
the analysis sees a memory dereference with the sym-
bolic address p1+ 128 . The access is four bytes, and so
POA adds to des_cbc3_decrypt ‚Äôs summary the mapping
[p17!f128; : : : ; 131g] . The analysis acts similarly for Line 21,
leading to the overall summary [p17!f128; : : : ; 135g].
Next, POA examines des3_decrypt_public_ossh .
The memory accesses on Lines 9 and 10 are ignored because
the analysis cannot know whether they refer to scalar local
variables or to Ô¨Åelds of a local struct (as in our example).
On Line 11, the address of var4 is loaded into ecx and
placed onto the top of the stack, which corresponds to passing
&var4 as the Ô¨Årst parameter to des_cbc3_decrypt . At
the call site at Line 13, the analysis retrieves the summary for
the called function, sees that there is a non-trivial set for the
Ô¨Årst parameter, and uses the information from the summary to
conclude that var4 is at least 136 bytes.
The information inferred by the POA is used to modify the
IR used by CodeSonar/x86 by merging the three objects at
esp,esp+128 , and esp+132 , creating a 136-byte structure.This corrects the data-boundary information and eliminates
the spurious warnings. (CodeSonar/x86 currently only looks at
overruns of an entire top-level object and not Ô¨Åelds, so the fact
that the resulting object is a structure instead of a monolithic
object is currently ignored.)
III. D ATA-DELINEATION ANALYSIS
Data-delineation analysis is comprised of three steps:
Step 1: Extract a superset of potential object boundaries.
Step 2 (POA): Identify a set of aggregate objects.
Step 3: ReÔ¨Åne the set of object boundaries identiÔ¨Åed in Step 1
by eliminating boundaries that fall within any of the
aggregate objects identiÔ¨Åed in Step 2.
The main contribution of this paper is the analysis for
performing Step 2 above. Steps 1 and 3 are likely to be speciÔ¨Åc
to the clients of the overall data-delineation analysis.
A. Initial Object-Boundary IdentiÔ¨Åcation
The identiÔ¨Åcation of the initial set of object boundaries is
likely to be tied to the implementation speciÔ¨Åcs of a DDA
client. For instance, many binary analysis tools use the IDA
Pro disassembler for initial processing of an executable and
may adopt the sets of object boundaries identiÔ¨Åed by IDA
Pro; CodeSonar/x86 uses IDA Pro along with other sources of
information to compute its superset of object boundaries.
In addition to CodeSonar/x86, we have a standalone imple-
mentation of DDA. That implementation does not explicitly rely
on IDA pro, but instead uses a heuristic that we believe captures
the spirit of IDA Pro‚Äôs object-boundary identiÔ¨Åcation; we call
this the Constant-Offsets Heuristic. To identify a superset of
local-object boundaries, our heuristic scans each function‚Äôs
instructions looking for dereferences of the form reg+c,
147
147
147
147
ICSE 2015, Florence, Italywhere regis the stack or frame pointer ( esp orebp on x86)
andcis a constant. For each such access, we add an object
boundary derived from c.
B. Parameter-Offset Analysis
Parameter-Offset Analysis (POA) is the main contribution of
this paper. The analysis operates by identifying base addresses
of aggregate objects and collecting sets of constant offsets
that are used in memory dereferences in conjunction with
each base address. The collected sets of offsets are used to
estimate objects‚Äô sizes. This section describes how the analysis
collects and propagates the offsets, how the base addresses are
recognized, and how the resulting set of object sizes is derived.
1) Offset Collection and Propagation: The analysis proceeds
bottom-up through the call graph of a program constructing a
summary of each function.2Letfbe a function. A summary of
fis a map Mf:P!2Z, where Pis the set of f‚Äôs parameters
andZis the set of integers. The summary maps each parameter
to the set of constant offsets that are used in dereferences of the
parameter‚Äôs value. Consider function des_cbc3_decrypt
in Figure 1: the summary that the analysis constructs for this
function has the form [p17!f128; : : : ; 135g] . This captures
the fact that the Ô¨Årst parameter of the function is used as a
base address with offsets 128‚Äì135 dereferenced.
To Ô¨Ånd instructions that dereference pointers passed in pa-
rameters, the analysis uses intraprocedural symbolic execution.
Symbolic execution starts at the function entry point with a
state in which parameter locations are initialized with symbolic
constants. (In x86 code, the parameters are either placed on
the stack above the return address or passed in general-purpose
registers.) For expediency, we perform symbolic execution
of all paths in a spanning tree of each function‚Äôs CFG. This
approximation greatly speeds up the analysis and had very
little effect on analysis precision in our experiments.3
We recognize four major sources of offset information:
Explicit dereferences. We check the symbolic value of the
dereferenced memory address. If the address has the form
pi+c, where piis a symbolic constant that corresponds
to a parameter and cis a constant value (which may
vacuously be zero) and where kis the size of the access,
the summary of the function is extended as follows:
Mf=Mf[pi7!Mf(pi)[fc; c + 1; :::; c +k 1g]
Function calls. A parameter may be dereferenced by a callee
of a function if it is passed transitively. At each call site,
we check the symbolic values of each parameter to be
2To handle call-graph cycles due to recursion, our implementation ignores
back edges; in such cases, summaries of callees may not be available when
needed. In our experiments, we have observed only a few cases of imprecision
due to this decision. The precision may be recovered by iteratively repeating the
analysis of the functions in strongly-connected components of the call-graph,
but we have not implemented this.
3We believe that the precision of the analysis is rarely affected by this
simpliÔ¨Åcation because the analysis collects offsets that appear as literal
constants in program‚Äôs text and, thus, are not affected by loops.passed to the callee. If the value of callee parameter jis
of the form pi+c, the summary is updated as follows:
Mf=Mf[pi7!Mf(pi)[translate (Mg(pj); c)]
where translate (S; c) =fs+cjs2SgandMgis the
summary of the callee.
Buffer-manipulation library calls. Calls to standard buffer
and string manipulation functions (e.g., memset and
strncpy ) may dereference parameter values. For func-
tions that take an explicit length, POA checks if that length
is a syntactic constant; if so, POA considers it trustworthy.
(This will arise, for example, when sizeof is used.)
At call sites to these buffer functions, POA inspects the
symbolic values of these parameters. If the buffer address
has the form pi+cand the length parameter has a constant
value l, we extend the summary as follows:
Mf=Mf[pi7!Mf(pi)[fc; c + 1; :::; c +l 1g]
Hardware-assisted loop instructions. The x86 instruction set
contains several instructions that are executed repeatedly
in a hardware-induced loop until a certain condition is met.
For instance, rep stos writes the value from register
eax to the memory word addressed by the destination
register edi, decrements the counter register ecx, updates
the address in edi based on the direction Ô¨Çag df, and
repeats until the value in the counter register becomes
zero. For each such instruction, we inspect the symbolic
values of source and destination registers, counter register,
and direction Ô¨Çag. If the counter register and direction
Ô¨Çag have constant values kanddrespectively, and source
or destination register has the symbolic value pi+c, we
update the summary as follows:
Mf=Mf2
4pi7!Mf(pi)[8
<
:c+iabs(i)< k
^
sign(i) = d9
=
;3
5
2) Identifying Base-Address Construction Points: This anal-
ysis phase maps base addresses of objects to sets of offsets
that are used in dereferences of those base objects. For each
function and for the global data region, the analysis computes
a map with signature Z!2Z. We will use Lfto denote the
map for function fand denote the global map as LG.
This analysis phase is similar to the offset-collection analysis,
but instead of symbolic parameter constants we look for global
and local addresses. For instance, at each call site, we inspect
the symbolic values of arguments that are being passed to the
callee g; if the value of parameter jis an address and Mg(pj)
is a non-empty set, we update the maps as follows:
The parameter value is a global address, A.The global map
is updated:
LG=LG[A7!LG(A)[Mg(pj)]
The parameter value is a local address, sp+C,where spis
the symbolic value of the stack pointer at function entry.
We update the map for the analyzed function as follows:
Lf=Lf[C7!Lf(C)[Mg(pj)]
148
148
148
148
ICSE 2015, Florence, ItalyCalls to buffer-manipulation functions and invocations of
hardware loop instructions are treated similarly. Explicit
memory dereferences, however, are skipped ‚Äì they would
only yield primitive-type objects whose boundaries are already
picked up by the the initial object-boundary identiÔ¨Åcation.
In our implementation, we simpliÔ¨Åed the above approach
slightly: we seeded the symbolic execution with a Ô¨Åxed initial
value for the stack pointer. This speeds up the analysis as
it opens up more opportunities for constant folding during
symbolic execution; also, it simpliÔ¨Åes handling of local memory
accesses because symbolic local addresses are reduced to inte-
ger constants. As with the previously described approximations,
no ill effects have been observed as a result.
Local-Offset Analysis. In our experiments, we observed a
handful of cases where, instead of Ô¨Çat addressing relative to
the frame pointer, the elements of a local struct are accessed
by Ô¨Årst loading the base address of the struct into a register
and then using Ô¨Åeld offsets to make an actual dereference. The
following example illustrates this:
struct S s, *p;
p = &s;
p->x = 5;1: lea eax,[ebp-0x28]
2: mov DWORD PTR
[eax+0x20],0x5
The analysis described above does not recover accurate sizes
for such objects because of constant folding performed during
symbolic execution. For the example above, the symbolic value
of the dereferenced address is reduced to ‚Äú ebp 0x8‚Äù, losing
information about the object‚Äôs base address.
To account for such cases, we extended the analysis as
follows: if an instruction assigns an address of a local variable
(i.e., a symbolic value sp+C) to a register, we replace the value
of that register with specially constructed symbolic constant
lC. At the places where offset sets are collected (memory
dereferences, function calls, library calls, and hardware-assisted
loops), we check if the dereferenced address has the form lC+d,
and if so, we update the Lfmapping for Caccordingly. For
the example above, at line 1, the extended analysis puts a
symbolic constant l28intoeax. Thus, at line 2, the analysis
is able to infer that a local object at address ‚Äú ebp 0x28 ‚Äù is
dereferenced with a constant offset 0x20 and update the size
of the object accordingly.
3) Aggregate Object Extraction: The Ô¨Ånal step in our
analysis is to extract the actual objects from the L-maps
described above. The process we follow is trivial: for each
mapping in the Lmap, we extract the set of offsets and
determine the starting address of the object (note that offsets in
the set may potentially be negative) and its extent. The objects
that overlap are merged together.
IV. DDA A CCURACY EVALUATION
In this section, we describe our evaluation of the accuracy
of the boundaries inferred by DDA. We applied our standalone
implementation of the analysis to a number of real-world x86
programs. Table I presents the results. The Ô¨Årst block in the
table shows the results for Coreutils binaries (100 small utilities
for basic Ô¨Åle, shell, and text manipulation). We analyzed the
Coreutils suite at various optimization levels to investigatethe effect of optimization on DDA‚Äôs results. The next two
blocks of benchmarks in the table are larger C programs and
C++ programs, respectively, compiled without optimization.
All benchmarks were built on Ubuntu 12.04 with GCC 4.6.3.
Evaluation Methodology. We compared the set of inferred
objects to ground truth as deÔ¨Åned by the debugging infor-
mation emitted by GCC. In this set of experiments, we only
concerned ourselves with local variables. In addition, we only
compare the parts of each activation record that correspond to
explicit variables in the source; function frames typically store
additional data, such as compiler-introduced temporaries and
spilled register values, that DDA will infer information about
but which has no associated debug information.
There are two types of imprecision our analysis yields. False
positives correspond to inferred object boundaries that do
not have counterparts in the ground truth. False negatives
correspond to ground-truth object boundaries that are missed
by the analysis. We measure both of these:
Precision: is a measure of how many spurious boundaries the
analysis infers (i.e., a measure of false positive rate).
Recall: is a measure of how many true objects the analysis
misses (i.e., the measure of false negative rate).
We use the following formulas to compute the two metrics. Let
Mdenote the number of object boundaries that the analysis
correctly identiÔ¨Åed, FP denote the number of false positives,
andFN denote the number of false negatives. Also, let GT=
M+FN denote the number of ground-truth object boundaries.
Precision =GT
GT+FP100% Recall =M
GT100%
The two metrics must be used together to assess the accuracy
of the analysis: for an accurate analysis, both precision and
recall should be close to 100% . Neither statistic tells the whole
story: e.g., Ô¨Ånding no boundaries yields 100% precision but 0%
recall; similarly, infering that each byte in the activation record
is a separate object yields 100% recall but low precision.
Analysis Results. Tab. I presents the experimental evaluation
of our analysis. We report both precision (columns on the
left) and recall (columns on the right) for several different
analysis conÔ¨Ågurations. CO shows the results for the Constant
Offsets heuristic from Sect. III-A (i.e., when no POA is used).
This data represents a good baseline for the evaluation of
the analysis: it shows the lowest obtainable precision and
the highest obtainable recall for boundary identiÔ¨Åcation. We
also show the results obtained by using standard IDA Pro
mechanisms for detecting local variables. Note that IDA Pro
results are generally comparable to those of constant-offset
heuristic. IDA Pro sports slightly higher precision than constant-
offset heuristic, which is due to IDA Pro‚Äôs use of FLIRT
for recognizing library calls and using that information to
infer types for some of the variables. Surprisingly, IDA Pro‚Äôs
recall is slightly lower. Our investigation showed that it was
caused by IDA Pro‚Äôs failure to recognize variables in function
main(...) for some of the benchmarks, possibly due to the
presence of stack-alignment operations.
149
149
149
149
ICSE 2015, Florence, ItalyTABLE I: A NALYSIS EVALUATION . THE‚ÄúVARS‚ÄùCOLUMN SHOWS THE NUMBER OF LOCAL VARIABLES IN THE GROUND TRUTH DATA . COLUMN IDA
SHOWS THE MEASUREMENTS FOR IDA P RO OBJECT DETECTION . COLUMN CO SHOWS MEASUREMENTS FOR THE CONSTANT OFFSETS HEURISTIC . THE
REMAINING COLUMNS SHOW HOW THOSE MEASUREMENTS ARE IMPROVED WITH THE USE OF ADDITIONAL POA HEURISTICS . COLUMN DEREF SHOWS
WHAT HAPPENS IF AGGREGATE OBJECTS ARE IDENTIFIED BASED ON EXPLICIT DEREFERENCES ONLY . COLUMN +LOC.SHOWS HOW MEASUREMENTS
IMPROVE IF THE LOCAL OFFSET EXTENSION IS ENABLED . COLUMN +LIB SHOWS THE EFFECT OF TAKING BUFFER -MANIPULATION FUNCTIONS INTO
CONSIDERATION . COLUMN ALL SHOWS THE MEASUREMENT FOR THE FULL -SCALE DATA -DELINEATION ANALYSIS . FINALLY ,COLUMN +64B IT SHOWS THE
DDA RESULTS ARE AFFECTED BY A SIMPLE HEURISTIC FOR DETECTION OF 64-BIT INTEGERS .
PRECISION (%) RECALL (%)
Benchmark Vars IDA CO D EREF +LOC. +L IB ALL +64B IT IDA CO D EREF +LOC. +L IB ALL +64B IT
Coreutils 214 81.64 80.99 87.40 87.42 88.17 88.23 94.36 95.00 98.94 98.94 98.93 98.91 98.91 97.66
Coreutils (-O) 76 59.03 56.41 72.66 72.66 74.32 74.45 85.37 77.23 86.01 85.96 85.97 85.86 85.86 84.29
Coreutils (-O2) 86 38.98 37.86 54.75 54.75 55.72 55.80 77.96 74.79 82.08 80.57 80.57 80.48 80.48 80.16
grep 1043 86.63 86.48 92.55 92.55 93.29 94.22 96.93 98.37 99.81 99.81 99.81 99.71 99.71 99.33
irssi 4635 98.16 97.99 98.49 98.49 99.02 99.02 99.34 97.78 97.78 97.78 97.78 97.73 97.73 96.63
nginx 1056 52.35 50.99 77.59 77.59 80.92 86.35 91.43 99.62 99.91 99.91 99.91 99.91 99.91 99.05
tcpdump 588 59.33 57.53 67.82 67.82 69.10 72.86 80.33 96.43 99.83 99.83 99.83 99.66 99.66 97.96
wget 1954 88.02 85.36 87.66 87.66 91.44 91.91 95.78 99.90 99.85 99.85 99.85 99.64 99.64 98.41
zsh 3884 91.32 90.43 91.67 91.67 94.41 94.66 96.86 99.95 99.95 99.92 99.92 99.79 99.79 98.56
average 2193 79.30 78.13 85.96 85.96 88.03 89.84 93.45 98.68 99.52 99.52 99.51 99.41 99.41 98.32
llvm-as 8145 95.41 95.27 96.21 96.21 96.36 96.36 97.93 99.82 99.90 99.89 99.89 99.89 99.89 99.12
llvm-diff 7189 94.38 94.23 95.43 95.43 95.55 95.55 97.40 99.74 99.83 99.82 99.82 99.82 99.82 98.94
llvm-mc 11937 84.55 84.46 88.04 88.04 88.17 88.17 93.48 99.59 99.61 99.60 99.60 99.60 99.60 97.79
llvm-objdump 13682 83.90 83.82 87.49 87.49 87.87 87.87 93.16 99.58 99.60 99.59 99.59 99.59 99.59 97.98
llvm-size 1721 84.45 84.24 90.10 90.10 92.93 92.93 97.45 99.88 99.88 99.88 99.88 99.88 99.88 98.37
doxygen 14351 98.25 98.15 98.61 98.61 98.80 98.80 99.21 99.92 99.98 99.97 99.97 99.96 99.96 98.61
average 9504 90.16 90.03 92.65 92.65 93.28 93.28 96.44 99.76 99.80 99.79 99.79 99.79 99.79 98.47
The subsequent columns show how the results are affected
by using various conÔ¨Ågurations of POA. D EREF shows the
measurements for a variant of POA that relies only on explicit
memory dereferences. +L OC. shows the measurements for
explicit-dereferences-only POA with the Local Offsets Analysis
extension enabled. +L IBshows measurements if calls to
buffer-manipulation functions are also taken into consideration.
Finally, A LLshows the measurements for the complete DDA.
As the data in Tab. I demonstrates, compared to the Constant
Offsets heuristic, our analysis improves the precision of data
delineation by 12% for C programs (by 10% with respect to
IDA Pro) and by 3:2% for C++ programs without signiÔ¨Åcantly
affecting the recall. That is, the use of POA eliminates about
half of the false positives yielded by the Constant-Offsets
heuristic for C programs, and about third of those for C++.
The experiments with the Coreutils show that optimization
signiÔ¨Åcantly decreases the precision of the analysis (though,
the gain compared to the constant-offsets heuristic is increased).
Our investigation showed that the primary culprit is function
inlining: the instances of structs are created and manipulated
locally, and thus POA is not able to identify them.
We examined the false positives and false negatives that our
analysis yields and identiÔ¨Åed several causes.
64-bit ints. In a 32-bit build, GCC uses two 32-bit words that
are manipulated separately to implement 64-bit integer types.
Thus, our analysis is not able to connect the two words. This
category accounts for the majority of false positives we saw in
our benchmarks. To estimate how much this category of false
poitives affects the analysis precision, we implemented a simple
heuristic for detecting 64-bit integers. The heuristic identiÔ¨Åes
pairs of adjacent words in each stack frame that are always
read or written together within a basic block and marks themas 64-bit words. The column +64B ITshows how applying
this simple heuristic affects the overall results of DDA. On
average, the heuristic removes about half of the remaining false
positives. However, it also has an effect (sometimes sizable) on
the analysis recall. Additional work is needed to make 64-bit
integer detection more precise.
Incomplete IR. The standalone DDA implementation‚Äôs re-
construction of program‚Äôs intermediate representation is not
yet complete and does not always recover the entire control
Ô¨Çow of a program. In particular, indirect control transfers pose
a challenge: indirect function calls and control Ô¨Çow due to
jump tables is not always properly resolved. This causes both
false negatives and false positives.
Passing structures by value. Our techniques are geared
towards programs that pass aggregate objects by reference
and yields false positives when they are passed by value.
Infeasible paths. We have seen several examples in which
POA over-estimated the size of objects because the summary it
computed for a function included information about paths that
were infeasible in some of that function‚Äôs calling contexts. (For
example, consider a function that takes a pointer to objects of
varying size and adjusts its behavior based on object‚Äôs dynamic
type. For such function, POA may compute a summary that
maps the parameter to the size of the largest type it accepts,
even though some call sites pass smaller objects.)
Local objects. If a buffer is used only locally the compiler
never generates an access through a base pointer, our analysis
will not be able to identify it.
These shortcomings of the analysis remain to be addressed
in our future work.
150
150
150
150
ICSE 2015, Florence, ItalyTABLE II: C ODESONAR /X86 WARNING SUMMARY INFORMATION .F.O.
STANDS FOR FRAMES ONLY AND O .O.FOR OBJECT OVERRUN . THE COLUMN
#GIVES THE NUMBER OF BINARIES MEASURED . THE DATA SHOWN HERE
ARE NORMALIZED TO THE TOTAL NUMBER OF NO DDA /OBJECT OVERRUN
WARNINGS IN THE RESPECTIVE CATEGORY (MATCHED OR BINARY -ONLY ).
TP PROXY FP PROXY
(higher is better) (lower is better)
NO DDA DDA NO DDA DDA
Benchmark # F.O. O.O. O.O. F.O. O.O. O.O.
Windows Dbg. C 29 0.6 0.9 0.6 0.2 4.8 1.2
Windows Dbg. C++ 3 0.0 0.0 0.0 0.3 5.3 2.3
Windows Debug 32 0.6 1.0 0.6 0.5 10.1 3.5
Windows Rls. C 29 0.4 0.7 0.6 0.3 6.3 1.9
Windows Rls. C++ 3 0.0 0.0 0.0 0.2 13.6 0.9
Windows Release 32 0.4 0.7 0.6 0.5 19.9 2.9
All Windows 64 0.9 1.7 1.2 1.0 30.1 6.4
Linux 4 0.0 0.1 0.1 0.0 0.2 0.1
All 68 1.0 1.8 1.3 1.0 30.3 6.5
V. S TATIC BUFFER -OVERRUN DETECTION EVALUATION
In this section, we present our evaluation of the effect of DDA
on CodeSonar/x86‚Äôs ability to Ô¨Ånd buffer overruns. We Ô¨Årst
present an brief overview of our heuristic static-analysis tool
CodeSonar/x86. We then describe our evaluation methodology,
followed by the results.
CodeSonar Overview. CodeSonar is GrammaTech‚Äôs com-
mercial tool that specializes in static defect detection [ 20].
CodeSonar was originally developed for C and C++ programs,
but has been retargeted to also work on machine code.
Regardless of the language, CodeSonar uses heuristic analyses
to Ô¨Ånd a diverse set of defects including memory-safety errors
and API misuses.
The machine-code version of CodeSonar begins with front-
end analyses that build an IR of the program. It uses IDA
Pro for disassembly and initial IR inference, but adds many
additional advanced analyses to increase the precision of the
recovered IR. The DDA implementation resides in the front
end because the IR contains information about the objects
present in a program.
The CodeSonar back end then analyzes the IR to determine
potential defects. The IR that the back end uses is common
between the different source and binary front ends. The back
end‚Äôs analyses are heuristics that scale to very large, industrial-
sized programs.
Evaluation Methodology. As a portion of CodeSonar/x86‚Äôs
routine testing, we analyze several dozen open-source programs
to watch for unexpected changes in the reported warnings.
The number of programs and number of warnings are large
enough that we cannot manually classify each warning to
determine whether it is a true positive or a false positive.
Instead, we use a proxy for these measurements.
The evaluation procedure for CodeSonar/x86‚Äôs warnings
proceeds as follows:
1)We start with the source version of a program, and build
it to create a binary.2)We run CodeSonar/C/C++ on the source version of the
program to produce a list of source warnings.
3)We run CodeSonar/x86 on the binary to produce a list of
binary warnings.
4)For each binary warning produced by Step 3, we (auto-
matically) classify it into one of three categories:
Matched Warnings: The binary warning appears to be the
same as some source warning; these warnings are our
proxy for the true positives in the binary analysis.
Binary-Only Warnings: The binary warning is not the
same as any source warning, but is warning about a
location in the program‚Äôs source; these warnings are
our proxy for false positives.
Out-Of-Scope Warnings: The binary warning was in an
external library (e.g., the C runtime) rather than appli-
cation code; these warnings are ignored for purposes
of estimating warning accuracy.
Finding correspondences between warnings (Step 4) is done by
using debugging information for the binary to get the source
Ô¨Åle and line number of each binary warning, then looking for a
source warning of the same type on the same source line. Note
that the use of debugging information in this process is only
during the evaluation of the results and not during analysis.
We use this measure because CodeSonar/C/C++ is a leading
static-analysis tool [ 22], and thus we trust the warnings it
produces to be a reasonable approximation to ground truth. If
CodeSonar/x86 Ô¨Ånds a warning that CodeSonar/C/C++ did not
Ô¨Ånd or vice versa, we expect the chance that it is caused by
imprecise IR recovery (relative to the source) to be much higher
than the chance that the binary analysis actually did a better
job ‚Äì though this is by no means guaranteed.4Out-of-scope
warnings correspond to portions of the binary for which there
was no source and thus the source analysis had no opportunity
Ô¨Ånd the warnings; we believe excluding them results in a more
apples-to-apples comparison.
CodeSonar/x86 supports two modes of operation for Ô¨Ånding
buffer overruns. The Ô¨Årst mode looks for overruns only of
entire stack frames and heap blocks. The second mode looks
for overruns of individual objects as well ‚Äì it can Ô¨Ånd an
overrun from one object to another within a stack frame and
from one global to another. The Ô¨Årst mode we call FRAME
ONLY (despite it Ô¨Ånding heap overruns too); the second we call
OBJECT OVERRUNS . Until our implementation of the analyses
described in this paper, the OBJECT OVERRUN version was not
practical to run on real examples, as the false positive rate was
too high. We present data for the following conÔ¨Ågurations:
FRAME ONLY /NO DDA This conÔ¨Åguration serves as a baseline
for the results in this section.
OBJECT OVERRUN /NO DDA The improvement to true positives
relative to FRAME ONLY /NO DDA illustrates the beneÔ¨Åt
4Indeed, one motivation behind producing a binary version of CodeSonar is
to make it possible to Ô¨Ånd ‚ÄúWYSINWYX‚Äù (What You See Is Not What You
eXecute) problems [ 23], where defects and vulnerabilities only arise because
of compiler transformations or low-level implementation decisions.
151
151
151
151
ICSE 2015, Florence, Italyto consider intra-frame overruns; the increase in false
positives shows the cost.
OBJECT OVERRUN /DDA Relative to OBJECT OVERRUN /NO
DDA, the drop in false positives represents the improve-
ment to warnings brought about by better delineation of
stack objects. The drop in true positives represents cases
where DDA is too aggressive in eliminating boundaries.
For all of the reported conÔ¨Ågurations, we disabled an
additional warning-pruning heuristic that is enabled by default
in CodeSonar/x86, called the ‚Äúscalar guard.‚Äù As a result, the
number of false-positive warnings reported in this paper are
higher (sometimes signiÔ¨Åcantly) than what a typical user
of CodeSonar/x86 would currently see. The scalar guard
suppresses any non-heap buffer-overrun warning where the
object being overrun is four bytes or less. The are two reasons
we disable the scalar guard for these experiments:
Our long term plan is to disable the scalar guard. The
scalar guard suppresses a vast majority of warnings:
both false and true warnings. Prior to DDA, the scalar
guard was the only way to enable OBJECT OVERRUNS
without an overwhelming number of false positives,
even if did cause many true candidates to be dropped.
DDA was improved and incorporated into CodeSonar/x86
speciÔ¨Åcally to support the goal of allowing us to disable
the scalar guard.
The scalar guard interacts with DDA in unexpected ways.
In particular, even though the better object boundaries
found through DDA ‚Äúshould‚Äù strictly reÔ¨Åne the presented
warnings, the number of warnings would sometimes
increase with DDA enabled because it increases the size
of an aggregate beyond four bytes. The results are not
worse because we gain true positives that the scalar guard
suppressed, but it makes evaluating the effects of DDA
more difÔ¨Åcult. Disabling the scalar guard eliminates this
interaction and leads to a much clearer picture of the
effects of better data delineation.
Buffer-Overrun Detection Results. We ran CodeSonar/x86
on 68 subject binaries. Most of them ‚Äì 64 binaries ‚Äì are
Windows programs and libraries, and the remaining 4 are
Linux programs. Each Windows test is compiled twice, once
in debug mode (no optimization, but still ignoring debugging
information) and once in release mode (optimized). The four
Linux binaries are compiled from separate programs; all four
were optimized. The increase in analysis time to run DDA is
negligible in all cases.
Tab. II show summary data across our benchmark set;
Tab. III show full results and more information. For purposes
of evaluating DDA, we are interested in the change in the
numbers more than the absolute values.
There is a noticeable increase in the number of matched
warnings when we allow object overruns: the total number of
matched warnings across the suite almost doubles from the
FRAME ONLY /NO DDA conÔ¨Åguration to OBJECT OVERRUN /NO
DDA. However, OBJECT OVERRUN comes at a cost: the number
of binary-only warnings climbs by about 30x.However, turning on DDA helps substantially. The number
of false positives is cut by almost a factor of 5, while the
proportion of lost true positives is not much more than 1=4. In
other words, DDA allows us to retain most of the beneÔ¨Åt of
being able to Ô¨Ånd OBJECT OVERRUNS , while at the same time
dramatically reducing the number of false positives.
Interestingly, particularly in light of the results described
in Sect. IV, DDA seems to both help more and hurt less
on optimized executables. Comparing the ‚ÄúWindows Debug‚Äù
vs. ‚ÄúWindows Release‚Äù measures, we see that CodeSonar/x86
retains 85% of the true positives in the optimized binaries
when DDA is enabled vs. only 63% of the true positives for
the debug build. At the same time, DDA eliminates 86% of
false positives in the release binaries vs. only 56% of them
in the debug binaries. Considering that the set of programs
and libraries are the same across the two sets of runs, it is not
clear why this happens. However, it is encouraging in terms
of real-world applicability, as we believe optimized code is of
the most real-world interest.
Secondary Effects on Other Warnings. Our work on
integrating DDA into CodeSonar/x86 was driven by the desire
to improve reporting of buffer overruns. Unexpectedly, we saw
beneÔ¨Åts to other warning classes as well. For example, consider
the following code snippet:
1 struct { int x, *y; } object;
2 memset(&object, 0, sizeof(object));
3 printf("%d", *object.y + object.x);
Without DDA, the CodeSonar/x86 front end breaks up the
memory containing object into two variables because there
are explicit uses of both of its Ô¨Åelds on Line 3. CodeSonar
treats the call to memset as performing an 8-byte write into
the variable corresponding to object.x , which is only 4
bytes, and reports a buffer overrun on Line 2.
However, CodeSonar also reports another ‚Äúproblem.‚Äù In part
to increase scalability, CodeSonar does not track the effects of
illegal memory accesses such as the reported buffer overrun.
As a result, CodeSonar does not consider the memset call
to have initialized object.y , and it reports a ‚Äúuse of an
uninitialized variable‚Äù warning on Line 3 for object.y.
DDA allows the CodeSonar/x86 front end to infer that the
memory belonging to object is all one object. As a result,
CodeSonar‚Äôs IR sees an 8-byte memset of an 8-byte buffer, and
thus there is no overrun. CodeSonar is also able to determine
thatobject.y has been initialized, and as a result the ‚Äúuse
of an uninitialized variable‚Äù warning is also removed.
In addition, CodeSonar/x86 without DDA misses reporting
the null-pointer dereference on Line 3, because it does not
know that object.y has been set to 0. With DDA enabled,
CodeSonar/x86 understands that object.y is initialized to
null and reports a warning.
In summary, without DDA CodeSonar/x86 experiences:
A false-positive buffer-overrun warning on Line 2
A false-positive uninitialized-variable warning on Line 3
A false-negative null-pointer dereference on Line 3
Enabling DDA Ô¨Åxes all three problems.
152
152
152
152
ICSE 2015, Florence, ItalyVI. R ELATED WORK
Our parameter-offset analysis was inspired by the Howard
tool [ 24,25]. However, there are some important differences
between the two tools. Howard is a dynamic analysis, and
requires a test suite of (a) benign inputs that (b) collectively
exercise all potential accesses of aggregate data types. Because
DDA is a static analysis, it does not require a high-coverage
test suite. Further, Howard does not honor our position to
trust only syntactic constants. Howard infers some of the
internal structure of objects as well as information about arrays.
Our implementation Ô¨Ånds some of this information too (e.g.,
it determines information about nested structures in similar
circumstances as Howard), but because we do not currently
need this information for our applications, we discard it.
Lin, Zhang, and Xu [ 26] presented a different dynamic
analysis called Rewards. Rewards is primarily focused on
propagating type information from type sinks (e.g. library or
system calls) backwards and forward to locations that held or
will hold a value of the same type; it does not appear to Ô¨Ånd
the size of aggregate objects other than those that are passed
to a known function in such a manner.
Jin et al. presented a technique for recovering information
about what C++ classes and objects are present in a binary [ 27].
Their tool, Objdigger, uses interprocedural symbolic execution
to track allocations of objects, looking at how they are passed
to functions that use the ‚Äúthiscall‚Äù calling convention (passing
this in the register ecx). Objdigger also recovers some
information about the layout of objects based on uses within
these functions. To this extent, our work resembles theirs.
However, our goals are also very different, and this leads
each analysis to infer several things that the other cannot. For
example, Objdigger is much less Ô¨Çexible in the kinds of patterns
it recognizes, both in terms of only tracking objects through
thiscall functions and in the fact that Objdigger isn‚Äôt
prepared to learn anything from buffer-manipulation functions.
Lee, Avgerinos, and Brumley present a technique, TIE, for
performing type inference on a binary [ 28]. While we could
probably proÔ¨Åt from the kind of information it computes in
other scenarios, TIE both does much more than we need and
yet does not quite match our goal. TIE tries to compute actual
type information (e.g., signed/unsigned integers vs. pointers)
whereas all we need is the locations and sizes of objects. At
the same time, it appears that TIE would, at least as stated,
have the soundness problem mentioned in the introduction: if
a program can overrun a buffer, it seems that TIE would just
infer a larger buffer size. (It would probably be possible to
modify TIE to honor our ‚Äúonly constants are trustworthy‚Äù rule.
However, if you do not need the full power of TIE, we think
that our technique is simpler to understand and implement.)
Balakrishnan and Reps present a technique, DIVINE, for
statically recovering object information from a binary [ 19],
which is a novel combination of Value-Set Analysis (VSA) [ 29]
and a ported version of Ramalingam et al.‚Äôs Aggregate Structure
IdentiÔ¨Åcation (ASI) [18] from COBOL to x86 machine code.Interestingly, the goal of DIVINE in some cases is the
opposite of our needs: a crude description is that DIVINE
sometimes attempts to separate, e.g., Ô¨Åelds of objects so
that separate VSA abstract values can be tracked for each
Ô¨Åeld (leading to more precise VSA results). ASI‚Äôs role in
DIVINE is to Ô¨Ånd opportunities for summarization, but it is
at a different level than is helpful for us. In addition to the
different goals, DIVINE has the soundness problem discussed
in the introduction ‚Äì it infers the objects based on the program‚Äôs
access patterns, and thus if the program is incorrect so will
the inferences be.5
VII. F UTURE DIRECTIONS
In this paper, we presented a static analysis for inferring
the locations and sizes of global and local data in an arbitrary
stripped executable, while avoiding the trap of choosing a
‚Äúsound‚Äù technique that will infer objects that make buggy
programs look correct. The inferred data layout information
allows a number of existing techniques for ensuring memory
safety to be applied effectively in the absence of source code.
Our evaluation of the analysis showed that it achieves good
precision at low cost. We used the data inferred by our analysis
to signiÔ¨Åcantly improve the precision of static buffer overrun
detection in the defect-detection tool CodeSonar/x86.
In the future, we plan to further enhance DDA. The current
work focuses primarily on detecting the layout of top-level
objects and ignores their internal structure. We believe that
our approach can be extended in a straightforward fashion to
infer information about the internal structure of program data,
for example structure Ô¨Åelds that are themselves structures. (As
mentioned before, we compute and discard information that
naturally leads to Ô¨Ånding internal structure.) Once we have
information about the internal structure, there is the potential
for Ô¨Ånding overruns of the subobjects itself. The CodeSonar
back end has support for Ô¨Ånding warnings of this type in source
code, though doing the same thing for binaries would require
non-trivial extensions even once the internal structure is known.
Another improvement to the analysis that we are considering,
is a more sophisticated tracking of offsets from base pointers.
Currently, the analysis collects sets of constant offsets. Extend-
ing the tracking to support symbolic offsets will improve the
precision of the analysis by allowing it to model naturally
functions that are similar to memset andmemcpy (e.g.,
program-speciÔ¨Åc wrappers of those functions).
Finally, most of our effort during the integration of DDA
into CodeSonar/x86 was spent on reducing the number of
binary-only warnings (FP proxy) with little attention paid to
the matched warnings (TP proxy) that we were dropping at
the same time. We would like to return to the lost matched
warnings and either make sure that they are being dropped for
a good reason or determine what we can do to retain them
without undermining the reduction in FPs.
5VSA can be run within the CodeSonar/x86 front end, though it was not
enabled for our tests. In addition, the DIVINE implementation would not
actually create a larger object in CodeSonar/x86‚Äôs IR in the presence of an
overrun ‚Äì the ASI results would not be incorporated in that way.
153
153
153
153
ICSE 2015, Florence, ItalyTABLE III: D ATA FOR CODESONAR /X86EXPERIMENTS . FOR SUMMARY LINES , ‚Äú#‚Äù GIVES THE NUMBER OF TESTS
SUMMARIZED . ‚ÄúINSTRS ‚ÄùIS THE NUMBER OF INSTRUCTIONS , ‚ÄúFUNCS ‚ÄùIS THE NUMBER OF FUNCTIONS ,AND ‚ÄúTIME ‚ÄùIS
THE NUMBER OF SECONDS SPENT IN POA. TP AND FP COLUMNS GIVE THE NUMBER OF MATCHED AND BINARY -ONLY
WARNINGS ,RESPECTIVELY (OUR PROXIES FOR THE NUMBER OF TRUE AND FALSE POSITIVES ).DEFAULT BOUNDARIES DDA
FRAME ONLY OBJECT OVERRUN OBJECT OVERRUN
Benchmark # instrs funcs time TP FP TP FP TP FP
bzip2 52,188 564 12 0 0 0 270 0 75
DXSDK.Tutorial00 29,450 439 6 0 16 0 51 0 47
freeglut-2.6.0-VS9.Fractals 3,360 58 1 0 1 1 14 1 14
freeglut-2.6.0-VS9.freeglut 121,066 1,608 27 0 31 0 274 0 86
freeglut-2.6.0-VS9.Lorenz 3,375 62 0 0 1 0 13 0 11
freeglut-2.6.0-VS9.shapes 4,940 83 1 0 1 0 10 0 10
glut 56,206 815 14 15 54 15 280 8 118
libidn-1.9-VS8 9,350 137 3 2 2 2 17 2 17
libogg 33,199 504 8 0 7 0 42 0 38
libpng-1.4.0-win 58,032 418 15 3 12 6 269 0 25
miniupnpc-1.4.20100609-VS9 10,135 109 4 0 10 0 28 0 19
miranda 81,366 780 20 1 6 1 410 1 37
putty.pageant 61,130 555 16 0 8 0 269 0 115
putty.plink 121,509 1,071 37 2 12 5 359 2 170
putty.pscp 129,723 1,194 38 2 10 5 543 1 191
putty.putty 180,243 1,467 80 3 22 5 713 1 258
Python-2.1.3-win 206,617 2,395 80 12 104 31 1,297 28 358
quakeIII 341,134 3,759 159 0 66 29 2,484 10 509
repeater 30,466 373 8 0 7 2 46 2 31
sphinx.sphinx2-allphone 94,793 926 29 30 22 40 290 32 102
sphinx.sphinx2-batch 94,726 926 30 28 21 37 292 30 102
sphinx.sphinx2-client 95,763 938 31 29 21 37 296 31 96
sphinx.sphinx2-server 101,173 989 30 28 21 37 292 30 100
vpx-win-8.ivfenc 88,096 812 19 1 13 1 310 1 77
vpx-win-8.vp8-set-maps 85,680 795 17 1 13 1 320 1 74
xmail 145,910 1,597 60 42 57 62 1,371 18 107
yasm-1.0.1-VS10-x86.vsyasm 242,185 2,647 95 2 1 2 518 1 78
yasm-1.0.1-VS10-x86.yasm 242,238 2,647 104 2 1 2 523 2 85
zlib-win 20,900 141 5 1 7 10 125 10 21
Windows Dbg. C 29 2,744,953 28,809 949 204 547 331 11,726 212 2,971
bzip2 30,708 481 7 0 0 0 222 0 46
DXSDK.Tutorial00 6,979 128 1 0 0 0 0 0 0
freeglut-2.6.0-VS9.Fractals 1,333 29 0 0 0 0 4 0 4
freeglut-2.6.0-VS9.freeglut 62,620 1,046 13 0 38 0 230 0 177
freeglut-2.6.0-VS9.Lorenz 1,369 32 0 0 0 0 11 0 11
freeglut-2.6.0-VS9.shapes 1,911 44 0 0 0 0 0 0 0
glut 31,033 656 7 17 7 17 177 17 60
libidn-1.9-VS8 5,431 111 1 0 11 0 19 0 18
libogg 15,847 325 3 0 0 0 3 0 0
libpng-1.4.0-win 36,484 393 8 9 0 11 216 10 35
miniupnpc-1.4.20100609-VS9 5,572 72 1 0 3 0 237 0 3
miranda 79,560 781 18 1 3 1 401 1 32
putty.pageant 37,675 453 7 2 24 2 388 2 123
putty.plink 78,980 967 20 3 35 7 654 4 244
putty.pscp 85,504 1,087 21 4 36 7 788 5 221
putty.putty 118,730 1,361 32 6 89 11 997 8 369
Python-2.1.3-win 163,905 2,339 41 16 171 29 1,576 21 588
quakeIII 233,104 3,386 91 5 90 42 4,241 39 1,036
repeater 17,260 277 4 0 1 2 51 2 39
sphinx.sphinx2-allphone 63,396 892 14 13 23 18 317 19 130
sphinx.sphinx2-batch 63,335 892 13 13 22 18 316 19 130
sphinx.sphinx2-client 64,050 903 14 13 18 19 314 19 125
sphinx.sphinx2-server 67,582 951 14 13 22 19 321 20 130
vpx-win-8.ivfenc 69,526 798 13 1 27 1 371 1 180
vpx-win-8.vp8-set-maps 66,433 779 13 1 27 1 351 1 179
xmail 111,990 1,482 35 4 24 30 2,273 8 525
yasm-1.0.1-VS10-x86.vsyasm 149,851 2,161 32 3 3 4 395 4 130
yasm-1.0.1-VS10-x86.yasm 149,867 2,156 34 3 3 4 391 4 139
zlib-win 12,232 120 3 11 1 11 49 11 11
Windows Rls. C 29 1,832,267 25,102 460 138 678 254 15,313 215 4,685
cryptopp-5.6-VS8 908,684 31,676 442 0 472 0 7,418 0 4,763
shareaza-2.2.1.0 1,117,192 29,060 662 0 136 17 3,070 7 297
tinyCAD-2.50.10 733,561 18,678 385 0 95 1 2,393 1 550
Windows Dbg. C++ 3 2,759,437 79,414 1,489 0 703 18 12,881 8 5,610
cryptopp-5.6-VS8 416,109 11,774 168 0 201 0 20,943 0 996
shareaza-2.2.1.0 644,413 17,306 361 5 42 11 7,803 9 696
tinyCAD-2.50.10 386,418 15,657 182 0 215 1 4,424 1 555
Windows Rls. C++ 3 1,446,940 44,737 711 5 458 12 33,170 10 2,247
Windows Dbg. C 29 2,744,953 28,809 949 204 547 331 11,726 212 2,971
Windows Debug 32 5,504,390 108,223 2,438 204 1,250 349 24,607 220 8,581
Windows Rls. C 29 1,832,267 25,102 460 138 678 254 15,313 215 4,685
Windows Release 32 3,279,207 69,839 1,171 143 1,136 266 48,483 225 6,932
All Windows 64 8,783,597 178,062 3,609 347 2,386 615 73,090 445 15,513
gnuchess-5.07 29,333 239 5 2 1 2 48 4 43
irssi-0.8.14 141,058 2,328 35 1 6 2 217 1 91
naim-0.11.8.3.1 70,044 657 17 9 32 10 154 10 61
wu-ftpd-2.6.2 27,257 201 7 3 6 13 77 9 42
Linux 4 267,692 3,425 64 15 45 27 496 24 237
All 68 9,051,289 181,487 3,673 362 2,431 642 73,586 469 15,750
154
154
154
154
ICSE 2015, Florence, ItalyREFERENCES
[1]C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke,
S. Beattie, A. Grier, P. Wagle, and Q. Zhang, ‚ÄúStackGuard:
Automatic adaptive detection and prevention of buffer-overÔ¨Çow
attacks,‚Äù in Proceedings of the 7th Conference on USENIX
Security Symposium - Volume 7, ser. SSYM‚Äô98. USENIX
Association, 1998, pp. 5‚Äì5.
[2]PaX Team, ‚ÄúAddress space layout randomization,‚Äù http://pax.
grsecurity.net/docs/aslr.txt.
[3]S. Bhatkar, D. C. DuVarney, and R. Sekar, ‚ÄúAddress obfuscation:
An efÔ¨Åcient approach to combat a board range of memory error
exploits,‚Äù in Proceedings of the 12th Conference on USENIX
Security Symposium - Volume 12, ser. SSYM‚Äô03. USENIX
Association, 2003, pp. 8‚Äì8.
[4]S. Andersen and V . Abella, ‚ÄúData execution prevention: Changes
to functionality in Windows XP service pack 2,‚Äù http://technet.
microsoft.com/en-us/library/bb457155.aspx.
[5]T. Chiueh and F. Hsu, ‚ÄúRAD: A compile-time solution to buffer
overÔ¨Çow attacks,‚Äù in ICDCS, 2001, pp. 409‚Äì417.
[6]‚ÄúStack Shield: A ‚Äústack smashing‚Äù technique protection tool for
linux,‚Äù http://www.angelÔ¨Åre.com/sk/stackshield/.
[7]M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, ‚ÄúControl-Ô¨Çow
integrity principles, implementations, and applications,‚Äù ACM
Trans. Inf. Syst. Secur., vol. 13, no. 1, pp. 4:1‚Äì4:40, Nov. 2009.
[8]U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C.
Necula, ‚ÄúXFI: Software guards for system address spaces,‚Äù in
Proceedings of the 7th Symposium on Operating Systems Design
and Implementation, ser. OSDI ‚Äô06. USENIX Association,
2006, pp. 75‚Äì88.
[9]M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, ‚ÄúControl-
Ô¨Çow integrity,‚Äù in Proceedings of the 12th ACM Conference on
Computer and Communications Security, ser. CCS ‚Äô05. ACM,
2005, pp. 340‚Äì353.
[10] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, ‚ÄúPractical control Ô¨Çow integrity and
randomization for binary executables,‚Äù in Security and Privacy
(SP), 2013 IEEE Symposium on. IEEE, 2013, pp. 559‚Äì573.
[11] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, ‚ÄúNon-
control-data attacks are realistic threats,‚Äù in Proceedings of the
14th Conference on USENIX Security Symposium - Volume 14,
ser. SSYM‚Äô05. USENIX Association, 2005, pp. 12‚Äì12.
[12] B. D. Rodes, A. Nguyen-Tuong, J. D. Hiser, J. C. Knight, M. Co,
and J. W. Davidson, ‚ÄúDefense against stack-based attacks using
speculative stack layout transformation,‚Äù in Runtime VeriÔ¨Åcation,
ser. Lecture Notes in Computer Science. Springer Berlin
Heidelberg, 2013, vol. 7687, pp. 308‚Äì313.
[13] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic,
‚ÄúSoftBound: highly compatible and complete spatial memory
safety for C,‚Äù in ACM Sigplan Notices, vol. 44. ACM, 2009,
pp. 245‚Äì258.[14] ‚Äî‚Äî, ‚ÄúCETS: compiler enforced temporal safety for C,‚Äù in ACM
Sigplan Notices, vol. 45. ACM, 2010, pp. 31‚Äì40.
[15] N. Hasabnis, A. Misra, and R. Sekar, ‚ÄúLight-weight bounds
checking,‚Äù in Proceedings of the Tenth International Symposium
on Code Generation and Optimization, ser. CGO ‚Äô12. ACM,
2012, pp. 135‚Äì144.
[16] M. S. Simpson and R. K. Barua, ‚ÄúMemSafe: ensuring the spatial
and temporal memory safety of C at runtime,‚Äù Software: Practice
and Experience, vol. 43, pp. 93‚Äì128, 2013.
[17] ‚ÄúIDA Pro ‚Äì interactive disassembler,‚Äù http://www.hex-rays.com/
idapro/.
[18] G. Ramalingam, J. Field, and F. Tip, ‚ÄúAggregate structure identi-
Ô¨Åcation and its application to program analysis,‚Äù in Proceedings
of the 26th ACM SIGPLAN-SIGACT Symposium on Principles
of Programming Languages, ser. POPL ‚Äô99. ACM, 1999, pp.
119‚Äì132.
[19] G. Balakrishnan and T. W. Reps, ‚ÄúDIVINE: DIscovering
Variables IN Executables,‚Äù in VMCAI, 2007, pp. 1‚Äì28.
[20] GrammaTech, Inc., ‚ÄúCodeSonar static analysis tool,‚Äù http://www.
grammatech.com/products/codesonar.
[21] S. Tatham, ‚ÄúPuTTy: A free telnet/SSH client,‚Äù http://www.chiark.
greenend.org.uk/sgtatham/putty/.
[22] S. Shiraishi, V . Mohan, and H. Marimuthu, ‚ÄúQuantitative
evaluation of static analysis tools,‚Äù in Software Reliability
Engineering Workshops (ISSREW), 2014 IEEE International
Symposium on, Nov 2014, pp. 96‚Äì99.
[23] G. Balakrishnan, T. W. Reps, D. Melski, and T. Teitelbaum,
‚ÄúWYSINWYX: What you see is not what you execute,‚Äù in
VSTTE, 2005, pp. 202‚Äì213.
[24] A. Slowinska, T. Stancescu, and H. Bos, ‚ÄúDynamic data struc-
ture excavation,‚Äù http://www.few.vu.nl/asia/papers/dde tr10.pdf,
Vrije Universiteit Amsterdam, Tech. Rep. IR-CS-55, February
2010.
[25] ‚Äî‚Äî, ‚ÄúHoward: a dynamic excavator for reverse engineering
data structures,‚Äù in Proceedings of NDSS 2011, San Diego, CA,
2011.
[26] Z. Lin, X. Zhang, and D. Xu, ‚ÄúAutomatic reverse engineering
of data structures from binary execution,‚Äù in NDSS, 2010.
[27] W. Jin, C. Cohen, J. Gennari, C. Hines, S. Chaki, A. GurÔ¨Ånkel,
J. Havrilla, and P. Narasimhan, ‚ÄúRecovering C++ objects
from binaries using inter-procedural data-Ô¨Çow analysis,‚Äù in
Proceedings of ACM SIGPLAN on Program Protection and
Reverse Engineering Workshop 2014, ser. PPREW‚Äô14. ACM,
2014, pp. 1:1‚Äì1:11.
[28] J. Lee, T. Avgerinos, and D. Brumley, ‚ÄúTIE: Principled reverse
engineering of types in binary programs,‚Äù in NDSS, 2011.
[29] G. Balakrishnan and T. Reps, ‚ÄúAnalyzing memory accesses in
x86 executables,‚Äù in Compiler Construction, ser. Lecture Notes
in Computer Science. Springer Berlin Heidelberg, 2004, vol.
2985, pp. 5‚Äì23.
155
155
155
155
ICSE 2015, Florence, Italy