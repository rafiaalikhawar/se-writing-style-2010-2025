PARTI: A Multi-interval Theory Solver
for Symbolic Execution
Oscar Soria Dustmann
Comm. and Distributed Systems
RWTH Aachen University, Germany
dustmann@comsys.rwth-aachen.deKlaus Wehrle
Comm. and Distributed Systems
RWTH Aachen University, Germany
wehrle@comsys.rwth-aachen.deCristian Cadar
Department of Computing
Imperial College London, UK
c.cadar@imperial.ac.uk
ABSTRACT
Symbolic execution is an effective program analysis technique
whose scalability largely depends on the ability to quickly solve
large numbers of first-order logic queries. We propose an effective
general technique for speeding up the solving of queries in the
theory of arrays and bit-vectors with a specific structure, while
otherwise falling back to a complete solver.
The technique hastwo stages: a learning stage thatdetermines
the solution sets of each symbolic variable, and a decision stage
that uses this information to quickly determine the satisfiability
ofcertaintypesofqueries.Themainchallengesinvolvedeciding
which operators to support and precisely dealing with integer type
casts and arithmetic underflow and overflow.
Weimplementedthistechniqueinanincompletesolvercalled
PARTI (‚ÄúPARtial Theory solver for Intervals‚Äù), directly integrating
it into the popular KLEE symbolic execution engine. We applied
KLEEwithPARTIandastate-of-the-artSMTsolvertosyntheticand
real-world benchmarks. We found that PARTI practically does not
hurt performance while many times achieving order-of-magnitude
speedups.
CCS CONCEPTS
‚Ä¢Theory of computation ‚ÜíConstraint and logic program-
ming;‚Ä¢Softwareanditsengineering ‚ÜíSoftwaretestingand
debugging;
KEYWORDS
Constraint solving, Symbolic execution, Multi-intervals
ACM Reference Format:
Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar. 2018. PARTI:
AMulti-intervalTheorySolverforSymbolicExecution.In Proceedingsof
the 2018 33rd ACM/IEEE International Conference on Automated Software
Engineering(ASE‚Äô18),September3‚Äì7,2018,Montpellier,France. ACM,New
York, NY, USA, 11pages.https://doi.org/10.1145/3238147.3238179
1 INTRODUCTION
Symbolic execution is a popular testing and analysis technique
whichhastheabilitytoexploremultiplepathsintheprogramunder
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238179testingwiththegoalofdetectingsoftwareerrors[ 1,7,8,17,18].At
ahighlevel,symbolicexecutionrunstheprogramon symbolicinput,
whichisinitiallynotconstrainedtoanyparticularvalue.Whenever
executionreachesabranchthatdepends‚Äîdirectlyorindirectly‚Äîon
thesymbolicinput,executionmaybesplitintwo:onthe thenpath,
theinputisconstrainedtosatisfythebranchcondition(e.g., x>2),
whileonthe elsepathitisconstrainedtosatisfythenegationofthe
branch condition (e.g., x‚â§2). On each path, a constraint solver is
used to determine whether the current conjunction of constraints
collected at each branch‚Äîcalled the path condition ‚Äîis satisfiable. If
itisnot,thatpathisterminatedasitisinfeasible.Finally,whena
pathfinishesexecution,aconstraintsolvercanprovideasolution
for the path condition, which represents a test input that can be
usedtoreplaythecorrespondingpath,e.g.,fordebuggingpurposes.
The effectiveness of symbolic execution depends directly on the
effectiveness of the underlying constraint solver, as often morethan 90% of the total execution time of a symbolic execution en-
gineisspentinthesolver[ 26].Modernsymbolicexecutiontools
rely on existing Satisfiability Modulo Theory ( SMT) solvers, which
can answer satisfiability problems in a given theory, e.g., linear
arithmetic. Perhaps the most popular theory employed by modern
symbolicexecutionenginesisthatofQuantifierFreeArraysand
Bit-Vectors( QF_ABV),asitcanbeused[ 1,6,16,18,25]toprecisely
model the semantics of popular programming languages such as C,
C++ or Java, and we will therefore consider only this theory in the
remainder of this paper.
State-of-the-art SMTsolvers, such as Boolector [ 4], STP [16],
and Z3 [11], generally start with a pre-processing and optimisa-
tion stage, in which an instance of QF_ABV is simplified using
various strategies, followed by a bit-blasting stage, in which the
query is translated from the level of the theory to that of a boolean
satisfiability( SAT)problem.Whilethepre-processingandoptimi-
sation stage tries to exploit the characteristics of the theory, it is
oblivious to those of the queries generated during symbolic exe-
cution. As a result, symbolic execution engines perform their own
pre-processingandoptimisationstagebeforeinvokingtheunder-
lyingSMTsolver. Examples include performing simple arithmetic
simplifications[ 6,7],cachingsolutions[ 7,33,34],exploitinglogical
implications [6, 24] and rewriting complex array constraints [27].
Inthispaper,weintroduceanewconstraintsolvingoptimisation
techniqueforsymbolicexecution,implementedinanincomplete
solver called PARTI (‚ÄúPARtial Theory solver for Intervals‚Äù), which
aimstoexploitconstraintsolvingquerieswhosesolutionscanbeex-
pressed as the union of a small number of intervals. Hence, PARTI
provides a mechanism to solve only a subset of SMTproblems
fast and resorts to an off-the-shelf solver for other queries. For
430
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar
instance, such queries are generated by inequality conditions in-
volvingasymbolicinputandaconstantvalue,andareprevalentin
real programs as indicated by our evaluation (cf. ¬ß4). Furthermore,
theyoftenoccurinsomesymbolicexecutionimplementationsin
thepointerresolutionstage,whendeterminingvalidobjectsofa
symbolic pointer value.
At a high-level, when deciding a query, PARTI keeps track of
all possible values for each symbolic variable. For instance, the
solution set of an unsigned 8-bit integer symbolic variable xcould
be[1,3]‚à™[120,140]. If laterxis constrained to be greater than 5
byfollowingthe thensideofthebranch if (x > 5) ,itssolution
set becomes just [120,140], as none of the values in [1,3]satisfy
x>5.Withanefficientrepresentationofthesolutionset,PARTI
can quickly solve certain types of queries and bypass the more
expensivecompletesolver.E.g.,itcanquicklydeterminethatthe
queryx>200isunsatisfiable,sincethevaluesfor xarein[120,140].
The first challenge is to precisely deal with integer type casts
and arithmetic underflow and overflow. To better understand this
challenge, consider our previous example where valid solutions
arex‚àà[120,140].I fxis now type-cast to a signed 8-bit variable y
(with a range of [‚àí128,127]), the solution set for yis[120,127]‚à™
[‚àí128,‚àí116]as some values in [120,140]overflow.
Thesecondchallengeistheselectionofsupportedoperandsand
anefficientrepresentationofthesolutionsetinordertobalanceap-
plicability and performance: The sketched approach clearly cannot
efficientlysolveeverysingle SMTqueryastheexplicitderivationof
thesolutionsetofallvariablesisimpossibleinthegeneralcaseand
even when possible, it may lead to exponential blowup depending
on the representation of the solution set.
Our contribution is firstly a scheme for effectively reasoning
aboutsuchintervalqueriesinthecontextofsymbolicexecution,
together with a comprehensive analysis of the operations that we
decide to handle, secondly an implementation of the presented
techniqueandathoroughevaluationoftheperformancegainsit
can achieve.
2 PRELIMINARIES
We denote a QF_ABV SMT queryqas a pair (e,C), whereeis a
query expression whose satisfiability we try to determine and Cis
thesetofconstraintsthatareknowntohold.Forexample,thequery
(Eq(a,3),{Ule(1,a),Ule(a,5)})isanSMTquerythatissatisfiable
but not a tautology (cf. Table 1). If the solution set for a variable x
is independent from other variables, we denote its solutions as /llbracketx/rrbracket,
e.g., /llbracketa/rrbracket={1,2,3,4,5}.
Each expression has a bit-width. E.g., eand all expressions in C
havebit-width1,i.e.theyarebooleanexpressions.Werepresent
an expression by an Abstract Syntax Tree ( AST). This tree consists
of (1) internal vertices, representing operators combining one or
more sub-expressions, e.g., Add, and, (2) leaf vertices, representing
either a constant, e.g., Const(42), or a read from a free variable,
e.g., Read(x). For readability, we may omit explicitly specifying
theReadandConstoperators.Notethattheremaybeseveralreads
with different offsets and bit-widths from a free variable in one
AST,butwerestrictPARTItosuchqueriesthathavenopartially
overlapping reads for any given variable.Table 1: The relevant QF_ABV operators for this paper. Full
SMT encompasses a longer list, including, e.g., modulo.
Operator Children Semantics
Const 0 leaf: constant value
Read 0 leaf: free variable
LShr 1 logical right-shift
Not 1 negation
ZExt, SExt1 unsigned/signed type conversion
Add, Sub2 addition/subtraction
Eq 2 equality
Mul 2 multiplication
Ule, Sle2 unsigned/signed less-than-or-equal-to
Ult, Slt2 unsigned/signed less-than
The list of relevant operators discussed in this paper is depicted
in Table 1. Note that all queries are assumed to be normalised
to exclude operators such as ‚Äònot-equal‚Äô as these can be trivially
lowered to the given operators.
3 CORE DESIGN
PARTI has been designed to enable very fast solving of a subset
ofSMTquerieswithastructurethatmanyprogramsproducefre-
quentlyduringsymbolicexecution.Thatis,PARTIattemptstosolve
aquerybutmaygiveupatanytimewhileprocessingtheexpression
ortheconstraints.Thiswillbecommunicatedtoacomplete SMT
solverwhichactsasafall-back.Wedistinguishbetween complete
solvers,that,givenenoughresources,cansolveall SMTqueries,and
incomplete solvers,suchasPARTI,thatcanonlysolve(efficiently)a
subsetofSMT.Inthissection,wecharacterisethesubsetsupported
by our incomplete solver and describe its operation in detail.
3.1 Overview
Weassumethatthesolverispresentedwithaquery qconsistingof
anexpressionandasetofconstraints,asdefinedin¬ß 2.Theresultof
the solver can either be [1,1](‚Äòalways-true‚Äô), [0,0](‚Äòalways-false‚Äô),
[0,1](‚Äòtrue-or-false‚Äô) or ‚ä•(‚Äòunknown‚Äô). If ‚ä•is returned, the query
could not be solved and a complete solver must be consulted.
As PARTI is an incomplete solver by design, it has some limi-
tations as to which queries it can answer. This is reflected in the
operatorsitcanprocess.Forinstance,themodulooperatorisen-
tirelyunsupported,whileotheroperatorsmaybesupportedonly
insomecases.Hence,atanymoment,whenweencounterapart
ofthequerythatcannotbeprocessed,PARTIimmediatelyaborts
processing the query and returns ‚ä•.
The operation of PARTI is divided into two stages: learning and
decision.Beforewediscusstheindividualstepsindetailin¬ß3.3 and
¬ß3.4,wefirstillustratethegeneralideaofthesestagesbyprocessing
the following example query:
(Eq(Add(x,2),y),
{Ule(x,7),Ule(4,x),Ule(Sub(y,3),7)})
431
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. PARTI: A Multi-interval Theory Solver for Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
lH2‚Üê[1,1]
am#
y 37/squigglerightam#‚Üê[0,7]
y 3/squiggleright y‚Üê[3,10]
Figure 1: Processing the constraint Ule(Sub(y,3))in the
learningstage,whereconstraintsareprocessedtop-downin
order to derive information about the solution sets of vari-
ables (yin this case.)1[
//
x 2y/squiggleright1[
//
[4,7]2y/squiggleright1[
[6,9] y
Figure 2: Two steps in evaluating the query expression in
the decision stage. The expression will eventually evaluate
to[0,1]. As opposed to the learning stage (cf. Figure 1), an
expression is processed bottom-up in the decision stage.
3.1.1 LearningStage. Duringthelearningstage,PARTIextracts
information about all involved symbolic variables from the con-
straints. We assign to each variable xa structure /angbracketleft|x|/angbracketright, which repre-
sentsanapproximationofthesolutionset /llbracketx/rrbracket.Witheachprocessed
constraint, /angbracketleft|x|/angbracketrightis refined,reaching anexact representationof the
admissible values for xonce all constraints have been processed.
Hence,untilallconstraintshavebeenprocessed, /angbracketleft|x|/angbracketrightremainsan
approximation of x‚Äôs solutions /llbracketx/rrbracket.
For the subset of constraints {Ule(x,7),Ule(4,x)}, we have
/llbracketx/rrbracket=[4,7]. While learning the first constraint, we would record
/angbracketleft|x|/angbracketright=[0,7]. Then, when processing the second constraint this
approximationwouldberefinedto /angbracketleft|x|/angbracketright=[4,max]‚à©[0,7]=[4,7]=
/llbracketx/rrbracket, where maxcorresponds to the maximal value of x‚Äôs type.
Eachconstraintisprocessedtop-down,thatis,theinitialimplicit
truth value of the expression is recursively pushed down along the
AST: As illustrated in Figure 1, the expression Ule(Sub(y,3),7)
mustevaluateto [1,1],astheconstraintisknowntobetrue.There-
fore,itcanbereasonedthatitsleftoperand Sub(y,3)mustevaluate
to[0,7]. This in turn implies that ymust evaluate to [3,10].A syis
aleafexpressionthatcannotbetakenapartanyfurther,wehave
learnt that /angbracketleft|y|/angbracketright=[3,10]and necessarily /llbrackety/rrbracket=[3,10].
The result of the learning stage is an exact solution set for all
relevant variables.
3.1.2 Decision Stage. In the second stage, all occurrences of
variablesinthequeryexpressionaresubstitutedwiththeirsolution
setandthetreeissubsequentlycollapsed,asdepictedinFigure 2.
Giventheconstraintsover xandylearnedabove,theexpression
Eq(Add(x,2),y)is first substituted with Eq(Add([4,7],2),y). Af-
terwards, by evaluating the solution sets of the Addexpression and
substituting y, we obtain Eq([6,9],[3,10])which in turn may be
true as[6,9]and[3,10]have a non-empty intersection (e.g., 8)
or false as we can choose different representatives from each of
thesets(e.g.,6and10).Thisleavesuswiththesolutionset [0,1],
meaning that the query expression can be both true or false. In
summary,wefoldverticesinthe ASTinabottom-upfashion,until
thetop-mostoperatorisevaluated.Asimplelinear-timepost-order
walk through the AST is sufficient to decide the given expression.
Theresultof thedecisionstageandtheoverall resultofPARTI
is a value in {[0,0],[1,1],[0,1],‚ä•}, as discussed above.
3.2 Representation of Solution Sets
After having presented the general overview of the solving algo-
rithm, we now motivate the design of its primary data structure,multi-intervals,bystudyingtherequirementsthatarisewhentrying
to represent a simple solution set.
3.2.1 Signedness. Inoursetting,symbolicvariablesareuntyped
withregardtotheirsignednessandhaveafixedbit-width(cf.¬ß2).
Hence,theirsemanticvaluedependsontheoperatorusingthem
or their sub-expressions and might therefore implicitly change
depending on the context. Assume for instance a one-byte sym-
bolicvariablewithasolutionsetwiththebit-vectorrepresentation
{11111111 b,00000000 b}.Whenusedinasignedcontextthiscan
be expressedwith theinterval [‚àí1,0]as11111111 bis interpreted
as‚àí1 and 00000000 bas 0 and we have ‚àí1‚â§0 and no integer
between‚àí1 and 0. However, if in an unsigned context, 11111111 b
would be interpreted as 255 for which holds that 255 >0 and thus
the interval [255,0]would be ill-formed, while [0,255]would be
incorrect. In an unsigned context, the same solution set cannotbe represented as a single interval. The same problem can arise
analogously when casting from unsigned to signed.
3.2.2 Multi-Intervals. Weobservethatkeepingasingleinterval
isinsufficientevenforverysimpleproblems.Asshownabove,sign
conversion alone is sufficient to illustrate this limitation, but it
also applies to all operators that can result in integer overflows.
For instance, the operation Add(x,y)for/llbracketx/rrbracket={253,254,255}and
/llbrackety/rrbracket={1}results in /llbracketAdd(x,y)/rrbracket={0,254,255}for 8-bit variables
in an unsigned context.
A sufficiently expressive representation is to, rather than us-
ing a single interval, keep a set of intervals for each variable: a
multi-interval. However, this repr esentation allows for exponential
blowupifthesetofsupportedoperationsisnotchosencarefully.
Forthisreason,weaddsomefurtherrestrictionsinthedesignofthe
algorithm, and choose to explicitly not implement some operators
that in theory could be represented by this data structure.
Weencodemulti-intervalsassortedsetsofpairsofintegerssuch
that the individual intervals never overlap. For instance, the un-
signedadditiondepictedabovewouldresultinthemulti-interval
/angbracketleft[0,0],[254,255]/angbracketrightu8.Notethatmulti-intervalsmaybetyped:Wede-
notethetypeassubscript,e.g., u8,asinthisexample,indicatingan
8-bit unsigned integer. Analogously, an sindicates a signed integer.
Weomitannotatingthetypeifitisinconsequential.Thecardinal-
ity|H|of a multi-interval H, denotes the number of intervals it
contains,forexample |/angbracketleft[10,50],[100,200]/angbracketright|=2.Weusetheprevi-
ouslyintroduced /angbracketleft|x|/angbracketrightnotationinordertoreferto x‚Äôsmulti-interval/angbracketleftbig
[Œæ1,0,Œæ1,1],...,[Œæn,0,Œæn,1]/angbracketrightbig
.
Inthefollowing,wepresentallsupportedoperatorsinthelearn-
ing stage (¬ß3.3) and the decision stage (¬ß3.4), discussing both the
432
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar
Table 2: Cost incurred while processing each supported
operator. In the learning stage, we process an expression
Op(e,c)‚Üêv, withnthe cardinality of the multi-interval
representing vandmthecardinalityofthecurrentsolution
set. In the decision stage, niis the cardinality of the multi-
interval for the ith argument. Operations marked with an
asterisk are only partially supported.
Section Operator Output size Computation
Learning Stage
¬ß3.3.1 Eq,Not ‚â§2 O(1)
¬ß3.3.2 Ult, Slt, Ule, Sle1 O(1)
¬ß3.3.3 Add, Sub ‚â§n+1 O(n)
¬ß3.3.4 Mul ‚â§n O(n)
¬ß3.3.5 ZExt*, SExt* ‚â§n O(n)
¬ß3.3.6 Read* ‚â§max(n,m)O(n+m)
Decision Stage
¬ß3.4.1 Eq 1 O(n1+n2)
¬ß3.4.2 Not 1 O(1)
¬ß3.4.3 Ult, Slt, Ule, Sle1 O(1)
¬ß3.4.4 ZExt, SExt ‚â§n1+1 O(n1)
¬ß3.4.5 Add, Sub ‚â§n1¬∑n2+1O(n1¬∑n2)
¬ß3.4.6 LShr*, Div* ‚â§max(n1,n2)O(n1+n2)
¬ß3.4.7 Mul* ‚â§max(n1,n2)O(n1+n2)
computational complexity of each operator and the sizes of theresulting multi-intervals. We summarise all operators in Table 2.
In ¬ß3.5we end our analysis with an overview of the algorithm‚Äôs
limitations.
3.3 Operations for the Learning Stage
To obtain the admissible multi-interval for each symbolic variable,
weextractitfromallconstraintsduringthelearningstage.Here,
eachconstraintisprocessedindependently,refiningthepreviousap-proximation. After the last constraint is successfully processed, the
extracted multi-interval will exactly, as opposed to approximately,
reflect the solution set.
The top-down approach presented here is restricted to binary
caterpillartrees [ 21]containing asingle Read.Such binarycater-
pillar trees, i.e. trees where each branch has one side with depth 1,
occurofteninpractice,asshowninourevaluation.However,ifanyconstraint with a different type of tree is encountered, the learning
stage will be aborted and ‚ä•returned.
Whilewedescendsuchatree,foreachbinaryoperator Opwe
alwayshaveaconstantside candasidewithanarbitraryexpression
e,aswellasanassignmentofavalue v,denotedas Op(e,c)‚Üêv.W e
derivetheadmissiblevaluesfor ebyinspecting c,v,and Op.Initially,
everyconstraintisimplicitly trueatthetop-mostlevel,therefore
it is of the form Op0(Op1(e,c1),c0)‚Üêv0withv0=[1,1].F r o m
c0we canthen derivea newvalue v1depending onthe semantics
ofOp0and recursively process Op1(e,c1)‚Üêv1. Finally, we have
e‚Üêv2withv2derived from v1,c1and the semantics of Op1.
3.3.1 EqualityandLogicalNegation. Consider,w.l.o.g., Eq(e,c)
‚Üêv,wherevmaybeeither [0,0],[1,1],or[0,1].Forv=[0,1],theremainderoftheconstraintcanbeignoredasitisirrelevantwhether
it holds or not. If vis[1,1], we can simply continue recursively
withe‚Üêc.I fvis[0,0], the solution set is ¬Øc, i.e. a multi-interval
containing exactly all values that cdoes not contain. As the multi-
interval/angbracketleft|c|/angbracketrightmustbeoftheform /angbracketleft[c,c]/angbracketright,thisset-minusoperation
can be computed in constant time and its size is bound by 2.
The logical negation Not(e)‚Üêvcan be lowered to Eq(e,v)‚Üê
[0,0],aseandvmustbeone-bitvalues.Thus,if Not(e)isassigned
v, then this is equivalent to enot being equal to v, which in turn is
expressed by assigning [0,0]toEq(e,v). The same bounds as for
Eqapply.
3.3.2 Comparison. Assumeacomparison L(e,c)‚Üêvwith L‚àà
{Ult,Ule,Slt,Sle}. The inverse case L(c,e)‚Üêvis analogous.
Again,v=[0,1]may be disregarded as the expression would be
a tautology. If we have v=[1,1], we may recursively continue
by learning e‚Üê[a,b]whereais the minimum of the respective
datatypeof L,e.g.,‚àí128foran8-bitsignedtype.Thisisbecause
the constraint L(e,c)only imposes some upper bound con the
sub-expression e, while not imposing any lower-bound. For the
same reason, bis eithercorc‚àí1 depending on whether or not
the operation is a less-than or less-than-or-equal-to operation. So,
[a,b]istheintervalmatchingthe typeof Landindicatingthat e‚Äôs
upperboundis c.Thesizeoftheresultingmulti-intervalistrivially
exactly 1 and is computed in constant time.
3.3.3 Addition and Subtraction. The subtraction operator is
analogous to the addition operator, so we will only investigate
Add(e,c)‚Üêv. Observe that now vis not limited to a boolean
value but may be an arbitrarily complex multi-interval. In order to
continuetherecursionwith e‚Üêwwemustdetermineasuitable
w.Logically,wehave e+c=v‚áíe=v‚àíc=w,sowfollowsas
thedifferencebetweenthemulti-intervalrepresenting vandc.Asc
isstilllimitedtoaconstant,theoperation v‚àíccanbecomputedin
lineartime,bysubtracting cfromallintervalsin v.Thismaycause
atmostoneintervaltospantheunderflowpointandhencebesplit
into two. All other intervals [a,b]invcan trivially be transformed
to[a‚àíc,b‚àíc].Theexpressionisthencontinuedtobeprocessed
recursively: e‚Üêw=v‚àíc.Hence,theresultingmulti-interval w
is computed in linear time and is bound by |v|+1.
3.3.4 Multiplication. By the same logic as with addition and
subtraction operators, Mul(e,c)‚Üêvis resolved by a division of v
byc. Due to the nature of multiplication, some intervals may be
mergedor dropped,leadingto the resultingmulti-intervalhaving
|/angbracketleft|w|/angbracketright|‚â§|/angbracketleft|v|/angbracketright|. As with Add, Mulhas linear complexity.
Ontheotherhand,a Div(e,c)‚Üêvremovesinformationfrom e.
Hence, this operation cannot be reversed efficiently in this context,
asrepresentingallcorrectsolutionsinamulti-intervalwouldpo-
tentiallyleadtoalargenumberofintervals,so Divisnotsupported
by PARTI.
3.3.5 TypeConversion. Therearetwokindsoftypeconversions,
asign cast changing the signedness of an expression and a type
castchanging the bit-width of an expression. For each of these, we
distinguishtwocases.Forasigncast,wecanbecastingfromsignedtounsignedorvice-versa,whileforatypecastwemightbecasting
down, that is reducing the number of bits, or casting up, that is
extendingthenumberofbits.W.l.o.g.weonlydiscussunsigned
433
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. PARTI: A Multi-interval Theory Solver for Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
typecastsassignedtypecastsareanalogousandcanbeloweredto
unsigned type casts. Hence we assume an operation ZExt(e)‚Üêv,
where the expression ZExt(e)has sizekandehas sizek/prime.
‚Ä¢In the case of an upcast, the operator extends the number of bits.
When traversing it backwards, the argument v/primeof the recursive
calle‚Üêv/primeis restricted in the number of bits, i.e. k/prime<k. This
canbeeasilycomputedbytruncatingtheintervalsthatexceed
2k/primesuch that they are bound by 2k/prime. The resulting multi-interval
v/primeis computed in linear time and |v/prime|had an upper bound of |v|.
‚Ä¢Inthecaseofadowncast,theoperatorwouldremoveinforma-
tion. Therefore, the multi-interval that would correspond to e
cannot be computed from the multi-interval that corresponds to
ZExt(e)without risking an exponential blowup. Asan illustrat-
ingexample,fromtheinformationthatanexpression eoftype
u16 satisfies Eq(ZExt u8(e),42), we can derive the solution set
{42,298,554,...,65322},whichcannotbeefficientlyrepresented
by a multi-interval. Hence this operation is not supported.
3.3.6 Leaf Operators. Once the tree has been descended to the
onenon-constantleaf,wehaveanoperationoftheform Read(x)‚Üê
vwithvguaranteedtomatchthewidthofthereadastypecasts
arealwaysexplicit.Hence,ifthisisthefirstprocessedconstraint
touchingvariable x,themulti-intervalof vcanbedirectlyrecorded
as/angbracketleft|x|/angbracketright,thecurrentapproximationofthesolutionsetof x.Incase
xhasalreadybeenreadbyapreviouslyprocessedconstraint,we
ensure that the offset and size of the previous read(s) either match
the new read‚Äôs offset and size exactly or read disjoint bytes (cf. ¬ß2).
Anypartialsolutionsetcannotbeextendedbyfutureconstraints,
but only restricted. The result of applying the information from
thenewmulti-intervalcorrespondstotheintersectionofthecur-
rentsolutionsetwiththenewmulti-interval.Asamulti-interval
is a sorted sequence of intervals, the intersection of two can be
computed in linear time.
3.4 Operations for the Decision Stage
We next describe the operations that are employed during the
bottom-up decision stage, after the learning stage has finished.
A summary of all operators supported in the decision stage, to-
gether with the size of the output multi-interval and the associated
computational cost is given in the bottom part of Table 2.
3.4.1 Equality. Whentwosymbolicvariables a,barecompared
for equality, Eq(a,b), it is insufficient for them to merely share
the exact same solution set to return [1,1]. They must both have
thesame singleton solutionset,asotherwisetheymightevaluate
to differing values. Hence, only if both multi-intervals are of the
form/angbracketleft[k,k]/angbracketright(forsomeconstant k)theresultis [1,1].Conversely,
if their non-singleton solution sets have a non-empty intersection,
theequalityissatisfiable,butnotatautology,andtheresultis [0,1].
Finally, if they have no solution in common, the result is [0,0].
3.4.2 Logical Negation. The logical negation /angbracketleft|r|/angbracketright=/angbracketleft|Not(a)|/angbracketright
ofamulti-interval /angbracketleft|a|/angbracketrightcanbecomputedbyinvertingtherespective
truth values. That is, if /angbracketleft|a|/angbracketrightcontains 0, then /angbracketleft|r|/angbracketrightmust contain 1.
And if/angbracketleft|a|/angbracketrightcontains 1, then /angbracketleft|r|/angbracketrightmust contain 0. This implies that if
/angbracketleft|a|/angbracketright=[0,1], then Notis idempotent and the result is /angbracketleft|r|/angbracketright=[0,1].
Asamust have width 1, no value outside of [0,1]can be contained
in/angbracketleft|a|/angbracketright. Clearly, |/angbracketleft|r|/angbracketright|=1.3.4.3 Comparison. For a comparison L(a,b)with L‚àà{Ult,
Ule,Slt,Sle}, we must determine if indeed for all Œ±‚àà/llbracketa/rrbracketand
allŒ≤‚àà/llbracketb/rrbracket, we have L(Œ±,Œ≤). To solve this problem efficiently,
we rely on the representation of multi-intervals and extract the
closurecl(/angbracketleft|a|/angbracketright)=[Œ±min,Œ±max]of/angbracketleft|a|/angbracketrightand the closure cl(/angbracketleft|b|/angbracketright)=
[Œ≤min,Œ≤max]of/angbracketleft|b|/angbracketright. The closure cl(/angbracketleft|x|/angbracketright)of a non-empty multi-
interval/angbracketleft|x|/angbracketright=/angbracketleftbig
[Œæ1,0,Œæ1,1],...,[Œæn,0,Œæn,1]/angbracketrightbigcan be computed in
constant time by extracting the lower bound of the first interval
and the upper bound of the last interval: cl(/angbracketleft|x|/angbracketright)=[Œæ1,0,Œæn,1].
Then L(a,b)evaluates to [1,1]ifL(Œ±min,Œ≤max),t o[0,0]if we have
¬¨L(Œ±max,Œ≤min)and to[0,1]if both conditions are satisfied.
3.4.4 Type Conversion. An extending type cast from the multi-
interval/angbracketleft|a|/angbracketright=/angbracketleftbig
[Œ±1,0,Œ±1,1],...,[Œ±k,0,Œ±k,1]/angbracketrightbig
miform‚àà{u,s}to
/angbracketleft|r|/angbracketright=/angbracketleftbig
[œ±1,0,œ±1,1],...,[œ±l,0,œ±l,1]/angbracketrightbig
mjwithj>iis trivial, as none
of the intervals are affected and we have |/angbracketleft|r|/angbracketright|=l=k=|/angbracketleft|a|/angbracketright|
withallintervalsbeingidentical.For j<i,theresultingsolution
set is bound to some /angbracketleft[min,max]/angbracketrightand those intervals [Œ±i,0,Œ±i,1]
withŒ±i,1<minormax<Œ±i,0are dropped from /angbracketleft|r|/angbracketright. Any inter-
vals including the minormaxbound are truncated to fit inside
[min,max].Aseachintervaliseithershrunkordroppedwehave
|/angbracketleft|r|/angbracketright|‚â§|/angbracketleft|a|/angbracketright|.
A sign cast must comply with two‚Äôs-complement semantics: For
an unsigned-to-signed cast, every interval strictly smaller thanthe boundary
h=2i‚àí1is preserved, while every interval strictly
greater than or equal to his also preserved but moved left in the
sorted list of intervals, to preserve the strict order. Finally, if there
existsanintervalthatincludesboth handh‚àí1,itissplitintwo,
one with the upper bound h‚àí1 and one with the lower bound
h.Asigned-to-unsignedcastisperformedanalogously,whilethe
boundary his set ath=0 and intervals are moved to the right, not
theleft.Asuptooneintervalmightbesplitintwoandeveryother
interval is preserved, we have |/angbracketleft|r|/angbracketright|‚â§|/angbracketleft|a|/angbracketright|+1.
3.4.5 Additionand Subtraction. Theplusoperator Add(a,b)is
implemented by successively adding individual intervals of bto
aakin to a cross product. For this algorithm, we break down the
operationtoaddingtwointervals [Œ±0,Œ±1]+[Œ≤0,Œ≤1]=[Œ±0+Œ≤0,Œ±1+
Œ≤1]=s.I fshappens to overflow or underflow, it is split in two
as described in ¬ß3.4.4. Finally, all resulting intervals are merged
into one multi-interval. For each pair of intervals from /angbracketleft|a|/angbracketrightand
/angbracketleft|b|/angbracketrightwe may get up to two intervals. However, as all intervals that
lead to an underflow or overflow will be merged, we have in total
|/angbracketleft|r|/angbracketright|‚â§|/angbracketleft|a|/angbracketright|¬∑|/angbracketleft|b|/angbracketright|+1. Subtraction is analogous to addition.
3.4.6 Non-RotatingShift. Fromthetwopotentialshiftoperators,
left-shiftandright-shift,theleft-shiftoperatorbehavesanalogously
to a multiplication, which we discuss in ¬ß3.4.7. A right-shift with a
non-constantshiftamountmayleadtoexponentialblow-upand
thusisnotsupported.Aright-shiftbyaconstant, /angbracketleft|r|/angbracketright=LShr(a,c),
potentiallycondensesthemulti-interval,i.e. |/angbracketleft|r|/angbracketright|‚â§|/angbracketleft|a|/angbracketright|,sow e
support it. For instance, the right-shift by 2 of the multi-interval
/angbracketleft[0,9],[11,20],[30,40]/angbracketrightu8resultsinthefirsttwointervalsmerging:
/angbracketleft[0,5],[7,10]/angbracketrightu8.
3.4.7 Multiplication. Leftshift,andbyextensionintegermul-
tiplication,presentsuswithapotentialexponentialblow-up.For
instance, consider the multi-interval /angbracketleft[0,42]/angbracketrightu8. A left-shift of 1 or
434
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar
amultiplicationwith21wouldresultinasolutionsetcontaining
all the even integers from 0 to 84, i.e., it would have the form
/angbracketleft[0,0],[2,2],[4,4],...,[84,84]/angbracketrightu8. However, our problem analy-
sis shows that multiplication with constants of the form 2iare
verycommon,especiallystemmingfrompointerresolutionlogic
(see ¬ß4.1.1). Therefore, we extend multi-intervals in the decision
stage to carry a left-shift attribute ( LSA). That is, the operation
Mul(/angbracketleft[0,42]/angbracketrightu8,2)will result in the multi-interval /angbracketleft[0,42]/angbracketrightu7with
anLSAof 1. In the general case, this gives us |/angbracketleft|r|/angbracketright|‚â§|/angbracketleft|a|/angbracketright|. Subse-
quentbinaryoperationslike Addwillthenstillabortifpresented
with two operands with differing LSAs, but may succeed when the
LSAs are the same. Similarly, inequality operators can apply the
LSA when computing the closure without incurring blow-up.
3.5 Limitations
Bydesign,ourapproachhassomelimitations.Inthelearningstage,
wecannotprocessconstraintswithmorethanone Readasweneed
todescendonthecentralpathfromtheroottothesingularvariable.
(Ontheotherhand,wecanprocessmultiplereadsinthedecision
stage.) In both stages, some operators are not supported, as they
may lead to an exponential blowup.
Foreveryquery,PARTIdecideson-the-flywhetheritcancon-
tinue to process it or has to abort. This results in an overall com-
plexity that is at worst quadratic in the size of the entire query and
exponential in thenumber of Add/Suboperators in theexpression
(cf. Table 2).
4 EVALUATION
Weevaluateourapproachbycomparingacompletestate-of-the-art
SMTsolver, namely Z3, with PARTI in conjunction with the same
complete solver. We first validate PARTI‚Äôs results with those of
Z3, finding no discrepancy over the entire course of our several
CPU-weekslongevaluation.Hence,theremainderofthissection
will assess the performance of PARTI.
WeimplementedthePARTIalgorithmdirectlyintheKLEEsym-
bolic execution engine [ 6] in version 1.4.0, intercepting queries
before they are being handed to the back-end solver. This is fa-
cilitated by the solver chain of KLEE, which allows to inject an
incompletesolverandthenautomaticallyconsultthenextsolver
in thechain oncethe injectedsolver failsto solvethe givenquery.
By default, KLEE also invokes the final, complete solver by forking
the current process. This is done to enforce the solver timeout,
i.e., to terminate the solver, should it consume too much time. We
deactivatethismechanism,asforkingwouldcreateasubstantial
overheadandbiastheevaluationinfavourofPARTI.However,thatresultsinsolverfailuresofZ3,whichoccurquiteinfrequently,tobe
propagateduptoKLEE,requiringonereruneveryapproximately
1000 runs.
WechooseZ3asithasfinertime-outcontrolbuiltinthanKLEE‚Äôs
defaultSMTsolverSTP.Runningthelatterwouldincurtheover-
head stemming from process forking or make it impossible to reli-
ablymeasurethesolvertimeduetoextremelylong-runningqueries
beingprevalentinmanyruns.However,wealsocomparetheper-
formance of PARTI under both solvers on a smaller benchmark
which does not produce such time-out breaking queries in ¬ß4.2.3.Our evaluation was run on an Intel Xeon [ 23] with 12 threads
at3.4GHzwith0.25TBRAMandwithhyper-threadingdisabled.
We ran no more than 11 processes in parallel and no swapping
occurred during any run.
Westructuretheevaluationintotwomainparts:Afunctional
analysis (¬ß4.1) and a performance evaluation (¬ß4.2).
In both cases, each experiment is repeated several times as time
measurements always result in noisy data. The exact number of
repetitions and the semantics of the depictedconfidence intervals
isdenoted oneach figurewhere itapplies. Toalso minimisenoise
as much as possible, we use the DFS deterministic searcher, which
descendsononeexecutionpath,onlypursuingotherpathsafterthe
currentoneterminates.Asthiswillgeneratebothshortandlong,
simpleandcomplexqueries,itprovidesagoodcollectionofqueries.
WealsodeactivatedquerycachesinKLEEtoenhancedeterminism.
4.1 Functional Analysis
As a means of obtaining an insight into the strengths and limita-
tions of PARTI, we first perform a functional analysis of mostly
synthetictestprograms.Here,weevaluatetheterminationtimeforacompletecoverageoftheinputprogram,imposingnotimeoutfor
KLEE. Each run is repeated manifold with PARTI+Z3 and with Z3.
4.1.1 ObjectResolution. InKLEE,objectresolutionforsymbolic
pointers(includingarrayindexes)dependsonaseriesofcompar-
isons,checkingifthepointervaluecouldpointinsideeachofthe
memory objects on the current path. For instance, when KLEE
encounterstheaccess a[i],whereiisanunconstrainedsymbolic
index (which could thus refer to other arrays, too), it compares
the symbolic value a+iagainst the bounds of all possible objects
on that path. This causes a large number of comparison queries,slowing down such operations to the extent that users of KLEE
repeatedly complain about this shortcoming.
Weanalysethisscenariowithrespecttodifferentarraytypesand
lengths in Figure 3. The performance here heavily depends on the
support of multiplication in the decision stage: In this scenario, we
can identify most queries to have the form L/parenleftbigb,Mul/parenleftbigx,2i/parenrightbig/parenrightbigwhere
bandiare constants, and xis a symbolic pointer. If we deactivate
thesupportfor LSAs(cf.¬ß3.4.7),everythingbutthespeedupforthe
8bitrunsdropsto1.With LSAsweobserveahugespeedupwell
above a factor of 200 xfor all array types‚Äîas to be expected, the
array size (horizontal axis) has no influence on the execution time.
As our example only performs the indexing operation, no query is
produced that cannot be solved by PARTI directly.
4.1.2 Worst Case Scenario. We analyse PARTI‚Äôs behaviour in a
worstcasescenario.Tocreateanadversarialprogram,weheavily
exploitthemulti-intervalexplosionintroducedbyan Addoperation
duringthedecisionstage.First,wecreateaseriesof Nvariables vi
andconstraintheirsolutionsettothevalues/braceleftbig
0,2i/bracerightbig
fori=1,...,N.
Second, we compute the sum over all viand multiply with an
additional variable with the solution set {0,1}. This creates a value
with the solution set/braceleftbig
0,2,4,6,...,2N+1‚àí2/bracerightbig, which is correctly
represented by PARTI but incurs an exponential blowup. Finally,
PARTI has toabort computation becauseof the unsupportednon-
constant multiplication. For a control experiment, we omit the
435
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. PARTI: A Multi-interval Theory Solver for Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
23242526272829
Length of the indexed array (N)14080120160200240280KLEE speedup (0.99 conf. @ 200 reps.)8 bit
16 bit32 bit
64 bit
Figure 3: Speedup when indexing an ar-
rayofsize Nandvariousdatatypeswith
a symbolic 64-bit index. Here, the rela-
tive time does not depend on the size or
the type of the array, as constant multi-plication is supported due to LSAs.6789101112131415161718192021222324
Number of symbolic variables2‚àí52‚àí32‚àí121232527time in s (0.99 conf. @ 30 reps.)control Z3
control PARTI+Z3
worst case Z3
worst case PARTI+Z3
Figure 4: Runtime for the symbolic exe-cutionoftheworstcaseandcontrolpro-grams (cf. ¬ß4.1.2). PARTI performs well
forupto16 Addexpressions.Afterwards
theexponentialblowupduetoadditions
in the decision stage take over.6789101112131415161718192021222324
Number of symbolic variables2526272829210211212peak res in MB (0.99 conf. @ 30 reps.)control Z3
control PARTI+Z3
worst case Z3
worst case PARTI+Z3
Figure5:Peakresidentmemoryforsym-bolic execution of the worst case andcontrolprograms.PARTI performswell
up to a number of 16 Addexpressions,
whenthenumberofindividualintervals
in one multi-interval surpasses 2
16.
multiplication, allowing PARTI to succeed instead of having to
additionally invoke Z3.
Notethatweonlyanalyseonepathinthisexperiment,artificially
constraining the solution set of vi. In a real setting, we would
experience path explosion of the magnitude 4i, with most of the
paths not incurring worst case queries in PARTI.
Figure4showsabsoluteruntimesofKLEEforanexecutionofthis
worstcaseprogramfordifferentvaluesof N,whileFigure 5depicts
thepeakresidentmemoryforthesameexperiment.Withasmall
number of symbolic values, the control run shows a noticeable
speed up, while the worst case run shows that PARTI can only
decidethequeriesgeneratedwhilestilladdingconstraints.Around
17 variables, theoverhead beginsto overtakethe speedupand the
exponentialblowupdominatestheoverallperformanceofKLEE,both in the control as well as in the worst case. A very similar
behaviour can be observed for the memory consumption.
This also means that while the cardinality of all involved multi-
intervals remains below 216, the overhead of PARTI remains negli-
gible compared to that of KLEE and Z3.
4.1.3 Sorting Algorithms. To get an insight into the efficacy of
PARTI in specific scenarios, we investigate its behaviour on a suite
ofclassicalsortingalgorithms,suchasmergesortandquicksort.
Ourtestfunctionsortsanarrayofconcretedataandafixednumber
of symbolic entries, placed at random positions within the array.
Foreachofsixsortingalgorithms,wemeasurethetimeuntilKLEE
explores all paths and terminates on its own. Depending on thenumber of symbolic array entries and the tested algorithm, the
time-to-finishmayrangefromfractionsofaseconduptooveran
hour.Figures 6and7showthatdependingonthesettings,differ-
ent algorithms produce more favourable queries for PARTI: For
instance, when analysing a single symbolic entry, both the merge
and heap sort algorithms show a speedup of around 10x, slowly
declining with larger input arrays, while selection sort achieves
speedups well above 40.
When analysing the same algorithms with two symbolic entries,
insteadofone,thespeedupdropssignificantlyforallalgorithms.While the variance is greatly increased for three algorithms, we
still measure speedups ranging from 1.5x to 10x. The different per-
formance in Figure 7is due to the order in which these algorithms
comparethedata-to-sort.Whenanalgorithmsuchasbubblesort
touchesthefirsttwoentriesinitsveryfirstcomparisonandthey
are both symbolic, in the second query there will already be a con-
straint that contains reads from more than one symbolic value,
barring PARTI from processing any subsequent query on that path.
Hence,nosubsequentquerycanbeansweredbyPARTIasitwill
abort each time during the learning stage. So, the speedup depends
onthealgorithm‚Äôsmemoryaccesspatternsandthepositionsofthe
symbolic entries.
ThisdemonstratesthatthesuccessofPARTIisheavilydepen-
dent on the nature of the queries generated by the target program.
Forinstance,ifthereisonlyonesymbolicvaluepresent,thegen-
erated constraints will have the structure of a binary caterpillar
tree with only one symbolic read, such that the learning phase can
succeed. In the second scenario, the symbolic execution introduces
a comparison between two symbolic values in every path at some
point. Therefore, PARTI can be applied only for a portion of the
queries,ascanbeseenbythestarklyreducedspeedupinFigure 7
(approx. 1.5x to 10x) compared to Figure 6(approx. 10x to 50x).
4.2 Performance Evaluation
WeevaluatePARTI‚Äôsperformanceonanumberofreal-worldpro-
grams, to understand the speedup we would see in the wild. Again,
we run each experiment with PARTI+Z3 and with Z3.
4.2.1 Coreutils. TheGNUCoreutils[ 15]arewidelyusedforthe
analysis of the efficacy and efficiency of symbolic execution. We
run the Coreutils suite version 8.29, using 98 individual programs
as a benchmark set with a configuration corresponding to [31].
To compare the runtime of KLEE configured with PARTI+Z3
versus just Z3, we first ran the respective utility, e.g., sum, for a
fixed amount of time, e.g., 900s and logged the number of instruc-
tions,I, KLEE managed to process in that time. Then, we rerun
theexperiment,withoutanimposedtime-out,butinstructKLEE
436
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar
404142434445464748495051525354555657585960
Length of the sorted array1510152025303540455055KLEE speedup (0.99 conf. @ 200 reps.)bubble sort
heap sort
insertion sortmerge sort
quick sort
selection sort
Figure 6: Speedup for sorting algorithms with 1 symbolic
field and N-1 concrete fields when using PARTI+Z3 versus
Z3 alone. Compared to Figure 7, this experiment offers sig-
nificantly more opportunities for our solver as there is no
comparison between two symbolic values.404142434445464748495051525354555657585960
Length of the sorted array123456789KLEE speedup (0.99 conf. @ 30-200 reps.)bubble sort
heap sort
insertion sortmerge sort
quick sort
selection sort
Figure 7: Speedup for sorting algorithms with 2 symbolicfield and N-2 concrete fields when using PARTI+Z3 versus
Z3 alone. As bubble, selection and insertion sort have very
long runtime, they are run with much fewer repetitions,
while still achieving adequate confidence in the mean.
300 900 1800 3600
KLEE timeout (s)1/2123456789101112131415161718192021222324KLEE speedup (0.99 conf. @ 50 reps.)dir
dirname
du
expand
factor
fmthead
mv
pathchk
printenv
sum
tac
Figure8:Speedupwhenexecuting98Coreutilstools.Theleg-end shows those tools with the highest and lowest speedup.
The confidence intervals of some tools include portions be-
lowthe1xline,indicatingthatsmallslowdownsarepossible.Manytimeshowever,wemeasureasignificantspeedup.300 900 1800 3600
KLEE timeout (s)1/21234KLEE speedup (0.99 conf. @ 50 reps.)addr2line
ar
as-new
bfdtest1
bfdtest2
elfeditld-new
objcopy
ranlib
size
strip-new
sysinfo
Figure9:Speedupwhenexecuting17Binutilstools.Theleg-end shows those tools with the highest and lowest speedup.
Weobservethatthevarianceissignificantlyhigherthanfor
the Coreutils experiments and PARTI achieves little to nooverallspeedup.
to terminate after processing Iinstructions. We then record the
time KLEE takes to terminate when using PARTI+Z3 versus Z3
alone.Duetonon-determinisminKLEE(cf.[ 26])thevarianceof
themeasuredtimescanvarygreatly,especiallysincewedecided
to include all Coreutils. Hence, some results may exhibit higher
variance and therefore show larger confidence intervals.
Figure8showsthemeasuredspeedupofPARTI+Z3versusjust
Z3. It shows that many programs benefit from a speedup up to 2x,
while only seldom falling slightly below the neutral mark of 1x.Aroundtenprograms runatleasttwiceas fastwithPARTI,while
two, namely dirname and printenv, even climb above a speedupof 20x. So, while in many cases only moderate speedup can be
achieved, in some instances KLEE‚Äôs performance can be improved
drastically, from an hour down to a few minutes.
4.2.2 Binutils. For a set of programs with different characteris-
tics,weanalyseGNUBinutils[ 14]‚Äîasuiteoftoolsformanipulation
and creationof binaryfiles. Weuse the Binutilssuite version2.28,
437
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. PARTI: A Multi-interval Theory Solver for Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
103104105
Total queries0.00.20.40.60.81.0Success rate (portion of queries solved by PARTI)œÅB900=‚àí0.55
œÅB1800 =‚àí0.44
œÅB3600 =‚àí0.34œÅC900=0.05
œÅC1800=0.01
œÅC3600=0.12Binutils (900)
Binutils (1800)
Binutils (3600)
Coreutils (900)
Coreutils (1800)
Coreutils (3600)
Figure10:AcomparisonofPARTI‚ÄôssuccessrateontheCore-
utilsandBinutilssuites.Eachdotrepresentsonerunofonetool.Thecurvesrepresentlinearbestfitsofthedatapoints.
including17individualprograms.Wemeasurethetimeforthepro-cessingofapre-determinedsetofinstructions,aswiththeCoreutils
evaluation (cf. ¬ß4.2.1).
AsdepictedinFigure 9,thereisnosignificantspeedupforthe
Binutils suite. The number of exploitable queries here is smaller, asPARTIdoesnotsupportbitwiseoperators.Thesearemoreprevalent
whenprocessingbinarydataandhencetobeexpectedingreater
number in the Binutils suite compared to the Coreutils suite.
This indicates that although PARTI can often result in an advan-
tage,ascouldbeobservedwiththeCoreutilsevaluation,wherea
numberofprogramsexperienceaspeedupofwellover2x,other
programstructuresarelesssuitedforourchoiceofsupportedoper-
ators. Furthermore, we see a greater variance of execution times in
thissuite,suchthatwecanonlystatethatthereisneveraslowdown
worsethat1.5xandneveraspeedupbetterthan3x.
4.2.3 GNU sort. We analysed GNU sort from Coreutils in more
detail.Wepassapartiallysymbolicfileandinstructsorttocheck
whether the file is already sorted. Attempts to actually sort a sym-
bolicfilewithKLEE,whetherwithorwithoutPARTI,resultedin
hundredsofGBofRAMbeingusedwithinminutes,preventinga
proper investigation of anything but the most trivial cases.
We tested sort -Con a file with a total of Nalternating sym-
bolic and random concrete lines of uniform length m, showing our
findings in Figure 11for values of m=4,8,12,16.
Notethatthecomplexityofthegeneratedqueriesgrowswiththe
lengthofthesymboliclines,asmorebytesneedtobecompared.In
this experiment, we observe that the more complicated the queries
are for different values of m, the better PARTI performs relative to
Z3. In addition, the more queries generated by symbolic execution,
the more queries are sped up, yielding an approximately linear
speedup, as all queries can be solved by PARTI in this setup. There-
fore, especially in settings with a significant amount of queries,PARTI‚Äôs ability to quickly resolve some queries results in a high1 2 3 4 5 6 7 8
Total number of input lines (N) with length m1234567891011121314151617181920KLEE speedup (0.99 conf. @ 10 reps.)m=4 (STP)
m=4 (Z3)
m=8 (STP)
m=8 (Z3)
m=12 (STP)
m=12 (Z3)
m=16 (STP)
m=16 (Z3)
Figure 11: Completing GNU sort -CandNalternating con-
crete and symbolic input lines of fixed length m. Thespeedup grows both with the length of lines and with thenumber of lines.
overall speedup. Further, the overall speedup increases with the
length of the file‚Äôs lines, as the complexity of the queries increases.
For this experiment, we also investigated the performance gains
between using Z3 and STP as the baseline solver. The results show
thatwith.99confidencenodifferencecanbeidentifiedbetweenthe
two solvers, even though the plotted average appears to indicate a
slight advantage for STP.
4.2.4 Success Rate. The total execution time is most relevant
to the user of a constraint solver or symbolic execution engine.
However, it provides no information about the ratio of queries that
can be answered by PARTI. Figure 10shows the distribution of the
successrateontheCoreutilsandBinutilssuiteswithrespecttothe
total number of queries issued by the respective tool.
Thisdistributionmatchesthespeedupweseein¬ß 4.2.1and¬ß4.2.2,
seeingasignificantlysmallersuccessrateformostoftheBinutils
toolsandawidespreadfortheCoreutilstools.Additionally,wecan
observe that there appears to be no significant relation betweenthe number of Coreutils queries and the success rate of solving
them.However,thenegativecorrelationfortheBinutilsexplains
the ineffectiveness on that suite: With more queries and a more
complexprogramissuingunsupportedoperations,fewerqueries
fall in the supported set, and only short runs are sped up. The
success rate of the GNU sort evaluation in ¬ß4.2.3 is not included in
Figure10as it reaches 1 for all runs.
5 RELATED WORK
Asdiscussedintheintroduction,ourapproachissimilarinspirit
to other constraint solving optimisations employed by modernsymbolic execution engines. For instance, prior work has usedcaching of satisfiability queries [
7] and counterexamples [ 6,33,
34], expression simplifications [ 7], logical implications [ 6,24]o r
rewritingofcomplexarrayconstraints[ 27]toeitheravoidcalling
438
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Oscar Soria Dustmann, Klaus Wehrle, and Cristian Cadar
the SMT solver or call it with simpler queries. Similar to these
approaches,PARTIaimstospeedupacertain classofconstraint
solving queries.
ManySMTsolvers for QF_ABV are built on top of SAT solvers,
and may perform theory-specific optimizations before bit-blasting
thequeryintoaSATformula.Forinstance,theSTPsolver[ 16]per-
forms optimizations such as arithmetic expression simplifications
and array-based refinement before bit-blasting the formula to SAT.
SolverslikeZ3[ 10,11]orYices[ 12,13]alsouseaconjunctionof
various theory solvers together with the SAT solver.
LazysolvershavealsobeenproposedbyBruttomessoetal.[ 5],
whichproposesalayeredsolverdesign,MathSAT.Itusesvarious
rewriting rules to simplify a given query, applying faster passes
whichsupportasmallersetofproblemsbeforeresortingtomore
complex ones.The second layeris similar toPARTI, as itemploys
anumberofdeductionrulespertainingtothepropertiesofvarious
operators. Contrary to PARTI, however, these apply to relations
betweendifferentvariables,suchasthetransitivityof <,andyields
notadefinitesolutionbutasimplifiedquery.Similarsimplifications
are also part of KLEE‚Äôs internal query optimisation.
Hadarean etal. [ 20] discuss a staged solver that leverages equal-
ity,inequality,andbit-blastingtheorieswithacoresolver.Similarly
to PARTI, all solvers in this chain are incomplete with respect to
SMTbut can solve subsets in polynomial time and are called in
orderoftheircomplexity,beginningwiththefastest.Thetheory
solversarecalledrepeatedlyfromthemainsolverloopandsome,
such as the bit-blasting theory solver, may employ a SAT solver.
Approaches like StratEVO [ 28] concern themselves with the
adjustment and selection of solving strategies within a solver such
as Z3 [11]. Here, genetic algorithms are employed to evolve the
selection process towards the fastest strategies. Conversely, the
multi-solverversionofKLEEpresentedin[ 26]proposestoruna
collectionofcomplete SMTsolversinparallelsuchthatdifferences
in their performance can be exploited.
Interval Arithmetic ( IA) has been employed for several decades
now [2,3,19,22].IAoperates in the domain of real numbers ( R),
representedbyIEEEfloating-pointmachinenumbersandwasin
itsinfancyappliedtoprovideabettermeansofavoidingfloating-
point roundingerrors inProlog [ 2,9]. Itsolves thetask offinding
the solution set, represented as an interval, of a list of variablesgiven a finite number of constraints. To this end, it repeatedly
attempts to approach the solutionset by an enclosing of cartesian
products of intervals. This is quite different from the approachpresented in this paper, as PARTI represents the solution set ofeach variable as a set of intervals, while
IArepresents the total
solutionsetasasetofproductsofsingularintervals.Thismakes
therepresentationmorepowerful,butalsoitscomputationmore
complex. Additionally, IA‚Äôs aim is to tackle non-linear problems
on floating-point numbers. Although it has been applied to non-
negativeintegralnumbers,itisnotdesignedforthebehaviourof
two‚Äôs complement integer arithmetic. Solvers like iSAT3 [ 29,30]
andraSAT[ 32]employ IAandconstraintpropagationtechniques
to sharpen approximations ofsolution sets. These operate similar
to the merging step in the learning stage and the procedure of the
decisionstage,butasoptimisationsonapproximationsofreal-value
sets lacking multiplication-gaps and overflows.6 CONCLUSION
Inthispaper,weapproachedthechallengepresentedbytherelianceofsymbolicexecutionon
SMTsolversandthecorrespondingbottle-
neck.Thefundamentalcomplexityoftheunderlying NP-complete
problem severely impacts the efficacy with which symbolic execu-
tioncananalyseprogramsanddetectdefects.Wedemonstratedhow
our approach improves the performance of solving SMTqueries in
the context of symbolic execution.
By designing a lightweight incomplete solver, PARTI, we are
capable of exploiting the structure of many queries that can besolved efficiently, leaving the remainder for a complete solver to
handle. We discussed the theoretical complexity of our solver, and
verifiedempiricallythatitsoverheadisnegligible.Hence,theoverall
solver performance is not impaired, while often being improvedsignificantly, exhibiting order-of-magnitude speedups in severalcases. For instance, tools from the Binutils suite, such as sysinfo,
experiencenospeedup,whiletoolsfromtheCoreutilssuite,such
as dirname and printenv, are sped up by more than 20x.
Our solver relies on a two stage approach, first extracting infor-
mationaboutsymbolicvariables fromthegiven constraints,and
secondsubstitutingreadsfromthesevariableswiththeextracted
information. We find our proposed multi-interval data structure
to be a suitable representation of this information as it lends itself
to an efficient manipulation of results while consuming very little
memory.
Experimental results indicate the viability of this approach in
quickly answering queries that can be solved efficiently by oursolver, but would require more time to be solved by a complete,
state-of-the-art, SMTsolver such as STP or Z3. For some Coreutils
tools, we observe that practically every single query can be an-swered by PARTI, yielding a high speedup. In general, while wecan observe a number of examples without significant speedups,
weoftenmeasureconsistentandreproduciblespeedupswellabove
a factor of 2x and up to a factor of 20x.
ACKNOWLEDGMENTS
This research has received funding from the European Research
CouncilundertheEU‚ÄôsHorizon2020FrameworkProgramme/ERC
Grant Agreement no. 647295 (SYMBIOSYS) and from the EPSRC
under the grant EP/L002795/1.
REFERENCES
[1]Saswat Anand, Corina S. PƒÉsƒÉreanu, and Willem Visser. JPF‚ÄìSE: A Symbolic
Execution Extensionto JavaPathFinder. In Proceedings ofthe 13thInternational
Conference on Tools and Algorithms for the Construction and Analysis of Systems
(TACAS 2007), pages 134‚Äì138. Springer Berlin Heidelberg, 2007.
[2]Fr√©d√©ricBenhamou,LaurentGranvilliers,andFr√©d√©ricGoualard. IntervalCon-
straints:ResultsandPerspectives. In InProceedingsoftheJointERCIM/Compulog
NetWorkshop on New Trends in Constraints, 1999.
[3]Fr√©d√©ricBenhamouandWilliamJ.Older. Applyingintervalarithmetictoreal,
integer, and boolean constraints. The Journal of Logic Programming, 32(1):1 ‚Äì 24,
1997.
[4]Robert Brummayer and Armin Biere. Boolector: An Efficient SMT Solver for
Bit-Vectors and Arrays. In Proceedings of the 15th International Conference on
ToolsandAlgorithmsfortheConstructionandAnalysisofSystems(TACAS2009),
pages 174‚Äì177. Springer Berlin Heidelberg, 2009.
[5]Roberto Bruttomesso, Alessandro Cimatti, Anders Franz√©n, Alberto Griggio,
Ziyad Hanna, Alexander Nadel, Amit Palti, and Roberto Sebastiani. A Lazy and
LayeredSMT(BV)SolverforHardIndustrialVerificationProblems. In Proceedings
ofthe19thInternationalConferenceonComputerAidedVerification(CAV2007),
pages 547‚Äì560. Springer Berlin Heidelberg, 2007.
439
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. PARTI: A Multi-interval Theory Solver for Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
[6]Cristian Cadar, Daniel Dunbar, and Dawson Engler. KLEE: Unassisted and
AutomaticGenerationofHigh-coverageTestsforComplexSystemsPrograms.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (OSDI‚Äô08), pages 209‚Äì224. USENIX Association, 2008.
[7]Cristian Cadar, Vijay Ganesh, Peter M. Pawlowski, David L. Dill, and Dawson R.
Engler. EXE: Automatically Generating Inputs ofDeath. ACMTrans.Inf. Syst.
Secur., 12(2):10:1‚Äì10:38, December 2008.
[8]CristianCadarandKoushikSen. SymbolicExecutionforSoftwareTesting:Three
Decades Later. Commun. ACM, 56(2):82‚Äì90, February 2013.
[9]J. G. Cleary. Logical Arithmetic. Future Computing Systems, pages 125‚Äì149, 1987.
[10]Leonardo de Moura and Nikolaj Bj√∏rner. Efficient E-Matching for SMT Solvers.
InProceedingsofthe21stInternationalConferenceonAutomatedDeduction(CADE-
21), pages 183‚Äì198. Springer Berlin Heidelberg, 2007.
[11]Leonardo de Moura and Nikolaj Bj√∏rner. Z3: An Efficient SMT Solver. In
Proceedingsofthe14thInternationalConferenceonToolsandAlgorithmsforthe
Construction and Analysis of Systems (TACAS 2008), pages 337‚Äì340. Springer
Berlin Heidelberg, 2008.
[12]Bruno Dutertre. Yices 2.2. In Proceedings of the 26th International Conference on
ComputerAidedVerification(CAV2014),pages737‚Äì744.SpringerInternational
Publishing, 2014.
[13]Bruno Dutertre and Leonardo De Moura. The YICES SMT Solver. volume 2,
pages 1‚Äì2, 2006.
[14]Free Software Foundation. Binutils, 2018-07-19. URL: http://www.gnu.org/
software/binutils.
[15]Free Software Foundation. Coreutils - GNU core utilities, 2018-07-19. URL:
http://www.gnu.org/software/coreutils.
[16]VijayGaneshandDavidL.Dill. ADecisionProcedureforBit-VectorsandArrays.
InProceedingsofthe19thInternationalConferenceonComputerAidedVerification
(CAV 2007), pages 519‚Äì531. Springer Berlin Heidelberg, 2007.
[17]Patrice Godefroid, Michael Y Levin, and David Molnar. Automated Whitebox
Fuzz Testing. In Proceedings of the16th Annual Network and Distributed System
Security Symposium (NDSS‚Äô08), volume 8, pages 151‚Äì166, 2008.
[18]Patrice Godefroid, Michael Y. Levin, and David Molnar. Sage: Whitebox fuzzing
for security testing. Queue, 10(1):20:20‚Äì20:27, January 2012.
[19]Laurent Granvilliers and Fr√©d√©ric Benhamou. Algorithm 852: RealPaver: An
Interval Solver Using Constraint Satisfaction Techniques. ACM Trans. Math.
Softw., 32(1):138‚Äì156, 2006.
[20]LianaHadarean,KshitijBansal,DejanJovanoviƒá,ClarkBarrett,andCesareTinelli.
A Tale of Two Solvers: Eager and Lazy Approaches to Bit-Vectors. In Proceedings
ofthe26thInternationalConferenceonComputerAidedVerification(CAV2014),
pages 680‚Äì695. Springer International Publishing, 2014.[21]Frank Harary and Allen J. Schwenk. The Number of Caterpillars. Discrete
Mathematics, 6(4):359 ‚Äì 365, 1973.
[22]T. Hickey, Q. Ju, and M. H. Van Emden. Interval Arithmetic: From Principles to
Implementation. J. ACM, 48(5):1038‚Äì1068, 2001.
[23]Intel Corporation. Intel ¬ÆXeon¬ÆProcessor E5-2643 v4, 2018-07-19. URL: http:
//ark.intel.com/products/92989/.
[24]Xiangyang Jia, Carlo Ghezzi, and Shi Ying. Enhancing Reuse of Constraint
SolutionstoImproveSymbolicExecution. In Proceedingsofthe2015International
Symposium on Software Testing and Analysis (ISSTA‚Äô15), pages 177‚Äì187. ACM,
2015.
[25]GuodongLi,IndradeepGhosh,andSreerangaP.Rajan. KLOVER:ASymbolic
ExecutionandAutomaticTestGenerationToolforC++Programs. In Proceedings
of the 23rd International Conference on Computer Aided Verification (CAV‚Äô11) ,
pages 609‚Äì615. Springer Berlin Heidelberg, 2011.
[26]Hristina Palikareva and Cristian Cadar. Multi-solver Support in Symbolic Ex-
ecution. In Proceedingsofthe25thInternationalConferenceonComputerAided
Verification (CAV 2013), pages 53‚Äì68. Springer Berlin Heidelberg, 2013.
[27]David M. Perry, Andrea Mattavelli, Xiangyu Zhang, and Cristian Cadar. Acceler-
ating array constraints in symbolic execution. In Proceedings of the International
Symposium on Software Testing and Analysis (ISSTA 2017), pages 68‚Äì78, 2017.
[28]N.G.Ram√≠rez,Y.Hamadi,E.Monfroy,andF.Saubion.EvolvingSMTStrategies.In
Proceedingsofthe28thInternationalConferenceonToolswithArtificialIntelligence
(ICTAI‚Äô16), pages 247‚Äì254, 2016.
[29]Karsten Scheibler and Bernd Becker. Implication Graph Compression inside the
SMT Solver iSAT3. In MBMV, pages 25‚Äì36, 2014.
[30] Karsten Scheiblerand BerndBecker. Using IntervalConstraintPropagation for
Pseudo-Boolean Constraint Solving. In Proceedings of the 14th Conference on
Formal Methods in Computer-Aided Design (FMCAD‚Äô14) , pages 32:203‚Äì32:206,
2014.
[31]KLEETeam. OSDI‚Äô08CoreutilsExperiments,2018-07-19. URL: https://klee.github.
io/docs/coreutils-experiments/.
[32] Vu Xuan Tung, To Van Khanh, and Mizuhito Ogawa. raSAT: an SMT solver for
polynomial constraints. Formal Methods in System Design, 51(3):462‚Äì499, 2017.
[33]Willem Visser, Jaco Geldenhuys, and Matthew B. Dwyer. Green: Reducing,
reusing and recycling constraints in program analysis. In Proceedings of the 20th
ACMSIGSOFTInternationalSymposiumontheFoundationsofSoftwareEngineering
(FSE‚Äô12), pages 58:1‚Äì58:11. ACM, 2012.
[34]Guowei Yang,Corina S.PƒÉsƒÉreanu, andSarfraz Khurshid. MemoizedSymbolic
Execution. In Proceedingsofthe2012InternationalSymposiumonSoftwareTesting
and Analysis (ISSTA‚Äô12), pages 144‚Äì154. ACM, 2012.
440
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:50:20 UTC from IEEE Xplore.  Restrictions apply. 