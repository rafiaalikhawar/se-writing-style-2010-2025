Debugging Data Flows in Reactive Programs
Herman Banken
Delft University of Technology
Delft, The Netherlands
hermanb@ch.tudelft.nlErik Meijer
Delft University of Technology
Delft, The Netherlands
h.j.m.meijer@tudelft.nlGeorgios Gousios
Delft University of Technology
Delft, The Netherlands
g.gousios@tudelft.nl
ABSTRACT
Reactive Programming is a style of programming that provides
developers with a set of abstractions that facilitate event handling
and stream processing. Traditional debug tools lack support for
Reactive Programming, leading developers to fallback to the most
rudimentary debug tool available: logging to the console.
In this paper, we present the design and implementation of
RxFiddle, a visualization and debugging tool targeted to Rx, the
mostpopularformofReactiveProgramming.RxFiddlevisualizes
the dependencies and structure of the data flow, as well as the data
insidetheflow.WeevaluateRxFiddlewithanexperimentinvolving
111developers.TheresultsshowthatRxFiddlecanhelpdevelopers
finishdebuggingtasksfasterthanwithtraditionaldebuggingtools.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging; Data flow languages ; Software maintenance tools;
KEYWORDS
reactive programming, debugging, visualization, program compre-
hension
ACM Reference format:
Herman Banken, Erik Meijer, and Georgios Gousios. 2018. Debugging Data
FlowsinReactivePrograms.In ProceedingsofICSE’18:40thInternational
Conference on Software Engineering, Gothenburg, Sweden, May 27–June 3,
2018 (ICSE ’18), 13 pages.
https://doi.org/10.1145/3180155.3180156
1 INTRODUCTION
Software often needs to respond to external events and express
computations as data flows. Traditionally, handling asynchronous
eventswasdoneusingthe Observerdesignpattern [23](inobject-
oriented environmets) or callback functions [22] (when the host
language supports higher-order functions). Using these patterns,
the system consuming the data does not have to block waiting for
new data to arrive, but instead it yields control until new data isavailable. While these patterns decouple the data producer from
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
©2018 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180156the consumers, they typically lead to dynamic registration, side
effects on the consumer side, and inversion of control [17, 46].
Reactive Programming (RP) is an alternative to these patterns
for event driven computation. RP defines event streams as lazy col-
lections and provides operators that allow developers to deal with
thecomplicationsofasynchronouseventhandling.RPstartedin
academiaintheformofFunctionalReactiveProgramming(FRP)[ 15,
18,19,35,39], but in recent years the use of RP has exploded. Lan-
guagessuchasElm[ 14]andlibrariessuchasReactor[ 27],Akka[9]
and Rx [38] are being used by companies like Netflix, Microsoft
and Google, to build highly responsive and scalable systems. Front-
end libraries like Angular1, that use RP in their foundations, are
used by many large sites (9.1% of Quantcast Top 10k websites2).
Agroupofdevelopersandcompanieshasstandardized“Reactive
Programming” in the form of the Reactive Manifesto [8].
While reactive programs offer more declarative and concise syn-
tax for composing streams, RP does not work well with traditional
interactive debuggers, shipped with most IDEs [ 48]. RP borrows
from Functional Programming (FP) for its abstractions, its laziness
and its use of “pure” functions. Those features contribute to a con-
trolflowthatishiddeninsidetheRPimplementationlibraryand
leadtonon-linearexecutionofusercode.Thisresultsinnon-useful
stack traces, while breakpoints do not help either, as relevant vari-
ables are frequently out of scope. Furthermore, using a low level
debuggermakesithardertointeractwiththehighlevelabstractions
thatRPprovides.Comparedtoimperativeprogramming,thereis
limitedknowledgeonhowtoefficientlydebugreactiveprograms.
Traditional imperative program debugging practices [ 5] do not
apply to RP [48].
In this work, we address the issue of RP debugging by design-
ingandimplementingahighleveldebuggercalledRxFiddlefora
popularversionofRP,namelyReactiveExtensions(Rx).RxFiddle
(1)providesanoverviewofthedependenciesinthedataflow,(2)
enables introspection of both the data flow and the timing of in-
dividual events, and (3) enables developers to trace values backthrough the data flow. To guide our design, we conducted inter-
views among professional developers. After building RxFiddle, we
validateditwithauserexperimentinvolvingover100developers.
WefoundthatRxFiddlecanhelpdeveloperscomprehendanddebug
RP data flows faster.
To steer the research, we formulate the following research ques-
tions:
RQ1How do developers debug RP?
Beforedesigningtoolsitisimportanttounderstandtheprac-
tices they must support along with the problems in the cur-
rentstateoftheart[ 50].Forthis,weperformedanextensive
1https://angular.io/
2https://trends.builtwith.com/, accessed 2017-06-20
7522018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
analysis of the literature (both scientific and practitioner-
oriented) and conducted interviews with RP practitioners.
RQ2How can we design a tool that helps developers debug RP?
ByexaminingtheresultsofRQ1,thelimitationsoftraditional
debuggers and the opportunities that RP programs offer
in terms of structure and explicit dependencies between
data flows, we design a novel RP debugger. We validate the
design’sfeasibilitybyprovidingan implementationforthe
popular JavaScript RP library RxJS.
RQ3Can our specialized RP debugger speed up comprehension &
debugging?
To validate our design and examine whether specialized
tooling can improve the debugging experience, we measure
thespeedand correctnessofcomprehensionwithanopen
experiment.
2 BACKGROUND: REACTIVE
PROGRAMMING AND RX
RPisadeclarativeprogrammingparadigmforworkingwithstreams
of input data. According to a definition of reactivity3a reactive
program must interact with the environment “at a speedwhichis
determined by the environment”. Conceptually, when a reactive
programisrun,itsetsupadataprocessingpipelineandwaitsuntil
input arrives, i.e., when the environment changes. Reactive Pro-
gramming languages and libraries provide developers with a set of
abstractions and methods to create such programs.
Many RP implementations share a notion of a collection that ab-
stractsover time,incontrastto spacelikestandardcollections.This
collectioncomesindifferentflavors,suchasObservable(Rx[ 38]),
Signal (Elm [ 14]), Signal/Event (REScala [ 47]) or Behavior/Event
(FRP[18]).The implementationsdifferinthe precisesemanticsof
their collections, their execution model (push/pull), and the set of
availableoperators.In thispaper,wefocus ontheRxformulation,
but our work is applicable to other RP implementations to some
extent.
Understanding how we derive our visualization requires a mini-
mal understanding of the internals of Rx. Rx introduces two basic
types,Observable andObserver.Observablesdefinethedataflow
and produce the data while Observers receive the data, possibly
movingthedatafurtherdownthestream.Figure1ashowsavery
basicexampleofan“insitu”dataflowinRx.Initially,anObserv-
ableiscreated,hereusingthestatic of()method,thendependent
Observablesare createdusing the map()andfilter()methods on
theObservableinstance.Finallywe subscribe ()tostartthedata
flow and send the data to the console.
Assembly. ItisimportanttonotethatObservablesarelazy;ini-
tiallytheyonlyspecifyablueprintofthedesireddataflow.Creating
this specification is called the assembly phase. In Figure 1a, the
assembly phase consists of the calls to of(),map() andfilter(),
creating respectively Observables o1,o2ando3(Figure 1b).
Subscription. Whenthe subscribe ()methodofanObservable
is called,the data flow isprepared by recursively subscribing“up”
the stream: every subscribe call creates an Observer, that is passed
3“Reactive programs [..] maintain a continuous interaction with their environment, at
aspeedwhichis determined by the environment, not the program itself.” [6]to the input Observable, which again subscribes an Observer to itsinput Observable, until finally the root Observables are subscribed
to.Wecallthisthe subscription phase.InFigure1a,insidethesingle
subscribe ()call,theObserverobject s1iscreated,andpassedto o3,
which in turn will recursively subscribe to o2with a new Observer
s2with destination s1, until the full chain is subscribed (Figure 1b).
Runtime. After the root Observables are subscribed to, they can
start emitting data. This is the runtimephase. Depending on the
nature of the Observable, this might attach event listeners to UI
elements,opennetworkconnectionsorstartiteratingoverinmem-ory data. Events are pushed to
s3,t os2and finally to s1which calls
console.log() in Figure 1a.
Rx identifies three types of events that can occur during the
runtime phase: next,errorandcompleteevents.nextevents contain
the next value in the flow, an errorevent signifies an unsuccessful
termination to a stream, while a complete event denotes the suc-
cessful termination of the stream. There are restrictions on theirorder:anObservablemayfirstemitanunlimitedamountof next
events,andtheneitheran errororacomplete event.Observables
do not need to emit any nextevents, and do not need to terminate.
MorecomplexprogramsfeatureoperatorsthatmergeObserv-
ables4, split Observables5or handle higher-order Observables6,
resultinginmorecomplexgraphs.Anexampleofahigher-orderObservable operation (
flatMap()) is shown in Figure 1d. While
merging and splitting happens on an Observable level (the source
property still points to one or more dependencies), higher-order
Observable flattening only manifests within Observer structures
(thereisnoreferencebetweentheObservables).Figure1eshows
this with an innerObservable that is subscribed twice (for both
values2and3,value1isskipped),resultingintwoidenticaldata
flowsover o1.Thedataflowthrough s4,nands4mispushedinto s1,
flattening the data flow.
Marble Diagram. The term Marble Diagram comes from the
shape of the glyphs in the images used to explain Rx in the official
documentation.AnexampleisshowninFigure1c.Thediagrams
contain one or more timelines containing the events that enter and
leave Observables. Next events are typically represented with a
circle, error events with a cross and complete event with a vertical
line.Fromthediagramdeveloperscanunderstandhowoperators
work by inspecting the difference between the timelines, where
events might be skipped, added, transformed or delayed. Mapping
timeonthex-axisprovidesinsightthatismissingwheninspecting
only a single time slice.
3 RESEARCH DESIGN
To answer our research questions, we employ a three-phase Se-
quential Exploratory Strategy, one of the mixed methods research
approaches [ 13,28]. First, we interview professional developers
andreviewavailabledocumentation(RQ1)toformaunderstanding
about current debugging practices. Second, we apply this under-
standingtodesignadebuggerandimplementittotestitsfeasibility
(RQ2).Finally,wevalidatethedebuggerusinganexperiment(RQ3).
4concat(), merge(),combineLatest(), and zip()
5partition(), or through multicasting with share() or publish()
6flatMap(), mergeMap(), and concatMap()
753
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Debugging Data Flows in Reactive Programs ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
Observable.of (1,2,3)
.map(x=>x*2)
.filter(x =>x<3)
.subscribe(console.log)
(a) Rx code example
o1 o2 o3
s3 s2 s1source sourcemap(_ * 2) filter (_ < 3)
destination destinationsubscribe subscribe subscribeof(1,2,3)
(b) Rx graph example
multiplyByTen
40 604 6 a 8
(c) Marble Diagramletinner=Rx.Observable.of ("A","B")
letouter=Rx.Observable.of (1,2,3)
.skip(1)
.flatMap(() =>inner)
.subscribe()
(d) Higher-order flatMap operation
o2 o3 o4
s3 s2 s1
o1
s4,n
s4,msource sourceskip(1) flatMap(() ⇒inner)
destination destinationsubscribe subscribe subscribe
subscribe
destination
subscribedestinationo1
s4,n
s4,msubscribe
subscribeinnerof(1,2,3)
···
···
···
(e) Higher-order Rx graph example
Figure 1: Samples of Rx Observables
4 RQ1: RP DEBUGGING PRACTICES
To validate the need for better tools we must first understand how
existing tools are used (RQ1). For this, we interview developers, as
wewanttoexploreandunderstandhowtheyuseexistingtoolsand
techniques to debug Rx code. The questions are semi-structured.
We first establish a general understanding of the experience of the
subjects.Wethenaskseveralopenquestionsregardingtheiruseof
RP, how subjects debug RP and test RP. Table 1 lists the questions
used as a guideline for the interviews.
Fivedeveloperswithprofessionalprogrammingexperiencerang-
ingfrom 4to12 yearswere interviewed.Thefirst fourdevelopers
(D1-D4) work in Company A, which builds reactive systems [ 8]
usingvariousRPsolutions.DeveloperexperiencewithRxranges
from a month to over a year. The fifth developer (D5) works inCompany B, and is concerned with building and maintaining a
large scale distributed server application, that uses Rx to handle
asynchronous events.
4.1 Interviews
In the following paragraphs we discuss the results of Q6-Q10 in
detail.Noteverysubjectansweredeachquestioninthesamedetail,
so we discuss the answers that provide meaningful insights in the
current practice.
Testing.Ofthe4subjectsofCompanyA,noneperformedtests
specificallyforRxlogic. “Justrunningtheapplication”,isenough
accordingtoD3,sayingthattheyonlytestthebusinesslogicintheir
application and consider the Rx code as “glue”’ which either works
or not. In contrast, D5 and his team at Company B extensively testtheir application using the Rx library’s built-in test facilities like
“marbletests”andthe TestScheduler [44].Usingtests,thesubject
confirms his beliefs about the behavior of the chain of operators,
while tests are also helpful when refactoring code.
Debugging. All subjects independently mention using tempo-
raryprintf() debugging statements (printing messages to the sys-
tem output, e.g. with console.log () in JavaScript). Subjects use
printf()debuggingto “addmorecontext” (D1)totheirdebugses-
sions. Printing which values flow through the flow allows them to
“quicklyreasonwhathappens” (D3).Breakpointsareonlyusedwhen
thecostofrecompilationishigh,forexamplewhenTypeScriptis
used insteadof Javascript: developers preferto attach theirdebug-
ger to a running program session rather than inserting printf()
statements and restarting the session.
Often,it isdifficulttouse existingdebuggersto inspectthelife
cycle of Observables ( subscribe () anddispose()), as the corre-
sponding code lives within the Rx library. Debugging inside the Rx
librarywasdescribedas “painful” byD2,whenusingtheNode.js
debugger to step through the inners of Rx. Alternative solutionsused by our subjects are (1) creating a custom
debug() operator
whichprintstheselifecycleevents(D5),and(2)creatingcustom
Observables(with Observable.create ())thatoverridethedefault
lifecycle methods with facilities to print life cycle events (D2, D5).
Whileprintf() debugging and breakpoints are useful in various
degrees when executing a single Observable chain, these methods
bothbecomeconsiderablymoredifficultand “overviewiseasilylost”
when executing multiple chains concurrently (D3, D5).
754
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
Question
Undestanding the subjects
Q1 Explain your (professional) experience.Q2 Assess your experience on a scale from beginner to expert.
Q3 Explain your (professional) reactive programming experience.
Q4 Assess your RP experience on a scale from beginner to expert.Q5 Have you ever refactored or reworked RP code?
Content questionsQ6 How do you test or verify the workings of Rx code?
Q7 How do you debug Rx code?
Q8 How do you use documentation on Rx?
Q9 What difficulties do you experience with RP?
Q10 What is your general approach to understand a piece of Rx?
Table 1: Interview questions
Documentation. Subjects give different reasons to consult the
documentation,butthemostcommonreasonisto “findanoperator
for what I need” (D1). They feel that there might be an operator
that precisely matches their needs, however knowing all opera-
tors by heart is not common (the JavaScript Rx Observable APIhas 28 static methods and 114 instance methods), therefore sub-
jectssometimesendupdoinganextensivesearchforsomespecific
operator. Another reason to visit the documentation is to com-
prehendhowoperatorsinexistingcodework.Forthis,subjectsuse
theMarbleDiagramsatRxMarbles.com[ 36](D2,D5),theRxJS4
documentationonGitHub(D2,D5),theRxJS5documentationatRe-activeX.io[
44](D1,D4,D5)andtheonlinebookIntroToRx.com[ 10]
(D4).D1specificallymentionstheneedformoreexamplesinthe
documentation.
Difficultiesexperienced. The IDEdoes nothelp withdeveloping
Rx(D2,D4);accordingtoD4 “Rxismoreabouttimingthanabout
types”, and “...you miss some sort of indication that the output is
what you expect”. It is not always clear what happens when you
execute a piece of code, “mostly due to Observables sometimes being
lazy”(D2). Flows are clear and comprehensible in the scope of a
single class or function, but for application-wide flows it becomes
unclear (D3, D4 and D5). D3 mostly used RxScala and mentions
that creating micro services helps in this regard. D1 mentions that
“you need to know a lot as a starting [RxJS] developer”, giving the
example of the many ways to cleanup. D1 used both logging while
analyzing existing code and learning to overcome inexperience.
Understanding. Subjects first look at which operators are used,
thenthey reasonaboutwhattypesandvaluesmightflowthroughthe
stream(D2,D3,D4andD5),usingvariousmethods.Byanalyzingthe
variablenamesD2formsanexpectationoftheresultingvaluetypes,
thenreasoningbackwards,toseehowthisdataisderived. Running
thecode,isusedwhenpossiblebyD5,toobservetheoutcomeofthe
stream,asthis “showstheintentionsoftheoriginaldeveloper”.If
it remains unclear how the data is transformed, the subject injects
adebug() operator or looks up operators in the documentation.
4.2 Analysis of Literature
Developers can learn Rx through several sources, such as the of-ficial documentation at ReactiveX.io, books, online courses, andblog posts. We gathered resources to be analyzed by selecting 4popular books about Rx, and complement this with the officialdocumentations and an article by a core contributor of RxJS. All
reviewed resources eithermention debugging briefly andsuggest
using the do() operator for printf() debugging, or teach the devel-
operprintf() debugging via code samples.
TheRxJS4documentation[ 3]andtwobooks[ 20,42]propose
theuseofthe do()operatorfordebugging.EspositoandCiceri[ 20]
furtherexplainhowtobestformatthelogstatementsandintroduce
ways to limit the logging by modifying the Observable through
meansofthrottlingandsampling.TheRxJavabook[ 42]alsocon-
tains tips to use the various do-operators to integrate with existing
metric tools. To our knowledge the only article [ 37] addressing
issues of debugging Rx is by Staltz, one of the contributors of RxJS,
noting that conventional debuggers are not suitable for the higher
levelofabstractionofObservables.Staltzproposesthreewaysto
debug Rx: (1) tracing to the console, (2) manually drawing the
dependency graph, and (3) manually drawing Marble Diagrams.
We analyzed a set of 13 books about RxJS, which was created
by selecting 69 books matching “RxJS” from the O’Reilly Safari
catalogue[ 2],andfurtherreducingthesetbyfilteringontheterms
“debug”and“debugger”.While,noneoftheremainingbookshad
achapteraboutdebugging,manyofthesebooksuse printf()de-
buggingintheircodesamples.Notably,Blackheathsuggests[ 7],in
a “Future Directions” chapter, that special debuggers could provide
a graphical representation of FRP state over time and would allow
debugging without stepping into the FRP engine.
4.3 Overview of practices
Theavailableliteraturematchestheresultsoftheinterviews: printf()
debugging is both commonly advised and used. While the conven-
tionaldebuggerworksinsomecases,thisismostlythecaseforthe
procedural logic that interleaves Rx logic. Rx-specific debuggers
are suggested, but not implemented. We found that developers use
printf() debugging to learn the behavior of Observables, behavior
meaningboththeirvaluesflowingthroughandtheir(oneormany)
subscriptions.
Overall,weidentifiedfouroverarchingpracticeswhendebug-
ging Rx code:
(1) Gaining high-level overview of the reactive structure.(2) Understanding dependencies between Observables.(3) Finding bugs and issues in reactive behavior.(4) Comprehending behavior of operators in existing code.
5 RQ2: DEBUGGER DESIGN
Inthissection,wedescribethedesignofavisualizerfortheReac-
tiveX (Rx) family of RP libraries to answer RQ2. Given the findings
of RQ1, the requirements for our visualizer are:
REQ1ProvideanoverviewofObservableflows. Thisoverviewshould
support practices 1 and 2, by graphically representing the
relations between all Observables and their interactions.
REQ2Provide detailed view inside the data flow. This view should
support practices 3 and 4 by giving access to both data flow
andlife-cycleeventsandshouldbeabletoshowthebehavior
of an operator visually.
755
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Debugging Data Flows in Reactive Programs ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
of(1,2,3)
map(x⇒x*2 )
filter(x⇒x≤3)
(a) DFG of Figure 1bof(1,2,3)
skip(1)
flatMap(() ⇒inner)of(‘A’, ‘B’)
(b) DFG of Figure 1e
Figure2:SimplifiedDFGscorrespondingtoexamplesinFig-
ure 1
To meet those requirements, we propose a visualizer consisting
of two parts: (1) a Data Flow Graph and (2) a Dynamic Marble
Diagram. The data flow graph satisfies REQ1 by providing a high-
level overview and by showing how different flows are created,
combined and used. The dynamic marble diagram offers a more
in-depthlookintoasingledataflow,byshowingthecontents(in
terms of values and subscriptions) of the flows. Developers can use
it to learn the behaviors and the interplay of operators.
5.1 Data Flow Graph
Simplifiedgraphs. WhenrunninganRPprogram,Observables
arecreatedthatdependonotherObservables(their source)andOb-
serversarecreatedtosendtheirvaluestoadefinedsetofObservers
(theirdestination ).Figure1bshows theserelations ina graph.For
the simplest of programs, the relations between the Observables
(O=o1,o2,o3) and those between Observers ( S=s1,s2,s3) share
an equally shaped sub-graph after a reversal of the Observer edges.
To provide more overview, we process the graph to merge the two
Observable and Observer sequences together, simplifying it in the
process,resultingina DataFlowGraph (DFG)asinFigure2a.Todo
so,weretainonlytheObserversubgraphnodes,complementing
them with the metadata of the corresponding Observable nodes.
Higher-orderrelationsareretained,asshowninFigure2.Figure3B
shows the DFG in practice.
Layout.Layout isused toadd anextralayer of information to
the graph. If multiple subscriptions on the same Observable are
created, multiple flows are kept in the graph and they are bundled
togetherintheresultinglayout.Usingit,developerscanfindrelated
flows.Theycanalsoidentifypossibleperformanceoptimizations;
for example, when they see Observables to be reused often, they
can introduce the share() operator to optimize subscriptions.
Our layout engine is based on StoryFlow [ 33]. StoryFlow was
initially introduced to visually describe complex storylines involv-
ing multiple characters and interactions between them in a way
thatminimizesstorylinecrossings.7WhereasStoryFlowclusterson
physicalcharacterlocation,weclusterflowsperObservable.Fur-
thermore,StoryFlowsupportsinteractivityinvariouslayoutstages
ofwhichweusethealgorithmsfor straightening anddragging.A
selected flow is thus highlighted, straightened and positioned at
the right in order to align with the Marble Diagram.
7An example visualization of the Lord of the Rings character storylines can be found
here: http://www.shixialiu.com/publications/storyflow/index.htmlColor.Observablescanbereused,socoloringthenodescanbe
usedtoidentifythesameObservableinmultipleplacesinthegraph.
For example, in Figure 1e the innerObservable is reused twice,
which we denote visually by applying the same color to its two
occurrences in the DFG.
5.2 Dynamic Marble Diagrams
WeextendtheoriginalnotionoftheMarbleDiagrambyintroducing
animation; our dynamic marble diagrams update live when new
eventsoccurandarestackedtoshowthedatainthecompleteflow.
This allows developers to trace a value back through a flow, an
operation which is impossible using a classic debugger. Handcrafted
marble diagrams can use custom shapes and colors to represent
events,butforthegenericdebuggerweuseonlythreeshapes:next-
eventsareagreendot,errorsareablackcrossandcompletesare
a vertical line, as shown in Figure 3C. For our generic debugger,
itisunfeasibletoautomaticallydecidewhichproperties(content,
shape and color) to apply to events, as the amount of events anddistinguishing features might be unbounded. Instead the event
values are shown upon hovering the mouse cursor on the marble.
5.3 Architecture
To support the visualization, we design a debugger architecture
consistingoftwocomponents:ahostinstrumentationandavisu-
alizer.Bysplittingtheinstrumentationfromthevisualization,the
debugger can be used for the complete Rx family of libraries by
only reimplementing the first component.
TheHost instrumentation instruments the Rx library to emit
useful execution events. Depending on the language and platform,
specific instrumentation is required. What the instrumentationdoes is wrap calls to functions that i) create or modify the DFG,
and ii) introduce events to Observers. The instrumentation uses an
operationalprotocolconsistingof4functionstodrivethedebugger
interface.
TheVisualizer takes the output of the host instrumentation,
the initial graph, and simplifies it into a Data Flow Graph. Then it
laysouttheDataFlowGraphandcreatesthedebugger’sUserInter-
face. By separating the visualizer, we can export generated graphs
and visualize them post mortem, for example for documentation
purposes.
The components can run in their own environment. The instru-
mentation must run inside the host language, while the Visualizer
can use a different language and platform.
5.4 Implementation
To validate our design and to provide an implementation to the de-
veloper community, we created RxFiddle.net. The RxFiddle project
is a reference implementation of our reactive debugger design. Be-
sides the visualizer, the website also contains a code editor for
JavaScript code with sharing functionality, for developers to share
snippetswiththeirpeers,asshowninFigure3A.Inthissectionwe
willexplaindifferentpartsoftheimplementation.ForRxFiddle,we
initially focused on RxJS (JavaScript).
Instrumentation. With JavaScript being a dynamic language, we
use a combination of prototype patching and Proxies [ 1] to instru-
ment the RxJS library: the Observable and Observer prototypes
756
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
AB
C
Figure 3: Screenshot of RxFiddle.net, showing the Code Editor (A), the DFG (B) and the Dynamic Marble Diagram (C)
are patchedto returnProxies wrappingthe API methodcalls. The
instrumentation passes every method entry and method exit to the
Linking step.
Linking.Wedistinguishbetweenmethodcallsfromthediffer-
entphases(Section2).Fromtheassemblyphase,wedetectwhen
Observablesareusedastargetorargumentsofacallorasreturn
value,andcreateagraphnodeforeachdetectedObservable.We
add an edge between the call target and call arguments and re-
turnedObservables,denotingthe sourcerelation.Also,wetagthe
returnedObservablewiththecallframeinformation(time,method
name, arguments). In the subscription phase, we detect calls to
subscribe (): the destination Observers are passed as arguments,
sowecreatethegraphnodesandsavetherelationasanedge.In
the runtime phase, we detect next,errorandcomplete calls on
Observers and add these as meta data to the Observer nodes.
GraphLoggers. FromtheLinkingstepthegraphmutationsare
streamed to the environment of the visualizer, where the graph
is rebuilt. Depending on the host language, a different protocolis used: RxFiddle’s code editor executes the code in a Worker [
1]
and transmits events over the postMessage [1] protocol, while
RxFiddle for Node.js transmits over WebSockets. Being able tosupport multiple protocols, extends the possible use cases; our
prototype implements a code editor for trivial programs, a Node.js
plugin for server applications, and Chrome DevTool extensions8
for web applications.
Visualizer. The visualizer receives the current state in the form
of a graph from the Logger. It then uses the Observers in the graph
tocreatetheDFG.TolayouttheDFGusingStoryFlow,wefirstrank
thegraphusingdepthfirstsearch,removeslack[ 24]andreverse
edges, in order to create a directed acyclic graph. We then add
dummynodestoreplacelongedgeswithedgesspanningasingle
rank.Finally,weorderandalignthenodesintheranksassigning
8https://developer.chrome.com/extensions/devtoolscoordinatesforthevisualization.Itisimportantthatlayoutingis
fast,asitrunseverytimetheDFGischanged.TorendertheMarble
Diagrams,theflow toandfromtheselectedObserverisgathered,
by recursively traversing the graph in the direction of the edges.
6 RQ3: EVALUATION
In this section, we evaluate our debugger to assess the efficacyof our approach. To do so, we use an experiment, in which we
controlforthedebuggerfacilitiesthatsubjectsuse.The“control”groupisprovidedaclassicwebdevelopmentenvironment,while
the “treatment” group uses RxFiddle.
Ko et al. [ 31] describes two commonly used measures for exper-
iments regarding tools in Software Engineering: successon task,
andtimeontask.Thegoalofourexperimentistomeasurethe time
requiredtosolveprogrammingproblemscorrectly.Ifourreasoning
for RQ2 is right and our debugger design lends itself for RP, we
expecttoseethatthegroupusingRxFiddlecanmorequicklyreason
about the reactive code at hand and can trace bugs faster. We do
not use success or correctness as a measure for the experiment, as
weexpectbothgroupstobeabletocompletethetaskscorrectly:
whilethecurrentdebuggingsituationisnon-optimal,itisstillused
in practice, indicating that it works at least to some extend. The
construct of time also matches debugging better; developers need
to continue debugging untilthey find an explanation or a solution
to their problem, while assumptions can be tested and corrected.
We measure the time from the moment the participant received
the question until the correct answer is given. Participants useeither the built-in Chrome Browser debugger (group Console)o r
the RxFiddle debugger (group RxFiddle). This single alternative
Console debugger togetherwith the experiment UI (whichacts as
a small IDE) offers all the debugging capabilities subjects of our
preliminary interviews (RQ1) reported to use.
The experiment consists of a questionnaire, a warm-up task and
fourprogrammingtasks,allavailableinasinglein-browserapplica-
tion,ofwhichthesourcecodeisavailableat[ 4].Thequestionnaire
757
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Debugging Data Flows in Reactive Programs ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
containsquestionsregardingage,experienceinseveralprogram-
minglanguagesandseveralreactiveprogrammingframeworks.We
usethisselfestimationasameasurementofskillinsteadofapretest,
sinceitisafasterandbetterestimator[ 21,30,49].Thewarm-up
program is placed in the same environment as the programming
problemsandcontainsseveraltasksdesignedtolettheparticipants
useeverycontrol ofthistestenvironment. Thefirsttwoprogram-
mingproblemsrequirestheparticipantstoobtainanunderstandingaboutthebehavioroftheprogramandreportthefindings.Thelast
two programming problems contain a program with a bug. The
participants are asked to find the event that leads to the bug in the
thirdproblemandtoidentifyandtextuallyproposeasolutionin
the fourth problem. The first two problems are synthetic examples
of two simple data flows, taken and adapted from the Rx documen-
tation, while the latter two are carefully constructed to match the
documented use of Rx operators and contain some mocked (oth-erwise remote) service which behaves like a real world example.In T3, an error in an external service propagates through the Rx
stream. In T4, concurrent requests lead to out-of-order processing
of responses.
Weuseabetween-subjectsdesignforoursetup.Whilethiscom-
plicatestheresults—subjectshavedifferentexperienceandskills—
wecannotuseawithin-subjectsdesignasitwouldbeimpossibleto
controlforthelearningeffectincurredwhenaskingsubjectstoper-
form survey questions with and without the tool. This also allows
us to restrict the amount of tasks to incorporate in the experiment,
requiring less time from our busy subjects. In the experiment envi-
ronment,subjectscananswerthequestionandthenhit“Submit”;
alternatively they can “Pass” if they do not know the answer.
6.1 Context
Theexperimentwasrunbothinaofflineandinanonlinesetting.
The offline experiment was conducted at a Dutch software engi-
neering company. Subjects are developers with several years ofprogramming experience, ranging from little to several years ofexperience with RP. As we did not try to measure the effect of
learning a new tool, we explained RxFiddle in the introductory
talk and added the warm-up question to get every participant to a
minimum amount of knowledge about the debugger at hand.
The online experiment was announced by the authors on Twit-
ter, and consequently retweeted by several core contributors to RP
libraries,andviavariousothercommunicationchannels,suchas
Rx-relatedSlackandGittertopics.Subjectstotheonlineexperiment
tookthetestattheirownpreferredlocationandhavepossiblyverydifferentbackgrounds.Wecreatedseveralshortvideo tutorialsand
included these in the online experiment to introduce the partici-
pantstothedebugtoolavailabletothemandthetaskstheyneeded
to fulfill. The introductory talk given to the offline subjects was
usedasthescriptforthevideos,inanattempttogetallparticipants
to the same minimum level of understanding.
6.2 Results
Theonlineexperiment wasperformedoutsideofour control,and
someparticipantsquittheexperimentprematurely.Intotalwehad
111subjects(13offline,98online)startingthesurvey,ofthose98
completed the preliminary questionnaire, and 89, 74, 67, and 58subjects startedrespectively T1, T2,T3 and T4.All of thesubjects
in the offline setting started all tasks. Figure 4b shows the outcome
ofthetasks;intheremainderofthissectionweconsideronlythe
outcomes marked as “Correct”.
Overall.Figure 4b shows the time until the correct answer was
given per task. Here, we consider the combined results from theoffline experiment and the online experiment. We make no as-
sumptions about the underlying distribution, so we perform a non-
parametric Wilcoxon Mann-Whitney U test ( H0: times for the Con-
sole group and RxFiddle group are drawn from the same population )
to see if the differences are significant, and a Cliff’s delta test for
ordinaldatatodeterminetheeffectsize.Theresultsareshownin
Figure 4a.
FortaskT3,wecanreject H0withhighsignificance( p<0.05),
the RxFiddle group is faster. For the tasks T1, T2 and T4 we can not
rejectH0(p>0.05), meaning the RxFiddle group and Console group
perform or could perform equally.
Control for experience. To investigate this further, we split the
results for different groups of subjects. When we control for the
self-assessed Rx experience, we see bigger differences for all tasks
for groups with more experience, as shown in Figure 4c and Fig-
ure4d(wesplitatthemedian; exp_rx>“Beginner”-level).Still,for
tasks T1, T2, and T4 we can not reject H0, but the results are more
significant comparing only experienced subjects.
7 DISCUSSION
Wenowdiscussourmainfindings,howRxFiddleresolvesthede-
bugging problem of Rx, and contrast our design to other design
choices and possibilities of future work.
7.1 Main results
Quick and dirty debugging. Through interviews and literature
weestablishthatcurrentdebuggingpracticesforRPconsistmostly
ofprintf() debugging. The shortcomings of this method were
evidentfromtheinterviews:itworksreliablyonlyforsynchronousexecutionorwhensmallamountsofeventsbeinglogged,otherwise
theoverviewislost.Furthermore,thetime-contextofeventsand
dependency-contextofflowsarenotavailableusingthismethod.
Weattributetheprevalenceof printf()debuggingtothis “quick
and dirty” method being available in every language and on every
platform, without a viable alternative.
Improved context: being complete, disposing doubts. With our de-
signandcomplementaryimplementation,weshowthatourabstract
model of RP is suitable for visualization on two levels: overviewand detail. At the overview level, we complement the dependen-
ciesvisibleinsourcecodewithagraphoftheresultingstructure,
showing the run-time effect of certain operators on the reactive
structure. At the detail level, we add the time context, by showing
previous values on a horizontal time line, and the dependency con-
text, by showing input and output flows above and below the flow
ofinterest.Whiletheresultsofourevaluationcouldbeobserved
as a negative, RxFiddle is a new tool, where subjects have only just
been exposed to the tool and received only a short training. We
expectthatbydesigningadebuggermodelsoclosetotheactualab-
stractions, our debugger works especially well for users with some
758
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
console rxfiddle W p-value Cliff’s δ
T134 36 559 0.540 0.0866
T232 31 517 0.780 -0.0424
T323 28 96 6 .19e−60.702
T413 12 60 0.347 0.231
(a) Results comparing the Console and RxFiddle groups●●●
●●
●●●●●●
●●●
0200400600
T1 T2 T3 T4
TaskTime (s)mode
console
rxfiddle
(b) Time until correct answer per task, overall
console rxfiddle W p-value Cliff’s δ
T116 17 105 0.276 0.228
T214 13 99 0.720 -0.0879
T310 11 10 7 .88e−40.818
T4 8 7 13 9 .34e−20.536
(c)ResultscomparingtheConsoleandRxFiddlegroups,withRxex-
perience above “Beginner”-level.●
●
●
●
●●
●●●
0200400600
T1 T2 T3 T4
TaskTime (s)mode
console
rxfiddle
(d) Time until correct answer per task, for subjects with more than
“Beginner”-level of experience with Rx.
Figure 4: Experiment results, overall (top row) and experienced developers only (bottom row).
knowledgeoftheseabstractions;whileonlyT3showsbetterper-
formance with high significancy, we observe slightly better results
when controlling for experience. Future research might investigate
theeffectofexperienceinmoredetail,includingtheuseofmore
complicated tasks, with larger samples.
In the presented research, we did not perform tests with sub-
jects using their own code. However, during piloting and after the
release of RxFiddle, we received positive feedback regarding the
completeness of the visualization. As one user put it, “by using
RxFiddle when learning and understanding what RxJS does in ourproject, I have a feeling of improved control over our Observables,
Subscriptions and the reactive parts of our app”. Specifically the life-
cycle events, which are generally hard to debug using printf()
debugging, are more clear: “Initially we were reluctant to manually
subscribe,butafterseeingthat‘complete’oftentriggersa‘dispose’,theteam became more confident to sometimes use
subscribe () directly”.
Future research might address this evaluation aspect by designing
experiments specifically using code owned by the users.
7.2 Implications
The developers using Rx in practice now have an alternative to
printf()debugging.DeveloperscantryRxFiddleontheircodebase
to better understand the reactive behavior of their application, and
potentiallydetectandverify(performance)bugstheyarenotaware
of. At least one example of this has already occurred in practice:one of our interview subjects reported a bug
9in thegroupBy()
implementation of RxJS, which resulted in retention of subscrip-
tions,increasedmemoryusageandfinallyledtoanout-of-memory
exception. The subject detected the bug in practice and required
extensive amount of debugging involving the Node.js debugger to
tracedown;thesamebugisimmediatelyobviousinRxFiddlewhen
examining the life-cycle events using the visualization.
9https://github.com/ReactiveX/rxjs/issues/2661Contributors of RP libraries could use tools like the RxFiddle
visualizer in documentation to provide executable samples, which
would allow for a better learning experience, and at the same time
would introduce novice developers to other ways of debugging
thanprintf() debugging.
7.3 Limitations and Future Work
Multiple inputs and outputs. If we compare our debugger visual-
izationtothevisualizationoflearningtools,likeRxMarbles[ 36]or
RxViz [41], the main difference is that those tools show all input
and output Observables of a single operator concurrently, whileRxFiddle shows one input and output Observable per Marble Di-agram, part of a single full flow (a path through the graph). The
choicetoshowafullflowallowsdeveloperstotraceeventsfrom
thestartuntiltheendoftheflow,butrestrictsusinshowingonlya
single ancestor flow per node at each vertical position, as adding a
third dimension would clutter the (currently 2D) visualization. For
future research, it would be interesting to compare (1) the different
waysObservablestreamscanbecombinedinMarbleDiagramsand
(2) which visualization elements can be added to explicitly show
causality andlineagefor events and show durations for subscrip-
tions.
Edgevisualization. Inourgraphvisualization,theedgesrepre-
sent the dependencies and the path of the events. Nodes with mul-
tiple incoming edges mergethe events, however users could falsely
think that all event data ends up in the outgoing path: besides data
flows, Rx also uses Observables for timing, as durations ( window()),
as stop conditions ( takeUntil ()), or as toggles ( pausable ()). Dif-
ferent visual representations for joining paths could be explored to
distinguish between using Observables for data or for timing.
Graph scalability. Debugging large reactive systems over longer
periods of time can result in significantly larger Observable graphs
759
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Debugging Data Flows in Reactive Programs ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
and Marble Diagrams than currently evaluated. During tests of
RxFiddlewithlargerapplicationslikeRxFiddleitselfandanexisting
Angularapplication,thegraphbecametoolargetorenderinreal
time.Besidesrenderingperformance,apotentiallyevenbiggerissue
is with communicating large graphs to the developer. We propose
severalextensionstoRxFiddletoremedythisissue:(1)pruningthe
graphofoldflowstoshowonlytheactiveflows,(2)bundlingflows
thathavethesamestructure andonlyrenderingasingleinstance
offering a picker into the flow of interest, (3) collapsing certain
partsofthegraphthatarelocaltoonesourcefileorfunction,(4)
addingsearchfunctionalitytoquicklyidentifyflowsbyoperator
or data values, (5) support navigation between code & graph.
Marble Diagram scalability. Our experience shows that while
Marble Diagrams are useful for small to medium amount of events
(<20),bothbetterperformanceandbetterfunctionalitycouldbe
achievedbyprovidingadifferentinterfaceforhighvolumeflows.
Above a certain threshold of events, this high volume interface
could be the default, offering features like (1) filtering, (2) watch
expressions(tolookdeeperintotheevent’svalue),andadvanced
featureslike(3)histograms&(4)FastFourierTransform(FFT)views.
Moreover,manuallyexaminingthesedistincteventscouldtakea
long time; a debugger could leverage the run-time informationabout the events that actually occur, to provide a UI. Advanced
features like histograms could help the filtering process, while FFT
could offer new ways to optimize the application by doing smarter
windowing, buffering and sampling later on in the chain.
Breakpoints. Placing traditional breakpoints in a reactive pro-
gramstopsthesystemfrombeingreactive,andthereforecanchange
the behavior of the system. Breakpoints can be used by developers
in two ways: i) tomodify the application state by interacting with
the variables in scope, and ii) to notify them of an event occur-
rence.Whilethefirstisarguablynotdesirableforreactivesystems,
the notification property might be a good addition to RxFiddle.
BIGDEBUG [ 26], a debugging solution for systems like Spark [ 52],
introduces simulated breakpoints for this purpose. When a simu-
lated breakpoint is reached, the execution resumes immediately
and the required lineage information of the breakpoint is collected
in a new independent process. Implementing this for RxFiddle isa matter of creating the right UI as the required lineage data is
already available.
Other RP implementations. RxFiddle is specific to Rx, but the
debugger design is applicable to other RP implementations. The
visualization should work for every RP collection abstracting over
time,andwouldbedirectlyapplicabletolanguagessuchasREScala,
andvarious JavaScriptRPimplementations.Future workcouldin-
vestigatewhetherthedebuggerprotocolcanbegeneralizedsuch
thatotherRPsemanticscanbecapturedtoo,forexamplebypro-
viding extension points for the language specific features.
8 THREATS TO VALIDITY
Externalvalidity. Fortheinterviewsweselected5professional
developers thatwerebothavailable and workedon projects involv-ingRxJS.Theonlineexperimentwasopentoanyonewhowantedtoparticipate,andsharedpublicly.Theserecruitmentchannelsposea
threattogeneralizability:differentpracticesmightexistindifferentcompanies,differentdevelopercommunitiesandfordifferentRP
implementations&languages.Futureworkisneededonvalidating
the debugger in these different contexts.
Our code samples for the tasks are based on documentation
samples and common use cases for Rx; RxFiddle might perform
differently on real-world code, especially when the developer is
familiarwiththeprojectordomain.Theexperimentconsistsof2
smalland2mediumtasks;forlargertaskstheeffectofusingthe
debugger could be bigger and therefore be better measurable. Still,
we chose for these smaller tasks: in the limited time of the subjects
they could answer only so many questions.
Constructvalidity. Wemeasurethetimebetweenthemoment
aquestionisdisplayedandthemomentitscorrectanswerissub-
mitted. Even though our questions and code samples are short and
were designed to be read quickly, still some variation is introduced
by differentreading speedsofsubjects.A setup wherethe question
and code can be read before the time is started can remedy this
threat; butintroduces the problemof planning when givenunlim-
ited time [ 31]: subjects can start planning their solution before the
timestarts.Furthermore,subjectsmighthavedifferentstrategiesto
validatetheir(potentiallycorrect)assumptionsbeforesubmitting,
ranging from going over the answer once more, to immediatelytesting the answer by submitting it. However, explicitly stating
thatinvalid answersdonot leadtopenalty mightintroducemore
guessingbehavior.Futurestudiescoulduselongertasks,withprepa-ration time to read the sample software at hand, with a wizard-like
experiment interface presenting one short question at a time.
Internal validity. As a result of the recruitment method of the
experiment, a mixed group of developers took part, attracting eventhose without Rx experience. To reducethe variation in experience
that this introduces, we separately examined the results of more
experienced developers.
At the time of the experiment RxFiddle was already available
online for use, and furthermore some of the experiment subjects
hadalreadyusedRxFiddleduringpiloting.Wemitigatethisissue
partially by providing a instruction video at the start of the experi-
ment,howeversubjectswithextensiveexperiencewithRxFiddle
might bias the results.
Thesubject-expectancy effect [31] poses a validity concern, since
subjects whoexpect acertain outcome,may behavein away that
ensures it. Our subjects had the opportunity to learn the context of
the experiment and thus could be more motivated to use RxFiddle
than using the traditional debugger. Our online experiment cap-tures motivation to some extend as drop-out (defined as quiting,
before havingstarted all tasks) happens;the approximately equal
drop-out in both groups (RxFiddle 56.3%, Console 63.4%), suggests
nosignificantmotivationaldifferences.Futurestudiescouldoffer
subjects external motivation (e.g. by ranking contenders and gami-
fication [ 16]oftheexperiment,ororganizingaraffleamongtop
contenders), to limit the threats introduced by motivation.
9 RELATED WORK
RP Debugging. REScala [ 47] is an RP library for Scala, based on
Scala.React. Recently a debugger model was created for REScala,
760
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
called“RPDebugging”[ 48],featuringadependencygraphvisual-
ization,breakpoints,aquerylanguageandperformancemonitoring.
ThedebuggerfullyintegrateswiththeEclipseIDEandtheScala
debuggerfacilities,creatinga(Scala)developerexperienceanda
featureRxFiddlecurrentlydoesnotoffer:reactivebreakpoints.Our
debuggerdesignsupportsmultiplelanguages,andworksoutside
oftheIDE,inthebrowserenvironmentand/orconnectingtoapro-
ductionsystem.Rxhasdifferentreactivesemanticsandarguably
amorepowerful,butalsomoreextensiveAPI,whichincludesop-
erators acting in the time domain ( delay(), etc.). Therefore, we
argue that seeing values in a flow over time is very valuable; RP
Debugging shows the latest values at the selected time.
RP Visualization. RxMarbles [ 36] visualizes single Rx operators,
for the purpose of learning and comprehension. Users can drag to
modify(only)thetimingofeventsandinstantlyseethechangesre-
flectedintheoutput.Byusingspecificprecodedinputsandtimings
the essence of the operator is made clear. In RxViz [ 41], Moroshko
takes a similar approach, but provides a code editor instead of pre-
pared inputs, and visualizes the output of the stream. RxMarbles
doesnotsupporthigher-orderstreams,whileRxVizsubscribesto
the one outer and multiple inner streams when it detects a higher-
order stream, showing them concurrently. In contrast to our work,
these tools are not debuggers: focus is on teaching the behavior of
single operators or stream outputs, instead of full programs.
OmniscientDebugging. Omniscientdebuggers[ 43]trace,store
andqueryalleventsinaprogramexecution.Whenstoringvasts
amountofprogramexecutioninformation,performanceandeffi-ciencybecomesaproblemandresearchinomniscientdebuggers
focusesonthisspecifically.Wealsotraceeventsoftheentireexe-
cution, ho wever in contrast to omniscient debuggers we only store
trace events regarding RP data flows. The RP semantics allow us to
createfutureoptimizations,forexampleretainingonlytheactive
flow structure, while the flow’s data is kept in a rolling buffer.
DynamicAnalysis. Thestudyofprogramexecutioniscalled“dy-
namicanalysis”[ 12].Inmanycases,dynamicanalysisinvolvesa
post mortem analysis, where first the program is run, collecting
anexecutiontrace,andthenthetracedataisanalyzedtocreatea
visualization.Derivedvisualizations,likeclassandinstanceinter-
action graphs, function invocation histories [ 32], invocation views
and sequence diagrams [ 11] show the possibility to use trace in-
formation for debugging. Arguably, on-line analysis is more useful
for debugging than the standard post mortem analysis. Reiss, in
reference [ 45], mentions the compromises that have to be made to
makeanon-lineanalysis:reducedtracingisrequiredtonotslow
downthesystem(knownastheobservereffect)andfastanalysis
isrequiredtolowerthecostofgettingtothevisualization,tonot
discouragetheusers.Inourdesign,wehandlethesamecompro-
misesastheyarerelevantforRPdebuggingtoo,andourJavaScript
traceimplementationbearsresemblancetothatofProgramVisu-
aliser [32].
UnderstandingDebugging. Debuggingforgeneralpurposelan-
guages revolves around attaching a debugger, stepping through
the code, attaching code or data breakpoints, navigating along dif-
ferent calls in the call stack and examining variables and resultsof expressions [
51]. However, existing research, measuring howthesedifferenttasksarepartofthedevelopersworkday,foundthat
whiledevelopersspendmuchtimeoncomprehendingcode,they
donotspendmuchtimeinsidetheIDE’sdebugger[ 40].Belleret
al.[5]foundthatonly23%oftheirsubjectsactivelyusetheIDE’s
debugger, with the most common action being adding breakpoints,
followedbysteppingthroughcode.Theautomatedtoolingofthese
studies did not measure different kinds of debugging other than
usingtheIDEprovidedtools,howeverBeller’ssurveyindicatesthat
71% also uses printf() statements for debugging. No indication
was given of any RP language and libraries used by the subjects in
the study, but the observation that printf() debugging is common,
matches our experience with debugging reactive programs.
DebuggingforProgramComprehension. Developersneedtoboth
comprehend and debug code almost daily. Initially, comprehension
wasseenasadistinctstepprogrammershadtomakepriortobe-
ing able to debug programs [ 29]. This distinction is criticized by
Gilmore: “debugging [is] a design activity” [ 25], part of creating
andcomprehendingprograms.Maalejetal.[ 34]interviewedpro-
fessional developers and found that developers require runtime
information to understand a program, and that debugging is fre-
quently used to gather this runtime information. This supports our
view that debugging is not only used for fault localization, but also
for comprehension.
10 CONCLUSIONS
Through analysingthe current RPdebugging practices, this work
showstheprevalentmethodforRPdebuggingis printf()debug-
ging. To provide a better alternative, we present an RP debugger
designanditsimplementationfortheRxJSlibray(RxFiddle),which
enablesdevelopersto:(1)gainahigh-leveloverviewofthereactivedataflowstructureanddependencies,and(2)investigatethevalues
and life-cycle of a specific data flow, at run-time.
Throughanexperiment,weshowthatRxFiddleisanviableal-
ternative for traditional debugging and in some cases outperforms
traditional debugging in terms of time spent. There are several
promisingdirectionsforimprovingourdesign.Specificallyscala-
bility could be improved and different edge visualizations could be
explored,toimprovetheusabilityofthetool.Furthermore,bylever-agingalreadycapturedmetadataabouttimingofevents,evenmore
insight could be provided. At the implementation level, we plan to
extend RxFiddle to other members of the Rx-family of libraries.
In this paper, we make the following concrete contributions:
(1)A design of a generic RP debugger, initally tuned for the Rx
RP variant
(2)TheimplementationofthedebuggerforRxJS,andtheservice
RxFiddle.net
InthemonthafterthereleaseofRxFiddle.netthesitewasvisited
by784peoplefrom57differentcountries.Thedebuggerwasalready
used by 53 developers, excluding the use inside of the experiment.
During that same period 42846 interactions with the visualizations
of the debugger have been recorded, such as selecting Observables
or inspecting values by hovering the mouse over the event.
Thedebuggerandtheplatformareopensourceandareavailable
online at [4].
761
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. Debugging Data Flows in Reactive Programs ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden
REFERENCES
[1][n.d.]. MozillaDeveloperNetwork. ([n.d.]). http://mdn.io/Proxy, http://mdn.io/
Worker and http://mdn.io/postMessage.
[2][n.d.]. O’ReillySafariBooksOnline. ([n.d.]). http://www.safaribooksonline.com
[3][n. d.]. RxJS 4 Documentation. ([n. d.]). https://github.com/Reactive-Extensions/
RxJS/blob/master/doc/gettingstarted/testing.md
[4]HermanJBanken.2017.RxFiddle,release1.0.4.http://github.com/hermanbanken/
RxFiddle. (July 2017). https://doi.org/10.5281/zenodo.814981
[5]Moritz Beller, Niels Spruit, Diomidis Spinellis, and Andy Zaidman. 2018. On the
DichotomyofDebuggingBehaviorAmongProgrammers.In 40thInternational
ConferenceonSoftwareEngineering,ICSE2018,Gothenborg,Sweden . OpenAccess
version: https://pure.tudelft.nl/portal/files/38319543/paper.pdf.
[6]GBerry.1989. Realtimeprogramming:specialpurposeorgeneralpurposelanguages.
Technical Report 1065. INRIA.
[7]Stephen Blackheath and Anthony Jones. 2016. Functional Reactive Programming.
Manning, New York.
[8]Jonas Bonér, Dave Farley, Roland Kuhn, and Martin Thompson. 2014.
The reactive manifesto. (2014). http://www.reactivemanifesto.org/pdf/
the-reactive-manifesto-2.0.pdf
[9]JonasBonér,ViktorKlang,andRolandKuhn.2010. AkkaLibrary. (2010). http:
//akka.io
[10] Lee Campbell. 2012. Introduction to Rx. (2012). http://www.introtorx.com
[11]BasCornelissen,AndyZaidman,DannyHolten,LeonMoonen,ArievanDeursen,
and Jarke J van Wijk. 2008. Execution trace analysis through massive sequence
andcircularbundleviews. JournalofSystemsandSoftware 81,12(2008),2252–
2268.
[12]BasCornelissen,AndyZaidman,ArieVanDeursen,LeonMoonen,andRainer
Koschke.2009. Asystematicsurveyofprogramcomprehensionthroughdynamic
analysis. IEEE Transactions on Software Engineering 35, 5 (2009), 684–702.
[13]John W Creswell. 2013. Research design: Qualitative, quantitative, and mixed
methods approaches. Sage publications, Thousand Oaks, CA, USA.
[14] Evan Czaplicki. 2012. Elm: Concurrent FRP for functional GUI. (2012).
[15]Evan Czaplicki and Stephen Chong. 2013. Asynchronous Functional ReactiveProgramming for GUIs. In Proceedings of the 34th ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI ’13). ACM, New
York, NY, USA, Article Czaplicki:2013:AFR:2491956.2462161, 12 pages. https:
//doi.org/10.1145/2491956.2462161
[16]Darina Dicheva, Christo Dichev, Gennady Agre, and Galia Angelova. 2015. Gam-
ificationineducation:Asystematicmappingstudy. EducationalTechnology&
Society18, 3 (2015), 75–88.
[17]Jonathan Edwards. 2009. Coherent Reaction. In Proceedings of the 24th ACM
SIGPLANConferenceCompaniononObjectOrientedProgrammingSystemsLan-
guagesandApplications(OOPSLA’09) .ACM,NewYork,NY,USA,Article1640058,
8 pages. https://doi.org/10.1145/1639950.1640058
[18]ConalElliottandPaulHudak.1997.FunctionalReactiveAnimation.In Proceedings
of the Second ACM SIGPLAN International Conference on Functional Programming
(ICFP’97).ACM,NewYork,NY,USA,263–273. https://doi.org/10.1145/258948.
258973
[19]ConalM.Elliott.2009.Push-pullFunctionalReactiveProgramming.In Proceedings
of the2NdACMSIGPLAN Symposiumon Haskell(Haskell ’09). ACM,New York,
NY, USA, 25–36. https://doi.org/10.1145/1596638.1596643
[20]Antonio Esposito and Michael Ciceri. 2016. Reactive Programming for. NET
Developers. Packt Publishing Ltd, Birmingham, UK.
[21]JanetFeigenspan,ChristianKästner,JörgLiebig,SvenApel,andStefanHanen-
berg. 2012. Measuring programming experience. In Program Comprehension
(ICPC), 2012 IEEE 20th International Conference on. IEEE, IEEE, New York, NY,
USA, 73–82. https://doi.org/10.1109/ICPC.2012.6240511
[22]Keheliya Gallaba, Ali Mesbah, and Ivan Beschastnikh. 2015. Don’t Call Us, We’ll
Call You: Characterizing Callbacks in Javascript. In 2015 ACM/IEEE International
SymposiumonEmpiricalSoftwareEngineeringandMeasurement(ESEM).IEEE,
New York, NY, USA, 1–10. https://doi.org/10.1109/ESEM.2015.7321196
[23]ErichGamma,RichardHelm,RalphJohnson,andJohnVlissides.1995. Design
Patterns:ElementsofReusableObject-orientedSoftware. Addison-WesleyLongman
Publishing Co., Inc., Boston, MA, USA.
[24]Emden R Gansner, Eleftherios Koutsofios, Stephen C North, and K-P Vo. 1993. A
techniquefordrawingdirectedgraphs. IEEETransactionsonSoftwareEngineering
19, 3 (1993), 214–230.
[25]David J Gilmore. 1991. Models of debugging. Acta psychologica 78, 1 (1991),
151–172.
[26]MuhammadAliGulzar,MatteoInterlandi,SeunghyunYoo,SaiDeepTetali,Tyson
Condie, Todd Millstein, and Miryung Kim. 2016. BigDebug: Debugging Prim-
itives for Interactive Big Data Processing in Spark. In Proceedings of the 38th
International Conference on Software Engineering (ICSE ’16). ACM, New York, NY,
USA, Article 2884813, 12 pages. https://doi.org/10.1145/2884781.2884813
[27]Felipe Gutierrez. 2017. Reactive Messaging. Apress, Berkeley, CA, 163–178.
https://doi.org/10.1007/978-1-4842-1224-0_10[28]William E Hanson, John W Creswell, Vicki L Plano Clark, Kelly S Petska, and
JDavidCreswell.2005.Mixedmethodsresearchdesignsincounselingpsychology.
Journal of counseling psychology 52, 2 (2005), 224.
[29]IrvinRKatzandJohnRAnderson.1987. Debugging:Ananalysisofbug-location
strategies. Human-Computer Interaction 3, 4 (1987), 351–399.
[30]Sebastian Kleinschmager and Stefan Hanenberg. 2011. How to Rate Program-mingSkillsinProgrammingExperiments?:APreliminary,Exploratory,Study
Based on University Marks, Pretests, and Self-estimation. In Proceedings of
the 3rd ACM SIGPLAN Workshop on Evaluation and Usability of Programming
Languages and Tools (PLATEAU ’11). ACM, New York, NY, USA, Article Klein-
schmager:2011:RPS:2089155.2089161, 10 pages. https://doi.org/10.1145/2089155.
2089161
[31]AndrewJKo,ThomasDLatoza,andMargaretMBurnett.2015. Apracticalguide
tocontrolledexperimentsofsoftwareengineeringtoolswithhumanparticipants.
Empirical Software Engineering 20, 1 (2015), 110–141.
[32]Danny B Lange, Yuichi Nakamura, et al .1995. Program Explorer: A Pro-
gram Visualizer for C++.. In Proceedings of the USENIX Conference on Object-
Oriented Technologies on USENIX Conference on Object-Oriented Technolo-
gies (COOTS) (COOTS’95) . USENIX Association, Berkeley, CA, USA, Article
Lange:1995:PEP:1268098.1268103, 1 pages. http://dl.acm.org/citation.cfm?id=
1268098.1268103
[33]ShixiaLiu,YingcaiWu,EnxunWei,MengchenLiu,andYangLiu.2013. Storyflow:
Trackingtheevolutionofstories. IEEETransactionsonVisualizationandComputer
Graphics 19, 12 (2013), 2436–2445.
[34]Walid Maalej, Rebecca Tiarks, Tobias Roehm, and Rainer Koschke. 2014. On
thecomprehensionofprogramcomprehension. ACMTransactionsonSoftware
Engineering and Methodology (TOSEM) 23, 4 (2014), 31.
[35]Ingo Maier, Tiark Rompf, and Martin Odersky. 2010. Deprecating the observer
pattern. Technical Report. EPFL.
[36] A. Medeiros. 2014. RxMarbles. (2014). http://rxmarbles.com[37]
A. Medeiros. 2015. How to debug RxJS code. (2015). http://staltz.com/
how-to-debug-rxjs-code.html Online; Accessed September 2016.
[38]EMeijer.2010. Subject/Observerisdualtoiterator.In FIT:FunIdeasandThoughts
attheConferenceonProgrammingLanguageDesignandImplementation.ACM,
New York, NY, USA, 1–2.
[39]LeoA.Meyerovich,ArjunGuha,JacobBaskin,GregoryH.Cooper,MichaelGreen-
berg,AleksBromfield,andShriramKrishnamurthi.2009.Flapjax:AProgramming
LanguageforAjaxApplications.In Proceedingsofthe24thACMSIGPLANCon-
ference on Object Oriented Programming Systems Languages and Applications
(OOPSLA ’09). ACM, New York, NY, USA, 1–20. https://doi.org/10.1145/1640089.
1640091
[40]Roberto Minelli, Andrea Mocci and, and Michele Lanza. 2015. I Know What You
Did Last Summer: An Investigation of How Developers Spend Their Time. In
Proceedingsofthe2015IEEE23rdInternationalConferenceonProgramCompre-
hension(ICPC’15).IEEEPress,Piscataway,NJ,USA,Article2820289,11pages.
http://dl.acm.org/citation.cfm?id=2820282.2820289
[41]M. Moroshko. 2017. RxViz: Animated playground for Rx Observables. (2017).
https://github.com/moroshko/rxviz
[42]Tomasz Nurkiewicz and Ben Christensen. 2016. Reactive Programming with
RxJava. O’Reilly Media, CA, USA.
[43]Guillaume Pothier and Éric Tanter. 2009. Back to the future: Omniscient debug-
ging.IEEE software 26, 6 (Nov 2009), 78–85. https://doi.org/10.1109/MS.2009.169
[44] ReactiveX 2014. ReactiveX.io. (2014). http://reactivex.io/[45]
StevenP.Reiss.2006. VisualizingProgramExecutionUsingUserAbstractions.
InProceedings of the 2006 ACM Symposium on Software Visualization (SoftVis ’06).
ACM, New York, NY, USA, Article Reiss:2006:VPE:1148493.1148512, 10 pages.
https://doi.org/10.1145/1148493.1148512
[46]Guido Salvaneschi, Sven Amann, Sebastian Proksch, and Mira Mezini. 2014. An
Empirical Study on Program Comprehension with Reactive Programming. In
Proceedingsofthe22NdACMSIGSOFTInternationalSymposiumonFoundations
ofSoftwareEngineering(FSE2014).ACM,NewYork,NY,USA,Article2635895,
12 pages. https://doi.org/10.1145/2635868.2635895
[47]Guido Salvaneschi, Gerold Hintz, and Mira Mezini.2014. REScala: Bridging Be-
tween Object-oriented and Functional Style in Reactive Applications. In Proceed-
ingsofthe13thInternationalConferenceonModularity(MODULARITY’14).ACM,
New York, NY, USA, Article Salvaneschi:2014:RBO:2577080.2577083, 12 pages.
https://doi.org/10.1145/2577080.2577083
[48]Guido Salvaneschi and Mira Mezini. 2016. Debugging for reactive programming.
InProceedings of the 38th International Conference on Software Engineering (ICSE
’16).ACM,NewYork,NY,USA,ArticleSalvaneschi:2016:DRP:2884781.2884815,
12 pages. https://doi.org/10.1145/2884781.2884815
[49]JanetSiegmund,ChristianKästner,JörgLiebig,SvenApel,andStefanHanenberg.
2014. MeasuringandModelingProgrammingExperience. EmpiricalSoftw.Eng.
19, 5 (Oct. 2014), 1299–1334. https://doi.org/10.1007/s10664-013-9286-4
[50]JaniceSinger, TimothyLethbridge,Norman Vinson,and NicolasAnquetil. 2010.
AnExaminationofSoftwareEngineeringWorkPractices.In CASCONFirstDecade
HighImpactPapers(CASCON’10).IBMCorp.,Riverton,NJ,USA,Article1925815,
762
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27–June 3, 2018, Gothenburg, Sweden Banken et al.
15 pages. https://doi.org/10.1145/1925805.1925815
[51]Diomidis Spinellis. 2016. Effective Debugging: 66 Specific Ways to Debug Software
and Systems (1st ed.). Addison-Wesley Professional, Boston, MA, USA.
[52]Matei Zaharia, Mosharaf Chowdhury, Tathagata Das, Ankur Dave, Justin Ma,
Murphy McCauley, Michael J.Franklin, Scott Shenker, and IonStoica. 2012. Re-
silient Distributed Datasets: A Fault-tolerant Abstraction for In-memory Cluster
Computing.In Proceedingsofthe9thUSENIXConference onNetworkedSystems
Design and Implementation(NSDI’12). USENIX Association,Berkeley,CA, USA,
Article 2228301, 1 pages. http://dl.acm.org/citation.cfm?id=2228298.2228301
763
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 11:37:39 UTC from IEEE Xplore.  Restrictions apply. 