Automated Refactoring of Nested-IF Formulae in Spreadsheets
Jie Zhang1, Shi Han2, Dan Hao1, Lu Zhang1, Dongmei Zhang2
1Key Laboratory of High Con/f_idence So/f_tware Technologies (Peking University), MoE, Beijing, China
2Microso/f_t Research, Beijing, China
1fzhangjie marina,haodan,zhanglucs g@pku.edu.cn,2fshihan,dongmeiz g@microso/f_t.com
ABSTRACT
Spreadsheets are the most popular end-user programming so/f_tware,
where formulae act like programs and also have smells. One well
recognized common smell of spreadsheet formulae is nested-IF ex-
pressions, which have low readability and high cognitive cost for
users, and are error-prone during reuse or maintenance. However,
end users usually lack essential programming language knowledge
and skills to tackle or even realize the problem. /T_he previous re-
search work has made very initial a/t_tempts in this aspect, while no
eﬀective and automated approach is currently available.
/T_his paper /f_irstly proposes an AST-based automated approach to
systematically refactoring nested-IF formulae. /T_he general idea is
two-fold. First, we detect and remove logic redundancy on the AST.
Second, we identify higher-level semantics that have been fragmen-
ted and sca/t_tered, and reassemble the syntax using concise built-in
functions. A comprehensive evaluation has been conducted against
a real-world spreadsheet corpus, which is collected in a leading IT
company for research purpose. /T_he results with over 68,000 spread-
sheets with 27 million nested-IF formulae reveal that our approach
is able to relieve the smell of over 99% of nested-IF formulae. Over
50% of the refactorings have reduced nesting levels of the nested-IF s
by more than a half. In addition, a survey involving 49 participants
indicates that for most cases the participants prefer the refactored
formulae, and agree on that such automated refactoring approach
is necessary and helpful.
1 INTRODUCTION
Spreadsheets are the most popular end-user programming tools [ 1].
One of the most important enabling factors is that spreadsheets
provide immediate feedback so users can make a change in one
place and immediately see the results [ 2]. Underneath such an
advantage, formulae play an important role as end-user friendly
programs. However, end-users typically lack essential knowledge
and skills of programming, and are easier to write formulae with
bad smells [3].
One of the well-recognized spreadsheet smells is nested-IF expres-
sions [ 3,4].IFfunctions1(i.e., the syntax is IF(condition ;true branch ;
f alse branch )) are widely used spreadsheet functions. Nested-IF
expressions happen when end users write an IFfunction inside an-
other IFornested-IF function. According to previous research [ 3–7],
nested-IF formulae in speadsheets are complex, unreadable, error-
prone, as well as hard to debug and maintain. /T_here are also a lot
of online discussions about the harm of nested-IF formulae. Some
people have expressed their desire to reduce nested-IF s “wherever
possible” [8–10].
1Functions are prede/f_ined built-in formulae already available in spreadsheet systems.What is worse, the bad practice of using nested-IF expressions
among end users is quite common: our study of over 68,000 real-
world spreadsheets2reveals that for the worksheets containing IF,
30.04% of them also contain nested-IF . If we denote the maximum
nesting level inside a nested-IF asif-depth3, in our corpus each
spreadsheet includes on average 9 formulae with if-depth over 10,
while the observed maximum if-depth is 48 with multiple instances.
Formula refactoring is a practical solution to tackle this prob-
lem, which was /f_irst proposed by Badame and Dig [ 12]: to perform
semantic-preserving formula transformations (without changing
the behavior) with the purpose of removing formulae smells. Nev-
ertheless, such refactoring requires essential knowledge and skills
of programming which is challenging for end users. To help end
users, several previous works [ 4,12,13] have proposed a few simple
refactoring pa/t_terns trying to decrease the if-depth , but they either
have very low coverage (i.e., the ratio of formulae that can be ameli-
orated) or are non-automatic.
In this paper, we /f_irstly propose an AST (Abstract Syntax Tree)
based approach to systematically tackling this problem via auto-
mated refactoring. /T_he general idea is two-fold. First, there o/f_ten
exists logic redundancy across diﬀerent condition paths within a
nested-IF . Reduction of the redundant logic can remove useless
parts and simplify the nested-IF formula. Second, some higher-level
semantics are o/f_ten fragmented into hierarchical combinations of IF
conditions in a nested-IF . Reassembling the fragmented syntax from
corresponding IF-subtrees into built-in functions can shorten the
nested-IF formula. To analyze and refactor both redundant logic and
fragmented syntax, our approach leverages and works on the AST
(Abstract Syntax Tree) structure as intermediate representation of
nested-IF formulae.
/T_he evaluation is conducted on over 68,000 real-world spread-
sheets with over 27 million nested-IF formulae. /T_he experimental
results lead to the following three key takeaways. First, our ap-
proach is generally applicable - over 99% of the nested-IF formulae
can be refactored and the refactor has been veri/f_ied as correct.
Second, our approach is eﬀective - over 50% of the refactoring
have achieved more than half of their if-depth reduced; while the
nested-IF functions in most formulae are completely reduced or
transformed with if-depth 1. /T_hird, end users recognize our ap-
proach and its results. A survey on 49 participants indicates that
most of them prefer the refactored formulae and believe the auto-
mated refactoring is necessary and helpful; while only a few of
them are equipped with the knowledge of manual refactoring.
/T_he main contributions of this paper are shown as follows.
1) An automated and highly-eﬀective approach to identify
and refactor nested-IF formulae. /T_he goal is to help end users
2In this paper, we refer spreadsheet as a /f_ile consisting of one or multiple work-
sheets [11].
3E.g,I F(I F(L1>=F$5;L1);I F(L1<=F$6;L1;“”);“”)has an if-depth of 2.arXiv:1712.09797v1  [cs.SE]  28 Dec 2017reduce the complexity and cognitive cost of nested-IF formulae in
spreadsheets.
2) A comprehensive evaluation of the proposed automated
approach. We evaluated the correctness, applicability, eﬀective-
ness and usefulness of the approach.
3) A statistical study on the current usage of nested-IF for-
mulae in real-world spreadsheets. We present detailed statistics
ofnested-IF formulae against over 68,000 real-world spreadsheets
collected in a leading IT company for research purpose.
2 PRELIMINARY STUDY
Our preliminary study aims to present the usage status of nested-IF
formulae and to further motivate our approach.
/T_he investigation is based on a spreadsheet corpus including
over 68,000 real-world Excel /f_iles (a.k.a. spreadsheets/workbooks),
which contain a total of over 149,170 worksheets. /T_he source of this
corpus is a spreadsheet repository collected in a leading IT company
for research purposes. And the /f_iles in our corpus are extracted
by excluding those with technical complications as obstacles for
interaction-free processing (e.g., password protected, external ref-
erence embedded requiring trust con/f_irmation). Compared to the
corpora that have been widely used in previous research work–the
EUSES Spreadsheet Corpus [ 14], Enron Spreadsheet Corpus [ 11],
and Hawaii Kooker Corpus [ 15]–our corpus has the following two
advantages:
1) Larger scale. /T_he number of spreadsheets (68,075) is much
larger than the Enron corpus (15,770), EUSES corpus (4,037), and
Hawaii Kooker Corpus (74). Table 1 lists a detailed comparison
between our corpus and the previous largest corpus Enron4.
2) Higher diversity regarding domains. /T_he corpus contains
diverse spreadsheets for various purposes across multiple domains,
while the other corpora either contain large numbers of toy spread-
sheets or come from a single company of a speci/f_ic domain.
Table 1: Comparison between Enron and our corpus
Corpus
Enron Ours
Total number of spreadsheets 15,770 68,075
Total number of worksheets 79,983 149,170
Average size of spreadsheets 113.4 KB 1,211.3 KB
Number of spreadsheets with formulae 9,120 37,109
Number of spreadsheets with IFfunctions 2,020 14,425
Number of IFfunctions 3,420,790 138,085,568
Based on this very large and diverse corpus, we investigate the
usage status of nested-IF formulae. Inside one spreadsheet many
formulae may be created by dragging one formula down or to the
right to repeat its calculation. As in previous work [ 11,17,18], we
remove these formulae by clustering the formulae based on their
R1C1 notation5. We then pick one formula from each cluster to
form the new formula set. We call this new set the “Unique Set”
and the original set the “Total Set”.
/T_he results are shown in Table 2. /T_he /f_irst two rows show the
results of the formula number. /T_he remaining rows show the num-
ber of formulae in diﬀerent depth ranges. Column “Total”/“Unique”
4We do not compare with the other two corpora because their /f_ile type is too old for
Python excel library openpyxl [16] to parse.
5/T_he R1C1 notation will stay the same even if the formula is dragged down or right.
M= “”
“”T
MF
Q1 =X1
Q1T
Q1 = “”
X1T
Q1<>X1
Q1T
FALSEFFF
Figure 1: AST example
shows the results of the Total/Unique Set, From the table, among
the 27,689,699 total formulae and 19,260,407 unique formulae, over
12% formulae have an if-depth of over 5, over 75,000 total formu-
lae and 35,000 unique formulae even have an if-depth of over 15,
indicating surprisingly heavy usage of nested-IF formulae.
Table 2: Usage status of nested-IF formulae
Total Unique
Formula number 27,689,699 19,260,407
Formula number per-spreadsheet 407 283
if-depth in range (1,5] 24,206,022 16,680,744
if-depth in range (5,10] 2,815,521 2,408,549
if-depth in range (10,15] 548,129 118,355
if-depth in range (15,65] 75,455 35,201
/T_his heavy usage of common nested-IF formulae would cause
much harm as we mentioned in the introduction. However, end-
users usually lack the awareness of such harm. /T_hey also tend to
lack enough spreadsheet function knowledge to manually refactor
or avoid using nested-IF formulae. Consequently, it is essential that
automatic approaches should be constructed to help tackle these
problems.
A/f_ter manually checking a sample of these nested-IF formulae6,
we realize that many formulae contain unnecessary conditions
which would cause dead branches7. Additionally, a large part
ofnested-IF functions actually combine together to ful/f_ill a cer-
tain functionality, which can also be ful/f_illed by other high-level
functions already de/f_ined in spreadsheets like Excel. For example,
the following formula is a real case from our corpus: IF(IF(Q1 =
X1;Q1;IF(Q1 = “” ;X1;IF(Q1<>X1;Q1))) = “” ;“”;IF(Q1 =X1;
Q1;IF(Q1 = “” ;X1;IF(Q1<>X1)))). If we use Mto represent
sub-string IF(Q1 =X1;Q1;IF(Q1 = “” ;X1;IF(Q1<>X1;Q1))),
then the formula can be wri/t_ten as IF(M= “”;“”;M). To be/t_ter
illustrate the formula structure, in Figure 1 we present the gen-
eral AST in the le/f_t as well as the AST of Min the right. From
Figure 1, it is easy to tell that condition Q1<>X1 is redundant:
this condition is in the false branch of condition Q1 =X1, and
thus is certain to be true. Additionally, IF(M= “”;“”;M) actu-
ally equals to Mno ma/t_ter what value Mis. If we remove these
unnecessary IFexpressions, the formula can be refactored into
IF(Q1 =X1;Q1;IF(Q1 = “” ;X1;Q1). Furthermore, we can use the
IFS function to transform IF(Q1 =X1;Q1;IF(Q1 = “” ;X1;Q1) into
IFS(Q1 =X1;Q1;Q1 = “00;X1;TRU E ;Q1), which is much cleaner
than the original one. Inspired by this observation, we propose our
AST-based approach to automatically accomplishing such kind of
formula refactorings.
6/T_he authors manually checked the nested-IF formulae in 100 randomly-sampled spread-
sheets.
7A dead branch will never be executed.
23 APPROACH
3.1 Overview
By analyzing the AST structure of each formula, our approach
identi/f_ies optimizable nested-IF expressions and performs refact-
oring by replacing basic-level and counter-intuitive syntax with
non-redundant and high-level syntax. /T_he major rationale behind
using AST is the desirable structural mapping between AST and
nested-IF as follows. An IFfunction typically contains three parts:
1) condition, 2) true-branch expression, and 3) false-branch expres-
sion. /T_herefore, the ASTs of nested-IF expressions are binary trees,
with the true- and false-branch expressions being the two child-
nodes of the condition node. Consequently, with AST, it is easy to
detect and locate nested-IF in a formula as well as convenient to
conduct further analysis based on the tree structure.
In this section, we /f_irst introduce a high-level overview of our
3-step algorithm framework, followed by detailed introductions
to the two key algorithms for redundancy removal and syntax
reassembling, respectively.
Step1: AST generation. We parse each formula and generate
its AST to support the subsequent analysis. AST is a tree repres-
entation of the abstract syntactic structure of source code wri/t_ten
in a programming language. In spreadsheet related research, AST
is usually adopted to indicate formula complexity [ 19]. /T_he larger
depth (height) of the AST, the higher complexity of the formula.
Based on the AST of the formula, we then traverse the AST and
calculate the if-depth . Speci/f_ically, along each path of AST, we re-
cord the number of IFfunctions, and regard the largest one across all
paths as the if-depth of the formula. For example, the if-depth of for-
mula IF(condition 1;IF(condition 2;/v.altalue1;/v.altalue2);IF(condition 3;IF(
condition 4;/v.altalue3;/v.altalue4);/v.altalue5) is 3.
Anested-IF is identi/f_ied in a formula when its if-depth is greater
than 1, and will be passed to the subsequent steps for refactoring
analysis. Otherwise, if the if-depth equals 0 (i.e., no IFin this
formula) or 1 (i.e., no nested-IF in this formula), our algorithm will
bypass the formula directly.
Step2: Redundancy removal. AnIFexpression can essentially
be mapped to an if-else branching statement in professional pro-
gramming. Once the condition on some node remains deterministic
due to its preceding evaluation at some ancestor node on AST, it will
become a redundant condition and one of its child branches must be
dead code. Such redundant conditions are spreadsheet smells that
require removal, since they introduce unnecessary complications
to the spreadsheet data thus may confuse end users. We conduct
such redundancy removal /f_irst, because its existence may also ob-
scure the AST structure from well understood pa/t_terns and thus put
negative impact on our pa/t_tern matching for syntax reassembling.
More details of this step can be found in Section 3.2.
Step3: Syntax reassembling. We have observed another typ-
ical smell in real-world spreadsheets, where single and higher-level
semantics are o/f_ten fragmented by end user into lower-level syn-
tax pieces with nested-IF s. In fact, for such semantics there are
concise and easily understood forms in spreadsheet systems with
built-in functions. /T_he goal of this step is to conduct reverse infer-
ence against such a smell, i.e., to recognize and reassemble such
semantic-fragmented AST regions into their more concise forms via
pa/t_tern matching and replacement. In this paper, we have manuallyidenti/f_ied 9 pa/t_terns for 9 major types of semantics respectively.
/T_hese pa/t_terns are summarized based on our case analysis. First,
we sampled around 100 spreadsheets from the large-scale corpus.
Second, we manually studied the samples and came up with the
pa/t_terns by summarization and abstraction, combining with our
own knowledge. Each pa/t_tern corresponds to a spreadsheet built-in
functions8. We present the name, explanation, and examples of
each alternative function in Table 3. As of the composing of this
paper, there might be other function candidates that remain out of
our knowledge. Nonetheless, our proposed algorithm framework
should be extensible for easy incorporation of new pa/t_terns, and we
do plan to continue related study in the future accordingly. More
details of this step can be found in Section 3.3.
3.2 Redundancy Removal
In this section, we introduce how we identify and remove redundant
conditions in a formula (Step 2). /T_he procedure is presented in
Algorithm 1, with the help of an example /f_low in Figure 2.
1)Nested-IF expression extraction . First, we extract outmost
nested-IF expressions from each formula (see Line 4 in Algorithm 1,
function getParentIfList ). By outmost we mean the highest hier-
archy in a nested branching logic or on an AST. For example, as
shown in Figure 2, for formula SU M (IF(C1;V1;IF(!C1;V2;IF(C2;
V3;V4)));V5), there is only one target nested-IF expression: the out-
most IF expression: IF(C1;V1;IF(!C1;V2;IF(C2;V3;V4))); for for-
mula SU M (IF(C1;V1;V2);IF(C2;V3;IF(!C2;V4;V5));IF(C3;V5;
IF(IF(C4;V6;V7)))), there are two target nested-IF expressions:
IF(C2;V3;IF(!C2;V4;V5)) and IF(C3;V5;IF(IF(C4;V6;V7))). Please
note that the nested-IF targets to be analyzed may also exist in
predicates of a condition node, and we also extract such IFexpres-
sions. For example, IF(C1;V1;IF(!C1;V2;V3)) is also extracted
from the condition part of formula IF(IF(C1;V1;IF(!C1;V2;V3)) =
V1;V3;IF(!C1;V4;V5)). By doing so, we do not miss the chance
of optimizing the nested-IF at condition parts. Moreover, in case
thenested-IF would be reduced as simple predicates, it would po-
tentially increase the chance of eventually optimizing the outmost
nested-IF .
2) Branch collection . Based on the AST of each extracted
nested-IF , we create a dictionary dicConBranch as the key structure
to help detect and remove redundant logic (function /afii10069.italetDicConBranch
in Line 7). As shown in Figure 2, for each entry in the dictionary,
its key is the condition of an AST node such as C1 or C2; the
dBranchList value (Line 10) stores a tuple of two AST sub-trees
corresponding to true and false branches respectively. In addition,
each entry also has a nBranchList value (Line 11) for the negation
of the key condition such as ! C1, and stores the tuple of true and
false branches accordingly. /T_he dictionary is constructed by visit-
ing each condition node on the AST. When the same condition (or
negation) is hit for multiple times, the AST sub-tree tuples at each
hi/t_ting site are appended to the dBranchList (ornBranchList ).
3) Redundancy identi/f_ication and removal . Intuitively, if
any entry stores more than 1 tuple in dBranchList andnBranchList
collectively (Line 12, 24), it indicates existence of redundant branches
on the AST about the condition at key. We iterate such inspection
8Most mainstream spreadsheet tools such as Excel and Google Sheets support these
functions.
3Algorithm 1: Function: removeRedun
Input: Fm: the current nested-IF formula
Input: AST : the AST of Fm
Output: Fm: the new formula
1containRedun TRUE
2while containRedun do
3 containRedun FALSE
4 if List getParentIfList( AST ,Fm)
5 foreachif exp inif List do
6 if T ree = generateAST( if exp )
7 dicConBranch getDicConBranch( if T ree )
8 foreach condition in dicConBranch do
9 branchList dicConBranch.get(condition)
10 dBranchList branchfList.directpart
11 nBranchList branchfList.negativepart
12 ifdBranchfList.len >2then
13 containRedun TRUE // Redundancy exists.
14 redunIFList generateRedunList(condition,
dBranchList)
15 foreach redunIF in redunIFList do
16 ifredunIF in condition.truebranch then
17 Fm Fm.replace(redunIF,
redunIF.truebranch)
18 else
19 Fm Fm.replace(redunIF,
redunIF.falsebranch)
20 end
21 end
22 end
23 ifnBranchList.len >0then
24 containRedun TRUE // Redundancy exists.
25 redunIFList generateRedunList(condition,
nBranchList)
26 foreach redunIF in redunIFList do
27 ifredunIF in condition.falsebranch then
28 Fm Fm.replace(redunIF,
redunIF.truebranch)
29 else
30 Fm Fm.replace(redunIF,
redunIF.falsebranch)
31 end
32 end
33 end
34 AST generateAST( Fm)
35 end
36 end
37end
38return Fm
against dicConBranch to detect and remove redundancies. Each
detected redundancy site corresponds to one redundant IFexpres-
sion that can be replaced with either the true branch (the condition
is deterministic as true) or the false branch (the condition is de-
terministic as false). /T_hus, under each situation, we generate the
redundant IFexpression according to the condition and its branch
list (Lines 15 and 26) and make replacement. For example, as the
example in Figure 2 shows, the nBranchList of key C1 is not null,indicating that IFexpression IF(!C1;V2;IF(C2;V3;V4)) is redund-
ant. Since this expression lies in the false branch of condition C1,
condition ! Cis deterministic as true. /T_herefore, we remove con-
dition ! C1 and its false branch, and only keep the true branch V2.
As a result, the original formula becomes SU M (IF(C1;V1;V2);V5).
Such iteration repeats until no redundancy is detected.
3.3 Syntax Reassembling
A/f_ter removing redundancies, if the resultant formula still contains
nested-IF expressions, in this third step we further analyze the
AST to detect and reassemble fragmented semantics into built-in
functions as listed in Table 3.
3.3.1 General Procedure. In general, this step is in a paradigm
of iterative pa/t_tern-matching and replacement. For each remaining
nested-IF a/f_ter step 2, we further construct a threePartList as the
key structure to facilitate pa/t_tern matching. Each threePartList
consists of three lists for condition, true branch, and false branch, re-
spectively. For example, for expression IF(C1;IF(C2;IF(C3;V1;V2);
V2);V2), the condition part is [ C1;C2;C3], the true branch part is
[IF(C2;IF(C3;V1;V2);V2);IF(C3;V1;V2);V1], and the false part
is [V2;V2;V2].
Subsequently, based on threePartList , we infer the semantic of the
IFexpression and check if it matches some spreadsheet functions.
If yes, we transform the formula using the matched function, and
replace the nested-IF expression with the transformed one. Follow-
ing the order shown in Table 3, we probe each pa/t_tern in sequence.
Once a pa/t_tern is matched, the probe jumps to the next iteration
from the /f_irst pa/t_tern again. /T_his iteration terminates with zero pat-
tern match. Note that the pa/t_terns CHOOSE /MATCH /LOOKU P
have higher priority than the pa/t_tern IFSduring the matching,
because they are more comprehensible and enable more concise ex-
pressions. In the future, we may consider to provide all alternative
refactoring recommendations for end users to choose from.
3.3.2 Alternative Functions. In this paper, we have identi/f_ied 7
categories of pa/t_terns corresponding to 7 types of spreadsheet func-
tions. In this sub-section, we explain the pa/t_terns in details by text
description, AST, and examples. /T_he basic pa/t_terns (with if-depth
of 5 in all examples) are illustrated in Figure 3. Based on speci/f_ic
structures of each pa/t_tern, their pa/t_tern matching algorithms share
the preceding general procedure and diﬀer in minor details.
(1) AND pattern. If anested-IF expression satis/f_ies the follow-
ing conditions, we infer it has the semantic of the AND function,
as shown in Figure 3: /f_irst, the false branches of each condition are
all identical; second, the true branches of each condition are all IF
expressions, except for the last true value (i.e., V1). Such expressions
can be replaced with IF(AN D (conditionlist );truebranch ;f alsebranch ).
For example, the expression with the /f_irst AST in Figure 3 can be
replaced with IF(AN D (C1;C2;C3;C4);V1;V2).
(2) OR pattern. If anested-IF expression satis/f_ies the follow-
ing conditions, we infer that it actually has the semantic of the
OR function, as shown in the second AST of Figure 3: /f_irst, the
true branches of each condition are all identical; second, the false
branches of each condition are all IF expressions, except for the last
false value (i.e., V2). Such kind of expressions can be replaced with
4KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
C1V1T!C1V2TC2V3TV4FFFC1V1T!C1V2TC2V3TV4FFFC1V1TV2FC1C2C3C4V1TV2FTV2FTV2FTV2FANDC1V1TC2V1TC3V1TC4V1TV2FFFFORA1=n1str1TA1=n2str2TA1=n3str3TA1=n4str4TFALSEFFFFCHOOSEA1=str1n1TA1=str2n2TA1=str3n3TA1=str4n4TFALSEFFFFMATCHA1=r1r2TA1=r3r4TA1=r5r6TA1=r7r8TFALSEFFFFLOOKUP
A>BATBFMAXA<BATBFMINC1V1TC2V2TC3V3TC4V4TV5FFFFIFS
Figure 2: Typical AST of function AND,OR,CHOOSE,MATCH,LOOKUP, and IFS.strirepresents a string;nirepresents a number;rirepresents a reference.true branches of each condition are all identical; second, the falsebranches of each condition are all IF expressions, except for the lastfalse value (i.e.,V2). Such kind of expressions can be replaced withIF(OR(conditionlist),true alue,fa l s e alue). For example, the ex-pression with the second AST in Figure 2 can be replaced withIF(OR(C1,C2,C3,C4),V1,V2).(3) CHOOSE pattern.An IF expression that matches theCHOOSE pa￿ern should have the following features. First, allthe conditions are number equality evaluations, the correspond-ing numbers could form a arithmetic progression, which can betranslated into a natural sequences. Second, the false branches ofeach condition are all IF expressions, except for the last false value.￿ird, the true branch values are all strings. For example,IF(A1=1,str1,IF(A1=2,str2,IF(A1=3,str3,IF(A1=4,str4)))) couldbe transformed intoCHOOSE(A1,str1,str2,str3,str4); expressionIF(A1=2,str1,IF(A1=4,str2,IF(A1=6,str3,IF(A1=8,str4))))could be transformed intoCHOOSE(A1/2,str1,str2,str3,str4).(4) MATCH pattern.An IF expression that matches the MATCHpa￿ern should have the following features. First, all the condi-tions are string equality evaluations. Second, the true branchvalues are all numbers that could form a arithmetic progression,which can be translated into a natural sequences.￿ird, the falsebranches of each condition are all IF expressions, except for thelast false value. For example, expressionIF(A1=str1,1,IF(A1=str2,2,IF(A1=str3,3,IF(A1=str4,4)))) could be transformed intoCHOOSE(A1,str1,str2,str3,str4,0); expressionIF(A1=str1,2,IF(A1=str2,4,IF(A1=str3,6,IF(A1=str4,8)))) could be trans-formed into 2⇤CHOOSE(A1,str1,str2,str3,str4,0).(5) LOOKUP pattern.An IF expression that matches the LOOKUP(VLOOKUP or HLOOKUP) pa￿ern should have the following fea-tures. First, all the conditions are reference value equality evalu-ations.￿e references are cell neighbours vertically/horizontally.Second, all the true branches are references that referred to othercells.￿e references are cell neighbours vertically/horizontally, andhave the same columns/rows as the references in the conditions.￿ird, the false branches of each condition are all IF expressions,except for the last false value. For example, as shown in Table 3, ex-pressionIF(A1=C1,D1,IF(A1=C2,D2,IF(A1=C3,D3,IF(A1=C4,D4)))) can be transformed intoVL OOKUP(A1,C1:D4,2,FALSE).￿e above pa￿erns suit the circumstance that the values lookedup can be found directly in other cells. For those cannot be founddirectly, in this paper, we propose to create new tables in the ex-cel to make ease for the look up function. Consequently, as longas the conditions are evaluating the value of a certain cell (do-ing look up based on this cell), we can perform transformationwith the LOOKUP function. For example, for expressionIF(A1=V1,V2,IF(A1=V3,V4,IF(A1=V5,V6,IF(A1=V7,V8)))), wecreate a table ranged (E1:F4), whereE1=V1,F1=V2,E2=V3,F2=V4,E3=V5,F3=V6,E4=V7,F4=V8. In this way, theexpression can be transformed intoVL OOKUP(A1,E1:F4,2).(6) MAX/Min pattern.An IF expression that matches theMAX or MIN pa￿ern should have the following features.￿econdition should do the comparison of two parts, e.g.,A<B,A<=B,A>B,A>=B.￿e true branch and the false branchshould be these two parts respectively. For example, expressionsIF(A<B,A,B),IF(A<=B,A,B),IF(B>A,A,B),IF(B>=A,A,B)can all be transformed intoMIN(A,B); expressionsIF(A>B,A,B),IF(A>=B,A,B),IF(B<A,A,B),IF(B<=A,A,B) can all be trans-formed intoMAX(A,B).(7) IFS pattern.￿e past pa￿ern is the IFS pa￿ern, which is themost￿exible one. As long as the false branches of each conditionare all IF expressions (except for the last one), the expression canbe transformed with the IFS function, as shown in Table 3.Except for the above pa￿erns that match the existing spread-sheet functions, we found another pa￿ern that does not matchany function, but can also be transformed accordingly to removenested IF. We all this pa￿ern the“USELESS”pa￿ern. For example,expressionIF(A=B,A,B) actually equals toAorB. We put thechecking order of this pa￿er before the IFS pa￿ern.4 RESEARCH QUESTIONSIn this paper, we would like to investigate the following four re-search questions.5
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
C1V1T!C1V2TC2V3TV4FFFC1V1T!C1V2TC2V3TV4FFFC1V1TV2FC1C2C3C4V1TV2FTV2FTV2FTV2FANDC1V1TC2V1TC3V1TC4V1TV2FFFFORA1=n1str1TA1=n2str2TA1=n3str3TA1=n4str4TFALSEFFFFCHOOSEA1=str1n1TA1=str2n2TA1=str3n3TA1=str4n4TFALSEFFFFMATCHA1=r1r2TA1=r3r4TA1=r5r6TA1=r7r8TFALSEFFFFLOOKUP
A>BATBFMAXA<BATBFMINC1V1TC2V2TC3V3TC4V4TV5FFFFIFS
Figure 2: Typical AST of function AND,OR,CHOOSE,MATCH,LOOKUP, and IFS.strirepresents a string;nirepresents a number;rirepresents a reference.true branches of each condition are all identical; second, the falsebranches of each condition are all IF expressions, except for the lastfalse value (i.e.,V2). Such kind of expressions can be replaced withIF(OR(conditionlist),true alue,fa l s e alue). For example, the ex-pression with the second AST in Figure 2 can be replaced withIF(OR(C1,C2,C3,C4),V1,V2).(3) CHOOSE pattern.An IF expression that matches theCHOOSE pa￿ern should have the following features. First, allthe conditions are number equality evaluations, the correspond-ing numbers could form a arithmetic progression, which can betranslated into a natural sequences. Second, the false branches ofeach condition are all IF expressions, except for the last false value.￿ird, the true branch values are all strings. For example,IF(A1=1,str1,IF(A1=2,str2,IF(A1=3,str3,IF(A1=4,str4)))) couldbe transformed intoCHOOSE(A1,str1,str2,str3,str4); expressionIF(A1=2,str1,IF(A1=4,str2,IF(A1=6,str3,IF(A1=8,str4))))could be transformed intoCHOOSE(A1/2,str1,str2,str3,str4).(4) MATCH pattern.An IF expression that matches the MATCHpa￿ern should have the following features. First, all the condi-tions are string equality evaluations. Second, the true branchvalues are all numbers that could form a arithmetic progression,which can be translated into a natural sequences.￿ird, the falsebranches of each condition are all IF expressions, except for thelast false value. For example, expressionIF(A1=str1,1,IF(A1=str2,2,IF(A1=str3,3,IF(A1=str4,4)))) could be transformed intoCHOOSE(A1,str1,str2,str3,str4,0); expressionIF(A1=str1,2,IF(A1=str2,4,IF(A1=str3,6,IF(A1=str4,8)))) could be trans-formed into 2⇤CHOOSE(A1,str1,str2,str3,str4,0).(5) LOOKUP pattern.An IF expression that matches the LOOKUP(VLOOKUP or HLOOKUP) pa￿ern should have the following fea-tures. First, all the conditions are reference value equality evalu-ations.￿e references are cell neighbours vertically/horizontally.Second, all the true branches are references that referred to othercells.￿e references are cell neighbours vertically/horizontally, andhave the same columns/rows as the references in the conditions.￿ird, the false branches of each condition are all IF expressions,except for the last false value. For example, as shown in Table 3, ex-pressionIF(A1=C1,D1,IF(A1=C2,D2,IF(A1=C3,D3,IF(A1=C4,D4)))) can be transformed intoVL OOKUP(A1,C1:D4,2,FALSE).￿e above pa￿erns suit the circumstance that the values lookedup can be found directly in other cells. For those cannot be founddirectly, in this paper, we propose to create new tables in the ex-cel to make ease for the look up function. Consequently, as longas the conditions are evaluating the value of a certain cell (do-ing look up based on this cell), we can perform transformationwith the LOOKUP function. For example, for expressionIF(A1=V1,V2,IF(A1=V3,V4,IF(A1=V5,V6,IF(A1=V7,V8)))), wecreate a table ranged (E1:F4), whereE1=V1,F1=V2,E2=V3,F2=V4,E3=V5,F3=V6,E4=V7,F4=V8. In this way, theexpression can be transformed intoVL OOKUP(A1,E1:F4,2).(6) MAX/Min pattern.An IF expression that matches theMAX or MIN pa￿ern should have the following features.￿econdition should do the comparison of two parts, e.g.,A<B,A<=B,A>B,A>=B.￿e true branch and the false branchshould be these two parts respectively. For example, expressionsIF(A<B,A,B),IF(A<=B,A,B),IF(B>A,A,B),IF(B>=A,A,B)can all be transformed intoMIN(A,B); expressionsIF(A>B,A,B),IF(A>=B,A,B),IF(B<A,A,B),IF(B<=A,A,B) can all be trans-formed intoMAX(A,B).(7) IFS pattern.￿e past pa￿ern is the IFS pa￿ern, which is themost￿exible one. As long as the false branches of each conditionare all IF expressions (except for the last one), the expression canbe transformed with the IFS function, as shown in Table 3.Except for the above pa￿erns that match the existing spread-sheet functions, we found another pa￿ern that does not matchany function, but can also be transformed accordingly to removenested IF. We all this pa￿ern the“USELESS”pa￿ern. For example,expressionIF(A=B,A,B) actually equals toAorB. We put thechecking order of this pa￿er before the IFS pa￿ern.4 RESEARCH QUESTIONSIn this paper, we would like to investigate the following four re-search questions.5
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
C1V1T!C1V2TC2V3TV4FFFC1V1T!C1V2TC2V3TV4FFFC1V1TV2FC1C2C3C4V1TV2FTV2FTV2FTV2FANDC1V1TC2V1TC3V1TC4V1TV2FFFFORA1=n1str1TA1=n2str2TA1=n3str3TA1=n4str4TFALSEFFFFCHOOSEA1=str1n1TA1=str2n2TA1=str3n3TA1=str4n4TFALSEFFFFMATCHA1=r1r2TA1=r3r4TA1=r5r6TA1=r7r8TFALSEFFFFLOOKUP
A>BATBFMAXA<BATBFMINC1V1TC2V2TC3V3TC4V4TV5FFFFIFS
Figure 2: Typical AST of function AND,OR,CHOOSE,MATCH,LOOKUP, and IFS.strirepresents a string;nirepresents a number;rirepresents a reference.true branches of each condition are all identical; second, the falsebranches of each condition are all IF expressions, except for the lastfalse value (i.e.,V2). Such kind of expressions can be replaced withIF(OR(conditionlist),true alue,fa l s e alue). For example, the ex-pression with the second AST in Figure 2 can be replaced withIF(OR(C1,C2,C3,C4),V1,V2).(3) CHOOSE pattern.An IF expression that matches theCHOOSE pa￿ern should have the following features. First, allthe conditions are number equality evaluations, the correspond-ing numbers could form a arithmetic progression, which can betranslated into a natural sequences. Second, the false branches ofeach condition are all IF expressions, except for the last false value.￿ird, the true branch values are all strings. For example,IF(A1=1,str1,IF(A1=2,str2,IF(A1=3,str3,IF(A1=4,str4)))) couldbe transformed intoCHOOSE(A1,str1,str2,str3,str4); expressionIF(A1=2,str1,IF(A1=4,str2,IF(A1=6,str3,IF(A1=8,str4))))could be transformed intoCHOOSE(A1/2,str1,str2,str3,str4).(4) MATCH pattern.An IF expression that matches the MATCHpa￿ern should have the following features. First, all the condi-tions are string equality evaluations. Second, the true branchvalues are all numbers that could form a arithmetic progression,which can be translated into a natural sequences.￿ird, the falsebranches of each condition are all IF expressions, except for thelast false value. For example, expressionIF(A1=str1,1,IF(A1=str2,2,IF(A1=str3,3,IF(A1=str4,4)))) could be transformed intoCHOOSE(A1,str1,str2,str3,str4,0); expressionIF(A1=str1,2,IF(A1=str2,4,IF(A1=str3,6,IF(A1=str4,8)))) could be trans-formed into 2⇤CHOOSE(A1,str1,str2,str3,str4,0).(5) LOOKUP pattern.An IF expression that matches the LOOKUP(VLOOKUP or HLOOKUP) pa￿ern should have the following fea-tures. First, all the conditions are reference value equality evalu-ations.￿e references are cell neighbours vertically/horizontally.Second, all the true branches are references that referred to othercells.￿e references are cell neighbours vertically/horizontally, andhave the same columns/rows as the references in the conditions.￿ird, the false branches of each condition are all IF expressions,except for the last false value. For example, as shown in Table 3, ex-pressionIF(A1=C1,D1,IF(A1=C2,D2,IF(A1=C3,D3,IF(A1=C4,D4)))) can be transformed intoVL OOKUP(A1,C1:D4,2,FALSE).￿e above pa￿erns suit the circumstance that the values lookedup can be found directly in other cells. For those cannot be founddirectly, in this paper, we propose to create new tables in the ex-cel to make ease for the look up function. Consequently, as longas the conditions are evaluating the value of a certain cell (do-ing look up based on this cell), we can perform transformationwith the LOOKUP function. For example, for expressionIF(A1=V1,V2,IF(A1=V3,V4,IF(A1=V5,V6,IF(A1=V7,V8)))), wecreate a table ranged (E1:F4), whereE1=V1,F1=V2,E2=V3,F2=V4,E3=V5,F3=V6,E4=V7,F4=V8. In this way, theexpression can be transformed intoVL OOKUP(A1,E1:F4,2).(6) MAX/Min pattern.An IF expression that matches theMAX or MIN pa￿ern should have the following features.￿econdition should do the comparison of two parts, e.g.,A<B,A<=B,A>B,A>=B.￿e true branch and the false branchshould be these two parts respectively. For example, expressionsIF(A<B,A,B),IF(A<=B,A,B),IF(B>A,A,B),IF(B>=A,A,B)can all be transformed intoMIN(A,B); expressionsIF(A>B,A,B),IF(A>=B,A,B),IF(B<A,A,B),IF(B<=A,A,B) can all be trans-formed intoMAX(A,B).(7) IFS pattern.￿e past pa￿ern is the IFS pa￿ern, which is themost￿exible one. As long as the false branches of each conditionare all IF expressions (except for the last one), the expression canbe transformed with the IFS function, as shown in Table 3.Except for the above pa￿erns that match the existing spread-sheet functions, we found another pa￿ern that does not matchany function, but can also be transformed accordingly to removenested IF. We all this pa￿ern the“USELESS”pa￿ern. For example,expressionIF(A=B,A,B) actually equals toAorB. We put thechecking order of this pa￿er before the IFS pa￿ern.4 RESEARCH QUESTIONSIn this paper, we would like to investigate the following four re-search questions.5
KeydBranchListnBranchListC1[V2,IF(!C1,V2,IF(C2,V3,V4))][V2,IF(C2,V3,V4)]C2[V3,V4]NullSUM(IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4))),V5)=>IF(C1, V1, IF(!C1,V2,IF(C2,V3,V4)))
SUM(IF(C1, V1, V2), V5)Figure 2: Redundancy removal process.
C1
C2
C3
C4
V1T
V2FT
V2FT
V2FT
V2FAND
C1
V1T
C2
V1T
C3
V1T
C4
V1T
V2FFFFOR
A1 =n1
str1T
A1 =n2
str2T
A1 =n3
str3T
A1 =n4
str4T
F ALSEFFFFCHOOSE
A1 =str1
n1T
A1 =str2
n2T
A1 =str3
n3T
A1 =str4
n4T
F ALSEFFFFMATCH
A1 =r1
r2T
A1 =r3
r4T
A1 =r5
r6T
A1 =r7
r8T
F ALSEFFFFLOOKUP
A>B
AT
BFMAX
A<B
AT
BFMIN
C1
V1T
C2
V2T
C3
V3T
C4
V4T
V5FFFFIFS
Figure 3: Typical AST of function AND,OR,CHOOSE,MATCH,LOOKUP, MAX,MIN, and IFS. strirepresents a string; nirepres-
ents a number; rirepresents a reference ( 0<i<5).
Table 3: /T_he advanced functions
Name Explanation Transformation Examples
AND Returns TRUE if all of the arguments evaluate to TRUE. I F(C1;I F(C2;I F(C3;V1;V2);V2);V2)!I F(AN D (C1;C2;C3);V1;V2)
OR Returns TRUE if any argument evaluates to TRUE. I F(C1;V1;I F(C2;V1;I F(C3;V1;V2)))!I F(OR(C1;C2;C3);V1;V2)
CHOOSE Returns a value from a list using a given position or index. I F(A1 = 1 ;str1;I F(A1 = 2 ;str2;I F(A1 = 3 ;str3)))!
CHOOSE (A1;str1;str2;str3)
MATCH Returns a number representing a position in an array. I F(A1 =str1;1;I F(A1 =str2;2;I F(A1 =str3;3)))!
MATCH (A1;fstr1;str2;str3g;0)
LOOKUP Perform a vertical/horizontal lookup (corresponding to func-
tion VLOOKUP and HLOOKUP) by searching for a value in
the /f_irst column/row of a table and returning the value in the
same row/column in the index position.I F(A1 =C1;D1;I F(A1 =C2;D2;I F(A1 =C3;D3;I F(A1 =C4;D4))))!
V LOOKU P (A1;C1 :D4;2;F ALSE )
MAX/MIN Return the largest/smallest value from a supplied set of nu-
meric values.I F(A>B;A;B)!MAX (A;B)
IFS Run multiple tests and return a value corresponding to the
/f_irst TRUE result.I F(C1;V1;I F(C2;V2;I F(C3;V3;I F(C4;V4)))) !
I F S(C1;V1;C2;V2;C3;V3;C4;V4)
IF(OR(conditionlist );true/v.altalue;f alse /v.altalue). For example, the ex-
pression with the second AST in Figure 3 can be replaced with
IF(OR(C1;C2;C3;C4);V1;V2).
(3) CHOOSE pattern. Anested-IF expression that matches
the semantic of CHOOSE function [ 20] should have the following
features. First, all the conditions are number equality evaluations,
with the corresponding numbers forming an arithmetic progression,
which can be translated into natural sequences. Second, the false
branches of each condition are all IF expressions, except for the last
false value. /T_hird, the true branch values are all strings. For example,
IF(A1 = 1 ;str1;IF(A1 = 2 ;str2;IF(A1 = 3 ;str3;IF(A1 = 4 ;str4))))
could be transformed into CHOOSE (A1;str1;str2;str3;str4); ex-
pression IF(A1 = 2 ;str1;IF(A1 = 4 ;str2;IF(A1 = 6 ;str3;IF(A1 =
8;str4)))) could be transformed into CHOOSE (A1=2;str1;str2;str3;
str4).
(4) MATCH pattern. Anested-IF expression that matches the
semantic of MATCH function [ 21] should have the following fea-
tures. First, all the conditions are string equality evaluations. Second,
the true branch values are all numbers that could form an arith-
metic progression, which can be translated into a natural sequence./T_hird, the false branches of each condition are all IF expressions,
except for the last false value. For example, expression IF(A1 =
str1;1;IF(A1 =str2;2;IF(A1 =str3;3;IF(A1 =str4;4)))) could be
transformed into MATCH (A1;str1;str2;str3;str4;0); expression
IF(A1 =str1;2;
IF(A1 =str2;4;IF(A1 =str3;6;IF(A1 =str4;8)))) could be trans-
formed into 2MATCH (A1;str1;str2;str3;str4;0).
(5) LOOKUP pattern. Anested-IF expression that matches
the semantic of VLOOKUP/HLOOKUP9pa/t_tern [ 22,23] should
have the following features. First, all the conditions are equality
evaluations of reference values. /T_he references are cell neighbors
vertically/horizontally. Second, all the true branches are refer-
ences that referred to other cells. /T_he references are cell neighbors
vertically/horizontally, and have the same columns/rows as the
references in the conditions. /T_hird, the false branches of each con-
dition are all IF expressions, except for the last false value. For
example, as shown in Table 3, expression IF(A1 =C1;D1;IF(A1 =
C2;D2;IF(A1 =C3;D3;IF(A1 =C4;D4)))) can be transformed into
V LOOKU P (A1;C1 :D4;2;FALSE ).
9/T_he “V” and “H” refer to “vertical” and “horizontal” respectively.
5/T_he above pa/t_terns suit the circumstance that the values looked
up can be found directly in other cells. For those that cannot be
found directly, in this paper, we propose creating new tables in the
worksheets to make ease for the look up function. Consequently,
as long as the conditions are evaluating the value of a speci/f_ic cell
(doing look up based on this cell), we can perform transformation
with the LOOKUP function. For example, for expression IF(A1 =
V1;V2;IF(A1 = V3;V4;IF(A1 = V5;V6;IF(A1 = V7;V8)))), we
create a table ranged ( E1 :F4), where E1 =V1,F1 =V2,E2 =V3,
F2 =V4,E3 =V5,F3 =V6,E4 =V7,F4 =V8. In this way, the
expression can be transformed into V LOOKU P (A1;E1 :F4;2).
(6) MAX/MIN pattern. Anested-IF expression that matches
the semantic of MAX or MIN pa/t_tern should have the following
features. /T_he condition should do the comparison of two parts,
e.g., A<B,A<=B,A>B,A>=B. /T_he true branch and the
false branch should be these two parts respectively. For example,
expressions IF(A<B;A;B),IF(A<=B;A;B),IF(B>A;A;B),
IF(B>=A;A;B) can all be transformed into MIN (A;B); expressions
IF(A>B;A;B),IF(A>=B;A;B),IF(B<A;A;B),IF(B<=A;A;B)
can all be transformed into MAX (A;B).
(7) IFS pattern. /T_he IFS pa/t_tern has the fewest conditions. As
long as the false branches are IF expressions (except for the leaves),
the expression can be transformed with the IFS function, as shown
in Table 3. Note that this pa/t_tern makes the fewest syntax changes
comparing to the original syntax, and the number of conditions
remain the same. However, the IFS function has the advantage
of conciseness and readability, and there is also no need to worry
about the IF statements and parentheses [ 24]. Additionally, there
is no need to supply a value if the condition is false (unlike the
nested-IF expression which needs another IF expression to serve
as the false branch) [ 25]. Our survey of end users re/f_lects these
advantages as well (see Section 4.5).
(8) USELESS pattern. Except for the above pa/t_terns that match
the existing spreadsheet functions, we /f_ind another pa/t_tern that
does not match any function, but can also be transformed accord-
ingly to remove nested IF. We call this pa/t_tern the “USELESS”
pa/t_tern. For example, expression IF(A=B;A;B) actually equals A
orB. We put the checking order of this pa/t_ter just before the IFS
pa/t_tern.
For ease of presentation, we unify the condition redundancy,
the USELESS pa/t_tern, and the 7 types of advanced functions all as
“pa/t_terns”.
4 EVALUATION
4.1 Research /Q_uestions
In this paper, we investigate the following four research questions.
RQ1: Are the refactored formulae functionally equal to the
original ones? /T_his question aims to check the correctness of our
refactoring approach.
RQ2: What is the refactor coverage of our approach? /T_his
question aims to check the applicability of our approach: how
many nested-IF formulae can our approach handle.
RQ3: What is the refactor eﬀectiveness of our approach?
/T_his question aims to check whether our refactorings relieve the
nested-IF smells: how much can our approach decrease the if-depth
ofnested-IF formulae.Table 4: Refactor coverage
Formula Set Original Refactored Refactor Coverage
Total 27,689,299 27,645,688 99.84%
Unique 19,260,407 19,243,407 99.91%
RQ4: Do end users prefer the refactored formulae? /T_his ques-
tion aims to /f_ind out the necessity of refactoring from the respective
of end users, as well as whether end users prefer the refactored
formula our approach provides.
4.2 Refactor Equality
To answer the /f_irst research question, we conduct manual inspection
as well as formula calculation result comparison.
For manual inspection, considering that there are over 10 million
formulae and it is impossible to check the refactorings one by one,
we randomly select 2000 formula pairs <Fo;Fr>(Forepresents
the original formula, Frrepresents the refactored formula). /T_he /f_irst
three authors then check each pair and record their judgements.
For formula value comparison, we scan all Excel /f_iles and replace
the original nested-IF formulae with the refactored ones. For each
formula pair <Fo;Fr>, we get a responding value pair <Vo;Vr>.
We thus record whether Voequals Vr. To automatically achieve
the above process, we use ClosedXML , which is a powerful .NET
library enabling users to create and modify Excel /f_iles.
Our experiment results indicate that either manual inspection
or value comparison indicates a 100% correctness of the refactored
formulae. /T_his result reveals the reliability of our refactoring results.
4.3 Refactor Coverage
To answer the second research question, we present the total pro-
portion of refactored formulae in Section 4.3.1, the proportion of
formulae handled by each pa/t_tern in Section 4.3.2, and the propor-
tion of formulae handled by more than one pa/t_terns in Section 4.3.3.
4.3.1 Total Coverage. For the original total set of nested-IF for-
mulae Ototal and original unique set Ounique , we conduct auto-
matic refactoring following the refactoring procedure introduced
in Section 3. Correspondingly, we get the refactored set Rtotal (out
ofOtotal ) and Runique (out of Ounique ). /T_he refactor coverage
can then be calculated as#Rtotal
#Ototal100% and#Runique
#Runique100% (#
represents the number).
Table 4 presents the refactor coverage results. /T_he /f_irst row is
for the total formula set, the second row is for the unique formula
set. From this table, our approach is able to handle almost all the
nested-IF formulae, with a refactor coverage of over 99%.
We also observe that there are around 43,000 nested-IF formu-
lae that cannot be automatically refactored. We analyze them and
found that they can be categorized into two types. In the /f_irst type,
the condition part of the outmost IF expression contains another IF
expression and does not match our pa/t_terns even if being treated as
a whole, such as IF(AN D (IFsubexpression 1;IFsubexpression 2) =
TRU E ;/v.altalue1;/v.altalue2). In the second type, although the inner IF
expression lies in the branches of the outer expression, it is wrapped
with other non-IF functions, and thus the AST is quite complex, such
asIF(Condition ;SU M (IFsubexpression 1;IFsubexpression 2);/v.altalue).
6Table 5: Refactor coverage of each pattern
PatternTotal Unique
Refactored Coverage Refactored Coverage
REDUN 1,766,803 6.39% 1,250,006 6.50%
AND 2,322,346 8.40% 2,206,296 11.47%
OR 4,169,992 15.08% 2,099,450 10.91%
CHOOSE 165,594 0.60% 141,695 0.74%
MATCH 23,254 0.08% 9,331 0.05%
LOOKUP 1,780,419 6.44% 1,637,564 8.51%
MAXMIN 234,960 0.85% 214,452 1.11%
USELESS 83,060 0.30% 69,912 0.36%
IFS 18,239,046 65.97% 12,520,577 65.06%
4.3.2 Coverage of Each Single Pa/t_tern. We next investigate the
coverage of each pa/t_tern. To do this, for each refactored formula, we
assign it with a pa/t_tern list pList = [REDU N ;AN D ;OR;CHOOSE ;
MATCH ;LOOKU P ;MAXMIN ;U SELESS ;IFS] (REDU N represents
redundancy) recording which pa/t_terns are adopted during the re-
factoring process. Because the MAX andMIN are quite similar, we
merge them into one MAXMIN . /T_he adopted pa/t_terns are assigned
with a value of 1, otherwise their values are 0.
For example, for formula IF(condition 1;/v.altalue1;IF(cell1>cell2;
cell1;cell2)), our approach will refactor it into IF(condition 1;/v.altalue1;
MAX (cell1;cell2)),and thus pList = [0;0;0;0;0;0;1;0;0]. Each for-
mula would have a list. In this way, we will get a matrix of all
pa/t_terns with the total formula set, based on which it is easy to
calculate the proportion of the formulae that each pa/t_tern handles.
We present the /f_inal results in Table 5. Column “Total” shows the
results of the total formula set. Column “Unique” shows the results
of the unique formula set. Column “Coverage” shows the proportion
of formulae that each pa/t_tern handles against all original formulae.
/T_he /f_irst row presents the results of redundant conditions, the
remaining rows show the results of diﬀerent alternative functions.
As shown in Table 5, around 6% formulae contain redundant
conditions. /T_his is rather surprising, because redundant conditions
are somewhat low-level spreadsheet smells users should not make if
they know the basic structure of IFexpressions. /T_he dead branches
caused by redundant conditions are like the dead code in traditional
programming, and should be removed de/f_initely. /T_hese results
re/f_lect the fact that end users may lack the basic knowledge of
programming, even in understanding conditional logic.
For the pa/t_terns, the AND, OR, and LOOKUP pa/t_terns handle
around 6%-15% of formulae respectively, the IFS pa/t_tern handles as
high as 65% of formulae. /T_he remaining pa/t_terns such as MATCH,
CHOOSE, and USELESS handle less than 2% respectively. /T_he high
refactor coverage of the IFS pa/t_tern is not surprising, because as we
introduced in Figure 3, IFS has the fewest conditions which most
nested-IF expressions match.
4.3.3 Coverage of Multi Pa/t_terns. As our approach will repeatedly
try diﬀerent pa/t_terns until no IFexpressions can be removed, some
formulae may be handled by more than one pa/t_tern during the
repeat. Corresponding to the pList (introduced in Section 4.3.2)
of this formula, more than one element would have value “1”. To
investigate the frequency of such circumstances, we record the
formulae handled by multi pa/t_terns.Table 6: Number of formulae processed by multi-patterns
Pattern Num Total Unique
2 1,019,035 (3.69%) 785,156 (4.1%)
3 60,843 (0.22%) 60,825 (0.32%)
total 1,079,878 (3.91%) 845,981 (4.40%)
Figure 4: Circos chart of the overlap between patterns.
/T_he results are shown in Table 6. In summary, at most 3 pa/t_terns
are applied to process a formula. 3.91%/4.40% of the total/unique set
of refactored formulae are processed with more than one pa/t_terns.
We also present the speci/f_ic overlap of diﬀerent pa/t_terns (of the
total set), as shown in Figure 4. /T_he /f_igure is a circos10visualization.
/T_he pa/t_tern segment size re/f_lects the scale of refactored formulae
of each pa/t_tern (shown in Table 4). /T_he lines between diﬀerent
segments are called cells. /T_he thickness of these cells can indicate
the absolute number of overlapped formulae between diﬀerent
pa/t_terns. As shown in this /f_igure, the IFS pa/t_tern has overlap with
almost all other pa/t_terns, except AND, MATCH, CHOOSE. /T_his
is because the IFS pa/t_tern has the fewest conditions and many
formulae satisfy them (as the example in Section 2 shows). MATCH
has no overlap with any pa/t_tern. /T_he reason may be that formulae
that match the MATCH pa/t_tern are usually very regular and have
simple semantics.
4.4 Refactor Eﬀectiveness
To answer the third research question, we present the absolute
if-depth reduction results in Section 4.4.1, the relative if-depth re-
duction (the depth reduction rate) in Section 4.4.2, and the /f_inal
if-depth of refactored formulae in Section 4.4.3.
4.4.1 Absolute Depth Reduction. First, we would like to know
how many if-depths can our approach reduce on the refactored
formulae. For each refactored formula pair <Fo;Fr>, we parse Fo
andFrand calculate their respective if-depth :depo,depr. /T_he depth
reduction DepReduce num is then calculated by DepReduce num =
depo depr.
Table 7 presents the results for the unique set. Row “Formula
Number” presents the number of formulae that was refactored with
the corresponding depth reduction. For example, in the /f_irst cell,
the number 7,885,404 means that among all the refactored formulae,
7,885,404 of them have a if-depth reduction of 1. From the table,
10h/t_tp://mkweb.bcgsc.ca/tableviewer/visualize/
7Table 7: Absolute number of if-depth reduction for Unique.
Depth Reduce 1 2 3 4 5 6 7 8 9 10 11 12 13
Number 7,885,404 5,284,297 2,280,668 836,304 418,525 96,353 1,790,044 454,225 38,614 5,772 45,452 47,105 6,927
Depth Reduce 14 15 16 19 20 22 24 27 28 29 36 39 48
Number 6,302 12,214 507 10,200 1 12 10,200 1,963 490 490 2 795 10,541
(0%,25%], 0(25%,50%], 10231301(50%,75%], 2378167(75%,100%], 15036220Total
(0%,25%], 0(25%,50%], 7884846(50%,75%], 1987628(75%,100%], 9370933Unique
Figure 5: Distribution of diﬀerent depth reduction ratios.
Table 8: Number of formulae with diﬀerent new depth
Total Unique
New Depth Formula Num New Depth Formula Num
013,906,460 (50.30%) 0 8,723,082 (45.33%)
113,717,158 (49.62%) 110,498,258 (54.56%)
2 22,070 2 22,067
our approach is able to reduce the if-depth with various degrees,
indicating the eﬀectiveness of our approach.
Most of the refactorings have a depth reduction of below 5.
However, the absolute depth reduction results shown in this table
depend on the amount of original formulae with diﬀerent if-depths .
A formula with 2 nested-IF functions can have a depth reduction
of 2 at most. To relieve this problem, we also present the relative
depth reduction results in Section 4.4.2 as well as the /f_inal new
if-depth of the refactored formulae in Section 4.4.3.
4.4.2 Relative Depth Reduce. As mentioned above, only present-
ing the absolute number of depth reduction may fail to re/f_lect the
real eﬀectiveness. In this section, we also present the results of relat-
ive depth reduction: DepReduce ratio =DepReduce num=depo. For
ease of presentation, we divide DepReduce ratio into four ranges:
(0%;25%]11, (25% ;50%], (50% ;75%], and (75% ;100%]. /T_he distribu-
tion of each range is presented in Figure 5.
From the /f_igure, in general over half of the refactoring reduc-
tion is over 50% of if-depth . In particular, for the total and unique
set of refactored formulae, most refactorings fall into the range
of (25% ;50%] and (75% ;100%], indicating that our relative depth
reduction results are good.
4.4.3 Final Depth A/f_ter Refactoring. Except for the absolute and
relative depth reduction results, we check whether the refactored
formulae still have large if-depth . To answer this question, we
investigate the new if-depth deprof each refactored formula Fr.
/T_he results are shown in Table 8.
From the table, most of the refactorings yield a new if-depth of 0
or 112, indicating that our approach is able to completely remove
thenested-IF functions in most formulae.
110%<DepReduce ratio <=25%
12if-depth of 0 and 1 are equally eﬀective in relieving nested IF smells, because either of
them avoid the smell completely.
2017/8/25
4Q3:Before this survey, do you know how to manually refactor F1 to F2?  [  ] Yes, I know [  ] No, I don’t know.Q2:Do you prefer F1 or F2?
Q4:Will it be helpful to automaticallyrefactor F1 to F2?EndThanks!Reason:__________________
Reason:__________________StartPlease have a look at F1 and F2
F2F1
YesNo[   ] A:F2 is shorter[   ] B:F2 is less complex[   ] C:F2 is easier to understand[   ] D:F2 is not easy to make mistakesPlease tick your reason(s):Q1:Before this survey, do you know F1 equals to F2? [  ] Yes, I know [  ] No, I don’t know.Figure 6: Survey questions.
4.5 Preference of End Users
In this section, we explore end users’ a/t_titude towards the nested-
IFformulae and the refactored formulae. Our survey includes 49
participants. 26 of them have been using use spreadsheets quite of-
ten (over 5 times per-week), 18 of them use spreadsheet sometimes
(about once per-week), 2 occasionally (about once per-month), and 3
rarely use them. Additionally, about two thirds of them are employ-
ees employed in banks, law /f_irms, telecommunication companies,
and so on. /T_he remaining ones are mainly college students.
Our survey includes seven parts. Each part contains one repres-
entative pa/t_tern13. For each pa/t_tern, we present two functionally
equivalent spreadsheet formulae F1 and F2 and several questions
concerning the participants’ preferences. For example, for the
AND pa/t_tern, we /f_irst describe a function like “If three conditions
Condition1, Condition2, Condition3 are all TRUE, return Value1;
otherwise return Value2.”. /T_hen, F1 and F2 will be presented as: F1 :
IF(Condition 1;IF(Condition 2;IF(Condition 3;Value 1;Value 2);
Value 2);Value 2),F2 :IF(AN D (Condition 1;Condition 2;Condition 3);
Value 1;Value 2). At the beginning, the participants are invited to
have a look at a formula pair. /T_hen, they are supposed to answer
four questions as shown in the /f_irst column of Figure 6. /Q_ues-
tion Q1 investigates participant’s basic knowledge. Q2 investigates
participant’s preference (between FoandFr). Q3 and Q4 checks
whether a participant lacks the knowledge of manual refactoring
and whether automatic refactoring is needed. As each of the 49
participants are supposed to /f_inish the seven parts one by one, for
each question we collect 49 7 = 343 answers. We call each answer
a “case”.
/T_he survey results are shown in Table 9. Row “A2.A” “A2.D” are
concerned with the reasons why participants prefer F2 (the refact-
ored formula). We /f_irst focus on the total survey results shown
in Column “Total” and “Prop.”. From this table, only under 28.57%
13Pa/t_tern AND and OR are combined, as are MAX and MIN.
8Table 9: Feedback from end users
Answer Redundancy AND/OR CHOOSE MATCH LOOKUP MAX/MIN IFS Total Prop.
A1: I know F1 equals to F2. 17 18 12 10 8 24 9 98 28.57%
A2: I prefer F2. 45 46 46 48 43 45 45 318 92.71%
A2.A:F2 is shorter. 24 23 26 26 28 27 23 177 51.60%
A2.B:F2 is less complex. 41 41 29 29 34 31 37 242 70.55%
A2.C:F2 is easier to understand. 31 26 29 29 24 27 24 190 55.39%
A2.D:F2 is not easy to make mistakes. 17 18 20 20 33 22 17 147 42.86%
A3: I can refactor manually. 11 11 10 9 7 20 4 72 20.99%
A4: Automatic refactoring is helpful. 48 49 48 48 49 49 48 339 98.83%
cases participants have the knowledge to judge the equivalence
between F1 and F2. 92.71% of cases participants prefer the refact-
ored formulae. All four reasons we listed have high votes, with
“A2.B:F2 is less complex. ” the highest. Only with 20.99% cases parti-
cipants have the ability to manually refactor. 98.83% believe that
our automated refactoring approach is necessary and helpful.
Note that there are still around 7% (24) of the cases where parti-
cipants do not like the refactored formulae. We look into their com-
ments and /f_ind that in 6 cases the participants prefer F1 because they
have no idea which one is be/t_ter and choose one answer randomly.
In one case the participant said that IF(cell1>cell2;cell1;cell2) is
be/t_ter than MAX (cell1;cell2) because when cell1 equals cell2, the
result is more speci/f_ic. In all the remaining 17 cases the participants
prefer F1because they do not have knowledge related to F2. Sim-
ilarly, there are 1% cases where participants regard our approach
helpless, and all of the reasons are that they lack knowledge about
the refactored formulae. /T_hese negative opinions are quite valuable,
indicating that in practical application, it is necessary to provide
knowledge related to new functions to help end users understand
them be/t_ter. A possible application scenario may be that refact-
oring will not be conducted without the permission of end users.
/T_hey may get some refactor suggestions as well as explanations,
and could choose whether they would like to adopt the suggestion.
More discussion about the application scenario can be found in
Section 5.
We then focus on the answers of diﬀerent pa/t_terns. LOOKUP
and IFS are known to the fewest participants, while MAXMIN is
known to the most participants. More people think that LOOKUP
are less error-prone comparing to other pa/t_terns. /T_he other answers
more or less have no obvious diﬀerences among diﬀerent pa/t_terns.
5 DISCUSSION
In this section, we discuss the application scenario (in Section 5.1)
and the future work of our approach (in Section 5.2).
5.1 Application
Our application scenario is to make our approach a spreadsheet
plug-in. When an end user /f_inishes writing a formula with nested
IF functions, the plug-in may identify whether the formula can be
refactored. If yes, it alerts that these nested IFs are bad smells, and
provides refactor suggestions. Note that in this paper each formula
will yield one speci/f_ic refactor result, while it is also applicable
that we generate diﬀerent refactoring results: for the formulae that
can be handled by multiple pa/t_terns, each pa/t_tern corresponds to
one result. All the results can be ranked and serve as suggestioncandidates, so that the end users can choose which ever they like.
Note that from our survey results introduced in Section 4.5, it
maybe be/t_ter if we provide explanations of each suggestion to aid
the understanding of end users. We will develop and present such
a plug-in in future work.
5.2 Limitations and Future Work
/T_here are several directions that our approach can be improved.
First, there may be be/t_ter application scenarios. Except for the
application scenario introduced above, another more intelligent one
is to provide possible refactoring suggestions before the end users
/f_inish writing the formula. /T_his scenario especially suits (intended)
nested-IF formulae with high if-depth . For example, suppose that an
end user intends to write a 30-depth Nest-IF formula, it would be
useful if we identify the possible semantics when the user starts to
write the 10th nested IF expression. In this way, the user may skip
the verbose writing of the remaining 20 depth and choose to use
the suggested function. Another advantage is that this application
scenario can help users to avoid making errors aroused from using
nested-IF formulae. /T_his application scenario is applicable. In future
we plan to use machine learning techniques to infer the semantics
of a formula based on a part of its syntax.
Second, the refactor eﬀectiveness can be further improved. Al-
though our approach is currently eﬀective in relieving the smell of
nested-IF formulae, the coverage of some pa/t_terns can be enlarged.
For example, for the formula in Section 2: IF(Q1 =X1;Q1;IF(Q1 =
“”;X1;Q1), except for the IFS pa/t_tern, it would also match the OR
pa/t_tern if we transform it into IF(Q1 =X1;Q1;IF(Q1! = “” ;Q1;X1)
(refactored as IF(OR(Q1 =X1;Q1! = “”) ;Q1;X1)). In other words,
it is interesting to explore how to preprocess a formula to make it
be/t_ter prepared for refactoring.
/T_hird, the refactor coverage can be further improved. /T_here are
some nested-IF formulae out of our refactoring ability, such as the
two types mentioned in Section 4.3. Also, our current pa/t_terns are
not the universal set. /T_here must be some other pa/t_terns that can
also contribute to the nested IF problem, yet are outside of our
current knowledge. Nevertheless, the main idea of the approach
remains eﬀective, and we would complement the pa/t_tern set upon
/f_inding other good pa/t_tern candidates.
6 RELATED WORK
End user programming has been studied since 1993 [ 26]. Spread-
sheets have been recognized as the most successful and most popu-
lar form of end user programming [ 6]. Current research on spread-
sheets mainly follows the trend of applying traditional so/f_tware
9engineering methods to deal with spreadsheet problems. For ex-
ample, most research focus on smell detection [ 4,5,14,27–32], fault
detection and automatic repair [ 33–38], clone detection [ 39–41],
refactoring [4, 13, 31], visualisation [42–45], and so on.
/T_he research work most related to ours include smell detection
and refactoring. /T_he former is related to the motivation of this
paper: why nested-IF formulae are bad smells. /T_he la/t_ter is related
to the approach of this paper: how to refactor spreadsheets to
reduce smells. We next introduce these two aspects one by one.
6.1 Smell Detection
Same as code smells [ 46], spreadsheets smells refer to some char-
acteristics that may cause problems. Smells have diﬀerent levels:
formula-level, cell level, and structural level. We mainly introduce
the formula-level ones.
Abreu et.al. [ 5] combines 15 smells to indicate potential faults.
/T_hey treat conditional complexity as one of the key smells. /T_he
results indicate that this smell only can detect 6 spreadsheet faults.
Hermans et.al. [ 4] regard conditional complexity as one of the
/f_ive smells, because even in traditional professional programming,
conditional complexity is a threat to code readability. However,
according to their results derived from EUSES, on average each
spreadsheet only has 3 formulae containing at least one condition,
while from our corpus, we /f_ind that on average each spreadsheet
has 1,193 formulae containing conditions; from the corpus of Enron,
the number is 217. /T_he reason for this huge diﬀerence may be that
EUSES contains a lot of toy spreadsheets created by users who
rarely use spreadsheet formulae.
Hermans et.al. [ 4] also mention that end users already know the
bad eﬀects of conditional complexity. Our survey results con/f_irm
this statement: around half of the participants think that formulae
with high conditional complexity are more complex and error-
prone; 70.55% think that they are harder to understand.
Another work of Hermans et.al. [ 6] present an overview of so/f_t-
ware engineering approaches applied to spreadsheets. /T_hey claim
that most spreadsheets contain formulae with multiple IF condi-
tions, which is an obvious spreadsheet smell.
6.2 Formula Refactoring
Badame and Dig [ 12] are the /f_irst to propose refactoring in the
spreadsheet domain. A tool – ReeBook – is presented, with which
seven refactoring pa/t_terns are presented. /T_hese seven pa/t_terns
target at diﬀerent smells. For example, pa/t_tern MAKE CELL CON-
STANT aims to make formulae less error prone and more readable
by adding the $ symbol. However, their approach is disperse and
can handle only simple formulae. For example, one of their refact-
oring pa/t_terns is called “REPLACE AWKWARD FORMULA”, which
only focus on the SUM function (e.g., replace B5 +C5 +D5 +E5 with
SU M (B5 :E5) ). /T_hey evaluate their approach on EUSES corpus and
/f_ind that their refactoring can be applied to many formulae. How-
ever, they only present the number of formulae that are “potential
candidates” for each pa/t_tern, while not presenting the actual num-
ber of successfully refactored formulae. /T_hus, the refactor coverage
and eﬀectiveness are unknown.
Hermans et.al. [ 4] de/f_ined diﬀerent refactoring according to their
smells. /T_he results indicate that their refactoring approach is ableto relieve the smells of 87% formulae. However, their approach does
not support automated refactoring.
Later on, Hermans and Dig [ 13] combine the two approaches
above and present BumbleBee, which is a refactoring tool allowing
a formula to be refactored based on the de/f_ined transformation rules.
Several pa/t_terns such as MAXMIN and OR are also mentioned in
the paper. However, the formula can be refactored only when
the transformation rule is de/f_ined, while according to our survey,
only 20.99% of participants may have the knowledge of de/f_ining
transformation rules. /T_he work of Hoepelman [ 47] expand this
work and introduces more refactoring support.
To sum up, currently several works aim to tackle the challenges
brought by spreadsheet smells, while no automatic and high-coverage
refactoring approach is available. We propose to systematically
tackling the nested-IF formulae refactoring problem, which is able
to handle almost all formulae with high depth-reduce eﬀectiveness.
7 CONCLUSION
We propose a spreadsheet formula refactoring approach aiming
to automatically relieve the smells of nested IF functions. We /f_irst
try to identify if the formula contains redundant conditions. A/f_ter-
wards, we identify the semantics of the combination of nested IFs
and replace them with an alternative spreadsheet function. Evalu-
ation on a very large real world spreadsheet corpus indicates that
the refactor eﬀectiveness is impressive: most of the nested-IF for-
mulae can be refactored. Our survey of 49 participants reveals that
the majority of them like our refactoring approach and think it is
helpful.
10REFERENCES
[1]wiki. End user development. h/t_tps://en.wikipedia.org/wiki/End-user
development, 2015.
[2] Margaret M Burne/t_t and Christopher Scaﬃdi. 10. end-user development.
[3]Felienne Hermans, Martin Pinzger, and Arie van Deursen. Detecting and re-
factoring code smells in spreadsheet formulas. Empirical So/f_tware Engineering ,
20(2):549–575, 2015.
[4]Felienne Hermans, Martin Pinzger, and Arie van Deursen. Detecting and re-
factoring code smells in spreadsheet formulas. Empirical So/f_tware Engineering ,
20(2):549–575, Apr 2015.
[5] R. Abreu, J. Cunha, J. P. Fernandes, P. Martins, A. Perez, and J. Saraiva. Smelling
faults in spreadsheets. In Proc. ICSME , pages 111–120, Sept 2014.
[6]F. Hermans, B. Jansen, S. Roy, E. Aivaloglou, A. Swidan, and D. Hoepelman.
Spreadsheets are code: An overview of so/f_tware engineering approaches applied
to spreadsheets. In Proc. SANER , volume 5, pages 56–65, March 2016.
[7] Michele Tufano, Fabio Palomba, Gabriele Bavota, Rocco Oliveto, Massimiliano
Di Penta, Andrea De Lucia, and Denys Poshyvanyk. When and why your code
starts to smell bad. In Proc. ICSE , pages 403–414. IEEE Press, 2015.
[8] Dave Bruns. 19 tips for nested IF formulas. h/t_tp://h/t_tps://exceljet.net/nested-ifs,
2016.
[9]reddit. Is it a good or bad practice reducing nested if statements.
h/t_tps://www.reddit.com/r/csharp/comments/33puzj/is itagood orbad
practice reducing nested if/, 2015.
[10] reddit. Never use nested IFs again. h/t_tps://www.reddit.com/r/excel/comments/
2slys1/never usenested ifsagain/, 2015.
[11] Felienne Hermans and Emerson Murphy-Hill. Enron’s spreadsheets and related
emails: A dataset and analysis. In Proc. ICSE , pages 7–16. IEEE Press, 2015.
[12] Sandro Badame and Danny Dig. Refactoring meets spreadsheet formulas. In
Proc. ICSM , pages 399–409. IEEE, 2012.
[13] Felienne Hermans and Danny Dig. Bumblebee: a refactoring environment for
spreadsheet formulas. In Proc. ICSE , pages 747–750. ACM, 2014.
[14] Marc Fisher and Gregg Rothermel. /T_he euses spreadsheet corpus: a shared
resource for supporting experimentation with spreadsheet dependability mech-
anisms. In ACM SIGSOFT So/f_tware Engineering Notes , volume 30, pages 1–5.
ACM, 2005.
[15] Salvatore Aurigemma and Raymond R Panko. /T_he detection of human spread-
sheet errors by humans versus inspection (auditing) so/f_tware. arXiv preprint
arXiv:1009.2785 , 2010.
[16] E Gazoni and C Clark. openpyxl-a python library to read/write excel 2010
xlsx/xlsm /f_iles, 2016.
[17] T. Schmitz and D. Jannach. Finding errors in the enron spreadsheet corpus. In
Proc. VL/HCC , pages 157–161, 2016.
[18] Bas Jansen. Enron versus euses: A comparison of two spreadsheet corpora. arXiv
preprint arXiv:1503.04055 , 2015.
[19] /T_homas Reschenhofer, Bernhard Waltl, Klym Shumaiev, and Florian Ma/t_thes. A
conceptual model for measuring the complexity of spreadsheets. arXiv preprint
arXiv:1704.01147 , 2017.
[20] CHOOSE. CHOOSE function. h/t_tps://support.oﬃce.com/en-us/article/
CHOOSE-function-fc5c184f-cb62-4ec7-a46e-38653b98f5bc.
[21] MATCH. MATCH function. h/t_tps://support.oﬃce.com/en-us/article/
MATCH-function-e8dﬀd45-c762-47d6-bf89-533f4a37673a.
[22] VLOOKUP. VLOOKUP function. h/t_tps://support.oﬃce.com/en-us/article/
VLOOKUP-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1.
[23] HLOOKUP. HLOOKUP function. h/t_tps://support.oﬃce.com/en-us/article/
HLOOKUP-function-a3034eec-b719-4ba3-bb65-e1ad662ed95f.
[24] oﬃce. IF function /f_i/question_exclam nested formulas and avoiding pitfalls
. h/t_tps://support.oﬃce.com/en-us/article/IF-function-%e2%80%93-nested-formulas-and-avoiding-pitfalls-0b22ﬀ44-f149-44ba-aeb5-4ef99da241c8?
ui=en-US&rs=en-US&ad=US, 2015.
[25] spreadsheeto. Let/f_is take a look at IF, Nested IF and IFS. h/t_tp://spreadsheeto.
com/if/, 2015.
[26] Bonnie A Nardi. A small ma/t_ter of programming: perspectives on end user
programming, 1993.
[27] Rui Abreu, J ´acome Cunha, Joao Paulo Fernandes, Pedro Martins, Alexandre
Perez, and Jo ˜ao Saraiva. Smelling faults in spreadsheets. In Proc. ICSME , pages
111–120. IEEE, 2014.
[28] F. Hermans, M. Pinzger, and A. van Deursen. Detecting and visualizing inter-
worksheet smells in spreadsheets. In Proc. ICSE , pages 441–451, 2012.
[29] F. Hermans, M. Pinzger, and A. van Deursen. Detecting code smells in spreadsheet
formulas. In Proc. ICSM , pages 409–418, 2012.
[30] J´acome Cunha, Jo ˜ao P Fernandes, Hugo Ribeiro, and Jo ˜ao Saraiva. Towards
a catalog of spreadsheet smells. In International Conference on Computational
Science and Its Applications , pages 202–216. Springer, 2012.
[31] Wensheng Dou, Shing-Chi Cheung, and Jun Wei. Is spreadsheet ambiguity harm-
ful? detecting and repairing spreadsheet smells due to ambiguous computation.
InProc. ICSE , pages 848–858. ACM, 2014.
[32] Shing-Chi Cheung, Wanjun Chen, Yepang Liu, and Chang Xu. Custodes: auto-
matic spreadsheet cell clustering and smell detection using strong and weak
features. In Proc. ICSE , pages 464–475. ACM, 2016.
[33] S. Roy, F. Hermans, and A. van Deursen. Spreadsheet testing in practice. In Proc.
SANER , pages 338–348, 2017.
[34] Ray Panko. What we don’t know about spreadsheet errors today: /T_he facts, why
we don’t believe them, and what we need to do. arXiv preprint arXiv:1602.02601 ,
2016.
[35] Kamalasen Rajalingham, David R Chadwick, and Brian Knight. Classi/f_ication of
spreadsheet errors. arXiv preprint arXiv:0805.4224 , 2008.
[36] Yirsaw Ayalew and Roland Mi/t_termeir. Spreadsheet debugging. arXiv preprint
arXiv:0801.4280 , 2008.
[37] Rui Abreu, J ´acome Cunha, Joao Paulo Fernandes, Pedro Martins, Alexandre Perez,
and Joao Saraiva. Faultysheet detective: When smells meet fault localization. In
Proc. ICSME , pages 625–628. IEEE, 2014.
[38] Joseph R Ruthruﬀ, Margaret Burne/t_t, and Gregg Rothermel. Interactive fault
localization techniques in a spreadsheet environment. IEEE Transactions on
So/f_tware Engineering , 32(4):213–239, 2006.
[39] Felienne Hermans, Ben Sedee, Martin Pinzger, and Arie van Deursen. Data clone
detection and visualization in spreadsheets. In Proc. ICSE , pages 292–301, 2013.
[40] Felienne Hermans, Ben Sedee, Martin Pinzger, and Arie van Deursen. Data clone
detection and visualization in spreadsheets. In Proc. ICSE , pages 292–301. IEEE
Press, 2013.
[41] Chanchal K Roy. Detection and analysis of near-miss so/f_tware clones. In Proc.
ICSM , pages 447–450. IEEE, 2009.
[42] Felienne Hermans, Martin Pinzger, and Arie van Deursen. Supporting profes-
sional spreadsheet users by generating leveled data/f_low diagrams. In Proc. ICSE ,
pages 451–460, 2011.
[43] Felienne Hermans, Martin Pinzger, and Arie Van Deursen. Automatically ex-
tracting class diagrams from spreadsheets. Proc. ECOOP , pages 52–75, 2010.
[44] Takeo Igarashi, Jock D Mackinlay, Bay-Wei Chang, and Polle T Zellweger. Fluid
visualization of spreadsheet structures. In Proc. ICIV , pages 118–125. IEEE, 1998.
[45] Hidekazu Shiozawa, Ken-ichi Okada, and Yutaka Matsushita. 3d interactive
visualization for inter-cell dependencies of spreadsheets. In Proc. ICIV , pages
79–82. IEEE, 1999.
[46] Martin Fowler and Kent Beck. Refactoring: improving the design of existing code .
Addison-Wesley Professional, 1999.
[47] DJ Hoepelman. Tool-assisted spreadsheet refactoring and parsing spreadsheet
formulas. 2015.
11