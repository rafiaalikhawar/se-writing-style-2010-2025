Region and Effect Inference for Safe Parallelism
Alexandros Tzannes, Stephen T. Heumann, Lamyaa Eloussi,
Mohsen V akilian, Vikram S. Adve
Univ. of Illinois at Urbana-Champaign, Dept. of Computer Science
{atzannes,heumann1,eloussi2,mvakili2,vadve }@illinois.eduMichael Han
Autodesk Inc.
michael.han@autodesk.com
Abstract —In this paper, we present the ﬁrst full regions-
and-effects inference algorithm for explicitly parallel fork-join
programs. We infer annotations inspired by Deterministic ParallelJava (DPJ) for a type-safe subset of C++. We chose the DPJannotations because they give the strongest safety guarantees of
any existing concurrency-checking approach we know of, staticor dynamic, and it is also the most expressive static checking
system we know of that gives strong safety guarantees. Thisexpressiveness, however, makes manual annotation difﬁcult and
tedious, which motivates the need for automatic inference, but
it also makes the inference problem very challenging: the codemay use region polymorphism, imperative updates with complex
aliasing, arbitrary recursion, hierarchical region speciﬁcations,
and wildcard elements to describe potentially inﬁnite sets ofregions. We express the inference as a constraint satisfactionproblem and develop, implement, and evaluate an algorithm for
solving it. The region and effect annotations inferred by the
algorithm constitute a checkable proof of safe parallelism, and itcan be recorded both for documentation and for fast and modularsafety checking.
I. I NTRODUCTION
In imperative parallel programs, the overwhelmingly many
possible dynamic interleavings of instructions make it difﬁcult
for programmers to reason about the correctness of theirprogram, and the non-deterministic or unstable nature ofdynamic execution schedules makes it challenging to exposeor reproduce parallelism bugs [1]. Many dynamic and staticapproaches have been proposed to address these challenges.Dynamic approaches [2], [3], [4] have been devised to address
the issue, but all incur substantial performance overhead and
some also require specialized hardware. Static approaches havezero runtime performance overhead but suffer from limitedexpressiveness and sometimes impose a heavy annotation bur-den on programmers. Ideally, we would like to have a highlyexpressive static checking approach with strong guarantees and
minimal annotation burden on the programmer.
The strongest guarantees we know of in any parallelism
checking approach – static ordynamic – are provided by
Deterministic Parallel Java (DPJ) [5], [6]. For fork-join parallel
programs, DPJ guarantees data race freedom, strong atomicity,
determinism-by-default, and compositional reasoning for de-terministic and non-deterministic parallel components, usingonly modular, static checking (cf. Section II). Using DPJ,however, can impose a signiﬁcant burden: every variable,parameter, and ﬁeld must be annotated with one or moreregion arguments specifying where it lives and/or points to;every method must be annotated with an effect summaryspecifying which regions the method may read or write;
every type is optionally annotated with one or more region
parameters, allowing the aforementioned annotations to takeparametric forms, potentially allowing to distinguish betweendifferent dynamic instances of objects of the same type. Inshort, manually annotating the code involves conceptuallysophisticated program annotations, which are likely to be toocomplex for general-purpose programmers to use in practice.
In this paper, we present the ﬁrst regions and effects
inference algorithm DPJ annotations. In particular, a pro-grammer only has to parallelize a program using fork-joinparallelism, and the algorithm infers the annotations neededfor the DPJ checker to enforce all its guarantees. The currentimplementation of our algorithm has limitations that makesome manual annotations necessary, but we will argue that allof them can be inferred using the same principles as we haveused for the rest of the annotations, and it is merely a matter
of implementation effort to support the necessary extensions.
The expressiveness (and complexity) of DPJ’s annotations
makes inference much more challenging than similar but less
expressive static approaches for safe parallelism, such as type
qualiﬁer approaches (cf. Section V). Moreover, unlike other
approaches that require programmer involvement when multi-ple solutions are possible, our annotation generation phase willautomatically ﬁnd a satisfying set of annotations (if one exists),and it can optionally be queried for alternate solutions. In orderto allow programmers to guide the inference algorithm whennecessary, we support partially annotated code: our inferencemust then ﬁnd a solution that honors existing annotations.
V akilian et al. [7] present an algorithm for inferring the DPJ
effect annotations given the region annotations. This is insufﬁ-cient to make DPJ practical because the region annotations,which the programmer must still provide, are signiﬁcantlymore challenging to select than the effect ones, and they are
still too numerous. Also, in terms of the inference algorithm,
effect inference has to solve only effect constraints with allregions therein completely speciﬁed (i.e., no region variables– only effect variables), whereas our inference has three typesof constraints to solve, and those constraints include both effectand region variables to be determined. In short, the inferenceproblem we are solving is substantially more challenging.
We tackle the complexity of inferring region and effect
annotations by proceeding in four phases (cf. Section III).
First , we introduce region and effect variables at all syntactic
locations where manual annotations are missing. Second ,w e
parse method declarations and their bodies to generate con-straints according to the rules of the region and effect annota-
tion language. Third , we process the generated constraints to
simplify them and to infer simpler constraints that effectively
prune the search space. F ourth, we instantiate all region and
effect variables produced in the ﬁrst phase with values thatsatisfy the constraints output by the third phase.
The third phase, which simpliﬁes the constraints generated
during the second phase, is one of our core contributions.
2015 30th IEEE/ACM International Conference on Automated Software Engineering
978-1-5090-0025-8/15 $31.00 © 2015 IEEE
DOI 10.1109/ASE.2015.59512
Its role is to prune the solution space by inferring prop-
erties of region variables and by simplifying the complexconstraints produced by the previous phase, without making
the set of constraints unsatisﬁable (sound & complete). At
its core are two lemmas and two theorems that transformsets of constraints matching a pattern into sets of constraintsthat are simpler to solve. The ﬁrst theorem applies to caseswhere object distinction is necessary because two objects areupdated in parallel, and the second one applies to recursiveupdates. Section III-C explains the theorems intuitively, andour technical report [8] provides the formal proofs.
Our contributions are: (1)A new algorithm that infers both
region and effect annotations to statically guarantee that aparallel code is safe; This algorithm also works with partiallyannotated code, allowing the programmer to control multipleaspects of the parallelism checking, and allowing to modularizeinference by providing manual annotations at module bound-
aries (Section III). (2)Formalized constraint generation rules
for an object-oriented core language (Section III-B); (3)Con-
straint simpliﬁcation rules that prune the solution space and
greatly reduce time-to-solution, and formal proofs that thesesimpliﬁcation rules are sound and complete (Section III-C);(4) A prototype implementation of our inference algorithm
for a type-safe subset of C++, and an evaluation of it thatdemonstrates the feasibility of the inference.
II. B
ACKGROUND
This section gives the needed background on the DPJ
annotations to be inferred. A complete presentation of DPJ canbe found in [5], [9]. Figure 1 gives a ﬁrst running example.
1class Point<region P> {
2 region X, Y;
3 double x in P:X;
4 double y in P:Y;
5
6 void setX(int v) writes P:X { x = v; }
7 void setY(int v) writes P:Y { y = v; }
8 void setXY(int vx, int vy) writes P: *{
9 cobegin { setX(vx); setY(vy); } }
10 }
11 region Foo;
12 void foo() writes Foo: *{
13 region R1, R2;
14 Point <Foo:R1> p1 = new Point();
15 Point <Foo:R2> p2 = new Point();
16 i n tx=3 ,// effects on locals
17 y=4 ;// are ignored
18 cobegin{
19 p1.setXY(y,x); // writes Foo:R1: *
20 p2.setXY(x,y); // writes Foo:R2: *
21 }
22 }
Fig. 1. Example of annotated Point class (effects in comments are
computed by the checker)
Region names, region parameters, and RPLs. To reason
about memory accesses and aliasing at an appropriate granu-
larity and level of abstraction, DPJ groups memory locationsinto regions . Regions are logical (not necessarily contiguous)
sets of memory locations. Line 2 declares region names X
andY, which may be used in region arguments for types, as
we will describe below. Line 1 indicates that the class takesa region parameter P, which allows to distinguish between
different dynamic instances of objects, as we will see later.The ﬁeld xis declared to be in region P:X, which is the
region of ﬁeld xof a particular instance of a Point object.
Deﬁnition 1 (RPL): A region path list (RPL) is a colonseparated list of region parameters, region names, and wild-cards that represents a set of regions (e.g., X, P:X, P:⋆:X).
The only wildcard we consider in this paper is ⋆, which stands
for zero or more colon separated RPL elements.
Deﬁnition 2 (Fully Speciﬁed RPL): An RPL is fully spec-
iﬁed if and only if it does not contain wildcards.
Similarly, ﬁeld yis in region P:Y, which is disjoint from
region P:X, and both are disjoint from regions P , X, and Y .
Deﬁnition 3 (Disjointness
#):Two RPLs are disjoint if
they are distinct from the left ( #L) or from the right ( #R).
RPLsR1andR2are distinct from the left if they are the same
in the ﬁrst nelements, they differ in element n+1, and neither
contains a ⋆in the ﬁrst n+1 elements. Symmetrically, RPLs
R1andR2are distinct from the right if they are the same in
the lastnelements, they differ in element n+1 from the end,
and neither contains a ⋆in the last n+1 elements.
RPLs allow us to describe nesting of regions, which is
important for capturing many parallel idioms, such as paralleltree traversals, parallel divide-and-conquer algorithms, andparallel updates through an array of pointers. However, thesemantics of RPL nesting may be slightly counterintuitive atﬁrst: we say that P:XisunderPand write P:X≤P,b u t
the two RPLs describe disjoint regions. In order to describe
a parent region and all the child regions nested under it, we
append a star to the RPL of the parent region (P :⋆in our
example). Then P:Xis included in P:⋆(P:X⊆P:⋆).
Deﬁnition 4 (Inclusion ⊆):RPLR
2includes RPL R1if
the set of regions described by R1is a subset of the set of
regions described by R2:R1⊆R2.
For example, P:⋆includesP,P:X,P:Y,P:X:⋆, etc.
Effect Summaries. Each method is annotated with an effect
summary which must cover the effects of its body. In this
paper, we focus on read and write effects and leave other kindsof effects [6] for future work. We denote with ∅the absence of
(visible) side-effects, which we call pure effect . A read effect
on an RPL R(readsR) indicates a read operation on one or
more of the regions described by R. Similarly, a write effect
on an RPL R(writesR) indicates a write operation.
Deﬁnition 5 (Coverage ⊆):Effecte
1on RPLR1covers
effecte2on RPLR2(e2R2⊆e1R1) if and only if e2≤e1
andR2⊆R1, wheree1,e2∈{ reads,writes,∅}and∅≤
reads≤writes .
Line 6 of Fig.1 deﬁnes method setX, which writes ﬁeld
xand thus has effect summary writes P:X. Similarly,
method setY on line 7 writes P:Y. Method setXY calls
the previously deﬁned setter methods of the current object,and has the declared effect summary writes P: *, which is
coarser than needed for illustration purposes. The effects of thebody are invocations, so the static checker fetches the effectsummaries of these methods, computes their union writes
P:X,P:Y, and checks that it is covered by writes P: *.
The DPJ checker does not trust effect summary annota-
tions: it checks them by inferring the effects of the methodbody using region information for all references in read andwrite operations and the declared effect summaries of themethods that are called. Having effect summaries allows theDPJ checker to be modular, and inferring the effect summariesrequires interprocedural analysis [7].
Non-Interference. Parallelism is introduced via cobegin in
Lines 9 and 18; the DPJ techniques support a variety of
other language constructs for nested fork-join parallelism. Each
513statement in a cobegin block may be executed in parallel in
separate tasks, and all such tasks must complete before the
statement after the cobegin may start. Parallelism is safe if
the effects of concurrent tasks are non-interfering. We use the
same symbol ( #) for non-interference as for RPL disjointness.
Deﬁnition 6 (Interference): Two effects interfere if one or
both are writes, and their RPLs are not disjoint.
In the body of setXY, the two setter methods are called
in parallel, so we check that the effects of the two tasks arenon-interfering. Indeed writes P:X does not interfere with
writes P:Y because the RPLs are disjoint.
Object Distinction. Lines 12 onward show a method foo,
which creates and initializes two point objects in parallel. Line14 declares object p1and provides region argument Foo:R1
to the region parameter Pof its type Point. Similarly, p2
gets instantiated with region argument Foo:R2 on line 15.
The invocation of setXY through p1on line 19 induces the
substitution σ=[P←Foo:R1] on its effect summary, which
yields writes Foo:R1: *. Similarly, the effect of line 20 is
writes Foo:R2: *. The checker conﬁrms that these effects
are non-interfering (distinction from the left) and conﬁrms thatthey are covered by the declared effect summary of foo.
Recursion and the use of ⋆in RPLs. The recursive example
code in Figure 2 demonstrates a feature of the DPJ annotationsthat presents one of the primary challenges for the inference,namely summarizing an inﬁnite set of regions using a star, anddistinguishing between disjoint inﬁnite sets of regions.
1class TreeNode <region P> {
2 region M, L, R, Links;
3 double mass in P:M;
4 TreeNode <P:L> left in Links;
5 TreeNode <P:R> right in Links;
6
7 double computeMass() reads Links writes P: *:M {
8 if (left==null && right==null)// reads Links
9 return mass; // reads P:M
10 double ml = 0, mr = 0;
11 cobegin {
12 if (left!=null) // reads Links
13 ml=left.computeMass(); // rd Links wr P:L: *:M
14 if (right!=null) // reads Links
15 mr=right.computeMass();// rd Links wr P:R: *:M
16 }
17 return mass = ml + mr; // writes P:M
18 }
19 }
Fig. 2. Example of annotated TreeNode class (effects in comments
are computed by the checker)
TheTreeNode class has a mass ﬁeld in P:M to enable
parallel updates of the ﬁeld in different tree nodes, and two
references to child nodes. The references themselves reside inregion Links (the references of all TreeNode objects will
be in the same region because we do not care to distinguishthem by object in this example). The TreeNode objects they
refer to take region arguments P:L andP:R .
The method computeMass returns the mass of leaf
nodes (Line 8-9), and it recursively computes the total massof the two subtrees for each non-leaf node (Lines 11-16),which it also stores in the mass ﬁeld (Line 17). The effects ofthe method are reads Links from reading the left and
right references, and writes P: *:M (meaning it writes
the M region of all RPLs/nodes under P) from the write onLine 17 and the recursive invocations. The effects of therecursive invocation on line 13 are computed by applying thesubstitution σ=[P←P:L]to the declared effect summary
ofcomputeMass, yielding reads Links writes
P:L: *:M. Similarly, the recursive invocation on line 15 has
effects reads Links writes P:R: *:M. These effects
are covered by the effect summary of computeMass . The
parallelism is safe because the two tasks have non-interferingeffects:{reads Links, writes P:L: *:M}
#{reads
Links, writes P:R: *:M}. Non-interference is decided
by making all the pairwise comparisons, four in this case:
rd Links #rd Links rd Links #wr P:R: *:M
wr P:L: *:M#rd Links wr P:L: *:M#wr P:R: *:M
III. I NFERENCE
In this section, we start by giving an overview of the phases
of our annotation inference algorithm, and we informallyfollow these phases for the Point class example described
in the previous section. Then, we formalize the key phases ofthe algorithm in the following subsections.
A. Overview
Our annotation inference proceeds in four phases. In the
ﬁrst phase, we generate an RPL variable ρ
vfor each unan-
notated variable v(ﬁeld, parameter, or local variable) and for
each unannotated type that requires a region argument, and we
generate an effect summary variable Emfor each unannotated
methodm. Each RPL variable is also given a domain of valid
region names and parameters from which it can be instantiated,which we describe later. In the second phase, we scan thecode of the program to produce three kinds of constraintson these variables: assignments (including passing parametersand returning values at method calls) produce subtyping con-straints; method deﬁnitions produce effect summary inclusion
constraints; and parallelism produces task non-interference
constraints. In the third phase, we process the constraints toproduce simpler constraints, which greatly prune the solutionspace deﬁned by the ρ
vandEmvariables. This pruning often
makes full inference tractable, as we will demonstrate in theevaluation section. In Section III-C (and [8]), we prove thatthese simpliﬁcation rules are sound and complete. Finally, inthe fourth phase, we search for an instantiation of the variablesthat satisﬁes the constraints. We use a structure- and value-
aware algorithm, which guides the variable instantiation order
and greatly reduces the amount of backtracking required, thusimproving the solver’s performance.
We initially attempted to use an SMT solver for the
constraint processing and solving phases (3rd and 4th) insteadof implementing our own from scratch, and we experimentedwith Z3 because its support for recursive rules was the mostmature. Unfortunately, the complex recursive decision proce-dures required to check RPL disjointness and inclusion, andthe fact that we had to provide these rules declaratively to Z3,resulted in solving times exceeding one minute for a simpledisjointness constraint. So, we concluded that we would not be
able to use an existing SMT solver to solve our constraints, and
we implemented our own custom solver prototype in Prolog.
The rest of this subsection explains the four phases in more
detail, ﬁrst informally through examples, then formally.
Phase 1: Introduction of Variables. Figure 3 shows the same
code as Figure 1 but without annotations. We introduce a
fresh region parameter Pfor the type Point, fresh RPL
variables ρ
xandρyfor ﬁelds xandy, and fresh effect
summary variables Ex,Ey, andExyfor the setter methods, as
5141class Point { // Implicit region parameter P
2 double x; // inρx
3 double y; // inρy
4
5 void setX(int v){x=v ;} //Ex(summary)
6 void setY(int v){y=v ;} //Ey(summary)
7 void setXY(int vx, int vy) { //Exy(summary)
8 cobegin { setX(vx); setY(vy); } }
9}
1011 void foo() { //E
f(summary)
12 Point p1 = new Point(); // Point< ρp1>
13 Point p2 = new Point(); // Point< ρp2>
14 int v1 = 3, // no annotation needed for locals
15 v2 = 4; // unless their address is taken
16 cobegin{
17 p1.setXY(v1,v2); //Exy[P←ρp1]
18 p2.setXY(v2,v1); //Exy[P←ρp2]
19 }
20 }
Fig. 3. Example Point class without annotations.
shown in the comments (their names are chosen for clarity of
presentation). For foo , we introduce effect summary variable
Efand RPL variables ρp1,ρp2for the region arguments of
p1andp2. If a solution is found where the type Point does
not require the region parameter P(i.e.,ρxandρydo not
containP, which would also mean that Ex,Ey, andExydo
not contain P), thenρp1andρp2can be dropped as their values
are not used. We can reason locally about the effects on thelocal variables v1andv2and the method parameters v,vx,
andvy, as long as their address is not taken and their type does
not expect a region argument. In those cases, a region argumentannotation is not necessary, and we need not report effects onthose variables in effect summaries. (This is a weaker form of
the property of uniqueness [10].)
Phase 2: Constraint Generation. For method setX,w e
generate the effect inclusion constraint that its effect summary
should cover the effects of its body: {writesρ
x}⊆Ex.
Correspondingly, for setY we generate: {writesρy}⊆Ey.
The effect summary of setXY, which invokes the other
two setter methods, must cover the union of their effects:
Ex∪Ey⊆Exy. We will somewhat abuse the notation and
write instead: {Ex,Ey}⊆Exy. Moreover, the two tasks
on line 8 must be non-interfering, so we generate the non-
interference constraint: Ex#Ey.
Line 17 invokes setXY on point p1, which has region
argument ρp1. We compute its effects by applying the substi-
tution[P←ρp1]to its effect summary Exy, which we denote
Exy[P←ρp1]. Similarly, the effects of the invocation on
line 18 are Exy[P←ρp2]. The effect inclusion constraint for
foo is then{Exy[P←ρp1],Exy[P←ρp2]}⊆E f, and the
non-interference constraint is Exy[P←ρp1]#Exy[P←ρp2].
Table I summarizes the generated constraints.
TABLE I. C ONSTRAINTS GENERA TED FOR CODE IN FIGURE 3
No. Constraint Type
1{writesρx}⊆Ex Effect Inclusion
2{writesρy}⊆Ey Effect Inclusion
3{Ex,Ey}⊆Exy Effect Inclusion
4Ex#Ey Effect Disjointness
5{Exy[P←ρp1],E xy[P←ρp2]}⊆E f Effect Inclusion
6Exy[P←ρp1]#Exy[P←ρp2] Effect Disjointness
Phase 3: Constraint Processing. The third phase helps prune
the vast instantiation space deﬁned by RPL and effect variablesby processing the generated constraints symbolically, withoutinstantiating any of the RPL or effect summary variables. Allthe transformations are sound, in that they do not introduce
solutions that would violate the original set of constraints,and complete, in that if the original set of constraints had
a solution, so will the resulting set, though it may be smaller.
Effect Inclusion to Equality. We can replace simple effect
inclusion constraints (e.g., 1 and 2 in Table I) with effect
equality constraints when the left hand side does not include
invocations (cf. 1 and 2 in Table II), because the effects arefully deﬁned (except for any region variables). Conversely,we cannot yet perform this simpliﬁcation to constraint 5
in Table I because the left hand side contains invocations.Now that we have effect equality constraints for E
xand
Ey, we can substitute them into constraints 3 and 4 to get
{writesρx,writesρy}⊆Exy(which we can now replace with
an equality constraint) and writes ρx#writesρy; the latter is
further simpliﬁed as ρx#ρy(disjointness of regions). With
Exysimpliﬁed, we can substitute it in the effect constraint for
Ef, resulting in a long but simple constraint (#5 in Table II).
Notice that converting an effect inclusion constraint to an
equality disallows potential solutions with less precise effectsummaries, but it is a complete transformation according to
the deﬁnition we gave above.
We can also substitute E
xyin constraint 6 and get:
{writes(ρx[P←ρp1],ρy[P←ρp1])} #{writes(ρx[P←
ρp2],ρy[P←ρp2])}. This decomposes into four simpler
pairwise disjointness constraints shown in the table (6.1-6.4), where we have also reduced the effect non-interferenceconstraints to region disjointness ones by dropping the writes.
TABLE II. S IMPLIFIED CONSTRAINTS FOR CODE IN FIGURE 3
No. Simpliﬁed Constraint Type
1{writesρx}=Ex Effect Equality
2{writesρy}=Ey Effect Equality
3{writes (ρx,ρy)}=Exy Effect Equality
4ρx#ρy RPL Disjointness
5{writes (ρx[P←ρp1],ρy[P←ρp1], Effect Inclusion
ρx[P←ρp2],ρy[P←ρp2])}=Ef
6.1ρx[P←ρp1]#ρx[P←ρp2] RPL Disjointness
=⇒ρx=P:/tildewiderρx∧ρp1#ρp2 RPLvar param. & Disj.
6.2ρx[P←ρp1]#ρy[P←ρp2] RPL Disjointness
6.3ρy[P←ρp1]#ρx[P←ρp2] RPL Disjointness
6.4ρy[P←ρp1]#ρy[P←ρp2] RPL Disjointness
=⇒ρy=P:/tildewiderρy∧ρp1#ρp2 RPLvar param. & Disj.
Disjointness Under Substitution. So far, the simpliﬁcations
were straightforward, but the next steps, which are moretricky, are important for performance. From constraint 6.1,we can deduce two constraints. First , the substitution on
ρ
xmust produce a change, in other words ρxmust contain
the parameter P, otherwise the constraint would evaluate to
ρx#ρx, which is unsatisﬁable. Because in DPJ a parameter
can only appear at the head of an RPL, we infer the structural
constraint ρx=P:/tildewiderρx, where/tildewiderρxis a fresh tail-RPL variable,
which is just a regular RPL variable, except it may not containRPL elements that can only appear at the head position. Now,we can apply the substitutions on both sides of 6.1, and wegetρ
p1:/tildewiderρx#ρp2:/tildewiderρx. Now, we can deduce the second
constraint: ρp1#ρp2(the substituents – i.e., the right-hand
sides of the substitutions – must be disjoint in order for thedisjointness constraint 6.1 to be satisﬁable). Note that this isa necessary but not a sufﬁcient condition if the fresh tail-RPL
variable contains a wildcard, as we will show in Section III-C
where we also determine the sufﬁcient condition. The samereasoning is applied to constraint 6.4. Finally, we can use
515the structural constraints for ρxandρy, substitute them into
the constraints and further simplify them (e.g., constraint 5
becomes {writes(ρp1:/tildewiderρx,ρp1:/tildewideρy,ρp2:/tildewiderρx,ρp2:/tildewideρy)}=Ef).
Occasionally, in this phase we will reduce or infer a
constraint that is clearly unsatisﬁable, such as ρ#ρ, in which
case we cannot prove the parallelism to be safe, either becausewe cannot check it statically or because it is indeed unsafe, andwe terminate the inference. Otherwise, we move on to the nextphase, which attempts to ﬁnd an annotation instantiation thatallows the code to be checked successfully. Section III-C (andour technical report [8]) show that the constraint processingtransformations are both sound and complete.Phase 4: Instantiation and Checking. In this phase, we
instantiate RPL variables and check that they honor the con-straints generated during the previous two phases. The naiveapproach is to ﬁrst instantiate all RPL variables (in some arbi-trary order) and then to check if they satisfy all the constraints,backtracking if they don’t. This approach is not tractablebecause the space is too big, and a bad instantiation order will
incur exponential amounts of unnecessary backtracking. Sayyou have a constraint A with variables ρ
1,ρ2and a constraint
B with variables ρ2,ρ3,ρ4, and the instantiation order is
lexicographic. If constraint A is not satisﬁed, we will haveto backtrack across all values of ρ
3,ρ4(which are not going
to make A satisﬁable), before trying a new value for ρ2which
may make A satisﬁable. The obvious solution is to check aconstraint as soon as all its RPL variables become instantiatedto trigger backtracking, but this approach is still too sensitive tothe variable instantiation order and incurs too much overhead.
Our approach is a structure and value sensitive extension
of the above idea. The constraints boil down to RPL inclusion
or disjointness and have the form R
1/vector σ1/circleplustextR2/vector σ2, where/vector σis
a vector of substitutions and/circleplustextstands for either the inclusion
or disjointness operator. We use this structure to drive the
instantiation process. First, we instantiate the left hand side.
We start by instantiating any variables in R1, but before we
proceed to instantiate /vector σ1, we apply the substitution: if the
instantiation value ofR1was not parametric, the entire sub-
stitution vector has no effect and we don’t need to instantiateany of its variables. Then, we instantiate the right hand sideusing the same approach, and once both sides are instantiated
we check if the constraint is satisﬁed.
Because RPL variables appear in multiple constraints, the
above approach is still too sensitive to the instantiation order.
To trigger backtracking earlier, we use an unsatisﬁability test:
each time we instantiate an RPL variable ρ, we check for
unsatiﬁability all constraints in which it appears: for eachpartially instantiated constraint independently, we try to ﬁndan instantiation of its uninstantiated variables that satisﬁes it,given the values of the instantiated variables; if such an instan-
tiation does not exist, the value we used to instantiate ρcaused
that constraint to become unsatisﬁable, and backtracking is
triggered. These checks are expensive but a missed opportunityfor early backtracking can have an exponential cost.
To pick an instantiation for an RPL variable, we must
deﬁne a domain for each variable. Such a domain lists all the
region names and parameters that may be used to instantiatethe corresponding RPL variable. Since we do not expectprogrammers to provide region name declarations, we must
also implicitly provide those in order to instantiate the domains
of RPL variables. A naive approach is to declare as manyregion names as there are RPL variables and allow all RPLvariables to be instantiated from that global pool, but thisapproach allows too many isomorphic solutions (solutions thatcan be converted from one to another via alpha renaming).We use scoping and DPJ-speciﬁc knowledge to constrain
the domains in ways that limit isomorphic instantiations, as
described in our technical report [8].
One noteworthy choice was to restrict the instantiation
length of RPL variables to two elements because we have notencountered the need for longer region arguments. This meansthat the size of the instantiation space of an RPL variable(which we call its cardinality ) is roughly quadratic in the size
of its domain. RPL arguments with length greater than twocould be used to hide implementation details at API bound-aries, but the constraint generation relies on having access tothe code, so the desire of hiding the code will come with aneed to manually annotate such module APIs. The annotationson the internals of such modules can still be automaticallyinferred. Finally, the restriction of the instantiation length doesnot carry to any other parts of the inference algorithm, whichcan work with RPLs of arbitrary length. Such longer RPLs can
occur either from manual annotations, or due to substitutions
applied to shorter RPLs (e.g., P:L:⋆:Min Fig.2).
The ﬁrst and fourth phases (variable introduction and
annotation instantiation) are relatively straightforward, so inthe following sections, we focus on the constraint generationand constraint processing phases.
B. Constraint Generation
This section describes the constraint generation phase of
our inference algorithm. For conciseness, we focus on a core
calculus (Figure 4) in the style of Huang et al. [11], whichmodels Java with a syntax in A-normal form [12], [13].
Deﬁnition Meaning
p ::= cdτys program
cd ::= class C< region P> {fdmd} class decl.
fd ::=τfi n˚R ﬁeld decl.
md ::=τrm(τ xx)E{τys; return y} method decl.
τ::= C<R> types
R::= R|ρ RPLs
R ::= Root |P|R:r|R:* RPL annot.
E ::=∅|rdR| wrR|/epsilon1|E∪E Effects
s ::= s;s |s/bardbls|x = new τ()|x=y Statements
|x . f=y|this.f = y |x=y . f
|x = this.f |x = y.m(z) |x = this.m(z)
Fig. 4. Syntax of a core OO language.
Programs in our language comprise class declarations,
followed by global variable declarations and a statement toexecute. Class declarations specify a class name C, a regionparameter P , a list of ﬁeld declarations and a list of methoddeclarations. Field declarations have a type τ, a ﬁeld name
f, and a fully speciﬁed region ˚Rwherein the reference
is stored. Types τare composed of a name C and of a
region argument R. Method declarations are composed of a
return type τ
r, a method name m, a formal parameter x with
typeτx, an effect summary E and a body. The body has a
list of local variable declarations τy, a statement s, and a
return statement. RPL arguments Rare either RPL variables
ρintroduced in phase 1 or RPL annotations given by the
programmer (R). RPL annotations R are a colon-separated
list of RPL elements that start either with the region Root
or a parameter P , and may contain region names (r) and the
star wildcard. An effect summary E is a possibly empty set
516of read (rd) or write (wr) effects on RPLs R, or an effect
summary variable /epsilon1, or a union of effect summaries. For
brevity, we will write {rdR1,R2;wrR3,R4}instead of
{rdR1,rdR2,wrR3,wrR4}. A statement can be composed
of two statements either sequentially (;) or in parallel (/bardbl); or it
can be an assignment statement, assigning a variety of right-hand-side (RHS) expressions to a variable or to a ﬁeld ofthe current object (this.f) or of another object (y.f). The RHSexpressions may be a heap allocation with a type argument,a variable, a ﬁeld dereference (this.f or y.f), or a method call(this.m(z) or y.m(z)).
Subtyping for the explicitly or implicitly (i.e., with RPL
variables introduced in phase 1) region-annotated types isequivalent to region inclusion of their RPL arguments:
Γ/turnstileleftR
1⊆R 2
Γ/turnstileleftC/angbracketleftR1/angbracketright≤C/angbracketleftR2/angbracketright(SUBTYPING )
The environment Γis a set of variable-type bindings ( τx)
and parameter inclusion facts (P ⊆R ) used by the capture
rule, explained later in this section. The typing relation for
statements Γ/turnstilelefts:τ,E|Kreads “statement shas typeτand
effectsEin environment Γunder the constraints K.
Next, we discuss the constraint generation as driven by the
typing relation for the most interesting categories of statements
and declarations. Due to lack of space, we omit rules that aresimilar to the ones we present.
For sequential composition, the type is that of the second
statement, the effects are the union of the effects of the twostatements, and the constraints are the union of the constraints.Parallel composition is similar, with only an additional non-interference constraint {E
1#E2}.
Γ/turnstilelefts1:τ1,E1|K1Γ/turnstilelefts2:τ2,E2|K2
Γ/turnstilelefts1;s2:τ2,E1∪E2|K1∪K2(SEQ)
Γ/turnstilelefts1:τ1,E1|K1Γ/turnstilelefts2:τ2,E2|K2
Γ/turnstilelefts1/bardbls2:τ2,E1∪E2|K1∪K2∪{Γ/turnstileleftE1#E2}(PAR)
For a simple assignment (x=y), the class of x and y must
be the same in the environment, and the region argument ofy must be included in that of x. This is a straightforwardapplication of the subtyping rule towards constraint generation.The rule for a statement allocating a new object is very similar,
so we omit it. The effects on variables are not expressed
in terms of RPLs because in the core language variablesare unique (i.e., they cannot be aliased because their address
cannot be taken). Thus, variables do not require an inclause,
and effects on them simply use the variable name.
C/angbracketleftR
x/angbracketrightx∈ΓC/angbracketleftRy/angbracketrighty∈ΓK={Γ/turnstileleftRy⊆Rx}
Γ/turnstileleftx=y:C/angbracketleftRy/angbracketright,{rdy;wrx}|K
(ASSIGN )
Next, we discuss the constraints for aliasing a variable
xto a ﬁeld faccessed through variable y(x=y.f ). The
auxiliary function typeof() retrieves the type of ﬁeld ffrom
its declaration, and paramof() retrieves the region parameter
Pyfrom the declaration of class Cy.xandfmust have the
same class C, substitution σreplaces the parameter Pywith
the region argument Ryofy, and we apply it to the region ˚Rfin which flives. The type of the statement is C/angbracketleftRf/angbracketrightσ, i.e.,
the type of the ﬁeld after applying the substitution. Its effectsare (i) reading the region in which flives, after applying σ,
(ii) reading y, and (iii) writing x. Finally, the generated region
inclusion constraint requires that the region argument of the
right hand side ( y.f), which we get by applying σto the
region argument R
fof the type of f, be included in the region
argument of x. We skip the simpler rule for x=this.f,a si t
follows from this one by omitting the substitution σ.
C/angbracketleftRx/angbracketrightx∈Γ typeof(f)=C/angbracketleftRf/angbracketrightin˚Rf
Cy/angbracketleftRy/angbracketrighty∈Γ paramof(Cy)=Py
σ=[Py←Ry]K={Γ/turnstileleftRfσ⊆Rx}
Γ/turnstileleftx=y.f:C/angbracketleftRf/angbracketrightσ,{rdy,˚Rfσ;wrx}|K
(READ VF IELD )
The next rule assigns to a ﬁeld through a variable (x.f=y).
The substitution σreplacing the parameter of the type Cxof
xwith its region argument Rxis what one might expect, and
it is used to determine the effect of the statement. We mustuse a different substitution σ
/prime, however, to check the legality
of the assignment. In σ/prime, we substitute the parameter Pxof
Cxwith a fresh parameter P, called the capture parameter ,
which can take values in Rx, i.e.,P⊆Rx, and we require
thatRy⊆Rfσ/primein the augmented environment that includes
the fresh parameter Pwith its constraint. (This complication
with the capture parameter is needed in this rule to avoidunsoundness in the presence of wildcards, as explained in moredetail in [9]. It is similar to how Java handles the capture of ageneric wildcard.) If R
xis fully speciﬁed, then P=Rxand
σ/primebecomes equivalent to σ. Otherwise, the capture parameter
tells us that the only information we have about the regionargument of x is that it is included in R
x.
Cx/angbracketleftRx/angbracketrightx∈Γ typeof(f)=C/angbracketleftRf/angbracketrightfin˚Rf
C/angbracketleftRy/angbracketrighty∈Γ paramof(Cx)=Px
σ=[Px←Rx]σ/prime=[Px←P],freshP, P⊆Rx
K={Γ∪{P⊆Rx}/turnstileleftRy⊆Rfσ/prime}
Γ/turnstileleftx.f=y:C/angbracketleftRy/angbracketright,{rdy;wrx,˚Rfσ}|K
(W RITE VF IELD )
To type a method declaration, we type its body sin the
augmented environment Γ/primewhich includes the declarations of
its formal parameter and local variables. Also, the effects E
of the body must be covered by the method’s effect summaryE
m. Finally, the return statement generates the same constraint
K/primeas an assignment would.
C/angbracketleftRy/angbracketrighty∈τy τ r=C/angbracketleftRr/angbracketright
Γ/prime=Γ∪τy∪τxxΓ/prime/turnstilelefts:τ,E|K
K/prime={Γ/prime/turnstileleftRy⊆Rr}K/prime/prime={Γ/turnstileleftE⊆Em}
Γ/turnstileleftτrm(τxx)Em{τys;returny}:∅,∅|K∪K/prime∪K/prime/prime
(M ETHOD )
Lastly, we give the rule for a method call through a variable
(y.m(v)) without explanation, as it is built up from the same
principles we have discussed so far (including the use of a
capture parameter Pin the substitution applied to the region
of argument x). The simpler rule for member method call
(this.m(v)) is omitted.
517C/angbracketleftRz/angbracketrightz∈Γ typeof(m)=τrm(τxx)Em{...}
τr=C/angbracketleftRr/angbracketrightC/prime/angbracketleftRv/angbracketrightv∈Γτx=C/prime/angbracketleftRx/angbracketright
Cy/angbracketleftRy/angbracketrighty∈Γ paramof(Cy)=Pyσ=[Py←Ry]
K1={Γ/turnstileleftRr⊆Rz}σ/prime=[Py←P],freshP
K2={Γ∪{P⊆Ry}/turnstileleftRv⊆Rxσ/prime}
Γ/turnstileleftz=y.m(v):τrσ,{rdv,y; wrz}∪Emσ|K1∪K2
(VC ALL )
C. Constraint Processing
In this section, we present two lemmas and two theorems
that form the cornerstone of the effect processing phase be-
cause they demonstrate that the key constraint simpliﬁcationsperformed by this phase are sound (no invalid solutions areintroduced) and complete (if the original constraint set wassatisﬁable, so is the simpliﬁed one).
Lemma 1 (Effect Inclusion to Equality): An effect inclu-
sion constraint {E
1,...,E n}⊆ES can be replaced by an
equality constraint {E1,...,E n}=ES if none of the effects
E1,...,E nare invocation effects, and ES does not appear on
the right-hand-side of any other effect inclusion constraint.
The goal of Lemma 1 is to replace an inclusion constraint
with an equality constraint which is simpler and will allowsubstituting the effect variable wherever it appears in otherconstraints. This transformation is trivially sound. Intuitively,it is also complete because it simply restricts inferred effect
summaries to be as precise as possible. See [8] for the proof.
Lemma 2 (RPL Inclusion Chain): Ifρ
1⊆ρ2,ρ2⊆ρ3,
...,ρn−1⊆ρn, andρ2,...,ρ n−1 do not appear in any
other RPL inclusion constraints, then inclusion is replaced
by equality for all but the last RPL inclusion constraint:ρ
i=ρi+1, for1≤i≤n−2.
Again, soundness is trivial and the same intuitive argument
for completeness holds as for Lemma 1: we are only constrain-
ing potential solutions that would be less precise. The fact
that RPL variable ρ2does not appear in other RPL inclusion
constraints means it does not have to include any regions otherthan those of ρ
1. Conversely, if ρ2appeared in another RPL
inclusion constraint, it could be necessary for ρ2/negationslash=ρ1, which
is why the lemma is not applicable in that case.
The next two theorems target two more sophisticated sets of
simpliﬁcations that arise for common parallelism patterns. The
ﬁrst theorem infers the need (and the associated constraints)
for object distinction, which is necessary when we need to
modify multiple objects of the same type in parallel. Thesecond theorem infers the need for recursive object distinction ,
which is necessary when we need to modify multiple nested
objects of the same type recursively in parallel.
The ﬁrst theorem helps us deal with constraints of the form
ρ[P←ρ
1]#ρ[P←ρ2]. We saw this kind of constraint earlier
and presented intuitively how to process it. Here we formalizeour approach.
Theorem 1 (Disjointness Under Substitution):
ρ[P←ρ
1]#ρ[P←ρ2]⇐⇒ {ρ=P:/tildewideρ,fresh/tildewideρ}∧
((ρ1#Rρ2∧/tildewideρ∈˚R)( a)
∨(ρ1#Lρ2∧((ρ1/negationslash≤ρ2∧ρ2/negationslash≤ρ1)( b)
∨(/tildewideρdoes not start with wildcard)))) (c)
A disjointness constraint on a common RPL ρwith two
different substitutions with the same base Pis satisﬁed if and
only ifρstarts with the substitution base P, and at least one ofthe three following cases holds: (a) the substituents ρ1andρ2
are distinct from the right and /tildewideρis fully-speciﬁed, or (b,c) the
substituents are distinct from the left and (b) neither substituentis under the other, or (c) /tildewideρdoes not start with a wildcard.
The formal proof is in our technical report [8]. Here, we
will give some intuition for why the result holds. First, unless ρ
is parametric in P, the substitutions will have no effect and the
non-interference constraint will not be satisﬁable. Similarly,ρ
1#ρ2is necessary because these are the only RPL elements
that will differ after the two substitutions. It is not, however,
a sufﬁcient condition, primarily because the rest of ρmay
contain wildcards. For example, if ρ=P:⋆,ρ1=R1, and
ρ2=R1:R2, thenρ1#ρ2is true but R1:⋆#R1:R2:⋆is not
satisﬁable because R1:R2:⋆⊆R1:⋆.
The three cases (a-c) in the theorem structurally decompose
all the ways in which ρ1#ρ2can be used to prove that ρ1:
/tildewideρ#ρ2:/tildewideρ. (a) says if ρ1andρ2are disjoint from the right,
then the RPL elements following them ( /tildewideρ) must not contain
any wildcards in order to prove the required property. If ρ1and
ρ2are disjoint from the left, i.e., due to leading RPL terms,
we can prove the resulting RPLs disjoint in one of two ways.
(b) says we can prove it (regardless of /tildewideρ)i fρ1andρ2are in
distinct subtrees of the region tree (i.e., neither is an ancestor ofthe other). (c) says we can also prove it if /tildewideρis a subtree with a
unique root because then appending that subtree to ρ
1andρ2,
which are distinct from the left, preserves their disjointness.
For simplicity, because constraints with disjunctions are
expensive to check, our implementation of the constraintprocessing phase leverages this theorem only partially: it adds
the simpler constraints ρ=P:/tildewideρandρ
1#ρ2to the original
disjointness constraint. The ﬁrst constrains the instantiation of
ρimproving performance, and the second provides a necessary
condition for disjointness which is quicker to check.
The second theorem deals with recursive write effects. Let
mbe a method with effect summary variable Ethat has some
non-interference constraint (cf. Figure 5), and a (directly or
indirectly) recursive method call, represented by a sequence
of substitutions Sc(i.e., a substitution cycle). Effect inclusion
for the body of myields Eq. 1. Furthermore, let minclude
awrites effect, writes ρSderef , possibly through a chain of
invocations from mthat contributes a substitution chain Sinv
(if the statement contributing this writes effect is in mthen
Sinv will be empty), and let S=SderefSinv (Eq. 2). Let the
writes effect and the substitution cycle Scbe on opposing sides
of a non-interference constraint (Eq. 3). Finally, we assume that
the code compiles without errors, which allows us to claim
that the substitutions SandScare well-formed , meaning they
properly translate the RPL ρinto the context of m.
/;#23/;#23#23/;#23#23#23/;#23#23#23#23
/;#23#23#23#23#23/;#23#23#23#23#23#23/;#23#23#23#23#23/;#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23
/;#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23
 /;#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23/;#23#23#23#23#23#23#23#23#23#23#23#23#23#23#23
ESc⊆E (1)
writesρS⊆E (2)
writesρS#ESc (3)
Fig. 5. Recursive Write Theorem
Theorem 2 (Non-interference of Recursive Writes):
518The premises Eq. 1–3 imply:
ρ=P/prime:/tildewideρ (4)
S=[P/prime←P:/tildewides] (5)
Sc=[P←P:/tildewidesc] (6)
/tildewidescisn’t empty and doesn’t start with ⋆ (7)
∞/uniondisplay
i=0writesP:/tildewidesci:/tildewides:/tildewideρ⊆E (8)
Again, the theorem’s transformation is sound and complete.
For each write effect directly or indirectly within the body of
m, described by Eq. 2, the inferred constraints of the theoremare added to the original set of constraints, trivially preserving
soundness. The proof of the theorem guarantees completenessbecause the premises imply the conclusion [8].
Adding these inferred constraints helps the solver by re-
ducing the instantiation domain of several RPL variables andof substitutions that contain RPL variables: Eqs. 4, 5, and 6require that the relevant RPL variables start with a speciﬁc
parameter, and Eq. 7 puts some additional constraints on the
instantiation of the tail of the RPL variable.
We brieﬂy discuss why Theorem 2 holds. First, let the
region parameter in the context where the write effect occurs
beP
/prime, and the one in the context of mbeP(possibly the same
asP/prime). Then, Eq. 4 (i.e., ρis parametric in P/prime) is necessary to
make the non-interference constraint in Eq. 3 satisﬁable. This
is because ρScontributes a term to E, and if the result did not
include a region parameter, that term would be left unchangedbyS
c, so Eq. 3 would be unsatisﬁable.
Note that in Eqs. 5 and 6 the substitution chains SandSc
are shown as a single substitution. This is because well formedsubstitution chains can be simpliﬁed into a single substitution(cf. [8]). Eq. 5 follows from the well-formedness hypothesis.Eq. 6 says that the substitution cycle S
ccan be simpliﬁed
into a substitution which has the same parameter Pboth at
its base and at the head of its substituent. In other words, Sc
preserves the parameter P– it does not ground the effects
it is applied to to ﬁxed regions, which would then make thenon-interference constraint unsatisﬁable. Eq. 7 (in conjunctionwith Eq. 6) says that the substitution cycle S
cisexpanding
(i.e.,scis not empty), meaning one or more region names are
added to RPLs after Scis applied, allowing the effects of an
invocation of mand those of a recursive invocation of mto be
over disjoint regions. The second requirement, that scnot start
with⋆, stems from a technical detail of the DPJ annotations,
whose justiﬁcation can be found in our technical report [8].
Eq. 8 follows from Eqs. 1, 2, 4, 5, and 6 as follows.
Eq. 1 and 2 yield∞/uniontext
i=0writesρSSi
c⊆E, whereSi
cdenotesi
applications of Sc. Using Eq. 4, 5, and 6 to substitute the values
ofS,Sc, andρwe get Eq.8. We can summarize this inﬁnite
set of regions with some loss of precision as P:∗:/tildewides:/tildewideρ,b u t
under certain conditions (adversarial partial annotations) this
can be incomplete. It has not been an issue in practice, but in
the future we plan to avoid this incomplete summarization byallowing the constraint solving engine to reason about RPLsof the form P:/tildewides
c∗:/tildewides:/tildewideρwhich would precisely describe such
inﬁnite sets of regions.
IV . I MPLEMENTA TION &E V ALUA TION
We implemented the ﬁrst two phases [14] (RPL and effect
summary variable insertion and constraint generation) on topof our annotation checker tool written in Clang [15]. Ourtarget language is a type-safe subset of C++11 with parallelism
introduced via TBB [16] constructs and, in certain cases, a fewmanual annotations provided as attributes. We implemented the
other two phases [17] (constraint processing and annotation
instantiation) in Prolog because of its native support foruniﬁcation and its declarative programming style, which madeit extremely productive.
A. Benchmarks
We evaluated the feasibility and performance of our in-
ference tool on a number of parallel benchmarks [17]. They
include a variety of algorithms and parallelism styles, includingcomputations on trees, recursive subdivision of arrays, and a
parallel loop algorithm with a synchronized reduction phase.
The parallel computations are written so that they can beproven deterministic using DPJ-style region and effect anno-tations.
List updates all the elements of a linked list and performs the
update on the current node in parallel with the recursive call
to update the rest of the list.
Tree builds a binary tree of a given depth: at each node, the
two subtrees are built recursively in parallel.MergeSort uses recursive parallelism, sorting the two halves
of an array in parallel with each other before merging them.
This algorithm allocates a new output array at each recursivestep. This allows us to place the output arrays of each step innested regions corresponding to the recursive tree structureof the computation, so the effects of each recursive stepcan be speciﬁed using an RPL containing the ⋆wildcard
(writes{Pout:A:⋆,Pout:B:⋆}, whereAandBspecify the
left and right half of the array at each step).
KMeans is a clustering algorithm adapted from the STAMP
benchmarks. It identiﬁes kclusters from a set of points in
N-dimensional space. It uses a parallel loop with a reduction
step where information about each cluster may be updated.
We use a manually-inserted block-scoped lock for this step,because our algorithm does not currently infer atomic blocksand atomic effects, which would be used by DPJ for this code.Our analysis assumes without checking that the locked blockcorrectly synchronizes the operations in it, so its effects canbe ignored. The remaining operations within the parallel loopare read-only, so the data they access can all be placed in asingle region that is read by each iteration of the loop.
QuadTree builds a spatial partitioning tree where each node
represents a region of a 2-D plane and internal nodes each
have four child nodes corresponding to sub-quadrants of the
parent node. This data structure has many applications such
as collision detection, spatial indexing, image analysis, andsimulation. 2-D points are inserted in the quad tree by startingfrom the root node and recursively moving down the tree bychecking which quadrant the point belongs to. If we reach aleaf node, we insert the point there if the node is not full;otherwise, we subdivide the node into four quadrants andrecursively repeat the process. We parallelize the recursivecomputation by attempting to insert the point in each of a
node’s four subtrees in parallel; this will check the point’s
location against each subtree’s bounding box in parallel andonly proceed with the insertion in the appropriate subtree.
CollisionTree implements a tree-based collision detection
algorithm which was adapted from the open-source jMon-
keyEngine game engine. We ported it from a version previ-
519ously used to benchmark DPJ [5]. The Collision Tree algorithm
processes a pair of spatial partitioning trees, each containingthe triangles in a 3-D mesh, and ﬁnds any pairs of trianglesin the two trees that intersect. It uses a recursive parallel
approach, processing the two subtrees of one of the trees in
parallel at each recursive step. This algorithm is read-only onthe trees, but we want it to work with trees that could bebuilt in parallel, so we kept manual annotations for the left
andright pointers of the TreeNode class, similar to those
shown in Figure 2. The inferred effects of each recursive step inthe algorithm will therefore contain the ⋆wildcard to designate
effects on each subtree it is processing. This is an example ofthe inference working with partial manual annotations.
B. Evaluation
We evaluate the feasibility of our proposed inference al-
gorithm and the performance improvements achieved by our
simpliﬁcation phase (Phase 3). To do so we measure the time-
to-solution with different levels of simpliﬁcation enabled aswell as the size of the instantiation space of RPL variables.
Table III(a) shows how long it takes the constraint solver
(in seconds, except where noted) to ﬁnd a solution givendifferent levels of simpliﬁcation. The ﬁrst column states thename of the program along with the number of lines of codeas counted by sloccount [18]. The second column shows
the time to solution with phase 3 disabled (only Lemma 1 isapplied because it is so fundamental), the third column showsthe time when Lemma 2 is enabled, the fourth shows the timewhen Theorem 1 is also enabled, and the ﬁfth when Theorem2 is also enabled (cf. Section III-C). Runs that took more than24 hours are marked as T/O (time-out). We ran the solver on anIntel Core i7-2600, with 8G of RAM, running a 64 bit Ubuntu10.14 using kernel 3.16.0-37-generic. The times reported arethe average of ﬁve runs. The standard deviation of these runs
was below 10%, or below 20% for the cases marked with an
asterisk. This somewhat higher than expected variability seemstied to Prolog’s runtime system.
The size of the instantiation space is computed as the
product of the cardinalities of the RPL variables reachable
by the union of all the non-interference constraints. An RPLvariablevis reachable by a constraint Cif it is included in Cor
if it is included in a constraint C
/primethat contains an RPL variable
v/primethat is reachable by C. Table III(b) shows the instantiation
space at various stages before, during, and after the constraintprocessing phase. Notice that the simpliﬁcations signiﬁcantlyreduce the space and that different benchmarks beneﬁt more orless from a speciﬁc simpliﬁcation depending on the parallelismpattern they use. For example, tree based code reaps increasedbeneﬁts from the simpliﬁcations of Theorem 2.
We make the following observations from the timing and
space-size numbers: (i)the inference of region and effect
annotations is tractable for these programs; (ii)in half of the
cases, at least some of the simpliﬁcations are necessary tomake the inference tractable, although Theorem 1 does notseem helpful on this set of benchmarks by itself. (iii) there
is not a direct correlation between the time-to-completion andthe space size (e.g., KMeans faster than Quadtree); (iv) even
when the simpliﬁcations do not improve solving time, theiroverhead is minimal so it is reasonable to always perform them
(cf. KMeans). For KMeans, because we currently trust that
the atomic block is safe and the remaining parallelism onlyhas read effects, ﬁnding a solution for read-only parallelismis very easy, as shown by the very quick time-to-solution; (v)
Theorem 1 does not seem to improve time-to-solution on ourset of benchmarks, which may be because it would mainlybeneﬁt ﬂat
Finally, Table III shows the counts of the region arguments
and effect summaries inferred automatically (c) and of theregion parameter and argument annotations provided manually(d). Because our current implementation has some limitations,some manual annotations are needed. (1)If a method requires
region parameters, they need to be manually provided andany region arguments using those parameters also need tobe provided. This case will be easy to automate. Take the
following annotated example from MergeSort:
void sort<Pin,Pout>(int *<Pin> in, int *<Pout> out)
Its formal parameters in andout have type pointer-to-int,
which requires a region argument to describe which region
the pointer points to. To enable sort to take arguments that
point to various regions, we need to declare region parametersPin andPout, and use them as region arguments in the dec-
larations of its formals. While this is currently not automated,the way to achieve it would be to count the number of RPL
variables generated for the formals of a function, then create
an equal number of fresh region parameters for the functionand include them in the domains of the RPL variables wecounted. Moreover, at each call-site, we need to generate a setof substitutions giving concrete values to those function regionparameters. Currently, we require region arguments to enablethe annotation checker to infer these substitutions, but we couldlift that restriction by generating a substitution [P←ρ]with
a fresh RPL variable ρfor each parameter per call-site. This
is straightforward but tedious, so we opted for incorporatingmore benchmarks into our evaluation at the cost of addingsome straightforward manual annotations. (2) We currently
assume that each non-annotated user-deﬁned type takes (atmost) one parameter. This assumption is true for all types inour benchmarks except for functors implemented as classeswith an overloaded operator() method, which are used
by TBB parallel constructs. These are treated like methodswith multiple parameters as in case (1) above, so it is equally
straightforward to manually annotate them.
Overall, we have shown that our inference approach is
successfully able to infer the complex regions and effects
annotations for non-trivial parallel algorithms. In the future,we envisage three improvements. First, when the parallelismis unsafe (and thus the constraints are unsatisﬁable), the solvertakes too long to fail: procedures and heuristics must be
devised to quickly detect an unsatisﬁable core . Second, the
algorithm must be extended to remove the need to provide
manual annotations. In particular, lifting the assumption thatunannotated types have a single region parameter withoutpaying a steep performance penalty could be challenging.Third, there are several optimizations for constraint solvingalgorithms that make a big difference to the speed and scala-bility of compiler alias analysis, taking algorithms like Ander-sen’s [19] from unscalable to practical and widely used [20],[21], [22]. Although they will require extensive adaptations,
these optimizations could prove beneﬁcial to our algorithm.
These are all exciting future directions.
V. R
ELA TED WORK
a) Region Inference for Memory Management: There is
substantial work on inference of regions for automatic memory
520TABLE III. E V ALUA TION RESULTS FOR BENCHMARKS .
(a) Time-to-Solution (s) (b) Instantiation Space Size (c) Inferred (d) Provided
Program (LOC) None Lem 2Lem 2 &
Thm 1Lem 2 &Thms 1&2Initial Lem 2Lem 2 &Thm 1 L e m2&Thms 1&2#arg #ES #par #arg
List (64) 0.046 0.046 0.045 0.046 1.1·10136.5·10106.5·10102.5·10919 5 0 0
Tree (92) 0.140 0.112 0.117 0.115 1.0·10182.1·10132.1·10131.7·101131 9 0 0
MergeSort (60) 579.0 0.482 0.494 0.227 8.5·10171.13·10158.5·10142.9·101424 4 2 2
K-means (1063) 0.444 0.469 0.476 0.479 5.2·10871.2·10781.2·10781.2·107882 28 0 1
QuadTree (98) T/O 3h52m∗3h58m∗42.9 7.7·10401.2·10393.1·10371.1·103642 12 6 6
CollTree (836) T/O 112.0∗115.8∗98.0 5.2·101419.8·101208.4·101208.3·10115125 32 32 66
management [23], [24], [25]. This body of work infers regions
that group heap objects with similar lifetimes into commonregions. The techniques used in those papers are not applicable
to our problem because they are based on analysis of object
lifetimes and not on analysis of effects or of non-interferencebetween parallel tasks.
b) Languages and Systems for Safe Parallelism: Nu-
merous systems use some form of static and/or dynamicchecks to ensure determinism or other parallel safety properties(e.g., [26], [2], [27], [3], [28], [5], [4], [29], [10], [30]).
Many of these require the programmer to write some form
of annotations or to use special libraries to obtain safetyguarantees, but only a few support automatic inference of theseannotations; we discuss them below.
Systems like CoreDet [4] and Kendo [28] use dynamic
mechanisms to provide deterministic execution for threadedcode without special annotations, but they impose substantialrun-time overheads. Also, the deterministic execution order
provided by these systems does not correspond to the structure
of the program’s code, making it difﬁcult to reason about.
c) Automatic Effect Inference: Bierman and Parkin-
son [31] present an inference algorithm for Greenhouse andBoyland’s object-oriented effect system [32]. This system isdesigned to enable more aggressive compiler optimizations,not parallel safety, and has only limited hierarchical regions,e.g., they cannot express arbitrarily nested structures.
The work on inferring the side-effects of procedure calls in
imperative languages [33], [34], [35], [36], [37] uses interpro-cedural dataﬂow analysis to propagate side-effect informationover the call graph. All these techniques rely on the results of apointer alias analysis, whereas we infer (at least, indirectly) the
pointer aliases in a program as part of the algorithm throughthe subset constraints at assignments and function calls. (Tech-nically, our algorithm is comparable to a ﬂow- and context-
insensitive, Andersen-style subset-based alias analysis [19] in
terms of analysis power.)
Jouvelot and Gifford [38], Talpin and Jouvelot [39], and
Tofte and Birkedal [40] all infer types and effects for mostly-functional languages with much simpler effect systems thanours: they cannot express effects on nested region structures,which are fundamental to many realistic parallel algorithmsand signiﬁcantly complicate the inference problem we address.
The work of V akilian et al. [7] was discussed in Section I.
Immutability and purity type systems statically reason
about the mutability of references or objects and purity of
methods [41], [42], which can help to achieve safe parallelism.Several systems can infer mutability [43], [41], [44], andPearce [42] describes a tool to infer pure methods. Immutabil-ity and purity are simple enough to be expressed using a few
kinds of annotations. However, our annotations for expressing
safe parallelism are nested and more complicated, which makesthe inference more challenging.d) Inference of Annotations for Safe Parallelism:
SharC [27] infers type qualiﬁers indicating the sharing mode ofobjects using a whole-program sharing analysis that propagates
information about which data may be shared between threads.
SharC can guarantee data-race freedom but not determinism,so their annotations are much less expressive than the regionsystem in DPJ, e.g., they do not explicitly describe aliasing
(region types) or effects within hierarchical data structures.
Gordon et al. [10] propose an extension to the C# type
system that adds uniqueness and immutability qualiﬁers totypes with the intention to support safe parallelism. Theyinfer allowable implicit conversions between their qualiﬁerconstraints, which reduces the annotation burden, but theprogrammer still needs to provide the bulk of the annotations.Their qualiﬁer inference requires only intraprocedural analysisselecting between a small number of type qualiﬁers, makingit much simpler than the problem we address.
Kawaguchi et al. use liquid effects to guarantee determin-
istic parallelism [29], and they use liquid type inference [45]to signiﬁcantly reduce the annotation burden. However, theunderlying type inference is intraprocedural and the remaining
annotations are too difﬁcult for general-purpose programmers.
e) Inference of Ownership Types and Universe Types:
Ownership Types (OT) [46] and Universe Types (UT) [47]
aim to restrict aliasing in object oriented languages in order toexpress the programmer’s intended containment abstractions.UT and OT do not target safe parallelism explicitly, and theirannotations involve only a small ﬁxed set of type modiﬁers.
Several systems [11], [48], [49] support inference of owner-
ship or universe types. These systems use relatively simpleinference approaches which are insufﬁcient for our highlyexpressive type system, in which each annotation has a vastset of allowed values.
VI. D
ISCUSSION AND FUTURE WORK
There are no practical programming languages in
widespread use today that are as expressive as Java or C++ yetguarantee safe use of concurrency constructs. The automaticregion-and-effect inference algorithm described in this worktakes a step in that direction by greatly simplifying the
use of static checking techniques for such languages. Our
implementation demonstrates that inferring rich and complexannotations, such as those of DPJ, can be tractable givena smart solver, and opens opportunities for further research.More speciﬁcally: (a) support of the remaining DPJ constructs,such as index-parameterized arrays and atomic blocks, as wellas scoped locks (cf. KMeans); (b) techniques to improve theperformance of the algorithm, e.g., using more aggressiveconstraint processing rules, and perhaps heuristic techniques
for navigating the solution space more efﬁciently; and (c) better
diagnosis information when the constraints are unsatisﬁable, toassist programmers in correctly parallelizing their programs.
521REFERENCES
[1] E. A. Lee, “The problem with threads,” Computer, vol. 39, no. 5, pp.
33–42, May 2006.
[2] M. C. Rinard and M. S. Lam, “The design, implementation, and
evaluation of Jade,” ACM Trans. Program. Lang. Syst. , vol. 20, no. 3,
pp. 483–545, May 1998.
[3] M. D. Allen, S. Sridharan, and G. S. Sohi, “Serialization sets: A
dynamic dependence-based parallel execution model,” in Proceedings
of the 14th ACM SIGPLAN Symposium on Principles and Practice of
Parallel Programming, 2009.
[4] T. Bergan, O. Anderson, J. Devietti, L. Ceze, and D. Grossman,
“CoreDet: A compiler and runtime system for deterministic multi-threaded execution,” in Proceedings of the Fifteenth Edition of ASPLOS
on Architectural Support for Programming Languages and OperatingSystems, 2010.
[5] R. L. Bocchino, Jr., V . S. Adve, D. Dig, S. V . Adve, S. Heumann,
R. Komuravelli, J. Overbey, P . Simmons, H. Sung, and M. V akilian, “Atype and effect system for deterministic parallel java,” in Proceedings of
the 24th ACM SIGPLAN Conference on Object Oriented Programming
Systems Languages and Applications, 2009.
[6] R. L. Bocchino, Jr., S. Heumann, N. Honarmand, S. V . Adve,
V . S. Adve, A. Welc, and T. Shpeisman, “Safe nondeterminism ina deterministic-by-default parallel language,” in Proceedings of the
38th Annual ACM SIGPLAN-SIGACT Symposium on Principles ofProgramming Languages, 2011.
[7] M. V akilian, D. Dig, R. Bocchino, J. Overbey, V . Adve, and R. John-
son, “Inferring method effect summaries for nested heap regions,”inProceedings of the 2009 IEEE/ACM International Conference on
Automated Software Engineering, 2009.
[8] A. Tzannes, S. Heumann, L. Eloussi, M. V akilian, V . Adve, and M. Han,
“Technical report: Region and effect inference for safe parallelism,”
https://www.ideals.illinois.edu/handle/2142/79048, 2015.
[9] R. L. Bocchino, Jr., “An effect system and language for deterministic-
by-default parallel programming,” Ph.D. dissertation, University ofIllinois at Urbana-Champaign, 2010.
[10] C. S. Gordon, M. J. Parkinson, J. Parsons, A. Bromﬁeld, and J. Duffy,
“Uniqueness and reference immutability for safe parallelism,” in Pro-
ceedings of the ACM International Conference on Object Oriented
Programming Systems Languages and Applications, 2012.
[11] W. Huang, W. Dietl, A. Milanova, and M. D. Ernst, “Inference and
checking of object ownership,” in Proceedings of the 26th European
Conference on Object-Oriented Programming, 2012.
[12] A. Sabry and M. Felleisen, “Reasoning about programs in continuation-
passing style,” Lisp and Symbolic Computation - Special issue on
continuations - part I , vol. 6, no. 3-4, pp. 289–360, November 1993.
[13] C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen, “The essence of
compiling with continuations,” in Proceedings of the ACM SIGPLAN
1993 Conference on Programming Language Design and Implementa-tion. New Y ork, NY , USA: ACM, 1993, pp. 237–247.
[14] Region and Effects Annotations Inference Engine
https://github.com/hanm/clang/tree/dev/prolog-full.
[15] “clang: a C language family frontend for LLVM,” http://clang.llvm.org/.
[16] “Threading Building Blocks,” https://www.threadingbuildingblocks.org/.
[17] Region and Effects Annotations Inference Solver & Benchmarks
https://bitbucket.org/atzannes/annotationinference.
[18] D. A. Wheeler, “SLOCCount,” http://www.dwheeler.com/sloccount.[19] L. O. Andersen, “Program analysis and specialization for the C pro-
gramming language,” Ph.D. dissertation, DIKU, University of Copen-
hagen, May 1994.
[20] M. F ¨ahndrich, J. S. Foster, Z. Su, and A. Aiken, “Partial online cycle
elimination in inclusion constraint graphs,” in Proceedings of the ACM
SIGPLAN 1998 Conference on Programming Language Design and
Implementation, 1998.
[21] A. Rountev and S. Chandra, “Off-line variable substitution for scaling
points-to analysis,” in Proceedings of the ACM SIGPLAN 2000 Confer-
ence on Programming Language Design and Implementation , 2000.
[22] B. Hardekopf and C. Lin, “The ant and the grasshopper: Fast and
accurate pointer analysis for millions of lines of code,” in Proceedingsof the 2007 ACM SIGPLAN Conference on Programming LanguageDesign and Implementation , 2007.
[23] M. Tofte and J.-P . Talpin, “Implementation of the typed call-by-value
λ-calculus using a stack of regions,” in Proceedings of the 21st
ACM SIGPLAN-SIGACT Symposium on Principles of ProgrammingLanguages , 1994.
[24] A. Aiken, M. F ¨ahndrich, and R. Levien, “Better static memory manage-
ment: Improving region-based analysis of higher-order languages,” in
Proceedings of the ACM SIGPLAN 1995 Conference on Programming
Language Design and Implementation , 1995.
[25] S. Cherem and R. Rugina, “Region analysis and transformation for
java programs,” in Proceedings of the 4th international symposium on
Memory management, V ancouver, Canada, 2004.
[26] J. M. Lucassen and D. K. Gifford, “Polymorphic effect systems,”
inProceedings of the 15th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages , 1988.
[27] Z. Anderson, D. Gay, R. Ennals, and E. Brewer, “SharC: Checking
data sharing strategies for multithreaded C,” in Proceedings of the 29th
ACM SIGPLAN Conference on Programming Language Design andImplementation, 2008.
[28] M. Olszewski, J. Ansel, and S. Amarasinghe, “Kendo: Efﬁcient de-
terministic multithreading in software,” in Proceedings of the 14th
International Conference on Architectural Support for ProgrammingLanguages and Operating Systems , 2009.
[29] M. Kawaguchi, P . Rondon, A. Bakst, and R. Jhala, “Deterministic par-
allelism via liquid effects,” in Proceedings of the 33rd ACM SIGPLAN
Conference on Programming Language Design and Implementation,
2012.
[30] S. Treichler, M. Bauer, and A. Aiken, “Language support for dy-
namic, hierarchical data partitioning,” in Proceedings of the 2013 ACM
SIGPLAN International Conference on Object Oriented ProgrammingSystems Languages and Applications , 2013.
[31] G. Bierman and M. Parkinson, “Effects and effect inference for a core
Java calculus,” Workshop on Object Oriented Developments , 2003.
[32] A. Greenhouse and J. Boyland, “An object-oriented effects system,”
inProceedings of the 13th European Conference on Object-Oriented
Programming. Springer-V erlag, 1999.
[33] J. P . Banning, “An efﬁcient way to ﬁnd the side effects of proce-
dure calls and the aliases of variables,” in Proceedings of the 6th
ACM SIGACT-SIGPLAN Symposium on Principles of ProgrammingLanguages, 1979.
[34] B. G. Ryder, W. A. Landi, P . A. Stocks, S. Zhang, and R. Altucher,
“A schema for interprocedural modiﬁcation side-effect analysis with
pointer aliasing,” ACM Trans. Program. Lang. Syst. , vol. 23, no. 2, pp.
105–186, March 2001.
[35] P . Nguyen and J. Xue, “Interprocedural side-effect analysis for Java
programs in the presence of dynamic class loading,” in Proceedings
of the Twenty-eighth Australasian Conference on Computer Science -V olume 38 , 2005.
[36] A. Rountev, “Precise identiﬁcation of side-effect-free methods in java,”
inProceedings of the 20th IEEE International Conference on Software
Maintenance , 2004.
[37] A. Salcianu and M. C. Rinard, “Purity and side effect analysis for
Java programs,” in Proceedings of the 6th International Conference on
V eriﬁcation, Model Checking, and Abstract Interpretation, 2005.
[38] P . Jouvelot and D. Gifford, “Algebraic reconstruction of types and
effects,” in Proceedings of the 18th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages , 1991.
[39] J.-P . Talpin and P . Jouvelot, “Polymorphic type, region and effect
inference,” Journal of Functional Programming , vol. 2, pp. 245–271,
July 1992.
[40] M. Tofte and L. Birkedal, “A region inference algorithm,” ACM Trans.
Program. Lang. Syst. , vol. 20, no. 4, pp. 724–767, Jul. 1998.
[41] S. Artzi, A. Kieun, J. Quinonez, and M. D. Ernst, “Parameter refer-
ence immutability: formal deﬁnition, inference tool, and comparison,”
Automated Software Engineering , vol. 16, pp. 145–192, 2009.
[42] D. J. Pearce, “JPure: A Modular Purity System for Java,” Compiler
Construction, pp. 104–123, 2011.
522[43] J. Quinonez, M. S. Tschantz, and M. D. Ernst, “Inference of Reference
Immutability,” in Proceedings of the 22nd European Conference on
Object-Oriented Programming, 2008, pp. 616–641.
[44] W. Huang, A. Milanova, W. Dietl, and M. D. Ernst, “ReIm & ReImInfer:
Checking and Inference of Reference Immutability and Method Purity,”
inProceedings of the ACM International Conference on Object Oriented
Programming Systems Languages and Applications, 2012.
[45] P . M. Rondon, M. Kawaguchi, and R. Jhala, “Low-level liquid types,”
inProceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, 2010.
[46] D. G. Clarke, J. M. Potter, and J. Noble, “Ownership types for
ﬂexible alias protection,” in Proceedings of the 13th ACM SIGPLAN
Conference on Object-oriented Programming, Systems, Languages, andApplications , 1998.[47] D. Cunningham, W. Dietl, S. Drossopoulou, A. Francalanza, P . M ¨uller,
and A. J. Summers, “Formal methods for components and objects,”F. S. Boer, M. M. Bonsangue, S. Graf, and W.-P . Roever, Eds. Berlin,
Heidelberg: Springer-V erlag, 2008, ch. Universe Types for Topology
and Encapsulation, pp. 72–112.
[48] W. Dietl, M. D. Ernst, and P . M ¨uller, “Tunable Static Inference
for Generic Universe Types,” in Proceedings of the 25th European
Conference on Object-oriented Programming, 2011.
[49] C. Dymnikov, D. J. Pearce, and A. Potanin, “OwnKit: Inferring modu-
larly checkable ownership annotations for java,” in Proceedings of the
22nd Australian Conference on Software Engineering , 2013.
523