RefiNym: UsingNames to Refine Types∗
Santanu KumarDash
UniversityCollegeLondon
London,UK
santanu.dash@ucl.ac.ukMiltiadisAllamanis
Microsoft Research
Cambridge,UK
miallama@microsot.comEarlT.Barr
UniversityCollegeLondon
London,UK
e.barr@ucl.ac.uk
ABSTRACT
Source code isbimodal: it combines a formal, algorithmic channel
andanaturallanguagechannelofidentiiersandcomments.Inthis
work, we model the bimodality of code with name lows , an assign-
ment low graph augmented to track identiier names. Conceptual
types are logically distinct types that do not always coincide with
program types. Passwords and URLs are example conceptual types
that can share the program type string. Our tool, RefiNym, is an
unsupervised method that mines a lattice of conceptual types from
namelowsandreiiesthemintodistinctnominaltypes.For string,
RefiNym inds and splits conceptualtypes originally mergedinto a
single type, reducing the number of same-type variables per scope
from 8.7 to 2.2 while eliminating 21.9% of scopes that have more
thanonesame-typevariableinscope.Thismakesthecodemore
self-documenting and frees the type system to prevent a developer
from inadvertentlyassigning data acrossconceptualtypes.
CCS CONCEPTS
·Softwareanditsengineering →Datatypesandstructures ;
KEYWORDS
Type Reinement,Information-theoreticClustering
ACMReference Format:
Santanu Kumar Dash, Miltiadis Allamanis, and Earl T. Barr. 2018. Re-
fiNym: Using Names to Reine Types. In Proceedings of the 26th ACM
Joint European Software Engineering Conference and Symposium on the
Foundations of Software Engineering (ESEC/FSE ’18), November 4ś9, 2018,
Lake Buena Vista, FL, USA. ACM, New York, NY, USA, 11pages.htps:
//doi.org/10.1145/3236024.3236042
1 INTRODUCTION
During development, programmers tend to use imprecise types,
especiallyundertimepressure.Forexample,theymightcombine
conceptuallydistincttypeslikepasswordsorlastnamesintoasingle
built-intypelike string.Workingwithasimplertypehierarchy
helps rapidprototyping, but comesat a cost.The members ofthis
coarse-grainedtypelatticeoftendonotnaturallybelongtogether
and are a source of bugs at deployment. For example, if a program
∗This research was funded by the Engineering and Physical SciencesResearch
Council (EPSRC)grant EP/P005314/1.
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forproitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
ontheirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspeciicpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’18, November 4ś9, 2018, Lake BuenaVista,FL,USA
©2018 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-5573-5/18/11...$15.00
htps://doi.org/10.1145/3236024.32360421varserver = Config.’et( "fxcm-server" , ... );
2varterminal = Config.’et( "fxcm-terminal" , ... );
3varuserName = Config.’et( "fxcm-user-name" , ... );
4varpassword = Config.’et( "fxcm-password" , ...);
5
6vardownloader = newFxcmDataDownloader(server, terminal,
7 userName, password);
8
9foreach ( varticker in tickers) {
10if(downloader.HasSymbol(ticker)){...}
11}
Figure 1: Motivating example from the Lean C# Project; we
lightlymodiied thecodeto it.
uses only built-in types, then invalid or dangerous operations like
cost + distance orstring.Concat(password, lastname) are
type-correct.Thisisawell-documentedproblemcalled primitive
obsession thatoccurswheneveradeveloperavoidsdeiningbespoke
types [12,20,26].
Figure 1shows a classic example of primitive obsession in Lean
(commithash f574bfd7 ),anopen-sourcealgorithmictradingen-
ginewritteninC#.ThissnippetconnectstoadataproviderforFor-
eignExchangeCapitalMarkets(FXCM)andsearchesfortickersym-
bols. Using it requires logging in through the FxcmDataDowloader
class.Thisclasstakesinfourarguments.Allfourargumentsarean-
notated as strings, intermixing disparate concepts such as server
addresses, terminals, usernames and passwords with each other
and plain-text strings. Accidentally using the password in place of
theusernamewould nottriggeratypeerrorandgounnoticeduntil
theattacksurfaceisexploitedatruntime.RobinMilnerfamously
observed ł Well-typed programs don’t go wrong .ž Here, we see an
example ofcode that typechecksbut isnot well-typed.
Conceptual types are the types the developer had in mind while
writingaprogram.Oftentheycoincidewiththeprogram’stypes,
but sometimes, as with primitive obsession, they are not explicitly
deinedandarelatenttoaprogram’sexplicittypehierarchy.Inthis
work,wecombatthisproblem,includingprimitiveobsession,by
assisting developers to identify reinements of a program’s type
lattice: we mine conceptual types, then suggest their reiication
intoactualtypes.Todiscoverlatentconceptualtypes,weintroduce
RefiNym,atoolthatautomaticallyminesconceptualtypes,then
presentsthemtodeveloperstohelpthemdeineamorespeciictype
thatsurfacesdistinctconceptualtypes,theirvaluesandbehaviours,
tothetypechecker. RefiNym usesdatalowandnameinformation
todetectconceptualtypes.In Figure1,RefiNym suggestsseparating
allfourvariablesÐ server,terminal ,userName ,andpassword Ð
intodistincttypes,sothatthetypecheckercanpreventadeveloper
from carelesslydirectlyassigning between them.
We formulatetheproblem ofreining atypein aC#program’s
typelatticeasasearch-basedsoftwareengineeringproblem[ 14]
andsearchforvalidandcoherenttypelatticeswhoseelementsareaESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Santanu KumarDash,Miltiadis Allamanis, andEarl T.Barr
mixofexplicitandconceptualtypes.Informationwithinidentiiers
in the code and assignment lows between them constrains the
search. Our approach is bimodalbecause it intermixes semantic
information(lows)andsyntacticinformation(names).Ourmethod
exploits lexical similarities to build a conceptual type lattice using
theinformation-theoreticprinciplethatacandidateconceptualtype
is good if it minimizes the shared information distance between
namesandtypes:givenaconceptualtype,thenamesofthevariables
ofthattypeandnamesof themethodsthatreturnthattypeshould
havelowentropy( i.e.bepredictable);givenavariableormethod
name,its conceptualtype should be easyto predict.
RefiNym constructs a name low graph (Section 2.1 ) from a pro-
gram that type checks. A name low graph contains all the type
constraints imposed by assignment lows in the program across
variables and parameter bindings. RefiNym then uses variation
ofinformation,aninformation-theoreticobjective,to clusterthe
nodes of the name low graph subject to C#’s subtype rules ( Sec-
tion2.2).Theseclustersarecandidateconceptualtypes. RefiNym
generates fresh names for these clusters and suggests them as type
reinements. If a developer accepts one, RefiNym rewrites its input
to use that type ( Section 3).
RefiNym inds reinementsfor an existing program type;so,as
asanitycheck,weartiiciallycreateconceptualtypesbymerging
user-deined types, then ask RefiNym to reconstruct them. Re-
fiNymexactlyreconstructed62%ofthesetypes( Section4.1 ).We
haveequipped RefiNym witharewriterthatautomatesrefactoring
acodebase to use its suggestedreinementsfor C#,asyntactically
rich, industrial language ( Section 3). Software engineers care about
howcodeevolvesinresponsetotheirneeds.Someofthesechanges
worsenthecodebase,movingittowardacriticalpointwherefurther
changescancascadeintoerror.Ascopeinwhichtwoconceptual
types share a primitive is such a critical point. In these critical
scopes, the type system cannot prevent a developer from mistak-
enlyassigningvaluesfrom oneconceptual type totheother.Over
ourcorpus, RefiNym automaticallyeliminates21.9% (onaverage)
of these critical scopes ( Section 4.2 ) while reducing the potential
of inadvertently introducing cross-conceptual type lows within
scopesbydrasticallyreducingthenumberofsame-typevariables
perscopefroman averageof8.7to2.2,therebyenablingthetype
systemto betterprotectthe developer from herownmistakes.
Contributions. Ourcorecontributionsfollow:a)wepresentan
information-theoreticnominaltypereinementmethodthatuses
identiier names and datalow to mine conceptual types; b) we
presentRefiNym, a practical C# tool that implements our method;
and c) we comprehensively evaluate RefiNym on real world openś
sourceprojectsandshowthatiteliminates21.9%(onaverage)of
potentialinadvertentlows. RefiNym andour evaluationartifacts
are available at htp://github.com/askdash/refinym .
2 INFERRING CONCEPTUALTYPE LATTICES
Thelatenttypesinaprogramoftendiferfromthetypelatticein
theprogramthedeveloperexplicitlydeinedwithtypeannotations.
We call these latent, precise types, conceptual types . These types
grouprelateddataandoperations.TheyaresimilartoGuo’s et al.’s
[11]abstracttypes,exceptthattheyarenotalwaysmoreabstract
thanthetypesintheprogram’stypelattice.Weareinterestedin
exePath
fileDir
file
c1
f
filePath
fileDir
 path
c2
dir
path
file
 str
 c3
str
val
 val
s
 str
id
c4
id
Figure 2: Conceptual clustering of a name low graph for
string: A node is a variable or a function, while edges are
assignments or actual to parameter bindings ( Section 2.1 ).
RefiNym clusters nodes into conceptual types, such as the
shadowed areas. Here, c1represents ile path, c2general
paths,c4identiiers; and c3arbitrary strings.
usingnamestoinferconceptualtypes,thenlookforreinements
that bring a program’s explicit type lattice closer to its implicit
conceptualtype lattice,bysplitting the mergedconceptualtypes.
Modernsoftwareengineeringpracticeunanimouslyagreeson
theneedforwell-namedidentiiers.Indeed,mostdeveloperschoose
nameswithgreatcare[ 1,4].Forexample,namesofvariablesand
functionsare selected insuch away that theyrelect their seman-
tic role and function. The correspondence between names and
semanticsisa crucialcomponentwhenunderstanding code,since
developersthinksemanticallyaboutcodeandrepresentativenames
facilitate this process[ 17].
For these reasons, our core intuition is that variable and method
namesareoftensemanticallyrichandcloselyrelecttheiridenti-
ier’s functionality and therefore provide strong information about
an identiier’s conceptual type. Speciically, we observe that names
tend to low into names that describe similar concepts following
the general covariance and contravariance principles. For exam-
ple, a numeric variable named distance sometimes lows into a
numeric variable with a more abstract name like value, but rarely
the other way around. Therefore, a program’s data low imposes
łis-až relationships among the names of the variables and meth-
odsand,consequently,totheconceptstheydescribe.Wecapture
these relationships in a name low graph , described next. To rec-
ognize salient conceptual types, we cluster the graph, such that
the inferred clusters, along with the original unreined type as top
and the standard bottom, form a lattice ( Figure 2). In this work,
we focus on using discrepancies between the program’s implicit
concept type lattice and its explicit type lattice to ind and suggest
typereinements.Forexample,whenthe stringclassholdsboth
passwordsandsurnames, RefiNym willsuggestdistinctsubtypes,
likePasswordString andSurnameString . If a developer adopts
these suggestions, the type checker can then prevent the developer
from mistakenlysharingdata between thesetypes.
2.1 The Name FlowGraph
For each variable, we need to collect the names whose values low
intothatvariable.Tothisend,weaugmentastandardconstraint-
basedtypesystemtocapturesingle-stepnamelow,thenbuilda
graphforthevariable vwhosetraversaldeinestheinlowname
closure of v.
For the type-correct program P, letVbe its variables, Lbe its
literals, and Mbe its method names. For the function Ξ:V→RefiNym: Using Namesto Refine Types ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
Γ⊢v:σ1Γ⊢k:σ2σ2<:σ1
Ξ(v)∪{v,(k,l)}Γ⊢v:=k:unit(AssignL)
Γ⊢v:σ1Γ⊢v′:σ2σ2<:σ1
Ξ(v)∪{v,(v′,v)}Γ⊢v:=v′:unit(AssignV)
Γ⊢v:σ1Γ⊢m(¯e):σ2σ2<:σ1
Ξ(v)∪{v,(m,m)}Γ⊢v:=m(¯e):unit(AssignM )
e/nelementL∪V∪MΓ⊢v:σ1Γ⊢e:σ2σ2<:σ1
∀n∈names(e),Ξ(v)∪{v,(n,label(n)))}Γ⊢v:=e:unit
(AssignE)
Γ⊢e0:σ0mtype(m(¯p),σ0)=¯δ→σΓ⊢¯e:¯σ¯σ<:¯δ
⃗p=⟨p1:=a1,···,pi:=ai,···pn:=an⟩Γ⊢e0.m(¯e):σ
(Invoke)
Figure 3: A constraint-based system for typing variables,
augmented to update Ξ(v), the set of names whose values
low into v; our additions to standard rules are boxed; In-
vokemake formal to actual parameter bindings explicit for
matchingby theassignment rules.
2V⊎2L⊎2M,Ξ(v)is all the names that low into vvia an assign-
ment:=or a formal-to-actual binding. The names in Ξ(v)are type
compatible under the assumption that Ptype checks. Ξreturns an
elementfromadisjointunion,where vtagsvariables, ltagsliterals,
andmtags methods.
Figure 3shows extensions to standard rules for typing variables
that are relevant to RefiNym.RefiNym identiies reinement types
for variables bound only to irst-order terms. Therefore, we only
discuss the subset of rules related to variables: Invokeand the
four rulesforcollecting constraintsfromexplicit assignments. As-
signL,AssignV,AssignM , andAssignE handle assignments from
constants, variables, methodreturns, andallotherexpressions,re-
spectively. In our irst order setting, we handle method types by
projecting them onto their constituent parameter and return types.
Asusual,theassertionsin Figure3areoftheform Γ⊢v:τwhere
Γis the type environment that maps types to terms in the calculus.
Forsimplicityandwithoutlossofgenerality,werestrict σitoscalars.
We could have modiied all expression judgments to collect names,
but,forbrevity,focusedonassignment.Alloftheassertionsinthese
rulesarestandardwiththeexceptionoftheboxedassertionineach
rule’s conclusion and the e/nelementL∪V∪MinAssignE. The boxed
assertionsusedisjointuniontoextend Ξ.InInvoke,mtypereturns
thetypeofamethod m(¯p)inaclass σ0.Theadditionalconstraint
onAssignE prevents its redex from overlapping those of the other
assignment rules and is consequence of our decision to modify
only assignment judgments. We augmented Invoketo convert
m’s parameter list ⃗pinto an explicit sequence of assignments to
which our four assignments rules apply and collect name lows
from actuals into m’sformals.
AssignE relies on two helper functions: labelthat distinguishes
literal, variable, and method names and namesthat extracts namesin the expression ethat are type-compatible with vand adds them
to the name-low for v. Consider ł intx = strlen(str)+ y ž. Be-
cause of the ’+’, AssignM does not match strlenand we fall
throughto AssignE,whichapplies names.Thisfunctioncollectsall
theassignmentcompatiblenamesfromanexpression,here strlen
andy.AssignEaddsthesenamesto xinthename-lowgraph.The
methodnamesignoresstrbecause it is a parameter of strlen; in
otherwords,methodinvocationsaresinksforthename-lowsof
theirparameters.
After building Ξ,RefiNym uses it to construct the name low
graphG=(N,E).Thenodesin Narefullyscope-qualiiedvariable,
method,orformalnames.Anedgeconnectstwonamesintwocases:
1)whenthesourcenameisontheRHSofanassignmentandthe
targetisontheLHSor2)whenthesourcenamestheactualboundto
theformalname, i.e.thetarget.The labelfunctionlabelseachedge.
Because we collect name lows alongside type constraints onlyfor
assignments and parameter bindings, the name lows from literals,
variable, and method returns are type-compatible by construction;
thenamelowsfromthenamesusedinotherexpressionsmayor
maynot be dependingonthe implementationof names().
InFigure3,theboxedassertionsthatcollectnamesinto Ξarein-
dependentoftheunderlying,standardconstraint-basedtypecheck-
ing. Thus, they can be adapted to other type systems, including
type systems that support partially typed programs via an łanyž
type wildcard.
Figure4showshow Ξevolvesacrossfunctionapplications.At
thetopleftoftheigure,wehavethe Calcclasswhichhasamethod
addthat takes two integers, xandy, as inputs. Maininvokesadd
twice on lines 6 and 7. In each case, InvokeandAssignM type the
assignment expression. For brevity, Figure 4merges the updates
toΞthese two rules make. There are two dotted arrows leading to
the type rulefor the twoassignment operations.
The solidarrows annotated withcircled numbers indicatehow
Ξchanges as the two type rules are applied. Before line 6 in Main,
xandydo not have any name lows coming into them. This is
indicates by a·in theirΞ’s. The execution of line 6 assigns the
variablefsttoxandsndtoy.Additionally,throughtheassignment
operator :=, line 6 also binds sumto the result of c.add. In the
conclusion of type rule, we update Ξ’s forx,yandsumwith the
informationabove.Theassignmentinline7issimilarexceptthat
itbindsyto aliteral.
2.2 Clustering theGraph
Inthiswork,weareinterestedinpartitioning(clustering)thenodes
in a name-low graph Ginto clusters that form a lattice over the
graph.Theseclustersrepresentminedconceptualtypes.Conceptual
typesnameprogramvariablesthatshareacommonpurposeand
identify operations over them ( Figure 2). Precisely because they
shareapurpose,weexpecttheirnamestorelectthatpurposeto
reminddevelopersaboutitandtheconstraintsitimposes.Thus,we
expect names and conceptual types to be mutually informative. To
clusterG,wethereforeexploittheinterplaybetweennamelows
inGandthenamesofthevariablesandmethodsbyclustering.For
example, two variables that are not closely related in Gbut share a
name have a high chance of being related, while two variables that
haveverydiferentnamesbutwithverysimilarnamelowsarealsoESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Santanu KumarDash,Miltiadis Allamanis, andEarl T.Barr
Γ⊢c:Calc mtype (add(x,y),Calc)=int→int→intΓ⊢fst:intΓ⊢snd:int
¯p={⟨x:=fst,y:=snd⟩}
Ξ(x)∪{x,(fst,v)}Ξ(y)∪{y,(snd,v)}Ξ(sum)∪{sum,(c.add,m)}Γ⊢c.add(fst,snd):int1public class Calc{
2publicCalc(){}
3
4public int add(intx,inty){
5returnx+y;
6}
7}1public static void main(...) {
2Calc c = newCalc();
3intsum, fst = 20;
4intsnd = fst;
5
6sum = c.add(fst, snd);
7sum = c.add(sum, 40);
8}
Ξ(x) ϕ
Ξ(y) ϕ
Ξ(fst){⟨fst,(20,l)⟩}
Ξ(snd){⟨snd,(fst,v)⟩}
Ξ(sum) ϕΞ(x){⟨x,(fst,v)⟩}
Ξ(y){⟨y,(snd,v)⟩}
Ξ(fst){⟨fst,(20,l)⟩}
Ξ(snd){⟨snd,(fst,v)⟩}
Ξ(sum){⟨sum,(c.add,m)⟩}Ξ(x){⟨x,(fst,v)⟩,⟨x,(sum,v)⟩}
Ξ(y){⟨y,(snd,v)⟩,⟨y,(40,l)⟩}
Ξ(fst){⟨fst,(20,l)⟩}
Ξ(snd){⟨snd,(fst,v)⟩}
Ξ(sum){⟨sum,(c.add,m)⟩}
Γ⊢c:Calc mtype (add(x,y),Calc)=int→int→intΓ⊢sum:intΓ⊢40 :int
¯p={⟨x:=sum,y:=40⟩}
Ξ(x)∪{x,(sum,v)}Ξ(y)∪{y,(40,l)}Ξ(sum)∪{sum,(c.add,m)}Γ⊢c.add(sum,40):int1 2
3 4
Figure 4:Anexample ofhow Ξ,which mapsdirectvalue exchangesbetween nodes,evolvesovermethod invocations.
probablyrelated.Toextractmaximalsignalfromnames,weexploit
theirinternal structure andextracttheirsubtokens ( Equation3 ).
The key problem then is to exploit these names to automatically
ind groups of nodes in Gthat are conceptually similar. To achieve
this, we design a novel non-parametric clustering method over
graphsthatisbasedoninformation-theoreticconcepts;wedescribe
itbelow.Figure 2showsasample depictionofthe task.
Intheclusteringmethodwepresenthere, names(e)=∅(AssignE
inFigure 3). We made this choice because name lows across op-
erators mustbe selective. Someoftheselowswouldconlate con-
ceptual types. Thus, handling operators would unnecessarily com-
plicateour model,so here we treatoperators as namelow breaks,
just asAssignEtreats functions. To illustrate the problem, imagine
the concatenation of two strings of diferent conceptual types. The
outputmightbeyetanotherconceptualtype.Forexample,concate-
nating a łusernamež string with a łdelimiterž string could result
intoałcsvžstring.Correctlyaddressingthisproblemwouldrequire
teaching the clustering method to be aware of operators polymor-
phic over conceptual types. By excluding the cross-operator name
lowsthat AssignEadds,ourclusteringmethodcan inferthetypes
of all involved terms by learning from their names and all other
usages,essentiallycircumventingthisproblemwithminimalloss
ofinformation.Further, RefiNym toleratesinformationlossfrom
notaddingcross-operatorlowsthatdidoccurbecauseitusesprob-
abilisticmethodsthatrobustlyhandlenoiseandextrapolatefrom
missingdata.Notation. LetG=(N,E)be a name-low (directed) graph. Let C
partition Nandci∈Cbe a part of C. We equip each partition C
with the function parentC:C→2C. Its application, parentC(ci),
returns{c|(n0,n1)∈E∧n0∈c∧n1∈ci}:alltheclustersof Cthat
contain a node directly connected to a node in ci. We overload the
notation for Cto imply both the partition and the random variable
of selecting some ci∈C, since the intended meaning is clear from
context.Ncontains fully scope-qualiied names, but here we are
only interested in the unqualiied name because the namespace
preix adds noise for our task. We use the function nameto extract
the unqualiied name from a node. As with C, we overload Nto
referboththenodesin Gandtherandomvariableofselectingsome
name from{name(n)|n∈N}. Finally, we refer to cieither as a
part oras acluster.
Objective. For the purpose of this explanation, irst consider the
case where we ignore the structure of Gand simply partition N.
Saywecluster Nsuchthateachpart cicontainsonlysimilarnames.
In the limit, this would yield uninformative partitions that contain
nodes with identical names. Instead, we choose to minimize the
variationofinformation1(VI)[6]betweennodenamesandparts. VI
naturallyrepresentsthetensionbetweencreatingtoomanyclusters
thatdonotdifersigniicantlyortoofewthatarenotinformative
abouttheirelements andisdeinedas
VI(C,N)=H(C|N)+H(N|C)=H(N,C)−I(N,C),(1)
1VIisalso known as łshared information distancež.RefiNym: Using Namesto Refine Types ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
whereCandNare the random variables of the nodes’ cluster
labelsandnames, H(A|B)istheconditionalentropyof AgivenB,
H(A,B)is the joint entropy of AandB, andI(A,B)is the mutual
information between AandB.VIis a true metric: it obeys the
triangular inequality. Computing H(C|N)andH(N|C)requires
computing P(C|N)andP(N|C).Wediscussthemodelingchoices
we madetoformulatetheseprobability distributions atthe end of
this section.
Intuitively,tominimize Equation1 ,wesimultaneouslyrequire
positive answers to two questions: łGiven the name of node n, can
we easily predict the cluster (part) it came from ( i.e.P(C|N)has
lowentropy)?žandłGivenacluster,canweeasilypredictthename
of each node ( i.e.P(N|C)should have low entropy)?ž. Thus, the
goal is to pick a łsweet spotž among these two conlicting goals.
This łsweet spotž corresponts to the clustering that provides the
conceptual types. VIselects a single trade-of, valuing H(C|N)and
H(N|C)equally.Ifweminimized H(C|N)andH(N|C)separately,
i.e.asamultiobjectiveoptimizationproblem,wewouldretrievea
Paretofront ofoptimal solutions.
We choose VIas our metric for three reasons. First, it is non-
parametric: it does not require us to specify the number of clusters
upfront (incontrast to methodslike k-means).Second,it relies on
information-theoreticprinciplesthatcaptureourcoreintuitionthat
conceptualtypesandnamesrelecteachother.Finally,itisatrue
metric, so we know that the(theoretical) optimalsolution yields a
VI of0.
Sofar,wehaveignoredthestructurewithinthegraphandtreated
each node separately. However, we want to cluster (or partition or
color)Gso that the parts form a lattice, i.e.there is a well-deined
ordering relation R=(C,⊑)deined by the transitive closure of
∀cj∈parentC(ci):cj⊑ci. Thus, we formulate our clustering
problem as
C∗=argmin
CVI(C,N)s.t.∃R=(C,⊑). (2)
Although the evaluation of Equation 1 has not changed, our search
spaceÐallpossiblepartitioningsof GthatformalatticeÐimposes
avery strongconstraintonour method.
Optimization. Tominimize Equation2 ,weneedtoiterateover
all partitions ofGthat maintain the lattice property on Cand pick
onethatminimizesVI.However,thereisnoobviouswaytoenu-
merate allsuch partitions of Gand, even ifthere were,the space
is prohibitively large. Since we are unaware of existing methods
for minimizing Equation 2 , we resort to the greedy heuristic in Al-
gorithmAlgorithm 1 . We start fromGand assign all disconnected
componentstodiferentclusters.Then,weuniformlysamplearan-
dom permutation over pairs of clusters in Cand try to merge each
pair.The predicate lattice? checks∃R=(C,⊑),i.e.alatticeorder-
ingexistsover C.Thesecondloopuniformlyatrandomenumerates
clusters for splitting. After a candidate merge or split, lattice?
ilters out those partitions that violate the lattice constraint. Other-
wise,weapplyVItodeterminewhetherthenewpartitionimproves
onthecurrentpartition.TheVImeasurementsintheinnerloops
considertwopartitionsthatdiferbyonlyasinglesplitormerge
operation, so we need only compute VI on the changed part(s)
(cluster(s)), signiicantly speeding upthe computation.Algorithm1 Greedy Optimization of Equation2 .
▷Thishelperfunctionapplies ⊕(eithermergeorsplit)tothe
currentcluster Candeachelementofalisttoformanewcluster,
then checks whether the new cluster is better under VI. In the
caseofmerge,thelistelementsarepairsofclusters;for split,
the elements contain asinglecluster.
function ImproveCluster (list,C,Nb,⊕)
improved←False
while!improved∧!list.empty? do
C′←⊕(list.next(), C)
continueif !lattice?(C′)
ifVI(C′,Nb)<VI(C,Nb)then
C←C′; improved←True
returnC,improved
function OptimizeVI (G=(N,E))
C←DisconnectedComponents (G)
Nb←basenames (N)
repeat
improved←False
pairs←samplea permutation over pairs of clusters in C
C,improved←ImproveCluster (pairs,C,Nb,merge)
if!improved then
parts←sampleapermutationover clustersin C
C, improved←ImproveCluster (parts,C,Nb,split)
until!improved∨max number of iterations
returnC
Algorithm Algorithm 1 doesnotenumerate all sequences of
split/mergeoperations:somevalidclusteringsthatmaintainthelat-
ticeorderingcannotbereachedbycombiningsinglenodesplit/merges.
Nonetheless,weindthat,forpracticalnamelowgraphs,wereach
goodsolutions.Furthermore,theirststepofAlgorithm Algorithm1
helpsavoidlocaloptimabyirstsplitting Gintoitsdisconnected
components.
As we discuss later in Section 4 , we empirically ind that our
methodusuallyconvergestothesameor highlysimilarsolutions,
acrossallrandomrestarts.Thissuggeststhatthestructureofour
problemallowsustoreachasimilarsolutionsdespiteusingagreedy
approximation.
Modeling P(N|C)andP(C|N).To compute the conditional en-
tropiesin Equation1 ,weneedtocomputetheconditionalproba-
bilitiesP(C|N)andP(N|C).Computing P(N|C)isintricate, sowe
explainitindetailhere.Oncewehave P(N|C),computing P(C|N)is
straightforwardthankstoBayes’rule.Tocomputetheprobabilityof
aparticularname,wecouldusetheempiricaldistributionofnames
(i.e.theircount)withinacluster c.However,wewanttotakeadvan-
tageoftheinternalstructureofthenamesÐthesubtokenspresent
insourcecodeidentiiers.Weuseasimpleregularexpressionfor
pascal_case orcamelCase to split each name into subtokens. Let
ttokenize a name using this regular expression, then t(n)is the
multiset of subtokens for n. LetSN={s|s∈t(name(n)),n∈N}.
Then,wedeine PSN(s)asamultinomialdistributionoverallthe
subtokens across the set Nof all node names in a cluster. Formally,
for each possible subtoken s∈SN, we associate a probability wsESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Santanu KumarDash,Miltiadis Allamanis, andEarl T.Barr
such that/summationtext
sws=1andws≥0. Then
PSN(n)=/productdisplay
s∈t(n)ws. (3)
Similarly,tocompute PScforacluster,wecouldcounttheem-
pirical frequency of the subtokens within the cluster ( i.e.inSc).
However, computing the maximum likelihood estimate for each
cluster is prone to overitting. To partially overcome this issue, we
resorttoBayesianstatistics.Wespecialize Equation3 foreachclus-
tercby redeining wcs, as follows: We introduce a Dirichlet prior
wc∼Dir(αd)so,for asubtoken sat acluster c,we have
wc
s=count(s∈c)+αds/summationtext
icount(si∈c)+α(4)
whereα≥0 is the importance we assign to our prior and dis
weightsofthepriordistribution.Inthiswork,weset dtotheem-
pirical frequency of the subtokens within G, relecting our prior
beliefthatthesubtokenswithinaclusteraresimilartothesubto-
kensthroughouttheprogram.If α=0,weretrievetheempirical
subtoken distribution within the cluster c. Adding this prior bi-
asesthesubtokendistributionwithinaclustertowardtheempirical
globalsubtokensdistributionandallowsourobjectivetocreatenew
clustersonlywhenacluster’ssubtokendistributionsigniicantly
difersfromtheglobalsubtokendistribution.Italsołsmoothsžsmall
diferences between clusters allowing them to merge when their
diferences are small.
3 IMPLEMENTATION
RefiNym usesthe.NETCompilerframework(Roslyn)[ 9],tocollect
name lows. Our source code is written in C# language version 7.1
andourruntimeversionis4.6.TheRoslyncompilerthatweused
for our experiments is version 2.6. RefiNym’s clustering module
learnsconceptualtypesfromname-lowsharvestedthroughRoslyn
usingthetechniquesdescribedin Section2.2 .Therewritingmodule
thenmodiiestheprogramautomaticallytointroducethelearned
conceptualtypes intothe originalprogram.
RefiNym’sclusteringalgorithmisimplementedinC#usingstan-
dard.NETlibraries.Tospeed-uptheimplementationofAlgorithm 1
we make extensive use of caching. At each iteration, only two clus-
ters will be merged or only one will be split. Consider two cluster-
ings that difer only in a single merge m(c0,c1)or splits(c1)opera-
tion. Algebraically, the diference in the VI of these two clusterings
depends only on the two merged clusters or the single split cluster,
independent of the rest of the clusters in each clustering. Because
computing VI is so expensive, we cache the VI diferences of these
operations, keyed by the operation and its operand(s) i.e.m(c0,c1),
then check the cache when evaluating VI(C′,Nb)<VI(C,Nb)in
Algorithm 1 . Furthermore, computing the VIimprovement over
potentialsplit/mergeoperations isembarrassinglyparallel.
RefiNym’srewritertranslatesthelatticeformedbytheclustering
approachdescribedin Section2.2 intoC#code.Todothis,wedeine
latticepointsasuser-deinedtypesandsubtypingrelationsbetween
the points as type casts. Additionally, we need two other forms
of implicit casts: from a primitive type to a conceptual type and
back. For deining these casts, we use the implicit operator
keywords in C#. An implementation of a conceptual type with
conversions to and from the stringtype is shown in Figure 5.1classWord {
2publicWord(strings) { val = s; }
3private readonly stringval;
4public static implicit operator string(Word w) {
5 returnw.val;// Convert Word to a string
6}
7public static implicit operator Word( strings) {
8 return new Word(s); // Convert string to a Word
9}
10}
Figure 5:Auto-castingbetween aclass Wordand strings
Here,valstoresthevalueboundtotheoriginalprimitivetype.The
methods with implicit operator qualiiers cast a stringto the
learnedconceptualtype Wordandback.
C# is an industrial language with many features. RefiNym’s
rewriter supports a large subset of all rules in C#’s grammar. Re-
fiNymhandles pass by value and by reference. For the latter, Re-
fiNympassesareferencetothe valinsideaconceptualtypebound
totheprimitivetype.Forexample,in Figure5,RefiNym replaces
alloccurrencesofthequaliiedtype ref string x withref Word
x.val. For library calls, where RefiNym cannot rewrite the source
code, it upcasts arguments that are conceptual types into the origi-
nalprimitivetype.Similarly,itdowncastsreturnvaluesfromthe
librarycallsthatareofprimitivetypestoconceptualtypes.Itap-
pliesthesametechniquewhencallingamethodthatisdeinedonly
for a primitive type and when indexing collections of primitive
typessuchasarrays. RefiNym currentlyabstainsfromrewriting
primitive types that have type qualiiers such as constto preserve
program semantics. Details can be found in the source code at
htp://github.com/askdash/refinym .
Atestamenttotheversatilityand utilityof RefiNym’s rewriter
is the fact that it onlymakes 4 errors per 10KLOC on our corpus
(Table 1), which covers diverse application domains. All of these
errorsareduetothefactthat RefiNym doesnotyetcoverallterms
inthe C#grammar,like its higher-order functions.
Deployment. RefiNym isfullyautomatic.Itcanbeeasilymerged
intoworklowswithlittleintegrationoverhead.Althoughwedemon-
stratetheutilityofourtoolusingC#asanexample,ourtechniques
andthecore ofour learningframework isprogramminglanguage
agnostic. We harvest name-lows though assignments and our tool
canleverageanylowanalysisframeworkforanylanguage.ForC#,
we have implemented our toolasa command linetoolthat canbe
usedatdevelopment time.Theprogrammercanselectaprimitive
orauser-deinedtype(UDT)andinvoke RefiNym toautomatically
collectname-lowsforvariablesofthattype,identifypotentialcon-
ceptual type through the clustering, and rewrite the syntax tree to
automatically introduce these conceptual types. After rewriting,
the syntax tree is automatically recompiled and the tool reports
the efect of the rewriting by echoing Roslyn’s messages, including
compilation errors,to the plugin’sconsole.
Whileinferringtheinitialclusteringisanovernighttask,once
a clustering is inferred, it could be eiciently updated, given in-
crementalchanges,sinceonlythepartsofthegraphthatchange
needto be checked forpotential splitormergeoperations with
otherclusters.Furthermore,givenastaticclustering,classictype
inference methods can be used to infer the conceptual types of
newlyintroducedcode elements.RefiNym: Using Namesto Refine Types ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
Figure 6:Validating RefiNym viatype reconstruction.
RefiNym facilitates a developer’s exploration of type lattices.
Conceptualtypesandprogramtypescandivergeduringdevelop-
ment. Developers are focused on bug-ixing and rapid prototyping
butnoton type constraints.For adeveloper,merging changesup-
stream through branch promotion is natural time to address the
divergencebetweenprogramtypesandconceptualtypes.Thisis
whereRefiNym can be an excellent aid. Developers can install and
useitlocallyontheirmachinestoreviewtheiruseoftypeswithout
impactingotherdevelopersorneedingtosecurepermissionfrom
management.Webelievethatself-vettingpriortobranchpromo-
tionisause casefor which RefiNym isparticularlywell-suited.
4 EVALUATION
Here,weevaluatehowwell RefiNym identiieslatentconceptual
types by applying itto the task of reconstructing user-deinedtype
after they have been artiicially merged ( Section 4.1 ) and how well
it combats primitive obsession ( Section 4.2 ).Section 4.3 closes with
acasestudy ofthe clusters RefiNym produces.
Initially, we used the NancyFx project as our development set
for constructing RefiNym. To evaluate RefiNym, we turned to real-
worldopen-sourceprojects,systematicallyselectedasfollows.First,
we selectedtop C# GitHub projectsand removed projects thatwe
couldnotcompile.Wealsoselectedascientiicorphysicslibrary
called BEPUphysics Ð a 3D real-time physics simulator Ð to show
howRefiNym reiies types for variables that represent physical
quantitiesorunits. Table1showsdetailsofthese14C#projects.Our
experimentswereperformedona2.7GHzIntelCorei7machine
with16GBofmemory running OSX version10.13.3.
4.1 Reconstructing UDTs
Toassesshowwell RefiNym infersconceptualtypes,weartiicially
createamismatchbetweenaprogram’sconceptualtypesandits
program type lattice. Essentially, we monotype user-deined types
(UDTs)inthe program. Werestrictour attentiontoUDTsbecause
theytendtobepreciseandnotsubjecttoprimitiveobsession.Re-
strictedtoaprogram’sUDTsub-lattice,werewriteallUDTtype
annotationsto⊤,i.e.objectinC#.Figure6showstheprocess.The
resultisaprogramwithamaximaldivergencebetweenitsprogram
latticeanditsconceptualtypelatticeforUDTs;aprogramforwhich
we know the ground truth, assuming the correctness of the orig-
inalprogramtypeUDTsublattice.RecoveringtheoriginalUDTs
from this program is the UDT reconstruction problem . This problem
isparticularlychallengingfor RefiNym becauseitmonotypesall
UDTs, not a small subset of them. Then we ran RefiNym on the
monotyped program and ask łHow well does RefiNym recover the
originalprogram’s UDTs?ž.
To assess the quality of RefiNym’s reconstructionof UDTs, we
computehomogeneityHandcompleteness [24].Homogeneitymea-
suresthediversityoflabelsacrossallclusters(lowdiversityimplies
high homogeneity); completeness measures the extent to which0.2 0.4 0.6 0.8 1.0
Cluster Purity Score101102Frequency (log scale)
(a)Purity Distribution0 50 100 150 200 250
Cardinality0.00.20.40.60.81.0Cluster Purity Score
(b)Cardinality vs.Purity
Figure 7: RefiNym ’s performance at UDT reconstruction.
Figure 7a shows the distribution of cluster purity over our
corpus(noticelog-scalein yaxis):RefiNym perfectly (gener-
ating purity 1 clusters) reconstructs 77% of UDTs. Figure 7b
showsthedistribution ofcluster purity vs.size.
clusters contain all elements of a label. Like the more familiar pre-
cisionandrecallfrominformationretrieval,homogeneityandcom-
pleteness are in tension: increasing homogeneity tends to decrease
completeness, as you may lose elements of a target label when
shedding elements with an undesirable label. For a set of elements
for which Cis a clustering and Kis a labeling, homogeneity ( H) is
H(C,K)=1, ifH(C,K)=0
1−H(K|C)
H(C)otherwise,(5)
whereHis the Shannon entropy. Completeness is H(K,C).H
rangesfrom0to1.Highhomogeneitymeansthatthelabeldistri-
bution ofelementswithina cluster is skewed toward one label i.e.
the conditional entropy H(K|C)isclose to zero.
AsTable 1shows,RefiNym averages a homogeneity score of
0.80andacompletenessscoreof0.91ontheUDTreconstruction
task.Thebalancebetweenthesetwoaveragesshowsthat RefiNym
isefectivelyextractingsignalfromnamestogroupthemajority
of related names to achieve high completeness without simulta-
neouslyadding manyunrelated names, therebymaintaininghigh
homogeneity.
Homogeneityand completeness are globalmeasures ofa clus-
tering.RefiNym equatesclusterswithconceptualtypes.Thus,to
understand RefiNym’sperformanceatconceptualtypeinference,
we must assess its performance at the granularity of individual
clustersandlookatitspurity.For RefiNym toperfectlysolvethe
UDT reconstruction problem, each cluster must exactly coincide
withconceptualtypes.The purityofaclusteristheproportionof
its dominant label. The objective of the type reconstruction here is
to segregate nodes in the name-lows into pure clusters, those that
contain only names of the same type. This is not enough, however,
becauseanoriginalUDT’stypecouldbefragmentedinto kdiferent
clusters, eachofpurity1.
Figure7a showsthedistributionofpurityscores.Thekeyinding
here is that, at this very hard UDT reconstruction problem, 72% of
the types/clusters RefiNym inds have purity 1. This means that
RefiNym rewritercould reifythemintheprogram andtherewrit-
ten program would still type check. Since RefiNym’s clustering
module is unaware of the types for which the lows have been
harvested,thispurityresultalsoveriieshowmuchsignalidenti-
iers carry about their type. We now consider the fragmentationESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Santanu KumarDash,Miltiadis Allamanis, andEarl T.Barr
Table1:C#CorpusfromGitHub.HomogeneityandCompletenessScoresforReconstructedUser-DeinedTypes(UDT).Right-
hand columns report the reduction in the number of co-occurrences of the the type stringin the same scope by running
RefiNym with theexceptionofBEPUphysics that containsno string variables.
# same-typevariables per scope % removed
Name SHA Description kSLOC Homogeneity Completeness Before After critical
Mean Median Mean Median scopes
BEPUphysics 2f05f5e3 3D Physics Simulation Library 45.3 0.79 0.93 ś ś ś ś ś
Commandline 451be765 CommandLineParser 9.6 0.76 0.86 4.2 4 2.3 1 9.3
CommonMark e94800e6 Markdown Parser Library 13.9 0.79 0.80 1.5 1 0.1 0 35.2
Hangire ffc4912f Background JobProcessing Library 33.4 0.70 0.94 2.3 2 0.8 0 15.4
Humanizer cc11a77e String ManipulationLibrary 27.1 0.76 1.00 2.7 2 0.9 0 42.9
Lean f574bfd7 AlgorithmicTrading Engine 190.0 0.82 0.94 4.1 1 1.1 0 33.1
Nancy e589dc9b HTTP Service Framework 69.5 0.69 0.88 3.1 2 1.1 1 21.1
Newtonsoft.Json 372c396e JSONLibrary 119.7 0.76 0.90 3.4 3 2.8 2 8.0
Ninject 1c84b358 CodeInjectionLibrary 12.8 1.00 1.00 1.4 1 0.4 0 4.9
NLog 39541571 ApplicationLoggingLibrary 67.4 0.84 0.89 3.5 3 1.5 1 30.2
Quartznet b33e6f86 Scheduler 49.3 0.81 0.89 66.8 14 12.5 2 19.7
RavenDB 9d9ed290 Database 581.7 0.89 0.93 4.0 3 2.0 1 11.9
RestSharp 70de357b REST and HTTP API Client Library 20.3 0.79 0.85 6.7 5 1.3 0 30.2
Wox cdaf6272 Windows ApplicationLauncher 13.2 0.80 0.94 4.6 4 1.3 0 22.7
Average 86.4 0.80 0.91 8.7 3.4 2.2 0.6 21.9
of these pure clusters relative to the ground truth UDT labels. 62%
oftheUDTsmaptoexactlyone fragment,meaningthat RefiNym
perfectlyreconstructs the type of their UDT! 90% of the UDTs have
4orfewerfragmentsandthemaximumnumberoffragmentsfor
aUDTis30.Datasparsity,whichweexplorebelowwhenanalyz-
ing the impure clusters, accounts for some fragmentation. Other
fragmentationmayarisebecause RefiNym iscorrectlyseparating
mergedconceptualtypes(deinednext),despiteourfocusonUDTs.
Impureclustersappeartoresultfrominsuicientdata: Figure7b
is scatterplot of purity vs.size and shows that smaller clusters,
for which we have fewer data points, tend to be impure, while
bigger clusters tend to be pure. Manual inspection of mid-sized
clusters shows that misclassication tends to occur when the name-
lowgraph issmall andtherefore RefiNym reliestoo muchnames
alone.Forexample, ConfigurationItemFactory andLogFactory
are instances of the factory design pattern in our data set. Their
variablesdonotlowintoothervariables,so RefiNym clusterstheir
variablesintoasingleconceptualtypebecauseoftheirlinguistic
similarity.Thesecondclassoferrors RefiNym makesisthemerg-
ing of an uncommon type and its subtype ( e.g.LoggingRule and
ConsoleRowHighlightingRule inNLog)intoonecluster.Thisis
duetodatasparsityagain; RefiNym assumesthatthediversityof
thesenames does not warrantcreating anewtype.
4.2 CombatingPrimitiveObsession2
Merged conceptual types (MCT) are distinct conceptual types that
sharethesameprogramtype.Mergedconceptualtypesmayhold
very diferent data. A program may store both passwords and user-
namesin string.Whenvariablesofthesemergedconceptualtypes
share a scope, the type system cannot warn the developer if she
mistakenlystoresapasswordintoaname.Examplesofsuchscopes,
whichwecall critical,inourcorpusinclude Figure1inwhichserver
address, terminal, username and password conceptual types share
string.Asecond example fromtheRavenDB projectisshown in
2Arguably, primitive obsession is a misnomer, especially when applied to strings
in C# because strings are built-in types, not primitives. Throughout this paper, we use
primitive obsession to refer to the overuse of either the primitive or built-in types of a
language,notincludingthetypesinalanguage’sstandardlibrary(althoughonecould
argue for theirinclusion).1varjson = RavenJObject.FromObject(backupRequest).ToString();
2varurl ="/admin/backup" ;
3varreq = CreateRequest(url, "POST")
4req.WriteAsync(json).Wait();
Figure 8:Primitive obsessioninRavenDB.
Figure 8where the URL and the request JSON are conlated into
thestringtype.
RefiNym canidentifysuchscopes,suggestnewtypeannotations
thatseparatetheirMCTs,and automatically rewritetheprogram
to use these new types when the developer accepts a suggestion
(Section 3). Here, we ask łHow many critical scopes does RefiNym
eliminate?ž.Toanswerthisquestion,weran RefiNym onourcorpus
toreinestringandindthat21.9%ofcriticalscopesareeliminated
i.e.scopesthatcontainedMCTvariablesbeforerunning RefiNym
but contains reiied variables of a given (reined) type, after ac-
ceptingRefiNym’sreinements.Inallthesescopes, RefiNym has
freedthetypesystemtodoitsjobandwarnthedeveloperabout
potentially unwanted lows across conceptual types. For every crit-
ical scope,we alsoreportthe numberof MCTvariableswhich are
potential sources of confusion that result in no type errors. Table 1
shows that on average RefiNym reduces the number of same-type
variables in each scope from 8.7 to 2.2. This shows that RefiNym’s
suggestions reduce the possibility of inadvertently introducing
cross-conceptual type lows.
4.3 CaseStudy
We have just shown that RefiNym efectively identiies conceptual
types through its performance at reconstructing UDTs and then
showedhowacceptingitsreinementscanreducethenumberof
scopes in which a developer could introduce an unwanted low.
Here,we manually delve intoandanalyze someof its results.
RefiNym’s Primitive Reinements. We ranRefiNym over our cor-
pus reining stringfor all projects except BEPUphysics where
we reined float.Table 2andTable 3present a selection of the
namesRefiNym clusteredintointoconceptualtypesfor Nancyand
BEPUphysics .Naturallanguageutterancesortextcanbediverse,RefiNym: Using Namesto Refine Types ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
Table 2: Conceptual types from stringreinements in Nan-
cyFx, aframeworkforbuildingHTTPbased services.
Full nameof nodesorconstantvalues
1path,originalRequestPath ,modifiedRequestPath ,contentPath ,
"/emailConstraint/" ,basePath ,IViewEngineHost::ExpandPath ,
AspNetRootPathProvider::’etRootPath ,"/",owinRequestPath ,
DiagnosticsConfiguration::’etNormalizedPath ,Path,
NancyContext::ToFullPath ,ModulePath
2DefaultCulture ,defaultCulture ,cookieCulture ,cultureLetters ,name
3earlyExitReason ,"Requires Any Claim" ,"Requires Claims" ,
"Requires Authentication" ,"Accept"
4IObjectSerializer::Serialize ,DefaultObjectSerializer::Serialize ,
JsonObject::ToString ,SimpleJson::SerializeObject ,
HttpQsCollection::ToString
5method,Method,
"PUT","POST","PATCH","OPTIONS" ,"HEAD","’ET","DELETE"
6value,cookieValue ,sourceString ,"SomeValue" ,cookieValueEncrypted ,
attemptedValue ,decryptedValue ,defaultValue
7password ,"password" ,realPassword ,plainText ,Password
8HttpUtility::UrlDecode ,HttpUtility::UrlPathEncode ,url,path,
HttpUtility::UrlEncodeUnicode ,redirectUrl ,fallbackRedirectUrl
9header,"Accept-Language" ,"Accept-Encoding" ,"Accept-Charset" ,
"X-Custom" ,"Content-Disposition" ,"Vary","Etag"
exhibiting correct variation or noisy, exhibiting erroneous varia-
tion. Here, we discuss RefiNym’s robustness to natural language’s
diversityandnoise.
Unsurprisingly,mostclusterscontainlexicallysimilar,eveniden-
tical, names, because we expect similar or identical names to low
into each other. For example, all names in cluster 1 of Table 2
containthesubtoken path.Inthiscluster, pathappears73times,
althoughwe showeachnameonly onceinthetables.Cluster2in
Table3containsmanynamesrelatedtodistance,suggestingthat
RefiNym not only inds similar, or identical names, but copes with
the diversityofreal-world names.
RefiNym alsoindsclustersthatincludelexicallydissimilarel-
ements because of noise. For example, cluster 7 in Table 2predomi-
nantly contains the subtoken password but also the (badly named)
variableplainText . We deem this name noisy because it has no
textual similaritywith theother elements.Indeed, manualinspec-
tion reveals that plainText is always used to represent passwords
inthemethod byte[] ’enerateSaltedHash(string plainText,
byte[] salt) thatgeneratesahashforstoringpasswords.Clus-
teringplainText together with password wouldnothave been
possible if RefiNym only considered names and not the lattice
constraint over the name low graph. The interplay ofthe lattice
constraint and names allows RefiNym to tolerate noise and to gen-
eralize conceptual types across synonyms, alternative names, even
typos. For example, in Wox (not shown), we ind a cluster that con-
tains both pythonDirectory andpythonDirecotry (misspelled).
RefiNym also includes literals in G. Their values are notused
duringclustering,sincevaluesinstantiatetypes, i.e.areelements
of types, and therefore we expect little (textual) similarity between
literal values and variable or method names. However, given the
latticeconstraint,wecanstill clusterthem togetherwith other lit-
eralsandvariables.Anexampleofasuccessfulclusteringofliterals
andvariablesiscluster5in Table2.Itshowsaconceptualtypethat
corresponds to HTTP methods. Reining this conceptual type is
straightforward,requiringtheintroductionofanenumerationtype
whichcan preventbugs triggered when a random stringis passed
as an HTTP method. RefiNym also mined a conceptual type for
HTTPheaders(cluster9in Table2).Table 3: Sample conceptual type (cluster) nodes for float
type inBEPUphysics, aphysics simulation C#project.
Fullnameof nodes orconstantvalues
1damping,SuspensionDamping ,starchDamping ,dampingConstant ,
angularDamping ,LinearDamping
2currentDistance ,distance3 ,candidateDistance ,
pointDistance ,distanceFromMaximum ,grabDistance ,
VariableLinearSpeedCurve::’etDistance ,tempDistance
3goalVelocity ,driveSpeed ,’oalSpeed
4minRadius ,MinimumRadius ,Radius,minimumRadiusA ,
WrappedShape::ComputeMinimumRadius ,topRadius ,MaximumRadius ,
graphicalRadius ,TransformableShape::ComputeMaximumRadius
5blendedCoefficient ,KineticFriction ,dynamicCoefficient ,
KineticBrakingFrictionCoefficient
6angle,myMaximumAngle ,MinimumAngle ,currentAngle ,MaximumAngle ,
steeringAngle ,MathHelper::WrapAngle
7targetHeight ,Height,ProneHeight ,crouchingHeight ,standingHeight
8mass,effectiveMass ,newMassA ,newMass
9m22,m11,M44,resultM44 ,M43,intermediate ,m31,X,Y,Z
Inferring Unit Types. Units of measure and unit types are im-
portant in numericalcomputation. They can prevent a wide range
oferrors,suchasperforminginconsistentoperationsonphysical
quantities, e.g.adding velocity to an angle, or adding two variables
of the same physical quantity that are nevertheless measured on
a diferent unit, e.g.adding radians to degrees. The well-known
NASA’sMars Climate bug[ 25]exempliiestheir importance.
RefiNym’s focus is proposing nominal type reinements, not
unit types. Nevertheless, it distinguishes physical quantities and
coeicientsassigningthemtodiferentconceptualtypes. Table3
showsaselectionofclustersof floatvariables RefiNym indsin
BEPUphysics, a physics simulation project. Cluster 3 represents
speed-relatednodes;cluster8containsmass-relatednodes;andclus-
ter6 refers to angles.Thus, RefiNym canhelpdevelopersidentify
unittypes, alleviatingthe burden of manual annotation.
SinceRefiNym infersalatticeofconceptualtypes,itdetectsunit-
less coeicients, such as damping (cluster 1) and friction (cluster 5)
factors.Althoughallunitvariablesmaylowintogenericvariables,
RefiNym clusters such variables to appropriate supertype clusters.
For example, cluster 9 represents a common supertype of many
numericalquantitiesandincludesgeneric(orconceptless)variables
such as elements of a matrix ( e.g.m11) or generic vector coordi-
nates (X,Y,Z). Again, the reader may notice that cluster 9 ( Table 3)
contains highly diverse names with no textual similarity. These
namesareneverthelessclusteredtogetherthankstotheconstraints
imposedbythe RefiNym’slattice constraint.
QualitativeErrorAnalysis. Likeallmachinelearning, RefiNym
doesnotyieldperfectresults.Here,wequalitativelydiscusscom-
mon errors we observed and speculate about their causes. Re-
fiNym’smostcommonerroristoconlatenodesthatarelinguis-
ticallysimilar,butrepresentdistinctconceptualtypes.Manualin-
vestigation reveals that most of these errors arise because these
nodesbelongtodisconnectedcomponents,so RefiNym couldnot
collect name-low constraints among them. This commonly occurs
inlibrarieswhichprovideexternalAPIstotheiruserswithoutus-
ing them internally. These unused (public) methods ( i.e.the library
APIs) break the low in the name low graph resulting in discon-
nectedorlooselyconnectedcomponents.Inthefuture,aggregating
information from external uses of a library may alleviate this issue.ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA Santanu KumarDash,Miltiadis Allamanis, andEarl T.Barr
RefiNym also generates łsuperclustersž that contain alarge set
of mostlyunrelatednodes. RefiNym may be creatingthese super-
clusters because of the incompleteness of its split/merge operators
andthegreedyheuristic(Alg. 1).Thesesuperclustersmaynotbe
errors. They suggest that our information-theoretic objective does
notconsider further splitting to be statistically important or use-
ful. So, even though these superclusters may seem erroneous to
humans, it may be that RefiNym is inding base types in them that
arenotworth reining. This suggests an interesting new empiri-
cal research direction: ł DoesVIcorrelate with the usefulness of a
program’s type lattice? ž Starting from a monotyped program, VI
improves as the type lattice becomes more ine-grained. When the
type lattice becomes too ine-grained, VIstarts worsening again.
Thisphenomenonmayalsoberelatedtotheincreasingburdenof
gradually more complex type annotations inaprogram.
5 RELATED WORK
Typesinprogramminglanguagesarerecognizedfortheirabilityto
providereasonableguaranteestoaprogrammer,givenawell-typed
program. This worksrests on theobservation that theconceptual
typesdevelopershaveinmindandthetypestheyactuallyreifyina
programcandiverge.Aninstanceofthisisthełprimitiveobsessionž
codesmell[ 12,20,26,28],whichpractitionersacknowledge.This
smellisbadpracticeofusingprimitiveorbuiltintypesforelements
ofdistinctconceptualtypes.Primitiveobsessionmergesconceptual
types, like the use of intfor both IDs and counts that may lead
to a type-correct addition of an ID and a counter. RefiNym uses
code’sbimodalitytoindtypereinementsthatalignsconceptual
andprogramtypes,surfacinglatentconceptualtypestothetype
systemandalleviatingprimitive obsession.
Inferenceofabstractdatatypes(ADT)[ 11,22]isrelatedto Re-
fiNymsince both methods can be used to reine a program’s types
bylearningvariousformsofADTs.Lackwit[ 22]staticallyinfers
ADTsbyusingthelowofdataandassigningADTstoasetofvari-
ablesthatcanlowamongeachother.However,Lackwitsolelyuses
data low. In contrast to RefiNym, Lackwit cannot ind conceptual
types that share lexemes but whose variables have no low and
thereforesufersfromlowprecision[ 11].RefiNym avoidsthisissue
byexploitingtherichnaminginformationinsourcecodetoprovide
precise and consistent ADTs. Guo et al . [11]inferred ADTs from
primitives by dynamically observing the interactions only among
variable values, without learning or reining a type lattice. Their
approach is dynamic, requiring a representative set of run-time
data and broad code coverage. In contrast, our method is based on
purelystaticinformationandaimstoreineaprogram’stypes.Haq
etal.[13]usedynamicADTinferencetoindvariablesthatinter-
act. Then, they use variable names and a heuristic name-similarity
metrictodetectundesiredvariableinteractions,byclusteringthe
names within each ADT. In contrast, RefiNym reines types based
onsignalfromnames,ratherthanusingnamesinapost-processing
step.Furthermore,ourunsupervisedinformation-theoreticmethod
circumventsspecifying apriorithe number ofclusters.
RefiNym makesheavyuseofcodebimodality, i.e.theproperty
that human-written code contains two modalities: one for com-
municating with the hardware and one for communicating among
humans.BimodalityextendstheobservationsofHindleetal .[15]
whofoundthatcodeisłnaturalž.Withthisintuition,alargecorpusof work has followed[ 2]. Central to our work are the source code
identiiers of variables and methods. Identiier names have been
found to have a profound efect on code readability [ 5,17] and de-
velopers greatly care about the names used within source code [ 1].
Badvariablenameshavebeenusefulfordetectingbugs[ 19]and
are treated as anti-patterns in software development [ 3].RefiNym
isbasedonthisintuitionandthatdevelopersmakegreatefortto
pickgoodnamesandthereforecanprovidevaluableinformation
tobothhumansandmachinelearningmethods.Ofcourse,types
and identiier names are intricately connected since they both aim
to disambiguate entities,something that we explore inthis work.
The notion of types appears in natural language processing
through the concepts of hypo/hypernymy [ 7], the identiication of
namedentities[ 18,23]andsemanticparsing[ 16].Althoughconcep-
tuallythisnotionoftypeissimilartotheoneusedinprogramming
languages, a łsofterž non-discrete approximation is used given the
ambiguous nature ofnaturallanguage.
Clustering is a common topic in unsupervised machine learning
and datamining [ 30]thataimstoinferthestructureofsomedata
in an unsupervised way. Common machine learning methods such
ask-meansclusteringandGaussianmixturemodels(GMM)[ 21]
makestrongparametricassumptionsandaremostlyusedtocluster
individualindependentelements.Non-parametricmethods,suchas
DPGMM [ 27] and information clustering [ 10,29] do not require to
deinethenumberofclustersapriori.Information-theoreticclus-
tering,whichweuseinthiswork,isanattractivesetofmethods
since it makes no assumptions about the underlying data. Our core
noveltyovertraditionalnon-parametricclusteringmethods,includ-
ing information-theoretic methods, is that our method operates on
graph structures andinfersclustersthat have alattice structure.
Finally, the problem of grouping elements of a graph, resembles
the idea of community detection in (social) network analysis [ 8].
There,thegoalistodetectcoherentcommunitiesinthenetwork.In
contrastto RefiNym,suchmethodsmostlyrelyondetectingtightly
connected regions within a graph based on its structure without
consideringadditionalconstraintsoverthecontentofeachnodeor
the structure/relationship of eachcommunity/cluster.
6 CONCLUSION
In this work, we presented RefiNym, a method for mining concep-
tual types from existing source code. To achieve this, we cluster
over source code elements, such as variables, methods and liter-
als exploiting the interplay of their names and the structure of
assignment lows. Through this process, we retrieve a ine-grained
implicit conceptual type lattice that we use to suggest reinements.
Wepresentedquantitativeandqualitativeevaluationofourmethod
thatshowthe promisesof thisdirection inding thatthe proposed
reinements related strongly with conceptual types and can be
useful for assisting developers to deine more explicit type lattices.
Inthefuture,webelievethatthebimodalityofsourcecode, i.e.
its natural languageaspectsand its rich structure can be exploited
to ofer improved software engineering tools and assist program
analyses. This requires to develop new techniques that bridge pro-
gramming language concepts with machine learning methods and
preserve code semantics.RefiNym: Using Namesto Refine Types ESEC/FSE’18,November4ś9, 2018, Lake Buena Vista,FL,USA
REFERENCES
[1]Miltiadis Allamanis, Earl T Barr, Christian Bird, and Charles Sutton. 2014. Learn-
ingnaturalcodingconventions.In Proceedingsofthe22ndACMSIGSOFTInterna-
tional SymposiumonFoundationsofSoftwareEngineering . ACM,281ś293.
[2]Miltiadis Allamanis, Earl T Barr, Premkumar Devanbu, and Charles Sutton. 2018
(toappear). ASurveyofMachineLearningforBigCodeandNaturalness. Comput.
Surveys(2018 (to appear)).
[3]VeneraArnaoudova,MassimilianoDiPenta,GiulianoAntoniol,andYann-Gael
Gueheneuc.2013.Anewfamilyofsoftwareanti-patterns:Linguisticanti-patterns.
InSoftwareMaintenanceandReengineering(CSMR),201317thEuropeanConference
on. IEEE,187ś196.
[4]VeneraArnaoudova,LalehMEshkevari,MassimilianoDiPenta,RoccoOliveto,
Giuliano Antoniol, and Yann-Gael Gueheneuc. 2014. Repent: Analyzing the
natureofidentiierrenamings. IEEETransactionsonSoftwareEngineering 40,5
(2014), 502ś532.
[5]Raymond PL Buse and Westley R Weimer. 2010. Learning a metric for code
readability. IEEE Transactions onSoftwareEngineering 36,4 (2010), 546ś558.
[6]Thomas M Cover and Joy A Thomas. 2012. Elements of information theory . John
Wiley& Sons.
[7]JiaDeng,JonathanKrause,AlexanderCBerg,andLiFei-Fei.2012. Hedgingyour
bets: Optimizing accuracy-speciicity trade-ofs in large scale visual recognition.
InComputerVisionandPatternRecognition(CVPR),2012IEEEConferenceon .IEEE,
3450ś3457.
[8]David Easley and Jon Kleinberg. 2010. Networks, crowds, and markets: Reasoning
about a highly connectedworld . CambridgeUniversityPress.
[9].NETFoundationandContributors.2018. .NETCompilerFrameworkśRoslyn.
htps://github.com/dotnet/roslyn . (2018). [Online;accessed 2-March-2018].
[10]Erhan Gokcay and Jose C. Principe. 2002. Information theoretic clustering. IEEE
Transactions onPatternAnalysisand MachineIntelligence 24,2 (2002), 158ś171.
[11]Philip J Guo, Jef H Perkins, Stephen McCamant, and Michael D Ernst. 2006.
Dynamic inference of abstract types. In Proceedings of the 2006 international
symposiumonSoftwaretestingand analysis . ACM,255ś265.
[12]Refactoring Guru. 2017. Primitive Obsession. htps://refactoring.guru/smells/
primitive-obsession . (2017). [Online;accessed 15-Aug-2017].
[13]Irfan Ul Haq, Juan Caballero, and Michael D Ernst. 2015. Ayudante: Identifying
undesired variable interactions. In Proceedings of the 13th International Workshop
onDynamic Analysis . ACM,8ś13.
[14]Mark Harman and Bryan F Jones. 2001. Search-based software engineering.
Informationand softwareTechnology 43,14(2001), 833ś839.
[15]AbramHindle,EarlTBarr,ZhendongSu,MarkGabel,andPremkumarDevanbu.
2012. Onthenaturalnessofsoftware.In SoftwareEngineering(ICSE),201234th
InternationalConference on . IEEE,837ś847.[16]JayantKrishnamurthy,PradeepDasigi,andMattGardner.2017. Neuralsemantic
parsing with type constraints for semi-structured tables. In Proceedings of the
2017ConferenceonEmpiricalMethodsinNaturalLanguageProcessing .1516ś1526.
[17]Dawn Lawrie, Henry Feild, and David Binkley. 2007. An empirical study of rules
forwell-formedidentiiers. JournalofSoftware:EvolutionandProcess 19,4(2007),
205ś229.
[18]Xiao Ling, Sameer Singh, and Daniel S Weld. 2015. Design challenges for entity
linking.Transactions of the Association for Computational Linguistics 3 (2015),
315ś328.
[19]HuiLiu,QiurongLiu,Cristian-AlexandruStaicu,MichaelPradel,andYueLuo.
2016. Nomen est omen: Exploring and exploiting similarities between argu-
ment and parameter names. In Software Engineering (ICSE), 2016 IEEE/ACM 38th
InternationalConference on . IEEE,1063ś1073.
[20]MikaMantyla.2003. Badsmellsinsoftwareśataxonomyandanempiricalstudy.
HelsinkiUniversityofTechnology (2003).
[21] Kevin P. Murphy. 2012. Machinelearning: a probabilisticperspective .
[22]RobertO’CallahanandDanielJackson.1997. Lackwit:Aprogramunderstanding
toolbasedontypeinference.In InProceedingsofthe19thInternationalConference
onSoftwareEngineering .
[23]Jonathan Raiman and Olivier Raiman. 2018. DeepType: Multilingual Entity
LinkingbyNeuralTypeSystemEvolution. arXivpreprintarXiv:1802.01021 (2018).
[24]Andrew Rosenberg and Julia Hirschberg. 2007. V-Measure: A Conditional
Entropy-BasedExternalClusterEvaluationMeasure.In Proceedingsofthe2007
Joint Conference on Empirical Methodsin NaturalLanguage Processing andCom-
putational Natural Language Learning(EMNLP-CoNLL) . 410ś420.
[25]BrianJSauser,RichardRReilly,andAaronJShenhar.2009. Whyprojectsfail?
HowcontingencytheorycanprovidenewinsightsśAcomparativeanalysisof
NASA’s Mars Climate Orbiter loss. International Journal of Project Management
27,7 (2009), 665ś679.
[26]Mark Seemann. 2017. Primitive Obsession. htp://blog.ploeh.dk/2011/05/25/
DesignSmellPrimitiveObsession/ . (2017). [Online;accessed 15-Aug-2017].
[27]Yee Whye Teh and Michael I Jordan. 2010. Hierarchical Bayesian nonparametric
models with applications. Bayesiannonparametrics 1 (2010), 158ś207.
[28]Beyond the Lines. 2018. Leveraging the type system to
avoid mistakes. htps://www.beyondthelines.net/programming/
leveraging-the-type-system-to-avoid-mistakes/ . (2018). [Online; accessed
13-May-2018].
[29]Greg Ver Steeg, Aram Galstyan, Fei Sha, and Simon DeDeo. 2014. Demystifying
information-theoreticclustering.In InternationalConferenceonMachineLearning .
19ś27.
[30]Rui Xuand Donald Wunsch. 2005. Survey of clustering algorithms. IEEE Trans-
actions onneuralnetworks 16,3 (2005), 645ś678.
View publication statsView publication stats