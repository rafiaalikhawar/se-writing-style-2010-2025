Understanding and Detecting Wake Lock
Misuses for Android Applications
Y epang LiuxChang Xu‚Ä°Shing-Chi CheungxValerio Terragnix
xDept. of Comp. Science and Engineering, The Hong Kong Univ. of Science and Technology, Hong Kong, China
‚Ä°State Key Lab for Novel Software Tech. and Dept. of Comp. Sci. and Tech., Nanjing University, Nanjing, China
x{andrewust, scc*, vterragni}@cse.ust.hk,‚Ä°changxu@nju.edu.cn*
ABSTRACT
Wake locks are widely used in Android apps to protect crit-
ical computations from being disrupted by device sleeping.
Inappropriate use of wake locks often seriously impacts user
experience. However, little is known on how wake locks are
used in real-world Android apps and the impact of their mis-
uses. To bridge the gap, we conducted a large-scale empiri-
cal study on 44,736 commercial and 31 open-source Android
apps. By automated program analysis and manual investi-
gation, we observed (1) common program points where wake
locks are acquired and released, (2) 13 types of critical com-
putational tasks that are often protected by wake locks, and
(3) eight patterns of wake lock misuses that commonly cause
functional and non-functional issues, only three of which had
been studied by existing work. Based on our ndings, we
designed a static analysis technique, Elite , to detect two
most common patterns of wake lock misuses. Our experi-
ments on real-world subjects showed that Elite is eective
and can outperform two state-of-the-art techniques.
CCS Concepts
‚Ä¢Software and its engineering ‚ÜíSoftware testing and
debugging; Software performance; ‚Ä¢General and ref-
erence ‚ÜíEmpirical studies; ‚Ä¢Human-centered com-
puting ‚ÜíSmartphones;
Keywords
Wake lock, critical computation, lock necessity analysis
1. INTRODUCTION
Nowadays, smartphones are equipped with powerful hard-
ware components such as HD screen and GPS sensor to pro-
vide rich user experience. However, such components are big
consumers of battery power. To prolong battery life, many
smartphone platforms like Android choose to put energy-
consumptive hardware into an idle or sleep mode (e.g., turn-
ing screen o) after a short period of user inactivity [58].
Albeit preserving energy, this aggressive sleeping policy
may break the functionality of those apps that need to keep
smartphones awake for certain critical computation. Con-
sider a banking app. When its user transfers money onlineover slow network connections, it may take a while for the
transaction to complete. If the user's smartphone falls asleep
while waiting for server messages and does not respond in
time, the transaction will fail, causing poor user experience.
To address this problem, modern smartphone platforms al-
low apps to explicitly control when to keep certain hardware
awake for continuous computation. On Android platforms,
wake locks are designed for this purpose. Specically, to keep
certain hardware awake for computation, an app needs to ac-
quire a corresponding type of wake lock from the Android
OS (see Section 2.2). When the computation completes, the
app should release the acquired wake locks properly.
Wake locks are widely used in practice. We found that
around 27.2% of apps on Google Play store [21] use wake
locks for reliably providing certain functionalities (see Sec-
tion 3). Despite the popularity, correctly programming wake
locks is a non-trivial task. In order to avoid undesirable con-
sequences, a conscientious developer should carefully think
through the following questions before using wake locks:
1.Do the benets of using wake locks justify its energy cost
(for reasoning about the necessity of using wake locks)?
2.Which hardware components need to stay awake (for choos-
ing the correct type of wake lock)?
3.When should the hardware components be kept awake and
when are they allowed to fall asleep (for deciding the pro-
gram points to acquire and release wake locks)?
Unfortunately, we observe that in practice, many develop-
ers use wake locks in an undisciplined way. For example, our
investigation of 31 popular open-source Android apps, which
use wake locks, revealed that 19 (61.3%) of them have suf-
fered from various functional and non-functional issues/bugs
caused by wake lock misuses. These issues caused lots of user
frustrations. Yet, existing work only studied a small fraction
of them [38, 51, 58, 61]. Developers still lack guidance on
how to appropriately use wake locks and have limited ac-
cess to useful tools that can help locate their mistakes. To
bridge the gap, we performed a large-scale empirical study
on 44,736 commercial and 31 open-source Android apps,
aiming to investigate three important research questions:
‚óèRQ1 (Acquiring and releasing points): At what pro-
gram points are wake locks often acquired and released?
‚óèRQ2 (Critical computation): What computational tasks
are often protected by wake locks?
‚óèRQ3 (Wake lock misuse patterns): Are there com-
mon patterns of wake lock misuses? What kind of issues
can they cause?
By automated program analysis of commercial apps and
manual investigation of the bug reports and code revisions
* Corresponding authors
This is the author‚Äôs version of the work. It is posted here for your personal use. Not for
redistribution. The deÔ¨Ånitive version was published in the following publication:
FSE‚Äô16 , November 13‚Äì18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...
http://dx.doi.org/10.1145/2950290.2950297
Artifact evaluated by FSE‚úì
396Running
StoppedLaunch
activity
Paused
DestroyedonStop ()1.onCreate()
2.onStart()
3.onResume()1.onRestart()
2.onStart()
3.onResume()onPause ()
onResume ()
onDestroy ()
<<kill>><<kill>>Figure 1: Lifecycle of an activity component
of open-source apps, we made several important observa-
tions. For example, we found that although in theory wake
locks can be used to protect any computation from being
disrupted by device sleeping, in practice, the usage of wake
locks is often closely associated with a small number of com-
putational tasks. We also identied 55 real wake lock issues
from the 31 open-source apps. By studying their root causes,
we observed eight common patterns of wake lock misuses,
only three of which had been studied by existing work. Such
ndings can provide programming guidance to Android de-
velopers, and support follow-up research on developing tech-
niques for detecting, debugging, and xing wake lock issues.
Based on our empirical ndings, we designed a static anal-
ysis technique, Elite , to detect two most common patterns
of wake lock misuses. Unlike existing techniques [38, 61],
Elite makes no assumption on where wake locks should be
acquired and released, but automatically reasons about the
necessity of using wake locks at various program points via
dataow analysis. We evaluated Elite using six real issues
from real-world open-source subjects, and compared it with
two existing techniques [38, 61]. Elite eectively located
ve of the six issues without generating any false alarm. As
a comparison, the two existing techniques only located one
real issue and 12 of their reported 13 warnings are spurious.
To summarize, our work makes three major contributions:
‚óèWe conducted a large-scale empirical study to understand
how Android developers use wake locks in practice. To the
best of our knowledge, this study is the rst of its type.
‚óèWe collected 55 real wake lock issues in 31 popular open-
source Android apps [16]. By categorizing them, we ob-
served eight common patterns of wake lock misuses.
‚óèWe designed and implemented a static analysis technique
Elite to detect common wake lock misuses. Our evalu-
ation of Elite on real-world subjects showed that Elite
is eective and can outperform existing techniques.
Paper organization: Section 2 briefs Android app ba-
sics. Sections 3{4 describe our empirical study methodology
and ndings. Sections 5{6 presents and evaluates our Elite
technique. Section 7 discusses threats to validity. Section 8
reviews related work and Section 9 concludes this paper.
2. BACKGROUND
Android is a Linux-based mobile OS [5]. Android apps are
typically written in Java and compiled to Dalvik bytecode,
which are then encapsulated into Android app package les
(i.e., APK les) for distribution and installation [1].
2.1 App Components and Event Handling
An Android app typically comprises four types of com-
ponents [1]: (1) activities contain graphical user interfaces
(GUIs) for interacting with users; (2) services run at back-
ground for performing long-running operations; (3) broad-
cast receivers respond to system-wide broadcast messages;
and (4) content providers manage shared app data for queries.Table 1: Wake lock types and their impact
Wake lock type CPU Screen Keyboard backlight
Partial on o o
Screen dim‚àóon dim o
Screen bright‚àóon bright o
Full‚àóon bright bright
Proximity screen o Screen o when proximity sensor activates
‚àó: These types are deprecated in latest Android versions, but still often used.
PowerManager pm= (PowerManager) getSystemService (Context. POWER_SERVICE );
WakeLock wl= pm.newWakeLock (PowerManager. PARTIAL_WAKE_LOCK ,"lockTag");
wl.acquire ();//acquire wake lock
//performing critical computation when the wake lock is held
wl.release ();//release the wake lock when critical computation completes
Figure 2: Example code for using wake locks
Android apps are event-driven. Their logic is normally
implemented in a set of event handlers : callbacks that will
be invoked by the Android OS when certain events occur. To
provide rich user experience, the Android platform denes
thousands of handlers to process various events, of which we
introduce three major types [64]:
1)Component lifecycle event handlers process an app com-
ponent's lifecycle events (e.g., creation, pausing, and termi-
nation). For example, Figure 1 gives the lifecycle of an activ-
ity. When the activity is created, the handlers onCreate() ,
onStart() , and onResume() will be invoked consecutively.
2)GUI event handlers process user interaction events on
an app's GUI, which usually consists of standard widgets
(e.g., buttons) and custom views [4]. For example, a but-
ton's onClick() handler will be invoked if the button gets
clicked by user and its onClickListener is registered.
3)System event handlers process system-level events mon-
itored by the Android OS such as incoming calls and sensor
updates. These handlers (e.g., onLocationChanged() ) will
be invoked if the corresponding events occur and their lis-
teners (e.g., LocationListener ) are registered.
2.2 Wake Lock Mechanism
Wake locks enable developers to explicitly control the power
state of an Android device. To use a wake lock, devel-
opers need to declare the android.permission.WAKE_LOCK
permission in their app's manifest le [7, 36], create a Pow-
erManager.WakeLock instance, and specify its type (see Fig-
ure 2). Table 1 lists the ve types of wake locks supported
by the Android framework. Each type has a dierent wake
level and aects system power consumption dierently. For
instance, a full wake lock will keep device CPU running, and
screen and keyboard backlight on at full brightness. After
creating wake lock instances, developers can invoke certain
APIs to acquire and release wake locks. Once acquired, a
wake lock will have long lasting eects until it is released or
the specied timeout expires. When acquiring wake locks,
developers can also set certain ags. For example, setting
theON_AFTER_RELEASE ag will cause the device screen to
remain on for a while after the wake lock is released. Due to
wake locks' direct eect on device hardware state, developers
should carefully use them to avoid undesirable consequences.
3. EMPIRICAL STUDY METHODOLOGY
This section presents our datasets and how we analyze
them to answer our research questions.
3.1 Dataset Collection
Dataset 1: Binaries of 44,736 Android apps. An-
swering RQ1{2 requires analyzing the code of Android apps
that use wake locks. For this purpose, we collected the bi-
naries (APK les) of 44,736 Android apps from Google Play
3970 1,000 2,000 3,000 4,000 5,000 6,000
# of appsmean = 1,720(a) Category size distribution (Dataset 1)
1001011021031041051061071081091010
# downloads in 1og-10 scale (1K = 1,000)MinMax
mean = 218.3Kmean = 907.8K (b) App download distribution (Dataset 1)
0 20 40 60 80
File size (MB)mean = 7.9MB (c) APK le size distribution (Dataset 1)
0 5,000 10,000 15,000 20,000
# of revisionsmean = 3,345
(d) Revision number distribution (Dataset 2)
1031041051061071081091010
# downloads in 1og-10 scale (1M = 1,000,000)MinMax
mean = 39.0Mmean = 189.1M (e) App download distribution (Dataset 2)
0 20 40 60 80 100 120
App size (KLOC)mean = 40.3KLOC (f) App size distribution (Dataset 2)
Figure 3: Dataset statistics (Figures (b) and (e) have two boxplots because Google Play store provides a download range)
Decompilation
(Dex2jar )Program analysis 
(Soot, BCEL )Statistical
analysis
Retargeting appAPK
files toJava bytecode‚Ä¢Locating entry points
‚Ä¢Analyzing API usageCorrelating APIcalls 
with wake lock uses
Figure 4: Methodology for analyzing APK les
Algorithm 1. Finding the set of dynamically registered GUI
and system event handlers in an component class c
1.worklist;handlers ‚ÜêfindAllLifeCycleHandlers( c)
2.while worklist not empty do
3. h‚Üêdequeue( worklist )
4. regSites ‚ÜêfindEventListenerRegistrationSites( h)
5. foreach regSite ‚ààregSites do
6. hnew‚ÜêresolveEventHandler( regSite )
7. ifhnew‚â†null andhnew‚àâhandlers then
8. addhnewtohandlers andworklist
9.return handlers
store by the following process. First, we collected the basic
information (app ID, category, and declared permissions) of
1,117,195 Android apps using a web crawler [13]. By permis-
sion analysis, we found that 303,877 (27.2%) of these apps
declare permissions to use wake locks. We then proceeded
to download these apps using APKLeecher [9]. In total, we
tried 200,231 randomly selected apps and successfully ob-
tained 44,736 of them. The downloading took 11 months
(March 2015 to January 2016) with more than ten PCs and
one server. Figure 3 gives the statistics of our downloaded
apps. They cover all 26 app categories [10] and each cate-
gory on average contains 1,720 apps (Figure 3(a)). They are
popular on market: more than half of them have achieved
thousands of downloads and 1,318 (2.9%) of them have been
downloaded millions of times (Figure 3(b)). We also give the
size distribution of the downloaded APK les in Figure 3(c).
On average, each APK le takes 7.9 MB disk space.
Dataset 2: Bug reports and code repositories. An-
swering RQ3 requires studying the bug reports and code re-
visions of Android apps that use wake locks. Such data are
typically only available for open-source apps. To nd sub-
jects for our study, we searched four major open-source soft-
ware hosting sites: GitHub [19], Google Code [20], Source-
Forge [29], and Mozilla repositories [23]. We aimed to nd
those apps that have: (1) over 1,000 downloads (popular),
(2) a public issue tracking system (traceable), and (3) over
100 code revisions (well-maintained). After manually check-
ing more than 200 candidates, we identied 31 apps that use
wake locks and satisfy the three requirements. Figure 3 gives
the statistics of these apps. As we can see, they are pop-
ular on market: 15 (48.4%) of them have achieved millions
of downloads (Figure 3(e)). They are also well-maintained,
containing hundreds to thousands of code revisions (Fig-
ure 3(d)). Besides, they are large-scale. On average, each of
them contains 40.3 thousand lines of code (Figure 3(f)).3.2 Analysis Algorithms
Program analysis. To answer RQ1{2, we analyzed the
44,736 APK les. Figure 4 illustrates the overall process.
We rst decompiled each APK le to Java bytecode using
Dex2Jar [15]. We then analyzed each app's Java bytecode
using a static analysis tool we built on the Soot program
analysis framework [28] and Apache Byte Code Engineering
Library ( BCEL) [8]. The analysis consists of two major steps:
Step 1: Locating analysis entry points . Our tool rst
performs class hierarchy analysis to identify all app compo-
nent classes (e.g., those extending the Activity class) in an
app. It then locates the set of callbacks dened in each app
component, including lifecycle event handlers, GUI event
handlers, and system event handlers. Lifecycle event han-
dlers can be located by searching for the corresponding over-
written methods in an app component class. Finding GUI
and system event handlers requires a more sophisticated
searching algorithm because event handlers can freely regis-
ter other event handlers. To nd all dynamically registered
handlers,1our tool adopts a xed-point iterative searching
strategy, which is illustrated by Algorithm 1. The high level
idea is to iteratively extend the set of located event handlers,
which initially only contains component lifecycle event han-
dlers (Line 1), by adding new ones that are registered in
latest located event handlers (Lines 2{8). To nd the event
handlers registered by a certain event handler h, our algo-
rithm traverses the call graph of h, pinpoints all event lis-
tener registration sites (Line 4), and resolves the type of each
listener to locate its associated event handler (Line 6). All
located event handlers will serve as the entry points in later
analysis. It is worth mentioning that our tool also locates
other entry points such as the callbacks dened in custom
views [4] (e.g., onDraw() ) and asynchronous tasks [3] (e.g.,
doInBackground() ). Their locating algorithms are essen-
tially similar to the algorithms explained here.
Step 2: Analyzing API calls. Then, for each app compo-
nent, our tool traverses the call graph of each entry point
in a depth-rst manner to check whether wake lock acquir-
ing and releasing API calls can be transitively reached. If
yes, we consider the app component would use wake locks.
We understand that the call graphs constructed by Soot
may not be precise and complete. However, statically con-
structing precise and complete call graphs for Java pro-
grams is challenging due to the language features such as
dynamic method dispatching and reection [37]. Addressing
this challenge is out of our scope, but still, to ensure the pre-
cision of our results, our analysis would not visit obviously
imprecise call graph edges caused by conservative resolution
of virtual calls (see Section 7). During the analysis, our tool
1GUI event handlers statically declared in an app's layout con-
guration les can be located by XML parsing.
398logs the following information for later statistical analysis:
(1) the set of app components that use wake locks, (2) the set
of entry points where wake locks are acquired and released,
and (3) the set of APIs invoked by each component. Note
that for app components that use wake locks, we only log
the APIs that can be invoked after the wake lock is acquired
and before the wake lock is released.
Statistical analysis. With the data logged during pro-
gram analysis, we can analyze them to answer RQ1{2. An-
swering RQ1 only requires straightforward statistical analy-
sis and we do not further elaborate. Answering RQ2 requires
investigating the computational tasks that are performed by
our collected apps. To do so, we analyzed the APIs invoked
by the apps in our dataset, since API usage typically reects
the computational semantics of an app [67]. Our goal is to
identify those critical APIs that are commonly invoked by
app components that use wake locks ( locking app compo-
nents for short), but not commonly invoked by app compo-
nents that do not use wake locks ( non-locking app compo-
nents ). These APIs are very likely invoked by the apps to
conduct the critical computations. Before we explain how
to identify such APIs, we rst formally dene our problem.
Suppose that we analyze a set of apps A. Each app a‚ààA
can contain a set of napp components C(a)={c1;c2;:::;c n},
wheren‚â•1. Then, the whole set of app components to ana-
lyze isC(A)=/uni22C3a‚ààAC(a). With program analysis, for each
analyzed app component c‚ààC(A), we can know whether it
uses wake locks or not, and the set of APIs it invokes. Let
us use API to denote the ordered set of all concerned APIs.
Then, after analyzing the apps in A, we can encode the re-
sults as a bit matrix Mof size /divides.alt0C(A)/divides.alt0√ó(1+/divides.alt0API /divides.alt0). Each
row of the matrix is a bit vector that encodes the analysis
result for a corresponding app component. The rst bit of
the vector indicates whether the app component uses wake
locks or not. The remaining /divides.alt0API /divides.alt0bits indicate whether
corresponding APIs are invoked by the app component or
not. With such formulation, we can reduce our problem to
the classic term-weighting problem in the natural language
processing area with the following mappings [42]:
The set of analyzed app components C(A)can be con-
sidered as a corpus . Each app component c‚ààC(A)can be
considered as a document . Each API invoked by ccan be
considered as a term in the document that crepresents. The
set of locking app components can be considered as the pos-
itive category in the corpus and the set of non-locking app
components can be considered as the negative category .
With the reduction, we can adapt term-weighting tech-
niques to identify the APIs that are commonly invoked by
locking app components but not commonly invoked by non-
locking app components. To do so, we applied the widely-
used Relevance Frequency approach [42]. Formally, for each
api‚ààAPI , we count the following (\ #" = \the number of"):
‚óè:#locking app components that invoke api;
‚óè:#locking app components that do not invoke api;
‚óè:#non-locking app components that invoke api.
We dene the importance score ofapiby Equation 1. The
rf(api) computes the relevance frequency score of apiand
its denition in Equation 3 follows the standard one [42].
The ltering function freqFilter (api) dened by Equation 2
is to avoid assigning a high importance score to those APIs
that do not frequently occur in locking app components and
very rarely or never occur in non-locking app components
(whenis very small compared to , but/uni226B, the rfTable 2: Acquiring and releasing program points
(1) Results for activity components
Acquiring point Pct. Releasing point Pct.
onResume() 30.5% onPause() 35.4%
onCreate() 19.2% onDestroy() 15.8%
onPause() 14.2% onResume() 13.0%
onWindowFocusChanged() 10.8% onWindowFocusChanged() 11.2%
onDestory() 8.8% onCreate() 10.2%
Other 365 callbacks 16.5% Other 389 callbacks 14.4%
(2) Results for service components
Acquiring point Pct. Releasing point Pct.
onHandleIntent() 26.5% onHandleIntent() 68.2%
onStartCommand() 21.7% onStartCommand() 13.6%
onStart() 21.2% onDestroy() 8.6%
onCreate() 12.3% onStart() 5.2%
onMessage() 3.8% onCreate() 1.1%
Other 192 callbacks 14.5% Other 188 callbacks 3.3%
(3) Results for broadcast receiver components*
Acquiring point Pct. Releasing point Pct.
onReceive() 98.4% onReceive() 93.8%
Other 37 callbacks 1.6% Other 26 callbacks 6.2%
*: They only have one major lifecycle event handler onReceive() .
score will be exceptionally high). Assigning high scores to
such uninteresting APIs will waste our eort as we will study
the APIs with high importance scores to answer RQ2.
importance (api)=freqFilter (api)√órf(api) (1)
freqFilter (api)=/braceleft.alt41;if/slash.left(+)‚â•0:05
0;otherwise(2)
rf(api)=log/parenleft.alt42+
max(1;)/parenright.alt4 (3)
Search-assisted manual analysis. To answer RQ3, we
manually studied the bug reports and code revisions of the
31 open-source apps, aiming to nd wake lock misuse is-
sues. These apps contain thousands of code revisions and
bug reports. To save manual eort, we wrote a Python
script to search the apps' code repositories and bug tracking
systems for: (1) those interesting bug reports that contain
certain keywords, and (2) those interesting code revisions
whose commit log or code di contain certain keywords.
The keywords include: wake ,wakelock ,power ,powerman-
ager,acquire , and release . After search, 1,157 bug reports
and 1,558 code revisions meet our requirement. We then
carefully studied them to answer RQ3.
4. EMPIRICAL OBSERVATIONS
We ran the analysis tasks on a Linux server with 16 cores
of Intel Xeon CPU @2.10GHz and 192GB RAM. The major-
ity of CPU time was spent on decompiling the 44,736 APK
les (‚àº206 hours) and the program analysis ( ‚àº307 hours).
In total, these apps dened 893,374 activities, 185,672 ser-
vices, 447,302 broadcast receivers, 19,370 content providers,
and 5,190,728 GUI/system event listeners. We successfully
analyzed 43,888 (98.1%) APKs and found 52,816 app com-
ponents that use wake locks. The remaining 848 APKs failed
to be analyzed because Dex2Jar orSoot crashed when pro-
cessing them. In this section, we discuss our major ndings.
4.1 RQ1: Acquiring and Releasing Points
First, most apps acquire wake locks in broadcast
receivers .2Overall, 65.2% of our analyzed apps acquire
wake locks in broadcast receivers. For activities and ser-
2Due to Android fragmentation [6, 54], screen dim/bright and
full wake locks still account for 12.8% and 21.9% of all used ones.
399Table 3: Computational tasks that are commonly protected by wake locks
Computational task#related
APIsAPI examples#related
permissionsPermission example
Networking & Communications 103 java.net.DatagramSocket.connect() 9 Receive data from Internet
Logging & le I/O 100 android.os.Environment.getExternalStorageDirectory() 4 Access USB storage le system
Asynchronous computation 82 java.lang.Thread.start() /android.os.AsyncTask.execute() 0 N/A
UI & graphics rendering 79 android.opengl.GLSurfaceView.setRenderer() 1 Draw over other apps
Inter-component communication 48 android.content.ContextWrapper.sendBroadcast() 1 Send sticky broadcast
Data management & sharing 40 android.database.sqlite.SQLiteDatabase.query() 0 N/A
System-level operations 34 android.os.Process.killProcess() 5 Close other apps
Media & audio 33 android.media.AudioTrack.write() 1 Record audio
Security & privacy 28 javax.crypto.SecretKeyFactory.generateSecret() 3 Use accounts on the device
Sensing operations 16 android.location.LocationManager.requestLocationUpdates() 4 Precise location
Alarm & notication 10 android.app.NotificationManager.notify() 1 Control vibration
System setting 6 android.provider.Settings$System.putInt() 2 Modify system settings
Telephony services 2 android.telephony.TelephonyManager.listen() 1 Directly call phone numbers
Notes: \N/A" means that the corresponding computational tasks do not require special permissions.
vices, the percentages are 30.8% and 17.3%, respectively.
We did not nd any app that acquires wake locks in con-
tent providers. Note that these percentages do not add up
to 100% because some apps acquire wake locks in multiple
components. This nding suggests that in practice wake
locks are often used by apps when they process broadcast
messages, which are usually sent upon the occurrence of im-
portant events (e.g., servers' push notications).
We further analyzed each type of app components to in-
vestigate in which callbacks developers often acquire and
release wake locks. Table 2 summarizes the results. We
can observe that wake locks are commonly acquired
and released in major lifecycle event handlers . For
example, in activities, wake locks are mostly acquired in on-
Resume() handlers, which are invoked by Android OS when
the activities are ready for user interaction, and released in
onPause() handlers, which are invoked after the activities
lose user focus. This reveals developers' common practice for
avoiding energy waste as many apps do not need to keep de-
vice awake for computation when they are switched to back-
ground by users. Besides the major lifecycle event handlers,
we can also observe that developers may acquire and
release wake locks at various other program points
depending on the needs of their apps . For instance,
our analyzed activity components acquire wake locks in 370
dierent callbacks. This is out of our expectation. Previous
techniques [38, 61] for analyzing wake lock misuses often as-
sume that wake locks are acquired when an app component
launches and should be released at a set of program exit
points. This nding suggests that such assumptions may
not hold in many cases and eective techniques should not
rely on pre-dened rules. Instead, they should consider each
app case by case by analyzing its semantics.
4.2 RQ2: Critical Computation
RQ2 aims to identify the critical computational tasks that
are frequently protected by wake locks. To identify such
tasks, we performed API usage analysis on the 43,888 suc-
cessfully analyzed apps. For each category of apps, our tool
computed the importance score of each invoked API and
ranked the APIs according to their scores (a higher score
leads to a higher rank). Overall, these apps use 34,957 dif-
ferent APIs, 87.6% of which are ocial Android and Java
APIs. After the analyses and ranking, we manually exam-
ined the top 1% APIs commonly used by each of the 26 app
categories to answer RQ2. Now we present our observations.
Theoretically, wake locks can be used to prevent devices
from falling asleep during any kind of computation, which
could be app-specic. However, by analyzing a large numberof apps, we observe that developers often only use wake
locks to protect several types of computational tasks .
Particularly, we identied 807 APIs that are commonly in-
voked by locking app components, but not commonly in-
voked by other app components. We then categorized these
APIs according to their design purposes [1]. For example,
APIs in android.database and java.sql packages are de-
signed for data management and we would categorize them
into the same category. After categorization, we observed
that these APIs are mainly designed for 13 types of com-
putational tasks and many of them require the Android OS
to grant certain permissions to run [7, 36]. Table 3 sum-
marizes our categorization results. For each type of compu-
tational task, the table reports the number of related APIs
and their required system permissions, and provides exam-
ples to ease understanding.3We can see from the table that
these computational tasks, many of which are run
asynchronously and could be long running (e.g., lo-
cation sensing and media playing), can bring users
observable or perceptible benets . Take networking &
communications for example. Many apps frequently fetch
data from remote servers and present them to users. These
tasks typically should not be disrupted by device sleeping
when users are using the apps and expecting to see certain
updates. Hence, wake locks are needed in such scenarios.
Another typical example is security & privacy. We found
that a large percentage of apps (e.g., 84.5% Finance apps)
frequently encrypt and decrypt certain program data (e.g.,
those related to user privacy) for security concerns. Such
tasks should also be protected by wake locks as any disrup-
tion can cause serious consequences to users. This nding
can provide wake lock usage guidance to Android develop-
ers, and also facilitate the designing of useful techniques for
detecting wake lock misuses (see Section 5).
4.3 RQ3: Wake Lock Misuse Patterns
For RQ3, we manually investigated the 1,157 bug reports
and 1,558 code revisions found by keyword search. After
investigation, we found that 55 bug reports and code re-
visions are related to wake lock misuses. The other bug
reports and code revisions are irrelevant, but were acciden-
tally included because they contain our searched keywords.
We then carefully studied these 55 issues and categorized
them after understanding their root causes. By the catego-
rization, we observed eight common patterns of wake lock
misuses (covering 53 issues and aecting 18 apps), which
are listed in Table 4. For each pattern, the table lists the
3We failed to categorize 226 of the 807 APIs because they are
general-purpose (e.g., HashMap APIs).
400Table 4: Common patterns of wake lock misuses found in open-source Android apps
Misuse pattern #issues #aected appsExample issues
App name Downloads Bug report ID Issue xing revision Consequence
Unnecessary wakeup* 11 7 TomaHawk [30] 5K - 10K N/A 883d210525 Energy waste
Wake lock leakage* 10 7 MyTracks [24] 10M - 50M N/A 17ece1cd75 Energy waste
Premature lock releasing 9 7 ConnectBot [12] 1M - 5M 37 540c693d2c Crash
Multiple lock acquisition 8 3 CSipSimple [14] 1M - 5M 152 153 Crash
Inappropriate lock type 8 3SipDroid [27] 1M - 5M 268 533 Instability
Osmand [26] 1M - 5M 582 4d1c97fe7768 Energy waste
Problematic timeout setting 3 2 K-9 Mail [22] 5M - 10M 170/175 299 Instability
Inappropriate ags 2 2 FBReader [17] 10M - 50M N/A f28986383f Energy waste
Permission errors* 2 2 Firefox [23] 100M - 500M 703661 be42fae64e Crash
Notes: (1) For some issues, we failed to locate the associated bug reports (the issues may not be documented) and the corresponding cells are marked as \N/A".
public class MusicActivity extends Activity implements ‚Ä¶{
public void onCreate () {//start PlaybackService ‚Ä¶}
public void onTouch() {
PlaybackService.getInstance ().playPause ();‚Ä¶}
public void onDestroy () {//stop PlaybackService ‚Ä¶}}1.
2.
3.
4.
5.
public class PlaybackService extends Service {
public void onCreate () {‚Ä¶
-wakeLock .acquire ();//partial wake lock
-mediaPlayer .start();‚Ä¶}
public void playPause () {
if(mediaPlayer .isPlaying ()) {
mediaPlayer .pause();
+      if(wakeLock .isHeld()) wakeLock .release ();
} else{
+if(!wakeLock .isHeld()) wakeLock .acquire ();
mediaPlayer .start();}} 
public void onDestroy () {
if(wakeLock .isHeld())wakeLock .release ();
if(mediaPlayer .isPlaying ()) mediaPlayer .stop();‚Ä¶}}6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
Figure 5: Unnecessary wakeup in TomaHawk
number of issues we found, the number of aected apps, and
provides a typical example. We noticed that only three of
the eight patterns (marked with \*" in Table 4) have been
studied by existing work [38, 61, 51, 36]. The remaining ve
patterns that concern 30 issues are previously-unknown. We
now discuss each pattern in detail.
Unnecessary wakeup is the most common pattern. We
observe that in many apps, wake locks are correctly acquired
and released on all program paths, but the lock acquiring
and releasing time is not appropriate. They either acquire
wake locks too early or release them too late, causing the de-
vice to stay awake unnecessarily. To ease understanding, we
discuss a real issue in TomaHawk [30], a music player app.
Figure 5 gives the simplied code snippet. When users select
an album, TomaHawk's MusicActivity will start the Play-
backService to play music at background (Line 2). When
the service is launched, it acquires a partial wake lock, sets
up the media player, and starts music playing (Lines 7{9).
Users can pause or resume music playing by tapping the
device screen (Lines 3{4 and 10{16). When users exit the
app, MusicActivity andPlaybackService will be destroyed
and the wake lock will be released accordingly (Lines 5 and
17{19). This is functionally correct and the music can be
played smoothly in practice. However, since the wake lock
is used to keep the device awake for music playing, why
should it be held when the music player is paused? Hold-
ing unnecessary wake locks can lead to serious energy waste.
Developers later xed the issue by releasing the wake lock
when music playing is paused (Line 13) and re-acquiring it
when users resume music playing (Line 15).
Wake lock leakage is the second common pattern. As
we mentioned earlier, wake locks should be properly released
after use. However, ensuring wake locks to be released on all
program paths for event-driven Android apps is a non-trivial
task. Figure 6 gives an example wake lock leakage in My-
Tracks [24], a popular app for recording users' tracks when
they exercise outdoors. The app denes a long-running task
public class ExportAllAsyncTask extends AsyncTask {
public ExportAllAsyncTask () {
wakeLock = MyTrackUtils.acquireWakeLock ();‚Ä¶}
protected Boolean doInBackground (Void... params){
Cursor cursor= null;
try {
cursor = MyTrackUtils.getTracksCursorFromDB ();
for(inti= 0; i< cusor.getCount (); i++) {
if(isCancelled ()) break;
exportAndPublishProgress (cursor, i);}
} finally {
if(cursor != null) cursor.close ();
+      if(wakeLock .isHeld()) wakeLock .release ();}}
protected void onPostExecute (Boolean result){
-if(wakeLock .isHeld()) wakeLock .release ();}}1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.Figure 6: Wake lock leakage in MyTracks
ExportAllAsyncTask to export recorded tracks to external
storage (e.g., an SD card). When the task starts, it acquires
a wake lock (Line 3). Then it runs in a worker thread to
read data from database, write them to the external storage,
and notify users the exporting progress (Lines 4{13). When
the job is done, the Android OS will invoke the onPostExe-
cute() callback, which will release the wake lock (Line 15).
This process works ne in many cases. Unfortunately, de-
velopers forgot to handle the case where users cancel the
exporting task before it nishes. In such a case, onPostExe-
cute() will not be invoked after doInBackground() returns.
Instead, another callback onCancel() will be invoked. Then,
the wake lock will not be released properly. The consequence
is that the device cannot go asleep, causing signicant en-
ergy waste. Later, developers realized this issue and moved
the lock releasing operation to doInBackground() (Line 13).
Premature lock releasing is the third common pattern.
It occurs when a wake lock is released before being acquired
and can cause app crashes (e.g., ConnectBot issue 37 [12]).
In our studied apps, we often observed such issues. One
major reason is the complex control ows of Android apps
due to the event-driven programming paradigm. If devel-
opers do not fully understand the lifecycle of dierent app
components (e.g., temporal relations among callbacks), they
may mistakenly release a wake lock in a callback that can
be executed before another one that acquires the wake lock.
Multiple lock acquisitions. Wake locks by default are
reference counted. Each acquiring operation on a wake lock
increments its internal counter and each releasing operation
decrements the counter. The Android OS only releases a
wake lock when its associated counter reaches zero [1]. Due
to this policy, developers should avoid multiple lock acquisi-
tions . Otherwise, to release a wake lock requires an equiv-
alent number of lock releasing operations. However, due
to complex control ows, developers often make mistakes
that cause a wake lock to be acquired multiple times. For
example, in CSipSimple [14], a popular Internet call app,
developers put the wake lock acquiring operation in a fre-
quently invoked callback. The consequence is that CSipSim-
ple crashes after acquiring the wake lock too many times
(issue 152), which exceeds the limit allowed by the OS.
401Algorithm 2. Detecting wake lock misuses in an app
1.foreach component c ‚ààappdo
2. ifuseWakeLock( c)then
3. componentsUsingWakeLocks: add(c)
4. summarizeTopLevelMethods( c)
5. inferTemporalConstraintsBetweenTopLevelMethods( c)
6.warnings ‚Üê/uni2205
7.foreach c‚ààcomponentsUsingWakeLocks do
8. seqs‚ÜêgenerateAllValidTopLevelMethodCallSeqs( c;length )
9. foreach seq‚ààseqs do
10. foreach cp‚ààcheckPoints( seq)do
11. warnings: add(analyzeLockNecessity( seq;cp ))
12.return aggregateByRootCause( warnings )
Inappropriate lock type. Before using wake locks, de-
velopers should gure out which hardware needs to stay
awake for the critical computation, and choose an appro-
priate type of wake lock. Inappropriate lock types often
cause trouble in practice. For example, in SipDroid [27],
another popular Internet call app, developers used a partial
wake lock for keeping the device CPU awake during Internet
calls. However, on many devices, keeping CPU awake does
not prevent WiFi NIC from entering Power Save Polling
mode [59], which will signicantly reduce the network band-
width. The consequence is that SipDroid's calling quality
becomes unstable when device screen turns o (issue 268).
To x the issue, developers later used a screen dim wake
lock to keep both device screen and CPU on when users are
making phone calls. This is an example of mistakenly using
a wake lock with a low wake level. We also observed cases
where developers use wake locks whose wake levels are higher
than necessary. For instance, when users use Osmand [26],
a famous maps & navigation app, to record their trips dur-
ing outdoor activities (e.g., cycling), the app will acquire
a screen dim wake lock for location sensing and recording.
However, keeping screen on in such scenarios is unnecessary
and will waste a signicant amount of battery energy (Os-
mand issue 582). Developers later realized the issue after
receiving many user complaints and replaced the screen dim
wake lock with a partial wake lock.
Problematic timeout setting. When acquiring wake
locks, developers can set a timeout. Such wake locks will
be automatically released after the given timeout. Setting
an appropriate timeout (enough for the critical computa-
tion to complete, but not too long) seems to be an easy job.
However, in practice, developers can make bad estimation.
For example, in K-9 Mail [22], an email client with millions
of users, developers used a wake lock that would get time-
out after 30 seconds to protect the email checking process.
They thought that it was long enough for the checking to
complete. Unfortunately, due to various reasons (e.g., slow
network conditions), many users complained that they often
fail to receive email notications and this issue is annoyingly
intermittent. The developers later found the root cause.
They reset the timeout to 10 minutes and commented:
\This should guarantee that the syncing never stalls just
because a single attempt exceeds the wake lock timeout."
Inappropriate ags. We mentioned in Section 2 that
developers can set certain pre-dened ags when acquiring
wake locks. When they do so, they need to be careful as set-
ting inappropriate ags can cause unexpected consequences.
For example, the developers of FBReader [17], an eBook
reading app, found that setting the ON_AFTER_RELEASE ag
when using a screen bright wake lock could cause seriousenergy waste on some users' devices. This is because, with
the ag set, some Android system variants (i.e., those cus-
tomized by device manufacturers) can keep the device screen
on at full brightness for quite a long while after the wake lock
is released. They later removed the ag to x the issue.
Permission errors. Using wake locks requires an app
to declare the android.permission.WAKE_LOCK permission.
Forgetting to do so will lead to security violations. This is a
well-documented policy [1], but some developers still make
mistakes. For example, one version of Firefox did not declare
the permission properly and users found that the app would
crash because of this issue (Firefox issue 703661 [18]).
The above issues recur throughout our studied apps. We
also observed two other issues that only occurred once. One
is the instability issue caused by concurrent wake lock ac-
quiring and releasing in K-9 Mail. Developers xed the issue
by putting wake lock operations in synchronized blocks (re-
vision 1698 [22]). The other is the duplicate wake lock issue
in CSipSimple. Developers mistakenly made two app com-
ponents acquire two dierent wake locks of the same type,
but one is already sucient. They later xed the issue by
removing one wake lock (revision 1633 [14]).
5. DETECTING WAKE LOCK MISUSES
Based on our empirical ndings, we propose a static anal-
ysis technique Elite (wake lock necessit y analyze r) to de-
tect the two most common patterns of wake lock misuses:
unnecessary wakeup and wake lock leakage.
5.1 Algorithm Overview
The input of Elite is an Android app's APK le. The
output is a report of detected wake lock misuse issues. To
ease issue diagnosis, Elite also provides the method call
sequences leading to each detected issue and the program
points where wake locks should be released.
Algorithm 2 gives an overview of Elite . To detect wake
lock misuses in an Android app, Elite explores dierent
executions of each app component that uses wake locks to
locate the problematic program points, where wake locks
are not needed but acquired, by performing an interproce-
dural analysis (Lines 7{11). In Android apps, an app compo-
nent's execution can be represented as a sequence of calls to
the component's top level methods (or entry points). These
methods include lifecycle/GUI/system event handlers (e.g.,
onCreate() in Figure 5), callbacks of custom views and
asynchronous tasks (e.g., doInBackground() in Figure 6),
and non-callback methods that are exposed for other com-
ponents to invoke (e.g., playPause() in Figure 5). At run-
time, top level methods of an app component are invoked
by the Android OS or other components to handle various
events. For event handling, top level methods may invoke
other methods. Therefore, to emulate the executions of an
app component c,Elite identies the top level methods of c
and generates valid sequences of calls to such methods (Line
8 and Section 5.3). Then, for issue detection, Elite analyzes
each sequence and locates program points, where cunnec-
essarily holds wake locks (Lines 9{11 and Section 5.4). To
improve analysis eciency, before generating call sequences
to interesting top level methods, Elite rst summarizes the
methods' potential runtime behavior by an interprocedural
analysis (Line 4 and Section 5.2) so that the summaries can
be reused when analyzing method call sequences.
To make Elite 's analysis eective, we need to address
two technical challenges. First, the execution of top level
402onCreate () playPause () onDestroy ()
ACQ = {partial lock}
START = {media player}START = {media player}
STOP = {media player}REL= {partial lock}
STOP = {media player}Figure 7: An example method call sequence
methods follow implicit orders prescribed by the Android
platform. It is a non-trivial task to generate valid method
call sequences. Second, there are no well-dened criteria
to judge whether it is appropriate for an app to use wake
locks at certain program points. To address the rst chal-
lenge, Elite infers temporal constraints from an app's code
to model the execution orders of top level methods (Sec-
tion 5.3). To address the second challenge, Elite leverages
our empirical ndings and considers that if an app's com-
putation can bring users perceptible or observable benets,
the energy cost of using wake locks is justied (Section 5.4).
5.2 Summarizing Top Level Methods
The rst step of Elite 's analysis is to identify top level
methods in each app component cthat uses wake locks. To
identify top level methods that are callbacks, which include
lifecycle/GUI/system event handlers and callbacks dened
in custom views and asynchronous tasks, Elite relies on
the xed-point iterative searching algorithm described in
Section 3.2. To identify other non-callback top level meth-
ods thatcexposes for other components to invoke, Elite
iterates over non-callback methods dened in cand looks
for those that can be directly invoked by other components
without going through c's other methods. For each identied
top level method m,Elite then summarizes the following
potential runtime behavior (dataow facts) of m:
‚óèACQ: the set of wake lock instances that may have been
acquired after executing m;
‚óèREL: the set of wake lock instances that may have been
released after executing m;
‚óèSTART: the set of asynchronous computational tasks that
may have been started after executing m;
‚óèSTOP: the set of asynchronous computational tasks that
may have been stopped after executing m.
Elite tracks the asynchronous computational tasks started
and stopped by each analyzed method because these tasks
are likely long running and could be the reason that an app
uses wake locks (Section 4.2). To obtain these summaries,
Elite performs an interprocedural reaching-denition styled
forward dataow analysis [31] on the control ow graphs
(CFGs) of all identied top level methods to infer the dataow
facts. The dataow equations are dened as follows ( srep-
resents a statement in a CFG):
in(s)=/uni22C3.disp
p‚ààpred (s)out(p) (4)
out(s)=gen(s)‚à™(in(s)‚àíkill(s)) (5)
in(s)and out(s)represent the set of dataow facts before
and after executing s, respectively. gen(s)andkill(s)denote
the dataow facts generated or killed by s. The denitions
ofgen(s)andkill(s)depend on analysis tasks. For instance,
when inferring START of a method m, if a statement sin-
vokes a location listener registration API, gen(s)will have
one element representing that smay start a long term loca-
tion sensing task, and kill(s)will be an empty set. At the
control ow conuence and method return points, we use
the union operator to combine data ow facts, meaning that
in(s)contains all dataow facts from the predecessors of sin the CFG (Equation 4). out(s)is a union of the dataow
facts generated by sand the dierence between the dataow
factssinherits from its predecessors and those killed by s
(Equation 5). With these equations dened, Elite then
leverages Soot's dataow analysis engine to summarize all
top level methods in app components that use wake locks.
5.3 Generating Valid Method Call Sequences
Next, Elite proceeds to generate valid sequences of top
level method calls for each app component that uses wake
locks. Elite considers a sequence valid if the invocation
orders of the top level methods do not violate these temporal
constraints prescribed by the Android platform [1, 51]:
Policy for lifecycle event handlers. Each app com-
ponent typically passes through several phases during its
lifecycle. In each phase, the corresponding lifecycle event
handler(s) dened in the component class would be invoked
by the Android OS at a specic time (Figure 1). Elite
leverages such temporal constraints to decide the correct in-
vocation order of lifecycle event handlers.
Policy for GUI/system event handlers. An app com-
ponent may register multiple GUI/system event listeners.
The event handler dened in each event listener lcan only
be invoked when: (1) the top level method that registers l
has been invoked, and (2) the top level method that unregis-
terslhas not been invoked since then. Elite also considers
such constraints during method call sequence generation.
Policy for non-callback top level methods. Non-
callback top level methods dened in an app component
class are usually exposed for other components to invoke.
For example, in Figure 5, the playPause() method of Play-
backService can be invoked by the onTouch() callback of
MusicActivity . Such methods can only be invoked after
their declaring app components are set up (e.g., after the
onStartCommand() handler of PlaybackService is invoked).
Besides the three major types, in our implementation,
Elite also considers other temporal constraints to deal with
the callbacks dened in asynchronous tasks [3] and custom
views [4]. Elite infers all constraints via static analysis. It
then leverages them to generate valid method call sequences,
each of which consists of three parts: (1) method calls to
start components, (2) method calls to interact with the com-
ponents, and (3) method calls to destroy the components.
To ease understanding, Figure 7 provides a method call se-
quence Elite generates for PlaybackService of TomaHawk
(Figure 5). The sequence contains three top level method
calls: (1) the call to onCreate() starts the service,4(2) the
call to playPause() handles the user's touch on the Musi-
cActivity 's UI, and (3) the call to onDestroy() destroys
the service. It is worth mentioning that the number of all
possible method call sequences can be unbounded since users
can interact with an app in innite ways. For practical con-
sideration, Elite limits the number of top level method calls
in each sequence to generate a nite set of sequences. Other
than this limit, Elite 's sequence generation is exhaustive:
it will try all possible orders of top level method calls.
5.4 Wake Lock Necessity Analysis
With the generated method call sequences, Elite then
identies checkpoints in each sequence and performs wake
lock necessity analysis to detect wake lock misuses.
4When starting a service, Android System will also call the on-
StartCommand() handler after calling onCreate(). We simplied
the scenario to ease the presentation.
403Identifying checkpoints. Similar to other event-driven
programs, an Android app will enter a quiescent state after
it nishes handling every event [34]. An app may stay quies-
cent for a long time when there are no new events to handle.
Therefore, it is important to analyze such state-transitioning
time points, which we refer to as checkpoints , to see whether
an app unnecessarily holds any wake lock when it enters a
quiescent state. As we discussed earlier, at runtime, an app's
top level methods are invoked to handle various events. An
app will enter a quiescent state after invoking certain top
level methods to handle an event.5Then, given a sequence
of top level method calls /uni27E8m1;m2;:::;m n/uni27E9, to identify check-
points, Elite rst segments it into disjoint non-empty seg-
ments /uni27E8m1;:::;m i/uni27E9 /uni27E8mi+1;:::;m j/uni27E9. . ./uni27E8mk+1;:::;m n/uni27E9, each
of which contains only the top level method calls that handle
one particular event. Since Android's event handling mech-
anism is well-dened in the API guides [1], the segmentation
result is unique. After sequence segmentation, Elite then
performs analysis after the last method call mcpof each seg-
ment, andcpis the identier of the checkpoint. For example,
for the sequence in Figure 7, Elite will perform analysis af-
ter each method call since each of them handles one event.
Reasoning about the necessity of using wake locks.
At each checkpoint cpof a method call sequence, Elite an-
alyzes the dataow summaries of the methods m1;:::;m cp
and performs the following three checks to detect potential
wake lock misuses and reports the earliest program points
where wake locks should be released:
1) If the app might have acquired a wake lock wlbefore
executing the method mcp, is it possible that after executing
mcp,wlwould be released? If yes, Elite exits with no
warnings. Otherwise, Elite proceeds to the second check.
2) Is it possible that after executing mcp, the app might
have stopped all previously started asynchronous (long term)
computational tasks? If yes, Elite reports a warning since
the app would not be doing any computation after mcp,
but the wake lock wlmight have been acquired. Otherwise,
Elite proceeds to the third check.
3) Can the asynchronous computational tasks, which might
be left running, bring users observable or perceptible ben-
ets? If yes, Elite exits with no warnings. Otherwise,
Elite reports a warning since the benet brought by the
computation might not justify the energy cost of keeping
devices awake. To analyze the benet of a computational
task, Elite performs API call analysis by leveraging our
empirical ndings in Section 4.2. Specically, if any of our
observed critical computation APIs is invoked, Elite de-
cides that the computational task can bring users benets.
Let us illustrate the analysis process using the example in
Figure 7. Suppose that Elite is performing analysis after
the call to playPause() . The rst check will fail since there
is no wake lock releasing operation in onCreate() andplay-
Pause() . Then for the second check, Elite will nd that
the music playing task started by onCreate() might have
been stopped by playPause() and therefore the app might
unnecessarily hold the wake lock afterwards. It will report
a warning accordingly. Finally, after analyzing all check-
points, Elite may generate many warnings. In order not to
overwhelm users, Elite will aggregate the warnings by the
concerned long term computational tasks and the program
points where the wake locks are supposed to be released. To
5Some events requires multiple top level method calls to handle,
e.g., launching an activity component (see Figure 1) [1].ease issue diagnosis and xing, when unnecessary wakeup is-
sues are detected, Elite will also report the locations of the
late wake lock releasing operations so that users can consider
moving them to more appropriate program points.
5.5 Discussions
Elite 's analysis may not be entirely sound and precise
due to common limitations of static analysis. First, the lack
of full path sensitivity may cause Elite to report spuri-
ous warnings (false positives or FPs) or miss certain wake
lock misuses (false negatives or FNs). Second, although
we carefully handled the execution orders of various top
level methods, it is hard to guarantee that Elite can gen-
erate and analyze all feasible method call sequences. Third,
Elite analyzes app components separately, assuming each
one would take care of its own acquired wake locks. This
assumption is reasonable because each app component is a
dierent point through which the Android OS can enter an
app [2] and hence it should carefully manage its acquired sys-
tem resources. However, there is no language-level mecha-
nism to prevent an app component from delegating resource
management tasks to other components. If that happens,
Elite may generate FPs and FNs. Lastly, Elite reasons
about whether app computation can bring users percepti-
ble/observable benets by checking the invocation of pre-
specied platform APIs. This strategy has shown to be ef-
fective [65, 51], but may not work perfectly when the API
set is incomplete or app computation involves native code
or libraries whose implementation are unavailable for anal-
ysis. Although these factors may threaten the eectiveness
ofElite , in our evaluation, we only observed that the lack
of full path sensitivity caused Elite to miss one real issue.
6. EVALUATION
In this section, we evaluate the eectiveness of Elite .
We rst introduce some implementation details. We imple-
mented Elite on top of soot [28] and Apache BCEL [8]. In
soot'swjpp phase, Elite sets all non-abstract methods as
analysis entry points to construct whole program call graph.
In the wjtp phase, Elite identies those app components
that use wake locks and performs call graph analysis to as-
sociate them with their dynamically registered GUI/system
event handlers, custom view and asynchronous task call-
backs. In this process, Elite relies on BCEL for type reso-
lution (e.g., event listener type) and handling generics (e.g.,
inAsyncTask 's denition [3]). Then in the jtpphase, Elite
performs dataow analysis to summarize top level methods
in the app components that use wake locks. Finally, after
thejtpphase, Elite generates method call sequences and
performs wake lock necessity analysis for issue detection.
6.1 Subjects and Experimental Setup
To study whether Elite can eectively detect wake lock
misuses in real-world Android apps, we conducted experi-
ments using six real issues randomly selected from our iden-
tied wake lock misuses. Table 5 lists the basic information
of the issues and their containing apps, which cover ve dif-
ferent categories (diversity) and have received thousands to
millions of downloads (popularity). For our experiments, we
selected 12 versions of these apps. For each version, Table 5
lists its revision ID and lines of Java code. Six of the 12 ver-
sions contain unnecessary wakeup or wake lock leakage issues
and the remaining six are the corresponding bug-xing ver-
sions of these issues. With this setup, we can evaluate the
404Table 5: Wake lock misuse detection results of the three techniques under comparison
IndexSubject Information Issue ELITE Relda [38] Verier [61]
App Name Category Downloads Revision SLOC Info. Warnings TPs Warnings TPs Warnings TPs
1TomaHawk [30] Music & Audio 5K‚àº10Kb4f339bb24 3,027 Type1 1 1 1 0 2 0
2 883d210525 2,768 Clean 0 0 0 0 0 0
3Open-GPSTracker [25] Travel & Local 100K‚àº500Ka9663a7b8d 3,172 Type1 1 1 0 0 1 0
4 6e4e75934b 3,245 Clean 0 0 0 0 1 0
5MyTracks [24] Health & Fitness 10M‚àº50Mf2b4b968df 16,186 Type1 2 2 1 0 2 0
6 7749d47238 16,201 Clean 0 0 1 0 0 0
7FBReader [17] Books & References 10M‚àº50M769269336e 53,730 Type2 1 1 0 0 0 0
8 b90c9cdf5f 53,680 Clean 0 0 0 0 0 0
9MyTracks [24] Health & Fitness 10M‚àº50Mca300f0d 20,495 Type2 1 1 1 0 0 0
10 17ece1cd75 22,467 Clean 0 0 1 0 0 0
11CallMeter [11] Tool 1M‚àº5M60535cdab9 12,086 Type2 0 0 0 0 1 1
12 4e9106ccf2 12,127 Clean 0 0 0 0 1 0
\Type1" = \unnecessary wakeup"; \Type2" = \wake lock leakage"; \Clean" means that developers xed the bug in the corresponding version; \TPs" = \true positives".
precision and recall of Elite . In experiments, we cong-
uredElite to generate method call sequences with at most
eight top level method calls, which enabled Elite to gen-
erate thousands of dierent sequences for analysis. We also
compared Elite with two existing techniques: Relda [38]
and Verier [61]. Relda is a static analysis technique for
detecting resource leaks in Android apps [38] (wake locks
are also system resources). Verier is a static analysis tech-
nique for verifying that wake locks are properly released at
program exit points [61]. We obtained the original imple-
mentations of Relda and Verier from their authors.
6.2 Experimental Results and Analysis
All three techniques nished analyzing each subject in a
few minutes on our Linux server and reported some warn-
ings. We checked the warnings against our ground truth
and summarize the results in Table 5. Elite detected ve
real issues, but missed the wake lock leakage in CallMeter.
All its reported six warnings are true ones. Relda did not
detect real issues. Its reported ve warnings are false alarms
(Relda is a general resource leak detector, but we only con-
sider its reported wake lock issues here). Verier reported
eight warnings, only one of which is true. To understand
why these techniques report FPs and FNs, we further inves-
tigated their analysis results and gured out several reasons.
1) Relda and Verier are critical computation obliv-
ious. Their algorithms do not consider the semantics of
an app but simply assume that wake locks, once acquired,
should be released at a pre-dened set of event handlers. As
our empirical ndings suggest, Android apps may release
wake locks at various program points and such an assump-
tion may not hold in many cases. For instance, in Toma-
Hawk, Verier expects the wake lock to be released at the
onStartCommand() handler of PlaybackService , regardless
whether the wake lock is needed afterwards. This leads to
false warnings. As a comparison, Elite makes no assump-
tion on wake lock acquiring/releasing points, but automati-
cally reasons about the necessity of using wake locks at dif-
ferent program points. Therefore, it can precisely infer that
playPause() is an appropriate wake lock releasing point in
PlaybackService because the method may stop playing mu-
sic, which is the critical computation protected by the wake
lock. Several other FPs and FNs reported by Relda and
Verier are also due to this reason ( xxlabelled ones).
2) Some FPs and FNs ( xxlabelled ones) are caused by in-
complete handling of program callbacks . Specically,
Relda and Verier do not systematically locate all dened
program callbacks for each app component and properly
handle the temporal relations among them. For example,
Relda does not analyze callbacks of asynchronous tasks [3],
which are widely-used in real-world Android apps. There-fore, for the wake lock leakage in MyTracks (Figure 6), it can
only infer that the onPause() handler of the ExportAllAc-
tivity , which starts the ExportAllAsyncTask in its onCre-
ate() handler, should take care of wake lock releasing. This
is the reason why Relda reports false warnings for both the
buggy version and clean version (Rows 9{10). On the other
hand, although Verier can handle asynchronous tasks, it
cannot properly handle the temporal relations among their
callbacks. For the wake lock leakage in MyTracks, it did not
consider that onPostExecute() handler may not always fol-
lowdoInBackground() , and therefore failed to detect the is-
sue. As a comparison, Elite does not have such limitations.
It adopts a xed-point iterative algorithm to nd all reg-
istered GUI/system event handlers, asynchronous task and
custom view callbacks for each app component and leverages
temporal constraints formulated from Android API guides
to generate valid method call sequences for analysis.
3)The lack of full path sensitivity in program anal-
ysis also led to some FPs and FNs ( xxlabelled ones). For
example, Elite merges dataow facts at control ow con-
uence and method return points and therefore failed to
detect the wake lock leakage in CallMeter, which occurred
because developers forgot to release the wake lock on a spe-
cic program path. Relda's analysis is ow-insensitive and
also failed to detect the issue. Verier's analysis considers
a certain level of path sensitivity. It does not merge analy-
sis results at method return points and successfully detected
the issue in CallMeter. However, Verier still reports a false
warning when analyzing the corresponding bug-xing ver-
sion because it cannot handle cases where the lock acquiring
and releasing operations are guarded by the same condition.
From the above discussions, we can observe that eec-
tively detecting wake lock misuses in real-world Android
apps requires sophisticated algorithms. Elite outperforms
existing techniques in precision and recall because it system-
atically handles program callbacks and considers program
semantics by reasoning about the necessity of using wake
locks at dierent program points. Still, Elite 's analysis is
not path-sensitive and may fail to detect some real issues.
We will consider improving its algorithm in future work.
7. THREATS TO VALIDITY
The rst threat to the validity of our study results is the
representativeness of our selected Android apps. To mini-
mize the threat, we randomly downloaded the latest version
of 44,736 apps from Google Play store and chose 31 popular
open-source apps from major software hosting sites. We be-
lieve our ndings can generalize to many real-world Android
apps. The second threat is the imprecision of the statically
constructed call graphs. We understand that imprecise call
405graphs may lead to imprecise ndings. Therefore, before
analyzing the whole dataset, we did a pilot study on 50 ran-
domly sampled apps, 30 commercial and 20 open-source. In-
deed, we found Soot can generate infeasible call graph edges
when resolving virtual calls, because its default CHA algo-
rithm conservatively considers all possible callees based on
class hierarchy. To avoid such imprecision, during call graph
traversal, if our tool nds that a visited method has multiple
callees with the same method signature, it will stop visiting
them. We also tried the more precise Spark algorithm of
Soot.6However, when resolving virtual calls, Spark needs
to know the type of the base objects, which requires prop-
agating type information along assignments starting at an
allocation site [43]. In Android apps, many objects are not
created by invoking constructors, but from factory meth-
ods of Android SDK (e.g., the PowerManager and WakeLock
objects in Figure 2), whose implementation involves native
code. In such cases, Spark will fail to resolve virtual calls
(e.g., the wake lock acquiring API call in Figure 2). Al-
though this problem may be solved by manually writing li-
brary models or analyzing Android framework code together
with each app, such solutions are prohibitively costly. The
third threat is the potential errors in our manual investi-
gation of bug reports and code revisions in our empirical
study. To reduce the threat, we cross-validated the results
and also release them for public access [16]. Lastly, we did
not evaluate Elite on many real-world apps. Existing stud-
ies [38, 61] conducted evaluations on commercial apps from
Google Play store. We did not adopt a similar setting be-
cause it is hard to establish the ground truth due to the lack
of source code and bug reports for these apps, which can be
heavily obfuscated. In our work, we randomly selected ve
open-source apps and carefully prepared the ground truth
for 12 versions of them for experiments. We believe this set-
ting is fair and necessary to compare Elite with existing
techniques to analyze their strengths and limitations.
8. RELATED WORK
Our paper relates to a large body of existing studies. This
section discusses some representative ones in recent years.
Wake lock misuse detection. Wake lock misuses can
cause serious problems in Android apps [46, 48]. Pathak et
al. conducted the rst study and adapted reaching denition
dataow analysis technique to detect energy bugs caused by
wake lock leakage [58]. Later, researchers proposed other
static and dynamic analysis techniques for the same pur-
pose [61, 51, 62]. For example, Vekris et al. proposed a
static analysis technique for verifying the absence of wake
lock leakage in an Android app [61]. Wang et al. designed
a technique to repair these issues at runtime [62]. Nonethe-
less, these studies focused on energy waste issues caused by
wake lock leakage. As our study suggests, there are many
other common patterns of wake lock misuses that can cause
various functional and non-functional issues. These patterns
have not been well studied in existing literature.
Resource management and leak detection. Manag-
ing wake locks in Android apps resembles managing system
resources (e.g., memory blocks, le handles) in conventional
software [35, 32, 60]. In recent years, researchers have pro-
posed techniques to facilitate resource management on An-
droid platform. Jindal et al. identied four types of sleep
6Other algorithms may construct more precise call graphs, but
are not ecient for analyzing a large number of apps [63].conicts in Android device drivers and proposed a runtime
debugging system to avoid such conicts [40]. ARSM [41]
statically analyzes Android apps to mine resource manage-
ment specications (i.e., the correct order of resource opera-
tions). Relda adapts the idea of resource safety policy check-
ing [32, 60] to detect resource leaks in Android apps, which
cover wake lock leakage [38]. Similar to the earlier veri-
cation technique [61], Relda makes assumptions on resource
acquiring and releasing points (this is understandable since
Relda needs to handle general resources rather than focus-
ing on wake locks) and cannot properly handle the temporal
relations among callbacks. Due to such reasons, Relda may
fail to detect wake lock misuses in real-world Android apps.
Energy eciency analysis. Detecting wake lock mis-
uses can help improve energy eciency of Android apps.
There are also studies towards this goal from other angles [50].
For example, vLens [44], eLens [39], eProf [57], PowerTu-
tor [66] can estimate the energy consumption of Android
apps to identify hotspots. ADEL [65] and GreenDroid [49]
can locate energy bugs caused by ineective use of program
data. Banerjee et al. presented a framework to generate
test inputs to uncover energy bugs and hotspots [33]. Li
proposed a technique to bundle small HTTP requests in
Android apps to save energy [45]. AlarmScope [56] can help
reduce non-critical alarm-induced wakeup in Android apps.
SEEDS can help developers select energy-ecient implemen-
tations of Java libraries for Android apps [53]. GEMMA can
generate energy-ecient color palettes for apps running on
mobile devices with OLED screens [47]. These techniques
are mostly designed for developers. There also exist end
user-oriented techniques. For example, eDoctor [52] can cor-
relate system/user events to energy-heavy execution phases
to help users troubleshoot battery drains and suggest re-
pairs. Carat [55] shares the same goal, but adopts a big data
approach by collecting runtime data from a large community
of smartphones to infer energy usage models for providing
users advices on improving smartphone battery life.
9. CONCLUSION
In this paper, we conducted a large-scale empirical study
to understand how Android developers use wake locks in
practice. Our study revealed the common practices of de-
velopers and identied eight common patterns of wake lock
misuses. To demonstrate the usefulness of our empirical
ndings, we proposed a static analysis technique, Elite , to
detect the two most common patterns of wake lock misuses
that can cause serious energy waste. We evaluated Elite on
12 versions of ve real-world subjects and the experimental
results show that Elite is eective and can outperform two
existing techniques. In future, we plan to further improve
Elite (e.g., extending it to other six patterns) and conduct
more experiments to evaluate its eectiveness.
10. ACKNOWLEDGMENTS
This research was supported by RGC/GRF Grant 611813
of Hong Kong, National Basic Research 973 Program (Grant
No. 2015CB352202) and National Natural Science Founda-
tion (Grant Nos. 61472174, 91318301, 61321491) of China,
and 2016 Microsoft Research Asia Collaborative Research
Program. We would like to greatly thank the FSE 2016
reviewers for their comments and suggestions that helped
improve this work. We would also like to thank the support
of the Collaborative Innovation Center of Novel Software
Technology and Industrialization, Jiangsu, China.
40611. ARTIFACT DESCRIPTION
We release the following datasets and tool along with our
paper under the MIT License:
‚óèThe basic information (e.g., permissions) of the 1,117,195
Android apps and the .apk les of the 44,736 apps that
use wake locks. The data are available at:
http://sccpu2.cse.ust.hk/elite/downloadApks.html.
‚óèThe 31 popular and large-scale open-source Android apps
that use wake locks. Links to the apps' source code repos-
itories are available at:
http://sccpu2.cse.ust.hk/elite/dataset.html.
‚óèThe 55 wake lock misuse issues we found in the 31 open-
source Android apps. They are documented at:
http://sccpu2.cse.ust.hk/elite/les/wakelock issues.xlsx.
‚óèOur static analysis tool, Elite , that can analyze Android
apps to detect wake lock misuses. The tool is available at:
http://sccpu2.cse.ust.hk/elite/tool.html.
The package elite.zip , which you can download via the
above link to our tool, contains the following directories:
‚óèThe directory tools contains a copy of Elite 's implemen-
tation and scripts for running analysis tasks.
‚óèThe directory subjects contains our 12 experimental sub-
jects in .jar format. Running Elite on them can repro-
duce our experimental results in Table 5.
‚óèThe directory apks contains 20 Android apps in .apk for-
mat. These apps are randomly selected from Google Play
store for testing Elite .
11.1 Analyzing Android Apps (JAR Files)
Elite can take an Android app's Java bytecode (in .jar
format) as input for analysis. The expected running envi-
ronment is a 64-bit Linux machine with JRE 8.
To run Elite on our experimental subjects, rst navigate
to the tools directory and then run the elite_jar.sh script
from there with two arguments:
‚óèthe path to the .jar le for analysis
‚óèthe path to the output folder
For instance, the following command will start Elite to
analyze the example.jar le in the subjects directory and
save analysis results to the directory tools/outputs :
$ elite_jar .sh ../ subjects / example .jar outputs
When the analysis nishes, Elite will output three les
to the outputs directory. The les example.txt and ex-
ample.err contain detailed running information of Elite ,
which are redirected from console outputs stdout andstderr .
The le example-short.txt contains analysis result for each
app component c, including:
‚óèthe class name of the app component c
‚óèwhethercuses wake locks or not
‚óèthe type of wake locks if cuses wake locks
‚óèthe acquistion and releasing points of wake locks if cuses
wake locks
‚óèa list of warnings if cmisuses wake locks
Listing 1 gives the analysis result of running Elite on
the subject MyTracks (revision f2b4b968df ). In the exam-
ple,Elite reports that the app component TrackRecord-
ingService uses a partial wake lock and the wake lock is[ WLA : STATUS ] analyzing service =com. google . android . apps .
mytracks . services . TrackRecordingService
[ WLA :USE LOCK ] true
[ WLA : LOCK TYPE ] partial
[ WLA : LOCKING SITE ] <com. google . android . apps . mytracks . services .
TrackRecordingService : void onCreate () >
[ WLA : LOCKING SITE ] <com. google . android . apps . mytracks . services .
TrackRecordingService : void acquireWakeLock () >
[ WLA : RELEASING SITE ] <com. google . android . apps . mytracks .
services . TrackRecordingService : void onDestroy () >
...
=== policy violation ===
component class : com. google . android . apps . mytracks . services .
TrackRecordingService
wake lock should be released at: void endCurrentTrack ()
example sequence : <com . google . android . apps . mytracks . services .
TrackRecordingService : void onCreate () ><com. google . android .
apps . mytracks . services . TrackRecordingService : int
onStartCommand ( android . content .Intent ,int ,int) ><com . google .
android . apps . mytracks . services . TrackRecordingService : void
endCurrentTrack () ><com. google . android . apps . mytracks . services .
TrackRecordingService : void onStatusChanged ( java . lang . String ,
int , android .os. Bundle ) ><com . google . android . apps . mytracks .
services . TrackRecordingService : void onStatusChanged ( java . lang
. String ,int , android .os. Bundle )>
Listing 1: Example analysis output
acquired and released in the onCreate() and onDestroy()
handlers of the component, respectively. Elite also detects
that the component may suer from unnecessary wakeup
issues and reports warnings accordingly. To ease issue di-
agnosis, Elite further provides the method call sequences
leading to the detected issue and the program points where
wake locks should be released (i.e., endCurrentTrack() ).
11.2 Analyzing Android Apps (APK Files)
Elite can also take an Android app's .apk le, which
contains the Dalvik bytecode of the app, as input for anal-
ysis. The input le names should follow the format \pack-
agename.apk", where the package name is the app's unique
ID declared in the AndroidManifest.xml le.7The process
of running Elite on an .apk le is similar to that of running
Elite on an .jar le. The only dierence is to use another
script elite_apk.sh . For example, below is a sample com-
mand to invoke Elite for analyzing an .apk le (assuming
the current working directory is tools ).
$ elite_apk .sh ../ apks / example . apk outputs
11.3 Analyzing Android Apps in Batch Mode
We also provide scripts to run Elite to analyze a direc-
tory of .jar or.apk les. To run Elite in this batch mode,
please navigate to the tools directory and run the scripts
elite_jar_batch.sh orelite_apk_batch.sh with the fol-
lowing four arguments:
‚óèthe path to the directory of .jar les (or .apk les) for
analysis
‚óèthe path to the output folder
‚óèthe maximum number of concurrent jobs
‚óèthe total les to be analyzed
For instance, running the following command will start
Elite to analyze 20 .apk les in the apks directory with 6
concurrent jobs running at the same time and output the
analysis results to the outputs directory.
$ elite_apk_batch .sh ../ apks outputs 6 20
7https://developer.android.com/guide/topics/manifest/manifest-
element.html
40712. REFERENCES
[1] Android API guides.
https://developer.android.com/guide/.
[2] Android app fundamentals.
https://developer.android.com/guide/components/fun-
damentals.html.
[3] Android AsyncTask.
http://developer.android.com/reference/android/os/
AsyncTask.html.
[4] Android custom views.
http://developer.android.com/training/custom-views/.
[5] Android ocial website. http://www.android.com/.
[6] Android platform version distribution.
https://developer.android.com/about/dashboards/.
[7] Android system permissions.
http://developer.android.com/guide/topics/security/
permissions.html.
[8] Apache Commons BCEL.
http://commons.apache.org/proper/commons-bcel/.
[9] APKLeecher. http://apkleecher.com/.
[10] AppBrain statistics. http://www.appbrain.com/.
[11] CallMeter source code repository.
https://github.com/felixb/callmeter/.
[12] ConnectBot source code repository.
https://code.google.com/p/connectbot/.
[13] Crawler4j. https://code.google.com/p/crawler4j.
[14] CSipSimple source code repository.
https://code.google.com/p/csipsimple/.
[15] Dex2Jar. https://code.google.com/p/dex2jar.
[16]Elite project website. http://sccpu2.cse.ust.hk/elite/.
[17] FBReader source code repository.
https://github.com/geometer/FBReaderJ.
[18] Firefox issue tracker. https://bugzilla.mozilla.org/.
[19] GitHub. https://github.com/.
[20] Google Code. https://code.google.com/.
[21] Google Play store. https://play.google.com/store.
[22] K-9 Mail source code repository.
https://code.google.com/p/k9mail/.
[23] Mozilla repositories. https://mxr.mozilla.org/.
[24] MyTracks source code repository.
https://code.google.com/p/mytracks/.
[25] Open-GPSTracker source code repository.
https://code.google.com/archive/p/open-gpstracker/.
[26] Osmand source code repository.
https://code.google.com/p/osmand/.
[27] SipDroid source code repository.
https://code.google.com/p/sipdroid/.
[28] Soot project website. http://sable.github.io/soot/.
[29] SourceForge. http://sourceforge.net/.
[30] TomaHawk source code repository.
https://github.com/tomahawk-player/tomahawk.[31] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman.
Compilers: Principles, Techniques, and Tools (2nd
Edition) . Addison-Wesley Longman Publishing Co.,
Inc., 2006.
[32] M. Arnold, M. Vechev, and E. Yahav. QVM: An
Ecient Runtime for Detecting Defects in Deployed
Systems. In OOPSLA , pages 143{162, 2008.
[33] A. Banerjee, L. K. Chong, S. Chattopadhyay, and
A. Roychoudhury. Detecting Energy Bugs and
Hotspots in Mobile Apps. In FSE, pages 588{598,
2014.
[34] E. Cheong and J. Liu. galsC: A Language for
Event-Driven Embedded Systems. In DATE , pages
1050{1055, 2005.
[35] J. Clause and A. Orso. LEAKPOINT: Pinpointing the
Causes of Memory Leaks. In ICSE , pages 515{524,
2010.
[36] A. P. Felt, E. Chin, S. Hanna, D. Song, and
D. Wagner. Android Permissions Demystied. In CCS,
pages 627{638, 2011.
[37] D. Grove, G. DeFouw, J. Dean, and C. Chambers.
Call Graph Construction in Object-oriented
Languages. In OOPSLA , pages 108{124, 1997.
[38] C. Guo, J. Zhang, J. Yan, Z. Zhang, and Y. Zhang.
Characterizing and Detecting Resource Leaks in
Android Applications. In ASE, pages 389{398, 2013.
[39] S. Hao, D. Li, W. G. J. Halfond, and R. Govindan.
Estimating Mobile Application Energy Consumption
Using Program Analysis. In ICSE , pages 92{101, 2013.
[40] A. Jindal, A. Pathak, Y. C. Hu, and S. Midki.
Hypnos: Understanding and Treating Sleep Conicts
in Smartphones. In EuroSys , pages 253{266, 2013.
[41] Y. Kang, X. Miao, H. Liu, Q. Ma, K. Liu, and Y. Liu.
Learning Resource Management Specications in
Smartphones. In ICPADS , pages 100{107, 2015.
[42] M. Lan, C. Tan, J. Su, and Y. Lu. Supervised and
Traditional Term Weighting Methods for Automatic
Text Categorization. IEEE TPAMI , 31(4):721{735,
2009.
[43] O. Lhot ak and L. Hendren. Scaling Java Points-to
Analysis Using SPARK. In CC, pages 153{169, Berlin,
Heidelberg, 2003.
[44] D. Li, S. Hao, W. G. J. Halfond, and R. Govindan.
Calculating Source Line Level Energy Information for
Android Applications. In ISSTA , pages 78{89, 2013.
[45] D. Li, Y. Lyu, J. Gui, and W. G. Halfond. Automated
Energy Optimization of HTTP Requests for Mobile
Applications. In ICSE , pages 249{260, May 2016.
[46] M. Linares-V asquez, G. Bavota, C. Bernal-C ardenas,
R. Oliveto, M. Di Penta, and D. Poshyvanyk. Mining
Energy-greedy API Usage Patterns in Android Apps:
An Empirical Study. In MSR , pages 2{11, 2014.
[47] M. Linares-V asquez, G. Bavota, C. E. B. C ardenas,
R. Oliveto, M. Di Penta, and D. Poshyvanyk.
Optimizing Energy Consumption of GUIs in Android
Apps: A Multi-objective Approach. In FSE, pages
143{154, 2015.
408[48] M. Linares-Vasquez, C. Vendome, Q. Luo, and
D. Poshyvanyk. How Developers Detect and Fix
Performance Bottlenecks in Android Apps. In ICSME ,
pages 352{361, 2015.
[49] Y. Liu, C. Xu, and S. C. Cheung. Where Has My
Battery Gone? Finding Sensor Related Energy Black
Holes in Smartphone Applications. In PerCom , pages
2{10, 2013.
[50] Y. Liu, C. Xu, and S. C. Cheung. Diagnosing energy
eciency and performance for mobile internetware
applications. IEEE Software , 32(1):67{75, Jan 2015.
[51] Y. Liu, C. Xu, S. C. Cheung, and J. Lu. GreenDroid:
Automated Diagnosis of Energy Ineciency for
Smartphone Applications. IEEE TSE , 40(9):911{940,
2014.
[52] X. Ma, P. Huang, X. Jin, P. Wang, S. Park, D. Shen,
Y. Zhou, L. K. Saul, and G. M. Voelker. eDoctor:
Automatically Diagnosing Abnormal Battery Drain
Issues on Smartphones. In NSDI , pages 57{70, 2013.
[53] I. Manotas, L. Pollock, and J. Clause. SEEDS: A
Software Engineer's Energy-optimization Decision
Support Framework. In ICSE , pages 503{514, 2014.
[54] P. Mutchler, Y. Safaei, A. Doup e, and J. Mitchell.
Target Fragmentation in Android Apps. In MoST ,
May 2016.
[55] A. J. Oliner, A. P. Iyer, I. Stoica, E. Lagerspetz, and
S. Tarkoma. Carat: Collaborative Energy Diagnosis
for Mobile Devices. In SenSys , pages 10:1{10:14, 2013.
[56] S. Park, D. Kim, and H. Cha. Reducing Energy
Consumption of Alarm-induced Wake-ups on Android
Smartphones. In HotMobile , pages 33{38, 2015.
[57] A. Pathak, Y. C. Hu, and M. Zhang. Where is the
Energy Spent Inside My App?: Fine Grained Energy
Accounting on Smartphones with Eprof. In EuroSys ,
pages 29{42, 2012.[58] A. Pathak, A. Jindal, Y. C. Hu, and S. P. Midki.
What is Keeping My Phone Awake?: Characterizing
and Detecting No-sleep Energy Bugs in Smartphone
Apps. In MobiSys , pages 267{280, 2012.
[59] X. Perez-Costa and D. Camps-Mur. IEEE 802.11E
QoS and Power Saving Features Overview and
Analysis of Combined Performance. IEEE WC ,
17(4):88{96, 2010.
[60] E. Torlak and S. Chandra. Eective Interprocedural
Resource Leak Detection. In ICSE , pages 535{544,
2010.
[61] P. Vekris, R. Jhala, S. Lerner, and Y. Agarwal.
Towards Verifying Android Apps for the Absence of
No-Sleep Energy Bugs. In HotPower , pages 3{3, 2012.
[62] X. Wang, X. Li, and W. Wen. WLCleaner: Reducing
Energy Waste Caused by WakeLock Bugs at Runtime.
InDASC , pages 429{434, 2014.
[63] X. Xiao and C. Zhang. Geometric Encoding: Forging
the High Performance Context Sensitive Points-to
Analysis for Java. In ISSTA , pages 188{198, 2011.
[64] S. Yang, D. Yan, H. Wu, Y. Wang, and A. Rountev.
Static Control-Flow Analysis of User-Driven Callbacks
in Android Applications. In ICSE , pages 89{99, 2015.
[65] L. Zhang, M. S. Gordon, R. P. Dick, Z. M. Mao,
P. Dinda, and L. Yang. ADEL: An Automatic
Detector of Energy Leaks for Smartphone
Applications. In CODES+ISSS , pages 363{372, 2012.
[66] L. Zhang, B. Tiwana, R. Dick, Z. Qian, Z. Mao,
Z. Wang, and L. Yang. Accurate Online Power
Estimation and Automatic Battery Behavior Based
Power Model Generation for Smartphones. In
CODES+ISSS , pages 105{114, 2010.
[67] M. Zhang, Y. Duan, H. Yin, and Z. Zhao.
Semantics-Aware Android Malware Classication
Using Weighted Contextual API Dependency Graphs.
InCCS, pages 1105{1116, 2014.
409