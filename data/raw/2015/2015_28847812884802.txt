Improving Refactoring Speed by 10X
Jongwook Kim,
Don Batory
University of Texas at Austin
fjongwook,batoryg@cs.utexas.eduDanny Dig
Oregon State University
digd@eecs.oregonstate.eduMaider Azanza
University of the Basque
Country (UPV/EHU)
maider.azanza@ehu.eus
ABSTRACT
Refactoring engines are standard tools in today's Integrated
Development Environments (IDEs) . They allow program-
mers to perform one refactoring at a time, but programmers
need more. Most design patterns in the Gang-of-Four text
can be written as a refactoring script { a programmatic se-
quence of refactorings. In this paper, we present R3, a new
Java refactoring engine that supports refactoring scripts.
It builds a main-memory, non-persistent database to en-
code Java entity declarations (e.g., packages, classes, meth-
ods), their containment relationships, and language features
such as inheritance and modiers. Unlike classical refac-
toring engines that modify Abstract Syntax Trees (ASTs) ,
R3refactorings modify only the database; refactored code
is produced only when pretty-printing ASTs that reference
database changes. R3performs comparable precondition
checks to those of the Eclipse Java Development Tools (JDT)
butR3's codebase is about half the size of the JDT refactor-
ing engine and runs an order of magnitude faster. Further,
a user study shows that R3improved the success rate of
retrotting design patterns by 25% up to 50%.
1. INTRODUCTION
Refactoring is a core technology in software development.
All major IDEs today oer some form of refactoring sup-
port; refactoring is central to popular software design move-
ments, such as Agile [38] and Extreme Programming [10].
In the last decade, refactoring tools have revolutionized how
software is developed. They enable programmers to con-
tinuously explore the design space of large codebases, while
preserving existing behavior. Modern IDEs such as Eclipse,
NetBeans, IntelliJ IDEA, and Visual Studio incorporate refac-
torings in their top menu and often compete on the basis of
refactoring support.
Despite vast interest and progress, a key functionality that
many have recognized to be missing in IDEs is scripting [11,
28, 51]. Most design patterns in the Gang-of-Four text [25]
can be expressed as a refactoring script { a programmatic
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14-22, 2016, Austin, TX, USA
c2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.2884802sequence of refactorings [33, 52]. Adding and removing de-
sign patterns manually is laborious, repetitious, error prone,
and often too dicult to do { try creating a Visitor with over
10methods; the benets of scripting become clear.
We recently [35] added scripting to Eclipse JDT, exposing
the core declarations of a Java program (packages, classes,
methods, etc.) as objects whose methods are JDT refactor-
ings. Refactoring scripts that add or remove design patterns
are short Java methods. Our tool, called R2, is detailed in
the next section. Experiments revealed JDT Refactoring
Engine (JDTRE) is ill-suited for scripting for three reasons:
Reliability. JDTRE is buggy [21, 26, 48]. We led 31
new bugs to date, but only a fraction has been xed in
the latest version of Eclipse. Prior to the current release,
one R2script executed 6JDT refactorings producing a
program with 27compilation errors. Another script in-
voked 96refactorings, producing a program with 100com-
pilation errors. These errors are notdue to R2, but are
egregious bugs in JDTRE. We are constantly discovering
more. Worse is waiting months or years for a repair [21].
We rediscovered a bug that took 5years to be xed [19].
Note: We are not in a position to repair JDTRE. There is
no reason for us to believe our patches would be accepted.
We report bugs as others do.
Expressivity. We found the need for additional primitive
refactorings and to repair existing refactorings. JDTRE
refuses to move methods that include the super keyword;
moving methods with super reference(s) is really useful.
We also had to turn o parameter optimization, for ex-
ample, to make JDT refactorings produce design patterns
correctly [35].
Speed. JDTRE's Achilles heel is its speed: it is surpris-
ingly slow. While a single JDT refactoring is fast, exe-
cuting many is not. R2scripts that invoke 20refactorings
take over 10seconds. One script invoked 554refactor-
ings and took 5minutes to execute. Programmers expect
refactorings to be instantaneous.
We concluded that a radically dierent approach to build
refactoring engines for scripting was needed to remove these
problems. Our novel solution, called R3, creates a database
of program elements (such as classes, methods, elds), their
containment relationships, and Java language features such
as inheritance and modiers. Precondition checks consult
harvested values in database tuples; refactorings alter the
database. ASTs are never changed ; refactored code is pro-
duced only when pretty-printing ASTs that reference data-
base changes. This strategy yields a 10 increase in refac-
toring speed and a 50% smaller codebase.
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   1145
The contributions of this paper are:
A novel foundation ( R3) of database+pretty printing
for designing a new generation of refactoring engines
that support scripting,
R3's codebase is a mere 4K LOC and does not use
Eclipse Language Toolkit (LTK) [24] utilities,
Ecient ways to evaluate refactoring preconditions:
boolean properties of ASTs are harvested during data-
base creation where precondition checks consult their
values and the database supports fast searches,
An empirical evaluation of R3on6case studies exe-
cuted 52scripts. R3runs at least 10faster on average,
in two cases 285 faster than JDTRE, and
A user study involving 2 classes (44 undergraduates
and 10 graduates) showed R3improved the success rate
of retrotting design patterns by 25% up to 50%.
2. A RECAP OF R2
Most classical design patterns can be expressed by a series
of refactorings [33, 52]. In [35], we leveraged the JDTRE to
provide a practical way to write such scripts.
class Graphic { 
void draw { ‚Ä¶ }
}
class Square extends Graphic {
void draw() { ‚Ä¶ }
}
class Picture extends Graphic {
void add(Graphic g) { ‚Ä¶ }
void draw() { ‚Ä¶ }
}package
Square
drawPicture
draw addGraphic
drawùëêùëúùëöùëùùëñùëôùëíùëü
Source Abstract Syntax Tree (AST)AST methID name args clsID
m1 draw { }
m2 add { c1}
m3 draw {}
m4 draw { }AST clsID name parent
c1 Graphic
c2 Square c1
c3 Picture c1
ùë°ùëüùëéùë£ùëíùëüùë†ùëéùëôRClass
RMethod
R3Databaseclass Graphic { 
void draw { ‚Ä¶ }
}
class Square extends Graphic {
void draw() { ‚Ä¶ }
}
class Picture extends Graphic {
void add(Graphic g) { ‚Ä¶ }
void draw() { ‚Ä¶ }
}
Figure 1: A Java Program.R2is a Java package.
Its objects correspond to
Java entity declarations
such as packages, classes,
methods, etc. The pro-
gram in Figure 1 has
seven R2objects. There
are 3classes: Graphic ,
Square ,Picture and 4
methods: three draws and
oneadd.
Methods of R2objects are JDT refactorings or database
retrievals. Representative methods are listed in Table 1.
R2Type Method Name Semantics
RPackage newClassadd a new class to the
package
RClassaddSingletonapply Singleton pattern to
the class
getAllMethodsreturn a list of R2objects
that are all methods of the
class
getPackagereturn the R2object of its
own package
newConstructorass a new constructor to the
class
newMethodadd a new method stub to
the class
newField add a new eld to the class
setInterface set to implement an interface
RMethod getRelativesreturn a list of R2objects
of methods with the same
signature
RRelativeListaddParameteradd a parameter with its
default value to all methods
moveAndDelegatemove methods to a class,
leaving behind a delegate
rename rename all methods
Table 1: Methods of R2.
R2refactoring scripts are short Java methods. Here are
two examples. Figure 2 is an R2script that creates an
Adapter. A programmer uses the Eclipse GUI to identify
a Java class cthat is to be adapted to Java interface i. The
programmer then invokes R2'smakeAdapter refactoring (just
like a built-in Eclipse refactoring), which in turn invokes
i.makeAdapter(c,N) where Nis the name of the Adapter
class to be created. Class Nis created in the same pack-age as interface i(Line 3), to which is added a eld named
adaptee of type cand a constructor to initialize adaptee
(Lines 5{6). A stub is generated for each method in inter-
face i(Line 9). The created class Nimplements interface i
(Line 11). The R2object for Nis returned as the result of
makeAdapter .
1 // member of RInterface class
2 RClass makeAdapter ( RClass c, String N) {
3 RClass adapter = this . getPackage (). newClass (N);
4
5 RField f = adapter . newField (c, " adaptee ");
6 adapter . newConstructor (f);
7
8 for( RMethod m : this . getAllMethods ())
9 adapter . newMethod (m);
10
11 adapter . setInterface ( this );
12
13 return adapter ;
14 }
Figure 2: R2 makeAdapter Method.
Figure 3 is an R2script to create a Visitor design pattern.
Using the Eclipse GUI, a programmer identies a method,
called a seed, in a class hierarchy that s/he wants to create a
Visitor; s/he then invokes R2'smakeVisitor refactoring from
the Eclipse GUI. Doing so invokes seed:makeVisitor(N),
where seed isR2object of the seed and Nis the name of
the Visitor class to be created. makeVisitor gets the seed's
package, creates a Visitor class vwith name Nin that pack-
age, and makes va Singleton (Lines 3{5). Next, all methods
with the same signature as the seed are collected onto a list.
Every method on the list is renamed to accept (Line 8),
and then a parameter of type vis added whose default value
is the Singleton eld of N(Line 10). The index value that
is returned is the index number of the Visitor parameter.
Only movable methods (e.g., abstract orinterface meth-
ods cannot be moved) are relocated to class N, leaving behind
delegates, respectively (Line 11). All methods in the Visitor
class are renamed to visit .makeVisitor returns v, the R2
Visitor class object.
1 // member of RMethod class
2 RClass makeVisitor ( String N) {
3 RPackage pkg = this . getPackage ();
4 RClass v = pkg . newClass (N);
5 RField singleton = v. addSingleton ();
6
7 RRelativeList relatives = this . getRelatives ();
8 relatives . rename (" accept ");
9
10 int index = relatives . addparameter ( singleton );
11 relatives . moveAndDelegate ( index );
12
13 v. getAllMethods (). rename (" visit ");
14
15 return v;
16 }
Figure 3: R2 makeVisitor Method.
These examples of 15 LOC are typical of R2scripts;
they are very short. We implemented 18of the 23design
patterns in the Gang-of-Four text [25] using R2. Eight pat-
terns (including Visitor) are fully automatable as there are
no programmer TO-DO s. Another ten are partially automat-
able. This includes Adapter, where only stubs are generated.
Some of the remaining patterns are automatable, such as
State and Mediator,1while others, Fa cade and Iterator, are
1State is a typical MDE application [5]. Mediator is the essence of
1146so application-specic that little or nothing is reusable [35].
Java is a practical scripting language { writing R2scripts is
like writing regular Java code. Programmers do not need to
learn a Domain Specic Language (DSL) for program trans-
formations. R2scripts invoke JDT refactorings and create
new program elements. Although using Java as a scripting
language is great, JDTRE is not, as mentioned in the Intro-
duction (reliability and speed being the biggest detractors).
JDTRE was never designed for scripting refactorings. Hence
the motivation for R3.
3. R3 CONCEPTS
3.1 Modularity Perspectives
Elementary physics inspired R3. A physical object looks
dierent depending upon an observer's location. Silhouette
portraits of people are dierent from frontal portraits. Just
as viewpoints of a physical object are created by rotations
and translations, called coordinate transformations that pre-
serve object properties ,R3does the same for programs: it
refactors programs by pretty-printing without changing the
program's ASTs or behavior.
To see how, we strip away Object-Oriented (OO) notation.
A method implements an absolute function (the reason for
`absolute' is explained shortly) where all method parameters
are explicit as they would be in a C-language declaration.
Figure 4a is the signature of an absolute function foowith
three parameters whose types are B,C,D.
A foo(C c, D d)
A foo(B b, D d)
static A foo(B b, C c, D d)A foo(B b, C c, D d) (a)(b)
(c)
(d)
if
expr stmt(a)
if expr
then stmt;if (expr)
{ stmt}(b)
(c)expr
stmtyes no
(d)
Figure 4: An Absolute Function and its Relative Methods.
Iffoois displayed as a member of class B, Figure 4b is its
signature: the Bparameter becomes this and is otherwise
implicit. If foois displayed as a member of class C, Figure 4c
is its signature, where the Cparameter is this. We say
thenatural homes of an absolute function are its parameter
types. The natural homes for method fooare B,C,D. If
foois displayed as a member of class E, not a natural home,
it appears as the static method of Figure 4d which has no
implicit this parameter.
Amodularity perspective assigns absolute functions to class
declarations. The idea generalizes to other entity declara-
tions (e.g., packages, classes, elds) and their containment
relationships. To illustrate, nested classes generalize abso-
lute functions in an interesting way. Figure 5a shows class
Bnested inside class A. Method mof class Bhas the absolute
function:
void m(A a, B b) { a.i = a.i + b.j; }
Although m()displays without parameters inside B, it re-
ally has two implicit parameters: this (of type B) and A:this
(of outer type A). We see that m()can be displayed as a mem-
ber of class Ausing our modularity perspective techniques
by making the Bparameter explicit. See Figure 5b.
A `coordinate transformation' interpretation also explains
why refactoring engines do not move methods of anony-
mous classes. Consider Figure 5c. The absolute function
of method phas signature p(A a ;?b), where ? denotes an
GUI builders. Neither are appropriate for a refactoring engine.
class A {
inti = 5;
class B {
intj = 4;
void m() {
i= i+ j;
}
}
} (a) (b)class A {
inti = 5;
void m(B b) {
i= i+ b.j;
}
class B {
intj = 4;
}
}void k(C c, A a) {
c.i= c.i+ a.j;
}
class A {
inti = 5;
void t() {
new B() {
intj = 4;
void p() {
i= i+ j;
}
};
}
} (c)Figure 5: Nested Classes.
anonymous subclass of B. Since ? has no name to display,
refactoring engines refuse to move p.
InR3, by creating a database of program elements and
their containment relationships, classical refactorings become
simple database modications and never alter the ASTs of
the target program. The AST is `absolute' or immutable; it
appears dierent relative to the modularity perspective from
which it is displayed. The move-instance-method refactor-
ing, which is what Figure 4 is about, is a coordinate transfor-
mation for software; it preserves the semantic properties of
a program. The same holds for other primitive refactorings.
3.2 The R3 Database
R3maintains an internal, non-persistent database to re-
cord changes in perspective. When R3parses compilation
units of a program, it creates relational database tables for
all declaration types in a program. Each tuple of the RClass
table represents a unique class declaration in the program.
Among RClass attributes is a pointer to the AST of that
class. Each tuple of the RMethod table represents a unique
method (or absolute function) declaration in the program.
Each RMethod tuple points to the AST of its method and to
the RClass tuple in which that method is a member. Sim-
ilarly, there are tables for package declarations ( RPackage),
eld ( RField), etc. There are no tables for Java executable
statements or expressions; only classes, interfaces, elds,
methods, and parameters, as these are the focus of Gang-of-
Four design patterns and almost all classical refactorings.
Program source is compiled into ASTs which are traversed
to populate R3tables. Figure 6 shows the basic set-up.
Three RClass tuples ( Graphic, Square, Picture) are created.
So too are four RMethod tuples ( Graphic. draw, Square. draw,
Picture. add, Picture. draw) that are linked to the RClass tu-
ple for which each is a member.
Refactorings update this database. Renaming a method
updates the name eld of that method's R3tuple. Moving
a method to another class updates the method's R3tuple
to point to its new class. Only when an AST is rendered
(displayed) is the information in the R3database revealed.
When a method's AST is displayed, the name of the method
is extracted from the method's R3tuple.
When a class is displayed, the tuples of the elds, meth-
ods, constructors, etc. that belong to it are extracted from
the database. The ASTs of these tuples are then displayed,
relative to their current class. Figure 7 sketches the RClass
display method: it prints the class keyword, the current
class name, extends clause with its superclass name, and
implements clause with interface name(s); all names obtained
from the database. Then each member that is assigned to
that class is displayed, following by the display of the closing
brace `g'.R3reproduces the original order in which members
appeared for ease of subsequent reference by programmers
and preserves all source code comments.
Rendering is fast and less involved than updating ASTs
1147class Graphic { 
void draw() { ‚Ä¶ }
}
class Square extends Graphic {
void draw() { ‚Ä¶ }
}
class Picture extends Graphic {
void add(Graphic g) { ‚Ä¶ }
void draw() { ‚Ä¶ }
}package
Square
drawPicture
draw addGraphic
drawùíÑùíêùíéùíëùíäùíçùíÜùíìSourceAbstract Syntax Tree
AST methID name args clsID
m1 draw { }
m2 add { c1}
m3 draw {}
m4 draw { }AST clsID name parent
c1 Graphic
c2 Square c1
c3 Picture c1
ùíïùíìùíÇùíóùíÜùíìùíîùíÇùíçRClass
RMethodDatabaseclass Graphic { 
void draw { ‚Ä¶ }
}
class Square extends Graphic {
void draw() { ‚Ä¶ }
}
class Picture extends Graphic {
void add(Graphic g) { ‚Ä¶ }
void draw() { ‚Ä¶ }
}Figure 6: R3Database.
and moving AST subtrees from one parent to another. Con-
sider the changes that are needed when absolute method foo
(Figure 4a) is moved from class BtoC. All invocations of
foo, such as b:foo(c; d), are altered to c:foo(b; d). A rendering
simply changes the order in which arguments are displayed;
it is more work to consistently update pointers when making
this change to an AST.
void display() {
ast.displayHeader ();
List<RMember> 
mlist= getMemberList ();
for (RMember m : mlist)
m.display ();
ast.displayFooter ();
}class A extends B 
implements I {
member1;
member2;
member3;
}
(b) Code that is displayed (a) Method to display an RClass tuple
class A<T> {
voidm(B b) {
T t = null;
}
} 
(a)Can‚Äôt move with
non-local type Tclass A {
<T> voidm(B b) { 
T t = null;
}
}
(b) Can move with 
local type T(c) Generic entity targetclass A {
<T> voidm(T t) {
}
}
Figure 7: RClass Display Method.
Typical refactoring engines modify ASTs. In contrast,
R3eliminates AST manipulation. R3still needs to create
ASTs when new program elements are needed, but other
than that, R3does not manipulate ASTs. As we report
later, a consequence of the above is that the codebase for R3
is much smaller and simpler than JDTRE.
3.3 Primitive Refactorings
We now explain some representative primitive refactorings
to see how they are implemented in R3. In the refactoring
community, behavior preservation is determined by stati-
cally analyzing whether the input code passes the refactor-
ing's preconditions [43]. If all preconditions are met, the
refactoring engine is allowed to change the program code.
We partition our discussion on refactorings into two seg-
ments: database changes corresponding to code transforma-
tions in conventional refactorings (considered in this section)
and precondition checks (discussed in the next section).
3.3.1 Rename Method
Rename-instance-method modies the name eld of the
method's RMethod tuple. This refactoring, like most, have
a database-transaction quality. Consider a class hierarchy
where all classes have their own method foo. To rename foo
tobarcan be expressed as a loop, where getRelatives ()nds
all overriding/overridden methods with the same signature
asfoo:
for (RMethod m : foo.getRelatives()) {
m.rename("bar");
}
Until the loop completes, not all methods are renamed
and preserving program semantics is not guaranteed. R3
performs renames on sets of overriding/overridden methodswith identical signatures, and by being a set operation, does
not expose an inconsistent database to users:
RRelativeList relatives = foo.getRelatives();
relatives.rename("bar");
3.3.2 Change Method Signature
Change-method-signature adds, removes, and reorders me-
thod parameters. Encoded in the R3database is a list of
formal parameters for every method. Adding a parameter
to a method simply adds the parameter and its default value
to the database. When the method is displayed, it is shown
with its new parameter; method calls are displayed with its
default argument.
Prior work [41, 54] found that highly-parameterized refac-
torings with options (name, parameter add/delete/reorder,
exception, delegate) discourage the use of refactorings and
make them harder to understand. Accordingly, R3has sepa-
rate methods to add, remove, and reorder parameters. Line 1
below nds the R3tuple for a eld with name fin class C
of package p. The eld's type serves as the type of the new
parameter and a reference to that eld is the parameter's
default value (Line 2). The new parameter, by default, be-
comes the last formal parameter of method m. Line 3 makes
it the rst parameter of method m:
1 RField v = RField . find ("p", "C", "f");
2 RParameter newParam = m. addParameter (v);
3 newParam . setIndex (0) ;
Like rename, addParameter has a set-based version.
3.3.3 Move Method via Parameter
The move-instance-method refactoring in R3changes the
home class of a method m. Recall that a home parameter is
any parameter of m, and a home class is the class of a home
parameter. Moving mto a home class simply updates m'sR3
tuple to point to the tuple of its home class. Presuming cis
a home class, the code below moves method mto the class c:
m.move(c);
3.3.4 Move Method via Field
The move-via-eld refactoring is illustrated in Figure 8.
Method min class A, whose absolute signature is C m(A a;B b),
is moved to class Dvia eld d. A local invocation, m(b),
becomes d:m(this; b). Here is where scripting comes in handy:
move-via-eld is the following R3script:
// member of RMethod class
void moveViaField(RField f) {
RParameter newHome = addParameter(f);
move(newHome);
}
1148class A  { 
D d;
C m(B b) {‚Ä¶}
‚Ä¶ m(b) ‚Ä¶ // a call
}
class D  { 
}class A  { 
D d;
‚Ä¶ d.m(this, b) ‚Ä¶ // a call
}
class D  { 
C m(A a, B b) {‚Ä¶}
}move
via 
field
void MoveViaField (RClassparameterType , RField? defaultValue ) {
addParameter (parameterType , defaultValue );
moveToClass (parameterType );
}Figure 8: Move via Field Refactoring.
3.3.5 Introducing New Program Elements
R3introduces complex new code declarations (classes, meth-
ods, elds, etc.) into an existing program by creating a com-
pilation unit with these declarations. The le is compiled
and the database is updated with new declarations which are
then embedded into the existing program via move refactor-
ings. The code below shows how to create a custom method
mul(), whose R3object is mth:
String s = "package pkg; \n"+
"class C { \n"+
" int mul() { return 7*57; }\n"+
"}";
RPackage p = RProject.getPackage("Prj", "pkg");
RCompilationUnit cu = p.createCU(s);
RClass cls = p.getClass("C");
RMethod mth = cls.getMethod("mul");
Once the needed methods and elds are removed from com-
pilation unit cu, the unit can be marked deleted in the
database using the R3remove refactoring. The AST of cure-
mains, but at pretty-printing time no text of its (now empty)
compilation unit is produced.
3.3.6 Scripting Refactorings
R3supports all refactorings that are essential to introduce
or remove design patterns from existing programs. R3's in-
terface is compatible with R2. That is, R2scripts port to
R3. This gives us the ability to script refactorings to retrot
design patterns into Java programs and we can build com-
pound refactorings as compositions of primitive refactor-
ings. We already saw scripts for makeAdapter (Figure 2),
makeVisitor (Figure 3), and moveViaField in Section 3.3.4.
3.4 Preconditions
Precondition checks are themajor performance drain in
refactoring engines. JDTRE is typical: it checks precondi-
tions as needed. Every refactoring call r() on an R3object
objrequires a conjunction of precondition checks obj: 1()^
obj: 2()^:::^obj: n() wherei() is a primitive precondi-
tion. For example, the JDT move-instance-method refactor-
ing has 19distinct checks (which are also present in R3); if
any one fails, the move is disallowed. Since JDTRE does not
know if a programmer will invoke obj:r(), JDTRE does the
obvious thing by evaluating obj: 1()^obj: 2()^:::^obj: n()
only when needed.
R3is dierent. We too do not know what refactorings
a programmer will invoke. But we can precompute the
value of many { not all { i()for all R3objects at database
build time, even though we may never use these values. For
eachi(), we add a boolean attribute to R3tables to indi-
cate whether a tuple's AST satises i(). The checks for
a refactoring then become a conjunction of these boolean
attributes.
The R3database is created by traversing the ASTs of
a program and collecting semantic information. Doing sopopulates the R3database with tuples and assigns boolean
values to these checks. Further, in cases where harvested
boolean values are insucient, we optimized the R3database
to facilitate fast searches, e.g., R3collects all references of a
declaration to reduce search overhead. We will see in Sec-
tion 5 these techniques improve performance signicantly.
3.4.1 Boolean Checks Made by a Single Tuple Lookup
InR3, fteen preconditions (which JDT move-instance-
method uses and are shared by other refactorings) are AST-
harvestable at database build time as boolean values. Here
is a representative sample:
Abstract { is the method abstract?
Native { is the method native?
Constructor { is the method a constructor?
Interface Declaring Type { is the enclosing type of the
method an interface ?
Non-Local Type Reference { if the method references
a non-local type parameter (e.g., a type parameter of
a generic class), it cannot be moved. Figure 9a illus-
trates a non-local type parameter which prevents a move
of method m. In contrast, method min Figure 9b can be
moved as its parameter is local.
void display() {
ast.displayHeader ();
List<RMembers > 
mlist= getMemberList ();
for (RMember m : mlist)
m.display ();
ast.displayFooter ();
}class A extends B 
implements I {
member1;
member2;
member3;
}
(b) Code that is displayed (a) Method to display an RClass tuple
class A<T> {
voidm(B b) {
T t = null;
}
} 
(a)Can‚Äôt move with
non-local type Tclass A {
<T> voidm(B b) { 
T t = null;
}
}
(b) Can move with 
local type T(c) Generic entity targetclass A {
<T> voidm(T t) {
}
}
Figure 9: Generic Constraints.
Generic Entity Target { moving a method via a type
parameter is disallowed (Figure 9c).
Unqualied Target { a natural home of a method can-
not be an interface . A natural home is disqualied if its
argument is assigned a value as in Figure 10a.
Null Home Value { if a method call has a null home
parameter as in Figure 10b, a move to that home is dis-
allowed as it will dereference null.
void m(D d) {
d = new D();
}void m(D d) {...}
... m(null) ... //call(a) (b)TargetConstraints
class A {
<T> voidm(B<T> b) {
T t= null;
}
}
class B<T> { }Duplicate type parameter
class A { }
class B<T> {
voidm() {
T t= null;
}
}move
Figure 10: Target Constraints.
Polymorphic Method { when the target method is poly-
morphic, it cannot be moved unless a delegate is left be-
hind. Our makeVisitor script satises this constraint.
Super Reference { JDTRE refuses to move any method
that uses the super keyword. To write general purpose
refactoring scripts, we removed this precondition in R2and
R3by replacing each super :x()call with a call to a super
delegate , a manufactured method super x()[35]. Other
IDEs, such as IntelliJ IDEA [30] and NetBeans [42], do
move such methods, but do so erroneously (Figure 11).
class C {
void m(A a) {
a.super.n ();
}
}class A extends B {
void m(C c) {
super.n();
}
}NetBeansclass C {
void m() {
super.n();
}
}IntelliJ IDEAmove
Method with super call
before after
class C {
void m(A a) {
a.super.n ();
}
}class A extends B {
void m(C c) {
super.n();
}
}
(c) NetBeansclass C {
void m() {
super.n();
}
}
(b) IntelliJ IDEAmove
(a) Method with super call
Figure 11: Super Call Bugs.
The remaining boolean checks are more of the same [34].
11493.4.2 Checks that Require Database Search
Not all primitive preconditions are reducible to boolean
attributes; these outliers require a database search, which R3
performs eciently. Here are some for the move-instance-
method:
Accessibility { after a method is moved, it must still
be visible to all of its references. Symmetrically, every
declaration that is referenced inside the method's body
should be accessible after the move. JDTRE promotes
access modiers of the moved method and/or referenced
declarations to satisfy all visibility requirements. R3does
the same.
Associated with each RMethod object mis a list of its refer-
ences (this list is collected at database creation time). R3
traverses this list to ensure that mis still visible to each
reference. Similarly, R3maintains a second list of tuples
(again collected at database creation time) that are refer-
enced in m's body. R3traverses this list to ensure that all
referenced declarations remain visible to m.R3makes the
same adjustments in modiers as JDTRE.
Conicting Method { a method can be moved only
when it does not change bindings of existing method ref-
erences. Consider the 3-class program of Figure 12. A
method call m(:::) inside B:n() invokes A:m(C). When JDTRE
moves method C:m(B) to class B, the method call changes
its binding to the newly moved method B:m(C).
class A {
void m(C c) { }
}class C {
void m(B b) { }
}class B extends A {
void n() {
m(null);
}
}binding change
class A {
void m(C c) { }
}class C {
void m(B b) { }
}class B extends A {
void n() {
m(...);
}
}binding change
Figure 12: Method Binding Change.
Clearly this is wrong. JDTRE determines if a conict
exists in the destination class but not its superclasses , an
error that we have reported [20]. R3does better by travers-
ing the class hierarchy and evaluating access modiers to
nd conicts [47].
Duplicate Type Parameter { JDTRE moves method
min Figure 13 to class Bonly when type parameter Tis
removed from msince Talready exists in class B. After the
move, however, Tinside method mchanges binding to the
existing Tin class B.
void m(D d) {
d = new D();
}void m(D d) {...}
... m(null) ... //call(a) (b)TargetConstraints
class A {
<T> voidm(B<T> b) {
T t= null;
}
}
class B<T> { }Duplicate type parameter
class A { }
class B<T> {
voidm() {
T t= null;
}
}move
Figure 13: Duplicate Type Parameter.
R3harvests type parameter names and stores them in the
database tuple where they are declared. R3searches the
type parameter collections to nd a match.
4. CURRENT R3 IMPLEMENTATION
JDTRE does not use a standard pretty-print AST method.
To minimize R3coding, we used a pipeline of tools, relying on
Eclipse minimally and using AHEAD [6], which has pretty-
print methods ideal for R3. Figure 14 shows the R3pipeline:
it is a series of stages (A)-(G) that map a target Java pro-
gram (JDT project) on the left to a refactored program on
the right.
Java 
programEclipse 
ASTs + 
Symbol 
table
AHEAD
ASTs
Java 
program‚ÄôRefactored
program(A)
(C)(B)
(D)(E)(F)
(G)R3DBR3DB with 
links to AHEAD ASTsR3DB with 
refactoring updates
Java 
programEclipse
ASTs + data
(A)(B)(E)(F)
(G)R3DBR3DB with 
links to ASTsR3DB with 
refactoring updatesFigure 14: R3Pipeline.
(A) Eclipse parses a Java program into ASTs. Below is a
target program with a generic method that prints its
array argument of dierent types:
package p;
class C {
// generic method
static <E> void print(E[] array) {
for(E e : array)
System.out.printf("\%s ", e);
}
}
(B) JDT ASTs are traversed to harvest a major part of the
R3database. Later, step (E) completes the database.
(C) AHEAD requires a context-free parser. To satisfy this
constraint, a version of the original program is output
(shown below) where white space and comments are
preserved and all identiers are replaced with manufac-
tured and unique identiers ID#; symbols\ <"and\ >"
that indicate generics are replaced with unambiguous
symbols \ <:" and \ :>". AHEAD can parse the revised
compilation unit:
package ID_0;
class ID_1 {
// generic method
static <:ID_2:> void ID_3(ID_4[] ID_5) {
for(ID_6 ID_7 : ID_8)
ID_9.ID_10.ID_11("\%s ", ID_12);
}
}
and with the database of (B) can reconstruct the iden-
tical text of the original program.
(D) AHEAD parses the manufactured-identier program.
(E) R3database tuples are doubly-linked to their AHEAD
AST nodes so each pretty-printer of an AST node can
reference the corresponding R3tuple and vice versa.
(F)R3refactorings are executed. They modify only the R3
database, not AHEAD parse trees.
(G) The source code of the refactored program is pretty-
printed as described earlier.
5. EVALUATION OF R3
To evaluate the usefulness of R3, we answer the following
research questions:
RQ1 (Performance): How fast is R3compared to JDTRE?
RQ2 (Correctness): Does R3improve the correctness of
the result when retrotting a design pattern?
RQ3 (Productivity): Does R3reduce the required time to
retrot a design pattern?
Previously, in [35], we evaluated the expressiveness of the
R3's predecessor, R2, by demonstrating that its scripts can
retrot design patterns into real-world programs. We fo-
cused on patterns that (a) were the hardest to manually
create and (b) executed the most JDT refactorings. We
used the same R2tests for R3, not only to show that R3is
1150Application
(Ver#, LOC, #Tests)Seed
ID# of
RefacsJDTRE time (seconds) R3time (seconds)Speed
UpPrecon PerformTotalBuild Link Precon DB ProjTotalCheck Change DB(B) AST (E) Check (F1) Update (F2) (G)
AHEAD
jak2java [6]
(130320, 26K, 75)A1 104 16.58 2.31 18.89 0.000 0.028 0.21 0.24 79
A2 68 18.49 2.67 21.16 0.010 0.010 0.11 0.13 163
A3 554 260.85 37.48 298.33 1.66 0.06 0.017 0.230 1.87 2.12 141
A4 60 14.69 3.70 18.39 0.001 0.032 0.54 0.57 32
A5 96 35.46 7.19 42.64 0.003 0.047 0.96 1.01 42
Commons
Codec [2]
(1.8, 16K, 6103)C1 6 1.80 1.39 3.19 0.000 0.007 0.41 0.42 8
C2 16 4.26 0.70 4.96 0.000 0.007 0.30 0.31 16
C3 16 3.60 0.30 3.90 1.18 0.03 0.000 0.007 0.24 0.24 16
C4 12 3.91 0.68 4.59 0.000 0.007 0.21 0.22 21
C5 6 1.51 0.50 2.00 0.000 0.005 0.37 0.37 5
Commons
IO [3]
(2.4, 24K, 810)I1 4 1.20 0.19 1.40 0.000 0.000 0.05 0.05 28
I2 4 2.21 0.20 2.40 0.000 0.002 0.08 0.08 31
I3 6 1.80 0.50 2.31 1.75 0.04 0.000 0.004 0.35 0.35 7
I4 4 2.70 0.30 3.00 0.000 0.002 0.07 0.07 42
I5 6 1.68 0.20 1.88 0.000 0.004 0.32 0.32 6
JUnit [32]
(4.11, 23K, 2807)J1 16 4.49 0.70 5.20 0.000 0.011 0.17 0.18 29
J2 4 0.31 0.09 0.40 0.000 0.004 0.05 0.05 8
J3 18 30.22 3.37 33.60 2.01 0.04 0.000 0.008 0.32 0.33 103
J4 20 8.10 1.40 9.49 0.000 0.011 0.44 0.45 21
J5 4 1.41 0.20 1.61 0.000 0.003 0.09 0.10 17
Quark [6]
(1.0, 575, 9)Q 16 3.40 0.40 3.80 0.24 0.01 0.000 0.009 0.09 0.10 40
Refactoring
Crawler [18]
(1.0.0, 7K, 15)W1 28 6.99 0.90 7.90 0.000 0.016 0.33 0.35 23
W2 4 1.80 0.30 2.10 0.000 0.004 0.12 0.12 17
W3 26 11.82 1.01 12.82 0.79 0.02 0.000 0.013 0.32 0.34 38
W4 10 4.11 1.10 5.21 0.000 0.007 0.19 0.20 26
W5 28 9.69 1.40 11.08 0.000 0.015 0.33 0.34 33
Table 2: Applications and Comparison with JDTRE and R3
similarly expressive and can handle the complexities of real-
world programs, but also to measure R3's performance w.r.t.
JDTRE { noting that JDTRE is representative of the state
of the practice in refactoring engines. In addition, in this pa-
per we also focus on practicality . Namely, can programmers
useR3eectively?
To answer these questions, we use a combination of two
empirical methods: a case study using 6 Java real-world
programs and user studies (with 44 undergraduates and 10
graduate students) that complement each other. The user
study allows us to quantify programmer time and program-
mer errors, while the case studies give more condence that
R3generalizes to real-world situations.
5.1 Performance
The rst column of Table 2 lists the programs of the R3
evaluation, along with their version, LOC, and number of
regression tests. We performed two sets of experiments.
The rst set of experiments retrotted a Visitor pattern
into six Java applications. The second set removed a Vis-
itor by executing an Inverse-Visitor script that exercises a
dierent set of refactorings. Inverse-Visitor does not simply
undo existing changes, but is a script that removes an in-
stance of a Visitor design pattern by moving visit methods
back to their original classes.2These experiments engage the
primitive refactorings that are used the most often in design
patterns. We ran the regression tests on each application
after script execution to conrm there was no dierence in
their behavior. We used an Intel CPU i7-2600 3.40GHz, 16
GB main memory, Windows 7 64-bit OS, and Eclipse JDT
4.4.2 (Luna) in our work.
Table 2 shows the performance results of the rst set of
experiments. Each program (with the exception of Quark)
has ve methods that serve as a Visitor seed. The com-
plexity of a refactoring task is measured by (1) the number
of JDT refactorings executed; this number is given in the
#of Refacs column3and (2) the CPU time listed in the
2Imagine the scenario that a programmer creates a Visitor to view
all declarations of a method min class hierarchy. S/he then edits
the methods of this Visitor. Simply \undoing" this Visitor rolls back
both the Visitor andher/his changes. An Inverse-Visitor refactoring
removes the Visitor andpreserves programmer changes [35].
3Our makeVisitor and inverseVisitor scripts create and delete pro-
gram elements but these operations are not counted as JDT refactor-
ings.Total column.4
JDTRE execution time has two parts, precondition checks
and code changes, whose sum equals column Total . Column
Precon Check is the time for all precondition checks discussed
in Section 3.4 and a check/parse to see if the compilation
units (Java les) involved in the refactoring are `broken' {
meaning that the le has syntax errors. Code change (col-
umn Perform Change) is the sum of times for calculating the
code changes to make, updating the Eclipse workspace, and
writing updated les to disk. Note : precondition checks in
JDTRE consume about 87% of refactoring execution time.
R3execution time covers six steps (B)-(G) in Figure 15.
Steps (C)-(D) are due to our use of AHEAD for coding con-
venience and would be unnecessary if JDTRE had usable
pretty-print methods. We exclude times for (C)-(D) as they
have nothing do with R3performance.
Eclipse 
ASTs + 
Symbol 
table
AHEAD
ASTs
Java 
program‚ÄôRefactored
program(C)(B)
(D)(E)(F1) + (F2)
(G)R3DBR3DB with 
links to AHEAD ASTsR3DB with 
refactoring updates
Figure 15: Performance Pipeline of R3.
A cost of R3is (B) creating the database and (E) linking
database tuples to AST nodes, shown as columns in Build DB
and Link AST in Table 2. These execution times are minus-
cule. During the brief interval that it takes to display the
R3GUI refactoring menu, a database can be created+linked
with an unnoticeable delay.
The true execution time for R3is (F1) checking precon-
ditions, (F2) updating databse, and (G) at the end of the
script execution pretty-printing the compilation units that
have changed. The sum of these numbers, the Total column,
isR3's run-time.
We compute the ratio of the JDTRE and R3Total columns,
listed in the Speed Up column. R3ranges from 5to163
faster than JDTRE. The longest JDTRE execution time was
4We used proling tool VisualVM (ver. 1:3:8) [57] to measure CPU
times in running the JDTRE and R3scripts. We repeated each ex-
periment ve times and report the average execution time.
1151seed A3to create a Visitor of 276methods, taking 298sec-
onds of CPU time. In contrast, R3's execution time was
2:2seconds. Interestingly, even if the number of refactor-
ings executed in a makeVisitor script are small ( 4 6),R3
was 17faster on average; for larger numbers of refactorings
(>50), the speed-up was 91faster. On average for these
experiments, R3was 38faster than JDTRE.5
Table 3 shows the corresponding run-times for our sec-
ond set of experiments that removed a Visitor. Although a
dierent set of refactorings are exercised, we reach similar
conclusions. R3ranges from 5to291 faster than JDTRE.
On average, R3was 55faster than JDTRE.6
Seed
ID# JDTRE time (seconds) R3time (seconds)Speed
Upof Prec PerfTotPrec DBProj TotRefa Chk Chg Chk Udt
A1 104 50.80 8.47 59.27 0.003 0.005 0.20 0.21 286
A2 68 27.19 5.10 32.29 0.001 0.006 0.10 0.11 291
A3 554 167.27 46.59 213.86 0.023 0.021 1.75 1.79 119
A4 60 9.98 5.78 15.76 0.008 0.006 0.53 0.55 29
A5 96 19.23 8.97 28.21 0.010 0.008 0.99 1.01 28
C1 6 1.59 0.70 2.29 0.001 0.001 0.43 0.43 5
C2 16 6.61 0.68 7.28 0.000 0.001 0.28 0.28 26
C3 16 7.10 0.40 7.50 0.000 0.001 0.23 0.23 33
C4 12 4.61 0.59 5.20 0.000 0.001 0.20 0.20 26
C5 6 1.70 0.59 2.29 0.000 0.001 0.35 0.35 6
I1 4 2.20 0.21 2.40 0.000 0.000 0.05 0.05 51
I2 4 2.22 0.30 2.52 0.000 0.000 0.07 0.07 35
I3 6 2.21 0.50 2.71 0.000 0.001 0.33 0.33 8
I4 4 1.99 0.20 2.19 0.000 0.000 0.06 0.06 34
I5 6 1.51 0.49 2.00 0.000 0.001 0.30 0.30 7
J1 16 4.75 0.99 5.74 0.000 0.002 0.26 0.27 22
J2 4 1.90 0.20 2.10 0.000 0.000 0.04 0.04 51
J3 18 11.60 0.69 12.28 0.001 0.001 0.31 0.31 39
J4 20 5.81 1.10 6.91 0.001 0.002 0.45 0.46 15
J5 4 2.78 0.21 2.98 0.000 0.000 0.09 0.09 34
Q 16 2.58 0.80 3.38 0.000 0.001 0.08 0.08 41
W1 28 6.28 1.79 8.07 0.002 0.002 0.33 0.33 25
W2 4 5.01 0.40 5.41 0.000 0.001 0.11 0.11 49
W3 26 21.19 1.52 22.71 0.000 0.002 0.31 0.31 74
W4 10 7.92 0.87 8.79 0.000 0.001 0.20 0.20 44
W5 28 15.74 1.68 17.42 0.001 0.002 0.33 0.33 53
Visitor Adapter
Metric Baseline R3 z p r Baseline R3 z p r
Success 39.5% 78.0% 3.441 0.001 0.519 54.5% 81.8% 3.207 0.001 0.483
Mean SD Mean SD Mean SD Mean SD
Score 73.5 24.8 93.5 13.6 3.629 0.000 0.547 96.0 5.2 97.9 5.1 2.315 0.021 0.349
Time 37.2 29.7 91.8 46.9 4.918 0.000 0.741 19.9 9.2 43.7 27.2 5.152 0.000 0.777
Table 4: Experimental Results from UT (44 undergrad students)
In the Visitor experiment, each student received a target
program, RefactoringCrawler [17], an open-source Eclipse
plugin. RefactoringCrawler has 119 Java classes, 17 inter-
faces and 7K LOC, including a suite of JUnit tests.
In the Ô¨Årst task, Group A wrote a general R3script to
make a Visitor, and applied this script to create a Visitor
with 13 methods given seed W1.Group B applied Eclipse
refactorings manually to make the same Visitor. In the sec-
ond task, (1) participants removed an existing Visitor with
12 methods from the target program, but from a diÔ¨Äerent
class hierarchy and (2) we Ô¨Çipped the control group: Group
Aapplied Eclipse refactorings manually and Group B wrote
and applied a general R3script.
In the Adapter experiment, Group A was required to write
a general R3script to make an Adapter that implements 35
methods, Group B created the same Adapter by hand as
JTDRE oÔ¨Äers no useful refactorings for this task. In the
second task, we Ô¨Çipped the control group and targeted a
diÔ¨Äerent Adapter of the same size.
We capped each task to 2 hours, although some partici-
pants extended this limit. Participants were not allowed to
take extended breaks but were free to abort after spending
the maximum time. Participants had to verify their work by
running the regression tests that came with RefactoringCraw -
ler.
Tasks were homework assignments. Participants had ac-
cess to classroom material and tool tutorials. To determine
participant success or failure, we analyzed their refactored
programs and R3scripts, ran the regression tests, and man-
ually inspected their code. Students also reported the time
they spent on each task and completed a follow-up survey.
5.2.2 Results
Tables 4 and 5 summarize the results we obtained from the
UT and OSU executions respectively. As Shapiro-Wilk tests
showed a signiÔ¨Åcant deviance from normality for score and
time, we resorted to non-parametric Wilcoxon signed-rank
tests for all the analyses. Both tables present the percentageV
isitor
Me
tric B
aseline R3 z p r
S
uccess 2
0.0% 7
0.0% 2
.236 0
.025 0
.707
Me
an S
D Me
an S
D
S
core 5
6.0 3
9.2 9
1.0 1
2.9 2
.176 0
.030 0
.688
T
ime 6
6.6 3
8.3 9
2.1 3
7.7 2
.075 0
.038 0
.656
Table 5: Experimental Results from OSU (10 grad students)
of successful submissions, means and standard deviations for
the score they obtained, and time spent. Tables also show
the test result ( z), its corresponding pvalue and the eÔ¨Äect
size ( r) in the cases where statistically signiÔ¨Åcant diÔ¨Äerences
were found between both methods (p <0.05).
Results are consistent in both executions. For RQ2 (Cor-
rectness), we found statistically signiÔ¨Åcant diÔ¨Äerences that
favor R3in both success and score in both UT and OSU.
Moreover, the eÔ¨Äect size introduced by R3was large ( r>
0.5) for the Visitor experiment and medium ( r>0.3) for
the Adapter experiment, showing that R3has a signiÔ¨Åcant
impact on success and score rates. We hypothesize that even
greater beneÔ¨Åts for R3accrue when the complexity of a pat-
tern (i.e., the types and numbers of required refactorings)
increases. More on RQ2 in Section 5.3.
ForRQ3 (Productivity), results show statistically signif-
icant diÔ¨Äerences that favor using JDT refactorings in the
required time to apply the design pattern. EÔ¨Äect sizes are
large in all cases. In other words, for this experiment and
design pattern instances , it was faster to manually invoke
JDT refactorings than to write an R3 script from scratch
(however, once a script is written, it can be reused many
times). More on RQ3 in Section 5.3.
Clearly students can write R3scripts. In a follow-up poll,
91% of them said that writing ( R3) refactoring scripts would
be a useful addition to their IDE and 79.5% said that writ-
ing scripts improved their understanding of the Visitor and
Adapter patterns. Their response was gratifying as it sup-
ported primary motivation for our research.
R3and more details about our empirical evaluation can
be downloaded at [42].
Table 3: Inverse-Visitor Results.
There are three basic reasons for the huge dierence in
performance. First, as mentioned earlier, JDTRE evaluates
preconditions by searching ASTs, and piggy-backs the col-
lection of information to know what text changes to make
to perform an actual refactoring, such as creating a method
delegate, adjusting declaration visibility, etc. Proling ex-
periments indicate that the vast majority of time ( avg: 60%,
sd:15%) of the Precon Check column for JDTRE is simply
due to AST searching. R3reduces the overhead by collect-
ing all program elements and values needed for precondition
checks or code transformation in advance.
Second, the R3database has been optimized to make nor-
mally slow operations lightning fast. One such operation is
the rebinding of all references to one declaration to those
of another (Figure 16a). The move-and-delegate refactoring
is an example. Following the `one-fact-in-one-place' mantra
of database normalization, R3introduced an RBinding table
where declaration bindings are represented once and with
one update, all references are rebound (Figure 16b).
class A {
<T> voidm(B<T> b) {
}
}
class B<T> {
}class A {
inti;
class B {
void m(C c) {
i=0;
}
}
}
ref1
ref3ref2dec1
dec2slow
updateref1
ref3ref2dec1
dec2
(a)
ref1
ref3ref2bind1 dec1
fast
updateref1
ref3ref2bind1 dec1
(b)dec2 dec2
Figure 16: Reference Binding in R3.
Third, JDTRE parses all les involved in a refactoring
and writes out changed les after each refactoring. In con-
5Had we included database creation time for steps (B) and (E) in our
calculations, the average speed-up ratio drops to 11.
6Had we included database build time for steps (B) and (E) in our
calculations, the average speed-up ratio drops to 10.trast, R3refactorings are virtually instantaneous database
updates. Projection (i.e., writing out changed les) is per-
formed only once after the script execution is nished.
In short, JDTRE was not designed for ecient scripting.
5.2 Practicality
We conducted an evaluation of R3's practicality. We de-
signed two controlled experiments (the Adapter experiment
and the Visitor experiment) to assess how users worked with
R3. We ran the experiments with 44students in Spring 2015
at the undergraduate CS373S Software Design [49] course at
the University of Texas at Austin. The course exposes stu-
dents to fundamental structures and concepts in software de-
velopment, with an emphasis on automation. Two lectures
were devoted to refactoring and seven more were dedicated
to design patterns.
We ran another Visitor experiment with 10students in Fall
2014 at the graduate CS561 Advanced Software Engineer-
ing [1] course at the Oregon State University. This course
exposes students to seminal topics and recent trends in soft-
ware evolution; in particular automating common changes
to improve software quality. Results from both executions
were consistent.
5.2.1 Experimental Design
We had two dependent variables : correctness and time.
Correctness was rst measured as a boolean metric: either
the result was correct or not. We also used a score that
measured the degree of correctness ( 0meant nothing had
been done to the existing code, and 100meant the pattern
had been correctly introduced). Time was measured in min-
utes. The only independent variable was the method used to
retrot the pattern (i.e., R3scripts vs. using available JDT
refactorings or manual edits).
As an approximation, the complexity of a pattern instance
is the number of refactorings that must be applied to pro-
duce the instance. There is clearly more: programmers must
order refactorings in a proper sequence to achieve the de-
sired result. In any case, creating and removing Visitor
and Adapter pattern instances require sequences of refac-
torings of dierent length using dierent sets of primitive
refactorings. We believe both are representative of refactor-
ing scripts that programmers can (or would like to) apply.
Based on these patterns, we designed two separate exper-
iments: one for Visitor and another for Adapter. To coun-
teract the impact of the order of the method participants
used, we counterbalanced it. Each experiment consisted of
two tasks. Group A performed the rst task using R3and
the second using the available JDT refactorings; Group B
did in the opposite order. Further, we balanced Group A
and Group B w.r.t. their backgrounds, using information
that students provided in a survey at the beginning of the
course.
To ensure uniform knowledge among participants, each
participant read and practiced online tutorials to:
make and remove a Visitor and Adapter manually [35],
write and run R3scripts, and
apply JDT refactorings such as rename, move, and change-
method-signature, with an explanation of their options.
Students submitted practice assignments (code and scripts);
only when they passed the tutorial assignments could they
proceed to the real experiment.
1152Visitor Adapter
Metric Baseline R3 z p r Baseline R3 z p r
Success 39.5% 78.0% 3.441 0.001 0.519 54.5% 81.8% 3.207 0.001 0.483
Mean SD Mean SD Mean SD Mean SD
Score 73.5 24.8 93.5 13.6 3.629 0.000 0.547 96.0 5.2 97.9 5.1 2.315 0.021 0.349
Time 37.2 29.7 91.8 46.9 4.918 0.000 0.741 19.9 9.2 43.7 27.2 5.152 0.000 0.777
Table 4: Experimental Results from UT (44 undergrad students)
In the Visitor experiment, each student received a target
program, RefactoringCrawler [18], an open-source Eclipse
plugin. RefactoringCrawler has 119 Java classes, 17 inter-
faces and 7K LOC, including a suite of JUnit tests.
In the rst task, Group A wrote a general R3script to
make a Visitor, and applied this script to create a Visitor
with 13 methods given seed W1.Group B applied Eclipse
refactorings manually to make the same Visitor. In the sec-
ond task, (1) participants removed an existing Visitor with
12 methods from the target program, but from a dierent
class hierarchy and (2) we ipped the control group: Group
Aapplied Eclipse refactorings manually and Group B wrote
and applied a general R3script.
In the Adapter experiment, Group A was required to write
a general R3script to make an Adapter that implements 35
methods, Group B created the same Adapter by hand as
JTDRE oers no useful refactorings for this task. In the
second task, we ipped the control group and targeted a
dierent Adapter of the same size.
We capped each task to 2 hours, although some partici-
pants extended this limit. Participants were not allowed to
take extended breaks but were free to abort after spending
the maximum time. Participants had to verify their work by
running the regression tests that came with RefactoringCraw -
ler.
Tasks were homework assignments. Participants had ac-
cess to classroom material and tool tutorials. To determine
participant success or failure, we analyzed their refactored
programs and R3scripts, ran the regression tests, and man-
ually inspected their code. Students also reported the time
they spent on each task and completed a follow-up survey.
5.2.2 Results
Tables 4 and 5 summarize the results we obtained from the
UT and OSU executions respectively. As Shapiro-Wilk tests
showed a signicant deviance from normality for score and
time, we resorted to non-parametric Wilcoxon signed-rank
tests for all the analyses. Both tables present the percentage
of successful submissions, means and standard deviations for
the score they obtained, and time spent. Tables also show
the test result ( z), its corresponding pvalue and the eect
size ( r) in the cases where statistically signicant dierences
were found between both methods (p <0:05).
Results are consistent in both executions. For RQ2 (Cor-
rectness), we found statistically signicant dierences that
favor R3in both success and score in both UT and OSU.
Moreover, the eect size introduced by R3was large ( r>
0:5) for the Visitor experiment and medium ( r>0:3) for
the Adapter experiment, showing that R3has a signicant
impact on success and score rates. We hypothesize that even
greater benets for R3accrue when the complexity of a pat-
tern (i.e., the types and numbers of required refactorings)
increases. More on RQ2 in Section 5.3.
ForRQ3 (Productivity), results show statistically signif-
icant dierences that favor using JDT refactorings in the
required time to apply the design pattern. Eect sizes areV
isitor
Me
tric B
aseline R3 z p r
S
uccess 2
0.0% 7
0.0% 2
.236 0
.025 0
.707
Me
an S
D Me
an S
D
S
core 5
6.0 3
9.2 9
1.0 1
2.9 2
.176 0
.030 0
.688
T
ime 6
6.6 3
8.3 9
2.1 3
7.7 2
.075 0
.038 0
.656
Table 5: Experimental Results from OSU (10 grad students)
large in all cases. In other words, for this experiment and
design pattern instances , it was faster to manually invoke
JDT refactorings than to write an R3 script from scratch
(however, once a script is written, it can be reused many
times). More on RQ3 in Section 5.3.
Clearly students can write R3scripts. In a follow-up poll,
91% of them said that writing ( R3) refactoring scripts would
be a useful addition to their IDE and 79:5% said that writ-
ing scripts improved their understanding of the Visitor and
Adapter patterns. Their response was gratifying as it sup-
ported primary motivation for our research.
R3and more details about our empirical evaluation can
be downloaded at [45].
5.2.3 Threats to Validity
Every user study has limitations. First, although our re-
sults were comparable with undergraduate and graduate stu-
dents, the results might not be translatable to more experi-
enced programmers. Second, there might have been control
loss due to the tasks being homework assignments. This was
unavoidable considering the course design. The problem of
reconciling classroom objectives and experimental designs
has been largely recorded in the literature [7, 23]. Lastly,
students were aware that R3was developed by their instruc-
tors and, while we asked for their honest answers and were
careful not to inuence them on this point, this might have
impacted the results.
5.3 Perspective
0.00.10.20.30.40.50.60.70.80.91.0
0 10 20 30 40 50 60 70 80Probability of Failure
# of Refactorings Performed          
(a)  Probability of Failure050100150200250300350400
012345678910Time Spent in Minutes
# of Different Applications of Scriptmanual
R3
(b)  Effort Expended with Reuse
0.00.10.20.30.40.50.60.70.80.91.0
0 10 20 30 40 50 60 70 80Probability of Failure
# of Refactorings Performed          050100150200250300350400
012345678910Time Spent in Minutes
# of Different Applications of Scriptmanual
R3
Figure 17: Probability of Failure.There are at least
two dimensions that
are not captured
by our user study.
There is a non-zero
probability ethat
each manually per-
formed refactoring
will be erroneous.
Assuming Bernoulli
trials, Figure 17
shows the probabil-
ityP= (1 (1 e)n)
that one or more er-
rors will occur in a manual retrot of a design pattern re-
quiring nrefactorings. From Table 2 row W1, the value of
nis28. From Table 4, the value of Pis1 0:395 =0:605.
Solving 0:605 = (1 (1 e)28) yields e=1=30:6. That is,
our students made an error, on average, every 30:6 manual
refactorings. The dashed vertical lines in Figure 17 and Fig-
ure 18 indicate the point on this graph that corresponds to
1153our user study. Figure 17 predicts the results of additional
future user studies on RQ2 . As refactoring tasks become
more complicated, R3wins easily; it can perform tasks cor-
rectly that humans can not.
0.00.10.20.30.40.50.60.70.80.91.0
0 10 20 30 40 50 60 70 80Probability of Failure
# of Refactorings Performed          
(a)  Probability of Failure050100150200250300350400
012345678910Time Spent in Minutes
# of Different Applications of Scriptmanual
R3
(b)  Effort Expended with Reuse
0.00.10.20.30.40.50.60.70.80.91.0
0 10 20 30 40 50 60 70 80Probability of Failure
# of Refactorings Performed          050100150200250300350400
012345678910Time Spent in Minutes
# of Different Applications of Scriptmanual
R3
Figure 18: Error Expended with
Script Reuse.A second dimen-
sion is time spent
per refactoring task/
script. We gave
students only 1man-
ual refactoring task
in our evaluation
ofRQ3 . The
real benet is when
a design pattern
script is reused. Fig-
ure 18 shows that
the break-even point
of writing a script
rather than manual
pattern construction is on its third use. R3wins easily on
further reuse.
5.4 Other Relevant Observations on R3
R3uses the same or improved precondition denitions
as JDTRE; these denitions are well-documented in the
JDTRE code base. We extracted from the JDTRE regres-
sion suite ( org:eclipse:jdt:ui:tests :refactoring [44]) tests that
are relevant to R3refactorings. We excluded tests on Java
8 features (e.g., lambda expressions), as R3presently works
onJava Runtime Environment (JRE) 7. There were 122
tests for change-method-signature, 72for move-method, 73
for pull-up, 59for push-down, and 138for rename. R3sat-
ises all 464extracted tests; they are now part of the R3
regression suite.7Further, in building R2andR3, we discov-
ered and reported 31bugs in the JDTRE, 7of which have
now been corrected [21].
Comparing the size of R3to JDTRE in LOC is misleading,
as JDTRE relies on layers of Eclipse functionality, whereas
R3is self-contained. To level the playing eld, we used the
EcLEmma code coverage tool [29] to see what volume of code
was executed by JDTRE and R3when the makeVisitor script
runs { this gives us an estimate of the number of Unique
LOC (ULOC) executed for equivalent functionalities.
R3executes 1;782ULOC for makeVisitor. But these ULOC
are self-contained, meaning that print, le open and close
methods are its only external calls. In contrast, JDTRE
executes 1;050ULOC, which in turn calls 1;691ULOC in
ltk:core:refactoring (the primary package for JDTRE) and
975ULOC in ltk:ui:refactoring where other core refactor-
ing functionality resides.8We conservatively estimate R3's
codebase to be 2simpler than JDTRE.
6. RELATED WORK
We said earlier that R3was inspired by elementary physics.
Another inspiration was Intentional Programming (IP) [14].
IP is a structure editor whose ASTs could be adorned with
dierent pretty-print methods, allowing the contents of an
7R3does not produce exactly the same refactored source as JDTRE.
For example, R3keeps track of moved methods. All type declarations
in these methods are displayed with fully qualied names so that
additional import declarations do not need to be added.
8Example: see checkInitialConditions, checkFinalConditions, and
createChange methods in MoveInstanceMethodProcessor.java [40]AST to be printed textually or graphically. R3isnota
structure editor or a small tweak on IP. IP displays entire
trees; R3integrates a database of program facts and the
display of disconnected ASTs to yield a rendering that gives
the appearance of a single refactored program.
In developing R2[35], we found 13prior works [4, 9, 11, 12,
13, 15, 28, 37, 39, 50, 53, 55, 56] that could be used to im-
plement refactoring scripts. We classied them as program
transformation systems, DSLs, and refactoring engines built
atop of IDEs. Notably none reported performance of refac-
toring engines; all were demonstrations that their particular
infrastructure or tool could be used to implement refactor-
ings or transformation scripts. Most research on refactoring
engines mentions the importance of refactoring reliability
or error detection [16, 26, 31, 36, 48]. See [35] for further
details.
A critical property of R2and R3is that refactorings and
refactoring scripts are written in the same language as the
programs to be transformed (e.g., Java). We feel this prop-
erty is crucial because programmers do not have to learn yet
another language or programming paradigm to write refac-
toring scripts. Surprisingly, only one prior tool had this
property: Wrangler [36]. Wrangler refactorings and refac-
toring scripts were written in Erlang to modify Erlang pro-
grams.
7. CONCLUSIONS AND FUTURE WORK
OO refactoring technology is now 25years old [27, 46].
Most researchers, ourselves included, tacitly assume that
few signicant advances in tooling classical Java refactorings
are possible after this time. But looking closer, motivated
by new needs and applications for refactoring, reveals that
signicant practical advances are not only possible but are
necessary.
We showed how classical Java refactorings (e.g., move,
rename, change-method-signature) and refactorings that are
essential to script the creation and removal of Gang-of-Four
design patterns, can be implemented by a novel combination
of databases and AST pretty-printing. Our tool R3:
1. does not rely on a huge codebase required by general-
purpose program transformation systems,
2. has a much smaller code footprint than JDTRE,
3. supports the writing and execution of refactoring scripts,
4. executes refactoring scripts 10faster than JDTRE,
and
5. signicantly improves correctness when retrotting de-
sign patterns in a user study.
Having said the above, R3in no way eliminates the need
for general-purpose program transformation systems. There
are many refactorings that are not used in scripting design
patterns [8, 22] and there are many refactorings that can-
not simply be\pretty-printed", such as refactoring sequential
legacy code into parallel code [17]. Never-the-less, standard
OO refactoring engines leave a lotto be desired { slow speed,
no support for scripting, and overly complex code bases. Our
response is: let's do the basics better and to provide script-
ing for the vast majority of programmers, which we believe
is critical to next-generation OO refactoring engines. For
these reasons, R3oers a promising way forward.
Acknowledgments. We gratefully acknowledge support
for this work by NSF grants CCF-1212683 and CCF-1439957.
11548. REFERENCES
[1] Advanced Software Engineering (CS561) Course at
the Oregon State University. http:
//classes.engr.oregonstate.edu/eecs/fall2014/cs561/.
[2] Apache Commons Codec. https:
//commons.apache.org/proper/commons-codec/.
[3] Apache Commons IO.
https://commons.apache.org/proper/commons-io/.
[4] E. Balland, P. Brauner, R. Kopetz, P.-E. Moreau, and
A. Reilles. Tom: Piggybacking Rewriting on Java. In
RTA, 2007.
[5] D. Batory, E. Latimer, and M. Azanza. Teaching
Model Driven Engineering from a Relational Database
Perspective. In MODELS, 2013.
[6] D. Batory, J. Sarvela, and A. Rauschmayer. Scaling
Step-Wise Renement. IEEE TSE , June 2004.
[7] M. Baughman. The Inuence of Scientic Research
and Evaluation on Publishing Educational
Curriculum. New Directions for Evaluation ,
117:85{94, 2008.
[8] G. Bavota, B. D. Carluccio, A. D. Lucia, M. D. Penta,
R. Oliveto, and O. Strollo. When Does a Refactoring
Induce Bugs? An Empirical Study. SCAM, 2012.
[9] I. D. Baxter, C. Pidgeon, and M. Mehlich. DMS:
Program Transformations for Practical Scalable
Software Evolution. In ICSE, 2004.
[10] K. Beck and C. Andres. Extreme Programming
Explained: Embrace Change (2nd Ed.) .
Addison-Wesley, 2004.
[11] M. Boshernitsan and S. L. Graham. iXj: Interactive
Source-to-Source Transformations for Java. In
OOPSLA Companion , 2004.
[12] J. Brant and D. Roberts. The SmaCC Transformation
Engine: How to Convert Your Entire Code Base into a
dierent Programming Language. In OOPSLA
Companion , 2009.
[13] M. Bravenboer, K. T. Kalleberg, R. Vermaas, and
E. Visser. Stratego/XT 0.17. A Language and Toolset
for Program Transformation. Science of Computer
Programming, June 2008.
[14] S. C. Charles Simonyi, Magnus Christerson.
Intentional Software. In ONWARD! OOPSLA , 2006.
[15] J. R. Cordy. The TXL Source Transformation
Language. Science of Computer Programming , Aug.
2006.
[16] B. Daniel, D. Dig, K. Garcia, and D. Marinov.
Automated Testing of Refactoring Engines. In
ESEC-FSE , 2007.
[17] D. Dig. A Refactoring Approach to Parallelism. IEEE
Software, Jan 2011.
[18] D. Dig, C. Comertoglu, D. Marinov, and R. Johnson.
Automated Detection of Refactorings in Evolving
Components. In ECOOP, 2006.
[19] Eclipse Bug 217753. https:
//bugs.eclipse.org/bugs/shown bug.cgi?id=217753.
[20] Eclipse Bug 467019. https:
//bugs.eclipse.org/bugs/shown bug.cgi?id=467019.
[21] JDT Refactoring Bugs. http://www.cs.utexas.edu/
~jongwook/r2/jdtrefactoringbugs.html.
[22] M. Fowler, K. Beck, J. Brant, W. Opdyke, and
D. Roberts. Refactoring: Improving the Design ofExisting Code . Addison-Wesley, 2000.
[23] J. R. Fraenkel and N. E. Wallen. How to Design and
Evaluate Research in Education . McGraw-Hill, 2009.
[24] L. Frenzel. The Language Toolkit: An API for
Automated Refactorings in Eclipse-based IDEs.
http://www.eclipse.org/articles/Article-LTK/ltk.html.
[25] E. Gamma, R. Helm, R. Johnson, and J. Vlissides.
Design patterns: Elements of Reusable
Object-Oriented Software. Addison-Wesley, 1995.
[26] M. Gligoric, F. Behrang, Y. Li, J. Overbey, M. Haz,
and D. Marinov. Systematic Testing of Refactoring
Engines on Real Software Projects. In ECOOP, 2013.
[27] W. G. Griswold. Program Restructuring as an Aid to
Software Maintenance. PhD thesis, University of
Washington, 1991.
[28] M. Hills, P. Klint, and J. J. Vinju. Scripting a
Refactoring with Rascal and Eclipse. In WRT , 2012.
[29] M. R. Homann. EclEmma 2.3.2.
http://www.eclemma.org, 2014.
[30] IntelliJ IDEA 14.1.2. http://jetbrains.com/idea/.
[31] W. Jin, A. Orso, and T. Xie. Automated Behavioral
Regression Testing. In ICST , 2010.
[32] JUnit. http://junit.org/.
[33] J. Kerievsky. Refactoring to Patterns . Addison-Wesley,
2006.
[34] J. Kim. Refactoring by Pretty-Printing . PhD thesis,
University of Texas at Austin, forthcoming.
[35] J. Kim, D. Batory, and D. Dig. Scripting Parametric
Refactorings in Java to Retrot Design Patterns. In
ICSME, 2015.
[36] H. Li and S. Thompson. Implementation and
Application of Functional Languages . Springer-Verlag,
2008.
[37] H. Li and S. Thompson. A Domain-Specic Language
for Scripting Refactorings in Erlang. In FASE , 2012.
[38] R. C. Martin. Agile Software Development: Principles,
Patterns, and Practices . Prentice Hall, 2003.
[39] T. Mens and T. Tourwe. A Declarative Evolution
Framework for Object-Oriented Design Patterns. In
ICSM , 2001.
[40] MoveInstanceMethodProcessor.java.
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/plain/
org.eclipse.jdt.ui/core%20refactoring/org/eclipse/jdt/
internal/corext/refactoring/structure/
MoveInstanceMethodProcessor.java.
[41] E. Murphy-Hill, C. Parnin, and A. P. Black. How We
Refactor, and How We Know It. In ICSE, 2009.
[42] NetBeans 8.0.2. https://netbeans.org/.
[43] B. Opdyke. Refactoring Object-Oriented Frameworks .
PhD thesis, University of Illinois at
Urbana-Champaign, 1992.
[44] org.eclipse.jdt.ui.tests.refactoring.
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/tree/org.
eclipse.jdt.ui.tests.refactoring/.
[45] R3 Download and Empirical Data.
http://www.cs.utexas.edu/users/jongwook/r3/.
[46] D. Roberts. Practical Analysis for Refactoring . PhD
thesis, University of Illinois at Urbana-Champaign,
1999.
[47] M. Sch afer, A. Thies, F. Steimann, and F. Tip. A
Comprehensive Approach to Naming and Accessibility
1155in Refactoring Java Programs. IEEE TSE , Nov. 2012.
[48] G. Soares, R. Gheyi, and T. Massoni. Automated
Behavioral Testing of Refactoring Engines. IEEE
TSE, Feb. 2013.
[49] Software Design (CS373S) Course at the University of
Texas at Austin.
http://www.cs.utexas.edu/users/dsb/CS373S/.
[50] F. Steimann, C. Kollee, and J. von Pilgrim. A
Refactoring Constraint Language and its Application
to Eiel. In ECOOP, 2011.
[51] F. Steimann and J. von Pilgrim. Constraint-Based
Refactoring with Foresight. In ECOOP, 2012.
[52] L. Tokuda and D. Batory. Evolving Object-Oriented
Designs with Refactorings. In ASE, 1999.
[53] M. Toomim, A. Begel, and S. L. Graham. ManagingDuplicated Code with Linked Editing. In VLHCC ,
2004.
[54] M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar,
B. P. Bailey, and R. E. Johnson. Use, Disuse, and
Misuse of Automated Refactorings. In ICSE, 2012.
[55] M. van den Brand, A. van Deursen, J. Heering,
H. de Jong, M. de Jonge, T. Kuipers, P. Klint,
L. Moonen, P. Olivier, J. Scheerder, J. Vinju,
E. Visser, and J. Visser. The ASF+SDF
Meta-environment: A Component-Based Language
Development Environment. In CC, 2001.
[56] M. Verbaere, R. Ettinger, and O. de Moor. JunGL: a
Scripting Language for Refactoring. In ICSE, 2006.
[57] VisualVM 1.3.8. http://visualvm.java.net/.
1156