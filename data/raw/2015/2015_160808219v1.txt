NOFAQ: Synthesizing Command Repairs from Examples
Loris Dâ€™Antoni
University of Wisconsin-Madison
loris@cs.wisc.eduRishabh Singh
Microsoft Research
risin@microsoft.comMichael Vaughn
University of Wisconsin-Madison
vaughn@cs.wisc.edu
Abstract
Command-line tools are confusing and hard to use for novice pro-
grammers due to their cryptic error messages and lack of docu-
mentation. Novice users often resort to online help-forums for ï¬nd-
ing corrections to their buggy commands, but have a hard time in
searching precisely for posts that are relevant to their problem and
then applying the suggested solutions to their buggy command.
We present a tool N OFAQ that uses a set of rules to suggest
possible ï¬xes when users write buggy commands that trigger com-
monly occurring errors. The rules are expressed in a language
called F IXIT and each rule pattern-matches against the userâ€™s buggy
command and the corresponding error message, and uses these in-
puts to produce a possible ï¬xed command. Our main contribution
is an algorithm based on lazy VSA for synthesizing F IXIT rules
from examples of buggy and repaired commands. The algorithm
allows users to add new rules in N OFAQ without having to man-
ually encode them. We present the evaluation of N OFAQ on 92
benchmark problems and show that N OFAQ is able to instantly
synthesize rules for 81 benchmark problems in real time using just
2 to 5 input-output examples for each rule.
1. Introduction
Command-Line Interfaces (CLI) let users interact with a comput-
ing system by writing sequences of commands. CLIs are especially
popular amongst advanced computer users, who use them to per-
form small routine tasks such as committing a ï¬le to a reposi-
tory with version control, installing software packages, compiling
source code, ï¬nding and searching for ï¬les etc. Even though this
mode of interaction is getting replaced by more natural graphical
user interfaces, CLIs are still routinely used for most scripting tasks
in Unix and Mac OS. Even the Windows operating system now of-
ï¬cially provides complex command-line interfaces with products
such as Windows Powershell.
Since command-line interactions often require complex param-
eters and ï¬‚ag settings for specifying the desired intent, non-expert
users ï¬nd CLIs challenging to use [3]. Moreover, after entering an
incorrect input command, the user has to deal with cryptic errors
that are hard to decipher by just looking at the verbose text-based
documentation of the commands. For these reasons, users typi-
cally resort to online help-forums for ï¬nding corrections to their
buggy commands. Unfortunately, this can also be problematic as
users need to precisely search for posts that relate to the issues with
their commands and then transform the suggested solutions to ap-
ply them in their context. Sometimes users also need to create a
new post if no relevant post exists (or can be found), and then need
to wait for hours or days to obtain a solution to their problem.
What about common errors? Recently, a tool T HEFXXX1was
developed for automatically addressing common errors when work-
1We decided to censor the name of the tool. The tool can be found at
http://bit.ly/CmdCorrection .ing with a CLI. If after typing a command a user receives an error
message, T HEFXXX uses a set of hard-coded rules to suggest possi-
ble ï¬xes to the userâ€™s command. Each rule pattern-matches against
the input command and the error message, and uses these inputs
to produce a possible ï¬xed command. Typical ï¬xes include adding
missing ï¬‚ags, creating a missing directory, or changing ï¬le exten-
sions. T HEFXXX has become extremely popular and, on GitHub, it
has already been starred by more than 20,000 users and has been
forked more than 1000 times. Despite its success, the tool also has
a main limitation: to add a new rule a developer ï¬rst needs to un-
derstand the syntax and precise semantics of T HEFXXX and then
manually hard-code the rule into the tool. Due to this complexity,
newly added rules have at times caused non-terminating or unex-
pected behaviors2.
Synthesizing repairs from examples Inspired by the success and
limitations of T HEFXXX, we built N OFAQ (No more Frequently
Asked Questions), a tool for automatically addressing common
errors in CLIs. N OFAQ also uses a set of rules for ï¬xing common
errors, but it differs from T HEFXXX in the following key aspects:
1. Rules are encoded in a declarative domain-speciï¬c language
(DSL) called F IXIT.
2. To add new rules, users only provide examples of buggy and
repaired commands and N OFAQ automatically synthesizes the
desired F IXIT rules that are consistent with the given examples.
We envision N OFAQ system being used by non-developers and
end-users, who can easily extend the system by providing new
examples of ï¬xes. The long-term goal of the system is to learn from
examples obtained from shell histories of thousands of users in an
unsupervised manner. Although a developer can write similar rules
in a system like T HEFXXX manually, there are two main challenges
with doing so. First, it is not feasible to easily add thousands
of rules as end-users generally do not have contributor access to
THEFXXXâ€™s source code. Second, even for developers, writing
correct rules is difï¬cult and error-prone because of the complexity
of the string manipulations needed to perform the command ï¬xes.
In fact, T HEFXXX only consists of less than 100 rules in a little
over 1 year, since adding new ones is a fairly complex task.
The F IXIT DSL for encoding ï¬x rules is inspired by the types
of rules appearing in T HEFXXX and by common command repairs
requested by users on help-forums. A F IXIT rule ï¬rst uses pattern
matching and uniï¬cation to match the command and error mes-
sage, and then applies a ï¬x transformation if the match succeeds.
The transformations consist of substring and append functions on
strings present in the command and error message.
We present an algorithm that efï¬ciently synthesizes F IXIT rules
that are consistent with a given set of input-output examples using
a Version-space Algebra (VSA). VSA-based synthesis techniques
are used to succinctly represent the set of all expressions that are
2http://bit.ly/1j7zxOr andhttp://bit.ly/1YgngXJ .
1 2018/10/14arXiv:1608.08219v1  [cs.PL]  29 Aug 2016consistent with a set of examples [8, 11]. Even though existing VSA
data structures can represent an exponential number of F IXIT rules
in polynomial space, this space can still be quite large. To address
this problem we introduce lazy version-space algebra . Given a set
of examples, our algorithm maintains a lazy representation of only
a subset of the F IXIT rules that are consistent with the examples.
The rules missing from the version-space are only enumerated
when necessaryâ€”i.e., when a new input-output example can only
be accounted by adding a F IXIT rule that is not already present
in the version-space. Because of the careful design of F IXIT, our
synthesis algorithm has a polynomial time complexity. In contrast,
existing VSA-based synthesis techniques for string transformations
require exponential time [8]. The polynomial time complexity is
crucial for our synthesis algorithm to scale to a large number of
ï¬x examples. Since different examples may refer to different target
rules, we propose a strategy to partition the input examples into
groups of examples corresponding to individual rules. We then use
the lazy VSA algorithm to learn the F IXIT rules for each partition.
We evaluate the synthesis algorithm implemented in N OFAQ
on 92 benchmark problems obtained from both T HEFXXX (76) and
online help-forums (16). N OFAQ is able to learn the repair rules for
81 of the buggy commands in these benchmark problems from only
2 to 5 input-output examples each.
Contributions summary:
1. F IXIT, a declarative domain-speciï¬c language for encoding
rules that map a command and an error message to possible
ï¬xed commands (Â§ 3).
2. A sound and complete polynomial time synthesis algorithm
based on lazy version-space algebra for synthesizing F IXIT
rules from input-output examples (Â§ 4).
3. An analysis of the formal properties of the F IXIT language and
its synthesis algorithm (Â§ 5).
4. A qualitative and quantitative evaluation of the synthesis algo-
rithm on 92 benchmarks obtained from both T HEFXXX and on-
line help-forums (Â§ 6.2).
2. Motivating examples
We ï¬rst present the main ideas behind N OFAQ using some con-
crete examples. All the example rules presented in this section are
actual rules appearing in T HEFXXX system.
2.1 Adding missing ï¬le extension
Java programmers, in particular novice ones, are likely to encounter
this error when they accidentally pass a class name instead of a
source code ï¬le to the javac compiler.
cmd1: javac Employee
err1: Class names, â€˜Employeeâ€™, are only accepted if annota-
tion processing is explicitly requested
Often, this error is provided by the javac compiler when it is
invoked on a ï¬le that does not have the proper .java extension. A
seasoned programmer would immediately recognize the problem
and add the extension .java at the end of the input ï¬le.
ï¬x1: javac Employee.java
On the other hand, a novice programmer will search the web in
the hope of ï¬nding a way to address the error and understand how
to apply it to their setting. The goal of N OFAQ is to automatically
synthesize simple ï¬xes like this one from examples provided by
experienced users and use the synthesized ï¬xes to help novice userswho encounter similar errors. For example, letâ€™s say that a skilled
developer provides another triple of the following form.
cmd2: javac Pair
err2: Class names, â€˜Pairâ€™, are only accepted if annotation pro-
cessing is explicitly requested
ï¬x2: javac Pair.java
Using these two examples N OFAQ will synthesize the follow-
ing ï¬x rule.
match [STR(javac ), V AR-MATCH (1;";")]
and[STR(Class ), STR(names, ), V AR-MATCH (2;â€˜;â€™,)
STR(are), STR(only ), STR(accepted ), STR(if),
STR(annotation ), STR(processing ), STR(is),
STR(explicitly ), STR(requested )]
![FSTR(javac ), SUB-LR(0;0;";.java;VAR(1))]
The ï¬rst part of the rule (i.e., up to the symbol !) pattern-matches
against the command and the error message and binds the input
strings to the corresponding variables. The variables are then used
by the second part of the rule to produce the output. In this case the
SUB-LR(0;0;";.java;VAR(1)) expression extracts the complete
string associated with V AR(1)(a start index of 0and an end index
of0denotes the identity string extraction), and then prepends the
string"at the beginning of it, and appends the string .java at the
end of it.
2.2 Extracting substrings
The following scenario is another common one for novice Java
programmers.
cmd1: java Run.java
err1: Could not ï¬nd or load main class Run.java
ï¬x1: java Run
Given this example and another similar one, N OFAQ synthesizes
the following rule.
match [STR(java ), V AR-MATCH (1;";.java )]
and[STR(Could ), STR(not), STR(find ), STR(or),
STR(load ), STR(main ), STR(class ),
VAR-MATCH (2;";.java )]
![FSTR(javac ), SUB-LR(0; 5;";"; VAR(1))]
This rule extracts the substring of the input ï¬le name starting at
index 0and ending at the index  5(5thindex from the end of the
string) in order to remove the .java extension.
2.3 Extracting complex substrings
A user was trying to move a picture from one location to another
but got the following error message.
cmd1: mv photo.jpg Mary/summer12.jpg
err1: canâ€™t rename â€™photo.jpgâ€™: No such ï¬le or directory
ï¬x1: mkdir Mary &&mv photo.jpg Mary/summer12.jpg
The error is cryptic for novice command-line users and does not
guide them towards the actual problem of the missing directory.
Given this example and another similar one, N OFAQ synthesizes
the following rule.
2 2018/10/14match [STR(mv), V AR-MATCH (1,","),
VAR-MATCH (2;";")]
and [STR(canâ€™t ), STR(rename ), V AR-MATCH (3;â€˜;â€™), STR(No),
STR(such ), STR(file ), STR(or), STR(directory )]
![FSTR(mkdir ), SUB-LR(0;CPOS(/;1;0);";&&;VAR(2))
FSTR(mv), SUB-LR(0;0;";"; VAR(1)),
SUB-LR(0;0;";"; VAR(2))]
The second expression in the output extracts the directory
nameâ€”i.e., the substring that starts at index 0 and ends at the
index of ï¬rst occurrence of the character /. The rule also adds a
string &&at the end of the extracted string to pipe the two output
commands.
3. The command repair language F IXIT
We now describe F IXIT, a domain-speciï¬c language for expressing
repair rules. The syntax and semantics of F IXIT is presented in
Figure 1 and Figure 2 respectively. The language F IXIT is designed
to be expressive enough to capture most of the rules we found in
THEFXXX and in online help-forums, but at the same time concise
enough to enable efï¬cient learning from examples.
General structure Each F IXIT program is a rule of the form
matchcmd anderr!fix
that takes as input a command scmd and an error serrand either
produces a ï¬xed command or the undeï¬ned value ?. The inputs
scmd andserrare lists of strings that are obtained by extracting
all the space-separated strings appearing in the input command and
error message respectively. The output ï¬x produced by the rule is
also a list of strings. From now on, we assume that the inputs and
outputs are lists of strings that do not contain space characters.
A rule has three components.
1. A list of match expressions cmd = [m1;;ml]used to
pattern match against the input command scmd.
2. A list of match expressions err = [m1;;mk]used to
pattern match against the input error message serr.
3. A list of ï¬x expressions fix= [f1;;fm]used to produce
the new ï¬xed command.
Match expressions A match expression mis either of the form
STR(s)denoting a constant string sor of the form
VAR-MATCH (i;l;r). A V AR-MATCH (i;l;r)expression denotes
a variable index iand requires the matched string to start with the
preï¬xland end with the sufï¬x r. We assume that no two variable
expressions appearing in the match expression have the same in-
dex. When a list of match expressions [m1;;ml]is applied to
a list of strings s= [s1;:::;sl]with the same length l, it generates
a partial function :N7!that assigns variables appearing in
the match expressions to the corresponding strings in the input. For
example, evaluating
[STR(mv);VAR-MATCH (1;;.jpg);VAR-MATCH (2;;.jpg)]
on the list of strings [mv;a.jpg;b.jpg ]produces the function 
such that(1) = a.jpg and(2) = a.jpg . On the other hand,
evaluating it on [mv;a.png;b.jpg ]yields?, asa.png does not
match the required sufï¬x in V AR-MATCH (1;;.jpg).
Fix expressions A ï¬x expression fis either of the form F STR(s)
denoting the constant output string s, or of the form
SUB-LR(pL;pR;l;r; VAR(i))denoting a function that is applied
to the string simatched by the variable V AR(i). This function out-
puts the string lmr, wheredenotes the string concatenation
operator and m=substr (s;jL;jR)wherejLandjRare theFix rule r:= matchcmd anderr!fix
Input cmd cmd := [m1;;ml]
Input error err := [m1;;mm]
Output cmd fix := [f1;;fn]
Match expr m:= STR(s)
jVAR-MATCH (i;l;r)
Fix expr f:= FSTR(s)
jSUB-LR(pL;pR;l;r; VAR(i))
Pos expr p:= IPOS(k)
jCPOS(c;k; )
Variables and constants:
s;sl;sr:string i;k; :integer
c:character
Figure 1: Syntax of the rule description language F IXIT.
indices resulting from respectively evaluating the position expres-
sionspLandpRon the string s. Here, given a string s=a0:::an,
the expression substr (s;jL;jR)denotes the string ajL:::ajR 1
ifjL;jRn+ 1 and the undeï¬ned value ?otherwise. Notice
that, unlike previous VSA-based languages [8], F IXIT does not al-
low binary recursive concatenation; this is one of the key features
that enables polynomial time synthesis.
Positions expressions A position expression pcan be one of the
following types of expressions.
A constant position expression I POS(k), which denotes the in-
dexkifkis positive and the index jsj kifkis negative. If k=
0, this expression evaluates to 0when evaluated for pL(i.e.,
the starting index of the substring) and to jsjwhen evaluated
forpR, wherejsjdenotes the length of the string s. For exam-
ple, in the function S UB-LR(IPOS(0);IPOS(0);";"; VAR(1)),
where(1) = File the ï¬rst constant position evaluates to the
index 0, while the second constant position evaluates to the in-
dexjFilej= 4.
A symbolic position expression C POS(c;k; ), which denotes
the result of applying an offset to the index of the k-th oc-
currence of the character cinsifkis positive, and the result
of applying an offset to the index of the k-th to last occur-
rence of the character cinsifkis negative. For example, given
the string www.google.com , the expression C POS(.;1; 2)de-
notes the index 2(two positions before the ï¬rst dot), while the
expression C POS(.; 1;2)denotes the index 12(two positions
after the last dot). This operator is novel and can express op-
erations that are not supported by previous VSA-based work.
In particular, FlashFill [8] only allows the extraction of the ex-
act position of a character and not positions in its proximity.
Despite this additional capability, F IXIT programs can be syn-
thesized in polynomial time.
Comparison with FlashFill DSL At the top-level, F IXIT consists
of match expressions over original command and error message,
which perform pattern-matching and uniï¬cation of variables with
strings. This form of matching and uniï¬cation is not expressible in
FlashFill, so we cannot use it to learn the ï¬x rules directly. How-
ever, we can use FlashFill as a subroutine to learn string transforma-
tions corresponding to expressions similar to S UB-LRexpressions
in N OFAQ. However, the FlashFill DSL has two major limitations:
1) No support for offsets from regular expression matches in com-
puting position expressions (in contrast to F IXITâ€™s C POS(c;k; )
operator), and 2) A ï¬nite hard-coded token set for regular expres-
sions (e.g. no support for constant character tokens). Moreover, as
described in subsection 4.3 and section 8, our S UB-LRoperator
yields a synthesis algorithm that operates in polynomial time in the
3 2018/10/14Jmatchcmd anderr!fixK(scmd;serr) =(
JfixK=unify (cmd; scmd)[unify (err;serr)^6=?
? otherwise
unify ([m1;;ml];[s1;;sl]) =S
1jlmatch-expr (mj;sj);
match-expr (STR(s1);s2) =(
0ifs1=s2and0is the always undeï¬ned function
? otherwise
match-expr (VAR-MATCH (i;l;r);s) =(
 if9s.t.s=lrand(i) =sandis undeï¬ned on every j6=i
?otherwise
J[f1;;fn]K= [ Jf1K;;JfnK]
JFSTR(s)Kfun
=s
JSUB-LR(pL;pR;l;r; VAR(i))Kfun
=lmr if(i;s)2andm=substr (s;JpLKpos
s;L;JpRKpos
s;R)
JIPOS(k)Kpos
s;d=8
>>><
>>>:k k> 0
jsj+k k< 0
0k= 0^d=L
jsjk= 0^d=RJCPOS(c;k; )Kpos
s;d=8
>>>>><
>>>>>:I[k 1] + k> 0andI=indices (s;c)
andjIjk
I[l k] + k< 0andI=indices (s;c)
andjIj+k0^l=jIj
? otherwise
indices (s;c) = [i0;:::;ij] where80l<j :il<il+1;s[il] =cand8j:s[j] =c!90l<j :il=j
Figure 2: The semantics of the command repair DSL F IXIT.
number of examples, which enables the algorithm to scale to a large
number of examples. Because of the recursive binary concatenate
expressions in FlashFill, the DAG intersection based synthesis al-
gorithm is exponential in the number of examples.
4. Synthesizing rules from examples
In this section we ï¬rst describe our algorithm for synthesizing a
single F IXIT rule from a set of examples of concrete command
ï¬xes. We then describe a multi-stage partitioning algorithm for
learning multiple F IXIT programs from a large undifferentiated set
of command repair examples.
The algorithm for learning a single F IXIT rule is described in
Figure 8; it takes as input a list of examples E= [e1;:::;en]
where each example eiis a triple of the form (scmd;serr;sfix)
and outputs a symbolically represented set of F IXIT rulesR
consistent with Eâ€”i.e., for every rule r2Rand example
ei= (scmd;serr;sfix), the ruleroutputs sfixon the input
(scmd;serr).
The algorithm processes one input example at a time, and after
processing the ï¬rst iexamplesEi= [e1;:::;ei]the algorithm
has computed a set of rules Riconsistent with Ei. At the end, the
algorithm outputs one of the rules in Rn. We use?to denote the
undeï¬ned result. If at any point our algorithm returns ?it means
that there is no F IXIT rule that is consistent with the given set of
examples.
4.1 Symbolic representation of multiple rules
Since there can be exponentially many rules consistent with the
input examples, we adopt a symbolic representation of the set R
that is guaranteed to always have polynomial size. Our synthesis
algorithm takes as input a list of examples Eand produces as output
a symbolic rule of the form matchcmd anderr!sfixes ,
wherecmd anderrare tuples of expressions that can consist of
either constants or variables, and fixes = [f1;:::;fm]is a list
of expressions that symbolically represents a set of outputs that
is consistent with the examples E. Formally, each fiinfixes
is either a constant expression F STR(s)for somes, or a set ofsubstring expressions fsu1;:::;sukg, where each suiis of the
form S UB-LR(pL;pR;l;r; VAR(j)). Intuitively, if we replace each
set with one of the ï¬x expressions it contains, we obtain a F IXIT
rule. If each ficontainskelements, this symbolic representation
modelsknprograms using an expression of size kn.
4.2 Lazy rule representation
The core element of our algorithm is a lazy representation of the
rules that represents match and ï¬x expressions as constants for as
long as possibleâ€”i.e., until a new example shows that some parts
of the rule cannot be constants. This helps reduce the number of
variable expressions, which in turn reduces the number of substring
expressions to be considered. We ï¬rst illustrate the idea with a
concrete example. Letâ€™s say that we are given the two examples
shown in Figure 3a and 4a. After processing the ï¬rst example,
our algorithm synthesizes the F IXIT rule in Figure 5a in which
every match expression and every ï¬x expression is a constant.
However, since we have only seen one example, we do not yet know
whether some expression appearing in the match should actually
be a variable match expression or whether some element in the
ï¬x expression should actually be a function of some variable. The
main idea is that any of these possibilities can still be â€œrecoveredâ€
when a new example shows that indeed a variable is needed. Using
this idea, we maintain each expression as a constant until a new
example shows that some expression cannot actually be a constant.
This is exactly what happens when processing the input exam-
ple in Figure 4a. At this point in order to ï¬nd a rule that is consis-
tent with both examples we need to introduce a variable match as
the second expression of the command match, and some function
application as the second element of the ï¬x. To do so, our algorithm
applies the following operations to the previously computed rule.
1. All match expressions that cannot be constants are â€œpromotedâ€
to variable match expressions (making sure that all variable
names are unique), which match on the longest shared preï¬x
and sufï¬x of all previously seen values at that position. The
following table illustrates the idea for the case in which we try
4 2018/10/14cmd1: java Run.java
err1: Could not ï¬nd or load main class Run.java
ï¬x1: java Run
(a) First example.cmd2: java Meta.java
err2: Could not ï¬nd or load main class Meta.java
ï¬x2: java Meta
(a) Second example.
match [STR(java ), STR(Run.java)]
and [STR(Could ), STR(not), STR(find ), STR(or), STR(load ),
STR(main ), STR(class ), STR(Run.java )]
!s[FSTR(java), F STR(Run)]
(a) Symbolic rule representation synthesized after ï¬rst example.match [STR(java ), V AR-MATCH(1; ";.java )]
and [STR(Could ), STR(not), STR(find ), STR(or), STR(load ),
STR(main ), STR(class ), V AR-MATCH(2; ";.java )]
!s[FSTR(java),8
<
:SUB-LR(IPOS(0);IPOS( 5); "; "; VAR(1))])
SUB-LR(IPOS(0);CPOS(.;1;0); "; "; VAR(1))])
SUB-LR(IPOS(0);CPOS(.; 1;0); "; "; VAR(1))])9
=
;]
(a) Symbolic rule representation synthesized after both examples.
Figure 7: Two input examples e1ande2and symbolic rules synthesized after processing e1ande2.
to unify the command cmd2 in Figure 4a with the matching part
of the already computed rule in Figure 5a.
rule: S TR(java ) S TR(Run.java )
new-ex: java Meta.java
new-rule: S TR(java ) V AR-MATCH (1;";.java )
2. All the ï¬x expressions that cannot be constants are â€œpromotedâ€
to S UB-LR expressions that are consistent with the current
examples and are allowed to use the variables appearing in the
match expressions.
The second rule in Figure 7(d) reï¬‚ects this update. The ï¬gure
also shows how multiple S UB-LRexpressions are represented sym-
bolically as a set. We describe all of these components in detail in
the next section.
4.3 Synthesis algorithm
Given a list of input examples, the function S YNTH RULES uses
the ï¬rst example and the function C ONST RULE to generate the
symbolic rule composed only of constant operators. It then it-
eratively reï¬nes the rule on the remaining examples as shown
in Figure 8. This second operation is done by the function R E-
FINE RULE which takes as input a symbolic rule r, one new exam-
ple(scmd;serr;sfix), and the list of examples Eon which every
concrete rule represented by rbehaves correctly. R EFINE RULE ex-
ecutes two main steps using the following functions.
FINDVARIABLES tries to unify the inputs scmdandserrwith the
corresponding match expressions cmd anderrin the symbolic rule
rand generates new variable match expressions if necessaryâ€”i.e.,
whenrcontains a matching expression S TR(s)but the correspond-
ing component in the example is a string different from s. In this
case, a V AR-MATCH (i;l;r)expression is generated such that iis
a new variable name, and landrare the longest preï¬x and sufï¬x
shared bys, respectively.
When F INDVARIABLES is presented with a new scmd or
serrafter a constant match expression has been â€˜promotedâ€™ to a
VAR-MATCH (i;l;r)expression, the preï¬x and sufï¬x are up-
dated accordingly. F INDVARIABLES determines the longest preï¬x
r0and sufï¬xl0oflandr, respectively, that is consistent with
the appropriate component of the new example, and generates
VAR-MATCH (i;l0;r0).
SYNTH FIX uses the variables computed in the previous step to
synthesize all possible ï¬x expressions that are consistent with the
list of examplesf(scmd;serr;sfix)g::E.
In order to simplify variable naming and guarantee unique
names, each variable has the index of the corresponding element inthe inputâ€”i.e., V AR(i)denotes thei-th string in the list scmd@serr
obtained by concatenating the command and error input lists.
Lazy pattern matching The function F INDVARIABLES , given a
rulerand a new example e, iterates over the input components of
the new example eand outputs the set of variables necessary to
match this new example with respect to the previously computed
symbolic rule r. The function S YNTH FIX, given a rule rand a
list of examples E, individually synthesizes all the components fi
of the symbolic output ï¬x expression that are consistent with E.
SYNTH FIXis incremental in the sense that it tries to minimally
change the original ï¬x expression of r:
if thei-th component tiof the ï¬x expression of ris a con-
stant string consistent with the new example, then it is left un-
changed;
in any other case the output has to be a substring operation,
and the function S YNTH SUBSTRINGS is used to compute all
the possible S UB-LRexpressions that are consistent with the
set of examples E.
Given a list of examples e::E, the function S YNTH SUBSTRINGS
ï¬rst synthesizes all the S UB-LRexpressions that are consistent with
eusing the function A LLSUBSTRINGS and then runs each synthe-
sized expression on examples in Eto remove the inconsistent ones.
ALLSUBSTRINGS Figure 8 omits the formal deï¬nition of the
function A LLSUBSTRINGS due to space limitations, but we de-
scribe its main components. Given an example
e= (scmd;serr;sfix), a set of variable names V, and the index i
corresponding to the element of the output sequence we are trying
to synthesize, A LLSUBSTRINGS computes the set of all substring
expressions of the form fun=SUB-LR(pL;pR;l;r; VAR(j))that
are consistent with esuch that the result of applying fun to the
j-th string in scmd@serris thei-th string in sfix. Letâ€™s assume
thatjscmdj+jserrj=nI,jsfixj=nO, andnLis the length of
the longest string appearing in any of the three lists in the input
example. To compute the set A LLSUBSTRINGS (e;V;i )we iterate
over all variable indices and for each variable index j2Vwe do
the following.
1. Extract the string sjcorresponding to the variable V AR(j)â€”
O(nI)iterations.
2. For each string sthat is a substring of both sfix[i]and
sj, compute all possible pairs of indices k1;k2such that
substr (sj;k1;k2) =sâ€”O(n2
K)possible substrings and
O(nK)possible ways to place the substring in sfix[i].
5 2018/10/14//Rules consistent with input examples
funSYNTH RULES ([e0;:::;en])
r CONST RULE(e0)
for1indo .reï¬ne on each example ei
r REFINE RULE(r;[e0;:::;ei 1];ei)
returnr
//Constant rule consistent with one example
funCONST RULE([sc
1;:::;sc
n];[se
1;:::;se
m];[sf
1;:::;sf
l])
cstcmd [STR(sc
1);:::; STR(sc
n)]
csterr [STR(se
1);:::; STR(se
m)]
cstfix [FSTR(sf
1);:::; FSTR(sf
l)]
return (matchcstcmdandcsterr!scstfix)
//Reï¬nes a rule to make it consistent with one more example
funREFINE RULE(r;E; (scmd;serr;sfix))
r(matchcmd anderr!sfixes )
(cmd0;Vc) FINDVARIABLES (scmd;cmd; 0)
(err0;Ve) FINDVARIABLES (serr;err;jscmdj)
V Vc[Ve
E0 (scmd;serr;sfix) ::E
fixes0 SYNTH FIX(sfix;fixes;E0;V)
return (matchcmd0anderr0!sfixes0)
//Finds variables necessary to match example
funFINDVARIABLES ([s1;:::;sn];[t1;:::;tm];o)
ifn6=mthen .Input length same as match length?
return?
(m;V ) ([];;)
for1indo
caseti=STR(s)^s=si
(m;V ) (m@STR(si);V)
caseti=STR(s)^s6=si
pref LONGEST COMMON PREFIX (s;si)
suf LONGEST COMMON SUFFIX (s;si)
newId i+o . Create new variable
m m@[VAR-MATCH (newId; pref; suf )]
V V[fnewIdg
caseti=VAR-MATCH (j;l;r )
pref LONGEST COMMON PREFIX (s;l)
suf LONGEST COMMON SUFFIX (s;r)
m m@[VAR-MATCH (j; pref; suf )]
V V[fjg
return (m;V )//Outputs the ï¬xes consistent with all the examples Eand such
that S UB-LRexpressions can depend on any variable in V. The
ï¬x component of the latest example and the ï¬xes computed on the
previous examples are also passed as input
funSYNTH FIX([s1;:::;sn];[t1;:::;tn];e::E;V )
ifn6=mthen
return?
f []
for1indo
ifti=FSTR(s)^s=sithen
f f@[FSTR(si)]
else
f f@[SYNTH SUBSTRINGS (e::E;V;i )]
returnf
//Outputs all S UB-LRexpressions consistent with all the examples
that can appear at position iin the ï¬x expression
funSYNTH SUBSTRINGS (e::E;V;i )
F ALLSUBSTRINGS (e;V;i )
for all (scmd;serr;sfix)2Edo
F0 ;
for allfun2Fdo
letSUB-LR(pL;pR;l;r; VAR(j)) =fun
o jscmdj
ifj <o then .The variable is in scmd
ifEVAL (fun; scmd[j] = sfix)then
F0 fun::F0
else .The variable is in serr
ifEVAL (fun; serr[j o] = sfix)then
F0 fun::F0
F F0
returnF
//Outputs all S UB-LRexpressions consistent with one example that
can appear at position iin the ï¬x expression
funALLSUBSTRINGS ((scmd;serr;sfix);V;i )
return all S UB-LR(pL;pR;l;r; VAR(j))that
when evaluated on scmdandserroutput sfix[i]
and such that j2V.
Figure 8: Algorithm for synthesizing F IXIT rules from concrete examples.
3. For each k1(resp.k2) compute every position expression p1
(resp.p2) such that evaluating p1(resp.p2) onsjproduces the
indexk1(resp.k2) â€”O(nK)possible positions.
4. For each of these possibilities yield the expression
SUB-LR(p1;p2;l;r; VAR(j))wherelandrare such that
sfix[i] =lsubstr (sj;k1;k2)r.
ALLSUBSTRINGS produces a set of expressions that in the worst
case has size O(nIn5
K)3. If we restrict the offset component to
only range over the values f 1;0;1gfor the symbolic expressions
3Note that the efï¬ciency of this implementation is contingent on our
speciï¬c choice of data structure and algorithms. A more naive solution,
based on set intersection (like that of the DAG-based algorithm in FlashFill)
may experience exponential blow-up in the number of examples, due to the
quadratic nature of the intersection operations.CPOS(c;i; ), the size reduces to O(nIn3
K), and the synthesis
algorithm is still sound and complete for this fragment of F IXIT.
This last restriction of the language can capture all the rules we
are interested in. Notice that this analysis still holds in the extreme
case in which all input matches are variable expressions of the form
VAR-MATCH (i;";" ). In our experiments on real-world commands,
worst-case performance is uncommon, and is induced by substring
operations over heterogeneous strings which yield many possible
implementations. Consider the following two examples.
cmd1: aaaa aaaa cmd2: bbbb bbbb
err1: aaaa aaaa err2: bbbb bbbb
ï¬x1: aa ï¬x1: bb
Performing synthesis on this pair of examples yields a pattern
match consisting of four V AR-MATCH (i;;)expressions. Due to
the uniformity of the input strings, synthesis yields 48possible
6 2018/10/14SUB-LRexpressions. In particular, the desired ï¬x can be generated
from any of the four strings in the supplied scmd andserr. Each
of the four strings has three substrings of length 2, any of which
yields the desired output. For each such substring, there are four
pairs of I POS values that supply the appropriate indices: The pair
with two positive indices, the pair with two negative indices, and
the two pairs consisting of one positive and one negative index.
Key point At this point we are ready to explain why all the match
expressions can be kept as constants for as long as possible. If
after processing a set of examples E, some expression in cmd or
err is of the form S TR(si), then, for every input example, the
value of the i-th component is the string si. Therefore, even if
we replace this expression with a variable, all its instantiations
will have the same values. Consequently, every function of the
form S UB-LR(p1;p2;l;r; VAR(i))will produce a constant output,
making it equivalent to the some constant function F STR(s0).
4.4 Partition-Based Synthesis
FIXIT can learn repair rules from a set of examples corresponding
to a speciï¬c incorrect use of a command. In practice, however,
it may be difï¬cult to present F IXIT with a collection of neatly
curated sets of examples, from each of which, F IXIT learns a
single symbolic rule. Such a process is both labor-intensive and
error-prone. We instead envision large-scale learning of F IXIT rules
from undifferentiated sets of examples submitted by many users.
To facilitate this, we propose a simple multi-stage partitioning
strategy. As a consequence of F IXITâ€™s structure, each symbolic rule
matches on a pair of command and error strings, each of which
has a ï¬xed number of tokens. Upon a match, F IXIT generates
a repaired command with a ï¬xed number of tokens. Conversely,
every symbolic F IXIT expression must be learned from a set SEof
example triples of the form (scmd;serr;sfix)for which the lengths
ofscmd,serr, andsfixdo not vary.
Given an undifferentiated set of examples, SE, we partition
SEintondisjoint subsets iwhereSE=Sn
i=0i. For every
ithe property8(scmd;serr;sfix)2i;(scmd;serr;sfix)2
i:jscmdj=jscmdj^jserrj=jserrj^jsfixj=jsfixj. This
dividesSEinto subsets from which it is possible to synthesize
FIXIT rules.
After dividing SE, it may still be the case that individual sets i
contain examples representing distinct command repair rules which
share the same triple of scmd,serr, andsfixlengths. At this point,
we attempt to ï¬nd the smallest set of rules that can be synthesized
from the examples in i.
The search ranges over all partitions Pofi, wherePis the
setfi;1;i;2;:::;i;mgsuch thatSm
j=1i;j=iand8j6=
k;i;j\i;k=?. We enumerate the partitions in ascending
order of size m, starting with P=fig, and ending with the
partition consisting entirely of singleton sets. Given a partition P,
we attempt to synthesize a symbolic F IXIT rule for each set in P,
stopping when we have generated a rule for each i;j. As we will
show in section 6.2, this expensive procedure is only feasible when
using our novel contribution of lazy VSA.
Example partitioning Consider the example set shown in Fig-
ure 9. The ï¬rst two examples in this set correspond to the repair
in Section 2.1 while the last two correspond to the repair in Sec-
tion 2.3. The third and fourth example correspond to the rule that
outputs composer , followed by the token at index 8in the input
(i.e., the ï¬rst token suggested by the error message).
We ï¬rst group the examples based on the length of their compo-
nents. For the ï¬rst four examples, we have jscmdj= 2,jserrj= 8,
jsfixj= 2 and for the two remaining examples, jscmdj= 3 ,
jserrj= 8 ,jsfixj= 6 . Thus, we obtain two groups S1=
fe1;e2;e3;e4gandS2=fe5;e6g.cmd1: java Run.java
e1err1: Could not ï¬nd or load main class Run.java
ï¬x1: java Run
cmd2: java Test.java
e2err2: Could not ï¬nd or load main class Test.java
ï¬x2: java Test
cmd3: composer pkg
e3err3: did you mean one of these? pkg1 pkg2
ï¬x3: composer pkg1
cmd4: composer hptt
e4err4: did you mean one of these? http html
ï¬x4: composer http
cmd5: mv photo.jpg Mary/summer12.jpg
e5err5: canâ€™t rename â€˜photo.jpgâ€™: No such ï¬le or directory
ï¬x5: mkdir Mary &&mv photo.jpg Mary/summer12.jpg
cmd6: mv dec31.jpg Bob/family.jpg
e6err6: canâ€™t rename â€˜dec31.jpgâ€™: No such ï¬le or directory
ï¬x6: mkdir Bob &&mv dec31.jpg Bob/family.jpg
Figure 9: Examples requiring more than one F IXIT rule.
While there exists a F IXIT program that is consistent with the
examples in the set S2, no F IXIT program can describe a transfor-
mation that is consistent with all the examples in S1. We there-
fore proceed by iteratively partitioning the set Si, attempting to
ï¬nd a partition Pifor which we can synthesize a rule for every
Si;j2Pi. ForS2, we can clearly do so for the initial partition
P2=fS2g, yielding the rule from Section 2.2. For S1, the ï¬rst par-
tition for which we can generate a F IXIT rule for every element is
P1=fS1;1=fe1;e2g; S1;2=fe3;e4gg.S1yields the rule from
Section 2.1, and S2yields the simple substitution rule described
previously.
4.5 More Succinct Representation
The version of symbolic rule we presented is already able to store
exponentially many concrete F IXIT rules in polynomial space. In
this section, we discuss further improvements that can make the
representation more succinct.
Avoid redundancy In the set of ï¬x expressions enumerated by the
function A LLSUBSTRINGS , the last three components of the the
expression S UB-LR(p1;p2;l;r; VAR(j))are often repeated many
times. Looking at Figure 6a we can see how all the synthesized
functions have l=r="and are applied to the variable V AR(1).
We deï¬ne a data structure for representing sets of ï¬x expressions
that avoids these repetitions. A set of ï¬x expressions is represented
symbolically using a partial function
d:N7!()7!Set(PP)
wherePis the set of all position expressions. Formally, given a
variable index iand two strings landr, the setd(i;l;r)symboli-
cally represents the set of ï¬x expressions
fSUB-LR(p1;p2;l;r; VAR(i))j(p1;p2)2d(i;l;r)g. The func-
tiondcan be efï¬ciently implemented and avoids redundancy. Con-
sidering again the example rule in Figure 6a, all the ï¬x expressions
in the second component of the output can be succinctly repre-
sented by the function dthat is only deï¬ned on the input (1;";")
and such that
d(1;";") =f(IPOS(0);IPOS( 5));
(IPOS(0);CPOS(.;1;0));
(IPOS(0);CPOS(.; 1;0))g:
Avoid example representation Each synthesized rule is in some
sense coupled to the set of examples used to synthesize it. We
present a data structure that only keeps track of the important
7 2018/10/14â€œpartsâ€ of the input examples and therefore allows us to discard
each example after it has been processed.
We modify the symbolic rule representation as follows. Given a
set of examples (s1
cmd;s1
err;s1
fix):::(sn
cmd;sn
err;sn
fix),
every variable V AR-MATCH (i;l;r)in the match component
becomes a pair (VAR-MATCH (i;l;r);[b1;:::;bn])where the
second component is the list of strings that binds to V AR(i)in
the input components of the examplesâ€”i.e. bj= (sj
cmdsj
err)[i];
every set of ï¬x expressions represented by a function diand
corresponding to the i-th component of the ï¬x expression be-
comes a pair (di;[b1;:::;bn])where the second component is
the list of strings that appear in position iin the output compo-
nents of the examplesâ€”i.e. bj= sj
fix[i];
Using this data structure we do not need to store examples as we
can always re-infer them from the symbolic rule representation.
4.6 Concrete outputs
Taking into account the updated data structures, the algorithm
SYNTH RULES returns a symbolic rule rof the form
matchcmd anderr!sfixes wherecmd = [c1;:::;cn]
anderr= [e1;:::;em]are lists of expressions of the form S TR(s)
or(VAR(i);B), whilefixes = [f1;:::;fl]is a list of expressions
of the form F STR(s)or(d;B)wheredis the data structure for
representing multiple ï¬x expressions. The set of concrete F IXIT
rules induced by this symbolic representation is the following.
con(matchcmd anderr!sfix) =
fmatchcmd anderr!fjf2con(fix)g
con([f1;:::;fl]) =f[f0
1;:::;f0
l]jf0
i2con(fi)g
con(FSTR(s)) =fFSTR(s)g
con(d;B) =fSUB-LR(p1;p2;l;r; VAR(i))j
9i;l;r: (p1;p2)2d(i;l;r)g:
5. Formal properties
We study the formal properties of the synthesis algorithm and of the
language F IXIT. These speciï¬c properties describe the behavior of
the synthesis algorithm in the absence of the partitioning strategy
described in Section 4.4.
Properties of the synthesis algorithm First, our synthesis algo-
rithm is invariant with respect to the order in which the training
examples are presented. Thus, the properties of a symbolic rule
generated by S YNTH RULES , can be discussed solely in terms of
thesetof examples provided to S YNTH RULES .
Theorem 1 (Order invariance) .Given a list of examples E, for ev-
ery permutation of examples E0ofE, we have
con(SynthRules (E)) = con(SynthRules (E0)).
Proof sketch. Consider a list of examples E. If two examples differ
at theith position in their respective commands, the ith expression
incmd will be promoted to a V AR-MATCH , regardless of the order
in which they are presented to S YNTH RULES . Moreover, if all
jEjstrings at the ith position in the commands share a preï¬x or
sufï¬x, reordering Edoes not change this fact. Thus, the discovered
VAR-MATCH expressions will not vary based on order. The same
holds forerrand the â€œpromotionâ€ of constants in S YNTH FIX.
Moreover, S YNTH SUBSTRING starts from scratch at each iter-
ation of the loop in S YNTH RULES andfix depends only on the
output of S YNTH FIXin the ï¬nal iteration. Since the variable set
does not vary based on the ordering of E, the ï¬nal invocation of
SYNTH FIXdoes not depend on the ordering of E.
Second, the synthesis algorithm produces only rules that are
consistent with the input examples. If we select an arbitrary con-
crete rulerfrom the set speciï¬ed by a symbolic rule generated bySYNTH RULES , and run it on the command and error of any of the
examples provided to S YNTH RULES for the synthesis of r, we will
obtain the ï¬x originally provided in that example.
Theorem 2 (Soundness) .Given a list of examples E, for every rule
r2 con(SynthRules (E)) and for every example
(scmd;serr;sfix)2E,JrK(scmd;serr) = sfix.
Proof sketch. The repeated applications of F INDVARIABLES will
promote any S TR(s)expression if a new example does not match
ons. Moreover, when reï¬ning a V AR-MATCH , FINDVARIABLES
chooses the longest preï¬x and sufï¬x consistent with all examples
seen so far. Thus, cmd anderrwill correctly match on all exam-
ples. The soundness of the resulting fixderives from the fact that
at each iteration of the loop in S YNTH RULES , the invocation of
SYNTH SUBSTRING in S YNTH FIXtakes into account all examples
seen in previous iterations of the loop. Moreover, each invocation
begins with the set of all possible S UB-LRexpressions, and prunes
those inconsistent with any example seen so far.
Since parts of the match expressions are â€œpromotedâ€ to variables
only when the input examples show that this is required, our syn-
thesis algorithm does not explicitly keep track of all the possible
rules that can be consistent with the examples. Our completeness
result reï¬‚ects this idea.
Theorem 3 (Completeness) .Given a set of examples E, for every
Fixit ruler that is consistent with E, either
r2con(SynthRules (E))or there exists an example esuch that
r2con(SynthRules (e::E)).
Proof sketch. Concretely, a particular rule rthat is consistent with
Emight not appear in R=SYNTH RULES (E). However, this can
only happen because the match expression of rhas more variables
than the match of any rule in R. This can be ï¬xed by providing an
example that forces the algorithm to promote to variables all the
required match expressions.
Properties of the language Fixit We deï¬ne the size of an input
examplee= (scmd;serr;sfix)and the size of each rule rcon-
sistent with eas the sum of its lengths size(e) = size(r) =
jscmdj+jserrj+jsfixj. For each set of examples, there can be
exponentially many rules consistent with it.
Theorem 4 (Number of consistent rules) .Given a set of examples
E, each of size k, the set con(SynthRules (E))contains 2O(poly (k))
rules.
Proof sketch. As we showed in Section 4.3, for each position in
the output of a F IXIT rule there are potentially polynomially many
SUB-LRexpressions consistent with the provided examples. For
theith position in fix, we are free to choose any of the possible
SUB-LRs, independently of our choice at other positions. Thus, the
number of possible rules is potentially exponential in jsfixj.
Despite the exponential number of rules represented, our data
structure allows the S YNTH RULES to encode these rules using only
polynomial size.
Next, there exists an active learning algorithm for learning
FIXIT rules that requires only a polynomial number of examplesâ€”
i.e., queries to the user.
Theorem 5 (Complexity of active learning) .If there exists a target
rulerof sizek, there exists an active learning algorithm that will
learnrby askingO(poly(k))queries of the form: What should the
output ofrbe on the input (scmd;sfix).
Proof sketch. The algorithm ï¬rst asks kqueries to ï¬gure out which
match expressions are variables and which ones are constants.
Then, for each output component for which there exists two pos-
sible ï¬x expressions S UB-LRconsistent with the examples, it asks
8 2018/10/14a query that differentiates the two. Since there are only O(knIn5
K)
many expressions in the output the algorithm will ask at most poly-
nomially many queries.
6. Implementation and Evaluation
We now describe the implementation details of N OFAQ, as well as
our experimental evaluation of N OFAQ on a set of examples and
test cases isolated from T HEFXXX and web forums.
6.1 Implementation
We implemented the language F IXIT and its synthesis algorithm
in a system called N OFAQ. N OFAQ is implemented in F#4and
consists of some additional optimizations and design choices as
described below.
6.1.1 Implementation optimizations
The function A LLSUBSTRINGS in Figure 8 synthesizes all S UB-LR
functions that are consistent with the ï¬rst input/output pair (s;t)of
strings in the example set Eand then applies each of the synthe-
sized functions to the other elements of Efor ï¬ltering only con-
sistent functions. In practice, we ï¬rst compute the longest com-
mon preï¬xes and sufï¬xes of the strings appearing in the com-
ponents sfixofEto avoid enumerating instances of the form
SUB-LR(_;_;l;r; _)such thatlorrare not preï¬xes or sufï¬xes
of some output string tappearing in E.
The other optimization is based on the following property of
the R EFINE RULE function: when adding a new example to r, if
the function F INDVARIABLES introduces a new set of variables
V, all the new instances of S UB-LRthat did not already appear
inrdepend on one of the newly introduced variables in V. Based
on this idea, the function A LLSUBSTRINGS only has to compute
functions of the form S UB-LR(_;_;_;_;VAR(i))wherei2V, and
can reuse the previously computed functions for the other variables
by simply ï¬ltering the ones that behave correctly on the newly
introduced example.
6.1.2 Ranking
Since there can be multiple possible expressions in F IXIT that are
consistent with the examples, we employ a simple ranking tech-
nique to select an expression amongst them. If there are multiple
SUB-LRexpressions that can generate the desired output string,
we select the expression that uses the variable with the lowest
indexâ€”i.e., the leftmost one. Similarly, the landrincluded in
VAR-MATCH expressions implicitly encode all rules matching on
preï¬xes and sufï¬xes of landr, respectively. We choose the longest
landrover all others.
As the example set increases in size, we envision users will
likely submit diverse sets of examples, particularly in use cases
with thousands of users submitting examples. As users submit
examples which draw from heterogeneous collections of command
parameters, V AR-MATCH preï¬xes and sufï¬xes should converge to
the least restrictive versions. Similarly N OFAQ should discover
the least restrictive set of constants for both match expressions.
As these input parameters vary over the set of examples, spurious
ambiguities in S UB-LRshould be eliminated when N OFAQ is
presented with speciï¬c ï¬x examples which function as counter-
examples to unnecessary substring expressions.
6.2 Evaluation
We now describe our experimental evaluation. The experiments
were run on an Intel Core i7 2.30GHz CPU with 16 GB of RAM.
4The implementation will be made open-source and publicly available after
the review process.We present both qualitative and quantitative analysis of the algo-
rithm. We assess the expressiveness of N OFAQ by attempting syn-
thesis on a benchmark suite that includes the rules in the tool T HE-
FXXX. We then evaluate the performance of N OFAQ and its scala-
bility.
6.2.1 Benchmark Suite
We compiled our benchmark suite from an initial set of of 92
benchmarks, which were collected from both T HEFXXX (76) and
online help forums (16). We considered the 76 repair rules hard-
coded in the T HEFXXX tool to assess the expressiveness of N O-
FAQ. Since rules in T HEFXXX can use arbitrary Python code, it
is hard to exactly compare them to the ones produced by N OFAQ.
We use manual testing to check that a rule rgenerated by our tool
isconsistent with a ruler0in T HEFXXX. To do so, we manually
constructed a set of examples based on the pattern-matching and
textual substitutions performed by the T HEFXXX rules.
The other sixteen example sets were obtained from examples
found during a non-exhaustive survey of command-line help fo-
rums on the web. These commands consist of various types of
git, svn, and mvn commands, including committing, reverting, and
deleting from repositories, as well as installing and removing pack-
ages.
The N OFAQ system is able to synthesize a rule for 81 of the 92
benchmarks. The remaining 11 failing benchmarks can be divided
into three broad categories: i) Hard-coded operations searching for
speciï¬c strings in some context (8), ii) Complex patterns check-
ing relationships between variable expressions (2), and iii) Error
messages displaying parts of the input ï¬leâ€™s content (1). We did not
provide examples for these 11 rules. We elaborate more about these
categories in Section 7.
Number of examples We observed that it was natural to provide
two to ï¬ve examples per benchmark for N OFAQ to uniquely learn
the desired ï¬x rule. We also provided additional examples for
manually testing the learned rules, yielding a set of three to six
examples. Given the rule appearing in Figure 7, for example, we
used the two examples in Figure 7 and another example with the
ï¬le name Employee.java. In future, we envision users to contribute
different examples to the system for automatically building a large
corpus of learned ï¬x rules.
While these examples are synthetic examples reverse engi-
neered from other sources, they are also natural examples which
exercise the range of e.g. path and ï¬le names one would expect
to see in a real Unix system. In the case of the repaired command
in Section 2.3, the natural two-example set would consist of two
distinct directory names which do not share preï¬xes and sufï¬xes,
as well as ï¬lenames with distinct preï¬xes and extensions.
6.2.2 Qualitative evaluation
Given a single set containing examples for all the 81 cases in which
NOFAQ is capable of synthesizing a rule, we performed synthesis
as described in Section 4.4. For each rule we retained a single
example from the training set and used it to test the accuracy of
each rule. We also report how often a given input could be repaired
using more than one rule.
Results For all 81 cases, N OFAQ synthesized a rule consistent
with the corresponding T HEFXXX rule or web forum answer. In
some cases we had to synthesize more than one F IXIT rule to cap-
ture the different possible behaviors of a single rule in T HEFXXX.
For example, one can try adding â€˜sudoâ€™ in front of a command for
several possible errors such as â€œCommand not foundâ€, â€œYou donâ€™t
have the permission" etc. In such cases, thanks to the partitioning
algorithm, N OFAQ generated a separate rule for each possible er-
ror message. For each case where we synthesized a rule, correctness
9 2018/10/1405101520253035
1 11 21 31 41 51 61 71 81Size of the Expressions
BenchmarksDistribution of Cmd, Err, Fix Expr Size
CmdSize ErrSize FixSizeFigure 10: The distribution of benchmarks in terms of individual
sizes of scmd,serr, and sfixexpressions in the examples.
was independent of our choice of examples. If the correct rule was
synthesized, it was synthesized regardless of which subset of the
examples provided for that rule we selected.
Distribution of rule sizes We deï¬ne the size of an expression
such as scmd,serr, and sfixas the number of strings present in
it. The distribution of the size of the benchmarks in terms of the
sizes of the scmd,serr, and sfixtuples in input-output examples is
shown in Figure 10. Note that we do not show two benchmarks in
the graph with disproportionately high serrexpression size of 110
for clarity. The average total size of the examples in the benchmarks
was15:9117:185, with the maximum size of 116. The average
sizes for the individual expressions of the examples were: i) scmd:
2:381:01with maximum of 6, ii)serr:10:1216:85with a
maximum of 110, and iii) sfix:3:411:55with a maximum of 7.
Distribution of rule matching For each set of example provided
for an individual rule, we isolated one example to measure the accu-
racy of the tool. All the test examples were correctly described by at
least one of the synthesized rules. For the majority of the test cases,
there was exactly one rule which matched both the command and
error message. The remaining 12test cases which matched against
multiple rules came from collections of example sets which repre-
sented different ï¬xes of the same command and error messages.
Total test cases 81
Test cases matched by one rule 69
Test cases matched by multiple rules 12
Ranking Consistent with our hypothesis in Section 6.1.2, a di-
verse set of examples was sufï¬cient for eliminating spurious re-
strictions and substring expressions. In every test case, the rule cho-
sen by our ranking policy was capable of correcting all test cases
presented. In practice, many rules still have several possible cor-
rect S UB-LRexpressions. However, this remaining ambiguity oc-
curs because the same string can appear many times in the com-
mand and error message (e.g., the string Employee in the example
in Section 2.1).
6.2.3 Quantitative evaluation
We now report on the quantitative metrics of our synthesis algo-
rithm. In this section we only report data for the 81 benchmarks for
which N OFAQ can successfully synthesize a F IXIT rule.
5We use asto denote an average awith standard deviation s.
05001,0001,5002,000
121314151617Synthesis	 Â Time	 Â in	 Â secondsSize	 Â of	 Â Largest	 Â GroupEager	 Â vs	 Â Lazy	 Â VSAEager	 Â VSALazy	 Â VSAEnumerating	 Â PartitionsFigure 11: Synthesis times for different benchmarks for the lazy
and non-lazy rule representations.
Evaluation of lazy VSA synthesis time In Figure 11, we show
the time taken to partition and synthesize F IXIT rules for the 81
benchmarks, using both the lazy and a non-lazy rule representation,
as the number of examples per benchmark increases. The non-
lazy representation always considers match and ï¬x expressions as
variables, rather than initially starting with constants.
To test the performance of the lazy and non-lazy representations
as the size of the input set increases, we iteratively increase the size
of the training set. For each test, we add a single example to one
of the benchmarks and then attempt synthesis. We plot the syn-
thesis time with respect to the largest set of examples for which we
must enumerate possible partitions until we successfully synthesize
rules. To understand the performance overhead induced by synthe-
sis, we also evaluate a version of the algorithm which enumerates
partitions without performing synthesis. For each algorithm, we it-
eratively increased the training set size until the algorithm reached
a2;000second timeout.
The non-lazy VSA incurs a signiï¬cant overhead, and scales
much worse than the lazy version, reaching the timeout when the
largest set has 14 examples. The lazy VSA, in contrast, is much
closer to the optimum; the synthesis time is negligible compared
to the inherent cost of enumerating all partitions of a set. In fact,
the lazy synthesis actually completes faster than exhaustive enu-
meration. This is reasonable, as the ï¬rst partitioning which yields
a successful F IXIT rule for all subsets tends to be somewhere near
the middle of the enumeration, and thus does not incur the cost of
enumerating the remainder of the search space. In summary, the
lazy VSA strictly outperforms non-lazy VSA and can handle much
larger sets of examples.
SUB-LRexpression in synthesized rules The distribution of
FSTR and S UB-LRexpressions in the synthesized F IXIT rules is
shown in Figure 12. The output components of the synthesized rule
contain on average 29:01%24:4%SUB-LRexpressions. Con-
cretely, a synthesized rule contains on average 0:910:76SUB-LR
expressions.
Synthesis time vs. number of SUB-LRexpressions The synthe-
sis time for different numbers of S UB-LRexpressions in the repair
rule is shown in Figure 13. As expected, the benchmarks that do not
contain S UB-LRexpressions take negligible time. The benchmarks
involving two S UB-LRexpressions on average require more time
than the benchmarks with a single S UB-LRexpression. Interest-
ingly, the benchmarks with 3 S UB-LRexpressions take lesser time
than the benchmarks with 2 S UB-LRexpressions. A possible expla-
nation for this behavior is that the complexity of substring extrac-
tion tasks for these benchmarks is relatively simpler (e.g. identity)
than the benchmarks with 2 S UB-LRexpressions.
10 2018/10/14012345678
1 11 21 31 41 51 61 71 81Size of the Fix Expression
Benchmarks# of S ubLR and FS trExprs in Fix Exprs
FStr SubLRFigure 12: The distribution of F STRand S UB-LRexpressions in the
ï¬nal synthesized repair expression.
050100150200250300350400450
0 1 2 3Learning Time (in ms)
Number of SubLR Expressions in Fix ExprSYNTH RULES Time vs # SubLR Exprs
Figure 13: Synthesis times for varying number of S UB-LRexpres-
sions in the repair rule.
Scalability of synthesis algorithm with example size Since all
real-world examples we collected are relatively of small size (with
maximum size of 116 space-separated strings), we evaluate the
scalability of the S YNTH RULES algorithm by creating artiï¬cial
examples of increasing sizes. We create these artiï¬cial examples by
repeating the scmd,serr, andsfixcommands multiple times for the
example shown in Section 2.2. The synthesis times for increasing
size of examples is shown in Figure 14. From the graph, we observe
that the synthesis times scale in a quadratic fashion with respect to
the example size.
7. Limitations
We showed that the language F IXIT is able to express many real-
world command line repair rules and that these rules can be synthe-
sized using few examples. We now present some limitations of our
approach, in particular with respect to the 11 T HEFXXX rules that
FIXIT could not describe.
Complex patterns Two rules were checking complex properties
of the input that F IXIT cannot capture. For example, F IXIT
cannot check whether the error message contains some special
character. F IXITâ€™s conditional matching is limited to whole
string or preï¬x/sufï¬x matching, and thus cannot check if e.g.
a ï¬le name contains a non-unicode whitespace character. All
character relative logic occurs in the substring generation after
010002000300040005000
7 77 147 217 287 357Learning Time (in ms)
Number of Expressions in ExamplesSYNTH RULEtime vs # Example ExprsFigure 14: Synthesis times with increasing size of examples.
input matching. F IXIT also cannot check whether some string
in the input command is repeated more than once.
Context-dependencies Eight rules had hard-coded operations that
were searching some context (the ï¬le system, a conï¬guration
ï¬le, etc.) for speciï¬c strings to complete the output. F IXIT only
receives as inputs the command and the error message, and the
rules currently cannot use any context.
8. Related work
Version-space algebra for synthesis The concept of Version-
space algebra (VSA) was ï¬rst introduced by Mitchell [17] in the
context of machine learning and was later used by Lau et al. to
learn programs from demonstrations in a Programming By Ex-
amples/Demonstrations system called SmartEdit [11]. It has since
been used for many PBE systems from various domains including
syntactic string transformations in FlashFill [7], table transforma-
tions [9, 25], number transformations [24], text extraction from
semi-structured text ï¬les in FlashExtract [12], and transformation
of semi-structured spreadsheets to relational tables in FlashRe-
late [2]. Our synthesis algorithm also uses VSA to succinctly rep-
resent a large set of conforming expressions. However, in contrast
to previous approaches that represent all conforming expressions
concretely and then use intersection for reï¬nement, our synthesis
algorithm maintains a lazy representation of rules and concretizes
the choices on demand in a lazy fashion only when it is needed.
Moreover, our careful design of DSL operators and the correspond-
ing VSA in N OFAQ lead to a polynomial time synthesis algorithm
unlike most previous approaches that have exponential time syn-
thesis algorithms.
In particular, it is illustrative to compare the FlashFill DSL with
FIXIT. While, like F IXIT, FlashFill synthesizes string manipula-
tions from input-output examples, speciï¬c performance properties
make it less suitable for large scale learning from large sample sets.
Prior to developing N OFAQ, we evaluated the possibility of sim-
ply using the FlashFill algorithm as-is for our purpose of learning
command repair rules. Early empirical results indicated that the off-
the-shelf algorithm scaled poorly as the error messages increased
in length, which was a common occurrence for our benchmarks.
Moreover, other limitations of no offset operator in position expres-
sions and support for ï¬nite hard-coded regular expression tokens
made FlashFill unsuitable for learning S UB-LRexpressions.
We isolated several theoretical properties of FlashFillâ€™s key op-
erators which yielded poor performance on large inputs. In partic-
ular, the binary concatenation operator over arbitrary substrings of
11 2018/10/14the entire input string induces a DAG structure for the symbolic
representation of programs. More explicitly, given an example out-
put stringS, there exists a node npfor each position pinS. An
edge fromnpton0
p,p<p0represents the substring S[p:p0]. Each
edge is labelled with the set Fof functions over the example inputs
which yield the substring. Thus, a path from n0tonjSjrepresents
some concatenation of the output of several string operations which
yields the desired output. Given a DAG Dconsistent with a set of
examplesE, FlashFill incorporates a new example erepresented by
DAGD0by taking the cartesian product of the vertices of Dand
D0, to construct a new DAG D00. An edge with label set F00in the
new DAG represents a set of functions which were part of a correct
program for the examples E, and also map from the inputs of eto
a substring of eâ€™s output. The iterated cartesian products yield time
complexity exponential in the number of examples.
FIXIT, in contrast, posesses unary string operations constrained
to speciï¬c variable terms. F IXITâ€™s unary S UB-LRoperator yields
a language that is disjoint from FlashFill with concatenation re-
moved; we obtain a language expressive enough for a large set of
practical command repair transformations isolated from real use
cases, while dramatically improving worst-case performance. The
constrained nature of the program representation lets the synthe-
sis algorithm eliminate programs inconsistent with a new example
without directly computing the intersection of two sets of candi-
date programs, ensuring polynomial-time performance even in the
worst case. Moreover, F IXIT also allows for repair transformations
that require arbitrary offsets from a regex match, which are not ex-
pressible in the FlashFill DSL.
Programming by Examples (PBE) PBE has been an active re-
search area in the AI and HCI communities from a long time [15].
In addition to VSA-based data wrangling [8], PBE techniques have
recently been developed for various domains including interactive
synthesis of parsers [14], synthesis of recursive functional pro-
grams over algebraic data types [4, 18], synthesizing sequence
of program refactorings [20], imperative data structure manipula-
tions [26], and network policies [31]. Our technique also learns re-
pair rules from few input-output examples of buggy and ï¬xed com-
mands, but both our problem domain of learning command repairs
and the learning techniques of using lazy VSA are quite different
from these PBE systems.
Program repair Research in automated program repair focuses
on automatically changing incorrect programs to make them meet a
desired speciï¬cation [6]. The main challenge is to efï¬ciently search
the space of all programs to ï¬nd one that behaves correctly. The
most prominent search techniques are enumerative or data-driven.
GenProg uses genetic programming to repeatedly alter the incor-
rect program in the hope to make it correct [13]. Data-driven ap-
proaches use the large amount of code that is publicly available
online to synthesize likely changes to the input program [21, 30].
Prophet [16] is a patch generation system that learns a probabilistic
application-independent model of correct code from a set of suc-
cessful human patches. Unlike these techniques that learn a global
model of code repair across different applications, our technique
learns command-speciï¬c repairs by observing how expert users ï¬x
their buggy commands â€” i.e., from both the incorrect command
the user started with (together with the error message) and the cor-
rect command she wrote as a ï¬x.
Crowdsourced Repairs HelpMeOut is a social recommender sys-
tem that helps novice users facing programming errors by showing
them examples of how other programmers have corrected similar
errors [10]. While HelpMeOut can show examples of similar ï¬xes
it does not concretely show the user how the code should be cor-
rected. This aspect is the major difference between HelpMeOut and
NOFAQ.THEFXXX provides a Python interface for command substitu-
tion and repair rules, and it requires a degree of language and tool-
speciï¬c knowledge that may not be accessible to command line
novices, particularly if non-trivial substring operations are required
to derive the desired command. Much like FlashFill, we aim to em-
ulate the workï¬‚ow of non-technical users communicating with ex-
perts on web forums. For a beginner learning the command line,
Python string manipulations are likely a fairly challenging task, and
the cost of an incorrectly transformed shell command is potentially
catastrophic. In such a situation where a non-expert desires a new
THEFXXX rule, such a user may provide an example of several
command/error pairs, and the desired ï¬x for each, from which an
expert would write the desired Python code. NoFAQ shortens this
loop by moving the ï¬x synthesis into a polynomial time algorithm
on the userâ€™s machine.
Rule learning Rules provide a simple way to represent program-
mers actions and in general any type of data transformation. Rule
learning has been extensively investigated in classical machine
learning and data mining [5]. The goal of rule learning is to discover
and mine rules describing interesting relations appearing in data.
Common concept classes for describing rules are Horn clauses or
association rules [19]. The approach presented in this paper dif-
fers from rule learning in two aspects: 1) the rules are expressed in
a complex concept class and are hard to learn â€” i.e., F IXIT pro-
grams; 2) the examples are given by a teacher that has in mind a
target rule. In the future we plan to build a system that uses rule
learning techniques to mine F IXIT rules from unsupervised data.
Program synthesis There has been a resurgence in Program
Synthesis research in recent years [1]. In addition to examples
(as described above), there have been several techniques devel-
oped for handling other forms of speciï¬cations such as partial
programs [27, 28], reference implementations [23], and concrete
traces [29]. While these speciï¬cation mechanisms have been found
to be useful in several domains, we believe examples are the most
natural mechanism for specifying command line repairs especially
for beginners. There is also a recent movement towards using
data-driven techniques for synthesis [22], e.g. the PLINY project
(http://pliny.rice.edu/index.html ). In future, we envision
our system to also make use of large number of examples of buggy
commands and their corresponding repairs to learn a big database
of F IXIT rules.
9. Conclusion and Future Directions
We presented a tool N OFAQ that suggests possible ï¬xes to com-
mon buggy commands by learning from examples of how experts
ï¬x such issues. Our language design walks a ï¬ne line between ex-
pressivity and performance: by careful choice of unary operators
over pre-deï¬ned variables, and exclusion of arbitrary substring op-
erations, we avoid exponential-time worst case performance, while
still maintaining a useful degree of functionality. N OFAQ was able
to instantly synthesize 85% of the rules appearing in the popular
repair tool T HEFXXX and 16 other rules from online help forums.
Although N OFAQ tool is aimed towards repairing commands, we
believe our novel combination of synthesis and rule-based program
repair is quite general and is applicable in many other domains as
well. We plan to to apply this methodology to more complex tasks,
such as correcting syntax errors in source code, applying code op-
timization, and editing conï¬guration ï¬les. In the future, we hope
to create a tool which can take large command histories from ex-
pert users and quickly derive rules, as well as synthesize new rules
online as experts use the shell.
12 2018/10/14References
[1] R. Alur, R. BodÃ­k, E. Dallal, D. Fisman, P. Garg, G. Juniwal, H. Kress-
Gazit, P. Madhusudan, M. M. K. Martin, M. Raghothaman, S. Saha,
S. A. Seshia, R. Singh, A. Solar-Lezama, E. Torlak, and A. Udupa.
Syntax-guided synthesis. In Dependable Software Systems Engineer-
ing, pages 1â€“25. 2015.
[2] D. W. Barowy, S. Gulwani, T. Hart, and B. Zorn. Flashrelate: Ex-
tracting relational data from semi-structured spreadsheets using exam-
ples. In Proceedings of the 36th ACM SIGPLAN Conference on Pro-
gramming Language Design and Implementation , PLDI 2015, pages
218â€“228, New York, NY , USA, 2015. ACM. ISBN 978-1-4503-3468-
6. doi: 10.1145/2737924.2737952 . URL http://doi.acm.org/
10.1145/2737924.2737952 .
[3] S. M. Doane, D. S. McNamara, W. Kintsch, P. G. Polson, and D. M.
Clawson. Prompt comprehension in unix command production. Mem-
ory & cognition , 20(4):327â€“343, 1992.
[4] J. K. Feser, S. Chaudhuri, and I. Dillig. Synthesizing data structure
transformations from input-output examples. In Proceedings of the
36th ACM SIGPLAN Conference on Programming Language Design
and Implementation, Portland, OR, USA, June 15-17, 2015 , pages
229â€“239, 2015. doi: 10.1145/2737924.2737977 . URL http:
//doi.acm.org/10.1145/2737924.2737977 .
[5] J. Furnkranz, D. Gamberger, and N. Lavrac. Rule learning in a
nutshell. In Foundations of Rule Learning , Cognitive Technologies,
pages 19â€“55. Springer Berlin Heidelberg, 2012. ISBN 978-3-540-
75196-0. doi: 10.1007/978-3-540-75197-7_2 . URL http://
dx.doi.org/10.1007/978-3-540-75197-7_2 .
[6] C. Goues, S. Forrest, and W. Weimer. Current challenges in automatic
software repair. Software Quality Journal , 21(3):421â€“443, Sept. 2013.
ISSN 0963-9314. doi: 10.1007/s11219-013-9208-0 . URL http:
//dx.doi.org/10.1007/s11219-013-9208-0 .
[7] S. Gulwani. Automating string processing in spreadsheets using input-
output examples. In Proceedings of the 38th Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages , POPL
â€™11, pages 317â€“330, New York, NY , USA, 2011. ACM. ISBN 978-
1-4503-0490-0. doi: 10.1145/1926385.1926423 . URL http:
//doi.acm.org/10.1145/1926385.1926423 .
[8] S. Gulwani, W. R. Harris, and R. Singh. Spreadsheet data manip-
ulation using examples. Commun. ACM , 55(8):97â€“105, Aug. 2012.
ISSN 0001-0782. doi: 10.1145/2240236.2240260 . URL http:
//doi.acm.org/10.1145/2240236.2240260 .
[9] W. R. Harris and S. Gulwani. Spreadsheet table transformations from
examples. In Proceedings of the 32nd ACM SIGPLAN Conference
on Programming Language Design and Implementation, PLDI 2011,
San Jose, CA, USA, June 4-8, 2011 , pages 317â€“328, 2011. doi: 10.
1145/1993498.1993536 . URL http://doi.acm.org/10.1145/
1993498.1993536 .
[10] B. Hartmann, D. MacDougall, J. Brandt, and S. R. Klemmer. What
would other programmers do: Suggesting solutions to error mes-
sages. In Proceedings of the SIGCHI Conference on Human Fac-
tors in Computing Systems , CHI â€™10, pages 1019â€“1028, New York,
NY , USA, 2010. ACM. ISBN 978-1-60558-929-9. doi: 10.
1145/1753326.1753478 . URL http://doi.acm.org/10.1145/
1753326.1753478 .
[11] T. Lau, S. A. Wolfman, P. Domingos, and D. S. Weld. Pro-
gramming by demonstration using version space algebra. Mach.
Learn. , 53(1-2):111â€“156, Oct. 2003. ISSN 0885-6125. doi: 10.
1023/A:1025671410623 . URL http://dx.doi.org/10.1023/
A:1025671410623 .
[12] V . Le and S. Gulwani. Flashextract: A framework for data extraction
by examples. In Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and Implementation , PLDI â€™14,
pages 542â€“553, New York, NY , USA, 2014. ACM. ISBN 978-1-
4503-2784-8. doi: 10.1145/2594291.2594333 . URL http://
doi.acm.org/10.1145/2594291.2594333 .
[13] C. Le Goues, M. Dewey-V ogt, S. Forrest, and W. Weimer. A sys-
tematic study of automated program repair: Fixing 55 out of 105
bugs for $8 each. In Proceedings of the 34th International Confer-ence on Software Engineering , ICSE â€™12, pages 3â€“13, Piscataway,
NJ, USA, 2012. IEEE Press. ISBN 978-1-4673-1067-3. URL http:
//dl.acm.org/citation.cfm?id=2337223.2337225 .
[14] A. Leung, J. Sarracino, and S. Lerner. Interactive parser synthesis
by example. In Proceedings of the 36th ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation, Port-
land, OR, USA, June 15-17, 2015 , pages 565â€“574, 2015. doi: 10.
1145/2737924.2738002 . URL http://doi.acm.org/10.1145/
2737924.2738002 .
[15] H. Lieberman. Your wish is my command: Programming by example .
Morgan Kaufmann, 2001.
[16] F. Long and M. Rinard. Automatic patch generation by learning
correct code. In Proceedings of the 43rd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages , POPL
2016, pages 298â€“312, 2016.
[17] T. M. Mitchell. Generalization as search. Artif. Intell. , 18(2), 1982.
[18] P. Osera and S. Zdancewic. Type-and-example-directed program
synthesis. In Proceedings of the 36th ACM SIGPLAN Confer-
ence on Programming Language Design and Implementation, Port-
land, OR, USA, June 15-17, 2015 , pages 619â€“630, 2015. doi: 10.
1145/2737924.2738007 . URL http://doi.acm.org/10.1145/
2737924.2738007 .
[19] G. Piatetsky-Shapiro. Discovery, analysis and presentation of strong
rules. In G. Piatetsky-Shapiro and W. J. Frawley, editors, Knowledge
Discovery in Databases , pages 229â€“248. AAAI Press, 1991.
[20] V . Raychev, M. SchÃ¤fer, M. Sridharan, and M. T. Vechev. Refac-
toring with synthesis. In Proceedings of the 2013 ACM SIGPLAN
International Conference on Object Oriented Programming Systems
Languages & Applications, OOPSLA 2013, part of SPLASH 2013,
Indianapolis, IN, USA, October 26-31, 2013 , pages 339â€“354, 2013.
doi:10.1145/2509136.2509544 . URL http://doi.acm.org/
10.1145/2509136.2509544 .
[21] V . Raychev, M. Vechev, and E. Yahav. Code completion with sta-
tistical language models. In Proceedings of the 35th ACM SIG-
PLAN Conference on Programming Language Design and Implemen-
tation , PLDI â€™14, pages 419â€“428, New York, NY , USA, 2014. ACM.
ISBN 978-1-4503-2784-8. doi: 10.1145/2594291.2594321 . URL
http://doi.acm.org/10.1145/2594291.2594321 .
[22] V . Raychev, M. T. Vechev, and A. Krause. Predicting program prop-
erties from "big code". In Proceedings of the 42nd Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Lan-
guages, POPL 2015, Mumbai, India, January 15-17, 2015 , pages
111â€“124, 2015. doi: 10.1145/2676726.2677009 . URL http:
//doi.acm.org/10.1145/2676726.2677009 .
[23] E. Schkufza, R. Sharma, and A. Aiken. Stochastic superoptimization.
InArchitectural Support for Programming Languages and Operating
Systems, ASPLOS â€™13, Houston, TX, USA - March 16 - 20, 2013 ,
pages 305â€“316, 2013. doi: 10.1145/2451116.2451150 . URL
http://doi.acm.org/10.1145/2451116.2451150 .
[24] R. Singh and S. Gulwani. Synthesizing number transformations from
input-output examples. In Proceedings of the 24th International Con-
ference on Computer Aided Veriï¬cation , CA Vâ€™12, pages 634â€“651,
Berlin, Heidelberg, 2012. Springer-Verlag. ISBN 978-3-642-31423-0.
doi:10.1007/978-3-642-31424-7_44 . URL http://dx.doi.
org/10.1007/978-3-642-31424-7_44 .
[25] R. Singh and S. Gulwani. Learning semantic string transformations
from examples. Proc. VLDB Endow. , 5(8):740â€“751, Apr. 2012. ISSN
2150-8097. doi: 10.14778/2212351.2212356 . URL http://dx.
doi.org/10.14778/2212351.2212356 .
[26] R. Singh and A. Solar-Lezama. Synthesizing data structure manipula-
tions from storyboards. In SIGSOFT FSE , pages 289â€“299, 2011.
[27] A. Solar-Lezama. Program Synthesis By Sketching . PhD thesis, EECS
Dept., UC Berkeley, 2008.
[28] A. Solar-Lezama, R. Rabbah, R. Bodik, and K. Ebcioglu. Program-
ming by sketching for bit-streaming programs. In PLDI , 2005.
[29] A. Udupa, A. Raghavan, J. V . Deshmukh, S. Mador-Haim, M. M. K.
Martin, and R. Alur. TRANSIT: specifying protocols with concolic
13 2018/10/14snippets. In ACM SIGPLAN Conference on Programming Language
Design and Implementation, PLDI â€™13, Seattle, WA, USA, June 16-19,
2013 , pages 287â€“296, 2013. doi: 10.1145/2462156.2462174 . URL
http://doi.acm.org/10.1145/2462156.2462174 .
[30] M. Yakout, A. K. Elmagarmid, J. Neville, M. Ouzzani, and I. F.
Ilyas. Guided data repair. Proc. VLDB Endow. , 4(5):279â€“289, Feb.
2011. ISSN 2150-8097. doi: 10.14778/1952376.1952378 . URL
http://dx.doi.org/10.14778/1952376.1952378 .
[31] Y . Yuan, R. Alur, and B. T. Loo. Netegg: Programming network poli-
cies by examples. In Proceedings of the 13th ACM Workshop on Hot
Topics in Networks, HotNets-XIII, Los Angeles, CA, USA, October 27-
28, 2014 , pages 20:1â€“20:7, 2014. doi: 10.1145/2670518.2673879 .
URL http://doi.acm.org/10.1145/2670518.2673879 .
A. Proofs of Theorems 1, 2, and 3
We ï¬rst deï¬ne a notion of completeness for a symbolic rule. Intu-
itively a symbolic rule has to summarize all possible correct rules
to be complete.
Deï¬nition 6 (Command-string completeness) .Let
r=matchcmd anderr!sfixes
be a symbolic rule such that cmd = [c1;:::;ca],
err= [m1;:::;mb],fixes = [f1;:::;fc], andE= [e1;:::;en]
a sequence of examples. We say that cmd is complete for E
and produces variables V1,CompC (cmd;E;V 1)iff for every
1ia:
ci=Str(s)(for somes) iff every example (scmd;serr;sfix)in
Eis such that scmd= [s1;:::;sk], for somek, andsj=s.
ci=Var-Match (j;l;r )iffi2V,i=j, and there exists two
examples (s1
cmd;s1
err;s1
fix)and(s2
cmd;s2
err;s2
fix)inEsuch
thats1
cmd= [s1;:::;sk],s2
cmd= [s0
1;:::;s0
k], for somek,
andsj6=s0
j.
Ifci= Var-Match (j;l;r ), then for every example
(scmd;serr;sfix)inEwhere scmd= [s1;:::;sk],lis a preï¬x
ofsj. Moreover,lis the longest such preï¬x.
Ifci= Var-Match (j;l;r ), then for every example
(scmd;serr;sfix)inEwhere scmd = [s1;:::;sk],ris a
sufï¬x ofsj. Moreover,ris the longest such sufï¬x.
Deï¬nition 7 (Error-string completeness) .Analogously, we say that
err is complete for E and produces variables V2,
CompE (err;E;V 2), iff for every 1ib:
mi=Str(s)(for somes) iff every example (scmd;serr;sfix)
inEis such that scmd= [s1;:::;sk], for somek, andsj=s.
mi=Var-Match (j;l;r )iffi2V,i+a=j, and there exists
two examples (s1
cmd;s1
err;s1
fix)and(s2
cmd;s2
err;s2
fix)inE
such that s1
err= [s1;:::;sk],s2
err= [s0
1;:::;s0
k], for somek,
andsi6=s0
i.
Ifmi=Var-Match (j;l;r ), andi+a=j, then for every
example (scmd;serr;sfix)inEwhere serr= [s1;:::;sk],l
is a preï¬x of si. Moreover,lis the longest such preï¬x.
Ifmi=Var-Match (j;l;r ), andi+a=jthen for every
example (scmd;serr;sfix)inEwhere serr= [s1;:::;sk],
ris a sufï¬x of si. Moreover,ris the longest such sufï¬x.
Deï¬nition 8 (Input completeness) .If bothCompC (cmd;E;V 1)
andCompE (err;E;V 2)hold we say that cmd anderrare com-
plete for E and produce variables V1[V2,
Comp (cmd;err;E;V 1[V2).
Deï¬nition 9 (Partialfi-completeness) .We say thatfiis partially
complete,PCompFi (fi;E;i), with respect to Eif the following
condition holds: fi= [Fstr(s)](for somes) iff every example
(scmd;serr;sfix)inEis such that sfix= [s1;:::;sk], for somek, andsi=s. If for every 1ic,PCompFi (fi;E;i)holds,
then we say that that fixes is partially complete with respect to V,
PCompF (fixes;E ).
Deï¬nition 10 (fi-completeness) .If there exists a V=fi1;:::;ijg
such thatComp (cmd;err;E;V )we say thatfiis complete with
respect toVat positioni,CompFi (fi;E;V;i ), iff:
PCompFi (fi;E;i).
fi= [t1;:::;tm]such that for all ind,tind6=Fstr(s)(for any
s) iff the following properties hold.
For everyindmandlk,JtindKfun
l= sl
fix[i](where
for allyj,l(iy) = (sl
cmd@sl
err)[iy]).
If there exists a Sub-lr functiontsuch that for every indn
andlk, ,JtKfun
l= sl
fix[i](where for all yj,
l(iy) = (sl
cmd@sl
err)[iy]), then there exists xmsuch
thattx=t.
Deï¬nition 11 (Fix completeness) .If for every 1ic,
CompFi (fi;E;V;i )holds, then we say that that fixes is com-
plete with respect to V,CompF (fixes;E;V ).
Deï¬nition 12 (Rule completeness) .If there is a Vsuch that
Comp (cmd;err;E;V )andCompF (fixes;E;V ), we say that
ris complete for E,CompR (r;E).
Notice that for any permutation E0ofE CompR (r;E)iff
CompR (r;E0).
Proposition 13 (CompR andcon).LetEa sequence of examples
andr=matchcmd anderr!sfixes be a symbolic rule. If
CompR (r;E)then every concrete rule r02con(r)is consistent
with any example in E. Moreover, for every (non-symbolic) rule
r1=matchcmd anderr![t1;:::;tn]
consistent with E= [(s1
cmd;s1
err;s1
fix);:::; (sn
cmd;sn
err;sn
fix)]
the following is true: if for every i,ti6=Fstr(s)iff for some
j1;j2nsj1
fix[i]6= sj2
fix[i], thenr12con(r).
Proof. Immediate from Deï¬nition 12 and the deï¬nition of con.
More speciï¬cally, assume there is some r02con(r)not con-
sistent with an example e2E. The only way it can be inconsistent
withscmd orserris if some match expression in cmd orerris a
ï¬xed string not equal to some string in scmd orserr. Deï¬nition 8
precludes this possibility.
Similarly, it follows from Deï¬nition 9 that if one of the ï¬x
expressions is a constant string, then it is consistent with every
example ï¬x. By Deï¬nition 10, if it is a set of S UB-LRexpressions,
then each one is consistent with every example.
We now show that S YNTH SUBSTRING and S YNTH FIXhave the
intended behaviour with respect to Deï¬nition 12.
Lemma 14 (Correctness of S YNTH SUBSTRING ).Let
E= [(s1
cmd;s1
err;s1
fix);:::; (sn
cmd;sn
err;sn
fix)]be a sequence
of examples where every sv
fixhas lengthm,V=fi1;:::;ijg
be a set of variables, and imbe an index in the out-
put ï¬x. If there exist aandbsuch that sa
fix[i]6= sb
fix[i], then
SynthSubstring (E;V;i ) =SiffComp (S;E;V;i ).
Proof. This lemma states that S YNTH SUBSTRING returns all the
SUB-LRfunctions consistent with the given examples. Again the
proof is by induction on the length of E. The base casejEj= 1
follows from the deï¬nition of A LLSUBSTRINGS . The inductive
step is also trivial: S YNTH SUBSTRING simply runs all the functions
computed so far on the added example and ï¬lters out those that are
not consistent with it. Since, by IH, the varaible Fwas correct at
14 2018/10/14the beginning of the loop, it remains correct. Notice that the order
of the examples does not matter.
Lemma 15 (Correctness of S YNTH FIX).LetS= [s1;:::;sn]be
a list of strings, T= [t1;:::;tn]be a sequence of symbolic ï¬x
expressions,
E= [(s1
cmd;s1
err;s1
fix);:::; (sn
cmd;sn
err;sn
fix)]
be a sequence of examples where every sv
fixhas lengthm,e=
(scmd;serr;sfix)be an example such that for each 1in,
sfix[i] =si, andVbe a set of variables. If PCompF (T;E),
then SynthFix (S;T;e ::E;V) =fixes iffCompF (fixes;e ::
E;V).
Proof. Immediate by induction on mand by using Lemma 14 at
each step.
As S YNTH FIXiterates over each string in the example ï¬x, and
compares it to the corresponding ï¬x expression, we can see that
the only interesting case of the proof is when tiis either a ï¬xed
string not equal to the correpsonding sn+1
fix[i]ine, ortiis a set
of S UB-LRexpressions. In this case, correctness follows directly
from Lemma 14, as S YNTH FIXcalls S YNTH SUBSTRING to reï¬ne
the set of substring operation to those generating sn+1
fix[i]as well as
all other sfix[i]values.
Next we show the correctness of R EFINE RULE and F INDVARI-
ABLES .
Lemma 16 (Correctness of F INDVARIABLES ).Let
E= [(s1
cmd;s1
err;s1
fix);:::; (sn
cmd;sn
err;sn
fix)]be a sequence of
examples, and cmd anderrbe two sequences of match expressions
of lengthsjsi
cmdjandjsi
errjrespectively. If there exists two sets of
variablesV1andV2such thatCompC (cmd;E [1 :: (n 1)];V1)
andCompE (err;E [1 :: (n 1)];V2), then
if(cmd0;V0
1) = FindVariables (sn
cmd;cmd; 0), then
CompC (cmd0;E;V0
1).
if(err0;V0
2) = FindVariables (sn
err;err;jsi
cmdj), then
CompE (err0;E;V0
2).
Proof. The two statements can be proved separately but the proof is
identical. The proofs are both by induction on the length of the ï¬rst
argument of F INDVARIABLES and are very simple case analysis
following Deï¬nitions 6 and 7.
W.L.O.G, consider the case for cmd .
Over a run of F INDVARIABLES , a S TR(s)incmd is only changed
if, at thenth iteration of the loop, cmd[i]is S TR(S)whereSis not
equal to sn
cmd[i]. In that case F INDVARIABLES introduces a new
variable match expression V AR-MATCH (i;l;r)wherelandrare
(respectively) the longest shared preï¬x and sufï¬x of Sandsn
cmd[i].
By the I.H,cmd was command complete. It follows directly from
Deï¬nition 6 that command completeness continues to hold.
A V AR-MATCH (i;l;r)incmd is only changed if, at iteration n,
the longest common preï¬x (sufï¬x), x, shared by sn
cmd[i]andl(r)
is not equal to l(r). In this case V AR-MATCH (i;l;r)is replaced
by V AR-MATCH (i;l0;r)(VAR-MATCH (i;l;r0)), wherer0(l0) is
equal to the common preï¬x (sufï¬x) x. By the I.H, lwas the longest
preï¬x (sufï¬x) shared by the ï¬rst n 1values of sk
cmd[i]. Clearly,
x=r0(l0) is the longest preï¬x (sufï¬x) shared by the ï¬rst n
values of sk
cmd[i]. Moreover, by the I.H. cmd satisï¬ed all other
criteria for command completeness. Thus, it follows that command
completeness continues to hold. It is clear that determining the
shorteset preï¬x and sufï¬x shared by every sk
cmd[i]does not depend
on the order in which the examples are presented.Lemma 17 (Correctness of R EFINE RULE).Letrbe a sym-
bolic rule,Ebe a sequence of examples, ebe an example, and
r0=Reï¬neRule (r;E;e ). IfCompR (r;E)thenCompR (r0;e::
E).
Proof. Immediate from Deï¬nition 12 and Lemmas 15 and 16.
Lemma 18 (Correctness of S YNTH RULES ).LetEbe a sequence
of examples. If r0=SynthRules (E)thenCompR (r;E).
Proof. By induction on the length of E. CasejEj= 1andE= [e]:
the result of C ONST RULE(e)clearly satisï¬es CompR (r;E). The
inductive step follows from Lemma 17.
We can now conclude the proofs of Theorems 1, 2, and 3. The-
orem 1 and 2 follow from the order invariance of CompR (r;E)
and from Proposition 13 and Lemmas 18.
Proof of Theorem 3 Let
E= [(s1
cmd;s1
err;s1
fix);:::; (sn
cmd;sn
err;sn
fix)]
be a sequence of examples,
SYNTH RULES (E) =r=matchcmd anderr!sfixes
be the symbolic rule for Eand
r0=matchcmd0anderr0!fix0
be a concrete rule that is consistent with all the examples in E. If
r0belongs to con(r)then we are done. Assume it doesnâ€™t.
Case 1.cmd =cmd0anderr =err0. Then by Propo-
sition 13 there exists some ti1;:::;tiksuch that each tivis of
the form S UB-LR(pv
L;pv
R;lv;rv;VAR(jv)), and for all jn
sj
fix[iv] =sfor somes(i.e., the output is a function of the in-
put, but all examples can be captured using a constant output).
In this case it is enough to create a new example e0starting from
any example (scmd;serr;sfix)2Ewhere for each ivwe modify
sjv= (scmd@serr)[jv]so that S UB-LR(pv
L;pv
R;lv;rv;VAR(jv))
now returns a value different from the previous one (this can be
done by simply adding a new character between pv
Landpv
R).sfix
is replaced by the result of applying r0to the modiï¬ed input.
Case 2.cmd@err6=cmd0@err0. This means that r0uses
more variables then r(notice that from Deï¬nition 12 the set of
variables used by r0is necessary). This can be ï¬xed by changing
the input of any example (scmd;serr;sfix)2E. For each variable
VAR(i)that is incmd0@err0but not incmd@errreplace the string
(scmd@serr)[i] =a1:::anwithba1:::anwherebis a symbol
not appearing in a1:::an.sfixis replaced by the result of applying
r0to the modiï¬ed input. If the rule is still not in con(r0)we can
then modify the example using the techniques from Case 1 since
nowcmd =cmd0anderr=err0.
15 2018/10/14