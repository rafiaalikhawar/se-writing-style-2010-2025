BinaryReduction ofDependency Graphs
ChristianGram Kalhauge
kalhauge@cs.ucla.edu
ComputerScienceDepartment
Universityof California,LosAngeles (UCLA)
LosAngeles,CA,USAJens Palsberg
palsberg@ucla.edu
ComputerScienceDepartment
Universityof California,LosAngeles (UCLA)
LosAngeles,CA,USA
ABSTRACT
Deltadebuggingis atechniqueforreducingafailure-inducingin-
puttoasmallinputthatrevealsthecauseofthefailure.Thishas
been successful for a wide variety of inputs including C programs,
XML data, and thread schedules. However, for input that has many
internaldependencies,deltadebuggingscalespoorly.Suchinput
includes C#, Java, and Java bytecode and they have presented a
major challenge for input reduction until now. In this paper, we
showthatthecorechallengeisareductionproblemfordependency
graphs,andwepresentageneralstrategyforreducingsuchgraphs.
WecombinethiswithanovelalgorithmforreductioncalledBinary
ReductioninatoolcalledJ-ReduceforJavabytecode.Ourexperi-
mentsshowthatourtoolis12xfasterandachievesmorereduction
than delta debugging on average. This enabled us to create and
submitshort bugreports for three Java bytecode decompilers.
CCS CONCEPTS
·Software and its engineering →Software testing and de-
bugging.
KEYWORDS
Debugging, dependencies,reduction
ACMReference Format:
Christian Gram Kalhauge and Jens Palsberg. 2019. Binary Reduction of
Dependency Graphs. In Proceedings of the 27th ACM Joint European Soft-
ware Engineering Conference and Symposium on the Foundations of Software
Engineering (ESEC/FSE ’19), August 26ś30, 2019, Tallinn, Estonia. ACM, New
York, NY, USA, 11pages.https://doi.org/10.1145/3338906.3338956
1 INTRODUCTION
Delta debugging automates a process that programmers otherwise
do by hand. Whena program crasheson aninput, the programmer
tries to understand the cause of the crash by reducing the input.
Intuitively, the programmer can cut the input in half and see if one
ofthetwohalvescausesthecrashaswell.Aftersomerepetitions
of this step, the input may be small enough for the programmer to
spotthecauseoftheproblem.Deltadebuggingexecutesamoread-
vancedversionofthis,automatically.Forexample,deltadebugging
Permissionto make digitalor hard copies of allorpart ofthis work for personalor
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.Copyrights forcomponentsofthisworkownedbyothersthanthe
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ESEC/FSE ’19, August 26ś30,2019, Tallinn,Estonia
©2019 Copyright heldby the owner/author(s). Publicationrightslicensed to ACM.
ACM ISBN 978-1-4503-5572-8/19/08...$15.00
https://doi.org/10.1145/3338906.3338956can map the original input to a nonconsecutive subsequence. Thus,
deltadebuggingrelievesprogrammersfromthetediumofreducing
andexecuting,andletsthemfocusonimprovingtheir programs.
In their seminal paper on delta debugging, Zeller and Hilde-
brandt [27] showed successful experiments in which the inputs
wereCprograms,Mozillauseractions,andUNIXcommands.Other
papershavereportedonexperimentswithXMLdata[ 19],thread
schedules[ 5],andeventsequences[ 11].Theproblemofreducing
failure-inducinginputtoaminimalsizeisNP-complete[ 19],and
foraninputwith ncharacters ,tryingall2nsubstringsmaybefutile.
Instead, the delta debugging algorithm ddmin [ 27] triesO(n2)sub-
strings. This led to massive success but when most natural subsets
of the input are invalid, most iterations of ddmin fail and are of
no help towards reduction. As a step towards scalability, Zeller
andHildebrandtshowedhowddmindoesbetterwhenappliedto
a list oflines. This is better than a character-oriented approach
because often a line of code represents a syntactic element such as
a statement. Misherghi and Su [ 19] went further and introduced
hierarchical delta debugging (HDD) that works with the syntactic
structure of the data. For example, for reduction of a method body,
HDD represents the body as a list of statements and runs ddmin
onthelist.Thisisbetterthanaline-orientedapproachbecausea
statementcanspanmultiplelines.Useofthesyntacticstructureen-
suresthateachinputissyntacticallyvalidandincreasesthechance
that eachrun produces useful information.
Inthispaperweconsiderthenextlevelofdifficulty,whicharises
when elements of the syntactic structure have many internal de-
pendencies . Such input includes C#, Java, and Java bytecode, where
a class may depend on other classes and where compilation and
bytecodeverificationrequirealldependenciestobepresent.Wecan
represent such a program as a list of classes and run ddmin on the
list,yetmostrunswillfailbecausetheinputisinvalid.Wesolvethis
bymodelingtheinternaldependenciesintheinputasa dependency
graphand then running reduction on a list of transitive closures in
thedependencygraph.Wewillshowexperimentswithreduction
byboth ddminandanovel algorithm calledBinary Reduction.
Intheremainderofthepaper,Section 2introducesthechallenge
indetail,after whichSections 3ś6present our contributions:
•We show that dependency graphs are a convenient data
structure for reduction, particularlybyddmin(Section 3).
•We present a new reduction algorithm, called Binary Reduc-
tionthat runsonly O(nlogn)iterations (Section 4).
•We evaluate on 238 Java bytecode programs that induce
failures in three decompilers. Binary Reduction on graphs is
12xfasterandreduces more thanddmin(Section 5).
•We submittedbugreports for the decompilers(Section 6).
Finally,Section 7discussesrelatedwork, andSection 8concludes.
556
ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia Christian GramKalhauge andJens Palsberg
2 THE CHALLENGE
We will explain the challenge of reducing input with dependencies
viaanexample.TheexampleconcernstheJavabytecodedecompiler
calledCFR( http://www.benf.org/other/cfr/ ).CFRtakesas inputa
valid Java bytecode program and decompiles it to a Java source
program. Thisis useful for programmers who want toinspect and
reasonaboutlibrariesthathavebeenshippedasbytecode.Ideally,a
decompiler produces source code that can be compiled to bytecode
such that the input bytecode and output bytecode are behaviorally
equivalent. When we look for bugs, we will use a more modest
quality measure: a decompiler should produce source code that
compiles.IfCFRmapsavalidbytecodeprogramtoasourceprogram
that doesn’tcompile,we say that CFR fails.
Wedefineavalidbytecodeprogramasasetofclass-filesthateach
individually verifies and depends only on classes in the program
itself or in the standard library. A class Adepends on another class
BifAmentions Banywhere in its bytecode. This can happen in
many places, such as in an extends-clause, in a type annotation, in
anew-expression,orinatype cast.
Our example begins with the discovery of a bug in CFR. We ran
CFR on a valid Java bytecode program with 17 classes and then we
ranjavaconthe producedsourceprogram,which ledtothis error
messagefrom javac:
... error: illegal start of expression
if (var2_3.hasNext()) ** break;
Now we would like to send a bug report to CFR, but it can be hard
tolocatethebugin17classes. Inthispaperwe focuson reducing
thebytecodeprogramtoonewith asubsetoftheclassesthatstill
induces CFR to fail with the same bug report. Thus, the reducer
picksclasseswithout changing them.
The task of reducing a set of classes to a smaller set of classes
isofthekindforwhichdeltadebuggingusuallyexcels.Weimple-
mentedthedeltadebuggingalgorithmcalled ddminbyZellerand
Hildebrandt [ 27] such that it works on a list of classes. However,
theresultofreducingourJavabytecodeprogramwith17classes
wasdisappointing:the result wasaprogram with14 classes.
Figure1illustrates our run of ddmin. The boxes and×’s show
whichclasseswereinputtoaniterationof ddmin,whilethecolumn
labeledfailshowswhetherCFRfailed(markedwith yes),succeeded
(marked with no), or whether the bytecode program was invalid
(marked with ?). In most cases, the input bytecode program is
invalidsotohighlightthefewstepswithvalidinputs,weuseboxes
inthosesteps.Specifically,whenCFRreproducesthebugweuse
□,andinallothercaseswithvalid inputswe use ■.
The many iterations with invalid bytecode programs inputs are
of no help towards reduction. Additionally, each invocation of CFR
andjavaccan take between a couple of seconds and multiple
minutes,whichdecreasesscalability.
Regehr et al. [ 21] identified this kind of problem in 2012 and
called it the test-case validity problem . They also identified two
kindsofsolutions, namely:
(1) detectinvalidinputsor
(2) avoid invalidinputs.
InthecontextofC,Regehretal.[ 21]usedtwotoolsto detectinvalid
code,whichledtoanexcellentreducer.However,theyleft avoiding
invalidcode as an open problem.00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 fail
× × × × × × × × × · · · · · · · · ?
· · · · · · · · · × × × × × × × × ?
× × × × × · · · · · · · · · · · · ?
· · · · · × × × × × · · · · · · · ?
· · · · · · · · · · × × × × × · · ?
· · · · · · · · · · · · · · · × × ?
· · · · · × × × × × × × × × × × × ?
× × × × × · · · · · × × × × × × × ?
× × × × × × × × × × · · · · · × × ?
□ □ □ □ □ □ □ □ □ □ □ □ □ □ □ · · yes
× × × × × · · · · · · · · · · · · ?
· · · · · × × × × × · · · · · · · ?
· · · · · · · · · · × × × × × · · ?
· · · · · × × × × × × × × × × · · ?
× × × × × · · · · · × × × × × · · ?
× × × × × × × × × × · · · · · · · ?
× × × · · · · · · · · · · · · · · ?
· · · × × × · · · · · · · · · · · ?
· · · · · · × × × · · · · · · · · ?
· · · · · · · · · × × × · · · · · ?
· · · · · · · · · · · · × × × · · ?
· · · × × × × × × × × × × × × · · ?
× × × · · · × × × × × × × × × · · ?
× × × × × × · · · × × × × × × · · ?
× × × × × × × × × · · · × × × · · ?
× × × × × × × × × × × × · · · · · ?
× × · · · · · · · · · · · · · · · ?
· · × × · · · · · · · · · · · · · ?
· · · · × × · · · · · · · · · · · ?
· · · · · · × × · · · · · · · · · ?
· · · · · · · · × × · · · · · · · ?
· · · · · · · · · · × × · · · · · ?
· · · · · · · · · · · · × × · · · ?
· · · · · · · · · · · · · · × · · ?
· · × × × × × × × × × × × × × · · ?
× × · · × × × × × × × × × × × · · ?
× × × × · · × × × × × × × × × · · ?
× × × × × × · · × × × × × × × · · ?
× × × × × × × × · · × × × × × · · ?
× × × × × × × × × × · · × × × · · ?
× × × × × × × × × × × × · · × · · ?
× × × × × × × × × × × × × × · · · ?
■· · · · · · · · · · · · · · · · no
· × · · · · · · · · · · · · · · · ?
· · × · · · · · · · · · · · · · · ?
· · · × · · · · · · · · · · · · · ?
· · · · × · · · · · · · · · · · · ?
· · · · · × · · · · · · · · · · · ?
· · · · · · × · · · · · · · · · · ?
· · · · · · · ■· · · · · · · · · no
· · · · · · · · × · · · · · · · · ?
· · · · · · · · · × · · · · · · · ?
· · · · · · · · · · × · · · · · · ?
· · · · · · · · · · · × · · · · · ?
· · · · · · · · · · · · × · · · · ?
· · · · · · · · · · · · · × · · · ?
· · · · · · · · · · · · · · × · · ?
·□ □ □ □ □ □ □ □ □ □ □ □ □ □ · · yes
· × · · · · · · · · · · · · · · · ?
· · × · · · · · · · · · · · · · · ?
· · · × · · · · · · · · · · · · · ?
· · · · × · · · · · · · · · · · · ?
· · · · · × · · · · · · · · · · · ?
· · · · · · × · · · · · · · · · · ?
· · · · · · · ■· · · · · · · · · no
· · · · · · · · × · · · · · · · · ?
· · · · · · · · · × · · · · · · · ?
· · · · · · · · · · × · · · · · · ?
· · · · · · · · · · · × · · · · · ?
· · · · · · · · · · · · × · · · · ?
· · · · · · · · · · · · · × · · · ?
· · · · · · · · · · · · · · × · · ?
· · × × × × × × × × × × × × × · · ?
· × · × × × × × × × × × × × × · · ?
· × × · × × × × × × × × × × × · · ?
· × × × · × × × × × × × × × × · · ?
· × × × × · × × × × × × × × × · · ?
· × × × × × · × × × × × × × × · · ?
· × × × × × × · × × × × × × × · · ?
· × × × × × × × · × × × × × × · · ?
· × × × × × × × × · × × × × × · · ?
· × × × × × × × × × · × × × × · · ?
· × × × × × × × × × × · × × × · · ?
· × × × × × × × × × × × · × × · · ?
· × × × × × × × × × × × × · × · · ?
· × × × × × × × × × × × × × · · · ?
·□ □ □ □ □ □ □ □ □ □ □ □ □ □ · ·
Figure 1: A detailed run of the example using unmodified
deltadebugging( ddmin).Therowsaretheiterationsof ddmin.
The columns identifies classes (represented using a num-
ber) in the input of each iteration: if a class is included it
ismarked with □,■,or×.
557Binary Reductionof Dependency Graphs ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
2 1 0
3 45
6
7 8
9 1011
1213 14 1516
Figure 2: The dependency graph of our example program.
Thenodesareclassesintheprogramandtheedgesrepresent
references to other classes. The class marked 1induces the
buginthedecompiler.
00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 fail
□ □ □ □ □ □ □ □ □ □ □ □ □ □ □ · · yes
■· · · · · · · · · · · · · · · · no
· · · · · · · ■· · · · · · · · · no
·□ □ □ □ □ □ □ □ □ □ □ □ □ □ · · yes
· · · · · · · ■· · · · · · · · · no
·□ □ □ □ □ □ □ □ □ □ □ □ □ □ · ·
Figure 3: A run where all the invalid bytecode program in-
putshave been filtered outbefore execution ( verify).
Inspired by the success of Regehr et al. [ 21], our first attempt
toimprovethesituationwasto detectinvalidbytecodeprograms.
Specifically, we enhanced ddminto a version called verifythat
checks,ineveryiteration,thatthebytecodeprogramisvalidbefore
running CFR and javac. Given that the original bytecode program
is validand that each class stays unchanged, a checkof whether a
bytecodeprogramisvalidboilsdowntocheckingthatalldepen-
dencies are present. We do this by going through each class to find
its dependencies, after which we assemble the dependencies into a
graph.
Figure2shows the dependency graph for our example; each
node represents a class and each edge represents a dependency.
The classes are numbered from 0 to 16 (corresponding to numbers
in Figure 1), for simplicity. The edge 1 →4 means that class 1
dependsonclass4.Sometimesclassesaretightlycoupled,inthat
case bidirectional edges are possible. Using this graph, verifycan
checkforeachiterationthatallthedependenciesarepresentbefore
running CFR. Figure 3shows that verifyinvokes CFR and javac
just five times, yet still produces a program with 14 classes. InSection 5, our experiments show that verifyis 3x faster than
ddminonalistofclasses,onaverage.
Wehavefoundthattheactualerrorisinducedbyclass1,marked
in bold in Figure 2. However, for a bytecode program with class
1tobevalid,classes2,4,and7alsohavetobepresent.Thus,the
smallestvalidinputthatinducesanerrorinCFRis {1,2,4,7},which
is 3.5x smaller than the result given by ddminandverify. This
raises the question: why do ddminandverifydo poorly and what
can we do aboutit?
Theproblemhastodowithalackof monotonicity thatweexplain
now.Inourexample,considerthetwovalid,failure-inducinginputs
{1,2,4,7}and{0,1,...,16}.Figure3showsmanysets Swhere
{1,2,4,7} ⊆S⊆ {0,1,...,16}
and in every case, Sis invalid bytecode. Thus, we don’t have the
propertythatasinputsgetbigger,failureispreserved.Equivalently,
we don’t have the property thatas inputsget smaller,nonfailure
is preserved. In other words, when we run CFR followed by javac
on possibly invalid bytecode, this combined operation fails to be
monotonic.
Thelackofmonotonicityhasabigeffectonthereductionprocess.
Specifically, the process can move from a failure-inducing input
such as{0,1,...,16}to a smaller input such as {0,1,...,8}that
induces no failure, and still miss the even smaller, failure-inducing
input{1,2,4,7}. For example, if we from {0,1,...,8}remove some
classesthathad missingdependencies,theremoval may makethe
inputvalid again, hence make the failure reappear.
We notethat theoriginalpaperon ddminassumesthat ł failure
is monotone ž [27, Section VIII]. However, delta debugging has been
successful even when monotonicy fails (including when the input
is a C program) so what is different about our case? The answer is
that
forinputwithmanyinternal dependencies,
monotonicitycanfail spectacularly.
Indeed,Figure 1showsthatalmosteverysubsetisinvalidbytecode
sotrying O(n2)subsetsamongthe (2n)possiblesubsetshaslittle
chance ofsuccess.
NoticethatinFigure 1,ddminmanagedtoremovetheinterde-
pendentclasses15and16inasinglestep.Thiswasmostlyduetoa
lucky ordering of the classes. We can see from this example that
forddmintoremoveinterdependentclasses,itmustremovethem
at the same time. An attempt to remove either one in a single step
wouldrun intoinvalidbytecode.
For another example, notice that if we remove class 11 from
{0,1,...,16},wegetaninvalidbytecodeprogram.Byinspecting
Figure2wecanseethatinadditiontoremovingclass11,wealso
havetoremoveclass8,thusalsoclass13,andsoon.For ddminto
have a chance to remove such a long dependency chain in a single
step, we would need the classes to be ordered in a particularly
fortunateway.However,giventhatthereductionproblemisNP-
complete,findingagoodlisting isahardproblem.
Theaboveanalysishasledustoabandontheideaof detecting
invalidinputandinsteadpursuehowto avoidit.Wewillpresent
a new approach that avoids invalid bytecode programs entirely
by putting dependencies front and center. The key idea is to do
reduction ofdependency graphs, as we explainnext.
558ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia Christian GramKalhauge andJens Palsberg
3 REDUCTION OFDEPENDENCYGRAPHS
In this section we will distill the essence of reducing an input with
internal dependencies in a way that avoids invalid inputs. Thus,
we will run CFR followed by javaconly on valid bytecode. Hence,
all remaining violations of monotonicity, in the sense of Section 2,
come from CFRand javacc,andthosetendto be insignificant.
Let us assume that the validity of an input can be modeled with
adependencygraph.Ifallelementsintheinputhavenomissing
dependencies,theinputisvalid.Intuitively,ifwegroupallelements
with their dependencies, and with the dependencies of their depen-
dencies,andsoon,thenpickingsuchagroupwouldbeavalidinput.
For the case of a set of verified classes, no missing dependencies
mean avalid bytecode program.
We avoid invalid inputs by changing the reduction problem
from working with a list of elements to working with a list of
sets of elements . We ensure that each such set of elements is a
validinputbyrequiringthatitisaself-containedsubsetwithout
missing dependencies. Those subsets are the transitively closed
subsets of nodes in the dependency graph of the input. Recall that
the transitive closure (or simply closure) of a set of nodes is the
smallest superset that istransitivelyclosed.
Our reduction strategy is based on the idea that a set of closures
representstheunionofthoseclosures ,whichmakessensebecause
the union of two closures is itself a closure. This means that no
matter what subset of the list of closures a reduction algorithm
picks, the union of that subset would be a closure. And since every
closure is valid input we have a strategy that avoidsinvalid inputs.
Thedependencygraphreductionstrategy. Hereisourstrategyfor
reduction ofan inputwithinternal dependencies:
(1) Map the inputto its dependency graph.
(2) Compute the closure ofeachnode.
(3) Form alistofthe closures.
(4) Runareduction algorithm onthe listofclosures.
(5) Outputthe union ofthe reducedlistofclosures.
For our dependency graph in Figure 2, Step 2 maps the 17 nodes
to the following 8 different closures: S1={7,8,...,16},S2=
{7,8,...,14},S3={1,2,...,7},S4={1,2,3,4,7},S5={1,2,4,7},
S6={4,7},S7={7}, andS8={0}. We have fewer closures than
nodes because ofcyclesinthe graph.
The above strategy leaves two aspects to be refined. First, in
Step 3 we must decide how to order the closures. This turns out to
be important,as we will discussbelow.Second, inStep4 we must
decidehowtoreducethelistofclosures.Wehavesomefreedom
here because when we remove a closure from the list, the result
is again a list of closures. Thus, a reduction algorithm can remove
closures andavoid invalidsubsetsentirely.
Using ddmin on a list of closures. In this section we use ddmin
inStep4andrefertothisalgorithmas closure.Ineachiteration
of ddmin, the union of the closures represents a valid bytecode
program soallwe needto doisto checkwhether CFRfails.
Figure4showstworunsof closureontheclosuresofthenodes
inFigure 2.Thedifferenceliesinhowweorderedtheclosuresup
front;anyorderingispossible.Inbothcases,thenumberofitera-
tionsismuchsmallerthanintherunof ddminshowninFigure 1.
The reason is that closure encounters no invalid subsets so itS1S2S3S4S5S6S7S8fail
□ □ □ □ · · · · yes
■ ■· · · · · · no
· · □ □· · · · yes
· · □· · · · · yes
· · □· · · · ·
S7S8S6S5S4S3S2S1fail
□ □ □ □ · · · · yes
■ ■· · · · · · no
· · □ □· · · · yes
· · ■· · · · · no
· · · □· · · · yes
· · · □· · · ·
Figure 4: Two runs of closure on the example in Figure 2,
where{1}induces failure. The first run has the closures in
an arbitrary order; thesecond hasthemsorted after size.
S7S8S6S5S4S3S2S1fail
■ ■ ■ ■ · · · · no
· · · · □ □ □ □ yes
· · · · ■ ■· · no
· · · · · · ■ ■ no
· · · · ■· · · no
· · · · · ■· · no
· · · · · · ■·no
· · · · · · · ■no
· · · · · □ □ □ yes
· · · · · ■· · no
· · · · · · ■·no
· · · · · · · ■no
· · · · · · ■ ■ no
· · · · · □·□yes
· · · · · ■· · no
· · · · · · · ■no
· · · · · □·□
Figure5: Arunof closureontheexampleinFigure 2,where
{1,12}induces failure.
homes in on a solution in just four and five iterations, respectively.
In this example closure run as fast as verify, in Figure 3, but the
first run returns S3={1,2,...,7}, which is much better than the
outputin Figure 3, whichis{1,2,...,14}.The secondrun returns
S5={1,2,4,7},whichisthe bestpossible subset.
For the second run in Figure 4, we sorted the closures by size,
from smallest to largest. The reason this works well has to do with
aquirkinrunningddminonalistofsets.Specifically,ddminviews
S3,S4,S5as equally good reduced sets, because each one is a single
closure. Whether ddmin produces one of S3,S4, andS5depends
on the order of the closures, and, like in Section 2, some orders
are more lucky than others. In each of the two runs in Figure 4,
closure produced a single closure and behaved like binary search.
We know that ddmin tends to process input from left to right, as
we can see in Figure 1, so when we sort the closures by size we
have agoodchance to getthe smallest closure.
559Binary Reductionof Dependency Graphs ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
The algorithm closureleaves room for improvement. For ex-
ample,supposethefailureisinducedbythecombinationofclass
1andclass12(ratherthanonlyclass1).Thesmallestreducedset
isS5∪S2, which has size 11. However, Figure 5shows a run of
closure that produces the larger set S3∪S1, which has size 16.
Like before, this happens because ddmin looks for the smallest
possiblesetofsetswithoutconsideringthesizesofthosesets.Here,
ordering the closures by size is insufficient to get the best result. In
the next section we present an algorithm that matches closure in
simplecasesandisbetterandfasteringeneral.
4 BINARY REDUCTION
Wewillextendtheclassicalreductionproblemwithanotionof cost
that canmodel sizesof closures, and we will presentan algorithm
calledBinary Reduction.
4.1 The Input ReductionProblem
For all sets we can refer to the elements using indicies: e.g. if Ais a
set,thenA1,...,A|A|refertotheelementsof A.IfΣisaset,then
2Σis the powerset of Σ; we useD,S,Uto range over the elements
of 2Σ. We say that P: 2Σ→Bool, a predicate on subsets of Σ, is
monotonic ifS1⊆S2implies that P(S1)⇒P(S2).
We recastreduction as adecision problem:
Definition1(InputReductionProblem). Given(Σ,P,C,U,k),
whereΣisasetofsymbols, P: 2Σ→Boolisapolynomial-timemono-
tonicpredicate, C: 2Σ→Nisapolynomial-timecostfunction,and
U∈2Σisafailureinducinginput (P(U)=True),k∈Nisanatural
number,decide∃S⊆U:P(S)∧(C(S)<k).
Intuitively, Prepresentsbuggysoftwareand Urepresentsfailure-
inducinginput.WefollowtheconventionofMisherghiandSu[ 19]
thatPreturnsFalseboth in the case of invalid input and in the
case of no failure. The novelty in the above definition is the cost
functionC. In order to define the problem as a decision problem,
weusethestandardtechniqueofaskingwhetherthecostof Sex-
ceedsathreshold k.Manyinstantiationsarepossible,includingthe
following four.
OriginalProblem. Intheseminaldeltadebuggingpaper[ 27],Σis
theindexsetoftheinputlist, U=2Σ,andC(S)=|S|.Theproblem
is to find the smallest subset of the index set that induces a failure.
SyntaxTrees. In thepaperonhierarchicaldelta debugging[ 19],
Σis a set of subtrees of a tree, U=2Σ, andC(S)=|S|. Thus, the
problemistofindthefewestsubtreesthatinduceafailure.Contrary
totheoriginalpaper,ifwedefinethecostfunctiontobethesum
ofthesizesofthesubtrees,areducerthatsolvestheproblemwill
aim to choose the smallest subtrees.
Set of Sets. If we want to minimize the unionof a set of sets,
we can pick Σ=2E, whereEis a set,U=2Σ, andC(S)=|∪S|.
Additionally, we can lift any predicate Q: 2E→Boolon subsets of
Eto apredicate P: 2Σ→Boolbydefining P(S)=Q(∪S).
Dependency Graphs. The previous section explains how to do
reduction of a dependency graph by mapping it to the Set of Sets
problem above. The idea is to compute the closures of the nodes in
the dependency graph and then to find the smallest union of the
closures that satisfiesthe predicate.Algorithm1: Binary Reduction
Input:(Σ,P,C,U,k)
Define:A⪯S′B:=C(S′∪{A})≤C(S′∪{B})
Data:S←∅andD←sort⪯S(U)
whiler>0wherer←minrst.P/parenleftBig
S∪/braceleftBig
Dj:j≤r/bracerightBig/parenrightBig
do
S←S∪{Dr}
D←sort⪯S/parenleftBig/braceleftBig
Dj:j<r/bracerightBig/parenrightBig
end
returnC(S)<k
Misherghi and Su[ 19] provedthatthe hierarchicaldelta debug-
gingproblemisNP-complete.Inasimilarmanner,weprovethat
the InputReduction Problem isNP-complete.
Theorem 1. TheInputReduction Problemis NP-complete.
Proof.The Input Deduction Problem is in NP because, given a
witnessS⊆U,wecancheckinpolynomialtimethat P(S)∧(C(S)<
k)sincePandCrunsinpolynomialtime.
We show that the Input Deduction Problem is NP-hard by re-
ducingfromtheHittingSetProblem,whichisNP-complete[ 15].
The Hitting Set Problem is: given (Σ,Z,k), whereZ⊆2Σis a set
of sets, decide∃S⊆∪iZi:(∀i:S∩Zi/nequal∅)∧(|S|<k). The
reduction works as follows. Define U=∪iZiandP(S)=(∀i:
S∩Zi/nequal∅)andC(S)=|S|. Notice that Pis monotonic. Notice
also that if (Σ,P,C,U,k)has a solution S, then(S⊆∪iZi=U),
(∀i:S∩Zi/nequal∅),and(C(S)=|S|<k).Thismeansthat Sisalsoa
solution to (Σ,Z,k). □
Our problem is NP-complete and, unless P=NP, the best we
can do in polynomial time is an approximation. In the next section,
we will present a polynomial-time approximation algorithm for
solving the inputreduction problem.
4.2 The BinaryReductionAlgorithm
Recall that in Figure 5,closure makes a bad choice and rejects
the left half of the input. The closures on the left are insufficient
toinduceafailure.Instead, closurefindsamuchworsesolution
amongthebiggerclosuresontheright.Thereasonisthat closure
takes noadvantageofgettingasortedinputlist.
WeintroduceAlgorithm 1,analgorithmcalledBinaryReduction.
The algorithm is inspired by the second run of closurein fig.4,
whereddminoperateslikeabinarysearchandquicklyfindsasingle
closure. Binary Reduction extends this idea to work in cases where
multiple closures are required. We use (sort⪯S(X))to denote the
sorting of Xaccording to the total order ⪯Sand(minrst.p)to
denotefindingthe smallest rsuch that pissatisfied.
Theideaistomaintaintwosets SandaD.Here,Sisthesetof
elements that we know are in the final set, and Dis a sorted set of
elementsstilltobesearched.Weinitialize Stobeempty,indicating
weknownothing,andweinitialize Dtobetheinput,aswewant
to searchthe entire space.
The algorithm searches for the minimal prefix of a sorted list-
ing ofDthat together with SsatisfiesP. Since we know that
S∪/braceleftBig
Dj:j≤r/bracerightBig
isthesmallestprefixthatsatisfies P,wealsoknow
thatremoving Drfromthesetswouldmake Pfalse,therefore Dr
560ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia Christian GramKalhauge andJens Palsberg
S1S2S3S4S5S6S7S8fail
· · · · · · · · no
□ □ □ □ · · · · yes
■· · · · · · · no
■ ■· · · · · · no
□ □ □ · · · · · yes
· · ⊠· · · · · yes
· · ⊠· · · · ·
S7S8S6S5S4S3S2S1fail
· · · · · · · · no
□ □ □ □ · · · · yes
■· · · · · · · no
■ ■· · · · · · no
■ ■ ■ · · · · · no
· · · ⊠· · · · yes
· · · ⊠· · · ·
Figure 6: Two runs of Binary Reduction ( binary) on the ex-
ample in Figure 2, where{1}induces failure. The first run
hasC(X)=|X|; thesecond has C(X)=|∪X|.
S7S8S6S5S4S3S2S1fail
· · · · · · · · no
■ ■ ■ ■ · · · · no
■ ■ ■ ■ ■ ■ · · no
□ □ □ □ □ □ □ ·yes
· · · · · · ⊠·no
■ ■ ■ · · · ⊠·no
□ □ □ □ □ ·⊠·yes
□ □ □ □ · · ⊠·yes
· · · ⊠· · ⊠·yes
· · · ⊠· · ⊠·
Figure7: ArunofBinaryReduction( binary)ontheexample
inFigure 2,withC(X)=|∪X|andfailure induced by {1,12}.
mustbepartofthefinalset.Wecanthereforeadd DrtoSandre-
ducethesearchspacetothesmallerprefixwithout Dr,/braceleftBig
Dj:j<r/bracerightBig
.
We continue to reduce thesearchspace until thesmallestprefixis
empty(r=0).Sinceweonlyaddedelementstothesolutionthat
wererequiredandsince Pismonotonic,thesolutionis one-minimal
[27]:ifanyelementisremovedfrom S,thenPisnolongersatisfied.
The core of the algorithm is the search for the smallest prefix of
Dthat satisfies P. In general, this takes O(n)time, where nis the
size ofthe searchspace.However,we have amonotonic Pso
P(∅)⇒P({D1})⇒P({D1,D2})⇒...⇒P({D1,D2,...,Dn})
andthus we can use binary search.
Thefinaltouchistokeeptheset Dsorted,usingthecostfunction
C. Ouridea is to use the costfunction to sort the search space such
that low-cost elements are chosen early. This is a greedy algorithm
thatmakesthebestpickpossibleineachiteration.Aswithother
greedyalgorithms,thismayfailtoproducethebestglobalsolution,
yet our experiments show that the results are good in practice.
Notice that every iteration sorts Daccording to the cost of the
unionofthecurrentlyselectedset Sandtheindividualinputs.Thisis an advantage because sometimes the cost of the union of two
inputsetsdoes not equal the sum of the costof eachof the sets.
We will use Binary Reduction in Step 4 of the strategy in Sec-
tion3; we refer to this algorithm as binary. The first diagram in
Figure6shows a run of binaryon the example in Figure 2, with a
natural cost function C(X)=|X|. We use⊠to mark the Drthat is
added to the solution in the line S←S∪{Dr}. Like in the first run
ofdeltadebuggingovertheclosuresofthegraphinFigure 4,weget
S3, whichis suboptimal.However,incontrastto closure, wecan
easilymodify binarytouseamoreinterestingcostfunction,like
thenumberof elementsintheunionof thesets C(X)=|∪X|.Fig-
ure6showsthatrun.Likeinthesecondrunof closure inFigure 4,
we getS5,whichisthe bestsolution.
Figure7shows a run of binaryon the example in Figure 2, but
thistime thefailure is induced by {1,12}.In contrast to therun of
closureinFigure 5,wegetthebestsolution S5∪S2.Noticethat
the run took only 3binary searches and9invocations of P.
Even thought the choice of C(X)=|∪X|solves our problem,
we could imagine more interesting cost functions like the total
size of classes. Binary Reduction greedily choose a local minimum
regardlessofcostfunction,butweexpectthatitperformsbestif
the costfunction ismonotone inthe size of X.
Complexity analysis. The complexity of Binary Reduction de-
pendsonthecomplexityofthecostfunction C($C),thepredicate P
($P), the size n=|U|of the input, and the final size sof the reduc-
tion. We do at most sbinary searches, with O(logn)invocations of
Pandworst-case ncalculationsof C(S)aspartofsorting(assuming
caching)whichtakes O(nlogn)time.So intotal we have
O(s(logn·$P(n)+n·$C(s)+nlogn)).
Inspecting the time complexity of the algorithm we can see that
wewillmakeatmost O(slogn)invocationsof P.Sincesisbound
byn,the complexityofthe algorithm is O(nlogn)iterations.
5 EXPERIMENTALRESULTS
This section presents an empirical evaluation of using dependency
graphs and Binary Reduction for reduction. We have implemented
those techniques in a tool for Java bytecode programs called J-
Reduce.J-Reduceisageneraltoolforreducinginputswhilepreserv-
ing errors. We will use three decompilers as part of the evaluation,
yetanytoolthattakesJavabytecodeasinputcouldhavebeenused.
The evaluation supports the twomain claims of the paper:
(1) Reduction based on a list of closures is faster and better than
reduction based on a list of classes. When we run ddmin on a list
of classes, we time out 75% of the runs after an hour. In contrast,
when we run ddmin on a list of closures, we time out only 9% of
therunsafteran hour.Includingthetimeouts,thelist-of-closures
approach gives 7x speedup and1.07x smallerresults, onaverage.
(2) Binary Reduction is faster and better than ddmin. Only 1% of
the runs of Binary Reduction on a list of closures time out after an
hour. Including the timeouts, Binary Reduction gives 1.7x speedup
and 1.15x smaller results, on average, compared to running ddmin
onthesameinput.Overall,weget12xspeedupand1.24xsmaller
results comparedto running ddminonalistof classes.
561Binary Reductionof Dependency Graphs ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
Figure 8: These three histograms show the distribution of the failure inducing inputs over three metrics; number of classes,
theaverage in- andoutdegree oftheunderlying dependencygraph,andthenumberofstronglyconnected components.
5.1 ExperimentalSetup
5.1.1 Implementation. J-Reducehasasinglefrontendthatextracts
a dependency graph from binary Java class files. Specifically, J-
Reduce scans through each class-file to search for references to
other classes and assembles them into a dependency graph. The
commonfrontendandbackendenableeasycomparisonofthealgo-
rithms.J-Reduce implements fourdifferentreduction algorithms:
•ddmin: Classicaldelta debuggingonalistofclasses.
•verify: Usesddminplusdetection ofinvalidbytecode.
•closure: Uses ddminonalistofclosures, sortedafter size.
•binary: Uses Binary Reduction onalistofclosures.
WeimplementedJ-Reducein7,929linesofHaskellcodethatpassed
FSE’s artifact evaluation [ 13]andisopen source1.
5.1.2 ChoiceofPredicate. Fortestingofthedecompilers,weuse
the property that a decompiler should produce source code that
compiles with javac; otherwise it has a bug. We use the predicate
thatjavacproduces the same bugas the originalbug.
To get a monotonic predicate we took special care to keep all
inputs except the reduced class files exactly the same. For example,
theinternalorderinginthefilesystemmayplayaroleintheoutput
of the decompilers and in javac. Specifically, javacproduces only
a subset of the bugs in the source code, depending on which files it
readsfirst.So,wekeptasortedlistsoffilesandonlywrotetothe
file systemandjars inthat order.
5.1.3 Choice of Decompilers. We choose three decompilers as the
basisofourpredicates:CFR[ 3,version0.132],Fernflower[ 22,com-
mit8be977e76],andthe decompilerfromtheProcyonproject[ 23,
version0.5.30].Wesetupeachdecompileraccordingtotheinstruc-
tionsonitswebpage.WeranFernflowerwiththe -dgs=1flagtoen-
ablehandlingofgenerics.WeranCFRwith --caseinsensitivefs
true.We ranProcyonwithnospecialarguments.
5.1.4 Benchmarks. Ourbenchmarksare100largeJavaprograms
that we obtained from the NJR project [ 20]. We selected programs
thateachhasatleast100classesandforwhichwehavesourcecode.
Wefocusonbytecodefilesthatwehaveproducedfromsourcecode
1https://github.com/ucla-pls/jreduceTable1: Aggregatedresultsofalltheruns.Thefirstcolumn
indicatesthepercentageofrunsthatwehadtotimeout.The
second column is the average (GM) final relative size after
reduction.Thethirdcolumnsaretheaverage(GM)running
timesinseconds.Smalleris better.
timeout final size time [s]
binary 0.8% 25.7% 203
closure 8.8% 29.8% 336
verify 19.8% 42.6% 750
ddmin 74.8% 31.9% 2339
ourselves to ensure that we start each reduction with a valid byte-
codeprogram.Someoftheprojectsaredependentonlarge-scale
libraries,butourreductionleavesthoselibrariesunchangedandwe
exclude themfrom the dependency graph andour measurements.
We found that CFR fails on 94% of the programs, Fernflower
failson56%,andProcyonfailson88%.Thus,intotalwehave238
failure-inducinginputs.
Figure8shows how the distribution of the inputs over three
metrics:numberofclasses,averagein-degreeandout-degreeinthe
underlying dependency graph(excludingself-loops), and number
ofstronglyconnectedcomponents.Theinputscontainamedian
of 171 classes, and between 103 and 1006 classes. The benchmarks
arediversebothintermsofthein-degreeandout-degree,witha
median of3.6,and intermsofthe number ofstrongly connected
components,withamedian of 100.
5.1.5 Platform. Weperformedtheexperimentsonamachinewith
24Intel(R)Xeon(R)Silver4116CPUcoresat2.10GHzand188Gb
RAM. We executed the experiments using OpenJDK (1.8.0_172-02).
We ran the experiments in parallel in batches of 8. We ran each
reduction for nomore thanan hour (3600s).
5.2 Results
Foreachreductionalgorithm( binary,closure,verify,andddmin)
we measured the total time in seconds, the number of invocations
562ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia Christian GramKalhauge andJens Palsberg
Figure 9: For reduction that preserves the full bug, the first two charts show the number of cases that terminate within x
secondsand xiterations, andthethird chart showsthefinalnumberofclasses relative to the originalsize.Higheris better.
of the predicate made by the algorithm, and the fraction of classes
leftintheoutputafterreduction.TheresultsareshowninFigure 9.
If a tool was timed out after an hour (3,600 seconds), we report the
smallestsetofclassesthathadbeenfoundtopreservethebug.This
reflectsthat ausercan use the bestresult available at time out.
Thetimesincludethegenerationofthegraph(median0.5s,max
7.1s), the initial run that tests if the predicate is true, and for the
tools that used closures, the calculation of the closures (median
5.0ms,max 96.0ms).
Table1shows the aggregated results of all the runs: the per-
centage of the runs that we time out, the geometric mean of the
relativefinalsize,andthemeantimeused(includingtimeouts).The
geometricmeanallowsustotalkabouthowmanytimesatoolis
betterthananother,basedonhowmuchisleft after reduction.
Wehavealsoplottedalltheresultsincumulativecharts.Figure 9
showstheresultsofthefourconfigurationsinthreecharts.Thefirst
chart shows how many programs that each reducer has finished
aftersomeseconds.Thesecondchartshowshowmanyprograms
that each reducer has either finished or timed out on after some
invocationsofthepredicate.Thethirdandfinalchartrepresents
the relative size after reduction for an hour.
First,letusevaluatehowddmin( ddmin)performsagainstddmin
plusdetectionofinvalidbytecode( verify).Unsurprisingly, verify
ismuchfasterthan ddmin,becauseitdoesnothavetorunthepred-
icateforthecaseswherenotallthedependenciesarepresent.Also,
verifytimeoutson19.8%oftheprogramswhere ddmintimeouts
on 74.8%. The resulting size of verify, however, is worse, with
42.6% average final size against ddmin’s average of 31.9%. There
are twofactors that affectthis. One,adding the verifier makesthe
predicate more non-monotonic: missing dependencies in classes
not visited by javacemerge as a problem. Two, our dependency
graphmaybeanover-approximationoftheactualdependencies
used by the decompilers and compiler. This means that our veri-
fier can reject a program that might decompile and make javac
produce an error.
Second,letusevaluaterunsofddminonalistofclosures(named
closure). This is affected by the overapproximation of the depen-
dency graph, but the number of items is now both smaller (median100vsmedian171),andalsothepredicateisnowmonotonic(disre-
garding non-determinism). This has a dramatic effect on speed and
leadsto a smaller output. closure only timeouts in 8.8% of all the
inputs,andproducesonaverage29.8%finalsize. closure preforms
betteronmostoftheinputs, but ddminoutperforms closureina
fewcases.Wethinkthishappensbecausethedependencygraph
is an overapproximation of the actual dependencies used by the
compiler.Thismeansthat ddmininsomecasescanremoveanextra
class, because itisinreality not neededbythe compiler.
Third,letusevaluaterunsofBinaryReductiononalistofclo-
sures(binary).binaryperformsbetterthan closure,withatim-
outerateof only0.8%,andis onaverage1.7xfaster.Thefinalsize
ofthereductionisalsobetter,with25.7%finalsizeonaverage.The
better reduction can be attributed to two factors: fewer timeouts
andBinaryReduction’sabilitytopickthesmallestclosure.When
controllingforthefewertimeouts,bynotcountingthebenchmarks
where either of the algorithms timed out, Binary Reduction is able
to produce 1.11x smaller results than delta debugging. On a few
casesddminoutperforms binary, this is partly due to the over-
approximation,butalsothatsomeofthebenchmarkscouldyield
differentresultswhenruntwice. ddminsometimesrunsthesame
reductioncandidatetwice,whichmeansthatithasahigherchance
ofgettinglucky andaccepting the reduction.
Inconclusion,usingBinaryReductiononthedependencygraph
of Java bytecode programs are 12x faster and 1.24x smaller results
onaveragethandelta debuggingdirectlyonthe listof classes.
5.3 Threatsto Validity
5.3.1 External Validity. The primary threats to external validity
isthechoiceofdomain.Wechosethedomainofdecompilers,be-
causebugswereplentifulandeasytofind.Wedo,however,believe
that the results extend to all domains with inputs with internal
dependencies,andespeciallytodomainsthatexpectvalidbytecode
programs as inputs.
5.3.2 Internal Validity. We chose 100 fairly large benchmarks at
randomfromtheNJRrepository;wedeemthemtoberepresentative
ofreallifeprograms.Wechoseprogramswithover100classestogo
beyondwhatpeoplemaybewillingtoreducebyhand.Thetimeout
563Binary Reductionof Dependency Graphs ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
time was set at one hour, which might skew the study; however,
wethinkthatfewuserswouldrunareductionprogramformore
than an hour. Our definition of a bug in a decompiler ( produces
code that does not compile ) is not the strongest definition. We could
expectthatwecouldfindevenmorebugsifwehadusedastronger
requirement. This does however not affect our study as we find
plenty bugs.
In our experiment we reduced using a cost function that tries
to minimize the number of classes, however the total size of the
classes would also be an interesting metric, as two small classes
might be better than one big class. Our technique is sufficiently
general to reduce using any cost function, though we do expect
ddmintoperformevenworseinthiscaseanditwouldbeanunfair
comparisonasddmincanonlyreducebasedoncounts.Whilewe
believe that ddmin is anadequatebaseline,we could calculatethe
reductionapproximationratioofbothalgorithmsifwehadanideal
reduction, which we could find by doing an exhaustive search. We
leave thisto future work, perhapsfora smaller benchmark suite.
Finally, the decompilers that we have chosen are not completely
deterministic,whichmeansthatthepredicates,evenovertheclo-
sures,arenotcompletelymonotonic.Weseethisasastrengthof
the study since in real life programs are often not deterministic,
andpredicates are often not completely monotonic.
5.4 Data Availability
We havemadethe rawdataused fortheanalysis available[ 14].It
includes two files: a łbenchmarks.csvž file, which contains the data
forhistograminFigure 8,andałdeliverable.csvžfile,whichcontains
thedataforthecumulativediagramsinFigure 9andaveragesin
Table1.
6 REPORTING BUGS
Section 5 listed results from reducing input in a general manner
that preserves the output from javacin its entirety. The median
reduced bytecode program has 84 classes, which is too many to
includeinasuccinctbugreport.Thisobservationledustoconsider
howdomain-specificknowledgeabout javaccanleadtoadditional
reduction.We found thatthe outputfrom javacmay list multiple
problemssoastraightforwardideaistopreserve lessthantheentire
output.Asaradicalsteptowardsmoreaggressivereduction,weran
an experiment in which we preserve only javac’s exit code. Thus,
we preserve that javacreturns an error, but not which one(s).
Indeed, the final list of problems may have no overlap with the
initiallist.
OurexperimentwithrunningBinaryReductionon238programs
took 34 minutes in wall clock time, or 13 hours in processing time,
for an average of 3 minutes per program. The median reduced
bytecode program had 2 classes, excluding libraries. Indeed, in 133
casesoutof238cases,thereducedprogramhad1or2classes:57
cases for CFR, 46 for Procyon, and 30 for Fernflower. The output
fromjavaccincluded many distinct error messages (disregarding
linenumberandclass):67distincterrormessagesforCFR,83for
Procyon,and27 for Fernflower.
We used the results of the experiment to report 2 bugs to CFR, 1
bug to Procyon, and 2 to Fernflower. We choose the benchmarks of
sizenomorethan2classes,whichinducederrorsthatlookedlikeafixablebugsandweresignificantlydifferentfromeachother.Atthe
time of writing these lines, the developers of CFR have confirmed
andfixed one ofthebugs, thedevelopersofProcyon have triaged
the bug, but not yet fixed it, and the developers Fernflower have
triagedthe bugsbut not hadtime to fixthem.
Westoppedshortoffilingadditionalbugreportsbecauseweare
aware that two failure-inducing inputs may be about the same bug.
We want to avoid reportingthe same bugtwice andwe leave itto
future work to find an effective wayto categorize bugreports.
7 RELATED WORK
Theliteratureonprogramreductionanddeltadebuggingisrichand
diverse.Wewillcoversomeofthemostcloselyrelatedpapersfrom
thatliteratureandwewillfocusonthreeaspects.Thefirstaspectis
howpreviousworkhasdealtwiththetest-casevalidityproblem,the
secondaspectishowourapproachcomparestovariousapproaches
to input reduction, and the final aspect looks at program reduction
as slicing.
The Test-Case Validity Problem. Our paper is the first to avoid
invalid input. We will discuss how some prominent papers have
dealt withinvalidinput.
Zeller and Hildebrandt [ 27] introduceddelta debugging. They
wrote [27,SectionVIII] that łDelta Debugging assumes thatfailure
is monotonež . However, their paper showed how to apply Delta
Debuggingtoavarietyofinputforwhichfailure isn’tmonotone,
namelyCprograms,Mozillauseractions,andUNIXcommands.For
each kind we can remove a few characters from a failure-inducing
inputandtherebychangeitintoaninvalidinput.Insomecases,we
can remove additional characters and get another failure-inducing
input.Deltadebuggingworkswellforthosekindsofinputsbecause
mostnaturalsubsets are valid. In contrast, for Java bytecode, most
natural subsets are invalid. Our experiments show that for Java
bytecode, delta debugging of a list of classes times out often and
gives adisappointing factor of reduction.
Delta debugging has also been implemented in the Delta tool
[18].Thistoolusesaline-basedalgorithmthatsuppressesnewlines
below a particular depth in the syntax tree. This decreases the risk
of removing half of a subtree and thereby producing invalid inputs.
MisherghiandSu[ 19],intheirpaperonhierarchicaldeltadebug-
ging,avoidedinvalidsubsetsbystructuringtheinputasasyntax
treeandbyremovingentiresubtreesatatime.Theirinsightisthat
the elements of a subtree can be a natural subset of the input, such
asastatementinastatementlist.Theyfoundthattheycanremove
asinglestatementfromastatementlistandpreservethatthesyntax
treeisvalid.Comparedtheclassicaldeltadebuggingalgorithm,the
hierarchical approach gave a decreasein the number tests needed
forC-programinputbyafactorof11.5onaverage.However,while
each Java bytecode class is a natural subset of a bytecode program,
mostsubsetsoftheclassesareinvalid.ForJavabytecode,thetop
level ofhierarchicaldeltadebugging isdeltadebuggingofa list of
classes,whichwe have shownworks poorly.
Regehr et al. [ 21]identified the problem withinvalidinput and
pursued an approach, for C, that detects invalid input. The core of
theirapproachisakintothealgorithmwecalled verify.Theywent
further and built in detailed knowledge of C that enabled their tool
to reduce C-program 25 times more than language-independent
564ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia Christian GramKalhauge andJens Palsberg
tools.Incontrast,ourtoolavoidsinvalidcodeandusesageneral
reducer. Our experiments showthat for Javabytecode, detection of
invalidinputisslowandthis gives asmall factor ofreduction.
Sunetal.[ 24]showed,withtheirtoolPerses,howtoavoidin-
validinputsinalanguage-independentmanner.Theydidthisby
transforming an input grammar into a convenient form that can
guide reduction. They showed that this approach is competitive
with less general approaches. However, the approach relies on that
oncethegrammarhasreachedtheconvenientform,twospecific
transformations preserve validity. While indeed those transfor-
mations do preserve validity for many kinds of input, they often
produce invalid subsets in the case where the input is a list of Java
bytecodeclasses.Theproblemisthatagrammarhasnomodelof
the many internaldependencies.Thus, while the generality of the
approachisattractive,theapproachisineffectiveforinputssuch
as Java bytecode programs.
The resent tool Chisel [ 12] uses reinforcement learning to do
fastdebloatingofCprograms.Theapproachis3.7ś7.1xfasterthan
competing approaches. The approach detectsinvalid input, as illus-
tratedbythefollowingquotefromthepaper:łChiselsimplyrejects
nonsensicalprogramswithoutinvokingthetestscriptbyusinga
simple dependency analysis, such as programs that do not contain
the main function, variable declarations, variable initializations, or
returnstatements.ž.Wespeculatethatonecancombinetheirideaof
reinforcement learning with our idea of using a dependency graph
to avoid invalidinput.We leave this to future work.
InCleveandZeller’sworkonSTRIPE[ 6],theytriedtousediffer-
ent clustering techniques to increase the speedof delta debugging
onanexecutiontrace.Specifically,theywroteł[O]urfuturework
willconcentrateonintroducingdomainknowledgeintodeltade-
bugging.Inthedomainofcodechanges,we haveseensignificant
improvementsbygroupingchangesaccordingtofiles,functions,
orstatic program slices,and rejecting infeasibleconfigurations[.]ž
Webelievethatwehavesolvedthisproblembygivingtheusera
simple interface, dependencies, with which they can encode many
differentkindsofdomainspecific dependency information.
ApproachestoInputReduction. BiSect[7,8]isatoolforusewith
gitthatdoesabinarysearchtofindthecommitthatintroduceda
bug. This is akin to the binary search that we use to implement the
minfunction in Binary Reduction. The BiSect technique does no
reduction ofthe input.
The papers by Artho [ 2], by Li et al. [ 17], and by Yu et al. [ 26]
allhavethegoaltoisolatefailure-inducingchangesinarevision
history.Theyusecleverrepresentationsofrevisionhistoriesanduse
variationsofdeltadebuggingtoachievethegoal.Inallthreepapers,
dependencies among changes and validity of history slices play
major roles. Artho [ 2] notes that, in the context of interdependent
changes,the approach łcannot deal withcertain changes affecting
multiplefilesž.Lietal.[ 17]detectsinvalidhistoryslices,whileYu
etal.[26]usesclassicaldeltadebuggingwithnooptimizationfor
invalid input. We speculate that those approaches can be enhanced
with ways to avoid invalid history slices, in a way that is akin how
we avoid invalidinput.We leave this to future work.
Delta debugging has a wide range of applications. In particu-
lar, researchers have shown how to use delta debugging to help
normalize, generalize, and improve test cases [ 9,10,16]. For testcases with many internal dependencies, our approach can be used
to avoid giving invalidinputsto the reducer.
ProgramSlicingandDe-bloating. Deltadebuggingcanbeusedto
sliceaprogram[ 25],that is,reducethe programwhilepreserving
itsbehavior.Whentheslicesareintendedtobeusedasrunnable
program, such reduction iscalledde-bloating.
Deltadebuggingisasimpleapproachtoslicingasitrequireslittle
knowledgeabouttheprogram:wecanreducetheprogramwhile
preserving the observable properties like those given test cases.
Binkley et al. [ 4] uses delta debugging to reduce a set of files using
atechniquetheycallobservationalslicing(ORBS).Ourtechnique
is sufficiently general that it can augment ORBS by allowing the
userto definedependency edges between linesindifferentfiles.
J-Reduce functions perfectly as a program slicer. Since we are
using a static analysis to detect the edges in the dependency graph
we likely under-approximate edges that are the result of reflection.
Under-approximating the dependency graph is acceptable, as it
will only result in more strongly connected components in our
algorithm.Intheworstcasewehaveexactlyonestronglyconnected
componentforeachinputnode,whichmeansthatwearejustdoing
regularreduction.Thismighttakelonger,butwillalwaysoutput
correctbyte code.
Our technique is akin to Agrawal and Horgan [ 1], which uses a
over-approximatingstaticanalysistocollectadependencygraph
betweenstatementsinaprogram.Itthenusesadynamicanalysisto
traverse the program and reduce the graph to see which nodes are
actuallyexecuted.Incontrastourtechniquestartswithapossible
under-approximating staticanalysis anddoes not need to run the
program. This means that it can be used on other properties like
findingbugsindecompilers.Sinceourtechniquetoleratesunder-
approximation,wemightuseadynamicanalysistogeneratethe
dependency graph. We leave this for future work.
8 CONCLUSION
We have presented a new approach to reducing failure-inducing
inputwith many internal dependencies. Ourapproachusesa de-
pendencygraphtoavoidinvalidinputs,anditusesanewalgorithm
called Binary Reduction, that we showed works better than ddmin.
Wehaveimplementedanopen-sourcetoolJ-Reducethatreduces
Java class-files. We evaluated our tool on decompilers, yet our tool
works for any program that takes class files as input. Examples
include static and dynamic analyses, code coverage tools, and code
visualizers.Ourtoolis12xfasterandachievesmorereductionthan
delta debugging. This enabled us to create and submit short bug
reports for three Java bytecode decompilers.
Our approach may work well for other kinds of inputs with
many internal dependencies. For example, our technique can be
usedforlanguageswithmodulesystems,suchasC#orPython.We
can also consider use of a dependency graph in which the nodes
are methodsandfields. We leave thesepointsto future work.
ACKNOWLEDGMENTS
WethankJohnBender,ShuyangLiu,AkshayUtture,andtheanony-
mous reviewers for helpful suggestions. DARPA award number
RF228-G1:5andONR awardN00014-18-1-2037 supportedus.
565Binary Reductionof Dependency Graphs ESEC/FSE ’19, August 26–30, 2019,Tallinn,Estonia
REFERENCES
[1]Hiralal Agrawal and Joseph R Horgan. 1990. Dynamic program slicing. In ACM
SIGPlanNotices , Vol. 25.ACM,246ś256.
[2]Cyrille Artho. 2011. Iterative delta debugging. International Journal on Software
Toolsfor Technology Transfer 13,3 (2011), 223ś246.
[3]Lee Benfield. [n. d.]. CFR ś another Java decompiler. ([n. d.]). http://www.benf.
org/other/cfr/ (accessed Aug 24,2018).
[4]DavidBinkley,NicolasGold,MarkHarman,SyedIslam,JensKrinke,andShinYoo.
2014. ORBS: Language-independent programslicing. In Proceedings ofthe 22nd
ACM SIGSOFT International Symposium on Foundationsof Software Engineering .
ACM,109ś120.
[5]Jong-Deok Choi and Andreas Zeller. 2002. Isolating Failure-inducing Thread
Schedules.In ISSTA.
[6]HolgerCleveandAndreasZeller.2000. Findingfailurecausesthroughautomated
testing.arXiv preprint cs/0012009 (2000).
[7]Wiktor Czajkowski. 2018. Sneaky Bugs and How to Find Them (with git bisect).
Netguru(January 2018). https://www.netguru.co/codestories/sneaky-bugs-and-
how-to-find-them .
[8]Developers.[n.d.]. Bisect.([n.d.]). https://git-scm.com/docs/git-bisect (accessed
Aug 24,2018).
[9]Alex Groce, Mohammad Amin Alipour, Chaoqiang Zhang, Yang Chen, and John
Regehr. 2016. Cause reduction: delta debugging, even without bugs. Software
Testing,Verification and Reliability 26,1 (2016), 40ś68.
[10]Alex Groce, Josie Holmes, and Kevin Kellar. 2017. One test to rule them all.
InProceedings of the 26th ACM SIGSOFT International Symposium on Software
Testingand Analysis . ACM,1ś11.
[11]Mouna Hammoudi, Brian Burg, Gigon Bae, and Gregg Rothermel. 2015. On the
use of delta debugging to reduce recordings and facilitate debugging of web
applications. In Proceedings of the 2015 10th Joint Meeting on Foundations of
SoftwareEngineering . ACM,333ś344.
[12]KihongHeo,WoosukLee,PardisPashakhanloo,andMayurNaik.2018. Effective
Program DebloatingviaReinforcement Learning.In Proceedings ofthe2018 ACM
SIGSAC Conference onComputer and Communications Security . ACM,380ś394.
[13]Christian Gram Kalhauge and Jens Palsberg. 2019. Artifact from "Binary Reduc-
tionof DependencyGraphs". https://doi.org/10.5281/zenodo.3262201[14]ChristianGramKalhaugeandJensPalsberg.2019.Resultsfrom"BinaryReduction
of DependencyGraphs". https://doi.org/10.5281/zenodo.2574326
[15]Richard M. Karp. 1972. Reducibility among Combinatorial Problems. In Com-
plexity of Computer Computations , R. Miller and J. Thatcher (Eds.). Plenum Press,
85ś103.
[16]AndreasLeitner,ManuelOriol,AndreasZeller,IlincaCiupa,andBertrandMeyer.
2007. Efficientunittestcaseminimization.In Proceedingsofthetwenty-second
IEEE/ACM international conference on Automated software engineering . ACM,
417ś420.
[17]Yi Li, Chenguang Zhu, Julia Rubin, and Marsha Chechik. 2016. Precise semantic
historyslicingthroughdynamicdeltarefinement.In AutomatedSoftwareEngi-
neering (ASE), 201631st IEEE/ACMInternationalConference on . IEEE,495ś506.
[18]SMcPeak,DSWilkerson,andSGoldsmith.2015. BerkeleyDelta. URLhttp://delta.
tigris.org (2015).
[19]GhassanMisherghiandZhendongSu.2006. HDD:HierarchicalDeltaDebugging.
InICSE’06,InternationalConference onSoftwareEngineering .
[20]Jens Palsberg and Cristina Lopes. 2018. NJR: A Normalized Java Resource. In
SOAP’18, Proceedings of ACM SIGPLAN International Workshop on State Of the
Art inProgramAnalysis .
[21]John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang.2012. Test-case Reduction for CCompilerBugs.In PLDI.
[22]RomanShevchenkoandothercontributors.[n.d.]. Fernflower.([n.d.]). https:
//github.com/fesh0r/fernflower (accessed Aug 24,2018).
[23]MikeStrobel.[n.d.]. ProcyonJavaDecompiler.([n.d.]). https://bitbucket.org/
mstrobel/procyon/overview (accessed Aug 24,2018).
[24]Chengnian Sun, Yuanbo Li, QirunZhang, Tianxiao Gu, and Zhendong Su. 2018.
Perses: Syntax-Guided ProgramReduction. In ICSE’18, International Conference
onSoftwareEngineering .
[25]Mark Weiser. 1981. Program slicing. In Proceedings of the 5th international
conference onSoftwareengineering . IEEE Press,439ś449.
[26]KaiYu,MengxiangLin,JinChen,andXiangyuZhang.2012. Towardsautomated
debugging in software evolution: Evaluating delta debugging on real regression
bugsfromthedevelopers’perspectives. JournalofSystemsandSoftware 85,10
(2012), 2305ś2317.
[27]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
InducingInput. TSE(2002).
566