jStanley: Placing a Green Thumb on Java Collections∗
Rui Pereira
HASLab/INESC TEC, Universidade do Minho
Portugal
ruipereira@di.uminho.ptPedro Simão
NOVA LINCS, DI, FCT, Universidade NOVA de Lisboa
Portugal
p.simao@campus.fct.unl.pt
Jácome Cunha
NOVA LINCS & Universidade do Minho
Portugal
jacome@di.uminho.ptJoão Saraiva
HASLab/INESC TEC, Universidade do Minho
Portugal
saraiva@di.uminho.pt
ABSTRACT
Software developersare moreand moreeager tounderstand their
code’senergyperformance.However,evenwithsuchknowledge
itisdifficulttoknowhowtoimprovethecode.Indeed,littletool
supportexiststounderstandtheenergyconsumptionprofileofa
softwaresystemandtoeventually(automatically)improveitscode.
Inthispaperwepresentatooltermed jStanleywhichautomat-
ically finds collections in Java programs that can be replaced by
otherswithapositiveimpactontheenergyconsumptionaswellas
ontheexecutiontime.Inseconds,developersobtaininformation
aboutenergy-eagercollectionusage. jStanleywillfurthersuggest
alternative collections to imp rove the co de, making it use less time,
energy,oracombinationofboth.Thepreliminaryevaluationwe
ran using jStanleyshows energy gains between 2% and 17%, and a
reduction in execution time between 2% and 13%.
Avideocanbeseenat https://greensoftwarelab.github.io/jStanley.
CCS CONCEPTS
•Softwareanditsengineering →Softwareperformance ;Soft-
ware design tradeoffs; Software evolution;
KEYWORDS
Green Software, Energy-aware Software, JCF, Eclipse Plugin
ACM Reference Format:
RuiPereira,PedroSimão,JácomeCunha,andJoãoSaraiva.2018.jStanley:
Placing a Green Thumb on Java Collections. In Proceedings of the 2018 33rd
ACM/IEEE International Conference on Automated Software Engineering (ASE
’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY, USA,
5pages.https://doi.org/10.1145/3238147.3240473
∗WorkfinancedbyEuropeanRegionalDevelopmentFundthroughtheOper-
ationalProgrammeforCompetitivenessandInternationalizationCOMPETE
2020ProgrammeandbyNationalFundsthroughthePortuguesefunding
agencyFCTprojectPOCI-01-0145-FEDER-016718.Thefirsttwoauthorsare
supported by grants SFRH/BD/112733/2015 andPTDC/EEI-ESS/5341/2016.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32404731 INTRODUCTION
Originally, computer performance was the principal concern for
software developers and manufacturers alike. Now, while yet not a
dramaticchange,therehasbeenamajorshiftinfocus.Increasing
energycostsrelatedtoICTinorganizations[ 11],datacenters[ 9],
andsociety’senvironmentalconcerns,arestartingtochangethe
wayboth computermanufacturers andsoftwareengineers arere-
sponding and looking at the issue of software energy efficiency.
Whiletherearemanyenergyestimationandmeasurementtools[ 2,
5–7,15],thesedonotsupplydeveloperswiththecounselingneeded
for energy-aware development. In fact, recent findings [ 16,19,23]
haveshownthatprogrammersareawareoftheenergyconsump-
tion problem, many times seeking help in resolving this. There
are many misconceptions within the programming communityas to what causes high energy consumption, how to solve theseissues, and expressed heavy lack of support and knowledge for
energy-aware development.
PintoandCastor[ 22]arguethattherearetwomainproblems
in regards to energy efficient software development: the lack of
knowledge the lack of tools.Theyalsomentionseveralkeypoints
on energy-related solutions to software engineering, three of these
being: static analysis tools, refactoring, and data structures.
In this paper, in Section 2, we detail our jStanleytool, which
touchesonthepriorthreepoints. jStanleyisastaticanalysistool
which suggests a more energy efficient (and/or performance effi-
cient) Java collection, by statically detecting collections used ina Java project, and which methods are used for each collection.Using this information, it not only suggests a better alternative,
but can automatically change the code with the new collections if
theprogrammerchoosesso.However,itisnotpossibletoalways
guarantee the change to best collection is a refactoring as some
collections for instance change the order of the elements.
More specifically, thistool is based on previouswork on the in-
fluenceoftheJavaCollectionFramework(JCF)inregardstoenergy
consumption [ 21], where energy consumption and performance
profile tables were attributed to each of the JCF’s collections (Lists,
Sets, and Maps), down to a method level.
We have ran an initial evaluation with 7 publicly available Java
projectsusedinotherresearchworksand,using jStanley,improved
the energy consumption between 2% and 17%. The execution time
has also decreased between 2% and 13% (Section 3).
WeconcludeourpaperwithSection 4describingrelatedwork,
andSection 5,summarizingour paperandlookingatfuturework.
856
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Pereira, P. Simão, J. Cunha, and J. Saraiva
2 JSTANLEY
jStanley1isastaticanalyzerdevelopedasanEclipsepluginsince
thisisthemostusedIDEforJava.Thetoolweproposeiscapableof
staticallydetecting theusageof energy-inefficientcollectionsand
suggest better alternatives. It can do the same, but considering the
executiontimeorbothenergyandtimeatthesametime.Tothis
end, it uses information on the energy consumption and execution
time for Java collections [ 21]. This information can be provided to
the tool through a set of CSV files, one per type of collection (map,
listandset).Eachfilemustcontaininformationabouttheenergy
and time usage for each method of the collection.
jStanleyconstructstheabstractsyntaxtree(AST)oftheprogram
being analyzed, traversing it to compute the number of method
calls of a given collection variable. As a result, the tool knows how
many method calls for each variable of a collection the program
has. For instance, for a given program, the tool can tell variable
aof type ArrayList has 3 calls to the method addand 9 to get,
and variable bof type HashMap has 20 calls to put, throughout the
whole program.
Figure 1: jStanley
Eclipse menuOurtoolprovidesadropdownmenu
within Eclipse, as shown in Figure 1, al-
lowing programmers to select their pref-
erences. This menu displays options to
chooseiftheywishtofocusonenergy,ex-ecutiontime,orboth,bychoosingJoules,
Milliseconds, or both, respectively. Ad-
ditionally,aswehaveseeninourprevi-
ous study [ 21], different population sizes
bringaboutdifferentenergyprofilesfor
collections. Thus, there is also an option
to allow the programmer to choose which of the three options are
closest to what they believe would best represent the program.
Before analyzing a program, the tool loads the data tables (from
CSVfiles)correspondingtothesettingschosenbytheprogrammer.
Thisinformationisfirstnormalizedbysortingeachmethodfrom
each collection and attributing a value of 1 to the lowest. After-
wards, each other value is divided by the lowest, obtaining a value
greater than 1 indirectly encoding the percentage of how worse
that collection’s method is to the lowest one. This is done for both
energy and time values, allowing the tool to combine these values
to obtain an overall ranking if both options are chosen to optimize.
Thecalculatedsuggestionscanbeshownvisuallythroughsource
codeflagging,asshowninFigure 2.Hereasmallflagappearsnextto
anidentifiedcollectionwhichmaybechangedtoamoreoptimized
one, and shows the programmer the best two alternatives. If theprogrammer wishes, they may select the option to change the
collections to the suggested one. It is to note that pure refactoring
propertiesmaynotbeguaranteedwhenchangingcollections,for
example natural sorting in Treecollections, or the non-acceptance
ofnullvalues in HashTable collections.
2.1 Implementation
Fourtasksdividethetool’sanalysis.Thefirsttask, Source Code
Analysis , detects existing collections within the program, and all
1jStanley, and other resources for this paper, can be found at: https://github.com/
greensoftwarelab/jStanley
Figure 2: Suggestion flagging and quick-fix
the invocations on these collections. Using the constructed AST,and the ASTVisitor offered by the Eclipse JDT API,we can easily
visit each variable and method invocation. Using the ASTVisitor,
we collect all the AST nodes which are FieldDeclarations, Vari-
ableDeclarationStatements,and Assignments.These nodesallow us
to determine the data type of a variable and focus on those which
are collections.
Afterwards, we analyze all the MethodDeclaration nodes. Often
times,collectionsarepassedtomethodsasparameters.Thus,we
also collect all these method references along with the type of
collections passed through, allowing us to match declarations and
method invocations.
Finally, all MethodInvocation nodes are analyzed to determine
which are JCF API methods which may be invoked during the
program’sexecution.Inthesecases,wedividethemintwotypes:
direct and indirect invocations. Direct invocations would be forexample a line of code with
students.add(); . An indirect invo-
cation represents methods declared throughout the program, in
which a direct invocation may occur. For example, method m1con-
tains a line with students.add(); students.add(); (two direct
invocations), thus m1would be an indirect invocation.
Theresultofthisanalysisisalistofalltheexistingcollections
withintheprogram,alldirectinvocationsofeachcollection(and
their source code location), all indirect invocations, and the collec-
tions which are passed as parameters of these indirect invocations.
Inthesecondtask, ResolveInvocations ,usingtheinformation
wenowhaveonallthedirectandindirectinvocations,wecalcu-
latetheamountoftimeseachmethodmaybeused.Forexample,
LinkedList.add(); iswithinmethod m1.Soweknowthe add()
method on LinkedList will be executed once. But method m1is
invokedtwicewithinanothermethod,sowemayassumethe add()
method may be invoked atleast twice, and not only once. Addition-
ally, during an indirect invocation where a collection is passed as a
parameter,amatchisalsomadewithourexistinglistofcollections.
This way, we may trace every possible path a collection may go
through and all possible method invocations upon the collection.
Afterwardsinthe CalculateCost task,thecostofeachcollec-
tion, considering all the existing invocations and data tables, is
calculated. jStanleycalculatesamatrixwithalltheinvocationcosts
ofeach collectionand methodbymultiplying thetotal numberof
invocations of each method by its normalized value.
Finally, in Calculate Suggestions , the sum of all the method
costsarecalculatedforeachcollection(representingeitherthetotal
cost of energy, time, or both depending on the selected options).
857
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. jStanley: Placing a Green Thumb on Java Collections ASE ’18, September 3–7, 2018, Montpellier, France
Table 1: Metrics of the projects evaluated. These metrics were calculated using OpenClover [1]
Project Branches Statements Methods Classes Files Packages LOC
Barbecue (for bar codes) 536 2,536 369 59 59 13 8,838
Battlecry (game) 534 1,800 125 12 11 1 3,343
Jodatime (time library) 5,162 13,318 3,909 242 166 7 70,872
Lagoon (web site maintenance) 1,746 4,211 646 96 81 10 16,922
Templateit (template file generator) 408 1,067 177 22 19 3 3,317
Twfbplayer (game) 684 3,307 777 135 104 12 14,682
Xisemele (XML library) 76 522 250 57 56 3 5,770
Table 2: Evaluation data for the projects
Test Suite Analysis Improvement
Project #Tests %Coverage Analysis (ms) #Changes %PKG (J) %CPU (J) %ms
Barbecue 152 62 2735 14 5.10 5.81 1.70
Battlecry 1* 69.4 514 4 16.79 11.49 12.76
Jodatime 4221 88.5 10490 5 7.21 7.29 7.75
Lagoon 18 4 1513 7 1.55 1.77 2.05
Templateit 31 4 1019 14 6.07 6.05 3.14
Twfbplayer 57 91 3437 51 6.04 6.30 4.36
Xisemele 167 20 588 1 4.25 4.38 3.18
* Instead of unit tests, this project has a simulated execution example
3 VALIDATION
To evaluate our tool regarding the energy savings it promotes, we
selected7 Javaprojects whichuseJCF collectionsand haveeither
atestsuiteorsimulatedexampleoftheprogram’sexecution.We
obtained these projects from SourceForge [ 18], a repository for
open-source applications, and from the SF110 corpus of classes [ 8],
a statistically representative sample of 110 Java projects.
The selected projects and some of their metrics are listed in
Table1. The projects vary from games to time libraries. The size
and complexity also varies between 3.000 and 70.000 lines of code
(LOC) or between 76 and 5.000 branches in the flow graph control.
We ran jStanley, according to a 25k population size (since we
are using only unit tests which tend to not stress collections as
much),oneachprojectandobtainedthelistofsuggestedenergyoptimizations, which were automatically applied. For each new
projectversion,were-ranthetestsuite,obtainingexactlythesame
results as the original ones. This means that, considering the avail-
abletests,thechangesactedasrefactorings.Theamountoftime
spent by our tool to analyze, and the number of suggested changes
are found in Table 2under the Analysis (ms) and#Changes column.
To measure the energy consumed by each project, before and
after the changes, we used Intel’s Runtime Average Power Limit
(RAPL) [6]. RAPL is an interface provided by (modern) Intel pro-
cessors to allow the access to energy and power readings. RAPL
is capable of providing very fine-grained level measurements as it
has already proven [ 10,25]. For our study, we measured 2 RAPL
domains: PKG energy consumed by an entire socket (including the
core and uncore domains); PP0 energy consumed by the CPU core.
ThisstudywasexecutedonalaptopwithUbuntu14.04.5LTS,
6GB of RAM, and Intel(R) Core(TM) i5-2430 CPU @ 2.40GHz. Both
the Java compiler and interpreter were versions 1.8.0_101.We ran each project’s test suite 25 times [ 13], and for each ex-
ecution,weextractedtheenergyconsumedinJoules(J)forboth
RAPLdomains,andtheexecutiontimeinmilliseconds(ms).The
numberoftestsandtestcoveragepercentagearelistedinTable 2
under the #Testsand%Coverage column respectively.
The energy consumption improvements are shown in Table 2.
Column %PKG (J) and%CPU (J) show the energy improvement
percentagerelativetotheoriginalprojectmeasuredbythepackage
andCPUrespectively.Column %msshowsthetimeimprovement
percentage. Each value is calculated as the average of the 25 ex-ecutions, excluding outliers, that is, values outside of the range
[Q1−1.5×IQ,Q3+1.5×IQ],where Q1andQ3arethefirstandthe
thirdquartiles,respectively,and IQ=Q3−Q1[27].Indeeditiscom-
mon to remove outliers for energy measurements [ 4]. For instance,
we know, from experience, that the first few runs of Java programs
tend to spent more energy than the remaining runs [3, 20,21].
Using jStanley, we were able to achieve between 2%-17% with
anaverageof6.7%energysavingsforPKG,andbetween2%-11%
with an average of 6.2% energy savings for CPU. Additionally, the
performance was also improved upon with an average of 5%. jStan-
leyspent on average 3 seconds to analyze our projects, with the
fastest and slowest spending 0.5 and 10 seconds respectively.
Thesevaluesarepositive,especiallywhencomparedtothelittle
work required by the developer. Moreover, in some cases the tests’
coveragewassmall,maybetoosmalltoactuallystressthecollec-
tions enough to make the gains more evident. Also, the fact that
weusedunittestsinsteadofactualsoftwarerunsmayimpactthe
results, but most likely in a negative way. A real usage of the appli-
cations would make more use of the collections thus most likelymaking the gains higher. In any case, building on these positive
results, we will run an in depth evaluation to fully understand the
potential of jStanley.
858
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France R. Pereira, P. Simão, J. Cunha, and J. Saraiva
4 RELATED WORK
There are several recent works showing the impact data structures
haveonenergyconsumption.Pintoetal.[ 24]specificallystudied
theenergyefficiencyonJava’sthread-safecollections,andwereable
to improveup to 17% energysavings by switchingout collections.
OthershavefocusedonmapdatastructuresinAndroid[ 26],and
offered guidelines for choosing the most appropriate choice if one
isworriedaboutenergyconsumption.Limaetal.[ 14]analyzedthe
energy behavior of various Haskell sequential and concurrent data
structures. They too were able to show how making changes on
whichdatastructuresareusedcanhavelargeimpacts,savingupto
60% ofenergy inone of theirsettings. Finally,they arguethat tools
tosupportdevelopersinquicklyrefactoringaprogramtoswitch
betweensuchprimitivescanbeofgreathelpifenergyisaconcern.
Two very similar studies looked at the influence of the Java Col-
lection framework on energy consumption [ 12,21]. While looking
attheproblemintwodifferentperspectives,thestudiesarevery
complementaryandyetagainshowhoweachcollectionhasadif-
ferentenergyfootprintdependingonwhatoperationsandmethods
are invoked. The tool we present in this paper is based off of the
methodology presented in the latter work.
Finally,themostsimilarworktooursisthe SEEDSframework[ 17].
This was the first automated support for optimizing the energy us-
ageofapplicationsbymakingcode-levelchanges.Aspecificinstan-
tiation of this framework was presented by the authors to improve
theenergyconsumptionofprojectsusingJava’sCollectionsAPI,
producing good results. While our approach is static and based
off data tables, SEEDSis a dynamic approach which follows a trial
and error method, testing each possible alternative, until the most
energy efficient one is found. While this approach may find the
bestalternativecollection,itisatimeconsuminganalysis.Bothour
studieslookedatJodatime,andwhilebothwereabletoimprovethe
energyefficiencyby8%,ourstaticcodeanalysistook10seconds
whiletheirapproachtook3hours.Forasecondcommonproject,
Barbecue, our approach improved it by 6%, taking 3 seconds, while
SEEDS improved it by 17%, but taking again 3 hours. As expected,
a static approach will be faster but not generate as good fits as a
dynamic analysis.
5 CONCLUSIONS AND FUTURE WORK
Inthispaperwepresented jStanley,atoolcapableofquicklydis-
coveringtheusageofenergy-inefficientJavacollections.Itcanalso
suggest and automatically evolve the code with better alternatives.
The initial evaluation we performed shows promising results with
savings between 2% and 17%.
Asfuturework,wewillextendtheavailablecollections,consider
their memory usage, and make suggestions of collections of differ-
entkinds(e.g.listtomap),performingthecorrespondingevolution,
leading to even greater savings.
REFERENCES
[1] Atlassian. 2018. OpenClover 4.2.1. http://openclover.org. (2018).
[2]Tarsila Bessa, Pedro Quintão, Michael Frank, and Fernando Magno Quin-
tão Pereira. 2016. JetsonLeap: A Framework to Measure Energy-Aware Code
Optimizations in Embedded and Heterogeneous Systems. In Proc. of the 20th
Brazilian Symposium on Programming Languages,FernandoCastorandYuDavid
Liu (Eds.). Springer Int. Publishing, 16–30.[3]Marco Couto, Tiago Carção, Jácome Cunha, João Paulo Fernandes, and João
Saraiva.2014. DetectingAnomalousEnergyConsumptioninAndroidApplica-
tions. In Programming Languages: 18th Brazilian Symposium, SBLP 2014, Maceio,
Brazil, October 2-3, 2014. Proceedings, Fernando Magno Quintão Pereira (Ed.).
Springer Int. Publishing, 77–91.
[4]LuisCruzandRuiAbreu.2017.Performance-basedGuidelinesforEnergyEfficient
Mobile Applications. In Proceedings of the 4th International Conference on Mobile
Software Engineering and Systems (MOBILESoft ’17).IEEEPress,Piscataway,NJ,
USA, 46–57. https://doi.org/10.1109/MOBILESoft.2017.19
[5]Dario Di Nucci, Fabio Palomba, Antonio Prota, Annibale Panichella, Andy Zaid-
man,andAndreaDeLucia.2017.Software-basedenergyprofilingofandroidapps:
Simple, efficientand reliable?.In Software Analysis, Evolution and Reengineering
(SANER), 2017 IEEE 24th International Conference on. IEEE, 103–114.
[6]MartinDimitrov,CarlStrickland,Seung-WooKim,KarthikKumar,andKshitij
Doshi.2015. Intel ®PowerGovernor. https://software.intel.com/en-us/articles/
intel-power-governor. (2015). Accessed: 2015-10-12.
[7]MiguelAFerreira,EricHoekstra,BoMerkus,BramVisser,andJoostVisser.2013.
Seflab: A lab for measuring software energy footprints. In Green and Sustainable
Software (GREENS), 2013 2nd Int. Workshop on. IEEE, 30–37.
[8]Gordon Fraser and Andrea Arcuri. 2014. A Large Scale Evaluation of Automated
Unit Test Generation Using EvoSuite. ACM Transactions on Software Engineering
and Methodology (TOSEM) 24, 2 (2014), 8.
[9]Erol Gelenbe andYvesCaseau. 2015. The impact ofinformation technology on
energy consumption and carbon emissions. Ubiquity 2015, June (2015), 1.
[10]MarcusHähnel,BjörnDöbel,MarcusVölp,andHermannHärtig.2012.Measuringenergy consumption for short code paths using RAPL. SIGMETRICS Performance
Evaluation Review 40, 3 (2012), 13–17.
[11]RobertRHarmonandNoraAuseklis.2009. SustainableITservices:Assessingthe
impactofgreencomputingpractices.In Management of Engineering & Technology,
2009. PICMET 2009. Portland Int. Conf. on. IEEE, 1707–1717.
[12]Samir Hasan, Zachary King, Munawar Hafiz, Mohammed Sayagh, Bram Adams,
andAbramHindle.2016. Energyprofilesofjavacollectionsclasses.In Proc. of
the 38th Int. Conf. on Software Engineering. ACM, 225–236.
[13]Robert V Hogg and Elliot A Tanis. 1977. Probability and statistical inference.
Vol. 993. Macmillan New York.
[14]Luís Gabriel Lima, Gilberto Melfe, Francisco Soares-Neto, Paulo Lieuthier,
JoãoPauloFernandes,andFernandoCastor.2016. HaskellinGreenLand:Ana-
lyzing the Energy Behavior of a Purely Functional Language. In Proc. of the 23rd
IEEE Int. Conf. on Software Analysis, Evolution, and Reengineering.IEEE,517–528.
[15]KenanLiu,GustavoPinto,andYuDavidLiu.2015. Data-orientedcharacterization
of application-level energy optimization. In Fundamental Approaches to Software
Engineering. Springer, 316–331.
[16]Irene Manotas, Christian Bird, Rui Zhang, David Shepherd, Ciera Jaspan, Caitlin
Sadowski,LoriPollock,andJamesClause.2016. Anempiricalstudyofpractition-
ers’ perspectives on green software engineering. In Software Engineering (ICSE),
2016 IEEE/ACM 38th International Conference on. IEEE, 237–248.
[17]IreneManotas,LoriPollock,andJamesClause.2014. SEEDS:ASoftwareEngi-
neer’s Energy-Optimization Decision Support Framework. In Proc. of the 36th
Int. Conf. on Software Engineering. ACM, 503–514.
[18] Slashdot Media. 2018. SourceForge. https://sourceforge.net. (2018).
[19]Candy Pang, Abram Hindle, Bram Adams, and Ahmed E Hassan. 2016. What do
programmers know about software energy consumption? IEEE Software 33, 3
(2016), 83–89.
[20]Rui Pereira, Marco Couto, Francisco Ribeiro, Rui Rua, Jácome Cunha, João Paulo
Fernandes, and João Saraiva. 2017. Energy Efficiency Across Programming
Languages: How Do Energy, Time, and Memory Relate?. In Proceedings of the
10th ACM SIGPLAN International Conference on Software Language Engineering
(SLE’17). ACM, 256–267. https://doi.org/10.1145/3136014.3136031
[21]RuiPereira,MarcoCouto,JoãoSaraiva, JácomeCunha, andJoão PauloFernan-
des. 2016. The Influence of the Java Collection Framework on Overall Energy
Consumption. In Proc. of the 5th Int. Workshop on Green and Sustainable Software
(GREENS ’16). ACM, 15–21.
[22]Gustavo Pinto and Fernando Castor. 2017. Energy efficiency: a new concern for
application software developers. Commun. ACM 60, 12 (2017), 68–75.
[23]Gustavo Pinto, Fernando Castor, and Yu David Liu. 2014. Mining questions
aboutsoftwareenergyconsumption.In Proc. of the 11th Working Conf. on Mining
Software Repositories. ACM, 22–31.
[24]G.Pinto,K.Liu,F.Castor,andY.D.Liu.2016. AComprehensiveStudyontheEnergy Efficiency of Java’s Thread-Safe Collections. (Oct 2016), 20–31. https:
//doi.org/10.1109/ICSME.2016.34
[25]Efraim Rotem, Alon Naveh, Avinash Ananthakrishnan, Eliezer Weissmann, and
DoronRajwan.2012. Power-ManagementArchitectureoftheIntelMicroarchi-
tecture Code-Named Sandy Bridge. IEEE Micro 32, 2 (2012), 20–27.
[26]RubénSaborido,RodrigoMorales,FoutseKhomh,Yann-GaëlGuéhéneuc,and
Giuliano Antoniol. 2018. Getting the most from map data structures in Android.
Empirical Software Engineering (2018), 1–36.
[27] John W Tukey. 1977. Exploratory data analysis. Addison-Wesley Pub. Co.
859
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 