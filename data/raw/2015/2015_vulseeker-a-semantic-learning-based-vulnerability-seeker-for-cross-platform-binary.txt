VulSeeker: A Semantic Learning Based Vulnerability Seeker for
Cross-Platform Binary
Jian Gaoâˆ—
School of Software, Tsinghua University
Beijing, China
gaojian094@gmail.comXin Yang
School of Software, Tsinghua University
Beijing, China
yangx16@mails.tsinghua.edu.cnYing Fu
School of Software, Tsinghua University
Beijing, China
fy17@mails.tsinghua.edu.cn
Yu Jiangâ€ 
School of Software, Tsinghua University
Beijing, China
jiangyu198964@126.comJiaguang Sun
School of Software, Tsinghua University
Beijing, China
ABSTRACT
Codereuseimprovessoftwaredevelopmentefficiency,however,vul-
nerabilities can be introduced inadvertently. Many existing works
compute the code similarity based on CFGs to determine whether
abinaryfunctioncontainsaknownvulnerability.Unfortunately,
their performance in cross-platform binary search is challenged.
This paper presents VulSeeker , a semantic learning based vul-
nerability seeker for cross-platform binary. Given a target function
and a vulnerable function, VulSeeker first constructs the labeled
semanticflowgraphsandextractsbasicblockfeaturesasnumerical
vectors for both of them. Then the embedding vector of the whole
binaryfunctionis generated byfeedingthenumericalvectors of
basicblockstothecustomizedsemanticsawareDNNmodel.Finally,
the similarity of the two binary functions is measured based on
the Cosine distance. The experimental results show that VulSeeker
outperformsthestate-of-the-artapproachesintermsofaccuracy.
Forexample,comparedtothemostrecentandrelatedworkGemini,
VulSeeker finds50.00%morevulnerabilitiesinthetop-10candidates
and 13.89% more in the top-50 candidates, and improves the values
of AUC and ACC for 8.23% and 12.14% respectively. The video is
presented at https://youtu.be/Mw0mr84gpI8.
CCS CONCEPTS
â€¢Security and privacy â†’Vulnerability scanners;
KEYWORDS
semantic learning, vulnerability search, cross-platform binary
ACM Reference Format:
JianGao,XinYang,YingFu,YuJiang,andJiaguangSun.2018.VulSeeker:A
SemanticLearningBasedVulnerabilitySeekerforCross-PlatformBinary.In
Proceedingsofthe201833rdACM/IEEEInternationalConferenceonAutomated
Software Engineering (ASE â€™18), September 3â€“7, 2018, Montpellier, France.
ACM,NewYork,NY,USA, 4pages.https://doi.org/10.1145/3238147.3240480
âˆ—Alsowith BeijingNationalResearchCenterforInformationScienceandTechnology.
â€ Correspondence author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE â€™18, September 3â€“7, 2018, Montpellier, France
Â© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32404801 INTRODUCTION
Inordertoimprovetheefficiencyofsoftwaredevelopment,copy-
pasteofcodeandreuseofthird-partylibrariesarecommon.Ifsuch
adevelopmentprocessispoorlymanaged,unpatchedvulnerable
codecaneasilybepropagatedtodifferentsoftwareprograms.With
thepopularityofterminaldevices,softwareprogramsontraditional
x86architecture aregraduallybeing compiledandported toother
architectures (e.g., ARM, MIPS). As a consequence, more and more
binary programs contain a large number of similar or identical
vulnerable codes. For example, 145 unpatched clone vulnerabilities
are confirmed in the Debian system [7].
Manyworkshavebeenpresentedtoperformvulnerabilitysearch
for cross-platform binaries based on code clone techniques [ 3,5,6,
9,14]orfuzzytesting[ 8,13].Mostoftheclone-basedtechniques
analyzethecontrolflowgraph(CFG)todeterminewhetherabinary
containsvulnerabilitiesornot[ 3,5,6,14].Theyperformwellon
their settings, but the accuracy and efficiency may lose coming
across to large-scale binaries.
In this paper, we present VulSeeker1, a semantic learning based
vulnerabilityseekerforcross-platformbinary. VulSeeker acquires
a higher accuracy and efficiency through the labeled semantic flow
graph (LSFG) construction and the semantics aware deep neuralnetwork (DNN) based function semantics generation. The LSFG
containsboththeCFGandDFG(dataflowgraph),somoresemantic
information of a binary function is captured than using the CFG
alone. The semantics aware DNN model transforms numerical fea-
turesofbasicblockswithinthefunctionintofunctionsemantics
(or embedding vector). Vulnerability is identified by measuring the
similarity of two binary functions based onthe Cosinedistance of
their embedding vectors.
For evaluation, we compare VulSeeker with the state-of-the-art
cross-platformbinaryclonevulnerabilitysearchapproachonsome
widely used third-party benchmarks consisting of real-world appli-
cations.Theexperimentalresultsshowthat VulSeeker outperforms
themostrecentandrelatedworkGemini[ 14].Onaverage,interms
ofclonedetection, theAUCandACC of VulSeeker are88.49%and
81.3%, which are 8.23% and 12.14% higher than those of Gemini.
Furthermore,weusetheCVE-2015-1791vulnerabilitytoevaluate
the vulnerability search capability in 4643 firmware images. In the
top-10 and top-50 most similar results, VulSeeker found 50.00% and
13.89% more real vulnerabilities than Gemini.
1VulSeeker is available at https://github.com/buptsseGJ/VulSeeker
896
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Jian Gao, Xin Yang, Ying Fu, Yu Jiang, and Jiaguang Sun
7DUJHWELQDULHV 9XOQHUDELOLW\
GDWDEDVH
9XOQHUDELOLW\
UHSRUW/6)*FRQVWUXFWLRQ
%ORFNIHDWXUHH[WUDFWLRQ
)XQFWLRQVHPDQWLFV
JHQHUDWLRQEDVHGRQ'11(PEHGGLQJYHFWRU
IRUWDUJHW(PEHGGLQJYHFWRU
IRUYXOQHUDELOLW\
6LPLODULW\FDOFXODWLRQ
(a) Overall architecture and workflow of VulSeeker .SXVKUES
PRYUESUVS
VXEUVSK
PRY>UESYDUB@HGL
PRY>UESYDUB@
PRY>UESYDUB@
PRY>UESYDUB@
FPS>UESYDUB@
M]VKRUWORFBE
DGG>UESYDUB@ 
PRYHD[>UESYDUB@PRYHD[
MPSVKRUWORFBORFB%
DGG>UESYDUB@
PRYHD[>UESYDUB@
PRYHD[
PRY>UESYDUB@HD[
PRYHD[
OHDYH
UHWQ 
 Å˜
Å™Åš
Å›
(b) An example of the LSFG construction.>@
>@ >@
>@Å˜
Å™Åš
Å› 
 
 
(c) An example of the block feature extraction.
Figure1: VulSeeker design.(a)istheoverallarchitecture.(b-c)areexamplesforLSFGconstructionandblockfeatureextraction.
2 RELATED WORK
Binary Clone Detection. COP[9] is a plagiarism detection tool
that combines program semantics with longest common subse-
quencebasedfuzzymatching. BinGold[2]extractsthesemantics
of binary code in terms of both the DFG and the CFG, and syn-
thesizes them into a novel representation called the semantic flow
graph. However, it does not support cross-architecture clone de-
tection.BinSim[11]calculatestheequivalencesofalignedsystem
callstobetterhandlecodeobfuscation.Itcombinesdynamicslicing
with the weakest precondition calculation to identify fine-grained
semantic similarities between two execution traces.
Vulnerability Search. Bingo[3] leverages selective inlining
and length variant partial trace to compute function semantics,
whichconstitutefunctionmodelstoperformsimilaritycomparison
and vulnerability search. Genius[6] utilizes the spectral clustering
to generate a codebook and calculates the similarity between a
specificACFGandeachrepresentativeACFGinthecodebookbased
onthebipartitegraphmatchingalgorithm. Gemini[14]extractsthe
same lightweight features as Geniusand only relies on the CFG to
generate the embedding vector of the function. Then the similarity
of two embedding vectors is measured to get a prediction result.
Main Difference. Differentfromtheabovework,asfaraswe
know,VulSeeker isthefirsttoolthatcombinesCFGandDFGtoform
LSFG,andappliesdeeplearningtoperformvulnerabilitysearchfor
cross-platform binary. It extracts 8 types of lightweight instruction
features for each basic block in LSFG. Based on the graph topology
and the revised semantics aware DNN model, we apply 6 layer
iterations to the LSFG to obtain the semantic representation of the
entire binary function, and acquire higher accuracy.
3VULSEEKER DESIGN
Theoverallworkflowof VulSeeker isshowninFigure 1(a).Itcon-
tainsfourmajorcomponents: LSFGconstruction, blockfeatureex-
traction,function semantics generation andsimilarity calculation.
The goal of VulSeeker is to determine whether the target binary
containsfunctions similartoknown vulnerabilitiesornot. There-
fore,itsinputistwobinaryfunctionsfromthetargetbinaryand
the vulnerability database. Firstly, VulSeeker constructs the LSFGs
forthetwobinaryfunctions.Thenitextracts8typesoflightweight
instruction features and encodes them as a numerical vector for
eachbasicblockoftheLSFG.FunctionsemanticsisgeneratedbyfeedingthenumericalvectorsofbasicblockswithintheLSFGto
the semantics aware deep neural network (DNN) model. Finally,
VulSeeker outputs whether the target binary function contains a
knownvulnerabilityornotbasedonthesimilarityofembedding
vectors of the two input functions.
3.1 LSFG Construction
LabeledsemanticflowgraphcontainsboththeCFGandthedata
flow graph (DFG), and their edges are marked as 0 and 1 respec-
tively. Its purpose is to improve the accuracy of function semantics
generation, because it considers both the control structure and
the data transfer within a function, which will effectively mitigate
thestructuralinterferenceintroducedbythevaryingCFGunder
different platforms. Figure 1(b) illustrates an example of the LSFG.
WeuseIDAPython providedby IDAPro[12]tocreatetheCFG
for the basic blocks of each binary function. Based on the CFG,
we infer whether there should be a data pointing edge between
two basic blocks by leveraging the LLVM IR plugin [10]o nIDA
Pro. For two instructions iandjfrom two different basic blocks
which meet the CFG topology, if the instruction iwrites a memory
location and the instruction jreads the same memory address, we
createadatadependentedgeforthesetwoblocks.Inaddition,only
the data dependencies between different blocks are preserved, and
thereisatmostonedatadependentedgebetweentwobasicblocks.
VulSeeker stores the control edges and data edges of each function
in two files.
3.2 Block Feature Extraction
Byreferringtofeaturesusedinpreviousworks[ 2,6]andexecuting
a series of code clone experiments for different feature sets, we
havefinallydeterminedtouse8typesoffeaturesshowninTable
1astheinitialsemanticrepresentationofeachbasicblock.These
selectedfeaturesarelightweightandrobust,whichcanbeeasily
extractedandchangelittleundervariousimplementationplatforms
withdifferentmicroprocessorarchitecturesandvariouscompilation
optimization configurations. We utilize the IDAPython to extract
features for each basic block. Then we encode the 8 features of
each basic block as a numerical vector. Figure 1(c) is the numerical
vectors of each basic block corresponding to the function in Figure
1(b). For each binary function, numerical vectors of all the basic
blocks within the function are stored in a separate file.
897
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. VulSeeker: A Semantic Learning Based Vulnerability Seeker for Cross-Platform Binary ASE â€™18, September 3â€“7, 2018, Montpellier, France
Table 1: Basic-block level features used by VulSeeker .
Feature Name Example
No. of stack operation instructions push, pop
No. of arithmetic instructions add, sub
No. of logical instructions and, or
No. of comparative instructions testNo. of library function calls call printf
No. of unconditional jump instructions jmp
No. of conditional jump instructions jne, jb
No. of generic instructions mov, lea
3.3 Function Semantics Generation
The input of this component is the ddimensional initial numerical
vectorsofallthebasicblockswithinthefunction,andtheoutput
isthepdimensionalembeddingvectorrepresentingthefunction
semantics.Topreciselycapturefunctionsemantics,dataandcontrol
dependencies between basic blocks along the LSFG topology need
to be considered. Referring to the structure2vec neural network [ 4],
we propose a semantics aware DNN model shown in Figure 2that
specializes in processing structured LSFG representation.

  	
  
	

				
	
				 		 
         
 
 
	  
			
	
	
				
Figure 2: The DNN model of VulSeeker .
Figure2(a) is a LSFG denoted as Ð´=/angbracketleftV,E/angbracketright, containing three
vertices with initial numerical vectors: x1,x2,x3, where VandE
representthevertexsetandedgeset,respectively.Edgesmarked
1 and 0 indicate data dependency and control dependency, respec-
tively. The DNN model contains a total of Tlayer iterations, and
each iteration transforms the initial numerical vector xiof each
vertexiinto its embedding vector /tildewideÎ¼(t)
i. After obtaining the embed-
ding vectors of all the basic block vertices within the function, we
aggregatethemintothe pdimensionalembeddingvector /tildewideÎ¼ofthe
function with the formula /tildewideÎ¼=W2(Î£iâˆˆV/tildewideÎ¼(T)
i), where W2is apÃ—p
dimensional parameter matrix.
Figure2(b) illustrates the schematic diagram for generating the
embeddingvector /tildewideÎ¼(t)
iofeach vertex iduringthe t-layeriteration.
The input of the transformation process consists of three different
parts: initial numerical vector xiof the corresponding vertex i(the
dotted arrow in Figure 2(a-b)), the sum of previous embedding vec-
torsofverticespointingtovertex ithroughthecontroldependency
(denoted as C(i)), and the sum of previous embedding vectors of
vertices pointing to vertex ithrough the data dependency (denoted
asD(i)).Theembeddingvectorofvertex iiscalculatedthroughthe
formula /tildewideÎ¼(t)
i=tanh(W1xi+Ïƒc(Î£jâˆˆC(i)/tildewideÎ¼(tâˆ’1)
j)+Ïƒd(Î£jâˆˆD(i)/tildewideÎ¼(tâˆ’1)
j)), whereW1is adÃ—pdimensional parameter matrix. ÏƒcandÏƒdare two
nlayer fully-connected networks responsible for calculating an
embedding vector with more powerful representation capability,
they are represented as follows:
/braceleftbiggÏƒc(lc)=P1Ã—ReLU(P2Ã—Â·Â·Â·ReLU(PnÃ—lc))
Ïƒd(ld)=Q1Ã—ReLU(Q2Ã—Â·Â·Â·ReLU(QnÃ—ld))
wherenistheembeddingdepthofeachvertex, PiandQiarepÃ—p
dimensionalparametermatrixes.Through Tlayeriterations,the
featureofeachvertexispropagatedtootherverticesastheiteration
progresses along with the LSFG topology, ensuring that each basic
block of the function has corresponding context semantics.
3.4 Similarity Calculation
Once obtaining the embedding vector /tildewideÎ¼for target function and
the embedding vector /tildewideÎ½for vulnerable function, VulSeeker calcu-
lates their similarity with the Cosinefunction /hatwidey=cos(/tildewideÎ¼,/tildewideÎ½)=/tildewideÎ¼Â·/tildewideÎ½/bardblex/bardblex/bardblex/tildewideÎ¼/bardblex/bardblex/bardblexÂ·/bardblex/bardblex/bardblex/tildewideÎ½/bardblex/bardblex/bardblex,
where /hatwideyis the similarity score, ranging from âˆ’1 to 1. If the sim-
ilarity score /hatwideyis larger than a pre-defined threshold, the target
binaryfunctionisconsideredsimilartothevulnerability.Weuse
TensorFlow [1] to implement the semantics aware DNN model and
apply the stochastic gradient descent algorithm to automatically
learn model parameters, such as W1,W2,P1andQ1.
4 EXPERIMENTAL RESULTS
VulSeeker mainlycontains3executablefilesthatcanbeusedbased
on the following steps: 1) modify the config.py file to configure the
targetprogramsforvulnerabilitysearch;2)executethe command.py
file to generate the LSFGs and extract initial numerical features
forbasicblocks;3)executethe search_by_list_vulseeker.py fileto
obtain the embedding vectors of functions and get the function list
in descending order of similarity scores.
VulSeeker isevaluatedontwodatasets.DatasetIcontains735,540
functionswith9,345K basicblocks.Wecompile BusyBox(v1.21.0),
OpenSSL (v1.0.1fandv1.0.1u)and Coreutils (v6.5andv6.7)in X86,
X64, MIPS32, MIPS64, ARM32, ARM64 architectures, using GCC
(v4.9andv5.5)withoptimizationlevelsO0-O3.DatasetIIconsists
of 4643 firmware images for various architectures from [ 6]. All
experimentsareconductedondefaultconfigurationsoftheDNN
modelasfollows:theembeddingdepth nis2,theembeddingsize
pis 64, the number of iterations Tfor each basic block is 6, the
training epoch is 100.
Accuracy of Code Clone .We treat two different compiled ver-
sions of the same source function as a pair of similar functions and
vice versa. We randomly select 2500 pairs of similar functions and
2500 pairs of dissimilar functions from the dataset I to perform the
comparative experiment with Gemini configured with the optimal
parameters[ 14].Figure3istheirROC(receiveroperatingcharac-
teristic) curves of code clone. We observe that the ROC curve of
VulSeeker isaboveGemini,whichmeansthat VulSeeker canachieve
a higher true positive rate at the same false positive rate. The AUC
value and ACC value of VulSeeker are 88.49% and 81.3%, which
are 8.23% and 12.14% higher than those of Gemini. In summary,
VulSeeker outperforms Gemini, because in addition to the CFG, we
alsoconstructtheDFGfortrackingtheusagesofvariablesbetweenbasicblocks.Duringfunctionsemanticsgeneration,weobtainmore
robust semantic information with a revised DNN structure, which
is beneficial to the effective identification of clone functions.
898
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. ASE â€™18, September 3â€“7, 2018, Montpellier, France Jian Gao, Xin Yang, Ying Fu, Yu Jiang, and Jiaguang Sun
     
)DOVH3RVLWLYH5DWH7UXH3RVLWLYH5DWH
9XO6HHNHU
*HPLQL
Figure 3: ROC curves of code clone.
Furthermore, the experimental result of Gemini here is lower
comparedwiththedescriptionoftheliterature[ 14].Tworeasons
lead to this situation. One is that our dataset I contains 5 programs,
but Gemini onlycontains 2of them.The otheris thatwe compile
theseprogramsintosixarchitectures,includingthree64-bitones,
andGeminionlycompilesthemintothree32-bitones.Thenumber
of general-purpose registers used in 32-bit and 64-bit architectures
isdifferent,whichaffectsthefeaturevectorsofbasicblocks,and
its results drop accordingly. In their relatively simpler setting, they
couldacquiretheAUCvalueof97%,andwecouldimprovethevalue
to almost 99%. We found that the more complex the dataset is, the
moreimprovements VulSeeker wouldachieve,andtheperformance
of Gemini drops faster than VulSeeker for complex settings.
Accuracy of Vulnerability Search .We employ dataset II to
evaluate the effectiveness of VulSeeker and Gemini in vulnerability
search.Wetake CVE-2015-1791 with48compiledversionsasthevul-
nerable function. For each version of the vulnerability, we employ
the two tools to perform the search task from known vulnerable
firmwareimages.Foreachfirmwareimage,wesortthefunctions
indescendingorderoftheaveragesimilarityscoresfor48searches.
VulSeeker ranksthevulnerabilityfunction8thonaverage,whereas
Gemini ranks 99th on average. If we take the highest rankings
outof48searchesforeachfirmwareimage, VulSeeker hasa100%
chanceoffindingthevulnerablefunctionintop-3candidateswhich
is 11.76% higher than Gemini.
Table 2: The accuracy of vulnerability search
top-KGemini VulSeeker
#Num Percent #Num Percent
1 1 100% 1 100%
5 2 40% 3 60%
10 4 40% 6 60%50 36 72% 41 82%
100 75 75% 83 83%
Forthesearchresultsofthe MIPS32versionvulnerability,wesort
thefunctionsinallfirmwareimagesindescendingorderofsimilar-
ityscores.Table 2showstheeffectivenessofvulnerabilitysearchon
thetop-Kmostsimilarresultsamongallfunctions.Column1isthe
differentKvalue. Columns 2 and 4 are the number of real vulnera-
bilitiesinthetop- Kresults,andcolumns3and5arethepercentage
of corresponding real vulnerabilities. We can see that VulSeeker
hasagreatimprovementonthesearchprecisionthanGemini.Intop-10 results, VulSeeker finds 50% more vulnerabilities than Gem-
ini.Insummary, VulSeeker outperformsGeminiinthevulnerability
search in terms of the CVE-2015-1791. We also do some evaluation
on other CVEs, and the performance improvements remain.
Time Cost . VulSeeker mainly consists of four components, and
for the size of the experimental database, it can determine whether
thegivenbinaryfunctioncontainsaknownvulnerabilitywithin
an average of 0.20 seconds, while Gemini takes about 0.15 seconds.
Function semantics generation takes up almost half of the time
cost, and its time cost grows linearly with the number of basic
blocks within the function. Although the time cost of VulSeeker is
0.05 seconds more than Gemini, we can achieve a higher search
accuracy in a reasonable time.
5 CONCLUSION
In this paper, we present VulSeeker , a cross-platform binary vul-
nerability seeker based on semantic learning. With integrating the
CFG and the DFG of the binary function, we capture more func-
tion semantics. Experimental results show that VulSeeker achieves
88.49% AUC value and 81.3% ACC value for code clone, which
improves8.23%and12.14%thanGemini,respectively.Inthecase
studyofCVE-2015-1791vulnerabilitysearch, VulSeeker finds50.00%
morevulnerabilitiesinthetop-10candidatesand13.89%morein
the top-50 candidates. For the time cost of vulnerability search,
VulSeeker needs 0.20 seconds to determine whether a function has
aknownvulnerabilityornotintherelativelyhugedatabase.These
demonstrate that VulSeeker is suitable for vulnerabilitysearchof
large-scale code.
REFERENCES
[1]MartÄ±nAbadi,AshishAgarwal,PaulBarham,etal .2015. TensorFlow:Large-Scale
Machine Learning on Heterogeneous Systems. http://tensorflow.org/ Software
available from tensorflow.org.
[2]Saed Alrabaee, Lingyu Wang, and Mourad Debbabi. 2016. BinGold: Towards
robustbinaryanalysisbyextractingthesemanticsofbinarycodeassemantic
flow graphs (SFGs). Digital Investigation 18 (2016), S11â€“S22.
[3]Mahinthan Chandramohan, Yinxing Xue, Zhengzi Xu, Yang Liu, Chia Yuan Cho,
and Hee Beng Kuan Tan. 2016. Bingo: Cross-architecture cross-os binary search.
InSIGSOFT FSE. ACM, 678â€“689.
[4]HanjunDai,BoDai,andLeSong.2016. Discriminativeembeddingsoflatentvari-
able models for structured data. In International Conference on Machine Learning.
2702â€“2711.
[5]Yaniv David, Nimrod Partush, and Eran Yahav. 2016. Statistical similarity of
binaries. ACM SIGPLAN Notices 51, 6 (2016), 266â€“280.
[6]Qian Feng, Rundong Zhou, Chengcheng Xu, Yao Cheng, Brian Testa, and Heng
Yin.2016. Scalablegraph-basedbugsearchforfirmwareimages.In CCS.ACM,
480â€“491.
[7]Jiyong Jang, Abeer Agrawal, and David Brumley. 2012. ReDeBug: finding un-
patched code clones in entire os distributions. In Security and Privacy (SP), 2012
IEEE Symposium on. IEEE, 48â€“62.
[8]JieLiang,MingzheWang,YuanliangChen,YuJiang,andRenweiZhang.2018.
Fuzz testing in practice: Obstacles and solutions. In 25th International Conference
on Software Analysis, Evolution and Reengineering.
[9]Lannan Luo, Jiang Ming, Dinghao Wu, Peng Liu, and Sencun Zhu. 2014.
Semantics-basedobfuscation-resilientbinarycodesimilaritycomparisonwith
applications to software plagiarism detection. In SIGSOFT FSE.
[10]MIASM.[n.d.]. ReverseEngineeringFramework. https://github.com/cea-sec/
miasm. Accessed May 20, 2018.
[11]JiangMing,DongpengXu,YufeiJiang,andDinghaoWu.2017. BinSim:Trace-
basedsemanticbinarydiffingviasystemcallslicedsegmentequivalencechecking.
USENIX.
[12]IDAPro.[n.d.]. TheIDAProDisassemblerandDebugger. https://www.hex-rays.
com/. Accessed May 20, 2018.
[13]MingzheWang,JieLiang,YuanliangChen,YuJiang,XunJiao,HanLiu,Xibin
Zhao, and Jiaguang Sun. 2018. SAFL: Increasing and Accelerating Testing Cover-
age with Symbolic Execution and Guided Fuzzing. In ICSE.
[14]XiaojunXu,ChangLiu,QianFeng,HengYin,LeSong,andDawnSong.2017.Neu-
ral Network-based Graph Embedding for Cross-Platform Binary Code Similarity
Detection. In CCS. ACM, 363â€“376.
899
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:09 UTC from IEEE Xplore.  Restrictions apply. 