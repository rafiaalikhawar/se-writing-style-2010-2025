arXiv:1902.09099v1  [cs.CR]  25 Feb 2019MitigatingPower SideChannels duringCompilation
JingboWang
University ofSouthern California
LosAngeles,California,USAChunghaSung
University of Southern California
LosAngeles,California,USAChaoWang
University of Southern California
LosAngeles,California,USA
ABSTRACT
The code generation modules inside modern compilers such as
GCC and LLVM, which use a limited number of CPU registers
to store a large number of program variables, may introduces ide-
channelleakseveninsoftwareequippedwithstate-of-the- artcoun-
termeasures. We propose a program analysis and transformat ion
based method to eliminate this side channel. Our method has a
type-basedtechniquefordetectingleaks,whichleverages Datalog-
based declarative analysis and domain-speciﬁc optimizati ons to
achieve high eﬃciency and accuracy.Italsohas a mitigation tech-
nique for the compiler’s backend, more speciﬁcally the regi ster
allocation modules, to ensure that potentially leaky inter mediate
computationresultsarealwaysstoredindiﬀerentCPUregis tersor
spilled to memory with isolation. We have implemented and ev al-
uatedourmethodinLLVMforthex86instructionsetarchitec ture.
Ourexperimentsoncryptographicsoftwareshowthatthemet hod
is eﬀective inremoving the sidechannel while being eﬃcient , i.e.,
ourmitigatedcodeismorecompactandrunsfasterthancodem it-
igated using state-of-the-art techniques.
ACMReference Format:
JingboWang,ChunghaSung,andChaoWang.2019.MitigatingPowerSide
Channels during Compilation. In Proceedings of ACM Conference (Confer-
ence’17).ACM,NewYork, NY,USA, 13pages.
1 INTRODUCTION
Cryptographyisanintegralpartofmanysecurityprotocols ,which
in turn are used by numerous applications. However, despite the
strongtheoreticalguarantee,cryptosystemsinpracticea revulner-
able to side-channel attacks when non-functional properti es such
as timing, power and electromagnetic radiation are exploit ed to
gain information aboutsensitive data [22, 25, 27, 41,44,53 , 54, 63,
69, 77]. For example, if the power consumption of a device run -
ninganencryptionalgorithmdependsonthesecretkey,stat istical
techniques such as diﬀerential power analysis (DPA) can be u sed
toperformattacks reliably[22,27,43, 52,55].
Although there are techniques for mitigating power side cha n-
nels [2,3, 14, 15, 34, 35, 75], they focusexclusively onthe Boolean
level, e.g., by targeting circuits in cryptographic hardware or s oft-
warecodethathasbeenconvertedtobit-levelrepresentati ons[42].
Thislimitstheuseofsuchtechniquesinrealcompilers;asa result,
none of them was able to ﬁt into modern compilers such as GCC
andLLVMtodirectlyhandlethe word-level intermediaterepresen-
tation(IR).Inaddition,codetransformationsincompiler smayadd
new side channels, even if the input program is equipped with
state-of-the-art countermeasures.
Speciﬁcally,compilerstendtousealimitednumberoftheCP U’s
registers to store a potentially-large number of intermedi ate com-
putation results of a program. And, when two masked and hence
de-sensitizedvaluesareputintothesameregister,itispo ssiblefor
themaskingcountermeasure to be removed accidentally. We will
Conference’17,July 2017,Washington,DC,USA
2019.User-speciﬁed
Input Annotation
Variable to
Register Map
LLVM
BitCode
ProgramPInfo.Datalog
Type Checking
Domain-Speciﬁc
Optimization
DetectionLLVM Backend
Modiﬁcation
Register
Allocation
MitigationLeakage-free
Assembly
Figure1: Overviewof oursecurecompilation method
show, as part of this work, that even provably-secure techni ques
suchashigh-ordermasking[6,8,9]isvulnerabletosuchlea ks.In-
deed,wehavefoundleaksinthecompiledcodeproducedbyLLV M
for both x86 and MIPS/ARM platforms,regardless of whether t he
inputprogram is equippedwithhigh-order masking.
Tosolvetheproblem,weproposeasecurecompilationmethod
with two main contributions.First, we introducea type-inf erence
systemtosoundlyandquicklydetectpowerside-channellea ks.By
soundly,we mean that the system is conservative and guarant ees
not to miss real leaks. By quickly, we mean that it relies only on
syntactic information of the program and thus can be orders- of-
magnitudefasterthanformalveriﬁcation[35,75].Second, wepro-
poseamitigationtechniqueforthecompiler’sbackendmodu lesto
ensurethat,foreachpairofintermediatevariablesthatma ycause
side-channel leaks, the two values are always stored in diﬀe rent
registers ormemorylocations.
Figure 1 shows an overview of our method, which takes a pro-
gramPas input and returns the mitigated code as output. It has
twomajorsteps.First,soundtypeinference isusedtodetec tleaks
by assigning each variable a distribution type. User only provides
an initial annotation of input variables, i.e., public(e.g., plaintext),
secret(e.g., key), or random(e.g., mask), while the types of other
variables are inferred automatically. Based on the inferre d types,
wecheck foreach pair (/v.alt1,/v.alt2)ofvariables toseewhether theval-
uesmaybestoredinthesameregisterandcauseleaks.Ifthep airis
foundtobeleaky,weconstrainthecompiler’sbackend regis teral-
locationmodulestoensurethat /v.alt1and/v.alt2areassignedtodiﬀerent
registers orspilledtomemory.
Ourmethoddiﬀers fromexisting approachesinseveral aspec ts.
First, it speciﬁcally targets power side-channel leaks cau sed by
reuseofCPUregistersincompilers,whichhavebeenlargely over-
lookedby prior work. Second, it leverages Datalog, togethe r with
a number of domain-speciﬁc optimizations, to achieve high e ﬃ-
ciency and accuracy during leak detection, where type infer ence
rulesaredesignedspeciﬁcallytocaptureregisterreusere latedleaks.
Third, mitigation in the backend is systematic and leverage s the
existing production-quality modules in LLVM to ensure that the
compiledcodeis securebyconstruction.
Unlike existing techniques that require a prioritranslation of
theinputprogramtoaBooleanrepresentation,ourmethodwo rks
directly on the word-level IR and thus ﬁts naturally into mod ernConference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
compilers.Foreachprogramvariable,theamountofleakisq uanti-
ﬁedusingthewell-known HammingWeight (HW)and Hamming
Distance (HD) leakagemodels[49,50].Correlationbetween these
modelsandleaksonrealdeviceshasbeenconﬁrmedinpriorwo rks
(seeSection2).Weshallalsoshow,via experiments,thatle akstar-
geted by our method exist even in program equipped with high-
order masking [6,8, 9].
Todetectleaksquickly,werelyontypeinference,whichmod els
theinputprogramusingasetofDatalogfactsandcodiﬁesthe type
inferencealgorithminasetofDatalogrules.Then,anoﬀ-th e-shelf
Datalogsolverisusedtodeducenewfacts.Here,adomain-sp eciﬁc
optimization, for example, is to leverage the compiler’s ba ckend
modules to extract a map from variables to registers and util ize
the map to reduce the computational overhead, e.g., by check ing
pairs of some(instead of all)variables forleaks.
Our mitigation in the compiler’s backend is systematic: it e n-
suresthatallleaksdetectedbytypeinference areeliminat ed.This
is accomplished by constraining register allocation modul es and
then propagating the eﬀect to subsequent modules, without h av-
ingtoimplementanynew backendmodulefromscratch.Ourmit -
igation is also eﬃcient in that we add a number of optimizatio ns
toensure thatthemitigated codeis compactand has lowrunti me
overhead.Whileourimplementationfocusesonx86,thetech nique
itself isgeneral enough thatitmaybeappliedtootherinstr uction
set architectures (ISAs) such as ARMand MIPS as well.
We have evaluated our method on a set of cryptographic soft-
warebenchmarks[8,14],includingimplementationsofwell -known
cipherssuchasAESandMAC-Keccak.Thesebenchmarkprogram s
are all protected by masking countermeasures but, still, we de-
tectedregisterreuserelatedleaksintheLLVMcompiledcod e.The
code produced by our mitigation, also based on LLVM, is alway s
leakfree.Intermsofperformance,ourmethodsigniﬁcantly outper-
formedcompetingapproachessuchashigh-order maskingint hat
our mitigated code not only is more compact and secure, but al so
runs signiﬁcantly faster than code mitigated by high-order mask-
ing techniques [8, 9].
To summarize,wemake thefollowingcontributions:
•We show that register reuse introduces side-channel leaks
even insoftwarealready protectedbymasking.
•WeproposeaDatalogbasedtypeinferencesystemtosoundly
and quicklydetect theseside-channel leaks.
•Weproposea mitigationtechniqueforthecompiler’s back-
end modulestosystematicallyremove theleaks.
•We implement themethod in LLVM and show its eﬀective-
ness ona set of cryptographicsoftware.
The remainder of thepaperis organized as follows.First,we il-
lustrate the problem and the technical challenges associat ed with
solvingit inSection2.Then,wereview thebackgroundinclu ding
thethreatmodelandleakagemodelinSection3.Next,wepres ent
our method for leak detection in Section 4 and leak mitigatio n in
Section 5, followed by domain-speciﬁc optimizations in Sec tion 6.
We present our experimental results in Section 7, review the re-
latedwork inSection8,and give ourconclusions inSection9 .
2 MOTIVATION
We use examples to illustrate why register reuse may lead to side-
channel leaks and thechallenges forremoving them.///quotesingle.Vartxt/quotesingle.Var: PUBLIC, /quotesingle.Varkey/quotesingle.Var: SECRET and /quotesingle.Vart/quotesingle.Var is HW-sensitive
uint32 Xor(uint32 txt, uint32 key) {uint32 t = txt ^ key; returnt;}
//random variable /quotesingle.Varmask1/quotesingle.Var splits /quotesingle.Varkey/quotesingle.Var to secure shares {ma sk1,mk}
uint64 SecXor(uint32 txt, uint32 key, uint32 mask1) {
uint32 mk = mask1 ^ key; // mask1^key
uint32 t = txt ^ mk; // txt^(mask1^key)
return(mask1,t);
}
///quotesingle.Varmask1/quotesingle.Var splits /quotesingle.Varkey/quotesingle.Var to shares {mask1,mk} a priori
///quotesingle.Varmask2/quotesingle.Var splits the result to shares {mask2,t3} before ret urn
uint64 SecXor2(uint32 txt, uint32 mk, unit32 mask1, unit32 mask2) {
uint32 t1 = txt ^ mk; // txt^(mask1^key)
uint32 t2 = t1 ^ mask2; // (txt^mask1^key)^mask2
unit32 t3 = t2 ^ mask1; // (txt^mask1^key^mask2)^mask1
return{mask2,t3};
}
Name Approach HW-Sensitive HD-Sensitive
Xor No Masking ✓ ✓
SecXor First Order Masking ✗ ✓
SecXor2 SpecializedHardware& Masking ✗ ✓
Figure 2: Implementations of an XOR computation in the
presenceof HWand HDpower side-channelleaks.
2.1 The HW andHD Leaks
Considertheprogram Xor()inFigure2,whichtakesthepublic txt
andthesecret keyasinputandreturnstheexclusive-orofthemas
output.Since logical 1 and 0 bits in a CMOS circuit correspon d to
diﬀerent leakage currents, they aﬀect the power consumptio n of
thedevice[49];suchleakswereconﬁrmedbypriorworks[22, 55]
andsummarizedintheHammingWeight(HW)model.Inprogram
Xor(),variable thasapowerside-channel leak becauseitsregister
valuedepends onthesecret key.
Theleak may bemitigated by masking[2, 37] as shown in pro-
gramSecXor().Theidea is tosplit a secret to nrandomizedshares
beforeusingthem;unlesstheattackerhasall nshares,itistheoret-
ically impossible to deduce the secret. In ﬁrst-order masking, the
secretkeymay be split to {mask1,mk} wheremask1is a random
variable, mk=mask1⊕keyis the bit-wise Exclusive-OR of mask1
andkey, and thus mask1⊕mk=key. We say that mkismaskedand
thusleakfreebecauseitisstatisticallyindependent ofthevalueof
thekey:ifmask1hasauniformrandomdistributionthensois mk.
Therefore, when mkis aggregated over time, as in side-channel
attacks,theresultreveals no informationof key.
Unfortunately,therecanbeleaksin SecXor()whenthevariables
sharearegisterandthuscreatesecond-ordercorrelation. Forexam-
ple,thex86assemblycodeof mk=mask1⊕keyisMOV mask1 %edx;
XOR key %edx , meaning the values stored in %edxaremask1and
mask1⊕key, respectively. Since bit-ﬂips in the register also aﬀect
the leakage current, they lead to side-channel leaks. This i s cap-
turedbytheHammingDistance(HD)powermodel[22]: HD(mask1,mask1⊕key)
=HW(mask1⊕(mask1⊕key))=HW(key),whichreveals key.Con-
sider, for example, where keyis 0001bandmask1is 1111bin bi-
nary.If aregister stores mask1(=1111b)ﬁrstandupdatesitsvalue
asmask1⊕key(=1110b), the transition of the register (bit-ﬂip) is
0001b,which is same as the keyvalue.
In embedded systems, specialized hardware [4, 47, 66] such a s
physicallyunclonablefunction(PUF)andtruerandomnumbe rgen-
erator (TRNG) may produce keyandmask1and map them to the
memory address space; thus, these variables are considered leak
free. Specialized hardware may also directly produce the ma sked
shares{mask1,mk} withoutproducingtheunmasked keyintheﬁrst
place. This more secure approach is shown in program SecXor2(),Mitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
where masked shares are used to compute the result ( txt⊕key),
which is alsomasked, butby mask2instead of mask1.
InsideSecXor2(),carehas beengiven torandomizetheinterme-
diate results by mask2ﬁrst, before de-randomize them by mask1.
Thus, the CPU’s registers never hold any unmasked result. Ho w-
ever,therecanstillbeHDleaks,forexample,whenthesamer egis-
terholdsthefollowingpairsatconsecutivetimesteps: (mask1,mk) ,
(mask1,t1) , and(mask2,t3) .
2.2 IdentifyingtheHD Leaks
Toidentifytheseleaks,weneedtodevelopascalablemethod .While
therearetechniquesfordetectingﬂawsinvariousmasking i mple-
mentations [9,10,17,18,23,30,33,34,37, 40, 62, 64, 65, 67 ],none
of them were scalable enough for use in real compilers, and no ne
of them targetedtheHDleaks causedbyregister reuse. Ourwo rk
bridges thegap.
First,wecheckiftherearesensitive, unmaskedvaluesstor edin
a CPU’s register. Here, maskmeans that a value is made statisti-
cally independent of the secret using randomization. We say that
avalueis HW-sensitive if,statistically,itstilldependsonthesecret.
Forexample,inFigure2, keyisHW-sensitivewhereas mk=mask1⊕key
has been masked. If there were nk=mask1∨key, it wouldbe called
HW-sensitive becausethemasking is not perfect.
Second, we check if there is any pair of values (/v.alt1,/v.alt2)that,
when stored in the same register, may cause an HD leak. That is ,
HD(/v.alt1,/v.alt2)=HW(/v.alt1⊕/v.alt2)may statisticallydepend onthesecret.
For example, inFigure 2, mkandmask1form aHD-sensitive pair.
Formal Veriﬁcation. In general, deciding whether a variable is
HW-sensitive, or a pair of variables is HD-sensitive, is NP- hard,
since it corresponds to model counting [35, 75]. This is illustrated
byTable1,whichshowsthetruthtableofBooleanfunctions t1,t2
andt3in terms of secret variable kand random variables m1,m2
andm3.First, there is no HW leak because, regardless of whether
k=0or1,thereisa50%chanceof t1andt2being1anda25%chance
oft3being1.Thiscanbeconﬁrmedbycountingthenumberof1’s
in thetopand bottomhalves of thetable.
When two values(t1,t2)are stored in the same register, how-
ever, the bit-ﬂip may depend on the secret. As shown in the col -
umnHD(t1,t2)of the table, when k=0, the bit is never ﬂipped;
whereas when k=1, the bit is always ﬂipped. The existence of
HD leak for(t1,t2)can be decided by model counting over the
function ft1⊕t2(k,m1,m2,m3): the number of solutions is 0/8 for
k=0but8/8for k=1.Incontrast,thereis no HDleak for (t2,t3)
becausethenumberofsatisfyingassignments(solutions)i salways
2/8 regardless ofwhether k=0 ork=1.
Type Inference. Since model counting is expensive, e.g., taking
hours or longer even for small programs, it is not suitable fo r a
compiler.Thus,wedevelopafast,sound,andstatictypeinf erence
system to identify the HD-sensitive pairs in a program. By fa st,
we mean that our method relies on syntactic information of th e
program or theplatform(e.g., mapping from variables to phy sical
registers). By sound, we mean that our method is conservativ e: it
may introduce false alarms, and thus may mitigate unnecessa rily,
butit never misses real leaks.
Speciﬁcally,weassigneachvariableoneofthreetypes: RUD,SID
orUKD(details in Section 3). Brieﬂy, RUDmeans random uniform
distribution, SIDmeans secret independent distribution, and UKDTable1: Truthtableshowing that(1)thereisnoHWleakin
t1,t2,t3but(2)thereisanHDleakwhen t1,t2sharearegister.
km1m2m3 t1= t2= t3=HD(t1,t2) HD(t2,t3)
m1⊕m2t1⊕kt2∧m3=t1⊕t2=t2⊕t3
0000 0 0 0 0 0
0001 0 0 0 0 0
0010 1 1 0 0 1
0011 1 1 1 0 0
0100 1 1 0 0 1
0101 1 1 1 0 0
0110 0 0 0 0 0
0111 0 0 0 0 0
1000 0 1 0 1 1
1001 0 1 1 1 0
1010 1 0 0 1 0
1011 1 0 0 1 0
1100 1 0 0 1 0
1101 1 0 0 1 0
1110 0 1 0 1 1
1111 0 1 1 1 0
UKDRUDRUDRUD RUD RUD SID UKD SID*
* Our Datalogbased typeinference rules can infer it as SIDinstead of UKD
meansunknowndistribution.Therefore,avariablemayhave aleak
onlyif itis the UKDtype.
InTable1,forexample,given t1←m1⊕m2,wherem1andm2
arerandom( RUD),itiseasytoseethat t1isalsorandom( RUD).For
t3←t2∧m3,wheret2,m3areRUD, however, t3 may not always
berandom,butwecanstillprovethat t3isSID;thatis,t3isstatis-
tically independent of k. This type of syntactical inference is fast
becauseit doesnot rely onany semantic information,although in
general,itisnotasaccurateasthemodelcountingbasedapp roach.
Nevertheless,suchinaccuracydoesnotaﬀectthesoundness ofour
mitigation.
Furthermore, we rely on a Datalog based declarative analysi s
framework [20,45,71,72,76]toimplementand reﬁnethetype in-
ferencerules,whichcaninfer HD(t2,t3)asSIDinsteadof UKD.We
alsoleveragedomain-speciﬁcoptimizations,suchaspreco mputing
certainDatalogfactsandusingcompiler’sbackendinforma tion,to
reducecostand improve accuracy.
2.3 MitigatingtheHD Leaks
Toremovetheleaks,weconstraintheregisterallocational gorithm
usingourinferredtypes.WefocusonLLVMandx86,butthemet hod
is applicable to MIPS and ARM as well. To conﬁrm this, we in-
spected the assembly code produced by LLVM for the example
(t1,t2,t3) in Table 1 and found HD leaks on all three architectures.
For x86, in particular, the assembly code is shown in Figure 3 a,
which uses %eaxtostoreallintermediatevariables and thus has a
leak inHD(t1,t2).
Figure 3b shows our mitigated code, where the HD-sensitive
variables t1andt2arestoredindiﬀerent registers.Here, t1resides
in %eax and memory -20(%rbp) whereas t2resides in %ecx and
memory-16(%rbp).Thestackandavalueof%eaxareshowninFi g-
ure3c, bothbeforeand after mitigation, when theleak mayoc cur
at lines 8-9. Since the value of kis used only once in the example,
i.e., for computing t2, overwriting its value stored in the original
memory location -16(%rbp) does not aﬀect subsequent execut ion.
Ifkwere to beused later,our methodwouldhave madea copy in
memoryand directuses of ktothat memorylocation.
Register allocation in real compilers is a highly optimized pro-
cess. Thus, care must be given to maintain correctness and pe r-
formance. For example, the naive approach of assigning all H D-
sensitivevariablestodiﬀerentregistersdoesnotworkbec ausetheConference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
1 // assembly for Table1
2 movl %edi, -4(%rbp)
3 movl %esi, -8(%rbp)
4 movl %edx, -12(%rbp)
5 movl %ecx, -16(%rbp)
6 movl -4(%rbp), %eax
7 xorl -8(%rbp), %eax
8 movl %eax, -20(%rbp)
9 xorl -16(%rbp), %eax
10 movl %eax, -24(%rbp)
11 andl -12(%rbp), %eax
12 movl %eax, -28(%rbp)
13
14 popq %rbp
(a)Before Mitigation1 // assembly for Table1
2 movl %edi, -4(%rbp)
3 movl %esi, -8(%rbp)
4 movl %edx, -12(%rbp)
5 movl %ecx, -16(%rbp)
6 movl -4(%rbp), %eax
7 xorl -8(%rbp), %eax
8 movl %eax, -20(%rbp)
9 xorl %eax, -16(%rbp)
10 movl -16(%rbp), %ecx
11 andl -12(%rbp), %ecx
12 movl %ecx, -28(%rbp)
13 movl -28(%rbp), %eax
14 popq %rbp
(b)AfterMitigation
stack
...
m1
m2
m3
key
m1⊕m2
...-4(%rbp)
-8(%rbp)
-12(%rbp)
-16(%rbp)
-20(%rbp)%eax
m1⊕m2
After executing line 8stack
...
key
m1⊕m2
...-16(%rbp)
-20(%rbp)%eax
m1⊕m2⊕key
Before Mitigation
(after executing line 9)
stack
...
m1⊕m2⊕key
m1⊕m2
...-16(%rbp)
-20(%rbp)%eax
m1⊕m2
After Mitigation
(after executing line 9)HD= key(leak)
HD= 0
(c) Diagramforstackandregister %eax
Figure3: Theassemblycodebefore andaftermitigation.
number of registers is small (x86 has 4 general-purpose regi sters
whileMIPShas24)whilethenumberofsensitivevariablesis often
large, meaning many variables mustbe spilledtomemory.
Theinstructionsetarchitecturealsoaddconstraints.Inx 86,for
example, %eax is related to %ah and %al and thus cannot be as-
signedindependently.Furthermore,binaryoperationssuc hasXor
may require that the result and one operand must share the sam e
registerormemorylocation.Therefore,for mk=mask1⊕key,itmeans
that either mkandmask1share a register, which causes a leak in
HD(mk, mask1)=HW(key) , ormkandkeyshare a register, which
causes a leak in HW(key) itself. Thus, while modifying the back-
end, multiplesubmodulesmust beconstrained together to en sure
thedesired register and memory isolation(see Section5).
2.4 Leaks in High-order Masking
Here,aquestioniswhethertheHDleakcanbehandledbysecon d-
order masking (which involves two variables). The answer is no,
because even with high-order masking techniques such as Bar the
etal.[8–10],thecompiledcodemaystillhaveHDleaksintro duced
by register reuse. We conﬁrmed this through experiments, wh ere
thecodecompiledbyLLVMforhigh-ordermaskedprogramsfro m
Bartheet al.[8]was found tocontainHDleaks.
Figure 4 illustrates this problem on a second-order arithme tic
masking of themultiplicationof txt(public)and key(secret) ina
ﬁniteﬁeld.Here,thesymbol ∗denotesmultiplication.Whilethere
are a lot of details, at a high level, the program relies on the same
idea ofsecret sharing : random variables are used to split the se-
cretkeytothreeshares,beforethesesharesparticipateinthecom-
putation. The result is a masked triplet (res0,res1,res2) such that
(res0⊕res1⊕res2)=key∗txt.
The x86 assembly code in Figure 4 has leaks because the same
register %edx stores both mask0⊕mask1andmask0⊕mask1⊕1uint8 SecondOrderMaskingMultiply(uint8 txt, uint8 key) {
2 intmask0, mask1, mask2, mask3, mask4, mask5, mask6; //random
3 intt1 = mask0 ^ mask1 ^ key;
4 intt2 = mask2 ^ mask3 ^ txt;
5 intt3 = (mask4 ^ mask0 * mask3) ^ mask1 * mask2;
6 intt4 = (mask5 ^ mask0 * t2) ^ t1 * mask2;
7 intt5 = (mask6 ^ mask1 * t2) ^ t1 * mask3;
8 res0 = (mask0 * mask2 ^ mask4) ^ mask5;
9 res1 = (mask1 * mask3 ^ t3) ^ mask6;
10 res2 = (t1 * t2 ^ t4) ^ t5;
11 return{res0, res1, res2};
12}
movzbl -41(%rbp), %edx // mask0 is loaded to %edx
movzbl -43(%rbp), %esi // mask1 is loaded to %esi
xorl %esi, %edx // mask0^mask1 is stored to %edx (%edx1)
movzbl -44(%rbp), %esi // key is loaded to %esi
xorl %esi, %edx // mask0^mask1^key is stored to %edx (%edx2)
movb %dl, %al
movb %al, -50(%rbp)
Figure4:Second-ordermaskingofmultiplicationinaﬁnite
ﬁeld,and theLLVM-generatedx86assemblycodeof Line3.
key. Let the two values be denoted %edx 1and %edx 2, we have
HD(%edx 1,%edx2)=HW(key) .SimilarleaksexistintheLLVM-generated
assemblycodeof this program forARMand MIPS as well,butwe
omitthem forbrevity.
3 PRELIMINARIES
We deﬁne the threat model and then review the leakage models
usedforquantifying thepower sidechannel.
3.1 The Threat Model
We assume the attacker has access to the software code, but no t
the secret data, and the attacker’s goal is to gain informati on of
thesecretdata.Theattackermaymeasurethepowerconsumpt ion
of a device that executes the software, at the granularity of each
machineinstruction.Asetofmeasurement tracesisaggrega tedto
perform statistical analysis, e.g., as in DPA attacks. In mi tigation,
our goal is to eliminate the statistical dependence between secret
dataand the(aggregated) measurement data.
LetPbetheprogramunderattackandthetriplet (x,k,r)bethe
input: sets x,kandrconsist of public,secret, andrandom (mask)
variables,respectively.Let x,k1,k2,andrbevaluationsofthesein-
putvariables.Then, σt(P,x,k1,r)denotes,attimestep t,thepower
consumptionofadevice executing Punder input x,k1andr.Sim-
ilarly,σt(P,x,k2,r)denotes the power consumptionof the device
executing Punderinput x,k2andr.Betweensteps tandt+1,one
instructionin Pis executed.
WesayPhas aleak ifthereare t,x,k1andk2suchthatthedis-
tributionof σt(P,x,k1,r)diﬀersfromthatof σt(P,x,k2,r).Letran-
dom variables in rbe uniformly distributed in the domain R, and
lettheprobabilityof each r∈RbePr(r),we expect ∀t,x,k1,k2./summationdisplay.1
r∈Rσt(P,x,k1,r)Pr(r)=/summationdisplay.1
r∈Rσt(P,x,k2,r)Pr(r)(1)
Foreﬃciency reasons,inthiswork,weidentify suﬃcientcondi-
tionsunderwhichFormula1isimplied.Towardthisend,wefocus
ontheleaks ofindividual variables,and pairs ofvariables , inPin-
steadofthesum σt:ifweremoveallindividualleaks,theleak-free
propertyover thesum σt(P,x,k,r)is implied.
3.2 The Leakage Model
In the Hamming Weight (HW) model [49, 50], the leakage associ -
ated with a register value, which corresponds to an intermed iateMitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
variable in the program, depends on the number of 1-bits. Let the
valuebeD=/summationtext.1n−1
i=0di2iwhered0istheleastsigniﬁcantbit, dn−1is
the mostsigniﬁcant bit,and each bit di,where 0≤i<n,is either
0 or1.TheHammingWeight of DisHW(D)=/summationtext.1n−1
i=0di.
In the Hamming Distance (HD) model [49, 50], the leakage de-
pendsnotonlyonthecurrentregistervalue Dbutalsoareference
valueD′. LetD′=/summationtext.1n−1
i=0d′
i2i. We deﬁne the Hamming Distance
betweenDandD′asHD(D,D′)=/summationtext.1n−1
i=0di⊕d′
i,whichisequalto
HW(D⊕D′), theHamming Weight of the bit-wise XOR of Dand
D′.Anotherinterpretationistoregard HW(D)asaspecialcaseof
HD(D,D′),where allbitsin thereference value D′areset to0.
The widely used HW/HD models have been conﬁrmed on var-
ious devices [22, 27, 43, 52, 55]. The correlation between po wer
variance andnumberof1-bitsmaybeexplainedusingthe leakage
currentof a CMOS transistor, which is the foundation of modern
computing devices. Broadly speaking, a CMOS transistor has two
kinds of leakage currents: staticanddynamic. Static leakage cur-
rent exists all the time but the volume depends on whether the
transistor is on or oﬀ, i.e., a logical 1. Dynamic leakage cur rent
occurs only when a transistor is switched (0-1 or 1-0 ﬂip). Wh ile
staticleakagecurrentiscapturedbytheHWmodel,dynamicl eak-
age current is capturedbytheHDmodel(fordetails refer toM an-
gard [49].)
3.3 The DataDependency
We consider two dependency relations: syntactical andstatistical .
Syntactical dependency is deﬁned over the program structur e: a
functionf(k,...)syntacticallydependsonthevariable k,denoted
Dsyn(f,k), ifkappears in the expression of f; that is,kis in the
supportof f,denoted k∈supp(f).
Statistical dependency is concerned with scenarios where r an-
domvariablesareinvolved.Forexample,when f(k,r)=k⊕r,the
probability of fbeing logical 1 (always 50%) is not dependent on
k. However, when f(k,r)=k∨r, whereris a random uniform
distribution in[0,1], the probability of fbeing logical 1 is 100%
whenkis 1, but 50% when kis 0. In the latter case, we say that f
is statisticallydependent on k,denotedDsta(f,k).
The relative strengths of the dependency relations are as fo l-
lows:¬Dsyn(f,k)=⇒ ¬D sta(f,k),i.e., iffis syntactically inde-
pendent of k, it is statistically independent of k. In this work, we
rely onDsynto inferDstaduring type inference, since the detec-
tionof HDleaks must bebothfast and sound.
4 TYPE-BASED STATIC LEAK DETECTION
Weuseatypesystemthatstartsfromtheinputannotation( INPUBLIC,
INSECRETandINRANDOM) and computes a distribution type for all
variables. The type indicates whether a variable may statis tically
depend onthesecret input.
4.1 The TypeHierarchy
The distributiontype of variable /v.alt, denoted TYPE(/v.alt),may be one
of thefollowingkinds:
•RUD, which stands for random uniform distribution , means
/v.altis either a random input m∈INRANDOMor perfectlyran-
domized[18]by m,e.g.,/v.alt=k⊕m.
•SID,whichstandsfor secretindependentdistribution ,means
that, while not RUD,/v.altis statistically independent of the se-
cret variablein INSECRET.•UKD, which stands for unknown distribution , indicates that
we are not abletoprove that /v.altisRUDorSIDand thushave
toassumethat /v.altmayhave a leak.
The three types form a hierarchy: UKDis the least desired be-
causeitmeansthataleakmayexist. SIDisbetter:althoughitmay
notbeRUD,wecanstillprovethatitis statisticallyindependent of
thesecret,i.e.,noleak. RUDisthemostdesiredbecausethevariable
notonlyis statisticallyindependent ofthesecret (same as inSID),
butalsocan beused likea random input,e.g., to mask other ( UKD)
variables.For leak mitigationpurposes,it is always sound totreat
anRUDvariable as SID,or anSIDvariable as UKD, althoughit may
forceinstructionstobeunnecessarily mitigated.
In practice, we want to infer as many SIDandRUDvariables as
possible. For example, if k∈INSECRET,m∈INRANDOMandkm=
k⊕m,thenTYPE(k)=UKDandTYPE(km)=RUD. Ifx∈INPUBLIC
andxkm=x∧km, thenTYPE(xkm)=SIDbecause, although
xmay have any distribution, since kmisRUD,xkmis statistically
independent ofthesecret.
Weprefer RUDoverSID,when both are applicableto a variable
x1, because if x1is XOR-ed with a UKDvariablex2, we can easily
provethat x=x1⊕x2isRUDusinglocalinference, aslongas x1is
RUDandx2isnotrandomizedbythesameinputvariable.However,
ifx1islabelednotas RUDbutasSID,localinference rulesmaynot
bepowerfulenough toprovethat xisRUDorevenSID;as aresult,
wehave totreat xasUKD(leak), which is less accurate.
4.2 Datalogbased Analysis
In the remainder of this section, we present type inference f or in-
dividualvariables ﬁrst,and thenfor HD-sensitive pairs.
WeuseDatalogtoimplementthetypeinference.Here,progra m
informationiscapturedbyasetofrelationscalledthe facts,which
include the annotation of input in INPUBLIC(SID),INSECRET(UKD)
andINRANDOM(RUD).Theinferencealgorithmiscodiﬁedinasetof
relations called the rules, which are steps for deducing types. For
example, when z=x⊕mandmisRUD,zis alsoRUDregardless of
the actual expression that deﬁnes x, as long as m/nelementsupp(x).This
canbeexpressed as aninference rule.
Aftergeneratingboththefactsandtherules,wecombinethe m
toformaDatalogprogram,andsolveitusinganoﬀ-the-shelf Dat-
alogengine. Inside theengine, therules areappliedtothef actsto
generatenew facts(types);theiterativeprocedurecontin ues until
thesetof facts reaches a ﬁxedpoint.
SinceourtypeinferenceisperformedontheLLVMIR,therear e
only a few instruction types to consider. For ease of present ation,
we assume that a variable /v.altis deﬁned by either a unary operator
ora binaryoperator( n-aryoperatormay behandled similarly).
•/v.alt←Uop(/v.alt1), whereUopis a unary operator such as the
Boolean(orbit-wise) negation.
•/v.alt←Bop(/v.alt1,/v.alt2), whereBopis a binary operator such as
Boolean (or bit-wise) ⊕,∧,∨and∗(ﬁnite-ﬁeld multiplica-
tion).
For/v.alt←Uop(/v.alt1), we have TYPE(/v.alt)=TYPE(/v.alt1), meaning /v.altand
/v.alt1have the same type. For /v.alt←Bop(/v.alt1,/v.alt2), the type depends on
(1) ifBopisXor, (2) ifTYPE(/v.alt1)andTYPE(/v.alt2)areSIDorRUD,and
(3)thesets of inputvariables uponwhich /v.alt1and/v.alt2depend.Conference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
4.3 Basic TypeInference Rules
Priortodeﬁningtherulesfor Bop,wedeﬁnetworelatedfunctions,
unqanddom,inadditionto supp(/v.alt),whichisthesetofinputvari-
ables uponwhich /v.altdepends syntactically.
D/e.sc/f.sc/i.sc/n.sc/i.sc/t.sc/i.sc/o.sc/n.sc 4.1. unq:V→INRANDOMis a function that re-
turns,for each variable /v.alt∈V,a subset of mask variablesdeﬁnedas
follows: if /v.alt∈INRANDOM,unq(/v.alt)={/v.alt};butif/v.alt∈IN\INRANDOM,
unq(/v.alt)={};
•if/v.alt←Uop(/v.alt1),unq(/v.alt)=unq(/v.alt1);and
•if/v.alt←Bop(/v.alt1,/v.alt2),unq(/v.alt)=(unq(/v.alt1)∪unq(/v.alt2))\(supp(/v.alt1)
∩supp(/v.alt2)).
Given the data-ﬂow graph of all instructions involved in com put-
ing/v.altand aninput variable m∈unq(/v.alt),theremustexist a unique
pathfrom mto/v.altinthegraph.Iftherearemorepaths(ornopath),
mwouldnothave appeared in unq(/v.alt).
D/e.sc/f.sc/i.sc/n.sc/i.sc/t.sc/i.sc/o.sc/n.sc 4.2. dom:V→INRANDOMis a function that re-
turns,for each variable /v.alt∈V,a subset of mask variablesdeﬁnedas
follows:if /v.alt∈INRANDOM,dom(/v.alt)={/v.alt},butif/v.alt∈IN\INRANDOM,
thendom(/v.alt)={};
•if/v.alt←Uop(/v.alt1),dom(/v.alt)=dom(/v.alt1);and
•if/v.alt←Bop(/v.alt1,/v.alt2),whereoperator Bop=Xor,thendom(/v.alt)=
(dom(/v.alt1)∪dom(/v.alt2))∩unq(/v.alt);elsedom(/v.alt)={}.
Given the data-ﬂow graph of all instructions involved in com put-
ing/v.altandaninputvariable m∈dom(/v.alt),theremustexistaunique
pathfrom mto/v.alt,alongwhichallbinaryoperatorsare Xor;ifthere
aremoresuchpaths(ornosuchpath), mwouldnothaveappeared
indom(/v.alt).
Following the deﬁnitions of supp,unqanddom, it is straight-
forward toarriveat thebasic inference rules [9,57, 75]:
Rule1dom(/v.alt)/nequal∅
TYPE(/v.alt)=RUD
Rule2supp(/v.alt)∩INSECRET=∅∧TYPE(/v.alt)/nequalRUD
TYPE(/v.alt)=SID
Here,Rule1saysif/v.alt=m⊕expr,wheremisarandominputand
expris not masked by m,then/v.althas random uniform distribution.
This is due tothe propertyof XOR. Rule2says if/v.altis syntactically
independent of variables in INSECRET, it has a secret independent
distribution,provided thatitis not RUD.
4.4 Inference Rules to Improve Accuracy
With the two basic rules only, any variable not assigned RUDor
SIDwillbetreatedas UKD,whichistooconservative. Forexample,
/v.alt=(k⊕m)∧xwherek∈INSECRET,m∈INRANDOMandx∈
INPUBLIC,is actually SID.This isbecause k⊕misrandom andthe
othercomponent, x,issecretindependent.Unfortunately,thetwo
basicrulescannotinferthat /v.altisSID.Thefollowingrulesareadded
tosolvethis problem.
Rule3a/v.alt←Bop(/v.alt1,/v.alt2)∧supp(/v.alt1)∩supp(/v.alt2)=∅
∧Bop/nelement{Xor,GMul}∧TYPE(/v.alt1)=RUD∧TYPE(/v.alt2)=SID
TYPE(/v.alt)=SID
Rule3b/v.alt←Bop(/v.alt1,/v.alt2)∧supp(/v.alt1)∩supp(/v.alt2)=∅
∧Bop/nelement{Xor,GMul}∧TYPE(/v.alt1)=SID∧TYPE(/v.alt2)=RUD
TYPE(/v.alt)=SIDTheserulesmeanthat,forany Bop={∧,∨},ifoneoperandis RUD,
the other operand is SID, and they share no input, then /v.althas a
secretindependentdistribution( SID).GMuldenotesmultiplication
in a ﬁnite ﬁeld. Here, supp(/v.alt1)∩supp(/v.alt2)=∅is need; otherwise,
thecommoninputmaycauseproblem.Forexample,if /v.alt1←m⊕k
and/v.alt2←m∧x, then/v.alt=(/v.alt1∧/v.alt2)=(m∧¬k)∧xhas a leak
becauseif k=1,/v.alt=0;butifk=0,/v.alt=m∧x.
Rule4/v.alt←Bop(/v.alt1,/v.alt2)∧supp(/v.alt1)∩supp(/v.alt2)=∅
∧TYPE(/v.alt1)=SID∧TYPE(/v.alt2)=SID
TYPE(/v.alt)=SID
Similarly, Rule4may elevate a variable /v.altfromUKDtoSID, e.g., as
in/v.alt←((k⊕m)∧x1)∧(x2)wherex1andx2arebothSID.Again,
thecondition supp(/v.alt1)∩supp(/v.alt2)=∅inRule4is neededbecause,
otherwise,theremaybecasessuchas /v.alt←((k⊕m)∧x1)∧(x2∧m),
whichisequivalentto /v.alt←¬k∧(m∧x1∧x2)andthushasaleak.
Figure 5 shows the other inference rules used in our system.
Since theserules areself-explanatory, weomittheproofs.
4.5 DetectingHD-sensitive Pairs
Based on the variable types, we compute HD-sensitive pairs. For
eachpair(/v.alt1,/v.alt2),wecheckif HD(/v.alt1,/v.alt2)resultsinaleakwhen /v.alt1
and/v.alt2share aregister. There aretwoscenarios:
•/v.alt1←expr1;/v.alt2←expr2, meaning /v.alt1and/v.alt2are deﬁned in
twoinstructions.
•/v.alt1←Bop(/v.alt2,/v.alt3), where the result /v.alt1and one operand /v.alt2
arestoredin thesameregister.
Inthetwo-instruction case,wecheck HW(expr1⊕expr2)usingXor-
related inference rules. For example, if /v.alt1←k⊕mand/v.alt2←m,
sincemappears in the supports of both expressions, (k⊕m)⊕m
isUKD.Suchleakwillbedenoted SEN_HDD(/v.alt1,/v.alt2),whereDstands
for“Double”.
In thesingle-instruction case, we check HW(Bop(/v.alt2,/v.alt3)⊕/v.alt2)
basedontheoperatortype.When Bop=∧,wehave(/v.alt2∧/v.alt3)⊕/v.alt2=
/v.alt2∧¬/v.alt3;whenBop=∨,wehave(/v.alt2∨/v.alt3)⊕/v.alt2=(¬/v.alt2∧/v.alt3);when
Bop=⊕(Xor), we have(/v.alt2⊕/v.alt3)⊕/v.alt2=/v.alt3; and when Bop=∗
(GMul), the result of(/v.alt2∗/v.alt3)⊕/v.alt2is{/v.alt2,/v.alt3}if/v.alt2∗/v.alt3/nequal0x01
andis(/v.alt2⊕0x01)otherwise.Sincethetypeinference procedureis
agnostictotheresultof (/v.alt2∗/v.alt3),thetypeof(/v.alt2∗/v.alt3)⊕/v.alt2depends
on the types of /v.alt3and/v.alt2; that is,TYPE(/v.alt2)=UKD∨TYPE(/v.alt3)=
UKD=⇒TYPE((/v.alt2∗/v.alt3)⊕/v.alt2)=UKD. If there is a leak, it will be
denotedSEN_HDS(/v.alt1,/v.alt2).
ThereasonwhyHDleaksaredividedto SEN_HDDandSEN_HDS
isbecausethey havetobemitigateddiﬀerently. Whenthelea kin-
volves two instructions, it may be mitigated by constrainin g the
register allocation algorithm such that /v.alt1and/v.alt2no longer can
share a register. In contrast, when the leak involves a singl e in-
struction, it cannot be mitigated in this manner because in x 86,
for example, all binary instructions requirethe result to s hare the
sameregister ormemorylocationwithoneoftheoperands.Th us,
mitigating the SEN_HDSrequires that we rewrite the instruction
itself.
We also deﬁne a relation Share(/v.alt1,/v.alt2), meaning /v.alt1and/v.alt2in-
deedmaysharearegister,anduseittoﬁltertheHD-sensitiv epairs,
as showninthetwo rulesbelow.
Share(/v.alt1,/v.alt2)∧TYPE(/v.alt1⊕/v.alt2)=UKD∧/v.alt1←expr1∧/v.alt2←expr2
SEN_HDD(/v.alt1,/v.alt2)
Share(/v.alt1,/v.alt2)∧TYPE(/v.alt1⊕/v.alt2)=UKD∧/v.alt1←Bop(/v.alt2,/v.alt3)
SEN_HDS(/v.alt1,/v.alt2)Mitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
Rule5a/v.alt←Bop(/v.alt1,/v.alt2)∧
dom(/v.alt1)\supp(/v.alt2)=∅∧TYPE(/v.alt1)=RUD∧
dom(/v.alt1)=dom(/v.alt2)∧supp(/v.alt1)=supp(/v.alt2)
TYPE(/v.alt)=SIDRule5b/v.alt←Bop(/v.alt1,/v.alt2)∧
dom(/v.alt2)\supp(/v.alt1)=∅∧TYPE(/v.alt2)=RUD∧
dom(/v.alt1)=dom(/v.alt2)∧supp(/v.alt1)=supp(/v.alt2)
TYPE(/v.alt)=SID
Rule6/v.alt←Bop(/v.alt1,/v.alt2)∧Bop/nelement{Xor,GMul}∧(dom(/v.alt1)\supp(/v.alt2)/nequal∅∨dom(/v.alt2)\supp(/v.alt1)/nequal∅)∧TYPE(/v.alt1)=RUD∧TYPE(/v.alt2)=RUD
TYPE(/v.alt)=SID
Rule7a/v.alt←Bop(/v.alt1,/v.alt2)∧Bop=GMul∧TYPE(/v.alt1)=RUD∧
TYPE(/v.alt2)=SID∧dom(/v.alt1)\supp(/v.alt2)/nequal∅
TYPE(/v.alt)=SIDRule7b/v.alt←Bop(/v.alt1,/v.alt2)∧Bop=GMul∧TYPE(/v.alt1)=SID∧
TYPE(/v.alt2)=RUD∧dom(/v.alt2)\supp(/v.alt1)/nequal∅
TYPE(/v.alt)=SID
Rule8/v.alt←Bop(/v.alt1,/v.alt2)∧Bop=GMul∧(dom(/v.alt1)\dom(/v.alt2)/nequal∅∨dom(/v.alt2)\dom(/v.alt1)/nequal∅)∧TYPE(/v.alt1)=RUD∧TYPE(/v.alt2)=RUD
TYPE(/v.alt)=SID
Figure5: Theremaining inferencerulesusedin ourtypesyst em(inaddition to Rule1−4).
Backend information(Section6.1)isrequiredtodeﬁnether ela-
tion; fornow,assume ∀/v.alt1,/v.alt2:Share(/v.alt1,/v.alt2)=true.
5 MITIGATION DURINGCODE GENERATION
We mitigate leaks by usingthe twotypes of HD-sensitive pair s as
constraints duringregister allocation.
Register Allocation. The classic approach, especially for static
compilation,is based on graphcoloring [24,36],whereas dynamic
compilation may use faster algorithms such as lossy graph color-
ing[28]orlinearscan [61].Weapplymitigationonbothgraphcol-
oringand LLVM’s basicregister allocationalgorithms.For ease of
comprehension,weusegraphcoloringtoillustrateourcons traints.
Ingraphcoloring,eachvariablecorrespondstoanodeandea ch
edgecorrespondstoan interference betweentwovariables,i.e.,they
may be in use at the same time and thus cannot occupy the same
register.Assigningvariablesto kregistersissimilartocoloringthe
graph with kcolors. To be eﬃcient, variables may be grouped to
clusters, or virtual registers , before they are assigned to physical
registers (colors). In this case, each virtual register ( vreg), as op-
posed to each variable, corresponds to a node in the graph, an d
multiplevirtualregisters may bemappedtoonephysical reg ister.
5.1 Handling SEN_HD DPairs
For each SEN_HDD(/v.alt1,/v.alt2), where/v.alt1and/v.alt2are deﬁned in two in-
structions, we add the following constraints. First, /v.alt1and/v.alt2are
not to bemapped to the same virtual register. Second, virtua l reg-
istersvreg1andvreg2(for/v.alt1and/v.alt2) are not to be mapped to the
samephysicalregister.Towardthisend,weconstrainthebe havior
of twobackend modules: RegisterCoalescer andRegisterAllocator .
Ourconstrainton RegisterCoalescer statesthat /v.altre/afii10069.ital1and/v.altre/afii10069.ital2,
whichcorrespondto /v.alt1and/v.alt2,mustnevercoalesce,althougheach
ofthemmaystillcoalescewithothervirtualregisters.Asf orRegis-
terAllocator ,ourconstraintisontheformulationofthegraph.For
each HD-sensitive pair,weaddanew interference edgetoindicate
that/v.altre/afii10069.ital1and/v.altre/afii10069.ital2mustbeassigned diﬀerent colors.
Duringgraphcoloring,thesenewedgesaretreatedthesamea s
allotheredges.Therefore,ourconstraintsareaddedtothe register
allocator and its impact is propagated automatically to all subse-
quentmodules,regardless ofthearchitecture(x86,MIPSor ARM).
When variables cannot ﬁt in the registers, some will be spilledto
memory,andallreferencetothemwillbedirectedtomemory. Due
to the constraints we added, there may be more spilled variab les,
butspilling is handled transparently bytheexisting algor ithms in
LLVM.Thisisanadvantageofourapproach:itidentiﬁesaway toconstrain the behavior of existing modules in LLVM, without the
needtorewriting any ofthem from scratch.
5.2 Handling SEN_HDSPairs
ForeachSEN_HDS(/v.alt1,/v.alt2)pair,where /v.alt1and/v.alt2appearinthesame
instruction, we additionally constrain the DAG Combiner module
to rewrite the instruction before constraining the registe r alloca-
tionmodules.Toseewhy,consider mk=(m⊕k),which compiles
to
MOVL -4(%rbp), %ecx //-4(%rbp)= m (random)
XORL -8(%rbp), %ecx //-8(%rbp)= k (secret)
Here,-4(%rbp)and -8(%rbp)arememorylocationsfor mandk,re-
spectively. Although mandmkareRUD(no leak) when stored in
%ecx,thetransitionfrom mtomk,HW(m⊕mk)=k,has a leak.
Toremove theleak, wemustrewrite theinstruction:
MOVL -4(%rbp), %ecx //-4(%rbp)= m
XORL %ecx, -8(%rbp) //-8(%rbp)= k, and then mk
Whilemstillresides in%ecx,both kandmkresideinthememory
-8(%rbp). There is no leak because %ecx only stores m(RUD) and
HW(m⊕m)=0. Furthermore, the solution is eﬃcient in that no
additional memory is needed. If kwere to be used subsequently,
wewouldcopy ktoanothermemorylocationandre-directeduses
ofktothatlocation.
Example. Figure6showsarealprogram[74],where sisanarray
storing sensitive data while m1-m8 are random masks. The com-
piled code (left) has leaks, whereas the mitigated code (rig ht) is
leak free. The reason why the original code (left) has leaks i s be-
cause, prior to Line 8, %eax stores m1⊕m5, whereas after Line 8,
%eaxstores s[0+i∗4]⊕m1⊕m5;thus,bit-ﬂipsin%eaxisreﬂected
inHW(%eax1⊕%eax2)=s[0+i∗4],which is thesensitive data.
During register allocation, a virtual register vreg1would corre-
spondtom1⊕m5whilevreg2wouldcorrespondto s[0+i∗4]⊕m1⊕
m5.Duetoaconstraintfromthis SEN_HDSpair,ourmethodwould
preventvreg1andvreg2fromcoalescing,orsharingaphysicalreg-
ister. After rewriting, vreg2shares the same memory location as
s[0+i∗4]whilevreg1remainsunchanged.Thus, m1⊕m5isstored
in%aland s[0+i∗4]⊕m1⊕m5isspilledtomemory,whichremoves
theleak.
6 DOMAIN-SPECIFIC OPTIMIZATIONS
While themethod presented so far has all thefunctionality, it can
bemadefaster bydomain-speciﬁc optimizations.Conference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
1voidremask(uint8_t s[16], uint8_t m1, uint8_t m2, uint8_t m3, u int8_t m4,
uint8_t m5, uint8_t m6, uint8_t m7, uint8_t m8){
2 inti;
3 for(i = 0; i< 4; i++){
4 s[0+i*4] = s[0+i*4] ^ (m1^m5);
5 s[1+i*4] = s[1+i*4] ^ (m2^m6);
6 s[2+i*4] = s[2+i*4] ^ (m3^m7);
7 s[3+i*4] = s[3+i*4] ^ (m4^m8);
8 }
9}
1 //Before Mitigation
2 movslq -28(%rbp), %rdx
3 movq -16(%rbp), %rcx
4 movzbl (%rcx,%rdx,4), %edi
5 movzbl -17(%rbp), %esi
6 movzbl -21(%rbp), %eax
7 xorl %esi, %eax
8 xorl %edi, %eax
9 movb %al, (%rcx,%rdx,4)1 //After mitigation
2 movslq -28(%rbp), %rdx
3 movq -16(%rbp), %rcx
4
5 movzbl -17(%rbp), %esi
6 movzbl -21(%rbp), %eax
7 xorl %esi, %eax
8
9 xorb %al, (%rcx,%rdx,4)
Figure6: Codesnippetfrom theByteMaskedAES[74].
6.1 Leveraging theBackend Information
To detect HD leaks that likely occur, we focus on pairs of vari -
ables that may share a register as opposed to arbitrary pairs of
variables. For example, if the live ranges of two variables o verlap,
theywillnever sharearegister,andweshouldnotcheckthem for
HD leaks. Such information is readily available in the compi ler’s
backend modules,e.g., in graph coloringbased register all ocation,
variables associatedwithany interference edgecannotshareareg-
ister.
Thus, we deﬁne Share(/v.alt1,/v.alt2), meaning /v.alt1and/v.alt2may share a
register. After inferring the variable types as RUD,SID, orUKD, we
useShare(/v.alt1,/v.alt2)to ﬁlter the variable pairs subjected to checking
forSEN_HDDandSEN_HDSleaks (seeSection4.5).Wewillshow in
experiments that such backend information allows us to dram ati-
callyshrink thenumberof HD-sensitive pairs.
6.2 Pre-computing DatalogFacts
Bydefault,onlyinputannotationandbasicdata-ﬂow(def-u se)are
encoded as Datalog facts, whereas the rest has to be deduced b y
inference rules. However, Datalogis not themost eﬃcient wa y of
computingsets,suchas supp(/v.alt),unq(/v.alt)anddom(/v.alt),orperforming
set operationssuch as m1∈supp(/v.alt).
Incontrast,itislineartime[57]tocomputesetssuchas supp(/v.alt),
unq(/v.alt)anddom(/v.alt)explicitly.Thus,wechoosetoprecomputethem
inadvanceandencodetheresultsasDatalogfacts.Inthisca se,pre-
computationresults are used to jump start Datalog based typ e in-
ference.Wewillshow,throughexperiments,thattheoptimi zation
can leadtofaster typeinference thanthedefaultimplement ation.
6.3 Eﬃcient Encoding ofDatalogRelations
There are diﬀerent encoding schemes for Datalog. For exampl e, if
IN={i0,...,i3}andsupp(v1)={i1,i2}andsupp(v2)={i0,i1,i3}.
One way is to encode the sets is using a relation Supp:V×IN,
whereVare variables and INareinputs:
Supp(v1,i1)∧Supp(v1,i2)=supp(v1)
Supp(v2,i0)∧Supp(v2,i1)∧Supp(v2,i3)=supp(v2)
While the size of Suppis|V||IN|, each set needs up to |IN|predi-
cates, and set operationneeds |IN|2predicates.Table 2: Statisticsof the benchmarkprograms.
NameDescription LoCProgram Variables
INPUBLIC INSECRET INRANDOM Internal
P1AES Shift Rows [14] 110 2 2 22
P2Messerges Boolean[14] 120 2 2 23
P3GoubinBoolean[14] 120 1 2 32
P4SecMultOpt_wires_1 [65] 251 1 3 44
P5SecMult_wires_1 [65] 251 1 3 35
P6SecMultLinear_wires_1 [65] 321 1 3 59
P7CPRR13-lut_wires_1 [30] 811 1 7 169
P8CPRR13-OptLUT_wires_1 [30] 841 1 7 286
P9CPRR13-1_wires_1 [30] 104 1 1 7 207
P10KS_transitions_1 [8] 964 1 16 32 2,329
P11KS_wires [8] 1,130 1 16 32 2,316
P12keccakf_1turn[8] 1,256 0 25 75 2,314
P13keccakf_2turn[8] 2,506 0 25 125 4,529
P14keccakf_3turn[8] 3,764 0 25 175 6,744
P15keccakf_7turn[8] 8,810 0 25 349 15,636
P16keccakf_11turn[8] 13,810 0 25 575 24,472
P17keccakf_15turn[8] 18,858 0 25 775 33,336
P18keccakf_19turn[8] 23,912 0 25 975 42,196
P19keccakf_24turn[8] 30,228 0 25 1,225 53,279
P20AES_wires_1 [30] 34,358 16 16 1,232 63,263
Anotherwayistoencodethesetsisusingarelation Supp:V×
2IN,where 2INis thepower-set (set of allsubsetsof IN):
Supp(/v.alt1,b0110)=supp(v1)
Supp(/v.alt2,b1011)=supp(v2)
While the size of Suppis|V|2|IN|, each set needs one predicate,
and set operationneeds 2predicates (a bit-wise operation) .When
|IN|is small, the second approach is more compact; but as |IN|
increases, thetablesizeof Suppincreases exponentially.
Therefore,weproposeanencoding,calledsegmentedbitset rep-
resentation (idx,bitset) ,whereidx=irefers tothe i-th segment and
bitsetidenotes thebits inthe i-th segment.
Supp(v1,1,b01)∧Supp(v1,0,b10)=supp(v1)
Supp(v2,1,b10)∧Supp(v2,0,b11)=supp(v2)
In practice, when the bitsetsize is bounded, e.g., to 4, the table
size remains small while the number of predicates increases mod-
erately. This encoding scheme is actually a generalization of the
previous two. When the size of bitsetdecreases to 1 and the num-
ber of segments increases to |IN|, it degenerates to the ﬁrst ap-
proach. When the size of bitsetincreases to|IN|and the number
ofsegments decrease to1,itdegenerates tothesecond appro ach.
7 EXPERIMENTS
We have implemented our method in LLVM 3.6 [46]. It leverages
theµZ[39]Datalogengine inZ3[31]toinfertypes,and thencon-
strains backend modules using the inferred HD leaks. While t he
mitigation part is implemented speciﬁcally for x86 in LLVM, this
approachcanalso beimplemented forotherplatforms.
We conducted experiments on a number of cryptographic soft-
warebenchmarks.Table2showsthestatistics,includingth ename,
ashortdescription,thenumberoflinesofcode(LoC),andth enum-
berofprogramvariables,whicharedividedfurthertoinput andin-
ternalvariables.Allbenchmarksarefrompublicdomain,an dallof
themaremasked.TheprogramsP1-P3,inparticular,areprot ected
by Booleanmasking that previously has been veriﬁed [14, 35, 75].
Theother programs,from Bartheetal.[8],are masked multip lica-
tion[65],maskedS-box[30],maskedAES[30]andvariousmas ked
MAC-Keccakfunctions [8].
Our experiments were designed to answer three questions: (1 )
Is ourDatalog-based typesystem eﬀective indetecting HDle aks?
(2)Arethedomain-speciﬁcoptimizationseﬀectiveinreduc ingthe
computational overhead? (3) Does the mitigated code have go odMitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
Table 3: Resultsof type-basedHD leakdetection.
Name DetectionTimeHDLeaks Detected Details of theInferred Types
SEN_HDDSEN_HDSRUDSID UKD
P1 0.061s NONE NONE 22 0 4
P2 0.105s NONE NONE 20 0 7
P3 0.099s NONE 2 31 3 1
P4 0.208s NONE 2 3112 6
P5 0.216s NONE 2 2910 1
P6 0.276s 4 2 4815 1
P7 0.213s 10 2 151 25 2
P8 0.147s 12 2 249 42 4
P9 0.266s 6 2 153 61 2
P10 0.550s NONE NONE 2,334 12 31
P11 0.447s 4 16 2,334 0 31
P12 0.619s NONE 7 2,062 300 52
P13 1.102s NONE 5 4,030 600 49
P14 1.998s NONE 5 5,995 900 49
P15 16.999s NONE 25 13,861 2,100 49
P16 24.801s NONE 5 21,723 3,300 49
P17 59.120s NONE 5 29,587 4,500 49
P18 2m1.540s NONE 4 37,449 5,700 47
P19 3m22.415s NONE 5 47,280 7,200 49
P20 16m12.320s 29 33 38,07026,330 127
performance after compilation,in terms of boththe codesiz e and
theexecutionspeed?
In all the experiments, we used a computer with 2.9 GHz CPU
and 8GB RAM,and set thetimeout(T/O) to120minutes.
7.1 Leak Detection Results
Table3showstheresults,whereColumns1-2showthebenchma rk
nameanddetectiontimeandColumns3-4showthenumberofHD
leaks detected. The leaks are further divided into SEN_HDD(two-
instruction) and SEN_HDS(single-instruction). Columns 5-7 show
more details of the type inference, including the number of RUD,
SIDandUKDvariables, respectively. While the time taken to com-
plete type inference is not negligible, e.g., minutes for th e larger
programs,itisreasonablebecauseweperformamuchdeeperp ro-
gram analysis than mere compilation. To put it into perspect ive,
theheavy-weightformalveriﬁcationapproachesoftentake hours[35,
75].
As for the number of leaks detected, although the benchmark
programsareallmasked,duringnormalcompilation,newHDl eaks
were still introduced as a result of register reuse. For exam ple, in
P20, which is a masked AES [8],we detected 33 SEN_HDSleaks af-
ter analyzing more than 60K intermediate variables. Overal l, we
detectedHDleaks in17outofthe20programs.Furthermore,6 of
these 17 programs have both SEN_HDDandSEN_HDSleaks, while
theremaining 11have only SEN_HDSleaks.
Results in columns 5-7 of Table 3 indicate the inferred types
of Program Variables. Despite the large number of variables in a
program,ourtypeinferencemethoddidanexcellentjobinqu ickly
proving that the vast majority of them are RUDorSID(no leak);
even for the few UKDvariables, after the backend information is
used, the number of actual HD leaks detected by our method is
small.
7.2 Eﬀectiveness of Optimizations
Toquantifytheimpactofouroptimizations,wemeasuredthe per-
formanceofourmethodwithandwithoutthem.Table4showsth e
signiﬁcantdiﬀerences inanalysistime(Columns2-3)andde tected
HDleaks(Columns4-7).Overall,theoptimizedversioncomp leted
allbenchmarkswhereastheunoptimizedonlycompletedhalf .For
P12, in particular, the optimized version (Section 6) was 11 ,631X
faster. In unoptimized version, since the memory requireme nt in-
creases as the | IN| goes up, P12 ran out of memory and started
using virtualmemory,which resultedin theslow-down.Table 4: Resultsof quantifyingimpactof optimizations.
NameDetectionTime WithoutBackend-Info WithBackend-Info
w/ooptimization w/ optimization SEN_HDDSEN_HDSSEN_HDDSEN_HDS
P1 0.865s 0.061s 0 18 0 0
P2 0.782s 0.105s 0 9 0 0
P3 0.721s 0.099s 0 15 0 2
P4 1.102s 0.208s 0 32 0 2
P5 1.206s 0.216s 0 32 0 2
P6 1.113s 0.276s 8 40 4 2
P7 5.832s 0.213s 44 144 10 2
P8 4.306s 0.147s 68 323 12 2
P9 5.053s 0.266s 43 160 6 2
P10 10m1.513s 0.550s 12 180 0 0
P11 15m51.969s 0.447s 12 180 4 16
P12 T/O 0.619s 473 1,820 0 7
P13 T/O 1.102s 492 1,884 0 5
P14 T/O 1.998s 492 1,884 0 5
P15 T/O 16.999s 492 1,884 0 25
P16 T/O 24.801s 492 1,884 0 5
P17 T/O 59.120s 492 1,884 0 5
P18 T/O 2m1s 468 1,800 0 4
P19 T/O 3m22s 492 1,884 0 5
P20 T/O 16m13s 620 1,944 29 33
Table 5: Results of ourHD leakmitigation.
NameCode-sizeOverhead (byte) RuntimeOverhead (us) VirtualRegister
original mitigated %original mitigated %sensitive non-sensitive
P3 858 8550.3 - -- 2 4
P4 1,198 1,174 2 0.23 0.20-13 2 13
P5 1,132 1,1082.12 0.30 0.372.3 2 9
P6 1,346 1,3390.52 0.30 0.27-10 5 8
P7 3,277 3,2231.64 0.29 0.303.4 10 27
P8 3,295 3,2670.85 0.20 0.2210 11 83
P9 3,725 3,6990.69 0.7 0.7811 10 29
P11 44,829 44,735 0.21 5.60 6.007.1 18 680
P12 46,805 46,787 0.03 6.20 6.504.83 7 726
P13 90,417 90,288 0.14 13.60 13.00-4.41 5 1,384
P14 134,060 133,931 0.09 23.00 21.00-8.69 5 2,040
P15 313,454 312,930 0.16 52.00 58.0011.5 25 4,637
P16 496,087 495,943 0.03 91.00 96.005.49 5 7,288
P17 677,594 677,450 0.02 129.00 136.00 5.42 5 9,912
P18 859,150 859,070 0.009 178.00 183.00 2.80 4 12,537
P19 1,086,041 1,085,897 0.047237.000 250.000 5.48 5 15,816
P20 957,372 957,319 0.005228.600 248.300 8.75 56 9,035
Leveragingthebackendinformationalsodrasticallyreduc edthe
number of detected leaks. This is because, otherwise, we hav e to
beconservativeandassumeanytwovariablesmaysharearegi ster,
whichcauses alotoffalseleaks inX86platform.InP12,fore xam-
ple,using thebackend informationresultedin 260Xfewer le aks.
7.3 Leak MitigationResults
Wecomparedthesizeand executionspeedoftheLLVM compiled
code, with and without our mitigation. The results are shown in
Table 5, including the number of bytes in the assembly code an d
the execution time. Columns 8-9 show more details: the numbe r
of virtual registers marked as sensitive and non-sensitive , respec-
tively.
Theresultsshowthatourmitigationhaslittleperformance over-
head. First, the code sizes are almost the same. For P8, the mi ti-
gated code is even smaller because, while switching the stor age
fromregistertomemoryduringourhandlingofthe SEN_HDSpairs,
subsequentmemorystoresmaybeavoided.Second,theexecut ion
speedsarealsosimilar.Overall,themitigatedcodeis8%-1 1%slower,
but in some cases, e.g., P4 and P6, the mitigated code is faste r be-
causeofourmemoryrelated rewriting.
Themainreasonwhyourmitigationhaslittleperformanceov er-
headisbecause,asshowninthelasttwocolumnsofTable5,co m-
pared to the total number of virtual registers, the number of sen-
sitive ones is extremely small. P17 (keccakf_15turn), for e xample,
hasonly5sensitivevirtualregisters outofthe9,917intot al.Thus,
ourmitigationonlyhastomodifyasmallpercentageofthein struc-
tions,which doesnot leadtosigniﬁcant overhead.Conference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
Table 6: Comparison with order- dmaskingtechniques[8].
Name Codesize (byte) Runtime(us) HW-leak HD-leak SEN_HDDSEN_HDS
P4 (ours) 1,171 0.20 No No NONE NONE
P4 (d=2) 2,207 0.75 No Yes NONE 2
P4 (d=3) 4,009 0.28 No Yes NONE 2
P4 (d=4) 5,578 0.75 No Yes NONE 2
P4 (d=5) 7,950 1.00 No Yes NONE 2
P5 (ours) 1,108 0.37 No No NONE NONE
P5 (d=2) 2,074 0.70 No Yes NONE 2
P5 (d=3) 3,733 0.60 No Yes NONE 2
P5 (d=4) 5,120 0.75 No Yes NONE 2
P5 (d=5) 7,197 0.67 No Yes NONE 2
P6 (ours) 1,339 0.27 No No NONE NONE
P6 (d=2) 3,404 0.83 No Yes NONE 2
P6 (d=3) 6,089 0.57 No Yes NONE 2
P6 (d=4) 9,640 0.80 No Yes NONE 2
P6 (d=5) 14,092 1.60 No Yes NONE 2
P7 (ours) 3,223 0.30 No No NONE NONE
P7 (d=2) 8,456 1.41 No Yes NONE 2
P7 (d=3) 15,881 3.20 No Yes NONE 2
P7 (d=4) 25,521 4.20 No Yes NONE 2
P7 (d=5) 37,578 7.80 No Yes NONE 2
P8 (ours) 3,267 0.25 No No NONE NONE
P8 (d=2) 8,782 1.30 No Yes NONE 2
P8 (d=3) 16,420 2.00 No Yes NONE 2
P8 (d=4) 26,431 4.00 No Yes NONE 2
P8 (d=5) 38,996 8.00 No Yes NONE 2
P9 (ours) 3,699 0.45 No No NONE NONE
P9 (d=2) 9,258 1.15 No Yes NONE 2
P9 (d=3) 17,565 3.00 No Yes NONE 2
P9 (d=4) 28,189 5.11 No Yes NONE 2
P9 (d=5) 41,383 8.40 No Yes NONE 2
7.4 Comparison toHigh-Order Masking
On the surface, HD leaks seem to bea typeof second-order leak s,
which involves two values. For people familiar with high-or der
masking[8],anaturalquestioniswhethertheHDleakscanbe mit-
igated using high-order masking techniques. To answer the q ues-
tion,weconductedtwoexperiments.First,wecheckedifHDl eaks
exist in programs equippedwith high-order masking. Second , we
compared the size and execution speed of the code protected b y
either high-order masking orourmitigation.
Table 6 shows the results on benchmarks P4-P9, which come
from Bartheet al.[8]and thushave versions protectedby d-order
masking, where d=2to5.Whileinitiallywealso expectedtosee
no HD leaks in these versions, the results surprised us. As sh own
in thelast two columns, HDleaks were detected in all these hi gh-
ordermaskingprotectedprograms.Acloserlookshowsthatt hese
leaks are all of the SEN_HDStype,meaning they are duetorestric-
tionofthex86ISA:anybinaryoperationhastostoretheresu ltand
oneoftheoperandsinthesameplace,andbydefault,thatpla ceis
a general-purposeregister.
Measured by the compiled code size and speed, our method
(which is already more secure than high-order masking) is mo re
eﬃcient. In P9, for example, our mitigated code has 3K bytes i n
sizeandrunsin0.45us,whereasthehigh-ordermaskingprot ected
code has 9K to 41K bytes (for d=2 to 5) and runs in 1.15us to
8.40us.
7.5 Threat to Validity
We rely on the HW/HD models [49, 50] and thus our results are
valid only when these models are valid. Although they have be en
widelyadoptedandvalidated[22,27,43,52,55],furtherva lidation
is always needed, but it is out of the scope of this work. We as-
sume the attacker can only measure the power consumption but
notother informationsuch asdata-busortiming. If suchinf orma-
tionbecomesavailable, ourmitigationmay no longer besecu re.
Sincewefocusoncryptographicsoftware,whichtendstohav e
simple program structure and language constructs, there ha s not
beenaneedtousemoresophisticatedpoints-toanalysistha nwhatis providedbyLLVM.Our analysis is intra-procedural:for c rypto-
graphicbenchmarks,wecanactuallyinlineallfunctionsto forma
monolithic program before conducting the analysis. Nevert heless,
going forward,theseare someoftheissues thatwill beaddre ssed
tobroadenthescopeofourtool.
8 RELATED WORK
Broadlyspeaking,existingmethodsfordetectingpowersid echan-
nels fall into three categories: static analysis, formal ve riﬁcation,
and hybrid approach. Static analysis relies on compile-tim e infor-
mationtocheckifmaskingschemes areimplementedcorrectl y[8,
9, 14, 16, 57]. They are faster than formal veriﬁcation, whic h of-
ten relies on SAT/SMT solvers or model counting [35]. Howeve r,
formal veriﬁcation is more accurate than static analysis. T he hy-
bridapproach[75]aimstocombinethetwotypesoftechnique sto
obtain the best of both worlds. However, none of these method s
focused on the leaks caused by register reuse inside a compil er,
which is ourmaincontribution.
Speciﬁcally,althoughourtypebasedmethodfordetectings ide-
channel leaks is inspired by several prior works [8, 16, 57, 7 5], it
is signiﬁcantly diﬀerent from theirs. Forexample, themost recent
method, proposedby Zhang et al. [75], interleaves type infe rence
with a model-counting procedure, with the goal of detecting HW
leakscausedbyerrorsinmaskingimplementations;however ,they
donot detectHDleaks caused byregister reuse nor remove the se
leaks. Their method does not use Datalog or any of the domain-
speciﬁcoptimizationswehave proposed.
Barthe et al. [8] proposed a relational technique to check th e
correctness of masked implementations. Although the techn ique
covers high-order masking, when applied to a pair of variabl es, it
hastoconsiderallpossiblewaysinwhichsecond-orderleak smay
occur, as opposed to the speciﬁc type of leak involved in regi ster
reuse. Thus, their mitigation would have been too expensive , in
terms of the code size and the execution speed. Furthermore, as
wehave shownin experiments, it doesnot seem to beeﬀective i n
preventing leaks causedbyregister reuse.
Anotherdiﬀerencebetweenourmethodandexistingmethodsi s
ourfocusonanalyzingtheword-levelrepresentationofapr ogram,
as opposedto a bit-level representation. While turning a pr ogram
intoapurelyBoolean,circuit-like,representation isfea sible[3,15,
35,75],itdoesnotﬁtintothestandardﬂow ofcompilers.Ass uch,
implementing theapproach incompilersis notstraightforw ard.
The practical security against side-channel leakages via m ask-
ing can be evaluated using the ISW model [42] and subsequent
extensions [6,29]withtransitions.However, theydonotco nsider
leaks that arespeciﬁcto register useinmoderncompilers su chas
GCCandLLVM.Theydonotconsiderconstraintsimposedbythe
instructionset architectureeither.Furthermore, they ne ed todou-
ble the masking order [6] to deal with leaks with transitions , but
stilldonoteliminate leaks introducedbycompilation.
Itisknownthatthesecurityguaranteeofsoftwarecounterm ea-
sures may become invalid after compilation [11, 38, 51, 58]. In
this context, Barthe et al. [11] showed that the compilation pro-
cess could maintain the constant-time property for timing s ide-
channel leaks, while our work addresses potential leaks thr ough
powersidechannels. Marc [38]also investigated potential vulner-
abilities in power side-channel countermeasures during co mpiler
optimizations,butdidnotprovideasystematicmethodform itigat-
ingthem.Mitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
Beyondpowersidechannels,therearetechniquesforanalyz ing
othertypesofsidechannels usinglogicalreasoning [5,26, 68],ab-
stractinterpretation[12,32],symbolicexecution[7,21, 48,59,60]
anddynamic analysis [70].Asformitigation,therearetech niques
thatinsertmaskingandothercountermeasureseitherthrou ghcom-
pilers [1, 13, 56, 73] or through program synthesis tools [19 , 34].
However, these techniques focus exclusively on eliminatin g the
leaks appearedintheinputprogram.Noneofthempaidattent ion
totheleaks introducedbyregister reuseduring thecompila tion.
9 CONCLUSIONS
Wehavepresented amethodformitigatingatypeofside-chan nel
leakscausedbyregisterreuseincompilers.Themethodreli esona
typeinference systemtodetectleaks,andleverages thetyp einfor-
mationtorestrictthecompiler’sbackendtoguaranteethat register
allocationissecure.WehaveimplementedthemethodinLLVM for
x86 and evaluated it on cryptographic software benchmarks. Our
experiments demonstrate that the method is eﬀective in miti gat-
ing leaks and the mitigated program has low performance over -
head.Speciﬁcally,itoutperformsstate-of-the-arthigh- ordermask-
ing techniques in terms of both the code size and the executio n
speed.Conference’17, July2017,Washington, DC,USA Jingbo Wang,Chungha Sung, andChaoWang
REFERENCES
[1] GiovanniAgosta,AlessandroBarenghi,andGerardoPelo si.2012.Acodemorph-
ing methodology to automate power analysis countermeasure s. InProceedings
of the The49thAnnual DesignAutomationConference 2012(DA C).77–82.
[2] Mehdi-Laurent Akkar and Louis Goubin. 2003. A generic pr otection against
high-order diﬀerential power analysis. In International Workshop on Fast Soft-
wareEncryption .192–205.
[3] José Bacelar Almeida, Manuel Barbosa, Jorge Sousa Pinto , and Bárbara
Vieira. 2013. Formal veriﬁcation of side-channel counterm easures using self-
composition. (2013).
[4] Nikolaos Athanasios Anagnostopoulos, Stefan Katzenbe isser, John A. Chandy,
and Fatemeh Tehranipoor. 2018. An overview of DRAM-based se curity primi-
tives.Cryptography 2,2(2018),7. https://doi.org/10.3390/cryptography202 0007
[5] Timos Antonopoulos, Paul Gazzillo, Michael Hicks, Eric Koskinen, Ta-
chio Terauchi, and Shiyi Wei. 2017. Decomposition instead o f self-
composition for proving the absence of timing channels. In ACM SIGPLAN
Conference on Programming Language Design and Implementati on. 362–375.
https://doi.org/10.1145/3062341.3062378
[6] JosepBalasch,BenediktGierlichs,VincentGrosso,Osc arReparaz,andFrançois-
Xavier Standaert. 2014. On the cost of lazy engineering for m asked software
implementations. In International Conference on Smart Card Research and Ad-
vanced Applications . Springer,64–81.
[7] LucasBang,AbdulbakiAydin,Quoc-SangPhan,CorinaS.P asareanu,andTevﬁk
Bultan. 2016. String analysisfor sidechannels with segmen ted oracles.In ACM
SIGSOFTSymposium on Foundationsof Software Engineering .193–204.
[8] GillesBarthe,SoniaBelaïd,FrançoisDupressoir,Pier re-AlainFouque,Benjamin
Grégoire, and Pierre-Yves Strub. 2015. Veriﬁed proofs of hi gher-order mask-
ing. InAnnual International Conference on the Theory and Applicat ions of Cryp-
tographicTechniques . 457–485.
[9] Gilles Barthe, Sonia Belaïd, François Dupressoir, Pier re-Alain Fouque, Ben-
jamin Grégoire, Pierre-Yves Strub, and Rébecca Zucchini. 2 016. Strong non-
interference and type-directed higher-order masking. In ACM SIGSAC Confer-
ence onComputer and CommunicationsSecurity . 116–129.
[10] Gilles Barthe, François Dupressoir, Sebastian Faust, Benjamin Grégoire,
François-Xavier Standaert, and Pierre-Yves Strub. 2017. P arallel implementa-
tions of masking schemes and the bounded moment leakage mode l. InAnnual
International Conference on the Theory and Applications of Cryptographic Tech-
niques.535–566.
[11] Gilles Barthe, Benjamin Grégoire, and Vincent Laporte . 2018. Secure compila-
tion of side-channel countermeasures: the case of cryptogr aphic âĂĲconstant-
timeâĂİ.In 2018IEEE31stComputerSecurityFoundationsSymposium(CS F).IEEE,
328–343.
[12] Gilles Barthe, Boris Köpf, Laurent Mauborgne, and Mart ín Ochoa. 2014. Leak-
ageResilienceagainstConcurrentCacheAttacks.In InternationalConferenceon
Principles ofSecurity and Trust .140–158.
[13] Ali GalipBayrak,FrancescoRegazzoni,Philip Brisk,F rançois-XavierStandaert,
andPaoloIenne.2011. Aﬁrststeptowardsautomaticapplica tionofpoweranal-
ysiscountermeasures.In ACM/IEEEDesignAutomationConference . 230–235.
[14] Ali Galip Bayrak, Francesco Regazzoni, David Novo, and Paolo Ienne. 2013.
Sleuth: Automated veriﬁcationof softwarepower analysisc ountermeasures.In
InternationalWorkshoponCryptographicHardwareandEmbe ddedSystems .293–
310.
[15] Swarup Bhunia, Michael S Hsiao, Mainak Banga, and Seeth aram Narasimhan.
2014. HardwareTrojanattacks:threatanalysisandcounter measures. Proc.IEEE
102,8 (2014), 1229–1247.
[16] Elia Bisi, Filippo Melzani, and Vittorio Zaccaria. 201 7. Symbolic analysis of
higher-ordersidechannel countermeasures. IEEETrans.Computers 66,6(2017),
1099–1105.
[17] Roderick Bloem, Hannes Gross,RinatIusupov,Bettina K önighofer, StefanMan-
gard, and Johannes Winter. 2018. Formal veriﬁcation of mask ed hardware im-
plementations inthepresenceofglitches.In AnnualInternational Conferenceon
the Theory and Applications of CryptographicTechniques . Springer,321–353.
[18] Johannes Blömer, Jorge Guajardo, and Volker Krummel. 2 004. Provably secure
masking of AES. In International workshop on selected areas in cryptography .
Springer,69–83.
[19] ArthurBlot, MasakiYamamoto,andTachioTerauchi.201 7. Compositional Syn-
thesisofLeakageResilientPrograms.In InternationalConferenceonPrinciplesof
Security and Trust .277–297.
[20] Martin Bravenboer and Yannis Smaragdakis. 2009. Stric tly declarative speciﬁ-
cation of sophisticated points-to analyses. ACM SIGPLAN Notices 44, 10 (2009),
243–262.
[21] Tegan Brennan, Seemanta Saha, and Tevﬁk Bultan. 2018. S ymbolic path cost
analysis for side-channel detection. In International Conference on Software En-
gineering. 424–425.
[22] EricBrier,ChristopheClavier,andFrancisOlivier.2 004. Correlationpoweranal-
ysiswith aleakagemodel. In International workshoponcryptographichardware
and embedded systems .16–29.
[23] David Canright and Lejla Batina. 2008. A very compact “p erfectly masked” S-
box for AES. In International Conference on Applied Cryptography and Netw ork
Security. Springer,446–459.[24] GregoryChaitin.2004. Registerallocationandspilli ngviagraphcoloring. ACM
SIGPLAN notices 39,4 (2004), 66–74.
[25] Suresh Chari, Charanjit S Jutla, Josyula R Rao, and Pank aj Rohatgi. 1999. To-
wards sound approachesto counteract power-analysisattac ks.InAnnual Inter-
national Cryptology Conference .398–412.
[26] JiaChen,YuFeng,andIsilDillig.2017. Precisedetect ionofside-channelvulner-
abilitiesusingquantitativecartesianhoarelogic.In ACMSIGSAC Conferenceon
Computer and CommunicationsSecurity . 875–890.
[27] ChristopheClavier,Jean-SébastienCoron,andNoraDa bbous.2000. Diﬀerential
power analysis in the presence of hardware countermeasures . InInternational
Workshop onCryptographic Hardwareand Embedded Systems .252–263.
[28] Keith D. Cooper and Anshuman Dasgupta.2006. Tailoring graph-coloring reg-
isterallocationforruntimecompilation.In FourthIEEE/ACMInternational Sym-
posiumonCodeGenerationandOptimization(CGO2006),26-2 9March2006,New
York,New York,USA .39–49. https://doi.org/10.1109/CGO.2006.35
[29] Jean-Sébastien Coron, Christophe Giraud, Emmanuel Pr ouﬀ, Soline Renner,
Matthieu Rivain, and Praveen Kumar Vadnala. 2012. Conversi on of security
proofs from one leakage model to another: A new issue. In International Work-
shop onConstructiveSide-Channel Analysis and Secure Desi gn.Springer,69–81.
[30] Jean-Sébastien Coron, Emmanuel Prouﬀ, Matthieu Rivai n, and Thomas Roche.
2013. Higher-orderside channel security and mask refreshi ng.InInternational
Workshop onFastSoftware Encryption .410–424.
[31] Leonardo De Moura and Nikolaj Bjørner. 2008. Z3: an eﬃci ent SMT solver. In
Proceedings of the Theory and Practiceof Software, 14thInter national Conference
on Tools and Algorithms for the Construction and Analysis of Systems. Springer-
Verlag, Berlin,Heidelberg,337–340.
[32] GoranDoychev,DominikFeld,BorisKöpf,LaurentMaubo rgne,andJanReineke.
2013. CacheAudit: A tool for the static analysis of cache sid e channels. In Pro-
ceedings ofthe 22thUSENIXSecurity Symposium .431–446.
[33] Alexandre Duc, Sebastian Faust, and François-Xavier S tandaert. 2015. Making
maskingsecurityproofsconcrete.In AnnualInternationalConferenceontheThe-
ory and Applications of CryptographicTechniques . 401–429.
[34] Hassan Eldib and Chao Wang. 2014. Synthesis of masking c ountermeasures
againstsidechannelattacks.In InternationalConferenceonComputerAidedVer-
iﬁcation.114–130.
[35] HassanEldib, ChaoWang,and PatrickSchaumont. 2014. F ormalveriﬁcationof
software countermeasures against side-channel attacks. ACM Transactions on
Software Engineering and Methodology 24, 2(2014), 11.
[36] Lal George and Andrew W. Appel. 1996. Iterated register coalescing.
InConference Record of POPL’96: The 23rd ACM SIGPLAN-SIGACT Symp o-
sium on Principles of Programming Languages, Papers Presented a t the Sym-
posium, St. Petersburg Beach, Florida, USA, January 21-24, 1 996. 208–218.
https://doi.org/10.1145/237721.237777
[37] LouisGoubin. 2001. A sound method for switching betwee nbooleanand arith-
metic masking. In International Workshop on Cryptographic Hardware and Em-
bedded Systems .Springer,3–15.
[38] Marc Gourjon. 2019. Towards Secure Compilation of Powe r
Side-Channel Countermeasures. Retrieved Jan 13, 2019 from
https://popl19.sigplan.org/event/prisc-2019-towards -secure-compilation-of-power-side-channel-counterme asures
[39] Krystof Hoder, Nikolaj Bjørner, and Leonardo de Moura. 2011. muZ - An ef-
ﬁcient engine for ﬁxed points with constraints. In Computer Aided Veriﬁcation
- 23rd International Conference, CAV 2011, Snowbird, UT, US A, July 14-20, 2011.
Proceedings (LectureNotesin ComputerScience) , Vol. 6806. 457–462.
[40] Shourong Hou, Yujie Zhou, Hongming Liu, and Nianhao Zhu . 2017. Improved
DPA attack on rotating S-boxes masking scheme. In Communication Software
and Networks(ICCSN),2017IEEE9th International Conferen ceon.1111–1116.
[41] Ralf Hund, Carsten Willems, and Thorsten Holz. 2013. Pr actical timing side
channel attacksagainst kernel spaceASLR. In IEEESymposium on Security and
Privacy. 191–205.
[42] Yuval Ishai, Amit Sahai,and DavidA. Wagner.2003. Priv ateCircuits:Securing
Hardware against Probing Attacks. In Advances in Cryptology - CRYPTO 2003,
23rdAnnualInternationalCryptologyConference,SantaBa rbara,California,USA,
August17-21,2003,Proceedings . 463–481.
[43] Paul Kocher, Joshua Jaﬀe, and Benjamin Jun. 1999. Diﬀer ential power analysis.
InAnnual International Cryptology Conference .388–397.
[44] PaulCKocher.1996.Timingattacksonimplementations ofDiﬃe-Hellman,RSA,
DSS,andothersystems.In AnnualInternationalCryptologyConference .104–113.
[45] Monica S Lam, John Whaley, V Benjamin Livshits, Michael C Martin, Dzintars
Avots,MichaelCarbin,andChristopherUnkel.2005. Contex t-sensitiveprogram
analysisas databasequeries.In Proceedings of the twenty-fourth ACM SIGMOD-
SIGACT-SIGARTsymposiumon Principlesof database systems .ACM,1–12.
[46] Chris Lattner and Vikram Adve. 2004. LLVM: A compilatio n framework for
lifelongprogramanalysis&transformation.In InternationalSymposiumonCode
Generation and Optimization . 75.
[47] Abhranil Maiti and Patrick Schaumont. 2011. Improved R ing Oscillator PUF:
An FPGA-friendly Secure Primitive. J. Cryptology 24, 2 (2011), 375–397.
https://doi.org/10.1007/s00145-010-9088-4
[48] PasqualeMalacaria,MHRKhouzani,CorinaSPasareanu, Quoc-SangPhan,and
KasperLuckow.2018.Symbolicside-channelanalysisforpr obabilisticprograms.
In2018 IEEE 31st Computer Security Foundations Symposium (CS F). IEEE, 313–
327.Mitigating Power SideChannelsduring Compilation Confere nce’17, July2017,Washington, DC,USA
[49] Stefan Mangard. 2002. A simple power-analysis (SPA) at tack on implementa-
tionsoftheAESkeyexpansion.In International ConferenceonInformationSecu-
rityand Cryptology .Springer,343–358.
[50] Stefan Mangard, Elisabeth Oswald, and Thomas Popp. 200 7.Power analysis at-
tacks- revealingthe secretsof smartcards .
[51] DavidMcCann, CarolynWhitnall, and ElisabethOswald. 2016. ELMO:Emulat-
ing Leaksfor the ARM Cortex-M0without Accessto aSide Chann el Lab.IACR
Cryptology ePrintArchive 2016 (2016), 517.
[52] Thomas S Messerges. 2000. Using second-order power ana lysis to attack DPA
resistant software. In International Workshop on Cryptographic Hardware and
Embedded Systems .238–251.
[53] ThomasSMesserges,EzzyADabbish,andRobertHSloan.1 999. Investigations
of poweranalysisattackson smartcards. Smartcard 99 (1999), 151–161.
[54] Thomas S Messerges, Ezzat A Dabbish, and Robert H Sloan. 2002. Examining
smart-cardsecurityunderthethreatofpoweranalysisatta cks.IEEEtransactions
on computers 51,5 (2002), 541–552.
[55] AmirMoradi.2014. Side-channel leakagethroughstati cpower.In International
Workshopon CryptographicHardware and Embedded Systems .562–579.
[56] Andrew Moss, Elisabeth Oswald, Dan Page, and Michael Tu nstall. 2012. Com-
pilerassistedmasking.58–75.
[57] InèsBenElOuahma,QuentinMeunier,KarineHeydemann, andEmmanuelleEn-
crenaz.2017.SymbolicapproachforSide-Channelresistan ceanalysisofmasked
assemblycodes. In Security ProofsforEmbedded Systems .
[58] Kostas Papagiannopoulos and Nikita Veshchikov. 2017. Mind the gap: towards
secure1st-ordermaskinginsoftware.In InternationalWorkshoponConstructive
Side-Channel Analysis and Secure Design .Springer,282–297.
[59] CorinaS.Pasareanu,Quoc-SangPhan,andPasqualeMala caria.2016. Multi-run
Side-Channel analysis using symbolic execution and Max-SM T. InIEEE Com-
puter Security Foundations Symposium . 387–400.
[60] Quoc-SangPhan,LucasBang,CorinaS.Pasareanu,Pasqu aleMalacaria,andTev-
ﬁkBultan.2017. SynthesisofAdaptiveSide-ChannelAttack s.InIEEEComputer
Security Foundations Symposium .328–342.
[61] Massimiliano Poletto and Vivek Sarkar. 1999. Linear sc an register
allocation. ACM Trans. Program. Lang. Syst. 21, 5 (1999), 895–913.
https://doi.org/10.1145/330249.330250
[62] Emmanuel Prouﬀ and Matthieu Rivain. 2013. Masking agai nst side-channel at-
tacks:Aformalsecurityproof.In Annual International ConferenceontheTheory
and Applications of CryptographicTechniques . 142–159.
[63] Jean-Jacques Quisquater and David Samyde. 2001. Elect romagnetic analysis
(ema):Measuresandcounter-measuresforsmartcards. In SmartCardProgram-
mingand Security . 200–210.
[64] OscarReparaz, Begül Bilgin, Svetla Nikova,Benedikt G ierlichs, and Ingrid Ver-
bauwhede.2015. Consolidatingmaskingschemes.In AnnualCryptologyConfer-
ence. Springer,764–783.
[65] Matthieu Rivain and Emmanuel Prouﬀ. 2010. Provably sec ure higher-order
maskingofAES. In International WorkshoponCryptographicHardwareand Em-
bedded Systems .Springer,413–427.
[66] Ulrich Rührmair, Heike Busch, and Stefan Katzenbeisse r. 2010.
Strong PUFs: models, constructions, and security proofs. I nTo-
wards Hardware-Intrinsic Security - Foundations and Practi ce. 79–96.
https://doi.org/10.1007/978-3-642-14452-3_4
[67] Kai Schramm and Christof Paar. 2006. Higher order maski ng of the AES. In
Cryptographers’trackat theRSA conference . Springer,208–225.
[68] MarceloSousaand Isil Dillig. 2016. Cartesianhoarelo gic for verifyingk-safety
properties. In ACMSIGPLAN Conference on ProgrammingLanguage Design and
Implementation . 57–69. https://doi.org/10.1145/2908080.2908092
[69] François-XavierStandaert,TalGMalkin,andMotiYung .2009. Auniﬁedframe-
work for the analysis of side-channel key recovery attacks. InAnnual Interna-
tional Conference on the Theory and Applications of Cryptog raphic Techniques .
443–461.
[70] Shuai Wang, Pei Wang, Xiao Liu, Danfeng Zhang, and Dingh ao Wu. 2017.
CacheD: Identifying cache-based timing channels in produc tion software. In
USENIXSecurity Symposium . 235–252.
[71] John Whaley, Dzintars Avots, Michael Carbin,and Monic a S Lam. 2005. Using
datalog with binary decision diagrams for program analysis . InAsian Sympo-
siumonProgrammingLanguages and Systems .Springer,97–118.
[72] JohnWhaleyand MonicaSLam.2004. Cloning-basedconte xt-sensitivepointer
aliasanalysisusingbinarydecisiondiagrams.In ACMSIGPLANNotices ,Vol.39.
ACM,131–144.
[73] Meng Wu,ShengjianGuo, PatrickSchaumont, and ChaoWan g.2018. Eliminat-
ingtimingside-channelleaksusingprogramrepair.In InternationalSymposium
on SoftwareTestingand Analysis .
[74] YuanYao,MoYang,ConorPatrick,BilgidayYuce,andPat rickSchaumont.2018.
Fault-assisted side-channel analysis of masked implement ations. In 2018 IEEE
International SymposiumonHardwareOriented Securityand Trust(HOST) .IEEE,
57–64.
[75] Jun Zhang, Pengfei Gao, Fu Song, and Chao Wang. 2018. SCI nfer: Reﬁnement-
basedveriﬁcationofsoftwarecountermeasuresagainstSid e-Channelattacks.In
International Conferenceon ComputerAided Veriﬁcation .
[76] XinZhang,RaviMangal,RaduGrigore,MayurNaik,and Ho ngseok Yang.2014.
On abstraction reﬁnement for program analyses in Datalog. ACM SIGPLANNotices49, 6(2014), 239–248.
[77] Yongbin Zhou and Dengguo Feng. 2005. Side-Channel Atta cks: Ten yearsafter
itspublicationandtheimpactsoncryptographicmodule sec uritytesting. IACR
Cryptology ePrint Archive (2005), 388.