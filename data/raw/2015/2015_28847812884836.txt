Finding Security Bugs in Web Applications using a
Catalog of Access Control Patterns
Joseph P . Near
University of California, Berkeley
jnear@berkeley.eduDaniel Jackson
Massachusetts Institute of Technology
dnj@mit.edu
ABSTRACT
We propose a specication-free technique for nding missing
security checks in web applications using a catalog of access
control patterns in which each pattern models a common
access control use case. Our implementation, Space , checks
that every data exposure allowed by an application's code
matches an allowed exposure from a security pattern in our
catalog. The only user-provided input is a mapping from
application types to the types of the catalog; the rest of the
process is entirely automatic. In an evaluation on the 50
most watched Ruby on Rails applications on Github, Space
reported 33 possible bugs|23 previously unknown security
bugs, and 10 false positives.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation
Keywords
web application security, access control, bug nding
1 Introduction
Web application security holes represent a large and growing
class of bugs. Programming frameworks and static analysis
tools have begun to address bugs that violate generic, cross-
application specications (for example, injection, cross-site
scripting and overow vulnerabilities). However, applica-
tion-specic bugs (like missing security checks) have received
less attention. Traditional solutions, such as verication
and dynamic policy-enforcement techniques, ask the user to
write a specication of the intended access control policy.
We propose a specication-free technique for nding appli-
cation-specic security bugs using a catalog of access control
patterns . Each pattern in our catalog models a common
access control use case in web applications. Our catalog
is based on the assumption that developers usually intend
for a particular pattern to be applied uniformly to all uses
of a given resource type|an assumption supported by our
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14 - 22, 2016, Austin, TX, USA
c2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.2884836experience with real-world applications.
Our approach checks that for every data exposure allowed
by an application's code, our catalog also allows the ex-
posure. When the application allows a data exposure not
allowed by the catalog, we report that exposure as a secu-
rity bug. This process requires only that the user provide
a mapping of application resources to the basic types (such
as user, permission, etc.) that occur in our catalog. From
this information alone, application-specic security bugs are
identied automatically.
We have implemented this technique in Space (Security
Pattern Checke r).Space uses symbolic execution to ex-
tract the set of data exposures [25] from the source code
of a Ruby on Rails application. The constraints associ-
ated with these exposures and the user-provided mapping
are passed through a constraint specializer, which re-casts
the constraints in terms of the types in our pattern catalog.
Then, Space uses the Alloy Analyzer to perform automatic
bounded verication that each data exposure allowed by the
application is also allowed by our catalog.
We applied Space to the 50 most watched open-source
Rails applications on Github. We found that 30 of the 50
implement access control, and Space found bugs in 8 of
those 30|a total of 23 unique bugs. Both the symbolic
execution and bounded verication steps of our technique
scale to applications as large as 45k lines of code|none of
our analyses took longer than 64 seconds to nish.
This paper makes the following contributions:
A highly automated technique for nding security bugs
based on the idea of matching extracted access pat-
terns to known safe patterns;
An initial catalog of common security patterns, based
on those we encountered in an analysis of real-world
applications;
An open-source implementation,1Space , that has been
used to nd previously unknown bugs in open-source
Rails applications.
In section 2, we describe Space from the user's perspec-
tive and demonstrate its use to nd a bug. In section 3, we
formalize our catalog of patterns and the technique used to
check them against an application. Section 4 describes our
implementation of Space , and section 5 details our evalu-
ation of its eectiveness. In section 6, we discuss related
work, and section 7 contains our conclusions.
1http://www.cs.berkeley.edu/~jnear/space
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   947
class UserController <ApplicationController
before lter : signed inuser , : only => [:show, : edit ,
:update]
before lter : correct user , : only = >[:show, : edit ]
...
defshow
@user = User.nd(params[:id ])
@posts = nd posts byuser id @user.id
@editing = true if signed in ?
end
def edit
@user = User.nd(params[:id ])
@url = '/user/' + params[:id]
end
defupdate
@user = User.nd(params[:id ])
if@user. update attributes (user params)
redirect to @user, success : ' Editing successful ! '
else
redirect to edit user path (@user.id), error : ' Editing
failed ! '
end
end
end
Figure 1: Controller Code for MediumClone
2 Description & Example
Space (Security Pattern Checke r) nds security bugs in
Ruby on Rails2web applications, and requires only that the
user provide a mapping from application-dened resource
types to the object types of the standard role-based model
of access control (RBAC) [30, 15]. Space is otherwise com-
pletely automatic: it analyzes the target application's source
code and returns a list of bugs.
Space is designed primarily to nd mistakes in the imple-
mentation of an application's security policy. Most often,
these mistakes take the form of missing security checks. In
this section, we describe an example open-source applica-
tion (MediumClone) and demonstrate how we used Space
to nd security bugs in its implementation.
2.1 Example Application: MediumClone
MediumClone3is a simple blogging platform designed to
mimic the popular web site Medium. Using MediumClone,
users can read posts and log in to create new posts or update
existing ones. The site requires users to sign up and log
in before writing posts, and prevents users from modifying
others' posts.
A Rails application is composed of actions , each of which
handles requests to a particular URL within the applica-
tion. Controllers are collections of actions; each controller's
actions implement an API for interacting with a resource ex-
posed by the site. Resources are dened using the ActiveRe-
cord library, which implements an object-relational mapper
to persist resource instances using a database, and which
provides a set of built-in methods for querying the database
for resource instances.
Figure 1 contains a part of the controller code for Medi-
umClone's UserController, which provides a RESTful API
for user proles. Following the REST convention, the show
2http://rubyonrails.org/
3https://github.com/seankwon/MediumCloneaction is for displaying proles, the editaction displays an
HTML form for editing the prole, and submitting that form
results in a POST request to update action, which actually
performs the database update (using update attributes ). The
call to before lter installs a lter |a procedure that runs
before the action itself|for the show and editactions. The
lter checks that the logged-in user has permission to per-
form the requested action, and redirects them to an error
page if not. This use of lters to enforce security checks
is common in Rails applications, and helps to ensure that
checks are applied uniformly.
MediumClone's Security Bug. The code in Figure 1
fails to apply the correct user lter to the update action, so
an attacker can send an HTTP POST request directly to
theupdate URL of the MediumClone site to update any
user prole. The lter isproperly applied to the editac-
tion. In our experience, this kind of mistake is common: the
developer assumes the user will use the interface provided
by the site (in this case, the editpage), and will not craft
malicious requests to constructed URLs. Developers often
fail to consider alternative paths not accessible through the
interface, and therefore omit vital security checks.
Finding the Bug Using Space .Space compares the
checks present in the application code against its built-in
catalog of common security patterns. When the applica-
tion code is missing security checks required by the patterns,
Space reports a bug in the code.
Space 's security patterns are formalized in terms of role-
based access control (RBAC), which denes sets of users,
roles, operations, objects , and permissions .Space 's formal
models of security patterns enforce security checks by con-
straining relations between these sets. In order to check
these patterns against a piece of code, the user provides a
mapping of the application's resources to the sets of objects
dened in the RBAC model. MediumClone's User type rep-
resents the User type in the RBAC pattern, and Posts are
special RBAC objects that have an owner. The owns rela-
tion is dened by our model of ownership, and user: owns
means that the usereld of a Post species its owner. The
user provides this mapping for MediumClone as follows:
Space.analyze do
mapping User: RBACUser,
Post: OwnedObject(user: owns)
end
Space requires the mapping above and MediumClone's
source code|it needs no further input or guidance from the
user. The mapping provided by the user translates between
the RBAC objects constrained by the pattern catalog and
the resource types dened in the application code. Space
uses this mapping to specialize the constraints derived from
the checks present in the code to the set of RBAC objects,
so that the two sets of security checks can be compared.
Space compares the specialized constraints against the
constraints required by the pattern catalog. When Space
nds a missing check, it builds a counterexample demon-
strating the security vulnerability caused by the missing
check. The counterexample is specic to the application
code under analysis: it involves resource types dened in
the code, rather than RBAC concepts.
For MediumClone, Space produces the counterexample
shown in Figure 2(a). The \Update0" box indicates that an
update is possible on the prole of\AUser0"(the\target"|a
948(a) (b)
Figure 2: Space Counterexample Showing Medium-
Clone Security Bugs: (a) user can update another
user's prole; (b) unauthenticated user (\NoUser")
can update any post
renaming of\User"to avoid clashes) by the distinct\AUser1"
(the \current user", or currently logged-in user). This coun-
terexample demonstrates a user updating another user's pro-
le using the update action|a situation that is not captured
by our security pattern catalog. The User Prole Pattern
explicitly requires that users can update their own proles,
but no pattern exists that allows updating another user's
prole. The bug can be xed by adding :update to the list
of actions for which the : correct user lter is applied.
More Bugs in MediumClone. Fixing the bug and run-
ningSpace again yields a new counterexample, shown in
Figure 2(b). This counterexample suggests that Post re-
sources in MediumClone can be updated not only by users
who did not create them, but by users who are not logged
in (\NoUser") at all! The code for PostController checks that
the user is logged in before performing the new, create, and
editactions, but omits this check for the update action:
class PostController <ApplicationController
before lter : signed inuser , : only => [:new, :create ,
: edit ]
...
end
This bug is interesting because the intended security policy|
that users only modify their own posts|is forgotten across
the entire application codebase. This mistake exemplies a
class of bugs that are dicult to detect with testing or with
our previously-developed consistency checker, Derailer [25].
3 Formal Model
This section formalizes our catalog and Space 's method for
comparing it to a web application's code. The rst step is
to derive a list of data exposures from the application code,
representing the dierent ways users of the application can
read or update data stored in the database. Second, Space
uses the mapping dened by the user to specialize each expo-
sure's constraints to the objects constrained by the catalog.
Finally, Space veries that each data exposure allowed by
the application code is also allowed by the catalog.
3.1 Web Applications
We consider web applications in terms of sets of Databases ,
Requests , and Resources . An application denes relations
response and update describing (in the context of a given
database) the resources sent to the requester and updatedin the database, respectively. Note that the updates do not
specify the resulting state of the database; our concern is
only whether modications can be made to particular re-
sources, and not the actual values of those modications.
Databases P (ResourcesValues )
response DatabasesRequestsResources
update DatabasesRequestsResources
Space approximates these relations by using symbolic ex-
ecution to build the exposures relation, representing the ap-
plication's set of data exposures:
Operations =fread;writeg
Constraints rst-order predicates over requests
and databases
exposures RequestsConstraints
OperationsResources
The exposures relation characterizes the conditions ( )
under which the application code allows a particular re-
source to be read or written. The formula ( db;req;res )2
response)means that if the application exposes resource
res, itmust be under conditions .
8db;req;res;: ((db;req;res )2response))()
(req;; read;res)2exposures
8db;req;res;: ((db;req;res )2update))()
(req;; write;res)2exposures
Space builds the exposures relation by symbolically eval-
uating each action of the web application under analysis,
passing symbolic values for the database and user-supplied
parameters. Space enumerates the symbolic values that can
appear on a rendered page and constructs an exposure for
each one. These exposures have the form ( req;; read;res),
wherereqis the original symbolic request, is the path con-
dition derived from the symbolic execution, and resis the
symbolic expression representing the exposed resource. Sim-
ilarly, when Space nds a database update, it constructs an
exposure of the form ( req;; write;res), wherereqis the re-
quest,is the current path condition, and resis a symbolic
expression representing the resource being updated.
Example. As a running example, we take MediumClone's
UserController bug from section 2. For this controller's buggy
update action, Space generates the exposure:
(update (user.prole );true; write;user)
meaning that when the application receives a request to up-
date a user prole of user, it performs the modication with-
out enforcing any constraints. The exposure that correctly
enforces the desired security policy (by enforcing that the
modied prole is the current user's) is instead:
(update (user.prole );user =current user; write;user)
3.2 Role-Based Access Control
As a basis for representing security policies, we adopt the
role-based access control model of Sandhu et al. [30] (specif-
ically,RBAC 0). The standard model of role-based access
control consists of sets Users ,Roles ,Permissions , and Ses-
sions , over which the following relations are dened to assign
permissions and users to roles:
permission a PermissionsRoles
user a UsersRoles
We adopt the extension of this model by Ferraiolo et al.
[15] with Objects andOperations , where Objects contains the
949targets of permissions (which will correspond to the web ap-
plication's resources) and Operations (for our applications)
contains the operation types read and write already used in
the denition of the exposures relation. This model denes
Permissions to be a set of mappings between operations (ei-
ther read orwrite) and objects allowed by that permission:
Permissions =P(OperationsObjects)
3.3 Security Pattern Catalog
The patterns in our catalog constrain the relations of the
generic RBAC model to specically allow certain behaviors.
Each one of these pattern denitions corresponds to a stan-
dard use case for resources in web applications; in eect, the
patterns \whitelist" common kinds of correct data accesses.
Access Pattern 1: Ownership. In most applications,
resources created by a user \belong" to that user, and a
resource's creator is granted complete control over the re-
source. To express this use case, we dene a relation owns
between users and objects, and then allow those owners to
perform both reads and writes on objects they own:
owns UsersObjects
8u;o: (u;o)2owns)
9r:(u;r)2user a^
((read;o);r)2permissiona^
((write;o);r)2permissiona
Access Pattern 2: Public Objects. Many applications
make some resources public. A blog, for example, allows
anyone to read its posts. This pattern denes PublicObjects
to be a subset of the larger set of Objects, and allows anyone
to read (but not write) those objects:
PublicObjects Objects
8u;r;o;p:o2PublicObjects^(u;r)2user a)
((read;o);r)2permissiona
Access Pattern 3: Authentication. Every application
with access control has some mechanism for authenticating
users, and many security holes are the result of the program-
mer forgetting to check that the user is logged in before al-
lowing an operation. To model authentication, this pattern
denes logged in, a (possibly empty) subset of Users rep-
resenting the currently logged-in users, and constrains the
system to allow permission only for logged-in users (except
for public objects):
logged in Users
8u;r;o;op;p:
(u;r)2user a^((op;o);r )2permissiona)
(op=read^o2PublicObjects )_
u2logged in
Access Pattern 4: Explicit Permission. Some applica-
tions dene a kind of resource representing permission, and
store instances of that resource in the database. Before al-
lowing access to another resource, the application checks for
the presence of a permission resource allowing the access. To
model this use case, this pattern denes PermissionObjects
to be a subset of Objects, denes a relation permits relat-
ing a permission object to the user, operation, and object it
gives permission to, and allows users to perform operations
allowed by permission objects:PermissionObjects  Objects
permits PermissionObjects Users
OperationsObjects
8u;o;p;op: (p;u;op;o)2permits)
9r:(u;r)2user a^((op;o);r )2permissiona
Access Pattern 5: User Proles. Applications with
users tend to have prole information associated with those
users. Programmers commonly forget checks requiring that
the user updating a prole must be the owner of that prole;
this pattern constrains the allowed writes so that no user can
update another user's prole:
proleUsersObjects
8u;p:9r:(u;r)2user a^(u;p)2prole^
((write;p);r )2permissiona
Access Pattern 6: Administrators. Many applications
distinguish a special class of users called administrators that
have more privileges than normal users. We can represent
these users with a special role called Admin , which grants its
users full permissions on all objects:
Admin2Roles
8o:((read;o);Admin )2permissiona^
((write;o);Admin )2permissiona
Access Pattern 7: Explicit Roles. A few applications
specify distinct roles and represent them explicitly using a
resource type. They then assign roles to users and allow
or deny permission to perform operations based on these
assigned roles. This pattern introduces a level of indirection
to allow mapping these resource-level role denitions to the
RBAC-dened set of roles:
RoleObjects Objects
object roles RoleObjectsRoles
user roles UsersRoleObjects
8ro;r;u: (ro;r )2object roles^
(u;ro )2user roles)
(u;r)2user a
3.4 Mapping Application Resources to RBAC
Objects
To compare the operations allowed by an application to
those permitted by our security patterns, a mapping is re-
quired between the objects dened in the RBAC model and
the resources dened by the application. In many cases, this
mapping is obvious (a resource named \User" in the appli-
cation, for example, almost always represents RBAC users),
but in general it is not possible to infer the mapping directly.
Space asks the user to dene this mapping. Formally, it
is a mapping from types of application resources to types of
RBAC objects; the mapping is a relation, since some appli-
cation resources may represent more than one type of RBAC
object. The set of resource types can be derived from the ap-
plication's data model (which is present in its source code),
and the set of RBAC object types is based on the formal
model of RBAC dened here.
Resource = application-dened types
RBAC =fUser, Object, PermissionObject,
OwnedObject, PublicObject,
RoleObjectg
mapResourceRBAC
We also need to provide denitions from the application
for the new concepts introduced in our pattern denitions:
PublicObjects ,PermissionObjects , and the owns andpermits
950relations. The map relation can be used to dene public and
permission objects, but we must dene a separate mapping
from eld names of resources to the corresponding relations
they represent in our security patterns. We use map eldsfor
this purpose.
FieldNames = application-dened eld names
RelationNames =fowns, permits, logged in,
object roles, user rolesg
map elds FieldNamesRelationNames
Finally, we dene session relating web application Requests
and the currently logged-in RBAC User :
session RequestsUsers
The session relation is needed to determine the currently
logged-in user (if any|some requests are sent with no au-
thentication) of the application. Since Rails has session
management built in, this mapping can be inferred auto-
matically.
Example. Based on the mapping provided for Medium-
Clone in section 2, Space populates the mapping relations
as follows:
Resource =fMUser, MPostg
map = ((MUser, User),
(MPost, OwnedObject) )
FieldNames =fauthor, ...g
map elds = ((author, owns) )
3.5 Finding Pattern Violations
To nd bugs in a given application, the goal is to nd expo-
sures that are not allowed by some security pattern. For each
exposure in exposures , this process proceeds in two steps.
To check exposure ( req;;op;res ):
1. Build a specialized constraint 0fromby substituting
RBAC objects for application resources using the map
relation supplied by the user.
2. Determine whether or not some pattern allows the ex-
posure by attempting to falsify the formula:
0)(u;r)2user a)((op;obj );r)2permissiona
whereu;randobjare RBAC objects corresponding
to the current user sending reqand the resource res.
Intuitively, this formula holds when the conditions im-
posed by the application imply that some pattern al-
lows the exposure.
Building0.We use map to build a specialized constraint
0fromas follows:
Replace each reference resto an application resource
inwith an expression fj(res; )2mapgrepresent-
ing the corresponding set of possible RBAC objects.
Replace each eld reference o:fld inwith an expres-
sionfo0j(fld;r )2mapelds^(o0;o)2rgrepresenting a
reference to the corresponding relation dened by our
security patterns.
Intuitively, this means replacing references to application re-
sources with the corresponding RBAC objects (based on the
user-supplied map), and replacing references to elds of re-
sources that represent object ownership, permission type, or
permission for a particular object with formulas representing
those concepts in terms of RBAC objects.
Checking Conditions. For each (req;;op;res )2exposures :Let0be the result of performing substitution on 
using the user-supplied map.
Letobjbe the RBAC objects corresponding to the
application resource res, so that if ( res;o )2map then
o2obj.
Letube the current user, so that ( req;u )2session .
LetCbe the conjunction of all of the constraints de-
ned by our pattern catalog.
Then the following formula must hold:
C^0)9r: (u;r)2user a^((op;obj );r)2permissiona
This process checks that if both the pattern catalog and
the specialized condition hold, then the current user uis
allowed to perform operation opon the RBAC object obj
corresponding to the resource resacted upon by the appli-
cation code. If a counterexample is found, it means that the
application allows the user to perform a particular operation
on some object, but no security pattern exists allowing that
action. In other words, such a counterexample represents a
situation that does not correspond to one of our common
use-cases of web applications, and is likely to be a security
bug.
Example. To check the buggy exposure in our running
example, Space setsop=write,0=true, obj=user,
and u=current user. Then, Space attempts to falsify the
formula:
C^true)9r: (current user;r )2user a^
((write;user);r)2permissiona
This formula is falsied by any assignment under which
user6=current userand user aand permissionado not give
the current user permission to update user's prole, since
the user prole pattern requires only that the current user
be able to update his or her ownprole. An example of such
an assignment is the one that Space reports for this bug,
shown earlier in Figure 2.
The exposure corresponding to the correct security policy,
in contrast, yields 0= (user =current user), so the formula
to be falsied is:
C^user =current user)
9r:(current user;r )2user a^
((write;user);r)2permissiona
Since this formula requires that the prole being updated is
the current user's, any assignment that falsies it also falsi-
es the user prole pattern. Substituting the (specialized)
user prole pattern for Cresults in a tautology:
9r:(current user;r )2user a^
((write;current user);r )2permissiona^
user =current user)
9r:(current user;r )2user a^
((write;user);r)2permissiona
4 Implementation
Our implemented tool, Space (Security Pattern Checke r),
nds security bugs in Ruby on Rails web applications. Fig-
ure 3 contains an overview of Space 's architecture. Space
extracts the data exposures from an application using sym-
bolic execution, specializes the constraints on those expo-
sures to the types of role-based access control using the
mapping provided by the user, and exports the specialized
constraints to an Alloy specication. Then, Space uses the
951SPACEApplication Code
Symbolic Evaluator
Exposures
Constraint SpecializerObject 
Mapping
Alloy AnalyzerSpecialized 
ConstraintsAccess 
Control 
Patterns
BugsFigure 3: Summary of the Architecture of Space
Alloy Analyzer|an automatic bounded verier for the Al-
loy language|to compare the specialized constraints to our
pattern catalog (which is also specied in Alloy).
4.1 Symbolic Execution
Implementing a standalone symbolic evaluator is dicult for
any language, but especially so for Ruby. Ruby is dynamic,
has no formal specication, and changes quickly. Since Rails
is a large library using nearly all of Ruby's features, however,
a symbolic evaluator for Ruby on Rails applications must
implement all of those features too.
Rather than attempt to build a standalone symbolic eval-
uator, we used a symbolic execution library to coerce Ruby's
standard interpreter into performing symbolic execution. We
developed this approach for Rubicon [24], which performed
bounded verication of user-dened properties on Rails ap-
plications, and Derailer [25], which interacts with the user to
nd mistakes in the uniform application of a security policy.
We present a brief explanation of the library-based ap-
proach to symbolic execution here for completeness. De-
tailed descriptions of our approach to symbolic execution is
available as part of our earlier work; a formal description of
the technique, including an embedding in a simplied Ruby-
like language with a formal semantics and a proof that it
produces the same results as the standard approach to sym-
bolic execution, is available in [26].
Symbolic Values. Our library denes Ruby classes for
symbolic objects and expressions. When a program invokes
a method on a symbolic object, Ruby's method missing fea-
ture is used to produce a new symbolic expression.
defmethod missing(m,a)
Exp.new(m, [ self]+a)
end
def==(o)
Exp.new(:==,[ self,o])
end
endclass Exp<SymbolicObject
def initialize (m, a)
@meth = m
@args = a
end
end
These class denitions dene symbolic values, and can be
used to perform simple symbolic execution. For example,
the following three statements evaluate to (written )) theresult of symbolically evaluating the given method call:
x = SymbolicObject.new
y = SymbolicObject.new
x.foo(y))Exp(foo, [x, y])
Similarly, since Ruby's inx operators are interpreted as
method calls, the symbolic evaluator we have dened works
for these operators as well:
x+y == y+x)Exp(==,[Exp(+,[x,y]),Exp(+,[y,x]) ])
Conditionals. Symbolic execution runs both branches of
each conditional. Ruby does not allow redening condition-
als, so we rewrite the source code of the target application
to call our own denition of if.
x = SymbolicObject.new
ifx.even? then
(x+1).odd?
end)Exp( if,[ Exp(even?,[x]) ,
Exp(odd?,[Exp(+,[x,1]) ]) ]) g
Side eects. Programs may perform side eects inside of
conditionals; the results should be visible only if the con-
dition holds. We split the current state into two versions,
recording the condition and values using a Choice object.
x = SymbolicObject.new
ifx.even? then x = 1
else x = 2 end
x) Choice(Exp(even?,[x]) ,1,2)
4.2 Analyzing Rails Applications
Space symbolically evaluates each action in a Rails appli-
cation and collects the set of symbolic objects appearing on
a page or written to the database. These symbolic objects
represent the set of possible exposures of the application.
Wrapping ActiveRecord. Rails applications interact with
the database using ActiveRecord, an object-relational map-
per (ORM) that provides methods like\ nd"and\ all." These
methods are wrappers around database queries: they al-
low the specication of queries (including features of SQL
likewhere and group by ) directly in Ruby, and are trans-
lated by the ORM into SQL queries. Space provides a new
implementation of the ActiveRecord API that ignores the
concrete database and instead returns symbolic values rep-
resenting the set of possible results for alldatabases. Given
a \User" class extending ActiveRecord, for example, the fol-
lowing code would normally nd users with the name \Bob,"
but it returns a symbolic expression representing the query
under our redenition of ActiveRecord.
User. nd :name => " Bob"
)Exp[User, [Exp(query, [name = >" Bob" ])]]
Rendering. The Rails renderer evaluates a template |
which contains both HTML and Ruby expressions|to pro-
duce an HTML string. Space wraps the Rails rendering
API, recording the symbolic objects referenced during eval-
uation of the Ruby expressions contained in the template.
This strategy allows the existing renderer to run unchanged,
which is valuable because Rails developers often replace the
standard Rails renderer with other versions.
4.3 Constraint Specializer
Using the user-provided mapping from application resources
to role-based access control objects, the constraint special-
izer substitutes one for the other in each exposure's con-
straints and translates the result into the Alloy language.
User-provided Mapping. As in the example in Section 2,
the user provides the mapping between application resources
952and role-based access control objects using a Space -provided
embedded domain-specic language. The mapping speci-
cation is written according to this grammar:
<map spec>::= <Clause >
<Clause >::= <Resource >:<Object >
j<Resource >:<Object >(<FMap >)
<FMap >::= <FieldName >:<MapRelation >
where Resource is the set of resource names in the appli-
cation under analysis, Object is the set of object names in
the role-based access control model, FieldName is the set
of resource eld names dened by the application code, and
MapRelation is the set of relation names dened by our se-
curity patterns (in section 3.4).
Resource/Object Substitution. As in Section 3.5, the
specializer replaces all references to names in the Resource
set with references to their corresponding RBAC objects in
Object. A eld reference r.fis replaced by a reference to one
of the relations dened by our patterns using the mapping
from FieldName toMapRelation (if one is present). Some
eld references are not security-related; since no mapping is
provided, the specializer leaves these unchanged.
Translation to Alloy. Finally, the specializer translates
the substituted constraints into Alloy for comparison to the
security pattern models. Since Alloy is based on rst-order
relational logic, this translation is straightforward.
4.4 Bounded VeriÔ¨Åcation
Alloy [17] is a specication language based on rst-order re-
lational logic with transitive closure. Space uses Alloy to
represent both the complete pattern catalog and the spe-
cialized constraints derived from an application's exposures.
Due to the kinds of quantier alternation present in our pat-
tern catalog, analysis of rst-order formulas is required, and
soSpace 's verication task is not decidable. Unbounded
tools such as SMT solvers are therefore less suited than a
bounded verier like Alloy. As detailed in Section 5.4, our
experience suggests that Alloy's analysis is a good t for the
kinds of bugs Space is designed to nd: it scales well to
the bounds required to nd the bugs we discovered in our
experiments.
We model web applications, role-based access control, and
our security pattern catalog in Alloy after the formal descrip-
tion given in Section 3. Each pattern consists of a set of Al-
loy constraints on RBAC objects. The patterns that dene
new subsets of the set of RBAC objects are modeled Alloy's
extends keyword, and the relations dened by the pattern
catalog are represented using Alloy's global relations.
Space uses the Alloy Analyzer to compare the specialized
constraints to the security pattern models and nd bugs.
The Alloy Analyzer is a tool for automatic bounded analysis
of Alloy specications; it places nite bounds on the number
of each type of atom present in the universe, then reduces
the specication to propositional logic.
Space builds a single Alloy specication containing the
model of role-based access control, the denitions of secu-
rity patterns, and for each exposure, an Operation denition
and a predicate imposing its specialized constraints. Finally,
Space invokes the Analyzer to check that each operation
predicate is implied by the pattern catalog.
4.5 Limitations
Space 's analysis sacrices soundness for compatibility and
scalability, and is therefore capable of analyzing real-worldapplications. This compromise leads to several limitations:
Dynamic environment changes. No static analysis can
provide guarantees about a Ruby program without making
assumptions about the environment, since Ruby allows re-
placing any method's implementation at any time. Space
assumes that the environment at analysis time is the same
as in production.
Unexpected API calls. Space detects only information
owing from ActiveRecord calls to rendered pages. It there-
fore misses leaks through native code, direct network con-
nections, or non-ActiveRecord data sources. Space relies on
the application developer to ensure that these mechanisms
do not introduce security bugs.
Bugs outside the nite bound. Space uses a bounded
model nder to nd violations of its pattern library. If the
counterexample exposing a bug contains a large number of
objects, the model nder may not be able to represent it
within its nite bound. In this situation, the model nder
may report no bugs even when one exists. In practice, all of
the bugs we encountered require only a handful of objects
to represent a counterexample.
5 Evaluation
In evaluating Space , we examined three questions:
IsSpace eective at nding bugs? We applied Space to
the 50 most watched open-source Ruby on Rails applications
on Github. 30 of those implement access control; Space
found bugs in 8 (a total of 23 bugs). Space reported 10
false positives in addition to these actual bugs. These results
suggest that Space is eective at nding security bugs and
does not produce excessive false positives.
Does Space 's analysis scale to real-world applica-
tions? We recorded analysis times for the 30 analyses per-
formed in the experiment above; every analysis nished within
64 seconds, and the average time was 38 seconds. We also
tested Space 's symbolic execution step on the 1000 most
watched Rails applications on Github; every execution n-
ished within one minute. These results suggest that Space 's
symbolic evaluator scales to applications of many sizes.
How does the bound selected for verication aect
the number of bugs found and the scalability of the
analysis? For the bugs found in the experiment described
above, we re-ran the bounded verication step at progres-
sively lower nite bounds until the verier no longer detected
the bug. A nite bound of 3 was sucient to nd these bugs;
Space uses a bound of 8 (thus considering 8 objects of each
type) by default|a bound well in excess of that required to
nd the bugs we discovered. For a bound of 8, the veri-
cation step nished in under 10 seconds for all applications.
These results suggest that Space 's default bound of 8 scales
well and is large enough to catch most bugs.
5.1 Experimental Setup
We considered the 50 most-watched open-source Ruby on
Rails applications hosted by Github, assuming that the num-
ber of \watchers" a repository has is proportional to its pop-
ularity. These applications fall into two categories: applica-
tions intended for installation by end-users and fragments of
example code intended to help programmers build new ap-
plications. Security bugs are a serious issue in both types of
application: in end-user applications, they make user data
vulnerable, while in example code, they can propagate to
953Exposure Veri- Finite
Author / Application LOC Expo- Generation cation Bugs False Bound
sures Time Time Found Positives Required
RailsApps/rails3-bootstrap-devise-... 1103 16 45.02 s 7.66 s 0 0 -
nov/fb graph sample 655 87 41.13 s 8.31 s 2 1 2
tors/jquery-leupload-rails-paperclip... 727 15 28.71 s 7.11 s 0 0 -
heartsentwined/ember-auth-rails-demo 742 28 28.94 s 6.48 s 0 0 -
kagemusha/ember-rails-devise-demo 619 24 29.84 s 3.25 s 0 0 -
openbookie/sportbook 3568 94 49.67 s 7.16 s 4 0 3
shageman/rails container andengines 778 39 23.94 s 7.20 s 0 3 -
OpenFibers/TOT2 1470 54 34.07 s 5.21 s 2 0 2
Eric-Guo/bootstrap-rails-startup-site 389 17 41.00 s 4.72 s 0 0 -
IcaliaLabs/furatto-rails-start-kit 293 16 44.69 s 4.95 s 0 1 -
ngauthier/postgis-on-rails-example 206 22 21.56 s 4.14 s 0 0 -
johnbender/jqm-rails 340 43 24.66 s 3.84 s 3 0 2
GAFuller/rails-4-landing 800 21 41.67 s 3.09 s 0 0 -
netxph/redport 142 9 22.68 s 3.73 s 0 2 -
PaulL1/league-tutorial 833 31 22.50 s 3.14 s 0 0 -
jwhitley/requirejs-rails-jasmine-... 197 11 23.36 s 8.17 s 0 0 -
danneu/grinch 1059 24 32.27 s 5.44 s 0 0 -
phaedryx/rails-angularjs-example 423 17 23.31 s 8.18 s 0 0 -
brobertsaz/railscrm-advanced 2373 132 59.75 s 4.63 s 5 0 3
Ask11/dreamy 243 13 22.14 s 8.84 s 0 1 -
m1k3/tada-ember 200 8 26.60 s 6.67 s 0 0 -
tomgrim/ribbit 473 41 24.53 s 3.35 s 2 0 2
myitcv/test-signet-rails 282 20 27.05 s 4.51 s 0 0 -
hjhart/yelp 1077 48 21.78 s 6.55 s 0 1 -
geraldb/world.db.admin 866 63 27.95 s 7.22 s 0 0 -
seankwon/MediumClone 797 46 38.43 s 3.43 s 4 0 2
yakko/permissions 523 58 22.82 s 7.82 s 0 0 -
theef/rails-devise-backbone-auth 296 14 26.19 s 7.69 s 0 1 -
asterite/geochat-rails 9596 89 49.32 s 3.99 s 0 0 -
OAGr/rails-api-authentication 1003 51 32.22 s 4.56 s 1 0 2
Figure 4: Results of Running Space on Access Control-Enabled Open-Source Rails Applications on Github
applications that have copied the code.
Selecting Applications. We used the Github Archive
database4to make a list of the most-watched Rails-associated
repositories. We developed a Ruby script to automatically
clone each repository in the resulting list, check that it con-
tains a Rails application, install its dependencies, and run
the application. We used this script to lter the original list
of 4000 repositories down to the 1000 most-watched reposi-
tories containing actual Rails applications. We used the rst
50 of these to perform our bug-nding experiments, and the
full list of 1000 applications for our scalability tests.
Building Mappings. We rst eliminated those applica-
tions with no access control through manual inspection, leav-
ing 30 applications with some access control checks. For
each of these, we constructed a mapping from application
resources to RBAC types as detailed in section 3. We used
application documentation and the code itself as a guide; in
most cases, it was a straightforward process, involving map-
ping the \User" type to RBAC users, a \Permission" type to
permission objects, a subset of resources to owned objects,
and perhaps a role type to role objects. This process took
us approximately 15 to 25 minutes per application.
Experimental Setup. We used Ubuntu GNU/Linux on
a virtual machine equipped with a single Intel Xeon core
at 2.5GHz and 2GB of RAM. We used RVM to install the
4https://www.githubarchive.org/version of Ruby required by each application and Bundler
to install each application's dependencies. We ran Space on
each application using its default nite bound of 8 (atoms
per data type) for the verication step. After running the
experiment, we examined each reported bug and classied
it as either a duplicate, a false positive, or a real bug.
Limitations. The 50 applications we considered contained
a number of abandoned and \toy" projects that likely have
few real-world users. Our experimental design|sorting ap-
plications by number of watchers|was an attempt to miti-
gate this factor in an objective way; we speculate that a large
number of real-world Rails codebases are not open source,
causing a bias in open-source applications towards example
and toy projects.
5.2 Bug Finding
The results of the experiment are summarized in Figure 4.
In total, Space reported 23 bugs and 10 false positives. The
longest analysis took 64 seconds, while the average time was
38 seconds. In most cases, the symbolic execution step (gen-
erating exposures) took most of the time.
Bugs Found. Figure 5 classies the 23 bugs we found ac-
cording to the pattern we believe the programmer intended
to implement. The largest category is Authentication, indi-
cating that the check programmers forget most often is the
one ensuring that the user is logged in. The next largest,
Ownership and Explicit Permission, indicate situations in
954No. Bugs Pattern Violated
5 Ownership
2 Public Objects
10 Authentication
3 Explicit Permission
3 User Proles
Figure 5: Classication of Bugs Found by Pattern
Violated
which a user is allowed to view or modify a resource owned
by someone else without permission. The User Proles cat-
egory includes situations where a user can modify another
user's prole, and the Public Objects category includes bugs
where a resource was marked public when it should not have
been. We did not nd any bugs violating the Administrator
or Explicit Roles patterns; developers, it seems, tend to use
these patterns correctly.
The vast majority of vulnerabilities we discovered fell out-
side the standard use cases of the applications. To exploit
these, an attacker must craft a URL or form submission
manually; exposing the bug using the application's exposed
user interface is impossible. This is the kind of security bug
that is dicult to detect using testing, because the program-
mer writing the test cases is biased towards the standard use
cases of the application, and often ignores access paths out-
side of those use cases.
False Positives. In our experiment, Space produced a
total of 10 false positives. All of these were situations in
which the application exposed a particular eld of a resource
in a dierent way from the other elds of that resource. For
example, the redport photo manager allows users to provide
\feedback" on a photo that another user owns, but does not
allow changing any of that photo's other elds. Because
Space maps whole resource types to RBAC objects, it does
not allow per-eld permissions to be specied.
However, this limitation is not inherent in our approach|
it is a conscious decision to make the resource mapping easier
to construct. A ner-grained mapping would eliminate these
false positives, but would require more eort to construct.
False Negatives. The possibility of false negatives isin-
herent to our approach: our security patterns are intended
to capture common use cases of web applications, but some
applications may intend to implement a security policy that
ismore restrictive than the common cases expressed by our
patterns. A mistake in such an implementation would not
be caught by our technique.
For example, an e-commerce web site may implement ad-
ministrative access, but may disallow even administrators
from viewing customers' saved credit card numbers. Our
catalog, on the other hand, includes a pattern allowing ad-
ministrators to view everything. Space would therefore miss
a bug allowing administrators to view card numbers, since
the intended policy is actually more restrictive than the pat-
tern in our catalog.
We examined the code of the applications in our experi-
ment for precisely this situation|security policies intended
(based on evidence in the code itself) to be more restrictive
than the corresponding patterns in our catalog|and found
none. Given the correct user-provided mapping, the pat-
terns applied by Space were always at least as restrictive
515253545
1 10 100 1000 10000 100000
Exposure Generation Time (s)
Application Source Lines of CodeFigure 6: Scalability of Exposure Generation: Gen-
eration time vs application lines of code for 1000
applications
0150300450600
123456789101112131415
VeriÔ¨Åcation Time (s)
Finite Bound Setting
Figure 7: Eect of Finite Bound on Verication
Time
as those enforced by the target applications. However, the
number of applications we considered was limited: we do
not consider this enough evidence to conclude that security
policies are generally less restrictive than our patterns.
5.3 Scalability
Since exposure generation time dominates verication time,
we performed an additional experiment to test the scalability
of the exposure generator more thoroughly. We ran the ex-
posure generation step only on the 1000 most-watched Rails
applications on Github. Figure 6 plots exposure generation
time against lines of source code for each of these applica-
tions. Exposure generation nished within one minute for
every application, with most taking much less time.
5.4 Choice of Finite Bounds
Space uses the Alloy Analyzer, which requires the user to
place nite bounds on the number of objects it will consider.
Since these bounds both scalability and bugs found (because
bugs requiring a counterexample larger than the nite bound
will be missed), choosing the default bound carefully is vi-
tal. We ran the verication step against the applications in
Figure 4 using nite bound settings from 3 to 15. The re-
sults, in Figure 7, indicate that the verication step runs in
an acceptable time at nite bound settings below 10. Above
that bound, the verication time grows quickly.
We chose the default bound of 8 based on these perfor-
955mance results and the counterexample sizes required for the
bugs we discovered. Bugs may exist beyond this bound, but
the distribution of bounds required to nd the bugs we dis-
covered (100% of bugs with bound 3, and 0% of bugs from
bounds 3-15) suggests that more bugs have small counterex-
amples than have large ones. Users of Space can easily select
a dierent bound in order to tune the verier.
6 Related Work
Modeling Security Patterns. Conceptually, our cata-
log of security patterns is similar to the built-in specica-
tions of common bugs that static analysis tools have used for
decades: memory errors, race conditions, non-termination,
null pointer exceptions, and so on. Like Space , tools that
attempt to nd these classes of bugs can run without user
input. However, these specications represent a blacklist|
a model of situations that should notoccur|in contrast to
our catalog of patterns, which whitelist only those situa-
tions that should occur. Our pattern catalog is similar in
approach to the formal model of web security by Akhawe et
al. [1], which denes a general model of the actors (browsers,
servers, attackers etc.), and threats (XSS, CSRF, etc.) in-
volved the larger picture of web security problems, then uses
a constraint solver to discover attacks that potentially in-
volve several dierent components; the model is not directly
applicable to code. Our technique, by contrast, focuses on
mistakes in access control policies, and compares the model
against the code automatically.
Symbolic Execution. Symbolic execution was rst pro-
posed by King [20] and Clarke [11] in 1976, and recent sym-
bolic evaluators [7, 18, 28, 33, 32, 16] have made improve-
ments in scalability and applicability of the idea. Symbolic
execution has also seen application to dynamic languages in
recent years, with systems for evaluating Javascript [32, 13,
32], PHP [2, 19], Python [31], and Ruby [9]. In contrast to
Space , all of these use standalone symbolic evaluators.
Other recent eorts implement symbolic execution as a
library, like Space . NICE-PySE [8] and Commuter [12]
both implement library-based symbolic execution in Python,
but only for particular domain-specic languages. Yang et
al. [36] and K oskal et al. [21] use the same technique in Scala,
but to enforce security policies and perform constraint pro-
gramming, respectively. Rosette [35] uses a library to sym-
bolically execute Racket for verication and program syn-
thesis. None of these systems allow symbolic execution of
arbitrary programs, however.
Chef [5] produces symbolic evaluators for interpreted lan-
guages by symbolically executing the standard interpreter
itself on the target program. Like our approach, Chef re-
sults in a system that is 100% compatible with the standard
interpreter; however, the indirection of symbolically execut-
ing the interpreter incurs signicant overhead (at least 5x
over NICE-PySE [8], which is implemented like Space ).
Static Analysis of Web Applications. Existing work
on the application of static analysis to web applications fo-
cuses on modeling applications, and especially on building
navigation models. Bordbar and Anastasakis [4], for exam-
ple, model a user's interaction with a web application using
UML, and perform bounded verication of properties of that
interaction by translating the UML model into Alloy using
UML2Alloy; other approaches ([22, 34, 29]) perform similar
tasks but provide less automation. Nijjar and Bultan [27]translate Rails data models into Alloy to nd inconsistencies,
but do not examine controller code. Boci c and Bultan [3]
and Near and Jackson [24] check Rails code, but require the
user to write a specication. Space , in contrast, requires
only that the programmer provide a simple object mapping.
Techniques that do not require the programmer to build
a model of the application tend to focus on the elimina-
tion of a certain class of bugs, rather than on full verica-
tion. Chlipala's Ur/Web [10] statically veries user-dened
security properties of web applications, and Chaudhuri and
Foster [9] verify the absence of some particular security vul-
nerabilities for Rails applications; unlike Space , neither ap-
proach can nd application-specic bugs. Derailer [25] can
nd application-specic bugs but lacks Space 's automation:
it requires the user to interact with the tool to discover bugs.
Run-Time Approaches to Web Application Security.
Resin [37] is a runtime system that enforces information ow
policies attached to data objects; it has been successfully ap-
plied to web applications. Jeeves [36], a similar language for
enforcing information ow policies, has also been applied
to the web. Jif [23], an extension of Java, also supports
checking policies at runtime. GuardRails [6] allows the pro-
grammer to annotate ActiveRecord classes with access con-
trol information, then performs source-to-source translation
of the application's implementation, producing a version of
the application that enforces, at run time, the access con-
trol policies specied by the annotations. Nemesis [14] is a
similar eort for PHP applications: it is a tag-based system
that enforces authentication and access-control at runtime.
All of these approaches, in contrast to Space , require the
programmer to write some form of specication to encode
the application's security policy.
7 Conclusion
In this project, we explored the idea that a small set of
formal models|our catalog of access control patterns|is
enough to capture a large portion of the access control poli-
cies that web applications use in practice. We have presented
a technique leveraging this idea to nd security bugs in web
applications, based on checking that if the application allows
some data to be exposed, then some pattern in the catalog
must also allow it. To be eective, this approach relies on
the premise that real-world web applications share common
patterns of access control.
Our implementation, Space , demonstrates that our cat-
alog of patterns, plus a mapping from application types to
the types of the catalog, is sucient to nd bugs in real-
world applications automatically. The results of our evalua-
tion indicate that this approach is eective: Space scales to
large applications, produces few false positives, and found a
signicant number of previously unknown bugs, suggesting
that our pattern-based approach is a promising strategy for
eliminating application-specic security bugs.
Acknowledgements
We are grateful to the anonymous reviewers for their in-
sightful comments. We also thank Eunsuk Kang, Aleksan-
dar Milicevic, and Jean Yang for their helpful discussions.
This research was funded in part by the National Science
Foundation under grant 0707612 (CRI: CRD - Development
of Alloy Tools, Technology and Materials)
9568 References
[1] Devdatta Akhawe, Adam Barth, Peifung E Lam, John
Mitchell, and Dawn Song. Towards a formal
foundation of web security. In Computer Security
Foundations Symposium (CSF), 2010 23rd IEEE ,
pages 290{304. IEEE, 2010.
[2] Shay Artzi, Adam Kiezun, Julian Dolby, Frank Tip,
Danny Dig, Amit Paradkar, and Michael D Ernst.
Finding bugs in dynamic web applications. In
Proceedings of the 2008 international symposium on
Software testing and analysis , pages 261{272. ACM,
2008.
[3] Ivan Boci c and Tevk Bultan. Inductive verication of
data model invariants for web applications. In
Proceedings of the 36th International Conference on
Software Engineering, pages 620{631. ACM, 2014.
[4] B. Bordbar and K. Anastasakis. Mda and analysis of
web applications. Trends in Enterprise Application
Architecture, pages 44{55, 2006.
[5] Stefan Bucur, Johannes Kinder, and George Candea.
Prototyping symbolic execution engines for
interpreted languages. In Proceedings of the 19th
international conference on Architectural support for
programming languages and operating systems , pages
239{254. ACM, 2014.
[6] J. Burket, P. Mutchler, M. Weaver, M. Zaveri, and
D. Evans. Guardrails: a data-centric web application
security framework. In Proceedings of the 2nd
USENIX conference on Web application development,
pages 1{1. USENIX Association, 2011.
[7] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted
and automatic generation of high-coverage tests for
complex systems programs. In Proceedings of the 8th
USENIX conference on Operating systems design and
implementation , pages 209{224. USENIX Association,
2008.
[8] Marco Canini, Daniele Venzano, Peter Peresini, Dejan
Kostic, Jennifer Rexford, et al. A nice way to test
openow applications. In NSDI , volume 12, pages
127{140, 2012.
[9] A. Chaudhuri and J.S. Foster. Symbolic security
analysis of ruby-on-rails web applications. In
Proceedings of the 17th ACM conference on Computer
and communications security , pages 585{594. ACM,
2010.
[10] A. Chlipala. Static checking of dynamically-varying
security policies in database-backed applications. In
Proceedings of the 9th USENIX conference on
Operating systems design and implementation , page 1.
USENIX Association, 2010.
[11] L.A. Clarke. A system to generate test data and
symbolically execute programs. Software Engineering,
IEEE Transactions on , (3):215{222, 1976.
[12] Austin T Clements, M Frans Kaashoek, Nickolai
Zeldovich, Robert T Morris, and Eddie Kohler. The
scalable commutativity rule: Designing scalable
software for multicore processors. ACM Transactions
on Computer Systems (TOCS) , 32(4):10, 2015.
[13] Charlie Curtsinger, Benjamin Livshits, Benjamin G.
Zorn, and Christian Seifert. Zozzle: Fast and precise
in-browser javascript malware detection. In USENIXSecurity Symposium . USENIX Association, 2011.
[14] M. Dalton, C. Kozyrakis, and N. Zeldovich. Nemesis:
preventing authentication & access control
vulnerabilities in web applications. In Proceedings of
the 18th conference on USENIX security symposium ,
pages 267{282. USENIX Association, 2009.
[15] David F Ferraiolo, Ravi Sandhu, Serban Gavrila,
D Richard Kuhn, and Ramaswamy Chandramouli.
Proposed nist standard for role-based access control.
ACM Transactions on Information and System
Security (TISSEC) , 4(3):224{274, 2001.
[16] Patrice Godefroid, Michael Y. Levin, and David A.
Molnar. Automated whitebox fuzz testing. In NDSS.
The Internet Society, 2008.
[17] D. Jackson. Software Abstractions: logic, language,
and analysis . The MIT Press, 2006.
[18] S. Khurshid, C. P as areanu, and W. Visser.
Generalized symbolic execution for model checking
and testing. Tools and Algorithms for the Construction
and Analysis of Systems , pages 553{568, 2003.
[19] Adam Kieyzun, Philip J Guo, Karthick Jayaraman,
and Michael D Ernst. Automatic creation of sql
injection and cross-site scripting attacks. In Software
Engineering, 2009. ICSE 2009. IEEE 31st
International Conference on , pages 199{209. IEEE,
2009.
[20] J.C. King. Symbolic execution and program testing.
Communications of the ACM , 19(7):385{394, 1976.
[21] Ali Sinan K oksal, Viktor Kuncak, and Philippe Suter.
Constraints as control. In John Field and Michael
Hicks, editors, POPL , pages 151{164. ACM, 2012.
[22] DR Licata and S. Krishnamurthi. Verifying interactive
web programs. In Automated Software Engineering,
2004. Proceedings. 19th International Conference on ,
pages 164{173. IEEE.
[23] A.C. Myers, L. Zheng, S. Zdancewic, S. Chong, and
N. Nystrom. Jif: Java information ow. Software
release. Located at http://www. cs. cornell. edu/jif ,
2005, 2001.
[24] Joseph P Near and Daniel Jackson. Rubicon: bounded
verication of web applications. In Proceedings of the
ACM SIGSOFT 20th International Symposium on the
Foundations of Software Engineering , page 60. ACM,
2012.
[25] Joseph P Near and Daniel Jackson. Derailer:
interactive security analysis for web applications. In
Proceedings of the 29th ACM/IEEE international
conference on Automated software engineering, pages
587{598. ACM, 2014.
[26] Joseph P. Near and Daniel Jackson. Symbolic
execution for (almost) free: Hijacking an existing
implementation to perform symbolic execution.
Technical Report MIT-CSAIL-TR-2014-007,
Computer Science and Articial Intelligence Lab,
Massachusetts Institute of Technology, Cambridge,
Massachusetts, April 2014.
[27] Jaideep Nijjar and Tevk Bultan. Bounded
verication of ruby on rails data models. In
Matthew B. Dwyer and Frank Tip, editors, ISSTA ,
pages 67{77. ACM, 2011.
[28] C. Pasareanu and W. Visser. Verication of java
programs using symbolic execution and invariant
957generation. Model Checking Software , pages 164{181,
2004.
[29] Filippo Ricca and Paolo Tonella. Analysis and testing
of web applications. In Hausi A. M uller, Mary Jean
Harrold, and Wilhelm Sch afer, editors, ICSE, pages
25{34. IEEE Computer Society, 2001.
[30] Ravi S Sandhu, Edward J Coyne, Hal L Feinstein, and
Charles E Youman. Role-based access control models.
Computer , 29(2):38{47, 1996.
[31] Samir Sapra, Marius Minea, Sagar Chaki, Arie
Gurnkel, and Edmund M Clarke. Finding errors in
python programs using dynamic symbolic execution.
InTesting Software and Systems , pages 283{289.
Springer, 2013.
[32] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
S. McCamant, and D. Song. A symbolic execution
framework for javascript. In Security and Privacy
(SP), 2010 IEEE Symposium on , pages 513{528.
IEEE, 2010.
[33] Koushik Sen, Darko Marinov, and Gul Agha. Cute: a
concolic unit testing engine for c. In Michel
Wermelinger and Harald Gall, editors,
ESEC/SIGSOFT FSE , pages 263{272. ACM, 2005.
[34] P. Tonella and F. Ricca. Dynamic model extraction
and statistical analysis of web applications. 2002.
[35] Emina Torlak and Rastislav Bodik. A lightweight
symbolic virtual machine for solver-aided host
languages. In Proceedings of the 35th ACM SIGPLAN
Conference on Programming Language Design and
Implementation, page 54. ACM, 2014.
[36] Jean Yang, Kuat Yessenov, and Armando
Solar-Lezama. A language for automatically enforcing
privacy policies. pages 85{96, 2012.
[37] A. Yip, X. Wang, N. Zeldovich, and M.F. Kaashoek.
Improving application security with data ow
assertions. In Proceedings of the ACM SIGOPS 22nd
symposium on Operating systems principles , pages
291{304. ACM, 2009.
958