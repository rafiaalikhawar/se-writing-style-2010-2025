SuperMod: Tool Support for Collaborative Filtered
Model-Driven Software Product Line Engineering
Felix Schw√§gerl
Applied Computer Science I
University of Bayreuth
95440 Bayreuth, Germany
felix.schwaegerl@uni-bayreuth.deBernhard Westfechtel
Applied Computer Science I
University of Bayreuth
95440 Bayreuth, Germany
bernhard.westfechtel@uni-bayreuth.de
ABSTRACT
The increase in productivity implied by model-driven soft-
ware product line engineering is weakened by the complex-
ity exposed to the user having to manage a multi-variant
model. Recently, a new paradigm has emerged: ltered
software product line engineering transfers the established
check-out/modify/commit workow from version control to
variability management, allowing to iteratively develop the
multi-variant model in a single-variant view. This paper
demonstrates SuperMod , a tool that supports collaborative
ltered model-driven product line engineering, implemented
for and with the Eclipse Modeling Framework. Concerning
variability management, the tool oers capabilities for editing
feature models and specifying feature congurations, both
being well-known formalisms in product line engineering. Fur-
thermore, collaborative editing of product lines is provided
through distributed version control. The accompanying video
shows that SuperMod seamlessly integrates into existing tool
landscapes, reduces the complexity of multi-variant editing,
automates a large part of variability management, and en-
sures consistency. A tool demonstration video is available
here: http://youtu.be/5XOk3x5kjFc
CCS Concepts
Software and its engineering √ëSoftware conguration
management and version control systems; Software mainte-
nance tools;
Keywords
Model-driven software engineering, software product line
engineering, version control, ltered editing
1. INTRODUCTION
Software product line engineering (SPLE) [11] exploits
commonalities and dierences of related software products
in order to achieve organized reuse. From a multi-variant
platform , specic products having exactly the functionalproperties desired by a customer may be derived on demand
(mass customization ). In the last decade, SPLE was com-
bined with model-driven software engineering (MDSE) [5].
In addition to the variability model, both the platform and
specic products are represented as well-dened models.
Tools and approaches to model-driven software product
line engineering (MDPLE) can be distinguished as follows:
Positive variability is realized by extending a small core,
realizing only the commonalities of product line members,
with feature-specic parts. Often, model transformations
[22] are applied to compose products. Negative variability
means that from a multi-variant domain model, realizing all
features at a time, those parts are ltered out which are not
relevant for specic products. Typically, this has been real-
ized by preprocessor-like tools [8]. While positive variability
suers from requiring specialized transformation languages
in addition to the domain language, negative variability im-
pedes MDPLE due to the architectural complexity of the
multi-variant domain model [14].
The tool SuperMod presented in this paper internally re-
lies on negative variability, but reduces the aforementioned
complexity by having the user working in a single-variant
workspace, i.e., in one product representatively. The tool fol-
lows the paradigm of ltered MDPLE , adopting the iterative
check-out/modify/commit workow known from version con-
trol systems [13]. It has been implemented [14] for and with
theEclipse Modeling Framework (EMF) [18]. The variability
model is represented as a feature model [7], an established
formalism in SPLE. The specic variant to be edited and the
set of variants to which the change applies are described by
feature congurations , which resolve the variability dened
in the feature model.
SuperMod addresses two groups of users: rst, software
product line engineers who consider their productivity to
be limited by the aforementioned disadvantages of positive
or negative variability. Second, the tool may be used as
an ordinary version control system that oers variant man-
agement capabilities in addition. SuperMod's functionality
goes far beyond branches, which are typically oered for this
purpose [2, 3]. An agile style of product line engineering is
encouraged by an iterative and incremental editing model
[15]. Therefore, the tool suits product lines in which the
variability model may evolve during product development.
Subsequently, we explain ltered MDPLE . In Section 3,
the tool SuperMod and its functionalities are presented. Sec-
tion 4 recapitulates SuperMod's distinguishing properties
demonstrated by the tool video. Section 5 compares Super-
Mod with related tools, before the paper is concluded.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970288
822
1. check -out
2. modify
3. commit
Repository
RepositoryCHOICE
AMBITION
Figure 1: A sketch of ltered MDPLE.
2. FILTERED MODEL-DRIVEN PRODUCT
LINE ENGINEERING
The paradigm of ltered software product line engineering
emerged recently [6, 8, 14, 20] and oers dierent \avors"
such as partially ltered editing (cf. Section 5). In this
section, we characterize our representative of totally ltered
editing ;SuperMod combines ltered SPLE with model-driven
engineering and version control [13].
As shown in Figure 1, the editing model resembles version
control. An iteration consists of three steps: First, a ver-
sion to be edited is checked-out from a repository into the
workspace using a two-stage selection process. In addition to
version control, where a specic revision is selected, a choice
(i.e., a product variant) is dened in the form of a feature
conguration , which assigns a selection state (selected or
deselected) to each feature. Second, the checked-out version
may be modied using arbitrary modeling tools. In addition,
the feature model itself is made available for modication.
Third, the performed modications are written back to the
repository. They typically aect a broader set of product
variants than only the choice; this set is specied by the user
as the ambition , a feature conguration where features to
which the modications are immaterial may be left unbound.
During commit, the contents of the repository are updated
automatically; inserted (deleted) elements become visible
(invisible) for variants included in the ambition.
Let us reconsider Figure 1 at a greater level of detail. The
illustrated iteration refers to a product line of metamodels
for graphs [10, 14] having optional features such as weighted ,directed , orcolored . The metamodel is represented as a UML
class diagram. During check-out , aweighted and directed
variant is chosen, such that the workspace is populated with
a class diagram that includes, among others, the attribute
weight . During modify , both the feature colored and its
realization (the class Color , including an association to Vertex )
are dened in the feature model (not shown) and in the
product variant, respectively. In the subsequent commit ,
the change is associated only with the new feature colored ,
while all other features remain unbound (neither selected nor
deselected) in the specied ambition .
This conceptual overview has highlighted the role of tool
support in our approach. The user interacts with Super-
Mod for editing the variability model during modify , and for
variant selection (i.e., choice /ambition specication) during
check-out and commit . While evolving the product during
the respective development iterations, the user is not occu-
pied with architectural decisions involving variability (such
as modeling variation points and variants explicitly in the
platform [11]), but he/she may concentrate on the variant
provided in the workspace. Thus, SuperMod behaves as
non-disruptively as an ordinary version control system, while
oering a much higher degree of automation concerning vari-
ability management. Furthermore, the distinction between
domain engineering , where the platform is developed, and ap-
plication engineering , where specic products are customized,
is blurred intentionally.
3. TOOL FUNCTIONALITIES
This section provides a functionally organized tool de-
scription. In the respective subsections, the provided user
interface (UI) commands are described one after another.
As shown in Figure 2, the commands have been integrated
into a context menu, which has been implemented as an
Eclipse team provider extension1. SuperMod is available
as a modular set of Eclipse plug-ins on the update site:2.
When running in multi-user mode, SuperMod requires a
server application, which may be installed as Tomcat servlet
using the following web archive:3.
Figure 2: SuperMod's team context menu.
3.1 Workspace Management
The workspace presents the currently selected product
variant described by the choice, represented as Eclipse project.
1http://eclipse.org
2http://btn1x4.inf.uni-bayreuth.de/supermod/update
3http://btn1x4.inf.uni-bayreuth.de/supermod/webapp/
supermod-server.war
823Figure 3: The Eclipse project explorer with an ac-
tive SuperMod project.
SuperMod imposes only few restrictions on the versioned
products; they may consist of arbitrary EMF model resources
or plain text les. For our purely state-based approach, no
tool extensions are required to be supported by SuperMod.
Transparently, all versioning metadata are stored in a hidden
folder .supermod .
A non-versioned Eclipse project may be put under version
control using the UI command Share . As in ordinary ver-
sion control systems, individual folders and les may then
be added to or removed from version control | see corre-
sponding UI commands in Figure 2. In case the user has
not decided on whether a le is to be versioned, a dialog is
shown in the beginning of commit , where the user may select
(deselect) les to be added to (removed from) version control.
The UI command Disconnect removes all local version control
metadata and retains only the current variant of the project
in the local workspace.
For a better overview, the active choice is presented in a
condensed textual form in the project explorer next to the
project name. Furthermore, in case an ambition is reserved
(see below), it is also displayed here. Figure 3 shows an
example corresponding to the iteration from Figure 1.
3.2 Feature Model Editor
Conceptually, the feature model is part of the workspace,
yet physically hidden in the metadata folder .supermod .
For its editing, a dedicated UI command Edit Version
Space is provided (see Figure 2). Once selected, the feature
model editor (cf. screenshot in Figure 4) is opened. Here,
features may be added or removed, toggled mandatory (lled
circle) or optional (empty circle), or renamed. Furthermore,
the tree structure may be modied arbitrarily, and feature
groups andrequires/excludes constraints [13] may be specied.
EMF Validation [18] ensures that the feature model remains
satisable, e.g., that there exist no contradicting requires
and excludes constraints.
3.3 Check-out, Update, and Commit
A typical development iteration is embraced by the com-
mands check-out and commit . As shown in Figure 2, UI
commands are provided for both operations. This subsection
Figure 4: The feature model editor.considers the \straightforward" workow, where the choice is
specied during check-out and the ambition during commit.
However, the user may deviate from this by using one of the
specialized commands presented subsequently.
Having executed the command Check-Out , the user is asked
to dene a version of the product to populate the workspace.
Since both the primary product and the feature model are
subject to historical version control, a revision must be se-
lected rst (cf. left hand part of Figure 5; column Scope
displays the ambition used for the respective commit). Then,
the selected revision of the feature model is presented to the
user, who must then specify a feature conguration binding
all visible features to either true (cyan) or false (orange
symbols in the right hand part of Figure 5). The feature con-
guration specication dialog also ensures that the selected
conguration is consistent according to all constraints de-
ned in the feature model (e.g., mandatory features must be
selected). The inconsistency reported in the gure is caused
by none of the features undirected anddirected located in an
XOR group being selected.
Figure 5: Dialogs for revision and feature congura-
tion selection shown during check-out.
Figure 6: Dialogs for commit message and feature
ambition selection shown during commit.
Technically, the UI command Update specializes Check-Out
in a non-interactive way. In the revision graph, the latest
revision is selected; in the feature model, the current choice
is retained.
The UI command Commit terminates an iteration and
prompts the user for an ambition that delineates the set of
versions for which the change, representatively applied in
the version described by the choice , is intended. As usual in
version control, a new revision is introduced transparently.
The user is only asked for a commit message (see left hand
part of Figure 6). Thereafter, the feature ambition spec-
ication dialog appears (right hand part). In addition to
824true and false, the value unbound (yellow) is permitted here,
signaling that the change is immaterial to the respective
feature. Typically, few features are bound in order to aect
as many variants as possible. The dialog ensures that the
ambition is consistent and includes the previously dened
choice.
Please note that in the editing model realized by Super-
Mod, the operation check-out is optional, such that after
having committed, it is assumed that the user wants to stay
in the current variant. The choice is migrated using the
ambition transparently. Following this common assumption
from version control systems, the workow becomes even
more non-disruptive and automated.
3.4 Exporting Products
To nally deploy products to customers, the development
loop may be left by the UI command Export Project . When
referring to SPLE terms, this performs fully automated ap-
plication engineering . A revision and feature conguration
must be selected by the user; the specied version is exported
into a new Eclipse project clear of version control metadata.
3.5 Reserving and Amending Ambitions
As aforementioned, SuperMod weakens the assumption
that the choice is always specied during check-out and the
ambition during commit.
First of all, the tool may be used in a more conservative
way provided by the UI command Scope and Check-Out .
Here, both the ambition and the choice are specied already
during check-out in order to x the scope of the change as
early as possible. After selecting a revision, the ambition
selection dialog is shown rst; thereafter, the user selects
a representative choice | the validation of according con-
sistency constraints is preponed. The conservative ltered
editing model, as opposed to the agile workow presented
here, was realized by early related work [12, 21].
Second, when selecting only a choice during check-out (or
when omitting the check-out), it is still possible to reserve
an ambition at arbitrary points in time during modify . After
selecting the UI operation Scope , the ambition selection
dialog appears. Reserved ambitions are displayed in the
project explorer (cf. colored in Figure 3). During commit,
the ambition selection dialog is omitted.
Last, an erroneously specied ambition can be corrected
using the UI command Amend Previous Commit . When
selected, the ambition specication dialog shows up, where
the ambition used for the preceding iteration may be altered.
Local
RepositoryWorkspacecheck -out
commitUser A
Local
RepositoryWorkspacecheck -out
commitUser ZRemote
Repositorypull
pullpush
push
Figure 7: Distributed version control architecture.
Figure 8: Revision selection dialog in collaborative
versioning mode.
3.6 Collaboration
Being a version control system, SuperMod naturally sup-
ports collaborative development [16]. This has been realized
using the distributed architecture shown in Figure 7, which
resembles Git [2]. Each user interacts with a local repository
using the commands update and commit (see above). In
order to orchestrate multiple copies of the repository, the UI
commands PullandPush are provided, which communicate
with a central remote repository. As a consequence, orga-
nizational overhead caused by multi-user operation is not
created at each check-out or commit, but only at distinct
synchronization points dened by the user(s).
The distinction between check-out/commit and pull/push
gives rise to the distinction between private and public re-
visions, leading to a two-level revision naming scheme ( pub-
lic.private ). In multi-user mode, the revision selection dialog
shows additional details (see Figure 8). The private revision
counter is incremented after each commit. Complementarily,
when pushing, the current public revision is nalized and
a new public revision is started automatically, setting the
private revision counter to zero. The public revision counter
is organized by the remote repository unambiguously.
4. DEMONSTRATION
The accompanying demonstration video refers to the collab-
orative development of a product line of graph metamodels
[10, 14] (cf. Sections 2 and 3). Two hypothetical users,
Alice and Bob, are involved: Alice creates and initializes
the product line and develops an initial feature model and
platform using multiple iterations. In particular, the root fea-
ture Graph , its children Vertices andEdges , and the optional
features weighted ,labeled , and undirected are dened and
realized. Bob connects to the remote repository thereafter.
Alice and Bob concurrently realize dierent features using
disjoint ambitions for their commits: Bob realizes directed ;
Alice focuses on a new feature colored . Synchronization is
explicitly triggered by pulland push.
The demonstration video illustrates four important prop-
erties of SuperMod and its underlying approach.
Reuse of Preferred Editing Tools.
SuperMod integrates into existing, Eclipse-based tool land-
scapes in an unobtrusive way. For editing the domain model,
i.e., the platform, familiar single-version editing tools may be
reused without the necessity of any further tool extensions.
In our example, the protagonists employed the EMF-based
UML modeling tool Valkyrie [1].
825Reduced Complexity.
Related approaches and tools dedicated to unltered prod-
uct line engineering require to edit and maintain multi-variant
domain models in connection with presence conditions ( neg-
ative variability ), or to specify composition rules ( positive
variability ), both facing the user with a high cognitive com-
plexity. In contrast, SuperMod provides the user with a
single-version workspace, where the change may be applied
without involving multi-variant modeling decisions or model
composition languages, respectively. The reduced cognitive
complexity signicantly eases collaborative development.
E.g., the changes performed by Bob at 3120 and by Alice
at 41002are independent and integrated later (41222).
Automated Variability Management.
SuperMod internally relies on negative variability; the
repository contains a multi-variant domain model, whose
elements carry visibilities denoting in which revisions and
variants they are included [13]. Visibilities of aected ele-
ments are updated during commit transparently. By inten-
tion, neither the multi-variant domain model nor visibilities
are shown to SuperMod users. However, the user is always
aware of the current workspace version, which is displayed
next to the project root (cf. Figure 3). After each commit,
the workspace choice is migrated automatically in order to
obviate a subsequent check-out ; an example is given at 11352.
Consistency Control and Error Correction.
As outlined in Section 3.5, The functionalities of reserving
(21202) and amending ambitions (41402) allow for more exi-
bility and reduce potential sources of errors. Furthermore,
during the choice selection dialog, it is ensured that the selec-
tion is complete (31052) and complies with the rules dened
in the feature model ( 11552). Further consistency constraints,
which refer to the satisability of the feature model and to
the syntactical correctness of the product, are not subject
of this paper. Taken together, SuperMod automatically en-
sures several consistency constraints that have to be checked
manually when relying on explicit variability management
as realized by approaches to unltered SPLE.
5. RELATED TOOLS
This demonstration paper complements a series of previ-
ous publications referring to the theoretical foundations of
our approach [13], its implementation [14], the underlying
development process [15], and collaborative versioning [16].
With branches , many contemporary version control sys-
tems, e.g., Git [2], oer logical variants to a limited extent.
However, they only allow to restore variants that have been
committed earlier, but not to re-combine new variants based
on predicates similar to feature congurations.
A few software conguration management systems have
been extended with partial support for SPLE, and vice versa.
The SCM system Adele [4] has logical variants built into its
object-oriented data model as symmetric deltas, which are
exposed to the user. Temporal variability is realized by a
versioning layer on top. Conversely, in [9], an extension to
the SPLE toolchain BigLever is presented that deals with
controlling the variability of dierent diverging products. In
both approaches, however, logical and cooperative versioning
are not integrated at the same conceptual level.
The approach presented in [17] relies on explicit historicalversioning of the variability model. Both historical and logi-
cal versioning are realized upon a (directed) delta language
for EMF models, such that for each increment added to the
product line, a forward delta must be specied manually. To
derive a specic version of the product, a revision must be se-
lected for each active feature independently. In contrast, our
tool manages (symmetric) deltas transparently and removes
the necessity of specialized editing tools.
The source-code centric product line tool CIDE (Colored
IDE) [8] generalizes preprocessors using a colored represen-
tation to distinguish features. CIDE oers the possibility
to temporarily restrict a variational project to views on a
specic feature or variant. Then, irrelevant source code frag-
ments are hidden. The performed changes only aect the
selected feature or variant; choice andambition are mutually
equal. Similarly, the MDPLE tool Feature Mapper [6] pro-
vides change recording during creation of the multi-variant
domain model. All changes are associated with a feature
expression derived from the provided feature selection. How-
ever, only insertions are supported.
The product line version control system introduced in [19]
relies on change propagation at conguration level. Though,
change propagation, as opposed to state-based versioning,
requires deep integration into the toolchain. Moreover, a
solution for semi-automatic backward propagation of prod-
uct-specic changes to the product line is described. Though,
instead of connecting of updated elements to an ambition ,
manual updates in the platform are required.
SuperMod's conceptual predecessor UVM [21] supports
conservative ltered editing, where both the choice and the
ambition are specied during the mandatory check-out oper-
ation. In contrast, in our tool, the check-out is optional and
the ambition may be specied later; furthermore, in UVM,
both the product space and the version space are represented
at a low level of abstraction (plain text les and propositional
logic, respectively).
The source-code centric approach presented in [20] does
not distinguish between choice and ambition, but uses a
single lter, a projection , for both purposes. In contrast to
SuperMod, the variant available in the workspace is only
partially ltered ; variability is represented using preprocessor
directives. To the best of our knowledge, this approach has
not been implemented (yet).
6. CONCLUSION
The high cognitive complexity introduced by (model-dri-
ven) software product line engineering has given rise to a
new class of tools and approaches that apply ltered editing ;
instead of developing the platform of a software product
line as a whole, only the parts relevant for the intended
change are accessed through a lter. In this demonstration
paper, we have presented a tool that realizes totally ltered
editing , where changes are applied on one specic product
variant representatively, but the changes are propagated to a
larger set of variants. SuperMod adopts the iterative check-
out/modify/commit workow from version control systems,
making it naturally suited for collaborative SPLE.
The accompanying demonstration video shows four im-
portant properties of our tool: it seamlessly integrates into
existing tool landscapes, reduces the cognitive complexity of
multi-variant editing, automates a large extent of variability
management, and oers dedicated consistency control. These
properties have also been conrmed by a larger case study
826in the domain of home automation systems [15].
Current work focuses on a more ne-grained consistency
control and conict management in connection with Super-
Mod's multi-user mode. In addition, more standard VCS
facilities, including di,branch , orlock, will evolve the tool
to a full-edged version control system.
7. REFERENCES
[1] T. Buchmann. Valkyrie: A uml-based model-driven
environment for model-driven software engineering. In
S. Hammoudi, M. van Sinderen, and J. Cordeiro,
editors, Proceedings of the 7th International Conference
on Software Paradigm Trends (ICSOFT 2012) , pages
147{157. SCITEPRESS, July 2012.
[2] S. Chacon. Pro Git . Apress, Berkely, CA, USA, 1st
edition, 2009.
[3] B. Collins-Sussman, B. W. Fitzpatrick, and C. M.
Pilato. Version Control with Subversion . O'Reilly,
Sebastopol, CA, 2004.
[4] J. Estublier and R. Casallas. The Adele conguration
manager. In W. F. Tichy, editor, Conguration
Management , volume 2 of Trends in Software , pages
99{134. John Wiley & Sons, Chichester, UK, 1994.
[5] H. Gomaa. Designing Software Product Lines with
UML: From Use Cases to Pattern-Based Software
Architectures . Addison-Wesley, Boston, MA, 2004.
[6] F. Heidenreich, J. Kopcsek, and C. Wende.
FeatureMapper: Mapping Features to Models. In
Companion Proc. 30th International Conference on
Software Engineering (ICSE'08) , pages 943{944, New
York, NY, USA, May 2008. ACM.
[7] K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak,
and A. S. Peterson. Feature-oriented domain analysis
(FODA) feasibility study. Technical Report
CMU/SEI-90-TR-21, Carnegie-Mellon University,
Software Engineering Institute, Nov. 1990.
[8] C. K astner, S. Trujillo, and S. Apel. Visualizing
software product line variabilities in source code. In
Proc. 2nd International SPLC Workshop on
Visualisation in Software Product Line Engineering
(ViSPLE) , pages 303{313, 9 2008.
[9] C. W. Krueger. Variation management for software
production lines. In Proceedings of the Second
International Conference on Software Product Lines ,
SPLC 2, pages 37{48, London, UK, UK, 2002.
Springer-Verlag.
[10] R. E. Lopez-Herrejon and D. S. Batory. A standard
problem for evaluating product-line methodologies. In
Proc. 3rd International Conference on Generative and
Component-Based Software Engineering , GCSE '01,
pages 10{24, London, UK, 2001. Springer.
[11] K. Pohl, G. B ockle, and F. van der Linden. Software
Product Line Engineering: Foundations, Principles and
Techniques . Springer, Berlin, Germany, 2005.
[12] N. Sarnak, R. L. Bernstein, and V. Kruskal. Creation
and maintenance of multiple versions. In J. F. H.
Winkler, editor, SCM , volume 30 of Berichte des
German Chapter of the ACM , pages 264{275. Teubner,1988.
[13] F. Schw agerl, T. Buchmann, S. Uhrig, and
B. Westfechtel. Towards the integration of
model-driven engineering, software product line
engineering, and software conguration management.
In S. Hammoudi, L. F. Pires, P. Desfray, and J. Filipe,
editors, Proc. of the 3rd International Conference on
Model-Driven Engineering and Software Development ,
pages 5{18, Angers, France, 2015. SCITEPRESS.
[14] F. Schw agerl, T. Buchmann, and B. Westfechtel.
SuperMod - A model-driven tool that combines version
control and software product line engineering. In Proc.
10th International Conference on Software Paradigm
Trends , pages 5{18, Colmar, Alsace, France, 2015.
SCITEPRESS.
[15] F. Schw agerl, T. Buchmann, and B. Westfechtel.
Filtered model-driven product line engineering with
SuperMod: The home automation case. In P. Lorenz,
J. Cardoso, L. A. Maciaszek, and M. van Sinderen,
editors, Software Technologies , volume 586 of
Communications in Computer and Information Science
(CCIS) , chapter 2, pages 19 { 41. Springer, April 2016.
[16] F. Schw agerl and B. Westfechtel. Collaborative and
distributed management of versioned model-driven
software product lines. In Proc. 11th International
Conference on Software Paradigm Trends , Lisbon,
Portugal, 2016. SCITEPRESS. Accepted for
publication.
[17] C. Seidl, I. Schaefer, and U. Amann. Integrated
management of variability in space and time in
software families. In Proc. 18th International Software
Product Line Conference - Volume 1 , SPLC '14, pages
22{31, New York, NY, USA, 2014. ACM.
[18] D. Steinberg, F. Budinsky, M. Paternostro, and
E. Merks. EMF Eclipse Modeling Framework . The
Eclipse Series. Addison-Wesley, Upper Saddle River,
NJ, 2 edition, 2009.
[19] C. Thao. Managing evolution of software product line.
In M. Glinz, G. C. Murphy, and M. Pezz e, editors, 34th
International Conference on Software Engineering,
ICSE 2012 , pages 1619{1621. IEEE, 2012.
[20] E. Walkingshaw and K. Ostermann. Projectional
editing of variational software. In Generative
Programming: Concepts and Experiences, GPCE'14,
Vasteras, Sweden, September 15-16, 2014 , pages 29{38,
2014.
[21] B. Westfechtel, B. P. Munch, and R. Conradi. A
layered architecture for uniform version management.
IEEE Transactions on Software Engineering ,
27(12):1111{1133, 2001.
[22] S. Zschaler, P. S anchez, J. Santos, M. Alf erez,
A. Rashid, L. Fuentes, A. Moreira, J. Ara ujo, and
U. Kulesza. VML* | a family of languages for
variability management in software product lines. In
M. van den Brand, D. Ga sevic, and J. Gray, editors,
Software Language Engineering , volume 5969 of Lecture
Notes in Computer Science , pages 82{102. Springer
Berlin / Heidelberg, Denver, CO, USA, 2010.
827