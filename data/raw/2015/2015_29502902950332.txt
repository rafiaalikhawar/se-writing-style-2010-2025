ECHO: Instantaneous In Situ Race Detection in the IDE
Sheng Zhan, Jeff Huang
Parasol Laboratory
Texas A&M University, USA
echo@tamu.edu, je@cse.tamu.edu
ABSTRACT
We present ECHO , a new technique that detects data races
instantaneously in the IDE while developers code. ECHO
is the rst technique of its kind for incremental race detec-
tion supporting both code addition and deletion in the IDE.
Unlike conventional static race detectors, ECHO warns de-
velopers of potential data races immediately as they are in-
troduced into the program. The core underpinning ECHO
is a set of new change-aware static analyses based on a novel
static happens-before graph that, given a program change,
eciently compute the change-relevant information without
re-analyzing the whole program. Our evaluation within a
Java environment on both popular benchmarks and real-
world applications shows promising results: for each code
addition, or deletion, ECHO can instantly pinpoint all the
races in a few milliseconds on average, three to four orders
of magnitude faster than a conventional whole-program race
detector with the same precision.
CCS Concepts
Software and its engineering !Software mainte-
nance tools; Software verication and validation;
Keywords
Data Races, Change-aware, Instantaneous Detection, IDE
1. INTRODUCTION
Data races are among the hardest to debug types of bugs
in software systems. As software becomes more parallel,
race detection techniques are proliferating [1, 2, 3, 4, 5, 6].
Several industrial-strength tools [7, 8, 9] have also been de-
ployed. Most techniques and tools, however, are designed
for late phases of the software development cycle, e.g., test-
ing or production, where the whole program is completed.
Although races detected in a later phase are more likely to
be real bugs, scaling to programs with a large code base
without sacricing detection coverage or accuracy is di-
Figure 1: Instantaneous race detection by ECHO.
cult. Moreover, the later a bug is found, the more expensive
it would be to x it [10].
We advocate detecting races early in the programming
phase (ideally, in the IDE) such that it is both easier to
scale the race detector, by amortizing the analysis cost, and
cheaper to x the detected races, by providing developers
early feedback. However, existing IDEs ( e.g., Eclipse [11])
lack the support for detecting sophisticated bugs such as
data races, because of the expensive analysis cost. For exam-
ple, static race detectors [1, 2, 12] typically require pointer
analysis, which often takes several seconds or minutes to
compute for realistic programs. Upon a code change in the
IDE, instead of running a conventional race detector and
waiting for seconds or minutes, developers would favor an
in situ race checker running in the background that, similar
to checking syntax errors, detects races \instantaneously" as
they are introduced, and as non-intrusively as possible.
In this paper we present ECHO , a new technique and a
prototype tool that realize the above vision in Eclipse. A
snapshot of ECHO is shown in Figure 1 (see also a video
demo at [13]). The two statements at lines ( 20,37) form a
race on a shared variable x.ECHO detects this race and
displays the bug warning instantly ( i.e., in a few millisec-
onds) as the two statements are introduced into the pro-
gram. When either of the two statements is deleted or the
statement at line 37is moved into the synchronized region,
ECHO will invalidate the warning, again, instantly.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
FSE‚Äô16 , November 13‚Äì18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950332
775
In a nutshell, ECHO leverages the fact that program-
ming often involves frequent but small changes, which can
be analyzed quickly together with only their respective de-
pendencies without re-analyzing the whole program. Yet,
for race detection, the problem of how to eciently up-
date the change eects and correctly relate them to races
is quite challenging. We develop a new change-aware race
detection algorithm based on a novel graph representation
of the happens-before relation that handles a realistic subset
of multithreaded Java programs (see Section 3), supporting
both addition and deletion of dierent types of statements.
A critical component of our algorithm is an on-the-y
points-to analysis that determines the heap locations ac-
cessed by program statements and pointer aliases for rea-
soning about lock operations. Although points-to analysis
has been intensively studied before [14, 15, 16] including
a few incremental algorithms [17, 18], there is no previous
technique that is applicable within an IDE in which both
code addition and deletion must be handled. In particular,
handling deletion is dicult because it may involve complex
data-ow analysis and invalidation of the existing points-to
set. A reset-then-recover algorithm does not scale because
the analysis is cubic in the program size. We develop a novel
reachability-based algorithm that optimizes the invalidation
of the points-to set when a statement is deleted, achieving
as much as 41X (see Section 4.1) speedup over the reset-
then-recover algorithm on a real-world application.
Like other static race detectors, ECHO is incomplete and
can report false positives due to the limitation of static
analysis. However, compared to conventional race detec-
tors, we argue that ECHO is less over-whelming to de-
velopers as they receive immediate feedback on potential
races rather than getting a large number of warnings all
at once. Moreover, ECHO implements two optimizations
to improve precision. First, ECHO uses a hybrid algo-
rithm combining happens-before and lockset. As observed
by other researchers [19, 1], the hybrid algorithm is eec-
tive in pruning false positives reported by purely lockset-
based detectors. Second, ECHO builds on top of an object
eld-sensitive (but context-insensitive), locally ow-sensitive
Andersen-style analysis [20]. The eld and locally ow sen-
sitivity eectively reduces false positives caused by object-
level false sharing and ow-insensitivity within a method.
Our evaluation on a variety of popular benchmarks and
real-world applications shows that ECHO detects 100% of
the known races with a 36% false positive ratio and it takes
only 1-5ms on average to handle each change. Compared
to a whole-program race detector with the same recall and
precision, ECHO is three to four orders of magnitude faster.
We highlight our contributions as follows:
To our best knowledge, ECHO is the rst static race
detection technique that makes instantaneous in situ
race detection possible in the IDE.
We present a set of novel change-aware static analyses
including ecient data structures and new points-to
analysis algorithms that enable ECHO to quickly re-
spond to both code addition and deletion.
We present an evaluation of ECHO on both popular
multithreaded benchmarks and real-world Java appli-
cations and demonstrate that it can pinpoint races in
milliseconds with a reasonable precision. We also iden-
tify three common sources of false positives.2. OVERVIEW
We rst present an overview of ECHO with an articial
example, and then discuss the technical challenges.
Example. Imagine that in an IDE the developer has writ-
ten the Java program in Figure 2(a) but not yet the code
in the gray region ( i.e., the changes ¬¨{¬∞). The program
starts two threads testing a Vector container by storing and
retrieving objects of the Conference class, which has two at-
tributes, name andyear. The main thread ( T1) rst creates
twoConference objects, c1andc3, and assigns c1to another
object reference c2. It then adds c2to the vector vand
starts the child thread ( T2) passing vas an argument. T2
traverses the vector and prints out each element contained
in it. The Vector implementation here is not thread-safe,
because its methods are not synchronized. However, there
is no data race in this program so far, because all operations
are ordered by happens-before ,i.e.,T2 must execute after
the thread start operation by T1 at line 39.
2.1 ECHO in Action
Suppose the developer now performs the changes ¬¨{¬∞.
We next show how ECHO reacts to them one by one.
Change ¬¨.When the rst change ¬¨v.add(c3) is in-
troduced, ECHO displays two races between lines ( 19,23)
and ( 23,27). The reason is that the change adds the second
Conference object (referenced by c3) to the vector, which
modies both the size of the vector ( count ) and the corre-
sponding array element ( elems ) at line 23. These two writes
are not ordered with the two method calls v2.size() and
v2.get(i) byT2, which respectively read count and elems
on the same vector at lines 19and 27. None of these four
accesses is protected by any lock and they form two races.
Changes ¬≠¬Æ.Upon seeing the two race errors, the devel-
oper attempts to x them by introducing Change ¬≠: adding
synchronized keyword to both add(e) andsize() .ECHO
detects that the race ( 19,23) is xed (because both of the two
accesses are now protected by the same lock) and clears the
warning. However, the other race ( 23,27) remains because
the access at line 27is not protected. As a result, the devel-
oper proceeds to introduce Change ¬Æ: adding synchronized
toget(i) . After this change, the race warning ( 23,27) also
disappears because ECHO detects that both accesses to the
array element are now protected by the same lock.
Changes ¬Ø¬∞.Now the developer adds ¬Øc3.increment-
Year() at line 41.ECHO detects a new race ( 8,10), because
this method call modies the attribute year at line 8and it
is not ordered with the method call p.toString() byT2 at
line51, which reads year at line 10. Both c3 and pcan refer
to the second Conference object and these two methods are
not synchronized, so the two accesses to year form a real
race. To x this race, instead of adding synchronization,
the developer realizes that c3 should not be added to the
vector and hence performs Change ¬∞: deleting v.add(c3)
at line 40. Upon the deletion, ECHO invalidates the race
warning ( 8,10) because now lines 8and 10access dierent
objects and pcannot refer to the second Conference object.
2.2 ECHO in a Nutshell
Figure 2(b) shows an architectural overview of ECHO ,
consisting of three components: a change tracker, a race
detection engine, and a race displayer. The rst and the
third components are both IDE-specic. The second compo-
nent takes one or more changes as input and runs a change-
776(a) Example(d) Static Happens-Before Graph (b) Architecture Overview(c) Points-to GraphChangeTracker 1‚É£(19,23)(23,27)In&decrementalRace DetectionStatic HB Graphchange-awarePoints-to Analysischange-aware 4‚É£(8,10) 
     RaceDisplayerc1o33t[x]c2c3o35evo36v1v2thrd2o38p 1‚É£mainv.addt.startthrd2.runv.addv2.sizev2.getp.toStringread v2.countread v2.t[x]read p.yearwrite v.t[x]T1T2
write: T1o36.t[x]read: T2o36.countread & write v.countwrite: T1read: T1, T2o33.yearo35.yearwrite:    read: T2read: T1, T2 1‚É£
write: T1     4‚É£c3.incYear 4‚É£read & write c3.year
3‚É£1234567891011121314151617181920212223242526272829class Vector{	Object[] elems;	int count;	Vector(){		this.elems = new Object[MAXSIZE];   }	public int size(){		return count;   }	void add(Object e){		Object[] t = this.elems;		t[count++] = e; // writes t[x]	}	Object get(int i){		Object[] t = this.elems;		return t[i]; // reads t[x]	}}class Conference{	String name;	int year;	Conference(String n, int y){		this.name = n;		this.year = y;}	public void incrementYear(){		this.year++;}	public String toString(){		return name+year;}}public static void main(String[] args){   String name = "FSE";   int year = 2016;	Conference c1 = new Conference(name,year);	Object c2 = c1;	Conference c3 = new Conference(name,year);	Vector v = new Vector();	v.add(c2);	Thread2 thrd2 = new Thread2(v);	thrd2.start();	   v.add(c3);     v.add(c3);	   c3.incrementYear();}class Thread2 extends Thread{	Vector v2;	public Thread2(Vector v1) {		this.v2 = v1;	}	public void run(){		for(int i=0;i<v2.size();i++){			Object p = v2.get(i);			System.out.println(p.toString());		}	}}30313233343536373839404142434445464748495051525354 1‚É£ 2‚É£ synchronizedsynchronized4‚É£   5‚É£Figure 2: ECHO Technical Overview.
aware algorithm to detect races. The algorithm relies on
three mutually dependent graphs { a points-to graph, a call
graph, and a static happens-before (SHB) graph, all of which
are computed in a change-aware manner: only those facts
(nodes and edges) in the graph that are aected by the
change are recomputed and the rest of the graph remains
the same. The points-to graph and call graph are standard.
We refer the readers to previous work [14, 21] for their back-
ground. The SHB graph is a new data structure:
Static Happens-Before (SHB) Graph. The SHB
graph augments the call graph with directed edges represent-
ing the happens-before relation between abstract threads
and heap accessing statements: read or write to abstract
heap locations (AHL) { a eld of an abstract object or an ar-
ray element. Figure 2(d) shows the SHB graph of the exam-
ple program. The edge v.add!t.start means that v.add
should be executed before t.start andt.start!thrd2.run
because thrd2.run can only execute after the thread is started.
The edges are transitive. In addition, for the race detection
algorithm to identify conicting accesses to AHL, the SHB
graph is also associated with two states from each heap ac-
cess statement to the corresponding AHL: a read set and
a write set, denoting reads and writes to the AHL, respec-
tively. For example, the method v.add byT1 writes to t[x]
and count onv. Because vcan point to o36, these two
writes by T1 are included in the write sets of o36.t[x] and
o36.count , respectively.
Algorithm 1 ECHO Race Detection ( P)
1:Input : P- a set of program changes.
Additions: +{a1,a2,...} ; deletions: -{d1,d2,...} .
2:Global states: ptg- points-to graph;
3: cg- call graph;
4: shb- static happens-before graph.
5:  ptg, cg UpdatePointsToAndCallGraph (P);
6:  shb UpdateSHBGraph (P,ptg,cg);
7:DetectDataRaces (shb,ptg).
Algorithm Overview. An overview of our race detec-
tion algorithm is shown in Algorithm 1. Given a set of pro-gram changes  P(including both addition and deletion1),
the points-to graph and call graph are updated rst (we will
show how in Section 3). Then,  Ptogether with the changes
in the call graph ( cg) are used to update the SHB graph.
Finally, we check if any update in the points-to graph ( ptg)
and the SHB graph ( shb) can lead to new races or invali-
date any existing races. There are two basic steps: nding
and invalidating conicting accesses and checking happens-
before and lockset . The rst step tracks changes of states
(i.e., read and write sets) associated with each AHL. If the
write set contains accesses from at least two dierent ab-
stract threads, or at least one access from a thread that is dif-
ferent from any thread in the read set, the two corresponding
accesses are considered conicting. The second step checks
for the two conicting accesses their happens-before relation
and locksets, which can be computed using the SHB graph.
If the two accesses are not ordered by happens-before or
their locksets do not overlap, they are reported as a race.
Example. The points-to graph and the SHB graph before
the changes ¬¨-¬∞are shown in Figure 2, ignoring the colored
nodes and edges. When ¬¨v.add(c3) is added, both of the
two graphs are updated. A new edge c3;eis added in the
points-to graph because c3is passed as the method argu-
ment. A new node v.add is added in the SHB graph and a
new edge from t.start is added to this new node. In addi-
tion, because pcan now refer to o35, the read set of o35.year
is updated to include T2. The new v.add node has the same
read and write statements as that of the rst v.add node
before t.start . However, the dierence is that this node
is not ordered with the nodes from T2. Hence, by check-
ing happens-before and lockset related to the new accesses
too36.t[x] ando36.count , our algorithm detects two races,
(19,23) and ( 23,27). Similarly, when ¬Øc3.incrementYear()
is added, a new c3.incYear node is added to the SHB graph
and a new edge from t.add is added to the new node. Both
the read and write sets of o35.year are updated to include
T1, because c3.incrementYear() reads and writes the eld
1Note that a code update can be treated as two changes:
deletion of the old statement, and addition of the new state-
ment. Large code chunks can be treated as a sequence of
small changes.
777P ::= defne (program)
defn ::= class Cffieldmethg(class decl)
field ::= T f (eld decl)
meth ::= C m (arg){sreturn z}(method decl)
s ::=
j¬∂x= new C (allocate )
j¬∑x=y (simple assign )
j¬∏x=y.f (eld read )
j¬πx.f=y (eld write )
j¬∫x=o.m(arg) (method call )
j¬ªx=y[i] (array read )
j¬ºx[i] =y (array write )
j¬Ω t.start() (thread fork )
j¬æ t.join() (thread join )
j¬ø synchronized( x){s} (lock)
jJ loop( b){s} (loop )
j if(b){s} (conditional)
j e (other)
Figure 3: SIMJava.
year, and c3can refer to o35. The read set of o35.year
contains T2, so the two accesses at lines 8and 10are con-
icting. By checking their happens-before and locksets, our
algorithm detects a new race ( 8,10).
2.3 Technical Challenges
To achieve both fast speed and good precision, there are
several tough technical problems that we must solve:
1.Change-aware race detection. How to correctly
and eciently react to a program change? How to
correctly handle dierent types of changes? How to
eciently maintain the happens-before relation and
lockset upon a change?
2.Change-aware points-to analysis. How to soundly
update the points-to graph and call graph upon a change?
By soundness, we mean that any true points-to rela-
tion must be represented in the points-to graph. Mean-
while, we would like to compute a points-to graph that
is as precise as possible. For example, in Figure 2,
before Change ¬Ø, the variable pcannot refer to o35.
Otherwise, a false positive would be reported.
3.Sound static happens-before graph. How to con-
struct a sound SHB graph such that any true happens-
before relation is represented and no reachable heap
access is missed? How to handle back edges caused by
loops or recursion? How to identify abstract threads
that may have multiple runtime instances?
We next present our algorithms to address these challenges.
3. ALGORITHM
We rst introduce a multithreaded language SIMJava ,
which contains a subset of Java basic constructs for multi-
threaded programming. Based on SIMJava , we then present
our change-aware analysis algorithms.
The SIMJava Language. SIMJava is inspired from
ConcurrentJava [22], with a few dierences and exten-
sions that make it more powerful for expressing concur-
rency and also cleaner for change-aware analysis. Figure 3
shows the syntax. SIMJava supports three types of inter-
thread synchronization operations, fork,join, and synchro-Table 1: Static HB Graph Construction. Array ac-
cesses are treated similarly to eld accesses (as to a
single eld) and are omitted.
Statement Nodes
¬∏x = y.f read(y.f)
¬πx.f = y write(x.f)
¬∫x = o.m( y)8Oc2pts(o):call( Oc:m)
¬Ωt.start() 8Oc2pts(t):fork( Oc)
¬æt.join() 8Oc2pts(t):join( Oc)
¬øsynchronized( x){8Oc2pts(x):lock( Oc)
s} unlock( Oc)
Jloop( b){s} unroll twice :ss
Two fake nodes: 8Oc2pts(t):start( Oc)&end(Oc)
Edges:8Oc2pts(t): fork( Oc)!end(Oc)
end(Oc)!join( Oc)
Method call s(o.m):
8Oc2pts(o):)Node( s)!FirstNode( Oc:m)
LastNode( Oc:m)!NextNode( s)
8s1; s22m&s1s2)Node( s1)!Node( s2)
nized . The forkand joinoperations together form the inter-
thread happens-before relation and synchronized forms the
lock mutual exclusion relation. Statements ¬∂-¬øinclude the
typical operations for object allocation, assignments, eld
and array read and write, method invocation, as well as the
concurrency primitives. All these statements are analyzed in
our race detection. In addition, SIMJava supports the loop
operation Jloop(b){s*} that evaluates a boolean variable
band iterates the statements s*. The loopoperation reects
loop constructs, such as forand while . For race detection,
loopoperations must be considered in our algorithm because
they may spawn multiple threads and may also introduce
multiple other types of synchronizations. However, condi-
tionals are ignored because our algorithm is path-insensitive.
3.1 Change-aware Data Race Detection
The core of our algorithm is a change-aware static happens-
before (SHB) graph powered by an on-the-y points-to anal-
ysis. We rst present the SHB graph construction algorithm.
3.1.1 SHB Graph Construction
Starting from a unique entry method ( e.g.,main), the SHB
graph is constructed following the rules in Table 1. There
are nine dierent types of nodes in the SHB graph, corre-
sponding to the nine statements ¬∏-¬øinSIMJava .¬∏(eld
read) and ¬π(eld write) are similar to ¬ª(array read) and
¬º(array write), except that the index to eld is xed and
bounded, but to array it is not. To improve eciency, array
index is often ignored in static analysis. We also do not dis-
tinguish dierent array elements, instead we create a single
\eld" xfor each array object aand consider all accesses to
aas to a[x]. In this way, ¬ªand¬ºare equivalent to ¬∏and
¬π, respectively. We hence omit the discussion of ¬ªand¬º
in the rest of this paper.
The synchronization statement ¬ø(synchronized( x){s})
generates two nodes: lock and unlock , inserted at the be-
ginning and end of the synchronized block, marked by \ {"
and \ }", respectively. In addition, we introduce two fake
nodes for each abstract thread: start and end, which are
used to construct the inter-thread happens-before relation.
Abstract Heap Location (AHL). For eld and array
778read/write node, we maintain a linkfrom the node to one
(or more) AHL, which corresponds to the abstract data the
node accesses. The AHL is identied by O.f(for eld) or
O.x(for array), where Ois an abstract object in the points-
to set of the base variable. Each AHL is associated with
two states: a read set and a write set, recording write and
read accesses to the location from abstract threads. This
information is used to identify conicting heap accesses.
Abstract Thread and Lock. For the other nodes, each
node is associated with one (or more) abstract object, which
is computed using the points-to set of the corresponding
base variable. For example, for fork and join (and start
andend), their abstract object is the corresponding abstract
thread, identied by the points-to set of tint.start() ,
t.join() , or the main method (for only the main thread).
Forlock andunlock , their abstract object is the correspond-
ing abstract lock: the points-to set of xinsynchronized(x) .
Handling Loop. For loop statements J(loop( b){s}),
we create more than one sequence of nodes for s, because
each smay generate multiple reads/writes or fork multiple
threads. The challenge is that the number of loop iterations
is unknown statically. Nevertheless, for race detection, it
suces to unroll the loop twice. The reason is that data
races involve only two abstract threads and two memory ac-
cesses. Unrolling a loop twice will guarantee to expose the
same set of races as unrolling more than two times. Simi-
larly, we handle recursion by unrolling all loops in the call
graph twice and removing the corresponding back edges.
Statement Location. Each node in the SHB graph is
also associated with a unique location, corresponding to the
program location of the statement. The unique location is
used to determine the program order for statements from the
same method. For synchronized blocks and loop statements,
the locations of their corresponding nodes are treated in the
following way. For lock and unlock , their locations corre-
spond to the locations of \ {" and \ }" of the synchronized
block. For loops, we add a loop iteration identier (either
I1orI2) to each node, all nodes with I1should happen be-
fore nodes with I2unrolled from the same loop statement.
Together with the call graph, the node location information
is used to compute the intra-thread happens-before relation.
Happens-Before. The happens-before edges are con-
structed over fork!start andend!join for each abstract
thread object and over method calls. For a method call s,
o.m, for each abstract object, Oc, in the points-to set of o, an
edge is added from its corresponding node, Node( s), to the
rst node of the callee method, FirstNode( Oc:m). In ad-
dition, an edge is added from the last of the callee method,
LastNode( Oc:m), to the next node of s,NextNode( s).
Furthermore, happens-before edges are added between con-
secutive nodes in Oc:mfollowing the program order.
Lockset. lock andunlock nodes do not introduce happens-
before edges. Instead, we associate every memory access
node ( read and write ) protected by each pair of lock and
unlock nodes with a lockset and add all the abstract lock
objects to which these lock variables may refer to the lock-
set. The lockset is used together with happens-before to
improve precision of race detection.
3.1.2 Change-aware SHB Algorithm
If any of these nine types of statements is added or deleted,
our change-aware SHB algorithm updates the SHB graph.
This step is relatively straightforward by following the rulesin Table 1. For addition, we rst insert the correspond-
ing nodes (introduced by the new statement) into the SHB
graph according to the statement location. We then add the
links for AHL and add the happens-before edges according to
the points-to set. For deletion, we simply remove all the cor-
responding nodes and their links and edges from the graph.
If a removed node nis between two nodes n1!n!n2,
then the two nodes will be connected n1!n2. For loop
statements, their addition and deletion are equivalent to
adding and deleting sin the loop body. For synchronization
statements, we update the lockset of each read and write
node that they protect accordingly.
For statements ¬∂(allocate) and ¬∑(simple assignment),
they may change the points-to graph and call graph. For
points-to changes, we update the SHB graph by adding or
deleting the corresponding nodes/edges/links according to
the changed points-to set of each base variable. For call
graph changes, we delete only the related edges but not the
nodes, to reuse the nodes later if a method call statement
to the same method is added.
A caveat is that a statement may appear as multiple nodes
in the SHB graph because the statement is in a loop or its
enclosing method is called in multiple places. Therefore, for
changes to these statements, we must track and update all
their occurrences in the SHB graph. We track these state-
ments by maintaining a map from each method to its loca-
tions in the graph and a boolean state for each statement
indicating if it is in a loop. For a statement change, we lo-
cate all their occurrences by checking both the map with its
enclosing method, and the boolean state. We do not han-
dle method recursion separately because recursion is already
handled by unrolling the loops twice in the call graph.
3.1.3 Change-aware Race Checking
The race checking procedure is triggered upon a change in
the SHB graph. There are three types of changes: links to
AHL, lockset, and happens-before. When a link to an AHL
is added or deleted, it means that a read orwrite node, X, is
added or deleted, and we perform race checking specic to X.
We rst nd all the pairs of conicting nodes including Xby
checking the associated read and write sets. Because any of
these pairs may become a race (or no longer a race), for each
pair, we check the happens-before relation and the lockset
condition between the two nodes. If the two nodes cannot
reach each other on the SHB graph and their locksets do not
intersect, we ag them as a race. The lockset condition here
is essentially a may-alias analysis that determines if two lock
variables may refer to a common lock. If the ag of any pair
is changed, we update the race warning in the IDE.
For happens-before changes, we only handle inter-thread
changes because intra-thread happens-before is determined
by program order and it alone cannot introduce new races or
invalidate existing races. There are two types of inter-thread
happens-before edges: (1) fork!start and (2) end!join.
For (1), we check only the conicting node pairs involving
those nodes that happen before the fork node and those that
happen after the start node because only (the happens-
before relation of) those nodes can be aected by this happens-
before edge. Similarly, for (2), we check only the conicting
node pairs involving those nodes that happen before the end
node and after the joinnode. For lockset changes, similarly,
we only nd and check those conicting node pairs involving
nodes whose locksets are changed.
779Table 2: Extended Andersen's Algorithm ( Ocrefers to abstract objects of type C).
Statement Points-to Set Constraint Points-to Graph Edge
¬∂x = new C Oc2pts(x) Oc;x
¬∑x = y pts(y)pts(x) y;x
¬∏x = y.f 8O2pts(y) :pts(O:f)pts(x) O:f;x
¬πx.f = y 8O2pts(x) :pts(y)pts(O:f) y;O:f
¬∫x = o.m'( y)//from method C.m pts(y)pts(y0) and pts(z)pts(x)z;xandy;y0
call: m'(y0){sreturn z}8Oc02pts(o):add (C:m; cs );C0:m0in the call graph //cs{ call site
3.2 Change-aware Points-to Analysis
Our change-aware points-to analysis builds on an on-the-
y Andersen-style algorithm [20]. It is context-insensitive,
but eld-sensitive and locally ow-sensitive, i.e., ow-sensitive
within each method. The key novelty of our new algorithm
(Algorithm 2) is to make the analysis more ecient in han-
dling program changes including both addition and deletion.
On-the-y Andersen's Algorithm. Letpts(v) denote
the points-to set of a variable vandOvthe abstract object
directly assigned to v. Points-to analysis is often cast as a
graph closure problem. Each node represents a variable v
and has an associated points-to set pts(v) orOv. In Ander-
sen's algorithm, edges represent subset constraints between
nodes: an edge a;bmeans that pts(a) is a subset of pts(b).
ForSIMJava , there are seven types of statements ( ¬∂-¬º)
relevant to points-to analysis. ¬∂(allocate) and ¬∑(simple
assignment) are used to initialize the points-to graph, and
the rest ve ( ¬∏-¬º) may add more edges on-the-y. Table 2
shows an extended Anderson's algorithm. The statement ¬∫
(method call) is also directly related to call graph construc-
tion. When a new call graph edge is discovered, the points-
to graph may also be updated because of the new points-to
facts introduced by parameter passing and value returning.
As a result, the on-the-y algorithm works in a loop until
reaching a xed point, i.e., both the points-to graph and call
graph are unchanged. In each iteration, a worklist is used to
track the new points-to facts and the points-to information
is propagated along the two graphs following the constraint
rules in the second column in Table 2.
3.2.1 Statement Addition
Handling statement addition follows the same rationale
as the on-the-y Anderson's algorithm. New points-to facts
(nodes/edges) are rst extracted from the added statement
and put into the worklist. Then, the points-to information
is computed along the relevant paths in the two graphs until
reaching a xed point. The key advantage of our new algo-
rithm is that only those nodes in the paths related to the
new facts are recomputed, all the other nodes are untouched.
The algorithm (Algorithm 2 lines 7-19) takes an added
statement sand its enclosing method C:m as input ( C:m is
needed for building the call graph). It rst nds out all the
new edges that smay introduce using the function FIND-
EDGES (Algorithm 3). FINDEDGES handles each type
of statements following the rules in the third column of Ta-
ble 2. For the rst two types ( ¬∂and¬∑), the new edges
can be added straightforwardly (note that the side eect
of Statement ¬∑(x = y ) is handled by the xed-point com-
putation in Algorithm 2 at lines 9-19). For the other three
(¬∏¬π¬∫ ), which we call complex statements , their correspond-
ing edges are not xed but depend on the points-to set of
their base variable. For example, for ¬∏(x = y.f ), suppose
pts(y) contains two objects o1ando2, then two edges mustbe added: o1:f;xando2:f;x. Moreover, when pts(y)
is changed during the computation, the corresponding state-
ment must be re-evaluated because new edges may be added
or deleted. Therefore, in addition to nding edges for these
complex statements, FINDEDGES also maintains a map,
CS, that records the corresponding complex statements and
their methods for each base variable. For example, for ¬π
(x.f = y ),x;(C:m; s ) is added to CSfor statement ad-
dition and deleted for deletion.
Statement ¬∫(x = o.m'( y)) may additionally update the
call graph, trigger new statements (in the callee method)
to be added, or introduce points-to edges related to both
formal parameters and return. We handle all these cases
correspondingly in Algorithm 3.
For each new edge src;dst, if it is not already in the
points-to graph, it is added to the graph and its points-
to set is updated following the subset constraints: pts(dst)
 pts(dst)[pts(src). Ifpts(dst) is changed, all edges from
dstin the points-to graph are added to the worklist and re-
processed to update the points-to set of v. In addition, all
the complex statements that have dstas their base variable
will be re-processed because new points-to edges may be
introduced by the change in pts(dst).
3.2.2 Statement Deletion
Handling statement deletion is more complicated than ad-
dition. Intuitively, it is the reverse of addition and, if we can
track the state changes of the points-to graph by each ad-
dition, we may undo the changes for deletion of the same
statement. Yet, this intuition is not true because points-to
analysis is not \reversible". Deletion is fundamentally dier-
ent from insertion in that it requires updating not only the
pointer information of the specic change, but also previous
changes that are dependent on this change. Moreover, for
large graphs, it is expensive to memorize the state changes.
Reset-then-recover. One (less ecient) solution (Al-
gorithm 2 lines 20-40) is to reset the points-to sets of all
relevant nodes and then recompute them. We can rst nd
all the points-to edges that are related to the deleted state-
ment, remove all these edges, and reset (set to empty) the
points-to sets of their destination nodes as well as all nodes
that they can reach. Then, following the same method for
addition, we can add all the edges in the remaining points-to
graph that can reach the reset nodes into the worklist and
repeat the xed point computation. This method is ine-
cient because the points-to sets of some reset nodes may in
fact remain unchanged before and after the deletion, such
that all the reset-then-recover computations are wasted.
Reachability-based Algorithm. Our optimized solu-
tion is based on two observations. First, after deleting an
edge x;y, the points-to set of ymay remain the same if x
is still reachable to y. Second, for any abstract object O, if
Ois reachable to ythen Omust be included in the points-
780Algorithm 2 Change-Aware Points-to Analysis
1:Input :s{ a new added or deleted statement in C:m.
2:Global States :ptg=< Vp; Ep>{ points-to graph;
3: cg=< Vc; Ec>{ call graph;
4: pts{ points-to set function;
5: W{ worklist;
6: CS{ variable to complex statements;
7: //Addition
8:W FINDEDGESS (C:m,s);
9:while W6=;do
10: e SELECT FROM W//e:src;dst
11: ife62Epthen //eis a new points-to edge
12: Ep Ep[e;
13: pts(dst) pts(dst)[pts(src);
14: ifpts(dst)changed then
15: foreach (dst;v)2Epdo
16: W W[(dst;v);
17: //process complex statements
18: foreach (C:m,s)2CS(dst)
19: W W[FINDEDGES( C:m,s);
20: // Deletion - Reset-then-recover
21:Reset ;;
22:W FINDEDGES( C:m,s);
23:while W6=;do
24: e SELECT FROM W//e:src;dst
25: Ep Epne; //remove efrom Ep
26: Reset Reset[dst;
27:while Reset6=;do
28: v SELECT FROM Reset
29: pts(v) ;; //reset the points-to set of v
30: foreach (v;dst)2Epdo
31: Reset Reset[dst;
32: foreach (src;v)2Epdo
33: W W[(src;v);
34:while W6=;do
35: e SELECT FROM W//e:src;dst
36: pts(dst) pts(dst)[pts(src);
37: ifpts(dst)changed then
38: //process complex statements
39: foreach (C:m,s)2CS(dst)
40: W W[FINDEDGES( C:m,s);
41: // Deletion - Reachability-based
42:W FINDEDGES( C:m,s);
43:while W6=;do
44: e SELECT FROM W//e:src;dst
45: if IsReachble (src,dst)then
46: continue ;
47: foreach o2pts(src)do
48: // L: a set of nodes whose points-to sets may change
49: L L[dst;
50: while L6=;do
51: v SELECT FROM L
52: if IsReachble (o,v)then
53: continue ;
54: pts(v) pts(v)no; //remove ofrom pts(dst)
55: foreach (v;dst)2Epdo
56: L L[dst;//propagate the change
57: //process complex statements
58: foreach (C:m,s)2CS(dst)
59: W W[FINDEDGES( C:m,s);Algorithm 3 FINDEDGES (C:m,s)
1:Output :E{ a set of edges, initially empty.
2:Notation :N{union for addition;
3: removal for deletion.
4:switch sdo
5:case¬∂x = new C :E E[Oc;x;
6:case¬∑x = y :E E[y;x;
7:case¬∏x = y.f :
8: foreach O2pts(y)do
9: E E[O:f;x;
10: CS CSN(y;(C:m; s ));
11: case¬πx.f = y :
12: foreach O2pts(x)do
13: E E[y;O:f;
14: CS CSN(x;(C:m; s ));
15: case¬∫x = o.m'( y):
16: foreach Oc02pts(o)do
17: ifC:m;C0:m062Ecthen
18: foreach s02C0:m0(y0)fs0return zgdo
19: E E[FINDEDGES( C:m,s0);
20: E E[fy;y0; z;xg;
21: Ec EcN(C:m;C0:m0)
22: CS CSN(o;(C:m; s );
23:return E.
to set of y. Our new algorithm (shown in Algorithm 2 lines
41-59) hence lazily updates the points-to set by checking the
path reachability beforehand, using the function IsReach-
able(x,y). The algorithm updates the points-to set of y
(denoted by pts(y)) only when IsReachable (x,y) returns
false and it removes an abstract object Ofrom pts(y) only
when IsReachable (O,y) returns false.
po1yqwo2xzdeleted
Figure 4: An exam-
ple of edge deletion.Consider the example in Fig-
ure 4 where the edge x;y
is deleted. We rst check if
xis still reachable to y, if yes
(e.g., in the existence of the
path x;p;y), we simply
stop. If not, we go on to check
the reachability from each ab-
stract object oinpts(x) toy.
Ifois not reachable to y, we
remove ofrom pts(y) and con-
tinue to check the reachability from oto the nodes that are
reachable from y(e.g., zin the example) and propagate the
removal if not reachable. Otherwise, oremains in pts(y) and
we stop the propagation for o. If the path x;p;ydoes
not exist, after deleting x;y,o1can no longer reach y
ando1is hence removed from pts(y). The removal is prop-
agated to pts(z) because zis reachable from yando1is no
longer reachable to z. However, o2is still reachable to y
via the path o2;w;q;yando2remains in pts(y).
The computational improvement here is that we can skip
the propagation to pts(z), because pts(y) is unchanged.
3.3 Soundness and Other Optimizations
Soundness. Both of our change-aware happens-before
graph construction and points-to analysis algorithms are
sound. Our incremental computation on the happens-before
graph and points-to graph produces the same state as the
one-shot whole-program computation. The key to the proof
is that adding/removing a statement computed by our algo-
781Table 4: Race Detection Performance. ECHO is
typically four orders of magnitude faster than con-
ventional whole program race detector.
Pointer analy. Whole-prog. ECHO
(one-time) detector Average Worst
Example 3.3s 3.3s 0.27ms 153ms
FileWriter 4s 4.1s 0.96ms 837ms
Loader 2.4s 2.5s 0.27ms 197ms
Manager 2.5s 2.5s 0.32ms 269ms
MergeSort 2.9s 4.3s 0.3ms 238ms
Racey 2.5s 2.6s 0.25ms 226ms
Pool 2.4s 2.4s 0.24ms 122ms
WebLech 16.4s 16.5s 5ms 6.4s
H2 5.2s 5.2s 0.89ms 1.0s
rithms leave the states of the two graphs the same.
However, our race detection algorithm is unsound, due to
its use of may-alias for reasoning about lockset. May-alias
may incorrectly determine that two dierent lock variables
(that refer to dierent locks at runtime) alias each other
and certain real races may be missed. Nevertheless, this
issue rarely happens in practice when the points-to analysis
is locally ow-sensitive. In our studied benchmarks, ECHO
can detect all known real races.
SCC Optimization. Precise tracing of all eected edges
and nodes can be expensive due to the presence of cycles in
the points-to graph. However, all nodes in the same cycle
are guaranteed to have identical points-to sets, so we can
collapse those strongly-connected components (SCC) into a
single node. Previous research [21] has shown that the SCC
optimization is eective scaling to millions lines of code. We
also apply this optimization in our algorithm. Specically,
we maintain a super node for each SCC and update the super
nodes after the initial worklist is set. A super node can be
either augmented (for addition) or shrinked or broken (for
deletion). Once updated, both the graph traversal and the
update of points-to set in the SCCs become faster.
4. EVALUATION
We implemented ECHO as an Eclipse plugin based on the
WALA framework [23]. We modied the ZeroOneCFA [20]
implementation of Andersen's algorithm (that identies ab-
stract objects by allocation sites). We evaluated ECHO on a
variety of popular Java multithreaded benchmarks collected
from previous concurrency studies [1, 4, 24], including three
real-world systems { the H2 database [25], the WebLech Spi-
der [26], and the Apache Commons Pool library. Our eval-
uation answers two sets of research questions:
1.Performance { How ecient is ECHO in reacting to
program changes? How scalable is ECHO in detect-
ing races? How much speed up compared to whole-
program race detection?
2.Recall & Precision { Can ECHO detect all real
races? How precise is it? What is the false positive
ratio and what are the reasons for false positives?
Benchmarks. Table 3 summarizes the static character-
istics of the benchmarks including our example program in
Figure 2. The size of the smaller benchmarks ranges from
68 to 2.8K lines of code. The size of real-world programs
ranges from 10K to 172K. All benchmarks except H2are
self-contained, i.e., each of them has a single entry point
(the main method) for the analysis. For H2, we use thetest driver class org.h2.test.synth.thread.TestMulti in
the H2 test suite as the entry point. All JDK libraries (e.g.
java.lang.* and java.util.* ) are included in the anal-
ysis except those excluded by WALA by default, such as
java.awt.* and sun.* . These JDK libraries account for
the majority of the classes (the number reported in Column
3) for building the class hierarchy. Nevertheless, for points-
to analysis, only those methods that are reachable from the
entry points are analyzed. The number of reachable meth-
ods for these benchmarks ranges from 927 to 3.7K, contain-
ing 27K to 108K SSA instructions. The points-to graph for
each benchmark contains 9K-41K pointer keys ( i.e., refer-
ence variables), 1.2K-5K instance keys ( i.e., object alloca-
tion sites), and 60K-2.5M points-to edges. For WebLech ,
its points-to graph is much larger and more dense than the
other benchmarks. It is particularly interesting for our eval-
uation of scalability because Anderson's algorithm in the
worst case is cubic in the size of the graph.
Evaluation Methodology. ECHO can be used by de-
velopers starting either from an empty project or from an
existing code base. We choose the latter scenario for our
evaluation. For each benchmark, we run the experiment in
three phases: (1) run points-to analysis and static happens-
before graph construction for the whole program; (2) delete a
statement and run race detection; (3) add the deleted state-
ment back and run race detection. Phase 1 is needed only
once for ECHO . Phases 2 and 3 are performed for each
statement in each method.
To understand the performance improvement of our novel
change-aware algorithms, we also implement a whole pro-
gram race detector and compare its performance with ECHO .
The whole program race detector uses the same hybrid al-
gorithm and the same pointer analysis as we use in ECHO .
The only dierence is that for every change it has to re-run
the whole-program analysis. Hence, the whole program race
detector and ECHO have the same race detection ability
(i.e., report the same races with same precision and recall),
except that ECHO is faster.
In addition, to show the improvement of our reachability-
based algorithm for handling deletion, we compare its per-
formance with the reset-and-recover algorithm.
All experiments were performed on an Apple Mac Pro
with 2.5GHz dual-core Intel i5 processor and 4GB of memory
running Java HotSpot 64-bit Server VM version 1.8.0.
4.1 Performance
Table 4 reports the performance of ECHO compared to
the whole program race detector. Column 2 reports the time
for performing the points-to analysis for each benchmark.
The points-to analysis time typically ranges between 2s-5s,
except for WebLech , which takes 16.4s because of its large
points-to graph. Column 3 reports the time taken by the
whole program race detector to detect races upon a change.
The whole program race detector needs 2.5s-16.5s to detect
races. Columns 4-5 report the average and worst-case time
(including all incremental analyses and the race detection)
taken by ECHO for each change.
For most benchmarks (including H2and Pool),ECHO
takes less than 1ms on average per change and 1s in the
worst case. Compared to the whole program race detector,
ECHO is typically four orders of magnitude faster. The
only exception is WebLech , which has a much larger and
more dense points-to graph. However, even for WebLech ,
782Table 3: Benchmarks. JDK libraries are also analyzed except those excluded by WALA by default.
Benchmark LOC #Classes #Methods #SSAInstructions #PointerKeys #InstanceKeys #PointerEdges
Example 68 7091 927 26881 8832 1178 58540
FileWriter 256 7094 1569 52568 17044 2825 324631
Loader 109 7089 938 27263 8952 1199 60133
Manager 171 7090 956 27811 9121 1221 67671
MergeSort 298 7089 971 28522 9401 1275 66694
Racey 294 7091 930 27447 8859 1179 58932
Pool 10K 7091 931 26991 8852 1182 55956
WebLech 35K 7144 3650 108176 41612 5004 2578820
H2 172K 7628 1814 66463 20506 3174 391769
Table 5: Performance of Addition and Detection.
Fast-Insts: instructions that take <0.1s to handle.
Average Worst case Fast-Insts%
delete add delete add delete add
Example 0.4ms 0.06ms 153ms 21ms 92% 92%
FileWriter 1.7ms 0.23ms 837ms 28ms 93% 93%
Loader 0.44ms 0.07ms 197ms 29ms 92% 92%
Manager 0.5ms 0.07ms 269ms 25ms 92% 92%
MergeSort 0.53ms 0.06ms 238ms 36ms 92% 92%
Racey 0.44ms 0.06ms 226ms 34ms 92% 92%
Pool 0.43ms 0.06ms 122ms 22ms 92% 92%
WebLech 8.9ms 1.1ms 6.4s 219ms 91% 93%
H2 1.6ms 0.17ms 1.0s 79ms 93% 94%
Table 6: Performance of detection algorithms.
Reach-based Reset-then-recover
average worst average worst
Example 0.4ms 153ms 0.5ms( 1.3X ) 507ms( 3.3X )
FileWriter 1.7ms 837ms 2.4ms( 1.4X ) 1.3s( 1.6X )
Loader 0.44ms 197ms 0.48ms( 1.1X ) 319ms( 1.6X )
Manager 0.5ms 269ms 0.58ms( 1.2X ) 317ms( 1.2X )
MergeSort 0.53ms 238ms 0.55ms( 1.0X ) 338ms( 1.4X )
Racey 0.44ms 226ms 0.46ms( 1.0X ) 343ms( 1.5X )
Pool 0.43ms 122ms 0.49ms( 1.1X ) 517ms( 4.6X )
WebLech 8.9ms 6.4s 368ms( 41X) 54.2s( 8.5X )
H2 1.6ms 1.0s 3.7ms( 2.3X ) 1.9s( 1.9X )
ECHO takes only 5ms on average for each change and 6.4s
in the worst case, a 3000X speedup over the whole program
race detector on average and 2.5X in the worst case.
Addition & Deletion. Table 5 compares the perfor-
mance between addition and deletion. Columns 2-3 and
Columns 4-5 report the average and worst case time, respec-
tively, taken by ECHO for adding and deleting a statement.
Columns 6-7 report the percentage of instructions that take
ECHO less than 0.1s to handle. Overall, addition (0.06{
1.1ms on average and 21{219ms in the worst case) is much
faster than deletion (0.4{9ms on average and 112ms{6.4s
the worst). The reason is that addition does not involve the
complex invalidation of existing points-to sets. Nevertheless,
over 91% of all the statements take less than 0.1s .
Reachability-based Deletion vs Reset-then-recover.
Table 6 compares the performance between the reachability-
based and the reset-then-recover algorithms for handling
statement deletions. In the average case, the reachability-
based algorithm takes 0.4{8.9ms per change, whereas the
reset-then-recover algorithm takes 0.46-368ms. In the worst
case, the reachability-based algorithm takes 0.15{6.4s, while
the reset-then-recover algorithm takes 0.3{54s. On aver-
age, the reachability-based algorithm is 4.6X faster than
reset-then-recover for the average case and 2.3X faster for
the worst case. The speedup is more signicant for the
real-world systems. In particular, for WebLech , the reset-Table 7: Results of detected races.
#total #true races #false positives
Example 1 1 0
FileWriter 7 5 2
Loader 4 2 2
Manager 9 6 3
MergeSort 0 0 0
Racey 0 0 0
Pool 0 0 0
WebLech 15 9 6
H2 0 0 0
163:204:URLGetter urlGetter = new URLGetter(conÔ¨Åg); List newURLs = downloadURL(urlGetter...);class Spider run():260:urlGetter.getURL(url); downloadURL():63:if(failureCount>10) {   failureCount=0;} failureCount++;class URLGetter getURL():67:132:T1, T2
Figure 5: False positives on \failureCount" in We-
blech due to the lack of object sensitivity.
then-recover algorithm takes 368ms on average and 54.2s
the worst, while the reachability-based algorithm takes only
8.9ms and 6.4s, respectively, which is 41X and 8.5X faster.
4.2 Recall & Precision
Table 7 reports the results of detected data races by ECHO .
Each race has a unique signature, i.e., a pair of program
statements. For several benchmarks, they have one or more
known data races. We rst studied all the known races and
manually inspected the races reported by ECHO . We found
thatECHO reported all those known races in these bench-
marks. ECHO detected 23 true races and 13 false positives
in total (all these races are available at [13]). The precision
is 64% (23/36) and recall 100%. Nevertheless, ECHO may
still miss certain true races in other Java programs because
of its limited support of language features ( e.g.,ECHO does
not handle reection) and its use of may-alias (as described
in Section 3.3). However, both of these two issues are fun-
damental to static analysis.
False Positives. ECHO reported 13 false positives in
these benchmarks. The false positive ratio is 36% (13/36).
Previous research [12, 1] has shown numerous sources of false
positives raised by static analyses. We identied three main
78335:if(m_iCount>=m_iSize) {   doubleArray();} m_DataArray[m_iCount++] = new Data(data);class DataStorage putData():T1T2int rand = Math.abs(randomizer.nextInt());int count = DataStorage.getInstance().getCount();int place=rand%count;DataStorage.getInstance().getData(place);class DataPrinter run():class DataStorage getData():synchronized (m_sync) {     ret = m_DataArray[place]}getCount():  return  m_iCount; 38:18:19:20:23:43:45:31:Figure 6: False positives on \m DataArray[x]" in
FileWriter due to indistinguishable array indexing.
sources in our experiments:
Object Sensitivity. Identifying static objects by their
allocation sites is imprecise. It can often lead to false posi-
tives between accesses to objects allocated at the same pro-
gram location but are dierent. Consider an example in
WebLech (Figure 5). The program starts two concurrent
threads, both executing the runmethod of the Spider class.
Each thread creates a new URLGetter object at line 163
and uses it to fetch URL, which accesses the object eld
failureCount at lines 63, 67, 132. ECHO reported 6 false
positives on failureCount because the underlying pointer
analysis does not distinguish the two URLGetter objects al-
located at the same site by the two threads.
Indistinguishable Array Indexing. ECHO does not
distinguish between dierent array indexes, which can lead
to false alarms because accesses to dierent elements of the
same array are considered as to the same memory. This issue
can be more complicated when the array indexes are under
complex data ow and path conditions. Consider an exam-
ple in FileWriter (Figure 6). Thread T1writes to a shared
array m_DataArray with index m_iCount at line 38. Thread
T2reads m_DataArray with index place , which is computed
by a random value mod m_iCount . The two indexes cannot
be equal because of the mod operation. ECHO reported 2
false positives in FileWriter due to this problem.
Ad Hoc Synchronization. ECHO handles standard
thread synchronizations in Java such as thread fork,join
and the synchronized keyword but does not recognize ad
hoc synchronizations. Missing ad hoc synchronizations caused
several false positives in our experiments. Due to space rea-
sons we refer the readers to our technical report [27] for a
detailed example of this issue.
These issues open several interesting directions that we
plan to investigate in future work. For example, adding
more object and context sensitivity [28, 29, 16] in the points-
to analysis could reduce false positives. A more precise array
index analysis [30, 31, 32] could alleviate the second issue,
and recognizing ad hoc synchronizations [33, 34, 35] could
further improve the precision of ECHO .
5. RELATED WORK
A large number of static race detection techniques have
been proposed, including many types systems [36, 37, 38,39, 40, 41, 42], scalable whole-program analyses [1, 2, 43,
44, 12], model checking [45, 46], and other specialized tech-
niques [47, 48]. The key advantage of static race detection is
that it provides the potential to detect all races over all pro-
gram paths, which eliminates false negatives, although most
techniques in practice sacrice soundness for scalability.
A primary limitation of static analysis is that it is impre-
cise and may produce false positives. A few sophisticated
data ow analyses [12, 43, 44] have been proposed to improve
precision via more expensive analysis. Compared to existing
techniques, ECHO amortizes the analysis cost across many
small program changes and avoids redundant computation
through change-aware analysis. Moreover, ECHO works in
the IDE and can detect races and warn the developers to x
the races as they are introduced.
Type-based race checking systems [39, 42, 36, 37, 38] can
perform well in the IDE, but they typically require a signif-
icant amount of manual annotations and/or work only for
an ideal language. ECHO is fully automatic without any
annotation and works for a realistic Java-like language.
Praun et al. [49] propose an object use graph (OUG)
model that statically approximates the happens-before re-
lation between accesses to a specic object. The key dier-
ences between OUG and our SHB graph are that the SHB
graph is eld-sensitive while OUG is object-sensitive and
that OUG does not model lock operations.
Points-to analysis has been extensively researched [14, 28,
16, 29, 21, 15] in several dierent dimensions, e.g., ow-
sensitivity, context-sensitivity, heap modeling, etc. Precise
points-to analysis is NP-hard [15]. Any practical points-to
analysis must approximate the exact solution and balance
between precision and performance.
A few incremental and demand-driven points-to analysis
algorithms have been proposed, based on CFL reachabil-
ity [50, 17], logic programming [51], and data ow anal-
ysis [52, 18]. However, demand-driven approaches do not
handle changes, and existing incremental approaches cannot
eciently handle code deletion. Moreover, none of them has
been applied in IDEs for multithreaded programs before.
6. CONCLUSION AND FUTURE WORK
We have presented a new IDE-based static race detection
technique and a tool, ECHO , that can detect data races
as soon as they are introduced into the program. ECHO
is powered by a set of novel change-aware static analyses
that eciently compute change-relevant program informa-
tion upon code changes without re-analyzing the whole pro-
gram. Our results on a variety of multithreaded benchmarks
and real-world Java applications show that ECHO can de-
tect races within milliseconds upon a code change with a
reasonable precision. In future work, we plan to conduct
empirical studies with developers to evaluate the usability
and usefulness of ECHO for diagnosing and xing real races.
We also plan to improve the precision of ECHO by address-
ing the sources of false positives as discussed in Section 4.2.
7. ACKNOWLEDGEMENTS
The authors would like to thank Lawrence Rauchwerger
and the anonymous reviewers for their constructive com-
ments on earlier versions of this paper. This research is sup-
ported by faculty start-up funds from Texas A&M Univer-
sity, a Google Faculty Award, and NSF award CCF-1552935.
7848. REFERENCES
[1] Mayur Naik, Alex Aiken, and John Whaley. Eective
static race detection for Java. In ACM SIGPLAN
Conference on Programming Language Design and
Implementation , pages 308{319, 2006.
[2] Jan Wen Voung, Ranjit Jhala, and Sorin Lerner.
Relay: static race detection on millions of lines of
code. ESEC-Joint European Software Engineering
Conference and ACM SIGSOFT Symposium on
Foundations of Software Engineering, 2007.
[3] Cormac Flanagan and Stephen N. Freund. FastTrack:
ecient and precise dynamic race detection. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation , pages 121{133, 2009.
[4] Je Huang, Patrick O'Neil Meredith, and Grigore
Rosu. Maximal sound predictive race detection with
control ow abstraction. In ACM SIGPLAN
Conference on Programming Language Design and
Implementation , pages 337{348, 2014.
[5] Swarnendu Biswas, Minjia Zhang, Michael D. Bond,
and Brandon Lucia. Valor: Ecient, software-only
region conict exceptions. In ACM SIGPLAN
Conference on Object Oriented Programming,
Systems, Languages, and Applications , 2015.
[6] Veselin Raychev, Martin Vechev, and Manu
Sridharan. Eective race detection for event-driven
programs. In ACM SIGPLAN International
Conference on Object Oriented Programming Systems
Languages and Applications , pages 151{166, 2013.
[7] ThreadSanitizer Documentation.
http://clang.llvm.org/docs/ThreadSanitizer.html.
[8] Intel inspector.
https://software.intel.com/en-us/intel-inspector-xe/.
[9] Go data race detector.
https://golang.org/doc/articles/race ndetector.html.
[10] The True Cost of a Software Bug. http:
//blog.celerity.com/the-true-cost-of-a-software-bug/.
[11] The Eclipse IDE. https://eclipse.org/downloads/.
[12] Dawson Engler and Ken Ashcraft. Racerx: eective,
static detection of race conditions and deadlocks. In
ACM Symposium on Operating Systems Principles ,
2003.
[13] The ECHO webpage.
http://parasol.tamu.edu/~je/echo/.
[14] Yannis Smaragdakis and George Balatsouras. Pointer
analysis. Found. Trends Program. Lang. , 2(1):1{69,
2015.
[15] William Landi and Barbara G. Ryder. Pointer-induced
aliasing: A problem classication. In Proceedings of
the 18th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages , pages 93{103,
1991.
[16] John Whaley and Monica S. Lam. Cloning-based
context-sensitive pointer alias analysis using binary
decision diagrams. In Proceedings of the ACM
SIGPLAN 2004 Conference on Programming Language
Design and Implementation , pages 131{144, 2004.
[17] Yi Lu, Lei Shang, Xinwei Xie, and Jingling Xue. An
incremental points-to analysis with c-reachability. In
Compiler Construction , pages 61{81, 2013.
[18] Jyh-shiarn Yur, Barbara G Ryder, and William A
Landi. An incremental ow-and context-sensitivepointer aliasing analysis. In Proceedings of the 21st
international conference on Software engineering ,
pages 442{451, 1999.
[19] Robert O'Callahan and Jong-Deok Choi. Hybrid
dynamic data race detection. In ACM SIGPLAN
Symposium on Principles and Practice of Parallel
Programming , 2003.
[20] WALA pointer analysis. http://wala.sourceforge.net/
wiki/nnindex.php/UserGuide:PointerAnalysis.
[21] Ben Hardekopf and Calvin Lin. The ant and the
grasshopper: Fast and accurate pointer analysis for
millions of lines of code. In Proceedings of the 28th
ACM SIGPLAN Conference on Programming
Language Design and Implementation , pages 290{299,
2007.
[22] Cormac Flanagan and Shaz Qadeer. A type and eect
system for atomicity. In ACM SIGPLAN Conference
on Programming Language Design and
Implementation , 2003.
[23] T. J. Watson Libraries for Analysis (WALA).
http://wala.sourceforge.net/.
[24] Je Huang. Stateless model checking concurrent
programs with maximal causality reduction. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation , pages 165{174, 2015.
[25] H2 Database Engine. http://www.h2database.com.
[26] WebLech URL Spider. http://weblech.sourceforge.net.
[27] ECHO technical report.
http://parasol.tamu.edu/~je/academic/echo-tr.pdf.
[28] George Kastrinis and Yannis Smaragdakis. Hybrid
context-sensitivity for points-to analysis. In
Proceedings of the 34th ACM SIGPLAN Conference
on Programming Language Design and
Implementation , PLDI '13, pages 423{434, 2013.
[29] Manu Sridharan and Rastislav Bod k.
Renement-based context-sensitive points-to analysis
for java. In Proceedings of the 27th ACM SIGPLAN
Conference on Programming Language Design and
Implementation , PLDI '06, pages 387{400, 2006.
[30] Patrick Cousot, Radhia Cousot, and Francesco
Logozzo. A parametric segmentation functor for fully
automatic and scalable array content analysis. In
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , 2011.
[31] Denis Gopan, Thomas Reps, and Mooly Sagiv. A
framework for numeric analysis of array operations. In
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , 2005.
[32] Nicolas Halbwachs and Mathias P eron. Discovering
properties about arrays in simple programs. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation , 2008.
[33] Weiwei Xiong, Soyeon Park, Jiaqi Zhang, Yuanyuan
Zhou, and Zhiqiang Ma. Ad hoc synchronization
considered harmful. In USENIX Symposium on
Operating Systems Design and Implementation , 2010.
[34] Je Huang and Lawrence Rauchwerger. Finding
schedule-sensitive branches. In Joint European
Conference and ACM SIGSOFT Symposium on
Foundations of Software Engineering , 2015.
[35] Le Yin. Eectively recognize ad hoc synchronizations
785with static analysis. In LCPC , 2013.
[36] Chandrasekhar Boyapati, Robert Lee, and Martin
Rinard. Ownership types for safe programming:
preventing data races and deadlocks. In ACM
SIGPLAN Conference on Object Oriented
Programming, Systems, Languages, and Applications ,
2002.
[37] Nicholas D. Matsakis and Thomas R. Gross. A
time-aware type system for data-race protection and
guaranteed initialization. In ACM SIGPLAN
Conference on Object Oriented Programming,
Systems, Languages, and Applications , 2010.
[38] Chandrasekhar Boyapati and Martin Rinard. A
parameterized type system for race-free Java
programs. In ACM SIGPLAN Conference on Object
Oriented Programming, Systems, Languages, and
Applications , 2001.
[39] Cormac Flanagan and Stephen N. Freund. Type-based
race detection for Java. In ACM SIGPLAN
Conference on Programming Language Design and
Implementation , 2000.
[40] Martin Abadi, Cormac Flanagan, and Stephen N.
Freund. Types for safe locking: Static race detection
for Java. ACM Trans. Program. Lang. Syst. ,
28(2):207{255, 2006.
[41] Bart Jacobs, Frank Piessens, Jan Smans,
K. Rustan M. Leino, and Wolfram Schulte. A
programming model for concurrent object-oriented
programs. ACM Trans. Program. Lang. Syst. ,
31(1):1:1{1:48, 2008.
[42] Cormac Flanagan, K. Rustan M. Leino, Mark
Lillibridge, Greg Nelson, James B. Saxe, and Raymie
Stata. Extended static checking for Java. In ACM
SIGPLAN Conference on Programming Language
Design and Implementation , 2002.
[43] Mayur Naik and Alex Aiken. Conditional must not
aliasing for static race detection. In ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , 2007.
[44] Polyvios Pratikakis, Jerey S. Foster, and Michael
Hicks. Locksmith: context-sensitive correlation
analysis for race detection. In ACM SIGPLANConference on Programming Language Design and
Implementation , 2006.
[45] Thomas A. Henzinger, Ranjit Jhala, and Rupak
Majumdar. Race checking by context inference. In
ACM SIGPLAN Conference on Programming
Language Design and Implementation , 2004.
[46] Vineet Kahlon, Yu Yang, Sriram Sankaranarayanan,
and Aarti Gupta. Fast and accurate static data-race
detection for concurrent programs. In International
Conference on Computer Aided Verication , 2007.
[47] Cosmin Radoi and Danny Dig. Practical static race
detection for Java parallel loops. In Proceedings of the
2013 International Symposium on Software Testing
and Analysis , pages 178{190, 2013.
[48] Vineet Kahlon, Nishant Sinha, Erik Kruus, and Yun
Zhang. Static data race detection for concurrent
programs with asynchronous calls. In Joint European
Software Engineering Conference and ACM SIGSOFT
Symposium on Foundations of Software Engineering ,
2009.
[49] Christoph von Praun and Thomas R. Gross. Static
conict analysis for multi-threaded object-oriented
programs. In ACM SIGPLAN Conference on
Programming Language Design and Implementation ,
2003.
[50] Manu Sridharan, Denis Gopan, Lexin Shan, and
Rastislav Bod k. Demand-driven points-to analysis for
java. In Proceedings of the 20th Annual ACM
SIGPLAN Conference on Object-oriented
Programming, Systems, Languages, and Applications ,
pages 59{76, 2005.
[51] Diptikalyan Saha and C. R. Ramakrishnan.
Incremental and demand-driven points-to analysis
using logic programming. In Proceedings of the 7th
ACM SIGPLAN International Conference on
Principles and Practice of Declarative Programming ,
pages 117{128, 2005.
[52] Steven Arzt and Eric Bodden. Reviser: Eciently
updating ide-/ifds-based data-ow analyses in
response to incremental program changes. In
Proceedings of the 36th International Conference on
Software Engineering , pages 288{298, 2014.
786