Android Testing via Synthetic Symbolic Execution
Xiang Gao‚àó
National University of Singapore, Singapore
gaoxiang@comp.nus.edu.sgShin Hwei Tan‚Ä†
Southern University of Science and Technology, China
tansh3@sustc.edu.cn
Zhen Dong
National University of Singapore, Singapore
zhen.dong@comp.nus.edu.sgAbhik Roychoudhury
National University of Singapore, Singapore
abhik@comp.nus.edu.sg
ABSTRACT
Symbolic execution of Android applications is challenging as it
involves either building a customized VM for Android or modeling
the Android libraries. Since the Android Runtime evolves from one
version to another, building a high-fidelity symbolic execution en-
gine involves modeling the effect of the libraries and their evolved
versions.WithoutsimulatingthebehaviorofAndroidlibraries,path
divergencemayoccurduetoconstraintlosswhenthesymbolicval-
ues flow into Android framework and these values later affect the
subsequentpathtaken.PreviousworkssuchasJPF-Androidhave
relied on the modeling of execution environment such as libraries.
In this work, we build a dynamic symbolic execution engine for
Android apps, withoutany manual modeling of execution environ-
ment.Environment(orlibrary)dependentcontrolflowdecisions
in the application will trigger an on-demand program synthesis
steptoautomatically deducearepresentationofthelibrary.This
representation is refined on-the-fly by running the corresponding
librarymultipletimes.Theoverarchinggoaloftherefinementisto
enhancebehavioral coverageandto alleviatethepath divergence
problem during symbolic execution. Moreover, our library synthe-
siscanbemadecontext-specific.Comparedtotraditionalsynthesis
approaches which aim to synthesize the complete library code, our
context-specificsynthesisenginecangeneratemorepreciseexpres-
sions for a given context. The evaluation of our dynamic symbolic
execution engine, built on top of JDART, shows that the library
modelsobtainedfromprogramsynthesisareoftenmoreaccurate
than the semi-manual models in JPF-Android. Furthermore, our
symbolic execution engine could reach more branch targets, as
compared to using the JPF-Android models.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware testing and de-
bugging;
‚àóCorresponding Author
‚Ä†This work was done by the author at National University of Singapore.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238225KEYWORDS
Android testing, Symbolic execution, Program synthesis
ACM Reference Format:
Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury. 2018.
AndroidTestingviaSyntheticSymbolicExecution.In Proceedingsofthe2018
33rd ACM/IEEE International Conference on Automated Software Engineering
(ASE ‚Äô18), September 3‚Äì7, 2018, Montpellier, France. ACM, New York, NY,
USA,11pages.https://doi.org/10.1145/3238147.3238225
1 INTRODUCTION
Symbolicexecutionisapowerfulprogramanalysistechniquewhich
can simultaneously explore multiple program paths that a pro-
gramcouldtakeunderdifferentinputs.However,itisdifficultto
apply it to framework-oriented Android apps because Android
framework is very complex and it is built with multiple languages.
Moreover,AndroidframeworkcannotbeexecutedoutsideAndroid
devices/emulators.
One common solution to this problem is to manually generate a
framework modelthatsimulatestheframeworkbehaviorbutcan
besymbolicallyexecuted.Forexample,JPF-Android[ 4]relieson
a semi-manual created model of Android framework that can be
symbolicallyexecutedonJava virtualmachine.However,signifi-
canteffortneedstobespentonwritingmodelsofAndroidlibraries.
Accordingto astudy onthe Androidecosystem,Android isevolv-
ingrapidlyatanaveragerateof115APIupdatespermonth[ 18].
The rapid evolution of Android API poses additional challenges
for applying these approaches in practice. To relieve the burden of
writingframeworkmodels,PASKET[ 13]exploresthepossibilityof
synthesizingframeworkmodelsforsymbolicexecution.Itleverages
severaldesignpatterns(e.g,theObserverpatterns)tosynthesize
modelsforseveralclassesinAndroidframeworksandthesemodels
arethenpassedtooff-the-shelfsymbolicexecutionenginewhere
thesymbolicexecutionenginesimplyservesasaseparatevalida-
tionstepforthecorrectnessofthesynthesizedmodels.Insteadof
incorporating the constraints gathered during symbolic execution,
PASKET requires tutorial programs to exercise the target models.
Anotherstandardsolutionistoperformconcreteexecutionof
theframeworkcodetoprovideenvironmentmodelsforsymbolic
execution of a particular code of interest such as app code. Forexample, S
2E[6] performs symbolic execution on specified com-
ponents and concretely executes other components. Meanwhile,existing concolic execution techniques on Android apps such as
ACTEve[ 1]andCollider[ 11]usesinstrumentationfor constraint
tracking. One of the major challenges in such approaches is the
419
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury
problemof pathdivergence wheremissed instrumentationscould
leadtothedivergencebetweentheconcreteandsymbolicexecution
paths[1,10].Moreover,thepathdivergenceproblemmayimpair
thesoundnessandcompletenessoftheconcolicexecution.Without
symbolic execution of framework code, certain path constraints
can be missed when symbolic values flows into the framework.
In this paper, we present synthetic symbolic execution,a se m -
bodied by our tool SynthesiSE. It is a concolic execution approach
for Android apps that aims to alleviate all of the above mentioned
problems.InsteadofrelyingonmanuallywrittenmodelsforAn-
droidframework,ourapproachautomaticallydeducesexpression
representing Android models dynamically during the execution.
When dependent control flow decisions are encountered in sub-
sequent execution, the deduced expression will be refined with
the ultimate goal of enhancing branch coverage and to alleviate
thepath divergenceproblem.Moreover, insteadofgenerating the
entire Android model classes in a single step, our library synthe-
sis is context-specific, which allows it to generate more precise
expression for a given context.
Symbolicexecutionofapplicationsalwaysrequirescaptureofthe
environment,whichincludeslibraries.Thetwoextremeapproaches
are thein-vitroapproach where theeffect of the libraries are mod-
eled,andthe in-vivoapproachwheretheeffectoflibraries/environ-
mentarecapturedviawholesystemexecution.ForCprograms,the
KLEE tool [ 5] embodies the in-vitro approach and the S2E tool [ 6]
embodiesthein-vivoapproach.Atahighlevel,ourapproachlies
inbetweenthein-vivoandin-vitroapproaches.Wedonotmodel
the libraries, and yet we go beyond concrete execution of libraries.
Instead, we synthesize expressions to capture the effect of libraries
with the goal of enhancing branch coverage in testing. We have
implemented a dynamic symbolic execution platform for Android
apps. In summary, we make the following contributions.
‚Ä¢On demand framework synthesis. We present an approach
which synthesizes the relationship between symbolic inputs and
outputsforaframeworklibraryduringconcreteexecution.Using
the deduced relationship, we collect more complete path con-
straints from the programs to explore paths which are missed by
symbolicexecutionduetoconcreteexecutionofframeworkcode.
WeimplementadynamicsymbolicexecutionplatformforAn-
droidappswhichcouldbeusedforenhancingtestingofAndroid
apps. As our approach does not require manual modeling, our
platformisagnostictodifferentAndroidSDKversions.Moreover,
this approach could be used for the symbolic execution of any
code that uses libraries.
‚Ä¢IncorporatingGUIconstraints. AndroidappsrelyonGraph-
icalUserInterface(GUI)tointeractwithusers.GUIconstraint
imposesrestrictionstothelayoutandapplicationresourcesde-
fined in an Android app. Our platform automatically extracts
theseconstraintsandincorporatesthemintosymbolicexecution
for exploration of Android apps.
‚Ä¢Importance of modeling Android libraries We perform a
study of 68 Android apps in the Androtest benchmark [ 7]t o
investigatehowoftentheresultsofinvokingAndroidlibraries
affectthedependentbranchdecisioninAndroidapps.Ourstudyshowsthat37.1%ofbranchesinAndroidappsareaffectedbythe
results of executing Android libraries.‚Ä¢Evaluation. Weevaluateourapproachon14Androidappsby
comparing oursynthesized models against realimplementation
andsemi-manuallycreatedmodelsinJPF-Android.Ourevalua-
tionshowsthatifwetreatallthebranchesaffectedbyanAndroid
library invocation as targets, our synthesized models are able to
reach more targets than the models used in JPF-Android.
2 BACKGROUND
Concolic execution. Concolic execution [ 9] is a program analysis
techniquecombiningconcreteexecutionandsymbolicexecution.
It uses a concrete value cto generate a path œÄc, and uses symbolic
executionalongthepathtocomputea pathcondition pc.System-
atic negation of branch conditions in the path condition pcthen
leadstomodifiedconstraints pc/prime,whichissolvedtogenerateinputs
which trace different paths. The process is repeated to obtain a
test-suite with high path coverage. Concolic execution has beenused to analyze Android apps for event generation [
1], and fault
localization [ 2]. Typically it is performed either on a Java sym-
bolic engine with Android library models, or on Android Runtime
using instrumentation techniques to trace the app execution for
constraintscollectionandexploredifferentpathswithgenerated
inputs.
Program synthesis. Program synthesis has been formalized to be
asecond-orderconstraintsolvingproblemthroughpropositional
synthesisencoding,recentlyin[ 20],andweusethisworkinour
testing method. Given a set of components, it will construct the set
of terms and represent them via a tree. Boolean variables si, called
selector variables, are assigned to choose a particular term from
among a set of terms. Specifically, each leaf of the tree corresponds
tocomponentswithoutinputandintermediatenodehasasmany
subnodes as the maximal number of inputs of a component. Foreach node
iwith sub-node { i1,i2,...,ik}, the output and inputs are
representedby outiand{outi1,outi2,...,outik},respectively.Inaddi-
tion,sj
iis thej-th selector of node i, which means j-th component
is used in this node, Cis the number of components, Fjis the se-
mantics of j-th component. For node i, a set of terms is encoded as
œÜi:=œÜnode‚àßœÜchoice, such that
œÜnode:=|C|/logicalanddisplay.1
j=1sj
i‚áíouti=Fj(outi1,outi2,...,outik)(1)
œÜchoice:=exactlyOne (s1
i,s2
i,...,sC
i) (2)
œÜnodedescribesthesemanticrelationsbetweentheoutputvalueof
nodeiand the output value of its subnode, while œÜchoicerestricts
that onlyone component isselected inside eachnode. Given aset
ofinput-outputpairs,thisalgorithmshouldreturnasetofnodes
satisfyingtheinput-outputrestriction.Usingtheaboveencoding,
thesecond-orderconstraintsolvercanbeimplementedontopof
the first-order solver.
3 THE IMPORTANCE OF MODELING
ANDROID LIBRARIES
To study the importance of encapsulating the constraints given by
Androidlibraries,weperformaninitialinvestigationof68Android
appsintheAndrotestbenchmark[ 7],acommonlyusedbenchmark
inpriorevaluationsofAndroidtestingtechniques[ 17,30].Ourgoal
420
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Android Testing via Synthetic Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
565758595:5;5<5=5>5655
57:5:55<:560555607:560:5560<:570555
7%
'))!!'%
!'"!$ $)"/#.*)
#.""$)''.$(,)%
$$ 1)!$*)(
))'.
"#%("!
*)$#(,',$'!!$  
$*#)$,#"'!+ 1-%!$''''$'!'7
+#$#&*'!-%!$''()*'(#'$$))('$".$ "#$ >"!

(('$
!$ %))'##')$'$!)*!'
#$),'"*!)("((#'*#.-%#(()'$
)$*#)'$"'
'$/#*!!$ (
$$$'#(
"%$')$#))( %
((,$' ''$$)$()'"* ))#(
#$"*(!.'#'$(#).
$*#$'
%'))$()%')-).#.-)%%.)%%')$"'$'#(!)'#!
)')
$	(.)*$'%'((.)/
'#)$'#()*"'$'#()2'#()
A'#()
Figure 1: The number of branches affected by Android library calls and the corresponding percentage
istoinvestigatehowoftentheresultsofinvokingAndroidlibraries
affectthedependentbranchdecisioninAndroidapps.Toachieve
this goal, we perform taint analysis to determine whether there
existsaninformationflowfromAndroidlibrarycallstosubsequent
branches in the evaluated Android apps. Specifically, we modify
FlowDroid [ 3], a taint analysis tool, by specifying all Android li-
braries as ‚Äúsource‚Äù and branches as ‚Äúsink‚Äù to count the numberof paths from ‚Äúsource‚Äù to ‚Äúsink‚Äù. We also instrument apps using
Soot [35] to compute the total number of branches.
Our investigation aims to answer two questions:
Q1:What is the general structure of Android apps in terms of
control flow? What is the number of branches in apps?
Q2:HowwouldtheresultsofinvokingAndroidlibrariesinfluence
the branch decisions in Android apps?
We study Q1 to obtain an overview of the control structure
in Android apps. Our main goal in Q1 andQ2 is to compute the
percentageofbranchdecisionsaffectedbytheresultsofinvoking
Android libraries.
Figure1shows the results of our study. The x-axis in Figure 1
denotesthenamesoftheevaluatedapps,whereasthey-axisonthe
left and the bar represent the number of branches in each app that
areaffectedbytheresultsofinvokingAndroidlibraries.Meanwhile,
thedashedlineandthey-axisontherightofFigure 1denotethe
percentageofbranchesaffectedbyAndroidlibrarycalls,computed
using the equation in the following.
%branches affected =#ofbranches affected
total#of branches
AccordingtoFigure 1,thebranchdecisionsofmostappsareheav-
ily influenced by Android libraries. On average, 37.1% of branches
in the evaluated Android apps are affected by the results of invok-
ing Android libraries. Figure 1also shows that in one extreme case,
although the ‚Äúgestures‚Äù app only contains six branches in total,all of its branches are affected by Android library calls. Overall,
our studydemonstrates ahigh percentageof branchesin Android
apps are affected by Android library calls. Hence, we derive that if
Androidlibrariesarenotproperlymodeledbyasymbolicexecution
engine, the constraints imposed by Android libraries in Android
apps may be lost. Subsequently, the inappropriate modeling of An-
droid libraries may also hinder the ability of a symbolic execution
engine to explore more program branches.1 public boolean onTouchEvent (MotionEvent event) {
2 floatx = event.getX() ;
3 floaty = event.getY() ;
4 intoffset = getOffsetForPosition(x, y);
5 putOffsetInRange(offset);
6. . . }
7 private int putOffsetInRange( into) {
8 intoffset = o;
9 Editable text = getText();
10 intrealLength = text.l ength();
11 if(offset >= realLength)
12 return offset;
13 Editable editable = getText();
14 while(offset >= 0 & & fi ndText( editable , offset)
15 ==‚àí1 && findChip( offset) == null){
16 offset ‚àí‚àí;
17 }
18 return offset;
19 }
Listing1:TheonTouchEventeventhandlerofTagActivity
4 OVERVIEW
We give a high-level overview of synthetic symbolic execution
and SynthesiSE by presenting an example Android application,TagActivity. TagActivity is an Android open-source text tag edi-
tor that generates tags using user text input. Listing 1shows the
simplified source codes of one event handler, onTouchEvent, which
will be invoked when user touches the screen. The execution of
this event handler proceeds as follows: (1) extracting the touchcoordinates (x, y ) (2) invoking Android library method getOffset-
ForPosition withtouchcoordinatesasparameters(3)triggeringa
local method putOffsetInRange which contains at least four path
conditions (including path conditions inside findTextandfindChip)
that are related to the return variable of getOffsetForPosition.
Existingsymbolicexecutionapproachesmayfaceseveralchal-
lengeswhenanalyzingthissimpleAndroidapp.First,pathexplo-
sion may occur when these techniques symbolically execute the
wholeAndroidappandframework.Second,someAndroidlibraries,
suchasgetX,cannotbesymbolicallyexecuted,sinceitwillinvokea
nativecallwhichisimplementedintheClanguage.Althoughexist-
ing symbolic execution techniques could leverage pre-built models
forAndroidlibraries,buildingmodelsisatime-consumingtaskand
the manually/automatically designed model may be imprecise. For
example, in the model of JPF-Android, the method getOffsetForPosi-
tioninListing 1simplyreturnsaconstantglobalvariableTOP_INT.
Another option is to concretely execute Android libraries while
performingsymbolicexecutionofappcode.However,thesymbolic
relationship between the input x,y, and the output offsetwill be
lostifthelibrarycodeisconcretelyexecuted.Therefore,existing
421
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury
 	
 


‚àß!
‚àß
!		
‚àß‚àß =



 
   
	







= 


Figure 2: Workflow of on-demand synthesis for symbolic execution
symbolicexecutionenginescannotgeneratethecorrectinputs(x,y )
toexploreprogrambranchesthatareaffectedbytheoutput(offset ).
To solve the above mentioned problems, SynthesiSE is designed
toefficiently explorebehaviorsthatare constrainedbythereturn
valuesofconcretelyexecutedlibrary.Forexample,ifweconcretely
execute the method getOffsetForPosition, the execution of line 16
(Listing1) is constrained by the concrete execution result. To con-
tinue the symbolic exploration after concrete execution, symbolic
relation between its input and output should be recovered.
The key idea of SynthesiSE lies on the Symbolic-Concrete tran-
sition across the symbolic/concrete execution boundary. The in-
terleaving between symbolic value and concrete value must behandled carefully, to preserve the consistency and completeness.
We now describe how we handle the transition.
Symbolic ‚ÜíConcrete transition When a library that should
beconcretelyexecutedisinvokedanditsparametersaremarked
symbolic,theconcretevaluesfortheargumentsshouldbegener-
ated.Theconcretizationofsymbolicvariablescanaffectsubsequent
path exploration by (incorrectly) ruling out certain paths. S2E uses
a back-and-forth mechanism for switching between symbolic and
concrete execution to ensure the execution consistency [ 6]. Differ-
ent from S2E, SynthesiSE does not suffer from the path missing
problem due to concretization, as it performs concolic execution
fromthebeginningoftheexecution.SynthesiSEretainsconcrete
valueaswellassymbolicvalueforeachvariableateachprogram
point.Therefore,itcandirectlyinvokeaconcreteexecutionwith
the concrete values of its parameters, without affecting the subse-
quent symbolic exploration.
Concrete ‚ÜíSymbolic transition We consider two situations
where concrete value is transferred to symbolic:
‚Ä¢thereturnvalueoflibrarymethodsthatobtainuserinputs
(likegetX()in Listing 1)
‚Ä¢the return value of library method, if its return value is
dependent on its symbolic arguments.
For the first scenario, a new symbolic variable will be created. For
the second scenario, we will illustrate our workflow in Figure 2.
Assumethatthelibrarycode getOffsetForPosition (representedby
Fin Figure 2) should be concretely executed and x,yare symbolic
variables. This method is invoked with the concrete value of its
parameters.Dueto theconcreteexecution,thesymbolicinforma-
tionofparameterscannotflowintotheoutput(offset ).Therefore,
a function Œ¥(x,y)is introduced to represent the Android library
call (F). Meanwhile, the symbolic value of method output (offset )
will be regarded as Œ¥(x,y). In the subsequent execution, there is
path condition Œ¥(x,y)>0 related to variable o. Assume that inthe first iteration of the execution, we explore the left path, then
we can generate a path constraint ( œï‚àßŒ¥(x,y)>0) along with
the concreteexecution. To explore adifferent path, wenegate the
corresponding path condition and provide the generated path con-
straintsœï‚àßŒ¥(x,y)‚â§0tothesolver.Asfunction Œ¥(x,y)isunknown,
asynthesisprocesswillbetriggeredtodeducetherelationbetween
inputs (x,y) and output (offset ). With the initialized expression e,a
newvalue(x‚Äô,y‚Äô )willbegeneratedbysolving œï‚àßŒ¥(x,y)‚â§0‚àßŒ¥=e.
Ideally, the solution (x‚Äô, y‚Äô ) should allow us to explore the target
path.However,sincewecannotensurethatthesynthesizedexpres-
sionŒ¥(x,y)represents Fcorrectly,thissolutionmayfailtofollow
the negated path. If the input ( x‚Äô, y‚Äô) could trigger the execution of
the target path, then we derive a new input. Otherwise, the expres-
sionewill be refined based on the newly generated input (x‚Äô, y‚Äô )
and its corresponding output o‚Äô.
Furthermore, application configurations or UI hierarchy may
impose additional constraints on the variables. In this example,touch coordinates (x, y ) must be within the scope of the screen.
We define such constraints as GUI constraint, which can be missed
by concretely executing library code. Therefore, we introduce a
strategy to collect GUI constraint by parsing app configuration
(XML) and monitoring UI hierarchy.
5 APPROACH
Inthissection,wefirstintroducethenotationsthatweuse,andthen
we present the on-demand program synthesis and the extension of
traditional concolic execution technique. Throughout this section,
Prepresentstheprogramundertest, Xtodenotethesetofsymbolic
variables, and Œ¥to denote the library function to be synthesized.
5.1 On-demand Analysis
Algorithm 1showsthekeystepsinouron-demandanalysisbuilt
on top of existing concolic execution engine. The algorithm op-
erates on an Android app that consists of Java source code with
function calls to Android libraries. The pathExploration procedure
is similar to traditional concolic execution approaches [ 9] where
symbolic execution is run simultaneously with concrete execution
andpathconstraints pcarecollectedalongsidewiththeconcrete
execution. The pathExploration procedure proceeds by invoking
theexecuteConcolic procedure that iterates through each program
statement. For each program statement stmt,executeConcolic pro-
cedure distinguishes between two kinds of statements: (1) state-
mentsthatinvolveinvocationsofAndroidlibrariesand(2)other
statementsthatcanbetreatedasregularJavastatements.Theal-
gorithm will process the second kind of statements by invoking
422
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Android Testing via Synthetic Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Algorithm 1: Syntheticsymbolicexecution;themainproce-
dure is pathExploration
1Procedure executeConcolic(program P, symbolic X)
2symbolic memory S=[x/mapsto‚Üíexpression |x‚ààX];
3concrete memory C=[x/mapsto‚Üívalue|x‚ààX];
4path condition pc:=‚àÖ;
5library functions Œî:=[];
6stmt:=stmt0;// Initial program statement
7whilestmt /nelementExitsdo
8 switchstmtdo
9 casey:=libraryInvocation( v0,v1,...vn)do
10 c:=executeConcrete (stmt);
11 C:=C[y/mapsto‚Üíc];
12 D:={v|v‚àà{v0,v1,...vn}‚àßS[v]/nequalnull};
13 if!isEmpty( D)then
14 s‚ÜêŒ¥({S[d]|d‚ààD});
15 S:=S[y/mapsto‚Üís];
16 Œî:=Œî‚à™Œ¥;
17 end
18 otherwise do
19 executeJavaConcolic (stmt,pc);
20 end
21 end
22 stmt:=P.getNextStmt ();
23end
24return/angbracketleftpc,Œî/angbracketright;
25
26Procedure pathExploration(program P )
27X:=init();
28whileX/nequalnulldo
29 /angbracketleftpc,Œî/angbracketright:=executeConcolic (P,X);
// select one condition to negate
30 pci:=select(pc );
31 pc/prime=¬¨pci‚àß(pc\pci);
32 Œò:={Œ¥|Œ¥‚ààŒî‚àßcontains (pc/prime,Œ¥)};
33 if!isEmpty(Œò) then
34 X: =synthesize( pc/prime,Œò);
35 else
36 X=solve (pc/prime);
37 end
38end
a concolic execution engine for Java programs (lines 18-20). For
the statements that contain invocations of Android libraries, we
assumethattheyareoftheform y:=libraryInvocation (v0,v1,...vn)
where the effect of calling an Android library function will be cap-
tured through its return values1. We execute the statements that
involveAndroidlibraryfunctioncallsandanalyzethestatementtocheck if it satisfies two criteria (1) at least one of the function argu-
mentsissymbolicvariable(line12-13),and(2)itsreturnvalueis
accessed in subsequent branch conditions in the program (line 32).
As our synthesis engine is triggered when an Android library invo-
cation satisfies these two criteria, our synthesis engine is invoked
on-demand. In line 14, the to-be-synthesized function Œ¥collects all
1A function where its return value is not stored is rewritten with new temporary
variable that store the return value.Algorithm 2: Iterative Synthesis
1Procedure synthesize(program P, pathCond pc, func Œ¥)
//<in0,out0>from initial execution
2e=out0;
3R={/angbracketleftin0,out0/angbracketright};
4synthesisIteration =0;
5whilesynthesisIteration <Ldo
6 x/prime:=solve(pc‚àßŒ¥=e);
7 ifUNSAT or UNKNOWN then
8 x/prime:=solve(pc‚àßŒ¥/nequale);
9 ifUNSAT or UNKNOWN then
10 returnnull;// unsatisfiable pc
11 end
12 end
13 /angbracketleftœÄ,rio/angbracketright:=concreteExecution(P, x/prime);
14 R=R‚à™{rio};
15 ifœÄ==tar–¥etthen
16 returnx/prime;
17 else
18 e:=componentBasedSynthesis( R);
19 end
20 synthesisIteration ++;
21end
argumentsofthefunction libraryInvocation thatcontainsymbolic
values. After that, our algorithm maps the return variable yto the
to-be-synthesized function in our symbolic memory S(line 15).
Afterprocessingtheprogramstatementsonline29,theconcolic
executionengineproceedsbypickingaconditiontonegateinordertovisitanewexecutionpath(line30-31).Inlines32-34,ifthemod-
ifiedpathconstraint pc/primecontainstheto-be-synthesizedfunction,
our algorithm will trigger the synthesis procedure to generate new
input to explore a new execution path. Otherwise, our engine will
solve the modified path condition like regular concolic execution.
5.2 Synthesis
One of the main challenges in concolic execution is the problem
whereconcolictestingmaygetstuckinexploringahugenumberof
programpathsbefore reachingthetargetstate[ 16].Oursynthesis
engine aims to solve this problem by synthesizing a representation
for the Android library invocation. Specifically, we consider all the
subsequentbranchdecisionsthataredependentontheresultsof
theAndroidlibraryinvocationasthetargetstates tar–¥et.During
thepathexploration,ageneratedinputmaynotbeabletoreachthe
target states, or no input satisfies the condition of the target states
duetotheinaccuratelibrarysynthesis.Forsuchcases,weconcretelyexecutetheprogramanditerativelyrefinethesynthesizedfunction
until generated inputs reach the target states.
5.2.1 Iterative Refinement. Algorithm 2presentsouriterativere-
finementsteps.Inpractice,pathconditionscollectedbyconcolicengine might be computed with symbolic values from multiple
to-be-synthesizedfunctions.Ouralgorithmrefineseachofthein-
volved functions independently using the same process. For the
sake of simplicity, we demonstrate iterative refinement with a sin-
gle synthesized function in Algorithm 2. Given the input-output
423
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury
Table 1: The categorization of synthesis components
Level Type Elements
1 Constant constants
2 BitWise <<, >>, &, |
3 Arithmetic +, -, *, /
4 Flow-control Ite (If-then-else)5 Array-access array
pair/angbracketleftin0,out0/angbracketrightfrom the initial concrete execution of an Android
library function, the synthesize procedure starts by initializing the
synthesizedexpression etotheoutput out0(constantexpression)
of the Android library function (line 2). Then, our synthesis engine
conjoins the constraint Œ¥=erepresented by the synthesized ex-
pressionwiththepathconstraint pcandpassthisnewconstraintto
theSMTsolver(line6).IfthesolverreturnsUNSATorUNKNOWN,
this unsatisfiability may be caused by pcor the introduced con-
straintŒ¥=e.Therefore,wewilltrytosolve pc‚àßŒ¥/nequale.Ifthesolver
still returns UNSAT or UNKNOWN, that means pcis unsatisfiable
andwedirectlyreturnnull.Otherwise,wegenerateanewinput x/prime,
and perform concrete execution of program Pusing the updated
input to obtain additional input-output pair rio(line 13). When
ouralgorithmhassuccessfullysynthesizedalibraryrepresentation
toreachthetargetstate,wereturnthenewgeneratedinput x/primeto
the concolic execution engine for its path exploration (Section 5.1).
Otherwise,thesynthesisengineaddsanewinput-outputpair rioto
the setRand continue generating new expressions until we reach
the target state or the synthesis iteration exceeds the threshold L.
Thoughthisalgorithmrequiresiterativerefinement,theprogram
will not be concolically executed multiple times. To gather more
input-output pairs, multiple concrete executions are needed, while
the symbolic execution is performed once. Therefore, compared
with traditional concolic execution, this algorithm will not induce
too much overhead.
5.2.2 Core Program Synthesis. Differentfromtraditionalsynthesis
approacheswhichaimtosimulate behaviorsofalibrary,oursyn-
thesisengineisdesignedtosynthesizeanexpressionthatcanguide
path exploration of symbolic execution. We use the recent work of
[20]togenerateexpressionsbyincrementallyfeedinginput-output
pairs.
As mentionedin Algorithm 2, we provideour synthesizerwith
oneinput-outputpairinitially,theniterativelyfeedmorepairsonlyifthesynthesizedexpressiondoesnothelpingeneratingnewinputs
to explore the target state. When the generated input
x/primeby solving
(pc‚àß(Œ¥=e))fails to make real execution follow the target path,
the synthesized expression emust be incorrect. In this situation,
refinement process will be triggered to refine expression e. This
strategydoesnotneedpre-generatedinput-outputpairs,instead,
it will generate new pairs according to the feedback of concrete
execution. Therefore, this strategy needs less input-output pairs to
synthesize an expression to cover more program behaviors.
Moreover,weprovidedifferentcomponentstothesynthesizer
based on an incremental strategy. To reduce the complexity ofsynthesis, we first categorize common components according to
theircomplexity[ 25].Table1showsthecategorizedcomponents.
The first level is ‚ÄúConstant‚Äù, which means that our synthesizer willfirstuseaconstantvaluetorepresentthelibrary.Ifthislevelfailsto
generate expressions that satisfies the input-output relations, then
it will try higher levels with more input-output pairs. This process
willterminatewhenacertainiterationlimitisreachedorwhenit
generatesnewinputsthatexplorethetargetpath(algorithmwill
reach the iteration limit if the target path is infeasible).
5.2.3 Context-Specific. Our synthesisprocess is context-specific,
whichmeansthatwewilltreatthesamemethodinvokedindifferent
programpointsasdifferent.Synthesizingalibrarymethodunder
acertaincontextwillsimplifythesynthesisprocess,becausethe
library method may only show part of its behaviors under this
context(e.g.someexecutionpathsareconstrainedbyglobalstates).
Underacertaincontext,moreprecisemodelscanbesynthesized.
Context-specificsynthesisisusedbecausethegoalofoursynthesis
is not simulating complete library behaviors, instead, synthesizing
a model to help symbolic execution reach more branches.
Weconsiderthe contextofanAndroidapptobetheglobalstates
of the app. In the refinement process, we have to make sure the
functionto-be-synthesizedisinvokedunderthesamecontext,so
thattheinput-outputpairsaregeneratedbasedonsamecontext.We
will illustrate this process using the example in Figure 2. Consider
alibrarycall F(x,y)invokedwith xandyasargument.Let x1and
x2betwoconcretevaluesof x(sameoperationforvariable y).In
Figure2,œïisthepathconstraintbeforetheinvocationof F(x,y),and
x1andx2isobtainedbysolving œï‚àßŒ¥(x,y)‚â§0‚àßŒ¥=e.Sincex1and
x2satisfythepathconstraint œï,theprogramwillreachthemethod
invocation Ffollowing the same path when it is given either x1
orx2as input. Hence either the library invocation is reached with
thesame global state,orthe differenceinglobalstatesat thetime
ofthelibrary invocation F(x)isaccountedfor bythedifferencein
thevalueof x.Thoughoursynthesizedexpressionsdonotmodel
the effect of global states, they adequately capture this situation by
synthesizing expressions on the argument x.
5.3 GUI Constraints
For Android apps, developers often specify certain constraints on
inputsbydefiningconstraintsforUIelements.Theseconstraints
are validated by Android libraries at runtime. For instance, in
appTagActivity, the touch coordinates ( x,y) are extracted at run-
time. Based on our experimental devices, the bound of screen is
[0,0][1440,2879]. This means that xis limited to (0, 1440) while yis
limitedto(0,2879).Wecallthistypeofconstraint GUIconstraint.
GUI constraint collection can be added after line 17 in Algorithm 1
andthenincorporatedtopathcondition pc.AddingGUIconstraints
to the path condition can help the concolic execution engine togenerate valid inputs (i.e., inputs that are accepted by the app).Generating valid inputs is important in ensuring that the errors
foundbyourconcolicexecutionenginecorrespondtorealerrors
that could be replicated in Android devices.
OurconcolicexecutionincorporatesGUIconstraintsintwosteps.
First, we collect the GUI constraints from the Android execution at
runtime.Secondly,weprovideasetoftemplatestotranslateGUI
constraints to constraints that are supported by the SMT solver.
Defining a template is required since GUI constraints are typically
defined in high-level semantics and cannot be directly used by
SMTsolvers.Currently,wesupportsevencommonGUIconstraints
424
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Android Testing via Synthetic Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Table 2: The templates for translating GUI constraints,
wheremandnrepresent attribute values.
Source GUI constraints Translation
Layoutandroid:maxLength=n; android:digit=true 0‚â§i& &i <10n
android:alpha = m 0‚â§m& &m‚â§1.0
android:progress = m; android:max = n 0‚â§m& &m‚â§n
android:maximumAngle = m 0‚â§m& &m <360
UI
hierarchycomboBox:numItems = n 0‚â§i& &i <n
list:numItems = n 0‚â§i& &i <n
bound=[0,0][m,n] 0‚â§x<m&&0‚â§y<n
	

	 
	



Figure 3: Architecture of our implementation SynthesiSE.
shown in Table 2. This list of supported GUI constraints can be
easily extended.
5.4 Handling Library Functions with Side
Effects
As capturing the effect of an Android library invocation via its
returnvaluemaynotbesufficientforlibraryfunctionswithsideef-
fects, we handle the potential imprecision caused by methods with
sideeffectsbymitigatingthisissueforcertainAndroidlibraryfunc-
tions. Specifically, we analyze Android libraries that are accessor
methods(getters) if it has a corresponding mutator methods (set-
ters) that are invoked before the execution of the mutator method
withinthesameclass.Foreachmutatormethod(e.g., setX(val) )
thatchangesthevalueofafield,westorethevalueinamapand
we use this value for representing the subsequent accessor method
(e.g., val=getX() ).Similarstrategycanalsobeusedforlibraryfunc-
tions related to inter-process communication (Intent) and database
access.
6 IMPLEMENTATION
ToperformconcolicexecutionofAndroidapp,wereusethecon-
colicexecutionenginedesignedforJavaprograms.Duringconcolic
execution,whenencounteringacalltoAndroidAPI(fromAndroid
framework), it communicates with Android device/emulator to ob-
tain the runtime value for the result of the API call. If the Android
libraryinvocationsatisfiesthecriteriadefinedinSection 5.1,itwill
trigger a synthesis process.
Figure3showsthearchitectureofourimplementationSynthe-
siSE(implementedinJava),whichcomprisesofthreelayers:con-
colic executor, JVM-Android communicator, and Java and Android
execution environments.Concolic executor
. We implement our synthesis engine based on
the recent work of [ 20] which embodies program synthesis via
second-order constraint solving; this is partly because [ 20] hasbeensuccessfullyusedforlibrarymodeling.WechooseJDART[ 15]
(GitHub commit id 6584bd0) as the concolic engine of SynthesiSE.
JDART, which has been used to test industry programs, is devel-
oped as an extension to Java Pathfinder (JPF) [ 37]. The concolic
engine can be easily replaced by other engines since our approach
does not require modifications of the concolic execution engine,
InSynthesiSE,weuseMicrosoftZ3[ 8]astheSMTsolversinceit
supports constraints containing complex arithmetic operations.
JVM-Android communicator . The Android-related statements
will be delegated to the Android devices/emulators so that the Java
concolic engine does not need to execute them. We implement An-
droid execution delegator on top of the Model Java Interface (MJI2)
component supported by JPF and JDART, which allows delegating
theexecutionofthespecifiedmethodstothehost-VMfromthecon-
colic engine.Furthermore, we leverage theAndroid Debug Bridge
(ADB) to communicate with a device/emulator from one desktop.
Execution environments . Our concolic execution runs in the
Java environment. The concrete execution of Android apps can
runonrealdevices/emulatorssothatourconcolicexecutioncan
analyze Android apps in a real Android environment.
7 EVALUATION
WeperformevaluationontheeffectivenessofSynthesiSEinsyn-
thesizing Android library methods, and its ability to enhance code
coverageofsymbolicexecution.Ourevaluationaimstoaddressthe
following research questions:
RQ1If we treat all the branches affected by an Android library
invocation as targets, howmany targets can we reach with
our synthesized model?
RQ2What is the quality of the synthesized library code? How
many iterations are needed for our synthesis engine?
7.1 Subject Selection
To compare our synthesized library models with other existing
models,weevaluateourgeneratedmodelsagainstthemodelsin
JPF-Android[ 4].WechoosetoevaluateagainstthemodelsinJPF-
Android3because (1) it contains a large number of models (a set of
modelsdevelopedoveracourseofseveralyears);and(2)allofthese
modelsarepubliclyavailable.SomeofthemodelsinJPF-Android
are manually crafted, whereas others are automatically generated
usingOCSEGen[ 34](theseautomaticallygeneratedmodelmethods
will return default values). Thedetails of our selection process are
described below:(1)
Asitisdifficulttodistinguishbetweenmanuallycraftedmodels
and automatically generated models, we first obtain the set
of Android library methods that have been modeled by JPF-
Android.Amongthesupportedlibrarymodels,weonlyconsider
the library methods with at least one input of primitive type
and output of primitive type.
(2)We randomly select 20 methods for our evaluation because we
need to manually assess the quality of each synthesized library
methods.
(3)Foreachofthese methods,wesearchthroughGitHub forAn-
droid apps that invoke these methods.
2https://babelfish.arc.nasa.gov/trac/jpf/wiki/devel/mji
3https://bitbucket.org/heila/jpf-android/src
425
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury
Table 3: Statistics for the selected Android library calls
Method Class Description App LOC
calculateSignalLevel WifiManager Calculates the level of the signal. WifiScanner 875
checkSignatures PackageManager Compare the signatures of two packages CatLogDonate 3.5K
compareSignalLevel WifiManager Compare Signal level GoProClose 3.4K
getAttributeResValue AttributeSetImpl Return the value of ‚Äôattribute‚Äô as a resource identifier. MusicXiaMi 3.4K
getColor ContextCompat Retrieve the color value for the attribute at index MyLeafPic 16K
getDefaultSize View Utility to return a default size constrained by input AudioVideoRecord 12K
getDimensionPixelOff TypedArray Retrieve a dimensional offset in raw pixels Marketing 738
getIndex TypedArray Returns an index in the array that has data. RobolectricIssue 100
getIntExtra Intent Retrieve extended data from the intent. twowayActivity 156
getLayoutDimension TypedArray Retrieving ViewGroup‚Äôs layout_width and layout_height attributes PrecentAdaptation 579
getOffsetForPosition TextView Get the character offset closest to the specified absolute position. TagActivity 1.5K
nextSpanTransition SpannableStringBuilderReturn the first span offset that is greater than the first parameter,
or parameter itself.SecHandTreak 3.6K
resolveSize View Reconcile a desired size and state, and return only masked bits Surrounding-scanner 425
resolveSizeAndState View Reconcile a desired size and state constrained by input Paper-scissors 719
(4)FromtheGitHubsearchresults,weselectthefirstappwhere
at least one of its branches are affected by the output of the
corresponding library methods. We exclude six methods where
the outputs of these methods do not affect any branch decision
in the evaluated Android apps.
Overall, we select 14 Android apps using the process mentioned
above.Table 3showstheselectedsubjectsaswellastheirstatistics,
where the Classcolumn represents the class in which the corre-
sponding method is defined. Meanwhile, the Description column
givesabriefdescriptionofeachmethodaccordingtotheGoogle
API document. The last two columns show the open-source An-
droid apps that usethe corresponding method, and the line of code
(LOC) of these apps.
7.2 Experimental Setup
We conduct two experiments to answer our research questions. To
answerRQ1, we regard all the branches affected by the invocation
of the given library method as targets. We manually generate an
event sequence that can reach the method (in app code) where the
correspondinglibrarymethodisinvoked.Basedonthegenerated
event sequence, concolic execution will generate data inputs, envi-
ronment inputs, etc, to reach the targets. We evaluate how many
targetscan be reached with three variants of concolic execution:
Concrete Concolic execution with concretely executing Android
library method (without synthesis).
SynthesiSE Concolic execution with concretely executing An-
droid library method and on-demand synthesis.
JA Model Concolic execution with JPF-Android models.
The comparison of the first two approaches aims to investigate
whether our synthesis could help concolic execution explore more
affected branches. Meanwhile, the comparison with existing model
evaluatesexistingmanual/automatedmodelingstrategy.Wechoose
to use the JPF-Android models instead of the tool itself because (1)
JPF-Androidrequiresuserstomanuallywritetheinputsequence
andapplication-specificmodelswhichwouldrequirealmostone
dayforeachsubjectapp[ 4];and(2)weneedtoensurethatthecon-
colicexecutionengineusedinallvariantsisthesametofacilitateafair comparison between the synthesized library methods and the
JPF-Android models.
Our synthesis terminates when we find new inputs that can
coverthetargetbranchorwhenthenumberofiterationsexceedsa
certainlimit(weuse synthesisIteration =20forourexperiment).
To answer RQ2, we evaluate SynthesiSE by manually analyzing
the synthesized expressions obtained from RQ1. Our analysis eval-
uatesthecorrectnessofoursynthesizedexpressionscomparedto
the real library and JPF-Android models.
WeconductalltheexperimentsonarealAndroiddevice(LGG6,
AndroidOSv7.0,API24).Fortheconcolicexecutionengine,wecon-
figureittouseZ3forconstraintsolving(symbolic.dp=z3)andreuse
otherdefaultconfigurations(symbolic.dp.z3.bitvectors=true)[ 15].
We run our concolic execution engine on a desktop (Ubuntu 16.04,
Intel Core i7-2600 3.40GHz processor, 8GB Memory).
7.3 Results
Target reachability. As our synthesized models will only induce
differencesincodecoverageforbranchesthataredependentonthe
resultsofAndroidlibraryinvocations,weregardthosebranches
astarget. Table 5shows the number of reached targetsfor each
subjectbyeachvariant.The #Targetscolumnrepresentsthetotal
number of targets,whereas the SynthesiSE, JA Model andConcrete
columns indicate the number of reached targetsusing synthesis,
JPF-Androidmodelandconcretevalues,respectively.Ifwecompare
thereached targetsbySynthesiSEandconcolicexecutionusingJPF-
Androidmodel,SynthesiSEoutperformstheJPF-Androidmodelsin
itsabilitytoreachmore targetsformostofthesubjects.Specifically,
SynthesiSE reach more targetsin nine subjects. For the subjects
markedwith NA,SynthesiSEcouldnotsynthesizeexpressionsto
reach more targetsas it reaches its limit during the synthesis it-
erations. Specifically, SynthesiSE reach one more targetthan the
JPF-Android model for the checkSignatures method because the
JPF-Android model throws an exception. For the getIntExtra and
compareSignalLevel methods, both synthesis and JPF-Android pro-
videcorrectmodels.Comparedtoconcolicexecutionwithconcrete
values,SynthesiSEreachmore targetsexceptfor:(1)twosubjects
426
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Android Testing via Synthetic Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
Table 4: Synthesized results
Method #synthesis Time(s) Synthesis Type Synthesized Correctness JA model
calculateSignalLevel 3 29 Arithmetic 0.18*x1+18 C2 Constant(0)
checkSignatures Reach Limit 336 No No - Exception
compareSignalLevel 2 15 Arithmetic x1 - x2 C1 x1 - x2
getAttributeResValue Reach Limit 438 No No - Constant(0)
getColor 13 156 Array-access array(x1->y) C2 x2
getDefaultSize 4 28 BitWise x2 & 0xbfffffff C2,C3 TOP_INT
getDimensionPixelOff 15 192 Array-access array(x1->y) C2 x2
getIndex 14 204 Array-access array(x1->y) C2 Canstant(0)
getIntExtra 1 10 Set-get put ->get C1 Map
getLayoutDimension 12 120 Array-access array(x1->y) C2 x2
getOffsetForPosition 4 35 Arithmetic x1/30-0.13 C2 TOP_INT
nextSpanTransition 2 28 Arithmetic x2 C3 Constant(0)
resolveSize 4 42 BitWise x2 & 0xbfffffff C2,C3 TOP_INT
resolveSizeAndState 5 54 BitWise & ITE (x2==0)? 0:x2&0xbfffffff C2,C3 TOP_INT
Table5:Affectedbranchesreachedwithsynthesizedmodels,
JPF-Android models and concrete values
Method #Targets#reached targets
SynthesiSE JA Model Concrete
calculateSignalLevel 2 2 1 1
checkSignatures 2 (NA)1 (Exception)0 1
compareSignalLevel 2 2 2 1
getAttributeResValue 2 (NA)1 1 1
getColor 18 18 1 1
getDefaultSize 4 4 2 2
getDimensionPixelOff 8 4 4 4
getIndex 3 3 1 1
getIntExtra 5 5 5 1
getLayoutDimension 8 6 4 4
getOffsetForPosition 8 6 3 3
nextSpanTransition 2 2 1 1
resolveSize 4 4 1 1
resolveSizeAndState 2 2 1 1
thatSynthesiSEfailtosynthesizeexpressions;(2)onesubject getDi-
mensionPixelOff, where some targetsare unreachable in the single
test input used for concolic execution.
SynthesiSE is able to reach more targetsthat are affected
by library output.
Synthesis result. Table4shows the synthesis results, where
#synthesis is the number of synthesis iterations and Synthesis Type
indicate the type of synthesized expression. The Timecolumn rep-
resents the time taken to infer each of the stubs, which is corre-
lated with the number of synthesis iterations. On average, it takes
103s to synthesize the final expression. The Synthesized column
shows the simplified expression, where x1, x2 represent the first
and second parameter respectively and y represents the output.
The supported synthesis type (component) includes ‚ÄúConstant‚Äù,
‚ÄúArithmetic‚Äù, ‚ÄúBitWise‚Äù, ‚ÄúITE (if-then-else)‚Äù and ‚ÄúArray-access‚Äù. We
also include "Set-get" (explained in Section 5.4) as a synthesis type.
Among the 14 subjects, four of the synthesized expressions are
arithmetic,threeofthemarebitwise operation,fourexpressions
are synthesized by Array-access, one expression synthesized usingITE, and one is handled by Set-get. Table 4shows that the number
of synthesis iterations for the ‚ÄúArithmetic/Bitwise‚Äù expression isless than the ‚ÄúArray-access‚Äù expression because we give higher
priority to Arithmetic/Bitwise component (Table 1). Meanwhile, li-
brary methods that require access to Android resources are usually
synthesized using Array-access. For example, the method getColor
which extracts color values based on resource id, is synthesized
using Array-access.
SynthesiSEgeneratesexpressionsfor12outof14evaluated
method libraries within the iteration limit.
Correctness Wemanuallycompareeachsynthesizedexpression
withcorrespondingmethodinAndroidframeworkandJPF-android
model. If the semantic of the synthesized expression is different
fromthereallibrary,wefurtherinvestigatethecontext-specificandconditionalcorrectness.Givenasynthesizedexpression
libsyn,and
itscorrespondingimplementationinAndroidframework libreal,
we measure the correctness of libsynusing three criteria:
(C1) Correct: libsyniscorrectifandonlyif libsynandlibreal
always produce the same semantic behavior.
(C2) Conditionally Correct: libsynisconditionallycorrectif
libsynandlibrealshow the same behavior for a range of inputs.
(C3) Context-specific Correct: libsynis context-specific cor-
rect iflibsynandlibrealshow the same behavior under certain
context (e.g. global variables).
IntheCorrectness column,wemarktwocaseswith‚Äú-‚Äùbecause
our synthesis engine reaches its iteration limit for these cases.
Specifically, the correct expression of checkSignatures andgetAt-
tributeResValue should involveobject comparison, which oursyn-
thesis does not support. These two cases do not synthesize code
which can be classified as C1, C2 or C3.
TheCorrectness column denotes the correctness category for
eachsynthesizedexpression.Overall,oursynthesisenginegener-
ates correct expressions for two library methods. Meanwhile, nine
ofthesynthesizedexpressionsareconsideredconditionally-correct
expressions. Among these conditionally-correct expressions, three
expressions are context-specific at the same time. Our synthesis
enginemaygenerateconditionally-correctexpressionbecause(1)
the synthesis process terminates once new inputs exploring target
427
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Xiang Gao, Shin Hwei Tan, Zhen Dong, and Abhik Roychoudhury
patharegenerated,and(2)theinput-outputpairmaynotbeableto
cover all behaviors. If more input-output pairs are given, then our
synthesis engine will be able to generate more correct expressions.
For example, the synthesized expression for calculateSignalLevel is
(0.18*x1+18).Thissynthesizedexpressioniscorrectforallinputs,
except for cases where the real library will return 0 if x1 is less
than a constant variable MIN _RSSI. Given more input-output pairs
(e.g.<MIN_RSSI-1, 0 >), SynthesiSE will be able to generate a more
precise expression. Meanwhile, we synthesize four context-specific
correct expressions. These expressions simulate the (simplified)
behaviors of the library only under certain context (global states).
Alloftheexpressionssynthesizedwithintheiterationlimit
are correct, conditionally-correct or context-specific correct.
7.4 Threat to Validity
Internal validity: There are several internal threats in the experi-
mental methodology that may affect our results. While there are
several symbolic execution engines that rely on library models,
we only compare our synthesized models against the JPF-Android
modelsbecausetheyarepubliclyavailableandarecraftedspecifi-
callyforAndroidlibraries.Oursynthesisengineterminatesafter
20 refinement iterations, we did not investigate the effect of differ-
ent iteration limits on the synthesis results. Nevertheless, for most
subjectsinourevaluation,asmallnumberofsynthesisiterations
is sufficient to synthesize the desired expression. Moreover, we
manually evaluate the correctness of the synthesized expression.
AstheimplementationofAndroidframeworkisopen-source,the
analysis is relatively straightforward.
External validity: Ourstudyis limitedtotheevaluatedAndroid
appsandourresultsmaynotgeneralizebeyondtheevaluatedapps.
8 RELATED WORK
Symbolic/concolicexecution .Thereexistsseveralsymbolic/con-
colicexecutionframeworks.S2E[6]embodiesthein-vivoapproach
toperformexplorationofprogramsinsidecomplexsystems.Similar
toourwork,S2Edoesnotrequiremodelingoflibrariesbutitdif-
fers from SynthesiSE in two aspects. First, S2E performs symbolic
execution while SynthesiSE conducts concolic execution. After
symbolic variables are concretized (for concrete execution), S2E
stops exploring paths constrained by these variables and uses a
backtracking mechanism to alleviatethis issue. SynthesiSE solves
this issue by maintaining both symbolic values and concrete val-
ues. Second, SynthesiSE leverages program synthesis for deducing
the relations between inputs and outputs, whereas S2E may ob-
tain incomplete constraints when symbolic information flows into
libraries. KLEE [ 5] embodies the in-vitro approach which relies
on manually-written POSIX libraries. Symbolic Pathfinder [ 26,27]
(SPF) is an extension of JPF, which uses Java library models. Dif-
ferent from these approaches, SynthesiSE do not model libraries,
instead, we synthesize expressions to capture the effect of libraries.
Program synthesis for symbolic execution . We use program
synthesis[ 20]whichembodiesprogramsynthesisviasecond-order
constraint solving, to synthesize a representation for Android li-
brary.Toincreasethescalabilityofprogramsynthesis,oursynthesis
engineadaptsthecategorizationofcommoncomponentsinpriorwork that synthesizes program expression to patch software er-
rors [25]. Although the models synthesized by PASKET [ 13]a r e
alsousedinasymbolicexecutionengine,itssynthesisalgorithm
is driven by several commonly used design patterns. Meanwhile,
SynthesiSE synthesizes libraries to drive the program execution to
unexploredprogrambranchesandtorelieftheprogramdivergence
problem. Qi et al. [ 28] synthesize library models by sampling be-
haviorsoftheoriginalimplementationofafunction.SynthesiSE
synthesizeslibrarymodelusinginput-outputspecificationsandthe
feedback about branch reachability.
Android testing via symbolic/concolic execution .Extensions
of Symbolic Pathfinder (e.g., JPF-Android [ 36], PathDroid [ 24] and
Mirzaei‚Äôs work [ 23]) conduct symbolic execution on Android apps
in JVM by modeling Android libraries which require significant
manual effort to adapt to the rapidevolution of Android versions,
while SynthesiSE is designed to solve this problem. SymDroid [ 12]
isasymbolicexecutorforDalvikbytecode,whilejpf-mobile[ 14]
attempts to run JPF on Android systems. Both approaches have
been evaluated only on small demo apps. Applying symbolic/con-
colic execution to GUI testing has beenexplored in several works:
ACTEve [ 1], Collider [ 11], AppIntent [ 38], ConDroid [ 29], and SIG-
Droid[22].Thosetoolsuseseitherinstrumentationorsimplified
models. Instrumentation based approaches (including ACTEve [ 1],
[11],etc)maysufferfrompathdivergenceproblemasmissedinstru-
mentations could lead to the divergence between the concrete and
symbolicexecutionpaths.TherefinementprocessinSynthesiSE
is able to address this problem. Approaches based on library stubs,
including ConDroid [ 29] and SIGDroid [ 22] (does not consider An-
droid framework in symbolic execution) may miss many path con-
straints.Inconstrast,SynthesiSEleverageson-demandsynthesisto
deduce a model to simulate Android libraries. Meanwhile, crashes
foundby ourapproach couldbeused asinputsfor existingrepair
approaches for automatically fixing these crashes [19, 21,31‚Äì33].
9 CONCLUSION
Wepresent syntheticsymbolicexecution,anditsrealizationviaacon-
colic execution engine that leverages a novel on-demand program
synthesisfortestingAndroidapps.Programsynthesisisiteratively
invoked to generate library code which can help achieve greaterbranch coverage in testing of Android apps. We believe our ap-
proach shows promise in terms of solving the rather hard problem
of environment behavior capture in symbolic execution, since li-
braries are a form of environment. Our work shows the promise of
symbolic executiontechniques whichneither manuallymodel the
environment,nordependonwholesystemexecutionstocapture
the environment via under-approximations.
ACKNOWLEDGEMENT
ThisresearchispartiallysupportedbytheNationalResearchFoun-
dation, Prime Minister‚Äôs Office, Singapore under its Corporate Lab-
oratory at University Scheme, National University of Singapore,
and Singapore Telecommunications Ltd.
REFERENCES
[1]SaswatAnand,MayurNaik,MaryJeanHarrold,andHongseokYang.2012. Auto-
matedConcolicTestingofSmartphoneApps.In ProceedingsoftheACMSIGSOFT
20th International Symposium on the Foundations of Software Engineering (FSE
2012). ACM, Article 59, 11 pages.
428
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Android Testing via Synthetic Symbolic Execution ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
[2]Shay Artzi, Julian Dolby, Frank Tip, and Marco Pistoia. 2010. Directed test
generation for effective fault localization. In Proceedings of the 19th international
symposium on Software testing and analysis (ISSTA 2010). ACM, 49‚Äì60.
[3]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bar-
tel,JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014.
FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware
Taint Analysis for Android Apps. In Proceedings of the 35th ACM SIGPLAN Con-
ference on Programming Language Design and Implementation (PLDI 2014). ACM,
259‚Äì269.
[4]Heila Botha, Oksana Tkachuk, Brink van der Merwe, and Willem Visser. [n.
d.]. Addressing Challenges in Obtaining High Coverage when Model Checking
AndroidApplications.In Proceedingsofthe24thACMSIGSOFTInternationalSPIN
Symposium on Model Checking of Software (SPIN 2017). ACM, 31‚Äì40.
[5]Cristian Cadar, Daniel Dunbar, and Dawson Engler. 2008. KLEE: Unassisted and
AutomaticGenerationofHigh-coverageTestsforComplexSystemsPrograms.
InProceedings of the 8th USENIX Conference on Operating Systems Design and
Implementation (OSDI 2008). USENIX Association, 209‚Äì224.
[6]Vitaly Chipounov, Volodymyr Kuznetsov, and George Candea. 2011. S2E: A
platformforin-vivomulti-pathanalysisofsoftwaresystems.In Proceedingsofthe
16th international conference on Architectural support for programming languages
and operating systems (ASPLOS 2011), Vol. 46. ACM, 265‚Äì278.
[7]Shauvik Roy Choudhary, Alessandra Gorla, and Alessandro Orso. 2015. Auto-
mated test input generation for android: Are we there yet?(e). In 30th IEEE/ACM
International Conference on Automated Software Engineering (ASE 2015). IEEE,
429‚Äì440.
[8]LeonardoDeMouraandNikolajBj√∏rner.2008. Z3:AnEfficientSMTSolver.In
14th International Conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS 2008/ETAPS 2008). Springer, 337‚Äì340.
[9]PatriceGodefroid,NilsKlarlund,andKoushikSen.2005. DART:directedauto-
mated random testing. In Proceedings of the 2005 ACM SIGPLAN conference on
Programming language design and implementation (PLDI 2005), Vol. 40. ACM,
213‚Äì223.
[10]Patrice Godefroid, Michael Y Levin, David A Molnar, et al .2008. Automated
whiteboxfuzztesting.In TheNetworkandDistributedSystemSecuritySymposium
(NDSS 2010), Vol. 8. 151‚Äì166.
[11]Casper S. Jensen, Mukul R. Prasad, and Anders M√∏ller. 2013. Automated Testing
withTargetedEventSequenceGeneration.In Proceedingsofthe2013International
Symposium on Software Testing and Analysis (ISSTA 2013). ACM, 67‚Äì77.
[12]Jinseong Jeon, Kristopher K Micinski, and Jeffrey S Foster. 2012. SymDroid:
Symbolic execution for Dalvik bytecode.
[13]JinseongJeon,XiaokangQiu,JonathanFetter-Degges,JeffreyS.Foster,andAr-
mandoSolar-Lezama. 2016. SynthesizingFrameworkModelsfor SymbolicExe-
cution.In Proceedingsofthe38thInternationalConferenceonSoftwareEngineering
(ICSE 2016). ACM, 156‚Äì167.
[14]AlexanderKohan,MitsuharuYamamoto,CyrilleArtho,YoriyukiYamagata,Lei
Ma, Masami Hagiya, and Yoshinori Tanabe. 2017. Java Pathfinder on Android
Devices. SIGSOFT Software Engineering Notes 41, 6 (Jan. 2017), 1‚Äì5.
[15]Kasper Luckow, Marko Dimja≈°eviƒá, Dimitra Giannakopoulou, Falk Howar, Malte
Isberner,TemesghenKahsai,ZvonimirRakamariƒá,andVishwanathRaman.2016.
JDart:Adynamicsymbolicanalysisframework.In InternationalConferenceon
Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2016) .
Springer, 442‚Äì459.
[16]Rupak Majumdar and Koushik Sen. 2007. Hybrid concolic testing. In Proceedings
of the 29th international conference on Software Engineering (ICSE 2007). IEEE,
416‚Äì426.
[17]KeMao,MarkHarman,andYueJia.2016. Sapienz:Multi-objectiveAutomated
Testing for Android Applications. In Proceedings of the 25th International Sympo-
sium on Software Testing and Analysis (ISSTA 2016). ACM, 94‚Äì105.
[18]Tyler McDonnell, Baishakhi Ray, and Miryung Kim. 2013. An empirical study of
apistabilityandadoptionintheandroidecosystem.In 29thIEEEInternational
Conference on Software Maintenance (ICSM 2013). IEEE, 70‚Äì79.
[19]SergeyMechtaev,XiangGao,ShinHweiTan,andAbhikRoychoudhury.2018.
Test-equivalenceAnalysisforAutomaticPatchGeneration. ACMTrans.Softw.Eng. Methodol. (2018), To Appear.
[20]Sergey Mechtaev, Alberto Griggio, Alessandro Cimatti, and Abhik Roychoud-
hury.2018. SymbolicExecutionwithExistentialSecond-OrderConstraints.In
Proceedings of The 26th ACM Joint European Software Engineering Conference and
Symposium on the Foundations of Software Engineering (ESEC/FSE 2018). ACM.
[21]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scal-
able multiline program patch synthesis via symbolic analysis. In Proceedings
ofIEEE/ACM 38thInternationalConferenceonSoftwareEngineering (ICSE2016).
IEEE, 691‚Äì701.
[22]Nariman Mirzaei, Hamid Bagheri, Riyadh Mahmood, and Sam Malek. 2015. SIG-
Droid:AutomatedsysteminputgenerationforAndroidapplications.In 2015IEEE
26th International Symposium on Software Reliability Engineering (ISSRE 2015).
IEEE, 461‚Äì471.
[23]Nariman Mirzaei, Sam Malek, Corina S PƒÉsƒÉreanu, Naeem Esfahani, and Riyadh
Mahmood.2012.Testingandroidappsthroughsymbolicexecution. ACMSIGSOFT
Software Engineering Notes 37, 6 (2012), 1‚Äì5.
[24]NASA. 2013. PathDroid. https://ti.arc.nasa.gov/opensource/projects/pathdroid/
[25]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra.2013. Semfix:Programrepairviasemanticanalysis.In Proceedingsofthe2013
International Conference on Software Engineering (ICSE 2013). IEEE, 772‚Äì781.
[26]Corina S PƒÉsƒÉreanu and Neha Rungta. 2010. Symbolic PathFinder: symbolic exe-
cution of Java bytecode. In Proceedings of the IEEE/ACM international conference
on Automated software engineering (ASE 2010). ACM, 179‚Äì180.
[27]Corina S PƒÉsƒÉreanu, Willem Visser, David Bushnell, Jaco Geldenhuys, Peter
Mehlitz, and Neha Rungta. 2013. Symbolic PathFinder: integrating symbolic
execution with model checking for Java bytecode analysis. Automated Software
Engineering 20, 3 (2013), 391‚Äì425.
[28]Dawei Qi, William N Sumner, Feng Qin, Mai Zheng, Xiangyu Zhang, and Abhik
Roychoudhury.2012. Modelingsoftwareexecutionenvironment.In 19thWorking
Conference on Reverse Engineering (WCRE 2012). IEEE, 415‚Äì424.
[29]Julian Sch√ºtte, Rafael Fedler, and Dennis Titze. 2015. ConDroid: Targeted Dy-
namic Analysis of Android Applications. In 2015 IEEE 29th International Confer-
ence on Advanced Information Networking and Applications. 571‚Äì578.
[30]TingSu,GuozhuMeng,YutingChen,KeWu,WeimingYang,YaoYao,GeguangPu,
YangLiu,and ZhendongSu.2017. Guided,StochasticModel-basedGUITesting
of Android Apps. In Proceedings of the 2017 11th Joint Meeting on Foundations of
Software Engineering (ESEC/FSE 2017). ACM, 245‚Äì256.
[31]ShinHweiTan,ZhenDong,XiangGao,andAbhikRoychoudhury.2018.Repairing
CrashesinAndroid Apps.In Proceedingsofthe40th InternationalConferenceon
Software Engineering (ICSE 2018). IEEE, 187‚Äì198.
[32]Shin Hwei Tan and Abhik Roychoudhury. 2015. relifix: Automated repair of soft-
ware regressions. In Proceedings of the 37th InternationalConference on Software
Engineering (ICSE 2015). IEEE, 471‚Äì482.
[33]ShinHweiTan,HiroakiYoshida,MukulRPrasad,andAbhikRoychoudhury.2016.
Anti-patterns in search-based program repair. In Proceedings of the 2016 24th
ACMSIGSOFTInternationalSymposiumonFoundationsofSoftwareEngineering
(FSE 2016). ACM, 727‚Äì738.
[34]Oksana Tkachuk. 2013. OCSEGen: Open components and systems environment
generator. In Proceedings of the 2nd ACM SIGPLAN International Workshop on
State Of the Art in Java Program analysis. ACM, 9‚Äì12.
[35]RajaVall√©e-Rai,PhongCo, EtienneGagnon,Laurie Hendren,PatrickLam, and
Vijay Sundaresan. 2010. Soot: A Java bytecode optimization framework. In
CASCON First Decade High Impact Papers. IBM Corp., 214‚Äì224.
[36]Heila van der Merwe, Brink van der Merwe, and Willem Visser. 2014. Execution
and property specifications for jpf-android. ACM SIGSOFT Software Engineering
Notes39, 1 (2014), 1‚Äì5.
[37]Willem Visser, Klaus Havelund, Guillaume Brat, SeungJoon Park, and FlavioLerda. 2003. Model checking programs. Automated software engineering 10, 2
(2003), 203‚Äì232.
[38]Zhemin Yang, Min Yang, Yuan Zhang, Guofei Gu, Peng Ning, and X. Sean Wang.
2013. AppIntent: analyzing sensitive data transmission in android for privacy
leakagedetection.In Proceedingsofthe2013ACMSIGSACconferenceonComputer
&#38; communications security (CCS 2013). ACM, 1043‚Äì1054.
429
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 