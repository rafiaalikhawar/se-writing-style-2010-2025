Static Window Transition Graphs for Android
Shengqian Yang, Hailong Zhang, Haowei Wu, Yan Wang, Dacong Yany, and Atanas Rountev
Ohio State University, Columbus, OH, USA
Email: {yangs,zhanhail,wuhaow,wang10,rountev}@cse.ohio-state.edu
yGoogle Inc., Mountain View, CA, USA
Email: dacongy@google.com
Abstract ‚ÄîThis work develops a static analysis to create a
model of the behavior of an Android application‚Äôs GUI. We pro-
pose the window transition graph (WTG), a model representing
the possible GUI window sequences and their associated events
and callbacks. A key component and contribution of our work is
the careful modeling of the stack of currently-active windows, the
changes to this stack, and the effects of callbacks related to these
changes. To the best of our knowledge, this is the Ô¨Årst detailed
study of this important static analysis problem for Android. We
develop novel analysis algorithms for WTG construction and
traversal, based on this modeling of the window stack. We also
describe an application of the WTG for GUI test generation,
using path traversals. The evaluation of the proposed algorithms
indicates their effectiveness and practicality.
I. I NTRODUCTION
The explosive growth in the number of deployed smart-
phones and tablets has signiÔ¨Åcantly changed the computing
landscape. The correctness, security, and performance of such
devices is of paramount importance for many millions of users.
For software engineering researchers, this raises high expecta-
tions for developing a comprehensive toolset of algorithms for
understanding, testing, and veriÔ¨Åcation of Android software.
Our focus is on a key component of such a toolset: a
static analysis to create a model of an application‚Äôs graphical
user interface (GUI). Such a model can be used for program
understanding, testing, and dynamic exploration [1]‚Äì[6]. It
could also potentially be a starting point for static data-Ô¨Çow
analyses, for example, for checking of security properties, leak
defects, and other correctness properties [7]‚Äì[24].
We propose a particular form of a GUI model for An-
droid: a window transition graph (WTG). Nodes in this graph
represent windows and edges represent transitions between
windows, triggered by callbacks executed in the UI thread.
To allow the development of client data-Ô¨Çow analyses based
on the WTG, graph edges are annotated with the sequences
of callback methods invoked by the Android platform. These
annotations capture event handling callbacks and window
lifecycle callbacks .
Technical challenges and insights. The representation and
analysis of these callback methods play a critical role in a
static analysis for WTG construction, and more generally,
control/data-Ô¨Çow analysis for Android. Transitions between
windows are triggered by such methods, and during these
transitions additional callbacks occur. The current state of
the art in static analysis for Android is inadequate when it
comes to represent such run-time behavior. For example, we
have seen various cases from real applications where an event
handler may force the closing of the current window and itspredecessor window, while at the same time opening a new
window; this leads to complicated interleavings of callbacks
for the three windows. As another example, we have seen many
cases where the return from a window does not come back to
the predecessor, but rather to another window displayed earlier.
In existing work, including our own prior work, there is no
conceptual clarity on these possible run-time behaviors and
how they can be analyzed in a static control-Ô¨Çow analysis.
We address this problem by clarifying the major elements
of such behaviors, with the help of the abstraction of a window
stack . The window stack generalizes the standard Android
notion of a ‚Äúback stack‚Äù [25], which stores the currently-alive
activities. (Activities correspond to one category of windows.)
Our generalization (1) captures additional categories of win-
dows, and (2) models the changes to the window stack. An
important observation is that a single transition in the WTG can
have complex effects on the window stack: for example, it can
pop and/or push windows, all as part of the same WTG edge. A
major contribution of our work is the careful modeling of these
stack changes and their related callbacks‚Äîboth the callbacks
that trigger the stack changes, and the callbacks triggered by
them. To the best of our knowledge, this is the Ô¨Årst detailed
study of this important static analysis problem for Android.
The combined analysis of callbacks and the window stack
also provides a solution to an important related problem: which
sequences of window transitions are feasible? One cannot
consider all WTG paths, since some such paths are provably
infeasible. We can draw an analogy with the sequences of
calls/returns in ordinary programs: modeling the possible states
of the call stack is a key concern in static analysis of call/return
sequences (which, in turn, is an important component of inter-
procedural data-Ô¨Çow analysis). However, the behavior of the
window stack can be signiÔ¨Åcantly more complicated. Our work
provides a systematic identiÔ¨Åcation of valid WTG paths (and,
by trivial extension, valid call/return sequences), which is a
critical prerequisite for future developments in interprocedural
data-Ô¨Çow analysis for Android. As an exemplar client, we have
developed a test generation tool in which valid WTG paths
naturally correspond to test cases.
Contributions. The contributions of this work are: (1) deÔ¨Åni-
tion of the window transition graph (WTG) as a GUI model
for understanding, testing, dynamic exploration, and static
checking of Android applications; (2) static analysis for WTG
construction, employing careful modeling of the interplay
between callbacks and the window stack; (3) algorithm to
identify valid paths in the WTG, based on modeling of window
stack changes; (4) test generation tool based on the WTG; and
(5) experimental evaluation of the proposed algorithms.II. A NDROID BEHAVIOR AND ITSWTG R EPRESENTATION
A. Relevant Android Features
Figure 1 contains an example derived from the APV PDF
viewer [26]. For simplicity, the code and its description omit
a number of non-essential details. The example illustrates
windows (e.g., ChooseFileActivity ), GUI widgets (e.g.,
fileListView ), and event handlers (e.g., onItemClick ).
Windows. Subclasses of android.app.Activity are used
to deÔ¨Åne activities, which are core application building blocks.
ChooseFileActivity ,OpenFileActivity ,Options , and
About from Figure 1 are such classes; execution starts from
an instance of ChooseFileActivity , which shows a Ô¨Åle
list. An activity displays a window containing several GUI
widgets. A widget (also referred to as a ‚Äúview‚Äù) is an instance
of a view class . In Figure 1, variables that refer to widgets
include fileListView (list of Ô¨Åles), l(the same list), item
(individual list element), aboutItem ,optionsItem (both are
elements of a menu, as described below), and btn (a button).
We also consider the two other common categories of
Android windows: menus and dialogs. Instances of menu
classes represent short-lived windows associated with activities
(‚Äúoptions‚Äù menus) and widgets (‚Äúcontext‚Äù menus). In Fig-
ure 1 OpenFileActitivy has an options menu, initialized by
onCreateOptionsMenu to contain menu items aboutItem
andoptionsItem . A dialog is an instance of a subclass of
android.app.Dialog . Both menus and dialogs are used for
modal events that require users to take an action before they
can proceed [27].1We will use Win to denote the set of all
run-time windows (activities, menus, and dialogs), and View
for the set of all run-time widgets in these windows.
A menu/dialog takes control temporarily for a simple
interaction with the user, and its lifetime is shorter than activity
lifetime. The last activity that was displayed before a menu or
a dialog was displayed is considered to be the owner activity of
this menu/dialog. In the running example, the options menu is
owned by OpenFileActivity . There are more general cases:
for example, in OpenFileActivity there exists a button (not
shown in Figure 1) for which a long-click event opens a context
menum1, in which a menu item can be clicked to open a
dialogd1asking for a page number in the PDF Ô¨Åle; if an
incorrect number is entered, d1shows another dialog d2with
an error message. In this example OpenFileActivity is the
owner activity of m1,d1, andd2. The lifetime of a menu or
a dialog is contained within the lifetime of its owner activity.
Events. Eachw2Win can respond to several events. Widget
events are of the form e= [v;t]wherev2View is a
widget and tis an event type (e.g., vcould be a button and
tcould be ‚Äúclick‚Äù). We also consider Ô¨Åve kinds of default
events . Event back corresponds to pressing the hardware
BACK button, which typically (but not always) returns to
the window that triggered the current window. Event rotate
shows that the user rotates the screen, which triggers various
GUI changes. For example, if the currently-active window is a
dialog, this dialog is destroyed, its underlying activity is also
destroyed, and the activity (but not the dialog) is recreated and
redisplayed. Event home abstracts a scenario there the user
1Such windows are common: for example, in our experiments, more than
half of window transitions involved menus and dialogs.1class ChooseFileActivity extends Activity
2 implements onItemClickListener {
3 ArrayList<FileListEntry> fileList;
4 ListView fileListView;
5 // === Lifecycle callbacks ===
6 void onCreate() { ...
7 fileListView.setOnItemClickListener( this ); }
8 // Other lifecycle callbacks: onDestroy, onStart,
9 // onRestart, onStop, onResume, onPause
10 // === Widget event handler callback ===
11 void onItemClick(ListView l, View item, int p) {
12 FileListEntry entry = fileList.get(p);
13 File file = entry.getFile();
14 if(!file.exists()) return ;
15 Intent in = new Intent(OpenFileActivity. class );
16 // initialize intent based on file
17 startActivity(in); } }
18class OpenFileActivity extends Activity {
19 MenuItem aboutItem, optionsItem;
20 // === Lifecycle callbacks ===
21 // onCreate, onDestroy, etc.
22 void onCreateOptionsMenu(Menu menu) {
23 aboutItem = menu.add("Item");
24 optionsItem = menu.add("Options"); }
25 void onOptionsMenuClosed(Menu menu) { ... }
26 // === Widget event handler callback ===
27 void onOptionsItemSelected(MenuItem item) {
28 if(item == aboutItem)
29 startActivity( new Intent(About. class ));
30 if(item == optionsItem) {
31 startActivity( new Intent(Options. class ));
32 this .finish(); } }
33class Options extends Activity
34 implements OnClickListener {
35 Button btn;
36 void onCreate() { btn.setOnClickListener( this ); }
37 void onClick(View v) {
38 startActivity( new Intent(About. class ));
39 this .finish(); } } }
40class About extends Activity { ... }
Fig. 1. Example derived from the APV PDF reader [26].
switches to another application and then resumes the current
application (e.g., by pressing the hardware HOME button to
switch to the launcher, and then eventually returning to the
application.) Event power represents a scenario where the
device is put in low-power state by pressing the hardware
POWER button, followed by device reactivation. Event menu
shows the pressing of the hardware MENU button to display
an options menu (or a click to display the hidden parts
of an action bar). A default event will be represented as
e= [w;t]2Winfback;rotate;home;power;menug
wherewis the currently-active window. We will use Event
to denote the set of all widget events and default events.
Callbacks. Eache2Event triggers a sequence of call-
backs that can be abstracted as [o1;c1][o2;c2]:::[ok;ck]. Here
ciis a callback method and oiis a run-time object on
whichciwas triggered. We focus on two categories of
callbacks. Widget event handler callbacks respond to widget
events. Figure 1 shows three examples. Method onItemClick
handles click events for items of list fileListView . The
call at line 7 registers the activity with a listener for such
events. The list, the item being clicked, and its position in
the list are provided as parameters to the callback. Method
onOptionsItemSelected handles clicks for items in the
options menu, and takes the clicked item as a parameter.
Method onClick at lines 37‚Äì39 responds to clicks on btn.Lifecycle callbacks are used for lifetime management of
windows. These methods are of signiÔ¨Åcant interest to de-
velopers (e.g., in order to avoid leaks [3], [20]‚Äì[22]). There
are seven kinds of lifecycle callbacks for activities, as indi-
cated in Figure 1. For example, creation callback onCreate
indicates the start of the activity‚Äôs lifetime, and termination
callback onDestroy indicated end of lifetime. Menus and
dialogs can also have create/terminate callbacks, for exam-
ple, onCreateOptionsMenu and onOptionsMenuClosed
in Figure 1.2We will use abstract names create and
destroy to represent these create/terminate callbacks. Simi-
larly, start;:::; pause will denote corresponding callbacks in
activities and (if applicable) in dialogs and menus. Let Cback
be the set of all lifecycle and widget event handler callbacks.
B. Motivation and Related Work
Section II-C describes the window transition graph (WTG),
our proposed static representation of window transitions and
callbacks. Each node corresponds to a window and each
edge represents a window transition, labeled with a callback
sequence. Figure 2 shows the WTG for the running example.
Why this static representation? A number of challenging
software engineering problems for Android can be addressed
with static analyses where the modeling of control Ô¨Çow plays
a critical role. A few examples include checking of security
properties (e.g., [7]‚Äì[15]), detection of energy defects (e.g.,
[17]‚Äì[19]), leak defects (e.g., [3], [20]‚Äì[22]), data races (e.g.,
[16]), and other correctness checking (e.g., [23], [24]). For
example, common battery-drain defects‚Äî‚Äúno-sleep‚Äù [17] and
‚Äúmissing deactivation‚Äù [18], [19]‚Äîcan be stated as properties
of callback sequences. These sequences could potentially be
derived from WTG paths. Prior work [17] deÔ¨Ånes a data-Ô¨Çow
analysis to identify relevant API calls (e.g., GPS is turned on)
and to search for no-sleep paths along which corresponding
turn-off/release calls are missing. For this work, the order of
callbacks is of critical importance, but their solution lacks
generality and precision, and may even involve manual efforts
by the user. Some dynamic analyses of energy defects [18],
[19] also consider paths in which a sensor (e.g., the GPS) is not
put to sleep appropriately, often because of mismanagement
of lifecycle callbacks. A static approach to identify such code
paths requires callback ordering information, and the WTG
can provide this information. Another example is static taint
analysis for Android. Representative algorithms such as [12]
do not model soundly all callback interleavings and do not
employ the control-Ô¨Çow validity constraints captured in our
work. Future work could investigate whether such analyses
beneÔ¨Åt from the WTG representation. Yet another example is
static detection of resource leaks. Such leaks are often the
result of improper resource management under event/callback
sequences [3], [20]‚Äì[22], including events such as rotate ,
home , and back . Developing static leak detectors requires
callback sequences, which could be obtained from the WTG.
In addition to defect detection, the WTG is directly appli-
cable for GUI model construction for program understanding,
testing [1]‚Äì[4], and dynamic exploration [5], [6], [28]. In
Section IV we describe a test generation tool we developed
based on the WTG, using traversals of valid WTG paths.
2There is a related callback onPrepareOptionsMenu ; for simplicity, it
is not discussed here, but our implementation handles it.Related work. Despite the critical importance of analyzing
statically the possible GUI behaviors of an Android appli-
cation, the current state of the art lacks a systematic and
comprehensive solution. For example, an activity transition
graph is constructed in [5] to guide run-time GUI exploration,
but the underlying static analysis [7], [29] uses conservative
assumptions about GUI-related control Ô¨Çow, and does not
model the changes to the window stack. Other work that
creates static GUI models (e.g., [10]) also lacks generality
and representations of the window stack. Our earlier work
[30] considers analysis of callbacks and determines ordering
constraints between them. However, it also does not provide a
comprehensive solution: (1) it considers only a limited subset
of lifecycle callbacks; (2) it does not represent the interleavings
of callbacks from multiple windows, as illustrated in Table I;
(3) it does not model the window stack (e.g., it assumes that
each back event will return to the previous window); (4) it does
not handle the owner-close operations described shortly; (5) it
does not consider rotate ,home , and power events. Other work
that analyzes possible callbacks in Android (e.g., [12]‚Äì[16],
[31]) has similar or even more signiÔ¨Åcant limitations. To the
best of our knowledge, the proposed static analysis is the Ô¨Årst
comprehensive solution to the important problem of modeling
the possible window/callback sequences in an Android GUI.3
C. Modeling of Window Transitions
Opening and closing of windows. Each callback could open a
new window or close an existing one. Consider the following
scenario: when an ‚ÄúExit‚Äù button in an activity ais clicked,
the corresponding event handler opens a new dialog dto ask
the user to conÔ¨Årm the exit. When the dialog‚Äôs ‚ÄúYes‚Äù button
bis selected, its handler hcloses both the dialog as well as
its owner activity a, and control returns back to some prior
activitya0. At each event, various callbacks occur. For exam-
ple, clicking btriggers [b;h] [d;destroy ] [a;pause ] [a0;restart ]
[a0;start ] [a0;resume ] [a;stop] [a;destroy ]. Our goal is to
model statically such behavior and the related changes to the
window stack.4Note that we focus on the behavior of the main
thread (i.e., UI event thread) of the application; analysis of
multiple threads (e.g., as done in [16]) or of control Ô¨Çow across
applications is not being considered. Additional limitations of
the approach are discussed in Section III-D.
There are various API calls to open and close windows.
For example, a call to startActivity opens a new activity,
and a call to finish closes an existing one. Similarly, calls to
show anddismiss can create and destroy a dialog. These will
be represented with abstract operations open(w)andclose (w),
wherewis the window being created/destroyed. We have never
encountered an example of an execution of a callback method
cthat opens more than one window, and thus we assume that
any path through ccontains at most one open(w)operation.
Operations close (w)may also be triggered during an exe-
cution ofc. The two common patterns are self-close andowner-
close . In a self-close, cis associated with a window wandc‚Äôs
execution issues close (w); an example is shown at line 39
of Figure 1. Another example is onOptionsItemSelected
3Since our approach is tightly coupled with Android-speciÔ¨Åc semantics, it
is unlikely that it will be relevant beyond Android code.
4The discussion assumes Android version 4.3; some earlier versions have
slight variations in certain sequences of callbacks.TABLE I. S OME WINDOW STACK CHANGES AND CORRESPONDING CALLBACK SEQUENCES .
Stack Event Handler Open/Close Stack changes Callback sequence
1(: : : ; a ) [ v;t] [ v;h]none none [v;h]
2(: : : ; a ) [ v;t] [ v;h]open (a0) pusha0[v;h][a;pause ][a0;create ][a0;start ][a0;resume ][a;stop]
3(: : : ; a0; a) [ v;t] [ v;h]close (a) popa [v;h][a;pause ][a0;restart ][a0;start ][a0;resume ][a;stop][a;destroy ]
4(: : : ; a ) [ v;t] [ v;h]close (a);open (a0) popa, push a0[v;h][a;pause ][a0;create ][a0;start ][a0;resume ][a;stop ][a;destroy ]
5(: : : ; a0; a) [ a;back]implicit close (a) popa [a;pause ][a0;restart ][a0;start ][a0;resume ][a;stop][a;destroy ]
6(: : : ; a ) [ a;rotate ]implicit close (a);open (a) popa, push a [a;pause ][a;stop][a;destroy ][a;create ][a;start ][a;resume ]
7(: : : ; a ) [ a;home ]implicit none none [a;pause ][a;stop][a;restart ][a;start ][a;resume ]
8(: : : ; a ) [ a;power ]implicit none none [a;pause ][a;stop][a;restart ][a;start ][a;resume ]
9(: : : ; a ) [ a;menu ]implicit open (m) pushm [m;create ]
10(: : : ; a ) [ v;t] [ v;h]open (m) pushm [v;h][m;create ]
11(: : : ; a ) [ v;t] [ v;h]open (d) pushd [v;h][d;create ]
12(: : : ; a; m ) [v;t] [ v;h]close (m) popm [v;h][m;destroy ]
13(: : : ; a; m ) [v;t] [ v;h]close (m);open (a0) popm, push a0[v;h][m;destroy ][a;pause ][a0;create ][a0;start ][a0;resume ][a;stop]
14(: : : ; a0; a; m ) [v;t] [ v;h]close (m);close (a) popm, popa [v;h][m;destroy ][a;pause ][a0;restart ][a0;start ][a0;resume ][a;stop][a;destroy ]
15(: : : ; a; m ) [v;t] [ v;h]close (m&a);open (a0)popm&a, push a0[v;h][m;destroy ][a;pause ][a0;create ][a0;start ][a0;resume ][a;stop][a;destroy ]
16(: : : ; a; m ) [m;back]implicit close (m) popm [m;destroy ]
17(: : : ; a; m ) [m;rotate ]implicit close (m&a); popm&a, [a;pause ][m;destroy ][a;stop][a;destroy ][a;create ][a;start ][a;resume ][m;create ]
open (a&m) pusha&m
18(: : : ; a; m ) [m;home ]implicit close (m) popm [a;pause ][m;destroy ][a;stop][a;restart ][a;start ][a;resume ]
19(: : : ; a; d ) [ v;t] [ v;h]open (a0) pusha0[v;h][a;pause ][a0;create ][a0;start ][a0;resume ][a;stop]
associated with the options menu m: the semantics of menu-
item-click event handlers includes an implicit menu self-close
operation close (m)that does not appear in the code. In owner-
close operations, if cis associated with a menu mor a dialogd,
it may issue close (a)for the owner activity a. For example, the
path at lines 30‚Äì32 in Figure 1 has an open operation followed
by owner-close at line 32 and then an implicit self-close.
Note that the actual opening/closing of windows, as well as
the related lifecycle callbacks, happen only after the callback
issuing the open/close operations has completed. For example,
after lines 30‚Äì32 are executed and onOptionsItemSelected
completes, menu mand its owner a=OpenFileActivity
are closed, activity a0=Options is opened, and the follow-
ing callbacks are observed: [m;destroy ] [a;pause ] [a0;create ]
[a0;start ] [a0;resume ] [a;stop] [a;destroy ]. The ordering of
open and close operations in a callback‚Äôs execution path
typically does not affect the outcome of its execution.
Behavior of the window stack. The window stack represents
the set of currently-alive windows. The window that currently
interacts with the user is on top of the stack. Due to space lim-
itations, we describe the case where open and close operations
appear only in widget event handler callbacks. Our algorithms
and implementation also handle common cases where such
operations occasionally appear in lifecycle callbacks.
The window stack starts a single element: the starting
activitya. The creation of this initial state is associated with the
lifecycle callback sequence to initialize a:[create;a] [start;a]
[resume;a]. At any moment of time, the window w2Win at
the top of the stack determines the possible events that could
be triggered by the user. These include widget events [v;t]
wherev2View is a widget deÔ¨Åned by wandtis the event
type, as well as default events such as [w;back], etc. When
a widget event [v;t]is triggered, callback [v;h]is invoked.
Hereh2Cback is the corresponding event handling method,
invoked on that same widget v. Ifhtriggers a self-close
operation,wis popped from the window stack. If, in addition,
htriggers an owner-close operation, the owner activity is also
popped from the top of the stack.5Finally, ifhopens a new
window, this window is pushed on top of the stack.
5Since the lifetime of a menu/dialog is contained within the lifetime of its
owner, closing an owner implies that all owned windows have been closed.Some of these scenarios are summarized in Table I. The
Ô¨Årst column describes the stack state, with the currently-visible
window on top. We use aanda0to denote activities, m
to denote an options menu, and ddenote a dialog. Only a
representative sample of cases are described; additional details
on the scenarios captured by our algorithm are presented
elsewhere [32]. In several rows the event handler is listed
as ‚Äúimplicit‚Äù, because it is deÔ¨Åned by the Android platform
semantics and not by the application code. Column ‚ÄúOpen/
Close‚Äù shows the window open/close operations triggered by
the event handler. The corresponding changes to the window
stack are shown in the next column. After these changes are
applied, the new stack top becomes the visible window.
The Ô¨Årst four rows represent an event for a widget vin an
activitya. If the window stack changes (rows 2‚Äì4), the callback
sequences interleave lifecycle callbacks for aand the activity
a0which becomes the new stack top. The implicit handlers
for default events also may trigger stack changes: for example,
rotating the screen destroys aand then recreates it on top of
the stack (row 6). Rows 12‚Äì18 present scenarios for an options
menum, owned by an activity a. The widget events [v;t]
are of the form [menu _item;click]with handlers hillustrated
byonOptionsItemSelected in the running example. The
implicit close (m)operation in his explicitly represented in
the table. Row 13 corresponds to lines 28‚Äì29 in the running
example, and row 15 represents the effects of lines 30‚Äì32.
Window transition graph. The WTG is deÔ¨Åned as G=
(Win;E;;; )with nodes w2Win and edgese2E
WinWin . Here we use Win andView to denote sets of
static abstractions of run-time windows and widgets (while
previously these sets denoted the actual run-time entities).
There are various ways to deÔ¨Åne such static abstractions. We
use the approach from [33], [34], which creates a separate
a2Win for each activity class, together with appropriate
m;d2Win for its menus and dialogs, and abstractions
v2View for their widgets (i.e., deÔ¨Åned in layout XML Ô¨Åles),
and then propagates them similarly to interprocedural points-to
analysis, but with special handling of Android API calls.
Labels:E!Event indicate that the window transition
represented by an edge could be triggered due to a particular
event. Labels :E!(fpush;popgWin )annotate ana1:ChooseFileActivitye1:item,
click
a2:OpenFileActivitye2:item,
clicke3:back
m:OptionsMenu(a2)e4:menu e5:back e6:home
a3:Aboute7:aboutItem,click
a4:Optionse9:optionsItem,clicke12:back
e8:back ¬†e10:back
¬†e11:btn,click¬†(a) Window transition graph
e  (e)(e)e  (e) (e)
e1  1e7 popm, pusha3 13
e2 pusha2 2e8 popa3 5
e3 popa2 5e9 popm, popa2, pusha4 15
e4 pushm 9e10 popa4 5
e5 popm 16e11 popa4, pusha3 4
e6 popm 18e12 popa3 5
(b) Edge labels
Fig. 2. WTG for the running example.
edge with a sequence of window stack operations push(w)
andpop(w). Finally,:E!((Win[View )Cback )
shows the sequence of callbacks for the transition.
The meaning of an edge e=w1!w2is as follows:
suppose that the currently-visible window is w1(i.e., it is on
top of the window stack). If event (e)is issued by the GUI
user, the processing of this event may trigger the stack changes
described by (e), resulting in a new stack top element w2.
During these changes, the callback sequence (e)is observed.
Example. Figure 2 shows the WTG for the running example.
To simplify the Ô¨Ågure, edges w!wforrotate andhome
events are not shown. Since edges for power are very similar to
the ones for home , they are not shown either. The back -event
edge from the starting activity a1, which returns control back
to the Android platform, is also not shown. Each eiis labeled
with its triggering event (ei). Edgee1represents the case
when the PDF Ô¨Åle does not exist (line 14 in onItemClick )
and the event handler returns without opening a new window.
The table shows the associated stack changes as well as row
numbers from Table I describing the callback sequences (e).
Two acyclic paths reach a3:p=e2;e4;e7andp0=
e2;e4;e9;e11, wherepproduces a window stack (a1;a2;a3)
andp0produces (a1;a3). Edgese8ande12correspond to
possible next edges along pandp0, respectively. Note that if
e8is appended to p0, the path is invalid: it represents a stack
(a1), but the end node of the path is a2, which violates the
property that the current window is on top of the window stack.
Similarly,e12cannot be appended to p. Our graph construction
creates both e8ande12, while our subsequent path traversal
avoids the infeasible paths p0;e8andp;e12.Algorithm 1: ConstructInitialEdges
1foreachw2Win do
2 foreach widget event [v;t]with callback [v;h]forwdo
3 ifMayOpenNone ([v;h])then
4 ADDEDGE(w;w; [v;t])
5 foreach open(w0)2Open ([v;h])do
6 ADDEDGE(w;w0;[v;t])
7 ifwis an activity awith options menu mthen
8 ADDEDGE(a;m; [a;menu ])
9 ADDEDGE(w;w; [w;back])
10foreach menu and dialog w2Win do
11 FINDOWNER (w)
12ifwis an activity athen
13 ADDEDGE(a;a;[a;rotate ])
14 ADDEDGE(a;a;[a;home ])
15 ADDEDGE(a;a;[a;power ])
16ifwis an options menu mwith ownerathen
17 ADDEDGE(m;m; [m;rotate ])
18 ADDEDGE(m;a; [m;home ])
19 ADDEDGE(m;a; [m;power ])
20ifwis a context menu mwith ownerathen
21:::
22ifwis a dialogdwith ownerathen
23:::
III. WTG C ONSTRUCTION ALGORITHM
The static analysis algorithm to construct the WTG takes
as input all w2Win ,v2View , and, for each w, the
possible widget events [v;t]and their corresponding event
handler callbacks [v;h]. This information is computed by an
existing static analysis described in [33], [34]. Given this input,
the algorithm proceeds in three stages. In the Ô¨Årst stage, initial
edgeseare constructed and annotated with trigger-event labels
(e). This stage requires analysis of open(w)operations in
event handlers, as well as modeling of default events rotate ,
home ,power , and menu . Since close (w)operations are not
accounted for in this stage, some of the resulting edges have
incorrect target nodes. In the second stage, the initial edges
are extended to include push/pop sequences (e)and callback
sequences(e). This requires analysis of self-close and owner-
close operations. In the third stage, backward traversal of
the graph is used to analyze the push/pop sequences along
traversed paths, in order to determine the correct target nodes
of edges that could not be resolved earlier.
A. Stage 1: Open-Window Operations and Default Events
In Stage 1, helper function A DDEDGE(w1;w2;ev)repre-
sents the addition to the WTG of an edge from window w1to
windoww2. The edge is labeled with event ev: a widget event
[v;t], wherevis an widget in w1, or a default event [w1;t].
The Ô¨Årst stage of the analysis applies Algorithm 1. For
each window w, in addition to w‚Äôs widget events [v;t]and
their callbacks [v;h], the algorithm requires two additional
properties. The Ô¨Årst is a map Open , mapping each callback
[v;h]to the set of open(w0)operations that could be triggered
by paths in the callback‚Äôs execution. The second is a map
MayOpenNone from [v;h]to a boolean value: true if the
callback‚Äôs execution could complete without triggering anya1:ChooseFileActivitye1:item,
click
a2:OpenFileActivitye2:item,
click
e3:back
m:OptionsMenu(a2)e4:menue6:home
e5:back a3:Aboute7:aboutItem,
click
a4:Optionse9:optionsItem,
clicke8,e12:back
¬†e11:btn,click¬†
¬†e10:backFig. 3. WTG after Stage 1.
open(w0)(i.e., there is an execution path without window-
open operations), and false otherwise. Both of these maps
can be computed using an approach from [30], in which
interprocedural control-Ô¨Çow traversal of h(and its transitive
callees) is performed to Ô¨Ånd calls such as startActivity .
Algorithm 1 considers each event and its callback. If [v;h]
could be executed without opening a new window, an edge
w!wis created. Edge e1in Figure 2 illustrates this case;
the edge is created because there is a path in onItemClick
(through line 14 in Figure 1) for which no windows are created.
We will refer to such edges as no-open edges. Next, each
possibly-opened window w0is considered. At line 6, an edge
fromwtow0is created for event [v;t]. Line 8 handles default
event menu for activities. The edges created at lines 6 and 8
push a new window on top of the window stack, and will be
referred to as window-open edges.
At line 9, initial edges for back -button events are created.
The targets of these edges (as well as their callback se-
quences) will not be known until Stage 3. Next, for each menu
and dialogw, its owner activity is determined by traversing
backward the newly-created window-open edges, using helper
function F INDOWNER .6Finally, default events rotate ,home ,
andpower are handled. This handling is consistent with the
description in Table I. The cases for context menus and dialogs
are not shown, but they are similar to those for options menus.
Example. Figure 3 shows the WTG for the running example
after Stage 1 has completed. The edge numbering is the same
as in the Ô¨Ånal WTG from Figure 2. Similarly to that earlier
Ô¨Ågure, certain rotate ,home , and power edges are not shown
for simplicity. Edge e1is created because MayOpenNone is
true for the corresponding event handler, while e2shows that
this handler could open a2. The owner of misa2, and the
home edge formreÔ¨Çects that. The back -event edges have
incorrect targets that will be Ô¨Åxed later. The back -event edge
fora3is labeled as e8;e12since eventually it will lead to the
creation of two separate edges e8ande12.
6In general,wcould have multiple owners, e.g., due to subclassing of
activities; the necessary algorithmic generalizations are straightforward.B. Stage 2: Close-Window Operations
In this stage the analysis Ô¨Årst considers each edge efor a
widget event [v;t]and handler [v;h]. Using the interprocedural
control-Ô¨Çow reachability analysis from [30], hunder calling
contextvis analyzed for self-close operations (e.g., calls to
finish ) andeis classiÔ¨Åed in one of three disjoint categories:
must-not-self-close, may-self-close, and must-self-close. If h
under context vdoes not contain a path reaching a self-close
operation,eis in the Ô¨Årst category. If some but not all paths
reach a self-close, the second category applies. If every path
reaches a self-close, the edge is must-self-close.
In a similar manner, classiÔ¨Åcation is performed for owner-
close operations. The analysis considers each menu and dialog
wandw‚Äôs owner activity a. For an edge e=w!:::for a
widget event [v;t], we can classify eas must-not-close-owner,
may-close-owner, and must-close-owner.
Example. In Figure 3, e7ande9are must-self-close due to
the implicit close (m)inonOptionsItemSelected . Edge
e11is also must-self-close due to the call to finish at line
39 in the running example. (If, hypothetically, this call were
guarded by a conditional, the classiÔ¨Åcation would have been
may-self-close.) The other two widget event edges e1ande2
are must-not-self-close. For owner-close operations, e7is must-
not-close-owner, while e9is must-close-owner, since under
widget context optionsItem the handler deÔ¨Ånitely closes the
owner activity a2(line 32 in the running example).
This classiÔ¨Åcation is used to create push/pop labels (e)for
the analyzed edges. For example, e9opensa4while deÔ¨Ånitely
closingmand its owner a2; thus,(e9) = popm;popa2;
pusha4. Algorithm 2 provides some details on this process.
One important observations is that a single edge created by
Stage 1 may be expanded into several edges, with different
(e)labels. For example, if (hypothetically) e11were may-
self-close, it would expand to two edges from a4toa3, one
labeled with pusha3(line 7 in the algorithm) and the other
withpopa4;pusha3(line 5 in the algorithm). Helper function
EXPAND EDGE(e;d)takes an edge ecreated by Stage 1 and
constructs an ‚Äúexpanded‚Äù version of it with (e) =d. After
Stage 2, the edges from Stage 1 are discarded.
Some details of the processing are elided due to space
limitations. For example, the handling of dialogs is similar to
that of menus, but with the additional possibility that a self-
close operation is not executed. The handling of rotate ,home ,
andpower events is consistent with the push/pop sequences
listed in Table I, and is not shown in Algorithm 2. After the
algorithm completes, all edges have labels (e). The labels
created for the running example are shown in Figure 2b. At
this point, there is still a single back -event edge for a3(labeled
with popa3); Stage 3 creates two separate edges from it.
Certain edges have incorrect targets and have to be pro-
cessed by Stage 3. These edges do not open new windows, but
close existing ones: namely, (1) edges for back events, and (2)
no-open edges that contain close operations. In both cases, the
top of the stack after executing the edge is some (yet) unknown
previously-opened window. The rest of the edges have correct
target nodes and their callback sequences (e)can be deter-
mined at this time, using the Android semantic speciÔ¨Åcation
illustrated by Table I. For edges e1;e2;e4;e6;e7;e9;e11from
Figure 3, the callback sequences computed by Stage 2 areAlgorithm 2: ExpandEdgesWithLabels
1foreachw2Win do
2 ifwis an activity athen
3 foreach window-open edge e=a!w0do
4 ifeis may/must-self-close then
5 EXPAND EDGE(e;[popa;pushw0])
6 ifeis not must-self-close then
7 EXPAND EDGE(e;[pushw0])
8 foreach no-open edge e=a!ado
9 ifeis may/must-self-close then
10 EXPAND EDGE(e;[popa])
11 ifeis not must-self-close then
12 EXPAND EDGE(e;[ ])
13 ifexistse=a!mfor default event [w;menu ]then
14 EXPAND EDGE(e;[pushm])
15 ifwis a menumwith ownerathen
16 foreach window-open edge e=m!w0do
17 ifeis may/must-owner-close then
18 EXPAND EDGE(e;[popm;popa;pushw0])
19 ifeis not must-owner-close then
20 EXPAND EDGE(e;[popm;pushw0])
21 foreach no-open edge e=m!mdo
22 ifeis may/must-owner-close then
23 EXPAND EDGE(e;[popm;popa])
24 ifeis not must-owner-close then
25 EXPAND EDGE(e;[popm])
26 ifwis a dialogdwith ownerathen
27:::
28foreach edgew!wfor default event [w;back]do
29 EXPAND EDGE(e;[popw])
listed in Figure 2b. The rest of the edges in Figure 3 have
incorrect target nodes, and since (e)depends on the target of
e, their callback sequences cannot yet be determined.
C. Stage 3: Backward Analysis of the Window Stack
Edges with incorrect targets require further processing.
They are of the form e=w!w, with labels (e)containing
nopush but at least one pop. To identify the correct target of
e, Stage 3 performs a backward traversal from w, using correct
edges Ô¨Ånalized in Stage 2, to examine all paths ending at w.
This traversal is parameterized by a value k, which deÔ¨Ånes the
largest number of edges along any path being considered.7
For each such path e1;e2;:::;e n, wherenkand the
target node of enisw, we need to consider the sequence of
push/pop operations (e1);(e2);:::; (en);(e)and to decide
(1) whether this sequence represents valid run-time behavior,
and (2) what could be the top of the window stack after the
sequence is executed.
Example. Suppose that k= 2and we consider e5=m!m
in Figure 3, labeled with popm. Two paths ending at mneed
to be examined: e2;e4ande6;e4. The edge labels for the
Ô¨Årst path (including e5‚Äôs label) are pusha2;pushm;popm.
This is a feasible sequence whose execution is guaranteed to
leavea2as the top of the stack. Thus, e5should have a2
7An alternative would be to traverse all acyclic paths, without a length limit.as a target, and the analysis creates this corrected edge. For
the second path, the edge labels (including e5) are popm;
pushm;popm. Although this is a feasible sequence, it does
not provide enough information to decide what would be the
top of the stack after executing these operations, and the
analysis does not create any edges due to this path.
As another example, consider edge e10=a4!a4. Fork=
4, the relevant path is e0;e2;e4;e9. Heree0is an implicit edge
enteringa1, labeled with pusha1; this edge represents the
triggering of the start activity a1by the Android platform. The
sequence for e0;e2;e4;e9;e10ispusha1;pusha2;pushm;
popm;popa2;pusha4;popa4. This sequence leaves a1as
the top of the stack. Thus, e10should be redirected to a1(as
shown in the graph in Figure 2).
As a Ô¨Ånal example, consider back -event edge a3!a3.
Pathe2;e4;e7, with this edge appended, has the sequence
pusha2;pushm;popm;pusha3;popa3. Thus, this back -
event edge should have a2as target. In the Ô¨Ånal graph from
Figure 2,e8is this redirected edge. Another relevant path is
e0;e2;e4;e9;e11; the sequence along the path, appended with
theback -event edge, is pusha1;pusha2;pushm;popm;
popa2;pusha4;popa4;pusha3;popa3, which leaves a1
as the top of the stack. In this case an edge from a3toa1
needs to be introduced ( e12from Figure 2).
Stage 3 analyzes an edge e=w!was follows. A stack
containing push andpop operations is maintained. The stack
is initialized with the reverse of (e); for all examples from
above, this is an operation popw. Backward traversal from w
is performed, limiting path length to at most kedges. When an
edgeeiis encountered during the traversal, the reverse of its
(ei)sequence is used to update the stack. If popw0is seen,
it is just added on top of the stack. If pushw0is encountered
and the stack is not empty, the top of the stack must be popw0
(otherwise the path is infeasible and is ignored) and popw0is
removed from the stack. If pushw0is observed when the stack
is empty, the traversal stops and w0is identiÔ¨Åes as a possible
target, leading to a new edge w!w0.
Example. Consider edge e10=a4!a4. Starting from a stack
containing popa4, edgese9;e4;e2;e0are visited to produce
the following sequence: pusha4;popa2;popm;pushm;
pusha2;pusha1. Operations pusha4andpusha2empty
the stack. Since pusha1occurs for an empty stack, edge e10
becomesa4!a1.
D. Limitations
The algorithm and its implementation have several lim-
itations. As discussed earlier, control Ô¨Çow due to multiple
threads or across multiple applications is not modeled. The
modeling of GUI widgets and event handlers [33] captures
many commonly-used Android widgets, but is not fully com-
prehensive. Furthermore, custom window/widget systems can-
not be handled. Asynchronous transitions (e.g., due to timers
and sensor events) are not represented in the WTG. The
interprocedural intent analysis used to resolve open(w)calls
[30] considers only explicit intents, as they are designed for use
inside the same application [35]. More general intent analyses
(e.g., [11], [29], [36]) could be used instead. Our analysis also
does not model the different launch modes for activities [25].
Due to these limitations, some window transitions are missing:for example, for the 20 apps used in our evaluation, on average
13% of the WTG nodes have no incoming edges. While most
of these limitations are orthogonal to the contributions of this
paper, they emphasize the need to advance the state of the art in
static analysis for Android, and in particular the comprehensive
modeling of Android-speciÔ¨Åc control Ô¨Çow and data Ô¨Çow.
E. Path Validity
The analysis outlined in the previous sections does not
ensure that each path represents a feasible run-time execution.
Consider again the Ô¨Ånal WTG (after Stage 3) shown in
Figure 2. Paths p=e0;e2;e4;e7andp0=e0;e2;e4;e9;e11
both reach node a3. However,pcannot be extended with edge
e12because the corresponding edge labels would be pusha1;
pusha2;pushm;popm;pusha3;popa3. This leaves a2as
the top of the window stack, while the target node of e12is
a1. Similarly, if p0were extended with e8, the top of the stack
would bea1while the target of e8isa2.
The WTG can be augmented with a path validity check,
which ‚Äúsimulates‚Äù the window stack along a given path of
interest, and decides whether the path is valid. This is similar in
spirit to classical interprocedural analyses, where the sequence
of calls and returns along a path is used to simulate the call
stack, in order to decide path validity [37]. A WTG edge may
correspond to several push/pop operations, but the validity of
these operations is still based on the same style of push/pop
matching as in traditional analyses. As discussed in the next
section, one use of this validity check is during test generation,
to avoid the creation of unexecutable test cases. Path validity
checks may also be needed for static checking of correctness
properties, in order to avoid analyzing infeasible paths that
lead to false positives.
IV. T ESTGENERATION
One possible application of the WTG is for model-based
test generation (e.g., [1]‚Äì[4], [19]). To illustrate this use of the
WTG, we developed a prototype test generation tool. The tool
traverses certain WTG paths and for each path creates a test
case implemented with the Robotium testing framework [38].
For a pathp=e1;e2;:::, the event label (ei)is translated to
corresponding Robotium API calls to trigger the event. Some
events may require additional input from the tester‚Äîe.g., to
decide which item in a list to click. Since the static analysis
solution is conservative, it is possible that event (ei)may
not be feasible at run time, or even if it is feasible, the target
window ofeiafter the run-time event is not as expected. Each
test case includes run-time checks to detect such scenarios and
report the test case as infeasible.
One can consider various test generation schemes (e.g.,
leak testing in [3] considers neutral-effect cycles in a manually-
constructed model). In our proof-of-concept tool, we use a
simple path-based approach. Starting from the implicit edge
e0showing the invocation of the start activity, we append m
distinct edges to create a path p=e0;e1;:::;e m. A naive
approach is to simply explore all such paths. A more precise
approach is to apply the validity check from Section III-E each
time the path is extended with a new edge. The next section
shows that this validity check, which is based on our proposed
tracking the push/pop sequences, can reduce substantially the
number of test cases being generated.V. E XPERIMENTAL EVALUATION
The WTG was constructed for the 20 open-source appli-
cations used in our prior work [30], [33]. The Ô¨Årst goal of the
evaluation is to characterize the effects of different stages of
the algorithm, as well as its overall cost. The second goal is to
evaluate precision, relative to a manually-constructed model.
The third goal is to evaluate precision for the test generation
from Section IV. The implementation is available as part of
our public analysis toolkit [39].
A. Algorithm for Building the WTG
Table II provides measurements of the number of WTG
nodes and edges. Column ‚ÄúStage 1‚Äù shows the number of
edges before considering any close-window operations (Algo-
rithm 1). After Stage 2, the edges are expanded with push/pop
sequences, based on analysis of close-window effects. Column
1;2shows the increase due to this expansion. One can observe
that an edge from Stage 1 can often have several possible
push/pop sequences. This indicates that an event handler may
exhibit a variety of behaviors. Our analysis discovers such vari-
ations and represents them with separate edges (Algorithm 2).
We are not aware of any existing work that performs such
detailed analysis of Android event handlers.
The large number of edges for FBReader andXBMC is
caused by a known limitation of our prior analyses [30], [33]:
both analyses use a context-insensitive call graph based on
class hierarchy analysis. For example, in FBReader , two utility
methods are responsible for over 96% of the WTG edges.
Both methods take parameters of an interface type which is
implemented by 130 classes. Class hierarchy resolution for
calls on these parameters is highly imprecise. More precise
call graph construction is likely to solve this problem.
Recall that some of the Stage 2 edges have incorrect target
nodes. Column ‚ÄúStage 3‚Äù shows the number of edges after
the correct targets have been determined. This is achieved
with backward path analysis, based on a parameter kfor
path length; the column contains measurements for k= 4.
Column 2;3shows the size of the difference (number of edges
removed and added) between the edge sets from Stage 2 and
Stage 3. The backward path traversal, combined with tracking
of feasible push/pop sequences along the path (Section III-C),
results in signiÔ¨Åcant changes to the graph. The next four
columns show the effects of increasing the path length limit
k. In general, newly-created edges require backward traversals
of non-trivial length. Thus, one cannot consider just the edges
entering a node wto determine the targets of Stage 3 edges
w!:::; rather, paths of length kreachingwmust be exam-
ined. To the best of our knowledge, ours is the Ô¨Årst approach to
perform such static modeling of possible transitions in Android
GUIs. For most programs, the graph stabilizes at k=4; for the
rest, slightly larger values of k(not shown here) are needed.
The last column shows the running time of the analysis in
seconds. This measurement includes the time for the event
handler analysis from [30], which is invoked on-demand
inside our analysis. Overall, the running times are suitable for
practical use, even though we have not made any signiÔ¨Åcant
effort to optimize the implementation. However, as indicated
by the results for FBReader , scalability limitations could be
encountered for large WTGs.TABLE II. WTG CONSTRUCTION ALGORITHM :NUMBER OF NODES /EDGES AND ANALYSIS COST .
Application SLOC Nodes Edges k Time
Stage 1 Stage 2 1;2 Stage 3 2;3 k=1 k=2 k=3 k=4 (sec)
APV 3832 14 77 101 24 105 58 75 95 104 105 5
Astrid 24487 93 594 740 146 838 236 675 836 838 838 18
BarcodeScanner 6549 20 90 121 31 128 65 98 118 128 128 6
Beem 12962 24 99 125 26 132 65 100 118 132 132 6
ConnectBot 32638 37 185 233 48 237 112 182 211 234 237 8
FBReader 45510 45 286 17774 17488 41942 26326 29473 39820 41941 41942 2086
K9 52240 55 258 411 153 516 221 433 486 509 516 25
KeePassDroid 27457 41 272 468 196 643 389 399 598 640 643 9
Mileage 9881 75 409 562 153 676 268 485 636 676 676 7
MyTracks 23389 61 212 314 102 391 197 294 363 391 391 7
NotePad 4986 22 122 191 69 213 110 162 195 213 213 6
NPR 12118 32 344 502 158 590 106 525 590 590 590 6
OpenManager 2562 18 95 116 21 116 64 84 113 116 116 5
OpenSudoku 6079 35 173 232 59 237 125 180 208 237 237 6
SipDroid 24533 31 176 305 129 406 331 226 364 396 406 12
SuperGenPass 2119 9 49 63 14 64 39 45 58 64 64 5
TippyTipper 1739 10 54 63 9 65 16 56 61 65 65 5
VLC 10670 26 117 130 13 131 45 112 131 131 131 6
VuDroid 2380 7 30 44 14 47 23 34 41 47 47 4
XBMC 23295 67 1080 3819 2739 4279 722 3690 4241 4278 4279 16
TABLE III. F EASIBILITY OF WTG EDGES .
Application WTG Manual Infeasible
APV 105 105 0
BarcodeScanner 128 106 22
OpenManager 116 109 7
SuperGenPass 64 64 0
TippyTipper 65 65 0
VuDroid 47 45 2
B. Manual Examination of WTGs
For in-depth evaluation of analysis precision, we examined
the WTG (k= 4) for APV,BarcodeScanner ,OpenManager ,
SuperGenPass ,TippyTipper , and VuDroid . These applica-
tions had the smallest numbers of WTG nodes, and thus could
be examined manually with reasonable effort.
Column ‚ÄúWTG‚Äù in Table III replicates the Stage 3 mea-
surements from Table II. Column ‚ÄúManual‚Äù shows the number
of WTG edges that were manually conÔ¨Årmed to be feasible
using run-time test cases. The last column contains the number
of infeasible WTG edges. The infeasibility was asserted by
examining the source code. In general, the number of infeasible
edges is small (around 6% across the six applications). We
determined the root causes of all infeasible edges. In all cases,
the infeasibility was due to deÔ¨Åciencies in the earlier work on
window/widget modeling [33], [34] and event handler analysis
[30]. If these existing static analyses were to be improved, the
WTG would achieve perfect precision. These results highlights
the need for continued advances in static analysis of GUI
structure and behavior for Android applications. Still, the small
number of infeasible edges is a positive indicator that highly-
precise static GUI models can be constructed automatically.
C. Test Generation
Recall that our prototype test generator considers paths p=
e0;e1;:::;e m(alleiare distinct) and generates test cases from
them. Heree0represents the invocation of the start activity by
the Android platform. The numbers of paths for m= 2 and
m= 3 are shown in Table IV. Columns ‚ÄúAll‚Äù contain the
number of all paths, while columns show the reduction (in
percent) when the path validity check from Section III-E isapplied. For FBReader the number of paths with m= 3was
too large enumerate in reasonable time.
For several applications the path validity check reduces the
number of test cases. For example, for m= 3(i.e., test cases
containing three GUI events), 10 applications show reductions
of26% or more. Such reductions indicate that statically we
can eliminate signiÔ¨Åcant numbers of infeasible test cases.
Of course, even if a path satisÔ¨Åes the static validity condi-
tion, it could still result in an infeasible test case. As indicated
earlier, due to deÔ¨Åciencies in prior static analyses, some WTG
edges (and thus paths) may be infeasible. To understand better
this infeasibility, for the six applications studied in Section V-B
we generated test cases from the statically-feasible paths for
m= 2 . Although the sequences of events (implemented
through Robotium [38] API calls) are generated automatically,
some test cases still require manual effort: for example, for
BarcodeScanner , we need to manually set up a variety of
actual barcode images to drive the different test cases. Due to
this manual effort, we did not consider larger values of m.
The number of test cases (with path validity) is shown in
column ‚ÄúStatic‚Äù in Table V. We set up and executed all 1581
test cases indicated in this column. The next column ‚ÄúFeasible‚Äù
shows the number of these test cases that were feasible at run
time‚Äîthat is, they could match the event sequence and target
windows of the static path. In BarcodeScanner , the event
handler analysis from [30] leads to infeasible edges that make
most of the test cases infeasible. As described in [30], the
application processes eleven types of barcodes, and the GUI
behavior (subset of visible widgets and subset of handler ef-
fects) differs based on the barcode type. This variability cannot
easily be modeled statically. In OpenManager , the 6.5% of
infeasible test cases are due to inter-application interactions.
When the main activity is invoked by another application
(rather than by the user), that activity computes information
about a Ô¨Åle, returns it to the invoking application, and closes
itself. Our analysis does not model the interactions between
multiple applications and does not recognize that the activity-
close operation happens under these conditions. Overall, with
the exception of one application, the vast majority of statically-
generated test cases are feasible at run time.TABLE IV . N UMBER OF PATHS FOR TEST GENERATION .
Application m=2 m=3
All (%) All (%)
APV 116 24.1 1416 37.7
Astrid 232 62.1 1822 75.3
BarcodeScanner 526 1.9 7675 4.6
Beem 138 26.1 929 38.6
ConnectBot 287 26.1 3384 40.3
FBReader 33404638 84.9 N/A N/A
K9 12393 19.8 443647 27.0
KeePassDroid 20 0.0 48 0.0
Mileage 16 0.0 45 0.0
MyTracks 1331 9.4 35212 20.5
NotePad 217 17.5 2625 26.0
NPR 4171 21.0 251251 30.5
OpenManager 392 0.8 5803 1.5
OpenSudoku 111 23.4 980 33.3
SipDroid 905 32.9 13604 51.6
SuperGenPass 195 0.0 2110 0.0
TippyTipper 341 0.0 5405 0.0
VLC 42 0.0 131 0.0
VuDroid 52 0.0 276 0.0
XBMC 5728 62.3 1330605 71.0
TABLE V . R UN-TIME FEASIBILITY OF GENERATED TEST CASES .
Application Static Feasible
APV 88 88
BarcodeScanner 516 88
OpenManager 389 364
SuperGenPass 195 195
TippyTipper 341 341
VuDroid 52 52
Summary. Columns 1;2and2;3of Table II indicate that
event handlers can have complex behaviors and their tran-
sitions depend on non-trivial sequences of preceding events.
Our analysis is the Ô¨Årst to model these features, leading to
improved static GUI models and test case generation. For
six applications, manual comparison with run-time behavior
indicates that the analysis achieves good precision.
VI. R ELATED WORK
Control-Ô¨Çow analysis for Android. The control/data Ô¨Çow of
Android applications is driven by the GUI and static analysis
of this Ô¨Çow is an important problem. One of the Ô¨Årst related
efforts is the SCanDroid analysis tool [7], [29] which employs
control-Ô¨Çow analysis and intent analysis in the context of a
security analysis. Later work on related security problems [8],
[9], [11] also uses intent analysis and control-Ô¨Çow analysis.
These techniques do not attempt detailed analysis of GUI-
related control/data Ô¨Çow due to widgets and event handlers.
An activity transition graph, used for run-time GUI ex-
ploration [5] and based on [7], [29], has some similarities to
our WTG. This representation does not capture menus/dialogs,
does not consider the general GUI effects of event handlers
(e.g., window-close) and the triggered callbacks, and does not
model the window stack and its state changes. A similar model
of activity transitions is used in an analysis of security-sensitive
behaviors [10]. This approach is much less comprehensive than
ours, in terms of both the model and the analysis algorithm.
The taint analysis in FlowDroid [12] models the effects
of callbacks by creating an artiÔ¨Åcial main method. The Ô¨Çow
of control in this method encodes possible sequences of
callbacks, but does not account for the general GUI effects ofevent handlers, and does not represent control Ô¨Çow that spans
multiple activities. This approach cannot capture the callback
sequences described in Table I. Control Ô¨Çow involving dialogs,
menus, and window termination is also not captured. A more
comprehensive solution is available from our prior work [30],
where ordering constraints between callbacks are represented
by a callback control-Ô¨Çow graph. This work provides event
handler analysis for our WTG analysis (to detect window
open/close effects of callbacks). However, this earlier approach
does not represent the window stack, the push/pop sequences at
transitions, or the path feasibility based on these sequences. It
also ignores several categories of lifecycle callbacks, cannot
represent correctly the callback interleavings from Table I,
does not handle operations that close the owner, and does not
represent the effects of rotate ,home , and power .
An existing operational semantics for activities [40] cap-
tures aspects of Android control Ô¨Çow, including callbacks and
the activity stack, but does not deÔ¨Åne GUI static models or
analysis algorithms. Various other static analyses aim to model
the sequences of callbacks in Android, in the context of se-
curity analysis (e.g., [13]‚Äì[15], [31]), GUI model construction
(e.g., [28]), race detection (e.g., [16]), leak analysis (e.g., [17],
[22]), and static checking (e.g., [23], [24]). None of these
techniques provide comprehensive behavior deÔ¨Ånition/analysis
for the key aspects of GUI behavior: widgets, event handlers,
callback sequences, and window stack changes. We develop
a more general approach for static analysis and representation
of Android GUI behavior, which provides a promising starting
point for generalizing existing (and future) static analyses.
GUI models for understanding and testing. Reverse engi-
neering of GUI models is well developed in prior work (e.g.,
[41]‚Äì[43]) and has more recently been used for Android (e.g.,
[5], [6], [28], [44], [45]). The models are usually constructed
through dynamic exploration. As results from [30] indicate, a
static approach could produce more comprehensive models‚Äî
of course, at the expense of potential infeasibility. For the
purposes of program understanding, hybrid static/dynamic
techniques are the most promising. Existing examples of such
techniques [5], [28] may beneÔ¨Åt from our static GUI models,
including the path validity check which could be beneÔ¨Åcial
for dynamic GUI crawling. Finite state machines and similar
models for GUI testing have been used widely (e.g., [1]‚Äì
[4], [42], [46]‚Äì[49]), and various test generation schemes can
be employed (e.g., [47]). Techniques have been proposed to
improve the generated test cases (e.g., [50]‚Äì[52]) and it may
be possible to integrate them with WTG-based test generation.
VII. C ONCLUSIONS
A representation of window/callback sequences is a foun-
dation for static analyses for Android. One can draw an
analogy with the interprocedural control-Ô¨Çow graph [37], a
key representation for traditional static analysis. We propose
the WTG as a similarly-important static model for Android,
and develop algorithms for its construction and traversal. In
the future, it is important to generalize this work to handle
more comprehensive control Ô¨Çow in Android applications.
Acknowledgments. We thank the ASE reviewers for their
valuable feedback. This material is based upon work supported
by the U.S. National Science Foundation under CCF-1319695
and CCF-1526459, and by a Google Faculty Research Award.REFERENCES
[1] T. Takala, M. Katara, and J. Harty, ‚ÄúExperiences of system-level model-
based GUI testing of an Android application,‚Äù in ICST , 2011, pp. 377‚Äì
386.
[2] C. S. Jensen, M. R. Prasad, and A. M√∏ller, ‚ÄúAutomated testing with
targeted event sequence generation,‚Äù in ISSTA , 2013, pp. 67‚Äì77.
[3] D. Yan, S. Yang, and A. Rountev, ‚ÄúSystematic testing for resource leaks
in Android applications,‚Äù in ISSRE , 2013, pp. 411‚Äì420.
[4] S. Yang, D. Yan, and A. Rountev, ‚ÄúTesting for poor responsiveness in
Android applications,‚Äù in MOBS , 2013, pp. 1‚Äì6.
[5] T. Azim and I. Neamtiu, ‚ÄúTargeted and depth-Ô¨Årst exploration for
systematic testing of Android apps,‚Äù in OOPSLA , 2013, pp. 641‚Äì660.
[6] D. AmalÔ¨Åtano, A. R. Fasolino, P. Tramontana, S. De Carmine, and
A. M. Memon, ‚ÄúUsing GUI ripping for automated testing of Android
applications,‚Äù in ASE, 2012, pp. 258‚Äì261.
[7] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, ‚ÄúSCanDroid: Automated
security certiÔ¨Åcation of Android applications,‚Äù University of Maryland,
College Park, Tech. Rep. CS-TR-4991, 2009.
[8] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, ‚ÄúAnalyzing inter-
application communication in Android,‚Äù in MobiSys , 2011, pp. 239‚Äì252.
[9] M. Grace, Y . Zhou, Z. Wang, and X. Jiang, ‚ÄúSystematic detection of
capability leaks in stock Android smartphones,‚Äù in NDSS , 2012.
[10] C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, and W. Zou,
‚ÄúSmartDroid: An automatic system for revealing UI-based trigger
conditions in Android applications,‚Äù in SPSM , 2012, pp. 93‚Äì104.
[11] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, and
Y . le Traon, ‚ÄúEffective inter-component communication mapping in
Android with Epicc,‚Äù in USENIX Security , 2013.
[12] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y . Le Traon, D. Octeau, and P. McDaniel, ‚ÄúFlowDroid: Precise con-
text, Ô¨Çow, Ô¨Åeld, object-sensitive and lifecycle-aware taint analysis for
Android apps,‚Äù in PLDI , 2014, pp. 259‚Äì269.
[13] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang, ‚ÄúCHEX: Statically vetting
Android apps for component hijacking vulnerabilities,‚Äù in CCS, 2012,
pp. 229‚Äì240.
[14] J. Huang, X. Zhang, L. Tan, P. Wang, and B. Liang, ‚ÄúAsDroid:
Detecting stealthy behaviors in Android applications by user interface
and program behavior contradiction,‚Äù in ICSE , 2014, pp. 1036‚Äì1046.
[15] Y . Feng, S. Anand, I. Dillig, and A. Aiken, ‚ÄúApposcopy: Semantics-
based detection of Android malware through static analysis,‚Äù in FSE,
2014, pp. 576‚Äì587.
[16] Y . Lin, C. Radoi, and D. Dig, ‚ÄúRetroÔ¨Åtting concurrency for Android
applications through refactoring,‚Äù in FSE, 2014, pp. 341‚Äì352.
[17] A. Pathak, A. Jindal, Y . C. Hu, and S. P. Midkiff, ‚ÄúWhat is keeping my
phone awake?‚Äù in MobiSys , 2012, pp. 267‚Äì280.
[18] Y . Liu, C. Xu, S. C. Cheung, and J. Lu, ‚ÄúGreenDroid: Automated
diagnosis of energy inefÔ¨Åciency for smartphone applications,‚Äù TSE,
vol. 40, pp. 911‚Äì940, Sep. 2014.
[19] A. Banerjee, L. K. Chong, S. Chattopadhyay, and A. Roychoudhury,
‚ÄúDetecting energy bugs and hotspots in mobile apps,‚Äù in FSE, 2014,
pp. 588‚Äì598.
[20] ‚ÄúStopping and restarting an activity,‚Äù developer.android.com/
training/basics/activity-lifecycle/stopping.html .
[21] P. Dubroy, ‚ÄúMemory management for Android applications,‚Äù in Google
I/O Developers Conference , 2011.
[22] C. Guo, J. Zhang, J. Yan, Z. Zhang, and Y . Zhang, ‚ÄúCharacterizing and
detecting resource leaks in Android applications,‚Äù in ASE, 2013, pp.
389‚Äì398.
[23] S. Zhang, H. L√º, and M. D. Ernst, ‚ÄúFinding errors in multithreaded
GUI applications,‚Äù in ISSTA , 2012, pp. 243‚Äì253.
[24] E. Payet and F. Spoto, ‚ÄúStatic analysis of Android programs,‚Äù IST,
vol. 54, no. 11, pp. 1192‚Äì1201, 2012.
[25] ‚ÄúTasks and back stack,‚Äù http://developer.android.com/guide/
components/tasks-and-back-stack.html .[26] ‚ÄúAPV PDF viewer,‚Äù code.google.com/p/apv .
[27] ‚ÄúAndroid dialogs,‚Äù http://developer.android.com/guide/
topics/ui/dialogs.html .
[28] W. Yang, M. Prasad, and T. Xie, ‚ÄúA grey-box approach for automated
GUI-model generation of mobile applications,‚Äù in FASE , 2013, pp. 250‚Äì
265.
[29] ‚ÄúSCanDroid: Security CertiÔ¨Åer for anDroid,‚Äù spruce.cs.ucr.edu/
SCanDroid/tutorial.html .
[30] S. Yang, D. Yan, H. Wu, Y . Wang, and A. Rountev, ‚ÄúStatic control-
Ô¨Çow analysis of user-driven callbacks in Android applications,‚Äù in ICSE ,
2015, pp. 89‚Äì99.
[31] S. Liang, A. W. Keep, M. Might, S. Lyde, T. Gilray, P. Aldous, and
D. Van Horn, ‚ÄúSound and precise malware analysis for Android via
pushdown reachability and entry-point saturation,‚Äù in SPSM , 2013, pp.
21‚Äì32.
[32] S. Yang, ‚ÄúStatic analyses of GUI behavior in Android applications,‚Äù
Ph.D. dissertation, Ohio State University, 2015.
[33] A. Rountev and D. Yan, ‚ÄúStatic reference analysis for GUI objects in
Android software,‚Äù in CGO , 2014, pp. 143‚Äì153.
[34] D. Yan, ‚ÄúProgram analyses for understanding the behavior and per-
formance of traditional and mobile object-oriented software,‚Äù Ph.D.
dissertation, Ohio State University, Jul. 2014.
[35] ‚ÄúIntents and intent Ô¨Ålters,‚Äù developer.android.com/guide/
components/intents-filters.html .
[36] D. Octeau, D. Luchaup, M. Dering, S. Jha, and P. McDaniel, ‚ÄúCom-
posite constant propagation: Application to Android inter-component
communication analysis,‚Äù in ICSE , 2015, pp. 77‚Äì88.
[37] M. Sharir and A. Pnueli, ‚ÄúTwo approaches to interprocedural data
Ô¨Çow analysis,‚Äù in Program Flow Analysis: Theory and Applications ,
S. Muchnick and N. Jones, Eds. Prentice Hall, 1981, pp. 189‚Äì234.
[38] ‚ÄúRobotium testing framework for Android,‚Äù code.google.com/
p/robotium .
[39] ‚ÄúG ATOR : Program Analysis Toolkit For Android,‚Äù web.cse.ohio-
state.edu/presto/software/gator .
[40] E. Payet and F. Spoto, ‚ÄúAn operational semantics for Android activities,‚Äù
inPEPM , 2014, pp. 121‚Äì132.
[41] A. M. Memon, I. Banerjee, and A. Nagarajan, ‚ÄúGUI ripping: Reverse
engineering of graphical user interfaces for testing,‚Äù in WCRE , 2003,
pp. 260‚Äì269.
[42] A. M. Memon and Q. Xie, ‚ÄúStudying the fault-detection effectiveness
of GUI test cases for rapidly evolving software,‚Äù TSE, vol. 31, no. 10,
pp. 884‚Äì896, 2005.
[43] F. Gross, G. Fraser, and A. Zeller, ‚ÄúSearch-based system testing: High
coverage, no false alarms,‚Äù in ISSTA , 2012, pp. 67‚Äì77.
[44] P. Tramontana, ‚ÄúAndroid GUI Ripper,‚Äù wpage.unina.it/
ptramont/GUIRipperWiki.htm .
[45] P. Wang, B. Liang, W. You, J. Li, and W. Shi, ‚ÄúAutomatic Android GUI
traversal with high coverage,‚Äù in CSNT , 2014, pp. 1161 ‚Äì 1166.
[46] L. White and H. Almezen, ‚ÄúGenerating test cases for GUI responsibil-
ities using complete interaction sequences,‚Äù in ISSRE , 2000, pp. 110‚Äì
121.
[47] A. M. Memon, M. L. Soffa, and M. E. Pollack, ‚ÄúCoverage criteria for
GUI testing,‚Äù in FSE, 2001, pp. 256‚Äì267.
[48] A. M. Memon, ‚ÄúAn event-Ô¨Çow model of GUI-based applications for
testing,‚Äù STVR , vol. 17, no. 3, pp. 137‚Äì157, 2007.
[49] Q. Xie and A. M. Memon, ‚ÄúUsing a pilot study to derive a GUI model
for automated testing,‚Äù TOSEM , vol. 18, no. 2, pp. 7:1‚Äì7:35, 2008.
[50] X. Yuan and A. M. Memon, ‚ÄúGenerating event sequence-based test
cases using GUI run-time state feedback,‚Äù TSE, vol. 36, no. 1, pp. 81‚Äì
95, 2010.
[51] X. Yuan, M. B. Cohen, and A. M. Memon, ‚ÄúGUI interaction testing:
Incorporating event context,‚Äù TSE, vol. 37, no. 4, pp. 559‚Äì574, 2011.
[52] S. Arlt, A. Podelski, C. Bertolini, M. Sch√§f, I. Banerjee, and A. M.
Memon, ‚ÄúLightweight static analysis for GUI testing,‚Äù in ISSRE , 2012,
pp. 301‚Äì310.