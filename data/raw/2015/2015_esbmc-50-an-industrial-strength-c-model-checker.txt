ESBMC 5.0
An Industrial-Strength C Model Checker‚àó
Mikhail R. Gadelha
University of Southampton
United KingdomFelipe R. Monteiro
Federal University of Amazonas
BrazilJeremy Morse
University of Bristol
United Kingdom
Lucas C. Cordeiro
University of Manchester
United KingdomBernd Fischer
University of Stellenbosch
South AfricaDenis A. Nicole
University of Southampton
United Kingdom
ABSTRACT
ESBMC is a mature, permissively licensed open-source context-
bounded model checker for the verification of single- and multi-
threadedCprograms.Itcanverifybothpredefinedsafetyproperties
(e.g., bounds check, pointer safety, overflow) and user-defined pro-
gramassertionsautomatically.ESBMCprovidesC++andPython
APIs to access internal data structures, allowing inspection and ex-
tensionatanystageoftheverificationprocess.Wediscussimprove-
ments over previous versions of ESBMC, including the description
ofnewfront-andback-ends,IEEEfloating-pointsupport,andan
improved k-inductionalgorithm.Ademonstrationisavailableat
https://www.youtube.com/watch?v=YcJjXHlN1v8.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíFormal software verifica-
tion;‚Ä¢Theoryofcomputation ‚ÜíVerificationbymodelchecking ;
‚Ä¢Hardware ‚ÜíBug detection, localization and diagnosis ;
KEYWORDS
Software model checking; k-induction; Bug detection.
ACM Reference Format:
MikhailR.Gadelha,FelipeR.Monteiro,JeremyMorse,LucasC.Cordeiro,
BerndFischer,andDenisA.Nicole.2018.ESBMC5.0:AnIndustrial-Strength
CModelChecker.In Proceedingsofthe201833rdACM/IEEEInternational
Conference on Automated Software Engineering (ASE ‚Äô18), September 3‚Äì7,
2018, Montpellier, France. ACM, New York, NY, USA, 4pages.https://doi.
org/10.1145/3238147.3240481
1 INTRODUCTION
ESBMC is a mature bounded model checking (BMC) tool for multi-
threaded C programs. Its development started in 2008 on top of
the CProver framework [ 1], but almost all components have been
re-designed and re-implemented in subsequent years, including
thebasicdatastructures,front-end,symbolicexecution,memory
model,andback-end.Thepurposeofthispaperistodescribethe
recenttoolmodificationsandextensions,including (i)amorerobust,
‚àóE-mail:esbmc@googlegroups.com
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3240481clang-based [ 2] frontend; (ii)an improved handling of floating-
pointarithmetics; (iii)animproved k-inductionschemethatallows
ESBMC to better handle programs with unbounded loops; and (iv)
a Python API that gives users access to ESBMC‚Äôs data structures.
ESBMCprimarilyaimstohelpsoftwaredevelopersbyfinding
subtle bugs in their code (e.g., array bounds violations, NULL-
pointerdereferences,arithmeticoverflows,ordeadlocks).Itdoes
not require any special annotations in the source code to find such
bugs,butitdoesallowuserstoaddtheirownassertionsandalso
checksforviolationsofthese.Inaddition,ESBMCimplements k-
induction [ 3] and can be used to provethe absence of property
violations (resp. the validity of user-defined assertions). It relies
on off-the-shelf satisfiability modulo theory (SMT) solvers such as
Boolector,Z3,Yices,MathSAT,andCVC4tocheckautomatically
the verification conditions corresponding to the safety properties.
ESBMChasbeenappliedtoalargenumberofapplicationsinclud-
ingtelecommunications,controlsystems,andmedicaldevices[4].
Itisopensource(underthetermsoftheApacheLicense2.0)and
its source code and self-contained binaries for 64-bit Linux envi-
ronments are available at https://github.com/esbmc/esbmc/ and
www.esbmc.org, respectively.
2 COMPONENTS AND FEATURES
By default, ESBMC takesaCp r ogram and checks for array bounds
violations,divisionsbyzero,pointersafety(incl.alignment),andall
user-definedproperties.Ithasoptionstocheckforoverflows,mem-ory leaks, deadlocks and data-races, and to choose between a fixed-
or(IEEE)floating-pointarithmetic.Figure 1showsitsarchitecture.
Front-end. ESBMC now uses clang [ 2], a state-of-the-art com-
piler suite for C/C++/ObjectiveC/ObjectiveC++ widely used in in-
dustry[5],asitsfront-end.Asdevelopers,wethusavoidtheneedto
maintainaseparatefront-end,butthisapproachalsobringsanum-
ber of advantages for users: (i)ESBMC provides compilation error
messages as expected from an industrial-strength tool; (ii)ESBMC
leveragesclang‚Äôspowerfulstaticanalyzertoprovidemeaningful
warnings when parsing the program; (iii)clang can simplify the
inputprogram(e.g.,calculate sizeofexpressions,evaluatestatic
asserts),whichsimplifiestheanalysisofthecode.Notethatweuse
clang‚ÄôsAPItoaccessandtraversetheprogramAST,withouthaving
details of the input program compiled away, which differs from
other verifiers (e.g., LLBMC [6]) that rely on the LLVM bytecode.
Control-flow Graph (CFG) Generator. The CFG generator
takes the program AST and transforms it into an equivalent GOTO
program:asimplifiedrepresentationthatconsistsonlyofassign-
ments,conditionalandunconditionalbranches,assumes,andasser-
tions. In particular, this step eliminates all for,while,do-while
andswitchstatements. It also adds checks for division by zero
888
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France M. R. Gadelha, F. R. Monteiro, J. Morse, L. C. Cordeiro, B. Fischer, and D. A. Nicole

(!
	
" "
	  " 

 
 &"( 
'%$ 	
 &"$"" !"$(
 #%!
$  %
" !"$(& $ 

 %"
 &"$""$ %##%
 %$"'!

	
Figure1:ESBMCarchitecturaloverview.ThetooltakesaCprogramasinput.ItthenconvertstheASTgeneratedbyclanginto
a CFG and the symbolic execution engine unrolls the program and generates the SSA form of the program. The SSA is then
converted to an SMT formula which is satisfiable only if the program contains errors.
and out-of-bounds access (and for integer and floating-point over-
flow,ifenabled).In k-inductionmode(cf.Section 3)italsoanalyses
loopbodiesand‚Äúhavocs‚Äùanyvariablewritten-toinsidealoopwith
non-deterministicvalues;thehavockedvariablesareusedbythe
inductive step to over-approximate the loop.
Symbolic Execution Engine. ESBMC then symbolically exe-
cutes the GOTO program: it unrolls loops ktimes, generates the
static single assignments(SSA) form of theunrolled program, and
derivesallthesafetypropertiestobecheckedbytheSMTsolver.
This step also inserts pointer safety checks for dynamically allo-
cated memory, if they are enabled. Note that this can only be done
after unrolling because the pointer analysis needs to know the
maximumsetofdynamicallyallocatedstructures.ESBMCaggres-
sively simplifies the program to generate small SSA sets, using
constantfoldingandvariousarithmetic(includingfloating-point)
simplifications.
SMT back-end. ESBMC‚Äôs SMT back-end supports five solvers:
Boolector(default),Z3,MathSAT,CVC4andYices.Theback-end
ishighlyconfigurableandallowstheencodingofquantifier-free
formulas with support for bitvectors, arrays, tuple, fixed-point and
floating-point arithmetic (all solvers), and linear integer and real
arithmetic(allsolversbutBoolector).Weusetheback-endtoencode
the SSA form of the program into a quantifier-free formula and
check satisfiability of C‚àß¬¨P, whereCis the set of constraints
andPis the set of properties. If the formula is SAT, the program
containsa bug:ESBMCwillgenerate acounterexample with the
set of assignments that lead to the property violation.
Python API. ESBMCnowincludesaPythonAPIthatreduces
the difficulty of prototyping new features and makes the tool in-
ternals accessible to a wider audience, i.e., the verification process
showninFigure 1canbeinterceptedandchangedatanypoint.For
example, a developer can easily add their own intrinsic function to
model a new library function or to exploit a different SMT theory:
1def symex_step(self, art):
2# Boilerplate accessing instruction 'insn' omitted
3ifinsn.type == gptypes. FUNCTION_CALL:
4call = esbmc. downcast_expr( insn.code)
5sym = esbmc.downcast_expr( call.function)
6 ifsym.name. as_string() == 'c::isnan':
7 # Interpretation of call here
8 return
9# Otherwise call through to rest of ESBMC
10super(ThisClass, self). symex_step(art)
Thecodeoverridesthedefaultinstructioninterpretationfunction
(l1),andforfunction-callinstructions(l3)aquiresthecalldefinition
(l4), the name of the called function (l5), and should it be named‚Äôisnan‚Äô(l6)appliesspecialhandling(l7,detailsomitted).Forallother
instructionsthedefaultinstructioninterpretationfunctioniscalled
(l10).
Python is well-known for its expressiveness (e.g., set compre-
hensions)andthelanguagebindingseliminatetheneedtoconsider
object lifetime and other low-level details. Rapid prototyping is en-
couragedbyavoidingrecompilationofthemaintool;itenablesnew
verificationideastobequicklytested.However,thePythonAPIalso
has drawbacks‚Äîit is slower than C++, and developers can operate
itillegally,causingthetooltocrash.Inthelongterm,itwouldthus
be desirable to provide ESBMC as a library of verification facilities
for the development of new tools.
3 THE K-INDUCTION PROOF RULE
k-induction allows BMC to find a property violation or even to
prove (partial) correctness without fully unwinding loops. ESBMC
uses the algorithm in an iterative deepening style:
kind (P,k)=‚éß‚é™‚é™‚é™‚é®‚é™‚é™‚é™‚é©Pcontains a bug ,ifB(k)is SAT
Pis correct ,ifB(k)‚àß[F(k)‚à®I(k)] is UNSAT
kind (P,k+1),otherwise .
Here, the base case formulaB(k)is the standard BMC formula,
which is satisfiable iffthe program has a counterexample of length
kor less. If all states are reachable for the current k, we know
thattheprogrammustbecorrectwithoutcheckingtheinductive
step.The forwardcondition F(k)formalizesthis;itcanbederived
fromtheprogrambyinserting unwindingassertions aftereachloop.
Thisstepisparticularlyusefulforprovingsafetyinthepresence
of bounded loops. The inductive step I(k)checks that, if a safety
property holds in the first ksteps, then it also holds for k+1 steps.
Iterative deepening implies that ESBMC always finds the smallest
kto either prove correctness or find a property violation.
ESBMC nowuses scheme improvedover the earlierversion de-
scribedbyGadelhaetal.[ 3].Inparticular,thisnewversionnolonger
collects havocked variables into states, rewriting every access to
these variables into state accesses. Instead, the havocked variables
are directly assigned nondeterministic values in the inductive step.
Thisisasimplerandmoreaccuratetransformationandfollowsthe
workbyDonaldsonetal.[ 7].Note,however,thattheirimplemen-
tation works by unwinding the program during CFG generation,
thus replicating the loop ktimes and removing the backward jump.
In ESBMC, the algorithm only adds the nondeterministic assign-
mentsbeforetheloopandtherequiredassumptions[ 3]duringCFG
generation, and relies on the symbolic execution to unroll the loop.
889
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ESBMC 5.0 ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
4 FLOATING-POINT ENCODING IN ESBMC
In previous versions, ESBMC verified programs using a fixed-point
arithmetic[ 4];thisisappropriatefor,e.g.,programsrunningina
number of embedded devices, but not for programs that rely on
floating-pointarithmetic.ThecurrentversionofESBMCencodes
floating-pointarithmeticeitherusingtheSMTtheoryoffloating-
points, fully available in Z3 and, partially, in Mathsat and CVC4,
or using bitvectors, which extends the floating-point arithmetic
support (exceptfor floating-point exceptions) to all solvers that are
currentlyintegrated.Thisisamajorimprovementoverourprior
work [8], where we model most of the C11 standard functions [9].
Currently, MathSAT does not support fp.rem(remainder opera-
tor)andfp.fma(fusedmultiply-add)andCVC4doesnotsupport
sortconversionfunctions.OurSMTbackendfallsbacktothebitvec-
tor mode when an unsupported operation needs to be encoded;
it converts the arguments from floating-points to bitvectors, en-
codes the operation and returns the resulting bitvector encoded as
a floating-point.This isonly possible byusing the (non-standard)
SMT-LIBfunctions fp_as_ieeebv andfp_from_ieeebv toconvert
to and from bitvectors. This process is transparent to the user and
effectivelymeansthatmissingoperationswillbecorrectlyencoded,
despite the lack of support by the underlying solver; it allows us
to use SMT solvers as Boolector and Yices that do not have any
built-infloating-pointtheory.Mostofthefloating-pointoperations
inANSI-CprogramscanbedirectlyconvertedtoSMT;onlytwo
operations needed special handling:
CasttoBoolean. TheSMTstandarddoesnotdefineconversions
betweenBooleanandfloating-pointtypes.InESBMC,whencasting
fromBooleanstofloating-points,an iteoperatorisused,suchthat
the result of the cast is 1 .0 if the Boolean is true; otherwise it is 0 .0.
We encode casts from floating-points to Booleans as conditional
assignments: the cast result is true when the floating is not 0 .0;
otherwise it is false.
Equality. Bitvector assignment and equality operations are en-
codedusingtheequalityoperator( ==).However, theSMTstandard
defines a separate operator for floating-point equalities, the fp.eq
operator, where ‚Äú(fp.eq x y) evaluates to true if x evaluates to -zero
and y to +zero, or vice versa. fp.eq and all the other comparison
operatorsevaluatetofalseifoneoftheirargumentsisNaN‚Äù.The
operator is defined to handle the special symbols from the IEEE
floating-pointstandard,inparticular,signaledzerosand NaNs;for
this reason, ESBMC encodes all equality of floating-points using
thefp.eqoperator,whileassignmentsremainencodedusingthe
equality operator.
5 ILLUSTRATIVE EXAMPLE
WedescribehowtoverifyaCprogramwithESBMCusingthecode
fragment shown in Fig. 2. Here, ESBMC is invoked as follows:
esbmc <file>.c --floatbv --k-induction
where<file>.c istheCprogramtobechecked, --floatbv indi-
cates that ESBMC will use floating-point arithmetic to represent
the program‚Äôs floatanddoublevariables, and --k-induction
selects the k-induction proof rule. The user can select the SMT
solver, property, and verification strategy; esbmc --help provides
the full list of options.
ESBMC unrolls the program in Fig. 2and converts it into SSA
form,to produceverificationconditions(VCs), oneforeachasser-
tionthatcannotbestaticallydetermined.Equations (1)and(2)give
CandPduring the inductive step ( k=2).1#include <math.h>
2intmain() {
3unsigned int N = nondet_uint();
4double x = nondet_double();
5if(x <= 0 || isnan(x))
6 return 0;
7unsigned int i=0 ;
8/*i = nondet_uint();*/
9/*x = nondet_double();*/‚é´‚é™‚é¨‚é™‚é≠inductive step only
10/*__ESBMC_assume(i < N);*/
11 while(i < N) {
12x = (2*x);
13 assert(x>0);
14++i;
15}
16/*__ESBMC_assume(!(i < N));*/ }inductive step only
17 assert(x>0);
18 return 0;
19}
Figure 2: C code fragment. Here nondet_uint() and
nondet_double() stand for non-deterministic integer and
double values, respectively. isnanchecks whether a given
floating-point is a not-a-number (NaN) value. The com-
mentedlines 8-10and16arethetransformationsintroduced
during the inductive step of the k-induction algorithm.
Note that isnan (x1)in Eq.(1)checks if the symbol is a NaN,
which is translated to the fp.isNaN SMT operator. ESBMC also
addsadditionalliteralsforeachclauseof Ptoidentifytherespec-
tiveVCs.Theresultingformula C‚àß¬¨PisthenpassedtoanSMT
solver, where it is checked in less than one second. We can also
introduceabugbyremovingthe isnan (x)checkfromline 5inFig.2,
S1/mapsto‚ÜíN=0
S2/mapsto‚Üíx=‚àíNaN
S3/mapsto‚Üíx>0.0f(effectivelyremoving –¥2fromEq.(1))
which would lead to the counterex-
ample in the right-hand side. Here,
stateS3leadstoanassertionfailure
in line13(i.e.,i fx=‚àíNaN, thenx>0.0fevaluates to false);
ESBMC is also able to detect this violation in less than one second.
C:=‚é°‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£N
1=nondet_uint1
‚àßx1=nondet_double 1
‚àß–¥1=(x1‚â§0.0f)
‚àß–¥2=ite (–¥1,TRUE ,isnan (x1))
‚àßi1=nondet_uint2
‚àßx2=nondet_double 2
‚àß¬¨–¥2=‚áíi1<N1
‚àß–¥3=(i1<N1)
‚àßx3=2.0f‚àóx2
‚àß¬¨–¥2‚àß–¥3=‚áíx3>0.0f
‚àßi2=i1+1
‚àß–¥4=(i2<N1)
‚àßx4=2.0f‚àóx3
‚àßx5=ite (¬¨–¥4,x3,x4)‚é§‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶(1)P:=‚é°‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é£¬¨–¥
2‚àß–¥3‚àß–¥4
=‚áíx4>0.0f
‚àß¬¨–¥2
‚àß(–¥3‚àß¬¨–¥4‚à®¬¨–¥3)
=‚áíx5>0.0f‚é§‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é¶(2)
Fig.2alsoshowsthetransformationsintroducedbytheinduc-
tive step, during k-induction; the transformations are commented
out during the base case and the forward condition. The trans-
formations aim to prove that no property violation is reachable,
regardless of loop unwinding; this is translated to assuming nonde-
terministicvaluestotheloopvariables(lines 8-9),assumingthat
the loop body is evaluated (line 10, the assumption removes every
state that does not satisfy the loop entry condition) and terminates
(line16,theassumptionremoveseverystatethatdoesnotsatisfy
the loop termination condition). Note that, since the inductive step
is an overapproximation, only correctness can be proved, i.e., it
might find spurious counterexamples.
890
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France M. R. Gadelha, F. R. Monteiro, J. Morse, L. C. Cordeiro, B. Fischer, and D. A. Nicole
Table 1: Results from SV-COMP 2018.
2LSCBMCCPA-Seq DepthKESBMC v1.25.2 ESBMC v5.0 Symbiotic UAutomizer UKojakUTaipan
Correct true 189814383790 1184 1957 2822 1418 3902 1725 2292
Correct false 142618562598 1516 1476 1494 1209 1278 514 563
Incorrect true 22019 336 14 1 2 0 3
Incorrect false 53437 92 10 0 0 0 3
Total correct results 332432946388 2694 3433 4316 2627 5180 2239 2855
Total incorrect results 75458 428 24 1 2 0 6
6 EXPERIMENTAL EVALUATION
We evaluated ESBMC over the SV-COMP [ 10] benchmarks, which
comprises 9523 verification tasks that check for property reachabil-
ity (2941 tasks), memory safety (326 tasks), reachability in concur-
rent programs (1047 tasks), overflow (358 tasks), termination (2009
tasks) and reachability in Linux device drivers (2842 tasks). Table 1
shows our experimental results; a detailed description of the dif-
ferent tools and the experimental setup can be found in [ 10]. Here,
a task counts as correct true if it does not contain any reachable
error location or assertion violation, and the tool reports ‚Äúsafe‚Äù;
however,ifthetoolreports‚Äúunsafe‚Äù,itcountsas incorrecttrue.Sim-
ilarly, a task counts as correct false if it does contain a reachable
violation, and the tool reports ‚Äúunsafe‚Äù, together with a confirmed
witness(pathtofailure);otherwise,itcountsas incorrectfalse ac-
cordingly. The difference between the grand total (9523) and the
sum of the two sub-totals gives the number of tasks for which the
tool exhausted time or memory, or failed otherwise.
k-induction. Overall, ESBMC ranked third, behind CPA-Seq
andUAutomizer,with14incorrectfalseresults(10duetoinaccu-
racies in our concurrency and memory models, plus 4 due to bugs
inthesimplifier),and10incorrecttrueresults.However,noneof
theincorrectresultsarerelatedtothe k-inductionalgorithm,and
the results show that ESBMC is currently the best k-induction tool.
ESBMC outperformed CPA-Seq and UAutomizer in the verification
of reachability properties for arrays and memory safety issues.
CBMC also implements k-induction, requiring three different
calls:togeneratetheCFG,toannotatetheprogramandtoverifyit,
whereasESBMChandlesthewholeprocessinasinglecall.Addi-
tionally, CBMCdoes not havea forwardcondition to checkif all
states were reached and relies on a limited loop unwinding [7].
CPA-Seq applies a number of different techniques when verify-
ing a program, so a direct comparison to their k-induction is not
possible; however, a ‚Äúpure k-induction‚Äù version (CPA-kind [ 11])
showed poor results in a previous competition.
DepthKusesaninvariantgeneratortoinstrumentthecodewith
invariants and uses k-induction to verify the program [ 12]. Al-
thoughonewouldexpectbetterresults,DepthKusesanoldversion
of ESBMC to verify the programs; this explains the poor results.
2LS integrates an abstract interpretation invariant generation
between the base case and the inductive step; in contrast to our
k-induction, their version has no forward condition. Overall 2LS
verifies22%fewerbenchmarksthanESBMC(2LSreturns33%fewer
correct results), although it also returns fewer incorrect results.
Comparisonwithold k-inductionschema. Inordertocom-
parewiththeold k-inductionschemausedinESBMCv1.25.2[ 3],we
re-ran it over the current SV-COMP benchmark set. Table 1shows
a 25% increase in correct results and a 95% decrease in incorrect
results,butthisisslightlymisleading:168oftheincorrectresultsproducedbytheoldschemearefromtheconcurrencycategoryand
are caused by the concurrent model used back then. However, the
old scheme also produces incorrect results in the ReachSafety-ECA
(95)andReachSafety-Recursive(28)categories,whicharerelated
to its incorrect approximation of loop termination conditions.
Floating-point verification. ESBMC uses MathSAT for tasks
that involve floating-point arithmetics. This combination not only
outperforms a Z3-based ESBMC, but also all other tools in SV-
COMP.ESBMCachievedthehighestscoreintheReachSafety-Floats
subcategory where it can verify 84% of the tasks (145 out of 172)
within the time and memory restrictions.
7 CONCLUSION AND FUTURE WORK
We presented ESBMC, the first open-source SMT-based context-
bounded model checker to support full C programs [ 4,13]. ESBMC
is a mature tool; here, we focussed on three novel features of ES-
BMCv5.0:thenewclangfront-end,thenewfloating-pointback-end
and,inparticular,ournewimplementationofthe k-inductionproof
rule.ResultsovertheSV-COMP2018benchmarksuiteshowthat
ESBMC is the strongest k-induction tool currently available. We
areextendingthe k-inductionproofruletouseinformationfrom
the inductive step, to make bug finding more efficiently [14].
REFERENCES
[1]E. Clarke, D. Kroening, and F. Lerda, ‚ÄúA tool for checking ANSI-C programs,‚Äù
TACAS, LNCS 2988, 2004, pp. 168‚Äì176.
[2]B. C. Lopes and R. Auler, Getting Started with LLVM Core Libraries. Packt
Publishing, 2014.
[3]M.Y.R.Gadelha,H.I.Ismail,andL.C.Cordeiro.,‚ÄúHandlingloopsinbounded
model checking of C programs via k-induction,‚Äù STTT, vol. 19, no. 1, pp. 97‚Äì114,
2017.
[4]L. C. Cordeiro, B. Fischer, and J. Marques-Silva, ‚ÄúSMT-based bounded model
checkingforembeddedANSI-Csoftware,‚Äù IEEETransactionsonSoftwareEngi-
neering, vol. 38, no. 4, pp. 957‚Äì974, 2012.
[5]C. Metz, ‚ÄúWhy Apple‚Äôs swift language will instantly remake computer program-
ming,‚Äù 204, http://www.wired.com/2014/07/apple-swift/.
[6]F.Merz,S.Falke,andC.Sinz,‚ÄúLLBMC:BoundedmodelcheckingofCandC++
programs using a compiler IR,‚Äù VSTTE, LNCS 7152, 2012, pp. 146‚Äì161.
[7]A. Donaldson, L. Haller, D. Kroening, and P. R√ºmmer, ‚ÄúSoftware verification
using k-induction,‚Äù SAS, 2011, pp. 351‚Äì368.
[8]M.Y.R. Gadelha, L.C. Cordeiro, and D.A. Nicole, ‚ÄúEncoding floating-point num-
bersusingtheSMTtheoryinESBMC:AnempiricalevaluationovertheSV-COMP
benchmarks,‚Äù SBMF, 2017, pp. 91‚Äì106.
[9]R.Smith, WorkingDraft,StandardforProgrammingLanguageC++,2016,[Online;
accessed January-2017].
[10]SoSy-Lab,‚ÄúSV-Comp2018,‚Äù https://sv-comp.sosy-lab.org/2018/,2018,[Online;
accessed January-2018].
[11]D.Beyer,M.Dangl,andP.Wendler,‚ÄúBoostingk-inductionwithcontinuously-
refined invariants,‚Äù CAV, LNCS 9206, 2015, pp. 622‚Äì640.
[12]W. Rocha, H. Rocha, B. Fischer, and L. C. Cordeiro, ‚ÄúDepthk: A k-induction
verifierbasedoninvariantinferenceforCprograms-(competitioncontribution),‚Äù
TACAS, 2017, pp. 360‚Äì364.
[13]L.C. Cordeiro and B. Fischer, ‚ÄúVerifying multi-threaded software using SMT-
based context-bounded model checking,‚Äù ICSE, 2011, pp.331‚Äì340.
[14]M. Y. R. Gadelha, L. C. Cordeiro, and D. A. Nicole, ‚ÄúCounterexample-guided
k-induction verification for fast bug detection,‚Äù CoRR, vol. abs/1706.02136, 2017.
891
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. 