Programming Bots by Synthesizing
Natural Language Expressions into API Invocations
Shayan Zamanirad, Boualem Benatallah, Moshe Chai Barukh, Fabio Casati, and Carlos Rodriguez
School of Computer Science and Engineering
University of New South Wales (UNSW), Sydney, NSW 2052
fshayanz, boualem, mosheb, crodriguezg@cse.unsw.edu.au
University of Trento, Italy / Tomsk Polytechnic University, Russia
fabio.casati@unitn.it
Abstract —At present, bots are still in their preliminary stages
of development. Many are relatively simple, or developed ad-hoc
for a very speciﬁc use-case. For this reason, they are typically
programmed manually, or utilize machine-learning classiﬁers to
interpret a ﬁxed set of user utterances. In reality, real world
conversations with humans require support for dynamically cap-
turing users expressions. Moreover, bots will derive immeasurable
value by programming them to invoke APIs for their results.
Today, within the Web and Mobile development community,
complex applications are being stringed together with a few
lines of code – all made possible by APIs. Yet, developers today
are not as empowered to program bots in much the same way.
To overcome this, we introduce BotBase, a bot programming
platform that dynamically synthesizes natural language user
expressions into API invocations. Our solution is two faceted:
Firstly, we construct an API knowledge graph to encode and
evolve APIs; secondly, leveraging the above we apply techniques
in NLP, ML and Entity Recognition to perform the required
synthesis from natural language user expressions into API calls.
I. I NTRODUCTION
The API economy is in full swing. Applications are rapidly
developed by composing APIs. Companies increasingly struc-
ture their development and internal systems in terms of APIs,
and business strategies for many companies revolve around
APIs. This novel economy facilitates the creation of new
business models and opens many revenue opportunities [1].
Technological advances, the cloud, awareness at the CxO level
(starting from the famous memo by Jef Bezos [2]), and the in-
creased need for business agility are making applications based
on composing APIs mainstream. The “Internet of Things” is
pushing this trend even more by providing API access to all
sort of devices, so that we can use APIs not only to place an
order but also to make coffee.
This paper leverages the API economy in combination with
advances in bots technology to facilitate the development of in-
tuitive computing solutions that connect user needs, expressed
in natural language, with invocations of the APIs that can
fulﬁll these needs. Intuitive computing envision a collaboration
between users and “an intelligent digital assistant that models
user intent, and that suggests or carries out actions likely to
satisfy that intent” [3]. Developing applications that enable
such kind of collaboration today is facilitated by the many
bot builders frameworks and systems provided by nearly everybig IT player such as Facebook [4], Google [5], Microsoft [6],
Amazon [7], IBM Watson [8] and more.
Messaging bots could in fact, be well set as the viable
alternative or even successor of mobile apps [9], [10]. Text
messaging itself are already embedded in many apps and
used by over 3 billion people, with this number is increasing
rapidly [9]. Messaging bots look and feel not much different
to chatting with a friend via instant messaging. There is no
need to learn, understand or navigate disparate interfaces or
languages – yet they carry the potential of being programmed
to automate conversations, transactions or workﬂows [10].
However, at present, bot building systems while useful in
detecting the user’s intent, still require signiﬁcant development
and conﬁguration work for each usage scenario, and they
hardcode the dependency with the APIs to be invoked. In other
words, today, for each class of functionality we want to enable
through a bot, and for each API, we need to hardcode the logic
that interacts with the user to identify their intent and obtain
the desired values for the speciﬁc API parameters. Bot building
framework have no knowledge of these APIs: they support the
identiﬁcation of speciﬁc intents and parameters and then they
can be conﬁgured to make a REST call. APIs are therefore
external to the bot builder and is completely outside of the
process, only appearing at the end in an hardcoded fashion.
Our vision consists of making APIs ﬁrst class citizens of bot
builders. We aim at synthesizing natural language expression,
and at dynamically determining which API to invoke based on
our understanding of the users’ intent and on the knowledge
over an API knowledge graph that describes what the methods
do and how they can be invoked. The vision we set forth in
this paper is that of users being able to talk with assistants
(as some of us do every day with Siri, Alexa or Cortana)
and, with the help of a knowledge of APIs modeled via a
knowledge graph and built incrementally, dynamically identify
intents, APIs fulﬁlling the identiﬁed intent, and collect from
the user the value of the required parameters for invocation. If
successful, this can enable a new approach to the development
of cognitive services where the “program” is built on the
ﬂy based on users’ requests and available services exposed
through APIs.
More speciﬁcally, we devise a technique for synthesizing
natural language user expressions into concrete API calls by
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research - New Ideas832
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. leveraging an API Knowledge Graph (KG) to achieve this. The
API KG contains information about APIs, their declarations,
expressions, parameters and possible values.
II. P RELIMINARIES
The following are accepted terminology as related to bot-
technology [4][5][8]:
Expression. This refers to a natural language user utterance
whilst conversing with a bot (e.g. ’what is the weather
forecast for tomorrow?’). Based on the users’ expression,
the bot recognizes a category such as ’weather condition’,
’ﬁnd restaurant’. This refers to the users’ intention.
Intent. The notion of intent is widely used in conversation
systems, and refers to the users’ purpose in an expression. For
the example above, the underlying intent may be summarized
as’weather condition’. In conversation systems, a fundamen-
tal step to answer a users’ query is to recognize intention.
Entity. A common notion amongst NLP systems, an entity
represents a concept speciﬁc to domain or context. In the
previous example, an expression such as ’what is the weather
like tomorrow?’ identiﬁed a keyword such as ’tomorrow’.
When reshaped as an entity, we link this to a type such as
time/date. Formulating entities often requires analyzing the
keyword in conjunction with the overall intent.
Conversation. In order to execute an action by the bot
(e.g. calling an API), all required parameters would need
to ﬁlled in prior to execution. However, in the event that
something is missing, the bot will typically prompt users with
more questions to obtain any missing information. This back
and forth question-answering between user and bot (and vice
versa) is referred to as conversation.
Action. This ties a high-level user expression into a concrete
execution plan, in order to obtain the required results to
satisfy the user’s query. For example, we may have an action
such as FindRestaurant. In many ways, actions are akin to
functions in traditional programming languages. Whereby, just
like functions, actions also often requires input parameters.
For example, more speciﬁcally the action above could likely
be described as FindRestaurant(type,place,location), such as:
FindRestaurant(‘Italian’,‘cafe’,‘Sydney’).
Our Approach. BotBase builds upon all the above concepts,
plus in our work we propose the notion of Declaration, which
refers to the expressivity of an API. Moreover, the notion
of API and its constituent declarations, in our context are
synonymous with the traditional notion of intent.
Figure 1 illustrates the relationship between expression,
APIs, Declarations, Entities and API Calls.
III. API K NOWLEDGE GRAPH
A. Knowledge Model
We propose a lightweight model to capture useful in-
formation about APIs (and their related information). Such
knowledge, which may be created incrementally and collec-
tively, will signiﬁcantly assist bot programming both during
development and execution. During development, it is the onus
Fig. 1. BotBase Approach – An API-oriented Methodology
of the developer to properly specify set of expressions (or
patterns thereof), possible keywords and the required actions
for each. Clearly, specifying this each time is not only tedious
but likely to lack full inclusion (e.g. there may be some
valid expressions that the developer did not think about).
Thus, the value of a knowledge graph in this context would
alleviate these challenges. More so, in our proposed work the
synthesis technique performs in real-time (with the help of the
knowledge-graph), thus also acting during execution time to
assist in the bot’s processing of the result.
The following are the main entities of our model: API is the
root and contains a name, description, a set of descriptive tags
and a base URI (e.g.api.yelp.com). An API may have
one or more Declarations that are supported for this particular
API. It contains a type (e.g. GET orPOST) and a path (e.g.
/search?term=[term]&location=[location]).
Declarations are linked to a set of textual Sample Expressions.
Declarations may also have one or more Parameters (e.g.
term, location); which may be linked to possible values
Para Values (e.g. food, San Francisco). Parameters also has
arequired ﬁeld to ﬂag if the parameter is optional or not.
Finally, we deﬁne an entity called Value WEValue that
links concrete values with semantically similar words that
are derived from our deep learning model. (Note, WE is an
acronym for Word Embedding.)
B. Knowledge Acquisition
We employ a combination of two techniques for acquisi-
tion and enrichment of new knowledge: Firstly, we harness
crowdsourcing, and this paradigm enables an incremental and
collective approach. Crowdsourced workers such as (i) devel-
opers enrich the KG by entering sample expressions at bot
training time, (ii) end-users enrich the KG whilst talking with
bots. Secondly, we apply deep learning, and this paradigm
introduces a layer of intelligence and automation.
Word Embedding – Deep Learning Model. We use a
deep-learning model called Word Embedding[11] to generate
semantically similar keywords, that relate to existing parameter
values. To more the dense, the easier it makes it to more suc-
cessfully link arbitrary user expressions with API declaration.
833
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. This is because we would be able to better recognize a match
to the API’s declaration and parameters, and ﬁnd an API that
would useful to process the expression’s intent.
More speciﬁcally, the model we use is Word2vec [11]. This
model takes as input a corpus and produces a vector-space
where each word in the corpus is represented by a vector.
Words that are semantically similar are close to each other in
the vector space and such distance is typically measured with
the help of the cosine similarity metric [12]. While our model
can be trained on any text corpus, in this paper we use a dataset
of Wikipedia1because it is general and it covers a variety of
topics. This corpus contains more than 2 billion words. The
neural network uses 150 hidden layers; sliding window size of
ﬁve; skip gram with negative sampling[11]; sets the minimum
occurrence of a words to ﬁfty (i.e. the word must appear at
least ﬁfty times to be inside the training set); and ignores
stopwords by using the NLTK[13] library for preprocessing
the corpus. Our trained model contains both unigrams (e.g.
car, restaurant, computer) and biagrams2(e.g. Opera House,
New York, ice cream).
We use our trained model (i) in API KG enrichment
process: for a given parameter value (e.g. ”Paris”), we can
add its neighbours (from the word embedding model) such
as”Sydney”, ”New York”, ”London” as another possible
values for that parameter (e.g. ”location”), (ii) in the synthesis
process: for an extracted value (e.g. ”Melbourne”) from user
expression, we can link it to the most relevant parameter
(e.g. ”location”) by computing similarity ratio between the
extracted value and values already linked to that parameter
inside the API KG.
IV. S YNTHESIS OF EXPRESSION TO API
BotBase is actualized as a set of components, that when
placed in orchestration serves to fulﬁll the fundamental goal
of mapping a natural language user expression into a concrete
API call. We refer to this overall process as “synthesis”.
Underlying this process, the components critically relies on
the intelligence of the knowledge graph and word embedding
model that we proposed in the previous section. This process
(or even individual components) could potentially be used
at every stage of a bots lifecycle. For example, during bot
development, a bot developer usually have to select the API
and declaration from a pool of APIs. Especially when there are
a large number of APIs, this could be much simpliﬁed using
the KG to help guide the developer select the matching API/s.
The developer could input a set of sample user expressions –
and then feed them into the process to discover the API that the
synthesis process deems most relevant. Similarly, during bot
training, developers may enter sample expressions, to allow
the bot to learn possible values for the various parameters
of the selected API declaration. Finally, during execution, of
course it serves the fundamental purpose of processing user
expressions into API calls.
1https://dumps.wikimedia.org/
2https://en.wikipedia.org/wiki/Bigram
Fig. 2. Entity Extractor using Stanford POS Tagger and Word Embedding
Figure 3 illustrates the functional architecture of these com-
ponents in orchestration. We now describe in more detail, the
role and individual functionality of each of these components:
Entity Extractor. This component takes a user expression and
decomposes into a set of entities; which are then classiﬁed into
nouns, adjectives and proper nouns with the help of Stanford
POS tagger [14]. This ﬁlters all words that are irrelevant (e.g.,
stop words like theandat). Secondly, this component derives
bigrams (e.g., ice cream andNew York ) with the help of our
word embedding model (Figure 2).
API Selector. Upon performing entity extraction from the
inputted user expression, this provides the ﬁrst step towards
understanding the basic intent. Accordingly, we can use this
information to select APIs that could potentially be a match in
satisfying the user’s request. We can match with APIs based
on semantic similarity: this means, using the extracted entity
information (i.e. nouns, verbs, as well as complex analysis
derived from bigrams, see Figure 2), we can match with
APIs in the KG by comparing with their associated tags,
parameter names and values. It is important to note ﬁnding
the best API match will require additional layers of analysis,
namely examining the declarations of APIs and checking if
their parameter signatures are covered. This will therefore be
dealt with at subsequent steps (as we will describe in more
detail below). However, the purpose of this stage is to perform
an early ﬁltration and produce a set of viable APIs.
API Declaration Selector. Now that we have a viable
set of APIs, the next step is identifying the best matched
declarations. We may recall, declaration curated in the KG
are linked with “sample expressions”. Accordingly, we can
perform semantic similarity analysis between the inputted user
expression and the set of sample expressions stored for each
834
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. Fig. 3. Synthesis Process – Natural Language User Expressions into API Invocations
declaration. To implement this, we again leverage our word
embedding model to compute semantic similarity. We compute
the vector representation of both the inputted user expression
and each of the sample expressions as follows:
  !S=nX
i=1  !Swiwhere  !Swi2WE
  !
Tk=nX
i=1 !
Tk
wiwhere !
Tk
wi2WE(1)
where  !Sand  !
Tkare the vector representation of the user
expression and a sample expression from the API Knowledge
Graph respectively;  !Swiand !
Tk
wiare the vector representation
of a single word within each expression. WE is the vector
space deﬁned by the Word Embedding model.
The actual semantic similarity of  !Sand  !
Tkis computed
using the cosine similarity metric [12]. Using this metric, the
API Declaration Selector chooses the declaration that has the
highest score for similarity , which is equated as follows:
expr= arg max
  !
Tk
i
similarity (  !S ;  !
Tk
i)
dec =declaration(expr)(2)
where expris the sample expression from the API Knowl-
edge Graph that has the highest similarity with the user
expression  !S, and decis the declaration that is associated to
the sample expression. The declaration is obtained through the
function declaration above that takes as input an expression
and returns an API declaration.
Entity-Parameter Mapper(EPM). We are now ready to
map extracted entities to the parameters of the chosen
declaration. Let’s return to our earlier example for
illustration. Consider we have a user expression that
states, “Is there any Chinese restaurant near SydneyOpera House”, and the selected API declaration is
api.yelp.com/search?term=[term]&location=
[location]. The job of the Entity-Parameter Mapper is to
recognize that Chinese restaurant should be mapped to the
parameter term, and that Sydney Opera House tolocation.
In order to determine which entity should be mapped to
which parameter, we once again apply the Word Embedding
model. We compute for each parameter of the selected API
declaration, the semantic similarity with stored parameter
values for that declaration. (We may recall these stored values
are acquired based on the methods discussed at Section III-B).
Therefore, more speciﬁcally in this example, if we compare
the input entity Chinese, with all stored parameter values of
the selected API declaration, we could conclude the keyword
Chinese is probably a value of the term parameter because of
its semantic similarity with e.g. ’French’, which is also a value
of the term parameter as stored in the Knowledge Graph.
The output of the EPM component is paraValue matrix.
It contains parameter-value pairs (i.e. mapped entities to
parameters), together with conﬁdence ratio for each. We also
use a component named KG updater to store new values into
the knowledge graph as users are conversing with the bot.
This component only store new values provided the conﬁdence
ratio above a certain threshold. At this stage, we set it to
0:40. However, this may considered an initial threshold for
experimentation purposes. We believe, as increasingly more
knowledge is gained, it will become clearer to understand the
right balance, and this ﬁgure will be more precise.
Coverage Checker. This component is responsible for per-
forming two main tasks: (i) Firstly, to choose the best dec-
laration that has the maximum number of fulﬁlled required
parameters amongst candidate API declarations; (ii) Secondly,
to make sure that all the required parameters of the selected
declaration are fulﬁlled before calling the API. Accordingly,
theCoverage Checker component takes two inputs: the can-
didate API declarations; and secondly, the paraValue matrix
that was produced by the previous component.
835
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. We determine coverage for each viable declaration by
computing the following:
coverage(dec k) =PN
i=1mapping (pi)
N
mapping (pi) =(
1piis mapped to a value
0piis not mapped to a value(3)
where coverage(dec k)represents the ratio of parameters
of the declaration deckwith a value assigned to it,
mapping (pi)2f0; 1gindicates whether or not a parameter
has been mapped to a value, and Nis the total count
of required parameters for the API declaration. When this
component is performed during execution, we require that
thecoverage(dec k)should be equal to 1. This implies, all
required parameters of the API declaration are fulﬁlled. When
this happens, a call to the API can be performed and the results
returned as a JSON object for processing of the ﬁnal results
and display to end-user. If coverage (dec k)is not equal to
1, then Coverage Checker notiﬁes the end-user, and tries to
obtain the necessary feedback about parameters for which no
suitable value could be found.
In some cases, we may want to choose one declaration
amongst a set (e.g., many declarations appear too similar, or if
used during development mode, the bot developer may simply
wants help to compare various declarations). Accordingly, the
best declaration is picked based on equation (4):
dec= arg max
deck
coverage(dec k)
(4)
where decrepresents the declaration that scored the highest
coverage metric, as deﬁned in equation (3). As a result of
this, the Coverage Checker outputs the best API declaration.
V. R ELATED WORK AND DISCUSSIONS
There is a considerable body of research conducted on
spoken dialog systems. Some works used crowds in areas like
writing and editing [15], image description and interpretation
[16]. Some others worked on taking advantage of the crowd
to empower the dialog system abilities (answer to questions in
several domains with various styles) by creating API calls [17].
BotBase takes inspiration from the latter work for building
API calls dynamically, albeit by using machine learning and
knowledge graph.
Besides, there are some works focused on API recommen-
dation techniques which are relevant to our work. RACK [18]
translates a natural language query into a list of relevant APIs
by mapping keywords to APIs, Portfolio [19] recommends
relevant API methods for a given natural language query by
employing indexing and graph based algorithms, proposed
technique in [20] recommends a graph of API methods from
precise textual phrase matching.
Furthermore, improvements in natural language processing
techniques as well as bot development approaches have led
to a renewal in bots. Most recent efforts in natural languageprocessing have focused on translating user expressions into
program codes [21] [22]. For bot development side, rule-
based approaches such as AIML, RiveScript, ChatScript, Pan-
dorabots and Superscript provide scripting-based languages for
describing service-user conversations as a rule set (e.g., if-
then statements). Flow-based approaches such as Motion.ai,
ChatFuel, Manychat, FlowXO and Sequel provide platforms to
describe end-user conversations as a ﬂowchart (e.g. sequence
of options and actions). Hybrid approaches like Wit.ai, API.ai,
Microsoft LUIS, Meya, Pullstring, Gupshup, Microsoft Bot-
Framework, IBM Conversation Service and Amazon Lex pro-
vide platforms to describe service-user conversations as intents
and natural language expressions. However, these approaches
are forcing developers to handle almost all the parts (e.g.
training bot, writing pieces of codes for each user intents,
interacting with underlying backend services such as APIs,
code invocation commands and programming libraries) to
generate user responses. BotBase beneﬁts from techniques in
hybrid platforms to learn possible values for API parameters
and to enrich its API Knowledge Graph.
The idea of building an API Knowledge graph for BotBase
comes from Augur [23] which is a knowledge graph of human
actions, activities and their relation with objects; KnowBot
[24] a question-answer system that builds a knowledge graph
of concepts (in science) and their relations through conversa-
tional dialogs between user and system; Commandspace [25]
a knowledge graph of user expressions and Adobe Photoshop
application commands; and QF-Graph [26] a mapping between
user’s vocabulary and system features. We use the same idea
to construct API knowledge graph contains API, API declara-
tions, parameters and values. Furthermore, BotBase leverages
concepts in previous effort on synthesizing Java language
codes for a given input text by using PCFG model and
mapping words and API declarations [27]. BotBase constructs
mappings between API declarations to sample expressions and
parameters to values in its knowledge graph.
VI. L IMITATIONS & F UTURE WORK
In this paper, we have unleashed the ﬁrst generation of
our vision towards an era of intelligent bots that learns from
complex data sets and mimics the way of the human brain. At
this stage, we make certain assumptions, we elaborate upon
these limitations below together with possible solutions for
each.
Conversational Bots. AsBotBase is only within its early
stages, it does not yet support conversational bots. At this
stage we assume a stateless environment, where each question
from the user has an answer from the bot, and the bot does not
remember anything from the previous chat messages. Future
works therefore requires a stateful conversation mechanism in
BotBase.
Process Workﬂows. One of the most signiﬁcant limitations
of our current work is the assumption that an action can be
performed by one API declaration alone. While it is true,
there are currently a plethora of APIs and large amounts of
836
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. user requests could in fact be fulﬁlled by a single declaration.
Nevertheless, in future work we intend to support executing
dynamic process workﬂows (i.e. calling upon a series or
combination of APIs) to fulﬁll a user request.
Advanced Knowledge Mining. The success of this proposed
approach depends greatly on the quantity and accuracy of the
knowledge graph. At present, we have acquired a sizable quan-
tity of data using bootstrapping, crowdsourcing and general
purpose Wikipedia corpus to train our word embedding model.
This truly does supply an enormous amount of data, however
in future we would beneﬁt from gathering from other sources
of data, no only formal datasets or corpuses.
VII. C ONCLUSION
In this paper, we provide a solution for dynamically syn-
thesizing natural language user expressions into API invoca-
tions. To achieve this we have proposed a lightweight API
Knowledge Graph that contain the required information about
APIs. We enrich the KG with new APIs, as well as appending
supplementary knowledge about existing APIs. Enrichment is
achieved with the intelligence of deep-learning (Word Embed-
ding model trained by Wikipedia corpus) in conjunction with
crowdsourcing approaches. In the synthesis process, BotBase
beneﬁts from the API KG and the word embedding model to
determine which API to invoke based on user expressions.
ACKNOWLEDGMENT
We Acknowledge Data to Decisions CRC for funding
scholarship on Query Answering and Predictive Techniques
for Analyst Tasks in End-User Big Data Analytic.
REFERENCES
[1] L. Columbus. 2017 is quickly becoming the
year of the api economy. [Online]. Avail-
able: https://www.forbes.com/sites/louiscolumbus/2017/01/29/2017-is-
quickly-becoming-the-year-of-the-api-economy
[2] J. Hernandez, “Jeff bezos’ mandate: Amazon and web services,” Psy-
chology, Management and Leadership, 2012.
[3] U. of Rochester Computer Science (URCS). Intuitive computing.
[Online]. Available: http://www.cs.rochester.edu/research/intuitive/
[4] Wit.ai. (2017) Natural Language for Developers. [Online]. Available:
https://wit.ai/
[5] Api.ai. (2017) Conversational User Experience Platform. Now we’re
talking. [Online]. Available: https://api.ai/
[6] Microsoft. (2016) Build a great conversationalist. [Online]. Available:
https://dev.botframework.com/
[7] Amazon Web Services Inc. (2016) Amazon Lex: Conver-
sational interfaces for your applications. [Online]. Available:
https://aws.amazon.com/lex/
[8] IBM Watson Developer Cloud . (2016)
Conversation Service. [Online]. Available:
https://www.ibm.com/watson/developercloud/conversation.html
[9] H. Francis. Rise of the chatbots: bigger than apps? [Online].
Available: http://www.smh.com.au/technology/technology-news/rise-of-
the-chatbots-bigger-than-apps-20160407-go1ca3.html
[10] B. Sheth. Forget apps, now the bots take over. [Online]. Available:
https://techcrunch.com/2015/09/29/forget-apps-now-the-bots-take-over/
[11] T. Mikolov, I. Sutskever, K. Chen, G. Corrado, and J. Dean,
“Distributed representations of words and phrases and their
compositionality,” in Proceedings of the 26th International Conference
on Neural Information Processing Systems, ser. NIPS’13. USA:
Curran Associates Inc., 2013, pp. 3111–3119. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2999792.2999959[12] D. Jurafsky and J. H. Martin, Speech and Language Processing (2Nd
Edition). Upper Saddle River, NJ, USA: Prentice-Hall, Inc., 2009, ch.
Computational Lexical Semantics.
[13] M. Goossens, F. Mittelbach, and A. Samarin, Natural language process-
ing with Python. O’Reilly Media, Inc., 2009.
[14] C. D. Manning, M. Surdeanu, J. Bauer, J. Finkel, S. J. Bethard,
and D. McClosky, “The Stanford CoreNLP natural language
processing toolkit,” in Association for Computational Linguistics
(ACL) System Demonstrations, 2014, pp. 55–60. [Online]. Available:
http://www.aclweb.org/anthology/P/P14/P14-5010
[15] M. S. Bernstein, J. Brandt, R. C. Miller, and D. R. Karger,
“Crowds in two seconds: Enabling realtime crowd-powered
interfaces,” in Proceedings of the 24th Annual ACM Symposium
on User Interface Software and Technology, ser. UIST ’11. New
York, NY , USA: ACM, 2011, pp. 33–42. [Online]. Available:
http://doi.acm.org/10.1145/2047196.2047201
[16] J. P. Bigham, C. Jayant, H. Ji, G. Little, A. Miller, R. C. Miller, R. Miller,
A. Tatarowicz, B. White, S. White, and T. Yeh, “Vizwiz: Nearly
real-time answers to visual questions,” in Proceedings of the 23Nd
Annual ACM Symposium on User Interface Software and Technology,
ser. UIST ’10. New York, NY , USA: ACM, 2010, pp. 333–342.
[Online]. Available: http://doi.acm.org/10.1145/1866029.1866080
[17] T.-H. K. Huang, W. S. Lasecki, and J. P. Bigham, “Guardian: A crowd-
powered spoken dialog system for web apis,” in Third AAAI Conference
on Human Computation and Crowdsourcing, 2015.
[18] M. M. Rahman, C. K. Roy, and D. Lo, “Rack: Automatic api recommen-
dation using crowdsourced knowledge,” in Software Analysis, Evolution,
and Reengineering (SANER), 2016 IEEE 23rd International Conference
on, vol. 1. IEEE, 2016, pp. 349–359.
[19] C. McMillan, M. Grechanik, D. Poshyvanyk, Q. Xie, and C. Fu,
“Portfolio: Finding relevant functions and their usage,” in Proceedings
of the 33rd International Conference on Software Engineering, ser.
ICSE ’11. New York, NY , USA: ACM, 2011, pp. 111–120. [Online].
Available: http://doi.acm.org/10.1145/1985793.1985809
[20] W.-K. Chan, H. Cheng, and D. Lo, “Searching connected api subgraph
via text phrases,” in Proceedings of the ACM SIGSOFT 20th Interna-
tional Symposium on the Foundations of Software Engineering. ACM,
2012, p. 10.
[21] A. Desai, S. Gulwani, V . Hingorani, N. Jain, A. Karkare, M. Marron,
S. R, and S. Roy, “Program synthesis using natural language,”
inProceedings of the 38th International Conference on Software
Engineering, ser. ICSE ’16. New York, NY , USA: ACM, 2016, pp. 345–
356. [Online]. Available: http://doi.acm.org/10.1145/2884781.2884786
[22] S. Gulwani and M. Marron, “Nlyze: Interactive programming by
natural language for spreadsheet data analysis and manipulation,”
in Proceedings of the 2014 ACM SIGMOD International
Conference on Management of Data, ser. SIGMOD ’14. New
York, NY , USA: ACM, 2014, pp. 803–814. [Online]. Available:
http://doi.acm.org/10.1145/2588555.2612177
[23] E. Fast, W. McGrath, P. Rajpurkar, and M. S. Bernstein, “Augur:
Mining human behaviors from ﬁction to power interactive systems,”
inProceedings of the 2016 CHI Conference on Human Factors in
Computing Systems. ACM, 2016, pp. 237–247.
[24] B. Hixon, P. Clark, and H. Hajishirzi, “Learning knowledge graphs for
question answering through conversational dialog,” in Proceedings of the
the 2015 Conference of the North American Chapter of the Association
for Computational Linguistics: Human Language Technologies, Denver,
Colorado, USA, 2015.
[25] E. Adar, M. Dontcheva, and G. Laput, “Commandspace: Modeling the
relationships between tasks, descriptions and features,” in Proceedings
of the 27th Annual ACM Symposium on User Interface Software and
Technology, ser. UIST ’14. New York, NY , USA: ACM, 2014, pp. 167–
176. [Online]. Available: http://doi.acm.org/10.1145/2642918.2647395
[26] A. Fourney, R. Mann, and M. Terry, “Query-feature graphs: Bridging
user vocabulary and system functionality,” in Proceedings of the 24th
Annual ACM Symposium on User Interface Software and Technology,
ser. UIST ’11. New York, NY , USA: ACM, 2011, pp. 207–216.
[Online]. Available: http://doi.acm.org/10.1145/2047196.2047224
[27] T. Gvero and V . Kuncak, “Synthesizing java expressions from
free-form queries,” in Proceedings of the 2015 ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems,
Languages, and Applications, ser. OOPSLA 2015. New York,
NY , USA: ACM, 2015, pp. 416–432. [Online]. Available:
http://doi.acm.org/10.1145/2814270.2814295
837
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. 