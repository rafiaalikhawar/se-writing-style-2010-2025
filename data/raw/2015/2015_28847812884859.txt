Type-Aware Concolic Testing of JavaScript Programs
Monika Dhok
Indian Institute of Science
monika.dhok@csa.iisc.ernet.inMurali Krishna Ramanathan
Indian Institute of Science
muralikrishna@csa.iisc.ernet.inNishant Sinha
IBM Research, India
nishant.sinha@in.ibm.com
ABSTRACT
Conventional concolic testing has been used to provide high
coverage of paths in statically typed languages. While it has
alsobeenappliedinthecontextofJavaScript(JS)programs,
we observe that applying concolic testing to dynamically-
typed JS programs involves tackling unique problems to en-
sure scalability. In particular, a naive type-agnostic exten-
sion of concolic testing to JS programs causes generation of
large number of inputs. Consequently, many executions op-
erate on undeﬁnedvalues and repeatedly explore same paths
resulting in redundant tests, thus diminishing the scalability
of testing drastically.
Inthis paper, we address this problem by proposinga sim-
pleyeteﬀective approach that incorporates type-awareness
intelligently in conventional concolic testing to reduce the
number of generated inputs for JS programs. We extend
our approach inter-procedurally by generating preconditions
for each function that provide a summary of the relation be-
tween the variable types and paths. Employing the function
preconditions when testing reduces the number of inputs
generated even further.
We implement our ideas and validate it on a number of
open-source JS programs (and libraries). For a signiﬁcant
percentage (on average 50%) of the functions, we observe
thattype-aware concolic testing generates a minuscule per-
centage (less than 5%) of the inputs as compared to con-
ventional concolic testing approach implemented on top of
Jalangi . On average, this approach achieves over 97% of
line coverage and over 94% of branch coverage for all the
functions across all benchmarks. Moreover, the use of func-
tion preconditions reduces the number of inputs generated
by 50%. We also demonstrate the use of function precon-
ditions in automatically avoiding realcrashes due to incor-
rectly typed objects.
CCS Concepts
•Software and its engineering →Software testing and
debugging; Software reliability;
Keywords
Dynamic analysis; JavaScript; Testing
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ’16, May 14-22, 2016, Austin, TX, USA
c/circlecopyrt2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI:http://dx.doi.org/10.1145/2884781.28848591. INTRODUCTION
Dynamic typing [11] in JavaScript (JS) enables modiﬁ-
cations to the object properties during runtime and helps
reduce development time [6]. However, the lack of compile
time warnings increases the possibility of dormant bugs re-
sulting in many type errors in the ﬁeld [12]. Hence, eﬀective
testing frameworks are essential to reduce the maintenance
cost for JS based applications [36, 25, 13, 37, 28, 18]. These
approaches are targeted towards testing various facets of JS
applications – event driven and string intensive web appli-
cations can employ SymJS[25], security vulnerabilities can
be detected using Kudzu[36], web speciﬁc features pertain-
ing to manipulation of domandajaxcan be tested using
Artemis [13], etc. Unfortunately, there is limited support
to generate high coverage test cases for pureJS programs
e.g., nodejs programs, where input types are complex ob-
jects instead of events or strings.
In practice, for programs based on statically typed lan-
guages, concolic testing [20, 38, 19, 31, 24] helps achieve
high coverage. Broadly, this involves a combination of con-
crete and symbolic execution which generates a collection
of symbolic constraints on execution paths [30, 15]. Diﬀer-
ent paths in a program are covered by negating collected
branch constraints appropriately and solving the resultant
collection. When constraints cannot be solved symbolically,
concrete values are provided to ensure completion of the
process. The approach is designed to avoidredundant ex-
ploration of paths.
When conventional concolic testing is applied to JS (as
in [37]), we observe that twokinds of constraints are gener-
ated. Constraints that correspond to program branch con-
ditions, labeled branch constraints (e.g.,z= 1); these con-
straints may be ﬂipped[20, 38] to execute hitherto unex-
plored paths. Constraints that restrict variable types are
calledtype constraints , (e.g.,typeof(z) =number). Testing
diﬀerentcombinationsofbranchconstraintshelpexploredif-
ferent paths in the program. In contrast, type constraints
ensure that the variables are well-typed, which in turn pro-
vides the basis for assigning correct values to them.
When applying concolic testing to JS, we encounter an
unexpected stumbling block to scalability: highly-redundant
input generation. Redundant inputs are inputs that do not
achieve new code coverage with respect to existing tests.
We observe that many of these tests predominantly contain
variables that have not been assigned any value. Such vari-
ables are recognized as undefined in JS. If undeﬁnedness is
expected explicitly, execution of a program in the presence
of undeﬁned values can help achieve more coverage. Other-
wise, thisleadstogeneration ofinputswhichareafeworders
of magnitude more than the actual number of normally ter-
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   168
minating paths.1This is mainly because a large number
of type constraints along with branch constraints are cre-
ated. Treating the branch and type constraints equivalently
causes this redundancy. The problem is further exacerbated
for inter-procedural testing.
In this paper, we address the problem of generating re-
dundant inputs while performing concolic testing of JS pro-
grams. We propose a simple yeteﬀective approach that
incorporates type-awareness to minimize the generation of
redundant inputs by distinguishing branch and type con-
straints. In particular, our approach groups the type con-
straints together and infer the types for all the relevant vari-
ables in a single attempt without trying all possible type
assignments. Branch constraints are handled as usual by
exploring all paths based on all combinations of branches.
We extend our approach to handle inter-procedural JS
programs in a scalable manner. We achieve this by deriving
type preconditions for each function fsuch that each pre-
condition summarizes the correct types of input parameters
inf. Creating call graphs for JS programs is non-trivial due
to its dynamic nature [17]. Therefore, we use a combination
of top-down testing and memoization to create call graphs
incrementally. More speciﬁcally, when concolic testing is
performed on a function fwhich invokes a function gwhose
precondition is unavailable, then the precondition ξgforg
is derived on-demand. Then, ξgis utilized during analysis
forfto restrict the type of variables in f. Thiscomposi-
tionof the function preconditions allow us avoid redundant
execution failures inside nested function calls.
Wehaveimplementedourapproachon Jalangi [37], ady-
namic analysis framework and incorporated our design for
two variants of concolic testing – depth-ﬁrst and breadth-
ﬁrst [20, 38]. Evaluation on multiple open-source JS pro-
grams and libraries reveal that for a majority of the tested
functions, our approach generates only5% of the inputs gen-
erated by the conventional concolic testing in [37]. Employ-
ingpreconditionsduringinter-proceduraltestingreducesthe
number of inputs by 50% across multiple benchmarks.
Wealsoimplementaclientanalysis toavoidcrashes dueto
type related failures in JS. Our analysis monitors the types
and values of parameters for diﬀerent method invocations.
If we detect the absence of any property (ﬁeld, function, etc)
with the help of the derived function precondition, we auto-
matically insert a dummy property and record the problem.
This helps in ensuring that the programs do not crash dur-
ing runtime. We demonstrate the eﬃcacy of the analysis by
applying it on known real issues.
The paper makes the following technical contributions:
•We propose a simple yet eﬀective approach that incorpo-
rates type-awareness to scale concolic testing for JS pro-
grams. We implement two variants of type-aware testing
algorithm (depth-ﬁrst and breadth-ﬁrst).
•We extend the approach to handle testing inter-
procedurally by deriving and composing function precon-
ditions incrementally.
•We validate the scalability of our approach by applying
it on multiple open-source JS programs and libraries and
compare with conventional concolic testing implemented
onJalangi .
1We consider paths that do not trigger runtime exception in
a function as normally terminating paths.2. MOTIV ATION
In this section, we motivate the need for our approach by
usingareal example from hapi-v8.1.0 [8], apopular library
with 99k downloads in the month of July 2015, that provides
a rich framework for building JS applications and services.
It is also under active development with 4400 commits, 188
releases and 125 contributors.
Figure 1 presents a simpliﬁed implementation of two func-
tions_marshal and_streamify fromresponse.js in the li-
brary. Thenumberofintra-proceduralcontrolﬂowpathsare
2 and 7 respectively.2The function _marshal takes one pa-
rameter, invokes _streamify conditionally depending upon
the presence of the ﬁeld, _processors in the invoking ob-
ject, which should not contain the property marshal (lines
3 - 5). Meanwhile, the function _streamify checks the type
of the ﬁrst parameter, and considers the ﬁelds present in the
passed object to perform various operations (lines 19 - 26).
Overall, an invocation of _marshal on a malformed object
can result in a failure at any one of lines 3, 20 and 21 in the
presented code.
1 o1._marshal = function (next) {
2 var self = this;
3 if (!this._processors.marshal) {
4 return this._streamify(this.source, next);
5 }
6 this._processors.marshal(this, function (err, source) {
...
13 });
14 };
17 o1._streamify = function (source, next) {
19 if (source instanceof Stream) {
20 var stream = (source.socket || source ) ;
21 if (stream._readableState.objectMode) {
22 return next(Boom.badImplementation(’error’));
23 }
24 this._payload = source;
25 return next();
26 }
...
55 }
Figure 1 Motivating example.
Initially, when concolic testing is applied to _marshal , the
receiver ( this) does not have ﬁeld _processors causing a
crash at line 3. This results in the inference that it has a
ﬁeld_processors which can be dereferenced and added ap-
propriately. When re-executed, the absence of marshal in
_processors results in the invocation of _streamify at line
4. The check at line 19 will fail because the receiver does not
havesource. Consequently, a new input is generated where
the receiver has sourcewhich is an instance of Stream. The
absence of socketinsourcecausesthis.source to be as-
signed to streamat line 20. Then, the execution crashes
(also referred to as exceptions) again at line 21 due to the
absence of _readableState . With a re-execution where
this.source has_readableState , the absence of object-
Moderesults in condition at line 21 to be false and execution
of lines 24 and 25. This completes the execution of an entire
path. The inference due to the execution will cause object-
Modeto be added as a ﬁeld (default value is zero) causing
lines 24 and 25 to be re-executed. The value of objectMode
is made non-zero to cover the other branch.
2Line 20 is treated as a conditional.
169There are two problems even when an execution com-
pletes (e.g., return at line 25) and is free of crashes. Firstly,
all objects are not well-formed (e.g., this.source.socket
andthis._processors.marshal are undeﬁned). Secondly ,
these undeﬁned variables can introduce redundancy to the
entire process. More speciﬁcally, when the approach back-
tracks to ﬁx the undeﬁned this.source.socket (at line
20) and assigns a zero to it, the constraints pertaining to
_readableState andobjectMode (due to line 21) are elim-
inated. Also, the assignment leads the execution along the
previously explored path. This causes the re-executions
torepeatpreviously seen crashes (and inferences) at line
21, albeit with this.source.socket = 0. Similarly, when
this._processors.marshal is ﬁxed, the redundancy is fur-
thermagniﬁed due to repetition of previously seen crashes
(and inferences) in _streamify at lines 19, 20 and 21, albeit
withthis._processors.marshal = 0.
In summary, the problems with existing concolic testing for
JS are:
•Execution of program in the presence of undeﬁned vari-
ables does not help achieve more coverage, unless unde-
ﬁnednessis expectedexplicitlyin aconditional orthevari-
able type cannot be inferred.
•Deﬁning the undeﬁned variables incrementally results in
repeated exploration of the same paths.
•The redundancy is magniﬁed for inter-procedural testing.
When we test _marshal in conjunction with _streamify ,
concolic testing generated more than 1000 inputs in 1 hour.
A variant of the testing which employs a depth-ﬁrst version
to explore paths (implemented in Jalangi ) generates 72 in-
puts. This diﬀerence in the number of generated tests is
mainly because of the way branches are explored. In con-
trast, we design an approach based on type-aware concolic
testing which generates only8 inputs without loss of cov-
erage. These inputs are also suﬃcient to generate eﬀective
type preconditions for the tested functions.
There are multiple beneﬁts that accrue due to func-
tion preconditions. Apart from their use in inter-
procedural testing, these can help avoid potential crashes
due to invocations with malformed objects. For example,
the derived function precondition of _streamify speciﬁes
thatthis.source._readableState should be present when
this.source is an instance of Streamto avoid the crash at
line 21. This need not always be followed (e.g., see issue
2368 inhapi[5]). The derived preconditions can be used to
monitor the type of this.source and_readableState can
be inserted, whenever absent, during an invocation to avoid
potential runtime crashes [33].
3. DESIGN
We now present the design of type-aware concolic testing
of JS programs. Initially, we present the deﬁnitions in Sec-
tion 3.1 that are used in the rest of the Section. We explain
the extension of conventional concolic testing to JS using
Algorithm 1 which uses (a) Algorithm 2 and 3 to add con-
straints on the execution stack, and (b) Algorithm 4 to ﬂip
the constraints on the stack for new input generation [20].
In Section 3.3, we explain type-aware intra-procedural
concolic testing. We design a modiﬁed ﬂip procedure (Al-
gorithm 5) to resolve type and path constraints separately.
Subsequently, we discuss type-aware inter-procedural test-
ing procedure in Algorithm 6.3.1 Preliminaries
For ease of presentation, we consider a subset of JS, JS-
Lite, over the following grammar:
ap∈accesspath :=v|v.f
e∈expr:=ap|callap|uop e1|e1bop e2
s∈stmt:=v:=e|if(e) gotoℓ
where
v∈Var, bop ∈ {+,−,≤,<,...}, uop∈ {!,−,+,...}
Access paths include variables ( v) and one-level derefer-
ences to the variables ( v.f). An access path v.f.gcan be
represented as a composition of multiple access paths. The
variables are from a set of symbolic variables ( Var). Ex-
pressions include the access paths, invocations of functions,
expressions involving unary ( uop) and binary ( bop) opera-
tions. Statements correspond to assignments or conditional
branches. We maintain the state ( σ) as a ﬁve element tuple:
σ=/an}bracketle{tλ,T,C,S,stack /an}bracketri}ht,
whereλis the function name, Tmaps variables
to concrete type values, CandSmap variables to
concrete and symbolic values respectively, and stack
maintains an ordered list of constraints. We con-
sider the following concrete types in the language:
{number,string,object,function ,null,undefined}.
3.2 Concolic Testing of JavaScript
Algorithm 1 RunConcolic
Input:{λ,T,C,S,stack}
1:stackPos←0;
2:while((I←nextInstruction( λ))/∈{exception,halt })do
3:switch Ido
4: case(ap := e)
5: ap′←eval(ap,S);e′←eval (e,S)
6: AddC(e′,T,stack );AddC(ap′,T,stack);
7: update( ap′,e′,T,C,S )
8: case(if(b) then goto ℓ)
9: AddTC(b, T,stack)
10: if(eval(b, C))thenc←eval(b,S)
11: elsec←neg(eval(b,S))
12: if(stackPos≥stack.length) then
13: stack.push({constraint: c, isbranch:1, ﬂipped:0 })
14: Increment stackPos by one;
15:if(stack.length >0)then
16: Flip(stack);
17: (T′,C′,S′)←solve(stack);
18: RunConcolic (/an}bracketle{tλ,T′,C′,S′,stack/an}bracketri}ht)
The procedure RunConcolic in Algorithm 1 presents
concolic testing algorithm for JS. It takes as input a ﬁve-
tuple state σ, where T,CandSare initialized to value
undefined for all access paths, and the stack is empty. In
RunConcolic ,nextInstruction executes the instructions
in the function λuntil it encounters a haltinstruction or a
crash due to an exception . We describe RunConcolic for
the intra-procedural case where we ignore all the other func-
tion invocations inside that procedure. The return values of
this function is considered as seed input for better coverage.
RunConcolic makes use of two standard auxiliary func-
tionsevalandupdatefor expression evaluation and heap
update, respectively, whose descriptions we omit for brevity.
Given a program term tand a mapping Σ from access paths
to values, eval(t,Σ) evaluates the term tin Σ to a value. If
Σ is concrete, i.e., contains only constant values, then eval
170returns a constant value; else a symbolic term is returned.
Theupdate(l,v,T,C,S ) updates the heap reference corre-
sponding to expression lwith the value of expression vin
bothCandSand also the concrete type of linT.
To evaluate expressions in assignments (line 4), RunCon-
coliccreatestypeconstraints to make sure that expressions
are well-typed, using AddC(Algorithm 2). AddCderives
the type of a given expression eas either object(line 2),
function (lines 3-4) or the operator type (lines 5-9), and
computes a type constraint c, using the uninterpreted func-
tionty. Based on the current concrete type of expression
e, computed using the map T, theAddTC (Algorithm 3)
adds either corneg(c) (lines 2 - 4) to the stack. It also
records that the constraint is not a branch constraint. We
write type constraints of form ty(x) =numasx≏num.
Algorithm 2 AddC
Input: expression e, concrete type map T, stackstack
1:switch edo//recursively
2:case(v.f) :AddTC(T(v)/ne}ationslash=“object”, ty(v)/ne}ationslash=“object”, stack)
3:case(callap) :
4: AddTC(T(ap)/ne}ationslash= “function”, ty(ap)/ne}ationslash= “function”, stack)
5:case(uope1) : /* uopis unary operator*/
6: t←getOperandType( uop);
7: AddTC(T(e1)/ne}ationslash=t,ty(e1)/ne}ationslash=t,stack)
8:case(e1bope2) : /* bopis binary operator*/
9: /*handled similar to unary operators*/
Algorithm 3 AddTC
Input: Boolean value ( b), constraint ( c), stack ( stack)
1:if(stackPos≥stack.length) then
2:if(¬b)thenc=neg(c)
3:stack.push({constraint: c, isbranch:0, ﬂipped:0 });
4:Increment stackPos by one;
For the conditional statement in Algorithm 1 at line 8, it
evaluates the condition bin concrete value map Cand de-
pending upon the result, it adds a branchconstraint c(cor-
responding to bevaluated in symbolic map S) to the stack
using(lines12-14). Ifthecurrentstackpointeris notbeyond
the top of the stack, then the constraint already exists in the
stack (applicable for subsequent runs of the algorithm) and
need not be added. Otherwise, the constraint cis pushed
on the stack along with the annotation flipped= 0, which
tracks whether chas been ﬂipped or not. We also add an
annotation denoting cis a branch constraint.
After collecting all the constraints, Algorithm 1 calls Flip
procedure at line 16. This procedure is used to ﬂip i.e.,
negate the constraint on the top of the stack to explore a
new path. This procedure (Algorithm 4) describes the con-
ventional [20] ﬂipping procedure: ﬁrst, it pops out all con-
straints that are already ﬂipped from the stack. Then, the
unﬂipped constraint at the top of the stack is negated. The
constraints remaining on the stack are solved using a con-
straint solver (the function solve) at line 17. This results in
updated concrete maps T′andC′;RunConcolic is invoked
on the state consisting of the updated maps and the stack.
Algorithm 4 Flip
Input: stack (stack)
1:while(e←stack.top()∧e.ﬂipped) dostack.pop();
2:if(stack.length≥0)then
3:e.constraint←neg(e.constraint );
4:e.flipped←1IDI/p (x, y, z, o) Constraints
1(⊥,⊥,⊥,⊥)x/ne}ationslash≏N, y/ne}ationslash≏N, z/ne}ationslash≏N
2(⊥,⊥, 0,⊥)x/ne}ationslash≏N, y/ne}ationslash≏N, z≏N, z/ne}ationslash= 1
3(⊥,⊥, 1,⊥)x/ne}ationslash≏N, y/ne}ationslash≏N, z≏N, z = 1, o/ne}ationslash≏O
4(⊥,⊥, 1,{})x/ne}ationslash≏N, y/ne}ationslash≏N, z≏N, z = 1, o ≏O, o.bar/ne}ationslash≏F
5(⊥,⊥, 1,{})x/ne}ationslash≏N, y/ne}ationslash≏N, z≏N, z = 1, o ≏O, o.bar ≏F
6(⊥, 0,⊥,⊥)x/ne}ationslash≏N, y≏N, z/ne}ationslash≏N
7(⊥, 0, 0,⊥)x/ne}ationslash≏N, y≏N, z≏N, z/ne}ationslash= 1
8(⊥, 0, 1,⊥)x/ne}ationslash≏N, y≏N, z≏N, z = 1, o/ne}ationslash≏O
9(⊥, 0, 1,{})x/ne}ationslash≏N, y≏N, z≏N, z = 1, o ≏O, o.bar/ne}ationslash≏F
10(⊥, 0, 1,{})x/ne}ationslash≏N, y≏N, z≏N, z = 1, o ≏O, o.bar ≏F
11(⊥, 0, 1,{})x≏N, y/ne}ationslash≏N, z/ne}ationslash≏N
12(⊥, 0, 1,{})x≏N, y/ne}ationslash≏N, z≏N, z/ne}ationslash= 1
... ... ...
Table 1 Inputs and constraints for the example.
3.2.1 Redundant input generation
Algorithm 4 does not diﬀerentiate between a type con-
straint and a branch constraint. However, in the context
of dynamically-typed JS programs, this results in the gen-
eration of a large number of redundant inputs, thus dras-
tically diminishing the scalability of the testing algorithm.
We demonstrate the drawback using the following example:
function foo(x,y,z,o) {
var d = x - y;
if(z == 1) o.bar(d);
}
There are four inputs to function fooand applying Algo-
rithm1generates more than20inputstocoverthe twopaths
in the function. Table 1 presents the inputs generated and
the constraints generated for the corresponding execution.
For ease of presentation, the stack is shown as a sequence.
Initially, all inputs are undeﬁned( ⊥). Here we refer to types
number, object and function by N, O and F respectively.
When the ﬁrst input is executed, the assignment d = x -
yis considered at line 4 of Algorithm 1. Applying AddCon
the RHS results in addition of the type constraints x/ne}ationslash≏num
andy/ne}ationslash≏num. Subsequently, when z== 1 is evaluated, the
constraint z/ne}ationslash≏numis also added and because zis undeﬁned
currently, the conditional in foois not satisﬁed and the exe-
cution terminates. A state is added to the precondition and
because the stack length is greater than 0 (currently 3), the
constraint at the top of the stack is ﬂipped. This causes z
/ne}ationslash≏numbeing negated and the constraints on the stack are
solved using solveat line 17. Consequently, the input ( ⊥,
⊥, 0,⊥) is generated to satisfy the constraints and Run-
Concolic is invoked at line 18. The remaining rows in the
table are computed similarly.
For the constraints generated due to execution of foowith
the ﬁfth input, the last four constraints are removed from
the sequence as their corresponding negations are already
solved (inputs 4, 3, 2 and 1 respectively). The resultant
last constraint y/ne}ationslash≏numis negated to generate the sixth in-
put.Interestingly , not only does it lose the knowledge on
inferred types of z,oando.barbeingnumber,objectand
function respectively, but also the generated constraints do
not expose any new fact. The exploration repeatsup to the
tenth input, without exploring a newer execution path. The
process repeats all over again for x= 0. Not diﬀerentiating
the type and branch constraints results in this unnecessary
generation of inputs.
3.3 Type-aware Concolic Testing
We address this fundamental drawback by proposing an
approach that diﬀerentiates between the branch and type
1711 2 3 4 554321
x/ne}ationslash≏N x ≏Ny/ne}ationslash≏Nz/ne}ationslash≏N
y≏Nz≏Nz/ne}ationslash=1o.bar/ne}ationslash≏F
(0, 0, 1,{bar()}( 0, 0, 1, {})( 0, 0, 1, ⊥)( 0, 0, 0, ⊥)(⊥,⊥,⊥,⊥)
x≏Ny≏No/ne}ationslash≏O
z = 1
z≏Nz = 1
z≏N
x≏Ny≏No≏Oo.bar≏F
o≏O
x≏Ny≏Nz≏Nz = 1
(a)3 4 5 6 2 11
2
3
4
5
6
merged 
stackmerged 
stackz≏Nz/ne}ationslash=1x≏Ny≏N
z≏Nz/ne}ationslash=1x≏Ny≏No/ne}ationslash≏O
z/ne}ationslash≏Nz = 1o≏O
y≏N
x≏N
z/ne}ationslash=1
z≏N z/ne}ationslash≏N z≏Nz/ne}ationslash=1(⊥,⊥,⊥,⊥)
(0, 0, 1,{bar()})(0, 0, 1,⊥)(0, 0, 0,{})(0, 0, 0,⊥)(⊥,⊥, 0,⊥) o.bar≏F
o≏O
y≏N
z = 1
z≏N z≏Nz = 1x≏Ny≏No≏O
x≏No.bar≏F
(b)
Figure 2 Inputs and constraints for the illustrative example
constraints. This is achieved by ﬂipping the set of type
constraints simultaneously. For this purpose, we propose
a modiﬁed version of the ﬂipping algorithm in Algorithm 5
that can be used instead of Algorithm 4.
Algorithm 5 Flip2
Input: stack (stack)
1:while(e←stack.top()∧e.ﬂipped) dostack.pop();
2:if(stack.length≥0∧e.isbranch) then
3:e.ﬂipped←1;e.constraint←neg(e.constraint);
4:else
5:pos←stack.length - 1;
6:while(pos≥0∧¬stack[pos].isbranch)do
7: c←stack[pos];c.ﬂipped←1
8: c.constraint←neg(c.constraint); pos←pos−1;
Initially, Flip2eliminates all constraints that are already
ﬂipped (line 1). Subsequently, if it ﬁnds a branch constraint
at the top of the stack, it negates the constraint and returns
(lines 2-3). This is because of the invariant that all the
type constraints beneath the branch constraint are already
ﬂipped. Otherwise, it identiﬁes all the non-branch con-
straints (using is_branch ), negates themandmarks themas
ﬂipped (lines 5-8). When Algorithm 1 is executed after this,
the type constraints that are seen previously are guaranteed
to be ﬂipped and hence need not be solved incrementally.
Figure??ﬁg:intra presents the inputs and constraints gen-
erated by incorporating the new Flip2algorithm in Run-
Concolic at line 16. The ﬁrst input and the associated
constraints are similar to the existing concolic testing al-
gorithm. However, unlike the previous algorithm, we ﬂip
the type constraints simultaneously and solve them. This
results in the types of x,yandzto benumand a default
value of 0 is assigned to them resulting in the second input.
When executed, the condition z== 1 is not satisﬁed and
a branch constraint is added accordingly. Subsequently, the
constraint at the top of the stack is ﬂipped and the third
input is constructed with zequals 1. This results in a crash
due to a dereference of oas it is still undeﬁned. The deref-
erence causes it to be considered as an object resulting in
the generation of theconstraint and consequently, thefourth
input. The example demonstrates that solving the type con-
straints simultaneously ensures signiﬁcant reduction in the
number of inputs generated and is closer to the number of
normally terminatingpathsintheprogram. Ourapproachis
able to completely cover all the paths with just ﬁve inputs
as compared to more than 20 inputs by existing concolic
testing.
By applying this technique, we avoid generation of the
same pattern of malformed inputs by ﬁxing the inputs after
the execution crashes. Executingthe program with the ﬁxedinput avoids the crash at the same point. For instance, in
Table 1, for inputs 3 and 8, program crashes at the same
pointrepeatedly. However, input 8 doesn’t add any ad-
ditional information. As shown in Figure ??ﬁg:intra, our
approach exposes the crash oncewith input 3 reducing the
redundancy.
3.3.1 Differentiating branch and type constraints
Our algorithm relies on how we carefully deﬁne and dis-
tinguish between branch and type constraints. Branch con-
straints correspond directlyto the branch condition expres-
sion; type constraints are implicitly generated at multiple
places, including assignment, call and branch statements.
For example, the statement, if (x == 3) , generates a type
constraint (x ≏num) and a branch constraint (x == 3).
This distinction between the constraints allows us to apply
our type-aware exploration to programs where the branch
constraint may restrict the type of the variable but is not
collated with the type constraints.
if (typeof x == ‘number’) { ... }
else if (typeof x == ‘string’) { ... }
In the above code, we treat the constraints generated on
xas branch constraints. Thus, we can explore both paths
without losing coverage. Otherwise, if these are considered
as type constraints, then ﬂipping them together and solving
will lead to an infeasible execution and hence loss of cov-
erage. Note that for buggy programs, a programmer may
erroneously assume inconsistent types for a variable xalong
some path of execution p. In such cases, we detect that type
constraints are unsatisﬁable together on pand abort testing.
3.4 Inter-procedural Testing
Extending RunConcolic (Algorithm 1) to an inter-
procedural setting involves a number of challenges to avoid
path explosion. For example, if a function f′callsfin the
program under test, the inputs to fmay be undeﬁned or
ill-typed, causing the execution to crash in f. To handle
the crashes, we need to call fwith well-typed values after
detecting each abort. Repeating this exercise for each call
tofand execution path inside fcan lead to a severe blowup
in the number of input tests generated, thus diminishing the
scalability. We propose to address this problem by generat-
ing input preconditions forfduring testing. We use these
preconditions to avoid invoking fwith ill-typed values.
Function preconditions are generated during the process
of performing concolic testing of a function λ. It is achieved
by updating RunConcolic (Algorithm 1) between lines 14
and 15 with following.
If(I=halt)ξ[λ]←ξ[λ]∪{stack}
172In other words, when an execution halts in λ, we add the
stack from the termination state to the set of preconditions
ξ[λ] forλ. The preconditions generated for the method foo
fromtheillustrativeexampleisshowninTable2(constraints
are represented as a comma-separated list). It has two en-
tries that corresponds to the two normally executing exe-
cution paths due to condition z== 1. Each precondition
contains the relevant type constraints as well as branch con-
straints on inputs of foo. Because the number of precondi-
tions may be quite large (in worst case, equals the numberof
paths executed in λ), we represent the set compactly using
atriedata structure, ordered by formal parameter names,
for eﬃcient lookup and reuse (see below).
ID Precondition
1x≏N, y≏N, z/ne}ationslash= 1
2x≏N, y≏N, z = 1, o ≏O, o.bar ≏F
Table 2 Preconditions of foo.
3.4.1 Employing function preconditions
Algorithm 6 shows how to handle function call statements
(call ap) in Algorithm 2 by using previously generated pre-
conditions. Here, let apevaluate to a callee function λ′and
as before, the caller function is λ.
Algorithm 6 Call
Input:{callerλ, callee λ′,T,C,S,stack}
1:ifall type constraints in stack are not ﬂipped then
2:foreach unﬂipped type constraint cinstackdo
3: c.constraint←neg(c.constraint); c.ﬂipped←1
4:σ′←solve(stack)
5:RunConcolic (σ′);abort
6:if((ξ[λ′] does not exist)) then
7:ρ←formal parameters of λ′
8:T′[p] =C′[p] = undeﬁned,∀p∈ρ;S′[p] =p,∀p∈ρ
9:RunConcolic (/an}bracketle{tλ′,T′,C′,S′, []/an}bracketri}ht);
10:σ←/an}bracketle{tλ,T,C,S,stack/an}bracketri}ht
11:for(eachπinξ[λ′])do
12: π′=Unify(π,σ);doAbort←false
13: ifπ′/ne}ationslash= []then
14: doAbort←true;stack′←stack
15: foreachcinπ′doc.ﬂipped←1;stack′.push(c)
16: (T′′,C′′,S′′) = solve( stack′);
17: RunConcolic (/an}bracketle{tλ,T′′,C′′,S′′,stack′/an}bracketri}ht);
18:ifdoAbort then abort
The procedure ﬁrst ﬂips all type constraints on the stack
before calling λ′and re-run RunConcolic (lines 1-5 in Al-
gorithm 6) while aborting the current execution. This en-
sures that the variables passed to λ′are restricted by the
types in the current execution preﬁx. To avoid exploring
redundant inputs, Callﬁrst computes (lines 6-9) the pre-
conditions for λ′(if it doesn’t exist) and then reuse one or
more precondition entries of λ′(lines 10-17). To compute
the preconditions, we deﬁne a new set of type, concrete and
symbolic maps ( T′,C′,S′) for the formal parameters of λ′
and apply RunConcolic toλ′. The completion of this step
ensures the generation of the precondition for λ′.
In order to reuse pre-computed preconditions, Calluses
an auxiliary procedure Unify, which tries to unifythe cur-
rent execution state σinλwith some precondition entry
π(recall that each entry πis a list of type and path con-
straints). Uniﬁcation is based on the following rule: if π
constrains a variable xwith value v, thenσ.C(x) =v. Simi-
larly, ifπconstraints the type of xtot, then either σ.T(x) isundeﬁned or t. If uniﬁcation succeeds, it returns set of con-
straintsπ′(possibly empty) to update σwith.Calladds
these constraints to σ.stack, and solves for new inputs which
satisfy these constraints; the current execution is aborted.
We will illustrate the use of preconditions in inter-
procedural concolic testing (Algorithm 6) using the example
that invokes the method foodiscussed in Section 3.3.
function baz(x,y,z,o) {
if(z == 1) foo(x,y,z,o);
else foo(x,y,z,o);
o.z = z;
}
Figure 2b presents the inputs and constraints generated
with the use of preconditions from Table 2. Initially, the
inputs are undeﬁned resulting in the constraint z/ne}ationslash≏number.
Because z/ne}ationslash= 1,fooin theelse branchis called. Atthis point,
because the type constraint in the caller is not ﬂipped, we
negate the constraint, solve it and generate the second input
suchthat zisanumberandassign itthedefaultvalue(zero).
Whenfoois invoked in the else branch, the stack contains
a path constraint z/ne}ationslash= 1. The precondition entry for foo
that is feasible on this path is the ﬁrst entry in Table 2. The
constraints are placed on the stack and ﬂipped value of these
constraints is set to one as speciﬁed in Algorithm 6 (line 15).
This ensures that newly generated input will follow the path
corresponding to the chosen precondition.
The merging of the two stacks is shown next to the second
input. When the third input is generated to satisfy the
constraints, the execution crashes at o.zando/ne}ationslash≏objis
added. The constraint is ﬂippedtogenerate thefourth input
with which execution halts. All the constraints that are
ﬂippedonthestackareeliminated andthebranchconstraint
z/ne}ationslash= 1 is ﬂipped. When foois invoked in the ifbranch, the
constraints that correspond to the feasible path are added
(see Table 2). The constraints are solved to generate the
sixthinputwhichwhenexecutedreaches endofpath. Unlike
theelsebranch, executing the ifbranch will ensure that
o.zdoes not crash in the ﬁrst attempt as the precondition
offooensures that ois an object.
4. IMPLEMENTATION
The concolic testing approaches can be classiﬁed as type-
agnostic and type-aware approaches. For each classiﬁcation,
there are two variations of exploring the paths in the pro-
gram – DFS and BFS. The only diﬀerence between these
strategies is the order in which constraints are solved. Over-
all, we consider the following variants:
1.BFS:Existing concolic testing implementation in [37],
2.DFS:Implementation of Alg. 1 that uses Alg. 4,
3.TA-BFS: Type-aware variant of BFS, and
4.TA-DFS: Implementation of Alg. 1 that uses Alg. 5.
Test Driver: To perform concolic testing, it is essential
that a proper environment be setup with initial seed in-
puts and variables, and the function under consideration is
invoked. We statically parse the programs and setup the
environment to perform concolic testing on each function.
We consider global variables detected by JSHint [3] as seed
inputs. The seed inputs are initialized with undeﬁnedvalues
to enable coverage of all possible types.
Path-sensitivity: The existing implementation of (type-
agnostic) BFS is path-insensitive and generates inputs con-
sidering properties on objects accessed on irrelevant paths.
173Benchmark IDProgram/
ClassVLoCFTA-BFS TA-DFS Coverage (%)
MinMaxTotalMinMaxTotalStatement Branch Function
sunspider B13d-cube 0.9143712112591125597.5 94.83 100
sunspider B23d-raytracer 0.9145125110781107997.30 93.5 100
sunspider B3access-nbody 0.9117911112421123697.90 100 100
box2d B4b2Mat22 2.1a12911395231053100 100 100
box2d B5b2Mat33 2.1a11311326743287799.64 95.46 100
v8B6splay 7.039316113721147398.65 91.29 98.58
v8B7raytrace 7.090424325119325118 100 100 100
hapi B8response 8.4.058617398531611399.36 96.11 98.52
hapi B9connection 8.4.04041533012033113085.46(100) 84.15(97.23) 81.84(99.30)
hapi B10validation 8.4.022010310503155695.52(98.9) 89(95) 93.15(95.23)
Table 3 Benchmark Information and Results. V - version, F - number of functions, TA - Type Aware.
Because, this unnecessarily increases the redundancyof gen-
erated inputs, we made it path-sensitive. The DFS variants
are also implemented to be path-sensitive. Consequently,
the number of entries in the preconditions is few reducing
the lookup time during inter-procedural testing.
Handling function calls: Constructing call graph, re-
quiredfor inter-proceduraltesting, for dynamicallytypelan-
guages is diﬃcult [17] and the absence of type information
of input objects makes the task more diﬃcult. We address
this by generating the preconditions of the callee functions
on demand. These preconditions are derived in a context-
insensitive manner. For example, if a function fooinvokes
bar, it is discovered at runtime. We stall the execution of
fooand compute the precondition of bar. For subsequent
invocations of bar, we reuse the computed preconditions.
k-level inter-procedural challenges: Inthe case of inter-
procedural testing, we save the state of the current func-
tion (i.e., symbolic and concrete values, and stack) when
the preconditions for the callee are being derived. Since the
preconditions are generated on demand, the process can be
performed in a nested manner until no more functions are
invoked. Because saving the state at each level is complex,
we parameterize the approach to handle k-levels of nesting.
Arrays, loops and recursions: The existing implementa-
tion of BFS testing does not handle arrays which can aﬀect
coverage. Therefore, for an array access, we ensure that the
type of the index is set before setting the type of the array
object. For loops, we discard the constraints generated be-
yond a speciﬁed limit. We arbitrarily break recursions based
on the order of function invocations.
5. EXPERIMENTAL RESULTS
We evaluate the beneﬁts of type-aware concolic testing
across various dimensions. We use a 64 bit, 8 core Ubuntu-
13.10 desktop, equipped with an Intel core i7 processor and
16GB RAM to run experiments. We applied our approach
on various open-source JS programs (andlibraries). Wecon-
sider the following benchmarks – SunSpider [7] programs
used to measure performance of JavaScript, box2dprograms
that are part of the octane benchmark suite [4], V8programs
used for tuning the performance of V8 [1], and hapi[8] li-
braryclasses thatformaframework forbuildingapplications
and services.
Table 3 presents the benchmarks, their version, lines of
code and number of functions in the programs/classes ana-
lyzed. We associate an identiﬁer with each benchmark ( B1
toB10) and henceforth will use them for reference. The
LoC ranges from 113 for B5to 904 for B7and the function
count ranges from 10 to 25. We designed our experiments
to answer the following research questions:1.RQ1: Is type-aware intra-procedural concolic testing
more beneﬁcial than existing type-unaware approaches?
2.RQ2: Does type-aware intra-procedural concolic testing
help achieve more coverage?
3.RQ3: Do preconditions reduce the number of generated
inputs for inter-procedural testing?
4.RQ4: Can preconditions be used to handle type-related
crashes?
5.1 RQ1: Beneﬁts of Type-aware Testing
Initially, we study the beneﬁts of type-aware intra-
procedural concolic testing. We analyze each function in
an isolated manner without providing the implementation
of its callees. The goal is to demonstrate the ability of the
generated tests to achieve high coverage. If we consider the
callee implementation, achieved coverage will be limited by
the existing program structure. For each function, we ana-
lyze it with four variants of concolic testing as described in
Section 4. The statistics pertaining to the number of inputs
generated by TA-BFS and TA-DFS is given in Table 3 in-
cludingtheminimumandmaximumnumberofinputsgener-
ated across all functions in abenchmark. For example, when
the 15 functions in B9are tested, the number of inputs gen-
erated for the diﬀerent functions in it using TA-BFS range
from 3 to 30. The total number of inputs required to cover
the paths in all the functions is also presented. The overall
number of inputs required to cover the paths in all the func-
tions analyzed across all the benchmarks ranges from 42 to
119 using TA-BFS and 36 to 130 for TA-DFS.
Figure 3 presents the improvements due to type-aware
concolic testing. More speciﬁcally, we compute the percent-
age of number of inputs generated using type-aware testing
compared to that generated by the existing approach. Since
the existing approach can generate large number of inputs,
we bound the input generation to 1000 per function. Out
of 152 functions that are tested across all benchmarks, BFS
and DFS approaches reach the upper bound of 1000 inputs
for 60 (40%) and 16 (11%) functions respectively. In other
words, concolic testing these functions can be signiﬁcantly
longer due to redundant exploration of paths.
Figure 3a presents the comparison between TA-BFS and
BFS. In the ﬁgure,“ <5%”segment shows the percentage of
functions for which type-aware testing generated less than
5% of the inputs as compared to the original,“5-10%”shows
thepercentageoffunctionsfor whichtype-awaretestinggen-
erated 5 to 10% of the inputs generated by the original ap-
proach and so on. We observe that for a signiﬁcant per-
centage of functions, TA-BFS generates less than 5% inputs
as compared to BFS. For example, B2has approximately
80% of the functions that is present in this category. More-
174 0 20 40 60 80 100
B1 B2 B3 B4 B5 B6 B7 B8 B9 B10Percentage of functions
Benchmarks12(7) 25(14) 11(4) 11(4) 11(4) 16(4) 24(12) 17(4) 15(5) 10(2)
(a) TA-BFS. 0 20 40 60 80 100
B1 B2 B3 B4 B5 B6 B7 B8 B9 B10Percentage of functions
Benchmarks12(4) 25(2) 11(3) 11(0) 11(3) 16(1) 24(1) 17(0) 15(2) 10(0)
(b) TA-DFS./0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0/0
/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1/1> 50% inputs
10−50% inputs
5−10% inputs
< 5% inputs/0/0/0/0/0/0/0/0/0/0/0/0/0/0
/1/1/1/1/1/1/1/1/1/1/1/1/1/1
Figure 3 Distribution of functions demonstrating the improvement due to type-aware concolic testing.
Label above bar is overall function count (time-out functions count).
 0 0.05 0.1 0.15 0.2 0.25 0.3 0.35
B1B2B3B4B5B6B7B8B9B10Exception Ratio
BenchmarksTA-BFS
TA-DFS
Figure 4 Normalized exception
ratios w.r.t the original approaches. 0 0.1 0.2 0.3 0.4 0.5 0.6
B1B2B3B4B5B6B7B8B9B10Ratio of inputs
BenchmarksTA-BFS
TA-DFS
Figure 5 Representative
number of inputs. 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7
B1B2B3B4B5B6B7B8B9B10Time Ratio
BenchmarksTA-BFS
TA-DFS
Figure 6 Normalized time w.r.t the
original approaches.
over, of the 25 functions analyzed for B2, 14 functions timed
out (reached the upper bound) using BFS. Even for the re-
maining functions that did not go beyond 1K inputs, the
percentage of inputs generated with TA-BFS is quite low.
There are a few functions across benchmarks for which
input generation is not signiﬁcantly aﬀected due to type-
awareness (e.g., 10% of the functions in B1,B2andB3). Our
manual inspection shows fewer property accesses in these
functions. Consequently, they do not expose the potential
problem with type-agnostic approaches. Even when there
are a signiﬁcant number of such functions (e.g., B4and
B5have approximately 70%), few functions (30%) exist for
which input generation reaches the upper bound. In these
scenarios, TA-BFS out performs BFS and reduces the num-
ber of inputs generated.
Figure 3b presents the corresponding improvement for the
DFSvariants of concolic testing. Here, the overall numberof
functions that reach the upper bound is lower (as compared
to BFS). This is because of the diﬀerence in the way con-
straints are solved in both the approaches. Even with the
reduction, the number of inputs generated by DFS is non-
trivial. By employing TA-DFS, for 30% of the functions, we
reduce the number of inputs generated by 95% (on average).
In Figure 4, we present the ratio of number of exceptions
(e.g., an exception will happen when o.x is executed and o is
undeﬁned) during an execution when type-aware testing is
employed to the exceptions in the original version. Based on
Figure 3, we expect thenumber of exceptions tobe quite low
(here, less than 0.03) when executing with TA-BFS. Simi-
larly, the ratio of the number of exceptions is also low with
TA-DFS. This is a consequence of reducing the redundancy.We tabulated the ratio of the representative inputs com-
pared to total inputs that are generated for the type-aware
variants. We deﬁne representative inputs as the inputs that
do not encounter exceptions during an execution, and there-
fore can contribute to the function precondition. Figure 5
presents the ratios for TA-BFS and TA-DFSand are compa-
rable for both the variants. Broadly, they range from 0.2 for
B4to 0.6 for B2. This shows that the functions that are con-
sidered havemany properties that cause executions on many
inputs generated by type-aware approaches to have excep-
tions. For B4andB5, we veriﬁed that even though there are
many functions with few inputs, the representative inputs is
still lower than the overall inputs because of the exceptions.
Figure 6 presents the normalized execution time of the
type-aware approaches with respect to the original ap-
proaches. The time taken, which ranges from 1.5 to three
seconds per function, is signiﬁcantly lower than the original
approaches. Interestingly, even though the exceptions for B9
are relatively less, the time ratio of TA-DFS is nevertheless
high. This is because of the actual time taken to execute
the diﬀerent functions in it is higher.
Type-awareintra-proceduralconcolic testingresultsinthe
generation of fewer inputs and takes lesser time than ex-
isting approaches.
5.2 RQ2: Coverage of Type-aware Testing
In this section, we show that coverage is uncompromised
due to type-awareness. We use Istanbul [9], a JS code cov-
erage tool to track statements, branches and functions exe-
cuted. Table 3 shows the coverage data for the benchmarks.
175 0 5 10 15 20 25 30 35
B1 B2 B3 B4 B5 B6 B7 B8 B9 B10Average number of inputs
Benchmarkswith callee impl, no preconditionswithout callee implwith callee impl, use preconditions
Figure 7 Average number of inputs generated. 0 5 10 15 20 25 30
B1 B2 B3 B4 B5 B6 B7 B8 B9 B10Average number of exceptions
Benchmarkswith callee impl, no preconditionswithout callee implwith callee impl, use preconditions
Figure 8 Average number of exceptions.
The number represents the average coverage achieved using
intra-procedural type-aware concolic testing for that bench-
mark. For example, in 3d-cube program, 97.5% statement
coverage is obtained after testing 12 functions.
As shown in Table 3, for a majority of the benchmarks,
the achieved coverage is closer to 100%. However, for B2,B9,
B10, following are the reasons for poor coverage – presence
(or return) of a function deﬁnition within a function body,
and presence of constraints involving strings, array proper-
ties and complex expressions. Since the statements in the
function deﬁnition cannot be counted as part of the encom-
passing function which is tested, we obtain code coverage
closer to 100% after discarding these statements as shown
in the parenthesis in Table 3. The problem with unsolvable
constraints exists even for existing type-agnostic approaches
and is orthogonal to the proposed approach.
Though it is hard to get coverage numbers for BFS and
DFS in many cases, we believe that the coverage remains
unaﬀected since the search strategy remains the same. In
addition, to demonstrate that the ability of concolic testing
to ﬁnd bugs is not diminished in the proposed approach,
we inserted 20 defects randomly across all the benchmarks.
After performing concolic testing, we observe that, both ex-
isting and type-aware concolic testing detected 17 defects.
For the remaining three defects, the defect was introduced
at unreachable source locations (e.g., inside a condition with
unsolvable constraint). As mentioned earlier, this is an or-
thogonal to the problem addressed in this paper.
Type-aware concolic testing helps achieve high coverage.
5.3 RQ3: Inter-procedural testing
Wealsostudythebeneﬁtsofemployingfunctionprecondi-
tions in reducing the overall number of test inputs. For each
benchmark, we pick three functions randomly such that it
has at least one invocation to some other function. We per-
form concolic testingoneachfunctionusingTA-DFS.Thisis
because the experimental results in Section 5.1 demonstrate
thattheDFSvariantofconcolic testingis comparablybetter
than DFS and BFS. We perform the testing as follows:
•Test the function with the implementation of its callees
but without using preconditions, and
•Test the function in isolation without providing the im-
plementation of its callees,
•Test the function with the implementation of its callees
and use the preconditions for the callees in Section 5.1.Figure 7 presents the comparison of the average number
of inputs generated across the three dimensions for all the
benchmarks using TA-DFS. The average number of inputs
generated when the callee implementations are provided
without preconditions is approximately twice the number of
inputs generated when implementations are not provided.
Moreover, for most of the benchmarks, using the precondi-
tions of the callees reduces the number of inputs generated
by half as compared to when the preconditions are not used.
As expected, these numbers are slightly more than the sce-
nario when no callee implementations are provided.
We observe an interesting aspect pertaining to the results
ofB7andB10. The number of inputs generated is lower
while using preconditions as compared to when the imple-
mentation is not provided. Upon closer examination, we
identify that having the callee implementation ensures that
types of objects are determined and testing does not result
in an exception in other parts of the caller function. How-
ever, when the implementation is not provided, these types
are unavailable resulting in more exceptions in the caller.
Another interesting data point is the result on B3in Fig-
ure 7. The number of inputs generated when the implemen-
tations are providedis independentofwhether preconditions
are used. This is because the normally terminating paths in
the function is equal to the number of entries for the callee
precondition. Therefore, employing preconditions does not
reduce the number of inputs generated in that scenario.
Figure 8 presents the average number of exceptions and
provides a comparison under the three scenarios. In general,
the results validate our expectations in that the use of callee
preconditions reduce the exception count. For B8, when the
implementation is not provided, an exception happens in
the caller because the callee is not recognized. On the other
hand when preconditions are provided, even this exception
disappears resulting in the absence of any exceptions with
the use of preconditions for it.
The number of exceptions is also a function of the number
of entries in the function preconditions. For example, for B4,
we observe that the number of exceptions is more with pre-
conditions than without the callee implementation. This is
because of multiple entries corresponding to the same func-
tion in the preconditions. On the contrary, when multiple
invocations are made without the callee implementations,
each invocation will result in an exception.
The derivation of function preconditions reduces the num-
ber of inputs generated for inter-procedural testing.
1765.4 RQ4: Handling type-related crashes
Apart from using function preconditions in the context of
inter-procedural concolic testing, the generated conditions
can also be employed in automatically ﬁxing ill-typed ob-
jects being passed to methods during a method invocation.
We now demonstrate the use of the preconditions in auto-
matically ﬁxing malformed inputs.
Broadly, the idea is similar to failure oblivious computing
[33] where the the crash is avoided by manufacturing values
whenafailure is expected. [33]uses thisstrategytoenhance
server availability whereas we propose to use this strategy
to avoid crashes in JS applications. Consider a function foo
deﬁned in Section 3.3, and corresponding preconditions in
Table 2. When foo(5, 2, 1,{}) is invoked, we can avoid the
crash by using the second precondition in Table 2. This is
achieved by introducing a dummy barfunction in the object
o(i.e., last parameter) during runtime.
Library File #IssueMissing Property E
hapi response.js 2368 readableState 4
hapi handler.js 2242 isBoom 2
pm2childprocess.js 808 close 12
pm2 monit.js 2 cpu 3
mocha mocha.js 1496 callback 2
Table 4 Real crashes in JS programs. E: number of
entries in the precondition.
Table 4 presents a sample of real crashes reported on dif-
ferent JS programs. Typically, these crashes happen when
the method is invoked with malformed objects. Therefore,
a dereference on such an object for a speciﬁc property re-
sults in the crash. For the purpose of detecting the correct-
ness of the objects passed to a method, it is essential that
function preconditions are available. As our experimental
results demonstrate, deploying existing concolic testing ap-
proaches to derive preconditions can be infeasible due to
the number of inputs generated. On the other hand, our
type-aware approach generates the preconditions eﬀectively.
Moreover, because the preconditions are path-sensitive, we
ﬁx malformed objects along feasible paths.
We are able to generate preconditions for all the problem-
atic functions reported in Table 4. The associated numberof
entries in the preconditions is also shown. For example, for
classchild_process , the number of entries in the precondi-
tion for function onexitis 12. In this case, when an input
with an object that does not havethe property closeis used
to invoke the method, we lookup the entries in the precondi-
tion and detect that the feasible path for the corresponding
path requires the receiver, to contain close. Applying a
variant of the procedure described in Algorithm 6 to ﬁx the
receiver ensures that the execution does not crash.
The function preconditions can help avoid crashes due to
malformed objects.
6. RELATED WORK
Several approaches for automated test generation have
been proposed [20, 38, 39, 35, 34]. Sen et al.[37] imple-
ment a“multi-path”symbolic execution [39] and variant of
concolic testing [20, 38] to generate test inputs for JS pro-
grams. We show that [37] generates redundant inputs even
for small programs. In this paper, we propose an approach
that builds on top of Jalangi to reduce the redundancy bydistinguishing type constraints and branch constraints.
Automatic testing of such applications [25, 36, 13, 27] has
beenstudiedextensively. SymJS[25]containsasymbolicen-
gine for JavaScript and an automatic event explorer for web
pages using taint analysis. Mirshokraie et al.[28] present a
technique to automatically generate test cases for individ-
ual JavaScript functions and event sequences to maximize
function coverage. Wassermann et al.[40] use ﬁnite state
transducers to solve string constraints and use real values
when constraint resolution is incomplete. While the focus
of these approaches is to generate proper event sequences
or inputs for complex strings, we are generating minimum
number of test inputs to cover JS programs.
Various typeinference techniques[10, 21, 29] are proposed
to generate optimized code or to detect type inconsisten-
cies. Hackett and Guo [21] generate fast JS code by us-
ing derived type information. Ahn et al.[10] propose inline
caching mechanisms for faster property look ups. Pradel et
al.[29] use type inference to detect inconsistent types to ex-
pose optimization opportunities. These techniques perform
type inference during JIT compilation. Our aim is to derive
the appropriate types of variables starting from executions
with undeﬁned types. Also, due to imprecision, existing
static type checkers (e.g., Flow [2]) are not suitable for our
approach.
TypeScript [14] extends JavaScript with type annotations
to prevent typeinconsistencies. Feldthaus et al.[16] propose
anapproachtoautomatically detecterrorsintheTypeScript
declaration ﬁles for JavaScript libraries. Rastogi et al.[32]
improve soundness of TypeScript by enforcing stricter type
checks to minimize performance overhead of runtime checks.
Our work diﬀers from these approaches as our technique
does not require any programmer interference.
Several static analysis [22, 23, 26] tools are proposed to
improve the reliability of JavaScript programs. Jensen et
al.[22] propose a static analysis infrastructure that can infer
detailed andsound typeinformation usingabstract interpre-
tation. Kashyap et al.[23] developed an eﬃcient abstract
interpreter that takes care of several features including con-
ﬁgurable sensitivity. Previous approaches either ignore or
make assumptions about dynamic behavior. Since we em-
ploy testing, we do not suﬀer from these drawbacks.
7. CONCLUSIONS
We observe that conventional concolic testing approaches
arenotscalable for testing JS programs. This is a con-
sequence of treating branchandtypeconstraints, equiva-
lently. We address the problem by proposing an eﬀective
approach that introduces type-awareness to reduce gener-
ation of redundant inputs. We extend the approach for
inter-procedural testing by incorporating preconditions ap-
propriately. We perform elaborate experimentation and
demonstrate the scalability of type-aware concolic testing
approaches over existing approaches. We also show the use-
fulness of the derived preconditions in avoiding crashes.
Acknowledgments
Wethanktheanonymousreviewers for their useful feedback.
We are grateful to Malavika Samak and Rashmi Mudduluru
for providing comments on an initial draft of the paper. The
project is partially funded by a Google Faculty Research
award and a Microsoft Research India travel grant.
177References
[1] http://code.google.com/p/v8/.
[2] http://ﬂowtype.org/.
[3] http://jshint.com/.
[4] https://developers.google.com/octane/.
[5] https://github.com/hapijs/hapi/issues/2368.
[6] http://stackoverﬂow.com/questions/42934/what-do-
people-ﬁnd-so-appealing-about-dynamic-languages.
[7] http://sunspider-mod.googlecode.com/svn/ data/host-
ed/versions.html.
[8] https://www.npmjs.com/package/hapi.
[9] https://www.npmjs.com/package/istanbul.
[10] W. Ahn, J. Choi, T. Shull, M. J. Garzar´ an, and J. Tor-
rellas. Improving javascript performance by decon-
structing the type system. In Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’14, pages 496–507,
New York, NY, USA, 2014. ACM.
[11] A. Aiken and M. F ¨ahndrich. Dynamic typing and sub-
type inference. In Proceedings of the Seventh Inter-
national Conference on Functional Programming Lan-
guages and Computer Architecture , FPCA ’95, pages
182–191, New York, NY, USA, 1995. ACM.
[12] C. Anderson, P. Giannini, and S. Drossopoulou. To-
wards type inference for javascript. In Proceedings of
the 19th European Conference on Object-Oriented Pro-
gramming , ECOOP’05, pages 428–452, Berlin, Heidel-
berg, 2005. Springer-Verlag.
[13] S. Artzi, J. Dolby, S. H. Jensen, A. Møller, and F. Tip.
A framework for automated testing of javascript web
applications. In Proceedings of the 33rd International
Conference on Software Engineering , ICSE ’11, pages
571–580, New York, NY, USA, 2011. ACM.
[14] G. Bierman, M. Abadi, and M. Torgersen. ECOOP
2014 – Object-Oriented Programming: 28th European
Conference, Uppsala, Sweden, July 28 – August 1,
2014. Proceedings , chapter Understanding TypeScript,
pages 257–281. Springer Berlin Heidelberg, Berlin, Hei-
delberg, 2014.
[15] C. Cadar, D. Dunbar, and D. Engler. Klee: Unas-
sisted and automatic generation of high-coverage tests
for complex systems programs. In Proceedings of the
8th USENIX Conference on Operating Systems Design
and Implementation , OSDI’08, pages 209–224, Berke-
ley, CA, USA, 2008. USENIX Association.
[16] A. Feldthaus and A. Møller. Checking correctness of
typescript interfaces for javascript libraries. In Proceed-
ings of the 2014 ACM International Conference on Ob-
ject Oriented Programming Systems Languages & Ap-
plications , OOPSLA ’14, pages 1–16, New York, NY,
USA, 2014. ACM.[17] A. Feldthaus, M. Sch ¨afer, M. Sridharan, J. Dolby,
and F. Tip. Eﬃcient construction of approximate call
graphs for javascript ide services. In Proceedings of the
2013 International Conference on Software Engineer-
ing, ICSE ’13, pages 752–761, Piscataway, NJ, USA,
2013. IEEE Press.
[18] K. Gallaba, A. Mesbah, and I. Beschastnikh. Don’t
call us, we’ll call you: Characterizing callbacks in
JavaScript. In Proceedings of the ACM/IEEE Interna-
tional Symposium on Empirical Software Engineering
and Measurement (ESEM) , page 10 pages. IEEE Com-
puter Society, 2015.
[19] P. Godefroid. Compositional dynamic test generation.
InProceedings of the 34th Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming
Languages , POPL ’07, pages 47–54, New York, NY,
USA, 2007. ACM.
[20] P. Godefroid, N. Klarlund, and K. Sen. Dart: Directed
automated random testing. In Proceedings of the 2005
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’05, pages 213–223,
New York, NY, USA, 2005. ACM.
[21] B. Hackett and S.-y. Guo. Fast and precise hybrid
type inference for javascript. In Proceedings of the 33rd
ACM SIGPLAN Conference on Programming Language
Design and Implementation , PLDI ’12, pages 239–250,
New York, NY, USA, 2012. ACM.
[22] S. H. Jensen, A. Møller, and P. Thiemann. Type anal-
ysis for javascript. In Proceedings of the 16th Interna-
tional Symposium on Static Analysis , SAS ’09, pages
238–255, Berlin, Heidelberg, 2009. Springer-Verlag.
[23] V. Kashyap, K. Dewey, E. A. Kuefner, J. Wag-
ner, K. Gibbons, J. Sarracino, B. Wiedermann, and
B. Hardekopf. Jsai: A static analysis platform for
javascript. In Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software
Engineering , FSE 2014, pages 121–132, New York, NY,
USA, 2014. ACM.
[24] K. Lakhotia, P. McMinn, and M. Harman. An empir-
ical investigation into branch coverage for c programs
usingcuteandaustin. Journal of Systems and Software ,
83(12):2379–2391, 2010.
[25] G. Li, E. Andreasen, and I. Ghosh. Symjs: Auto-
maticsymbolictestingofjavascriptwebapplications. In
Proceedings of the 22Nd ACM SIGSOFT International
Symposium on Foundations of Software Engineering ,
FSE 2014, pages 449–459, New York, NY, USA, 2014.
ACM.
[26] M. Madsen, B. Livshits, and M. Fanning. Practical
static analysis of javascript applications in the presence
of frameworks and libraries. In Proceedings of the 2013
9th Joint Meeting on Foundations of Software Engi-
neering, ESEC/FSE 2013, pages 499–509, New York,
NY, USA, 2013. ACM.
[27] A. Marchetto, F. Ricca, and P. Tonella. A case study-
based comparison of web testing techniques applied to
ajax web applications. International journal on soft-
ware tools for technology transfer , 10(6):477–492, 2008.
178[28] S.Mirshokraie, A.Mesbah, andK.Pattabiraman. Jseft:
automated javascript unit test generation. In Soft-
ware Testing, Veriﬁcation and Validation (ICST), 2015
IEEE 8th International Conference on , pages 1–10.
IEEE, 2015.
[29] M. Pradel, P. Schuh, and K. Sen. Typedevil: Dy-
namic type inconsistency analysis for javascript. In
37th IEEE/ACM International Conference on Software
Engineering, ICSE 2015, Florence, Italy, May 16-24,
2015, Volume 1 , pages 314–324, 2015.
[30] D. Qi, H. D. Nguyen, and A. Roychoudhury. Path ex-
ploration based on symbolic output. In Proceedings
of the 19th ACM SIGSOFT Symposium and the 13th
European Conference on Foundations of Software En-
gineering , ESEC/FSE ’11, pages 278–288, New York,
NY, USA, 2011. ACM.
[31] X.QuandB. Robinson. Acase studyofconcolic testing
tools and their limitations. In Proceedings of the 2011
International Symposium on Empirical Software Engi-
neering and Measurement , ESEM ’11, pages 117–126,
Washington, DC, USA, 2011. IEEE Computer Society.
[32] A. Rastogi, N. Swamy, C. Fournet, G. Bierman, and
P. Vekris. Safe & eﬃcient gradual typing for typescript.
InProceedings of the 42Nd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming
Languages , POPL ’15, pages 167–180, New York, NY,
USA, 2015. ACM.
[33] M. Rinard, C. Cadar, D. Dumitran, D. M. Roy, T. Leu,
and W. S. Beebee, Jr. Enhancing server availability
and security through failure-oblivious computing. In
Proceedings of the 6th Conference on Symposium on
Opearting Systems Design & Implementation - Volume
6, OSDI’04, 2004.
[34] M. Samak and M. K. Ramanathan. Synthesizing tests
for detecting atomicity violations. In Proceedings of
the 2015 10th Joint Meeting on Foundations of Soft-
ware Engineering , ESEC/FSE 2015, pages 131–142,
New York, NY, USA, 2015. ACM.
[35] M. Samak, M. K. Ramanathan, and S. Jagannathan.
Synthesizingracytests. In Proceedings of the 36th ACM
SIGPLAN Conference on Programming Language De-
sign and Implementation , PLDI 2015, pages 175–185,
New York, NY, USA, 2015. ACM.
[36] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCa-
mant, and D. Song. A symbolic execution framework
for javascript. In Proceedings of the 2010 IEEE Sympo-
sium on Security and Privacy , SP ’10, pages 513–528,
Washington, DC, USA, 2010. IEEE Computer Society.
[37] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs. Jalangi:
A selective record-replay and dynamic analysis frame-
work for javascript. In Proceedings of the 2013 9th Joint
Meeting on Foundations of Software Engineering , ES-
EC/FSE 2013, pages 488–498, New York, NY, USA,
2013. ACM.
[38] K. Sen, D. Marinov, and G. Agha. Cute: A concolic
unit testing engine for c. In Proceedings of the 10th Eu-
ropean Software Engineering Conference Held Jointlywith 13th ACM SIGSOFT International Symposium on
Foundations of Software Engineering , ESEC/FSE-13,
pages 263–272, 2005.
[39] K. Sen, G. Necula, L. Gong, and W. Choi. Mul-
tise: Multi-path symbolic execution using value sum-
maries. In Proceedings of the 2015 10th Joint Meeting
on Foundations of Software Engineering , ESEC/FSE
2015, 2015.
[40] G.Wassermann, D.Yu, A.Chander, D.Dhurjati, H.In-
amura, and Z. Su. Dynamic test input generation for
web applications. In Proceedings of the 2008 Interna-
tional Symposium on Software Testing and Analysis , IS-
STA ’08, pages 249–260, New York, NY, USA, 2008.
ACM.
179