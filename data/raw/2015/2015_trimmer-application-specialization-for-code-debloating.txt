TRIMMER: Application Specialization for Code Debloating
HashimSharif
DepartmentofComputerScience
UniversityofIllinoisatUrbana-Champaign
Urbana,USA
hsharif3@illinois.eduMuhammadAbubakar
DepartmentofComputerScience
LahoreUniversityofManagementSciences
Lahore,Pakistan
bakar95@gmail.com
AshishGehani
ComputerScienceLaboratory
SRIInternational
MenloPark,USA
ashish.gehani@sri.comFareedZaffar
DepartmentofComputerScience
LahoreUniversityofManagementSciences
Lahore,Pakistan
fareed.zaffar@lums.edu.pk
ABSTRACT
With the proliferation of new hardware architectures and ever-
evolvinguserrequirements,thesoftwarestackisbecomingincreas-
inglybloated.Inpractice,onlyalimitedsubsetofthesupported
functionalityisutilizedinaparticularusagecontext,therebypre-
sentinganopportunitytoeliminateunusedfeatures.Inthepast,
programspecializationhasbeenproposedasamechanismforen-
ablingautomaticsoftwaredebloating.Inthiswork,weshowhow
existing program specialization techniques lack the analyses re-
quiredforprovidingcodesimplificationforreal-worldprograms.
Wepresentanapproachthatusesstrongeranalysistechniquesto
take advantage of constant configuration data, thereby enabling
moreeffectivedebloating.WedevelopedTrimmer,anapplication
specializationtoolthatleveragesuser-providedconfigurationdata
to specialize an application to its deployment context. The spe-
cializationprocessattemptstoeliminatetheapplicationfunction-
ality that is unused in the user-defined context. Our evaluation
demonstrates Trimmer can effectively reduce code bloat. For 13
applicationsspanningvariousdomains,weobserveameanbinary
sizereductionof21%andamaximumreductionof75%.Wealso
showspecializationreducesthesurfaceforcode-reuseattacksby
reducingthenumberofexploitablegadgets.Fortheevaluatedpro-
grams,weobservea20%meanreductioninthetotalgadgetcount
andamaximumreductionof87%.
CCS CONCEPTS
•Software and its engineering →Compilers;
KEYWORDS
Staticanalysis,Codedebloating,Programspecialization,LLVM
Permissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalor
classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthefirstpage.CopyrightsforcomponentsofthisworkownedbyothersthanACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee.Requestpermissionsfrompermissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
©2018AssociationforComputingMachinery.
ACMISBN978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238160ACM Reference Format:
HashimSharif,MuhammadAbubakar,AshishGehani,andFareedZaffar.
2018.TRIMMER:ApplicationSpecializationforCodeDebloating.In Proceed-
ings of the 2018 33rd ACM/IEEE International Conference on Automated Soft-
wareEngineering(ASE’18),September3–7,2018,Montpellier,France. ACM,
NewYork,NY,USA, 11pages.https://doi.org/10.1145/3238147.3238160
1 INTRODUCTION
Ashardwarearchitecturesanduserrequirementscontinuetoevolve,
softwareplatformsandapplicationsarebecomingincreasinglycom-
plex [33]. With such software growth, it is not surprising to see
applicationsbecomingsubjecttofeaturecreep.Asavariantofthe
80/20 rule, it has been argued that 80% of the users only utilize
20% of the functionality with each user requiring a distinct set
offeatures[ 24].Withmostusersdemandingonlyasubsetofthe
completefunctionality,featureextensionsoftencomeatthecostofsoftwarebloat.Suchcodebloatmaynegativelyimpactperformance,
whilealsopotentiallybroadeningtheattacksurfaceoftheappli-
cation[7,40,52].Moreover,softwarebloatisafirst-classconcern
inembeddedsystemshostedonresource-constraineddeviceswith
limitedmemoryandsecondarystoragecapabilities[36].
Protocolstacksforembeddedsystemsoftenneedtobehighly
customizedinviewoftheirtargetapplications.Thisrequiresde-
velopers to manually identify and eliminate unused code from
thestack[ 35].Suchmanualstrippingofunnecessaryfeaturescan
beatime-consuminganderror-proneprocess.Alternatively,pro-
gramspecializationtechniqueshavebeenacknowledgedasauseful
mechanismforautomaticcustomizationofsoftware[41].
Conceptually,aspecializertakesatargetapplicationandaspe-
cializationcontextasinput,andproducesaversionoftheapplica-
tionspecializedfortheprovidedcontext.Thespecializationcontext
iscomposedofknowndatavaluesandconfigurationparameters
available at compile time. Prior work has leveraged partial eval-
uation as a technique for program specialization [ 6,16]. Partial
evaluationisanoptimizationtechniquethatprecomputesprogram
expressionsintermsoftheknownstaticinput,therebygenerating
aspecializedbinary[28].
Inthiswork,weshowhowexistingpartialevaluationmecha-
nismsareinsufficientforprovidingusefulprogramspecialization
forreal-worldprograms.Specifically,thecurrentapproachesfor
automatedspecializationarenotequippedwiththeanalysesthat
catertothediverseprogrammingpatternsemployedforreading
329
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar
and parsing user configuration. Moreover, the absence of prop-
agating configuration invariants, coupled with the conservative
natureofexistingoptimizationsinproductioncompilers[ 17],limits
opportunitiesforconstantfoldinganddeadcodeelimination.
Accordingly,wehavedevelopedTrimmer,atoolthatenables
configuration-basedsoftwareslimming.Trimmerspecializesatar-getprogramwithrespecttoauser-definedconfiguration.Thepro-
videdconfigurationspecifiestheusagecontextoftheapplicationin
thedeploymentofinterest,andisleveragedtopruneunusedfunc-
tionalityfromtheapplication.Ourtoolusesstrongertechniquestoincorporateconfigurationinformation,andincludescompiler
transformationstailoredtotakeadvantageoftheknownprogram
constants,therebyenablingeffectivedebloating.Insteadofrelying
onheroiccompileranalysis,wedevelopthenecessarytransforms
that enable effective propagation of configuration invariants. In
particular,webuildaninterproceduralconstantpropagationtrans-
formationthatismoreprecise,andhencefacilitatesthepruningof
programpathsthatareunreachableinthecontextoftheusercon-
figuration.Theunreachablepathsareprunedasaresultofstatically
evaluatingbranchconditionsbyleveragingtheprovablyconstant
data.Moreover,thispotentiallyallowsforpruningfunctionsthat
areinvokedwithintheeliminatedprogrampath.
Additionally, we show existing transformations such as loop
unrollingcanbeappliedmoreusefullyinlightoftheknownstatic
input.Ourexperimentsshow,byapplyingtheseadditionaltrans-
forms,weachievemorepreciseconstantpropagation,asaresult
enablingaggressiveeliminationofunusedprogramcode.Thecom-pilertransformsincludedinthetoolaredevelopedusingtheLLVM
compilerframework[34].
Ourspecificcontributionscanbesummarizedasfollows:
•Wedevelopaninterproceduralconstantpropagationtransfor-
mationthatpropagatesthestaticprogramconfigurationmore
precisely,andhencefacilitatesthepruningofunreachablecode
paths.
•Wedevelopaloopunrollingtransformationtomoreaggressively
unrollloops.Inparticular,weleveragetheimprovedconstant
foldingcapabilitiestobetterguidethecostmodelsthatdrivetheloopunrollingtransform.Forthemajorityofprograms,fullloop
unrollingforcertainloops(particularlyinputparsingloops)isa
prerequisiteforanyusefulconstantpropagation.
•Wepresenttheresultsofanevaluationofourtool.Ourexperi-
mentsdemonstrate:Reducedcodesize:
Forasetof13commonlyusedLinuxappli-
cations,weobserveageometricmeanbinarysizereductionof
21.1%andamaximumreductionof75.4%.Reduced attack surface:
Code-reuse attacks use instruction
sequences(calledgadgets)fromexecutablecodesectionsasthe
attackpayload.Weshowspecializationintroducessoftwaredi-
versity and reduces the number of exploitable gadgets. In our
evaluation, we observe specialization reduces the gadgets by
20.1%(onaverage).Moreover,forallourbenchmarks,applying
specializationeliminatesallsurvivinggadgets(atknownbyte
locations).2 MOTIVATION
Wediscussourmotivationsforapplicationspecialization.
Eliminating auxiliary program features: Priorstudieshave
shownasignificantfractionofprogramfeaturesarerarelyused[ 24].
We view this as an opportunity to eliminate the less commonly
usedfeaturesbyspecializingapplicationstotheircorefunctionality.
Inourexperiments,weaimtoselectconfigurationsthatrepresent
thecorefunctionalityofthetargetapplicationswhileleavingout
theauxiliaryfeatures.
Reduced attack surface: Modern operating systems protect
againstcodeinjectionattacksbypreventingpagesfrombeingsi-
multaneously executable and writable [ 49]. Code reuse attacks
circumventtheserestrictionsbyusinginstructionsequencesintheexecutablesectionsastheattackpayloaditself[
10,46].Thesecode
snippets,calledgadgets,endinareturnorjumpinstruction,thus
allowinganattackertochaintheexecutionofmultiplegadgets[ 26].
Asspecializationeliminatesunusedprogramfeatures,itreducesthe
attacksurfaceoftheprogrambyreducinggadgets.Inourresults,
weshowareductioninbinarysizecorrespondinglyreducestheset
ofprogramgadgetsanattackercanexploit.Toconductacodereuse
attack,anattackermusthaveknowledgeofthegadgetlocations
intheexecutable[ 32].Weshowspecializationintroducessoftware
diversity,makingitharderforattackerstogaininsightsaboutthe
gadgetlocationsinthetargetbinary.
3 TRIMMER
In this section, we describe the workflow for our configuration-based debloating tool Trimmer. For our implementation, we se-lected the LLVM framework [
34] since it provides frontends for
popularprogramminglanguagesincludingC/C++,andsupports
awealthofcompileranalysesandoptimizationpassesthatmake
it suitable for developing new compiler transforms. Trimmer isintendedtobeusedwithsoftwarethatiscompiledtoLLVMbit-
code modules - bitstream container format for encoding LLVM
IntermediateRepresentation(IR).Figure 1showstheworkflowfor
theproposedsystem.
The input to the tool is a manifest file that includes the user-
definedstaticconfiguration,andthepathtoawhole-programLLVM
bitcodefile.Theuser-definedstaticconfigurationcharacterizesthe
usagecontextoftheapplicationforagivendeployment.Trimmer
specializesthetargetapplicationmoduleswithrespecttothisusage
context.Thewhole-programbitcodefileconsistsofapplicationcode
thatiscompiledandlinkedintoasingleLLVMmodule.
Trimmeriscomposedofthreemajorcompilertransformsnamely
inputspecialization,loopunrolling,andconstantpropagation.The
firstphaseofthetoolworkflowincludesinputspecialization.In-put specialization propagates the static configuration data into
theprogramviatheprogramentrypoint.This,inturn,facilitates
simplifying program expressions dependent on these configura-tionconstants.Inputspecializationisdescribedinmoredetailin
Section3.1.Nextinthepipelineisaloopunrollingpassthataggres-
sively unrollsloops toaidlater optimizationpasses. We observe
thatimprovedloopunrollingisnecessarytofacilitateeffectivein-
terproceduralconstantpropagation.Thetransformisdiscussedin
Section3.2.
Oncetheconfigurationparametersareincorporatedasprogram
invariants, they can be aggressively propagated throughout the
330
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. TRIMMER: Application Specialization for Code Debloating ASE ’18, September 3–7, 2018, Montpellier, France
Figure 1: Overview of the tool workflow. Inputs to the tool include a) a whole-program LLVM bitcode file, and b) a manifest file. The user-
defined configuration specified in the manifest is leveraged to generate a specialized binary.
program.ProductioncompilerssuchasLLVMprovideoptimization
passes for constant propagation that enable this goal. However,
as LLVM optimizations tend to be conservative for purposes of
correctnessandefficiency[ 2,17],thisleadstomissedopportunities
foroptimizingthecodemoreaggressivelyinlightofthestatically
knownvalues.Accordingly,wedevelopamoresophisticatedinter-
proceduralconstantpropagationtransformthatbetterpropagates
the static configuration data throughout the program callgraph,
therebyenablingcodesimplification.Theimplementationoftheconstantpropagationoptimizationisdescribedinmoredetailin
Section3.3.Asconfigurationdataisincorporatedandpropagated,
existingcompileroptimizationscanbeinvokedlaterinthepipeline
tofurtherattemptcodesimplification.Finally,thelinkertakesas
inputthespecializedbitcodeandthelinkerflags(alsoreadfrom
themanifestfile),andgeneratesaspecializedbinaryexecutable.
3.1 Input Specialization
Applicationsparseuser-providedconfigurationinavarietyofdif-
ferentways.Commonly,configurationissuppliedasprogramar-
gumentsandconfigurationfiles.Whileourtoolincludestransfor-
mationsforincorporatingcommand-linearguments,supporting
file-basedconfigurationisnotwithinthescopeofthecurrentwork.
Inpractice,weobserveamajorityofapplicationsincludeawealth
ofconfigurablecommand-lineflagsthatcanbeexploitedforspe-
cialization.
Wedescribeourinputspecializationtransformthatleverages
partialevaluationconcepts[ 18,28].Thegoalofthistransformis
toincorporateuser-definedconstantinputsdirectlyintothepro-
gram, therefore specializing the application for a specific usage
context.Laterpassessuchasloopunrollingandconstantpropaga-tioncanleveragetheseconstantstosimplifyprogramexpressions,
consequently facilitating code debloating. Specifically, the trans-form specializes the program entry point for the user-provided
inputarguments.Thesestaticprogramargumentsareprovidedas
partofthemanifestfilethatisinputtothespecializer.
Algorithm 1shows the algorithm for the input specialization
transform.Thepassbeginsbyreadingtheinputargumentsfrom
the manifest file. Then, for each constant argument specified inthemanifest,alloriginalusesoftheargumentaresubstitutedbythe known constant value. If a target argument is explicitly an-notated as dynamic input (as part of the manifest), the original
usesremainunsubstituted.Thisisparticularlyuseful,asitallows
userstospecializeprogramsonapartially-specifiedsetofconstant
arguments.
Asapracticalexampleofinputspecialization,consideranetwork
monitoringtoolthattakesasinputaparticularnetworkinterface.Algorithm 1: AlgorithmforInputSpecialization
1
2Function inputSpecialization(manifestFile, programEntry)
3inputArgs←readArgs(manifestFile);
4programArgs←getProgramArgs(programEntry);
5argIndex←0;
6foreachargValue in inputArgs do
7 ifargValue is constant then
8 replaceArgUses(argValue,programArgs[argIndex]);
9 end
10 argIndex←argIndex+1;
11end
12
Whiletheapplicationmaysupportmultiplenetworkinterfaces,a
usage scenario may only require monitoring a specific interface
(e.g.,Ethernet).Specializingtheapplicationforaparticularinterface
allowsforpruningunusedfunctionality,thusreducingcodesize.
3.2 Loop Unrolling
In this section, we introduce our loop unrolling transformation.
Inthecontextofprogramspecialization,weobservethatloopun-
rollingisanecessaryoptimization.Unrollingisparticularlyimpor-
tantforinputparsingloopsthatextracttheuser-providedconfigu-
rationandstorethesevaluesasprogramvariables.Sinceunrolling
facilitatesthefoldingofprogramexpressionsinsidetheloopbody,
itsupportsconstantpropagationofthestaticconfiguration.
WhileLLVMincludesaloopunrollingpassintheoptimizations
suite, it is not entirely suited for our use case. Since the LLVM
unrollingpassisdrivenbyconservativeheuristicstoestimatethe
profitabilityoftheloopunroll,itveryoftenmissesopportunitiesfor
simplifyingexpressionsintheloopbody.Accordingly,wedevelop
aloopunrollingtransformthatleveragesourimprovedconstant
foldingtransformtomorepreciselydeterminetheprofitabilityof
unrolling a target loop. Specifically, the transform aggressively
unrollsloopsandthereafterappliesacostmodelontheunrolled
loop.Inthecontextofaspecificloop,thecostmodeldeterminesthe
usefulnessofthetransformbyidentifyingloop-basedoperations
that are simplified/folded as a result of the unrolling. Since the
transformreliesonconstantfoldingtodrivethecostmodel,ourtoolbundlestheloopunrollingtransformandtheconstantpropagation
transformasoneunifiedcompilerpass.Constantpropagationis
describedindetailinSection 3.3.
Algorithm 2illustratesthealgorithmfortheunrollingtransfor-
mation.The tryToUnrollLoop procedureattemptstofullyunroll
theprovidedtargetloop.First,thecallto getLoopTripCount ex-
tracts the trip count for the loop. If the loop trip count can be
staticallydeterminedasaconstantvalue,theloopisfullyunrolled.
331
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar
Algorithm 2: AlgorithmforLoopUnrolling
1
2Function tryToUnrollLoop(loop)
3tripCount←getLoopTripCount(loop);
4ifisConstant(tripCount) then
5 unrolledLoop←unrollLoop(loop,tripCount);
6 runConstProp(unrolledLoop);
7 unrollCost←evaluateCost(unrolledLoop);
8 ifunrollCost >costThreshold then
9 rerollLoop(unrolledLoop,tripCount);
10 end
11end
12ifnot isConstant(tripCount) then
13 peeledLoop←peelLoop(loop,peelCount);
14 runConstProp(peeledLoop);
15 ifisFullyUnrolled(peeledLoop) then
16 unrollCost←evaluateCost(peeledLoop);
17 ifunrollCost >costThreshold then
18 rerollLoop(peeledLoop,tripCount);
19 end
20 else
21 rerollLoop(peeledLoop,tripCount);
22 end
23else
24end
Figure2a:Theexampleparsingroutineextractsthecommand-line
options in a loop.
voidparse_input(int argc,char*argv[], structConfig *config){
while((intc = getopt (argc, argv, /quotedblVarpd/quotedblVar)) != -1){
switch(c){
case/quotesingleVarp/quotesingleVar: config->enable_plugins = false; break;
case/quotesingleVard/quotesingleVar: config->enable_debug = false; break;
}
}
}
Oncetheloopbodyisfullyunrolled,itallowsforpreciselydetermin-
ingtheusefulnessoftheunroll.Afterunrolling,the runConstProp
procedurerunsaconstantpropagationpassontheunrolledloop.
Thepurposeofinvokingtheconstantpropagationpassistofacili-
tatesimplificationoftheunrolledloopexpressions.Subsequently,
evaluateCost leveragesacostmodeltocomputethecostassoci-
atedwithunrollingthetargetloop.Sinceunrollingcertainloops
canpotentiallyincreasecodesize,itisnecessarytoevaluatethe
benefitofunrollingandskipunrollingifitdoesnotassistconstant
foldingofloop-orientedexpressions. evaluateCost determinesthe
fractionofinstructionssimplifiedasaresultofapplyingconstant
propagationontheunrolledloopandaccordinglycomputesacost
value.Ifnoorfewinstructionsaresimplified/folded,thecostmodel
returns a high cost value. If the cost model returns a high costassociatedwiththeunroll,theunrolledloopisrerolledtoregen-
eratetheoriginalloop.Ifthelooptripcountisnon-constant,the
peelLoop procedureisinvokedtopeelthefirstfewiterationsofthe
loop.Subsequently, runConstProp invokesconstantpropagation
topromoteconstantfoldingofexpressionsinthepeelediterations.
Applyingconstantpropagationonthepeeledloopiterationspo-
tentiallyallowsforstaticallyevaluatingtheloopexitconditions,
therebyassistingafullunroll.Iftheloopisnotfullyunrolled,it
cannotpromotefurtherconstantpropagation,andhence,theloop
isrerolled.Figure 2b: The parsing loop is fully unrolled.
voidparse_input(int argc,char*argv[], structConfig *config){
intoption = /quotesingleVarp/quotesingleVar;// getopt() replaced
switch(option){
case/quotesingleVarp/quotesingleVar: config->enable_plugins = false; break;
case/quotesingleVard/quotesingleVar: config->enable_debug = false; break;
}
option = /quotesingleVard/quotesingleVar;// getopt() replaced
switch(option){
case/quotesingleVarp/quotesingleVar: config->enable_plugins = false; break;
case/quotesingleVard/quotesingleVar: config->enable_debug = false; break;
}
}
}
Figure2c:Theunrolled getoptcallsarefoldedtocorrespondingcon-
stant values.
voidparse_input(int argc,char*argv[], structConfig *config){
config->enable_plugins = false;
config->enable_debug = false;
}
Figure2ashowsaninputparsingroutinethatreadstheinput
arguments in a getoptloop and sets the program configuration
variablesaccordingly.Forpurposesofillustration,weassumethat
thestaticprograminputincludestwocommand-lineflags, pandd.
Sincetheloopexitswhenthe getoptcallindicatesnomoreoptions
arepresent,thetripcountfortheargumentprocessingloopisnota
compile-timeconstant.Accordingly,theunrollingtransformpeels
thefirstfewiterationsoftheloop,anticipatingthatthesubsequent
constantfoldingtransformcanallowforstaticallyevaluatingthe
loopexitcondition,therebyeffectivelyfullyunrollingthetarget
loop. The transformed program in Figure 2bshows the loop is
fullyunrolledparticularlybecausetheresultofthe getoptcallis
staticallyevaluatedintermsofthestaticprogramarguments.As
getoptandgetopt_long areverycommonlyusedinparsingcode,
wehaveincludedacustomtransformtospecializethesecallsin
termsofconstantarguments.Asthe getoptcallsareevaluated,the
configurationsettingscanbecorrespondinglyresolvedtoconstant
values.Figure 2cdemonstratestheconfigurationsettingsarecorre-
spondinglyresolvedtoconstantvalues.Theexampledemonstrates
howfullyunrollingtheinputparsingloopfacilitatestheconstant
foldingofexpressionsintheloopbody.
3.3 Constant Propagation
The goal of our tool is to effectively debloat unused application
functionalitywithrespecttoagivenuser-definedusagecontext.Inordertoenablethis,theuser-providedconstantconfiguration
valuesmustbeaggressivelypropagatedthroughouttheprogram
callgraph,therebyaidingthecompileroptimizationpassesinfur-
thersimplifyingprogramexpressionsandpotentiallypruningdead
code.However,duetotheconservativenatureofconstantpropa-
gationinproductioncompilerssuchasLLVM[ 17],thesesimplifi-
cationsareoftennotfullyrealizable.Theconservativenatureof
thesetransformsisinspiredbyaneedformaintainingreasonable
compile-timesinthegeneralcompilationworkflow,thusavoiding
potentiallyexpensiveanalyses.Nonetheless,forourparticularuse
case of debloating, a more sophisticated albeit relatively expen-
siveconstantpropagationtransformisjustified.Ourexperimental
resultsdemonstratetheanalysesoverheadsareveryreasonable.
332
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. TRIMMER: Application Specialization for Code Debloating ASE ’18, September 3–7, 2018, Montpellier, France
Wedevelopaninterproceduralconstantpropagationtransfor-
mation that provides more precise propagation of configuration
invariants.Thetransformworksbymaintainingmemorystatefor
eachoftheprogramobjectsandtrackstheloadsandupdatesfrom
thetargetobjects.Algorithm 3givesthealgorithmforthetrans-
form.The runOnBasicBlock procedureisinvokedoneachbasic
blockofafunction, inreversepostorder.R eversepostorderensures
ablockisvisitedafterallitspredecessorblockshavebeenvisited.
Theprocedureisinitiallyinvokedontheentrybasicblockofthe
programentryroutine.Theargumenttotheprocedureisacontext
datastructurethatmaintainsthestateforeachtrackedmemory
object.Withintheprocedure,eachinstructioninthebasicblockis
traversed.Thekeypointsofthealgorithmcanbesummarizedas
follows:
Algorithm 3: AlgorithmforInterproceduralConstantPropa-
gation
1
2Function processCallInst(callInst, context)
3ifcallee is externally defined then
4 foreachargument in callInst do
5 checkSideEffects(argument,context);
6 end
7else
8 runOnBasicBlock(callee →entryBlock,context);
9end
10Function processBranchInst(branchInst)
11foreach successor block in branchInst do
12 ifall predecessors are visited then
13 newContext=mergePredecessorContext();
14 runOnBasicBlock(successor,newContext);
15 end
16end
1718
Function runOnBasicBlock(basicBlock, context)
19i=firstinstructioninbasicBlock;
20repeat
21 ifi is an allocation then
22 objectContext←createObjectContext(i);
23 addToContext(objectContext,context);
24 end
25 ifi is a store instruction then
26 ifconstant value store then
27 updateMemContext(operand,source,context);
28 else
29 markNonConstant(operand,context);
30 end
31 end
32 ifi is a load instruction then
33 ifoperand is constant in context then
34 replaceLoadWithConstant(i,context);
35 end
36 end
37 ifi is a call instruction then
38 processCallInst(i);
39 end
40 ifi is a branch instruction then
41 processBranchInst(i);
42 end
43 i←getSuccessorInst(i);
44 untili is the last instruction ;
45markVisited(basicBlock);HandlingAllocations: Foreachallocationsite(HeapandStack
allocations), a context data structure is created to represent the
memorystateoftheunderlyingmemoryobject.Thememorystate
forgloballydeclaredobjectsiscreatedatanalysisstartup.
Handling Loads and Stores: Foreach Storeinstruction,the
memorycontextofthetargetmemoryobjectisupdated.Forcon-
stant value stores, the memory state is updated with the corre-
spondingconstantvalue.Fornon-constantstores,thecorrespond-
ingmemorystateismarkedasnon-constant.Foreach Loadthat
correspondstoaconstantvalueinthetargetmemorycontext,the
load is directly replaced with the constant value. Such constant
foldingofloadspromotesfurtherconstantpropagation.
Handling Function Calls: TheprocessCallInst procedure
detailsthepoliciesforhandlingcallinstructions.Forcalleefunc-
tions defined internally, the control is transferred to the callee.
Moreover, the state of the memory context at the call-site is for-
wardedtothecallee.
As the constant propagation transform replaces the constant
memory loads inside a function body, the specialized call pathisonlyvalidinaparticularmemorycontext.Therefore,foreachdistinct memory context, a new cloned specialized routine mustbe created. However, since creating multiple clones of a single
functioncanincreasecodesize,weonlyspecializefunctionsthat
haveasingleidenticalmemorycontextacrossallcall-sites.Thisconservative approach prevents a code size blow up that could
resultwithgeneratingaspecializedfunctionperdistinctmemory
context.
Handling Branches: Asbranchinstructionsareencountered,
controlistransferredtothesuccessorblocks.The processBranch-
Instproceduredetailsthepoliciesforhandlingbranchinstructions.
Controlistransferredtoabasicblockonceallitspredecessorblockshavebeenvisited.Thisisnecessarysincethememorycontextavail-
ableataparticularblockiscomputedasanintersectionofthecon-
stantmemorycontextsavailableatallthepredecessorblocks.For
instance,ifoneofthepredecessorsincludesanon-constantstoreto
amemoryobject,thesuccessor’smemorycontextcorresponding
tothatobjectismarkednon-constant,regardlessofapotentially
constantcontextinadifferentpredecessor.Specifically,thecallto
procedure mergePredecessorContext merges the memory con-
textsofallpredecessorblocks.Weincludespecialhandlingofloops.
Ifthebasicblockistheheader(entryblock)ofaloop,theanalysis
doesnotwaitfortheanalysiscompletionofthelooplatches(blocks
that branch back into the loop header) and starts traversing the
loopbody.
Theimplementationsupportsamuchwiderrangeofinstruction
types. However, due to space limitations, we have detailed only
specific,interestingdetailsofthealgorithm.Figure 3aincludescode
thatpopulatestheconfigurationstructureswiththeuser-provided
settings. The parsing code under parse_input is assumed to be
alreadysimplifiedbyacombinationofinputspecializationandloop
unrolling.Theroutine start_process includescodethatiscondi-
tionalontheconfigurationsettings.Sincetheconfigurationvalues
enable_plugins andenable_debug areresolvedasconstants,the
constantpropagationtransformcanbeleveragedforpropagating
the constant values to the corresponding branch conditions un-der
start_process .Thisallowsexistingcompileroptimizations
to further simplify the code by statically evaluating the branch
333
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar
Figure 3a: The example code invokes routines that are conditional
on the configuration settings. The data structure configis popu-
lated with the configuration values.
voidparse_input(int argc,char*argv[], structConfig *config){
config->enable_plugins = false;
config->enable_debug = false;
}
voidstart_process(struct Config *config){
if(config->enable_plugins)
load_plugins(); // conditional invocation
if(config->enable_debug)
print_debug(); // conditional invocation
start_main_process(config);
}
voidmain(int argc,char*argv[]){
structConfig* config = malloc(sizeof(struct Config));
parse_input(argc, argv, config);start_process(config);
}
Figure3b:Theconstantconfigurationvaluesarepropagated;hence,
pruning the unreachable branch conditions, and in turn, eliminat-ing unreachable routines load_plugins and print_debug.
voidstart_process(struct Config *config){
// pruned unreachable calls
start_main_process(config);
}
voidmain(int argc,char*argv[]){
structConfig* config = malloc(sizeof(struct Config));
parse_input(argc, argv, config);start_process(config);
}
conditions, thereby eliminating dead code. Figure 3bshows the
correspondingtransformedprogramafterapplyingourconstant
propagationtransformfollowedbythestandardLLVMoptimiza-
tions. The calls to routines load_plugins andprint_debug are
prunedasaresultoftheoptimizations.
3.4 Soundness of Transformations
Trimmerprovidespropagationofconfigurationvaluesthrougha
combinationofsequentiallyexecutedpasses:inputspecialization,
loop unrolling, and constant propagation, while allowing exist-
ingLLVManalysestopruneprovablyunusedcodeinlightofthe
introducedconstants.Topreserveprogramsemantics,ourtransfor-
mationsmustpreventanyincorrectconstantfolding(replacinga
non-constantexpressionwithaconstantvalue).Incorrectconstant
foldingmayalsopotentiallyleadtounsounddeadcodeelimination
(eliminatingfunctions/branchesthatmaybeinvoked).
Toensurethecorrectnessofconstantfolding,wemakeconser-
vative assumptions regarding memory side effects. While these
assumptionslimittheprecisionofouranalysis,theyensurethat
thetransformationsaresound.Wediscussscenariosthatpresent
threatstothevalidityofourtransformationsandtheassumptions
necessarytopreservesoundness.
InputSpecialization: Intheinputspecializationtransform,we
replaceoccurrencesoftheprograminputarguments(argv refer-
ences)withcorrespondingconstantvaluesprovidedinthemanifest
file.Inputspecializationisasoundandincompletetransformation
tospecializeprogramsundertheassumptionthatcommandline
argumentsarenotdynamicallymodifiedintheprogram.Dynam-
icallyconfigurablesoftwareusesothermeanssuchassocketsorfilestoreconfigure(e.g.,HUPsignaliscommonlyusedinUnixpro-
gramstore-readtheconfigurationfile)[ 45].Inpractice,dynamic
reconfigurabilityisuncommon,andhenceinputspecializationcan
becorrectlyappliedinthecontextofmostprograms.
Notably,wedonoteliminatethecommandlineargumentsbut
onlyeliminatetheirreferences.Theargumentsarestillpresentand
loadedinmemory.Therecanbepointersto argvthatwecannot
trackduetoimprecisepointeranalysisbutthosepointerswillstill
readthecorrectarguments(maintainingsoundness)andtheseref-
erenceswillnotbeconvertedtoconstants(limitingcompleteness).
Sinceonlyreferencesthatareguaranteedtopointtoarguments
are replaced, other variables are not impacted. Similarly, in the
constantfoldingtransform,onlythereferencestostatically-proven
constant variables are replaced, thereby not impacting variables
withdynamicvalues.
External Function Calls: Forexternalfunctioncallswithun-
knownsemantics,wemakeconservativeassumptionsregarding
thememorysideeffects.Notably,a)eachcallargumentthatisnot
a read-only function parameter is assumed to be modified, andthecorrespondingcontextismarkedasnon-constant,andb)we
assumearbitraryglobalmemorysideeffects,markingallprogram
globalsasnon-constant.
Forstandardlibraryinterfaces(e.g., libccalls)withpredefined
standardsemantics,thetransformationscanmorepreciselyreason
aboutmemorysideeffects.Toallowthetooltoanalyzethelibrary
calls,theuserscanprovidea)pathstolibrarymodules(aspartof
theinputmanifestfile),orb)staticallylinkthelibrarieswiththe
applicationmodules(eliminatingexternalcalls).
Indirect Calls: Sinceourcurrentframeworkdoesnotinclude
supportfordevirtualizingindirectfunctioncalls,itmakesconser-
vativeassumptionsformemorysideeffects.Specifically,arguments
passedtoindirectfunctioncallsareconservativelyassumedtobe
modifiedandmarkednon-constant.Moreover,sincethetargetsof
indirect calls cannot be precisely determined, we conservatively
markallprogramglobalsasnon-constant.Theseconservativeas-
sumptionscanlimittheprecisionofconstantpropagationinsce-
narios where the configuration variables are globals. While an
incompletecall-graphnegativelyimpactstheprecisionofouranal-
yses,itdoesnotrenderitunsound.Sinceindirectlycalledfunctions
havetheiraddressestaken,thedeadcodeeliminationtransforms
inLLVMdonotprunethesefunctions.
4 EVALUATION
Ourevaluationseekstoanswerthefollowingquestions:(1)Does
Trimmereffectivelyreducecodebloatforreal-worldprograms?(2)
DoesTrimmerreducetheattacksurfaceforcode-reuseattacks?(3)
Whataretheperformanceimplicationsofspecialization?(4)Are
theanalysisoverheadsreasonable?
4.1 Experimental Setup
Toevaluatetheeffectivenessofourtool,weincludefourcompila-
tionpipelines.
•Baseline: TheBaselinepipeline includes programs compiled
withthestandardcompileroptimizations.Specifically,wecom-
pileapplicationsatthe-O2levelofoptimization.
334
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. TRIMMER: Application Specialization for Code Debloating ASE ’18, September 3–7, 2018, Montpellier, France
•PE:Thesecondpipeline,referredtoas PE,modelstheworkflow
ofanLLVM-basedpartialevaluationtool OCCAM[40].While
OCCAMuses a similar approach of specializing applications
forstaticarguments,itdoesnotincludetheloopunrollingand
constantpropagationtransformsforeffectivelypropagatingthe
staticconfiguration.Ourresultsshowthelackofthesetransforms
leadstomissedopportunitiesforcodedebloating.
•Trimmer: Thiscompilationpipelinerepresentstheworkflow
ofourdebloatingtoolTrimmerillustratedinFigure 1.Inaddi-
tiontoourproposedtransforms,weapplythestandardLLVM
optimizationsincludedinthe-O2optimizationlevel.
•Autotuned: Programautotuningisanoptimizationtechnique
thatisextensivelyusedtoimproveprogramperformance[ 14,23].
Autotuningleveragesheuristicsearchspaceexplorationtoiden-
tifyconfigurationsthatmaximizeagivenobjective.Theconfigu-
rationscontainparametersandsettingsthatimpactthetarget
objective.OpenTuner[ 4]isapopulartoolthatprovidesanex-
tensibleframeworkforautotuningbyallowinguserstospecify
thesearchspaceandtheparticularobjectivetooptimize.Forour
experiments, we used OpenTuner to search for compiler passsequencesthatoptimizethebinarysize.ApplyingOpenTunerto a specialized program is useful since it allows for discover-
ingoptimalcompilerpasssequencesthatbetterexploitthepro-
gramconstants.Forthisreferencepipeline,wereplacethe-O2
optimization level with an autotuned compiler pass sequence
extractedbyOpenTuner(onaper-programbasis).
4.2 Applications
For our experimental evaluation, we include 13 commonly used
Linuxapplications.TheprogramdescriptionsaredetailedinTable 1.
Weselectedadiversesetofprogramsincludingnetworkingtools
(knockd,httping,netperf,netstat,aircrack-ng,airtun-ng),popular
Linuxtoolsfordatatransfer,compression,profiling,andcaching
(curl, bzip2, gprof, memcached), commonly used Linux utilities(objdump,readelf),andanSMTsolver(Yices).Overall,weselect
programsthatprovideconfigurablecommand-lineflagsthatcan
beleveragedforprogramspecialization.Currently,ourtooldoes
notincludetransformsforfileI/Ospecializationandthuswedo
notincludeapplicationsthatreadconfigurationfiles.Sincesome
of these programs are also used in embedded systems, the code
sizereductionsachievedhaveimportantimplicationsforresource-
constraineddevices.Intermsofreducingresourceusage,whilebi-
narysizereductionisnotparticularlyvaluableforgeneral-purpose
systems,asmallercodefootprintreducestheexploitablevulnera-
bilitiesandsimplifiessecurityanalysis.Section 4.4discusseshowa
trimmedbinaryresultsinareducedattacksurface.
Thecorrespondingstaticargumentsusedforspecializationare
alsodetailedinTable 1.The“ ”symbolsinthestaticarguments
columnindicatenon-constantargumentsthatcanbespecifiedat
runtime.Forinstance,thenameofaninputfilemaybeprovidedas a runtime argument to the specialized binaries. Our selection
ofstaticprogramargumentsisdrivenbytwocommonscenarios.
Specifically, we select arguments that i) represent the core func-
tionalityoftheapplicationwhileleavingouttheauxiliaryfeatures,
orii)representacommonusecaseforanapplicationthatsupports
multiple use cases. The first scenario is useful with applications
thatprovidecertaincorefunctionality,andtheauxiliaryfeaturesarerarelyeverusedandhencecanbeeliminated.Thesecondsce-
narioisusefulwithapplicationsthathavemultipleusagescenarios,
however,onlyafractionofthoseusagescenariosarelikelytobe
relevantinaparticulardeployment.
4.3 Reducing Code Bloat
Inthissection,weevaluatethecodesizereductionsachievedbyus-ingTrimmertospecializeapplicationsforasetofconstantprogramarguments.Figure 4showsthecodesizereductionsfortheincluded
applicationsacrossthefourreferencecompilationpipelines.Now
wedescribetheusecasesofspecializingprogramsforstaticconfigu-
rations.Duetospaceconstraints,wedetailasubsetofspecialization
scenarios:
knockdisapopularport-knocktoolusedinLinuxservers[ 39].
knockdlistenstoalltrafficonanEthernet(orPPP)interface,lookingforspecial“knock”sequencesofport-hits.Aclientmakestheseport-
hitsbysendingaTCP(orUDP)packettoaportontheserver.We
specializedknockdforthemorecommonlyusedEthernetinterface
(alsothedefault),whichresultedinslimmingthebinaryby23.8%.
Thecodesizereductionisachievedbyremovingthesupportfor
thePPPinterface.
memcached isapopularkey-valuedistributedmemoryobject
cachingsystem.Itisusedextensivelyforcachingresultsofdatabase
queries and API calls [ 29]. We specialized memcached for two
essentialarguments:maxmemory(-m)andtheIPaddresstobind
to(-l).SincethevaluescorrespondingtothemaxmemoryandIP
addressflagsarespecifiedasdynamicvalues(“ ”symbols),these
valuescanstillbeprovidedasargumentstothespecializedbinary.
Forthisconfiguration,weobserveareductionof14%.Thereduction
is achieved by debloating support for auxiliary features such as
knobsthattuneverbositylevels,pagesizes,anddataitemsizes.
netperfis a benchmark tool used to determine the maximum
latencyandthroughputbetweentwoendpoints[ 9,11].netperfpro-
videssupportforarangeofnetworktestsforprotocolsincluding
TCPandUDP.Wespecializenetperfforcommonlyusedarguments
including:IPoftheremoteendpoint(-H),nameofnetworktest(-t),
intervalsfordisplayinginterimresults(-D),andlengthofthetest
(-l).Thevaluesfortheseflagsarepassedasruntimevaluestothe
specializedbinary.Therefore,thespecializedbinarystillsupports
allincludednetworktestswhiledebloatingauxiliaryfunctionality
includingoutputformatting,debugoutput,andIPv6connections
amongothers.Specializationforthisconfigurationprovidesasize
reductionof22.1%.Greatersizereductionsareachievablebyspecial-
izingnetperfforoneparticularnetworktest.Forinstance,merely
including support for the default “TCP_STREAM” test yields a
reductionof38.1%.For11networktestsincludedwithnetperf,spe-
cializing for one network test provides a mean size reduction of
54.8%.
curlisatoolcommonlyusedfortransferringdata.Itisexten-
sivelyusedincars,televisionsets,routers,printers,audioequip-ment, mobile phones, and media players among other softwareapplications[
50].curlincludessupportformultipleprotocolsin-
cludingHTTP,FTP,SMTP,IMAP,andLDAPamongothers.curlis a feature-rich program with more than 120 command-line op-tions for various tasks and knobs including proxy connections,FTPoperations,progressbars,ratelimiting,andIPv6addressing
amongothers.Whilecurlisusedinavarietyofdifferentways,itis
335
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar
Table 1: Descriptions of the studied applications. The static arguments used for specialization are included. The “ ” symbols indicate non-
constant arguments that can be specified at runtime.
Application Binary Size Static Arguments Description
knockd 47KB -ieth0 Listenstotrafficonaspecifiednetworkinterface,lookingforsequencesofporthits
httping 44KB -G-s-X-b-B Measureslatencyandthroughputforagivenwebserver
netperf 162KB -H-t-D-l Benchmarkformeasuringvariousaspectsofnetworkingperformance
aircrack-ng 113KB -b-awpa-s-wdictionary.lst UsedtoassessWiFinetworksecurity
airtun-ng 88KB -a-w Createsavirtualtunnelinterfacetomonitorencryptednetworktraffic
bzip2 31KB -force–keep–quiet–small PopularcompressiontoolusedonmajorLinuxdistributions
objdump 1.9MB -D–syms-s-w Displaysinformationfromobjectfiles.Optionscontroltheinformationdisplayed
readelf 524KB -h-l-S-s-r-d DisplaysinformationaboutELFfiles.Theoptionscontroltheinformationdisplayed
gprof 894KB -c-r-i-s Profilesprogramexecutionandcollectsprogramstatistics
memcached 100KB -m-l Anin-memorykey-valuestoreforsmallchunksofarbitrarydata
netstat 117KB -a-e-p-s Printsnetworkconnections,routingtables,interfacestatistics,multicastmemberships
curl 279KB –compress–http2.0–ipv4–ssl–url Transfersdatafromortoaserver,usingoneofthesupportedprotocols
yices 1.6MB –logic=QF_AUFBV SMTSolverwithsupportforarithmetic,array,bitvector,anduninterpretedfunctions
unlikelyadeploymentscenariowouldrequirealltheshippedfunc-
tionality.Insuchcases,specializationcanbeleveragedtoremove
theundesiredfeatures.Wespecializedcurlforthecommonusage
scenarioofreadingdataoveranHTTPSconnectiongivenatarget
URL(curl-1inFigure 4).Thisparticularcurlconfigurationiscom-
monlyusedforreadingRSSfeedsandprovidesa75.4%binarysize
reduction.Similarly,specializingcurlasanSMTPclientforsending
emails(curl-2)reducesthebinarysizeby71.8%.Thesereductions
are achieved by debloating protocols and features that were not
requiredinthecorrespondingconfigurations.Sinceusagescenarios
willvaryacrossdeployments,userscandefinestaticconfigurations
thatbestrepresenttheirusecases.
Yices[21]isanSMTsolverthatincludessupportforfourtheories
including:linearandnon-lineararithmetic,theoryofarrays,bitvec-
tortheory,andtheoryofuninterpretedfunctions.SMTsolversare
used in a range of different application domains including hard-
wareverification[ 15,47],symbolicexecution[ 13,38],andbounded
modelchecking(BMC)[ 8]amongothers.WespecializedYicesfor
3 different combinations of theory solvers to generate versions
specializedforaparticularproblemdomain.Sincehardwareverifi-
cationusuallyrequiresSMTsolverswithsupportforthebitvector
theory[27],wespecializedYicesforthisconfiguration(yices-1in
Figure4) yielding a 10.2% reduction in code size. Similarly, sym-
bolicexecutionandtestgenerationrequiresupportforthetheory
ofbitvectorandarrays[ 12,22].SpecializingYicesforthisconfig-
uration(yices-2)yieldeda7.7%reductioninbinarysize.Bounded
modelcheckingandk-inductionfortimedsystemsmerelyrequire
support for linear real arithmetic [ 31]. Specializing Yices for the
lineararithmeticsolver(yices-3)resultedina24.1%sizereduction.
ResultsSummary: Asintheaforementionedusecases,therest
oftheapplicationshavebeenspecializedwithstaticconfigurations
thatrepresentrealisticusecases.Forthe13programsstudied,we
observe a mean binary size reduction of 21.1% compared to the
baseline.Forallprograms,partialevaluation(PE )usingtheOCCAM
tool does not provide binary size reduction. Since OCCAM does
notincludethenecessarysimplifyingtransformsofimprovedloop
unrolling and constant propagation, it misses opportunities for
debloatingcode.
Weleverageautotuningtechniquestosearchforcombinations
ofoptimizationsthatreducecodesize.Incomparisontoapplying
thestandard-O2optimizationpipeline,autotuningthespecialized020406080100120Baseline PE TRIMMER AutotunedBinary size as percentage of Baseline (%)
Figure4:Comparingbinarysizesacrossthefourreferencecompila-
tion pipelines. The reductions are shown relative to the Baseline.
applicationprovidesanadditional4.3%sizereduction(25.4%over-
all) on average. These results show an optimized compiler pass
sequence can better exploit the constants introduced as part of
specialization.
4.4 Reducing the Attack Surface
Weassesstheimplicationsofspecializationonreducingcodereuse
attacks. Acodereuse attackis morepowerfulcomparedto codeinjectionattackssinceitleveragesexistingcodesnippets(called
gadgets)intheexecutableastheattackpayload[ 46].Theseattacks
require subverting the programs’ control flow by exploiting vul-nerabilities such as buffer overflows [
3], integer overflows [ 42],
or format string vulnerabilities [ 37]. Gadgets are small code se-
quencesthatusuallyendwitha RETorJMPinstruction.Thisallows
attackers to chain pointers to the gadgets on the stack, thereby
constructingamaliciouspayload.However,toconductacodereuse
attack,anattackermusthaveknowledgeofthegadgetlocationsintheexecutable[
32].Priorworkhasfocusedondiversification
techniques that limit the attacker to a small subset of these pre-
dictabletargets,thusrenderingtheattacksinfeasible.SomeofthesetechniquesincludeNOPinsertionandinstructionlocationrandom-
ization(ILR)[25, 26].
336
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. TRIMMER: Application Specialization for Code Debloating ASE ’18, September 3–7, 2018, Montpellier, France
OurresultswithTrimmershowthatspecializationcanreduce
thenumberofexploitablegadgetsaswellasrelocatethegadget
locations,thusdiversifyingthebinary.Whilewedonotclaimspe-
cialization serves as a standalone defense mechanism, we show
it can significantly reduce the attack surface. Table 2shows the
resultsofourgadgetanalysis.Forourexperiments,weusedROP-
gadget[44],apopulartoolforfindinggadgetsinprogrambinaries.
TheGadgets Baseline columnincludesthetotalnumberofgadgets
in the original binary compiled with the baseline. The Gadgets
Trimmercolumnincludesthenumberofgadgetsinthebinaryafter
applying specialization using Trimmer. For all applications, we
observenoticeablereductionsinthetotalgadgetcount.Acrossall
programs,weobserveameanreductionof20.1%andamaximum
reductionof87%(forcurl).Wealsomeasurethesystemcallgadgets
across the original and specialized binaries. To carry out useful
tasks,attackersoftenneedtoexploitsystemcalls[ 10].Hencemost
ROPattackssetupthestacktoexecuteshortsequencesofgadgets
beforeasystemcallisissued[ 19].Thegadgetsexecutedpriortothe
systemcallgadgetallowforsettingupthestackwiththeintended
arguments,thusallowinganattackertoexecuteanoperationof
interest.Ourresultsindicatefor7outofthe8programsthatcon-
tain system call gadgets, the gadgets are reduced. For 4 of these
programs,thesystemcallgadgetsarecompletelyremoved,there-
forecreatingbinariesthatarenotsusceptibletoROPattacksthat
leveragesystemcalls.Notably,specializing curlforbothconfigura-
tions(describedintheprevioussection)eliminatedall11system
callgadgetsinthebaselinebinary.For3programs,weobservea
slightincrease(of1)insystemcallgadgets.Althoughspecializationmaypotentiallyintroducenewgadgets,weobservethatdebloating
unusedfeaturesmostlyreducesgadgets.
Specializingapplicationsforspecificconfigurationsallowsfor
diversifying the program, making it harder for attackers to gain
insightsaboutthegadgetlocations.Tomeasurediversification,we
countthenumberoffunctionallyequivalentgadgetsatthesame
bytelocationinthebaselineandspecializedbinaries.Wecallthese
surviving gadgets,consistentwithpriorworkincodediversifica-
tion[26].Notably,acrossallprograms,thesurvivinggadgetsare
reducedto0,showingthatinstructionsequencesaresufficiently
modifiedbyourtransforms.Thebenefitsofdiversificationareen-
hancedifanapplicationcanbespecializedforarangeofdifferent
configurationsandeachspecializedbinaryissufficientlydissimi-
larfromtheother.Toevaluatethis,wespecializedtheYicesSMT
solverfordifferentcombinationsoftheorysolvers.Forall12pos-
sible configurations of Yices, we generated a specialized binary
foreachconfigurationanddidapair-wisecomparisonofcommon
gadgets(functionallyequivalentgadgetsatthesamebytelocation)
across the binaries. The highest gadget overlap across any twobinaries is only 4.2%. Moreover, none of the 12 specialized bina-
rieshasanycommongadgetswiththebaselinebinary.Similarly,
comparing the specialized binaries corresponding to 5 differentconfigurationsofcurl,thehighestgadgetoverlapisonly3%and
noneofthespecializedbinarieshasanycommongadgetswiththe
baselinebinary.Compared to existing diversification and enforcement-based
mechanisms,specializationprovidesamajoradvantagebyincur-
ringnoperformanceoverheadandreducingspaceoverhead.Tech-
niquessuchasCFI,ILR,NOPinsertionallhavenegativeimplica-
tionsforcodesizeandperformance[ 1,25,26,53].Overall,Trimmer
can provide a useful diversification mechanism for applicationsthat can be specialized based on their deployment settings. Di-
versification via specialization can be used in conjunction with
enforcement-based mechanisms such as CFI to provide stronger
securityguarantees.
Table2:“GadgetsBaseline"referstothetotalgadgetsintheoriginal
binary,while“GadgetsTrimmer"referstothegadgetsremainingin
thespecializedbinary(applyingTrimmer).“SyscallGadgets"isthe
numberofsystemcallgadgetsintheoriginalbinary,while“SyscallGadgets Trimmer" refers to gadgets remaining in the specialized
binary. Reduction (%) shows the percentage reduction in the total
gadgets after specialization.
Application Gadgets
BaselineSyscallGadgets Gadgets
TrimmerSyscallGadgets
TrimmerReduction
(%)
knockd 246 0 161 0 34.6%
httping 580 0 218 0 62.9%
netperf 963 1 793 0 17.7%
aircrack-ng 1091 0 955 1 12.5%
airtun-ng 786 1 733 0 6.7%
bzip2 246 0 208 0 15.5%
objdump 11228 1 9419 2 16.1%
readelf 3875 1 2902 0 25.1%
gprof 9555 6 8433 1 11.7%
memcached 883 0 641 1 27.4%
netstat 440 4 355 0 19.3%
curl-1 2786 11 372 0 86.7%
curl-2 2786 11 382 0 86.2%
yices-1 12245 8 11348 3 7.3%
yices-2 12245 8 11651 3 4.9%
yices-3 12245 8 9660 3 21.1%
4.5 Performance Impact
Tounderstandtheperformanceimpactofapplicationspecialization,
we measured the execution time of each program over ten runs,
comparing the original and specialized binaries. For gprof, curl,
and netperf, we observe noticeable performance improvementsof4.8%,4.6%,and13%,respectively.Fortheremainingprograms,
we observe less than 1% improvement. Measuring the dynamic
instructionsshowsspecializationimprovesperformancewhenthe
instructionsexecutedonthehotpathofexecutionarereduced.In
otherinstances,althoughdebloatingreducesthestaticinstructions,itdoesnotsignificantlyreducetheinstructionsexecutedonthehot
path. Prior work has shown autotuning compiler transforms for
parallelizingcompilerscanyieldsignificantperformanceimprove-
ments[5,51].However, sinceourautotuningsearchistunedfor
minimizingcodesize,wedonotobservenoticeableperformance
differencescomparedwiththe-O2pipeline.
4.6 Analysis Time
WeevaluatedthetimeusageofourtoolonaLinuxworkstationwith
anIntelCorei5-3380MCPUrunningat2.9GHz.Wecompiledour
LLVMtransformswithClangatthe-O2levelofoptimization.Fig-
ure5showsthepercentagebreakdownoftheindividualtransform
overheads. Loop Unroll denotestheoverheadfortheloopunrolling
transform, Const Prop showstheoverheadfortheconstantprop-
agation transform, and O2denotes the overhead of running the
337
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Hashim Sharif, Muhammad Abubakar, Ashish Gehani, and Fareed Zaffar
0%10%20%30%40%50%60%70%80%90%100%Loop Unroll Const Prop O2
Figure 5: Comparing the analysis overheads of loop unrolling, con-
stant propagation, and the standard LLVM optimizations (-O2).
LLVM-O2optimizationpipeline,whichincludesmultiplestandard
compileroptimizationpasses.Wedonotshowtheexecutiontimes
fortheinputspecializationtransformsincethatincursnegligible
overhead.Theevaluationindicatesloopunrollingdoesnotincur
significant overhead, while the -O2 optimization pipeline incurs
thelargestfractionoftheanalysistime.Onaverage,loopunrolling
constitutes6.4%,constantpropagationconstitutes35.5%,and-O2
constitutes 58.1% of the total execution time. The absolute time
usageofthetoolisalsoreasonable.Onaverage,theanalysistime
acrossallprogramsis7.2seconds,andthemaximumanalysistime
(forYices)is18.9seconds.Thetimeusagesarequitereasonable,par-
ticularlyconsideringthespecializationoverheadisaone-timecost.
Theseoverheadsindicateitmaybefeasibletoincorporatemore
sophisticatedloopunrollingandconstantpropagationtransforms
aspartoftheLLVMtoolchain.
5 RELATED WORK
Programspecializationhasbeenthetopicofbothearlierandrecent
researchefforts.Ourtoolbuildsonpreviouslypublishedworkin
theareaofspecialization.Weseeourworkfittinginthebroadscope
oftheseefforts,withaspecificmotivationforcodedebloating.
Malechaetal.[ 40]presentedapartialevaluationtoolchainfor
specializingwholeprograms.Whiletheirtoolincludestransforms
for specializing programs with respect to the predefined static
userinput,itentirelyreliesonthestandardLLVMoptimizations
forprovidingthenecessarycodesimplification.Inourwork,we
observe these techniques are inadequate for providing effective
specialization.Insteadofrelyingonheroiccompileranalysis,we
developtransformsthatimproveconstantpropagation.
Smowtonetal.[ 48]proposedaframeworkthatpropagatescon-
stantdatafromthefilesystemintotheprogram.Thesetechniques
areparticularlyrelevantforprogramsthatreadstaticconfiguration
files.Whilethesetechniquespresentinterestingsolutions,webe-
lievetheyneedtobeextendedtoworkeffectivelywithreal-world
programs.Aspartoffuturework,wehopetoinvestigatehowto
integratefile-basedspecializationaspartofourframework.
Specializationhasalsobeenenvisionedinthebroadercontextof
optimizingthefullsoftwarestack[ 6,41].Bhatiaetal.[ 6]applied
partialevaluationtechniquesforspecializingthenetworkstackin
operatingsystemkernels.Theapproachappliedissemi-automaticasitrequirestheusertoprovidedeclarativeannotationsforspec-
ifying program invariants. We believe this process can be fully
automatedandtherebymademorepractical,byextendingourtool
withthenecessarytechniquesforhandlingOS-specificconstructs.
Debloating application containers such as those provided by
Dockerhasbeenthetopicofrecentwork[ 43].Rastogietal.employ
anapproachbasedondynamicanalysisforautomaticallypartition-ingcontainerstoprovidebetterprivilegeseparationacrossdifferent
applications.Inparticular,dynamicanalysisisleveragedtoiden-
tifytheresourcedependenciesofapplicationstherebyguidingthe
partitioningprocess.However,theirtoolonlypartitionscontainers
atthegranularityofindividualexecutablesanddoesnotpartition
executables. Trimmer uses static analysis techniques to debloat
functionalityatfinergranularity.
6 LIMITATIONS AND FUTURE WORK
Trimmerprovidesanimportantstepinmakingspecializationprac-
ticalforreal-worldprograms.Inthissection,wepointoutsome
limitationsofourtoolanddiscussdirectionsforfutureresearch.
Operatingsystemstacksoftencontainlow-levelassemblycode
to implement the architecture-specific operations. To specialize
thefullsoftwarestack,compilertransformsmusteitherhavethe
capabilitytoanalyzeassemblycodeorrelyonthetranslationof
assemblycodetothecompilerIR[ 20].Aspartoffuturework,we
intend to extend Trimmer with analyses that can reason about
assemblycode.Moreover,systemscodeandapplicationsoftenin-
cludeindirectfunctioncallsthatcanlimitthecapabilitiesofstatic
analysis [30]. In the presence of indirect function calls, our con-
stantpropagationtransformmakesconservativeassumptionsabout
memorysideeffects.Infutureresearch,wehopetoincludeanal-
ysesfordevirtualizingindirectfunctioncalls,therebyfacilitating
morepreciseconstantpropagation.Currently,ourtoolspecializes
applicationsforstaticprogramarguments.Tosupportapplications
thatreadconfigurationfiles,weintendtobuildtransformationsfor
specializingfileI/Ooperations.
7 CONCLUSION
Inthispaper,weintroducedTrimmer,anapplicationspecialization
toolthatdebloatsunusedfunctionalitybyspecializingprograms
foruser-definedconfigurations.Ourresultsdemonstrateourtool
effectivelyoptimizesbinarysizesforreal-worldprograms.Forap-
plicationsspanningvariousdomains,weobservedameanbinary
sizereductionof21%andamaximumreductionof75%.Wealsoshowedspecializationcanserveasamechanismforintroducing
softwarediversityandcanreducethenumberofexploitablegad-
gets.Fortheevaluatedprograms,weobservea20%meanreduction
inthetotalgadgetsandamaximumreductionof87%.Webelieve
ourtoolisanimportantsteptowardsthegoalofspecializingthe
fullsoftwarestack.
ACKNOWLEDGEMENTS
This material is based upon work supported by the US National
Science Foundation (NSF) under Grant ACI-1440800 and the Of-
ficeofNavalResearch(ONR)underContractN68335-17-C-0558,
Grant N00014-4-1-0525, and Grant N00014-17-1-2996. Any opin-
ions,findings,andconclusionsorrecommendationsexpressedin
thismaterialarethoseoftheauthorsanddonotnecessarilyreflect
theviewsofNSForONR.
338
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. TRIMMER: Application Specialization for Code Debloating ASE ’18, September 3–7, 2018, Montpellier, France
REFERENCES
[1]Abadi,M.,Budiu,M.,Erlingsson,U.,andLigatti,J. Control-flowintegrity.
InProceedings of the 12th ACM Conference on Computer and Communications
Security (CCS) (2005),ACM,pp.340–353.
[2]Aho,A.V.,Sethi,R.,andUllman,J.D. Compilers,Principles,Techniques.Addison
WesleyBoston,1986.
[3]Aleph, O. Smashing the stack for fun and profit. http://www. shmoo.
com/phrack/Phrack49/p49-14 (1996).
[4]Ansel, J., Kamil, S., Veeramachaneni, K., Ragan-Kelley, J., Bosboom, J.,
O’Reilly,U.-M.,andAmarasinghe,S. Opentuner:Anextensibleframework
forprogramautotuning. In 23rd International Conference on Parallel Architecture
and Compilation Techniques (PACT) (2014),IEEE,pp.303–315.
[5]Basu,P.,Venkat,A.,Hall,M.,Williams,S.,VanStraalen,B.,andOliker,L.
Compilergenerationandautotuningofcommunication-avoidingoperatorsfor
geometricmultigrid. In 20thAnnualInternationalConferenceonHighPerformance
Computing (2013).
[6]Bhatia,S.,Consel,C.,LeMeur,A.-F.,andPu,C. Automaticspecializationof
protocolstacksinOSkernels. In Proceedings of the 29th Annual IEEE Conference
on Local Computer Networks (2004).
[7]Bhattacharya,S.,Rajamani,K.,Gopinath,K.,andGupta,M. Theinterplay
ofsoftwarebloat,hardwareenergyproportionalityandsystembottlenecks. In
Proceedingsofthe 4thWorkshopon Power-Aware ComputingandSystems (2011),
ACM,p.1.
[8]Biere,A.,Cimatti,A.,Clarke,E.M.,Strichman,O.,Zhu,Y.,etal. Bounded
modelchecking. Advances in Computers 58 (2003),117–148.
[9]Binkert,N.L.,Hallnor,E.G.,andReinhardt,S.K. Network-orientedfull-
systemsimulationusingm5. In Sixth Workshop on Computer Architecture Evalu-
ation using Commercial Workloads (CAECW) (2003),pp.36–43.
[10]Bletsch,T.,Jiang,X.,Freeh,V.W.,andLiang,Z. Jump-orientedprogramming:
anewclassofcode-reuseattack. In Proceedingsofthe6thACMSymposiumon
Information, Computer and Communications Security (2011),ACM,pp.30–40.
[11]Blum,R.NetworkPerformanceOpenSourceToolkit:usingNetperf,tcptrace,NISTnet,
and SSFNet. JohnWiley&Sons,2003.
[12]Brummayer,R.,andBiere,A. Boolector:AnefficientSMTsolverforbit-vectors
andarrays.In InternationalConferenceonToolsandAlgorithmsfortheConstruction
and Analysis of Systems (2009),Springer,pp.174–177.
[13]Cadar,C.,Dunbar,D.,Engler,D.R.,etal. KLEE:Unassistedandautomatic
generationofhigh-coveragetestsforcomplexsystemsprograms. In Proceedings
ofthe8thUSENIXconferenceonOperatingSystemsDesignandImplementation
(OSDI)(2008),vol.8,pp.209–224.
[14]Christen,M.,Schenk,O.,andBurkhart,H. Patus:Acodegenerationandautotuning framework for parallel iterative stencil computations on modern
microarchitectures. In IEEEInternationalParallel&DistributedProcessingSym-
posium (IPDPS) (2011),IEEE,pp.676–687.
[15]Clarke, E., Talupur, M., Veith, H., and Wang, D. SAT based predicate ab-
stractionforhardwareverification. In International Conference on Theory and
Applications of Satisfiability Testing (2003),Springer,pp.78–92.
[16]Consel,C.,Hornof,L.,Marlet,R.,Muller,G.,Thibault,S.,Volanschi,E.-N.,
Lawall,J.,andNoyé,J. Tempo:Specializingsystemsapplicationsandbeyond.
ACM Computing Surveys (CSUR) 30,3es(1998),19.
[17] Cooper,K.,andTorczon,L. Engineering a Compiler. Elsevier,2011.
[18]Danvy,O. Type-directedpartialevaluation. In PartialEvaluation.Springer,1999,
pp.367–411.
[19]Davi,L.,Sadeghi,A.-R.,Lehmann,D.,andMonrose,F. Stitchingthegadgets:
Ontheineffectivenessofcoarse-grainedcontrol-flowintegrityprotection. In
USENIX Security Symposium (2014),pp.401–416.
[20]Dinaburg,A.,andRuef,A. Mcsema:Statictranslationofx86instructionsto
LLVM. In ReCon 2014 Conference, Montreal, Canada (2014).
[21]Dutertre,B.Yices2.2.In InternationalConferenceonComputerAidedVerification
(CAV)(2014),Springer,pp.737–744.
[22]Ganesh,V.,andDill,D.L. Adecisionprocedureforbit-vectorsandarrays. In
InternationalConferenceonComputerAidedVerification(CAV) (2007),Springer,
pp.519–531.
[23]Grauer-Gray, S., Xu, L., Searles, R., Ayalasomayajula, S., and Cavazos, J.
Auto-tuningahigh-levellanguagetargetedtoGPUcodes. In Innovative Parallel
Computing (InPar) (2012),IEEE,pp.1–10.
[24]Hibbs,C.,Jewett,S.,andSullivan,M. The art of lean software development: a
practical and incremental approach. "O’ReillyMedia,Inc.",2009.
[25]Hiser, J., Nguyen-Tuong, A., Co, M., Hall, M., and Davidson, J. W. ILR:
Where’dmygadgetsgo? In IEEE Symposium on Security and Privacy (SP) (2012),
IEEE,pp.571–585.
[26]Homescu,A.,Neisius,S.,Larsen,P.,Brunthaler,S.,andFranz,M. Profile-
guidedautomatedsoftwarediversity. In Proceedings of the 2013 IEEE/ACM In-
ternational Symposium on Code Generation and Optimization (CGO) (2013),IEEE
ComputerSociety,pp.1–11.
[27]Jha, S., Limaye, R., and Seshia, S. A. Beaver: Engineering an efficient SMT
solverforbit-vectorarithmetic. In InternationalConferenceonComputerAidedVerification (CAV) (2009),Springer,pp.668–674.
[28]Jones,N.D.,Gomard,C.K.,andSestoft,P. Partialevaluationandautomatic
program generation. PeterSestoft,1993.
[29]Jose,J.,Subramoni,H.,Luo,M.,Zhang,M.,Huang,J.,Wasi-urRahman,M.,
Islam,N.S.,Ouyang,X.,Wang,H.,Sur,S.,etal. Memcacheddesignonhigh
performanceRDMAcapableinterconnects.In InternationalConferenceonParallel
Processing (ICPP) (2011),IEEE,pp.743–752.
[30]Kim, H., Joao, J. A., Mutlu, O., Lee, C. J., Patt, Y. N., and Cohn, R. VPC
prediction:reducingthecostofindirectbranchesviahardware-baseddynamic
devirtualization. ACMSIGARCHComputerArchitectureNews35,2(2007),424–
435.
[31]Kindermann,R.,Junttila,T.,andNiemelä,I. SMT-basedinductionmethods
fortimedsystems. In International Conference on Formal Modeling and Analysis
of Timed Systems (2012),Springer,pp.171–187.
[32]Larsen,P.,Brunthaler,S.,Davi,L.,Sadeghi,A.-R.,andFranz,M. Automated
softwarediversity. Synthesis Lectures on Information Security, Privacy, & Trust 10,
2(2015),1–88.
[33]Larus,J. SpendingMoore’sdividend. CommunicationsoftheACM52,5(2009),
62–69.
[34]Lattner,C.,andAdve,V.LLVM:Acompilationframeworkforlifelongprogram
analysis&transformation. In ProceedingsoftheInternationalSymposiumonCode
Generation and Optimization: Feedback-directed and Runtime Optimization (2004),
IEEEComputerSociety,p.75.
[35]Lee, C.-T., Lin, J.-M., Hong, Z.-W., and Lee, W.-T. An application-oriented
Linuxkernelcustomizationforembeddedsystems. J.Inf.Sci.Eng.20,6(2004),
1093–1107.
[36]Lekatsas, H., and Wolf, W. Code compression for embedded systems. In
Proceedingsofthe35thAnnualDesignAutomationConference(DAC) (1998),ACM,
pp.516–521.
[37]Lhee,K.-S.,andChapin,S.J. Bufferoverflowandformatstringoverflowvul-
nerabilities. Software: Practice and Experience 33,5(2003),423–460.
[38]Ma,K.-K.,Phang,K.Y.,Foster,J.S.,andHicks,M. Directedsymbolicexecution.
InInternational Static Analysis Symposium (SAS) (2011),Springer,pp.95–111.
[39]Madia, A., Nikoletseas, S., Stamatiou, Y., Tsolovos, D., and Vlachos, V.
Crowdsourcingbasedprivacythreatanalysisandalerting. Cryptography, Cyber
Security and Information Warfare (3rd CryCybIW) (2016).
[40]Malecha,G.,Gehani,A.,andShankar,N. Automatedsoftwarewinnowing.
InProceedings of the 30th Annual ACM Symposium on Applied Computing (SAC)
(2015),ACM,pp.1504–1511.
[41]McNamee,D.,Walpole,J.,Pu,C.,Cowan,C.,Krasic,C.,Goel,A.,Wagle,P.,
Consel,C.,Muller,G.,andMarlet,R. Specializationtoolsandtechniques
forsystematicoptimizationofsystemsoftware. ACM Transactions on Computer
Systems (TOCS) 19 ,2(2001),217–251.
[42]Molnar,D.,Li,X.C.,andWagner,D. Dynamictestgenerationtofindinteger
bugsinx86binaryLinuxprograms. In USENIXSecuritySymposium (2009),vol.9,
pp.67–82.
[43]Rastogi,V.,Davidson,D.,DeCarli,L.,Jha,S.,andMcDaniel,P. Cimplifier:
automaticallydebloatingcontainers. In Proceedingsofthe201711thJointMeeting
on Foundations of Software Engineering (FSE) (2017),ACM,pp.476–486.
[44] Salwan,J. Ropgadgettool. http://shell-storm.org/project/ROPgadget/,2012.
[45]Schilit, B. N., Theimer, M. M., and Welch, B. B. Customizing mobile ap-
plications. In Proceedings USENIX Symposium on Mobile & Location-indendent
Computing (1993),vol.9.
[46]Shacham, H. The geometry of innocent flesh on the bone: Return-into-libc
withoutfunctioncalls(onthex86). In Proceedings of the 14th ACM conference on
Computer and Communications Security (CCS) (2007),ACM,pp.552–561.
[47]Sheeran,M.,Singh,S.,andStålmarck,G. Checkingsafetypropertiesusing
induction and a sat-solver. In International Conference on Formal Methods in
Computer-aided Design (FMCAD) (2000),Springer,pp.127–144.
[48]Smowton,C.,andHand,S. Makeworld. In Proceedingsofthe13thUSENIXCon-
ferenceonHotTopicsinOperatingSystems(HotOS) (2011),USENIXAssociation,
pp.26–26.
[49]Snow,K.Z.,Monrose,F.,Davi,L.,Dmitrienko,A.,Liebchen,C.,andSadeghi,
A.-R. Just-in-timecodereuse:Ontheeffectivenessoffine-grainedaddressspace
layoutrandomization. In Proceedingsofthe2013IEEESymposiumonSecurityand
Privacy(2013),IEEE,pp.574–588.
[50]Stenberg, D. Everything curl. https://legacy.gitbook.com/book/bagder/
everything-curl/,2017.
[51]Tiwari,A.,Chen,C.,Chame,J.,Hall,M.,andHollingsworth,J.K. Ascal-
able auto-tuning framework for compiler optimization. In IEEE International
Symposium on Parallel & Distributed Processing (IPDPS) (2009),IEEE,pp.1–12.
[52]Xu,G.,Mitchell,N.,Arnold,M.,Rountev,A.,andSevitsky,G.Softwarebloat
analysis:finding,removing,andpreventingperformanceproblemsinmodern
large-scaleobject-orientedapplications. In Proceedings of the FSE/SDP Workshop
on Future of Software Engineering Research (2010),ACM,pp.421–426.
[53]Zhang,M.,andSekar,R. ControlflowintegrityforCOTSbinaries. In USENIX
Security Symposium (2013),pp.337–352.
339
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:26:52 UTC from IEEE Xplore.  Restrictions apply. 