View-Centric Performance Optimization for
Database-Backed Web Applications
Junwen Yang1, Cong Yan2, Chengcheng Wan1, Shan Lu1, Alvin Cheung2
1University of Chicago, junwen, cwan, shanlu@uchicago.edu2University of Washington, congy, akcheung@cs.washington.edu
Abstract ‚ÄîWeb developers face the stringent task of designing
informative web pages while keeping the page-load time low.
This task has become increasingly challenging as most webcontents are now generated by processing ever-growing amountof user data stored in back-end databases. It is difÔ¨Åcult fordevelopers to understand the cost of generating every web-pageelement, not to mention explore and pick the web design withthe best trade-off between performance and functionality. In thispaper, we present Panorama, a view-centric and database-awaredevelopment environment for web developers. Using database-aware program analysis and novel IDE design, Panorama pro-vides developers with intuitive information about the cost andthe performance-enhancing opportunities behind every HTMLelement, as well as suggesting various global code refactoringsthat enable developers to easily explore a wide spectrum ofperformance and functionality trade-offs.
I. I NTRODUCTION
A. Motivation
High-quality web applications need to provide both good
functionality ‚Äî informative and well-displayed web-page con-
tent, and good performance ‚Äî lower than 2 seconds of pageload time [1], with every second‚Äôs delay causing 11% fewerpage views, a 16% decrease in customer satisfaction, and 7%loss in conversions [2]. These functionality and performancerequirements are increasingly difÔ¨Åcult to satisfy simultane-
ously, as modern web-page content often requires processinga huge amount of user data to generate and the amount of userdata often increases by 10 √óper year [3]. Indeed, real-world
web developers often don‚Äôt understand the amount of dataprocessing required to render their web pages, which resultsin numerous design changes to address performance issues [4].Because of this, tools that can help developers understandperformance implications of their web-page design and exploredesigns with different performance-functionality trade-offs cangreatly improve the web development process.
To better understand the challenges faced by web de-
velopers, consider Tracks [5], a popular task-managementapplication constructed using the Ruby on Rails framework.Tracks has a todos/index page displaying all the to-do‚Äôs for
a user. At one point, users complained that this page was un-reasonably slow even though very few to-do‚Äôs were displayed[6]. After some debugging, developers turned their attentionto a sidebar on this page, which displayed all the projects theuser had been involved in. As shown in Figure 1, the view
http://hyperloop.cs.uchicago.edu/panorama

	



	

		

Fig. 1: Performance understanding challenge
Ô¨Ålesidebar.html.erb, which produces this sidebar, renders
these projects based on a Ruby variable @active projects
embedded in the HTML Ô¨Åle; this variable is computed
in a controller Ruby Ô¨Åle todos controller.rb through a
seemingly straightforward assignment @active projects =
user.projects.active. It turns out that this code actuallyretrieves objects stored in a database, and is translated intoa SQL query by the Rails framework at run time. It was thelong time taken for the database to run this query that resultedin the poor performance observed by users. After realizingthis, developers decided to remove the sidebar , and users cannow see the main content of this page, the to-do items, muchquicker.
This performance-functionality trade-off represents one of
the many challenges that web developers face:
Understanding the performance cost behind every ren-
dered web-page element is challenging for developers andrequires cross-stack knowledge as the above example shows.As shown in Figure 1, modern web pages commonly containdynamically generated contents. Consequently, the cost of aweb-page element includes not only browser rendering time,but also web server computation time and backend databaseserver processing time. As web applications are often con-structed using the Model, View, Controller [7] architecture,it is difÔ¨Åcult for users to manually search through multipleÔ¨Åles across application modules to identify code that leads toperformance issues, and it is even more difÔ¨Åcult for developersto reason about what database queries could be issued as theirapplication executes and how much data would be retrievedfrom database for rendering.
Existing proÔ¨Åling tools are insufÔ¨Åcient in aiding with this
regard. Some [8] only account for the client-side cost ofevery HTML tag, but do not account for the server-side cost;others [9] report database query cost but do not attributequeries to speciÔ¨Åc HTML tag, and hence cannot provide direct
9942019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)
1558-1225/19/$31.00 ¬©2019 IEEE
DOI 10.1109/ICSE.2019.00104
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. guidance to web-page design. Furthermore, all these proÔ¨Åling
tools rely on workloads provided by developers, and therefore
cannot help predict performance problems that manifest from
‚Äúreal-world‚Äù workloads.
Exploring the performance-functionality trade-offs
among different web-page designs is also challenging for
developers, requiring cross-module and cross-language code
refactoring. For example, to remove a web-page element, it
is insufÔ¨Åcient to just remove the corresponding HTML tag
from the view Ô¨Åle. Developers also need to check which
variables are referred to by that HTML tag, which controller
code snippets generated those variables, and whether removing
those code snippets altogether will affect other parts of the
application. In addition, there are also other web-page design
alternatives with different performance-functionality tradeoffs.
Unfortunately, most require global code restructuring and are
difÔ¨Åcult to carry out without tool support. Worse yet, recent
work on detecting and Ô¨Åxing database-related inefÔ¨Åciencies in
web applications only focuses on inefÔ¨Åcient ORM-API usage,
unnecessary data retrieval, and redundant queries [10]‚Äì[12],
and is completely oblivious to web-page designs. In short,
existing techniques do not consider performance-enhancing
opportunities that require web-page design changes (which we
refer to as view changes ), and hence cannot help developers
explore the performance-functionality trade-off space.
Indeed, empirical studies [4] have found that about a quar-
ter of real-world web application performance problems are
solved by developers through view changes, like pagination
and view content removal. These changes often bring much
more performance improvement than the view-preserving ones
(8.79√óvs 2.16√óon average) but involve more changes (2.9
Ô¨Åles vs. 1.4 Ô¨Åles). They are difÔ¨Åcult to perform manually and
having good tooling support is hence crucial.
B. Contributions
In this work, we present a framework called Panorama that
provides a view-centric and database-aware analysis for web
developers to understand and optimize their database-backed
web applications. Panorama currently targets applications writ-
ten using the Ruby on Rails framework, and makes three major
contributions as illustrated in Figure 2.
Panorama provides a view-centric estimator that helps de-
velopers understand the data-processing cost behind every
HTML tag. Panorama both dynamically monitors database
query performance using the test workload, statically esti-
mates data processing complexity independent of any speciÔ¨Åc
workload, and carefully attributes the cost to every HTML tag
through its cross-stack dependency analysis. The details will
be presented in Section IV.
Panorama provides a view-aware performance optimizer
that helps developers carry out view-changing code refactoring
to improve performance. Panorama suggests a variety of
refactorings that (1) change the manner of content rendering
(i.e., pagination or asynchronous loading); or (2) change the
accuracy of the rendered contents (i.e., approximation); or
(3) remove certain web-page contents from rendered contents.









	





	
	

Fig. 2: Panorama overview
Through static program analysis, Panorama not only identiÔ¨Åes
opportunities for applying such refactoring, but also automat-
ically suggests patches that complete such refactoring, often
involving modiÔ¨Åcations to multiple Ô¨Åles in model, view, and
controller components. We present the details in Section V.
Panorama provides a unique interface for developers to
effectively exploring different web-page designs with differ-
ent performance-functionality trade-offs. Instead of separately
presenting proÔ¨Åling information and refactoring suggestions,
Panorama integrates them in the web browser‚Äîwhile testing
a page of their web applications, the data processing cost for
each HTML tag is presented as a heat map in the browser.
Developers can right click on each HTML tag to see the dif-
ferent view-changing options for performance enhancement;
they can choose any option and immediately see an updated
web page with an updated heat map in the browser, with
all code refactoring automatically done by Panorama in an
accompanying Ruby editor.
We evaluated Panorama on 12 popular open-source Ruby
on Rails applications. Panorama statically identiÔ¨Åes 149
performance-enhancing opportunities through view changes.
We randomly sampled 15 view changes suggested by
Panorama and found that by applying the patches automat-
ically generated by Panorama, these 15 view changes speed
up end-to-end page load time by 4.5 √óon average (38 √ó
maximum), using database workloads that are similar to
those used in real-world deployments. We believe the beneÔ¨Åts
will increase with even larger workloads. Furthermore, we
conducted a thorough user study with 100 participants from
Amazon Mechanical Turk. The study shows that web pages
with these view changes are considered as similar or better
than the original web pages in most cases, with more users
preferring the design suggested by Panorama than the original
ones. This user study result, as well as the fact that these
optimizations save computation resources on web servers and
database servers, justify the need for developers to explore the
performance-functionality trade-off space in web application
design, with Panorama being a Ô¨Årst step towards that goal.
II. B ACKGROUND
Rails applications are structured based on the model-
view-controller (MVC) architecture. We illustrate this in
Figure 3. When a client requests for a URL such as
http://foo.com/projects/index/1 1/circlecopyrt,a controller ac-
tion ‚Äúprojects/index ‚Äù is triggered. This action takes in
995
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. the parameters from the request (e.g., ‚Äú 1‚Äù in the URL as
params[:id] ) and interacts with the DBMS by calling the
ActiveRecord API implemented by the Rails framework 2/circlecopyrt.
Rails translates the function calls into SQL queries 3/circlecopyrt, whose
results 4/circlecopyrtare serialized into model objects (e.g., the Project
model) and returned to the controller 5/circlecopyrt. Then, the returned
objects are passed to the view 6/circlecopyrt in order to generate a
webpage 7/circlecopyrtto send back to users 8/circlecopyrt. Each model is derived
from ActiveRecord , and is mapped to a database table by
Rails. A view Ô¨Åle (ends with .erb or.haml ) usually involves
multiple languages including html, JavaScript, and ruby. The
ruby code can dynamically generate the content of html
elements or decide which element to show.

+$%
861&**69
89867&698)9
89867&698)9
8669
#
1 7&,.%/-
171 &&!
'#(

		%%))&))#)3
  
 $

	  
   $
0 "
 +73!7 "
"
 
"    


+% 
	  , &-%
')#)(79'2#(
Fig. 3: Rails application architecture based on the MVC pattern
III. S TATIC ANALYSIS FRAMEWORK
Panorama leverages a database-aware static analysis frame-
work for Rails applications that we brieÔ¨Çy describe below.
A. Action dependency graph
Panorama‚Äôs static analysis centers around the action-
dependency graph (ADG) that is constructed for each con-
troller action. Figure 4 shows an example of ADG.
An ADG is a database-aware extension of the traditional
program-dependence graph (PDG) [13]. Every node nin the
ADG represents an intermediate representation (IR) statement
in the corresponding action‚Äôs JRuby [14] IR. Every edge
erepresents either control dependency or data dependency.
Edges shown in Figure 4 all represent data dependencies.
In contrast to the PDG, every node in the ADG that issues
a SQL query is associated with a query tag in ADG, such
as node 1/circlecopyrt and node 2/circlecopyrt in Figure 4. Information about
SQL queries that are issued and the tables they referenced
are determined by analyzing ActiveRecord function calls and
recorded in the ADG.
Since view Ô¨Åles may also contain Ruby code to process
or render data, they are also analyzed during the ADG
construction. SpeciÔ¨Åcally, for every action, like user/show in
Figure 4, its corresponding view Ô¨Åle is identiÔ¨Åed based on
an explicit render statement or implicit Ô¨Åle-name matching

					
 		! ! !			
 		!  ! !


		
	 		!  ! !  
!


 
 !
!
Fig. 4: Excerpt of an Action Dependency Graph
(as in Figure 4). The corresponding view Ô¨Åle is then parsed,
with all Ruby code embedded inside <% ...%> extracted and
inlined as part of the ADG, like the three statements inside
show.html.erb and the ADG shown in Figure 4.
B. Annotating the view component
In order for Panorama to attribute performance data cor-
rectly to each HTML tag, Panorama pre-processes every view
Ô¨Åle in the input web application to assign every HTML tag a
unique ID. That is, for every tag <tag> that does not already
have an ID, Panorama turns it into <tag id = ti> , where ti
is a unique ID, as shown in the <span> tags of Figure 4. The
current prototype of Panorama does not handle HTML tags
that are programmatically generated by JavaScript code.
As mentioned, the view Ô¨Åle has Ruby code embedded within
it. For every node in ADG whose source code is in a view
Ô¨Åle, Panorama identiÔ¨Åes its inner-most surrounding HTML tag
and associates it with the corresponding tag ID. Panorama
also checks whether its corresponding content is rendered or
not by analyzing the HTML, and assigns an isrendered
property accordingly. This information will help Panorama
attribute data processing cost to each HTML element and
identify alternative view designs, as we will explain in later
sections.
IV . P ANORAMA VIEW -CENTRIC COST ESTIMATOR
There are two key tasks in Panorama‚Äôs cost estimation. First,
given an HTML tag, Panorama determines which database
queries are executed to generate the data that is rendered
through that tag (we refer to them as contributing queries).
Second, for each HTML tag, Panorama measures the data
processing cost needed to render it.
While a web page‚Äôs load time consists of client side render-
ing time, network communication between client and server,
computation time on the server, and database query cost,
Panorama‚Äôs estimator currently focuses on database query cost,
as query time often contributes a signiÔ¨Åcant portion of the page
load time. This is particularly true as the data size increases,
and large query results lead to even more computation and
rendering time. Query time/complexity is also difÔ¨Åcult for
developers to estimate, particularly given the ORM abstraction.
As future work, we will incorporate other proÔ¨Åling tools to
measure the performance of the client code [8], network, and
server computation as part of Panorama.
996
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. A. Identifying contributing queries
Panorama identiÔ¨Åes contributing queries for an HTML tag
by statically analyzing control and data dependencies in the
ADG. Given an HTML tag in a view Ô¨Åle, Panorama Ô¨Årst
identiÔ¨Åes all ADG nodes Nthat contain the tag‚Äôs unique ID
‚Äî these nodes contain the Ruby code embedded in the HTML
tag. Then, Panorama traces backward along the ADG edges
to identify all query nodes that any node in Nhas control or
data dependence upon. All these queries, each identiÔ¨Åed by its
ADG node ID and Ruby source code location, are considered
as contributing queries of this HTML tag. For example, in
Figure 4, tracing dependency edges backward from node 3/circlecopyrt,
which corresponds to HTML tag with id ti1, will identify
two contributing queries, nodes 1/circlecopyrtand 2/circlecopyrt.
Panorama further conducts forward dependency checking
in the ADG to see how many other HTML tags each query
node contributes to. This number can be used as a weight
in computing the data processing cost of an HTML tag ‚Äî
if a query result is used to generate kHTML tags (e.g., the
query node 1/circlecopyrtcontributes to three HTML tags in Figure 4),
we could attribute 1/kof the query cost to each HTML tag
if the web developers choose so (while by default Panorama
attributes the complete query cost to each tag).
B. Cost analysis
Panorama offers two modes of cost estimation with or
without relying on testing workload.
1) Dynamic proÔ¨Åling: If a testing workload is available,
Panorama will measure the cost of each contributing query
during a testing run. However, using the query execution log
from the backend database engine as the testing workload does
not work ‚Äî the database engine has no knowledge about
frontend Ruby and HTML code, and hence does not allow
Panorama to connect the statement in the web application that
issues the query and the HTML tag uses the query result.
Panorama instead conducts its proÔ¨Åling through a hook API
provided by Rails infrastructure, ActiveRecordQueryTrace .
This API allows its hooked code to be called before and after
issuing each SQL query. Using this mechanism, Panorama logs
the amount of time of each query and the line of source code
that issues this query during the testing run, and attributes the
time to the corresponding HTML tags using contributing query
analysis as discussed above.
2) Static estimation: Since a bottleneck-exposing workload
may not be available during in-house testing, Panorama also
uses static analysis to estimate the potential data-processing
cost (in terms of its data complexity) to render each HTML
tag. For ease of estimation, Panorama assumes that all tables
in the database have the same size D. Then, for each con-
tributing query, Panorama estimates its complexity (i.e., how
its execution time might increase with D) by considering: (1)
the number of times this query might be issued, and (2) time
taken to execute one query instance.
To estimate the Ô¨Årst factor, Panorama analyzes loops. If the
query Qis not contained in any loop or is only contained by a
loop whose iteration number does not increase with D, whichwe refer to as a bounded loop , Panorama then considers Q
to be executed for a constant number of times. Otherwise,
Panorama considers Qto be executed for Dktimes, with
kbeing the number of unbounded loops containing Q.T o
identify the unbounded loops, Panorama analyzes the bound
variable of all loops that contain Q. If the loop iterates through
a set of records returned by an unbounded database query,
Panorama considers the loop to be unbounded. SpeciÔ¨Åcally,
in Rails, a query is unbounded in all but the following three
cases: (1) it always returns a single value, like a SUM query;
(2) it always returns a single record by selecting on primary
key; (3) it always returns a bounded number of records using
theLIMIT keyword.
To estimate the second factor, Panorama Ô¨Årst identiÔ¨Åes all
the query operators inside the query Q. For example, for
the query node 2/circlecopyrt in Figure 4, Panorama would identify
three query operators from the @user.issues.active.count
statement: a SELECT to get issues , another SELECT to get
active , and Ô¨Ånally a count operator. For most operators, we
estimate its execution complexity to be O(D). There are a few
exceptions: we consider the complexity of a JOIN operator to
beO(D2), and the complexity of an operator that explicitly
uses index, such as find andfind byid, to be constant.
Putting these two factors together gives Panorama the com-
plexity estimation for one contributing query Q. For example,
the estimated complexity of the query node 2/circlecopyrtin Figure 4 is
O(D3). If it is enclosed in an unbounded loop, its complexity
would increase to O( D4).
Panorama could choose to deliver the above performance
information using either a detailed text description or a nu-
meric score. The current prototype uses the latter: it uses
the highest complexity among all contributing queries as the
complexity score of an HTML tag. For example, in Figure
4, the complexity score of HTML node 3/circlecopyrtis 3, based on
the O( D3) complexity estimated for query node 2/circlecopyrt, and the
complexity scores of HTML node 4/circlecopyrtand 5/circlecopyrtare both 1, based
on the O( D) complexity estimated for query node 1/circlecopyrt.
Of course, this is just a best-effort estimation from
Panorama. There are several potential sources of inaccuracy
that can be improved by future work. For example, some
database tables may be much larger than others, which we do
not consider; the database can also lower the query complexity
than our estimation due to query optimization.
V. P ANORAMA VIEW -AW ARE OPTIMIZATION
Panorama suggests three categories of view-changing code
refactoring to improve page-load time:
1) Display the same contents in a different style, such as
pagination and asynchronous loading.
2) Display the same contents but with a different accuracy.
3) Remove a subset of contents from display.
These code refactorings can be applied for different types
of HTML tags, and complement each other.
Panorama code refactoring works independently from
Panorama cost estimator. As we will see in Section VI,
997
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. ! &##'&# #'
"$&#%	

	  #' &#%	 #'
	
  $	%'%




"$ %'!!$
Fig. 5: Refactoring so that the paginated page displays 30 items at
a time rather than the full list
Panorama interface will contain both features and help de-
velopers make informed refactoring decisions.
A. Display-style change: pagination
Many web pages are designed to display alldatabase
records satisfying certain conditions. When the database size
grows, such pages will take an increasingly more time to load,
and eventually become unresponsive.
A widely used solution to this problem, called pagination ,
is to display only a Ô¨Åxed number of records in a page and
allow users to navigate to other pages for more records.
Although pagination is widely used in practice, there are
still many cases where it is not used ‚Äî 14 out of 140 real-
world performance issues sampled by a previous study [4] are
due to lack of pagination ‚Äî either because developers are
unaware of pagination, or because they did not anticipate the
data size will become a performance problem. Therefore, we
design Panorama to automatically identify pagination opportu-
nities and conduct corresponding refactoring for developers.
1) Identifying opportunities: To identify these opportuni-
ties, Panorama checks each loop in the program for: (1)
whether the loop iterates through the result of an unbounded
query; and (2) whether each loop iteration leads to some
content being rendered in an HTML tag. If a loop passes both
checks, the corresponding HTML tag will be reported as a
pagination candidate.
For the Ô¨Årst check, Panorama locates the array variable that
a loop iterates through, like @products in the loop shown in
the left column of Figure 5, and then checks the data-Ô¨Çow
edges in ADG to determine whether this variable is produced
by an unbounded database query, as deÔ¨Åned in Section IV-B2.
For example, the ADG would show that @products is the
result of Product.all on Line 1 of in Figure 5b, and
Product.all will be translated to an unbounded database
query at run time.
For the second check, Panorama searches for an ADG node
nvthat is associated with an HTML tag and an isrendered
property inside the loop body (how to compute isrendered
is introduced in Sec. III-B). If nvis found, like Line 2 in
Figure 5a, the HTML tag associated with nvis identiÔ¨Åed as
a pagination candidate.
2) Generating patches: To carry out the refactoring,
Panorama performs two changes to the source code using the
will paginate library [15]. First, in the controller, Panorama
adds a .paginate call right after the code statement where the
to-be-rendered database records are retrieved, like Line 2, 3
and 4 in Figure 5b. The constant there, which is conÔ¨Ågurable
and 30by default, determines how many records will be
shown on every page. Second, in view, Panorama adds a <=%will paginate @products %> statement right after the loop
that renders these database records, as illustrated in Line 5 in
Figure 5a. The will paginate call inserts a page navigation
bar into the web page, allowing users to navigate to remaining
records after seeing the records displayed on the current page.
B. Display-style change: asynch-loading
Asynchronous programming is widely used to support low-
latency interactive software [16]‚Äì[18]. For web applications,
when there is an HTML tag that takes much longer time
to render than other tags on the same page, we can instead
compute and render the slow tag asynchronously, allowing
users to see other parts of the web page more quickly.
For example, Discourse is a forum application. Its
topics/show page mainly lists all the posts that belong to
a topic. At the bottom of that page after the listing of all the
posts , a list of suggested topics that are related to this
topic are displayed. In an issue [19], users complained that
this page is slow to load no matter a topic contains many or
few posts. Developers then realized that the query to retrieve
suggested topics is hurting the page-load time. Making things
worse, these suggested topics are not the main interests of this
page and often are not seen by users, as they are placed below
all the posts and require users to scroll down to the bottom
of the page to see. Consequently, developers created a patch
that defers the display of suggested topics until all other
content on the page is displayed.
1) Identifying opportunities: Conceptually, every HTML
tag can be computed and rendered asynchronously. We only
need to pay attention to two issues.
First, only tags that are among the slowest on a web page
are worthwhile for asynchronous loading. Otherwise, loading
an originally fast tag asynchronously does not help shorten the
page load time, the Panorama estimator (Section IV) already
provides information to help developers make this decision,
and hence we do not discuss this issue below.
Second, if too many HTML tags on a web page are rendered
asynchronously, the user experience could be greatly degraded.
Furthermore, if one HTML tag is rendered asynchronously,
other HTML tags may better be rendered asynchronously too
if they share a common contributing query. For example,
in Figure 4, once we decide to load HTML tag 3/circlecopyrtasyn-
chronously, 4/circlecopyrtand 5/circlecopyrtwill be loaded asynchronously too, as
they share a common query 2/circlecopyrt. Panorama considers this issue
in identifying opportunities for asynchronous loading, and we
will describe how this is handled below.
2) Generating patches: Given an HTML tag e, making
its content computed and rendered asynchronously requires
multiple changes to the controller and view components of a
web application, as illustrated in Figure 6: (1) creating a new
view Ô¨Åle that renders eonly, separating efrom other tags on
the same web page that will still be synchronously loaded;
(2) adding a new controller action to compute all and only
the content needed by eand render the new view Ô¨Åle created
above, separated from the computation for other tags on the
same web page that will still be carried out synchronously;
998
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply.  ! ! !
	 
   !	
	 	
	
!							 
	

! 
	
  	!
 ! ! !
Fig. 6: Refactoring for asynchronous loading
(3) replacing ein the original view Ô¨Åle with an AJAX request
and adding a new routing rule so that the AJAX request will
invoke the new action in (2) which then renders the view in
(1) asynchronously.
The Ô¨Årst item is straight-forward to automate. Panorama
simply moves the HTML tag einto a newly created view
Ô¨Åle, like iss cnt.html.erb (Figure 6(1)), where iss cnt
corresponds to the name of the new controller action that
Panorama will generate.
The second item is implemented by Panorama in three steps.
It Ô¨Årst identiÔ¨Åes all Ruby variables used by e, like @count in
Figure 6(1), and then applies static backward slicing to Ô¨Ånd all
code statements Cthat are used to compute those variables,
like @count = @user.issues.active.count in Figure 6.
SpeciÔ¨Åcally, Panorama starts from all the ADG nodes asso-
ciated with the speciÔ¨Åc HTML-tag ID, and traces backwards
in the ADG to identify all nodes inside the corresponding
controller that ehas control or data dependence on.
Panorama next applies forward taint analysis to see if any
statement c‚ààCis used to compute any other HTML tag
e/prime. If such an e/primeis found, there is a dilemma about whether
to render e/primeasynchronously: rendering e/primeasynchronously
could potentially cause many other HTML tags, which share
common backward slicing fragments with e/prime, to be rendered
asynchronously, and violate the design principle discussed in
Section V-B1; yet rendering e/primesynchronously incurs extra
overhead as cnow needs to be computed twice, once for e
and once for e/prime. Hence, Panorama currently considers eas
unsuitable for asynchronous loading if e/primeexists.
Panorama Ô¨Ånally moves the slice identiÔ¨Åed earlier to a new
controller action, like iss cnt in Figure 6(2) (the deletion
from the previous controller is not shown for simplicity), and
add a rendering statement at the end of the action, like render
:partial => ‚Äòiss cnt‚Äô in Figure 6(2), to render the same
content in the same format as the original web application
using the newly created view Ô¨Åle.
Panorama conducts the third item leveraging the
render sync library [20] to replace the original HTML tag
with ‚Äú <%= render async [action] path %> ‚Äù (Figure
6(3)), where render async is an API call that issues an
AJAX request for the speciÔ¨Åed action using jQuery [21].
Panorama then adds a new rule into the routing Ô¨Åle to connect
the AJAX request with the action it just created. As shown in
Figure 6(4), this new routing rule follows the template ‚Äú get
:[action], :controller = >:[home] ‚Äù, where action is
the name of new action name, and home is the controller
holding the action . !"! "!"
	

 	
  	
	

	
	

!"! " "!"
Fig. 7: Refactoring for approximation
C. Display-accuracy change: approximation
Approximation is a widely used approach to improving
performance and saving server resources [22]. Past database
research also proposed approximated queries [23]. However,
many techniques require changes to database engines [24]
and hence cannot be applied to web application refactor-
ing. Panorama focuses on approximating aggregation queries
whose results are displayed as numeric values on web pages,
as such approximation can be simply conducted by refactoring
Rails code and easily reasoned about by web viewers.
For example, Redmine [25] is a project collaboration ap-
plication like GitHub. Its user/index page lists all the recent
activities of a user, all projects a user is involved in (with
pagination), as well as two counts showing how many issues
are currently assigned to and have been reported by this user.
Although these two numerical counts occupy tiny space on the
web page, they can take more time, even more than 1 second,
to render than the remaining page, when a user is involved
in hundreds of or more issues. One way to keep the page
responsive is to set an upper-bound to such a count, like 100,
and only shows the count to be ‚Äú more than 100 ‚Äù when it is
too big ‚Äî when a count is too big, users probably does not
care about the exact number anyway.
1) Identifying opportunities: Panorama iterates through all
aggregation, including maximum, minimum, average, and
count, queries in the application. For each query, Panorama
checks its corresponding ADG node‚Äôs out-going data-Ô¨Çow
edges to see if the query result is only used in HTML-tag
rendering. If so, an approximation opportunity is identiÔ¨Åed
for corresponding HTML tag(s). Note that, Panorama does
not suggest approximating an aggregation query if its result
affects an HTML tag through control dependency, as that
type of approximation may cause program execution to take
a different path and hence potentially leads to large deviation
from original program behaviors.
2) Generating patches: An approximation refactoring in-
cludes two parts. On the controller side, Panorama appends a
limit(N) clause to the end of the aggregation query identiÔ¨Åed
above, with the constant NconÔ¨Ågured by web developers.
On the view side, instead of directly displaying the numeric
query result, changes are made depending on the aggregation
query type. For a count query, Panorama inserts a conditional
statement to check the aggregation result: if the result is
smaller than Nthen the accurate numerical result is displayed,
otherwise ‚Äúmore than N‚àí1‚Äù, as shown in Figure 7; for an
average query, Panorama adds ‚Äú about ‚Äù before the numeric
query result rendered in the HTML tag; for a maximum or
999
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. !	
  	
 # 


  
	
 
	
!  $	% $"	
 "%
 $"#		 "%
 $"#	 "% $		#	%
  $" "%
Fig. 8: code change for removing
minimum query, Panorama adds ‚Äú at least ‚Äùo r‚Äú at most ‚Äù
before the numeric query result.
D. Display contents removal
Obviously, one can remove an HTML tag to speed up the
page loading. This strategy is indeed used in practice, as the
Tracks example discussed in Section I. Whether an HTML tag
is worthwhile to display cannot be determined automatically.
Instead, what Panorama can do is to make the removal easy
and error-free, so that developers can easily try out different
design options and eventually make an informed decision.
1) Identifying opportunities: Removing an HTML tag e
does not guarantee to save page-loading time, because if the
expensive computation needed by eis also needed by other
HTML tags, removing ealone will not help performance
much. The current prototype of Panorama only suggests re-
moving an HTML tag eif its contributing query that is not fed
to any other HTML tag. This way, removing ecan guarantee
to save some data-processing time. Of course, future work can
relax this checking criterion.
2) Generating patches: Removing an HTML tag efrom the
web page again involves changes to both the view component
and the controller component of a web application. On the
view side, Panorama simply removes the speciÔ¨Åc HTML
tag. On the controller side, Panorama again analyzes control-
dependency and data-dependency graph to remove code that
was used only to help generate e.
To do so, Panorama Ô¨Årst identiÔ¨Åes all the nodes in ADG
that are associated with e‚Äôs ID. Panorama deletes those nodes,
removes all condition checking whose two branches now
execute exactly the same code because of those node deletions,
and then check if there are any other ADG nodes that become
useless and should be deleted ‚Äî a node is useless if it has
no out-going data-dependency or control-dependency edges.
Panorama repeats this process for several rounds until no more
nodes are identiÔ¨Åed as useless.
We use the view Ô¨Åle code snippet in Figure 8a as an exam-
ple. The HTML tag shown here corresponds to the sidebar that
lists all projects in the Tracks example discussed in Figure 1.
Given this tag, Panorama Ô¨Årst identiÔ¨Åes the Ruby expression
@active projects , and then checks the ADG to see how
@active projects is computed in the controller (Figure 8b).
Panorama also Ô¨Ånds out that the @active projects com-
puted in Figure 8b is not used in anywhere else. Consequently,
the content-removal change will simply delete the sidebar tag
in the view Ô¨Åle and the corresponding computation in the
controller Ô¨Åle, as shown in Figure 8.
Fig. 9: An example of Panorama browser interface
VI. T HEPANORAMA INTERFACE
Panorama comes with a new interface to present the cost
estimation and optimization information, and help developers
explore different web-page design options. We discuss the
Panorama interface in this section.
A. Information display in browser
Showing view-centric cost estimation information.
Panorama visualizes the performance information obtained by
dynamic proÔ¨Åling or static estimation (Section IV) through a
heat-map with the more costly HTML element having a more
red-ish background, as illustrated in Figure 9.
To generate this heat map, Panorama reads the output
of its view-centric cost estimation (Section IV) and
creates a JavaScript Ô¨Åle interactive.js that sets
the background color of every HTML tag through
‚Äú$(tag-id).css(‚Äò‚Äòbackground-color‚Äô‚Äô, color); ‚Äù,
where tag-id is the unique HTML tag ID and color is
computed based on the cost estimation for this HTML tag
(Section IV). Web developers can choose to see different
heat-maps with buttons on the web page, like ‚ÄúReal-time‚Äù
(dynamic proÔ¨Åling results) and ‚ÄúRelative‚Äù (statically estimated
results) in Figure 9. We set the color using the HSL color
scheme, with more expensive tags rendered with smaller hue
values (i.e., more red-ish) and cheaper tags with larger hue
values (i.e., more blue-ish).
Showing view-aware optimization suggestions.
interactive.js described above helps display not only
data-processing cost but also alternative view-design options
for various HTML tags. Users simply right click an HTML
tag in the browser to get a list of design options, as shown in
Figure 9. The implementation is straight-forward, given the
unique ID of every HTML tag and the performance-enhancing
1000
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 
	



 	
	 			 

Fig. 10: Panorama interface implementation
opportunities identiÔ¨Åed through Panorama static analysis as
discussed in Section V.
B. Design-space exploration in browser
To help developers explore different performance‚Äì
functionality design trade-offs, Panorama further connects
the browser-side information display and the Ruby editor
side refactoring together: (1) developers Ô¨Årst understand the
data-processing cost of various HTML tags in the browser;
(2) once developers choose an alternative design option for
an HTML tag, the corresponding code refactoring will be
automatically applied and displayed in the accompanying
Ruby editor for developers to review; (3) once the source
code is updated, the heat-map in the browser is updated
accordingly. Developers can explore different design options,
and eventually pick the best ones that suit their need.
To support this interface, Panorama carefully uses
JavaScript, IDE plugin, and other mechanisms to help the
communication between the browser and the Ruby editor, as
illustrated in Figure 10.1
First, Panorama automatically instruments the web appli-
cation under development to help communicate developers‚Äô
design choices to the Ruby editor. SpeciÔ¨Åcally, Panorama
adds a controller PANO handle request into the web
application. Whenever developers click a design-option button,
like one of those blue paginate ,async ,approximate ,remove
buttons in Figure 9, Panorama will send an HTTP request
to invoke the PANO handle request controller action ( 1/circlecopyrt
in Figure 10), which then records the design-option type and
the corresponding HTML tag ID into a web-server side Ô¨Åle
request.log (2/circlecopyrtin Figure 10).
In the editor, which we use RubyMine [26], Panorama uses
a thread to monitor the request.log Ô¨Åle. Whenever this Ô¨Åle
is changed, this monitoring thread will trigger the plugin to
apply corresponding code refactoring in the IDE, with all the
code changes generated using algorithms described in Section
V( 3/circlecopyrtin Figure 10).
After the code change, the data-processing cost estima-
tion will be updated automatically, which results in up-
dates to a performance proÔ¨Åle and corresponding updates to
interactive.js with changed background-color settings ( 4/circlecopyrt
in Figure 10). The changes in interactive.js lead to an
automated refresh in the browser with the updated heat-map
1The current prototype of Panorama assumes that the web-application under
testing is deployed on the same machine as the Ruby editor.TABLE I: Opportunities detected by Panorama in 12 apps
App Ds Lo Gi Re Sp Ro Fu Tr Da On FF OS SUM
pagi. 1 6 1 10 2 20 5 9 1 6 3 3 69
approx. 110705130 2 30 0 4 3
remo v a l12070412220 0 2 2
asynch 12020212220 0 1 5
SUM 4 11 1 26 2 31 8 16 5 33 3 3 149
display, as we use the Ruby react-rails-hot-loader to
enable automated refresh at every change in the Ruby source
code or heat-map display code ( 5/circlecopyrtin Figure 10).
VII. E V ALUATION
Our evaluation focuses on three research questions: RQ1 :
Can Panorama identify view-aware optimization opportunities
from latest versions of popular web applications? RQ2 :H o w
much performance beneÔ¨Åts can view-aware optimization pro-
vide? RQ3 : Is the performance-functionality trade-off space
exposed by Panorama worthwhile for developers to explore?
RQ4 : Does Panorama estimator estimate the per-tag data-
processing cost accurately?
A. Methodology
Applications. We evaluate Panorama using a suite of 12
open-source Ruby on Rails applications, including top 2 most
popular Ruby applications from 6 major categories of web
applications on GitHub: Discourse (Ds) and Lobster (Lo)
are forums; Gitlab (Gi) and Redmine (Re) are collaboration
applications; Spree (Sp) and Ror ecommerce (Ro) are E-
commerce applications; Fulcrum (Fu) and Tracks (Tr) are
Task-management applications; Diaspora (Da) and Onebody
(On) are social network applications; OpenStreetmap (OS) and
FallingFruit (FF) are map applications. They have all been
actively developed for years, with hundreds to tens of hundreds
of code commits.
Workload. Since we cannot obtain real-world user data,
we use synthetic data generation scripts released by previous
work that to populate the databases following real-world data
distribution and statistics. Similar to [4], we use the number
of records in a web application‚Äôs main database table to
describe the workload size. By default, we use a 20,000-record
workload unless otherwise speciÔ¨Åed. To our best knowledge,
allthe database sizes used in our evaluation are similar or
smaller than the sizes in real-world web applications.
Platform. We proÔ¨Åle the Rails applications on AWS Cloud9
platform [27], which has 2.5GB RAM and a 8-core CPU.
B. RQ1: how many opportunities does Panorama identify?
As shown in Table I, Panorama can indeed identify many
view-aware optimization opportunities. SpeciÔ¨Åcally, Panorama
static analysis identiÔ¨Åes 149 performance-enhancing opportu-
nities from the current versions of our benchmark applications.
Every type of optimization opportunities is identiÔ¨Åed from at
least 8 applications.
These 149 opportunities apply to 119 unique HTML tags.
For 101 HTML tags, only one view-change suggestion is
1001
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. TABLE II: Speed up of 15 view changes
Pagination Asynchronous Approximation Content Removal
ID Ro1 Tr1 Fu1 Re2 On1 Re1 Lo2 On5 Re2 On2 Tr2 On3 Lo1 Re3 On4
Server Time Speedup (X) 19.4 13.5 6.8 4.7 2.1 1.8 37.8 1.1 2.1 1.4 1.2 1.3 33 1.4 1.1
Server Time Speedup (X) 9.4 9.2 5.9 3.6 2.7 1.6 17.2 1.2 1.6 1.3 1.2 1 8.7 1.3 1.2
Every case is denoted by <application-short-name >-ID
TABLE III: Database sizes and page load time of 12 user-study cases
Pagination Asynchronous Approximation Content Removal
ID Re1 Ro1 Tr4 Re4 Tr3 Lo1 Re2 Tr1 Di1 Lo2 Tr5 Tr6
DB Size (k-record) 2 0.8 2 2 2 20 100 100 100 20 100 2
Base Page Load Time (s) 2 1.9 2.5 2 1.9 1.8 2.5 2.5 2.5 1.8 2.5 1.9
New Page Load Time (s) 0.5 0.4 1 0.5 0.4 0.3 1 1 1 0.3 1 0.4
3 red IDs are cases from existing issue-tracking systems; the other 9 cases are all in latest versions discovered by Panorama.
Every case is denoted in the same way as Table II, with 6 common cases.
made. For the remaining 18, Panorama suggests two or three
changes. Particularly, there are 15 HTML tags where removal
and asynchronous loading both apply. Overall, these four types
well complement each other.
C. RQ2: how much performance beneÔ¨Åts?
To quantitatively measure the performance beneÔ¨Åts of these
alternative view designs, we randomly sampled 15 optimiza-
tion opportunities identiÔ¨Åed above, with 6, 2, 4, and 3 cases
from Pagination, Asynchronous (loading), Approximation, and
Content Removal respectively, in 6 different applications.
For each application, before and after optimization, we run
a Chrome-based crawler that visits links randomly for 2 hours
and measure the average end-to-end-latency and server-cost of
every action. We then compute speedup accordingly.
As shown in Table II, the performance beneÔ¨Åts of these
view changes are signiÔ¨Åcant. By changing only one HTML
tag, these 15 cases on average achieve 8.6 √óspeed up on the
server side and 4.5 √óspeed up for end-to-end page load time.
Among the four optimization types, pagination ,asynchronous
loading, and content removal have cases where the end-to-end
page load time achieves about or more than 10 √óspeedup.
D. RQ3: are alternate view designs worthwhile?
We evaluate the quality of a web page from two aspects:
(1) how much users like the performance and functionality of
a web page; (2) how much resources are needed to generate
the page on the server side.
Allfour types of view changes suggested by Panorama can
help save server resources ‚Äî pagination ,approximation , and
content removal all reduce tasks that need to be done by web
and database servers; asynchronous loading provides more
scheduling Ô¨Çexibility to servers.
Therefore, we believe an alternative web design is worth-
while for developers to explore, as long as users feel pages
under this new design is not worse than the original one. To
evaluate this, we conduct a thorough user study.
1) User study set-up: We recruited 100 participants on
Amazon Mechanical Turk (Mturk). These participants are allmore than 18 years old and living in the United States, with
more than 95% MTurk Task Approval rate.
Our benchmark suite includes 12 web pages from 5 web
applications. For each of these 12 baseline pages, Panorama
automatically generates a new page with exactly one HTML
tag changed. We refer to the original page as Base and the one
optimized by Panorama as New . These 12 web pages cover all
four types of view changes, with exactly 3 cases in each type.
Furthermore, for every change type2, we cover one case from
on-line issue reports ‚Äî these changes were already adopted by
developers to Ô¨Åx performance problems in previous versions
of web applications, and some cases discovered by Panorama
in current versions of these applications. We also reuse cases
from Table II as much as we can.
Since the performance advantage of New pages depends
on the database size, to ease comparison, we populate the
database for each benchmark so that the load-time difference
between the Base version and the New version is exactly 1.5
seconds. The detail settings are shown in Table III.
Each participant is assigned 8 tasks. In each task, they are
asked to click two links one by one, and then answer questions
about (1) which page they think is faster (‚ÄúPerformance‚Äù in
Table IV); (2) which page they think delivers more or better
organized content (‚ÄúFunctionality‚Äù in Table IV); and (3) which
page do they like more with everything considered (‚ÄúOverall‚Äù
in Table IV). These two links are the Base and New versions
of one benchmark, with random ordering between them.
2) User study results: A summary of the user study results
is shown in Table IV, and the questionnaire and raw data are
available on Panorama webpage [28]. In this table, we show
the percentage of users who think New is better minus those
who think Base is better, which we refer to as the netbeneÔ¨Åt
of the new design, for every type of refactoring and every
question (Performance, Functionality, and Overall). Users are
given the two pages in random order, and are not aware of the
view-design difference between the two pages in advance.
A short answer to our research question is ‚ÄúYes‚Äù. In fact,
2Except for approximation, as we did not Ô¨Ånd performance issue reports in
these 12 web applications that are solved by approximation.
1002
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. TABLE IV: Net user perception enhancement by New design
(% users who prefer New ‚àí% users who prefer Base )
Approximation Asynch Paginate Removal
Performance 23.50% 31.00% 45.00% 35.50%
Functionality -7.50% 17.50% -13.00% 5.50%
Overall 1.00% 18.50% 28.00% 10.50%
for all type of view-changing optimization, users think the
New design is not worse than the Base design. Particularly,
for asynchronous loading, pagination , and removal , the new
designs clearly win more users than the baseline designs.
In terms of performance, the net win for the New design is
clear. Many users indeed notice the 1.5-second difference in
the page-load time. In 10 out of 12 cases, the New design has
a net positive beneÔ¨Åt on more than 30% of the participants.
In terms of functionality, the results are quite interesting.
For approximation and pagination , many users did notice the
content difference, leading to the Base design winning about
10% of users. However, for asynchronous loading and content
removal , surprisingly, many users neither notice the content
difference nor think New design delivers worse contents. It
could be that removing contents made the page cleaner to
some users. For example, after removing the sidebar in Tracks
(Tr5 in Table III ), some participants like it because ‚ÄúAdding
the sidebar makes scrolling harder.‚Äù
In terms of overall perception, the New design has a net
win. Among the four types of optimizations, paginations and
asynchronous loading are the most appealing to users, while
approximation is the least appealing.
We also conducted another set of user study with an-
other 100 participants, where we use an even larger (2-10 √ó)
database size and hence make the page-load time differences
between New design and Base design even bigger (3 seconds).
We do observe that more participants noticed the performance
advantage of the New design. However, we also observe that
the overall perception only goes up a little bit more for the
New design. We skip the details for the space constraints.
E. RQ4: how accurate is the Panorama estimator?
We use the web page shown in Figure 9 as a case study.
15 HTML tags on this page render dynamically generated
contents. With 200 database records, dynamic proÔ¨Åling shows
that the story tag is the top performance bottleneck, followed
by the guideline tag and then the message-count the cheapest.
When the workload increases to 2000 and 20000 records,
dynamic proÔ¨Åling shows that the guideline tag is the top
bottleneck, followed by the story tag. These results match the
performance gains we can get by optimizing these three tags:
using 20000 records, asynchronously loading or removing the
guideline text can reduce the page end-to-end load time by
more than 1 second; paginating the story-tag can speed up the
page load time by about 100 milliseconds; approximating the
message count does not change page load time.
The static mode of Panorama estimator can indeed predict
performance bottleneck without running the application ‚Äî the
guideline text gets the highest complexity score (5) among all15 tags, followed by the story tag (4), and then the message-
count tag (3), with the remaining 12 tags getting 0 points.
F . Threats to validity
Threats to the validity of our work could come from
multiple sources. Internal Validity : The HTML tags that
are dynamically generated through JavaScript can not be
detected or analyzed by Panorama. External Validity : The
12 applications in our benchmark suite may not represent all
real-world applications; The synthesized databases may not
represent real-world workloads; The machine and network
settings of our proÔ¨Åling may differ from real users setting;
the 100 participants of our user-study from MTurk may not
represent all real-world users. Overall, we have tried our best
to conduct an unbiased study.
VIII. R ELATED WORK
a) ORM performance problems :Much previous work
aimed to identify speciÔ¨Åc performance problems of web ap-
plications built with ORM framework, like unnecessary data
retrieval in applications [11], anti-patterns like the so-called
‚ÄúN+1‚Äù query problem [29], sub-optimal database physical
design [30], computation that is more efÔ¨Åcient to compute
inside the database [31]‚Äì[35], and general database-aware
data-Ô¨Çow optimization [12]. However, all prior work focuses
on view-preserving optimization that does not change web
page design. We instead show that by changing the view
design, there are many performance enhancing opportunities
and we build Panorama to interactively help developers make
such design-performance trade-off decisions.
b) Detecting and Ô¨Åxing performance bugs :Plenty of re-
search [36]‚Äì[43] aims to detect and Ô¨Åx performance problems
of general purpose software, such as loop inefÔ¨Åciency, tempo-
rary object bloating, inefÔ¨Åcient data structure, etc. Detecting
and Ô¨Åxing performance bugs of cross-stack web applications
built upon ORM frameworks requires different techniques.
IX. C ONCLUSION
It is increasingly challenging to develop web applications
that can deliver both good functionality and desired perfor-
mance. We present Panorama, a tool that helps web devel-
opers explore the performance-functionality trade-off space
in their web application design. The Panorama estimator
provides developers with data-processing cost information for
every HTML tag that renders dynamically generated data,
while the Panorama optimizer identiÔ¨Åes and automates view-
changing refactoring that can greatly improve performance.
The Panorama interface integrates estimator and optimizer
together to enable effective web application design.
X. A CKNOWLEDGEMENT
This work is supported in part by the NSF through
grants CCF-1837120, CNS-1764039, 1563956, 1514256, IIS-
1546543, 1546083, 1651489, OAC-1739419; DARPA award
FA8750-16-2-0032; DOE award DE-SC0016260; the Intel-
NSF CAPA center; gifts from Adobe, Google, Huawei, and
CERES research center for Unstoppable Computing.
1003
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] F. F.-H. Nah, ‚ÄúA study on tolerable waiting time: how long are web
users willing to wait?‚Äù Behaviour & Information Technology , pp. 153‚Äì
163, 2004.
[2] ‚ÄúSpeed is a killer,‚Äù https://blog.kissmetrics.com/speed-is-a-killer/.
[3] ‚ÄúStartup = growth,‚Äù http://paulgraham.com/growth.html.
[4] J. Yang, P. Subramaniam, S. Lu, C. Yan, and A. Cheung, ‚ÄúHow not to
structure your database-backed web applications: a study of performance
bugs in the wild,‚Äù in ICSE , 2018, pp. 800‚Äì810.
[5] ‚Äútracks, a task management application,‚Äù
https://github.com/TracksApp/tracks/.
[6] ‚Äútracks-870,‚Äù https://github.com/TracksApp/tracks/issues/870/.
[7] T. Reenskaug and J. Coplien, ‚ÄúMore deeply, the framework exists to
separate the representation of information from user interaction,‚Äù The
DCI Architecture: A New Vision of Object-Oriented Programming , 2013.
[8] ‚Äúchrome development tool,‚Äù
https://developers.google.com/web/tools/chrome-devtools/evaluate-
performance/reference.
[9] ‚Äúactive record query trace,‚Äù
https://github.com/ruckus/active-record-query-trace.
[10] M. Selakovic and M. Pradel., ‚ÄúPerformance issues and optimizations in
javascript: an empirical study,‚Äù in ICSE , 2016, pp. 61‚Äì72.
[11] T.-H. Chen, W. Shang, Z. M. Jiang, A. E. Hassan, M. Nasser, and
P. Flora, ‚ÄúFinding and evaluating the performance impact of redundant
data access for applications that are developed using object-relational
mapping frameworks.‚Äù in ICSE , 2016, pp. 1148‚Äì1161.
[12] J. Yang, P. Subramaniam, S. Lu, C. Yan, and A. Cheung, ‚ÄúPowerstation:
Automatically detecting and Ô¨Åxing inefÔ¨Åciencies of database-backed web
applications in ide,‚Äù in FSE, 2018.
[13] J. Ferrante, K. J. Ottenstein, and J. D. Warren, ‚ÄúThe program dependence
graph and its use in optimization,‚Äù ACM Transactions on Programming
Languages and Systems (TOPLAS) , vol. 9, no. 3, pp. 319‚Äì349, 1987.
[14] ‚ÄúJruby,‚Äù https://github.com/jruby/jruby.
[15] ‚Äúwill-paginate tool package,‚Äù
https://github.com/mislav/will-paginate.
[16] S. Okur, D. L. Hartveld, D. Dig, and A. v. Deursen, ‚ÄúA study and
toolkit for asynchronous programming in c,‚Äù in Proceedings of the 36th
International Conference on Software Engineering . ACM, 2014, pp.
1117‚Äì1127.
[17] S. Okur, D. Dig, Y . Lin et al. , ‚ÄúStudy and refactoring of android
asynchronous programming,‚Äù 2015.
[18] Y . Lin, C. Radoi, and D. Dig, ‚ÄúRetroÔ¨Åtting concurrency for android
applications through refactoring,‚Äù in Proceedings of the 22nd ACM
SIGSOFT International Symposium on F oundations of Software Engi-
neering . ACM, 2014, pp. 341‚Äì352.
[19] ‚ÄúDiscourse-4663 issue report,‚Äù
https://github.com/discourse/discourse/pull/4663.
[20] ‚Äúasynchronous rendering library,‚Äù
https://github.com/renderedtext/render-async.
[21] ‚Äújquery,‚Äù https://jquery.com/.
[22] A. Farrell and H. Hoffmann, ‚ÄúMeantime: Achieving both minimal energy
and timeliness with approximate computing.‚Äù in USENIX , 2016, pp.
421‚Äì435.
[31] A. Cheung, A. Solar-Lezama, and S. Madden, ‚ÄúOptimizing database-
backed applications with query synthesis,‚Äù in PLDI , 2013, pp. 3‚Äì14.[23] R. Motwani, J. Widom, A. Arasu, B. Babcock, S. Babu, M. Datar, G. S.
Manku, C. Olston, J. Rosenstein, and R. Varma, ‚ÄúQuery processing,
approximation, and resource management in a data stream management
system.‚Äù in CIDR , 2003, pp. 245‚Äì256.
[24] Y . E. Ioannidis and V . Poosala, ‚ÄúHistogram-based approximation of set-
valued query-answers,‚Äù in VLDB , 1999, pp. 174‚Äì185.
[25] ‚Äúredmine, a project management application,‚Äù https://redmine.org/.
[26] ‚ÄúRubymine, a popular ruby on rails ide,‚Äù
https://www.jetbrains.com/ruby/.
[27] ‚ÄúAws cloud9,‚Äù https://aws.amazon.com/cloud9/.
[28] ‚ÄúPanorama website,‚Äù https://hyperloop-rails.github.io/panorama/.
[29] T.-H. Chen, W. Shang, Z. M. Jiang, A. E. Hassan, M. Nasser, and
P. Flora, ‚ÄúDetecting performance anti-patterns for applications developed
using object-relational mapping,‚Äù in ICSE , 2014, pp. 1001‚Äì1012.
[30] C. Yan, J. Yang, A. Cheung, and S. Lu, ‚ÄúUnderstanding database
performance inefÔ¨Åciencies in real-world web applications,‚Äù in CIKM ,
2017.
[32] M. B. S. Ahmad and A. Cheung, ‚ÄúAutomatically leveraging mapreduce
frameworks for data-intensive applications,‚Äù in SIGMOD , 2018, pp.
1205‚Äì1220.
[33] A. Cheung, S. Madden, O. Arden, and A. C. Myers, ‚ÄúAutomatic
partitioning of database applications,‚Äù PVLDB , vol. 5, no. 11, pp. 1471‚Äì
1482, 2012.
[34] A. Cheung, S. Madden, and A. Solar-Lezama, ‚ÄúSloth: Being Lazy is a
Virtue (when Issuing Database Queries),‚Äù in SIGMOD , 2014, pp. 931‚Äì
942.
[35] M. B. S. Ahmad and A. Cheung, ‚ÄúLeveraging parallel data processing
frameworks with veriÔ¨Åed lifting,‚Äù in Proceedings Fifth Workshop on
Synthesis, SYNT@CA V 2016 , 2016, pp. 67‚Äì83.
[36] S. Zaman, B. Adams, and A. E. Hassan, ‚ÄúA qualitative study on
performance bugs,‚Äù in MSR , 2012, pp. 199‚Äì208.
[37] M. Jovic, A. Adamoli, and M. Hauswirth, ‚ÄúCatch me if you can:
performance bug detection in the wild,‚Äù in SIGPLAN , 2011, pp. 155‚Äì
170.
[38] A. Nistor, L. Song, D. Marinov, and S. Lu, ‚ÄúToddler: Detecting perfor-
mance problems via similar memory-access patterns,‚Äù in ICSE , 2013,
pp. 562‚Äì571.
[39] L. Song and S. Lu, ‚ÄúPerformance diagnosis for inefÔ¨Åcient loops,‚Äù in
ICSE , 2017, pp. 370‚Äì380.
[40] J. Li, Y . Chen, H. Liu, S. Lu, Y . Zhang, H. S. Gunawi, X. Gu, X. Lu,
and D. Li, ‚ÄúPcatch: automatically detecting performance cascading bugs
in cloud systems,‚Äù in EuroSys , 2018, pp. 7:1‚Äì7:14.
[41] A. Nistor, P. Chang, C. Radoi, and S. Lu, ‚ÄúCARAMEL: detecting and
Ô¨Åxing performance problems that have non-intrusive Ô¨Åxes,‚Äù in ICSE ,
2015, pp. 902‚Äì912.
[42] G. Jin, L. Song, X. Shi, J. Scherpelz, and S. Lu, ‚ÄúUnderstanding and
detecting real-world performance bugs,‚Äù in PLDI , 2012, pp. 77‚Äì88.
[43] B. Dufour, B. G. Ryder, and G. Sevitsky, ‚ÄúA scalable technique for
characterizing the usage of temporaries in framework-intensive java
applications,‚Äù in FSE, 2008, pp. 59‚Äì70.
1004
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 09:39:38 UTC from IEEE Xplore.  Restrictions apply. 