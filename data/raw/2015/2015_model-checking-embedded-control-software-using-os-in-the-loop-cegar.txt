Model checking embedded control software using
OS-in-the-loop CEGAR
Dongwoo Kim
School of Computer Science and Engineering
Kyungpook National University
Daegu, South Korea
kdw9242@gmail.comY unja Choi
School of Computer Science and Engineering
Kyungpook National University
Daegu, South Korea
yuchoi76@knu.ac.kr
Abstract —V eriﬁcation of multitasking embedded software re-
quires taking into account its underlying operating system
w.r .t. its scheduling policy and handling of task priorities in
order to achieve a higher degree of accuracy. However, such
comprehensive veriﬁcation of multitasking embedded software
together with its underlying operating system is very costly and
impractical. To reduce the veriﬁcation cost while achieving the
desired accuracy, we propose a variant of CEGAR, named OiL-
CEGAR (OS-in-the-Loop Counterexample-Guided Abstraction
Reﬁnement), where a composition of a formal OS model and
an abstracted application program is used for comprehensive
veriﬁcation and is successively reﬁned using the counterexamples
generated from the composition model. The reﬁnement process
utilizes the scheduling information in the counterexample, which
acts as a mini-OS to check the executability of the counterex-
ample trace on the concrete program. Our experiments using
a prototype implementation of OiL-CEGAR show that OiL-
CEGAR greatly improves the accuracy and efﬁciency of property
checking in this domain. It automatically removed all false alarms
and accomplished property checking within an average of 476
seconds over a set of multitasking programs, whereas model
checking using existing approaches over the same set of programs
either showed an accuracy of under 11.1% or was unable to ﬁnish
the veriﬁcation due to timeout.
Index T erms —CEGAR, embedded OS, multitasking
I. I NTRODUCTION
An embedded system consists of a number of devices
controlled by software programs. Such control software is
typically multitasking and runs on top of an operating system
designed for controlling small-scale embedded devices, such
as sensors, actuators, brake pedals, engines, etc., which are
mostly used in safety-critical domains. The control program,
in particular, is tightly coupled with its underlying operating
system as they are compiled together to generate a piece of
embedded control software, and the behavior of the control
program can therefore not be analyzed accurately without
taking into account the behavior of the operating system.
However, research and practice in this domain have focused
either on the veriﬁcation of the control program or on the
veriﬁcation of the operating system, independent of each
other [1]–[8], due to the huge veriﬁcation cost when trying
to comprehensively verify application software together with
the implementation of the operating system.
V erifying embedded control software without considering
the underlying OS often results in a high rate of false alarms,as such veriﬁcation is highly likely to refute a given veriﬁca-
tion property based on incorrect execution sequences among
tasks. For example, a low-priority task may be preempted by
higher-priority tasks in a control program. Such behavior is
determined by the system conﬁguration and the scheduling
policy of the OS used. Most existing approaches that do
not consider the underlying OS use sound abstraction of the
scheduling behavior such as non-deterministic scheduling of
tasks [1], [4]. Our experiments showed that these approaches
had an accuracy of only 11.1%, verifying only two of the 18
applications within the time bound.
This work sets out to ﬁnd an efﬁcient veriﬁcation method
for multitasking embedded control software that reduces false
alarm rates as well as veriﬁcation cost. To this end, we adapted
the CEGAR approach [9], [10], where abstraction-veriﬁcation-
reﬁnement iterations are successively performed until a real
problem is identiﬁed or the given property is veriﬁed, to the
domain of embedded software by taking the operating system
into the loop. Our approach, named OiL-CEGAR (OS-in-the-
Loop CEGAR) is unique in that (1) it utilizes models of the
operating system, which are assumed to be correct w.r.t. the
requirements speciﬁcations, and (2) we take advantage of two
different types of model checkers, a symbolic model checker,
NuSMV [11], for property checking and the C code model
checker CBMC [1] for code-based false alarm identiﬁcation.
For a given property, OiL-CEGAR ﬁrst tries to verify the
property on the composition of the operating system model
and the application model abstracted from the program source
code. If the property is refuted, the model checker NuSMV
generates a counterexample trace including task scheduling
information and the control ﬂow of the application program.
This task scheduling information is used to construct a mini-
OS for the application source code so that CBMC can be
used to check the executability of the given trace in the
concrete application program. If the trace is executable, then
the counterexample is a real alarm. Otherwise, the composition
of the OS model and the application model is reﬁned using
the trace so that the next iteration of OiL-CEGAR can be
performed.
OiL-CEGAR is efﬁcient in identifying real property vi-
olations with moderate veriﬁcation cost, even though more
complexity is introduced by taking the OS model into ac-
5652019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00059
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TASK t2 {
  priority = 2;
}
EVENT e1 {}; ...Application Program
System Con ﬁguration
RUN t1
SUS RUNRDY
WITRUN
RUNRDY RUN
SUS SUSSUS RUN
SUS t2AT(t2)
WE(e1)SE(t2,e1)
TT()AT(t2) TT()Expected Simulation   int wait_sw = OFF;
   Task(t1) {
     int local_var;
     int *p;
01:  p = &local_var;
02:  local_var = ON;
03:  ActivateTask(t2);
04:  if(wait_sw==ON) {
05:    wait_sw = ON;
06:    local_var = OFF;
07:    *p = local_var;
08:    SetEvent(t2, e1);
     }
09:  ActivateTask(t2);
10:  TerminateTask();
   }   Task(t2) {
     int t2_sw;
11:  t2_sw = OFF;
12:  if(wait_sw!=ON) {
13:    wait_sw = ON;
14:    WaitEvent(e1);
     }
15:  TerminateTask();
   }
RUNRDY
TT()TASK t1 {
  autostart = true;
  priority = 1;
}
Fig. 1. A multitasking program and its expected execution sequence
count. This is possible through two-way abstractions, code
abstraction for the property checking, and OS abstraction
for the executability checking, and by utilizing two different
model checking approaches suited best for the veriﬁcation of
statemachine-based models and the veriﬁcation of program
source code, respectively.
A prototype implementation of OiL-CEGAR was applied to
three sets of experiments. It showed 100% veriﬁcation accu-
racy, automatically removed all false alarms, and accomplished
property checking within 476 seconds, on average, whereas
existing veriﬁcation approaches using CBMC [1] and Y ogar-
CBMC [4] showed a veriﬁcation accuracy of 0% and 11.1%,
respectively, over the same set of programs.
The remainder of this paper is organized as follows. After
a brief introduction of the research background in Section II,
we formally deﬁne the basic terminology used throughout
this paper in Section III. Section IV introduces the OiL-
CEGAR process, Section V explains the abstraction techniques
applied to the program source code, and Section VI describes
the methods used for constructing models for OiL-CEGAR.
An experimental result of OiL-CEGAR is explained in Sec-
tion VII. We conclude with a brief discussion in Section IX,
after summarizing related work in Section VIII.
II. B ACKGROUND
A multitasking application program consists of a set of
tasks. Each task has its own priority so that a task with higher
priority is scheduled earlier than tasks with lower priority. It
is also possible for a task with lower priority to run prior to
a task with higher priority if it accesses a critical section by
occupying resources. A running task may be in a waiting state
by voluntarily waiting for an event.
An application program interacts with its underlying op-
erating system through API functions provided by the OS.
Figure 1 shows an example of the embedded application
program that will be used throughout this paper. Given the
system conﬁguration, the two tasks are expected to be executeda counterexample
satis ﬁableτ
yesno˜M
˜M⊧φM ˜M←refine (˜M,τ)
unsatis ﬁable
M⊧φM ⊭φ,ττ Does    feasible?
Fig. 2. Counterexample-guided abstraction reﬁnement
as shown in the lower part of the ﬁgure; The autostart task
t1 runs ﬁrst and activates task t2, which has higher priority.
Task t2 preempts t1, runs to set wait swto ON, and goes
to the waiting state by calling WaitEvent(e1) , giving another
execution round to task t1. t1 calls SetEvent for task t2, as the
branch condition in line 04 evaluates to true, which preempts
t1 again and wakes t2. After t2 terminates, t1 activates t2 again,
but t2 terminates immediately as wait swevaluates to ON.
A. V eriﬁcation of embedded control software
The behavior of an embedded application program is deter-
mined by its system conﬁguration, task logic, and OS behavior,
which typically produce a unique deterministic trace unless an
interrupt occurs. If we abstract the operating system, e.g., by
using non-deterministic scheduling, we need to consider multi-
ple execution traces for the same program as context switching
may occur at any instruction of each task. For example, there
can be up to 15C5=3,003 execution sequences to check for
the program in Figure 1 if we assume that a context switch may
occur in every line of the program. It is extremely expensive to
perform comprehensive veriﬁcation in this case, both in terms
of performing model checking for property checking and in
terms of identifying false alarms produced by incorrect task
execution sequences.
We note that even software-level dynamic testing of an
embedded control program is difﬁcult because embedded soft-
ware requires a speciﬁc hardware platform, platform-speciﬁc
library functions, and other peripherals such as sensors and
event generators. Software-level testing often requires speciﬁc
simulation environments [12], which are not always available
in the development process.
B. Counterexample-guided abstraction reﬁnement
CEGAR [9], [10] is an effective veriﬁcation method for alle-
viating veriﬁcation complexity through successive abstraction-
veriﬁcation-reﬁnement iterations. Figure 2 shows the overall
process of CEGAR. It starts with an initial abstraction of a
given application /tildewiderM. If the abstract model is veriﬁed for a
given property ϕ, then we can safely conclude that the concrete
application is veriﬁed, as the model is a sound abstraction of
the application. Otherwise, the counterexample τgenerated
from checking ϕis tested on the concrete application to
determine whether it is an actual execution trace, as it may be
the case that the trace is possible only on the abstract model
(false alarm). If it is executable on a concrete application,
it shows a property violation of the system (true alarm).
Otherwise, τis used to reﬁne /tildewiderM, which is veriﬁed w.r.t. ϕin
566
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. 0..n
0..n
- idKernelObject Parameter
use
Alarm
- state :
{held, released}
- priority : intResourceinvoke
- state : {suspended, ready, running, waiting}
- mode : {standard, extended}
- priority : intTask
ISR- API_nameSystem Call1OS Kernel1provide
belong to
- state : {cleared, set}Eventinvoke
0..n10..*0..*
set0..*
triggers1
allocates
Fig. 3. Structure of an embedded operating system (OSEK/VDX)
the next iteration. This process is repeated until a real alarm
is identiﬁed or until the property is veriﬁed.
CEGAR has been successfully applied in various applica-
tion domains [4], [13]–[18]. However, it has not been clear
whether it can be effectively applied to multitasking embedded
software, taking into account the OS behavior.
C. F ormal models of embedded operating system
A number of approaches for formally modeling and veri-
fying embedded operating systems have been proposed. Most
notably, the construction of seL4 [19] is based on successive
reﬁnements of a formal OS model written in Haskell [20],
which is thoroughly veriﬁed for correctness w.r.t. the func-
tional requirements of a real-time embedded operating sys-
tem. The other notable example is the formal modeling of
embedded operating systems that are compliant with the
OSEK/VDX international standard [21]. Approaches include,
for example, modeling in Promela [22], CSP [8], NuSMV [23],
UPPAAL [24] and the K-framework [25]. OiL-CEGAR is in-
dependent of formal models and modeling approaches, but this
work adopts the pattern-based automatic model construction
approach suggested in [23] to facilitate automation of the OiL-
CEGAR process.
Figure 3 shows the internal structure of the embedded
operating system used in [23], modeled by referring to the
OSEK/VDX international standard. An OS kernel consists of
a set of kernel objects, which can be Tasks, Events, Resources,
or Alarms. A task (or thread) is the basic building block of
embedded software. An embedded OS maintains the internal
states of each task which typically consists of {running, ready,
waiting, suspended }as in the OSEK/VDX OS, Zephyr [26],
FreeRTOS [27], etc., with minor variations. The internal state
of each task changes according to the task management and
scheduling mechanism in the OS kernel, which is triggered by
requests from the application program through API function
calls. A task may set a periodic alarm to activate another task
or to set an event. An external event triggers a corresponding
ISR (Interrupt Service Routine), which may call API functions.
The OSEK OS adopts priority-based FIFO scheduling with
dynamically changing ceiling priorities for resource allocation
in order to avoid the priority-inversion problem.
Reference [23] formally modeled the behavior of each
kernel object as a parameterized statemachine (called patterns)
and deﬁned an OS model as a synchronized parallel compo-sition of multiple kernel objects whose types and numbers
are determined by the system conﬁguration. In addition, an
OS generator was deﬁned as a function from conﬁguration
vectors to formal OS models. This approach is implemented
as a prototype tool for automated model construction by
composing the formal patterns speciﬁed in the input language
of NuSMV [11] or Spin [28]. The generated OS models are
validated through property veriﬁcation using a set of functional
requirements identiﬁed from the OSEK/VDX international
standard. For more details on the OSEK OS and pattern-based
OS model construction, please refer to [23].
Our work utilized the prototype tool with a minor exten-
sion to the OS model. To enable a focused discussion of
OiL-CEGAR, however, throughout this paper an OS model
is assumed to be a black-box component where transitions
among internal states of tasks are the only externally visible
behaviors.
III. B ASIC DEFINITIONS
This section deﬁnes the terminologies required to explain
OiL-CEGAR.
Deﬁnition 1. A control ﬂow graph (CFG) for a task TCFG=
(N,E,n 0,nt)is a directed graph where Nis a set of statement
blocks,n0∈Nis a unique entry block, nt∈Nis a unique
exit block, and E:N→Nis a set of directed control ﬂow
edges.
A statement block is a sequence of statements. It is also a
unit of atomic execution. Each statement block consists of the
maximal number of statements that can be executed in a single
control thread. To formally deﬁne a statement block, we use
the notion of visible variable and visible statement , similar to
the notion introduced in [2].
Deﬁnition 2. Visible variables and visible statements
- A visible variable is a variable that is globally accessible
or that uses other visible variables. Visible variables
include global variables, pointer variables, and variables
in shared memory,
- A visible statement is a simple statement that either
deﬁnes/uses a visible variable or calls an API function.
Deﬁnition 3. A statement block is the maximal sequence of
statements a1,...,anin a task, where only the ﬁrst statement
in the block is visible and there is no statement that uses
any variables deﬁned in previous statements, i.e., def(ai)∩
use(aj)=∅for alli<j≤n.
Each statement block contains at most one visible statement
and is a unit of context switching, i.e., the control ﬂow may
be switched to other tasks after the statement block has been
executed.
Deﬁnition 4. M=(S,S 0,R)is a statemachine, where Sis a
set of states, S0is a set of initial states, and R⊆S×Γ×G×S
is a set of transition relations triggered by a set of events
Γ, including a null event, and guarded by a set of guarding
conditions G.
567
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. a counterexample
satis ﬁableτ
yesno
M⊧φMapp
M←M⊙A(τ′)
unsatis ﬁable
Mos||Mapp⊧φMos||Mapp⊭φ,τ˜Mos(τ)||Mapp⊧n
RM=Mos||˜Mapp
τ′
Fig. 4. OS-in-the-Loop CEGAR
A transition r∈Ris represented as sie[g]→sj, wheresiand
sjare the source and target states, respectively. We sometimes
abbreviate a sequence of transitions s0e1[g1]→s1e2[g2]→s2e3[g3]→
···en[gn]→snass0s1s2...snto save space.
We use two composition operators on statemachines, ||and
⊙, which are deﬁned as follows:
Deﬁnition 5. M1||M2=(S,S 0,R)is a synchronous parallel
composition of two statemachines M1=(S1,S1
0,R1)and
M2=(S2,S2
0,R2)synchronized over a set of events in Γ,
where
-S=S1×S2,
-S0=S1
0×S2
0, and
-R⊆R1×R2such that s1
ie[g]→s1
j∈R1ands2
pe/prime[g/prime]→s2
q∈
R2implies (1) (s1
i,s2
p)e[g∧g/prime]→(s1
j,s2
q)∈Rife=e/prime, (2)
(s1
i,s2
p)e[g∧¬g/prime]→(s1
j,s2
p)∈R, and (3) (s1
i,s2
p)e/prime[¬g∧g/prime]→
(s1
i,s2
q)∈R.
A synchronous parallel composition [29] of two statema-
chines allows each statemachine to perform its own transition
while the other stays in the same state.
Deﬁnition 6. M1⊙M2=(S,S 0,R)is a trace composi-
tion of two statemachines M1=(S1,S1
0,R1)andM2=
(S2,S2
0,R2)w.r.t. the set of error states S2
EinM2and a
labeling function LoverS1∪S2, where
-S⊆S1,
-S0⊆S1
0, and
-R⊆R1, wherer:s1
ie[g]→s1
j∈Riffr∈R1and∃r/prime:
s2
pe[g/prime]→s2
q∈R2such that s2
q/negationslash∈S2
E,L(s1
i)=L(s2
p),
L(s1
j)=L(s2
q), andg=⇒g/prime.
A trace composition only allows a transition of a statema-
chine when the other statemachine has an equivalent transition
w.r.t. the state labels and transition conditions that does not
lead to an error state.
IV . O IL-CEGAR
OiL-CEGAR takes advantage of both CEGAR and the use
of the OS in the model checking process with a two-way
reciprocal abstraction scheme. It is a variation of CEGAR
in that (1) a veriﬁed OS model is used to enhance theaccuracy of the property checking and (2) the scheduling
information in the counterexample generated from the property
checking is used to construct a mini-OS, instead of the full-
scale OS implementation, for checking the executability of the
counterexample on the program source code.
This section provides an intuitive introduction to OiL-
CEGAR. Technical details will be provided in later sections.
A. Overview of OiL-CEGAR
Figure 4 illustrates the OiL-CEGAR process. It starts with
the composition of a veriﬁed OS model Mosand an ini-
tial sound abstraction /tildewideMapp of a given application program
Mapp. For a given property ϕ, if the composition model
M=Mos||/tildewideMapp respects the property, i.e., M|=ϕ, then
we conclude that the concrete embedded software OS||Mapp
also respects the property. Otherwise, a counterexample τ
showing a property violation in the form of a sequence of
states in M is generated. As τcan be a false alarm, due
to the use of the abstract model /tildewideMapp in the veriﬁcation,
so we need to check its executability on the concrete system
OS||Mapp. However, as it is difﬁcult to construct an execution
environment for the actual implementation of the OS and
the application program, we instead check the reachability of
the composition,/tildewiderMos(τ)||Mapp, where/tildewiderMos(τ)is a mini-OS
constructed from τ, so that if it terminates in a ﬁnal state, we
can conclude that τis an executable execution sequence in the
concrete program, i.e., a true alarm. Otherwise, a trace τ/prime,a
subsequence of τfrom the initial state to the ﬁrst unreachable
state ofτ, is generated and is used to reﬁne M, which is used
in the next iteration of OiL-CEGAR. This process is repeated
until either an actual property violation is found or the property
is proved.
Two well-known model checkers are used in OiL-CEGAR:
the symbolic model checker NuSMV [11] for LTL property
checking of Mos||/tildewideMapp|=ϕand the SA T-based C code
model checker CBMC [1] for checking the reachability of
/tildewiderMos(τ)||Mapp.
B. Construction of /tildewideMapp
An application program is a parallel composition of mul-
tiple tasks, i.e., Mapp=P1||P2||...||Pn. We construct an
abstraction of Mapp,/tildewideMapp by abstracting each task, i.e.,
/tildewideMapp=MP1||MP2||...||MPn, where each MPiis a statema-
chine representation of each task Pi.
Figure 5 illustrates how each task Piis modeled as a
statemachine using the example code shown in Figure 1. We
ﬁrst construct a control ﬂow graph (CFG) of each task, abstract
the CFG by eliminating statements involving visible vari-
ables, and then transform the abstract CFG into a statemachine
model by adding transitions from the exit node to the entry
node (as a task can be reactivated after its termination) and
guarding conditions to each transition to check the internal
state of the task. Details of the conversion process will be
explained in Section VI.
568
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. ActivateTask(t2)p = &local_var 
local_var = ON(a) Control abstracted CFG
(c) Task modelwait_sw = ON 
local_var = OFF
*p = local_var
SetEvent(t2, e1)
ActivateTask(t2)
TerminateTask()
<Task t1>
[β]initial
terminal
Mtt2_sw = OFF
wait_sw = ON
WaitEvent(e1)
TerminateTask()
<Task t2>initial
terminal
[ϵ]
ζB1
1
B1
2
B1
3B1
4
B1
5
B1
6
B1
7
B1
8B2
1
B2
2
B2
3
B2
4
B2
5
ActivateTask(t2)  
local_var = ON local_var = OFF
SetEvent(t2, e1)
ActivateTask(t2)
TerminateTask()
<Task t1>initial
terminalt2_sw = OFF
WaitEvent(e1)
TerminateTask()
<Task t2>initial
terminalB1
1
B1
2
B1
3B1
4
B1
5
B1
6
B1
7
B1
8B2
1
B2
2
B2
3
B2
4
B2
5(b) Data abstracted CFG
α
δγ
ζActivateTask(t2)local_var = ONlocal_var = OFF
SetEvent(t2, e1)
ActivateTask(t2)
TerminateTask()
<Task t1>initial
terminalt2_sw = OFF
WaitEvent(e1)
TerminateTask()
<Task t2>initial
terminalα
δγ[internal_state==running]
…
……
…
…
…
…[internal_state==suspended]…
……………[wait_sw!=ON][!(wait_sw!=ON)]
[wait_sw==ON]
[!(wait_sw==ON)]
[!β][!ϵ]
[...∧ β][...∧ ϵ]
[...∧! β][...∧! ϵ]B1
1
B1
2
B1
3B1
4
B1
5
B1
6
B1
7
B1
8B2
1
B2
2
B2
3
B2
4
B2
5
Fig. 5. Construction of the task model
RDYRUN SUS init
RUN
RUN RDY RUN WIT
RUN WIT
init WIT SUSRUN WITRUN RDY
RUN init SUS
RUN RDY
RUN RDY
init
SUS init init SUSRDY RUN
RUN init SUS
RUN init SUS
RUN RDY
SUS RUNRUN WITRUN SUS initRDY RUN
RDY RUN
RUN WIT
RUN WITRUN init SUS
RUN init SUS
RUN RDY
RUN RDYs0
s2s3
s5
s7
s11s8
s16
s12s14s17
s18
s21
s23
s24
s13s25s1
s4
s6
s9
s10s19
s20
s22
s15
s26[β][ϵ]
[!β][!ϵ]
[ϵ]
[!ϵ]B1
1
B1
2B1
2
B1
2
B1
2
B1
2B1
2
B1
3B1
3
B1
4B1
4
B1
5B1
5
B1
6B1
6 B1
6
B1
7B1
7
B1
7B1
7
B1
7
B1
7
B1
7
B1
8 B1
8B2
1
B2
1B2
2
B2
2B2
3
B2
3B2
4B2
4
B2
4
B2
4
B2
4
B2
4
B2
4B2
4B2
5
B2
5
B2
4B2
5
[!β]
[β]
Fig. 6. Composition of the OS model and the application model of the
program in Figure 1/tildewideMapp is composed with the OS model. Figure 61illustrates
a simpliﬁed Mos||/tildewideMapp for the example in Figure 1, where
each state consists of the internal state of task t1, the internal
state of task t2, the block number of task t1, and the block
number of task t2, respectively. The transition ﬁnishes either
ats13, indicating that task t2 is in the waiting state, or at s26,
indicating that all the tasks have terminated.
Let us assume that we are checking the following property:
P1. A call to WaitEvent shall be followed by a matching call
toSetEvent .
Model checking this property would generate a coun-
terexample, say s0s1s2s4s5s6s7s11s12s13s13s13..., wheret2
would go to the waiting state and stay there forever. τis a ﬁnite
maximal subsequence of a counterexample trace that does not
end with a cycle.
C. Executability checking using τ
Whether the counterexample τis a realistic execution trace
or not is tested in the concrete application program Mapp.
As the counterexample trace contains information on task
execution sequences, we use this information to guide the
execution sequence of the tasks in the actual program code.
The task execution sequence is a sequence of states in
τprojected to the states of the OS. For example, τ|os=
s0|oss1|os...s 12|oss13|os= (RUN,SUS)(RUN,SUS)(RDY,
RUN)(RDY,RUN)(RDY,RUN)(RDY,RUN)(RUN,WIT)(RU
N,WIT)(RUN,WIT)(SUS,WIT) and its corresponding task
execution sequence is t1t1t2t2t2t2t1t1t1∅, where the unit of
an execution is a block in the control ﬂow graph as shown
in Figure 5 (a). In other words, B1
1B1
2B2
1B2
2B2
3B2
4B1
3B1
7B1
8∅
is the actual sequence of blocks to be executed according to
this counterexample trace. However, it is impossible to execute
B1
7afterB1
3; i.e.,s7→s11is a non-executable transition in τ
because if wait_sw==ON , it must execute B1
4. We use the C
code model checker CBMC to identify the ﬁrst non-executable
transition in the counterexample trace using the information
on the task execution sequence extracted from the trace called
mini-OS, which acts like a test driver.
If the counterexample trace τhas an unreachable transition
in the actual application program, we use the same trace up
to the ﬁrst unreachable state, named τ/prime, to reﬁne Mos||/tildewideMapp.
D. Reﬁnements using τ/prime
Onceτ/primeis identiﬁed, we reﬁne (Mos||/tildewideMapp)so thatτ/prime
can be eliminated from its possible execution traces. To this
end, we ﬁrst construct a statemachine A(τ/prime)=(S,s 0,T,sE),
whereS={s∈τ/prime.S}∪{sU}is the set of states in τ/prime
plus one additional special state sUrepresenting the universal
state;s0is the initial state in τ/prime;sEis the ﬁnal state of τ/prime
representing the error state; and T=τ/prime.T∪{s→sU|s/negationslash=
sE}∪{sU→sU}∪{sE→sE}is a set of transitions in τ/prime
plus new transitions from each non-error state to the universal
state plus self-transitions of sUandsE. Figure 7 illustrates
A(τ/prime)for our example for each iteration of OiL-CEGAR.
1RUN ,RDY ,WIT , and SUS are abbreviations for Running ,Ready ,Waiting ,
and Suspended
569
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. A(τ1) (a) A(τ2) (b) A(τ3) (c)sUs0s1s2
s4
s5
s6
s7s0
s1
s2
s4s0 s1s2
s4s5
s6
s7
s8
s9 s10s14s21s22
sE sEsEs23sUsU
Fig. 7. Reﬁnement bases
/tildewideMapp is reﬁned by constructing (Mos||/tildewideMapp)⊙A(τ/prime),
where⊙represents the trace composition of the two statema-
chines. The trace composition A⊙Ballows transitions of
Aonly when AandBshare the equivalent source/target
states and satisfy both transition conditions, and when the
target state is not the error state. For example, the trace
composition of (Mos||/tildewideMapp)shown in Figure 6 and A(τ1)in
Figure 7 (a) results in removing the trace s0s1s2s4s5s6s7s11
from(Mos||/tildewideMapp). The OiL-CEGAR process is repeated
from the property checking of (Mos||/tildewideMapp)⊙A(τ1), pro-
ducing reﬁnement bases as shown in Figure 7 (b) and
Figure 7 (c), and thus, removing traces s0s1s2s4s3and
s0s1s2s4...s 10s14s21s22s23s15in order, before it concludes
that the property is satisﬁed.
V. A BSTRACTION
OiL-CEGAR starts by constructing an application model
/tildewideMapp as a synchronous parallel composition of statemachines,
each representing a task in the application program. This
section explains two major abstractions applied to the source
code of each task before the application model was composed
with the operating system model.
A. Pre-processing
Due to the limited expressive power allowed in the input
language of NuSMV compared to that of the implementation
language C, we performed two types of pre-processing on the
source code. First, user-deﬁned functions were replaced with
inline functions, assuming that the program did not contain
any inﬁnite recursive calls. Second, composite structures such
as arrays and user-deﬁned structures were ﬂattened so that all
variables were typed as primitives, assuming that there were
no dynamic allocations and that they were thus of ﬁxed size.
These assumptions are valid for embedded systems in critical
domains, as recommended by the MISRA-C international
standard [30].
B. Control abstraction
Multitask programs have multiple threads of control that
interleave with each other. This context switching may happen
as low as at the instruction level, but it is infeasible as well
as uninteresting to consider all possible context switchingbehaviors in multitasking programs. In this work, we applied
control abstraction to the CFG of each task based on the notion
of partial-order reduction [31] by deﬁning the statement block
as a maximal sequence of statements to be executed without
interrupts. The statement block in Deﬁnition 3 is a unit of
such a context switch, whose execution is independent of
concurrently executed transitions of other tasks.
The CFG of each task in the application source code was
constructed using the statement block as a unit of execution.
The rationale behind this was: (1) Non-visible variables would
not be affected by context switching, but visible variables
may be, and (2) a call to an API function certainly causes an
intervention of the operating system that may require context
switching among tasks. In addition, we reﬁned the statement
block to separate statements with def-use relations into differ-
ent blocks, due to the execution semantics of NuSMV , which
executes all statements in a block at the same time.
Figure 5 (a) shows the control-abstracted CFG of Figure 1.
BlocksB1
1andB1
4in Figure 5 (a) are the abstraction of lines
01-02 and lines 05-06 of Figure 1, respectively. Line 07 is
not blocked together with lines 05-06 because it is a visible
statement and also references the variable localvar, which is
deﬁned in line 06.
C. Data abstraction
A series of selective predicate abstractions was performed
on the CFG of the pre-processed, control-abstracted appli-
cation source code. These abstractions are major sources of
non-executable counterexample generation, but greatly help to
reduce the complexity of property checking.
1) Abstraction of visible statements: Each visible statement
is replaced by an empty statement with a unique symbol.
2) Abstraction of platform-dependent functions: Platform-
dependent, user-deﬁned library functions are replaced
with stubs that return arbitrary values of the same return
type. This abstraction is performed manually, once for
each OS platform.
3) Abstraction of branch conditions: If a branch condition
references a visible variable, the condition is replaced
with a Boolean variable whose value can be non-
deterministically assigned during property checking.
4) Numeric data abstraction: Statements involving ﬂoating
points variables are replaced with empty statements.
This is due to a limitation of the model checker NuSMV ,
which cannot handle ﬂoating points.
Compared to typical predicate abstraction [17], the sug-
gested data abstraction is selective, as it is not applied to
local variables with ﬁxed size. This is to avoid unnecessary
over-approximation, as embedded software frequently uses
variables with ﬁxed size due to the stringent memory space.
Figure 5 (b) shows the data-abstracted CFG. The ﬁrst
statement of B1
1,B1
4, the statement of B1
3,B1
5,B2
2, andB2
3
are replaced with empty statements because they reference
either a pointer variable por a global variable wait sw. The
second statement of B1
1and the second statement of B1
4are
570
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. not abstracted because local var is a local integer variable that
does not have any dependency on any visible variables.
VI. M ODEL CONSTRUCTION AND IMPLEMENTA TION
OiL-CEGAR requires the construction of three types of
models: the task model constructed from each task CFG after
a series of abstractions; the composition of the application
model and the OS model; and a mini-OS constructed from a
counterexample trace generated from property checking. This
section explains the construction of a task model and a mini-
OS in more detail.
A. Task model construction
The abstracted CFG for each task is converted into a
statemachine At=(St,Rt,St
0)by mapping the set of state-
ment blocks and the set of control ﬂow edges in the CFG to
a set of states Stand a set of transitions Rt, respectively. An
additional transition from the ﬁnal block to the entry block is
added to allow the same task to be activated multiple times,
removing the ﬁnal state from the machine. Each transition
in the statemachine is guarded by internal state[t]==running
to enable the transition only when the task is in the running
state. Note that the information about the internal state of
each task is maintained by the OS model. Figure 5 (c)
illustrates the task models converted from Figure 5 (b), where
the common guarding condition internal state[t]==running is
omitted from each transition to save space.
The application model /tildewideMapp=At1||At2||...||Atnis a
synchronous parallel composition of task statemachines. Given
the number of tasks nin an application program, a parallel
composition of an OS model and an application program
includes nstatemachines for representing tasks internally
maintained by the OS and nstatemachines, each representing
the application logic of each task, synchronized over the set
of API function calls and the internal states of the tasks, i.e.,
Mos||/tildewideMapp=ˆM||Mt1||...||Mtn||At1||...||Atn,
whereˆMis a parallel composition of kernel objects other than
tasks, such as events, resources, alarms, or schedulers. We use
(Mos||/tildewideMapp)|T=Mt1||...||Mtn||At1||...||Atnto represent
the projection of Mos||/tildewideMapp on the task statemachines of the
system, as only the task part of the model is of interest for us
in the reﬁnement process of the OiL-CEGAR.
B. Mini-OS construction
Given a property ϕ, the property checking Mos||/tildewideMapp|=ϕ
generates a counterexample if ϕis not satisﬁed by Mos||/tildewideMapp.
When(Mos||/tildewideMapp)|Tis a composition of nOS statemachines
andntask application statemachines, the counterexample trace
τprojected to (Mos||/tildewideMapp)|Tis a sequence of composite
states with 2∗nelements. The counterexample trace could be
an inﬁnite sequence, but we consider only a ﬁnite subsequence
of it.Deﬁnition 7. A counterexample trace τ|T=s0s1s2...smis
a sequence of states with length m+1. Each state siis a com-
posite state of 2∗nelements <o1
i,o2
i,...,on
i,t1
i,t2
i,...,tn
i>,
wherenis the number of tasks in the application program.
Model checking may generate an inﬁnite counterexample
trace in case it ends with a cycle. In such a case, τ|Tis
the maximal subsequence of the counterexample trace after
removing the ﬁnal cycle2.
For simplicity of notation, we will use τandτ|Tinter-
changeably in the remaining discussions. We will also use si|os
andsi|app to represent the OS part and the application part of
the composite state siinτ|T, respectively. The counterexample
trace includes information on task execution sequences, i.e.,
τ|os=s0|oss1|os...sm|os, which can act as a mini-OS that
drives the executability checking of τ|app in the application
program code.
Deﬁnition 8. A mini-OS/tildewiderMos(τ)=(Sτ,Sτ
0,Rτ,sτ
f)is a
statemachine constructed from a counterexample trace τ=
s0s1s2...sm, whereSτ={si|os|si∈τ},Sτ
0={s0|os},
Rτ={si|os→si+1|os|i=0...m−1}, andsτ
f=sm|os.
The mini-OS is just a sequence of ﬁnite state transitions
where each state indicates the internal states of each task.
Using this mini-OS as a test driver, we checked whether the
application program is executable until the mini-OS reaches
the ﬁnal state under the following execution semantics of the
application program.
Exec(i)=(Bi1,Bi2,...Bin),Bij→Bi/prime
j,/tildewiderMos(τ)|i,RUN=ik
(Bi1,Bi2,...Bi/prime
k,Bik+1,...,B in)
When the application program consists of ntasks, the ith
execution block is a statement block that belongs to the task
assigned to run by the ithstate of the mini-OS. With this
execution semantics, we applied CBMC model checking to
the application program to check whether it ﬁnishes all m+1
executions as indicated in the mini-OS. If so, the counterex-
ampleτis an executable counterexample, i.e., a true alarm.
Otherwise, we can identify the ﬁrst non-executable transition
sk|os→sk+1|os, wheresj|os→sj+1|osis executable for all
0≤j<k . We used the sequence of states from s0tosk+1,
namedτ/prime, to reﬁne Mos||/tildewideMapp.
C. Reﬁnement model construction
τ/primeis an execution trace in Mos||/tildewideMapp that leads to the ﬁrst
non-executable transition in Mapp. The goal of reﬁnement is to
remove such non-executable execution traces from the model
until a counterexample trace executable in the application
program is found or until no more counterexample traces exist.
We ﬁrst constructed a statemachine A(τ/prime)that included
all states and transitions in τ/primeplus an additional state sUto
represent the Universal state and transitions from each non-
error state to sU.
2NuSMV provides a counterexample trace indicating the start of a cycle,
if there is any.
571
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. Control/Data 
AbstractionApplication 
Program
CFG Analysis
CFGsAbstracted 
CFGTask model 
constructionSystem 
Conﬁguration
OS model 
generation
Task model
Property checking 
(NuSMV)OS 
Speci ﬁcation
OS Model
task execution 
sequence
Executability checking 
(CBMC)Reﬁnement model 
construction
Un-reachable 
blockReﬁnement 
base
app. block 
sequence
Mini-OS 
constructionAnnotated 
ApplicationProperty
Context switch 
point annotation
Mini-OS
Fig. 8. Overall process of a prototype tool for OiL-CEGAR
Deﬁnition 9. A reﬁnement base A(τ/prime)=(Sτ/prime,sτ/prime
0,Rτ/prime,sτ/prime
E)
is a statemachine constructed from a non-executable coun-
terexample trace τ/prime=s0s1s2...sksk+1, where
-Sτ/prime={si|si∈τ/prime}∪{sU},
-sτ/prime
0=s0,
-sτ/prime
E=sk+1,
-Rτ/prime={sie[g]→si+1|i=0...k}∪{sie/prime[g/prime]→sU|
i≤k,(e/prime/negationslash=e∧g/prime=true)∨g=¬g/prime}∪{sk+1→
sk+1}∪{sU→sU}.
We used the reﬁnement base to trace-compose, as deﬁned
in Deﬁnition 6, with the veriﬁcation model using the labeling
functionL. Here,Lis deﬁned over S∪Sτ/primeasL(s)=L(s/prime)
iffs=s/primeors=sUors/prime=sU. Since there is a transition
from any non-error state to sUinA(τ/prime)andsUhas the same
label as any other state, M⊙A(τ/prime)allows all transitions in
Mexcept for the sequence of transitions from the initial state
to the error state in τ/prime.
D. Implementation
The prototype tool we used to implement OiL-CEGAR
consisted of three components for model generation, exe-
cutability checking, and reﬁnement. Figure 8 illustrates the
overall process of the prototype tool, where the implementa-
tion for representing statemachine models in NuSMV follows
the approach described in [32]. The formal OS model used in
our tool is from the automotive domain and is based on the
OSEK/VDX international standard [21], [23].
The construction of /tildewiderMos(τ)||Mapp for executability check-
ing using CBMC required some instrumentation: (1) encoding
/tildewiderMos(τ)in C as a test driver, and (2) inserting assertions
for checking reachability. The main function in the right
part of Figure 9 shows the test driver deﬁned from τ|os,
where assert(0) is inserted after each call to the runnable task.
The corresponding execution sequence of statement blocks is
encoded in an array as indicated in τ|app. Each statement block
in the application source code is annotated with a unique label
and a program counter. Whenever the task is called by the
main , it jumps to the corresponding statement block which
is annotated with a unique label. An assumption, assume(c) ,
is also annotated before each statement block, which rulesTask(t1) { 
  static int local_var; 
  goto_pc_t1(); 
   pc_t1_1: 
   assume(B_t1_1==B[b_idx++]); 
  p = &local_var; 
  local_var = ON; 
   pc[t1] = 2;  return; 
   pc_t1_2: 
   assume(B_t1_2==B[b_idx++]); 
  ActivateTask(t2); 
   pc[t1] = 3;  return; 
    ...Annotated Application
 int main() { 
   Task(t1); assert(0); 
   Task(t1); assert(0); 
   Task(t2); assert(0); 
   Task(t2); assert(0); 
   Task(t2); assert(0); 
   Task(t2); assert(0); 
   Task(t1); assert(0); 
   Task(t1); assert(0); 
   Task(t1); assert(0); 
 } int pc[2]={1,1}; 
 int b_idx=0;  
 Block B[]={ 
   B_t1_1, 
   B_t1_2, 
   B_t2_1, 
   B_t2_2, 
   B_t2_3, 
   B_t2_4, 
   B_t1_3, 
   B_t1_7, 
   B_t1_8, 
 };τ|osτ|app
Fig. 9. Annotated task and C-encoded mini-OS
out program paths that do not respect the condition cduring
CBMC model checking. This assumption is used to check only
those execution paths that follow τ|app and to ignore all other
execution sequences of statement blocks. Each block ends with
saving the label of the next statement block to be executed in
pcand returning control to main .
If the task sequence is executable, CBMC is supposed to
ﬁnd veriﬁcation failures for all assertions speciﬁed in main .
Otherwise, we can identify the ﬁrst assertion that did not fail,
meaning that the task (and its corresponding statement block)
called before the assertion checking is non-executable.
VII. E XPERIMENTS
We conducted three sets of experiments to evaluate the
effectiveness of OiL-CEGAR using a formal OS model based
on the OSEK/VDX international standard for automotive
OSs [23] and using the following three test sets:
TS1. A set of application programs running on Lego Mind-
storms NXT [33],
TS2. a set of test programs from a commercial confor-
mance test suite used for certifying implementations of
OSEK/VDX-based OSs [34], and
TS3. a window controller program from the automotive do-
main [35].
We chose the programs in TS1 for the sake of fair com-
parison because they are open to the public, even though they
are quite small in scale. TS2 is a more realistic test set as it
comes from domain experts, but it is not open to the public.
The experiments with TS3 were done to check the feasibility
of applying OiL-CEGAR in a program with high complexity.
All experiments were performed on a Fedora Linux-based
machine with a 3.4-GHz Intel Xeon E5-1680 CPU and 128
GB of memory. We used CBMC version 5.10 for executability
checking, and NuSMV version 2.6.0 with dynamic variable
reordering and cone-of-inﬂuence reduction. These options
were used to accelerate the veriﬁcation performance.
A. Effectiveness of OiL-CEGAR
The ﬁrst experiment was aimed at evaluating the effective-
ness of OiL-CEGAR using TS1 and TS2. TS1 contained eight
programs with varying sizes from 35 to 87 lines of codes and
two to three tasks in each application. TS2 contained 14 test
programs with 172 to 571 lines of code and ﬁve to seven
572
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE I
PROPERTY CHECKING RESULTS ON TS1 AND TS2
App #T LoC B(NB)V eriﬁcation Exec. chk.
Time(s)ResultV erif. w/o OS - CBMC V erif. w/o OS - YOGAR-CBMC
Time(s) #R Time(s) #U Result Time(s) #U Result
btmaster 3 87 5(1) 5.415 - 0.62 violated 0.38 2 WT 2.96 2 WP
btslave 3 86 5(1) 5.330 - 0.61 violated 0.37 2 WCS 2.12 2 WP
cubbyhole 3 37 2(0) 0.616 - - satisﬁed 1.59 2 WP 2.85 6 WP
eds 3 60 4(0) 0.656 - - satisﬁed 0.44 2 WP 42.37 6 WP
eventtest 2 35 6(4) 0.258 - - satisﬁed 614.05 12 WP 0.39 10 satisﬁed
message 3 68 5(2) 4.076 - - satisﬁed 0.39 2 WCS 0.30 6 WCS
resourcetest 2 54 9(0) 0.475 - - satisﬁed - 6 TO - 5 TO
tttest 2 48 6(4) 1.133 - - satisﬁed - 12 TO 0.23 5 satisﬁed
confo 1 6 172 4(2) 40 0 0.131 violated 0.47 2 WCS 0.55 2 WP
confo 2 5 329 9(0) 735 4 0.145 satisﬁed 2.41 2 WP 0.57 2 WP
confo 3 6 409 9(0) 498 1 0.350 satisﬁed 2.69 2 WCS 0.69 2 WP
confo 4 5 419 6(0) 360 3 0.158 violated 1.05 2 WP 1.79 6 WP
confo 5 5 419 13(0) 2166 3 0.224 satisﬁed 0.94 2 WP 0.53 2 WP
confo 6 6 305 17(0) 638 3 0.168 satisﬁed 51.29 2 WP - 2 TO
confo 7 6 505 12(0) 205 1 0.173 satisﬁed 1.02 2 WCS 0.42 2 WP
confo 8 6 317 17(0) 613 3 0.216 satisﬁed 58.41 2 WP - 2 TO
confo 9 5 362 11(0) 1521 3 0.153 satisﬁed 72.53 2 WCS 122.91 2 WP
confo 10 7 346 15(0) 2904 3 0.277 satisﬁed 2.65 2 WP 0.64 2 WP
confo 11 6 571 21(0) 280 1 0.118 violated 74.25 2 WT - 2 TO
confo 12 6 276 5(0) 157 0 0.211 violated 0.35 2 WP 0.31 2 WP
confo 13 6 310 12(0) 169 1 0.229 satisﬁed 0.58 2 WP 0.32 2 WP
confo 14 6 308 11(0) 167 1 0.236 satisﬁed 0.88 2 WP 0.42 2 WP
tasks. These programs were veriﬁed with the same property
P1, “A call to WaitEvent shall be followed by a matching call
toSetEvent ”.
Column one to eight of Table I show the veriﬁcation results
using OiL-CEGAR. From left to right, the columns show the
application id, the number of tasks, the lines of codes, the
number of branch statements with the number of nested branch
statements (in parentheses), the time needed for property
checking, the number of required reﬁnement iterations, the
time for executability checking of the generated counterexam-
ples, and the ﬁnal verdict of OiL-CEGAR, respectively.
Applications on TS1 reported two counterexamples, which
turned out to be true alarms, among the eight properties
checked using NuSMV . Six of them were veriﬁed to be true
in the ﬁrst round of OiL-CEGAR. All these applications were
checked without further reﬁnements as they did not contain
many branch conditions that were subject to abstractions.
Among the programs veriﬁed to be true, message took far
longer to check its properties, mainly because it has more tasks
containing several nested loops. While verifying the 14 appli-
cations in TS2, a total of 41 property checks using NuSMV
were performed (including veriﬁcation after reﬁnements); 31
of them reported counterexamples and ten were veriﬁed as
having no property violations. Executability checking was
performed on these 31 counterexamples and 27 (87.09%)
of them were found to be non-executable; these were used
for model reﬁnement. On average, 1.92 reﬁnements were
required on those 14 applications, which ultimately veriﬁed
ten programs and refuted four.
We manually analyzed all 22 programs to ensure that our
veriﬁcation results using OiL-CEGAR are accurate.B. Comparison with CBMC and Yogar-CBMC
In the second experiment, we applied two representative C
code model checking tools (CBMC [1] and Y ogar-CBMC [4])
to TS1 and TS2 to compare the veriﬁcation accuracy of
OiL-CEGAR to that of the best-known existing veriﬁcation
approaches for multitask programs. CBMC is the most stable
and widely used C code model checker for the veriﬁcation of
multi-threaded programs under arbitrary interleavings among
threads. Y ogar-CBMC implements CEGAR in CBMC and is
the 2017, 2018, and 2019 winner of the SV-COMP competition
in the veriﬁcation of concurrent programs.
We successively increased the loop bound from 2 to 21
when applying CBMC, until it either found a counterexample
or veriﬁed the property without violating the unwinding asser-
tion. Y ogar-CBMC automatically sets the loop bound during
the CEGAR process. We used a time bound of one hour for
both cases.
Columns nine to fourteen of Table I show the veriﬁcation
results. To the right of column nine, the columns show
the veriﬁcation time, the number of loop unwindings, the
veriﬁcation result of CBMC, and the veriﬁcation result of
Y ogar-CBMC, respectively.
CBMC and Y ogar-CBMC were unable to ﬁnd any exe-
cutable counterexample trace for any of the six programs
supposed to violate the property. Y ogar-CBMC was able to
verify two out of sixteen programs correctly, but CBMC was
not able to verify any of them. Even though they identiﬁed
counterexamples relatively quickly, they were all false alarms
caused by infeasible context switches (WCS), caused by
allowing two instances of a task running at the same time
(WT) or by allowing a task with lower priority to run prior to
a task with higher priority (WP), or took more than one hour
573
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. TABLE II
REACHABILITY CHECKING RESULTS ON WINLIFT
State
namesV eriﬁcation Exec. chk.
Time(s)Result C.E.
len Time(s) #R
close 1023.505 5 660.75 violated 17
lock 88.644 0 0.92 violated 14
locked 695.026 0 0.94 violated 19
open 709.907 4 661.92 violated 17
down 12063.295 5 2183.62 violated 22
stall 29495.099 7 11997.35 violated 21
up 18128.581 7 10093.52 violated 22
reverse 94347.096 17 12775.4 violated 23
of time bound (TO). Note that multiple activations of the same
task are possible, but only one of the activated tasks should
run if priority-based FIFO scheduling is used. As CBMC and
Y ogar-CBMC do not take this situation into account, false
alarms such as WT may occur.
The programs eventtest ,resourcetest , and tttest are costly
to verify, taking far more time for counterexample generation
or going over the time limit. This is because they contain a
nested loop or a large number of iterations, e.g., ﬁve million
iterations in one example.
C. Scalability to complex systems with alarms and ISRs
The last experiment aimed to check how expensive it is to
apply OiL-CEGAR to an application program with multiple
alarms and interrupt service routines (ISRs). Alarms period-
ically ﬁre requests to OS services. ISRs handle interrupts,
which may occur at any time. They usually have higher
priority than tasks, preempting the running task at arbitrary
times. This is a major source of complexity in the veriﬁcation
of multitasking programs.
The automotive window controller program in TS3 com-
prises 980 lines of code, consisting of ﬁve tasks, ﬁve alarms,
and one ISR. The controller has eight system states: close,
lock, locked, open, down, stall, up, and reverse. OiL-CEGAR
was applied to this program w.r.t. property P2:
P2. (For each system state) The system state is not reachable
from the initial state.
Table II shows the veriﬁcation results. OiL-CEGAR suc-
cessfully identiﬁed counterexamples for all eight states, show-
ing that all states were reachable after 0 to 17 reﬁnement
iterations. The length of the generated counterexamples ranged
from 14 to 23. The cost for the veriﬁcation was quite high. For
example, checking reverse took over 26 hours for 17 iterations
of property checking and over 3.5 hours for executability
checking using CBMC. However, the veriﬁcation result was
100% accurate.
D. Threats to validity
OiL-CEGAR guarantees that property violations are found
when a sound OS model is used, but does not guarantee
that all false alarms will be identiﬁed, unless the model is
also complete. The use of a sound OS model is a neces-
sary prerequisite for OiL-CEGAR, as it may not be able to
identify real alarms in the ﬁrst place if this is not the case,which is a common requirement for most formal model-based
approaches. Available formal OS models [5]–[8] are sound,
but might not be complete w.r.t time-dependent behaviors due
to the use of relative timing. Our experiments showed 100%
veriﬁcation accuracy because the properties were not time-
dependent.
The pre-processing applied to the application source code,
such as the ﬂattening of data structures and the use of
ﬁxed-size primitive data types, assumes that the program
does not contain any data structure with undeﬁned size, as
recommended by the MISRA-C standard. If this assumption
is not fulﬁlled, the pre-processing might not be sound and
should better be replaced by data abstraction [36] or predicate
abstraction [17], which guarantee soundness. We also limited
the value ranges of the ﬁxed-size variables in the model
because NuSMV is not good at dealing with variables over
a large range. This data abstraction should be performed
with care, e.g., by using value analysis [37], in order not to
undermine the soundness of the model.
Though our experiments showed great improvement of ver-
iﬁcation accuracy, OiL-CEGAR might not be able to identify
non-executable counterexample traces, as we considered only
ﬁnite subtraces of possible inﬁnite traces. Similar to existing
CEGAR approaches, OiL-CEGAR might not terminate as it
might reﬁne the model inﬁnitely, e.g., when a task contains
an inﬁnite loop.
Our experiments were limited to API call constraint check-
ing and reachability checking. However, OiL-CEGAR can also
be used for general property checking with minor changes in
task annotation, as NuSMV is capable of checking LTL and
CTL properties and CBMC is used only for a bounded search
of the counterexample trace.
VIII. R ELA TED WORK
Numerous approaches for verifying embedded control soft-
ware exist, which can be divided into three categories: (1)
veriﬁcation of application programs with a highly abstracted
scheduling policy [1]–[4], [38]; (2) veriﬁcation approaches
for OS [5]–[8] that focus on the correctness of either OS
models or implementations; and (3) a number of recent works
on the veriﬁcation of embedded programs with veriﬁed OS
models [25], [32], [39]–[41].
A. V eriﬁcation with a highly abstracted scheduling policy
This approach has been a main stream in research and
practice for model checking multitasking programs. The ap-
proaches in [1]–[4], [38] assume arbitrary interleavings among
tasks, but reduce veriﬁcation complexity by either using partial
order reduction or limiting the number of context switches
among tasks. Lazy-CSeq [3], [42] further improves veriﬁcation
performance by predicting a range of values on numeric typed
variables [43]. References [4], [44] apply CEGAR under the
assumption of arbitrary interleavings among tasks. Notably,
references [4] found that most of the CNF formulas generated
by CBMC are related to the scheduling constraint that checks
sequential consistency [45] of shared variables, and applied
574
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. CEGAR on the scheduling constraint to achieve better perfor-
mance.
These approaches suffer from a high rate of false alarms
by allowing arbitrary sequences of task executions, as demon-
strated through our experiments.
B. V eriﬁcation of application software with OS
There are approaches that use veriﬁed OS models to reason
about application programs. References [22], [32], [40], [46]
veriﬁed embedded programs with a formal OS model using
Spin [28] or NuSMV by translating the application program
into the modeling language used to model the operating
system. Due to the difference in expressiveness between the
implementation language and the modeling language, it is
unavoidable that these approaches introduce abstractions into
the translation process, which can be a source of false alarms.
It is also predicted that faithful translation would result in high
veriﬁcation cost. These issues are not treated in the existing
approaches. Reference [25] is unique in that the application
program is implicitly converted into rewrite logic within the
K-framework, which is equipped with language interpreters
for C, Java, and JavaScript. However, it suffers from high
veriﬁcation cost due to the use of faithful interpretation of
the program code as well as the formal OS model.
C. Reﬁnement methods
Techniques for improving the efﬁciency of model reﬁne-
ments have been an active research issue [4], [13]–[16].
Studies [4], [13], [14] reﬁne the CNF formula using SA T-
core [47], which is a subset of the formula that is sufﬁcient
for establishing inconsistency with a counterexample. In trace
abstraction reﬁnement [15], [16], the program is abstracted
so that arbitrary execution of statements is possible and non-
executable counterexamples are iteratively excluded from the
model by checking the post-condition of each statement. The
reﬁnement in OiL-CEGAR is conceptually similar to trace
abstraction reﬁnement, but is different in that it uses the
scheduling information of the counterexample and the model
checker CBMC to identify non-executable counterexamples.
IX. D ISCUSSION
We have presented a novel approach named OiL-CEGAR
for accurately verifying multitasking embedded software using
a formally veriﬁed OS model in the CEGAR process. OiL-
CEGAR also alleviates the burden of executability checking in
the domain of embedded software, which requires a platform-
dependent HW/SW environment setting, by constructing a
mini-OS that can act as a test driver simulating feasible exe-
cution sequences of multiple tasks. Our experimental results
revealed that OiL-CEGAR had 100% veriﬁcation accuracy
with moderately increased cost, while CBMC and Y ogar-
CBMC showed an accuracy of under 11.1% and all the
counterexamples included incorrect task execution sequences.A. Why model-based?
One might argue that code-based veriﬁcation is more prac-
tical and efﬁcient, as model-based approaches require extra
work, whereas we can apply C code model checking directly
to C source code. This is not true if we have to take the OS
behavior into account because the OS implementation typically
involves platform-dependent libraries and direct access to
hardware. Abstraction and modeling are therefore necessary.
We can perform abstractions at the code level or translate the
OS model into the C language and perform code-level model
checking. If we do this, however, we lose all the powerful
support of the modeling language, such as implicit support
for concurrency, atomicity, and blocking and restarting of a
process. These constructs are essential for an OS and must
be explicitly modeled in C, resulting in higher complexity
in veriﬁcation. In addition, model-based veriﬁcation performs
property checking over inﬁnite traces while code-based veri-
ﬁcation is typically limited to ﬁnite traces.
In fact, we did try code-level model checking using CBMC
and Y ogar-CBMC on the same set of programs used in
the experiments, by converting the OS model into the C
language. Though code-level model checking was faster than
OiL-CEGAR on small-scale programs such as TS1 and TS2,
neither CBMC nor Y ogar-CBMC were able to ﬁnd any reach-
able state on TS3 within 26 hours, the longest OiL-CEGAR
took to ﬁnd each reachable control state. CBMC was able to
determine that the lock state was reachable within 20 minutes
only after we manually removed four tasks from Winlift and
limited the number of alarm occurrences to ﬁve.
B. Trace reﬁnement vs. predicate reﬁnement
OiL-CEGAR uses trace reﬁnement after identifying false
alarms, instead of using typical predicate reﬁnement as in
SLAM or BLAST [17], because it is simpler to apply it to
NuSMV models using constraints and invariants. The two ap-
proaches are orthogonal to each other, one reﬁning predicates
considering all execution paths and the other pruning infeasible
traces considering all possible values of the predicate for a
given trace.
C. Scalability
The use of a formal OS model in the reﬁnement loop
increases both veriﬁcation accuracy and veriﬁcation cost. The
cost for checking complex embedded software with multiple
alarms and ISRs is still very high, but, to the best of our
knowledge, this is the ﬁrst experiment showing high veriﬁca-
tion accuracy in this domain under such complexity. Improving
the scalability of OiL-CEGAR is our next research goal.
ACKNOWLEDGMENTS
This research has been supported by the Basic Science
Research Program through the National Research Founda-
tion of Korea (NRF), funded by the Ministry of Education
(NRF-2016R1D1A3B01011685), and by the Next-Generation
Information Computing Development Program through the
National Research Foundation of Korea (NRF), funded by the
Ministry of Science, ICT (No. 2017M3C4A7068175).
575
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] E. Clarke, D. Kroening, and K. Y orav, “Behavioral consistency of c and
verilog programs using bounded model checking,” in Proceedings of the
40th Annual Design Automation Conference , 2003, pp. 368–371.
[2] I. Rabinovitz and O. Grumberg, “Bounded model checking of concurrent
programs,” in International Conference on Computer Aided V eriﬁcation ,
2005, pp. 82–97.
[3] O. Inverso, E. Tomasco, B. Fischer, S. La Torre, and G. Parlato,
“Bounded model checking of multi-threaded c programs via lazy sequen-
tialization,” in International Conference on Computer Aided V eriﬁcation ,
2014, pp. 585–602.
[4] L. Yin, W. Dong, W. Liu, and J. Wang, “Scheduling constraint based
abstraction reﬁnement for multi-threaded program veriﬁcation,” CoRR ,
vol. abs/1708.08323, 2017.
[5] H. Chen, X. N. Wu, Z. Shao, J. Lockerman, and R. Gu, “Toward com-
positional veriﬁcation of interruptible OS kernels and device drivers,” in
Proceedings of the 37th ACM SIGPLAN Conference on Programming
Language Design and Implementation , 2016, pp. 431–447.
[6] Y . Choi, “Model checking trampoline OS: a case study on safety analysis
for automotive software,” Software Testing, V eriﬁcation and Reliability ,
vol. 24, no. 1, pp. 38–60, 2014.
[7] H.-P . Deifel, M. G ¨ottlinger, S. Milius, L. Schr ¨oder, C. Dietrich, and
D. L ¨ohmann, “Automatic veriﬁcation of application-tailored OSEK
kernels,” in 2017 F ormal Methods in Computer Aided Design (FMCAD) ,
2017, pp. 196–203.
[8] Y . Huang, Y . Zhao, L. Zhu, Q. Li, H. Zhu, and J. Shi, “Modeling and
verifying the code-level OSEK/VDX operating system with CSP,” in
2011 Fifth International Conference on Theoretical Aspects of Software
Engineering , 2011, pp. 142–149.
[9] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. V eith, “Counterexample-
guided abstraction reﬁnement,” in Proceedings of the 12th International
Conference on Computer Aided V eriﬁcation , July 2000, pp. 154–169.
[10] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre, “Lazy abstrac-
tion,” in Proceedings of the 29th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages , 2002, pp. 58–70.
[11] A. Cimatti, E. Clarke, F. Giunchiglia, and M. Roveri, “Nusmv: A new
symbolic model veriﬁer,” in International conference on computer aided
veriﬁcation . Springer, 1999, pp. 495–499.
[12] T. Kuroiwa, Y . Aoyama, and N. Kushiro, “A hybrid testing environment
between execution test and model checking for IoT system,” in IEEE
International Conference on Consumer Electronics (ICCE) , 2019, pp.
1–2.
[13] K. L. McMillan, “Lazy abstraction with interpolants,” in International
Conference on Computer Aided V eriﬁcation , 2006, pp. 123–136.
[14] S.-W. Lin, J. Sun, T. K. Nguyen, Y . Liu, and J. S. Dong, “Interpolation
guided compositional veriﬁcation (t),” in 2015 30th IEEE/ACM Inter-
national Conference on Automated Software Engineering (ASE) , 2015,
pp. 65–74.
[15] M. Heizmann, J. Hoenicke, and A. Podelski, “Reﬁnement of trace
abstraction,” in International Static Analysis Symposium , 2009, pp. 69–
85.
[16] F. Cassez and F. Ziegler, “V eriﬁcation of concurrent programs using
trace abstraction reﬁnement,” in Logic for Programming, Artiﬁcial
Intelligence, and Reasoning , 2015, pp. 233–248.
[17] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar, “The software
model checker Blast: Applications to software engineering,” Interna-
tional Journal on Software Tools for Technology Transfer , vol. 9, no. 5,
pp. 505–525, Oct. 2007.
[18] T. Ball, E. Bounimova, B. Cook, V . Levin, J. Lichtenberg, C. McGarvey,
B. Ondrusek, S. K. Rajamani, and A. Ustuner, “Thorough static analysis
of device drivers,” ACM SIGOPS Operating Systems Review , vol. 40,
no. 4, pp. 73–85, 2006.
[19] G. Klein, K. Elphinstone, G. Heiser, J. Andronick, D. Cock, P . Derrin,
D. Elkaduwe, K. Engelhardt, R. Kolanski, M. Norrish etal., “seL4:
Formal veriﬁcation of an OS kernel,” in Proceedings of the ACM
SIGOPS 22nd symposium on Operating systems principles , 2009, pp.
207–220.
[20] S. P . Jones, Haskell 98 language and libraries: the revised report .
Cambridge University Press, 2003.
[21] OSEK Group, “OSEK/VDX operating system speciﬁcation,” 2005.
[22] H. Zhang, G. Li, Z. Cheng, and J. Xue, “V erifying OSEK/VDX auto-
motive applications: A spin-based model checking approach,” Software
Testing, V eriﬁcation and Reliability , vol. 28, no. 3, p. e1662, 2018.[23] Y . Choi, “A conﬁgurable V&V framework using formal behavioral
patterns for OSEK/VDX operating systems,” Journal of Systems and
Software , vol. 137, pp. 563–579, 2018.
[24] J. Bengtsson, K. Larsen, F. Larsson, P . Pettersson, and W. Yi, “Up-
paal—a tool suite for automatic veriﬁcation of real-time systems,” in
International hybrid systems workshop . Springer, 1995, pp. 232–243.
[25] X. Zhu, M. Zhang, J. Guo, X. Li, H. Zhu, and J. He, “Toward a uniﬁed
executable formal automobile OS kernel and its applications,” IEEE
Transactions on Reliability , pp. 1–17, 2018.
[26] “Zephyr project,” https://www.zephyrproject.org/.
[27] “Freertos - market leading rtos for embedded systems with internet of
things extensions,” https://www.freertos.org/.
[28] G. J. Holzmann, “The model checker SPIN,” IEEE Transactions on
software engineering , vol. 23, no. 5, pp. 279–295, 1997.
[29] C. G. Cassandras and S. Lafortune, Introduction to discrete event
systems . Springer Science & Business Media, 2009.
[30] MISRA-C:2012: Guidelines for the use of the C language in critical
systems , 2013.
[31] P . Godefroid and P . Wolper, “Using partial orders for the efﬁcient
veriﬁcation of deadlock freedom and safety properties,” in International
Conference on Computer Aided V eriﬁcation . Springer, 1991, pp. 332–
342.
[32] D. Kim and Y . Choi, “A two-step approach for pattern-based API-call
constraint checking,” Science of Computer Programming , vol. 163, pp.
19–41, 2018.
[33] “nxtOSEK: ANSI C/C++ with OSEK/μITRON RTOS for LEGO MIND-
STORMS NXT,” http://lejos-osek.sourceforge.net/.
[34] Y . Choi and T. Byun, “Constraint-based test generation for automotive
operating systems,” Software & Systems Modeling , vol. 16, no. 1, pp.
7–24, 2017.
[35] “WinLift application distributed with CodeWarrior V5.1,” https://www
.nxp.com/support/developer-resources/software-development-tools/code
warrior-development-tools/downloads:CW DOWNLOADS.
[36] Y . Kesten and A. Pnueli, “Control and data abstraction: The cornerstones
of practical formal veriﬁcation,” International Journal on Software Tools
for Technology Transfer , vol. 2, no. 4, pp. 328–342, 2000.
[37] G. Canet, P . Cuoq, and B. Monate, “A value analysis for c programs,”
in2009 Ninth IEEE International Working Conference on Source Code
Analysis and Manipulation , 2009, pp. 123–124.
[38] X. Wu, Y . Wen, L. Chen, W. Dong, and J. Wang, “Data race detection for
interrupt-driven programs via bounded model checking,” in 2013 IEEE
Seventh International Conference on Software Security and Reliability
Companion , 2013, pp. 204–210.
[39] T. V ¨ortler, B. H ¨ockner, P . Hofstedt, and T. Klotz, “Formal veriﬁcation
of software for the Contiki operating system considering interrupts,” in
2015 IEEE 18th International Symposium on Design and Diagnostics
of Electronic Circuits & Systems , 2015, pp. 295–298.
[40] H. Zhang, T. Aoki, and Y . Chiba, “Yes! you can use your model checker
to verify OSEK/VDX applications,” in 2015 IEEE 8th International
Conference on Software Testing, V eriﬁcation and V alidation (ICST) ,
2015, pp. 1–10.
[41] Y . Chung, D. Kim, and Y . Choi, “Modeling OSEK/VDX OS require-
ments in C,” in Asia-Paciﬁc Software Engineering Conference (APSEC) ,
2017, pp. 398–407.
[42] O. Inverso, E. Tomasco, B. Fischer, S. La Torre, and G. Parlato, “Lazy-
CSeq: a lazy sequentialization tool for C,” in International Conference
on Tools and Algorithms for the Construction and Analysis of Systems ,
2014, pp. 398–401.
[43] T. L. Nguyen, B. Fischer, S. La Torre, and G. Parlato, “Concurrent
program veriﬁcation with lazy sequentialization and interval analysis,”
inInternational Conference on Networked Systems , 2017, pp. 255–271.
[44] C. Popeea and A. Rybalchenko, “Threader: a veriﬁer for multi-threaded
programs,” in International Conference on Tools and Algorithms for the
Construction and Analysis of Systems , 2013, pp. 633–636.
[45] S. V . Adve and K. Gharachorloo, “Shared memory consistency models:
A tutorial,” Computer , vol. 29, no. 12, pp. 66–76, 1996.
[46] L. Waszniowski and Z. Hanz ´alek, “Formal veriﬁcation of multitask-
ing applications based on timed automata model,” Real-Time Systems ,
vol. 38, no. 1, pp. 39–65, 2008.
[47] A. Belov, H. Chen, A. Mishchenko, and J. Marques-Silva, “Core min-
imization in SA T-based abstraction,” in Proceedings of the Conference
on Design, Automation and Test in Europe , 2013, pp. 1411–1416.
576
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:25:32 UTC from IEEE Xplore.  Restrictions apply. 