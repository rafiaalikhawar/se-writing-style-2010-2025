An Empirical Study of Goto in C Code from GitHub
Repositories
Meiyappan Nagappan1, Romain Robbes2, Y asutaka Kamei3, √âric Tanter2,
Shane McIntosh4, Audris Mockus5, Ahmed E. Hassan6
1Rochester Institute of Technology, Rochester, NY , USA;2Computer Science Department (DCC),
University of Chile, Santiago, Chile;3Kyushu University, Nishi-ku, Japan;4McGill University, Montreal,
Canada;5University of Tennessee-Knoxville, Knoxville, Tennessee, USA;6Queen‚Äôs University,
Kingston, Ontario, Canada
1mei@se.rit.edu,2{rrobbes, etanter}@dcc.uchile.cl,3kamei@ait.kyushu-u.ac.jp,
4shanemcintosh@acm.org,5audris@utk.edu,6ahmed@cs.queensu.ca
ABSTRACT
It is nearly 50 years since Dijkstra argued that goto ob-
scures the ow of control in program execution and urged
programmers to abandon the goto statement. While past
research has shown that goto is still in use, little is known
about whether goto is used in the unrestricted manner that
Dijkstra feared, and if it is `harmful' enough to be a part of
a post-release bug. We, therefore, conduct a two part em-
pirical study - (1) qualitatively analyze a statistically rep-
resentative sample of 384 les from a population of almost
250K C programming language les collected from over 11K
GitHub repositories and nd that developers use goto in C
les for error handling (80 :215%) and cleaning up resources
at the end of a procedure (40 :365%); and (2) quantita-
tively analyze the commit history from the release branches
of six OSS projects and nd that no goto statement was re-
moved/modied in the post-release phase of four of the six
projects. We conclude that developers limit themselves to
using goto appropriately in most cases, and not in an un-
restricted manner like Dijkstra feared, thus suggesting that
goto does not appear to be harmful in practice.
Categories and Subject Descriptors
D.3.3 [ Language Constructs and Features ]: Control
structures; D.2.9 [ Management ]: Software quality assur-
ance (SQA)
Keywords
Use of goto statements, Empirical SE, Github, Dijkstra
1. INTRODUCTION
In the March 1968 issue of the Communications of the
ACM , Edsger W. Dijkstra published his observations of the
problems caused by using goto statements in programs, ti-
tled Letters to the Editor: Go To Statement ConsideredHarmful [11]. This is one of the many works of Dijkstra
that is frequently discussed by software practitioners [25]
and researchers alike (more than 1,300 citations according
to Google Scholar and almost 4000 citations according to
ACM Digital Library as of Aug 15, 2014). This article has
also resulted in a slew of other articles of the type global
variables considered harmful [32], polymorphism considered
harmful [24], fragmentation considered harmful [16], among
many others. In fact, Meyer claims that as of 2002, there
are thousands of such articles, though most are not peer-
reviewed [15].
Indeed, Dijkstra's article [11] has had a tremendous im-
pact. Anecdotally, several introductory programming courses
instruct students to avoid goto statements solely based on
Dijkstra's advice. Marshall and Webber [19] warn that when
programming constructs like goto are forbidden for long
enough, they become dicult to recall when required.
Dijkstra's article on the use of goto is based on his de-
sire to make programs veriable. The article is not just an
opinion piece; as Koenig points out [7], Dijkstra provides
strong logical evidence for why goto statements can intro-
duce problems in software.
Since Dijkstra's article, several authors have theoretically
analysed the harmfulness (and sometimes benets) of goto
(Section 2), but there are seldom any empirical studies on
them. In the recent past, two studies examined the use of
goto in C code for error-handling. However, they focus on
improving the error handling mechanism [28, 29], and not
to characterize the use of goto statements in practice by
developers or examine their harmfulness.
Perhaps surprisingly, this topic is still highly discussed
and debated by developers. In Stackoverow a topic ti-
tled \GOTO still considered harmful?" has been viewed
more that 32K times with hundreds of votes to over 50 an-
swers [25]. In all these cases, the developers are replying
based on their own opinion and interpretation of Dijkstra's
article and the use of goto. Recently, a preprint version
of this paper has garnered over 7,000 views, and has been
downloaded more than 3,700 times [22].1This pre-print was
also the subject of a lively discussion with almost 600 com-
ments on Slashdot [26].
Therefore, motivated by the overwhelming interest shown
1The preprint appears as a non-peer reviewed article in the
PeerJ archive, which is compatible with further submission
to a peer-reviewed venue.by developers in this question, we empirically examine the
use of goto statements in modern software projects by soft-
ware developers after ascertaining that goto is indeed widely
used. Our experiments are designed to empirically iden-
tify whether goto statements are used in a disciplined|and
hence harmless|way or in the complex way that Dijkstra
feared would be be harmful (such as the recent case that re-
sulted in the security vulnerability in Apple iOS7 [8]). More
precisely, we carry out a two-dimensional case study of C
source code les from software repositories|a broad quali-
tative study on a statistically representative sample of code
from 11,627 repositories hosted by GitHub [3] followed by a
focussed quantitative study on specic releases of six Open
Source Software (OSS) projects to address the following re-
search questions:
RQ1: What are goto statements used for?
We nd that goto statements are used for 5 main pur-
poses. Among these, the most prevalent are handling
errors andcleaning up resources at the end of a proce-
dure (80 :215% and 40 :365% respectively).
RQ2: Do developers remove/modify goto statements?
We nd that no goto statement is removed/modied as
part of post-release bug xes in four of the six projects.
In the remaining two projects, goto was removed/-
modied only in a dozen bug x commits.
Therefore, goto is still very much used, but mostly fol-
lowing well-structured, harmless patterns. Note that there
are several possible hypotheses as to why goto is used in
such a disciplined manner. It could be that developers have
restricted their use of goto to specic controlled scenarios
because of Dijkstra's advice, or it could simply be based
on a natural evolutionary path, among others. This paper
does not pretend to shed light on these hypotheses, only to
empirically characterize the use of goto in practice.
2. BACKGROUND AND RELATED WORK
Dijkstra thought that the title of the article [11] misrep-
resented the actual argument he tried to make. He explains
that his article is referenced `often by authors who had seen
no more of it than its title' .2Therefore, we start with a
detailed discussion of the arguments given by Dijkstra in or-
der to provide context to the reader, and then discuss related
work that examined Dijkstra's communication.
2.1 Background
Dijkstra begins the article by stating that in his observa-
tion of programmers and programs, the use of goto state-
ments has `disastrous eects' . This is the reason why he
believes that goto statements should not be used in high
level languages, in which most current software is written.
He then goes on to explain why the goto statements can
have disastrous eects and what those eects might be.
The objective is for a programmer to be able to establish
clear assertions about the state of the executing program at
each line of code. Dijkstra then observes that the use of goto
statements in a program can make it dicult to determine
the exact set of statements that has been executed before
reaching a given label block.
Dijkstra explains that, in a language with procedures, one
can characterize the progress of a process with a coordinate
2All italicized text within single quotes in this section are
direct quotes from Dijkstra.system that consists of a sequence of textual indices|the
sequence of procedure calls (the call stack) followed by a
single point in the currently-executing procedure. With the
inclusion of repetition clauses such as while , one needs an
additional dynamic index. Reasoning is supported because
the repetition structure, like recursion, is amenable to induc-
tive reasoning. In any case, the crux of the argument is that
the coordinate system is independent of the programmer. In
contrast, in the case of goto statements `it becomes terribly
hard to nd a meaningful set of coordinates in which to de-
scribe the process progress' . In essence, `The go to statement
as it stands is just too primitive; it is too much an invitation
to make a mess of one's program.'
2.2 Related Work
In this subsection, we present related work (essays and
articles) done by others who have either carried out their
own analysis on the use of goto statements, or have critically
analyzed Dijkstra's article.
Analyzing the use of goto statements: The article
by Knuth [17] is probably one of the earliest works analyz-
inggoto statements, since Dijkstra's article was published.
Knuth clearly prefaces the article by stating that only his
`opinions' are expressed. His goal for the article is to provide
a fair discussion of both the pros and cons of goto state-
ments. He believes that the discussion should not be about
eliminating goto statements but about program structure.
He points out that in fact several cases of goto elimination is
merely replacing goto statements with other `euphemisms' .
Knuth [17] believes that goto statements must not be used
for error exists or loop creation, but only used to elimi-
nate recursion, boolean variables, and co-routines. He even
quotes Dijkstra to drive home the point: `Please don't fall
into the trap of believing that I am terribly dogmatical about
[the go to statement]. I have the uncomfortable feeling that
others are making a religion out of it, as if the conceptual
problems of programming could be solved by a single trick, by
a simple form of coding discipline!' . More recently Saha et
al.examine how goto statements are used for error-handling
and propose approaches to improve the error-handling mech-
anism in C code [28, 29]. Similarly Alnaeli et al. examine
the extent of goto statements in for-loops. Their goal is to
parallelize for-loops and goto can prevent this goal. When
empirically evaluating their approaches [6, 28, 29], they nd
that goto is still extensively used in system projects written
in the C programming language. However, the studies by
Saha et al. [28, 29] and Alnaeli et al. [6] are not about ex-
amining all the dierent ways in which developers use goto,
but just focussed on the use of goto for a single purpose.
Our study complements their studies by providing evidence
of when goto statements are used, and hence their work and
other future work can build solutions to take goto state-
ments into account or help avoid it if needed.
Analyzing Dijkstra's article: In his retrospective es-
say, Tribble [14] provides an annotated version of Dijkstra's
article, and also analyzes the relevance of the article in the
year 2005. He questions whether goto statements are even
needed, when developers are using languages that were de-
veloped well after Dijkstra's article was published. He con-
cludes that (in contrast to Knuth [17]) certain complex goto
statements cannot be avoided if the programming language
does not provide dedicated constructs for exiting nested loops
or for error handling. Since programming languages like Cdo not have an explicit error handling mechanism (exception
handling) like C++/Java, the developers who write their
software in C have to resort to using goto statements. In
the qualitative empirical analysis in RQ1 (Section 5), we ex-
amine if developers are indeed using goto for error handling
and for exiting out of loops among other purposes.
There are several references in the literature [13, 7, 17]
about heated discussions and analysis on Dijkstra's article
among practitioners. One such recorded discussion [25] can
be found on StackOverow, a community `question and an-
swer' website for developers. The consensus is that goto
statements need not be eliminated entirely, but just the `un-
constrained' use of it should be avoided. Another such dis-
cussion was among well-renowned Linux kernel developers|
Robert Love, Rik van Riel, and Linus Torvalds [27]. Their
position is that goto can be used when there is a real need
for it and that, if used carefully, goto is not harmful.
Unlike prior work, which have taken logical, argumenta-
tive, and example-based approaches, we use an empirical one
to identify, classify and quantify the dierent actual uses of
goto statements in real-world C code, and examine if goto
is harmful enough that developers removed/modied them
as part of post-release bug xes in a software project. While
the previous work is in no way incorrect or insucient, we
believe that adding empirical evidence can only further help
the discussion.
3. DATA SOURCE
In order to examine empirically the use of goto statements
along the two research questions we have, we used two dier-
ent data sources. In both datasets, we restrict our analysis
to C les only (excluding C header (".h") les), since (1) it
is a widely-used language; and (2) it provides the goto con-
struct; Additionally, we wanted to examine the use of goto
statements without any confounding factors based on dier-
ent programming languages. By restricting to just one pro-
gramming language we can place the results in context, and
have more condence about the conclusions with respect to
software projects written in C. Below we describe the data
source used for each research question and the reasons for
choosing them.
Data Source for RQ1: In this research question, we
want to understand the purpose of goto statements as used
by a variety of developers in their code. Hence studying
the programming practices of developers from a small set of
projects may not be sucient. Therefore, we use the source
code in the hundreds of thousands of software projects mined
by one of the coauthors [20]. We use a snapshot of the
project's software repositories (that are being continuously
mined) from January 2013. We restrict our analysis to soft-
ware projects that have their source code repositories on the
GitHub hosting service. This is because, GitHub hosts sev-
eral million repositories from several hundreds of thousands
of developers. Hence we will be able to examine developer
practices with respect to goto statements among a wide va-
riety of developers. From this collection of software projects
we extract all projects that have C les.
Not all repositories on GitHub represent actual software
projects. We ltered out projects with less than 10 les
written in any programming language to eliminate a bulk
of non-software projects, and very small software projects.
We chose the cuto at 10 as it appeared to provide a bal-
ance between eliminating most irrelevant repositories whileTable 1: Overview of the studied systems (RQ2).
Product Domain Version Tag name Lines of
code
ClamAV Antivirus 0.98 clamav-0.98 2,043,360
GIMP Image Ma-
nipulation2.8.0 GIMP 280 960,106
GhostScript Interpreter 9.01 ghostscript-
9.011,274,249
OpenLDAP Directory
Access
Protocol2.4.6 OPENLDAP R
ELENG 246303,917
Postgresql Database 9.3.0 REL9 30 963,900
VTK Visualization
Toolkit5.10.0 v5.10.0 2,910,353
leaving us with a sizable sample of repositories. While this
sample contains some repositories unrelated to software de-
velopment identifying them automatically on the scale of
GitHub is a research topic by itself, well beyond the scope
of this paper.
The ltered sample has 11,627 projects with C code. A
typical empirical software engineering study examines under
10 projects [23], and this larger sample should help with the
generalizablity of our conclusions (albeit in the context of
source code written in C and hosted on GitHub).
In the nal data cleaning step we ltered out les we iden-
tied as automatically generated. Such les are not directly
maintained, and, consequently, do not shed light on how de-
velopers are using goto statements. To develop the ltering
procedure, we manually examined a random sample of les
with hundreds of goto statements to identify if any of them
were generated. Every generated le had the word `generate'
in the comments at the beginning of the le. Our ltering,
therefore, searches for the word `generate' in each le. If
the term occurs, we then lter the le from the dataset.
The threats that arise due to not removing generated les
are discussed in Section 7. The cleaned sample contains
2,150,387 les written in the C programming language from
11,627 projects hosted on GitHub.
Data Source for RQ2: We would like to know what
impact goto statements have on the incidence of post-release
bugs: a popular proxy for software quality [30] because not
all bugs are of equal concern. Bugs that could be xed in
development and testing are of much lesser concern than
bugs that escape quality assurance steps and aect software
users. We focus on post-release bugs, which are not detected
until after the software is made available to end users.
To identify post-release bugs, we consider code changes
that occur on or that have been merged into the release
branch of a studied system. Such changes are often the re-
sult of bugs found after the release of software and these
changes are pushed to customers as part of a software up-
date. As a result, changes that land on a release branch
after a release are more strictly controlled than a typical
development branch to ensure that only the appropriately
triaged high-priority xes land in maintenance releases. In
other words, the changes that we study correspond to the
maintenance of ocial software releases.
Unfortunately, the overwhelming majority of projects ex-
amined in RQ1 do not contain carefully triaged release-
related changes. Hence, to address RQ2, we selected six
software projects primarily implemented in C with well-
established branching policies for deeper analysis. Theseprojects are selected from a variety of domains, ages, and
sizes to help with the generality of our conclusions. Some
of these projects like GIMP are used by millions of end
users [2], while others like Postgresql are used by promi-
nent industrial users such as Nasa [12], and Instagram [18].
Table 1 provides an overview of the studied systems.
4. PRELIMINARY ANALYSIS: Do develop-
ers use goto statements in their source code?
4.1 Motivation
Before we examine whydevelopers use goto statements,
we rst need to determine ifthey even use goto in the source
code of their software. Even though, past studies have shown
that goto statements are still in use [28, 29], we want to ex-
amine if our dataset of diverse projects have goto statements
in them and ascertain the true extent of goto usage.
4.2 Approach
Among the 2,150,387 source code les used in our study,
we determine which ones have a goto statement in it. We
do this by using the grep functionality for searching and use
the regular expression
([ \t]+goto|^goto)[ \t]+.*;
We determine not just if a le has a goto statement, but
also how many goto statements exist in each le.
4.3 Results
Considerable use of goto at the le level: We nd
that 246,657 out of the 2,150,387 les (or 11.47%) examined
in our study have at least one goto statement. Both the raw
number and the percentage of les that have a goto state-
ment indicates that the use of goto statements by developers
who work on software projects written in C and hosted in
GitHub, are quite common. The result agrees with the re-
sults of Saha et al. [28] { who found that there are almost
20K functions in Linux-2.6.34 that have a goto statement.
We also nd that most les have very few goto statements.
In fact 14.43% of les with goto had only one goto. How-
ever, there are those rare occasions where there exists a le
with more than 100 goto statements (0.55% of the les with
goto).
More than one-fourth of the projects used a goto:
In order to check if all the les with goto are just found in
a few projects, we calculate the distribution of goto state-
ments at the project level. We nd that 3,093 out of the
11,627 projects (or 26.60%) have at least one le with a goto
statement. We also nd that more than half the projects
have about 20% of the les that have at least one goto state-
ment.



	A considerable number of projects have les with
goto in them. Thus despite the popularity of Dijk-
stra's case against goto , developers use goto state-
ments considerably.
4.4 Discussion
When examining the path hierarchy and names of les
with and without goto statements in them, we noticed that
several of them looked like system code, i.e. they had thewords linux/android/kernel/driver (which is consistent with
the ndings of Saha et al. [28], who report that more than
half of the goto statements are in the driver directory of
Linux-2.6.34). To better characterize the context of use of
goto statements, we examine the number of \system les"
(source code les for hardware drivers, operating system
kernel etc.) in the dataset. A search for the keywords lin-
ux/android/kernel/driver in le names revealed that 454,670
les (21.14%) were system les. Of course, we could have
missed some system les, but due to the size of the dataset,
we were restricted to using such a heuristic, whose preci-
sion was veried with a manual analysis in RQ1 (Section 5).
Among the les that had a goto statement, we found that
169,523 (or 68.72%) were system les. Thus, we nd that
there is a greater concentration of goto statements in system
les than non-system les.
5. RQ1: What are goto statements used for?
5.1 Motivation
Beyond the raw frequency of goto usage, we were also
interested in howdevelopers are using them. This is because
not all usages of goto are created equal. Some goto usage
may be part of relatively harmless patterns, while others
may be much more nefarious [17], severely hampering the
readability of the source code. A related concern is that
goto statements may be used in various domains, and may
be used dierently in these domains.
5.2 Approach
We, therefore, conducted a qualitative study of the us-
ages of gotos on two levels: the le level, to understand
the domain in which goto statements were used, and gur-
ing out whether many false positives were due to generated
code; and the function level, to understand patterns of us-
age of goto statements, their interactions, and their impact
on the function comprehensibility. We performed the latter
analysis at the function level, since the scope of the goto
statements and the labels that they refer to are at the func-
tion level. We discuss the process for our qualitative study
in detail below (as it will help us and the reader place the
results and conclusions in context).
1. Sample Selection: The population of C les that
we examined for the presence of goto statements in RQ1
is 2,150,387. However, we want to study the patterns of us-
age of goto. Hence our true population is the set of les
with goto statements, i.e., 246,669 C les. We split this
population into two buckets - les with more than 5 goto
statements, and les with 5 or less goto statements, where
5 is the median number of goto statements in a le. From
each bucket we pick 192 les at random, to end up with a
total of 384 C les with goto statements. By examining 384
les from 246,669 les, we achieve a condence level of 95%
with a condence interval of 5% [5]. We use this sample of
384 les to perform the qualitative analysis at the le level.
In order to carry out our qualitative analysis at the func-
tion level, we take the sample of 384 les chosen for the
qualitative analysis at the le level, and follow a procedure
similar to that of Gallup polls [4]. For example, when polling
adults in the United States(US) to determine election re-
sults, Gallup randomly calls households across the US, and
picks one individual in the household randomly to interview.
Similarly, in order to carry out the study at the functionTable 2: A taxonomy of the dierent purposes and properties of goto statements.
Name Description RationaleFile LevelGenerated The source le containing the goto state-
ment was generated automatically.We are only interested in goto statements that pro-
grammers introduce manually.
Long jumps Non-local jumps performed with longjmp
to a context captured with setjmp .This has potentially much more serious consequences
than regular (local) goto statements.
Domain The domain to which the le belongs to. Knowing the domain of each le, lets us understand
the type of systems that are frequently using goto
statements.Purpose - Function LevelError To handle exceptions and errors. Tagged
when the code in the label is for error han-
dling.Since C does not have exception handling constructs
liketry/catch in Java. Also discussed in the litera-
ture [14, 17].
Cleanup To handle memory de-allocation and other
cleanup activities. Tagged when the code
in the label is executed whether or not the
goto statement is executed.Since C does not have a cleanup construct like
finally in Java.
Control-Exit To exit out of a nested loop. Since C does not have break to labels. Also discussed
in the literature [14, 17].
Loop-Create Unlike Control-Exit, this is when a goto
statement is used to create a loop.A priori unnecessary because C has repetition clauses
(while ,do,for, . . . ).
Spaghetti When a goto statement exists in the code
inside a label of another goto statement.This is the kind of goto statements that all prior work
has argued against [11, 14, 17].Properties - Function LevelSingle Only one goto statement per label. According to Dijkstra, while less harmful, a single
goto per label can still cause issues [11].
Multiple Many goto statement per label. A source of severe issues according to Dijkstra [11].
Forward Jump to a label that is located after the
goto statement.Easier to track by programmers because it follows the
natural order of reading code.
Backward Jump to a label that is located before the
goto statement.Harder to follow because it requires going back in the
procedure denition.
#goto state-
ments per
LOCThe number of goto statements per line of
code in each function that is examined.This will allow us to see if there is a relationship be-
tween the number of goto statements and the size of
a function.
Stacked labels Multiple labels that follow each other such
that execution ows from one label block
to the next.A mixed blessing: jumped-to code is localized, but
there are multiple entry points in the aggregate block,
making it hard to know which statements are actually
executed.
#statements
in label blockNumber of statements in the label block. An (imperfect) estimate of the complexity of the func-
tionality implemented in the label.
level, we randomly pick one function (an individual person in
the gallup scenario) from each le (an individual household
in the Gallup scenario). Thus we now have 384 randomly
chosen functions with goto and with the same condence
level and condence interval. We then manually tag the
sample data (384 randomly chosen les and functions).
2. Identifying Tags from Subset of Sample: From this
sample of 384 les, we came up with a preliminary classi-
cation of manual tags at the le and function level, based
on separate inspection of two pairs of 10 les, by authors 1
and 2, and 4 and 5. The identied tags at the le level and
function level are described in Table 2. At the function level,
we further split the tagging into two categories - properties
ofgoto statements and the purpose of goto statements.
3. Iterative Tagging of Complete Sample: Then each
of the four authors manually tagged a mutually exclusive
subset of les, while constantly discussing with the others
for clarications and renements of the tags. Each author
went through the tags assigned to each le and function at
least twice. Once we tag each le and function in the sample,
we examine the frequency of the tags in order to understand
the usage of goto. We present these results below:5.3 Results at the Ô¨Åle level
After manually tagging the 384 les at the le level, we
arrive at the following ndings:
Only 1.5 % of the les were ltered for noise: Out
of the 384 les, only ve les were automatically generated
les. These les were generated by a parser generator like
YACC (Yet Another Compiler Compiler). We also found
one case of a le that was submitted to the ACM Interna-
tional Collegiate Programming Competition. Even though
the le submitted to the competition is a software program,
we remove it from further analysis, since we know that it
was not developed for a software project. Hence, we did not
manually continue tagging with a total of six les. There-
fore, the fraction of irrelevant les present in our sample is
(1:55)%.
A large portion of les (85%) were system or net-
work les: We found that 312 out of the 384 les were in
the domain of `systems programming'. We dene that a le
is in the domain of `systems programming' when it is asso-
ciated with the Linux Kernel or any other OS, like the BSD
or Android or Sun OS. We also associate all driver related
les in the domain of `systems programming'. There werealso 13 les that were associated with `Networking'. Thus
overall we have 325 out of 384 les in the `Systems and Net-
working' domain. This translates to almost 85 5% of the
les in the dataset. There could be two possible reasons for
this - (a) C les in GitHub are mostly system/networking
purposes, or (b) goto is used more in systems/networking
les.
Some of the other domain types that we identied were:
Image Processing/Multimedia/Videogames/Web/UI Frame-
work related les with a total of 7 :285%, and PL/DB/H-
PC/Scientic/Security related les with a total of 5 :725%.
Only one case of setjmp :Apart from goto, which is
restricted to jumps local to a function, C provides setjmp to
perform arbitrary jumps between execution contexts. This
is arguably the worst case of a goto-like construct because
it compounds the eects of goto statements. We found that
there was only one le in which the command setjmp was
used, so we can safely assume that developers seldom use
this in their programs.
Summary: Our manual analysis at the le level led to
several ndings: it showed us that gotos are used predom-
inantly in systems and networking code, but also in other
type of les as well. It also gave information alleviating con-
cerns on some possible threats to validity: extremely few of
the les were noise, giving condence in our ltering mech-
anism; a single le used the a non-local jump ( setjmp ).
5.4 Results at the function level‚ÄîBasic prop-
erties
We start our investigation of the functions we tagged by
reporting on the distribution of basic properties on the num-
ber of goto statements, labels, and the length of label blocks.
Most functions have few goto statements and la-
bels: We nd that at least 25% of the functions in the sam-
ple have 1 goto statement. The median is 3, and the top
25% of functions have at least 5 gotos. We also nd some
outliers, functions with 10 or more gotos, and one extreme
outlier that has more than 50 gotos. Unsurprisingly, there
are less labels than goto statements. The median function
has just one label, i.e, at least half of the functions in our
sample have only one label in their body. The upper quartile
is 2, and there a few functions with 5 or more labels. Over-
all, both distributions show that the majority of functions
have few goto statements and labels.
Usually, few lines are in the label blocks: We summed
the amount of lines of code under each label of the functions
in our corpus. We found that the median lines of code in
the block of code under a label was 4, and the 75th and 90th
percentile was 8 and 36 LOC respectively. We found that
in most of the non-trivial cases, the code in the label block
had a line of code for clean up, a line of code for printing an
error message, and a line of code for the return statement,
which returned an error code. Thus, we can safely say that
developers are generally not doing complex operations in the
label blocks of their goto statements. This of course does
not apply to the few outliers, in which the label blocks can
grow very large. In some cases of backward jumps, label
blocks spanned more than half the size of functions.
5.5 Results at the function level‚ÄîPurpose
Tagging the les in the sample for classifying the purpose
ofgoto statements, we found the following (see Table 2 for
a denition of the purposes and Table 3 for the numericalTable 3: Results at the function level for the manual
tagging of 384 randomly sampled functions for the
purposes and properties of goto
Tage Name % among
All
Files (384)% among
System
Files (312)% among
Non-System
Files (66)
Error 80.21 82.69 75.76
Cleanup 40.36 38.78 51.52
Control-Exit 10.16 9.94 12.12
Loop-Create 8.85 8.33 12.12
Spaghetti 5.99 6.09 6.06
Single 54.17 56.09 50
Multiple 62.24 63.46 62.12
Forward 90.1 92.31 87.88
Backward 14.06 13.46 18.18
Stacked labels 26.3 29.17 15.15
# statements in
label block (me-
dian not %)4 4 3
results). Note that the examples in each of the following
purposes, are not examples of how we think goto statements
should be used. Rather, they are examples of how developers
used goto statements in the sample we looked at.
Most goto usage is for error handling: In manu-
ally tagging our dataset, we found that developers use goto
statements for the purpose of error handling in 80 :215%
of the functions. This can be explained in part because the
C programming language does not have an explicit error
handling mechanism like exception handling in C++/Java.
Therefore, developers are using the combination of goto
statements and the code block in the labels to emulate a
try/catch mechanism (see code example below). However,
note that exception handling with goto statements is a lim-
ited form of exception handling compared to that found in
C++/Java: handlers are limited to be in the same procedure
denition.
1int fun ( int x )
2f
3 code . . .
4 i f( e r r o r )
5 goto e r r l a b e l ;
6 code . . .
7 e r r l a b e l :
8 pr int ( e r r o r ) ;
9 cleanup (mem) ;
10 return 1;
11g
The second most frequent purpose is cleanup: Sim-
ilar to the lack of exception handling capabilities, the C pro-
gramming language does not have a cleanup construct such
asfinally , unlike C++/Java. Recall that a finally block
in C++/Java is executed upon exiting a method, regardless
of whether the exit is through a standard return or throw
a raised exception. Therefore, in order to capture the cases
where developers use goto statements to duplicate the pur-
pose of finally , we tag a particular use of goto as cleanup,
only if the code block in the label can be reached even when
agoto statement is not executed (like in the example code
above). We also found that developers use goto statements
for the purpose of cleanup activities such as memory de-
allocation at the end of a function, in 40 :365% of the
functions.Error handling and cleanup happened frequently
together, but not always: We also found that cleanup
occurred very frequently with error handling (like in the ex-
ample code above). In 31 :775% on the functions, de-
velopers used goto statements for both error handling and
cleanup activities. When both error handling and cleanup
happens in the block of code under the label, the developers
are essentially adding the code that is meant to be in the
`catch' block (error handling code), to the `nally' block.
In the remaining 48 :445% of the times (80 :21 31:77),
the developers used goto statements exclusively for error
handling. In the cases where developers used goto state-
ments exclusively for error handling, the code block in the
label could be reached only if a goto statement was exe-
cuted (see code example below). Such a behaviour is similar
to having a `catch' block, but no `nally' block, in languages
like C++/Java.
1int fun ( int x )
2f
3 code . . .
4 i f( e r r o r )
5 goto e r r l a b e l ;
6 code . . .
7return 1 ;
8 /because of the above return , the
goto i s not c l a s s i f i e d as cleanup
, s i n c e the code b l o c k below i s
executed only i f goto i s executed
./
9 e r r l a b e l :
10 print ( e r r o r )
11 return 1;
12g
Alternatively in a small percentage of functions (8 :59
5%), the developers use goto statements for cleanup, but
not error handling. In such cases, the developers intend the
execution to jump to a label where cleanup occurs (whether
or not a goto statement was executed). However, the goto
statement itself is not executed due to an error. The devel-
opers just wanted the function to end in certain ows.
Less intuitive usages such as control-exit and loop-
create are less common: We found that developers used
goto statements for exiting out of standard loops ( for,while ,
do-while ), and in some cases to create loops manually in-
stead of using a standard repetition construct. In 10 :165%
of the functions, developers used goto statements to exit out
of a normal loop. This is in-spite of the C programming lan-
guage having a construct to exit out of a loop. We found
that developers used this either for skipping code outside
the loop or the exit fully out of a nested loop.
In 8 :855% of the functions, developers used the combi-
nation of a goto statement and a label to create loops (see
example code below). When a certain condition was satis-
ed, a goto statement was executed, which took the execu-
tion backward to a label that is physically above the goto
statement in the function, in order to create a loop. This is
perhaps, one of the least intuitive uses of goto statements,
since looping constructs exist in C programming language.
Only in the case of loop-create, did we not nd a reason
for the developers to use them. This pattern of usage was
surprising to us, and it would be interesting in the future,
to interview developers and see what advantages they found
in manually crafting a loop based on goto.1int fun ( int x )
2f
3 // loop c r e a t e
4 l o o p c r e a t e l a b e l
5 code . . .
6 i f( condition )
7 goto l o o p c r e a t e l a b e l ;
8return 0 ;
9g
Summary: We nd that an overwhelming majority of the
gotos are used mostly for two related purposes: error han-
dling and cleanup. Thus as predicted by Tribble [14] (and
not as emphasized by Knuth [17]), in the absence of dedi-
cated constructs to handle these special operations (such as
try/catch and finally in C++/Java), C programmers re-
sort to using goto for error handling and cleanup, and do so
in a rather disciplined way: most functions we surveyed had
their error-handling or cleanup blocks systematically located
at the end of the function. Only a minority of functions use
goto statements for other purposes, such as breaking out of
nested loop, or creating loops in an ad-hoc manner (which
was not recommended by Knuth [17]).
5.6 Findings at the function level‚ÄîProperties
In a majority of functions, multiple goto state-
ments jump to the same label: In 62 :245% of the
functions, developers have several instance of goto state-
ments that jump to the same label. Such a use of goto,
was one of the main arguments against the use of goto by
Dijkstra. By having multiple goto statements jump to the
same label, a developer cannot know which goto statement
brought the execution to the code of the label block. Ad-
ditionally in the cases where multiple developers are editing
the same le, a developer cannot change the code in the label
without knowing why each of the goto statements (several of
which could have been introduced by other developers) are
jumping to that label. However, we found that in 55 :475%
of the functions, multiple goto statements jump to the same
label was used for error handling. The frequency of the use
ofgoto statements in such a manner, could indicate that
developers are comfortable with it.
Other jumping patterns are simpler to understand:
On the other hand, 54 :175% of functions contained labels
where each of the labels are associated with a single goto.
Each of these functions, could have one or more labels, but
each of them are associated with exactly one goto statement.
Additionally, there exists a subset of the functions in which
there is only one label block and it is unreachable by the
normal execution, and only reachable by a single goto state-
ment. In these functions, it is only possible to enter the label
block via a single point of entry, and hence Dijkstra's main
argument (not knowing from where the execution jumped to
the label) does not apply. These functions constitute 8 :855
% of the functions we surveyed.
Stacking labels at the bottom of functions is preva-
lent: We nd that in 26 :305% of the functions, developers
stack all the labels at the end of the function. An interesting
pattern for error functions is labels that are stacked in the
reverse order they are referenced in a function. Hence the
farther in the function the failure occurs, the most actions
to undo without needing to duplicate code. This provides a
concise solution to undoing a series of steps that can individ-
ually fail. Some of the functions in our corpus had upwardsof 4 labels stacked in such a way (which is not easy to ac-
complish with a try/catch block in C++/Java). Therefore,
this is one of the cases where goto and appropriately placed
label blocks might be simpler than a try/catch block.
Spaghetti code is uncommon: We found that in a
few cases (5 :995%), the developers used goto to create
spaghetti code { goto statements inside the code block that
is under the label of a dierent goto statement. Such a use of
goto allows arbitrary jumps within the code of the function,
thus making it dicult to keep track of which line of code
is currently being executed. Overall, such behaviour exem-
plies the really harmful usages of goto, especially when
used in complex functions. Nevertheless, we stress that we
encountered a very small amount (6%) of such cases.
Most jumps are forward, not backwards: We found
that in 90 :555% of the functions, developers used goto
statements to jump to a label that is physically after the cor-
responding goto statement (like example code above). On
the other hand, developers used goto statements to jump
to a label that was physically before the corresponding goto
statement in the code, in a relatively small, but non negligi-
ble, portion of the functions (14 :065%, note that the % of
backward and forward jumps do not add up to 100% since
there are functions where both such jumps exist).
As we saw before, developers used goto statements for cre-
ating loops. In order to create loops, the developers would
have had to use a goto that jumped backwards to a la-
bel (see above for example to create loops). Unsurprisingly,
most usages of backward goto statements are for this pur-
pose. However, we found that in 5 :215% of the functions,
developers jumped backwards to a label from a goto, but
were not creating a loop (because the goto statement was
not part of a condition). Every time the code executed such
agoto, the execution would go back to a label.
Additionally we found that in 4 :175% of the functions, a
backward jump from a goto statement was done from within
the label of another goto statement, thus making it both a
backward jump and spaghetti code. Such a use of goto
might be very hard to keep track of during execution. That
may be the reason why we nd so few cases of this.
Summary: We nd that the usages of goto statements
exhibit several properties. First, we nd that it is common
to have several goto statements jumping to the same label:
if this presents the issue highlighted by Dijkstra that it is
not possible to know exactly the control ow that led to
the label, it also means code duplication has been avoided
(similar to calling an inner function { something standard
in languages that support them). On the other hand, many
labels are only reached by a single goto (54 :175%). Fur-
ther, 8 :855 % of functions have label blocks that are only
reachable by a single goto statement; in those cases, Dijk-
stra's main concern does not apply. We also nd that back-
wards jumps are often, but not always, correlated with loop
creation goto statements. Finally, arbitrary jumps between
goto statements (\spaghetti") are a relatively rare occur-
rence alleviating concerns about their impact.



	We nd that, in general, the use of goto is actu-
ally well disciplined. Most uses of goto are reason-
ably structured, lling the void of missing higher-level
constructs found in other languages. Also there are
usages that are unstructured as Dijkstra feared.6. RQ2: Do developers remove/modify goto
statements?
6.1 Motivation
Since Dijkstra's article claims that goto statements can
have harmful eects, we wanted to empirically examine if
goto statements did cause harm. However, a causal relation
between a programming construct and harm is dicult to
establish. Hence, we approximate harm as post-release bugs
or bugs that are likely to aect the users of software and that
could not be detected in development and testing. Then we
examine if goto statements were removed/modied in any
of the post-release bug xes of a particular release of six OSS
projects. In doing so, we assume that if a goto statement is
removed/modied in a post-release bug x, then it is more
likely to be associated with that post-release bug (harmful).
6.2 Approach
We examine 180 days of post-release commit history for
the six oss projects shown in Table 1. During this period
we extract the code that was removed and the code that
was added in every bug xing commit to the git repository.
We determine if a commit was a bug x commit or not by
looking for keywords such as `bug', `x', `issue' [21]. Then
for each bug x commit, we look at the added and removed
code to see if goto was removed from the code or modied
(when the same goto statement exists both in the added
and removed code).
In some cases, the developers might include in the commit
comment or in the comments section of the bug in the is-
sue tracking repository that a goto statement was the cause
of the bug, and that was the reason why they removed/-
modied it, but we cannot be sure that they will make such
a comment. The only sure way of knowing is by examin-
ing the code that was committed to the source code reposi-
tory (which is what we do in our paper). Also note that we
only focus on the goto statement and not the labels, since
the removal/modication of a label will implicitly always
require a change to the actual goto statement. We also do
not examine if any change was made to the code within the
block of code under a label, since that is the action taken
once the goto is executed, and does not imply that a goto
statement caused a bug. It only implies that the code exe-
cuted after the goto call has a bug. Hence, we focus only
on the actual goto statement. Also note that we only look
for bugs and not code smells [10].
6.3 Results
The results of our analysis is presented in Table 4. We
found that there are anywhere between 87 and 1,012 com-
mits to the release we examined for the six OSS projects.
Among the post-release commits, there were 25-145 bug
xing commits. However, only in two projects (ghostpdl,
openldap) were goto statements removed in post-release bug
x commits. In the remaining four projects no goto state-
ment was removed in a post-release bug x commit. We
found only one project (ghostpdl) where the goto statements
were modied (either moved in the code or the target label
was modied). In ghostpdl, eight of the 143 post-release bug
x commits had a goto statement that was modied.
We also looked at all post-release commits instead of just
the bug xing ones. We found that now four projects hadTable 4: The number of times a goto statement is removed/modied in the post-release phase of a project
Project All Post Release Commits Bug Fix Commits Number of
goto state-
ments in the
code
# Commits # goto
statements
removed#goto state-
ments modi-
ed# Commits # goto
statements
removed#goto state-
ments modi-
ed
clamav-devel 87 0 ( 0 %) 1 ( 1.1 %) 25 0 ( 0 %) 0 ( 0 %) 758
ghostpdl 446 9 ( 2 %) 14 ( 3.1 %) 143 4 ( 2.8 %) 8 ( 5.6 %) 576
gimp 126 0 ( 0 %) 0 ( 0 %) 84 0 ( 0 %) 0 ( 0 %) 4,557
openldap 158 4 ( 2.5 %) 0 ( 0 %) 112 3 ( 2.7 %) 0 ( 0 %) 2,101
postgresql 97 1 ( 1 %) 2 ( 2.1 %) 24 0 ( 0 %) 0 ( 0 %) 815
VTK 1,012 1 ( 0.1 %) 0 ( 0 %) 145 0 ( 0 %) 0 ( 0 %) 4,579
goto removed, and three projects had goto modied. How-
ever, in two of those four projects (postgresql, VTK), only
onegoto statement was removed. In total, between 0 and 9
commits had goto statements removed, and between 0 and
14 commits had goto statements modied. However, the
corresponding total number of commits ranged from 87 to
1,012. The highest percentage of post-release commits with
goto statements modied was 3.1% | which is very small.
We place the above results in context in two ways. (1)
We rst examine the number of goto statements present in
the respective release of the six OSS projects. If the num-
ber of goto statements is small, then obviously the number
ofgoto statements removed/modied in the commits will
be small. We found that the six projects had between 576
and 4,579 goto statements in the respective releases. There-
fore, the lack of goto statements being removed/modied in
bug x commits is not due to the lack of goto statements
in the code; (2) We also looked at another programming
construct to place the results regarding goto statements in
context, namely ifstatements. We found that between one
and 29 ifstatements were removed, and between four and
59ifstatements were modied in the bug x commits. In
ve out of the six projects the ratio of goto statements re-
moved/modied to all goto statements is not signicantly
dierent from the ratio of ifstatements modied/removed
to all if statements. Only in GIMP that ratio is higher for
goto statements and the dierence is statistically signicant.
This means that only in one out of six projects post-release
xes were more likely to modify a goto statement than an if
statement after adjusting for the relative frequency of goto
and ifstatements. Therefore the number of goto state-
ments removed/modied are much smaller in comparison.
Finally, we manually analyze the post-release bug x com-
mits in which goto was removed/modied. The two projects
with such commits are ghostpdl and openldap. In none of
the commits were goto statements removed/modied because
they caused a post-release bug . There were three reasons
for a goto to be removed/modied: (1) A feature was re-
moved and the goto within the code of the feature was no
longer needed; (2) goto was moved due to code/comments
added somewhere above the goto statement; and (3) goto
was moved to a dierent if-condition's block of code (only
one case). We noticed that no goto was modied in such a
way that it jumped to a dierent label.
Additionally, we found that all but two of the goto state-
ments in the commits were used for cleanup or error handlingpurposes. Among the two remaining goto related commits:
one was a goto that was modied (similar to case 2 above)
in ghostpdl. It was used for spaghetti code; another was a
goto that was removed (similar to case 1 above) in openl-
dap. It was used for a loop exit. Interestingly, the loop that
it was exiting out of was created with a goto as well. Also
along with the goto the label was removed as well.


If we assume bugs in the post-release phase of a
project as a measure of harm, then the small number
ofgoto statements being removed/modied in bug
xes implies that goto statements were not consid-
ered harmful enough to be removed/modied in the
post-release phase of the project in most cases.
7. THREATS TO V ALIDITY
False positives due to code generation: the heuristic
we used may not be sucient to lter out all generated les.
However, the manual inspection of the random sample pro-
vides us with a very small estimate of generated les that
are left in the sample (1 :55%).
False positives due to other reasons: the regular ex-
pression we used to nd gotos may return false positives,
however our manual analysis uncovered only one such case
(a goto in commented-out code).
Overestimation due to forks: projects in GitHub are
easy to fork, and that may lead to a potential proliferation
of very similar projects in the population. However, none
of the les in the random sample of 384 les we manually
examined in RQ1 were from forked projects.
Sampling errors: we performed a simple random sam-
pling without replacement at the le level to get the list of
les to inspect. We then followed that by sampling one func-
tion per le for detailed inspection. An alternative was to
sample directly at the function level which conicted with
our goal to perform the analysis at the level of both les and
functions. Another alternative was to use all the functions
in the le, which may bias the results towards les with large
number of functions with goto statements. As such there is
a small threat the sample is not representative. However,
our way of sampling is similar to the way Gallup samples
people for its polls [4].
Yet another alternative to sampling is to use an automated
tool like Coccinelle [1] to automatically determine patterns.
However, we choose not to use an automatic parser for fourreasons: (a) we had to rst do a manual inspection to deter-
mine all the dierent uses of goto, before any automation
could be done; (b) we could have identied several prop-
erties like forward or backward jumps, it would have been
more dicult to identify others, such as spaghetti code; (c)
manually analyzing a random sample gives an accurate rep-
resentation of the whole population; and (d) automatically
extracting the various uses of goto statements will not pro-
duce any more accurate results, since even the code that we
have examined automatically is but a sample of the popula-
tion of the world of C code out there;.
Goto semantics specic to C: C's goto can only jump
inside a function. Other languages may permit other things,
and have dierent usage patterns, as such further studies are
needed in those languages. We also searched for setjmp, C's
equivalent to a goto that can jump to other functions, but
found very few usages of it.
Generalizability: We conducted our study on the set
of C source code projects available on GitHub, which is the
largest open-source repository in use at the moment. As
such, we expect that the results of this study are somewhat
generalizable, unless the C projects available on GitHub are
markedly dierent from other C projects in existence.
Domain of the les: there may be dierent domains
for les using goto statements, compared to other C les.
We found that 85 5% of the les with goto statements in
the dataset that we inspected manually are system or net-
working les. In terms of type of usage, we found that the
proportions of goto statements dened for a certain pur-
pose or exhibiting a certain property were comparable be-
tween system and non-system les, with the notable excep-
tion of the \stacked labels" property. If we cannot discard
the possibility that there are dierences in usage in terms of
domains, we have not encountered strong evidence towards
this either. In any case, further studies on a larger sample of
non-system les need to be conducted. In particular, more
work is needed to determine if there are systematic dier-
ences between the system code and the non-system C code
(though some may argue that C is designed primarily for
system code). Surveys and interviews with developers will
help corroborate and enrich the ndings presented here.
8. CONCLUSION
For decades, there have been arguments over the use of
goto in programs. However, they have been mostly the-
oretical. While some of our results may be obvious to C
developers, the overall software community may not know
(and there is no empirical evidence so far) how goto state-
ments are used in practice. This study is to our knowledge
the rst to bring empirical evidence to the debate; by report-
ing on how C developers are actually using goto in practice,
and by investigating if they are involved in post-release bugs.
We conducted a large-scale study of more than 11K projects
(more than two millions C les), featuring both quantitative
and qualitative components. Summarizing our ndings:
Most usages of goto statements appear to be rea-
sonable. Our qualitative study of a sample of les and
functions using goto shed light on why goto is used: far
from being maintenance nightmares, most usages of goto
follow disciplined, well-designed usage patterns, that are
handled by specic constructs in more modern languages.
The most common pattern are error-handling and cleanup,
for which exception handling constructs exist in most mod-ern languages, but not in C. Even properties such as sev-
eralgoto statements jumping to the same label have ben-
ets, such as reducing code duplication, in spite of the
coordinate problem described by Dijkstra.
Developers did not remove/modify gotostatements
in the post-release phase of four of the six projects.
Finally, our quantitative study on the post-release history
of six OSS projects showed that developers did not nd
goto statements harmful enough to be removed in a bug
x commit in four of the six projects. Even in the two
projects where goto statements are removed/modied, we
notice through manual inspection that goto statements
did not cause the bugs. Thus we do not nd evidence
that goto caused post-release bugs in these projects.
Overall, our qualitative study tells us that only a minor-
ity of goto usages are really exemplary of the `disastrous ef-
fects' Dijkstra warned us about. We have no evidence that
goto statements were used dierently prior to Dijkstra's fa-
mous article than now. However, the current usage heeds
Dijkstra's advice, but not to the letter: goto is being used,
but is mostly limited to the cases where it actually oers
an improvement over the alternatives. Indeed, some devel-
opers perceive that sometimes goto is the cleanest way to
achieve something [31]. Thus goto statements do not ap-
pear to cause harm in practice, as they are mostly used for
a limited set of straightforward purposes, quite unlike the
ways Dijkstra feared they may be misused. Experienced C
programmers may not nd the results very surprising; How-
ever we think it is very important that there is now sound,
quantiable empirical evidence about the use of goto state-
ments for error handling in C. The harmless uses of goto
may happen because (as suggested by developers on Slash-
dot [26] and StackOverow [25]) developers heeded the call
of Dijkstra and used goto statements carefully. Or, as noted
in PeerJ [22], perhaps the real impact of Dijkstra's article
was cultural. However, it may also be due to other reasons,
such as the developers own experience. In fact, the actual
reason cannot be known without a user study that includes
interviews with developers on why they use (or do not use)
goto statements in their code, which we intend to do in fu-
ture work. Therefore, when teaching C, educators may no
longer need to say that goto statements are always harmful,
but may rather teach the ways in which goto can be used in
a harmless, and even productive way. However, we do not
advocate that goto statements have to be used. We only
say that goto statements should be provided as an option
for anyone who wants to use it. In future work we want
to examine the underlying fault model in goto statements{
i.e., common errors when using goto statements and their
frequency of occurrence in Github projects. For example if
the return codes in goto statements were error prone [9].
On a closing note, the continuous interest shown by devel-
opers to topics such as the usage of goto shows that empiri-
cal studies of early inuential articles are needed in order to
assess how they fare over time.
9. REFERENCES
[1] Coccinelle. http://coccinelle.lip6.fr/, Checked Aug
2014.
[2] Download statistics for GIMP in Sourceforge.
http://goo.gl/AiUg8f, Checked Aug 2014.
[3] GitHub. https://GitHub.com/, Checked Aug 2014.[4] How does gallup polling work?
http://www.gallup.com/poll/101872/how-does-gallup-
polling-work.aspx, Checked Aug
2014.
[5] Sample size calculator.
http://www.surveysystem.com/sscalc.htm, Checked
Aug 2014.
[6] S. Alnaeli, A. Alali, and J. Maletic. Empirically
examining the parallelizability of open source software
system. In Reverse Engineering (WCRE), 2012 19th
Working Conference on , pages 377{386, Oct 2012.
[7] Andrew Koenig. What dijkstra said was harmful about
goto statements. http://www.drdobbs.com/cpp/what-
dijkstra-said-was-harmful-about-got/228700940, Mar
2009.
[8] Arie van Deursen. Learning from Apple^ a AZs #gotofail
Security Bug.
http://avandeursen.com/2014/02/22/gotofail-
security/, Checked July
2015.
[9] M. Bruntink, A. van Deursen, and T. Tourw e.
Discovering faults in idiom-based exception handling.
InProceedings of the 28th International Conference on
Software Engineering , ICSE '06, pages 242{251, 2006.
[10] A. Chou, J. Yang, B. Chelf, S. Hallem, and D. Engler.
An empirical study of operating systems errors. In
Proceedings of the Eighteenth ACM Symposium on
Operating Systems Principles , SOSP '01, pages 73{88,
2001.
[11] E. W. Dijkstra. Letters to the editor: Go to statement
considered harmful. Communications of ACM ,
11(3):147{148, Mar. 1968.
[12] D. P. Duncavage. Nasa needs postgres - nagios help.
http://goo.gl/AyY8J2, Checked Aug 2014.
[13] Edsger W. Dijkstra. What led to \notes on structured
programming". http://www.cs.utexas.edu/ EWD/-
transcriptions/EWD13xx/EWD1308.html, Jun
2001.
[14] Edsger W. Dijkstra. Go to statement considered
harmful: A retrospective.
http://david.tribble.com/text/goto.html, Nov 2005.
[15] Eric A. Meyer. \considered harmful" essays considered
harmful.
http://meyerweb.com/eric/comment/chech.html, Dec
2002.
[16] C. A. Kent and J. C. Mogul. Fragmentation
considered harmful. SIGCOMM Comput. Commun.
Rev., 25(1):75{87, Jan. 1995.
[17] D. E. Knuth. Structured programming with go to
statements. ACM Computing Surveys , 6(4):261{301,
Dec. 1974.
[18] M. Krieger. Keeping instagram up with over a millionnew users in twelve hours. http://goo.gl/415Zrk,
Checked Aug 2014.
[19] L. Marshall and J. Webber. Gotos considered harmful
and other programmers^ a AZ taboos, 2000.
[20] A. Mockus. Amassing and indexing a large sample of
version control systems: Towards the census of public
source code history. In Proceedings of the 2009 6th
IEEE International Working Conference on Mining
Software Repositories , MSR '09, pages 11{20, 2009.
[21] A. Mockus and L. Votta. Identifying reasons for
software changes using historic databases. In Software
Maintenance, 2000. Proceedings. International
Conference on , pages 120{130, 2000.
[22] M. Nagappan, R. Robbes, Y. Kamei, E. Tanter,
S. McIntosh, A. Mockus, and A. E. Hassan. An
empirical study of goto in C code. PeerJ PrePrints , 3.
[23] M. Nagappan, T. Zimmermann, and C. Bird. Diversity
in software engineering research. In Proceedings of the
2013 9th Joint Meeting on Foundations of Software
Engineering , ESEC/FSE 2013, pages 466{476, 2013.
[24] C. Ponder and B. Bush. Polymorphism considered
harmful. SIGPLAN Not. , 27(6):76{79, June 1992.
[25] Posted by MaD70. Goto still considered harmful?
http://goo.gl/jjG8qI, Checked Mar 2015.
[26] Posted by timothy. Empirical study on how C devs
use goto in practice says \not harmful".
http://goo.gl/fq8vDC, Checked Mar 2015.
[27] Robert Love, Rik van Riel, Linus Torvalds. Linux:
Using goto in kernel code (mailing list discussion).
http://goo.gl/ItZHiu, Jan 2003.
[28] S. Saha, J. Lawall, and G. Muller. An approach to
improving the structure of error-handling code in the
linux kernel. In Proceedings of the 2011
SIGPLAN/SIGBED Conference on Languages,
Compilers and Tools for Embedded Systems , LCTES
'11, pages 41{50, 2011.
[29] S. Saha, J.-P. Lozi, G. Thomas, J. Lawall, and
G. Muller. Hector: Detecting resource-release omission
faults in error-handling code for systems software. In
Dependable Systems and Networks (DSN), 2013 43rd
Annual IEEE/IFIP International Conference on ,
pages 1{12, June 2013.
[30] E. Shihab. An Exploration of Challenges Limiting
Pragmatic Software Defect Prediction . PhD thesis,
School of Computing, Faculty of Arts and Science,
Queen's University, 2012.
[31] M. Szeredi. Commit - fuse: fuse llsuper error
handling cleanup. http://goo.gl/kRPJva, Checked
Aug 2014.
[32] W. Wulf and M. Shaw. Global variable considered
harmful. SIGPLAN Not. , 8(2):28{34, Feb. 1973.