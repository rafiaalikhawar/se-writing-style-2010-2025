Launch-Mode-Aware Context-Sensitive Activity Transition
Analysis∗
Yifei Zhang
UNSW Sydney, AustraliaYulei Sui
University of Technology Sydney,
AustraliaJingling Xue
UNSW Sydney, Australia
ABSTRACT
Existing static analyses model activity transitions in Android apps
context-insensitively, making it impossible to distinguish different
activity launch modes, reducing the pointer analysis precision for
anactivity’scallbacks,andpotentiallyresultingininfeasibleactivitytransitionpaths.Inthispaper,weintroduceChime,alaunch-mode-
aware context-sensitive activity transition analysis that models
differentinstancesofanactivityclassaccordingtoitslaunchmode
and the transitions between activities context-sensitively, by work-
ing together with an object-sensitive pointer analysis.
Our evaluation shows that our context-sensitive activity transi-
tionanalysisismoreprecisethanitscontext-insensitivecounter-
partincapturingactivitytransitions,facilitatingGUItesting,and
improving the pointer analysis precision.
CCS CONCEPTS
•Theory of computation →Program analysis ;•Software
and its engineering →Object oriented languages;
KEYWORDS
Android, Pointer Analysis, Activity Transition Analysis
ACM Reference Format:
YifeiZhang,YuleiSui,andJinglingXue.2018.Launch-Mode-AwareContext-
SensitiveActivityTransitionAnalysis.In ICSE ’18: ICSE ’18: 40th Interna-
tional Conference on Software Engineering , May 27-June 3, 2018, Gothenburg,
Sweden.ACM,NewYork,NY,USA,11pages.https://doi.org/10.1145/3180155.
3180188
1 INTRODUCTION
Activity, as a majortype of Android components,lies at the heart
of the Android programming framework due to its event-driven
nature. An activity acts as a container consisting of various GUI
elements (e.g., views and text boxes), through which, users interact
with an app for activity navigations, i.e., transitions between dif-
ferentactivities.Conceptually,anappexecutesalongtheactivity
transition paths and other callbacks are sprawled out of them.
∗Thankstoallthereviewersfortheirvaluablecomments.Thisresearchissupportedby
ARCgrants,DP170103956andDE170101081.YifeiZhangissupportedbyanAustralian
Government Research Training Program Scholarship.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.31801884 class  Search  extends  Activity { 
5  void  onClick(...) {
6   startActivity( new  Intent( this, 
   Search .class )); }
7  void  onCreate(...) {...}
8  void  onStart() {...}
    …
9  void  onRestart() {...}
   ... }Android Framework
10 startActivity(Intent intent) {
…
// find target activity instance
// based on the launch mode
11 a = findActivity(intent);
12 if (a == null) {
13 a = createNewActivity(intent);
14 a.onCreate();15 a.onStart();
16 ...} else {
17 a.onRestart();
... }
omain o3    o 6 (a) Application code
(c) Two activity transition sequences when Search  activity
is configured under standard (left)  and singleTask (right)  launch modes (b) Library pseudo-code1 class  Home  extends  Activity {
2  void  onClick(...) {
3   startActivity( new  Intent( this, 
   Search .class )); } }
Home Search SearchomainHome o3Search
Figure 1: Three activity transitions, represented by ,
and , via callbacks: Homelaunches Searchand
Searchlaunchesitselfwith standard andsingleTask modes.
AfundamentalstaticanalysisforAndroidappsistomodelac-
tivity transitions for event-driven callbacks. This serves as a cor-
nerstoneformanyclients,suchasvulnerabilitydetection[ 5,6,9,
10,14,19,27,31], malware detection and mitigation [ 7,8,27], GUI
model generation [32, 33], and GUI testing [2–4, 20, 23].
Thecore datastructureused foranapp isan activity transition
graph(ATG) [2,4,23], which represents the activity transitions in
theapp.InanATG,anoderepresentsanactivityinstanceandan
edge between two nodes denotes an activity transition.
In Android, a parent activity can start a child activity by in-
voking, e.g., startActivity() as a form of an inter-component
communication (ICC) call, passing it an intent that describes the
child activity to be launched. In addition, an activity instance ofa class, say,
Tcan be launched in one of the four launch modes,
standard ,singleTask ,singleTop andsingleInstance , either
configured in AndroidManifest.xml or specified in the intent
passed to startActivity() . The first one is the default while the
otherthreeareknownasspeciallaunchmodes.Theselaunchmodes
affectwhichactivityinstancesarelaunchedandtheirtransitions.
For example, standard always requests a new activity instance of
Tto be launched while singleTask requires an existing activity
instance of Tto be reused if it exists (by thus limiting only one
instance of Tin each activity transition path).
Figure 1 gives an example to demonstrate how we intend to
use an ATG to keep track of activity transitions (in the presenceof ICC calls) under different launch modes, with
Searchbeing
configured once with standard and once with singleTask .W e
assumeanavigationscenariowheretheuserclicksabuttononthe
5982018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Yifei Zhang, Yulei Sui, and Jingling Xue
currentHomeactivitytolauncha SearchactivityviatheICCcall
startActivity() at line 3. Next, the user clicks another button
onthelaunched Searchactivity,causingeitheranew Searchac-
tivity(with standard )ortheexistingone(with singleTask )tobe
launched via the ICC call startActivity() at line 6.
LetusunderstandtheinternalworkingofICCcallbacksinthe
abovenavigationscenarioforthethreetransitionsashighlightedin
black,redandbluearrows.Therearethreestepsforeachtransition
viatheAndroidcallbackmechanismwhenanapp(Figure1(a))inter-
acts with the Android framework (Figure 1(b)). First, the app code
passesanewintentobject(line3)totheframework(line10).Second,
the framework finds the corresponding activity instance a(line 11)
basedonthelaunchmodespecified.AsshowninFigure1(b),anew
instanceiscreated(line13)iftheactivityislaunchedforthefirst
time, i.e., oHome
mainoSearch
3,o ri nstandard mode with the
transition oSearch
3oSearch6, whereoSearch
3andoSearch6are
twodifferentinstancesof Search.Finally,theframeworklaunches
Searchvia the callbacks (lines 14-15) to their corresponding life-
cycle methods (lines 7-8). If a special mode, singleTask , is used,
the Android framework will retrieve the existing Searchinstance
to restart the activity (line 17), oSearch
3.
Building ATGs statically to reason about activity transitions for
Android apps is challenging. Unlike a Java program with a ded-
icated main()method, an Android app can have multiple entry
points, with some activities implicitly launched by the Android
framework through nondeterministic user and system events. This
can significantly complicate static activity transition analysis in
the presence of a large number of callbacks. In addition, activity
transitionsthroughICCmakeuseofintentobjectstospecifytarget
activities launched, requiring a precise pointer analysis to discover
thecontentsinsuchintents.Finally,theheapallocationsitesforac-tivityinstancesareinvisibleintheappcode,astheyaredistributed
via deep call chains in the Android framework. Thus, perform-
ing a precise pointer analysis for an app over the entire Android
framework (with millions of lines of code) is unrealistic [9].
ExistingGUItestingtechniques[ 2,4,23]usecontext-insensitive
ATGs to model activity transitions in Android apps, implying that
allinstancesofanactivityclassareabstractedwithonesingleob-ject.Thus,context-insensitivitymakesitinherentlyimpossibleto
distinguish different activity launch modes, reduces the pointer
analysis precision for an activity’s callbacks, and potentially intro-
duces infeasibleactivity transition paths.To analyzethe callbacks
ofanactivity,existingstaticanalyses[ 1,9,14,24–26,31]construct
a“fat”harness main(),consistingofoneallocationsiteperactivity
class (for allocating one single abstract object for the class) and the
calls to all its callbacks (e.g., onCreate() andonClick() )o nt h e
abstractobject.InFigure1, oSearch willbecreatedregardless
of thelaunch mode specifiedfor Search. Thetransitions between
activities are modeled context-insensitively, as discussed Section 2.
Toaddresstheabove-mentionedchallengesinmodelingactivity
transitionsandthelimitationsofthepriorwork,wepresentChime,
a launch-mode-aware context-sensitive activity transition analysis
for Android apps that builds context-sensitive ATGs, together with
an object-sensitive pointer analysis [ 12,13,15–17,21,22,28–30].Activity-Aware 
Object-Sensitive 
Pointer AnalysisContext-
Sensitive 
ATGPreprocessing
 Launch
Mode 
AnalysisChime
Slim Harness 
main()Intent FiltersLaunch ModesTargets of 
ICC Calls
Activity
 Behaviors 
Modeling
Figure 2: An overview of the Chime framework.
By maintaining context-sensitivity in tracking activity transitions,
Chime can model launched activities based on their launch modes
andreducethenumberofinfeasibletransitionpaths(thatwould
otherwisebeintroducedcontext-insensitively).Bydistinguishing
different instances of an activity class based on their activity tran-
sitionsequencesascontexts,Chimeavoidshavingtoanalyzethe
Androidframework(e.g.,tolookfortheheapallocationsitesfor
activities) and improves the pointer analysis precision for the call-
backs of an activity.
Figure 2 depicts our framework. The activity-aware object-
sensitivepointeranalysisandlaunchmodeanalysisaremutually
dependent. Its preprocessing phase extracts metadata, including
activity launch modes and intent filters for an Android app. Unlike
existingstaticanalyses[ 1,9,14,24–26,31],whichuseafatharness
main()for allocatingall theactivities andcalling its callbacks(as
mentioned earlier), Chime builds an ATG for an app by using a
slimharness main(),consistingofinitiallythesameinformation
but restricted to the entry activities, i.e., the ones registered via
intent filters or exported to the system. The other activities will be
gradually introduced into the ATG during the analysis.
This paper makes the following contributions:
•Weintroducealaunchmodeanalysisfordistinguishinglaunched
instancesofanactivityclassbasedonthelaunchmodespecified.
•We introduce Chime, a launch-mode-aware context-sensitive
activitytransitionanalysisthattracksactivitytransitionscontext-
sensitively, together with an object-sensitive pointer analysis.
•WehaveimplementedChimeintheDroidSafeframework[ 9].
Evaluated with a set of 42 large real-world Android apps from
GooglePlay,Chimeisshowntobemoreprecisethanitscontext-
insensitive counterpart in modeling activity transitions, guiding
GUI testing, and improving the pointer analysis precision.
2 MOTIVATION
InSection1,wehaveusedanexampleinFigure1toexplainwhy
modeling activity transitions context-sensitively is essential in ac-
counting for the effects of launch modes on launched activities.
In this section, we use another example to demonstrate why such
context-sensitive modeling is also essential in modeling accurately
activitytransitions,improvingthepointeranalysisprecision,and
potentially reducing the number of infeasible activity transitions.
With this second example in Figure 3, we show how Chime
modelscontext-sensitivelytheactivityinstanceslaunchedfor Home,
NewTrip,TripView ,andEditFolder ,andtheirtransitions,bycon-
sideringtheirlaunch modes. InFigure3(a),we see acodesnippet
from TripView,arealpublictransportationtripplantool. Homeis
themainactivity.Twolaunchmodes, singleTask andstandard ,
will be considered. The other three activities, configured under
standard launch mode, are not exported (to the system).
599
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Launch-Mode-Aware Context-Sensitive Activity Transition Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
1  class Home extends Activity {
2 // The “+” button registered with the following callback
3   void onClick(View view) {
4    Intent HMtoNT = new Intent( this, NewTrip. class);
5    startActivity( HMtoNT); }
6 // A list registered with the following callback
7   void onItemSelected(..., int pos, long row) {
8    if(getItem( pos) instanceof  TripFolder) {
9     Intent HMtoTV = new Intent( this, TripView. class);
10    startActivity( HMtoTV); } ... } 
11  void onNewIntent(..., Intent EFtoHM) {...} }
12 class NewTrip extends Activity {
13 // The “New Folder ” button registered with the following callback
14  void onClick(View view) {
15   Intent NTtoEF = new Intent( this, EditFolder. class);
16   startActivityForResult( NTtoEF, ...); }
17  void onActivityResult(..., Intent EFtoNT) {...} }
18 class TripView extends Activity {
19 // A menu registered with the following callback
20  void onContextItemSelected(MenuItem menuItem ) {
21   if(menuItem .getItemId() == EDITFOLDER ) {
22    Intent TVtoEF = new Intent( this, EditFolder. class);
23    startActivityForResult( TVtoEF, ...); } ... }
24  void onActivityResult(..., Intent EFtoTV) {...} }
25 class EditFolder extends Activity {
26 // A menu registered with the following callback
27  void onContextItemSelected(MenuItem menuItem ) {
28   if(menuItem .getItemId() == SAVE) {
29    Intent ret = new Intent();
30    ret.putExtra( "folder_name" , name);
31    setResult( ..., ret); 
32   } else if(menuItem .getItemId() == HOME) {
33    Intent EFtoHM = new Intent( this, Home.class);
34    startActivity( EFtoHM); } ... } }
(a) App code abstracted from TripView
HomeNewTrip
TripViewEditFolder
(b) Activity transitions (including GUI events)
<oHM, ∅>
<oNT, ∅> <oTV, ∅>
<oEF, ∅>
(c) Context-insensitive ATG<omain, ∅>
<o10, [o main]> <o5, [o main]>
<o16, [o 5, omain]> <o23, [o 10, omain]>NT
NTTV
TVHM
HM HMHM HM
EF EF
(d) context-sensitive ATG ( singleTask forHome)<omain, ∅>
<o10, [o main]> <o5, [o main]>
<o16, [o 5, omain]> <o23, [o 10, omain]>
<o34, [o 16, o5, omain]> <o34, [o 23, o10, omain]>HM
HM HM
HM HM
HM HMNT
NT
NTTV
TV
TVEF
EFEF
EF HM HM
(e)Context-sensitive ATG ( standard forHome)
Figure 3: A motivating example. ot
−is an instance of t, wheret∈{Home (HM),NewTrip (NT),TripView (TV),EditFolder (EF) }.
In (d) and (e), and denote two context-sensitive activity transition paths identified by Chime.
2.1 Two Navigations Scenarios
Figure 3(b)shows twoactivity navigations highlightedin redand
bluearrows, respectively. For the rednavigation, Homelaunches
NewTrip via the ICC call at line 5 once the “+” button for NewTrip
is clicked. Then NewTrip launches EditFolder , once the “New
Folder”buttonisclicked,tocreateanewtripfolderviatheICCcall
startActivityForResult() atline16,andsubsequently,receives
an intent object from the target activity as its result. If “Save” on
themenuisclicked, EditFolder transitsbackto NewTripsothat
setResult() , which is invoked at line 31, returns an intent object
as the result to the previous NewTripinstance that has launched
EditFolder through the Android callback onActivityResult()
at line 17. If “Home” on the menu is clicked instead, EditFolder
transits back to Homevia the ICC call at line 34.
For thebluenavigation, Homelaunches TripView to look up an
existing trip at line 10 once the list item “ Existing Trip Folder ”
is selected. TripView launches EditFolder to edit the name of an
existing folder via the ICC call at line 23 once “Edit Folder” on the
menu is clicked. Then EditFolder transits back to TripView if
“Save” is clicked or returns to Homeif “Home” is clicked.
2.2 Context-Insensitive Transition Analysis
Existing static analyses [ 1,2,4,9,14,23–26,31] model activity
transitions context-insensitively. For our example, the context-
insensitive ATG obtained is shown in Figure 3(c). For each app,a “fat” harness
main()is created, responsible for allocating one
abstract object for each activity class (to represent all its instances)
andcallingallitscallbacks(e.g., onCreate() )ontheabstractobject.
Thus, each abstract activity is parameterized with an empty con-
text∅.Asthereareonlyfourcontext-insensitiveactivityobjects,/angbracketleftoHM,∅/angbracketright,/angbracketleftoNT,∅/angbracketright,/angbracketleftoTV,∅/angbracketrightand/angbracketleftoEF,∅/angbracketright,thetwoEditFolder instances
that are actually created at run time along two different transition
paths are indistinguishable. In addition, regardless of the launch
mode specified for Home, the same ATG is always built.
Finally,ATGsareessentiallycallgraphsbutusedformodeling
activity transitions. When constructed context-insensitively, ATGs
will potentially exhibit infeasible transition paths.
2.3 Context-Sensitive Transition Analysis
For our example, Chime will eventually build the context-sensitive
ATGinFigure3(d)if HomeusessingleTask asitslaunchmodeand
the one in Figure 3(e) if Homeusesstandard as its launch mode.
Initially, its slim harness main()allocates one instance, oHM
main,o f
themainactivity Home(andalsocallsallthecallbacksregistered).
As before, oHM
mainis parameterized with ∅in the ATG.
Our activity-aware pointer analysis is then performed on the
harnessedapptoresolveitsactivity-relatedICCcalls.Duringthe
analysis, the pointed-to objects of theintent variables at the two
ICCcallsatlines5and10arequeriedinordertofindtheirtargetac-
tivities.Oncetheirclasstypes, NewTrip (line4)and TripView (line
9), are found, Chime creates two activity instances, /angbracketleftoNT
5,[oHM
main]/angbracketright
atline5and/angbracketleftoTV
10,[oHM
main]/angbracketrightatline10,andthenaddsthetransition
edgesfrom oHM
maintooNT
5andoTV
10asshown.Notethat oNT
5andoTV
10are
parameterized with [ oHM
main], a context representing currently the
onlyactivitytransitionsequencereaching oHMmain.ForEditFolder ,
however, there are two reaching transition paths, resulting in two
differentinstances, /angbracketleftoEF
16,[oNT5,oHM
main]/angbracketrightand/angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketright,param-
eterized by two different transition sequences.
600
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Yifei Zhang, Yulei Sui, and Jingling Xue
Finally,/angbracketleftoEF
16,[oNT
5,oHM
main]/angbracketrightatline34launchesa Homeactivity.If
Homeis configured with singleTask (Figure 3(d)), Chime retrieves
its existing instance /angbracketleftoHM
main,∅/angbracketrightalong the transition path reach-
ing/angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright, and adds an edge from /angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright
to/angbracketleftoHM
main,∅/angbracketright. Similarly, the context-sensitive transition from
/angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketrightto/angbracketleftoHMmain,∅/angbracketrightis added. If Homeis configured
withstandard instead (Figure 3(e)), two new instances of Home
will be created,/angbracketleftoHM
34,[oEF
16,oNT5,oHM
main]/angbracketrightand/angbracketleftoHM
34,[oEF
23,oTV
10,oHM
main]/angbracketright,
one per each transition path, resulting in the following two
new edges added:/angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright/angbracketleftoHM
34,[oEF
16,oNT5,oHM
main]/angbracketrightand
/angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketright/angbracketleftoHM
34,[oEF
23,oTV
10,oHM
main]/angbracketright.
2.4 Object-Sensitive Pointer Analysis
Considertheclass EditFolder withonCreate() showninFigure4.
At line 4, its intentEF is known to point to only one of the two
intentobjectspassedfromlines15and22inFigure3(a),respectively.
1 class EditFolder extends  Activity {
2  protected  void onCreate(...) {
3   ...
4   Intent intentEF  = getIntent();
5   ... } }
Figure 4: Context-sensitive pointer analysis of callbacks
with context-insensitive and context-sensitive ATGs.
Based on the context-insensitive ATG in Figure 3(c), existing
context-sensitive pointer analyses for Android apps [ 9,31] will
analyze all the callbacks of an activity context-insensitively. As
there is only one instance of EditFolder ,/angbracketleftoEF,∅/angbracketright, in Figure 3(c),
onCreate() will be analyzed only once on the receiver object
/angbracketleftoEF,∅/angbracketright. As a result, intentEF at line 4 in Figure 4 will point to
the two intent objects passed from lines 15 and 22 in Figure 3(a).
Chime builds one of the two context-sensitive ATGs in Fig-
ures 3(d) and (e) depending on whether Homeis configured with
singleTask orstandard launch mode. There are two instances
ofEditFolder ,/angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright(representing the instance of
EditFolder ,startedatline16inFigure3(a))and /angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketright
(representing the instance of EditFolder , started at line 23 in Fig-
ure 3(a)). Our activity-aware object-sensitive pointer analysis is
abletoanalyze onCreate() separately.With/angbracketleftoEF
16,[oNT5,oHM
main]/angbracketrightas
itsreceiverobject, intentEF willpointtotheintentobjectpointed
to byNTtoEFat line 15 in Figure 3(a). With /angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketrightas its
receiver object, intentEF will point to the intent object pointed to
byTVtoEFat line 22 in in Figure 3(a).
3 APPROACH
First,wereviewbrieflyAndroid’sintentsanditsICCmechanism
(Section3.1)andintroduceournotationsused(Section3.2).Next,
we discuss how Chime preprocesses an app to enable our subse-
quentanalyses(Section3.3).Then,weintroduceouractivity-aware
object-sensitivepointeranalysis(Section3.4).Finally,westartwith
a context-insensitive approach (Section 3.5) and then move to a
context-sensitiveone(Section3.6)formodelingactivitytransitions.
3.1 Android Intents and ICC Calls
Theintentat an ICC call, e.g., startActivity(intent) deter-
minesthetargetactivitytobeopened,where intentiseither ex-
plicitorimplicit.Withanexplicitintent,theclassnameofthetargetactivity is explicit (e.g., as in line 3 in Figure 1). With an implicit in-
tent, an action,together with some data withwhich to perform the
action, is provided. The Android framework will find a target class
witharegisteredintentfilter(initsapp’s AndroidManifest.xml )
that has advertised its ability for performing the action.
The Android framework provides various APIs to store
the information regarding a target activity in the fields ofan intent object, such as
setClassName() andsetAction() ,
whose parameters are target class name and action name, re-
spectively. For an explicit intent, the target class name isstored into the field
Intent.mComponent.mClass , where the
type ofIntent.mComponent isComponentName and the type of
ComponentName.mClass isString. We will use the action field,
Intent.mAction ,toresolveanimplicitintent.Therefore,thetarget
activityofanICCcallcanbedeterminedbyqueryingthepointed-to
values in the fields of an intent object (Section 3.4).
3.2 Notations
Figure5givesournotations.Thefirstpartliststhedomainsused.
Abstract objects are created at object allocation sites. To achieve
object-sensitivity, a context is a sequence of abstract objects.
variable intent,cpnt,a∈V
class type t∈T
abstract object oi,ot,ot
i∈O
context c∈C=∅∪O∪O2∪...
launch mode{Std,Top,Task,Inst}=LM
pt:V×C→P(O×C)
fpt:O×C×F→P(O×C)
newActObj :T→O
heapCtxSelector :O×C→C
mtdCtxSelector :O×C→C
ATGG=(V,E)
ATG Node/angbracketleftoi,c/angbracketright∈V⊆O×C
ATG Edge/angbracketleftoi,c/angbracketright/arrowhookleft→p/angbracketleftoj,c/prime/angbracketright∈E⊆V×V×N
Figure 5: Notations.
The middle part lists several functions used in our inference
rules.pt(p,c) gives the points-to set of a pointer punder context c.
fpt(oi,c,f)givesthepoints-tosetofthefield fofanobject oiunder
contextc.newActObj (t) creates an instance of an activity class t
inmain()(whilenew(t)appliestoeveryothertype t).Following
[12,21,22,29], we use mtdCtxSelector (heapSelector ) to generate
a method(heap) context required for analyzing (identifying) avir-
tual method call (a non-activity object) to enable k-object-sensitive
pointer analysis. Note that heapCtxSelector andmtdCtxSelector
are recursively defined. For heapCtxSelector , the object oiat al-
location site iis modeled context-sensitively by a heap context
[oi1,...,oik−1](oflength k−1),where ijistheallocationsitefor
thereceiverobject oijofthemethodthatcontains ij−1(withi0=i).
FormtdCtxSelector ,i fxpoints to an object oimodeled under a
heap context [ oi1,...,oik−1], then the k-object-sensitive method
contextusedforanalyzingavirtualcall x.foo()is[oi,oi1,...,oik−1].
The bottom part defines an ATG as a directed multi-edge graph
for an app. A node /angbracketleftoi,c/angbracketrightrepresents a context-sensitive instance of
601
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Launch-Mode-Aware Context-Sensitive Activity Transition Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
anactivity.Anedge /angbracketleftoi,c/angbracketright/arrowhookleft→p/angbracketleftoj,c/prime/angbracketrightfromaparentactivity /angbracketleftoi,c/angbracketright
toachildactivity/angbracketleftoj,c/prime/angbracketrightrepresentsanactivitytransition,where
/angbracketleftoi,c/angbracketrightstarts/angbracketleftoj,c/prime/angbracketrightviaanICCcall,say, startActivity() atlinep.
In Figures 1 and 3, the line numbers on their edges are elided.
WewillpresentourformalismforaJava-likelanguageconsisting
offivetypesofstatements:objectallocation( x = new t() ),copy
(x=y), load (x = y.f ), store (x . f=y ) and virtual call ( x=
y.g(arg 1,...,arg n)).Staticvariablesandstaticmethodcallsare
excluded but handled context-insensitively.
In addition, we handle four types of ICC-related statements
specially. We resolve an explicit intent at intent.mComponent =
cpntand an implicit intent at intent.mAction = action . For
activity-related ICC calls, we consider startActivity(intent)
(for starting an activity) and setResult(intent) (for receiving
a result from an activity). Note that startActivity() repre-
sents all the APIs that can start an activity, including, e.g., also
startActivityForResult() andstartActivityIfNeeded() .By
handling startActivity() ,onNewIntent() is also modeled. By
handling setResult(), onActivityResult() is also modeled.
3.3 Preprocessing
During this preprocessing step, an app is decompiled to extract its
code and metadata, such as the launch mode of and intent filters
registeredbyeachactivityclassinits AndroidManifest.xml file.
To analyze an app, we must generate a slim harness main().
For the user-defined Android components of class types,
Service,BroadcastReceiver andContentProvider in an app,
w ep r o c e e da si n[ 1,9,31], by including in the harness (1) one
heap allocation site for each component class (for allocating one
abstract object from this class) and (2) a call to each of its callbacks
registered for the object. These components can start an activity
but do not otherwise contribute to activity transitions.
For the user-defined Android components of class type,
Activity ,theharnessforanappwillincludethesameinformation
pertainingonlytoitsentryactivities,i.e.,theonesregisteredvia
intent filters or exported to the system. All the other activities that
are started by these entry activities will be added later to the ATG
of the app context-sensitively during the analysis.
3.4 Activity-Aware Object-Sensitive
(Whole-Program) Pointer Analysis
Given an app, Chime builds a context-sensitive ATG G=(V,E)
while performing an object-sensitive pointer analysis to the app,
starting from its harness main(). Figure 6 gives our rules. Let
contexts(m) be the set of all the contexts reaching method mfrom
main(), where contexts(main())=∅. Initially, G=(V,E) is empty.
Letusconsiderthefirstsixrules.Wehandleanobjectallocation
site dependingon whetherit isfor anactivity classin main()([P-
NewAct])orotherwise([P-NewOther]).Intheformercase,the
activityinstancecreatedisaddedtotheATG.Noedgesareavailable
at this stage yet. In each case, o−
iuniquely identifies the abstract
object created as an instance of tat allocation site i.
In[P-Copy], [P-Load], [P-Store] and[P-Call],wehandleallthe
other non-ICC-related statements. In [P-Copy], the points-to facts
flow from RHS to the LHS of a copy statement. In [P-Load] and
[P-Store],thefieldsofanabstractobject oiaredistinguished.Inm: the containing method for each statement being analyzed
i:x=newt()m=main()
ti sas u b t y p eof Activity
/angbracketleftot
main,∅/angbracketright∈pt(x,∅)
/angbracketleftot
main,∅/angbracketright∈V[P-NewAct]
i:x=newt()c∈contexts(m)
¬(m=main()∧ti sas u b t y p eof Activity)
/angbracketleftoi,heapCtxSelector (oi,c)/angbracketright∈pt(x,c)[P-NewOther]
x=yc∈contexts(m)
pt(y,c)⊆pt(x,c)[P-Copy]
x=y.fc∈contexts(m)/angbracketleftoi,c/prime/angbracketright∈pt(y,c)
fpt(oi,c/prime,f)⊆pt(x,c)[P-Load]
x.f=yc∈contexts(m)/angbracketleftoi,c/prime/angbracketright∈pt(x,c)
pt(y,c)⊆fpt(oi,c/prime,f)[P-Store]
x=y.д(arд1,...,arдn)
c∈contexts(m)/angbracketleftoi,c/prime/angbracketright∈pt(y,c)
д/prime=dispatch( oi,д)c/prime/prime=mtdCtxSelector (oi,c/prime)
c/prime/prime∈contexts(д/prime)/angbracketleftoi,c/prime/angbracketright∈pt(д/prime
this,c/prime/prime)
∀1/lessorequalslantk/lessorequalslantn:pt(arдk,c)⊆pt(д/prime
pk,c/prime/prime)
pt(д/prime
ret,c/prime/prime)⊆pt(x,c)[P-Call]
intent.mComponent =cpntc∈contexts(m)
/angbracketleftoi,c/prime/angbracketright∈pt(intent,c)/angbracketleftoj,c/prime/prime/angbracketright∈pt(cpnt,c)
fpt(oj,c/prime/prime,mClass)⊆fpt(oi,c/prime,tgtClassName)[I-Ex]
intent.mAction =actionc∈contexts(m)
/angbracketleftoi,c/prime/angbracketright∈pt(intent,c)/angbracketleftoj,_/angbracketright∈pt(action,c)
actionToCpnt (oj)⊆fpt(oi,c/prime,tgtClassName)[I-Im]
p:this.startActivity (intent)c∈contexts(m)
thisinstanceof Activity /angbracketleftoi,c/prime/angbracketright∈pt(this,c)
/angbracketleftoj,c/prime/prime/angbracketright∈pt(intent,c)/angbracketleftok,_/angbracketright∈fpt(oj,c/prime/prime,tgtClassName)
t=дetType(ok)lm=дetLM(t)
(/angbracketleftoi,c/prime/angbracketright,/angbracketleftoj,c/prime/prime/angbracketright,lm,p)/leadstot[I-Act]
this.setResult (intent)c∈contexts(m)
thisinstanceof Activity /angbracketleftok,c/prime/angbracketright∈pt(this,c)
/angbracketleftoj,c/prime/prime/prime/angbracketright∈pt(intent,c)/angbracketleftoi,c/prime/prime/angbracketright/arrowhookleft→−/angbracketleftok,c/prime/angbracketright∈E
modelSetResult(/angbracketleft oi,c/prime/prime/angbracketright,/angbracketleftoj,c/prime/prime/prime/angbracketright)[I-Ret]
Figure 6: Rules for activity-aware object-sensitive pointer
analysis(tgtClassName isapseudofieldforanintentobject).
[P-Call], the function dispatch(oi,д) is used to resolve the virtual
dispatch of method дon the receiver object oito beд/prime. We assume
thatд/primehas a formal parameter д/prime
thisfor the receiver object and
д/prime
p1,...,д/prime
pkfor the remaining parameters, and a pseudo-variable
д/prime
retis used to hold the return value of д/prime.
Finally,letusconsiderthelastfourrulesforhandlingICC-related
statements. [I-Ex]and[I-Im]resolveexplicitandimplicitintents,
respectively (passed via ICC calls). To handle both uniformly, a
pseudo field of type String,tgtClassName, for an intent is used.
In[I-Ex], we analyze intent.mComponent = cpnt by storing
the name of each target activity class in cpnt.mClass directly
intointent.tgtClassName .I n[I-Im], we do likewise in analyzing
intent.mAction = action except that actionToCpnt (oj) gives
risetothesetoftargetclasses(identifiedagainbytheirnames)that
have registered an intent filter for performing action oj.
[I-Act] and[I-Ret] handle the two ICC APIs,
a.startActivity() anda.setResult() , respectively. For
602
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Yifei Zhang, Yulei Sui, and Jingling Xue
simplicity, we assume that a = this , wherethisis an instance
ofActivity .Thiscapturesthetwomostlycommonlyusedcases.
Theothercasescanbehandledsimilarly,involvingasimplesearch
for anyparent activitythat maypossibly start achild activityand
possibly receive a result from the child activity in the app.
In[I-Act],everycallto this.startActivity(intent) atlinep
induces a fact (/angbracketleftoi,c/prime/angbracketright,/angbracketleftoj,c/prime/prime/angbracketright,lm,p)/leadstot, meaning that a parent
activity/angbracketleftoi,c/prime/angbracketrightstarts an instance of activity class twith its launch
modelmat linep, with/angbracketleftoj,c/prime/prime/angbracketrightpassed as the intent object. Here,
дetType(ok) maps the name of a class okto its corresponding class
type and дetLM(t) obtains the launch mode of an activity class t.
In[I-Ret], we analyze setResult(intent) , where the
intent is given by /angbracketleftoj,c/prime/prime/prime/angbracketright, which is invoked on a child
activity/angbracketleftok,c/prime/angbracketrightin order to find its matching callback
onActivityResult( ...,intentRES) that is invoked on its
parent activity/angbracketleftoi,c/prime/prime/angbracketright(thanks to the ATG built on the fly).
Now,modelSetResult (/angbracketleftoi,c/prime/prime/angbracketright,/angbracketleftoj,c/prime/prime/prime/angbracketright) simply tells the pointer
analysistoanalyze onActivityResult( ...,intentRES) invoked
on/angbracketleftoi,c/prime/prime/angbracketright, whereintentRES points to/angbracketleftoj,c/prime/prime/prime/angbracketright.
3.5 Launch-Mode-Unaware Context-Insensitive
Activity Transition Analysis
Figure 7givesthe rule [Act-Ci] for buildinga context-insensitive
ATG,G=(V,E),andalsoperformingthepointeranalysisforthe
callbacks of every newly started activity at the same time.
(/angbracketleftoi,∅/angbracketright,/angbracketleftoj,c/angbracketright,_,p)/leadstot
ot=newActObj (t)/angbracketleftoj,c/angbracketright∈fpt(ot,∅,mIntent)
/angbracketleftot,∅/angbracketright∈V/angbracketleftoi,∅/angbracketright/arrowhookleft→p/angbracketleftot,∅/angbracketright∈E
modelCallBacks(/angbracketleft ot,∅/angbracketright)
modelNewIntent(/angbracketleft ot,∅/angbracketright,/angbracketleftoj,c/angbracketright)[Act-Ci]
Figure 7: A rule for context-insensitive activity transition
analysis (as assumed in the state of the art).
Accordingtothepriorwork[ 1,2,4,9,14,23–26,31],onlyone
abstractobject,/angbracketleftot,∅/angbracketright,(withanemptycontext ∅)iscreatedforeach
activity class t. In addition, the launch mode for tis ignored.
Given the new activity /angbracketleftot,∅/angbracketrightstarted,modelActivity (/angbracketleftot,∅/angbracketright)
tellsthepointeranalysistoanalyzethecallbacksof tinvokedon
/angbracketleftot,∅/angbracketright.Inaddition,fortheintentobject /angbracketleftoj,c/angbracketright,whichisnowadded
toot.mIntent(undercontext∅)andcanberetrievedlaterbycalling
getIntent() on/angbracketleftot,∅/angbracketright,modelNewIntent() serves to inform the
pointer analysis to analyze onNewIntent() with this intent on the
receiver/angbracketleftot,∅/angbracketrightconservatively (as this may be reused).
3.6 Launch-Mode-Aware Context-Sensitive
Activity Transition Analysis
Figure 8 is an analogue of Figure 7 except that our analysis now is
launch-mode-aware and builds a context-sensitive ATG, G=(V,E).
Theexecutionofanappismanagedbyoneormoretasks.Every
task has a back stack, which is used to manage activity navigations
(adding a newly created activity to the stack) and backtracking(popping off the finished activity off the stack). A launch mode
specifies how a new instance of an activity class is associated with
thecurrenttask[ 11].Developersselectlaunch modestoprovidea smooth and consistent user experience or to achieve design re-
quirements such as the singleton pattern. In Figure 3, two different
launch modes, singleTask andstandard , forHomeare illustrated.
Withthehelpofacontext-sensitiveATG,differentlaunchmodes
can now be distinguished and effectively handled during the analy-sis.TheATGkeepstrackofactivitytransitionsforeverytransition
path, mimicking the back stack of a task. Let us examine the rules
for handling four types of of launch modes: [L-Std](standard ),
[L-TopReuse] and[L-TopNew] (singleTop ),[L-TaskReuse] and
[L-TaskNew] (singleTask), and [L-Inst](singleInstance).
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Std,p)/leadstot
hc=heapCtxSelector (oi,c)
otp=newActObj (t)
/angbracketleftotp,hc/angbracketright∈V/angbracketleftoi,c/angbracketright/arrowhookleft→p/angbracketleftotp,hc/angbracketright∈E
/angbracketleftoj,c/prime/angbracketright∈fpt(otp,hc,mIntent)
modelCallBacks(/angbracketleft otp,hc/angbracketright)[L-Std]
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Top,p)/leadstotд e t T y p e (oi)=t
/angbracketleftoi,c/angbracketright/arrowhookleft→p/angbracketleftoi,c/angbracketright∈E
modelNewIntent(/angbracketleft oi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright)[L-TopReuse]
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Top,p)/leadstotд e t T y p e (oi)/negationslash=t
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Std,p)/leadstot[L-TopNew]
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Task,p)/leadstot
/angbracketleftok,c/prime/prime/angbracketright/arrowhookleft→∗/angbracketleftoi,c/angbracketrightдetType(ok)=t
/angbracketleftoi,c/angbracketright/arrowhookleft→p/angbracketleftok,c/prime/prime/angbracketright∈E
modelNewIntent(/angbracketleft ok,c/prime/prime/angbracketright,/angbracketleftoj,c/prime/angbracketright)[L-TaskReuse]
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Task,p)/leadstot
/angbracketleftok,c/prime/prime/angbracketright/negationslash/arrowhookleft→∗/angbracketleftoi,c/angbracketrightдetType(ok)=t
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Std,p)/leadstot[L-TaskNew]
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Inst,p)/leadstot
(/angbracketleftoi,c/angbracketright,/angbracketleftoj,c/prime/angbracketright,Task,p)/leadstot[L-Inst]
Figure 8: Rules for Chime’s launch-mode-aware context-sensitive activity transition analysis.
standard.
For the default launch mode, we always create a
new instance of t, identified by/angbracketleftotp,hc/angbracketright, wherepis the line num-
ber of its corresponding startActivity() , and then deliver its
passed-in intent to this new activity object. While the ATG grows,
modelCallBacks (/angbracketleftotp,hc/angbracketright) serves again (as in [Act-Ci]) to request
the callbacks on the new activity /angbracketleftotp,hc/angbracketrightto be analyzed now.
singleTop. If the activity to be started has the same type as the
top activity, then the top activity is reused ([L-TopReuse] ), with its
onNewIntent() reanalyzed ( modelNewIntent() ). Otherwise, we
handle it identically as in the case of standard ([L-TopNew]).
singleTask. This mode is similar to singleTop , except that
the activity instance closest to the top of the back stack will be
reused if it has the same type as the new activity to be started ([L-
TaskReuse]). Otherwise, we fall back to the case where standard
is handled ([L-TaskNew] ). Here,/angbracketleftok,c/prime/prime/angbracketright/arrowhookleft→∗/angbracketleftoi,c/angbracketrightrepresents
thestandardgraphreachabilityonadirectedgraphexceptthatit
disallowstheexistenceofanyintermediatenode /angbracketleftos,c/prime/prime/prime/angbracketrightsuchthat
/angbracketleftos,c/prime/prime/prime/angbracketright/arrowhookleft→∗/angbracketleftoi,c/angbracketrightalso holds, where дetType(ok)=дetType(os).
603
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Launch-Mode-Aware Context-Sensitive Activity Transition Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
singleInstance. This mode is similar to singleTask , except
that only one instance of its activity class resides in its task. There-
fore, this mode is handled identically as singleTask ([L-Inst]).
3.7 Discussion
Inourevaluation,wewillcompareChimewithCiChime,aversion
of Chime, with [ACT-CI] used for building the ATG for an app.
Given the same object-sensitive pointer analysis applied to a given
app, Chime’s ATG is strictly non-less precise than CiChime’s ATG
as the former is context-sensitive but the latter is not.
Thus, the pointer analysis under Chime will also be strictly non-
less precise than the one under CiChime. With a context-sensitive
ATG, Chime enables an activity’s callbacks to be analyzed context-
sensitively. With a context-insensitive ATG, however, CiChime
allows such callbacks to be analyzed only context-insensitively.
3.8 Example
LetusgothroughsomeofourrulesfortheexampleinFigure3(with
Homeconfiguredfor singleTask andtheothersfor standard )to
see how Chime builds the context-sensitive ATG in Figure 3(d).
Initially, the ATG contains /angbracketleftomain
HM,∅/angbracketright, an instance of Homeallocated
when its harness main()is analyzed ([P-NewAct] ). Leto4ano9
betheintentobjectsresolvedatlines4and9respectively,sothat
weobtain "NewTrip"∈fpt(o4,_,tgtClassName )and"TripView"
∈fpt(o9,_,tgtClassName )([I-Ex]). By applying [I-Act]to lines
5 and 10, the two ICC call relations ( /angbracketleftomainHM,∅/angbracketright,/angbracketlefto4,_/angbracketright,Std,5)/leadsto
NewTrip and (/angbracketleftomainHM,∅/angbracketright,/angbracketlefto9,_/angbracketright,Std,10)/leadstoTripView are estab-
lished.Byfurtherapplying [L-Std]tothesetworelations,where
heapCtxSelector (omain
HM,∅)=[omainHM], we obtain two new activity
objectsoNT
5andoTV
10. In addition, two ATG edges /angbracketleftoHM
main,∅/angbracketright/arrowhookleft→5
/angbracketleftoNT
5,[oHM
main]/angbracketrightand/angbracketleftoHMmain,∅/angbracketright/arrowhookleft→10/angbracketleftoTV
10,[oHM
main]/angbracketrightare discovered.
Similarly, we can resolve the ICC calls at lines 16 and 23. Let o15
ano22betheintentobjectsresolvedatlines15and22,respectively,
so that we obtain "EditFolder"∈fpt(o15,_,tgtClassName )
and"EditFolder"∈fpt(o22,_,tgtClassName )([I-Ex]). At line
16, we obtain (/angbracketleftoNT
5,[oHM
main]/angbracketright,/angbracketlefto15,_/angbracketright,Std,16)/leadstoEditFolder
([I-Act]). By applying ([L-Std]) to this relation, where
heapCtxSelector (oNT
5,[oHM
main] )=[ oNT
5,oHM
main], we obtain
(/angbracketleftoNT
5,[oHM
main]/angbracketright/arrowhookleft→16/angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright. At line 23, we ob-
tain (/angbracketleftoTV
10,[oHM
main]/angbracketright,/angbracketlefto22,_/angbracketright,Std,23)/leadstoEditFolder ([I-
Act]). By applying ([L-Std]) to this relation, where
heapCtxSelector (oTV
10,[oHM
main] )=[ oTV
10,oHM
main], we obtain
(/angbracketleftoTV
10,[oHM
main]/angbracketright/arrowhookleft→23/angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketright.
Finally, we consider the startActivity() at line 34. Let
o33be the intent object resolved at line 33, so that "Home"∈
fpt(o33,_,tgtClassName )([I-Ex]). Two relations will be estab-
lished at line 34, ( /angbracketleftoEF
16,[oNT5,oHM
main]/angbracketright,/angbracketlefto33,_/angbracketright,Task,34)/leadstoHome
and (/angbracketleftoEF
23,[oTV
10,oHM
main]/angbracketright,/angbracketlefto33,_/angbracketright,Task,34)/leadstoHome.A sHomeuses
singleTask launch mode, the final ATG is shown in Figure 3(d).
4 EVALUATION
The objective of our evaluation is to demonstrate that our context-
sensitiveactivitytransitionanalysisismoreprecisethanitscontext-
insensitive counterpart in modeling activity transitions, guiding
GUI testing, and improving the pointer analysis precision.4.1 Implementation
ChimeisbuiltontopoftheSparkpointeranalysisframeworkin
DroidSafe[ 9].WeleveragetheAndroidDeviceImplementation
(ADI) provided by DroidSafe [ 9], a comprehensive modeling of
the Android framework and Java library, to improve the precision
and soundness of our analysis. DroidSafe is used to decompile
anapp,generateaslimharness main(),andobtainappmatadata
from its manifest file. To resolve reflection, we use Ripple [ 34] but
may consider a hybrid analysis [18] in future work.
4.2 Experimental Setup and Methodology
Wehaveselected a total of 42Androidapps in the top-chart free
apps from Google Play downloaded on 30 November 2016. Our
k−object-sensitivepointeranalysisisconfiguredtobe2obj+h(with
two elements for a method context and one for a heap context),
whichisawidelyusedconfigurationforachievingthebesttradeoff
between precision and scalability [12, 17, 28–30].
Ourexperiments areconductedon aXeon E5-16603.2GHzma-
chinewith256GBRAMrunningUbuntu16.04LTS.Theanalysis
time of every app is the average of three runs.
Chimemodelsactivitytransitionscontext-sensitivelyanddistin-
guishes activity launch modes. To demonstrate the benefits of our
approach,wecompareChimewithCiChime,asimplifiedversionof
Chime (realized with [Atg-Ai]), which models activity transitions
context-insensitively,andconsequently,incapableofhandlingor
distinguishing activity launch modes adequately.
Our evaluation answers the following research questions (RQs):
•RQ1.Is Chime able to distinguish an activity along different
transition paths compared with CiChime?
•RQ2.Is Chime capable of analyzing launch modes effectively?
•RQ3.is Chime useful for facilitating GUI testing?
•RQ4.is Chime able in improving the pointer analysis precision?
4.3 Results and Analysis
4.3.1 RQ1. Activity Transition .Table1comparesChimeand
CiChimeintermsoftheATGsconstructedforthe42appsevaluated.
For each app, the context-sensitive ATG from Chime is usually
largerthanthecontext-insensitiveATGfromCiChime(Columns
“ATGNode”and“ATGEdge”).ToseewhyChimecandistinguish
different activity transition sequences leading to an activity better
thanCiChime,werelyonthemaximal/average/minimalnumber
oftheclasstypesofthepredecessoractivitiesofanactivityinan
ATG (Columns “Max/Avg/Min Typ”). The “Max/Avg/Min Typ” for
Chime is always no larger than that for CiChime, showing that
Chime can distinguish different activities that would otherwise be
merged under CiChime. Figure 9 plots the same data measured by
thesethreemetrics.Finally,Chimeismorecostlyinmaintaining
context-sensitivity.Theaveragepointeranalysistimespentperapp
is 183.9 seconds under CiChime but 472.6 seconds under Chime.
4.3.2 RQ2. Launch Modes .Launchmodesforactivitiescan
significantly affect how activities are created and their transitions.
We first examine the widespread use of special launch modes,
singleTask ,singleTop andsingleInstance , other than just
standard inreal-worldAndroidapps.Wethenpresentanddiscuss
604
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Yifei Zhang, Yulei Sui, and Jingling Xue
Table1:ComparingChimeandCiChimeintermsofATGsconstructed.Foreachapp,Column“ATGNode”(“ATGEdge”)gives
thenumberofnodes(edges)inanATG,Column“Max/Avg/MinTyp”representsthemaximal/average/minimalnumberofthe
class types of the predecessor activities of an activity, and Column “PTA Time” gives the pointer analysis time in seconds.
App
IDApp NameCiChime Chime App
IDApp NameCiChime Chime
ATG
NodeATG
EdgeMax
TypAvg
TypMin
TypPTA
TimeATG
NodeATG
EdgeMax
TypAvg
TypMin
TypPTA
TimeATG
NodeATG
EdgeMax
TypAvg
TypMin
TypPTA
TimeATG
NodeATG
EdgeMax
TypAvg
TypMin
TypPTA
Time
1Instagram 12 171 10 3.8 1 238 288 6440 2 1.2 1 844 22Opal 10 38 9 2.8 1 26 46 113 1 1 1 50
2GoogleLite 4 12 2 1.7 1 16 11 39 1 1 1 25 23RollingSky 9 242 9 3.8 1 288 37 998 1 1 1 439
3Raider 6 7 2 1.2 1 19 17 21 1 1 1 29 24StarWars 4 9 2 1.7 1 24 8 11 1.5 1.2 1 35
4Speed 11 19 6 1.6 1 34 13 20 6 1.6 1 54 25ClashofClan 251 1 1 1 5 25 1 1 1 2 1
5FlashLight 51 1 4326 8 13 25 1.5 1.3 1 108 26TripView 12 14 2 1.1 1 11 28 41 1 1 1 19
6Booster 653 2 1 3 0 653 2 1 4 5 27FireFox 11 57 7 2.8 2 71 124 272 2 1.1 1 190
7Seek 484 2 1 1 9 11 15 1 1 1 29 28PowerCleaner 27 19 4 1.3 1 44 77 110 1 1 1 119
8ANZ 7 187 7 5 1 23 50 1182 1 1 1 41 29TalkingAngela 31 0 1113 8 51 01116 2
9Antivirus 26 244 20 8.2 1 508 369 5101 17 2.3 1 1800 30SpeedTest 3 3 2 1.5 1 83 6 6 1 1 1 136
10Solitaire 261 1 1 6 6 26 126 1 1 1 148 31TalkingTom 31 0 1114 2 51 01116 7
11Clean 8 7 3 1.7 1 34 9 7 3 1.7 1 53 32Slots 4 41 2 1.3 1 12 7 103 1 1 1 17
12PhoneClean 16 29 9 2 1 44 28 61 4.2 1.3 1 80 33HealthEngine 8 149 8 5.6 1 73 113 7713 1 1 1 210
13Pool 2 19 2 1.5 1 18 32 8 1112 6 34Tiles 18 675 18 5.4 1 824 391 23589 2 1.1 1 2901
14PayPal 15 221 15 4 1 19 90 1943 1 1 1 77 35HillClimb 4 119 4 2.3 1 84 8 236 1 1 1 126
15ClashRoyale 251 1 1 1 5 251 1 1 2 1 36HungryJacks 11 34 10 3.4 1 45 52 152 1.6 1.1 1 80
16MobileStrike 51 3 3211 8 15 45 1 1 1 27 37MachineZone 51 3 3211 7 15 45 1 1 1 27
17Cleaner 7 6 3 1.7 1 30 7 6 3 1.7 1 48 38DeathWorm 3 5 3 2.5 2 31 69 1 1 1 4 7
18Domino 3 11 2 1.3 1 19 16 47 1.8 1.3 1 31 39Wallet 18 186 12 4.9 1 166 426 11260 10.1 2.3 1 867
19Mail 21 710 21 9.8 2 2960 364 5216 2.6 1 1 6252 40Legends 4 9 3 1.5 1 12 41 165 1 1 1 28
20VLC 11 71 6 2.9 1 17 168 5357 2.8 1.4 1 105 41Catch 40 232 21 3.1 1 1312 216 953 18 1.8 1 2398
21PowerClean 21 45 8 3.1 1 81 80 77 1 1 1 301 42K9 20 78 8 3.2 1 231 277 1775 2 1 1 1868
11 1 1 1 11 11 1 1111 111 11 111111 1 11 113579111315171921
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 4142Max/Avg/Min Typ 
App IDCICHIME
CHIME
Figure 9: Comparing CiChime andChimegraphically in
terms of “Max/Avg/Min Typ” from Table 1. For each bar, itstop edge represents “Max Typ”, its bottom edge represents
“Min Typ” and the dash in the bar represents “Avg Typ”. In
the case of a “1”, “Max Typ” = “Avg Typ” = “Min Typ” = 1.
the results of our launch mode analysis. Finally, we use a real-
world Android app to demonstrate the effectiveness of our activity
transition analysis in handling special launch modes.
Figure 10 present our results on the activity classes analyzed by
Chime in all the 42 apps, with default and special launch modes.
Note that for each activity class, only one launch mode is counted
(statically).Wecanseethat30%ofallactivityclassesareconfigured
with special launch modes. Developers often use special launch
modesforsomeactivitiesinreal-worldAndroidappsinordertoprovide a smooth and consistent user experience. Such special
launch modes are also used to achieve certain design requirements
such as the singleton pattern. Therefore, it is important to develop
a launch-mode-aware analysis to understand activity transitions.
Let us examine why Chime can but CiChime cannot handle
four types of activity launch modes, The key difference between a
speciallaunchmodeandthedefaultmode(i.e., standard )isthat
the former may cause an existing activity to be resumed but the
latter will always cause a new activity to be created.
Without context-sensitivity, CiChime represents all instances of
anactivityclasswithonesingleabstractobject.Asaresult,differentlaunchmodescannotbedistinguished.Inacontext-insensitiveATG
constructed, its edges are unaware of the launch modes used.
Withcontext-sensitivity,Chimecandistinguishdifferentlaunch
modesasitcandistinguishdifferentinstancesofanactivityclass
under different activity transition sequences. In a context-sensitive
ATGconstructed,itsedgesareessentiallyannotatedwiththelaunch
modes used. To see this, let us distinguish two types of edges in
anATG:(1) StdEdgecorrespondingto standard and(2)SplEdge
corresponding to singleTask, singleTop,o rsingleInstance.
Table2givesourresultsforindividualapps.Foreachapp,while
many activity classes are configured with the default launch mode,
manyothersusespeciallaunchmodes(Columns“Std”and“Spl”).
Note that these two columns contain the raw data used for plot-ting Figure 10. For each app, its ATG consists of not only edges
markedby StdEdge butalsomanyotheredgesmarkedby SplEdge
(Columns“StdEdge”and“SplEdge”).Forsomeapps,suchas Seek,
an activity class configured with a special launch mode may not
haveanyincomingedgeoftype SplEdge sinceonlyoneinstanceis
ever created. On the other hand, for Catch, 14 activity classes with
special launch modes result in 456 edges of type SplEdge.
For all the 42 apps combined, there are 275 and 138 activity
classesconfiguredforthedefaultandspeciallaunchmodes,respec-
tively (Figure 10). In the 42 ATGs constructed, there are 59275 and
14067 edges marked with StdEdgeandSplEdge, respectively.
Finally, let us conduct a case study, by considering the code
snippet from Catchin Figure 11. The launch mode for MainHome
(MH)issingleTask butthelaunchmodesfor SearchActivity (SA)
andShoppingCartView (SC) are irrelevant here. MHlaunches SAat
1andSAlaunches ( SC)a t2. Afterwards, SClaunches MHagain
at3.Chimegeneratesalaunch-mode-awareATGtocapturethe
activity transitions, by considering singleTask forMHat3([L-
TkPrev] inSection3.6),sothattheexisting MHisresumed.Thus,
the activity transitions oMH
mainoSA
9oSC
14are precisely captured.
605
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Launch-Mode-Aware Context-Sensitive Activity Transition Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Default
(standard)
(67%)singleTop
(11%)
singleTask
(16%)
singleInstance
(6%)Special
(33%)
Figure 10: Percentage of the analyzed activity classes with
the default and special launch modes in the 42 apps.
Table 2: Classification of ATG edges under the default and
special modes. For each app, Columns “Std” and “Spl” givethenumberofdifferentactivityclassesconfiguredwiththedefault and special launch modes, respectively. For each
ATG,Columns“StdEdge”and“SplEdge”givethenumberof
edges marked by StdEdge and SplEdge, respectively.
App
IDApp NameLaunch
ModeATG Edge
App ID App NameLaunch
ModeATG Edge
StdSplStdEdge SplEdge StdSplStdEdge SplEdge
1Instagram 93 5446 994 22Opal 91 113 0
2GoogleLite 40 39 0 23RollingSky 81 998 0
3Raider 42 20 1 24StarWars 31 92
4Speed 47 10 10 25ClashofClan 11 23
5FlashLight 32 23 2 26TripView 12 0 41 0
6Booster 24 23 27FireFox 74 255 17
7Seek 13 15 0 28PowerCleaner 52 2 110 0
8ANZ 70 1182 0 29TalkingAngela 12 37
9Antivirus 17 9 4632 469 30SpeedTest 21 60
10Solitaire 20 126 0 31TalkingTom 12 37
11Clean 26 43 32Slots 22 102 1
12PhoneClean 79 31 30 33HealthEngine 80 7713 0
13Pool 11 27 1 34Tiles 15 3 20805 2784
14PayPal 13 2 1883 60 35HillClimb 31 236 0
15ClashRoyale 11 23 36HungryJacks 10 1 131 21
16MobileStrike 50 45 0 37MachineZone 50 45 0
17Cleaner 25 33 38DeathWorm 21 90
18Domino 12 37 10 39Wallet 12 6 2623 8637
19Mail 17 4 5106 110 40Legends 31 164 1
20VLC 74 4957 400 41Catch 26 14 497 456
21PowerClean 13 8 76 1 42K9 18 2 1744 31
1 // launch mode: singleTask
2 class MainHome extends Activity {
3  void onNewIntent(Intent SCtoMH) {
4   setIntent(SCtoMH ); 
5   ...}
6  boolean onQueryTextSubmit(String query) {
7   Intent MHtoSA = new Intent( this, SearchActivity. class);
8   MHtoSA.putExtra( "search_query" , query);
9   startActivity( MHtoSA); } }
10 // launch mode: standard
11 class SearchActivity extends Activity {
12  void onClick(View view) {
13   Intent SAtoSC = new Intent( this,ShoppingCartView. class);
14   startActivity( SAtoSC); } }
15 // launch mode: singleTask  
16 class ShoppingCartView extends Activity {
17  boolean onOptionsItemSelected(MenuItem menuItem ) {
18   Intent SCtoMH = new Intent( this, MainHome. class);
19   startActivity( SCtoMH); } }ķ
ĸ
ĹNewActEdge NewAvtEdgePrevActEdge
Figure 11: Activity transitions tracked by Chime in Catch.
4.4 RQ3. GUI Testing
Existing static analyses, TrimDroid [ 23], Brahmastra [ 4] and
A3E[2], rely on context-insensitive ATGs to guide GUI testing. For
thisclient,ChimeisexpectedtobemoreeffectivethanCiChimeascontext-sensitiveATGsaremorebeneficialthancontext-insensitive
ATGs. For example, Brahmastra et al. [ 4] instrument an app to
track a transition path from one activity to another based on acontext-insensitiveATGfortheappinordertofindsecurityvul-
nerabilitiesatruntime.Duetocontext-insensitivity,theuserhas
toworkoutthetransitionpathsbetweenthetwoactivitiestobe
tested,withpotentiallysomeinfeasibletransitionpathsbeingin-
strumentedredundantly(causingfalsepositives).Thisproblemcan
bealleviatedifacontext-sensitiveATGisusedfortheapp,sincethe transition paths between two activities are available context-sensitively (with the number of infeasible transitions also being
reduced).
To demonstrate that Chime can be more effective than CiChime
in guiding GUI testing, Table 3 compares both in terms of the
averagenumberofactivityclasses(NAC)reachinganactivityclass
in an ATG (with each cycle in an ATG counted only once). Ina context-sensitive ATG, different nodes may represent different
instancesofacommonclass.Inthiscase,theNACfortheclassistheaverageoftheNACsonthetransitionpathsreachingallsuchnodes.Foragivenapp,thesmallerNACis,thelesseffortisexpectedtobe
spent on GUI testing. In general, Chime’s NAC is always no larger
than CiChime’s NAC. For 10 out of the 42 apps evaluated, both are
indistinguishable. There are two different reasons behind (Table 1).
In the case of Booster,CashRoyale ,Cleaner andClashofClan ,
Chime and CiChime produce the same ATG for each app. In the
caseoftheother6apps,theATGsbuiltbyChimeandCiChimefor
an app are different but their NACs happen to be the same.
Let us take a look at some specific activity classes. Consider
PostTwitterActivity fromHungryJacks . For CiChime, it is rep-
resentedby oneabstractobjectin theATG for HungryJacks .The
numberofactivityclassesreachingitis11.ForChime,thisabstract
object is split into 7 context-sensitive instances. The average num-
ber of activity classes reaching these instances remains to be 11.
Consider SignInActivity fromOpal.For CiChime,it isalso rep-
resentedbyoneabstractobjectintheATGfor Opal.Thenumber
of activity classes reaching it is 9. For Chime, this abstract object is
now split into 24 context-sensitive instances. The average number
of activity classes reaching these instances is 4.67.
4.5 RQ4. Pointer Analysis
Givenanapp,itsATGiscontext-sensitiveunderChimebutcontext-
insensitiveunderCiChime.Thus,ChimeismoreprecisethanCi-
Chime as the the callbacks of an activity are analyzed context-
sensitively under Chime but context-insensitively under CiChime.
Table4comparesChimeandCiChimeintermsoftheaverage
size of the points-to sets of the intent variables accessed in the
callstoonCreate() inalltheactivityclassesinanapp.ForChime,
the size of the points-to set of the intent variable accessed in a
onCreate() call is the average of the sizes of the points-to sets un-
derallitscontextsanalyzed.Recallhow intentEF inEditFolder in
Figure4isanalyzed(Section2.4),where EditFolder maybestarted
fromtwo differentcontexts, NewTripandTripView (Figure3(a)).
As CiChime is context-insensitive, intentEF inonCreate() will
pointtothetwointentobjectspassedbothcontextsindiscriminately.
However,Chimecandistinguishthetwointentsfor intentEF as
onCreate() is analyzed separately under these two contexts.
606
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Yifei Zhang, Yulei Sui, and Jingling Xue
Table3:ComparingChimeandCiChimeintermsoftheav-
eragenumberofactivityclassesreachinganactivityclassin
an ATG (measuring the effort spent in GUI testing).
App
IDApp Name CiChime ChimeApp
IDApp Name CiChime Chime
1Instagram 7.25 5.1222Opal 4.10 3.15
2GoogleLite 1.75 1.6723RollingSky 2.44 1.56
3Raider 2.17 1.7824StarWars 2.50 1.88
4Speed 2.55 2.3625ClashofClan 1.50 1.50
5FlashLight 1.80 1.3526TripView 2.00 1.93
6Booster 1.50 1.5027FireFox 3.45 2.42
7Seek 2.25 2.0028PowerCleaner 4.33 3.21
8ANZ 4.71 4.3229TalkingAngela 1.33 1.33
9Antivirus 10.12 8.2330SpeedTest 1.67 1.50
10Solitaire 1.50 1.5031TalkingTom 1.33 1.33
11Clean 1.50 1.5032Slots 2.50 2.08
12PhoneClean 4.56 4.5633HealthEngine 6.25 5.78
13Pool 1.50 1.5034Tiles 8.39 7.12
14PayPal 7.40 6.1235HillClimb 2.25 2.00
15ClashRoyale 1.50 1.5036HungryJacks 5.09 4.14
16MobileStrike 1.80 1.7337MachineZone 1.80 1.73
17Cleaner 1.57 1.5738DeathWorm 2.00 1.89
18Domino 2.33 1.9539Wallet 9.11 8.47
19Mail 8.86 7.2140Legends 2.00 1.96
20VLC 4.45 3.7041Catch 7.78 5.64
21PowerClean 2.29 1.4242K9 8.00 6.18
Givenanapp,theaveragesizeperpoints-tosetunderChimeisal-
waysnolargerthanthatunderCiChime.For Booster,CashRoyale ,
Cleaner andClashofClan , Chime and CiChime build the same
ATGineachcase(Table1).However,Chimeismoreprecisethan
CiChime as Chime allows an activity’s callbacks to be analyzed
context-sensitively.For Seek,Pool,Opal,SpeedTest ,HillClimb
andDeathWorm , Chime and CiChime build different ATGs (Ta-
ble1)but areequallyprecise.Letus seewhybyconsidering Seek
withfouractivityclasses,(1) MainActivity ,(2)AuthActivity ,(3)
HardUpgradeActivity , and (4)com.adobe.mobile.ar , where (1)
starts(2)twiceusingacommonintent,(1)starts(3)twiceusinga
commonintent,and(1)–(3)start(4)usingacommonintent.Dis-
tinguishing calling contexts for each onCreate() is not beneficial.
5 RELATED WORK
Pointer Analysis. Object-sensitivepointeranalysisproposed
by Milanova et al. [ 21,22] is known to be the best context-
sensitive pointer analysis for object-oriented programming lan-guages [
12,13,15–17,28–30]. Type sensitivity [ 28] and hybrid
context-sensitivity[ 12]aretwovariantsbasedonobject-sensitivity.
The former approximates (roughly) the objects created at alloca-
tionsitesbytheirdynamictypes,tradingprecisionforscalability
and efficiency. The latter applies call-site-sensitivity to static calls
andobject-sensitivitytovirtualcalls.Recently,Tanetal.improve
object-sensitivity pointer analysis to achieve better precision by
removing redundant context elements [ 29] and better scalability in
building call graphs by targeting type-dependent clients [30].
However,existingcontext-sensitivepointeranalysesareinsuf-
ficient in analyzing the Android-specific APIs, such as ICC calls,
which trigger a large number of callbacks interacting with the
Androidframework(e.g.,activityobjectscreatedtherein).Incon-
trast, Chime is aware of the activity-related APIs so that activity
transitions are modeled context-sensitively, thereby improving the
precision of the underlying object-sensitive pointer analysis.Table 4: Comparing Chime and CiChime in terms of the
average size of the points-to sets of the intent variables ac-cessed in the calls to onCreate() in all activity classes.
App
IDApp Name CiChime ChimeApp
IDApp Name CiChime Chime
1Instagram 16.33 10.78 22Opal 1.30 1.30
2GoogleLite 3.00 2.5823RollingSky 6.44 5.79
3Raider 5.33 3.8024StarWars 5.25 4.00
4Speed 4.45 4.0025ClashofClan 2.00 1.60
5FlashLight 5.60 5.0026TripView 4.08 3.92
6Booster 4.17 3.8327FireFox 20.82 8.98
7Seek 2.75 2.7528PowerCleaner 2.78 2.51
8ANZ 4.14 3.8629TalkingAngela 8.67 7.92
9Antivirus 11.42 7.7630SpeedTest 6.33 6.33
10Solitaire 6.50 4.2131TalkingTom 9.33 8.58
11Clean 4.75 4.1332Slots 4.75 4.38
12PhoneClean 4.88 4.1033HealthEngine 4.50 3.87
13Pool 2.00 2.0034Tiles 8.39 6.32
14PayPal 8.00 7.5935HillClimb 3.75 3.75
15ClashRoyale 2.00 1.6036HungryJacks 3.91 3.55
16MobileStrike 4.00 3.6037MachineZone 4.00 3.60
17Cleaner 4.14 3.8638DeathWorm 3.67 3.67
18Domino 8.67 6.7839Wallet 13.78 5.37
19Mail 17.19 11.00 40Legends 6.00 4.00
20VLC 5.91 5.0841Catch 8.60 5.94
21PowerClean 5.43 4.1942K9 19.95 8.59
Static Android App analysis. FlowDroid [ 1] is a popular
open-sourcestaticinformationflowanalysis,whichconstructsa
harnessmethodtomodelthebehaviorsoftheAndroidcomponentsin an app. Then a context-insensitive pointer analysis is performed
to construct its call graph and inter-procedural control-flow graph,
againstwhichsomeintra-componenttaintanalysisisperformed.
IccTA[14]representsastatictaintanalysisbuiltontopof Flow-
Droid to detect inter-component privacy leaks. It queries the ICC
analysis IC3 [ 25] to instrumentthe target activities startedat ICC
calls by using a flow- and context-insensitive pointer analysis.
DroidSafe [ 9] detects information leaks by applying an object-
sensitive pointer analysis to resolve the intents associate with ICC
calls.Amandroid[ 31]isastaticinter-componentdata-flowanal-
ysis framework for supporting security vetting tasks, by using a
call-site-sensitiveandflow-sensitivepointeranalysistoconstruct
the call graph for an app. Despite the fact that both frameworks
use context-sensitive pointeranalysis to constructcall graphs, all
the activities are still modeled context-insensitively.
Unliketheseearlierapproaches,Chimedistinguishesdifferent
activities launched under different launch modes along different
transitionsequencesbyusingcontext-sensitiveATGs,whichare
constructed on-the-fly during the object-sensitive pointer analysis
fortheentireapp.Suchcontext-sensitiveATGscanhelpimprove
the efficiency of GUI testing tools [2, 4, 23].
6 CONCLUSION
We present Chime, a launch-mode-aware context-sensitive activity
transition analysis for Android apps. Chime models the activitytransitions under different launch modes context-sensitively, to-gether with an object-sensitive pointer analysis. Our evaluation
showsthatourcontext-sensitiveactivitytransitionanalysisismore
precise than its context-insensitive counterpart in modeling activ-
itytransitions,facilitatingGUItesting,andimprovingthepointer
analysis precision for real-world Android apps.
607
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. Launch-Mode-Aware Context-Sensitive Activity Transition Analysis ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
REFERENCES
[1]Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexandre Bartel,
JacquesKlein,YvesLeTraon,DamienOcteau,andPatrickMcDaniel.2014. Flow-
Droid:PreciseContext,Flow,Field,Object-sensitiveandLifecycle-awareTaint
Analysis for Android Apps. In Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI ’14). ACM, New
York, NY, USA, 259–269. https://doi.org/10.1145/2594291.2594299
[2]TanzirulAzimandIulianNeamtiu.2013. TargetedandDepth-firstExploration
forSystematicTestingofAndroidApps.In Proceedings of the 2013 ACM SIGPLAN
International Conference on Object Oriented Programming Systems Languages &
Applications (OOPSLA ’13). ACM, New York, NY, USA, 641–660. https://doi.org/
10.1145/2509136.2509549
[3]Young-MinBaekandDoo-HwanBae.2016. AutomatedModel-basedAndroid
GUITestingUsingMulti-levelGUIComparisonCriteria.In Proceedings of the 31st
IEEE/ACM International Conference on Automated Software Engineering (ASE ’16).
ACM, New York, NY, USA, 238–249. https://doi.org/10.1145/2970276.2970313
[4]Ravi Bhoraskar, Seungyeop Han, Jinseong Jeon, Tanzirul Azim, Shuo Chen,
JaeyeonJung,SumanNath,RuiWang,andDavidWetherall.2014. Brahmastra:
DrivingAppstoTesttheSecurityofThird-PartyComponents.In 23rd USENIX
Security Symposium (USENIX Security ’14). USENIX Association, San Diego, CA,
1021–1036.
[5]Qi Alfred Chen, Zhiyun Qian, and Z. Morley Mao. 2014. Peeking into Your App
without Actually Seeing It: UI State Inference and Novel Android Attacks. In
23rd USENIX Security Symposium (USENIX Security ’14). USENIX Association,
San Diego, CA, 1037–1052.
[6]Lisa Nguyen Quang Do, Karim Ali, Benjamin Livshits, Eric Bodden, Justin Smith,
andEmersonMurphy-Hill.2017. Just-in-timeStaticAnalysis.In Proceedings of
the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis
(ISSTA ’17).ACM,NewYork,NY,USA,307–317. https://doi.org/10.1145/3092703.
3092705
[7]YuFeng,SaswatAnand,IsilDillig,andAlexAiken.2014. Apposcopy:Semantics-
based Detection of Android Malware Through Static Analysis. In Proceedings
of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software
Engineering (FSE ’14). ACM, New York, NY, USA, 576–587. https://doi.org/10.
1145/2635868.2635869
[8]Yu Feng, Osbert Bastani, Ruben Martins, Isil Dillig, and Saswat Anand. 2017. Au-
tomatedSynthesisofSemanticMalwareSignaturesusingMaximumSatisfiability.
InThe 2017 Network and Distributed System Security Symposium (NDSS ’17).
[9]MichaelIGordon,DeokhwanKim,JeffHPerkins,LimeiGilham,NguyenNguyen,
and Martin C Rinard. 2015. Information Flow Analysis of Android Applications
in DroidSafe. In The 2015 Network and Distributed System Security Symposium
(NDSS ’15).
[10]WeiHuang,YaoDong,AnaMilanova,andJulianDolby.2015.ScalableandPrecise
TaintAnalysisforAndroid.In Proceedings of the 2015 International Symposium
on Software Testing and Analysis (ISSTA ’15). ACM, New York, NY, USA, 106–117.
https://doi.org/10.1145/2771783.2771803
[11]Google Inc. 2017. Tasks and Back Stack. (2017). https://developer.android.com/
guide/components/activities/tasks-and-back-stack.html
[12]George Kastrinis and Yannis Smaragdakis. 2013. Hybrid Context-sensitivity
forPoints-toAnalysis.In Proceedings of the 34th ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI ’13).ACM,NewYork,
NY, USA, 423–434. https://doi.org/10.1145/2491956.2462191
[13]OndrejLhotákandLaurieHendren.2006. Context-sensitivepoints-toanalysis:
is it worth it?. In Proceedings of the 15th International Conference on Compiler
Construction (CC ’06). Springer, 47–64.
[14]LiLi,AlexandreBartel,TegawendéF.Bissyandé,JacquesKlein,YvesLeTraon,
Steven Arzt, Siegfried Rasthofer, Eric Bodden, Damien Octeau, and PatrickMcDaniel. 2015. IccTA: Detecting Inter-component Privacy Leaks in An-droid Apps. In Proceedings of the 37th International Conference on Software
Engineering - Volume 1 (ICSE ’15) . IEEE Press, Piscataway, NJ, USA, 280–291.
http://dl.acm.org/citation.cfm?id=2818754.2818791
[15]YueLi,TianTan,YuleiSui,andJinglingXue.2014. Self-inferencingReflection
ResolutionforJava.In 28th European Conference on Object-Oriented Programming
(ECOOP ’14). 27–53. https://doi.org/10.1007/978-3-662-44202-9_2
[16]Yue Li, Tian Tan, and Jingling Xue. 2015. Effective Soundness-Guided Reflection
Analysis. In 22nd International Static Analysis Symposium (SAS ’15). 162–180.
https://doi.org/10.1007/978-3-662-48288-9_10
[17]YueLi,TianTan,YifeiZhang,andJinglingXue.2016. ProgramTailoring:Slic-
ingbySequentialCriteria.In 30th European Conference on Object-Oriented Pro-
gramming, ECOOP 2016, July 18-22, 2016, Rome, Italy (ECOOP ’16). 15:1–15:27.
https://doi.org/10.4230/LIPIcs.ECOOP.2016.15
[18]Jie Liu, Yue Li, Tian Tan, and Jingling Xue. 2017. Reflection Analysis for Java:Uncovering More Reflective Targets Precisely. In 2017 IEEE 28th International
Symposium on Software Reliability Engineering (ISSRE ’17). 12–23. https://doi.org/10.1109/ISSRE.2017.36
[19]LongLu,ZhichunLi,ZhenyuWu,WenkeLee,andGuofeiJiang.2012. CHEX:Statically Vetting Android Apps for Component Hijacking Vulnerabilities. In
Proceedings of the 2012 ACM Conference on Computer and Communications Security
(CCS ’12). ACM, New York, NY, USA, 229–240. https://doi.org/10.1145/2382196.
2382223
[20]RiyadhMahmood,NarimanMirzaei,andSamMalek.2014. EvoDroid:Segmented
Evolutionary Testing of Android Apps. In Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software Engineering (FSE ’14). ACM,
New York, NY, USA, 599–609. https://doi.org/10.1145/2635868.2635896
[21]AnaMilanova,AtanasRountev,andBarbaraG.Ryder.2002.ParameterizedObject
SensitivityforPoints-toandSide-effectAnalysesforJava.In Proceedings of the
2002 ACM SIGSOFT International Symposium on Software Testing and Analysis
(ISSTA ’02). ACM, New York, NY, USA, 1–11. https://doi.org/10.1145/566172.
566174
[22]AnaMilanova,AtanasRountev,andBarbaraGRyder.2005. ParameterizedObject
Sensitivity for Points-to Analysis for Java. ACM Trans. Softw. Eng. Methodol. 14,
1 (Jan. 2005), 1–41. https://doi.org/10.1145/1044834.1044835
[23]NarimanMirzaei,JoshuaGarcia,HamidBagheri,AlirezaSadeghi,andSamMalek.
2016. ReducingCombinatoricsinGUITestingofAndroidApplications.In Pro-
ceedings of the 38th International Conference on Software Engineering (ICSE ’16).
ACM, New York, NY, USA, 559–570. https://doi.org/10.1145/2884781.2884853
[24]Damien Octeau, Somesh Jha, Matthew Dering, Patrick McDaniel, Alexandre
Bartel,LiLi,JacquesKlein,andYvesLeTraon.2016. CombiningStaticAnaly-
siswithProbabilisticModelstoEnableMarket-scaleAndroidInter-component
Analysis.In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages (POPL ’16).ACM,NewYork,NY,USA,
469–484. https://doi.org/10.1145/2837614.2837661
[25]Damien Octeau, Daniel Luchaup, Matthew Dering, Somesh Jha, and Patrick
McDaniel. 2015. Composite Constant Propagation: Application to Android Inter-
component Communication Analysis. In Proceedings of the 37th International
Conference on Software Engineering - Volume 1 (ICSE ’15). IEEE Press, Piscataway,
NJ, USA, 77–88. http://dl.acm.org/citation.cfm?id=2818754.2818767
[26]DamienOcteau,PatrickMcDaniel,SomeshJha,AlexandreBartel,EricBodden,
Jacques Klein, and Yves Le Traon. 2013. Effective inter-component communica-
tionmappinginandroidwithepicc:Anessentialsteptowardsholisticsecurity
analysis. In 22nd USENIX Security Symposium (USENIX Security ’13). 543–558.
[27]Yuru Shao, Xiapu Luo, Chenxiong Qian, Pengfei Zhu, and Lei Zhang. 2014.
Towards a Scalable Resource-driven Approach for Detecting Repackaged An-
droid Applications. In Proceedings of the 30th Annual Computer Security Ap-
plications Conference (ACSAC ’14). ACM, New York, NY, USA, 56–65. https:
//doi.org/10.1145/2664243.2664275
[28]Yannis Smaragdakis, Martin Bravenboer, and Ondrej Lhoták. 2011. Pick Your
ContextsWell:UnderstandingObject-sensitivity.In Proceedings of the 38th Annual
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages
(POPL ’11).ACM,NewYork,NY,USA,17–30. https://doi.org/10.1145/1926385.
1926390
[29]Tian Tan, Yue Li, and Jingling Xue. 2016. Making k-object-sensitive pointer
analysismoreprecisewithstillk-limiting.In International Static Analysis Sym-
posium (SAS ’16).Springer,489–510. https://link.springer.com/chapter/10.1007/
978-3-662-53413-7_24
[30]TianTan,YueLi,andJinglingXue.2017. EfficientandPrecisePoints-toAnalysis:
Modeling the Heap by Merging Equivalent Automata. In Proceedings of the 38th
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI ’17). ACM, New York, NY, USA, 278–291. https://doi.org/10.1145/3062341.
3062360
[31]Fengguo Wei, Sankardas Roy, Xinming Ou, and Robby. 2014. Amandroid: A
PreciseandGeneralInter-componentDataFlowAnalysisFrameworkforSecurity
Vetting of Android Apps. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security (CCS ’14). ACM, New York, NY, USA,
1329–1341. https://doi.org/10.1145/2660267.2660357
[32]ShengqianYang,DacongYan,HaoweiWu,YanWang,andAtanasRountev.2015.
Static Control-Flow Analysis of User-Driven Callbacks in Android Applications.
In2015 IEEE/ACM 37th IEEE International Conference on Software Engineering
(ICSE ’15), Vol. 1. 89–99. https://doi.org/10.1109/ICSE.2015.31
[33]Shengqian Yang, Hailong Zhang, Haowei Wu, Yan Wang, Dacong Yan, and
Atanas Rountev. 2015. Static Window Transition Graphs for Android (T). In
Proceedings of the 2015 30th IEEE/ACM International Conference on Automated
Software Engineering (ASE ’15) . IEEEComputer Society, Washington,DC, USA,
658–668. https://doi.org/10.1109/ASE.2015.76
[34]YifeiZhang,TianTan,YueLi,andJinglingXue.2017. Ripple:ReflectionAnalysis
for Android Apps in Incomplete Information Environments. In Proceedings of
the Seventh ACM on Conference on Data and Application Security and Privacy
(CODASPY ’17). ACM, New York, NY, USA, 281–288. https://doi.org/10.1145/
3029806.3029814
608
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:54:18 UTC from IEEE Xplore.  Restrictions apply. 