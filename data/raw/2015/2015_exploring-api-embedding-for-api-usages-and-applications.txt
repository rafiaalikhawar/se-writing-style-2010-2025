Exploring API Embedding for API Usages
and Applications
Trong Duc Nguyen, Anh Tuan Nguyen, Hung Dang Phan
Electrical and Computer Engineering Department
Iowa State University
Email: {trong,anhnt,hungphd}@iastate.eduTien N. Nguyen
Computer Science Department
University of Texas at Dallas
Email: tien.n.nguyen@utdallas.edu
Abstract —Word2Vec is a class of neural network models that
as being trained from a large corpus of texts, they can produce for
each unique word a corresponding vector in a continuous space in
which linguistic contexts of words can be observed. In this work,
we study the characteristics of Word2Vec vectors, called API2VEC
orAPI embeddings , for the API elements within the API sequen-
ces in source code. Our empirical study shows that the close
proximity of the API2VEC vectors for API elements reﬂects the
similar usage contexts containing the surrounding APIs of those
API elements. Moreover, API2VEC can capture several similar
semantic relations between API elements in API usages via vector
offsets. We demonstrate the usefulness of API2VEC vectors for
API elements in three applications. First, we build a tool that mi-
nes the pairs of API elements that share the same usage relations
among them. The other applications are in the code migration
domain. We develop API2API, a tool to automatically learn the
API mappings between Java and C #using a characteristic of the
API2VEC vectors for API elements in the two languages: semantic
relations among API elements in their usages are observed in the
two vector spaces for the two languages as similar geometric
arrangements among their API2VEC vectors. Our empirical
evaluation shows that API2API relatively improves 22.6% and
40.1% top-1 and top-5 accuracy over a state-of-the-art mining
approach for API mappings. Finally, as another application in
code migration, we are able to migrate equivalent API usages
from Java to C #with up to 90.6% recall and 87.2% precision.
Keywords -Word2Vec; API embedding; API usages; migration
I. I NTRODUCTION
Software library plays an important role in modern software
development. To access the functionality of a library, develop-
ers use Application Programming Interfaces (API elements,
APIs for short), which are the classes ,methods , and ﬁelds pro-
vided by the library’s designers. A certain combination of API
elements is used to achieve a programming task and is called
anAPI usage . An example of a Java Development Kit (JDK)
usage for reading from a ﬁle could involve the sequence of the
APIs of File and Scanner , and the control unit while to iterate
over the ﬁle’s contents. The combination of API elements al-
lows intricate and complex API usages, yet, in many cases, the
API usages that developers write are repetitive . As an evidence
of that, researchers have been able to mine API usage patterns,
which are frequently occurring API usages, from large code
corpora [1], [2]. In other words, the sequences of API elements
in API usages are natural ,i.e., have high regularity .
Existing works have explored the regularity of API usages
to build API recommendation engines by using the statisti-cal modeling of natural utterances and applying it to API
sequences to suggest the next API call in a program editor.
Typical natural language processing (NLP) models for API call
suggestion include n-gram model [3], [4], deep neural network
model [5], and graph-based generative model [6].
In this work, we focus on exploring the naturalness of API
usage sequences from a different perspective by investigating
the embeddings of API elements in a continuous vector space
created by Word2V ec [7]. Let us call them API embeddings or
API 2VEC . Word2V ec has been shown to be able to capture the
similarities of the relations between pairs of words in senten-
ces: pairs of words sharing a particular relation have Word2V ec
vectors with constant/similar vector offsets . Via visualization
with Principal Component Analysis (PCA) [8] and vector
operations, researchers have observed the syntactic relations,
e.g., (base, comparative), (base, superlative), (singular, plural),
(base, past tense), etc. [9]. Semantic relations among words
can also be captured via vector operations [7]. For example,
for (state, capital): V(France )-V(Paris )≈V(Italy )-V(Rome ),
whereVdenotes Word2V ec and the minus sign is for vector
subtraction. Other types of semantic relations are also observ-
ed: (city, state), (famous name, profession), (company, famous
product), (team, sport), etc. [10]. If these observations hold for
the relations among API elements , we could leverage API 2VEC
to support the tasks related to API usages, e.g., API code
completion, usage migration, API pattern detection, etc.
Toward that goal, we conducted experiments on a large nu-
mber of Java and C #projects to answer the following research
questions: 1) In a vector space produced by API 2VEC on API
elements, do nearby vectors represent the APIs that have
similar usage contexts (deﬁned as similar surrounding API
elements of those APIs)? 2) By vector offsets, can API 2VEC re-
veal similar usage relations between API elements (deﬁned as
co-occurring relations between API elements in API usages )?
Our empirical results conﬁrmed that close proximity of the
vectors for two API elements reﬂects their similar usage con-
texts. We also showed that API 2VEC can capture similar usage
relations between the APIs in usages by vector offsets.
We demonstrated the usefulness of API 2VEC vectors for
APIs in three applications by using those characteristics. First,
we built a tool to mine pairs of API elements sharing the same
usage relations among them. For example, we can mine that
the relation “checking the existence of the current element be-
2017 IEEE/ACM 39th International Conference on Software Engineering
 
DOI 10.1109/ICSE.2017.47436
2017 IEEE/ACM 39th International Conference on Software Engineering
1558-1225/17 $31.00 © 2017 IEEE
DOI 10.1109/ICSE.2017.47438
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. fore retrieval” is shared between ListIterator.hasNext and ListIte-
rator.next , and between StringT okenizer.hasMoreT okens and String-
T okenizer.nextT oken , despite that they have different names for
similar functionality. Thus, given the pair <ListIterator.hasNext ,
ListIterator.next >, and StringT okenizer.hasMoreT okens , our tool can
suggest StringT okenizer.nextT oken using vector offsets.
The other applications are in the domain of code migration.
We build API 2API to automatically learn API mappings bet-
ween Java and C #(i.e., the API elements in two languages
with the same/similar functionality). It is based on a characte-
ristic of API embeddings in two languages as follows. In the
two languages, despite that the respective APIs might have
different names, since if they are used to achieve the same/si-
milar functionality, each of the API elements would have the
same/similar role in its respective API usage, and the relations
between two API elements would have the same/similar mea-
ning as the relation between the corresponding API elements
in the other language. For example, the relation “checking
the existence of the current element before retrieval” exists
between ListIterator.hasNext and ListIterator.next in Java as well
as between the corresponding APIs IEnumerator.MoveNext and
IEnumerator.Current in C#. A usage could have multiple API
elements ( e.g., the above API usage could include List.iterator()
since we ﬁrst need to obtain an iterator of a list). However,
the relation between two Java API elements in a usage will
exist and be interpreted as the same meaning as the relation
between the two respective APIs in C #.
Thanks to the above vector offset characteristic in both Java
and C #vector spaces, in our experiment, we were able to
observe that the API elements in the corresponding API usages
in Java and C #have their vectors in similar geometric arrange-
ments in the two vector spaces for Java and C #. For example,
Fig. 4 shows similar arrangements of the vectors for the APIs
in the usages with FileReader and FileWriter in Java and Stream-
Reader and StreamWriter in C#. This is reasonable since each
element and its corresponding API element play the same/-
similar role in the corresponding usage. Then, due to similar
geometric arrangements, we can learn the transformation ( e.g.,
rotating and/or scaling) between the vector spaces if we know
some API mapping pairs in a training data. To ﬁnd the mapped
C#API for a given Java API jwith its vector Vj, we use the
learned function to compute its transformed vector VCin the
C#space. The C #API cwith the vector most similar to the
transformed vector VCis considered as the mapped API of j.
To evaluate API 2API, we conducted an empirical study. Our
result shows that for a given Java API, in 53.1% of the cases,
the correct respective C #API is listed on the top of API 2API’s
resulting list. It has 22.6% and 40.1% relative improvement in
top-1 and top-5 accuracy, respectively, over the state-of-the-
art approach StaMiner [11]. To show the third application,
we used our resulting API mappings in a phrase-based ma-
chine translation tool, Phrasal [12], to translate a JDK usage
sequence into the equivalent .NET usage with multiple API
elements . The result showed that with the mappings, our tool
achieves high precision (up to 87.2%) and recall (up to 90.6%)
in migrating API usages. Our key contributions includeAPI vector
API API API API
API API API
API API API API APIAPI sequencesLarge code
corpus
</>CBOW
Word2Vec 
ModelingSequence 
Extraction
.
Wi-n Wi - 1 ... Wi + 1 Wi + n ...×
. # #Hidden
InputOutput
N-dimV-dim
×          ×        ×        ×
#
Fig. 1: V ector Representations for API Elements with CBOW
•An extensive study on the characteristics of API 2VEC em-
beddings/vectors for API elements in API sequences;
•An application of API 2VEC for API elements in mining the
pairs of API elements that share same usage relations;
•API 2API: an approach to mine API mappings via vector
projection without a parallel corpus of respective code;
•An empirical study to show API 2API’s accuracy in mining
API mappings, and migrating API usages from Java to C #.
II. B ACKGROUND ON WORD 2V EC
Word2V ec [7] is a class of neural network models in which
after being trained in a large corpus of texts, they can produce
for each unique word a corresponding vector in a continuous
space in which linguistic contexts of words can be observed. It
represents words by encoding the contexts of their surrounding
words into vectors. Mikolov et al. [7] introduce two Word2V ec
models, named Continuous Bag-of-Words (CBOW) and Skip-
gram models. We show CBOW model in Fig. 1 as we used it.
Let us summarize the CBOW model. Basically, CBOW has
a neural network architecture with three layers: input, hidden,
and output. The input layer has a window of nwords preceding
the current word wiand a window of nwords succeeding wi.
The total (context) window ’s size is 2 n. The output layer is for
wi. Each word is encoded into the model as its index vector.
An index vector for a word is an 1×Vvector with Vbeing the
vocabulary’s size, and only the index of that word is 1 and the
other positions of the index vector are zeros. The Word2V ec
vector for each word wiis the output of the hidden layer with
Ndimensions , which is the number of the dimensions of the
vector space. To compute Word2V ec vector for wi, CBOW
ﬁrst takes the average of the vectors of the 2 ninput context
words, and computes the product of the average vector and the
input-to-hidden weight matrix WV×N(shared for all words):
V(wi)=1
2n(w(i−n)+...w (i−1)+w(i+1)+...+w(i+n)).WV×N
V(wi)is the Word2V ec vector for wi.2nis the win-
dow’s size. WV×Nis the input-to-hidden weight matrix.
w(i−n),...,w (i+n)are the vectors of the words in the context
window. Training criterion is to derive the input-to-hidden
weight matrix WV×Nand the hidden-to-output weight matrix
437
439
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. W/prime
N×Vsuch that Word2V ec correctly classiﬁes the current
wordw=wifor all words. Details can be found in [7].
III. API 2VEC : API E MBEDDINGS FOR API U SAGES
A. API 2VEC for API Usages
In API usages, one needs to use API elements in certain or-
ders. Thus, APIs are often repeatedly used in similar contexts,
i.e., similar surrounding API elements in which each of them
has a speciﬁc role. We aim to verify if Word2V ec vectors can
capture the regularity of APIs via maximizing the likelihood
of observing an API element given its surrounding elements
in the API usages. Let us call them API2VEC vectors.
Speciﬁcally, in Word2V ec, the regularity of words is expres-
sed in two key characteristics. First, it has been shown that in
the Word2V ec vector space for texts, the nearby vectors are
the projected locations of the words that have been used in the
similar contexts consisting of similar surrounding words [13].
Thus, our ﬁrst research question is to verify whether the close
proximity of the vectors in the API2VEC vector space re-
present the API elements that have similar usage contexts .
Two APIs have similar usage contexts if they have similar sets
of surrounding API elements in their API usages . Examples of
APIs with similar contexts are the APIs in the same class or the
classes with similar purposes ( e.g., StringBuffer and StringBuilder ).
They are often surrounded by similar sets of APIs in usages.
Second, in NLP , the regularity of words is observed as si-
milar vector offsets between the pairs of words sharing a par-
ticular relation. For API usages, APIs are used in certain ways
with semantic dependencies/relations among them. For exam-
ple, the relation “check if the current element exists before
retrieval” occurs between ListIterator.hasNext and ListIterator.next ,
and between XMLStreamReader.isEndElement and XMLStreamRea-
der.next . Such relations among APIs, called usage relations , are
parts of API usages and occur regularly in source code. Thus,
our second research question is to verify if similar usage
relations between APIs can be observed via vector offsets .
B. Building API Sequences for API Usages
For training, we process a large code corpus to build the
sequences of annotations to represent API elements in usages.
We traverse an AST to build an annotation sequence according
to the syntactic units related to APIs, including literals ,identi-
ﬁers ,API elements (method/constructor calls ,ﬁeld accesses ),
variable declarations ,array accesses , and control statements
(while ,for,if, etc.). For a non-control unit, we collect data types,
method/ﬁeld names, return types, and roles (literals, variables,
receivers/arguments). Such annotation is expected to increase
regularity and characterize API elements. The names of types/-
classes/methods/ﬁelds are kept. Those of variables/identiﬁers
are discarded since different usages could use different names.
Table I shows the key rules to build annotation sequences in
Java. Similar rules are used for C #(not shown). θis used to
denote the function to build an annotation sequence ( API seq-
uence for short). It is initially applied on a method and recur-
sively called upon the syntactic units in the code until we
have all terminal annotations. A terminal annotation is eitherTABLE I
KEYRULESθ(E)TOBUILD API S EQUENCES IN JAVA
Syntax T = typeof, RetType = return type
Expression
Literal: θ(E)= T(Lit)
E::=Lit e.g.,θ("ABC") = String
Identiﬁer θ(E)= T(ID)#var
E::=ID e.g.,θ(writer)= FileWriter #var
MethodCall θ(E)=θ(e1) ...θ(en) RetType(m)#ret θ(e)#rec
E::= T(e).m T(e1)#arg ... T( en)#arg
e.m(e1,...,en) Discardθ(ei)i feiis ID or Literal
Discardθ(e)#rec if e is a class name
e.g.,θ(dict.get(vocab) )=
Integer #ret HashMap #rec HashMap.get String #arg
Constructor θ(E)=θ(e1) ...θ(en)[θ(e)] T(C).new
E::=[e.]new T(e1)#arg...T( en)#arg
C(e1,...,en) e.g.,θ(new FileWriter (“A ”))
=FileWriter.new String #arg
Field Access θ(E)= T(f)#retθ(e)#rec T(e).f
E::= e.f Discardθ(e)#rec if e is a class name
e.g.,θ(reader.lock)= Object #ret Reader #rec Reader .lock
V ariable Decl θ(E)= C#varθ(e1) [... C#var θ(en)]
E ::= Cid1[=e1],
...[idn[=en]] e.g.,θ(FileWriter writer )=FileWriter #var
ArrayAccess θ(E)=θ(e) T(a[]) T(a)#access T(e)#arg
E::= a [e] Discardθ(e)ifeis ID or Literal
e.g.,θ(list[1] )=String String []#access Integer #arg
Lambda expr E
::=(e1,...,en)= >eθ(E)=θ(e1)...θ(en)T (e1)#arg ... T( en)#argθ(e)
Statement
ForStmt S::= θ(S)=‘for’θ(i1) ...θ(in)θ(e)θ(u1) ...θ(um)θ(S1)
for (i1,...,in;e;e.g.,θ(for (;it.hasNext ();)) =
u1, ...,um)S 1 for bool Iterator #var Iterator.hasNext
S::= while (e) S1 θ=‘while ’θ(e)θ(S1)
S::= if (e) S1 θ(S)=‘if’θ(e)θ(S1) ’ else ’[θ(S2)]
[else S2 ]
ExprStmt S::= e ; θ(S) =θ(e)
Block S::= s1,.,snθ(S)=θ(s1) ...θ(sn)
a method call ( e.g., Reader.read) , ﬁeld access, or a type with/wit-
hout a sufﬁx annotation (e.g., String ,FileWrite#var ,HashMap#rec ,
String#arg ). The ﬁnal sequence contains only terminal ones.
1) Literal : We keep only its type.
2) Identiﬁer : We concatenate its type with annotation #var .
3) Method call : We keep its full signature including the return
type and the types (not the concrete names) of its receiver and
arguments. For example, for dict.get(vocab) ,w eh a v e Integer#ret
HashMap#rec HashMap.get String#arg . Such type information
could help predict the current API call given the return type
and its arguments’ types, or predict the current argument given
the name of API call, its return type, and other arguments. We
keep the receiver’s type since we want to capture the following
relations: an object “invokes” an API call, and a call “returns”
an object with a speciﬁc type. If a method call is an argument
of another call, m(n()), the sequence for n()is created before
the one for m()becausen()is executed ﬁrst.
4) Constructor call or ﬁeld access : similar to method call. For
a constructor call, no return type and receiver’s type is needed.
5) V ariable declaration : We keep its type and annotation #var ,
e.g., FileWriter#var .We discard its name to increase its regularity.
6) Array access : We keep the types of the array, the elements,
and the index, e.g., list[1]→ String String[]#access Integer#arg .
7) Statements : The rules for while ,for,if, and other statements
are similar, however, those keywords are also kept.
438
440
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. 1HashMap dict = new HashMap ();
2 dict . put("A", 1);
3FileWriter writer = new FileWriter ("Vocabulary.txt");
4for (String vocab: dict . keySet ())
5 writer . append ( v o c a b+""+ dict. get(vocab)+"\r\n") ;
6 writer . close ();
Fig. 2: An API Usage in Java JDK
TABLE II
DA TASETS TO BUILD API 2VEC VECTORS
#projects #Classes #Meths #LOCs V oc size
Java Dataset 14,807 2.1M 7M 352M 123K
C#Dataset 7,724 900K 2.3M 292M 130K
For example, in Fig. 2, we produce the API sequence:
HashMap #var HashMap .new
String #ret HashMap #rec HashMap.put String #arg Integer #arg
FileWriter #var FileWriter.new String #arg
for String #var String[] #ret HashMap #rec HashMap.keySet
String #ret HashMap #rec HashMap.get String #arg FileWriter #rec
FileWriter.append String #arg
FileWriter #rec FileWriter.close
Such sequences for all methods in a dataset is used to train
CBOW. An API (annotation) sequence for a method is called
a sentence . Each element in a sentence is considered as the
current one. Assume that the current API is HashMap.keySet
(used for the output layer, Fig. 1). If the context window’s size
is 10, we use 5 elements preceding and 5 succeeding it for the
input. After training, the output of the hidden layer gives the
vector for the current API, which is called API embedding .
IV . C HARACTERISTICS OF API E MBEDDINGS
We conducted experiments to answer the following questions:
RQ1. In a vector space for the APIs in usages, do nearby
vectors represent the APIs that have similar usage contexts?
RQ2. Can vector offsets in API 2VEC capture similar usage
relations ( i.e.,co-occurring relations among APIs in usages)?
Data Collection (Table II) The ﬁrst dataset, collected from
Allamanis et al. [14], is for training Word2V ec model to build
the vectors for JDK APIs. For vectors for .NET APIs, we chose
7,724 C #projects with the ratings of +10 stars in GitHub.
A. RQ1. Nearby V ectors Represent APIs with Similar Contexts
We ﬁrst randomly selected 1,000 JDK API methods and
ﬁelds in our dataset. For each API, we computed the top-5 API
method calls and ﬁeld accesses that are closest to that API in
the vector space. We processed those 1,000 groups of 6 API
methods/ﬁelds (one main API of the group and top-5 closest
ones) to verify if each of those 5 elements shares similar usage
contexts with the main API ( i.e., used with similar surrounding
APIs). For such veriﬁcation, we wrote a program to take two
APIsaandband search through our Java dataset to compute
two setsAandBof API elements that have been frequently
occurred with aandb, respectively (80% threshold), in the
methods in the dataset. If AandBoverlaps more than 80%,
we consider aandbshare similar surrounding APIs in usages.TABLE III
EXAMPLES OF API S SHARING SIMILAR SURROUNDING API S
G1. File.new G4. List.iterator
System.getProperty
ProcessBuilder.directory
Path.toFile
FileDialog.getFile
JarFile.newSynchronousQueue.iterator
ArrayList.iterator
ArrayDeque.iterator
Collection.iterator
V ector.iterator
G2. System.currentTimeMillis G5. String.hashCode
Calendar.getTimeInMillis
ThreadMXBean.getThreadUserTime
Thread.sleep
File.setLastModiﬁed
Calendar.setTimeInMillisInteger.hashCode
Date.hashCode
Class.hashCode
Boolean.hashCode
Long.hashCode
G3. String.compareTo G6. Map.keySet
Integer.compareTo
Comparable.getClass
Boolean.compareTo
Long.compareTo
Comparable.toStringIdentityHashMap.entrySet
EnumMap.entrySet
AbstractMap.keySet
NavigableMap.keySet
IdentityHashMap.keySet
TABLE IV
t-TEST RESULTS FOR VECTOR DISTANCES OF API S IN THE SAME AND
DIFFFERENT CLASSES AND PACKAGES FOR JAVA A N D C#
t df p-value Conﬁdence interval
Java Class -934.33 223.330 <2.2x10−15(-∞; -0.5280486)
Java Package -109.52 67.360 <2.2x10−15(-∞; -0.0472560)
C# Class -962.47 351.961 <2.2x10−15(-∞; -0.6252377)
C# Package -443.71 282.878 <2.2x10−15(-∞; -0.1364794)
Among 5,000 pairs of APIs (1,000 groups and 5 compari-
sons each), we found that 4,632 pairs (92.64% of them) have
similar surrounding APIs in their usages. Thus, this gives a po-
sitive answer to our RQ1. For the other 7.36%, this is because
an API has multiple contexts and some contexts with infre-
quently used APIs were not captured with insufﬁcient data.
Table III displays a few groups of those nearby API vectors.
The 3 groups on the left share similar surrounding API ele-
ments despite that their names are quite different. The 3 groups
on the right have members sharing the names. For illustration,
we show only the groups with the members in different classes.
B. V ectors of the APIs in Same Classes/Packages
In this experiment, we aim to verify if an API method call
or ﬁeld access to be projected closer to the other APIs of the
same class than the APIs of different classes (*).
We computed the cosine distances among the vectors of
the API methods and public ﬁelds in the same class and the
distances among the vectors of the APIs from different classes.
For every API method/ﬁeld m, we computed the distances
fromm to all other API method/ﬁelds in the same class
withmand to all other methods/ﬁelds in different classes.
To verify (*), for all the distances in the entire set of APIs,
we conducted the independent-samples t-test with signiﬁcance
levelα=0.99. We chose the following alternative hypothesis:
“the distances among the vectors of the APIs within a class are
smaller than the distances among the vectors of APIs belong
to different classes ”. The null hypothesis is “those distances
are equal” . We also performed the same procedure for the
439
441
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. /g25/g19/g13/g26/g26/g15/g25/g27/g20/g26/g26/g28/g26
 /g29/g30/g31/g32/g30/g33/g15/g25/g27/g20/g26/g26
Fig. 3: Distances of JDK API V ectors within and cross Classes
API methods/ﬁelds with respect to the boundary of packages.
Table IV shows the results for both Java and C #vectors.
As seen, with the p-values, we can conﬁrm our alternative
hypothesis: the distances among the vectors for APIs in the
same class/package is signiﬁcantly smaller than the distances
for APIs in different classes/packages. Thus, we can verify (*).
Fig. 3 shows the boxplot for the distributions of distances
among the vectors of the methods/ﬁelds in the same classes
for the 7 most popular JDK classes in our dataset. We also
show the boxplot for the distributions of distances between the
vectors of the APIs in each class and those in other classes.
As seen, the two boxplots for each class are quite separated.
In brief, the APIs in the same class/package perform functi-
ons relevant to the class/package’s theme, and often share si-
milar surrounding APIs. They tend to have nearby vectors .
C. RQ2. Similar V ector Offsets Reﬂect Similar Relations
We ﬁrst mined the frequent pairs of APIs by collecting all
the pairs of the APIs in the same methods in our Java dataset.
We ranked the pairs by their occurrence frequencies. We then
manually checked the most frequent pairs and collected 120 of
them, which are placed into 14 groups of pairs representing 14
different relations. Similarly, we collected a set of 138 correct
pairs of C #APIs placed into 16 groups. We used those two
sets of pairs in JDK and .NET as our benchmarks.
We processed the pairs as follows. For each group of pairs
of APIs (representing a relation), we randomly picked a seed
pair, e.g., (List#var ,List.add ). For each of the other pairs in the
group, e.g., (Map#var ,Map.put ), we applied the vector offset
from the seed pair to the vector of the ﬁrst API of the current
pair to compute the resulting vector, e . g . ,X=V ( List.add )−
V(List#var )+V(Map#var ). We then searched for the vectors
that are closest to X(e.g., Map.put ) and considered them as the
candidates (ranked by their respective cosine distances). If the
second API of the current pair in the benchmark is in the top- k
of the candidate list, we count it as a hit. Accuracy is the ratio
between the number of hits over the total number of cases.
There are 94.2% of the correct APIs in those relations show-
ing up in the top-5 candidate lists. 74.1% are actually at the top
one. Table V shows examples of 5 groups of relations in our
oracle for JDK APIs and the ranks of the correct APIs in the
candidate lists. As seen, API 2VEC can capture similar relations
between APIs and rank highly the correct APIs, even when the
respective names are different. For example, in the relationTABLE V
EXAMPLE RELA TIONS VIA VECTOR OFFSETS IN JDK
R1. Check the current element before retrieval Rank
ListIterator.hasNext ListIterator.next 1
Enumeration.hasMoreElements Enumeration.nextElement 1
StringTokenizer.hasMoreTokens StringTokenizer.nextToken 3
XMLStreamReader.isEndElement XMLStreamReader.next 1
R2. Obtain property after creating system/stream
System#var System.getProperty 1
Properties#var Properties.getProperty 1
XMLStreamReader#var XML...Reader.getAttr...V alue 1
R3. Add an element to various types of collections
List#var List.add 1
Map#var Map.put 1
Hashtable#var Hashtable.put 1
Dictionary#var Dictionary.put 1
R4. Parse a string into different types of numbers
Float#var Float.parseFloat 1
Double#var Double.parseDouble 1
Integer#var Integer.parseInt 1
Long#var Long.parseLong 1
R5. Avoid adding duplicate element to a collection
Set.contains Set.add 1
Map.containsKey Map.put 3
LinkedList.contains LinkedList.add 1
Hashtable.containsKey Hashtable.put 3
“add an element to various types of collections” , as using
List, one uses List.add , however, Map.put is used for Map .W e
were also able to observe/interpret the same relations in C #:
•“Check size before removal” ,
e.g., Dictionary.Count –Dictionary.Remove ,
•“Add an element to a collection” ,
e.g., Hashtable.new –Hashtable.Add ,
•“Read a ﬁle with different types” ,
e.g., BinaryReader.ReadInt64 –System.Int64 ,
•“Check the current element before retrieval” ,
e.g., IEnumerator.MoveNext –IEnumerator.Current , etc.
We also build a tool to derive pairs of API elements with
the same/similar relations. The tool takes as input a pair of
API elements in the same class, e.g., List#var and List.add , and
another API in a different class, e.g., Hashtable#var . It then
uses the vector offsetting operation to derive the corresponding
API Hashtable.put , without understanding the meaning of the
relation. One could use this tool to derive that List.add could
be used to achieve the similar functionality as Hashtable.put .
This is useful for developers who are new to the APIs.
V. M INING API M APPINGS BETWEEN JAVA A N D C#
A. API Mappings
This section presents an application of API embeddings
in code migration. Migrating code from one language to
another requires not only the mappings between the language
constructs ( e.g., statements, expressions), but also the map-
pings between the APIs in the two languages that have the
same/similar functionality. For example, in JDK, one uses Sys-
tem.out.println , while in .NET, (s)he could use Console.Writeln .T o
440
442
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. FileReader.readFileReader.close
FileReader#var
FileReader.newFileWriter.close
FileWriter.write
FileWriter#var
FileWriter.new
FileWriter.appendStreamReader.ReadLineStreamReader.Close
StreamReader#var
StreamReader.newStreamWriter.Close
StreamWriter.Write
StreamWriter#var
StreamWriter.new
StreamWriter.WriteLineJava JDK C# .NET Y
X-1.0-0.8-0.6-0.4-0.20.00.20.40.60.81.0
-1.0     -0.8     -0.6    -0.4    -0.2      0.0     0.2      0.4     0.6      0.8      1.0Y
X-1.0-0.8-0.6-0.4-0.20.00.20.40.60.81.0
-1.0     -0.8     -0.6    -0.4    -0.2      0.0     0.2      0.4     0.6      0.8      1.0
Fig. 4: Distributed V ector Representations for some APIs in Java (left) the corresponding APIs in C #(right)
reduce manual effort, several approaches have been proposed
tomine API mappings from a parallel training corpus of the
libraries’ client code that already had two respective versions
in two languages [15], [16]. However, building such corpus
with parallel implementations in general requires much effort.
B. Mappings via Transformation between Two V ector Spaces
In this work, we introduce API 2API, an approach/tool to
automatically mine API mappings between Java and C #
without requiring a parallel corpus. API 2API is based on a
characteristic of the API 2VEC vectors for API elements in two
languages: semantic relations among APIs in their usages are
observed in the two vector spaces for the two languages as
similar geometric arrangements among their vectors .
For motivation, we conducted an experiment in which we
picked 2 groups of APIs in Java JDK, FileReader and FileWriter ,
and the corresponding APIs in C #.NET. The vectors for the
respective APIs in JDK and .NET in each group were projected
down to two dimensions using PCA [8] (Fig. 4). We visually
observe that the group of FileReader and that of the respective
one StreamReader have similar geometric arrangements in the
two vector spaces. This suggests further exploration. With
this projection to 2-D spaces, we were able to compute a
transformation matrix that converts those two groups of APIs
in Java to the respective ones in C #. That is, similar geometric
arrangements enable us to ﬁnd a transformation with rotating
and scaling between the vectors in the two vector spaces.
The rationale is that the usage relations, e.g., in the
usage “open a ﬁle, read, and close it” (among FileReader-
#var ,FileReader.new ,FileReader.read , and FileReader.close ) are
observed as the vector offsets in the Java API vector space.
In C#, those usage relations are also captured via the
vector offsets among the corresponding APIs in the C #
vector space ( StreamReader#var ,StreamReader.new ,StreamRe-
ader.ReadLine , and StreamReader.Close ). The distance (vector
offset) between the API vectors with such a relation in the
Java space might be different from the distance between the/g1/g2/g3/g4/g5/g6/g7/g2/g8/g3/g9/g10/g7/g4/g11
/g12/g7/g13/g14/g15/g16/g1/g2/g3/g2/g4/g5/g6/g7/g8/g9/g10/g11
/g1/g2
/g12/g13/g4/g5/g6/g7/g8/g9/g10/g11/g1/g3/g1/g3/g4/g1/g2/g1/g2/g3/g2/g4/g8/g9/g4/g12/g13
/g14/g10/g2/g15/g11/g16/g9/g10/g17/g2/g8/g18/g9/g15/g4
/g19/g2/g8/g10/g18/g20/g17/g3/g18/g3
/g19/g7/g2/g13/g20/g21/g16/g22/g11
/g12/g7/g13/g16/g15
/g23/g24
/g19/g7/g2/g13/g20/g21/g16/g22/g11
/g12/g7/g13/g16/g15/g1/g2/g3/g2/g4/g5/g6/g7/g8
/g9/g10/g4/g5/g6/g7/g8
Fig. 5: Training for Transformation Matrix
corresponding API vectors with the same relation in the C #
space. However, as in NLP , such a distance (vector offset)
for two API vectors in Java space can be interpreted as the
same relation as the distance (offset) between two vectors
for the corresponding APIs in C #space. For example, both
V(FileWriter.new )-V( FileWriter.append ) and V( StreamWriter.new )-
V(StreamWriter.WriteLine ) can be interpreted as the relation
“open and append to a ﬁle” . Thus, the respective vectors in
two vector spaces could form similar geometric arrangements.
C. Transformation Matrix to Compute Single API Mappings
From the above observation, we aim to learn the transforma-
tion between the two vector spaces for APIs from some prior-
known API pairs, and then use the learned transformation to
locate the C #vectors corresponding to other unknown Java
APIs. Fig. 5 shows how we train the transformation model.
First, we collect the single mappings between JDK in Java and
.NET in C #into a training set (in our empirical evaluation,
we used a set of API mappings that was provided as part of
the migration tool Java2CSharp [17]). For example, FileReader
in JDK is mapped to StreamReader in .NET. Then, we use the
trained Word2V ec models for JDK and .NET to collect the
vectors for all the pairs of APIs in the training set.
In training, the pairs of vectors of those respective APIs are
used to derive the transformation matrix from Java to C #as
follows. Let us have a training set of API pairs and their asso-
ciated vector representations {ji,ci},i=1..n wherejiis a
441
443
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. /g1/g2/g3/g2/g4/g5/g3/g6 /g4/g1/g3/g5 /g4/g1/g3/g6 /g4/g4/g3/g7 /g4/g8/g3/g1/g4/g2/g3/g5/g7/g4/g3/g4/g8/g5/g3/g2/g8/g4/g3/g9 /g8/g8/g3/g6/g9/g2/g3/g1
/g10/g11/g10/g1/g10/g7/g10/g9/g10/g5/g10/g10
/g12/g13/g14/g15/g5 /g12/g13/g14/g15/g11 /g12/g13/g14/g15/g2 /g12/g13/g14/g15/g1 /g12/g13/g14/g15/g4 /g12/g13/g14/g15/g5/g10/g16/g17/g17/g18/g19/g20/g17/g21/g15/g22/g23/g24
/g54/g87/g68/g48/g76/g81/g72/g85
 /g36/g51/g44/g21/g57/g40/g38
Fig. 6: Comparison in Top- kAPI Mapping Mining Accuracy
vector in the Java vector space with d1dimensions and ciis
the corresponding vector in the C #space with d2dimensions.
We need to ﬁnd a transformation matrix Tsuch that T×jiap-
proximates ci. Adapted from [18], we learn the matrix Twith
the dimensions d2×d1by minimizing the Least Square Errors:
min
Wn/summationdisplay
i=1||T×ji−ci||2
Training process is done with stochastic gradient descent [18].
For prediction, for a given API in Java j, we compute
c=T×j. The API in C #whose vector is closest to
cvia cosine similarity will be the top result. We produce
multiple candidates with their scores using the cosine simi-
larity measures. For all JDK APIs in its vocabulary, we use
the computed matrix to compute their corresponding single
mappings in .NET in C #. That is, we have {ji,ci},i=1..|V|
withVis the vocabulary of JDK APIs. Note that, our mining
approach works in the other direction as we can compute the
transformation matrix from C #to Java in the same manner.
D. Accuracy Comparison
This section presents our experiments to evaluate API 2API’s
accuracy in mining API mappings between Java and C #.
Beside the two datasets (Table II) to train the respective
Word2V ec models in Java and C #, we also used 860 API
mapping pairs between Java JDK and C #.NET, provided by
the migration tool Java2CSharp [17] as the oracle. We used
part of those mappings to compute the transformation matrix.
For a test JDK API j,API 2API produces a resulting list. If the
true mapping API in C #.NET for jis in the top- kresulting
list, we count it a hit. Top- kaccuracy is computed as the ratio
between the number of hits and the total of hits and misses.
1)Quantitative Comparison :We conducted an experi-
ment to compare API 2API with the state-of-the-art approach
StaMiner [11]. StaMiner could mine both single API map-
pings as well as the mappings for the usages with multiple
API elements. For comparison with API 2API, we conﬁgured
StaMiner to mine single API mappings. In StaMiner [11], the
authors showed that it performs better than the existing mining
approaches such as MAM [15], AURA [19], and HiMa [20],
thus, we do not compare with those existing tools.
We trained StaMiner in the same dataset used in its paper
(Table 2 of [11]) with 34,628 pairs of respective methods in
Java and C #in 9 projects that have been developed in Java
and (semi-)automatically ported to C #.F o r API 2API, we usedTABLE VI
NEWL Y FOUND API MAPPINGS ,NOT IN JAVA 2CS HARP BENCHMARK
Java API C#API
java.util.HashMap.size System.Collect...Generic.Dictionary.Count
java.util.List.size System.Collections.Generic.IList.Count
java.util.Map.Entry.getKey System.Coll...Generic.KeyV aluePair.Key
java.util.ArrayList.ensureCapacity System.Collections.Generic.List.Capacity
java.sql.ResultSet.getShort System.Data...SqlDataReader.GetInt16
java.sql.ResultSet.getInt System.Data.....SqlDataReader.GetInt32
java.sql.ResultSet.getLong System.Data...SqlDataReader.GetInt64
java.io.File.canWrite System.IO.FileInfo.IsReadOnly
java.io.InputStream.read System.IO.Stream.ReadByte
the training datasets in Table II to produce Word2V ec vectors
for the APIs. We conﬁgured API 2VEC with the number of
dimensions of vector spaces N=300, and the window size of
Word2V ec model 2* n=10. For both tools, we used 10-fold
cross validation on Java2CSharp’s API mapping dataset.
As seen in Fig. 6, API 2API achieves high accuracy. For a
given Java JDK API, it can correctly derive the corresponding
API in C #.NET in 53.1% of the time with just a single
suggestion . That is, the correct corresponding .NET API is on
the top of the resulting list in more than half of the suggestion
cases . Moreover, for a given JDK API, the correct correspon-
ding API in .NET is in the list of 5 suggested .NET APIs in
almost 4 out of 5 cases (77.9% ). That is, in 77.9% of the time,
users just need to check a list of 5 suggested APIs to ﬁnd the
correct C #API for a given JDK API . This result shows that
it is practical to use API 2API in helping code migration.
Importantly, as seen, API 2API outperforms StaMiner about
10% at top-1 accuracy, i.e., 22.6% relative improvement. At
top-5 accuracy, the relative improvement is 40.1%.
API 2API is able to detect a large number of pairs of APIs
with different names. Some examples are shown in Table VI.
2)Qualitative Comparison :Investigating further the re-
sult, we reported the (dis)advantages of two approaches. First,
StaMiner requires a parallel corpus of corresponding usages
in two languages. It is not always easy to collect a statistically
signiﬁcant number of parallel code. Second, both tools have
out-of-vocabulary issue, i.e., requiring to see the APIs in the
training dataset to produce their mappings. Third, StaMiner
has a stronger requirement that the mapped APIs must be in
respective pairs in the parallel corpus . Using transformation,
API 2API does not need a parallel corpus with respective API
usages. However, it requires a training dataset of single API
pairs. It would be better if the training API pairs are diversely
selected in multiple packages (discussed in Section V -E1).
Fourth, it needs a high volume of code to build high-quality
vectors. This issue is easily mitigated due to a large wealth
of open-source repositories. In this study, with our easily-
collected datasets (Table II), API 2API performs better than
StaMiner with 34,628 pairs of respective methods. Finally, this
result leads to a potential direction to combine two approaches.
3)Newly Found API Mappings :Interestingly, we found
that API 2API correctly detected a total of 52 new API map-
pings that were not manually written in the latest mapping ﬁle
442
444
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. /g1/g2/g3/g4/g5/g6/g3/g1/g2/g1/g3/g6/g2/g7/g3/g8 /g2/g9/g3/g9/g10/g2/g3/g7
/g2/g1/g3/g11/g10/g2/g3/g2/g7/g11/g3/g1/g7/g2/g3/g6 /g7/g7/g3/g9/g6/g1/g3/g5
/g4/g8/g4/g5/g4/g10/g4/g6/g4/g11/g4/g4
/g12/g13/g14/g15 /g11 /g12/g13/g14/g15 /g8 /g12/g13/g14/g15 /g1 /g12/g13/g14/g15 /g5 /g12/g13/g14/g15 /g2 /g12/g13/g14/g15 /g11/g4/g16/g17/g17/g18/g19/g20/g17/g21/g15/g22/g23/g24
/g25/g20/g17/g26/g20/g27/g28/g29/g30/g20/g31/g28/g32/g15/g31/g28/g33/g28/g17/g34/g35/g13/g36
 /g37/g35/g38/g28/g19 /g31/g35/g39/g35/g28/g32/g15/g31/g28/g33/g28/g17/g34/g35/g13/g36
Fig. 7: Top- kAccuracy with different Training Data Selections
/g31/g19/g36/g18/g2
/g55/g82/g83/g3/g23
/g31/g19/g36/g18/g21
/g55/g82/g83/g3/g24/g31/g19/g36/g18/g22
/g55/g82/g83/g3/g20/g19/g53/g88/g81/g81/g76/g81/g74/g3/g55/g76/g80/g72
/g1/g2/g1/g3/g1/g4/g1/g5/g1/g6/g1/g7/g1/g8/g1
/g3/g1/g4/g1/g5/g1/g6/g1/g7/g1/g8/g1/g9/g1/g10/g1
/g2/g1 /g2/g1/g1 /g3/g1/g1 /g4/g1/g1 /g5/g1/g1 /g6/g1/g1 /g7/g1/g1/g8/g1/g1/g9/g1/g1 /g10/g1/g1 /g2/g1/g1/g1
/g11/g12/g13/g13/g14/g13/g15/g16/g17/g14 /g18/g19/g16/g20/g21/g22/g12/g23/g24/g25/g26/g27/g27/g12/g23/g28/g27/g29/g16/g20/g30/g25
/g31/g14/g18/g19/g13/g24/g14/g22/g13
Fig. 8: Top- kAccuracy with different Numbers of Dimensions
in Java2CSharp (currently, we counted them as incorrect cases
since those mappings are not in the Java2CSharp benchmark.
Thus, API 2API’s actual accuracy is even higher). Some cases
with different syntactic types and names are listed in Table VI
(see our website [21] for more). Those newly found mappings
are correct and could be added to complement Java2CSharp’s
data ﬁle. StaMiner can detect only 25 new mappings.
E. Sensitivity Analysis: Impacts of Factors on Accuracy
1)Selecting different packages of API mapping pairs to
train the transformation matrix :As shown in Section IV -B,
the vectors for APIs in the same classes/packages are closer
than those for other APIs in different classes/packages. Thus,
we aimed to answer the question of whether this characteristic
affects the training quality of the transformation matrix and
consequently affects accuracy. We ﬁrst divided our dataset of
all 860 API mappings into 13 groups corresponding to 13 JDK
packages. We used one group of mappings for testing, and
the other 12 groups for training. We repeated the process with
every group as the testing group and accumulatively measured
the top-kaccuracy. We compared this accuracy with that in
which we conducted 10-fold cross validation with the map-
pings in the training set being randomly selected from every
package (each package must have at least one pair).
As seen in Fig. 7, randomly selecting training mappings
in more diverse packages gives better accuracy than the ﬁrst
setting. For top-1 accuracy, the difference is 53.1%-35.0%=
18.1%. In the ﬁrst setting, the lack of mappings in the package
used for testing really hurts accuracy. This result implies that
in addition to the large size of training data, we need to have a
diversity in API mappings used for training. Investigating furt-
her from the result in Section IV -B, we found that the vectors
for APIs in the same classes/packages or for APIs sharingsimilar surrounding API elements are clustered into groups of
nearby vectors. We found that the vectors of JDK APIs in the
same cluster have similar arrangements as the corresponding
vectors of .NET APIs in the respective cluster. Thus, if we
provide the mappings for some APIs in a cluster , they likely
help derive other mappings in the cluster since they provide
better information to learn the transformation matrix .
There are two implications from this result. First, if we
want to derive the API mappings in some package, we need
to have in the training data the pairs of APIs from that package.
Second, if one aims to manually build a training set of map-
pings, (s)he needs to diversify the pairs in JDK packages.
2)Varying Numbers of Dimensions of Vector Spaces :
The dimension Nof vector space (Section II) is a crucial
factor that could affect API 2API’s accuracy. In this experiment,
we conﬁgured the dimensions of the two Word2V ec models
for Java and C #APIs ranging from Njava =NC#=N=10, 100,
200,..., 1,000. We performed 10-fold cross validation on the
pairs of API mappings. We also measured running time.
Fig. 8 shows the result. As seen, the very low-dimensional
vector spaces give low accuracy, e.g., 25.1% top-1 accuracy for
N=10. As we increase N, accuracy increases gradually and
reaches its peak (across all top- kaccuracy values) around
N=300. This is reasonable since the low-dimensional vector
space does not fully capture the APIs’ characteristics with re-
gard to their surrounding APIs in usages. Multiple features are
compressed into same dimensions. When Nis large enough,
the characteristics of APIs are better captured, leading to
higher accuracy. However, as we increase Nmore (N>=400),
accuracy starts to decline gradually. In this case, a more com-
plex model with larger Nrequires larger training data.
As seen in Fig. 8, training time increases signiﬁcantly as
N>=300-400 due to the signiﬁcant increase in the numbers of
models’ parameters. To achieve both high accuracy and rea-
sonable training time, we use N=300 (6 hours of training) as
the default conﬁguration for subsequent experiments. Time to
derive a mapping for an API is a few milliseconds (not shown),
thus, API 2API is suitable to be interactively used in an IDE.
3)Varying Word2Vec Window’s Sizes :We varied the
size of the window 2* nof the Word2V ec model and measured
its impact on accuracy. When nis small (n=1–2), the context is
insufﬁcient to represent each API element in API usages. For
our dataset, with the window’s size of 10–12 (5–6 APIs be-
fore and 5–6 APIs after the current API), accuracy reaches its
peak (not shown) since the window can cover well the length
of API sequences in an API usage. When the window’s size is
larger (>12), running time increases much, while accuracy is
stable. Thus, we use window’s size of 10 as a default setting.
4)Varying Sizes of Training Datasets for Word2Vec :
We varied the sizes of both training datasets in Java and C #
(Table II). First, we randomly selected 2% of all the methods
in Java dataset and 2% of the methods in C #dataset to train the
Word2V ec models. We repeated the 10-fold cross validation
as in the previous study and measured top- kaccuracy. Next,
we increased the training data’s sizes for both Java and C #
by randomly adding more methods to reach 5%, 10%, 25%,
443
445
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. /g31/g19/g36/g18/g2/g3
/g55/g82/g83/g3/g23
/g31/g19/g36/g18/g21/g3
/g55/g82/g83/g3/g24/g31/g19/g36/g18/g22
/g55/g82/g83/g3/g20/g19/g45/g68/g89/g68/g3/g36/g51/g44/g3
/g38/g6/g3/g36/g51/g44
/g1/g2/g2/g3/g2/g2/g4/g2/g2/g5/g2/g2/g6/g2/g2/g7/g2/g2/g8/g2/g2/g9/g2/g2/g2/g9/g9/g2/g2
/g9/g2/g10/g2/g1/g2/g3/g2/g4/g2/g5/g2/g6/g2/g7/g2/g8/g2
/g10/g11 /g4/g11 /g9/g2/g11 /g10 /g4/g11 /g4/g2/g11 /g9/g2/g2/g11
/g12/g13/g14/g15/g16/g17/g18/g19/g20/g18/g14/g21/g22/g22/g16/g23/g18/g24/g25/g26/g27/g24/g28/g28/g13/g17/g21/g28/g29/g18/g30/g11/g31
/g32/g17/g21/g33/g34/g33/g34/g35/g18/g36/g33/g37/g16/g18/g30/g22/g16/g17/g28/g16/g34/g38/g18/g19/g20/g18/g20/g13/g39/g39/g18/g28/g19/g17/g22/g13/g27/g31
Fig. 9: Accuracy with V aried Training Datasets for Word2V ec
/g1/g2/g3/g2/g4/g2/g5/g2/g6/g2/g7/g2/g8/g2/g9/g2
/g8/g6 /g10/g7/g1 /g1/g5/g8 /g3/g4/g4 /g4/g3/g2 /g5/g10/g6 /g6/g2/g1 /g6/g8/g8 /g7/g7/g4/g11/g12/g12/g13/g14/g15/g12/g16/g17/g18/g19/g20
/g21/g13/g22/g23/g24/g14/g17/g25/g26/g17/g27/g14/g15/g28/g29/g28/g29/g30/g17/g11/g31/g32/g17/g33/g15/g28/g14/g34/g35/g25/g33/g17/g10 /g35/g25/g33/g17/g1 /g35/g25/g33/g17/g3 /g35/g25/g33/g17/g4 /g35/g25/g33/g17/g5 /g35/g25/g33/g17/g10/g2
Fig. 10: Accuracy with various Numbers of Training Mappings
50%, and full training corpora. As seen in Fig. 9, as more
training data added, API 2API encounters more APIs and usage
contexts , and the regularity of APIs increases. Moreover, as
seen, more mapped APIs were observed , we trained better the
transformation matrix, thus leading to higher accuracy.
5)Varying number of mapping pairs to train the
transformation matrix :In this experiment, we varied the size
of the dataset to train the transformation matrix. We divided
all 860 API mappings from Java2CSharp into 10 equal folds.
First, we chose the ﬁrst fold as the testing fold . We then used
the second fold for training and measured accuracy. Next, we
added the third fold to the current training data (consisting of
the second fold) and tested on the testing fold. We repeated
the process by adding more folds to the current training data
until the 10thfold was used. Then, we chose the second fold
as the testing fold and repeated the above process. The top-
kaccuracy for each size of training data was accumulatively
computed over all executions for that size. Note that, we do not
need 9 folds for training to run for one fold. In fact, API 2API
produced mappings for all the Java APIs not in the training set.
As seen in Fig. 10, as more training mappings are added,
top-kaccuracy increases across all ks. Top-1 accuracy increa-
ses from 22.4% to 53.1% when training data increases from 1
to 9 folds (86 to 774 mappings). Importantly, with only 10% of
data, it achieves 60% top-5 accuracy . As 30% of the mappings
(258) are used, it achieves high top-1 accuracy (40%).
VI. M IGRA TING EQUIV ALENT API U SAGE SEQUENCES
We conducted another experiment to show a useful applica-
tion of our approach. We used API 2API’s single API mappings
in a phrase-based machine translation tool, Phrasal [12], thatTABLE VII
ACCURACY (%) INGENERA TING EQUIV ALENT API USAGE SEQUENCES
ProjectWithin-Project Cross-Project
Recall Precision Recall Precision
Antlr 87.8 75.2 90.6 87.2
db4o 83.9 79.4 88.7 75.8
Fpml 89.6 86.1 86.3 83.7
Itext 75.9 77.2 76.5 81.3
JGit 77.2 66.4 81.1 67.1
JTS 76.3 76.6 76.3 73.7
Lucene 75.7 77.7 77.1 78.5
Neodatis 78.6 70.4 78.8 74.2
POI 76.9 78.3 77.1 78.6
takes a JDK API usage and produces a respective usage
sequence with multiple API elements in .NET . For example,
given the Java code in Fig. 2, our Phrasal-based tool, equipped
with API 2API’s API mappings, will produce a sequence of
APIs in C #:Dictionary#var ,Dictionary.new ,StreamWriter#var , etc.
Users will ﬁll out the concrete variables to produce the com-
plete code. (We did not aim to migrate complete code since it
requires the mappings of all constructs in Java and C #.)
Settings and metrics. We used the dataset Oof 34,628 pairs of
respective methods as in the study in Section V -D1. We parsed
the methods to build the API sequences, and used them and
API 2API’s single mappings to train Phrasal.
We have two settings. The ﬁrst one is within-project usage
migration, which supports the case that users partially migrated
a project and our tool helps in migrating the remaining
methods. For each project, we used 10-fold cross validation
on all of its methods. We compared the resulting sequences of
APIs in C #with the real sequences in the manually-migrated
C#code in the dataset O. The second setting is cross-project
migration, which supports the case that developers can use
our tool to migrate the usages for a new project while using
the migrated usages in the other projects for training. In this
setting, we used the API sequences in the methods of a project
for testing and those in the remaining projects for training. We
repeated the process for each of those projects, and compared
the result against the human-migrated oracle O.
To measure accuracy in migrating API usages, we computed
precision and recall of our translated sequences while also con-
sidering the orders of APIs. We computed the longest common
subsequence (LCS) of a resulting sequence and its reference
sequence in the oracle. Precision and recall values are com-
puted as: Precision =|LCS|
|Result|, Recall =|LCS|
|Reference |. They
are accumulatively computed for all resulting sequences. The
higherRecall , the higher coverage the migrated sequences.
Recall =1 means that the migrated sequences cover all the
APIs in the oracle in the right order. The higher Precision ,
the more correct the migrated sequences. Precision =1 means
that the migrated APIs are all correct and in the right order.
We also computed BLUE score for lexical matching [11].
Result. As seen in Table VII, the results in both settings are
comparable since JDK and .NET APIs are very popular. Our
Phrasal-based tool is able to migrate API sequences from Java
to C#with high recall and precision . Speciﬁcally, for a given
444
446
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. sequence of JDK API elements, the ﬁrst resulting .NET API
sequence from our tool covers from 7.6–8.9 out of 10 needed
.NET APIs, and from 6.6–8.6 out of 10 generated .NET API
elements are in the correct order in that API sequence . Thus,
users just need to remove 1.4–3.4 .NET APIs and search for
additional 1–2.4 APIs out of 10 elements. BLUE scores (n=4)
are from 65.2–76.5%. Accuracy in the cross-project setting
is slightly higher than that in the within-project one since the
model observed more diverse API usages in other projects. The
improvement is not much due to a small number of projects.
VII. T HREA TS TO VALIDITY AND LIMITA TIONS
Our datasets and the randomly selected sets of API pairs
might not be representative. For API mappings, we did not
train and test of API mappings on the same package due to the
small number of samples for each package in Java2CSharp
oracle. For fair comparison between models, we measured in-
vocabulary accuracy (counting cases with already-seen APIs).
Due to space limit, we did not report the result from Skip-
gram model. CBOW predicts target words from the words in
their contexts, while Skip-gram predicts context words from
the target words. We focused on CBOW since it ﬁts with our
need better in characterizing an API via its surrounding ele-
ments. We tried both and CBOW gave slightly better accuracy.
API 2API has shortcomings. First, it works best with one-to-
one mappings. It cannot handle the cases with n-to-1 or 1-to-
nmappings, and the case of mappings to multiple alternative
subclasses of a class. Second, it needs a diverse training set of
API mappings. Third, to ﬁnd a mapped API in C #, it needs to
search in a large number of candidates. Finally, it might not
work for the pairs of libraries with much different paradigms.
VIII. R ELA TED WORK
DeepAPI [22] uses Recurrent Neural Network Encoder-
Decoder to generate API sequences for a given text by using
word embeddings and deep learning. DeepAPI has a different
goal as it learns the association of API sequences and anno-
tated words to generate API sequences from texts . We use
Word2V ec to capture the relations between API elements and
generate C #API sequences from Java API sequences. While
DeepAPI uses a deep learning translation model between texts
and API sequences, we use transformation between two vector
spaces to derive the API mappings between two languages.
API 2API is also related to the work by Y e et al. [23]. The
authors used Skip-gram model on API and reference docu-
ments and tutorials to create embeddings for words and code
elements. Semantic similarities among such documents are
modeled via those embeddings. The ﬁrst key difference is
that they aimed to quantify the relations between words and
code elements, while we focus on the relations among API
elements in API usages. Thus, they used documentation, while
we work on API sequences from source code. Finally, their
application is to improve text-code retrieval, while we support
the applications involving API usages and code migration.
Researchers have applied statistical NLP methods including
word embeddings to software artifacts. PAM [24] is a parame-
ter-free, probabilistic algorithm to mine API patterns. It uses aprobabilistic formulation of frequent sequence mining on API
sequences. Allamanis et al. [25] suggest methods/classes’ na-
mes using embeddings. The elements with statistical cooccur-
rences are projected into a continuous space with the words
from the names. In comparison, we use Word2V ec and learn
the transformation between two spaces. Their model works in
the same space. Maddison and Tarlow use probabilistic CFGs
and neuro-probabilistic language models for code [26].
Researchers have proposed to use language models to
suggest next tokens or API calls [3], [4], [5], [27]. Allamanis et
al.[28] use bimodal modeling for short texts and source code
snippets. They use traditional probabilistic model, and we use
Word2V ec for learning API embeddings. NA TURALIZE [29]
suggests natural identiﬁer names and formatting conventions.
API 2API is inspired from a work by Mikolov et al. [18] where
similar geometric arrangements were observed in English and
Spanish words for numbers and animals. Anycode [30] uses
a probabilistic CFG for Java constructs to synthesize Java ex-
pressions. SWIM [31] synthesizes code by using IBM Model
to produce code elements and then uses n-gram for synthesis.
Peng et al. [32] propose a deep learning model to learn vec-
tor representations for tree-based source code. Mou et al. [33]
introduce convolutional neural networks over tree structures.
We could use those models in place of Word2V ec in API 2API.
To mine API mappings , MAM [15] uses API Transforma-
tion Graphs, and compares APIs via similar names and calling
structures. HiMa [20] and Aura [19] use call dependency and
text similarity to identify change rules. Rosetta [16] needs pairs
of functionally-equivalent applications.
Our work StaMiner [11] mines API mappings by maximi-
zing the likelihoods of observing the mappings between API
pairs from a parallel corpus of client code. The resulting API
mappings are useful for rule-based migration tools [17], [34],
[35], [36], [37], [38], [39]. Our prior work SLAMC [40] pro-
vides a code representation for our phrase-based SMT models
in mppSMT [41] and semSMT [42]. Phrase-based SMT was
enhanced with grammar structures [43]. SMT is used to create
pseudo-code [44]. Early work on API 2API was in a poster [45].
IX. C ONCLUSION
We have shown that Word2V ec for APIs can capture the
regularities of the relations of APIs in API usages. We demon-
strate its usefulness in 3 applications. We build a tool to mine
the pairs of API elements that share the same usage relations
among them. We also propose an approach to automatically
mine API mappings by learning the transformation between
the two vector spaces of APIs in the source and target
languages. Our experiment shows that for just one suggestion,
our approach is able to achieve high precision and recall. In
the ﬁnal application, we build a migration tool that migrate
API usages between Java and C #and show its high accuracy.
X. A CKNOWLEDGMENTS
This work was supported in part by the US National Science
Foundation (NSF) grants CCF-1723215, CCF-1723432, TWC-
1723198, CCF-1518897, and CNS-1513263.
445
447
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T. N.
Nguyen, “Graph-based mining of multiple object usage patterns,” in
Proceedings of the the 7th Joint Meeting of the European Software
Engineering Conference and the ACM SIGSOFT Symposium on The
Foundations of Software Engineering , ser. ESEC/FSE ’09. New
Y ork, NY , USA: ACM, 2009, pp. 383–392. [Online]. Available:
http://doi.acm.org/10.1145/1595696.1595767
[2] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei, “MAPO: Mining
and recommending API usage patterns,” in Proceedings of the
23rd European Conference on ECOOP 2009 — Object-Oriented
Programming , ser. Genoa. Berlin, Heidelberg: Springer-V erlag,
2009, pp. 318–343. [Online]. Available: http://dx.doi.org/10.1007/
978-3-642-03013-0_15
[3] A. Hindle, E. T. Barr, Z. Su, M. Gabel, and P . Devanbu, “On the
naturalness of software,” in Proceedings of the 34th International
Conference on Software Engineering , ser. ICSE ’12. Piscataway,
NJ, USA: IEEE Press, 2012, pp. 837–847. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2337223.2337322
[4] V . Raychev, M. V echev, and E. Y ahav, “Code completion with
statistical language models,” in Proceedings of the 35th ACM SIGPLAN
Conference on Programming Language Design and Implementation ,
ser. PLDI ’14. New Y ork, NY , USA: ACM, 2014, pp. 419–428.
[Online]. Available: http://doi.acm.org/10.1145/2594291.2594321
[5] M. White, C. V endome, M. Linares-Vásquez, and D. Poshyvanyk,
“Toward deep learning software repositories,” in Proceedings of the
12th Working Conference on Mining Software Repositories , ser. MSR
’15. Piscataway, NJ, USA: IEEE Press, 2015, pp. 334–345. [Online].
Available: http://dl.acm.org/citation.cfm?id=2820518.2820559
[6] A. T. Nguyen and T. N. Nguyen, “Graph-based statistical language
model for code,” in Proceedings of the 37th International Conference
on Software Engineering - V olume 1 , ser. ICSE ’15. Piscataway,
NJ, USA: IEEE Press, 2015, pp. 858–868. [Online]. Available:
http://dl.acm.org/citation.cfm?id=2818754.2818858
[7] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean, “Distri-
buted representations of words and phrases and their compositionality,”
inAdvances in Neural Information Processing Systems 26: 27th Annual
Conference on Neural Information Processing Systems 2013 (NIPS’13). ,
2013, pp. 3111–3119.
[8] I. Jolliffe, Principal Component Analysis . USA: Springer-V erlag, 1986.
[9] T. Mikolov, W. T. Yih, and G. Zweig, “Linguistic regularities in
continuous space word representations,” in Proceedings of the 2013
Conference of the North American Chapter of the Association for
Computational Linguistics: Human Language Technologies (NAACL-
HLT-2013) . Association for Computational Linguistics, May 2013.
[10] T. Mikolov, K. Chen, G. Corrado, and J. Dean, “Efﬁcient estimation
of word representations in vector space,” CoRR , vol. abs/1301.3781,
2013. [Online]. Available: http://arxiv.org/abs/1301.3781
[11] A. T. Nguyen, H. A. Nguyen, T. T. Nguyen, and T. N. Nguyen,
“Statistical Learning Approach for Mining API Usage Mappings for
Code Migration,” in Proceedings of the 29th ACM/IEEE International
Conference on Automated Software Engineering , ser. ASE ’14. New
Y ork, NY , USA: ACM, 2014, pp. 457–468. [Online]. Available:
http://doi.acm.org/10.1145/2642937.2643010
[12] D. Cer, M. Galley, D. Jurafsky, and C. D. Manning, “Phrasal: A toolkit
for statistical machine translation with facilities for extraction and
incorporation of arbitrary model features,” in Proceedings of the NAACL
HLT 2010 Demonstration Session , ser. HLT-DEMO ’10. Stroudsburg,
PA, USA: Association for Computational Linguistics, 2010, pp. 9–12.
[Online]. Available: http://dl.acm.org/citation.cfm?id=1855450.1855453
[13] L. Deng and D. Y u, “Deep learning: Methods and applications,” Found.
Trends Signal Process. , vol. 7, pp. 197–387, Jun. 2014. [Online].
Available: http://dx.doi.org/10.1561/2000000039
[14] M. Allamanis and C. Sutton, “Mining source code repositories at
massive scale using language modeling,” in Proceedings of the 10th
Working Conference on Mining Software Repositories , ser. MSR ’13.
Piscataway, NJ, USA: IEEE Press, 2013, pp. 207–216. [Online].
Available: http://dl.acm.org/citation.cfm?id=2487085.2487127
[15] H. Zhong, S. Thummalapenta, T. Xie, L. Zhang, and Q. Wang, “Mining
API mapping for language migration,” in Proceedings of the 32nd
ACM/IEEE International Conference on Software Engineering - V olume
1, ser. ICSE ’10. New Y ork, NY , USA: ACM, 2010, pp. 195–204.
[Online]. Available: http://doi.acm.org/10.1145/1806799.1806831[16] A. Gokhale, V . Ganapathy, and Y . Padmanaban, “Inferring likely
mappings between APIs,” in Proceedings of the International
Conference on Software Engineering , ser. ICSE ’13. IEEE, 2013, pp.
82–91. [Online]. Available: http://dl.acm.org/citation.cfm?id=2486788.
2486800
[17] “Java2CSharp,” http://sourceforge.net/projects/j2cstranslator/.
[18] T. Mikolov, Q. V . Le, and I. Sutskever, “Exploiting similarities among
languages for machine translation.” CoRR , vol. abs/1309.4168, 2013.
[Online]. Available: http://dblp.uni-trier.de/db/journals/corr/corr1309.
html#MikolovLS13
[19] W. Wu, Y .-G. Guéhéneuc, G. Antoniol, and M. Kim, “Aura: A hybrid
approach to identify framework evolution,” in Proceedings of the 32nd
ACM/IEEE International Conference on Software Engineering - V olume
1, ser. ICSE ’10. New Y ork, NY , USA: ACM, 2010, pp. 325–334.
[Online]. Available: http://doi.acm.org/10.1145/1806799.1806848
[20] S. Meng, X. Wang, L. Zhang, and H. Mei, “A history-based matching
approach to identiﬁcation of framework evolution,” in Proceedings of
the 34th International Conference on Software Engineering , ser. ICSE
’12. Piscataway, NJ, USA: IEEE Press, 2012, pp. 353–363. [Online].
Available: http://dl.acm.org/citation.cfm?id=2337223.2337265
[21] “Jv2cs project’s website,” http://home.eng.iastate.edu/ ∼trong/projects/
jv2cs/.
[22] X. Gu, H. Zhang, D. Zhang, and S. Kim, “Deep API learning,” in
Proceedings of the 2016 24th ACM SIGSOFT International Symposium
on Foundations of Software Engineering , ser. FSE 2016. New
Y ork, NY , USA: ACM, 2016, pp. 631–642. [Online]. Available:
http://doi.acm.org/10.1145/2950290.2950334
[23] X. Y e, H. Shen, X. Ma, R. Bunescu, and C. Liu, “From word embeddings
to document similarities for improved information retrieval in software
engineering,” in Proceedings of the 38th International Conference on
Software Engineering , ser. ICSE ’16. ACM, 2016, pp. 404–415.
[Online]. Available: http://doi.acm.org/10.1145/2884781.2884862
[24] J. M. Fowkes and C. A. Sutton, “Parameter-free probabilistic API
mining at GitHub scale,” CoRR , vol. abs/1512.05558, 2015. [Online].
Available: http://arxiv.org/abs/1512.05558
[25] M. Allamanis, E. T. Barr, C. Bird, and C. Sutton, “Suggesting accurate
method and class names,” in Proceedings of the 2015 10th Joint
Meeting on Foundations of Software Engineering , ser. ESEC/FSE 2015.
New Y ork, NY , USA: ACM, 2015, pp. 38–49. [Online]. Available:
http://doi.acm.org/10.1145/2786805.2786849
[26] C. J. Maddison and D. Tarlow, “Structured generative models of natural
source code,” in The 31st International Conference on Machine Learning
(ICML) , June 2014.
[27] Z. Tu, Z. Su, and P . Devanbu, “On the localness of software,” in
Proceedings of the 22nd ACM SIGSOFT International Symposium
on Foundations of Software Engineering , ser. FSE 2014. New
Y ork, NY , USA: ACM, 2014, pp. 269–280. [Online]. Available:
http://doi.acm.org/10.1145/2635868.2635875
[28] M. Allamanis, D. Tarlow, A. D. Gordon, and Y . Wei, “Bimodal
modelling of source code and natural language,” in Proceedings of the
32Nd International Conference on International Conference on Machine
Learning - V olume 37 , ser. ICML’15. JMLR.org, 2015, pp. 2123–2132.
[Online]. Available: http://dl.acm.org/citation.cfm?id=3045118.3045344
[29] M. Allamanis, E. T. Barr, C. Bird, and C. Sutton, “Learning natural
coding conventions,” in Proceedings of the 22Nd ACM SIGSOFT
International Symposium on Foundations of Software Engineering , ser.
FSE 2014. New Y ork, NY , USA: ACM, 2014, pp. 281–293. [Online].
Available: http://doi.acm.org/10.1145/2635868.2635883
[30] T. Gvero and V . Kuncak, “Synthesizing Java expressions from
free-form queries,” in Proceedings of the 2015 ACM SIGPLAN
International Conference on Object-Oriented Programming, Systems,
Languages, and Applications , ser. OOPSLA 2015. New Y ork,
NY , USA: ACM, 2015, pp. 416–432. [Online]. Available: http:
//doi.acm.org/10.1145/2814270.2814295
[31] M. Raghothaman, Y . Wei, and Y . Hamadi, “SWIM: Synthesizing What
I Mean: Code Search and Idiomatic Snippet Synthesis,” in Proceedings
of the 38th International Conference on Software Engineering , ser.
ICSE ’16. New Y ork, NY , USA: ACM, 2016, pp. 357–367. [Online].
Available: http://doi.acm.org/10.1145/2884781.2884808
[32] H. Peng, L. Mou, G. Li, Y . Liu, L. Zhang, and Z. Jin, “Building
program vector representations for deep learning,” Knowledge Science,
Engineering and Management, Lecture Notes in Computer Science , vol.
9403, pp. 547–553, 2015.
446
448
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. [33] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin, “Convolutional neural
networks over tree structures for programming language processing,” in
Proceedings of the Thirtieth AAAI Conference on Artiﬁcial Intelligence ,
ser. AAAI’16. AAAI Press, 2016, pp. 1287–1293. [Online]. Available:
http://dl.acm.org/citation.cfm?id=3015812.3016002
[34] “Sharpen,” https://github.com/mono/sharpen.
[35] “DMS,” http://www.semdesigns.com/Products/DMS/DMSToolkit.html.
[36] “Java to C# Converter,” http://www.tangiblesoftwaresolutions.com/Prod
uct_Details/ Java_to_CSharp_Converter.html.
[37] “XES,” http://www.euclideanspace.com/software/language/xes/userGuide/
convert/javaToCSharp/.
[38] “Octopus.Net Translator,” http://www.remotesoft.com/octopus/.
[39] “Microsoft Java Language Conversion Assistant,”
http://support.microsoft.com/kb/819018.
[40] T. T. Nguyen, A. T. Nguyen, H. A. Nguyen, and T. N. Nguyen, “A
statistical semantic language model for source code,” in Proceedings of
the 2013 9th Joint Meeting on Foundations of Software Engineering ,
ser. ESEC/FSE 2013. New Y ork, NY , USA: ACM, 2013, pp. 532–542.
[Online]. Available: http://doi.acm.org/10.1145/2491411.2491458
[41] A. T. Nguyen, T. T. Nguyen, and T. N. Nguyen, “Divide-and-conquer
approach for multi-phase statistical migration for source code (t),” in
Proceedings of the 2015 30th IEEE/ACM International Conference on
Automated Software Engineering (ASE) , ser. ASE ’15. Washington,
DC, USA: IEEE Computer Society, 2015, pp. 585–596. [Online].Available: http://dx.doi.org/10.1109/ASE.2015.74
[42] ——, “Migrating code with statistical machine translation,” in
Companion Proceedings of the 36th International Conference on
Software Engineering , ser. ICSE Companion 2014. New Y ork,
NY , USA: ACM, 2014, pp. 544–547. [Online]. Available: http:
//doi.acm.org/10.1145/2591062.2591072
[43] S. Karaivanov, V . Raychev, and M. V echev, “Phrase-based statistical
translation of programming languages,” in Proceedings of the 2014
ACM International Symposium on New Ideas, New Paradigms, and
Reﬂections on Programming & Software , ser. Onward! 2014. New
Y ork, NY , USA: ACM, 2014, pp. 173–184. [Online]. Available:
http://doi.acm.org/10.1145/2661136.2661148
[44] Y . Oda, H. Fudaba, G. Neubig, H. Hata, S. Sakti, T. Toda,
and S. Nakamura, “Learning to generate pseudo-code from source
code using statistical machine translation (t),” in Proceedings of
the 2015 30th IEEE/ACM International Conference on Automated
Software Engineering (ASE) , ser. ASE ’15. Washington, DC, USA:
IEEE Computer Society, 2015, pp. 574–584. [Online]. Available:
http://dx.doi.org/10.1109/ASE.2015.36
[45] T. D. Nguyen, A. T. Nguyen, and T. N. Nguyen, “Mapping API Elements
for Code Migration with V ector Representations,” in Proceedings of the
38th International Conference on Software Engineering Companion ,
ser. ICSE ’16. New Y ork, NY , USA: ACM, 2016, pp. 756–758.
[Online]. Available: http://doi.acm.org/10.1145/2889160.2892661
447
449
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 16:32:49 UTC from IEEE Xplore.  Restrictions apply. 