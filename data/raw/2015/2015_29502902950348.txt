Detecting Sensitive Data Disclosure via Bi-directional Te xt
Correlation Analysis
Jianjun Huang Xiangyu Zhang
Department of Computer Science
Purdue University, USA
{huang427, xyzhang}@cs.purdue.eduLin Tan
Electrical and Computer Engineering
University of Waterloo, Canada
lintan@uwaterloo.ca
ABSTRACT
Traditional sensitive data disclosure analysis faces two c hallenges:
to identify sensitive data that is not generated by speciﬁc A PI calls,
and to report the potential disclosures when the disclosed d ata is
recognized as sensitive only after the sink operations. We a ddress
these issues by developing B IDTEXT, a novel static technique to
detect sensitive data disclosures. B IDTEXT formulates the prob-
lem as a type system, in which variables are typed with the tex t
labels that they encounter (e.g., during key-value pair ope rations).
The type system features a novel bi-directional propagatio n tech-
nique that propagates the variable label sets through forwa rd and
backward data-ﬂow. A data disclosure is reported if a parame ter
at a sink point is typed with a sensitive text label. B IDTEXT is
evaluated on 10,000 Android apps. It reports 4,406 apps that have
sensitive data disclosures, with 4,263 apps having log base d disclo-
sures and 1,688 having disclosures due to other sinks such as HTTP
requests. Existing techniques can only report 64.0% of what BID-
TEXT reports. And manual inspection shows that the false positiv e
rate for B IDTEXT is 10%.
CCS Concepts
•Software and its engineering →Software testing and debug-
ging;•Security and privacy →Software security engineering;
Keywords
Sensitive Data Disclosure, Bi-directional Text Correlati on, Android
apps
1. INTRODUCTION
Sensitive data disclosure has been a long-standing challen ge for
data security. By accessing the disclosed sensitive inform ation, ad-
versaries can learn about the system and then conduct attack [28,
25]. A prominent example is the OpenSSL Heartbleed vulnera-
bility disclosed in 2014. The OpenSSL versions with such a ﬂa w
allow remote attackers to retrieve sensitive data, for exam ple, user
authentication credentials and secret keys [12, 38]. Attac kers canthen compromise the target systems with the disclosed sensi tive in-
formation.
The proliferation of mobile devices [13, 33] makes the situa -
tion even worse since mobile devices process a lot of sensiti ve user
data. Previous studies showed that it is common that mobile a pps
undesirably disclose sensitive user information [26, 39, 1 0]. Many
techniques have been proposed that work at the system level o r the
application level, static or dynamic [21, 9, 14, 8]. Haris et al. pro-
vide a comprehensive list of the approaches to detecting sen sitive
information disclosures in mobile computing [16]. All thes e ap-
proaches require deﬁnition of the sensitive data sources, u sually
certain APIs whose return value is sensitive. With the deﬁni tion, if
forward data ﬂow is observed between taint sources and sinks, dis-
closure defects are reported. Later, researchers realized that some
generic APIs may return sensitive values, depending on the c on-
text, although they may return insensitive values in many ca ses.
SUPOR [17] and UIPicker [27] aimed to identify which user in-
puts on the user interfaces can be sensitive. Then the sensit ive in-
puts are associated with the variables in the code such that s tatic
or dynamic forward data ﬂow analysis can be applied to detect the
potential sensitive user inputs disclosures. Sensitive us er inputs are
identiﬁed in the context of the user interfaces which contai n text or
graphical information to instruct what the users should ent er.
However, the above solutions still have limitations. Sensi tive
data may come from generic API methods not related to UI ( e.g.,
loading data from some ﬁle or receiving data from network). I n
these cases, most existing approaches would not work proper ly. We
cannot simply treat the generic APIs as the taint sources as t hat will
lead to a large number of false warnings. In addition, forwar d data
ﬂow analysis is insufﬁcient. In many cases, a piece of data ma y be
ﬁrst emitted through a sink and then later typed as sensitive . There
may not be any forward data ﬂow from the type revelation point to
the sink point.
In this paper, we develop B IDTEXT, a technique to detect data
disclosures by examining the text labels correlated with va riables.
The text labels, either from the code ( e.g., the textual keys in key-
value pairs) or the UI, provide rich information about the da ta con-
tained in the variables. B IDTEXT extracts these labels, and lever-
ages a novel type system to propagate these labels through bo th
backward and forward data ﬂow. Data disclosures are reporte d
when a parameter at a sink point is typed with a sensitive text ual
label. The bi-directional propagation scheme is unique and differ-
ent from the traditional uniﬁcation based type inference sy stems.
It features the capability of avoiding undesirable uniﬁcat ion of text
labels, enabling a low false positive rate. Backward propag ation
allows B IDTEXT to capture cases in which data sensitiveness is
revealed after the data is sent through some sink.
Our work makes the following contributions:
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
FSE’16 , November 13–18, 2016, Seattle, WA, USA
ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950348
Artifact evaluated by FSE✓
169
1classCampaignActivity_20 implements Handler.Callback{
2CampaignActivity act;
3CampaignActivity_20(CampaignActivity a){
4this.act= a;
5}
6public boolean handleMessage(Message msg){
7Bundle b = msg.getData();
8String dt = b.getString( "data");
9Log.d("CampaignActivity" ,"Got data back: " +
dt);//sink
10Runnable r = newCampaignActivity_20_1(dt);
11act.runOnUiThread(r);
12return false ;
13}
14}
15classCampaignActivity_20_1 implements Runnable{
16StringjsonString ;
17CampaignActivity_20_1(String data){
18jsonString = data;
19}
20public void run(){
21JSONArray jsonArray = newJSONArray( jsonString );
22intlen = jsonArray.length();
23for(inti=0; i<len; i++) {
24JSONObject json = jsonArray.getJSONObject(i);
25String url = json.getString( "avatar_url" );
26ImageView iv = ... // omitted
27displayImage(url, iv); // omitted
28String un = "<b>"+ json.getString( "username" ) +
"</b>"+ json.getString( "created_at" );
29TextView tv = ... // omitted
30tv.setText(Html.formHtml(un));
31String c = json.getString( "content" );
32TextView ctv = ... // omitted
33ctv.setText(Html.fromHtml(c));
34// ...
35}
36}
37}
Figure 1: Motivating example from app com.buycott.android .
•We propose B IDTEXT, a novel method to detect sensitive
data disclosures. B IDTEXTleverages constant text labels and
features a novel type system that performs bi-directional t ext
label propagation.
•We implement a prototype of B IDTEXT for Android apps,
and evaluate it on 10,000 apps. B IDTEXT reports 4,406 apps
that have sensitive data disclosures, with 4,263 apps havin g
log based disclosures and 1,688 having disclosures due to
other sinks such as HTTP requests. Existing techniques [7,
17] can only report 64.0% of what B IDTEXT reports. And
manual inspection shows that the false positive rate for B ID-
TEXT is 10%.
•BIDTEXTis available at https://bitbucket.org/hjjandy/toydroid .
bidtext.
2. MOTIV ATING EXAMPLE
We use a real-world Android app com.buycott.android to mo-
tivate our technique. It is an app that allows users to check t he
company/vendor of a product by scanning the product’s barco de.
It even allows users to view the family tree of the company/ve n-
dor. Users can then make decision on whether this is a company
that rips off its customers so that they do not want to have bus iness
with. Users can also start/join campaigns against speciﬁc c ompa-
nies [1].
Fig. 1 shows a piece of simpliﬁed code snippet from the app. Th e
app sends a request to the Web server and obtains a list of post mes-
sages. The HTTP response is converted to a string in the app an d
then sent to a handler via a Message object. The following opera-
tions are present in the code snippet. At line 7, a key-value m appingdt@8
sink @9 data @17
jsonString @18
jsonArray @21
json @24
json.getString("username") @28call@9 call@10
assignment@18
new instance@21
call@24
call@28username
Figure 2: Data ﬂow (solid arrows) and type propagation
(dashed arrows) for Fig. 1.
is retrieved from the Message object. Then the data string of the
message is obtained from the mapping at line 8. Right after th at,
the data string is written to the log ﬁle at line 9. Note that wr iting
to a log ﬁle is usually considered as a sink for data disclosur es [7,
17, 22] because log ﬁles can be accessed by malware1. After the
logging operation, the app instantiates a Runnable object with
the data string at line 10, which runs in the UI thread (line 11 ) to
allow interactions with UI elements.
The data string is transmitted to the Runnable instance via the
instantiation at line 10. Inside the constructor at line 17, the data
is stored in a ﬁeld variable jsonString at line 18. When the UI
thread is running, the run() method at line 20 is invoked. The
data string is converted to a JSONArray object at line 21 which
is then iterated. Every element in the array is a JSONObject
(line 24). The app then obtains the URL for the avatar image, t he
corresponding user Id, the time of creation and the content o f the
post message by looking for the values via corresponding key s in
the JSON object (lines 25, 28, and 31). All such information i s
shown on some UI elements ( e.g., line 33).
Now let’s consider the potential sensitive data disclosure in this
running example. Based on the above description, the data fa lling
into the sink at line 9 comes from the Web server. We later know
that the data contains some sensitive user account informat ion. In
other words, the app retrieves the sensitive user account in forma-
tion from the server and writes it to the local log ﬁle without any
encryption. This is a typical kind of undesirable informati on dis-
closure [24, 40] that emits sensitive information from serv er such
as user account, balance in bank account, and employee salar y to
local ﬁles.
Traditional sensitive data disclosure analysis inspects t he data
ﬂow between some sensitive source point, for example, an API call
whose return value can be easily recognized as sensitive ( e.g.,Tele -
phonyManager.getDeviceId() in Android), and a sink point
(e.g., a ﬁle write or a socket send). If forward data ﬂow can be dis-
covered from the source point to the sink point, a disclosure prob-
lem is reported. In this example, while we do have data ﬂow fro m
the Web server response to the logging operation but we canno t de-
termine whether the response contains sensitive data from the oper-
ations along the data ﬂow . If we treat all data from server sensitive,
a lot of false alarms will be produced; but if we simply ignore them,
we miss true disclosures as in this example.
Different from the traditional disclosure analysis, our te chnique
1The recent version of Android has substantially mitigated t his
problem by limiting access to log ﬁles. But there are still a l arge
number of devices running old versions of Android. Note that BID-
TEXT is general to support various conﬁgurations of sink points.
170relies on the observation that the sensitiveness of data use d in ap-
plications can be recognized through examining the textual infor-
mation involved in the operations. Such texts are constant s trings in
either the code or the user interfaces. We randomly sampled 2 ,000
Android apps and found that on average each app contains 76.7
constant strings in layout ﬁles ( i.e.,XML ﬁles used to statically
deﬁne UIs) and 151 constant strings in app code. These consta nt
strings often provide rich information about what is being h eld by
the corresponding variables. For example, in Fig. 1, method call
json.getString("username") at line 28 uses a constant
string “ username ”. We can infer that the JSON object contains
some sensitive user Id. Since the JSON object is part of the We b
server response, according to the work ﬂow, we can conclude t hat
the response contains sensitive information. Thus the logg ing op-
eration at line 9 should be reported as a sensitive data discl osure.
Note that even if we recognized that the JSON object at line 28
contains sensitive information, we could not detect the dis closure
problem using traditional analysis techniques that try to ﬁ nd for-
ward data ﬂow from source points to sink points. We show the da ta
ﬂow via solid arrows in Fig. 2, starting from retrieving the d ata
from the key-value mapping (line 8). If we treat line 28 as a so urce
point, we cannot get a forward data ﬂow path from the source po int
to the sink point. Thus the disclosure defect is still missed after we
augment traditional techniques with our new sensitive data recog-
nition method.
BIDTEXTsolves the problem by introducing bi-directional prop-
agation. Instead of propagating tags like tainted anduntainted in
traditional techniques, our approach uses the constant str ings as the
tags and propagates both backward and forward. As the dashed ar-
rows in Fig. 2 show, constant text “ username ” is propagated back-
ward from the method call at line 28 to the variable json cre-
ated at line 24, and so on. Consequently, variables jsonArray ,
jsonString ,data and ﬁnallydtare tagged with the text “ user-
name ”. Intuitively, it means all these variables contain sensit ive
user Id information. Next we forwardly propagate the tag fro m line
8 to the sink point at line 9. Therefore, the logging statemen t oper-
ates on variables that are associated with text “ username ”. By ap-
plying this approach to the whole code snippet, we obtain the set of
correlated text as {“ CampaignActivity ”, “Got data back: ”, “data”,
“avatar_url ”, “username ”, “created_at ”, “content ”}. The ﬁrst two
textual tags are associated to the variable directly at the s ink point.
Tag “ data” is propagated to the variable (at the logging statement)
in a forward manner. The remaining texts are propagated to th e
sink point via a bi-directional manner discussed above.
BIDTEXT also associates UI texts to variables. UI often con-
tains texts that also indicate the sensitiveness of data sho wn on the
UI (see [17, 27]). We examine the corresponding layout ﬁle to get
the texts, add them to the tag set of the related variables and prop-
agate them like the texts found in the code. In the example, we can
ﬁnd several code locations that interact with the UI ( e.g., line 33),
through which we identify the corresponding layout ﬁles to c ollect
UI texts. However, the content of the UI is dynamically creat ed and
none of the UI elements holds constant texts. Therefore, no G UI
texts are propagated to the sink point in this example.
Next we apply a natural language processing (NLP) technique to
the tag set of the sink point to ﬁnd out if the texts can tell the sensi-
tiveness of the variable dt. Among the collected texts, “ username ”
matches a predeﬁned sensitive keyword. Thus our technique r e-
ports a sensitive data disclosure problem for the logging op eration
at line 9.
3. DESIGN
We propose B IDTEXT, a static bi -directional text correlation anal-Program p ::= s*
Statement s ::= v := t /*constant string in code*/
| v := i /*UI-related Id*/
| v := c /*values of other types*/
| v := ⊖v1 /*unary assignment*/
| v := v 1⊕v2 /*binary assignment*/
| call(m,v a→vf) /*v a/vfactual/formal arg*/
| v := return(m,v r) /*m returns v rto v*/
| v := apicall(m,v a) /*API call to method m*/
| IF(v) {s t} ELSE {s f}
| LOOP {s} /*loop structure*/
| v := φ(vt, vf) /*value merging in SSA*/
Variable v
Method m
String t
ID i
Value c /*Non-str, non-Id Values*/
Figure 3: Language.
ysis approach, to detect sensitive data disclosures. B IDTEXT com-
bines both the bi-directional propagation and the new appro ach that
uses internal constant texts to identify sensitive variabl es as illus-
trated in Section 2.
3.1 Language Abstraction
To simplify our discussion, we introduce an abstract langua ge.
The language is presented in Fig. 3. We only model the languag e
features that are related to explaining the text correlatio n analysis
and the bi-directional propagation. Others are abstracted away or
simpliﬁed. As we discussed in Section 2, we leverage the cons tant
texts in the code as well as in the UI to tag variables and deter mine
whether sensitive data is disclosed at sink points. Therefo re, con-
stant strings in the code and constant Ids that are associate d with
UI are of special interest and explicitly modeled in the lang uage.
For simplicity, we do not allow constant strings/Ids to appe ar in
complex operations, e.g., binary operations and method calls. For
such scenarios, the constant is ﬁrst assigned to a variable, which is
further used in the complex operation. This is similar to how An-
droid apps handle constant values in DEX bytecode. For examp le,
the method call json.getString("username") at line 28
in Fig. 1 is converted to two statements: tmp = "username";
json.getString(tmp); .
An invocation to method m(vf)is modeled by two separate
statements: call(m,v a→vf)passing the actual argument va
to the formal argument vfandv=return(m,v r)returning the
value invrinm() tovin the caller. The separation allows us
clearly model the data ﬂow at the entry and the exit of a method
call.v :=apicall(m,v a)abstracts invocation to an API func-
tionm() whose implementation is usually excluded or not avail-
able during analysis, e.g., the runtime C library and the framework
methods for Android apps.
The language also supports conditional branches and loops. There
are different loop structures such as for loops andwhile loops.
We ignore these differences and use a LOOP statement to model
them. Loop conditions are not relevant to our analysis and he nce
not modeled. Any side effects (in the loop conditions) are ex plicitly
modeled as assignments in the loop body.
Our language is a kind of SSA language so that φfunction is
used to merge values from different branches (of a predicate ). As
we will show later in Section 3.2.2, φfunctions require delicate
consideration during bi-directional propagation.
3.2 Type System and Bi-directional Propaga-
tion
As discussed earlier, we use the constant texts in either the code
171Const-BindingΓ,v:=t|= Γ⇒[v:{t}]Γ
UI-Bindingresource _id(i)
Γ,v:=i|= Γ⇒[v:extract _text(i)]Γ
Unary-AssignmentΓ⊢v:TΓ⊢v1:T′
Γ,v:=⊖v1|= Γ⇒[v:T∪T′,v1:T′∪T]Γ
Binary-AssignmentΓ⊢v:TΓ⊢v1:T1Γ⊢v2:T2
Γ,v:=v1⊕v2|= Γ⇒[v:T∪T1∪T2,v1:T1∪(T−T2),v2:T2∪(T−T1)]Γ
Phi-AssignmentΓ⊢v:TΓ⊢v1:T1Γ⊢v2:T2
Γ,v:=φ(v1,v2)|= Γ⇒[v:T∪T1∪T2,v1:T1∪(T−T2),v2:T2∪(T−T1)]Γ
Method-Call-ParamΓ⊢va:TΓ⊢vf:T′
Γ,call(m,va→vf)|= Γ⇒[vf:T′∪T,va:T∪T′]Γ
Method-Call-ReturnΓ⊢v:TΓ⊢vr:T′
Γ,v:=return(m,vr)|= Γ⇒[v:T∪T′,vr:T′∪T]Γ
API-CallΓ⊢va:T′Γ⊢v:T
Γ,v:=apicall(m,va)|= Γ⇒[v:T∪model _fwd(m,va),va:T′∪model _bwd(m,v)]Γ
Figure 4: Bi-directional propagation rule.
or the UI to tag the correlated variables and propagate the ta gs bi-
directionally. We formalize this approach in a type system, i.e.,the
set of tags associated with a variable is treated as the type o f the
variable . Since the type is a set, we also call it a type set in this
paper. The mappings from variables to their type sets form th e
contextΓof the type system, which is iteratively updated during
analysis until a ﬁxed point is reached. For example, at the be gin-
ning,Γis empty. Upon a statement tmp = "username" ,Γis
updated to { tmp: {username }}. At this point, we have Γ⊢tmp:
{username }, which means under context Γ, variabletmp is typed
with set { username }. In other words, Γ(tmp)= {username }, where
Γ(tmp)evaluates variable tmp in the context to obtain the corre-
sponding type set.
When a statement is evaluated, the context may be updated. We
useΓ,S|= Γ⇒Γ′to indicate that under context Γ, evaluating
statement Supdates the context from ΓtoΓ′.
We use[var:T]Γto represent an update to the context. Specif-
ically, if no mapping is found for variable var in context Γ, the
mapping is added into the context. But if there exists some ma p-
ping forvar, the rule substitutes the existing type set for var with
the given type set T. Multiple mappings can be updated simul-
taneously, e.g.,[var:T,var’ :T′]Γupdates the context for two
variablesvar andvar’ .
Given two type sets TandT′,T∪T′unions the two sets while
T−T′returns a new type set which contains all elements belonging
toTbut notT′.
With the language in Fig. 3 and the above deﬁnitions, we deﬁne
the bi-directional type set propagation rules in Fig. 4. The propa-
gation is iterative. That means once the analysis starts, it does not
terminate until the context Γreaches a ﬁxed point.
3.2.1 Binding Constant Value
As mentioned earlier, we focus on constant texts in the code a nd
the constant Ids that are associated to UI. An assignment of a con-
stant string to a variable adds a new mapping from the variabl e to a
set holding the string to the context. For a constant Id, we ne ed to
make sure the Id is indeed a resource Id ( e.g., layout Id in Android
apps or an Id for a speciﬁc UI element). This check is modeled b y
predicateresource_id() . If the prerequisite satisﬁes, updating
the context is similar to the constant string assignment, ex cept that
the type set is the extracted texts from the corresponding UI through
functionextract_text() . For instance, if the constant Id is as-sociated with a typical login screen, the extracted text set may often
be {Username ,Password ,Login }.
3.2.2 Propagation for Assignment
Rule Unary-Assignment updates the context for both the LHS
and RHS variables with the union of the two separate type sets .
Note that it allows the tags from LHS to propagate to RHS and
vice versa through the union operation ( i.e.,bi-directional propa-
gation). Use the statement jsonString = data at line 18 in
Fig. 1 as an example. Assume before evaluating this statemen t,
Γ(jsonString )= {avatar_url ,username ,created_at ,content } and
Γ(data)= {data} via previous evaluation steps. After evaluating
this statement, the type sets for both variables jsonString and
data are updated to { avatar_url ,username ,created_at ,content ,
data}. This shares some similarity with type uniﬁcation in clas-
sic type inference. However, as we will see next, uniﬁcation does
not properly model the intended propagation behavior for bi nary
operations and φfunctions.
For a binary assignment, we cannot simply union all the type
sets of the LHS and RHS variables and associate the resultant type
set to all the variables, which is what classic type inferenc e would
do. We observe that this is undesirable as it allows the type s et of
a RHS variable to be propagated to another RHS variable while the
operation does not induce any data ﬂow between the two variab les.
Intuitively, assuming the two RHS variables are v 1and v2, v1being
associated with a sensitive tag does not entail v 2having the same
sensitive tag (by the operation). Thus, as speciﬁed by Rule B inary-
Assignment, the propagation is conducted as follows. The ty pe sets
of the RHS variables are unioned and inserted to the type set o f the
LHS variable. Only the part of the LHS type set that is not in th e
type set of v 1is propagated to v 2and only the part of the LHS type
set that is not in the type set of v 2is propagated to v 1. There is
a corner case in which the two RHS variables are the same one,
e.g.,a = b⊕b. The updated type set for bisΓ(b)∪(Γ(a)−
Γ(b)), which is equal to Γ(a)∪Γ(b). In other words, this special
case behaves the same as a unary assignment. The propagation for
φstatements has the same nature (Rule Phi-Assignment).
We use a real example from an Android app com.mojo.animewall -
paper to show how our propagation rule for φstatements eliminates
false alarms. The simpliﬁed code snippet is shown in Fig. 5a. If a
certain condition satisﬁes, the device Id is assigned to var iablexat
line 2. The detail of acquiring the device Id is omitted but ev en-
1721if(...) {
2x = getDeviceId(); // x is tagged with "android_id"
3}else{
4x = some_random_uuid(); // gen random value for x
5Log.d("Random: " , x);// sink
6}
7use(x);
(a) Simpliﬁed code snippet.
x@2
x@7 =φ(x@2,x@4)x@4
sink@5 android_id
(b) Data ﬂow and type propagation.
Figure 5: Code example and bi-directional propagation for φ
from app com.mojo.animewallpaper .
tually a constant string “ android_id ” is added to the type set of x.
If the condition doesn’t satisfy, a random value is generate d as the
requested Id at line 4 and stored to variable x, which is immedi-
ately used at a sink point at line 5. After the branch, variabl ex,
whose value is either the real device Id or a random value, is u sed
elsewhere.
From the perspective of φrepresentation, we know that right be-
fore thexis used at line 7, we have a φstatement as x@7 =φ(x@2,
x@4). The data ﬂow for the several occurrences of xis described
by the solid arrows in Fig. 5b and the propagation relations a re
shown by dashed arrows.
Consider a naive bi-directional propagation that simply un ions
all the type sets. During the ﬁrst iteration, “ android_id ” is prop-
agated tox@7 via forward propagation. Nothing is backwardly
propagated to x@2 orx@4 fromx@7. Therefore, at the end of
the ﬁrst iteration, Γ(x@2)=Γ(x@7)= {android_id } andΓ(x@4)
=∅. Then during the second iteration, if we directly propagate the
type set of x@7 to both x@2 andx@4, we would get Γ(x@4)=
{android_id }, which is later propagated to the sink point at line 5.
Thus a sensitive data disclosure is reported which is a false alarm.
In contrast, our propagation rule supports the mutual exclu sion of
the type sets in the two respective branches. Speciﬁcally, w e only
backwardly propagate Γ(x@7)−Γ(x@2),i.e.,an empty set, to
x@4. At last, the type set of x@4 stays unchanged and the sink
point does not observe any sensitive type for the variable. T hus no
sensitive data disclosure is reported.
3.2.3 Propagation for Method Calls
Propagation through a method call occurs at passing argumen t
from the caller and returning value from the callee. Therefo re, we
deﬁne two separate rules for these two events. Note that thes e two
rules handle method calls whose implementations are includ ed in
the analysis. We also propose a special rule for propagation over
API functions, the implementations of which are typically i nvisible
during analysis.
Rules Method-Call-Param and Method-Call-Return union the type
sets. A concrete example for rule Method-Call-Param is the i nstan-
tiation call at line 10 in Fig. 1. The constructor at line 17 is invoked
and the value held by variable dtis passed to variable data . Then
constant value “ data” associated with dtis propagated to data
and “ username ” associated with data is backwardly propagated
todt.
Rule API-Call does not directly propagate the type sets betw een
parameters and the return value. B IDTEXT relies on the model for
the API function for proper propagation. Prior static taint analy-
sis [7, 14] have shown that it is effective to simply propagat e from
all parameters to the return value and the receiver object ( i.e.,this
reference in instance method calls). However, this naive ap proachCheckAlert ::= IF(v c) {alert(v m)}
(a) Specialized statement.
Check-AlertΓ⊢vc:TΓ⊢vm:T′
Γ,IF(vc){alert(vm)} |= Γ⇒[vc:T∪T′]Γ
(b) Propagation rule.
Figure 6: Abstraction and propagation rule for Check-and-
Alert cases.
does not work well in bi-directional propagation. We need to in-
vestigate the type correlations for the variables involved in an API
call, including all the parameters and the return value.
Some API functions may not support fully bi-directional pro p-
agation among the variables. For example, variable name can be
used to type value in statement value=HashMap.get(name)
but not the reverse according to the semantics. Speciﬁcally , if
name holds some sensitive constant strings, we can infer that value
may hold sensitive information, but not the other way around . If we
ignorethis reference, after evaluating the statement under con-
textΓ, we have Γ′(name)=Γ(name)andΓ′(value)=Γ(value)
∪Γ(name). Many API functions, on the other hand, can be ap-
plied with the naive propagation policy, unioning the type s ets of
all variables. For example, we have Γ′(ret)=Γ′(str)=Γ(ret)∪
Γ(str)after evaluating statement ret = str.toUpperCase()
under context Γ. In the rule, the behavior depends on functions
model_fwd() andmodel_bwd() which deﬁne the propaga-
tion policies from vatovand from vtova, respectively.
We formalized our approach to identifying and bi-direction ally
propagating constant texts in a type system and developed a s et of
propagation rules based on our abstract language in Fig. 3. W hile
the rules are general for our language, in practice we need to per-
form a number of enhancements to the rules to handle real-wor ld
language/program features. These enhancements are discus sed in
next section.
3.3 Practical Enhancements
There are two main practical enhancements to our formal mode l
that are critical to the effectiveness of B IDTEXT.
3.3.1 Check and Alert
It is common in real programs to prompt some alerts to the user
or write to the log ﬁle if a condition check fails. In this case , we
can use the alert/log message to infer what the correspondin g vari-
ables involved in the condition check may hold. For example, an
Android app can alert the user about some previous errors, e.g.,
some required inputs are missing, by showing a short message on
the screen. A typical implementation looks like the followi ng.
1if(str == null|| str.isEmpty())
2Toast.makeText( this,"Please Enter Password" , 1);
We can type variable str with the constant text “ Please Enter
Password ” and propagate it through the aforementioned rules.
The abstraction and the corresponding propagation rule are shown
in Fig. 6. This applies to a set of API functions, called the alert
functions.
3.3.2 String Concatenation
String concatenation is common in real-world apps. A concat e-
nation operation may involve both constant values and multi ple
variables. If we simply union the type sets of all the involve d vari-
ables and update the variables with resultant type set, we ma y in-
troduce false positives. Furthermore, the associations be tween the
constant strings (involved in the concatenation) and the va riables
(involved in the concatenation) also need to be properly ide ntiﬁed.
173const0
builder0const1
builder1
unbuilder2
pbuilder3
urlhttp://.../login?
username=&pwd= &pwd=
Figure 7: Propagation graph for a simple string concatenati on.
Str-APIapi_w_str(m) Σ⊢va:E
Γ′=string _partition (m,E)
Γ,v:=apicall(m,va)|= Γ⇒Γ∪Γ′
Figure 8: Propagation rule for string concatenation.
A simple strategy that associates all constant strings to al l variables
also produces a lot of false positives. For example, buildin g a URL
often involves multiple variables, each holding a value as p art of
the HTTP request. The variables can be either sensitive ( e.g., pass-
word) or insensitive ( e.g., user comment). We need to distinguish
the exact types correlated to the variables. Consider the fo llowing
example, in which a typical URL is constructed.
1url ="http://.../login?username=" + un +"&pwd=" + p;
At the bytecode level, the above statement is converted to:
1builder0 = new
StrinBuilder( "http://.../login?username=" );
2builder1 = builder0.append(un);
3builder2 = builder1.append( "&pwd=");
4builder3 = builder2.append(p);
5url = builder3.toString();
Assume the model for API StringBuilder.append() en-
tails fully bi-directional propagation, i.e., we propagate the type
sets of all involved variables to each other. The constant st ring
“http://.../login?username= ” is propagated to builder0 ,build -
er1,un,builder2 andp. A later text analysis would indicate
that bothunandpare associated with the sensitive text “ user-
name ”, which is incorrect for variable p. Similarly, “ &pwd= ” will
be propagated to un, which causes a false alarm.
However, if we do not allow the propagation from the String-
Builder instance ( e.g.,builder0 ) to the appended variable
(e.g.,un), that is, the red and blue edges are removed from Fig.7,
then neither “ username ” nor “ pwd” could be propagated to unor
p. As a result, we cannot infer that these two variables may hol d
sensitive information.
The expected propagation, according to the semantics of the URL
string, is that “ username ” is propagated to un, and “pwd” top, ex-
clusively. We observe that it is impossible to enforce such p ropa-
gation through API models ( e.g., the model for append() ) as an
API call may only represent a local operation that does not ha ve
the global view of the concatenated string. To address the pr oblem,
we need to analyze the entire concatenated string produced a t the
end. In our example, we ought to examine the ﬁnal result assoc i-
ated withurl in order to associate the appropriate text to variables
unandp. Therefore, we need to enhance our type system with the
following string analysis.
Rule Str-API in Fig. 8 determines if an API call has a string ar gu-
mentvawith a well-deﬁned format through function api_w_str() .
For example, new URL(str) is such a function as it implies
the variable str is a string of the url format. If so, the string
is of interest. B IDTEXT computes an abstract string Eforva,
which is stored in a string context Σthat maps a variable to an ab-
stract string. An abstract string is a regular expression including
both constant strings and variables . The abstract string is parti-
tioned by the function string_partition() so that the vari-
ables in the regular expression are associated with the appr opriateStrcatΣ⊢v1:E1Σ⊢v2:E2
Σ,v:=strcat(v1,v2)|= Σ⇒[v:E1·E2]Σ
Strcat-NilΣ⊢v1:nilΣ⊢v2:E2
Σ,v:=strcat(v1,v2)|= Σ⇒[v:v1·E2]Σ
Str-Const-AssignΣ,v:=t|= Σ⇒[v:t]Σ
Str-IfΣ,st|= Σ⇒ΣtΣ,sf|= Σ⇒Σf
Σt⊢v:Et Σf⊢v:Ef
Σ,IF(∗){st}ELSE{sf} |= Σ⇒[v:Et|Ef]Σ
Str-LOOP-Closure⊥,s|=⊥⇒Σ′Σ′⊢v:v·EΣ⊢v:E0
Σ,LOOP{s} |= Σ⇒[v:E0·(E)*]Σ
Str-LOOP-Simple⊥,s|=⊥⇒Σ′Σ′⊢v:E v/ne}ationslash∈E
Σ,LOOP{s} |= Σ⇒[v:E]Σ
Figure 9: Computing abstract strings.
texts. For the above example, the rule produces Γ′= {un: {user-
name },p: {pwd}}. We then combine Γ′into the current con-
textΓand further propagate the generated texts. Next, we will
ﬁrst explain how the abstract strings are computed and then t he
string_partition() function.
The rules for computing abstract strings are shown in Fig. 9. The
interpretation of the rules is similar to that for our type sy stem.
One difference is that we use the string context Σinstead of the
type context Γ. Rule Strcat simply concatenates the two abstract
strings of the operands. Rule Strcat-Nil handles the case in which
the ﬁrst operand does not have any mapping, meaning that it is
a string variable encountered for the ﬁrst time. In this case , the
variable itself is concatenated to the resulting string. It is similarly
handled when the second operand does not have mapping and the
rule is elided. Rule Str-Const-Assign handles the constant string
assignment.
Rule Str-If speciﬁes that for a conditional statement, B IDTEXT
computes the string contexts for the true and false branches sepa-
rately. For any variable that is present in the string contex t(s), the
resulting abstract string is an alternation of the abstract strings in
the branches. Consider the following code snippet.
1if(c) str := strcat( "&UserId=" , uId);
2elsestr := strcat( "&sessionId=" , sId);
The abstract string for variable str is (“&UserId= ”·uId)|(“&ses -
sionId= ”·sId).
Rule Str-LOOP-Closure speciﬁes that for a loop, B IDTEXT ﬁrst
computes the string context for the loop body with an empty st ring
context and then aggregates the resulting abstract strings to the
original string context. In particular, if the abstract str ing for a vari-
ablevalso contains v, it indicates the resulting string has recursive
structure (caused by the loop), B IDTEXT hence associates vto a
kleene closure in the context outside the loop. Tail recursi on is
similarly handled. Currently, B IDTEXT only handles regular lan-
guages, which is sufﬁcient for most cases we encountered. Ru le
Str-LOOP-Simple speciﬁes that if there is no recursive stru cture,
the abstract strings are simply copied from the context of th e loop
body to the context outside the loop. For the following examp le,
BIDTEXT produces the abstract string “ Output: ”·(“A”)* for vari-
ablestr.
1str :="Output:" ;
2for(...)
3str := strcat(str, "A");
As shown by Rule Str-API, the abstract string at an API that
speciﬁes the format of the string is partitioned to acquire t he texts
for the variables within the abstract string. This is done by calling
174string_partition (). This function has a number of built-in
parsers that can parse the different string formats based on the API
name. For example, if the API is URL() , it uses the parser for url.
Particularly, the parser searches for symbol “ ?”, the part after the
symbol is parsed by “ ([^=]*)=([^&]*) ” with the ﬁrst part being the
key and the second part the value. If the key is a constant tand the
value is a variable v,Γis updated with the mapping from vtot.
BIDTEXT also has parsers for other formats such as SQL queries.
For example, two mappings { v1: {password },v2: {userid }} can
be extracted from an abstract string denoting a SQL update “ update
TABLE set password= ”·v1·“where userid= ”·v2.
For the prior URL example, append() is essentially a str-
cat() . According to the rules, the ﬁnal abstract string for url is
“http://.../login?username= ”·un·“&pwd= ”·p. It is partitioned so
thatunis mapped to { username } andpis mapped to { pwd}.
3.4 Disclosure Analysis
After the type set computation converges, B IDTEXTchecks whe-
ther arguments at the sinks points hold any sensitive data vi a textual
analysis. If the type set information indicates the sensiti veness of
an argument, we report a potential disclosure.
Algorithm 1 Sensitiveness determination.
determine_sensitiveness( T,S,KWD )
1:for allt∈Tdo
2:t′= preprocess( t)
3: ift′matches in KWD then
4: ift′is a word ort′doesn’t match any negation template then
5: S=S∪t
6: end if
7: end if
8:end for
The process to determine the sensitiveness of a variable wit h a
set of associated constant texts is presented in Algorithm 1 , which
assumes the text set Tand a set of sensitive keywords KWD . For
each collected string ( i.e., word, phrase or sentence), B IDTEXT
ﬁrst conducts some preprocessing. For example, “ EmailAddress ”
is converted to “ email address ”. If a string contains more than one
sentence, it is split using the standard sentence division m ethod
implemented in Stanford Parser [34]. If the string matches a ny
keyword, we check whether it is a single word. If so, we put the
string into Swhich holds all sensitive strings. Scan be used to
decide what sensitive information is disclosed after the al gorithm
ﬁnishes. If the string is a phrase or a sentence, we need to che ck
if it is the negation of a sensitive keyword. For example, “ do not
enter password here ” tells the user that the input ﬁeld should not
contain any password. Even though the string matches a sensi tive
keyword “ password ”, we do not consider it sensitive. So if the cor-
responding variable does not have any other associated sens itive
texts, it is treated insensitive and the sink does not have a s ensitive
data disclosure problem.
We use Stanford Parser [34] to parse a phrase or a sentence int o
a syntax tree, which is then converted to a dependency relati on
(please refer to [5]). Based on the dependency relation, B IDTEXT
searches the negation word “ not” and then checks the auxiliary
word right before the negation word. It also examines if ther e exists
a subject noun word before the auxiliary word. By combining t he
auxiliary word and the possible subject word, B IDTEXT can iden-
tify whether the phrase/sentence is imperative or declarat ive. For
example, “ do not ” and “ you should not ” are imperative negations
but “ you did not ” is declarative negation. B IDTEXT only consid-
ers the imperative negation as a negation (of sensitive keyw ord). In
such cases, the text is not sensitive.4. IMPLEMENTATION
We implemented B IDTEXTto detect sensitive data disclosures in
Android apps. B IDTEXTis built on top of WALA [6], which parses
the Android DEX bytecode to intermediate representations. We
implemented the algorithm in [23] to collect possible entry points
(e.g.,onCreate for an activity ) in the target Android app. For
each entry point, B IDTEXT builds the call graph and the depen-
dency graph. The constant strings are propagated on the grap hs.
We do not distinguish the correlated text for each UI element as in
[17]. Instead, all elements in one layout ﬁle are associated with all
the texts found in that layout ﬁle.
BIDTEXT relies on a keyword set to determine the sensitiveness
of computed texts. To acquire the keyword set, we ran B IDTEXT
on 2,000 randomly selected apps and extracted all texts disc overed
for each sink. We then manually inspected these texts to cons truct
the keyword set. In order to detect traditional data closure s that
are due to data-ﬂow between source APIs and sink APIs instead
of texts, we assign some sensitive textual keywords to the so urce
APIs that must expose sensitive information so that B IDTEXT can
propagate the keywords. For example, we assign “ imei” to API
TelephonyManager.getDeviceId() .
We leverage Stanford Parser [34] as the engine for analyzing
phrases and sentences. B IDTEXT currently only supports English.
For better efﬁciency, B IDTEXT also performs on the ﬂy type
set reduction. Speciﬁcally, when a text set reaches a certai n size,
garbage collection is conducted by ﬁltering out the texts in the type
set that do not indicate sensitiveness and those that are red undant.
5. EV ALUATION
All experiments are performed on an Intel Core i7 3.4GHz ma-
chine with Ubuntu 12.04. The task of analyzing each app is giv en
the maximum memory of 10GB and the maximum analysis time of
20 minutes. The subjects are a collection of 10,000 Android a pps
downloaded from Google Play in March 2015. The sink points
used in the evaluation contain all the logging operations in Android
and the Apache HTTP access APIs that are commonly used in An-
droid apps. This is also the standard setup for many existing static
taint analysis [17, 18]. The other types of sink points can be easily
added to B IDTEXT.
5.1 Pilot Study
As discussed earlier, B IDTEXT heavily relies on accurate propa-
gation models for API method calls. However, Android framew ork
contains thousands of API functions, making it almost infea sible to
manually build the models for all API functions. Our approac h is to
randomly select 2,000 apps and run B IDTEXT on these apps. Then
we inspect the results to discover popular API functions and create
models only for those functions. These models are later used in the
larger scale study.
During the pilot study, we also observe a kind of false positi ve
that appears frequently. It is caused by a Facebook library u sed
by many apps. The library logs an error message when it fails t o
obtain the device Id. The code snippet is abstracted as follo ws.
1try{/*acquire device id */}
2catch(Exception e) { Utility.logd( "android_id" , e); }
The message eis typed with “ android_id ”, which is a sensitive
keyword. But the meaning of this message is indeed that the ac tion
of acquiring the device Id fails. Solving this issue require s in-depth
semantic analysis of ewhich is not supported by B IDTEXT. Since
the pattern is ﬁxed, we post-process all the reports to ﬁlter out this
pattern for both the pilot study and the later large scale stu dy.
17542% 51% 
0% 25% 50% 75% 100% 
Figure 10: Distribution of accumulative analysis time for a ll
apps.
2293 
1331 
472 200 83 27 52.0% 82.3% 93.0% 97.5% 99.4% 100.0% 
0.0% 50.0% 100.0% 
01250 2500 
0~1 1~5 5~10 10~15 15~20 20~ #Apps 
CDF 
Figure 11: Distribution for the analysis time (in minutes) o f the
apps reported with sensitive data disclosures.
5.2 Uniﬁcation vs. Bi-directional Propagation
In classic type inference, given an assignment statement su ch as
z=x+y andz=φ(x,y) , the updated type sets of x,y, andzare
the union of all three original type sets. In Section 3.2.2 (R ules
Binary-Assignment and Phi-Assignment in Fig. 4), we mentio ned
that such a uniﬁcation based approach may produce a lot of fal se
positives and hence B IDTEXT makes use of a bi-directional prop-
agation strategy that avoids propagating type sets between right-
hand-side operands ( i.e.,xandyin the example). In this experi-
ment, we want to compare these two propagation strategies.
Due to the lack of ground truth, such a study requires manuall y
inspecting the reported disclosure defects and determinin g if they
are false positives. Among the 2000 apps tested in the pilot s tudy,
we selected the ﬁrst 60 apps whose data disclosure path (i.e.,the
data ﬂow subgraph that includes the path from the source to th e sink
and the path that the sensitive text is propagated from its or igin to
the sink) involves φstatements and/or binary operations with the
uniﬁcation based propagation policy. We re-run B IDTEXT on the
60 apps with the bi-directional propagation policy and comp are the
two sets of results.
Among these 60 apps, 42 of them are reported by both the uni-
ﬁcation policy and the bi-directional policy; 25 of them con tains
ﬂows only reported by the uniﬁcation policy. Note that the tw o do
not add up to 60 because some apps have multiple reported disc lo-
sures, some being reported by both policies and the others be ing
only reported by the uniﬁcation policy. We manually studied the
25 cases reported by the uniﬁcation policy and found that the y are
all false positives. We have shown one sample false positive in
Section 3.2.2.
5.3 Large Scale Evaluation
In this experiment, we use 10,000 apps not covered by the pilo t
study. The apps have a minimum size of 6.46KB for the APK ﬁles
and a maximum size of 49.94MB. The average size of the APK
ﬁles is 9.17MB. Among these apps, there are two that do not con -
tain any DEX bytecode in the APK ﬁles. For the remaining apps,
the minimum size of the bytecode ﬁles ( classes.dex ) is 452
bytes and the maximum size is 10.32MB. The average size of the
bytecode ﬁles is 2.53MB.
5.3.1 Results
The total analysis time for the 10,000 apps is 587.6 hours. Fi g. 10
presents the distribution of the cumulative analysis time f or all the
10,000 apps. We divide the total analysis time into three par ts ac-
cording to how the analysis on an app terminates. As mentione d
above, we set the analysis timeout to 20 minutes for each app. In
our evaluation, 856 apps (8.56%) time out and the total analy sis
time account for 49% of the total time consumed for the 10,000
TEXT-Only, 36.0% 
API-Only, 0.3% 
TEXT+API, 9.8% TEXT+GUI, 27.4% API+GUI, 0.2% TEXT+API+GUI, 
7.2% GUI-Only, 19.1% 
(a) By sources.
Logging-Only, 
61.7% 
Non-Logging-Only, 
3.2% Both, 35.1% 
(b) By sinks.
Figure 12: Breakdown of the reported apps.
17.5% 53.9% 
0.0% 25.0% 50.0% 75.0% 100.0% TraditionalSUPOR BidText 
(a) All sinks.15.3% 60.4% 
0.0% 25.0% 50.0% 75.0% 100.0% TraditionalSUPOR BidText 
(b) Non-logging sinks.
Figure 13: Comparing BIDTEXT with static tainting (tracking
speciﬁc APIs) and SUPOR [17].
apps. We have 293 other apps of which the analysis ran out of
memory. The total time for these apps accounts for 9%. For the
remaining 8,852 apps that ﬁnished normally take only 42% of t he
total analysis time. Observe in Fig. 10 that the ﬁrst 7,500 ap ps take
less than 15% of the total time. Among the 8,852 apps, the mini -
mum analysis time is 0.2 seconds and the maximum time is 1197. 4
seconds. The median is 24.9 seconds while the average time is 99.9
seconds. The largest app that terminates normally has the AP K size
of 49.94MB, and the bytecode size of 10.32MB.
Overall, B IDTEXT reports 4,406 apps with sensitive data disclo-
sure problems. We show the analysis time distribution of the se apps
in Fig. 11. The blue bars show the number of apps that ﬁnished
within a time period. For instance, 472 apps took more than 5 m in-
utes but less than 10 minutes. We also see that 27 apps timed ou t in
the experiments, although partial results were collected b efore the
analysis terminated. The red line presents the cumulative a nalysis
time: 93.0% of the apps were analyzed within 10 minutes. We ca n
conclude that B IDTEXT is efﬁcient to be applied to market-scaled
apps.
We also show the breakdown of the 4,406 apps by the sources of
data disclosures in Fig. 12a.
There are three types of sources: (1) TEXT – constant texts in
the code that denote sensitive data; (2) API – sensitive API ( recall
that B IDTEXT also detects data disclosures originating from sen-
sitive APIs by associated artiﬁcial texts to the source APIs such
asLocation.getLatitude() ); and (3) UI – constant texts
retrieved from user interfaces that denote sensitive data. Observe
that the majority of disclosures are/can be detected by the s ensi-
tive text labels. Some data disclosure defects can be recogn ized
through multiple sources ( e.g., TEXT+API), meaning that there
are some (bi-directional) data ﬂow paths from a sensitive AP I to
a sink and from some constant text to the same sink. Consider
the following example. The data ﬂow path 2 →6→7 denotes a dis-
closure originating from TEXT ( i.e.,“android_id ”) and the path
4→6→7 denotes a disclosure originating from API ( i.e.,“getDe-
viceId() ”).
1if(fails_to_obtain_imei()) {
2id= Settings.Secure.getString(resolver,
"android_id" );
3}else{
4id= telephonyManager.getDeviceId();
5}
6json.putString( "id",id);
7http_sink( json.toString()); // sink
The breakdown of the apps by the sink types is shown in Fig. 12b .
Note that 64.9% of the reported apps contain disclosures due to
logging. Although data disclosure through logging is subst antially
17622.0% 29.5% 
23.7% 
11.4% 
6.4% 2.9% 1.5% 1.4% 1.2% 
0.0% 10.0% 20.0% 30.0% 
1~10 11~20 21~30 31~40 41~50 51~60 61~70 71~80 81~ 
Figure 14: Length distribution of the emitted paths for the r e-
ported apps. X axis shows the length of the paths.
Table 1: Manually inspected evaluation results for 100 apps .
TEXT API UI
Total 84 22 39
Only 44 214
FP 3 0 7
mitigated by access control in the latest version of Android , it is
still a security concern for legacy Android systems such tha t most
existing works [7, 22, 17] report these disclosures. About 3 8.3% of
the reported apps (16.9% of all the apps evaluated) contain s ensi-
tive data disclosures due to to non-logging sinks. They are s erious
threats even in the latest Android systems.
Fig. 13 shows how B IDTEXT compares with an implementation
of the traditional taint tracking technique (tracking disc losures from
source APIs through forward data-ﬂow similar to [14]) and SU -
POR [17], which is a technique that tracks disclosures from s en-
sitive UI elements ( e.g., input boxes) through forward data-ﬂow.
BIDTEXT always reports a super-set of those reported by the clas-
sic tainting and SUPOR. In the ﬁgure, the numbers of apps repo rted
by tainting and SUPOR are normalized to those reported by B ID-
TEXT. Observe that they only report 17.5% and 53.9% of those
reported by B IDTEXT, respectively. Even combining the two can
only detect 64.0%. If only taking non-logging disclosures i nto ac-
count, they report 15.3% and 60.4% of those reported by B IDTEXT.
This attributes to both the new text label correlation analy sis and the
bi-directional type set propagation strategy.
We present the length distribution of the emitted data discl osure
paths for the 4,406 apps in Fig. 14. Though some paths tend to
be very long (more than 80 elements), most of them are relativ ely
short. More than 75% of the paths require less than 30 steps fr om
the origination of the sensitive texts to the sink points.
False Positives and False Negatives. It is critical to understand the
quality of the reported defects. Due to the lack of ground tru th, we
had to perform manual inspection. Studying the full set of re sults
is infeasible. Hence, we randomly chose 100 reported apps wi th
a uniform size distribution for manual inspection. The resu lts are
presented in Table 1.
The columns indicate the sources of the disclosures. Row Total
shows the total number of reported apps for each sources. Row
Only shows the number of apps that only have reported disclosures
falling into one category. The last row shows the number of fa lse
positives.
Observe that the 10 false positives are exclusive. Therefor e, the
false positive rate is 10%. The causes for false positives wi ll be
discussed in Section 5.3.3. We do not count the false negativ es
because we don’t have the ground truth.
Among the 84 apps where disclosures are reported by code text
analysis, 62 apps contain paths that can be only detected by o ur ap-
proach via text correlation analysis, i.e.,the data used at sink points
neither come from any UI inputs nor from traditional source A PIs.
In other words, 62 of them cannot be detected by classic taint ing or
SUPOR. This ratio is consistent with that in Fig. 13 for the la rger
experiment. The other reported disclosures have the sensit ive data
coming from these two categories of sources. They are report ed by
both B IDTEXT and the existing technique(s). Another interesting
ﬁnding is that B IDTEXT often produces a shorter disclosure path.A typical scenario is that there is a long data ﬂow path from a U I
input element to a sink. However, mid way through the path, th e
(sensitive) data is put/get to/from some container with a se nsitive
textual key, which allows B IDTEXT to report a shorter path from
the put/get operation to the sink. The beneﬁts of shorter pat hs are
two-folded: less human efforts needed for inspection and de tecting
more disclosures (because the full path from the source poin ts to the
sink points might be complicated, involving inter-compone nt com-
munications, such that the tool may fail to traverse the full path).
5.3.2 Case Studies
We observe many cases in which sensitive textual keys appear to-
gether with data in key-value operations, e.g., constructing a name
value pair ( e.g.,com.gunsound.eddy.fafapro ), inserting data into a
hash map ( e.g.,me.tango.ﬁshepic ), retrieving/adding data to persis-
tent storage through an instance of SharedPreferences (e.g.,
com.ifreeindia.sms_mazaa ) or putting data into a JSON object ( e.g.,
com.mobilegustro.war.battle.air.force ). B IDTEXT recognizes the
sensitiveness of corresponding data via text correlation a nalysis.
In the following, we show a code snippet adopted from app com. -
pro.ﬁnd.differences that discloses sensitive device information to
Web servers.
1voidobtainDeviceInfo() {
2TCore.aid= Settings.Secure.getString( resolver ,
"android_id" );
3}
4voidconnectWebServer() {
5Map map = newHashMap();
6safePut(map, "android_id" , TCore. aid);
7String params = convertURLParams(map); // omitted
8http_sink(params); // sink
9}
10voidsafePut(Map map, String k, String v) {
11map.put(k, v);
12}
The method call at line 2 returns system information based on
the given key value. For example, a unique Id for the device is
obtained if “ android_id ” is given as the key. If the key is “ en-
abled_input_methods ”, the return value contains a list of input meth-
ods that are currently enabled. Therefore, the sensitivene ss of the
return value depends on the key. B IDTEXT works by correlating
the textual key with the return variable to decide whether a l ater
sink operation involves sensitive data or not.
In the above example, the variable TCore.aid is typed with
the constant text “ android_id ” at line 2, which is later propagated
to parameter vof method safePut() at line 10. vis inserted
into the hash map at line 11. Note that “ android_id ” at line 6 is
propagated to k@10 which is further propagated to the hash map
and variable vaccording to the corresponding API model for prop-
agation. Along the data ﬂow, the constant text is propagated to
params @7 that is eventually used at the sink point at line 8. B ID-
TEXT reports the data disclosure.
5.3.3 False Positives
One of the 10 false positives is caused by unmodeled API func-
tions. The corresponding code snippet is from app at.zuggabecka. -
radiofm4 .
1uidx = cursor.getColumnIndex( "username" );
2iidx = cursor.getColumnIndex( "_id");
3id = cursor.getLong(iidx);
4sink(id);
At line 1, a sensitive keyword “ username ” is correlated with the
receiver object cursor that is related to a database query. Then all
uses ofcursor propagate the text label to other variables, e.g., the
return value of a relevant method call. Thus, idat line 3 is typed
177with “ username ”. Later when it is used at a sink point, B IDTEXT
reports a sensitive data disclosure after analyzing the cor responding
type set. To remove this false alarm, we can build a model for A PI
Cursor.getColumnIndex(key) to only propagate type set
fromkey to the return value, avoiding propagating to the receiver
object. Then in the above code snippet, only variable uidx @1
is typed with “ username ”. Variable idthat appears at the sink
point is only typed with “ _id” which is not considered as a sensitive
keyword. Therefore there is no disclosure problem with the m odel.
All the other nine false positives are caused by incorrect re cog-
nition of text, two for code text and seven for UI text.
App com.netcosports.andalpineski contains a text label as “ Apps -
_lang[apps_lng_iso2] ” which indicates the language of the app.
However, it contains a predeﬁned sensitive keyword “ lng” which
is mostly used as an abbreviation of “ longitude ”. Failing to un-
derstand the meaning of the text, B IDTEXT incorrectly reports a
sensitive data disclosure.
App com.wactiveportsmouthcollege has a UI text of “ Pin to desk-
top” where sensitive keyword “ Pin” is used as a verb. Failing to
understand it leads to a false positive. All other false posi tives
have similar causes – sensitive keywords in a phrase or sente nce
do not indicate any sensitive information. Possible soluti ons for
this type of false positives include integrating more advan ced NLP
techniques with program analysis to understand the meaning s of
the text.
5.4 Discussion
One limitation of B IDTEXT lies in that the text in code may not
be in a generalized format. For example, some developers use “lng”
for “ longitude ” whereas others use “ long” for it, which is a more
general word in English. If we treat “ long” as a sensitive keyword,
we can expect many false positives. In addition, developers tend to
combine several words (or abbreviations) into a single word , which
makes it more difﬁcult to determine whether the correlated d ata are
sensitive or not.
In the future, we plan to improve our approach in the followin g
aspects. The ﬁrst one is to discover text labels in the names o f
method calls, if they are not obfuscated, and variable/ﬁeld names.
The second improvement is to consider code comments if sourc e
code is available. The third one is to improve the NLP aspect b y
putting the keywords in their program context. Doing so, we m ay
be able to recognize “ long” indeed means longitude.
6. RELATED WORK
A lot of prior research has focused on detecting sensitive da ta
disclosures, either statically or dynamically, for mobile apps [14, 7,
8, 9, 15]. Most of them consider speciﬁc APIs as sensitive sou rce
points while B IDTEXT analyzes text labels to determine if a vari-
able can hold sensitive data. S USI[32] gives a comprehensive list
of the data sources in Android, but it does not assume the data
obtained from the sources must be sensitive. In addition, ev en if
the state-of-the-art static detectors, e.g., FlowDroid [7] and Droid-
Safe [15], had been enhanced with various ways of determinin g
data sensitiveness, they would likely not be able to detect s ome
sensitive data disclosures reported by B IDTEXT such as our moti-
vating example, where the sensitiveness of the data is deter mined
after the sink point and there is no forward data-ﬂow from the sen-
sitiveness revelation point and the sink point. B IDTEXT, however,
leverages bi-directional propagation to address this prob lem.
Huang et al. developed type-based taint analysis to detect infor-
mation leaks in Java-based Web applications and Android app s via
type inference [19, 20]. They abstract the information ﬂow a nal-
ysis into a type system and check if any type error occurs. The irtechnique scales well without using advanced points-to ana lysis [7,
15]. Their technique still follows the traditional deﬁniti on of data
disclosure, which is a forward data ﬂow path from the source t o the
sink. In other words, it does not propagate data sensitivene ss in a
backward fashion. As such, it may not be able to report many di s-
closures reported by B IDTEXT, including the motivating example.
Furthermore, their type system does not leverage text infor mation.
Ernst et al. also developed a type-based taint analysis system [11].
Their technique associates a few (security) types such as LO CA-
TION, INTERNET, and SMS to sources and sinks and have a set
of predeﬁned policies such as LOCATION can only be compati-
ble, or type-checked, with INTERNET. So if LOCATION reaches
a program point with the SMS type, a leak is reported. Their ﬂo w
analysis is forward whereas B IDTEXT is bi-directional. And B ID-
TEXT leverages text labels.
SUPOR [17] and UIPicker [27] discover sensitive informatio n
on user interfaces through static analysis. However, they e ssen-
tially belong to the traditional forward data-ﬂow based tec hniques.
AsDroid [18] collects the set of API calls in an event handler and
compares the meaning of these API calls with the UI text of the
event to detect unwanted/unexpected app behavior. In contr ast,
BIDTEXT types individual variables in the program with text la-
bels and leverages a type system that allows bi-directional propa-
gation. Researchers also combine code and comment analysis to
detect bugs or inconsistencies [35, 36, 37]. We envision com ment
analysis can leverage our bi-directional type system so tha t the in-
formation in comments can be leveraged to analyze ﬁne-grain ed
and in-depth app behavior. In addition, W HYPER [29] and Au-
toCog [31] apply NLP techniques to app’s descriptions to obt ain a
comprehensive view of the app and check if the required permi s-
sions are appropriately speciﬁed in the descriptions. Besi des, [30]
and [41] apply NLP techniques on API descriptions or documen ts
to infer method speciﬁcations. We can leverage these techni ques to
automate the generation of API models used in B IDTEXT.
7. CONCLUSION
We propose B IDTEXT, a novel static technique to detect sensi-
tive data disclosures. B IDTEXT identiﬁes text labels appearing in
both code and UI, treats them as types, associates them to the cor-
responding variables, bi-directionally propagates the ty pes through
data ﬂow and eventually attributes them to sink points that p oten-
tially disclose sensitive information. At the end, the para meters at
the sink points have type sets of correlated texts. Textual a nalysis is
applied to the type sets to determine if the variables may hol d sensi-
tive data. We implement B IDTEXT and evaluate it on 10,000 apps
downloaded from Google Play store. B IDTEXT reports 4,406 apps
that have sensitive data disclosure problems including 4,2 63 apps
disclosing sensitive information through logging and 1,68 8 through
non-logging channels. Existing techniques can only report 64.0%
of cases reported by B IDTEXT. Manual inspection shows the false
positive rate is 10%. The overhead of B IDTEXT is reasonable.
8. ACKNOWLEDGEMENTS
We thank the anonymous reviewers for their constructive com -
ments. This research was supported, in part, by DARPA under c on-
tract FA8650-15-C-7562, NSF under awards 1409668, 1320444 ,
and 1320306, ONR under contract N000141410468, Cisco Sys-
tems under an unrestricted gift, and Natural Sciences and En gi-
neering Research Council of Canada. Any opinions, ﬁndings, and
conclusions in this paper are those of the authors only and do not
necessarily reﬂect the views of our sponsors.
1789. ARTIFACT DESCRIPTION
This artifact provides an executable environment of B IDTEXT.
The goal is to reproduce the results shown in the paper, as wel l as
to let the users be able to apply B IDTEXT on Android apps of their
interest.
9.1 Where is the artifact?
The source code is publicly available at https://bitbucket .org/
hjjandy/toydroid.bidtext. Gradle [3] build is supported. And JDK
7 or newer versions is required to compile the source code.
A virtual machine (VM) image with Ubuntu 14.04 can be found
at: https://github.com/hjjandy/FSE16-BidText-Artifac ts-VM. It is
created by Oracle VM VirtualBox [4]. The VM contains the sour ce
code, executables and a small set of test apps. It has been tes ted on
Windows 10 and Ubuntu 14.04, but not on MacOs.
The users can also download the executables and the test apps at
https://github.com/hjjandy/FSE16-BidText-Artifacts. It provides sup-
port to execute the tool on both Windows and Linux if Java 7
or newer versions with AMD64 architecture has been installe d.
Git LFS [2] is required to clone the repository. If the users e n-
counter anIOException when B IDTEXT tries to load the parser
from englishPCFG.ser.gz , please check if the models of Stanford
Parser (“ stanford-parser-3.4.1-models.jar ”) have been downloaded
correctly via Git LFS.
9.2 What are contained?
In the HOME directory of the VM, one ﬁle and three folders are
related to the artifacts.
File “ FSE16-Artifacts-Eval-README ” is a detailed description
of the artifacts, including how to run the tool and how to unde rstand
the results. It also contains some issues that need special a ttention
to run the tool well.
Folder “ BidText-Source ” contains a full copy of the source code.
The users can update it via “ git pull ”. “BidText-TestApps ” contains
a portion of Android apps used in the paper. Inside it, there a re four
special cases, corresponding to the four examples presente d in the
paper. They are the motivation example (Fig. 1 in Section 2), the
example for bi-directional propagation on PHI statement (F ig. 5
in Section 3.2.2), the example of two different types of sour ces
ﬂowing to the same sink (Section 5.3.1) and the case study in S ec-
tion 5.3.2. Besides, sub-folder “ Others ” contains the 100 apps used
to measure the accuracy of B IDTEXT, whose results are presented
in Table 1. “ BidText-Bin ” contains the necessary libraries, conﬁg-
urations and scripts to execute B IDTEXT. Note that it is infeasible
to host all the apps used in the paper due to the sheer volume of the
apps.
9.3 How to run the tool?
In order to apply the tool on an Android app, the user can run it
on a terminal under the folder “ BidText-Bin ”:./RUNPath_to_APK .
The user can also use the four start scripts to perform analys is on
the four corresponding cases. For example, ./Motivation is
equal to./RUN$HOME/BidText-TestApps/Motivation/
com.buycott.android-22.apk . If the users want to test the
100 apps, just execute ./Eval-100 .
Since B IDTEXT requires a lot of memory to perform analysis,
the user is required to allocate enough memory for the VM when
creating a VM in VirtualBox. It should be at least 5GB because
the default setting of JVM heap size for running B IDTEXT in the
VM is 4GB, which is not enough to evaluate all the 100 apps. We
suggest 12GB to evaluate the 100 apps. The users can modify “ bid-
text.prop ” to set a larger JVM heap size for B IDTEXT.
The non-VM artifacts also contain start scripts (batch ﬁles ) toallow easy execution of B IDTEXT on Windows. The commands
and the settings are the same as in the VM.
9.4 How to understand the results?
After analyzing an APK ﬁle, B IDTEXT generates the results (if
reported any) in folder “ APK_name .bidtext” which is aside the APK
ﬁle. Each reported sink point has an individual result ﬁle na med
“idx.Sink_Type .txt”, e.g., 384.LOG.txt. The result ﬁle contains the
sink API and the enclosing method of the sink. For each identi ﬁed
sensitive textual label, surrounded by “********”, the pro pagation
path is listed. Each path element is the String representation of
a WALA [6] Statement , an IR used during the analysis. In the
following, we show part of the results for the motivation exa mple.
Note that we did some simpliﬁcation for readability.
1******** username ********
2NORMAL_RET_CALLER :Node: <CampaignActivity$20$1,
run()V> 66 = invokevirtual <JSONObject,
getString( String)String> 18,64
3NORMAL_RET_CALLER :Node: <CampaignActivity$20$1,
run()V> 18 = invokevirtual <JSONArray,
getJSONObject( int)JSONObject> 5,172
NORMAL_RET_CALLER is the type of the Statement and
“Node ” indicates the location of the statement. The numbers are
the variables values, distinct for any SSA variables. For ex ample,
“66” can be treated as a variable v66, which can only be deﬁned
once in the enclosing method. For more details about the repr e-
sentation, please refer to WALA document. The sensitive tex tual
label “ username ” propagates from line 1, which is a method invo-
cation. Through inspecting the app’s code, we know that the l abel
is a constant string stored in v64 while the JSON object is asso-
ciated with v18. In the second statement, we see that v18 is the
return value of a method call. That means, the two statements con-
stitute a backward propagation. Please refer to Fig. 1 to get a better
understanding of the motivation example.
10. REFERENCES
[1] Buycott. http://buycott.com/. Accessed: 03 Mar 2016.
[2] Git large ﬁle storage. https://git-lfs.github.com/.
[3] Gradle build tool | modern open source build automation.
https://gradle.org/.
[4] Oracle VM VirtualBox. [https://www.virtualbox.org/.
[5] Universal dependencies. http://universaldependenci es.github.
io/docs/.
[6] WALA: T.J. Watson Libraries for Analysis. http://wala.
sourceforge.net.
[7] A RZT, S., R ASTHOFER , S., F RITZ , C., B ODDEN , E.,
BARTEL , A., K LEIN , J., L ETRAON , Y., O CTEAU , D., AND
MCDANIEL , P. FlowDroid: Precise context, ﬂow, ﬁeld,
object-sensitive and lifecycle-aware taint analysis for
Android apps. In PLDI (2014).
[8] E GELE , M., K RUEGEL , C., K IRDA , E., AND VIGNA , G.
PiOS: Detecting privacy leaks in iOS applications. In NDSS
(2011).
[9] E NCK, W., G ILBERT , P., C HUN , B.-G., C OX, L. P., J UNG ,
J., M CDANIEL , P., AND SHETH , A. N. TaintDroid: an
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In OSDI (2010).
[10] E NCK, W., O CTEAU , D., M CDANIEL , P., AND
CHAUDHURI , S. A study of Android application security. In
USENIX Security (2011).
[11] E RNST , M. D., J UST, R., M ILLSTEIN , S., D IETL , W.,
PERNSTEINER , S., R OESNER , F., K OSCHER , K., B ARROS ,
179P. B., B HORASKAR , R., H AN, S., V INES , P., AND WU,
E. X. Collaborative veriﬁcation of information ﬂow for a
high-assurance app store. In CCS (2014).
[12] F ORTI GUARD CENTER . Information disclosure
vulnerability in OpenSSL (Heartbleed). http://www.
fortiguard.com/advisory/2014-04-08-information-
disclosure-vulnerability-in-openssl.
[13] G ARTNER . Gartner says smartphone sales surpassed one
billion units in 2014. http://www.gartner.com/newsroom/ id/
2996817.
[14] G IBLER , C., C RUSSELL , J., E RICKSON , J., AND CHEN, H.
AndroidLeaks: Automatically detecting potential privacy
leaks in Android applications on a large scale. In TRUST
(2012).
[15] G ORDON , M. I., K IM, D., P ERKINS , J., G ILHAMY , L.,
NGUYENZ , N., AND RINARD , M. Information-ﬂow analysis
of Android applications in DroidSafe. In NDSS (2015).
[16] H ARIS , M., H ADDADI , H., AND HUI, P. Privacy leakage in
mobile computing: Tools, methods, and characteristics.
CoRR abs/1410.4978 (2014).
[17] H UANG , J., L I, Z., X IAO, X., W U, Z., L U, K., Z HANG ,
X., AND JIANG , G. Supor: Precise and scalable sensitive
user input detection for android apps. In USENIX Security
(2015).
[18] H UANG , J., Z HANG , X., T AN, L., W ANG , P., AND LIANG ,
B. Asdroid: Detecting stealthy behaviors in Android
applications by user interface and program behavior
contradiction. In ICSE (2014).
[19] H UANG , W., D ONG , Y., AND MILANOVA , A. Type-based
taint analysis for Java Web applications. In FASE (2014).
[20] H UANG , W., D ONG , Y., M ILANOVA , A., AND DOLBY , J.
Scalable and precise taint analysis for Android. In ISSTA
(2015).
[21] K IM, J., Y OON , Y., AND YI, K. ScanDal: Static analyzer
for detecting privacy leaks in Android applications. In MoST
(2012).
[22] L U, K., L I, Z., K EMERLIS , V., W U, Z., L U, L., Z HENG ,
C., Q IAN, Z., L EE, W., AND JIANG , G. Checking more and
alerting less: Detecting privacy leakages via enhanced
data-ﬂow analysis and peer voting. In NDSS (2015).
[23] L U, L., L I, Z., W U, Z., L EE, W., AND JIANG , G. CHEX:
Statically vetting Android apps for component hijacking
vulnerabilities. In CCS (2012).
[24] M AHEMOFF , M. "Ofﬂine": What does it mean and why
should I care? http://www.html5rocks.com/en/tutorials/
ofﬂine/whats-ofﬂine/.
[25] MITRE. CWE-200: Information exposure. https://cwe.
mitre.org/data/deﬁnitions/200.html.[26] M ULLINER , C. Privacy leaks in mobile phone internet
access. In ICIN (2010).
[27] N AN, Y., Y ANG , M., Y ANG , Z., Z HOU , S., G U, G., AND
WANG , X. UIPicker: User-input privacy identiﬁcation in
mobile applications. In USENIX Security (2015).
[28] OWASP. Information leakage. https://www.owasp.org/
index.php/Information_Leakage.
[29] P ANDITA , R., X IAO, X., Y ANG , W., E NCK, W., AND XIE,
T. WHYPER: Towards automating risk assessment of
mobile applications. In USENIX Security (2013).
[30] P ANDITA , R., X IAO, X., Z HONG , H., X IE, T., O NEY, S.,
AND PARADKAR , A. Inferring method speciﬁcations from
natural language API descriptions. In ICSE (2012).
[31] Q U, Z., R ASTOGI , V., Z HANG , X., C HEN, Y., Z HU, T.,
AND CHEN, Z. AutoCog: Measuring the
description-to-permission ﬁdelity in Android applicatio ns. In
CCS (2014).
[32] R ASTHOFER , S., A RZT, S., AND BODDEN , E. A
machine-learning approach for classifying and categorizi ng
Android sources and sinks. In 2014 Network and Distributed
System Security Symposium (NDSS) (2014).
[33] S EARCH ENGINE WATCH . Mobile now exceeds PC: The
biggest shift since the Internet began. https://
searchenginewatch.com/sew/opinion/2353616/mobile-no w-
exceeds-pc-the-biggest-shift-since-the-internet-beg an.
[34] The Stanford Natural Language Processing Group, 1999.
http://nlp.stanford.edu/.
[35] T AN, L., Y UAN, D., K RISHNA , G., AND ZHOU , Y. /*
iComment: Bugs or bad comments? */. In SOSP (2007).
[36] T AN, L., Z HOU , Y., AND PADIOLEAU , Y. aComment:
Mining annotations from comments and code to detect
interrupt-related concurrency bugs. In ICSE (2011).
[37] T AN, S. H., M ARINOV , D., T AN, L., AND LEAVENS , G. T.
@tComment: Testing javadoc comments to detect
comment-code inconsistencies. In ICST (2012).
[38] US-CERT. OpenSSL ’Heartbleed’ vulnerability
(CVE-2014-0160). https://www.us-cert.gov/ncas/alerts /
TA14-098A.
[39] X IA, N., S ONG , H. H., L IAO, Y., I LIOFOTOU , M., N UCCI ,
A., Z HANG , Z.-L., AND KUZMANOVIC , A. Mosaic:
Quantifying privacy leakage in mobile networks. In
SIGCOMM (2013).
[40] Z AKAS , N. C. Towards more secure client-side data storage.
https://www.nczonline.net/blog/2010/04/13/towards-m ore-
secure-client-side-data-storage/.
[41] Z HAI, J., H UANG , J., M A, S., Z HANG , X., T AN, L.,
ZHAO, J., AND QIN, F. Automatic model generation from
documentation for Java API functions. In ICSE (2016).
180