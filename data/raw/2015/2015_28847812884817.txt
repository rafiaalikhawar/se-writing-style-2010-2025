Automated Partitioning of Android Applications for
Trusted Execution Environments
Konstantin Rubinov1, Lucia Rosculete2, T ulika Mitra3, Abhik Roychoudhury3∗
1DeepSE Group at DEIB, Politecnico di Milano, Italy
2Application Threat Intelligence - Ixia, Romania
3School of Computing, National University of Singapore, Singapore
Email: konstantin.rubinov@polimi.it, luciarosculete@gmail.com, {tulika,abhik}@comp.nus.edu.sg
ABSTRACT
The co-existence of critical and non-critical applications on
computing devices, such as mobile phones, is becoming com-
monplace. The sensitive segments of a critical application
should be executed in isolation on Trusted Execution Envi-
ronments (TEE) so that the associated code and data can be
protected from malicious applications. TEE is supported by
diﬀerent technologies and platforms, such as ARM Trustzone,
that allow logical separation of“secure”and“normal”worlds.
We develop an approach for automated partitioning of
critical Android applications into“client”code to be run in
the“normal”world and“TEE commands”encapsulating the
handling of conﬁdential data to be run in the“secure”world.
We also reduce the overhead due to transitions between
the two worlds by choosing appropriate granularity for the
TEE commands. The advantage of our proposed solution is
evidenced by eﬃcient partitioning of real-world applications.
1. INTRODUCTION
Mobile devices have seen the emergence of services that
require an increased level of security (e.g., online banking,
premium content access, enterprise networks connection). At
the same time, these devices adopt open software platforms
allowing consumers to install arbitrary third-party applica-
tions capable of compromising the critical services. Attackers
have responded by investing in exploiting the growing number
of such vulnerabilities to gain access to valuable data [10].
As a countermeasure, device manufacturers take a scalable
approach to security through hardware protection measures
factored in early in the design process. For example, ARM
TrustZone [16] is designed to support Trusted Execution
Environment (TEE) [39]: a small secure kernel that shares
the processor with a rich OS (e.g., Android). TEE provides
hardware-enforced security to authorized software (Trusted
Applications) protecting them from malware in the rich OS.
∗Most of this work was done while the ﬁrst two authors were
aﬃliated to National University of Singapore.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citationon the ﬁrst page. Copyrights for components of this work owned by others than ACMmust be honored. Abstracting with credit is permitted. To copy otherwise, or republish,to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or afee. Request permissions from permissions@acm.org.
ICSE ’16, May 14-22, 2016, Austin, TX, USA
c/circlecopyrt2016 ACM. ISBN 978-1-4503-3900-1. . . $15.00
DOI: http://dx.doi.org/10.1145/2884781.2884817Even though TEE provides security guarantees against
strong attacks, few applications employ this technology. En-
hancing existing mobile applications with TEE requires iden-
tiﬁcationofconﬁdentialdataandalltheoperationsassociated
with this data in complex Android applications. Even for
in-house applications, this task can prove daunting in the
context of Java deep class ﬁelds and aliasing.
We propose to fortify existing Android applications by au-
tomatically partitioning them with respect to their data pro-tection needs. The partitioning abstracts Java code segmentsthat manipulate conﬁdential data into candidate Trusted Ap-
plications to be executed in the secure world with higher
privileges, isolated from less privileged malicious or hijacked
applications running in the rich OS.
Ourapproachautomaticallyanalyses, partitions, andtrans-
forms existing applications for deployment of their conﬁden-
tial data and computations on TEE as Trusted Applications.
It automates the laborious and prone-to-human-error tasks
such as detection of application paths that propagate and
operate on conﬁdential data, application partitioning in the
presence of control-dependent secure information ﬂow, extrac-
tion and grouping of conﬁdential fragments of application,
and interfacing between the normal and secure worlds.
The approach is suitable for complex real-life applications
with extended inter-procedural inter-class secure information
ﬂow. The analysis is precise; it extends context- and ﬁeld-
sensitive taint analysis of FlowDroid [25]. The refactored app
preserves application semantics, satisﬁes an unidirectional
TEE execution model, and maintains a minimal Trusted
Computing Base (TCB)1after the addition of Trusted Appli-
cations. Field-sensitive analysis produces safe data handles
(opaquepointers)toenforceinformationhidingwhileallowing
the rich OS to reference conﬁdential data and thereby reduce
the unnecessary communication between the two worlds.
Our automated partitioning framework takes in an appli-
cation binary as input and outputs the source code of the
refactored application with privileged instructions isolated
as static Java methods. Presently, we require the developer
to manually convert these Java methods to Trusted Applica-
tions in native code. But our approach facilitates deploymentof Trusted Applications through automatic generation of aux-
iliary TEE-speciﬁc code for establishing interaction between
normal and secure worlds. In the future, we plan to takeadvantage of available Java to C language translators for
transformation of Java methods to native code.
Our solution guarantees data integrity, i.e., data cannot
be modiﬁed in an unauthorized or undetected manner. Con-
1TCB: a set of components to be trusted to trust a system.
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
   923
Rich OS
TEE Kernel
Trusted Core 
Environment
Trusted 
FunctionsTEE Functional API
 TEE Internal API
 TEE Functional API
TEE Client APITrusted Execution Environment Rich OS Application Environment
HW Secure
ResourcesHW Keys, Secure Storage,
Trusted UI, Crypto 
Accelerators, 
NFC Controller, etc. Client Applications
ureStorage
 ure Storage
Cli A
 li i
Trusted 
Application 
DRM
Trusted 
Application 
Payment
Trusted 
Application 
Corporate
Hardware Platform
Figure 1: TEE system architecture
ﬁdential data and computation on these data reside only
in TEE; conﬁdential data can reside in rich OS only in en-
crypted form. Any data accessed through peripherals under
control of TEE is conﬁdential, while any data returned to rich
OS is not (as it can be leaked to unauthorized users). The
approach allows for controlled release of declassiﬁed informa-
tion. Execution of Trusted Applications in TEE may aﬀect
execution of applications in rich OS; however, execution in
rich OS cannot interfere with the execution in TEE.
We evaluate our approach with real-world Android applica-
tions and micro-benchmarks. Evaluation results highlight the
eﬀectiveness of our approach in automatically partitioning
complex applications and variety of ﬂow situations arising in
Android applications. Trusted Applications maintain a small
TCB size of approximately 200–300 lines of code (LOC) and
low communication overhead. Overall, the approach enables
conﬁdentiality and integrity enforcement through code trans-
formation while substantially reducing development eﬀorts.
2. BACKGROUND
Ourapproachfacilitatesapplicationdevelopmentandtrans-
formation for Trusted Execution Environment built using
ARMTrustZone. ARMTrustZonetechnologyoﬀersasystem-
widesecuritysolution, partitioningthehardwareandsoftware
resources so that they exist in one of two worlds: Secure
worldfor the security subsystem and Normal world for ev-
erything else [16]. This is achieved with a set of protective
measures integrated in the ARM processor core, memory
management unit and the AMBA AXI bus.
Despite wide availability of proprietary implementations
of TEE for platforms with ARM TrustZone hardware exten-
sions, there are few Android applications that leverage this
technology due to the lack of standardization. This issue is
addressed by Global Platform [3] that developed the standard
for managing applications on secure chip technology and a
set of speciﬁcations for the TEE system architecture [11 –13].
The overall TEE system architecture is shown in Figure 1.
TEE oﬀers safe execution of authorized software known
asTrusted Applications (TAs). A TA is composed of TEE
Commands that collectively provide secure services to the
clients of the TA, while enforcing conﬁdentiality, integrityand access rights to the resources and data. Each TA is
independent and protected against unauthorized access from
other TAs, allowing an ecosystem of application providers.
TAs can access security resources and services such as keymanagement, cryptography, secure storage, secure clock,
trusted display and trusted virtual keyboard via the TEE
Internal API . Client applications running in the rich OS can
access and exchange data with TAs via TEE Client API.
Our main contribution is to automatically extract applica-
tion segments to be deployed as TEE Commands in TA. We
automaticallygeneratetheauxiliarycodetoinvokebothTEE
Client API from rich OS and TEE Internal API from TAs
to provide secure services and establish connection between
the trusted and un-trusted application segments.
The deployment of TAs requires careful analysis of the
capabilities and the constraints inherent to the TEE. A
critical constraint imposed by TEE is that TA contributes to
the TCB size, which should be kept as small as possible to
reduce security risks [28]. Thus TA code should be minimized.
Another constraint is imposed by the unidirectional com-
m u n i c a t i o nb e t w e e nc l i e n ta n dT A s .R i c hO Si n i t i a t e st h e
communication whereby the processor switches to the secure
world, executes TEE Command, and ﬁnally switches back to
the normal world. TAs cannot perform callbacks to the client
code. This constraint is especially challenging in the face of
complex control ﬂow, and OS- and UI-related operations in
Android.
3. OVERVIEW
An overview of our approach is shown in Figure 2. The
approach builds on several insights that enable extraction
of minimal code fragments to TEE and semantic-preserving
transformation of the application code.
We highlight the intuition behind our approach using a
real-life example – an open-source application Google Au-
thenticator [4]. The app supports One-Time Password (OTP)
security tokens for two-factor authentication and implements
the HMAC-Based (HOTP) and the Time-based (TOTP)OTP generation algorithms. Google Authenticator uses ei-
ther QR code scanning or manual input to obtain an encoded
security key issued by Google. The key is decoded and used
to calculate a message authentication code (MAC) of a times-
tamp or a counter to generate OTP. The conﬁdential data
in the app includes: security key; user account information;
and program state including program clock and an internal
counter. For our example, the engineer would ﬁrst want to
protect the conﬁdentiality of the security key by protecting
e n t r yp o i n t so ft h ek e y ,i t sm a n i p u l a t i o na n ds t o r a g e .
Manual inspection of the example revealed that the sen-
sitive data and operations are distributed in six medium
to large classes of the application. These are highly UI-
dependent classes with complex control ﬂows owing to the
event-based nature of the app. There are more than one hun-
dred methods and over 1.6K lines of code (LOC) involved
in the propagation of the security key across the classes.
Analysis and protection of code fragments of this size and
complexity require a systematic approach.
The situation is exacerbated by the presence of overlapping
ﬂows of sensitive data from diﬀerent contexts – a security key
coming from a QR code scanning and from manual key entry.
The multiple-entry-point components of an Android app
make it diﬃcult to establish whether extraction of a speciﬁc
code fragment aﬀects diﬀerent application ﬂows. Manual
transformation of such an app to deploy sensitive operations
and data on TEE is not trivial.
924Sources
Sinks*Android app
CFG and tags
Partitioning 
framework
(classify,
context 
analysis)Candidate 
program locations Trusted App
generation
(grouping,
control ﬂow 
analysis,
code synthesis)
1 2 3
//taint_assign
//taint_array$i1 = lengthof $r1;
$i1 = $i1 - $i0;
specialinvoke 
$r0.<java.lang.Object: void <init>()>();Code fragments
4Refactored
Android app
Native
Trusted Apps
Taint 
analysis
(FlowDroid)Program
annotation
Trusted App
translationNative code
wrapping
Figure 2: An overview of the approach
Our approach does not require the engineer to inspect
the complete application to identify critical or non-critical
segments thereby relieving him/her of the laborious and
error-prone task. The approach starts with an automated
context-sensitive taint analysis to track propagation of the
conﬁdential data in the program (phase 1in Figure 2).
It collects the intermediate analysis data and results, and
feeds them to our automated partitioning framework that
generates candidate code segments to be deployed as TEE
Commands of a Trusted Application, and refactors original
app integrating in it TEE Command invocations (phases 2,
3and4). Gray areas in Figure 2 highlight the external (in
phase1) or manually supported components (in phase 4).
The approach builds upon and extends the state-of-the-art
static taint analysis of FlowDroid speciﬁcally designed for
conﬁdential data leak detection in Android applications. It is
lifecycle-aware, and implements context- and ﬁeld-sensitive
information ﬂow analysis building on an IFDS framework [34].
Taint analysis detects conﬁdential data leaks as propa-
gation of “tainted” information through the system fromso-called sourcesthat introduce conﬁdential data into the
system to the sinksthat expose the data to an unprotected
environment. In the scope of our approach, developer is only
required to indicate the sources of conﬁdential data in the
application through program annotations. Any method that
reads and returns conﬁdential data is a source.
In the Google Authenticator example, an engineer needs
to protect the security key entry and manipulation, and in-
dicates two sources – intent.getStringExtra("SCAN_RESULT")
for obtaining QR-code scan result and getEnteredKey() for
getting a manually entered key. These sources will be trans-
formed into a TEE-controlled virtual keyboard service to
manually enter the key, and a secure QR scanner service that
uses a TEE-controlled camera, respectively.
Asinkin our approach is deﬁned for several situations
where conﬁdential data“extends”beyond the control of the
application. In other words, a sink writes conﬁdential data
into a resource that can be accessed or controlled outside the
application. In Android OS such resources include screen,
network connection, storage, etc. In addition, speciﬁc to
Android OS, the data extends beyond the control of the app
when one component (such as Activity) of the app commu-
nicates with another component of the same app, which is
not safe – any data passed to the rich OS can be leaked to
unauthorized users.
ForGoogle Authenticator , the taint analysis identiﬁes that
the security key ﬂows through six application classes; from
the sources to a local app database and then, depending on
the scenario, through an OTP value, to the sinks – a text
ﬁeld to be displayed on a screen, or to the system clipboard.
We then use the analysis results in the application parti-
tioning algorithm represented by phase 2in Figure 2. Thealgorithm implements our observation that in real-world ap-
plications a large portion of statements do not process data,
but only transfer data along secure information ﬂow paths.
For instance, in Google Authenticator,ak e yr e a d - s t o r eﬂ o w
traverses seven methods in three classes, where only onemethod
getEnteredKey() processes the data, while none of
the other methods operates on the conﬁdential data. Our
insight is that such a“transfer”code does not require trans-
formation, can remain in rich OS, and operate on surrogate
data (unique opaque references), while supporting the correct
application control ﬂow and context sensitivity.
Another observation that supports our approach indi-
cates that statements operating on conﬁdential data can be
grouped together when extracted into Trusted Applications.
This is implemented in the phase 3of the approach. For
instance, the core functionality of Google Authenticator for
OTP generation combines a set of transformation operations
that hash the internal app state value, truncate the result
and pad the output value. These consecutive statements can
be grouped and extracted to TEE as a single code segment.
Our approach leverages heuristics for grouping operations
on conﬁdential data.
Finally, our partitioning framework identiﬁes corner cases
where segments of code cannot be automatically extracted
and reports them to the engineer. These include code seg-
ments that manipulate OS-dependent code, conﬁdential op-
erations with overlapping contexts that cannot be isolated
properly, and code fragments control-dependent on conﬁden-
tial data.
By applying our approach to protect the security key
manipulation in Google Authenticator, we extract eight code
fragments (including fragments for key decoding, generation
of message authentication code or MAC, key manipulation
and display) with a total of 35 LOC, suﬃcient to protectthe entire conﬁdential data ﬂow, instead of analyzing and
transforming more than 1.6 KLOC related to the ﬂow in the
original application.
The ﬁnal phase of the approach concerns TEE-speciﬁc
engineering eﬀorts for integrating Trusted Applications into
Android OS and TEE (phase 4in Figure 2). In this phase,
our approach assists an engineer in transforming code frag-
ments to native TEE Commands by automatically generating
code with TEE API calls for establishing communication
and parameter passing between normal and secure worlds.
4. PARTITIONING FRAMEWORK
Our approach starts with taint analysis enhanced with
annotation of taint-propagating statements with contextual
information (Section 4.1). We classify the annotated state-
ments and capture a subset of the statements that will form
a secure partition to be deployed on TEE (Section 4.2). In
this process we identify groups of statements (Section 4.3)
925and resolve corner cases (Section 4.4). To maintain the
ﬂow of data through“transfer”statements (statements that
pass conﬁdential data without modiﬁcation), we substitute
conﬁdential data references with opaque references in the
transformed application (Section 4.5).
4.1 Capturing path and context information
For our partitioning goal, we determine all the statements
that transfer conﬁdential data from one variable to another
in a given context across reachable paths. To that end, we
employ taint analysis and extend it to precisely capture con-
textual information by annotating statements that propagate
taints from sources to sinks. Our analysis intercepts the re-
sults of ﬂow function computation during taint analysis and
registers contextual information including originating context
and the corresponding source of the taint.
We encapsulate taint information for a taint-propagating
statement in a tag t/angbracketleftsource,successor,type /angbracketright, where sourceis an
incoming tainted variable (predecessor ﬂow fact abstraction),
successor is a variable propagating taint further, and typeis
an auxiliary entity describing the taint propagation condition
foragiv ent ypeofstatemen t.W edistinguish27t ypesoftain t-
propagating statements (e.g., ASGN_INSTANCE y=x.f ;ASGN_-
ARRAY_REF y=x[i] ) used to classify transfer and privileged
statements. Sourceand successor ﬁelds of a tag are used
with alias analysis to ensure that we work only with explicit
taint propagation.
It is not suﬃcient to store a single instance tper state-
ment, as a single statement may be traversed by the taint
analysis with more than one source abstraction and in mul-
tiple method contexts. To that end, for each statement we
record a set Tof all tags tthat corresponds to all the distinct
traversals of the statement by the taint analysis.
We assure context-sensitivity of our analysis by collecting
and matching the context of tagged statements with the
contexts (incoming ﬂow fact abstractions) of their enclosing
methods. We deﬁne method context as a set of ﬂow facts
Dproc, such thatfor any tainted statement ninamethod proc
thereisapathedge2sourcedattheexplodedsupergraphnode
corresponding to the entry point sofprocand terminating
at the given statement n:/angbracketleftsprocOf (n),d1/angbracketright→/angbracketleft n, d 2/angbracketright, where
ﬂow fact d1∈Dproc,a n dd 2is the new discovered ﬂow fact
abstraction at n.A s sprocOf (n)is uniquely identiﬁed by n,
we only need d1to identify the path edge. In other words,
diﬀerent sets of ﬂow facts Dprocat the start of the method
denote that the method is reached from diﬀerent sources or
diﬀerent contexts.
We annotate statements that are both reachable in the
taint analysis and have outgoing edges from the incomingﬂow fact abstraction to the other ﬂow facts. To capture
the method context information for each statement n,w e
associate each d∈Dprocwith a subset of tags Tn⊆Tthat
denote taint propagation in a given context.
4.2 Identifying candidate program segments
Our algorithm for selection of candidate program segments
is shown in Algorithm 1. It takes as input an inter-procedural
control-ﬂow graph (ICFG) G, annotated representation of
2Apath edge summarizes the eﬀect of ﬂow functions on a
supergraph from the start node of a method sprocOf (n)to a
statement n[34]. It forms the suﬃx of a realizable tainted
path from the application entry point to the statement.Algorithm 1 Analysis of candidate program segments
Input:S– list of sources; K–l i s to fs i n k s ; G– interprocedural CFG; M–
worklist of methods;
Output: OUT ⊿ output is a map of candidate privileged stmts and
associated input/output taint sets
1:M←∅ ;Mcache←∅
2:forsinSdo
3:M←M∪{methodOf (s)} ⊿Initialize worklist of methods
4:whileM/negationslash=∅do
5:m←pick (M)
6: ifm/∈Mcache then
7: Dm←getMethodContext(m )
8: forstmt inmdo
9: Tstmt←getTags (stmt)
10: ifisAnnotated(stmt) ∧(∃t∈Tstmt :Dm⇒t)then
⊿Process tagged statement with matching method context:
11: OUT←OUT∪{processStatement(stmt,m)}
12: Mcache←Mcache∪m
13: M←M\m
14:procedure processStatement(n,m )
15:Pn←getInTaintSetOf (n,D m)
16:Rn←getOutTaintSetOf (n,D m)
STAGE 1: Extend the worklist
⊿Transfer call statement with a tainted parameter:
17: ifisCallStatement( n)∧(params(n) ∩Pn/negationslash=∅)then
18: M←M∪{getCallee (n,G)} ⊿add callee to the worklist
19: return∅
⊿Returning taint – add callers of m to the worklist:
20: ifisExitStatement (n)then
21: M←M∪{callersOf (m,G)}
22: return∅
⊿Taint ﬂows to a ﬁeld variable – add callers of class methods to the
worklist:
23: if∃r∈Rn∧isFieldVar (r)then
24: c←getDeclaringClass (r)
25: formingetMethodsOf (c)do
26: M←M∪{callersOf (m,G)}
⊿Source stmt taints parameters of enclosing method – add callers of m
to the worklist:
27: if(n∈S)∧(Dm/negationslash=∅)then
28: M←M∪{callersOf (m,G)}
STAGE 2: Record privileged statement
29: ifisPrivilegedStatement(n) then
30: return (n,R n,Pn)
31: else ⊿transfer statements are not added
32: return∅
program statements (nodes) with ﬂow fact information, lists
of sources Sand sinks K. Starting from a method that
contains an invocation of a source, it traces methods that
propagate taint in both“forward”and“backward”directions,
classiﬁes and records candidate conﬁdential statements.
The algorithm maintains a list of taint-propagating meth-
ods M. For each annotated statement in a method on a
taint-propagating path, it ﬁrst detects successive propagator
methods to be added to the worklist ( Stage 1in Algorithm 1).
This is followed by Stage 2, where the annotated statement
is classiﬁed and, potentially, recorded together with the sets
of incoming and outgoing taints.
Taint can be propagated “forward” and “backwards”, as
exempliﬁed in the implementation of taint analysis in Flow-
Droid. Forward analysis follows taint propagation along
the call graph edges, while backward analysis traces taint
propagation through statements at which tainted values are
assigned to the heap, i.e., to ﬁelds or arrays, and searches
backwards for aliases of these values. Our algorithm traces
caller-callee relationships forward, and return, instance ﬁeld,
array, and container assignments backwards (Stage 1 ).
The algorithm descends into methods following taint from
amethodofagivensourceandchecksgeneratedtaintabstrac-
tions. Upon reaching the next method, it resolves whether
tainted abstractions produced from a given source are ex-plicitly propagated to the statements in the body of this
926method. At each stage of the algorithm we use alias analysis
and resolve variable access path to ensure that we consider
only statments with explicit taint propagation. Access path
models taint propagation to object ﬁelds [36] and is symboli-
cally represented as x.f.gor abbreviated as x.fkwith k=2
denoting a path of length two rooted at x. The notation
allows us to split ﬁeld accesses as x.fk=x.fm.fp, where
k=m+p.
We preserve deep ﬁeld-sensitivity in the analysis ensuring
that only statements that directly (explicitly) use the tainted
access path x.fm.fp( a na c c e s sp a t hw i t hm +pﬁelds) or a
longer access path accessible through x.fm.fpare processed
as candidate statements. Statements that only refer to x.fk
where k<(m+p) correspond to implicit taint propagation
that does notrevealconﬁdentialdatareferences, and need not
be considered as far as moving to secure world is concerned.
The following listing highlights the basic cases of explicit
and implicit taint propagation:
// Example 1: Explicit taint propagation :
y=x . f // where x or x . f i s tainted
// Example 2: Implicit taint propagation :
y=x // where x . fis tainted
// Example 3: Implicit taint propagation :
y.f = x // where x . fis tainted
InStage 2of the algorithm, we classify taint-propagation
statements. We distinguish privileged and transfer taint-
propagation statements. Statements that operate on, modify
and multiply instances of conﬁdential data are privileged.
Conversely, transfer statements access conﬁdential data and
propagate it without modifying it. Examples of transferstatements include: method invocations that pass tainteddata into a body of a method through a function param-eter:
update(secret) ; assignment statements of a form x=
secret, where tainted variable secretis not modiﬁed; return
statements in the form return secret .
Privileged statements modify the value of a passed tainted
data and/or derive new instances of tainted data. In Algo-
rithm 1, the classiﬁcation of taint-propagation statementsis incorporated in a condition
isP rivilegedStatement (n)that
expands into the following set of conditions:
(isAssign(n)∧hasOp(getRHS (n)))∨isArrayAssign (n)
∨isConditional (n)∨(n∈S)∨(n∈K)∨isW rapperCallStatement(n )
Each of the clauses helps to identify diﬀerent kinds of priv-
ileged statements. These include arithmetic, bitwise and bit
shift operations on primitive data types to derive new tainted
values ( x = taint + 42 ) and array manipulation operations
(a[i] = taint ). Our algorithm checks these cases with the
conditions isAssign(n )∧hasOp(getRHS (n))and isArrayAssign (n)
respectively. To ensure secure information ﬂow, we classify
statements that assign elements of tainted arrays as privi-
leged ( taint[i] = y ). We also classify source and sink invo-
cations as privileged (clauses (n∈S)and (n∈K)). Condition
isConditional (n)checks for a special case of control-dependent
taint that we discuss in Section 4.4.
Not all operations in object-oriented software can be (or
shall be) traced to the lowest level of manipulation of primi-
tive data types. Such operations include external and library
functions whose code may not be available, standard Java
and Android functionality (for instance, container classes are
commonly used and diﬃcult to analyze), GUI functions, etc.
FlowDroid abstracts taint propagation for these operations
using so-called taint wrapping or explicit taint propagation1 public void process(View v) {
2 String secondPin =p i n c o d e . getText() . toString () ;
3 if(! firstPin .equals(secondPin )){// TEE cmd ()
4 /∗...∗/
5 showErrorView( details ) ; // implicit flow
6 return ;
7 }
8 hideSoftKeyboard(pincode );
9 /∗...∗/
Figure 3: Implicit ﬂow in tiqr pin veriﬁcation
rules. We classify statements involving these operations as
privileged ( isW rapperCallStatement(n )condition).
Note that the same set of statements operates on both
benign and conﬁdential data in diﬀerent contexts or along
diﬀerent execution paths. Our technique provides a feedbackto an engineer that can either indicate that a potential source
of sensitive data is not included in the analysis, or suggest
that overlapping application paths have to be decoupled.
4.3 TEE Command creation by grouping
The two competing requirements imposed by TEE include
minimizationofTCBandminimizationofthecommunication
overhead between app in normal world and a trusted appli-
cation. Extraction of minimal code fragments ensures small
TCB, while extraction of multiple fragments contributes to
increasing the communication overhead. We develop a heuris-tic to ensure appropriate granularity for each TEE Command
through consolidation of temporally close secure partitions.
We consider each privileged statement as a candidate for
being extracted as a distinct TEE Command. Our heuristic
applies intra-procedurally to aggregate privileged statements
within the scope of enclosing methods into groups of state-
ments forming distinct TEE Commands.
We aggregate both consecutive privileged statements and
non-adjacent groups of privileged statements (separated by
other constructs). To that end, we consider sets of variables
t a i n t e dw i t h i nag r o u pa n dt y p e so fs t a t e m e n t st h a ts e p a r a t e
the privileged statements such as assignment orconditional .
We aggregate normal non-privileged statements in the groups,
where the type of separating statements determines whether
we can aggregate the adjacent groups. To preserve the appli-
cation semantics we do not aggregate statements separated
by a conditional statement, nor by Android OS methodssuch as
startActivity(intent) that can aﬀect the control
ﬂow of an app. The group size is thus bounded either by the
enclosing basic block (for groups separated by conditional
statements) or by an enclosing method.
4.4 Control-dependent taint and implicit ﬂows
Conditional expressions controlled by conﬁdential data
may lead to implicit ﬂows – conditional executions implicitly
leaking conﬁdential data by updating non-privileged data in
a conditional structure. Consider an example of an implicit
ﬂow in the code of tiqr, an open source solution for user
authentication on web applications using smart phones [38].
Figure 3 shows an abridged code for an implicit ﬂow in
tiqrin an enrollment pin veriﬁcation activity. Checking
the correctness of a pin entry (conﬁdential data) aﬀects
the control ﬂow of the enclosing method process() —an error
dialog is shown to a user if two pin codes do not match—thus
leaking information about privileged data.
Implicit ﬂows directly aﬀect the granularity of application
partitioning in our approach, and, in some cases, represent
the limits of our automated solution w.r.t. complete pro-
927tection of conﬁdential data. Complete protection requires
deployment of all implicitly tainted data ﬂows as secure TEE
Commands. This includes protection of a complete control
structure or a complete method, if the control structure
contains returnstatements. In the example in Figure 3, a
complete protection of the implicitly tainted data would re-
quire method refactoring to obtain a single method exit point,
and deployment of a code for visualization and handling of
an error dialog as a TEE Command.
In cases when complete protection is possible, we classify
all statements in a conditional structure as privileged, and
extract this group of statements into a single TEE Command.In many cases complete protection is infeasible or detrimental
due to high contribution of an implicitly tainted code to the
TCB size, or due to the presence of a rich OS-dependent
code (e.g., GUI, database access) that cannot be moved to
TEE without breaking application semantics. In these cases,
our technique provides engineer with a feedback highlighting
an implicit ﬂow that has to be protected manually.
It is possible to release an implicitly tainted informa-
tion and support our automated solution by declassifying
a boolean result of a tainted conditional expression and ex-
tracting the condition as a TEE Command invocation. In the
example in Figure 3, expression firstPin.equals(secondPin)
canbesubstitutedforaninvocationofaTEECommandwith-out revealing the conﬁdential data. Yet, out of the three basic
types of control structures such as if-then-else /loop/switch,
only if-then-else is practically amenable to this solution.
4.5 Unique opaque references
To support the preservation of transfer statements in nor-
mal world we provide an opaque reference mechanism to se-
curely transfer references to conﬁdential data within normal
world and from normal to secure world. Opaque references
enable context-sensitive addressing of conﬁdential data from
normal world in cases when privileged statements can be
reached from diﬀerent contexts or with data propagated from
diﬀerent sources.
In our approach an opaque reference is an object refer-
ence that points to a unique Java object of a required type,
w h e r e a so b j e c t ’ su n i q u eh a s hc o d es e r v e sa sak e yt oa
hashtable of actual conﬁdential data references stored in
TEE. We create a reference by allocating a new unique Java
object of a required type. Each opaque reference produced
in a speciﬁc context uniquely identiﬁes this context to TEE.
Wegenerateopaquereferencesoftypesexpectedbyoriginal
implementation thus avoiding compile and runtime errors.
To uniquely identify primitive types, we apply minor code
refactoring on the original application and substitute tainted
primitive variables with objects of primitive wrapper classes.
Opaquereferencesdonotconﬂictwithpolymorphicmethod
invocations. This is because polymorphic method invoca-
tions with tainted base objects are marked as privileged by
our approach and deployed in TEE Commands. Thus, the
runtime type of a base object (its opaque reference) does not
aﬀect the control ﬂow of the application.
5. IMPLEMENTATION
The main components of our system are built as extensions
to the FlowDroid analysis on top of the program analysisframework Soot [27]. Figure 4 shows a general view of the
components of our system. In addition to the extensions, ourframework provides a code generation facility and
Wrapperto
Soot
App Spark
FlowDroidCall graph/
ICFG
Taint ﬂows
(InfoﬂowResults)
Annotated 
ICFGSinks 
(from SuSi)SourcesPartitioning
framework
StmtProcessor
CMDMethodData
Grouping
CodeGenerator
Annotation(.apk)
Trusted AppWrapperRefactored
App
TEE
CommandsTaint analysis
(InfoFlowProblem)
Figure 4: System implementation
Refac tored
Android  appOriginal source  code  
Java-to-C casting
TEE Client setupJNI/TEEC lient A PI:
TEEUser
LibrariesTrustedApp_N
Param  marsha l.
CMD execu tion ...
TA int egration/registra tionTrusted App_1
Param  marsha l.
CMD execu tion Native calls
Figure 5: Generated and transformed source code
generate native TEE Client and Internal API calls used for
registration of trusted application and establishing communi-
cation between a refactored app and trusted applications. A
complete template of generated and modiﬁed source code of
a transformed application is schematically shown in Figure 5.
Our framework works with a developer-generated list of
conﬁdential data sources and a list of sinks. To generate a
list of sinks, we use a machine-learning approach SuSithat
classiﬁes Android sources and sinks extracted from source
code using the semantic and syntactic features [33]. WeuseSuSito generate a list of sinks for specifying standard
shared resources in Android (ﬁles, network connections, etc.)
and the sinks related to app lifecycle that persist and pass
information within an app (between app components) and
between apps. In addition, we treat declassiﬁer methods
(e.g., methods that return encrypted data) as sinks.
5.1 Tagging statements across reachable paths
Our implementation annotates program statements dur-
ing taint analysis using tagging functionality of the Soot
framework. The granularity of our analysis is at the level of
program statements in Jimple intermediate representationused by Soot [37]. We integrate the annotation in the
In-
foflowProblem implementation of FlowDroid and annotate
statements during ﬂow function computation with free-form
labels that implement the Taginterface. Using these tags
we capture path and context information as described in
Section 4.1.
5.2 Partitioning framework
We retrieve the taint analysis results by implementing the
ResultsAvailableHandler interface of FlowDroid and post-
process the statements that we have tagged. The post-
processing implements Algorithm 1 where tagged statements
are classiﬁed, grouped, and transformed. We abstract all
conﬁdential variables and operations on conﬁdential variables
as static methods in a separate program partition shown as
TEE Commands in Figure 4. These static methods are later
transformed to native Trusted Applications with the help
of the Wrapper.T h e Wrapperalso generates the code for the
allocation and association of opaque references to each of the
conﬁdential variable.
For groups of statements, we use their input/output vari-
able sets and generate single TEE Command invocation calls
928for each group. We then automatically substitute the groups
for invocations of TEE Command methods. As a result, we
produce a modiﬁed version of the original application shown
asRefactored App in Figure 4.
5.3 Generation of TEE-speciﬁc code
The transition from extracting secure partition to its de-
ployment as TEE Commands is not trivial and our framework
assists a developer in this process. TEE Commands are frag-
ments of C code that use standard C library available on
TEE, TEE Internal API (including Trusted Storage, Crypto-
graphic operations, Timer API, etc.), and user libraries that
developer can integrate in the TEE code base.
Our approach does not automatically translate the privi-
legedinstructionsfromJavatonativeTAs. Oncetheengineer
transforms the Java priviledged instructions to C code, our
framework automatically generates TEE-speciﬁc code with
Wrapper. In particular, the Wrappergenerates TEE Command
signatures, TEE Internal API invocations for command iden-
tiﬁcation, parameter marshalling, and memory allocation
and access ( Param. marshal. and CMD execution in Figure 5).
On the normal world side of the app, the Wrappergenerates
theTEEClientAPIcodeforinvokingcommandsfromnormal
world. It generates code for instantiating TEE Context —
an abstraction of the logical connection that exists between
the client Android application and TEE. Inside the TEE
Context that the app has created, it initializes TEE Session
— an abstraction of the logical connection between the app
and a speciﬁc Trusted Application identiﬁed by a command
ID. This code is schematically shown in Figure 5 as TEE
Client setup .
Operations in TEE Client setup o p e naT E ES e s s i o no ri n -
voke a command of a Trusted Application. These operations
may carry additional payload, stored inside a TEE Operation
data structure that permits a maximum of four parameters.
To overcome the restriction, we serialize the parameters in-
side the input memory reference and deserialize them in the
Trusted Application command processing function. To sup-
port opaque references, we generate a Hashmap structure on
the trusted partition in TEE that keeps a mapping between
opaque references and actual values in its secure memory.
The deployment of TEE Client API chain of calls inside
an Android app necessitates interfacing native C Trusted
Application invocation with Java Native Interface (JNI) to
be called from the Java code of the app. Thus, we wrap the
c o m m a n di n v o c a t i o nw i t haJ N ICm e t h o d( s h o w na s Native
callsand Java-to-C casting in Figure 5). We automatically
generate respective headers and integrate the generated JNI
C methods as a native library that we generate using Android
Native Development Kit (NDK) [1].
6. EXPERIMENTAL EV ALUATION
We evaluate our approach with six real-world applications
and a set of micro-benchmarks. We demonstrate that our
approach successfully partitions applications with simple and
complex ﬂows of conﬁdential data, and generates TAs that
exhibit low TCB and realistic execution time compared to
the original applications.
6.1 Experimental setup
We explore the capabilities of a commercial Trusted Exe-
cution Environment, SierraTEE [9], on Microvision MV4412
board [6] with ARM Trustzone. The MV4412 board featuresTable 1: Micro-benchmarks – results
SecuriBench Correct/Total DroidBench Correct/Total
Aliasing 5/5 Aliasing 1/1
Arrays 6/6 ArraysAndLists 2/3
Basic 30/40 FieldAndObjectSens 7/7
Collections 11/11 GeneralJava 23/23
DataStructures 5/5 ImplicitFlows 1/2
Factories 3/3 Control-dependent Correct/Total
Inter 11/12 DecisionProtecSimple 9/12
Pred 6/8 DecisionProtec 6/8
StrongUpdates 4/4
Samsung Exynos4412 system-on-chip with ARM Cortex-A9
quad core running at maximum frequency of 1.4GHz, 4 GB
eMMC, and 1 GB LPDDR2 memory. We installed POSIX-
compliant SierraTEE as secure kernel and Android Version
4.0.3, Kernel 3.0.15 as the rich OS.
6.2 Micro-benchmarks
We highlight the applicability and the correctness of the
approach in a variety of situations by applying it to a set
of standard Android benchmarks DroidBench [24] and an
adapted set SecuriBench [30]. These benchmarks are de-
signed to check taint analysis for diﬀerent cases of data ﬂow
arising in secure context. We have adapted SecuriBench to
Android by integrating original Java test cases in Android
applications. We have also extended the test set with two
of our own benchmarks to evaluate the partitioning of appli-
cations with control-dependent ﬂows, where we extract the
decision part of the control structure as a TEE command.
We use FlowDroid taint analysis from April 1, 2015.
Table 1 summarizes the results of automated partitioning
applied to the micro-benchmarks. Partitioned apps have not
been deployed to TEE. The total number of cases of conﬁ-
dential data ﬂow from sources to sinks for each benchmark
obtained through taint analysis is reported ( Total). We then
apply our prototype framework to all these cases, manually
check the partitioning, and report the number of cases where
the resulting transformation is successful ( Correct).
Our approach can successfully partition and transform
86% of the cases across all the benchmarks. The analysis
and transformation time for all the benchmarks is only a few
seconds. We observe that the invalid transformations are due
to the limitations of the current prototype. In particular, the
prototype is not fully supporting transformation of tainted
conditional structures. The largest share of inapplicable
cases (ten cases in Basic of SecuriBench ) map directly to
the extraction of control-dependent taint. Our approach can
extract only some cases of control-dependent taint shownin Table 1. Other cases of taint propagation are covered
exhaustively by our approach. We are implementing minor
modiﬁcation to the prototype to avoid these issues.
6.3 Case studies
We select six widely-used open-source applications as case
studies. Google Authenticator ,tiqr, OpenKeychain, card.io,
Hash it!,a n d Pixelknot provide enhanced security of user
data, communication and/or authentication processes. We
apply our approach to each case study to generate candidate
program partitions. We then transform and deploy the par-
titioned applications to Android OS and SierraTEE. Trusted
Applications are loaded to SierraTEE at compile time.
Google Authenticator. IntroducedinSection3, the Google
Authenticator (GA) generates a six- to eight-digit One-Time
929Passwords (OTPs) that users supply in addition to their
user name and password to log into Google services or other
sites [4]. GA uses a security key provided by Google (scanned
or manually entered) to generate and cryptographically sign
the generated OTPs. The secure partitions extracted by
our approach correspond to reading and signing the secure
key for protecting generation of counter- and timer-based
OTPs. In addition to protecting OTP generation, we have
integrated in secure partition a standard Virtual Keyboard
service of SierraTEE for secure manual key entry, and a QR
code parsing library Quirc C [18] for secure key entry by
means of QR code scanning. To support cryptographic oper-
ations in TA, we replace the javax.crypto.Mac library used
by original app with an OpenSSL counterpart HMAC_*,a n d
conﬁgure SierraTEE to provide OpenSSL library support.
tiqr. tiqris an open source authentication solution for
smart phones and web applications [38]. It is based on
Open Standards from the Open Authentication Initiative
(OATH) [14]. It performs challenge/response authentication
using QR codes. Similar to the GA app, we have integrated ina secure partition the Virtual Keyboard service of SierraTEEfor secure PIN entry, and a QR code parsing library Quirc C.
Our approach extracts four TEE commands for tiqrthat
together constitute an authentication service for logging intoaw e b - s i t e .
CMD1scans a QR code with an encoded authentica-
tion challenge projected by a web-site and returns an opaque
reference to the scanned result. CMD2parses the result and
based on the challenge from the decoded QR code, chooses
user enrollment or authentication thus aﬀecting the control
ﬂow of the app. This is followed by user authentication on
the phone by PIN entry where CMD3is called to enter and
validate the PIN entry using virtual keyboard. Depending
on the control decision in CMD2,CMD4extracts enrollment or
authentication URL from the decoded QR code and sends it
to the server for validation and login authorization.
OpenKeychain. OpenKeychain (OK) [7] is an open-source
digitalkeymanagementappbasedonOpenPGPstandard[20].
It supports encryption, decryption, signature generation, sig-
nature veriﬁcation of ﬁles/text, and provides key exchange
via QR or NFC with secret keys stored on Yubikey devices.
In this case study we protect the generation of 2048-bit
RSA key that we deploy as a TEE Command genRSA,a n d
encryption/signing of the user-provided text with a securely
stored private key signRSA. The app ﬁrst calls genRSAto create
the conﬁdential data – the key. The key is then used in sign
operation (a sink) for text encryption. The two generated
TEE Commands pass an opaque reference to the private key
stored in TEE. The signRSAcommand takes a byte array
input and the opaque reference, encrypts the text in TEE,and returns the encrypted text as a byte array. As in the
case of GA, we have conﬁgured SierraTEE to use OpenSSL
in place of Spongy Castle Android cryptography APIs.
card.io. card.io(CI) is a simple credit card scanning inter-
face for mobile apps [2]. The two generated TEE commands
capture the user input of a card or cvv number on the TEE
side and return it to the normal world.
Pixeknot. Pixeknot (PK) implements steganographic ma-
trix encoding algorithm to help users to hide conﬁdential
text-based messages in photographs and share them across
trusted channels [8]. The four generated commands include:
CMD1: captures the secret message to be hidden in an image
a n ds t o r e do nT E E . CMD2: captures the password/salt usedTable 2: Client code and Trusted Computing Base.
CCF = Conﬁdential code fragment; JNIC = JNI + Java-to-C
code; TCAC = TEE Client API code; TCC = TEE Commandcode; PM&TIAC = Param. marshal.+ TEE Internal API code;LIB = User or external library.
Trusted App
CommandOriginal app Normal World Secure World
Size
(KLOC)CCF
(LOC)JNIC
(LOC)TCAC
(LOC)TCC
(LOC)PM&TIAC
(LOC)LIB
(KLOC)
GA TOTP 3.7 3 49 113 6 218 134.9
GA HOTP - 6 9 95 8 143 134.9
tiqr CMD1 6.1 8 15 121 11 250 1.9
tiqr CMD2 - 1 20 116 6 260 n/a
tiqr CMD3 - 115 5 116 1 40 1.37
tiqr CMD4 - 1 20 116 6 260 n/a
OK genRSA 57 1 31 125 24 210 131.7
OK encRSA - 1 48 125 24 232 131.7
CI CMD1 15 30 5 90 5 210 1.37
CI CMD2 - 33 5 90 5 210 1.37
PK CMD1 5 1 5 90 5 210 1.37
PK CMD2 - 1 5 90 5 210 1.37
PK CMD3 - 1 42 120 76 290 131.7
PK CMD4 - 1 52 130 120 260 131.7
Hash it! 6 4 49 114 6 218 131.7
for encryption and stored on TEE. CMD3: extracts the secret
message on the TEE side, encrypts it using AES-GCM-256,
and returns the encrypted text to the normal world. CMD4:
takes the extracted text as input, decrypts the message on
the TEE side and returns plain text to the normal world.
Hash It! Hash It! generates site-speciﬁc passwords derived
from a secret master key [5]. The extracted TEE command
deploys to TEE a cryptographic message authentication code
(MAC) function to derive site-speciﬁc passwords.
6.3.1 Developer Effort and TCB size
Table 2 summarizes the contribution of the commands to
the Trusted Computing Base (TCB) size in SierraTEE and
the changes to the client code.
As we can see from Table 2, the original code size for
our case-study applications is quite large ranging from 3.7
KLOCto57KLOC.However, theconﬁdentialcodefragments
identiﬁed by our analysis engine are pretty small ranging
from 1 LOC to at most 115 LOC for a command. It is clear
that the developer would need to spend signiﬁcant eﬀort to
manually identify these code fragments — a burden that is
completely relieved through automation.
The columns under Normal World correspond to the com-
ponents required to integrate TEE commands with an An-
droid app. We have highlighted these components schemat-
ically in Figure 5 using thick borderlines. For each TEE
command, an app needs JNI code to pack and unpack pa-
rameters from Java to C and back ( JNI Java-to-C ). The normal
world also includes TEE command setup using TEE Client
API and TEE client headers that hold structure deﬁnitions
for command invocation parameters. TEE Client API code
is automatically generated by our framework.
The components under Secure World contribute to TCB
size. These include parameter marshalling ( Param. marshal. )
and command setup using TEE Internal API, command reg-istration code (a constant of 100 LOC for each command, not
shown in Table 2), the core code that performs the function
corresponding to the command ( TEE Command code ), and
user/external libraries registered to TEE. These contribute
to at most 380 LOC to TCB for an application, which is
really small compared to the 41.6KLOC TCB of Sierra OS.
930Table 3: TEE Command execution time. Mean val-
ues with standard deviations in parentheses.
Trusted App
CommandOrig. app
exec.JNI copy
exec.TEE Command
exec.
Concat 13μs( 0 . 9 ) 9μs( 1 5 ) 9μs (10)
Multiply 140μs (10) 30μs (11) 30μs (10)
GA TOTP 640μs (107) 40μs( 4 ) 85μs (18)
GA HOTP 600μs (28) 40μs( 3 ) 70μs (20)
tiqr CMD1 14μs( 3 ) 13μs( 1 ) 250μs (35)
tiqr CMD2 21μs( 6 ) 13μs( 1 ) 220μs (10)
tiqr CMD3 2.5μs (0.4) 0.8μs (0.04) 78μs( 5 )
tiqr CMD4 19μs( 4 ) 10μs( 0 . 5 ) 220μs (14)
OK genRSA 2.8 s (1.8) 0.6 s (0.3) 0.5 s (0.3)
OK encRSA 0.8 s (0.04) 0.034 s (0.0009) 0.1 s (0.001)
CI CMD1 3.8μs (0.8) 0.7μs (0.03) 78μs( 5 )
CI CMD2 3.2μs (0.7) 0.6μs (0.06) 79μs( 5 )
PK CMD1 3.2μs (0.5) 0.9μs (0.06) 86μs( 6 )
PK CMD2 4.6μs (0.4) 0.7μs (0.03) 80μs( 5 )
PK CMD3 1.99 s (0.0001) 26μs( 3 ) 280μs (34)
PK CMD4 2.11 s (0.0002) 27μs( 5 ) 267μs (32)
Hash it! 557μs (61) 27μs( 5 ) 71μs (10)
Consider, for instance, tiqr CMD3in Table 2. The original
conﬁdential code fragment with 115 LOC involves two ac-
tivity classes for reading and verifying user pin entry. The
corresponding TEE version reads the pins using virtual key-
board and compares them using 1 LOC. The contribution to
TCB mostly comes from parameter marshalling (40 LOC)
and external library usage (1.37 KLOC Virtual Keyboard ser-
vice) reaching 1.41 KLOC. Nevertheless, most of generated
TEE Commands contribute more lines of code in C than their
original conﬁdential code fragments in Java. For instance,
CMD4inPixelknot substitutes a single message decryption
statement in Java with 120 LOC on TEE.
Consideration of transfer statements gives us up to two
orders of magnitude reduction in LOC in TEE Command Code
compared to the pure taint analysis that would extract all
the tainted statements potentially breaking app semantics,
and contributing to high TCB.
Note that the only code that has to be manually written
by the developer is JNI Java-to-C in normal world and TEE
Command Code in secure world. This is because we do not
handle automated translation from Java to C for TEE Com-
mands. Fortunately, both these components require minimal
eﬀort as can be seen from the table.
6.3.2 Runtime Overhead
In addition to the real-world case studies, we generate two
simple applications to evaluate the runtime overhead of our
approach. The ﬁrst application Concatis a trivial TA that
takes two characters as input and returns the concatena-
tion of the two to accentuate the communication overhead
between two worlds. The second application Multiply multi-
plies two 10 ×10 integer matrices and thus can diﬀerentiate
computation time in TEE from communication overhead.
W ec o m p a r et h ee x e c u t i o nt i m eo fT E Ec o m m a n dw i t ht h e
e x e c u t i o nt i m eo ft h eo r i g i n a lJ a v ac o d ea n dw i t haJ N IC
alternative. The JNI C code is executed in Android OS; but
not deployed to TEE. We perform ten measurements for each
case and present in Table 3 mean end-to-end execution time
of single iterations of user scenarios followed by standard
deviations in parentheses.
For individual command invocations, computation in TEE
is up to an order of magnitude faster than the original ap-plication for pure computation ( Concat, Multiply, GoogleAuthenticator ). This is not surprising, because execution of
C code is usually faster than execution of Java code. For
OpenKeychain, Hash it! ,a n d Pixelknot CMD3and CMD4,t h e
TEE version takes less time than original app because cryp-
tographic operations are much faster in SierraTEE (C code)
compared to Android. We have conﬁrmed this by running
the JNI C copy of the original code that shows comparable
execution time to TEE. Services using virtual keyboard or
reading/writing persistent objects ( tiqr, card.io, Pixelknot
CMD1and CMD2)t a k eu pt oa no r d e ro fm a g n i t u d em o r et i m e
in TEE than in the original application, because they require
extra setup and checks on TEE.
Most of the overhead from the complete TEE solution is
the penalty for setting up TEE context, establishing TEEsession, and switching between normal and secure world.
A context/session represents a logical connection between
a client application and a speciﬁc TA. Multiple TEE com-mands can be issued inside an established session for the
client application to access services provided by the TA. A
command invocation in a session adds only 100μs overhead
on an average for switching between two worlds, while each
new TEE context/session adds an average of 6.5ms overhead.
These overheads get added over the computation time shown
in Table 3. Note that since our example applications are
reactive software and hence non-terminating, they do not
have any concept of end-to-end delay.
7. THREATS TO V ALIDITY
We highlight the limitations of the presented approach and
threats to validity of our results.
As usual, with a diﬀerent set of subjects the size of the
TCB could be diﬀerent. The underlying taint analysis in our
approach, has some limitations in determining ﬂow through
recursive data structures as well as limited precision in dis-
tinguishing elements of arrays. In reporting experimental
results in Table 1, the Totalscore diﬀers from the results
reported in the FlowDroid work [25]. The diﬀerence is due toour framework using a more recent version of FlowDroid and
due to our adaptation of the benchmarks that aﬀected the
precision of FlowDroid analysis when applied to bytecode
i n s t e a do fs o u r c ec o d e .
There are also some limitations in transformation and par-
titioning of our approach. Despite contextual sensitivity, the
approach does not handle situations when the same method
is tainted from diﬀerent contexts with diﬀerent combina-
tions of tainted method parameters. Currently, whenever we
replace privileged statements with TEE Command invoca-
tions, we check that the tainted method-parameter-context
combination is unique.
Finally, in generation of opaque references, not all objects
of a required type can be generated. The approach instanti-
ates classes with public constructors, whereas singleton or
Android system classes, for instance, limit class instantiation.
8. RELATED WORK
TrustZone and TEE infrastructure. TrustZone security
extensions isolate security-sensitive application logic fromrich OS and other applications, and thus protect an appli-cation by deploying conﬁdential partition to TEE. Mainchallenges in adopting TrustZone-based solutions include
realizing approaches that maintain a small TCB size and
enable seamless application development [23,39]. Recent
931eﬀort to address these challenges includes general solutions
in standardization of TEE interfaces and protocols [31,32,40],
and custom solutions for TrustZone infrastructure [17,35].
TofacilitateseamlessapplicationdevelopmentMarforioetal.
implement secure enrollment protocols for TrustZone en-
abling service providers to associate the identity of a user
to her device [31,32]. Approach by Winter et al. develops a
platform emulation tool based on QEMU platform emulator
to help developers to design for TrustZone emulating ARM
TrustZone platforms [40].
TZ-RKP approach implements a safe security monitor
leveraging TrustZone architecture [17]. The monitor providesa real-time OS kernel protection by routing privileged system
functions through secure world for examination. In contrast
to our analysis-based approach that focusses on protection
of individual applications and data, the TZ-RKP approach
c a nb es e e na sal o w - T C Bs y s t e ml e v e ls o l u t i o n .
A notable alternative to TEE is a custom Trusted Lan-
guage Runtime (TLR) [35]. TLR is an infrastructure to
run .Netapplications using TrustZone extensions to isolate
security-sensitive application logic. Provided with a parti-tioned application, TLR is able to interpret intermediate
.Netcode in its runtime engine. High-level language support
on secure world ensures ease of development and veriﬁcation
on TLR. However, considering the restrictions of TLR that
cannot access peripherals, the usability gain is uncertain
since only small code fragments shall be deployed to secure
world to preserve small TCB.
Program partitioning. To the best of our knowledge,
there are no solutions available to secure Android applica-
tions for integration with TEE using automatic partitioning.
However, there is a body of related work tackling program
partitioning of other types of applications either for security
policy enforcement in distributed computing or for privilege
separation [15,19,21,22,26,29,41,42]. Existing solutions at-
tempt to compartmentalize application into partitions with
diﬀerent privileges, reduce the attack surface, minimize TCB
and communication between parts of the applications with
diﬀerent privileges, and maintain secure information ﬂow.
Partitioning for privilege separation. Partitioning for
privilege separation prevents malicious exploitation of appli-
cations that typically run with maximum privilege by seg-
menting them into smaller components that can be granted
minimal necessary privileges [15,19,26,41]. A ProgramCut-
tercollects information ﬂow and privilege levels of program
functions from dynamic traces keeping track of the size of
program fragments [41]. It then applies mincutalgorithm
to partition program into function-level components with
diﬀerent privileges to minimize their size and communication.
A related approach Privtrans requires expert knowledge to
specify privileged functions and variables [19]. It annotates
the source code and partitions source program into only two
components: a privileged program (the monitor) and anunprivileged program (the slave). Privtrans does not deal
with complex features of the C language such as pointer
arithmetic, function pointers and unrestricted type casting.
The approach aims at minimizing the privileged code size,
but not the slave-monitor communication overhead.
Virtual Application Partitioning enablesdeveloperstoman-
age application attack surface by protecting the most exposed
partition [26]. The approach automatically partitions soft-
ware based on the intrinsic property of user authentication.Analysis of the application binary enables ranking of poten-
tial risks at speciﬁc points of application and selection of
corresponding protection measures. The approach helps to
reduce costs by enabling protection on demand.
SeCageapproach by Liu et al. combines static and dynamic
analyses to partition C applications w.r.t. sensitive data,and provides a supporting memory protection mechanism
enabling a vitalization-based application protection [29]. Theextracted partition is possibly incomplete aiming at reductionof TCB by protecting only the most commonly used sensitive
functions discovered with dynamic analysis.
Partitioning for secure distributed computation. An-
other set of language-based techniques protects conﬁdential
data during computation in distributed systems containing
mutually untrusted hosts [42]. Using annotations, informa-
tion ﬂow is constrained between trusted/non-trusted hosts
through appropriate automatic partitioning. The approach
was extended to tackle the challenge for secure web and
database applications [21,22]. These systems synthesize a
good host assignment for each ﬁeld or statement, and rely
on type checking that lacks the context- and ﬂow-sensitivity
of data ﬂow analysis. To alleviate the issue, systems are en-
riched with a client and a server runtime system to manage
synchronization between the two programs, and correct for
the assumptions of the static analysis. This increases the
amount of code deployed to the secure server side. Moreover,
these approaches allow for control of the program execution
to be passed in both directions, whereas in a typical TEE
setting, most of the program is executed in rich OS, and only
small computations are invoked as commands in TEE.
9. CONCLUSIONS
In recent years we have witnessed the growth of technolo-
gies to support hardware enforced application protection. In
this paper we propose to harness this technology without
incurring high development costs by automatically adapting
existing applications to the new technology. The proposed
approach requires only a binary package of the original ap-
plication, leverages state-of-the-art taint analysis, and auto-
matically identiﬁes and extracts code fragments relevant to
manipulation of conﬁdential data. These fragments, groupedand transformed, are deployed to Trusted Execution Environ-ment with the help of our approach. The only non-automatedstep of the technique is the translation of the code fragments
from Java to C. However, because the fragments are small,
this manual eﬀort is not overwhelming. The proposed ap-
proach provides ﬁne-grained protection of real world Android
applications. It produces a small Trusted Computing Base
(TCB), incurs an adequate overhead, and enables application
developers to adapt existing Android apps to take advantage
of existing secure hardware / virtualization technologies.
Acknowledgments
We thank Mingyuan Gao, Nithilan Meenakshi Karunakaran,
and Manh Dung Nguyen for help with experimental setup.
This research was partially supported by – (i) Singapore
MoE AcRF grant T1 251RES1314, (ii) a grant from DSO
National Laboratories, and (iii) the National Research Foun-
dation, Prime Minister’s Oﬃce, Singapore under its National
Cybersecurity R&D Program (TSUNAMi project, Award
No. NRF2014NCR-NCR001-21) and administered by the
National Cybersecurity R&D Directorate.
93210. REFERENCES
[1] Android ndk toolset.
https://developer.android.com/ndk/index.html.
[2] card.io. https://www.card.io.
[3] Global platform device speciﬁcations. http:
//www.globalplatform.org/speciﬁcationsdevice.asp.
[4] Google authenticator. https:
//github.com/google/google-authenticator-android.
[5] Hash it! http://android.ginkel.com/.[6] Microvison co., ltd. microvision mv4412 board. http:
//www.boardset.com/products/products
v4412.php.
[7] Openkeychain. http://www.openkeychain.org/.[8] Pixelknot.
https://guardianproject.info/apps/pixelknot/.
[9] Sierraware: Sierratee trusted execution environment.
http:
//sierraware.com/open-source-ARM-TrustZone.html.
[10] The MITRE Corporation: List of common
vulnerabilities and exposures for all versions of Google
Android. http://www.cvedetails.com/product/19997/
Google-Android.html?vendor \
id=1224/.
[11] GlobalPlatform Device Technology TEE Client API
Speciﬁcation Version 1.0 GPD SPE 007. Technical
report, July 2010.
[12] GlobalPlatform Device Technology TEE Internal API
Speciﬁcation Version 1.0 GPD SPE 010. Technical
report, December 2011.
[13] GlobalPlatform Device Technology TEE System
Architecture Version 1.0 GPD SPE 009. Technical
report, December 2011.
[14] Initiative for open authentication.
http://openauthentication.org/speciﬁcation, 2015.
[15] D. Akhawe, P. Saxena, and D. Song. Privilege
separation in html5 applications. In Presented as part
of the 21st USENIX Security Symposium (USENIX
Security 12) , pages 429–444, Bellevue, WA, 2012.
USENIX.
[16] ARM. Arm security technology – building a secure
system using trustzone technology. arm technical white
paper. http://infocenter.arm.com/help/topic/com.arm.
doc.prd29-genc-009492c/PRD29-GENC-009492C
trustzone security whitepaper.pdf, 2009.
[17] A. M. Azab, P. Ning, J. Shah, Q. Chen, R. Bhutkar,
G. Ganesh, J. Ma, and W. Shen. Hypervision across
worlds: Real-time kernel protection from the arm
trustzone secure world. In Proceedings of the 2014
ACM SIGSAC Conference on Computer and
Communications Security , CCS ’14, pages 90–102, New
York, NY, USA, 2014. ACM.
[18] D. Beer. Quirc. https://github.com/dlbeer/quirc/.
[19] D. Brumley and D. Song. Privtrans: Automatically
partitioning programs for privilege separation. In
Proceedings of the 13th Conference on USENIX
Security Symposium - Volume 13 , SSYM’04, pages
57–72, 2004.
[20] J. Callas, L. Donnerhacke, H. Finney, D. Shaw, and
R. Thayer. RFC 4880: OpenPGP Message Format. Rfc
4880, RFC Editor, November 2007.
[21] A. Cheung, S. Madden, O. Arden, and A. C. Myers.
Automatic partitioning of database applications. Proc.
VLDB Endow. , 5(11):1471–1482, July 2012.[22] S. Chong, J. Liu, A. C. Myers, X. Qi, K. Vikram,
L. Zheng, and X. Zheng. Secure web applications via
automatic partitioning. In Proceedings of Twenty-ﬁrst
ACM SIGOPS Symposium on Operating Systems
Principles , SOSP ’07, pages 31–44, New York, NY,
USA, 2007. ACM.
[23] J.-E. Ekberg, K. Kostiainen, and N. Asokan. Trusted
execution environments on mobile devices. In
Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security, CCS ’13, pages
1497–1498, New York, NY, USA, 2013. ACM.
[24] C. Fritz, S. Arzt, and S. Rasthofer. Droidbench test
suite. http://sseblog.ec-spride.de/tools/droidbench/.
[25] C. Fritz, S. Arzt, S. Rasthofer, E. Bodden, A. Bartel,
J. Klein, Y. le Traon, D. Octeau, and P. McDaniel.
Flowdroid: Precise context, ﬂow, ﬁeld, object-sensitive
and lifecycle-aware taint analysis for android apps. In
Proceedings of the 35th ACM SIGPLAN conference onProgramming language design and implementation
(PLDI), 2014.
[26] D. Geneiatakis, G. Portokalidis, V. P. Kemerlis, and
A. D. Keromytis. Adaptive defenses for commodity
software through virtual application partitioning. In
Proceedings of the 2012 ACM Conference on Computer
and Communications Security , CCS ’12, pages 133–144,
2012.
[27] P. Lam, E. Bodden, O. Lhot´ ak, and L. Hendren. The
Soot framework for Java program analysis: aretrospective. In Cetus Users and Compiler
Infrastructure Workshop, Galveston Island, TX,
October 2011.
[28] B. Lampson, M. Abadi, M. Burrows, and E. Wobber.
Authentication in distributed systems: Theory and
practice. ACM Trans. Comput. Syst. , 10(4):265–310,
Nov. 1992.
[29] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia.
Thwarting memory disclosure with eﬃcient
hypervisor-enforced intra-domain isolation. In 22th
ACM Conference on Computer and Communications
Security, Denver, Colorado, US, October 2015.
[30] B. Livshits. Securibench micro test suite. http://suif.
stanford.edu/˜livshits/work/securibench-micro/.
[31]
C. Marforio, N. Karapanos, C. Soriente, K. Kostiainen,
and S. Capkun. Secure enrollment and practicalmigration for mobile trusted execution environments.
InProceedings of the Third ACM Workshop on Security
and Privacy in Smartphones & Mobile Devices ,S P S M
’13, pages 93–98, New York, NY, USA, 2013. ACM.
[32]C. Marforio, N. Karapanos, C. Soriente, K. Kostiainen,
and S. Capkun. Smartphones as practical and securelocation veriﬁcation tokens for payments. In
Proceedings of the Network and Distributed System
Security Symposium , NDSS’14, 2014.
[33] S. Rasthofer, S. Arzt, and E. Bodden. A
machine-learning approach for classifying and
categorizing android sources and sinks. Network and
Distributed System Security Symposium (NDSS), 2014.
[34] T. Reps, S. Horwitz, and M. Sagiv. Precise
interprocedural dataﬂow analysis via graph reachability.
InProceedings of the 22Nd ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages ,
933POPL ’95, pages 49–61, New York, NY, USA, 1995.
ACM.
[35] N. Santos, H. Raj, S. Saroiu, and A. Wolman. Using
ARM TrustZone to Build a Trusted Language Runtime
for Mobile Applications. In Proceedings of the 19th
International Conference on Architectural Support for
Programming Languages and Operating Systems,
ASPLOS ’14, pages 67–80, 2014.
[36] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and
S. Guarnieri. Andromeda: Accurate and scalable
security analysis of web applications. In Proceedings of
the 16th International Conference on Fundamental
Approaches to Software Engineering , FASE’13, pages
210–225, Berlin, Heidelberg, 2013. Springer-Verlag.
[37] R. Vallee-Rai and L. J. Hendren. Jimple: Simplifying
java bytecode for analyses and transformations.
Technical report, Sable Research Group, McGill
University, 1998.
[38] R. M. van Rijswijk and J. van Dijk. tiqr : a novel take
on two-factor authentication. In Proceedings of LISA
’11: 25th Large Installation System AdministrationConference, pages 81–97, Boston, MA, 2011. USENIX
Association.
[39] A. Vasudevan, J. M. McCune, and J. Newsome.
Trustworthy Execution on Mobile Devices, volume 8 of
SpringerBriefs in Computer Science. Springer, 2014.
[ 4 0 ]J .W i n t e r ,P .W i e g e l e ,M .P i r k e r ,a n dR .T ¨ogl. A
ﬂexible software development and emulation framework
for arm trustzone. In Proceedings of the Third
International Conference on Trusted Systems ,
INTRUST’11, pages 1–15, Berlin, Heidelberg, 2012.
Springer-Verlag.
[41] Y. Wu, J. Sun, Y. Liu, and J. S. Dong. Automatically
partition software into least privilege components using
dynamic data dependency analysis. In 2013
IEEE/ACM 28th International Conference on
Automated Software Engineering (ASE), pages 323–333,
Nov 2013.
[42]S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers.
Secure program partitioning. ACM Trans. Comput.
Syst., 20(3):283–328, Aug. 2002.
934