SRCIROR: A Toolset for Mutation Testing of C Source Code and
LLVM Intermediate Representation
FarahHariri
University ofIllinois at Urbana-Champaign
Illinois, USA
hariri2@illinois.eduAugust Shi
University ofIllinois atUrbana-Champaign
Illinois, USA
awshi2@illinois.edu
ABSTRACT
We present SRCIROR (pronounced “sorcerer“), a toolset for per-
forming mutation testing at the levels of C/C++source code (SRC)
and the LLVM compiler intermediate representation (IR). At the
SRClevel, SRCIROR identifiesprogramconstructsformutationby
pattern-matching on the Clang AST. At the IR level, SRCIROR di-
rectly mutates the LLVM IR instructions through LLVM passes.Our implementation enables SRCIROR to (1) handle any program
that Clang can handle, extending to large programs with a mini-
mal overhead, and (2) have a small percentage of invalid mutants
thatdonotcompile. SRCIROR enablesperformingmutationtesting
using the same classes ofmutationoperatorsat boththeSRC and
IR levels, and it is easily extensible to support more operators. In
addition, SRCIROR can collect coverage to generate mutants only
forcoveredcodeelements.OurtoolispubliclyavailableonGitHub
(https://github.com/TestingResearchIllinois/srciror ). We evaluate
SRCIROR on Coreutilssubjects. Ourevaluation shows interesting
differences between SRC and IR, demonstrating the value of SR-
CIRORinenablingmutationtestingresearchacrossdifferentlevels
of coderepresentation.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
KEYWORDS
SoftwareTesting, MutationTesting
ACM Reference Format:
Farah Hariri andAugust Shi.2018.SRCIROR:AToolset forMutation Test-
ing of C Source Code and LLVM Intermediate Representation. In Proceed-
ingsofthe2018 33rdACM/IEEEInternational ConferenceonAutomatedSoft-ware Engineering (ASE ’18), September 3–7, 2018, Montpellier, France. ACM,
New York, NY, USA, 4pages.https://doi.org/10.1145/3238147.3240482
1 INTRODUCTION
Software testing is commonly used in industry for quality assur-
ance.Onekeychallengeofsoftwaretestingistoproperlyevaluatethe quality of test suites in terms of their bug-finding capability.
Permission to make digital or hard copies of all or part of this work for personal or
classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed
for profit or commercialadvantage and that copies bear this notice and the full cita-
tion on thefirstpage. Copyrightsfor components of thiswork owned byothers than
ACMmustbehonored.Abstractingwithcreditispermitted. Tocopyotherwise,orre-
publish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/or afee. Requestpermissionsfrompermissions@acm.org.
ASE ’18,September 3–7,2018,Montpellier, France
© 2018 Associationfor Computing Machinery.
ACM ISBN978-1-4503-5937-5/18/09 ...$15.00
https://doi.org/10.1145/3238147.3240482A test suite with a large number of tests, or that achieves a high
statement or branch coverage, does not necessarily have a high
bug-finding capability.
Mutationtestingiswidelyusedinresearchtoevaluatethequal-
ityoftestsuites[ 13],andithasrecentlystartedtogainmomentum
in industry as well [ 17]. Mutation testing proceeds in two steps.
Thefirststepismutantgeneration.Amutantisamodifiedversion
oftheoriginalprogramobtainedbyapplyingamutationoperator.
Amutationoperatorisaprogramtransformationthatintroducesa
smallsyntacticchangetotheoriginalprogram.Thesecondstepof
mutationtesting is to run the test suite and determine which mu-
tants are killed. A mutant is killed if the tests behave differently,
typically in their pass/fail status, when run on the mutant com-paredagainst running thetestsontheoriginalprogram.Mutation
testing produces a measure of quality of the test suite called the
mutationscore. The mutationscore ofa given test suite is the per-centageofmutantskilledbythattestsuiteoutofthetotalnumber
ofgenerated mutants.
Multiple mutation testing tools were developed that perform
mutation at different levels. Traditional mutation testing is per-
formedatthelevelofsourcecode( SRC),e.g.,for
C[4–8,11,12],and
Java[14,15]. More recently, mutation testing has been applied at
thelevel ofcompiler intermediate representation ( IR), e.g., forthe
LLVMIR[ 10,18–20].However,thecurrentlyavailabletoolsdonot
meetallresearchers’ needs.First,someofthetoolsapplytransfor-
mations on the text of the source code without performing any
parsing[5,9].Suchtoolsgenerate alargenumberofmutantsthat
do not compileand can waste a lot ofthe mutant generation time.
Theyalsocanmissgeneratingsomemutantsastheyrelyonsyntac-
ticmatchingtodetectmutationopportunities.Second,sometools
implement their own parsing trees and, therefore, may not sup-portalllanguageconstructsandwouldfailtogeneratemutantsoneven moderately sized programs. Lastly, there does not exist one
framework that supportsmutationat different levels (SRC and IR)
allowing fair comparison and easy extension for supportingmoreoperators.
Wepresent SRCIROR (pronounced“sorcerer“), atoolsetforper-
forming mutation testing at the levels of
C/C++source code (SRC)
and the LLVM compiler intermediate representation (IR). At theSRC level, SRCIROR identifies program constructs by performing
pattern-matchingontheClangAST. SRCIROR thenappliestherel-
evant mutationoperatorsonthefound constructs.At theIR level,SRCIROR finds the instructions that should be mutated using an
LLVM pass and then directly mutates those IR instructions. Our
implementation enables SRCIROR to (1) handle any program that
Clang can handle, extending to large programs with a minimal
overhead, and (2) have a small percentage of invalid mutants that
860
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Farah Hariri and August Shi
do notcompile. SRCIROR enables performing mutationtesting us-
ingthesamemutationoperatorclassesatboththeSRCandIRlev-
els,andSRCIROR iseasilyextensibletosupportmoreoperators.In
addition, SRCIROR can collect coverage to generate mutants only
forcoveredcodeelements. SRCIROR isopen-sourceandispublicly
available at https://github.com/TestingResearchIllinois/srciror .
We evaluate SRCIROR onfivesubjectsfromCoreutils.Coreutils
isalibraryofcommandlineutilitiesforUnixthatiswidelyusedinresearch.WearethefirsttoperformmutationtestingontheentirecodeofourfivesubjectsforbothSRCandIRlevels.Ourevaluation
shows interesting results demonstration the value of SRCIROR in
enabling mutationtesting research across different levels.
2 MUTATION TOOLS IMPLEMENTATION
Inthissectionwedescribethemutationoperatorsin SRCIROR.W e
then describe in detail theimplementation of SRCIROR’s SRC and
IRmutantgenerationcomponents.Finally,wedescribeusingcode
coverage tofilteroutmutantsformutationtesting.
2.1 Mutation Operators
We define four mutation operators in common at both SRC and
IR levels. A similar set of mutation operators is often used in theexistingmutationtoolsforthe
Clanguage,e.g.,byAndrewsetal.[ 4,
5]orJia and Harman [ 11,12].Thesefourmutationoperatorsare:
●AORreplaces every arithmetic operatorfrom the set { +, -,
*, /, %}w i t hadifferentarithmetic operatorfromthesame
set. Atthe SRC level, the AOR classalso includes replacingthe arithmetic assignment operators from the set {
+=, -=,
*=, /=, %= } with other operators of that same set. Replac-
ing arithmetic assignment operators does not apply at theIRlevelwheresuchassignment operatorsarealreadytrans-
latedintosimpler instructions.
●LCRreplaces every logical connector with another logical
connector.AttheSRClevel,itreplaceseveryoperatorfrom
theset oflogical operators{
&&, ||}, theset ofbitwise oper-
ators {&, |, ˆ}, and the set of logical assignment operators
{&=, |=, ˆ= }w i t hadifferentoperatorfromthesame set.At
the IR level, only bitwise operators are applicable, because
the other two sets are translated into different instructions
(potentiallybitwiseoperatorsorconditional branches).
●RORreplaces every relational operator with another rela-
tionaloperator.AttheSRClevel, itreplaces every operator
fromthe set of relational operators{ >, >=, <, <=, ==, != }
with adifferentoperatorfrom the same set. It also replaces
booleanconditionsinconditionalstatementsandloopswiththeir negations; specifically, it replaces
ewith!efor every
expressionfromtheset{ if(e), while(e), for(...;e;...) }.
At the IR level, the operatorinvolves replacing every IR in-
struction from the set { eq, ne, ugt, uge, ult, ule, sgt,
sge, slt, sle }w i t hadifferentpredicate fromthe same set.
●ICRreplacesevery integer constant cwithavaluefromthe
set {-1,0,1,-c, c-1,c+1}∖ {c}.
2.2 Source-level Mutant Generation Tool
We implement our source (SRC)-level mutant generation tool as
a source-to-source transformation tool based on Clang (version
Figure 1: SRC Mutator Architecture
Figure 2: IR Mutator Architecture
3.8.1).ThearchitectureofourimplementationisshowninFigure 1.
We perform the SRC mutation in three steps. First, we use Clang
to parse the input files and build an abstract syntax tree (AST).
Second, we use AST Matchers [2]( c o m b i n e dw i t h LibTooling [1])
to search for candidate mutation locationsin the AST. Finally, for
each of these candidates, we use these same two libraries to mod-
ify the Clang AST, performing a source-to-source transformation
thatmutatestheASTbasedonthemutation,generatingadifferentmutatedsourcefilefor eachmutation.
SRCIROR supports generating mutants in different files for a
project. This feature is an essential characteristic of a mutationtool, as code is generally organized in multiple files and directo-
ries according to its functionality. For example, a significant part
ofthefunctionalityusedbytheCoreutilstoolsisdefinedinautility
directory that gets compiled into a shared library
libcoreutils.a
that links to the executable. Failing to generate mutants for code
fromlibcoreutils.a decreases the confidence in the value of the
mutationtestingresults.
2.3 IR-level Mutant Generation Tool
ForIR-levelmutantgeneration, SRCIROR usestransformationpasses
in the LLVM compiler infrastructure (LLVM version 3.8.1) to gen-
erate mutants(Figure 2).First,we useClangwiththeflags -S
-emit-llvm to generate LLVM bitcode files representing the code.
Next,weapplytwoLLVMpasses.ThefirstLLVMpasstakesinthe
bitcodefile and generates as outputthe list of mutationopportuni-
ties;amutationopportunityisdefinedbyalocation(specificLLVM
instruction and one of its operands) that can be mutated and themutation type (the mutation operator and the value to substitute
the operand for). The second LLVM pass takes as input a bitcode
861
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. SRCIROR: A Toolset for Mutation Testing for C Source Code and ... ASE ’18, September 3–7, 2018, Montpellier, France
file and the mutation opportunity to apply, and then actually ap-
pliesthemutation,creatinganewmutatedbitcodefileforeachmu-
tation.Finally,themutatedbitcodeispassedalongtothecompilerto resume the original compilation, resulting in a final compiled
mutant.Notethatthesecondstepofgeneratingmutantsiscarried
by the user; a simple loop is needed to go over each mutation op-portunitygeneratedinthefirststepandfeeditinto SRCIROR along
withtheoriginal bitcodefiletoperformthemutation.
For both SRC and IR, we create Python wrapper scripts that
are called by the project build scripts instead of Clang. The wrap-
perscriptsimplementthesameinterfaceasClang,performingthe
sameoperationsasdescribedearlierforSRCandIRmutations,andthen delegating theremaining compilationcommands backtothe
actual Clang. For example, in the case of SRC, the Python script
callsthemutatoronthecommandsthat have sourcefilesin them.
InthecaseofIR,thePythonscriptusesthecommandsalongwith
some inserted flags to first generate LLVM bitcode, call the mu-
tator LLVM passes on the bitcode, and then finish compiling themutatedbitcodebydelegatingbacktotheoriginalClangcompiler.
2.4 Incorporating Coverage
While we can run tests against all the mutants generated at the
SRCandIRlevel tocomputethemutationscore,thetestsmaynotnecessarily cover some of the generated mutants. If tests do notcover certain mutants, then those tests cannot kill such mutants.
While it is important for a developer using the mutation testing
toolto know when some mutantsare not even covered, as it indi-catesaweakness inthetestsuite,sometimesadeveloperwantsto
know just how good the test suite is on the mutants already cov-
ered. Furthermore, checking only mutants killed of the mutantscovered leads to faster mutationtesting as fewer mutants are run.
Weallowforusingcodecoverage tofilteroutmutantsthatshould
not berunwithtests(Figures 1and2).
AttheSRC-level, weruntestsfirstoncodeinstrumentedusing
llvm-cov gcov tocollectsimplecoverage. Thenwefeedinthecov-
ered lines asinput tothemutator;thepattern-matchinglogic willonly generate mutantsof covered lines.
At theIR-level, thereisno existing toollike
llvm-cov gcov that
collects code coverage of IR instructions. As such, we implementour own code coverage tool at the IR level as a new LLVM pass.
The pass iterates through each LLVM instruction while keeping
a counter, giving a unique count for each instruction. At each in-struction, the pass inserts a call to a helper coverage instrumen-
tation method. When the tests are executed on the instrumented
code, executing the call records the instruction count, which isthen written into a trace file. This trace file represents the cover-
ageattheIR-level. InthefirstLLVMmutatorpassthatdetermines
whatinstructionstomutate,thepasscountstheinstructionsinthe
same way as in the coverage pass, and then the pass onlyoutputsa mutation for an instruction if its count matches an instruction
countfrom theinput coverage information.
3 EVALUATION
3.1 Splitting Coreutils Tests
We perform an evaluation of using SRCIROR on programs from
Coreutilsversion6.11.ThetestsformostprogramsinCoreutilsaremanually written scripts that invoke the program multiple times,
whereeachinvocationconceptuallyrepresentsadifferenttest.Such
scripts are not ideal for evaluating mutation testing. For example,
many of the programs have test script files that contains tests. If
we were to execute such a test script for a given program directly
ontheoriginalandmutatedversionsoftheprogram,itwouldexe-cutealltestsandreportafailureifany ofthetestsfails.Therefore,
we would just know if a mutant is killed or not,but we would not
g e tt h ef u l lt e s t - m u t a n tm a t r i x ,i . e . ,w ew o u l dn o tk n o wf o re a c htest-mutantpairwhetherthattestkillsthatmutant.Ifonewereto
useamutationtestingtooltoevaluatethequalityofatestsuite,it
is enough to know what mutants are killed by any test in the testsuite. However, it is often desirable to obtain the full test-mutant
matrix because it can facilitate a further analysis of mutants nor-
mally needed in mutation research, e.g., computation of minimalmutant sets [ 3]. To get the full matrix for the programs, we man-
ually analyzed all the test script files for the Coreutils programsused in our evaluation, and we split each long script into severalshorterscriptsthat eachrunsanindividual test.
Wesplitlongtestscriptsintoshortertestscriptsthroughacom-
bination ofautomatedtransformations(whenever it waspossible)and manual changes. To ensure that our process for splitting the
test scripts does not affect the validity of the results, we executed
all shorter test scripts on their respective programs to verify thateach of them gives the expected result on the original code. More
precisely, executing a test on a program in Coreutils can give one
of the three possible results: PASS, FAIL, or SKIP. The tests are
skipped during execution when their precondition state is not es-
tablished, which can happen for a number ofreasons. One reason
thatwe commonlyfound for skippedtestswasthat they required
to be run with the root privilege level. Another reason was that
a few tests required the presence of more than one disk partition
mounted on the filesystem. These tests report the SKIP result for
the original program as well as for any mutant generated for the
program. Further,weinspectedallteststhatweregettingskipped
after our splitting of long test scripts into shorter test scripts. Formostcases,thetestwasalsooriginallyskippedinthelongerscriptduetounavailableprivileges orresources, whichis thecorrectbe-
havior. For a few cases, the test started being skipped after our
splitting.Wecarefullyinspectedthelattercasesandfoundoutthatsome tests were getting skipped because their setup was getting
skipped—this setup usually sets some test environment variables
and is performed when all tests are run by invoking
make check
fromthetop-mosttestdirectory;ourshorterscriptsdonotinvoke
teststhatway.However,themostimportantaspectisthatthesame
testsareskippedconsistently,andthustheydo notaffectmutation
testinganalyses usingtheartifact.TheCoreutilsartifacts(splitted
testsalong withthescriptswe wroteto perform thesplitting) are
available at
http://mir.cs.illinois.edu/farah/artifacts/coreutils-artifact.tar.gz .
3.2 Results
Tables1and2showthenumbersofmutantsgeneratedby SRCIROR
that are covered by tests at the SRC and IR levels, respectively
(columns“#M”). SRCIROR generates many moremutantsat the IR
level thanattheSRClevel, 15944versus4261,respectively.
862
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Farah Hariri and August Shi
Table 1: Number of SRC mutants generated and the num-
ber/percentage of them that are equivalent/duplicated
Program
 Tests
Overhead
 SRC
#M
#E
E%
#D
D%
#NEND
factor
 31
 32.14
 364
12
3.3
37
10.2
 315
head
 85
 54.06
 946
43
4.5
123
13.0
 780
seq
 37
 72.96
 989
40
4.0
123
12.4
 826
stat
 68
150.96
 1619
72
4.4
246
15.2
 1301
unexpand
 38
 18.02
 343
8
2.3
37
10.8
 298
Overall
 259
 328.14
 4261
175
4.1
566
13.3
 3520
Table 2: Number of IR mutants generated and the num-
ber/percentage of them that are equivalent/duplicated
Program
 Tests
Overhead
 IR
#M
#E
E%
#D
D%
#NEND
factor
 31
 20.92
 599
60
10.0
64
10.7
 475
head
 85
157.38
 2611
174
6.7
312
11.9
 2125
seq
 37
431.02
 4441
362
8.2
595
13.4
 3484
stat
 68
562.50
 7127
375
5.3
934
13.1
 5818
unexpand
 38
 36.53
 1166
 54
4.6
214
18.4
 898
Overall
 259
1208.35
 15944
1025
6.4
2119
13.3
12800
Table 3: Raw mutation scores and NEND mutation scores
Program
 SRC
 IR
Raw
NEND
 Raw
NEND
factor
 52.5
 53.0
20.4
 24.8
head
 44.0
 44.7
8.0
 9.7
seq
 56.4
 58.5
16.2
 20.1
stat
 16.4
 16.5
5.1
 5.9
unexpand
 65.0
 66.4
18.3
 22.6
Overall
 38.8
 40.1
10.2
 12.2
We also compute the number/percentage of equivalent/dupli-
catedmutantsforeachoftheSRCandIRmutantsseparately.Equiv-
alent mutants are mutants that are the same as the original pro-gram. Duplicated mutants are mutants that are equivalent to one
another but not necessarily equivalent to the original program.
All equivalent mutants should be ignored, while all but one mu-
tant from an equivalence class of duplicated mutants should beignored. The remaining mutants are then what we consider non-
equivalent,non-duplicated (NEND) mutants [ 10].Wedetectequiv-
alent/duplicated mutants using trivial compiler equivalence [ 16].
We show these number/percentage of equivalent/duplicated mu-
tantsandthenumberofNENDmutantsforSRCandIRinTables 1
and2.EvenwhenconsideringonlyNENDmutants,therearemany
more mutants atthe IR level than atthe SRC level.
Table3showstherawmutationscores(considering allcovered
mutants)andthemutationscoreswithonlyNENDmutantsattheSRC and IR level. We see that mutation scores at SRC tend to be
higher than scores at IR. These differences show the value of thetoolinenablingresearchthatasksinteresting questionsaboutmu-
tationtestingat thedifferent levels.
Lastly,tounderstandtheefficiencyof SRCIROR,wemeasurethe
timeoverheadformutantgenerationatboththeSRCandIRlevels.If thecodeis builtfrom scratchfor every mutant,theoverhead ofSRCIROR wouldbeequaltothenumberofmutantsgenerated, i.e.,
4261X for SRC and 15944X for IR. However, one can use various
optimizations to improve SRCIROR’s performance. In our evalua-
tion,weuseasimplesetupthatperformsincrementalcompilationbetween mutants. Columns marked “Overhead” in Tables 1and2
s h o wt h eo v e r h e a d sa st h er a t i oo ft h et i m en e e d e dt og e n e r a t e
all mutants for a given program to the time needed to perform
a clean build of that program (without mutation). The overhead
varies from 18.02X to 562.50X. Overall, SRCIROR incurs an over-
head of 328.14X for 4261 SRC mutants and 1208.35X for 15944 IRmutants;overheads aremuchlower thanthenumber ofmutants.
4 CONCLUSIONS
We present SRCIROR, atoolsetfor performingmutationtesting at
theC/C++source and LLVM IR levels. We evaluate SRCIROR on a
subsetofprogramsfromCoreutilsandhowSRCandIRcomparein
terms of number of mutants generated, mutation score, and num-berofequivalentandduplicatedmutants. SRCIROR opensthedoor
for performing mutation testing research for
C/C++programs on
multiplelevels and comparingthem.
ACKNOWLEDGMENTS
We thank Darko Marinov and the anonymous reviewers for their
constructivefeedback.ThisworkispartiallysupportedbytheNSFgrantsCCF-1409423and CCF-1421503.
REFERENCES
[1] Libtooling. http://clang.llvm.org/docs/LibTooling.html .
[2] Matching the Clang AST. http://clang.llvm.org/docs/LibASTMatchers.html .
[3] Paul Ammann, MarcioEduardoDelamaro,and Jeff Offutt. Establishingtheoret-
icalminimal setsof mutants. In ICST,pages21–30,2014.
[4] James H. Andrews and Amin Alipour. MutGen tool.
https://github.com/alipourm/cmutate.
[5] J.H. Andrews, L.C. Briand, and Y. Labiche. Is mutation an appropriate tool for
testing experiments? In ICSE, pages402–411,2005.
[6] MarcioEduardo Delamaroand Jose Carlos Maldonado. Proteum tool for muta-
tion testing of C programs. https://github.com/magsilva/proteum.
[7] MárcioEduardoDelamaroandJoséCarlosMaldonado. Proteum—Atoolforthe
assessmentof testadequacy forCprograms. In PCS,pages79–95,1996.
[8] RahulGopinath,AminAlipour,IftekharAhmed, CarlosJensen,andAlexGroce.
Measuringeffectivenessof mutant sets. In ICSTW, pages132–141,2016.
[9] AlexGroce,JosieHolmes,DarkoMarinov,AugustShi,andLingmingZhang. An
extensible,regular-expression-basedtoolformulti-languagemutantgeneration.
2018.
[10] Farah Hariri, August Shi, Hayes Converse, Sarfraz Khurshid, and Darko Mari-
nov. Evaluatingtheeffects ofcompileroptimizations onmutationtestingatthecompiler IR level. In ISSRE, pages105–115, 2016.
[11] Yue Jia. Milu: A higher order mutation testing tool.
https://github.com/yuejia/Milu.
[12] Yue Jia and Mark Harman. MILU: A customizable, runtime-optimized higher
ordermutationtesting tool for the fullClanguage. In TAIC PART ,pages94–98,
2008.
[13] YueJiaandMarkHarman. Ananalysisandsurveyofthedevelopmentofmuta-
tion testing. TSE,37(5):649–678, 2011.
[14] RenéJust. TheMajormutationframework:Efficientandscalablemutationanal-
ysisforJava. In ISSTA, pages433–436,2014.
[15] Yu-Seung Ma, Jeff Offutt, and Yong-Rae Kwon. Mujava: a mutation system for
Java. InICSE,pages827–830, 2006.
[16] Mike Papadakis, Yue Jia, Mark Harman, and Yves Le Traon. Trivial compiler
equivalence:A largescaleempiricalstudyof asimple,fastand effectiveequiva-lent mutant detection technique. In ICSE,pages936–946, 2015.
[17] Goran Petrovic and Marko Ivankovic. State of mutation testing at google. In
ICSE SEIP ,2018.
[18] EricSchulte. llvm-mutate. http://eschulte.github.io/llvm-mutate/.[19] Eric Schulte. Neutral Networks of Real-World Programsand their Application to
Automated Software Evolution . PhD thesis,Universityof NewMexico,2014.
[20] Marcelo Sousa and Alper Sen. Generation of TLM testbenches using mutation
testing. In CODES+ISSS, pages323–332,2012.
863
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. 