Identifying and Quantifying Architectural Debt
Lu Xiao, Yuanfang Cai
Drexel University
Philadelphia, PA, USA
{lx52,yc349}@drexel.eduRick Kazman
University of Hawaii &
SEI/CMU
Honolulu, HI, USA
kazman@hawaii.eduRan Mo, Qiong Feng
Drexel University
Philadelphia, PA, USA
{rm859,qf28}@drexel.edu
ABSTRACT
Our prior work showed that the majority of error-prone
source les in a software system are architecturally con-
nected. Flawed architectural relations propagate defects
among these les and accumulate high maintenance costs
over time, just like debts accumulate interest. We model
groups of architecturally connected les that accumulate
high maintenance costs as architectural debts . To quantify
such debts, we formally dene architectural debt , and show
how to automatically identify debts, quantify their mainte-
nance costs, and model these costs over time. We describe
a novel history coupling probability matrix for this purpose,
and identify architecture debts using 4 patterns of architec-
tural aws shown to correlate with reduced software qual-
ity. We evaluate our approach on 7 large-scale open source
projects, and show that a signicant portion of total project
maintenance eort is consumed by paying interest on ar-
chitectural debts. The top 5 architectural debts, covering a
small portion (8% to 25%) of each project's error-prone les,
capture a signicant portion (20% to 61%) of each project's
maintenance eort. Finally, we show that our approach re-
veals how architectural issues evolve into debts over time.
CCS Concepts
Software and its engineering !Software architec-
tures;
Keywords
Software Architecture, Software Quality, Technical Debt
1. INTRODUCTION
Technical Debt (TD) is a metaphor to describe the long-
term consequences of shortcuts taken in coding activities to
achieve near-term goals [7]. Debts are introduced when de-
velopers opt for \quick and dirty" solutions, but postpone
longer-term improvements. Our prior work [26] showed that
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ICSE ‚Äô16, May 14-22, 2016, Austin, TX, USA
c2016 ACM. ISBN 978-1-4503-3900-1/16/05. . . $15.00
DOI: http://dx.doi.org/10.1145/2884781.288482 2most error-prone les in a project are architecturally con-
nected through awed relations. These awed relations can
propagate defects among large numbers of les, and incur in-
creasing maintenance costs over time. A awed architecture
relation is similar to a debt in that it accumulates penalty ,
in terms of maintenance costs, the same way a debt accu-
mulates interest. We call such aws architectural debts .
Although the concept of TD has been inuential, it has
until now largely been a metaphor. The dierences with real
(nancial) debt are crucial. A real debt always starts from
aprincipal , and grows with a certain interest rate. How to
quantify the principal and interest rate in software invest-
ments has been a challenge. Our goal is to advance the
understanding and management of architectural debt, a type
of technical debt, by quantifying it.
We dene the concept of architectural debt (ArchDebt)
as a tuple consisting of: 1) a group of architecturally con-
nected les, and 2) a model of the maintenance cost growth
for such les. Based on this denition, we contribute an
approach to automatically locate architecture debts. Once
we locate each debt we model its growth using regression
models. Our approach to identify ArchDebt has two parts.
We rst create a novel history coupling probability (HCP)
matrix to manifest the probability of changing one le when
another le is changed. Then we index le groups through
the lens of 4 patterns of prototypical architectural aws that
have been shown to correlate with reduced software quality
[21], namely hub, anchor-submissive ,anchor-dominant, and
modularity violation .
Given an ArchDebt, we quantify the maintenance costs
(approximated by bug-xing churn) spent on the les in-
volved in the debt. From the costs incurred in each release,
we can model the growth trend using linear, logarithmic,
exponential or polynomial regression models. These models
represent coherent scenarios of stable, reducing, increasing,
and uctuating maintenance interest rates respectively. Fi-
nally, we rank the identied architectural debts according to
the maintenance costs they have accumulated.
We have evaluated our approach using seven Apache open
source projects, and identied many instances (between 74
and 204) of ArchDebts in each project. The results show
that a signicant portion (from 51% to 85%) of the main-
tenance eort in each project is consumed by paying inter-
est on these debts, and that non-trivial portions (20% to
61% ) of the maintenance eort is consumed by just ve
ArchDebts, which represent a small portion of all error-
prone les. Our evaluation also revealed that about half of
the identied debts t linear regression models, indicating a
2016 IEEE/ACM 38th IEEE International Conference on Software Engineering
488
steady increase in the penalty that these debts incur. About
1/3, 1/10, and less than 1/10 of all debts t polynomial,
logarithmic, and exponential models respectively, indicating
the interest rate trends of these debts can vary drastically.
Finally, we qualitatively analyzed the design problems be-
hind debts, and how these evolve over time.
This approach will not only enable an analyst to precisely
locate architectural debts, but also rank and prioritize them,
so that informed decisions can be made on if, where, and how
to refactor. Although the ArchDebt detection and modeling
approaches we propose only work retrospectively when the
penalty has already accumulated, this approach can be used
to monitor the formation of a debt [23], and thus prevent it
from growing early in the software development process.
2. BACKGROUND
We now introduce the key concepts our work is based on.
Design Rule Space. In our prior work [26] we proposed
a novel architectural model| Design Rule Space (DRSpace)|
based on the Baldwin and Clark's design rules [2]. Build-
ing upon existing denitions of software architecture [3], we
characterize a software architecture as a set of overlapping
DRSpaces, each reecting a unique aspect of the architec-
ture. Each DRSpace is a subset of a system's source les and
some kind of relationships (dependencies) among these les.
Each DRSpace has one or more \leading le(s)", which all
other les in the DRSpace depend on, directly or indirectly.
The leading les are usually the les with architectural im-
portance, such as interfaces or abstract classes, which we
callDesign Rules . The relations within a DRSpace may be
structural|such as \ Implement ", \Extend ", \Call"|or re-
lations may be based on history coupling between source
les|indicating the number of times two les changed to-
gether as recorded in the project's revision history.
There are numerous DRSpaces in any non-trivial soft-
ware system, e.g., each dependency type forms a DRSpace:
les connected by\ Extend "and\ Inherit "relationships form
aninheritance DRSpace, and les that are coupled in the
project's revision history form an evolution DRSpace. We
created an architecture root detection algorithm that com-
putes the intersection between DRSpaces and the project's
\error space"|the set of error-prone les in a system [26].
We showed that the majority of the error-prone les are
concentrated in just a few DRSpaces, suggesting that these
error-prone les are not islands{they are architecturally con-
nected [26]. Furthermore, we showed that these DRSpaces
frequently contain architectural issues (aws) that, we claim,
are the root causes of error-proneness.
Design Structure Matrix (DSM). We use a DSM [2]
to represent a DRSpace. Each element in the DSM is a
source le, and each cell represents the relationships between
the le on the row and the le on the column. For exam-
ple, Figure 5 is a DRSpace with leading le ColumnParent .
Each cell shows the structural dependencies | \ implement ",
or \dp" | between the le on the row and the le on the
column, followed by the conditional probability of change
propagation. In the original DRSpace [26], we used the
number of times two les changed together in the project's
revision history to represent their history dependency. In
this paper, we replace this count with a probability . For
example, cell[6,2] contains \ Implement ", meaning that the
le on row 6, CassandraServer , implements the interface
on row 2, Cassandra ; cell[2,6] contains \48%", meaning thatwhen Cassandra changes, there is a 48% probability that
CassandraServer will change with it.
Architecture Issues. Our recent work [21] dened, im-
plemented, and validated an algorithm for detecting recur-
ring architectural issues in software systems, which we call
hotspot patterns , including: 1) unstable interface , where an
inuential le changes frequently with its dependents in the
revision history; 2) modularity violation , where structurally
decoupled les frequently change together in the project's re-
vision history; 3) unhealthy inheritance , where a super-class
depends on its sub-class or where a client class depends on
both a super-class and its sub-class; 4) cyclic dependency,
where a set of les forms a dependency cycle. In the 9
projects we examined, we observed a strong correlation be-
tween the number of aws a le has and: 1) the number
of bugs reported and xed in it, 2) the number of changes
made to it, and 3) the amount of eort spent on it (in terms
of committed lines of code to x bugs and to make changes).
3. DEFINITION AND IDENTIFICATION
In this section, we dene architectural debt (ArchDebt)
and present an ArchDebt identication approach.
3.1 ArchDebt DeÔ¨Ånition
We formally dene the software architecture of a system,
implemented at release r, as a set of overlapping DRSpaces:
SoftArch r=fDRSpace 1; DRSpace 2; :::; DRSpace ng(1)
where nis the number of DRSpaces, each revealing a dif-
ferent aspect of the architecture. For example, each depen-
dency type can form a distinct DRSpace [26]. We dene an
Architectural Debt ( ArchDebt )as a group of architecturally
connected les that incur high maintenance costs over time
due to their awed connections, as follows:
ArchDebt =< FileSetSequence; DebtModel > (2)
The rst element, FileSetSequence, is a sequence of le
groups, each extracted from a dierent project release:
FileSetSequence = (FileSet 1; FileSet 2:::; FileSet m)(3)
where mis the number of releases that ArchDebt impacts,
mR, the number of project releases. FileSet r,r= 1:::m
is a connected le group in release r. The number of les in
each FileSet may vary in dierent releases.
The second element, DebtModel is a formula capturing
the growth, i.e. interest rate, of the ArchDebt, in the form
of maintenance costs for FileSetSequence.
3.2 ArchDebt IdentiÔ¨Åcation
Given this denition of ArchDebt , we rst identify FileSet 
Sequence, and then build a DebtModel to capture the \in-
terest rate" based on the costs FileSetSequence has in-
curred. There are numerous DRSpaces in each release, and
numerous debt candidates (le groups) in each DRSpace.
We illustrate our process of searching for a FileSetSequence
on analogy with searching for web pages on the internet,
consisting of the following steps as shown in Figure 1:
1) Crawling: this step collects a subset of DRSpaces from
each SoftArch r, r from 1 to R, similar to crawling and
collecting web pages.
2) Indexing: this step identies (indexes) a specic le
group, FileSet, from each DRSpace selected in the rst
489Input  ‚ë°Indexing: 
Identify debt 
candidates 
R1 to  
Rn 
 
Revision 
Log 
Bug Report  Crawl  
Titan  ErrorSpace 
R1 to Rn  AS 
AD HB 
MV 
Input file  
Input files  New approach 
Prior approach Output files  
Output  ‚ë†Crawling: 
Select 
DRSpaces 
SoftArch 
R1 to Rn  SelDRSpace 
R1 to Rn  
HCPGen  Index  
HCP  
R1 to Rn  Candidate 
FileSetSeq ArchDebt  
DebtModels  
   
‚Ä¶ ArchDebt_x  
<FileSetSeq, DebtModel > Ranked  
ArchDebs  
 
   
‚Ä¶ Source 
Code Repo 
Und 
Commercial Tool  ‚ë¢Modeling: 
Compute debt 
model 
Model  ‚ë£Ranking: 
Identify costly 
ArchDebt 
Rank  
ArchDebt_1 
<FileSetSeq, DebtModel > ArchDebt_1 <FileSetSeq, DebtModel > 
ArchDebt_x  
<FileSetSeq, DebtModel > 
Und Figure 1: Approach Framework
step, then locates sequences of related FileSets in dierent
releases as a FileSetSequence.
3) Modeling: we measure the maintenance costs incurred
by each sequence of FileSet r. An ArchDebt is dened as a
FileSetSequence whose costs increase over time.
4) Ranking: we rank the severity of each ArchDebt ac-
cording to the amount of maintenance costs they have accu-
mulated in the project's evolution history.
3.2.1 Crawling: Selecting DRSpaces
We rst dene the set of error-prone les in a particular
release ras an error space: ErrorSpace r=ff 1; f2; :::; f ng,
where le fi,i= 1:::n, was revised to x bugs at least once
from release 1 to release r. According to this denition:
ErrorSpace ris a subset of ErrorSpace r+1. For each release
r, we select a set of DRSpaces from SoftArch r, each led by
a le in ErrorSpace r, and form a SelectedDRSpace set as
the output of Crawling :
SelectedDRSpace r=Crawling (SoftArch r; ErrorSpace r)
(4)
Each DRSpace in SelectedDRSpace ris led by an error-
prone le in ErrorSpace r, and contains other les that de-
pend on the leading error-prone le. If there are nles in
ErrorSpace r, there are nDRSpaces in SelectedDRSpace r.
3.2.2 Indexing: Identify ArchDebt Candidates
Next we nd the FileSetSequences that are debt candi-
dates. Files in such a sequence must have changed together
in the project's revision history. We rst calculate a his-
tory coupling model|HCP matrix|and then we lter le
groups using 4 indexing patterns .
HCP Matrix.
In our prior work [26], we used a DSM to model history
coupling : each cell in the DSM displays the number of times
two les changed together. To manifest how a change to
a le inuences other les, we propose a new model: the
history coupling probability (HCP) matrix . Although
each column and row in a HCP still represents a le, we use
each cell to record the conditional probability of changing the
le on the column, if the le on the row has been changed,
i.e., the odds of changes propagating from le to le.
0.7 0.7*0.3  (<thred=0.3 , discard)  
 
1*0.7  
 
 
 
A 
 B 
 D  
 
     Commit1: A, B 
     Commit2: A, B      Commit3: B, D  
     Commit4: A, C   
 
    
                                                                                      ‚ë†      
      
 
    
‚ë° 
                                                                                      ‚ë¢ 
     
 
      ‚ë£ 
     
 
      
 
 0.7*0.3 (discard)  
 
          1*0.7 
 
 
 1*0.7*0.3  (discard)  
 
1*0.7 *0.7  
 
 
 0.7 
0.7 0.3             1 0.3             1  0.7 
 
0.7 1 1/1 
 
1/3 3 
3 3 1 3 1/1  
 
1/3 
 
 
 2/3  
 
2/3 
 
 
 
B 
 D 
 A 
 B 
A 
 C 
D 
A 
B 
C 
B 
 A 
 C 
C 
 A 
 B D 
A 
B 
C 0.3    1  
D 0.7    1  
0.5 
 
 
0.7 
 
 
 Figure 2: Generate HPC Matrix
Figure 2 shows an example of the creation of a HCP. Part
1 shows 4 les A,B,C, and D, that change in 4 com-
mits: Commit1fA,Bg(Commit1 changes AandB), Com-
mit2fA,Bg, Commit3fB,Dg, and Commit4fA,Cg. First, we
compute the pair-wise conditional change probabilities for
any pair of les. For example, the probability of changing
leA, given that le Chas changed, denoted by ProbfAjCg,
is the number of times AandCchange in the same com-
mits divided by the total number of changes to C. Similarly,
ProbfCjAgis the number of times AandCchange in the
same commits divided by the total number of changes to A.
Hence, ProbfAjCgis 1=1, indicating that Aalways changes
with C, and ProbfCjAgis 1=3, indicating a probability of
1=3 that Cchanges with A. In this relation, we label C
asdominant andAassubmissive because ProbfAjCg>
ProbfCjAg. We compute the probabilities for every pair of
les and get the graph in part 2 of Figure 2.
As shown in part 3, we compute the N-Transitive-Closure
of the graph in part 2 to identify history dependencies be-
tween les that change in distinct but potentially related
commits. The conditional probabilities between les with-
out direct connections are the multiplication of the probabil-
ities on the transitive links. For example, les BandCnever
change in the same commits, but they change with Ain
Commit1 and Commit4. Hence, there are transitive history
connections between BandC.ProbfBjCgisProbfBjAg*
ProbfAj Cg=0.7*0.3=0.21, and ProbfCjBgisProbfCjAg*
ProbfAj Bg=1*0.7=0.7. We only keep links with probabili-
ties of at least 0.3 to avoid keeping weak connections. In case
there are multiple paths between two les, we keep just the
highest probability. Part 4 shows the N-Transitive-Closure,
stored in an adjacency matrix called a HCP matrix. For each
release rof a project, we compute a HPC matrix ( HPC r),
consisting of les in ErrorSpace r, from the bug-xing revi-
sion history between release 1 to release r.
Indexing Patterns.
Now we compute the interaction between SelectedDRSpaces r
andHCP rto nd FileSet rfrom each release. We observe
that, in most cases, even though the number of les in a
FileSet may vary in dierent releases, they are always con-
490nected to at least one le over all releases. For example, if
more child classes are dened to extend a parent class over
time, the group of les connected to the parent class grows.
We thus call this one special le the Anchor le of the group,
denoted as le a. We thus dene FileSet ras:
FileSet r=fa; M rjMr=fmi:ifrom 1 to ngj
8mi2Mr; miarchitecturally connected with ain release rg
(5)
where FileSect r2FileSetSequence, ais the anchor le,
and the les contained in Mrmay change with release r.
We call Mrthe member les of ain release r.
We also dene two boolean expressions to describe the
relationships between two les (x andy) in release r:Sr(x!
y) and Hr(x!y).Sr(x!y) means ystructurally depends
onxin release r.Hr(x!y) means xis dominant and yis
submissive in their co-changes between release 1 to release
r. In HCP r,HCP r[x; y] is the probability of changing y,
given xhas changed. If HCP [x; y]> HCP r[y; x], then x
is dominant and yis submissive. HCP [x; y] =HCP r[y; x]
means xandyare equally dominant. Formally:
In release r,
Sr(x!y) is true if y2DRSpace rx, otherwise it is false
Hr(x!y) is true if HCP [x; y]>=HCP r[y; x]
^HCP [x; y]6= 0, otherwise it is false
(6)
For any pair of aandmin aFileSet r, we identify 4 re-
lationships: Sr(a!m),Sr(m!a),Hr(a!m), and
Hr(m!a). Each relationship could be either true or false.
We enumerated all 16 combinations of these 4 relationships.
The 4 combinations with Hr(a!m) and Hr(a!m)false
are irrelevant to our analysis (as we need history to measure
debt). From the remaining 12 possible combinations, we de-
ned 4 indexing patterns|Hub, Anchor Submissive, Anchor
Dominant, Modularity Violation . Each pattern corresponds
to prototypical architectural issues that proved to correlate
with reduced software quality [21].
Given any anchor le a2ErrorSpace r, we can calculate
itsFileSet rausing SelectedDRSpace randHCP rthrough
the lens of the 4 indexing patterns:
Hub|the anchor le and each member have structural
dependencies in both directions and history dominance in at
least one direction. The anchor is an architectural hub for
its members. This pattern corresponds to cyclic dependency,
unhealthy inheritance (if the anchor le is a super-class or
interface class), and unstable interface (if the anchor le has
many dependents). Informally such structures are referred
to as \spaghetti code", or \big ball of mud". A FileSet ra
with anchor le ain release rthat matches a hubpattern is
denoted by HBFileSet raand is calculated as:
HBFileSet ra=Index HB(a; SelectedDRSpace r; HCP r)
=fa; M rj8m2Mr; Sr(a!m)^Sr(m!a)
^(Hr(a!m)_Hr(m!a))g
(7)
Figure 3 is a Hub FileSet for the PDFBox project, an-
chored by PDAnnotation . The dark grey cell represents the
anchor le (cell[4,4] for PDAnnotation ). The cells showing
the historical and structural relationships between member
les and the anchor le are in lighter grey. In this HBFile-
Set, the anchor le structurally depends on each member
1 2 3 4 5 6 7
1PDA*Line (1) ,100% ,100% dp,100% ,100% ,100% ,100%
2PDA*SquareCircle ,100% (2) ,100% dp,100% ,100% ,100% ,100%
3PDA*FileAtt* ,100% ,100% (3) dp,100% ,100% ,100% ,100%
4PDA* dp,50% dp,50% dp,50% (4) dp,50% dp,50% dp,50%
5PDA*Text ,100% ,100% ,100% dp,100% (5) ,100% ,100%
6PDA*Link ,100% ,100% ,100% Extend,dp,100% ,100% (6) ,100%
7PDA*Widget ,100% ,100% ,100% Extend,dp,100% ,100% ,100% (7)
A* stands for AnnotationFigure 3: Hub
1 2 3 4 5 6 7 8
1AbstractType (1)
2UUIDSerializer ,100% (2) ,50% ,100% ,50%
3UUIDType ext,dp,33% dp, (3) ,33% ,50%
4AbstractCell dp,50% (4)
5TypeCast dp,33% ,33% (5) ,33% ,33%
6IntegerSerializer ,100% ,100% ,50% (6) ,50%
7LongType ext,dp,67% ,67% ,33% (7) dp,67%
8DateType ext,dp,40% ,60% dp,40% (8)
Figure 4: Anchor Submissive
le, and each member le also structurally depends on the
anchor le. When the anchor le changes, each member le
has a 50% probability of changing as well. When a member
le changes, the anchor le always changes with it. A HB-
FileSet is potentially problematic because the anchor le,
like a hub, is strongly coupled with every member le both
structurally and historically.
Anchor Submissive |each member le structurally de-
pends on the anchor le, but each member historically dom-
inates the anchor. This pattern corresponds to an unstable
interface, where the interface is submissive in changes. An
Anchor Submissive FileSet with anchor ain release rtis:
ASFileSet ra=Index AS(a; SelectedDRSpace r; HCP r)
=fa; M rj8m2Mr; Sr(a!m)^
+ S r(m!a)^Hr(m!a)
(8)
Figure 4 shows an ASFileSet with anchor AbstractType
in Cassandra. Each member le directly or indirectly de-
pends on the anchor le, but when the member les change,
the anchor le changes with each of them, with historical
probabilities of 33% to 100%. A ASFileSet is problematic
because history dominance is in the opposite direction to
the structural inuences: the anchor should inuence the
member les, not the other way around.
Anchor Dominant |each member le structurally de-
pends on the anchor le and the anchor le historically
dominates each member le. This pattern corresponds to
the other type of unstable interface, where the interface is
dominant in changes. An Anchor Dominant FileSet with
anchor ain release rtcan be calculated as:
ADFileSet ra=Index AD(a; SelectedDRSpace r; HCP r)
=fa; M rj8m2Mr; Sr(a!m)^
+ S r(m!a)^Hr(a!m)g
(9)
Figure 5 shows an ADFileSet calculated using anchor
ColumnParent in Cassandra. Each member le (from row 2
to row 6) structurally depends on (cell[2 to 6:1]) the anchor
le (row 1), and when the anchor le changes, the member
les change as well with probabilities from 41% to 100%
(cell[1:2 to 6]). A ADFileSet presents potential problems
where the anchor le is unstable and propagates changes to
4911 2 3 4 5 6
1ColumnParent (1) ,100% ,50% ,41% ,50% ,100%
2Cassandra dp, (2) ,48%
3CliClient dp, dp, (3)
4Column*Reader dp, dp, (4)
5ThriftValidation dp, (5)
6CassandraServer dp, Implement, dp, (6)Figure 5: Anchor Dominant
1 2 3 4 5 6 7 8
1JMXETPEMBean (1) ,100% ,44% ,50% ,100% ,100% ,50%
2DebuggableTPExecutor (2) ,31%
3StorageService (3) dp, dp,Use,
4ColumnFamilyStore dp, (4)
5MessagingService dp, (5) dp,
6NodeProbe ,44% dp, (6)
7StatusLogger ,50% dp,50% dp, ,50% (7)
8JMXCTPExecutor ,50% ,100% ,31% ,100% ,50% ,50% ,50% (8)
   
Figure 6: Modularity Violation
member les that structurally depend on it.
Modularity Violation|there are no structure depen-
dencies between the anchor and any member, however they
historically couple with each other. In a modularity violation
the anchor and member les share assumptions (\secrets")
that are not represented in any structural connection. A
MV FileSet with anchor ain release ris calculated as:
MV FileSet ra=Index MV(a; SelectedDRSpace r; HCP r)
=fa; M rj8m2Mr; + S r(a!m)^+ S r(m!a)
^(Hr(m!a)_Hr(a!m))g
(10)
Figure 6 is a MV FileSet with anchor JMXCTPExecutor
(row 8) in Cassandra. The anchor le, on the bottom of the
matrix, is structurally isolated from the member les. How-
ever, when the anchor le changes, there are historically
31% to 100% probabilities that the member les change as
well, and when the member le JMXETPEMBean (on row 1)
changes, the anchor le has a 50% chance to change with it.
This pattern identies potential problems where the anchor
le and the member les share common assumptions, with-
out explicit structural connections, and these assumptions
are manifested by historical co-change relationships.
Identify ArchDebtCandidates .
For each release r, we use each ainErrorSpace ras the
anchor le to calculate a FileSet for each of the 4 pat-
terns: HB,AS,AD, and MV FileSet ra. The FileSet-
Sequence in the Hubpattern with anchor le ais denoted by
HBFileSetSequence a. Similarly, for anchor a, we can identify
AS, AD, and MV FileSetSequence a. Using any error-prone
le as the anchor, we can identify 4 FileSetSequences , each
of which is an ArchDebtCandidate .
As a result, for each a2ErrorSpace rand for each release
r, we can exhaustively detect 4* j[n
r=1ErrorSpace rjcandi-
dates, which equals 4* jErrorSpace njbecause ErrorSpace n
is a super set of all ErrorSpaces in earlier releases.
3.2.3 Modeling: Build Regression Model
Now that we have identied the FileSetSequences, the
candidates of ArchDebt, we: (1) measure maintenance costs
incurred by each FileSet within a FileSetSequence, and (2)
DebtModel(T) = 510.49ln(T) + 875 
R¬≤ = 0.9351 
600800100012001400160018002000
0 2 4 6 8Wicket  
Reque stParameters  Logarithmic 
DebtModel(T) = 290.81e0.385T  
R¬≤ = 0.9108 
020004000600080001000012000
0 2 4 6 8 10Exponential  
DebtModel(T) = -145.28*T3 + 1582.9*T2 - 
3985.8*T + 3772.7 
R¬≤ = 0.9631 
0100020003000400050006000
0 2 4 6 8Wicket  
StockQuoteLabel  Polynormial  DebtModel(T)= 857.3*T + 1070.7 
R¬≤ = 0.9839 
0200040006000800010000
0 2 4 6 8 10HBase  
KeyValueHeap  Linear  
PDFBox  
Type1Encoding  Figure 7: 4 Types of Regression Model
formulate a DebtModel to capture cost variation.
Measure ArchDebtCandidates .
From each FileSetSequence, we rst exclude any singleton
FileSet r, that is, a set containing just 1 le since this can
not involve architecture problems. After that, we dene the
age of a FileSetSequence as the number of FileSets in it
after singleton FileSets are ltered out. Then, for each
FileSet r, we measure the maintenance eort , denoted by
Effort FileSet r, that it consumes by the end of release r.
For any le f2FileSet r, we approximate its maintenance
costs as the amount of bug-xing churn expended on it by
the end of release r. We denote the maintenance cost for le
fby release rasErrorChurn rf.Effort FileSet ris the
sum of maintenance costs spent on each le in the set:
Effort FileSet r=X
8f2FileSet rErrorChurn rf
(11)
To qualify as a debt, rst a FileSetSequence should have
long-lasting impacts. This can be evaluated using the age
ofFileSetSequence. Second, FileSetSequence should require
ever-increasing maintenance eort. Suppose a software sys-
tem has nreleases. Let FileSet fandFileSet lbe the rst
and last element in FileSetSequence. A FileSetSequence is
identied as a real debt if it satises the following condi-
tions:(
age >= n=c;
Effort FileSet l> Effort FileSet f:
where cis a tunable parameter. Here, we use c=2, mean-
ing that FileSetSequence inuences at least half of the re-
leases. Otherwise, the candidate is not a meaningful debt,
at least not yet. The second condition requires that the
maintenance costs on FileSetSequence increase over time.
Formulate DebtModel .
For each FileSetSequence identied as a real debt, we se-
lect a regression model as its DebtModel to describe the
growing trend (the interest rate) of maintenance costs over
time. We use four types of regression models: linear, loga-
rithmic, exponential, and polynomial (up to degree 10). Fig-
ure 7 shows typical examples of these 4 models. Each model
represents a coherent scenario. In a linear model (part 1 of
Figure 7), the penalties of a debt increase at a stable rate in
each version. In a logarithmic model (part 2), the penalties
of a debt increase more slowly over time (e.g., when devel-
492opers refactor a group of les, they become easier change,
so the interest rate decreases over time). In an exponential
model (part 3), the penalties of a debt increase at ever-faster
rates over time (e.g., the structure of a tangled group of les
worsens, often in the early stages of a project, before any-
one worries about TD). In a polynomial model (part 4), the
penalties of a debt uctuate over the releases.
We calculate the maintenance costs| Effort FileSet rfor
each FileSet rin a FileSetSequence using equation 11. The
Effort FileSet rof all FileSet rin a FileSetSequence form
an array that we call Effort Array .Effort Array [i] =
Effort FileSet r, where FileSet ris the ith element of File-
SetSequence. We dene an integer array T[i] = r, where
ris the release number of the ith element in FileSetSe-
quence . Each release ris numbered by its order in the re-
lease in history. In the DebtModel of a FileSetSequence ,
Effort Array is the independent value and Tis the de-
pendent value. We created a ModelSelector algorithm to
select a regression model for the relationship between Tand
Effort Array . The formula and R2of the regression model
are returned as DebtModel :
DebtModel =ModelSelector (EffortArray; T )(12)
We dene a global parameter R2
thresh (R2threshold) for
ModelSelector .R2
thresh ranges from 0 to 1; the higher the
value, the stricter Effort Array andTt the model. Our
ModelSelector algorithm rst tries to t the Effort Array
andTto a linear regression model. If the R2
Linof the linear
model reaches the threshold R2
thresh , it returns the linear
model. If not, it builds both logarithmic and exponential
models, and computes their R2values. If the R2values of
both models reach R2
thresh ,ModelSelector returns the model
that gives a higher R2. Otherwise, it returns the model
that reaches the threshold. If the debt ts neither with
R2>=R2
thresh , it tries polynomial models of degrees up
to 10. A polynomial model where R2
poly>=R2
thresh or the
degree reaches 10, whichever is satised rst, is returned.
In the ModelSelector algorithm, we give higher priority
to linear, logarithmic, and exponential models over poly-
nomial models. We do not simply pick the best t (i.e.,
the model with highest R2). The reason is that the linear,
logarithmic, and exponential models present three general
types of penalty interest rate: stable, decreasing, and in-
creasing. The polynomial model, however, catches minor
uctuations of the penalty trend, most likely a result of noise
due to extraneous factors. For example, the debt in part
1 of Figure 7, intuitively a linear model ( DebtModel (r) =
857r+ 1070 with R2of 0.98), can t into a polynomial
model DebtModel (r) = 2r6+ 59r5 680r4+ 3874
r3 11342r2+ 16538r 6466, with a higher R2(0.99).
The polynomial model ts better (higher R2), but the lin-
ear model is preferred. As long as a debt penalty generally
(R2>=R2
thresh , where e.g. R2
thresh is 0.8) ts into a linear,
logarithmic or exponential model, we choose those models.
For each FileSetSequence, we identify its DebtModel. This
completes our ArchDebt identication.
3.2.4 Ranking: Identify High-maintenance ArchDebt
Not all architectural debts have the same severity|the
maintenance costs they incur. Debts with higher mainte-
nance costs deserve more attention. We rank all the identi-
ed architectural debts according to their cumulative main-
tenance cost as follows. We dene a pair pf=<f,ErrorChurn f>,where fis an error-prone le, ErrorChurn fis the mainte-
nance costs for f, approximated by bug-xing churn on f.
LetEortMap be the set of pf, such that8f2ErrorSpace n
(n is the latest release), there exists a pf2EortMap .Ef-
fortMap is one of the inputs to the ranking algorithm. The
other input is the identied ArchDebts.
RankedDebts =ranking (ArchDebts; EffortMap)
(13)
In the ranking algorithm, we rank the importance of each
ArchDebt according to EortMap iteratively. In each it-
eration, we select maxArchDebt that consumes the largest
portion of eort for les in EortMap from ArchDebts . The
eort for duplicate les is excluded, and the iteration ter-
minates when all ArchDebts are ranked.1The top debts re-
turned consume the largest maintenance eort, and deserve
more attention and higher priority for refactoring.
4. EV ALUATION
To evaluate the eectiveness of our approach, we investi-
gate the following research question:
RQ: Whether the le groups identied in ArchDebts
generate and grow signicant amount of maintenance
costs? That is, are they true and signicant debts?
If the identied le groups only consume a small portion of
overall maintenance eort, then they do not deserve much
attention. Similarly, if the identied le groups cover a large
portion of the system itself, it is not surprising if they also
consume the majority of maintenance eort. In both cases,
we cannot claim that they are debts worthy of attention.
4.1 Subjects
We chose 7 Apache open source projects as our evalua-
tion subjects. These projects dier in scale, application do-
main, length of history, and many other project character-
istics. They are: Camel|a integration framework based on
Enterprise Integration Patterns; Cassandra|a distributed
DBMS; CXF|a Web services framework; Hadoop|a frame-
work for reliable, scalable, distributed computing; HBase|
the Hadoop distributed, scalable, big data store; PDFBox|
a library for working with PDF documents; and Wicket|a
component-based web application framework. A summary
of these projects is given in Table 1. The second column
is the start to end time and the total number of months
(in parentheses) for each project. The third column \#R"
shows the number of releases selected per project. We se-
lected releases to ensure that the time interval between two
releases is approximately 6 months. The column \#Cmt" is
the number of commits made over the selected history. The
column \#Iss" is the number of bug reports, extracted from
the project's bug-tracking system. The last column shows
the size range, measured as the number of les in the rst
and the last selected release.
4.2 Analysis Results
To answer our research question, we measured the amount
of maintenance eort spent on the ArchDebts we identied.
Since we can not directly measure the amount of eort in
working hours or budgets, we use error-xing churn as an
approximation: the number of lines of code modied and
committed to x bugs.
1For pseudo code of all algorithms, see: https://www.cs.
drexel.edu/~lx52/ArchDebt.html
493Table 1: Subject Projects
Su
bject Len
gth of history (#Mon) #R #C
mt #I
ss #F
iles
C
amel 7/
2008 to 7/2014 (72) 12 14
563 27
90 18
38 to 9866
C
assandra 9/
2009 to 11/2014 (62) 10 14
673 47
31 31
1 to 1337
C
XF 12
/2007 to 5/2014 (77) 13 89
37 38
54 28
61 to 5509
Had
oop 8/
2009 to 8/2014 (60) 9 82
53 54
43 13
07 to 5488
HBa
se 12
/2009 to 5/2014 (53) 9 67
18 62
80 56
0 to 2055
P
DFBox 8/
2009 to 9/2014 (62) 12 20
05 18
57 44
7 to 791
Wi
cket 6/
2007 to 1/2015 (92) 15 83
09 35
57 18
79 to 3081
43%  68%  78%  83%  84%  84%  85%  
22%  61%  75%  80%  81%  82%  82%  
10%  28%  33%  35%  37%  38%  
9% 22%  29%  33%  37%  38%  39%  
6% 14%  17%  18%  19%  19%  19%  
0%10%20%30%40%50%60%70%80%90%
12345678910111213141516171819202122232425262728Percentage of Total Error -fixing Churn Error Churn Associated with Top ArchDebts (HBase)  
All Patterns MV AD AS HB
Figure 8: Debt Churn Consumption (HBase)
We use HBase as an example to illustrate our observations.
Figure 8 shows the percentage of maintenance eort associ-
ated with the les in FileSets of all identied ArchDebts
in HBase. The x-axis is the number (from 1 to 28) of iden-
tied architectural debts. The y-axis is the accumulated
percentage of maintenance eort associated with the top x
ArchDebts. Each line represents the percentage of each type
of debt. This gure depicts, from bottom to top, you can
see: Hub, Anchor-Submissive ,Anchor-Dominant, and Mod-
ularity Violation debts respectively. The line on the top is
the total percentage of the 4 types of debts. The values of
the top line are not simply the sum of the values of the 4
types because dierent types of debts may share some les.
Thus we make the following observations in HBase.
(1) Architectural debts consume a signicant per-
centage (85%) of the total project maintenance ef-
fort. A signicant portion of the maintenance eort is spent
on paying interest on related groups of les. If they can iden-
tify such debts early, a project can save signicant eort by
paying down the debts via refactoring [15]. As the number
of debts increases, the total does not reach 100% because
not all errors are architecturally connected. Occasionally,
developers introduce errors that can be xed in isolation.
(2) The top few architectural debts consume a
large percentage of maintenance eort. The top 5
Modularity Violation debts in HBase consume 61% of to-
tal eort, wherease allModularity Violation debts consume
82% of total eort. Similar observations hold for Anchor-
Submissive ,Anchor-Dominant, and Hub debts. The lines
atten as the number of debts increases, indicating that
most of the eort concentrates in the top few debts. This
means that instead of reviewing all identied debts, project
leaders only need to focus on the top few.
(3)Modularity Violation debt is the most com-
mon and expensive debt. Hub debts consume the least
percentage of eort, while Anchor-Dominant and Anchor-
Submissive take similar percentages. We can see that the
line for Modularity Violation is close to the line for the sum
of all types. This is because Modularity Violation debtsinvolve the les in other debts as well.
We made consistent observations from all 7 projects, as
summarized in Table 2. Column \All Debts Ch%" shows
that, for all 7 projects, from 51% to 85% of the total main-
tenance eort is consumed by architectural debts. And, a
large percentage (31% to 50%) of the eort is consumed
by the top 5 Modularity Violation debts (shown in sub col-
umn \Ch%" under \Modularity Vio" ). Modularity Violation
debts impact the largest number of les and consume the
greatest eort, Hub debts consume the least, while Anchor-
Submissive and Anchor-Dominant rotate their orders.
If a debt contains a large number of les, it is not surpris-
ing that they take a large percentage of eort. We observed,
however, that (4) the top 5 architectural debts con-
tain only a small number of les, but consume a
large amount of the total project eort. We compare
the number of les in the top 5 architectural debts versus
the percentage of eort they take. For example, in table 2,
column \Modularity Vio" under \Top 5 Debts" shows that,
in Camel, there are 206 les (13% of all the error-prone les)
in the top 5 ModularityViolation debts, and these 206 les
consume 32% of the total project bug-xing eort. Similarly,
in Camel, the top 5 Anchor Submissive, Anchor Dominant ,
and Hub debts contain only 1%, 4%, and 2% of the error-
prone les, but consume 7%, 16%, and 5% of the total eort
respectively. From the column \All 4 types" under \Top 5
Debts", we can observe that, for all the projects, the top
5 architectural debts contain from only 11% to 32% of the
error-prone les, but consume 27% to 49% of the total eort.
The average ratio of percentage of eort to the percentage
of les in the top 5 debts is 2.
Finally, we analyze the le size (in lines of code) of the
debts we identied. Much research has shown that le size
correlates with error rates and churn. We would like to know
that the debts identied by our approach are not just a set
of large les. To show this we counted the LOC of the les
in the top 5 debts, and observed that the sizes of these les
are randomly distributed. Figure 9, for example, shows the
le size distribution of the top 5 Modularity Violation debts
in Cassandra. The x-axis is the range of le size: 10% means
the top 10% largest les, 10-20% means les in the 10-20%
range in LOC, and so forth. The y-axis is the percentage
of les in the top 5 debts that belong to each size range.
For example, 22% of the les in top 5 debts are in the top
10% largest les, and 11% of the les are in the range of
90-100% range (that is, the smallest les). The top 5 debts
do contain a non-trivial number of large les (22% from the
top 10% size range), consistent with other studies showing
that large les tend to be problematic. But Figure 9 shows
that the top 5 debts contain les in allsize ranges.
In summary, we can claim that the architectural debts
identied by our approach are truly debts that account for
a large amount (from 51% to 85%) of maintenance eort.
Most (31% to 61%) of the maintenance eort concentrates
in the top 5 architectural debts, which contain only a small
percentage (13% to 25%) of the project's les.
5. DISCUSSION
We now discuss which model best describes the interest
rate of an ArchDebt and illustrate how our approach helps
to understand and monitor the evolution of ArchDebts.
494Table 2: Top 5 Debt:#Files vs Churn
ProjectsAll Debts Top 5 Debts
Ch%All 4 types Modularity Vio Anchor Sub. Anchor Dom. Hub
Fls Ch% Fls Ch% Fls Ch% Fls Ch% Fls Ch%
Camel 59% 230(15%) 35% 206(13%) 32% 20(1%) 7% 60(4%) 16% 40(2%) 5%
Cassandra 72% 273(28%) 57% 196(20%) 50% 72(7%) 28% 33(3%) 32% 26(3%) 16%
CXF 56% 200(11%) 27% 136(8%) 20% 70(4%) 6% 22(1%) 10% 12(1%) 3%
Hadoop 51% 145(25%) 44% 118(20%) 42% 45(8%) 22% 10(2%) 16% 10(2%) 6%
HBase 85% 349(30%) 67% 290(25%) 61% 87(7%) 15% 36(3%) 27% 23(2%) 13%
PDFBox 67% 133(32%) 49% 107(25%) 45% 35(8%) 12% 30(7%) 26% 17(4%) 10%
Wicket 62% 295(22%) 38% 214(16%) 31% 130(10%) 11% 35(3%) 13% 14(1%) 7%
22%  
13%  
8% 10%  
5% 5% 6% 9% 11%  11%  
0%5%10%15%20%25%
10% 10%-20% 20%-30% 30%-40% 40%-50% 50%-60% 60%-70% 70%-80% 80%-90% 90%-100%File LOC Distribution -Top 5 MV Debt (Cassandra)  
Figure 9: Top 5 Debts File Size Distribution (Cassandra)
5.1 The Interest Rate of ArchDebt
For each ArchDebt , we search for a suitable regression
model to capture its interest rate, as introduced in 3.2.3,
using R2
thresh of 0.75 and 0.8 respectively. The results are
reported in Table 3. The rst column is project name. The
second column is the number of instances of ArchDebt iden-
tied in a project. The third and forth columns are model
distributions for R2
thresh of 0.75 and 0.8 respectively.
When R2
thresh =0.75, in all the projects, about half (46%
to 65%) of the debts t a linear regression model (with R2
>= 0.75). For other debts where a linear model doesn't t,
a small percentage ts either a logarithmic (4% to 22%) or
exponential (0% to 7%) model (with R2>= 0.75), and a
polynomial model ts 25% to 41% of the identied debts.
When R2
thresh =0.8, the models are less noise-tolerant. We
can see that linear model is still common (36% to 62%) for
all projects. But a small portion of debts, from 6% (HBase,
31% minus 25%) to 18% (PDFBox, 51% minus 33%), can
no longer t into linear, logarithmic, or exponential models,
but t a polynomial model.
In summary, when R2
thresh is 0.75, the linear model is most
common|about half of the debts t into it. This indicates
that half of ArchDebts accumulate maintenance interest at
a constant rate. Only a small portion of debts accumulate
interest at a faster (less than 7% in exponential) or slower
(less than 22% in logarithmic) rate. About 1/3 of the iden-
tied debts accumulate costs with a more uctuating rate,
which is captured by a polynomial model. More ArchDebts
t into a polynomial model as R2
thresh increases.
5.2 Architectural Debt Evolution
We showed, in section 4, that the top 5 debts consume a
large amount of eort. We manually inspected the evolution
of these debts, and now illustrate how architectural aws
evolve into debts over time. As an example, consider the
topHub debt with anchor le ProcessorDef (referred toTable 3: Debt Costs Model Distribution
P
roject #D
sR2
thr
eshold = 0:75 R2
thr
eshold = 0:8
Li
n Log Ex
p P
oly Li
n Log Ex
p P
oly
C
amel 19
9 52
% 19
% 0% 30
% 39
% 20
% 2% 39
%
C
assandra 18
0 61
% 7% 2% 30
% 53
% 6% 3% 39
%
C
XF 18
9 56
% 12
% 1% 32
% 45
% 10
% 4% 41
%
Had
oop 74 46
% 7% 7% 41
% 36
% 8% 3% 53
%
Hb
ase 20
4 65
% 7% 2% 25
% 62
% 4% 2% 31
%
P
DFBox 85 59
% 4% 5% 33
% 39
% 1% 9% 51
%
W
icket 15
3 46
% 22
% 1% 30
% 38
% 17
% 1% 44
%
asPDef in the following) in Camel (Figure 10). We have
provided 3 snapshots of this debt|in release 2.0.0 (age 1),
release 2.2.0 (age 2), and release 2.12.4 (age 11)|to show
its evolution. Snapshots from age 3 to 10 are similar to age
11. \Ext" and \Impl" stand for \extend" and \implement",
\dp" denotes all other types of structural dependencies.
In release 2.0.0, PDef forms a hub with 10 member les:
3 les are its subclasses, 7 les are its general dependents,
andPDef structurally depends on all of them. Note that
in this snapshot, all les, except InterceptStrategy , de-
pend on RouteContext (column 5). The 11 les in this hub
structurally form a strongly connected graph. According to
the revision history, PDef changes with all member les
with probabilities from 50% to 100% (column 1). The de-
pendents (on rows 5 to 11) of PDef are highly coupled with
each other. This is problematic in 3 ways: 1) the parent class
PDef depends on each subclass and each dependent class
(unhealthy inheritance [21]); 2) the parent class is unstable
and often changes with its subclasses and dependent classes
(unstable interface [21]). 3) RouteContext forms cyclic de-
pendencies with 9 les (cycles). Without xing these aws,
we expect the maintenance costs of this group to grow.
In release 2.2.0, the impacts of this hub have enlarged|
PDef has 3 more subclasses and 6 more general dependents,
and it depends on each of them as well. Each newly involved
le also depends on RouteContext (column 13). The revi-
sion history shows that PDef changes with its subclasses
and dependents with probabilities of 33% to 100%. Also,
the subclasses and dependents (rows 5 to 11) of PDef are
highly coupled with each other|changing any of them is
likely to trigger changes to the rest. In following releases,
the hub grows further. Up to release 2.12.4, PDef has 9
subclasses and 18 general dependents|the size of the hub
tripled compared to the start, and, as always, PDef depends
on each of them. In addition, 6 of the 18 general dependents
(rows 11 to 16) of PDef also become its grandchildren. The
inheritance tree has increased in width and depth. The re-
vision history shows PDef still changes with its dependents
with probabilities from 33% to 100%. The les in this snap-
shot are tightly coupled with each other, and so changing
any le is likely to trigger changes to others.
4951 23 45 6 7 8 9 10 11
1ProcessorDef (1) dpdp dpdp dp dp dp dp dp dp
2LoadBalanceDef Ext,dp,100% (2) dp,
3ChoiceDef Ext,dp,100% (3) dp, ,100%
4RollbackDef Ext,dp,100% (4)dp,
5RouteContext dp,67% (5) ,33% ,67% ,33% ,33% dp,33%
6MarshalDef dp,100% dp,67% (6) ,100% ,100% ,50% ,100%
7PolicyDef dp,67% dp,44% ,33% (7) ,33% ,33% ,33%
8TryDef dp,100% ,100% dp, (8)
9UnmarshalDef dp,100% dp,67% ,100% ,100% (9) ,50% ,100%
10Error*Ref dp,50% dp, ,33% (10)
11InterceptStrategy dp,50% ,33% ,50% ,50% ,50% (11)(a) R-2.0.0, Age 1, #File 11, Churn 392
1 2 34 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1ProcessorDef (1) dp, dpdp, dp, dp, dp, dp, dp, dp, dp, dp dp dp, dp, dp, dp, dp, dp, dp,
2ChoiceDef Ext,dp,100% (2) dp ,100%
3LoadBalanceDef Ext,dp,100% (3) dp
4RollbackDef Ext,dp,100% (4) dp ,33%
5OnCompletionDef Ext,dp,67% (5) ,33% ,33% ,33% ,33% ,33% dp ,33% ,33%
6RouteDef Ext,dp,33% (6) dp dp, ,33%
7OnExceptionDef Ext,dp,100% ,100% (7) ,33% ,50% ,33% ,33% dp ,100% ,33%
8Channel dp,50% ,50% (8) ,50% ,50% ,50% dp ,50% dp
9Def dp,44% ,33% Implt,dp,33% (9) ,33% ,33% dp ,33% dp
10ToDef dp,100% ,33% ,100% ,33% ,100% ,100% (10) ,100% dp,40% ,40% ,100%
11ThreadsDef dp,100% ,33% ,100% ,33% ,100% ,100% ,100% (11) dp,40% ,40% ,100%
12RecipientListDef dp,100% (12) dp
13RouteContext dp,60% dp, (13) ,50% dp
14MarshalDef dp,100% ,50% dp,40% (14) ,100% ,100% ,50% ,100%
15PolicyDef dp,75% dp (15)
16TryDef dp,100% ,100% dp (16)
17UnmarshalDef dp,100% ,50% dp,40% ,100% ,100% (17) ,50% ,100%
18Error*Ref dp,40% dp, dp, dp (18)
19MulticastDef dp,100% ,50% ,50% ,50% ,50% ,50% dp (19)
20InterceptStrategy dp,50% ,50% ,50% ,50% ,50% (20) (b) R-2.2.0, Age 2, #File 20, Churn 771
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
1ProcessorDef (1) dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp dp
2ExpressionNode Ext,dp,60% (2) ,40% ,40% ,40% ,40% ,40% ,40% ,40% ,40% ,30
3CatchDef Ext,dp,40% dp,40% (3) ,40% ,40% ,40% ,40% dp, ,40% dp, dp,60% ,30 ,40%
4ChoiceDef Ext,dp,67% dp, (4) dp,33% dp, ,33%
5LoadBalanceDef Ext,dp,50% (5)
6RecipientListDef Ext,dp,50% dp, (6) ,33% ,33% ,33% dp, dp, ,50%
7WireTapDef Ext,dp,33% ,67% (7) ,67% ,33% ,44% ,33% ,33% ,33% ,33% dp,33% ,33% dp,33% ,67%
8AggregateDef Ext,dp,33% ,33% ,33% ,33% ,33% (8) ,50% ,67% ,33% ,50% ,50% ,33% dp, ,33% dp, ,33% ,50%
9ResequenceDef Ext,dp,50% ,50% ,50% ,75% (9) ,75% ,50% ,50% dp, ,50% ,37
10OnCompletionDef Ext,dp,44% dp, ,44% ,33% (10) dp, ,33% dp, ,33% dp, ,33%
11LoopDef dp,100% Ext,dp,100% ,100% ,50% ,50% ,33% ,100% ,100% ,100% (11) ,100% ,100% ,100% ,100% ,33% ,100% ,100% ,100% ,100% ,100% ,100% ,100% ,100% ,100%
12ThrottleDef dp,40% Ext,dp,67% ,33% ,33% ,33% ,67% ,33% ,67% ,33% (12) ,33% ,67% ,67% dp,33% ,67% ,33% dp, ,33% ,33% ,33% ,33% ,33% ,67% ,33%
13I*ConsumerDef dp,50% Ext,dp,50% ,50% ,75% ,50% ,50% (13) ,50% dp, ,50% ,50%
14WhenDef dp,100% Ext,dp,50% ,50% ,100% ,50% ,50% ,50% ,50% (14) ,50% ,50% ,37
15SplitDef dp,50% Ext,dp,50% ,50% ,50% ,75% ,50% ,75% ,50% ,50% (15) ,50% dp, ,50% dp, ,50% ,75%
16DelayDef dp,33% Ext,dp,44% ,33% ,33% ,33% ,67% ,33% ,67% ,33% ,67% ,33% ,67% (16) dp,33% ,67% ,33% dp, ,33% ,33% ,33% ,33% ,33% ,67% ,33%
17Processor*Helper dp,33% dp, dp, dp, (17) dp, dp, dp, dp,
18ThreadsDef dp,33% ,33% ,50% ,33% ,33% ,33% dp, (18) dp, ,50%
19OtherwiseDef dp,100% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% (19) ,50% ,50% ,50% ,50% ,50% ,50% ,50%
20RouteContext ,43% ,33% ,33% ,33% ,33% (20) ,33% ,33% ,33% dp
21PolicyDef dp,80% ,40% (21) dp,100%
22TryDef dp,60% ,40% dp,60% ,40% ,40% ,40% ,40% ,40% dp, ,40% dp, (22) ,30 dp,40%
23TransactedDef dp,56% dp, ,71 (23)
24PipelineDef dp,100% ,100% ,100% ,50% ,50% ,33% ,100% ,100% ,100% ,100% ,100% ,100% ,100% ,100% ,33% ,100% ,100% ,100% ,100% ,100% (24) ,100% ,100% ,100%
25SamplingDef dp,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% ,33% (25) ,33% ,33%
26MulticastDef dp,43% ,43% ,43% ,43% ,43% dp, ,43% dp, (26)
27FinallyDef dp,60% ,50% ,100% ,40% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% ,50% dp,100% ,50% ,50% ,50% ,50% (27)
28InterceptStrategy ,50% ,50% ,50% (28)
(c) R-2.12.4, Age 11, #File 28, Churn 2134
Figure 10: Camel Hub Debt Evolution|Anchor ProcessorDenition
The maintenance costs spent on this debt t a linear re-
gression model: DebtModel (rt) = 158 :75rt+ 509:35 with
R2= 0:89. This means that, in every release, developers
contribute 158.75 more lines of code to x errors in the hub
anchored by PDef . Although this model can only be ob-
tained after the costs and penalty have accumulated, one
could use our approach to detect architecture aw patterns
at any point (as described in [21]), monitor how le groups
grow, monitor the formation of debts, and prevent signi-
cant costs by investing in proper refactorings [15].
6. RELATED WORK
Technical Debt. Since Cunninghan [7] coined the term,
TDhas referred to the consequences of short-cuts taken in
software projects to achieve near-term goals. During the
past decade, TDhas drawn increasing attention [6, 10, 25].
Li et al. [19] conducted a mapping study on dierent
categories of TDbased on related literature published be-
tween 1992 and 2013. They classied ten coarse-grained
TDtypes according to the phases of the software devel-
opment life-cycle, such as requirements, architectural, and
code. They found that Code TDis the most well-studied
type, and Architectural TDhas also received signicant at-
tention. They further categorized Architectural TDinto
seven sub-categories, including architectural smells [22], ar-chitectural anti-patterns [13][24], complex architectural be-
havioral dependencies [5], violations of good architectural
practices [8], architectural compliance issues [16], system-
level structural quality issues, and all others. TDcan com-
promise both functional and quality requirements, such as
performance, security, usability, and modiability.
Alves et al. [1] organized 13 types of TDand their key in-
dicators, including Architectural TD. They described Archi-
tectural TDas \problems encountered in software architec-
ture", and referred to issues in software architecture, struc-
ture dependencies/analysis, and modularity violations as in-
dicators of Architectural TD. Their work focused on build-
ing an ontology of TDrather than focusing on resolving a
specic type of TD.
Everton et al. [9] proposed an approach to identify dif-
ferent types of \self-admitted" TDin software projects, by
reviewing the comments left by developers. They identied
ve types of self-admitted TD: design, requirement, defect,
test, and documentation TD. According to their study, the
most common types of TDare design and requirement. But
as the name \self-admitted" suggests, the TDidentied in
their work was limited to ones that the developers are aware
of. There are forms of TDintroduced unwittingly by devel-
opers, such as the architecture debts we have identied.
Martini et al. [20] conceptualized two patterns of Archi-
496tectural TD: contagious debt and vicious circle. Contagious
debt leads to ripple eects in projects. Vicious circle refers
to a more severe contagious debt where the ripple eects
form a loop. Their work has two limitations. First, it in-
tensively relies on interviewing developers to identify these
problems. As stated above, it is possible the developers are
not aware of all the TDexisting in their project. Further-
more, this approach is labor-intensive and relies highly on
the expertise of the analyst. Second, this only identies two
anti-patterns, and these overlap with each other.
Given the substantial research literature, it is surprising
that denitions of the types of TDare still largely informal.
In fact, the identication of TDrelies heavily on interviews
or reviewing developers' revision comments, and these are
only problems that the developers are aware of. Many ques-
tions in TDresearch remain open. For example, how to
precisely dene the forms of TD, how to automatically iden-
tify these forms of TD, and how to measure TD: its costs
and consequences.
Co-change Analysis An analysis of co-changes in soft-
ware projects at the package, class, method, and statement
level has been used to gain insight into problems in software
development. Zimmermann et al. [28] applied data mining
on revision histories to predict likely changes given a change
that has already occurred. Kagdi et al. [14] proposed an
approach to calculate the change impact scope of a software
entity by combining structural coupling, reected in source
code, and change coupling, recorded in the project's revision
history. Their approach improved the accuracy of change
impact analysis, compared with either technique used inde-
pendently. Gethers et al. [11] proposed an integrated ap-
proach to identify the impact set of a change request (e.g. a
bug ticket in bug-tracking database), based on data mining
of past source code commits and run-time traces.
Analysis of co-changes has also been used in reverse-engi-
neering. Beck et al. [4] used co-change analysis to compute
clusterings. They used an Evolutionary Class Dependency
Graph to represent co-change coupling. They calculated
three types of clusterings using (1) only co-change coupling,
(2) only structure dependencies, and (3) a combination of
the two. They found that clustering based on the combined
approach yielded the best results.
Co-change analysis has also been applied to investigate
problems in software projects, such as bugs and code smells.
Kouroshfar et al. [17, 18] investigated how co-changes im-
pact bugs. They found that co-changes dispersed across dif-
ferent sub-systems are more likely to result in bugs than
localized co-changes. Girba et al. [12] used co-change pat-
terns to identify hidden dependencies between dierent parts
of software system that reveal bad smells. They dened
history patterns in three granularity levels: method level,
class level, and package level. These patterns can reveal
code smells, such as similar code, cloned code, and short-
gun surgery. Code smells have also been used as a heuristic
for approximating TD. Zazworka et al. [27] reported that
not all TDapproximated by code smells will lead to high
maintenance costs, and not all TDhave code smells.
7. LIMITATIONS AND THREATS
We now briey discuss our limitations and threats to va-
lidity. First, since we have only examined 7 projects and
all of these are Apache projects, we can not guarantee that
our results will generalize to other projects with dierentcultures and organizational policies. Second, our approach
has the limitation that it relies on revision history to iden-
tify architectural debt. For projects without enough history
data, our approach can still identify groups of les with the
potential to become architectural debt. The building of a
DebtModel relies on having adequate history data. But our
pattern matching approach is still feasible for projects with
short history. We plan to evaluate the eectiveness of our
approach on projects without enough history in our future
work. Third, our approach relies on mining error-prone les
from a project's revision history and bug tracking data. We
use the bug report ID that developers enter into commits
to locate error-prone les. The availability and accuracy of
such information heavily depend on the project's protocols.
This is both a limitation and threat to validity to our ap-
proach. Finally, we can't guarantee that error-xing churn
is the best proxy measure for eort. In our future work, we
plan to explore more eort proxies, and we are collaborating
with an industry project that records actual eort data, and
we plan to compare this with our proxy measures of eort.
8. CONCLUSION
To quantify and manage architectural TD, we formally de-
ned the concept of architectural debt , and then described an
approach to automatically identify such debts, to measure
their maintenance consequences, and to model their growth.
We proposed a novel history model|the HCP matrix|to
approximate the probabilities of change propagation among
les, and dened 4 patterns based on the HCP matrix to
capture problematic architectural connections among les.
We evaluated our approach on 7 large-scale Apache open
source projects and the results showed that a signicant por-
tion (51% to 85%) of overall maintenance eort was con-
sumed by paying interest on architectural debts. This sug-
gests that projects could save a signicant amount of main-
tenance costs if they can discover these debts early, and pay
them down by refactoring. The top 5 architectural debts in
each of the 7 projects consume a non-trivial portion (20%
to 61%) of each project's maintenance eort, but they only
contain a small portion of each project's error-prone les
(8% to 25%). Thus investing in refactoring small groups
of les could reap large benets. Finally, we quantied the
growing trend of maintenance costs for each debt. About
half of the debts grow linearly, meaning that developers pay
a consistently increasing penalty on these debts in every re-
lease. And using DSMs, we qualitatively illustrated how
architectural issues connect more les, incur more mainte-
nance costs, and evolve into debts over time.
Acknowledgments
This work was supported in part by the National Science
Foundation under grants CCF-1065189, CCF-1514315, and
CCF-1514561.
This material is based upon work funded and supported
by the Department of Defense under Contract No. FA8721-
05-C-0003 with Carnegie Mellon University for the operation
of the Software Engineering Institute, a federally funded re-
search and development center. [Distribution Statement A]
This material has been approved for public release and un-
limited distribution. Please see Copyright notice for non-US
Government use and distribution. DM-0003317.
4979. REFERENCES
[1] N. S. Alves, L. F. Ribeiro, V. Caires, T. S. Mendes,
and R. O. Spinola. Towards an ontology of terms on
technical debt. In Managing Technical Debt (MTD),
2014 Sixth International Workshop on , pages 1{7.
IEEE, 2014.
[2] C. Y. Baldwin and K. B. Clark. Design Rules, Vol. 1:
The Power of Modularity . MIT Press, 2000.
[3] L. Bass, P. Clements, and R. Kazman. Software
Architecture in Practice. Addison-Wesley, 3rd edition,
2012.
[4] F. Beck and S. Diehl. Evaluating the impact of
software evolution on software clustering. In Proc.
17th Working Conference on Reverse Engineering ,
pages 99{108, Oct. 2010.
[5] J. Brondum and L. Zhu. Visualising architectural
dependencies. In Proceedings of the Third
International Workshop on Managing Technical Debt ,
MTD '12, pages 7{14, Piscataway, NJ, USA, 2012.
IEEE Press.
[6] N. Brown, Y. Cai, Y. Guo, R. Kazman, M. Kim,
P. Kruchten, E. Lim, A. MacCormack, R. Nord,
I. Ozkaya, R. Sangwan, C. Seaman, K. Sullivan, and
N. Zazworka. Managing technical debt in
software-reliant systems. pages 47{52, 2010.
[7] W. Cunningham. The WyCash portfolio management
system. In Addendum to Proc. 7th ACM SIGPLAN
Conference on Object-Oriented Programming, Systems,
Languages, and Applications , pages 29{30, Oct. 1992.
[8] B. Curtis, J. Sappidi, and A. Szynkarski. Estimating
the principal of an application's technical debt. IEEE
Software , 29(6):34{42, 2012.
[9] E. da S. Maldonado and E. Shihab. Detecting and
quantifying dierent types of self-admitted technical
debt. SIGSOFT Softw. Eng. Notes , Apr. 2015.
[10] D. Falessi, P. Kruchten, R. L. Nord, and I. Ozkaya.
Technical debt at the crossroads of research and
practice: report on the fth international workshop on
managing technical debt. ACM SIGSOFT Software
Engineering Notes , 39(2):31{33, 2014.
[11] M. Gethers, B. Dit, H. Kagdi, and D. Poshyvanyk.
Integrated impact analysis for managing software
changes. In Proceedings of the 34th International
Conference on Software Engineering, ICSE '12, pages
430{440, Piscataway, NJ, USA, 2012. IEEE Press.
[12] T. G^ rba, S. Ducasse, A. Kuhn, R. Marinescu, and
R. Daniel. Using concept analysis to detect co-change
patterns. In Ninth International Workshop on
Principles of Software Evolution: In Conjunction with
the 6th ESEC/FSE Joint Meeting , IWPSE '07, pages
83{89, New York, NY, USA, 2007. ACM.
[13] I. Grith and C. Izurieta. Design pattern decay: The
case for class grime. In Proceedings of the 8th
ACM/IEEE International Symposium on Empirical
Software Engineering and Measurement , ESEM '14,
pages 39:1{39:4, New York, NY, USA, 2014. ACM.
[14] H. Kagdi, M. Gethers, D. Poshyvanyk, and M. L.
Collard. Blending conceptual and evolutionary
couplings to support change impact analysis in source
code. In Proc. 17th Working Conference on ReverseEngineering, pages 119{128, Oct. 2010.
[15] R. Kazman, Y. Cai, R. Mo, Q. Feng, L. Xiao,
S. Haziyevy, V. Fedaky, and A. Shapochkay. A case
study in locating the architectural roots of technical
debt. In Proc. 37th International Conference on
Software Engineering, 2015.
[16] R. Kazman and S. J. Carriere. Playing detective:
Reconstructing software architecture from available
evidence. Automated Software Engineering,
6(2):107{138, Apr. 1999.
[17] E. Kouroshfar. Studying the eect of co-change
dispersion on software quality. In Software
Engineering (ICSE), 2013 35th International
Conference on, pages 1450{1452, May 2013.
[18] E. Kouroshfar, M. Mirakhorli, H. Bagheri, L. Xiao,
S. Malek, and Y. Cai. A study on the role of software
architecture in the evolution and quality of software.
InProceedings of the 12th Working Conference on
Mining Software Repositories , MSR '15, pages
246{257, Piscataway, NJ, USA, 2015. IEEE Press.
[19] Z. Li, P. Avgeriou, and P. Liang. A systematic
mapping study on technical debt and its management.
J. Syst. Softw. , 101(C):193{220, Mar. 2015.
[20] A. Martini and J. Bosch. The danger of architectural
technical debt: Contagious debt and vicious circles. In
Software Architecture (WICSA), 2015 12th Working
IEEE/IFIP Conference on , pages 1{10, May 2015.
[21] R. Mo, Y. Cai, R. Kazman, and L. Xiao. Hotspot
patterns: The formal denition and automatic
detection of architecture smells. In Proc. 15th Working
IEEE/IFIP International Conference on Software
Architecture, May 2015.
[22] R. Mo, J. Garcia, Y. Cai, and N. Medvidovic.
Mapping architectural decay instances to dependency
models, 2013.
[23] M. Naedele, H.-M. Chen, R. Kazman, Y. Cai, L. Xiao,
and C. A. Silva. Manufacturing execution systems: A
vision for managing software development. Journal of
Systems and Software , 101:59{68, Mar. 2015.
[24] L. Peters. Technical debt: The ultimate antipattern -
the biggest costs may be hidden, widespread, and long
term, 2014.
[25] F. Shull, D. Falessi, C. Seaman, M. Diep, and
L. Layman. Technical debt: Showing the way for
better transfer of empirical results. In J. M unch and
K. Schmid, editors, Perspectives on the Future of
Software Engineering, pages 179{190. Springer Berlin
Heidelberg, 2013.
[26] L. Xiao, Y. Cai, and R. Kazman. Design rule spaces:
A new form of architecture insight. In Proc. 36th
International Conference on Software Engineering ,
2014.
[27] N. Zazworka, A. Vetro, C. Izurieta, S. Wong, Y. Cai,
C. Seaman, and F. Shull. Comparing four approaches
for technical debt identication. Software Quality
Journal , pages 1{24, 2013.
[28] T. Zimmermann, P. Weigerber, S. Diehl, and
A. Zeller. Mining version histories to guide software
changes. In Proc. 26th International Conference on
Software Engineering, pages 563{572, May 2004.
498