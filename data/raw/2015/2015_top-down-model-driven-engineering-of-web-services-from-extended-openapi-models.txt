Top-Down Model-Driven Engineering of Web Services from
Extended OpenAPI Models
David Sferruzza
LS2N - UMR CNRS 6004
Nantes, France
david.sferruzza@ls2n.fr
ABSTRACT
Web services engineering is a crucial subject, because web services
areoftenbuilttobeusedbyotherprograms;thustheyshouldhave
a good documentation targeting developers. Furthermore, when
buildingadigitalproduct,engineersneedtobuildseveralprograms
that interact with a central instance of web services. OpenAPI, a
popular industry standard, makes possible to document web ser-
vices in order to quickly make a prototype of the product. It allows
a top-down process where developers iterate to build an OpenAPI
modelthatdescribesthewebservicestheywant,andthenimple-
ment both the web services and the programs that will consumethem. However, when doing such rapid prototyping, developers
tendtoeitherskipthisdesignphaseandimplementwebservices
rightaway,orstopupdatingtheOpenAPImodelwhentheproduct
is released; in both cases they cannot take advantage of having an
OpenAPImodelalignedwiththeimplementation.Weshowhow
OpenAPI can be extended to add implementation details insidemodels. These extensions link services to assemblies of compo-
nents that describe computations. Hence a top-down development
processthatkeepsmodelandimplementationaligned.Moreover,
this makes possible for developers to benefit from more support
features while keeping the same flexibility.
CCS CONCEPTS
•Softwareanditsengineering →Model-drivensoftwareen-
gineering; Domain specific languages ;Software prototyping ;
KEYWORDS
Web Services, Model-Driven Engineering, Documentation, Code
Generation, OpenAPI 3.0
ACM Reference Format:
DavidSferruzza.2018.Top-DownModel-DrivenEngineeringofWebSer-
vices from Extended OpenAPI Models. In Proceedings of the 2018 33rd
ACM/IEEEInternationalConferenceonAutomatedSoftwareEngineering(ASE
’18), September 3–7, 2018, Montpellier, France. ACM, New York, NY, USA,
4pages.https://doi.org/10.1145/3238147.3241536
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32415361 INTRODUCTION
Context.Webservicesarekeyelementsofmanydigitalproducts.
Indeed, these products often require to be available on several
platforms (web, Android, iOS, ...) thus can benefit from separating
concerns: web services centralizing data and business logic have
differentlifecyclesthantheseveraluserinterfacesthatrelyonthem.
This architecture is quite common; for example, after several years
ofcoachingstartupsatStartupPalace1,itappearsthatalotofthem
are using it or should be. One of the difficulties of this approach
istodesignandmaintainaconsistentinterfacebetweentheweb
servicesandtheotherprograms,whicharesometimesdevelopedby
other teams or even unrelated people. Fortunately, many tools and
languages exist to help designing, writing and maintaining such
interfaces. OpenAPI [6] is one of them: it defines a specification
to describe the HTTP APIs of web services in a language-agnostic
way. It is quite famous in the industry and has a rich ecosystem of
tools2.
Motivation. Building or fast-prototyping digital products can be
achievedusingatop-downapproach.First,theydesignanOpenAPI
model and make sure it is suitable as an interface between thedifferent actors. Then, they can rely on this model to implementthem independantly using programming languages. Some tools
likeSwagger Code Generator [13] provide support to developers in
this process: they generate code based on the OpenAPI model, tar-
geting one of the numerous supported languages and frameworks.
However, because OpenAPI is language-agnostic, the generated
codedoesnotcontainimplementationdetails;developersstillhave
to complete it in a way that respects the contract defined by theOpenAPI model, so that they obtain a working implementation.
Focusingonwebservices,thismeansthat,apartfromthisone-timegeneration,theOpenAPImodelandtheactualimplementationwill
need to be maintained in a separate manner, which in many cases
results inthe implementation beingmaintained andthe OpenAPI
modelbeingoutdated.Thisbecomesmoreproblematicwhenthe
digitalproductevolvesalot(i.e.itisaMVP3)becausedevelopers
cannot benefit again from the code generation step when doing an-
other top-down cycle as it would override precedently customized
code.
Contributions. Toovercomethisissueandgiveevenmoresup-
port to developers, we extend the OpenAPI 3.0 Specification to
make possible to add some implementation details in models, and
1https://www.startup-palace.com
2https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.
md
3Minimum Viable Product: a finished but lightweight product made to test market
hypotheses.
940
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France David Sferruzza
provide a tool to generate working web services from extended
models.
Implementation details added to OpenAPI models consist of
assemblies of components that represent computation units. These
components can be defined in two ways: (i)by a contract and
animplementationinaprogramminglanguage,or (ii)intermof
alreadydefinedcomponents.Everyserviceislinkedtoacomponent
whose purpose is to generate an HTTP response.
Ourtool,SWSG[10],providessupporttoautomatizesthetop-
down development process. It can read these extended models,
checkseveral propertiestoensuretheir consistency, andgenerate
code of working web services. On top of solving the alignment
problem, this gives even more support to developers.
The article is structured as follows. Section 2 describes the com-
ponentsystemandhowitisintegratedinOpenAPI3.0. Section3
introducesSWSGandshowshowitchecksmodelsandgenerates
code.Section4 presents relatedwork. Finally, Section5 concludes
the article with some lessons and future work.
2 EXTENDING OPENAPI
The OpenAPI Specification defines a standard to express interfaces
toHTTPAPIsinalanguage-agnosticway.Itaimsatallowing“both
humans and computers to discover and understand the capabilities
of the service without access to source code, documentation, or
through network traffic inspection” [6]. As in Model-Driven Engi-
neering (MDE), the point of having such meta-models is to have
tools that can rely on them in order to safely manipulate models
and offer support to developers. Indeed, the growing ecosystem of
OpenAPI contains numerous tools that can be used in a top-down
process, which often means that an OpenAPI is given as input to a
tool that will refine it and produce another artifact. For exemple,
bothSwaggerEditor [14]andSwaggerUI [15]provideaninterac-
tivegraphicaluserinterfacefromamodel,and Dredd[1]generates
functional tests from a model.
By design, OpenAPI does not contain implementation details
thatdescribehowthewebservicesaretobeimplemented.Asstated
in the introduction, this can lead to a misalignment between the
OpenAPImodelanditsimplementation.Toovercomethislimitation
whilekeepingthebenefitsofusingOpenAPImodelsinatop-down
process,weextendOpenAPItoaddanewlayerofinformationthat
describes the implementation of the web services at a high-level
ofabstraction.Thislayerconsistsofcomponentsdefinitionsand
instanciationssuchasthoseweintroducedinapreviouswork[12].
Section 2.1 describes this new layer, and Section 2.2 shows how
it is integrated in OpenAPI 3.0.
2.1 The Component System
Componentsareunitsofprocessesandcomputationsthatoccurin-sidewebservicesandwhosepurposeistoproduceHTTPresponses.
Their execution happens in an isolated context, that can contain
variables. They can mutate this context by adding and removing
variables, or return an HTTP response. Components can be of two
kinds: either atomic or composite.Atomic components are defined by a name and four sets of vari-
ables:parameters,preconditions,additionsandremovals.Parame-
ters are variables whose values must be provided when instanciat-
ingthecomponent;itallowstodesigngenericcomponentsthatare
easiertoreuse.Theotherthreesetsofvariablesformthecontractof
the component: they define what variables it needs to access from
thecontext(preconditions),whatvariablesitwilladdtothecontext
(additions) and what variables it will remove (removals). The point
ofthiscontractistosupportalightweightkindofstaticverification
we call structural consistency. Atomic components must go along
with an implementation in a programming language, which makes
them very flexible.
Composite componentsare defined bya name, aset of parame-
ters and a list of instances of components. Parameters work in the
samewayasforatomiccomponents.Instancesofcomponentsrefer-
enceacomponentbyitsnameandprovidebindingsandaliases,that
arespecifictotheinstance.Bindingsassociateaparameterofthe
component to a value, and aliases allow to rename a variable from
thecomponent’scontractinalocalway.Compositecomponents
do not need to be implemented using a programming language
becausetheyaredefinedintermofothercomponents.Indeed,their
behaviorconsistsofexecutingtheirsubcomponentssequentially,
eachgettingthecontextoutputbytheprevious.However,thisse-
quential execution is interrupted if any of the components outputs
an HTTP response instead of a new context.
Thiscomponentsystemwasvoluntarilydesignedtobesimple
and offer a good trade-off between expressiveness and ease of sup-
port.Thatiswhy,forexample,sequentialexecutionistheonlyway
to combine components.
2.2 Extensions to OpenAPI 3.0
To make it possible to use this component system and describe
implementationsofwebservicesfrominsideanOpenAPImodel,
theOpenAPI3.0Specificationmustbeextended.Twokindsofin-
formations must be added: definitions of components and, for each
service,aninstanceofcomponent.Hopefully,OpenAPIprovides
anextensionmechanismthatpreservestoolscompatibility:most
of the schemas of the specification can be enhanced with more
attributes, if their names start with x-. The full specification of our
extensions is available in [11].
TheListing 1 shows an extract of the Petstoreexample [7], an
official example of OpenAPI 3.0 model, that has been enhanced
with our extensions. The components object contains two new
properties: x-swsg-cc andx-swsg-ac . The first is a set of com-
posite component definition; here we define a component called
FindPet in terms of two other components named GetPetById
andRenderPet .Thesecondisasetofatomiccomponentdefinition
that contains the definitions of GetPetById andRenderPet . The
Listing 2 shows how the FindPet component is instanciated from
a service, in the x-swsg-ci attribute.
3 GENERATING WEB SERVICES
To use our extensions to OpenAPI 3.0, we propose the following
top-down development process:
(1)developerswriteastandardOpenAPImodelthatfitstheir
needs;
941
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:52 UTC from IEEE Xplore.  Restrictions apply. Top-Down MDE of Web Services from Extended OpenAPI Models ASE ’18, September 3–7, 2018, Montpellier, France
components:
schemas:
Pet:
allOf:
- $ref: '#/components/schemas/NewPet'
- required:
-i d
properties:
id:
type: integer
format: int64
NewPet:
required:
- name
properties:
name:
type: string
tag:
type: string
x-swsg-cc:
- name: FindPet
components:
- component: GetPetById
- component: RenderPet
x-swsg-ac:
- name: RenderPet
pre:
- name: pet
type:
entity: Pet
- name: GetPetById
pre:
- name: id
type: String
add:
- name: pet
type:
entity: Pet
Listing 1: Components Definition
paths:
/pets/{id}:
get:
parameters:
- name: id
in: path
description: ID of pet to fetch
required: true
schema:
type: integer
format: int64
responses:
'200':
description: pet response
content:
application/json:
schema:
$ref:'#/components/schemas/Pet'
x-swsg-ci:
component: FindPet
Listing 2: Service Definition
(2)they use our extensions to design components and associate
them to every web services;
(3) they write an implementation for each atomic component;
(4) they run SWSG to check the model and generate code.
Thestep(2)ismadepossiblebyourextensionsandprovideatran-
sitional step between the modelling (1) and the implementation (3)
intherefinementprocess.Itsimplifiestheimplementation(3)by
reducing it to several small functions instead of a whole program.
The step(4) makes useof our tool,SWSG [10], thatfollows the
process shown in Figure 1. We present this tool in the followingsections: Section 3.1 focuses on the model consistency verification
andSection 3.2 on the code generation.
OpenAPI 
modelModel parsingSyntax
OK?Failure
StartTransforming to 
SWSG model
Consistent?Consistency 
checkingGenerationAC 
implementations
Web 
servicesTransformation
OK?
StopFailure
Failure
yesyes
yesno
nono1 2
34
Figure 1: Process of SWSG
3.1 Consistency Verification
ThethirdstepoftheprocessofSWSG(Figure1)isastaticverifi-
cation of the structural consistency of the model. It consists of a
setofformalrulesthatcheckthesemanticsofmodelstodetermine
whether it allows for a safe code generation. This set of rules is
derivedfromtheonewepresentedin[12, /pilcrow3].Itspurposeistohelp
developers to spot inconsistencies in models as earlier as possible.
For example, the model presented in Listings 1 and2is inconsis-
tent: SWSG indicates a PreconditionError . Details of the error
tell us that the GetPetById component is not given a variable of
typeStringcalledid, as it requires. Indeed, the service definition
shows that the idvariable comes from a service parameter that
has theIntegertype. This kind of mistakes is quite common in
softwaredevelopment,buthavingtherighttoolscanmitigateits
consequences.Here,SWSGdetectedtheproblembeforeweeven
run the code in production, so we just lost a small amount of time;
wecouldhavelostalotmoretimeifthiscodehadbeendeployed
(just for a typo).
When this error is fixed in the model, SWSG can proceed to the
code generation step.
3.2 Code Generation
The process depicted by Figure 1is generic: it does not rely on a
specific language or technology. Yet the language and technolo-
gies used to implement atomic components must be identical orcompatiblewiththoseofthecodegenerationtarget.Becausewe
experimentin StartupPalace ’scontext,thecurrentimplementation
ofSWSGtargetsthePHPprogramminglanguage4withtheLaravel
web framework5, which is a common tool stack.
The generation in itself is done with a model-to-text transfor-
mation that uses a template engine called Twirl6. Apart from some
static classes and from the implementations of atomic components
(that are not altered), SWSG generated two kinds of source files:
implementations of composite components and a route file. The
Listing 3 shows the code generated for the FindPet component
(defined in Listing 1).
Wetooktheapproachofgeneratingcodethatshouldneverbe
manuallyedited.Thegeneratedcodedoesnotoverrideanyexisting
4https://php.net/
5https://laravel.com/
6https://github.com/playframework/twirl
942
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:52 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France David Sferruzza
<?php
// This is a generated file, do not edit
namespace App\Components;
useApp\SWSG\Component, App\SWSG\Ctx, App\SWSG\Params;
class FindPet implements Component
{
public static function execute(Params $params, Ctx $ctx)
{
$ctx0=\App\Components\GetPetById::execute(new \App\SWSG\Params([]),
$ctx); /arrowhookleft→
if($ctx0instanceof \Illuminate\Http\Response) return$ctx0;
if($ctx0instanceof \SWSG\Ctx) $ctx0=$ctx0;
$ctx1=\App\Components\RenderPet::execute(new \App\SWSG\Params([]),
$ctx0); /arrowhookleft→
if($ctx1instanceof \Illuminate\Http\Response) return$ctx1;
if($ctx1instanceof \SWSG\Ctx) $ctx1=$ctx1;
return$ctx1;
}
}
Listing 3: Generated Code for the FindPetComponent
files in a Laravel’s architecture and can be easily hooked to an
existing web application through configuration.
Incaseofevolutionoftheneeds(whichislikelywhenworkingwith
MVPs), developershave togo through thetop-down development
processagain,butcanreusemostoftheexistingitems(partsofthe
extended OpenAPI model, implementation of atomic components).
Thisapproachpreservesalignmentbetweenthemodelandtheweb
services, and fosters reuse of components.
4 RELATED WORK
The use of MDE for development and automatic generation of web
servicesorwebapplicationsisnotanewtopic[2, 3,9].Indeed,this
work is built on top of the approach of SWSG [12] and Reifier [8].
ThroughSWSG,ourprocesssharesthemeta-modellingapproach
with tools such as M3D(introduced in [2] and extended in [3]) that
alsofocusonbuildingwebservicesusingMDE.Oneofthemain
differencesbetween SWSGand M3Disthat SWSGwas developed
with a focus on design-time support. Even if SWSG is definitely re-
latedtoexistingstandardssuchasBPEL[4]orWSDL,ourapproach
differsonseveralaspects.First,wewantto avoidtheshortcomings
described in[5], that is WSDL models contain toomuch technical
detailsandaredifficulttounderstandforhumans.Indeedourmeta-
model is simpler and less expressive than WSDL or BPEL. Second,
this allows SWSG to provide more support to users; the balance
between flexibility and support is discussed in [16].
One of the tools featured in the OpenAPI ecosystem is Swagger
CodeGenerator [13].Itaimsatgeneratingclientlibrairies,server
stubsordocumentationsfromanOpenAPImodel.Itsupportsmany
languages and frameworks, but only helps developers to write new
services by generated boilerplate code. This automatizes a tedious
task; howeve r they still need to add a lot of code on top of it. More-
over, when services evolve, developer need to manually propagate
evolutions into the codebase because Swagger Code Generator isn’t
abletomergethemautomatically.Ourapproachsolvesthisissue
becauseitgivesflexibilitytodevelopersbeforethecodegeneration
step,makinguselesseditinggeneratedcode.Thisensuresalignment
between the (OpenAPI) model and the web services.5 CONCLUSION
We extended OpenAPI 3.0 with a component system to describe
implementationsofwebservicesfromahigh-level.Thisestablishesanintermediaryartifactthatfitswellinthetop-downdevelopment
process, between the abstract OpenAPI model and the concrete im-
plementationofwebservices.Thisallowstogenerateanimplemen-tationofthewebservicesthatdoesnotneedmanualmodifications.
As a consequence, alignment between the OpenAPI model and the
implementation is guaranteed. Moreover, this paves the way for
enhanced support features; for example, verification or interactive
visualization. We also presented SWSG, a tool that can check struc-
tural consistency of extended OpenAPI models and generate code
of the web services.
This approach was tested on several case studies7, but needs
moretestingonbiggerprojects.Anotherperspectiveistogeneralize
SWSG to support more languages and technologies. This would
probably lead to the formalization of interfaces to make it possible
toplugexternalcodegenerators.Also,itwouldbeinterestingto
allow SWSG to check the compliance between implementations of
atomic components and their contract. In a similar manner, calling
external tools could be a solution to keep SWSG generic.
REFERENCES
[1] Apiary. 2017. Dredd. https://github.com/apiaryio/dredd.
[2]MarioLucaBernardi,MartaCimitile,GiuseppeDiLucca,andFabrizioMaria
Maggi. 2012. M3D: a tool for the Model Driven Development of Web Applica-
tions. InProceedings of the Twelfth International Workshop on Web Information
and Data Management. WIDM 2012. Maui, HI, USA, (Nov. 2, 2012), 73–80.
[3]MarioLucaBernardi,MartaCimitile,andFabrizioMariaMaggi.2016.Auto-
mated development of constraint-driven web applications. In Proceedings of
the 31st Annual ACM Symposium on Applied Computing. ACM, 1196–1203.
[4]XiangFu,TevfikBultan,andJianwenSu.2004.AnalysisofinteractingBPEL
web services. In In Proc. 13th Int. World Wide Web Conf. Citeseer.
[5]RoyGronmo,DavidSkogan,IdaSolheim,andJonOldevik.2004.Model-driven
web services development. In E-Technology, e-Commerce and e-Service. EEE’04.
IEEE, 42–45.
[6]Open API Initiative. 2017. OpenAPI Specification. (Dec. 7, 2017). https://github.
com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md.
[7]OpenAPI Initiative.2017. ThePetstore Example.Version 3.0.1.(Dec.7, 2017).
https://github.com/OAI/OpenAPI-Specification/blob/3.0.1/examples/v3.0/
petstore-expanded.yaml.
[8]Jérôme Rocheteau and David Sferruzza. 2016. Reifier: Model-Driven Engineer-
ingofComponent-BasedandService-OrientedJEEApplications.InACM/IEEE
19thInternationalConferenceonModelDrivenEngineeringLanguagesand
Systems. Saint-Malo, France, (Oct. 5, 2016).
[9]Markus Scheidgen, Sven Efftinge, and Frederik Marticke. 2016. Metamodel-
ing vs Metaprogramming: A Case Study on Developing Client Libraries for
REST APIs. In European Conference on Modelling Foundations and Applications.
Springer, 205–216.
[10]David Sferruzza. 2017. Safe Web Services Generator. https://gitlab.startup-
palace.com/research/swsg.
[11]David Sferruzza. 2018.Specification of SWSG extensions forOpenAPI. (2018).
https://gitlab.startup-palace.com/research/swsg/blob/master/openapi-
extensions-specification/1.0.0.md.
[12]DavidSferruzza,JérômeRocheteau,ChristianAttiogbé,andArnaudLanoix.
2018.AModel-DrivenMethodforFastBuildingConsistentWebServicesin
Practice.In6thInternationalConferenceonModel-DrivenEngineeringand
Software Development. Funchal, Madeira, Portugal, (Jan. 23, 2018).
[13]SmartBearSoftware.2018.SwaggerCodeGenerator.Version3.0.0-rc1.(May29,
2018).https://github.com/swagger-api/swagger-codegen/.
[14]SmartBear Software. 2018. Swagger Editor. https://github.com/swagger-
api/swagger-editor.
[15]SmartBear Software. 2018. Swagger UI. https://github.com/swagger-api/
swagger-UI.
[16]Wil M.P. van der Aalst, Maja Pesic, and Helen Schonenberg. 2009. Declara-
tiveworkflows:Balancingbetweenflexibilityandsupport. ComputerScience-
Research and Development, 23, 2, 99–113.
7https://gitlab.startup-palace.com/research/swsg/tree/master/examples
943
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:10:52 UTC from IEEE Xplore.  Restrictions apply. 