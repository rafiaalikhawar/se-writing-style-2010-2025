Automatic Inference of Code Transforms for Patch Generation
Fan Long
MIT EECS & CSAIL, USA
fanl@csail.mit.eduPeter Amidon
UCSD, USA
peter@picnicpark.orgMartin Rinard
MIT EECS & CSAIL, USA
rinard@csail.mit.edu
ABSTRACT
We present a new system, Genesis, that processes human patches to
automatically infer code transforms for automatic patch generation.
We present results that characterize the effectiveness of the Genesis
inference algorithms and the complete Genesis patch generation
system working with real-world patches and defects collected from
372 Java projects. To the best of our knowledge, Genesis is the
first system to automatically infer patch generation transforms or
candidate patch search spaces from previous successful patches.
CCS CONCEPTS
â€¢Software and its engineering â†’Automatic programming ;
Software testing and debugging ;
KEYWORDS
Patch generation, Code transform, Search space inference
ACM Reference Format:
Fan Long, Peter Amidon, and Martin Rinard. 2017. Automatic Inference of
Code Transforms for Patch Generation. In Proceedings of 2017 11th Joint
Meeting of the European Software Engineering Conference and the ACM
SIGSOFT Symposium on the Foundations of Software Engineering, Paderborn,
Germany, September 4-8, 2017 (ESEC/FSEâ€™17), 13 pages.
https://doi.org/10.1145/3106237.3106253
1 INTRODUCTION
Automatic patch generation systems [ 30,33â€“35,37,38,40,48,56,
61,62] hold out the promise of significantly reducing the human
effort required to diagnose, debug, and fix software defects. The
standard generate and validate approach starts with a set of test
cases, at least one of which exposes the defect. It deploys a set of
transforms to generate a search space ofcandidate patches , then runs
the resulting patched programs on the test cases to find plausible
patches that produce correct outputs for all test cases. All previous
generate and validate systems work with a set of manually crafted
transforms [ 33â€“35,37,38,48,56,61,62] to patch bugs that fall
within the scope of these transforms.
1.1 Genesis
We present Genesis, a novel system that infers code transforms for
automatic patch generation systems [ 36]. Given a set of successful
human patches drawn from available revision histories, Genesis
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
Â©2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-5105-8/17/09. . . $15.00
https://doi.org/10.1145/3106237.3106253generalizes subsets of patches to infer transforms that together
generate a productive search space of candidate patches. Genesis
can therefore leverage the combined patch generation expertise of
many different developers to capture a wide range of productive
patch generation strategies. Genesis applies the inferred transforms
to successfully patch bugs in previously unseen applications. To the
best of our knowledge, Genesis is the first system to automatically
infer patch generation transforms or candidate patch search spaces
from successful patches.
Transforms: Each Genesis transform has two template abstract
syntax trees (ASTs) . One template AST matches code in the orig-
inal program. The other template AST specifies the replacement
code for the generated patch. Template ASTs contain template
variables , which match subtrees or subforests in the original or
patched code. Template variables enable the transforms to abstract
away application-specific details to capture common patterns im-
plemented by multiple patches drawn from different applications.
Generators: Many useful patches do not simply rearrange existing
code and logic; they also introduce new code and logic. Genesis
transforms therefore implement partial pattern matching in which
the replacement template AST contains free template variables that
are not matched in the original code. Each of the free template
variables is associated with a generator , which systematically gen-
erates new candidate code components for the free variable. This
new technique, which enables Genesis to synthesize new code and
logic in the candidate patches, is essential to enabling Genesis to
generate correct patches for previously unseen applications.
Search Space Inference with ILP: A key challenge in patch search
space design is navigating an inherent tradeoff between coverage
and tractability [ 39]. On one hand, the search space needs to be
large enough to contain correct patches for the target class of de-
fects (coverage). On the other hand, the search space needs to be
small enough so that the patch generation system can efficiently
explore the space to find the correct patches (tractability) [39].
Genesis navigates this tradeoff by formulating and solving an
integer linear program (ILP) whose solution maximizes the number
of training patches covered by the inferred search space while
acceptably bounding the number of candidate patches that the
search space can generate.
1.2 Experimental Results
We use Genesis to infer patch search spaces and generate patches
for three classes of defects in Java programs: null pointer (NP),
out of bounds (OOB), and class cast (CC) defects. Working with a
training set that includes 483 NP patches, 199 OOB patches, and
287 CC patches drawn from 356 open source applications, Genesis
infers a search space generated by 108 transforms.
Our benchmark defects include 20 NP, 13 OOB, and 16 CC defects
from 41 open source applications. All of the benchmark applications
are systematically collected from github [ 2] and contain up to 235K
lines of code. With the 108 inferred transforms, Genesis generates
727
ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
correct patches for 21 out of the 49 defects (11 NP, 6 OOB, and 4
CC defects).
We compare Genesis with PAR [ 33,44], a previous patch gen-
eration system for Java that works with manually defined patch
templates. For the same benchmark set, the PAR templates generate
correct patches for 10 fewer defects (specifically, 7 NP and 4 OOB
defects).
We attribute these results to the ability of the automated Genesis
inference algorithms to navigate complex patch transform tradeoffs
at scale. Genesis works with hundreds to over a thousand candidate
transforms to obtain productive search spaces generated by tens to
over a hundred selected transforms â€” many more transforms than
any previous generate and validate system. Deploying this many
transforms enables Genesis to capture a broad range of patch pat-
terns, with the transforms selected to ensure the overall tractability
and coverage of the resulting patch search space.
1.3 Contributions
Transforms with Template ASTs and Generators: We present
novel transforms with template ASTs and generators for free tem-
plate variables. These transforms enable Genesis to abstract away
patch- and application-specific details to capture common patch
patterns and strategies implemented by multiple patches drawn
from different applications. Generators enable Genesis to synthe-
size the new code and logic required to obtain correct patches for
defects that occur in large real-world applications.
Patch Generalization: We present a novel patch generalization
algorithm that, given a set of patches, automatically derives a trans-
form that captures the common patch generation pattern present
in the patches. This transform can generate all of the given patches
as well as other patches with the same pattern in the same or other
applications.
Search Space Inference: We present a novel search space infer-
ence algorithm. Starting with a set of training patches, this algo-
rithm infers a collection of transforms that together generate a
search space of candidate patches with good coverage and tractabil-
ity. The inference algorithm includes a novel sampling algorithm
that identifies promising subsets of training patches to general-
ize and an ILP-based solution to the final search space selection
problem.
Complete System and Experimental Results: We present a
complete patch generation system, including defect localization
and candidate patch evaluation algorithms, that uses the inferred
search spaces to automatically patch defects in large real-world ap-
plications. We also present experimental results from this complete
system.
To the best of our knowledge, Genesis is the first system to
automatically infer patch generation transforms or candidate patch
search spaces from previous successful patches. All experimental
data (including the Genesis source code, inferred templates, and
generated patches) are available at http://groups.csail.mit.edu/pac/
patchgen/.2 TRANSFORM INFERENCE
We next present, via an example, an overview of the Genesis trans-
form inference algorithm. Genesis works with a training set of suc-
cessful human patches to infer a set of patch generation transforms.
In our example, the training set consists of 963 human patches
collected from 356 github repositories.
Patch Sampling and Generalization: The Genesis inference
algorithm works with sampled subsets of patches from the
training set. For each subset, it applies a generalization al-
gorithm to infer a transform that it can apply to generate
candidate patches (Section 4.3). Figure 1 presents one of the
sampled subsets of patches in our example: the first patch
disjoins the clause mapperTypeElement==null to an if con-
dition, the second patch conjoins the clause subject!=null
to a return value, and the third patch conjoins the clause
Material.getMaterials(getTypeId())!=null to an if condi-
tion. These patches are from three different applications, specifically
mapstruct [ 20] 6d7a4d, modelmapper [ 22] d85131, and Bukkit [ 6]
f13115. Genesis generalizes these patches to infer the transform ğ’«1
in Figure 1. When applied, ğ’«1can generate all of the sampled three
patches as well as other patches for other applications.
Template Anatomy: Each transform has a template . In our ex-
ample, the template is V0=â‡’ ((V3)op2(null ))op1(V0)(Figure 1
presents this template in graphical form). The transform has an
initial template AST ğ’¯0, which matches a boolean expression V0
in the unpatched program. V0must occur within a function body
(if all of the training patches had modified if conditions, ğ’¯0would
have reflected that more specific context).
The transform also has a replacement template AST ğ’¯1, which
replaces the matched boolean expression V0with a patch of the
form ((V3)op2(null ))op1(V0). Here V3,op2, and op1areunmatched
template variables . Each such variable is associated with a generator ,
which enumerates candidate code components for the variable.
Generator Constraints: Generator constraints control the com-
ponents that the generator will enumerate. The generator con-
straints for op2and op1(op2âˆˆ{==,!=}and op1âˆˆ{&&,||}) sim-
ply specify sets of operators to enumerate. The generator con-
straints for V3control the AST subtrees that the generator will
enumerate for V3.V3âˆˆExpr states that V3must be an expression.
nodes (V3)âŠ†CallâˆªVarstates that V3can contain only method calls
or variable references. |V3|â‰¤2states that V3can contain at most 2
AST nodes.
vars (V3)âŠ†Mstates that any variables that appear in V3must
also appear in the matched template AST V0(here Mdenotes the set
of nodes in the original matched code). |vars (V3)|â‰¤1states that at
most 1 variable can appear in V3.calls (V3)âŠ†Mand|calls (V3)|â‰¤2
similarly constrain the method calls that may appear in V3.
As these generator constraints illustrate, the Genesis patch gen-
eralization algorithm infers the least general Genesis transform
that generates all of the sampled training patches. This strategy is
critical for obtaining precisely targeted transforms that produce a
tractable number of patches in the patch search space.
Candidate Transforms: Genesis repeatedly samples training
patches to obtain the candidate transforms (from which Genesis will
select the selected transforms that it uses for patch generation). In
728Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
return type.isAssignableFrom(subject.getClass());return subject !=null &&   type.isAssignableFrom(subject.getClass());if (Material.getMaterial(getTypeId()).getData() != null) {...}if (Material.getMaterial(getTypeId()) != null &&  Material.getMaterial(getTypeId()).getData() != null) {...}if (MapperPrism.getInstanceof(  mapperTypeElement) == null) {...}if (mapperTypeElement == null ||  MapperPrism.getInstanceof(  mapperTypeElement) == null) {...}
if (unions.isEmpty()) { if (useDefault) return defaultValue; ... }if (unions == null || unions.isEmpty()) {   if (useDefault) return defaultValue; ... }unionsTransform P1P1transform toGenerators:nullV32Expr nodes(V3)âœ“Call[Var|vars(V3)|ï£¿1|calls(V3)|ï£¿2vars(V3)âœ“Mcalls(V3)âœ“M==||T1T0V02Exprop12{||,&&}op22{==,!=}V0V0V3op1op2
Figure 1: Example inference and application of a Genesis transform. The training patches (original and patched code) are at
the top, the inferred transform is in the middle, and the new patch that Genesis generates is at the bottom.
P1P2P3P4VP144264 40>105VP2 308253440>105VP3 24 8040>105# of candidate patches derived by applyingeach transform to each validation caseInteger Linear Programming SolverThe integer linear program selects P1P1, P2P2, and P3P3.Constraint: the # of derived candidate patches for each covered case is less than 50000.Maximize: the # of covered validation cases
Figure 2: Using integer linear programming to select an effective set of transforms.
our example the candidate transforms include the previous trans-
formğ’«1as well as a transform ( ğ’«2) that adds a conditional (ternary)
operator to guard the computation of an expression from NP de-
fects, a transform ( ğ’«3) that adds an if-guarded return or continue
statement to skip the computation that triggers NP defects, and
a transform ğ’«4that replaces an arbitrary expression with a new
expression. The new expression may contain binary operators, con-
ditional operators, and up to six variables and six method calls from
the enclosing function.
Not all of these transforms are equally useful. ğ’«4, for example,
is an overly general transform that can generate an intractably
large patch search space that Genesis cannot search effectively.
ğ’«1,ğ’«2, andğ’«3, on the other hand, are more targeted â€” because
they were inferred from conceptually similar training patches, each
generates a much smaller search space that nevertheless contains
correct patches. And ğ’«1,ğ’«2, andğ’«3effectively complement each
other â€” their generated search spaces have relatively few patches
in common.
Search Space Inference: To obtain an effective set of transforms,
Genesis must discard overly general transforms such as ğ’«4and
include complementary and effectively targeted transforms such
asğ’«1,ğ’«2, andğ’«3. Genesis drives the transform selection with a
set of validation patches chosen from the training patches. Genesis
starts by computing the number of validation patches that each
candidate transform generates and the size of the search space that
each candidate transform generates when applied to the pre-patch
code for each validation patch.
The matrix in Figure 2 presents these numbers for the four can-
didate transforms ğ’«1,ğ’«2,ğ’«3, andğ’«4and three validation patchesVP1, VP2, and VP3 (in our example the validation patches are drawn
from joda-time [ 17] revision bcb044, dynjs [ 8] revision 68df61, and
orientdb [ 21] revision 51706f). Each number in the matrix is the
number of candidate patches that a transform generates when ap-
plied to the pre-patch code of a validation patch. A bold green
number indicates that a transform can generate the validation
patch when applied to the pre-patch code of the patch. These num-
bers highlight the coverage vs. tractability tradeoff that the can-
didate patches present. With tractable search spaces, ğ’«1,ğ’«2, and
ğ’«3all generate a single validation patch. ğ’«4, in contrast, generates
two validation patches but at the cost of an intractably large search
space.
Working with the information from the matrix, Genesis formu-
lates an integer linear program (ILP) that maximizes the number of
validation patches that the selected transforms can generate sub-
ject to the constraint that the total number of generated candidate
patches from all selected transforms for each covered validation
case is less than 5Ã—104. In our example the ILP selects ğ’«1,ğ’«2, and
ğ’«3as the selected transforms and excludes ğ’«4.
Patch Generation: For the NP defect from DataflowJavaSDK [ 7]
revision c06125 (shown at the bottom of Figure 1), Genesis first uses
a defect localization technique (Section 5) to produce a ranked list
of potential statements to modify. The resulting ranked list includes
the if condition shown at the bottom left of Figure 1. Genesis then
applies all selected transforms, including ğ’«1, to the if condition to
generate candidate patches.
Figure 1 shows how Genesis applies ğ’«1to the if condition. Here
the patch instantiates V3as the variable unions ,op2as==andop3
729ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
as||to disjoin the clause unions == null to the original if condi-
tion. The patch causes the enclosing function innerGetOnly() to
return a predefined default value when unions isnull (instead of
incorrectly throwing a null pointer exception). This patch validates
(produces correct outputs for all inputs in the DataflowJavaSDK
JUnit [ 19] test suite), is correct, and matches the subsequent human
developer patch for this defect.
3 INFERRED TRANSFORMS
The implemented Genesis system selects 108 transforms from a
space of 577 sampled transforms. We next present an overview of
these 108 transforms.
Transforms That Target Boolean Expressions: Many defects
involve incorrect boolean expressions [ 27,37,38,40]. It is therefore
not surprising that many of the inferred transforms target boolean
expressions. Specifically, 17 of the 108 transforms (including the
example transform discussed in Section 2) conjoin or disjoin a
generated subexpression to a boolean condition in the original
program.
Conditional Execution: 6 transforms conditionally execute exist-
ing matched code. 3 of the 6 implement a direct null pointer check,
with the matched code executing only if the pointer is not null.
There are also composite transforms, such as a transform that 1)
initializes a variable to the result of a method call and 2) avoids
a null pointer error by wrapping the intialization and subsequent
relevant code in a null pointer check:
V2V1=V0; if(V5op4V6){V8};V9=â‡’
if(V10!=null ){V2V1=V10.V12(); if(V5op4V6){V8}};V9
Inserted If Then Else: 8 transforms wrap existing code in an if
then else statement. The generated condition tests for a previously
unhandled case, generated code handles the case on one branch,
and the transform places existing code in the other branch. One
transform, for example, inserts a null pointer check and generates
code to return an empty array if the check succeeds. Another gen-
erates an equality check and sets a variable to a different value on
the new branch:
V0=V1;=â‡’if(V3==V4){V0=V6;}else{V0=V1;}
Inserted If Then: 12 transforms insert conditionally executed
generated code â€” the condition tests for a previously unhandled
case. The generated code executes when the case occurs. 6 of the
12 transforms directly check for various null pointer cases, for
example:
V0=â‡’if(V1==null ){V4};V0
Replace Code: 29 transforms replace existing code with newly
generated code. The transforms differ in 1) the form of the code
they replace and generate and 2) the generator constraints. There
are also several transforms that replace most but not all of the
existing code. The following method call transform, for example,
replaces the invoked method and parameters, but keeps the original
receiver:
V2.V1(V0)=â‡’V2.V6(V5)
Try/Catch/Continue: One transform wraps existing code in a
try construct with an empty catch block. Like failure-oblivious
computing [ 53], the patch discards the exception and continues
execution:
V0=â‡’try{V0}catch (V2){}For Loop Off By One: One transform corrects off by one errors
in for loops, specifically by enumerating combinations of starting
values and loop termination conditions as follows:
for (V1V4=0;V0<V2;V0+ + ){V5}=â‡’
for (V1V4=V7;V0op6V2;V0+ + ){V5},V7âˆˆ{0,1},op6âˆˆ{<,â‰¤}
Change Declared Type: One transform changes the declared type
(and potentially also the initializer) of a variable declaration. This
transform generates patches that eliminate class cast exceptions,
specifically by moving the declared type up in the class hierarchy
(V2is the original declared type and V4is the new declared type):
V2V1=V0=â‡’V4V1=V3
Other Transforms: Genesis also infers a variety of more special-
ized transforms that, for example, combine null check insertions
with method receiver replacement or a return of null. It also infers
20 transforms that, in our judgement, are specific to the defects
in the training set and are unlikely to be useful for other defects.
Even though these transforms are unlikely to correct any other
defects, because they are so specific, they impose negligible search
overhead.
Discussion: In comparison with previous manually developed
transforms [ 33,37,38], the Genesis transforms are more numerous,
more diverse, and target a wider range of defects more precisely
and tractably. Some transforms target specific defect classes such as
off by one defects in for loops. Other transforms apply general tem-
plates (for example, replacing one expression with another expres-
sion), with the generator constraints controlling the enumeration
to deliver a tractable search space. While the inferred templates
often correspond to intuitive patch generation patterns that can
correct a wide range of defects, the generator constraints typically
more closely reflect the specific characteristics of the patches in
the training set. For example, many generator constraints focus
the transform on introducing instanceof checks (to patch class cast
exceptions), null pointer checks (to patch null pointer defects), or
checks involving comparison operators such as <, â‰¤, >, orâ‰¥(to
patch out of bounds defects). As the above discussion highlights,
the combination of transform inference and generator constraints
enables Genesis to infer a rich, precisely targeted, but still tractable
patch search space.
4 INFERENCE SYSTEM
We next present the Genesis inference system. Given a set of train-
ing pairs D, each of which corresponds to a program before a change
and a program after a change, Genesis infers a set of transforms P
that, working together, generate the search space of patches.
4.1 Preliminaries
Genesis works with abstract syntax trees (ASTs) of programs. We
model the programming language that Genesis works with as a
context free grammar (CFG) with abstract syntax trees (AST) as the
parse trees for the CFG.
Definition 4.1 (CFG). Acontext free grammar (CFG) Gis a tu-
pleâŸ¨N,Î£,R,sâŸ©where Nis the set of non-terminals, Î£is the set of ter-
minals, Ris a set of production rules of the form aâ†’b1b2b3. . .bk
where aâˆˆNandbiâˆˆNâˆªÎ£, and sâˆˆNis the starting non-terminal
of the grammar. The language of Gis the set of strings derivable
from the start non-terminal: â„’(G)={wâˆˆÎ£âˆ—|sâ‡’âˆ—w}.
730Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
Definition 4.2 (AST). Anabstract syntax tree (AST) Tis a tu-
pleâŸ¨G,X,r,Î¾,ÏƒâŸ©where G=âŸ¨N,Î£,R,sâŸ©is a CFG, Xis a finite
set of nodes in the tree, râˆˆXis the root node of the tree,
Î¾:Xâ†’Xâˆ—maps each node to the list of its children nodes, and
Ïƒ:Xâ†’ (NâˆªÎ£)attaches a non-terminal or terminal label to each
node in the tree.
Definition 4.3 (AST Traversal and Valid AST). Given an AST
T=âŸ¨G,X,r,Î¾,ÏƒâŸ©where G=âŸ¨N,Î£,R,sâŸ©,str (T)denotes the ter-
minal string obtained via traversing T.Tis a valid AST of Giff
str (T)âˆˆâ„’(G).
We next define AST forests and AST slices, which we will use to
present the Genesis inference algorithm. An AST forest is similar to
an AST except it contains multiple trees and a list of root nodes. An
AST slice is a special forest inside a large AST which corresponds
to a list of adjacent siblings.
Definition 4.4 (AST Forest). An AST forest Tis a tuple
âŸ¨G,X,L,Î¾,ÏƒâŸ©where Gis a CFG, Xis the set of nodes in the forest,
L=âŸ¨x1,x2, . . . , xkâŸ©is the list of root nodes of trees in the forest, Î¾
maps each node to the list of its children nodes, and Ïƒmaps each
node in Xto a non-terminal or terminal label.
Definition 4.5 (AST Slice). An AST slice Sis a pairâŸ¨T,LâŸ©.T=
âŸ¨G,X,r,Î¾,ÏƒâŸ©is an AST; L=âŸ¨râŸ©is a list that contains only the root
node or L=âŸ¨xci, . . . , xcjâŸ©is a list of AST sibling nodes in Tsuch
thatâˆƒxâ€²âˆˆX:Î¾(xâ€²)=âŸ¨xc1, . . . , xci, . . . , xcj, . . . , xckâŸ©(i.e., Lis a
sublist ofÎ¾(xâ€²)).
Given two ASTs TandTâ€², where Tis the AST before the
change and Tâ€²is the AST after the change, Genesis computes
AST difference between TandTâ€²to produce an AST slice pair
âŸ¨S,Sâ€²âŸ©such that SandSâ€²point to the sub-forests in TandTâ€²
that subsume the change. For brevity, in this section we assume
D={âŸ¨S1,Sâ€²
1âŸ©,âŸ¨S2,Sâ€²
2âŸ©, . . . ,âŸ¨Sm,Sâ€²mâŸ©}is a set of AST slice pairs, i.e.,
Genesis has already converted AST pairs of changes to AST slices.
Notation and Utility Functions: For a map M,dom (M)denotes
the domain of M.M[a7â†’b]denotes the new map which maps ato
band maps other elements in dom (M)to the same values as M.âˆ…
denotes an empty set or an empty map.
nodes (Î¾,L)denotes the set of nodes in a forest, where Î¾maps each
node to a list of its children and Lis the list of the root nodes of the
trees in the forest.
inside (S)denotes the set of non-terminals of the ancestor nodes of
an AST slice S.
nonterm (L,X,Î¾,Ïƒ,N)denotes the set of non-terminals inside a
forest, where Lis the root nodes in the forest, Xis a finite set of
nodes,Î¾maps each node to a list of children nodes, Ïƒattaches
each node to a terminal or non-terminal label, and Nis the set of
non-terminals.
diff (A,B)denotes the number of different terminals in leaf nodes
between two ASTs, AST slices, or AST forests. If AandBdiffer in
not just terminals in leaf nodes, diff (A,B)=âˆ.Aâ‰¡Bdenotes that
AandBare equivalent, i.e., diff (A,B)=0.
4.2 Template AST Forest, Generator,
Transforms
Template AST Forest: We next introduce the template AST forest,
which can represent a set of concrete AST forests or slices. The
key difference between template and concrete AST forests is thattemplate AST forests contain template variables, each of which can
match against any appropriate AST subtree or AST sub-forest.
Definition 4.6 (Template AST Forest). A template AST forest ğ’¯
is a tupleâŸ¨G,V,Î³,X,L,Î¾,ÏƒâŸ©, where G=âŸ¨N,Î£,R,sâŸ©is a CFG, Vis
a finite set of template variables, Î³:Vâ†’{0,1}Ã—Powerset (N)is
a map that assigns each template variable to a bit of zero or one
and a set of non-terminals, Xis a finite set of nodes in the subtree,
L=âŸ¨x1,x2, . . . , xkâŸ©,xiâˆˆXis the list of root nodes of the trees in
the forest, Î¾:Xâ†’Xâˆ—maps each node to the list of its children
nodes, and Ïƒ:Xâ†’NâˆªÎ£âˆªVattaches a non-terminal, a terminal,
or a template variable to each node.
For each template variable vâˆˆV,Î³(v)=âŸ¨b,WâŸ©determines
the kind of AST subtrees or sub-forests which the variable can
match against. If b=0,vcan match against only AST subtrees not
sub-forests. If b=1, thenvcan match against both subtrees and
sub-forests. Additionally, vcan match against an AST subtree or
sub-forest only if its roots have non-terminals in W.
Intuitively, each non-terminal in the CFG of a programming
language typically corresponds to one kind of syntactic unit in
programs at a certain granularity. Template AST forests with tem-
plate variables enable Genesis to achieve a desirable abstraction
over concrete AST trees during the inference. They also enable
Genesis to abstract away program-specific syntactic details so that
Genesis can infer useful transforms from changes across different
applications.
Definition 4.7 (The |=and|=slice Operators for Template AST
Forests). Figure 3 presents the formal definition of the operator
|=for a template AST forest ğ’¯=âŸ¨G,V,Î³,X,L,Î¾,ÏƒâŸ©.ğ’¯|=âŸ¨T,MâŸ©
denotes that ğ’¯matches the concrete AST forest Twith the template
variable bindings specified in M, where Mis a map that assigns
each template variable in Vto an AST forest.
Figure 3 also presents the formal definition of the operator
|=slice . Similarly, ğ’¯|=sliceâŸ¨S,MâŸ©denotes that ğ’¯matches the
concrete AST slice Swith the variable bindings specified in M.
The first rule in Figure 3 corresponds to the simple case of a
single terminal node. The second and the third rules correspond to
the cases of a single non-terminal node or a list of nodes, respec-
tively. The two rules recursively match the children nodes and each
individual node in the list.
The fourth and the fifth rules correspond to the case of a single
template variable node in the template AST forest. The fourth rule
matches the template variable against a forest, while the fifth rule
matches the variable against a tree. These two rules check that the
corresponding forest or tree of the variable in the binding map Mis
equivalent to the forest or tree that the rules are matching against.
Generators: Generators enumerate new code components:
Definition 4.8 (Generator). A generator ğ’¢is a tupleâŸ¨G,b,Î´,WâŸ©,
where G=âŸ¨N,Î£,R,sâŸ©is a CFG, bâˆˆ{0,1}indicates the behavior of
the generator, Î´is an integer bound for the number of tree nodes,
andWâŠ†Nis the set of allowed non-terminals during generation.
Generators exhibit two kinds of behaviors. If b=0, the generator
generates a sub-forest with less than Î´nodes that contains only
non-terminals inside the set W. Ifb=1, the generator copies an
existing sub-forest from the original AST tree with non-terminal
labels in Wand then replaces up to Î´leaf nodes in the copied
sub-forest.
731ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
G=âŸ¨N,Î£,R,sâŸ©
ğ’¯=âŸ¨G,V,Î³,X,L,Î¾,ÏƒâŸ©L=âŸ¨x1,x2, . . . , xkâŸ©
T=âŸ¨G,Xâ€²,Lâ€²,Î¾â€²,Ïƒâ€²âŸ© Lâ€²=âŸ¨xâ€²
1,xâ€²
2, . . . , xâ€²
kâ€²âŸ©
k=kâ€²=1Ïƒ(x1)=Ïƒâ€²(xâ€²
1)âˆˆÎ£
ğ’¯|=âŸ¨T,MâŸ©
k=kâ€²=1Ïƒ(x1)=Ïƒâ€²(xâ€²
1)âˆˆN
âŸ¨G,V,Î³,X,Î¾(x1),Î¾,ÏƒâŸ©|=âŸ¨âŸ¨G,Xâ€²,Î¾â€²(xâ€²
1),Î¾â€²,Ïƒâ€²âŸ©,MâŸ©
ğ’¯|=âŸ¨T,MâŸ©
k=kâ€²>1
âˆ€iâˆˆ{1,2, . . . , k}
âŸ¨G,V,Î³,X,{xi},Î¾,ÏƒâŸ©|=âŸ¨âŸ¨G,Xâ€²,{xâ€²
i},Î¾â€²,Ïƒâ€²âŸ©,MâŸ©
ğ’¯|=âŸ¨T,MâŸ©
k=1Ïƒ(x1)=vâˆˆV
M(v)â‰¡TÎ³(v)=âŸ¨1,WâŸ© (âˆªkâ€²
i=1Ïƒâ€²(xâ€²
i))âŠ†(WâˆªÎ£)
ğ’¯|=âŸ¨T,MâŸ©
k=kâ€²=1Ïƒ(x1)=vâˆˆV
M(v)â‰¡TÎ³(v)=âŸ¨0,WâŸ©Ïƒâ€²(xâ€²
1)âˆˆ(WâˆªÎ£)
ğ’¯|=âŸ¨T,MâŸ©
ğ’¯|=âŸ¨âŸ¨G,Xâ€²,Lâ€²,Î¾â€²,Ïƒâ€²âŸ©,MâŸ©
ğ’¯|=sliceâŸ¨âŸ¨âŸ¨G,Xâ€²,râ€²,Î¾â€²,Ïƒâ€²âŸ©,Lâ€²âŸ©,MâŸ©
Figure 3: Definitions of |=and|=slice
G=âŸ¨N,Î£,R,sâŸ© S=âŸ¨T,LâŸ©
T=âŸ¨G,X,r,Î¾,ÏƒâŸ©Tâ€²=âŸ¨G,Xâ€²,Lâ€²,Î¾â€²,Ïƒâ€²âŸ©
|nodes (Î¾â€²,Lâ€²)|â‰¤Î´ nonterm (Lâ€²,Xâ€²,Î¾â€²,Ïƒâ€²,N)âŠ†W
âŸ¨âŸ¨G,0,Î´,WâŸ©,SâŸ©=â‡’Tâ€²
âˆƒxâ€²âˆˆX Lâ€²â€²is a sublist of Î¾(xâ€²)
diff (âŸ¨G,X,Lâ€²â€²,Î¾,ÏƒâŸ©,Tâ€²)â‰¤Î´âˆ€xâ€²â€²âˆˆLâ€² Ïƒâ€²(xâ€²â€²)âˆˆW
âŸ¨âŸ¨G,1,Î´,WâŸ©,SâŸ©=â‡’Tâ€²
Figure 4: Definition of the =â‡’for the generator ğ’¢=
âŸ¨G,b,Î´,WâŸ©
Definition 4.9 (Generation Operator =â‡’).Figure 4 presents the
formal definition of the operator =â‡’for a generator ğ’¢. Given ğ’¢
and an AST slice S=âŸ¨T,LâŸ©as the context,âŸ¨ğ’¢,SâŸ©=â‡’Tâ€²denotes
that the generator ğ’¢generates the AST forest Tâ€².
The first rule in Figure 4 handles the case where b=0. The rule
checks that the number of nodes in the result forest is within the
boundÎ´and the set of non-terminals in the forest is a subset of W.
The second rule handles the case where b=1. The rule checks that
the difference result forest and an existing forest in the original
AST is within the bound and the root labels are in W.
Transforms: Finally, we introduce transforms, which generate the
search space inferred by Genesis. Given an AST slice, a transform
generates new AST trees.
Definition 4.10 (Transform). A transform ğ’«is a tuple
âŸ¨A,ğ’¯0,ğ’¯1,BâŸ©.AâŠ†Nis a set of non-terminals that denote the con-
text where this transform can apply; ğ’¯0=âŸ¨G,V0,Î³0,X0,L0,Î¾0,Ïƒ0âŸ©
is the template AST forest before applying the transform;
ğ’¯1=âŸ¨G,V1,Î³1,X1,L1,Î¾1,Ïƒ1âŸ©is the forest after applying theS=âŸ¨âŸ¨G,X,r,Î¾,ÏƒâŸ©,LâŸ© AâŠ†inside (S)
ğ’¯0|=âŸ¨S,MâŸ© B={v17â†’ğ’¢1,v27â†’ğ’¢2, . . . ,vm7â†’ğ’¢m}
âˆ€m
i=1
âŸ¨ğ’¢i,SâŸ©=â‡’Tâ€²â€²
i
Mâ€²={v17â†’Tâ€²â€²
1,v27â†’Tâ€²â€²
2, . . .vk7â†’Tâ€²â€²
m}
ğ’¯1|=âŸ¨Tâ€²,MâˆªMâ€²âŸ© âŸ¨ S,Tâ€²âŸ©â–·T str (T)âˆˆâ„’(G)
âŸ¨âŸ¨A,ğ’¯0,ğ’¯1,BâŸ©,SâŸ©=â‡’T
1â‰¤iâ‰¤jâ‰¤k
S=âŸ¨âŸ¨G,X,r,Î¾,ÏƒâŸ©,LâŸ©L=âŸ¨xi, . . . , xjâŸ©Î¾(xâ€²)=âŸ¨x1,x2, . . . , xkâŸ©
Tâ€²=âŸ¨G,Xâ€²,Lâ€²,Î¾â€²,Ïƒâ€²âŸ©Lâ€²=âŸ¨xâ€²â€²
1,xâ€²â€²
2, . . . , xâ€²â€²
kâ€²âŸ© Xâˆ©Xâ€²=âˆ…
Lâ€²â€²=âŸ¨x1, . . . , xiâˆ’1,xâ€²â€²
1,xâ€²â€²
2, . . . , xâ€²â€²
kâ€²,xj+1, . . . , xkâŸ©
âŸ¨S,Tâ€²âŸ©â–·âŸ¨G,XâˆªXâ€²,r,(Î¾âˆªÎ¾â€²)[xâ€²7â†’Lâ€²â€²],ÏƒâˆªÏƒâ€²âŸ©
Sâ€²=âŸ¨Tâ€²,Lâ€²âŸ© âŸ¨ğ’«,SâŸ©=â‡’Tâ€²
âŸ¨ğ’«,SâŸ©=â‡’slice Sâ€²
Figure 5: Definition of =â‡’and=â‡’slice for the transform ğ’«
transform; Bmaps each template variable vthat appears only in
ğ’¯1to a generator (i.e., âˆ€vâˆˆV1\V0,B(v)is a generator).
Definition 4.11 ( =â‡’and=â‡’slice Operators). Figure 5 presents
the formal definition of the =â‡’and=â‡’slice operators for a trans-
formğ’«.âŸ¨ğ’«,SâŸ©=â‡’Tâ€²denotes that applying ğ’«to the AST slice S
generates the new AST Tâ€².âŸ¨ğ’«,SâŸ©=â‡’slice Sâ€²denotes that applying
ğ’«to the AST slice Sgenerates the AST of the slice Sâ€².
Intuitively, in Figure 5 Aandğ’¯0determine the context where the
transform ğ’«can apply. ğ’«can apply to an AST slice Sonly if the
ancestors of Shave all non-terminal labels in Aandğ’¯0can match
against Swith a variable binding map M.ğ’¯1andBthen determine
the transformed AST tree. ğ’¯1specifies the new arrangement of
various components and Bspecifies the generators to generate
AST sub-forests to replace free template variables in ğ’¯1. Note that
âŸ¨S,Tâ€²âŸ©â–·Tdenotes that the obtained AST tree of replacing the AST
slice Swith the AST forest Tâ€²is equivalent to T.
4.3 Transform Generalization
The generalization operation for transforms takes a set of AST slice
pairs Das input and produces a set of transforms, each of which
can at least generate the corresponding changes of the pairs in D.
Definition 4.12 (Generator Generalization). Figure 6 presents the
definition of the generalization function Ïˆ(D). Given a set of of AST
slice pairs D={âŸ¨S1,Sâ€²
1âŸ©,âŸ¨S2,Sâ€²
2âŸ©, . . . ,âŸ¨Sm,Sâ€²mâŸ©}from the same CFG
grammar G, where Siis the generation context AST slice and Sâ€²
iis
the generated result AST slice, Ïˆ(D)={ğ’¢1,ğ’¢2, . . .ğ’¢k}denotes the
set of the generators generalized from D.
In Figure 6, Ais the formula for a generator that generates
from scratch (i.e., b=0) and Bis the formula for a generator
that generates via copying from the existing AST tree (i.e., b=1).
The formula Aproduces the generator by computing the bound of
the number of nodes and the set of non-terminals in the supplied
slices. The formula Bproduces the generator by computing 1) the
bound of the minimum diffdistance between each supplied slice
and an arbitrary existing forest in the AST tree and 2) the set of
non-terminals of the root node labels of the supplied slices.
Definition 4.13 (Transform Generalization). Figure 7 presents
the definition of Î¨(D). Given a set of pairs of AST slices D=
{âŸ¨S1,Sâ€²
1âŸ©,âŸ¨S2,Sâ€²
2âŸ©, . . . ,âŸ¨Sm,Sâ€²mâŸ©}where Siis the AST slice before a
change and Sâ€²
iis the AST slice after a change, Î¨(D)is the set of
transforms generalized from D.
732Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
G=(N,Î£,R,s) D=âŸ¨âŸ¨S1,Sâ€²
1âŸ©,âŸ¨S2,Sâ€²
2âŸ©, . . . ,âŸ¨Sm,Sâ€²mâŸ©âŸ©
âˆ€iâˆˆ{1,2, . . . , m}:
Si=âŸ¨Ti,LiâŸ© Ti=âŸ¨G,Xi,ri,Î¾i,ÏƒiâŸ©
Sâ€²
i=âŸ¨Tâ€²
i,Lâ€²
iâŸ© Tâ€²
i=âŸ¨G,Xâ€²
i,râ€²
i,Î¾â€²
i,Ïƒâ€²
iâŸ©
Lâ€²
i=âŸ¨xâ€²
i,1,xâ€²
i,2, . . . , xâ€²
i,kâ€²
iâŸ©
Ïˆ(D)=({A,B} âˆ€ iâˆˆ{1, . . . , m},âˆ€jâˆˆ{1, . . . , kâ€²
i},Ïƒâ€²(xâ€²
i,j)âˆˆN
{A} otherwise
where:
A=âŸ¨G,0,maxm
i=1|nodes (Î¾â€²
i,Lâ€²
i)|,Sm
i=1nonterm (Sâ€²
i)âŸ©
B=âŸ¨G,1,maxm
i=1Ci,Sm
i=1Skâ€²
i
j=1{Ïƒâ€²(xâ€²
i,j)}âŸ©
Ci=minLâ€²â€²
idiff (âŸ¨Ti,Lâ€²â€²
iâŸ©,Sâ€²
i),âˆƒxâ€²â€²âˆˆXi,Lâ€²â€²
iis a sublist of Î¾i(xâ€²â€²)
Figure 6: Definition of the generator inference operator Ïˆ
Î¨(âŸ¨âŸ¨S1,Sâ€²
1âŸ©,âŸ¨S2,Sâ€²
2âŸ©, . . . ,âŸ¨Sm,Sâ€²mâŸ©âŸ©)=
{âŸ¨âˆ©m
i=1inside (Si),ğ’¯0,ğ’¯1,BâŸ©|
âŸ¨ğ’¯0,MâŸ©=Î¨â€²(âŸ¨S1,S2, . . . , SmâŸ©,âˆ…),
âŸ¨ğ’¯1,Mâ€²âŸ©=Î¨â€²(âŸ¨Sâ€²
1,Sâ€²
2, . . . , Sâ€²mâŸ©,M),
B={vi7â†’ğ’¢i|
viâˆˆdom (Mâ€²)\dom (M),
Mâ€²(vi)=âŸ¨bi,Wi,âŸ¨Sâ€²â€²
i,1,Sâ€²â€²
i,2, . . . , Sâ€²â€²
i,mâŸ©âŸ©,
Pi={âŸ¨S1,Sâ€²â€²
i,1âŸ©,âŸ¨S2,Sâ€²â€²
i,2âŸ©, . . . ,âŸ¨Sm,Sâ€²â€²
i,mâŸ©},
ğ’¢iâˆˆÏˆ(Pi)}}
Figure 7: Definition of the generalization function Î¨
The formula for Î¨in Figure 7 invokes Î¨â€²twice to compute the
template AST forest before the change ğ’¯0and the template AST
forest after the change ğ’¯1. It then computes Bby invoking Ïˆto
obtain the generalized generators for AST sub-slices that match
against each free template variable in ğ’¯1. Figure 8 presents the
definition of Î¨â€². Intuitively, Î¨â€²is the generalization function for
template AST forests. Î¨â€²(S,M)=âŸ¨ğ’¯,Mâ€²âŸ©takes a list of AST slices
Sand an initial variable binding map Mand produces a generalized
template AST forest ğ’¯and an updated binding map Mâ€².
The first two rows in Figure 8 correspond to the formulas for the
cases of empty slices and slices with a single terminal, respectively.
The two formulas simply create an empty template AST forest or a
template AST forest with a single non-terminal node. The third row
corresponds to the formula for the case of a single non-terminal.
The formula recursively invokes Î¨â€²on the list of children nodes of
each slice and creates a new node with the non-terminal label in
the result template AST forest as the root node.
The fourth and fifth rows correspond to the formulas for the
cases where each slice is a single tree and the root nodes of the
slice trees do not match. The fourth formula handles the case where
there is an existing template variable in Mthat can match the
slice trees. The formula creates a template AST forest with the
matching variable. The fifth formula handles the case where there
is no existing template variable in Mthat can match the slice trees.
The formula creates a template AST forest with a new variable
and updates the variable binding map to include the variable. For
brevity, we omit three additional formulas for recursively handling
AST forests.
4.4 Sampling Algorithm
Given a training database D, we could obtain an exponential num-
ber of transforms with the generalization function Î¨described inInput : a training set of pairs of AST slices Dand a set of pairs of AST slices E
Output: a set of transforms Pâ€²
1Wâ†{{âŸ¨ S,Sâ€²âŸ©,âŸ¨Sâ€²â€²,Sâ€²â€²â€²âŸ©}|âŸ¨S,Sâ€²âŸ©âˆˆD,âŸ¨Sâ€²â€²,Sâ€²â€²â€²âŸ©âˆˆD,âŸ¨S,Sâ€²âŸ©,âŸ¨Sâ€²â€²,Sâ€²â€²â€²âŸ©}
2fori=1to5do
3 fâ†{S7â†’fitness (W,S,D,E)|SâˆˆW}
4 Wâ€²â†{S|SâˆˆW,f(S)>0}
5 Sort elements in Wâ€²based on f
6 Select topÎ±elements in Wâ€²with largest fvalue as a new set Wâ€²â€²
7 Wâ†Wâ€²â€²
8 ifi,5then
9 forSinWâ€²â€²do
10 forâŸ¨S,Sâ€²âŸ©inDdo
11 Wâ†Wâˆª{SâˆªâŸ¨S,Sâ€²âŸ©}
12Pâ€²â†âˆª SâˆˆWÎ¨(S)
13return Pâ€²
Algorithm 1: Sampling algorithm sample (D,E)
Section 4.3, i.e., we can invoke Î¨on any subset of Dto obtain a
different set of transforms. Not all of the generalized transforms are
useful. The goal of the sampling algorithm is to use the generaliza-
tion function to systematically obtain a set of productive candidate
transforms for the inference algorithm to consider.
Figure 1 presents the pseudo-code of our sampling algorithm. As
a standard approach in other learning and inference algorithms to
avoid overfitting, Genesis splits the training database into a training
setDand a validation set E. Genesis invokes the generalization
functions only on pairs in the training set Dto obtain candidate
transforms. Genesis uses the validation set Eto evaluate generalized
transforms. Win Figure 1 is a work set that contains the candidate
subset of Dthat the sampling algorithm is considering to use to
obtain generalized transforms. The algorithm runs five iterations. At
each iteration, the algorithm first computes a fitness score for each
candidate subset, keeps the top Î±candidate subsets, (we empirically
setÎ±to 1000 in our experiments) and eliminates the rest from W
(lines 3-7). The algorithm then attempts to update Wby augmenting
each subset in Wwith one additional pair in D(see lines 8-10).
fitness (W,S,D,E)denotes the fitness score of the subset Sbased
on the coverage and tractability of transforms generalized from S.
4.5 Search Space Inference Algorithm
ILP Formulation: Given a set of candidate transforms Pâ€², the goal
is to select a subset PfromPâ€²that successfully navigates the patch
search space coverage vs. tractability tradeoff.
Figure 9 presents our formulation of the transform selection
problem as an integer linear program (ILP). Eis the set of train-
ing and validation patch pairs. In Figure 9, the first n0pairs are
training patches (i.e. âŸ¨S1,Sâ€²
1âŸ©. . .âŸ¨Sn0,Sâ€²n0âŸ©), the remaining pairs are
validation patches. Ci,jcorresponds to the size of the search space
derived from the j-th transform when applied to the i-th AST slice
pair in E.Gi,jindicates whether the space derived from the j-th
transform contains the corresponding change for the i-th AST slice
pair.
The variable xiindicates whether the result search space covers
thei-th AST slice pair. The variable yiindicates whether the ILP
solution selects the i-th transform. The ILP optimization goal is to
maximize the weighted sum of x, whereÎ·=0.1is a parameter that
controls the weight of covering training patches. The intuition is to
733ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
S=âŸ¨S1,S2, . . . , SmâŸ©G=(N,Î£,R,s)xâ€²is a fresh node vâ€²is a fresh template variable
âˆ€iâˆˆ{1,2, . . . , m}:Si=âŸ¨Ti,LiâŸ© Li=âŸ¨xi,1,xi,2, . . . , xi,kiâŸ©Ti=âŸ¨G,Xi,ri,Î¾i,ÏƒiâŸ©ci=Ïƒi(xi,1)
Î¨â€²(S,M)= Conditions for kandc Other Conditions
âŸ¨âŸ¨G,âˆ…,âˆ…,âŸ¨âŸ©,âˆ…,âˆ…âŸ©,MâŸ© âˆ€iâˆˆ{1, . . . , m}ki=0
âŸ¨âŸ¨G,âˆ…,âˆ…,{xâ€²},âŸ¨xâ€²âŸ©,
{xâ€²7â†’âˆ…} ,{xâ€²7â†’d}âŸ©,MâŸ©dâˆˆÎ£âˆ€iâˆˆ{1, . . . , m}
ki=1ci=d
âŸ¨âŸ¨G,V,Î³,Xâ€²âˆª{xâ€²},âŸ¨xâ€²âŸ©,
Î¾â€²[xâ€²7â†’Lâ€²],Ïƒâ€²[xâ€²7â†’d]âŸ©,Mâ€²âŸ©dâˆˆNâˆ€iâˆˆ{1, . . . , m}
ki=1ci=dSâ€²=âŸ¨âŸ¨T1,Î¾1(x1,1)âŸ©,âŸ¨T2,Î¾2(x2,1)âŸ©, . . . ,âŸ¨Tm,Î¾m(xm,1)âŸ©âŸ©
Î¨â€²(Sâ€²,M)=âŸ¨ğ’¯,Mâ€²âŸ©ğ’¯=âŸ¨G,V,Î³,Xâ€²,Lâ€²,Î¾â€²,Ïƒâ€²âŸ©
âŸ¨âŸ¨G,{v},{v7â†’âŸ¨0,WâŸ©},
{xâ€²},âŸ¨xâ€²âŸ©,
{xâ€²7â†’âˆ…} ,{xâ€²7â†’v}âŸ©,MâŸ©âˆƒi,iâ€²âˆˆ{1, . . . , m}
ci,ciâ€²M(v)=âŸ¨0,W,âŸ¨Sâ€²
1,Sâ€²
2, . . . , Sâ€²
mâŸ©âŸ©
âˆ€iâˆˆ{1, . . . , m}
Siâ‰¡Sâ€²
i
âŸ¨âŸ¨G,{vâ€²},{vâ€²7â†’âŸ¨0,WâŸ©},
{xâ€²},âŸ¨xâ€²âŸ©,
{xâ€²7â†’âˆ…} ,{xâ€²7â†’vâ€²}âŸ©,Mâ€²âŸ©âˆ€iâˆˆ{1, . . . , m}ki=1
âˆƒiâ€²,iâ€²â€²âˆˆ{1, . . . , m}
(ciâ€²,ciâ€²â€²)âˆ€vâˆˆdom (M)
M(v)=âŸ¨0,Wâ€²,âŸ¨Sâ€²
1,Sâ€²
2, . . . , Sâ€²
mâŸ©âŸ© âˆƒ iâˆˆ{1,2, . . . , m}
Si.Sâ€²
i
W=Nâˆ©(âˆªm
i=1{Ïƒi(xi,1)})Mâ€²=M[vâ€²7â†’âŸ¨0,W,SâŸ©]
Figure 8: Definition of Î¨â€²
Pâ€²={ğ’«1,ğ’«2, . . . ,ğ’«k} E={âŸ¨S1,Sâ€²
1âŸ©, . . . ,âŸ¨Sn,Sâ€²nâŸ©}
Ci,j=|{str (T)|âŸ¨ğ’«j,SiâŸ©=â‡’T}|
Gi,j=(1âŸ¨ğ’«j,SiâŸ©=â‡’slice Sâ€²
i
0otherwise
Variables: xi,yiMaximize:Î·Â·Pn0
i=1xi+Pn
i=n0+1xiSatisfy:
âˆ€iâˆˆ{1, . . . , n}:Î¶âˆ’(Î¶âˆ’Î²)Â·xiâˆ’Pk
j=1Ci,jyjâ‰¥0
âˆ€iâˆˆ{1, . . . , n}:Pk
j=1Gi,jyjâˆ’xiâ‰¥0
âˆ€iâˆˆ{1, . . . , n}:xiâˆˆ{0,1}
âˆ€iâˆˆ{1, . . . , k}:yiâˆˆ{0,1}
Result Transform Set: P={ğ’«i|yi=1}
Figure 9: Integer linear programming formulas for selecting
transforms given a set of candidate transforms Pâ€²and a val-
idation set of AST slice pairs E
prioritize the coverage of validation patches because the validation
patches are hidden during the generalization step.
The first group of constraints is for tractability. The i-th
constraint specifies that the derived final search space size (i.e.
Î£k
j=1Ci,jyj), when applied to the i-th AST pair in E, should be less
thanÎ²if the space covers the i-th AST pair (i.e. xi=1) or less
thanÎ¶if the space does not cover the i-th AST pair (i.e. xi=0).
We empirically set Î²=5Ã—104andÎ¶=108. The second group of
constraints is for coverage. The i-th constraint specifies that if the
final search space covers the i-th AST slice pair in E(i.e.xi=1),
then at least one of the selected transforms should cover the i-th
pair.
Inference Algorithm: Starting from a training set of AST slice
pairs D, Genesis first removes 25% of the AST slice pairs from Dto
form the validation set E. It then runs the sampling algorithm to
produce a set of candidate transforms Pâ€². It finally solves the above
ILP with Gurobi [ 31], an off-the-shelf solver, to obtain the set of
transforms Pthat generates the Genesis patch search space.
5 IMPLEMENTATION
We have implemented Genesis for Java programs. We use the spoon
library [ 46] to parse Java programs. Our current implementation
supports any Java application that operates with the maven project
management system [5] and JUnit [19] testing framework.
Given a program p, a set of test cases, at least one of which
exposes a defect in p, and an inferred search space P, Genesis firstuses a defect localization algorithm to identify a ranked list of
suspicious locations (as AST snippets) in pthat are relevant to
the defect. For each suspicious AST snippet S, Genesis applies
each transform in Pto generate candidate patches. It validates
each candidate patch against the test cases and appends it to the
generated patch list if it passes all test cases. Genesis is designed
to work with arbitrary defect localization algorithms. Our current
implementation derives the suspicious locations with stack traces
obtained from test cases that trigger Java exceptions.
Genesis applies its inferred transforms to each of the suspicious
statements in the ranked defect localization list. For each trans-
form, Genesis computes a cost score which is the average number
of candidate patches the transform needs to generate to cover a
validation case. For each suspicious statement, Genesis prioritizes
candidate patches that are generated by transforms with lower cost
scores.
6 EXPERIMENTAL RESULTS
Collect Training Patches and Errors: We used a script to search
the top 1000 github Java projects (ranked by number of stars), a
list of 50968 github repositories from the MUSE corpus [ 3], and the
github issue database for human patches for null pointer (NP), out
of bounds (OOB), and class cast (CC) defects. We collected 1012
human patches from 372 different applications, including 503 NP
patches, 212 OOB patches, and 303 CC patches.
Training and Benchmark Patches: From these collected patches,
we identified benchmark patches that 1) have a JUnit [ 19] test suite
in the repository that Genesis can run automatically, 2) the JUnit test
suite contains at least one test case that can expose and reproduce
the patched defect in our experimental environment, 3) the JUnit
test suite contains at least 50 test cases in total, and 4) the test
suite does not cause non-deterministic behavior. From the collected
1012 patches we identified 49 benchmark patches including 20 NP
patches, 13 OOB patches, and 16 CC patches. We removed the 49
benchmark patches from the 1012 collected patches to obtain 963
training patches including 483 NP, 199 OOB, and 287 CC patches.
Search Space Inference: We ran the inference algorithm on the
training patches for each class of defects to infer transforms for
that class of defects. We also ran the inference algorithm on all of
the training patches together to infer transforms for patching all
three classes of defects combined. Table 1 presents the results. The
first row â€œSampled Transformsâ€ presents the number of candidate
734Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
Table 1: Genesis search space inference results.
NP OOB CC Combined
Sampled Transforms 1354 978 769 577
Selected Transforms 52 35 28 108
Inference Time 1464m 1181m 861m 2886m
Table 2: Genesis patch generation results.
Genesis Genesis (Combined) PAR
Errors First 1/5/10 (All) First 1/5/10 (All) First 1/5/10 (All)
20 NP 8/10/11 (11) 8/11/11 (11) 7/7/7 (7)
13 OOB 3/4/5 (6) 5/5/5 (6) 4/4/4 (4)
16 CC 3/3/4 (5) 1/2/4 (4) 0/0/0 (0)
Total 14/17/20 (22) 14/18/20 (21) 11/11/11 (11)
transforms produced by the sampling algorithm for each search
space. The second row â€œSelected Transformsâ€ presents the number
of selected transforms in each inferred search space. We note that
the number of selected transforms (tens for the targeted search
spaces to over a hundred for the combined search space) is substan-
tially larger than the number of manually generated transforms
that previous search spaces work with [ 33â€“35,37,38,48,56,61,62].
This fact highlights the ability of the automated Genesis inference
system to work effectively with large, detailed, and appropriately
targeted sets of candidate transforms.
PAR Template Implementation: PAR [ 33,44] deploys a set of
transform templates to fix bugs in Java programs, with the templates
manually derived by humans examining real-world patches. We
implemented the PAR templates for NP, OOB, and CC defects under
our own framework (most of the reported PAR patches are gener-
ated by the PAR NP and OOB templates [ 44]). To circumvent any
ambiguities in the PAR template descriptions, we implemented the
templates, with our best efforts, to enable the templates to generate
correct patches for as many benchmark defects as possible.
Patch Generation: We ran Genesis on all of the benchmark de-
fects with 1) the inferred transforms for patching each class of
defects, 2) the inferred transforms for patching all three classes of
defects combined, and 3) the PAR templates. For each defect, Gene-
sis produces (a possibly empty) ranked list of validated patches. We
performed all of the patch generation experiments on Amazon EC2
m4.xlarge instances with Intel Xeon E5-2676 processors, 4 vCPU,
and 16 GB memory. We collected all patches that validated within
5 hours.
We next manually analyzed each benchmark defect along with
the corresponding developer patch from the repository to under-
stand the root cause of the defect. We then analyzed the ranked list
of generated patches to identify the first correct patch in each list (if
any). Note that in our experiments all of the generated patches that
we identify as correct are semantically equivalent to the correspond-
ing developer patch (and differ in at most error or log messages).
Patch Generation Results: Table 2 summarizes the patch genera-
tion results. The first column presents the number and type of each
class of defect. The next columns present patch generation results
for Genesis working with 1) the transforms for patching each class
of defect, 2) the transforms for patching all three classes of defects
combined, and 3) the PAR templates. Each entry is of the form
X/Y/Z (W), where X is the number of defects for which the first
patch to validate is correct, Y is the number of defects for which
one of the first 5 patches to validate is correct, Z is the number ofdefects for which one of the first 10 patches to validate is correct,
and W is the number of defects for which one of the validated
patches is correct. Moving to the combined transforms drops only a
single correct CC patch, highlighting the ability of Genesis to infer
meaningful patches for multiple classes of defects from a single
combined corpus of human patches. The PAR templates correctly
patch roughly half as many defects as the Genesis transforms.
Consistent with previous results [ 39], there are many more val-
idated patches than correct patches â€” for the combined search
space, there are 8 NP defects, 4 OOB defects, and 1 CC defect with
more than 20 validated patches. The maximum numbers of vali-
dated patches for a single NP, OOB, or CC defect are 62, 166, and
74 validated patches, respectively.
Defect Localization Oracle: To isolate the effect of defect local-
ization, we also run Genesis and PAR with an oracle that identifies,
for each defect, the correct line of code to patch. With the oracle, the
combined Genesis space generates correct patches for two more NP
defects (HikariCP [ 12] revision ce4ff92, first correct patch ranked
13th, and spring-data-rest [ 1] revision aa28aeb, first correct patch
ranked 1st) and one more CC defect (jade4j [ 14] revision 114e886,
first correct patch ranked 1st). PAR does not generate any additional
correct patches with the oracle.
Correct Patches: In general, the correct patches either 1) apply a
standard defect-specific patch pattern that Genesis successfully in-
ferred, or 2) modify an existing condition in the unpatched program.
Four of the NP patches insert a null pointer check that returns if
the checked variable is null. Another three insert a null pointer
check that conditionally executes existing code only if the checked
variable is not null. Another throws an exception if the checked vari-
able is null; yet another inserts a null pointer check that executes
generated code when the check fires.
Three of the OOB patches insert a check for either a variable less
than zero or an object field equal to zero, then return a generated
value (either null or zero) if the check fires. One of the remaining
OOB patches conditionally executes existing code if an object field is
not zero. Two of the correct CC patches insert a try/catch statement
that catches and ignores class cast exceptions. One of the remaining
CC patches changes the declared type of a local variable.
The remaining NP, OOB, and CC patches change existing condi-
tions in various ways. For example, one OOB patch corrects an off
by one defect by changing <to<=; another changes a condition to
compare an expression against a variable instead of against zero.
PAR Comparison: The PAR NP templates include â€œadd an if state-
ment to guard an existing statementâ€ and â€œadd an if guarded return
statementâ€ with null check boolean conditions. For the 11 NP de-
fects for which Genesis generates correct patches, one NP defect
(error-prone-370933 [ 9]) is outside the PAR search space because
the correct patches add â€œif (...) throw ...â€ statements. Three more NP
defects (DataflowJavaSDK-c06125 [ 7], javaslang-faf9ac [ 15], and
Activiti-3d624a [ 4]) are outside the PAR search space because the
correct patches change condition expressions in a non-trivial way
that is not equivalent to adding an if-guard.
The PAR OOB templates include â€œadd an if statement to guard an
existing statementâ€ and â€œadd an if guarded return statementâ€ with
range check conditions. The templates also consider â€œincreases or
decreases a variable by oneâ€ and â€œadd an if guarded assignment
statement to enforce index lower and upper bounds of a variableâ€.
735ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
For six OOB defects for which Genesis generates correct patches,
two OOB cases (jgit-929862 [ 16] and jPOS-df400a [ 18]) are outside
the PAR search space because the correct patches change conditions
in a way different from the standard range checks.
The PAR CC templates include â€œadd an if statement to guard an
existing statementâ€ and â€œadd an if guarded return statementâ€ with
instanceof type checks. They also include â€œchange the casting
type of a cast operatorâ€. These templates do not generate correct
patches for any of the benchmark CC defects. For two of these five
defects (jade47 [ 14] revision 114e88 and HdrHistogram-030aac [ 11]),
the correct patches change existing expressions in a way that is
not equivalent to adding a type check guard. The correct patches
for two more CC defects (htmlelements-bf3f27 [ 13] and hamcrest-
bean-84586d [ 10]) insert a try-catch statement to catch and ignore
class cast exceptions (the developers introduced these try-catch
statements in the patched revision and these statements are still
present in the latest revision of these repositories). The correct
patch for the remaining defect (jade4j-dd4739 [ 14]) modifies the
declared type of a local variable to avoid class cast exceptions.
Discussion: These results highlight how automating transform
inference can produce more effective patch search spaces. Automat-
ing the inference makes it possible to work with larger sets of more
detailed transforms that, working together, can more effectively
navigate the inherent tradeoff between coverage and tractability.
In comparison with manual transforms, the inferred transforms
can be more specific (with focused generator parameters). But be-
cause there are so many more inferred transforms (over 100 for
the combined training set) together they cover many more patch
patterns and can successfully patch more defects. By automating
transform inference and formulating the transform selection prob-
lem as an integer linear program, Genesis can effectively work with
hundreds to thousands of candidate transforms to select tens of
final transforms.
7 RELATED WORK
Generate And Validate Systems: GenProg [ 35,62], AE [ 61], and
RSRepair [ 48] use a variety of search algorithms (genetic pro-
gramming, stochastic search, random search) in combination with
transforms that delete, insert, and swap existing program state-
ments. Kali [ 49] applies a single transform that simply deletes code.
NOPOL [ 30] and ACS [ 63] apply transforms to fix errors in branch
conditions. Prophet [ 37] and SPR [ 38] apply a set of predefined pa-
rameterized transformation schemas to generate candidate patches.
Prophet processes a corpus of successful human patches to learn
a model of correct code to rank plausible patches; SPR uses a set
of hand-code heuristics for this purpose. Genesis differs in that it
does not work with a fixed set of human-specified transforms. It
instead automatically processes previous correct patches to infer a
set of transforms that together define its patch search space.
Constraint Solving Systems: Prophet [ 37], SPR [ 38], Qlose [ 26],
NOPOL [ 30], SemFix [ 45], and Angelix [ 40] all use constraint solv-
ing to generate new values for potentially defective expressions
(often defective conditions). ClearView [ 47] enforces learned invari-
ants to eliminate security vulnerabilities. Angelic Debugging [ 25]finds new values for potentially incorrect subexpressions that al-
low the program to produce correct outputs for test inputs. PH-
PQuickFix and PHPRepair use string constraint-solving techniques
to automatically repair PHP programs that generate HTML [ 56].
Specification-based data structure repair [ 28,29,32,64] takes a
data structure consistency specification and an inconsistent data
structure, then synthesizes a repair that produces a modified data
structure that satisfies the consistency specification. Genesis differs
in that it works with automatically inferred transforms, with gener-
ators playing the role of constraint solvers to generate expressions
that enable parameterized transforms to produce correct patches.
Probabilistic Models for Programs: There is a rich body of
work on applying probabilistic models and machine learning learn-
ing techniques to programs, specifically for identifying correct
repairs [ 37], code refactoring [ 51], and code completion [ 24,50,52].
These techniques learn a probabilistic model from a training set
of patches or programs and then use the learned model to identify
the best repair or token for a defective or partial program. Instead
of learning individual patches, Genesis infers transforms that can
be applied to generate multiple candidate patches. Genesis does
not use probabilistic models. It instead obtains transforms with a
novel patch generalization algorithm and formulates the transform
selection problem as an integer linear program.
Code Transfer: CodePhage [ 57],ÂµScalpel [ 23], and CodeCarbon-
Copy [ 58] transfer code across applications. While Genesis also
leverages code from multiple applications, it infers transforms from
previous successful patches instead of transferring code.
Edit, Template, and Transformation Extraction: SYDIT [ 42]
and Lase [ 43] extract edit scripts from one (SYDIT) or more (Lase)
example edits. The script is a sequential list of modification opera-
tions that insert statements or update existing statements. SYDIT
and Lase then generate changes to other code snippets in the same
application with the goal of automating repetitive edits. RASE [ 41]
uses Lase edit scripts to refactor code clones. FixMeUp [ 59,60]
extracts and applies access control templates to protect sensitive
operations. REFAZER (first published [ 54] after the first publica-
tion of this research [ 36]), implements an algorithm for learning
syntactic program transformations from examples [ 55]. The RE-
FAZER transformations were used to perform repetitive edits on
large code bases and to correct defects in student submissions, and
were mostly not useful across assignments. Genesis differs in that it
processes patches from multiple applications to derive generalized
application-independent transforms that it can apply to fix bugs in
yet other (previously unseen) applications. The Genesis transforms
also include generators that enable transforms to generate new
code (as opposed to simply reusing existing matched code).
8 CONCLUSION
Previous generate and validate patch generation systems work with
a fixed set of transforms defined by their human developers. By
automatically inferring transforms from successful human patches,
Genesis makes it possible to leverage the combined expertise and
patch generation strategies of developers worldwide to automati-
cally patch bugs in new applications.
736Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
Table 3: Genesis results with the combined search space.
Type Repository RevisionInit. Search Explored Search Validated First Correct Patch PAR
Time Space Space Time Patches Generation Validated Space Result
Size Size Time Rank Rank
NP caelum-stella 2ec5459 2m 62433 62433 76m 25 <1m 1 147 Correct
NP caelum-stella 2d2dd9c 1m 33198 33198 47m 28 <1m 1 553 Correct
NP caelum-stella e73113f <1m 33592 33592 48m 28 <1m 1 528 Correct
NP HikariCP ce4ff92 3m 163998 79985 >5h 33 - - - No
NP nutz 80e85d0 2m 675603 245793 >5h 0 - - - No
NP spring-data-rest aa28aeb 7m 153943 18773 >5h 0 - - - No
NP checkstyle 8381754 3m 592851 110058 >5h 29 12m 3 3261 Correct
NP checkstyle 536bc20 2m 839914 119964 >5h 49 <1m 1 26 Correct
NP checkstyle aaf606e 2m 681420 117819 >5h 0 - - - No
NP checkstyle aa829d4 1m 0 0 <1m 0 - - - No
NP jongo f46f658 1m 325561 41504 >5h 0 - - - No
NP DataflowJavaSDK c06125d 3m 86731 78301 >5h 1 10m 1 4653 No
NP webmagic ff2f588 1m 184724 115693 >5h 0 - - - No
NP javapoet 70b38e5 <1m 280469 136400 >5h 0 - - - No
NP closure-compiler 9828574 4m >10631940 >5h 5 16m 1 14 Correct
NP truth 99b314e <1m 84076 84076 56m 0 - - - No
NP error-prone 3709338 2m 665832 3350 >5h 9 2m 1 473 No
NP javaslang faf9ac2 <1m >106392392 >5h 18 2m 2 12242 No
NP Activiti 3d624a5 4m 462310 2142 >5h 62 3m 4 31 No
NP spring-hateoas 48749e7 <1m 25633 25633 38m 43 <1m 1 268 Correct
OOB Bukkit a91c4c6 <1m 430352 118319 >5h 4 2m 1 728 Correct
OOB RoaringBitmap 29c6d59 4m 537740 70293 >5h 0 - - - No
OOB commons-lang 52b46e7 2m 136402 8347 >5h 0 - - - No
OOB HdrHistogram db18018 <1m 344483 134113 >5h 140 - - - No
OOB spring-hateoas 29b4334 <1m 37105 37105 41m 0 - - - No
OOB wicket b708e2b 7m 233586 102339 >5h 29 160m 12 46506 Correct
OOB coveralls-maven-plugin 20490f6 <1m 7298 7298 6m 0 - - - No
OOB named-regexp 82bdfeb <1m 0 0 <1m 0 - - - No
OOB jgit 929862f 3m 140077 140077 193m 3 84m 1 54732 No
OOB jPOS df400ac 3m 222560 222560 299m 17 26m 1 18022 No
OOB httpcore dd00a9e 2m 300612 20984 >5h 166 1m 1 427 Correct
OOB vectorz 2291d0d <1m 184636 184636 268m 32 <1m 1 2 Correct
OOB maven-shared 77937e1 2m 0 0 <1m 0 - - - No
CC jade4j dd47397 <1m 239966 120217 >5h 1 169m 1 65325 No
CC jade4j 114e886 <1m 437323 87192 >5h 0 - - - No
CC HdrHistogram 030aac1 <1m 49997 49997 166m 74 2m 7 2662 No
CC pdfbox 93c0b69 1m 208714 142352 >5h 0 - - - No
CC tree-root fef0f36 <1m 43785 43785 39m 0 - - - No
CC spoon 48d3126 9m 0 0 <1m 0 - - - No
CC pebble 942aa6e 2m 255076 103554 >5h 0 - - - No
CC fastjson c886874 1m >106258758 >5h 0 - - - No
CC htmlelements bf3f275 1m 164348 144123 >5h 12 36m 7 16270 No
CC spring-cloud-connectors 56c6eca 1m 151568 151568 244m 5 - - - No
CC joinmo a5ee885 1m 689426 158816 >5h 4 - - - No
CC buildergenerator d9d73b3 <1m 58520 58520 84m 0 - - - No
CC mybatis-3 809c35d 8m 1184696 136625 >5h 0 - - - No
CC antlr4 9e7b131 3m 5917 5917 48m 1 - - - No
CC hamcrest-bean 84586d9 <1m 1081802 148401 >5h 4 30m 2 12029 No
CC raml-java-parser 49aab8f <1m 87054 87054 162m 0 - - - No
9 REPLICATION PACKAGE
All experimental data (including the Genesis source code, inferred
templates, and generated patches) are available at http://groups.
csail.mit.edu/pac/patchgen/. Table 3 shows the results from the
replication package using the inferred combined search space. There
is a row in the table for each defect. The â€œTypeâ€, â€œRepositoryâ€,
and â€œRevisionâ€ columns present the defect type, the Github reposi-
tory name, and the revision, respectively. The â€œInit. Timeâ€ column
presents the amount of time required to initialize the search for
that defect. The â€œSearch Space Sizeâ€ column presents the size of
the search space for that defect, the â€œExplored Space Sizeâ€ column
presents the size of the search space that the algorithm explores
within the five hour timeout, the â€œSearch Timeâ€ column presents theamount of time spent exploring the space, and â€œValidated Patchesâ€
presents the number of candidate patches that validate (produce
correct outputs for all test cases). The next three columns present
statistics for the first generated correct patch, specifically how long
it takes to generate the patch (â€œGeneration Timeâ€), the rank of
the first correct patch in the sequence of validated patches (â€œVali-
dated Rankâ€), and the rank of the correct patch in the sequence of
candidate patches (â€œSpace Rankâ€). The last column (â€œPAR Resultâ€)
presents whether PAR can generate correct patches for the defect
or not.
737ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany Fan Long, Peter Amidon, and Martin Rinard
REFERENCES
[1] Spring Data REST. http://projects.spring.io/spring-data-rest/. (????).
[2] GitHub. https://github.com/. (2008).
[3]Mining and Understanding Software Enclaves (MUSE) Program. https://wiki.
museprogram.org. (2016).
[4] Activiti. http://activiti.org/. (2017).
[5] Apache maven. https://maven.apache.org/. (2017).
[6] Bukkit. https://bukkit.org. (2017).
[7]Dataflow Java SDK. https://github.com/GoogleCloudPlatform/DataflowJavaSDK.
(2017).
[8] dyn.js. http://dynjs.org/. (2017).
[9] Error Prone. http://errorprone.info/. (2017).
[10] Hamcrest Bean. https://github.com/eXparity/hamcrest-bean. (2017).
[11] HdrHistogram. https://github.com/HdrHistogram/HdrHistogram. (2017).
[12] HikariCP. https://brettwooldridge.github.io/HikariCP/. (2017).
[13] Html Elements framework. https://github.com/yandex-qatools/htmlelements.
(2017).
[14] jade4j. https://github.com/neuland/jade4j. (2017).
[15] Javaslang. http://www.javaslang.io/. (2017).
[16] JGit - Eclipse. https://eclipse.org/jgit/. (2017).
[17] Joda-Time. http://www.joda.org/joda-time/. (2017).
[18] jPOS. http://www.jpos.org/. (2017).
[19] JUnit. http://junit.org/. (2017).
[20] MapStruct - Java Bean Mappings, the Easy Way! http://mapstruct.org/. (2017).
[21] OrientDB. http://orientdb.com/orientdb/. (2017).
[22] Simple, Intelligent, Object Mapping. http://modelmapper.org/. (2017).
[23] Earl T Barr, Mark Harman, Yue Jia, Alexandru Marginean, and Justyna Petke.
2015. Automated software transplantation. In Proceedings of the 2015 International
Symposium on Software Testing and Analysis . ACM, 257â€“269.
[24] Pavol Bielik, Veselin Vechev, and Martin Vechev. 2016. PHOG: Prababilistic Model
for Code. In Proceedings of the 33rd International Conference on Machine Learning .
[25] Satish Chandra, Emina Torlak, Shaon Barman, and Rastislav Bodik. 2011. An-
gelic Debugging. In Proceedings of the 33rd International Conference on Soft-
ware Engineering (ICSE â€™11â€™) . ACM, New York, NY, USA, 121â€“130. DOI: http:
//dx.doi.org/10.1145/1985793.1985811
[26] Loris Dâ€™Antoni, Roopsha Samanta, and Rishabh Singh. 2016. Qlose: Program
Repair with Quantitative Objectives. In Computer-Aided Verification (CAV) .
[27] Favio DeMarco, Jifeng Xuan, Daniel Le Berre, and Martin Monperrus. 2014.
Automatic Repair of Buggy if Conditions and Missing Preconditions with SMT.
InProceedings of the 6th International Workshop on Constraints in Software Testing,
Verification, and Analysis (CSTVA 2014) . ACM, New York, NY, USA, 30â€“39. DOI:
http://dx.doi.org/10.1145/2593735.2593740
[28] Brian Demsky, Michael D. Ernst, Philip J. Guo, Stephen McCamant, Jeff H. Perkins,
and Martin C. Rinard. 2006. Inference and enforcement of data structure consis-
tency specifications. In Proceedings of the ACM/SIGSOFT International Symposium
on Software Testing and Analysis, ISSTA 2006, Portland, Maine, USA, July 17-20,
2006. 233â€“244.
[29] Brian Demsky and Martin C. Rinard. 2006. Goal-Directed Reasoning for
Specification-Based Data Structure Repair. IEEE Trans. Software Eng. 32, 12
(2006), 931â€“951.
[30] Thomas Durieux, Matias Martinez, Martin Monperrus, Romain Sommerard, and
Jifeng Xuan. 2015. Automatic Repair of Real Bugs: An Experience Report on the
Defects4J Dataset. CoRR abs/1505.07002 (2015). http://arxiv.org/abs/1505.07002
[31] Inc. Gurobi Optimization. Gurobi Optimizer Reference Manual. (2015). http:
//www.gurobi.com
[32] Sarfraz Khurshid, IvÃ¡n GarcÃ­a, and Yuk Lai Suen. 2005. Repairing Structurally
Complex Data. In Model Checking Software, 12th International SPIN Workshop,
San Francisco, CA, USA, August 22-24, 2005, Proceedings . 123â€“138.
[33] Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic
Patch Generation Learned from Human-written Patches. In Proceedings of the
2013 International Conference on Software Engineering (ICSE â€™13â€™) . IEEE Press,
802â€“811. http://dl.acm.org/citation.cfm?id=2486788.2486893
[34] Xuan-Bach D. Le, David Lo, and Claire Le Goues. 2016. History Driven Program
Repair. In IEEE 23rd International Conference on Software Analysis, Evolution, and
Reengineering, SANER 2016, Suita, Osaka, Japan, March 14-18, 2016 . 213â€“224.
[35] Claire Le Goues, Michael Dewey-Vogt, Stephanie Forrest, and Westley Weimer.
2012. A Systematic Study of Automated Program Repair: Fixing 55 out of 105
Bugs for $8 Each. In Proceedings of the 2012 International Conference on Software
Engineering (ICSE 2012) . IEEE Press, 3â€“13. http://dl.acm.org/citation.cfm?id=
2337223.2337225
[36] Fan Long, Peter Amidon, and Martin Rinard. 2016. Automatic Inference of Code
Transforms and Search Spaces for Automatic Patch Generation Systems . Technical
Report MIT-CSAIL-TR-2016-010. http://hdl.handle.net/1721.1/103556
[37] Fan Long and Martin Rinard. Automatic patch generation by learning correct
code. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL 2016, St. Petersburg, FL, USA, January
20 - 22, 2016 . 298â€“312.[38] Fan Long and Martin Rinard. 2015. Staged Program Repair with Condition
Synthesis. In Proceedings of the 2015 10th Joint Meeting on Foundations of Software
Engineering (ESEC/FSE 2015) . ACM, New York, NY, USA, 166â€“178. DOI: http:
//dx.doi.org/10.1145/2786805.2786811
[39] Fan Long and Martin C. Rinard. 2016. An analysis of the search spaces for generate
and validate patch generation systems. In Proceedings of the 38th International
Conference on Software Engineering, ICSE 2016, Austin, TX, USA, May 14-22, 2016 .
702â€“713.
[40] Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: scalable
multiline program patch synthesis via symbolic analysis. In Proceedings of the
38th International Conference on Software Engineering, ICSE 2016, Austin, TX, USA,
May 14-22, 2016 . 691â€“701.
[41] Na Meng, Lisa Hua, Miryung Kim, and Kathryn S. McKinley. 2015. Does Auto-
mated Refactoring Obviate Systematic Editing?. In Proceedings of the 37th Interna-
tional Conference on Software Engineering - Volume 1 (ICSE â€™15â€™) . IEEE Press, Pis-
cataway, NJ, USA, 392â€“402. http://dl.acm.org/citation.cfm?id=2818754.2818804
[42] Na Meng, Miryung Kim, and Kathryn S. McKinley. 2011. Systematic Editing:
Generating Program Transformations from an Example. In Proceedings of the 32Nd
ACM SIGPLAN Conference on Programming Language Design and Implementation
(PLDI â€™11â€™) . ACM, New York, NY, USA, 329â€“342. DOI: http://dx.doi.org/10.1145/
1993498.1993537
[43] Na Meng, Miryung Kim, and Kathryn S. McKinley. 2013. LASE: locating and
applying systematic edits by learning from examples. In 35th International Con-
ference on Software Engineering, ICSE â€™13, San Francisco, CA, USA, May 18-26, 2013 .
502â€“511.
[44] Martin Monperrus. 2014. A Critical Review of "Automatic Patch Generation
Learned from Human-written Patches": Essay on the Problem Statement and the
Evaluation of Automatic Software Repair. In Proceedings of the 36th International
Conference on Software Engineering (ICSE 2014) . ACM, New York, NY, USA, 234â€“
242. DOI: http://dx.doi.org/10.1145/2568225.2568324
[45] Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra. 2013. SemFix: Program Repair via Semantic Analysis. In Proceedings of the
2013 International Conference on Software Engineering (ICSE â€™13â€™) . IEEE Press, Pis-
cataway, NJ, USA, 772â€“781. http://dl.acm.org/citation.cfm?id=2486788.2486890
[46] Renaud Pawlak, Martin Monperrus, Nicolas Petitprez, Carlos Noguera, and Lionel
Seinturier. 2015. Spoon: A Library for Implementing Analyses and Transforma-
tions of Java Source Code. Software: Practice and Experience (2015), na. DOI:
http://dx.doi.org/10.1002/spe.2346
[47] Jeff H. Perkins, Sunghun Kim, Sam Larsen, Saman Amarasinghe, Jonathan
Bachrach, Michael Carbin, Carlos Pacheco, Frank Sherwood, Stelios Sidiroglou,
Greg Sullivan, Weng-Fai Wong, Yoav Zibin, Michael D. Ernst, and Martin Rinard.
2009. Automatically patching errors in deployed software. In Proceedings of the
ACM SIGOPS 22nd symposium on Operating systems principles (SOSP â€™09) . ACM,
87â€“102. DOI: http://dx.doi.org/10.1145/1629575.1629585
[48] Yuhua Qi, Xiaoguang Mao, Yan Lei, Ziying Dai, and Chengsong Wang. 2014. The
Strength of Random Search on Automated Program Repair. In Proceedings of the
36th International Conference on Software Engineering (ICSE 2014) . ACM, New
York, NY, USA, 254â€“265. DOI: http://dx.doi.org/10.1145/2568225.2568254
[49] Zichao Qi, Fan Long, Sara Achour, and Martin Rinard. 2015. An Anlysis of Patch
Plausibility and Correctness for Generate-and-Validate Patch Generation Systems.
InProceedings of the ACM/SIGSOFT International Symposium on Software Testing
and Analysis, ISSTA 2015 .
[50] Veselin Raychev, Pavol Bielik, Martin Vechev, and Andreas Krause. 2016. Learning
Programs from Noisy Data. In Proceedings of the 43rd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages (POPL â€™16â€™) . ACM,
New York, NY, USA, 761â€“774. DOI: http://dx.doi.org/10.1145/2837614.2837671
[51] Veselin Raychev, Martin Vechev, and Andreas Krause. 2015. Predicting Program
Properties from "Big Code". In Proceedings of the 42Nd Annual ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages (POPL â€™15â€™) . ACM,
New York, NY, USA, 111â€“124. DOI: http://dx.doi.org/10.1145/2676726.2677009
[52] Veselin Raychev, Martin Vechev, and Eran Yahav. 2014. Code Completion with
Statistical Language Models. In Proceedings of the 35th ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI â€™14â€™) . ACM, New
York, NY, USA, 419â€“428. DOI: http://dx.doi.org/10.1145/2594291.2594321
[53] Martin Rinard, Cristian Cadar, Daniel Dumitran, Daniel M. Roy, Tudor Leu, and
William S. Beebee. 2004. Enhancing Server Availability and Security Through
Failure-Oblivious Computing. In OSDI . 303â€“316.
[54] Reudismam Rolim, Gustavo Soares, Loris Dâ€™Antoni, Oleksandr Polozov, Sumit
Gulwani, Rohit Gheyi, Ryo Suzuki, and Bjoern Hartmann. Learning Syntactic
Program Transformations from Examples. (Aug. 2016). arXiv:arXiv:1608.09000
[55] Reudismam Rolim, Gustavo Soares, Loris Dâ€™Antoni, Oleksandr Polozov, Sumit
Gulwani, Rohit Gheyi, Ryo Suzuki, and BjÃ¶rn Hartmann. 2017. Learning syntactic
program transformations from examples. In Proceedings of the 39th International
Conference on Software Engineering, ICSE 2017, Buenos Aires, Argentina, May 20-28,
2017.
[56] Hesam Samimi, Max SchÃ¤fer, Shay Artzi, Todd D. Millstein, Frank Tip, and Laurie J.
Hendren. 2012. Automated repair of HTML generation errors in PHP applications
using string constraint solving. In ICSE 2012, June 2-9, 2012, Zurich, Switzerland .
277â€“287.
738Automatic Inference of Code Transforms for Patch Generation ESEC/FSEâ€™17, September 4-8, 2017, Paderborn, Germany
[57] Stelios Sidiroglou, Eric Lahtinen, Fan Long, and Martin Rinard. 2015. Automatic
Error Elimination by Multi-Application Code Transfer. In Proceedings of the 36th
ACM SIGPLAN Conference on Programming Language Design and Implementation .
ACM.
[58] Stelios Sidiroglou-Douskos, Eric Lantinen, Anthony Eden, Fan Long, and Martin
Rinard. 2017. CodeCarbonCopy. In Proceedings of the 2017 11th Joint Meeting on
Foundations of Software Engineering (ESEC/FSE 2017) .
[59] Sooel Son, Kathryn S. McKinley, and Vitaly Shmatikov. 2011. RoleCast: finding
missing security checks when you do not know what checks are. In Proceedings
of the 26th Annual ACM SIGPLAN Conference on Object-Oriented Programming,
Systems, Languages, and Applications, OOPSLA 2011, part of SPLASH 2011, Portland,
OR, USA, October 22 - 27, 2011 . 1069â€“1084.
[60] Sooel Son, Kathryn S McKinley, and Vitaly Shmatikov. 2013. Fix Me Up: Repairing
Access-Control Bugs in Web Applications.. In NDSS .[61] Westley Weimer, Zachary P. Fry, and Stephanie Forrest. 2013. Leveraging program
equivalence for adaptive program repair: Models and first results. In ASEâ€™13 . 356â€“
366.
[62] Westley Weimer, ThanhVu Nguyen, Claire Le Goues, and Stephanie Forrest. 2009.
Automatically Finding Patches Using Genetic Programming. In Proceedings of the
31st International Conference on Software Engineering (ICSE â€™09â€™) . IEEE Computer
Society, 364â€“374. DOI: http://dx.doi.org/10.1109/ICSE.2009.5070536
[63] Yingfei Xiong, Jie Wang, Runfa Yan, Jiachen Zhang, Shi Han, Gang Huang, and
Lu Zhang. 2017. Precise Condition Synthesis for Program Repair. In Proceedings
of the 39th International Conference on Software Engineering (ICSE â€™17) . IEEE Press,
Piscataway, NJ, USA, 416â€“426. DOI: http://dx.doi.org/10.1109/ICSE.2017.45
[64] Razieh Nokhbeh Zaeem, Muhammad Zubair Malik, and Sarfraz Khurshid. 2013.
Repair Abstractions for More Efficient Data Structure Repair. In Runtime Verifi-
cation - 4th International Conference, RV 2013, Rennes, France, September 24-27,
2013. Proceedings . 235â€“250.
739