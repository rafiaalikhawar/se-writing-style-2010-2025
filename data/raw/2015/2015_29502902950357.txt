Python Predictive Analysis for Bug Detection
Zhaogui Xu*, Peng Liuy, Xiangyu Zhangyz, and Baowen Xu*z
*State Key Laboratory of Novel Software TechnologyyDepartment of Computer Science
*Nanjing University, ChinayPurdue University, USA
zgxu@smail.nju.edu.cn {peng74,xyzhang}@cs.purdue.edu bwxu@nju.edu.cn
ABSTRACT
Python is a popular dynamic language that allows quick
software development. However, Python program analy-
sis engines are largely lacking. In this paper, we present
a Python predictive analysis. It rst collects the trace of
an execution, and then encodes the trace and unexecuted
branches to symbolic constraints. Symbolic variables are in-
troduced to denote input values, their dynamic types, and
attribute sets, to reason about their variations. Solving the
constraints identies bugs and their triggering inputs. Our
evaluation shows that the technique is highly eective in an-
alyzing real-world complex programs with a lot of dynamic
features and external library calls, due to its sophisticated
encoding design based on traces. It identies 46 bugs from
11 real-world projects, with 16 new bugs. All reported bugs
are true positives.
CCS Concepts
Software and its engineering !Software testing
and debugging;
Keywords
Python; Dynamic Language; Debugging; Predictive Analy-
sis
1. INTRODUCTION
Python is becoming one of the most widely used program-
ming languages due to its exibility, usability, and strong
library support for quick development. According to IEEE
Spectrum [1], Python is one of the four most popular pro-
gramming languages in 2015.
Due to the prevalence of Python, analyzing Python pro-
grams becomes as important as analyzing programs in tra-
ditional languages such as Java and C. However, analyzing
Python programs is much more dicult due to the following
zCorresponding authors.reasons. First of all, Python is dynamically typed. Variables
have no static type declarations and may hold values of dif-
ferent types at runtime. The signatures of Python functions
also have no type declarations for the parameters, which
allows the functions to accept any types of parameters. Sec-
ondly, everything in Python is an object. Particularly, func-
tions, classes and other kinds of objects are all rst-class
objects that can be created and passed anywhere. Thirdly,
object attributes can be dynamically accessed and updated
through computed names (e.g., through reection functions
getattr() and setattr() ). Fourthly, collections are per-
vasively used in Python. They are usually heterogeneous so
that they may hold any types of values. Finally, external
function calls are pervasive in Python programs.
Existing analysis for Python and other dynamic languages
can be classied to three kinds. Static analysis [25, 23, 2,
3] (e.g., abstract interpretation and type inference) analyze
program statically. They have limited eectiveness due to
the dynamic features in Python. Dynamic analyses [11, 13]
focus on the observed executions, and hence cannot ana-
lyze unexecuted paths. Symbolic and concolic execution en-
gines [15, 17, 18, 19] are developed for dynamic languages
such as Python, Javascript, and Ruby. These engines ex-
plore individual paths in a program. Many of them do not
support exploring other aspects of the state space such as
type variations and attribute set variations that are very
common in dynamic languages, due to state explosion and
diculties in explicitly encoding these variations.
In this paper, we develop a predictive analysis engine
for Python programs. Predictive analysis [4, 5, 6, 7] is a
kind of symbolic analysis driven by concrete executions. It
rst collects the execution trace of a passing run. It then
symbolically encodes the trace, and relaxes the parts that
the analyst wants to reason about by introducing symbolic
variables to denote possible variations (e.g., schedules in a
multi-threaded program execution). Solving the constraints
is equivalent to exploring the executions that have small
dierences from the traced execution to nd bugs. We call
these the neighboring executions of the observed execution.
Our contributions are summarized as follows.
We develop the rst predictive analysis engine for
Python programs. It explores neighboring executions
of an observed execution by relaxing the inputs, includ-
ing their types, attribute sets, and values. Dierent
from most predictive analysis that encodes schedule
variations and prohibits path changes, it encodes in-
put variations and handles the resulting state changes
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
FSEâ€™16 , November 13â€“18, 2016, Seattle, WA, USA
c2016 ACM. 978-1-4503-4218-6/16/11...$15.00
http://dx.doi.org/10.1145/2950290.2950357
Artifact evaluated by FSEâœ“
121
including path changes. Like other predictive analysis,
ours is sound, never reporting false positives.
We design a novel encoding scheme for Python pro-
grams and execution traces. It focuses on handling
dynamic features by introducing symbolic variables to
represent dynamic types and attributes, and explicitly
reasoning about their changes and correlations.
As part of the engine, we develop a tracing infrastruc-
ture for Python programs. It features tracing not only
the traditional control ow and data ow information,
but also the implicit dynamic properties of executed
Python statements such as object attributes.
We build a prototype and evaluate it on 11 real-world
Python programs. We have identied totally 46 real
bugs, and 16 of them were never found before. The
analysis time is reasonable.
The Essence of Our Technique. Symbolic/concolic anal-
ysis explore program state space leveraging concrete and
symbolic reasonings. The entire program state space can
be divided into three parts: (1) sub-space that is not ex-
plored (e.g., the concretized values in concolic execution);
(2) sub-space implicitly explored by the solver (e.g., sched-
ule variations in traditional predictive analysis); and (3)
sub-space explicitly explored by the engine not the solver
(e.g., path exploration in symbolic execution). Dierent
symbolic/concolic analysis dier in the distribution of the
three sub-spaces. For example, traditional symbolic/con-
colic execution engines (e.g., [18, 15, 16]), including those
for dynamic languages, explicitly explore individual program
paths. Along each path, they leverage the solver to implic-
itly explore variable values along the path. Explicit explo-
ration substantially simplies constraint encoding as only
one path is encoded at a time. State variations caused by
path variations do not need to be encoded. However, identi-
fying sophisticated exploration strategies and symbolic state
checkpointing/backtracking are challenging. Implicit explo-
ration can achieve eciency leveraging the built-in demand-
driven nature of constraint solving in modern solvers. Its
diculties lie in the complexity of constraint encoding.
Compared to existing symbolic/concolic execution, our
technique has the following unique features that make it
suitable for Python. (1) It encodes values, types, attribute
sets, paths, and their correlations so that the solver can be
leveraged to perform ecient implicit exploration, whereas
most existing techniques explicitly explore paths and do not
reason about type or attribute variations that are critical for
dynamic languages. (2) The user provides initial (passing)
executions to direct our system to the functionalities/com-
ponents in which they want to nd bugs. For each initial
execution, our technique encodes its neighboring state space
including paths not executed in the initial run. In other
words, one request (to the solver) allows implicit exploration
of all the executions in the neighborhood. This completely
avoids the highly demanding explicit path exploration. (3)
Modeling for the large number of external functions can be
substantially mitigated by trace preprocessing (Section 4.3).
2. MOTIVATING EXAMPLE
In this section, we use a simplied problematic Python
program to motivate our approach.
Fig. 1 shows the code snippet simplied from the very
popular Python HTTP library requests . The test driver
function test_post() invokes the function post at line 276#Input: url="http://httpbin/post",data={"some":"data"}
267 def test_post(url, data,...):
276 post2 = requests.post(url, data, ...)
277 self.assertEqual(post2.status_code, 200)
... # other 6 functions are omitted
# requests/models.py
87 def _encode_files(files, data):
98 new_fields = []
99 fields = to_key_val_list(data or{})
100 for field, val infields:
101 if not hasattr (val, â€™__iter__â€™) or
isinstance (val, str):
104 val = [val]
105 for vinval:
106 ifvis not None:
107 new_fields.append((field, v))
133 encode_multipart_formdata(new_fields)
# urllib3/filepost.py
42 def encode_multipart_formdata(fields):
61 body = BytesIO()
65 for fieldname, value initer_fields(fields):
84 if isinstance (value, int):
85 data = str(value)
87 if isinstance (value, unicode ):
88 writer(body).write(value)
89 else :
90 body.write(value)
Figure 1: A Motivating Example. (_encode_ï¬les() is an
internal function called during execution whose argument data comes
from the test input. Unrelated code is omitted for readability.)
and checks its return value at line 277. The input parameter
data can be a dictionary.
Suppose the input parameter data is{"some": "data"} .
The function call post () at line 276 invokes the function
_encode_ï¬les() (lines 87-133) transitively through a chain
that consists of six function calls (omitted for simplicity).
Line 99 converts the dictionary data into a list of pairs,
where each pair represents an entry of the dictionary. The
resultant list ï¬elds is[("some", data")] . Line 100 iter-
ates over the list and unpacks each pair to ï¬eld and val.
For the pair ("some", "data") , the unpacked ï¬eld andval
are"some" and "data" , respectively. Valis wrapped as
a list (line 104) if it is not iterable (i.e., without the at-
tribute \iter ") or is of the strtype (line 101). Here, val
is wrapped as a list since it is of strtype. Lines 105-107
then iterate over val, form a pair with ï¬eld and store the
pair into the list new_ï¬elds . In this example, new_ï¬elds
is[("some", "data")] .New_ï¬elds is then passed to the
function encode_multipart_formdata() as the parameter
ï¬elds . Lines 42-90 iterate over ï¬elds and check the value
in each pair. If it is not of the int(line 84) or unicode (line
87) type, e.g., it is the string "data" in our example, it is
written to the body (line 90).
The defect is at line 90. The method body.write() re-
quires the parameter to implement the buer interface. For
example, the strtype implements the interface while the
float type does not. If body.write() takes a oat value
(e.g., 0.0) as parameter, it will crash. Our approach is able
to compute the new input data,{"some": 0.0} , to trigger
such a crash.
The example illustrates a number of the inherent chal-
lenges in analyzing Python programs. Observe that all vari-
ables are dynamically typed such as value at line 90. Func-
tion parameters can also accept dierent types. Type er-
rors are only captured by crashes. This example is dicult
for static analysis as it involves a lot of container related
operations (e.g., the operations in _encode_ï¬les() ) which
require complex heap abstraction. This example also im-
122Figure 2: System Framework .
poses challenges to symbolic analysis. For example, the bug
manifests in a very deep call chain. The execution has a
lot of invocations to external functions, which require sub-
stantial eorts to model. In fact, the traced run for the ex-
ample executes more than 18000 Python statements, among
them there are about 2700 container operations and 99 re-
ection function calls. There are also 946 external func-
tions calls. In addition, we cannot analyze the function en-
code_multipart_formdata() in isolation. In fact, the func-
tion is also used in a library urllib3 , where its use is not
buggy since the library performs dynamic checks to ensure
the inputs are of the proper types during the function calls.
Our Solution. Our technique belongs to the category of
predictive analysis, which starts with the trace of an exist-
ing run and predicts a new feasible run. Given the trace
collected from the passing run with the input {"some":
"data"} , our analysis rst models the inputs, including their
values, types, and attribute sets, as symbolic variables to
denote possible input variations; then it encodes the execu-
tions possibly derived from the trace into constraints; next
it encodes the bug nding assertions, e.g., the value is not
of the type strorbytearray (for line 90), which implements
the buer interface; lastly it leverages a solver to compute
the input that triggers any assertion violation. In this ex-
ample, we compute the input data as{"some": 0.0} . The
predicted run follows the same path as the observed run to
reach line 90 and executes body.write(0.0) , which leads to
the crash.
Our approach fully supports dynamic typing and dynamic
attribute updates in Python. The readers may notice that
the input contains dierent types/attributes in the origi-
nal run and the predicted run (i.e., {"some": "data"} and
{"some": 0.0} ), and value at line 90 has dierent types/at-
tributes in the two runs. Our system introduces auxiliary
type/attribute symbolic variables to track type/attribute
information explicitly and supports type/attribute checks
(e.g., lines 84 and 87). In contrast, most existing symbolic
execution engines do not reason about type/attribute vari-
ations, and hence have diculties nding the bug.
Our approach not only encodes the current execution path
(as in many existing symbolic/concolic execution engines),
but also encodes the unexecuted branches together with the
path. For example, lines 85 and 88 were not executed in
the original run but our technique encodes them with the
original run so that the solver can explore these branches
implicitly. In contrast, existing symbolic/concolic engines
follow some strategy (e.g., depth-rst search) to explicitly
explore the unexecuted branches through many runs. De-
tails will be discussed in section 5.2.
Besides dynamic types and attribute sets, our approach
also supports other dynamic features such as reection calls
andeval() , leveraging the traces.3. SYSTEM FRAMEWORK
In this section, we give an overview of the system. As
shown in Fig. 2, it consists of two components: the tracing
component and the constraint encoding/solving component.
The tracing component takes a Python program and a
test input, and produces a trace of the execution. The trac-
ing procedure consists of three steps. First, the program
is run to collect all the involved modules and the string
parameters of the eval() function invocations, which are
loaded or constructed at runtime and are unknown at com-
pile time. This step essentially collects the complete set of
executed code. Second, we normalize the code (collected
from the modules and the eval() parameters) by breaking
the complex statements into simple statements. Finally, we
run the normalized program again to collect the trace. One
prominent challenge in tracing Python program execution
is to handle a large number of external function calls that
are implemented in other languages and have unknown side-
eects. Our tracing component also features an on-the-y
side-eect detection technique to handle external functions.
The constraint encoding/solving component takes three
resources as inputs, namely, the trace, the normalized source
code and the input relaxation specication1. Our sys-
tem reports bugs and the corresponding inputs that trig-
ger the bugs. The constraint system consists of four sub-
components: the bug predictor, the constraint encoder, the
event slicer and the SMT solver. The bug predictor sub-
component is a controller that scans the execution trace.
During the procedure, it may invoke the other three com-
ponents. When it nds a satisable solution, meaning a
bug, it will stop evaluating further. The constraint encoder
mainly performs three actions: (1) relaxing the encodings
of inputs according to the input specication such that the
encoding describes a much larger state space than the traced
execution; (2) encoding the execution trace to constraints;
(3) aggressively including the unexecuted branches to the
constraints whenever encountering a predicate event (in the
trace). A trace slicer is used to slice events on which a spe-
cic assertion event (i.e., the slice criterion) is dependent.
We provide the constraints of the slice to an SMT solver. If
it is satisable, we nd a bug and its triggering input. Oth-
erwise, our tool does not nd a violation to the assertion
and moves on to the next assertion.
4. TRACING COMPONENT
Similar to existing methods of predictive analysis [4, 5, 8],
we trace an execution based on 3-address instructions, which
are more suitable for constraint encoding than bytecode in-
structions. Our tracing component follows three steps to
collect trace. (1) It executes the program for the rst time,
and collects all the involved modules and string parameter
values for the exec() /eval() calls. (2) With the collected
modules and string values, it normalizes the source code to
a simplied form with each line only having one simple op-
eration. (3) After replacing the original modules with the
normalized versions, it re-executes the program and in the
meantime collects the execution trace.
4.1 Code Normalization
The ocial releases of Python have a built-in tracing API
sys.settrace allowing hooking the execution environment
1We put the specication design into our technical report for refer-
ence: https://sites.google.com/site/pypredictor/
123before executing each source code line, through which we can
perform a set of queries to the runtime environment, making
tracing and gathering runtime information very convenient
(e.g., querying values, types and attributes). However, the
API only allows tracing at the level of source code line, which
is problematic for our purpose as one source code line may
contain multiple statements and a long statement may cross
multiple lines. As a result, we need to normalize the source
code such that each line only contains a simple operation.
We perform the following three kinds of normalization.
Linearizing Nested Expressions. Nested Expressions are
prevalent in Python code, which combine multiple opera-
tions together(e.g., a.b.f()+x ). We linearize these nested
expressions into a group of simple assignments, each con-
taining one simple expression.
Eliminating Complex Constructs. Python has very expres-
sive syntax, so that complex semantics can be represented
concisely. While it provides convenience for programmers, it
creates diculties for analysis. Our system transforms these
advanced constructs to a small set of simple constructs. We
list several typical transformations as follows.
x = [f(i) for iinlst \
ifi>0]x = []
for iinlst:
ifi>0:
tmp = f(i)
x.append(tmp)
x = reduce (lambda a,b: a+b,\
lst)def v1(a, b):
v2 = a + b
return v2
x = reduce (v1,lst)
The rst row presents a concise method to construct a
list by applying a function f()to the loop index i, with the
transformed code on the right. The second row illustrates
how we transform a lambda expression.
Transforming eval() /exec() .Our system also replaces
eval() /exec() calls with the corresponding real code col-
lected earlier. Consider the following example.
#a.py
10: co = x + "=a"
11: exec (co)#records
ha#11;co;b =ai
ha#11;co;c =aico = x + "=a"
ifco == "b=a":
b=a
elif co == "c=a":
c=a
else :
exec (co)
The left column shows the original code that contains an
exec() call at line 11. The middle column presents the trace
records of this line, in which \ b=a" and \ c=a" are the values
of variable coin the two records. The right column shows
the corresponding code that our system uses to replace the
call. Observe that we use branches to handle the dierent
statements induced by the dierent values of co. We also
reserve the original exec(co) in the else branch to ensure
soundness. With the transformed code, we now can trace
the execution of the original exec() call.
4.2 Trace Generation
After replacing the involved modules with the normalized
ones, we now re-execute the program to gather the execution
trace. Tracing Python program execution is more challeng-
ing than tracing programs in many other languages because
the execution of a Python statement may have many implicit
side-eects, such as type changes and attribute set changes.
All these need to be explicitly captured as many bugs are
related to these implicit side-eects. Next, we rst introduce
some notations and then illustrate the tracing rules.v2Value  2Type x2Var `2Label
l2HeapLoc ::=ValueAttr
A2AttrSet ::=Attr
TTypeSet ::= (P(Type );4)
 2Trace ::=heid;s; (v;;A );`i
2ValueStore ::=VarjHeapLoc7!Value
2TypeStore ::=VarjHeapLoc7!Type
2AttrSetStore ::=Value7!AttrSet
Fbaset () returns the default attribute set of type ;
Fbtype (1;2;bop) returns the type for the computation on
1bop  2.
Findex (v) returns the index of next iteration for a for-loop.
Figure 3: Denitions Related to Tracing Rules
Statement s ::=
z=`jxj(x op y )j(basic assignments)
y=`x:fj(attr-read)
y:f=`xjvj(attr-write)
if(x relop y )`s1elses2j(cmp-predicate)
ifisinst (x;t)`s1elses2j(isinst-predicate)
ifhasattr (x;f)`s1elses2j(hasattr-predicate)
y=f`(a1;:::;an)jx:m`(a1;:::;an)j(callsite)
Figure 4: Python Statements
Fig. 3 presents the denitions related to the tracing rules.
Basically,vrepresents an arbitrary value. Note that every
value in Python is essentially an object, so the value here
means an object; Arepresents an attribute set which consists
of attributes; Trepresents all the types as well as the class
hierarchy of these types ( 4denotes the subtype relation); 
denotes the value store mapping a variable or a heap location
to a value; represents a type store mapping a variable or
a heap location to a type; denotes an attribute set store
mapping a value to an attribute set, representing the set of
attributes of a value (or object); Fbaset represents a function
returning the default attribute set for a specic type; Fbtype
returns the type of a binary operation; Findex returns the
index of the next iteration of a for-loop. The execution of a
Python program in our system is a procedure of dynamically
updatingT,,and.
Trace and Events. We model a few Python statements
in our presentation shown in Fig. 4. Some of the symbols
are dened in Fig. 3. For example, `stands for a label that
is similar to the source code line number. Observe that we
model two specic predicates: the type check ( isinst ()) and
the attribute check ( hasattr ()). The rest is standard.
An execution trace  is a sequence of events recorded
during the execution. An event is an execution instance
of a statement, denoted as a tuple heid;s; (v;;A );`iwhere
eidrepresents a unique identier; sdenotes the statement;
(v;;A ) represents the involved value, type and attribute
set by the execution of the statement. Note that besides the
valuev, we also record the type and attribute set of each
execution of the statement as they may be changed.
Tracing Rules. Table 1 represents the tracing rules for
a set of commonly used Python statements. The rst four
rules specify four typical object creation statements. More
specically, rule ( class-def ) represents the tracing of a
class denition statement, which creates and initializes a
new class object. It creates a class object o1and associates
it withC. It also creates a method object o2, associated with
themattribute of o1. The attribute \ m" is added to the at-
tribute set of the class object o1.MethodType andClasstype
are two built-in types in Python. CType andBType are sym-
bols generated by our system to denote the types of class C
andB. As shown in the last column, the system generates
two eventse1ande2wheree1represents the class object cre-
ation ande2represents the setup of the method in the class.
124Rule ( func-def ) species the rule for a function denition.
It creates a function object and then assigns it to variable
f. The corresponding trace event is straightforward. Rule
(list-alloc ) represents the tracing for creating a list ob-
ject. It rst creates a list object o1assigned to yand then
appends two elements to it ( o10 represents the rst ele-
ment). Accordingly, our system generates three events e1,
e2ande3withe1creating the list object, and e2ande3set-
ting the elements. Rule ( class-instant ) represents object
creation through class instantiation. It creates a new object
o1and assigns it to y. The attribute set of o1is inherited
from the object associated with the class C.
Rules ( simple-assign ), (bop-assign ), (attr-read ) and
(attr-write ) are standard. Particularly, the execution of
an attribute write statement may dynamically change the
attribute set of the object. Rule ( for-loop ) species the
tracing for the next-iteration operation of a for-loop state-
ment. The rule only species the situation in which the
object is a collection (e.g., list, tuple). Rule ( if-cmp ), (if-
isinst ) and ( if-hasattr ) specify the tracing rules of three
dierent kinds of branch predicates. In Rule ( call), we
record two events, one for parameter passing and the other
for the call itself.
4.3 Handling External Functions
Function calls to external libraries are prevalent in Python
programs. We cannot easily trace the execution of these li-
braries due to the lack of source code. However, if we do not
trace their execution, the resulting trace is incomplete espe-
cially when these functions have side-eects on heap, leading
to unsoundness of our later symbolic analysis. One way is
to manually model the external functions. However, this re-
quires tremendous eorts due to the sheer volume of these
functions. Hence, our strategy is to manually model the
commonly used external functions. For the others (which
are still in a large number), we develop a technique to detect
side-eects such that we handle them to avoid unsoundness.
Next, we focus on discussing side-eect detection.
To detect side-eects, we maintain a value store :
VarjHeapLoc7!Value recording the current value of each
variable. The value store is only updated when the Python
code is executed. In other words, it is not updated by exe-
cution of external functions. When a variable is used in the
Python code, we compare the value from the store with
the observed value from store . If the two are dierent,
there must be side-eects by some external function call(s).
1: x.f = 1
2: y=extfunc(x)
3: z = x.fve [[x]:f]
vr [[x]:f]#here,vr=1
if ve=vr:
 ! ;hz=x:f;(1;:::)i
else:
 ! ;hx:f=ve;(ve;:::)i
 ! ;hz=ve;(ve;:::)i
![z7!ve]
Line 2 of the left column shows an unmodeled external
function call, which has side-eects on x. When tracing the
execution of line 3, we use the rule shown in the right col-
umn. We rst get the current value veof the heap location
pointed-to by x:ffrom the execution environment ( ), which
is updated by both the Python code and the external func-
tion, and then query the recorded value of x:ffrom, which
is only updated by Python code. If veis equal to 1, we treat
it as an attribute read event. Otherwise, we concretize both
the values of x:fandzdue to the invisible side-eects that
we cannot model, which essentially under-approximates theSource Code Trace
1: x = input ()
2: y = C() #new object o1
3:if isinstance (x, int):
4: y.f = "S"
5:else :
6: y.f = 2
7: z = y.f
8: w = z.lower()hx= 1;(1;int;Aint)i
hy=o1;(o1;C;Ao1)i
hif isinst (x;int );:::i
hy:f= \S";(\S";str;Astr)i
hz=y:f;(\S";str;Astr)i
hw=z:lower ();:::i
Figure 5: An Example Illustrating the Challenges
program state by xing the input and output values of the
external function. On the other hand, it ensures soundness.
5. CONSTRAINT ENCODING
Our technique is essentially a kind of predictive analy-
sis [4, 5, 6]. As mentioned in Section 1, predictive analysis
is based on the observed execution traces and can easily an-
alyze the very long executions similar to the observed traces.
Leveraging traces also allows mitigating the problems caused
by dynamic features. While most existing predictive analy-
ses explore dierent schedules of a concurrent execution and
prohibit path changes, our technique explores the program
state space caused by input variations, which may cause dif-
ferences of execution paths and heap states. Such possible
dierences are encoded as constraints and an SMT solver is
leveraged to explore the encoded state space to nd bugs.
Our technique is sound, meaning that it does not produce
false positives2. Now we introduce the main challenges in
encoding Python programs for predictive analysis.
(1) Dynamic typing in Python makes the type of a variable
path sensitive, which means the same variable at the same
program point may have dierent types depending on the
execution path. However, symbolic variables in constraints
are statically typed. Existing static encoding techniques of-
ten project a program variable (in its SSA form) to a sym-
bolic variable in the constraint system. Such a method is no
longer applicable. Note that the SSA form does not help in
our context because even though the SSA form can express
a variable having dierent types at dierent locations (by
introducing multiple variables for each denition location),
it cannot handle that a variable may have dierent types
even at the same location. Note that the problem does not
exist for symbolic execution or concolic execution as these
techniques encode one path at a time.
(2) Besides encoding the value of a variable like in most
existing work, we have to explicitly encode the type and
the attribute set of a variable (or object) in order to reason
about such features.
(3) Some bugs can only be triggered when the execution
goes through a path dierent from the trace. Therefore,
to predict such kind of bugs, we should also include the
unexecuted branches into the constraint model.
Example. We use an example in Fig. 5 to illustrate the
above challenges. The left column is the code snippet. Line
1 represents the initialization of xwhich may accept a value
of various types (e.g., int and string). Line 2 creates a new
object of class C, denoted as o1. Line 3 is a type check
predicate. If xis of the int type, it writes a string \ S" to
the attribute \ f" of o1. Otherwise it writes the integer 2.
Note that, the initial attribute set of o1does not contain
the attribute \ f", so the execution will dynamically add it
to the attribute set of o1. Line 7 reads the attribute and
2We put the proof in our technical report: https://sites.google.com/
site/pypredictor/
125Table 1: Tracing Rules for Typical Statements
Rule Statement Execution States Events( eidand`omitted)
(class-def)class C(B):
def m(self, x):
self.x = x![C7!o1=newobject ();
o1:m7!o2=newobject ()]
![C7!ClassType;
o1:m7!MethodType ]
![o17!Fbaset (ClassType )[f\m"g;
o27!Fbaset (MethodType )]
T!T[fCType 4BTypege1:hC=o1;(o1;[C];[o1])i
e2:hC:m=o2;(o2;[o1:m];[o2])i
 ! ;e1;e2
(func-def)def f(x):
return x![f7!o1=newObject ()]
![f7!FuncType ]
![o17!Fbaset (FuncType )] ! ;hf=o1;(o1;[f];[o1]i
(list-alloc) y=[1,2]![y7!o1;o107!1;o117!2]
![y7!list;o 107!int;o 117!int]
![o17!Fbaset (list)]e1:hy=o1;(o1;list;Fbaset (list))i
e2:hy0=1;(1;int;Fbaset (int))i
e3:hy1=2;(2;int;Fbaset (int))i
 ! ;e1;e2;e3
(class-instant) y=C() # C is a class![y7!(o1=newObject ())]
![y7!CType ]![o17![[C]] ! ;hy=o1;(o1;CType; (C))i
(simple-assign) y=x ![y7!(x)]![y7!(x)]  ! ;hy=x;((y);(y);((y)))i
(bop-assign) z=x bop y![z7![x]bop  [y]]
![z7!Fbtype ([x];[y];bop)]
![(z)7!Fbaset ([z])] ! ;hz=x bop y; ([z];[z];[[z]])i
(attr-read) y=x.f|y= getattr (x, â€™fâ€™) ![y7![[x]:f]]![y7![[x]:f]] ! ;hy=x:f;([y];[y];[[y]])i
(attr-write) y.f=x| setattr (y,â€™fâ€™,x)![[y]:f7![x]]![[y]:f7![x]]
![[y]7![[y]][f\f"g] ! ;hy:f=x;([x];[x];[x])i
(for-loop) for xiny...i Findex ([y])
![x7![[y]i]]![x7![[y]i]] ! ;hx=yi;([x];[x];[[x]])i
(if-cmp) if(x relop y)... r ([x]relop  [y])  ! ;hrelop (x;y);(r;bool;Fbaset (bool))i
(if-isinst) if(isinstance (x, list ))...r ([x]4list)  ! ;hisinst (x;list );(r;bool;Fbaset (bool))i
(if-hasattr) if(hasattr (x, â€™fâ€™))... r (\f"2[[x]])  ! ;hhasattr (x;\f");(r;bool;Fbaset (bool))i
(call) y=f(a) ![b7![a]]![b7![a]]
(b is the formal parameter )e1:hb=a;([a];[a];[[a]])i
e2:hy=f(a);([[a]:f];
FuncType;Fbaset (FuncType ))i ! ;e1;e2
assigns it to z. Line 8 calls a method lower() ofz. The
bug will occur when the else branch is taken because the
value of zis of the int type and does not have the lower()
method. However, the bug does not manifest itself when the
true branch is executed.
From the example, we observe that zat line 7 may have
dierent types depending on the path and SSA cannot ad-
dress the problem. To reason about the predicate at line 3
and the bug at line 8, we need to explicitly encode the types
and attribute sets. Assuming the trace is along the true
branch, to expose the bug, we also need to encode the else
branch, which may not be taken in the observed execution.
5.1 Encoding Scheme
Next we explain our encoding scheme from dierent as-
pects.
Using Multiple Symbolic Variables to Denote the Value of
a Python Variable. We use multiple symbolic variables (of
dierent types) to represent the value of a Python variable
of dierent types. More specically, given a Python variable
x, we use a set of symbolic variables in the form of  
to
denote its value of type . The superscript indicates this is
a symbolic variable for value . For example, if xcan be an
integer or a string, we use two symbolic variables  
int(x) and
 
str(x) to denote its value. For a statement sinvolvingx,
both symbolic variables are updated to encode the possible
behavior of swhenxhas dierent types.
Explicitly Reasoning about Types. To encode the dynamic
typing behavior, we introduce a new symbolic variable  (x)
to represent the type of the variable x. The superscript indi-
cates this is a variable for type. We support equivalence and
non-equivalence checking, and sub-typing on the values of
these variables. We encode the subtype relation as a partial
order between types, which is supported by the solver.
Explicitly Reasoning about Attributes . We introduce sym-
bolic variable  (obj) to represent the attribute-set of anobjectobj. Note that the attribute sets are associated with
objects instead of variables following the Python memory
model. In particular, if xandyare aliases through the
assignment y=x, then the statement x:f=:::adds the at-
tribute\f"to the object that both xandycan reference. We
represent the attribute set as a set in the constraint system
and support the membership operation.
Encoding Rules. Before encoding, we rst transform the
trace into its single static assignment (SSA) form so that
every variable is dened exactly once. We use xito denote
the denition instance of xat trace entry i. We also ex-
tend the trace with statements from unexecuted branches
(see Section 5.2). As such, -functions are also introduced
to integrate denitions from two branches of a conditional
statement at the join point. Table 2 shows the encoding
rules for the typical events.
Rule (1) species the encoding for the assignment with
a constant. The symbolic value variable  
(zi) is asserted
to the value v. The symbolic type variable is asserted to
type, and the object created to represent the value of zi,
which is acquired by a function obj(zi), is asserted to have
the attribute set A.
Rule (2) species the encoding for a simple assignment. In
the encoding, since we introduce a set of symbolic variables
of dierent types to denote the value of a program variable
of various types, for each type , we assert the equivalence of
the corresponding (symbolic) value of ziandxj. This rule
does not aect the attribute set, which is associated with
the object instead of the variable.
Rule (3) encodes the addition operation. The basic idea
is that for each type having the addition operation, we en-
code its behavior. For simplicity, we assume the solver only
supports additions for int and string types. As such, the
rst two clauses assert integer addition and string concate-
nation, respectively. The third one encodes additions that
are not supported by the solver such that we cannot reason
126Table 2: Encoding Rules. The events are in the SSA form with the superscript of a variable xrepresenting the id of the event where x
is most recently dened. obj(x) represents the object created for variable x. (x), (x), and (x) represent the symbolic variables denoting
value, type, and attribute set for a program variable/value x. Each type means each possible type of x.type(o) denotes the type of object o.
SSA Formed Event( ei) Encoded Symbolic Constraints
(1)hzi=v;(v;;A )i 
(zi) =v^ (zi) =^ (obj(zi)) =A
(2)hzi=xj;:::i (V
each type 
(zi) = 
(xj))^ (zi) = (xj)
(3)hzi=xj+yk;(v;;A )iif 
 (xj) =int^ (yk) =int
) 
 
int(zi) = 
int(xj) + 
int(yk)^ (zi) =int^ (obj(zi)) =Aint
elif 
 (xj) =str^ (yk) =str
) 
 
str(zi) =concat ( 
str(xj); 
str(yk))^ (zi) =str^ (obj(zi)) =Astr
else 
 
(zi) =v^ (zi) =^ (obj(zi)) =A
^ 
type(obj(xj))(xj) =obj(xj)^ 
type(obj(yk))(yk) =obj(yk)
(4)hif isinst (xj;);:::i (xj)4
(5)zi=(ek;zt;zf)(ek)) 
(^
each type 
(zi) = 
(zt))^ (zi) = (zt)
^
:(ek)) 
(^
each type 
(zi) = 
(zf))^ (zi) = (zf)
(6)hyi=xj:f;:::iV
o2pts(xj) 
 
type(o)(xj) =o))((V
each type 
(yi) = 
(o:fk))^ (yi) = (o:fk)
(7)hyj:f=xk;:::iV
o2pts(yj)( 
type(o)(yj) =o)) 
(^
each type 
(o:fi) = 
(xk))^ (o:fi) = (xk)^ (o)0= (o)[f\f"g
^
( 
type(o)(yj)6=o))((^
each type 
(o:fi) = 
(o:fp))^ (o:fi) = (o:fp)^ (o)0= (o))
(8)hif hasattr (xj;\f");:::iW
o2pts(xj)( 
type(o)(xj) =o)^(\f"2 (o))
about their value variations. We assert the value, type, at-
tribute set of zito the observed ones. More importantly, we
also need to assert the operands xjandykmust hold their
observed values to ensure soundness.
Rule (4) encodes a type check predicate. It simply asserts
the type of the variable is a subclass of the intended type .
Rule (5) species the encoding for the function that joins
the updates of a variable in the two branches of a predicate:
ziis equal toztif the predicate ekholds, and is equal to zf
otherwise, where ztandzfare the most recent versions of z
inside the branches. In the encoding, all the symbolic value
and type variables are updated according to the encoding
ofek, denoted as (ek). The encoding of object attribute
sets is also handled path-sensitively, similar to functions
for variables. In other words, we also join the attribute sets
of an object in a path sensitive fashion at a merge point of
branches. Details are elided.
Rule (6) encodes an object attribute read. The encoding
relies on a pre-computed points-to set pts(xj) representing
the set of objects that may be pointed to by xj. We use
the Anderson algorithm [10] to compute the may points-to
set on the trace (extended with the un-executed branches).
Intuitively, our extended trace can be considered as a pro-
gram with loop unrolled and dynamic features uncovered.
In the encoding, for the object oin the points-to set that xj
actually points-to, we assert the equivalence of the values of
o:fkandyiand the equivalence of their types. Note that
the superscript kdenotes the most recent denition point of
o:f. Function type(o) represents the type of object o.
Rule (7) encodes an object attribute write. For the object
opointed-to by yj, we assert the equivalence of both the
values and types of o:fiandxk. Besides, we assert the new
attribute set is the union of the old attribute set and the
\f". If the object is not pointed to by yj, we assert the value
and type, and the attribute-set of the base object stay the
same. Note that the superscript iandpdenote the current
and the most recent denition points of the object attribute,
respectively. We use  (o)0to denote a new dened version
of the symbolic attribute set of o.
Rule (8) encodes an attribute check. For any object oin
the points-to set of xj, if the object referred to by xjequals
o, the attribute \ f" must be in the attribute set of o.Handling Solver Unsupported Types. Python sup-
ports many more types compared to those supported by the
solver. In our encoding rules, we do not specify the details of
handling solver unsupported types for space reason. In fact,
we treat the values of solver unsupported types as objects
denoted by IDs. We only reason about equivalence and non-
equivalence of object IDs. This is consistent with existing
work of predictive analysis [8, 7].
5.2 Unexecuted Path Relaxation
To allow reasoning about possible path changes induced
by input variations, we need to include the unexecuted
branches to our constraint system. The basic idea is to en-
hance the observed trace to aggressively include statements
in unexecuted branches as long as those statements can be
fully resolved by static analysis. We preclude the unresolved
branches by asserting the branch outcome as the observed
one. This ensures the soundness of our analysis, although it
limits the coverage. Next, we explain how we determine if
an unexecuted statement can be resolved.
Assignments. Constant assignments x=vcan always be
resolved and encoded. For a simple assignment y=x, our
analysis rst looks for the most recent denition of x. If it
may be dened in an unresolved branch, which was hence
not encoded, we consider the variable xunresolved. As a
result, the assignment and the whole branch are also unre-
solved. Assignments of binary operations like z=x+yare
handled similarly.
Conditionals and Loops. For a conditional statement ifx>
y s1elses2inside an unexecuted branch, we rst try to
resolvexandyand thens1ands2. If any of these cannot be
resolved, the conditional is not resolved, except the following
case. Ifxandycan be resolved, and one of the branches
can be resolved, say s1. We encode s1and assert the branch
outcome to be true. For a loop statement in an unexecuted
branch, we require the loop bound can be statically resolved
as constant.
Calls. For a function call in an unexecuted branch, we must
ensure it is not a recursive call or an unmodeled external
function. If this is satised and the callee can be resolved,
we say the invocation can be resolved. If a call statement
has multiple possible callees and only some of them can be
127Source Code Trace(Instruction)
1:x = [1, 2]
2:y = [3]
3:ifa > 0:
4: x = y
5:ifb > 0:
6: y = x
7: for iiny:
8: t = i
9: z = y10:x1= [1,2]
11:y2= [3]
12:ifa0> 0:
13:x4=y2
14:x5=(a>0;x1;x4)
16:b <= 0
17:z8=y2
Figure 6: Unexecuted Path Relaxation.
resolved, we assert the call target falls into the set that can
be resolved. We do not handle try-except statements. If we
encounter any such statements in an unexecuted branch, the
branch is considered unresolved.
Example. Consider the example in Fig. 6. The left column
is the source code and the shaded statements are executed
by the observed run. Lines 4 and 6-8 are not executed. The
right column shows the intermediate SSA form of the trace
after we extend it with the unexecuted branches. Note that
we are able to resolve and add line 4 as ycan be resolved.
As a result, a statement is added at line 14. In contrast,
the branch consisting of lines 6-8 cannot be resolved as we
cannot statically resolve the loop bound yat line 7. As such,
we assert the branch outcome of line 5 to be false.
5.3 Constraint Solving for Bug Detection
After the extended trace is fully encoded, we further add
assertions for bug detection before the constraints are passed
to the solver. While the user can come up various cus-
tomized bug detection assertions. In our current system,
we mainly focus on two kinds of assertions.
Subtype Assertion. Subtype assertion is used to detect
type errors. More specically, we assert if the type of a
variable may fall out of an acceptable range. For example,
suppose the acceptable types of variable xincludeintor
str. We assert:( (x)4int_ (x)4str). For operations
involving multiple variables, we check the type combinations
of these variables. For example, for a binary operation z=
x+y, the Python interpreter does not allow the addition of
a string and a number. Therefore, we assert xis an integer
andyis string or vice versa.
Attribute Assertion. Attribute assertion is used to check
if a non-existent attribute may be read. More specically,
for an attribute read y=x:f, let points-to set pts(x) =
fobj1;:::;objng, we check if there exists objt2pts(x) that
satises: (1) there is a feasible path making x=objtsatis-
able, and (2) objtdoes not contain the attribute \ f".
We send all the constraints to the solver. If the result is
SAT, we nd a bug and its triggering input.
6. EVALUATION
We have implemented a prototype in Python. The system
mainly consists of a tracing infrastructure and a constraint
encoding and solving component. As mentioned in earlier
sections, Python programs tend to use a lot of external func-
tions and classes implemented in other languages. We man-
ually modeled a set of commonly used external functions by
rewriting them in Python. We use Z3 as the SMT solver.
To improve scalability, we also implement a dynamic slicer
to prune unrelated trace entries for a given assertion. We
make our prototype along with the evaluation environment
publically available at [27].Our evaluation aims to address the following questions:
RQ1: How eective is our approach in detecting potential
bugs for real world Python projects?
RQ2: How ecient is our approach? Can it scale to real
world programs and executions?
RQ3: How applicable is it to use the test cases provided
in the projects as the observed runs? Can our approach
detect more bugs by increasing test coverage?
To answer the above research questions, we apply our ap-
proach to a set of real world Python projects, as shown in
Table 3 (columns 1-2). These benchmarks are mainly from
GitHub. All of them are highly ranked in popularity and
widely used in practice. To select these benchmarks, we
went through the ranking of popularity and bug reports, and
selected those that have the highest ranking and at least one
reproducable bug report. We also considered diversity dur-
ing selection. Observe that some of them are large. The
largest one has over 84K source lines of Python code. The
sum of the source code lines of these projects is about 164K.
These projects fall in the following application domains,
which are representative for Python programs:
Requests andurllib3 - very popular HTTP libraries.
Fabric and salt - well-known remote deployment and
system administration applications.
Flask ,bottle andweb2py - widely used Web application
development frameworks.
Tweepy ,boto andpraw - well known web service APIs.
Bs4- a very popular HTML and XML parsing library.
Our experiments were conducted on a machine with an
Intel i5-4210U, 4GB RAM, Ubuntu 14.04, and Python 2.7.4.
6.1 Experimental Results
Table 3 shows the experimental results. For each program,
we rst run the (passing) test cases provided as part of the
project and then encode these traces together with unexe-
cuted branches to nd bugs. In Table 3, we only report the
statistics for those test runs that allow us to identify bugs.
Trace and Constraints. Column 3 ( Mod) presents the
number of modules executed, which ranges from 2 to
36. Note that we have excluded some uninteresting mod-
ules such as those related to logging and multiprocessing.
Columns 4-7 report the number of instructions that fall into
some popular categories, namely, attribute reads ( AttrR ),
attribute writes ( AttrW ), predicates ( Pred) and calls. Col-
umn 8 presents the total number of events in the trace. Ob-
serve that many of these executions are long. The longest
execution has over 70K events.
Column 9 ( AP) presents the number of events encoded
when reaching the buggy assertion point. Recall that our
system adds assertions in order to nd bugs (Section 5.3).
Column 10 ( ExtE) presents the number of unexecuted state-
ments that are added to the encoding in column 9. Observe
that our technique was able to resolve a lot of unexecuted
branches, allowing us to explore a large number of neigh-
boring executions of the observed run. Column 11 ( Cons)
presents the total number of constraints when reaching the
assertion of the violation, which ranges from 41 to over 135K.
Detected Defects (RQ1). Our system is able to detect
a set of bugs for these programs. The reported bugs are
all true positives. Column 12 presents the bug issue ids if
available. The issue ids prexed with * are the new bugs
that have not been reported before. We reported these new
defects to the developers through the bug tracker of Github
128Table 3: Statistics of Experimental Results
(a)Benchmarks (b)Trace (c)Constraints (d)Defects (e)Time(sec)
Name SLOC Mod AttrR AttrW Pred Calls Events AP ExtE Cons. Issue# Count Tracing Solving Total
requests 9934 36 1257 2506 1022 1331 18558 6468 1223 11461 1462 8+4 6.89 84.74 91.63
8 126 37 72 107 982 71 0 144 2077 0.62 0.83 1.45
35 1680 3566 1537 1738 26436 8107 1445 14378 1711 9.31 96.08 105.39
31 1159 2360 968 1230 17225 11980 2494 20965 1082 5.12 121.52 126.64
30 1350 10097 1108 1406 42092 7309 1318 12886 1324 8.3 78.96 87.26
33 1285 10192 1078 1320 41707 10656 2201 18669 1019 8.03 106.71 114.74
34 975 2449 830 1155 15943 7852 1460 13763 2613 11.9 98 109.9
10 86 223 101 160 1801 71 5 139 2267 1.27 1.87 3.14
11 140 258 144 196 1257 2819 651 4887 *2527 0.97 29.1 30.07
12 266 353 232 330 3708 4467 878 7910 *2552 1.59 42.03 43.62
29 902 1942 782 1059 13623 6734 1261 11781 *2638 6.31 84.4 90.71
35 982 2348 834 1161 15666 2824 534 5093 *2639 6.64 40.4 47.04
urllib3 4798 7 41 38 20 43 406 168 15 324 355 2 0.31 1.52 1.83
10 347 8695 310 387 28801 505 69 836 143 4.29 6.88 11.17
fabric 2995 10 188 143 179 169 2318 289 33 609 1204 6+1 1.61 4.2 5.81
6 31 25 13 32 302 243 17 482 610 0.24 3.32 3.56
2 6 0 4 7 57 30 3 55 1096 0.06 0.69 0.75
4 6 0 5 7 57 30 3 55 1096 0.07 0.63 0.7
3 20 14 14 11 168 111 18 195 1191 0.28 1.24 1.52
2 9 0 8 6 71 57 15 100 1096 0.08 0.83 0.91
3 21 14 15 16 171 117 23 196 *1303 0.15 1.64 1.79
salt 84789 13 1264 330 594 863 7341 12667 5368 17978 5959 6+7 12.26 49.85 62.11
13 2438 2806 1970 2058 30099 10930 2436 18988 11873 13.3 106.91 120.21
14 1298 356 630 903 7736 12869 5432 18327 12651 7.15 89.9 97.05
5 19 11 11 15 160 23 2 41 6817 0.49 0.35 0.84
19 2296 694 1320 1533 15385 13122 5436 18837 12453 9.76 90.1 99.86
4 9 25 11 27 198 227 29 398 8635 0.4 2.42 2.82
14 1303 358 632 906 6696 12781 5290 18184 *22547 6.99 88.66 95.65
14 1341 306 644 942 7728 12515 5359 17689 *s22547 9.55 109.24 118.79
15 1344 304 648 927 7686 12635 5414 17834 *24820 11.36 122.27 133.63
15 1817 904 1148 1678 15291 17563 6540 26468 *25006 10.47 129.33 139.8
15 1818 904 1149 1678 15295 14110 5566 20702 *s25006 10.99 106.3 117.29
15 1817 904 1149 1678 15290 17571 6540 26486 *s25006 9.64 128.11 137.75
19 1591 599 837 1433 11678 15398 6028 22692 *s25006 11.11 156.91 168.02
ask 2645 9 2206 1014 1650 941 15975 21497 5696 33615 857 2 13.01 351.72 364.73
25 10142 2456 4320 2333 70361 76215 8210 135908 237 67.23 1549.81 1617.04
bottle 3003 4 150 104 99 156 1625 1468 214 2680 223 1 0.71 18.03 18.74
web2py 2 16 13 8 14 125 48 7 80 11/01/12 1+1 1.28 1.32 2.6
2 5 6 11 7 80 68 17 101 *968 3.97 1.29 5.26
tweepy 2394 19 68 198 69 112 1316 1483 218 2748 12/22/13 1+1 1.25 26.9 28.15
7 9695 1840 3707 5284 61571 67406 5899 121255 *642 36.25 1165.21 1201.46
boto 47904 18 265 265 158 45 2619 2766 535 4840 03/19/12 1 3.07 70.19 73.26
praw 3034 4 87 152 86 68 1324 19 4 38 87 1 7.22 0.4 7.62
bs4 2718 7 41 42 77 79 771 44 10 79 1307471 1+2 0.53 0.68 1.21
5 83 50 101 83 921 171 47 254 *1463984 0.64 3.42 4.06
5 66 42 81 75 783 160 44 244 *1463984 1.34 3.17 4.51
Total 164214 - 30+16=46 -
orlaunchpad . Most of them have been conrmed and even
xed. Id \ *s22547 " means that the root cause of the bug is
very similar to that of issue \ 22547 ". There are three known
bugs that we cannot nd the issue numbers. Instead, we
provide the commit records. Column 13 presents the number
of the detected defects. Note that our approach is eective,
identifying 46 defects with 30 known and 16 new.
Analysis Time (RQ2). Columns 14-16 present the tracing
time, solving time, and total time, respectively. The solving
time is the sum of the many queries to the solver regarding
the bug identication assertions. From the results, we argue
that the cost of our approach is reasonable. It detects most
of these defects in a few seconds to a few minutes. The most
time-consuming case is issue 237 of flask , which took about
27 minutes to process. Further inspection shows that it is
due to the long execution trace.
Fault Detection Capability versus Test Coverage
(RQ3). The detection capability of our approach largely
depends on the observed runs. In our experiment, we mainly
choose the test cases along with the projects as the seed runs.
The reason is that test-driven development is pervasive in
programming with dynamic languages. As such, there are
often many test cases along with Python projects.
We randomly choose 100 passing test cases from the test-
suites of two benchmarks, requests and salt, which have
the largest number of defects. We then study how the accu-
mulative number of detected bugs grows with the test cover-
age. Fig. 7(a) shows the result. Note that here we measurestatement coverage. The result reveals a close-to-linear rela-
tion between the two. We hence argue that our approach can
detect more defects with more test cases to achieve better
coverage. In some sense, these test cases drive the execution
to interesting places and our technique reasons about bugs
in the neighboring executions. Fig. 7(b) shows the accumu-
lative analysis time of our system. Observe that the growth
is steady and the total time is reasonable.
6.2 Defect Study
To better understand the common patterns of defects in
Python programs, we further examine these reported bugs
and classify them into three categories as shown in Table 4.
Attribute Errors. 23(50%) of the detected defects cause
AttributeError crashes, which mean that the execution ac-
cesses a nonexistent attribute. In Python programs, it is
possible that an attribute is added to the object in one path
but not in another path. Developers may forget the latter
path and access the attribute which does not exist.
More specically, there are 6 such defects in requests
with 2 new defects. Consider the new issue 2527. Pre-
paredRequest.copy() invokes the copy() method of object
self._cookies , which is passed from some high level API
(e.g., the instantiation method of class Request ). Unfortu-
nately, some of these APIs may not add the copy() method
to the attribute set. There are 2 attribute defects in fab-
ric. For instance, in issue 610, the key_ï¬lename() function
of the network.py module checks if env.key_ï¬lename is an
129(a) Coverage and Defects
(b) Time Overhead
Figure 7: Bug Detecting Capability along with Cov-
erage
instance of list type. If not, it will wrap env.key_ï¬lename
into a list. Later on, it reads the \ startswith " attribute
of each item in the list. Our approach nds that the
program will crash with an AttributeError raised when
env.key_ï¬lename is initialized as another iterable type ob-
ject (e.g., a set). This is because the program wraps the
set object into a list and reads the \ startswith " attribute
of the set object, which does not exist.
Type Errors. 3 (6:52%) of the detected defects cause
TypeError crashes, which occur when a parameter of an
invalid type is passed to a built-in function or when a bi-
nary operation has unmatched operands. The type error
bug in requests is shown in Fig. 1 and discussed. The bug
insalt occurs if the parameter passed to time.sleep() is
not of a number type (e.g., int and oat).
Unicode Errors. 20 (43:48%) of the reported de-
fects cause UnicodeEncodeError orUnicodeDecodeError
crashes. Unicode errors are very common in Python appli-
cations, especially in Web related applications. The Python
2.x interpreter implicitly casts a byte string to a unicode
string during certain operations (e.g., concatenation be-
tween a byte string and a unicode string). However, such
casting crashes if the input string contains non-ascii charac-
ters. Specically, we have found 5 such bugs in requests ,
and 2 of them are new bugs. In issue 1082, requests pro-
vides a set of HTTP APIs (e.g., get/put) that support val-
ues of dierent types for the parameters headers anddata.
Both parameters allow unicode and byte strings. The pro-
gram crashes when headers contains a unicode string (e.g.,
headers={uâ€œContent  Type": ...} ) and data contains a
byte string with non-ascii characters. This is because an in-
ternal method _send_output() of module httplib.py con-
catenates them, triggering the implicit cast and causing the
crash. We have also found unicode bugs in salt, all of which
are not reported before.
7. RELATED WORK
Our approach belongs to the category of predictive anal-
ysis [4, 5, 8]. Existing predictive analyses were originally
used in concurrency program analysis, such as race detec-
tion [4, 5, 6, 7] and atomicity violation detection [8]. They
focus on changing the schedules to explore dierent execu-
tions. Dierently, our approach is the rst to change inputs
to explore dierent executions. Besides, our approach allows
the exploration of the unexecuted branches, while existingTable 4: Classications of Detected Defects
Benchmarks AttributeError TypeError UnicodeError
Known New Known New Known New
requests 4 2 1 0 3 2
urllib3 2 0 0 0 0 0
fabric 2 0 1 0 3 1
salt 5 1 1 0 0 6
ask 1 0 0 0 1 0
bottle 1 0 0 0 0 0
web2py 0 0 0 0 1 1
tweepy 0 0 0 0 1 1
boto 1 0 0 0 0 0
praw 1 0 0 0 0 0
bs4 1 2 0 0 0 0
Total(Ratio) 23(50%) 3(6.52%) 20(43.48%)
approaches do not. Our handling of the Python (dynamic)
features, such as typing and attribute sets, is also novel.
Several tools have been developed for Python in bug de-
tection [2, 3] and symbolic (concolic) execution [15, 17]. Bug
detection tools are mainly based on static analysis and han-
dle defects that do not involve dynamic features. Recent ad-
vances in Python symbolic (concolic) execution [15, 17] have
shown good potentials. These techniques gradually explore
paths within the search space, driven by a path exploration
engine. In contrast, we use test cases to drive execution
to interesting states and explore bugs in the neighborhood.
Our state exploration is done inside the solver, not by a path
exploration engine. As such, we need to address some new
challenges such as encoding a variable in various types, han-
dling unexecuted paths, and modeling attribute set changes.
Type inference for Python [23, 24, 25] has also been pro-
posed. The work is mainly based on abstract interpretation,
which may have diculty handling dynamic features.
A set of analyses have been proposed for other dynamic
languages such as Javascript [11, 12, 18, 20], Ruby [14, 13,
19] and PHP [26, 21, 22]. TypeDevil [11] detects type in-
consistencies through checking if a variable or eld may have
multiple types in the same run. Jalangi [18] supports con-
colic testing for Javascript which enables detecting type in-
consistencies. Rubydust [13] dynamically infers types to re-
port errors at method boundaries. Zheng et al. [22] proposed
a path-sensitive static analysis of PHP web applications for
security vulnerability detection.
8. CONCLUSION
In this paper, we present a Python predictive analysis.
It has two steps to detect bugs in Python programs. The
rst step is to collect the execution trace of a passing run.
The second is to encode the collected trace and some unex-
ecuted branches into symbolic constraints. By solving the
constraints, we can identify bugs as well as their triggering
inputs. Our evaluation shows that our technique is able to
detect 46 bugs with 16 unreported before. All of them are
true positives.
9. ACKNOWLEDGMENTS
This research was partially supported by DARPA un-
der contract FA8650-15-C-7562, NSF under awards 1409668,
1320444, and 1320306, ONR under contract N000141410468,
Cisco Systems under an unrestricted gift, China Scholar-
ship Council (CSC) Scholarship, National Basic Research
Program of China (973 Program) No.2014CB340702, Na-
tional Natural Science Foundation of China No.91418202,
No.61472178 and No.91318301. Any opinions, ndings, and
conclusions in this paper are those of the authors only and
do not necessarily reect the views of our sponsors.
13010. ARTIFACT DESCRIPTION
We prepare our artifact package on a VMWare image
which can be launched on a host with VMWare Workstation
(version 10) installed. In this section, we provide detailed
instructions about how to use the system.
Installation of VMWare Workstation. Our artifact im-
age requires VMWare Workstation 10, which can be down-
loaded from [28]. Note that the Linux version of VMWare
Workstation is packaged in a \ *.bundle " executable so
that one can simply use the command \ sudo sh /path/-
to/<ï¬lename>.bundle " to start installation.
Download and Load the VM Image. First of all,
go to the project website https://sites.google.com/site/
pypredictor/ to download the VM image. After decom-
pression, please start VMware Workstation and go to menu
File>Open>Select the *.vmx ï¬le to load the image.
Artifact Contents in the Image. After loading the im-
age, the HOME directory contains the following contents:
A README le on the desktop (i.e., $HOME/Desktop ),
which includes the requirements, instructions, evalua-
tion and so on.
The virtual environment ( $HOME/Pythons/vir-
tualenvs ) of Python with our tool and all the
benchmarks installed.
The working directory ( $HOME/Desktop/testcases ),
including all the test cases, congurations and running
scripts.
A mapping le issue-id-mapping.txt on the desk-
top, describing the mapping between test cases and
the corresponding issue identiers.
Source Code and Case Studies. We make the source
code of our tool publicly available. It can be down-
loaded from the project website https://sites.google.com/
site/pypredictor/. Our tool can be installed on Python
2.7 (Linux). We also provide tutorials about how to in-
stall and run the system on a small buggy program. We
have also put a number of case studies on the project web-
site https://sites.google.com/site/pypredictor/ where we de-
scribe in details how these bugs occur, how our technique
detects them and the analysis results of our tool.
Run the Tool. Before running the tool, please make sure
the network of the VM works properly. Otherwise, the user
may not get the right results of some cases. To start the
tool, please use the following steps:
1. Open a terminal.
2. Switch to the Python virtual environment
by: source $HOME/Pythons/virtualen-
vs/python2.7.1/bin/activate .
3. Move to the working directory by command: cd
$HOME/Desktop/testcases .
4. Congure the Salt project by: ./saltconf.sh . Test
the conguration by: salt "*" test.ping . If the test
prints \True", the conguration was successful.
5. For a quick and full evaluation, use the command:
./run.sh . It will take 30-40 minutes to complete.
6. To evaluate the cases one by one, use the command:
python test_caseX.py where Xmeans the ID of the
test case.
We also provide the above instructions in the README
le.Evaluate the results. The evaluation goal is to repro-
duce the results shown in Table 3, which represents our
main results. We have three kinds of output les during
the execution of our tool. All of them are located in folder
testcases/output by default. They are listed as follows:
TraceMatrix_test_caseX.txt stores the detailed
statistics of tracing results for test case X. Refer to
README for the meaning of each record.
PredictMatrix_test_caseX.txt stores the detailed
results of the predictive analysis. Also refer to
README for the meaning of each record.
PyTracer_test_caseX.db stores the dumped trace of
test case X.
Refer to the issue mapping le issue-id-mapping.txt to
align the results with those in the evaluation section. For
more details about the evaluation, please refer to Section
[Evaluation] in the README le.
11. REFERENCES
[1] IEEE Spectrum. http://spectrum.ieee.org/computing/
software/the-2015-top-ten-programming-languages.
[2] PyChecker.
http://sourceforge.net/projects/pychecker/.
[3] PyLint. http://www.pylint.org/.
[4] Y. Smaragdakis, J. Evans, C. Sadowski, J. Yi, and C
Flanagan. Sound predictive race detection in
polynomial time. In 39th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL) , 2012.
[5] J. Huang, P. O. Meredith, and G. Rosu. Maximal
sound predictive race detection with control ow
abstraction. In 35th Annual Conference on
Programming Language Design and Implementation
(PLDI) , 2014.
[6] M. Said, C. Wang, Z. Yang, and K. Sakallah.
Generating data race witnesses by an smt-based
analysis. In Third NASA Formal Methods Symposium
(NFM) , 2011.
[7] C. Wang, S. Kundu, M. Ganai, and A. Gupta.
Symbolic predictive analysis for concurrent programs.
InFormal Methods (FM) , 2009.
[8] F. Sorrentino, A. Farzan, and P. Madhusudan.
PENELOPE: weaving threads to expose atomicity
violations. In 18th ACM SIGSOFT Symposium on the
Foundations of Software Engineering (FSE) , 2010.
[9] A. Farzan, P. Madhusudan, N. Razavi, and
F. Sorrentino. Predicting null-pointer dereferences in
concurrent programs. In 20th ACM SIGSOFT
Symposium on the Foundations of Software
Engineering (FSE) , 2012.
[10] L. O. Andersen. Program Analysis and Specialization
for the C Programming Language. PhD's thesis,
UCPH , 1994.
[11] M. Pradel, P. Schuh, and K. Sen. TypeDevil:
Dynamic type inconsistency analysis for JavaScript. In
37th International Conference on Software
Engineering (ICSE) , 2015.
[12] L. Gong, M. Pradel, M. Sridharan, and K. Sen. DLint:
dynamically checking bad coding practices in
JavaScript. In International Symposium on Software
Testing and Analysis (ISSTA) , 2015.
131[13] J. D. An, A. Chaudhuri, J. S. Foster, and M. Hicks.
Dynamic inference of static types for Ruby. In 38th
ACM SIGACT-SIGPLAN Symposium on Principles of
Programming Languages (POPL) , 2011.
[14] J. D. An, A. Chaudhuri, and J. S. Foster. Static
Typing for Ruby on Rails. In 24th IEEE/ACM
International Conference on Automated Software
Engineering (ASE) , 2009.
[15] T. Ball and J. Daniel Deconstructing Dynamic
Symbolic Execution In Proceedings of the 2014
Marktoberdorf Summer School on Dependable Software
Systems Engineering , 2014
[16] DART: directed automated random testing In ACM
SIGPLAN 2005 Conference on Programming
Language Design and Implementation (PLDI) , 2005.
[17] S. Bucur, J. Kinder, and G. Candea. Prototyping
Symbolic Execution Engines for Interpreted
Languages. In 19th International Conference on
Architecture Support for Programming Languages and
Operating Systems (ASPLOS) , 2014.
[18] K. Sen, S. Kalasapur, T. Brutch, et al. Jalangi: A
selective record-replay and dynamic analysis
framework for JavaScript In 9th Joint Meeting of the
European Software Engineering Conference and the
ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC/FSE) , 2013.
[19] A. Chaudhuri and J.S. Foster. Symbolic security
analysis of ruby-on-rails web applications. In 20th
ACM Conference on Computer and Communications
Security (CCS) , 2010.
[20] S. Artzi, J. Dolby, S. H. Jensen, A. Mller, and
F. Tip. A framework for automated testing ofjavascript web applications. In 33rd International
Conference on Software Engineering (ICSE) , 2011.
[21] E. Kneuss, P. Suter, and V. Kuncak. Runtime
instrumentation for precise ow-sensitive type
analysis. In 2nd International Conference on Runtime
Verication (RV) , 2011.
[22] Y Zheng, X. Zhang. Path sensitive static analysis of
web applications for remote code execution
vulnerability detection In 35th International
Conference on Software Engineering (ICSE) , 2013.
[23] M .Salib. Starkiller: A static type inferencer and
compiler for python. In Master's thesis, MIT , 2004.
[24] A. Rigo and S. Pedroni. Pypy's approach to virtual
machine construction. In ACM SIGPLAN
International Conference on Object Oriented
Programming Systems Languages &Applications
(OOPSLA) , 2006.
[25] M. Gorbovitski, Y. A. Liu, S. D. Stoller, T. Rothamel,
and K. T. Tekle. Alias analysis for optimization of
dynamic languages. In Dynamic Languages
Symposium (DLS) , 2010.
[26] H. Zhao, I. Proctor, M. Yang, X. Qi, M. Williams, et
al. The hiphop compiler for php. In ACM SIGPLAN
International Conference on Object Oriented
Programming Systems Languages &Applications
(OOPSLA) , 2012.
[27] Python Predictive Analysis
https://sites.google.com/site/pypredictor/.
[28] VMWare Workstation https:
//my.vmware.com/web/vmware/info?slug=desktop
enduser computing/vmware workstation/10 0.
132