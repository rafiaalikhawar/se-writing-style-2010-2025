API Recommendation System for Software Development
Ferdian Thung
School of Information Systems
Singapore Management University
ferdiant.2013@smu.edu.sg
ABSTRACT
Nowadays, software developers often utilize existing third
party libraries and make use of Application Programming
Interface (API) to develop a software. However, it is not
always obvious which library to use or whether the chosen
library will play well with other libraries in the system. Fur-
thermore, developers need to spend some time to understand
the API to the point that they can freely use the API meth-
ods and putting the right parameters inside them. In this
work, I plan to automatically recommend relevant APIs to
developers. This API recommendation can be divided into
multiple stages. First, we can recommend relevant libraries
provided a given task to complete. Second, we can rec-
ommend relevant API methods that developer can use to
program the required task. Third, we can recommend cor-
rect parameters for a given method according to its context.
Last but not least, we can recommend how dierent API
methods can be combined to achieve a given task.
In eort to realize this API recommendation system, I
have published two related papers. The rst one deals with
recommending additional relevant API libraries given known
useful API libraries for the target program. This system
can achieve recall rate@5 of 0.852 and recall rate@10 of
0.894 in recommending additional relevant libraries. The
second one deals with recommending relevant API methods
a given target API and a textual description of the task.
This system can achieve recall-rate@5 of 0.690 and recall-
rate@10 of 0.779. The results for both system indicate that
the systems are useful and capable in recommending the
right API/library reasonably well. Currently, I am working
on another system which can recommend web APIs (i.e.,
libraries) given a description of the task. I am also work-
ing on a system that recommends correct parameters given
an API method. In the future, I also plan to realize API
composition recommendation for the given task.CCS Concepts
Software and its engineering !Software libraries
and repositories; Information systems !Recom-
mender systems;
Keywords
API; Library; Recommendation System
1. INTRODUCTION
Gone are the days when developers have to build a soft-
ware from scratch. Proliferation of third party libraries
makes software development task faster and easier than ever
before. In fact, it has been an integral part or software de-
velopment [2, 9, 16]. In one of my paper [22], I have also
investigated a number of GitHub projects with substantial
size and found that 93.3% of them use third party libraries.
Indeed, using third party libraries allow developers to save
time since they do not need to reinvent the wheel. Instead,
they can focus on the specic task at hand. Third party
libraries are also tested; thus, they reduce the likelihood of
creating bugs.
Although third party libraries are readily available, nd-
ing relevant libraries and using them are not always straight-
forward. Developers need to nd relevant libraries among
thousands and manually check whether the library function-
ality is a match with their requirement. This manual check-
ing might involve a long process involving nding relevant
methods in the API and understanding how to use them.
Comprehending the structure of API and how to ll method
parameters properly are among the things that developers
need to learn. Clearly, this process can be time consuming
and the existence of an API recommendation system would
help developers a great deal in doing their job.
In order to help developers nd and use API libraries, I
plan to build an API recommendation system for software
development. I divide API recommendation into multiple
stages. At rst, we can recommend which libraries to pick.
Second, we recommend the method to use. Third, we rec-
ommend how to ll parameters. Lastly, we recommend how
to compose the API methods. I have published two papers
related to this line of work.
The rst paper recommends API library given a known
to be useful or existing libraries in the system [22]. This
recommendation system can help developers to nd addi-
tional relevant APIs. At this point, it was assumed that
developers have some idea on APIs to use. The recommen-
dation system is built by combining association rule mining
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2975940
896
and collaborative ltering techniques. Experiments on the
approach shows that it can achieve recall rate@5 of 0.852
and recall rate@10 of 0.894 for recommending additional li-
braries.
The second paper recommends API methods given a tar-
get library and a textual description of the task [21]. This
recommendation system can help developers to nd relevant
API methods in the given library that can be used to real-
ize the task. The recommendation system is built by com-
bining information retrieval (IR) and collaborative ltering
techniques. Experiment on the approach shows that it can
achieve recall-rate@5 of 0.690 and recall-rate@10 of 0.779 for
recommending API methods.
To continue the work on API recommendation system, I
am currently in progress of building web API recommen-
dation. This is essentially also a library recommendation
system that takes as input a textual description of the given
task. For this system, I have built a personalized ranking
model to rank known libraries based on their expected rel-
evancy given the description. Other than this system, I am
also building an API method parameter recommendation
system. For this system, I am planning to rank parame-
ters based on the surrounding context of the code in which
the method is to be inserted. Unlike the library recommen-
dation system, this recommendation system is still in an
early progress and thus still under a lot of exploration. In
the future, I am also planning to create an API composi-
tion recommendation system. This system would be able
to recommend whether two or more API methods can be
composed and how to compose them.
The structure of this paper is as follows. In Section 2, I
describe my published proposed works in API recommenda-
tion. In Section 3, I explain my ongoing works in the area.
I then discuss related works in Section 4. I then conclude
and talk about future work in Section 5.
2. PUBLISHED WORK
2.1 Library Recommendation
Figure 1 shows the proposed library recommendation frame-
work. It was named as LibRec [22]. It consists of two main
components: LibRecRULEandLibRecCOLLAB.LibRecRULE
makes use library usage patterns to recommend libraries.
The patterns are mined using association rule mining tech-
nique. LibRecCOLLABmakes use a nearest-neighbor-based
collaborative ltering approach to recommend libraries that
are used by similar projects. In the training phase, our sys-
Rule Extractor  Training  
Projects  Feature Vector Extractor  
Rule Matcher  Nearest Neighbor Processor  
Aggregator  New  
Projects  LibRecRULE LibRecCOLLAB 
API Recommendations  TRAINING  
DEPLOYMENT  
Figure 1: Architecture of LibRec
tem extracts model from a training dataset ( TrainingProjects ).
TrainingProjects is a set of projects that contains informa-
tion of third-party libraries that they use. Model extractionis specically performed by the following sub-components:
1.RuleExtractor , capture library usage patterns from Train-
ing Projects by mining association rules.
2.FeatureVectorExtractor , extracts a feature vector from
the set of libraries that the project uses. Each feature
dimension represents a specic library. A value of 1
indicates that the library is used by the project and 0
otherwise.
Given the association rules and feature vectors model, in
the deployment phase, our system can recommend libraries
to new projects ( NewProjects ).NewProjects is a set of new
projects that contains information of third-party libraries
that they have used. Library recommendation is performed
by the following sub-components:
1.RuleMatcher , takes a new project in NewProjects and
the association rule model as inputs. It then nd the
rules that match the libraries used in the project. The
recommendation is made based on the post-conditions
of the matching rules.
2.NearestNeighborProcessor , takes a new project in
NewProjects and the feature vectors model as inputs.
It then calculates the distance between each of feature
vectors in the model and the feature vector generated
from the new project. Based on this distance, the
nearest neighbors are identied. Most recommended
libraries in this component will be the one that is
used by the highest number of nearest neighbors. This
whole process is based on collaborative ltering ap-
proach.
Both RuleMatcher andNearestNeighborProcessor would
give a score for each library in the database. The Aggregator
component computes nal recommendation score by linearly
combining the two scores. Libraries having the highest scores
will be recommended.
2.2 API Method Recommendation
The proposed API method recommendation framework is
shown in Figure 2 [21]. This framework contains three ma-
jor components: History Based Recommender ,Description
Based Recommender , and Integrator .
Historical Feature 
Request  
Database (HDB)  API 
Documentation 
(ADoc ) Textual 
Description  
History Based 
Recommender  Description Based 
Recommender  
Integrator  
Ranked 
Recommendation  
Figure 2: API Method Recommendation Frame-
work
History Based Recommender takes as input the descrip-
tion of a new feature request, i.e. a task, ( Textual Descrip-
tion) and a historical database containing past feature re-
quests ( Historical Feature Request Database (HDB) ). The
recommender nds feature requests in the historical database
that are the closest to the new feature request. The meth-
ods that are used to implement the closest feature requests
897are ranked higher. This recommendation is based on col-
laborative ltering approach. Description Based Recom-
mender takes as input the description of the new feature re-
quest ( Textual Description ) and the API libraries documen-
tation( API Documentations (ADoc) ). The recommender
computes the similarity of the feature request description
with each method description in the API documentation.
Methods whose textual descriptions are the most similar
with the new feature request description are more recom-
mended. This recommendation is based on information re-
trieval approach. History Based Recommender andDescrip-
tion Based Recommender output recommendation scores for
each API method. Integrator combines the recommendation
scores and outputs a list of API methods ranked by the -
nal combination score. API method with the highest score
is rst recommended to the developer.
3. ONGOING WORK
3.1 Web API Recommendation
The architecture of currently developed web API recom-
mendation system WebAPIRec , is shown in Figure 3. It takes
as input a description of new project, a set of completed
projects, and a set of API descriptions. The new project de-
scription contains a textual description and set of keywords
for the project. For each completed projects, other than
description of the project (i.e., text and keywords), actual
APIs that are used in the project are also recorded. Simi-
lar like project description, API description also contain a
textual description and a set of keywords for the API. We-
bAPIRec analyzes these inputs and nally produces a ranked
list of APIs to be recommended to the target project.
Personalized	 ¬†API	 ¬†Ranking	 ¬†ModelDescription	 ¬†of	 ¬†New	 ¬†Projects	 ¬†(evaluation	 ¬†data)Ranked	 ¬†List	 ¬†of	 ¬†APIsDescriptions	 ¬†of	 ¬†Past	 ¬†Projects(training	 ¬†data)Project	 ¬†DatabaseAPIs‚Äô	 ¬†Descriptions(training,	 ¬†evaluation	 ¬†data)API	 ¬†DatabaseProjects'	 ¬†API	 ¬†Usages(training	 ¬†data)
LegendDataDatabaseProcessOutput
Figure 3: Architecture of WebAPIRec
WebAPIRec consists of two phases: training phase andde-
ployment phase . In training phase, WebAPIRec converts the
input project descriptions to feature vectors. WebAPIRec rst
identies nouns from the textual descriptions using Stan-
ford Parts-of-Speech (POS) tagger. These words carry more
meaning than other kinds of words, c.f. [5, 18]. WebAPIRec
combines the nouns with the keywords, remove stop words,
stem each word, and nally construct a feature vector. The
same process is executed to convert an API's textual descrip-
tion into a feature vector. These project and API feature
vectors are put to a set of training triples ( p; a; a0) for the
personalized ranking model. In a triple ( p; a; a0),pis the
feature vector of a project, ais the feature vector of an API
inp, and a0is the feature vector of an API not in p. From
this data, the personalized API ranking model is learned.The personalized API ranking model is built as a variant of
ranking support vector machine (RankSVM) [8].
In deployment phase, similar to the training phase ,We-
bAPIRec constructs feature vectors from a new project. Lever-
aging the personalized API ranking model, WebAPIRec com-
putes the relevancy of the APIs in database and sort them in
descending order based on the recommendation scores. To
evaluate WebAPIRec , the recommendation is checked against
the ground truth.
3.2 API Method Parameter Recommendation
This direction is still on the early stage. The closest works
in this area is done by Zhang et al. [23] and Asaduzzaman
et al. [1]. Asaduzzaman et al. is the state of the art and it
has been shown that their approach beats Zhang et al.'s ap-
proach. Their approach leverages parameter usage context
using a source code localness property and static type anal-
ysis to recommend method parameters. In this direction,
I plan to develop a better approach that beats Asaduzza-
man et al.'s approach. One possible improvement is to use
a better ranking method. I am experimenting with dierent
ranking methods to nd an approach that suitable for rank-
ing API parameters. One promising direction is to learn
from historical API parameter usage. Another possible im-
provement is to develop better features for identifying rel-
evant parameters. For example, two parameters might be
more likely to appear together. Thus, knowing one correct
parameter could make the recommendation for the other
parameters better. For evaluation, I will check whether it
matches the ground truth.
4. RELATED WORK
Mandelin et al. proposed a tool to recommend a code
snippet that converts an object of one type to another [11].
Their work was extended by Thummalapenta and Xie [20]
who used a code search engine to solve the same problem.
This approach queries a code search engine (i.e., Google
Code) to return a set of code examples. Bruch et al. rec-
ommended method calls for code auto-completion based on
the context of the code that a developer is working on [4].
Robbes and Lanza proposed a technique to improve code
auto-completion by using recorded program history [14]. Hin-
dleet al. proposed a code auto-completion feature using a
statistical language model [7]. Chan et al. proposed an ap-
proach to recommend API methods given textual phrases [6].
Moreno et al. proposed MUSE to recommend code examples
by extracting concrete method usages [13].
Robillard et al. proposed Suade, which takes as input
a set of program elements of interest and outputs another
set of program elements that are likely to be interesting to
developers [15]. Their approach was extended by Saul et
al., which employs an algorithm named FRAN to recom-
mend a set of methods that are relevant to a target method
by performing random walk on a call graph [17]. Long et
al.proposed Altair which extends Suade and Fran by rec-
ommending methods to a target method based on variables
that are shared among them [10]. Zhang et al. extended the
previous approaches by making use of a call graph that is
enhanced with control ow information [24]. Zimmermann
et al. use association rule mining to infer program elements
that also need to also be changed, when a set of program
elements are changed [25].
Teyton et al. proposed an approach that creates a library
898migration graph by analyzing library migrations performed
by a large number of projects [19]. McMillan et al. proposed
an approach to recommend software packages for rapid pro-
totyping given product descriptions [12]. The approach rst
recommends feature to the user and use the user selected
features to recommend the relevant software modules. Bian-
chini et al. presented a framework for dierent web API
search patterns [3]. It supports recommending web API for
a new mashup, adding a web API to a mashup, and replacing
an existing web API in a mashup.
5. CONCLUSION AND FUTURE WORK
I have developed two systems for API recommendation.
One recommends API libraries while the other recommends
API methods. I currently have two ongoing works. One of
the works is essentially recommending API libraries. How-
ever, instead of needing some known libraries, this system
only requires a textual description of the task. The other
ongoing work is dealing with a problem of recommending
parameters for an API method. I am also planning to do
API composition recommendation work in the future. The
target of such system is the ability to automatically arrange
the correct order of API and ideally synthesize the relevant
glue codes to make the APIs work together. Eventually, I
want to deploy the systems to get feedback from developers.
6. ACKNOWLEDGEMENT
My dissertation research would not have been possible
without incredible supports from my advisor: David Lo, As-
sociate Professor, Singapore Management University.
7. REFERENCES
[1] M. Asaduzzaman, C. K. Roy, S. Monir, and K. A.
Schneider, \Exploring api method parameter
recommendations," in Software Maintenance and
Evolution (ICSME), 2015 IEEE International
Conference on . IEEE, 2015, pp. 271{280.
[2] V. Bauer, L. Heinemann, and F. Deissenboeck, \A
structured approach to assess third-party library usage,"
inICSM , 2012, pp. 483{492.
[3] D. Bianchini, V. De Antonellis, and M. Melchiori,
\Advanced web API search patterns adding collective
knowledge to public repository facets," in Proceedings of
the International Conference on Information
Integration and Web-based Applications & Services , vol.
211, 2013, pp. 211{219.
[4] M. Bruch, M. Monperrus, and M. Mezini, \Learning from
examples to improve code completion systems," in
Proceedings of the Joint Meeting of the European
Software Engineering Conference and the ACM
SIGSOFT Symposium on the Foundations of Software
Engineering , 2009, pp. 213{222.
[5] G. Capobianco, A. D. Lucia, R. Oliveto, A. Panichella,
and S. Panichella, \Improving IR-based traceability
recovery via noun-based indexing of software artifacts."
Wiley Online Library, 2012.
[6] W.-K. Chan, H. Cheng, and D. Lo, \Searching connected
API subgraph via text phrases," in Proceedings of the
International Symposium on the Foundations of
Software Engineering , 2012, p. 10.
[7] A. Hindle, E. T. Barr, Z. Su, M. Gabel, and P. T.
Devanbu, \On the naturalness of software," in
Proceedings of the International Conference on
Software Engineering , 2012, pp. 837{847.
[8] T. Joachims, \Optimizing search engines using
clickthrough data," in Proceedings of the ACM SIGKDDInternational Conference on Knowledge Discovery and
Data Mining , 2002, pp. 133{142.
[9] R. L ammel, E. Pek, and J. Starek, \Large-scale,
AST-based API-usage analysis of open-source Java
projects," in SAC, 2011, pp. 1317{1324.
[10] F. Long, X. Wang, and Y. Cai, \API hyperlinking via
structural overlap," in Proceedings of the International
Symposium of the Foundations of Software
Engineering , 2009, pp. 203{212.
[11] D. Mandelin, L. Xu, R. Bod k, and D. Kimelman,
\Jungloid mining: helping to navigate the API jungle," in
Proceedings of the ACM SIGPLAN conference on
Programming Language Design and Implementation ,
2005, pp. 48{61.
[12] C. McMillan, N. Hariri, D. Poshyvanyk,
J. Cleland-Huang, and B. Mobasher, \Recommending
source code for use in rapid software prototypes," in
Proceedings of the International Conference on
Software Engineering , 2012, pp. 848{858.
[13] L. Moreno, G. Bavota, M. Di Penta, R. Oliveto, and
A. Marcus, \How can i use this method?" in 2015
IEEE/ACM 37th IEEE International Conference on
Software Engineering , vol. 1. IEEE, 2015, pp. 880{890.
[14] R. Robbes and M. Lanza, \Improving code completion
with program history," Automated Software
Engineering , vol. 17, no. 2, pp. 181{212, 2010.
[15] M. P. Robillard, \Automatic generation of suggestions for
program investigation," in Proceedings of the
International Symposium of the Foundations of
Software Engineering , 2005, pp. 11{20.
[16] M. P. Robillard and R. DeLine, \A eld study of API
learning obstacles," Empirical Software Engineering ,
vol. 16, no. 6, pp. 703{732, 2011.
[17] Z. M. Saul, V. Filkov, P. T. Devanbu, and C. Bird,
\Recommending random walks," in Proceedings of the
International Symposium of the Foundations of
Software Engineering , 2007, pp. 15{24.
[18] R. Shokripour, J. Anvik, Z. M. Kasirun, and S. Zamani,
\Why so complicated? simple term ltering and
weighting for location-based bug report assignment
recommendation," in Proceedings of the Working
Conference on Mining Software Repositories , 2013, pp.
2{11.
[19] C. Teyton, J.-R. Falleri, and X. Blanc, \Mining library
migration graphs," in Proceedings of the Working
Conference on Reverse Engineering , 2012, pp. 289{298.
[20] S. Thummalapenta and T. Xie, \Parseweb: a
programmer assistant for reusing open source code on the
web," in Proceedings of the IEEE/ACM International
Conference on Automated Software Engineering , 2007,
pp. 204{213.
[21] F. Thung, S. Wang, D. Lo, and J. Lawall, \Automatic
recommendation of API methods from feature requests,"
inASE, 2013.
[22] F. Thung, L. David, and J. Lawall, \Automated library
recommendation," in Proceedings of 20th Working
Conference on Reverse Engineering (WCRE 2013) ,
2013, pp. 182{191.
[23] C. Zhang, J. Yang, Y. Zhang, J. Fan, X. Zhang, J. Zhao,
and P. Ou, \Automatic parameter recommendation for
practical api usage," in Proceedings of the 34th
International Conference on Software Engineering .
IEEE Press, 2012, pp. 826{836.
[24] Q. Zhang, W. Zheng, and M. R. Lyu, \Flow-augmented
call graph: A new foundation for taming API
complexity," in Proceedings of the International
Conference on Fundamental Approaches to Software
Engineering , 2011, pp. 386{400.
[25] T. Zimmermann, P. Weisgerber, S. Diehl, and A. Zeller,
\Mining version histories to guide software changes." in
ACM/IEEE International Conference on Software
Engineering , 2004, pp. 563{572.
899