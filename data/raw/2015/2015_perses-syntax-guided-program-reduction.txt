Perses: Syntax-Guided Program Reduction
Chengnian Sun
University of California
Davis, CA, USA
cnsun@ucdavis.eduYuanbo Li
University of California
Davis, CA, USA
yboli@ucdavis.eduQirun Zhang
University of California
Davis, CA, USA
qrzhang@ucdavis.edu
Tianxiao Gu
University of California
Davis, CA, USA
txgu@ucdavis.eduZhendong Su
University of California
Davis, CA, USA
su@ucdavis.edu
ABSTRACT
Given a program Pthat exhibits a certain property ψ(e.g.,aC
program that crashes GCC when it is being compiled), the goal
ofprogramreduction istominimize Ptoasmallervariant P/primethat
still exhibits the same property, i.e.,ψ(P/prime). Program reduction is
important and widely demanded for testing and debugging. For
example, all compiler/interpreter development projects need effec-
tive program reduction to minimize failure-inducing test programs
to ease debugging. However, state-of-the-art program reduction
techniques — notably Delta Debugging (DD), Hierarchical Delta
Debugging(HDD),andC-Reduce—donotperformwellintermsofspeed(reduction time)andquality(sizeofreducedprograms),orare
highly customized for certain languages and thus lack generality.
This paper presents Perses, a novel framework for effective,ef-
ficient,and generalprogramreduction.The keyinsight istoexploit,
inageneralmanner,theformalsyntaxoftheprogramsunderre-
ductionandensurethateachreductionstepconsidersonly smaller,
syntacticallyvalid variantstoavoidfutileeffortsonsyntactically
invalid variants. Our framework supports not only deletion (as for
DD and HDD), but also general, effective program transformations.
Wehavedesignedandimplemented Perses,andevaluateditfor
twolanguagesettings:CandJava.Ourevaluationresultson20C
programstriggeringbugsinGCCandClangdemonstrate Perses’s
strong practicality compared to the state-of-the-art: (1) smaller size
—Perses’s results are respectively 2%and45%in size of those
fromDD andHDD; and(2) shorterreduction time —Persestakes
23%and47%time taken by DD and HDD respectively. Even when
compared to the highly customized and optimized C-Reduce for
C/C++, Persestakes only 38-60%reduction time.
CCS CONCEPTS
•Software and its engineering →Software testing and de-
bugging;
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5638-1/18/05...$15.00
https://doi.org/10.1145/3180155.3180236KEYWORDS
program reduction, delta debugging, debugging
ACM Reference Format:
Chengnian Sun, Yuanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong
Su.2018.Perses:Syntax-GuidedProgramReduction.In ICSE’18:ICSE’18:
40th International Conference on Software Engineering , May 27-June 3, 2018,
Gothenburg,Sweden. ACM,NewYork,NY,USA,11pages.https://doi.org/
10.1145/3180155.3180236
1 INTRODUCTION
Program reduction is important and widely used. Given a program
Pthat exhibits a property, the objective of program reduction is to
generateasmallerprogram P/primefromPthatstillexhibitsthesame
property. The reduction process continuously generates smaller
programvariants,andchecksthemagainsttheproperty.Aminimal
variant that perserves the property is returned at the end.
A common usage scenario for program reduction is reducing
test programs that trigger compiler bugs. It is well-known that
debuggingtypicalapplicationsoftwareispainstakinganddaunting.
Debuggingcompilerscanbeevenmoredifficultascompilersare
amongthemostcomplexsoftwaresystems( e.g.,GCC’scodebase
is close to 20 million lines). It is worse when the bug-triggering
programcontainsalargeamountofirrelevantcodetothebugas
compiler developers need to manually distill useful information
fromthetestprogram.Mostofthetime,thesizedifferencebetween
the original and the distilled version can be considerable. For ex-
ample, a recent study on the characteristics of bugs in GCC and
LLVM[21]hasshownthat,onaverage,minimizedtestprograms
contain only 30 lines of code to trigger compiler bugs. In contrast,
the original bug-triggering test programs may have hundreds or
thousands of lines of code [ 9,11,22,25]. Therefore, it is important
to automatically compute the distilled version. Indeed, compiler
developers strongly encourage submitting small, reproducible test
programs — both GCC and LLVM advocate test reduction in their
bug reporting processes [4, 13].
Existing Reduction Techniques. The state-of-the-art program
reduction techniques are Delta Debugging [ 24], Hierarchical Delta
Debugging [16], and C-Reduce [17].
Delta Debugging (DD) :ZellerandHildebrandt[ 24]pr oposedDD
to minimize failure-inducing test inputs. It is general, and works
on not only programs, but also arbitrary inputs as DD can operate
attheindividualbytelevel.Initially,thetestinputissplitintoalist
of elements at acertain granularity ( e.g., byte, lexeme or line). New
3612018 ACM/IEEE 40th International Conference on Software Engineering
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chengnian Sun, Y uanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su
inputsarethensystematicallygeneratedbydeletingelementsfrom
thelist,andcheckedwhethertheystilltriggerthesamefailure.The
algorithm terminates with a minimal failure-inducing input.
DD is general, but not suited for reducing programs because,
bydesign, itdoesnot leveragenorrespect syntaticstructuralcon-
straints available in programs and enforced by a programminglanguage’s formal syntax. Thus, DD inevitably considers a large
numberofcandidateinputsthataresyntacticallyinvalid,leading
to poor reduction performance.
Hierarchical Delta Debugging (HDD) : Misherghi and Su [ 16]p r o -
posed HDD to improve the effectiveness of DD for tree-structured
inputs.DifferentfromDD,HDDconvertstheinputintoatree w.r.t.
the input’s format. In the particular case of program reduction,
HDD converts a program into its parse tree or abstract syntax tree
(AST),performsbreadth-firstsearchonthetree,andinvokesthe
DD algorithm on each level to prune tree nodes from that level.
Although HDD’s tree-based reduction considers fewer syntacti-
callyinvalidprogramsthanDDandthusoutperformsit,itprovides
no guarantee and still generates many syntactically invalid inputs
(e.g.,removingthevariablenamein adeclaration).The reasonis
that HDD only uses the formal syntax of a language ( i.e., its gram-
mar) to convert a test input into its tree representation, but does
notexploitthegrammarfurthertoguidereduction.AsHDD’score
reductionisbasedonDD,itgeneratessmallerprogramsonlyvia
deletion, thus may be incapable of generating smaller programs
that require other transformations (see Section 2 for illustration).C-Reduce
:Regehret al.proposedC-Reduce[ 17],ahighlycustomized
reducer for C/C++, that embodies a set of C/C++ program transfor-
mations implemented via the Clang LibTooling [14] library.
Although C-Reduce is powerful at minimizing C/C++ programs,
the reduction process may take significant time. To mitigate its
performance issue, Le et al.combined DD and C-Reduce to reduce
C test programs in the EMI compiler testing work [ 9]. More impor-
tantly, C-Reduce is not general — to support another programming
language, one needs to re-design and re-implement program trans-
formations targetting the language, which is obviously nontrivial.
In short, DD is fast, but often cannot produce good quality
(i.e., small) reductions; C-Reduce offers high-quality reductions
forC/C++programs,butlacksgeneralityandtakesmuchreduction
time; and HDD is in between — it produces better reductions than
DD, and runs faster than C-Reduce.
Syntax-Guided Program Reduction. Thispaperaddressesthe
aforementioned shortcomings of existing techniques by proposing
anovelframework, Perses,toenablegeneral,effective,andeffi-
cient program reduction. Our conceptual insight is to utilize the
formal syntax ( i.e., grammar) of a programming language to guide
reduction.Our technicalinsight istoleveragethegrammarto(1)
generate only syntactically valid inputs, and (2) support generic,
effective program transformations.
Inmoredetail,programreductionisaboutsearchingforsuitable
programsinasearchspace P,1whichcanbepartitionedintotwo
disjoint sets: the set of syntactically valid programs Pvalid, and the
set ofsyntactically invalid onesPinvalid,i.e.,
P=Pinvalid/unionmultiPvalid
1Pistheuniverseofcandidateprogramsthataprogramreducercanderivefrom P,
wherePis the initial program to reduce.where/unionmultidenotesthedisjointunionoperator.DDandHDD2have
non-empty Pinvalid,becauseasaforementionedDDdoesnotcon-
siderprogramsyntaxatthepreprocessingstep( i.e.,convertinga
test program into a list) or during reduction, and HDD does not
eitherduringreduction.Bothalgorithmsgenerateaconsiderable
number of syntactically invalid programs, only being a waste of
reduction time. On the other hand, both reduction algorithms only
delete elements from test programs, which limits the search space
of syntactically valid programs, i.e.,Pvalid.
Our use of grammars is fundamentally different from that of
HDD. HDD only uses grammars to parse programs into tree struc-
tures,whereas Persesfurtheranalyzesandleveragesgrammars
during reduction. This brings us two advantages:
Pinvalid=∅: From the definition of the grammar, during reduction
Persescandeterminewhetheratreenodeisdeletable.Ifno,we
can avoid generating variants by deleting that node. This makes it
veryeasyfor Persestoensure Pinvalid=∅,whichconsequently
reduces the number of unnecessary property tests.
Enlarging Pvalid:Persesleveragesthegrammartosupportmore
advanced program transformations, which thus increases Pvalid.
For example, according to the C grammar, a conditional state-
ment if (...) {print("");} can be simplified to if (...)
print(""); ,asthetruebranchofanifstatementisastatement,
and the compound statement {print("");} and the function call
print(""); are both statements. Though increased Pvalidmay in-
crease the number of property tests, it enables Persesto generate
more valid, diverse, possibly smaller variants than DD and HDD.
Itiseasyfor Persestosupportanewlanguagebyjustproviding
its grammar in Backus-Naur form (BNF). However, it is very likely
thattheoriginalgrammarinarbitraryformmayhindertheeffec-
tiveness of Perses. Thus we define a normal form of grammars to
facilitatereduction,referredtoasPersesNormalForm(PNF).We
also design an algorithm to automatically convert any grammar
into itsequivalent PNF.
Ourevaluationresultsof Perseson20largeCprogramsthat
trigger bugs in GCC and Clang demonstrates that Perses’s strong
practicality compared to the state-of-the-art: (1) smaller size —
Perses’s results are respectively 2%and45%in size of those from
DDandHDD;and(2) shorterreductiontime —Persestakes23%
and47%time taken by DD and HDD respectively. Even when com-
paredtothehighlycustomizedandoptimizedC-ReduceforC/C++,
Persestakesonly 38-60%reductiontime.Todemonstratethegener-
alityof Perses,wealsoevaluate Perseson6smallJavaprograms
triggering bugs in Javac and Eclipse Compiler for Java, and the re-
sults areconsistent with those onC programs. Persesconstantly
outperforms HDD in terms of both time and reduction quality.
Contributions. This paper makes the following contributions.
•We propose Perses, a framework for effective and efficient pro-
gramreduction.Itisthefirst generalprogramreducerthatlever-
ages formal syntax to guide program reduction. It guarantees no
generation of syntactically invalid programs, and supports more
program transformations to produce smaller reduction results.
2We exclude C-Reduce from comparison and discussion in the remainder of the paper
except Section 5, as C-Reduce is language-specific and this paper focuses on language-
independent program reducers.
362
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Perses: Syntax-Guided Program Reduction ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
•We define Perses Normal Form of grammars to facilitate pro-
gram reduction, and also propose an algorithm to automatically
convert any context free grammar into an equivalent PNF.
•Ourevaluationresultsonreal-worldbenchmarksdemonstrate
significant improvement of Persesover the state of the art.
•Persesprovidesanewperspectiveforprogramreduction.With
theknowledgeofformalsyntax,wecandesignmoreprogram
transformations to produce better reduction results.
2 A MOTIVATING EXAMPLE
We illustrate Perseswith a contrived C program. The full algo-
rithmisdetailedinSection4.Figure1ashowsaprogramthatprints
threelines(‘ 1’, ‘Hello world! ’,and‘ End’).Assumethatwearein-
terestedinthebehaviorofprinting‘ Hello world! ’.Then Perses
outputs a minimized program that only prints ‘ Hello world! ’.
Different from HDD which performs reduction level by level,
Persesdoesnodebynode.Itmaintainsapriorityqueue Qtostore
the treenodes forreduction. Eachtime, itretrieves thenode with
themosttokensfrom Q,andreducesthatnodewithvarious syntax-
preserving program transformations. After the node is reduced, the
remaining children of the node are added to Qfor future reduction.
Initially, Persesparses this program into the parse tree shown
in Figure 1e. Then, it performs the following reduction steps:
Step 1 ( 1.func _def):Persesreducestherootoftheparsetree, i.e.,
‘1.func _def’.However,removingitdoesnotpossesstheproperty.
So all its children are added to Q.
Step 2 ( 2.compound _stmt):Thefunctionbody‘ 2.compound _stmt’
is dequeued for reduction, because it has the most tokens in Q. For
thiscompoundstatement,wecannotdeleteit,asthefunctionbody
is compulsory for a function definition. However, we can replace it
with one of its descendants which is also a compound statement.
In this case, we can replace it with ‘ 6.compount _stmt’, the true
branch of ‘ if(a)’ on line 3. After replacement, the new variant is
listedbelow.Althoughitissyntacticallycorrect,itdoesnotcompile
astheidentifier‘ a’isnotdefined.Sothisreductionstepfails,and
we add the three immediate children to Q.
int main() { printf("%d\n" ,a ) ;
printf("Hello "); printf("world!\n"); printf( "End\n"); }
Step 3 ( 3.stmt _star):The suffix ‘_star’ indicates that this node is
aKleene-Star node, and represents that it can have zero or more
statements as immediate children. In other words, any child of this
nodecanbedeletedwithoutviolatingtheCprogramsyntax.Forthis
node, Persesuses DD to delete irrelevant children. Unfortunately,
all three children cannot be deleted, and then are added to Q.
Step 4 ( 4.if _stmt):Thelargestnodein Qis‘4.if _stmt’.Itspar-
ent is ‘ 3.stmt _star’ that expects zero or more statements. So we
can find a statement to replace ‘ if_stmt’, and the program syntax
willstillbevalid.Wesearchallitschildren,andfinditstruebranch
to be a statement, i.e.,n od e‘ 6.compoudt _stmt’. So we obtain the
first successful reduced variant shown in Figure 1b.
Step 5 ( 5.compound _stmt):To reduce this node, we attempt to
use one of its children to replace it. As it replaces ‘ 4.if _stmt’, its
parent becomes the node ‘ 3.stmt _star’ which expects zero or
more statements. Then we can use ‘ 6.stmt _star’ (which is also a
Kleene-Star node that expects zero or more statements) to replacethiscompoundstatement.Indetail,‘ 6.stmt _star’becomesachild
of ‘3.stmt _star’, and this transformation does not invalidate the
grammar,becausethetokensownedby‘ 3.stmt _star’stillconsti-
tutealistofstatements.Thistransformationpreservestheproperty,
and the result is shown in Figure 1c.
Step 6 ( 6.stmt _star):AsitisaKleenestarnode,weuseDDtore-
duceit.Andnodes‘ 8.printf@4 ’and‘ 11.printf@7 ’areremoved.
Following Steps: After ‘ 8.printf@4 ’(i.e., the print statement on
line4)isremoved,thedependencyonvariable aisalsoremoved.
When Persespicks ‘ 12.inta=1 ; ’f r o mQ, this statement can
be safely removed without introducing any compilation error.
Figure 1d shows the final result, and Figure 1f shows the final
pruned parse tree. Only the two print statements and the return
statement are kept in the result. The if statement is removed by
replacing it with its child. This transformation is not possible in
eitherHDDorDDexceptwithcase-by-casespecializedsolutions.In
contrast,ourapproachissystematic,andinvolvenoad-hocdesigns.
Alltransformationsin Persesaredesignedbasedonthesemantics
oflanguagegrammars, e.g.,deletingsomechildrenofKleeneStar
nodes, replacing a statement node with another statement node.
3 PRELIMINARIES
This section formalizes program reduction, introduces DD, and
defines PersesNormal Form.
3.1 Program Reduction
LetB={true,false},Pbe a program that exhibits a property,
Pbe the search space of programs defined by concrete program
reductionalgorithmsover P.3Wedefineapropertytestfunction
ψ:P→B, such that ψ(P)=trueand for any program p∈P,
ψ(p)=trueifpexhibitsthe property,otherwise ψ(p)=false.The
size ofpis denoted as |p|, which is the number of tokens in p.
Given a program Pand its property test ψ(s.t.,ψ(P)=true), the
goal of program reduction is to search for a minimized program
p∈P, such that ψ(p)∧|p|<|P|.Ideally, the goal of reducing P
(denoted as Reduce(P)) is defined as
argmin
p∈P∧ψ(p)|p|≡{p|p∈P∧ψ(p)∧∀x∈P.|p|≤|x|}
1-Minimality and 1-Tree-Minimality. However, obtainingthe
globalminimalityisNP-complete[ 16,24].Therefore,inpractice,
thereductionproblemisrelaxedtocomputetheminimumresult
within a program reducer’s capacity. For example, DD defines 1-
minimality[ 24].Thatis, p∈Pis1-minimalifanyvariant p/primederived
frompbyremovingasingleelementfrom pdoesnotpasstheprop-
erty test, i.e.,ψ(p/prime)=false. HDD also defines a similar notion [ 16]:
A program is 1-tree-minimality if any nodeof the tree representa-
tion of the program cannot be further simplified by the reducer.
3.2 Delta Debugging Algorithm
DD is integral to Perses, and we briefly introduce its reduction
algorithm ddmin.Givenaninputandaproperty ψ,DDfirstconverts
theinputintoalist Lofelements.Then ddmindeterminesasubset
3Note that the search space Pis not the universe of all programs. As aforementioned
in Section 1, it is defined by the concrete reduction algorithm over P, andP∈P.
363
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chengnian Sun, Y uanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su
1int main() {
2 int a=1 ;
3 if(a) {
4 printf( "%d\n", a);
5 printf( "Hello ");
6 printf( "world!\n");
7 printf( "End\n");
8 }
9 return 0;
10 }
(a) Original.1int main() {
2 int a=1 ;
3 if(a) {
4 printf("%d\n" ,a ) ;
5 printf("Hello ");
6 printf("world!\n" );
7 printf("End\n" );
8 }
9 return 0;
10 }
(b)Perses: first success.1int main() {
2 int a=1 ;
3 if(a) {
4 printf("%d\n" ,a ) ;
5 printf("Hello ");
6 printf("world!\n" );
7 printf("End\n" );
8 }
9 return 0;
10 }
(c)Perses: second success.1int main() {
2 int a=1;
3 if(a) {
4 printf("%d n", a);
5 printf( "Hello ");
6 printf( "world!\n");
7 printf("End n");
8 }
9 return 0;
10 }
(d)Perses: final result.
1.func_def
’int’ ’main’ ’(’ ’)’ 2.compound_stmt
’{’ 3.stmt_star
12.inta=1 ; 4.if_stmt
’if’ ’(’ expr
’a’’)’ 5.compound_stmt
’{’ 6.stmt_star
8.printf@4 9.printf@5 10.printf@6 11.printf@7’}’13.return 0;’}’
(e) The parse tree of Figure 1a, simplified for illustration purpose.1.func_def
’int’ ’main’ ’(’ ’)’ 2.compound_stmt
’{’ 3.stmt_star
12.inta=1 ; 4.if_stmt
’if’ ’(’ expr
’a’’)’ 5.compound_stmt
’{’ 6.stmt_star
8.printf@4 9.printf@5 10.printf@6 11.printf@7’}’13.return 0;’}’
(f) The pruned parse tree after reduction.
Figure 1: An example program.
ofLsuchthatnooneelementcanbedeletedfrom Lwhilepreserving
ψ,i.e., the reduced Lis 1-minimal. It involves three steps.
Step 1:SplitLintonpartitions.Foreachpartition u,testifuonly
without the other partitions can preserve the property. If yes, re-
move the complement of ufromL, and resume at Step 1.
Step 2:Test if the complement of each partition upreserves the
property. If yes, remove ufromL, and resume at Step 1.
Step 3:Try to split each remaining partition into halves. That is,
increasethenumberofpartitionsfrom nto2n.ThenresumeatStep
1 with the newlysplit smaller partitions. If each partitionscannot
be further split, the remaining elements in Lare the reduced result,
andddminterminates.
3.3 Input Grammar Forms
PersestakesasinputlanguagegrammarsspecifiedinBackus-Naur
Form (BNF)notation. Unlessotherwisestated, wealways assume
thegrammarsareexpressedinBNFnotation. Persesalsosupports
the context-free grammar rules with three additional quantifier
over terminals and nonterminals.
Kleene Star (∗).The quantified terminal or nonterminal should
occurzeroormultipletimes.Forexample,A*cangenerateempty
strings, ‘A’, ‘AA’, and so on.
Kleene Plus (+).Thequantifiedterminalornonterminalshould
occuroneormultipletimes.Forexample,A+issimilartoA*except
that A+ does not accept empty strings.
Optional (?).The quantified terminal or nonterminal should
occur either zero times or once. For example, A? accepts either
empty strings or ‘A’.In particular, a grammar rule is defined as a quantified rule iff at
least oneof itsright-hand sidesymbols is equippedwith aquanti-
fier.Thethreequantifierssimplifythegrammarrepresentationand
have been widely used in many popular parser generators such as
ANTLR [2] and JavaCC [ 7].Persesleverages the three quantifiers
toperformsyntaxguidedprogramreduction.Wesaythatanon-
terminalAisquantifiable ifAcouldbetransitivelydescribedbya
quantified rule. For instance, “ B/ColonequalD∗” is a quantified rule and the
nonterminal Bisquantifiable.Supposethatwehaveanotherrule
“A/ColonequalBC”. The nonterminal Ais also quantifiable since Acould be
transitivelydescribedbyaquantifiedrule“ A/ColonequalD∗C”byreplacing
theBsymbol with “ D∗”. Next, we formally introduce the grammar
normal form used in Perses.
Definition3.1(PersesNormalForm). Acontext-freegrammar
CFGisinPersesnormalform(PNF)ifallitsproductionrulesareof
the following form:
(i)A/ColonequalB1B2...Bn,o r
(ii)A/ColonequalB1∗,o r
(iii)A/ColonequalB1+,o r
(iv)A/ColonequalB1?,o r
(v)S/Colonequalϵ,
whereSdenotesthestartsymbol, Adenotesanonterminal, Bidenotes
either a terminal or a nonterminal for all i∈[1,n], andn>1.
Moreover, all quantifiable nonterminals are transitively described by
at leastone quantified rule.
The PNF could be viewed as a restricted form of the extended
Backus-Naurform. Every context-freegrammarcould be normal-
ized to PNF. The normalization algorithm is detailed in Section 4.1.
364
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Perses: Syntax-Guided Program Reduction ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Intuitively,rule(i)inDefinition3.1referstoanynon-epsilonrulein
a context-free grammar. The epsilon rules could be safely removed
duringnormalization[ 1].Rules(ii)-(iii)correspondtoanyrecursive
ruleswitheitherleft-orright-recursion.Thenormalizationalgo-
rithmfindsatleastonesuchrecursiverulesforeachquantifiable
nonterminal.Rule(iv)couldbedistilledfromtheruleswithoptional
terminal or nonterminals. Figure 2 shows the grammar in PNF for
theprograminFigure1a.Forillustrationpurposeitissimplified
by covering a small subset of the C programming language.
/angbracketleftfunc_def/angbracketright::=/angbracketlefttype/angbracketright/angbracketleftidentifier/angbracketright‘(’‘)’/angbracketleftcompound_stmt /angbracketright
/angbracketleftstmt/angbracketright ::=/angbracketleftif_stmt/angbracketright
|/angbracketleftdecl_stmt/angbracketright
|/angbracketleftexpr_stmt /angbracketright
|/angbracketleftcompound_stmt /angbracketright
/angbracketleftif_stmt/angbracketright ::=/angbracketleftcond_plus /angbracketright/angbracketleftdecl_stmt/angbracketright
|/angbracketleftcond_plus /angbracketright/angbracketleftexpr_stmt /angbracketright
|/angbracketleftcond_plus /angbracketright/angbracketleftcompound_stmt /angbracketright
/angbracketleftcond_plus /angbracketright::=/angbracketleftif_cond/angbracketright+
/angbracketleftif_cond/angbracketright ::= ’if’ ’(’ /angbracketleftexpr/angbracketright’)’
/angbracketleftdecl_stmt/angbracketright::=/angbracketlefttype/angbracketright/angbracketleftidentifier/angbracketright‘=’/angbracketleftexpr/angbracketright‘;’
/angbracketleftexpr_stmt /angbracketright::=/angbracketleftexpr/angbracketright‘;’
/angbracketleftcompound_stmt /angbracketright::= ‘{’/angbracketleftstmt_star/angbracketright‘}’
/angbracketleftstmt_star/angbracketright::=/angbracketleftstmt/angbracketright*
Figure 2: A normalized grammar in PNF for the program
in Figure 1a. We omit the rules of nonterminals /angbracketlefttype/angbracketright,
/angbracketleftidentifier /angbracketrightand/angbracketleftexpr/angbracketrightfor brevity.
4 APPROACH
Grammar
NormalizerJava
GrammarJavaScript
GrammarC
GrammarOther
Grammar
PNF
Parse T ree
ReducerProgram
PropertyMinimized
Program
Figure 3: Overall Workflow of Perses.
Figure 3 shows the overview workflow of Perses. Conceptu-
ally,Persessupportsanyunambiguouscontext-freegrammars.To
support a specific language, Persesconverts its grammar to the
normal form i.e., Definition 3.1. When Persesis used to reduce
a program Pw.r.t.a property. Persesfirst uses the normalized
grammar to parse Pinto a parse tree T. ThenTis fed to the core
reductionalgorithmconsistingofasetofprogramtransformations.Guidedbythepropertytest,thereducergraduallydeletesirrelevant
elementsfromthetree,andoutputtheminimizedprogramupon
termination./angbracketleftA/angbracketright::=/angbracketleftB/angbracketright/angbracketleftC/angbracketright
|/angbracketleftD/angbracketright
|ϵ
/angbracketleftB/angbracketright::=/angbracketleftA/angbracketright/angbracketleftD/angbracketright
|/angbracketleftC/angbracketright/angbracketleftD/angbracketright
/angbracketleftC/angbracketright::= c
/angbracketleftD/angbracketright::= d
(a) Original grammar./angbracketleftS/angbracketright::=/angbracketleftA/angbracketright|ϵ
/angbracketleftA/angbracketright::=/angbracketleftB/angbracketright/angbracketleftC/angbracketright
|/angbracketleftD/angbracketright
/angbracketleftB/angbracketright::=/angbracketleftA/angbracketright/angbracketleftD/angbracketright
|/angbracketleftC/angbracketright/angbracketleftD/angbracketright
|/angbracketleftD/angbracketright
/angbracketleftC/angbracketright::= c
/angbracketleftD/angbracketright::= d
(b) Preprocessing.
/angbracketleftS/angbracketright::=/angbracketleftA/angbracketright
|ϵ
/angbracketleftA/angbracketright::=/angbracketleftB/angbracketright/angbracketleftC/angbracketright
|/angbracketleftD/angbracketright
/angbracketleftB/angbracketright::=/angbracketleftB/angbracketright/angbracketleftC/angbracketright/angbracketleftD/angbracketright
|/angbracketleftD/angbracketright/angbracketleftD/angbracketright
|/angbracketleftC/angbracketright/angbracketleftD/angbracketright
|/angbracketleftD/angbracketright
/angbracketleftC/angbracketright::= c
/angbracketleftD/angbracketright::= d
(c) Transformation./angbracketleftS/angbracketright::=/angbracketleftA/angbracketright|ϵ
/angbracketleftA/angbracketright::=/angbracketleftB/angbracketright/angbracketleftC/angbracketright|/angbracketleftD/angbracketright
/angbracketleftB/angbracketright::=/angbracketleftG/angbracketright+|/angbracketleftD/angbracketright/angbracketleftE/angbracketright/angbracketleftF/angbracketright
/angbracketleftC/angbracketright::= c
/angbracketleftD/angbracketright::= d
/angbracketleftE/angbracketright::=/angbracketleftD/angbracketright?
/angbracketleftF/angbracketright::=/angbracketleftG/angbracketright∗
/angbracketleftG/angbracketright::=/angbracketleftC/angbracketright/angbracketleftD/angbracketright
(d) Normalization.
Figure 4: An illustrative example for PNF normalization.
4.1 PNF Normalization
This section describes our normalization algorithm for computing
thePersesnormalform(PNF).Ournormalizationalgorithmtakes
asinputanycontext-freegrammarinBNFnotationandoutputsan
equivalent grammar in PNF. The basic idea of our normalization
algorithmistocomputequantifiedrulesbasedongrammartrans-
formations. We notice that the “ ∗” and “+” quantifiers correspond
tothesequencerepetitionsinregularexpressions.Therepetitionistypicallyspecifiedusingleft-orright-linearcontext-freegrammars.
Asaresult,wecouldcomputethe“
∗”and“+”quantifiedrulesfrom
thoseleft-orright-recursionrules.The“?”quantifiedrulescould
be computed by comparing the differences of each pair of rules.
Our normalization algorithm involves three essential steps. We
briefly describe these steps with an example in Figure 4. Figure 4a
shows the original grammar where /angbracketleftA/angbracketrightis the start symbol. The
original grammar is not in the PNF. In particular, the nonterminal
/angbracketleftB/angbracketrightis quantifiable since it could potentially be described by a “ +”-
quantified rule obtainable from the left-recursion rule “ /angbracketleftB/angbracketright/Colonequal
/angbracketleftB/angbracketright/angbracketleftC/angbracketright/angbracketleftD/angbracketright”. However, thegrammarin Figure4adoesnotcontain
any quantified rule. We then discuss PNF normalization as follows.
•Preprocessing. Our preprocessing procedure eliminates the ϵpro-
ductions and unreachable rules. We also assign a random or-dering to all nonterminals in the grammar. The preprocessedgrammar is given in Figure 4b. In particular,
/angbracketleftS/angbracketrightbecomes the
new start symbol.
•Transformation. To facilitate our next normalization step, we
preferleft- orright-recursiveproductions.During thetransfor-
mationprocedure,foreachnonterminalwetrytodescribeitbya
left- or right-recursive production rule according to the original
grammar. Figure 4c shows the example after the transformation,
nonterminal /angbracketleftB/angbracketrightis transformed into a left-recursion form.
•Normalization. In the normalization step, the corresponding left-
orright-recursiveproductionrulesaretransformedintoquan-
tifiedrules.Onceallquantifiablenonterminalshavebeentran-
sitivelydescribedusingquantifiedrules,Weconverttheresult
365
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chengnian Sun, Y uanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su
Algorithm 1: PNF Normalization — Normalization (G)
Input:G: a context-free grammar in BNF notation.
Output:G/prime: an equivalent grammar in PNF.
1Preprocess (G)
2G1←GrammarNormalizationLeft (G)
3G/prime←GrammarNormalizationRight (G1)
4returnG/prime
5Function GrammarNormalizationLeft( G):
Input:G: a context-free grammar in BNF notation.
Output:G: an equivalent grammar without quantifiable nonterminals in
form of left recursion.
6letGcfgbe an empty digraph
7foreachNi→NjαdoGcfg←Gcfg∪{ (Ni,Nj)}
8SCC←Compute_SCC( Gcfg)
9foreachscci∈SCCdo
10 Gi←∅
11 foreachA∈sccidoinsert all rules of the form A→αtoGi
12 G/prime
i←GrammarTransformationLeft (Gi)
13 G/prime
i←QuantifierIntroductionLeft (G/prime
i)
14 G←(G\Gi)∪G/prime
i
15returnG
16Function GrammarTransformationLeft( G):
Input:G: a context-free grammar in BNF notation.
Output:G: an equivalent grammar with direct left recursion
17foreachnonterminal Ni∈Gdo
18 repeat
19 foreachruleNi→Njαi∈Gdo
20 ifj<ithen
21 removeNi→NjαifromG
22 foreachruleNj→αj∈Gdo
23 addNi→αjαitoG
24 untilGrammarGremains unchanged.
25returnG
26Function QuantifierIntroductionLeft( G):
Input:G: a context-free grammar in BNF notation.
Output:G: an equivalent grammar with quantifiers.
27foreachnonterminal Ni∈Gdo
28 StarIntroductionLeft (G,Ni)
29 foreachNi→α1α/prime(α/prime)∗α2do
30 removeNi→α1α/prime(α/prime)∗α2fromG
31 letU1,U2be new auxiliary nonterminals
32 G←G∪{Ni→α1U1α2,U1→U+
2,U2→α/prime}
33 foreachpair of(Ni→αi,Ni→αj), where|αi|≤|αj|do
34 ifαj=α1α/primeα2andαi=α1α2then
35 removeNi→αiandNi→αjfromG
36 letU3,U4be new auxiliary nonterminals
37 G←G∪{Ni→α1U3α2,U3→U4?,U4→α/prime}
38returnG
39Function StarIntroductionLeft( G,N):
Input:G: a set of grammar productions
Input:N: a nonterminal
Output:G: a set of grammar productions with ∗-quantified rules
40A←∅andB←∅
41foreachruleN→α∈Gdo
42 ifα=Nα1thenA←A∪{α1}
43 elseB←B∪{α}
44 removeN→αfromG
45foreachbi∈Bdo
46 denote set Aas{a1,a2,... ,aj}
47 letU1,U2be new auxiliary nonterminals
48 G←G∪{N←biU1,U1→U∗
2,U2→a1|a2|...|aj}
49returnG
grammartoPNFbyintroducingnecessaryauxiliarynontermi-
nals. Figure 4d gives the example grammar in PNF.
Algorithm Overview. Algorithm1describesourPNFnormaliza-
tionalgorithm,whereeach Nirepresentsanonterminalandeach
αirepresents a sequence of terminals and nonterminals.Algorithm 2: The Main Algorithm — Reduce(P,ψ)
Input:P: the program to be reduced.
Input:ψ:P→B: the property to be preserved.
Output:A minimum program p∈Ps.t.ψ(p)
1best←ParseTree (P)
2worklist←{RootNode (best)}
3while|worklist|>0do
4 largest←GetAndRemoveLargestFrom (worklist)
5iflargestis Kleene-Star Node then
6 (best,pending)← ReduceStar (best,ψ,largest)
7else if largestis Kleene-Plus Node then
8 (best,pending)← ReducePlus (best,ψ,largest)
9else if largestis Optional Node then
10 (best,pending)← ReduceStar (best,ψ,largest)
11else if largestis Regular Rule Node then
12 (best,pending)← ReduceRegular (best,ψ,largest)
13else continue // Skip token nodes
14 worklist←worklist∪pending
15return best
Inparticular,lines1-4describethemainnormalizationalgorithm.
After preprocessing, many quantifiable nonterminals may still not
betransitivelydescribedusingquantifiedrules.Ouralgorithmthen
processesthegrammarintwopasses.Thefirstpasshandlestheleft
recursion rules, and the second pass handles the right recursion
rules.Inprinciple,thetwopassesarealmostidentical.Therefore,
we only discuss the first pass.
Online5,thefunction GrammarNormalizationLeft processes
all left recursion rules. We first build a directed graph Gcfgby con-
structingedges (Ni,Nj)fromanonterminal Nitotheleftmostnon-
terminalNjaccording to its productions (lines 6-7). Then, we find
the strongly connected components (SCC) in Gcfgusing Tarjan’s
algorithm (line 8). Each SCC corresponds to at least one recursive
rule.Therefore,thealgorithmperformsgrammartransformation
and grammar normalization for each SCC (lines 12-13).
Grammar Transformation. The function on line 16 performs
grammartransformation.Inparticular,ittransformsanyindirect
recursionruletoanequivalentrulewithleftrecursion.Itutilizes
theassignedordering(line20),anditerativelyreplacesthelower
order nonterminals with its production rules (line 21-23). The pro-
cedure terminates when there is no indirect recursion rules w.r.t.
the ordering (line 24).Grammar Normalization.
The grammar normalization proce-
dureonline26introducesthequantifiersandoutputsanequivalent
grammar in the PNF form. Specifically, it converts the recursive
rulesinto“ ∗”-quantifiedrules(line39),“ +”-quantifiedrules(line29-
32),or“?”-quantifiedrules(line33-37).Lines32,37and48introduce
the quantified rules to the output grammar. Finally, all rules are in
the PNF according to Definition 3.1. The transformation procedure
fully exploits all dependencies among the nonterminals, and the
normalizationprocedureintroducesthequantifiedrules w.r.t.the
definition.ItisstraightforwardtoseethatAlgorithm1preserves
the grammar equivalence.
4.2 Main Reduction Algorithm
Algorithm2liststhemainproceduretoreduceaprogram Pw.r.t.ψ.
The output is a minimum variant derived from Pthat still passes ψ.
Initially,Pisconvertedintoaparsetree bestwiththePNFgrammar.
Then all the following reduction is performed on this parse tree.
366
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Perses: Syntax-Guided Program Reduction ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
The overall reduction process is a prioritized traversal of best.
Algorithm 2maintainsa worklistoftree nodespending reduction,
andeachtimepopsoutthenodewiththemosttokenstoreduceon
line 4. We treat quantified nodes and regular rule nodes differently.
Forexample,ifthenode largestisaKleene-Starnode,wereduce
it with the function ReduceStar on line 6 that returns a pair of
which the first is the reduced result and the second is the pending
nodesforfuturereduction.Theothernodesaretreatedsimilarly
onlywithdifferentfunctions.Whenreducing largestfinishes,we
update the worklistby adding the pending nodes on line 14, and
proceed to the next largest node in worklist.
4.3 Reducing Quantified Nodes
For a Kleene-Star, Kleene-Plus or Optional node, we use ddminto
delete its children, as each child is independent of the others in
terms of syntax validity, which fits in the assumption of DD well.
Reducing Kleene-Star and Optional Nodes. WetreatKleene-
StarandOptionalnodesinthesameway,asOptionalnodesarea
specialcaseofKleene-Star.Algorithm3showsthegeneralreduction
procedure. We use ddminto perform Delta Debugging on all the
childrenof treetoremovethechildren thatareirrelevantto ψ.At
last, we return the minimized tree by removing irrelevant nodes
fromtreeand the remaining children of nodeas the result.
Algorithm 3: ReduceStar (tree,ψ,node)
Input:tree: the parse tree to be reduced.
Input:ψ:P→B: the property to be preserved.
Input:node: the parse tree node to be reduced.
Output:(best,pending):bestis the minimum tree by reducing tree, and
pendingis a set of remaining descendants of node.
1all←Children (node)
2remaining ←ddmin(all,ψ)
3best←tree.CopyAndRemove (all\remaining )
4return(best,remaining )
Reducing Kleene-Plus Node. Reducing Kleene-Plus nodes is
similartoreducingKleene-Starnodes, i.e.,Algorithm3.Italsouses
ddminas the underlying reduction algorithm. The main difference
is that when reducing the children of node, we need to maintain
oneconstraintinducedbythesemanticsofKleene-Plus—atleast
onechildof nodeisnotdeleted.Forexample,whenweareaboutto
test avariant bydeleting allthe childrenof node, weneed tokeep
one child, e.g., the first child, in order to avoid syntax errors.
4.4 Reducing Regular Rule Nodes
Algorithm4showshowaregularrulenodeisreduced.Thegeneral
idea is to replace the tree node nodethat is being reduced with
one of its compatible descendants. The compatibility is determined
based on the subsume relation defined as follows.
Definition 4.1 (Subsume Relation). Given two symbols Aand
B(terminals or non-terminals) in a grammar, Bis subsumed by A
(denoted as B<:A) if one of the following conditions holds:
•A=B
•Bcan be derived from A
For example, /angbracketleftstmt/angbracketright<:/angbracketleftstmt/angbracketright, and/angbracketleftif_stmt/angbracketright<:/angbracketleftstmt/angbracketright. Intu-
itively,/angbracketleftif_stmt/angbracketright<:/angbracketleftstmt/angbracketrightmeansthatanyparsetreeof /angbracketleftif_stmt/angbracketrightcanbesyntacticallysafetobeusedinthecontextwhereaparsetree
of/angbracketleftstmt/angbracketrightisexpected.Wedefinethreeauxiliaryfunctionsrelated
to rule types for a node n.
Rule(n)returnstheproductionrulethatcreatesthenode n.Forex-
ample,theruleofthenode‘ 4.if _stmt’inFigure1eis /angbracketleftif_stmt/angbracketright.
ExpectedRule (n)returns the expected production rule at the po-
sition ofnin the context of its parent Parent(n). For example,
the expected production rule for node ‘ 4.if _stmt’ in Figure 1e
is/angbracketleftstmt/angbracketright, because its parent ‘ 3.stmt _star’ expects each of its
children to be /angbracketleftstmt/angbracketright.
QuantifiedRule (n)onlyappliestoKleenenodes( niseitherKleene-
Star or Kleene-Plus). It returns the quantified production rule of
n. For example, QuantifiedRule returns/angbracketleftstmt/angbracketrightfor the node
‘3.stmt _star’, because it expects a list of /angbracketleftstmt/angbracketrightchildren.
With the subsume relation and auxiliary functions, we can iden-
tify two types of compatible descendants to replace node.
Regular Nodes (lines 2-5) Aregulardescendantnode nofnode
is a replacement candidate if its production rule Rule(n)is sub-
sumed by that of node,i.e.,Rule(n)<:ExpectedRule (node).
Take Figure 1e as an example. Assume that we are reducing
‘4.if _stmt’.Itsexpectedruletypeis /angbracketleftstmt/angbracketrightasaforementioned.
Thenitsdescendant‘ 4.compound _stmt’isacompatiblenode,
astheruletypeofthisdescendantis /angbracketleftcompound _stmt/angbracketrightwhich
is a kind of statements.
Kleene Node (lines 6-10) If the parent of nodeis either Kleene-
Star or Kleene-Plus, then a descendant nis compatible if nis
also a Kleene node and its quantified rule type is subsumed
by the expected rule of node, namely QuantifiedRule (n)<:
ExpectedRule (node).
Forexample,inFigure1e,thenode‘ 6.stmt _star’canreplace
‘4.if _stmt’,becausetheparent‘ 3.stmt _star’of‘4.if _stmt’
quantifies a list of /angbracketleftstmt/angbracketrightnodes, and using ‘ 6.stmt _star’t o
replace ‘ 4.if _stmt’ still maintains the syntactical invariant,
that is, ‘ 3.stmt _star’ still quantifies a list of /angbracketleftstmt/angbracketrightnodes,
thoughthenewlyaddednode‘ 6.stmt _star’introducesalayer
of indirection.
Note that the number of compatible nodes for nodecan be enor-
mous. In order to limit the search space, we require the path L
betweennode(exclusive) and its compatible node n(inclusive) sat-
isfy the following two constraints: (1) The number of nodes in L
is bounded; (2) There is no other compatible node on Lbeforen.
In other words, nis the first compatible node on L. The function
BoundedBFS online18implementsthesetwoconstraints.Inthis
work, we use 4 as the maximum length of L,i.e., line 4 and line 9.
4.5 Fixpoint Reduction Mode
A single run of the reduction function Reducedoes not guarantee
thatthereducedprogramis1-tree-minimal( cf.Section3.1),because
the deletion of one node may enable the deletion of another node.
Forexample,assumetwofunctions fooandmain;foohasmore
tokensthan main;maincalls foo;mainhasthepropertyofinterest,
andfoois irrelevant to this property. When Reduceis reducing
this program, it first reduces foo. However foois referenced by
main,soitcannotbecompletelydeleted.Later,when mainisbeing
367
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chengnian Sun, Y uanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su
Algorithm 4: ReduceRegular (tree,ψ,node)
Input:tree: the parse tree to be reduced.
Input:ψ:P→B: the property to be preserved.
Input:node: the parse tree node to be reduced.
Output:(best,pending):bestis the minimum tree by reducing tree, and
pendingis a set of remaining descendants of node.
1candidates ←∅
2beginsearching for replacement candidates
3 subsume _pred←λn.Rule(n)<:ExpectedRule (node)
4replacement_candidates ←BoundedBFS (node,subsume _pred ,4)
5 candidates ←candidates ∪replacement_candidates
6ifIsKleene (Parent(node))then
7 kleene _pred←λn.IsKleene (n)
8 ∧QuantifiedRule (n)<:ExpectedRule (node)
9quantified_candidates ←BoundedBFS (node,kleene _pred ,4)
10 candidates ←candidates ∪quantified_candidates
11best←node
12foreachc∈candidates do
13t←tree.CopyAndReplace (node,c)
14ifψ(t)∧|t|<|tree.CopyAndReplace (node,best)|then
15 best←{c}
16ifbest=nodethen return (tree,Children (node))
17else return (tree.CopyAndReplace (node,best),best)
18Function BoundedBFS( node,pred,max_depth ):
Input: node: the starting node of breadth-first search
Input: pred:TreeNodes →B: predicate to match tree nodes.
Input: max_depth : depth bound.
Output: result: the matched tree nodes.
19 Queue queue←Children (node)
20 result←∅
21while|queue|>0∧max_depth >0do
22 max_depth ←max_depth −1
23 queue_size ←| queue|
24 fori←0toqueue_size do
25 n←Dequeue(queue)
26 ifpred(n)then
27 result←result∪{n}
28 continue;
29 ifmax_depth >0then
30 foreachc∈Children (n)doEnqueue(queue ,c)
31return result
reduced,thecallto fooisdeleted.Then foocanberemoved.But
it has been visited so Reducewill not delete it in the current run.
Therefore,similartoHDD*[ 16],weproposeafixpointreduction
mode, in which Reduceis repeatedly applied to the reduced result
until no more tree nodes can be removed from the result. And the
final result will be 1-tree-minimal.
5 EVALUATION
We evaluate Perseswith 20 large C programs that trigger bugs in
GCC and Clang, and compare it with DD, HDD, and C-Reduce. On
average, Persesoutperforms the other reducers nearly in every
aspect,e.g.,reducedfilesize(55-98%smallerexceptC-Reduce),num-
berofpropertytests(47-93%fewer),reductiontime(34-77%shorter
exception MultiDelta), and reduction speed(1.1-2.6xspeedup),.
Todemonstratethegeneralityof Perses,weinstantiate Perses
with an ANTLR Java grammar. The evaluation on six benchmarks
confirmsagainthat PersesoutperformsHDDinvariousmetrics.
All experiments are conducted on a Ubuntu machine with an Intel
Core i7-4770 CPU and 16 GB memory.5.1 Evaluation on C Programs
Benchmark Collection. The benchmark C programs are col-
lected from the official bug repositories of two mainstream C com-
pilers (GCC and Clang). We have randomly selected 20 recent bug
reports and requested the unreduced testcase from the original
reporter. The selected bug reports include both crash and miscom-
pilationbugs.Moreover,allselectedbugreportsarereproducible
w.r.t.at least one stable release of the two compilers.
Tools for Comparison. We run PersesandPersesF(Perses
infixpointmode)incomparisonwiththefollowingtools: Delta[15]
(a line-based Delta Debugging tool), DeltaF(Delta in fixpoint
mode),MultiDelta [15] (A variant of Delta that is aware of blocks
inprograms), C-Reduce [17],HDD[16]andHDDF(HDDinfix-
point mode).
5.1.1 Reduction Quality . Table 1 shows the reduction quality
results. It also gives the original token count of a test program and
that of the minimized program by a reducer. In general, Perses
produces much smaller results than the other reducers except C-
Reduce (55-98% smaller ). The row sizein Table 3 shows the av-
erageimprovementof PersesandPersesFoverotherreducers.
Forexample,thesizeoftheresultby PersesFisonly2%ofthatof
Delta,and45%ofHDDF.ComparedtoC-Reduce, Persesproduces
167 tokens more than C-Reduce on average. However, this is ex-
pected, because C-Reduce is a C/C++ language specialized reducer
which performs aggressive semantic program transformations.
5.1.2 Reduction Efﬁciency . Efficiency is another key criterion
toevaluateareducer.Table2andapartofTable1showsthedetails
ofefficiency-wisedata.4Thissectionfurtherquantifiesefficiency
in the following three different metrics.
Number of Property Tests. Thisisthemetricusedin[ 16].Ifthe
property test runs in constant time, then this metric can reliably
reflect the runtime complexity of reducers. Table 1 lists this metric.
PersesFrunspropertytests5095timesonaverage,whichis 2.26x
fewer than MultiDelta, 15.4xfewer than DeltaF,5.37xfewer than
C-Reduceand 3.31xfewerthanHDDF.Therow #testsinTable3
lists the detailed improvement.Reduction Time.
This measures how long a reducer takes to
terminate. It depends on the number of property tests and the time
of each property test. The row timein Table 3 shows the time ratio
between Persesandtheotherreducers.ExceptMultiDelta, Perses
constantly takes shorter time to terminate (34-77% shorter). As far
as MultiDelta, though taking similar time as MultiDelta. Perses
produces much smaller results than MultiDelta.Reduction Speed.
Reductionspeed isthenumberoftokensthat
a reducer can delete per second. The row speedin Table 3 lists
the speed ratio between Persesand the other tools. Both Perses
andPersesFrunfasterthantheothers.Especially Persesisthe
fastest (1.5-3.6x faster than the rest).
4In Table 1 Delta and DeltaFperforms only two property tests, and in Table 2 they
spendzerosecondsonthisbenchmark.Thisisbecauseallthetokensoftheoriginal
test program are placed in a single line, and the line-oriented strategy of Delta just
treats the program as a single line, which demonstrates the limitation of DD.
368
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Perses: Syntax-Guided Program Reduction ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
Table 1: Size information of original and reduced programs, and number of property tests.
BugO (#)Delta MultiDelta DeltaFC-Reduce HDD HDDFPerses PersesF
R(#)Q (#)R(#)Q (#)R(#)Q (#)R(#)Q (#)R(#)Q (#)R(#)Q (#)R(#)Q (#)R(#)Q (#)
clang-22382 21,068 4,426 4,741 3,086 8,061 3,011 12,259 79 19,569 1,554 7,681 221 9,362 1,479 2,517 152 3,601
clang-22704 184,444 5,318 12,847 3,099 11,524 2,732 22,499 58 19,339 1,312 6,562 105 7,783 1,208 2,374 106 3,163
clang-23309 38,647 5,097 7,620 5,861 10,355 3,641 17,758 132 32,875 2,418 11,370 1,197 25,097 2,030 3,115 456 7,394
clang-23353 30,196 3,681 5,310 2,365 6,846 1,493 11,164 67 17,400 1,535 7,977 143 9,711 1,317 2,636 117 3,565
clang-25900 78,960 4,948 14,023 2,514 6,718 2,052 22,952 105 21,448 1,686 7,774 496 15,391 1,387 2,325 265 5,145
clang-26760 209,577 10,992 58,786 9,227 13,842 6,427 67,623 47 19,868 1,386 7,102 424 11,583 1,299 2,198 124 3,489
clang-27137 174,538 18,008 29,861 10,224 21,919 5,914 54,991 52 31,036 4,772 22,561 664 36,554 4,287 5,937 276 8,466
clang-27747 173,840 7,519 19,443 1,633 4,941 919 30,016 116 20,852 775 3,919 312 8,474 863 1,549 121 2,662
clang-31259 48,799 3,753 8,410 3,225 9,791 2,339 14,743 132 28,445 1,863 8,648 697 13,712 1,340 2,357 328 4,726
gcc-59903 57,581 6,592 8,242 7,152 12,276 5,699 19,759 103 54,443 2,086 9,551 754 17,575 2,228 3,241 206 6,509
gcc-60116 75,224 45,160 50,314 8,110 11,739 20,884 574,790 127 40,698 2,979 13,594 1,543 30,523 2,459 3,604 379 7,254
gcc-61383 32,449 14,728 24,857 5,322 8,860 2,817 139,024 92 37,402 2,117 10,354 586 19,969 1,855 2,859 293 6,671
gcc-61917 85,359 35,428 55,073 5,072 10,801 4,788 409,674 63 31,251 1,678 7,940 358 11,688 1,751 2,786 144 4,298
gcc-64990 148,931 5,504 14,056 9,787 25,203 3,317 26,118 82 23,535 1,924 9,195 519 14,972 1,854 3,179 478 6,112
gcc-65383 43,942 5,486 7,712 4,086 9,686 3,724 14,354 83 24,537 1,733 8,235 308 11,926 1,353 2,327 185 3,769
gcc-66186 47,481 5,701 8,575 3,949 11,228 3,680 21,287 133 30,932 1,898 8,928 620 15,933 1,656 2,542 330 5,629
gcc-66375 65,488 5,599 10,071 2,921 9,299 2,948 23,442 60 29,041 2,153 10,040 860 19,890 1,635 2,688 427 5,624
gcc-70127 154,816 7,783 20,412 6,154 14,714 2,671 38,771 84 27,268 2,505 11,895 658 19,324 1,534 2,779 317 5,024
gcc-70586 212,259 12,225 28,960 11,019 19,247 6,272 44,879 145 29,520 3,257 15,247 988 34,330 2,469 3,696 393 7,479
gcc-71626 6,133 6,133 2 235 4,078 6,133 24 6 7,730 538 3,504 53 3,931 596 1,193 53 1,335
mean 94,486 10,704 19,465 5,252 11,556 4,573 78,305 90 27,359 2,008 9,603 575 16,886 1,730 2,795 257 5,095
median 70,356 5,917 13,435 4,579 10,578 3,479 23,197 83 27,856 1,880 8,788 552 15,181 1,584 2,662 270 5,084
ColumnsO,R,Qlist the number of original tokens, the number of tokens after reduction, and the number of queries, respectively.
Table 2: Reduction time and reduction speed.
BugDelta MultiDelta DeltaFC-Reduce HDD HDDFPerses PersesF
T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)T(s)E(#/s)
clang-22382 471 35 462 39 710 25 904 23 532 37 588 35 378 52 442 47
clang-22704 2,556 70 1,991 91 2,915 62 2,182 85 2,816 65 2,873 64 1,143 160 1,205 153
clang-23309 1,375 24 1,096 30 1,751 20 5,586 7 1,998 18 3,733 10 831 44 1,394 27
clang-23353 644 41 570 49 804 36 1,010 30 1,046 27 1,112 27 476 61 543 55
clang-25900 2,707 27 726 105 3,111 25 1,575 50 890 87 1,253 63 522 149 776 101
clang-26760 14,248 14 2,613 77 13,700 15 2,868 73 2,459 85 2,665 78 1,200 174 1,365 153
clang-27137 16,382 10 6,706 25 18,501 9 7,787 22 16,122 11 18,430 9 7,150 24 8,296 21
clang-27747 7,107 23 635 271 7,640 23 1,456 119 638 271 912 190 601 288 797 218
clang-31259 1,446 31 1,149 40 1,674 28 2,887 17 2,078 23 3,504 14 748 63 2,155 22
gcc-59903 2,813 18 2,918 17 3,851 13 4,632 12 1,980 28 2,352 24 1,116 50 1,448 40
gcc-60116 8,955 3 1,330 50 57,722 1 4,888 15 2,704 27 4,441 17 1,409 52 2,475 30
gcc-61383 2,631 7 1,001 27 7,964 4 3,799 9 1,709 18 3,237 10 805 38 1,959 16
gcc-61917 10,732 5 1,576 51 33,502 2 2,847 30 1,565 53 1,685 50 1,043 80 1,154 74
gcc-64990 5,875 24 4,446 31 6,402 23 3,292 45 4,572 32 4,931 30 1,901 77 2,914 51
gcc-65383 904 43 703 57 1,162 35 2,295 19 1,069 39 1,365 32 474 90 660 66
gcc-66186 1,363 31 2,082 21 1,777 25 5,317 9 2,368 19 4,189 11 1,228 37 3,220 15
gcc-66375 3,553 17 2,686 23 4,407 14 8,442 8 4,325 15 8,998 7 1,297 49 3,136 21
gcc-70127 9,044 16 3,265 46 9,822 15 6,191 25 8,495 18 14,101 11 1,827 84 3,580 43
gcc-70586 16,733 12 5,955 34 16,791 12 5,312 40 9,416 22 12,612 17 3,398 62 6,376 33
gcc-71626 0 — 133 44 0 — 232 26 163 34 174 35 68 81 74 82
mean 5,477 24 2,102 56 9,710 20 3,675 33 3,347 46 4,658 37 1,381 86 2,198 63
median 2,760 23 1,453 42 4,129 20 3,090 24 2,038 28 3,055 26 1,080 63 1,421 45
ColumnsT,Elist the time of reduction, and the efficiency in tokens per second, respectively.
Table3:Ratioofvariousmetricsbetween Persesandothers.
Delta MultiDelta DeltaFC-Reduce HDD HDDF
sizePerses 16% 33% 38% 1,922% 86% 300%
PersesF2% 5% 6% 285% 13% 45%
#testsPerses 14% 24% 4% 10% 29% 17%
PersesF26% 44% 7% 19% 53% 30%
timePerses 25% 66% 14% 38% 41% 30%
PersesF40% 105% 23% 60% 66% 47%
speedPerses 3.6x 1.5x 4.3x 2.6x 1.9x 2.3x
PersesF2.6x 1.1x 3.2x 1.9x 1.4x 1.7x5.2 Evaluation on Java Programs
Wedemonstratethegeneralityof Persesbyinstantiatingitwith
anANTLRJavagrammartoreduceJavaprograms.Tothebestof
ourknowledge, Persesisbyfarthemosteffectiveprogramreducer
for Java, as there is no C-Reduce-like tool for Java.
WemanuallycheckedtheofficialbugrepositoriesofOpenJDK
andEclipseCompilerforJava(ECJ),andcollected5bugsthatcanbe
reproducedandhave unreduced inputprogramsattachedinthebug
reports.Table4showsthereductionresults. Persesoutperforms
HDD. In general, Persesis2.07xfaster, produces 1.13xsmaller
results, and reduces 3.99xfewer queries than HDD.
369
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden Chengnian Sun, Y uanbo Li, Qirun Zhang, Tianxiao Gu, and Zhendong Su
Table 4: Results of Java benchmarks.
Bug O (#)HDDFPersesF
R(#)Q (#)T(s)R(#)Q (#)T(s)
ecj-352665 1,142 180 2,921 364 157 834 166
ecj-361938 438 16 114 10 16 29 9ecj-404146 348 170 1,787 147 155 403 78
jdk-8068399 447 81 998 127 69 207 60jdk-8145466 462 53 368 42 44 77 20
Total 2,837 500 6,188 690 441 1,550 333
ColumnsO,R,QandTlist the number of original tokens, the number
of tokens after reduction, the number of queries, and the reduction time,
respectively.
6 DISCUSSION
Generality to Programming Languages. Persesisageneral
reductionframework,anditmakes noassumptionaboutspecific
programming languages. It takes as input language grammars, and
thus is able to exploit any language-specific syntactical properties
(e.g., which nodes can be replaced with other nodes, or deleted) of
the programs under reduction. All transformations presented in
Section4arebasedonthePNF.Anycontext-freegrammarcould
be converted to PNF. Therefore, Persesis applicable to any pro-
gramming language. This is why we can easily, effectively support
reducingJavaprogramsinadditiontoCaspresentedinSection5.2,
which requires little effort on integrating the Java grammar.
Generality to Other Test Inputs. Although we only focus on
program reduction in this paper, Persesis capable of reducing
other structured test inputs ( e.g., XML and HTML documents).
PersesisexpectedtoperformatleastaswellasHDD.Wefocus
on program reduction since programs have much more complex
constraints(intermsofbothquantityandcomplexity)overtheir
syntacticalstructuresthaneitherXMLorHTML.Thesecomplex
constraints significantly increase the difficulty of reduction and
increase the search space of invalid variants Pinvalidas well.
Extensibility. The transformations described in Section 4 are
the first attempt to instantiate the Persesreduction framework.
More transformations can be designed. Persescurrently supports
reducing production rules either by deletion ( cf., Section 4.3) or
replacement( cf.,Section4.4).Wecandefinenewtransformations
to increase Pvalid. for example, replacing long string literals with
an empty string, converting an expression by appending ‘ ;’t o
an expression statement to replace an existing large statement.
Before Perses,duetotheomissionoftheinformationingrammar
definitions, it is impossible to design such an extensible reduction
tool in a general way . Persesmakes this feasible.
7 RELATED WORK
The most related work to Persesis Hierarchical Delta Debug-
ging[16]thatexploitsthetreestructureofthetestinputs.Hodován
et al.proposed an approach to speed up HDD in [ 5]. Delta De-
bugging[ 24]istheseminalworkontestcasereduction.However,
neither of them address the syntactical validity for program re-
duction.Asaresult,theywasteaconsiderableamountoftimein
exploring the invalid search space Pinvalid. Many delta-debugging-
based frameworks leverage the underlying language feature to
achieve almost optimal program reduction for a specific language.For instance, JS Delta [ 8] relies on the WALA static analysis infras-
tructure [ 6] to reduce JavaScript programs. C-Reduce [ 17] employs
a set of heuristics for efficient program reduction based on the
C/C++ semantics obtained from Clang. Our evaluation shows that
in terms of the reduction throughput (i.e., the number of tokens
deleted per second), Persesis 1.67×faster than C-Reduce.
For reducing C programs, it is possible to combine both Perses
andC-Reduce.Specifically,wecouldrun Persestoquicklyremove
irrelevant program elements, and then use C-Reduce to obtain the
almost optimal reduction result. Le et al.introduce a meta-reducer
by combining Berkeley Delta [15] and C-Reduce in their EMI test-
ingproject[ 9–11,20].Persescan improve theperformanceofthe
meta-reducerbyreplacingBerkeleyDelta.Recently,Herfert et al.
proposeaGeneralizedTreeReduction(GTR)algorithmwhichcom-
bines a generic set of transformations for a particular language by
learningfromacorpusofexampledata[ 18].Persesisageneral
framework and does not require any prior knowledge on the in-
put data. Persescould also be used for reducing other structured
testcasessuchasminimizingstructuredtextformatsforsecurity
testing[12,19].Binkley et al.proposeanObservationalProgram
Slicing(OPS)techniquetoreduceaprogrambasedontheresults
ofpropertychecks[ 3,23].Toreduceaprogram,theOPStechnique
uses line deletion whereas Perses manipulates trees. Perses is more
general and supports arbitrary program properties.
8 CONCLUSION
In this paper, we propose a novel, effective program reduction
framework Perses.SameasHDD,itisgeneraltoanyprogramming
languagesandperformsreductionontheparsetreesofprograms.
Butdifferently,itisawareofthesyntacticalconstraintsbetween
nodes,andthusguaranteesnogenerationofsyntacticallyinvalid
programs during reduction and enables more effective program
transformations.ItsignificantlyoutperformsDD,HDDandeven
C-Reduce—a specialized reducer for C/C++ programs—in terms of
size of reduced programs and efficiency of reduction.
In order to further demonstrate the generality of Perses,w e
instantiate with anAntlr grammar for Java. The evaluationon six
bugsinJavacompilersshowsthat Persesrunsmuchfasterthan
HDD and produced much smaller results, which is consistent with
the evaluation on C programs.
Webelievethat Perses’sintegrationofsyntacticalknowledge
opens a new way towards general, effective, and efficient program
reduction.Consequently,inthefuturemoreprogramtransforma-
tionscanbeeasilydesignedandimplementedwithin Perses,either
general or specific to a certain programming language.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable feedback.
This research was supported in part by the United States National
ScienceFoundation(NSF)Grants1319187,1528133,and1618158,and by a Google Faculty Research Award. The information pre-
sentedheredoesnotnecessarilyreflectthepositionorthepolicy
of the Government and no official endorsement should be inferred.
REFERENCES
[1]Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. 1986. Compilers: Principles,
Techniques, and Tools. Addison-Wesley.
370
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. Perses: Syntax-Guided Program Reduction ICSE ’18, May 27-June 3, 2018, Gothenburg, Sweden
[2]ANTLR. 2017. The ANTLR Parser Generator. (2017). http://www.antlr.org/,
accessed: 2017-08-05.
[3]David Binkley, Nicolas Gold, Mark Harman, Syed S. Islam, Jens Krinke, and
Shin Yoo. 2014. ORBS: language-independent program slicing. In Proceedings
ofthe2014 ACMSIGSOFT InternationalSymposiumonFoundationsofSoftware
Engineering. 109–120.
[4]GCC. 2017. A Guide to Testcase Reduction. (2017). https://gcc.gnu.org/wiki/A_
guide_to_testcase_reduction, accessed: 2017-08-05.
[5]Tony Hoare. 2003. The verifying compiler: A grand challenge for computing
research. In Modular Programming Languages. Springer, 25–35.
[6]IBM.2017. TheT.J.WatsonLibrariesforAnalysis. (2017). http://wala.sourceforge.
net/, accessed: 2017-08-05.
[7]JavaCC.2017. TheJavaParserGenerator. (2017). https://javacc.org/,accessed:
2017-08-05.
[8]JS Delta. 2017. JS Delta. (2017). https://github.com/wala/jsdelta, accessed:
2017-08-05.
[9]Vu Le, Mehrdad Afshari, and Zhendong Su. 2014. Compiler Validation via Equiv-
alenceModuloInputs.In Proceedingsofthe2014ACMSIGPLANConferenceon
Programming Language Design and Implementation (PLDI).
[10]VuLe,ChengnianSun,andZhendongSu.2014. RandomizedStress-Testingof
Link-Time Optimizers. In Proceedings of the 2015 International Symposium on
Software Testing and Analysis (ISSTA).
[11]VuLe,ChengnianSun,andZhendongSu.2015. FindingDeepCompilerBugsvia
Guided Stochastic ProgramMutation. In Proceedings of the2015 ACM SIGPLAN
InternationalConferenceonObject-OrientedProgramming,Systems,Languages,
and Applications (OOPSLA 2015). ACM, New York, NY, USA, 386–399.
[12]Sebastian Lekies, Ben Stock, and Martin Johns. 2013. 25 million flows later:
large-scale detection of DOM-based XSS. In CCS. 1193–1204.
[13]LLVM. 2017. How to submit an LLVM bug report. (2017). https://llvm.org/docs/
HowToSubmitABug.html, accessed: 2017-08-05.
[14]LLVM/Clang. [n. d.]. Clang documentation – LibTooling. ([n. d.]). https:
//clang.llvm.org/docs/LibTooling.html, accessed: 2017-08-06.
[15]ScottMcPeak,DanielS.Wilkerson,andSimonGoldsmith.[n.d.]. BerkeleyDelta.
([n. d.]). http://delta.tigris.org/, accessed: 2017-08-20.[16]GhassanMisherghiandZhendongSu.2006. HDD:HierarchicalDeltaDebugging.
InProceedings of the 28th International Conference on Software Engineering (ICSE
’06).ACM,NewYork,NY,USA,142–151. https://doi.org/10.1145/1134285.1134307
[17]John Regehr, Yang Chen, Pascal Cuoq, Eric Eide, Chucky Ellison, and Xuejun
Yang.2012. Test-casereductionforCcompilerbugs.In Proceedingsofthe2012
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation
(PLDI). 335–346.
[18]Jibesh Patra Satia Herfert and Michael Pradel. 2017. Automatically Reducing
Tree-Structured Test Inputs. In ASE. To appear.
[19]PrateekSaxena,SteveHanna,PongsinPoosankam,andDawnSong.2010. FLAX:
SystematicDiscoveryof Client-sideValidation VulnerabilitiesinRichWebAp-
plications. In NDSS.
[20]ChengnianSun,VuLe,andZhendongSu.2016. Findingcompilerbugsvialive
code mutation. In Proceedings of the 2016 ACM SIGPLAN International Conference
on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2016. 849–863.
[21]Chengnian Sun, Vu Le, Qirun Zhang, and Zhendong Su. 2016. Toward Under-
standingCompilerBugsinGCCandLLVM.In Proceedingsofthe25thInternational
Symposium on Software Testing and Analysis (ISSTA 2016). 294–305.
[22]XuejunYang,YangChen,EricEide,andJohnRegehr.2011. Findingandunder-
standingbugsinCcompilers.In Proceedingsofthe2011ACMSIGPLANConference
on Programming Language Design and Implementation (PLDI). 283–294.
[23]ShinYoo,DavidBinkley,andRogerD.Eastman.2014. SeeingIsSlicing:Observa-
tionBasedSlicingofPictureDescriptionLanguages.In Proceedingsofthe2014
IEEE International Working Conference on Source Code Analysis and Manipulation.
175–184.
[24]Andreas Zeller and Ralf Hildebrandt. 2002. Simplifying and Isolating Failure-
Inducing Input. IEEE Trans. Softw. Eng. 28, 2 (Feb. 2002), 183–200. https://doi.
org/10.1109/32.988498
[25]Qirun Zhang, Chengnian Sun, and Zhendong Su. 2017. Skeletal program enu-
meration for rigorous compiler testing. In Proceedings of the 38th ACM SIGPLAN
ConferenceonProgrammingLanguageDesignandImplementation.ACM,347–361.
371
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 10:52:13 UTC from IEEE Xplore.  Restrictions apply. 