Coexecutability for EfÔ¨Åcient VeriÔ¨Åcation of Data
Model Updates
Ivan Boci ¬¥c, TevÔ¨Åk Bultany
Department of Computer Science
University of California, Santa Barbara, USA
bo@cs.ucsb.eduybultan@cs.ucsb.edu
Abstract ‚ÄîModern applications use back-end data stores for
persistent data. Automated veriÔ¨Åcation of the code that updates
the data store would prevent bugs that can cause loss or
corruption of data. In this paper, we focus on the most challenging
part of this problem: automated veriÔ¨Åcation of code that updates
the data store and contains loops. Due to dependencies between
loop iterations, veriÔ¨Åcation of code that contains loops is a hard
problem, and typically requires manual assistance in the form of
loop invariants. We present a fully automated technique that
improves veriÔ¨Åability of loops. We Ô¨Årst deÔ¨Åne coexecution , a
method for modeling loop iterations that simpliÔ¨Åes automated
reasoning about loops. Then, we present a fully automated
static program analysis that detects whether the behavior of
a given loop can be modeled using coexecution. We provide
a customized veriÔ¨Åcation technique for coexecutable loops that
results in more effective veriÔ¨Åcation. In our experiments we
observed that, in 45% of cases, modeling loops using coexecution
reduces veriÔ¨Åcation time between 1 and 4 orders of magnitude.
In addition, the rate of inconclusive veriÔ¨Åcation results in the
presence of loops is reduced from 65% down to 24%, all without
requiring loop invariants or any manual intervention.
I. I NTRODUCTION
Nowadays, it is common for software applications to store
their persistent data in a back-end data store in the cloud.
For many application domains, such as social networking,
data is the most valuable asset of an application. Hence, the
correctness of the code that updates the data is of signiÔ¨Åcant
concern. In this paper, we present automated veriÔ¨Åcation
techniques that improve the veriÔ¨Åability of code that update
the data.
Typically, application programmers write object oriented
code for accessing and updating the data in the back-end
data store. This code is automatically translated to data-
store queries using Object Relational Mapping (ORM). Mod-
ern software development frameworks use the Model-View-
Controller (MVC) [23] architecture to separate the user inter-
face code (View) from the code that handles the user requests
(Controller), and the code that accesses and modiÔ¨Åes the data
store (Model). The inherent modularity in this architecture
creates opportunities for automated veriÔ¨Åcation. In a typical
RESTful [11] MVC-based application, user requests trigger
execution of actions that read from or write to the back-end
data store using an ORM library. Data store related bugs can be
eliminated by verifying the implementations of these actions.
This work is supported in part by the NSF grant CCF-1423623.1class PostsController
2 def destroy_tags
3 ...
4 posts = Post.where(id: params[:post_ids])
5 ...
6 posts.each do |p|
7 p.tags.destroy_all!
8 end
9 ...
10 end
11end
Fig. 1. An Example Action
In our earlier work [5], we demonstrated that one can
check invariants about the data store by translating veriÔ¨Åcation
queries about actions to satisÔ¨Åability queries in First Order
Logic (FOL), and then using an automated FOL theorem
prover to answer the satisÔ¨Åability queries. However, due to
undecidability of FOL, an automated theorem prover is not
guaranteed to come up with a solution every time, and some-
times it may time-out without providing a conclusive result.
In particular, actions that have loops in them are hardest to
check automatically. VeriÔ¨Åcation of code that contains loops
typically requires manual intervention where the developer
has to provide a loop invariant in order to help the theorem
prover in reasoning about the loop. This reduces the level of
automation in the veriÔ¨Åcation process and, hence, its practical
applicability.
In this paper, we present a fully automated technique that
signiÔ¨Åcantly improves the veriÔ¨Åability of actions with loops.
Our key contribution is the deÔ¨Ånition of a concept we call
coexecution , which, while intuitively similar to parallel or
concurrent execution, does not correspond to an execution
on actual hardware. It is a concept we introduce speciÔ¨Åcally
to make veriÔ¨Åcation easier. We call a loop coexecutable if
coexecution of its iterations is equivalent to their sequential
execution. We present an automated static analysis technique
that determines if a loop is coexecutable. We also developed
a customized translation of coexecutable loops to FOL that
exploits the coexecution semantics and improves veriÔ¨Åability.
We implemented these techniques for veriÔ¨Åcation of actions
that update the data model in applications written using
the Ruby-on-Rails (Rails) framework [26]. We applied our
approach to veriÔ¨Åcation of actions extracted from real world
Rails applications. Our experimental results demonstrate that
exploiting the coexecutability property signiÔ¨Åcantly improves
the veriÔ¨Åability of actions with loops.{p1, p2, p3, t1, t2, t3,
‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}
{p1, p2, p3, t3}
{p1, p2, p3, t3}{p1, p2, p3, t2, t3, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}Iteration execution for p1
Delta: remove{t1, ‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©}
Iteration execution for p2
Delta: remove{t2, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}{p1, p2, p3, t1, t2, t3,
‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}{p1, p2, p3, t1, t2, t3,
‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}
Delta union: remove{t1, t2,
‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}{p1, p2, p3, t1, t3, ‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©}
{p1, p2, p3, t3}Iteration execution for p3
Delta: empty{p1, p2, p3, t2, t3, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©} {p1, p2, p3, t3}Iteration execution for p1
Delta: remove{t1, ‚ü®p1, t1‚ü©, ‚ü®p2, t1‚ü©}Iteration execution for p2
Delta: remove{t1, t2, ‚ü®p1, t2‚ü©,
‚ü®p2, t1‚ü©, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}Iteration execution for p3
Delta: remove{t2, ‚ü®p2, t2‚ü©, ‚ü®p3, t2‚ü©}
Delta union(a) Sequential Execution (b) Coexecution
Fig. 2. Sequential execution compared to Coexecution
The rest of the paper is organized as follows. Section II
provides an overview of the problem and presents coexecution
at an intuitive level. Section III formally deÔ¨Ånes data stores
and sets up the foundation for Section IV, in which we
deÔ¨Åne coexecution and deÔ¨Åne and prove the coexecutability
condition. Section V presents the static program analysis
algorithm that decides whether a given loop is coexecutable.
Section VI demonstrates the beneÔ¨Åts of modeling loops using
coexecution on loops extracted from real world applications.
Section VII discusses related work, and Section VIII concludes
the paper.
II. O VERVIEW
Recently, we presented an automated veriÔ¨Åcation frame-
work [5] for verifying the actions that update the data, which
1) translates the action code and user-speciÔ¨Åed invariants into a
formal model we call Abstract Data Store (ADS), 2) translates
veriÔ¨Åcation queries about ADS speciÔ¨Åcations into Ô¨Årst order
logic (FOL), and 3) veriÔ¨Åes them using an off-the-shelf FOL
theorem prover [32].
The key obstacle in automated veriÔ¨Åcation of actions is
veriÔ¨Åcation of loops. The inclusion of even simple loops in
actions greatly increases veriÔ¨Åcation time, and it also increases
the chance that the theorem prover times out without ever
reaching a conclusion on whether the given action breaks
an invariant. Upon manual inspection of the theorem prover
deduction logs, we found out that the key issue that the
theorem prover struggles with is reasoning about the iteration
interdependencies in loops.
In order to verify loops, it is necessary for the automated
theorem prover to deduce the rules that deÔ¨Åne which objects
and associations will exist after the loop has executed. To ac-
complish this, the theorem prover has to compute the transitive
closure of the loop body which is not expressible in FOL,
hence FOL theorem provers cannot make such deductions.
Lacking that capability, the theorem prover attempts to deduce
the state of the data store after the Ô¨Årst iteration has executed,
then after the second iteration has executed, etc. Since we do
not bound the number of iterations, unless the theorem prover
discovers a way to violate the invariant without reasoning
about the loop, which is a very speciÔ¨Åc case, the automateddeduction process employed by the theorem prover does not
terminate. This causes the theorem prover to time-out without
a conclusive result.
A. Coexecution Overview
Figure 1 presents an example Rails action based on an open
source discussion platform called Discourse [7]. This action
deletes all the Tagobjects associated with a set of Post objects.
The set of Post objects that are chosen by the user are assigned
to a variable called posts in line 4. Then, using a loop (lines
6 to 8) that iterates over each Post object in posts (with the
loop variable p), all the Tagobjects that are associated with
the objects in posts are deleted.
A data store invariant about the Discourse application could
be that each Tagobject in the data store is associated with at
least one Post object. In order to verify such an invariant, we
need to prove that each action that updates the data store (such
as the one shown in Figure 1) preserves the invariant.
As we discussed above, actions with loops are especially
hard to verify when translated to FOL. The observation
that lead to the technique we present in this paper is, the
loops can often be modeled in a way that does not require
iteration interdependency. And, in such cases, it is possible to
translate the loops to FOL in a way that is more amenable to
veriÔ¨Åcation. We call this alternate execution model for loops
that removes iteration interdependency coexecution .
Consider the action shown in Figure 1. Assume that the
initial data store state contains three Post objectsp1,p2and
p3and three Tag objectst1,t2andt3, with the following
associations:hp1;t1i;hp2;t1i;hp2;t2i;hp3;t2i. Also, assume
that the loop iterates on all the Post objects in the order
p1;p2;p3(i.e., the variable posts is the ordered collection
ofp1;p2;p3).
Given this initial state, the standard sequential execution
semantics of the loop in lines 6 to 8 in Figure 1 is shown in
Figure 2(a) where gray rectangles with rounded corners denote
states of the data store, and solid line arrows denote iteration
executions.
The Ô¨Årst iteration, executed for Post p1 , deletes all Tags of
p1and their associations. We identify the operations executed
by this iteration and summarize them as a delta of thisoperation (i.e., the changes in the data store state caused by this
operation). The Ô¨Årst iteration removes t1and all associations
oft1(hp1;t1iandhp2;t1i). Similarly, the second iteration
deletes all Tags ofp2, resulting in a delta that removes t2,
hp2;t2iandhp3;t2i. Finally, the third iteration does not alter
the data store state as p3is not associated with any Tags at
that point.
Figure 2(b) demonstrates the alternate coexecution seman-
tics for the same loop. Instead of executing iterations sequen-
tially to reach the post-state, we Ô¨Årst identify the delta for each
iteration directly from the pre-state, in isolation from other
iterations. As expected, the Ô¨Årst iteration (the one for p1) is
identical to the one from Figure 2(a). However, the iteration
forp2deletes all Tags ofp2, its delta removing t1andt2
and all their associations. Note that this delta is different from
the delta of the sequential execution iteration for p2shown
in Figure 2(a). Similarly, the iteration for p3deletest2and
all associations whereas sequential execution for p3produced
an empty delta. The deltas of these independent executions
are combined together using the delta union operation, which
in this case returns a union of all the delete operations (we
formally deÔ¨Åne the deltas and the delta union operation in
Section IV). In this example, the uniÔ¨Åed delta removes t1,
t2and their associations. Finally, we use the uniÔ¨Åed delta
to migrate from the pre-state to the post-state in one step,
reaching the same post-state we acquired using sequential
execution as shown in Figure 2(b). We call this one step
execution semantics based on the uniÔ¨Åed delta, coexecution.
For some loops, based on the dependencies among loop iter-
ations, coexecution will yield a different result than sequential
execution. However, coexecution is equivalent to sequential
execution for some classes of interdependencies. Note that,
in our example, iterations areinterdependent (since the p1
iteration prevents the p2iteration from deleting t1and its
associations), and yet coexecution and sequential execution
produce identical results. In Section IV-C, we formally deÔ¨Åne
theCoexecutability Condition that, if true for a given loop,
guarantees that coexecution of the loop is equivalent to se-
quential execution of iterations. In Section V we implement
this condition as a static program analysis, and based on this
analysis we are able to translate loops to FOL in a manner
that is more amenable to veriÔ¨Åcation.
In our analysis, we assume that actions that update the data
store are executed as transactions (which is the case for most
MVC-based web applications). Hence, the database ensures
that actions do not interfere with one another during runtime.
Effectively, all actions can be considered to execute within
atomic blocks, and hence, so are the loops we are verifying.
This gives us to freedom to model operations within a loop
in any order, as long as the Ô¨Ånal effects of the loop execution
are identical to the effects of sequential execution.
III. F ORMAL MODEL
In this section we present the formal model we use for
modeling data stores.A. Data Store
Semantically, an abstract data store is a structure DS=
hC;R;A;IiwhereCis a set of classes, Ris a set of relations,
Ais a set of actions, and Iis a set of invariants.
The set of classes CidentiÔ¨Åes the types of objects that
can be stored in the data store. Each class can have a single
superclass or no superclass ( superclass(c)2C[f?g ) and,
transitively, the superclass relation cannot contain cycles. A
relationr=hname;c o;ct;cardi2Rcontains the name of
the association, an origin class co2C, a target class ct2C
and a cardinality constraint card (such as one-to-one, one-to-
many etc.).
1) Data Store States: Given a data store DS =
hC;R;A;Ii, the set of all possible data store states is denoted
asDS. Each data store state is a structure hO;Ti2DSwhere
Ois a set of objects andTis a set of tuples . Together, we
refer to objects and tuples as entities .
We simplify our notation by using certain operators on ob-
jects and tuples indiscriminately. For a state s=hO;Ti2DS,
objectoand tupletthat may or may not be in s:
s[fog=hO[fog;Ti
snfog=hOnfog;Ti
o2s,o2Os[ftg=hO;T[ftgi
snftg=hO;Tnftgi
t2s,t2T
Objects are instances of classes, whereas tuples are instances
of relations. Each object o2Ois an instance of a class
c2Cdenoted by c= classof(o). Each tuple t2Tis in
the formt=hr;oo;otiwherer=hname;c o;ct;cardi2R
andclassof(oo) =coandclassof(ot) =ct. For a tuple
t=hr;oo;otiwe refer toooas the origin object and otas the
target object, and 8t=hr;oo;oti;8s2DS:t2s)oo2
s^ot2s. Cardinality constraints of each relation r2Rmust
be satisÔ¨Åed by every data store state in DS.
Note that, in the abstract data store model, objects do not
have basic Ô¨Åelds. This model focuses on objects and how they
are associated with one another. Basic Ô¨Åelds can be introduced
to the model by treating them as associations to a basic type
class. For example, an ageÔ¨Åeld would be an association to
one object of the Integer class (this way of treating basic
Ô¨Åelds has been used in Alloy [19], [20] for example). Observe
that, in the abstract data store model, all updates consist of
creations and deletions of entities (i.e., objects and tuples).
2) Actions and Invariants: Given a data store DS =
hC;R;A;Ii,Adenotes the set of actions. Each action
a2Acorresponds to a set of possible state transitions
hhO;Ti;hO0;T0iiDSDS. Actions characterize possible
updates to data store states (i.e., the transitions between the
states).
Given a data store DS =hC;R;A;Ii,Iis the set of
invariants. An invariant i2Icorresponds to a Boolean
functioni:DS!ffalse;truegthat identiÔ¨Åes the set of data
store states which satisfy the invariant.
3) Behaviors: Given a data store DS=hC;R;A;Ii, a
behavior of a data store DS is an inÔ¨Ånite sequence of data
store statess0;s1;s2:::where
8k0 :sk2DS^9a2A:hsk;sk+ 1i2a
8k0;8i2I:i(sk) =trueIn other words, each behavior of a data store starts with an
initial data store state for which all invariants hold, and each
pair of consecutive states corresponds to execution of a data
store action.
Given a data store DS=hC;R;A;Ii, all states that appear
in a behavior of DS are called the reachable states ofDS
and denoted as DSR.
B. Statements
An action is composed of a Ô¨Ånite number of statements .
A statement can be represented as a set of pairs of states
hs;s0i DSDS which semantically represent possible
state transitions by means of that statement. For a statement
Sand two states sands0, we will use [s;s0]Sto denote that
hs;s0iis a possible execution (state transition) of S.
For example, a statement Scthat creates an object of class
C could be deÔ¨Åned as:
[s;s0]Sc$9oc: classof(oc) =C^ 
oc2s0^oc62s^ 
8e: (e2s$e2s0)_e=oc
As an other example, consider a Block statementBwhich
is a sequence of statements Ai, for 1infor somen.
StatementA1transitions between states sands1if and only
if[s;s1]A1. The set of states that the sequence A1;A2can
transition to from sis equal to the union of all states that
A2can transition to from any state s1such that [s;s1]A1.
Therefore,8s;s02DSDS: [s;s0]A1;A2,(9s12DS:
[s;s1]A1^[s1;s0]A2). If we extrapolate this reasoning to the
whole block B:
8s;s02DSDS: [s;s0]B,(9s1;s2:::sn 12DSDS:
[s;s1]A1^[s1;s2]A2^^ [sn 1;s0]An)
1) ForEach Loop Statement: AForEach loop statement
(FE) is deÔ¨Åned by two parameters: the set of objects being
iterated over, denoted as , and the block of code Bthat will
be executed for each member of . Letjj=n. The order
of iteration is non-deterministic. Bhas access to the iterated
object and, therefore, the set of possible executions of Bis
affected by the iterated variable. Effectively, each iteration is
a different state transition: we use notation [s;s0]Boto refer
to a possible execution of an iteration executed for object o.
In this case, we refer to oas the trigger object . The formula
deÔ¨Åning the FE loop is:
8s;s02DSDS: [s;s0]FE,9o1:::on2;9s1:::sn2DS:
8i;j2[1:::n] :i6=j,oi6=oj^ (1)
[s;s1]Bo1^[s1;s2]Bo2^^ [sn 1;sn]Bon^sn=s0(2)
In other words, a pair of states is an execution of a given loop
FE if and only if there exists a selection of objects from 
and a sequence of states such that (1) the said selection of
objects is a permutation of , and (2) the said sequence of
states is achievable by triggering iterations in the order of the
object permutation (2).
There exists a corner case where an object that is about
to trigger an iteration gets deleted by a prior iteration. We
did not include this corner case as part of the deÔ¨Ånition as
it introduces considerable complexity, but the semantic is as
follows: such an iteration will still execute with an empty set
iterator variable value. This behavior is in concordance withour abstraction and the behavior of ORM tools when objects
are deleted before triggering iterations.
IV. C OEXECUTABILITY
Automated reasoning about loops is difÔ¨Åcult since it is nec-
essary to take into account many possible intermediate states
that can appear during the loop execution. A loop invariant can
provide a compact characterization of the intermediate loop
states and help with automated reasoning, but loop invariant
discovery is itself a difÔ¨Åcult problem, and loop invariants
are typically speciÔ¨Åed manually. The coexecution concept we
introduce in this paper is a novel approach that enables us
to reason about the loop behavior without loop invariants and
reasoning about intermediate states.
Below, we formally deÔ¨Åne coexecution. We also give a
condition under which coexecution is equivalent to sequential
execution, and we call this property coexecutability. Note that
multiple iterations of a loop correspond to repeated sequential
execution of the loop body. In order to simplify our presenta-
tion, we will discuss how any two statements AandBcan be
coexecuted (which, for example, can represent the execution
of the same loop body twice for different values of the iterator
variable). This discussion can be extended to coexecution of
any number of statements, and, hence, is directly applicable to
loops by treating iterations of a loop as separate statements.
In this section, for brevity and simplicity, we will as-
sume that the data store we reason about contains only one
class called Class and only one relation called relation
that associates objects of type Class with objects of type
Class with many-to-many cardinality. This allows us to use
minimal notation for data-store states, avoiding the need to
explicitly provide type information. For example, the state
fa;b;c;ha;bi;ha;cigcontains exactly three objects of type
Class , as well as two tuples of the relation type that associate
objectawith the other two.
As we discussed earlier, given two statements AandB,
their sequential composition A;Bis deÔ¨Åned by the sequential
execution formula below:
8s;s02DSDS: [s;s0]A;B,9si: [s;si]A^[si;s0]B (3)
A. Execution Deltas
In order to deÔ¨Åne coexecution, we Ô¨Årst need to deÔ¨Åne a way
to express the effects of executing statements. Let us deÔ¨Åne
a structurehOc;Tc;Od;Tdifor that purpose: OcandTcare
sets of objects and tuples, respectively, that are created by a
given execution, and OdandTdare sets of objects and tuples,
respectively, that are deleted by a given execution. Let us call
this structure the delta of an execution.
Given an execution from state stos0, we denote the delta
of this execution as s0	s. For example, if given two states
s1=fa;b;ha;bigands2=fa;b;cg, thens2	s1=
hfcg;fg;fg;fha;bigiands1	s2=hfg;fcg;fha;big;fgi.
A delta is consistent if and only if its corresponding create
and delete sets are mutually exclusive, i.e.,
Oc\Od=Tc\Td=;^
(8t=hoo;oti2Tc:oo62Od^ot62Od)^
(8t=hoo;oti2Td:oo62Oc^ot62Oc)In order to combine the changes done by different execu-
tions, we introduce the union ( [) of two deltas:
81=hOc1;Tc1;Od1;Td1i;2=hOc2;Tc2;Od2;Td2i:
1[2=hOc1[Oc2;Tc1[Tc2;Od1[Od2;Td1[Td2i
We will use this operation to merge the changes done by
independently executed statements. Note that the result of
the union operation may not be a consistent delta even if
all the arguments were individually consistent. We call deltas
conÔ¨Çicting if and only if their union is not consistent.
1) Delta Apply Operation: We will introduce the apply
operation, that takes a state sand a consistent delta and
updates the state as dictated by the delta. The result is a new
state that contains all objects and tuples that existed in sand
were not deleted by , and all objects and tuples created by
. In addition, whenever an object is deleted, all the tuples
referring to that object are deleted as well. The apply operation
maps a state and a consistent delta into a state, and we use the
operator to denote this operation. Formally, given a state s
and a consistent delta =hOc;Tc;Od;Tdi:
8s=hO;Ti2DS;s0=hO0;T0i2DS:s0=s,
(8o:o2O0,(o2O_o2Oc)^o62Od)^
(8t=hoo;oti:t2T0,(t2T_t2Tc)^
t62Td^oo2O0^ot2O0)
For example, given a state s=fa;b;c;ha;bigand a delta
=hfcg;fbg;fha;cig;fgi,s=fa;c;ha;cig. Notice how
the creation of object cwas idempotent given that salready
had that object, and that deletion of object bimplied that all
tuples related to bwere deleted as well.
We can observe that 8s;s02DSDS:s0=s(s0	s).
This follows directly from the deÔ¨Ånition, as s0	swill create
all entities (objects and tuples) in s0that are not in sand delete
all the entities that are part of sand nots0.
Lemma 1: Given any two non-conÔ¨Çicting deltas 1and2:
8s2DS: (s1)2=s(1[2)
This lemma follows directly from deÔ¨Ånitions of delta union
and the apply operation. For simplicity we will limit the proof
to objects, but the same proof can be extended to cover tuples.
Given a state s=hO;Ti, non-conÔ¨Çicting deltas 1=
hOc1;Tc1;Od1;Td1iand2=hOc2;Tc2;Od2;Td2i, and post-
statesss=hOs;Tsi= (s1)2andsp=hOp;Tpi=
s(1[2), we proceed to show that any object in ssmust
be insp, and that any object in spmust be inss.
8o2Os: (o2O^o62Od1^o62Od2)_
(o2Oc1^o62Od2)_o2Oc2
)8o2Os: (o2O^o62Od1^o62Od2)_
(o2Oc1_o2Oc2)
Because these deltas are non-conÔ¨Çicting, (o2Oc1_o2
Oc2))(o62Od1^o62Od2). Joining this implication with
the previous formula:
8o2Os: (o2O^o62Od1^o62Od2)_
((o2Oc1_o2Oc2)^o62Od1^o62Od2)
)8o2Os: (o2O_o2Oc1_o2Oc2)^o62Od1^o62Od2
)8o2Os: (o2O_o2Oc1[Oc2)^o62Od1[Od2
)8o2Os:o2Op
s
sisi ‚äñ s
s's' ‚äñ sis
sA ‚äñ s sB ‚äñ s
sA sBs
s'(sA ‚äñ s) U (sB ‚äñ s)UFig. 3. Sequential execution vs. Coexecution
The inverse implication also holds:
8o2Op: (o2O_o2Oc1[Oc2)^o62Od1[Od2
)8o2Op: (o2O^o62Od1^o62Od2)_
(o2Oc1^o62Od2)_o2Oc2
)8o2Op:o2Os
A consequence of this property is that the delta apply
operation is commutative for non-conÔ¨Çicting deltas (as delta
union is trivially commutative).
B. Coexecution
Coexecution of two statements AandB, which we denote
asAjB, means Ô¨Ånding the deltas of independent executions of
both statements starting from the pre-state, Ô¨Ånding the union
of those deltas, and applying the union to the pre-state. This is
visualized in Figure 3, similar to Figure 2 but applied to two
generic states and any two statements AandB. Formally,
8s;s02DSDS: [s;s0]AjB,9sA;sB2DSDS:
[s;sA]A^[s;sB]B^s0=s((sA	s)[(sB	s)) (4)
Notice that coexecution, because of the delta apply operation,
is deÔ¨Åned only if no two possible deltas from the pre-state via
statementsAandBare conÔ¨Çicting.
For example, if statement Aadds a new object to a state,
and statement Bdeletes all tuples from a state, executing these
statements from the state s=fa;b;ha;bigindependently will
yield the following states:
sA=fa;b;c;ha;big; s B=fa;bg
Therefore,
sA	s=hfcg;fg;fg;fgi
sB	s=hfg;fg;fg;fha;bigi
(sA	s)[(sB	s) =hfcg;fg;fg;fha;bigi
and, the coexecution AjBwill result in the following state:
s((sA	s)[(sB	s)) =fa;b;cg
which is the same state to which sequential execution of A
andBwould transition from s, which means that AandB
are coexecutable.
C. Coexecutability Condition
Not all statements are coexecutable since coexecution re-
quires non-conÔ¨Çicting deltas, and even if their deltas are
not conÔ¨Çicting, the result of coexecution may not be equal
to the result of sequential execution. Below we deÔ¨Åne a
coexecutability condition , such that, given any two statements
AandB, ifAandBsatisfy the coexecutability condition,
then their sequential execution is always equivalent to their
coexecution.1) Statement Reads, Creates and Deletes: We model each
statement as a set of (potentially non-deterministic) state tran-
sitions. This deÔ¨Ånition of statements is very general and widely
applicable, but makes it difÔ¨Åcult to identify a statement‚Äôs read
set. We need to have access to a statement‚Äôs read set in order to
reason about interdependencies of statements. In the remainder
of this subsection we deÔ¨Åne how to infer a statement‚Äôs read,
create and delete sets from its transition set.
First, we deÔ¨Åne what it means for a delta set to
cover a given statement Afrom a given set of states S=
fs1;s2:::sng:
cover(;A;S ),(8s2S;s02DS: [s;s0]A)(92 :s0=s))
^(8s2S;2 : [s;s]A)
I.e., a set of deltas covers a statement Afrom a set of states
Sif and only if every state transition achievable from any state
inSviaAis achievable from the same state via some delta
in, and any transition achievable from any s2Svia any
delta in is a transition of A.
A delta cover precisely describes all possible executions of
a statement from a set of states using a single set of deltas.
Intuitively, the existence of a delta cover shows that the given
statement does not need to distinguish between the covered
states in order to decide how to proceed with execution.
Note that this does not mean that is the collection of all
deltas achievable from states in SviaA. We can demonstrate
this by considering a delete-all statement with S=DS, and
containing a single delta that creates no entities and deletes
all entities that exist in any state in DS. In this particular case,
the delta in is different than any delta achievable from any
Ô¨Ånites2SviaA, yet it is true that this coversAfromS.
We can now deÔ¨Åne what it means for a statement Atoread
an entitye:
reads(A;e),9s2DS::9DS: cover(;A;fs[feg;snfegg)
This means that Areadseif and only if there exists a pair of
statess[fegandsnfegthat cannot be covered by any for
the statement A. This implies that A‚Äôs actions are dependent
one‚Äôs existence in some way, for example if it is deciding
whether to delete or not delete some object other than ebased
one‚Äôs existence. I.e., if statement Areads entity e, then in
order to describe the behavior of A, we need to speciÔ¨Åcally
refer toe.
Based on this deÔ¨Ånition, a delete-all statement does not
read any entity ebecause, for any two states s[fegand
snfegfor any state s, there exists a that covers it:
 =fhfg;fg;objects of (s[feg);tuples of (s[feg)ig.
Hence, using this deÔ¨Ånition, we are able to infer that two
delete-all statements that are executed back to back are co-
executable, although in sequential execution, behavior of the
second delete-all statement changes (it becomes a no-op) due
to the presence of the Ô¨Årst delete-all statement.
We can also deÔ¨Åne what it means for a statement Atocreate
ordelete an entity similarly:
creates(A;e),9s;s02DS: [s;s0]A^e62s^e2s0
deletes(A;e),9s;s02DS: [s;s0]A^e2s^e62s0
Recall that, since we are abstracting away the basic types,
any update to the data store state consists of creation and
deletion of entities (i.e., objects and associations).2) Coexecutability Condition DeÔ¨Ånition and Proof: We can
now deÔ¨Åne the coexecutability condition and our main result:
Theorem 1: Given two statements AandB, if the following
condition holds:
8s2DS;8e2s: (reads(A;e)): creates(B;e)^:deletes(B;e))
^(creates(A;e)): reads(B;e)^:deletes(B;e))
^(deletes(A;e)): reads(B;e)^:creates(B;e))
then coexecution of AandBis equivalent to their sequential
execution (i.e.,8s;s02DS: [s;s0]A;B,[s;s0]AjB). In other
words,AandBarecoexecutable .
The proof of the above theorem is tedious due to the
differences between objects and tuples and how they depend
on one another (e.g., deleting an object deletes all associated
tuples, and creating a tuple that is associated with a non-
existing object is impossible etc.). In order to simplify the
proof, without loss of generality, we will outline the proof by
focusing only on the creation and deletion of objects.
First, the condition in Theorem 1 implies that no statement
can delete an object that can be created by the other. Therefore
the deltas from any sviaAandBare not conÔ¨Çicting, and
coexecution is always deÔ¨Åned.
Let us take any two states sands0and assume that there
exists a state sAsuch that [s;sA]A.
Let us consider any object octhat is created by sA	s.
All objects created by sA	sare not read by B. Therefore,
there exists a delta cover that describes all transitions from
s[focgandsnfocgviaB. SincesA	sis creatingocwe
know thatoc62s, so this delta cover describes all transitions
fromsands[focgviaB.
Let us inspect every member of such a delta set . If any
2creates anything in sthen this operation is always
redundant for states sands[focg, so we can remove this
operation and still have a delta cover of Boverfs;s[focgg.
We can similarly remove all deletions of all objects outside s[
focgas redundant operations. Since occannot be deleted by B,
we know that this trimmed delta cover does not delete anything
outsides. From the deÔ¨Ånition of a delta cover it follows that
the resulting trimmed delta cover is, in fact, precisely the set
of all deltas achievable from sviaB.
Similar reasoning can be followed for any object odthat is
deleted bysA	s. It follows that the set of deltas achievable
fromsviaBcoversBoverfs;snfodgg.
Because the set of all deltas achievable from sviaBcovers
fs;s[focgg, directly from the deÔ¨Ånition of delta covers (with
the prior assumption that an sAs.t.[s;sA]Aexists):
8s;s02DSDS:9sA: [s;sA]A)
([s[focg;s0]B,9sB2DS: [s;sB]B^s0=sB[focg)
Let us generalize and say that sA	screates objects ocifor
some 1incand deletes objects odifor some 1ind.
If we were to now enumerate all objects created and deleted
bysA	sone by one and apply the above reasoning to them,
the resulting formula would be:
8s;s02DSDS:9sA2DS: [s;sA]A)
([s[foc1;:::o cncgnfod1;:::o dndg;s0]B,9sB2DS:
[s;sB]B^s0=sB[foc1;:::o cncgnfod1;:::o dndg)Category Node Children
StatementBlock *Statement
Either *Block
If Formula ,Block ,Block
ObjectSetStmt Object Set
Assign Variable ,Object Set
Delete Object Set
CreateTuple Object Set ,Relation ,Object Set
DeleteTuple Object Set ,Relation ,Object Set
ForEach Variable ,Object Set ,Block
Object SetVariable
CreateObjectSet Class
Dereference Object Set ,Relation
AllOfClass Class
Subset Object Set
OneOf Object Set
Union *Object Set
Empty
DereferenceCreate Object Set ,Relation
Fig. 4. Abstract Data Store Statement and Object Set Nodes
Which is equivalent to
8s;s02DSDS:9sA2DS: [s;sA]A)
[s(sA	s);s0]B,9sB2DS: [s;sB]B^s0=sB(sA	s)
BecausesB=s(sB	s), and applying non-conÔ¨Çicting
deltas in sequence is equivalent to applying their union, this
formula is equivalent to
8s;s02DSDS:9sA2DS: [s;sA]A)
([sA;s0]B,9sB2DS: [s;sB]B^s0=s(sB	s)[(sA	s))
We can move the sAquantiÔ¨Åcation and implication ( 9sA2
DS: [s;sA]A):::) to both sides of the inside equivalence:
8s;s02DSDS:
(9sA2DS: [s;sA]A^[sA;s0]B),
(9sA;sB2DSDS: [s;sA]A^[s;sB]B
^s0=s(sB	s)[(sA	s))
which is the formula for equivalence of sequential execution
and coexecution.
V. S YNTACTIC ANALYSIS
In order to keep our veriÔ¨Åcation process fully automatic,
we developed a syntactic check that determines, for a given
ForEach loop, whether we can coexecute the iterations while
maintaining the loop semantics. Our syntactic analysis works
on an intermediate abstract data store (ADS) language [5], and
we automatically extract ADS language speciÔ¨Åcations from
Rails applications using the techniques presented in [5].
The summary of all statements in our ADS lan-
guage is provided in Figure 4. The ADS language
includes constructs for creating and deleting objects
(CreateObjectSet ,DereferenceCreate ,Delete ), updating
associations ( CreateTuple ,DeleteTuple ), variables and as-
signments ( Variable ,Assign ), loops ( ForEach ), conditional
and non-deterministic branches ( If,Either ). Most statements
use expressions in the form of Object Sets . For example, a
Delete statement takes an Object Set expression and will
delete all objects inside this set. We check the coexecutability
condition on ForEach statements.
The syntactic check is two-fold: 1) we analyze if sequen-
tial execution is necessary to uphold variable dependencies,
and 2) if iteration operations may overlap as deÔ¨Åned in the
coexecutability condition (Theorem 1).1program A n a l y s i s
2var d a t a : A n a l y s i s D a t a ;
3
4f u n c t i o n Analyze ( lo op : ForEach ) : Boolean
5 d a t a . c l e a r A l l D a t a ;
6 A n a l y z e S t a t e m e n t ( loo p ) ;
7 f o r type in D a t a S t o r e T y p e s :
8 o p e r a t i o n s = d a t a . operationsDoneOn ( type ) ;
9 i f( o p e r a t i o n s . hasTwoDifferentOpsWithOneGlobal ( ) ) then
10 r e t u r n F a l s e ;
11 end ;
12 end ;
13 r e t u r n True ;
14 end
15
16 procedure A n a l y z e S t a t e m e n t ( s t m t : S t a t e m e n t )
17 c as e type ( s t m t ) of
18 Block :
19 f o r subStmt ins t m t . s u b S t a t e m e n t s do
20 A n a l y z e S t a t e m e n t ( subStmt ) ;
21 end ;
22 D e l e t e :
23<objSetType , o b j S e t L o c a l >= A n a l y z e O b j s e t ( s t m t . o b j S e t )
24 d a t a . markDelete ( objSetType , o b j S e t L o c a l ) ;
25 f o r r e l a t i o n ino b j S e t T y p e . a s s o c i a t i o n s do
26 d a t a . markDelete ( r e l a t i o n , F a l s e ) ;
27 end ;
28 O b j e c t S e t S t m t :
29 A n a l y z e O b j s e t ( s t m t . o b j S e t ) ;
30 Assignment :
31<objSetType , o b j S e t L o c a l >= A n a l y z e O b j s e t ( s t m t . o b j S e t ) ;
32 s t m t . v a r i a b l e . o b j S e t T y p e = o b j S e t T y p e ;
33 s t m t . v a r i a b l e . o b j S e t L o c a l = o b j S e t L o c a l ;
34 ForEach :
35<objSetType , o b j S e t L o c a l >= A n a l y z e O b j s e t ( s t m t . o b j S e t ) ;
36 d a t a . markRead ( objSetType , o b j S e t L o c a l ) ;
37 s t m t . i t e r a t o r V a r i a b l e . o b j S e t T y p e = o b j S e t T y p e ;
38 s t m t . i t e r a t o r V a r i a b l e . o b j S e t L o c a l = o b j S e t L o c a l ;
39 A n a l y z e S t a t e m e n t ( s t m t . block , d a t a ) ;
40 . . .
41 end ;
42 end
43
44 f u n c t i o n A n a l y z e O b j s e t ( o b j S e t : O b j e c t S e t ) : <Type ,Boolean>
45 c as e type ( o b j S e t ) of
46 C r e a t e O b j s e t S e t :
47 d a t a . markCreate ( o b j S e t . c r e a t e d T y p e , True ) ;
48 r e t u r n <o b j S e t . c r e a t e d T y p e , True>;
49 V a r i a b l e :
50 r e t u r n <o b j S e t . objSetType , o b j S e t . o b j S e t L o c a l >;
51 D e r e f e r e n c e :
52<o r i g i n T y p e , o r i g i n L o c a l >=
53 A n a l y z e O b j s e t ( o b j S e t . o r i g i n O b j S e t ) ;
54 d a t a . markRead ( o r i g i n T y p e , o r i g i n L o c a l ) ;
55 d a t a . markRead ( o b j S e t . r e l a t i o n , F a l s e ) ;
56 r e t u r n <o b j S e t . t a r g e t T y p e , False>;
57 . . .
58 end
59 end
Fig. 5. Syntactic Analysis Pseudocode
First, to check if coexecution would invalidate variable
dependences, we convert the whole action to static single
assignment (SSA) form. If, after converting to SSA and
removing unnecessary assignments, there exists a Phi function
assignment at the beginning of the loop‚Äôs iteration body (i.e. an
iteration reads a variable assigned to by a previous iteration)
or at the end of the loop (i.e. the iteration assigns to a variable
that is read after the loop terminates), then iterations must be
modeled sequentially to preserve variable state.
If the variable dependency check passes, we proceed to
check whether the loop is coexecutable. To achieve this, we
identify every data store class or relation that is touched by a
read, create or delete operation inside the iteration body.
For example, if a delete statement deletes a set of objects
of classc, we mark that cas well as all c‚Äôs subclasses havehad a delete operation executed. In addition, since all tuples
of deleted objects are deleted as well, we mark all relations
of these classes and their supertypes as having had a delete
operation executed.
We increase the precision of our analysis by identifying
whether operations are executed on iteration-local objects. For
example, if an iteration were to create an object of class c
and subsequently delete it, then the coexecutability condition
would not be violated (since no object created by one iteration
would be deleted by another) but the above syntactic check
would fail as cwould have had both a create and a delete
operation executed.
In order to facilitate this we denote whether each read,
create or delete operation is done iteration-locally or not.
For example, CreateObjectSet creates an object iteration-
locally as every iteration will create a different object and these
created sets will not overlap. Operations such as dereferencing
from an object set return a global domain object set even if a
local domain was dereferenced, because even if each iteration
dereferences from a different object domain, the target object
sets may overlap.
Therefore, in order for the syntactic check to pass, there
must not exist a domain of objects or tuples that has two of the
operations (read, create, delete) executed, where at least one of
this operations is not done iteration-locally. The pseudocode
for the operation domain analysis is provided in Figure 5.
The AnalysisData global variable called data (line 2)
aggregates information about which domains of objects and
tuples are operated on and in what way. It is essentially a
key-value structure that maps every class and relation in the
data store into a set of operation entries , which are pairsho;li
whereo2 fcreate;read;delete gandl2 fTrue;Falseg.
This structure lists, for each data store class and relation, all
the different create ,read and write operations executed on
entities of that particular class or relation and if these oper-
ations were executed iteration-locally ( True ) or not ( False ).
This structure is populated by invoking methods markRead ,
markCreate and markDelete on it, all of which take two
arguments: a data store class or relation type, and a boolean
denoting whether the operation is iteration-local (e.g. line 24).
The Analyze function is the entry point of our algorithm
(lines 4-14). It Ô¨Årst clears all information from the data object
(line 5), then proceeds to gather information in the data object
by invoking the AnalyzeStatement on the given loop (line
6). It then iterates over all classes and relations (lines 7-
12) and tests whether there exist two operation entries on
the same class or relation such that they contain different
fcreate;read;delete gtypes where at least one of them is
executed on a global domain. If such a pair of operation entries
is found, the coexecutability check fails and the function
returns False (line 10). Otherwise, it returns True (line 13).
The AnalyzeStatement procedure takes a statement as an
argument and its purpose is to populate the data object with
information about which operations are executed on which
domain by that statement. For example, a Delete statement
(lines 22-27) invokes the AnalyzeObjset method to acquiredomain information about the object set to be deleted (line
23), then marks this domain as deleted (line 24). Since the
delete statement also deletes all tuples of the deleted objects,
all relations around the object set‚Äôs type are iterated over (lines
25-27) and are marked deleted globally (line 26). The tuples
are always deleted on a global domain because, even if the
deletion is on a local domain, these tuples may relate to some
other iteration‚Äôs local domain.
The Assignment statement (lines 30-33) does not add any
entry to the data object , and instead stores the domain of
the assigned object set in the variable. These values will later
be extracted when the variable is referred to in lines 49-50.
The AnalyzeObjset function (lines 44-59) is invoked with
an object set argument and it returns the domain of the objects
inside the object set in form of a hType;Booleanipair. In
addition, object sets may populate the data object themselves.
For example, the CreateObjectSet object set (lines 46-49)
creates a new object and returns a singleton set containing it.
For each such object set, we mark that object‚Äôs class with the
create operation (line 47) in an iteration-local domain because
this object set will contain a different object for each iteration.
The Dereference object set (lines 51-56) takes another
object set, referred to as the origin object set, and a relation
type. It contains all the objects that can be reached from the
origin object set via at least one tuple of the given relation
type. As such, the origin object set is read in the domain
supplied by it (lines 52-54), and the relation type is read on
the global domain (line 54). Finally, the returned domain of
this very Dereference object set is equal to the target type of
the relation and is always global (line 56).
VI. E XPERIMENTS
We implemented the analysis and veriÔ¨Åcation techniques
presented in this paper in our data model veriÔ¨Åcation tool
which is available at http://bocete.github.io/adsl/.
In order to evaluate the effect of coexecution on the veriÔ¨Å-
cation process, we implemented two ways to model ForEach
loops (as sequentially executed iterations, and as coexecuted
iterations). We looked at the top 20 most popular (most
starred) Rails applications hosted on Github [16] for real-world
examples of loops. Four of them do not use ActiveRecord or
a relational database. Two of them are not web applications
per se, but rather web application templates, and one has an
unorthodox architecture that was not compatible with the data
model extraction component of our tool. Out of the remaining
13, 6 of them had no loops in their actions. We found a total
of 38 loops in actions of the remaining 7 applications: 5 in
Discourse [7], 9 in FatFreeCRM [9], 5 in Tracks [30], 4 in
Lobsters [25], 5 in SprintApp [29], 8 in Redmine [27], and 1
in Kandan [21]. Our analysis determined that all these loops
were coexecutable.
Interestingly, 12 of the 38 loops we extracted had empty
loop bodies. This is due to the fact that the abstract data
store model we extract abstracts away the Ô¨Åelds with basic
types. Hence, the loops that do not modify the state of the
data store as far as the set of objects and associations areconcerned (but might change the value of basic type Ô¨Åelds
of some objects) result in empty loop bodies. Note that,
since the invariants we verify are on sets of objects and their
associations, the automated abstraction performed by our tool
during abstract data store extraction, in effect, is demonstrating
that these loops preserve all invariants. However, during our
experiments, we found out that the FOL theorem prover would
occasionally timeout even for loops with an empty body
when the sequential semantics is used. This demonstrates the
inherent complexity of reasoning about the sequential loop
model, even without the complexity of reasoning about the
statements in the loop body.
The remaining loops we extracted contain various program
structures such as branches, object and association creation
and deletion as well as loop nesting.
We manually wrote application speciÔ¨Åc invariants for each
application to be used in our experiments. Given an action
and an invariant, our veriÔ¨Åcation tool generates a set of FOL
formulas that correspond to axioms, and a formula that cor-
responds to a conjecture. If the axioms imply the conjecture,
then this proves that the action preserves the invariant.
We used the Spass [32] tool as the FOL theorem prover in
our experiments. Spass takes the set of FOL axioms and the
conjecture generated by our tool and attempts to prove that the
axioms imply the conjecture. More precisely, Spass conjoins
the negation of the conjecture with the axioms and starts
deducing formulae from this set of axioms. If a contradiction
is ever reached, the conjecture is deemed to hold. If the entire
space of deducible formulae is exhausted, the conjecture is
deemed to not imply from the axioms. Finally, since FOL is
undecidable and the space of deducible formulae may be inÔ¨Å-
nite, deduction may never terminate. We stop veriÔ¨Åcation after
5 minutes, at which point we deem the result as inconclusive.
Spass guides the formula space exploration using heuristics
that can be Ô¨Åne tuned by the user. We used two heuristics:
one with the Sorts option on, and the other with that option
off. The Sorts option allows Spass to make decisions based
on soft sorts [31]. By turning the Sorts option on and off
and looking at the deduction logs of Spass we noticed that
the order of deduction Spass takes changes signiÔ¨Åcantly, and
furthermore, in our previous work [5] we found that, often,
one of these heuristics terminates when the other one does not.
Therefore, running Spass with the Sorts option on and off gives
us very different heuristics for comparison of coexecution and
sequential execution.
Normally, when we encode an action/invariant pair in FOL,
the loop semantics are encoded in the axioms section with an
invariant being the conjecture. In order to isolate the effect of
the axioms on the overall deduction process, we also veriÔ¨Åed
all actions using the conjecture false . This conjecture often
gives us the worst case performance for a set of axioms.
Because Spass attempts to deduce a contradiction from the
axioms and negated conjecture, it negates the conjecture to
true and hence needs to explore the entire space of deducible
formulae to reach a contradiction that does not exist. If Spass
terminates with the false conjecture then we can reasonablyApplication KLOC# of Model # of # Avg Loop
Classes Loops Body Size
Discourse 308.77 116 5 1.4
FatFreeCRM 38.79 34 9 1.0
Tracks 28.72 39 5 2.0
Lobsters 7.99 17 4 3.0
SprintApp 7.89 19 5 3.2
Redmine 153.43 67 9 1.1
Kandan 6.10 11 1 0
(a) Application Statistics
Loop Model Heuristic # of Timeouts / Total Avg Time (seconds)
SequentialSorts on 66/94 (70.2%) 216.4
Sorts off 56/94 (60.2%) 186.0
CoexecutionSorts on 27/94 (29.3%) 94.0
Sorts off 18/94 (19.8%) 68.5
(b) VeriÔ¨Åcation statistics
(c) Number of action/invariants per performance gain factor
Fig. 6. Application and VeriÔ¨Åcation Statistics
expect that it will terminate with other invariants as long as
they do not add signiÔ¨Åcant complexity to the veriÔ¨Åed theorem.
We also included 4 actions that we manually created to
explore how the theorem prover handles coexecution vs se-
quential execution of nested loops and branches in iterations.
In total, we had 94 action/conjecture pairs. We translated
each one of those to two FOL theorems, one using coexecution
and the other using sequential execution to model loops. We
sent each one of these theorems to two instances of Spass with
different heuristic settings, resulting in 376 veriÔ¨Åcation tasks.
All veriÔ¨Åcation experiments were executed on a computer with
an Intel Core i5-2400S processor and 32GB RAM, running
64bit Linux. Memory consumption never exceeded 200Mb.
We speciÔ¨Åcally looked at how coexecution fared as opposed
to sequential execution. With the sequential execution model,
out of 188 veriÔ¨Åcation tasks 122 of them timed out (64.89%).
With the coexecution model, only 45 tasks out of 188 timed
out (24.19%). The summary of our results can be seen on Fig-
ure 6. Figure 6(a) summarizes information on the applications
we used for evaluation. Figure 6(b) summarizes the number of
timeouts and average veriÔ¨Åcation time over loop interpretation
(sequential vs coexecution) and heuristic.
Figure 6(c) summarizes the performance effects of coexecu-
tion as opposed to sequential execution. We had 188 cases in
which to compare coexecution and sequential execution under
identical action/invariants and theorem prover heuristics. In
86 cases (45%, columns labeled 10x and up), coexecution
improved veriÔ¨Åcation times by at least an order of magni-
tude. Among them, in 24 cases (13%) the theorem prover
reached a conclusive answer instantly using coexecution and
could not deduce a conclusive answer at all with sequential
execution (column labeled 10000x ). Coexecution yielded noimprovement in a total of 99 tasks (52%, column 1x). In
these cases either both loop models resulted in a timeout
or both methods produced results instantly. In three cases,
coexecution produced worse results than the sequential model.
This is not surprising since, as we mentioned above, the proof
search implementation of the theorem prover relies on several
heuristics which inÔ¨Çuence its performance.
In total, we found that coexecution reduced the timeout rate
from 65% to 24% (almost threefold), made veriÔ¨Åcation at least
an order of magnitude faster 45% of the time, with 13% of
cases terminating quickly as opposed to not terminating at all.
We conclude that, overall, coexecution allows for signiÔ¨Åcantly
faster veriÔ¨Åcation and signiÔ¨Åcantly decreases the chance of
veriÔ¨Åcation never terminating.
VII. R ELATED WORK
The contributions of this paper are motivated by our previ-
ous work on data model veriÔ¨Åcation [5]. In our previous work
we presented an imperative language for web application data
modeling called abstract data store language (ADS), a method
for automated extraction of this language from a given Rails
web application, as well as the process of translating ADS
veriÔ¨Åcation tasks to FOL. In contrast to our earlier work, this
paper focuses on effective veriÔ¨Åcation of actions that contain
loops, which is one of the key difÔ¨Åculties in the FOL-based
veriÔ¨Åcation of data models. Using coexecution to model loops
is applicable to program veriÔ¨Åcation in general, beyond the
scope of our previous work.
VeriÔ¨Åcation of software using theorem provers has been
explored before in projects such as Boogie [3], Dafny [24]
and ESC Java [12]. These projects focus on languages such
as C, C#, and Java, and typically require user guidance in
the form of explicit pre- and post-conditions, explicit data
structure constraints, and loop invariants. While loop invariants
may be inferred for certain loops, they are ultimately required
to reason about the loops. Our method does not require loop
invariants, and uses static analysis to automatically optimize
the loop translation to FOL. While low level languages such
as C and Java present different challenges then our high level
language, we believe that modeling loops via coexecution is
applicable and would be beneÔ¨Åcial for the veriÔ¨Åcation of loops
in low level languages as well.
The lack of support for precise reasoning about program-
ming language constructs in theorem provers has been no-
ticed and addressed before [6]. SpeciÔ¨Åcally, [6] discusses this
problem with regard to ANSI-C basic types and operations,
bit-vectors and structures, pointers and pointer arithmetic.
They address this problem by devising a theorem prover that
supports all these elementary operations. These improvements
do not improve on the basic problems with loop veriÔ¨Åcation,
and the tools that use Simplify still require loop invariants [12].
Alloy [19], [20] is a formal language for specifying object
oriented data models and their properties. Alloy Analyzer
is used to verify properties of Alloy speciÔ¨Åcations. Alloy
Analyzer uses SAT-based bounded veriÔ¨Åcation techniques as
opposed to the FOL based unbounded veriÔ¨Åcation techniquewe use. DynAlloy is an extension of Alloy that supports
dynamic behavior [13], [14] by translating dynamic speciÔ¨Åca-
tions onto Alloy. While they talk about actions in their work,
those actions do not correspond to actions in web applications.
Instead, they are more similar to statements in programming
languages [15]. Their work has focused on veriÔ¨Åcation of data
structures, not behaviors in data models of web applications.
An interesting parallel can be drawn between coexecution
of loop iterations and snapshot isolation in the domain of
databases [4], [10]. The coexecutability problem is similar
to the problem of equivalence of serializability and snapshot
isolation. However, we see no parallel between our delta
union and the delta apply operations and snapshot isolation
notions such as Ô¨Årst-committer-wins , transactions aborting or
committing based on conÔ¨Çicts etc. Our purpose is veriÔ¨Åcation
viability, not scalability or optimization of transactions.
There exists a long body of work focusing on operation
commutativity with applications such as automatically paral-
lelizing data structures [22] and computation [18], [28]. Auto-
matic loop parallelization has been researched for decades [1],
[2], [17]. This prior research acknowledges loop dependencies
as problematic for parallelization, and the potential for per-
formance increase if no such dependencies exist. While we
are also avoiding loop dependencies, our purpose is not opti-
mization or making execution scalable, but making veriÔ¨Åcation
more feasible in practice. Coexecution is a theoretical concept
that is not executable in actual hardware. Furthermore, there
exist parallelizable loops that are not coexecutable.
Semantic properties of operations have been used for the
purposes of simplifying veriÔ¨Åcation [8]. This is similar to
our approach at a high level. However, we do static analysis
of a particular condition that allows us to use a completely
alternate deÔ¨Ånition of a loop, whereas [8] iteratively abstracts
and subsequently reduces the model in order to infer and
enhance atomicity rules without altering the validity of the
given invariants. Their problem, domain of application, goal
and solution are fundamentally different.
VIII. C ONCLUSION AND FUTURE WORK
In this paper we deÔ¨Åned coexecution, a technique for
modeling loop iterations that bypasses the need to model inter-
iteration dependence, and the coexecutability condition which
tests whether, when given a loop, coexecution of its iterations
is equivalent to its sequential execution. We developed a static
program analysis technique that tests the coexecutability con-
dition on a given loop. Finally, we demonstrated that modeling
loops using coexecution signiÔ¨Åcantly improves veriÔ¨Åcation
viability and performance.
We believe that coexecutability can be useful in other
contexts and we plan to investigate its application to other
veriÔ¨Åcation problems. We also plan to continue and extend our
work on automated veriÔ¨Åcation of data stores. For example,
basic data types are completely abstracted away in our data
model speciÔ¨Åcations. Support for basic data types coupled with
an automated abstraction mechanism could enable us to check
a richer set of properties on data models in the future.REFERENCES
[1] A. Aiken and A. Nicolau. Optimal loop parallelization. In Proceedings
of the ACM SIGPLAN 1988 Conference on Programming Language
Design and Implementation (SIGPLAN 1988) , PLDI ‚Äô88, pages 308‚Äì
317, New York, NY , USA, 1988. ACM.
[2] U. Banerjee, R. Eigenmann, A. Nicolau, and D. A. Padua. Automatic
program parallelization. Proceedings of the IEEE (1993) , 81(2):211‚Äì
243, 1993.
[3] M. Barnett, B.-Y . E. Chang, R. DeLine, B. Jacobs, and K. R. M. Leino.
Boogie: A modular reusable veriÔ¨Åer for object-oriented programs. In
F. S. de Boer, M. M. Bonsangue, S. Graf, and W. P. de Roever, editors,
Proceedings of the 4th International Symposium on Formal Methods for
Components and Objects (FMCO 2005) , volume 4111 of Lecture Notes
in Computer Science , pages 364‚Äì387. Springer, 2005.
[4] H. Berenson, P. A. Bernstein, J. Gray, J. Melton, E. J. O‚ÄôNeil, and P. E.
O‚ÄôNeil. A critique of ansi sql isolation levels. In Proceedings of the
1995 ACM International Conference on Management of Data (SIGMOD
1995) , pages 1‚Äì10, 1995.
[5] I. Bocic and T. Bultan. Inductive veriÔ¨Åcation of data model invariants for
web applications. In Proceedings of the 36th International Conference
on Software Engineering (ICSE 2014) , May 2014.
[6] B. Cook, D. Kroening, and N. Sharygina. Cogent: Accurate theorem
proving for program veriÔ¨Åcation. In Proceedings of the 17th Interna-
tional Conference on Computer Aided VeriÔ¨Åcation, (CAV 2005) , pages
296‚Äì300, 2005.
[7] Discourse, Mar. 2014. www.discourse.org.
[8] T. Elmas, S. Qadeer, and S. Tasiran. A calculus of atomic actions.
InProceedings of the 36th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (POPL 2009) , pages 2‚Äì15, 2009.
[9] Fat Free CRM - Ruby on Rails-based open source CRM platform, Sept.
2013. http://www.fatfreecrm.com.
[10] A. Fekete, D. Liarokapis, E. J. O‚ÄôNeil, P. E. O‚ÄôNeil, and D. Shasha.
Making snapshot isolation serializable. ACM Trans. Database Syst. ,
30(2):492‚Äì528, 2005.
[11] R. T. Fielding. Architectural Styles and the Design of Network-based
Software Architectures . PhD thesis, University of California, Irvine,
2000.
[12] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe,
and R. Stata. Extended static checking for java. In Proceedings of the
2002 ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI) , pages 234‚Äì245, 2002.
[13] M. F. Frias, J. P. Galeotti, C. L. Pombo, and N. Aguirre. Dynalloy:
upgrading alloy with actions. In 27th International Conference on Soft-
ware Engineering (ICSE 2005), 15-21 May 2005, St. Louis, Missouri,
USA, pages 442‚Äì451, 2005.
[14] M. F. Frias, C. L. Pombo, J. P. Galeotti, and N. Aguirre. EfÔ¨Åcient
analysis of dynalloy speciÔ¨Åcations. ACM Transactions on Software
Enginnering Methodology , 17(1), 2007.[15] J. P. Galeotti and M. F. Frias. Dynalloy as a formal method for the
analysis of java programs. In Software Engineering Techniques: Design
for Quality, SET 2006, October 17-20, 2006, Warsaw, Poland , pages
249‚Äì260, 2006.
[16] GitHub, Sept. 2014. http://github.com.
[17] M. H. Hall, S. P. Amarasinghe, B. R. Murphy, S.-W. Liao, and M. S.
Lam. Detecting coarse-grain parallelism using an interprocedural par-
allelizing compiler. In Proceedings of the 1995 ACM/IEEE Conference
on Supercomputing , Supercomputing ‚Äô95, New York, NY , USA, 1995.
ACM.
[18] O. H. Ibarra, P. C. Diniz, and M. C. Rinard. On the complexity
of commutativity analysis. International Journal of Foundation of
Computer Science , 8(1):81‚Äì94, 1997.
[19] D. Jackson. Alloy: A lightweight object modelling notation. ACM
Transactions on Software Enginnering and Methodology (TOSEM 2002) ,
11(2):256‚Äì290, 2002.
[20] D. Jackson. Software Abstractions: Logic, Language, and Analysis . The
MIT Press, Cambridge, Massachusetts, 2006.
[21] kandanapp/kandan, Sept. 2013. http://github.com/kandanapp/kandan.
[22] D. Kim and M. C. Rinard. VeriÔ¨Åcation of semantic commutativity condi-
tions and inverse operations on linked data structures. In Proceedings of
the 32nd ACM SIGPLAN Conference on Programming Language Design
and Implementation (PLDI 2011) , pages 528‚Äì541, 2011.
[23] G. E. Krasner and S. T. Pope. A cookbook for using the model-view
controller user interface paradigm in Smalltalk-80. Journal of Object
Oriented Programming (JOOP 1988) , 1(3):26‚Äì49, Aug. 1988.
[24] K. R. M. Leino. Dafny: An automatic program veriÔ¨Åer for functional
correctness. In Proceedings of the 16th International Conference on
Logic Programming, ArtiÔ¨Åcial Intelligence, and Reasoning (LPAR) ,
pages 348‚Äì370, 2010.
[25] Lobsters, Mar. 2014. https://lobste.rs.
[26] Ruby on Rails, Feb. 2013. http://rubyonrails.org.
[27] Overview - Redmine, Sept. 2014. www.redmine.org.
[28] M. C. Rinard and P. C. Diniz. Commutativity analysis: A new
analysis technique for parallelizing compilers. ACM Transactions on
Programming Languages and Systems (TOPLAS 1997) , 19(6):942‚Äì991,
1997.
[29] macfanatic/SprintApp, Sept. 2014. https://github.com/macfanatic/
SprintApp.
[30] Tracks, Sept. 2013. http://getontracks.org.
[31] C. Weidenbach. Spass input syntax version 1.5. http://www.spass-
prover.org/download/binaries/spass-input-syntax15.pdf.
[32] C. Weidenbach, D. Dimova, A. Fietzke, R. Kumar, M. Suda, and
P. Wischnewski. SPASS version 3.5. In Proceedings of the 22nd Int.
Conf. Automated Deduction (CADE 2009), LNCS 5663 , pages 140‚Äì145,
2009.