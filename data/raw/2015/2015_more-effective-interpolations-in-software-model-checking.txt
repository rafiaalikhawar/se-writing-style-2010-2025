More Effective Interpolations
in Software Model Checking
Cong Tian, Zhao Duan, Zhenhua Duan, and C.-H. Luke Ongy
ICTT and ISN Lab, Xidian University, Xi‚Äôan 710071, P.R. China
ctian@mail.xidian.edu.cn, duanzhao@stu.xidian.edu.cn, zhhduan@mail.xidian.edu.cn
yDepartment of Computer Science, University of Oxford, UK
Luke.Ong@cs.ox.ac.uk
Abstract ‚ÄîAn approach to CEGAR-based model checking
which has proved to be successful on large models employs Craig
interpolation to efÔ¨Åciently construct parsimonious abstractions.
Following this design, we introduce new applications, universal
safety interpolant andexistential error interpolant, of Craig inter-
polation that can systematically reduce the program state space to
be explored for safety veriÔ¨Åcation. Whenever the universal safety
interpolant is implied by the current path, all paths emanating
from that location are guaranteed to be safe. Dually whenever
the existential error interpolant is implied by the current path,
there is guaranteed to be an unsafe path from the location. We
show how these interpolants are computed and applied in safety
veriÔ¨Åcation. We have implemented our approach in a tool named
INTERP CHECKER by building on an open source software model
checker. Experiments on a large number of benchmark programs
show that both the interpolations and the auxiliary optimization
strategies are effective in improving scalability of software model
checking.
I. I NTRODUCTION
Software model checking [1], [2] is an approach to program
veriÔ¨Åcation that promises accurate analysis with push-button
automation. Model checking approaches can achieve precision
because they are path-sensitive. On the Ô¨Çip side, because they
often track too many facts, state explosion gets in the way of
scalability.
An extensively studied method, called Counterexample
Guided Abstraction ReÔ¨Ånement (CEGAR) [4], [5], [6], [7],
[8], can automatically tune the precision of the analysis using
false positives. In a CEGAR analysis, predicate abstraction
[9] is used to extract a coarse abstract model from a program.
The model is iteratively reÔ¨Åned by adding facts to make the
abstraction precise enough to refute spurious counterexamples.
These ‚Äúfacts‚Äù are predicates that relate values of program
variables.
The scalability of CEGAR-based analyses depends crucially
on the ability to efÔ¨Åciently analyze a false positive so as to
learn from it a small set of sufÔ¨Åciently accurate predicates,
and to use the discovered predicates parsimoniously. To this
end, Craig interpolation [10] has been employed effectively
to construct abstractions that are locally useful, and only
those that are required for proving correctness [25], [5]. By
integrating various techniques, notably lazy abstraction [28]
and parsimonious abstraction via Craig interpolation [25],
Zhenhua Duan is the corresponding author.great strides have been made in the development of efÔ¨Åcient
model checking that scales to large programs. Software model
checkers such as BLAST [5] and CPAChecker [13], [12] have
achieved impressive success in recent software veriÔ¨Åcation
competitions [26], [27], [29], [30], [31]. However (see Sec-
tion V for details), the development of precise andscalable
model checking tools that are Ô¨Åt for real-world applications
remains a daunting challenge.
Our approach to scalable CEGAR-based model checking
[13] is to exploit Craig interpolation to learn abstractions that
can systematically reduce the program state space which must
be explored for a given safety veriÔ¨Åcation problem. In addition
to the interpolants for parsimonious abstraction [25] (which is
called reachability interpolants in this paper for clarity), we
introduce two new kinds of interpolants, called universal safety
interpolants and existential error interpolants. A universal
safety interpolant (orsafety interpolant for short) is useful
for determining whether all the paths emanating from a state
are safe, without exploring all the possible branches from it;
while an existential error interpolant (orerror interpolant
for short) is useful for determining whether there exists an
unsafe path emanating from a state, without exploring all the
possible branches from it. The safety interpolant at a location
of a control Ô¨Çow graph (CFG) collects predicates that are
relevant to a yes-instance of the safety veriÔ¨Åcation, so that
whenever the safety interpolant is implied by the current path,
all paths emanating from this location are guaranteed to be
safe. Dually, whenever the error interpolant at a location of a
CFG is implied by the current path, there is guaranteed to be an
unsafe branch from it, and so, one can immediately conclude
that the program is unsafe. We show how safety interpolants
and error interpolants are learnt from spurious error traces
throughout the CEGAR-based program veriÔ¨Åcation process.
To maximise the effect of the proposed interpolations, we also
present two kinds of optimizing strategies.
We have implemented the approach in a tool named I NTER -
PCHECKER by augmenting the open source tool CPAChecker
[12], [13] with the proposed interpolations and the optimizing
strategies. To evaluate it, a large number of experiments on
more than 58 million lines of C programs (mostly linux driver
programs between 10 to 80 KLOC) have been carried out.
Empirical results show that the proposed interpolations are
effective in reducing the explored state space so that more
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research183
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. programs can be successfully veriÔ¨Åed within the given time
bound. In particular, the experiments indicate that the tool is
most effective when all three kinds of interpolations and the
optimization strategies are applied together.
The rest of the paper is structured as follows. Section II
presents the preliminaries and a motivating example. In Sec-
tion III, we introduce error interpolants and safety interpolants,
and discuss their formalization and use in detail. Two optimiz-
ing strategies are then presented in Section IV. In Section V,
we present an empirical evaluation of our approach. Finally,
Section VI discusses related work and Section VII concludes
the paper.
II. P RELIMINARIES
This section brieÔ¨Çy presents control Ô¨Çow graphs, abstract
reachability trees, Craig interpolation, and an interpolation-
aided CEGAR approach to program veriÔ¨Åcation with a moti-
vating example.
A. Control Flow Graphs
Acontrol Ô¨Çow graph (CFG) is a directed graph that captures
the control Ô¨Çow of a program. Formally, a CFG is a tuple
G= (L;T;l 0;f), whereLis the set of program locations,
l02Lis the initial location, f2Lis the Ô¨Ånal location,
TLOpsLis the transition relation, and Ops is the
set of instructions. An instruction op2Ops is (i) a basic
assignment statement, (ii) an assume predicate corresponding
to the condition that must hold for the control to Ô¨Çow across
an edge, (iii) a function call with call-by-value parameters,
or (iv) a return statement. A transition t2Tis a triplet=
(l;op;l0)denoting the Ô¨Çow of control from ltol0by executing
the instruction op. An example CFG is depicted on the LHS
of Fig. 1.
To clearly express our approach, we further decorate a CFG
with three location attributes, E,S, andRrespectively, and
onetransition attribute W. Intuitively, l(E),l(S), andl(R),
respectively, denote the E-Interp,S-Interp, and R-Interp (to
be deÔ¨Åned later) at a location l; andt(W)gives the weight
of the transition t. How these attributes are initialized and
updated throughout the veriÔ¨Åcation process will be discussed
later.
B. Abstract Reachability Trees
Anabstract reachability tree (ART) is generated by un-
winding a CFG. An ART A= (SA;EA)obtained from a
CFGG= (L;T;l 0;f), consists of a set SAof abstract states
and a setEAof edges. An abstract state s2SAis a triple
s= (l;c;p) wherelis a location in the CFG, cis the current
call stack (i.e. a sequence of CFG locations representing
return addresses), and pis an abstract predicate indicating
the reachable region of the current state. (As we shall see,
the reachable region, i.e. s[2], of a state sis determined by
the reachable interpolant, R-Interp, of the location s[0]in the
CFG.) Given two states sands0, we saysiscovered bys0just
ifs[0] =s0[0],s[1] =s0[1], ands[2]!s0[2]. (Notation: for
a tuplee, we write e[i]for thei-th component of e.) Further,ifsis covered by s0and all the future of s0(i.e. all abstract
states reachable from s0) has been explored, then the future
ofscan be saved from exploring (because the result will be
the same as the future of s0). An edge e2EAis a triple
e= (s;op;s0)wheresands0are abstract states in SA, and
opis an instruction in Ops, including assignment expression,
assume expression, function call and return expression.
A branch (path) of an ART, denoting a possible execution
of the program, is a Ô¨Ånite alternating sequence of states and
edges,  =hs0;e0;;en 1;sni, such that for all 0i<n ,
ei[0] =siandei[2] =si+1. The length of a path is the number
of edges occurring in it. Given a path of an ART, we write
Pf() for the path formula
SSA(e0[1])^^ SSA(en 1[1])
obtained from . Here SSA(op)is the static single assignment
(SSA) form [5] of an operation opwhere every variable
occurring in is assigned a value at most once. In this paper,
the SSA form is obtained by introducing a new subscript to a
variable whenever it is newly assigned. Fig. 2 gives an example
of an ART.
C. Craig Interpolation
Given two formulas AandBsuch thatA^Bis unsat-
isÔ¨Åable, a Craig interpolant Cis a formula that satisÔ¨Åes the
following conditions: 1) AimpliesC; 2) the conjunction C^B
is unsatisÔ¨Åable; and 3) all variables in Care common to A
andB. For convenience, we use
C=Craig (A;B )
to denote the Craig interpolant of formulas AandB. In
software model checking, Craig interpolation has been used
successfully with abstraction reÔ¨Ånement so that more precise
abstractions can be constructed from spurious counterexamples
in order to eliminate them. For clarity, the resulting inter-
polants are called reachability interpolants, or R-Interp for
short, in this paper.
DeÔ¨Ånition 1 (Reachability Interpolant, R-Interp): Let =
hs0;e0;;en 1;snibe a spurious path of an ART. For
0< i < n, set R-Interp (si[0]) := R-Interp (si[0])[
Craig 
Pf(s0;;si);Pf(si;;sn)
. Note that for every
locationlof a CFG, initially, R-Interp (l) =ftrueg.
D. Interpolation-Aided CEGAR VeriÔ¨Åcation Approach
We present a version of CEGAR safety veriÔ¨Åcation that
uses R-Interp. The procedure starts with the most abstract
model (no predicates are considered) and checks whether a
counterexample (i.e. error path) can be detected. If no error
path is found, the procedure terminates, reporting the non-
existence of counterexamples. Otherwise, if a counterexample
path is found, we check satisÔ¨Åability of the relevant path
formula, i.e. Pf(), to determine if is genuine. In case
Pf() is satisÔ¨Åable, the procedure terminates by reporting 
as a counterexample. If Pf()is unsatisÔ¨Åable, new predicates
are discovered [25] at each location involved in according
to DeÔ¨Ånition 1. Observe that at each location of the path , we
184
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. infer the relevant predicates as an interpolant between the two
formulas that deÔ¨Åne the past and the future segments of the
path. Each interpolant, R-Interp (l), is a relationship between
current values of program variables, and is relevant only at the
particular location l.
In the following, we use an example program Exa.c shown
in the LHS of Fig. 1 to illustrate how R-Interp-aided CEGAR
works and motivate our work at the same time. In program
Exa.c, if the code in Line 16 is executed, the program is
unsafe; otherwise, it is safe. The RHS of Fig. 1 gives the
CFG of the program where L11is the error location. Thus the
problem of whether the program is unsafe is reduced to the
reachability analysis of L11in the CFG.
Fig. 1. Program Exa.c and its CFG
In the R-Interp-aided CEGAR approach, by depth-Ô¨Årst
traversal of the CFG, the branch P1in the ART of Fig. 2
is explored in the Ô¨Årst run. In Fig. 2, we annotate each
abstract state s(i.e. node) of the ART with the R-Interp,
R:R, and reachability predicate, p: , at that abstract state;
i.e.R-Interp (s[0]) =fj2Rg ands[2] = . Note that
for clarity, if the R-Interp at a location is updated, we ignore
the element true in Fig. 2. Note that for every state sinP1,
we haveR-Interp (s[0]) =ftruegands[2] = true. Then, the
veriÔ¨Åcation process proceeds straightforwardly to the second
run whereP2is explored since L11is not reached in P1.
Even though the error location is reached in P2, we need to
determine if the path is genuine or spurious.
To do so, we check satisÔ¨Åability of the path formula
Pf(P2) = \(s 1= 1)^!(a1== 1)^!(i1>1)^(s2=s1+2)^(s2>3)":
ObviouslyPf(P2)is unsatisÔ¨Åable since s2= 3 ands2>3
are contradictory. Thus P2is a spurious counterexample. As a
result, theR-Interp at each location of the CFG involved in P2
is updated, and s[2]at each state of P2is updated, accordingly,
as illustrated in Fig. 2. Note that p=false atL10ofP2
indicates that L10cannot be reached. Subsequently, in the third
run,P3is explored. When L8is analyzed, it is found that L8
inP3is covered by L8inP1. Thus, we can conclude that
P3is not a counterexample at L8without further exploration.
This process is repeated until a real counterexample, i.e. P8,is found. Note that, similar to L8inP3,L8inP5andP7are
also covered by L8inP1.
In summary, in Fig. 2, in the worst case, 3 states are saved
from being explored before the real counterexample P8is
found. Nevertheless, as we can see, the explored state space
is still large. Thus, we are motivated to seek further reduction
of the state space by using more interpolations throughout
the veriÔ¨Åcation process. Two ideas can be gleaned from this
example. (1) If we already know L10inP2is unreachable,
thenL10inP4is also unreachable since the value of satL7
ofP4is obviously smaller than the value of satL7ofP2.
(2) By analyzing P6, we can infer that the error location is
reachable from L15ifs>3holds there. Thus, when exploring
L15inP7, we can conclude that a real counterexample can
certainly be found if the path formula of the preÔ¨Åx from L1
toL15satisÔ¨Åes ‚Äòs> 3‚Äô.
III. M ORE INTERPOLATIONS
To further reduce the state space to be explored, universal
safety interpolation andexistential error interpolation, which
we abbreviate to S-Interp andE-Interp respectively, are for-
malized in this section.
A. Universal Safety Interpolation
DeÔ¨Ånition 2 (Universal Safety Interpolation, S-Interp): Let
lbe a location of a CFG. The universal safety interpolation
(orsafety interpolation for short) of lis a pairS-Interp (l) =
(F;Is), where Fis a variable with value forhindicating
whether the interpolant is fullorhalf; and Isis a conjunction
of predicates.
Initialization: For each location lin a CFG, the default
value of its safety interpolant is:
S-Interp (l) :=8
<
:(f;false) iflis an error location
(f;true) iflis a Ô¨Ånal location
(h;true) otherwise
Update S-Interp: The safety interpolant at each location is
updated whenever a spurious counterexample is found (in an
ART). Let  =hs0;e0;;en 1;snibe a preÔ¨Åx of a spurious
pathhs0;e0;;em 1;smiwheresnis the last reachable
state andn < m. For each 0< in, the Ô¨Årst component
(F-value) of the safety interpolant at si[0], i.e.F(si[0]), is
updated by:
F(si[0]) :=8
<
:f ifS-Interp of all successors of si[0]
are full, ori=n
h otherwise:
The second component (I s-value) of the safety interpolant at
si[0], i.e.Is(si[0]), is updated by:
Is(si[0]) :=8
<
:Is(si[0])^Craig (A;B ) if0<i<n and
F(si+1[0]) =f
Is(si[0])^!Pf(si;ei;si+1)ifi=n
whereA=Pf(s0;;si)andB=Pf(si;ei;si+1)^
!(Is(si+1[0])).
185
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 2. Explored paths
Uses: Safety interpolants are helpful in checking whether
all the paths departing from a state are safe without exploring
all the possible branches emanating from it. For any preÔ¨Åx-
path =hs0;e0;;ei 1;siiwherei0, we can conclude
that all the paths that have as a preÔ¨Åx are safe if
F(si[0]) =fandPf(s0;e0;;ei 1;si)!Is(si[0])
When applying safety interpolation in verifying program
Exa.c, the state space explored is depicted in Fig. 3. First,
P1is explored as usual. When P2is explored, we still check
whether it is spurious and Ô¨Ånd that L7is the last reachable
state. Then, by the update rule of S-Interp, we have
F(L7) =f;andIs(L7) =true^(s3):
Subsequently, the S-Interp ofL6,L4,L3andL2are also
updated as shown in Fig. 3. Note that the S-Interp ofL1is
not updated since the S-Interp ofL2is half. After that, when
exploringL6ofP3, we can conclude that P3is safe since
F(L6) =f;andPf(L1L6)!Is(L6)
holds. Here Pf(L1L6) = \(s 1= 1)^(!(a1== 1))^(i1>
1)^(s2=s1+ 1)" andIs(L6) = \s 23"(obtained in P2).
This process is repeated until the real counterexample P8is
found. Obviously, more states are saved from being explored
than using only R-Interp as shown in Fig. 3. Note that in this
ART, all the grey states (unexplored) reachable from the states
in green are pruned because of safety interpolation.
B. Existential Error Interpolations
In contrast to universal safety interpolation, existential error
interpolation is for checking whether there exists an unsafe
path departing from the current state without exploring all the
future ones.
DeÔ¨Ånition 3 (Existential Error Interpolation, E-Interp): Letl
be a location of a CFG. The existential error interpolation (orerror interpolation for short) at lisE-Interp (l) =Ie, where
Ieis a disjunction of predicates.
Initilization: For each location lof a CFG, its default error
interpolant is:
E-Interp (l) :=8
<
:true iflis an error location
false iflis a Ô¨Ånal location
false otherwise
Update E-Interp: Error interpolants are also updated when-
ever a spurious counterexample is found. Given a spurious
counterexample  =hs0;e0;;en 1;sniwheresn[0]is an
error location, let 0=hsi;ei;;en 1;sniwith 0<in
be the maximal feasible sufÔ¨Åx of . TheE-Interp of locations
involved in  =hs0;e0;;si 1;ei 1;siiare updated by:
E-Interp (si[0]) :=E-Interp (si[0])_Craig (A1;B1)
whereA1=Pf(si;;sn)^E-Interp (sn[0]) andB1=
Pf(s0;;si). For each 0<j <i , set
E-Interp (sj[0]) :=E-Interp (sj[0])_Craig (A2;B2)
whereA2=Pf(sj;ei;sj+1)^E-Interp (sj+1[0]) and
B2=Pf(s0;;sj).
Uses: Error interpolants are useful for checking whether
there exists an unsafe path departing from a state without
exploring all the possible branches emanating from it. For any
preÔ¨Åx-path  =hs0;e0;;ei 1;siiwithi0, it can be
concluded that there exists at least one unsafe path with 
being preÔ¨Åx if
Pf(s0;e0;;si)is satisÔ¨Åable, and
Pf(s0;e0;;si)!E-Interp (si)
Now we show how error interpolation is used in verifying
program Exa.c. As shown in Fig. 4, when P2is explored
as a spurious counterexample, we Ô¨Årst Ô¨Ånd out the maximal
186
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 3. Explored paths under R-Interp andS-Interp
feasible sufÔ¨ÅxhL10;L11iofP2. Then,E-Interp (L10)is
updated by:
E-Interp (L10)
=E-Interp (L10)_Craig 
true;Pf(L1;;L10)
=true
Then,E-Interp s of locations L7,L6,L4,L3, andL2are
updated in order:
E-Interp (L7) =s>3
E-Interp (L6) =s>3
E-Interp (L4) =s>1
E-Interp (L3) =s>1
E-Interp (L2) =s>1
When exploring L15ofP7, we can conclude that there exists
at least one feasible unsafe path since
Pf(L1L15)!E-Interp(L 15)
holds. Here Pf(L1L15) = \(s1= 1)^(a1== 1)^(!(i1>
1))^(s2=s1+ 3)" andE-Interp (L15) = \s 2>3". The
eventually explored state space is depicted in Fig. 4. The states
in grey are not explored while the ones reachable from the
yellow state are pruned because of error interpolation.
C. Interpolations Together
Now we show how the three kinds of interpolations, R-
Interp, S-Interp, and E-Interp, work together to reduce state
space to be explored for checking safety properties of pro-
grams.
Given a CFG whose locations are enriched with default
values of R-Interp, S-Interp, and E-Interp, we produce the
ART for exploring a real counterexample by starting from the
root, i.e.s0: (l0; ;true). The Ô¨Çowchart in Fig. 5 gives a
bird‚Äôs eye view of our approach to safety veriÔ¨Åcation with
reachability, safety and error interpolations. When a state
s: (l;c;p) is being explored and lis not an error location:(1) Reversely traverse the current path for other possibilities
if one of the following three conditions holds:
‚Äìp=false ;
‚Äìp6=false ,F(l) =f, andPf(s0;;s)!Is(l); or
‚Äìp6=false andsis covered by a visited state s0.
(2) Report the program is unsafe, if p6=false and
Pf(s0;;s)!E-Interp (l).
(3) Explore the succeeding state s00: (suc(l );c;p0), other-
wise.
Whenlof the current state s: (l;c;p) is an error location,
we Ô¨Årst check whether the current path  =hs0;;siis
spurious. If is not spurious, we conclude that the program is
unsafe. Otherwise, by update S-Interp, update E-Interp, and
update R-Interp (DeÔ¨Ånition 1), the S-Interp, E-Interp, and
R-Interp of locations involved in are updated, respectively.
Subsequently, we reversely track the current path for other
possibilities and treat a new current state s: (l;c;p) in the
same way until the program is reported as unsafe or there are
no states can be explored (the program is safe).
With the three interpolations working together, we apply
the veriÔ¨Åcation procedure to the example program Exa.c.
In the worst case, when the program is proved unsafe, we
present the state space explored in Fig. 6. In this Figure, the
unexplored states reachable from a state in green are pruned
because of safety interpolants, and those reachable from a state
in yellow are pruned because of error interpolants. As we can
see, more states are saved from being explored than R-Interp,
R-Interp+E-Interp, or R-Interp+S-Interp.
IV. O PTIMIZATION
This section presents optimizing strategies in two directions:
pruning, and accelerating formation of full safety-interpolants
byweight-guided search strategy.
187
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 4. Explored paths under R-Interp andE-Interp
No
Y es
explore state s: (l; c; p)
A:fSA,EAg
No
Y es
SAFE
Y es
No
No
No
produce state s00:(l00; c; p00),
Y es
adds00inSA
Y es
exist
new states
l is an error
location
p==false
sis covered
bys0
Y es
No
Y es
UNSAFE
No
Spurious
update
E-Interp
forward search
reverse search
use S-Interp
use E-Interp
update
S-Interp
update
R-Interp
Pf(Q
)!Is(l)
F(l) =fand
Pf(Q
)!E-Interp (l)
Fig. 5. Interpolations work together
A. Pruning CFG
When verifying real-world programs, there may exist some
locations in a CFG which can never reach any error location.
For instance, for the example program Exa.c in Fig. 1,L8
andL9in the CFG can never reach the error location L11. To
avoid exploring these locations when verifying the program,
we prune the CFG by removing these locations and the relative
control Ô¨Çow edges before generating the ART. To do that, we
start from the error location and traverse the CFG against
the Ô¨Çow of control in depth-Ô¨Årst order; then we remove all of
edges and locations which are not visited. With the aid of such
a pruning strategy, the state space explored when utilizing all
the three kinds of interpolations shown in Fig. 6 can be further
reduced by eliminating the sufÔ¨Åx of P1starting from L7, as
depicted in Fig. 7.
B. Weight-Guided Search Strategy
As discussed in the previous section, a safety interpolant
works only when it is full. Hence, the earlier full safety-
interpolants are formed, the better the effect will be. Theintuition is that if one side of a branch is explored, we expect
to explore the other side as early as possible so as to form full
interpolants. To achieve the goal, we introduce an attribute
weight to transitions of a CFG. When generating an ART, the
branch with the largest weight will be explored Ô¨Årst. Note
that the default weight value of each transition of a CFG is
undeÔ¨Åned (denoted as ?).
Throughout the veriÔ¨Åcation process, for a transition t:
(l;op;l0), we reset
weight (t) = 0 ifF(l0)is changed from htof;
weight (t) =jf(l0; ; )j(l0; ; )is a succeeding tra-
nsition oftgj  1ifl0is the last reachable state in the
current path of the ART and F(l0) =h.
weight (t) =  weight ((l0; ; ))6=? weight ((l0; ; ))+jf(l0
; ; )jweight ((l0; ; )) =?gj for anyt: (l;op;l0),
if the weight value of some transition departing from l0
is changed.
Note that a weight value can be an integer larger than 0
(denoted (>0)),?, and 0. Here we decree: (>0)>?>0. If
the weight values of all the possible transitions are the same,
we just randomly explore one the them.
As an example, for the CFG in Fig. 8, the weight of all edges
are undeÔ¨Åned, initially. When P1is explored as shown in Fig. 8
(1), the weight of all the reachable edges are updated. Then, P2
is explored as shown in Fig. 8 (2). Since L11is unreachable,
no weights are updated. Subsequently, in the third run, P3,
the real counterexample, is explored under the rule since the
weight values of both (L2;s> 1;L 4)and(L6;!(a< 3);L 11)
are?while those of their opposites are both 0. Note that
without the guidance of weight values, in the worst case, 4
paths are required to be explored in order to Ô¨Ånd the real
counterexample.
V. I MPLEMENTATION AND EXPERIMENTS
We have implemented the proposed interpolations and
optimization strategies in a tool called I NTERP CHECKER ,
188
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 6. Explored paths with all interpolations
Fig. 7. Explored paths by pruning strategy
by building on the open source software model checker
CPAChecker [13] (ABE conÔ¨Åguration [16]) which supports
reachability interpolation aided CEGAR veriÔ¨Åcation. Our tool
augments CPAChecker with safety interpolations and error
interpolations, as well as the optimizing strategies proposed
in Section IV. Note that ABE conÔ¨Åguration of CPAChecker
combines predicate abstraction with CEGAR to verify the
programs. Almost all of the new features (some of them are
not publicly available) [38], [39] of CPAChecker are also
implemented based on this conÔ¨Åguration.
To evaluate the proposed interpolations in the safety ver-
iÔ¨Åcation of programs, we selected 11 packages, as shown
in Table I, from the benchmark suite of SV-COMP1where
a large number of programs cannot be successfully veriÔ¨Åed
within a speciÔ¨Åed time bound. These 11 packages constitute
the category ‚ÄúDevice Drivers Linux 64‚Äù in SV-COMP.
1https://github.com/sosy-lab/sv-benchmarks/tree/master/cAll experiments in this paper were done on a Linux virtual
machine, which is conÔ¨Ågured on a PC running octa-core
Windows 7 with 4 GHz and 64GB RAM. The virtual machine
applies Ubuntu 12.04 LTS operation system with 4GHz and
4GB RAM.
Table I describes the results of the original CPACheck-
er (ABE) and another three tools, Smack+Corral [36],
UAutomizer[5], and SATABS [37], which perform well in
the competitions. The third column of Table I gives the
number of programs contained in each package, and the fourth
column gives the total number of lines of programs in each
package. The remaining four columns, give the respective
numbers of programs which are successfully veriÔ¨Åed in 15
mins, using CPAChecker (ABE), Smack+Corral, SATABS,
and UAutomizer. As shown in Table I, CPAChecker (ABE)
performs best with still 33.1% of the programs fail to be
veriÔ¨Åed within the time bound.
189
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 8. Exploration with weight
TABLE I
BENCHMARK PROGRAMS
No. Package-names #Programs #KLOCCPAChecker(ABE) Smack+Corral SATABS UAutomizer
#Suc. #Suc. #Suc. #Suc.
1 ldv-linux-3.7.3 11 246.7 7 6 0 0
2 ldv-challenges 15 448.8 3 3 0 0
3 ldv-validator-v0.6 21 212.8 10 13 2 0
4 ldv-validator-v0.8 27 265.5 7 20 0 0
5 ldv-linux-3.12-rc1 40 478.2 11 28 5 0
6 ldv-linux-3.0 41 755.2 25 35 15 13
7 ldv-consumption 163 2720.8 74 24 85 3
8 ldv-commit-tester 56 477.0 34 34 29 20
9 ldv-linux-3.16-rc1 159 2134.7 45 60 97 0
10 ldv-linux-4.2-rc1 432 10040.8 53 107 13 26
11 ldv-linux-3.4-simple 1163 40763.4 1155 1087 1099 689
Total 2128 58543.7 1424 66.9% 1417 66.6% 1345 63.2% 751 35.3%
The most recent SV-COMP competitions [26], [27] also
show that CPAChecker [5] was the strongest performer on this
category2. Hence we benchmark the performance of our im-
plementations of safety interpolations and error interpolations
against CPAChecker (ABE). By comparison with CPAChecker
(ABE), it can embody directly the advantage of our approach.
Note that the result of CPAChecker presented in Table I might
be inconsistent with the one reported in the competitions
because of different experimental environment.
To examine the effectiveness of the various interpolations,
we verify the programs in Table I using our tool in 5
different modes, namely, R+E, R+S, R+S+E, R+S+W, and
R+S+E+W, where R, E and S denote R-Interp, E-Interp, and S-
Interp respectively; and W indicates the weight -guided search
strategy. (Recall that weight -based searching strategy is only
for the formation of safety interpolants.) Table II presents
the veriÔ¨Åcation results where the sub-column #Suc. gives the
number of programs that are veriÔ¨Åed successfully, and the
sub-column #T.o. gives the sum of programs that failed to be
veriÔ¨Åed within the time bound of 15 mins. It is emphasized
2This category is not included in SV-COMP 2017.that a program is successfully veriÔ¨Åed with a tool indicates
that the veriÔ¨Åcation results (SAFE or UNSAFE) is correctly
reported within the given time bound. That is false positives
or false negatives are not counted in the sub-column #Suc.
From the experimental results, we observe that:
(1) VeriÔ¨Åcation using each of R+E (R-Interp andE-Interp)
and R+S (R-Interp andS-Interp) is more accurate than
veriÔ¨Åcation using only R (R-Interp).
(2) More programs are veriÔ¨Åed using R+S+E than either R+E
or R+S.
(3) VeriÔ¨Åcation using R+S+W is more accurate than R+S.
(4) VeriÔ¨Åcation using R+S+E+W is the most accurate.
Thus we can say that each of the proposed interpolations and
the optimization strategies improves the accuracy, and hence
effectiveness, of program veriÔ¨Åcation. Further, false positive
may occur in principle since the interpolations are over-
approximations of a program. However, our experience shows
that SMTInterpol (tool for computing Craig interpolation in
CPAChecker) always produces good predicates in practice.
In the experimental results, no false positives are introduced
because of the new interpolations.
190
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. TABLE II
COMPARING WITH R
No.R(CPAChecker ABE) R+E R+S R+S+E R+S+W R+S+E+W
#Suc. #T.o. #Suc. #T.o. #Suc. #T.o. #Suc. #T.o. #Suc. #T.o. #Suc. #T.o.
1 7 4 7 4 7 4 7 4 7 4 7 4
2 3 12 3 12 3 12 3 12 4 11 4 11
3 10 11 10 11 10 11 10 11 10 11 11 10
4 7 20 7 20 7 20 8 19 9 18 10 17
5 11 29 12 28 13 27 12 28 15 25 16 24
6 25 16 25 16 25 16 30 10 25 16 29 11
7 74 89 74 89 76 87 76 87 78 85 77 86
8 34 22 39 17 39 17 41 15 39 17 40 16
9 45 114 48 111 67 92 68 91 76 83 79 80
10 53 379 58 374 61 371 64 368 78 354 80 350
11 1155 8 1156 7 1155 8 1156 7 1157 6 1157 6
Total1424 704 1439 689 1463 665 1475 653 1498 630 1510 618
66.9% 33.1% 67.6% 32.4% 68.8% 31.2% 69.3% 30.7% 70.4% 29.6% 71% 29%
TABLE III
TIME CONSUMPTION
No.Time consumption (s)
R R+E R+S R+S+E R+S+W R+S+E+W
1 3950.1 3872.7 4582.1 4675.7 4511.7 4568.5
2 10951.6 10935.6 10944.5 10960.6 10025.3 10029.3
3 10559.1 10355.3 10533.5 9863.3 10735.2 9877.5
4 18421.5 18423.6 18418.6 17629.2 17069.7 16216.5
5 26510.1 25927.6 25210 25514.3 23058.4 22221.5
6 14586.6 14617.1 14606.2 10198.9 15122.9 11260.5
7 82261.3 82035.2 80796.7 80852.4 79918.4 80698.6
8 20105.1 15799.5 15752.7 14077 15633.4 14828.7
9 105364.2 102110.2 84636.7 84086 77140 74989.9
10 344786.1 340653.6 339106 338033.6 325391.5 325703
11 8816.5 7822.3 8772.5 7894.1 6287.9 6273.6
Total 646312.2 632552.7 613359.5 603785.1 584894.4 576667.3
In addition to the number of programs which are success-
fully veriÔ¨Åed with different kinds of interpolations, we are also
interested in the ratio of programs successfully veriÔ¨Åed using
S-Interp and E-Interp, to those successfully veriÔ¨Åed using
the original CEGAR+R-Interp (CPAChecker ABE). Similarly
we are interested in the ratio of programs that fail to be
veriÔ¨Åed using S-Interp andE-Interp, to those that fail to be
veriÔ¨Åed using the original CEGAR+R-Interp. Fig. 9 (a) shows
the percentage (N suc=1424) of the programs veriÔ¨Åed under
each mode; and Fig. 9 (b) shows the percentage (N fail=704)
of the programs that fail to be veriÔ¨Åed under each mode.
Note thatNsucis the number of veriÔ¨Åed programs (in the
respective modes) from the original set of R-Interp -veriÔ¨Åed
1424 programs, and Nfailis the number of the unveriÔ¨Åed
programs (in the respective modes) from the original set of
R-Interp -unveriÔ¨Åed 704 programs.
As shown in Fig. 9 (a), 100% of the programs veriÔ¨Åed under
R-Interp remain successfully veriÔ¨Åed under each of R+E, R+S,
and R+E+S modes, and 98.8% of them remain successfully
veriÔ¨Åed under R+S+W, and R+E+S+W. The rate is lower than
the modes without weight-guided searching strategy, since the
order in which the branches are explored are changed. As
shown in Fig. 9 (b), the ratios of the unveriÔ¨Åed programs under
R+E, R+S, and R+E+S to the unveriÔ¨Åed programs under Rare in descending order, and the rate is lower when the weight
strategy is utilized.
We also compare the time consumption of each mode. As
shown in Table III, R+E and R+S take less time than R;
R+E+S takes less time than both R+E and R+S; R+S+W
takes less time than R+S; and R+S+E+W takes less time than
all others. Thus, both the interpolations and the optimization
strategy are useful in improving the runtime efÔ¨Åciency of
software model checking.
VI. R ELATED WORK
In recent years, Craig interpolation has been extensively
applied to software model checking, symbolic execution, and
testing. An important advantage of these applications is a much
reduced program state space.
A. Program VeriÔ¨Åcation
In pioneering work [14], McMillan computes interpolants to
build unbounded symbolic model checking of Ô¨Ånite state sys-
tems according to the refutations (counterexamples) produced
in bounded model checking. The approach was extended to
the veriÔ¨Åcation of inÔ¨Ånite state systems in [11] by employing
lazy abstraction to reÔ¨Åne the abstract model on demand, thus
producing a sequence of interpolants according to spurious
191
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. Fig. 9. Experimental results
counterexamples. Vizel and Grumberg [15] then applied the
idea of interpolant sequence to SAT-based unbounded model
checking. A three-step interpolant computation process was
proposed by Cabodi, Loiacono and Vendraminetto [18] to
reduce the size of the generated Craig interpolants in SAT-
based unbounded model checking. It improves over standard
interpolation by reducing memory and time. Chu and Jaffar
[23] proposed a framework to synergize partial order reduction
with state interpolation, so as to reduce the state explosion
problem in the safety veriÔ¨Åcation of concurrent programs.
Wachter, Kr ¬®oning and Ouaknine [24] combined lazy abstrac-
tion with interpolants and partial-order reduction: when a
spurious counterexample is found, Craig interpolation is used
to reÔ¨Åne and adjust the precision. The approach by Brillout et
al. [19] uses an expressive interpolating calculus that extends
to the full theory of quantiÔ¨Åer-free Presburger arithmetic with
uninterpreted predicates. This setting enables the synthesis
of quantiÔ¨Åed invariants about arrays. The algorithm WHALE
introduced by Albarghouthi et al. [20] uses interpolation
to compute a function summary by generalizing from an
under-approximation of a function. It can verify recursive
programs and produce modular safety proofs. Cardinality-
constrained extension of Craig interpolation is proposed by
von Gleissenthall et al. [17] to synthesize formulas that satisfy
a given cardinality constraints based on CEGAR. In [33], it
casts the new concept of error invariants for fault localization.
An error trace provides sufÔ¨Åcient information to repeat the
program‚Äôs behavior that violates the correctness assertion. In
order to localize the cause of an error efÔ¨Åciently, it uses errorinvariants to rule out irrelevant transitions from an error trace
and compact the actual cause of an error. Error invariants are
also computed by Craig interpolants. The work in [34] extracts
interpolants in both forward and backward manner and exploits
them for an interwined approximated forward and backward
reachability analysis. It applies Craig Interpolants to obtain
useful information, that is, computes forward and backward
interpolants. In this paper, Error interpolants represent an over-
approximation of the pre-image of the bad states. We extract
the useful information from spurious counterexample paths by
Craig Interpolants.
B. Abstraction-ReÔ¨Ånement-Based VeriÔ¨Åcation
Henzinger et al. [25] have successfully applied Craig inter-
polation to efÔ¨Åciently construct, given an infeasible abstract
error trace, a reÔ¨Åned abstraction that removes the trace. The
approach has been integrated into an explicit-value analysis,
which tracks explicit values for a speciÔ¨Åed set of variables, by
Beyer and L ¬®owe [16]. They use Craig interpolation to reÔ¨Åne
spurious counterexamples in order to construct more precise
abstractions of the explicit-value domain. In this paper, we
refer to interpolants thus employed in [25], [16] as reachability
interpolants. The difference is that we additionally compute
safety interpolants and error interpolants from spurious coun-
terexamples, so as to further reduce the state space to be
explored when verifying safety properties of programs.
C. Symbolic Execution and Testing
In [21], Jaffar, Murali and Navas applied interpolations to
program testing to subsume paths with similar actions. In
symbolic execution, when the search fails to reach a goal, an
annotation on the CFG of the program, called lazy annotation,
is constructed by Craig interpolation. These notations are used
to check whether the current state can reach the goal [22].
VII. C ONCLUSION
In this paper, we have introduced new applications of Craig
interpolation designed to systematically reduce the program
state space to be explored in safety veriÔ¨Åcation. Experiments
on a large number of benchmark programs show that the
new interpolants and the auxillary optimization strategies are
effective in improving scalability of software model checking.
In future work, we plan to develop further optimization tech-
niques, and extend our approach to verify liveness properties of
programs. An important problem is the reduction of overheads
in the construction of interpolants throughout the veriÔ¨Åcation
process.
ACKNOWLEDGEMENT
This research is supported by the National Natural Sci-
ence Foundation of China under grant No. 61420106004 and
61732013. The work was done partially while Duan and Ong
were visiting the Institute for Mathematical Sciences, National
University of Singapore in 2016. The visit was partially
supported by the Institute.
192
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] Ranjit Jhala and Rupak Majumdar. Software model checking. ACM
Computing Surveys, 41(4): 21, 2009.
[2] Edmund M Clarke, Orna Grumberg, and David E Long. Model checking
and abstraction. ACM transactions on Programming Languages and
Systems (TOPLAS), 16(5): 1512-1542, 1994.
[3] Edmund M Clarke, William Klieber, Milo Àás Nov ¬¥aÀácek, and Paolo Zuliani.
Model checking and the state explosion problem. In LASER Summer
School on Software Engineering, pages 1-30. Springer, 2011.
[4] E. M. Clarke, O. Grumberg, S. Jha, Y . Lu, H. Veith, Counterexample-
guided abstraction reÔ¨Ånement for symbolic model checking, J. ACM, vol.
50, no. 5, pp. 752-794, 2003.
[5] Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Gregoire
Sutre. Software VeriÔ¨Åcation with Blast. Proceedings of the 10th SPIN
Workshop on Model Checking Software (SPIN), LNCS 2648, Springer-
Verlag, pages 235-239, 2003.
[6] T. Ball and S.K. Rajamani. The SLAM project: debugging system
software via static analysis. In POPL 02: Principles of Programming
Languages, pages 1-3. ACM, 2002.
[7] Cong Tian, Zhenhua Duan, and Zhao Duan. Making CEGAR
More EfÔ¨Åcient in Software Model Checking. In IEEE Transactions
on Software Engineering (TSE), V ol 40(12), 1206-1223, Dec 2014.
DOI:10.1109/TSE.2014.2357442, 2014.
[8] Cong Tian and Zhenhua Duan. Detecting Spurious Counterexamples
EfÔ¨Åciently in Abstract Model Checking. In the 35th International
Conference on Software Engineering (ICSE 2013), 202-211, 2013.
[9] Dirk Beyer and Philipp Wendler. Algorithms for software model check-
ing: Predicate abstraction vs. impact. In Formal Methods in Computer-
Aided Design (FMCAD), 2012, pages 106-113, IEEE, 2012.
[10] William Craig. Linear reasoning. a new form of the Herbrand-Gentzen
theorem. The Journal of Symbolic Logic, 22(03): 250-268, 1957.
[11] Kenneth L McMillan. Lazy abstraction with interpolants. In Internation-
al Conference on Computer Aided VeriÔ¨Åcation, pages 123-136, Springer,
2006.
[12] Dirk Beyer, Alessandro Cimatti, Alberto Griggio, M Erkan Keremoglu,
and Roberto Sebastiani. Software model checking via large-block
encoding. In Formal Methods in Computer-Aided Design, 2009. FMCAD
2009, pages 25-32, IEEE, 2009.
[13] Dirk Beyer, M Erkan Keremoglu, and Philipp Wendler. Predicate
abstraction with adjustable-block encoding. In Proceedings of the 2010
Conference on Formal Methods in Computer-Aided Design, pages 189-
198, FMCAD Inc, 2010.
[14] Kenneth L McMillan. Interpolation and SAT-based model checking. In
International Conference on Computer Aided VeriÔ¨Åcation, pages 1-13,
Springer, 2003.
[15] Yakir Vizel and Orna Grumberg. Interpolation-sequence based model
checking. In Formal Methods in Computer-Aided Design, 2009. FMCAD
2009, pages 1-8, IEEE, 2009.
[16] Dirk Beyer and Stefan L ¬®owe. Explicit-state software model checking
based on CEGAR and interpolation. In International Conference on Fun-
damental Approaches to Software Engineering, pages 146-162, Springer,
2013.
[17] Klaus von Gleissenthall, Boris K ¬®opf, and Andrey Rybalchenko. Symbol-
ic polytopes for quantitative interpolation and veriÔ¨Åcation. In Internation-
al Conference on Computer Aided VeriÔ¨Åcation, pages 178-194, Springer,
2015.
[18] Gianpiero Cabodi, Carmelo Loiacono, and Danilo Vendraminetto. Op-
timization techniques for Craig interpolant compaction in unbounded
model checking. Formal Methods in System Design, 46(2):135‚Äì162, 2015.
[19] Angelo Brillout, Daniel Kroening, Philipp R ¬®ummer, Thomas Wahl.
Program veriÔ¨Åcation via Craig interpolation for Presburger arithmetic with
arrays. In VERIFY@ IJCAR, pages 31-46, 2010.[20] Aws Albarghouthi, Arie GurÔ¨Ånkel, and Marsha Chechik. Whale:
An interpolation-based algorithm for inter-procedural veriÔ¨Åcation. In
International Workshop on VeriÔ¨Åcation, Model Checking, and Abstract
Interpretation, pages 39-55, Springer, 2012.
[21] Joxan Jaffar, Vijayaraghavan Murali, and Jorge A Navas. Boosting
concolic testing via interpolation. In Proceedings of the 2013 9th Joint
Meeting on Foundations of Software Engineering, pages 48-58, ACM,
2013.
[22] Kenneth L McMillan. Lazy annotation for program testing and veriÔ¨Åca-
tion. In International Conference on Computer Aided VeriÔ¨Åcation, pages
104-118, Springer, 2010.
[23] Duc-Hiep Chu and Joxan Jaffar. A framework to synergize partial order
reduction with state interpolation. In Haifa VeriÔ¨Åcation Conference, pages
171-187, Springer, 2014.
[24] Bj ¬®orn Wachter, Daniel Kroening, and Joel Ouaknine. Verifying multi-
threaded software with impact. In FMCAD, pages 210‚Äì217, 2013.
[25] T. A. Henzinger, R. Jhala, R. Majumdar, and K. L. McMillan. Abstrac-
tions from proofs. In Proc. POPL, 2004, pp. 232-244.
[26] Dirk Beyer. Software veriÔ¨Åcation and veriÔ¨Åable witnesses (Report on
SV-COMP 2015). In International Conference on Tools and Algorithms
for the Construction and Analysis of Systems, pages 401-416, Springer,
2015.
[27] Dirk Beyer. Reliable and reproducible competition results with benchex-
ec and witnesses (report on sv-comp 2016). In International Conference
on Tools and Algorithms for the Construction and Analysis of Systems,
pages 887-904, Springer, 2016.
[28] Thomas A Henzinger, Ranjit Jhala, Rupak Majumdar, and Gr ¬¥egoire
Sutre. Lazy abstraction. In In POPL, pages 58-70, ACM, 2002.
[29] Dirk Beyer, Georg Dresler, and Philipp Wendler. Software veriÔ¨Åcation
in the google app-engine cloud. In International Conference on Computer
Aided VeriÔ¨Åcation, pages 327-333, Springer, 2014.
[30] Bugs found in linux kernel with CPAChekcer: https://cpachecker.sosy-
lab.org/achieve.php
[31] Emanuel Kolb, Ond ÀárejÀáSer`y, and Roland Weiss. Applicability of the blast
model checker: An industrial case study. In International Andrei Ershov
Memorial Conference on Perspectives of System Informatics, pages 218‚Äì
229, Springer, 2009.
[32] Dirk Beyer. Competition on software veriÔ¨Åcation. In International
Conference on Tools and Algorithms for the Construction and Analysis
of Systems, pages 504‚Äì524. Springer, 2012.
[33] Evren Ermis, Martin Sch ¬®af, and Thomas Wies. Error invariants. In
International Symposium on Formal Methods, pages 187‚Äì201. Springer,
2012.
[34] Yakir Vizel, Orna Grumberg, and Sharon Shoham. Intertwined forward-
backward reachability analysis using interpolants. In International Con-
ference on Tools and Algorithms for the Construction and Analysis of
Systems, pages 308‚Äì323. Springer, 2013.
[35] David Gries. The science of programming. Springer Science & Business
Media, 2012.
[36] Arvind Haran, Montgomery Carter, Michael Emmi, Akash Lal, Shaz
Qadeer, and Zvonimir Rakamari ¬¥c. Smack+ corral: A modular veriÔ¨Åer. In
International Conference on Tools and Algorithms for the Construction
and Analysis of Systems, pages 451‚Äì454. Springer, 2015.
[37] G ¬¥erard Basler, Alastair Donaldson, Alexander Kaiser, Daniel Kroening,
Michael Tautschnig, and Thomas Wahl. Satabs: a bit-precise veriÔ¨Åer for
c programs. In International Conference on Tools and Algorithms for the
Construction and Analysis of Systems, pages 552‚Äì555. Springer, 2012.
[38] Dirk Beyer, Stefan L ¬®owe, and Philipp Wendler. ReÔ¨Ånement selection.
InModel Checking Software, pages 20‚Äì38. Springer, 2015.
[39] Daniel Wonisch. Block abstraction memoization for cpachecker. In
International Conference on Tools and Algorithms for the Construction
and Analysis of Systems, pages 531‚Äì533. Springer, 2012.
193
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. 