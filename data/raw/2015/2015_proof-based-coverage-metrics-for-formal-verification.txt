Proof-Based Coverage Metrics
for Formal VeriÔ¨Åcation
Elaheh Ghassabani, Andrew Gaceky, Michael W. Whalen, Mats P. E. Heimdahl, Lucas Wagnery
Department of Computer Science & Engineering, University of Minnesota, MN, USA
yRockwell Collins, Advanced Technology Center, IA, USA
Email:ghass013, mwwhalen, heimdahl@umn.edu,yandrew.gacek, lucas.wagner@rockwellcollins.com
Abstract ‚ÄîWhen using formal veriÔ¨Åcation on critical software,
an important question involves whether we have we speciÔ¨Åed
enough properties for a given implementation model. To address
this question, coverage metrics for property-based formal veriÔ¨Å-
cation have been proposed. Existing metrics are usually based on
mutation, where the implementation model is repeatedly modiÔ¨Åed
and re-analyzed to determine whether mutant models are ‚Äúkilled‚Äù
by the property set. These metrics tend to be very expensive to
compute, as they involve many additional veriÔ¨Åcation problems.
This paper proposes an alternate family of metrics that can
be computed using the recently introduced idea of Inductive
Validity Cores (IVCs). IVCs determine a minimal set of model
elements necessary to establish a proof. One of the proposed
metrics is both rigorous and substantially cheaper to compute
than mutation-based metrics. In addition, unlike the mutation-
based techniques, the design elements marked as necessary by the
metric are guaranteed to preserve provability. We demonstrate the
metrics on a large corpus of examples.
Index Terms‚ÄîCoverage, requirements completeness, formal
veriÔ¨Åcation, inductive proofs, inductive validity cores
I. I NTRODUCTION
In safety critical systems development, an important question
involves whether the requirements and testing process are ade-
quate for the implementation. For example, in DO178B/C [30],
tests are derived from requirements and the adequacy of the
tests is measured by examining coverage of the implementation.
As the criticality of the software increases, more rigorous
adequacy measures (statement, decision, MC/DC) are required,
with the justiÔ¨Åcation that code must be more rigorously exe-
cuted by tests to demonstrate its compliance. If complete cover-
age is not achieved, analysis is performed to determine whether
additional tests or additional requirements are necessary to
achieve coverage.
For critical systems, it has been argued that formal methods
should be applied to gain higher assurance than is possible with
testing [19], [27], [31]. Unfortunately, proof-based approaches
tend not to answer the question as to whether implementations
have functionality that is not covered by requirements. Unlike
testing, for proof the whole system is ‚Äòexecuted‚Äô, but many
parts of the system may be irrelevant to the property that is
proved.
This work was carried out within the HACMS and SOSITE Phase II grants
(DARPA FA8750-12-9-0179 and FA8650-16-C-7656).Relatively recently, techniques have been devised for analyz-
ing adequacy of requirements against formal implementation
models speciÔ¨Åed as transition systems or Kripke structures [5],
[7], [10], [15]. The mechanism used is based on mutation and
proof: is it possible to prove that the requirements still hold of
the system after mutating the model in some way? If so, then
the requirements are incomplete with respect to the mutated part
of the model. Unfortunately, previous approaches to computing
coverage metrics can underapproximate which portions of a
program are necessary to prove the requirements. In addition,
the mutation-based analyses tend to be computationally very
expensive because there are many possible mutant models
to verify. For example, for model checkers, state of the art
techniques have runtimes of (in the best case) several times
more than is required for proof [4].
We wish to have a graduated set of metrics, suitable for
use in certiÔ¨Åcation, for checking the adequacy of requirements
against an implementation model that: (1) can be applied early
and throughout a development cycle on different implemen-
tation artifacts, (2) are proof preserving: the portion of the
implementation that is identiÔ¨Åed as covered demonstrates the
fulÔ¨Ållment of the requirement but does not contain irrelevant
information, and (3) are efÔ¨Åcient to compute. Towards this
end, we propose measures of requirements adequacy based on
minimal proofs of requirements. We measure the adequacy of a
set of requirements by examining an (approximately) minimal
set of model elements necessary to construct a proof of all the
requirements.
Our approach is applicable to reactive software that does
a bounded amount of computation in response to an input
for an unbounded sequence of inputs. This set contains most
embedded and especially safety-critical software, and can be
described as transition systems (equivalently, inÔ¨Ånite-state ‚Äúcir-
cuits‚Äù that compute next states given an input and current state).
It is implemented using Inductive Validity Cores (IVCs) [13]
for transition systems, and integrated into a branch of the
JKind model checker [1]. In our benchmarks, we demonstrate
that one of the proof-based metrics is considerably more
computationally tractable than previous approaches based on
mutation, averaging 24% overhead over model-checking alone,
rather than the 2369% overhead required for the state of the art
of the mutation-based metrics. Thus, the contributions of this
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research - New Ideas194
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. node asw(alt1, alt2: int; inhibit: bool)
returns (doi_on: bool);
var
a1_below, a2_below, a1_above, a2_above,
below, above_hyst, d1, d2: bool;
let
a1_below = (alt1 < THRESHOLD); // (1)
a2_below = (alt2 < THRESHOLD); // (2)
a1_above = (alt1 >= T_HYST); // (3)
a2_above = (alt2 >= T_HYST); // (4)
below = a1_below or a2_below; // (5)
above_hyst = a1_above and a2_above; // (6)
doi_on = if (below and not inhibit) // (7)
then true else d1;
d1 = if (inhibit or above_hyst) // (8)
then false else d2;
d2 = (false -> pre(doi_on)); // (9)
tel;
Fig. 1. Altitude Switch Model
work are:
1) A family of coverage metrics for formal veriÔ¨Åcation
based on minimal Inductive Validity Cores (MIVCs).
Most of the proposed metrics are proof preserving,
2) A discussion of the relationship between proof-based
metrics and mutation-based metrics, including a proof of
equivalence between non-deterministic mutation cover-
age and one of the proof-based metrics ( MUST-COV).
3) An implementation that efÔ¨Åciently computes property
coverage over symbolic transition systems,
4) An initial experiment that compares our technique against
a state of the art mutation-based notion of completeness.
II. R UNNING EXAMPLE
We use a very simple system from the avionics domain
to illustrate our approach. An Altitude Switch (ASW) is a
hypothetical device that turns power on to another subsystem,
the Device of Interest (DOI), when the aircraft descends below
a threshold altitude and turns the power off again after we
ascend over the threshold plus some hysteresis factor. An
implementation of an ASW containing two altimeters written
in the Lustre [17] language (simpliÔ¨Åed and adapted from [20])
is shown in Figure 1. If the system is not ‚Äúinhibited‚Äù by the
user and either altimeter is below the constant THRESHOLD,
then it turns on the DOI; else, if the system is inhibited or both
altimeters are above the threshold plus the hysteresis factor
(THRESHOLD + HYST T_Hyst), then the DOI is turned off,
and if neither condition holds, then in the initial computation
it is false and thereafter retains its previous value. The nota-
tion(false -> pre(doi_on)) in equation (9) describes an
initialized register in Lustre: in the initial state, the expression
isfalse, and thereafter it is the previous value of doi_on. In
the remainder of the paper, we will use this model to illustrate
aspects of requirements completeness.
III. P RELIMINARIES
This section presents formalizations of transition systems,
inductive validity cores, and background information onmutation-based coverage metrics. Although we focus the for-
malism below on safety properties, the approach is able to han-
dle liveness properties through reduction to safety properties,
as is performed by, e.g., K-liveness [8].
A. Models, Requirements, and Provability
Given a state space U, a transition system (I;T)consists
of an initial state predicate I:U!bool and a transition
step predicate T:UU!bool. We deÔ¨Åne the notion of
reachability for (I;T)as the smallest predicate R:U!bool
which satisÔ¨Åes the following formulas:
8u: I (u))R(u)
8u;u0:R(u)^T(u;u0))R(u0)
A safety property P:U!bool is a state predicate that holds
on a transition system (I;T)if it holds on all reachable states,
i.e.,8u:R(u))P(u), written as R)Pfor short. When this
is the case, we write (I;T)`P. We assume the transition
relation has the structure of a top-level conjunction. This
assumption gives us a structure that we can easily manipulate.
GivenT(u;u0) =T1(u;u0)^^Tn(u;u0)we will write
T=T1^^Tnfor short. By further abuse of notation,
Tis identiÔ¨Åed with the set of its top-level conjuncts. Thus,
x2Tmeans thatxis a top-level conjunct of T, andST
means all top-level conjuncts of Sare top-level conjuncts of T.
When a top-level conjunct xis removed from T, it is written
asTnfxg. Such a transition system can easily encode our
example model in Section II. We assume each equation deÔ¨Ånes
a conjunct within the transition system which we will denote
by the variable assigned, so T=fa1_below, a2_below,
a1_above, a2_above, below, above_hyst, d1, d2 g.
DeÔ¨Ånition 1. Inductive Validity Core (IVC ) [13]:STfor
(I;T)`Pis an Inductive Validity Core, denoted by IVC(P;S ),
iff(I;S)`P.
In examining provability, we are interested in minimal sets
that satisfy a property P; tracing a property to the entire
model is not particularly enlightening. Fortunately, IVCs have
the following monotonicity property [13]: given (I;T)`P,
8S1S2T.IVC (P;S 1))IVC (P;S 2). We next
introduce the notion of minimal inductive validity cores.
DeÔ¨Ånition 2. Minimal Inductive Validity Core (MIVC ) [13]:
STis a minimal Inductive Validity Core, denoted by
MIVC(P;S ), iff IVC(P;S )^8Ti2S:(I;SnfT ig)0P.
Note that given (I;T)`P,Palways has at least one MIVC,
which implies MIVC s are not necessarily unique. For example,
takeI=a^b,T=a0^b0, andP=a_b. Then bothfa0g
andfb0gareMIVC s for (I;T)`P. To capture this fact, the
all MIVCs (AIVC )relation has been introduced [29].
AIVC (P)fSjST^MIVC(P;S )g
Establishing the AIVC for a single property, one gets a
clear picture of the all the model elements constrained by the
property. The set of AIVC s for all properties demonstrates
a complete mapping from the requirements to the design
elements, which is called complete traceability [29].
195
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. B. Coverage and Mutations
In general, speciÔ¨Åcation completeness can be deÔ¨Åned with
regard to the notion of coverage. In fact, the way that coverage
is formalized plays a key part in the strength/effectiveness of
a method for the assessment of completeness. The goal of
a coverage metric is usually to assign a numeric score that
describes how well properties cover the design. The majority of
the work on coverage metrics has focused on mutations, which
are ‚Äúatomic‚Äù changes to the design, where the set of possible
mutations depends on the notation that is used. A mutant is
‚Äúkilled‚Äù if one of the properties that is satisÔ¨Åed by the original
design is violated by the mutated design [4]‚Äì[6], [24], [25].
There are many different kinds of mutations that have been
proposed, primarily focused on checking sequential bit-level
hardware designs. Similarly, for software, it is possible to apply
any of the ‚Äústandard‚Äù source code mutation operators used for
software testing [3] towards requirements coverage analysis.
We assume each element Ti2Thas a set of possible
mutations associated with it. Depending on the modeling for-
malism used, this may be the value of a gate or signal or an
expression within a statement in a program. We will further
assume the existence of a mutation function fmthat, given a
model element, will return a Ô¨Ånite set of mutations for that
element. We can then deÔ¨Åne the set of mutant models Mas
follows:
M=f(TnfT ig)[fmgjTi2T;m2fm(Ti)g
and then deÔ¨Åne the mutation score for property Pin the
standard way:
DeÔ¨Ånition 3. Generalized mutation coverage.
MUTANT -COV=jfmjm2M^(I;m )0Pgj
jMj
Note that without loss of generality, we consider a single
propertyP, which can be viewed as the conjunction of all
the properties of the model.
In our example in Figure 1, applying the software muta-
tions from [3] would involve manipulating the constants used
in the deÔ¨Ånitions of a1_below, a2_below, a1_above,
a2_above, swapping orandand in the deÔ¨Ånition of below,
above_hyst, or negating the conditions in the if/then/else
statements. Even for this small model, there are many possible
mutations (57). The number of single-mutation programs is
roughly the product of the leaf elements of the program
abstract syntax tree (AST) and the size of the chosen set
of mutations, which can lead to an impractical number of
veriÔ¨Åcation problems.
Mutations for hardware are discussed in [4], [24], [25]. The
state of the art of mutation-based coverage can be found in
[4], where a design is considered as a net-list with nodes of
types fAND, INVERTER, REGISTER, INPUTg. Each mutant
design changes the type of a single node to INPUT. When
propertysatisÔ¨Åed by the original net-list fails on the mutant
design, it is said that a mutant is discovered for . Then, the
coverage metric for is deÔ¨Åned as the fraction of the discoveredmutants, based on which the coverage of a set of properties
is measured as the fraction of mutants discovered by at least
one property. To decrease the cost of computation, coverage
analysis is performed at several stages; Ô¨Årst, all the nodes that
do not appear in the resolution proof of a given property are
marked as not-covered, and the rest of the nodes are marked
asunknown. Then, for the unknown nodes, the basic mutation
check is performed: if a corresponding mutant design violates
the property, it will be considered as covered.
IV. P ROOF -BASED METRICS
We propose a new approach for measuring property com-
pleteness based on proof rather than mutation. We Ô¨Årst deÔ¨Åne
notation, then describe different possible metrics given a set of
minimal proofs.
DeÔ¨Ånition 4. IVC coverage ( IVC-C OV):
GivenS2AIVC (P),Tiis covered by PviaSiffTi2S.
We call DeÔ¨Ånition 4 a proof-preserving metric because, with
a set of the model elements marked as covered by IVC-C OV,
Pis provable. Other notions, as will be discussed in Sec-
tion IV-A, may yield subsets of the model that are insufÔ¨Åcient
to reconstruct the proof of the property. The coverage score for
IVC-C OVcan be calculated with:
jSj
jTj
BecausePmay have multiple MIVC s,IVC-C OVmetric can
lead to various scores that belong to the following set:
fjSj
jTjjS2AIVC (P)g
Note that if an MIVC contains all model elements (i.e., the
model is completely covered), then there is only one possible
MIVC, so in this case there is no diversity of scores.
Given allproofs of a particular property, it is possible to
deÔ¨Åne additional, complementary coverage notions. To do so,
we use the following categorization of the model elements
based on MIVC andAIVC relations for P:
MUST (P) =TAIVC (P)
MAY (P) = (SAIVC (P))nMUST (P)
IRR(P) =Tn(SAIVC (P))
This categorization helps to identify the role and relevance of
each design element in satisfying a property. Function MUST
speciÔ¨Åes the parts of the model absolutely necessary for the
property satisfaction. Any change to these parts will affect prov-
ability of the property. On the other hand, any single element
inMAY (P), may be modiÔ¨Åed without affecting satisfaction of
P(though modifying multiple elements may require re-proof).
TheIRR denotes model elements that are irrelevant to the
validity ofP[29]. Using the notions of MAY andMUST ,
we can introduce additional coverage metrics.
DeÔ¨Ånition 5. (MAY-COV):Ti2Tis covered by PiffTi2
MAY-COV(P), where MAY-COV(P) =fTij9S2AIVC (P)
Ti2Sg.
196
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. DeÔ¨Ånition 6. (MUST-COV):Ti2Tis covered by PiffTi2
MUST-COV(P), where MUST-COV(P) =fTij8S2AIVC (P)
Ti2Sg.
The MAY-COVnotion aims to deal with the fact that a
propertyPmay have several distinct MIVC s. In such cases,
IVC-C OVonly looks at an arbitrary MIVC that may contain
a subset of MAY (P), which means, depending on which
MIVC it considers, every time it may report a different part of
MAY (P)as uncovered. However, MAY-COVresolves this issue
reporting the entire set of MAY (P)as covered, which also
leads to higher coverage scores. MUST-COVtakes the opposite
view, considering a model element as covered only if it affects
all the proofs of P.
It is still possible to build more relaxed coverage metrics in
which coverage is captured by looking at individual properties,
rather than their conjunction. We can, for example, describe a
metric in which any element used by an MIVC for any prop-
erty is considered covered. The next deÔ¨Ånition, MODEL -COV,
formalizes this notion.
DeÔ¨Ånition 7. (MODEL -COV):Given a set of properties 
overT,Ti2Tis covered iffTi2MODEL -COV(T), where
MODEL -COV(T) =fTij9P2; S2AIVC (P): T i2Sg.
A. Discussion
Based on the categorization of elements, we will state some
relationships about MIVC s so to compare different proof-based
metrics proposed earlier.
Lemma 1. IfMAY (P)6=?, thenPis not provable by
MUST (P).
Now we focus on the relationship between non-deterministic
mutation-based coverage and proof-based metrics. In Chockler
et. al. [4], each mutant design changes the type of a single
node to INPUT. Given a suitable encoding of the netlist,
assigning a ‚Äúfresh‚Äù input is an isomorphic operation to simply
removing a TifromT. The mapping is as follows: the net-
list becomes a conjunction of equations, where each vertex
becomes a variable vi2U, and where each non-input vertex
becomes an assignment equation Ti2T. For example, given
anAND-vertexviwith three input edges from other vertexes
fva;vb;vcg, we would deÔ¨Åne an equation Ti2Tof the form
(vi= (va^vb^vc)).
Given this encoding, we can reframe the non-deterministic
coverage proposed in [4] as follows:
DeÔ¨Ånition 8. Nondeterministic coverage (alternate speciÔ¨Åca-
tion) ( NONDET -COV) [4].Ti2Tis covered by property
PiffTi2NONDET -COV(P), where NONDET -COV(P) =
fTij(I;T)`P^(I;TnfT ig)0Pg.
Given this deÔ¨Ånition, it becomes straightforward to deÔ¨Åne some
additional properties.
Lemma 2. Ti2NONDET -COV(P),Ti2MUST-COV(P).In light of Lemma 2, the NONDET -COVcoverage score of
speciÔ¨Åcation Pcan be also calculated by
jMUST (P)j
jTj
Immediate from Lemmas 1 and 2, NONDET -COVis not
proof-preserving, while IVC-C OVis proof-preserving by deÔ¨Åni-
tion. Note that one can deÔ¨Åne many more proof-based coverage
metrics based on the MIVC=AIVC idea. Metrics that make
use of theAIVC relation are computationally more expensive
to compute than IVC-C OValthough they might be easier to
satisfy (i.e., result in higher coverage scores). In general, when
coverage scores of a given property are obtained from the
proposed metrics, the following relationship holds:
NONDET -COVIVC-C OVMAY-COVMODEL -COV
IVC-C OVand NONDET -COVare equivalent when all elements
within the model are covered: if all model elements are MUST
elements, then there can only be one MIVC, and this MIVC uses
all of the model elements. In the implementation and exper-
iments, we will focus on the IVC-C OVand NONDET -COV
metrics. Both metrics are fairly rigorous and can be com-
puted reasonably efÔ¨Åciently. The equivalence of MUST-COVand
NONDET -COVallows us to compare our algorithms against
state-of-the-art mutation based coverage.
V. I LLUSTRATION
We illustrate the idea of completeness metrics and the
‚Äúscore‚Äù from different metrics on our altitude switch (ASW)
example from Section II. The ASW is responsible for turning
on and off a device of interest, so we formulate two require-
ments that describe when the ASW should be onand when it
should be off. The Ô¨Årst attempt at formalization (property set
1) is as follows:
on_p = (a1_below and a2_below) and not inhibit =>
doi_on = true;
off_p = (a1_above and a2_above) and inhibit =>
doi_on = false;
all_p = on_p and off_p;
For each of the IVC-C OV,MAY-COV, and MUST-COVmetrics,
all_p only requires fbelow, d1, doi_ong. This small set
of elements is due to a classic speciÔ¨Åcation problem: using
computed variables as the antecedents of implications. We
therefore modify our properties to use inputs and constants as
antecedents and derive:
on_p = ((alt1 < THRESHOLD) and (alt2 < THRESHOLD))
and not inhibit => doi_on = true;
off_p = ((alt1 >= T_HYST) and (alt2 >= T_HYST))
and inhibit => doi_on = false;
In this version, distinctions emerge between the metrics.
all_p has two MIVC s:ffa1_below, below, doi_on,
d1g, fa2_below, below, doi_on, d1gg, because of the
on_p property: in the implementation, the DOI is turned on
when either of the altimeters is below the threshold, while
our property states that they both must be below. The MUST
elements remain the same: fbelow, doi_on, d1g, because
197
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. neither a1_below ora2_below is required for all proofs, and
the MAY elements contain both a1_below anda2_below.
The above_hyst, a1_above, a2_above, and d2equa-
tions are still missing, meaning that the ‚Äúabove‚Äù thresholds
are irrelevant to our properties. We realize we are missing a
hysteresis case, and end up with the following set of properties:
on_p = ((alt1 < THRESHOLD) and (alt2 < THRESHOLD))
and not inhibit => doi_on = true;
off_p = ((alt1 >= T_HYST) and (alt2 >= T_HYST))
or inhibit => doi_on = false;
hyst_p = not inhibit and
(alt1 > THRESHOLD and alt2 > THRESHOLD) and
(alt1 < T_HYST or alt2 < T_HYST) =>
(doi_on = false -> doi_on = pre(doi_on))
all_p = on_p and off_p and hyst_p;
The hysteresis property states that if the antecedent conditions
hold, then in the initial state, the doi_on variable is assigned
false, and in subsequent steps, it retains the same value as it
previously had. This property set, which includes all variables
for all measures, can reasonably be seen as describing the
interesting behavior of the model.
VI. I MPLEMENTATION AND INITIAL RESULTS
For implementation we have made use of the technique
proposed by Ghassabani et al. [13] using the Algorithm IVC UC
that computes an approximately minimal IVC in an efÔ¨Åcient
way.1To compute the must set of a given property as efÔ¨Åciently
as possible, we use the algorithm from [4], adapted to use
the more scalable PDR [11] algorithm rather than interpola-
tion for model checking. We call this algorithm MUST-COV.
These algorithms have been implemented in the JKind model
checker [1], [9], [12]. JKind proves safety properties using
multiple cooperative engines in parallel including k-induction
[32], property directed reachability (PDR) [11], and template-
based lemma generation [22].
To examine the efÔ¨Åciency and effectiveness of our approach,
we ran the MUST-COVand the IVC-C OVmetric against a bench-
mark suite consisting of 475 Lustre models (395 from [16]
and 80 industrial models derived from [28] and other sources).
Most of the benchmark models from [16] are small (10kB
or less, with 6-40 equations) and the industrial models each
are80kB with over 600 equations.2The overhead of the
IVC UCalgorithm is, on average, 24% over the baseline proof,
as opposed to the 2369% runtime overhead for the MUST-COV
computation. In many cases, the IVC-C OVmetric is efÔ¨Åcient
enough to run as part of the veriÔ¨Åcation process.
To examine effectiveness, we examined the portion of the
model required by each of the coverage metrics. Any proposed
metric should be justiÔ¨Åed and yield meaningful information
about the adequacy of the property set. As a baseline, we
use backwards static slicing, which is used in the hardware
veriÔ¨Åcation community for measuring adequacy. Our claim is
that slicing is too loose a metric to be useful. This claim was
justiÔ¨Åed in our benchmarks, where coverage reported by static
slicing is, on average, 20.5x higher than the IVC-C OVmetric.
1For complete information, see Ghassabani et. al [13].
2Tools and complete presentation of results are accessible from [2].Our metrics have a justiÔ¨Åcation from proof: for each of
the metrics, any model element returned must be necessary
tosome proof. However, there are differences between the
reported coverage of the metrics. On average, the IVC-C OV
metric yields 1.15x higher coverage than the MUST-COVmetric.
This might lead one to prefer the MUST-COVmetric, but it is
more expensive to compute and the resulting set of elements
does not always lead to a proof. Additional study is necessary
to determine the best circumstances for use of each metric.
VII. R ELATED WORK
Coverage in veriÔ¨Åcation was introduced in [21], [23].
Hoskote et al. [21] suggested a state-based metric in model
checking based on FSM mutations, which are small atomic
changes to the design. Later in [6], Chockler et al. provided
corresponding notions of metrics used in simulation-based
veriÔ¨Åcation for formal veriÔ¨Åcation. However, the proposed algo-
rithm in [6] is both computationally expensive (approximately
linear in the number of mutations). Most of the mutation-based
metrics, including [5], [25], are focused on Ô¨Ånite state systems
and hardware systems. A more recent work in [4] performs
coverage analysis through interpolation [26]. This work is also
based on design-dependent mutations [6], as explained in III-B.
The proposed algorithm is similar to the IVC MUST algorithm
as discussed in IV-A except that our implementation uses PDR
andk-induction rather than interpolation.
A similar notion to ours was outlined in a patent [18], which
sketches a family of proof core-based metrics for hardware veri-
Ô¨Åcation. While the approach described by the patent is general,
no formal description of the models, metrics, algorithms, or
experimental results are provided.
VIII. C ONCLUSIONS & F UTURE WORK
In this paper, we have examined the use of proof-based cov-
erage notions for formal veriÔ¨Åcation. These provide an alternate
way of measuring property completeness, which, in some cases,
are much more efÔ¨Åcient than existing work in the literature
while still providing accurate information about the covered
parts of a given design. Most of our proposed metrics preserve
provability, which means that the set of elements considered
covered by our algorithm is sufÔ¨Åcient to establish the validity
proof for every requirement in the set of speciÔ¨Åcations. The
notion of proof preservation is appealing because it allows a
concrete demonstration to the user of the irrelevance of portions
of the implementation. The utility of the proposed metrics are
being evaluated by Rockwell Collins on a pilot project. The
proposed metrics appear to be useful for both traceability and
adequacy checking [33].
Since some of the proposed metrics need to compute all
IVCs, we have investigated efÔ¨Åcient algorithms for computing
all IVCs [14]. In cases where there are multiple minimal
satisfying sets, the all IVCs give insight on multiple ways by
which the model meets a requirement.
198
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] JKind. http://loonwerks.com/tools/jkind.html.
[2] Tools and Experimental Results. https://github.com/elaghs/Working/tree/
master/ASE17.
[3] J. Andrews et al. Using mutation analysis for assessing and comparing
testing coverage criteria. TSE, 2006.
[4] H. Chockler et al. Coverage in interpolation-based model checking. In
DAC.
[5] H. Chockler et al. A practical approach to coverage in model checking.
InCAV01, 2001.
[6] H. Chockler et al. Coverage metrics for formal veriÔ¨Åcation. CHARME,
2003.
[7] K. Claessen. A coverage analysis for safety property lists. In FMCAD‚Äô07,
2007.
[8] K. Claessen and N. Srensson. A liveness checking algorithm that counts.
InFMCAD, pages 52‚Äì59. IEEE, 2012.
[9] D. D. Cofer et al. Compositional veriÔ¨Åcation of architectural models. In
NFM‚Äô12, 2012.
[10] S. Das et al. Formal methods for analyzing the completeness of an
assertion suite against a high-level fault model. In VLSID.
[11] N. Een et al. EfÔ¨Åcient implementation of property directed reachability.
InFMCAD ‚Äô11, 2011.
[12] A. Fifarek et al. Spear v2.0: Formalized past LTL speciÔ¨Åcation and
analysis of requirements. In NFM‚Äô17, 2017.
[13] E. Ghassabani et al. EfÔ¨Åcient generation of inductive validity cores for
safety properties. In FSE2016, 2016.
[14] E. Ghassabani et al. EfÔ¨Åcient generation of all minimal inductive validity
cores. In FMCAD‚Äô17, 2017.
[15] D. Grosse et al. Estimating functional coverage in bounded model
checking. In DATE‚Äô07, 2007.
[16] G. Hagen and C. Tinelli. Scaling up the formal veriÔ¨Åcation of Lustre
programs with smt-based techniques. In FMCAD ‚Äô08, 2008.
[17] N. Halbwachs et al. The Synchronous DataÔ¨Çow Programming Language
Lustre. Proceedings of the IEEE, 1991.[18] Z. Hanna et al. Formal veriÔ¨Åcation coverage metrics for circuit design
properties, May 14 2015. US Patent App. 14/474,280.
[19] D. Hardin et al. Development of security software: A high-assurance
methodology. In ICFEM‚Äô09, 2009.
[20] M. P. Heimdahl et al. Deviation analysis via model checking. In ASE‚Äô02,
2002.
[21] Y . Hoskote et al. Coverage estimation for symbolic model checking. In
DAC.
[22] T. Kahsai et al. Instantiation-based invariant discovery. In NFM‚Äô11, 2011.
[23] S. Katz et al. Have i written enough properties?-a method of comparison
between speciÔ¨Åcation and implementation. In CHARME, 1999.
[24] O. Kupferman. Sanity checks in formal veriÔ¨Åcation. In CONCUR‚Äô06,
2006.
[25] O. Kupferman et al. A theory of mutations with applications to vacuity,
coverage, and fault tolerance. In FMCAD‚Äô08, 2008.
[26] K. L. McMillan. Interpolation and sat-based model checking. In CAV‚Äô03.
[27] S. P. Miller et al. Software model checking takes off. 2010.
[28] A. Murugesan et al. Compositional veriÔ¨Åcation of a medical device
system. In HILT‚Äô13, 2013.
[29] A. Murugesan et al. Complete traceability for requirements in satisfaction
arguments. In RE@Next, 2016.
[30] RTCA/DO-178C. Software considerations in airborne systems and
equipment certiÔ¨Åcation.
[31] J. Rushby. Software veriÔ¨Åcation and system assurance. In SEFM‚Äô09.
[32] M. Sheeran et al. Checking safety properties using induction and a SAT-
solver. In FMCAD, 2000.
[33] L. Wagner. Automating DO-178C objectives with SpeAR: A
case study. http://www.mys5.org/Proceedings/2017/Day 1/2017-S5-
Day1 1335 Wagner.pdf, Safe and Secure Systems and Software Sym-
posium (S5), AFRL, 2017.
199
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 14:48:35 UTC from IEEE Xplore.  Restrictions apply. 