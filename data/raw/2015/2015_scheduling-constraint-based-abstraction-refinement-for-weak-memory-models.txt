Scheduling Constraint Based Abstraction Refinement for Weak
Memory Models
Liangze Yin
Laboratory of Software Engineering for Complex Systems
National University of Defense Technology
Changsha, Hunan, China
yinliangze@163.comWei Dong‚àó
Laboratory of Software Engineering for Complex Systems
National University of Defense Technology
Changsha, Hunan, China
wdong@nudt.edu.cn
Wanwei Liu
Laboratory of Software Engineering for Complex Systems
National University of Defense Technology
Changsha, Hunan, China
wwliu@nudt.edu.cnJi Wang‚àó
State Key Laboratory of High Performance Computing
National University of Defense Technology
Changsha, Hunan, China
wj@nudt.edu.cn
ABSTRACT
Scheduling constraint based abstraction refinement (SCAR) is one
ofthemostefficientmethodsforverifyingprogramsundersequen-
tial consistency (SC). However, most multi-processor architectures
implement weak memory models (WMMs) in order to improve the
performance of a program. Due to the nondeterministic execution
of those memory operations by the same thread, the behavior of
a program under WMMs is much more complex than that under
SC, which significantly increases the verification complexity. This
paper elegantly extends the SCAR method to WMMs such as TSO
andPSO.Tocapturetheorderrequirementsofanabstractioncoun-
terexample under WMMs, we have enriched the event order graph
(EOG)ofacounterexamplesuchthatitiscompetentforbothSCand
WMMs. We have also proposed a unified EOG generation method
which can always obtain a minimal EOG efficiently. Experimental
resultsonalargesetofmulti-threadedCprogramsshowpromising
results ofour method.It significantlyoutperforms state-of-the-art
tools, and the time and memory it required to verify a program
under TSO and PSO are roughly comparable to that under SC.
CCS CONCEPTS
‚Ä¢Software and its engineering ‚ÜíSoftware verification and
validation;
KEYWORDS
concurrent program verification, weak memory model, scheduling
constraint, event order graph
‚àóCorresponding authors.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACM
mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,
topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
¬© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238223ACM Reference Format:
LiangzeYin,WeiDong,WanweiLiu,andJiWang.2018.SchedulingCon-
straintBasedAbstractionRefinementforWeakMemoryModels.In Proceed-
ings of the 2018 33rd ACM/IEEE International Conference on Automated Soft-
wareEngineering(ASE‚Äô18),September3‚Äì7,2018,Montpellier,France. ACM,
New York, NY, USA, 11pages.https://doi.org/10.1145/3238147.3238223
1 INTRODUCTION
Sequential consistency (SC) is a simple and commonly assumed
memoryconsistencymodelforconcurrentprograms.Mostexisting
work for concurrent program verification focuses on SC. How-
ever, to improve the performance of concurrent programs, most
multi-processor architectures use weak memory models (WMMs).
Programs under WMMs exhibit two kinds of nondeterminism: the
inter-threadnondeterminismduetothethreadinterleaving,andthe
intra-threadnondeterminismduetotheoutofordereffectonthose
memory operations by the same thread. Due to the intra-thread
nondeterminism,aprogramunderWMMsallowsmanymorepaths
thanthatunderSC,whichsignificantlyincreasesthecomplexity
of writing and verifying concurrent programs.
Bounded model checking (BMC) [ 10] is one of the most efficient
techniquestoalleviatethepathexplosionproblemofconcurrent
programs.However,a largeformulaisusually requiredtogivean
exact encoding of the program behavior. To avoid the large encod-
ing,wehaveproposedaschedulingconstraintbasedabstraction
refinement(SCAR)methodforverificationofconcurrentprograms
under SC [ 31]. The idea is that, observing that the scheduling con-
straint usually dominates the monolithic encoding, we initially
ignoretheschedulingconstraintandobtainanover-approximation
of the original program. If a counterexample is found, further vali-
dationofthecounterexampleisperformedandtheabstractionis
refined if the counterexample is determined to be infeasible. Toprune more search space in each iteration, we have proposed a
notionofeventordergraph(EOG)andtwograph-basedalgorithms
over EOG for counterexample validation and refinement genera-
tion. We have proved that our method is both sound and complete
w.r.t. the given loop unwinding depth. Our tool implementing this
methodhaswonthegoldmedalintheConcurrencySafetycategory
of both SV-COMP 2017 and 2018.
645
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang
In this paper, we try to extend this method to WMMs such
as TSO and PSO. We first analyzed the difference between the
monolithicencodingsofconcurrentprogramsunderSCandWMMs.
The only difference is on the execution order of those memory
operationsbythesamethread,whichisdeterministicunderSCbut
nondeterministic under WMMs. The out of order effect of WMMs
allowsafollowingoperationtoexecutebeforeapreviousone.Inthe
SCAR method, the execution order of different memory operations
iscapturedbytheEOGofanabstractioncounterexample.Toextend
thismethodtoWMMs,wehaveenrichedtheEOGbyemploying
a directed graph rather than a line to restrain the intra-thread
execution order. An intuitive method to obtain the EOG usually
generatesmanyredundantorders,whichmaysignificantlyincrease
the overhead of those graph analysis processes. To address this
problem, we have devised a unified EOG generation algorithm,
whichcanalwaysobtaintheminimalEOGforbothSCandWMMs
efficiently.Then,weobtainedaunifiedSCARmethodwhichcan
deal with programs under both SC and different WMMs.
We have implemented our method on top of Yogar-CBMC and
evaluated it on the benchmarks in the ConcurrencySafety category
of SV-COMP 2018. Experimental results show promising perfor-
manceofourmethod.Ithassuccessfullyverifiedallexamplesunder
TSO and PSO, and performs much better than CBMC, one of the
most popular verifier for concurrent program verification. We also
observedthatourmethodisnotsensitivetodifferentmemorymod-
els. In our experiments, the time and memory it required to verify
a program under WMMs are comparable to that under SC.
The contributions of this paper are listed as follows.
(1)This paper has elegantly extended the SCAR method to a
unified approach for different memory models, which can
deal with programs under both SC and WMMs.
(2)ThispaperhasproposedaunifiedalgorithmforEOGgen-
eration, which is suitable for different memory models, and
can always obtain the minimal EOG efficiently.
(3)We have implemented our method on top of Yogar-CBMC.
Experimentalresultsonalargenumberofprogramsshow
promising performance of our method.
(4)We have verified all examples in the ConcurrencySafety
category of SV-COMP 2018 under TSO and PSO. To the best
of our knowledge, we are the first to give exact results to all
these examples under TSO and PSO.
The rest of this paper is organized as follows. Section 2intro-
duces the preliminaries. Section 3reviews the SCAR method under
SC.Sections 4extendsthismethodtoWMMs.Section 5enriches
theEOGtoWMMsandpresentsourEOGgenerationmethodwhich
can obtainthe minimal EOG efficiently. Section 6provides theex-
perimentalresults.Section 7reviewstherelatedwork,andSection 8
concludes the paper.
2 PRELIMINARIES
2.1 Multi-Threaded Program
Amulti-threaded program consists of multiple concurrent threads.
It contains a set of variables which are partitioned into shared vari-
ablesandlocalvariables.Eachthreadcanread/writeboththeshared
variables and its local variables. We assume each variable access is
atomic. This paper focuses on programs based on PThreads, one of,QLWLDOO\[ \ 
3 3
[  \ 
U \ V [
Figure 1: A simplified Dekker algorithm.
themostpopularlibrariestowardsmulti-threadedprogramming.
It uses pthread_create(&t, &attrib, &f, &args) to create a
new thread t, and pthread_join(t, &_return) to suspend cur-
rent thread until thread tterminates.
Givenamulti-threadedprogram,wewrite Vforthesetofshared
variables. An eventeis a read/write access to a shared variable.
We useEto denote all events. Each e‚ààEis associated with an
elementvar (e)‚ààVand a literal guard (e), which represent the
accessedvariableandtheguardliteral,respectively.Anevent ecan
be either a read or a write of the shared variable var (e). To express
the execution orders of different events, we associate each event
withauniquenaturalnumber clk (e).clk (e1)<clk (e2)represents
thate1executes before e2.
Theprogram Pdeterminesapartialorder ‚â∫0
P‚äÇE√óE.Intuitively,
e1‚â∫0
Pe2(orwewrite (e1,e2)‚àà‚â∫0
P)indicatesthat‚Äú e1shouldhappen
beforee2according to the program order ofP‚Äù. A read-write link
(e1,e2)representsthat‚Äú e2readsthevaluewrittenby e1‚Äù.Therefore,
var (e1)=var (e2),e1is a write, e2is a read, and the value of e2is
equal to that of e1. In addition, there should be no other ‚Äúwrite‚Äù of
var (e1)happening between them.
2.2 Weak Memory Model
SCisthemostsimpleandcommonlyassumedmemoryconsistency
model. It requires the execution order of those events by the same
thread(wecallit‚Äúintra-threadorder‚Äùinthefollowing)tobecon-
sistent with the program order. Consider the simplified Dekker
mutualexclusionalgorithmshowninFigure 1,whichconsistsof
two threads P1andP2. It contains two shared variables xandy.
Both of them are initialized to 0. Under SC, it requires the write
ofxto execute before the read of yforP1, and the write of yto
executebeforethereadof xforP2.Afterboth P1andP2terminate,
at least one of randsmust be 1.
Under WMMs, to make full use of hardware and compiler-level
optimizations, it allows the intra-thread order to be inconsistent
withtheprogramorder.Thatis,forthoseeventsbythesamethread,
it allows a following event to execute before a previous one. We
usually call this feature the out of order effect of WMMs. The most
widely used Intel x86 and SPARC architectures use the TSO (Total
Store Ordering) model [ 23][28], which relaxes the Write to Read
program order, i.e., a following read can execute before a previous
writetoadifferentaddress.ThePSO(PartialStoreOrdering)model
further relaxes the Write to Write program order, i.e., it further
allows a following write to execute before a previous write to a
different address. The IBM PowerPC model relaxes program order
betweenalloperationstodifferentaddresses[ 21].Thus,afollowing
read or write can execute before a previous read or write to a
646
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. SCAR for Weak Memory Models ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
0XOWL7KUHDGHG
&3URJUDP
$EVWUDFWLRQ
0RGHO
*UDSKEDVHG
(2*9DOLGDWLRQ
&RQVWUDLQWEDVHG
(2*9DOLGDWLRQ
&RQVWUDLQWEDVHG
5HILQHPHQW
*UDSKEDVHG
5HILQHPHQW
>6$7@
&RXQWHUH[DPSOH
>816$7@>,QIHDVLEOH@ >,QIHDVLEOH@
>1RW6XUH@
>)HDVLEOH@
3URRI7UXH
&RXQWHUH[DPSOH$EVWUDFWLRQ5HILQHPHQW&RQVWUDLQW
(UURUVWDWHV
K«Äƒû∆åÕ≤ƒÇ∆â∆â∆å≈Ω«Ü≈ù≈µƒÇ∆ö≈ù≈Ω≈∂Õó
/≈ê≈∂≈Ω∆åƒû∆ö≈öƒû∆êƒê≈öƒûƒö∆µ≈Ø≈ù≈∂≈êƒê≈Ω≈∂∆ê∆ö∆åƒÇ≈ù≈∂∆ö
Figure 2: An overview of the SCAR method [31].
differentaddress.WeinthispapermainlyfocusonTSOandPSO.
Nevertheless, our method can also be applied to other models.
TheoutofordereffectofWMMsplaysacrucialroleinimproving
the program performance. However, programs based on WMMs
mayexhibitmanybehaviorsthatviolatetheprogrammer‚Äôsintuition.
FortheexampleshowninFigure 1,underTSO,thereadof ycan
execute before the write of xforP1, and the read of xcan execute
beforethewrite of yforP2.Hence,randsmaybothbe0 after P1
andP2terminate.
3 THE SCAR METHOD FOR SC
BMC is one of the most applicable techniques to alleviate the path
explosion problem of concurrent programs. Instead of explicitly
enumeratingallthreadinterleavings,itemploysasymbolicrepre-
sentation to encode the verification problem, which is then solved
by a SAT/SMT solver. If a positive answer is given, then a satis-
fying assignment corresponding to a feasible counterexample isacquired. Otherwise, the program is proven safe w.r.t. the given
loop unwinding depth.
In BMC, a multi-threaded program under SC is usually encoded
asamonolithicencoding Œ±sc:=œïinit‚àßœÅ‚àßŒ∂‚àßŒæsc,whereœïinitis
theinitialstates, œÅencodeseachthreadinisolation, Œ∂formulates
that‚Äúeachreadofavariable vmayreadtheresultofanywriteof
v‚Äù, andŒæscformulates the scheduling constraint, which defines the
orderrequirementsamongalleventsoftheprogramunderSC.The
Œæscis constituted of two parts: Œæpo
scandŒærf
sc, whereŒæpo
screquires
that ‚Äúthe intra-thread order should be consistent with the program
order‚Äù, and Œærf
scdefines that ‚Äúfor any read-write link (e1,e2), there
should be no other write of var (e1)between them‚Äù.
A problem for BMC of concurrent programs is that the mono-
lithicencoding Œ±scusuallygeneratesalargeformulawhichover-
whelmsmodernconstraintsolvers.Observingthat Œ±scisusually
dominatedbytheschedulingconstraint Œæsc,w ehav epr oposeda
schedulingconstraintbasedabstractionrefinement(SCAR)method
forverificationofmulti-threadedprogramsunderSC,whichcan
avoid the large formula [ 31]. Figure 2presents the overview of
the method. Given a multi-threaded C program, it first ignoresthe scheduling constraint in the encoding. An over-approximated
abstraction of the original program is then obtained as œÜ0:=
œïinit‚àßœÅ‚àßŒ∂.Itthenaddstheabstraction œÜ0andtheerrorstates
œïerrtotheabstractionmodel.Ifitisunsatisfiable,thentheproperty
is proven safe w.r.t. the given loop unwinding depth. Otherwise,
a counterexample of the abstraction is provided. Given that the
schedulingconstraint Œæscisignoredintheabstraction,thiscoun-
terexample may be infeasible and further validation is required. To
validate the feasibility of an abstraction counterexample, a notion
of event order graph (EOG)is proposed. We have proved that an
abstractioncounterexampleisfeasibleiffthecorrespondingEOG
is feasible. An intuitive method for EOG validation is constraint
solving.IftheEOGisinfeasible,thentheabstractionisrefinedbyex-
ploringtheunsatisfiablecore.However,thismethodisnoteffective
for refinement generation. To obtain an effective refinement, we
devised two graph-based algorithms over EOG for counterexample
validationandrefinementgeneration,inwhichasmallyeteffective
refinement can always be obtained if the EOG is determined to be
infeasible.However,thismethodisnotcomplete.Itcanonlygive
aninfeasibleanswer.Tomaketheoverallmethodbothefficientand
sound,wefirstadoptthegraph-basedEOGvalidationmethod.If
theEOGisdeterminedtobeinfeasible,thegraph-basedrefinement
processisperformedtoobtainaneffectiverefinementconstraint.
Otherwise,weemploytheconstraint-basedvalidationprocessto
further validate the EOG.
Abstraction Counterexample. A counterexample œÄof an ab-
straction œÜi, is a set of assignments to the variables in œÜi‚àßœïerr,
whereœïerristheerrorstates.Itdefinesasetofeventsoccurringin
œÄand theread-write linksfor each readevent. Denote by EœÄ‚äÜE
the set of events occurring in œÄ. A counterexample œÄis said to
befeasibleifaconcreteexecutionoftheoriginalprogramcanbe
constructed from œÄ. Given that the events occurring in a concrete
executionmustsatisfytheorderrequirementsdefinedin Œæpo
scand
Œærf
sc, the crucial issue to validate a counterexample œÄis to find a
total order <œÄoverEœÄs.t.<œÄobeys all the order requirements
defined in scheduling constraint.
647
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang
LQW[ \ P Q 
YRLGWKUYRLGDUJ^
[ \P \[ 
`
YRLGWKUYRLGDUJ^
\ [
Q [
\ 
`
YRLGPDLQ^
SWKUHDGBW WW
SWKUHDGBFUHDWH	WWKU
SWKUHDGBFUHDWH	WWKU
SWKUHDGBMRLQWSWKUHDGBMRLQW
DVVHUWP  		Q  
`LQW[Õ≥ \ P Q 
YRLGWKUYRLGDUJ^
[ \
P \
[ 
`
YRLGWKUYRLGDUJ^
\ [
Q [
\ 
`
YRLGPDLQ^
SWKUHDGBW WW
SWKUHDGBFUHDWH	WWKUSWKUHDGBFUHDWH	WWKU
SWKUHDGBMRLQW
SWKUHDGBMRLQW
DVVHUWP
  		Q  
`
D7KHRULJLQDOSURJUDP E7KH66$VWDWHPHQWVRIWKHSURJUDP
Figure 3: A three thread program [31].
EventOrderGraph. Todefinetheorderrequirementsofacoun-
terexample, two partial orders ‚â∫0œÄand/triangleleftœÄare defined on EœÄ√óEœÄ.
The‚â∫0œÄdenotes the order requirements due to Œæpo
sc. Any order
(e1,e2)‚àà‚â∫0œÄrequirese1to execute before e2. The/triangleleftœÄdenotes the
order requirements due to Œærf
sc. Any order (e1,e2)‚àà/triangleleftœÄrepresents
that (e1,e2)isaread-writelinkin œÄ,whichrequires e1toexecute
beforee2, and there should be no write of var (e1)happening be-
tween them. An order Œª‚àà‚â∫0œÄ(resp.Œª‚àà/triangleleftœÄ) is called a program
order (resp. read-from order) of œÄ.
Aneventordergraph(EOG)isagraphthatcapturesalltheorder
requirements of a counterexample. Given a counterexample œÄ, the
EOGGœÄis a triple/angbracketleftEœÄ,‚â∫0œÄ,/triangleleftœÄ/angbracketright, where the nodes are the events
inEœÄ, and the edges are the orders defined in ‚â∫0œÄand/triangleleftœÄ. Each
nodecorrespondstoeithera‚Äúread‚Äùora‚Äúwrite‚Äùof œÄ,andeachedge
corresponds to either a program order or a read-from order of œÄ.
For each edge corresponding to a program order (e1,e2)‚àà‚â∫0œÄ,i t
requiresthat clk (e1)<clk (e2);andforeachedgecorrespondingtoa
read-fromorder (e1,e2)‚àà/triangleleftœÄ,itrequiresthat clk (e1)<clk (e2),and
for any other write of var (e1)inEœÄ, it requires clk (e3)<clk (e1)
orclk (e2)<clk (e3). A counterexample œÄis feasible iff there exists
atotalorder <œÄoverEœÄs.t.<œÄobeysalltheorderrequirements
defined in GœÄ.
EOGbasedcounterexamplevalidationandrefinementgen-
eration. Any edge (e1,e2)of an EOG GœÄrequires that clk (e1)<
clk (e2).Hence,anEOGmustbeinfeasibleifitcontainssomecycles.
Given that a read-from order (e1,e2)‚àà/triangleleftœÄfurther requires that
no other write of var (e1)could happen between e1ande2, some
derivedorders deduciblefromtheEOGmustexist.Threeruleshave
beenproposedin[ 31]todeduceasmanyderivedordersaspossible
first. If some cycle exists in the result graph, then the EOG must be
infeasible.Ifacounterexampleisdeterminedtobeinfeasible,one
shouldaddsomeconstraintstotheabstraction topreventthiscoun-
terexample from appearing again in the future search. To prune\
P
Q
\
[
\
P
[
P[
\
Q[
Q
\[
UUU
U
U
UKK
Figure 4: An EOG of the program of Figure 3[31].
more search space, the kernel reasons that make the counterex-
ample infeasible are analyzed, and the negations of them are then
added to the next abstraction.
Consider the example presented in [ 31] (We will use it later).
The example is shown in Figure 3, where Figure 3(a) is the original
program,andFigure 3(b)isthestaticsingleassignment(SSA)state-
mentsoftheprogram,inwhichtheprogramvariablesarerenamed
suchthateachvariableisassignedonlyonce.Figure 4isanEOG
ofacounterexample œÄforthisexample.Inthefiguresthatdescribe
EOGs, the white and gray nodes denote ‚Äúwrites‚Äù and ‚Äúreads‚Äù oc-
curring in the corresponding counterexample, respectively. A solid
arrowwithatriangularheadfrom e1toe2representsa programor-
der,whichrequires e1tohappenbefore e2.Adashedarrowfrom e1
toe2representsa read-writelink (e1,e2).Itrequiresthat:1) e1should
happenbefore e2,and2)nowriteof var (e1)shouldhappenbetween
them. A solid arrow with a hollow head from e1toe2represents a
derived order, which is derived from existing order requirements.
Italsorequires e1tohappenbefore e2.Figure4showstwocycles,
including C1:clk (x2)<clk (y3)<clk (y4)<clk (x5)<clk (x2)
andC2:clk (x2)<clk (x4)<clk (y4)<clk (x5)<clk (x2). Hence,
œÄis infeasible. The kernel reasons of these two cycles are then
analyzed to refine the abstraction, which contains only two simple
CNF clauses.
4 THE SCAR METHOD FOR WMMS
ForprogramsunderWMMs,themonolithicencodingcanberep-
resented as Œ±wmm:=œïinit‚àßœÅ‚àßŒ∂‚àßŒæwmm, whereœïinit,œÅ, and
Œ∂are the same as those for SC. The Œæwmm:=Œæpo
wmm‚àßŒærf
wmmfor-
mulates the scheduling constraint under WMMs, which defines
theorderrequirementsamongalleventsofaprogram.Here,the
Œærf
wmmisthesamewith Œærf
sc,whichdefinesthat‚Äúforanyread-write
link (e1,e2), there should be no other write of var (e1)between
them‚Äù. The only difference between the encodings under SC and
648
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. SCAR for Weak Memory Models ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
WMMsison Œæpo
scandŒæpo
wmm,whichcapturetheorderrequirements
due to the program order of SC and WMMs, respectively. Under
SC, the intra-thread order must be consistent with the programorder. But under WMMs, the intra-thread order is relaxed, and a
following event may execute before a previous one. Under SC, the
intra-threadorderisdeterministic,andtheencodingof Œæpo
scislinear
in the number of events. But under WMMs, the intra-thread order
is nondeterministic, and the encoding of Œæpo
wmmis quadratic in the
number of events.
As observed in[ 31],the monolithicencoding Œ±scisdominated
bytheschedulingconstraint Œæsc.Formostexamplesintheirexperi-
ments,Œæscusuallyaccountsformorethan85%oftheencoding.For
programsunderWMMs,themonolithicencodingissamewiththat
under SC, except for Œæpo
wmm, which is much larger than Œæpo
sc. Hence,
the monolithic encoding Œ±wmmis even larger than Œ±sc, and the
scheduling constraint Œæwmmaccounts for a even larger proportion
than that under SC.
Toavoidthelargeformulaof Œæwmm,wewillextendtheSCAR
methodtoWMMs.Theideaisthat,similartotheframeworkshown
inFigure 2,wefirstignoretheschedulingconstraint Œæwmmfrom
the monolithic encoding Œ±wmm, and obtain an over-approximated
abstraction of the original program, œÜ0:=œïinit‚àßœÅ‚àßŒ∂. Here, the
initial abstraction œÜ0is exactly the same as under SC. We then
addtheabstraction œÜ0andtheerrorstates œïerrtotheabstraction
model, which is then solved by a constraint solver. If it is unsatisfi-
able,giventhattheabstractionisstillanover-approximationofthe
originalprogramunderWMMs,thepropertyisprovensafew.r.t.
thegivenloopunwindingdepth.Otherwise,acounterexample œÄ
oftheabstractionisprovided,andfurthervalidationofthecoun-
terexample is required. Given that the abstraction is obtained by
excludingthe schedulingconstraint Œæwmm,the counterexample œÄ
is feasible iff there exists a total order <œÄoverEœÄs.t.<œÄobeys all
the order requirements defined in Œæwmm.
Again, we can employ an EOG GœÄto capture all the order re-
quirementsthattheeventsin œÄmustsatisfy.Ifthereisatotalorder
ofEœÄwhich satisfies all the order requirements defined in GœÄ,
thenœÄisfeasible.TodeterminethefeasibilityofanEOG,wefirst
employthegraph-basedEOGvalidationmethod.Particularly,we
deduceas manyderivedordersas possiblebythe sameruleswith
that under SC. If there exists some cycle in the result EOG, then
we can conclude that no total order of EœÄcan satisfy all the order
requirements.Inthiscase,weanalyzethekernelreasonsleadingto
these cycles, which are then negated to refine the abstraction. The
kernel reason analysis method is exactly the same with that under
SC.Ifnocycleisfound,weemployaconstraintbasedmethodto
further decide the feasibility of the EOG. The method is that weencode all the order requirements of the EOG into a constraintformula, which is then solved by a constraint solver. The EOG is
feasibleiffasatisfiableresultisreturned.Ifanunsatisfiableresultis
obtained,weemploytheunsatisfiablecoretorefinetheabstraction.
The overall framework of the SCAR method can be elegantly
extended to programs under WMMs. Moreover, the methods for
initialabstractiongeneration,EOGvalidation,andkernelreason
analysis etc. are all exactly the same with that under SC. The only
difference is that,given that Œæpo
wmmis different from Œæpo
sc, the EOGand the constraint formula encoding order requirements of the
EOG should be different from that under SC.
5 A UNIFIED EOG FOR BOTH SC AND WMMS
An EOG is used to capture the order requirements that must be
satisfied for those events of a counterexample.Given a counterex-
ampleœÄ,theEOG GœÄisatriple/angbracketleftEœÄ,‚â∫0œÄ,/triangleleftœÄ/angbracketright,wherethenodesare
theeventsin EœÄ,andtheedgesrepresenttheorderrequirements
definedin‚â∫0œÄand/triangleleftœÄ.ForprogramsunderWMMs,the EœÄand/triangleleftœÄ
are exactly the same with that under SC. The only difference is on
‚â∫0œÄ. For ease of presentation, for an EOG, we discuss only ‚â∫0œÄin
the following.
5.1 The EOG for WMMs
The‚â∫0œÄdefinestheorderrequirementsduetotheprogramorder.
UnderSC,itrequirestheintra-threadordertobeconsistentwith
theprogramorder.Accordingtotheprogramorder,theintra-threadorderofanycounterexampleisdeterministic.Itusuallyformsaline
foranythreadofacounterexampleunderSC.Figure 5(a)demon-
strates the‚â∫0œÄunder SC for the counterexample shown in Figure 4.
However, for programs under WMMs, the intra-thread order is
relaxed. The TSO model allows a following read to execute before
a previous write to a different address. Figure 5(b) demonstrates
the‚â∫0œÄunderTSOforthecounterexampleshowninFigure 4.For
thread thr1,giventhat x2isawriteto xandy3isareadto y,w e
havey3can execute before x2and there is no order requirement
betweenx2andy3.However,giventhat y2shouldexecutebefore
y3, andx2should execute before m3, we have the orders (y2,y3)
and (x2,m3). The order requirements for thread thr2are the same
with those of thread thr1.
ThePSOmodelfurtherallowsafollowingwritetoexecutebefore
a previous write to a different address. Figure 5(c) demonstrates
the‚â∫0œÄunderPSOforthesamecounterexample.Forthread thr1,
according to the semantics of PSO, we have m3can execute before
x2,andx3canexecutebefore m3. However, x2mustexecutebefore
x3, andy3must executebefore m3andx3. Moreover,according to
the program, m2should wait until all events in thr1have finished.
TheordersshowninFigure 5(c)obeyalltheserequirements.The
order requirements for thread thr2are the same with those of
thread thr1.
From the above analysis, the ‚â∫0œÄunder WMMs is much more
complexthanthatunderSC.Theintra-threadorderisdeterministic
and can be represented as a line under SC. However, it is nonde-
terministic and needs to be represented by a directed graph under
WMMs. In fact, the ‚â∫0œÄunder SC can be treated as a special case of
the‚â∫0œÄunder WMMs.
5.2 Intuitive EOG Generation Method
Given a counterexample œÄ, to generate the EOG, we should obtain
EœÄ,‚â∫0œÄ, and/triangleleftœÄ. Given that both EœÄand/triangleleftœÄare exactly the same
with that under SC, we introduce the method to generate ‚â∫0œÄhere.
Toobtain‚â∫0œÄ,anintuitivemethodisthat:foreacheventpair (e1,e2)
by the same thread where e2is a following event of e1, we check
whethere1should execute before e2according to the WMM effect.
If it does, then we add the order (e1,e2)to‚â∫0œÄ.
649
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang
[
D7KHXQGHU6& E7KHXQGHU762 F7KH XQGHU362
 åE
 åE
 åEWKU WKU
PDLQWKU WKU
PDLQWKU WKU
PDLQ\
P
Q
\
[
\
P
[
P[
\
Q[
Q
\\
P
Q
\
[
\
P
[
P[
\
Q[
Q
\[
\
P
Q
\
[
\
P
[
P[
\
Q[
Q
\[
Figure 5: The‚â∫0œÄ‚Äôs under SC, TSO and PSO for the counterexample shown in Figure 4.
Given a memory model mmand two events{e1,e2}by the same
thread where e2is a following event of e1, Algorithm 1presents
the procedure MustBefore which determines whether e1should
executebefore e2.Theprocedurereturnstrueif mmisSC,which
representsthatnoprogramorderisrelaxedunderSC.Italsoreturns
true ife1ande2are of the same address, which represents that the
program order is relaxed only on events of different addresses.
Otherwise (which already implies that e1ande2are of different
addresses), for TSO, it returns true if e1is not a write or e2is not a
read; for PSO, it returns true if e1is not a write or e2is neither a
writenoraread.UnderWMMs,afencestatementrequiresthat‚Äúany
eventbefore(resp.after)afencestatementshouldexecutebefore
(resp. after) this statement‚Äù. The semantics of fence statements has
also been considered in the MustBefore procedure. We allow an
eventtobeafencetoo.Accordingtotheprocedure,itwillreturn
true if either e1ore2is a fence.
Input:Amemorymodel mm,andtwoevents{e1,e2}wheree2
is a following event of e1.
Output:Returntrueife1should execute before e2undermm,
falseotherwise.
ifmm=SCthen
returntrue;
end
ifvar (e1)=var (e2)then
returntrue;
endifmm=TSOthen
return¬¨(IsWrite (e1)‚àßIsRead (e2));
endifmm=PSOthen
return¬¨(IsWrite (e1)‚àß(IsRead (e2)‚à®IsWrite (e2)));
end
Algorithm 1: The procedure MustBeforeConsiderthe‚â∫0œÄofthecounterexampleshowninFigure 4under
TSO.AccordingtotheintuitiveEOGgenerationmethod,itwillgen-
eratetenordersforthread thr1,including{(y2,x2),(y2,y3),(y2,m3),
(y2,x3),(x2,m3),(x2,m3),(x2,x3),(y3,m3),(y3,x3),(m3,x3)}.
5.3 Our EOG Generation Method
A problem for the intuitive EOG generation method is that it may
generate many redundant orders in ‚â∫0œÄ.
Definition5.1. Anorder Œª:=(e1,e2)issaidtoberedundantin
‚â∫0œÄifŒªcan be deduced by other edges in ‚â∫0œÄ.
In other words, an order Œª:=(e1,e2)is redundant if there exists
apathfrom e1toe2in‚â∫0œÄ\{Œª}.Fortheaboveexample,theorder
(y2,m3)isredundantbecauseitcanbededucedbytwootherorders
(y2,x2)and (x2,m3).Theexistenceofredundantordersmaysignif-
icantlyincreasetheoverheadofthegraph-basedcounterexample
validationandrefinementgenerationprocesses.Forexample,the
numberofcyclesintheEOGmayincreaseexponentially.However,
mostofthesecyclesmayberedundant,thatis,theirkernelreasons
may be redundant with other cycles.
To address this problem, we have devised a ‚â∫0œÄgeneration algo-
rithm, which can always obtain the minimal ‚â∫0œÄefficiently. This
algorithmissuitableforallmemorymodels,includingSC,TSOand
PSO, etc. Actually, it is a unified algorithm for generating ‚â∫0œÄof
different memory models. Our algorithm is shown in Algorithm 2.
The‚â∫0œÄis initialized to‚àÖ. We first use the EventsExtract function
to obtain EœÄ. We denote by EœÄ,ithe events of thread Pi. Here the
events in EœÄ,iare stored in the program order. To generate the
intra-thread orders of a thread Pi, we add the events in EœÄ,ito
theEOGonebyoneintheprogramorder.Let ejbetheeventsto
be added. Then we check whether we should add an order fromsome of its previous event
ektoejreversely. The method is that
we first use the MustBefore procedure shown in Algorithm 1to
determine whether ekshould execute before ejaccording to the
WMMeffectof mm.Ifitdoes,weemploythe IsRedundant function
to check whether the edge is redundant in current ‚â∫0œÄ. If it cannot
650
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. SCAR for Weak Memory Models ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
be deduced from‚â∫0œÄ, then we add the order Œª:=(ek,ej)to‚â∫0œÄ.
After the intra-thread orders of all threads have been added, we
use theInterThreadOrderGeneration function to add those pro-
gramordersamongdifferentthreads,i.e.,theorderrequirements
due topthread_create‚Äôs andpthread_join‚Äôs. When the algorithm
terminates, we will obtain a minimal ‚â∫0œÄwith no redundant orders.
Input:A counterexample œÄ, and a memory model mm
Output:The program order ‚â∫0œÄ
‚â∫0œÄ:=‚àÖ;
EœÄ:=EventsExtract (œÄ);
foreach thread Pido
// Generate intra-thread orders of Pi;
LetEœÄ,i:=EœÄ(Pi);
forj=0;j<|EœÄ,i|;j++do
Letej:=EœÄ,i[j];
fork=j‚àí1;k>=0;k‚àí‚àído
Letek:=EœÄ,i[k];
ifMustBefore (mm,ek,ej)then
LetŒª:= (ek,ej);
if¬¨IsRedundant (Œª,‚â∫0œÄ)then
‚â∫0œÄ:=‚â∫0œÄ‚à™{Œª};
end
end
end
end
end
‚â∫0œÄ:=‚â∫0œÄ‚à™InterThreadOrderGeneration ();
Algorithm 2: Our‚â∫0œÄgeneration algorithm.
The performance of Algorithm 2significantly depends on the
performance of the IsRedundant function. To improve its perfor-
mance, for each node of the graph, we maintain two bit-vectors
tomarkthepredecessorsandsuccessorsofeachnode.Whenever
a new order is added to ‚â∫0œÄ, the two bit-vectors will be updated
properly. In this manner, an order Œª:=(e1,e2)is redundant in‚â∫0œÄ
iffe1is a predecessor of e2.
We prove that we always obtain a correct and minimal ‚â∫0œÄin
Algorithm 2as follows.
Theorem5.2. Foranyrequiredorderrequirement Œª/nelement‚â∫0œÄ,Œªcould
be deduced from‚â∫0œÄ.
Proof.InAlgorithm 2,ifŒªisrequiredintheEOGbut Œª/nelement‚â∫0œÄ,
thenŒªmust be redundant in ‚â∫0œÄ. According to Definition 5.1,i t
could be deduced from ‚â∫0œÄ. /square
Theorem 5.3. For any order requirement Œª‚àà‚â∫0œÄ,Œªcannot be
deduced from‚â∫0œÄ\{Œª}.
Proof.LetŒª:=(em,en). Suppose that Œªcan be deduced from
‚â∫0œÄ\{Œª}. Then there must exist a path from emtoenin‚â∫0œÄ\{Œª}.
Suppose that the path is em‚Üíe0‚Üí¬∑¬∑¬∑‚Üí ek‚Üíen. Given that
all orders in‚â∫0œÄmust start from a previous event to a following
event,emandallei(0‚â§i‚â§k)shouldbepredecessorsof en.Hence,
Œªshould be redundant in ‚â∫0œÄ, and the IsRedundant function in
Algorithm 2should return true when Œªis considered. Hence, Œªwill not be added to ‚â∫0œÄ, which is contradict with that Œª‚àà‚â∫0œÄ.
Therefore, any order requirement Œª‚àà‚â∫0œÄcannot be deduced from
‚â∫0œÄ\{Œª}. /square
5.4 EOG Encoding
If the graph-based EOG validation process is not sure about the
feasibility of the EOG, we need to further validate its feasibility via
a constraint-based EOG validation process. The method is that we
directlyencodealltheorderrequirementsdefinedintheEOGintoa
constraintformula.TheEOGisfeasibleifftheconstraintformulais
satisfiable. Again, to avoid the encoding of those redundant orders,
onlythoseordersin ‚â∫0œÄshouldbeconsideredintheencoding,such
that the size of the constraint formula can be reduced.
6 EXPERIMENTAL RESULTS
We have implemented our method on top of Yogar-CBMC [ 30],
which has won the gold medals in the ConcurrencySafety category
ofSV-COMP2017and2018.Weusethe1047multi-threadedpro-
gramsofSV-COMP2018[ 25]asourbenchmarks.Ourtoolsupports
all features of C language in the experiments.
6.1 Benchmark of SV-COMP 2018
Theopen-source,representative,andreproduciblebenchmarksof
CompetitiononSoftwareVerification(SV-COMP)havebeenwidely
accepted for program verification. Given that these benchmarks
aredevisedforcomparisonofthosestate-of-the-arttechniquesandtools,asignificantnumberofstudiesonconcurrentprogramverifi-
cationhaveperformedtheirexperimentsonthem.Theconcurrency
benchmarks of SV-COMP 2018 include 1047 examples and cover
most of the publicly available concurrent C programs that are used
for verification. These programs contain hundreds of lines, 4 to
8 threads, complex structure variables with 2-dimensional point-ers, and hundreds or even a thousand read/write accesses. With
thesecomplexfeatures,theseprogramsarechallengingforstate-
of-the-artconcurrencyverification techniques andtools. Though
many studies have been performed on this benchmark, these stud-
ies mainly focus onSC. Existingworkfor WMMsusually performs
their experiments on a small subset of this benchmark [1, 2,14].
6.2 Experimental Setup
Weconduct allofourexperiments usingacomputerwith Intel(R)
Core (TM) i5‚àí4210M CPU 2 .60GHz and 12 GB memory. A 600-
second time limit is observed.
Our experiments are presented in four parts. We first present
the verification results of our method under TSO and PSO. Then
we compare our performance of TSO and PSO with that of SC,
and discuss the overhead due to WMMs. Third, we compare theperformance of our method with a popular verifier CBMC [
5],
whichalsosupportsTSOandPSO.Differentfromourmethod,it
providesanexactencodingoftheschedulingconstraintforprogram
verification. We use CBMC-5.8, the latest version of CBMC, in our
experiments. Lastly, we compare our method with the intuitive
EOGgenerationmethodanddiscusstheimprovementbenefitfrom
our EOG generation method.
The loop unwinding depths for both our method and CBMC are
setasthatof Yogar-CBMC[ 30],whichdynamicallydeterminesthe
651
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang
Table 1: Results under SC, TSO and PSO.
SCTSOPSO
true246237125
false801810922
total104710471047
unwinding depth through syntax analysis. Particularly, the bound
isset to2for programswitharrays, and nifsome oftheprogram‚Äôs
for-loops are upper bounded by a constant n.
6.3 Effectiveness and Efficiency
6.3.1 Verification Results for TSO and PSO. The results of the 1047
examplesunderSCareknowntothepublic,whichinclude246true
examplesand801falseones. However,ther esultsoftheseexamples
underTSOandPSOremaintobeunknown.Giventhattheorder
constraintsofSC,TSOandPSOareinturnweaker,afalseexample
underSC(resp.TSO)is alsofalseunderTSO(resp.PSO), butatrue
example under SC (resp. TSO) may be false under TSO (resp. PSO).
We perform our method on the overall 1047 examples under
SC, TSO, and PSO. TABLE 1presents the number of true and false
results we have obtained under the three memory models. Yogar-
CBMC has won the gold medal of SV-COMP 2017 and 2018, which
can successfully verify all these examples. In our experiments, we
have observed that under SC, the EOGs generated by our EOG
generationmethodareexactlythesamewiththosegeneratedby
theoriginalYogar-CBMC.Hence,ourresultsunderSCcoincide
withthoseof Yogar-CBMC.ForTSOandPSO,ourmethodcanstill
solve all examples under these two memory models. It is observed
fromtheexperimentsthat,underTSO,allthe801falseexamples
underSCarestillfalse,and9trueexamplesfliptofalse.UnderPSO,
allfalseexamplesunderTSOarestillfalse,butthereare112true
examplesbecomingfalse.Fromtheexperimentalresults,itseems
thatallowingthereorderoftwodifferentwritesismorelikelyto
affect the program than allowing the reorder between a write and
a following read.
6.3.2 Performance for TSO and PSO. Given that the behaviors
of a program under WMMs are much more complex than that
under SC, more efforts are usually required in existing work to
verifyaprogramunderWMMs.Toevaluatetheefficiencyofour
method, we compare the performance among SC, TSO and PSO. In
ourexperiments,wehaverespectivelyspent1568,1937,and1930
seconds under SC, TSO and PSO to solve all examples. Meanwhile,
thememorywehaveconsumedunderthethreememorymodelsare
44,43, and45GB,respectively.Fromtheseresults, inourmethod,
thetimeandmemoryitrequiredforWMMsarejustalittlemore
than that under SC.
Figure6furthercomparestheperformanceofthethreememory
modelsforeachexample,whereFigure 6(a)forSCandTSO,and
Figure6(b) for TSO and PSO. In these figures, each point stands
for an example. The x-coordinate of a point denotes the spent
time (s) under one memory model (or for one method), and the
y-coordinatedenotesthatofanothermodel(ormethod).Among
all these examples, there are 451 examples which can be verified
fasterunderTSOthanunderSC,andthereare338exampleswhich
   VHF
VHF

6&762
(a) TSO versus SC

   VHF
VHF

762362
(b) PSO versus TSO
Figure 6: Comparison among SC, TSO and PSO
canbeverifiedfasterunderPSOthanunderTSO.Thereareonly89
(resp.115)exampleswhichrequireshalfmoretimefromSC(resp.
TSO) to TSO (resp. PSO).
Though programs under WMMs have more behaviors, it also
provide a higher probability to obtain a feasible counterexample in
our method.Even forthose trueexamples, due tothe randomness
of counterexample generation, the verification under WMMs may
also performs better than that under SC. Moreover, in the SCAR
method, the core kernel reasons of a cycle is more sensitive to the
read-fromlinkliterals.Hence,ourmethodisinsensitivetothetype
of memory models.
6.3.3 Comparison with CBMC. We further compare the perfor-
mance of our method with that of CBMC, which supports TSO
andPSO.Toverifyprogramsunderthesetwomemorymodels,it
adopts the monolithic encoding which gives an exact encoding to
the scheduling constraint.
In our experiments, under TSO, CBMC ran error for 8 examples,
ran timeoutfor 29 examples,and gave wronganswers for3 exam-
ples(ItturnedafalseexampletotruefromSCtoTSO).Tofinishall
examples,CBMChasspent32605secondsandconsumed128GB
ofmemoryintotal.UnderPSO,CBMCranerror,rantimeoutand
652
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. SCAR for Weak Memory Models ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France

   &%0&
2XU0HWKRGVHF
VHF
(a) TSO

   &%0&
2XU0HWKRGVHF
VHF
(b) PSO
Figure 7: Comparison with CBMC
gave wrong answers for those same examples under TSO. It has
spent 26738 seconds and consumed 117 GB of memory to finish all
examples in total.
Figure7further compares the performance of our method with
thatof CBMC,whereFigure 7(a)isforTSOandFigure 7(b)isfor
PSO. From these two figures, we can see that our method performs
better than CBMC for nearly all examples, no matter under TSO or
underPSO.TheSCARmethodperformsmuchbetterthanCBMC
underSC.ThisadvantagehasbeenbroughtintofullplaytoWMMs
inourmethod.ForCBMC,giventhattheencodingforWMMsis
much larger than that under SC, its performance is worse under
WMMs than that under SC. Hence, the results coincide with our
original expectation.
6.3.4 Comparison with the Intuitive EOG Generation Method. One
of our majorinnovation is on theunified EOG generation method
whichcanalwaysobtaintheminimal ‚â∫0œÄwithnoredundantorders.
Toevaluatetheimprovementbenefitfromthismethod,wecompare
the performance of our method with that of the intuitive EOG
generation method.
UnderTSOandPSO,theintuitiveEOGgenerationmethodcan
solve only 138 and 139 of the 1047 examples, respectively. Actually,
itcannotsolveanyexampleinthe pthread_wmm directory,which
   VHF
2XU0HWKRG
VHF,QWXLWLYH0HWKRG
(a) TSO

   ,QWXLWLYH0HWKRG
2XU0HWKRGVHF
VHF
(b) PSO
Figure 8: Comparison with the intuitive method
contains898examples.Fortheseexamples,therearealargenumber
of shared variable accesses. The intuitive EOG generation method
may generate thousands of orders in ‚â∫0œÄ, which significantly in-
creasestheoverheadofthegraph-basedcounterexamplevalidation
and refinement generation processes. But with our algorithm, the
numberoforderscontainedin ‚â∫0œÄisreducedtoaboutthreehun-
dred.Hence,ourmethodperformsmuchbetterthantheintuitive
EOG generation method on these examples.
Figure8further compares the performance of our method with
thatoftheintuitiveEOGgenerationmethod,whereFigure 8(a)is
forTSOandFigure 8(b)isforPSO.Fromthesetwofigures,forthose
examples which generate relatively fewer redundant orders, the
performance of the intuitive EOG generation method may be com-
parablewithourimprovedmethod.Therearesomeexampleson
whichtheintuitivemethodperformsevenalittlebetter.Thereason
isthatintherefinementgenerationprocess,toreducetheoverhead
ofcycledetection,wehavelimitedthenumberofdetectedcyclesto
400.Obtainingdifferentcyclesmaygeneratedifferentrefinement
constraints,whichwillaffecttheefficiencyoftheverification.How-
ever,forthoseexampleswhichgeneratemanyredundantorders,
our improved method runs much faster than the intuitive EOG
generation method.
653
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang
7 RELATED WORK
Verification of concurrent programs under SC has been extensively
studiedinrecentyears.Themostsuccessfultechniquestoallevi-
ate the path explosion problem include stateless model checking
[2,7,12,18],boundedmodelchecking[ 5,15,19,26],andabstrac-
tionrefinement[ 16,17,20,24],etc.Thegeneralmethodofstateless
modelcheckingistoemploypartialorderreduction(POR)toex-
plore only non-redundant interleavings. There are also some work
which reduces the search space by restricting the schedules of the
program [ 8,29]. Bounded model checking has been considered
anefficienttechniquetoaddresstheinterleavingproblem.InSV-
COMP2017,16outofthe18participantsintheConcurrencySafety
categoryhaveadoptedthistechnique[ 9].However,pureBMCis
not efficient enough. Many existing tools combine this method
with other techniques [ 15,19]. Abstraction refinement is also an
importanttechniqueforconcurrentprogramverification.Mostof
existing work employs predicate abstraction to address the data
space explosion problem, which uses a finite number of predicates
to abstract the program.
For programs under WMMs, given that the path explosion prob-
lemisstillthemainchallenge,mostoftheexistingworkisbasedon
the techniques for SC. Existing work for verifying programs under
WMMs can be divided into two directions. The first direction is to
convert a program under a WMM to another program under SC,
andthenemploythetechniquesandtoolsforSCtoverifytheresult
program. In the work of [ 6], to verify the reachability properties
ofaprogram PunderTSO,itfirstconverts Pintoanewprogram
P/primeunder SC, such that the reachable sets of PandP/primeare the same.
Theworkin[ 4]furtherextendedthisapproachtoPSO,RMOand
PowerPC, etc. Precise conversion usually makes P/primemuch more
complex than P. To improve the verification performance, some
work tried to decrease the complexity of the result program by
fenceinsertion.Ho wever,fenceinsertionmayloosesomeprecision.
To find a better trade-off between precision and efficiency, how to
insertthefencesiscrucial.Theworkof[ 3],[13],and[22]employed
CEGAR,predicateabstractionandstatic analysismethodsrespec-
tively to help insert fences. In the work of [ 27], E. Tomasco et al.
employed shared memory abstraction (SMA) to convert a program
PunderTSOandPSOintoanewprogram P/primeunderSC,whichis
then verified by Lazy-CSeq. Nevertheless, the obtained program P/prime
is usually much more complex than the original program P, which
makes the verification of programs under WMMs much difficult
than that under SC.
AnotherdirectionistoextendthetechniquesofSCtoWMMs.
Themoststudiedapproachistoextendstatelessmodelchecking
to WMMs. Stateless model checking explicitly explores all possi-
ble paths one by one. To alleviate the path explosion problem, it
employs POR to reduce the number of exploredpaths. Hence, the
crucial issue of extending stateless model checking to WMMs is to
extend POR to WMMs. In the work of [ 32], N. Zhang et al. relaxed
the definition of enabled set and proposed a unified framework
whichcanmodelboththeinter-threadandintra-threadnondeter-
minismunderWMMs.Intheworkof[ 1],P.Abdullaetal.proposed
thenotionofchronologicaltraceforWMMs,whichcandistinguish
theequivalentpathsunderWMMs.ThePORisthenextendedto
WMMs based on this trace. There are also some work extendingBMCtoWMMs[ 5,11].Theseworkemploysalogicformulatorepre-
sentthebehaviorofprogramsunderWMMs,whicharethensolved
by a constraint solver. However, encoding the program behavior
directly usually requires a large formula, which overwhelms mod-
ernconstraintsolvers.Inthispaper,weextendtheSCARmethod
to WMMs, which avoids the large monolithic encoding.
8 CONCLUSION
Mostmulti-processorarchitecturesadoptWMMstoimprovethe
performanceofaprogram.Duetothenondeterminismoftheintra-
threadexecutionorder,thebehaviorofaprogramunderWMMs
ismuchmore complexthanthatunderSC. Inthispaper, wehave
enriched the EOG and elegantly extended the SCAR method to
WMMs. To further improve the performance of this method, a uni-
fiedEOGgenerationmethodhasbeendevisedwhichcanalways
obtainthe minimalEOG efficiently.Weimplemented ourmethod
on top of Yogar-CBMC and performed our experiments on the
benchmarks in the ConcurrencySafety category of SV-COMP 2018.
Experimentalresultsshowthatourmethodisnotsensitivetomem-
ory models, and it performs much better than CBMC, one of the
state-of-the-art tools for WMMs.
ACKNOWLEDGMENTS
This work was funded by the National Nature Science Foundation
of China (No. 61690203, No. 61532007); and the National key R&D
program of China (No. 2017YFB1001802).
REFERENCES
[1]Parosh Aziz Abdulla, Stavros Aronis, Mohamed Faouzi Atig, Bengt Jonsson,
CarlLeonardsson,andKonstantinosSagonas.2015. StatelessModelChecking
for TSO and PSO. In International Conference on Tools and Algorithms for the
Construction and Analysis of Systems, TACAS. London, UK, 353‚Äì367. https:
//doi.org/10.1007/978-3-662-46681-0_28
[2]Parosh Aziz Abdulla,Stavros Aronis, Bengt Jonsson, and Konstantinos Sagonas.
2014. Optimal Dynamic Partial Order Reduction. In ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL. San Diego, CA, USA,
373‚Äì384. https://doi.org/10.1145/2535838.2535845
[3]ParoshAzizAbdulla,MohamedFaouziAtig,Yu-FangChen,CarlLeonardsson,
andAhmed Rezine.2012. Counter-Example GuidedFenceInsertion underTSO.
InInternational Conference on Tools and Algorithms for the Construction and
AnalysisofSystems,TACAS.Tallinn,Estonia,204‚Äì219. https://doi.org/10.1007/
978-3-642-28756-5_15
[4]Jade Alglave, Daniel Kroening, Vincent Nimal, and Michael Tautschnig. 2013.
SoftwareVerificationforWeakMemoryviaProgramTransformation.In European
Symposium on Programming, ESOP . Rome, Italy, 512‚Äì532. https://doi.org/10.
1007/978-3-642-37036-6_28
[5]Jade Alglave, Daniel Kroening, and Michael Tautschnig. 2013. Partial Orders
for Efficient Bounded Model Checking of Concurrent Software. In International
ConferenceonComputerAidedVerification,CAV.SaintPetersburg,Russia,141‚Äì157.
https://doi.org/10.1007/978-3-642-39799-8_9
[6]Mohamed Faouzi Atig, Ahmed Bouajjani, and Gennaro Parlato. 2011. Getting
RidofStore-BuffersinTSOAnalysis.In InternationalConferenceonComputer
Aided Verification, CAV . Snowbird, UT, USA, 99‚Äì115. https://doi.org/10.1007/
978-3-642-22110-1_9
[7]Jiri Barnat, Lubos Brim, Vojtech Havel, Jan Havl√≠cek, Jan Kriho, Milan Lenco,
Petr Rockai, Vladim√≠r Still, and Jir√≠ Weiser. 2013. DiVinE 3.0 - An Explicit-State Model Checker for Multithreaded C & C++ Programs. In International
ConferenceonComputerAidedVerification,CAV .SaintPetersburg,Russia,863‚Äì
868.https://doi.org/10.1007/978-3-642-39799-8_60
[8]Tom Bergan, Luis Ceze, and Dan Grossman. 2013. Input-covering schedules for
multithreadedprograms.In ACMSIGPLANInternationalConferenceonObject-
OrientedProgramming,Systems,Languages,andApplications,OOPSLA.Indianapo-
lis, IN, USA, 677‚Äì692. https://doi.org/10.1145/2509136.2509508
[9]Dirk Beyer. 2017. Software Verification with Validation of Results - (Report
on SV-COMP 2017). In International Conference on Tools and Algorithms for
the Construction and Analysis of Systems, TACAS. Uppsala, Sweden, 331‚Äì349.
https://doi.org/10.1007/978-3-662-54580-5_20
654
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. SCAR for Weak Memory Models ASE ‚Äô18, September 3‚Äì7, 2018, Montpellier, France
[10]Armin Biere, Alessandro Cimatti, EdmundM. Clarke, and Yunshan Zhu.1999.
SymbolicModelCheckingwithoutBDDs.In InternationalConferenceonTools
and Algorithms for Construction and Analysis of Systems, TACAS. Amsterdam,
The Netherlands, 193‚Äì207. https://doi.org/10.1007/3-540-49059-0_14
[11]Sebastian Burckhardt, Rajeev Alur, and Milo M. K. Martin. 2007. CheckFence:
CheckingConsistencyofConcurrentDataTypesonRelaxedMemoryModels.InACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
PLDI.SanDiego,California,USA,12‚Äì21. https://doi.org/10.1145/1250734.1250737
[12]KatherineE.Coons,MadanMusuvathi,andKathrynS.McKinley.2013. Bounded
Partial-OrderReduction.In ACMSIGPLANInternationalConferenceonObject-
OrientedProgramming,Systems,Languages,andApplications,OOPSLA.Indianapo-
lis, IN, USA, 833‚Äì848. https://doi.org/10.1145/2509136.2509556
[13]Andrei Marian Dan, Yuri Meshman, Martin T. Vechev, and Eran Yahav. 2013.
Predicate Abstractionfor RelaxedMemory Models.In InternationalSymposium
on Static Analysis, SAS. Seattle, WA, USA, 84‚Äì104. https://doi.org/10.1007/
978-3-642-38856-9_7
[14]Brian Demsky and Patrick Lam. 2015. SATCheck: SAT-Directed Stateless Model
Checking for SCand TSO. In ACM SIGPLAN InternationalConference on Object-
OrientedProgramming,Systems,Languages,andApplications,OOPSLA .Pittsburgh,
PA, USA, 20‚Äì36. https://doi.org/10.1145/2814270.2814297
[15]Henning G√ºnther, Alfons Laarman, and Georg Weissenbacher. 2016. Vienna
Verification Tool: IC3 for Parallel Software - (Competition Contribution). In
International Conference on Tools and Algorithms for Construction and Analysis of
Systems, TACAS. Eindhoven, The Netherlands, 954‚Äì957. https://doi.org/10.1007/
978-3-662-49674-9_69
[16]Ashutosh Gupta, Thomas A. Henzinger, Arjun Radhakrishna, Roopsha Samanta,
andThorsten Tarrach.2015. Succinct Representationof ConcurrentTraceSets.
InACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,
POPL. Mumbai, India, 433‚Äì444. https://doi.org/10.1145/2676726.2677008
[17]Ashutosh Gupta, Corneliu Popeea, and Andrey Rybalchenko. 2011. Predicate
Abstraction and Refinement for Verifying Multi-threaded Programs. In ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL.
Austin, TX, USA, 331‚Äì344. https://doi.org/10.1145/1926385.1926424
[18]Jeff Huang. 2015. Stateless Model Checking Concurrent Programs with Maximal
Causality Reduction. In ACM SIGPLAN Conference on Programming Language
DesignandImplementation,PLDI .Portland,OR,USA,165‚Äì174. https://doi.org/
10.1145/2737924.2737975
[19]OmarInverso,ErmenegildoTomasco,BerndFischer,SalvatoreLaTorre,andGen-
naro Parlato. 2014. Bounded Model Checking of Multi-threaded C Programs via
LazySequentialization.In InternationalConferenceonComputerAidedVerification,
CAV. Vienna, Austria, 585‚Äì602. https://doi.org/10.1007/978-3-319-08867-9_39
[20]Alexander Malkis, Andreas Podelski, and Andrey Rybalchenko. 2010. Thread-
ModularCounterexample-GuidedAbstractionRefinement.In InternationalStatic
Analysis Symposium, SAS. 356‚Äì372. https://doi.org/10.1007/978-3-642-15769-1_
22[21]Cathy May, Ed Silha, Rick Simpson, and Hank Warren. 1994. The PowerPC
architecture:aspecificationforanewfamilyofRISCprocessors. MorganKaufmann
Publishers Inc.
[22]Yuri Meshman, Andrei Marian Dan, Martin T. Vechev, and Eran Yahav. 2014.
Synthesis of Memory Fences via Refinement Propagation. In International Sym-
posiumonStaticAnalysis,SAS.Munich,Germany,237‚Äì252. https://doi.org/10.
1007/978-3-319-10936-7_15
[23]PeterSewell,SusmitSarkar,ScottOwens,FrancescoZappaNardelli,andMag-
nus O. Myreen. 2010. x86-TSO: A Rigorous and Usable Programmer‚Äôs Model for
x86Multiprocessors. Commun.ACM 53,7(2010),89‚Äì97. https://doi.org/10.1145/
1785414.1785443
[24]Nishant Sinha and Chao Wang. 2011. On Interference Abstractions. In ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL.
Austin, TX, USA, 423‚Äì434. https://doi.org/10.1145/1926385.1926433
[25]SV-COMP.2018. 2018softwareverificationcompetition. http://sv-comp.sosy-lab.
org/2018/.
[26]Ermenegildo Tomasco, Omar Inverso, Bernd Fischer, Salvatore La Torre, and
Gennaro Parlato. 2015. Verifying Concurrent Programs by Memory Unwind-
ing. InInternational Conference on Tools and Algorithms for Construction and
Analysis of Systems, TACAS. London, UK, 551‚Äì565. https://doi.org/10.1007/
978-3-662-46681-0_52
[27]ErmenegildoTomasco,TrucL.Nguyen,OmarInverso,BerndFischer,Salvatore
LaTorre,andGennaroParlato.2016. LazySequentializationforTSOandPSO
via Shared Memory Abstractions. In 2016 Formal Methods in Computer-Aided
Design, FMCAD 2016. Mountain View, CA, USA, 193‚Äì200. https://doi.org/10.
1109/FMCAD.2016.7886679
[28]David L. Weaver, Tom Germond, Ghassan Abbas, Published Ptr, and Prentice
Hall. 1992. The SPARC Architecture Manual. Cliffs Nj(1992).
[29]Jingyue Wu, Yang Tang, Gang Hu, Heming Cui, and Junfeng Yang. 2012. Sound
and precise analysis of parallel programs through schedule specialization. In
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation,
PLDI. Beijing, China, 205‚Äì216. https://doi.org/10.1145/2254064.2254090
[30]LiangzeYin,WeiDong,WanweiLiu,YunchouLi,andJiWang.2018. YOGAR-
CBMC:CBMCwithSchedulingConstraintBasedAbstractionRefinement-(Com-
petitionContribution).In InternationalConferenceonToolsandAlgorithmsfor
the Construction and Analysis of Systems, TACAS. Thessaloniki, Greece, 422‚Äì426.
https://doi.org/10.1007/978-3-319-89963-3_25
[31]Liangze Yin, Wei Dong, Wanwei Liu, and Ji Wang. 2017. Scheduling Constraint
BasedAbstractionRefinementforMulti-ThreadedProgramVerification. CoRR
abs/1708.08323 (2017). http://arxiv.org/abs/1708.08323
[32]NalingZhang,MarkusKusano,andChaoWang.2015. DynamicPartialOrder
ReductionforRelaxedMemoryModels.In ACMSIGPLANConferenceonProgram-
mingLanguageDesignandImplementation,PLDI.Portland,OR,USA,250‚Äì259.
https://doi.org/10.1145/2737924.2737956
655
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:51:02 UTC from IEEE Xplore.  Restrictions apply. 