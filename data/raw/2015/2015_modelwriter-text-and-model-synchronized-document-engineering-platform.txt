ModelWriter: Text and Model-Synchronized
Document Engineering Platform
Ferhat Erata∗§, Claire Gardent†, Bikash Gyawali†, Anastasia Shimorina†, Yvan Lussaud/bardbl, Bedir Tekinerdogan∗,
Geylani Kardas¶∗∗, and Anne Monceaux‡
∗Information Technology Group, Wageningen University and Research Centre, The Netherlands
†CNRS, LORIA, UMR 7503 V andoeuvre-les-Nancy, F-54500, Nancy, France
‡System Engineering Platforms, Airbus Group Innovations, Toulouse, France
§UNIT Information Technologies R&D Ltd., Izmir, Turkey
¶Ege University, International Computer Institute, Izmir, Turkey
∗∗KoçSistem Information and Communication Services Inc. Istanbul, Turkey
/bardblOBEO, Nantes, France
Abstract —The ModelWriter platform provides a generic frame-
work for automated traceability analysis. In this paper , we
demonstrate how this framework can be used to trace the
consistency and completeness of technical documents that consistof a set of System Installation Design Principles used by Airbus toensure the correctness of aircraft system installation. We show inparticular , how the platform allows the integration of two types ofreasoning: reasoning about the meaning of text using semanticparsing and description logic theorem proving; and reasoningabout document structure using ﬁrst-order relational logic andﬁnite model ﬁnding for traceability analysis.
https://itea3.org/project/modelwriter .html
I. I NTRODUCTION
Due to the complexity of software systems that command,
control, and monitor safety-critical functions in airborne sys-
tems and the necessity of the compliance with the DO-
178C [1] standard, there is an increased need for sophisticated
and highly automated tools for the analysis of the tracingamong software artifacts (e.g., requirements, architecture mod-
els, source codes and test cases) to keep them synchronizedand consistent during the development process. In this context,
traceability [2] not only establishes and maintains consistency
between these artifacts but also ensures that each requirementis tested, that each line of source code has a purpose for the
fulﬁllment of a requirement, and so forth.
The implementation of traceability is highly contextual as
the certiﬁcation artifacts produced or used along the processdiffer depending on the product or the organization [3]. For
that reason, the ModelWriter platform provides the means forusers to specify which artifacts they want to precisely identify
and monitor and what meaning they want to assign to the
traces between these artifacts.
The considered artifacts represented in our context by trace
locations might be of different levels of granularity, ranging
from a complete document or model to fragments of text or
code. Focusing on documents and text, both the structure andthe content might be used to reason about traceability.
To this end, the ModelWriter platform provides a generic
traceability analysis applicable to text and model artifacts tosynchronize them. Trace locations can be fragments of text,elements of an architectural model, and parts of programcodes. Traces are relations between trace locations. The Mod-
elWriter platform allows axiomatization of these relations and
reasoning about them, i.e. supporting traceability analysis fordifferent types of artifacts.
In this paper, we focus on demonstrating the features of
the ModelWriter platform for traceability analysis applied totechnical documentation. A particular challenge in this usecase is to take into account the meaning of natural language.
We integrate techniques from Natural Language Processing
(NLP) and Automated Reasoning to reason both about the
meaning and about the structure of text. We use techniques
from semantic parsing to assign formal meaning representa-
tions to NL text. We then use techniques from theorem provingand model building to infer traceability relations between
text fragments (here System Installation Design Principles),
to check consistency and to ensure completeness.
II. T
HE AIRBUS SIDP U SECASE
We illustrate the workings of the ModelWriter platform
based on a set of System Installation Design Principles (SIDP)used by Airbus to ensure the correctness of aircraft design. AnSIDP rule is an installation requirement specifying properties
which must be fulﬁlled for the system to be well-formed. In
this usecase, SIDPs are trace locations and we deﬁne ﬁvetypes of trace links between these trace locations, namely
CONT AINS ,REFINES ,CONFLICTS ,EQUALS , and REQUIRES .
In the following, we informally give the meaning of the trace-
types adopted from the work of Goknil et. al. [4]. A formal
semantics is provided in Section III-C.
Ruler1contains Rule r2...r nifr2...r nare parts of the
wholer1(part-whole hierarchy). The contained rule is a sub-
rule of the containing rule. Ruler1reﬁnes another Ruler2if
r1is derived from r2by adding more details to its properties.
The reﬁned rule can be seen as an abstraction of the detailed
rules. In Fig. 1 contains and reﬁnes traces are illustrated. Each
box represents a property of the corresponding rule.
978-1-5386-2684-9/17/$31.00 c/circlecopyrt2017 IEEEASE 2017, Urbana-Champaign, IL, USA
T ool Demonstrations907
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. r1r2
r3contains
containsr4 r5reﬁnes
Fig. 1.r1containsr2andr3,r4reﬁnesr5
Ruler1conﬂicts with Ruler2if the fulﬁllment of r1
excludes the fulﬁllment of r2and vice versa. The existence
of a conﬂict trace indicates an inconsistency between two
rules. Ruler1equals toRuler2ifr1states exactly the same
properties with their constraints with r2and vice versa. Ruler1
requires Rule r2ifr1is fulﬁlled only when r2is fulﬁlled. The
required rule can be seen as a pre-condition for the requiringrule. In the following Fig. 2 conﬂicts, equals and requires
traces are illustrated.
r1 r2conﬂictsr1 r2equals
r1 r2requires
Fig. 2. Illustration of “conﬂicts, equals and requires”
Given a set of SIDPs, the ModelWriter platform can be
used to check completeness and consistency as follows. First,the SIDPs are parsed and assigned Description Logic (DL)
formulae representing their meaning (cf. Section III-A). Sec-
ond, traces are either manually speciﬁed by the end user or
inferred using semantic parsing and DL theorem proving (cf.
Section III-B). Third, new trace links can be inferred fromexisting ones using Relational Logic (RL) (cf. Section III-C)
and Model Finding (cf. Section III-D). Importantly, the in-
ference of trace links allows for the detection of missing orinconsistent SIDPs.
Table I illustrates this process. Given the SIDPs r
1-r6,
CONFLICTS and REFINES trace links are ﬁrst inferred using
semantic parsing and the Hermit theorem prover [5] (DL linesin the table).
TABLE I
EXAMPLE SIDP S AND INFERENCE OF TRACE LINKS
Nr. Artifact Annotations (Trace-locations)
r1 Bracket shall be used in hydraulic area Alpha
r2 Adhesive bonded bracket shall be used in hydraulic area
r3 Adhesive bonded bracket shall be used in hydraulic area Alpha
r4 Bracket shall be used in hydraulic area
r5 Bracket shall be installed in hydraulic area
r6 Bracket shall be installed in fuel tank
Nr. Inferred Traces Nr. Inferred Traces
DL 1conflicts (r5,r6) RL 1conflicts (r6,r4)
DL 2refines (r3,r2) RL 2requires(r 1,r5)
DL 3refines (r2,r4) RL 3conflicts (r6,r1)
DL 4refines (r1,r4) RL 4requires(r 2,r5)
DL 5requires(r 4,r5) RL 5conflicts (r2,r6)
For example, the DL formulae obtained by parsing sen-
tencesr5andr6conﬂict with each other because the un-
derlying ontology to which these axioms are added speciﬁesthat concepts “hydraulic area” and “fuel tank” are disjoint.Similarly, the axiom obtained for the sentence r
2reﬁnes the
axiom obtained for r4because the ontology speciﬁes that
“Bracket” is a sub concept of “Adhesive bonded bracket”. In
Fig. 3, Table I is represented as a digraph model in whichthe nodes represent trace-locations, i.e. SIDP rules listed inthe table, and edges represents traces. A red edge speciﬁcally
corresponds to the trace inferred using semantic parsing and
DL theorem proving. The black one is an example trace,refines(r
3,r6)created by the user manually.
r2 r2 r2
r4 r1 r5 r3
r6refinesrefines
refines
requires
refinesconflictsconflictsrequiresconflictsrequires
conflicts
Fig. 3. Inferred Traces (red traces indicate reasoning using DL, blue indicates
reasoning using RL, the black one indicates a manual trace)
Later, additional trace links are inferred using Relational
Model Finding (RL lines in the Table I and dashed blue edges
on Fig. 3). For instance, as part of the trace semantics ofthis use case, according to the axiom schema (3) formalized
in Section III-C where a,band care artifact elements, if a
reﬁnes, requires orcontains b, while b conﬂicts with c, then a
also conﬂicts with c. In this way, ModelWriter generates
CON -
FLICTS traces such that combination of conflicts (r5,r6)and
requires (r4,r5)makesconflicts (r6,r4); on the other hand,
according to axiom schema (1) described in Section III-C, the
combination of refines(r2,r4)andrequires (r4,r5)gener-
atesrequires (r2,r5)corresponding to the patterns shown in
Fig. 4.
a b
ca b
crefinesrequiresrequiresconflicts
requires conflicts
Fig. 4. Inferring “requires " with “reﬁnes " and inferring “conﬂicts"
Finally, in this example, DL-based reasoning process in-
ferred only one CONFLICTS trace using the meaning of the
sentences, i.e. r5conﬂicts with r6whereas the ModelWriter de-
tects three more conﬂicts traces using the meaning of trace
types by means of RL-based reasoning on top of DL-based
reasoning. As a result, it can be seen that not only r5andr6
but alsor4,r1, andr2are inconsistent.
908
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. III. O VERVIEW OF THE APPROACH
We now describe the four main modules making up the
ModelWriter platform. Section III-A introduces the semantic
parser, i.e., the module that converts text to Description Logic
formulae. Section III-B explains how the Hermit reasoner canbe used to detect
REFINES ,CONFLICTS and EQUALS trace
links between text fragments (here, SIDPs). Section III-Cshows how Alloy formalism [6] can be customized to axioma-tize trace types and semantics. Finally, Section III-D explains
how the KodKod model ﬁnder [7] is used to infer new trace
links between SIDPs to detect the inconsistent SIDPs.
A. Mapping Text to Description Logic F ormulae
The semantic parser used in ModelWriter to convert text to
DL formulae is described in details in [8]. In what follows,
we brieﬂy summarize its working and some evaluation results
on a set of 960 SIDPs used for testing.
The ModelWriter semantic processing framework combines
an automatically derived lexicon, a small hand-written gram-
mar, a parsing algorithm to convert text to DL formulae
and a generation algorithm to convert DL formulae to text.
This framework is modular and robust. It is modular in that,
different lexicons or grammars may be plugged to meet therequirements of the semantic application being considered. For
instance, the lexicon (which relates words and concepts) couldbe built using a concept extraction tool, i.e. a text mining tool
that extracts concepts from text (e.g., [9]). And the grammar
could be replaced by a grammar describing the syntax of other
document styles such as cooking recipes. It is robust in that,
in the presence of unknown words, the parser can skip wordsand deliver a connected (partial) parse. Fig. 5 outlines our
approach showing the interaction of various components. The
generation algorithm can be used to automatically synchronizedocuments with models (e.g., by generating a text verbalising
the meaning of a DL constraint added to the model). It is
also used to verify the quality of the DL formules derived byparsing: given a sentence S and the DL formula φderived for
S by the parser, are the sentences S
/primethat can be generated
fromφsimilar to S?
Input
SIDPsSemantic Parser
Grammar (Manual)
Lexicon (Automatic)OWL Axioms
Surface RealiserGenerated
SIDPsBLEU
ScoringFull/Partial
Parse
Syntax
Validation
Fig. 5. Parsing and Generation of Airbus SIDPs.
The lexicon maps verbs and noun phrases to grammar rules
and to complex and simple concepts respectively. Fig. 6 showsan illustrative example with a lexical entry on the left andthe corresponding grammar unit on the right. During genera-
tion/parsing, the semantic literals listed in the lexicon (here,
Use anduseArg2inv ) are used to instantiate the variables (here,A2and Rel) in the semantic schema (here, L0:subset(X,L 1)
L2:exists(A2,L 3)L 3:Rel(Y) ). Similarly, the Anchor value
(used ) is used to label the terminal node marked with the
anchor sign (/diamondmath) and each coanchor is used to label the terminal
node with corresponding name. Thus, the strings shall and
bewill be used to label the terminal nodes V1andV2
respectively.
Semantics:
Rel = Use
A2 = useArg2inv
Tree: nx0VAnchor: used
Coanchor: V1 →shall/V
Coanchor: V2 →be/VS
NP↓
XVP
VVL1
L2V
/diamondmathV1/diamondmathV2/diamondmath
L0:subset(X,L 1)
L2:exists(A2,L 3)
L3:Rel(Y)
Fig. 6. Example Lexical Entry and Grammar Unit
The grammar provides a declarative speciﬁcation of how
text relates to meaning (as represented by OWL DL [10]
formulae). We use a Feature-Based Lexicalised Tree Adjoining
Grammar (FB-LTAG) [11] augmented with a uniﬁcation-based
ﬂat semantics. Fig. 7 shows an example FB-LTAG for the
words “not", “pipes" and “shall be used". An FB-LTAG
tree is a set of initial and auxiliary trees which have beenlexicalised using the lexicon and can be combined using eithersubstitution or adjunction. Auxiliary trees are trees such as
the tree for “not" which contains a foot node (marked with
*) whose category (here AUX) matches that of the root node.
Initial trees are trees such as that of “pipes" and “shall be used"
whose terminal nodes may be substitution nodes (marked with
↓). Substitution inserts a tree with root category Cinto a
substitution node of the same category. For instance, the tree
for “pipes" may be substituted in the NP
Y
↓node of the “shall
be used" tree. Adjunction inserts an auxiliary tree with foot
node category Cinto a tree at a node of category C.F o r
instance, the tree for “not" may be adjoined into the tree for
“shall be used" at the AUX node.
NPL6
Pipes
L6:Pipe(X)S
NP↓YVP
AUX AUXL1
L2V
shall be used
L0:subset(Y,L 1)
L2:exists(useArg2inv,L 3)
L3:Use(Z)
AUXL4
ADV AUX∗
L5
not
L4:not(L 5)
Fig. 7. Example FB-LTAG with Uniﬁcation-Based Semantics. The variables
decorating the tree nodes (e.g., X) abbreviate feature structures of the form
[idx :X]whereXis a uniﬁcation variable.
The parser and the generator exploit the grammar and
the lexicon to map natural language to OWL DL formulae
(semantic parsing) and OWL DL formulae to natural language
909
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. (generation) respectively. For instance, given the sentence
“Pipes shall not be used", the parser will ﬁrst select the
grammar trees associated with “Pipes", “shall be used" and
“not" and then combines these trees using substitution and
adjunction. As shown in Fig. 8, the semantics derived for the
input sentence is then the union of the semantics of these trees
modulo uniﬁcation. Conversely, given the ﬂat semantics shown
in the ﬁgure the generator will generate the sentence “Pipesshall not be used", by ﬁrst selecting grammar trees whose
semantics subsumes the input and then combining them using
substitution and operation. The generated sentences are givenby the yield of the derived trees whose root is of category S
(sentence) and whose semantics is exactly the input semantics.
S
NP VP
AUX AUX V
ADV AUX
Pipes shall not be used
L6:Pipe(X) L 0:subset(L 6,L4)L4:not(L 5)
L5:exists(useArg2inv,L 3)L3:Use(Z)
Pipe/subsetsqequal¬ ∃useArg2−.(Use)
Fig. 8. Derived Tree. The ﬂat semantics representation produced by the
grammar is equivalent to the Description Logic Formula shown.
While the grammar integrates a so-called ﬂat semantics, as
shown in Fig. 9, there is a direct translation from this semantics
to OWL functional syntax. Further details about SemanticParser can be found at:
https://modelwriter .github.io/semanticparser
B. Inferring Traces using DL Theorem Proving
We use Hermit theorem prover to detect inconsistencies,
entailment and equivalence between two SIDPs s1ands2.
Given the DL formulae φ1andφ2associated by the semantic
parsing process to s1ands2, we determine these relations as
follows: (i) if φ1/intersectionsqφ2is not satisﬁable, we infer a CONFLICTS
trace between s1ands2, (ii) if¬φ1/unionsqφ2is satisﬁable, we infer
aREQUIRES trace between s1ands2, and (iii) if φ1≡φ2is
satisﬁable, we infer an EQUALS trace between s1ands2.
C. F ormal Semantics of Trace-types
Tarski is the module of ModelWriter for automated rea-
soning about traces based on conﬁgurable trace semantics,recently described in [12] and demonstrated in [13]. The tool
provides an enhanced text editor to allow users to deﬁne new
trace types in a restricted form of Alloy [6] to express complexconstraints among traces.
In the following, we axiomatize trace semantics based on the
informal deﬁnition explained in Section II using First-order
Predicate Logic (FOL) with the signature:
ΣT:{=,∈}∪Σ1
T∪Σ2T
Σ1
T:{Artifact,Requirement,Specification }
Σ2
T:{requires,refines,contains,equals,conflicts}Σ1
Tis the set of unary predicate symbols and Σ2Tis the set
of binary predicate symbols. For simplicity, we assume that the
universe only consists of the type, Artifact which is partitioned
into disjoint subsets of Requirement and Speciﬁcation. From
now on, Arepresents the set of Artifacts. The symbols =
and∈are interpreted and represent equality and membership
respectively. In the following, several axiom schemas are listedto formalize Traceability Theory, that is used in the SIDP case.
Reasoning about
REQUIRES traces is stated as follows:
/turnstileleft∀a,b,c∈A|(a,b)∈/square∧(b,c)∈/triangle→(a,c )∈/triangle (1)
/turnstileleft∀a,b,c∈A|(a,b)∈/triangle∧(b,c)∈/square→(a,c)∈/triangle (2)
where /square∈{requires, reﬁnes,contains} and/triangle:= requires
The following axiom schema is being used for generating
CONFLICTS traces.
/turnstileleft∀a,b,c∈A|(a,b)∈/square∧(b,c)∈/triangle→(a,c)∈/triangle (3)
/turnstileleft∀a,b∈A|(a,b)∈/triangle→(b,a )∈/triangle (4)
where /square∈{requires,reﬁnes,contains} and/triangle:= conﬂicts
Reasoning about EQUALS traces:
/turnstileleft∀a,b,c∈A|(a,b)∈equals∧(b,c)∈/square→(a,c)∈/square (5)
/turnstileleft∀a,b,c∈A|(a,b)∈equals∧(c,b)∈/square→(c,a)∈/square (6)
/turnstileleft∀a∈A|(a,a)∈equals (7)
where /square∈{contains,requires, reﬁnes,conﬂicts}
In the following axiom schema, transitivity (8) is used
for reasoning new traces, whereas anti-symmetry (9) and
irreﬂexivity (10) are used to check consistency.
/turnstileleft∀a,b,c∈A|(a,b)∈/square∧(b,c)∈/square→(a,c)∈/square, (8)
/turnstileleft∀a,b∈A|(a,b)∈/square∧(b,a)∈/square→a=b, (9)
/turnstileleft∀a∈A|(a,a)/∈/square, (10)
where /square∈{contains, requires, reﬁnes}
CONTAINS traces is left-unique (injective relation) in some
scenarios that induces an inconsistency when transitivity ax-iom (8) for
CONTAINS is instantiated in the speciﬁcation.
/turnstileleft∀a,a/prime,b∈A|(a,b)∈/square∧(a/prime,b)∈/square→a=a/prime(11)
where /square:= contains
We encode above axioms in First-order Relational Logic
using the Tarski’s text editor to conﬁgure the Tarski module.
D. Inferring Trace Links using Model Finding
We employ Kodkod [7], [14], an efﬁcient SA T-based con-
straint solver for FOL with relational algebra and partial
models, for automated trace reasoning using the trace seman-
tics that user provides. Once the user performs reasoningoperations about traces, the result is reported back to the user
by dashed traces as shown in Fig. 10. If there exists different
solutions, the user can traverse them back and forth. He can
also accept the inferred traces, and perform another analysis
operation including inferred traces. Further details about Tarskican be found at:
https://modelwriter .github.io/T arski/
910
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. τ(φ)=⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩ObjectSomeV aluesFrom (:Rτ(C)) ifφ=l
i:exists(R,l j)lj:C
SubClassOf (τ(C1)τ(C2)) ifφ=li:subset(lj,lk)lj:C1lk:C2
ObjectIntersectionOf(τ (C1)τ(C2)) ifφ=li:and(lj,lk)lj:C1lk:C2
(τ(C1)/intersectionsqτ(C2)) ifφ=li:and(lj,lk)lj:C1lk:C2
(τ(C1)/unionsqτ(C2)) ifφ=li:or(lj,lk)lj:C1lk:C2
not(τ(C)) ifφ=li:not(lj)lj:C
R−ifφ=Rinv
Ci f φ=li:C(x)
Fig. 9. Mapping Flat Semantics to Owl Functional Syntax
Fig. 10. Inferred Relations based on the current snapshot
IV . E V ALUA TION
We evaluate the Semantic Parsing approach of Model-
Writer on a dataset of 960 SIDPs provided by Airbus which
demonstrates (i) that the approach is robust (97.50% of the
SIDPs can be parsed) and (ii) that DL axioms assigned to full
parses are likely to be correct1. Regarding inference phase,
since we observed that DL-based reasoning is relatively faster
than SA T -based reasoning in the context of SIDPs, we only
focus on the Tarski module to evaluate the performance ofModelWriter approach. Table II shows the solving results of
three conﬁgurations of the formal trace speciﬁcation running
with Alloy Analyzer [6], KodKod [7] and Z3 [15]. The Minisat
[16] SA T Solver is chosen for both Alloy (alloy4.2-2015-02-22.jar) and KodKod (Kodkod 2.1) solvers. From Alloy
to SMT solver translation for these cases, we employ the
translation method proposed by El Ghazi et.al. [17] and the
problems are encoded in SMT -LIB [18] syntax which is fedinto Z3 solver. Transitive closure and integer arithmetic are not
used in these use cases to fairly benchmark the results with
the SMT solver. In SMT -LIB, the logic is set for EqualityLogic with Uninterpreted Functions (UF). Evaluation results
1A parse for a sentence S deriving a DL formulae φfor S is likely to be
correct if at least one of the sentences regenerated from φis highly similar
to the input sentence S.are obtained on a machine, that runs 64 bit Debian linux
operating system with 8 GB of memory and 2.90GHz Intel
i7-3520M CPU. Solving times are indicated in milliseconds.
The best results are obtained by the direct use of KodKod
API since to ﬁnd satisﬁable models, KodKod allows us to
conﬁgure lower and upper bounds for the solution spaceemploying different pre-processing techniques such as slicing,
incremental upper bounds and unrolling transitivity constraints.
The evaluation shows that our tool is practical and beneﬁcial
in industrial settings to specify trace semantics for automatedtrace reasoning. We plan to conduct more case studies to better
evaluate the practical utility and usability of the platform.
T ABLE II
COMP ARISONS OF SEVERAL USE CASES FOR TRACE INFERRING
Artifacts Traces Inferred Alloy KodKod Z3
#1 123 102 89 67922 25668 40900
#2 56 27 25 4428 84 480
#3 42 103 75 724 1 1460
V. R ELA TED WORK
Many existing works on semantic parsing describe the task
of obtaining axiomatic representation of natural langauge sen-
tences. However, they suffer from two main limitations: (i) use
of controlled languages such as Attempto Controlled English[19] (e.g. [20], [21]) and/or (ii) inability to deduce complex
axioms involving logical connectives, role restrictions and
other expressive features of OWL (e.g. [22], [23]), as noted in[24]. In contrast, we work on human authored real-world text
(Airbus SIDPs) and produce complex OWL axioms involving
the following DL constructs: /latticetop(the most general concept),
disjunction, conjunction, negation, role inverse, universal andexistential restrictions. Moreover, we extended the scope ofour application by deducing traces among the semantic parse
outputs. Such traces were then used as baseline input to
Tarski platform which could infer additional traces propagating
over the whole system.
Similarly, several approaches and tools have been proposed
for automated trace reasoning using the trace semantics [4],
[25]–[31]. These approaches employ a predeﬁned set of trace
types and their corresponding semantics. For instance, Goknil
et al. [4] provide a tool for inferencing and consistencychecking of traces between requirements using a set of trace
types and their formal semantics. Similarly, Egyed and Grün-
bacher [26] propose a trace generation approach. They do
911
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. not allow the user to introduce new trace types and their
semantics for automated reasoning. In the development ofcomplex systems, it is required to enable the adoption of
various trace types, and herewith automated reasoning using
their semantics. Tarski module of ModelWriter allows the userto interactively deﬁne new trace types with their semantics to
be used in automated reasoning about traces.
VI. C
ONCLUSION
We presented an integrated platform for automatically map-
ping natural language text to trace types and performing
further inference on those traces. Starting with the semanticparser module, we showed how complex axioms could be
derived to represent text coming from real world use cases.
We identiﬁed the traces among the parse outputs and fed it
to the Tarski tool. The Tarski tool, in turn, allowed usersto specify conﬁgurable trace semantics for various forms of
automated trace reasoning such as inference and consistency
checking. The key characteristics of our tool are (1) automatic
identiﬁcation of traces existing in text using semantic parsing
(2) allowing user to deﬁne new trace types and their semantics
which can be later conﬁgured, (3) deducing new traces based
on the traces which the user has already speciﬁed, and (4)identifying traces whose existence causes a contradiction.
A
CKNOWLEDGMENT
This work is conducted within ModelWriter project [32]
and partially supported by the Scientiﬁc and Technologi-
cal Research Council of Turkey under project #9140014,
#9150181 and Industry and Digital Affairs of France undercontract #142930204. The authors would like to acknowledge
networking support by European Cooperation in Science and
Technology Action IC1404 "Multi-Paradigm Modelling for
Cyber-Physical Systems".
R
EFERENCES
[1] RTCA and EUROCAE, “DO-178C: Software considerations in airborne
systems and equipment certiﬁcation,” 2017.
[2] I. C. Society, P . Bourque, and R. E. Fairley, Guide to the Software
Engineering Body of Knowledge (SWEBOK(R)): V ersion 3.0 , 3rd ed.
Los Alamitos, CA, USA: IEEE Computer Society Press, 2014.
[3] S. Maro, A. Anjorin, R. Wohlrab, and J. P . Steghöfer, “Traceability
maintenance: Factors and guidelines,” in 31st IEEE/ACM International
Conference on Automated Software Engineering , 2016, pp. 414–425.
[4] A. Goknil, I. Kurtev, K. van den Berg, and J.-W . V eldhuis, “Semantics
of trace relations in requirements models for consistency checking and
inferencing,” Software and System Modeling , vol. 10, no. 1, pp. 31–54,
2011.
[5] R. Shearer, B. Motik, and I. Horrocks, “Hermit: A highly-efﬁcient owl
reasoner.” in 5th OWL Experienced and Directions Workshop, vol. 432,
2008, p. 91.
[6] D. Jackson, Software Abstractions: Lo gic, Language, and Analysis . MIT
press, 2012.
[7] E. Torlak, “A constraint solver for software engineering: Finding models
and cores of large relational speciﬁcations,” Ph.D. dissertation, Mas-
sachusetts Institute of Technology, 2008.
[8] B. Gyawali, A. Shimorina, C. Gardent, S. Cruz-Lara, and M. Mahfoudh,
“Mapping natural language to description logic,” in The Semantic Web:
14th International Conference, ESWC 2017 , 2017, pp. 273–288.
[9] E. Bozsak, M. Ehrig, S. Handschuh, A. Hotho, A. Maedche, B. Motik,
D. Oberle, C. Schmitz, S. Staab, L. Stojanovic et al., “KAON – towards
a large scale Semantic Web,” in E-Commerce and Web Technologies.
Springer, 2002, pp. 304–313.[10] D. L. McGuinness, F. V an Harmelen et al., “OWL web ontology
language overview,” W3C recommendation, vol. 10, no. 10, p. 2004,
2004.
[11] C. Gardent and L. Kallmeyer, “Semantic construction in feature-based
T AG,” in Proceedings of EACL. Association for Computational
Linguistics, 2003, pp. 123–130.
[12] F. Erata, M. Challenger, B. Tekinerdogan, A. Monceaux, E. Tüzün, and
G. Kardas, “Tarski: A platform for automated analysis of dynamicallyconﬁgurable traceability semantics,” in the 32nd ACM SIGAPP Sympo-
sium on Applied Computing (SAC’17) , 2017, pp. 1607–1614.
[13] F. Erata, A. Goknil, B. Tekinerdogan, and G. Kardas, “A tool for auto-
mated reasoning about traces based on conﬁgurable formal semantics,”
in11th Joint Meeting of the European Software Engineering Conference
and the ACM SIGSOFT Symposium on the F oundations of Software
Engineering (ESEC/FSE 2017) , 2017, pp. 959–963.
[14] E. Torlak and D. Jackson, “Kodkod: A relational model ﬁnder,” in
the 13th International Conference on Tools and Algorithms for the
Construction and Analysis of Systems (TACAS’07), 2007, pp. 632–647.
[15] L. D. Moura and N. Bjørner, “Z3: An efﬁcient smt solver,” in Inter-
national conference on Tools and Algorithms for the Construction and
Analysis of Systems (TACAS’08), 2008, pp. 337–340.
[16] N. Eén and N. Sörensson, “An extensible sat-solver,” in the 6th Interna-
tional Conference on Theory and Applications of Satisﬁability Testing
(SAT’03), 2003, pp. 502–518.
[17] A. A. E. Ghazi and M. Taghdiri, “Relational reasoning via smt solving,”
inthe 17th International Conference on F ormal Methods (FM’11) , 2011,
pp. 133–148.
[18] C. Barrett, A. Stump, C. Tinelli et al., “The smt-lib standard: V ersion
2.0,” in the 8th International Workshop on Satisﬁability Modulo Theories ,
vol. 13, 2010, p. 14.
[19] K. Kaljurand and N. E. Fuchs, “V erbalizing OWL in Attempto Con-
trolled English,” in OWLED , vol. 258, 2007.
[20] 
V . Tablan, T. Polajnar, H. Cunningham, and K. Bontcheva, “User-
friendly ontology authoring using a controlled language,” in Proceedings
of LREC, 2006.
[21] A. Bernstein, E. Kaufmann, A. Göhring, and C. Kiefer, “Querying
ontologies: A controlled english interface for end-users,” in International
Semantic Web Conference. Springer, 2005, pp. 112–126.
[22] P . Buitelaar, P . Cimiano, and B. Magnini, Ontology learning from text:
methods, evaluation and applications. IOS press, 2005, vol. 123.
[23] M. Ruiz-Casado, E. Alfonseca, and P . Castells, “Automatic Extraction
of Semantic Relationships for Wordnet by Means of Pattern Learning
from Wikipedia,” in International Conference on Application of Natural
Language to Information Systems . Springer, 2005, pp. 67–79.
[24] J. Völker, P . Hitzler, and P . Cimiano, “Acquisition of OWL DL ax-
ioms from lexical resources,” in European Semantic Web Conference.
Springer, 2007, pp. 670–685.
[25] N. Aizenbud-Reshef, R. F. Paige, J. Rubin, Y . Shaham-Gafni, and
D. S. Kolovos, “Operational semantics for traceability,” in ECMDA
Traceability Workshop (ECMDA-TW’05) , 2005, pp. 8–14.
[26] A. Egyed and P . Grünbacher, “Supporting software understanding with
automated requirements traceability,” International Journal of Software
Engineering and Knowledge Engineering , vol. 15, no. 5, pp. 783–810,
2005.
[27] A. Egyed, “A scenario-driven approach to trace dependency analysis,”
IEEE Transactions on Software Engineering , vol. 29, no. 2, pp. 116–132,
2003.
[28] J. Cleland-Huang, C. K. Chang, and M. J. Christensen, “Event-based
traceability for managing evolutionary change,” IEEE Transactions on
Software Engineering , vol. 29, no. 9, pp. 796–810, 2003.
[29] L. C. Lamb, W . Jirapanthong, and A. Zisman, “Formalizing traceability
relations for product lines,” in the 6th International Workshop on
Traceability in Emerging F orms of Software Engineering (TEFSE’11) ,
2011, pp. 42–45.
[30] A. Goknil, I. Kurtev, and K. V . D. Berg, “Generation and validation
of traces between requirements and architecture based on formal trace
semantics,” Journal of Systems and Software, vol. 88, pp. 112–137, 2014.
[31] N. Drivalos, D. S. Kolovos, R. F. Paige, and K. J. Fernandes, “Engineer-
ing a dsl for software traceability,” in 1st International Conference on
Software Language Engineering (SLE’08) , 2008, pp. 151–167.
[32] F. Erata, “ModelWriter: Text & model synchronized document engineer-
ing platform,” https://itea3.org/project/modelwriter.html, Sep 2014.
912
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:58 UTC from IEEE Xplore.  Restrictions apply. 