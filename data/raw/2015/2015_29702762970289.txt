AnModeler: A Tool for Generating Domain Models from
Textual SpeciÔ¨Åcations
Jitendra Singh Thakur
Indian Institute of Information Technology
Design and Manufacturing, Jabalpur, India
jsthakur@iiitdmj.ac.in,
Jabalpur Engineering College, Jabalpur, India
jsthakur@jecjabalpur.ac.inAtul Gupta
Indian Institute of Information Technology
Design and Manufacturing
Jabalpur, India
atul@iiitdmj.ac.in
ABSTRACT
This paper presents AnModeler , a tool for generating analysis
models from software requirements specied using use cases.
The tool uses the Stanford natural language parser to extract
type dependencies (TDs) and parts of speech tags (POS-tags)
of sentences from input Use Case Specication (UCS). Then,
it identies sentence structures using a set of rules framed
based on Hornby's verb patterns. With the information of
the TDs, POS tags, and the identied sentence structures,
the tool discovers domain elements, viz.: domain objects
(including their attributes and operations) and interactions
between them; it consolidates the domain information as a
class diagram (as well as a sequence diagram). An experi-
ment conducted on 10 UCSs with two industry experts as
subjects showed that the analysis class diagrams generated
byAnModeler were remarkably close to those generated by
the two industry experts. Being lightweight and easy to use,
the tool can also be used to assist students and young de-
velopers in acquiring object-oriented domain modeling skills
quickly.
Link to a short demonstration video:
https://youtu.be/ Ct-qF4Y1fU
CCS Concepts
Software and its engineering !Model-driven soft-
ware engineering; Requirements analysis; Object ori-
ented development;
Keywords
Automated tool for analysis modeling; Model transformation;
Analysis class diagram; Problem level sequence diagram;
Template code; Automated approach
1. INTRODUCTION
Software requirements are normally written in Natural Lan-
guage (NL) to ensure easy communication between dierentstakeholders [1]. Typically, the rst step in the model driven
development of software is to obtain analysis models [3] (i.e.,
Platform Independent Models (PIM) [8]) by identifying do-
main objects (including their attributes and operations) and
the relationships between these objects from software re-
quirements. This process generally requires manual analysis
of typically several hundred pages of software specications
which involves signicant eort and time. Moreover, the
chances of this transformation to be error prone are very
high as it involves the understanding of user requirements
documented as NL texts and mapping them to PIM.
To help the human analysts in developing the domain
models, semi-automated1as well as automated2tools have
been proposed in literature [13, 7, 18, 7, 10, 14, 22, 23].
However, the existing semi-automated tools [13, 7, 18] are
highly dependent on the user skills to identify the domain
elements. The analysis models generated from the existing
automated tools [7, 10, 14, 22, 23] are constrained by some
serious issues such as: i) the presence of many incorrectly
identied classes and relationships [9, 11], ii) the absence of
many relevant classes and relationships [9, 11] (classes and
relationships which can be identied from the specications if
the specications are thoroughly analysed), iii) the presence
of many redundant classes and relationships.
One may argue here that most of the issues encountered
by the existing automated tools can be attributed to the
diculties associated with NL processing task. For instance,
English language has a variety of sentence types and struc-
tures which facilitate the expression of a similar concept in
various ways. Accordingly, the relevant information may be
present at dierent places across multiple sentences. To deal
with such issues, AnModeler uses i) a rich language model
based on Hornby's verb patterns that can interpret almost
all the simple sentences and a few complex sentences (con-
ditional sentences, complex sentences involving that clause
and conjunctive clause), ii) a set of domain element extrac-
tion rules (i.e., transformation rules) which capture semantic
relationships between the words of the sentences to correctly
extract the relevant domain elements from dierent places
in the sentences [21, 20].
AnModeler3is a GUI-based tool that takes textual speci-
cation of a problem documented in English as input, then
1The tools which need user skills to identify domain elements
2The tools which do not require user skills to identify domain
elements
3http://serg.iiitdmj.ac.in/tools/AnModeler, https://sites.
google.com/site/anmodeler (accessed July 31, 2016)
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ASE‚Äô16 , September 3‚Äì7, 2016, Singapore, Singapore
c2016 ACM. 978-1-4503-3845-5/16/09...$15.00
http://dx.doi.org/10.1145/2970276.2970289
828
uses the Stanford NL Parser API to obtain type dependencies
(TDs) and parts of speech tags (POS-tags) of each sentence
in the specication. It then identies structures of the sen-
tences. The identied sentence structure and the semantic
relationships between the words in the sentence obtained
from the TDs and POS-tags are used by the tool to iden-
tify domain elements viz.: domain objects, their attributes,
operations, and interactions between the objects. It nally
realizes the identied domain objects and their interactions
as analysis class diagram and sequence diagram.
An experimental study conducted with the help of 40
subjects and 40 UCSs in [21, 20] showed that the analysis
class diagrams generated by AnModeler were far more correct,
far more complete and less redundant than those generated
by existing automated tools. Another experiment conducted
on 10 UCSs with two industry experts as subjects showed
that the analysis class diagrams generated by AnModeler
were 90% correct, 99% complete and 2% redundant.
2. ANALYSIS MODELER (ANMODELER)
AnModeler is a tool for generating analysis models from
textual software requirements which is based on our ap-
proaches for generating analysis class diagrams [21, 20] and
problem level sequence diagrams [19].
2.1 Methodology
AnModeler works in ve steps [21, 20] (Figure 2). It rst
reads the UCS and stores the elements of the UCS into
an instance of UCS metamodel that we call UCS Instance
(Step 1). It parses the sentences in the UCS Instance using
the Stanford NL Parser API to generate TDs and POS-tags
(Step 2). It then identies the structures of the sentences
using a comprehensive set of Sentence Structure Rules [21, 20]
which are based on Hornby's verb patterns (Step 3). Then, it
identies domain elements (domain objects, their attributes
and operations, and interactions between the objects) from
semantic relationships between the words obtained from TDs
[21, 20] (Step 4). Finally, it realizes the identied domain
elements into classes and relationships which are stored in an
instance of a ClassDiagram metamodel called CD Instance,
and visualizes the class diagram using GraphViz (Step 5).
With the help of an illustrative example, Figure 1 shows
how AnModeler identies the domain elements from a sen-
tence in the input specication.
2.2 Architecture of AnModeler
AnModeler has six main components (Figure 3).
1.The SpecicationReader component provides input inter-
faces to read software specications written in various
formats (e.g., UCSs, simple text etc.); it provides an
output interface to store elements read from input spec-
ications in a common format i.e. an instance of UCS
metamodel shown in Figure 2.
2.The SentenceParser component provides an input interface
to read the sentences from the UCS Instance (an instance
of UCS metamodel); it uses Stanford NL Parser API to
obtain TDs and POS-tags of the sentence, and provides
TDs and POS-tags of the sentence as an output interface.
3.The SentenceInterpreter component provides an input
interface to scan the TDs and POS-tags of the sentence;
Input Sentence = ‚Äú The ATM Controller sends the ATM User an SMS ‚Äù. 
POS-tags  = [The/DT, ATM /NNP, Controller/ NNP, sends /VBZ, 
the/DT, ATM /NNP, User /NN, an/ DT, SMS/ NNP ] 
Sentence Structure  = SVIODO  
SMS 
sends( ATMUser ) ATMController  sends  Step 1 and 2: Read and Parse  the sentence  
Step 3: Identify the sentence structure using 
Sentence Structure Rules [21, 2]  
Step 4: Identify domain elements using 
Transformation Rules [21, 2]  
Step 5: Generate and Visualize the class diagram operationName =sends  
sourceEntityTerm =ATMController  
destinationEntityTerm =SMS 
operationParameter =ATMUser  
 (Subject)  (Indirect Object)  nsubj (sends , ATMController ) iobj(sends , ATMUser ) dobj (sends , SMS)  
The  ATMController   sends  the ATMUser  an SMS Subject  Direct object 
Indirect object 
(Verb)  (Direct Object)  TDs=  Figure 1: An illustrative example of the tool's
methodology
it identies the structure of the sentence using a compre-
hensive set of sentence structure rules framed based on
Hornby's verb pattern [21, 20], and provides an output
interface of the identied sentence structure.
4.The DomainElementExtractor component provides input
interfaces to read the TDs and POS-tags of the sentence
and the sentence structure; based on the identied sen-
tence structure and the semantic relationship relationships
between the words obtained from TDs, it identies the
domain elements (objects, their attributes, operations and
interactions between the objects) and provide them as
output interface.
5. The ClassDiagramRealizer component provides an input
interface to read the domain elements, and maps them
to the appropriate classes and relationships, and provides
them as an output interface.
6.The ClassDiagramViewer component provides an input
interface to read the classes and relationships, and provides
two kinds of output interfaces for visualizing the class
829Step 1: Read UCS and store the elements of the UCS in an instance of 
UCS meta model called UCS_Instance  
Step 2: Parse each sentence in UCS_Instance  to obtain TDs and POS tags  
Step 3: Identify sentence structure of each sentence from their TDs & 
POS-tags (using sentence structure rules SSR1- SSR33) [21, 2]  
Step 5: Generate & Visualize analysis class diagram  
Get the unidentified sentences corrected 
by user (Optional step)  
Stanford NL parser API 
GraphViz  API Step 1  
Step 2  
Step 3  
Step 5  <<uses>> 
<<uses>> (Input ‚Äì UCS )  
(Output ‚Äì Analysis class diagram of the UCS)  UCName :  WithdrawFund 
Actor : Customer  
PreCondition : ATM card validation done  
Main Flow:  
1. Customer selects Withdrawal.  
2. Customer enters the withdrawal 
amount      
        . . . . . . . .  
 User  
UCS Metamodel  UCS 
name  
name  Actor  
PreCondition  Description  
Constraint  
Flow  Class Diagram  
Operation  
name  
parameter  
sourceEntityTerm  
destEntityTerm  
Property 
name  
aggregation:AggregationKind  
 
Association  
   Step 4.1: Identify entity terms  
                         (Rule TR1)  
  Step 4.2: Identify control class           
                          (Rule TR2)  
Step 4.4: Identify entity classes and 
their attributes (Rules TR4- TR10)  
Step 4.5: Identify 
class operations, 
class attributes 
(Rules TR11- TR43)  
Step 4.6: Identify 
more entity 
classes (Rule 
TR44- TR45)  
Step 4.7: Identify association 
relationships (Rule TR46)  
Step 4.8: Identify generalization 
relationships (Rule TR47- TR50)  
Step 4.10: Eliminate extra classes  
(Rule TR54)  Step 4 :  
Class Diagram Metamodel  [derived from UML 2.0]  
Input / Output of steps  
Control flow  Association  
Aggregation  
Generalization  
Dependency  Identify domain classes, their attributes and operations, and relationships between domain classes (using transformation rule s  TR1-TR54) [21, 2]  
Step 4.3: Identify boundary classes 
(Rules TR3)  TR 1  
TR 2  
TR 3  
TR 4 -TR 9  
TR 10  
TR 11 -TR 43  TR 4 -TR 9  TR 46  TR44 -TR45  
TR 54  TR 47 -TR 48  
TR 47 -TR 48  TR 50  TR 49  
TR 51  TR 52 -TR 53  
TR 52 -TR 53  
Main Flow  Sub Flow  Specific Alt Flow  Relationship  
name  Class  
name  
Step 4.9: Identify aggregation 
relationships (Rules TR51- TR53)  Sentence 
sentence  
sentenceStruct  
posTags  
tDs 
 
Global Alt Flow  
Composition  PostCondition  TR 10  parent  
parent  
Step  
flowId  
subFlowId 
altFlowId  superClass 
* 
1..* 
1..* 
1 
* 1 
* * 
1..* 
* 
2 
* endClass attribute  1 
1..* 
1 
1 
1..* 1 1 1 
1 * 1 1 1 
* 1 
1 
1 Figure 2: Methodology of AnModeler
830diagram i) GraphViz dot commands to be used as input
to GraphViz APIs, ii) XMI le to be used as input to
UML models drawing tools such as ArgoUML, Visual
Paradigm etc.
AnModeler is implemented in Java 1.6 using Eclipse Indigo
IDE release 3.7.0. It uses the Stanford NLP parser APIs
version 2.0.44to parse specication sentences. It uses Apache
POI API 3.95to read UCSs written in MS Excel les. It uses
GraphViz API for visualising the class diagrams, and it uses
a Java API6to call dot (GraphViz) from a Java program.
2.3 Snapshots
Figure 4 show the input UCS given to AnModeler and the
corresponding analysis models (analysis class diagrams and
sequence diagrams) produced as output by the tool.
3. EXPERIMENTAL STUDY & RESULTS
The experimental study presented in [21] which was con-
ducted with the help of 40 subjects and 40 objects (i.e. Anal-
ysis class diagrams generated by AnModeler for 40 UCSs)
showed that the analysis class diagrams generated by An-
Modeler were far more correct, far more complete and less
redundant than those generated by existing automated tools.
We replicated that study in another experiment with two
industry experts as subjects. The experts had more than
three years of industry experience in analysis modeling. The
objects were the analysis class diagrams generated by An-
Modeler for ten UCSs selected randomly from 40 UCSs used
in the previous experiment which were taken from various
software engineering books [3, 12, 6, 17, 16, 4] and research
works [10, 14, 22, 5].
We provided the following materials to each industry ex-
pert: i) ve UCSs, ii) the analysis class diagrams generated
by AnModeler for each UCS, iii) questionnaires which were
based on the quality metrics for nding correctness, com-
pleteness and redundancy of the analysis class diagrams
presented in [20]. The data set obtained from the answers
to the questionnaires and the quality metrics for correctness,
completeness and redundancy were then used to obtain the
results which are shown in Table 1.
Table 1: Resutls for Correctness, Completeness
and Redundancy of the analysis class diagrams
genereated by AnModeler for ten UCSs
S# UseCaseName CDcr CDcm CDrd
1 AGV Move to Station 0.92 1.00 0.00
2 ATM ValidatePIN 0.94 1.00 0.10
3 EMS Generate Alarm 0.94 1.00 0.00
4 iCoot Make Reservations 0.91 1.00 0.00
5 Internet Book Store Write Review 0.93 0.96 0.00
6 Ticket Distributor PurchaseTicket 0.84 0.97 0.12
7 OSS Process Delivery Order 0.82 0.94 0.00
8 Print Pack Types 0.92 1.00 0.00
9 TTMS Monitor Train Systems 0.93 0.98 0.00
10 VTS Edit Pending Request 0.91 1.00 0.00
Average 0.90 0.99 0.02
CDcr = Class Diagram Correctness, CDcm = Class Diagram Completeness,
CDrd = Class Diagram Redundancy
4http://nlp.stanford.edu/software/lex-parser.shtml (ac-
cessed May 20, 2016)
5http://poi.apache.org/ (accessed May 20, 2016)
6https://github.com/jabbalaci/graphviz-java-api (accessed
May 20, 2016)4. FEATURES, USES & LIMITATIONS
In addition to the generation of analysis class diagrams
from textual specications, AnModeler can also generate
other useful artifacts such as i) Problem level sequence dia-
grams [19], ii) Java template code. The Java template code
generated by AnModeler realizes the classes with construc-
tors, objects initializations and the method calls. Moreover,
the template code is also realized with branching and loop-
ing statements, and their nesting identied from the objects
interactions in the generated sequence diagram.
Being lightweight and easy to use, the tool can also be used
to assist students and young developers in acquiring object-
oriented domain modeling skills quickly. For a given software
requriements specication, they can quickly see what are
its domain elements (objects, attributes, operations) and
interactions and relationships between the domain objects.
They can also cross check the models obtained by them with
those generated by the tool for the given specications.
AnModeler accepts the input software requirements writ-
ten in UCS as well as plain text. Along with the in place
visualization of the output class diagram, it provides facility
to export the class diagram as XMI (XML Metadata Inter-
change) le which can be used as input in various design
modeling tools such ArgoUML, Visual Paradigm etc.
Having separate components to handle each of the sub
tasks of analysis modeling, it can easily be modied to ac-
commodate changes, and can easily be extended to add more
features.
AsAnModeler is the implementation of our approaches for
generating analysis class diagrams and sequence diagrams
presented in [21, 19], so it also has all the limitations of these
approaches. Another limitaion is that its current implemen-
tation cannot generate sequence diagrams from the software
requirements specied as plain text, however it can generate
the class diagrams from both the UCS as well as the plain
text.
5. EXISTING AUTOMATED TOOLS
CM-Builder2 presented in [7] obtains candidate classes
from all the nouns in the text and candidate relationships
from all non-copular verbs. It identies attributes from pos-
sessive relationships and adjectives. It discards the candidate
classes obtained from nouns having low frequency in the re-
quirements and those not participating in any relationships.
The class diagrams obtained from the tool do not contain
class operations, lack association relationships between many
classes, and the tool cannot identify generalization relation-
ships.
UCDA presented in [10] processes the text based on classi-
cation of sentences as transitive, intransitive, ditransitive,
intensive, complex transitive, prepositional and non-nite
given in [15]. To identify domain classes, it needs a glossary
of domain specic terms. It is unable to identify aggregation
and generalization relationships between entity classes.
The aim of Dowser presented in [14] is to be used to iden-
tify inconsistencies in requirement specications with the
help of automatically generated analysis class diagrams. It
parses the requirements based on a constraining grammar
to obtain link types which are used to identify the domain
elements. The obtained analysis class diagram can then be
checked by human analysts to detect inconsistencies in the
input specications. The tool can interpret only the simple
831AnModeler  
SentenceInterperter  DomainElementExtractor  SentenceParser  ClassDiagramRealizer  SpecificationReader  ClassDiagramViewer  ApachiPOIAPI  
StanfordNLParserAPI  GraphVizAPI  Input Use Case Specification (UCS) 
UCS 
<<uses>> Sentences 
TDs & POS -tags 
Sentence 
Structures  TDs & POS -tags Domain Objects 
& Interactions 
b/w them Classes & 
Relationships  Dot 
commands 
for Class 
Diagram 
Output Class Diagram Text 
XMI File  Figure 3: Component Diagram of AnModeler
Figure 4: Tool snapshots - Input and Outputs
832sentences with ve patterns (SV, SVDO, SVPO, SVtobePO
and SVDOPO) and ve keyword specic sentences. The anal-
ysis class diagrams obtained from the tool lacks relationships
between many classes and many classes lacks operation.
aToucan presented in [22] can interpret a large variety of
sentences as compared to other existing tools. The tool can
identify domain entities (entity classes and attributes) of
only one word (single noun) in length. Most of the classes
obtained from the tool can be termed as UML smells [2] as
the tool assigns almost all the operations to a single control
class. Also, it cannot identify aggregation and generalization
relationships from the text.
6. CONCLUSION
This paper demonstrated AnModeler , a tool for generating
analysis class diagrams from textual specications. AnMod-
eleruses i) a rich language model which is based on Hornby's
verb patterns to interpret sentences of the input software
specications, ii) domain elements extraction rules based on
the structure of a sentence to nd semantic relationships
between the words depicted by Type dependencies (TDs) to
extract the relevant domain elements from dierent places in
the sentence [19, 21, 20]. AnModeler can also generate other
important artifacts viz.: i) problem level sequence diagrams,
ii) Java template code.
The replication of the experimental study presented in [21]
with the help of two industry experts as subjects for ten
UCSs showed that the analysis class diagrams generated
by AnModeler were 90% correct, 99% complete and 2%
redundant.
7. REFERENCES
[1] V. Ambriola and V. Gervasi. Processing natural
language requirements. In Automated Software
Engineering, 1997. Proceedings., 12th IEEE
International Conference , pages 36{45. IEEE, 1997.
[2] T. Arendt and G. Taentzer. UML model smells and
model refactorings in early software development
phases. Universitat Marburg , 2010.
[3]G. Booch, R. A. Maksimchuk, M. W. Engle, B. Young,
J. Conallen, and K. Houston. Object Oriented Analysis
& Design with Application 3rd Edition . Pearson
Education India, 2010.
[4] B. Bruegge and A. A. Dutoit. Object-oriented software
engineering; conquering complex and changing systems .
Prentice Hall PTR, 1999.
[5] D. K. Deeptimahanti and R. Sanyal. Semi-automatic
generation of UML models from natural language
requirements. In Proceedings of the 4th India Software
Engineering Conference , pages 165{174. ACM, 2011.
[6] H. Gomaa. Software modeling and design: UML, use
cases, patterns, and software architectures . Cambridge
University Press, 2011.
[7]H. Harmain and R. Gaizauskas. Cm-builder: A natural
language-based case tool for object-oriented analysis.
Automated Software Engineering , 10(2):157{181, 2003.
[8] A. G. Kleppe, J. B. Warmer, and W. Bast. MDA
explained: the model driven architecture: practice andpromise . Addison-Wesley Professional, 2003.
[9] O. I. Lindland, G. Sindre, and A. Solvberg.
Understanding quality in conceptual modeling.
Software, IEEE , 11(2):42{49, 1994.
[10] D. Liu, K. Subramaniam, A. Eberlein, and B. H. Far.
Natural language requirements analysis and class
model generation using ucda. In Innovations in Applied
Articial Intelligence , pages 295{304. Springer, 2004.
[11] P. Mohagheghi, V. Dehlen, and T. Neple. Denitions
and approaches to model quality in model-based
software development{a review of literature.
Information and Software Technology ,
51(12):1646{1669, 2009.
[12] M. O'Docherty. Object-Oriented Analysis and Design
Understanding System Development with UML 2.0 .
John Wiley & Sons Ltd, 2005.
[13] S. P. Overmyer, B. Lavoie, and O. Rambow.
Conceptual modeling through linguistic analysis using
LIDA. In Proceedings of the 23rd international
conference on Software engineering , pages 401{410.
IEEE Computer Society, 2001.
[14] D. Popescu, S. Rugaber, N. Medvidovic, and D. M.
Berry. Reducing ambiguities in requirements
specications via automatically created object-oriented
models. In Innovations for Requirement Analysis. From
Stakeholders' Needs to Formal Designs , pages 103{124.
Springer, 2008.
[15]P. Roberts. Patterns of English . Harcourt, Brace, 1956.
[16]D. Rosenberg and M. Stephens. Use case driven object
modeling with UML. APress, Berkeley, USA , 2007.
[17] D. Rosenberg and M. Stephens. Use Case Driven
Object Modeling with UML: Theory and Practice .
Springer Science & Business, 2008.
[18]N. Samarasinghe and S. S. Som e. Generating a domain
model from a use case model. In IASSE , page 278,
2005.
[19] J. S. Thakur and A. Gupta. Automatic generation of
sequence diagram from use case specication. In
Proceedings of the 7th India Software Engineering
Conference , page 20. ACM, 2014.
[20] J. S. Thakur and A. Gupta. Automatic generation of
analysis class diagrams from textual specications.
Technical report, Software Engineering Research Group,
IIITDM Jabalpur, India, February 2016.
[21] J. S. Thakur and A. Gupta. Identifying domain
elements from textual specications. In Proceedings of
the 31st IEEE/ACM International Conference on
Automated Software Engineering . IEEE/ACM, 2016.
[22] T. Yue, L. Briand, and Y. Labiche. Automatically
deriving a UML analysis model from a use case model.
Technical Report 2010-15 (Version 2), Simula Research
Laboratory, January 2013.
[23] T. Yue, L. C. Briand, and Y. Labiche. atoucan: An
automated framework to derive UML analysis models
from use case models. ACM Transactions on Software
Engineering and Methodology (TOSEM) , 24(3):13,
2015.
833