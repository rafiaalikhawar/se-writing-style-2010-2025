Development History Granularity Transformations
Kƒ±van√ß Mu¬∏ slu
 Luke Swart
 Yuriy Brun
 Michael D. Ernst
University of Washington
 University of Massachusetts
Seattle, WA 98105 Amherst, MA 01003
{kivanc, lukeswart, mernst}@cs.washington.edu, brun@cs.umass.edu
Abstract ‚ÄîDevelopment histories can simplify some software
engineering tasks, but different tasks require different history
granularities. For example, a history that includes every edit
that resulted in compiling code is needed when searching for the
cause of a regression, whereas a history that contains only changes
relevant to a feature is needed for understanding the evolution of
the feature. Unfortunately, today, both manual and automated
history generation result in a single-granularity history. This
paper introduces the concept of multi-grained development history
views and the architecture of Codebase Manipulation, a tool
that automatically records a Ô¨Åne-grained history and manages
its granularity by applying granularity transformations.
I. I NTRODUCTION
Most software development uses version control to enable
collaboration and to create a development history. The version
control history is useful for many tasks, such as localizing
changes that caused regression failures, identifying developers
responsible for speciÔ¨Åc code, and manually examining recent
changes. However, each of these tasks is best performed at
a different granularity of history. For example, Ô¨Ånding the
cause of a regression failure is best performed on a history
of all points during development at which the code compiled,
studying Ô¨Åne-grained change patterns [ 34] or backtracking [ 46]
requires the Ô¨Ånest possible granularity, and understanding how
a bug was Ô¨Åxed requires seeing one snapshot before the bug
repair began and one snapshot after the repair completed.
Unfortunately, today‚Äôs approaches generate inÔ¨Çexible histo-
ries, each of which works well for only a subset of software
engineering tasks. Manually-managed histories tend to be
too coarse-grained, while automatically-recorded histories are
too Ô¨Åne-grained. SpeciÔ¨Åcally, manually-managed histories‚Äô
coarse granularity causes them to omit many points during
development at which the code compiled, necessary for
localizing the cause of a regression. It is virtually impossible
to manually create the Ô¨Åne-grained history necessary for
studying change patterns [ 34] and backtracking [ 46]. And a
manually-managed history is unlikely to contain the snapshots
right before and after a repair. Manually-managed histories
are suboptimal for development tasks not just because they
fail to include important moments during development, but
also because manual version control checkpoints often tangle
changes made for multiple development tasks, such as Ô¨Åxing a
bug and refactoring code. By contrast, automatically-managed
approaches record all developer actions [ 24], [35], [45] and
lead to Ô¨Åne-grained histories that are well-suited to studying
developer behavior [ 34], [42] but poorly-suited to manual
examination and for analyses that rely on semantic checkpoints.
Even if a history can be created at an ideal granularity
for a speciÔ¨Åc task, no single way of recording the history
can satisfy all tasks, because different development tasks
require different granularities. Additionally, development taskssometimes require the development history to be restructured.
For example, one way to understand a bug Ô¨Åx is to reordering
the history to move away any unrelated changes that were
performed during the Ô¨Åx, so the developer can focus on the
relevant changes.
We argue that since different development tasks require
accessing the development history at different granularities, and
that the histories produced using today‚Äôs methods are inÔ¨Çexible
and offer no tools to change history granularity [ 24], [35], [45],
a new approach is needed. We posit that the development history
should not be restricted to a single granularity. Instead, the
history should be recorded automatically in a way that allows
its granularity to be transformed into the one best suited for the
particular development task at hand. To that end, we designed
Codebase Manipulation to mitigate the inÔ¨Çexibility of current
development histories by (1) automatically recording a Ô¨Åne-
grained development history and (2) providing the developer
with tools to manipulate the granularity and the order of
the history. Codebase Manipulation allows the developer to
change the history granularity repeatedly, and all its history
manipulations are reversible. This supports development tasks
that require the developer to view the history at multiple
granularities.
This paper presents a set of primitive manipulation trans-
formations that can be combined to manage history granularity.
We demonstrate powerful granularity transformations that can
be composed of these primitives and design an architecture
for a tool that automatically records and manages development
history granularity.
The three history-transforming primitives from which all
necessary transformations can be composed are COLLAPSE
for combining several edits into a single edit, EXPAND for
splitting a previously collapsed edit into its parts, and MOVE for
reordering edits. These primitives are sufÔ¨Åcient, for example, to
transform a Ô¨Åne-grained development history into granularities
such as all Ô¨Åle-level changes, all compilable code, and all
collocated edits. In turn, this supports activities such as Ô¨Ånding
the cause of a regression and separating distinct development
tasks into separate revisions.
The rest of the paper is organized as follows. Section II
formally deÔ¨Ånes Codebase Manipulation concepts and primitive
transformations. Section III shows that powerful granularity
transformations can be composed of these primitives. Section IV
proposes an architecture for a Codebase Manipulation imple-
mentation. Finally, Section V places our work in the context of
related research, and Section VI summarizes our contributions.
II. D EFINITIONS
Our goal is to improve the usability of development histories
by automatically recording a Ô¨Åne-grained version control history
and by providing automated granularity transformations to makethe history available at multiple granularities. To that end, we de-
sign Codebase Manipulation. To aid in understanding Codebase
Manipulation‚Äôs high-level granularity transformations, we Ô¨Årst
explain how Codebase Manipulation represents the development
history and how Codebase Manipulation‚Äôs primitives operate
on that history.
This section deÔ¨Ånes the representation and primitives, and
Section III speciÔ¨Åes the high-level granularity transformation
algorithms. For brevity, the deÔ¨Ånitions ignore Ô¨Åle creation and
deletion; they can be extended to handle these actions.
DeÔ¨Ånition 1 (Snapshot) .A snapshot sis a single developer‚Äôs
view of a program at a point in time, including the current
contents of unsaved editor buffers. Unsaved editor buffers have
priority: if a Ô¨Åle on disk differs from the editor buffer for that
Ô¨Åle, the snapshot contains the contents of the editor buffer.
An edit can either be atomic or compound. An atomic edit
encodes replacement of one chunk of text in a Ô¨Åle by another
chunk; either the original or the Ô¨Ånal chunk of text may be
empty. A compound edit is a sequence of edits, each of which
is either atomic or compound. A development history is an edit
that can be applied to the empty snapshot, /0. Two development
histories are views of each other if when applied to /0, they
produce the same snapshot.
DeÔ¨Ånition 2 (Edit) .An edit may be atomic orcompound .
(Atomic edit) .LetSbe the set of all snapshots. An atomic edit
is a 4-tuple r=
Ô¨Ålepath ;offset ;length ;text
. We treat ras
a function: r:S!S.r(s)is the same as sexcept that in r(s),
thelength characters in sin the Ô¨Åle Ô¨Ålepath starting at position
offset are replaced by text.1
(Compound edit) .Let Sbe the set of all snapshots. For
alln0, a compound edit is a sequence of edits e=
he1;e2;:::; eni. We treat eas a function e:S!Ssuch that
e(s) =en(en 1(:::(e2(e1(s))))) .
For example, the atomic edit e1=
foo.txt ;0;0;‚Äúpublic‚Äù
adds the word ‚Äúpublic‚Äù at the beginning of foo.txt . After that,
the atomic edit e2=
foo.txt ;1;5;‚Äúrivate‚Äù
replaces ‚Äúublic‚Äù
with ‚Äúrivate‚Äù, constructing the word ‚Äúprivate‚Äù; and after that, the
atomic edit e3=
foo.txt ;0;7;‚Äú‚Äù
deletes the word ‚Äúprivate‚Äù.
Example compound edits are he1;e2;e3iandhe1;he2;e3ii.
DeÔ¨Ånition 3 (Applicability) .LetSbe the set of all snapshots.
An atomic edit r=
Ô¨Ålepath ;offset ;length ;text
is applicable
to a snapshot s2Sif the Ô¨Åle Ô¨Ålepath has at least offset +length
characters. A compound edit e=he1;e2;:::; eniis applicable
to a snapshot s2Sife1;e2;:::; encan be applied in sequence
tos. More formally, eis applicable to siffe1is applicable
tos,e2is applicable to e1(s), . . . , and enis applicable to
en 1(en 2(:::(e2(e1(s))))) .
If an edit eis not applicable to a snapshot s,e(s)is
undeÔ¨Åned.
DeÔ¨Ånition 4 (Development history) .A development history is
a compound edit that is applicable to the empty snapshot, /0.
DeÔ¨Ånition 5 (Development history view) .Leth,h0be two
development histories. We call h0a view of h(and ha view
ofh0) iff h(/0) =h0(/0).
1Other deÔ¨Ånitions for the atomic edit are possible. For example, instead of
using character offsets to indicate where to change the text, an atomic edit
could specify the surrounding text.There are three history manipulation primitives: COLLAPSE ,
EXPAND , and MOVE . Collapse replaces a sequence of edits
by a compound edit that consists of that sequence. Expand is
the reverse of collapse; it replaces a non-top-level compound
edit by the sequence of its component parts. Move moves the
location of an edit within the history. These three primitives are
sufÔ¨Åcient to express all of Codebase Manipulation‚Äôs high-level
granularity transformations.
DeÔ¨Ånition 6 (COLLAPSE ).For all compound edits e=
e0;
::: ; ei 1;ei; ::: ; ej;ej+1; :::
,COLLAPSE (e;i;j)returns
e0; ::: ; ei 1;hei; ::: ; eji;ej+1; :::
.
For example, collapse (
e0;e1;e2
;0;1) =

e0;e1
;e2
andcollapse (
e0;e1;e2;e3;e4;e5
;fh0;1i;h3;5ig) =

e0;
e1
;e2;
e3;e4;e5
.
DeÔ¨Ånition 7 (EXPAND ).For all compound edits e=
e0; ::: ;
ei 1;ei;ei+1; :::
, where eiis a compound edit
ei1;ei2;
ei3; ::: ; eilast
,EXPAND (e;i)returns
e0; ::: ; ei 1;ei1;ei2;
ei3; ::: ; eilast;ei+1; :::
.
DeÔ¨Ånition 8 (MOVE).For all development histories
h=he0;e1;:::; ei 1;ei;:::; ej;:::i,move (h;i;j)returns
he0;e1;:::; ei 1;e0
i+1;:::; e0
j 1;e0
i;ej:::iif the resulting
sequence of edits is applicable to an empty snapshot /0;
otherwise, it returns hunmodiÔ¨Åed. The edits between the
reordered edits ( ei;:::; e0
j 1) might need to be modiÔ¨Åed to
ensure that the resulting history reaches the same snapshot.
The operational transform [ 41] deÔ¨Ånes how two adjacent edits
should modiÔ¨Åed to have their positions swapped.
DeÔ¨Ånition 9 (Granularity transformation) .LetHbe the set
of all development histories. A granularity transformation is a
function g:H!Hthat applies a series of collapse, expand,
and move transformations. In other words, gis a sequence of
history manipulation primitives. Granularity transformations
may be parameterized. That is, their domain may be HP,
where P is a set of parameters, such as starting and ending
edits in the history to which the transformation should apply.
For simplicity of exposition, this paper gives algorithms
for development histories with a single linear branch of
development. Our work generalizes to multiple developers
working concurrently and to using branches.
III. D EVELOPMENT HISTORY GRANULARITY
TRANSFORMATIONS
This section describes powerful granularity transformations
that can be composed of the three primitive transformations,
COLLAPSE ,EXPAND , and MOVE. Using the algorithms de-
scribed in this section, a developer who wishes to Ô¨Ånd the cause
of a regression failure can convert an automatically-recorded
history into one consisting of every compilable edit then use
history bisection on that ideal-granularity history. To manually
inspect how a code element has evolved (e.g., which developer
added a class and which other developers helped repair bugs
related to the class), the developer can convert the history into
one that groups together changes based on the Ô¨Åles they affect.
Finally, to better understand a set of changes made over time
to a part of a class, the developer can group all collocated edits
together.
We Ô¨Årst deÔ¨Åne two fundamental granularity transformations,
COLLAPSE BYGROUP and REORDER BYGROUP , and thenshow how these two transformations can be serve as a basis
for other transformations. Both COLLAPSE BYGROUP and
REORDER BYGROUP are composed entirely of the primitives
deÔ¨Åned in Section II. These transformations allow regrouping
and reordering edits. To direct these transformations, the the
GROUP NAME interface, speciÔ¨Åes relationships between edits.
An implementation of this interface map each edit in a history
to a name string; edits that are related map to the same name.
For example, an implementation of GROUP NAME can return
a single name for: all edits related to a feature, all edits to
the same Ô¨Åle, or all edits by the same developer. If an edit
is compound and composed of edits with different names,
GROUP NAME throws the multiplegroups exception, which could
prompt the algorithm using GROUP NAME to, for example,
consider these edits individually, fail, or use an alternate
method to classify the compound edit. Some GROUP NAME
implementations may be project-speciÔ¨Åc (e.g., the same feature
example), while others are general (e.g., the same Ô¨Åle or same
developer examples).
GROUP NAME :
Input: history hand edit einh
Output: The name of the group to which the edit belongs
Throws a multiplegroups exception if eis compound and the edits
making up ebelong to more than one group.
In all algorithms that follow that use GROUP NAME , an
implicit preprocessing step is to recursively EXPAND edits for
which G ROUP NAME throws the multiplegroups exception.
The COLLAPSE BYGROUP algorithm COLLAPSE s consecu-
tive edits with the same name without reordering the history.
An implementation of the GROUP NAME interface speciÔ¨Åes
which consecutive edits should be C OLLAPSE d.
COLLAPSE BYGROUP :
Input: history h, two edit indices start and endinh, and an
implementation of G ROUP NAME
Output: A view of hconsisting ofhe0;:::; estart 1,ea,eb,
eg;:::; ew;eend+1;:::i, where:
ea=hestart;estart +1;:::; eai,eb=hea+1;:::; ebi,eg=
heb+1;:::; eci, . . . , ew=hez+1;:::; eendi,
for all ÀÜ e2fea;eb;eg;:::; ewg, for all e;e02ÀÜe,
GROUP NAME (e)=GROUP NAME (e0), and
GROUP NAME (ea)6=GROUP NAME (ea+1),
GROUP NAME (eb)6=GROUP NAME (eb+1),
. . . ,
GROUP NAME (ez)6=GROUP NAME (ez+1).
TheREORDER BYGROUP algorithm enables history reorder-
ing. An implementation of the GROUP NAME interface speciÔ¨Åes
which edits should be M OVEd to be together.
REORDER BYGROUP :
Input: history h, two edit indices start and endinh, and an
implementation of G ROUP NAME
Output: A view of hproduced only by MOVEing edits in h, such
that for all starti;jend,GROUP NAME (ei) =GROUP NAME (ej)
() for all i<k<j, GROUP NAME (ek) = G ROUP NAME (ei).
REORDER BYGROUP andCOLLAPSE BYGROUP are power-
ful and enable expressing interesting history transformations,
including producing the following histories:
Compilable code. A compilable code history consists only
of edits that produce compiling snapshots. This history view is
useful for analyses, such as history bisection of test failures,
that only apply to compilable code and beneÔ¨Åt from havingaccess to every compilable snapshot that occurred during
development. GROUP COMPILABLE COLLAPSE s consecutive
edits of a history into a compilable code history. By default,
GROUP COMPILABLE has a preprocessing step of recursively
EXPAND ing all edits, but this step is optional. Without prepro-
cessing, GROUP COMPILABLE can preserve a custom history
granularity and select only the edits in the history‚Äôs current
granularity that produce compiling snapshots.
GROUP COMPILABLE :
Input: history h, two edit indices start and end inh, and a
procedure COMPILE whose input is a snapshot and output is true
if that snapshot compiles, and false otherwise
Output: A view of hproduced only by COLLAPSE ing
consecutive edits in h, such that the view consists of
he0;:::; estart 1;ea;eb;eg;:::; ew;eend+1;:::i, where:
Snapshotshe0;:::; estart 1;eai(/0),he0;:::; estart 1;ea;ebi(/0),
. . . ,he0;:::; estart 1;ea;eb;eg;:::; ewi(/0)all C OMPILE , and
For all ÀÜe2fea;eb;eg;:::; ewg, there does not exist an edit e2ÀÜe
such that the snapshot he0;:::; ei(/0)COMPILE s.
File-level. A Ô¨Åle-level change history reorders all of each
Ô¨Åle‚Äôs edits to be adjacent in the history, and keeps the edits to
different Ô¨Åles separate. This history view is useful for manual
inspection and analyses that are limited to individual Ô¨Åles.
Many version control systems already provide diff commands
that allow developers to view all the changes made to a single
Ô¨Åle, and other commands to view the history of a single Ô¨Åle,
e.g., git log filename .GROUP FILES rewrites a history into a
Ô¨Åle-level change history.
GROUP FILES:
Input: history h, and two edit indices start andendinh
Output: A view of h, transformed by REORDER BYGROUP where
the implementation of GROUP NAME returns the Ô¨Åle(s) in which
the edit was made.
Collocated edit. A sequence of consecutive edits in a
history is collocated if each edit in the sequence touches at
least one character that is either touched by or is adjacent to
a character touched by a previous edit in the sequence (see
DeÔ¨Ånition 10). Such a sequence represents a series of edits in
the same place in the codebase. For example, if a developer
types a line of text at the start in a Ô¨Åle, edits parts of that line,
types another line right after the Ô¨Årst, makes more edits to the
Ô¨Årst line, and then moves on either to a distant part of the
Ô¨Åle or to another Ô¨Åle, the creation of and edits to the Ô¨Årst two
lines would all be considered collocated. If the developer later
returned to edit the Ô¨Årst two lines after making the changes
elsewhere, these new edits would not be collocated with the
original ones. GROUP COLLOCATED rewrites a history into
a collocated edit change history, which COLLAPSE s together
maximal sequences of collocated edits (DeÔ¨Ånition 11). The
preprocessing step of recursively EXPAND ing all edits is
optional. This history view is useful when a developer wants
to manually examine a set of changes related to a particular
piece of code, or partially rollback some changes to a piece of
code.
DeÔ¨Ånition 10 (First maximal sequence of collocated edits) .
For all sequences of edits e0;e1;e2;:::; ez, the Ô¨Årst maximal
sequence of collocated edits ise0;:::; ek, such that kis the
largest value such that either k=0or for all 0ik, there
exists 0j<isuch that eitouches at least one character
touched by ej.DeÔ¨Ånition 11 (Grouping of maximal collocated edits) .
For all sequences of edits e0;e1;e2;:::; ez, the group-
ing of maximal collocated edits isea;eb;eg;:::; ew=
he0;:::; eai;hea+1;:::; ebi;:::;hey+1;:::; ezi, such that:
 he0;:::; eaiis the Ô¨Årst maximal sequence of collocated
edits of e0;e1;e2;:::; ez,
 hea+1;:::; ebiis the Ô¨Årst maximal sequence of collocated
edits of ea+1;ea+2;:::; ez,
. . . , and
 hey+1;:::; eziis the Ô¨Årst sequence of collocated edits of
ey+1;ey+2;:::; ez.
GROUP COLLOCATED :
Input: history h, and two edit indices start andendinh
Output: A view of hconsisting of
he0;:::; estart 1;ea;eb;eg;:::ew;eend+1;:::i, where ea;eb;eg;:::ew
is the grouping of maximal collocated edits of
estart;estart +1;:::; eend.
IV. C ODEBASE MANIPULATION ARCHITECTURE
This section describes an architecture for a Codebase
Manipulation implementation for the Eclipse IDE. Codebase
Manipulation automatically records a Ô¨Åne-grained development
history and enables the developer to modify the granularity
of that history and access the resulting history as a typical
version control repository. Codebase Manipulation removes
the burden of manual development history creation, improves
existing historical analyses, and simpliÔ¨Åes the implementation
of new historical analyses. Our Codebase Manipulation design
aims to satisfy the following requirements (although evaluating
that our design meets the requirements is outside of the scope
of this paper):
Complete history: Codebase Manipulation records every
developer action (including ones that the developer undoes)
and the resultant code changes.
Easy-to-use history: Codebase Manipulation‚Äôs history views
are easy to use by the developer, and by automated analysis
tools.
Unobtrusive recording: Codebase Manipulation does not
interfere with existing development tools. It neither slows down
the developer‚Äôs IDE nor affects manually-managed version
control histories.
Codebase Manipulation automatically records the Ô¨Åne-
grained history into a Git repository. Each developer action,
even ones that do not alter the source code, results in a commit,
with the log message storing information on the action itself. Do
do this, Codebase Manipulation is built on top of Solstice [ 31],
an Eclipse plug-in that enables Codebase Replication [ 29], [30]
and facilitates IDE interactions (Figure 1). Solstice maintains a
copy of the developer‚Äôs code in parallel to the developer‚Äôs work,
detects all code changes, and provides Codebase Manipulation
with observer patterns for the changes.
Codebase Manipulation satisÔ¨Åes the complete-history re-
quirement by detecting every developer action within Eclipse
via the Eclipse‚Äôs API, and recording all such actions and every
textual change to the source code.
Codebase Manipulation satisÔ¨Åes the easy-to-use require-
ment by providing a history manipulation framework to
automatically transform the recorded development history into
coarser granularities. The converted histories are themselves
Git repositories, which can be inspected manually and interface
with automated tools. Future work will evaluate how well
Codebase Manipulation satisÔ¨Åes this requirement.
Create fine-grained  history
Developer ‚Äôs
IDE
Developer actions IDE Develo per editsSolstice
Fine-grained 
his
toryS1 S2 S3 ‚Ä¶ Sn S4History manipulation framework
‚Ä¶File-level changes
‚Ä¶Compilable    code
‚Ä¶
Codebase
ManipulationFig. 1: Codebase Manipulation architecture. Codebase Manipulation
(blue) extends Solstice (black) to automatically maintain the Ô¨Åne-
grained development history, which the manipulation framework
transforms into views of other granularities.
Finally, Codebase Manipulation satisÔ¨Åes the unobtrusive-
recording requirement by storing its Ô¨Åne-grained Git repository
in a unique folder on the Ô¨Ålesystem. The developer may
continue to use any version control system, including Git,
to create a manual history in parallel, and tools can access both
the codebase and the manual history. We believe Git to be fast
enough for Codebase Manipulation‚Äôs overhead to be negligible.
Future work will evaluate how well Codebase Manipulation
satisÔ¨Åes this requirement.
Codebase Manipulation architecture limitations. Code-
base Manipulation is susceptible to Solstice‚Äôs design limitations.
Solstice detects source code changes through the IDE API; if the
source code is changed outside the IDE, Codebase Manipulation
will not record these changes immediately. Developers rarely
edit outside of their preferred IDE, but to mitigate this limitation,
each time the IDE is opened, Codebase Manipulation checks for
any changes to the source code that may have taken place and
creates an edit containing these external changes. Codebase
Manipulation could avoid this limitation by using OS-level
Ô¨Åle-system listeners to detect changes to the source code.
However, this approach would prevent Codebase Manipulation
from detecting changes that are not written to the Ô¨Åle system,
such as unsaved changes in editor buffers. Future work will
investigate how these external edits affect information retrieval.
Additionally, Solstice detects some developer actions initiated
via tools as typing actions, and therefore Codebase Manipulation
records them as such. For example, Codebase Manipulation
records Eclipse refactorings as a series of text replace operations
to the source code. Thus, Codebase Manipulation is complete in
its recording, but inherits Solstice‚Äôs limitations in recognizing
how some actions are initiated. Improvements to Solstice would
be immediately reÔ¨Çected in Codebase Manipulation.
V. R ELATED WORK
The typical way to create development histories is by
using version control systems (VCSs), such as Subversion [ 7],
Mercurial [ 26], and Git [ 10]. Unlike Codebase Manipulation,
these systems are manual and the history they provide has a
Ô¨Åxed, typically coarse granularity. Developers may change the
Ô¨Ålesystem state to earlier snapshots in the history, and may
compare the differences between two snapshots, but cannot
easily alter the history to suit particular development tasks.VCSs require the developer to manually create each
snapshot. Developers frequently forget to create snapshots,
or simply do not know the best time to to so. As a result, the
development history is often coarse-grained or incomplete. For
example, a single edit may include changes relevant to multiple
development tasks, and changes developers make but overwrite
before creating a snapshot are lost. This makes VCS histories
suboptimal for many analyses or manual inspection. Codebase
Manipulation addresses these limitations by automatically
recording the history of alledits and providing the framework
for rewriting this history into custom granularities better suited
for development tasks.
Some VCSs allow limited history rewriting [ 14], [27].
For example, git rebase can collapse, expand, move, and
remove edits [ 15]. However, these tools are complex, prevent
collaboration because rewriting a shared history prevents
subsequent sharing, and are irreversible and lead to further
history information loss. By contrast, Codebase Manipulation
history transformations are high-level, which hides all internal
complexity, reversible, and keep intact the recorded history‚Äôs
integrity to enable collaboration.
Fine-grained version control can simplify merging and
improve collaboration [ 23], [36]. Development histories can
also be created automatically by recording developer actions.
Fluorite [ 45] stores Ô¨Åne-grained edits to visualize, replay,
and query the development history, and implements Ô¨Åne-
grained selective undo [ 5]. Built on Fluorite, Azurite studies
developers‚Äô backtracking patterns [ 46] and also enables selective
undo [ 47]. Azurite also introduces change summarization with
collapse levels [44]: changes can be displayed at the raw
(Ô¨Åne-grained) level, parsable by the compiler level, method
level, and type level. Users reported wanting to see changes
at higher-levels than the Ô¨Åne granularity, e.g., at the level
of the method [ 44], so these collapse levels, similar to
views presented in this paper, are likely to be useful in
practice. Changing between these levels is similar to change
summarization [ 19], [38], and tools that summarize changes,
or select which changes belong to the same summary (e.g.,
semantic version history slicing [ 21]) are complementary to
Codebase Manipulation, which enacts collapsing, expanding,
or moving changes. Additionally, choice calculus can be
used to map features to implementation elements [ 43], which,
again, can select which changes Codebase Manipulation should
collapse. CodingSpectator [ 35] and CodingTracker record and
use the Ô¨Åne-grained development history to study refactoring
practices [ 42], development practices [ 35], and Ô¨Åne-grained
change patterns [ 34]. Storyteller VCS uses the Ô¨Åne-grained
history to transfer knowledge from an experienced developer
to an inexperienced one [ 24]. IDE++ [ 16], [17] maintains
a Ô¨Åne-grained development history to improve development
by analyzing Ô¨Åne-grained code changes. Each of these tools
focuses on particular development tasks or research goals. As
a result, these automatically-recorded Ô¨Åne-grained histories are
inÔ¨Çexible and only suitable for the tasks that require their
particular granularity. By contrast, Codebase Manipulation is
applicable to many tasks because it records a Ô¨Çexible history
whose granularity can be transformed to match each particular
task.
To aid understanding how a history should be rewritten,
heuristics can detect related changes to help identify which
changes in a large edit may need to be untangled. These
heuristics include historical code change patterns [ 20] andchange couplings, data dependencies, and code metrics[ 18].
These approaches focus on detangling large edits, which is
a problem of manually-recorded histories. Meanwhile change
distilling can difference changes made in parallel on projects
sharing code [ 8], which can suggest edit patterns. Codebase Ma-
nipulation provides access to overwritten changes, potentially
improving the effectiveness of these tools.
Visualization is also an important part of history under-
standing and many repository hosting services (e.g., GitHub
and Bitbucket) include visualization tools. Azurite visualizes
edits on a timeline at different collapse levels [ 44] and research
has argued that visualizations of changes relevant to bug Ô¨Åxes
are useful for understanding the state of development [9].
Development histories simplify some software engineering
tasks. For example, git‚Äôs annotate [11] and blame [13] commands
can help understand the context of an earlier change, and
test bisection [ 12] and delta debugging [ 48], [49] can help
Ô¨Ånd the cause of a regression failure. However, the history‚Äôs
granularity affects the effectiveness of these tools. Codebase
Manipulation is complementary to these tools and can improve
their effectiveness by transforming the granularity into one most
suitable for the task. Further, because Codebase Manipulation
automatically records every developer edit, it can create richer
history views of more granularities than is possible with
manually-created histories, further improving tool effectiveness.
Mining software repositories research uses development
histories to understand development practices [ 3], [4], [50],
to localize bugs [ 33], [22], [32], [37], [28], [25], and to help
collaborative teams work together [ 1]. However, performing
analyses on manually-recorded histories may lead to incorrect
conclusions [ 2]. A history created by recording the edits at each
save operation can be used to visualize the development and
create development summaries [ 6] and to study the evolution of
students‚Äô projects [ 39]. These repositories are Ô¨Åner-grained and
more complete than manually-created ones and research on such
repositories has, for example, identiÔ¨Åed a correlation between
static analysis warnings and test failures [ 40]. The histories
created by Codebase Manipulation are Ô¨Åner-grained, richer in
terms of containing information about developer actions, and
more complete, as they include edits a developer may overwrite
before saving a Ô¨Åle. This potentially creates better data sets for
mining software repositories research.
VI. C ONTRIBUTIONS
Development histories are necessary for software engineer-
ing tasks, but their inÔ¨Çexible granularity hinders their utility.
We have presented Codebase Manipulation to automatically
record a Ô¨Åne-grained history of all developer actions and
to provide high-level history transformations to rewrite the
history‚Äôs granularity to make it more suitable for speciÔ¨Åc
tasks. We have identiÔ¨Åed COLLAPSE ,EXPAND , and MOVE
as three primitive transformations that can be combined to
construct powerful high-level history transformations and
shown how two such transformations, COLLAPSE BYGROUP
and REORDER BYGROUP , can be used to create histories
of many useful granularities. Finally, we have designed a
Codebase Manipulation architecture that enable it to record a
complete history of development, produce easy-to-use history
views at multiple granularities, and function unobtrusively,
without affective the developer‚Äôs workÔ¨Çow. Overall, Codebase
Manipulation shows promise for automating version control
and improving the utility of development histories.ACKNOWLEDGMENTS
This material is based upon work supported by the United
States Air Force under Contract No. FA8750-12-C-0174 and
by the National Science Foundation under grants CCF-0963757
and CCF-1453508.
REFERENCES
[1] Christian Bird, Nachiappan Nagappan, Premkumar Devanbu, Harald
Gall, and Brendan Murphy. Does distributed development affect software
quality? An empirical case study of Windows Vista. In ICSE , pages
518‚Äì528, 2009.
[2] Christian Bird, Peter C. Rigby, Earl T. Barr, David J. Hamilton, Daniel M.
German, and Prem Devanbu. The promises and perils of mining Git.
InMSR , pages 1‚Äì10, 2009.
[3] Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin. Proactive
detection of collaboration conÔ¨Çicts. In ESEC/FSE , pages 168√¢ ÀòA¬∏ S‚Äì178,
2011.
[4] Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin. Early
detection of collaboration conÔ¨Çicts and risks. IEEE TSE , 39(10):1358‚Äì
1375, 2013.
[5] Aaron G. Cass and Chris S. T. Fernandes. Modeling dependencies for
cascading selective undo. In INTERACT , 2005.
[6] Jacky Chan, Alan Chu, and Elisa Baniassad. Supporting empirical
studies by non-intrusive collection and visualization of Ô¨Åne-grained
revision history. In eTX, pages 60‚Äì64, 2007.
[7] Ben Collins-Sussman. The Subversion project: Building a better CVS.
Linux Journal , 2002(94):3, Feb. 2002.
[8] Beat Fluri, Michael W√ºrsch, Martin Pinzger, and Harald C. Gall.
Change distilling: Tree differencing for Ô¨Åne-grained source code change
extraction. IEEE TSE , 33(11):725‚Äì743, 2007.
[9] Daniel M. German. An empirical study of Ô¨Åne-grained software
modiÔ¨Åcations. Empirical Software Engineering , 11(3):369‚Äì393, 2006.
[10] Git. http://www.git-scm.com/. Accessed on September 21, 2014.
[11] Git annotate. https://www.kernel.org/pub/software/scm/git/docs/git-
annotate.html. Accessed on September 21, 2014.
[12] Git bisect. https://www.kernel.org/pub/software/scm/git/docs/git-bisect.
html. Accessed on September 21, 2014.
[13] Git blame. https://www.kernel.org/pub/software/scm/git/docs/git-blame.
html. Accessed on September 21, 2014.
[14] Git: History rewriting. http://git-scm.com/book/en/Git-Tools-Rewriting-
History. Accessed on September 21, 2014.
[15] Git: Rebase. http://www.git-scm.com/book/en/Git-Branching-Rebasing.
Accessed on September 21, 2014.
[16] Zhongxian Gu. Capturing and exploiting Ô¨Åne-grained IDE interactions.
InICSE , pages 1630‚Äì1631, 2012.
[17] Zhongxian Gu. Toward Effective Debugging by Capturing and Reusing
Knowledge . PhD thesis, University of California, Davis, CA, USA,
2013.
[18] Kim Herzig and Andreas Zeller. The impact of tangled code changes.
InMSR , pages 121‚Äì130, 2013.
[19] Miryung Kim and David Notkin. Discovering and representing
systematic code changes. In ICSE , pages 309‚Äì319, 2009.
[20] Hiroyuki Kirinuki, Yoshiki Higo, Keisuke Hotta, and Shinji Kusumoto.
Hey! Are you committing tangled changes? In ICPC , pages 262‚Äì265,
2014.
[21] Yi Li, Julia Rubin, and Marsha Chechik. Semantic slicing of software
version histories. In ASE, 2015.
[22] Benjamin Livshits and Thomas Zimmermann. DynaMine: Finding
common error patterns by mining software revision histories. In
ESEC/FSE , pages 296‚Äì305, 2005.
[23] Boris Magnusson, Ulf Asklund, and Sten Min√∂r. Fine-grained revision
control for collaborative software development. In FSE, pages 33‚Äì41,
1993.
[24] Mark Mahoney. The Storyteller version control system: Tackling version
control, code comments, and team learning. In SPLASH demonstrations
track , pages 17‚Äì18, 2012.[25] Tim Menzies, Zach Milton, Burak Turhan, Bojan Cukic, Yue Jiang,
and Ay¬∏ se Bener. Defect prediction from static code features: Current
results, limitations, new approaches. Automated Software Engineering ,
17(4):375‚Äì407, 2010.
[26] Mercurial. http://mercurial.selenic.com/. Accessed on September 21,
2014.
[27] Mercurial: Editing history. http://mercurial.selenic.com/wiki/
EditingHistory. Accessed on September 21, 2014.
[28] Ayse Tosun Misirli, Ayse Basar Bener, and Resat Kale. AI-based
software defect predictors: Applications and beneÔ¨Åts in a case study. AI
Magazine , 32(2):57‚Äì68, 2011.
[29] Kƒ±van√ß Mu¬∏ slu, Yuriy Brun, Michael D. Ernst, and David Notkin. Making
ofÔ¨Çine analyses continuous. In ESEC/FSE , pages 323‚Äì333, 2013.
[30] Kƒ±van√ß Mu¬∏ slu, Yuriy Brun, Michael D. Ernst, and David Notkin.
Reducing feedback delay of software development tools via continuous
analyses. IEEE TSE , 2015.
[31] Kƒ±van√ß Mu¬∏ slu, Luke Swart, Alain Orbino, Yuriy Brun, Michael D. Ernst,
and David Notkin. Solstice. https://bitbucket.org/kivancmuslu/solstice/.
Accessed on September 21, 2014.
[32] Nachiappan Nagappan, Thomas Ball, and Andreas Zeller. Mining metrics
to predict component failures. In ICSE , pages 452‚Äì461, 2006.
[33] Nachiappan Nagappan, Andreas Zeller, Thomas Zimmermann, Kim
Herzig, and Brendan Murphy. Change bursts as defect predictors. In
ISSRE , pages 309‚Äì318, 2010.
[34] Stas Negara, Mihai Codoban, Danny Dig, and Ralph E. Johnson. Mining
Ô¨Åne-grained code changes to detect unknown change patterns. In ICSE ,
pages 803‚Äì813, 2014.
[35] Stas Negara, Mohsen Vakilian, Nicholas Chen, Ralph E. Johnson, and
Danny Dig. Is it dangerous to use version control histories to study
source code evolution? In ECOOP , pages 79‚Äì103, 2012.
[36] Dirk Ohst and Udo Kelter. A Ô¨Åne-grained version and conÔ¨Åguration
model in analysis and design. In ICSM , pages 521‚Äì527, 2002.
[37] Thomas J. Ostrand, Elaine J. Weyuker, and Robert M. Bell. Where the
bugs are. In ISSTA , pages 86‚Äì96, 2004.
[38] Xiaoxia Ren, Fenil Shah, Frank Tip, Barbara G. Ryder, and Ophelia
Chesley. Chianti: A tool for change impact analysis of Java programs.
InOOSPLA , pages 432‚Äì448, 2004.
[39] Jaime Spacco, David Hovemeyer, and William Pugh. An Eclipse-based
course project snapshot and submission system. In eTX, pages 52‚Äì56 ,
2004.
[40] Jaime Spacco, Jaymie Strecker, David Hovemeyer, and William Pugh.
Software repository mining with Marmoset: An automated programming
project snapshot and testing system. In MSR , pages 1‚Äì5, 2005.
[41] Chengzheng Sun, Xiaohua Jia, Yanchun Zhang, Yun Yang, and David
Chen. A consistency model and supporting schemes for real-time
cooperative editing systems. In Australian Computer Science Conference ,
pages 582‚Äì591, 1996.
[42] Mohsen Vakilian, Nicholas Chen, Stas Negara, Balaji Ambresh Rajkumar,
Brian P. Bailey, and Ralph E. Johnson. Use, disuse, and misuse of
automated refactorings. In ICSE , pages 233‚Äì243, 2012.
[43] Eric Walkingshaw and Martin Erwig. A calculus for modeling and
implementing variation. In GPCE , pages 132‚Äì140, 2012.
[44] YoungSeok Yoon. Backtracking Support in Code Editing . PhD thesis,
Carnegie Mellon University, Pittsburg, PA, USA, 2015.
[45] YoungSeok Yoon and Brad A. Myers. Capturing and analyzing low-level
events from the code editor. In PLATEAU , pages 25‚Äì30, 2011.
[46] YoungSeok Yoon and Brad A. Myers. A longitudinal study of
programmers‚Äô backtracking. In VL/HCC , pages 101‚Äì108, 2014.
[47] YoungSeok Yoon and Brad A. Myers. Supporting selective undo in a
code editor. In ICSE , 2015.
[48] Andreas Zeller. Yesterday, my program worked. Today, it does not.
Why? In ESEC/FSE , pages 253‚Äì267, 1999.
[49] Andreas Zeller and Ralf Hildebrandt. Simplifying and isolating failure-
inducing input. IEEE TSE , 28(2):183‚Äì200, 2002.
[50] Thomas Zimmermann, Peter Weisgerber, Stephan Diehl, and Andreas
Zeller. Mining version histories to guide software changes. In ICSE ,
pages 563‚Äì572, 2004.