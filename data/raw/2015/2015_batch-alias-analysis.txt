Batch Alias Analysis
Jyothi V edurada
Dept. of CSE, IIT Madras
vjyothi@cse.iitm.ac.inV . Krishna Nandivada
Dept. of CSE, IIT Madras
nvk@iitm.ac.in
Abstract —Many program-analysis based tools require precise
points-to/alias information only for some program variables. To
meet this requirement efﬁciently, there have been many works on
demand-driven analyses that perform only the work necessary
to compute the points-to or alias information on the requested
variables (queries). However, these demand-driven analyses can
be very expensive when applied on large systems where the
number of queries can be signiﬁcant. Such a blow-up in analysis
time is unacceptable in cases where scalability with real-time
constraints is crucial; for example, when program analysis tools
are plugged into an IDE (Integrated Development Environment).
In this paper, we propose schemes to improve the scalability of
demand-driven analyses without compromising on precision.
Our work is based on novel ideas for eliminating irrelevant and
redundant data-ﬂow paths for the given queries. We introduce the
idea of batch analysis , which can answer multiple given queries
in batch mode. Batch analysis suits the environments with strict
time constraints, where the queries come in batch. We present
a batch alias analysis framework that can be used to speed up
given demand-driven alias analysis. To show the effectiveness of
this framework, we use two demand-driven alias analyses (1) the
existing best performing demand-driven alias analysis tool for
race-detection clients and (2) an optimized version thereof that
avoids irrelevant computation. Our evaluations on a simulated
data-race client, and on a recent program-understanding tool,
show that batch analysis leads to signiﬁcant performance gains,
along with minor gains in precision.
I. I NTRODUCTION
Points-to analysis is the underlying base analysis for many
other static analyses, for example, the analyses designed for
callgraph construction [1], bug detection [2]–[4], compiler
optimizations, program understanding [5] and so on. On
one hand, there have been several whole-program points-to
analyses over the last two decades [6]–[9] that compute the
exhaustive solution and meet the requirements of clients that
need points-to information for many parts of the code. On
the other hand, many demand-driven analyses [2], [10]–[16]
have been proposed that compute only necessary results for a
ﬁxed set of queries and meet the requirements of clients that
need points-to information only for a few parts of the code.
Whole-program analyses are expensive because they are fully
exhaustive and compute the points-to information for the entire
input application. Many of the demand-driven analyses are
fully on-demand (work on each query independently) and may
not scale well to clients with a large number of queries [17],
[18], because they recompute a lot of information across
different queries. However, an open question (similar to the
one asked by Hind and Pioli [19]) which is of interest to the
community is: what is a suitable analysis for clients that fall
in-between? That is, for the clients that: (1) do not requirethe complete whole-program information but can trigger a
signiﬁcant number of queries on large applications, (2) trigger
queries which are not fully on-demand (i.e., all the queries
can come in a batch), and (3) are performance critical, that is,
should suit IDE kind of environments. There are many such
clients, for example, data-race detection analyses [4], [20],
analyses for identifying refactoring opportunities [5], and so
on, where the points-to or alias queries are available in a batch.
“Pointer Analyses should be designed to be appropriate in cost
and precision for speciﬁc groups of client problems. ”
–Barbara Ryder [8]
The existing demand-driven analyses [2], [10]–[16], [21]
answer one query at a time (fully on-demand) and none of
them provide special treatment when the queries from a client
come in batch. Some of these works perform ad-hoc caching
(or summarization) to avoid redundant computations across
different queries without exploiting the availability of queries
in advance and hence they suffer from storing unnecessary
information or from missing to store useful information across
different queries leading to performance losses. Su et al. [15]
provide a parallel algorithm to process queries from such
clients independently, but still do not take full advantage of
queries arriving in batches. We are not aware of any work that
efﬁciently answers such batch alias queries.
To address this issue of efﬁcient alias analysis where queries
come in batches, in this paper, we introduce the idea of
batch analysis . It can efﬁciently serve clients with strict time
constraints by modeling a batch query (a group of demand-
driven queries) as a single-source multiple-destination CFL-
reachability problem. To present our ideas on batch analysis,
we use two demand-driven alias analyses (1) the existing best
performing demand-driven alias analysis tool [2], and (2) an
optimized version thereof that avoids irrelevant computations
with respect to the input queries. The key step in batch anal-
ysis is identifying redundant computations across queries and
carefully forming batch queries such that these computations
are performed only once in a batch query. We believe that the
insights behind the batch analysis can be extended to other
analyses such as points-to analysis, null-pointer analysis, etc.
Our Contributions.
•We design a batch alias analysis framework that can efﬁ-
ciently address clients where alias queries come in batch, by
avoiding redundant computations within batch queries.
•We present techniques to optimize demand-driven analyses
by eliminating irrelevant analysis paths that can improve the
performance of the batch analysis further. We propose a
novel type-information based approach to eliminate irrelevant
9362019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE)
978-1-7281-2508-4/19/$31.00 ©2019 IEEE
DOI 10.1109/ASE.2019.00091
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. analysis paths when solving alias queries and thus improve the
performance and precision of demand-driven alias analyses.
•We present a detailed evaluation using a simulated data-
race client and on a recent program-understanding tool [5].
We show that batch analysis leads to signiﬁcant performance
gains, along with minor precision gains, and the elimination of
irrelevant search paths improves performance and precision.
II. P RELIMINARIES
In this section, we ﬁrst introduce some notations and
terminology, and then we outline the CFL-reachability-based
demand-driven context-sensitive alias analysis proposed by
Yan et al. [2] (implementation available [23]) as it serves as
our baseline; hereafter, we refer to it as B ASIC ANALYZER .
Alias Analysis. We use the notation Φ=alias?(a,b)to
represent an alias query between two variables aandb. To il-
lustrate, Fig. 1 shows a modiﬁed code snippet from jfreechart-
1.0.14 [22] (a chart library). Classes BarRenderer and
LineRenderer extend the abstract class Renderer . Meth-
odsclient1 ,client3 useLineRenderer and meth-
odsclient2 ,client4 useBarRenderer . The method
apply inChartTheme applies theme/style to a chart by var-
ious chart parameters like renderer. Note that ShadowPaint
controls the shadows drawn for the bars and hence is spe-
ciﬁc to BarRenderer . Suppose we are interested in ﬁnd-
ing whether the read of ﬁeld ShadowPaint:enabled at
Line 25 and the write of it at Line 22 maybe involved in a
data race, the alias query is Φ=alias?(lsp25,fsp22).
CFL-reachability. Context-free language (CFL) reachability
is an extension of graph reachability problem in which a
directed graph Gwith edges having labels from an alphabet Σ
and a context-free language LoverΣare considered. A path
pfrom a node nton/primeinGis called an L-path if the word
formed by concatenating the labels of edges in p, sayw,i s
a member of L. Here,n/primeis said to be L-reachable fromn.
This is a popular mechanism [2], [11]–[13], [15], [16], [20],
[24] to model ﬁeld- and context-sensitivity.
Program Representation. Interprocedural symbolic points-
to graph (ISPG) [2], [20] forms the basis for the CFL-
reachability-based alias analysis. Fig. 2 shows the ISPG for
the code in Fig. 1. The ISPG is constructed in two steps: (1)
an intraprocedural SPG is built locally for each method using
placeholders for the objects created outside the method. (2)
The constructed intraprocedural SPGs are connected to form
the ISPG. An ISPG contains three kinds of nodes: (1) nodes for
local variables (shown using ellipses), (2) abstract allocation
nodes representing allocated objects o∈O (shown using
rectangular white boxes), and (3) placeholder nodes called as
symbolic nodes s∈S (shown using shaded boxes).
Edges in ISPG: (1) The new , copy and store statements
lead to edges similar to the ones realized in standard points-to
analysis. For example, for each store statement of the form
x.f=y, a points-to edge o1f−→o2is added if xpoints to
o1andypoints to o2, whereo1ando2can be symbolic or
allocation nodes; (2) for each formal parameter f, an edge
f→sis added, where symbolic node srepresents the objectpassed from outside; (3) for each ﬁeld access v.f, an edge
vf−→sis added, where symbolic node sis used to represent
the object that v.f points to. (4) for each call site of the form
v=a0.m(a1,...,a i,...): (i) an entry edge is added from any
allocation or symbolic node that aipoints to in the caller, to
the symbolic node sithat formal parameter fipoints to in m;
(ii) an exit edge is added from any allocation or symbolic node
that a return variable points to in mto the symbolic node s
that was introduced as a placeholder of the return value in the
callerm. (iii) an edge v→sis added, where s(same as in
(ii)) is the symbolic node representing the object returned from
m. For an edge with label t,¯trepresents the reverse edge.
BASIC ANALYZER .Alias query Φto B ASIC ANALYZER is
performed as an on-demand single-source single-target CFL-
reachability problem on ISPG. Edge labels in ISPG are ﬁeld
names coming from ﬁeld read/write operations, and entry and
exit labels. A path between any two nodes n∈(O∪S)and
n/prime∈(O∪S)in ISPG has a string wformed by concatenating
these edge labels. The memory alias relation between nand
n/primecan be described using CFL memAlias as:
memAlias →¯f memAlias f |memAlias memAlias
|entry|entry|exit|exit|/epsilon1
Thus,memAlias is capturing ﬁeld-sensitivity by looking for
matching ﬁeld names ( f)i nw. For example, In Fig. 1, there
is amemAlias -path between lsp 25andrsp 13withw:“sp
entry 16entry 12entry 13sp exit 13”, and hence lsp 25and
rsp 13may alias. Context-sensitivity is captured using the
following grammar that matches entry and exit labels.
C→(iC)i|CC|/epsilon1(i→entry(i)|exit(i)
)i→exit(i)|entry(i)
Fig. 3 shows the demand-driven context-sensitive alias
analysis of B ASIC ANALYZER .I fΦ=alias?(a,b)is an alias
query on the local variables aandb, the algorithm takes ( n1,
n2) as the corresponding input query, where n1andn2are
the nodes that aandbpoint to respectively in the ISPG. We
callφ=(n1,n2)as an effective query ofΦ; sinceaand
bcan point to multiple allocation/symbolic nodes, an alias
query can have multiple effective queries. checkAliasing
checks for context-sensitive memAlias -path reachability from
n1ton2in the ISPG by performing a breadth-ﬁrst traversal.
The procedure maintains two stacks ( fldStk andcxtStk )t o
support ﬁeld sensitivity and context sensitivity. The function
processEdge processes each edge by updating fldStk and
cxtStk with the edge label when required and returns true
when it ﬁnds a context mismatch ( ⇒the corresponding path
should be ignored); detailed deﬁnition of this function is elided
for space. If n2is reached from n1and thefldStk is empty,
it implies that variables aandbare aliases. The termination
check (Line 10) does not check for cxtStk to be empty as a
realizable path may have unbalanced preﬁx and sufﬁx edges.
Caching. Xu et al. [20] use a whole program pre-analysis to
cache the reachability strings associated with all the reachable
nodes of each ISPG node to compute all-pairs memAlias -path
937
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 1void client1(){ ...
2client3( new LineRenderer());}
3void client2(){ ...
4BarRenderer b = new BarRenderer();
5b.setShadow( new ShadowPaint());
6client4(b);}
7void client3(LineRenderer lr){
8ChartTheme theme = ...;
9theme.apply(lr); ...}
10void client4(BarRenderer br){
11ChartTheme theme = ...;
12theme.apply(br);
13rsp = br.getShadow();...}
14class ChartTheme {
15void apply(ChartRenderer cr){
16 cr.paint();} ...} //end17abstract class ChartRenderer {
18void paint(){...} ...} //end
19class BarRenderer extends ChartRenderer{
20ShadowPaint sp;
21void setShadow(ShadowPaint fsp){
22 fsp.enabled= true ;this .sp = fsp;}
23void getShadow(){ return this .sp; }
24void paint(){ lsp = this .sp;
25 if(lsp.enabled){...} else {...}; }
26...} //end
27class LineRenderer extends ChartRenderer{
28 void paint(){ this ...} ...} //end
29class ShadowPaint{ boolean enabled; ...} //end
Fig. 1: Running example. Code snippet from jfreechart [22], with minor modiﬁcations.
O2client1
S1 lr7client3O4client2
S4this 23
applyS2 br10client4
S8
cr15getShadow
this 24 S6BarRenderer:paintthis 22 S10setShadowentry2entry6
entry
9 entry12
entry
16
entry16entry
5O5 fsp22 S11
S7 lsp25sp
spentry5
this 28 S5LineRenderer:paintS9sprsp13 S3exit 13
entry13
f Field points-to edge Field points-to edge
Exit edge at call site i Entry edge at call site ientryi exit i
Fig. 2: Symbolic Points-to Graph for the example in Fig. 1.
reachability information. Yan et al. [2] in their implementa-
tion [23] of B ASIC ANALYZER , use a caching scheme (evolved
from that of Xu et al.) that caches during the demand driven
analysis (in contrast to whole program pre-analysis), and
caches only the results of effective queries (thus, has lower
memory overhead than the work of Xu et al.) We now brieﬂy
discuss this caching scheme (termed CACHE) of Yan et al.
The code for caching gets executed upon setting an option
cachingOn . Here, for each input query ( n1,n2), (i) during
the analysis, upon visiting a node mwith empty ﬂdStk and
callStk (to respect ﬁeld- and context-sensitivity), this scheme
uses the prior result of the query ( m,n 2) if available (shown
in Fig. 4, Lines 3 and 4). (ii) in Fig. 3, before returning, the
answer for ( n1,n2) is stored (Lines 11 and 14).
III. O PPORTUNITIES FOR IMPROVEMENT
Our goal is to improve the performance of alias analy-
sis without compromising on precision. In this section, we
demonstrate two main opportunities for improving the per-
formance of a demand-driven alias analysis, for example,
BASIC ANALYZER . We illustrate the same by using the ex-
ample program in Fig. 1. Our identiﬁed opportunities can be
classiﬁed into two categories: redundant work (discussed in
Section III-A) and irrelevant work (discussed in Section III-B).1function checkAliasing( n1,n2)
2 WL←{(n1,∅,∅)};
3 while WL/negationslash=∅do
4 remove(n,fldStk n,cxtStk n)from WL ;
5(fldStk,cxtStk )←clone(fldStk n,cxtStk n);
6 foreach edgee∈n.Edges do
7 ignorePath ←processEdge( edge,ﬂdStk,cxtStk );
8 ifignorePath /negationslash=true then
9 m←neighbour (e,n 1);
10 ifm=n2∧fldStk=∅then
11 ifcachingOn then Results.add( (n1,n2), true);
12 return true; //n2andn1are may-aliases
13 WL←∪ {(m,fldStk,cxtStk )};
14 ifcachingOn then Results .add((n1,n2), false);
15 return false;
Fig. 3: Solving Alias Queries
1ifcachingOn ∧fldStk=∅∧cxtStk=∅then
2 ifeffective query (m,n 2)is in Results then // in “cache”
3 ifResults .get((m,n 2))istrue then return true ;
4 else continue ;
Fig. 4: Enable caching: code to be added to Fig. 3 (before Line 13).
A. Redundant Work
To see how B ASIC ANALYZER performs redundant work,
let us consider the example code from Fig. 1. Suppose
we are interested in ﬁnding whether the read of ﬁeld
ShadowPaint:enabled at Line 25 and the write of it
at Line 13 may involve in a data race and hence the alias
query becomes Φ1=alias?(lsp25,rsp13). Similarly, say,
we are also interested to answer the alias query Φ2=
alias?(lsp25,fsp22). The effective query of Φ1isφ=(S7,S3)
aslsp25points to S7andrsp13points to S3in the ISPG
as shown in Fig. 2. Similarly, the effective query of Φ2is
φ2=(S7,S11). Pathsπ2andπ1in Fig. 6 are the context-
sensitive memAlias -paths for φ1andφ2respectively. Fig. 5
shows the two sub graphs of the ISPG in Fig. 2 containing
edges of all the paths that are traversed by B ASIC ANALYZER
for answering φ1andφ2respectively. The start node during
938
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. O2client1
S1
client3O4client2
S4
applyS2client4
S8getShadow
S6BarRenderer:paintS10
entry2entry6
entry
9entry12
entry
16 entry16entry5
S7sp
S5S9sp S3exit 13
entry13
LineRenderer
:paintΦ1
12 3456 8
710
911O2client1
S1
client3O4client2
S4
applyS2client4
S8getShadow
S6BarRenderer:paintS10setShadow
entry2entry6
entry
9entry12
entry
16 entry16entry5
S11
S7sp
sp
S5S9sp S3exit 13
entry13
LineRenderer
:paintΦ2
12 3456 8
710
91112setShadow
Fig. 5: Sub graphs traversed for answering Φ1=alias?(lsp25,rsp13)andΦ2=alias?(lsp25,fsp22).
both the traversals is S7and the edges are numbered according
to their visiting order during the backward traversals. We can
see that the only difference between the traversal of φ1andφ2
is the edge 12; all other edges are redundantly traversed. Since
BASIC ANALYZER handles each query independently, there are
many redundant paths possible across different queries.
As discussed in Section I, for clients in which the input
alias queries come in a batch, handling the queries indepen-
dently adds a lot of overhead due to redundant traversals
across queries. To address such redundant traversals, stan-
dard demand-driven analyses perform optimizations such as:
caching the results of the previous queries and caching the
already analyzed method summaries etc. However, as sup-
ported by our evaluation, these optimizations are not sufﬁcient
to eliminate the possible redundant traversals across different
queries. If the queries are known to be available in batch,
the information about the query (S7,S3)will be known when
answering the query (S7,S11)(or vice versa). This prior
knowledge can be used to avoid redundant path traversals. In
this paper, we propose the idea of batch analysis framework
to efﬁciently handle multiple queries coming in batch mode.
We call our batch analysis technique as B AT C H ANALYZER .
B. Irrelevant Work
To see how B ASIC ANALYZER performs irrelevant work,
consider the code shown in Fig. 1. Suppose we are interested
in answering only the alias query Φ=alias?(lsp25,fsp22).
Based on the points-to edges of the variables involved, using
the ISPG in Fig. 2, we can see that the effective query of
Φisφ=(S7,S11). To answer this query, B ASIC ANALYZER
performs backward analysis from the start node S7to check for
a context-sensitive memAlias -path toS11.B ASIC ANALYZER
starts with the ISPG node S7corresponding to lsp25and
reachesS4, the ISPG node pointed by cr15in method
apply() , and from there reaches the nodes pointed by
lr7and br10in methods client3() andclient4()
respectively; the search continues until S11is found. Fig. 6
lists the different paths used by B ASIC ANALYZER starting
fromS7until it reaches S11to answer the query φ; the
analyzer may trace these paths in any order. Clearly, we can
see thatπ1is a context-sensitive memAlias -path from S7to
S11and is a relevant path. However, π3andπ4are different.
Pathπ3: This is not even a valid path and is not nec-
essary to the query because of the following two reasons:S6 S4entry16S5entry16S6 S4entry16S2entry12
S6 S4entry16S1entry9O2entry13
entry2exit 13S9 3
7
7π2:
π3:
π4:S7sp
S3sp
S7sp
S7spS6 S4entry16S2entry12O4entry6 entry5S10 3 π1:S7sp
S11sp
S8
Fig. 6: Paths traversed on Fig. 2 for Φ=alias?(lsp25,fsp22).
(1) Consider the subpath S7→S6→S4→S1ofπ3.
The string on this subpath is spentry16entry9, where
the type of S1isLineRenderer and the type of S7
isShadowPaint , which indicates that LineRenderer
has a ﬁeld sp of type ShadowPaint . However, from the
code in Fig. 1, we can see that only BarRenderer has a
ﬁeld sp of type ShadowPaint and the subpath traversal
happened because of the upcast at the virtual call at Line 16.
(2) Consider the subpath S6→S4→S1ofπ3. The
string of this subpath is entry16entry9and hence is a
context-sensitive memAlias -path from S6toS1. Therefore,
it is expected that the types of S6andS1are compati-
ble (same type or one is a subtype of another). However,
the type of S6isBarRenderer and the type of S1is
LineRenderer ; both are not compatible types but are
subtypes of ChartRenderer . Again, in this case, the invalid
path is resulting due to the underlying implicit type cast.
Pathπ4: Likeπ3even this path is invalid, but because of
a different reason: Consider the subpath S6→S4→S5of
π4. It is traversing back from S6which belongs to method
BarRenderer:paint toS5which belongs to method
LineRenderer:paint . As the entry edges to callees
LineRenderer:paint andBarRenderer:paint in
the ISPG are added for the same call site at Line 16 in
Fig. 1, the information from LineRenderer:paint cannot
propagate to BarRenderer:paint at runtime and hence
the subpath S6toS5and thereby path π4are invalid paths.
When processing the entry and exit edges, B ASIC ANALYZER
does not recognize the paths across different target callees of
the same virtual call site and hence allows such invalid paths.
To summarize, we see that even though B ASIC ANALYZER
traverses paths like π3andπ4, such paths are “irrelevant” for
answering the query Φ. These irrelevant traversals affect the
performance as well as the precision of the demand-driven
939
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. Query Uniﬁer
AutoAnswerer
BATCH ANALYZERAlias InformationAlias Queries
{φ1,φ2...φN}
Batch Queries {G1,G2...G M}
Fig. 7: Block diagram of the batch alias analysis framework.
analysis. Further, it is challenging to detect such irrelevant
paths for an on-the-ﬂy query during the analysis. Note that
context-sensitivity cannot capture these invalid paths as it
checks only for matching call/return pairs and all the invalid
paths discussed above respects (do not violate) this check. This
paper proposes a general type-information based technique to
avoid processing of such irrelevant paths which can be applied
to any pointer-analysis-based analysis to improve its precision
and performance. We call our technique as S MART ANALYZER .
We discuss B A TCH ANALYZER , our batch alias analysis
technique, in Section IV and S MART ANALYZER , our opti-
mized demand-driven alias analysis technique, in Section V.
IV . B AT C H ANALYZER
We now discuss the details of our proposed batch analysis
framework, which can use a plugged-in demand-driven anal-
yser (for example, B ASIC ANALYZER ,o rS MART ANALYZER
discussed in Section V) to efﬁciently answer batch queries,
by avoiding redundant computation. As discussed in Sections I
and III, in batch analysis all the possible alias queries from
a client are known in advance. Note that a na ¨ıve way to
reduce the redundant computations across different queries is
to cache all the intermediate traversed paths [20] and reuse
them upon re-analysis. However, such techniques store a lot
of information (not-scalable) which may or may not be reused
in future; B AT C H ANALYZER overcomes these challenges.
Fig. 7 depicts our batch alias analysis framework. Our
approach consists of two steps: (1) Query uniﬁcation: to group
the queries into a set of batch queries to make them more
amenable to batch processing. (2) Answering batch queries
by using the insights of batch analysis and the underlying
demand-driven analysis engine.
Batch Query Generation. Figure 8 shows the core of our
batch alias analysis framework. We group a subset Gof
standard alias queries to a batch query such that the redundant
computations are eliminated completely across the queries in
G. The function unifyToBatchQrys depicts how the batch
queries are created. The input to the function is the set of all
effective queries {φ1,φ2,...,φ N}of the input alias queries
{Φ1,Φ2,...,ΦN/prime}. Note that N≥N/primebecause an alias query
Φican have more than one effective query if a variable in Φi
points-to more than one symbolic/allocation node in the ISPG.
Answer to Φiis true if at least one of its effective queries’
answer is true and is false when all of its effective queries’
answers are false. The function unifyToBatchQrys treats
the effective queries (n1,n2)and(n2,n1)as the same query.
The function unifyToBatchQrys uniﬁes the effec-
tive queries into groups such that all the effective queriesInput : Q={(ni,mi)}N
i=1,N= number of effective queries
Output:{rj}N
j=1whererjstores the boolean value of φ(nj,mj)
1procedure batchAnalysis( Q)
2S=unifyToBatchQrys( Q);
3 foreachG∈Sprocessed in the order of decreasing size do
4 autoAnswer( G);
5 batchQryCheckAliasing( G);
6function unifyToBatchQrys( Q)//Q={(ni,mi)}K
i=1
7G←{ } ;
8 foreach(nx,mx)∈Qdo{cnt(nx)++;cnt(mx)++;};
9 max←nodeWithMaxCnt (cnt,n 1,...,n K,m1,...,m K);
10 foreach(nx,mx)∈Qdo
11 ifnx=maxormx=max thenG←G∪{(nx,mx)};
12 return{G}∪unifyToBatchQrys( Q−G);
Fig. 8: Batch Alias Analysis
Input : G={(nk,m1),(nk,m2),···(nk,mM)}
Output:{rj}N
j=1whererjstores the boolean value of φ(nk,mj)
1procedure batchQryCheckAliasing( G)
2D←{m1,m2,...,m M};WL←{(nk,∅,∅)};
3 while WL/negationslash=∅do
4 remove(n,fldStk n,cxtStk n)from WL
5(fldStk,cxtStk )←clone(fldStk n,cxtStk n)
6 foreachedge∈n.Edges do
7 ignorePath ←processEdge( edge,ﬂdStk,cxtStk )
8 ifignorePath /negationslash=true then
9 n2←neighbour (e,n 1);
10 if∃mj∈Ds . t .m j=n2∧fldStk=∅then
11 D←D−{mj};rj←true ;
12 ifD=∅then return ;
13 WL←WL∪{n2,fldStk,cxtStk )};
14 foreachmj∈Ddorj=false ;
Fig. 9: Alias analysis for batch queries
with a common node in them are uniﬁed into the same
group. Each such group becomes a batch query. How-
ever, two effective queries with a common node may
still be present in two different groups. For example,
if the set Q of input queries to the function are:
{(a,b),(c,a),(d,c),(m,n),(p,q),(c,r),(a,m)}. Here,(c,a)
can be included in the group where (a,b)is present or in
the group where (d,c)is present. The function breaks such
ties by greedily grouping the query with the group that can
have higher number of queries in it (See lines 9-11); note:
cnt is a local array. Thus, the set of batch queries for Qis:
{{(a,b),(a,c),(a,m)},{(c,d),(c,r)},{(m,n)},{(p,q)}}.
Answering Batch Queries. Given a batch query Gwith
queries sharing a common node, and an underlying demand-
driven alias analyzer (for example, S MART ANALYZER ), we
now discuss how B AT C H ANALYZER answers these queries.
As shown in Fig. 8, we ﬁrst check if Gcan be answered
based on the queries answered so far; we do so by invoking
the function autoAnswer . If not, we invoke the function
batchQryCheckAliasing . We process the groups in the
decreasing order of their size. If the group has only ele-
ment, the function batchQryCheckAliasing invokes the
checkAliasing function of the underlying demand-driven
analysis (for example, Fig. 3) – not shown explicitly.
940
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. n1 n2n3n4
n5
n6 n7
Fig. 10: Alias analysis paths in the ISPG.
In B A TCH ANALYZER a batch query is formulated as a
single-source multiple destination CFL-reachability problem.
Hence, batchQryCheckAliasing in Fig. 9 works similar
to function checkAliasing in Fig. 3. The function starts
from a common start node nkand searches for the destination
nodes of all individual effective queries in the batch query
G. An individual query in Gterminates at Line 11 when a
context-sensitive memAlias -path is found to its destination
node, otherwise it terminates at Line 14. When the function
terminates, all the individual queries in Gare answered. Unlike
BASIC ANALYZER ,B A TCH ANALYZER performs no redundant
traversals across the queries in G, because B AT C H ANALYZER
never re-traverses the common paths across the queries in G
unless the retraversal is required even for B ASIC ANALYZER
to solve an individual query. Here, we can see the advantage
of a batch analysis in which the redundant traversals across
different queries can be avoided without caching.
AutoAnswerer (Fig. 7) attempts individual effective
queries using prior solved queries. For example, if
alias?(n1,n2)=alias?(n2,n3)=true,⇒alias?(n1,n3)=true.
Thus, we can see that B A TCH ANALYZER avoids redundant
path traversals, without caching any intermediate results, by
treating a set of individual queries in a batch query as a single-
source multiple destination CFL-reachability problem instead
of treating it as many single-source single destination CFL-
reachability problems and AutoAnswerer further avoids
redundant path traversals.
Discussion: We brieﬂy describe the differences/similarities
between CACHE (see Section II) and the batch analysis
technique, using the graph in Fig. 10 that shows ISPG nodes
withmemAlias -paths joining them. Note that we use CACHE
to compare (and not its precursor [20]) as CACHE takes the
input demand-driven queries into consideration for caching.
Consider the batch query G1=(n1,{n4,n5,n7}). Here,
the batch analysis will traverse each of the paths in the graph
only once. In contrast, CACHE re-traverses the paths n1/squigglerightn2
andn2/squigglerightn3across the queries in G1:(n1,n4),(n1,n5)and
(n1,n7); here, path n2/squigglerightn3may also be traversed when
answering (n1,n7)because the traversal is performed in BFS
(breadth-ﬁrst search) manner. However, say, if a batch query
G0=(n3,{n4,n5})is solved before G1, batch analysis re-
traverses the paths n3ton4andn3ton5, whereas CACHE
reuses those paths if the individual queries in G0are solved
before solving the individual queries in G1. Hence, in theory,
neither of the techniques is more precise than the other (see
Section VI for an empirical comparison). Note that caching
can complement batching. For example, the answers to the
individual queries (n3,n4)and(n3,n5)ofG0can be cached,
and reused when solving a latter batch query, like G1.Statement Type Information
Alloc: x=new()
Copy: x=yτ1=typ(x)∧τ2=(typ(new())∨typ(y))
⇒τ2∈cmpt({τ1})∧τ1∈cmpt({τ2})
Load: x=y.f
Store: y.f=xτ1=typ(x)∧τ2=typ(y)
⇒τ2◦τ1[τ2encloses τ 1]
Call: r=
a0.m(a1,..,ai,..)Equivalent to assignments: fi=ai,r=
mret; where fiis theithformal parameter
ofmandmretis the variable returned in m
Fig. 11: Type relations in the statements that affect points-to
information. typ(e)returns the static type of expression e.
V. S MART ANALYZER
In this section, we use a novel type-based approach to
reduce the irrelevant work performed during demand-driven
analysis. Our approach is based on identifying relevant types
for the queries and by detecting edges that need not be
traversed (termed imaginary adjacent ISPG edges ).
A. Relevant Types
Our goal now is to provide a general scheme to avoid
demand-driven alias (or points-to) analysis via invalid paths
that occur due to upcasting and downcasting in codes written
in languages that support subtype polymorphism.
Our strategy is based on identifying the set of relevant types
for a given input query Φ. To avoid traversing irrelevant paths
during backward analysis, we process a node only if the node
has a relevant type with respect to Φ. Our approach is based
on the following two deﬁnitions.
Deﬁnition 1 (Compatible Types). Given a type τ, all the
sub-types and supertypes of τare the compatible types of τ.
Thus, for a set of types T, we compute its set of compatible
typescmpt(T)=T∪{t|tis a sub type or a super type of τ,
whereτ∈T}.
Deﬁnition 2 (Type Enclosing). We say a type τ/primeencloses a
typeτ/prime/primeif there exists a sequence τ1◦τ2◦τ3◦...τ ksuch that
τ1=τ/prime,τk=τ/prime/primeand for all 1≤i<k , there is a ﬁeld of
typeτi+1inτi(represented by τi◦τi+1).
Fig. 11 shows the compatible types and type enclosing
relations in the program statements that affect the points-to
information. For example, for an assignment (copy) statement,
the LHS variable’s type belongs to the compatible types of
the RHS variable and vice versa. For a store statement, the
base variable’s type of the LHS ﬁeld access encloses the type
of the RHS variable. The types of actual arguments and of
LHS variable at a call statement relate to the types of formal
parameters and of a return expression in the callee, in a
manner similar to that of a copy statement. As the edges in
ISPG are constructed by processing these program statements
(see Section II), entry/exit edges represent compatible type
relations and ﬁeld edges represent type enclosing relations.
Deﬁnition 3 (Declared Types). IfΦ=alias?(a,b)is an
input query and τ1is the declared-type of variable aandτ2
is the declared-type of variable b, then we deﬁne the set of
declared-types {τ1,τ2}asDtype(Φ).
941
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. Deﬁnition 4 (Relevant Types). We deﬁne the set of relevant
types for a given query Φas:cmpt(D)∪cmpt(E), whereDis
theDtype(Φ) andE={τ|τenclosesτ/primeandτ/prime∈cmpt(D)}.
LetΦ=alias?(a,b)is the input query and φ=(S1,S2)
is one of the effective queries of Φ. A context-sensitive
memAlias -path ofΦstarts from S1whose declared-type is
sayτ1and passes through intermediate nodes connected via
ﬁeld edges that represent type enclosing relations w.r.t. τ1,o r
entry/exit edges that represent compatible type relations and
ﬁnally reaches S2whose declared type is say τ2. Thus, the
set of relevant types for Φ(where, Dtype(Φ) ={τ1,τ2})
captures the set of types of the nodes that can appear in a
context-sensitive memAlias -path of Φ. A context-sensitive
memAlias -path has the following key property:
Property 1. If a pathπis a context-sensitive memAlias -path
for a query Φ, then a node nappears in πiffstatic -type(n)∈
Rtype , where Rtype =set of relevant types for Φ.
Our S MART ANALYZER computes relevant types and uses
Property 1 to answer a query Φ. It processes the edges
(by calling processEdge() , Section II) connected to a
node in the worklist only if its type is in the set of relevant
types of Φand thus avoids the irrelevant paths that can
be taken by B ASIC ANALYZER . We now demonstrate the
same on the example query Φ=alias?(lsp25,fsp22)from
Section III. Here, Dtype(Φ) ={ShadowPaint }, and the
set of relevant types of ΦisRtype={ShadowPaint,
BarRenderer, ChartRenderer, Object }.Rtype
includes BarRenderer as it encloses ShadowPaint
and includes {ChartRenderer, Object }because they
are the comaptible types of BarRenderer . Consider the
pathsπ1andπ3in Fig. 6 traversed by B ASIC ANALYZER
for answering the query Φ. Pathπ1is a context-sensitive
memAlias -path and hence the types of nodes in path π1
{ShadowPaint ,BarRenderer ,ChartRenderer }are
included in the set Rtype .A s LineRenderer , the type
of node S1inπ3, is not included in the set Rtype , path
π3cannot be a context-sensitive memAlias -path for Φand
hence it is not relevant to Φ. Similarly, path π4in Fig. 6
is not relevant to Φ.S MART ANALYZER avoids traversing
through paths π3andπ4, thereby reducing the search space.
Note that the idea of relevant types is not speciﬁc to CFL-
reachability-based demand-driven alias analysis and is directly
applicable to any demand-driven points-to/alias analysis as the
data-ﬂow in all these analyses is similar.
B. Imaginary Adjacent Edges
Our goal now is to detect and thereby avoid invalid path
traversals discussed in Case 2 in Section III-B, which happens
whenever there are multiple target callees at a virtual call site.
Letφ=(S1,S2)be an effective alias query. Let us
consider a method mcaller which calls a method mcallee at
a call site x. Letpbe a path from S1which has an edge
e1=(n1,n2)in it such that n1is inmcallee andn2is
inmcaller . Pathpis an invalid path if the edge e1has anadjacent edge e2=(n2,n3)inpsuch that n3is inm/prime
callee ,
wherem/prime
callee/negationslash=mcallee is another target callee of mcaller
at the same call site x. Hence, we focus on detecting such
imaginary adjacent edges to avoid invalid paths. In particular,
we look for adjacent edge pair (e1,e2)in pathp:S1.n1.e1n2.
e2n3.nk.(edge directions are omitted for simplicity), where
n1is inmcallee ,n2is inmcaller ,n3is inm/prime
callee , andmcallee
andm/prime
callee are the target callees of mcaller at the same call
sitex. We take this into consideration by noting that as we
are interested in a traversal from a callee to a caller and
again to a callee, e1ande2should have opposite directions.
Thus, we ignore paths with ( e1,e2) pair having edge labels as
(entry x,entry x)o r(exit x,exit x). To identify such adjacent
edge pair combinations, S MART ANALYZER memoizes the last
processed edge. It marks the edges with unique IDs to store the
call site information. Thus, S MART ANALYZER further reduces
the search space over that obtained using relevant-types, by
eliminating invalid paths due to imaginary adjacent edges.
VI. I MPLEMENTA TION AND EV ALUA TION
Implementation. Our algorithms are implemented [25] by
extending the Soot [26] framework We consider the following
seven variants for our evaluation. BASIC: Fig. 3, existing
BASIC ANALYZER [2]; RT: Fig. 3 with use of relevant types
(Section V-A); VC: Fig. 3 with only valid paths at virtual
call sites (Section V-B); SMART: SMART ANALYZER , Fig. 3
with extensions in RT and VC; BATCH: BA TCH ANALYZER
using BASIC in Fig. 8 and S-BATCH: BA TCH ANALYZER
using SMART in Fig. 8. CACHE: Fig. 3 with Fig. 4 and with
caching option enabled. We used the implementations of Yan
et al. [2], [23] for BASIC and CACHE. Note that we do not
choose the recent demand-driven works [14], [21] as baselines
for our work, as they are not suitable (we found them to take
signiﬁcantly more time, compared to BASIC) for data-race
kind of clients that require simpler alias information.
We investigate the following three research questions:
RQ1: Is batch analysis efﬁcient compared to a conventional
demand-driven analysis? RQ2: Is batch analysis beneﬁcial
compared to caching? RQ3: What is the impact of eliminating
irrelevant paths on the precision and the performance of a
demand-driven analysis?
Experimental Setup. We have run all our experiments on
an AMD 2.3GHz machine by allocating 64GB heap space to
the JVM. For RQ1, we evaluate our techniques on two clients:
(1) a data-race detection tool (simulated), and (2) a refactoring
tool (existing). For RQ2 and RQ3, we only use the data-race
detection client. For all the RQs, the set of all the queries for
a benchmark is collected and passed as an argument to the
function batchAnalysis (see Fig. 8).
We simulate a data race detector client as done by Yan et
al. [2] by considering all the queries of the form alias?(x,y)
where for some ﬁeld f,x.f andy.f are accessed in
two program statements (Soot’s jimple IR statements) of the
application code with at least one statement in the two being a
ﬁeld write operation. For this client, we evaluate our technique
using twelve Java programs from the DaCapo benchmark
942
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. DaCapo 2006 DaCapo 2009 Used by Client
Bench #RM Bench #RM Bench #RM
antlr 24190 avrora 10693 avrora 33780
bloat 13365 luindex 9730 fop 48780
chart 29017 lusearch 9612 javaGeom 27166
eclipse 12107 pmd 13448 JFreeChart 29137
fop 25252 jOcular 33059
hsqldb 28231 Rackj 15789
jython 18926 sunﬂow 28530
xalan 24121 UR 24434
Fig. 12: Benchmarks used for the experiments. #RM (#Reach-
able methods) is as computed by Spark [1].
suite [27]. We have used (i) four benchmarks from the latest
DaCapo version (dacapo-9.12-MR1-bach.jar) – all the ones
that could be processed by the TamiFlex [28] (to eliminate
reﬂective calls) and Soot combination, and (ii) eight non-
overlapping ones from DaCapo 2006, as listed in the ﬁrst and
the third columns of Fig. 12. The ﬁgure also lists the number
of callgraph reachable methods as computed by Spark [1].
Next, we consider an existing client Auto-SCST [5], a
program understanding tool which automatically identiﬁes
refactoring opportunities for two important refactorings ‘re-
place type code with subclass’ (SC-refactoring) and ‘replace
type code with state’ (ST-refactoring) that are required for per-
forming ‘replace conditional with polymorphism’ refactoring.
For many client analyses such as Auto-SCST [5], CHORD [4],
and so on, the alias queries can come in batches. Auto-SCST
has strict time budgets to identify the refactoring opportunities
because it is an Eclipse-plugin (IDE plugin). The tool classiﬁes
an identiﬁed refactoring opportunity, represented using the
class and ﬁeld pair /angbracketleftC,f/angbracketright, for ST-refactoring if there is a
control path from a read dereference x.f to a write dereference
y.f, both the dereferences refer to the ﬁeld fofC, andxandy
are aliases. Since the refactoring opportunities are independent
of each other, and all the opportunities are identiﬁed before
displaying to the developer, the set of all the queries is avail-
able (as input to batchAnalysis , Fig. 8). For Auto-SCST,
we use the eight open-source applications used by V edurada
and Nandivada [5], [29]. The last two columns in Fig. 12 show
the details of the applications. Note that for the overlapping
benchmarks, the entries in fourth column are different from
that of the ones in the last column, owing to the differences
in benchmark versions and the callgraph conﬁgurations.
For all the experiments, we use the cutoff used by by Yan
et al. [2] and set the budget as 75000 traversed ISPG nodes
for: (i) each demand-driven query in case of BASIC and (ii)
each batch-query in case of BA TCH and S-BA TCH. We also
enable summarization (to memoize intermediate method-level
summaries/results) for all the library methods.
A. RQ1: Beneﬁts of Batch Analysis
We ﬁrst discuss about the analysis times of BASIC, BA TCH,
and S-BA TCH, and then about their precision on the data-
race detection client followed by on the client Auto-SCST.
Fig 13 and Fig. 14 show the comparison of the time takenby the implementations and of their precisions, respectively.
The second column in Fig. 14(a) lists the number of alias
queries coming from the data-race client for each benchmark
and the third column lists the number of their corresponding
batch queries. We can see that the number of batch queries are
quite less than that of the actual queries; this is because of the
query-uniﬁer step in the batch analysis framework. Similarly,
in Fig. 14(b), columns 2 and 3 list the number of alias queries
generated by Auto-SCST and resulting batch-queries.
Results on Data-race Detection Client. Fig. 13(a) shows the
analysis times of all the three implementations to answer the
alias queries. BA TCH runs geomean 77.51% (up to 95.8%)
faster than BASIC and S-BA TCH runs geomean 83.14% (up
to 96.1%) faster than BASIC. S-BA TCH performs geomean
12.13% (up to 45.64%) faster than BA TCH showing the impact
of eliminating irrelevant path traversals.
We have studied the number of budget exceptions of all
the three implementations (detailed plots skipped for space).
We found BA TCH and S-BA TCH lead to 85.52%, and 87.8%
(geomean) less budget exceptions than BASIC, respectively –
points to the performance improvements and scalability due
to the batch alias analysis. Note that the percentage reduction
in the number of budget exceptions is due to the batching of
queries. For example, say, out of a given set of ten demand-
driven queries six got timed-out with BASIC. If these ten are
grouped as a single batch query then BA TCH would timeout
only once, as they are all solved together. Thus, the number of
budget exceptions reduce from six to one (hence would lead to
overall faster execution). Note that BASIC and BA TCH would
give the same answer for the remaining four.
Columns 4, 8 and 9 in Fig. 14(a) show the precision of all
the three implementations. Each entry shows the number of
‘true’ answers of the data race queries and thus indicate the
number of possible data races; lower the number, higher the
precision. BA TCH reports up to 1.12% less data races than
BASIC (see avrora ). The precision of BA TCH and BASIC
varies slightly because BA TCH transforms some effective
queries from (a,b)to(b,a)form during the uniﬁcation step
(see Section IV). Because of this swapping, BA TCH may avoid
hitting budget exceptions in some cases – leads to improved
precision. However, such swapping may also lead to newer
budget exceptions or encounter static globals in the backward
analysis and conservatively answers ‘true’ – leads to reduced
precision. For example, for the program hsqldb , BA TCH
reports two more data races than BASIC; but we found that
number of such cases have been very minimal. Similar to
BA TCH, S-BA TCH reports up to 10.22% less data races than
BASIC (for xalan ) and reports 0.28% more data races for
luindex . We found that, overall, BA TCH and SBA TCH
report minor improvements in precision: 0.07% and 0.61%
(geomean) less data races than BASIC, respectively.
Summary. Overall, compared to BASIC, over DaCapo
benchmarks, BA TCH and S-BA TCH run 77.5% (up to 95.8%)
and 83.1% (up to 96.1%) faster, respectively, with minor
precision gains; attests to the importance of batch analysis.
943
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 10100100010000
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdTime [sec] (log scale)BASIC
BATCH
S-BATCH
(a) Impact on data race queries (on DaCapo benchmark suite).1101001000
avrora fop geom jfree jocular rackj sun
owunicodeTime [sec] (log scale)BASIC
SMART
BATCH
S-BATCH
(b) Impact of batch analysis on queries from Auto-SCST.
Fig. 13: Timing comparison (in seconds).
1 2 3 4 5 6 7 8 9
Bench #Alias #Batch Precision
Queries Queries BASIC RT VC SMART BA TCH S-BA TCH
antlr 8594 283 4941 4941 4941 4941 4941 4941
bloat 51158 974 51110 51110 51103 51103 51109 51102
chart 2475 338 2407 2248 2407 2242 2407 2243
eclipse 2516 306 2418 2418 2418 2418 2414 2414
fop 899 105 899 899 899 899 899 899
hsqldb 15422 729 14730 14730 14724 14724 14732 14726
jython 9413 615 9103 9103 9103 9103 9090 9090
xalan 988 105 930 930 835 835 930 835
avrora 16720 527 15920 15920 15911 15911 15742 15741
luindex 2627 295 2531 2531 2531 2531 2538 2538
lusearch 1913 253 1884 1884 1884 1884 1883 1883
pmd 35547 365 35531 35531 35531 35531 35531 35531
(a) Precision on data race queries.1 2 3 4 5 6 7
Bench #Alias #Batch Precision
Queries Queries BASIC SMART BA TCH S-BA TCH
avrora 6136 248 4984 4984 4761 4761
fop 781 155 519 518 540 539
javaGeom 158 13 137 137 134 134
JFreeChart 748 146 654 654 654 654
jOcular 243 25 180 180 185 185
RackJ 75 9 29 29 29 29
sunﬂow 75 22 75 75 75 75
UR 62 14 36 36 42 42
(b) Precision on queries from the client Auto-SCST.
Fig. 14: Precision comparison in terms of the number of aliases detected (lower the better).
Results on Auto-SCST. SMART, BA TCH and S-BA TCH show
similar performance and precision improvements over BASIC
on Auto-SCST. Fig. 13(b) shows the analysis times of all the
four implementations on Auto-SCST. SMART, BA TCH and
S-BA TCH run 1.75%, 31.94%, and 33.3% (geomean) faster
than BASIC, respectively (and up to 29.35%, 88.15%, and
90.81% faster than BASIC, respectively). In terms of number
of budget exceptions, SMART, BA TCH and S-BA TCH have
3.7%, 73%, and 78.03% (geomean) less budget exceptions
than BASIC, respectively.
In Fig. 14(b), columns 4-7 list the number of ‘true’ answers
for the alias queries. SMART, BA TCH and S-BA TCH report
up to 0.19% ( fop ), up to 4.47% ( avrora ) and up to 4.47%
(avrora ), respectively, less aliases than BASIC. In UR,fop ,
andjocular the reason for precision losses of BA TCH and
S-BA TCH is again because of the swapping of queries in the
uniﬁcation step. We found that, overall, SMART reports 0.02%
(geomean) less data races than BASIC, and BA TCH and S-
BA TCH report 5.46%, and 5.44% (geomean) more data races
than BASIC. The geomean percentages for BA TCH and S-
BA TCH are mainly biased by the precision differences in UR.Summary. The performance improvements show the beneﬁts
of batch analysis over demand-driven analysis and the need
for a batch analysis framework, for real-world clients like
Auto-SCST, to answer alias queries in batch mode.
Discussion. For the tested benchmarks, auto-answerer (see
Section IV) had no impact. But in practice, we can easily
visualise cases where auto-answerer can be impactful. Hence,
we keep the auto-answerer step intact, especially considering
minimal overheads due to auto-answerer.
B. RQ2: Batch Analysis vs Caching
We now compare BA TCH and S-BA TCH against CACHE
(see Section II) to show the performance of our batch analysis
technique against caching. As it is known, the performance
of CACHE may depend on the order of queries. For each
benchmark, we use the data-race queries obtained by iterating
over the methods in the order as given by the SPARK call
graph (as used by Yan et al. [2]).
Fig. 15 shows the performance of CACHE against BASIC,
BA TCH and S-BA TCH on the queries from the data-race de-
tection client. CACHE performs 20.37% (geomean) better than
BASIC whereas BA TCH and S-BA TCH perform 77.51% and
83.14% (geomean) better than BASIC, respectively. Clearly,
944
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 10100100010000
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdTime [sec] (log scale)BASIC
CACHE
BATCH
S-BATCH
Fig. 15: Caching against batch analysis on data race queries.
our batch analysis techniques outperform CACHE; In terms
of the number of budget exceptions, CACHE, BA TCH and
S-BA TCH have 48.48%, 85.52% and 87.8% (geomean) less
budget exceptions than BASIC, respectively, asserting the
improvements in analysis timings. In case of hsqldb , we see
that caching shows negative effects which can happen when
the beneﬁts from reusing the cached entries get subsumed
by the cost of searching the cached entries. We have also
tried enabling caching for BA TCH and for S-BA TCH, and
we observed that caching has minimal impact on batching
techniques (BA TCH improved by 0.38%, S-BA TCH’s per-
formance decreased by 7.6% (geomean)). This shows that
our batch analysis technique subsumes most of the beneﬁts
of caching. In terms of precision, CACHE reports 0.02%
(geomean) more data races than BASIC, whereas BA TCH and
SBA TCH reported 0.07% and 0.61% (geomean) less data races
than BASIC, respectively. Note that the reason for precision
loss for CACHE (compared to BASIC) is because of not
differentiating the cached queries of form (a,b)with their
swapped form (b,a)during reuse (similar to batch analysis).
Summary. Overall, compared to CACHE, BA TCH and
S-BA TCH run 54.54% and 70.3% faster, respectively. We
argue that batch analysis technique mostly subsumes the
beneﬁts of caching and outperforms it.
C. RQ3: Performance of SMART ANALYZER
We ﬁrst discuss about the analysis times of the implemen-
tations BASIC, SMART, RT and VC, and then about their
precision. Fig. 16 shows the analysis times of all the four
implementations to answer the alias queries. SMART performs
10.97% (geomean) better than BASIC (up to 54.36% better).
We explain the reasons behind the performance difference by
studying the performance of RT and VC.
In Fig. 16, it can be seen that for most of the benchmarks RT
and VC perform better than BASIC. The reason for RT and
VC not showing performance beneﬁts over BASIC in some
cases is the following: BASIC may conservatively answer an
alias query as ‘true’ via an irrelevant path, whereas RT or
VC may try for the precise answer ‘false’ by searching a
much longer ‘relevant’ search space – can be expensive. For
example, in the case of the program chart , RT takes 16.3%10100100010000
antlr bloat chart eclipse fop hsqldb jython xalan avrora luindex lusearch pmdTime [sec] (log scale)BASIC
RT
VC
SMART
Fig. 16: Impact of irrelevant path elimination (DaCapo suite).
Bench Total types Avg %A v g Time (msec)
Relevant types Relevant types
antlr 5865 4109 70.0 722
bloat 3204 2191 68.4 948
chart 6642 4722 71.0 1240
eclipse 3261 2255 69.1 513
fop 8109 5850 72.1 646
hsqldb 6349 4478 70.5 1401
jython 4299 3127 72.7 975
xalan 6404 4543 70.9 530
avrora 3418 2326 68.0 855
luindex 3136 2066 65.8 383
lusearch 3121 2045 65.5 363
pmd 3792 2453 64.6 413
Fig. 17: Details on the computed relevant types.
more time than BASIC (also realizes improved precision, see
Fig. 14(a)). In Fig. 17, we show that the overheads of the RT
implementation cannot be the reason for such performance
degradation. Fig. 17 lists the total time taken by RT to ﬁnd
the relevant types for all the queries (in last column) and the
average number of relevant types for a query (in third column).
We can see that the average time taken by RT to ﬁnd relevant
types is almost negligible. RT performs up to 11.3% (lusearch)
better than BASIC; geomean = −0.43%; the negative value is
mainly because of the difference in performance on chart .
VC performs geomean 9.01% (up to 54%) better than BASIC.
In Fig. 14(a), columns 4-7 show the precision of all the
four implementations. SMART reports up to 10.2% less data
races than BASIC (for xalan ). SMART can be more precise
than BASIC when SMART ﬁnishes the search within the time
budget and: (1) BASIC fails to ﬁnish because of irrelevant
traversals, or (2) BASIC conservatively hits a static global
or a destination node via an irrelevant path. For the chart
program, the 16.3% performance loss of RT can be attributed
to the 6.61% precision improvements for that program. VC
also shows up to 10.2% precision improvements. We found
that, overall, RT, VC and SMART report 0.18%, 0.23% and
0.47% (geomean) less data races than BASIC, respectively.
Summary. Overall, compared to BASIC, SMART runs
10.97% (up to 54.36%) faster with minor precision gains, on
945
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. DaCapo benchmarks. It shows that demand-driven analyses
can be made performant by avoiding irrelevant path traversals.
VII. R ELA TED WORK
There exist many prior works on alias/points-to analysis.
Sridharan et al. [7] present a survey of the alias analy-
sis techniques for object-oriented programs. Ryder [30] and
Hind [8] present insightful discussions on different dimensions
on pointer analysis. In this section, we mainly focus our dis-
cussion to the works that are closely related to our approach.
Demand-driven Points-to/Alias Analyses. Many
researchers [11]–[13], [15], [20] have focused on improving
the scalability of demand-driven points-to analysis based on
CFL-reachability to suit the environments like just-in-time
(JIT) compilers and interactive development environments
(IDEs). Past works [2], [16] further improved the performance
of CFL-reachability based solution by answering the alias
queries directly without computing the points-to information
and show that for answering may-alias queries, a demand-
driven alias analysis is more efﬁcient than a demand-driven
points-to analysis. Boomerang [14] is a demand-driven, ﬂow-,
ﬁeld- and context-sensitive pointer analysis built on top of the
IFDS (Interprocedural Finite Distributive Subset problems)
framework. It supports all-alias (to ﬁnd all aliases of a
given variable along with its points-to information) queries
that are required for the clients like taint analysis. Since it
requires all-alias queries, in cases of simple demand-driven
points-to/alias queries, it can perform more work than that
required to answer the input demand-driven queries. Recently
Sp¨ath et al. [21] have presented a demand-driven, ﬂow-, ﬁeld-
and context-sensitive pointer analysis which encodes context-
sensitivity and ﬁeld-sensitivity as a separate “synchronized”
CFL reachability problems using the concept of synchronized
pushdown systems (SPDS). All these techniques answer one
query at a time (fully on-demand) and none of them exploit
the resulting advantages when the queries come in batch.
These works perform ad-hoc caching (or summarization)
to avoid redundant computations across different queries
without exploiting the availability of queries in advance in
batch mode. Hence they suffer from storing unnecessary
information and/or from missing to store useful information
across different queries leading to performance losses.
We overcome these challenges by proposing a batch analysis
framework that can handle multiple queries in a batch mode.
We instantiate a “batch version” of the popular demand-driven
analysis of Yan et al. [2]. We have observed the recent demand-
driven works [14], [21] although more precise than that of
Yan et al. [2], do not suit for clients where the number of
alias queries is large. Further, most of the techniques discussed
above suffer from the issue of irrelevant path traversals, which
is addressed in this paper.
Analyses that Handle Queries in Batch. Su et al. [15] pro-
posed a parallel algorithm to CFL-reachability-based demand-
driven, context-sensitive points-to analysis to meet the re-
quirements of clients where the queries come in batch. The
technique processes the queries independently on differentcores allowing some data-sharing across different queries
based on few heuristics. In this paper, we propose a sequential
algorithm which processes multiple queries together in one
pass as a batch query. Hence, our technique does not require
data sharing across individual queries in a batch query.
There have been prior works (not demand-driven) that
present target client-speciﬁc solutions [31], improving the
precision based on a complete set of queries [32]–[35]. In
contrast, we present a scheme to improve the performance
and precision by exploiting the underlying features of batch
queries. Their techniques are complimentary to our approach.
Type-based Optimizations in Points-to/Alias Analyses. Di-
wan et al. [36] use type information and propose different alias
analyses for Modula-3, a statically-typed type-safe language.
For Java, many past works [1], [7], [11] perform type-based
checks to avoid invalid data-ﬂow paths and thus improve
the precision and efﬁciency of the points-to analysis. The
work of Sridharan et al. [11] (hereafter referred to as SRI)
uses type-based optimizations that subsumes the ones used
by Lhot ´ak and Hendren [1], and Sridharan et al. [7]. The
type-based checks of SRI use compatible types to avoid
marking possible aliasing nodes in two phases: (1) during a
whole-program pre-analysis by avoiding the addition of some
“match” edges, ahead of time (not dependent on demand-
driven queries), (2) on-the-ﬂy when answering a points-to
query by not considering nodes whose types are incompatible
with the type of the query variable. In contrast, we consider
enclosing types along with compatible types (used in SRI)
for constructing the set of relevant types with respect to the
given demand-driven queries and use them to avoid traversing
irrelevant paths in the ISPG.
VIII. C ONCLUSION
Demand-driven analyses can be costly when applied on
large systems where the number of queries is high. This is
not acceptable in cases when the clients of the analyses are
plugged into an IDE-kind of resource-bound environments.
We propose the idea of batch alias analysis that can efﬁ-
ciently address such clients by avoiding redundant computa-
tions within batch queries. Batch analysis suits the environ-
ments with strict time constraints, where the queries come
in batch. Our proposed techniques (publicly available [25])
improve the performance by avoiding redundant and irrelevant
computation. Our evaluation shows that the proposed batch
analysis leads to signiﬁcant performance gains, along with
minor gains in precision. We also show that the elimination of
irrelevant search paths can improve the performance and the
precision of the demand-driven alias analysis of Yan at al. [2]
(the best one suitable for race-detection type of clients).
ACKNOWLEDGMENT
We thank the shepherd, the PC chairs and all the reviewers
for their valuable comments. We thank Dacang Yan, Harry
Xu and Atanas Rountev for making their code publicly avail-
able [23]. Jyothi V edurada is supported by the TCS Research
Scholarship Program for her doctoral studies.
946
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] O. Lhot ´ak and L. Hendren, “Scaling Java Points-to Analysis Using
Spark,” in Compiler Construction , G. Hedin, Ed. Berlin, Heidelberg:
Springer Berlin Heidelberg, 2003, pp. 153–169.
[2] D. Yan, G. Xu, and A. Rountev, “Demand-driven Context-sensitive
Alias Analysis for Java,” in Proceedings of the 2011 International
Symposium on Software Testing and Analysis , ser. ISSTA ’11. New
Y ork, NY , USA: ACM, 2011, pp. 155–165. [Online]. Available:
http://doi.acm.org/10.1145/2001420.2001440
[3] M. G. Nanda and S. Sinha, “Accurate interprocedural null-dereference
analysis for java,” in 2009 IEEE 31st International Conference on
Software Engineering , May 2009, pp. 133–143.
[4] M. Naik, A. Aiken, and J. Whaley, “Effective Static Race Detection
for Java,” in Proceedings of the 27th ACM SIGPLAN Conference on
Programming Language Design and Implementation , ser. PLDI ’06.
New Y ork, NY , USA: ACM, 2006, pp. 308–319. [Online]. Available:
http://doi.acm.org/10.1145/1133981.1134018
[5] J. V edurada and V . K. Nandivada, “Identifying Refactoring Opportunities
for Replacing Type Code with Subclass and State,” Proc. ACM Program.
Lang. , vol. 2, no. OOPSLA, pp. 138:1–138:28, Oct. 2018. [Online].
Available: http://doi.acm.org/10.1145/3276508
[6] L. O. Andersen., “Program Analysis and Specialization for the C Pro-
gramming Language,” Ph.D. dissertation, DIKU, University of Copen-
hagen, May 1994.
[7] M. Sridharan, S. Chandra, J. Dolby, S. J. Fink, and E. Yahav,
“Aliasing in object-oriented programming,” D. Clarke, J. Noble, and
T. Wrigstad, Eds. Berlin, Heidelberg: Springer-V erlag, 2013, ch.
Alias Analysis for Object-oriented Programs, pp. 196–232. [Online].
Available: http://dl.acm.org/citation.cfm?id=2554511.2554523
[8] M. Hind, “Pointer Analysis: Haven’t We Solved This Problem Yet?”
inProceedings of the 2001 ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools and Engineering , ser. PASTE ’01.
New Y ork, NY , USA: ACM, 2001, pp. 54–61. [Online]. Available:
http://doi.acm.org/10.1145/379605.379665
[9] A. Milanova, A. Rountev, and B. G. Ryder, “Parameterized Object
Sensitivity for Points-to and Side-effect Analyses for Java,” in
Proceedings of the 2002 ACM SIGSOFT International Symposium
on Software Testing and Analysis , ser. ISSTA ’02. New Y ork,
NY , USA: ACM, 2002, pp. 1–11. [Online]. Available: http:
//doi.acm.org/10.1145/566172.566174
[10] S. Z. Guyer and C. Lin, “Client-driven Pointer Analysis,” in
Proceedings of the 10th International Conference on Static Analysis ,
ser. SAS’03. Berlin, Heidelberg: Springer-V erlag, 2003, pp. 214–236.
[Online]. Available: http://dl.acm.org/citation.cfm?id=1760267.1760284
[11] M. Sridharan, D. Gopan, L. Shan, and R. Bod ´ık, “Demand-
driven Points-to Analysis for Java,” in Proceedings of the 20th
Annual ACM SIGPLAN Conference on Object-oriented Programming,
Systems, Languages, and Applications , ser. OOPSLA ’05. New
Y ork, NY , USA: ACM, 2005, pp. 59–76. [Online]. Available:
http://doi.acm.org/10.1145/1094811.1094817
[12] M. Sridharan and R. Bod ´ık, “Reﬁnement-based Context-sensitive
Points-to Analysis for Java,” in Proceedings of the 27th ACM SIGPLAN
Conference on Programming Language Design and Implementation ,
ser. PLDI ’06. New Y ork, NY , USA: ACM, 2006, pp. 387–400.
[Online]. Available: http://doi.acm.org/10.1145/1133981.1134027
[13] L. Shang, X. Xie, and J. Xue, “On-demand dynamic summary-
based points-to analysis,” in Proceedings of the Tenth International
Symposium on Code Generation and Optimization , ser. CGO ’12.
New Y ork, NY , USA: ACM, 2012, pp. 264–274. [Online]. Available:
http://doi.acm.org/10.1145/2259016.2259050
[14] J. Sp ¨ath, L. N. Q. Do, K. Ali, and E. Bodden, “Boomerang:
Demand-Driven Flow- and Context-Sensitive Pointer Analysis for
Java,” in 30th European Conference on Object-Oriented Programming,
ECOOP 2016, July 18-22, 2016, Rome, Italy , 2016, pp. 22:1–22:26.
[Online]. Available: https://doi.org/10.4230/LIPIcs.ECOOP .2016.22
[15] Y . Su, D. Ye, and J. Xue, “Parallel Pointer Analysis with CFL-
Reachability,” 43rd International Conference on Parallel Processing ,
no. ICPP , pp. 451–460, 2014.
[16] X. Zheng and R. Rugina, “Demand-driven Alias Analysis for C,” in
Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages , ser. POPL ’08. New
Y ork, NY , USA: ACM, 2008, pp. 197–208. [Online]. Available:
http://doi.acm.or g/10.1145/1328438.1328464[17] M. Sridharan, “Discussion in Soot mailing list on demand-driven
points-to analyses,” 2006, www.sable.mcgill.ca/pipermail/soot-list/
2006-January/000477.html.
[18] B. K. Rosen, “Linear Cost is Sometimes Quadratic,” in Proceedings
of the 8th ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , ser. POPL ’81. New Y ork, NY , USA:
ACM, 1981, pp. 117–124. [Online]. Available: http://doi.acm.org/10.
1145/567532.567545
[19] M. Hind and A. Pioli, “Which Pointer Analysis Should I Use?”
inProceedings of the 2000 ACM SIGSOFT International Symposium
on Software Testing and Analysis , ser. ISSTA ’00. New Y ork,
NY , USA: ACM, 2000, pp. 113–123. [Online]. Available: http:
//doi.acm.org/10.1145/347324.348916
[20] G. Xu, A. Rountev, and M. Sridharan, “Scaling CFL-Reachability-
Based Points-To Analysis Using Context-Sensitive Must-Not-Alias
Analysis,” in Proceedings of the 23rd European Conference on
Object-Oriented Programming, ECOOP 2009 . Berlin, Heidelberg:
Springer-V erlag, 2009, pp. 98–122. [Online]. Available: http://dx.doi.
org/10.1007/978-3-642-03013-0 6
[21] J. Sp ¨ath, K. Ali, and E. Bodden, “Context-, Flow-, and Field-sensitive
Data-ﬂow Analysis Using Synchronized Pushdown Systems,” Proc.
ACM Program. Lang. , vol. 3, no. POPL, pp. 48:1–48:29, Jan. 2019.
[Online]. Available: http://doi.acm.org/10.1145/3290361
[22] JFreeChart, “A Java Chart Library,” 2017, https://sourceforge.net/
projects/jfreechart/.
[23] “Source Code: Demand-Driven Context-Sensitive Alias Analysis for
Java,” 2013, http://web.cs.ucla.edu/ ∼harryxu/tools/ﬁles/MayAlias.zip.
[24] Y . Lu, L. Shang, X. Xie, and J. Xue, “An Incremental Points-
to Analysis with CFL-Reachability,” in Proceedings of the 22Nd
International Conference on Compiler Construction , ser. CC’13.
Berlin, Heidelberg: Springer-V erlag, 2013, pp. 61–81. [Online].
Available: http://dx.doi.org/10.1007/978-3-642-37051-9 4
[25] J. V edurada and V . K. Nandivada, “Source Code: Batch Alias Analy-
sis (BatchAnalyzer),” 2019, https://archive.softwareheritage.org/browse/
origin/https://github.com/jyothivedurada/BatchAnalyzer.git.
[26] R. V all ´ee-Rai, P . Co, E. Gagnon, L. Hendren, P . Lam, and
V . Sundaresan, “Soot - a Java Bytecode Optimization Framework,
booktitle = Proceedings of the 1999 Conference of the Centre for
Advanced Studies on Collaborative Research,” ser. CASCON ’99.
IBM Press, 1999, pp. 13–. [Online]. Available: http://dl.acm.org/
citation.cfm?id=781995.782008
[27] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley,
R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel,
A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, D. Ste-
fanovi ´c, T. V anDrunen, D. von Dincklage, and B. Wiedermann, “The
DaCapo Benchmarks: Java Benchmarking Development and Analysis,”
inOOPSLA ’06 . New Y ork, NY , USA: ACM Press, Oct. 2006, pp.
169–190.
[28] E. Bodden, A. Sewe, J. Sinschek, M. Mezini, and H. Oueslati, “Taming
Reﬂection: Aiding Static Analysis in the Presence of Reﬂection and
Custom Class Loaders,” in Proceeding of the 33rd International Con-
ference on Software Engineering , ser. ICSE ’11. New Y ork, NY , USA:
ACM, 2011, pp. 241–250.
[29] J. V edurada and V . K. Nandivada, “Refactoring Opportunities for
Replacing Type Code with State and Subclass,” in Proceedings of the
39th International Conference on Software Engineering Companion ,
ser. ICSE-C ’17. Piscataway, NJ, USA: IEEE Press, 2017, pp.
305–307. [Online]. Available: https://doi.org/10.1109/ICSE-C.2017.97
[30] B. G. Ryder, “Dimensions of Precision in Reference Analysis of
Object-Oriented Programming Languages,” in Compiler Construction ,
G. Hedin, Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2003,
pp. 126–137.
[31] M. Thakur and V . K. Nandivada, “Compare less, defer more: scaling
value-contexts based whole-program heap analyses,” in Proceedings of
the 28th International Conference on Compiler Construction, CC 2019,
Washington, DC, USA, February 16-17, 2019 , 2019, pp. 135–146.
[Online]. Available: https://doi.org/10.1145/3302516.3307359
[32] H. Oh, W. Lee, K. Heo, H. Yang, and K. Yi, “Selective Context-
sensitivity Guided by Impact Pre-analysis,” in Proceedings of the 35th
ACM SIGPLAN Conference on Programming Language Design and
Implementation , ser. PLDI ’14. New Y ork, NY , USA: ACM, 2014,
pp. 475–484. [Online]. Available: http://doi.acm.org/10.1145/2594291.
2594318
947
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. [33] S. Jeong, M. Jeon, S. Cha, and H. Oh, “Data-driven Context-
sensitivity for Points-to Analysis,” Proc. ACM Program. Lang. , vol. 1,
no. OOPSLA, pp. 100:1–100:28, Oct. 2017. [Online]. Available:
http://doi.acm.org/10.1145/3133924
[34] G. M. Rama, R. Komondoor, and H. Sharma, “Reﬁnement in
Object-sensitivity Points-to Analysis via Slicing,” Proc. ACM Program.
Lang. , vol. 2, no. OOPSLA, pp. 142:1–142:27, Oct. 2018. [Online].
Available: http://doi.acm.org/10.1145/3276512
[35] X. Zhang, R. Mangal, R. Grigore, M. Naik, and H. Yang,
“On Abstraction Reﬁnement for Program Analyses in Datalog,” in
Proceedings of the 35th ACM SIGPLAN Conference on Programming
Language Design and Implementation , ser. PLDI ’14. New Y ork,
NY , USA: ACM, 2014, pp. 239–248. [Online]. Available: http:
//doi.acm.org/10.1145/2594291.2594327
[36] A. Diwan, K. S. McKinley, and J. E. B. Moss, “Type-based Alias
Analysis,” in Proceedings of the ACM SIGPLAN 1998 Conference on
Programming Language Design and Implementation , ser. PLDI ’98.
New Y ork, NY , USA: ACM, 1998, pp. 106–117. [Online]. Available:
http://doi.acm.org/10.1145/277650.277670
948
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 12:38:06 UTC from IEEE Xplore.  Restrictions apply. 