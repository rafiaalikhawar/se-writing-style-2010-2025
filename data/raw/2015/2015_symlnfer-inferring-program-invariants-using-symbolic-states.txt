SymInfer: Inferring Program Invariants using
Symbolic States
ThanhVu Nguyen
University of Nebraska-Lincoln, USA
tnguyen@cse.unl.eduMatthew B. Dwyer
University of Nebraska-Lincoln, USA
dwyer@cse.unl.eduWillem Visser
Stellenbosch University, South Africa
wvisser@cs.sun.ac.za
Abstract ‚ÄîWe introduce a new technique for inferring program
invariants that uses symbolic states generated by symbolic
execution. Symbolic states, which consist of path conditions
and constraints on local variables, are a compact description
of sets of concrete program states and they can be used for
both invariant inference and invariant veriÔ¨Åcation. Our technique
uses a counterexample-based algorithm that creates concrete
states from symbolic states, infers candidate invariants from
concrete states, and then veriÔ¨Åes or refutes candidate invariants
using symbolic states. The refutation case produces concrete
counterexamples that prevent spurious results and allow the
technique to obtain more precise invariants. This process stops
when the algorithm reaches a stable set of invariants.
We present SymInfer, a tool that implements these ideas
to automatically generate invariants at arbitrary locations in
a Java program. The tool obtains symbolic states from Sym-
bolic PathFinder and uses existing algorithms to infer complex
(potentially nonlinear) numerical invariants. Our preliminary
results show that SymInfer is effective in using symbolic states to
generate precise and useful invariants for proving program safety
and analyzing program runtime complexity. We also show that
SymInfer outperforms existing invariant generation systems.
I. I NTRODUCTION
Program invariants describe properties that always hold at
a program location. Examples of invariants include pre/post-
conditions, loop invariants, and assertions. Invariants are useful
in many programming tasks, including documentation, testing,
debugging, veriÔ¨Åcation, code generation, and synthesis [1]‚Äì[4].
Daikon [2] demonstrated that dynamic analysis is a practical
approach to infer invariants from concrete program states that
are observed when running the program on sample inputs. Dy-
namic inference is typically efÔ¨Åcient and supports expressive
invariants, but can often produce spurious invariants that do
not hold for all possible inputs. Several invariant generation
aproaches (e.g., iDiscovery [5], PIE [6], ICE [7], NumInv [8])
use a hybrid approach that dynamically infers candidate invari-
ants and then statically checks that they hold for all inputs. For
a spurious invariant, the checker produces counterexamples,
which help the inference process avoid this invariant and
obtain more accurate results. This approach, called Coun-
terExample Guided Invariant Generation (CEGIR), iterates the
inference and checking processes until achieving stable results.
In this paper, we present a CEGIR technique that uses sym-
bolic program states. Our key insight is that symbolic states
generated by a symbolic execution engine are (a) compact
encodings of large (potentially inÔ¨Ånite) sets of concrete states,(b) naturally diverse since they arise along different execution
paths, (c) explicit in encoding relationships between program
variables, (d) amenable to direct manipulation and optimiza-
tion, such as combining sets of states into a single joint
encoding, and (e) reusable across many different reasoning
tasks within CEGIR algorithms.
We deÔ¨Åne algorithms for symbolic CEGIR that can be
instantiated using different symbolic execution engines and
present an implementation SymInfer that uses Symbolic
PathFinder [9] (SPF)‚Äî a symbolic executor for Java. SymIn-
feruses symbolic states in both the invariant inference and
veriÔ¨Åcation processes. For inference, SymInfer uses symbolic
states to generate concrete states to bootstrap a set of candidate
invariants using DIG [10]‚Äì[12]‚Äîwhich can infer expressive
nonlinear invariants. For veriÔ¨Åcation, SymInfer formulates
veriÔ¨Åcation conditions from symbolic states to conÔ¨Årm or
refute an invariant, solves those using a SAT solver, and
produces counterexamples to reÔ¨Åne the inference process.
Symbolic states allow SymInfer to overcome several limita-
tions of existing CEGIR approaches. iDiscovery, ICE, and PIE
are limited to computing relatively simple invariants and often
do not consider complex programs with nonlinear arithmetic
and properties such as x=qy+r; x2+y2=z2. These in-
variants appear in safety and security-critical software and can
be leveraged to improve quality, e.g., to verify the absence of
errors in Airbus avionic systems [13] and to analyze program
runtime complexity to detect security threats [14], [15]. As our
evaluation of SymInfer demonstrates in Sec. V, iDiscovery,
which uses Daikon for inference, does not support nonlinear
properties, and both ICE and PIE timeout frequently when
nonlinear arithmetic is involved. Recent work on NumInv [8]
also uses DIG to infer invariants, but it invokes KLEE [16]
as a blackbox veriÔ¨Åer for candidate invariants. Since KLEE
is unaware of the goals of its veriÔ¨Åcation it will attempt to
explore the entire program state space and must recompute that
state space for each candidate invariant. In contrast, SymInfer
constructs a fragment of the state space that generates a set
of symbolic states that is sufÔ¨Åciently diverse for invariant
veriÔ¨Åcation and it reuses symbolic states for all invariants.
We evaluated SymInfer over 3 distinct benchmarks which
consist of 92 programs. The study shows that SymInfer: (1)
can generate complex nonlinear invariants required in 21/27
NLA benchmarks, (2) is effective in Ô¨Ånding nontrivial com-
plexity bounds for 18/19 programs, with 4 of those improving
978-1-5386-2684-9/17/$31.00 c2017 IEEEASE 2017, Urbana-Champaign, IL, USA
Technical Research804
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. int idiv(int x1, int x2) {
assert(x1 >= 0 && x2 >= 1);
int y1,y2,y3;
y1 = y2 = 0; y3 = x1;
while (y3 != 0) //[L]
if (y2 + 1 == x2) {
y1 = y1 + 1;
y2 = 0;
y3 = y3 - 1;
} else {
y2 = y2 + 1;
y3 = y3 - 1;
}
return y1;
}concrete L-states :
x1 x2 y1y2y3
15 2 0 0 15
15 2 0 1 14
15 2 1 0 13
...
4 1 0 0 4
4 1 1 0 3
...
Fig. 1. An integer division program and concrete L-states observed on inputs
(x1 = 15 ; x2 = 2) and(x1 = 4 ; x2 = 1)
on the best known bounds from the literature, (3) improves
on the state-of-the-art PIE tool in 41/46 programs in the
HOLA benchmark, and (4) outperforms NumInv across the
benchmarks while computing similar or better invariants.
These results strongly suggest that symbolic states form
a powerful basis for computing program invariants. They
permit an approach that blends the best features of dynamic
inference techniques and purely symbolic techniques, such
as weakest-precondition reasoning. The key contribution of
our work lies in the identiÔ¨Åcation of the value of symbolic
states in CEGIR, in developing an algorithmic framework
for adaptively computing a sufÔ¨Åcient set of symbolic states
for invariant inference, and in demonstrating, through our
evaluation of SymInfer, that it improves on the best known
techniques.
II. O VERVIEW
We illustrate invariant inference using symbolic states on the
integer division algorithm in Figure 1; Lmarks the location at
which we are interested in computing invariants. This example
states assumptions on the values of the parameters, e.g., no
division by zero. The best invariant at L is x2y1+y2+y3=
x1. This loop invariant encodes the precise semantics of the
loop computing integer division, i.e., the dividend x1equals
the divisor x2times the quotient y1plus the remainder, which
is the sum of the two temporary variables y2andy3.
Existing methods of dynamic invariant inference would
instrument the program at location Lto record values of the 5
local variables, and then, given a set of input vectors, execute
the program to record a set of concrete states of the program
to generate candidate invariants. Since the focus here is on
location L, we refer to these as L-states and we distinguish
those that are observed by instrumentation on a program run.
It is these observed concrete L-states that form the basis for
all dynamic invariant inference techniques.
On eight hand-selected set of inputs that seek to expose
diverse concrete L-states, running Daikon [2] on this example
results in very simple invariants, e.g., y10,x22.
These are clearly much weaker than the desired invariant
for this example. Moreover, the invariant on x2is actually
spurious since clearly 1can be passed as the second inputv2:y1= 1^y2= 0^y3=X1 1
v11:y1= 0^y2= 2^y3=X1 2X10^X21
l1
l2
l3
l4
l5
l6X16=4
retX
1
=
4X2= 1X16=3
retX
1
=
3X2= 1X16=2
retX
1
=
2X2= 1X16=1
retX
1
=
1X2=1
l7
l8
l9
l10X16=3
retX
1
=
3X2= 2X16=2
retX
1
=
2X2=2
l11
l12X2=3
l13X
2
6=
3X16=2
retX
1
=
2X
26=
2X16=1
retX
1
=
1X2 6=1X16=0
retX
1=
0
Fig. 2.
Symbolic Execution Tree and Symbolic L-states
which will reach L. Applying the more powerful DIG [12]
invariant generator, permits the identiÔ¨Åcation of the desired
invariant, but it too will yield the spurious x22invariant.
Spurious invariants are a consequence of the diversity and
representativeness of the inputs used, and the L-states that are
observed. Leveraging symbolic states can help address this
weakness.
A. Generating a symbolic state space
Figure 2 depicts a tree resulting from a depth-bounded
symbolic execution of the example. The gray region includes
paths limited to at most 5 branches; in this setting depth is a
semantic property and syntactic branches with only a single
infeasible outcome are not counted, e.g., the branches with
labels enclosed in gray boxes. We denote the unknown values
of program inputs using variables Xiand return points with
ret.
The states at location Lare denoted liin the Ô¨Ågure. An
observed symbolic L-state, li, is deÔ¨Åned by the conjunction of
the path-condition, i.e., the set of constraints on the tree-path
to the state, and vi, a constraint that encodes the values of
local variables in scope at L. For example, the symbolic state
l2is deÔ¨Åned as (X2= 1^X16= 0^X10^X21)^(y1=
0^y2= 2^y3=X1 2).
As is typical in symbolic execution, it is possible to increase
the depth-bound and generate additional states, e.g., l6,l10,l12,
andl13which all appear at a depth of 6 branches.
There are several properties of symbolic states that make
them useful as a basis for efÔ¨Åcient inference of invariants:
805
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. a) Symbolic states are expressive: Dynamic analysis has
to observe many concrete L-states to obtain useful results.
Many of those states may be equivalent from a symbolic
perspective. A symbolic state, like l2, encodes a potentially
inÔ¨Ånite set of concrete states, e.g., X1>0^X2= 1.
Invariant generation algorithms can exploit this expressive
power to account for the generation and refutation of candidate
invariants from a huge set of concrete states by processing a
single symbolic state.
b) Symbolic states are relational: Symbolic states en-
code the values of program variables as expressions over
free-variables capturing program inputs, i.e., Xi. This permits
relationships between variables to be gleaned from the state.
For example, state l2represents the fact that y3<x1for a
large set of inputs.
c) Symbolic states can be reused: Invariant generation
has to infer or refute candidate invariants relative to the set
of observed concrete L-states. This can grow in cost as the
product of the number of candidates and the size of number of
observed states. A disjunctive encoding of observed symbolic
L-states,W
i2[1 13]li, can be constructed a single time and
reused for each of the candidate invariants, which can lead
to performance improvement.
d) Symbolic states form a sufÔ¨Åciency test: The diversity
of symbolic L-states found during depth-bounded symbolic
execution combined with the expressive power of each of
those states provides a rich basis for inferring strong invariants.
We conjecture that for many programs a sufÔ¨Åciently rich set
of observed L-states for invariant inference will be found at
relatively shallow depth. For example, the invariants generated
and not refuted by the disjunction of L-states at depth 5,
Lk=5=fl1; l2; l3; l4; l5; l7; l8; l9; l11g, is the same for those
at depth 6,W
i2[1 13]li. Consequently, we explore an adaptive
and incremental approach that increases depth only when new
L-states lead to changes in candidate invariants.
B.SymInfer in action
SymInfer will invoke a symbolic executor to generate a set
of symbolic L-states at depth k, e.g., k= 5in our example for
the gray region. SymInfer then forms a small population of
concrete L-states, using symbolic L-states, to generate a set of
candidate invariants using DIG. DIG produces three invariants
at L for this example: y1y2y3= 0, x2y1 x1+y2+y3= 0,
andx1y3 12y1y3 y2y3 y32= 0. SymInfer attempts
to refute these invariants by using the full expressive power
of the observed L-states to determine if all of the represented
concrete states are consistent with the invariant. It does this by
calling a SAT solver to check implications such asW
l2Lk=5l)
(y1y2y3= 0). This refutes the Ô¨Årst and third candidate
invariant.
SymInfer then seeks additional L-states by running sym-
bolic execution with a deeper bound, k= 6. While this process
produces an additional 4 states to consider, none of thosevoid pldi_fig2(int M,int N,int P){
assert (0 M&&0N&&0P);
int i = 0, j = 0, k = 0;
int t = 0; //counter variable
while(i < N){//loop 1
j = 0; t++;
while(j < M){//loop 2
j++; k = i; t++;
while (k < P){// loop 3
k++; t++;
}
i = k;
}
i++;
}
// [L]
}
Fig. 3. A program that has several nonlinear complexity bounds.
can refute the remaining invariant candidate. Thus, SymInfer
terminates and produces the desired invariant.
III. D YNAMICALLY INFER NUMERICAL INVARIANTS
A. Numerical Invariants
We consider invariants describing relationships over numer-
ical program variables such as xy;0idxjarrj 
1; x+ 2y = 100. These numerical invariants have been used
to verify program correctness, detect defects, establish security
properties, synthesize programs, recover formal speciÔ¨Åcations,
and more [2], [4], [13], [17]‚Äì[22]. A particularly useful
class of numerical invariants involves nonlinear relations, e.g.,
xy2; x2y1 +y2 +y3 =x1. While more complex these
arise naturally in many safety-critical applications [13], [23].
In addition to capturing program semantics (e.g., as shown
in Section II), nonlinear invariants can characterize the compu-
tational complexity of a program. Figure 3 shows a program,
adapted from Figure 2 of [24], with nontrivial runtime com-
plexity. At Ô¨Årst, this program appears to take O(NMP )due
to the three nested loops. But closer analysis shows a more
precise bound O(N+NM +P)because the innermost loop
3, which is updated each time loop 2 executes, changes the
behavior of the outer loop 1.
When analyzing this program, SymInfer discovers a com-
plex nonlinear invariant over the variables P; M; N andt(a
temporary variable used to count the number of loop iterations)
at location L(program exit):
P2Mt+PM2t PMNt M2Nt PMt2+MNt2+PMt
 PNt 2MNt +Pt2+Mt2+Nt2 t3 Nt+t2= 0:
This nonlinear (degree 4) equality looks very different than
the expected bound N+NM +Por even NMP . However,
when solving this equation (Ô¨Ånding the roots of t), we obtain
three solutions that describe the exact bounds of this program:
t= 0 when N= 0;
t=P+M+ 1 when NP;
t=N M(P N)when N > P:
These results give more precise bounds than the given bound
N+MN +Pin [24].
806
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. input : terms, states
output: equalities among terms
1eqInvs ;
2template createTemplate(terms)
3eqts eqts[instantiate(template; states)
4sols solve(eqts)
5eqInvs =extractEqts(sols; terms)
6return eqInvs
Fig. 4. inferEqts: DIG‚Äôs algorithm for Ô¨Ånding candidate equalities
B. Inferring Invariants using Concrete States
To infer numerical invariants, SymInfer uses the algorithms
in DIG [12]. For numerical invariants, DIG Ô¨Ånds (potentially
nonlinear) equalities and inequalities. Like other dynamic
analysis tools, DIG generates candidate invariants that only
hold over observed concrete L-states.
1) Nonlinear Equalities: To generate nonlinear equality
invariants, DIG uses terms to represent nonlinear information
from the given variables up to a certain degree. For example,
the set of 10 terms f1; x; y; z; xy; xz; yz; x2; y2; z2gconsist of
all monomials up to degree 2over the variables fx; y; zg.
DIG then applies the steps shown in Figure 4 to generate
equality invariants over these terms using concrete states
observed at location L, and returns a set of possible equality
relations among those terms. First, we use the input terms
to form an equation template c1t1+c2t2+cntn= 0,
where and tiare terms and ciare real-valued unknowns to
be solved for (line 2). Next, we instantiate the template with
concrete states to obtain concrete equations (line 3). Then
we use a standard equation solver to solve these equations
for the unknowns (line 4). Finally we combine solutions for
the unknowns (if found) with the template to obtain equality
relations (line 5).
2) Octagonal Inequalities: DIG uses various algorithms
to infer different forms of inequality relations. We consider
theoctagonal relations of the form c1v1+c2v2kwhere
v1; v2are variables and ci2f  1;0;1gandkis real-valued.
These relations represent linear inequalities among program
variables, e.g., xy; 10x y20.
To infer octagonal invariants from concrete states
f(x1; y1); : : :g, we compute the upper and lowerbounds:
u1= max(x i); l1= min( xi);
u2= max(y i); l2= min( yi);
u3= max(x i yi); l3= min( xi yi);
u4= max(x i+yi); l4= min( xi+yi)
and form a set of 8 (octagonal) relations fu1xl1; u2
yl2; u3x yl3; u4x+yl4g.
Although computing octagonal inequalities is very efÔ¨Åcient
(linear in the number of concrete states), the candidate results
are likely spurious because the upper and lower bound val-
ues might not be in the observed concrete states. SymInfer
deals with such spurious invariants using a CEGIR approach
described in Section IV.IV. CEGIR A LGORITHMS USING SYMBOLIC STATES
The behavior of a program at a location can be precisely
represented by the set of all possible values of the variables in
scope of that location. We refer to these values as the concrete
states of the program. Figure 1 shows several concrete states
observed at location Lwhen running the program on inputs
(x1 = 15 ; x2 = 2) and(x1 = 4 ; x2 = 1) .
The set of all concrete states is the most precise repre-
sentation of the relationship between variables at a program
location, but it is potentially inÔ¨Ånite and thus is difÔ¨Åcult to use
or analyze. In contrast, invariants capture program behaviors
in a much more compact way. For the program in Figure 1
invariants at location Linclude: 0x1;1x2;0
y2 +y3; x2y1 +y2 +y3 = x1; : : : The most useful at
Lisx2y1 +y2 +y3 =x1, which describes the semantics
of integer division. The inequality 0y2 +y3is also useful
because it asserts that the remainder is non-negative.
Dynamic invariant generation techniques, like Daikon and
DIG, use concrete program states as inputs to compute useful
invariants. We propose to compute invariants from the sym-
bolic states of a program. Conceptually, symbolic states serve
as an intermediary representation between a set of concrete
program states and an invariant that might be inferred from
those concrete states.
We assume a Ô¨Åxed and known set of variables in scope at a
given location in a program. Moreover, we assume variables
are indexed and that for an index i,var(i)is a canonical name
for that variable. Invariants will be inferred over these named
variables. This is straightforward for locals and parameters, but
permits richer naming schemes for other memory locations.
We write a set of appropriately typed values for those vari-
ables as ~ vhv1; v2; : : : ; v ni, where the indexing corresponds
to that of variables. UndeÔ¨Åned variables have a ?value and
theith value is written ~ v[i]. A concrete state is(l;~ v)where
control is at location land program variables have the values
given by ~ v.
LetIbe a set free-variables that denote the undeÔ¨Åned input
values of a program. A symbolic value is an expression written
using constants, elements of I, and the operators available for
the value‚Äôs type. We write a sequence of symbolic values as
~ ehe1; e2; : : : ; e ni.
DeÔ¨Ånition 1. A symbolic state is (l;~ e; c) where control is
at location l,cis a logical formula written over I, and a
program variable takes on the corresponding concrete values
that are consistent with cand symbolic value. The semantics
of a symbolic state is:
J(l;~ e; c)K =f(l;~ v )jSAT ((^
i~ v[i] =~ e[i])^c)g
The role of cin a symbolic state is to deÔ¨Åne the constraints
between variables, for example, that may be established on
execution paths reaching l‚Äîa path condition.
A. Using Symbolic States
Symbolic states can help invariant generation in many ways.
We describe two concrete techniques using symbolic states
807
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. input : progP,L, number of states n, depth d
output: cstates
1block false
2cstates ;
3sstates symex:getStatesAt(P; L; d )
4foreach s2sstates do
5 ifSAT(s:c) then
6 ~i getModel()
7 cstates cstates[(L;eval(s:~ e; ~i))
8 block block_(V
i2I~i[i] = i)
9whilejcstatesj < n do
10 s choose(sstates)
11 ifSAT(s:c^:block) then
12 ~i getModel()
13 cstates cstates[(L;eval(s:~ e; ~i))
14 block block_(V
i2I~i[i] = i)
15return cstates
Fig. 5. genStates: generate concrete states from symbolic states
to generate diverse concrete states and to verify candidate
invariants.
1) Bootstrapping DIG with Concrete States: Our method
generates candidate invariants using existing state of the art
concrete state-based invariant inference techniques like DIG.
In this application we need only use a small number of
concrete states to bootstrap the algorithms to generate a diverse
set of candidate invariants since symbolic states will be used
to refute spurious invariants. In prior work [10], [12], fuzzing
was used to generate inputs and that could be used here as
well, but we can also exploit symbolic states.
Figure 5 shows how we use symbolic states to generate a
diverse set of concrete states‚Äîat least one for each symbolic
state. It Ô¨Årst generates the set of symbolic L-states reachable
depth less than or equal to d(line 3); note that these states
can be cached and reused for a given PandL.
The loop on line 4 considers each such state, checks the
satisÔ¨Åability of the states path condition, c, and then extracts
the model from the solver. We encode the model as a sequence,
~i, indexed by the name of a free input variables. The symbolic
state is then evaluated by the binding of concrete values to
input variables in the model. This produces a concrete state
which is accumulated. A conjunction of constraints equating
the values of the model, ~i, and the names of inputs, I, is added
to the blocking clause for future state generation.
The loop on line 9 generates additional concrete states
up to the requested number, n. This process will randomly
choose a symbolic state and then call the SAT solver to
generate a solution that has not already been computed; here ~i
is converted to a conjunction of equality constraints between
input variables and values from a model. When a solution is
found, we use the same processing as in lines 6-7 to create a
new concrete state.
2) Symbolic States as a ‚ÄúVeriÔ¨Åer‚Äù: Figure 6 shows how
symbolic states are used to verify, or refute, a property. Theinput : progP, locL, prop p, clauses to block
output: counterexample cex
1p:isInv unknown
2result unknown
3result0 unknown
4cex ;
5k 10//default depth
6while true do
7 sstates symex:getStatesAt(P; L; k )
8 vc (W
s2sstates(s:c^V
ivar(i) = s:~ e[i])
9 vc vc^:(Wblock))
10 result0 SAT(:(vc)p)
11 ifresult0result then
12 k k 1
13 break
14 result result0
15 ifresult0satthen
16 p:isInv false
17 cex getModel()
18 break
19 else if result0unsat then
20 p:isInv true
21 else if result0unknown then
22 p:isInv unknown
23 k k+ 1
24return cex
Fig. 6. verify: check a candidate property using symbolic states
algorithm obtains new symbolic states when it is determined
that they increase the accuracy of the veriÔ¨Åcation.
Symbolic states are obtained from a symbolic execution
engine. There are potentially an inÔ¨Ånite number of symbolic
states at a location, but most existing symbolic execution tools
have the ability to perform a depth-limited search. We wrap the
symbolic execution engine to just return the symbolic L-states
encountered during search of a given depth (getStatesAt).
The number of symbolic states varies with depth. A low
depth means few states. Few states will tend to encode a
small set of concrete L-states, which limits veriÔ¨Åcation and
refutation power. Few states will also tend to produce a smaller
and faster to solve veriÔ¨Åcation condition. To address this cost-
effectiveness tradeoff, rather than try to choose an optimal
depth, our algorithm computes the lowest depth that yields
symbolic states that change veriÔ¨Åcation outcomes. In essence,
the algorithm adaptively computes a good cost-effectiveness
tradeoff for a given program, location of interest, and invariant.
The algorithm iterates with each iteration considering a
different depth, k. The body of the each iteration (lines 7 ‚Äì
23) works as follows. It extract a set of symbolic states for
the current depth using symbolic execution (line 7); note this
can be done incrementally to avoid re-exploring the program‚Äôs
state space using techniques like [25]. It then formulates
a veriÔ¨Åcation condition out of three components. (1) For
each symbolic state, it constructs the conjunction of its path
condition, c, with constraints encoding equality constraints
between variables and their symbolic values, ~ e; these per-
state conjunctions are then disjoined. This expresses the set of
808
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. concrete L-states corresponding to all of the symbolic states.
(2) The negation of the disjunction of the set of states that
are to be blocked is formed. These components are conjoined,
which serves to eliminate the concrete L-states that are to be
blocked. (3) If the resulting formula implies a candidate pthen
that candidate is consistent with the set of symbolic states. We
use a SAT solver to check the negation of this implication.
The solver can return sat which indicates that the property
is not an invariant (lines 15 ‚Äì 18). The solver is also queried
for a model which is a sample state that is inconsistent with
the proposed invariant. This counterexample state is saved
so that the inference algorithm can search for invariants that
are consistent with it. The solver can also return unsat
indicating the property is a true invariant; at least as far as
the algorithm can determine given the symbolic states at the
current depth. Finally, the solver can also return unknown,
indicating it cannot determine whether the given property is
true or false.
For the latter two cases, we increment the depth and
explore a larger set of symbolic states generated from a deeper
symbolic execution. Lines 10 ‚Äì 14 work together to determine
when increasing the depth does not inÔ¨Çuence the veriÔ¨Åcation.
In essence, they check to see whether the same result is
computed at adjacent depths and if so, they revert to the
shallower depth and return.
B. A CEGIR approach using symbolic states
CounterExample Guided Invariant Generation (CEGIR)
techniques consist of a guessing component that infers can-
didate invariants and a checking component that veriÔ¨Åes the
candidate solutions. If the candidate is invalid, the checker
produces counterexamples, i.e., concrete states that are not
consistent with the candidate invariant. The guessing process
incorporates the generated counterexamples so that any new
invariants account for them. Alternation of guessing and
checking repeats until no candidates can be disproved.
SymInfer integrates symbolic traces into two CEGIR algo-
rithms to compute candidate invariants. These algorithms use
the inference techniques described in Section III for equality
and inequality invariants.
1) Nonlinear Equalities: Figure 7 deÔ¨Ånes our CEGIR algo-
rithm for computing non-linear equality invariants. It consists
of two phases: an initial invariant candidate generation phase
and then an iterative invariant refutation and reÔ¨Ånment phase.
Lines 5 ‚Äì 7 deÔ¨Åne the initial generation phase. As as de-
scribed in Section III-B1, we Ô¨Årst create terms to represent
nonlinear polynomials (line 5). Because solving for nun-
knowns requires at least nunique equations, we need to
generate a sufÔ¨Åcient set of concrete L-states (line 6). This can
either be realized through fuzzing an instrumented version of
the program that records concrete L-states or, as described in
Figure 5, one can use symbolic L-states to generate them.
The initial candidate set of invariants is iteratively reÔ¨Åned on
lines 8 ‚Äì 18. The algorithm then refutes or conÔ¨Årms them using
symbolic states as described in Figure 6. Any property that is
proven to hold is recorded in invs and counterexample states,input : program P, location L, degree d
output: nonlinear equalities up to deg datL
1states ;
2invs ;
3block ;
4vars extractVars(P; L)
5terms createTerms(vars; d )
6states genStates(P; L; jtermsj)
7candidates inferEqts(terms; states)
8while candidates6=;do
9 cexs ;
10 foreach p2candidates do
11 newcexs verify(P; L; p; block)
12 cexs cexs[newcexs
13 ifp:isInv then invs invs[fpg
14 ifcexs; thenbreak
15 block block[cexs
16 states states[cexs
17 newcandidates inferEqts(termsstates)
18 candidates newcandidates invs
19return invs
Fig. 7. CEGIR algorithm for Ô¨Ånding equalities.
cexs, are accumulated across the set of properties. Generated
counterexample states are also blocked from contributing to
the veriÔ¨Åcation process.
If no property generated counterexample states, then the
algorithm terminates returning the veriÔ¨Åed invariants. The
counterexamples are added to the set of states that are used to
infer new candidate invariants; this ensures that new invariants
will be consistent with the counterexample states (line 16).
These new results may include some already proven invariants,
so we remove those from the set of candidates considered in
the next round of reÔ¨Ånement.
2) Octagonal Inequalities: Our next CEGIR algorithm uses
a divide and conquer approach to compute octagonal inequali-
ties. Given a term t, and an interval range [minV; maxV ], we
compute the smallest integral upperbound koftby repeatedly
dividing the interval into halves that could contain k. The use
of an interval range [minV; maxV ]allows us to exclude terms
ranges are too large (or that do not exist). For example, if we
check t > maxV and it holds then we will not compute the
bound of t(which is strictly larger than maxV ).
We start by checking a guess that tmidV , where
midV =dmaxV +minV
2e. These checks are performed by
formulating a veriÔ¨Åcation condition from symbolic states in
a manner that is analogous to Figure 7. If this holds, then k
is at most midV and we tighten the search to a new interval
[minV; midV ]. Otherwise, we obtain counterexample with t
having some value c, where c > midV . We then tighten the
search to a new interval [c; maxV ]. In either case, we repeat
the guess for kusing an interval that is half the size of the
previous one. The search stops when minV andmaxV are
the same or their difference is one (in which case we return
the smaller value if tis less than or equal both).
To Ô¨Ånd octagonal invariants over a set of variables, e.g.,
fx; y; zg, we apply this method to Ô¨Ånd upperbounds of the
termsfx; x; y; y; : : : ; y +z; y zg. Note that we obtain
809
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. both lower and upperbound using the same algorithm because
the upperbound for tessentially lowerbound of  tsince all
computations are reversed for  t.
SymInfer reuses the symbolic states from the inference of
equalities to formulate veriÔ¨Åcation conditions for inequalities.
This is another example of how reuse speeds up inference.
V. I MPLEMENTATION AND EVALUATION
We implemented SymInfer in Python/SAGE [26]. The tool
takes as input a Java program with marked target locations
and generates invariants at those locations. We use Symbolic
PathFinder (SPF) [9] to extract symbolic states for Java
programs and the Z3 SMT Solver [20] to check and produce
models representing counterexamples. We also use Z3 to check
and remove redundant invariants.
SymInfer currently supports equality and inequality re-
lations over numerical variables. For (nonlinear) equalities,
SymInfer uses techniques from DIG to limit the number
of generated terms. This allows us, for example, to infer
equalities up to degree 5 for a program with 4 variables and
up to degree 2 for program with 12 variables. For octagonal
invariants, we consider upper and lower bounds within the
range [ 10; 10]; we rarely observe inequalities with large
bounds. SymInfer can either choose random values in a
range, [ 300; 300] by default, for bootstrapping, or use the
algorithm in Figure 5. All these parameters can be changed
bySymInfer‚Äôs user; we chose these values based on our
experience.
A. Research Questions
To evaluate SymInfer, we consider three research questions:
1) Is SymInfer effective in generating nonlinear invariants
describing complex program semantics and correctness?
2) Can SymInfer generate expressive invariants that cap-
ture program runtime complexity?
3) How does SymInfer perform relative to PIE, a state-of-
the-art invariant generation technique?
To investigate these questions, we used 3 benchmark suites
consist of 92 Java programs (described in details in each
section). These programs come with known or documented
invariants. Our objective is to compare SymInfer‚Äôs inferred
invariants against these documented results. To compare in-
variants, we used Z3 to check if the inferred results imply
the documented ones. We use a script to run SymInfer 11
times on each program and report the median results. The
scripts automatically terminates a run exceeding 5 minutes.
The experiments reported here were performed on a 10-core
Intel i7 CPU 3.0GHZ Linux system with 32 GB of RAM.
B. Analyzing Program Correctness
In this experiment, we use the NLA testsuite [12] which
consists of 27 programs implementing mathematical functions
such as intdiv, gcd, lcm, power. Although these
programs are relatively small (under 50 LoCs) they con-
tain nontrivial structures such as nested loops and nonlinear
invariant properties. To the best of our knowledge, NLATABLE I
EXPERIMENTAL RESULTS FOR 27PROGRAMS IN THE NLA TESTSUITE .
XINDICATES WHEN SYMINFER GENERATES RESULTS SUFFICIENTLY
STRONG ENOUGH TO PROVE KNOWN INVARIANTS .
Prog Desc Locs V , T, D Invs Time (s) Correct
cohendiv int div 2 6,3,2 10 21.05 X
divbin int div 2 5,3,2 11 58.97 X
manna int div 1 5,4,2 6 35.33 X
hard int div 2 6,3,2 6 29.40 X
sqrt square root 1 4,4,2 5 20.03 X
dijkstra square root 2 5,7,3 16 93.01 X
freire1 square root 1 - - - -
freire2 cubic root 1 - - - -
cohencu cubic sum 1 5,5,3 4 21.90 X
egcd1 gcd 1 8,3,2 14 122.22 X
egcd2 gcd 2 - - - -
egcd3 gcd 3 - - - -
prodbin gcd, lcm 1 5,3,2 7 56.17 X
prod4br gcd, lcm 1 6,3,3 9 84.37 X
knuth product 1 - - - -
fermat1 product 3 5,6,2 17 60.26 X
fermat2 divisor 1 5,6,2 8 36.83 X
lcm1 divisor 3 6,3,2 24 248.17 X
lcm2 divisor 1 6,3,2 7 34.17 X
geo1 geo series 1 4,4,2 8 158.27 X
geo2 geo series 1 4,4,2 9 147.75 X
geo3 geo series 1 - - - -
ps2 pow sum 1 3,3,2 3 18.39 X
ps3 pow sum 1 3,4,3 3 19.69 X
ps4 pow sum 1 3,4,4 3 19.92 X
ps5 pow sum 1 3,5,5 3 46.19 X
ps6 pow sum 1 3,5,6 3 41.19 X
contains the largest number of programs containing nonlinear
arithmetic. These programs have also been used to evaluate
other numerical invariant systems [12], [27], [28].
These NLA programs come with known program invariants
at various program locations (e.g., mostly nonlinear equalities
for loop invariants and postconditions). For this experiment,
we evaluate SymInfer by Ô¨Ånding invariants at these locations
and comparing them with known invariants.
Results: Table I shows the results of SymInfer for the 27
NLA programs. Column Locs show the number of locations
where we obtain invariants. Column V ,T,D shows the number
of variables, terms, and highest degree from these invariants.
Column Invs shows the number of discovered equality and
inequality invariants. Column Time shows the total time in
seconds. Column Correct shows if the obtained results match
or imply the known invariants.
For 21/27 programs, SymInfer generates correct invariants
that match or imply the known results. In most cases, the
discovered invariants match the known ones exactly. Occasion-
ally, we obtain results that are equivalent or imply the known
results. For example, for sqrt, for some runs we obtained
the documented equalities t= 2a + 1; s = (a + 1)2, and for
other runs we obtain t= 2a + 1; t2 4s+ 2t = 1, which
are equivalent to s= (a+ 1)2by replacing twith 2a+ 1. We
also obtain undocumented invariants, e.g., SymInfer generates
the postconditions x=qy+r;0r; rx; ry 1for
cohendiv, which computes the integer division result of two
integers q=xy, The Ô¨Årst invariant is known and describes
the precise semantics of integer division: the dividend xis
the divisor ytimes the quotion qplus the remainder r. The
810
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. TABLE II
EXPERIMENTAL RESULTS FOR COMPUTING PROGRAMS ‚ÄôCOMPLEXITIES .
X:SYMINFER GENERATES THE EXPECTED BOUNDS .X:PROGRAM WAS
SLIGHTLY MODIFIED TO ASSIST THE ANALYSIS .XX:SYMINFER OBTAINS
MORE PRECISE BOUNDS THAN REPORTED RESULTS .
Prog V , T, D Invs Time (s) Bound
cav09 Ô¨Åg1a 2,5,2 1 12.41 X
cav09 Ô¨Åg1d 2,5,2 1 12.44 X
cav09 Ô¨Åg2d 3,2,2 3 58.40 X
cav09 Ô¨Åg3a 2,2,2 3 8.75 X
cav09 Ô¨Åg5b 3,5,2 6 49.44 X
pldi09 ex6 3,8,3 6 57.00 X
pldi09 Ô¨Åg2 3,15,4 6 60.60 XX
pldi09 Ô¨Åg4 1 2,3,1 3 56.24 X
pldi09 Ô¨Åg4 2 4,4,2 5 28.32 X
pldi09 Ô¨Åg4 3 3,3,2 3 59.19 X
pldi09 Ô¨Åg4 4 5,4,2 - - -
pldi09 Ô¨Åg4 5 3,4,2 3 103.70 X
popl09 Ô¨Åg2 1 5,12,3 2 50.86 XX
popl09 Ô¨Åg2 2 4,9,3 2 53.48 XX
popl09 Ô¨Åg3 4 3,4,3 4 58.62 X
popl09 Ô¨Åg4 1 3,3,2 4 65.19 X
popl09 Ô¨Åg4 2 5,12,3 2 51.24 XX
popl09 Ô¨Åg4 3 3,3,2 5 31.57 X
popl09 Ô¨Åg4 4 3,3,2 3 36.89 X
other obtained inequalities were undocumented. For example,
r0asserts that the remainder ris non-negative and
rx; ry 1state that ris at most the dividend x,
but is strictly less than the divisor y. Our experience shows
thatSymInfer is capable of generating many invariants that
are unexpected yet correct and useful.
SymInfer did not Ô¨Ånd invariants for 6/27 programs (marked
with ‚Äú-‚Äù in Table I). For egcd2, egcd3, the equation solver
used in SAGE takes exceeding long time for more than
half of the runs. For geo3, we obtained the documented
invariants and others, but Z3 stops responding when checking
these results. freire1 andfreire2 contain Ô¨Çoating point
arithmetic, which are currently not supported by SymInfer.
SPF failed to produce symbolic states for knuth for any depth
we tried. This program invokes a library function Math.sqrt
and SPF does not know the semantics of this function and
thus fails to provide useful symbolic information. For egcd2,
egcd3, and geo3, SymInfer times out after 5 minutes,
and for freire1, freire2, and knuth, it exits upon
encountering the unsupported feature.
C. Analyzing Computational Complexity
As shown in Section III, nonlinear invariants can represent
precise program runtime complexity. More speciÔ¨Åcally, we
compute the roots of nonlinear relationships to obtain disjunc-
tive information (e.g., x2= 4)(x= 2_x= 2), which
apture different and precise complexity bounds of programs.
To further evaluate SymInfer on discovering program com-
plexity, we collect 19 programs, adapted from existing static
analysis techniques speciÔ¨Åcally designed to Ô¨Ånd runtime com-
plexity [24], [29], [30]1. These programs, shown in Table II,
are small, but contain nontrivial structures and represent
examples from Microsoft‚Äôs production code [24]. For this
1We remove nondeterministic features in these programs because SymInfer
assumes determinstic behaviors.experiment, we instrument each program with a fresh variable
trepresenting the number of loop iterations and generate
postconditions over tand input variables (e.g., see Figure 3).
Results: Table II shows the median results of SymInfer
from 11 runs. Column Bound contains a Xif we can generate
invariants matching the bounds reported in the respective
work, and XXif the discovered invariants represent more
precise bounds than the reported ones.A Xindicates when the
program was modiÔ¨Åed slightly to help our analysis‚Äîdescribed
below.
For 18/19 programs, SymInfer discovered runtime com-
plexity characterizations that match or improve on reported
results. For cav09_fig1a, we found the invariant mt 
t2 100m + 200t = 10000, which indicates the correct
bound t=m+ 100_t= 100. For these complexity
analyses, we also see the important role of combining both in-
equality and equality relations to produce informative bounds.
Forpopl09_fig3_4, SymInfer inferred nonlinear equality
showing that t=n_t=mand inequalities asserting that
tn^tm, together indicating that t=max(n; m),
which is the correct bound for this program. In four programs,
SymInfer obtains better bounds than reported results. The
pldi_fig2 programs showing in Figure 3 is a concrete
example where the obtained three bounds are strictly less than
the given bound.
For several programs we needed some manual instrumenta-
tion or inspections to help the analysis. For popl09_fig4_1
we added the precondition asserting the input mis nonneg-
ative. For pldi09_fig4_5, we obtained nonlinear results
giving three bounds t=n m,t=m, and t= 0, which
establish the reported upperbound t=max(0; n m; m ). For
pldi09_fig4_4, we obtained invariants that are insufÔ¨Åcient
to show the reported bound. However, if we create a new term
representing the quotient of an integer division of two other
variables in the program, and obtain invariants over that term,
we obtain more precise bounds than those reported.
D. Comparing to PIE
We compare SymInfer to the recent CEGIR-based in-
variant tool PIE [6]. PIE aims to verify annotated relations
by generating invariants based on the given assertions. In
contrast, SymInfer generates invariants at given locations
without given assertions or postconditions. We use the HOLA
benchmarks [31], adapted by the PIE developers. These pro-
grams are annotated with various assertions representing loop
invariants and postconditions. This benchmark consists of 49
small programs, but contain nontrivial structures including
nested loops or multiple sequential loops. These programs,
shown in Table III, have been used as benchmarks for other
static analysis techniques [32]‚Äì[34].
For this experiment, we Ô¨Årst run PIE and record its run time
on proving the annotated assertions. Next, we removed the
assertions in the programs and asked SymInfer to generate
invariants at those locations. Our objective is to compare
SymInfer‚Äôs discovered invariants with the annotated asser-
tions. Because these HOLA programs only consist of asser-
811
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. TABLE III
SYMINFER RUN ON HOLA BENCHMARKS .X:PRODUCE SUFFICIENTLY
STRONG RESULTS TO PROVE ASSERTIONS .:FAIL TO MAKE SUFFICIENTLY
STRONG INVARIANTS .
Benchmark PIE time (s) SymInfer time (s) Correct
H01 21.88 3.69 
H02 36.12 3.36 X
H03 56.28 23.96 X
H04 19.11 3.12 X
H05 25.19 3.76 X
H06 61.98 4.56 X
H07 - 4.58 X
H08 19.02 4.33 X
H09 - 19.66 X
H10 24.6 4.25 X
H11 27.95 5.13 X
H12 44.52 14.60 X
H13 - 3.99 X
H14 25.98 4.07 X
H15 48.30 4.20 X
H16 33.19 4.99 X
H17 53.36 3.03 X
H18 21.70 5.69 X
H19 - 5.05 X
H20 331.93 29.45 X
H21 25.65 18.99 
H22 25.40 4.50 X
H23 23.40 4.90 X
H24 51.22 - -
H25 - 4.31 X
H26 87.64 5.55 X
H27 55.41 - -
H28 22.16 6.37 X
H29 58.82 6.80 X
H30 33.92 4.42 
H31 88.10 38.94 X
H32 226.73 6.75 X
H33 - 6.95 X
H34 121.87 11.34 X
H35 20.07 3.47 X
H36 - 7.61 X
H37 - 9.87 X
H38 37.37 6.47 X
H39 24.68 3.99 X
H40 60.71 60.20 X
H41 34.10 6.89 X
H42 54.93 5.55 
H43 21.16 5.34 X
H44 31.92 13.67 X
H45 84.00 5.39 X
H46 27.56 6.21 X
tions having linear relations, we ask SymInfer to only generate
invariants up to degree 2 (quadratic relations can represent
linear relations, e.g., x2= 4)x= 2_x= 2).
Results: Table III shows these obtained results from PIE and
SymInfer. Column PIE time shows the time, in seconds, for
PIE to run each program. Column SymInfer time shows the
time, in seconds, for SymInfer to generate invariants for each
program (the median of 11 runs). The ‚Äú-‚Äù symbol indicates
when PIE fails to prove the given assertions, e.g., because it
generates invariants that are too weak. Column Correct shows
whether SymInfer‚Äôs generated invariants match or imply the
annotated assertions and therefore prove these assertions. For
this experiment we manually check the result invariants and
use Z3 to compare them to the given assertions. A Xindicates
that the generated invariants match or imply the assertions.Aindicates that the generated invariants are not sufÔ¨Åciently
strong to prove the assertions.
For 40/46 programs, SymInfer discovered invariants are
sufÔ¨Åciently strong to prove the assertions. In most of these
cases we obtained correct and stronger invariants than the
given assertions. For example, for H23, SymInfer inferred the
invariants i=n; n2 n 2s= 0; in, which imply
the postcondition s0. For H29, we obtained the invariants
b+ 1 = c; a+ 1 = d; a+b2;2a, which imply the given
postcondition a+c=b+d.
Surprisingly, SymInfer also found invariants that are pre-
cise enough to establish conditions under forms that are
not supported by SymInfer. For example, H8 contains a
postcondition x < 4_y > 2, which has a disjunctive
form of strict inequalities. SymInfer did not produce this
invariant, but instead produced a correct and stronger re-
lation xy, which implies this condition. Many HOLA
programs contain disjunctive (or conditional) properties, e.g.,
if(c) assert (p); where the property ponly holds when the
condition cholds (written c)p). For example, for H18, we
obtained fj= 100f , which implies the conditional assertion
f6= 0)j= 100. For H37, PIE failed to prove the postcondi-
tion if(n > 0) assert(0 <= m && m < n); which involves
both conditional assertions and strict inequalities. For this
program, SymInfer inferred 2 equations and 3 inequalities2,
which together establish the postcondition.
For 6/46 programs, SymInfer either failed to produce in-
variants (2 programs marked with ‚Äú-‚Äù) or discovered invariant
that are not strong enough to prove the given assertions (4
programs marked with ). For both H24 and H27, Z3 stops
responding when checking the inferred results and the run
were terminated after 5 minutes. For H01, we found the
invariant x=y, which is not sufÔ¨Åciently to establish the
postcondition y1. For H27, SymInfer found no relation
involving the variable cto prove the assertion c0.
Summary: These preliminary results show SymInfer gen-
erates expressive, useful, and interesting invariants describing
the semantics and match documented invariants (21/27 NLA
programs), discovers difÔ¨Åcult invariants capturing precise and
informative complexity bounds of programs (18/19 programs),
and is competitive with PIE (40/46 HOLA programs). We also
note that PIE, ICE, and iDiscovery (other CEGIR-based tools
reviewed in Section VI), cannot Ô¨Ånd any of these high-degree
nonlinear invariants found by SymInfer.
E. Threats to Validity
SymInfer‚Äôs run time is dominated by computing invariants,
more speciÔ¨Åcally solving hundred of equations for hundred of
unknowns. The run time of DIG can be improved signiÔ¨Åcantly
by limiting the search to invariants of a given maximum degree
rather than using the default setting. Verifying candidate in-
variants, i.e., checking implication using the Z3 solver, is much
faster than DIG, even when multiple checks are performed at
different depths. This shows an advantage of reusing symbolic
states when checking new invariants.
2m2=nx m x; mn =x2 x; mx; xm+ 1; nx
812
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. SymInfer encodes all symbolic states to into the Z3 veriÔ¨Å-
cation condition. This results in complex formulas with large
disjunctions that can make Z3 timeout. Moreover, depending
on the program, SPF might not be able to generate all possible
symbolic states. In such cases, SymInfer cannot refute candi-
ate invariants and thus may produce unsound results. However,
our experience shows that SPF, by its nature as a symbolic
executor, turns out to be very effective in producing sufÔ¨Åcient
symbolic states, which effectively remove invalid candidates.
Finally, we reuse existing analysis tools, such as DIG and
SPF, which provides a degree of assurance in the correctness of
SymInfer, but our primary means of assuring internal validity
was performing both manual and automated (SMT) checking
of the invariants computed for all subject programs. While our
evaluation uses a variety of programs from different bench-
marks, these programs are small and thus do not represent
large software projects. Their use does promote comparative
evaluation and reproducibility of our results. We believe using
symbolic states will allow for the generation of useful and
complex invariants for larger software systems, in part because
of the rapid advances in symbolic execution and SMT solving
technologies and SymInfer leverages those advances.
VI. R ELATED WORK AND FUTURE WORK
Daikon [2] is a well-known dynamic tool that infers candi-
date invariants under various templates over concrete program
states. The tool comes with a large set of templates which
it tests against observed concrete states, removing those that
fail, and return the remaining ones as candidate invariants.
DIG [12] is similar to Daikon, but focuses on numerical in-
variants and therefore can compute more expressive numerical
relations than those supported by Daikon‚Äôs templates.
PIE [6] and ICE [7] uses CEGIR to infer invariants to prove
a given speciÔ¨Åcation. To prove a property, PIE iteratively infers
and reÔ¨Åned invariants by constructing necessary predicates
to separate (good) states satisfying the property and (bad)
states violating that property. ICE uses a decision learning
algorithm to guess inductive invariants over predicates sepa-
rating good and bad states. The checker produces good, bad,
and ‚Äúimplication‚Äù counterexamples to help learn more precise
invariants. For efÔ¨Åciency, they focus on octagonal predicates
and only search for invariants that are boolean combinations
of octagonal relations. In general, these techniques focus on
invariants that are necessary to prove a given speciÔ¨Åcation
and, thus, the quality of the invariants are dependent target
speciÔ¨Åcation.
NumInv [8] is a recent CEGIR tool that discovers invariants
for C programs. The tool also uses DIG‚Äôs algorithms to infer
equality and inequality relations. For veriÔ¨Åcation it instru-
ments invariants into the program and runs the KLEE test-
input generation tool [16]. KLEE does use a symbolic state
representation internally, but this is inaccessible to NumInv.
Moreover, KLEE is unaware of its use in this context and
it recomputes the symbolic state space completely for each
veriÔ¨Åcation check, which is inefÔ¨Åcient. For the experiments in
Section V, SymInfer is comparable to NumInv in the qualityof invariants produced, but SymInfer runs faster in spite of the
fact that KLEE‚Äôs symbolic execution of C programs is known
to be faster than SPF‚Äôs performance on Java programs. We
credit this to the beneÔ¨Åts of using symbolic states.
Similar to SymInfer, the CEGIR-based iDiscovery [5] tool
uses SPF to check invariants. However, iDiscovery does not
exploit the internal symbolic state representation of symbolic
excution but instead runs SPF as a blackbox to check program
assertions encoding candidate invariants. To speed up symbolic
execution, iDiscovery applies several optimizations such as
using the Green solver [35] to avoid recomputing the symbolic
state space for each check. In contrast, SymInfer precomputes
the full disjunctive SMT formula encoding the paths to the
interested location once and reuses that formula to check
candidate invariants. For dynamic inference, iDiscovery uses
Daikon and thus has limited support for numerical invariants.
For example, iDiscovery cannot produce the required nonlinear
invariants or any relevant inequalities for the programs in
Figures 1 and 3. Note that for programs involving non-
numerical variables, Daikon/iDiscovery might be able to infer
more invariants than SymInfer.
SymInfer is unlike any of the above in its reliance on
symbolic states to bootstrap, verify and iteratively reÔ¨Åne the
invariant generation process. There are clear opportunities for
signiÔ¨Åcantly improving the performance of SymInfer and tar-
geting different languages, such as C through the use of other
symbolic executors. For example, generating symbolic states
can be sped up for invariant inference by combining directed
symbolic execution [36] to target locations of interest, memo-
ized symbolic execution [25] to store symbolic execution trees
for future extension, and parallel symbolic execution [37] to
accelerate the incremental generation of the tree. Moreover,
we can apply techniques for manipulating symbolic states
in symbolic execution [16], [35] to signiÔ¨Åcantly reduce the
complexity of the veriÔ¨Åcation conditions sent to the solver.
VII. C ONCLUSION
We present SymInfer a method that uses symbolic en-
codings of program states to efÔ¨Åciently discover rich invari-
ants over numerical variables at arbitrary program locations.
SymInfer uses a CEGIR approach that uses symbolic states
to generate candidate invariants and also to verify or refute,
and iteratively reÔ¨Åne, those candidates. Key to the success of
SymInfer is its ability to directly manipulate and reuse rich
encodings of large sets of concrete program states. Preliminary
results on a set of 92 nontrivial programs show that SymInfer
is effective in discovering useful invariants to describe precise
program semantics, characterize the runtime complexity of
programs, and verify nontrivial correctness properties.
ACKNOWLEDGMENT
This material is based in part upon work supported by the
National Science Foundation under Grant Number 1617916.
813
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. REFERENCES
[1] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco, M. S.
Tschantz, and C. Xiao, ‚ÄúThe Daikon system for dynamic detection of
likely invariants,‚Äù Science of Computer Programming, pp. 35‚Äì45, 2007.
[2] M. D. Ernst, ‚ÄúDynamically detecting likely program invariants,‚Äù Ph.D.
dissertation, University of Washington, 2000.
[3] J. H. Perkins, S. Kim, S. Larsen, S. Amarasinghe, J. Bachrach,
M. Carbin, C. Pacheco, F. Sherwood, S. Sidiroglou, G. Sullivan, W.-F.
Wong, Y . Zibin, M. D. Ernst, and M. Rinard, ‚ÄúAutomatically patching
errors in deployed software,‚Äù in Symposium on Operating Systems
Principles. ACM, 2009, pp. 87‚Äì102.
[4] W. Weimer, ‚ÄúPatches as better bug reports,‚Äù in Generative Programming
and Component Engineering. ACM, 2006, pp. 181‚Äì190.
[5] L. Zhang, G. Yang, N. Rungta, S. Person, and S. Khurshid, ‚ÄúFeedback-
driven dynamic invariant discovery,‚Äù in ISSTA. ACM, 2014, pp. 362‚Äì
372.
[6] S. Padhi, R. Sharma, and T. Millstein, ‚ÄúData-driven precondition infer-
ence with learned features,‚Äù in PLDI. ACM, 2016, pp. 42‚Äì56.
[7] P. Garg, D. Neider, P. Madhusudan, and D. Roth, ‚ÄúLearning invariants
using decision trees and implication counterexamples,‚Äù in POPL. ACM,
2016, pp. 499‚Äì512.
[8] T. Nguyen, T. Antopoulos, A. Ruef, and M. Hicks, ‚ÄúA Counterexample-
guided Approach to Finding Numerical Invariants,‚Äù in FSE. ACM,
2017, pp. 605‚Äì615.
[9] S. Anand, C. S. P ÀòasÀòareanu, and W. Visser, ‚ÄúJPF-SE: A Symbolic
Execution Extension to Java PathFinder,‚Äù in TACAS. Springer-Verlag,
2007, pp. 134‚Äì138.
[10] T. Nguyen, D. Kapur, W. Weimer, and S. Forrest, ‚ÄúUsing Dynamic
Analysis to Discover Polynomial and Array Invariants,‚Äù in International
Conference on Software Engineering (ICSE) . IEEE, 2012, pp. 683‚Äì693.
[11] ‚Äî‚Äî, ‚ÄúUsing Dynamic Analysis to Generate Disjunctive Invariants,‚Äù in
ICSE. IEEE, 2014, pp. 608‚Äì619.
[12] ‚Äî‚Äî, ‚ÄúDIG: A Dynamic Invariant Generator for Polynomial and Array
Invariants,‚Äù TOSEM, vol. 23, no. 4, pp. 30:1‚Äì30:30, 2014.
[13] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min ¬¥e, D. Monniaux,
and X. Rival, ‚ÄúThe Astr ¬¥ee analyzer,‚Äù in ESOP. Springer, 2005, pp.
21‚Äì30.
[14] V . C. Ngo, M. Dehesa-Azuara, M. Fredrikson, and J. Hoffmann, ‚ÄúVer-
ifying and synthesizing constant-resource implementations with types,‚Äù
inSymposium on Security and Privacy (SP). IEEE, 2017, pp. 710‚Äì728.
[15] T. Antonopoulos, P. Gazzillo, M. Hicks, E. Koskinen, T. Terauchi, and
S. Wei, ‚ÄúDecomposition instead of self-composition for proving the
absence of timing channels,‚Äù in PLDI. ACM, 2017, pp. 362‚Äì375.
[16] C. Cadar, D. Dunbar, and D. R. Engler, ‚ÄúKLEE: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs.‚Äù
inOSDI. USENIX Association, 2008, pp. 209‚Äì224.
[17] T. Ball and S. K. Rajamani, ‚ÄúAutomatically validating temporal safety
properties of interfaces,‚Äù in SPIN. Springer, 2001, pp. 103‚Äì122.[18] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre, ‚ÄúLazy abstrac-
tion,‚Äù in POPL. ACM, 2002, pp. 58‚Äì70.
[19] M. Das, S. Lerner, and M. Seigle, ‚ÄúESP: path-sensitive program veriÔ¨Å-
cation in polynomial time,‚Äù in PLDI. ACM, 2002, pp. 57‚Äì68.
[20] L. De Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in TACAS.
Springer, 2008, pp. 337‚Äì340.
[21] X. Leroy, ‚ÄúFormal certiÔ¨Åcation of a compiler back-end or: programming
a compiler with a proof assistant,‚Äù in POPL. ACM, 2006, pp. 42‚Äì54.
[22] Y . Wei, Y . Pei, C. A. Furia, L. S. Silva, S. Buchholz, B. Meyer, and
A. Zeller, ‚ÄúAutomated Ô¨Åxing of programs with contracts,‚Äù in ISSTA.
ACM, 2010, pp. 61‚Äì72.
[23] B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Min ¬¥e,
D. Monniaux, and X. Rival, ‚ÄúA static analyzer for large safety-critical
software,‚Äù in PLDI. ACM, 2003, pp. 196‚Äì207.
[24] S. Gulwani, S. Jain, and E. Koskinen, ‚ÄúControl-Ô¨Çow reÔ¨Ånement and
progress invariants for bound analysis,‚Äù in PLDI, 2009, pp. 375‚Äì385.
[25] G. Yang, C. S. P ÀòasÀòareanu, and S. Khurshid, ‚ÄúMemoized symbolic
execution,‚Äù in ISSTA. ACM, 2012, pp. 144‚Äì154.
[26] W. A. Stein et al., ‚ÄúSage Mathematics Software,‚Äù 2017, http://www.
sagemath.org.
[27] E. R. Carbonell and D. Kapur, ‚ÄúGenerating all polynomial invariants
in simple loops,‚Äù Journal of Symbolic Computation, vol. 42, no. 4, pp.
443‚Äì476, 2007.
[28] R. Sharma, S. Gupta, B. Hariharan, A. Aiken, P. Liang, and A. V .
Nori, ‚ÄúA data-driven approach for algebraic loop invariants,‚Äù in ESOP.
Springer, 2013, pp. 574‚Äì592.
[29] S. Gulwani, ‚ÄúSPEED: Symbolic complexity bound analysis,‚Äù in CAV.
Springer-Verlag, 2009, pp. 51‚Äì62.
[30] S. Gulwani, K. K. Mehra, and T. M. Chilimbi, ‚ÄúSPEED: precise and
efÔ¨Åcient static estimation of program computational complexity,‚Äù in
POPL. ACM, 2009, pp. 127‚Äì139.
[31] I. Dillig, T. Dillig, B. Li, and K. McMillan, ‚ÄúInductive invariant
generation via abductive inference,‚Äù in OOPSLA, 2013, pp. 443‚Äì456.
[32] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar, ‚ÄúThe software
model checker BLAST,‚Äù Software Tools for Technology Transfer, vol. 9,
no. 5-6, pp. 505‚Äì525, 2007.
[33] A. Gupta and A. Rybalchenko, ‚ÄúInvgen: An efÔ¨Åcient invariant generator,‚Äù
inCAV. Springer-Verlag, 2009, pp. 634‚Äì640.
[34] B. Jeannet, ‚ÄúInterproc analyzer for recursive programs with numerical
variables,‚Äù 2014, http://pop-art.inrialpes.fr/interproc/interprocweb.cgi.
[35] W. Visser, J. Geldenhuys, and M. B. Dwyer, ‚ÄúGreen: Reducing, Reusing
and Recycling Constraints in Program Analysis,‚Äù in FSE. ACM, 2012,
pp. 58:1‚Äì58:11.
[36] K.-K. Ma, K. Y . Phang, J. S. Foster, and M. Hicks, ‚ÄúDirected symbolic
execution,‚Äù in SAS. Springer-Verlag, 2011, pp. 95‚Äì111.
[37] M. Staats and C. P ÀáasÀáareanu, ‚ÄúParallel symbolic execution for structural
test generation,‚Äù in ISSTA. ACM, 2010, pp. 183‚Äì194.
814
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 15:29:03 UTC from IEEE Xplore.  Restrictions apply. 