PFix: Fixing Concurrency Bugs Based on Memory Access
Patterns
Huarui Lin
School of Computer Software
Tianjin University
Tianjin, China
linhuaruitju@tju.edu.cnZan Wang∗
School of Computer Software
Tianjin University
Tianjin, China
wangzan@tju.edu.cnShuang Liu∗
School of Computer Software
Tianjin University
Tianjin, China
shuang.liu@tju.edu.cn
Jun Sun
Singapore University of Technology
and Design
Singapore
sunjun@sutd.edu.sgDongdi Zhang
School of Computer Software
Tianjin University
Tianjin, China
zhangdongdi@tju.edu.cnGuangning Wei
School of Computer Software
Tianjin University
Tianjin, China
weiguangning@tju.edu.cn
ABSTRACT
Concurrency bugs of a multi-threaded program may only mani-
fest with certain scheduling, i.e., they are heisenbugs which are
observedonlyfromtimetotimeifweexecutethesameprogram
withthesameinputmultipletimes.Theyarenotoriouslyhardto
fix. In this work, we propose an approach to automatically fix con-
currencybugs.Comparedtopreviousapproaches,ourkeyideais
tosystematicallyfixconcurrencybugsbyinferringlockingpolicies
from failure inducing memory-access patterns. That is, we auto-matically identify memory-access patterns which are correlated
with the manifestation of the bug, and then conjecture what is the
intended locking policy of the program. Afterwards, we fix theprogram by implementing the locking policy so that the failureinducingmemory-accesspatternsaremadeimpossible.Wehave
implemented our approach in a toolkit called PFix which supports
Java programs. We applied PFix to a set of 23 concurrency bugs
andareabletoautomaticallyfix19ofthem.Incomparison,Grail
which is the state-of-the-art tool for fixing concurrency bugs in
Java programs can only fix 3 of them correctly.
CCS CONCEPTS
•Software and its engineering →Software testing and debug-
ging;
KEYWORDS
Multi-threading, Concurrency bugs, Memory-access pattern, Lock-
ing policy, Automatic fixing
∗corresponding author
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
on the first page. Copyrights for components of this work owned by others than ACMmustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,orrepublish,topostonserversortoredistributetolists,requirespriorspecificpermissionand/ora
fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.3238198ACM Reference Format:
HuaruiLin,ZanWang,ShuangLiu,JunSun,DongdiZhang,andGuangning
Wei. 2018. PFix: Fixing Concurrency Bugs Based on Memory Access Pat-
terns. InProceedings of the 2018 33rd ACM/IEEE International Conference on
Automated Software Engineering (ASE ’18), September 3–7, 2018, Montpellier,
France.ACM,NewYork,NY,USA, 12pages.https://doi.org/10.1145/3238147.
3238198
1 INTRODUCTION
Multi-threadingisubiquitousnowadayswith thedevelopmentof
multi-coreandmany-coreprocessors.Concurrencybugs(ofamulti-
threaded program) are bugs which may only manifest with certain
scheduling,i.e.,theyareheisenbugswhichmayonlybeobservedif
we execute the same program with the same input multiple times.
Theyareknowntobehardtodebug[ 55].Thedifficultyinfixing
concurrent bugs is at least threefold. Firstly, it is challenging to
replay a concurrency bug. Even with the right test input, we must
find a failure-inducing scheduling as the bug may manifest only
with certain scheduling. In general, there could be exponentially
manyschedulingsinthenumberofschedulablepoints.Researchers
havetackledthisproblembyrecordingtheschedulingduringatest
executionsothatthebugcanbereplayed[ 12,13].Secondly,even
withtherecordedscheduling,debuggingthemulti-threadedbug
maystillbechallengingduetothelargenumberofstepsandcontext
switches in the test execution (i.e., the execution of the test case
with particular scheduling), many of which may not be relevant to
thebug.Aprogrammermustbeableto“abstract”thetestexecutionsoastoidentifytherootcauseofthebug.Recently,therehavebeen
several proposals on abstracting a test execution using memory-access patterns. It has been shown that memory-access patternsare often correlated to the presence of multi-threaded bugs [
50].
Thirdly,itischallengingtofixconcurrencybugsasafixmustbe
able to avoid the bug with all possible scheduling.
In this work, we investigate the problem of fixing concurrent
bugs. There have been multiple methods and tools proposed forfixing concurrency bugs [
25,29,32,34]. Existing approaches fix
concurrent bugs resulting in either atomicity violations [ 10,25,26,
33],deadlocks[ 9,53],ordataraces[ 48].Roughlyspeaking,existing
approaches design their fixes based on a few concrete execution
traces which are either obtained fromuser-provided bug reportsor
589
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
fromruntimemonitoring.WereferthereaderstoSection 5fora
detailed discussion on existing approaches.
Inmostofthecases,thefixinexistingapproachesamountsto
inserting additional locks and synchronization to inhibit the bad
concreteexecutions.In contrary,ourapproach isdesignedtosys-
tematicallyfixconcurrencybugsbasedoninferringtheintended
lockingpolicy(whichallowsustoreuseexistinglocks).Asstated
in [45] and other places, the key to reduce concurrency bugs and
ensure thread-safety is to design a locking policy according to the
program specification. For instance, a well-designed locking pol-
icymustguardthesamevariablewiththesamelockthroughout
theprogramandmustguardrelatedvariableswiththesamelock
throughoutthe program.Onlybyimplementing awell-designed
lockingpolicysystematicallythroughouttheprogram,wecanguar-
antee thread-safety and thus free of concurrency bugs. Ideally, ifthe locking policy is explicitly documented, we can fix a concur-
rencybugbyexaminingwherethelockingpolicyisnotcorrectly
implementedand fixit accordingly.In practice,howeversoftware
engineersoftendonotdocumentthelockingpoliciesproperly.The
challenge is then how to infer the locking policy and subsequently
fix concurrency bugs systematically.
Ourapproachisdesignedasfollows.Firstly,weapplyexistingap-
proachestosystematicallyidentifyfailure-inducingmemory-access
patterns with regard to a concurrency bug. The idea of correlating
bugswithmemory-accesspatternshasbeenexploredin[ 40,54,57].
It has been found that memory-access patterns are often corre-
latedwith theroot causeof concurrencybugs[ 50].In oursetting,
the failure-inducing memory-access patterns represent violationof the locking policy which ought to be implemented systemati-
cally to prevent the bug. Afterwards, we automatically conjecture
what is the intended locking policyof the program. The idea is to
identify a well-designed locking which makes the failure-inducing
memory-access patterns impossible. The last step of our approach
is to systematically fix the program by consistently implement-ing the conjectured locking policy throughout the program. Our
approach is different from those existing approaches on fixing con-
currency bugs as our fixes are based on a comprehensive set of
failure-inducing memory-access patterns (which have been shown
to be complete [ 50]), whereas existing approaches are often based
onconcreteexecutionsorparticularpatternslikesingle-variable
atomicity violation. Furthermore, our fixes work through consis-
tentlyimplementingwell-formedlockingpoliciesandthusnotonly
fixthoseprogramexecutionswhichhavebeenobservedbutalso
potentiallythoseunseenones.Itisourbeliefthatlockingpolicies
should play a central role in building thread-safe programs and
thus should be the basis of fixing concurrency bugs.
Our approach has been implemented in a self-contained toolkit
called PFix [ 4] (short for pattern-based fix) for Java programs.
PFix is implemented based on existing frameworks including Java
Pathfinder [ 19] and Soot [ 6]. We have experimented PFix with a
set of 23 concurrency bugs, which we collect from previously pub-
lished repositories. PFix is able to automatically fix 19 of them. On
average,PFixspends33.7secondstofixabug,whichweconsideris
reasonablyefficient.Forbaselinecomparison,weapplyGrail[ 34]
tothesamesetofbugsanditisonlyabletofix3ofthebugs.We
remark that other previously reported tools are either not main-
tainedortargetdifferentprogramminglanguages(e.g.,AFix[ 25],public synchronized StringBuffer append(StringBuffer sb){
if (sb == null) { sb = NULL; }
//fix: synchronized (sb) {
1. int len = sb.length();
int newcount = count + len;
if (newcount > value.length) {expandCapacity(newcount);}
2. sb.getChars(0, len, value, count);
//fix: }count = newcount;
return this;
}
public synchronized StringBuffer delete(int start,int end){
if (start < 0)
throw new StringIndexOutOfBoundsException(start);
if (end > count) { end = count; }if (start > end)
throw new StringIndexOutOfBoundsException();
int len = end - start;
if (len > 0) {
if (shared) { copy(); }System.arraycopy(value,start+len,value,start,count-end);
4. count -= len;
}return this;
}
public synchronized void getChars(int srcBegin,
int srcEnd, char dst[], int dstBegin) {
if (srcBegin < 0)
throw new StringIndexOutOfBoundsException(srcBegin);
if ((srcEnd < 0) || (srcEnd > count))
3. throw new StringIndexOutOfBoundsException(srcEnd);
if (srcBegin > srcEnd) throw
new StringIndexOutOfBoundsException("srcBegin>srcEnd");
System.arraycopy(value,srcBegin,dst,
dstBegin,srcEnd-srcBegin);
}
Figure 1: A concurrency bug in JDK1.4.2
AXIS [35] and CFix [ 26]). Furthermore, it has been reported that
Grail is stricter better than AFix and AXIS in [34].
The remainders of the paper are organized as follows. Section 2
illustrates how our approach works through an example. Section 3
presents the details of our approach step-by-step. Section 4evalu-
atesourapproach.Section 5discussesrelatedworkandSection 6
concludes.
2 MOTIVATING EXAMPLE
In this section, we show how our approach works with an illustra-
tive example. The example is a concurrency bug in the StringBuffer
class in JDK1.4.2 [ 1]. Figure1shows the relevant part of the pro-
gramundertest,i.e.,threemethodsofthe StringBuffer class.Method
appendappendsagivenstringbuffertotheendof thisstringbuffer;
methoddeletedeletes a substring (from index startto indexend)
fromthisstringbuffer;andmethod getCharscopiesfrom thisstring
buffer into the destination character array dstwith offset dstBegin.
Notethatmethod appendcallsgetChars throughtheinputstring
buffersb. All three methods are synchronized.
AtestcasewhichpotentiallyrevealsthebugisshowninFigure 2.
In the test case, two string buffer objects aandbare created and
two threads are created, one executing a.append(b) while the other
executing b.delete(0,b.length()).Executingthetestcasemanytimes,
we might observe a StringIndexOutOfBoundsException(srcEnd) due
toline3inmethod getChars.Oneconcreteexecutionwhichgen-
eratesthisexceptionisasfollows.First,onethreadexecutesline
1inmethod a.append(b) togetstringbuffer b’slength,whichis5.
Afterwards,theotherthreadexecutesmethod b.delete() todelete
everycharin b.Asaresult, b’scountbecomes0.Next,thethread
590
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns ASE ’18, September 3–7, 2018, Montpellier, France
Table 1: Memory-access patterns in the example
Memory-Access Pattern Susp.
(t1,l1,{count},{}) ,(t2,l4,{},{count}),(t1,l3,{count},{})1.00
(t1,l1,{count},{}) ,(t2,l4,{},{count}) 0.50
(t2,l4,{},{count}),(t1,l3,{count},{}) 0.49
executingmethod a.append(b) callsmethod b.getChars() atline2
withlenbeing 5. When method b.getChars() is executed, condition
srcEnd>count(which is 5 >0) is satisfied and thus the exception
is thrown.
Althoughtherecouldbemanyconcreteexecutionswhichgener-
atetheexception,wecanabstractlyseethattheexceptionoccurs
as long as the following memory-access pattern is present: thread
1 executes line 1, then thread 2 executes line 4, and then threads 1
executes line 3 to update the same variable count. In our approach,
PFix systematically analyzes multiple failing and passing concrete
executions in order to automatically identify a list of ranked ab-
stractmemory-accesspatternsinordertoidentifytherootcause
of the bug. There are a total of 17 generic patterns, and PFix scans
througheachconcreteexecutiontocountthenumberoftimesthat
an instance of those 17 patterns occurs. Table 1shows the three
patterns generated by PFix for this example where l1,l2,l3 andl4
denoteline1,2,3and4respectively.Eachpatterniscomposedofa
sequence of steps of the form (t,s,R,W), which reads thread texe-
cutes instruction sto read variables in Rand write variablesin W.
Notethatthefirstpatternmatchesourunderstanding,whereasthe
other two are patterns which capture only part of the first pattern.
PFix computes a suspicious score for each pattern based on how
frequent they appear in failed executions and passed executions.
The second column of Table 1shows the respective suspicious
scores.Notethatthefirstpatternisalwaysobservedinfailedtest
executions and thus has a suspicious score of 1.
Onceweidentifythefailure-inducingmemory-accesspatterns
(i.e.,the onesinTable 1),weproceed togeneratea fixforthe bug,
based on the most suspicious pattern first. For different genericpatterns, we have designed different fixes. According to our bug
fixingalgorithm(whichwillbepresentedindetailinSection 3),the
fix for this 3-step pattern is to add additional synchronization so
thatthefirststepandthethirdstepareinthesamesynchronizationblock.Intuitively,suchafixwouldmakethismemory-accesspattern
impossibleandthuspreventthebug.Thequestionis:whichlock
object do we use? To answer this question, PFix systematically
monitors all concrete executions in order to identify the locking
policy.Thatis,PFixmonitorseachsharedvariableandrecordwhich
lock is held when the variable is accessed (for either reading or
writing). In this example, PFix observes that variable b.countis
accessedalwayswithlock bheldandvariable a.countisaccessed
always with lock aheld. It thus conjectures that countin the class
is to be guarded by thisaccording to the locking policy.
Based on this locking policy, PFix then proceeds to analyze
whetheritispossibletointroducea synchronized blocksynchronized
( sb){}whichenclosesbothline1and3.Notethatthelockobject
issbsince both line 1 and line 3 access sb.count. As line 1 and 3
are in different methods, it is infeasible to introduce a synchronized
blockdirectly.PFixthenanalyzesthecallgraphinordertoidentify
acommonmethodwherethe synchronized blockcanbeintroduced.public void test() {
StringBuffer a = new StringBuffer("Hello");
StringBuffer b = new StringBuffer("World");new Thread(new Runnable () {
public void run() {
a.append(b);
}
}).start();
new Thread(new Runnable () {
public void run() {
b.delete(0, b.length());
}
}).start();
}
Figure 2: A test case for StringBuffer
Inourexample, becauseline3isexecuteddue tothefunctioncall
atline2andline1andline2areinthesamefunction,PFixthen
proceedstointroducea synchronized blockwhichbeginswithline1
andendswithline2,asshowninFigure 1intheformofcomments.
Lastly,wevalidatethefixedprogramthroughstandardmeans
(i.e.,extensive testingor usingtools likeJavapathfinder [ 19])and
repeat the above-discussed steps if necessary.
3 DETAILS OF THE APPROACH
Inthissection,wepresentdetailsofeachstepinourapproach.The
input to PFix is a buggy program as well as a set of executions of a
given test case (which can be obtained through standard means).
We assume that at least one of the test executions results in failure
(so that we know there is a concurrency bug).
3.1 Step 1: Identify Memory Access Patterns
The first step is to identify the failure-inducing memory-access
patterns. The reason that we focus on memory-access patterns
is that memory-access patterns are often correlated to bugs as
shown in [ 37,43]. An alternative is to focus on failure-inducing
scheduling, which is not ideal for multiple reasons. Firstly, there
mightbeahugenumberofschedulingandmanyofthemmaybe
failure-inducing. Identifying all of them would be expensive if not
infeasible. Secondly, even if we are able to identify all of them, it is
not clear how to fix the program so that all of them are prevented.
In comparison, concurrency bugs can be always reduced to one or
multiple of a total of 17 generic memory-access patterns as shown
in [42]. The idea is to design fixes for each and every one of the 17
patterns so that we can fix concurrency bugs systematically.
Amemoryaccesspatternisrepresentedintheformofasequence
ofstepsofatestexecution.Eachstepisatupleof (t,s,R,W),where
tisathreadid, sisabytecodeinstructiongeneratedbyastatement
inthe program, Risa setof variablesbeingread and Wisa setof
variablesbeingwritten.Givenabytecodeinstruction s,wewrite
oriдin(s)to denote the program statement which generates the
bytecode. In this work, we adopt the set of 17 memory access
patternsdefinedin[ 42],showninTable 2.Thesecondcolumnof
thetableshowsthememory-accesspattern.Eachmemory-access
pattern is a sequence of at most four steps in the test execution,
whichconcernsonlywithtwothreadsandatmosttwovariables.
Asaresult,givenatestexecution,thenumberofmemory-access
patterns is bounded by C2
N∗C2
M∗C4
KwhereNis the number of
shared variables, Mis the number of threads and Kis the total
number of steps in the test execution.
591
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
Table 2: The generic memory-access patterns [42]
IDMemory-Access Pattern
1(ta,si,{x},∅),(tb,sj,∅,{x})
2(ta,si,∅,{x}),(tb,sj,{x},∅)
3(ta,si,∅,{x}),(tb,sj,∅,{x})
4(ta,si,{x},∅),(tb,sj,∅,{x}),(ta,sk,{x},∅)
5(ta,si,∅,{x}),(tb,sj,∅,{x}),(ta,sk,{x},∅)
6(ta,si,∅,{x}),(tb,sj,{x},∅),(ta,sk,∅,{x})
7(ta,si,{x},∅),(tb,sj,∅,{x}),(ta,sk,∅,{x})
8(ta,si,∅,{x}),(tb,sj,∅,{x}),(ta,sk,∅,{x})
9(ta,si,∅,{x}),(tb,sj,∅,{x}),(tb,sk,∅,{y}),(ta,sl,∅,{y})
10(ta,si,∅,{x}),(tb,sj,∅,{y}),(tb,sk,∅,{x}),(ta,sl,∅,{y})
11(ta,si,∅,{x}),(tb,sj,∅,{y}),(ta,sk,∅,{y}),(tb,sl,∅,{x})
12(ta,si,∅,{x}),(tb,sj,{x},∅),(tb,sk,{y},∅),(ta,sl,∅,{y})
13(ta,si,∅,{x}),(tb,sj,{y},∅),(tb,sk,{x},∅),(ta,sl,∅,{y})
14(ta,si,{x},∅),(tb,sj,∅,{x}),(tb,sk,∅,{y}),(ta,sl,{y},∅)
15(ta,si,{x},∅),(tb,sj,∅,{y}),(tb,sk,∅,{x}),(ta,sl,{y},∅)
16(ta,si,{x},∅),(tb,sj,∅,{y}),(ta,sk,{y},∅),(tb,sl,∅,{x})
17(ta,si,∅,{x}),(tb,sj,{y},∅),(ta,sk,∅,{y}),(tb,sl,{x},∅)
It has been shown that these memory-access patterns capture
the essence of multi-threaded bugs [ 42]. In addition, it is shown
thatthissetiscomplete[ 50],asmulti-threadedbugscanbereduced
to one or more of these patterns. The memory-access patterns can
be viewed as an abstraction of the test execution, which allows us
to get rid of irrelevant details and yet preserve the cause of the
multi-threaded bug.
Based on the frequency of the memory-access patterns in the
testexecutions,wecalculateasuspiciousnessscoreforeachpattern
using Equation 1, where # fail(p)is the number of failing test exe-
cutionsinwhichthepattern poccursand# succ(p)isthenumber
of passing test executions in which the pattern poccurs.
suspicious (p)=#fail(p)
(#fail(p)+#succ(p))(1)
The larger the suspicious score, the more likely that the pattern
isfailure-inducing.Therefore,wesortthepatternsbasedontheir
suspicious scores in the descending order.
3.2 Step 2: Identify Locking Policy
Once the failure-inducing memory-access patterns have been iden-
tified, we proceed to identify the locking policy on the relevant
variables.Theideaistocheckiftherearelockingpoliciesdesigned
forthevariablesandwhetherthereasonofthebugisthatthelock-
ingpolicyhasnotbeenimplementedproperlyonthepartwhere
the failure-inducing memory access pattern is observed. Formally,
a locking policy is a function lockP:V→LwhereVis the set
of variables and Lis the set of locks. Note that we assume that
a variable should be guarded by exactly one lock following the
discussion in [ 45]. We use lockP(x)=yto denote that variable xis
guarded by lock y. A locking policy is consistently implemented if
andonly ifeveryaccessof any xisguarded byalockon lockP(x)
throughout the program1.
Inourapproach,weinferthelockingpolicydynamically.Thatis,
wemonitoratruntimewhenalockisheldandreleasedforeachtest
execution.Foranyvariable x,wethenobservewhetheritisaccessed
1Except the constructors since they are handled differently in Java.(either for reading or writing) while some lock yis being held. We
may observe that multiple locks are held while xis accessed, in
which case lockP(x)could be any of the held locks or even none
of them if we assume that the locking policy is not consistently
implemented.Ingeneral,wecanobtainabagofobservationsinthe
form of(x,y)wherexis a variable and yis a lock. Afterwards, we
heuristicallyconjecturethat lockP(x)isyif(x,y)occursmorethan
anyotherpairs (x,z)inthebag.Forinstance,intheexampleshown
inSection 2,weobtain (count,this)foreveryaccessof countinthe
class and thus conclude lockP(count)isthis.
We remark that another way to obtain the locking policy is
throughstaticanalysis,i.e.,staticallyanalyzewhenalockisapplied
andreleased,aswellasthevariablesaccessedinbetween.However,
compared to dynamic analysis, static analysis may suffer from
imprecision due to aliasing, dynamic typing, etc. Therefore, in our
work,weadoptdynamicanalysis,whichprovidesmoreaccurate
results.
3.3 Step 3: Fix Bugs
Afterobtainingthelockingpolicy,wethenexamineeachfailure-
inducing memory-access pattern (from the most suspicious to the
least) and see whether the bug is due to an inconsistent implemen-
tation of the locking policy or rather the locking policy itself isproblematic. In the following, we discuss how a bug is fixed for
eachfailure-inducingmemoryaccesspattern.Thegeneralideais
to design a fix such that the corresponding memory-access pat-
tern would be avoided. The algorithm is presented as Algorithm 1,
whichtakesasinputthefailure-inducingpattern patternandthe
lockingpolicy lockPwhichwehaveinferredinthepreviousstep.
The algorithm to fix bugs according to memory access pattern 1 to
3, 4 to 8 and 9 to 17 (of Table 2)a r es h o w nf r o ml i n e1t o9 ,1 0t o1 4
and 15 to 28 (of Algorithm 1), respectively.
Line1to9inAlgorithm 1appliesif patternismemory-access
pattern1to3inTable 2.Allofthesepatternshavetwosteps,where
two different threads read/write on a shared variable in certainorder. They are fixed in the same way. In the following, we use
the pattern
(ta,si,{x},∅),(tb,sj,∅,{x})(pattern 1 in Table 2)a s
an example to illustrate the fix. To make sure that these two steps
are ‘separated’ in the fixed program, we distinguish two cases in
fixing the bug. The first case is that siis not the last access of xin
oriдin(si)(whichisthesourcecodestatementcontaining si)orsj
isnotthefirstaccessof xinoriдin(sj).Insuchacase,weassume
thatthebugcanbeavoidedif oriдin(si)isfinishedbeforethread tb
preempts it or the other way around. To achieve that, we examine
whetherlockP(x)isdefined.Ifitisthecase,weenclose oriдin(si)
andoriдin(sj)in a synchronization block with lock lockP(x).I f
lockP(x)is not defined, we introduce a new lock l, and implement
thelockingpolicybyenclosingeveryaccessof xwithalockon l.
Notethatthesamelockingpolicyshouldbepropagatedthroughout
the program for all accesses of x, not only those statements in the
pattern.Ifhowever siisthelastaccessof xinoriдin(si)orsjisthe
first access of xinoriдin(sj), we conclude that the bug occurs if
stateoriдin(si)is followed by oriдin(sj)and this can not be fixed
withamodifiedlockingpolicyon x.Thefixisthentopreventsuch
ordering.Thisisachievedbyintroducingafreshvolatileboolean
variablezwithinitialvaluefalse,adding if(z)beforeoriдin(si)and
592
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns ASE ’18, September 3–7, 2018, Montpellier, France
Algorithm 1: Algorithm fix(pattern,lockP)
input:pattern : a failure-inducing pattern; lockP: a locking policy; the buggy program
output:the fixed program based on lockP
1ifpattern is any of pattern 1-3 in Table 2then
2if(ta,si,{x},∅)is not the last xaccess oforiдin(si)or(tb,sj,∅,{x})is not the first xaccess oforiдin(sj)then
3 iflockP(x)does not exist then
4 setlockP(x)=lwherelis a fresh lock and enclose oriдin(si)andoriдin(sj)with synchronization on l;
5 else
6 encloseoriдin(si)and/ororiдin(sj)with synchronization on lockP(x);
7else
8 introduce a fresh volatile boolean variable zwith initial value false ;
9 addif(z)beforeoriдin(si)and addz=trueafteroriдin(sj);
10ifpattern is any of pattern 4-8 in Table 2then
11iflockP(x)does not exist then
12 setlockP(x)=lwherelis a fresh lock and enclose oriдin(sj)and enclose oriдin(sj=i)andoriдin(sk)in the same block with
synchronization on l;
13else
14 encloseoriдin(sj)and enclose oriдin(sj=i)andoriдin(sk)in the same block with synchronization on lockP(x);
15ifpattern is any of pattern 9-17 in Table 2then
16iflockP(x)does not exist and lockP(y)does not exist then
17 setlockP(x)=lwherelis a fresh lock and enclose the two steps of tain the same block with synchronization on l;
18 enclose the two steps of tbin the same block with synchronization on l;
19else iflockP(x)does not exist then
20 setlockP(x)=lockP(y);
21 enclose the two steps of tain the same block with synchronization on lockP(y);
22 enclose the two steps of tbin the same block with synchronization on lockP(y);
23else iflockP(y)does not exist then
24 setlockP(y)=lockP(x);
25 enclose the two steps of tain the same block with synchronization on lockP(x);
26 enclose the two steps of tbin the same block with synchronization on lockP(x);
27else
28 setlockP(x)=lockP(y)and and apply the locking policy for every access of xandy;
1.voidtest () throwsException {
2.finalDd=new D();
3. Thread d1 = newThread(){public void run () {d.m1();}};
4. Thread d2 = newThread(){public void run () {d.m2();}};
5. d1.start(); d2.start();
6. d1.join(); d2.join();7.if(d.x<1) { assert(false); } //d.x<2
}classD{
8.intx=0 ;
9.voidm1() { x++; }
10.voidm2() { x*=2; }
}
Figure 3: An example illustrating repairing
addingz=trueafteroriдin(sj). Intuitively, it is then guaranteed
thatoriдin(sj)must be completed before oriдin(si).
Toillustratethe differencebetweenthesetwocases, letuslook
at the example shown in Figure 3. Note that line 9 and line 10 both
have two accesses (i.e., one read followed by one write) of variableclassD{
intx = 0; Object obj = newObject();
voidm1() {synchronized (obj) {x++;} }
voidm2() {synchronized (obj) {x*=2;} }
}
Figure4:Anexamplerepair(case1)forprograminFigure 3
classD{
intx=0 ;volatile bool flag = false;
voidm1() { x++; flag=true;}
voidm2() {if(flag) {x*=2;} }
}
Figure5:Anexamplerepair(case2)forprograminFigure 3
x. Given the assertion at line 7, one failure-inducing pattern which
could be identified is: (d1,l91,{d.x},∅),(d2,l102,∅,{d.x}). Intu-
itively,itmeansthatthread d2executes m2firstandthread d1reads
d.xbefored2finishesexecutingline10.Since (d1,l91,{d.x},∅)is
593
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
notthelastaccessof d.xbythread d1,applyingtheaboverepair-
ing strategy, we fix the program by introducing a fresh lock and
surrounding both line 9 and 10 with a synchronization block. This
is shown in Figure 4.
Ifwechangetheconditionatline7tobetheoneinthecomment
(d.x<2), one failure-inducing pattern which could be identified
is:(d2,l102,∅,{d.x}),(d1,l91,{d.x},∅),whichisaninstanceofpat-
tern2inTable 2.Intuitively,itmeansthatthread d2executes m2to
finishfirstandthread d1executes m1.Notethatthememoryaccess
patterninthepreviousparagraphisnolongerfailure-inducing.The
reason is that the assertion failure will be avoided only if thread
d1finishesexecutingline9beforethread d2startsexecutingline
10. In this case, since (d2,l102,∅,{d.x})is the last access of d.xby
threadd2, and(d1,l91,{d.x},∅)is the first access of d.xbyd1, ap-
plyingtheaboverepairingstrategy,wefixtheprogramasshownin
Figure5.Notethat flaдisdeclared volatilesoastoavoidvisibility
issues (due to caching).
The fixes for patterns 4 to 8 are the same, as shown in line 10 to
14inAlgorithm 1.Intuitively,thesefailure-inducingpatternscan
be prevented if we prevent thread tbfrom executing in between
siandsk. Thus, the idea is to implement a fix such that siand
skareinthesamesynchronizationblock.Therearetwocasesto
fix the bug. If lockP(x)does not exist, i.e., there lacks a locking
policy for x, we introduce a new lock land enclose siandskin
the same synchronization block with lock l, and enclose sjwith
a synchronization block with lock las well. Note that by right,
thisnewlockingpolicyon xmustbepropagatedthroughoutthe
program.If lockP(x)doesexist, weapplythesame fixusinglock
lockP(x)instead.
The fixes for pattern 9 to 17 are also the same. Intuitively, these
patterns can be prevented if we implement a fix such that the two
steps of thread taandtbin these patterns become atomic. The
remaining question is then which lock to use. Note that becausethese patterns are failure-inducing, we would assume that
xand
yarerelatedandthereforethelockingpolicyshouldbesuchthat
lockP(x)=lockP(y). We distinguish four cases on fixing the bug.
IfbothlockP(x)andlockP(y)arenotdefined,weuseafreshlock
lto fix the bug. Otherwise, if either lockP(x)orlockP(y)is de-
fined, we use the associated lock to fix the bug. Lastly, if both
lockP(x)andlockP(y)aredefinedbut lockP(x)/nequallockP(y),weset
lockP(y)to belockP(x)to fix the bug. These four cases are han-
dled accordingly in Algorithm 1, i.e., line 16-18 handle the case
where no locking policies for xoryexist; line 19-26 handle the
case where one locking policy exists either for x(line 19-22) or
y(line 23-26) but not both, and line 27-28 handle the case where
lockingpoliciesexistforboth xandy.NotethatPFixisdesigned
to fix concurrency bugs using synchronization blocks instead oflocks (i.e.,
java.util.concurrent .Locks) as synchronization blocks
are easier to maintain.
3.4 Step 4: Fix the Fixed Program
After the last step, we have applied a fix according to the failure-
inducing memory-access pattern and transformed the program to
geta“fixed”version.Next,weapplyafurthersteptofixthe“fixed”
program. This step has two main goals. One is to propagate theupdated locking policy throughout the program. The other is tomakesurethetransformedprogramisnotonlycompilablebutalso
efficient (e.g., without redundant locking).
Topropagatetheupdatedlockingpolicy,foreachsharedvariable
x, we analyze the program systematically to identify part of the
program which accesses x. For each access, we analyze whether
theaccessisguardedbyalockbymonitoringwhatarethelocks
which are held (and not released) before executing that part of
theprograminallthetestexecutions.Letthesetoflocksheldbe
denotedas L.Wethencheckwhether LincludeslockP(x),whichis
thelockforguarding xaccordingtotheidentifiedlockingpolicy.If
it is, we do nothing. Otherwise, we introduce a synchronized block
toenclosethepartoftheprogramwithalockobject lockP(x).This
way,wemakesurethelockingpolicyissystematicallyimplemented
throughout the program. Note that because our implementation
is based on dynamic analysis, we will not propagate the locking
policy to the part of the program which is never executed in the
test executions.
As demonstrated in Section 2, we may not always be able to
applythefixaccordingtoAlgorithm 1.Forinstance,twostatements
whichwewouldlikeencloseinthesame synchronized blockmay
be scattered in two very different parts of the program. We thus
applyanapproachsimilarto[ 32]tomakesurethefixedprogram
is syntactically correct. That is, we use Eclipse AST to check thescope of each synchronization block. If we find that the addedsynchronization crosses the original block of statements in the
program,i.e.,ifstatement,forloopandwhileloop,weadjustthe
scope of the added synchronization block so that it can include
theentireblockofstatements.Ifweneedtoaddsynchronization
blocksintwodifferentfunctions,wefirstuseSoottoidentifythe
call function, and then find the right place to add synchronization
so that the two statements are in the same block. In order to avoid
redundant locking, if we find that the added synchronization block
is in a constructor function, we discard the added synchronization.
3.5 Step 5: Test the Fixed Program
Asthe laststep, wetestthe fixedprogramby usingJPF torunthe
fixedprogram100times.Werepeatthefixingprocessifthereare
errorsoccurduringthetesting.Thenumber100ischosenbasedon
our experience that a program found to have errors during manual
inspections can almost consistently expose errors by executing 100
times with JPF random scheduling.
3.6 Overall Algorithm
The overall algorithm of our approach is shown in Algorithm 2.
Given a buggy program and a test case, we run the test case many
times in order to obtain a set of concrete test executions. In our
implementation,weuseJavaPathfindertogeneratedifferentsched-
uling.Next,werunthestate-of-the-artapproachUnicorn[ 42]to
obtain a ranked list of potential failure-inducing memory accesspatterns (line 3). Then we infer locking policies dynamically asdiscussed above (line 5). After the locking policy is obtained, wefix the concurrency bug based on our fixing algorithm shown in
Algorithm 1(line6).Afterapplyingthefixing,weapplystep4to
fix the fixed program. Lastly, we test the fixed program (i.e., run
theprogram100timeswiththehelpofJavaPathfinder)tocheck
whetherthebugisindeedfixed(line8).Ifallthe100testexecutions
594
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns ASE ’18, September 3–7, 2018, Montpellier, France
Algorithm 2: Overall Algorithm
input:a buggy program and a test case
output:a fixed program
1whiletruedo
2test the buggy program to obtain a set of test executions;
3obtain a ranked list of failure-inducing pattern P(Step 1);
4select (and remove) the most suspicious pattern p;
5identify locking policy lockPforp(Step 2);
6fix(p,lockP)(Step 3);
7fix the “fixed” program (Step 4);
8test the fixed program (Step 5);
9ifno failure is generated then
10 break;
Figure 6: The overall structure of PFix
pass, we conclude that the bug is fixed and the algorithm termi-
nates (line 10). If there are still failures observed during the test
executions, we repeat the above process.
4 IMPLEMENTATION AND EVALUATION
In thissection, wediscuss theimplementation detailsof PFix and
the evaluation results.
4.1 Implementation
The proposed method has been implemented in a self-contained
toolkit called PFix. PFix has a total of 4895 line of codes and thesource code is available online at [
4]. The overall structure of
PFix is shown in Figure 6. PFix is implemented based on Java
Pathfinder [ 19], Soot [6], Eclipse AST [ 3] and Unicorn [ 42]. PFix
utilizes Java Pathfinder and Unicorn to automatically detect shared
variables among multiple threads, and provides shared memory
accessinformationatruntimeinstep1.Unicornisusedtoautomat-
icallyidentifya rankedlistofsuspicious memory-accesspatterns.
Basedonthepatternsthatisobtainedfromstep1,PFixidentifies
the corresponding locking policies based on Java Pathfinder and
Unicorn in step 2. Then PFix implements our fixing method by uti-
lizing Soot and Eclipse AST. Soot is a Java optimization framework.
In this work, we use it to obtain the function call graph of a given
program.Thefunctioncallgraphisnecessaryinourapproachtohandlecasesinwhichstatementsofamemory-accesspatternare
in different functions. In such a case, a call graph generated bySoot, which allows us to identify the right scope for introducingsynchronized block. Eclipse AST, a part of Eclipse JDT is used to
analyze the program syntactically, find the location that the fix
patch should be inserted and then fine-tune the patch if the added
patchresultsincompilationerrors.Inthelaststep,PFixteststhe
fixed program using Java Pathfinder, Eclipse AST and Unicorn.
4.2 Evaluation Settings
Our evaluation subjects include concurrency bugs in Java pro-
grams from multiple existing benchmarks, including the SIR repos-
itory [15,21], Pecan’s benchmark programs [ 1] and JaConTeBe [ 2].
NotethatduetolimitationsofJavaPathfinder(unabletoexecute
largeJavaprograms),wearenotabletoapplyPFixtoalltheconcur-rencybugsinthebenchmarks.Intotal,wesuccessfullyappliedPFix
to 23 concurrency bugs to test our fixing method. The programs
are chosen based on the following reasons. Firstly, our methodfocuses on fixing concurrency bugsin Java. Therefore, we targetprograms which are written in Java and are known to have con-
currency bugs. Secondly, our approach adopts Java Pathfinder for
bug localization and repair. We thus focus on programs which JavaPathfindercanhandle
2.Informationontheseconcurrencybugsare
summarized in Table 3. The actual programs are available in our
Github repository [5].
Inthefollowing,weevaluatePFixintermofitseffectivenessand
efficiency.Allourexperimentresultsareobtainedonacomputer
with3.40GHzCPU,16GBmemory.WeuseWindows10andJDK
1.8. For each concurrency bug, we first run Java Pathfinder 100
timestoobtaintestexecutions(whichincludebothfailingonesand
passing ones). Unicorn [ 42] is then executed 100 times to obtain
memory-access patterns in the test executions. Afterwards, we
apply our approach for fixing the bug as discussed in Algorithm 1
based on the most suspicious pattern. After fixing the bug, we run
JavaPathfinder100timesinordertodeterminewhetherthebug
has been fixed. In addition, we run random testing 100 times on
thefixedprograminordertofurthertestit.Ifnobugisreported,
we conjecture that the bug has been fixed. Otherwise, we obtain
suspicious patterns and repeat our approach until either we fix the
program or run out of suspicious patterns. For each fixed program,
wethenmanuallyinspectwhetherthebugistrulyfixed.Wetakethe
original fix as a reference to check whether PFix fixes the program
correctly.
4.3 Evaluation Results
TheevaluationresultsareshowninTable 3.Thefirstthreecolumns
showthenameoftheprograms,thenumberlinesofthenativecode
(excluding the invoked library) and the bug type (e.g., atomicity
violation, data race, consistency bug)3. Columns 4 to 7 show the
evaluationresultswithPFix,includingthetime(inseconds)used
to identify the potential failure-inducing memory access patterns,
the time used to fix the bug, the number of locks added in order to
2In the future, we plan to replace Java pathfinder with an approach based on code
instrumentation so that our approach is more scalable.
3We use “unknown” to indicate that the root cause of the bug is complicated and it is
hard to classify it into existing types
595
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
Table 3: Evaluation Results: time is measured in seconds
program name #line typePFix Grail
time for patterns time fixing #lockfix status time fixing (s) #lockfix status
account 102atomicity violation 22.7 238.75 1success 3709 5success
accountsubtype 138atomicity violation 29.4 21.4 1success 490 4success
airline 51atomicity violation 8.35 16.2 1success NA NA NA
alarmclock 206 unknown 10.75 113.75 NA fail NA NA NA
atmoerror 48 data race 7.3 5.95 1success 146 1 fail
buggyprogram 258atomicity violation 9.45 33.55 2success 143 1 fail
checkfield 41atomicity violation 7.15 9.8 2success NA NA NA
consisitency 28consistency bug 6.75 9.95 1success NA NA NA
critical 56atomicity violation 15.4 14.1 2success 137 2 fail
datarace 90 data race 8.1 51.15 1success 152 NA fail
even 49atomicity violation 7.25 91.15 1success 155 1 fail
hashcodetest 1,258atomicity violation 8.45 7.45 1success 178 2 fail
linkedlist 204atomicity violation 7.95 35.25 1success 149 NA fail
log4j 18,799 atomicity violation 22.9 20.35 1success NA NA NA
mergesort 270 unknown 17.95 204.7 NA fail 630 6 fail
pingpong 130 data race 25.2 23.05 1success NA NA NA
pool 1,815 unknown 10.95 248.05 NA fail NA NA NA
ProducerConsumer 144 unknown 16 108.2 NA fail 221 1 fail
reorder2 135 consistency bug 7.7 11.9 1success NA NA NA
store 44atomicity violation 7.2 5.85 1success NA NA NA
stringbuffer 416atomicity violation 7 22.2 1success 172 NA fail
wrongLock 73atomicity violation 7.15 5.9 1success 156 3success
wrongLock2 36 data race 7.3 16.4 1success 146 1 fail
fixthebugandthefixingstatus(successorfail).Foreachfix,we
manuallycheckwhetherthefixiscorrectornot.Thedatashows
that PFix is able to fix 19 out of 23 in the benchmark. There are
fourcaseswhereourmethodisnotableto(completely)fixthebug.
We analyze them one by one in the following.
Inthecaseofthe ProducerConsumer program,theoriginalpro-
gram tries to guard a static shared variable with a lock on this
object.Suchalockingpolicyisproblematicastherearemultiple
instances of the class in the program and different threads lock on
differentthisobjectsbeforeaccessingthestaticvariable,whichis
as good as no locking at all. PFix is able to detect this ill-formed
locking policy and successfully fix it using a shared lock. However,
there is a further issue in the program. That is, if the consumer
threads are very fast, there will be one producer thread waiting
forever. The reason for this issue is that the main method proceeds
to check the result (i.e., an assertion) without waiting for all pro-
ducerstofinish.AlthoughitispossibleforPFixtofindtherelevant
failure-inducing memory-access pattern for this issue and fix it
through line 8 in Algorithm 1, PFix times out without success. For
the case of the alarmclock program and the poolprogram, we man-
ually analyse the source code and found that PFix failed to find
therealfailure-inducingmemory-accesspattern.Thisispossible
sincethetestexecutionsarerandomlygeneratedandthustheright
failure-inducing pattern may not always be the most suspicious.Forthemergesort program,theidentifiedpatterniscomposedof
statements from multipleclasses. PFix fixed the programby intro-
ducing a shared static object and adding a synchronized block for
each statement in the pattern, which unfortunately introduced a
deadlock.Ingeneral,itispossibletointroducedeadlocksasPFixsometimesintroducesadditionalsynchronization.Suchproblems
can be solved using existing approaches on fixing deadlocks [ 9],
which we leave as future work.
Forabaselinecomparison,weapplyGrail[ 34],whichisthestate-
of-the-art concurrency bug fixing tool for Java programs, on the
sameset ofbenchmarks. We remarkthatother previously reported
tools are either not maintained or target different programming
languages(e.g.,AFix[ 25],AXIS[35]andCFix[ 26]).Furthermore,it
has been reported in [ 34] that Grail is stricter better than AFix and
AXISoverasetofbenchmarks.TheresultsofGrailareshownin
thelastthreecolumnsofTable 3.GrailisbuiltbasedonPecan[ 20],
whichisatoolfordetectinggeneralaccessanomalies(AAs)incon-
current programs.AAs are similarto thememory-access patterns.
Pecan generates AAs of length 2 to 4. Our inspection of Grail’s
source code shows that Grail is designed to only fix programs with
length3AAs(i.e.,atomicityviolation)4.Amongallthe23programs
inourbenchmark,only4programs,i.e., account,accountsubtype,
wrongLock andbuggyprogram result in AAs of length 3. In order
to run more programs with Grail, we then manually modify the
outputofPecansothatthegeneratedAAshavelengthof3.Note
thattheAAsaremodifiedinawaysuchthatthecauseofthebug
in the original AA is not tampered. After the modification, Grail
successfully runs on 14 benchmarks. The other 9 programs that
cannotbeexecutedbyGrailaremarked NAinthethirdlastcolumn
of Table3.
Out of the 14 buggy programs, Grail is able to generate fixes for
11 of them. Our manual inspection, however, shows that only 3 of
4We tried our best to contact the authors of Grail and got no response.
596
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns ASE ’18, September 3–7, 2018, Montpellier, France
themarecorrect.Inthefollowing,weinvestigatewhyGrailfails
on many of the benchmarks.
•Grailisunabletofixbugswhichareacrossmultipleclassesor
methods.Weencountersuchsituationsinprograms linkedlist,
dataraceandstringbuffer where errors are reported by Grail
during the fixing process.
•Grailsometimesfailstoidentifythecorrectscopeforadding
locks. As a result, bugs remain after the fix. This happens
for programs evenandcritical.
•Grail has several implementation issues. For instance, if one
AA contains multiple statements at the same line, the fixing
codes may overwrite each other. This happens for program
wrongLock2, buggyprogram, and atmoerror. The result is a
program which has a statement for lock release with no
matchinglockacquirestatement.Incaseof hashcodetest,the
fix inserts two lock acquire operations but only one lock
release operation, which results in a deadlock.
•Lastly,Grailmaygenerateruntimeexceptionswhenthey
are applied to fix certain programs, e.g., program datarace.
Thereare4programs,i.e., alarmclock, mergesort, ProducerConsumer
andpool,that neitherPFixnorGrail canfix.All the bugsthatcan
be fixed by Grail are fixed by PFix.
Intermsofefficiency,PFixismoreefficient.Itsexecutiontime
rangesfromafewsecondstoafewminutes,whereasGrailisslower
in most cases. For some cases like the program account, Grail takes
10timesmoreexecutiontimethanPFix.Thereasonmaybebecause
Grail needs to conduct constraint solving during bug fixing, which
isverytimeconsuming.Furthermorenoticethatinmostcases,PFix
generates a fix which uses less locks than Grail. For all benchmark
programs, PFix introduces at most 2 locks whereas Grail generates
as many as 6 locks. The reason is that PFix is designed to fix the
bug based on the intended locking policy (i.e., using existing locks
unless a locking policy is missing for some variables). Introducing
excessive locks potentially makes the fix hard to comprehend andincreases the likelihood of introducing deadlocks.
4.4 Threats to Validity
In the following, we discuss the threats to validity in our experi-ments. Firstly, PFix is implemented based on Java Pathfinder. As
aresult,wearenotabletoevaluateourapproachwithverylarge
Java programs. While Java Pathfinder provides a good platform for
implementingourapproach(e.g.,foridentifyingsharedvariables
and obtaining status of locks), our method is not restricted to Java
Pathfinder.Inthefuture,weplantomitigateourimplementation
entirely to be based on Soot and Eclipse AST, which hopefully will
enable us to handle larger programs.
Secondly,instep1ofourapproach,werelyonexistingapproach
toidentifyarankedlistoffailure-inducingmemoryaccesspatterns.
Such ranking is based on simple statistical measurements and thus
may not be accurate. Although the most suspicious pattern is usu-
ally the correct one in our experiments with the 23 benchmarkprograms, in general there is no guarantee that the real failure-inducingpatternwillbethemostsuspicious.Furthermore,there
maybemultiplefailure-inducingmemory-accesspatterns.Differ-
ent patterns might lead to different fixes, some of which may be
better than others.Thirdly,instep4ofourapproach,weverifythefixedprogram
with random testing. Although we test for 100 times, it is possible
thattherearestillconcurrencybugsthatarenotrevealed.There-
fore, we manually inspect the fix to determine its validity in our
experiments.Thisproblemcanbepotentiallysolvedbyadopting
approaches like symbolic execution or model checking.
Lastly,PFixpotentiallyintroducesdeadlocks(e.g.,theaccount
program) and/or performance overhead. This is particularly the
case when PFix generates multiple fixes after repeating the fixing
process a few times. This problem can be potentially solved by
applyingexistingapproachesonfixingdeadlocks(e.g.,[ 9,53])to
the fixed programs.
5 RELATED WORK
Our approach is inspired and related to mainly three groups of
existing work, i.e., fault detection and localization, memory access
pattern analysis and most importantly, concurrency bug fixing. We
review them below.
Concurrency Bug Fixing. Our work is closely related to theline
of work on fixing concurrency bug. Different approaches have
beenproposedtofixconcurrencybugseffectivelyandefficiently.
Thereare manyproposalsto fixconcurrencybugsby eliminating
erroneousinterleavingpatterns,e.g.,[ 22,25,26,35].Inparticular,
Huanget al.[22] proposed to fix concurrency bugs by inserting
synchronization. Bradbury et al. [ 8], inspired by the use of genetic
programming in sequential software debugging, proposes to apply
genetic programming to fix concurrency bugs.
Therearea fewapproachesforfixingatomicityviolationbugs.
AFix [25] takes the CTrigger’s [ 41] output as input and adds a mu-
texlocktotheprogramtofixconcurrencybugs.AFixalsomodifies
CTriggertooutputallpossiblecombinationsofatomicity-violation
triples and the complete call stack for each atomicity-violation re-
lated statements. It collects each bug report patch and statically
identifies patches that can be merged or optimized to improveperformanceorreadability(e.g.,byremovingredundantpatchesand merging patches). On the basis of AFix, CFix [
26] fixes con-
currencybugsduetoorderviolation.Byaddingsynchronization,
CFix enforces all A-Borfirst A-B order relationships to fix or-
derviolation.CFixalsoenforcesmutualexclusionwiththesame
method. Axis [ 35], similar to AFix, fixes atomicity violations by
addingmutualexclusionlocksandsynchronizationmeasures.Axis
additionally takes efforts to reduce the possibility of introducing
deadlocks. Axis abstracts the source program into Petri net [ 49] us-
ing the supervisory control theory, i.e., Supervision Based on Place
Invariants (SBPI) [ 24], which turns the problem of program repair
intoaconstraintsolvingproblem.AlphaFixer[ 11]specializesinfix-
ing atomicity violations, it summarizes previous approaches based
on locking. By analyzing the lock acquisitions, AlphaFixer fine-
tunesthelockingsothatitispossibletoreducetheintroductionof
deadlocks.
In the name of generating high quality patches, Liu et al.[32]
proposedHFix,whichdesignsfixstrategiesguidedbyasurveyof77manualpatchesofreal-worldconcurrencybugs.Inadditiontousing
mutex locks, HFix can also use the create and join operations of
threads, while modifying the original locks to achieve the purpose
of fix. Grail [ 34] fixes concurrency bugs by adding locks in ways
597
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
similartoAFixandAxis.ComparedtoAFix,Grailadditionallytakes
measures for deadlock-freedom. Grail builds a Petri net analysis
model of the buggy program. The model is context-aware andconsiders lock alias by adding constraints to the Petri net model.
Compared to Axis, Grail guarantees at least the same concurrency
levelifnothigher.Grailcanbetimeconsumingduetotheuseof
constraint solving. Besides, Grail fails to consider related variables,
and thus cannot fix multi-variable bugs.
Althougha lotof workhas beenproposed onconcurrency bug
fixing, there is still room for improvement (as demonstrated in our
experiments). Our approach distinguishes itself from the above
workinmultipleways.Firstly,ourfixingisbasedonmemoryac-
cesspatterns,whichistherootcauseoftheconcurrencybugs.It
helps us accurately identify the statements which cause the bug.
Although some existing approaches like AFix and CFix use pat-
terns like (p, c, r), which are similar to some of our memory-access
patterns, their approaches are limited to only a few patterns. In
comparison,oursetofpatternsareshowntobecomplete[ 50].Sec-
ondly, our work fixes concurrency bugs based on inferred locking
policywhichallowsustosystematicallyfixbugsthroughoutthe
program as well as fixing bugs which involve multiple variables
(which are not considered by existing tools). Thirdly, PFix is more
comprehensive. For instance, AFix and AlphaFixer focus on fixing
atomicityviolations, whereasGrailcannot fixmulti-variablebugs.
PFix is able to fix order violations, atomic violations, data races,
which involve multiple variables.
Memory-accessPatternsAnalysis. Theideaofanalyzingmemory-
access patterns to understand/detect bugs has been explored in
multiplesettings.In[ 37],Luetal.presentedatoolnamedAVIOand
anempiricalstudyonrootcauseof74real-worldconcurrencybugs.
AVIOfocusesondetectingbugscausedbysingle-variableatomicity
violations,i.e.,oneparticularmemory-accesspattern.Falcon[ 43]
takes multiple test executions as input and computes statistical
measurement for memory-access patterns related to atomicity and
orderviolations.Itthenranksthepatternsaccordingtothemeasure,
i.e., the suspiciousness score. Griffin [ 40] groups multiple patterns
whicharefoundtoberelatedtoabug.Italsoprovidesbuggraphsto
help understand the root cause of the bug. Xu et al. [ 54] presented
an algorithm to identify erroneous event patterns from a failed
execution. It first finds the erroneous switch points and then deter-
mines the patterns related to this erroneous switch point, which
canhelpuserslocalizethebugs.Unicorn[ 42]isthefirsttounifythe
useofpatterndetectionandsequencingtolocatenon-deadlockcon-
currency bugs. It dynamically collects memory access information
andisextendedtodetectbothsingle-variableandmulti-variableconcurrencybugsbasedonFalcon’ssingle-variableconcurrencybugs detection. Our approach takes fault related information inthe form of memory access patterns as input and generates fixes
accordingly.
Fault Detection and Localization. Our work is related to the line
of work on fault detection and localization. Extensive researchhas been conducted on localizing bugs with different strategies.
Among them, quite a number are designed for sequential pro-
grams[17,18,27,30,31,39,44,47,51,52].Thesemethodscollect
and analyze runtime information of statements or predicates. They
reportthesuspiciousstatementsorpredicatesasfinalresults.Therehave been a number of proposals on fault localization for multi-
threaded bugs in recent years [ 7,23,36,38]. CSight [ 7] generates a
communicating finite state machine (CFSM) model by mining pro-
gram execution logs. Lazy-CSeq [ 23] works with context-bounded
model checking and supports deadlock detection for concurrent
Cprograms.Recon[ 38]providesinformationrelatedtobugroot
causes by showing the scheduling of a test execution. Recon ac-
quires short fragments of inter-thread communications near the
bugrootcauses,andthenappliesmachinelearningtechniquesto
identifythebug-relatedfragments.RaceMob[ 28]combinesstatic
and dynamic bug detection. During the static phase, it uses a static
dataracedetectortofindpotentialdataraces.ThenRaceMobdy-
namically validatesthe suspiciousdata racesand updatesa listof
data races to developers. Similarly, IteRace [ 46] is also presented
for race detection. However, IteRace conducts static race detection
in Java parallel loops. There are several approaches [ 14,23,41,56]
try to expose concurrent bugs by inserting random disturbances
when concurrent programs are accessing shared memory and syn-
chronizing, or controling the thread scheduling. These methods
aimtoincreasetheprobabilityoftriggeringtherareinterleaving
executionswiththeassumptionthatbugsmaybehiddeninthoseex-
ecutions. However, inserting random delay disturbance may cause
high performance overhead. Several techniques, such as model
checking [ 16,19] useJava Pathfinder to findconcurrency bugs. In
this work, we apply Java Pathfinder to precisely control thread
scheduling. It leverages controlled executions to check whether
certain patterns are relevant.
6 CONCLUSION
In this work, we propose an approach to automatically fix concur-
rency bugs. Our key idea is to systematically fix concurrency bugs
by inferring locking policies from failure inducing memory-access
patterns.Wefixtheprogrambyimplementingthelockingpolicy
systematicallyandconsistentlysothatthefailureinducingmemory-
access patterns are made impossible. We have implemented our
approach in a toolkit called PFix which targets Java programs. We
applied PFix to a set of 23 concurrency bugs (which range from
dozens of LOC to thousands of LOC) and are able to automatically
fix19ofthem.Forfuturework,withtheencouragingresultsinthis
work,weaimtore-implementPFixsothatitcanbeappliedfora
variety of real-world programs.
ACKNOWLEDGMENTS
This work is partially funded by projects 61202030, 71502125 from
NationalNaturalScienceFoundationofChina,projectT2MOE1704
from Ministry of Education, Singapore and Special Program of
Artificial Intelligence of Tianjin Municipal Science and Technology
Commission (No.:56917ZXRGGX00150), andCERNET innovation
project (NO.: NGII20170616).
REFERENCES
[1]2011. The Pecan Benchmarks. http://www.cse.ust.hk/prism/pecan/#Experiment
[2]2016.JaConTeBeObjectBiography. http://sir.unl.edu/portal/bios/JaConTeBe.php
[3]2018. Abstract Syntax Tree. http://www.eclipse.org/articles/article.php?file=
Article-JavaCodeManipulation_AST/index.html
[4] 2018. The Fix page. https://github.com/PFixConcurrency/Fix
[5]2018. TheFixExamplespage. https://github.com/PFixConcurrency/FixExamples
[6] 2018. The Soot GitHub Project. https://github.com/Sable/soot
598
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. PFix: Fixing Concurrency Bugs Based on Memory Access Patterns ASE ’18, September 3–7, 2018, Montpellier, France
[7]Ivan Beschastnikh, Yuriy Brun, Michael D. Ernst, and Arvind Krishnamurthy.
2014. Inferring Models of Concurrent Systems from Logs of Their Behavior with
CSight.In Proceedingsofthe36thInternationalConferenceonSoftwareEngineering.
ACM, 468–479.
[8]Jeremy S Bradbury and Kevin Jalbert. 2010. Automatic repair of concurrency
bugs. InInternational symposium on search based software engineeringâĂŤfast
abstracts. 1–2.
[9]Yan Cai and Lingwei Cao. 2016. Fixing deadlocks via lock pre-acquisitions. In
Proceedings of the 38th International Conference on Software Engineering, ICSE
2016, Austin, TX, USA, May 14-22, 2016. 1109–1120.
[10]YanCai,LingweiCao,andJingZhao.2017. Adaptivelygeneratinghighquality
fixesforatomicityviolations.In Proceedingsofthe201711thJointMeetingonFoun-
dationsof SoftwareEngineering,ESEC/FSE 2017,Paderborn,Germany,September
4-8, 2017. 303–314.
[11]Y. Cai, L. Cao, and J Zhao. 2017. Adaptively generating high quality fixes for
atomicity violations. In Proceedings of the 2017 11th Joint Meeting on Foundations
of Software Engineering (2017), 303–314.
[12]YanCaiandW.KChan.2012. MagicFuzzer:scalabledeadlockdetectionforlarge-
scale applications. In International Conference on Software Engineering. 606–616.
[13]Yan Cai, Jian Zhang, Lingwei Cao, and Jian Liu. 2016. A deployable sampling
strategy for data race detection. In Proceedings of the 24th ACM SIGSOFT Interna-
tionalSymposiumonFoundationsofSoftwareEngineering,FSE2016,Seattle,WA,
USA, November 13-18, 2016. 810–821. https://doi.org/10.1145/2950290.2950310
[14]LeeChewandDavidLie.2010. Kivati:fastdetectionandpreventionofatomic-
ityviolations.In EuropeanConferenceonComputerSystems,Proceedingsofthe
European Conference on Computer Systems, EUROSYS 2010, Paris, France, April.
307–320.
[15]Hyunsook Do, SebastianElbaum, and Gregg Rothermel. 2005. Supporting Con-
trolledExperimentationwithTestingTechniques:AnInfrastructureanditsPo-
tential Impact. Empirical Software Engineering 10, 4 (2005), 405–435.
[16]Patrice Godefroid. 1997. Model checking for programming languages using
VeriSoft.In ACMSigplan-SigactSymposiumonPrinciplesofProgrammingLan-
guages. 174–186.
[17]DanHao,TaoXie,LuZhang,XiaoyinWang,JiasuSun,andHongMei.2010. TestInput Reduction for Result Inspection to Facilitate Fault Localization. Automated
Software Engineering Journal 17, 1 (March 2010), 5–31.
[18] Dan Hao, Lu Zhang, Tao Xie, Hong Mei, and Jia-Su Sun. 2009. Interactive Fault
LocalizationUsingTestInformation. JournalofComputerScienceandTechnology
24, 5 (2009), 962–974.
[19]Klaus Havelund and Thomas Pressburger. 2000. Model checking JAVA programs
using JAVA PathFinder. International Journal on Software Tools for Technology
Transfer2, 4 (2000), 366–381.
[20]Jeff Huang and Zhang C. 2011. Persuasive prediction of concurrency access
anomalies[C]. International Symposium on Software Testing and Analysis (2011),
144–154.
[21]JeffHuang,PatrickO’NeilMeredith,andGrigoreRosu.2014. MaximalSoundPre-
dictive Race Detection with Control Flow Abstraction. In Proceedings of the 35th
ACMSIGPLANConferenceonProgrammingLanguageDesignandImplementation.
337–348.
[22]Jeff Huang and Charles Zhang. 2012. Execution privatization for scheduler-
obliviousconcurrent programs.In ACM InternationalConferenceonObject Ori-
ented Programming Systems Languages and Applications. 737–752.
[23]OmarInverso,TrucLNguyen,BerndFischer,SalvatoreLaTorre,andGennaro
Parlato.2015. Lazy-CSeq:AContext-BoundedModelCheckingToolforMulti-
threaded C-Programs. Automated Software Engineering (2015), 807–812.
[24]Antsaklis P J Iordache M V. 2006. Supervision Based on Place Invariants: A
Survey.Discrete Event Dynamic Systems (2006), 451–492.
[25]Guoliang Jin, Linhai Song, Wei Zhang, Shan Lu, and Ben Liblit. 2011. Automated
atomicity-violation fixing. Acm Sigplan Notices 46 (2011), 389–400.
[26]Guoliang Jin, Wei Zhang, Dongdong Deng, Ben Liblit, and Shan Lu. 2012. Auto-
matedconcurrency-bugfixing.In UsenixConferenceonOperatingSystemsDesign
and Implementation. 221–236.
[27]JamesA.JonesandMaryJeanHarrold.2005. Empiricalevaluationofthetarantula
automaticfault-localizationtechnique.In Ieee/acmInternationalConferenceon
Automated Software Engineering. 273–282.
[28]BarisKasikci,CristianZamfir,andGeorgeCandea.2013.RaceMob:Crowdsourced
data race detection. In Twenty-Fourth ACM Symposium on Operating Systems
Principles. 406–422.
[29]Sepideh Khoshnood, Markus Kusano, and Chao Wang. 2015. ConcBugAssist:
Constraint solving for diagnosis and repair of concurrency bugs. In Proceedings
of the 2015 International Symposium on Software Testing and Analysis. ACM,
165–176.
[30]XiangyuLi,MarceloDâĂŹAmorim,andAlessandroOrso.2016. IterativeUser-
Driven Fault Localization. In Hardware and Software: Verification and Testing:
12thInternationalHaifaVerificationConference,HVC2016,Haifa,Israel,November
14-17, 2016, Proceedings.
[31]Ben Liblit, MayurNaik, Alice X Zheng, Alex Aiken,and Michael I Jordan. 2005.
Scalable statistical bug isolation. In ACM Sigplan Conference on ProgrammingLanguage Design and Implementation. 15–26.
[32]Haopeng Liu, Yuxi Chen, and Shan Lu. 2016. Understanding and Generating
High Quality Patches for Concurrency Bugs. In The International Symposium on
the Foundations of Software Engineering.
[33]P. Liu, J. Dolby, and C. Zhang. 2013. Finding incorrect compositions of atomicity.
InProceedingsofthe20139thJointMeetingonFoundationsofSoftwareEngineering
(2013), 158–168.
[34]Peng Liu, Omer Tripp, and Charles Zhang. 2014. Grail: context-aware fixing
of concurrency bugs. In Proceedings of the 22nd ACM SIGSOFT International
Symposium on Foundations of Software Engineering. ACM, 318–329.
[35]PengLiuandCharlesZhang.2012. Axis:Automaticallyfixingatomicityviola-
tions through solving control constraints. In Proceedings of the 34th international
conference on software engineering. IEEE Press, 299–309.
[36]Shuang Liu, Guangdong Bai, Jun Sun, and Jin Song Dong. 2016. Towards Using
Concurrent Java API Correctly. In Engineering of Complex Computer Systems
(ICECCS), 2016 21st International Conference on. IEEE, 219–222.
[37]S.Lu,SoyeonPark,andYuanyuanZhou.2011. DetectingConcurrencyBugsfrom
the Perspectives of Synchronization Intentions. IEEE Transactions on Parallel &
Distributed Systems 23 (2011), 1060–1072.
[38]BrandonLucia,BenjaminP.Wood,andLuisCeze.2011. Isolatingandunderstand-
ingconcurrencyerrorsusingreconstructedexecutionfragments. AcmSigplan
Notices46 (2011), 378–388.
[39]Frolin S. Ocariza Jr., Karthik Pattabiraman, and Ali Mesbah. 2012. AutoFLox: An
AutomaticFaultLocalizerforClient-SideJavaScript.In Proceedingsofthe2012
IEEEFifthInternationalConferenceonSoftwareTesting,VerificationandValidation.
IEEE Computer Society, Washington, DC, USA, 31–40.
[40]SangminPark,MaryJeanHarrold,andRichardVuduc.2013. Griffin:grouping
suspiciousmemory-accesspatternstoimproveunderstandingofconcurrency
bugs.InACMSIGSOFTInternationalSymposiumonSoftwareTestingandAnalysis.
134–144.
[41]Soyeon Park, Shan Lu, and Yuanyuan Zhou. 2009. CTrigger: exposing atomicity
violation bugs from their hiding places. Acm Sigplan Notices 44 (2009), 25–36.
[42]Sangmin Park, Richard Vuduc, and Mary Jean Harrold. 2012. A unified approach
forlocalizingnon-deadlockconcurrencybugs.In 2012IEEEFifthInternational
Conference on Software Testing, Verification and Validation. IEEE, 51–60.
[43]SangminPark,RichardWVuduc,andMaryJeanHarrold.2010. Falcon:faultlocal-izationinconcurrentprograms.In Proceedingsofthe32ndACM/IEEEInternational
Conference on Software Engineering-Volume 1. ACM, 245–254.
[44]Spencer Pearson, José Campos, René Just, Gordon Fraser, Rui Abreu, Michael D.
Ernst, Deric Pang, and Benjamin Keller. 2017. Evaluating and improving fault
localization.In ProceedingsoftheInternationalConferenceonSoftwareEngineering
(ICSE).
[45]TimPeierls,BrianGoetz,JoshuaBloch,JosephBowbeer,DougLea,andDavid
Holmes. 2005. Java Concurrency in Practice. Addison-Wesley Professional.
[46]Cosmin Radoi and Danny Dig. 2015. Effective Techniques for Static Race De-
tection in Java Parallel Loops. ACM Transactions on Software Engineering and
Methodology (TOSEM) 24, 4 (September 2015), 24:1–24:30.
[47]AbreuRui,PeterZoeteweij,andArjanJ.C.VanGemund.2007.OntheAccuracyofSpectrum-basedFaultLocalization.In Testing:AcademicandIndustrialConference
Practice and Research Techniques - Mutation, 2007. Taicpart-Mutation. 89–98.
[48]K.Sen.2008. Racedirectedrandomtestingofconcurrentprograms. ACMSigplan
Notices43, 6 (2008), 11–21.
[49]MurataT.1989. Petrinets:Properties,analysisandapplications. ProcIEEE (1989),
541–580.
[50]Mandana Vaziri, Frank Tip, and Julian Dolby. 2006. Associating Synchronization
Constraints with Data in an Object-oriented Language. In Conference Record
of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages. 334–345.
[51]QianqianWang,ChrisParnin,andAlessandroOrso.2015. EvaluatingtheUse-
fulness of IR-based Fault Localization Techniques. In Proceedings of the 2015
International Symposium on Software Testing and Analysis. ACM, New York, NY,
USA, 1–11.
[52]Shaowei Wang, David Lo, Lingxiao Jiang, Lucia, and Hoong Chuin Lau. 2011.
Search-based FaultLocalization. In Proceedings ofthe 201126th IEEE/ACMInter-
national Conference on Automated Software Engineering. IEEE Computer Society,
556–559.
[53]Y. Wang, S. Lafortune, T. Kelly, M. Kudlur, and S Mahlke. 2009. The theory of
deadlockavoidanceviadiscretecontrol. InACMSIGPLANNotices 44,1(2009),
252–263.
[54]Jing Xu, Yu Lei, Richard Carver, and David Kung. 2013. Dynamic Approach to
Isolating Erroneous Event Patterns in Concurrent Program Executions. Springer
Berlin Heidelberg, 97–109.
[55]Zuoning Yin, Ding Yuan, Yuanyuan Zhou, Shankar Pasupathy, and Lakshmi
Bairavasundaram. 2011. How Do Fixes Become Bugs?. In Proceedings of the 19th
ACMSIGSOFTSymposiumandthe13thEuropeanConferenceonFoundationsof
Software Engineering. 26–36.
[56]JieYu,SatishNarayanasamy,CristianoPereira,andGillesPokam.2012. Maple:
A coverage-driven testing tool for multithreaded programs. Acm Sigplan Notices
599
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France H. Lin, Z. Wang, S. Liu, J. Sun, D. Zhang, G. Wei
47 (2012), 485–502.
[57]Wei Zhang, Junghee Lim, Ramya Olichandran, Joel Scherpelz, Guoliang Jin,
Shan Lu, and Thomas Reps. 2011. ConSeq: detecting concurrency bugs throughsequentialerrors. ArchitecturalSupportforProgrammingLanguagesandOperating
Systems46, 3 (2011), 251–264.
600
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:47:06 UTC from IEEE Xplore.  Restrictions apply. 