Semantic Crash Bucketing
Rijnard van Tonder
School of Computer Science
Carnegie Mellon University
USA
rvt@cs.cmu.eduJohn Kotheimer
Heinz College
Carnegie Mellon University
USA
john.kotheimer@alumni.cmu.eduClaire Le Goues
School of Computer Science
Carnegie Mellon University
USA
clegoues@cs.cmu.edu
ABSTRACT
Precise crash triage is important for automated dynamic testing
tools, like fuzzers. At scale, fuzzers produce millions of crashing
inputs. Fuzzers use heuristics, like stack hashes, to cut down on
duplicatebugreports.Theseheuristicsarefast,butoftenimprecise:
even after deduplication, hundreds of uniquely reported crashes
canstillcorrespondtothesamebug.Remainingcrashesmustbe
inspected manually, incurring considerable effort. In this paper we
present Semantic Crash Bucketing, a generic method for precisecrash bucketing using program transformation. Semantic CrashBucketing maps crashing inputs to unique bugs as a function of
changinga program(i.e., asemantic delta).Weobserve thata real
bug fix precisely identifies crashes belonging to the same bug. Our
insightisto approximate realbugfixeswithlightweightprogram
transformation to obtain the same level of precision. Our approach
uses (a) patch templates and (b) semantic feedback from the pro-gram to automatically generate and apply approximate fixes for
generalbugclasses.Ourevaluationshowsthatapproximatefixes
arecompetitivewithusingtruefixesforcrashbucketing,andsig-
nificantlyoutperformsbuilt-indeduplicationtechniquesforthree
state of the art fuzzers.
CCS CONCEPTS
•Software and its engineering →Error handling and recov-
ery;Maintaining software ;Software defect analysis ;•Secu-
rity and privacy →Software security engineering ;
KEYWORDS
Crash Bucketing, Fuzzing, Bug Triage, Program Transformation,
Automated Bug Fixing
ACM Reference Format:
RijnardvanTonder,JohnKotheimer,andClaireLeGoues.2018.Semantic
Crash Bucketing. In Proceedings of the 2018 33rd ACM/IEEE International
Conference on Automated Software Engineering (ASE ’18), September 3–7,
2018,Montpellier,France. ACM,NewYork,NY,USA, 11pages.https://doi.
org/10.1145/3238147.3238200
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation
onthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the
author(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or
republish,topostonserversortoredistributetolists,requirespriorspecificpermission
and/or a fee. Request permissions from permissions@acm.org.
ASE ’18, September 3–7, 2018, Montpellier, France
© 2018 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-5937-5/18/09...$15.00
https://doi.org/10.1145/3238147.32382001 INTRODUCTION
The advent of large scale fuzzing services, such as Google’s OSS-
Fuzz [1,45] and Microsoft’s fuzzing service [ 9], attest to the effec-
tivenessofautomaticbugfindingtools.Whenoperatingatscale,
accurately identifying unique bugs is critical for (a) reducing time-
consuming manual debugging efforts [ 14,41], (b) characterizing
theeffectivenessofautomatedbug-findingtools[ 12,14,37,42,48],
and(c)rankinginteresting crashingtestcases[ 14].However,one
outstanding challenge in effectively deploying automated fuzzing
techniquesisaccuratelyidentifyinguniquebugsduringcrashtriage.
Fuzzersoftengeneratethousandsofcrashinginputsthatultimatelycorrespondtothesamebug[
14],andthesheernumberofcrashing
inputs preclude manual inspection. This is a hard problem, and an
area of active research [17].
Automatedcrashtriagetechniquesseektoapproximately bucket
multiplecrashing(butultimatelyequivalent)inputs[ 14,17,37,41],
toreducethenumberofredundantbugreportsanengineermust
inspectbyhand.Atahighlevel,automatedtestingtoolslikefuzzers
andsymbolicexecutorstypicallyusetool-specific,heuristicbuck-
etingstrategies.Bothresearchandindustrystandardtriagetech-
niques have known limitations [ 17,42]. Techniques may assume
“best-effort” hardcoded values (e.g., the number of calls to con-
sider in a call stack [ 2]) or require tool-specific instrumentation for
feedback-drivenapproaches[ 3].Thevariedsensitivityofsuchad
hoctechniquesresultinimprecisebugidentificationthatcanfail
in two ways. Overapproximation occurs when multiple crashing
tests caused by a single bug incorrectly bucket to more than one
uniquebug(i.e.,duplicatebugreports). Underapproximation occurs
whencrashingtestsduetomultipleuniquebugsareputinthesame
bucket [41, 48] (i.e., missed unique bugs).
Stack hash [ 37,48] and branch sequence [ 7] techniques used in
state-of-the-practicefuzzers[ 2,3,7]cansufferfrombothover-and
underapproximation[ 41,48].Suchtechniquesseektodetermine
bug uniqueness as a function of, e.g., crashing input [ 48], program
traces[7,17],programcrashstate[ 3],oracombinationofthese[ 14].
Recent(andmoresophisticated)researchadvancesproposetomorepreciselyclassifyuniquebugsusingsymbolicanalysis[
41],machine
learningoncrashinginputs[ 14],andbackwardtaintanalysison
programtraces[ 17].Whilesuchapproachespromisemoreaccurate
bucketing by considering semantic program behavior (e.g., [ 17,
41]), their accuracy depends on sensitivity to a general semantic
trait (e.g., symbolic branch uniqueness) and can still misbucket
bugs.Built-inorhardcodedtechniquesfurtherstruggletointegrate
specialist knowledge that can produce more accurate output for
classes of bugs.1
1https://twitter.com/azonenberg/status/966738179486134272
612
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Rijnard van Tonder, John Kotheimer, and Claire Le Goues
We present a radically new approach to identifying unique bugs
in the context of fuzzing: by modifying the program itself. Our
insight is that bugs can be characterized by a semantic transfor-mation on the program under test. For example, patching one of
two buffer overflows in a single execution can distinguish crashes
unique onlyto thesecond. Further,a fixcan stopthe samelogical
bug from manifesting on multiple unique execution paths.
Our insight draws on the fact that fixing the program offers a
precisewaytoassociatecrashinginputswithauniquebug,since
correct fixes should neutralize all crash-inducing inputs associated
with the bug in question.
We introduce Semantic Crash Bucketing, which maps crashing
inputstobugsasafunctionofchange(delta)inprogramsemantics,
wherethedeltaapproximatesfixingtherootcauseofthebug.In
general, root cause analysis is hard [ 27,39], and automatically
fixing bugs is an open problem [ 30]. However, e xisting work in
automated program repair (APR) does demonstrate that programs
canprofitablybetransformedtoautomaticallyimprovequality[ 29,
34,36]. The motivation behind our approach is that changing a
program with approximate fixes can accurately and automatically
constrain crashing behavior in a way that mimics real program
fixes to detect unique bugs in fuzzer output.
Semantic Crash Bucketing contrasts with the usual sense of
seeking program fixes with respect to a correctness oracle (suchas tests [
29,34]). However, although the objective of Semantic
Crash Bucketing is different from APR, it can similarly suffer from
programtransformationsthatoverfittothesuccesscriterion.For
example,supposeaprogramcontainsmorethanoneuniquebug,
each with independent fixes. Inserting exit(0);at the beginning
of a program will satisfy the criterion of neutralizing all crashes,
butwillassociate(andunderapproximate)alluniquebugswitha
single fix. To be effective, program transformations must therefore
haveconstrainedsemanticeffectstopreciselyidentifyuniquebugs
under Semantic Crash Bucketing.
We propose a rule-based approach using fix templates to con-
strain the semantic transformations for crash bucketing. Our ob-
servationisthatcommonbugstypicallydetectedbyfuzzers(e.g.,
buffer and integer overflows, null dereferences, etc.) have semantic
properties that are amenable to a rule-based application of gen-
eralfixtemplates(asfoundinanalogAPRwork,e.g.,[ 16,26,46]).
At a high level, rule-based application of fix templates can inte-
grate specialist knowledge of bug semantics into the triage process
toproducemorepreciseoutput.WedemonstrateSemanticCrash
Bucketing for buffer overflows and null dereferences on real-world
bugs in the CVE database [ 4]. Buffer overflows and null derefer-
encevulnerabilitiesaccountforsomeofthemostcommonsoftware
security weaknesses [ 31] and are frequently discovered through
fuzzing [7, 42,45]. Our contributions are as follows:
•Semantic Crash Bucketing , a novel technique to auto-
matically identify unique bugs as a function of changinga program’s semantics. Semantic Crash Bucketing groups
crashinginputsbyapplyingprogramtransformationstothe
program under test. We use Semantic Crash Bucketing to
identifyimprecisecrashreportinginfuzzers,andtocomparetheeffectivenessofdeveloper-writtenfixesandapproximate
fixes.•Approximate fixes. We present an automated procedure
using bug-fixing patch templates and rule-based application
of patches to approximate correct fixes. In general, correctly
and automatically fixing a program is hard. The key insight
is that the effectiveness of approximate fixes is competitive
withusingcorrectfixesforidentifyinguniquebugs.Wein-
stantiateSemantic CrashBucketing withapproximate fixes
forreal-worldbugscommonlyfoundbyfuzzers:bufferover-
flows and null dereferences and demonstrate effectiveness.
•Empirical evaluation . We comparatively evaluate Seman-
tic Crash Bucketing using developer-written fixes and ap-
proximatefixeswithdeduplicationtechniquesofthreestate-
of-the-artfuzzers(AFL-Fuzz[ 7],CERTBFF[ 2],andHong-
gfuzz [3]). We show with Semantic Crash Bucketing that
approximate fixes associate crashing inputs precisely (i.e.,no under- or overapproximation) for 19 out of 21 bugs in6 projects compared to ground truth fixes. We also show
that bucketing with approximate fixes is more precise than
built-in deduplication of all three fuzzers. Our results are
available online.2
2 MOTIVATING EXAMPLE
AFL-Fuzzisknowntofindnulldereferenceandmemorycorruption
bugsinevenwell-testedsoftware[ 5].Consideronesuchbugfound
inSQLite:anulldereferencethatwaslaterfixedbythepatchinList-
ing1a.The sqlite3WalkSelect function(Line7)walkstheexpression
treeofaSQLselectstatement.Thereturnvalueof sqlite3WalkSelect
canindicatean errorina SELECT ... FROM ... statement,butthe re-
turn value is not checked. This missing check can lead to a nulldereference downstream during execution due to an invalid
FROM
clause. The fixing commit message says:

Make sure errors from the FROM clause of a SELECT cause
analysis to abort and unwind the stack before those errors
have a chance to mischief in the "*"column-name wildcard
expander. 
Thedeveloperthuschecksthereturnvalueof sqlite3WalkSelect
and aborts, avoiding any null dereferences downstream (Line 8,
Figure1a).
Current fuzzers and symbolic executors can find many different
crashing inputs that trigger bugs like these. For example, slight
modificationsinacrash-inducing SELECT...FROM... inputcouldfol-
low a different sequence of calls or branches, but still trigger thesame bug. Existing techniques use generic heuristics to identifyunique crashes from a set of many generated inputs. Call stackhashes [
2,3,12,20,37] are predominant; instrumentation-based
fuzzers may use program execution paths sensitive to branch se-
quences [ 3]. These heuristics are fast and moderately effective, but
remain imprecise, because they are sensitive to inputs that vary
program execution in a way that is unrelated to the actual bug. De-
pending on the heuristic and inputs, fuzzers report many duplicate
crashes as unique.
Ourapproachdefinesbuguniquenessintermsof programtrans-
formation. The motivation is that fixing a bug (as the developer didinFigure 1a)ideally“catches”allcrashinginputsrelatedtothebug,
2https://github.com/squaresLab/SemanticCrashBucketing
613
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Semantic Crash Bucketing ASE ’18, September 3–7, 2018, Montpellier, France
1--- a/src/select.c
2+++ b/src/select.c
3@@ -4153,7 +4153,7 @@ static int selectExpander(Walker
*pWalker, Select *p){
4 /* A sub-query in the FROM clause of a SELECT */
5 assert( pSel!=0 );
6 assert( pFrom->pTab==0 );
7- sqlite3WalkSelect( pWalker, pSel);
8+ if( sqlite3WalkSelect( pWalker, pSel) ) return
WRC_Abort;
9 pFrom->pTab = pTab = sqlite3DbMallocZero(db,
sizeof(Table));
10 if( pTab==0 ) return WRC_Abort;
(a)SQLite: a developer fix that avoids a null dereference.1--- a/src/resolve.c
2+++ b/src/resolve.c
3@@ -164,6 +164,9 @@ int sqlite3MatchSpanName(const char *
zSpan, const char *zCol, const char *zTab, const char
*zDb){
4int n;
5
6+ if(zSpan == NULL) {
7+ exit(101);
8+}
9for(n=0; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){}
10 if( zDb && (sqlite3StrNICmp(zSpan, zDb, n)!=0 || zDb[n
]!=0) ){
11 return 0;
(b)SQLite:autogeneratedapproximatefixforthenulldereference.
Figure 1: Two fixes for a null dereference in SQLite3.8.9. The actual fix is shown on the left (commit 10c478e). Our approach
automatically generates the patch on the right.
irrespective of call stacks or other program execution paths.3The
challengeisthatfindingtruefixesishard.Automatedrootcause
analysis is difficult and expensive [ 27,33], especially for bugs like
this one, that requires deep reasoning.
Our primary insightis thatsimpler approximate fixes cansubsti-
tute for real fixes to precisely bucket crashing inputs. For example,
Figure1bpresents an autogenerated approximate fix for the same
SQLitenulldereferencebug.Semantically,itsafelyabortsthepro-
gram if zSpanarenull. It turns out that the SQLitebug leads directly
tozSpanbeingnullat this later program point (i.e., when the input
statement contains a *expander described in the commit message).
The approximate patch precisely “catches” similar crashing inputs
like the actual patch.
Ourapproachusessyntactictemplatesandconfigurable“seman-
tic cues” to generate such patches. Semantic cues act as predicates
forapplyingpatchtemplates.Aconcreteexampleis“Checkwhether
any dereferenced variables atprogram point pisnull. If so, return
the variable name”. A patch template can then be instantiated with
the specific variable. In general, templates and rules for patch gen-
erationandapplicationarespecifiedjustonceperbugclass(e.g.,
null dereferences and overflows.). We describe the procedure fully
in Section 4, but provide a brief summary here for null derefer-
ences.Thepatchtemplatefornulldereferencescheckswhethera
variableis null,andsafelyabortstheprogramifso.Thistemplate
containsa“hole”forthevariabletocheck,andmustbeinstantiated
withaconcretevariable.Weconfiguretheproceduretocheckfor
a semantic cue: whether variables are null at the point of crash
using a debugger environment. In this case, our procedure finds
thatzSpan[n]could bea problematic dereference, and dynamically
checks whether zSpanis null when the program crashes. Variable
zSpanisfoundtoindeedbe null,generatingthepatchin Figure 1b.
The patch is validated to confirm that the modified program no
longercrashesfortheinput.Thatis,theautogeneratedpatchap-
proximatestherealfixeffectivelybecauseitdiscoversandfixesthe
related null dereference triggered downstream during execution
even though it does not deeply address the root cause.
3And, under correctness assumption of the fix, any other crashing input is associated
with a different unique bug.In essence, applying lightweight program transformation re-
duces noise compared to typical deduplication heuristics by focus-
ing on the semantic properties of the bug. At the expense of slight
upfrontcostperbugclass,ourapproachprovidesaconfigurable
mechanism that is sensitive to the semantic property of the bug to
more precisely identify uniqueness.
A configurable approach is important: bugs exhibit different
semantictraits towhichprogramtransformation mustbesensitive.
For example, null dereferences cause an immediate program crash
which allows us to identify possible causes at the point of crash.
On the other hand, buffer overflows typically only cause a crash
oncecorruptedmemoryisaccessed,andnotwhentheoverwrite
actuallyoccurs.Handlingoverflowsthereforerequiresadifferent
strategy (see Section 4).
Fuzzers can also underreport unique bugs. For example, under a
naïve call stack approach, two unique null dereferences in a single
function will be reported as just one unique bug. Our technique
can identify each bug uniquely via independent program transfor-
mations.
3 SEMANTIC CRASH BUCKETING
This section introduces Semantic Crash Bucketing (SCB). Semantic
CrashBucketingisageneralmethodforbucketingcrashes interms
ofprogramtransformation (i.e.,asemanticdelta).SemanticCrash
Bucketing can be performed with arbitrary program transforma-
tions. Our goal in this sectionis to develop a way for determining
howwellapproximatefixesidentifyuniquebugscomparedto(a)
ground truth fixes and (b) existing methods in fuzzers. We now in-
troducetheproblemdefinitionandapplicationofSCBfordetecting
inaccurate error reports.
3.1 Problem Formulation
Abuginourcontextisasoftwareflawthatleadstoanerror(i.e.,
undesirable program behavior); an error is a deviation from ex-
pectedbehaviordefinedbyatestoracle.Weaddressonthetypesof
bugs typically found by fuzzers, namely those that induce runtime
crashes. For such bugs, the error oracle is signaled by a runtime
failure: a crash results in SEGFAULT.
614
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Rijnard van Tonder, John Kotheimer, and Claire Le Goues
Semantic Crash Bucketing groups crashing inputs according to
a programchange that nullifiesthose inputs (i.e., causethe inputs
tono longercrashthe program).Thus,a truefixfor auniquebug
maps all crashing inputs for that bug to a unique bucket. Group-
ing crashes as a function of known fixing patches is a de facto
method for establishing ground truth classification of fuzzer crash
reports [14]. We use this idea to develop a general method of iden-
tifying misbucketing (e.g., duplicate crash reports) arising from
approximate fixes and fuzzers.
IdealBucketing. WebeginbydefininganIdealBucketing,where
the correct fixing patches for unique bugs in a program are known
orpresumed.Thisdefinitionrepresentsgroundtruthtomeasurethe
effectiveness of ourapproach (Section 5). The intuitionis straight-
forward:someknownorpresumedprogramtransformation Tifixes
all crashing input associated with a bug i, and only those inputs.
Tiisbyconstructionthetheoreticallyidealoracletransformation
that correctly fixes the bug iand thus all of the crashing behavior
it can cause. In practice, we may think of such a transformation as
a correct developer-written patch for a single bug.
WeexpressIdealBucketingintermsofuniquebugs,thecrashes
they induce, and their fixes. Let i∈nbe the identifier for a unique
bugiofnuniquebugsinaprogram P.Auniquebug iisassociated
with a set of one or more crashing inputs, which we denote by
a bucket bi. Let Ti:P→Pbe a function that applies a correct
fix to the program P, for unique bug i. A correct fix Tifixes all
crash-inducing inputs bidue to i, but none of the crashes due to a
different bug jwith crashing inputs bj.
Weexpressallbucketscontainingcrashinginputsuniquelyfixed
byknown Ti,i∈nasdisjointpartitions B=b1/unionmulti···/unionmulti bnunderthe
correctness assumption of Ti. For a particular Ti, ideal bucketing
implies:
∀bi∈B,
∀bj∈B\bis.t.
∀ci∈bi,/angbracketleftTi(P),ci/angbracketright/negationslash/squigglerightcrash
∀cj∈bj,/angbracketleftTi(P),cj/angbracketright/squigglerightcrash
Where/angbracketleftTi(P),c/angbracketright/negationslash/squiggleright crashexpresses that the program Punder
transformation of fix Tiand executed on crashing input cdoes not
induce a runtime crash. Ideal bucketing for a bug iexpresses
that the fix Tiassociates non-crashing behavior with all previously
crashinginputs c∈bi,butnotanycrashesforotherbuckets bj∈
B\bi.4
One subtlety of Ideal Bucketing is the special case where a
single input may trigger multiple bugs. For example, two separate
buffer overflow copies (i.e., two bugs b1andb2) along the same
executionpathmayoverwritethestack(twice)inasingleexecu-
tion.Fromourdefinition,neithercorresponding fix T1norT2will
bucketthecrashinginput.However,wecanextendthedefinitionto
account for composition of transformations T1andT2to place such
a crashing input into a separate bucketthat represents a composite
fault. Although conceptually useful,we focus on logically discrete
fixes (based on developer patches) to associate crashing inputs
with bugs so that it is tenable to experimentally compare real and
approximate fixes. In practice, fuzzer-generated inputs typically
4Note: if B\bi=∅then the constraint on bjholds vacuously.trigger single bugs, and our results corroborate this observation.
Classifying composite faults is an open problem [ 22] and we leave
the consideration of usingprogram transformation for classifying
such faults to future work.
3.2 Detecting Duplicates
One goal in fuzz triaging is to approximate the ground truth ideal
bucketing strategy, minimizing overhead and confusion for the
engineer using a fuzzer to identify defects. Approximations are
done by, e.g., unique call stack hashes or unique branch sequences.
Such approximations can fail, however, leading to misbucketing
of crashing inputs. Misbucketing can be classified into two cate-
gories [41]:
(1) duplicate bug reporting and
(2)suppressed unique bugs: unreported unique bugs that are
missed by crash bucketing (or “over-condensing”).
Inthispaper,wedealwiththefirstcaseofduplicatebugreports.
Wenowdescribehowwedetectduplicatebugreportsintermsof
fixingtransformations Ti,whereIdealBucketingdoesnothold.
Considertwoexamplebugreportsproducedbyafuzzer:bug1with
a crash bucket b1={c1}containing crashing input c1, and bug 2
with b2={c2}.Wesaythat b2isaduplicatebugreport ifc2actually
crashes the program due to bug 1. That is, the correct bucketingimplies
b1={c1,c2}and no bug 2 should be reported. Duplicate
misbucketingwronglyimpliesbuguniqueness,increasingthetriage
burden of engineers processing fuzzer output.
Inanimprecise bucketing B,duplicationoccurswhenthefollow-
ing is true for a particular Ti:
∃bi∈B,
∃bj∈B\bis.t.
∀c∈bi,/angbracketleftTi(P),c/angbracketright/negationslash/squigglerightcrash
∃cdup∈bj,/angbracketleftTi(P),cdup/angbracketright/negationslash/squigglerightcrash
Thatis,somecrash cdup∈bjactuallyfixed byTiisconsidereda
crashforadifferentuniquebug j,belongingto bj.Byourcorrect-
ness assumption of Ti, any crash fixed by Timust belong to bifor
idealbucketingtohold.Notethatif cistheonlycrashin bjthen
a unique bucketis implied, resulting in aduplicate report of bug i
as some other bug jthat should not exist.
In summary,given correct Ti’s, wecan determine groundtruth
Ideal Bucketing and detect duplicate bug reports as deviations
from Ideal Bucketing.
3.3 Semantic Crash Bucketing Procedure
Our formulation leads to a straightforward procedure for identi-fying misbucketing in fuzzers. Figure 2illustrates the process. A
Fuzzertakes a program Pand input to generate a set of crashes
C=c1,..., cn1. The fuzzer reports a set of crashing input accord-
ingtoitsbuilt-inmethodforidentifyinguniquebugs.Werepresent
the fuzzer output as a disjoint set of unique bugs indexed by I:
Bfuzzer=/unionmultitext
i∈Ibi2.
Asamatterofpracticality,afuzzerdoesnot,bydefault,preserve
allgeneratedcrashinginputs.Instead,afuzzerdiscardsanycrashing
input it believes triggers a bug it has already seen, and typically
outputsonerepresentativecrashfor eachbug/bucketitconsiders
615
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Semantic Crash Bucketing ASE ’18, September 3–7, 2018, Montpellier, France
unique. This is expressed as Bfuzzer=(b1={c1})/unionmulti(b2={c2})/unionmulti
···/unionmulti (bn={cn}).
Figure 2: The Semantic Crash Bucketing Procedure.
Thefunction SCBtakesasinputthesetofcrashes Candaground
truth fix Tj3. For a single fix Tj,SCBpartitions the set of crashes
Cinto a disjoint set bj/unionmultibrestby running each crash c∈Con the
modified program Tj(P). The set bjcontains all inputs fixed by Tj,
asintheIdealBucketingcase,while brestcontainsallinputsthat
still cause Tj(P)to crash. The final step 4tests if the crashes in
a nonempty bucket bjdistinguished by Tjis contained in Bfuzzer.
Because Bfuzzercontainsapartitionofuniquebugswithjustone
representative crash in any bi, there are only two outcomes for
the test bj∈Bfuzzer: (1)|bj|=1 andis equalto some biinBfuzzer,
implyingthat Bfuzzerpreciselybucketsthecrashinginputforabug
j, or (2)|bj|>1 implying that the crashes in c∈bjare partitioned
acrossmultiplebucketsin Bfuzzer,implyingthatthefuzzerreported
duplicate bugs. For simplicity, Figure 2illustrates the procedure
forasinglefix Tjthatfixesatleastonecrashinginputin C.Ideal
Bucketingchecksthateverycrashinginputin Ccanbefixed(and
bucketed) uniquely by one or more fixes T.
4 GENERATING APPROXIMATE FIXES
This section explains how we instantiate our approach to perform
SCBusing approximatefixes.Inpractice,adeveloperfixprovidesthe
bestassuranceofcorrectlyfixingaknownbug,whichweaccept
as ground truth Tfor SCB. However, our goal is to reduce the
burden on developers to triage fuzzing output when the crash’s
fix is not immediately known. In general, fixing arbitrary bugs
automatically is hard [ 30]. Our core insight is that an approximate
fix/hatwideTis competitive with using Tto identify unique bugs under
SCB.Inourapproach, /hatwideTisanautomatic productionencodingthe
semanticpropertiesnecessarytofixpossiblecrash-inducingbugs.
To demonstrate, we instantiate SCB with approximate fixes on null
dereferences and buffer overflows in C programs.
4.1/hatwideTProduction.
Atahighlevel, /hatwideTisaproductionofafunction G(P,T)thattakes
two inputs: the source program Pand a crash trace T. A crash
trace is produced by executing Pon a single crashing input c.G
generatespatchesfromfixingtemplates,andappliesthemtothe
source.Patchapplicationispredicatedoncertaininformationintheprogramsource,dynamictrace,orboth.Werefertothesepredicates
assemanticcues thatare sensitiveto semanticpropertiesof abug
class.Ifthepredicatesarenotsatisfied,theprogramisnotmodified.
We concretely represent /hatwideTas a source-level patch. This has two
advantages. First, patches can be used as better bug reports [ 47],
supportinghumantriageanddebugging.Second,patchescanapply
withoutactuallyrunningtheprogram,meaningstaticanalyses(e.g.,
static symbolic execution) can also benefit from SCB.
Weuse GDBandltracetoobtaindynamiccrashtraces.Inprinciple,
anydynamictechniqueoranalysiscanenrichthespaceofsemanticcues to trigger program modification. We now describe in concrete
terms how we obtain /hatwideTfor null dereferences and buffer overflows.
4.2 Null Dereferences
Null dereferences are typically fixed in one of two ways: correctly
initializing a variable or checking whether a variable is null before
dereferencingit[ 46,49].Atasemanticlevel,afixmustenforcea
nonnull property for a variable that results in a null dereference
crash. We use the template in Figure 3to approximate fixing a null
dereference. %%%PVAR%%% is a “hole” substituted with the offending
program variable.
1if(%%%PVAR%%% == null) {
2exit(101);
3}
Figure 3: A template for null dereferences
The patch approximates error handling by exiting the program
on condition of PVARbeingnull(similar to the common C idiom
ofreturn-1;).Whilesimplyexitingappearssimplistic,itisinfact
appropriateforourobjectivetoaccuratelybucketcrashinginput.
Consider if we chose a different strategy by returning a value or
initializing %%%PVAR%%% . Besides the difficulty of correctly inferring
appropriate values, we risk the possibility that the modified pro-
gram may continue executing and cascade errors or crash in other
unexpected ways. Without complete information of the root cause
to actually fix the bug, exiting is a conservative strategy: it acts as
anassertionensuringthedesirednonnullsemanticproperty.The
correct fix in our motivating example supports this strategy: SQLite
conservatively aborts for error cases (but does some extra work
propagating theerror up the callstack). Since thetemplate can be
changed,ourmethoddoesnotprecludeotherpossibilities;however,
our experiments show that the template in Figure 3approximates
true fixes well enough for precise crash bucketing.
Templatedefinitionisonlypartofthelargerproblem:generating
thefinalpatch /hatwideTalsoreliesonidentifyingtheappropriateprogram
variable and location to insert the patch. Semantic cues from a
GDBtrace inform patch application: whether a variable dereference
at the point of crash is null. For example, our approximate patch
in Figure 1bchecks the variable zSpan. The general procedure for
finding such crash-inducing variables works as follows:
(1) Attach GDBto the program, run it on the crashing input.
(2) Extract the source line and code reported at the crash.(3) Parse the code for pointer dereference syntax (e.g.,
p->q).
(4)Workingbackwards,extractprogramvariablesthatarederef-
erenced (e.g., extract pfromp->q). Test, using GDB, whether
the variable is nullin the debugger environment.
616
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Rijnard van Tonder, John Kotheimer, and Claire Le Goues
(5)If the variable is null, return the variable and associated line
number. If not, move backwards a basic block and continue
from (3).
Iftheproceduresucceeds,wesubstitutethetemplateprogram
variableandinsertthecandidatepatchjustbeforethenullderef-
erence. The null check could possibly be placed earlier, and a true
fix may indirectly prohibit a particular variable from being null (cf.
thecorrect SQLitefixinFigure 1a).Ourdecisionisaninexpensive
compromise that we show works well in practice.
Before we use the patch for SCB, we first validate that the modi-
fiedprogramnolongercrashesforinput c.Thepatchgeneration
procedure can produce more than one candidate patch, but our
implementation takes the first crash-fixing patch for bucketing.
4.3 Buffer Overflows
Buffer overflows are a class of memory corruption bugs commonly
discoveredbyfuzzers[ 7,45].Bufferoverflowsaretypicallyfixed
by performing array bounds checking on memory accesses. Our
approximation to fixing buffer overflows thus focuses on arraylength as the underlying semantic property to change. Inferring
arrayboundscandirectlyassistsuggestingapproximatefixesfor
arbitrary overflow bugs, but generally requires additional anal-ysis techniques and remains an open problem [
19,21,24]. Our
approachistotruncatememorywritesthatmaycauseinvalidac-
cesses.Applicationsinfailure-obliviouscomputing[ 44]andexploit
mitigation [33] use a similar mechanism.
UnsafeClibraryfunctionscommonlytriggerbufferoverflows[ 19,
28,33,38]andpersistinmodernsoftware.5Ourapproachapplies
templates for common C library functions, such as memcpy,strcpy,
sprintf,gets,strcat, etc.
Wegiveanexampletemplatefor memcpyinFigure 4;thetemplates
forotheroverflowsareconceptuallysimilar.Werewriteexisting
callsandrestrictthelengthofdatacopiedtoadefaultconcretevalue
of 1. Restricting data to only one byte approximates a conservative
angelic value [13] that is likely to lead to non-crashing program
termination.Notethatotherpossibilitiesexist:wemay,forexample,
instrument the code to obtain actual angelic values observed atruntime and use these to construct fixes. Our experiments show
that our current choice works well for precise bucketing.
1// Modify a possible overflowing memcpy call
2size_t angelic_length = 1;
3memcpy(%%%DST%%%,%%%SRC%%%,angelic_length);
Figure 4: A template for memcpy.%%%DST%%% binds to the destination
argument for the original memcpycall, and %%%SRC%%% is binds to the
source argument.
Compared to approximating null fixes, overflow fixes do not
attempt to stop execution: placing a condition on the length of a
potentialbufferprovesproblematicifwedonotknowitsbounds.
Conversely,simplyexitingbeforecallinganunsafefunctionwill
overfittouniquecrashinginputsthatwouldcrashafterthefunction.
Inaddition,whilememorycorruptionoccurs duringexecutionof
theClibraryfunctions,theprogramonly crashesatalaterpoint :
once an invalid memory access occurs in the heap, or when a
5AstrcpyvulnerabilityhasbeenfoundintheLinuxdistributionasrecentas2017[ 8].corruptedreturnaddressisaccessedonthestack.6Thesebehaviors
motivate different semantic cues compared to null dereferences,and emphasize the importance of a configurable approach. For
bufferoverflows,weimplementaproceduretodiscoverpossibly
problematiclibrarycallsandresolvetheirlocation.Apatchtemplate
like Figure 4then replaces the call. The steps are as follows:
(1)Useltracetoobtainatraceoflibrarycallsfromthecrashing
program run.
(2)Workingbackwards,resolvethesourcelocationoflibrary
calls in the trace for which we have fixing templates.
(3)Apply the template at the location and rerun the program
on the original crashing input.
(4)Iftheprogramnolongercrashes,emittheapproximatefixing
patch /hatwideT. Else continue from step (2).
Similar to null dereferences, we validate that the program no
longer crashes for any change done in step 3, and use the first
crash-fixing patch for bucketing.
ExtendingSemanticCrashBucketing. Thepatchtemplatesand
rulesfor patchingareembeddedin Pythonscriptsand areeasyto
change.Users candefinetheirown patchtemplatesandsemantic
cues for patch application depending on the semantic properties
of the bug types or application-specific APIs. The GDBinterface and
ltraceoutput is available in the scripting framework for customiza-
tion. Additional analysis tools can be integrated (e.g., valgrind),
though naturally this requires some extra effort.
5 EXPERIMENTAL DESIGN
Ultimately, we want to know how well approximate fixes /hatwideTdis-
tinguish unique crashes compared to (a) ground truth bucketing
byT(developer fixes) and (b) built-in fuzzer deduplication (the
previousstateoftheart).Weconductacontrolledexperimentwith
real bugs for which we know the ground truth fix (Section 5.1).
Unfortunately, for the purposes of our experiments, state of the art
fuzzers do not all neatly decouple fuzzing campaigns from crashdeduplication (e.g., deduplication is invoked during fuzzing iter-ations). Instead, we first generate, for each bug, an upper boundof inputs that trigger the same bug (i.e., a “crash corpus”) which
aimtoexercisedifferentexecutionpathstriggeringthesamebug
(Section5.2). We then provide this crash corpus as input to each
fuzzer, and run a campaign for a fixed length (2 hours), forcing the
fuzzertoperformdeduplicationonthecrashcorpusduringfuzzing
iterations (Section 5.3). We use the developer fix and apply SCB
to obtain the ground truth number of duplicate bug reports after
the campaign (which includes each fuzzer’s deduplication efforton the corpus). We then apply SCB with approximate fixes and
measure(a)thedifferencefromgroundtruth,and(b)deduplication
improvement over existing fuzzers.
Hardware. WeranourexperimentsonanUbuntu16.04LTSserver
with2XeonE5-2699CPUsand20GBofRAM.CrashCorpusgener-
ation and fuzzing campaigns all ran on a single CPU core. We used
fourcorestorecompilewhenvalidatingwhetheranapproximate
fix stops a crash.
6Memory fence-posts can detect overwrites immediately, and don’t require a program
toSEGFAULT .Thisrequirescodeinstrumentationandextrashadowmemorythathurts
fuzzing performance. Approximate fixes can be adapted accordingly, but we currently
do not assume such instrumentation.
617
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Semantic Crash Bucketing ASE ’18, September 3–7, 2018, Montpellier, France
5.1 Bugs with Ground Truth
Weevaluateonasampleof18nulldereferenceand3bufferoverflow
bugsin6real-worldprojects.Foreachbugwe(a)extractedaground
truthdeveloperfixfromtheprojectand(b)sourcedacrashinginput
that triggers the bug (e.g., from online bug reports).
Projects with multiple bugs. SQLiteiswell-tested,populardata-
basesoftware; w3misatext-basedwebbrowser.Fortheseprojects,
we curated datasets of multiple bugs in a single revision. To be use-
ful,adeduplicationstrategyshouldcorrectlybucketcrashinginputs
associated with a bug, but onlythat bug (and not those for other
bugs).Thatis, /hatwideTshouldbeasclosetoIdealBucketingaspossible,
giving strong assurance that /hatwideTdoes not overfit the input crashes.
Thus, we curated a dataset of fixes for 12 null dereference bugs
inasingleSQLiterevision.Thisisanoneroustaskbecausedeveloper
fixesareofteninterspersedoverlongperiodsoftime7andfixing
patchescannotalwaysbeautomaticallyappliedtopreviousrevi-
sions due to intermediate code changes. In addition, a single patch
maycontainmultiplefixes,whichwemustseparateforeachrespec-
tivebug.Wethereforemanuallyminimizedandbackportedpatches
to support a large, controlled ground truth study on multiple bugs
inSQLite.
Weselected w3moutofalistofprojectswithreportedCVEs[ 6]
and found that it also has multiple null dereferences for which we
could find developer fixes and crashing inputs that work on the
samerevision.8WedemonstrateSCBonfour(4)nulldereference
bugs on a single revision of w3m.
Other projects. We identify two null dereference bugs in differ-
ent versions of PHP, a large, popular project with well-documented
bugsandgroundtruthpatches.WedemonstrateSCBonreal-worldoverflowbugsin
R,alargeandpopularsoftwaresuiteforstatistical
computing; Conntrackd , a networking utility; and libmad, an MPEG
audiodecoder.WeapplySCBtoa strcpyvulnerabilityin R.Todemon-
stratereal-worldutility,wedemonstrateSCBontwoofourown
0-days found in previous fuzzing campaigns: a strcpyvulnerability
inConntrackd and amemcpyvulnerability in libmad.9
5.2 Crash Corpus Generation
Foreachbug,wegeneratealargebaselinecorpusofcrashingin-puts from the initial crashing input, aiming to exercise different
executionpathstriggeringthesamebug.Weusethiscorpustotest
howwelleachfuzzer’sdeduplicationmethodcopeswithvarying
behavior that trigger the same bug. Although a typical fuzzing
campaignbeginswithoneormorenon-crashingseedfilesasinput,
it is hard to trigger a specific bug starting with arbitrary seed files:
the inputsearch spaceis huge,and fuzzingnondeterminism means
itisdifficulttargetspecificareas ofcode.Isolatingfeaturesintest
cases is one strategy for producing crashing test cases that maycorrespondtothesamebug[
11,23],butcantakeseveraldaysto
produce a large test set. Instead, we pursue a conceptually similar
approach, mutating an initially crashing input to explore differ-
ent execution paths that trigger a particular bug. We then use this
corpus as input to the other state-of-the-art fuzzers.
7TheSQLitebugs were fixed over a period of four months.
8https://github.com/tats/w3m/issues?q=Null+pointer+is:closed
9Vulnerability disclosure is in progress with CERT under VRF#18-07-YMMKT and
VRF#18-07-XKJZJ .Todothis,weusetheexisting“CrashMode”procedureimple-
mented in AFL-Fuzz [ 7]. The crash exploration procedure tracks
branches executed by the input, and mutates input to try and force
execution along different branches, where the objective function is
topreservecrashingbehavior.Inputsthatfailtoexploreinterestingpathsorcrashtheprogramarediscarded.Weruncrashexploration
for two hours per bug, producing crash corpora of related inputs
for each bug’s crashing seed file.
5.3 Evaluating Fuzzers
Wecomparetothreestateoftheartfuzzers:AFL-Fuzz[ 7],CERT
BFF[2],andHonggfuzz[ 3].Thesefuzzersarefrequentlyusedin
industrialandresearchsettings[ 10,45,48]andimplementdiffer-
entdeduplicationtechniques.Ingeneral,fuzzersdonotdecouple
fuzzingcampaignswithcrashdeduplication;crashesarededupli-
catedduringfuzzeriterations.Totriggercrashdeduplication,we
seed fuzzing campaigns for each fuzzer with the crash corpus.
Industrial-strengthfuzzersarehighlyconfigurable.Wesoughtto
evaluate on default options across varying parameters in coverage-
based fuzzing, call stack depth, branch sequences, and point-of-
failure information. We evaluate on five configurations across the
three fuzzers:
AFL-Fuzz. We use AFL-Fuzz in its default configuration. AFL is
instrumentation-driven, and keeps track of branches taken dur-
ingfuzzing.Roughly,thismeansthatAFLissensitivetouniquely
executed paths. AFL’s default method for fuzzing uses the same
mechanismas“CrashMode”,startingfromanon-crashingseedand
withanobjectiveofdiscoveringarbitrarycrashes.Onekeydiffer-
ence,however,isthat“CrashMode”doesnotdeduplicatethecrash
corpus bydefault. Therefore, toapproximateAFL’s deduplication
in a real campaign (while avoiding a redundant fuzzing campaign),
we use AFL’s own minimization procedure directly on the crash
corpus, then remove equivalent duplicates.
CERTBFF. WerunCERTBFFinitsdefaultconfiguration,which
usesacallstackhashbasedon,bydefault,the fivelastcalls(frames)
leadingtoacrash.Thisnumberisconfigurable.Thus,forthesecond
configuration, we set BFF to use a call stack of just oneframe
to determine bug uniqueness. BFF also invokes a built-in input
minimizer while fuzzing on-the-fly.
Honggfuzz. WerunHonggfuzzinitsdefaultconfiguration,which
usesacallstackhashofsevencalls.Bydefault,Honggfuzzconsiders
informationatthepointoffailurewhenacrashoccurs(e.g.,thelast
knownPCinstructionandfaultingaddress)toreportuniqueness.
Honggfuzzcanenableafeedback-drivenfuzzingmode,provided
aprogramiscompiledwiththecoverageinstrumentation.Inthe
firstconfiguration,wedisablecoverage;inthesecond,weenable
coverage.
Notethatduetoinputmutationduringthecampaign,afuzzer
may trigger a bug that we do not have a fix for. As a final post
processing step, we use the ground truth fix Tto filter out only the
crashes fixed by T.
6 EXPERIMENTAL RESULTS
OurmainresultisthatSCBwithapproximatefixesis justaspre-
ciseas using the ground truth fix for 19 out of 21 bugs across all
configurations. Approximate fixes suffer only small imprecision,
618
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Rijnard van Tonder, John Kotheimer, and Claire Le Goues
Table 1: Semantic Crash Bucketing results. For each fuzzer configuration, we show the Ground Truth number of duplicate
crashes reported by thefuzzer (GT) compared to the numberof duplicate crashes reported using approximatefixes with SCB
(SCB+ /hatwideT). Crash Corpus is the number of crashing inputs that initially seed fuzzing campaigns for each configuration. For
example,Bug#1(firstrow)intheHFuzz,GTcolumnshowsthatHFuzzreports10duplicates(determinedbythegroundtruth
fix),whiletheapproximatefix(SCB+ /hatwideT)reports0duplicates.WhenSCB+ /hatwideTreports0duplicates,itisaspreciseasgroundtruth.
Crash AFL BFF-5 BFF-1 HFuzz HFuzz-Cov
Project Type IDCorpus GT SCB+ /hatwideTGT SCB+ /hatwideTGT SCB+ /hatwideTGT SCB+ /hatwideTGT SCB+ /hatwideT
SQLite Null-deref119125 0 21 11 10 0 91
248285 0 20 10 40 20
315338 0 60 00 16 0 14 0
432648 0 00 00 10 00
513934 0 00 00 00 00
6 6621 0 00 00 00 00
7 9720 0 00 00 00 00
823582 0 10 00 30 30
938929 0 10 00 10 10
10 27065 0 00 00 10 10
11 16745 1 00 00 42 11
12 10836 0 00 00 00 00
Subtotal 2,623 528 1 12 1 21 40 2 31 2
w3m Null-deref13 458103 0 25 0 10 75 0 77 0
14 54523 0 00 00 00 00
15 50736 0 00 10 60 40
16 52511 0 00 10 00 00
Subtotal 2,035 173 0 25 0 30 81 0 81 0
PHP Null-deref17 8180 00 00 00 00
18 27232 0 00 00 00 00
R Overflow 19 750 30 00 145 0 198 0
Conntrackd Overflow 20 2500 00 00 770 0 427 0
libmad Overflow 21 138 80 10 00 10 00
Total 5,181 754 1 41 1 51 1,037 2 737 2
andperformsignificantlybetterdeduplicationcomparedtostate-
of-the-art fuzzer deduplication in our experiments.
SpeedandPr oject Size. Automaticpatchgenerationforapprox-
imate fixes is fast. Generating a patch from crashing input and
validatingthatitfixesthecrash(includingprojectrecompilation)
takesjust18secondsonaverageacrossallbugs.Theminimumtime
for patch generation and validation is 2 seconds, the maximum 49
seconds.Oursampleuseslargereal-worldprojects,rangingfrom
12 KLOC to 1 MLOC.
6.1 Overall Results
Table1shows results. Each row corresponds to a unique bug, with
assigned “ID”. “Crash Corpus” is the number of crashing inputs
that initially seed the fuzzing campaigns. We deduplicate crash-
ing inputs for each bug using five fuzz campaign configurations
(Section5):AFL,BFF-5andHFuzzaredefaultconfigurationsfor
thethreefuzzers. BFF-1configuresBFFtousejustonecallinits
callstackhash; HFuzz-Cov turnsoncoverageinstrumentationfor
feedback fuzzing in HonggFuzz. “GT” is the Ground Truth num-
ber of duplicate reports for each respective configuration, which
we obtain using the actualdeveloper fix Tfor each bug. Column“SCB+ /hatwideT” isthe numberof duplicatebugs fora campaignreported
using approximate fixes with SCB.
ExceptforBugs 1and11in SQLite(discussedsubsequently),ap-
proximate fixes are as precise as the ground truth fix across all
configurations. That is, approximate fixes detect and remove allduplicates across all fuzzing configurations for 19 out of 21 bugs.For projects
SQLiteandw3mcontaining multiple bugs, none of our
approximate patches suppress any other unique bug. In aggregate,
SCBwithapproximatefixessignificantlyreducesthenumberofdu-
plicate crash reports compared to the default configurations: from
754 and 1,037 to just two duplicates for AFLandHFuzz, respec-
tively,andareductionof41duplicatestooneduplicatefor BFF-5.In
practice, crash reports produced by fuzzers must be further triaged
manually. Our results show that applying approximate fixes canautomatically cut down on the time that an engineer spends on
further triage.
Ground truth fixes expose different “semantic sensitivities” of
errorreportingacrossconfigurationsandbugtypes.AFL-Fuzzon
average reports more duplicate bugs; this is expected due to itssensitivity to unique execution paths, especially for null derefer-
ences.Ontheotherhand,AFLandBFFreportmoderatenumbers
619
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Semantic Crash Bucketing ASE ’18, September 3–7, 2018, Montpellier, France
ofduplicatesforoverflowbugs,whereasHonggfuzzreportshun-
dreds of crashes for two stack-based overflows (Bugs 19 and 20).
Honggfuzz’s default sometimes considers portions of overflowing
stackdatatosignaluniquebugs.Bug21isaheap-basedoverflow,
and does not adversely affect Honggfuzz compared to stack-based
bugs.BFF-1uses just one call to calculate a unique stack hash
per bug, and reports the least amount of duplicate bugs. Although
BFF-1appearstoperformwell,theconfigurationisnonstandard
in practice because it has the caveat that unique bugs triggered
in the same function are easily missed. None of the bugs in our
sample exposes this weakness in the BFF-1configuration, but it is
uncommoninrealfuzzingcampaigns.Weincludeitasoneextreme
example where coarse, aggressive deduplication can be performed
at the cost of potentially missing unique bugs.
Notethatevenforcaseswhereafuzzingconfigurationreports
noduplicates fora particularbug,approximatefixesdo aswellas
fuzzer deduplication, and strictly better for the majority of cases
whereduplicatesarereported.Thisemphasizesanimportantpoint:
approximatefixesuniformlybucketcrashesviaconfigurablesen-
sitivitytobug-classsemantics.Ourresultsshowthatlightweight
programtransformationcaneffectivelyavoidimprecisiondueto
varying (yet broadly applied) choices made by built-in fuzzer dedu-
plication methods.
6.2 Project-Specific Results
SQLite.Approximatefixesfor SQLiteperformidenticallytoground
truth except for Bugs 1 and 11. Patches for Bugs 1 and 11 failto fix 7 crashing inputs out of a larger duplicate crash set of 62
crashesreportedbyfuzzers.Weanalyzedtheseinputsandfound
thattheygenerallytriggerdifferentcrashingbehaviordownstream
in execution that our approximate patches do not catch (but which
correct patches handle earlier upstream). The implication is not
severe: SCB+ /hatwideTonly reports 7 duplicates over all configurations,
which is comparatively low compared to duplicate fuzzer reports.
w3m.SCB+/hatwideTperfectly simulates ground truth bucketing for w3m.
Our approximate fixes are semantically close to developer fixes:
each approximate patch checks the same program variable for NULL
as the corresponding developer patch. Interestingly, Bug 13 pro-
duces far more duplicate crashes compared to the other three bugs
across all configurations. This demonstrates a latent benefit of our
approach:SCBcanrevealpropertiesaboutbuggybehavior(e.g.,we
speculatethatBug13canbetriggeredalongmanyexecutionpaths
and different call chains compared to the other bugs).
Weconfirmedthatcrashbucketingwith Tand/hatwideTresultindisjoint
buckets for multiple bugs in SQLiteandw3m, and corresponds to the
assumptions of Ideal Bucketing (i.e., zero overlap of crashing
inputs of distinct bug fixes).
PHP.WeappliedSCBtoonebugeachin PHPv5(CVE-2016-6292)
and v7 (CVE-2016-10162). SCB improves over AFL’s reports; the
other configurations do not report duplicates.R
andConntrackd bothcontain strcpyoverflowbugs.The Rbug
is assigned CVE-2016-8714. We discovered a 0-day strcpybug in
Conntrackd in our own fuzzing efforts. Since no developer fix exists
fora0-day,wemanuallydebuggedtodevelopagroundtruthpatch.
We have disclosed the bug and recommended the patch to the
maintainers. As mentioned, Honggfuzz is particularly sensitive tochangesinthestack,especiallyoverflowvulnerabilitiesaffecting
thestack.Honggfuzzprovidesawayofblacklistingstackhashes
to compensate,10but this option is disabled by default.
libmad.Wealsodiscovereda0-day memcpybuginlibmadwithour
ownfuzzing. Wedevelopedour ownpatchtoperform thecorrect
boundscheckingonthelengthofbytestocopy.Interestingly,devel-
opers added a C assertstatement before the memcpycall that checks
thecorrectbounds.However, assertstatementsarenotcompiled
in release versions and the bug results in a SEGFAULT. We used the
assertstatementtoinformagroundtruthfixforcheckingthebuffer
bound.Ourdeduplicationgainsissmallerfor libmad,butremains
precise.Our libmadexampleshowsthatapproximatefixesextend
to varieties of API calls in real world bugs with little effort.
6.3 Discussion
MeritsofSCBandapproximatefixes. Ourapproachcanbelay-
eredontopofexistingfuzzerdeduplicationmethodsorasadrop-in
replacement.Ingeneral,SCBopenstheopportunitytoparameterize
bucketingusingtargetedprogramtransformation.Oneadvantage
ofautomatedpatchgenerationisresiliencetochangesinunrelated
code across revisions. Concretely, we can generate an approximate
fixforanyrevisioncontainingthebug.Thisisnottrueforstatic,de-
veloperwritten patches. As explained,we hadto takecarefuleffort
to isolate and backport existing patches for a ground truth study.
Approximate fixes can also improve fuzzing performance and
coverage [ 40]. Fuzzers are known to get stuck on shallow bugs
that restrict execution past a memory corruption bug.11Our ap-
proachprovidesalightweight,parameterizablesolutiontoaugment
fuzzing behavior and overcome such obstacles. We are currently
investigating these extensions and additional bug classes.
Limitations. Our approach requires some up front manual cost
to parameterize automated behavior for generating approximate
fixes.Complexityofthetargetedbugclassalsobearsonthediffi-
culty of specifying appropriate semantic cues and patch templates,
andvariousapproximationswillaffectaccuracyofsemanticbug
containment. We demonstrated, however, that conceptually simple
patch templates and semantic cues work well for common bugs
found by fuzzers in real world programs. We speculate that the
approachgeneralizesfurtherto,e.g.,division-by-zero,arithmetic
overflows and use-after-free bugs. In general, we offer that one-off
specifications per bug class is competitive with per-fuzzer configu-
ration that preclude fine-grained semantic control.
Our time spent selecting projects to evaluate was dominated
bywhetherwecouldfindgroundtruthfixesandcrashinginputs.
Thoughthesampleissmall,everyprojectthatsatisfiedthesecriteria
has worked with our approach so far (i.e., we do not fail to find
an approximate fix), modulo the need for incremental refinements
in our approach (e.g., we added a preprocessing step that expands
macrosin PHPtodiscovernulldereferencesyntaxwhentheprogram
crashes).
Inourexperimentsweobservethatbothapproximateanddevel-
operfixesaddressuniquebugswithasinglecheck.Conceptually,
we can imagine a case where some buggy behavior (e.g,. a null
pointer) may be checked once before branching on multiple paths,
10https://github.com/google/honggfuzz/pull/29
11https://github.com/google/fuzzer-test-suite/tree/master/libxml2-v2.9.2
620
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. ASE ’18, September 3–7, 2018, Montpellier, France Rijnard van Tonder, John Kotheimer, and Claire Le Goues
or alternatively along two different paths. Depending on the trans-
formation, crashing inputs may thus map to one or two buckets.
Our approach for null dereferences currently follows the second
strategy forbucketing (sincewe addthe checkclose towhere the
dereference occurs). In our experiments, this matched the behavior
of developer fixes. Note that we can extend our approach to usefirst strategy (i.e., by searching for branch points and inserting
checks upstream) and even compare different strategies; exploring
and comparing such transformation strategies holds interesting
potential for future work.
Duetothedifficultyofperformingorganicfuzzingcampaigns
forknownbugs,wepurposelygenerateacrashcorpusbymutatingexisting crashing inputs. The generated crash corpus likely inflates
the number crashes that an organic campaign would encounter.
Nevertheless,thecrashcorpusservesasausefulupperboundto
quantifyprecisionofdefaultdeduplicationtechniquesinfuzzers
versus SCB.
We evaluate our approach on existing state of the art fuzzers
under default options and with small modifications to BFF and
Honggfuzz.Werecognizethatdeduplicationcanbetweakedand
improved with additional parameters and post processing (e.g.,stack hash blacklists), but we generally believe that fuzzers (like
other tools), should run with sensible defaults.
7 RELATED WORK
Our approach relates generally to existing work in identifying bug
uniquenessandbucketingcrashinginputs[ 14,17,18,41].Ofpartic-
ular interest, Chen et al. [ 14] propose a machine learning approach
thatranksinterestingtestcasesforcompilerfuzzeroutput,anduse
fixing patches as ground truth to map crashing inputs to unique
bugs.SemanticCrashBucketingdrawsontheideaofusingground
truth fixes to precisely identify unique bugs, obtaining similar pre-
cision to ground truth by automatically approximating fixes.
Recent work by Pham et al. [ 41] uses a clustering algorithm
thatreliesonasemanticcharacterizationofinputsasconstraints
overpaths,withparticularapplicabilitytosymbolicexecutors.Our
approach also promotes a semantic characterization of bugs, butfocuses on being sensitive to semantic properties of bugs them-
selves,ratherthansummarizingcrashinginputsintermsofpath
constraints. Broadly, current techniques manipulate and analyze
program input orotherwise instrument programs to obtain“read-
only”behaviorofprograms(suchasinputcoverage[ 14],constraints
on input [ 41], or crash callstack [ 37]) to group crashes. To the best
ofourknowledge,SCBisthefirsttechniquethatappealsto program
modification forpreciselygroupingcrashinginputintheabsence
of ground truth fixes.
Angelicdebugging[13]seekstomodifyprogramsbyreplacing
expressionswithvalues,whichbearsconceptualsimilaritytoour
approximating fixes for C library functions. Our problem focus
differs, however: we seek accurate crash bucketing in the presence
ofduplicatedorunreportedbugs,whileAngelicdebuggingseeks
to fix failing test cases while preserving existing passing test cases.
In terms of program modification, our work relates to failure-
oblivious computing [ 35,44]. For instance, our rule-based appli-
cation of fix templates share similarities with the idea proposedby Long et al. [ 35], who modify a program so that a null derefer-
encedoesnotcauseittocrash.Theobjectiveoffailure-oblivious
computing, however, is to make program execution resilient to
crash-inducingeffectsofbugssuchasnulldereferencesordivide-
by-zero errors. In contrast, SCB seeks to isolateunique bugs by
selectivelyapplyingprogramtransformation,ratherthanprovidinganautomatic catch-alltechnique forkeeping aprogram runningin
the interest of resilience. Syntactic patches promote the benefit of
“patchesasbetterbugreports”[ 47]sothatengineerscananalyze
semantic effects that influence crash bucketing. Peng et al. [ 40]
show that applying program transformation while fuzzing can in-
creaseprogramcoverageandrevealmore bugs;whileourapproach
focusesonaccuratecrashbucketing,ourtechniquecomplements
this recent idea.
Fault localization [ 15,25,32,43] and automatic program re-
pair[30,33,49]sharesimilar highlevelgoalsforidentifying bugs
andautomaticallyfixingthem.Thisworkisbroadlycomplemen-
tarytoours,providingtechniquesthatcanassistwithaccurately
identifying fault locations for patch placement, and appropriate
program transformations for different bug classes.
8 CONCLUSION
We introduced Semantic Crash Bucketing, a way to perform crash
bucketing using lightweight program transformation. We then de-
veloped an automatic approach that applies patch templates to
approximate real developer fixes to perform crash bucketing. Our
approachusesconfigurablerules(specifiedonceperbugclass)that
instantiateandapplypatchtemplatesbasedoncrashingbehavior.
Unlikecoarse deduplicationmethods, rulesandtemplates aresen-
sitive to bug-specific semantic properties and crashing behavior.
We developed approximate fixes for null dereferences and buffer
overflows.WeperformedagroundtruthstudycomparingSCBand
approximate fixes to (a) true developer fixes and (b) crash dedupli-
cationofthreestateoftheartfuzzers(AFL,BFF,andHonggfuzz).
Ourresultsshowthatapproximatefixesarecompetitivewithcrash
bucketingprecisionoftruedeveloperfixes,andperformsstrictly
better deduplication than all tested fuzzer configurations.
ACKNOWLEDGMENTS
This work is partially supported under NSF grant number CCF-
1750116 and CCF-1563797. All statements are those of the authors,
and do not necessarily reflect the views of the funding agency. TheauthorswouldliketothankJeremyLacomisforcopyeditingearlier
versions of this work.
REFERENCES
[1] 2018. https://github.com/google/oss-fuzz. Online; accessed 26 April 2018.
[2] 2018. https://www.cert.org/vulnerability-analysis/tools/bff-download.cfm. On-
line; accessed 26 April, 2018.
[3] 2018. https://github.com/google/honggfuzz. Online; accessed 26 April, 2018.
[4] 2018. https://cve.mitre.org/. Online; accessed 26 April, 2018.
[5]2018.https://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.
html. Online; accessed 26 April, 2018.
[6]2018.https://access.redhat.com/security/security-updates/#/cve. Online; ac-
cessed 26 April, 2018.
[7]2018. AFL-Fuzz. http://lcamtuf.coredump.cx/afl/. Online;accessed26April,2018.
[8]2018. CVE-2017-12762. https://patchwork.kernel.org/patch/9880041/. Online;
accessed 26 April, 2018.
[9]2018. Microsoft Security Risk Detection. https://www.microsoft.com/en-us/
security-risk-detection/. Online; accessed 26 April, 2018.
621
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. Semantic Crash Bucketing ASE ’18, September 3–7, 2018, Montpellier, France
[10]2018. Public Vulnerabilities Discovered Using BFF. https://vuls.cert.org/
confluence/display/tools/Public+Vulnerabilities+Discovered+Using+BFF. Online;
accessed 26 April, 2019.
[11]Mohammad Amin Alipour, Alex Groce, Rahul Gopinath, and Arpit Christi. 2016.
Generating focused random tests using directed swarm testing. In International
Symposium on Software Testing and Analysis (ISSTA ’16). 70–81.
[12]Thanassis Avgerinos, Alexandre Rebert, Sang Kil Cha, and David Brumley. 2014.
Enhancingsymbolicexecutionwithveritesting.In InternationalConferenceon
Software Engineering (ICSE ’14). 1083–1094.
[13]SatishChandra,EminaTorlak,ShaonBarman,andRastislavBodík.2011. Angelic
debugging.In InternationalConferenceonSoftwareEngineering (ICSE’11).121–
130.
[14] Yang Chen,AlexGroce, ChaoqiangZhang,Weng-Keen Wong,XiaoliFern, Eric
Eide,andJohnRegehr.2013. Tamingcompilerfuzzers.In ConferenceonProgram-
ming Language Design and Implementation (PLDI ’13). 197–208.
[15]HolgerCleveand AndreasZeller.2005. Locatingcausesof programfailures.In
International Conference on Software Engineering (ICSE ’05). 342–351.
[16]ZackCokerandMunawarHafiz.2013. ProgramtransformationstofixCintegers.
InInternational Conference on Software Engineering (ICSE ’13) . 792–801.
[17]Weidong Cui, Marcus Peinado, Sang Kil Cha, Yanick Fratantonio, and Vasileios P
Kemerlis. 2016. RETracer: Triaging crashes by reverse execution from partial
memorydumps.In InternationalConferenceonSoftwareEngineering (ICSE’16).
820–831.
[18]YingnongDang,RongxinWu,HongyuZhang,DongmeiZhang,andPeterNobel.
2012. ReBucket:Amethodforclusteringduplicatecrashreportsbasedoncall
stacksimilarity.In InternationalConferenceonSoftwareEngineering (ICSE’12).
1084–1093.
[19]Vinod Ganapathy, Somesh Jha, David Chandler, David Melski, and David Vitek.
2003. Buffer overrun detection using linear programming and static analysis. In
Conference on Computer and Communications Security (CCS ’03). 345–354.
[20]Patrice Godefroid and Daniel Luchaup. 2011. Automatic partial loop summariza-
tion in dynamic test generation. In International Symposium on Software Testing
and Analysis (ISSTA ’11) . 23.
[21]Denis Gopan, Evan Driscoll, Ducson Nguyen, Dimitri Naydich, Alexey Loginov,
andDavidMelski.2015.Data-DelineationinSoftwareBinariesanditsApplication
toBuffer-OverrunDiscovery.In InternationalConferenceonSoftwareEngineering
(ICSE ’15). 145–155.
[22]Rahul Gopinath, Carlos Jensen, and Alex Groce. 2017. The Theory of Composite
Faults. In International Conference on Software Testing, Verification (ICST ’17).
47–57.
[23]Alex Groce, Chaoqiang Zhang, Eric Eide, Yang Chen, and John Regehr. 2012.
Swarm testing. In International Symposium on Software Testing and Analysis
(ISSTA ’12). 78–88.
[24]Brian Hackett, Manuvir Das, Daniel Wang, and Zhe Yang. 2006. Modular check-
ing for buffer overflows in the large. In International Conference on Software
Engineering (ICSE ’06). 232–241.
[25]JamesA.JonesandMaryJeanHarrold.2005. Empiricalevaluationofthetarantula
automatic fault-localization technique. In International Conference on Automated
Software Engineering (ASE ’05). 273–282.
[26]Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Auto-
matic patch generation learned from human-written patches. In International
Conference on Software Engineering (ICSE ’13). 802–811.
[27]ShuvenduK.Lahiri,RohitSinha,andChrisHawblitzel.2015. AutomaticRootcaus-
ing for Program Equivalence Failures in Binaries. In Computer Aided Verification
(CAV ’15). 362–379.
[28]David Larochelle and David Evans. 2001. Statically Detecting Likely Buffer
Overflow Vulnerabilities. In USENIX Security Symposium.
[29]ClaireLeGoues,MichaelDewey-Vogt,StephanieForrest,andWestleyWeimer.
2012. A Systematic Study of Automated Program Repair: Fixing 55 out of 105Bugs for $8 Each. In International Conference on Software Engineering (ICSE ’12).
3–13.
[30]ClaireLeGoues,StephanieForrest,andWestleyWeimer.2013.Currentchallenges
in automatic software repair. Software Quality Journal 21, 3 (2013), 421–443.
[31]Frank Li and Vern Paxson. 2017. A Large-Scale Empirical Study of SecurityPatches. In Conference on Computer and Communications Security (CCS ’17).
2201–2215.
[32]Ben Liblit, Mayur Naik, Alice X. Zheng, Alexander Aiken, and Michael I. Jordan.
2005. Scalable statistical bug isolation. In Programming Language Design and
Implementation (PLDI ’05). 15–26.
[33]Zhiqiang Lin, Xuxian Jiang, Dongyan Xu, Bing Mao, and Li Xie. 2007. AutoPaG:
towardsautomatedsoftwarepatchgenerationwithsourcecoderootcauseidenti-ficationandrepair.In SymposiumonInformation,ComputerandCommunications
Security. 329–340.
[34]Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning
Correct Code. In Principles of Programming Languages (POPL ’16). 298–31.
[35]Fan Long, Stelios Sidiroglou-Douskos, and Martin C. Rinard. 2014. Automatic
runtimeerrorrepairandcontainmentviarecoveryshepherding.In Conference
on Programming Language Design and Implementation (PLDI ’14). 227–238.
[36]Sergey Mechtaev, Jooyong Yi, and Abhik Roychoudhury. 2016. Angelix: Scal-
ableMultilineProgramPatchSynthesisviaSymbolicAnalysis.In International
Conference on Software Engineering (ICSE ’16). 691–701.
[37]D Molnar, XC Li, and DA Wagner. 2009. Dynamic test generation to find integer
bugs in x86 binary linux programs. In USENIX Security Symposium. 67–82.
[38]PaulMuntean,VasanthaKommanapalli,AndreasIbing,andClaudiaEckert.2015.
AutomatedGenerationofBufferOverflowQuickFixesUsingSymbolicExecution
andSMT.In ComputerSafety,Reliability,andSecurity (SAFECOMP’15) .441–456.
[39]Hoang Duong Thien Nguyen, Dawei Qi, Abhik Roychoudhury, and Satish Chan-
dra.2013.SemFix:ProgramRepairviaSemanticAnalysis. InternationalConference
on Software Engineering, 772–781.
[40]Hui Peng, Yan Shoshitaishvili, and Mathias Payer. 2018. T-Fuzz: fuzzing by
program transformation. In IEEE Symposium on Security and Privacy.
[41]Van-ThuanPham,SakaarKhurana,SubhajitRoy,andAbhikRoychoudhury.2017.
Bucketing Failing Tests via Symbolic Analysis. In Fundamental Approaches to
Software Engineering Conference (FASE ’17) . 43–59.
[42]Alexandre Rebert, Sang Kil Cha, Thanassis Avgerinos, Jonathan Foote, David
Warren,GustavoGrieco,andDavidBrumley.2014. OptimizingSeedSelection
for Fuzzing. In USENIX Security Symposium. 861–875.
[43]Manos Renieris and Steven P. Reiss. 2003. Fault Localization With Nearest
NeighborQueries.In InternationalConferenceonAutomatedSoftwareEngineering
(ASE ’03). 30–39.
[44]MartinCRinard,CristianCadar,DanielDumitran,DanielMRoy,TudorLeu,and
William S Beebee. 2004. Enhancing Server Availability and Security Through
Failure-Oblivious Computing.. In OSDI, Vol. 4. 21–21.
[45]KostyaSerebryany.2017. OSS-Fuzz-Google’scontinuousfuzzingserviceforopen
source software. In USENIX Security Symposium.
[46]Mauricio Soto, Ferdian Thung, Chu-Pan Wong, Claire Le Goues, and David
Lo. 2016. A deeper look into bug fixes: patterns, replacements, deletions, and
additions.In InternationalConferenceonMiningSoftwareRepositories (MSR’16).
512–515.
[47]Westley Weimer. 2006. Patches as better bug reports. In Generative Programming
and Component Engineering (GPCE ’06). 181–190.
[48]Maverick Woo, Sang Kil Cha, Samantha Gottlieb, and David Brumley. 2013.
SchedulingBlack-boxMutationalFuzzing.In ConferenceonComputer&Commu-
nications Security (CCS ’13). 511–522.
[49]Jifeng Xuan, Matias Martinez, Favio Demarco, Maxime Clement, Sebastian
R.LamelasMarcote,Thomas Durieux,DanielLeBerre,andMartinMonperrus.
2017. Nopol: Automatic Repair of Conditional Statement Bugs in Java Programs.
IEEE Trans. Software Eng. 43, 1 (2017), 34–55.
622
Authorized licensed use limited to: LAHORE UNIV OF MANAGEMENT SCIENCES. Downloaded on August 07,2025 at 13:28:00 UTC from IEEE Xplore.  Restrictions apply. 