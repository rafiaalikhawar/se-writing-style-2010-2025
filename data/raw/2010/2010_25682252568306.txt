Towards EfÔ¨Åcient Optimization in
Package Management Systems
Alexey Ignatiev
IST/INESC-ID, Lisbon,
Portugal
aign@sat.inesc-id.ptMikol√°≈° Janota
IST/INESC-ID, Lisbon,
Portugal
mikolas@sat.inesc-id.ptJoao Marques-Silva
University College Dublin,
Ireland
IST/INESC-ID, Lisbon,
Portugal
jpms@ucd.ie
ABSTRACT
Package management as a means of reuse of software arti-
facts has become extremely popular, most notably in Linux
distributions. At the same time, successful package manage-
ment brings about a number of computational challenges.
Whenever a user requires a new package to be installed,
a package manager not only installs the new package but
it might also install other packages or uninstall some old
ones in order to respect dependencies and conicts of the
packages. Coming up with a new conguration of packages
is computationally challenging. It is in particular complex
when we also wish to optimize for user preferences, such as
that the resulting package conguration should not dier too
much from the original one. A number of exact approaches
for solving this problem have been proposed in recent years.
These approaches, however, do not have guaranteed runtime
due to the high computational complexity of the problem.
This paper addresses this issue by devising a hybrid ap-
proach that integrates exact solving with approximate solv-
ing by invoking the approximate part whenever the solver
is running out of time. Experimental evaluation shows that
this approach enables returning high-quality package cong-
urations with rapid response time.
Categories and Subject Descriptors
D.2.13 [ Reusable Software ]: Domain engineering; F.2.2
[Nonnumerical Algorithms and Problems ]: Compu-
tations on discrete structures; G.1.6 [ Optimization ]: Con-
strained optimization; K.6.3 [ Software Management ]: Soft-
ware maintenance
General Terms
Algorithms, Performance, Management
Keywords
Package management, SAT solving, MaxSAT solving, Opti-
mization, Minimal Correstion Subsets
Permission to make digital or hard copies of all or part of this work for per-
sonal or classroom use is granted without fee provided that copies are not
made or distributed for proÔ¨Åt or commercial advantage and that copies bear
this notice and the full citation on the Ô¨Årst page. Copyrights for components
of this work owned by others than the author(s) must be honored. Abstract-
ing with credit is permitted. To copy otherwise, or republish, to post on
servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE ‚Äô14, May 31 ‚Äì June 07 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/06 ...$15.00.1. INTRODUCTION
The complexity of package management systems stems
from two main objectives: personalization and reusability .
On the one hand, dierent users are expected to use their
computers for dierent purposes and thus requiring dierent
software artifacts on their computers but on the other hand,
it is desirable to reuse software artifacts whenever possible.
Nowadays package management systems, such as those be-
hind Linux distributions , enable handling hundreds of thou-
sands of software artifacts. This is possible due to organizing
software into packages and explicitly recording relations be-
tween those packages. Once a user requires for a package to
be installed, a program called the package manager consults
thepackage repository and determines the package's depen-
dencies , i.e. which other packages also need to be installed.
Or, it might determine that some other package conicts
with the one that is supposed to be installed.
Due to such relations between packages, maintaining a
particular package conguration consistent poses a compu-
tational challenge. Indeed, to determine whether a package
can be installed into a given conguration of packages is NP-
complete [1]. Consequently, current package management
tools are known to be notcomplete, i.e. there are situations
when they are not able to nd a solution even if it exists [2].
All of the above motivates the formulation of package
upgradability problem (orpackage installability ). The input
to the problem is the initial conguration ,relations between
packages (conicts and dependencies), and user's request [3].
The output to the problem is a conguration of packages
that satises the relations between them and also the user's
request. For the purpose of this article we consider a request
to be a set of packages to be installed and a set of packages to
be removed. In our implementation, however, the upgrade
request is also supported; such can be modeled as removal
of an old version and installation of a new version.
In practice, users are not likely to be satised with an ar-
bitrary solution to the package upgradability problem. For
instance, users typically expect that the resulting congu-
ration of packages will not dier too much from the initial
conguration. Or, the user may wish to bring all the pack-
ages up to date. For this purpose, we also enable the user
to specify optimization criteria that are to be optimized in
the resulting package conguration.
While optimization criteria are indispensable for practical
application of package management, they make the problem
computationally more complex. However, number of ap-
proaches were developed in the recent years relying on vari-Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the author/owner(s). Publication rights licensed to ACM.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
ACM 978-1-4503-2756-5/14/05
http://dx.doi.org/10.1145/2568225.2568306
745
ous technologies, such as Answer set programming ,Pseudo-
Boolean optimization , or MaxSAT [1, 2, 4, 5]. It has been
demonstrated that these approaches are mature enough to
be applied in practice. Most notably, the development envi-
ronment Eclipse IDE [6] employs the pseudo-Boolean-based
engine P2 to drive package management.
Dedicated optimization solvers have an important advan-
tage over heuristic-based algorithms and that is, they guar-
antee to nd the optimal solution given sucient amount of
time. The runtime, however, might be an issue from a prac-
tical perspective due to the high computational complexity
of the problem. It is unacceptable for a user to wait hundreds
of seconds. Thus, for successful integration of the tools into
practice, they must be able to nd a solution within a num-
ber of seconds [7]. Therefore, an optimization solver may be
forced to stop in the middle of the computation and return
some solution, which is possibly non-optimal. This is indeed
the case in the solver P2, which is used in Eclipse IDE. Ob-
serve that Eclipse IDE is used by literally millions of users,
and so millions of users use P2 on a regular basis.
To our best knowledge, there is no approach to the pack-
age upgradability problem that would be dedicated to nd-
ing good approximate solutions within practical time limits.
Instead, the current approaches respond with a \best so far"
solution, which provides little or no guarantees.
The discussion above can be summarized into two main
observations:
1. Complete optimization solvers canbe successfully used
in practice.
2. Users require rapid responses and therefore it is likely
that the solver will run out of time.
These observations lead to the following challenge: if a
complete package upgradability solver is running out of time,
it must be able to produce a good solution nevertheless.
In response to this challenge, this paper proposes an ap-
proach for nding good near-optimal solutions to the pack-
age upgradability system. At the same time, it enables con-
struction of a hybrid solver . This hybrid solver integrates
a complete approach with the approximation approach in a
way that the approximation approach is invoked only when
needed. Thus, it is providing us with the best of the two
worlds: completeness and rapid response.
We have implemented this hybrid solver on top of an ex-
isting tool for the package upgradability problem. We have
performed an extensive experimental evaluation, where our
hybrid approach was compared to the tool P2. This evalua-
tion demonstrates that the hybrid approach enables resolv-
ing much larger number of instances than P2 within a rapid
timeout. Further, the provided responses are signicantly
closer to the optimum than the responses of P2.
This article is organized as follows. Section 2 introduces
concepts and notation used throughout the paper. Section 3
describes the proposed approach for solving package upgrad-
ability; this section is the main contribution of the paper.
Section 4 presents an experimental evaluation of the pro-
posed approach. Related work is summarized in Section 5
and nally the paper concludes by Section 6.
2. PRELIMINARIES
A number of formalisms exists to explicitly capture de-
pendencies between software artifacts. Prominent examples
arefeature models , which capture dependencies of software
a
b
 c
f
 d
 e()
conicts
g
h
x
y
z
w
or
(
()(
or
 or
Figure 1: Example dependencies
components of a software system including variability [8].
Linux distributions rely on package management systems
where software components are organized into packages cap-
tured in standardized formats such as RPM [9] or DEB [10].
Apackage manager is used to maintain a particular con-
guration of the system in a consistent state, i.e. in a state
where dependencies between packages are not violated. Such
package manager must be able to receive requests from the
user to install or uninstall certain packages. Whenever such
request is obtained, the package manager must compute a
new conguration satisfying both the request and the pack-
age dependencies.
Figure 1 schematically shows a small example of depen-
dencies between packages (the diagram uses primitives sim-
ilar to the ones used in feature modeling [8]). Imagine now
that we wish to install package aand at the same time we
wish to minimize the number of installed packages. Since a
requires both bandc, these have to be installed as well. Now
the packages f,d, andecan be used to fulll dependencies
ofbandc. In this case, as we want to minimize the number
of installed packages, we install das that satises dependen-
cies of both bandc. Now let us consider another scenario
where we wish to install both aandgand again, we wish to
minimize the number of installed packages. If we solve the
problem greedily and install a,b,c, andd, we will end up
with a suboptimal solution because package dexcludes the
use of package fand therefore packages h;x;y;z;w have to
be used to satisfy dependencies of package g.
In this paper we consider packages described in the lan-
guage Common Upgradability Description Format (CUDF,
e.g. see [11]) . CUDF was developed by the scientic com-
munity and thus is more amenable to scientic analysis and
is supported by a number of freely available tools [12]. At
the same time, CUDF is a realistic language which was suc-
cessfully integrated into existing tool-chains [13].
For the sake of succinctness and clarity, the presentation
in this paper does not consider the full extent of the CUDF
language (but the language was considered in full for the
experimental analysis). Every package has a name and a
version , where a name is a string and version is a positive
natural number. A package may depend on some other pack-
ages or it may conict with some other packages. A package
can also be attributed its sizeor the set of packages that are
recommended to be installed with it. The attribute installed
tells us if the package is installed in the current package
conguration. An example of a package in CUDF follows.
package: openssl
version: 5
depends: libc6 >= 9, libssl1.0.0 >= 5,
zlib1g >= 14
conflicts: openssl
installed: true
installedsize: 1184746The package's name is openssl in its version is 5. For its
functioning the package requires certain versions of libc6 ,
libssl1.0.0 , and zlib1g . For instance, if this package is
to be installed, there must be also installed a package libc6
with the version greater or equal to 91. The conflicts
specication in this case says that the package conicts with
all packages with the same name except with itself.
A solver for the package upgradability problem is given
a set of packages, each described as the one in the exam-
ple, and it outputs a new package conguration as a set of
packages that are installed in it.
2.1 Package Upgradability Problem
The problem that a package manager has to solve when-
ever it faces a user request is called the package upgradability
problem . A package manager operates on a package universe
(orrepository ), i.e. the set of packages that are visible to it.
Auser request comprises packages that the user wishes to
beinstalled and the set of packages that the user wishes to
beuninstalled . Additionally, the package manager may be
given a criterion according to which it should optimize when
looking for the new conguration. Such criterion can be for
instance minimizing the number of newly installed packages
or minimizing the number of packages that were installed in
the initial setup but are uninstalled in the solution.
More formally, a package manager is given a package uni-
verseUand a user request represented as a pair ( I;R), where
Irepresents the packages that are to be installed and Rare
the packages to be removed. The output is a set of pack-
agesNsuch thatNcontains all of the packages from I; does
not contain any of the packages from R; and all the package
dependencies and conicts are respected in N. If suchN
does not exist, the package manager reports a failure.
Optimization criteria are a complex issue and it is beyond
the scope of this paper to describe them in full detail. We
consider optimization criteria used in the MISC competi-
tion [12]. These criteria typically rely on some additional
attributes of a package (e.g. see openssl above). Most no-
tably, a package can have the attribute installed , which
signies that the package is currently installed in the sys-
tem (if the attribute is not present, it defaults to false ).
This attribute enables specifying criteria that express that
the new installation should dier from the original one as
little as possible. Multiple sub-criteria are combined by
alexicographic ordering . For instance a criterion specied
as(-count(removed), -count(changed)) denes a lexico-
graphic order where we wish to minimize the number of re-
moved and the number of changed packages, and, minimiz-
ing the number of removed packages has a higher priority
than minimizing the number of changed packages.
2.2 Boolean SatisÔ¨Åability and Maximum Sat-
isÔ¨Åability
To decide whether a package upgradability problem has
a solution or not, is NP-complete [1]. Hence, appropriate
tools for solving the problem need to be chosen. The pack-
age upgradability problem naturally translates to Boolean
satisability (SAT) [2],constraint satisfaction (CSP) [3, 4],
oranswer set programming (ASP) [5] paradigms. In this
paper we consider the SAT paradigm and for the optimiza-
1The version numbers of the packages does not necessarily
have to correspond to the version of the software component
that the package encapsulates.tion part of the problem we consider a maximal satisability
(MaxSAT) [14] formulation. For such the following standard
denitions are considered.
Aliteral is a Boolean variable or its negation. A clause
is a disjunction of nitely many literals (possibly none). A
formula is in conjunctive normal form (CNF) if it is a con-
junction of nitely many clauses (possibly none). As is com-
mon, whenever convenient, a clause is treated as a set of
literals and a CNF as a set of clauses. An assignment to
a set of variables Xis a function from Xto the constants
1 and 0, corresponding to true and false, respectively. An
assignment satises a formulai the formula evaluates to
1 under that assignment. The SAT problem is the problem
of deciding whether a CNF has a satisfying assignment.
Given a CNF , the MaxSAT problem consists in nding
an assignment to the variables of that maximizes the num-
ber of satised clauses (clauses that evaluates to 1 under the
assignment).
The partial MaxSAT problem is given as an input two
CNF formulas: the hard clauses Hand the soft clauses S.
A solution to such problem is an assignment that satises
all the clauses in Hand maximizes the number of satised
clauses inS. For instance, for the CNFs H=f(x_y)g
andS=f(:x);(:y)gthe assignment dened as(x) =
1;(y) = 0 is a solution satisfying one of the soft clauses. In
contrast, the assignment dened as(x) = 1;(y) = 1 is
not a solution since it does not satisfy any of the soft clauses.
MaxSAT also has a weighted variant, which is useful for
optimization with weights. A partial weighted MaxSAT con-
sists of hard clauses Hand weighted soft clauses S. A so-
lution to a partial weighted MaxSAT is an assignment that
satises all of the hard clauses and maximizes the number
of weights of soft clauses that are satised. We will denote
a weighted clause Cwith weight Was (W;C). For ex-
ample, if hard clauses are dened as H=f(x_y)gand
soft clauses as S=f(20 ;:x);(10 ;:y)g, the problem has
a single solution which is the assignment (x) = 0;(y) = 1.
Intuitively, the hard clauses prescribe that one of the xand
ymust be 1. At the same time, however, the soft clauses
force both of the variables to 0. Consequently, we must pick
one of the variables to be 1 and one of them to be 0 but
because the clause ( :x) has a larger weight, xis set to 0.
3. APPROACH
In our approach to the package upgradability problem,
we follow the popular techniques for translating dependen-
cies between packages into Boolean logic. Then, we use
(weighted) MaxSAT to express optimization criteria.
First we show how to decide whether a package upgrad-
ability problem has a solution or not can be encoded as a
SAT problem. Each package pis assigned a unique Boolean
variablevp, representing whether the package is installed in
the solution being constructed. The clauses capturing the
dependencies and conicts are generated according to the
following rules. If a package prequires one of the pack-
agesr1;:::;r n, generate the clause ( :vp_W
i21::nvri). If
a packagepconicts with a package o, generate the clause
(:vp_:vo). To encode the user request, we follow the fol-
lowing two rules. If a package pis requested to be installed,
generate the clause ( vp) and when it requested to be unin-
stalled, generate the clause ( :vp).
Once a CNF formula is constructed as described above, we
can invoke a SAT solver to decide whether the considered747upgradability problem has a solution or not. If it does, a
SAT solver also provides us with a satisfying assignment to
the constructed CNF. This assignment tells us which pack-
ages should be installed. In particular, a package pis in-
stalled if and only if the variable vpis assigned to the value 1.
As noted above, from the user point of view, it is not suf-
cient to just nd any solution to the package upgradability
problem but we want to nd a solution that is optimal with
respect to some criteria. We consider the encoding of the
optimization problem as (weighted) MaxSAT. For such, all
the clauses above are considered to be the hard clauses |
these must be satised by any solution. Soft clauses are used
to encode the criterion to be optimized.
For succinctness reasons, we will not describe all consid-
ered optimization criteria and their encodings; the reader is
referred to existing literature for further details [15]. For
illustration let us consider the criterion where we wish to
minimize the number of removed packages . A package is
considered removed if there is some version of the package
in the initial package conguration and there is no version
of that package in the nal conguration. For such we rst
collect the set of package names Ifor which there is some
package in the initial conguration. Then for each of these
namesn2 I we construct the soft clause (W
p:name =nvp).
Intuitively, this soft clause enforces that at least one ver-
sion of the package is installed. Recall that in MaxSAT, soft
clauses are not necessarily satised. However, a solution to a
MaxSAT guarantees that the largest possible number of soft
clauses is satised. Consequently, in this particular case, the
smallest possible number of packages will be removed.
To show how weighted MaxSAT is useful, consider the
criterion where we wish to minimize the total size of the
resulting package conguration. For such, for each package
pgenerate the soft clause ( p:size ;:vp). Such clause tries
to enforce that pisnotinstalled. However, more emphasis
is put on larger packages. Observe that if all packages have
the same weight, the problem is the same as minimizing
the total number of installed packages and then unweighted
MaxSAT is sucient.
To illustrate the above, consider the right-hand side of
Figure 1 under the assumption that we wish to install pack-
ageaand minimize the total number of installed packages.
The hard clauses are ( :va_vb), (:va_vc), (:vb_vf_vd),
(:vb_vd_ve), (:vf_:vd), and (va). Note that the last
clause represents the user request to install package a. The
soft clauses are (:va), (:vb), (:vc), (:vd), (:vf), and (:ve).
Observe that the soft clause ( :va) can never be satised in
a solution because of the hard clause ( va).
3.1 Boolean Lexicographic Optimization
So far we have discussed how to translate a single opti-
mization criterion into MaxSAT. In practice, however, mul-
tiple criteria might be required. For instance, the user may
wish to nd a package conguration that diers the least
from the existing conguration but at the same time it does
not occupy too much space on the disc. A natural way how
to combine multiple criteria is via the lexicographic ordering
where the individual criteria are given dierent priorities.
So for instance if we have two criteria C1andC2where
C1is given the higher priority, a total optimum must rst
optimizeC1and only then C2.
Since MaxSAT does not have native support for criteria
organized in a lexicographic order, we need a way to com-municate such order to the solver. A lexicographic order
can be encoded as an optimization of a single function by
given appropriate weights to the individual criteria [4,16]. In
practice, however, it has been observed that it is signicantly
more ecient to optimize for each of the criteria individu-
ally[17]. In particular, a solver begins by optimizing the
most important criterion, and xes the weight of the opti-
mum once it has found it. Then, it proceeds with optimizing
the second most important criterion, etc. This technique is
referred to as Boolean Lexicographic Optimization (BLO ).
More formally, package upgradability problem considered
as Boolean lexicographic optimization problem is represen-
ted as follows:
lexmax (f1;f2;:::;f k)
s. t.H(1)
where,fi, 1ikdenote the objective functions to op-
timize and Hdenotes the hard constraints. The function
f1has the highest priority, the function f2has the second
highest priority, etc.
Recent work on package management problems [17] pro-
poses solving (1) iteratively as follows:
maxfi
s. t.H
fj=Mj;j= 1;:::;i 1(2)
whereMjis the optimum value for the cost function fj,
given that preceding functions have already been optimized.
In recent years, dierent approaches for implementing (2)
have been proposed. A special place is occupied by meth-
ods based on SAT | namely, MaxSAT [4, 15, 17], Pseudo-
Boolean optimization [4, 17, 18], ASP [5, 19], etc. Among
these, the use of MaxSAT has been shown competitive with
alternative approaches. There have been developed a num-
ber of MaxSAT-based package upgradability solvers, e.g. in-
escp [20], PackUp [15].
The use of MaxSAT entails encoding each fias a set of
soft constraints i
S; this is done as described in the previous
section. At each iteration iit must be guaranteed that op-
timal values of the functions fj,j < i , which were already
found, are xed. Fixing the value of fjis done by introduc-
ing additional hard constraints CNF(fj=Mj), where CNFis
a function that constructs a CNF encoding of the constraint
fj=Mj. There are several ways to implement the function
CNF(fj=Mj), but their description is out of the scope of
this paper. The reader is referred to [15, 17] for further de-
tails. At each iteration, the MaxSAT problem to be solved
is characterized by a set of soft constraints i
Sand a set of
hard constraints i
H,H^Vi 1
j=1CNF(fj=Mj).
Algorithm 1 shows a general schema of the BLO algorithm
based on MaxSAT. Given a set of hard constraints Hand
a list of optimization functions fi,i2f1;:::;kg, it rst
makes an initial check whether the problem has a solution
(line 1). If yes, each function fiis iteratively optimized using
a MaxSAT oracle (line 5) and its optimal value is stored
inMi. The value Miis then xed (line 6) and the next
function to optimize is considered.
For complex package management problems, e.g. with mo-
re than a couple of functions to optimize, current BLO-based
solvers can require excessive run times. For instance, solving748Algorithm 1: General schema of BLO with MaxSAT
input :H,f1;f2;:::;f k
output : (M1;M 2;:::;M k) ifHis satisable,
false otherwise
1ifSAT(H) = falsethen // initial check
2 return false
3foreachi2f1;:::;kgdo
4i
S CNF(fi)
5Mi MaxSAT (H^i
S) // MaxSAT call
6H H^CNF(fi=Mi) // fixing value Mi
7return (M1;M 2;:::;M k)
a problem can take more than 300 seconds2, which is of
course inadmissible in real world applications. The situation
gets even worse for the case of weighted formulas.
A possible solution is to trade optimality for eciency.
One option is to use local search (e.g. [21]). Unfortunately,
our attempts were unsuccessful, in part because of the many
hard constraints that must be satised. As a result, we focus
on approaches that guarantee that the hard constraints are
still satised. For example, one can use specic MaxSAT al-
gorithms that rene upper bounds on the optimal value. By
doing so, after reaching a timeout one can stop the MaxSAT
solver and get some upper bound, which can be treated as
an approximation of the optimum value. However, the qual-
ity of the approximation done in such a way is typically low
(see Section 4 for experimental results). Moreover, usually
it is hard to even compute the rst upper bound. Thus, it is
not guaranteed that an instance will be solved within a given
timeout. This leads us to a hybrid approach to the pack-
age upgradability problem, which is based on computing a
subset-maximal set of satised soft constraints instead of
computing a cardinality-maximum set of satised soft con-
straints. The method is described in Section 3.2.
3.2 Approximation. Hybrid Approach
As noted above, using MaxSAT solvers for nding exact
(and even approximate) optima of individual optimization
functions for complex package upgradibility problems is of-
ten not ecient. This section is devoted to a pragmatic
approach to the considered problem, which performs very
well on the most of the practical instances and provides
high quality solutions. The idea of the method consists in
combination of the BLO strategy described in Section 3.1
with ecient approximate algorithms for solving MaxSAT
| namely, algorithms based on enumerating so-called min-
imal correction subsets (MCSes , e.g. see [22]).
Definition 1.Given a set of hard clauses Hand a set
of soft clauses S, a set of clauses  Sis called a minimal
correction subset if
1.H[Sn is satisable;
2.H[Sn( nfcg)is unsatisable for any clause c2 .
An MCS enables us to approximate MaxSAT. An MCS
set gives us a subset of the soft clauses whose removal
make the problem satisable. The smaller this set  is, the
2See values of the timeout used in the latest MISC compe-
titions [12].more soft clauses are satised and, thus, better approxima-
tion of MaxSAT is achieved. An important property of MCS
is that it cannot be made smaller by removing some clauses.
In contrast, MaxSAT unsatises the smallest possible num-
ber of soft clauses. Intuitively, MCSes correspond to local
optima and MaxSAT provides us with the global optimum .
Hence, the cost of an MCS gives us an upper bound on
the solution of the MaxSAT problem. For the case of un-
weighted formulas, the cost of an MCS is its size (the number
of clauses in it); for weighted formulas | the sum of weights
of all the clauses in the MCS. Recent work [23] proposes a
number of ecient algorithms for computing one and enu-
merating all MCSes of unsatisable CNF formulas. These
algorithms turned out to perform extremely well in practice.
There are dierent possible ways to apply computation of
MCSes of a MaxSAT formula to the package upgradability
problem. However, we mainly focus on the hybrid approach
represented in Algorithm 2 while other possibilities are men-
tioned in Section 3.3.
Assume that SAT,MaxSAT and BestApprox calls can han-
dle a given timeout and stop if it is exceeded. This can
be done in a manner of line 4 of Algorithm 2. Note that
Algorithm 2 is assumed to be able to asynchronously re-
spect given timeouts and halt the execution of MaxSAT and
BestApprox if necessary. Also assume that CurrentTime ,
CNF, and ComputeApprox calls can be done eciently and
do not take signicant computational time. Similar to the
BLO case, the arguments of Algorithm 2 are a set of hard
constraints Has well as a list of optimization functions
f1;:::;f k. Note that one of the goals of the approach is
to be able to stop and return a solution (or its approxi-
mation) within a reasonable timeout. Thus, the other two
arguments are the timeouts  teand  tafor the exact and
approximate parts of the algorithm, respectively. In order
to take into account the time used, Algorithm 2 rst assigns
current time to variable t0(line 1). Similar to the BLO case,
the algorithm checks whether the hard constraints are con-
sistent (see line 2). The lines 6{13 of the algorithm represent
an implementation of BLO that takes into account a time
limit. The algorithm tries to nd exact optimal values for
as many optimization functions as possible until it runs out
of time (see line 10).
The next phase of the algorithm is approximation of the
functions that were not optimized by BLO. The rst func-
tion to approximate is the last one that was timed out in
the BLO phase (see line 15 where jis assigned to be equal
toi). During this phase of the algorithm, the second time-
out value  tagets used. We assume that calling a function
BestApprox (see line 18) computes the cost M0
jof the best
MCS found by enumerating all MCSes of the j-th formula
withing the given timeout  ta. Observe that approximate
valueM0
jin some case can be equal to the exact optimum
Mj. VariableAkeeps the corresponding satisfying assign-
ment of the formula. With each new function that is suc-
cessfully approximated, value of Ais updated. When the
second timeout  tais reached, assignment Ais then used
to compute approximate values for the functions that were
not optimized nor approximated before (see line 25). Recall
that calling function ComputeApprox is assumed not to take
signicant time. As a result Algorithm 2 produces a vector
of found values ( M1;:::;M i 1;M0
i;:::;M0
k), where each Mi
is an exact optimal value while M0
jcan be both exact and
approximate value of the corresponding function.749Algorithm 2: Hybrid approach to BLO
input :H,f1;f2;:::;f k, te, and  ta
1t0 CurrentTime
2ifSAT(H;t0;te) = falsethen // initial check
3 return false
4else if CurrentTime t0>tethen
5 return false
6i 1
7whileikdo
8i
S CNF(fi)
9Mi MaxSAT (H^i
S;t0;te) // MaxSAT call
10 ifCurrentTime t0>tethen
11 break
12H H^CNF(fi=Mi) // fixing value Mi
13i i+ 1
14t0 CurrentTime
15j i
16whilejkdo
17j
S CNF(fj)
18 (A;M0
j) BestApprox (H^j
S;t0;ta)
19 ifCurrentTime t0>tathen
20 break
21H H^CNF(fj=M0
j) // fixing value M0
j
22j j+ 1
23whilejkdo
24j
S CNF(fj)
25M0
j ComputeApprox (j
S;A)
26j j+ 1
27return (M1;:::;M i 1;M0
i;:::;M0
k)
3.3 Other Approximation Strategies
In this section we list and briey describe other possible
ways of doing approximation in the package upgradability
problem. The simplest option would be to enumerate MC-
Ses (or compute one MCS) for a CNF-encoding of the rst
optimization function within a given timeout  ta. After
that, approximate values of each function fi,i > 1, can
be computed by a ComputeApprox call in a way similar to
line 25 of Algorithm 2. Another option is to use the approach
described in Section 3.2 but without the exact part, i.e. it
would approximate individually as many functions as possi-
ble until the timeout is reached. Another alternative is to
divide the value of timeout  tainto several timeouts, each
can be used for approximating one function. Here values of
dierent timeouts are not necessarily the same | instead,
one can use more time for approximating the most relevant
criteria.
And nally, one could construct a weighted MaxSAT for-
mula comprising all the optimization functions. As noted
above, in practice using a MaxSAT approach for such a
complex optimization problem is proved to be not ecient.
However, instead of calling a MaxSAT solver, one can, again,
run an MCS enumerator. Each MCS found for the complex
formula would approximate all the functions of the original
problem.Although there are many alternative ways of obtaining
approximate solutions of the package upgradability problem
that are based on computing MCSes, this article emphasizes
the hybrid approach described in Section 3.2. The strength
of the hybrid approach is that if it ispossible to nd quickly
the exact solution, it is returned. However, for computa-
tionally hard problem instances, the approximate approach
enables us to nd a good approximate solution. Overall,
the hybrid approach gives us the best of the two worlds, the
exact and the approximate. Nevertheless, alternative ap-
proaches are also interesting from the user perspective and
we return to this subject in Section 6.
4. EXPERIMENTAL EV ALUATION
Experiments described in this section were performed on
a large set of benchmarks from the MANCOOSI Interna-
tional Solver Competition 20123(MISC-2012). The experi-
mental results were obtained on an Intel Xeon 5160 3GHz,
with 4GB of memory, and running Fedora Linux operating
system. The experiments were made with a 800 seconds
time limit and a 2GB memory limit.
4.1 Experimental Methodology
The hybrid algorithm (Algorithm 2) was implemented on
top of the tool PackUp [15]. PackUp provides a framework
for solving the upgradability problem and its source code is
available online under the GNU license [24]. The developed
prototype is referred to as PackUpHyb . It accepts problem
instances in the Common Upgradability Description Format
(CUDF), which is a standard format of package description
proposed within the framework of the MANCOOSI project.4
The underlying SAT solver of the PackUpHyb solver is Min-
iSat 2.2 [25].
PackUpHyb has three general modes of operation. The
rst mode, called exact mode , makes use of a MaxSAT al-
gorithm and does lexicographic optimization by nding the
exact optimum for each optimization criterion of the pack-
age upgradability problem, as described in Section 3.1. The
second mode, implements the hybrid approach described in
Section 3.2, namely, Algorithm 2. Recall that the hybrid
mode is parameterized by two dierent timeouts. The rst
timeout limits the time of the exact solving while the second
one limits the time of the approximate solving. If the exact
solver is not able to solve a problem within its timeout, it
stops and the approximation process starts. The approxi-
mation is made for the rst criterion that was not optimized
by the exact solver.
The third mode is aimed at emulating the tool P2 [4],
which is a well-known package dependency solver currently
used in Eclipse IDE.5Similarly to P2, this mode of oper-
ation (hereinafter, we call it P2 mode ) hinges on the idea
of lexicographic optimization and, hence, optimizes all the
criteria iteratively, as described in Section 3.1. Moreover, as
an underlying solver intended for optimizing a criterion we
use a pseudo-Boolean solver EclipseP2 , which is a part of
3http://www.mancoosi.org/misc-2012/
4CUDF was developed in the MANCOOSI as a package de-
scription language with rigorous semantics and thus more
amenable to scientic analysis. However, the language is as
powerful as the package-description languages used in the
linux distributions.
5http://wiki.eclipse.org/P27500 100 200 300 400 500 600 700 800
instances1101001000CPU time (s)exact mode
800 sec P2 mode
10 sec P2 mode
5+5 sec hybrid mode(a) Performance of dierent modes of PackUpHyb
0 1 10 100 1000
exact mode011010010005+5 sec hybrid mode
(b) Exact approach vs. Hybrid approach
Figure 2: Performance comparison
the Sat4j library and the basis of P26. In case the EclipseP2
solver's execution process has timed out, it can produce an
approximate solution of the problem. This enabled us to or-
ganize the comparison of the approximation quality between
solutions found by the hybrid mode and the P2 mode.
The goal of the performed experiments is to show the ad-
vantages of the pragmatic approach proposed in Section 3
and implemented as the hybrid mode of PackUpHyb over
the existing exact solver that participated in a series of the
MISC competitions. First, we demonstrate the number of
instances that can be solved by the considered approaches.
Next, we compare the quality of the approximation produced
by the P2 mode and the approach proposed in Section 3.
4.2 Experimental Material
The MISC-2012 competition has several benchmark cate-
gories, each is intended to emulate a real situation that can
6Note that there is a specic variant of the P2 solver |
P2CUDF | intended for solving package dependency prob-
lems given in the CUDF format. However, it is not presented
in our experiments here. The reason is that for all considered
instances it performs much worse than our mode of Pack-
UpHyb that emulates P2. A possible explanation of this is
that the SAT solver, which P2CUDF is based on, does not
use the well-known watched literals and VSIDS heuristics
(due to patent reasons).Table 1: Number of solved instances
Exact mode hybrid mode P2 modeTimeout5 282 282 126
10 365 840 198
800 584 840 684
not solved 256 | 156
occur if a user makes a request to a package management
system. Our experiments include all these categories. Each
benchmark category represents a problem of optimizing a
number of optimization criteria. The performance of the ex-
act approach diers for dierent benchmark categories and
depends on the optimization criteria used. There are 120
various CUDF les in the competition. Thus, for 7 cate-
gories the total number of package upgradability instances
to solve is 840. Note that the size of the package universe
(taking into accout unique package names, but not package
versions) in the considered benchmarks varies from 27710
to 59094 with an average value 35275 :5, which is close to
the real repository size (around 40000 packages) in Debian-
based Linux distributions. Therefore, the obtained perfor-
mance results should mimic the behavior of the solvers on
real world problem instances.
4.3 Comparing Performance
Figure 2a shows a cactus plot illustrating the performance
of the considered modes of operation of the PackUpHyb pro-
totype. Here it is convenient to use a logarithmic scale for
the CPU time.
A typical user of a package management system is inter-
ested in having an answer to his request shortly. Therefore,
it is essential for a package upgradability solver to be able to
solve as many instances as possible in a short period of time.
For this reason, we separately consider a 5 seconds timeout.
In 5 seconds the exact and hybrid modes of PackUpHyb
perform identically and are able to solve 282 instances (this
is around 33.5% of the total 840 instances). Given the 5
seconds timeout, the P2 mode can cope only with 126 in-
stances.
Considering a 10 seconds timeout, the exact mode can nd
a solution for 365 instances (including the 282 solved in 5
seconds) while the hybrid mode solves all 840 instances. Re-
call that the hybrid mode starts doing the approximation by
enumerating local optima for the problem within 5 seconds
and choosing the best of them. An interesting observation
is that by doing this it is still able to nd exact solutions (it
does not reach the timeout) for 71 instances. The P2 mode
can solve only 198 instances (around 23.5%) in 10 seconds.
Finally observe that for 256 instances (around 30.5%) the
exact solver does not succeed in nding a solution within
800 seconds. Figure 2b shows a scatter plot that compares
the runtime of the exact and hybrid modes of PackUpHyb.
Given the 800 timeout, the P2 mode cannot nd a solution
(even approximate) of 156 instances (18.5%). Overall num-
bers of solved instances for dierent timeouts are represented
in Table 1.
4.4 Approximation Quality
A solution of a problem instance is a tuple of integer num-
bers, each represents a value found for one of the optimiza-751Table 2: Quality of the approximation by the hybrid
approach (%)
Criterion index
1 2 3 4 5Category of benchmarksparanoidavg. 0 2      
max. 0 82.7      
paranoid-sizeavg. 0 2.1 -58.8    
max. 0 27.2 63.3    
embeddedavg. 2.4 0.9      
max. 27.2 15.3      
slowlinkavg. 10.5 482.5 -0.1 6.6  
max. 317 6614 9.3 178.6  
upgradeavg. 0 0 0 0  
max. 0 0 0 0  
dist-upgradeavg. 0 0 0 0  
max. 0 0 0 0  
trendy-sizeavg. 0 2.6 38.7 0.3 -51
max. 0 43.7 84.1 100 60
tion criteria. The quality of the approximation for a par-
ticular criterion is represented by a value of the approxima-
tion error, i.e. value(va ve)
ve100%, where veis the exact
optimum value and vais its approximated value. For in-
stance, given tuples (10 ;20;30;40) and (10 ;25;15;40) that
are an exact solution and an approximate solution, respec-
tively, the approximation quality can be represented as a
tuple (0%;25%; 50%;0%). Note that due to the properties
of lexicographic ordering there are situations when the ap-
proximate solution for a criterion jis better than the exact
one (e.g. see j= 3 in the previous example), but only if
there is a criterion i,i<j , such that its approximate value
is worse than the exact value.
Also note that optimization criteria in the lexicographic
optimization are sorted by their priority: the value of the
rst criteria is the most important to optimize while the
last criterion is the least signicant. Hence, it is preferable
to have a smaller approximation error for the rst criterion
that is optimized.
Although the hybrid approach is able to solve all 840 in-
stances, we can evaluate the approximation quality only for
instances that are solved by the exact solver7. Also note
that some of the instances might not have a solution. Thus,
in this section we consider not 840 instances but only 525
that are solved by the exact approach and have a solution.
The number of optimization criteria vary from 2 to 5 for
dierent categories of benchmarks. In our comparison of ap-
proximation errors for the hybrid and P2 modes we consider
each optimization level separately. Since all benchmark cat-
egories have at least 2 optimization criteria, we consider 525
instances for the rst two optimization levels. There are
386, 337 and 150 instances for the 3rd, 4th and 5th opti-
mization levels, respectively. Cactus plots corresponding to
approximation errors for optimization levels 1, 2, 3, 4, and
5 are shown in Figure 4a, Figure 4b, Figure 4c, Figure 4d,
7Since initially we did not aim at analyzing the approxima-
tion quality, the exact mode of the solver was run for 800
seconds only. However, getting more representative analysis
of the approximation quality (with a greater value of the
timeout and with the use of a computing cluster) will be an
interesting topic of future research.
0 10 20 30 40
instance051015202530approximation error for crit. 2 (%)
0 10 20 30 40
instance-100-80-60-40-20020406080approximation error for crit. 3 (%)Figure 3: Quality of the approximation for the paranoid-
size benchmarks category by the hybrid approach (in-
stances are synchronized)
and Figure 4e, respectively. Again, the logarithmic scale is
used in the plots.
As one can see in the presented plots, not only the number
of instances solved by the P2 mode is signicantly smaller
than the number of instances solved by the hybrid approach,
but also the approximation error of the hybrid approach is
orders of magnitude better than the approximation error
of the P2 mode. Observe that this holds for both 10 and
800 seconds timeout for the P2 mode. Since the P2 mode
solves fewer instances, we do not compare average approxi-
mation errors for the approaches. Instead, detailed informa-
tion about the approximation error for the hybrid approach
is shown in Table 2.
As an example, a detailed graph illustrating the approxi-
mation error for the paranoid-size category is shown in Fig-
ure 3. There are 49 instances in the paranoid-size bench-
marks category and the number of optimization criteria is 3.
Observe that the rst optimization level is not presented in
the gure since for all 49 instances an exact solution for the
rst level is found. Note that instances in the remaining
2nd and 3rd levels are synchronized in the gure so that one
can see the quality of the full approximation for dierent
instances. The maximal approximation error for the second
criterion is 27 :2% while the average is 2 :1%. Values for the
third optimization criterion are 63 :3% and 58:8%, respec-
tively. Observe that the negativity of the average value is
caused by many instances for which the approximate solu-
tion is better than the exact one.7520 100 200 300 400 500
instances-10110100approximation error for crit. 1 (%)5+5 sec hybrid mode
800 sec P2 mode
10 sec P2 mode(a) Level 1
0 100 200 300 400 500
instances-101101001000approximation error for crit. 2 (%)5+5 sec hybrid mode
800 sec P2 mode
10 sec P2 mode (b) Level 2
0 50 100 150 200 250 300 350
instances-100-10-101101001000approximation error for crit. 3 (%)5+5 sec hybrid mode
800 sec P2 mode
10 sec P2 mode
(c) Level 3
0 50 100 150 200 250 300
instances-10-101101001000approximation error for crit. 4 (%)5+5 sec hybrid mode
800 sec P2 mode
10 sec P2 mode (d) Level 4
0 20 40 60 80 100 120 140
instances-100-10-101101001000approximation error for crit. 5 (%)5+5 sec hybrid mode
800 sec P2 mode
10 sec P2 mode
(e) Level 5
Figure 4: Comparison of approximation errors for the hybrid and P2 modes7535. RELATED WORK
The importance of SAT-based approaches to package man-
agement has been acknowledged in recent years [2{4,15,18,
20,26]. Original work mapped the problem into a Constraint
Programming formulation [3]. OPIUM [2] proposed opti-
mization approaches for achieving better results, which are
based on pseudo-Boolean optimization (PBO). Related work
for the Eclipse IDE project includes [4]. Recent solutions,
which allow for specifying a number of optimization crite-
ria, are based on lexicographic optimization. A number of
approaches have been proposed, which exploit a number of
SAT-related technologies. These include inescp [20], Apt-
PBO [18], PackUP [15], aspcud [5], and newer versions of
P2 [4]. Of these, P2 [4] is the only tool that has been de-
ployed and is being used by millions of users. Despite the
importance of recent work towards added modelling exi-
bility and better quality solutions, computation of the opti-
mum solution is unfeasible, because of the large required run
times. As a result, deployed solutions return any solution
identied within a short timeout, e.g. this is the case with
P2. Furthermore, the importance of additional analyzes of
software package repositories is illustrated by [26].
6. CONCLUSIONS AND FUTURE WORK
Managing package repositories poses a number of chal-
lenges. Indeed, it is not uncommon to encounter repositories
with dozens of thousands of packages. Each of these pack-
ages represents a software artifact or component. And, each
of these components may interact with other components.
Consequently, when a user wishes to add a package to his or
hers current conguration of packages, it must be done so
with care. Namely, a package must not be installed if it con-
icts with one of the other present packages and along with
the package, all required packages must be installed. This,
on its own, causes installation or uninstallation of packages
to be a nontrivial computational task. This task becomes
even more computationally challenging once we want to re-
spect user preferences over the resulting package congura-
tion. For instance, a typical user requires that the resulting
package conguration diers from the original conguration
as least as possible.
Altogether, package managers need to address two types
of objectives: 1) Respect the requirements and conicts of
the packages. 2) Try to optimize for user criteria as best
as they can. Recently, a number of approaches for exact
optimization of user criteria have been developed. However,
such approaches do not have guaranteed runtime. Indeed,
it is not uncommon for a solver to need hundreds of seconds
to nd an optimal solution. Unfortunately, users are not
willing to wait that long.
This paper proposes a technique of how to enable an exact
solver to provide good approximate solutions whenever it is
running out of time. The proposed technique hinges on the
concept of minimal correction sets (MCS) . Intuitively, an
MCS provides us with a local optimum, i.e. a better solution
might exist but larger change to the package conguration
would be required. Computationally, computing MCSes is
far more advantageous than computing the global optimum.
In practice this means that an MCS can be computed within
seconds for instances where the global optimum is not found
for hundreds of seconds.Using MCSes contrasts with the approximation approach-
es used up to date. There, a complete solver would simply
output the best solution that it has found so far. Such ap-
proach does not give any guarantee, while in MCSes we have
the guarantee of local optimality. This advantage is indeed
conrmed by our experimental evaluation, which shows that
using the approximation based on MCSes enables us to solve
a larger number of instances and with better proximity to
the optimum than the \best so far" method.
This paper implements and evaluates a hybrid approach ,
which uses a MaxSAT solver for computing exact optima
and MCSes for approximation. The MaxSAT solver is used
for a given period of time to optimize the most important
criteria and then approximation is used. This enables us to
give a response within 10 seconds. Further, these responses
do not deviate too much from the optimum.
It should be stressed that the proposed technique is not
limited to the use of MaxSAT solvers. Any existing exact
solver can be combined with our approximation technique
in the same way. As such, the technique enables an exact
solver to provide responses of good quality even in very short
timeouts.
The use of an MCSes opens a number of avenues for future
work. Several alternative way to integrate the approxima-
tion where already outlined Section 3.3, e.g. the total time-
out can be distributed dierently between the exact and ap-
proximate calculation. Beyond these alternatives, other ap-
plications can be envisioned. For instance, one could start
enumerating MCSes and order them by a criterion dier-
ent than a lexicographic one. This would allow considering
for instance criteria like leximin [27]. Leximin is extremely
interesting from the user perspective because it does not
require the user to pick an order on the dierent criteria
considered. And indeed, it is often hard for the user to pri-
oritize one criterion over another. Instead, the user wants
all these criteria to be all \good at the same time", which
is made more precise by the leximin order. To our best
knowledge, there is no publicly available package upgrad-
ability tool supporting leximin or any similar order. It is
also expected that computing the optimum in the leximin
order will be computationally much more dicult than for
the lexicographic order. Yet, the MCS technique enables
integrating any criterion at low computational cost.
There are also several topics of interest not covered by this
paper. Although the P2 solver is heavily used in practice
for the Eclipse IDE package management system [6], which
maintains dozens of thousands of packages, there are other
state-of-the-art approaches for package dependency solving
(e.g. OPIUM [2], Aspcud [28]). Thus, an interesting subject
of future work is the comparison of the developed method
to such approaches as well as to the known software tools
widely used by millions of Linux users every day, namely,
APT for Debian-based distributions [29] and ZYpp for open-
SUSE [30]. ZYpp, which is based on a modern SAT solver,
is one of the rst success stories of applying SAT technology
to package management in popular Linux distributions.
7. ACKNOWLEDGMENTS
This work is partially supported by SFI PI grant BEACON
(09/IN.1/I2618), FCT grants ATTEST (CMU-PT/ELE/00-
09/2009) and POLARIS (PTDC/EIA-CCO/123051/2010),
and INESC-ID's multiannual PIDDAC funding PEst-OE-
/EEI/LA0021/2013.7548. REFERENCES
[1] R. Di Cosmo, B. Durak, X. Leroy, F. Mancinelli, and
J. Vouillon, \Maintaining large software distributions:
New challenges from the FOSS era," in Proceedings of
the FRCSS '06 workshop , ser. EASST Newsletter,
vol. 12. Vienna, Autriche: EASST, 2006, pp. 7{20.
[2] C. Tucker, D. Shuelton, R. Jhala, and S. Lerner,
\OPIUM: Optimal package install/uninstall manager,"
in29th International Conference on Software
Engineering, ICSE , 2007, pp. 178{188.
[3] F. Mancinelli, J. Boender, R. Di Cosmo, J. Vouillon,
B. Durak, X. Leroy, and R. Treinen, \Managing the
complexity of large free and open source
package-based software distributions," in ASE. IEEE
Computer Society, 2006, pp. 199{208.
[4] D. Le Berre and P. Rapicault, \Dependency
management for the Eclipse ecosystem: Eclipse p2,
metadata and resolution," in Proceedings of the 1st
international workshop on Open component
ecosystems , ser. IWOCE '09. New York, NY, USA:
ACM, 2009, pp. 21{30. [Online]. Available:
http://doi.acm.org/10.1145/1595800.1595805
[5] M. Gebser, R. Kaminski, and T. Schaub, \aspcud: A
Linux package conguration tool based on answer set
programming," in LoCoCo , ser. EPTCS, C. Drescher,
I. Lynce, and R. Treinen, Eds., vol. 65, 2011, pp.
12{25.
[6] \Eclipse project," http://www.eclipse.org/.
[7] C. Hoover, \A methodology for determining response
time baselines," in Int. CMG Conference . Computer
Measurement Group, 2006, pp. 85{94.
[8] K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak,
and A. S. Peterson, \Feature-oriented domain analysis
(FODA) feasibility study," Carnegie Mellon University,
Nov., Tech. Rep. CMU/SEI-90-TR-021, 1990.
[9] E. C. Bailey, \Maximum RPM: Taking the Red Hat
package manager to the limit,"
http://www.rpm.org/max-rpm.
[10] J. R. O. Aoki, \Debian new maintainers' guide," http:
//www.debian.org/doc/devel-manuals#maint-guide.
[11] R. Treinen and S. Zacchiroli, \Common upgradeability
description format (CUDF) 2.0," MANCOOSI, Tech.
Rep. 003, Nov. 2009,
http://www.mancoosi.org/reports/tr3.pdf.
[12] \Mancoosi international solver competition,"
http://www.mancoosi.org/misc.
[13] \Mancoosi software,"
http://www.mancoosi.org/software.
[14] C. M. Li and F. Many a, \MaxSAT, hard and soft
constraints," in Handbook of Satisability , ser.
Frontiers in Articial Intelligence and Applications,
A. Biere, M. Heule, H. van Maaren, and T. Walsh,
Eds. IOS Press, 2009, vol. 185, pp. 613{631.
[15] M. Janota, I. Lynce, V. M. Manquinho, and
J. Marques-Silva, \PackUp: Tools for package
upgradability solving," JSAT , vol. 8, no. 1/2, pp.
89{94, 2012.
[16] M. Ehrgott, Multicriteria Optimization (2. ed.) .Springer, 2005.
[17] J. Marques-Silva, J. Argelich, A. Gra ca, and I. Lynce,
\Boolean lexicographic optimization: algorithms &
applications," Ann. Math. Artif. Intell. , vol. 62, no.
3-4, pp. 317{343, 2011.
[18] P. Trezentos, I. Lynce, and A. L. Oliveira, \Apt-pbo:
solving the software dependency problem using
pseudo-boolean optimization," in ASE, C. Pecheur,
J. Andrews, and E. D. Nitto, Eds. ACM, 2010, pp.
427{436.
[19] M. Gebser, R. Kaminski, B. Kaufmann, and
T. Schaub, \Multi-criteria optimization in answer set
programming," in ICLP (Technical Communications) ,
ser. LIPIcs, J. P. Gallagher and M. Gelfond, Eds.,
vol. 11. Schloss Dagstuhl - Leibniz-Zentrum fuer
Informatik, 2011, pp. 1{10.
[20] J. Argelich, D. Le Berre, I. Lynce, J. Marques-Silva,
and P. Rapicault, \Solving linux upgradeability
problems using Boolean optimization," in LoCoCo ,
ser. EPTCS, I. Lynce and R. Treinen, Eds., vol. 29,
2010, pp. 11{22.
[21] K. Smyth, H. H. Hoos, and T. St utzle, \Iterated
robust tabu search for MAX-SAT," in Canadian
Conference on AI , ser. Lecture Notes in Computer
Science, Y. Xiang and B. Chaib-draa, Eds., vol. 2671.
Springer, 2003, pp. 129{144.
[22] M. H. Liton and K. A. Sakallah, \Algorithms for
computing minimal unsatisable subsets of
constraints," J. Autom. Reasoning , vol. 40, no. 1, pp.
1{33, 2008.
[23] J. Marques-Silva, F. Heras, M. Janota, A. Previti, and
A. Belov, \On computing minimal correction subsets,"
inIJCAI , F. Rossi, Ed. IJCAI/AAAI, 2013.
[24] \Package upgradability problem solver,"
http://sat.inesc-id.pt/~mikolas/sw/packup/.
[25] N. E en and N. S orensson, \An Extensible SAT-solver,"
inTheory and Applications of Satisability Testing ,
2003, pp. 502{518.
[26] J. Vouillon and R. Di Cosmo, \Broken sets in software
repository evolution," in ICSE , D. Notkin, B. H. C.
Cheng, and K. Pohl, Eds. IEEE / ACM, 2013, pp.
412{421.
[27] S. Bouveret and M. Lema^ tre, \Computing
leximin-optimal solutions in constraint networks,"
Artif. Intell. , vol. 173, no. 2, pp. 343{364, 2009.
[28] M. Gebser, R. Kaminski, and T. Schaub, \aspcud: A
Linux package conguration tool based on answer set
programming," in Proceedings of the Second
International Workshop on Logics for Component
Conguration (LoCoCo'11) , ser. Electronic
Proceedings in Theoretical Computer Science
(EPTCS), C. Drescher, I. Lynce, and R. Treinen,
Eds., vol. 65, 2011, pp. 12{25.
[29] \Apt { Debian Wiki," https://wiki.debian.org/Apt,
accessed: 2014-02-27.
[30] \Portal:Libzypp { openSUSE,"
http://en.opensuse.org/Portal:Libzypp, accessed:
2014-02-27.755