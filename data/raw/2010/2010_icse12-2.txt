StaticDetectionof ResourceContentionProblemsin Server -SideScripts
Yunhui Zheng Xiangyu Zhang
Department of Computer Science
Purdue University
{zheng16,xyzhang }@cs.purdue.edu
Abstract—With modern multi-core architectures, web ap-
plications are usually conﬁgured to serve multiple request s
simultaneouslybyspawningmultipleinstances.Theseinst ances
may access the same external resources such as database tabl es
and ﬁles. Such contentions may become severe during peak
time, leading to violations of atomic business logic. In thi s
paper, we propose a novel static analysis that detects atomi city
violations of external operations for server side scripts. The
analysis differs from traditional atomicity violation det ection
techniques by focusing on external resources instead of sha red
memory. It consists of three components. The ﬁrst one is an
interprocedural and path-sensitive resource identity ana lysis
that determines whether multiple operations access the sam e
external resource, which is critical to identifying conten tions.
The second component infers pairs of external operations th at
should be executed atomically. Finally, violations are det ected
by reasoning about serializability of interleaved atomic p airs.
Experimental results show that the analysis is highly effec tive
in detecting atomicity violations in real-world web apps.
Keywords -php; resource contention; static analysis; con-
straint solving
I. INTRODUCTION
Web is becoming an important computation platform.
Many daily tasks such as online shopping, social network-
ing, data storage, and document processing are carried out
by web applications (apps). An important trend of web
apps is to leverage modern multi-/many-core architectures .
However, the incompatibility between the sequential pro-
gramming model of server side scripts and the concurrent
execution model conﬁgured in servers to leverage multiple
coresmay lead to harmfulcontentionson externalresources .
Particularly, for design simplicity, popular server side
scripting languages such as PHP do not support threading.
As a result, web app developers tend to think that they are
performing sequential programming, and they are at a safe
distance from troubles caused by concurrency. However, it
is not true under the most popular LAMP (Linux, Apache,
MySQL and PHP) web app environment, in which Apache
is the web server and server side scripting support is
provided through PHP. PHP scripts communicate with a
database system (e.g. MySQL) or the ﬁle system to provide
services. To optimize server performance, Apache is usuall y
conﬁgured to run in the MPM (Multi-Processing Modules)
mode,which allowsmultipleinstancesof a serverside scrip t
being spawned, each serving an independent client request.
Although these instances do not share variables in memoryas variables are by-default local to a thread, they do share
external resources such as database tables and ﬁles. Such
sharings nonetheless cause race conditions.
Many web application failures are essentially due to
such race conditions. For example, in ProductCart[1] and
OpenCart[2], they led to products being over-sold, resulti ng
in back-orders. In Drupal[3] and Joolam BibTeX[4], they
caused critical runtime exceptions and ﬁle corruptions.
Unfortunately, there are mis-perceptions that induce de-
velopers to overlook such problems. One of such is that
race conditions on external resources are well guarded by
the internal protection in the database engine and the ﬁle
system, otherwise any regular sequential programs would
be vulnerable as multiple instances of the same program
may share the same resources. The observation is that while
it is unlikely that multiple instances of a regular sequenti al
program are running simultaneously, the likelihood is much
higher for a web app as it aims to deliver the same service
to many users. In other words, we argue that the problem is
substantially exacerbated in the context of web apps.
Existing solutions for detecting concurrency errors fall
short. Most race detection [27], [24], [22], [23] and atom-
icity violation detection [14], [19], [26], [18] technique s
rely on analyzing synchronization primitives. However suc h
primitives are simply not provided by server side scripting
languages. Most existing techniques work by reasoning
about the interleavings of accesses from different threads
on shared memory. However, scripts usually do not share
memory. Sharing is on external resources instead. To reason
about the effect of interleaving external resource accesse s,
one needs to model these external operations, e.g. queries
to the database engine. Furthermore,these operationscann ot
be simply modeled as reads or writes on shared objects. For
example, the DELETE and INSERT database queries have
more complex semantics that cannot be described as simple
reads/writes. Identifying the resources being accessed al so
poses a unique challenge as they are usually denoted in the
program as concatenations of strings and variables. One has
to reason about the equivalence of such representations to
determine if the same resources are being accessed.
There has been some recent work speciﬁcally focusing
on concurrency errors in web apps. In [37], researchers
proposed a technique to detect race conditions caused by
the asynchronous AJAX requests. The technique is unfortu-nately not applicable as it only works on client side through
JavaScript and does not reason about external resources.
A dynamic analysis was proposed to detect race condi-
tions caused by interactions between a web app and the
database [25]. It collects SQL query traces and checks
whether a speciﬁc interleaving pattern occurs in traces.
It demands a proper input and a proper interleaving to
expose a bug, which are in general hard to acquire due
to non-determinism. The technique also completely neglect s
program semantics, leading to false positives.
Inthispaper,weproposeawholeprograminterprocedural
static analysis that detects atomicity violations regardi ng
external resources in PHP scripts. The overview of our
technique is presented in Fig. 1. It takes the PHP code of a
web app and translates it to C. The C code is analyzed in
three phases. The ﬁrst phase is the resource identity analys is
that determineswhether multiple operationsaccess the sam e
externalresource,whichiscriticaltoidentifyingconten tions.
The second phase infers pairs of external operations that
should be executed atomically. In phase three, violations
are detected by reasoning about serializability of interle aved
atomic pairs.
We make the following contributions.
•We develop a context- and path-sensitive interproce-
dural static analysis to automatically detect atomicity
violations on shared external resources in PHP code.
•We develop the resource identity analysis , a technique
toreasonabouttheequalityofresourcesbeingaccessed
by external operations. It is interprocedural and path
sensitive, leveraging a SMT solver.
•We propose a novel way of statically inferring atomic
regions in PHP code, which avoids demanding the
developer to annotate such regions, or guessing them
fromsynchronizationprimitivesordynamictraces[14],
[19], [34]. It leverages the observation that atomicity
properties in PHP programs are more amenable for
automatic inference compared to general concurrent
programs in C++ and Java, as PHP developers usually
follow a sequential programming paradigm.
•We develop expressive abstractions for external opera-
tions. They go beyond the read and write abstractions
for shared memory accesses. We deﬁne atomicity vio-
lations based on these abstractions.
•We evaluate the technique on real world web apps. The
results show that it is highly effective, detecting 113
real bugs. Some of them have ﬁnancial impacts.
II. MOTIVATING EXAMPLES
A. Atomicity Violation in OpenCart 1.4.9.4
We ﬁrst use a bug in a recent version of OpenCart
(v1.4.9.4) to motivate our technique. OpenCart is an open
source shopping cart application. It was reviewed as one
of the best open source e-commerce platforms [5] in 2010.
A user of OpenCart can be either a normal user or an@ catalog/controller/checkout/confirm.php 
005  public function index () {
201 1$tmp_coupon = $this->session->data['coupon'];
201 2$coupon = getCoupon($tmp_coupon);
203    if (  $coupon ) {
204       $data['coupon_id']  =  $coupon['coupon_id'] ;
205    } else {
206       $data['coupon_id'] = 0;
207    }
216    $this->session->data['order_id'] = create(  $dat a );
439  }
@ catalog/model/checkout/coupon.php 
003  public function getCoupon ($coupon) {
006     $coupon_query = mysql_query("SELECT * FROM coupon  c … 
                WHERE …   c.code =” . $coupon . “AND …”  
013 1$x= $coupon_query->row[‘coupon_id’]
013 2$sql = "SELECT COUNT(*) AS total FROM order WHERE…” 
                       . “coupon_id = " . $x ;
013 3$coupon_redeem_query = mysql_query( $sql );
$total = $coupon_redeem_query->row['total'];
           /* coupon validation */ 
015     if ( ...  && $total < $allowed) 
059          $coupon_data = $coupon_query;
076     return $coupon_data ;
078  }
@ catalog/model/checkout/order.php 
058  public function create (  $data ) {
/* create an order using a valid coupon*/ 
070 1      $y=$data[‘coupon_id’]
070 2$sql = "INSERT INTO  order  SET...coupon_id = " .$y…; 
070 3mysql_query( $sql );
093  }
Figure 2. Code snippet from OpenCart v1.4.9.4. The two recta ngled
database queries may not execute atomically while they shou ld. The update
query is (transitively) dependent on the select query throu gh the underlined
variables. For readability, we normalize the code snippet b y breaking some
statements into sub-statements, described by the subscrip ts.
administrator. The administrator can add, modify or delete
products and coupons. A normal user can place orders
with the option of applying coupons. The problem to be
demonstrated allows illegal coupon usage. In particular,
when multiple usersplace ordersconcurrently,whichis ver y
likely to happen in peak time, a coupon can be applied for
arbitrary number of times, ignoring its use limit.
Fig. 2 shows the relevant code snippet. Function index()
inconﬁrm.php validates a coupon by calling getCoupon() at
line201and then places the order by calling create().
Incoupon.php , function getCoupon () dispatches two
queries at lines 6 and 13. The ﬁrst query is to retrieve
the coupon information from database. The second query
is to determine the number of coupon uses by accessing
tableorder. If the coupon has reached its limit, variable
$coupondataholds the FALSEvalue at line 76, which
is returned to method index(), indicating expiration of the
coupon. Otherwise, the coupon details such as discount are
loaded to $coupondataand returned. Finally, at line 70 in
functioncreate()inorder.php ,anorderisplacedbyinserting
a record to table order, with the same coupon id.
The bug manifests itself when multiple users apply the
same coupon in the mean time. To simplify discussion,static atomic 
property inference serialibility 
analysis resource identity 
analysis operations on the 
same resource PHP 
code atomic 
pairs PHP to C C code violations 
Figure 1. Overview of our technique.
Order Request 1Handler 
1.006  $sql = “SELECT ...” 
1.013  $coupon_redeem_query = mysql($sql); 
$total = 
$coupon_redeem_query->row[‘total’]; 
// $total = 0 
…… 
1.015  if ( … && $total < $allowed) 
// $allowed = 1, coupon valid 
1.059  $coupon_data= $coupon_query; 
…… 
1.070 2$sql = “INSERT…” ; 
1.070 3mysql_query($sql); Order Request 2Handler 
2.006  $sql = “SELECT ...” 
2.013  $coupon_redeem_query = mysql($sql); 
$total = 
$coupon_redeem_query->row[‘total’]; 
// $total = 0 
…… 
2.015  if ( … && $total < $allowed) 
// $allowed = 1, coupon valid 
2.059  $coupon_data= $coupon_query; 
…… 
2.070 2$sql = “INSERT…” ; 
2.070 3mysql_query($sql); 
Figure 3. The buggy interleaving for the OpenCart example. S ymbol
1.013 means line 13 in the 1st thread.
suppose there are two concurrent order requests with the
same coupon that is supposed to be redeemed only once.
They can be processed concurrently by two threads on two
respective CPUs, leading to arbitrary interleaving of the
entailed database operations. Fig. 3 shows a failure induci ng
interleaving, in which the coupon usage selection query of
theseconduser(line2.013)happensinbetweentheselectio n
query (line 1.013) and the order insertion query (line 1.070 )
of the ﬁrst user. As a result, both users observe a valid
coupon and are allowed to apply the coupon. OpenCart has
alsoothersimilarbugs,leadingtovariousundesirableeff ects
such as products being over-ordered.
Although the essence of such bugs is typical atomicity
violation, static detection of such violations for web appl i-
cations is challenging, due to the following reasons.
•Compared to traditional atomicity violations, which are
caused by shared memory accesses not being sufﬁ-
ciently protected, web app atomicity violations have
different characteristics. They usually don’t involve
sharedmemory,but ratherexternalresources.PHP does
not have any build-in synchronization primitives either.
To reason about external resources, we have to model
the semantics of the operations on these resources
as part of the PHP program. Some apps leverage
external synchronizations (e.g. database transactions),
which need to be properly modeled in the analysis too.
•The operations involved in an atomicity violation have
to access the same external resource. Otherwise, there
are no real contentions. However, determining if mul-
tiple operations access the same resource is highly
challenging. Consider the OpenCart example. We need
to determine that the select query at line 132and the
insert query at line 702access the same tuples so that a
concurrent execution of the select query may observe a
stale value (aboutthe same coupon).It requiresproving
thatxat132is equivalent to yat702, demanding a
non-trivial interprocedural analysis.
•A necessary condition for the technique is the avail-
ability of atomic region deﬁnitions as violations are@ include/transfer.php 
146  function download( $url, $outputFile ) { 
154    $fh = @fopen( $url, 'rb' ); 
158    $ofh = @fopen( $outputFile, 'wb' ); 
164    $failed = false; 
165    while ( ! feof( $fh ) && ! $failed ) { 
166      $buf = fread( $fh, 4096 ); 
172      if ( fwrite( $ofh , $buf ) != strlen( $buf ) ) { 
173        $failed = true; break; 
176      } 
181    } 
182    fclose( $ofh ); 
183    fclose( $fh ); 
189   } 
Figure 4. Code snippet from eXtplorer File Manager v2.1.0-R C3
identiﬁed by reasoning about serializability of these
regions. There are often a lot of operations accessing
the same external resources, and only some of them
need to be atomic. Traditional ways to deﬁning atomic
regions include user annotations [32], leveraging ex-
isting critical sections [14] (e.g. regions delimited by
lock acquisitions and their correspondingreleases), and
inference from dynamic runs [19]. However, none of
these solutions are applicable in our context. Further-
more, atomic regions in web apps may not be lexical
(i.e. they do not form a lexical region such as a branch
or a block of straight line code). In many cases, the
operations that ought to execute atomically distribute
in different functions. For example in Fig. 2, atomicity
is present in the two rectangled SQL queries that are in
differentfunctionsand the region (i.e. the path between
them) is non-lexical.
The goal of our work is to develop a static analysis that
overcomes the aforementioned challenges.
B. Atomicity Violation in eXtplorer File Manager
Besides databases, ﬁle system is another external shared
resource that can suffer from similar problems. Next, we
use the popular eXtplorer ﬁle manager v2.1.0-RC3 web
app to explain the atomicity violation problem in ﬁle sys-
tem. EXtplorer is a PHP based ﬁle management system.
According to the stats of Sourceforge, eXtplorer has been
downloaded for more than 300,000 times since its initial
release in July 2007.The versionwe use is the latest release .
Its UI is similar to that of a PC ﬁle manager. After logging
in, the user can create, browse, edit, upload, download, and
archive ﬁles. While operations are executed on the server
via server side scripts, the user controls through a web-
based interface on the client side. Some operations may
entail downloading ﬁles from other remote servers to the
local server.
Fig. 4 shows a code snippet from eXtplorer, in which
functiondownload () is used to download ﬁles from other
remote servers. It takes two parameters: the address of thesource ﬁle $urland the local path (on the local server)
$outputFile to savethedownloadedﬁle.At line 166,it ﬁrstly
reads from a remote server to a local buffer and then writes
the buffer to the local path at line 172. The read and write
are inside a while loop. Depending on the size of the ﬁle,
fwrite() may be invoked several times.
Since a ﬁle is incrementally written in the loop, between
invocationsto fwrite() in consecutiveiterations, a concurrent
fwrite()to the same ﬁle througha differentuserrequestmay
happen, corrupting the ﬁle.
Detecting such ﬁle system related atomicity violations re-
quires addressing the same set of challenges as for database
related violations.
III. RESOURCE IDENTITY ANALYSIS
In order to reason about atomicity violations regarding
external resources, we have to determine if multiple opera-
tions are accessing the same external resource. We develop
aresource identity analysis for this purpose. The analysis
encodes the semantics of external operations into bit-vect or
logic constraints. These constraints, together with those
generated from the regular PHP statements, are resolved
by a SMT solver to determine if two given operations are
accessing the same external resource. We will focus on
analyzing database operations, which is more challenging
than analyzing ﬁle system operations.
A. Analyzing Database Queries
We assume that all SQL queries in a program have their
keywords, table names and tuple ﬁeld names as constants1.
We preprocess the program to its SSA form so that
one variable represents one value in the rules in this sec-
tion. Moreover, we preprocess the program by introducing
dummy variables to represent non-keyword constant strings
and values. This is to simplify the descriptionof the analys is
as we don’t need to distinguish cases operating on constants
from those operating on variables.
Modeling Simple Queries. We ﬁrst discuss SELECT
queries that retrieve a set of tuple ﬁelds from a single table
with a where-clause. Such a select query is modeled as a set
of conditional assignments of tuple ﬁelds to the result data
structure. The assignments are guarded by the conditions
described by the where-clause.
$r=lmysqlquery(“SELECT f1,...,fnFROMTWHERE ”. C)
ρ=⇒ρt(C)−→(tuple(l) =t∧r.f1=t.f1∧...∧r.fn=t.fn)/logicalandtext(¬ρt(C)−→tuple(l)/negationslash=t)
(SELECT )
C1.“AND”. C2ρt
=⇒ρt(C1)∧ρt(C2) ( COND-AND )
C1.“OR”. C2ρt
=⇒ρt(C1)∨ρt(C2) ( COND-OR )
“f ⊲⊳”.$xρt
=⇒t.f ⊲⊳ x (CLAUSE )
1In our experience, dynamic table/column names are not commo n. For
example, OpenCart has 59 data tables, all static, and 780 que ry strings with
only 1 using a variable as the column name.The above rule (SELECT) presents the encoding. Rules
(COND-AND), (COND-OR), and (CLAUSE) describe the
where-clause encoding. We use ‘ .’ to denote string con-
catenation. Program statements are on the left and the
corresponding encodings are on the right. The arrow in the
middlelabeledwith ρrepresentsthetransformation,whichis
sometimes also denoted as a function ρ(), with an optional
superscript representing its context. For example, symbol
ρtrepresents that the transformation is in the context of
abstract tuple t. We introducean abstract tuple tto represent
the tuple being selected. Observe that tis not constrained.
Later, we will show how to properly constrain the abstract
tuple based on the information from other queries. Also,
while at runtime multiple concrete tuples may be retrieved,
we statically represent them with the same abstract tuple.
The supporting function tuple() in rule (SELECT) maps
a program point, denoted by label l, to an abstract tuple. It
denotes the query at lentails reading tuple t. We support
regular comparison operations in the where-clause, denote d
by⊲⊳in rule (CLAUSE).
mysqlqueryl(“INSERT INTO T(f1,...,fn)VALUES (”.
$x1. ...$xn)ρ=⇒tl.f1=x1∧...∧tl.fn=xn(INSERT)
Rule (INSERT)showstheencodingforaninsert query.Note
that we introduce an abstract tuple tlspeciﬁcally for the
query at label l, denoting the tuple inserted by that query.
The encoding process models an insert query as a sequence
of assignments to the ﬁelds of the abstract tuple.
mysqlqueryl(“UPDATE TSET(f1= $x1,...,fn= $xn)
WHERE ”. C)
ρ=⇒ρt(C)−→(tuple(l) =t∧tl.f1=x1∧...∧tl.fn=xn)/logicalandtext(¬ρt(C)−→tuple(l)/negationslash=t) ( UPDATE )
An update-query at label lis encoded to conditional ﬁeld
assignments to tuple tl, guarded by the conditions in the
where-clause. Since an update-query entails reading tuple s,
we usetuple(l) =tto denote the tuple to be read at l. Note
that we use differentabstract variables tandtlto denotethat
the tuple has different values before and after the update.
Constraining Abstract Tuples. In our analysis, we aim
to determine if multiple operations are accessing the same
shared resource. For instance, we may need to know if a
tuple inserted by query at l2can be accessed by a select-
query at l1(assuming the same table and l1precedes l2).
If so,l1in a thread may contend with l2in another thread,
leading to atomicity violations(recall the OpenCart examp le
in Section II).
ToleveragetheSMTsolvertodetermineresourceidentity,
we constrain the abstract tuple in the select-query to those
in the insert/update queries, guarded by the where-conditi on
of the select-query. Intuitively, it means that if the tuple s
added/changedby the insert/updatequeriessatisfy the whe re
condition of the select-query, they may be retrieved by
the select-query and thus the two queries access the same
tuple. It is possible that multiple inserted/updated abstr acttuples satisfy the where-condition in the select-query. In
such a case, the retrieved tuple can be any of them, without
assuming any speciﬁc order.
Without losing generality, we assume there are 2 write-
queries (i.e. insert or update queries) to the same table Tin
the program, at labels l1andl2. The revised encoding rule
fora select query(SELECT-X) to Tis presentedas follows.
$r=lmysqlquery(“SELECT f1,...,fnFROMTWHERE ”. C)
ρ=⇒F1∧F2∧Fboth∧Fneither (SELECT-X )
F1= (ρtl1(C)∧¬ρtl2(C))−→
(tuple(l) =tl1∧r.f1=tl1.f1∧...∧r.fn=tl1.fn)
F2= (¬ρtl1(C)∧ρtl2(C))−→
(tuple(l) =tl2∧r.f1=tl2.f1∧...∧r.fn=tl2.fn)
Fboth= (ρtl1(C)∧ρtl2(C))−→
(tuple(l) =tl1∧r.f1=tl1.f1∧...∧r.fn=tl1.fn)/logicalortext
(tuple(l) =tl2∧r.f1=tl2.f1∧...∧r.fn=tl2.fn)
Fneither= (¬ρtl1(C)∧¬ρtl2(C))−→tuple(l)/negationslash=tl1∧tuple(l)/negationslash=tl2
The revised encoding of a select-query is the conjunction of
four clauses F1,F2,Fboth, andFneither.F1constrains the
selected tuple with the tuple at l1but not the one at l2.F2
is the opposite. Fbothdescribes that if both tuples at l1and
l2satisfy the where-condition, the selected tuple could be
either of them.
Example. Consider a simple PHP program as follows. It
performs three queries, the ﬁrst two insert two tuples with
the ﬁrst ﬁeld being 12 and 8, respectively, and the third
query selects the tuples with the ﬁrst ﬁeld greater-than 10.
Therefore, only the tuple inserted at 1 is selected.
1 mysql_query("INSERT TO T(f1,f2) VALUES(12,".$x);
2 mysql_query("INSERT TO T(f1,f2) VALUES(8,".$y);
3 $r=mysql_query("SELECT f2 FROM T WHERE f1>10");
The corresponding encoding is as follows. From the three
formula, it is easy to infer tuple(3) =t1.
ρ(1) = t1.f1= 12∧t1.f2=x
ρ(2) = t2.f1= 8∧t2.f2=y
ρ(3) =
(t1.f1>10∧¬t2.f1>10)−→(tuple(3) =t1∧r.f2=t1.f2)/logicalandtext
...
Aggregation queries are very common in PHP programs.
Sample aggregation queries include those acquiring the
count,sum,averageoftuples/ﬁelds.Theyareusuallyaccom -
panied by the groupby keyword. It is difﬁcult to statically
model values of aggregation queries. Fortunately in our
context, we only need to model the correlation between
queries, such as if an insert query affects the result of an
aggregationquery,whichismainlydeterminedbythewhere-
conditioninstead of the speciﬁc aggregationfunction.Hen ce
our encoding is very similar to that for regular selects and
thus elided. Our technique currently does not support sub-
queries.
Modeling PHP statements. Modeling queries alone is not
sufﬁcient to reason about resource identity as queries mayuse variables that are computed by regular PHP statements.
Therefore, we have to model regular PHP statements as part
of the analysis, including assignments, conditionals, loo ps,
and simple arithmetic operations.
Assignment statements are encodedas simple equivalence
constraints. The encoding is ﬁeld sensitive, supporting
deﬁnitions and uses of data structure ﬁelds. It also models
the access of a query result through keyword row. For
instance, $x= $r→row[′f′
1]is modeled as x=r.f1.
Similar to all constraint solving based static analysis [13 ],
[35], loops need to be unrolled to conditional statements. I n
this work, we unroll the loop body twice. It allows us to
reason about the operations in consecutive iterations. Mor e
unrollings are unlikely useful as it is unlikely for a resour ce
identity property to manifest itself after a large number of
iterations in PHP programs.
Conditional statements are encoded from their SSA form.
The following example shows a typical SSA transformation.
1if(C)
2 $x=E1
3else
4 $x=E2ssa=⇒11if(C)
12 $x1=E1
13else
14 $x2=E2
15 $x3= (C)? $x1: $x2;
A conditional assignment such as the one at line 15
is further encoded to a constraint by the following rule
(COND-ASSN).
$x=C?$y: $zρ=⇒(ρ(C)−→x=y)∧(¬ρ(C)−→x=z)
(COND-ASSN )
Condition Cin the rule corresponds to the predicate in the
original conditional statement. It is also called the guard of
the assignment. Our analysis is hence path sensitive as by
encoding predicates, we are able to leverage the solver to
associate a resource identity property with a feasible path ,
determined by ﬁnding a satisfying solution to the related
guards. Our analysis is also interprocedural. It is summary -
based.
At last, we deliver analysis results through a primitive
relationsameresource, which can be queried by other
analysis components.
sameresource(l1,l2):-ρ(program )∧tuple(l1) =tl2
The meaning of the relation is that the program is accessing
the same resource at program points l1andl2if the formula
to the right of symbol :-is satisﬁable. Intuitively, it means
that from the program encoding we can infer that the tuples
accessed at l1andl2are the same.
Example. Considerthe motivationexamplein Fig. 2. Part of
the encoding is presented in Table I. From the conjunction
of (1)-(14), we can infer tuple(133) = 70 3so that we
havesameresource(133,703). In particular, the condition
in (2), i.e. t703.couponid=x, can be inferred from (1)
x=couponquery.couponidand the equivalence of y
andcouponquery.couponid, which is established from
the conjunction of (14), (13), (12), (10), (8), (7), (5) and
(4)./squareTable I
PART OF THE ENCODING OF THE CODE SNIPPET IN FIG. 2.
statement encoding
131 (1)x=coupon query.coupon id
132,133(2)t703.coupon id=x−→(tuple(133) = 70 3∧
coupon redeem query.total=fv133/logicalandtext...
14 (3)total=conpon redeem query.total
15,59(4)coupon data1=coupon query
(5)total<allowed −→coupon data2=
coupon data1
(6)¬total<allowed −→coupon data2=false
76,2012(7)coupon=coupon data2
203−206(8)data1.coupon id=coupon.coupon id
(9)data2.coupon id= 0
(10)¬coupon=false−→data3=data1
(11)coupon=false−→data3=data2
216,58 (12)data4=data3
701 (13)y=data4.coupon id
702,703(14)t703.coupon id=y
fv133in (2) is a free variable.
B. Analyzing File Operations
Determining if multiple ﬁle operations have the same
subject ﬁle is relatively easier. In this work, we focus on
ﬁle open, read and write. We do not consider other ﬁle
operations (e.g. getting a ﬁle’s path) as they are less likel y
to be error-prone due to their nature. The basic idea of our
analysis is to use the label of a ﬁle open statement as the
abstractionoftheﬁleandthenuseconstraintsolvertoreas on
about if multiple operations are on the same abstract ﬁle.
Analysis results are delivered through the same primitive
relationsameresource(l1,l2).
IV. SERIALIZABILITY ANALYSIS
Atomicity violation detection is a process of reason-
ing about serializability of operations in atomic regions.
Speciﬁcally, given an sequence of interleaved operations
from multiple (usually two) atomic regions in different
threads/processes, a violation is reported if the sequence is
notserializable.Hence,atomicregiondeﬁnitionsare crit ical.
In this work, we do not require the developer to annotate
atomic regions. A way to addressing the lack of atomic
region deﬁnitions, as in [19], [34], [28], is to reason about
pair-wise atomicity instead, that is, to reason about if two
consecutive accesses of the same shared memory location
inside a thread, called local accesses , should be atomic. For
example, in [19], [34], if during training executions, two
consecutive local accesses are never observed to interleav e
with another access from a different thread, called the
remote access , they are considered to be atomic. The key
observation is that inferring atomic pairs is a lot more
tractable than inferring an arbitrary atomic region.
In this work, we adopt a similar solution by considering
pair-wise atomicity of external operations. However, we
do not rely on dynamic runs but rather infer statically,
leveragingthe aforementionedresource identityanalysis and
program dependences. With such atomic pairs, violations
are detected by reasoning about serializability of interle avedpairs. We will discuss how to infer atomic pairs in the next
section. In this section, we assume the availability of atom ic
pairs and discuss the serializability analysis.
Typical Serializability Analysis Not Applicable. In ex-
isting work [19], [34], it was shown that to detect pair-
wise atomicity violations, it is sufﬁcient to analyze seria l-
izability when an atomic pair of accesses are interleaved
with a remote access. Because shared memory accesses are
modeled as two kinds: readandwrite. There are totally 23
possible patterns. Table II presents some of these patterns .
Forexamplein case two, givenanatomic pairthat ﬁrst reads
(R) and then writes (W), if it interleaves with a remote read
(R’), the resulting sequence is serializable as it is equiva lent
to the sequence of R’ R W. In contrast, case one is not.
Table II
DETERMINING PAIR -WISE ATOMICITY VIOLATIONS FOR SHARED
MEMORY . RDENOTES READ , WDENOTES WRITE .Local(1/2)ARE THE
TWO LOCAL ACCESSES INVOLVED IN AN ATOMIC PAIR .EACH ENTRY
SHOWS A PAIR INTERLEAVED WITH A REMOTE ACCESS .
caselocal1remote local2serializable
1 R W’ W no
2 R R’ W yes
3W W’ W yes
... ...
8W W’ R no
However, such analysis is not sufﬁcient for our purpose.
First,modeling external operations to merely reads and
writes is problematic. For example, intuitively, we should
model a ﬁle write as W. According to case 3in Table II,
two local ﬁle writes interleaved with a remote ﬁle write
are serializable, which is wrong. Consider another example .
Intuitively,SQL selects should be modeled as R, and deletes
as W. In case 1, a local select and a local delete interleaved
with a remote delete (on the same tuple) are not serializable ,
which is incorrect as it has the same consequence as ﬁrst
performing the two local operations and then the remote
deletion, which becomes a no-op. The reason of these
problemsis that the semantics of ﬁle writes and SQL deletes
cannot be precisely described as low level writes.
Second, while all the eight patterns are possible for
shared memory accesses, a lot of them are rarely observed
in external operations in our experience. For instance, an
atomic pair with the form of WR is common for shared
memory accesses. But it may not be the case for external
operations, especially in PHP code, because it is unlikely
that a program ﬁrst writes to a tuple/ﬁle, and then reads it
in the same thread.
Table III
CATEGORIZING EXTERNAL OPERATIONS .
Category Description Operations
A append SQL inserts, ﬁle writes
D delete SQL deletes
W write SQL updates
R read SQL selects, ﬁle reads
Our Solution. We propose to model external operations
to four access categories, as shown in Table III, covering(1)R R′(A|W|D) (A′|W′) (2)A(A′|R′|W′)A
(3)W(A′|R′) (W|A) (4) D D′A A′
Figure 5. Atomicity violation patterns for external operat ions. Remote
operations are superscripted.
the most common external operations. Two new categories,
appendanddelete, are introduced.
Note with the new categories,theoreticallythere are many
more interleaving patterns. Fortunately, according to our
discussion earlier, most of them are not feasible in practic e.
We hence only consider a small subset as listed in Fig. 5.
We also preclude patterns that are serializable.
The examples in Fig. 2 and 4 belong to the patterns R
R’ A A’ and A A’ A, respectively. One example of pattern
(3) is that two update-queries update two disjoint sets of
ﬁelds of the same tuple. A select query from a different
thread is not supposed to see the partially updated tuple.
Note that pattern (4) involves four operations, which are
the interleaving of two DA atomic pairs. The code snippet
in Fig. 6 shows an example. It corresponds to the coding
pattern of cleaning stale data (maybe multiple tuples) befo re
inserting a new tuple with the same key. Sequence D D’ A
A’ is not serializable as two tuples will be inserted. This
pattern also discloses that reasoning about only triples (t wo
locals and one remote) as in shared memory serializability
analysis is not sufﬁcient for external resources. Observe t hat
although pattern (4) is unserializable, its sub-patterns D D’
A and D’ A A’ are serializable.
1 $s1 = "DELETE FROM book WHERE ID = ’" . $bookID . "’";
2 $r1 = mysql_query($s1);
/*update information about the book */
3 $s2 = "INSERT INTO book VALUES(’". $bookID ."’, .... )";
4 $r2 = mysql_query($s2);
Figure 6. Example for an atomic pair involving delete- and in sert-queries.
V. ATOMICPAIRINFERENCE
In this section, we discuss how to infer atomic pairs
from PHP programs. Considering all operations in a PHP
thread/process atomic is too simplistic to be useful. Many
operations present in a program allow concurrency. Our
experimental results (in Section VII) show that naively
consideringall operationson the same resourceatomic lead s
to many false positives.
We propose to consider program dependence in order to
infer pair-wise atomicity properties. The observation is t hat
iftwoexternaloperationsarecorrelatedthroughprogramd e-
pendences, the original intention of the developer was most
likely to assume such program dependences are exercised in
a way identical to a sequential execution. Recall that in the
OpenCart example in Fig. 2. The insert-query is transitivel y
dependent on the select-query as the execution of the insert -
query is determined by if the value of the selected total
number of coupon uses has not reached the allowedlimit.
The precise dependence path is indicated in the ﬁgure by
underlining the involved variables. The assumption implie dby the dependence path is that the total number of uses
should remain constant from the select-query till the inser t-
query that places a new order.
We consider program dependences in two different ways
depending on the category of an atomic pair.
•A pair of operations with the ﬁrst operation being a
read is consideredatomicif there is a dependencepath,
including both control and data dependences, from the
ﬁrst operation to the second. It corresponds to that
the result of the ﬁrst operation is used in the second
operation. The OpenCart example illustrates this case.
•A pair of operations with neither being a read is
considered atomic if both are data dependent on the
same variable and there is a valid program path
correlating the two operations. Intuitively, it means
that both operations are consuming/storing the same
or correlated computation results. Such a process is
oftennotintendedtobeinterferedbyotherthreads.The
eXtplorerexampleinFig.4illustratesthiscase.Theﬁle
writes in two consecutive iterations are both dependent
on the creation of the output ﬁle. Another example is
presented in Fig. 6, in which the two operations are
delete and insert. Both are dependent on the deﬁnition
point of variable $bookID.
Datalog Rules for Atomic Pair Inference. The atomic pair
inference process is described as datalog rules in Fig. 7.
Datalog [9] uses a Prolog-like notation. It provides a neat
representation for whole program analysis. Data ﬂow facts
can be formulated as relations. Analysis is represented as
inference rules on these relations. Relations are in the for m
P(x1,x2,...,xn)withPbeing a predicate and x1,...,xn
representing program artifacts, such as labels. A predicat e
is a declarative statement on the variables. For example,
datadep(l1,l2)denotes that there is a data dependence path
froml1tol2.
The form of an inference rule is as follows.
P:-B1, B2, ..., B n
B1,B2, ..., and Bnare either relations or negated rela-
tions. The rule means that if B1,B2, ..., and Bnare true
thenPis true.
Relations can be either inferred or atoms. In program
analysis,weoftenstartwithasetofatomsthatdescribebas ic
facts of the program and then infer other more interesting
relations.
In Fig. 7, we assume program dependence relation dep
and data dependence relation datadep as atoms. These
relations are generated through standard program analysis .
Rules (D1) and (D2) present the rules that infer atomic
pairs. Rule (D1) describes the process of inferring atomic
pairs with the ﬁrst operation being a read. It infers
from 4 atoms, in which sameresource relation is de-
scribed in Section III. In the OpenCart example, an entry
sqlatomicRA(133,703)is inferred.Rule (D2) describes the inference of atomic pairs with
neither operation being a read. Note that in (D1), we
don’t explicitly require l2is reachable from l1because
dep(l1,l2)implies that. In the example in Fig. 6, an entry
sqlatomicDA(2,4)is inferred.
Rules (D5) and (D6) describe the inference of ﬁle opera-
tionatomicpairs,whichisverysimilarto databaseoperati on
pairs.Notethatthepossiblepatternsforﬁleoperationato mic
pairs are fewer. Other patterns are either impossible or rar e.
VI. VIOLATION DETECTION
Given the inferred atomic pairs, violations are detected
by observing if the interleaving patterns presented in Fig. 5
can happen. Since the remote operation is from a different
execution instance of the samePHP code, it is sufﬁcient to
analyze if the same program contains the speciﬁc offending
remote operation. Although PHP does not provide any
buildin synchronizationsupport, developerscan make use o f
externalprimitivessuchasdatabasetransactions,tablel ocks,
and ﬁle locks to ensure atomicity. Therefore, our technique
also needs to detect if an atomic pair is well protected by
those external primitives.
Rule (D3) determines if a given pair of program points
(l3,l4)is nested in a database transaction. It requires the
existence of a transaction that starts and ends at l1andl2,
respectively, and l1dominates l3andl2post-dominates l4
such that all paths leading from program entry to l3must
go through l1and all paths from l4to program exit must go
throughl2.
Rule (D4)detectsqueryatomicityviolationsofthepattern
WR’WwithR’beingaremoteselect-query.Itreports (l1,l2)
as an atomic WW pair that could be violated if there exists
a sql-select at l3that operates on the same abstract tuple,
and(l1,l2)is not protected by a database transaction. Our
analysisalso modelstable locks.Due to the space limitatio n,
we are not presenting the relevant rules.
Detection rules for other sql operation and ﬁle operation
interleaving patterns can be similarly derived as Rule (D4) .
VII. EVALUATION
Our system is implemented on LLVM[7], an open source
PHP compiler( phc) [6], and the STP solver[8]. Phcis used
to translate PHP to C. The main analysis is implemented
in LLVM. It takes the C program and transforms it to
constraints, which are resolved by the solver. We translate
PHP to C to leverage LLVM for call graph construction,
points-toanalysis,etc.,aswe arenotawareofinfrastruct ures
that allow us to analyze PHP direclty.
Sincephcaims to generate C code that is compilable
and executable, the PHP features not directly supported by
C are realized by chunks of C code. For example, array
ﬁelds in PHP can be added dynmaically. In translated C,
hash tables are used, substantially increasing difﬁculty f or
our analysis. We therefore modiﬁed the code generator ofphcto generate simpliﬁed C code by replacing those hash
table accesses with ﬁeld accesses. The resulting code may
not be executable, but reﬂecting the original semantics.
The LLVM component translates the generated C pro-
grams to their SSA forms, which are further encoded to
constraints. In order to understand external operations an d
encodethemproperly,weimplementasimplestringanalysis
that tracks string concatenations so that we can acquire the
the query strings. A string variable is mappedto a linked lis t
of constants and variables denoting its value. Query string s
can be parsed to identify table name and ﬁeld names. Our
system currently requires these names to be constant.
Since PHP ﬁles are largely independent modules,it is
unnecessary to encode all the ﬁles of a web app. We use
a demand-driven strategy. In particular, given a query abou t
resource identity, we performprogramslicing to identify t he
relevant PHP modules and functions and then only encode
the slice.
We apply our technique to a set of real world web
applications.ThebenchmarksaremainlyfrompreviousPHP
analysis works[11], [31], [36], excluding those that have
trivial external resource accesses or functionally overla p
with the selected ones. In addition, the shopping, forum and
wiki kinds of apps are often accessed concurrently, so we
randomly pick OpenCart, phpBB, aphpkb for each kind.
The characteristics of these programs are listed in Ta-
ble IV. Observe that many of them are very large web apps,
with a few hundred PHP ﬁles and over 100k LOC. All
experiments are run on an Intel Dual Core 2.5GHz machine
with 2GB memory. The OS is Linux-2.6.35.
Table IV
PROGRAM CHARACTERISTICS .
PHP PHP LOC
Application ﬁlesmean stdev max total
openCart v1.4.9.4 535 991521233 53025
phpBB v3.0.0 245 685293345178 167797
ajallerix v0.1 164021283 5207 6435
eXtplorer v2.1.0-RC3 277 291 3974618 80598
scarf v2007-02-27 19 89 91369 1686
phpoll v0.97 beta 27167 122 494 4522
AWCM v2.2 187 79 8548314717
webChess v1.0.0 rc2 28186 2641243 5219
faqforge v1.3.2 19 90 73218 1710
schoolMate v1.5.4 63129 94539 8120
timeclock v1.04 63330 4372832 20800
aphpkb v0.95.5 46 93 67264 4283
news pro v1.4.0 30231 183 811 6925
DCP-Portal v 6.1.1 362 335 4285075121410
Employee Scheduler v2.1beta 43215 2201231 9264
Table V presents the result of violation detection. “ PHP
LOC w/ inclusion ” is the average LOC of PHP ﬁles after
inlining the scripts indicated by the include keyword.
“Converted C LOC ” is the average LOC of the C programs
translated from the expanded PHP. “ Constraint complexity ”
presents the average number of variables andconstraints
in the formula. The last four columns present the number
violations reported and the number of false positives for ou r
technique and a simpliﬁed static analysis. “ SA w/o Dep. ”Atoms
dep(l1,l2) : there is a program dependence path from l1tol2, including both data and control dependences.
datadep(l1,l2): there is a data dependence path from l1tol2.
sqlR/W/A/D(l): there is a SQL select/update/insert/delete query at l.
ﬁleR/A(l) : there is a ﬁle read/write operation at l.
reachable (l1,l2):l2is reachable from l1.
trans(l1,l2) : a database transaction is created at l1and then released at l2.
dom(l1,l2) :l1dominates l2.
pdom(l1,l2) :l1post-dominates l2.
Rules for Database Queries
/*(l1,l2)is a sql RW/RA/RD atomic pair*/
(D1)sqlatomicRW/RA/RD(l1,l2):-sqlR(l1),sqlW/A/D(l2),sameresource (l1,l2), dep(l1,l2)
/*(l1,l2)is a sql DA/WW/WA atomic pair*/
(D2)sqlatomicDA/WW/WA(l1,l2):-sqlD/W/W(l1),sqlA/W/A(l2),sameresource (l1,l2),reachable (l1,l2),
datadep(l,l1),datadep(l,l2)
/* The two operations at l3andl4are protected by the transaction in between l1andl2*/
(D3)intrans(l1,l2,l3,l4) :-trans(l1,l2),dom(l1,l3),pDom(l2,l4)
/* WR’W atomicity violation, l1andl2should be atomic, but the interleaving with l3is not serializable*/
(D4)sqlviolation wRw(l1,l2) :-sqlatomicWW(l1,l2),sqlR(l3),sameresource (l3,l1),¬intrans(l4,l5,l1,l2)
Rules for File Operations
/*(l1,l2)is a ﬁle RA atomic pair*/
(D5)ﬁleatomicRA(l1,l2):-ﬁleR(l1),ﬁleA(l2),sameresource (l1,l2),dep(l1,l2)
/*(l1,l2)is a ﬁle AA atomic pair*/
(D6)ﬁleatomicAA(l1,l2):-ﬁleA(l1),ﬁleA(l2),sameresource (l1,l2),reachable (l1,l2),datadep(l,l1),datadep(l,l2)
Figure 7. Datalog rules for atomicity violation detection f or external operations. W, R, A, and D denote write, read, app end, and delete.
Table V
ANALYSIS RESULT.
PHP LOC w/ Converted Complexity (avg) Our method SA w/o Dep.
Application inclusion (avg) C LOC (avg) Variable Constraint viocFPcviosFPs
openCart v1.4.9.4 899 49068 1359 1972 32 032 0
phpBB v3.0.0 2490 83683 1054 1568 14 014 0
ajallerix v0.1 86 5170 247 762 1010
eXtplorer v2.1.0-RC3 781 10559 326 598 2020
scarf v2007-02-27 402 9313 76 165 5012 7
phpoll v0.97 beta 208 5586 83 232 4040
AWCM v2.2 2679 51607 124 227 201513
webChess v1.0.0 rc2 1706 63616 82 174 7011 4
faqforge v1.3.2 217 2993 52 89 3030
schoolMate v1.5.4 421 14489 123 185 11 33325
timeclock v1.04 1154 25746 147 194 302724
aphpkb v0.95.5 842 17663 75 97 3052
news pro v1.4.0 1129 28331 178 239 11 03019
DCP-Portal v 6.1.1 423 20940 253 597 11 011 0
Employee Scheduler v2.1beta 2089 84659 169 271 7081
Total — — — —116 3208 95
represents a technique that can be considered as a static
version of the one used in [25] (which is dynamic). In
particular, it does not infer atomicity properties from PHP
code, but rather directly comparesthe query strings. Queri es
that access the same table and abstract tuple, and may form
unserializable interleavings are reported. The analysis t ime
is mostly within a few seconds and thus elided.
We make the following observations from the result.
•Our analysis is able to detect many violations in these
real worldweb apps.We manuallyvalidateeach bugby
constructing a real test input and exercising the prob-
lematic interleaving pattern. These bugs could lead to
problems such as coupon misuses, product being over-
sold, data corruption and runtime database exceptions.
•Our analysis produces very few false positives.•The simpliﬁed approach producesmany false positives.
This illustrates the beneﬁt of analyzing PHP code.
It also suggests that even though many queries are
accessing the same table and the same tuples, they are
allowed to execute concurrently.
•Slicingisaneffectiveoptimizationbecauseeventhough
the programsare large on average,the averagenumbers
of constraints and symbolic variables are small.
False Positive . Our analysis sometimes reports false posi-
tives. A typical example is shown in Fig. 8. Variables such
as$POST[...] hold the values submitted by the client so
that they are deﬁned in the client-side. Our analysis is not
able to make any assumptionsabout these values. Therefore,
we treat them as free variables.Based on such assumptions, the predicates at lines 1
and5are both satisﬁable, rendering the path between
the two queries (at lines 3 and 7) feasible. Since the
queries access the same resource and both depend on the
same$_POST[total] variable, according to our detec-
tion rules, the two operations are considered to be atomic.
Interleaving “1,1’,5” hence constitutes a violation. Howe ver,
in practice, these two queries are not related.
The reason of the FP in Fig. 8 is that we missed the
constraint that a client can never submit a single request
that can add a new record and edit an existing one in the
meantime. We speculate if we can model the client-side
logic, such FPs can be eliminated. We leave it to our future
work.
1 if($_POST["addassignment"] == 1) {
2 $s1 = "UPDATE courses SET ... $_POST[total] ... ";
3 $r1 = mysql_query($s1);
4 }
5 if($_POST["editassignment"] == 1) {
6 $s2 = "UPDATE courses SET ... $_POST[total] ... ";
7 $r2 = mysql_query($s2);
8 }
Figure 8. False Positive Example - simpliﬁed snippet from schoolMate .
False Negative . Our analysis is incomplete and may have
false negatives. For example, the atomicity inference is
heuristic based. The current string analysis handles strin g
concatenation but doesn’t support functions such as sub-
str()orstrrpos() . However, without an oracle, it’s hard to
determine false negatives automatically. We leave it to our
future work.
VIII. R ELATEDWORK
Data Race and Atomicity Violation Detections . There are
many works on data race detection [27], [24], [22], [23]
and atomicity violation detection[14], [19], [26], [18].T hey
are mostly addressing problems caused by shared memory
accesses. They often leverage synchronization primitives . In
contrast, the problem in our scenario is caused by sharing
external resources. Server side scripts provide no build-i n
threading or synchronization support. In other words, we
have to address a largely different set of challenges.
Web app testing . Server side script testing is increasingly
studied lately. Wassermann et al. [33] designed an auto-
matic input generation algorithm for web apps based on
concolicexecution.Theyalso modelsthe semanticsof strin g
operations and solve constraints involving different type s.
Harmanet al. [16] proposeda session data repairmethodfor
regression testing. The work by Halfond et al. [15] precisel y
identiﬁes a web app’s interface to improve test input gener-
ation via symbolic execution. Artzi et al. [11] proposed to
combine concrete and symbolic executions to automatically
generatetest casesthatexposefaultsbyanalyzingtheserv er-
side script. Sprenkle et al. [30] suggested that statistica l
model-based test generation can be adopted and applied for
web app testing. Marchetto et al.[21] proposed a testabilit ymeasurement that can be leveraged in automated testing
of web apps. The vulnerability measurement proposed in
[29] heuristically inspects SQL hotspots in server scripts to
decide priority. Carzaniga et al. [12] proposed an automati c
workaround of web app failures. Provided a failure, it tries
to ﬁnd a differentexecution sequence that achieves the same
functionalitywhile bypassthe failure. The aboveapproach es
do not address problems caused by concurrent executions.
Web app comprehension. Since web app source code is
usually not well organized, it is difﬁcult for human de-
veloper/maintainer to understand the (complex) correlati ons
between modules. Thus, many works have been proposed
to help people get better understanding. Hassan et al.
[17] proposed to extract code structure and display the
interactions between components. WANDA[10] instruments
web apps and combines dynamic and static informations
to address the problem. Similarly, the integration of WARE
andWANDA[20] combines static and dynamic analysis to
enhance comprehension. These works are too general to
solve our problem.
IX. CONCLUSION
We propose a static analysis that detects atomicity vi-
olations in web apps regarding external resources. The
technique features a novel resource identity analysis that is
interprocedural and path-sensitive. It models external op era-
tions to constraints and leveragesa SMT solver to determine
whether multiple operations are accessing the same externa l
resource,whichisacriticalconditionforcontention.Wea lso
develop an automated approachto statically infer if a pair o f
operationsthat access the same resource demands atomicity .
Violations are detected by reasoning about serializabilit y of
interleaved atomic pairs. Our results show that the techniq ue
is highly effective, capable of detecting many real atomici ty
violations in large web apps.
ACKNOWLEDGMENTS
We would like to thank the reviewers for their sub-
stantial efforts. This research is supported, in part, by th e
National Science Foundation (NSF) under grants 0834529
and 0845870. Any opinions, ﬁndings, and conclusions or
recommendations in this paper are those of the authors and
do not necessarily reﬂect the views of NSF.
REFERENCES
[1] ProductCart overselling. http://www.rotofugi.com/t oyscart/pc/
viewContent.asp?idpage=48.
[2] OpenCart overselling. http://forum.opencart.com/vi ewtopic.
php?f=20&t=37073.
[3] Drupal critical runtime failure. http://drupal.org/n ode/566832.
[4] Joomla ﬁlecorruption. http://forum.joomla.org/view topic.php?
p=1795892.[5] 5 Best Open Source Shopping Carts. http://www.stylomar t.
com/technology/5-best-open-source-shopping-carts/.
[6] Phc: open source PHP compiler. http://www.phpcompiler .org/.
[7] The LLVM Compiler Infrastructure Project. http://llvm .org/.
[8] The STP Constraint Solver. https://sites.google.com/ site/
stpfastprover/.
[9] A. Aho, M. Lam, R. Sethi, and J. Ullman. Compilers: princi -
ples, techniques, and tools (2nd Ed.). Pearson Education, Inc,
2006.
[10] G. Antoniol, M. Penta, M. Zazzara. Understanding Web
Applications through Dynamic Analysis. IWPC’04 .
[11] S. Artzi, J. Dolby, F. Tip and M. Pistoia. Practical faul t
localization for dynamic web applications. ICSE’10.
[12] A. Carzaniga, A. Gorla, N. Perino and M. Pezz` e. Automat ic
workarounds for web applications. FSE’10.
[13] E. Clarke, D. Kroening and K. Yorav. Behavioral consist ency
of C and verilog programs using bounded model checking.
DAC’03.
[14] C. Flanagan and S. Freund. Atomizer: a dynamic atomicit y
checker for multithreaded programs. In POPL’04 .
[15] W. Halfond, S. Anand and A. Orso. Precise interface iden -
tiﬁcation to improve testing and analysis of web applicatio ns.
InISSTA’09.
[16] M. Harman and N. Alshahwan. Automated Session Data
Repair for Web Application Regression Testing. In ICST’08.
[17] A. Hassan and R. Holt. Architecture recovery of web appl i-
cations. In ICSE’02.
[18] Z. Lai, S. C. Cheung and W. K. Chan. Detecting atomic-
set serializability violations in multithreaded programs through
active randomized testing invariants. In ICSE’10.
[19] S. Lu, J. Tucek, F. Qin and Y. Zhou. AVIO: detecting atom-
icity violations via access interleaving invariants. In ASPLOS-
XII.
[20] G. Lucca and M. Penta. Integrating Static and Dynamic
Analysis to improve the Comprehension of Existing Web
Applications. WSE’05.
[21] A. Marchetto, R. Tiella, P. Tonella, N. Alshahwan, M. Ha r-
man. Crawlability metrics for automated web testing. STTT
13(2) 2011 .[22] M. Naik, A. Aiken and J. Whaley. Effective static race
detection for Java. In PLDI’06 .
[23] A. Nistor, D. Marinov and J. Torrellas. Light64: lightw eight
hardware support for data race detection during systematic
testing of parallel programs. In MICRO-42 .
[24] R. O’Callahan and J. Choi. Hybrid dynamic data race dete c-
tion. InPPoPP’03 .
[25] R. Paleari, D. Marrone, D. Bruschi and M. Monga. On Race
Vulnerabilities in Web Applications. In DIMVA’08 .
[26] C. Park, K.Sen. Randomized active atomicity violation detec-
tion in concurrent programs. In SIGSOFT’08/FSE-16 .
[27] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro and T. An -
derson. Eraser: a dynamic data race detector for multithrea ded
programs. In TOCS 15(4) 1997 .
[28] A. Singh, D. Marino, S. Narayanasamy, T. Millstein and
M.Musuvathi. Efﬁcientprocessor supportforDRFx,amemory
model with exceptions. In ASPLOS’11 .
[29] B. Smith and L. Williams. Using SQL Hotspots in a Priori-
tization Heuristic for Detecting All Types of Web Applicati on
Vulnerabilities. In ICST’11.
[30] S. Sprenkle, L. Pollock and L. Simko. A Study of Usage-
Based Navigation Models and Generated Abstract Test Cases
for Web Applications. In ICST’11.
[31] F. Sun, L. Xu, and Z. Su. Static Detection of Access Contr ol
Vulnerabilities inWebApplications. In USENIXSecurity 2011 .
[32] M. Vaziri, F. Tip and J. Dolby. Associating synchroniza -
tion constraints with data in an object-oriented language. In
POPL’06 .
[33] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamur a
and Z. Su. Dynamic test input generation for web application s.
InISSTA’08.
[34] D. Weeratunge, X. Zhang, and S. Jagannathan. Accentuat -
ing the Positive: Atomicity Inference and Enforcement Usin g
Correct Executions. In OOPSLA’11 .
[35] Y. Xie and A. Aiken. Scalable error detection using bool ean
satisﬁability. In POPL’05 .
[36] Y. Xie and A. Aiken. Static detection of security vulner abil-
ities in scripting languages. In USENIX’06 .
[37] Y. Zheng, T. Bao and X. Zhang. Statically locating web
application bugs caused by asynchronous calls. In WWW’11 .