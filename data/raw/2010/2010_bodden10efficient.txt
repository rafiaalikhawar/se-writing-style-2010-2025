EfﬁcientHybrid Typestate Analysisby Determining
Continuation-EquivalentStates
Eric Bodden∗
Software Technology Group
Department ofComputer Science
TechnischeUniversitätDarmstadt,Germany
bodden@acm.org
ABSTRACT
Typestate analysis determines whether a program violates a
set of ﬁnite-state properties. Because the typestate-anal ysis
problem is statically undecidable, researchers have propo sed
a hybrid approach that uses residual monitors to signal prop -
erty violations at runtime.
We present an eﬃcient novel static typestate analysis that
is ﬂow-sensitive, partially context-sensitive, and that g en-
erates residual runtime monitors. To gain eﬃciency, our
analysis uses precise, ﬂow-sensitive information on an int ra-
procedural level only, and models the remainder of the pro-
gram using a ﬂow-insensitive pointer abstraction. Unlike
previous ﬂow-sensitive analyses, our analysis uses an addi -
tional backward analysis to partition states into equivale nce
classes. Code locations that transition between equivalen t
states are irrelevant and require no monitoring. As we show
in this work, this notion of equivalent states is crucial to
obtaining sound runtime monitors.
We proved our analysis correct, implemented the analysis
in the Clara framework for typestate analysis, and applied
it to the DaCapo benchmark suite. In half of the cases,
our analysis determined exactly the property-violating pr o-
gram points. In many other cases, the analysis reduced the
number of instrumentation points by large amounts, yieldin g
signiﬁcant speed-ups during runtime monitoring.
Categories andSubject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veriﬁ-
cation— Validation
General Terms
Algorithms, Experimentation, Performance, Veriﬁcation
Keywords
typestate analysis, static analysis, runtime monitoring
∗Eric conducted most of this research as a Ph.D. student
at McGill University, under supervision of Laurie Hen-
dren. This work was supported by NSERC and CASED
(www.cased.de).
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
ICSE’10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.connected closed errorclose
reconnectclose, reconnect, write
writeclose write
Figure 1: Finite-state machine for “Connection” property
1. INTRODUCTION
A typestate property [22] describes which operations are
available on an object or even a group of inter-related ob-
jects, depending on this object’s or group’s internal state ,
the typestate. For instance, programmers must not write to
a connection handle that is currently in its “closed” state.
Figure 1 shows a non-deterministic ﬁnite-state machine for
this property. It monitors a connection’s“close”,“reconn ect”
and“write”events and signals an error at its accepting stat e.
Typestate properties aid program understanding, and one
can even deﬁne type systems [5, 14] that prevent program-
mers from causing typestate errors, or derive static typest ate
analyses [17] that try to determine whether a given program
violates typestate properties. Unfortunately, the typest ate-
analysis problem is generally undecidable. Researchers ha ve
therefore proposed a hybrid approach [9, 10, 16] that uses
static-analysis results to generate a residual runtime mon -
itor. This monitor captures actual property violations as
they occur, but only updates its internal state at relevant
statements, as determined through static analysis.
A correct runtime monitor must observe events like“close”
and “write” that can cause a property violation, but also
events like “reconnect” that may prevent the violation from
occurring. Missing the former causes false negatives while
missing the latter causes false positives, i.e., false warn ings.
Either is unacceptable, as runtime monitors must handle
property violations exactly when they occur. A correct
static analysis must therefore determine program location s
that can trigger either kind of such “relevant” events.
In this work we present an eﬃcient novel static typestate-
analysis algorithm called Nop-shadows Analysis1that uses a
forward and a backward pass to identify provably irrelevant
code locations. For every program statement sof interest,
the forward analysis determines the possible typestates th at
can reach s. The additional backward analysis partitions
these states into equivalence classes. A program location
1The aspect-oriented-programming community uses the
term “shadow” [18] to refer to instrumentation points.that can only transition between equivalent states is irrel -
evant. This eases the burden on the programmer, as the
programmer does not need to consider such irrelevant loca-
tions during manual code inspections. Moreover, we elim-
inate the monitoring instrumentation from these program
locations, speeding up the residual runtime monitor. Our
novel analysis is not only simpler than earlier approaches, it
is also both precise and eﬃcient.
Any precise typestate analysis has to be ﬂow-sensitive and
requires must-alias information: to determine that the cod e
“c1.reconnect(); c2=c1; c2.write(); ”correctly uses the connec-
tion that c1andc2refer to, the analysis needs to know that
c1andc2must point to the same object, i.e. that c1andc2
must-alias. Such information is expensive to compute. To
gain eﬃciency, our analysis computes ﬂow information and
must-alias information on an intra-procedural level only, and
models the remaining program using a carefully designed
ﬂow-insensitive pointer abstraction.
To evaluate our approach, we have implemented our anal-
ysis in the Clara framework for typestate analysis [7] and
applied the analysis to the DaCapo benchmark suite [6].
Our results show that our lightweight abstractions are pre-
cise enough to exactly tell apart property-violating progr am
points from irrelevant program points in half of the cases.
For these cases, the analysis determines exactly the proper ty-
violating program locations. In many other cases the anal-
ysis identiﬁes and disables large amounts of irrelevant pro -
gram points. This eases manual code inspection and, as we
show, speeds up the resulting residual monitor signiﬁcantl y.
Our modest abstractions restrict the analysis time to a few
minutes in most cases.
We proved our analysis correct. As we found out during
this process, two analyses that we [10] and others [20] pub-
lished previously are unsound. They fail to identify certai n
program locations that trigger violation-preventing even ts
like “reconnect” above. As a consequence, the resulting run -
time monitors may cause false warnings at runtime. This
unsoundness is caused by the fact that traditional typestat e
analyses use a forward-analysis pass only and have no notion
of equivalent states like our novel analysis does.
To summarize, this paper presents the following original
contributions:
•a novel ﬂow-sensitive static typestate analysis, called
“Nop-shadows Analysis”, that detects equivalent type-
states to determine all statements that are relevant to
causing or preventing a property violation,
•an implementation of the Nop-shadows Analysis in the
Clara framework that generates eﬃcient residual run-
time monitors,
•a set of experiments that shows that the analysis is
both precise and eﬃcient, and
•an explanation of why some other static analyses that
use a forward-analysis pass only, generate unsound
runtime monitors.
We structured the remainder of this paper as follows. We
start oﬀ by giving a brief overview of the Clara framework,
in which we implemented our analysis. In Section 3 we give
an example to illustrate the Nop-shadows Analysis itself.
We explain the full analysis in Section 4, followed by our
experiments in Section 5. In Section 6 we discuss how we
improve over the state of the art. We conclude in Section 7.Claracompile & weave
woven programprogrammonitor aspect with
property annotation
static-analysis engineoptimized instru-
mented programruntime
monitordeﬁne or
generate
test-run
Figure 2: Overview of Clara
2. THE CLARA FRAMEWORK
Clara (CompiLe-time Approximation of Runtime Anal-
yses) is a novel research framework for the implementation
of hybrid typestate analyses. We developed Clara to sup-
port easy implementation of the analysis that we present in
this paper, among others. Clara ’s major design goal is to
de-couple the code-generation for eﬃcient runtime monitor s
from the static analyses that convert these monitors into
faster, residual monitors. In this work, we can only give an
overview of Clara . The author’s dissertation [7] gives a
more detailed account. Clara is available at:
http://bodden.de/clara/
Figure 2 gives an overview of Clara . With Clara , the
researcher ﬁrst deﬁnes a set of typestate properties, denot -
ing each property as an annotation to an AspectJ [3] aspect
that implements a runtime monitor for the same property.
Annotations directly encode a non-deterministic ﬁnite-st ate
machine, just as the one in Figure 1. In the author’s dis-
sertation [7] we show how researchers can even use runtime-
monitoring approaches like tracematches [2], JavaMOP [13] ,
and others, to generate these annotated aspects automati-
cally from high-level monitor speciﬁcations.
Clara weaves the monitoring aspect into the program
under test and emits helper classes that implement the run-
time monitor as deﬁned by the aspect. Clara extends the
AspectBench Compiler [4] for this purpose. Clara then
invokes its static-typestate-analysis engine. Researche rs can
add a number of static analyses to Clara and have them ap-
plied in any order. These analyses obtain, through the ﬁnite -
state machine deﬁned in the aspect’s annotation, enough in-
formation about the typestate property to precisely approx -
imate the set of relevant instrumentation points. When an
analysis determines that an instrumentation point is irrel e-
vant to a property, i.e., the program can neither violate the
property nor prevent a property violation at this point, the n
Clara automatically disables the instrumentation for this
property at this point. The result is an optimized instru-
mented program that updates the runtime monitor only at
program points at which instrumentation remains enabled.
The approach that we present in the following instantiates
Clara ’s static-analysis engine with a combination of two
previously published supporting analyses and our novel Nop -
shadows Analysis.
3. ANALYSIS BY EXAMPLE
We motivate our analysis using our running example: it
is an error to write to a connection object that was closed,
unless the connection was re-connected in between. Fig-
ure 1 shows the appropriate non-deterministic ﬁnite-state1public static void main(String args[]) {
2 Connection c1 = newConnection(args[0]);
3 c1.close ();· · · · · · · · · · · · · · · · · · · · · · · · · 0· · {}· · · {0,1,2}
4 c1.reconnect();· · · · · · · · · · · · · · · · · · · · · · · · · 1· · {}· · · {0,1,2}
5 c1.close ();· · · · · · · · · · · · · · · · · · · · · · · · · 0· · {}· · · {0,1,2}
6 c1.close ();· · · · · · · · · · · · · · · · · · · · · · · · · 1· · {}· · · {0,1,2}
7 c1.write(args [1]);· · · · · · · · · · · · · · · · · · · · · · · · · 1· · {}· · · {1,2}
8 c1.close ();· · · · · · · · · · · · · · · · · · · · · · · · · 2· · {}· · · {2}
9 c1.reconnect();· · · · · · · · · · · · · · · · · · · · · · · · · 1· · {}
10 c1.write(args [1]);· · · · · · · · · · · · · · · · · · · · · · · · · 0· · {1,2}
11}· · · · · · · · · · · · · · · · · · · · · · · · · 0· · {2}
Figure 3: Simple example program using a single connection
machine that Clara obtains from parsing the annotation
in the speciﬁed aspect. The state machine accepts events of
type“close”,“reconnect”and“write”. When a“write”follo ws
a “close”, then the state machine moves into its error state.
Clara represents error states as accepting states. Let us
call the language that this state machine accepts L.
Figure 3 shows a simple example program that uses a sin-
gle connection, along with the analysis information that we
compute (explanation follows). To keep the example sim-
ple, this program contains only straight-line code, no out-
going method calls that may change the connection’s type
state, and no aliasing. Our implementation, however, han-
dles complete Java programs, including method calls, recur -
sion, loops, exceptions and aliasing (see Section 4).
Our example program violates the connection property
by closing the connection (even twice, at lines 5 and 6),
and then writing to the connection (line 7). Note, though,
that all other statements in this program are irrelevant to
the property violation. In particular, one does not need to
monitor the “close” and “reconnect” operations at lines 3
and 4 because they precede the violating fragment of the
run. Conversely, the operations at lines 8 to 10 follow this
fragment, and hence do not need to be monitored either.
A little more subtle, it is even correct to omit monitoring
one of the two “close” events at lines 5 and 6. (But not
both!) The static analysis that we present in the following
will eliminate the instrumentation at exactly those shadow s
that we just identiﬁed as irrelevant—“nop shadows”, as we
call them. Instrumentation will only remain in lines 5 and
7, or 6 and 7—an optimal result for this program.
Exampleapplicationofanalysisalgorithm.
For a method containing nshadows, the Nop-shadows
Analysis consists of up to n“rounds”, where each round
identiﬁes a single nop shadow until no further nop shadows
can be identiﬁed. Each round consists of a forward and a
backward pass. The forward pass computes for every state-
ment sthe typestates that can reach s. The backwards
pass conversely computes classes of states from which the
property state machine can reach a violating state using the
remainder of the program execution that follows s.
The forward pass uses a determinized version of the ﬁnite-
state machine from the property speciﬁcation. Figure 4a
shows this state machine for our example. In the follow-
ing, we will call this state machine Mforward . We number
Mforward ’s states for presentation purposes. The forward0 1 2closereconnect, write
writeclose
reconnect close
reconnectwrite
(a) Deterministic ﬁnite-state machine Mforward forL
{2} {1,2} {0,1,2}write closewrite close, reconnect, write
(b) Deterministic ﬁnite-state machine Mbackward forL
Figure 4: Finite-state machines for Connection example
analysis starts oﬀ in this state machine’s initial state 0 an d
then updates the state according to the shadows that it en-
counters during analysis. In Figure 3, we show the states
that the forward analysis computes before and after each
statement, next to the downward arrow. For instance, the
“close” statement at line 3 changes the typestate from 0 to
1. Importantly, at property violations, e.g. at line 7, the
analysis will reach the violating state 2.
The backward pass, on the other hand, uses a determin-
istic ﬁnite-state machine for L’s mirror language L. For
any word w=w1. . . w n∈ L, we deﬁne the mirror word
wasw:=wn. . . w 1. The mirror language Lis deﬁned
byL:={w|w∈ L}. While it would be sound for our
backwards pass to use any ﬁnite-state machine that accepts
the language L, we speciﬁcally use the state machine that
we obtain by (1) reversing Mforward (by ﬂipping all edges
and swapping initial and accepting states), and then (2) de-
terminizing this ﬁnite-state machine again. The resulting
state machine is minimal for L[12]. As we will explain in
Section 4, a minimal ﬁnite-state machine yields a more pre-
cise analysis result because in this state machine equivale nt
states are collapsed into a single state. For our example,
Figure 4b shows the ﬁnite-state machine that we obtain this
way. (We omit the “sink” state that represents the empty
state set.) We call this automaton Mbackward . Note that
we labeled each of this automaton’s states with the set of
states of Mforward that this state represents. These labels
are important: our analysis will compare states from the
forward analysis with states from the backward analysis,
and labeling Mbackward ’s states with their equivalent states
ofMforward eases this comparison.
According to the semantics of Clara ’s state-machine no-
tation, a single program run can cause multiple property
violations. Each violating sub-path of the execution path
starts at one of the program’s possible entry points and ends
at what we call a“ﬁnal shadow”. A ﬁnal shadow is a shadow
that is labeled with a symbol that leads into an error state,
like “write” in our example. Therefore, in the example, we
apply the backwards analysis starting at both write state-
ments (lines 10 and 7). In Figure 3, we show the analysis
result for both backwards-analysis runs on the right-hand
side. For instance, the close statement at line 6 changes the
typestate from the state labeled with {1,2}to the state la-
beled with {0,1,2}. The same statement further loops on
the sink state {}: as we show next to the left upward arrow,
the statement transitions from {}again to {}.Nop-shadow condition. We now explain how we com-
bine the forward and backward-analysis information to iden -
tify nop shadows. Let source (s) be the state that the for-
ward analysis computed just before a statement s,target (s)
the state for the location just after s, and futures (s) the set
of state sets that the backwards analysis computed for just
after s. For instance, for the close statement at line 5 of
Figure 3 we have:
source (line 5) = 0
target (line 5) = 1
futures (line 5) = { {},{0,1,2} }
The following property is crucial to our approach: because
we compute futures (s) using a deterministic state machine
forL, the sets in futures (s) represent equivalence classes.
For instance, the set {0,1,2}represents the fact that, us-
ing the remainder of the program execution, one will reach
a property violation from Mforward ’s states 0, 1 or 2 either
way. By using a minimal state machine we assure opti-
mality: when two states q1andq2are equivalent, then in
futures (s) both q1andq2will be members of the same class.
In the following, for two states q1andq2we say that q1
andq2are equivalent and write q1≡q2if the following holds:
∀Q∈futures (s). q1∈Q↔q2∈Q
A shadow is a nop shadow when it transitions between states
in the same equivalence class. Let us denote by Fthe set of
accepting, i.e., violating states of Mforward . Then we call a
shadow at a statement sa “nop shadow” if:
1.source (s)≡target (s), and
2.target (s)/ne}ationslash∈F.
The second case is necessary, because according to Clara ’s
monitoring semantics, a monitor must signal repeated prop-
erty violations every time the violation occurs. This is use -
ful when the monitor executes error-handling code. For in-
stance, on “ c. close ();c.write();c.write() ” the monitor should
signal a violation after both“write” events. This is althou gh
the second “write” event does not change the typestate: we
havesource (s) =target (s) = 2.
Need for re-iteration . It is important to note that, by
our above deﬁnition, a nop shadow is only a nop shadow in
its current context, i.e., if all other shadows remain enabl ed.
This is because after identifying any particular single sha dow
as a nop shadow, by disabling this shadow, we change the
program’s transition structure, and previous nop shadows
may therefore not be nop shadows any more. This is ex-
actly the case at lines 5 and 6 of our example: According
to the nop-shadow condition, both shadows are nop shad-
ows. However, disabling one of these shadows will render the
other one necessary: one needs to observe one of these two
shadows; otherwise the runtime monitor will not reach its vi -
olating state at line 7. Conversely, our nop-shadow conditi on
does not initially identify the“reconnect”shadow at line 9 as
a nop shadow. This is because disabling this shadow, while
keeping the shadows at lines 8 and 10 enabled, would cause
a false positive at runtime, at line 10. However, after any of
these latter two shadows have been enabled, the reconnect
shadow will become a nop shadow too, and can be disabled
as well. To be both sound and eﬀective, we therefore pro-
grammed our analysis to disable a single shadow at a time,
and then re-compute the analysis information, re-iteratin guntil no further nop shadow can be identiﬁed. The num-
ber of iterations is bounded by the number of shadows that
the current method holds. In our example, we reach a ﬁxed
point in the 7th iteration; instrumentation will only remai n
in lines 5 and 7, or 6 and 7.
While this result is optimal for this particular program,
note that because our algorithm disables shadows one by
one, it works in a“greedy”fashion. In theory, this may cause
the algorithm to reach its ﬁxed point in a local optimum
instead of the global optimum. The author’s dissertation [7 ,
Appendix C] gives a constructed example that demonstrates
this behavior. As we will show, however, our simple“greedy”
solution performs very well in practice. We conjecture that
this is due to the usually relatively simple structure [15] t hat
typical ﬁnite-state properties have.
4. NOP-SHADOWSANALYSIS
We next explain how we handle the general analysis prob-
lem, involving loops, outgoing method calls, recursion, ex -
ceptions and aliasing. For every shadow sin the instru-
mented program, to determine whether sis a nop shadow,
our analysis needs to compute source (s),target (s) and the
setfutures (s). The analysis needs to fulﬁl multiple condi-
tions to compute these pieces of analysis information in a
sound way. We (1) need to consider all possible control-ﬂow
paths through the program that could potentially lead up to
the execution of sand that are completed by the continua-
tion of the control ﬂow after s. Then (2), along every such
path, we must assure that we never merge futures -sets at
any point: merging sets would compute incorrect equivalen-
cies. Lastly, (3) the analysis must be able to distinguish th e
typestates of multiple diﬀerent (combinations of) objects .
In particular, the analysis must be able to handle aliasing.
To cope with (3), the analysis distinguishes the analysis
information for diﬀerent objects by propagating “conﬁgura -
tions” instead of bare state sets: a conﬁguration c= (Q, b)
combines an automaton-state set Qwith a variable binding
b. When cis associated with a statement s, then the state
setQholds all possible typestates just before executing s.
The binding bdescribes the object(s) which this state set is
associated with. In our connection example, for any given
statement sthere could exist multiple connections that are
in diﬀerent typestates when sexecutes. The variable bind-
ings help distinguish these diﬀerent typestates. A variabl e
binding maps one or more variables from the typestate spec-
iﬁcation to object representatives2that model the runtime
objects that these variables are bound to. The treatment of
variable bindings is quite intricate, but has been presente d in
previous work [10]. Hence, we ease our presentation by ab-
stracting from variable bindings and instead assuming that
we perform typestate analysis only for one single object rep -
resentative. For the remainder of this paper we therefore as -
sume that a conﬁguration is just a set of automaton states,
without any binding. The author’s dissertation [7] gives a
complete treatment including variable bindings, with proo f.
2Object representatives [11] transparently model runtime
objects at compile time. Two representatives are equal when
they must-alias, i.e., represent the same runtime objects.
In addition, they support a must-not-alias operation. Ob-
ject representatives combine ﬂow-insensitive whole-prog ram
points-to sets with intra-procedural ﬂow-sensitive alias in-
formation. We compute points-to sets with Sridharan and
Bod´ ık’s context-sensitive points-to analysis [21].We ensure condition (2), i.e., not merging state sets, by
simply not merging conﬁgurations at any time. In partic-
ular, we do not merge conﬁgurations at control-ﬂow merge
points: if a conditional execution leads to a conﬁguration c1
on one branch and to c2on another branch then we propa-
gate both c1andc2after both branches have merged.
For eﬃciency, we designed the Nop-shadows Analysis to
compute ﬂow-sensitive analysis information only on an intr a-
procedural level. In particular, our must-alias analysis i s
only intra-procedural. One may think that such an analy-
sis would have to be quite imprecise. However, before we
designed our analysis, we manually investigated the instru -
mentation points that our typestate instrumentation cause s
and found that, in most cases, intra-procedural analysis in -
formation was suﬃcient to determine nop shadows. To take
care of condition (1), i.e., maintain soundness in the prese nce
of inter-procedural control ﬂow, we pair this precise intra -
procedural information with coarse-grained inter-proced ural
summary information that can be computed relatively eﬃ-
ciently. The results that we present in Section 5 conﬁrm
that this solution is both precise and eﬃcient.
In line with our example from Section 3, the Nop-shadows
Analysis computes for every shadow-bearing method both a
forward- and a backward-analysis pass. The forward and
backward analysis are both instances of a general worklist
algorithm that we show as Algorithm 1. In this algorithm,
the syntax f[x/mapsto→y] denotes the function that is equal to f
on all values v, except for x, in which case it returns y:
f[x/mapsto→y] :=λv(
y ifv=x
f(v) otherwise
We will explain the internal workings of this algorithm in
Section 4.2. First we will explain how we initialize the algo -
rithm’s parameters.
Algorithm 1 worklist (initial ,succcfg,succext, δ)
1:wl:=initial
2:before :=after:=λstmt.∅
3:while wlnon-empty do
4: pop job ( stmt,cs) from wl
5:before :=before [stmt/mapsto→before (stmt)∪cs]
6:cs′:=(
csifshadows (stmt) =∅
∅otherwise
7:forc∈cs,shadow ∈shadows (stmt)do
8: c′:=[
q∈c{δ(q,label(shadow ))}
9: cs′:=cs′∪ {c′}
10:end for
11: csnew:=cs′−after(stmt)
12:ifcsnewnon-empty then
13: after:=after[stmt/mapsto→after(stmt)∪csnew]
14: forstmt′∈succcfg(stmt)do
15: wl:=wl∪ {(stmt′, csnew)}
16: end for
17: forstmt′∈succext(stmt)do
18: wl:=wl[stmt′/mapsto→wl(stmt′)∪
reaching (csnew,relatedShadows (stmt))]
19: end for
20:end if
21:end while4.1 Initializingthe worklistalgorithm
The initialization depends on whether we perform a for-
ward or backwards analysis. The ﬁrst argument to the al-
gorithm is a set initial of initial “jobs”. A job is a pair
(stmt,cs), associating a statement stmtwith a set csof con-
ﬁgurations, i.e., with a set of sets of automaton states.
For the forward analysis we must initialize the algorithm
with conﬁgurations that model all possible control ﬂow that
could have occured before entering the current method m,
but without having executed malready. (Later in this sec-
tion, we explain how we soundly handle re-executions of m
as well, trough a special successor function succext.)
Ifq0is the initial state of Mforward andshadowsNotIn (m)
is the set of shadows outside of m, then the set of initial jobs
associates with m’s entry statement eall conﬁgurations that
are reachable from the initial conﬁguration {q0}by execut-
ing any of the shadowsNotIn (m):
initial :=˘
(e,reaching ({q0},shadowsNotIn (m)) )}
Here we deﬁne for every set csof conﬁgurations and ssof
shadows reaching (cs,ss) as the smallest set of conﬁgurations
for which holds:
•cs⊆reaching (cs,ss), and
• ∀c∈reaching (cs,ss)∀a∈l:
{δ(q, a)|q∈c} ∈reaching (cs,ss).
Note that this ﬁxed-point computation is ﬂow-insensitive:
we do not consider the order in which the shadows in sscould
execute. This allows us to compute reaching very eﬃciently.
For the backwards analysis, we generate initial conﬁgura-
tions in a similar but not identical way. A violating trace ca n
only start at the beginning of the program, but it can end
(causing a violation) in the current method mitself, or in
another method (either with mon the call stack or not). We
generate initial jobs to cover these three cases. Due to spac e
limitations we give a formal deﬁnition in the accompanying
dissertation [7, Section 5.2.3.4].
The second and third arguments to the algorithm, succcfg
andsuccext, are successor functions that model the possi-
ble control ﬂow within the current method m, respectively
outside of m. Figure 5 visualizes both successor functions.
We show the current method m, herefoo, as a box. The
method contains two invoke statements. The ﬁrst statement
resembles a potentially-recursive call (including mutual ly-
recursive calls), the second one a provably non-recursive c all.
The dashed arrows denote the successor function succcfg,
which is given by m’s control-ﬂow graph. This graph allows
us to soundly handle control ﬂow caused by conditionals,
loops and exceptions. Solid arrows show the second, inter-
procedural-successor function, succext. During the execution
ofm, invoke expressions within mmay cause methods to be
called. These calls either can or cannot transitively perfo rm
a recursive call back into m. When the call may be recursive,
then conﬁgurations that we computed for this call site can
reach m’s entry statement, see arrow (1). Conversely, for
conﬁgurations that we computed for any of m’s exit state-
ments, we need to propagate these conﬁgurations back to
any potentially-recursive call site within m, see (2). At com-
pile time, we can usually only determine that a method call
may be recursive, not that it must be. Hence, we also need
to propagate conﬁgurations from the call site to after it-
self, see (3a). For calls that are provably not recursive (aspublic void foo() {
}x.foo()
y.bar()◦
◦◦
◦
◦
◦(3a)
(3b)(4)
(2)(1)method entry
method exitpotentially-
recursive
call site
provably
non-recursive
call site
Figure 5: Functions succcfg(dashed) & succext(solid)
determined by a call graph), it suﬃces to propagate conﬁg-
urations past the call site itself, see (3b). Lastly, we need to
take into account the case in which method mreturns (ei-
ther normally or by throwing an exception— succcfghandles
both cases), and then re-executes. To model this case we
propagate conﬁgurations from m’s exit(s) to its entry, (4).
In line with Figure 5, we deﬁne succextas follows. Let
heads(m) be the set of entry statements of m, and tails(m)
the set of m’s exit statements3. Further, let recCall (m)
be the set of potentially-recursive invoke statements of m,
andnonRecCall (m) the set of provably non-recursive invoke
statements respectively. Then:
succext:=
λs.8
>>><
>>>:succcfg(s) if s∈nonRecCall (m)
heads(m)∪succcfg(s) if s∈recCall (m)
succcfg(recCall (m))∪heads(m) ifs∈tails(m)
∅ otherwise
For the backward analysis we revert both successor func-
tions the succcfgandsuccext, i.e., we ﬂip all their edges,
before passing them to our worklist algorithm. This causes
the backward analysis to actually compute backwards.
The fourth and ﬁnal parameter to our worklist algorithm
isδ, the automaton’s transition function. For the forward
analysis we use the transition function of Mforward . For
the backward analysis we revert this function, ﬂipping all
edges. Eﬀectively, this yields a non-deterministic versio n
ofMbackward . This is suﬃcient because Algorithm 1 deter-
minizes states on-the-ﬂy (see line 8). By not determinizing
Mbackward ahead-of-time, we ensure that both the forward
and the backward analyis act on the same state sets; just
the transition function diﬀers. This, in turn, makes it easi er
to determine nop shadows.
4.2 Actual worklistalgorithm
Algorithm 1 ﬁrst initializes its worklist wlwith the set
of initial jobs, as explained above. The algorithm further
3Usually, heads(m) will be a singleton set but because our
backwards analysis operates on a reversed control-ﬂow grap h
where heads become tails and tails become heads, heads(m)
can contain more than one element in this setting.initializes two mappings before andafterthat store the con-
ﬁgurations that have been computed so far before, respec-
tively after each statement. These sets allow us to perform
a terminating ﬁxed point iteration.
Next, the algorithm iterates through its worklist. For ev-
ery job ( stmt,cs), the algorithm ﬁrst updates stmt’s before-
set. Then, when a statement holds no shadow, we just leave
the conﬁgurations unchanged (line 6 in Algorithm 1). Other-
wise, we compute (line 7), for every new conﬁguration c∈cs
andshadow atstmt, successor conﬁgurations using the sup-
plied transition function δ. (In Clara , programmers de-
scribe events through AspectJ [3] pointcuts. Although sel-
dom the case, pointcuts can overlap, thereby causing one
single statement to be associated with multiple shadows.)
To compute the transition, the algorithm accesses the shad-
ows’s unique label label(shadow ). (In our running example,
this label could be “close”, “reconnect” or “write”.) To al-
low the analysis to later-on compare state labels of Mforward
with the state-set labels that Mbackward uses, we determinize
state machines on-the-ﬂy: line 8 computes the unique set of
successor states.
The algorithm then updates stmt’s after-set and associates
new jobs with two diﬀerent kinds of successor statements.
First, in lines 14–16, the algorithm adds new jobs containin g
the successor conﬁgurations csnewfor any statement that is a
successor of stmtinm’s control-ﬂow graph, as determined by
succcfg. Lines 17–19 use the the external-successor function
succextto handle inter-procedural control ﬂow.
When propagating conﬁgurations along a succext-edge, it
is not correct to just copy the conﬁgurations from the edge’s
source to it’s target. Note that between any two executions
ofm, other methods may execute and cause transitions in
the monitoring state machine. To soundly model these po-
tential transitions by “other methods”, Algorithm 1 asso-
ciates in line 18 with any inter-procedural successor not ju st
the set of new conﬁgurations csnewbut instead the set of
conﬁgurations reaching (csnew,relatedShadows (stmt)). We
deﬁned the function reaching already above. The function
relatedShadows (stmt) computes the set of all shadows re-
lated to stmt. We deﬁne this set as follows. For any in-
voke statement stmt(potentially recursive or not), the set
relatedShadows (stmt) contains all shadows in all methods
transitively reachable through stmt, except for the ones in
mitself. After all, these are all the shadows that one can
reach before reaching m’s entry statement again. Otherwise,
i.e., if stmtis a tail of m, then relatedShadows (stmt) con-
tains all shadows in the program, except for the ones in m.
(Our implementation further narrows down related shadows
by comparing each shadow’s variable binding to the binding
stored in the conﬁguration csnew.)
It is worthwhile noting that, because we compute the
expression reaching (csnew,relatedShadows (stmt)) for each
statement separately, we gain a certain amount of context-
sensitivity. While shadows inside a certain method m′(with
m′/ne}ationslash=m) may be relevant to one statement of mthey may
be irrelevant to other statements in m, and by recomputing
the above function we properly distinguish such cases.
4.3 Removing nopshadows
In addition to the Nop-shadows Analysis, Clara also con-
tains implementation of a syntactic Quick Check and a ﬂow-
insensitive, pointer-based Orphan-shadows Analysis [7, 9 ].
Because these analyses do not take control-ﬂow into account ,they take only milliseconds once points-to information has
been computed. Therefore, before executing the more ex-
pensive Nop-shadows Analysis, we execute the Quick Check
and the Orphan-shadows Analysis ﬁrst. Then, if shadows
remain enabled, we compute the Nop-shadows Analysis for
every shadow-bearing method. The analysis information di-
rectly provides us with source ,target andfutures for every
statement. We use this information to identify and disable
a nop shadow if possible, and then re-iterate until we can
ﬁnd no further nop-shadows for this method. In our bench-
mark set we had to iterate ten times or less for all but four
methods. When we reach the ﬁxed point, we proceed with
the next method. When all methods are processed, we ap-
ply the ﬂow-insensitive Orphan-shadows Analysis again and
then re-iterate the whole Nop-shadows Analysis. This is be-
cause disabling a shadow in one method may render shadows
in other methods irrelevant. It seems to be always suﬃcient
to iterate this outer loop two to three times. When this loop
reaches a ﬁxed point we stop.
5. EXPERIMENTS
To validate our approach, we veriﬁed a set of twelve type-
state properties over ten benchmark programs of the Da-
Capo benchmark suite [6]. This lead to 120 property/bench-
mark combinations. 43 of these combinations (36%) were
“interesting” to us in the sense that shadows remained after
applying the ﬁrst two, previously published, analysis stag es.
The 43 combinations comprised eight out of the original
twelve properties. Table 1 explains these properties. We
applied the Nop-shadows Analysis to these 43 combinations.
First, we were interested in comparing the Nop-shadows
Analysis to a traditional typestate analysis that only has a
forward component. As we will explain in Section 6, one
cannot use the latter to identify nop shadows and optimize
runtime monitors, but of course one can use both analyses
to determine potentially property-violating program poin ts,
i.e., program points at which the abstraction reaches a ﬁnal
state. We therefore modiﬁed our analysis to run the for-
ward pass only, recording all potentially property-violat ing
program points. Then we ran the Nop-shadows Analysis as
we described it earlier, with all re-iterations, disabling nop
shadows as they are identiﬁed, and recording as well all po-
tentially property-violating program points. Interestin gly,
we discovered that, for our benchmark set, the program
points completely coincided. Hence, we can state that the
backwards pass and the reiteration do not help with identi-
fying these program points. (However, they are crucial for
identifying nop shadows on the preceding execution.)
Next we were interested in seeing what fraction of shad-
ows the Nop-shadows Analysis manages to identify as nop
shadows. Table 2 summarizes our analysis results. The frac-
tion of shadows that our analysis identiﬁed as nop shadows
appears in white. In gray we show the fraction of shadows
which are known to trigger actual violations at runtime. The
remaining black slice represent shadows that remain active
even after analysis, either due to analysis imprecision or d ue
to actual property violations.
For 18 out of these 43 combinations (41%), our novel Nop-
shadows Analysis was able to identify all shadows as irrele-
vant and therefore proved that the program cannot violate
the stated property. These cases appear as all white cir-
cles. In four other cases, shadows remained enabled, but
only because they do trigger a property violation. TheseFailSafeEnum do not update a vector while iterating
over it
FailSafeEnumHT do not update a hash table while iter-
ating over its elements or keys
FailSafeIter do not update a collection while iter-
ating over it
FailSafeIterMap do not update a map while iterating
over its keys or values
HasNextElem always call hasMoreElements before
nextElement on an Enumeration
HasNext always call hasNext before calling next
on an Iterator
Reader do not use a Reader after its Input-
Stream was closed
Writer do not use a Writer after its Output-
Stream was closed
Table 1: Relevant typestate properties and their names
cases contain gray but no black fragments. In other words,
the analysis gave exactly the correct result, with no false
positives, in half of the cases. In three cases, the analysis
failed to identify any nop shadow (black circles).
In the remaining 18 cases, the analysis removed a some-
times signiﬁcant amount of shadows. This may speed up
runtime monitoring for these cases, depending on whether
the test run exercises these shadows a lot. For our exper-
iments we used monitoring aspects generated from trace-
matches [2]. Table 2 gives qualitative information about
the residual monitor’s runtime overhead through the ring
that surround each circle. (The dissertation [7] gives the f ull
data.) Interestingly, while there is some correlation betw een
the number of remaining shadows and the runtime overhead
that these shadows cause, the correlation is not one-to-one .
For instance, in jython-FailSafeIter, there remain 112 sha d-
ows, opposed to just 16 in the case of lusearch-FailSafeIter .
Nevertheless, lusearch does show a perceivable runtime ove r-
head but jython does not. We conclude that the positive
eﬀect that the removal of a shadow smay have on the mon-
itoring overhead depends to some extend on how often the
program under test would execute sat runtime.
Our analysis works well on the antlr, fop, hsqldb, luin-
dex, lusearch and xalan benchmarks. Most of the potential
false positives (black in the ﬁgure) appear only because the
benchmarks use reﬂection. Due to a known deﬁciency [1],
Java’sCloneable interface contains no public declaration
of aclone() method. Therefore, Java’s type system may
prevent clients from calling clone() even onCloneable ob-
jects. chart uses reﬂection to call the clone() method on
objects that implement the Cloneable interface. Because
chart clones collections, our points-to analysis has to saf ely
assume that the collections could be of any type, including
EmptySet , which, as a singleton object, is stored in a static
ﬁeld, causing our analysis to loose all context information .
bloat, jython and pmd cause similar problems.
There appear to be few cases where our analysis is too im-
precise because of its design. For example, two actually ir-
relevant ﬁnal shadows remain enabled in hsqldb with Reader
and Writer. These false positives occur because xalan uses
diﬀerent methods to open, close and write to streams. A
fully inter-procedural analysis could rule out possible vi ola-
tions in these cases. However, we found that, due to its intra -
procedural nature, the Nop-shadows Analysis has an inter-
esting property: the analysis revealed missing pre-condit ions
on xalan’s methods. For instance, the write-calling method
is missing the pre-condition that the argument ﬁle shouldantlr bloat chart fop hsqldb jython luindex lusearch pmd xalan
FailSafeEnum0
36
744
470
50
10
FailSafeEnumHT26
303
361
760
150
5
FailSafeIter830
922149
160112
1160
2716
36287
302
FailSafeIterMap444
44649
49OOME133
151204
314
HasNextElem0
860
80
634
470
160
60
61
3
HasNext452
56548
820
824
310
120
22184
250
Reader0
143
34
40
24
Writer35
4415
1910
100
7
Table 2: Shadows classiﬁed by our analysis. White slices: sh adows that the Nop-shadows Analysis identiﬁed as irrelevan t.
Black slices: shadows that we fail to identify as irrelevant , due to analysis imprecision or an actual violation. Gray sl ices:
actual property violations that we found through manual ins pection. The outer rings represent the residual monitor’s r untime
overhead. Solid: overhead ≥15%, dashed: overhead <15%, dotted: no overhead. OOME =OutOfMemoryError
not be in state “closed”. In future work we plan to use this
information to support program understanding and to fur-
ther enhance precision.
Detected property violations. When manually in-
specting the remaining shadows, we found several actual
property violations. bloat violates Writer because it con-
tains a method that writes to a ﬁle handle that it then
closes. When called multiple times, this method will violat e
the property. We could not conﬁrm whether certain runs of
bloat may actually call this method multiple times. jython
sometimes violates Reader by closing a stream prematurely.
jython then catches the resulting exception and returns nul l.
xalan violates HasNextElem by calling nextElement with-
out a preceding call to hasMoreElements . Nevertheless, the
program is safe because it checks the size of the underly-
ing vector to assure that the calls are legal. The property
speciﬁcation is too simplistic in this setting. Several ben ch-
marks violate FailSafeEnum and FailSafeEnumHT. These
benchmarks do indeed modify vectors (or hash tables) while
iterating over them. This can lead to unexpected behavior.
With iterators this does not usually happen because itera-
tors have fast-fail semantics and will throw a Concurrent-
ModificationException in such situations. luindex violates
the FailSafeIter pattern. This error probably remained un-
detected because it only occurs on quite unlikely execution
paths. The author’s dissertation [7] provides more details .
Analysis time. Our analysis time is clearly dominated
by the time it takes to compute the supporting analyses
that the Nop-shadows Analysis requires. Constructing a cal l
graph and context-sensitive points-to sets took about two
and a half minutes on average. The Nop-shadows Analysis
itself took under 50 seconds on average. This time includes
all re-iterations of the Orphan-shadows Analysis and Nop-
shadows Analysis that Clara performs. In 90% of the cases,
the analysis ﬁnished in under one minute. By far the worst
case was bloat-FailSafeIter, for which this analysis stage took
19 minutes. bloat is notoriously hard to analyze [8, 9, 20].
Limitations andthreatsto validity.
We identiﬁed the following limitations of our approach.
All DaCapo benchmarks load classes using reﬂection. Static
analyses like ours have to be aware of these classes so thatthey can construct a sound call graph. We wrote an As-
pectJ aspect that would print at every call to forName and
a few other reﬂective calls the name of the class that this
call loads and the location from which it is loaded. We fur-
ther double-checked with Ondˇ rej Lhot´ ak, who compiled suc h
lists of dynamic classes earlier. We then provided Soot [23]
(which is part of Clara ) with this information. The result-
ing call graph is sound for the program runs that DaCapo
performs. Obtaining a call graph that is sound for all runs
may be challenging for programs that use reﬂection.
For eclipse we were unable to determine where dynamic
classes are loaded from. eclipse loads classes not from JAR
ﬁles but from “resource URLs”, which eclipse resolves inter -
nally, usually to JAR ﬁles within other JAR ﬁles. Soot cur-
rently cannot load classes from such URLs and that is why
we omit eclipse in our experiments. The jython benchmark
generates code at runtime, which it then loads. We did not
analyze this code and so made the unsafe assumption that
this code would not cause any typestate changes.
Otherwise, the internal validity of our experiments is high
because we directly measure the number of ﬁnal shadows be-
fore and after the analysis. The ﬁnal shadows are exactly the
points that programmers would ﬁrst inspect when checking
possible property violations. Hence, reducing the number
of ﬁnal shadows will reduce the burden on the programmer.
This is especially true when eliminating all ﬁnal shadows,
thus proving that the program cannot violate the property.
To measure the runtime overheads precisely, we extended
the DaCapo harness with a custom driver class. With this
driver class, DaCapo ﬁrst executes a warm-up run and then
re-runs the benchmark multiple times until the relative sta n-
dard deviation of the determined runtimes drops below 3%
(but at least 5 times and at most 20 times). Then we re-
port the arithmetic mean of these runs. DaCapo’s stan-
dard driver only measures a single benchmark run, which
has caused misleading results for us in the past.
The external validity is limited by our choice of bench-
marks. However, the DaCapo benchmarks are a realistic,
representative set of medium-sized to large-scale applica -
tions. The suite contains both “well-behaved” benchmarks
that are free of reﬂection and benchmarks that are harder to
analyze due to reﬂection. Our analysis excels on the former,however, further work is required to handle the latter more
eﬀectively. We plan to address these problems by simulating
reﬂection in a more ﬁne-grained manner.
6. RELATED WORK
Strom and Yemini [22] were the ﬁrst to suggest the concept
of typestate analysis. In the last few years, researchers ha ve
presented several new approaches with varying cost/preci-
sion trade-oﬀs. In the following, we describe the approache s
that are most relevant to our work.
Type-systembasedapproaches.
Type-system based approaches deﬁne a type system and
implement a type checker. This is to prevent programmers
from compiling a potentially property-violating program i n
the ﬁrst place and gives the advantage of strong static guar-
antees. On the other hand, the type checker may reject
useful programs that statically appear to violate the state d
property but will not actually violate the property at run-
time. Our approach allows the programmer to deﬁne a pro-
gram that may violate the given safety property. Our analy-
sis then tries to verify that the program is correct, and when
this veriﬁcation fails it delays further checks until runti me.
Bierhoﬀ and Aldrich [5] present a type-system based ap-
proach that enables the checking of typestate properties in
the presence of aliasing. The author’s approach aims at
being modular, and therefore abstains from potentially ex-
pensive whole-program analyses like ours. To be able to
reason about aliases nevertheless, Bierhoﬀ and Aldrich as-
sociate special access permissions with references. Acces s
permissions allow the type checker to reason about a refer-
ence locally. The author’s current approach assumes that
a program contains information about access permissions
and also typestate changes in the form of special program
annotations. Our approach does not require any program
annotations; it is fully automatic.
DeLine and F ¨ahndrich’s approach [14] is similar in ﬂavor
to Bierhoﬀ and Aldrich’s but uses a more restrictive abstrac -
tion of aliases that allows for less ﬂexible calling convent ions
for typestate-changing methods. The authors implemented
their approach in the Fugue tool for specifying and check-
ing typestates in .NET-based programs. As in Bierhoﬀ and
Aldrich’s approach, DeLine and F ¨ahndrich assume that a
programmer (or tool) has annotated the program under test
with information about how calls to a method change the
typestate of the objects that this method references.
Static analysisapproaches.
Fink et al. present a static analysis of typestate proper-
ties [17]. Their approach, like ours, uses a staged analysis
which starts with a ﬂow-insensitive pointer-based analysi s,
followed by ﬂow-sensitive checkers. The authors’ analyses al-
low only for speciﬁcations that reason about a single object
at a time, while we allow for the analysis of multiple inter-
acting objects. Fink et al.’s algorithms only determine“ﬁn al
shadows” that complete a property violation (like “write” i n
our example) but not shadows that initially contribute to a
property violation (e.g. “close”) or can prevent a property
violation (e.g. “reconnect”). Therefore, these algorithm s
are unsuitable for generating residual runtime monitors, i .e.,
they can be used for a purely static analysis only.1voidfoo(Connection c) {
2 c. close ();
3 if(?) {
4 c.reconnect();
5 }
6 c.write (..);
7}
(a)c. close()
if(?)
c.reconnect()
c.write (..)
(b)
Figure 6: Example exposing unsoundness in earlier hybrid
typestate analyses
Hybridanalysisapproaches.
In own previous work [10] we presented a hybrid type-
state analysis that was, like the Nop-shadows Analysis, als o
ﬂow-sensitive on an intra-procedural level only, and used a
ﬂow-insensitive abstraction of the remainder of the progra m.
However, unlike the Nop-shadows Analysis, the earlier anal -
ysis used a forward-analysis only. A forward analysis can
only approximate the possible source andtarget states of a
statement sbut not the futures .
Consider the property-violating program in Figure 6a. Re-
member that a correct runtime monitor must not only ob-
serve events at property-violating shadows like the “close ”
shadow at line 2 and the “write” shadow at line 6, but also
at shadows that may prevent a violation, like the“reconnect ”
shadow at line 4. A design ﬂaw caused our earlier forward
analysis to mistakenly disable certain violation-prevent ing
shadows like the reconnect shadow in this example. To de-
termine relevant shadows, this earlier analysis used what w e
called a “shadow history”. The shadow history at a state-
ment sis the set of all shadows on the control ﬂow that
reaches s. When determining that the program may reach an
error state at s, the analysis would then commit the shadow
history at sto a global set of “relevant shadows” that need
to be monitored at runtime.
In Figure 6b we show the control-ﬂow graph for the exam-
ple program. As the graph shows, due to the if-statement,
the analysis will reach the write statement along two diﬀer-
ent branches. Along the left branch, the analysis determine s
that the connection is in its “connected” state when being
written to, and therefore no shadow history is committed, as
no violation can occur. Along the right branch, the analysis
determines that the connection will be in state“closed”whe n
reaching the write at line 6. Hence, the analysis will com-
mit the shadow history. However, the shadow history along
this branch contains the disconnect and write statements
only, because the reconnect occurs on the other branch! The
residual runtime monitor for this property will therefore m iss
any possible reconnect events, and may therefore signal fal se
runtime warnings. We proved that our novel Nop-shadows
Analysis causes neither false warnings nor missed violatio ns.
Naeem and Lhot´ ak present a fully context-sensitive and
ﬂow-sensitive inter-procedural whole-program analysis f or
typestate-like properties of multiple interacting object s [20].
This analysis can be seen as a generalized version of our
own earlier analysis [10]. Naeem and Lhot´ ak’s analysis is
fully inter-procedural. This can yield enhanced precision
in cases where combinations of objects that are relevant to
a given speciﬁcation are used by multiple methods. Ourbenchmark set showed some instances where this additional
information would have been helpful, but not many. It even
holds that, although our analysis is intra-procedural only ,
there are some instances where our analysis is more pre-
cise than Naeem and Lhot´ ak’s. This is due to the highly
context-sensitive points-to sets that we compute. It is im-
portant to note that Naeem and Lhot´ ak also use shadow
histories to determine relevant instrumentation points. U n-
fortunately, their analysis therefore suﬀers from the same
unsoundness problem that we described above. Naeem and
Lhot´ ak had proven their entire analysis sound except for th e
use of shadow histories [19].
Dwyer and Purandare use existing typestate analyses to
specialize runtime monitors [16]. Their work identiﬁes “sa fe
regions”in the code using a static typestate analysis. Safe re-
gions can be methods, single statements or compound state-
ments (e.g. loops). A region is safe if its deterministic tra n-
sition function does not drive the typestate automaton into
a ﬁnal state. A special case of a safe region would be a region
that does not change the automaton’s state at all—an“iden-
tity region”. For regions that are safe but no identity regio ns,
the authors summarize the eﬀect of this region and change
the program under test to update the typestate with the
region’s eﬀects all at once when the region is entered. This
has the advantage that the analyzed program will execute
faster because it will execute fewer transitions at runtime .
However, unlike our approach, the author’s analysis does
not aid programmers who wish to inspect their code man-
ually. The fact that the author’s transformation changes
the points at which transitions occur makes it even harder
for programmers to manually inspect these program points.
Dwyer and Purandare’s approach is, although hybrid, not
based on shadow histories and hence we have no reason to
believe that it is unsound. The approach cannot generally
handle groups of multiple interacting objects.
7. CONCLUSION
We have presented a precise ﬂow-sensitive and partially
context-sensitive typestate analysis that can handle type -
state speciﬁcations that refer to multiple interacting obj ects,
and which generates residual runtime monitors. Using an
additional backwards pass, the analysis computes classes
of equivalent states and disables transitions between such
states. This two-pass approach allows for precise local rea -
soning directly at relevant program points. Although the
analysis is lightweight and eﬃcient, it is also precise, exa ctly
telling apart property-violating program locations from i r-
relevant locations in more than half of the cases.
Acknowledgements. We thank Patrick Lam for inspir-
ing this research and for many fruitful discussions. Andrea s
Sewe helped to improve the quality of a draft of this paper.
8. REFERENCES
[1] Bug-database entry regarding “Cloneable”. http://bugs.
sun.com/bugdatabase/view_bug.do?bug_id=4098033 .
[2] Chris Allan, Pavel Avgustinov, Aske Simon Christensen,
Laurie Hendren, Sascha Kuzins, Ondˇ rej Lhot´ ak, Oege
de Moor, Damien Sereni, Ganesh Sittampalam, and Julian
Tibble. Adding Trace Matching with Free Variables to
AspectJ. In OOPSLA , pages 345–364, October 2005.
[3] AspectJ. http://eclipse.org/aspectj/ .
[4] Pavel Avgustinov, Aske Simon Christensen, Laurie
Hendren, Sascha Kuzins, Jennifer Lhot´ ak, Ondˇ rej Lhot´ ak ,
Oege de Moor, Damien Sereni, Ganesh Sittampalam, andJulian Tibble. abc: An extensible AspectJ compiler. In
AOSD , pages 87–98, March 2005.
[5] Kevin Bierhoﬀ and Jonathan Aldrich. Modular typestate
checking of aliased objects. In OOPSLA , pages 301–320,
October 2007.
[6] S. M. Blackburn, R. Garner, C. Hoﬀman, A. M. Khan,
K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg,
D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump,
H. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovic,
T. VanDrunen, D. von Dincklage, and B. Wiedermann. The
DaCapo benchmarks: Java benchmarking development and
analysis. In OOPSLA , pages 169–190, October 2006.
[7] Eric Bodden. Verifying ﬁnite-state properties of large-scale
programs . PhD thesis, McGill University, June 2009.
[8] Eric Bodden, Feng Chen, and Grigore Ro¸ su. Dependent
advice: A general approach to optimizing history-based
aspects. In AOSD , pages 3–14, March 2009.
[9] Eric Bodden, Laurie J. Hendren, and Ondˇ rej Lhot´ ak. A
staged static program analysis to improve the performance
of runtime monitoring. In ECOOP , volume 4609 of LNCS ,
pages 525–549, 2007.
[10] Eric Bodden, Patrick Lam, and Laurie Hendren. Finding
Programming Errors Earlier by Evaluating Runtime
Monitors Ahead-of-Time. In FSE, pages 36–47, November
2008.
[11] Eric Bodden, Patrick Lam, and Laurie Hendren. Object
representatives: a uniform abstraction for pointer
information. In Visions of Computer Science - BCS
International Academic Conference . British Computing
Society, September 2008.
[12] J. A. Brzozowski. Canonical regular expressions and
minimal state graphs for deﬁnite events. In Symposium on
Mathematical Theory of Automata , pages 529–561.
Polytechnic Institute of Brooklyn, 1962.
[13] Feng Chen and Grigore Ro¸ su. MOP: an eﬃcient and
generic runtime veriﬁcation framework. In OOPSLA , pages
569–588, October 2007.
[14] Robert DeLine and Manuel F ¨ahndrich. Typestates for
objects. In ECOOP , volume 3086 of LNCS , pages 465–490,
June 2004.
[15] Matthew B. Dwyer, George S. Avrunin, and James C.
Corbett. Patterns in property speciﬁcations for ﬁnite-sta te
veriﬁcation. In ICSE, pages 411–420, May 1999.
[16] Matthew B. Dwyer and Rahul Purandare. Residual
dynamic typestate analysis: Exploiting static analysis
results to reformulate and reduce the cost of dynamic
analysis. In ASE, pages 124–133, May 2007.
[17] Stephen Fink, Eran Yahav, Nurit Dor, G. Ramalingam,
and Emmanual Geay. Eﬀective typestate veriﬁcation in the
presence of aliasing. In ISSTA , pages 133–144, July 2006.
[18] Hidehiko Masuhara, Gregor Kiczales, and Chris Dutchyn .
A compilation and optimization model for aspect-oriented
programs. In CC, volume 2622 of LNCS , pages 46–60, April
2003.
[19] Nomair A. Naeem and Ondˇ rej Lhot´ ak. Extending typesta te
analysis to multiple interacting objects. Technical repor t,
University of Waterloo, 04 2008. CS-2008-04.
[20] Nomair A. Naeem and Ondˇ rej Lhot´ ak. Typestate-like
analysis of multiple interacting objects. In OOPSLA , pages
347–366, October 2008.
[21] Manu Sridharan and Rastislav Bod´ ık. Reﬁnement-based
context-sensitive points-to analysis for Java. In PLDI,
pages 387–400, June 2006.
[22] R. E. Strom and S. Yemini. Typestate: A programming
language concept for enhancing software reliability. TSE,
12(1):157–171, January 1986.
[23] Raja Vall´ ee-Rai, Phong Co, Etienne Gagnon, Laurie
Hendren, Patrick Lam, and Vijay Sundaresan. Soot - a
Java bytecode optimization framework. In CASCON ,
page 13. IBM Press, 1999.