Beyond Boolean Product-Line Model Checking:
Dealing with Feature Attributes and Multi-features
Maxime Cordy,* Pierre-Yves Schobbens, Patrick Heymans
University of Namur, Belgium.
fmcr, pys, pheg@info.fundp.ac.beAxel Legay
IRISA/INRIA Rennes, France.
University of Li `ege, Belgium.
axel.legay@inria.fr
Abstract ‚ÄîModel checking techniques for software product
lines (SPL) are actively researched. A major limitation they
currently have is the inability to deal efÔ¨Åciently with non-Boolean
features and multi-features. An example of a non-Boolean feature
is a numeric attribute such as maximum number of users which
can take different numeric values across the range of SPL
products. Multi-features are features that can appear several
times in the same product, such as processing units which number
is variable from one product to another and which can be
conÔ¨Ågured independently. Both constructs are extensively used
in practice but currently not supported by existing SPL model
checking techniques. To overcome this limitation, we formally
deÔ¨Åne a language that integrates these constructs with SPL
behavioural speciÔ¨Åcations. We generalize SPL model checking
algorithms correspondingly and evaluate their applicability. Our
results show that the algorithms remain efÔ¨Åcient despite the
generalization.
Index Terms ‚ÄîSoftware Product Lines; Numeric Features;
Feature Cardinalities; Model Checking; Semantics; Tools
I. I NTRODUCTION
Software Product Line (SPL) engineering is an increasingly
widespread software development paradigm in which similar
software products are designed and developed as a family
to make economies of scale [1]. A key challenge in SPL
engineering is the management of the differences between the
products, aka variability . Features are Ô¨Årst-class abstractions
to model and reason on variability. They specify character-
istics that may be present or absent in a product. Relations
between features, like parent-child, implication and exclusion,
are usually captured in a feature model (FM). Since they were
Ô¨Årst introduced by Kang et al. in 1990 [2], FMs became more
sophisticated. For detailed surveys of FM languages see, e.g.,
[3], [4]. In this paper we use TVL [4], one of the latest
incarnations of FMs, due to some of its advantages: high
expressiveness, formal semantics and tool support. A TVL
excerpt is given in Figure 1. TVL and the example are properly
introduced in Section II.
Many SPLs are complex critical systems and variability is
known to be the source of additional complexity. Therefore,
efÔ¨Åcient quality assurance is paramount. Model checking is
an established automated technique for verifying system be-
haviour. As for single systems, model checking techniques for
SPLs are actively researched [5]‚Äì[10]. Our past work [7]‚Äì[9]
was concerned with one of the major challenges in SPL model
* FNRS research fellowchecking: as the number of features grows, the number of
products increases exponentially. We thus proposed various
techniques for efÔ¨Åcient SPL model checking. We introduced
Featured Transition Systems (FTS), a mathematical formalism
to model the behaviour of SPL products in a concise man-
ner [7]. We also designed efÔ¨Åcient algorithms that identify
which products exhibit undesired behaviour. However, FTS
are a fundamental formalism, not meant to be used directly by
engineers. We thus proposed high-level speciÔ¨Åcation languages
to be used on top of FTS, notably fPromela [11], an SPL-
speciÔ¨Åc dialect of Promela [12]. Given the large number of
different products in an SPL, it is unrealistic to describe their
behaviour separately. Instead, our languages associate optional
behaviour with features that must (not) be present to enable
it.
A fundamental limitation of existing SPL model checking
approaches, including ours, is that they do not deal with
numeric features, nor features appearing several times in a
product, viz.multi-features1. Numeric (as opposed to purely
Boolean) features occur in FMs in the form of attributes
associated with features. An example could be Maximum
number of users which can take different numeric values
across the range of products. The multi-feature construct could
be used to represent, e.g., processing units which number
is variable from one product to another and which can be
conÔ¨Ågured independently. A recent survey, dubbed by our
own experience, showed that engineers commonly need these
constructs [15]. To transfer of our model checking techniques
to industry, we thus have to support them. Despite evidence of
their usefulness in practice, no SPL modelling tool currently
supports multi-features [4], and SPL model checking tools
support neither numeric nor multi-features.
In this paper, we propose a combined formalism that inte-
grates TVL with fPromela to model the behaviour of SPLs
with numeric attributes and multi-features. With the addition
of attributes, optional behaviour can be made dependent not
only on the presence or absence of features, but also on the sat-
isfaction of arithmetic constraints over attributes. This implies
a generalization of the underlying formalism, viz.FTS, and
its associated model checking algorithms. We implemented
the complete method on top of SNIP, an FTS-based model
checker [11]. The addition of arithmetic constraint solving
1Sometimes misleadingly referred to as clones in the literature [13], [14].978-1-4673-3076-3/13/$31.00 c2013 IEEE ICSE 2013, San Francisco, CA, USA472
naturally lead us to use SatisÔ¨Åability Modulo Theory (SMT)
solvers. Still, those are more computationally expensive than
solutions for purely Boolean satisÔ¨Åability. Our experiments
show that while multi-feature support does not constitute a
threat to performance, the use of SMT solvers to support
attributes drastically increases veriÔ¨Åcation time. We thus also
propose an alternative solution where attributes are converted
into sets of Boolean variables. This latter approach turns out
to be more efÔ¨Åcient.
Structure of the paper. Section II recalls the necessary
background. In Section III we expose the challenges related to
multi-features and deÔ¨Åne an extension of TVL that supports
them through an array-based semantics. In Section IV, we
deÔ¨Åne multi-features and attributes in fPromela. The imple-
mentation and evaluation are described in Section V. Related
work is discussed in Section VI.
II. B ACKGROUND
The necessary concepts and background are now recalled,
most of them based on our running example which is Ô¨Årst
introduced.
A. Running Example
CFDP is a highly-conÔ¨Ågurable deep-space Ô¨Åle transfer pro-
tocol [16]. In the past, our team helped Spacebel, a Belgian
company, to develop an implementation of CFDP as an
SPL [17]. The original CFDP FM has 98 features. Here,
we consider a small subset of the protocol, i.e., the ack
modes it offers. The corresponding sub-FM has 14 features
and yields 1,058 different valid products. We had to limit
ourselves to this subset because in addition to the variability,
we had to model the behaviour of the protocol‚Äôs features,
which is far more complex. We did that based on the protocol
speciÔ¨Åcation [16] and experimented with various SPL be-
havioural modelling languages. This turned out to be a difÔ¨Åcult
and time-consuming activity. The resulting models describe a
communication scenario where an entity ( e.g., a spacecraft)
has to transfer a message to another one. Depending on the
features of the protocol‚Äôs instance in each entity, properties like
successful transmission may or may not be satisÔ¨Åed during the
transaction. The Ô¨Ånal model has 1,812,652 states.
B. TVL
Figure 1 shows an excerpt of the TVL model of CFDP. The
equivalent graphical representation appears on its right. In both
representations, the FM‚Äôs fundamental structure remains a tree
that reÔ¨Çects the parent-child hierarchy between the features.
At the top of the tree lies the root feature (CFDP ). The root
is always part of a product, regardless of its other features.
A feature may have child features ; for instance, CFDP has
three:Entity ,Message andChannel .Group cardinalities
deÔ¨Åne how many children a feature may have in any given
product. This construct is common in FM languages, including
TVL. Here, it speciÔ¨Åes that CFDP must have exactly three
children, whereas Entity must have one or two.
CFDPEntity [2..2]Messageint sizeChannelSnd_minReliableRcv_minint timeout[1..2][0..1]root CFDP {   group  [3..3]  {      Entity  [2..2]  group  [1..2]  {         Snd_min,         Rcv_min  {            int timeout;         }      },      Message  {         int size;      },      Channel  group  [0..1]  {         Reliable      }   }}[3..3]Group cardinalitiesFeatures cardinalitiesAttributesFig. 1: A subset of the CFDP feature model, shown in TVL
and in a feature diagram.
Group cardinalities are not to be confused with feature
cardinalities [13], [14] which specify how many instances of
a feature may exist in any given product. When no feature
cardinality is given, as is the case for all features in the
model except Entity , the feature is implicitly assumed to
occur at most once in each product. But whenever there is a
need to allow a feature to have multiple instances, an explicit
cardinality is added to the feature itself (as opposed to the
group); we call such a feature a multi-feature . In the excerpt,
the only multi-feature is Entity . It has a feature cardinality
of exactly 2; hence two instances of this feature exist in each
product. In our scenario, each instance corresponds to one
of the two communicating spacecrafts. DeÔ¨Åning Entity as a
multi-feature allows the two spacecrafts to bear a different
conÔ¨Åguration. If Entity was a normal feature, the spacecrafts
should necessarily be identical. In reality, it is more likely that
they are not.
Each instance of Entity must have at least one of the
following child features: Sndmin (sending capabilities)
andRcvmin (receiving capabilities). Under Sndmin and
Rcvmin lie additional features, which have been omitted in
the Ô¨Ågure. Features Rcvmin andMessage both have an
integer attribute . The attribute timeout determines the number
of communication Ô¨Çaws that are allowed before aborting a
communication while size models the number of data packets
that must be sent for the transmission to end. Feature Channel
has an optional child feature Reliable , which speciÔ¨Åes whether
or not the communication channel is reliable.
In addition to the speciÔ¨Åcation of the tree structure, TVL
allows the deÔ¨Ånition of additional constraints ( i.e., Boolean
formulae) over both the features and their attributes (omitted
in the Ô¨Ågure). The semantics of an FM is usually deÔ¨Åned as
the set of valid products, i.e.products whose features satisfy
all the constraints deÔ¨Åned by the FM [3].
C. Featured Transition Systems (FTS)
FTS [7] is the formalism at the core of our model checking
approach. Its main advantage over competing approaches
is that it uses an explicit notion of feature, which brings473performance improvements and allows one to relate errors and
undesired behaviours to the exact set of products where they
occur. FTS are directed graphs whose transitions are anno-
tated with feature expressions ,i.e.Boolean formulae deÔ¨Åned
over the set of features. For instance, the feature expression
Message^Channel represents the set of products that have
the feature Message and the feature Channel ;:Reliable
models the set of products that do not have the feature
Reliable . A product is thus able to execute a transition iff
its set of features satisÔ¨Åes the associated feature expression. A
model-checking algorithm takes that information into account
while looking for error states. It can thus keep track of which
products are able to execute the currently analysed behaviour.
Feature expressions constitute an intuitive and Ô¨Çexible way to
represent variability in behavioural models. In their current
form, FTS do not support expressions over multi-features and
attributes. Formally, they are deÔ¨Åned as follows.
DeÔ¨Ånition 1 An FTS is a tuple (S;Act;trans;I;AP;L; d;
), whereSis a set of states, Actis a set of actions, trans is
a set of transitions, Iis a set of initial states, AP is a set of
atomic propositions, Llabels each state with the propositions
it satisÔ¨Åes,dis an FM, and associates each transition to a
feature expression.
D. SPL Behavioural SpeciÔ¨Åcation in fPromela
There are two kinds of approaches to implement (or model)
SPLs [18]. Compositional methods capture the effects of fea-
tures in isolated modules. A desired product is then obtained
by composing the right set of modules. On the contrary, anno-
tative approaches directly adorn code/models with constraints
over the features, e.g., feature expressions. These annotations
express that parts of the code/model are exclusive to the set
of products satisfying the formulae.
fPromela [11] falls into the latter category. It is an exe-
cutable language based on SPIN‚Äôs input syntax [12]. In an
fPromela model, the behaviour of each process is described
in aproctype structure. Within a process, executable state-
ments are expressed using constructs inspired by imperative
programming. Each of these can be annotated with feature ex-
pressions, such that only the products satisfying a formula are
able to execute the associated statement. Let us consider the
excerpt shown in Figure 2. Features are declared as Boolean
Ô¨Åelds of a user-deÔ¨Åned structure called features . In this
model, two processes of type cfdp_entity are speciÔ¨Åed.
At some point, the speciÔ¨Åcation of a cfdp_entity splits
into two parts: one for the products satisfying the feature
expressionSndmin and one for the others.
The semantics of an fPromela model is an FTS. Each
process is Ô¨Årst translated into an FTS. A state corresponds
to a variable valuation and a node of execution. Transitions
between states are determined according to the executable
statements. Feature expressions labelling transitions are di-
rectly derived from the fPromela model. Once all the processes
have been translated, the Ô¨Ånal FTS is obtained by computing
their parallel composition [11]....
typedef features {
...
bool Snd_min
}
features CFDP;
active[2] proctype cfdp_entity(...) {
int i = 0;
...
if :: CFDP.Snd_min -> ...
:: else -> ...
fi;
...
}
Fig. 2: Partial CFDP model.
A[2..2]B[1..2]C[1..2]R?
(a) FM example
ABCRABABCRA? (b) Group cardinalities (1)
ABCRABABCRABB?
(c) Group cardinalities (2)
ABBRACABBRABC?
(d) Feature cardinalities
Fig. 3: Ambiguities introduced by feature cardinalities.
An fPromela model may include behaviour that is exe-
cutable by no valid product. Let us suppose that during an
execution, the model goes through a transition annotated by
featureSndmin then through one annotated by its negation.
The resulting execution path is inconsistent because it requires
both the presence and the absence of the feature. To avoid
exploring this path, we use SAT solving methods which detect
non-satisÔ¨Åable formulae. Similarly, an execution path may
require an invalid combination of features. It is consequently
not a behaviour of the SPL since it cannot occur in any
valid product. Such paths are avoided by checking the feature
expression associated with the path of execution against the
FM [11].
III. A RRAY -BASED SEMANTICS FOR MULTI -FEATURES
The syntax and the semantics of attributes in TVL are
already deÔ¨Åned but the language does not support multi-
features. To overcome this, we extended the syntax as follows:
unless there is exactly one instance, the cardinalities are474written between brackets next to the name of the feature
(see Figure 1). Additional constraints over multi-features are
described further in this section. For clarity, we name TVL
our new version of TVL. Before we give it a formal semantics,
we have to deal with a number of issues.
A. Challenges in the DeÔ¨Ånition of Feature Cardinalities
As explained by Michel et al. [14], feature cardinalities
introduce semantic ambiguities. When a non-terminal feature
has a maximum cardinality greater than one, two ambiguities
exist regarding its group cardinalities. For instance, consider
the FM in Figure 3a and the two instances shown in Figure 3b.
According to the feature diagram shown in the former Ô¨Ågure,
featureAhas two instances and a group cardinality of [1..2]
(only one or two child features of Amay exist). However, it
is unclear whether the group cardinalities apply locally under
each instance ofAorglobally forallinstances of A. In other
words, either each instance can have one or two child features
(left diagram in Figure 3b), or there must be one or two child
features ofAaltogether (right diagram). Since our approach is
centred on multi-features, we consider the local interpretation
like Michel et al. [14].
The second ambiguity lies in the scope of group car-
dinalities; see Figure 3c. In the left diagram, cardinalities
restrict the number of instances ofA‚Äôs child features. On the
contrary, in the right diagram, the two instances of Bunder
the leftmost instance of Aare counted once; in this case,
cardinalities constrain the number of distinct child features.
Like Michel et al. [14], we believe that the original intent of
group cardinalities is to restrict the number of features in a
product; we thus consider the second option.
Multiple interpretations are also possible for feature cardi-
nalities. Let us consider Figure 3d. As for group cardinalities,
either feature cardinalities apply globally and count the total
number of instances of a feature (left diagram), or they apply
locally and count the number of instances of a feature under
a speciÔ¨Åc instance of its parent feature (right diagram). As
before, we adopt the most local option, i.e.the latter.
Another issue concerns the identiÔ¨Åcation of a feature by
means of its name. In FMs without multi-features, the (rel-
ative) name of a feature works as a unique reference to that
feature. This is not the case for multi-features. Let us consider
again the TVLmodel of CFDP (Figure 1). The relative name
Sndmin can refer to a child feature of either the Ô¨Årst instance
ofEntity or the second one. We have to identify this instance
using an ‚Äúabsolute‚Äù name (called fully qualiÔ¨Åed ). In TVL,
however, no construct exists for referring to a precise instance.
Moreover, the semantics proposed by Michel et al. deÔ¨Ånes the
children of a feature as a multiset of instances [14]. One cannot
refer to a precise element of a multiset in natural language. Our
SPL behaviour speciÔ¨Åcation language requires this capability;
the deÔ¨Ånition of Michel et al. is thus inappropriate for our
purpose.
We propose to represent the children of a feature by a set
of arrays of instances. In a given array, all the instances are
from the same feature. Each of them is identiÔ¨Åed by an index,the Ô¨Årst index being zero. For example, the Sndmin child
feature of the second instance of Entity is identiÔ¨Åed by the
fully qualiÔ¨Åed name CFDP [0]:Entity [1]:Sndmin[0]. When
the maximum number of instances of a given feature is 1,
the index can be omitted; CFDP:Entity [1]:Sndmin is thus
equivalent to the above name. An attribute of a given instance
must be referred to using its fully qualiÔ¨Åed name as well, e.g.,
CFDP:Message:size .
Since we introduce multi-features in the syntax of TVL,
we must provide means to specify constraints over them, their
attributes, and their number. Fully qualiÔ¨Åed names are already
suitable to refer to precise instances or attributes. However,
it is currently impossible to reason over a whole array. For
example, one cannot express that the number of instances
of a feature must not exceed the value of another feature‚Äôs
attribute , or that every instance of a feature must satisfy a
given constraint . To address this limitation, we deÔ¨Åne the op-
erator card which, given a fully qualiÔ¨Åed multi-feature name,
returns its number of instances. E.g.,card(CFDP.Entity)
always returns 2. We also deÔ¨Åne two new types of constraints:
forall(m)fgandexists(m)fg. Intuitively, they spec-
ify that for each (resp. at least one) instance of a multi-
feature m, the sub-tree of this instance satisÔ¨Åes the constraint
. For example, the constraint forall (CFDP:Entity )
fSnd_min_Rcv_mingis satisÔ¨Åed if and only if every
instance of Entity has at least one child. As we will see,
a notion of context is required for deÔ¨Åning the semantics of
such formulae.
The last challenge is related to constraints over attributes.
If a feature is not part of a product, references to its attributes
point to an unknown value. In this case, it is undetermined how
the constraint must be evaluated. Our new types of constraints
already provide a solution to that problem by specifying
constraints within the context of a instance. The evaluation
of a constraint is thus performed under the assumption that
the instance exists within its context. Still, this issue makes
such descriptions error-prone.
B. Abstract Syntax TVL
Now that the new TVLconstructs have been informally
introduced, we give them an abstract syntax and a formal
semantics. Note that this abstract syntax remains valid for
most feature modelling languages that support multi-features
and attributes, and whose diagrams follow a tree structure.
DeÔ¨Ånition 2 A TVLmodel is a tuple (F; r; DE; !; ; A;
; ; )whereFis a non-empty set of features, r2Fis the
root,Ais the set of attributes, and:
DEFFis the decomposition (hierarchy) relation
between features. For any (f;f0)2DE,fis the parent
andf0is the child feature. By children (f)we denote
the set of child features of f.
!:F!N(N[fg )gives the cardinality of
each feature. If !(f) = (n;m)thennis the minimum
cardinality of fandmits maximum cardinality. If m=
thenmcan be any Ô¨Ånite value.475:F!N(N[fg )indicates the decomposition
operator of a feature, i.e., its group cardinalities. It
follows the same pattern as !.
:A!Fis a total function that returns the feature
declaring a given attribute.
:A!fint;boolgassigns a type to each attribute.
is a Boolean-valued expression over the features Fand
the attributes A, expressing additional constraints.
Furthermore, each FM must satisfy the following well-
formedness rules: rexists and is unique: !(r) = (1;1);
any terminal feature fhas no child: (f) = (0;0); DE is
acyclic, that is, @n1;::;n k2N(nk;n1)2DE^8i2
f1::k 1g(ni;ni+1)2DE.
The main difference between this new syntax and that of
TVL [4] is the deÔ¨Ånition of !. In the latter, !was meant
to identify optional features. Here, we make it more general
since it deÔ¨Ånes the cardinality of a feature. Although this
difference might seem thin at Ô¨Årst sight, we already showed in
Section III-A that it raises a number of important issues. The
deÔ¨Ånition of is also different here, as we have introduced
a new operator and two new types of constraints. For conve-
nience, we suppose that attributes are either integer or Boolean.
Enumeration types can be mapped to integer and are thus
implicitly supported too. The introduction of real attributes
in the syntax is straightforward, but requires additional type
checking. The current version of our tools (presented further
in Section V) does not support them.
As explained in Section III-A, only a fully qual-
iÔ¨Åed name can be used to identify a speciÔ¨Åc in-
stance or an attribute. Formally, it is a tuple of the
form 
(f0;i0);(f1;i1);:::; (fk;ik)
2(FN)k+1or 
(f0;i0);(f1;i1);:::; (fk;ik);a
2(FN)k+1A, respec-
tively for an instance or an attribute. A fully qualiÔ¨Åed instance
name must satisfy the following. (1) The Ô¨Årst feature is the root
indexed by 0: (f0;i0) = (r;0); (2) the decomposition hierar-
chy is respected:8j0<jkfk2children (fk 1); (3)
each index satisÔ¨Åes the cardinalities of its associated feature:
8j0< jkw(fj) = (n;m))0ij< m . A fully
qualiÔ¨Åed attribute name (f0;i0);(f1;i1);:::; (fk;ik)ais valid
if and only if (f0;i0);(f1;i1);:::; (fk;ik)is valid and ais an
actual attribute of fk:fk2(a). From now on, we assume
the validity of every fully qualiÔ¨Åed name.
C. Formal Semantics
The purpose of TVL is to deÔ¨Åne the set of valid products
in an SPL, i.e.the valid combinations of features and attribute
values. We mentioned before that in SPLs without attributes
and multi-features, a product is uniquely identiÔ¨Åed by a set
of features. For reasons explained above, this representation is
not appropriate when multi-features or attributes occur in the
FM. Therefore we redeÔ¨Åne a product as a couple (F;A)where
F (FN)+is a set of instances and A: 
(FN)+A
!
Z[f>;?gis a partial function that associates attributes with
values. We assume that all the attributes of any instance in Fhave a value deÔ¨Åned by A:
8(f0;i0):::(fk;ik)2F;a2Afk=(a)
8 
(f0;i0):::(fk;ik);a
2dom(A):
Conversely, for any attribute whose value is deÔ¨Åned, Fmust
include the corresponding feature:
8 
(f0;i0):::(fk;ik);a
2dom(A)
)8(f0;i0):::(fk;ik)2F:
Although we could ignore these two assumptions, they sim-
plify the deÔ¨Ånition of the semantics.
DeÔ¨Ånition 3 LetM= (F;r;DE;!;;A;;; )be a TVL
model andp= (F;A)be a product. Then pis valid according
toM, notedpj=M, if and only if, for (f0;i0):::(fk;ik)2
F:
Fcontains the root: (r;0)2F;
Frespects the decomposition hierarchy: (fk 1;fk)2
DE;
every instance in Fhas its parent in Fas well:
(f0;i0):::(fk 1;ik 1)2F;
FsatisÔ¨Åes the group cardinalities: (fk) = (n;m))
njf(f0;i0):::(fk;ik)(fk+1;0)2Fgjm;
theith instance of a feature exists only if the i 1th does:
ik>0)(f0;i0):::(fk;ik 1)2F;
FsatisÔ¨Åes the feature cardinalities: !(fk) = (n;m)) 
ik<m^n>0)(f0;i0):::(fk;n 1)2F
;
psatisÔ¨Åes the additional constraints .
We consider that instances are contiguously placed in arrays,
which simpliÔ¨Åes the veriÔ¨Åcation of multi-features and con-
straints over them.
Due to lack of space, we do not provide all the satisfaction
rules for the additional constraints. However, we detail them
for the constructs we have added. As explained above, the
constraints of the form forall(m)fgandexists(m)fg
introduce the notion of context ,i.e., a sub-tree of the model.
For the context to be well-deÔ¨Åned, it is sufÔ¨Åcient to know the
instance it refers to.
DeÔ¨Ånition 4 LetM= (F;r;DE;!;;A;;; )be a TVL
model. Then (f0;i0):::(fk;ik)2(FN)+is a context of
Mif it is a valid fully qualiÔ¨Åed feature name.
The initial context is the root feature. A product p= (F;A)
must thus satisfy the additional constraints in the context
(r;0):pj=(r;0). The context changes only when one of the
above two constructs are encountered:
pj=cforall(m)fg,8 (c;m;i )2Fpj=(c;m;i );
pj=cexists(m)fg,9 (c;m;i )2Fpj=(c;m;i ):
Here,cmerely acts as a preÔ¨Åx for features name. References to
multi-features can occur in constraints, and express that at least
one instance of the feature exists. Given our convention about
array contiguity, this boils down to requiring the presence of
the instance at index 0: p j=cm,(c;m; 0)2 F . As in476TVL [4], the semantics of some constraints depend on the
evaluation of arithmetic expressions, variables, or operators.
For our new card operator, the evaluation is given by:
[ [card (m)] ]c=jf(c;m;i )2Fgj . If the card operator is
compared to a constant value vthen the constraint can be
reduced to a Boolean form:
pj=ccard (m)v,(c;m;v 1)2F (1)
We will also make use of this property to reduce the cost of
verifying these constraints in behavioural speciÔ¨Åcations.
IV. A B EHAVIOURAL SPECIFICATION LANGUAGE FOR
MULTI -FEATURES AND ATTRIBUTES
The semantics of TVLallows us to determine which
combinations of features constitute valid products. Still, we
need a way to express the behaviour of these products in a
concise ( i.e., not individual) manner. Based on the principles
of TVL, we generalize fPromela with feature expressions
supporting multi-features and attributes. Then we can verify
models of this language against properties using a model
checking tool (described in Section V). We name our extension
fPromela.
fPromelaextends fPromela‚Äôs syntax with more general data
types for representing features. For example, the data structure
deÔ¨Åned for the Entity feature would be:
t y p e d e f _Entity {
bool is_in;
bool Snd_min;
bool Rcv_min
};
The Ô¨Årst Ô¨Åeld of a structure is a Boolean called is_in . Its
truth value deÔ¨Ånes the presence or the absence of a feature.
The structures can be nested. Hence if, say, Sndmin is
not a terminal feature, we can declare it as an instance of
another structure. Attributes are declared as integer Ô¨Åelds.
More generally, there exists a transformation from a TVL
model to a set of fPromeladata structures. Each data structure
represents a non-terminal feature, and contains one Ô¨Åeld per
attribute and child feature. The type of the latter is either
Boolean or another data structure, respectively if the feature
is terminal or not. When the maximum cardinality of a feature
is1< m <1, the feature must be declared as an m-sized
array of its corresponding type:
t y p e d e f f e a t u r e s {
_Entity Entity[2];
...
};
Because fPromela does not allow arrays of an unknown
size, the transformation does not support inÔ¨Ånite maximum
cardinality (represented as a in TVL). However, we may
assume that in real cases, an upper bound can be deÔ¨Åned.
Unlike in fPromela, the use of nested user-deÔ¨Åned structures
is compulsory in fPromela. Indeed, a fully qualiÔ¨Åed name is
required to refer to an instance (see Section III-A). fPromela
offers a simple way to represent valid fully qualiÔ¨Åed names:references to Ô¨Åelds of the corresponding user-deÔ¨Åned struc-
tures, starting from that of the root feature. For example, the
Sndmin child feature of the second instance of Entity is
uniquely referred to by CFDP.Entity[1].Snd_min .
fPromelageneralizes feature expressions as well. We
distinguish between static and dynamic formulae. The
former specify one of the following requirements: (1)
the presence or absence of a given instance ( e.g.,
CFDP.Entity[1].Snd_min ); (2) constraints over at-
tributes ( e.g.,CFDP.Message.size>0 ); and (3) constraints
over number of instances ( e.g.,card(CFDP.Entity)==2 ).
As in TVL, the third type of constraints is subsumed by the
Ô¨Årst one when card is compared to integers (see Equation 1).
We can determine the products able to execute a transition as-
sociated with a static formula without executing the fPromela
model.
On the contrary, dynamic formulae are evaluated at runtime.
Typically, they deÔ¨Åne constraints over attributes and number of
instances in terms of variable values. For example, one could
analyse the content of a CFDP message by iterating on its
size:
i = 0;
do :: CFDP.Message.size > i
-> ... i++;
:: e l s e -> break ;
od;
Note that for a given product, the actual size of the above
model (in terms of states) depends on the value of the attribute
in the product. Attributes in fPromelaare thus the key for
specifying variable-size models. Instead of attributes, we could
also use the number of instances of a feature. In Section V, we
show that it is more efÔ¨Åcient to verify a variable-size model
rather than a set of Ô¨Åxed-size models, i.e.one per possible
size.
Let us illustrate the last addition of fPromelaby means
of the CFDP model. As mentioned before, two processes are
declared and model the behaviour of two spacecrafts. These
may have different conÔ¨Ågurations. In the partial model shown
in Figure 2, however, we Ô¨Ånd but an ambiguous reference to
featureSndmin. We have seen that the introduction of multi-
features permits the distinction between the features of the two
entities. Still, we need a way to associate each process with
the corresponding instance of Entity . To that aim, we deÔ¨Åne
the feature context of a process as an instance of a feature. We
propose two constructs to associate a context to a process. The
Ô¨Årst speciÔ¨Åes it explicitly in the run statement of fPromela,
which is used to dynamically instantiate a new process:
run [CFDP.Entity[1]] cfdp_entity(...)
The second method consists in declaring that the number of
instances of a process is equal to the number of instances of
a speciÔ¨Åc feature:
a c t i v e [card(CFDP.Entity)] cfdp_entity(...)
In this case, the context of each instance of cfdp_entity is477a distinct instance of Entity . A process cannot exist outside
its associated context. Accordingly, the Ô¨Årst transition of a
process is implicitly constrained by the formula representing
its context. Once deÔ¨Åned, contexts can act as a preÔ¨Åx in feature
expressions. For this purpose, one may use the keyword this ,
which points to the context of the process:
i f:: this.Snd_min -> ...
:: e l s e -> ...
f i;
References to features outside the context are still possible by
using fully qualiÔ¨Åed names.
More generally, one can regard contexts as an association
between an fPromelaprocess and a FM. Thanks to them,
one can describe the behaviour of parallel processes built
from different SPLs. Analysing the behaviour of compositions
of SPLs rather than individual SPLs is thus made possible.
However, this remains out of the scope of this paper and is
left for future work.
In [11], we deÔ¨Åned the semantics of an fPromela model as
an FTS. Since apart from feature expressions, fPromeladoes
not differ from fPromela, its semantics can be deÔ¨Åned in terms
of FTS where feature expressions have been generalized. We
call the resulting formalism FTS.
V. I MPLEMENTATION AND EVALUATION
Since the semantics of an fPromelais an FTS, we may
reuse algorithms based on this formalism [7]‚Äì[9]. We describe
how we implemented the approach on top of SNIP [11], which
we further used to carry out experiments.
A. Tool Description
SNIP is a model checker based on the FTS formalism. Fig-
ure 4 gives an overview of its architecture. Given an fPromela
model, the parser builds a program graph representing it. The
semantic engine generates on-the-Ô¨Çy the FTS equivalent to
the program graph. The veriÔ¨Åer module checks the FTS using
dedicated algorithms [7], [9]. Feature handler abstracts feature
formulae from their representations, whereas feature solver
checks their satisÔ¨Åability. The TVL library is used to compute
the feature formula representing the valid products of a TVL
model.
No change to the veriÔ¨Åer module is required since it is
independent of how feature formulae are represented. On
the contrary, we extended or built new variants of the other
modules. We updated the parser so that feature formulae
are declared and referenced as user-deÔ¨Åned data structures.
We also relaxed syntactic constraints for feature formulae
and modiÔ¨Åed the construction of program graphs accordingly.
Dynamic formulae are handled by the semantic engine, which
builds them at runtime.
Given that more general feature formulae are allowed,
the previous feature handler and checker are not appropriate
anymore. Both the representation and satisÔ¨Åability check-
ing of features were based on Binary Decision Diagrams
typedef features {!bool Nice};features f;chan mail = [1] of { mtype };mtype = { nothing, flowers, bomb };active proctype sender() {!if!:: f.Nice -> ms;!!:: else -> maimb;!fi;}active proctype receiver() {!mtype package = nothing;!mail?package;!assert(package != bomb);}
VendingMachinevTeatFreeDrinksfCancelPurchasecSodasBeveragesb
Parser
Semantic Engine
Feature handler
Feature solver
Veri/f_ierfPromela* model
TVL* modelprogram graph
valid productsfeature formulaefeature formulaeFTS
Sat?Yes/NoSat?Yes/NoFig. 4: Architecture of SNIP.
(BDDs) [19] and their implementation in the CUDD library2.
While BDDs have proven their efÔ¨Åciency in SNIP [11], they
are unable to represent arithmetic constraints. Multi-features
alone are not a problem in this regard but feature attributes are
not necessarily Boolean. SatisÔ¨Åability Modulo Theory (SMT)
solvers appear as natural candidates for arithmetic constraints
checking. Accordingly, our new feature solver is linked to
Microsoft‚Äôs Z3 [20]. Z3 implements many advanced tech-
niques and structures for SMT solving. We thus implemented
a new feature handler that relies on them. Equipped with Z3,
our tool is able to check the satisÔ¨Åability of formulae over
both the features and their attributes. However, this comes at
the price of a signiÔ¨Åcant reduction in efÔ¨Åciency, as further
experiments reveal. Consequently, we developed two variants
of the tool: one equipped with CUDD and the other with
Z3; the former supports only multi-features whereas the latter
handles attributes as well. They are now included in the
ProVeLines tool suite ( http://info.fundp.ac.be/fts/provelines ).
B. Overhead Measurement
We carried out experiments to evaluate the beneÔ¨Åts of our
approach, and to quantify the overhead that results from the
additional veriÔ¨Åcations (see above) and/or the use of Z3 in
place of BDD-based satisÔ¨Åability solvers. The following tools
are involved in the experiments: SNIP (as described in [11]),
our BDD-based variant that supports multi-features (SNIP-
MF), and our second variant equipped with Z3 (SNIP-Z3).
The addition of multi-features to fPromelagenerates addi-
tional computations in the semantic engine of SNIP. Moreover,
feature attributes require more general satisÔ¨Åability-checking
techniques, i.e., SMT solvers. These two generalizations are
likely to negatively impact the performance of our tool. To
quantify the resulting loss, we compare the time needed to
model check three fPromela models against Ô¨Åve properties
each. The models include neither multi-features nor attributes.
They are: (1) a minepump system [7], [21] (250,561 states
to explore); (2) a restricted version of CFDP where attributes
have received a Ô¨Åxed value and the two instances of Entity
are regarded as a single feature (1,801,581 states to explore);
(3) an elevator model inspired from Plath and Ryan [22]
2vlsi.colorado.edu/Àúfabio/CUDD478TABLE I: VeriÔ¨Åcation times (in seconds).
SNIP SNIP-MF SNIP-Z3
Minepump #1 2.72 3.21 (+18%) 78.22 (+2,776%)
Minepump #2 2.88 2.95 (+2%) 67.86 (+2,256%)
Minepump #3 4.90 5.47 (+12%) 88.63 (+1,709%)
Minepump #4 2.96 3.42 (+16%) 65.72 (+2,120%)
Minepump #5 9.22 9.76 (+6%) 197.43 (+2,041%)
CFDP #1 10.96 11.00 (+1%) 282.47 (+2,477%)
CFDP #2 2.23 2.41 (+2%) 63.37 (+2,741%)
CFDP #3 1.11 1.11 (+0%) 25.62 (+2,208%)
CFDP #4 3.82 4.00 (+5%) 113.36 (+2,867%)
CFDP #5 17.58 18.52 (+5%) 548.98 (+3,023%)
Elevator #1 286.50 301.10 (+5%) TIMEOUT
Elevator #2 9.53 10.47 (+10%) 9,172.05 (+96,144%)
Elevator #3 7.07 7.90 (+12%) 3,316 (+46,799%)
Elevator #4 3.5 3.55 (+1%) 1,858.65 (+53,004%)
Elevator #5 235.67 252.94 (+7%) TIMEOUT
(58,945,690 states to explore). We checked different kinds of
properties including deadlock freedom, safety properties, and
liveness properties. All benchmarks were run on a MacBook
Pro with a 2,8 GHz Intel Core i7 processor and 8 GB of DDR3
RAM. We coded an automated script to execute them. To avoid
random variations, we repeated each experiment several times
and computed the average.
Results are shown in Table I. We observe that multi-feature
support in our BDD-based tool generates but a small increase
in veriÔ¨Åcation time (between 2% and 18% for Minepump;
between 0% and 5% for CFDP; between 1% and 12% for
Elevator). This increment does not depend on the size of the
model. In every model, the increase is less than 6% for longest-
to-check properties. This indicates that the size of the property
has no impact on the loss of performance either.
On the contrary, the Z3 variant suffers from a large per-
formance drop. In Minepump and CFDP, the checking time
ranges from 21 to 31 times more than for the other two tools.
The tool performs even worse on Elevator: the veriÔ¨Åcation
time is multiplied by a factor between 468 and 962. For the
Ô¨Årst and Ô¨Åfth properties of that model, we could not even get
accurate results; according to our estimations, verifying those
properties would take 24 and 15 hours, respectively. Our SMT-
based tool does not scale well with the size of the model.
We carried out further analyses to explain this phenomenon.
For each tool, we computed the time required for satisÔ¨Åability
checking and formulae manipulation ( i.e., conjunction, dis-
junction, negation, simpliÔ¨Åcation) during each experiment. In
Table II we provide the time share of the two computations
in percentage, for every model and property.
For SNIP and SNIP-MF, the absolute time needed for
satisÔ¨Åability checking ( Sat) and formulae manipulation ( Man)
are identical. Indeed, given that all the models are free from
multi-feature and attribute, the only difference between the
two tools are the detection of dynamic formulae, which does
not depend on Sat orMan. For these tools, it turns out that
Sat constitutes but a small part of the total time (between 6%
and 15%). Although this share tends to slightly increase with
the size of the model, it is not a major threat to scalability. OnTABLE II: Share of veriÔ¨Åcation time due to satisÔ¨Åability
checking and formula manipulation (in percentage).
SNIP SNIP-MF SNIP-Z3
Sat Man Sat Man Sat Man
M. #1 8.59 27.72 7.28 23.48 75.38 22.16
M. #2 6.07 18.26 5.93 17.83 80.37 16.82
M. #3 5.94 17.87 5.32 16.00 74.92 21.99
M. #4 6.02 18.18 5.21 15.74 80.35 17.77
M. #5 5.98 17.36 5.65 16.40 79.05 16.96
C. #1 10.14 28.79 10.10 28.69 73.07 20.86
C. #2 11.79 27.24 10.91 25.21 77.85 16.65
C. #3 8.44 20.77 8.44 20.77 77.14 15.96
C. #4 9.25 22.70 8.84 21.68 81.87 13.72
C. #5 9.38 24.32 8.91 23.09 78.57 13.49
E. #1 14.70 52.82 13.99 50.26 TIMEOUT
E. #2 12.47 37.97 11.35 34.56 95.45 3.37
E. #3 12.09 38.23 10.82 34.21 94.68 4.87
E. #4 13.17 39.94 12.98 39.38 95.13 4.47
E. #5 11.31 37.57 10.54 35.0 TIMEOUT
the contrary, Man is an increasingly important part of the total
time. While the time share does not grow signiÔ¨Åcantly between
Minepump and CFDP, it nearly doubles in the Elevator case,
ranging from 38% to 53%. This indicates that managing a
large number of BDDs is the main challenge for efÔ¨Åcient BDD-
based tools .
In the third tool, Sat is the most costly computation. Its
share is already between 73% and 82% for Minepump and
CFDP, and reaches astonishing proportions in the Elevator case
(about 95%). This clearly shows that expensive satisÔ¨Åability
checking threatens scalability. We measured the average time
for aSat computation. It amounts to 6:5910 4seconds for
SNIP-Z3 as opposed to 3:3610 7in BDD-based tools. In
every model and property, the remaining computation time is
due to feature manipulations for the most part. The average
time of these is 1:6210 5seconds ‚Äì as opposed to 3:6810 7
in the other tools. Together, Sat andMan always make up
more than 92% of the overall veriÔ¨Åcation time, and even over
95.5% in Elevator.
In our context, SMT-based solutions thus appear less ef-
Ô¨Åcient than BDDs. This has to be conÔ¨Årmed through the re-
placement of Z3 by other SMT solvers. Indeed, Z3 offers many
facilities that we do not need. Using another solver speciÔ¨Åcally
designed for our purpose might yield better results. We leave
that for future work. Nevertheless, the poor performance raises
the need for alternatives to SMT.
C. Explicit Attributes versus Boolean Conversion
As an alternative to Z3, we propose to transform integer
attributes into a set of Boolean variables, i.e., one per attribute
value. This results in a model without attribute, which can thus
be checked by SNIP-MF. Each time a constraint over attributes
is encountered in an fPromelamodel, it is Ô¨Årst re-written in
a form where only Boolean negation and greater operators
occur. For instance, the constraint CFDP:Message:size< =
3is converted into:(CFDP:Message:size > 3). Then, a
Boolean variable representing that constraint is created and479TABLE III: VeriÔ¨Åcation times for the CFDP example (in
seconds).
SNIP-MF SNIP-Z3 Speedup
#1 9.79 898.88 91.82
#2 2.72 345.86 127.15
#3 1.35 137.05 101.51
#4 12.24 1694.61 138.45
#5 21.44 3661.89 170.79
replaces it. While this solution avoids the overhead of SMT
solving, it reduces the performance of SNIP-MF because more
variables have to be dealt with.
The following experiments aim at evaluating whether this
is more efÔ¨Åcient than the Z3-based solution. We consider
the complete CFDP model and compare the time needed by
SNIP-Z3 and SNIP-MF to perform the veriÔ¨Åcations. Results
are shown in Table III. It turns out that the transformation
implemented in SNIP-MF yields far better results than SNIP-
Z3. We observe a speedup ranging from 91.82 to 170.79.
Interestingly, apart from Property #1the difference in speed
increases as the properties are longer to check (see in particular
Property #5). This corroborates our previous results and tends
to show that in our context, attributes conversion is more
viable than SMT. This has to be conÔ¨Årmed through additional
experiments with more speciÔ¨Åc SMT solvers, though.
D. Variable-Size Models
In Section IV, we mentioned that multi-features and at-
tributes can represent variable-size models. Our new tools
have thus the capability to verify in a single execution a set
of models varying only by their size. They avoid redundant
checking of common parts of these models, and are thus
potentially more efÔ¨Åcient. However, multi-feature support has
an impact of performance. We must therefore evaluate if the
avoidance of redundancy offsets the loss in efÔ¨Åciency.
We consider the sieve of Eratosthenes modelled in
fPromela. The size of the model is determined by the number
of primes to compute. We compare the performance of (1)
SNIP applied on models where the number of primes is
Ô¨Åxed, and (2) SNIP-MF executed on a model where this
number is equal to the number of instances of a feature. For a
maximum number n, we compute the time needed by SNIP for
successively checking models with 1 to nnumbers to compute.
Then, we execute SNIP-MF on the variable-size model.
Figure 5a shows the resulting veriÔ¨Åcation times for n
ranging from 30 to 48, whereas Figure 5b presents the number
of explored states. Although the checking time always grows
exponentially, it turns out that SNIP-MF performs increasingly
better than SNIP. As illustrated in Figure 5b, this is because
the former explores fewer and fewer states than the latter.
However, we observe that for SNIP-MF, the veriÔ¨Åcation time
raises more rapidly than the number of explored states; the
overhead due to multi-features has again a visible impact
on the overall performance. Moreover, the beneÔ¨Åt might not
always exist. When the largest model has signiÔ¨Åcantly more
0	 ¬†100	 ¬†200	 ¬†300	 ¬†400	 ¬†500	 ¬†600	 ¬†700	 ¬†800	 ¬†900	 ¬†
30	 ¬†32	 ¬†34	 ¬†36	 ¬†38	 ¬†40	 ¬†42	 ¬†44	 ¬†46	 ¬†48	 ¬†SNIP	 ¬†"SNIP-¬≠‚ÄêCL"	 ¬†(a) VeriÔ¨Åcation times (in sec.)
0	 ¬†5000000	 ¬†10000000	 ¬†15000000	 ¬†20000000	 ¬†25000000	 ¬†
30	 ¬†32	 ¬†34	 ¬†36	 ¬†38	 ¬†40	 ¬†42	 ¬†44	 ¬†46	 ¬†48	 ¬†SNIP	 ¬†"SNIP-¬≠‚ÄêCL"	 ¬† (b) Number of explored states
Fig. 5: Benchmark results for the sieve of Eratosthenes.
states than the smaller ones, the time needed to check these is
negligible. In such cases, SNIP-MF might not be more efÔ¨Åcient
than SNIP applied on each model size.
VI. R ELATED WORK
Other SPL model checkers equipped with speciÔ¨Åcation
languages exist. Plath and Ryan [22] designed fSMV in the
context of feature interaction detection. This is a compositional
language where features are described in separate modules. We
previously developed an fSMV model checker [8]. Gruler et
al.[10] extended the CCS process algebra with a variability
operator that models alternative choices. Their language is
however less human-readable than fPromela. Apel et al. [5]
developed SPLVeriÔ¨Åer, a tool chain for product-line model
checking. Features are speciÔ¨Åed in separate modules written
in C or Java. The framework of Asirelli et al. [6] centred on
modal transition systems does not include high-level speciÔ¨Å-
cation languages. None of the above considers attributes and
multi-features.
A few attempts to reason on FM with attributes and multi-
features exist. Czanercki et al. [13] deÔ¨Åne the semantics
of an FM with feature cardinalities as the semantics of a
context-free grammar derived from the FM. Michel et al. [14]
deÔ¨Åned another semantics based on multisets. Czarnecki and
Kim [23] argue that OCL is suitable for expressing additional
constraints over multi-features. Mazo et al. [24] use constraint
logic programming to reason on FMs with multi-features and
attributes. However, their procedure relies on a heavyweight
transformation from visual FMs to XML, then to Gnu-Prolog‚Äôs
input syntax. Zhang et al. [25] propose a BDD-based approach
for reasoning over multi-features. However, it does not support
attributes and does not rely on an array-based semantics. A
broader survey of feature cardinality analyses is found in [14].
SMT solvers are increasingly used in model checking. They
have proven their usefulness in bounded model checking and
veriÔ¨Åcation of inÔ¨Ånite-state and array-based systems [26].
We showed that SPL model checking is another interesting
application domain for SMT solvers. However, they have to
be combined with heuristics in order to provide an acceptable
level of performance in our context.
VII. C ONCLUSION
We dealt with feature cardinalities and numeric features
in SPL model checking. Multi-features and feature attributes480have received little support, be it in FMs or behavioural
speciÔ¨Åcation languages. These constructs pose many problems
of both theoretical and technical nature. Nonetheless, the
deÔ¨Ånition of languages supporting them is essential. Both
constructs are useful in terms of expressiveness, conciseness,
and readability. In a behaviour speciÔ¨Åcation, they allow the
deÔ¨Ånition of variable-size models. Our experiments showed
that it is easier to verify such models than successively check-
ing the same model with different sizes. Multi-features are
also useful for specifying parallel processes that differ by their
conÔ¨Åguration. To deal with them, we introduced the notion of
feature context for parallel processes. More generally, contexts
can relate parallel process with different FMs. Combined with
feature-model composition [27], this result opens the way
for behavioural veriÔ¨Åcation of SPL compositions. This is an
interesting direction for our future work.
Handling attributes in SPL model checking is difÔ¨Åcult. SMT
solvers appeared as natural candidates to represent and reason
over numeric feature formulae. However, our experiments with
Microsoft‚Äôs Z3 revealed that the overhead of SMT satisÔ¨Åabil-
ity checking is too important, which forced us to consider
alternatives like converting attributes into Boolean variables.
Yet, we need but a small subset of Z3‚Äôs capabilities. Another
solver optimised for our purpose could perform better. A
complementary solution is not to check feature formulae each
time it is needed. This leads to exploring more states than
necessary but reduces the number of calls to the solver.
Moreover, Boolean conversion is not always practical. The
behavioural models we considered do not include quantitative
aspects like real-time or cost/rewards. Feature attributes in
these contexts likely represent more complex forms of vari-
ability, e.g., data throughput, processor speed, or energy con-
sumption. Model checking such SPLs requires the combination
of this work with quantitative formalisms like Featured Timed
Automata [28]. This is non-trivial; several theoretical issues
like decidability are expected. On the technical side, the use of
SMT solvers might be a mandatory step. Still, it constitutes an
interesting problem and we will most likely pursue our work
in that direction.
ACKNOWLEDGEMENTS
We thank Philippe Warnon and Raphael Michel for their
suggestions regarding TVL‚Äôs syntax, as well as Andreas
Classen for proofreading. This work was funded by the Fund
for ScientiÔ¨Åc Research ‚Äì FNRS in Belgium (project FC
91490).
REFERENCES
[1] K. Pohl, G. B ¬®ockle, and F. van der Linden, Software product line
engineering - foundations, principles, and techniques . Springer, 2005.
[2] K. Kang, S. Cohen, J. Hess, W. Novak, and S. Peterson, ‚ÄúFeature-
oriented domain analysis (FODA) feasibility study,‚Äù Tech. Rep.
CMU/SEI-90-TR-21, 1990.
[3] P.-Y . Schobbens, P. Heymans, J.-C. Trigaux, and Y . Bontemps, ‚ÄúFeature
Diagrams: A Survey and A Formal Semantics,‚Äù in RE‚Äô06 , 2006, pp.
139‚Äì148.
[4] A. Classen, Q. Boucher, and P. Heymans, ‚ÄúA text-based approach to
feature modelling: Syntax and semantics of TVL,‚Äù SCP, vol. 76, pp.
1130‚Äì1143, December 2011.[5] S. Apel, H. Speidel, P. Wendler, A. von Rhein, and D. Beyer, ‚ÄúFeature-
interaction detection using feature-aware veriÔ¨Åcation,‚Äù in ASE‚Äô11 .
IEEE, 2011, pp. 372‚Äì375.
[6] P. Asirelli, M. H. ter Beek, A. Fantechi, and S. Gnesi, ‚ÄúFormal
description of variability in product families,‚Äù in SPLC‚Äô11 . Springer-
Verlag, 2011, pp. 130‚Äì139.
[7] A. Classen, P. Heymans, P.-Y . Schobbens, A. Legay, and J.-F. Raskin,
‚ÄúModel checking lots of systems: efÔ¨Åcient veriÔ¨Åcation of temporal
properties in software product lines,‚Äù in ICSE‚Äô10 . ACM, 2010, pp.
335‚Äì344.
[8] A. Classen, P. Heymans, P.-Y . Schobbens, and A. Legay, ‚ÄúSymbolic
model checking of software product lines,‚Äù in ICSE‚Äô11 . ACM, 2011,
pp. 321‚Äì330.
[9] M. Cordy, A. Classen, G. Perrouin, P. Heymans, P.-Y . Schobbens,
and A. Legay, ‚ÄúSimulation-based abstractions for software product-line
model checking,‚Äù in ICSE‚Äô12 . IEEE, 2012, pp. 672‚Äì682.
[10] A. Gruler, M. Leucker, and K. Scheidemann, ‚ÄúModeling and model
checking software product lines,‚Äù in FMOODS‚Äô08 . Springer, 2008, pp.
113‚Äì131.
[11] A. Classen, M. Cordy, P. Heymans, A. Legay, and P.-Y . Schobbens,
‚ÄúModel checking software product lines with SNIP,‚Äù STTT , vol. 14,
no. 5, pp. 589‚Äì612, 2012.
[12] G. J. Holzmann, The SPIN Model Checker: Primer and Reference
Manual . Addison-Wesley, 2004.
[13] K. Czarnecki, S. Helsen, and U. W. Eisenecker, ‚ÄúFormalizing
cardinality-based feature models and their specialization.‚Äù Software
Process: Improvement and Practice , vol. 10, no. 1, pp. 7‚Äì29, 2005.
[14] R. Michel, A. Classen, A. Hubaux, and Q. Boucher, ‚ÄúA formal semantics
for feature cardinalities in feature diagrams,‚Äù in VaMoS‚Äô11 . New York,
NY , USA: ACM, 2011, pp. 82‚Äì89.
[15] A. Hubaux, Q. Boucher, H. Hartmann, R. Michel, and P. Heymans,
‚ÄúEvaluating a textual feature modelling language: four industrial
case studies,‚Äù in SLE‚Äô10 . Berlin, Heidelberg: Springer-Verlag, 2011,
pp. 337‚Äì356. [Online]. Available: http://dl.acm.org/citation.cfm?id=
1964571.1964603
[16] Consultative Committee for Space Data Systems (CCSDS), CCSDS File
Delivery Protocol (CFDP): Blue Book, Issue 4 . NASA, 2007.
[17] Q. Boucher, A. Classen, P. Heymans, A. Bourdoux, and L. Demonceau,
‚ÄúTag and prune: A pragmatic approach to software product line imple-
mentation,‚Äù in ASE‚Äô10 . ACM, 2010, pp. 333‚Äì336.
[18] C. K ¬®astner, S. Apel, and M. Kuhlemann, ‚ÄúGranularity in software
product lines,‚Äù in ICSE‚Äô08 . New York, NY , USA: ACM, 2008, pp.
311‚Äì320.
[19] R. E. Bryant, ‚ÄúSymbolic boolean manipulation with ordered binary-
decision diagrams,‚Äù ACM Computing Surveys , vol. 24, no. 3, pp. 293‚Äì
318, Sep. 1992.
[20] L. De Moura and N. Bj√∏rner, ‚ÄúZ3: an efÔ¨Åcient smt solver,‚Äù in TACAS‚Äô08 .
Springer-Verlag, 2008, pp. 337‚Äì340.
[21] J. Kramer, J. Magee, M. Sloman, and A. Lister, ‚ÄúConic: an integrated
approach to distributed computer control systems,‚Äù Computers and
Digital Techniques, IEE Proceedings E , vol. 130, no. 1, pp. 1‚Äì10, 1983.
[22] M. Plath and M. Ryan, ‚ÄúFeature integration using a feature construct,‚Äù
SCP, vol. 41, no. 1, pp. 53‚Äì84, 2001.
[23] K. Czarnecki and C. H. P. Kim, ‚ÄúCardinality-based feature modeling and
constraints: a progress report,‚Äù in International Workshop on Software
Factories at OOPSLA‚Äô05 , ACM. San Diego, California, USA: ACM,
2005.
[24] R. Mazo, C. Salinesi, D. Diaz, and A. Lora-Michiels, ‚ÄúTransforming
attribute and clone-enabled feature models into constraint programs over
Ô¨Ånite domains,‚Äù in ENASE‚Äô11 , 2011, pp. 188‚Äì199.
[25] W. Zhang, H. Yan, H. Zhao, and Z. Jin, ‚ÄúA bdd-based approach to
verifying clone-enabled feature models‚Äô constraints and customization,‚Äù
inICSR‚Äô08 . Berlin, Heidelberg: Springer-Verlag, 2008, pp. 186‚Äì199.
[26] S. Ghilardi and S. Ranise, ‚ÄúMcmt: A model checker modulo theories,‚Äù
inIJCAR‚Äô10 , 2010, pp. 22‚Äì29.
[27] M. Acher, P. Collet, P. Lahire, and R. B. France, ‚ÄúComposing feature
models,‚Äù in SLE‚Äô09 , 2009, pp. 62‚Äì81.
[28] M. Cordy, P. Heymans, P.-Y . Schobbens, and A. Legay, ‚ÄúBehavioural
modelling and veriÔ¨Åcation of real-time software product lines,‚Äù in
SPLC‚Äô12 . ACM, 2012.481