Proactive Detection of Collaboration ConÔ¨Çicts
Yuriy Brun
 , Reid Holmes
 , Michael D. Ernst
 , David Notkin
Computer Science & Engineering
 School of Computer Science
University of Washington University of Waterloo
Seattle, WA, USA Waterloo, ON, Canada
{brun,mernst,notkin}@cs.washington.edu, rtholmes@cs.uwaterloo.ca
Abstract
Collaborative development can be hampered when conÔ¨Çicts arise
because developers have inconsistent copies of a shared project. We
present an approach to help developers identify and resolve con-
Ô¨Çicts early, before those conÔ¨Çicts become severe and before rele-
vant changes fade away in the developers‚Äô memories. This paper
presents three results.
First, a study of open-source systems establishes that conÔ¨Çicts
are frequent, persistent, and appear not only as overlapping textual
edits but also as subsequent build and test failures. The study spans
nine open-source systems totaling 3.4 million lines of code; our
conÔ¨Çict data is derived from 550,000 development versions of the
systems.
Second, using previously-unexploited information, we precisely
diagnose important classes of conÔ¨Çicts using the novel technique of
speculative analysis over version control operations.
Third, we describe the design of Crystal, a publicly-available
tool that uses speculative analysis to make concrete advice unob-
trusively available to developers, helping them identify, manage,
and prevent conÔ¨Çicts.
Categories and Subject Descriptors: D.2.3 [Software Engineer-
ing]: Coding Tools and Techniques; D.2.6 [Software Engineering]:
Programming Environments; D.2.8 [Software Engineering]: Met-
rics: process metrics
General Terms: Design, Human Factors, Experimentation
Keywords: collaborative development, collaboration conÔ¨Çicts, de-
veloper awareness, speculative analysis, version control, Crystal
1. Introduction
Each member of a collaborative development project works on an
individual copy of the project Ô¨Åles (source code, build Ô¨Åles, etc.).
Each developer repeatedly makes changes to his or her local copy
of the Ô¨Åles, shares those changes with the team, and incorporates
changes from teammates.
The loose synchronization of these activities permits rapid devel-
opment progress, but also allows two developers to make simulta-
neous, conÔ¨Çicting changes. Such conÔ¨Çicts [8, 11, 13, 17, 23, 34]
are costly: they delay the project while the conÔ¨Çict is understood
and resolved. Fear of conÔ¨Çicts is also costly. A developer may
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE‚Äô11, September 5‚Äì9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.choose to postpone the incorporation of teammates‚Äô work because
of a concern that a conÔ¨Çict may be hard to resolve [8, 13]. Ironi-
cally, this fear of potential conÔ¨Çicts can cause developer copies to
diverge, making realconÔ¨Çicts more likely.
ConÔ¨Çicts can be textual orhigher-order . A textual conÔ¨Çict arises
when two developers make inconsistent changes to the same part
of the source code. To prevent subsequent changes from overwrit-
ing previous ones, a version control system (VCS) allows the Ô¨Årst
developer to publish changes, but precludes the second developer
from publishing until the conÔ¨Çict is resolved automatically (by the
VCS) or manually (by a developer). Higher-order, and likely more
damaging conÔ¨Çicts arise when the VCS can integrate the develop-
ers‚Äô textual changes, but the changes are semantically incompatible
and can cause compilation errors, test failures, or other problems.
Such conÔ¨Çicts are problematic to detect and resolve in practice [17].
As with errors in programs, it is generally easier and cheaper to
identify and Ô¨Åx conÔ¨Çicts early, before they propagate in the code
and the relevant changes fade away in the memories of the develop-
ers. Currently, this information is not readily available to develop-
ers [9].
Our approach, speculative analysis, unobtrusively provides in-
formation about the presence or absence of conÔ¨Çicts in a continual
and accurate way. Our intent is for this information to allow de-
velopers make better-informed decisions about how and when to
share changes, while simultaneously reducing the need for human
processing and reasoning. We make the following contributions:
We analyze nine open-source systems and show that, in prac-
tice, conÔ¨Çicts between developers‚Äô copies of a project are: (1)
the norm, rather than the exception, (2) persist, on average, 10
days, and (3) are often higher-order.
Using previously-unexploited information, we precisely diag-
nose important classes of conÔ¨Çicts and offer concrete advice
about addressing them. We do this by introducing a novel
technique called speculative analysis that anticipates actions a
developer may wish to perform and executes them in the back-
ground. Reporting the consequences of these likely version
control operations can improve the way in which collaborative
developers identify and manage conÔ¨Çicts.
We design and implement an open-source, publicly-available
tool called Crystal1‚Äîhttp://crystalvc.googlecode.com
‚Äî that implements the analyses and unobtrusively presents ad-
vice to developers, to aid them in identifying, managing, and
preventing conÔ¨Çicts.
Section 2 provides a brief scenario of two collaborative develop-
ers, sketching how their development activities would differ with
1Crystal ‚Äúexceeded expectations‚Äù of the ESEC/FSE 2011 artifact evaluation com-
mittee.Figure 1: A screenshot of the Crystal tool as run by a developer
named George. The green arrow informs George that his changes
can be published (uploaded) without conÔ¨Çict to the master reposi-
tory. The red merge symbol indicates that Ringo‚Äôs changes, if com-
bined with George‚Äôs, would cause a test (‚ÄúT‚Äù) failure.
and without the use of a Crystal-like tool. Section 3 presents VCS
terminology. Section 4 details our retrospective analysis of the fre-
quency and persistence of conÔ¨Çicts in practice. Section 5 describes
the information that can help developers better manage their con-
Ô¨Çicts. Section 6 introduces the design of Crystal, an unobtrusive
tool that computes and reports this information to developers. Sec-
tion 7 surveys related work. Section 8 discusses threats to validity.
Finally, Section 9 summarizes our results and contributions.
2. Scenario
Consider a simple scenario with George and Ringo adding fea-
tures to a project. As part of George‚Äôs feature, he makes changes
to a library that Ringo also uses. When Ô¨Ånished, George and Ringo
each independently publish their changes to the master repository.
Whenever the regression tests run after both have published, George
and Ringo are notiÔ¨Åed about failing tests. At that time, they have
to recollect their earlier changes and assumptions, and their Ô¨Åxes
might force them to rework other code they had written in the mean-
while.
One way to lessen these difÔ¨Åculties is to use an awareness tool,
which reports where in the code base teammates are working, al-
lowing a developer to be more attentive to conÔ¨Çicts that may arise
in those locations (see Section 7 for more details). For example,
when George edits the library, an awareness tool may tell Ringo that
someone else is editing code he depends on. However, if George‚Äôs
change to the library had not actually affected Ringo, the warn-
ing would have been a false positive. Furthermore, George might
have been exploring some ideas and changes, without ever intended
to share the intermediate changes with his team. Thus, awareness
tools have the potential to give early warnings, but also the potential
to give multiple types of false warnings.
By contrast, consider what would have happened if George and
Ringo were using a speculative analysis tool, such as our tool Crys-
tal, that proactively informs developers of version control conÔ¨Çicts.
Figure 1 shows how Crystal informs George that his library changes‚Äô
integration with Ringo‚Äôs changes causes Ringo‚Äôs test suite to fail.
The tool encourages George and Ringo to address the impending
conÔ¨Çict before their assumptions and understanding of the changes
fade.
Speculative analysis [4] does not guess at possible conÔ¨Çicts. In-
stead, it speculatively performs the work and executes the VCS op-
erations in the background on clones of the program: it actually
merges George‚Äôs and Ringo‚Äôs committed code, builds it, and runs
its tests. This allows speculative analysis to deliver precise informa-
tion about conÔ¨Çicts: those that can be merged safely are not reported
as potential conÔ¨Çicts, and textually-clean merges that fail to build
or test properly are reported as conÔ¨Çicts. With respect to the is-
sue of exploratory development and awareness tools, our approach
assumes that when a developer commits code to the VCS, the de-veloper decided to share that code with other developers. Overall,
our approach provides precise and pertinent information available
as soon as conÔ¨Çicts occur in the VCS.
3. Terminology
Our results are applicable in the context of both centralized ver-
sion control systems (CVCSes) ‚Äî such as CVS, Subversion, and
Perforce ‚Äî and distributed version control systems (DVCSes) ‚Äî
such as Git and Mercurial. This paper focuses on DVCSes to sim-
plify the presentation. We Ô¨Årst brieÔ¨Çy present accepted DVCS ter-
minology. We then introduce additional new terminology to allow
us to precisely characterize seven pertinent relationships between
repositories.
3.1 Version control terminology
Figure 2 shows a common [31] DVCS repository setup. There
is a single master repository and four developers: George, Paul,
Ringo, and John. Each developer makes a local repository clone
from the master. Each local repository contains a complete and in-
dependent history of the master repository at the time it was cloned.
In addition, each repository has a working copy , in which code
is edited. Changing the working copy does not modify the local
repository; to modify the local repository the developer commits
achangeset to the local repository‚Äôs history. Teammates are not
privy to these changesets until the developer pushes them to the
master repository from the local repository. After a push, another
developer can perform a pull from the master, which updates that
developer‚Äôs local repository with the changesets. To refresh a work-
ing copy after a pull, the developer must apply the update operation.
It is common for developers in a DVCS to commit multiple times
before publishing through a push. It is uncommon for develop-
ers to pull without a corresponding update. A merge conÔ¨Çict can
arise due to a pull operation, and the conÔ¨Çict must be resolved be-
fore proceeding. The terms used above are common, or have direct
equivalents, across DVCS systems.
The discussion in this paper makes a few simplifying assump-
tions for clarity: one, it assumes that developers push to and pull
from only the master repository; two, it assumes that developers
only make a commit when all their tests pass. However, our ap-
proach in general, and the Crystal tool, in particular, handle arbi-
trary pushes, pulls, and commits.
3.2 Repository relationships
We have identiÔ¨Åed seven relevant relationships that can hold be-
tween two repositories. Figure 2 illustrates these relationships.
SAME :The repositories have the same changesets. For example,
George‚Äôs repository is the S AME as the master repository be-
cause they both consist of changesets 100 and 101.
AHEAD :The repository has a superset of the other repository‚Äôs
changesets. For example, George‚Äôs repository is A HEAD of
Paul‚Äôs.
BEHIND :The inverse of A HEAD ; for example, George‚Äôs reposi-
tory is B EHIND John‚Äôs.
The remaining four relationships represent repositories that share
an initial sequence of changesets followed by distinct sequences of
changesets.
TEXTUAL 8:(pronounced ‚Äútextual conÔ¨Çict‚Äù) The distinct change-
sets necessitate human intervention as they cannot be automat-
ically merged by the VCS. For example, if George‚Äôs changeset
101 and Ringo‚Äôs changeset 102 modify overlapping lines of
code, they are in T EXTUAL 8.100
101
103history
100
102history
100history100
101
commit100
101historyrepo
repo repo repopull
push
working copy
George‚Äôs clone John‚Äôs clonemaster
Paul‚Äôs clone Ringo‚Äôs cloneupdate
working copyworking copyworking copyrepohistoryFigure 2: A DVCS with four clones of a master repository. The box
labeled ‚Äúhistory‚Äù lists those changesets currently in the repository.
Each repository may have a working copy. The commit command
creates a new changeset in its repository‚Äôs history, and the update
command incorporates changesets into the working copy. A devel-
oper can incorporate changesets from other repositories using the
pull command and can share changesets using the push command.
BUILD8:The repositories can be automatically merged by the VCS,
but the resulting merged code fails to build.
TEST8:The repositories can be automatically merged by the VCS
and the resulting merged code builds but fails its test suite.
TESTX:The repositories can be automatically merged by the VCS
and the resulting merged code builds and passes its test suite.
Analogously to T ESTX, there there are relationships B UILDX
and T EXTUAL Xwith the obvious meanings. The table header of
Figure 4 illustrates the interrelation among the relationships. When
build scripts and test suites are not available, we will distinguish
only Ô¨Åve relationships: S AME , AHEAD , BEHIND , TEXTUAL X, and
TEXTUAL 8.
Higher-order conÔ¨Çicts, such as B UILD8and T EST8, are not con-
sidered by existing VCS systems. Although this paper discusses
only these two higher-order relationships, others naturally arise for
other analyses; for example, consider when a test suite passes but a
performance analysis or code style checker does not.
4. ConÔ¨Çicts in practice
This section answers the following research questions. ‚ÄúHow
often do the T EXTUAL 8, BUILD8, TEST8, and T ESTXrelation-
ships of Section 3.2 happen?‚Äù Section 4.1 focuses on the T EX-
TUAL8relationship, and Section 4.2 addresses B UILD8, TEST8,
and T ESTX. Section 4.3 asks ‚ÄúHow long do developers experience
the conÔ¨Çict relationships such as T EXTUAL 8?‚Äù Section 4.4 asks
‚ÄúHow damaging is it not to share changes with teammates, if those
changes would currently merge cleanly?‚Äù
Anecdotally, conÔ¨Çicts are a serious problem. For example, in
a private communication, an industrial manager expressed the fol-
lowing concerns to us about his two offshore teams and their col-
laboration with his local team:
‚ÄúThe remote guys tend not to commit frequently enough to
get leverage out of our continuous integration builds, even
after prompting. It is a real challenge to know how far out of
sync [the remote teams] are [with the local team] when their
commits are not being merged in regularly.
. . .
I want [my developers] to at least initiate a conversation with
the relevant parties when the system says they have, or aresystem KNCSL devs changesets days description
Gallery3 57 24 4,838 437 Web-based photo album
Git 267 27 20,785 1,741 Version control system
Insoshi 173 15 1,316 629 Social networking platform
jQuery 26 23 2,183 1,393 JavaScript library
MaNGOS 643 27 3,511 626 Online game server
Perl5 660 51 34,653 8,061 Programming language
Rails 141 50 12,342 1,875 Web application framework
Samba 1,363 59 58,802 5,001 File and print services
V oldemort 103 22 1,219 375 Structured storage system
Total 3,433 298 138,549 20,138
Figure 3: Nine subject programs analyzed to address RQ1, RQ2,
and RQ3 in collaborative development environments. KNCSL
stands for thousands of non-comment source lines. The version
control history ends on Feb 13, 2010.
just about to, walk into a conÔ¨Çicting situation. I also want
the system to give them a certain level of trust of other de-
veloper‚Äôs changes so that if [a merge] won‚Äôt cause a problem,
they should sync up.‚Äù
There is little hard data on conÔ¨Çicts. Zimmermann‚Äôs analysis of
CVS repositories for four open source systems is the only work we
could Ô¨Ånd that directly addresses this issue [34]. He reported that
of all merges, 23% to 47% had textual conÔ¨Çicts (T EXTUAL 8) while
the remainder could be merged automatically (T EXTUAL X). An-
swering RQ1 and RQ2 requires analyses that signiÔ¨Åcantly augment
these data and anecdotes.
As subject programs (Figure 3), we chose Git itself and the eight
most active projects on GitHub ( http://github.com ) that satisfy
the following three criteria: (1) at least 10 developers, (2) at least
1000 changesets, and (3) not just a Git copy of a CVC repository
(which would not contain sufÔ¨Åcient information to answer our re-
search questions).
4.1 Textual conÔ¨Çicts
RQ1: How frequently do conÔ¨Çicts ‚Äî textual and higher-
order ‚Äî arise across developers‚Äô copies of a project?
The answer to RQ1 is that conÔ¨Çicts are the norm: for each subject
system, there were no times when all pairs of developers were in
consistent relationships (S AME , AHEAD , or B EHIND ) with each
other.
Figure 4 shows how often developers merged their changes. (This
is analogous to Zimmermann‚Äôs result described above.) Of all the
merges, one in six, or 17%, had textual conÔ¨Çicts as determined by
Git‚Äôs built-in merging mechanism, reÔ¨Çecting the T EXTUAL 8rela-
tionship. (This number may be smaller than Zimmermann‚Äôs 23‚Äì
47% due to better merging algorithms in DVCSes.) The other 83%
of the merges had no textual conÔ¨Çicts, meaning the relevant de-
velopers were in the T EXTUAL X(including B UILD8and T EST8)
relationship.
The importance of the frequency of the T EXTUAL 8relationship
is clear: an unrecognized T EXTUAL 8between the repositories of
two developers may cause problems. The importance of the fre-
quency of the T EXTUAL Xrelationship is also material: a devel-
oper who is unsure whether others‚Äô changes can be incorporated
safely might avoid doing so, allowing conÔ¨Çicts to persist and grow
(as suggested in the manager‚Äôs quotation above).
Figure 5 considers every commit at which developers who did
eventually merge their changes could have done so earlier. On av-
erage, 19% of the potential merges would have resulted in a tex-
tual conÔ¨Çict. In other words, had the developers been using Crys-systemTEXTUAL 8 TEXTUAL X
merges BUILD8 BUILDX
TEST8 TESTX
Git 1,362 227 17% 2 .1% 53 4% 1,080 79%
Perl5 185 14 8% 7 4% 51 28% 113 61%
V oldemort 147 25 17% 15 10% 5 3% 102 69%
Gallery3 458 42 9% 416 91%
Insoshi 93 23 25% 70 75%
jQuery 15 1 7% 14 93%
MaNGOS 192 81 42% 111 58%
Rails 362 51 14% 311 86%
Samba 748 100 13% 648 87%
total 3,562 564 16% 2,998 84%
Figure 4: Historical merges. Frequencies with which developers
experienced T EXTUAL 8, BUILD8, TEST8, and T ESTXrelation-
ships when they integrated their code. For three systems with non-
trivial test suites in the repository, we measured the frequencies of
all four relationships; for the other six (which had no non-trivial
test suite that we could run), we measured only T EXTUAL 8and
TEXTUAL X.
tal, it would have informed developers about T EXTUAL 8relation-
ships that resulted from 19% of the commits. Conversely, the 81%
of clean merges indicate the likely beneÔ¨Åt of notifying developers
when a safe textual merge can be performed.
4.2 Higher-order conÔ¨Çicts
In our subject programs, 17% of merge operations required hu-
man assistance to resolve a textual conÔ¨Çict (Figure 4). This un-
derestimates the human effort, since textually-safe merges are not
always safe: an automatically merged change may suffer a build
or test failure, for example. We computed the relationships at the
time of each of the 5,355 merges that developers performed during
the development of Git, Perl5, and V oldemort. We did not com-
pute the information for the other six subject program because of
the absence of a non-trivial test suite that we could run.
Figure 4 show that during the development of Git, Perl5, and
V oldemort, 76% of merges completed cleanly, 16% of merges re-
sulted in a textual conÔ¨Çict (T EXTUAL 8), 1% of merges resulted in a
build failure (B UILD8), and 6% of merges resulted in a test failure
(TEST8). The 266 textual conÔ¨Çicts reported by the version con-
trol system only represent 67% of all conÔ¨Çicts. Stated another way,
33% of the 399 merges that the version control system reported as
being a clean merge, actually were a build or test conÔ¨Çict.
Few current awareness tools detect higher-order conÔ¨Çicts (see
Section 7). Rather, they generally notify developers of all changes
to the repository (e.g., FASTDash [3]) or of concurrent changes to
ASTs (e.g., Syde [15]). In contrast, we use the project‚Äôs tool chain
to dynamically and precisely detect B UILD8relationships (via the
build system) and T EST8relationships (via the test suite).
4.3 Persistence of conÔ¨Çicts
RQ2: How long do conÔ¨Çicts persist?
RQ2 asks how long developers experience the T EXTUAL 8re-
lationship. As we argue in Section 4.4, the longer a relationship
persists, the more opportunities it has to change into a more severe
relationship.
To measure the lifespan of a conÔ¨Çict, for each conÔ¨Çict that was
eventually resolved, we found the Ô¨Årst changeset that introduced the
conÔ¨Çict and the changeset that resolved it. (We omitted all conÔ¨Çicts
between changesets that were never actually merged in the history,system merges TEXTUAL 8 TEXTUAL X
Git 179,249 15,965 9% 163,284 91%
Perl5 7,352 1,290 18% 6,052 82%
V oldemort 4,512 1,534 34% 2,978 66%
Gallery3 6,924 1,262 18% 5,662 82%
Insoshi 1,742 736 42% 1,006 58%
jQuery 74 13 18% 61 82%
MaNGOS 4,967 1,092 22% 3,875 78%
Rails 10,418 2,971 29% 7,447 71%
Samba 77,683 30,635 39% 47,048 61%
total 292,921 55,498 19% 237,423 81%
Figure 5: Potential early merges. The frequency with which devel-
opers would be informed of T EXTUAL 8and T EXTUAL Xrelation-
ships, if they had used Crystal throughout their development of nine
open-source systems.
such as those on dead-end branches.) Due to the sheer volume of the
data and computation necessary to process it, we examined the de-
velopment histories of only four of our subject programs: Gallery3,
Insoshi, MaNGOS, and V oldemort.
On average, the T EXTUAL 8relationship persisted for 9.8 days
and involved 23.2 changesets ‚Äî 11.6 per developer ‚Äî (with me-
dian values of 1.6 days and 3 changesets) before incorporating (left
side of Figure 6). A tool could have let developers know about these
TEXTUAL 8relationships immediately upon their creation. In the
worst case, one T EXTUAL 8relationship in MaNGOS persisted for
334 days and included 676 changesets by one of its developers.
If developers know that they can merge others‚Äô changes safely,
they may do so quickly and thus prevent a future conÔ¨Çict. The
longer a T EXTUAL Xrelationship persists, the more opportunities
it has to change into a conÔ¨Çict. Accordingly, we asked ‚ÄúHow long
do developers experience the T EXTUAL Xrelationship?‚Äù We mea-
sured the lifespan of a T EXTUAL Xrelationship for each conÔ¨Çict-
free merge in the history (again comparing the changeset that intro-
duced the relationship to the one that resolved it).
On average, the T EXTUAL Xrelationship persisted for 11 days
and spanned 23 changesets ‚Äî 11.5 per developer ‚Äî (with median
values of 1.9 days and 3 changesets) before incorporation (right
side of Figure 6). A tool could have helped developers learn im-
mediately about the T EXTUAL Xrelationship, encouraging earlier,
smooth incorporation. In the worst case, in terms of time, one T EX-
TUALXrelationship in V oldemort persisted for 138 days; in terms
of changesets, one T EXTUAL Xrelationship in Gallery3 persisted
for 232 changesets without a merge, while each of the possible
merges along the way would have been textually clean and fully
automated.
4.4 Escalation of clean merges into conÔ¨Çicts
RQ3: Do clean merges devolve into conÔ¨Çicting changes?
Parallel work enables faster progress, but also the creation of con-
Ô¨Çicts. We, and others, argue that developers should perform safe
merges as frequently as possible. To determine how often, in prac-
tice, parallel editing escalates into a conÔ¨Çict, we used a methodol-
ogy similar to that of Section 4.3.
Every conÔ¨Çict relationship develops from a situation in which a
second developer makes a change without having incorporated and
understood a Ô¨Årst developer‚Äôs work. We found that of all conÔ¨Çict
relationships (T EXTUAL 8, BUILD8, and T EST8), 93% developed
from a T ESTXrelationship; the other 7% of conÔ¨Çict relationships
developed from a B EHIND relationship. In other words, in almost
every case, both developers had already committed (but not shared)TEXTUAL 8relationships TEXTUAL Xrelationships
system number length (days) length (changesets) number length (days) length (changesets)
mean stddev median mean stddev median mean stddev median mean stddev median
V oldemort 39 25.7 35.0 8.9 12.8 16.4 6 128 35.0 46.6 7.3 9.7 15.1 3
Gallery3 80 3.1 9.4 0.7 7.5 19.7 3 483 7.1 12.5 1.0 14.3 30.0 3
Insoshi 27 11.8 21.2 4.8 9.4 16.3 3 87 7.7 13.5 3.7 6.3 8.5 3
MaNGOS 58 8.2 44.0 1.8 17.6 83.0 3 118 2.4 2.1 1.7 5.8 7.1 3
Total 204 9.8 30.3 1.6 11.6 96.9 3 816 11.0 23.8 1.9 11.5 24.2 3
BinFreq[0-3 min)[3-15 min)[15-120 min)[120 min - 9h)[9h - 2d)[2 - 12d)[12 - 72d)[72-421d)1419216562217
010203040506070
[0-3 min)[3-15 min)[15-120 min)[120 min - 9h)[9h - 2d)[2 - 12d)[12 - 72d)[72-421d)7216265
211941FrequencyBinFreq[0-3 min)[3-13 min)[13-72 min)[72 min -6.4h)[6.4h - 1.5d)[1.5 - 7.9d)[7.9 - 43d)[43-236d)111468123923415153
050100150200250
[0-3 min)[3-13 min)[13-72 min)[72 min -6.4h)[6.4h - 1.5d)[1.5 - 7.9d)[7.9 - 43d)[43-236d)53151234239
8146111Frequency
BinFreq[0-3 min)[3-15 min)[15-120 min)[120 min - 9h)[9h - 2d)[2 - 12d)[12 - 72d)[72-421d)1419216562217
010203040506070
[0-3 min)[3-15 min)[15-120 min)[120 min - 9h)[9h - 2d)[2 - 12d)[12 - 72d)[72-421d)
7
21
62
65
21
19
4
1FrequencyBinFreq[0-3 min)[3-13 min)[13-72 min)[72 min -6.4h)[6.4h - 1.5d)[1.5 - 7.9d)[7.9 - 43d)[43-236d)111468123923415153
050100150200250
[0-3 min)[3-13 min)[13-72 min)[72 min -6.4h)[6.4h - 1.5d)[1.5 - 7.9d)[7.9 - 43d)[43-236d)53151234239
8146111Frequency
Figure 6: Persistence of the T EXTUAL 8(left) and T EXTUAL X(right) relationships in historical data. The distributions are shown in eight-
bucket geometric-progression histograms.
changes before the conÔ¨Çict developed. Every T EXTUAL 8relation-
ship could have been prevented by earlier incorporation of others‚Äô
changes. Some B UILD8and T EST8relationships could also be
prevented, and the others would at least be discovered locally and
immediately, and would never be committed to the version control
system.
We also found that 20% of T ESTXrelationships devolved into a
conÔ¨Çict. The remaining 80% of T ESTXrelationships were merged
successfully, preventing a conÔ¨Çict from developing. This suggests
that what we call ‚Äúsafe merges‚Äù are actually at risk of devolving
into conÔ¨Çicts that require human effort to resolve. Being aware of
these merges early may prevent some such conÔ¨Çicts from arising.
While DVCSes record sufÔ¨Åcient information to let us reconstruct
how often a conÔ¨Çict arose from a B EHIND relationship, they do
not record information that would allow us to determine how often
a B EHIND relationship devolves into a conÔ¨Çict. We suspect that
BEHIND relationships are also risky.
5. Information about conÔ¨Çicts
RQ4: What information could developers use to reduce
the frequency and duration of conÔ¨Çicts?
What kind of unexploited information is available from a VCS
that is not yet leveraged to smooth collaboration? What information
could help the developer make better-informed decisions, such as
whether to perform a particular VC operation, to wait for a cowork-
er to perform one, or to communicate directly with a coworker?
We explored this space systematically by analyzing a hypotheti-
cal global view of all version control information in all repositories.
We then systematically analyzed this perspective by (1) enumerat-
ing all possible version control situations that can arise during col-
laborative development, (2) determining, based on the global per-
spective, the best course of action for the team, (3) identifying what
information that decision depended on, and (4) classifying the ad-
vice for the team.
We made the following assumptions in our exploration:
Without loss of generality, we considered all situations with
three developers, using the third developer to represent arbi-
trary other developers and repository hierarchies.We limit our lookahead to two rounds of version control oper-
ations: one developer performs one VC operation and then the
other developer may or may not perform one.
This approach has allowed us to identify key common and im-
portant use cases.
Section 5.1 describes Ô¨Åve pertinent local states of a developer.
We augment our classiÔ¨Åcation of the relationships between devel-
opers‚Äô repositories (already described in Section 3.2) with two other
categories of information: the developer‚Äôs possible actions (Sec-
tion 5.2) and guidance about those actions (Section 5.3). Finally,
we describe the information available about higher-order conÔ¨Çicts,
speciÔ¨Åcally build and test conÔ¨Çicts (Section 5.4).
5.1 Local states
The Ô¨Åve possible local states are:
uncommitted There are uncommitted changes in the working copy.
in conÔ¨Çict The local repository is in conÔ¨Çict with itself; that is,
it has two heads that are not automatically mergeable. This
happens, for example, when pulled changesets conÔ¨Çict with
local changesets.
build failure The repository‚Äôs version of the code fails to build.
test failure The repository‚Äôs version of the code builds but fails its
test suite.
OK The repository‚Äôs version of the code builds and passes its test
suite.
These states are not mutually incompatible; for example, a user
may have uncommitted changes, be in conÔ¨Çict with itself, and have
different build/compile status for each head and for the working
copy. Furthermore, these states obscure some information, such as
whether the working copy has been updated to all of the changesets
in the local repository. The list also omits some states, such as when
the local repository has two heads that can be merged automatically.
Our approach and tools can handle such situations. For simplicity
of exposition, however, this paper classiÔ¨Åes each developer‚Äôs state
as the Ô¨Årst one in the list that holds. This is all the information about
state that is needed to provide the generally best advice to the team.5.2 Actions
Given two repositories AandB, the relationship between Aand
Bas well as the local states determine the possible actions that de-
velopers can perform.
SAME : Nothing to do.
AHEAD : May push; the new relationship will be S AME .
BEHIND : May pull; the new relationship will be S AME .
TEXTUAL 8: May pull; will result in the ‚Äúin conÔ¨Çict‚Äù state. May
push; Bwill be in the ‚Äúin conÔ¨Çict‚Äù state.
BUILD8: May pull and merge; will result in the ‚Äúbuild fail-
ure‚Äù state. May push; Bwill be in the ‚Äúbuild failure‚Äù
state.
TEST8: May pull and merge; will result in the ‚Äútest failure‚Äù
state. May push; Bwill be in the ‚Äútest failure‚Äù state.
TESTX: May pull and merge; the new relationship will be
AHEAD . May push; Bwill be able to merge the
changes cleanly.
The consequences of applying available actions can be tricky to
understand and remember. One example is when the available ac-
tions are the same but the consequences differ. For example, the
developer can cleanly pull in both the B EHIND and T ESTXrelation-
ships. However, in the B EHIND case, the developer ends up in the
SAME relationship, while in the T ESTXcase, the developer ends
up in the A HEAD relationship. Another example is when there are
side-effects of performing an operation intended to change the rela-
tionship between AandB, such as incorporating B‚Äôs changes into A
may put Aand another repository Cinto a T EXTUAL 8relationship.
Using global version control information to help developers track
such situations can be beneÔ¨Åcial.
The local state also partially determines which version control op-
erations can be executed in different situations.
IfA‚Äôs state is ‚Äúuncommitted‚Äù , then the ‚Äúupdate‚Äù operation cannot
be applied. If A‚Äôs state is not ‚Äúuncommitted‚Äù , then the ‚Äúcommit‚Äù
operation is inapplicable.
IfA‚Äôs state is ‚Äúin conÔ¨Çict‚Äù , then all operations except ‚Äúmerge‚Äù are
discouraged. (DVCSes permit most operations at any moment, but
discourage some of them, most commonly by aborting the opera-
tion unless the user supplies an extra conÔ¨Årmation Ô¨Çag.) If A‚Äôs state
is not ‚Äúin conÔ¨Çict‚Äù , then the ‚Äúmerge‚Äù operation is inapplicable. The
‚Äúbuild failure‚Äù and ‚Äútest failure‚Äù states do not limit the possible ac-
tions ‚Äî VCSes are as yet unaware of such local states ‚Äî although
Ô¨Åxing these problems should likely be a priority. The ‚ÄúOK‚Äù state
does not limit the possible actions.
5.3 Guidance
Information about how each action may affect the developer‚Äôs
state and relationships can help developers make better-informed
decisions.
This section makes one common, generally realistic assumption:
developers perform actions in a tree hierarchy, pushing only to and
pulling only from a parent. This aligns with how developers pre-
dominantly interact with VCSes [31]. Further, we consider only
information relevant to two developers who share a common par-
ent repository (possibly that of one of the developers themselves),
because in all other cases, the developers‚Äô relationship is dependent
on actions by others.
We classify the guidance information into Ô¨Åve types. One type of
information concerns the relationship: Committer . The other four
concern the possible action: When ,Consequences ,Capable , and
Ease .
Committer : Who made the relevant changes?
Consider George and Ringo again, now working on a team with
Paul. If George knows he is in the T EXTUAL 8relationship withRingo, George might decide to contact Ringo to discuss the situa-
tion. However, Ringo may not have made the conÔ¨Çicting changes;
instead, Paul may have made and pushed the changes to the mas-
ter, and Ringo then pulled them from the master. In this case,
George should likely discuss the conÔ¨Çict with Paul rather than with
Ringo. Knowing the committer facilitates communication between
relevant parties, which in turn decreases the time required to Ô¨Åx
conÔ¨Çicts [6].
When : Can an action that affects the relationship be performed
now, or must it wait until later?
Ringo can be in the B EHIND relationship with George but may be
unable to incorporate his changes because George may not have yet
pushed them to the master. Thus, it may be helpful for Ringo to
know that although he will need to pull at some point, he cannot
get George‚Äôs changes until George pushes. As another example, a
developer may have to resolve an ‚Äúin conÔ¨Çict‚Äù state before being
allowed to push.
Consequences : Will an action ‚Äî perhaps one on a different repos-
itory ‚Äî affect a relationship?
The situation with Ringo B EHIND George illustrates this kind of
guidance as well. Is Ringo B EHIND George because George has not
yet pushed his changes to the master, or because George has pushed
but Ringo has not yet pulled from the master? In the Ô¨Årst case, even
if Ringo pulls from the master, his relationship with George will not
change. In the second case, if Ringo pulls, he will become S AME
with George.
Capable : Who can perform an action that changes the relationship?
Consider a situation in which George is in the T EXTUAL 8rela-
tionship with Ringo. If Ringo has already pushed his changes to
the master, then George must be the one who resolves the conÔ¨Çict
when he eventually pulls from the master. Conversely, if George
has already pushed his changes, he cannot resolve the conÔ¨Çict any
longer. And if neither has pushed, either of them might be the one
to resolve the conÔ¨Çict.
Ease : Has anyone made changes that ease resolving an existing
conÔ¨Çict?
Suppose George and Ringo created conÔ¨Çicting changes and Ringo
has pushed his to the master. If George were to pull from the master,
he would have to resolve the conÔ¨Çict. What if Ringo has made a set
of follow-up changes that he has not yet pushed? If these changes
resolve the conÔ¨Çict, then it is likely better for George to wait for
Ringo to push his new changes. Ringo‚Äôs pushing action would be
the best way to resolve George‚Äôs T EXTUAL 8with the master.
By performing actions, developers can affect how long a con-
Ô¨Çict persists, or even prevent it from ever occurring. The guidance
information can help developers decide which actions to perform.
Knowing of a conÔ¨Çict relationship can encourage the developer to
address it earlier, while the changes are fresh in the relevant devel-
opers‚Äô minds; this may reduce the conÔ¨Çict‚Äôs duration as well as the
effort necessary to resolve it. Knowing about B EHIND and T ESTX
relationships can reassure developers that it is safe to incorporate
others‚Äô changes, which in turn keeps the development states closer
together. In some cases, this may also allow the developer to pre-
vent some potential conÔ¨Çicts altogether, which would also reduce
conÔ¨Çict frequency. At a minimum, these relationships can prompt
developers to communicate, which can reduce conÔ¨Çicts in the de-
velopers‚Äô mental models and work plans.
The Committer guidance informs the developers of who else is
relevant to a conÔ¨Çict, reducing the time required to resolve it [6].
TheWhen andCapable guidance can inform developers of the right
time to perform an action, eliminating the overhead of manually Ô¨Åg-
uring out if an action can be performed now and possibly having toundo actions later. The Consequences guidance can allow the de-
velopers a peek into the future, also limiting undoing and redoing of
work. Finally, the Ease guidance can inform a developer if some-
one else may have an easier time resolving a conÔ¨Çict, thus helping
reduce the effort needed to resolve it.
5.4 Examples of higher-order conÔ¨Çicts
Early identiÔ¨Åcation of higher-order conÔ¨Çicts between developers
reduces ‚Äî or at the least is highly unlikely to increase ‚Äî the time
to resolve a conÔ¨Çict. We describe a T EST8and a B UILD8example
from V oldemort.
Malformed non-code resource: On October 10, 2009, a devel-
oper successfully merged two branches (‚Äútips‚Äù in Git), 50b74 and
00c35 . Branch 00c35 was edited 17 times while the branch was
alive and the last changeset on this branch occurred only eight min-
utes before the merge. Branch 50b74 had not been edited in the pre-
vious 48 days. Although the patch between these two branches was
very large (63,413 lines), Git successfully merged these change-
sets. Test voldemort.store.http.HttpStoreTest::testBad-
Port() did not fail either branch before the merge, but did in the
merged system. Thus, some unintended behavioral interaction be-
tween the two branches‚Äô changes broke this test. In fact, the merge
invalidated one of the metadata Ô¨Åles, cluster.xml . In this case, if
a tool had let the developers know that it was safe to merge earlier,
the problem could have been avoided completely by sequentializ-
ing the changes to cluster.xml and/or by enabling earlier testing
of the merged version.
Missing type: On November 9, 2009, a developer successfully
merged branches c77a4 and7f776 . Branch 7f776 was edited 11
times while the branch was alive; branch c77a4 was edited three
times. Both branches had been modiÔ¨Åed within four days of the
merge. While the merge had no textual conÔ¨Çicts, the code failed to
build: four compilation errors resulted from referencing a missing
type ProtoBuffAdminClientRequestFormat . Later, the devel-
oper merged in another branch ( 68e3b ), which resolved the compi-
lation problem.
In this case, a tool could have speculatively told the developer
about the compilation error that would arise as the result of the
merge. With this information, the developer may have chosen to do
the merges in an alternate order, or manually, to avoid the problem
and ensure other developers were not adversely affected.
6. Delivering version control advice
Given that version control conÔ¨Çicts are frequent and serious (Sec-
tion 4) and that a global view of the VCS could detect conÔ¨Çicts and
reduce their frequency and severity (Section 5), how can a tool ef-
fectively deliver that information and advice to developers?
The design of our tool, Crystal, has several ways to convey the
key information without overwhelming or distracting the developer,
(1) The main window summarizes all projects and relationships, al-
lowing a developer to instantly scan it to identify situations that may
require attention. (2) The main window is compact butnot needed
if the developer prefer to receive limited but critical information.
(The main nor any other window is ever opened asynchronously.)
(3) Full, detailed information about each relationship, action, and
guidance is available but hidden until a developer shows speciÔ¨Åc
interest in it.
Crystal uses (1) icons exploiting color and shape in stable lo-
cations in the main window (rather than, say, a textual list that a
developer would have to read and interpret), (2) a taskbar icon in
the system tray to report the most severe state for all tracked repos-
itories, and (3) mouse-over tooltips that provide, on demand, all the
information discussed in Section 5.
Figure 7: A screenshot of George‚Äôs view of Crystal. George is fol-
lowing two projects under development: ‚ÄúLet it be‚Äù and ‚ÄúHandle
with care‚Äù . The former has four observed collaborators: George,
Paul, Ringo, and John; the latter has Ô¨Åve: George, Jeff, Roy, Bob,
Tom. Crystal shows George‚Äôs local state and his relationships with
the master repository and the other collaborators, as well as guid-
ance based on that information.
Crystal addresses scalability by allowing developers to select the
repositories‚Äô relationships of interest. For example, a developer
may be interested in the relationships with those in the same col-
laborative team and the main development repositories of the other
teams. Crystal can provide information about relationships even
with developers who are not using it, easing adoption by avoiding a
requirement that the whole team uses the tool. Each developer can
independently choose whether or not to run Crystal. Advantages
accrue when more members of a team use Crystal, but this is not
necessary.
Crystal allows developers to select a subset of the tests to exe-
cute, to integrate more smoothly into large development projects
with extensive test suites. Naturally, for large projects with build
scripts and test suites that take a long time to execute, Crystal will
experience that latency. However, it would still identify relevant
information sooner than other existing methods.
We have implemented our design in Crystal, a tool that per-
forms speculative analysis of version control operations. Crystal
currently works with the Mercurial DVCS; later versions of Crys-
tal will support additional VCSes. Microsoft ‚Äî in cooperation
with us ‚Äî is developing a version of Crystal. Crystal is an open-
source, cross-platform, standalone tool and is available for down-
load: http://crystalvc.googlecode.com . Our initial qualita-
tive evaluation of Crystal is positive, but future work should evalu-
ate it via both qualitative and quantitative user studies.
6.1 Crystal‚Äôs UI
Figure 7 shows a screenshot of Crystal‚Äôs main window. The win-
dow displays a row of icons (see Figure 8) for each of a developer‚Äôs
projects. In this example, there are two projects: ‚ÄúLet it be‚Äù and
‚ÄúHandle with care‚Äù . The former has four collaborators: George (the
developer running Crystal), Paul, Ringo, and John. The latter has
Ô¨Åve collaborators: George, Jeff, Roy, Bob, and Tom.
On the leftmost side of the row, underneath the project name,
Crystal displays the local state. This tells George (in the native lan-
guage of the underlying VCS) whether he must commit changes ( hg
commit , in Mercurial) or resolve a conÔ¨Çict. Then Crystal displays
the relationship with the master and the collaborators‚Äô repositories.
If George has the ability to affect a relationship now, the icon isB
T
SAME AHEAD BEHIND TEXTUAL 8BUILD8TEST8TESTX
Figure 8: Crystal associates an icon with each of the seven relation-
ships. The color of each relationship icon represents the severity of
the relationship (Section 3.2): relationships that require no merg-
ing are green, that can be merged automatically are yellow, and that
require manual merging are red.
solid, which combines the When andCapable guidance. If George
cannot affect the relationship, the icon is hollow. For example, con-
sider John, who has made some changes in ‚ÄúLet it be‚Äù but has not
yet pushed them to the master; George is B EHIND John, but the
icon is hollow because George cannot affect this relationship until
John pushes. Similarly, George‚Äôs relationship with Ringo is a hol-
low T ESTXbecause (1) George has the S AME relationship with the
master, (2) Ringo had not pulled the latest changes from the mas-
ter, and (3) Ringo has made some other changes, which he has not
pushed but which can merge without human intervention. If the
relationship is of the might variety ‚Äî George might or might not
have to perform an operation to affect the relationship ‚Äî the icon is
solid but slightly unsaturated (see the relationship with Bob in the
‚ÄúHandle with care‚Äù project).
These features allow George to quickly scan the Crystal window
and identify the most urgent issues, the solid red icons, followed
by other, less severe icons. George can also easily identify quickly
whether there is something he can do now to improve his relation-
ships (in the example, George can perform actions to improve his
relationships in the ‚ÄúHandle with care‚Äù project, but not in ‚ÄúLet it
be‚Äù), and whether there are unexpected conÔ¨Çicts George may wish
to communicate with others about.
The most urgent relationship is displayed by Crystal as its system
tray icon, which allows a developer to know at all times whether
there is any action that requires attention without even having the
Crystal window open.
Crystal also provides other guidance that is hidden unless a de-
veloper wants to see it. Holding the mouse pointer over an icon
displays the action George can perform and the Committer ,Conse-
quences , and Ease guidance, when applicable. For example, when
George holds the mouse over Jeff‚Äôs T EXTUAL 8icon, it tells him
that he can perform a pull and a resolve ( hg fetch , in Mercurial),
that performing this action will resolve George‚Äôs T EXTUAL 8with
Jeff, and that Tom and George committed the conÔ¨Çicting change-
sets.
Even though George asked for information about the relationship
with Jeff, Crystal was able to correctly point George to Tom as
the developer who was responsible for the conÔ¨Çicting changesets
(which Jeff had pulled into his repository). In other situations, it
is possible that George performing a pull and resolve operations
with his parent would not resolve George‚Äôs T EXTUAL 8with Jeff
(e.g., if Jeff and Tom had both created conÔ¨Çicting changesets but
only Tom had pushed his changesets to the master). This is why
the consequences guidance is important. As a Ô¨Ånal note, because
no one else has merged these changesets, George must resolve this
conÔ¨Çict and there is no Ease guidance for Crystal to display.
6.2 Initial experience
Crystal consists of 5,200 NCSL of Java and has been tested on
Windows, Mac OS X, and several Linux distributions. The de-
veloper using Crystal must have read access to the collaborators‚Äô
repositories; the Crystal manual (available at http://crystalvc.
googlecode.com ) describes several simple ways to accomplish this.
We deployed the beta-test version of the tool to a small numberof developers and have been using it ourselves, and reÔ¨Åning it, since
early July 2010. One co-author uses Crystal to monitor 49 clones
of 10 projects belonging to eight actively working collaborators.
Designing and deploying Crystal, along with frequent feedback
from the handful of users, has helped us to better understand the
issues and to improve the tool‚Äôs design. Crystal user feedback
enhanced our understanding of the need for guidance as well as
which information is most pertinent to make available to the devel-
oper. For example, showing hollow and solid icons arose from a
user‚Äôs need to differentiate between relationships he or she could
and could not affect. The feedback drove us to systematically ex-
plore the complete space, as described in Section 5.
Here is one example piece of feedback from an external user, via
private communication:
‚ÄúKeeping a group of developers informed about the state of
a code repository is a problem I have tried solving myself.
My solution was an IRC bot that announced commits to an
IRC channel where all of the developers on the project idled.
This approach has many obvious problems. [. . . ] The Crys-
tal tool does not suffer from these problems. Crystal handles
several projects and users effortlessly and presents the nec-
essary information in a simple and understandable way, but
it is only a start at Ô¨Ålling this important void the in the world
of version control.‚Äù
Prior to developing Crystal, we surveyed 50 DVCS users about
their collaborative development habits. Their use of highly hetero-
geneous operating systems, IDEs, VCSes, and languages informed
Crystal‚Äôs design. Even among this small group, there were vast dif-
ferences in committing, pushing, and pulling styles, which further
encouraged our research. We anticipate that future user studies will
identify additional strengths and weaknesses that will allow us to
further improve Crystal.
7. Related Work
This section places our research in the context of related work
in evaluating the costs of conÔ¨Çicts, collaborative awareness, mining
software repositories, and continuous development.
7.1 The cost of conÔ¨Çicts
EfÔ¨Åcient coordination is important for effective software devel-
opment. The number of defects rises as the amount of parallel
work increases [23], but developers can more effectively manage
risks to the consistency of their systems if they are aware of the
consequences of their commits on other developers [11]. Develop-
ers eschew parallel work to avoid having to resolve conÔ¨Çicts when
committing changes [13], or rush their work into the trunk to avoid
being the developer who would have to resolve conÔ¨Çicts [8].
Several observational and laboratory experiments empirically as-
sess the beneÔ¨Åts of collaborative awareness for conÔ¨Åguration man-
agement [3, 10, 30]. Augmenting these results, we performed a
retrospective analysis on real projects to estimate the potential ben-
eÔ¨Åt. Our analysis is consistent with their studies in conÔ¨Årming the
potential for better coordination of individual and team repositories.
Sarma provides a comprehensive classiÔ¨Åcation of collaborative
tools for software development [27]; in this classiÔ¨Åcation, Crys-
tal could be considered a seamless tool as it provides continuous
awareness about development state and guidance about the conse-
quences of potential future actions.
7.2 Collaborative awareness
The research most similar in intent to ours studies collaborative
awareness ‚Äî increasing awareness of the activities among teammembers. Such awareness can be a distraction unless a conÔ¨Çict
is imminent, so awareness tools have adopted increasingly sophis-
ticated methods for avoiding false positive warnings, as we now
describe.
Palant√≠r [29, 28, 1] shows which developers are changing which
artifacts by how much. Palant√≠r has similar motivations to ours:
‚Äúproviding workspace awareness to users will enable them to detect
potential conÔ¨Çicts earlier, as they occur. Ideally developers can then
proactively coordinate their actions to avoid those conÔ¨Çicts‚Äù [29,
p. 444]. FASTDash [3] is similar: it is an interactive visualization
‚Äî a spatial representation of which Ô¨Åles each developer is edit-
ing ‚Äî that augments existing software development tools with a
speciÔ¨Åc focus on helping developers understand what other team
members are doing.
Syde [15] reduces false positives via a Ô¨Åne-grained analysis of
the abstract syntax trees (ASTs) modiÔ¨Åcations. Two potentially
conÔ¨Çicting changes to the same Ô¨Åle are Ô¨Çagged for a developer only
when they also affect changes to the same parts of the underlying
ASTs. For example, if two users have inserted, deleted, or changed
the same method, the changes will be Ô¨Çagged ‚Äúyellow‚Äù; if one of
user had committed, the changes would instead be Ô¨Çagged ‚Äúred‚Äù ,
indicating that there may be a merge conÔ¨Çict. Syde examines Ô¨Åles
every time they are saved.
The most detailed analysis is done by tools like CollabVS and
Safe-commit. CollabVS ‚Äúdetects a potential conÔ¨Çict when a user
starts editing a program element that has a dependency on another
program element that has been edited but not checked-in by an-
other developer‚Äù [10]. Safe-commit [33] does the deepest program
dependence analysis, identifying changes that are guaranteed not
to cause tests to fail. This allows earlier publishing of some of a
developer‚Äôs changes, on the theory that increasing the publishing
frequency can decrease the amount of duplicate development and
the likelihood of merge conÔ¨Çicts.
Our approach suffers fewer false positives and fewer false neg-
atives than previous awareness approaches [5] for several reasons.
First, our approach computes actual pending conÔ¨Çicts rather than
estimating potential ones. By speculatively doing exactly what a
developer will actually do in the future ‚Äî run a version control
operation, then run the build script and, Ô¨Ånally run the test script
‚Äî our approach only reports problems that would actually happen
while executing those steps. (A secondary beneÔ¨Åt of using the un-
derlying VCS directly is that users of Crystal can beneÔ¨Åt immedi-
ately from any improvements to the VCS merging algorithm.) Sec-
ond, Crystal does not report conÔ¨Çicts until they have been commit-
ted to some repository. This reduces false positives resulting from
exploratory edits, such as for debugging: developers typically com-
mit code that is consistent and is a candidate for sharing. This could
delay delays Crystal‚Äôs reports until a commit occurs, but commits
tend to be frequent in a DVCS. Third, unlike most of the previous
work, our approach aids developers in performing safe merges ear-
lier, in addition to early isolation of conÔ¨Çicts. Fourth, also unlike
most of the previous work, we consider and support multiple levels
of conÔ¨Çicts ‚Äî textual, build, and test.
7.3 Mining software repositories
Ball et al. [2] extracted metrics such as coupling ‚Äî based on
the probability that two classes are modiÔ¨Åed together ‚Äî and used
the metrics to assess the relationship between implementation deci-
sions and the evolution of the resulting system. Later efforts mine
version histories to determine functions that must likely be modiÔ¨Åed
as a group [35], to identify common error patterns [19], to predict
component failures [21], etc.
Our effort contrasts with these efforts in at least two dimensions.First, we are assessing a different property: opportunities to incor-
porate changes with others on a team. Second, the purpose of our
mining was to determine whether building a tool like Crystal would
be worthwhile. Other mining efforts generally aim to improve a
team‚Äôs software development process, such as by informing man-
agers of a pattern so that they will allocate more quality assurance
resources to more error-prone components.
7.4 Continuous development
Our approach can be characterized as continuous merging. Thus,
it is related to a number of other approaches to continuous compu-
tation in the context of software development.
A programming environment, modeled on spreadsheets, can con-
tinuously execute the program as it is being developed [16, 18].
Modern programming environments focus instead on providing con-
tinuous compilation The environment maintains the project in a
compiled state as it is edited, speeding software development in two
ways. First, the developer receives rapid (and usually unobtrusive)
feedback about compilation errors, allowing for quick correction
while that code is fresh in the developer‚Äôs mind. Second, the de-
veloper is freed from deciding when to compile, meaning that the
developer is not distracted by the compilation task and that when
it is time to run or test the code, no intervening compilation step is
necessary.
Continuous testing [24, 25, 26, 12] applies the same idea to test-
ing: it uses excess cycles on a developer‚Äôs workstation to continu-
ously run regression tests in the background. It is intended to reduce
the time and energy required to keep code well-tested and prevent
regression errors from persisting uncaught for long periods of time.
The vision is that after every keystroke, the developer knows im-
mediately (without taking any extra action) whether the change has
broken the tests. Similar ideas are gaining traction in the develop-
ment community.
Recent work has investigated supporting real-time integration to
decrease developer‚Äôs hesitation in committing changes using cen-
tralized version control [14]. Like FASTDash, this approach aims
to help developers avoid conÔ¨Çicts but, in contrast to FASTDash and
similarly to Crystal, it computes rather than predicts the presence
of merge conÔ¨Çicts.
These continuous approaches are reactive , albeit very fast. In
contrast, our notion of speculative VC relies instead on pre-com-
puting (and perhaps presenting, depending on the user interface
and user preferences) contingent information about VC operations
before the programmer has even considered taking the associated
speculative action.
8. Threats to validity
Our research, naturally, leaves open a set of potential concerns,
which we present using the standard notions of threats to validity.
Construct.
The version control histories tell us when a T EXTUAL 8or T EX-
TUALXrelationship Ô¨Årst arose and when the developers resolved it.
However, the histories do not tell us (1) when or how the develop-
ers found out about the relationship, (2) when the developers began
trying to resolve the relationship, and (3) had the developers known
about the relationship earlier, would they have done anything dif-
ferently?
In addition, DVCS histories only contain information about in-
corporate operations from the T EXTUAL Xand T EXTUAL 8states;
nothing is recorded when a developer pulls from the B EHIND state
or pushes from the A HEAD state.Internal.
Our experiments (Section 4) are in the context of DVCSes, which
differ from CVCSes [7, 20, 22]. The effect of the VCS on developer
behavior is not established: indeed, various researchers hypothesize
the full spectrum ‚Äî that a DVCS causes a developer to publish less
often, more often, or the same amount as a CVCS. If DVCSes
encourage more frequent branching and merging [32], that would
provide additional opportunities for Crystal.
While our full retrospective analysis cannot be done on the his-
tories of repositories built using existing CVCSes, we believe the
data we Ô¨Ånd in DVCS projects is an approximation of what hap-
pens in development with CVCSes; the largely similar results to
Zimmermann [34] justiÔ¨Åes this belief.
External.
Another threat is that our retrospective study focused on nine
open-source systems. The systems we selected may not be char-
acteristic of other systems. Anecdotally, developers are all-but-
universally worried about the problems that can arise from conÔ¨Çicts.
The professional web (blogs, Q&A sites, etc.) is Ô¨Ålled with exam-
ples of developers expressing this concern and suggesting ways to
reduce it.
Usability and developer style.
While Crystal can answer important questions about the devel-
opers‚Äô relationships in a collaborative environment and aid those
developers in making better-informed decisions, Crystal might also
harm productivity by distracting developers or leading them to pre-
mature integration. To mitigate the issues of distraction, we have
worked to reduce Crystal‚Äôs intrusiveness. In particular, humans tend
to be reasonably good at selecting which information to ignore, and
we have designed Crystal to be consistent with that ability. Some
developers may prefer to use the full Crystal view, while others may
prefer the system-tray view most of the time. And a developer who
is ‚Äúheads-down‚Äù can simply quit Crystal for a while, just as many
developers choose to, at times, ignore their email.
One challenge to Crystal‚Äôs adoption may be that developers may
fail to see its utility. One developer who attempted to use Crystal
reported that he simply was not interested in seeing conÔ¨Çicts with
unpublished changes and that he rarely experienced conÔ¨Çicts with
others in his development. While he saw no harm to running Crys-
tal, he anticipated it would provide him no beneÔ¨Åt either. Crystal,
indeed, may well not be appropriate for all classes of developers.
Nonetheless, the data in Section 4 show that conÔ¨Çicts are common,
not rare, suggesting strongly that most developers may well bene-
Ô¨Åt from Crystal, regardless of their intuitions. We plan to test this
hypothesis as part of a future user study.
Furthermore, conÔ¨Çicts are not the only reason to use Crystal. The
developer who declined to use Crystal ended up doing redundant
work. He noticed a problem and Ô¨Åxed it ‚Äî but another developer
had already made the same Ô¨Åx, and pushed it, six days earlier. The
non-Crystal-user had forgotten to pull changes before beginning to
work on the problem. Crystal would have reminded the user that he
could pull changes, and had he followed Crystal‚Äôs advice, he would
have avoided the wasted effort of the duplicated bug Ô¨Åx.
9. Conclusions
Speculative analysis over version control operations provides pre-
cise information about pending conÔ¨Çicts between collaborating team
members. These pending conÔ¨Çicts ‚Äî including textual, build, and
test ‚Äî are guaranteed to occur (unless a developer modiÔ¨Åes a com-
mitted change). Learning about them earlier allows developers to
make better-informed decisions about how to proceed, whether itbe to perform a safe merge, to publish a safe change, to quickly
address a new conÔ¨Çict, to interact with another developer etc.
Our retrospective, quantitative study of over 550,000 develop-
ment versions of nine open-source systems, spanning 3.4 million
distinct (and a total of over 500 billion, over all versions) NCSL,
conÔ¨Årms that (1) conÔ¨Çicts are the norm rather than the exception,
(2) that 16% of all merges required human effort to resolve tex-
tual conÔ¨Çicts, (3) that 33% of merges that were reported to contain
no textual conÔ¨Çicts by the VCS in fact contained higher-order con-
Ô¨Çicts, and (4) that conÔ¨Çicts persist, on average, for 10 days (with
a median conÔ¨Çict persisting 1.6 days). Although there is a signif-
icant amount of qualitative and anecdotal evidence consistent with
our Ô¨Åndings, the only previous quantitative research we could Ô¨Ånd
was Zimmermann‚Äôs [34]. We expand on his work in several dimen-
sions, including (1) comparing actual merges from project histories
to merges that could have taken place successfully earlier than they
did, and (2) considering not only textual conÔ¨Çicts but also higher-
order conÔ¨Çicts, such as build and test conÔ¨Çicts.
Our speculative analysis tool, Crystal, provides concrete infor-
mation and advice about pending conÔ¨Çicts while remaining largely
unobtrusive. Our evaluation of Crystal is preliminary and qualita-
tive; future work should evaluate it via both qualitative and quanti-
tative user studies.
Collaborative development is essential but troublesome. Making
pertinent and precise information available to developers, allowing
them to identify and Ô¨Åx conÔ¨Çicts before they fester, is one useful
and practical step in reducing some of the costs and difÔ¨Åculties of
collaborative software development.
Acknowledgments
The Crystal beta users provided valuable feedback. This material is
based upon work supported by the National Science Foundation un-
der Grants CNS-0937060 to the Computing Research Association
for the CIFellows Project and CCF-0963757, by a National Sci-
ence and Engineering Research Council Postdoctoral Fellowship,
and by Microsoft Research through a Software Engineering Inno-
vation Foundation grant.
References
[1] Ban Al-Ani, Erik Trainer, Roger Ripley, Anita Sarma, Andr√©
van der Hoek, and David Redmiles. Continuous coordination
within the context of cooperative and human aspects of soft-
ware engineering. In CHASE , pages 1‚Äì4, Leipzig, Germany,
May 2008.
[2] Thomas Ball, Jung-Min Kim, Adam A. Porter, and Harvey P.
Siy. If your version control system could talk... In PMESSE ,
Boston, MA, USA, May 1997.
[3] Jacob T. Biehl, Mary Czerwinski, Greg Smith, and George G.
Robertson. FASTDash: A visual dashboard for fostering
awareness in software teams. In CHI, pages 1313‚Äì1322, San
Jose, CA, USA, Apr. 2007.
[4] Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin.
Speculative analysis: Exploring future states of software. In
FoSER , pages 59‚Äì63, Santa Fe, NM, USA, Nov. 2010.
[5] Yuriy Brun, Reid Holmes, Michael D. Ernst, and David Notkin.
Crystal: Precise and unobtrusive conÔ¨Çict warnings. In ESEC
FSE Tool Demo , Szeged, Hungary, Sep. 2011.
[6] Marcelo Cataldo, Patrick A. Wagstrom, James D. Herbsleb,
and Kathleen M. Carley. IdentiÔ¨Åcation of coordination require-
ments: Implications for the design of collaboration and aware-
ness tools. In CSCW , pages 353‚Äì362, Banff, AB, Canada, Nov.
2006.[7] Reidar Conradi and Bernhard Westfechtel. Version models
for software conÔ¨Åguration management. ACM Comput. Surv. ,
30(2):232‚Äì282, 1998.
[8] Cleidson R. B. de Souza, David Redmiles, and Paul Dourish.
‚ÄúBreaking the code‚Äù, Moving between private and public work
in collaborative software development. In GROUP , pages 105‚Äì
114, Sanibel Island, FL, USA, Nov. 2003.
[9] Prasun Dewan. Dimensions of tools for detecting software con-
Ô¨Çicts. In RSSE , pages 21‚Äì25, Atlanta, GA, USA, Nov. 2008.
[10] Prasun Dewan and Rajesh Hegde. Semi-synchronous conÔ¨Çict
detection and resolution in asynchronous software develop-
ment. In ECSCW , pages 159‚Äì178, Limerick, Ireland, Sep.
2007.
[11] Jacky Estublier and Sergio Garcia. Process model and aware-
ness in SCM. In SCM , pages 59‚Äì74, Oxford, England, UK, Sep.
2005.
[12] David Samuel Glasser. Test factoring with amock : Generat-
ing readable unit tests from system tests. Master‚Äôs thesis, MIT
Dept. of EECS, Aug. 21, 2007.
[13] Rebecca E. Grinter. Using a conÔ¨Åguration management tool to
coordinate software development. In CoOCS , pages 168‚Äì177,
Milpitas, CA, USA, Aug. 1995.
[14] M√°rio Lu√≠s Guimar√£es and Ant√≥nio Rito-Silva. Towards real-
time integration. In CHASE , pages 56‚Äì63, Cape Town, South
Africa, May 2010.
[15] Lile Hattori and Michele Lanza. Syde: A tool for collabora-
tive software development. In ICSE Tool Demo , pages 235‚Äì
238, Cape Town, South Africa, May 2010.
[16] Peter Henderson and Mark Weiser. Continuous execution: The
VisiProg environment. In ICSE , pages 68‚Äì74, London, Eng-
land, UK, Aug. 1985.
[17] Susan Horwitz, Jan Prins, and Thomas Reps. Integrating non-
interfering versions of programs. ACM TOPLAS , 11:345‚Äì387,
July 1989.
[18] R. R. Karinthi and M. Weiser. Incremental re-execution of pro-
grams. In SIIT, pages 38‚Äì44, St. Paul, MN, USA, June 1987.
[19] Benjamin Livshits and Thomas Zimmermann. DynaMine:
Finding common error patterns by mining software revision
histories. In ESEC FSE , pages 296‚Äì305, Lisbon, Portugal, Sep.
2005.
[20] Tom Mens. A state-of-the-art survey on software merging.
IEEE TSE , 28(5):449‚Äì462, 2002.
[21] Nachiappan Nagappan, Thomas Ball, and Andreas Zeller. Min-ing metrics to predict component failures. In ICSE , pages 452‚Äì
461, Shanghai, China, 2006.
[22] Bryan O‚ÄôSullivan. Making sense of revision-control systems.
Queue , 7(7):30‚Äì40, 2009.
[23] Dewayne E. Perry, Harvey P. Siy, and Lawrence G. V otta. Par-
allel changes in large-scale software development: an observa-
tional case study. ACM TOSEM , 10:308‚Äì337, July 2001.
[24] David Saff and Michael D. Ernst. Reducing wasted develop-
ment time via continuous testing. In ISSRE , pages 281‚Äì292,
Denver, CO, USA, Nov. 2003.
[25] David Saff and Michael D. Ernst. Continuous testing in
Eclipse. In 2nd Eclipse Technology Exchange Workshop (eTX) ,
Barcelona, Spain, Mar. 2004.
[26] David Saff and Michael D. Ernst. An experimental evaluation
of continuous testing during development. In ISSTA , pages 76‚Äì
85, Boston, MA, USA, July 2004.
[27] Anita Sarma. A survey of collaborative tools in software devel-
opment. Technical Report UCI-ISR-05-3, University of Cali-
fornia, Irvine, Institute for Software Research, 2005.
[28] Anita Sarma, Gerald Bortis, and Andr√© van der Hoek. Towards
supporting awareness of indirect conÔ¨Çicts across software con-
Ô¨Åguration management workspaces. In ASE, pages 94‚Äì103, At-
lanta, GA, USA, Nov. 2007.
[29] Anita Sarma, Zahra Noroozi, and Andr√© van der Hoek.
Palant√≠r: raising awareness among conÔ¨Åguration management
workspaces. In ICSE , pages 444‚Äì454, Portland, OR, May 2003.
[30] Anita Sarma, David Redmiles, and Andr√© van der Hoek. Em-
pirical evidence of the beneÔ¨Åts of workspace awareness in soft-
ware conÔ¨Åguration management. In FSE, pages 113‚Äì123, At-
lanta, GA, USA, Nov. 2008.
[31] Chuck Walrad and Darrel Strom. The importance of branching
models in SCM. Computer , 35(9):31‚Äì38, 2002.
[32] Chuck Walrad and Darrel Strom. The importance of branching
models in SCM. Computer , 35(9):31‚Äì38, Sep. 2002.
[33] Jan Wloka, Barbara Ryder, Frank Tip, and Xiaoxia Ren. Safe-
commit analysis to facilitate team software development. In
ICSE , pages 507‚Äì517, Vancouver, BC, Canada, May 2009.
[34] Thomas Zimmermann. Mining workspace updates in CVS. In
MSR , Minneapolis, MN, USA, May 2007.
[35] Thomas Zimmermann, Peter Wei√ügerber, Stephan Diehl, and
Andreas Zeller. Mining version histories to guide software
changes. In ICSE , pages 563‚Äì572, Edinburgh, Scotland, UK,
2004.