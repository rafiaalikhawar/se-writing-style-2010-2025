Inductive VeriÔ¨Åcation of Data Model Invariants for Web
Applications
Ivan Boci ¬¥c and TevÔ¨Åk Bultan
Department of Computer Science
University of California, Santa Barbara, USA
{bo,bultan}@cs.ucsb.edu
ABSTRACT
Modern software applications store their data in remote cloud
servers. Users interact with these applications using web
browsers or thin clients running on mobile devices. A key
issue in dependability of these applications is the correctness
of the actions that update the data store, which are triggered
by user requests. In this paper, we present techniques for au-
tomatically checking if the actions of an application preserve
the data model invariants. Our approach rst automatically
extracts a data model specication, which we call an abstract
data store , from a given application using instrumented exe-
cution . The abstract data store identies the sets of objects
and relations (associations) used by the application, and the
actions that update the data store by deleting or creating
objects or by changing the relations among the objects. We
show that checking invariants of an abstract data store corre-
sponds to inductive invariant verication , and can be done
using a mapping to First Order Logic (FOL) and using a
FOL theorem prover. We implemented this approach for
the Rails framework and applied it to three open source
applications. We found four previously unknown bugs and
reported them to the developers, who conrmed and imme-
diately xed two of them.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation| Model checking ; F.3.1 [ Logics and Meanings of
Programs ]: Specifying and Verifying and Reasoning about
Programs| Invariants ; F.3.2 [ Logics and Meanings of
Programs ]: Semantics of Programming Languages| Pro-
gram analysis
General Terms
Design, Verication
Keywords
Automated verication, data model, inductive invariants,
Ruby on Rails
This work is supported by the NSF grant CCF 1117708.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 - June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.1. INTRODUCTION
Nowadays, most computers are connected to the Internet.
This network connectivity, when combined with the increas-
ingly prevalent cloud computing platforms, enables software
applications to store data on remote servers and use thin
clients (web browsers or mobile applications) that provide
access to application data from any device, anywhere, any-
time, without maintaining any local copies. However, these
applications are challenging to develop and maintain since
they are complex software systems consisting of distributed
components that run concurrently and interact over the In-
ternet.
In order to reduce this complexity and achieve modular-
ity, most web application development frameworks use the
Model-View-Controller (MVC) pattern [25] to separate the
code for the data model (Model) from the user interface
logic (View) and the navigation logic (Controller). The key
component in applications that use this pattern is the data
model, which is responsible for identifying the sets of objects
and the relations (associations) among the objects stored in
the back-end data store. Correctness of actions that update
the data store is the most signicant correctness concern for
these applications since erroneous actions can lead to unre-
coverable corruption or loss of data.
Another widely used approach in web application develop-
ment is the Representational State Transfer (REST) archi-
tecture with RESTful interfaces. In RESTful applications,
any action on the data model can be invoked at any time and
any number of times. This implies that any property that
should hold on the data model must be preserved by each
action, independently of the history of previous action exe-
cutions. Hence, invariants of the data model can be checked
in a modular manner, by checking each action in isolation,
using inductive invariant verication.
Based on the above observations, we developed a novel
approach for automatically verifying data model invariants
of web applications. First, by exploiting the structure of the
MVC-pattern, we automatically extract an abstract speci-
cation of the data model, including actions that update the
data store, using instrumented execution. Next, we convert
verication queries about the data model (stated as invari-
ants) to formulae in First-Order-Logic (FOL) based on in-
ductive invariant verication. Finally, we use an automated
FOL theorem prover to determine the result of the verica-
tion query.
We implemented our approach (Figure 1) for the Rails
framework [32]. We decided to focus on the Rails framework
since it is widely used. However, the approach presented inPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568281
620
Instrumentation  Rails code (+ invariants) 
Abstract Data Store Extractor 
Execution  
Translation to  First Order Logic  
Verifier 
First Order Logic  Theorem Prover 
Verified  (action, invariant)  pairs  
Falsified  (action, invariant)  pairs  
Figure 1: Verication of data model invariants
this paper can be adapted to other MVC-based web appli-
cation frameworks such as Django [9] and Spring [35]. We
evaluated our approach on three open source Rails appli-
cations: Kandan [23], Tracks [37], and Fat Free CRM [10].
These are non-trivial applications with more than 2K, 18K,
and 30K lines of code respectively. In addition to proving
that the majority of the actions preserve the stated invari-
ants, our tool also discovered previously unknown bugs in
these applications.
Our contributions in this paper are: 1) An intermediate
representation for data model specications called abstract
data stores. 2) Data model extraction using instrumented
execution and its implementation for the Rails framework.
3) Reduction of invariant verication queries for abstract
data stores to FOL using inductive invariant verication,
and a translator that implements this reduction. 4) Imple-
mentation of a verication tool for the Rails framework that
combines the components listed above with an existing FOL
theorem prover. 5) Evaluation of the proposed approach
on real world applications, and experiments demonstrating
the performance and eectiveness of our verication tool for
these applications.
This paper is organized as follows. Section 2 provides an
overview of the problem we are addressing and the tech-
niques we use to solve it. Section 3 gives an overview of
our intermediate language (abstract data stores) for repre-
senting data model specications. Section 4 explains our in-
strumented execution technique for extracting abstract data
store specications from application code. Section 5 ex-
plains how we translate invariant verication queries about
abstract data store specications into rst order logic. Sec-
tion 6 presents our experimental results and the bugs we
found. Section 7 includes discussions about the related work
and Section 8 concludes the paper.
2. OVERVIEW
Figure 2 shows an excerpt from an example Rails appli-
cation. In Rails, the data model is implemented using an
Object-Relational Mapping (ORM) library called ActiveRe-
cord. It is very similar to other ORM libraries (Hibernate,
Django ORM etc.) in that each class corresponds to a ta-
ble in a relational database, and that object references map
to foreign keys between tables. What sets ActiveRecord
apart is the highly dynamic implementation of the library
where methods get generated dynamically from the schema.
Some methods are generated on invocation from the method
name (e.x. User.find_by_name will, at invocation, generate
a method that looks up a User by name). Some methods,1class User
2 has_many : users
3 has_many : projects
4end
5class Project
6 belongs_to : user
7 has_many : todos
8 has_many : notes
9end
10 class Todo
11 belongs_to : user
12 belongs_to : project
13 end
14 class Note
15 belongs_to : project
16 end
17 class TodosController
18 def create
19 @project = Project . find ( params [: project_id ])
20 @user = User . find ( params [: user_id ])
21 @todo = Todo .new
22 @todo . user = @user
23 @todo . project = @project
24 @todo . save !
25 respond_to (...)
26 end
27 end
28 class ProjectsController
29 def destroy
30 @project = Project . find ( params [: project_id ])
31 @project . notes . each do |n|
32 n. delete
33 end
34 @project . delete
35 respond_to (...)
36 end
37 end
Figure 2: Excerpts from a Rails application
User Todo0..1  
    0..*
Project0..1         0..*     0..1      
        0..*Note0..1  
    0..*
Figure 3: Class diagram for the example
called ghost methods , may not exist even after invocation.
The example application denes four ActiveRecord classes:
User,Project ,Todo and Note are declared in lines 1-4, 5-9,
10-13 and 14-16 respectively. Each class contains a set of re-
lations (associations) with other classes. These associations
are declared using methods belongs_to ,has_one ,has_many
and has_and_belongs_to_many that dier in cardinality and
schema details. Figure 3 shows the class diagram corre-
sponding to the code given in Figure 2. For example, each
Todoobject has at most one associated Project (line 12). The
types and symmetry of associations are inferred from asso-
ciation names; for example, for every Projectpand every
Todotof that Project , the Project oftisp.
This application contains two actions: one in TodosCon-
troller called create and one in ProjectsController called
destroy . The ProjectsController#create action (lines 18-26)
takes two arguments as part of the request called project_id
and users_id . These arguments are used to lookup the corre-
sponding User/Project objects and assign them to variables
(lines 19-20). The action, then, creates a new Todo instance
(line 21), associates it with the queried objects (lines 22 and
23) and saves the changes (line 24). The response is synthe-
sized in line 25 by the view (which is omitted for brevity).
The TodosController#destroy action (lines 29-36) takes a
single request argument project_id . After looking up the
Project object under that id (line 30), it iterates through621allNotes associated with that project (line 31) and deletes
them (line 32). Finally, said project gets deleted (line 34).
Our VeriÔ¨Åcation Approach.
Assume that we would like to verify the following property
for the application in Figure 2: Each Todo object is associ-
ated with a Project object . What we mean by verifying this
property is that, we would like to show that this property
holds for all congurations of the data store during all pos-
sible executions of this application. For a Rails application,
this means verifying that all actions that update the data
store preserve the given property.
In order to do that, we rst need a formal specication of
the property. We developed a Rails library for specication
of data model invariants using Rails syntax. For example,
the above property would be stated as:
invariant forall{ |todo| not todo.project.empty? }
Given the property specication, our verication approach
consists of two major phases (Figure 1). The rst phase is
automatic extraction of a formal specication, which we call
anAbstract Data Store (ADS) , that characterizes the model
and the actions of the input web application. ADS models
the data store as sets of objects (corresponding to objects
of the data model classes) and relations among them (corre-
sponding to the associations among the data model classes).
Attributes that correspond to basic types are not modeled
(i.e., they are abstracted away). This means that we can
verify invariants about sets of objects and relations among
them (like the example above), but not about numeric at-
tributes of objects for example.
The crucial part of the extraction phase is extraction of ac-
tion specications, where actions of the web applications are
translated to ADS actions. ADS actions contain constructs
for creating and deleting objects and updating relations, and
they allow non-determinism, which is necessary due to ab-
straction of the attributes with basic types. For example,
ifstatements are represented as non-deterministic choices
in ADS actions.
We exploit the MVC-pattern during the extraction phase.
Actions that update the data model correspond to Con-
troller actions that are executed in response to user requests
and can in turn execute methods of the Model. We ignore
the View construction since it does not inuence the data
store state.
However, statically extracting actions specications from
Rails code is still challenging due to the dynamic nature of
the Ruby language. To address this challenge we instrument
the application code and extract the model by executing the
instrumented code.
The second major phase of our approach is automated
verication of invariants on the extracted model using First
Order Logic (FOL). Since Rails applications are RESTful
they allow any action to be invoked at any time. This means
that all actions have to preserve all invariants of the data
model. We therefore do inductive verication of invariants.
For each action/invariant pair we generate a FOL theorem
(i.e., a formula with no free variables) that evaluates to true
if and only if the invariant is preserved by the action. These
FOL theorems are sent to a theorem prover to check if they
evaluate to true (which means that the invariant holds) or
false (which means that the invariant is violated).
For the example application shown in Figure 2, and the
invariant we mentioned earlier, we generate two formulae.The theorem prover shows that the formula for the TodosCon-
troller#create action evaluates to true (which means that
the action preserves the given invariant) whereas the for-
mula generated for the ProjectsController#destroy action
evaluates to false (which means that this action violates the
invariant).
3. ABSTRACT DATA STORES
Abstract Data Store (ADS) is an intermediate language
we use for representing the data models we extract from
web applications. We rst start with a brief overview of the
semantics of ADS specications and then we describe the
constructs of the ADS language.
3.1 Formal Model
Semantically, an abstract data store is a structure DS=
hC;R;A;IiwhereCis a set of classes, Ris a set of relations,
Ais a set of actions, and Iis a set of invariants.
The set of classes Cidenties the types of objects that
can be stored in the data store. Each class can have a single
superclass or no superclass (superclass( c)2C[f?g ) and,
transitively, the superclass relation cannot contain cycles.
A relation r=hco;ct;cardi2Rcontains an origin class
co2C, a target class ct2Cand a cardinality constraint
card (such as one-to-one, one-to-many etc.).
3.1.1 Data Store States
Given a data store DS=hC;R;A;Ii, the set of all pos-
sible data store states is denoted as DS. Each data store
state is a structure hO;Ti2DSwhereOis a set of objects
andTis a set of tuples .
Objects are instances of classes, whereas tuples are in-
stances of relations. Each object o2Ois an instance of a
classc2Cdenoted by c= classof(o). Each tuple t2T
is in the form t=hr;oo;otiwherer=hco;ct;cardi2R
and classof( oo) =coand classof( ot) =ct. For a tuple
t=hr;oo;otiwe refer to ooas the origin object and otas
the target object. Cardinality constraints of each relation
r2Rmust be satised by every data store state in DS.
3.1.2 Actions and Invariants
Given a data store DS=hC;R;A;Ii,Adenotes the set
of actions. Each action a2Acorresponds to a set of possi-
ble state transitions ( hO;Ti;hO0;T0i)DSDS. Actions
characterize updates to the data store states such as creation
or deletion of a set of objects or creation or deletion of a set
of tuples.
Given a data store DS=hC;R;A;Ii,Iis the set of invari-
ants. An invariant i2Icorresponds to a Boolean function
i:DS!ffalse;truegthat identies the set of data store
states which satisfy the invariant.
3.1.3 Behaviors
Given a data store DS=hC;R;A;Ii, a behavior of a DS
is an innite sequence of data store states hO0;T0i;hO1;T1i;
hO2;T2i;:::where
for allk0,hOk;Tki2DSand there exists an action
a2Asuch that (hOk;Tki;hOk+1;Tk+1i)2a, and
8i2I:i(hO0;T0i) = true
In other words, each behavior of a data store starts with an
initial data store state where all invariants hold, and each
pair of consecutive states corresponds to execution of a data
store action.622Category Node Children Semantics
StatementBlock *Statement Executes statements sequentially
Either *Block Executes exactly one of the children Block s
ObjectSetStmt Object Set Evaluates the object set. Used for object sets with side-eects (e.g. CreateObjectSet )
Assign Variable ,Object Set Assigns the object set to the Variable
Delete Object Set Deletes objects belonging to the object set; disassociates deleted objects from all other objects
CreateTuple Object Set ,Relation ,Object Set Associates all objects from the two object sets over the Relation
DeleteTuple Object Set ,Relation ,Object Set Disassociates all objects from the two object sets over the Relation
ForEach Variable ,Object Set ,BlockExecutes the Block once for each object in the given object set, assigning the singleton set of
this object to the Variable prior to each iteration
Object SetVariable Contains objects assigned to the Variable and were not deleted since
CreateObjectSet ClassCreates a new object of the stated Class that is not associated to any other object, and has
the value of the singleton set containing this object
AllOfClass Class Contains all objects of class Class , including subclasses
Subset Object Set Contains a subset of the given object set
OneOf Object Set Exactly one object from the given object set, or empty if the given object set is empty
Union *Object Set Union of the given object sets
Empty Contains no objects. The type of this object set is compatible with all other types in Union etc
Dereference Object Set ,Relation All objects associated with at least one object from the given object set over the given Relation
DereferenceCreate Object Set ,RelationCreates a new object and associates it with all objects from the supplied object set over the
given Relation . Returns the newly created object
Figure 4: Abstract Data Store Statement and Object Set Nodes
Given a data store DS=hC;R;A;Ii, all states that ap-
pear in a behavior of DSare called the reachable states of
DSand denoted as DSR.
3.2 Language Constructs
We represent ADS specications as abstract syntax trees
(since ADS is an intermediate representation this is suf-
cient). The abstract syntax tree for an ADS specica-
tion contains a set of Class ,Relation ,Action , and Invariant
nodes corresponding to the semantic model DS=hC;R;A;Ii.
Following the formal denition of CandRgiven in Sec-
tion 3.1, a Class node may refer to another Class node as its
superclass, and contains any number of Relation s.Relation
nodes are dened by name, target Class and cardinality.
The most complex part of an ADS specication are the ac-
tion specications. The Action nodes contain a Block node,
which in turn contains any number of statement nodes. Most
statements use object set s as arguments. Object sets serve a
purpose similar to expressions in common programming lan-
guages. The list of statement and object set nodes in ADS
language is given in Figure 4. The ADS language includes
constructs for creating and deleting objects ( CreateObject-
Set,DereferenceCreate ,Delete ), updating relations ( Create-
Tuple ,DeleteTuple ), variables and assignments ( Variable ,
Assign ), loops ( ForEach ), and non-determinism ( Either ).
The Invariant nodes include standard FOL operators in-
cluding quantication over object sets.
4. MODEL EXTRACTION
The goal of the extraction phase is to translate the Rails
code to an intermediate language that captures the data
model behavior (in our case, the target language is the ADS
language dened above). Ideally, one would do this by
traversing the source code while generating the code in the
target language. However, due to the dynamic nature of
Ruby, we do not have all of Rails source code available stat-
ically as some methods are generated at runtime or may
not exist even after being invoked and, moreover, we do not
have the type information that would be necessary for the
translation.
To address this challenge, we developed a technique for
model extraction via instrumented execution. We do code
generation at instrumented runtime, with the entire Rails
stack running as congured by the application. In otherwords, we instrument the Rails application to implement
the code generation, and run the instrumented application.
Note that, for this approach to work, we need to exe-
cute all parts of the source code during instrumented execu-
tion, which we achieve by executing both branches one after
another when we encounter a branch condition. This also
means that the code generation must be ow-insensitive (so
that the order of execution of dierent branches does not
inuence the translation). However, this is not a problem,
since order of traversal during code generation does not mat-
ter as long as the generated code follows the control ow of
the source code.
We extract the data model specication by focusing on
one action at a time. We initiate instrumented execution
by instrumenting the action itself in such a way that, im-
mediately before invoking any method originating from the
action, the called method gets instrumented as well. This
way instrumentation propagates through the program, in-
cluding dynamic behavior. In eect, instrumentation and
instrumented execution are interleaved.
4.1 Action Extraction Example
Below, we illustrate our approach using the example in
Figure 5 where Figure 5(b) shows the instrumented version
of the action shown in Figure 5(a). This action creates a
new object of class User and assigns it to a variable @user
(line 2a), iterates through all existing Project s using project
as the iterator variable (line 3a) and, if the project ishir-
ing? (line 4a), adds the project to the collection of @user 's
projects (line 5a). The @user object is saved in line 8a and
the response is synthesized in line 9a, with details omitted
for brevity.
Before the instrumentation phase, we overload most Ac-
tiveRecord methods to return meta-objects . Meta-objects
do not contain any concrete values from the database, but
mimic actual ActiveRecord objects by responding to the
same method signatures, and return other meta-objects on
method calls.
These meta-objects can be translated into object sets de-
ned in Figure 4. For example, calling User.build(...) re-
turns a meta-object that will be translated into a CreateOb-
jectSet(User) object set. Calling any User.find_by_...(...)
method resolves to a meta-object that will be translated into
aOneOf(AllOf(User)) object set.
Figure 5(b) contains the instrumented version of the orig-6231a def create_user_example
2a @user = User.build(params)
3a Project.all.each do |project|
4a if project.hiring?
5a @user.projects << project
6a end
7a end
8a @user.save!
9a respond_to(...)
10a end
(a) Example action
Action
Block
Assign ForEach
Variable CreateObjectSet Variable AllOf Either
'at_user' User 'project' Project Block Block
CreateTuple
Variable 'projects' Variable
'at_user' 'project'
(c) Extracted action specication1b def create_user_example
2b ins_stmt(ins_asgn(:@user, User.build(params)))
3b ins_stmt(Project.all.each do |project|
4b ins_if(
5b project.hiring?,
6b ins_stmt(@user.projects << project),
7b nil
8b )
9b end)
10b ins_stmt(@user.save!)
11b end
(b) Action after instrumentation
Figure 5: Abstract Data Store extraction example
inal action. All statements are executed within a ins_stmt
call, which appends the ADS specication extracted from
the statement to the current ADS Block .
Executing ins_asgn (line 2b) creates an Assign ADS node
that contains the variable name and the ADS expression for
the right hand side of the assignment.
Lines 3b-9b all belong to the same ins_stmt call. The
expression Project.all returns a meta-object that will be
translated to the AllOf(Project) object set. The eachmethod
in Ruby is normally used to iterate through a collection and
execute a block for each element. When called on an meta-
object, however, the block will be executed only once; the
ADS Block node extracted from this single block execution
becomes the Block of the extracted ForEach statement.
We replace every Ruby branch statement (lines 4a-6a)
with an ins_if statement (lines 4b-8b). During instrumented
execution, ins_if will execute both the then andelsebranches
in dierent contexts and return an Either ADS node.
Finally, the statement in line 5a is identical to line 6b of
the instrumented action. During instrumented execution all
variable meta-objects will be translated into Variable nodes,
so the association meta-object will be translated into Deref-
erence(Variable('@user'), 'projects') . The <<method cre-
ates an CreateTuple statement node. The save! method (line
10b) is treated like a no-op. This translation results in the
ADS action specication shown in Figure 5(c).
4.2 Limitations and Assumptions
Our extraction method has some limitations and works
under certain assumptions. Since our extraction method
is dynamic, if an application were to construct a method's
code based on the user input, then we would not be able to
capture the full behavior of the application. However, this
is not the case for Rails actions since they are implemented
with ActiveRecord which is bound by the database schema,
and the dynamically generated methods follow this static
schema. So, although our extraction method would not work
for all dynamically generated methods in Ruby, it is able to
capture dynamically generated methods in Rails actions.
We assume that the application will never generate asso-ciations using mass assignments with foreign keys. In ad-
dition, the destroy operation can be translated to our in-
termediate representation only when no circular destroy de-
pendencies exist. This limitation comes from the fact that,
in the presence of circular destroy dependencies, the delete
operation propagation becomes recursive and this cannot be
translated into rst order logic.
Our extraction tool ignores polymorphic associations since
they are not currently modeled in our intermediate represen-
tation. However, with some extra programming eort, it is
possible to extend our approach to handle polymorphic as-
sociations. Similarly, the extraction assumes that all mod-
ications to objects in an action are executed atomically,
while in actuality, some changes are kept in memory until
asave method is called. Again, it is possible to extend our
approach to handle these cases.
Our current implementation does not instrument and ex-
tract while loops at this point, but with extra eort this can
be handled in a similar way we handle the each loops.
We assume that there are no recursive methods used dur-
ing action execution. However, our approach can be ex-
tended to handle recursive functions if our intermediate lan-
guage was extended to handle function call semantics.
Since branch conditions are not guiding the branch choice
during instrumented execution, it may happen that the ex-
ecution takes impossible paths. For example, in Tracks, the
login procedure checks whether an external authentication
library is included and, if it is, delegates authentication to
it. During instrumented execution this branch gets executed
even if the external module is not included, causing an ex-
ception. Similar problems may arise if the branch condi-
tion checks whether a variable has a non-null value, and the
branch gets executed even if this variable is null. We antic-
ipate cases like this and drop execution paths that raise an
exception during instrumented execution.
Our path exploration is not guided by inputs since we ex-
plore all paths regardless of input values. Since action inputs
are strings (usually URL parameters) and are abstracted
away, input information is unnecessary for the purpose of
ADS extraction.6245. VERIFICATION VIA FOL
Given an abstract data store DS=hC;R;A;Ii, we call
DSconsistent if and only if all reachable states of DSsatisfy
all the invariants of DS, i.e.,DSis consistent if and only if
for allhO;Ti2DSR, for alli2I,i(hO;Ti) = true. The
verication problem to determine if a given abstract data
store is consistent. Since we do not bound the sizes of the
classes and relations in a data model, and since we allow
arbitrary quantication in invariant properties, determining
if a data store specied in the ADS language is consistent
or not is an undecidable verication problem.
As we discussed earlier, in RESTful applications, each ac-
tion is required to preserve the invariants of the data model
independently of the previous execution history. This is a
stronger requirement that implies the consistency condition
dened above, and can be formulated as inductive invari-
ant verication. An inductive invariant is a property where
given a state that satises the property, all the next states
of that state also satisfy the property. In other words, an
inductive invariant is a property that is preserved by all
transitions (i.e., all actions) of a given system. An abstract
data storeDS=hC;R;A;Iiis consistent if the conjunction
of all the invariants i2Iis an inductive invariant. In other
words, an abstract data store DS=hC;R;A;Iiis consistent
if the formula, dened below, is valid:
Fcons8hO; Ti2DS;8a2A;
(8i2I; i(hO; Ti)))(8i2I; i(a(hO; Ti)))
In the rest of this section we show that, given an ADS
specication, the above formula can be checked by rst trans-
lating it to First Order Logic (FOL), and then, using an
automated FOL theorem prover for checking its validity.
An automated FOL theorem prover can either prove that a
given FOL formula is valid (corresponding to the case that
the data store is consistent), or it can prove that the formula
is not valid (corresponding to the case that there exists and
action that violates an invariant), or the theorem prover may
never terminate (due to undecidability of FOL). We handle
non-termination by setting a timeout value, and when the
timeout is reached we report that the result of the verica-
tion is inconclusive. In our implementation, we targeted a
FOL theorem prover called Spass [38], however, the trans-
lation discussed below would work for any FOL theorem
prover.
5.1 An Overview of FOL with Equality
First Order Logic (FOL) is a formal system that oper-
ates on an innite domain of entities. A theory in FOL
with equality is composed of a nite number of predicates
and axioms . FOL formulae are composed of variables (that
range over the innite set of domain elements), predicate
symbols (for a k-ary predicate pand variables v1;v2;:::vk,
p(v1;v2;:::vk) is a formula), Boolean operators ( :,^,_,),
,) and constants (false, true), quantication (for a formula
fwith free variables v1;v2;:::vk, both8v1;v2;:::;vk:fand
9v1;v2;:::;vk:fare formulae), and the equality predicate
(for variables v1andv2,v1=v2andv16=v2are formulae).
Axioms are formulae that set the basis of the theory: they
are assumed to be true by default. A set of conjecture for-
mulae holds on a FOL theory if and only if, for all predicate
assignments such that all axioms are true, all conjectures
are true as well.
The equality predicate has its expected interpretation (itclass Parent1 {}
class Child1 extends Parent1 {}
class GrandChild extends Child1 {}
class Child2 extends Parent1 {}
class Parent2 {}
8o:^0
@Child1 (o))Parent1 (o)
GrandChild (o))Child1 (o)
Child2 (o))Parent1 (o)1
A (1)
8o:^0
B@Parent1 (o)): Parent2 (o)
Parent2 (o)): Parent1 (o)
Child1 (o)): Child2 (o)
Child2 (o)): Child1 (o)1
CA (2)
8o: isobject( o),
Parent1 (o)_Child1 (o)_GrandChild (o)
_Child2 (o)_Parent2 (o)
(3)
Figure 6: Example class model and formulae
is reexive, symmetric and transitive, and for any two vari-
ablesx1andx2such thatx1=x2, the value of any pred-
icate does not change if any argument x1is replaced with
x2). Any variable that appears in a formula without being
quantied is called a free variable . Formulae with free vari-
ables cannot be assigned a truth value or be used as axioms
or conjectures.
During the translation process we describe below we often
conjoin or disjoin a set of formulae into a single formula. If
this set happens to be empty, the resulting conjunction/dis-
junction is assumed to take the form of the neutral element
of conjunction (true) or disjunction (false), respectively.
5.2 Translation of Classes and Relations
Classes and relations constitute the basis of an abstract
data store, so we start the description of our translation with
them.
Translation of Classes.
We show a simple class hierarchy in Figure 6 which is
designed to concisely showcase all features of the translation
for classes as well as corresponding formulae.
We introduce a unary predicate isobject (o) that evaluates
to true if and only if the domain element orepresents an
object. In addition, for each class c2C, we declare a new
unary predicate c(o) that evaluates to true if and only if o
is an instance of class c.
To enforce inheritance, for each two classes cpandccsuch
thatcp= superclass( cc) we dene that all objects of the cc
type are, by implication, of cptype as well (formula 1 in
Figure 6). We allow instances of a parent class to not be of
any child class. In addition, dierent classes with the same
superclass have mutually exclusive object sets (formula 2).
Finally, all objects have a class, and anything with a class
is an object (formula 3).
Translation of Relations.
Similarly to objects, we use FOL domain elements to rep-
resent tuples (which are instances of relations). Therefore,
in addition to some domain elements representing objects,
some represent tuples. A convenient consequence of this ap-
proach is that it allows us to dene creating and deleting of
objects and tuples in a uniform way.
We introduce a new unary predicate istuple (t) that re-
turns true if the domain element trepresents a tuple. We
dene that no domain element can be both an object and
a tuple; their sets are mutually exclusive. For each relation
r2Rwe introduce a unary predicate r(t) that returns true
if and only if tis representing a tuple that belongs to r.625In order to associate tuples with objects, for each re-
lationr2Rwe dene two additional binary predicates:
originr(t;o1) andtargetr(t;o2) which, together, identify that
t=hr;o1;o2i. Every tuple has exactly one origin object and
one target object, and we enforce this condition using the
following formula:
8t:r(t))(9oo: originr(t; oo)^9ot: targetr(t; ot)^
(8o1; o2: (originr(t; o1)^originr(t; o2)))o1=o2)^
(8o1; o2: (targetr(t; o1)^targetr(t; o2)))o1=o2))
We enforce cardinality constraints of rusing similar formu-
lae to limit the number of tuples per origin/target object.
Translation of Object Sets.
Object sets in ADS specications are a fundamental com-
ponent used in both actions and invariants, serving a pur-
pose similar to expressions in conventional programming
languages. An object set represents a set of objects with
a given, common superclass.
Every object set is translated into a formula Fthat has
two free variables xando, denoted as F(x;o).Fis true
if and only if obelongs to the object set under context
x(we explain how contexts are used in Section 5.3 below).
Object set formulae are meant to be injected into a formula
Gthat quanties xando, producing a formula with no free
variables assuming that Ghas no free variables.
For example, the Subset node in an ADS specication se-
mantically evaluates to an object set that is a subset of its
argument object set. To translate a Subset node, we intro-
duce a new binary predicate subset(x;o) and enforce no
additional constraints on this predicate. This predicate, if
it holds on xando, denotes that owill be chosen as part of
this subset under context x. The resulting formula is:
Fsubset (x;o)subset(x;o)^F(x;o)
whereF(x;o) is the translation of the argument object set
for the Subset node (i.e., its child). The resulting formula
still has free variables xando, meaning that it is a valid ob-
ject set formula. Notice that we enforced this subset function
to be non-deterministic by not having any rules on which o
is included in the subset using subset(x;o).
5.3 Translation of Statements
Actions in ADS are specied using sequences of state-
ments. Each individual statement is translated into for-
mulae that dene the transition between the pre-data store
states (the states before the statement is executed) and the
post-data store states (the states after the statement is ex-
ecuted) (from now on, shortened to pre- and post-states).
These formulae are designed to encapsulate the semantics
of an individual statement independently from previous or
successive statements. We can combine formulae for indi-
vidual statements together by joining intermediate states:
if a statement s1is followed by a statement s2, we conjoin
them by stating that the post-state of s1is equivalent to the
pre-state of s2. This method is used to combine statements
into blocks, and ultimately entire actions.
Statements may be executed multiple times if they are
contained within a loop body. In order to identify dierent
executions of a statement, we introduce contexts . Like ob-
jects and tuples, contexts are represented using FOL domain
elements. We use contexts to enforce the number of execu-
tions of each statement by enforcing the number of contexts8x;o: isobject( o))(
instatepost(x; o),instatepre(x; o)^:F(x; o)) (1)
8x;t: istuple( t))instatepost(x; t),(instatepre(x; t)
^:(9o: instatepre(x; o)^F(x; o)^originro1(t; o))
^: (9o: instatepre(x; o)^F(x; o)^originrono(t; o))
^:(9o: instatepre(x; o)^F(x; o)^targetrt1(t; o))
^: (9o: instatepre(x; o)^F(x; o)^targetrtnt(t; o))) (2)
Figure 7: Formulae dening a delete statement
for that statement. We create a unique context for the root
block of any action in order to simulate exactly one execution
of an action. Loops dene their own sub-contexts in order
to dene executions of loop bodies. Therefore, every pre-
and post-state sis represented by a predicate instates(x;a)
that denotes that object or tuple ais part of data store state
sduring the execution identied by context x.
Below we detail the translation of several statements that
demonstrate the methodology. The translation of other state-
ments is omitted for brevity.
Translation of the Delete statement.
ADelete statement deletes all objects from a given object
set. In addition it deletes all tuples that are related to a
deleted object. Other objects and tuples are unaected.
Given an object set (as the argument of the Delete state-
ment) and its translation into an open formula F(x;o), for-
mulae in Figure 7 dene the translation from the pre-state
into the post-state of the delete statement, dened by pred-
icates in statepre(x;a) and in statepost(x;a) respectively.
Formula 1 in Figure 7 denes that an object belongs to
the post-state if and only if it belonged to the pre-state and
did not belong to the object set.
A tupletin contextxpersists into the post-state if and
only if it existed in the pre-state and tdoes not touch a
deleted object (more precisely, if none of the predicates den-
ing relations originating or targeting the object set class ap-
ply totand a deleted object). Let cbe the class of the object
set, and let noandntbe the numbers of relations that have
cor its subclass as the origin or target class, respectively.
We deneroito be a relation that has cor its subclass as the
origin class, for 1 ino. We analogously dene rti. With
those denitions in mind, Formula 2 in Figure 7 denes how
aDelete statement migrates tuples between states.
Assignment statements and variables.
Before translation we convert each action into the static
single assignment (SSA) form. Since after this transforma-
tion every variable vis assigned to by exactly one Assign
statements, assuming we have an object set on the right
hand side of the assignment, we can translate an assignment
statement by introducing a binary predicate v(x;o) and en-
forcing that v(x;o) holds if and only if F(x;o).
The formula corresponding to the object set of a variable v
isv(x;o)^instatecurrent (x;o). The additional constraint of
the object belonging to the current state is necessary because
objects that were part of the variable may have been deleted
since the assignment of this variable.
Translation of Loops.
There is only one type of loop in ADS language: the ForE-
achstatement. It iterates through an object set, executing
the loop body once for each object in the object set. The626loop body can access the iterated object through the iterator
variable. The order of iterated objects is non-deterministic.
The loop body needs to be executed once for each object
in the supplied object set . Since we use contexts to de-
ne executions, we need to dene that, for each object in 
under context xp(the parent context), there exists exactly
one context xc(the child context) that will be used to ex-
ecute the loop body. We specify this by using a predicate
contextlink(xc;o) denoting that we created context xcto
execute the loop body for an object ofrom the iterated ob-
ject set. Child contexts are linked to their parent context
using the predicate parentcontext (xp;xc).
We also dene the pre- and post-state of the loop body,
referred as pre- and post-step states. Each pre-step state is
equal to the post-step state of the preceding iteration, with
the exception of the rst iteration whose pre-step state is
equal to the pre-state of the ForEach statement. The ForEach
statement's post-state is equal to the last post-step state.
Since we need to reason about iteration order, we intro-
duce a predicate prev(x1;x2) that denes that the iteration
dened by context x1is executed before x2's iteration, and
thatx1andx2belong to the same parent context xp. Fur-
ther constraints are added to impose a total order between
all contexts with the same parent context.
Our experiments with the Spass theorem prover have shown
that the theorem prover often cannot give conclusive results
about actions with a ForEach statement based on the transla-
tion outlined above. The problem is that the theorem prover
attempts to deduce all transitive formulae achievable by ex-
ecuting the iterations in a total order. This chain of deduc-
tions would terminate if the number of iterations is bounded
(i.e., if the object set that is iterated upon is bounded). If
the size of the iterated object set is unbounded the theorem
prover never terminates, leading to an inconclusive result.
We developed an optimized translation that resolves this
issue for a class of loops that are common in practice. We
have observed that, in most loops that update the data-
store, iterations do not aect each other (such as each it-
eration redening a variable read by the following one, or
creating objects that change the semantics of following iter-
ations, etc.), i.e., there is no dependency between iterations
of a loop. For such loops, it is unnecessary to dene a total
order on iterations, and we developed an optimized transla-
tion for ForEach loops based on this observation.
The optimized translation does not impose a total order
between iterations and instead executes them concurrently.
In this translation, entities (objects or tuples) exist in the
post-state of the loop if and only if the entity existed in the
pre-state of the loop and still exists in all post-step states, or
if it did not exist in the pre-state of the loop and exists in at
least one post-step state. The lack of total order among the
iterations in this optimized translation makes the resulting
FOL formulae more tractable. This optimized translation
was applicable to all loops of the three applications we ex-
perimented on.
5.4 Translation of Invariants
Invariants are formulae described by a syntax very similar
to FOL and are translated almost verbatim. Some additions
are functions over object sets, quantication over object sets
with quantied variables being singleton object sets etc.
For inductive invariant verication, all invariants should
be assumed to hold before an action is executed; then weFatFreeCRM Tracks Kandan
Lines of Code 30358 18023 2173
# ADS Nodes 85447 37755 907
# Nodes after optimization 1611 1483 280
# Classes 30 10 5
# Actions 167 70 35
# Invariants 8 10 5
# Empty actions 107 52 31
Avg. # of predicates 286 205 69
Theorem prover peak memory 243Mb 203Mb 126Mb
Avg. time per action/invariant 3.1 sec 40.5 sec 10.5 sec
# Action/invariant pairs 480 180 20
Veried 468 133 17
Falsied 2 2 0
Inconclusive 8 34 1
False positives 2 2 1
Detected Exceptions 0 9 1
Figure 8: Extraction and verication statistics
try to show that all invariants hold after the action execu-
tion. We add all invariants into the set of axioms, limiting
each quantication and object set to cover only objects and
tuples that exist in the pre-state of the action. We also add
all invariants into the set of conjectures, this time limited
such that all quantications and object sets span objects
and tuples that belong to the post-state of the action.
6. IMPLEMENTATION & EXPERIMENTS
Based on the techniques we discussed above, we imple-
mented a fully automatic extraction and verication tool
for Rails data models as a Rails gem (library) that can be
obtained at http://bocete.github.io/adsl/ . It is imple-
mented in Ruby in 15689 lines of code and is licensed under
the open LGPL license.
6.1 Experiments
We evaluated the tool on three Rails applications: Fat-
FreeCRM, Tracks and Kandan. These applications are multi-
user, have complex data models and are actively developed
and maintained by the open source community. As a conse-
quence of their open source nature these applications have
been exposed to varying coding styles and standards, making
them suitable to demonstrate the exibility and limitations
of our techniques. Statistics on these three applications can
be found in Figure 8.
FatFreeCRM is an application for customer-relation man-
agement. The coding style is characterized by high exibility
in the model, where often the types and names of objects
and associations are generated using string manipulations
instead of static declarations. That way the same implemen-
tation of an action can be used for dierent controllers and
actions. Because the extraction was done in instrumented
runtime, the translator had sucient information to auto-
matically infer the correct semantics of these actions, which
would not be doable by pure static analysis. Our tool found
two bugs in FatFreeCRM that we reported to the developers,
who conrmed and xed one of them.
Tracks is an application for organizing tasks. It is inter-
esting because of an unorthodox pattern in the data model,
where the association among the Todo objects denes a par-
tial order. This pattern posed a challenge for the verication
stage. Our tool found two bugs in Tracks that we reported
to the developers, who conrmed and xed one.
Kandan is a chat application that heavily relies on third-
party gems, most notably for authentication and authoriza-627tion (devise[8] and cancan[4]). These libraries oer many
features that are manually implemented in Tracks and Fat-
FreeCRM, and therefore, much Kandan's application logic
is handled by external gems.
6.2 Extraction details
Our tool initiates application verication by inspecting
the application's exposed URL patterns, instrumenting cor-
responding actions and libraries and invoking requests, as
described in Section 4. We manually entered invariants
based on our inspection of the applications by using the
Rails extension we developed for specifying invariants.
The process of automated extraction took up to 2 min-
utes for FatFreeCRM and signicantly less for other appli-
cations. The extracted ADS specications are very large
(Figure 8) which results in very large formulas when trans-
lated to FOL. The automatically extracted specication can
be signicantly reduced using an ADS optimization phase
that identies redundant nodes such as assignments to vari-
ables that are never read, Either statements with empty or
identical blocks, loops with empty bodies etc. Empty blocks
are frequently encountered since operations on basic types
are abstracted away during extraction. The optimization
phase removes redundant nodes, and alters nodes in order
to remove paths that do not modify the data store (as these
paths trivially preserve all invariants). These optimizations
reduce the size of the specication by an order of magnitude.
We manually checked each extracted ADS action against
the actual code to ensure that the extracted specication is a
sound abstraction of the implementation. We identied only
one unsound action extraction in Tracks where a part of the
action business logic is implemented inside the view. This is
a violation of the MVC paradigm, and since our extraction
approach relies on the MVC pattern, it is not surprising that
we are unable to extract a sound abstraction in this case.
We found two interesting action extraction instances in
Tracks. One is related to a coding error in the actual ac-
tion. The action is deprecated but still public and would
raise an exception if called. Our tool captured the exception
during instrumentation which resulted in an empty action.
This was the correct translation, but demonstrates that the
extraction procedure is sensitive to runtime errors.
Another interesting example comes from one of the model
methods being recursive ( Todo#touch_predecessors ). Since
calls are inlined during extraction, this leads to an innitely
deep abstract syntax tree (until a stack overow exception
is raised during instrumented runtime). Since the opera-
tions inside this recursive call were abstracted away (they
were only updating a eld with a basic type), this entire
call chain results in a no-op and is entirely removed dur-
ing the optimization phase, resulting in a sound translation.
Had there been updates to the objects and relations of the
data model in this recursive call, the recursion would have
been eectively unrolled a large but nite number of times,
resulting in an unsound abstraction.
6.3 VeriÔ¨Åcation details and identiÔ¨Åed bugs
Our tool veries each extracted ADS specication using
the Spass[38] theorem prover. The tool rst removes all
empty actions from ADS as they trivially preserve all in-
variants. Many actions do not modify the data store and
instead just look up data to show to the user; these actions
are empty in ADS. Our tool then creates a FOL theoremfor each remaining non-empty action-invariant pair, check-
ing if, assuming that all invariants hold in the pre-state, the
invariant holds in the post-state.
Spass veries a FOL theorem by negating the conjecture
and exhaustively exploring the space of deductible formulae.
As soon as it deducts a contradiction, it has proven that the
conjecture holds. To prove that the conjecture does not hold
it needs to explore the entire space of deductible formulae
and never deduct a contradiction, which takes much longer
and may never terminate since FOL is undecidable.
For each action/invariant pair, our tool runs two instances
of Spass concurrently with dierent heuristic settings; this
increases the possibility of reaching a conclusive answer. The
peak memory statistic in Figure 8 accounts for both Spass
instances together. Our tool lets the theorem prover run for
3 minutes before interrupting it and classifying the result as
inconclusive. We let the tool run for as much as 30 minutes
for each action/invariant pair, and we did not nd a single
instance where a conclusive result was found in more than 2
minutes. Evaluations were done on a computer with an Intel
Core i5-2400S processor, 32GB RAM, running 64bit Linux.
From a total of 480, 180, and 20 action/invariant pairs our
tool proved 468, 133, and 17 action/invariant pairs correct in
FatFreeCRM, Tracks and Kandan, respectively. We found
2 bugs in Tracks and 2 bugs in FatFreeCRM. We reported
them to the developers and two of them have been xed
since, other two pending a response.
In Tracks, one bug we found showed that it is possible
to orphan an instance of a Dependent class. This stems from
the way the ProjectController deletes a Project ; it cleans up
allProject 'sTodos, but does not clean up the Dependencies
of deleted Todos. The other bug is caused when a User is
deleted using the UsersController . All Project s of the User
are deleted, but Notes of deleted Project s remain orphaned.
In FatFreeCRM, one of the bugs we found relates to Per-
mission objects. These objects dene permissions for either
User orGroup objects. Our tool has shown that it was pos-
sible to have a Permission without associated User orGroup
objects. The other bug relates to Todo objects being or-
phaned when a User is deleted.
There were 5 cases of false positives where our tool re-
ported that an action broke an invariant but, when we man-
ually inspected, we found out that the action preserved the
invariant. The false positives are mainly due to the fact
that our tool over approximates the action behavior since
branches are converted to non-deterministic choices.
Our tool also identied 10 cases (9 in Tracks, 1 in Kan-
dan) where the actions were implemented under the assump-
tion that a look up operation always nds something in the
database. When the searched object was not found, these
actions would raise an exception and display a default er-
ror message to the user. Handling these cases as exceptions
is not a good programming practice since failing to nd an
object that matches a query is not an exceptional behavior
and should be handled by the normal program ow. While
these actions will not result in invariant violations during
runtime (since a raised exception will halt execution before
the invariant is broken), they still point out programming
problems and provide useful feedback to the programmer.
7. RELATED WORK
Nijjar et al. present techniques for analysis and verica-
tion of data models in Rails applications [30, 31, 29]. The628data model used in Nijjar et al.'s work is a static model that
does not represent the actions that modify the data store
states. The properties are checked with respect to associa-
tion declarations without considering how they are updated
via actions. Moreover, some assumptions used in construct-
ing the static data model (such as assuming belongs_to asso-
ciations have exactly one associated object) are not guaran-
teed to hold by the Rails semantics. In contrast, our model
captures the exact behavior of a data store by modeling how
actions update the data store states.
Near et al. [28] developed Rubicon, a web application veri-
cation tool that adds quantication to unit tests and trans-
lates tests into veriable Alloy specications using symbolic
execution. Rubicon uses the Alloy Analyzer for bounded
verication of generated specications.
Both Tracks and Fat Free CRM were analyzed by the
tool developed by Nijjar et al. and Rubicon. Neither of
their tools were able to uncover the four bugs we found.
Since the tool developed by Nijjar et al. only analyzes the
static data model it is unable to capture the semantics of
actions and nd the bugs in them. Rubicon's approach, on
the other hand, is a testing based framework. Successful
tests verify that, after an explicitly stated sequence of steps,
the application behaves as expected. Tests are not suitable
for verifying that no possible sequence of action executions
could lead to a faulty state, which is the condition checked
by our verication framework.
Alloy [21, 22] is formal language for specifying object ori-
ented data models and their properties. Alloy Analyzer is
used to verify properties of Alloy specications. Unlike our
work, Alloy focuses on static models and does not directly
support specication of actions or dynamic behavior. More-
over, Alloy Analyzer uses SAT-based bounded verication
techniques as opposed to the FOL based unbounded veri-
cation technique used in this paper.
There has been prior work on formal modeling of web
applications, mainly focusing on state machine based for-
malisms to capture the navigation behavior[36, 17, 2, 16,
39, 33]. In contrast to these previous eorts, we are focusing
on analysis of the data model rather than the navigational
aspects of the web applications.
There are previous results on unbounded verication of
data-driven web applications based on high level specica-
tions [6, 5, 7]. Deutsch et al. model actions as input/out-
put rules instead of specifying them procedurally, creating
a semantic gap between the implementation and the spec-
ication of the actions. Due to the semantic gap between
the input/output rule format used in their language and the
actual implementations of actions, the bugs we found would
not be discovered by their verication approach. Addition-
ally, they impose restrictions on the use of quantication in
their properties whereas we do not have any restrictions.
Verication of software using theorem provers has been
explored before in projects such as Boogie [1], Dafny [26]
and ESC Java [11]. These projects focus on languages such
as C, C#, and Java, and typically require user guidance in
the form of explicit pre- and post-conditions, explicit data
structure constraints, and loop invariants. Both our model
and domain of application are signicantly dierent. We
focus on objects and associations that are changed by high-
level code in web applications.
Another line of related work is inductive verication of
abstract data type specications [15, 27, 13], where algebraicspecications are used to model behaviors of data types such
as stacks, queues etc., and automated verication techniques
based on term-rewriting systems are used for verication.
The types of specications we focus on, and the verication
techniques we use, are signicantly dierent.
There has been work on the static analysis of Rails [19].
This line of work focuses on typechecking Rails applications
and builds on DRuby [12], which is a Ruby static type-
checker. The presented techniques infer types and detect
errors by converting each statement into a type constraint,
and exhaustively applying a set of rewrite rules. This is a
dierent approach than ours and achieves a dierent goal,
albeit on the same target language with certain common
challenges (ghost methods and dynamic types).
Rubydust [20] attempts to typecheck Ruby code, accom-
plishing this by wrapping objects with type constraints and
running actual code. They also use some basic instrumen-
tation. This makes their approach similar to the core idea
behind our extraction by instrumented execution technique,
and in both cases, the goal is to get around dynamic fea-
tures of Ruby. However, their wrapped objects contain type
information whereas we inject abstract syntax trees into Ac-
tiveRecord objects and variables. Their solution focuses on
general purpose Ruby which our solution cannot cover, but
within our domain and with the code generation purpose,
we cover much larger applications.
Finally, our verication approach has some high-level sim-
ilarities with the long line of work in the area of symbolic
execution [18, 24, 14, 34, 3]. For example, instrumentation
has been used in symbolic execution for extraction [24, 3].
However, apart from this core idea of using runtime informa-
tion to guide extraction, our goals and solutions largely dif-
fer. We extract a specication from a given application that
represents all behaviors rather than extracting path condi-
tions for specic paths as it is done in symbolic execution.
We do not unroll loops. We generate FOL formulae with
quantication, whereas path conditions extracted in sym-
bolic execution are typically unquantied constraints that
can be checked with SMT-solvers.
8. CONCLUSIONS AND FUTURE WORK
Cloud-based software applications store their data on re-
mote servers and use data models to capture the interface
between the back-end data store and the rest of the applica-
tion. In this paper, we presented techniques for verication
of actions that update the back-end data store in such ap-
plications. We achieve this by rst automatically extracting
a formal data model in our intermediate language. We show
that invariants of the data model can be checked by trans-
lating this intermediate representation to FOL formulae and
then using a FOL theorem prover. We implemented this
approach and conducted experiments on three open source
applications. We uncovered four previously unknown bugs
two of which were acknowledged and xed by the develop-
ers. There are several directions for future work. One of
them is integration of other verication techniques, such as
SAT-based bounded verication or SMT-based unbounded
verication, to our framework. Bounded-verication can be
used for the cases where the FOL theorem prover does not
generate a conclusive result, whereas SMT-solvers can be
used for verifying properties about object elds with basic
types which are abstracted away in our current approach.6299. REFERENCES
[1] M. Barnett, B.-Y. E. Chang, R. DeLine, B. Jacobs,
and K. R. M. Leino. Boogie: A modular reusable
verier for object-oriented programs. In F. S. de Boer,
M. M. Bonsangue, S. Graf, and W. P. de Roever,
editors, Proceedings of the 4th International
Symposium on Formal Methods for Components and
Objects (FMCO) , volume 4111 of Lecture Notes in
Computer Science , pages 364{387. Springer, 2005.
[2] M. Book and V. Gruhn. Modeling web-based dialog
ows for automatic dialog control. In Proceedings of
the 24th IEEE/ACM International Conference
Automated Software Engineering (ASE 2004) , pages
100{109, 2004.
[3] C. Cadar, D. Dunbar, and D. R. Engler. Klee:
Unassisted and automatic generation of high-coverage
tests for complex systems programs. In Proceedings of
the 8th USENIX conference on Operating systems
design and implementation (OSDI 2008) , pages
209{224, 2008.
[4] cancanjRubyGems.orgjyour community gem host,
Sept. 2013. http://rubygems.org/gems/cancan .
[5] A. Deutsch, L. Sui, and V. Vianu. Specication and
verication of data-driven web applications. Journal of
Computer and System Sciences , 73(3):442{474, 2007.
[6] A. Deutsch, L. Sui, V. Vianu, and D. Zhou. A system
for specication and verication of interactive,
data-driven web applications. In S. Chaudhuri,
V. Hristidis, and N. Polyzotis, editors, SIGMOD
Conference , pages 772{774. ACM, 2006.
[7] A. Deutsch and V. Vianu. WAVE: Automatic
verication of data-driven web services. IEEE Data
Engineering Bulletin , 31(3):35{39, 2008.
[8] devisejRubyGems.orgjyour community gem host,
Sept. 2013. http://rubygems.org/gems/devise .
[9] The Web framework for perfectionists with deadlines j
Django, Feb. 2013. http://www.djangoproject.com .
[10] Fat Free CRM - Ruby on Rails-based open source
CRM platform, Sept. 2013.
http://www.fatfreecrm.com .
[11] C. Flanagan, K. R. M. Leino, M. Lillibridge,
G. Nelson, J. B. Saxe, and R. Stata. Extended static
checking for java. In Proceedings of the 2002 ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , pages 234{245,
2002.
[12] M. Furr, J. hoon (David) An, J. S. Foster, and M. W.
Hicks. Static type inference for ruby. In Proceedings of
the ACM Symposium on Applied Computing (SAC
2009) , pages 1859{1866, 2009.
[13] S. J. Garland and J. V. Guttag. Inductive methods for
reasoning about abstract data types. In J. Ferrante
and P. Mager, editors, Conference Record of the 15th
Annual ACM Symposium on Principles of
Programming Languages (POPL 1988) , pages
219{228. ACM Press, 1988.
[14] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
automated random testing. In Proceedings of the ACM
SIGPLAN 2005 Conference on Programming
Language Design and Implementation (PLDI 05) ,
pages 213{223, 2005.
[15] J. V. Guttag, E. Horowitz, and D. R. Musser.Abstract data types and software validation.
Communications of the ACM , 21(12):1048{1064, 1978.
[16] S. Hall e, T. Ettema, C. Bunch, and T. Bultan.
Eliminating navigation errors in web applications via
model checking and runtime enforcement of navigation
state machines. In Proceedings of the 25th IEEE/ACM
Int. Conf. Automated Software Engineering (ASE
2010) , pages 235{244, 2010.
[17] M. Han and C. Hofmeister. Relating navigation and
request routing models in web applications. In
Proceedings of the 10th Int. Conf. Model Driven
Engineering Languages and Systems (MoDELS 2007) ,
pages 346{359, 2007.
[18] S. L. Hantler and J. C. King. An introduction to
proving the correctness of programs. ACM Computing
Surveys , 8(3):331{353, September 1976.
[19] J. hoon (David) An, A. Chaudhuri, and J. S. Foster.
Static typing for ruby on rails. In Proceedings of the
24th IEEE/ACM International Conference on
Automated Software Engineering (ASE 2009) , pages
590{594, 2009.
[20] J. hoon (David) An, A. Chaudhuri, J. S. Foster, and
M. Hicks. Dynamic inference of static types for ruby.
InProceedings of the 38th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL 2011) , pages 459{472, 2011.
[21] D. Jackson. Alloy: A lightweight object modelling
notation. ACM Transactions on Software Enginnering
and Methodology (TOSEM 2002) , 11(2):256{290, 2002.
[22] D. Jackson. Software Abstractions: Logic, Language,
and Analysis . The MIT Press, Cambridge,
Massachusetts, 2006.
[23] kandanapp/kandan, Sept. 2013.
http://github.com/kandanapp/kandan .
[24] S. Khurshid, C. S. Pasareanu, and W. Visser.
Generalized symbolic execution for model checking
and testing. In H. Garavel and J. Hatcli, editors,
TACAS , volume 2619 of Lecture Notes in Computer
Science , pages 553{568. Springer, 2003.
[25] G. E. Krasner and S. T. Pope. A cookbook for using
the model-view controller user interface paradigm in
Smalltalk-80. Journal of Object Oriented Programming
(JOOP 1988) , 1(3):26{49, Aug. 1988.
[26] K. R. M. Leino. Dafny: An automatic program verier
for functional correctness. In E. M. Clarke and
A. Voronkov, editors, Proceedings of the 16th
International Conference on Logic Programming,
Articial Intelligence, and Reasoning (LPAR) , volume
6355 of Lecture Notes in Computer Science , pages
348{370. Springer, 2010.
[27] D. R. Musser. On proving inductive properties of
abstract data types. In Proceedings of the 7th ACM
Symp. Principles of Programming Languages (POPL
1980) , pages 154{162, 1980.
[28] J. P. Near and D. Jackson. Rubicon: bounded
verication of web applications. In Proceedings of the
ACM SIGSOFT 20th Int. Symp. Foundations of
Software Engineering (FSE 2012) , pages 60:1{60:11,
2012.
[29] J. Nijjar, I. Boci c, and T. Bultan. An integrated data
model verier with property templates. In Proceedings
of the ICSE Workshop on Formal Methods in Software630Engineering (FormaliSE 2013) , 2013.
[30] J. Nijjar and T. Bultan. Bounded verication of Ruby
on Rails data models. In Proceedings of the 20th Int.
Symp. on Software Testing and Analysis (ISSTA
2011) , pages 67{77, 2011.
[31] J. Nijjar and T. Bultan. Unbounded data model
verication using SMT solvers. In Proceedings of the
27th IEEE/ACM Int. Conf. Automated Software
Engineering (ASE 2012) , pages 210{219, 2012.
[32] Ruby on Rails, Feb. 2013. http://rubyonrails.org .
[33] E. D. Sciascio, F. M. Donini, M. Mongiello, R. Totaro,
and D. Castelluccia. Design verication of web
applications using symbolic model checking. In
Proceedings of the 5th Int. Conf. Web Engineering
(ICWE 2005) , pages 69{74, 2005.
[34] K. Sen, D. Marinov, and G. Agha. Cute: a concolic
unit testing engine for c. In Proceedings of the 10th
European Software Engineering Conference held
jointly with 13th ACM SIGSOFT International
Symposium on Foundations of Software Engineering(ESEC/FSE 05) , pages 263{272, 2005.
[35] Spring Framework jSpringSource.org, Feb. 2013.
http://www.springsource.org .
[36] P. D. Stotts, R. Furuta, and C. R. Cabarrus.
Hyperdocuments as automata: Verication of
trace-based browsing properties by model checking.
ACM Transactions on Information Systems (TOIS
1998) , 16(1):1{30, 1998.
[37] Tracks, Sept. 2013. http://getontracks.org .
[38] C. Weidenbach, D. Dimova, A. Fietzke, R. Kumar,
M. Suda, and P. Wischnewski. SPASS version 3.5. In
Proceedings of the 22nd Int. Conf. Automated
Deduction (CADE 2009), LNCS 5663 , pages 140{145,
2009.
[39] S. Yuen, K. Kato, D. Kato, , and K. Agusa. Web
automata: A behavioral model of web applications
based on the MVC model. Information and Media
Technologies , 1(1):66{79, 2006.631