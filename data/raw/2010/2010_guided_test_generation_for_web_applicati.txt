Guided Test Generation for Web Applications
Suresh Thummalapenta,‚àóK. Vasanta Lakshmi,‚Ä†Saurabh Sinha,‚àóNishant Sinha,‚àóand Satish Chandra‚Ä°
‚àóIBM Research, India
‚Ä†Indian Institute of Science, India
‚Ä°IBM T.J. Watson Research Center, USA
Abstract ‚ÄîWe focus on functional testing of enterprise appli-
cations with the goal of exercising an application‚Äôs interesting
behaviors by driving it from its user interface. The difÔ¨Åculty
in doing this is focusing on the interesting behaviors among an
unbounded number of behaviors.
We present a new technique for automatically generating tests
that drive a web-based application along interesting behaviors,
where the interesting behavior is speciÔ¨Åed in the form of ‚Äúbusiness
rules.‚Äù Business rules are a general mechanism for describing
business logic, access control, or even navigational properties
of an application‚Äôs GUI. Our technique is black box, in that it
does not analyze the application‚Äôs server-side implementation, but
relies on directed crawling via the application‚Äôs GUI. To handle
the unbounded number of GUI states, the technique includes two
phases. Phase 1 creates an abstract state-transition diagram using
a relaxed notion of equivalence of GUI states without considering
rules. Next, Phase 2 identiÔ¨Åes rule-relevant abstract paths and
reÔ¨Ånes those paths using a stricter notion of state equivalence.
Our technique can be much more effective at covering business
rules than an undirected technique, developed as an enhancement
of an existing test-generation technique. Our experiments showed
that the former was able to cover 92% of the rules, compared
to 52% of the rules covered by the latter.
I. I NTRODUCTION
A. Testing Interesting Application Behaviors
Enterprise applications have complex logic that governs
the application behavior. The goal of functional testing of
these applications is to exercise meaningful or interesting
application behaviors. The starting point for functional testing
are documents that capture requirements speciÔ¨Åcations, use
cases, business rules, etc. Test designers study such documents
and create test cases to ‚Äúcover‚Äù the requirements, use cases,
or business rules. This activity is largely manual and is often
performed in several steps to get to executable test cases: e.g.,
high-level test cases are created initially, then reÔ¨Åned into low-
level test cases, and Ô¨Ånally automated to create executable
test cases. Being manual, these activities are not only time-
consuming, but also prone to human lapses.
Our goal is to automate the functional testing of enterprise
web applications. The challenge in doing this is efÔ¨Åciently
discovering the interesting behaviors from among a possi-
bly inÔ¨Ånite set of application behaviors. For this work, we
assume that interesting application behaviors are speciÔ¨Åed
as business rules. A business rule is typically related to
business calculations or access control policies. For example,
banking applications have rules for calculating interest rates,
loan eligibility, customer status, and so on, and healthcare
applications have rules on actions permissible in differentR1. Once a card type is added, it should be visible on
the registration page where the card type option is
available
R2. Discount should be computed as follows
if invoice amount is less than $50, discount = 0%
if invoice amount is between $50 and $100, discount = 5%
if invoice amount is more than $100, discount = 10%
R3. The data entered by a user on successful registration
should be visible on the user page
R4. Users logged in as admin should have admin functions
enabled
Fig. 1. Sample business rules for the BookStore application.
roles. In this paper, we use the business rule framework to
also express properties of the UI.
Figure 1 shows sample business rules, stated informally in
English, for an online BookStore application [1]. As the
samples illustrate, an application can have rules of different
types. For example, rules R1andR3specify properties of
the GUI; R4pertains to access control, whereas R2, which
describes how shipping discounts are to be computed, is the
speciÔ¨Åcation of a business calculation. Test designers create
test cases intended to cover such rules. For example, to cover
R1, a tester would create a test case that: (1) navigates to the
card types record page, (2) enters a non-empty name (of a new
card type), (3) selects the ‚Äúinsert‚Äù button, (4) navigates to the
registration page, and (5) veriÔ¨Åes that the list of cards shown
includes the newly added card type.
B. The Problem
In this paper, we consider the problem of automatically
generating executable test cases to cover interesting appli-
cation behaviors (speciÔ¨Åed as business rules). An executable
test case is a script consisting of a sequence of actions on
the application Graphical User Interface (GUI) along with
relevant data values. Figure 2 illustrates such a test case for
theBookStore application. This test case pertains to a web
application, in which the GUI elements are links, text boxes,
buttons, etc. The last action is a veriÔ¨Åcation step: a check that
the current state is as expected, which, in this case, looks for
a certain string in a drop-down list. Such scripts are meant to
be used in automated regression testing, and executed using a
driver implemented in a testing tool such as Selenium [2].
What does it mean for a test to cover a business rule?
Technically, a rule has an antecedent, a consequent, and
optionally an invariant, each of which are predicates over
the GUI state of the application. (Formal versions of rules
in Figure 1 are discussed in Section II.) For example, for R1,
the antecedent requires that a card name is entered, and the
Insert button is clicked, on the CardTypesRecord page; the
978-1-4673-3076-3/13/$31.00 c/circlecopyrt2013 IEEE ICSE 2013, San Francisco, CA, USA162Test Step Action Type Name Data
s1 select link administration
s2 enter text box user id ‚Äúadmin‚Äù
s3 enter text box password ‚Äúadmin‚Äù
s4 click button submit
s5 select link card types
s6 select link insert
s7 enter text box name ‚Äúdiscover‚Äù
s8 select button insert
s9 select link registration
s10 exists combo box credit card type ‚Äúdiscover‚Äù
Fig. 2. A test case, consisting of a sequence of steps; each step includes an
action, the target of the action (speciÔ¨Åed as the type and name of the GUI
element), and any required data.
consequent says that the card name previously entered should
appear on the CardTypesGrid page.
To cover a rule, a test must Ô¨Årst drive the application
to a GUI state in which the antecedent of the rule is true.
Then, it must drive the application along a path such that the
consequent can be evaluated, while ensuring that the invariant,
if any, is not violated along the way. Note that the consequent
may evaluate false, signaling that the application has violated
the rule. The test case shown in Figure 2 covers rule R1.
We have developed a technique for automatically generating
test cases to cover business rules. Our approach takes as
inputs a set of formal rules (see Section II). It outputs test
cases, one or more per rule, for as many rules as our analysis
is able to cover; these test cases are of the form shown in
Figure 2. Our approach is black box , as it does not analyze
the implementation of the application under test. Instead, it
relies on driving the application via its GUI‚Äî e.g., clicking
hyperlinks, selecting menu items, entering text in text boxes‚Äî
and observing the GUI state after each test step.
C. Challenges
Although a web application may have a small number of
distinct pages in terms of URLs, each page can have a large, or
even unbounded, number of distinct GUI states. This happens
because the content of a page can be generated dynamically
by the server and reÔ¨Çects some aspect of the server state; e.g.,
aShoppingCart page can have unbounded number of GUI
states. This also happens in AJAX-style pages that directly
manipulate the browser state. The enormity of the space of
GUI states creates a problem for test generation.
To cover a rule, a test must identify a sequence of GUI
actions (a path) that Ô¨Årst drives the application to a state in
which the antecedent can be evaluated, and from there to a
state in which the consequent can be evaluated. For R1, this
means identifying a path to the CardTypesRecord page in a
GUI state in which the Insert button appears on the page; and
then a path from there to the Registration page.
Directly jumping to a page, such as CardTypesRecord , based
on its URL does not work; for one thing, the authentication
credentials need to be established and, moreover, there is no
reason that this should lead to the page in the desired state.
Therefore, test generation needs to perform a search over
the space of the application‚Äôs GUI states to Ô¨Ånd a path to take
the application from its current state to the desired state; it
performs this search over and over again. Because there canCard Types
RecordAdministration
Default Registration
Shopping Cart Book DetailCard Types
Grid
Fig. 3. URL-level STD of the BookStore application; the edge labels are
omitted.
an unbounded number of GUI states, this approach does not
yield good results because the search can easily get stuck in
irrelevant parts of the state space.
The natural step in such situations is to resort to abstraction.
We create an abstract state-transition diagram (STD) using
some notion of equivalence of GUI states. The nodes in an
STD are states (equivalent states appear only once). Each
labeled edge represents a GUI action that leads from the source
state to the target state. Our approach for creating an STD
is based on a standard search until no new states or labeled
edges can be found. Once a state is explored in the search, it
is marked ‚Äúvisited‚Äù and not explored again.
For web applications, some options for state equivalence, in
order of decreasing coarseness, are: all states pertaining to the
same URL are equivalent, all states with the same clickable
elements ( e.g., buttons or links) are equivalent, and so on.
(Section 3 considers these options in more detail.) As we go
down the list, the number of states in the STD increase, as
does the cost of creating it. In the limit, each GUI state is
considered as a distinct state, in which case the full STD
cannot be constructed, in general, because of an unbounded
number of states. Figure 3 shows an STD based on the coarsest
abstraction mentioned above.
In principle, the test generator can carry out its work over an
STD quite easily. A path in the STD from a source state to the
destination state represents the sequence of GUI actions that
must be performed to take the application from the source state
to the destination state. Unfortunately, there are two problems
with search over an abstract STD.
The Ô¨Årst problem is that a path may not lead to the
desired GUI state. Being a path over abstract states, this
is quite expected. A path might reach the correct abstract
state, but perhaps another path was needed to reach the
desired (concrete) GUI state. A simple instance of this problem
occurs in BookStore .R1requires CardTypesRecord page to
be visited in a state in which the Insert button appears, as
shown in Figure 4. The path that leads to the desired GUI
state (screenshot 3) must traverse the ‚ÄúInsert‚Äù link from the
CardTypesGrid page (see screenshot 1); the other links would
go to the right page, but not in the desired state (screenshot 2).
The second, and a more subtle, problem is that a path in
an abstract STD may not correspond to an actual traversable
path. This is an artifact of how the STD is constructed. To
illustrate, consider Figure 5. When a state sis added to the
STD for the Ô¨Årst time, it is seen in a certain (concrete) GUI
163(1) CardTypesGrid.jsp(2) CardTypesRecord.jsp
(3) CardTypesRecord.jsp
Fig. 4. The HTML pages generated by CardTypesGrid.jsp and
CardTypesRecord.jsp .
stategs; suppose the path to arrive to state gsisœÄ1. Based on
gs, labeled edges (say llandl2) and their destination states are
added to the STD at the time sis explored; sis then marked
visited. Later, smay be encountered again along some other
pathœÄ2, in some other GUI state gs‚Ä≤. Ings‚Ä≤, labeled edge l1
may go to a different state s3, and edge l2may not exist. This
is not reÔ¨Çected in the STD. Thus, from the perspective of the
STD, the path œÄ2.l1ought to go to s1but, in reality, would
go tos3, and the path œÄ2.l2cannot be traversed.
D. Our Approach
Our approach works in two phases. In the Ô¨Årst phase, we
create a coarse STD of the application under test, using relaxed
notions of state equivalence. The Ô¨Årst phase does not consider
the business rules to be covered. The purpose of this phase
is to crawl the application, with no particular coverage goal,
to recover an initial STD that, in the second phase, can guide
test generation and can be reÔ¨Åned in a goal-oriented manner.
The novelty in our approach is in the second phase. For
each business rule, we begin with a set of plausible abstract
paths, and reÔ¨Åne each one until a desired traversable path is
found. In reÔ¨Åning an abstract path, we split certain states in the
STD, using stricter notions of state equivalence, in an attempt
to discover newer, potentially rule-relevant states. The graph
on the right in Figure 5 illustrates that the initial state sis
split to create a new state s‚Ä≤, which leads to the discovery of
states4along the newly explored link l3.
The beneÔ¨Åt of our approach is that it spends the extra effort
only in portions of the state space that are relevant for covering
rules. Thus, it can aggressively search for state elements that
are relevant for rule coverage, without risking getting stuck in
parts of the application‚Äôs state space unrelated to the rules.
E. Related Approaches
Although many approaches for web-application testing have
been presented ( e.g., [3], [4], [5], [6], [7], [8], [9], [10], [11]),
to the best of our knowledge, none of them has been designed
speciÔ¨Åcally to cover business rules. However, among these,
ATUSA [10] is a related approach. ATUSA Ô¨Årst creates a state-
Ô¨Çow graph ‚Äîa web-application model that is very similar to
the STD‚Äîusing a certain state abstraction. Then, it traverses
allk-length paths on this graph to generate tests.
Although ATUSA can provide good structural coverage, we
found that it is not effective in generating tests that cover
rules. For one reason, paths in an abstract STD are subjectœÄ1œÄ2
123112œÄ1œÄ2
121
2
31
43
43
Fig. 5. Illustration of non-traversable paths in the STD created due to state
abstraction. State splitting is shown on the right.
to the problems mentioned earlier. If the STD is sufÔ¨Åciently
reÔ¨Åned to detect rule-relevant concrete states, path coverage
as performed by ATUSA would eventually cover a given rule.
The problem is that it would take far too long to create an
adequately reÔ¨Åned STD in a rule-oblivious manner.
In our evaluation (Section IV), we compared our approach
with an enhanced implementation of ATUSA , hereafter re-
ferred as KPATH +.KPATH + shares the key idea of ATUSA ,
namely bounded-length path generation over an STD. How-
ever, KPATH + includes reÔ¨Ånement by state splitting (as shown
in Figure 5) so that the paths generated are traversable. Unlike
our approach, KPATH + still aims at creating k-length paths,
without considering rule coverage.
F . Highlights of Results
We implemented our approach in a tool called WATEG
(Web Application TEst Generator), and conducted empirical
studies using Ô¨Åve open-source web applications to evaluate the
effectiveness and efÔ¨Åciency of the technique. In the evaluation,
with 60 business rules over all subjects, we found that WATEG
covered 92% of the rules, within a maximum time budget
of 20 minutes per rule. We also implemented and evaluated
KPATH +: this technique covered only 52% of the rules even
though it exercised 5877 additional paths (over all applica-
tions) compared to WATEG .
G. Contribution
This paper makes an important contribution in the area
of automatic functional testing of web applications. Business
rules are a common form of functional speciÔ¨Åcation of en-
terprise applications. Our technique is able to automatically
generate tests that exercise business rules and, to our knowl-
edge, it is the Ô¨Årst technique with that capability.
We show that the key to searching for a state in a web-
application‚Äôs GUI state space is a two-phase approach. The
Ô¨Årst phase provides approximate reachability information,
whereas the second phase reÔ¨Ånes an abstract path into a
traversable one. This bypasses the problems in creating a very
reÔ¨Åned state space upfront. The metaphor is borrowed from
work in program veriÔ¨Åcation [12], but applied in a different
context.
In this paper, we present the two-phase approach in the
context of business rules, but it is applicable more generally
to other forms of functional speciÔ¨Åcations for which the goal
of testing is to cover certain interesting application states.
164TABLE I
FORMAL SPECIFICATION OF THE BOOKSTORE BUSINESS RULES SHOWN IN FIGURE 1.
Rule Antecedent Consequent Invariants
R1cardtyperecordpage.name/negationslash=EMPTY ‚àß cardtyperecordpage.name‚ààregpage.cardslist
explored (cardtyperecordpage.insert )
R2.1cartpage.invoice ‚â§50 checkout page.discount =cartpage.invoice ‚àó0
R2.250<cartpage.invoice ‚â§100 checkout page.discount =cartpage.invoice ‚àó0.05
R2.3cartpage.invoice >100 checkout page.discount =cartpage.invoice ‚àó0.1
R3regpage.login /‚ààUserCollection ‚àß regpage.login =myinfopage.login ‚àß ¬¨explored (loginpage.logout )
regpage.login =loginpage.user‚àß regpage.email =myinfopage.email ‚àß
explored (loginpage.login) regpage.fname =myinfopage.fname ‚àß
regpage.lname =myinfopage.lname
R4loginpage.user‚ààAdminUserCollection ‚àßexists (Administration Menu ) ¬¨explored (loginpage.logout )
explored (loginpage.login)
II. B USINESS RULES AND RULE COVERAGE
A business rule speciÔ¨Åes some aspect of the logic of an
application, and could pertain to business calculations, access
permissions, and so on (see Figure 1). Formally, a business
ruler= (Œ±, œï,Œì)is a triple consisting of an antecedent
Œ±, aconsequent œï, and a set Œìofinvariant conditions. The
interpretation of a business rule r= (Œ±, œï,Œì)is that, if Œ±
holds at some point in a program execution, œïmust not be
violated along any path from that point. Moreover, if œïholds
along a path, the invariant Œìmust hold at each step of the
execution between the step where Œ±becomes true and the
step where œïholds. Conversely, if there is an execution in
which Œ±andŒìhold but œïis violated, that execution reveals
a fault in the rule‚Äôs implementation. Revealing such faults is,
in fact, the goal of rule-directed test-case generation.
Business-rule speciÔ¨Åcations enable the construction of test
cases with automated oracles : the oracle is basically an
assertion on the consequent condition.
Table I illustrates the formal speciÔ¨Åcation of the BookStore
business rules from Figure 1. For example, the antecedent
ofR3states that (1) a login name that is not in the set of
existing users is entered on the registration page, (2) the same
login name is also entered on the login page, and (3) the login
button is clicked. Together, these three conjuncts specify the
condition that a new user registers and logs in. The consequent
states that the data entered on the registration page must
match the data shown on the user-information page. Finally,
the invariant ensures that, at no point after the antecedent
becomes true and before the user-information page is reached,
the logout button is clicked ( i.e.,the user logs out).
Each antecedent, consequent, and invariant is stated in an
application-speciÔ¨Åc vocabulary of business rule variables. A
business rule variable is drawn from an application-speciÔ¨Åc
domain of page-based labels and collection labels. A page-
based label (e.g.,reg_page.login ) is represented as p.l, where p
is a page and lis a label on the page. A label can be associated
with a user-interface element, such as a hyperlink, a button, or
a textbox. A collection label (e.g.,UserCollection ) represents
a predeÔ¨Åned collection of values.
The antecedent, the consequent, and the invariants are com-
posed using business rule variables, constants, and operators.
A constant represents a string, including the empty string. An
operator can be an arithmetic operator, a logical operator, or
the set-containment operator. In addition to these operators,we use three special operators on page-based labels: exists ,
enabled , andexplored .exists(p.l)evaluates true if label lex-
ists on page p.enabled (p.l)evaluates true if the user-interface
element associated with page-based label p.lis enabled ( i.e.,
the user can perform an action on the element). explored (p.l)
evaluates true if the user-interface element associated with p.l
has been explored ( e.g., the element has been clicked or a data
value has been entered).
For AJAX applications, static page references (URLs) may
not be sufÔ¨Åcient. In this case, we rely on a separately given
description of key GUI states (wireframes or UI mockups are
often available for this purpose), and assign ‚Äúvirtual‚Äù page
names to them to be able to specify page-based labels.
Our goal is to generate a covering test case for a formally
speciÔ¨Åed business rule. A test case, as illustrated in Figure 2,
is a sequence of test steps, where each step is an action
performed on application user interface or a veriÔ¨Åcation of
the user-interface state.
As a test executes, it observes business rule variables
progressively. At the Ô¨Årst test step at which all antecedent
variables have been observed (in this or previous steps), the
rule reaches the stage of antecedant observed (AO). At the
Ô¨Årst subsequent test step at which the antecedant condition
can be evaluated, either the antecedent is true or not. If it is
true, we say the rule has reached rule triggered (RT) stage. At
a subsequent test step, the consequent variables might also be
observed. At the Ô¨Årst such step, the rule is considered covered,
if the invariant is not violated since the RT stage until this step.
We call this stage rule covered (RC).
Consider rule R1(Table I) and the test in Figure 2. Step s6
of the test reaches card_type_record_page on which the an-
tecedent variables name andinsert occur. Therefore, step s6
bringR1to the AO stage. Step s7adds the name of a credit
card and step s8clicks the insert button on that page. Because
the antecedant is true, s8brings the rule to the RT stage.
Finally, step s9reaches the registration page reg_page where
the consequent variable cards_list is observed. Thus, at that
step,R1is covered (RC).
Automated test generation can, of course, fail to generate a
test that covers a rule. In our experiments, we report the best
stage (in the order AO <RT<RC) that an automatically
generated test takes a rule to.
More general coverage criteria for business rules could be
deÔ¨Åned, e.g., based on boundary-value coverage or multiple-
165condition coverage [13] of the antecedent. In this paper, we
focus on the basic level of coverage, and leave the investigation
of more general coverage to future work.
Creating formal speciÔ¨Åcation of rules can take some manual
work. But, this effort would be similar to what is involved in
capturing rules in business-rule management systems, such as
ILOG [14] and JBoss Drools [15], which require a vocabu-
lary of business rules to be established and where rules are
essentially if-then conditions. Moreover, this effort replaces
the manual effort currently spent in designing high-level and
low-level test cases and automating the test cases, which, for
a large set of rules, can be tedious to perform.
III. T EST-CASE GENERATION
The coverage of a rule rrequires the traversals of (1) a
speciÔ¨Åc path œÄanttotrigger the antecedent of rand (2) another
speciÔ¨Åc path œÄcons from œÄant toobserve all consequent
variables of r(while checking that the invariants of rare not
violated along œÄcons). Thus, the test-generation technique has
to discover the path œÄcov= (œÄant¬∑œÄcons).
Our approach consists of two phases. In the Ô¨Årst phase, we
use aggressive state abstraction (via a relaxed notion of state
equivalence) to recover a coarse STD. In the second phase,
we perform test generation guided by the STD and reÔ¨Åne the
STD, where necessary, using stricter notions of equivalence,
to discover new states. The reÔ¨Ånement is done in a goal-driven
manner, which avoids the exploration of irrelevant paths.
Next, we discuss the issue of state equivalence and then
present the two-phase algorithm for test generation.
A. State Equivalence
Many state-equivalence notions have been proposed in
the literature, e.g., based on the edit distance between two
Document Object Models (DOM) [16] and Ô¨Åltering irrelevant
DOM content [17], [18]. But, there is no general abstraction
mechanism that will be effective in all situations; often,
application-speciÔ¨Åc abstraction is required [9], [19] and the
abstraction may also have to be tailored to the analysis
under consideration ( e.g., state abstraction that is effective
for an indexing engine [20] may not be effective for test
generation [10]).
In our approach, we consider the following, progressively
stricter, notions of state equivalence.
‚Ä¢URL-based equivalence. Two application states are equiv-
alent if their base URLs ( i.e., URLs excluding form
parameters and sessions IDs) are the same.
‚Ä¢Container-based equivalence. Two application states are
equivalent if they satisfy URL-based equivalence and
include the same set of visible container elements, such
asdivand form . (In web applications, such container
elements are used to group other elements.)1
1We consider only visible elements because, in AJAX applications, an
element that exists in the DOM may be visible only after some action is
performed. Therefore, considering only visible elements lets the abstraction
distinguish the states before and after executing the action.D
R A BD1 BD2 BD3
CTG SC1 SC2 SC3
CTR1 CTR2 CTR3D
R A BD1
CTG SC1
CTR1
D
R A BD1
SC1
CTR1 CTR2(a) (b)
(c)D
R A BD1
SC1
CTR1 CTR2 CTR3
(d)
  
D: Default                  R: Registration           BD: Book Detail            CTR: Card Types Recor d
A: Administration     SC: Shopping Cart     CTG: Ca rd Types GridCTG CTG
Fig. 6. Illustration of STD construction and reÔ¨Ånement by our two-phase
algorithm. (a) STDmin constructed during Phase 1 using S‚âà. (b) Full
STD (STDmax) that would be constructed using S‚â°. (c)‚Äì(d) Goal-oriented
reÔ¨Ånement of STDmin performed during Phase 2 using S‚â°.
‚Ä¢Clickable-based equivalence. Two states are equivalent if
they satisfy container-based equivalence and include the
same set of clickable elements ( e.g., buttons and links).
‚Ä¢Element-based equivalence. Two states are equivalent if
they satisfy clickable-based equivalence and include the
same set of editable elements ( e.g., text box) with the
same values.
Phase 1 of our approach uses container-based equivalence
(denoted S‚âà) to construct the STD, whereas Phase 2 uses
element-based equivalence (denoted S‚â°) to reÔ¨Åne the STD by
splitting existing states. Phase 2 also uses S‚âàwhile exploring
newly discovered clickables to expand the STD.
The states shown in screenshots 2 and 3 in Figure 4 are
equivalent under S‚âà, but distinct under S‚â°.
To illustrate the STDs constructed under S‚âàandS‚â°,
consider Figure 6. Part (a) of the Ô¨Ågure shows the STD for
BookStore constructed using S‚âàin Phase 1; we refer to this
STD (which is the same as the STD in Figure 3) as STDmin.
The three edges between states CTG andCTR1represent
the three links ‚ÄúAmerican Express,‚Äù ‚ÄúVisa,‚Äù and ‚ÄúInsert‚Äù in
screenshot 1 of Figure 4. Part (b) of Figure 6 shows the fully
reÔ¨Åned STD (referred to as STDmax) constructed using S‚â°.
As shown, STDmax includes new states, such as CTR 2and
CTR 3, that do not exist in STDminbecause those states are
equivalent to CTR 1under S‚âà.
B. Phase 1: STD Construction
In Phase 1, our technique constructs STDminusing the S‚âà
equivalence relation. In particular, the technique explores all
clickables, starting from the initial state of the application, in a
breadth-Ô¨Årst manner. After exploring all clickables in the initial
166Algorithm 1: The algorithm for generating a test case that
covers the given antecedent or consequent condition.
Input : antecedent/consequent expression e, invariant Œì, start state s,
STDS
Output : testtornull
1identify the target states from ethat need to be reached;
2identify n-shortest paths Œ†starting from sthat cover all target states;
3foreach pathœÄ‚ààŒ†do
4 t= invokeExplorePath (œÄ,1, e,Œì, S);
5 ift/negationslash=null then
6 return t;
7return null ;
state, it descends to the newly discovered states and repeats the
process for each unexplored clickable in those states. Part (a)
of Figure 6 shows the STDmin ofBookStore constructed
during Phase 1.
The Phase 1 analysis is similar to existing web-crawling
techniques that perform depth-Ô¨Årst [16] or breadth-Ô¨Årst explo-
ration [20], or support multiple exploration strategies [21]. The
main difference is in our choice of a lenient state-equivalence
notion, which lets us efÔ¨Åciently construct a coarse model for
guiding test generation and subsequent reÔ¨Ånement. Note that
dynamic exploration can require data to be entered in web
forms. For this, we use user-provided or randomly generated
data, as existing crawling techniques do [16], [20], [21].
C. Phase 2: STD ReÔ¨Ånement and Guided Test Generation
Although Phase 1 exercises different paths in the applica-
tion, it may not cover rules because it can ignore desirable
application states for rule coverage. Consider rule R1, which
is covered by exercising path œÄcov(R1)= (œÄant¬∑œÄcons),
where œÄant=(D‚ÜíA‚ÜíCTG ‚ÜíCTR 3), and œÄcons
=(CTR 3‚ÜíCTG ‚ÜíR). This path occurs in STDmax
(Figure 6(b)), but not in STDmin(Figure 6(a)) because CTR 3
is equivalent to CTR 1under S‚âà.
In Phase 2, our technique reÔ¨Ånes STDmin by discovering
more states that are relevant for rule coverage. The reÔ¨Ånement
isgoal-oriented : the analysis expands only the rule-relevant
parts of STDmin and ignores the irrelevant parts. Thus, the
fully expanded STD under S‚â°will often not be constructed.
Consider again rule R1, which is covered by exercising path
œÄcov(R1). To discover this path, our technique selectively
expands STDminto the graphs illustrated in parts (c) and (d)
of Figure 6. Note that, in these graphs, SC1is not reÔ¨Åned
because that state is irrelevant for covering R1, whereas SC1
is reÔ¨Åned in STDmax.
Algorithms 1 and 2 present the Phase 2 analysis. Al-
gorithm 1 takes as inputs (1) an expression ethat is the
antecedent/consequent condition of a rule r, (2) the invariant
Œìofr, (3) the start state s, and (4) the STD S. Algorithm 1
is invoked twice: Ô¨Årst to discover œÄantand then to discover
œÄcons. In the Ô¨Årst invocation, srepresents the root state of S,
whereas in the second invocation, srepresents the last state in
œÄant(i.e.,the state at which ris triggered).Algorithm 2: Algorithm ExplorePath for exploring a path in
the state-transition diagram.
Input : path œÄ, index iintoœÄ, antecedent/consequent expression e,
invariant Œì, STD S
Output :tornull
1ifi=length (œÄ)then
2 evaluate eandŒìon the dynamic trace collected during the
exploration of œÄ;
3 ifsuccessful then
4 convert œÄinto test case t;
5 return t;
else
6 return null ;
7get clickables clickArr corresponding to the edges between œÄ[i]and
œÄ[i+ 1] ;
8foreach clickable c‚ààclickArr do
9 execute con current state;
10 get the new state snew of the application;
11 ifsnew/negationslash=œÄ[i+ 1] under S‚â°then
12 addsnew toS;
13 change target of ctosnew;
14 expand Sby executing all clickables in snew (using
equivalence relation S‚âà);
15 update œÄ[i+ 1] tosnew;
16 t= invokeExplorePath (œÄ, i+ 1, e,Œì, S);
17 ift/negationslash=null then
18 return t;
19 restore the application state to execute the next clickable;
20return null ;
Find candidate paths (Algorithm 1, Lines 1‚Äì4). Algorithm 1
Ô¨Årst identiÔ¨Åes the target states to be reached from the an-
tecedent/consequent expression (line 1). Then, it computes
then-shortest paths, where nis conÔ¨Ågurable, that start at
the source state sand cover all target states (line 2). Each
pathœÄis expressed as a list of application states in the STD.
For example, for the antecedent of R1, one of the identiÔ¨Åed
path in STDmin is(D‚ÜíA‚ÜíCTG ‚ÜíCTR 1). Finally,
Algorithm 1 invokes ExplorePath (Algorithm 2) to explore
each candidate path (lines 3‚Äì4).
A candidate STD path œÄpotentially observes all rule
variables of the antecedent/consequent expression under con-
sideration, but it need not necessarily do so because of the
inaccuracies caused by state abstraction (as discussed in the
Introduction): (1) œÄmay, in fact, not be an executable path or,
(2) if executable, it may reach a target state such that not all
rule variables are observed in the state. In the latter case, the
target state needs to be reÔ¨Åned, using stricter state-equivalence
notions, to discover new state elements (and rule variables).
Thus, the key idea of ExplorePath is to execute œÄand check
whether the concrete states generated along œÄare equivalent
under S‚â°to the states captured in STD S. If two states are not
equivalent, ExplorePath adds a new state to S, and further
explores the new state to identify potentially more, hitherto
undiscovered, states.
Evaluate expression (Algorithm 2, Lines 1‚Äì6). When Algo-
rithm 2 has explored œÄcompletely (line 1), it checks whether
the collected trace satisÔ¨Åes expression e(line 2). If eis
167an antecedent condition, the algorithm checks whether all
antecedent variables are observed and whether the antecedent
evaluates true over the trace. If eis a consequent, the algorithm
checks whether all consequent variables can be observed and,
additionally, that the invariant Œìis not violated in the trace. If
eis satisÔ¨Åed, it constructs and returns a test case (lines 3‚Äì5).
For example, in STDmin (Figure 6(a)), initially, Algo-
rithm 2 explores path (D‚ÜíA‚ÜíCTG ‚ÜíCTR 1)
following the edge labeled ‚Äú1‚Äù between CTG andCTR 1.
However, the resulting page does not contain the Insert button
(screenshot 2 in Figure 4), which has to be clicked to trigger
R1. Therefore, the trace collected over this path does not
satisfy the antecedent condition.
ReÔ¨Åne STD (Algorithm 2, Lines 7‚Äì19). Given the current
state (œÄ[i]) and the next state ( œÄ[i+1]) in the path, Algorithm 2
retrieves all clickables that lead from the current state to next
state and explores each clickable c. If the crequires data to be
entered for editable elements, the technique generates the nec-
essary data by solving constraints in the antecedent/consequent
expression, in addition to the ways used by Phase 1, such as
using random or user-provided data.
The algorithm next executes con the current state to get
the new application state, snew (lines 9‚Äì10). If snew is not
equivalent to œÄ[i+ 1] under S‚â°, the algorithm adds snew to
Sand explores all outgoing clickables of snewto expand the
STD further. During this exploration, the algorithm reverts to
the lenient state-equivalence relation S‚âà. Intuitively, at this
step, the algorithm can discover completely new states and,
therefore, the motivation for using S‚âàin Phase 1 applies here
as well: we intend the algorithm to avoid getting stuck in
parts of the state that may be irrelevant for the rule under
consideration.
Consider Figure 6 again. When the technique explores
edge 2 between CTG andCTR 1inSTDmin(part (a) of the
Ô¨Ågure), it discovers that the new state CTR 2is not equivalent
toCTR 1under S‚â°. Therefore, it extends the STD by adding
CTR 2and an outgoing edge; Figure 6(c) shows the resulting
STD. Even the discovery of CTR 2does not help in triggering
R1. Therefore, the algorithm backtracks and explores edge 3,
which results in the addition of CTR 3to the STD. The Ô¨Ånal
STD, after R1is triggered, is shown in Figure 6(d). After
triggering R1, the technique invokes Algorithm 1 again, this
time with the consequent expression of R1, and repeats the
same process.
IV. E MPIRICAL EVALUATION
We implemented our approach in a prototype tool called
WATEG (Web Application TEst Generator), and conducted two
empirical studies, using Ô¨Åve open-source web applications. In
the Ô¨Årst study, we compared the effectiveness of WATEG in
covering business rules with two other techniques: a technique
based on structural coverage and an undirected crawling tech-
nique. In the second study, we investigated the efÔ¨Åciency of
the three techniques. After describing the experimental setup,
we present the results of the two studies.TABLE II
SUBJECTS USED IN THE EMPIRICAL STUDIES .
Lines of Servlets Business
Subject Description Code Rules
BookStore Shopping portal for books 19402 28 9
ClassiÔ¨Åeds Portal for posting and 10702 19 5
checking advertisements
Events Portal for event announcements 7164 13 10
iTrust Medical web application 77299 184 29
Tudu Manage personal TODOs 23000 19 7
A. Experimental Setup
1) Implementation: WATEG requires formally-speciÔ¨Åed
rules for the web application under test, and attempts to
generate tests that cover the rules. Phase 1 of WATEG generates
an initial STD for the application; Phase 2 reÔ¨Ånes the STD in
a goal-oriented manner to generate rule-covering tests. These
tests are of the form illustrated in Figure 2 and are executed on
a web browser using the IBM Rational Functional Tester [22].
To compare WATEG with a structural-coverage-based testing
technique, we implemented KPATH +, as mentioned in the
Introduction. KPATH + performs bounded path generation over
an STD, but with reÔ¨Ånement by state splitting (as shown
in Figure 5) so that the generated paths can be traversed.
SpeciÔ¨Åcally, KPATH + explores all k-length non-loop paths. To
reÔ¨Åne a path, it checks whether the concrete states generated
along the path are equivalent under S‚â°to the states in the
STD. If the states are not equivalent, it adds new states and
transitions to the STD. There are two main differences between
KPATH + and our Phase 2 analysis: (1) Phase 2 identiÔ¨Åes paths
in a rule-aware manner, whereas KPATH + identiÔ¨Åes all k-
length paths; (2) Phase 2 adds new states in a demand-driven
manner based on rules, whereas KPATH + adds new states in a
rule-oblivious manner. Thus, KPATH + lets us evaluate whether
a structural testing technique that covers bounded-length paths,
without considering rules, can attain high rule coverage.
To assess the effectiveness of a crawling technique in
covering rules, we uses the Phase 1 analysis of WATEG as
the representative crawling technique.
For each test generated by WATEG orKPATH +, we compute
a dynamic trace that captures the browser state after each step.
The browser state includes (1) the page URL, (2) the form
parameters and values, (3) the user-interface elements along
with their current values and states ( e.g., enabled, editable),
(4) the Ô¨Ånite domains of elements such as drop-down lists,
and (5) the text labels. Using the browser states, we check
whether a test triggers, covers, or observes a rule.
2) Subjects and Rules: We used Ô¨Åve open-source web
applications, listed in Table II, as the experimental subjects.
These applications have been used in prior empirical studies
(e.g., [1], [23], [24]). Among the subjects, Tudu2is an AJAX
application, whereas the others are JSP applications.
Regarding business rules, for iTrust ,3the largest applica-
tion among our subjects, we obtained security policies (that
are critical in the application) from the development team
and used them as rules. The other subjects do not have such
2http://tudu.sourceforge.net
3http://agile.csc.ncsu.edu/iTrust/wiki/doku.php
168speciÔ¨Åcations available from which rules could be derived.
ForBookStore , we created nine rules by understanding the
application functionality. For Classifieds andTudu , we
asked a colleague, who is unaware of our technique, to create
the rules. For Events , we asked an IBM testing professional
to create the rules.
Each rule is represented formally (in XML format) as con-
sisting of an antecedent, a consequent, and a set of invariants.
To accommodate a small limitation of WATEG ‚Äîto observe
the values of rule variables, the values must be displayed
in UI elements ( e.g., text boxes), and not as labels, because
WATEG performs label-to-UI-element association‚Äîwe made
minor changes to the subjects. In some of the web pages
in the subjects, rule-related values are displayed as labels.
Therefore, we modiÔ¨Åed those pages to display values in text
boxes. We disabled these text boxes to ensure that WATEG
does not change their values during exploration. We modiÔ¨Åed
nine UI elements over all the subjects.
3) Method: For each subject, we identiÔ¨Åed the minimal
necessary form data, such as authentication credentials, re-
quired for navigating the applications; we provided this data
to each technique. We generated the STD for each application
using the WATEG Phase 1 analysis and measured the rule
coverage attained. Next, we ran KPATH + and the Phase 2
analysis of WATEG on the STDs and measured rule coverage.
For WATEG , we used the time limit of 20 minutes for
exploring each rule; we used the 25 shortest paths as the set
of candidate paths to guide exploration ( i.e., the parameter
nmentioned in Section III-C). For KPATH +, we bound the
path length to 10. (For iTrust , we limited the path length
to Ô¨Åve because any length beyond Ô¨Åve resulted in out-of-
memory failure during path identiÔ¨Åcation on the STD.) We
ran KPATH + until it either covered all rules or hit the time
limit of nine hours for each application. We also identiÔ¨Åed the
coverage attained during two intermediate time intervals: three
hours and six hours. This lets us study whether the number
of rules covered degrades over time and, thus, investigate the
potential beneÔ¨Åts of running KPATH + for longer periods. All
experiments were conducted on an Intel Core 2 Duo CPU
machine with 2.53 GHz and 3GB RAM. Next, we present the
results of the studies.
B. Coverage of Business Rules
Figure 7 presents data about the number of rules that
are covered, triggered, or observed by all techniques: STD
generation, WATEG , and KPATH +. For WATEG and KPATH +,
the coverage results include the rules covered during STD
generation. The chart contains Ô¨Åve segmented bars for each
subject. The Ô¨Årst two bars show coverage attained by STD
generation and WATEG , respectively. The last three bars show
coverage attained by KPATH + with time limits of three, six,
and nine hours, respectively. We use the notation KPATH +(X)
to show the coverage attained after running for Xhours.
The height of each bar represents 100% of the rules in
a subject. The segments (from bottom to top) represent the
percentage of rules that are covered, that are triggered, and
	
	
		
	
	
	
		
	
	
	
			
	
	
	
		
	
	
			   !"!# $% !	&  	&#&	
	'& ($# '& (	!))# %*#%(+, $#
Fig. 7. Effectiveness of the three techniques in covering, triggering, and
observing business rules.
TABLE III
EFFICIENCY OF THE THREE TECHNIQUES .
STD Generation WATEG KPATH + (9)
Subject #St #Tr #Pt Ti #St #Tr #Pt Ti#St #Tr #Pt Ti
BookStore 25 401 383 200 36 573 6215957 14001 2083 540
ClassiÔ¨Åeds 16 166 156 71 31 303 14 4961 13269 1846 540
Events 13 83 82 32 14 89 32100 727 117 21
iTrust 138 3962 4086 1560 164 4867 119 49197 5776 975 540
Tudulists 26 205 448 367 44 554 3559 99 1572 1089 540
St: States, Tr: Transitions, Pt: Paths, and Ti: Time (minutes)
whose antecedents are observed. For instance, for iTrust ,
which has 29 rules, KPATH + covered 9 (32%) rules, triggered
12 (40%) rules, and completely observed the antecedents of 8
(28%) rules. In contrast, WATEG demonstrated much greater
effectiveness: it covered all 29 rules.
WATEG outperformed KPATH + for all the subjects, and to a
substantial degree for two subjects‚Äî iTrust andTudu ‚Äîfor
which the effectiveness of KPATH + was quite low. Over all
subjects, WATEG covered 92% (55/60) of the rules, whereas
KPATH + covered only 52% (31/60) of the rules. The results
also show that only one more rule is triggered by KPATH +(6)
over KPATH +(3), and that KPATH +(9) provides no additional
beneÔ¨Åts in terms of coverage. This trend indicates that addi-
tional rule coverage cannot be achieved by simply running
KPATH + for a longer time period‚Äîthe gains from longer
runs are marginal at best. Also, our results show that STD
generation alone cannot cover most of the rules.
We observed that WATEG performs well in two scenarios.
First, when there exist only a few candidate paths in the
STD that observe rule variables (which occurs in iTrust ),
WATEG is able to explore the candidate paths and identify
the correct path to cover the rule. Second, when there exist
many candidate paths but exploring any path can cover the
rule (which occurs in Events ). However, WATEG does not
perform well if there exist many candidate paths that observe
rule variables, but only a few among them actually cover the
rule (which occurs in BookStore ). Also, currently, WATEG
cannot handle loops in the STD because of which it could not
cover some rules in BookStore andClassifieds . In future
work, we plan to extend WATEG to overcome these limitations.
C. STD Statistics and EfÔ¨Åciency
We next present data about the STDs generated, the number
of paths traversed, and the time taken by the three techniques.
169Table III shows this data. For each technique, columns ‚ÄúSt‚Äù
and ‚ÄúTr‚Äù show the number of STD states and transitions,
respectively; column ‚ÄúPt‚Äù shows the number of paths tra-
versed; and column ‚ÄúTi‚Äù lists the time taken (in minutes). For
example, for BookStore , Phase 1 took 200 minutes to gen-
erate the STD, and the resulting STD contained 25 states and
401 transitions. Also, during the STD generation, 383 paths
were exercised in the application. Note that the overhead for
constructing the STD is a one-time cost only. KPATH + timed
out for all subjects, except for Events for which it exercised
all paths of the bounded length.
The results show that WATEG and KPATH + discovered many
new states and transitions over the initial STD constructed by
Phase 1, which illustrates the signiÔ¨Åcance of S‚â°compared to
S‚âà.WATEG achieved high rule coverage by exercising only
a few paths, whereas KPATH + traversed a large number of
paths but could cover only a few additional rules compared
to STD generation. For example, for Tudu ,KPATH + covered
1089 additional paths, but could not cover any more rules.
These results signify that KPATH + can be good from the
perspective of achieving high structural coverage (by covering
more paths) over STD generation, but this additional structural
coverage does not necessarily translate to good rule coverage.
The results, thus, highlight the signiÔ¨Åcant beneÔ¨Åt of reÔ¨Åning
the STD in a goal-oriented manner, which avoids the explo-
ration of paths that are irrelevant for rule coverage.
V. R ELATED WORK
There exists a large body of work on testing web appli-
cations. Many of the existing techniques fall in the category
of model-based testing ( e.g., [3], [4], [5], [6], [9], [10]): they
construct a model of the web application and derive test cases
from the model based on different notions of coverage. The
techniques differ in terms of the models that are considered,
how the models are constructed, the coverage criteria deÔ¨Åned
on the models, and the analyses used for generating test cases
to satisfy the criteria. But, none of these techniques considers
the coverage of business rules as the goal of test generation.
Ricca and Tonella [3] deÔ¨Åne a web-application model
in which nodes represent pages, forms, and frames, and
edges represent relations, such as link, include, submit, and
split. They apply conventional coverage criteria‚Äî e.g., node
coverage, edge coverage, and path coverage‚Äîto the model
to guide test generation. Similarly, Lucca et al. [5] deÔ¨Åne
coarse and Ô¨Åne-grained web-application models that represent
different components ( e.g., pages, frames, forms, and scripts)
and relationships ( e.g., link, include, submit, and redirect),
and present a decision-table-based method for generating test
cases. Andrews et al. [4] present a hierarchical modeling
technique that partitions an application into clusters of logical
application pages and builds a Ô¨Ånite state machine (FSM) for
each cluster. The nodes in an FSM represent logical web pages
and software modules; edges represent transitions among the
pages and modules, and can be annotated with constraints. Test
cases are generated as sequences of transitions on the FSMs
to meet coverage criteria, such as all nodes and all edges.More recent techniques have focused on testing AJAX-
based (or, rich internet) applications ( e.g., [9], [10], [11]).
Marchetto et al. [9] present a technique that recovers a state
model from existing execution traces and uses the model to
drive further test generation targeted toward covering seman-
tically interacting events (a pair of events is semantically
interacting if there exists a state in which the execution of
those events does not commute). Mesbah and van Deursen [10]
present a crawling technique for AJAX applications that con-
structs a state-Ô¨Çow graph, from which tests to cover k-length
paths are generated.
Among the techniques that do not require an application
model to drive the generation of test cases, the more popular
ones leverage user sessions ( e.g., [7], [8], [11], [25]) or
perform unguided web crawling that is not directed toward
the attainment of any particular coverage goal ( e.g., [16],
[21]). User-session-based techniques generate test sequences
from execution proÔ¨Åles logged during application usage in the
Ô¨Åeld [7]. The effectiveness of these techniques in covering
business rules depends on the comprehensiveness and rich-
ness of the collected user sessions; in practice, many of the
logged sessions may be irrelevant for rule coverage. Similarly,
unguided crawling [16], [21] is unlikely to attain high rule
coverage. In fact, as our results indicate, even techniques
that go a step further, by constructing a model via unguided
crawling and generating tests to cover paths in the model [10],
are likely to achieve low rule coverage.
AJAX-based applications pose particular challenges for
testing. The high degree of dynamism in these applications
makes the construction of accurate state-transition models (to
drive testing) hard. Appropriate state-abstraction mechanisms
that ignore irrelevant parts of the DOM and explore only the
relevant parts are essential. Toward this goal, many abstraction
techniques for computing state equivalence have been pro-
posed, such as comparing the edit distance between two DOM
trees [16], pipelined DOM comparators [17], generic HTML
elements abstractions and application-speciÔ¨Åc abstractions [9],
hashing on the DOM content [20], Ô¨Åltering irrelevant DOM
content via page reloading [18], and comparing ‚Äúactive‚Äù DOM
elements that have attached event handlers, etc. [26]. The
novelty in our approach is that it uses a combination of strict
and relaxed state-equivalence relations in an interleaved and
goal-driven manner: the stricter container-based equivalence
relation while exploring the vicinity of rule-relevant states of
the application, and the relaxed container-based equivalence
when exploring other parts of the application.
Another class of web-application testing techniques focuses
on covering server-side scripts using approaches such as
dynamic symbolic execution ( e.g., [27], [28]), search-based
test generation ( e.g., [29]), or generating new test sequences
from existing tests ( e.g., [30]). For example, Apollo [27] per-
forms dynamic symbolic execution directed toward covering
branches in server-side PHP scripts. SART [30] generates test
sequences by combining parts of existing test sequences to
cover deÔ¨Ånition-use pairs with respect to server-side session
variables and database state. Unlike these techniques, our
170approach is black-box‚Äîit relies on driving the application
via its user interface, without performing any analysis of the
application code‚Äîand, speciÔ¨Åcally, targets navigation paths
that are relevant for rule coverage.
Willmor and Embury [31] present a technique for checking
the implementation of constraint business rules ( i.e.,rules that
constrain the application database). Given a speciÔ¨Åcation of
business rules (in Ô¨Årst-order logic) and an existing set of
database test cases, the technique augments each test case
with check conditions, which are declarative SQL queries, for
each rule; the augmented tests can detect rule violations. Our
approach differs in that we consider business rules that can
be triggered via the user interface (and that are not restricted
to constraint business rules), we formalize the notion of
business rule coverage, and we generate executable test cases
for covering business rules. The technique of Willmor and
Embury augments existing test cases‚Äîwhich may be unrelated
to rules‚Äîand does not use the notion of rule coverage.
Business rule management systems ( e.g., ILOG [14] and
JBoss Drools [15]) provide features for specifying, maintain-
ing, executing, and monitoring business rules. They let rules to
be externalized from the actual application so that rules can be
maintained and evolved separately from the application code.
Although such systems support rule execution and monitoring,
the onus of developing appropriate tests is on the user. Thus,
these systems can only monitor the rules triggered by user-
provided tests. Our approach is applicable in cases where rules
are implemented in the application code (including databases)
and it automatically generates rule-covering tests.
VI. C ONCLUSION
We presented a guided test-generation technique for func-
tional testing of web applications. The goal of functional
testing is to cover interesting application behaviors; in our
case, interesting behaviors are speciÔ¨Åed as business rules
that an application must conform to. Business rules are an
important form of functional speciÔ¨Åcation used in practice, and
testers routinely consult such rules to design functional tests.
Our technique can automate the creation of such tests. The
problem is challenging because a rule may be covered in only a
small fraction of all possible executions of an application, and
one of those desired executions must be orchestrated through
the application‚Äôs GUI. The novelty of our technique is a two-
phase algorithm that can deal with unbounded number of GUI
states via exploring only those states that are relevant for
rules. Our guided technique is much more effective at covering
business rules than an undirected technique.
Our notation of business rule is similar to rule representa-
tions in business-rule management systems ( e.g., ILOG [14]
and JBoss Drools [15]) and it can express certain kinds
of rules, such as business calculations or access-control
policies. However, enterprise applications can have complex
transaction-oriented rules that require more sophisticated mod-
eling (for test generation) than what our current notation per-
mits. In future work, we will investigate modeling techniques
that facilitate test generation for transaction-oriented rules.REFERENCES
[1] W. G. J. Halfond, S. Anand, and A. Orso, ‚ÄúPrecise interface identiÔ¨Åcation
to improve testing and analysis of web applications,‚Äù in ISSTA , 2009,
pp. 285‚Äì296.
[2] ‚ÄúSelenium,‚Äù http://seleniumhq.org/.
[3] F. Ricca and P. Tonella, ‚ÄúAnalysis and testing of web applications,‚Äù in
ICSE , 2001, pp. 25‚Äì34.
[4] A. A. Andrews, J. Offutt, and R. T. Alexander, ‚ÄúTesting web applications
by modeling with FSMs,‚Äù Software and Systems Modeling , vol. 4, no. 3,
pp. 326‚Äì345, Jul. 2005.
[5] G. Di Lucca, A. Fasolino, F. Faralli, and U. De Carlini, ‚ÄúTesting web
applications,‚Äù in ICSM , 2002, pp. 310‚Äì319.
[6] D. C. Kung, C.-H. Liu, and P. Hsia, ‚ÄúAn object-oriented web test model
for testing web applications,‚Äù in COMPSAC , 2000, pp. 537‚Äì542.
[7] S. Elbaum, G. Rothermel, S. Karre, and M. Fisher II, ‚ÄúLeveraging user-
session data to support web application testing,‚Äù IEEE Trans. on Softw.
Eng., vol. 31, no. 3, pp. 187‚Äì202, Mar. 2005.
[8] S. Sprenkle, E. Gibson, S. Sampath, and L. Pollock, ‚ÄúAutomated replay
and failure detection for web applications,‚Äù in ASE, 2005, pp. 253‚Äì262.
[9] A. Marchetto, P. Tonella, and F. Ricca, ‚ÄúState-based testing of Ajax web
applications,‚Äù in ICST , 2008, pp. 121‚Äì130.
[10] A. Mesbah and A. van Deursen, ‚ÄúInvariant-based automatic testing of
AJAX user interfaces,‚Äù in ICSE , 2009, pp. 210‚Äì220.
[11] D. AmalÔ¨Åtano, A. R. Fasolino, and P. Tramontana, ‚ÄúRich internet
application testing using execution trace data,‚Äù in ICST Workshops , 2010,
pp. 274‚Äì283.
[12] T. Ball, V . Levin, and S. Rajamani, ‚ÄúA decade of software model
checking with SLAM,‚Äù CACM , vol. 54, no. 7, pp. 68‚Äì76, Jul. 2011.
[13] G. J. Myers, The Art of Software Testing . John Wiley and Sons, 2004.
[14] ‚ÄúILOG,‚Äù http://www-01.ibm.com/software/websphere/ilog/.
[15] ‚ÄúJBoss Drools,‚Äù http://www.jboss.org/drools/.
[16] A. Mesbah, E. Bozdag, and A. van Deursen, ‚ÄúCrawling AJAX by
inferring user interface state changes,‚Äù in ICWE , 2008, pp. 122‚Äì134.
[17] D. Roest, A. Mesbah, and A. van Deursen, ‚ÄúRegression testing Ajax
applications: Coping with dynamism,‚Äù in ICST , 2010, pp. 127‚Äì136.
[18] S. Choudhary, M. E. Dincturk, G. V . Bochmann, G.-V . Jourdan, I. V .
Onut, and P. Ionescu, ‚ÄúSolving some modeling challenges when testing
rich internet applications for security,‚Äù in ICST , 2012, pp. 850‚Äì857.
[19] A. Mesbah, A. van Deursen, and S. Lenselink, ‚ÄúCrawling Ajax-based
web applications through dynamic analysis of user interface state
changes,‚Äù ACM Trans. on the Web , vol. 6, no. 1, pp. 1‚Äì30, Mar. 2012.
[20] C. Duda, G. Frey, D. Kossmann, R. Matter, and C. Zhou, ‚ÄúAJAX Crawl:
Making AJAX applications searchable,‚Äù in ICDE , 2009, pp. 78‚Äì89.
[21] M. Benedikt, J. Freire, and P. Godefroid, ‚ÄúVeriweb: Automatically
testing dynamic web sites,‚Äù in WWW , 2002.
[22] ‚ÄúRational Functional Tester,‚Äù http://www-
01.ibm.com/software/awdtools/tester/functional.
[23] A. Mesbah, A. van Deursen, and D. Roest, ‚ÄúInvariant-based automatic
testing of modern web applications,‚Äù IEEE Trans. Software Eng. , vol. 38,
no. 1, pp. 35‚Äì53, Jan/Feb 2012.
[24] W. Wang, Y . Lei, S. Sampath, R. Kacker, R. Kuhn, and J. Lawrence, ‚ÄúA
combinatorial approach to building navigation graphs for dynamic web
applications,‚Äù in ICSM , 2009, pp. 211‚Äì220.
[25] S. Sampath, V . Mihaylov, A. Souter, and L. Pollock, ‚ÄúA scalable
approach to user-session based testing of web applications through
concept analysis,‚Äù in ASE, 2004, pp. 132‚Äì141.
[26] D. AmalÔ¨Åtano, A. R. Fasolino, and P. Tramontana, ‚ÄúReverse engineering
Ô¨Ånite state machines from rich internet applications.‚Äù in WCRE , 2008,
pp. 69‚Äì73.
[27] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. M. Paradkar, and M. D.
Ernst, ‚ÄúFinding bugs in web applications using dynamic test generation
and explicit-state model checking,‚Äù IEEE Trans. Softw. Eng. , vol. 36,
no. 4, pp. 474‚Äì494, Jul-Aug. 2010.
[28] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura, and Z. Su,
‚ÄúDynamic test input generation for web applications,‚Äù in ISSTA , 2008,
pp. 249‚Äì260.
[29] N. Alshahwan and M. Harman, ‚ÄúAutomated web application testing
using search based software engineering,‚Äù in ASE, 2011, pp. 3‚Äì12.
[30] ‚Äî‚Äî, ‚ÄúState aware test case regeneration for improving web application
test suite coverage and fault detection,‚Äù in ISSTA , 2012, pp. 45‚Äì55.
[31] D. Willmor and S. M. Embury, ‚ÄúTesting the implementation of business
rules using intensional database tests,‚Äù in TAIC PART , 2006, pp. 115‚Äì
126.
171