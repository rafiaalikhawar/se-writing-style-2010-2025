A
Understanding Integer Overﬂow in C/C++1
WILL DIETZ , University of Illinois at Urbana-Champaign
PENG LI and JOHN REGEHR , University of Utah
VIKRAM ADVE , University of Illinois at Urbana-Champaign
Integer overﬂow bugs in C and C++ programs are difﬁcult to track down and may lead to fatal errors or exploitable vulner-
abilities. Although a number of tools for ﬁnding these bugs exist, the situation is complicated because not all overﬂows are
bugs. Better tools need to be constructed—but a thorough understanding of the issues behind these errors does not yet exist.
We developed IOC, a dynamic checking tool for integer overﬂows, and used it to conduct the ﬁrst detailed empirical study
of the prevalence and patterns of occurrence of integer overﬂows in C and C++ code. Our results show that intentional uses
of wraparound behaviors are more common than is widely believed; for example, there are over 200 distinct locations in the
SPEC CINT2000 benchmarks where overﬂow occurs. Although many overﬂows are intentional, a large number of accidental
overﬂows also occur. Orthogonal to programmers’ intent, overﬂows are found in both well-deﬁned and undeﬁned ﬂavors.
Applications executing undeﬁned operations can be, and have been, broken by improvements in compiler optimizations.
Looking beyond SPEC, we found and reported undeﬁned integer overﬂows in SQLite, PostgreSQL, SafeInt, GNU MPC and
GMP, Firefox, LLVM, Python, BIND, and OpenSSL; many of these have since been ﬁxed.
Categories and Subject Descriptors: D.3.3 [ Programming Languages ]: Language Constructs and Features; D.3.0 [ Pro-
gramming Languages ]: General— Standards ; D.2.5 [ Software Engineering ]: Testing and Debugging— Diagnostics ; D.2.4
[Software Engineering ]: Software/Program Veriﬁcation— Validation
General Terms: Experimentation, Languages, Measurement, Performance
Additional Key Words and Phrases: integer overﬂow, integer wraparound, undeﬁned behavior
1. INTRODUCTION
Integer numerical errors in software applications can be insidious, costly, and exploitable. These
errors include overﬂows, value-losing conversions (e.g., a truncating cast of an int to a short
in C++ that results in the value being changed), and illegal uses of operations such as shifts (e.g.,
shifting a value in C by at least as many positions as its bitwidth). We refer to all these types of errors
collectively as “overﬂow errors.” These errors can lead to serious software failures, e.g., a truncation
error on a cast of a ﬂoating point value to a 16-bit integer played a crucial role in the destruction of
Ariane 5 ﬂight 501 in 1996. These errors are also a source of serious vulnerabilities, such as integer
overﬂow errors in OpenSSH [MITRE Corporation 2002] and Firefox [MITRE Corporation 2010],
both of which allow attackers to execute arbitrary code. In their 2011 report MITRE places integer
overﬂows in the “Top 25 Most Dangerous Software Errors” [Christey et al. 2011].
Detecting integer overﬂows is relatively straightforward by using a modiﬁed compiler to insert
runtime checks. However, reliable detection of overﬂow errors is surprisingly difﬁcult because over-
ﬂow behaviors are not always bugs. The low-level nature of C and C++ means that bit- and byte-level
manipulation of objects is commonplace; the line between mathematical and bit-level operations can
often be quite blurry. Wraparound behavior using unsigned integers is legal and well-deﬁned, and
there are code idioms that deliberately use it. On the other hand, C and C++ have undeﬁned seman-
tics for signed overﬂow and shift past bitwidth: operations that are perfectly well-deﬁned in other
languages such as Java. C/C++ programmers are not always aware of the distinct rules for signed
vs. unsigned types, and may na ¨ıvely use signed types in intentional wraparound operations.2If such
uses were rare, compiler-based overﬂow detection would be a reasonable way to detect integer over-
ﬂow errors. If it is not rare, however, such an approach would be impractical and more sophisticated
techniques would be needed to distinguish intentional uses from unintentional ones.
1This is an extended version of a paper that was presented at the 34thInternational Conference on Software Engineering
(ICSE), Zurich, Switzerland, June 2012.
2In fact, in the course of our work, we have found that even experts writing safe integer libraries ortools to detect integer
errors sometimes make mistakes due to the subtleties of C/C++ semantics for numerical operations.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:2 W. Dietz et al.
Although it is commonly known that C and C++ programs contain numerical errors and also
benign, deliberate use of wraparound, it is unclear how common these behaviors are and in what
patterns they occur. In particular, there is little data available in the literature to answer the following
questions:
(1) How common are numerical errors in widely-used C/C++ programs?
(2) How common is use of intentional wraparound operations with signed types—which has un-
deﬁned behavior—relying on the fact that today’s compilers may compile these overﬂows into
correct code? We refer to these overﬂows as “time bombs” because they remain latent until a
compiler upgrade turns them into observable errors.
(3) How common is intentional use of well-deﬁned wraparound operations on unsigned integer
types?
Although there have been a number of papers on tools to detect numerical errors in C/C++ pro-
grams, no previous work we know of has explicitly addressed these questions, or contains sufﬁcient
data to answer any of them. The closest is Brumley et al.’s work [Brumley et al. 2007], which
presents data to motivate the goals of the tool and also to evaluate false positives (invalid error
reports) due to intentional wraparound operations. As discussed in Section 8, that paper only tan-
gentially addresses the third point above. We study all of these questions systematically.
This article expands upon our previous work [Dietz et al. 2012] making the following primary
contributions: First, we developed Integer Overﬂow Checker (IOC), an open-source tool that de-
tects both undeﬁned integer behaviors as well as well-deﬁned wraparound behaviors in C/C++
programs.3Second, we present the ﬁrst detailed, empirical study—based on SPEC 2000, SPEC
2006, and a number of popular open-source applications—of the prevalence and patterns of occur-
rence of numerical overﬂows in C/C++ programs. Part of this study includes a manual analysis of
a large number of intentional uses of wraparound in a subset of the programs. Third, we used IOC
to discover previously unknown overﬂow errors in widely-used applications and libraries, including
SQLite, PostgreSQL, BIND, Firefox, OpenSSL, GCC, LLVM, the SafeInt library, the GNU MPC
and GMP libraries, Python, and PHP. A number of these have been acknowledged and ﬁxed by the
maintainers (see Section 6).
In addition, this article makes the following new contributions: First, we conducted a new large-
scale experiment in which we automatically tested for overﬂows in 1172 of the top 10,000 Debian
packages. We found that 35% of these packages triggered an overﬂow during execution of their test
suites, and 16% invoked overﬂows with undeﬁned semantics. These results provide strong new evi-
dence that a substantial fraction of arbitrary C/C++ software packages, including many well-tested
ones, contain serious overﬂow errors. Second, we improved IOC by implementing and evaluat-
ing recoverability and two optimizations described in Section 4.4. Third, we integrated IOC into
mainline Clang, a widely used production C/C++ compiler (e.g., it is the primary system compiler
C/C++ compiler on Mac OS and iOS). The features of IOC are available via the -fsanitize=*
family of options, e.g., -fsanitize=integer and-fsanitize=shift . This deployment led to
improvements in diagnostics and the addition of new features such as error deduplication to meet
user needs. We describe this experience in Section 5, contributing the discussion of our end-to-end
development of an effective bug-detection tool that can now be easily used by LLVM/Clang users.
Fourth, this article contains additional discussion of relevant details including hardware support
for integer arithmetic (Section 2), language rules governing implementation-deﬁned behavior (Sec-
tion 3.1), and an explanation of the usual arithmetic conversions (Section 3.2). Fifth, we evaluated
the performance overhead imposed by IOC under different checking policies on integer-intensive
CPU benchmarks as well as security-sensitive server software. These results are presented in Sec-
tion 7.
3IOC is available as part of the production version of the Clang compiler for C/C++ [Clang 2011] as of version 3.3. Usage
information and list of available checks available at http://clang.llvm.org/docs/UsersManual.html . The original
IOC as described in Section 4 is also available at http://embed.cs.utah.edu/ioc/ .
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:3
The key ﬁndings from our study of overﬂows are as follows. First, all four combinations of in-
tentional and unintentional, well-deﬁned and undeﬁned integer overﬂows occur frequently in real
codes. For example, the SPEC CINT2000 benchmarks had over 200 distinct occurrences of in-
tentional wraparound behavior, for a wide range of purposes. Some uses for intentional overﬂows
are well-known, such as hashing, cryptography, random number generation, and ﬁnding the largest
representable value for a type. Others are less obvious, e.g., inexpensive ﬂoating point emulation,
negation of INTMIN, and even ordinary multiplication and addition. We present a detailed analy-
sis of examples of each of the four major categories of overﬂow. Second, overﬂow-related issues in
C/C++ are very subtle and we ﬁnd that even experts get them wrong. For example, the latest revision
of Firefox (as of Sep 1, 2011) contained integer overﬂows in the library that was designed to handle
untrusted integers safely in addition to overﬂows in its own code. More generally, we found very few
mature applications that were completely free of integer numerical errors. This implies that there
is probably little hope of eliminating overﬂow errors in large code bases without sophisticated tool
support. However, these tools cannot simply distinguish errors from benign operations by check-
ing rules from the ISO language standards. Rather, tools will have to use sophisticated techniques
and/or rely on manual intervention (e.g., annotations) to distinguish intentional from unintentional
overﬂows.
2. HARDWARE INTEGER ARITHMETIC
Integer overﬂow bugs in C and C++ ﬁnd their roots in features and limitations of the underlying
hardware platform. On modern processors, an n-bit unsigned integer is represented in such a way
that its value is
n 1
å
i=0xi2i
where xiis the value of the ith bit. The range of an n-bit unsigned integer is 0 :::2n 1. Signed
integers on all modern platforms use a two’s complement representation where the value of an
integer is:
 xn 12n 1+n 2
å
i=0xi2i
An advantage of two’s complement is that signed and unsigned addition can be performed us-
ing the same operation. The same is true for subtraction and multiplication. Historically, this was
advantageous because fewer instructions needed to be implemented. Also, unlike the ones’ comple-
ment andsign-magnitude representations, two’s complement has only one representation for zero.
A drawback of two’s complement is that its range,  2n 1:::2n 1 1, is asymmetric. Thus, there
is a representable value,  2n 1, that does not have a representable additive inverse—a fact that
programmers can and do forget.
When an n-bit addition or subtraction operation on unsigned or two’s complement integers over-
ﬂows, the result “wraps around,” effectively subtracting 2nfrom, or adding 2nto, the true mathe-
matical result. Equivalently, the result can be considered to occupy n+1 bits; the lower nbits are
placed into the result register and the highest-order bit is placed into the processor’s carry ﬂag.
Unlike addition and subtraction, the result of an integer multiplication can wrap around many
times. Consequently, a processor typically places the result of an n-bit multiplication into a location
that is 2 nbits wide, such as a pair of registers. Division instructions commonly have an analogous
structure where the dividend is 2 nbits wide, the divisor is nbits, and the quotient and remainder
are both nbits. Two’s complement division (unlike addition, subtraction, and multiplication) is
not performed by the same operation as unsigned division of the same width. For example, the
x86 architecture has both the idiv instruction for two’s complement integer division and div for
unsigned integer division.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:4 W. Dietz et al.
Table I. Examples of C/C++ integer operations and their results
Expression Result
UINT MAX + 1 0
LONG MAX + 1 undeﬁned
INTMAX + 1 undeﬁned
SHRT MAX + 1 SHRT MAX+1 ifINTMAX > SHRT MAX,
otherwise undeﬁned
char c = CHAR MAX; c++ varies1
-INT MIN undeﬁned2
(char)INT MAX commonly -1
1 << -1 undeﬁned
1 << 0 1
1 << 31 commonly INTMINin ANSI C and
C++98; undeﬁned in C99 and C++112,3
1 << 32 undeﬁned3
1 / 0 undeﬁned
INTMIN % -1 undeﬁned in C11,
otherwise undeﬁned in practice
1The question is: Does cget “promoted” to int before being incre-
mented? If so, the behavior is well-deﬁned. We found disagreement be-
tween compiler vendors’ implementations of this construct.
2Assuming that the inttype uses a two’s complement representation
3Assuming that the inttype is 32 bits long
Processors intended for digital signal processing, including dedicated DSPs and also SIMD ex-
tensions to general-purpose processors, support saturating semantics for overﬂowing integer oper-
ations. Saturating arithmetic never wraps around, but rather “sticks” at the maximum or minimum
representable value. In some domains saturation is a reasonable solution to the problem of integer
overﬂow, but since saturating semantics are not used by C or C++, we will not consider it further.
Processor-level left-shift instructions typically place zeros into vacated bit positions. Right shift
instructions come in logical and arithmetic varieties, where a logical shift places zeros into vacated
bit positions and an arithmetic shift ﬁlls vacated bits with the value contained in the (unshifted)
most signiﬁcant bit, in order to avoid changing the sign of a two’s complement integer. Finally,
many architectures support rotate instructions that treat the value being shifted as a circular buffer:
bits that “fall off” one end of the register are used to ﬁll in vacated bit positions at the other end.
Rotating semantics are not available to C/C++ programs and we will not consider them further.
3. INTEGER ARITHMETIC IN C AND C++
There is tension in the design of C and C++ between the desire for portability on one hand, and the
desire for highly predictable and efﬁcient execution of low-level code on the other hand. Therefore,
in spite of C’s reputation for being a simple “portable assembly language,” its integer semantics are
quite different from those provided by real assembly languages. The same is true of C++. The most
important differences include the following:
— Many integer operations are not entirely portable across platforms due to implementation-deﬁned
behaviors .
— C/C++ perform pervasive implicit conversions between bitwidths and between signed and un-
signed types.
— A number of arithmetic operations have undeﬁned behavior .
— Since the carry and overﬂow ﬂags are not exposed in the language, it is not straightforward for
programmers to write code that detects overﬂow before or after it happens.
The rest of this section explores the consequences of the ﬁrst three of these issues; the last is
discussed in Section 4.2. Table I contains some concrete examples of the results of evaluating some
C/C++ expressions.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:5
3.1. Implementation-Deﬁned Behaviors
An implementation-deﬁned behavior in C/C++ is one where individual implementations are given
freedom to make a choice, but this choice must be consistent and documented. A few of C/C++’s
integer-related implementation-deﬁned behaviors would break most non-trivial C programs if they
deviated from the expected values (given in parentheses):
— The number of bits in a byte (eight)
— The representation used for signed integers (two’s complement)
— The result of converting an integer-typed value into a narrower signed integer-typed value, where
the value cannot be represented in the new type (truncation, with the potential for converting a
positive number into a negative number)
— The result of performing a bitwise operation on values with signed integer types (it is as if the
operands were converted to unsigned integers of the same width, the bitwise operation was per-
formed on them, and the result was cast back to the signed type)
Other behaviors do tend to vary across platforms and compilers. These include the signedness of
thechar type and the size of the short ,int, and long types (expressed as a multiple of the size
of achar ). The inttype in C99 is not required to hold values in excess of 32,767.
3.2. The Usual Arithmetic Conversions
Most integer operators in C/C++ require that both operands have the same type and, moreover,
that this type is not narrower than an int. The collection of rules that accomplishes this is called
the usual arithmetic conversions . The full set of rules encompasses both ﬂoating point and integer
values; here we will discuss only the integer rules. First, both operands are promoted :
If an intcan represent all values of the original type, the value is converted to an int;
otherwise, it is converted to an unsigned int . These are called the integer promotions.
All other types are unchanged by the integer promotions.
If the promoted operands have the same type, the usual arithmetic conversions are ﬁnished. If the
operands have different types, but either both are signed or both are unsigned, the narrower operand
is converted to the type of the wider one.
If the operands have different types and one is signed and the other is unsigned, then the situation
becomes slightly more involved. If the unsigned operand is narrower than the signed operand, and if
the type of the signed operand can represent all values of the type of the unsigned operand, then the
unsigned operand is converted to signed. Otherwise, the signed operand is converted to unsigned.
These rules can interact to produce counterintuitive results. Consider this function:
int compare (void) {
long a = -1;
unsigned b = 1;
return a > b;
}
For a C/C++ implementation that deﬁnes long to be wider than unsigned , such as GCC for x86-
64, this function returns zero. However, for an implementation that deﬁnes long andunsigned to
have the same width, such as GCC for x86, this function returns one. The issue is that on x86-64,
the comparison is between two signed integers, whereas on x86, the comparison is between two
unsigned integers, one of which is very large. Some compilers are capable of warning about code
like this.
3.3. Unsigned Overﬂow
According to the C99 standard:
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:6 W. Dietz et al.
A computation involving unsigned operands can never overﬂow, because a result that
cannot be represented by the resulting unsigned integer type is reduced modulo the
number that is one greater than the largest value that can be represented by the resulting
type.
Thus, the semantics for unsigned overﬂow in C/C++ are precisely the same as the semantics of
processor-level unsigned overﬂow as described in Section 2. As shown in Table I, UINT MAX+1
must evaluate to zero in a conforming C and C++ implementation.
Unsigned overﬂow tends to lead to two kinds of problems in C/C++ programs. First, it is often the
case that developers are simply not expecting values to overﬂow. For example, one of the infamous
Therac-25 bugs [Leveson and Turner 1993] occurred when an 8-bit variable, which used a non-
zero value to signal an error, wrapped around to zero, causing a crucial checking function to be
bypassed. Second, since the sizes of integer types are implementation-deﬁned, overﬂow will occur
at different values on different platforms. For example, GCC evaluates 0UL-1 to 264 1 on x86-64
and to 232 1 on x86.
3.4. Signed Overﬂow and Other Undeﬁned Behaviors
If a signed arithmetic operation overﬂows, for example by evaluating INTMAX+1 , the behavior of
the C implementation is undeﬁned . According to the C99 standard, undeﬁned behavior is
“behavior, upon use of a non-portable or erroneous program construct or of erroneous
data, for which this International Standard imposes no requirements.”
In Internet parlance:4
“When the compiler encounters [a given undeﬁned construct] it is legal for it to make
demons ﬂy out of your nose.”
Other operations with undeﬁned behavior include shifting a value by at least as many bit positions
as the bitwidth of the promoted type of the operand, shifting by a negative number of bit positions,
and division by zero. Undeﬁned behavior represents a signiﬁcant departure from the semantics of
processor-level operations, and our experience is that many developers fail to appreciate the full
consequences of this. The rest of this section examines these consequences.
3.4.1. Silent Breakage. A C or C++ compiler may exploit undeﬁned behavior in optimizations
that silently break a program. For example, a routine refactoring of Google’s Native Client software
accidentally caused 1<<32 to be evaluated in a security check.5The compiler—at this point under
no particular obligation—simply turned the safety check into a nop. Four reviewers failed to notice
the resulting vulnerability.
Another illuminating example is the code in Listing 1. In this program, the same computation
((INT MAX+1) > INT MAX) is performed twice with two different idioms. Recent versions of GCC,
LLVM, and Intel’s C compiler, invoked at the -O2 optimization level, all print a zero for the ﬁrst
value (line 6) and a one for the second (line 7). In other words, each of these compilers consid-
ersINTMAX+1 to be both larger than INTMAXand also not larger, at the same optimization level,
depending on incidental structural features of the code. The point is that when programs execute
undeﬁned operations, optimizing compilers may silently break them in non-obvious and not neces-
sarily consistent ways.
3.4.2. Time Bombs. Undeﬁned behavior also leads to time bombs : code that works under today’s
compilers, but breaks unpredictably in the future as optimization technology improves. The Inter-
net is rife with stories about problems caused by GCC’s ever-increasing power to exploit signed
4http://catb.org/jargon/html/N/nasal-demons.html
5http://code.google.com/p/nativeclient/issues/detail?id=245
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:7
1int foo ( int x) {
2return ( x+1 ) > x;
3}
4
5int main ( void ) {
6printf ("%d\n", ( INT MAX+1 ) > INT_MAX );
7printf ("%d\n", foo ( INT_MAX ));
8return 0;
9}
Listing 1: Source for overflow.c referred to in the text
overﬂows. For example, in 2005 a principal PostgreSQL developer was annoyed that his code was
broken by a recent version of GCC:6
It seems that gcc is up to some creative reinterpretation of basic C semantics again;
speciﬁcally, you can no longer trust that traditional C semantics of integer overﬂow
hold ...
This highlights a fundamental and pervasive misunderstanding: the compiler was not “reinterpret-
ing” the semantics but rather was beginning to take advantage of leeway explicitly provided by the
C standard.
In Section 6.5 we describe a time bomb in SafeInt [LeBlanc 2004]: a library that is itself intended
to help developers avoid undeﬁned integer overﬂows. This operation had been compiled by GCC
(and other compilers) into code that behaved correctly. However, a subsequent version of GCC (4.7)
exposed the error, presumably because it optimizes the code more aggressively. We discovered this
error using IOC and reported it to the developers, who ﬁxed it within days [LeBlanc 2011].
3.4.3. Illusion of Predictability. Some compilers, at some optimization levels, have predictable be-
havior for some undeﬁned operations. For example, at low optimization levels, C and C++ compilers
typically give two’s complement semantics to signed overﬂows. It is, however, very unwise to rely
on this, as the behavior can change when the compiler, the compiler version, or the compiler ﬂags
are changed.
3.4.4. Informal Dialects. Some compilers support stronger semantics than are mandated by the
standard. For example, both GCC and Clang support a -fwrapv command line ﬂag that forces
signed overﬂow to have two’s complement behavior. In fact, the PostgreSQL developers responded
to the incident above by adding -fwrapv to their build ﬂags. They are now, in effect, targeting a
non-standard dialect of C.
3.4.5. Non-Standard Standards. Some kinds of overﬂow have changed meaning across different
versions of the standards. For example, 1<<31 is implementation-deﬁned in ANSI C and C++98,
while being explicitly undeﬁned by C99 and C11 (assuming 32-bit ints). Our experience is that
awareness of this particular rule among C and C++ programmers is low.
A second kind of non-standardization occurs with constructs such as INTMIN%-1 which is—by
our reading—well deﬁned in ANSI C, C99, C++98, and C++11. However, we are not aware of a
C or C++ compiler that reliably returns the correct result, zero, for this expression. The problem
is that on architectures including x86 and x86-64, correctly handling this case requires an explicit
check in front of every %operation; compiler vendors are unwilling to impose this overhead on their
6http://archives.postgresql.org/pgsql-hackers/2005-12/msg00635.php
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:8 W. Dietz et al.
Front End Back End ExecutionInstrumentation RuntimeIOC
Source Checked IR Executable
Fig. 1 . Architecture of IOC
users. The C standards committee has recognized the problem and C11 explicitly makes this case
undeﬁned.
4. TOOL DESIGN AND IMPLEMENTATION
IOC, depicted in Fig. 1, has two main parts: a compile-time instrumentation transformation and a
runtime handler. The transformation is a compiler pass that adds inline numerical error checks; it is
implemented as a1600 LOC extension to Clang [Clang 2011], the C/C++ frontend to LLVM [Lat-
tner and Adve 2004]. IOC’s instrumentation is designed to be semantically transparent for programs
that conform to the C or C++ language standards, except in the case where a user requests additional
checking for conforming but error-prone operations, e.g., wraparound with unsigned integer types.
The runtime library is linked into the compiler’s output and handles overﬂows as they occur; it is
900 lines of C code.
This section discusses some of the key design choices made in the tool, including at what point
in compilation to perform the instrumentation; how to perform the run-time overﬂow checks; the
design of the run-time library; and, how to efﬁciently recover from a detected overﬂow operation
and continue execution.
4.1. Where to Put the Instrumentation Pass?
The IOC transformation operates on the Abstract Syntax Tree (AST) late in the Clang front end—
after parsing, type-checking, and implicit type conversions have been performed. This is an appro-
priate stage for inserting checks because full language-level type information is available, but the
compiler has not yet started throwing away useful information as it does during the subsequent
conversion into the ﬂat LLVM intermediate representation (IR).
In a previous iteration of IOC we encoded the required high-level information into the IR (using
IR metadata), which is much simpler to transform than the AST and also allows the transformation
to be more naturally expressed as a compiler pass. Unfortunately, this proved to be unreliable and
unnecessarily complicated, because it requires a substantial amount of C-level type information to
be recorded with the IR in order to support a correct transformation. For example, the IR does not
distinguish between signed and unsigned integer types (since the two’s complement representation
is equivalent for both), but this distinction is essential for correct checking of integer overﬂows in C
code. Similarly, some important operations (such as signed to unsigned casts) do not exist at the IR
level. Also, the original transformation was further complicated by the lack of a one-to-one mapping
between IR and AST nodes. In short, it is much less error-prone to do the instrumentation in the
frontend, where all the required information is naturally available, despite the greater complexity of
the representation.
4.2. Overﬂow Checks
Finding overﬂows in shift operations is straightforward: operand values are bounds-checked and
then, if the checks pass, the shift is performed. Checking for overﬂow in arithmetic operations is
trickier; the problem is that a checked n-bit addition or subtraction requires n+1 bits of precision
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:9
and a checked n-bit multiplication requires 2 nbits of precision. Finding these extra bits can be
awkward. There are basically three ways to detect overﬂow for an operation on two signed integers
s1ands2.
(1)Precondition test. It is always possible to test whether an operation will wrap without actually
performing the operation. For example, signed addition will wrap if and only if this expression
is true:
((s2>0)^(s1>(INTMAX s2)))_((s2<0)^(s1<(INTMIN s2)))
In pseudocode:
if (!precondition) then
call failure handler
endif
result = s1 op s2
(2)CPU ﬂag postcondition test. Most processors contain hardware support for detecting overﬂow:
following execution of an arithmetic operation, condition code ﬂags are set appropriately. In the
general case, it is problematic to inspect processor ﬂags in portable code, but LLVM supports
a number of intrinsic functions where, for example, an addition operation returns a structure
containing both the result and an overﬂow ﬂag. The LLVM backends, then, emit processor-
speciﬁc code that accesses the proper CPU ﬂag. In pseudocode:
(result, flag) = s1 checked op s2
if (flag) then
call failure handler
endif
(3)Width extension postcondition test. If an integer datatype with wider bitwidth than the values
being operated on is available, overﬂow can be detected in a straightforward way by converting
s1ands2into the wider type, performing the operation, and checking whether the result is in
bounds with respect to the original (narrower) type. In pseudocode:
result = extend(s1) op extend(s2)
if (result < MIN || result > MAX) then
call failure handler
endif
IOC supports both the precondition test and the CPU ﬂag postcondition test; width extension
seemed unlikely to be better than these options due to the expense of emulating 64-bit and 128-bit
operations. Initially we believed that the CPU ﬂag postcondition checks would be far more efﬁcient
but this proved not to be the case. Rather, using the ﬂag checks has an uneven effect on performance.
We evaluated this performance question experimentally, as follows.
4.2.1. Performance of the Overﬂow Checks. We studied the overall performance impact of IOC
to answer two questions: How do the precondition test and the CPU ﬂag postcondition test compare
in terms of the overheads they introduce? And how much run-time overhead is introduced by using
IOC?
To answer these questions, we compiled SPEC CPU 2006 in three ways: (1) A baseline compila-
tion using Clang with optimization options set for maximum expected performance. (2) Checking
for undeﬁned integer overﬂows (shifts and arithmetic) using precondition checks. (3) Checking for
undeﬁned integer overﬂows (shifts and arithmetic) using the CPU ﬂag postcondition test. We then
ran the benchmarks on a 3.4 GHz AMD Phenom II 965 processor, using their “ref” inputs—the
largest input data, used for reportable SPEC runs—ﬁve times and used the median runtime. We con-
ﬁgured the fault handler to return immediately instead of logging overﬂow behaviors. Thus, these
measurements do not include I/O effects due to logging, but they do include the substantial overhead
of marshaling the detailed failure information that is passed to the fault handler.
For undeﬁned behavior checking using precondition checks, slowdown relative to the baseline
ranged from 0:5%–191%, i.e., from a tiny accidental speedup to a threefold increase in run-
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:10 W. Dietz et al.
time. The mean slowdown was 44%. Using ﬂag-based postcondition checks, slowdown ranged from
0:4%–95%, with a mean of 30%. However, the improvement was not uniform: out of the 21 bench-
mark programs, only 13 became faster due to the IOC implementation using CPU ﬂags.
The explanation for the uneven beneﬁts of the CPU ﬂag checks can be found in the interaction
between the overﬂow checks and the compiler’s optimization passes. The precondition test generates
far too many operations, but they are operations that can be aggressively optimized by LLVM. On
the other hand, the LLVM intrinsics supporting the ﬂag-based postcondition checks are recognized
and optimized by relatively few optimization passes, causing much of the potential performance
gain due to this approach to be unrealized.
4.3. Runtime Library for Error Reporting
To produce informative error messages, IOC logs the source-code location corresponding to each
inserted check, including the column number where the operator appeared. (Operating on the AST
instead of the LLVM IR makes such logging possible, and Clang has outstanding error reporting.)
Thus, users can disambiguate, for example, which shift operator overﬂowed in a line of code
containing multiple shift operators. Also in service of readable error messages, IOC logs the types
and values of the arguments passed to the operator; this is important for operators with multiple
modes of failure, such as shift. For example, an error we found in OpenSSL was reported as:
<lhash.c, (464:20)> : Op: >>, Reason :
Unsigned Right Shift Error: Right operand is negative or is greater than or equal to the width of the
promoted left operand ,
BINARY OPERATION: left (uint32): 4103048108 right (uint32): 32 .
Based on the value of an environment variable, the IOC failure handler can variously send its
output to STDOUT , toSTDERR , to the syslog daemon, or it can simply discard the output. The syslog
option is useful for codes that are sensitive to changes in their STDOUT andSTDERR streams, and for
codes such as daemons invoked in execution environments where capturing their output would be
difﬁcult.
Finally, to avoid overwhelming users with repetitive error messages, the fault handler uses another
environment variable to specify the maximum number of times an overﬂow message from any
particular program point will be printed.
4.4. Efﬁcient Error Recovery
When an overﬂow check is triggered, it is often desirable to continue program execution, which we
callrecovery . When running IOC on a code base there are often multiple errors, many of which may
be benign, and using recoverable checking to ﬁnd these with a single run is useful. Unfortunately,
our original implementation showed substantial slowdowns in error-free execution when making
checks recoverable. To evaluate these overheads, we ran IOC with signed overﬂow and division-
by-zero checks on the subset of SPEC CINT2006 benchmarks that did not trigger these errors
dynamically. Adding more check types caused this subset to be too small to be interesting. With our
initial implementation, the no-recovery case had an overhead of 15% on average while recoverable
checking had an average overhead of 35%.
We used hardware performance counters, accessed via Intel’s VTune software [Intel 2013], to
investigate the causes of the slowdowns. The ﬁrst source of slowdown poor code layout, which de-
graded performance via bad cache interaction and frontend stalls. We resolved this issue by adding
branch prediction metadata at the LLVM IR level, which the backend uses to guide block placement.
By hinting that the checks are unlikely to be taken, the basic blocks containing calls to the runtime
are not interspersed with the normal code. This issue did not arise with no-recovery checking be-
cause the code after the handler call is marked as unreachable, which similarly inﬂuences block
layout.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:11
Using performance counters, we veriﬁed that our ﬁx resolved the layout problem. For example,
in the SPEC benchmark 456.hmmer, we observed that the number of instruction-starved cycles
(cycles where the front-end did not issue an instruction) was reduced by 43% and CPI decreased
from 0 :685 to 0 :614. Indeed, this resulted in a signiﬁcant improvement for this benchmark: down
from 179s to 142s (from 53% to 21% slowdown, relative to the no-recovery case). Averaged across
the benchmarks, this optimization brought recovery overhead down to 25%, signiﬁcantly less than
the original 35%.
The second problem we identiﬁed was that, to enable recovery, failure-handling blocks for in-
serted checks must branch back into the program execution, which hurts register allocation perfor-
mance in error-free paths. In particular, the compiler backend has to allocate registers with the addi-
tional constraints imposed by the parameter preparation and the registers clobbered by the runtime
call. We resolved this by changing the runtime functions to use a special “cold” calling convention
which indicates the call clobbers as little as is possible for the architecture. This was a difﬁcult
change because it requires making the runtime functions save/restore all registers on entry/exit with
hand-written assembly and because, while LLVM already supports “coldcc” as part of the IR, it is
treated the same as the normal C calling convention on all architectures. To handle the former we
used hand-written assembly wrappers for the normal C functions, and plan on proposing a function
attribute to cause the compiler to do this automatically (gcc has support for this). For the latter, we
extended the LLVM x86 and x86 64 back ends to treat coldcc calls as not clobbering any registers.
Together, these changes reduced average overhead to 21% (only 6% over the no-recovery case),
which is low enough to make checks recoverable by default. These optimizations would beneﬁt any
similar runtime check instrumentation: the ﬁrst has already been adopted into mainline Clang for use
in other sanitization checks, and there are plans to make use of the calling convention optimization
once sufﬁcient support has been added to LLVM.
5. IOC DEPLOYMENT
After the initial release of IOC, our ﬁndings and user feedback encouraged us to work to make IOC
more widely available by working with the LLVM and Clang developers to include integer overﬂow
checks in the ofﬁcial Clang code. During this process we made a number of functionality, efﬁciency,
and usability changes resulting in the ﬁrst widely-available easy-to-use tools to enable developers to
better reason about integer overﬂows in the software they build and use. As a result of these efforts,
integer checking support is now available in LLVM/Clang. The ﬁrst release including our integer
checking features was version 3.3 in June 2013.
5.1. User Interface
In the original version of IOC, users speciﬁed what operations to check by requesting checks for
violations of a particular version of the C standard. This was found to be cumbersome and for the
version of IOC deployed with Clang, we integrated our command line options with the -fsanitize
family of options, providing users with a uniﬁed interface to a variety of dynamic checks. Ex-
ample invocations include -fsanitize=integer (check all suspicious integer operations) and
-fsanitize=shift (check only shift operations).
5.2. Improved Diagnostics
Diagnostics were improved to read more naturally and to match the formatting style of errors given
statically by the Clang compiler. Here are two examples taken from ClamA V 0.97.6:
bytecode vm.c:687:6: runtime error: signed integer overflow: 65535 * 65535 cannot be
represented in type `int'
bytecode vm.c:709:6: runtime error: left shift of 255 by 56 places cannot be represented in
type `int64 t' (aka `long')
These new diagnostics are designed to signiﬁcantly improve the user experience by providing a
natural explanation about what occurred including the operands that triggered the problem. While
the same information was available in the diagnostics printed by the original IOC, it has been made
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:12 W. Dietz et al.
cleaner with attention given to details such as providing source-level types and more speciﬁc expla-
nations.
5.3. New Features
Besides changing the interface, we also introduced a number of features to make IOC suitable
for a larger variety of use cases. First, we added the ability to continue program execution (to
“recover”) after a failing check. Making checks recoverable incurs a performance penalty, which
we signiﬁcantly reduced through the changes described in Section 4.4.
In addition to making checks recoverable, once a particular check has been triggered, often users
are not interested in seeing the error again. This error deduplication was originally accomplished
using a hash table, but this design proved to not scale well. To address this, we now emit a byte for
each check which is used to track its triggered state which scales well and only requires a minor
amount of additional space in the resulting binary.
Finally, often integer overﬂows are known to be intentional or the programmer has investigated
it and determined it to be acceptable. To address these use cases while still being useful in report-
ing undesired integer overﬂows a whitelist functionality was introduced to enable users to specify
certain ﬁles or functions that should not be checked.
5.4. Runtime Concerns
Inclusion in a production compiler required us to address a number of edge-cases in our runtime that
we previously ignored in our research prototype. Examples include avoiding dependencies on libc,
linking the IOC runtime automatically and transparently in a variety of build scenarios, ensuring
correct execution in multithreaded environments, and ensuring the preservation of errno across
calls into the runtime functions.
6. INTEGER OVERFLOW STUDY
This section presents the qualitative and quantitative results of our study of overﬂow behaviors in C
and C++ applications.
6.1. Limitations of the Study
There are necessarily several limitations in this kind of empirical study. Most important, because
IOC is based on dynamic checking, bugs not exercised by our inputs will not be found. In this
sense, our results understate the prevalence of integer numerical errors as well as the prevalence
of intentional uses of wraparound in these programs. A stress testing campaign, or use of a formal
methods tool, would be very likely to uncover additional integer bugs.
Second, our methodology for distinguishing intentional from unintentional uses of wraparound
is manual and subjective. The manual effort required meant that we could only study a subset of the
errors: we focused on the errors in the SPEC CINT2000 benchmarks for these experiments. For the
other experiments, we study a wider range of programs.
Finally, while some parts of our study are methodical, other parts were performed in an informal
fashion, and hence our reporting of the results is also informal. For example, in many cases we lack
links into bug reporting systems because the programs that we tested do not have bug reporting
systems—the bugs we found were reported by email. In other cases, we lack a deﬁnitive answer
about whether a particular bug was ﬁxed because (1) the developers failed to conﬁrm that they
ﬁxed the bug and (2) the changes across versions of programs are often large enough that manually
tracking the status of bugs in the code is infeasible.
6.2. A Taxonomy for Overﬂows
Table II summarizes our view of the relationship between different integer overﬂows in C/C++ and
the correctness of software containing these behaviors. Only Type 2 overﬂows do not introduce
numerical errors into carefully written C/C++ software. Using IOC, we have found examples of
software errors of Types 1, 3, and 4, as well as correct uses of Type 2. The section numbers in the
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:13
Table II. Taxonomy of integer overﬂows in C and C++ with references to discussion of examples
undeﬁned behavior deﬁned behavior
e.g. signed overﬂow, e.g. unsigned wraparound,
shift error, signed wraparound
divide by zero with -fwrapv
intentional Type 1: Type 2:
design error, no error,
may be a “time bomb” but may not be portable
§ 6.3.3, 6.3.9 § 6.3.2, 6.3.5, 6.3.8
unintentional Type 3: Type 4:
implementation error, implementation error
may be a “time bomb”
§ 6.3.4 § 6.3.1, 6.3.6
1/* ( this test assumes unsigned comparison ) */
2if ( w - d >= e)
3{
4memcpy ( slide + w, slide + d, e);
5w += e;
6d += e;
7}
Listing 2: Well-deﬁned but incorrect guard for memcpy in 164.gzip
table are forward references to discussions of bugs in the next section. We found many additional
examples of each type of error, but lack space to discuss them in detail.
6.3. Wraparound and Overﬂow in SPEC CINT 2000
To investigate the prevalence of, and use-cases for, overﬂows and wraparounds, we examined SPEC
CINT2000 in detail. The SPEC benchmark suites each contain a carefully selected set of C and
C++ programs, designed to be representative of a wide range of real-world software (and many
like GCC, bzip2, and povray, are taken from widely used applications). Moreover, since they are
primary performance benchmarks for both compilers and architectures, these benchmarks have been
compiled and tested with most optimizing compilers, making them especially good case studies.
We ran the SPEC benchmarks’ “ref” data sets. Using IOC, we investigated every addition, sub-
traction, multiplication, and division overﬂow in an attempt to understand what it is that developers
are trying to accomplish when they put overﬂows into their code.
Our ﬁndings are shown in Table III and described below. This benchmark suite consists of 12
medium-sized programs (2.5–222 KLOC), eight of which executed integer overﬂows while running
on their reference input data sets.
Note: Real C code can be messy. We have cleaned up the SPEC code examples slightly when we
deemed this to improve readability and to not change the sense of the code.
6.3.1. 164.gzip. IOC reported eight wraparounds in this benchmark, all using well-deﬁned un-
signed operations. Of course, even well-deﬁned operations can be wrong; we discuss an example of
particular interest, shown in Listing 2. The POSIX memcpy function is undeﬁned if its source and
target memory regions overlap. To guard against invoking memcpy incorrectly, the code checks that
e(number of bytes copied) is less than the distance between wandd(both offsets into a memory
region). If this check fails, a slower memory copy that correctly handles overlap is invoked.
However, when dwan unsigned overﬂow occurs, resulting in an integer that is much greater
than any potential value for e, causing the safety check to pass even when the source and target
regions overlap. This overﬂow was reported by IOC and while investigating the report we discovered
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:14 W. Dietz et al.
Table III. Integer wraparounds reported in SPEC CINT2000
Name Location1Op2Description
164.gzip bits.c(136:18) +uBit manipulation
164.gzip bits.c(136:28)  uBit manipulation
164.gzip deﬂate.c(540:21)  uUnused
164.gzip inﬂate.c(558:13)  uBit manipulation
164.gzip inﬂate.c(558:22)  uBit manipulation
164.gzip inﬂate.c(566:15)  uIncorrect memcpy guard (Listing 2)
164.gzip trees.c(552:25) +uType promotion
164.gzip trees.c(990:38)  uType promotion
175.vpr route.c(229:19)  uHash
175.vpr util.c(463:34) uRandom Number Generation (Listing 3)
175.vpr util.c(463:39) +uRandom Number Generation
175.vpr util.c(484:34) uRandom Number Generation
175.vpr util.c(484:39) +uRandom Number Generation
176.gcc combine.c6 sFind INTMAX(Listing 4)
176.gcc cse.c5 +uHash
176.gcc expmed.c15u;sBit manipulation
176.gcc expmed.c(2484:13) uInverse of xmod 2n
176.gcc expmed.c(2484:18)  uInverse of xmod 2n
176.gcc expmed.c(2484:21) uInverse of xmod 2n
176.gcc insn-emit.c(3613:5) +uRange check
176.gcc loop.c(1611:19) sCost calculation bug (Listing 5)
176.gcc m88k.c(127:44)  uBit manipulation (Listing 6)
176.gcc m88k.c(128:20) +uBit manipulation
176.gcc m88k.c(128:20)  uBit manipluation
176.gcc m88k.c(888:13) +uRange check
176.gcc m88k.c(1350:38) +uRange check
176.gcc m88k.c(2133:9) +uRange check
176.gcc obstack.c(271:49)  uType promotion artifact
176.gcc real.c(1909:35)  uEmulating addition
176.gcc real.c(2149:18) sOverﬂow check
176.gcc rtl.c(193:16) +uAllocation calc bug (Listing 7)
176.gcc rtl.c(193:16) uAllocation calc bug
176.gcc rtl.c(216:19) uAllocation calc bug
176.gcc rtl.c(216:5) +uAllocation calc bug
176.gcc stor-layout.c(1040:7)  sFind largest sint
176.gcc tree.c(1222:15) sHash
176.gcc tree.c(1585:37)  sBit manipulation
176.gcc varasm.c(2255:15) sHash
186.crafty evaluate.c(594:7)  uBit manipulation
186.crafty evaluate.c(595:7)  uBit manipulation
186.crafty iterate.c(438:16) sStatistic bug ( 100*a/(b+1) )
186.crafty utility.c(813:14) +uRandom Number Generation
197.parser and.c6 +u;sHash
197.parser fast-match.c(101:17) +uHash
197.parser fast-match.c(101:8) +sHash
197.parser parse.c10 +u;sHash
197.parser prune.c7 +u;sHash
197.parser xalloc.c(68:40) uCompute SIZE MAX >> 1 (Listing 8)
197.parser xalloc.c(70:19) +uCompute SIZE MAX >> 1
253.perlbmk hv.c7uHash
253.perlbmk md5c.c68 +uHash
253.perlbmk pp.c(1958:14)  uMissing cast
253.perlbmk pp.c(1971:6) +uMissing cast
253.perlbmk regcomp.c(353:26) +sUnused
253.perlbmk regcomp.c(462:21) +sUnused
253.perlbmk regcomp.c(465:21) +sUnused
253.perlbmk regcomp.c(465:34) sUnused
253.perlbmk regcomp.c(465:9) +sUnused
253.perlbmk regcomp.c(584:23) +sUnused
253.perlbmk regcomp.c(585:13) +sUnused
253.perlbmk sv.c(2746:19)  uType promotion artifact
254.gap eval.c(366:34) sOverﬂow check requiring -fwrapv
254.gap idents.c4uHash
254.gap integer.c28sOverﬂow check requiring -fwrapv
254.gap integer.c4 +sOverﬂow check requiring -fwrapv
254.gap integer.c4 sOverﬂow check requiring -fwrapv
255.vortex ut.c(1029:17) uRandom Number Generation
1Source, and line:column. For space, we summarize frequent ones as ‘ n’.
2Operation Type(s), and Signed/Unsigned.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:15
1# define IA 1103515245 u
2# define IC 12345 u
3# define IM 2147483648 u
4
5static unsigned int c_rand = 0;
6
7/* Creates a random integer [0... imax ] ( inclusive ) */
8int my_irand ( int imax ) {
9int ival ;
10 /* c_rand = ( c_rand * IA + IC) % IM; */
11 c_rand = c rand * IA + IC ;// Use overflow to wrap
12 ival = c_rand & (IM - 1); /* Modulus */
13 ival = ( int ) (( float ) ival * ( float ) ( imax + 0.999) / ( float ) IM);
14 return ival ;
15}
Listing 3: Correct wraparound in a pseudo-random number generator in 175.vpr
1/* ( unsigned ) <= 0 x7fffffff is equivalent to >= 0. */
2else if ( const_op == (( HOST_WIDE_INT ) 1 << ( mode_width - 1)) - 1)
3{
4const_op = 0, op1 = const0_rtx ;
5code = GE;
6}
Listing 4: Undeﬁned overﬂow in 176.gcc to compute INTMAX
this potential bug. Fortunately, the version of gzip used in this experiment is rather old (based on
1.2.4) and this issue has already been reported and ﬁxed upstream7as of version 1.4. Note that this
bug existed in gzip as of 1993 and was not ﬁxed until 2010. Furthermore, the initial ﬁx was overkill
and was later ﬁxed8to be the proper minimal condition to protect the memcpy . This illustrates the
subtlety of overﬂow errors, and serves as a good example of well-deﬁned overﬂows leading to logic
errors. In terms of the taxonomy in Table II, this wraparound is Type 4.
6.3.2. 175.vpr. This benchmark had four unsigned wraparounds caused by two similar imple-
mentations of random number generation. As shown in Listing 3, the developers documented their
intentional use of unsigned integer wraparound. These wraparounds are well-deﬁned and benign,
and represent an important idiom for high-performance code. They are Type 2.
6.3.3. 176.gcc. This benchmark had overﬂows at 48 static sites, some undeﬁned and some
well-deﬁned. Listing 4 shows code that tries to compute the largest representable signed in-
teger. HOST WIDE INT is an int andmode width is 32, making the expression equivalent to
(1 << 31) - 1 . This expression is undeﬁned in two different ways. First, in C99 it is illegal to
shift a “1” bit into or past the sign bit. Second—assuming that the shift operation successfully com-
putes INTMIN—the subtraction overﬂows. In our experience, this idiom is common in C and C++
code. Although compilers commonly give it the semantics that programmers expect, it should be
7http://git.sv.gnu.org/gitweb/?p=gzip.git;a=commit;h=b9e94c93df914bd1d9eec9f150b2e4e00702ae7b
8http://git.sv.gnu.org/gitweb/?p=gzip.git;a=commit;h=17822e2cab5e47d73f224a688be8013c34f990f7
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:16 W. Dietz et al.
1if ( moved_once [ regno ])
2{
3 insn count *= 2 ;
4...
5if ( already_moved [ regno ]
6 || ( threshold * savings * m-> lifetime ) >= insn_count
7 || (m-> forces && m-> forces -> done
8 && n_times_used [m-> forces -> regno ] == 1))
9{
10 ...
Listing 5: Overﬂow in loop hoisting cost heuristic in 176.gcc
1# define POWER_OF_2_or_0 (I) \
2((( I) & ( (unsigned)(I) - 1 )) == 0)
3
4int
5integer_ok_for_set ( value )
6 register unsigned value ;
7{
8/* All the " one " bits must be contiguous .
9 * If so , MASK + 1 will be a power of two or zero .*/
10 register unsigned mask = ( value | ( value - 1 ));
11 return ( value && POWER_OF_2_or_0 ( mask + 1 ));}
Listing 6: Correct use of wraparound in bit manipulation in 176.gcc
considered to be a time bomb. A better way to compute INTMAXis using unsigned arithmetic. This
overﬂow is Type 1.
6.3.4. 176.gcc. Listing 5 shows an undeﬁned overﬂow that may cause GCC to generate subop-
timal code even in the case where the signed overﬂow is compiled to a wraparound behavior . The
variable insn count is used as a score in a heuristic that decides whether to move a register outside
of a loop. When it overﬂows, this score inadvertently goes from being very large to being small,
potentially affecting code generation. This overﬂow is Type 3.
6.3.5. 176.gcc. Listing 6 shows code that determines properties about the integer passed in at a
bit level. In doing so, it invokes various arithmetic operations (subtraction, addition, and another
subtraction in the POWER OF2or0macro) that wrap around. These are all on unsigned integers
and are carefully constructed to test the correct bits in the integers, so all of these wraparounds are
benign. This example is a good demonstration of safe bit-level manipulation of integers, a popular
cause of wraparound in programs. This overﬂow is Type 2.
6.3.6. 176.gcc. In Listing 7 we see an allocation wrapper function that allocates a vector of nele-
ments. It starts with 16 bytes and then adds (n 1)8 more to ﬁll out the array, since the beginning
rtvec def struct has room for 1 element by default. This works well enough (ignoring the type
safety violations) for most values of n, but has curious behavior when n=0. Of course, since we are
using a dynamic checker, we know that it is actually called with n=0 during a SPEC benchmarking
run.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:17
1/* Allocate a zeroed rtx vector of N elements */
2rtvec rtvec_alloc ( int n) {
3rtvec rt;
4int i;
5
6rt = ( rtvec ) obstack_alloc ( rtl_obstack ,
7 sizeof ( struct rtvec_def )
8 +(( n - 1) * sizeof ( rtunion )));
9...
10 return rt;
11}
Listing 7: Wraparound in an allocation function in 176.gcc
1void initialize_memory ( void ) {
2SIZET i, j;
3...
4for (i=0, j =1; i < j; i = j, j = (2*j+1) )
5 largest_block = i;
6largest_block &= ALIGNMENT_MASK ;
7// must have room for a nuggie too
8largest_block += -sizeof ( Nuggie );
Listing 8: Computation of SIZE MAX >> 1 in 197.parser
First, consider this code after the sizeof operators are resolved and the promotion rules are ap-
plied: 16 + ((unsigned)(n-1)) * ((unsigned)8) . When n=0, we immediately see the code
casting 1 to unsigned, which evaluates to UINT MAX, or 232 1. The result is then multiplied by
eight, which overﬂows with a result of 232 8. Finally, the addition is evaluated, which produces
the ﬁnal result of 8 after wrapping around again.
Although the overﬂow itself is benign, its consequences are unfortunate. Only eight bytes are
allocated but the rtvec defstructure is 16 bytes. Any attempt to copy it by value will result in a
memory safety error, perhaps corrupting the heap. This is one of the more intricate well-deﬁned but
ultimately harmful overﬂows that we saw; it is Type 4.
6.3.7. 186.crafty. In this benchmark we found some Type 2 wraparounds in evaluate.c used
to reason about a bitmap representation of the chessboard. Additionally, there is a Type 3 statistic
miscalculation that seems like a minor implementation oversight.
6.3.8. 197.parser. This benchmark had a number of overﬂows, including undeﬁned signed over-
ﬂows in a hash table as indicated in Table III. Here we focus on an overﬂow in 197.parser’s custom
memory allocator, shown in Listing 8. This loop computes SIZE MAX, setting largest block to
SIZE MAX >> 1 . Unsigned overﬂow is used to determine when jexceeds the capacity of size t
(note that i = j when the loop terminates). While SIZE MAX was not introduced until C99, it is
unclear why sizeof and a shift were not used instead. This overﬂow is Type 2: well-deﬁned and
benign.
6.3.9. 254.gap. Most of the undeﬁned signed overﬂows in the SPEC 2000 suite are currently
latent: today’s compilers do not break them by exploiting the undeﬁnedness. 254.gap is different:
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:18 W. Dietz et al.
Table IV . Exposing time bombs in SPEC CINT 2006 by making undeﬁned integer operations
return random results. 4indicates the application continues to work; 6indicates that it breaks.
Benchmark ANSI C / C++98 C99 / C++11
400.perlbench 4 4
401.bzip2 4 6
403.gcc 6 6
445.gobmk 4 4
464.h264ref 4 6
433.milc 6 6
482.sphix3 4 6
435.gromacs 4 4
436.cactusADM 4 6
today’s compilers cause it to go into an inﬁnite loop unless two’s complement integer semantics are
forced. From the LLVM developers’ mailing list:9
“This benchmark thinks overﬂow of signed multiplication is well deﬁned. Add the
-fwrapv ﬂag to ensure that the compiler thinks so too.”
We did not investigate the errors in this benchmark due to the complex and obfuscated nature of
the code. However, as shown in Table III, our tool reported many sources of signed wraparound
as expected. The signed overﬂows are Type 1, as they rely on undeﬁned behavior and there is no
mention of -fwrapv in the documentation or source code. Using -fwrapv would make this Type 2,
but non-portable because it would be limited to compilers that support the -fwrapv ﬂag.
6.3.10. Shift Overﬂows. In our examination of SPEC CINT2000 we also checked for shift errors,
ﬁnding a total of 93 locations that overﬂow. Of these, 43 were 1 << 31 which is an idiom for
INTMINthat is legal in ANSI C, and another 38 were left shifts with a negative left operand which
is also legal in ANSI C. For space reasons, and because this behavior is fairly benign (and well-
deﬁned until C99), these are omitted from Table III and not discussed in detail.
Summary of Overﬂows in SPEC CINT2000. As shown in Table III, we found a total of 219 static
sources of overﬂow in eight of the 12 benchmarks. Of these, 148 were using unsigned integers, and
71 were using signed integers (32%). Overall, the most common uses of overﬂow were for hashing
(128), overﬂow check requiring fwrapv (37), bit manipulation (25), and random number generation
(6). Finally, the vast majority of overﬂows found (both unsigned and signed) were not bugs, sug-
gesting occurrence of integer overﬂow by itself is not a good indicator of a security vulnerability or
other functional error.
6.4. Latent Undeﬁned Overﬂows: Harmless, or Time Bombs?
The presence of integer overﬂows that result in undeﬁned behavior in a well-worn collection of
software like SPEC CINT raises the question: Do these overﬂows matter? After all—with the no-
table exception of 254.gap—the benchmarks execute correctly under many different compilers. For
each undeﬁned overﬂow site in a benchmark program that executes correctly, there are two possi-
bilities. First, the values coming out of the undeﬁned operation might not matter. For example, a
value might be used in a debugging printout, it might be used for inconsequential internal book-
keeping, or it might simply never be used. The second possibility is that these overﬂows are “time
bombs”: undeﬁned behaviors whose results matter, but that happen—as an artifact of today’s com-
piler technology—to be compiled in a friendly way by all known compilers.
To ﬁnd the time bombs, we altered IOC’s overﬂow handler to return a random value from any
integer operation whose behavior is undeﬁned by the C or C++ standard. This creates a high prob-
ability that the application will break in an observable way if its execution actually depends on the
results of an undeﬁned operation. Perhaps amusingly, when operating in this mode, IOC is still a
9http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20110131/115969.html
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:19
standards-conforming C or C++ compiler—the standard places no requirements on what happens
to a program following the execution of an operation with undeﬁned behavior.
SPEC CINT is an ideal testbed for this experiment because it has an unambiguous success cri-
terion: for a given test input, a benchmark’s output must match the expected output. The results
appear in Table IV. In summary, the strict shift rules in C99 and C++11 are routinely violated in
SPEC 2006. A compiler that manages to exploit these behaviors would be a conforming implemen-
tation of C or C++, but nevertheless would create SPEC executables that produce incorrect results
because it would expose the latent errors lurking in these codes.
6.5. Integer Overﬂows in the Wild
To understand the prevalence of integer overﬂow behaviors in modern open-source C and C++
applications, we ran IOC on a number of popular applications and libraries. In all cases, we simply
compiled the system using IOC and then ran its existing test suite (i.e., we typed “ make check ” or
similar). For this part of our work, we focused on undeﬁned behaviors as opposed to well-deﬁned
wraparounds. Also, we explicitly avoided looking for bugs based on the stricter C99 and C++11
shift rules; developer awareness of these rules is low and our judgment was that bug reports about
them would be unwelcome.
6.5.1. SQLite. SQLite is a compact DBMS that is extremely widely used: it is embedded in Fire-
fox, Thunderbird, Skype, iOS, Android and other systems. In March 2011 we reported 13 undeﬁned
integer overﬂows in the then-current version. Although none of these undeﬁned behaviors were
believed to be sources of bugs at the time, some of them could have been time bombs. The main
developer promptly ﬁxed all of these overﬂows and IOC found no problems in the next version.
IOC also found a lossy conversion from unsigned int to signed int that resulted in a negative value
being used as an array index. This code was triggered when SQLite attempted to process a corrupted
database ﬁle. The SQLite developer also promptly ﬁxed this issue.10
6.5.2. SafeInt and IntegerLib. SafeInt [LeBlanc 2004] is a C++ class for detecting integer over-
ﬂows; it is used in Firefox and also “used extensively throughout Microsoft, with substantial adop-
tion within Ofﬁce and Windows.” We tested SafeInt and found 43 sites at which undeﬁned overﬂows
occurred, about half of which were negations of INTMIN. The SafeInt developers were aware that
their code performed this operation, but did not feel that it would have negative consequences. How-
ever, newer versions of G++ do in fact exploit the undeﬁnedness of -INT MIN and we found that
when SafeInt was built with this compiler, it returned incorrect results for some inputs. Basically,
the G++ optimizer ﬁnally triggered this time bomb that had been latent in SafeInt for some time.
We informed the developers of this issue and they promptly released a new version of SafeInt that
contains no undeﬁned integer behaviors.
We tested another safe integer library, IntegerLib [CERT 2006], which was developed by CERT.
This library contains 20 sites at which undeﬁned integer overﬂows occur. One of them is shown
in Listing 9; it is supposed to check if arguments lhsandrhscan be added without overﬂowing.
However, at Line 3 the arguments are added without being checked, a bug that results in undeﬁned
behavior. A reasonable workaround for this case would be to cast the arguments to an unsigned type
before adding them.
6.5.3. Other Codes. Six overﬂows in the GNU MPC library that we reported were promptly ﬁxed.
We reported 30 overﬂows in PHP; subsequent testing showed that 20 have been ﬁxed. We reported
18 overﬂows in Firefox, 71 in GCC, 29 in PostgreSQL, 5 in LLVM, and 28 in Python. In all of
these cases developers responded in a positive fashion, and in all cases except Firefox and LLVM
we subsequently received conﬁrmation that at least some of the overﬂows had been ﬁxed. Finally,
we reported nine undeﬁned overﬂows in the GNU Multiple Precision Arithmetic Library, one in
BIND, and one in OpenSSL. We received no response from the developers of these three packages.
10http://www.sqlite.org/src/info/f7c525f5fc
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:20 W. Dietz et al.
1int addsi ( int lhs , int rhs ) {
2errno = 0;
3if (((( lhs+rhs )^ lhs ) &(( lhs+rhs )^ rhs ))
4 >> ( sizeof (int)* CHAR_BIT -1) ) {
5 error_handler (" OVERFLOW ERROR ", NULL , EOVERFLOW );
6 errno = EINVAL ;
7}
8return lhs+ rhs;
9}
Listing 9: An overﬂow in IntegerLib
Out of all the codes we tested, only three were completely free of undeﬁned integer overﬂows,
at least when tested with their own test suites: Kerberos, libpng, and libjpeg. All three of these
packages have had security vulnerabilities in the past; undoubtedly the more recent versions that we
tested have been subjected to intense scrutiny.
6.6. Automated Testing for Overﬂows
Building on our manual investigation of integer overﬂow in common C and C++ applications, we
also conducted an automated investigation of integer overﬂows found in a large number of popular
open-source software packages. Using a list of the most popular Debian packages, we built each
package from source and recorded overﬂows that occurred during this process. We explain the
details of our experiment below, and a summary of our ﬁndings is given in Table V.
6.6.1. Methodology. We built an automated testing system, making use of work by Ledru11to
help coerce packages to use a custom compiler in their build process. We modiﬁed IOC to integrate
well into our build automation, enabling us to capture a list of integer overﬂows that occurred while
running each package with the test suite included with the package. The errors reported are only
from the source for each package, and do not include dependencies which were provided from
binary packages.
Using this system, we built the top 10,000 source packages from Debian as posted to the popcon
website12as of Feb 20th, 2013. This list captures the top source packages used regularly by Debian
users with the popularity-contest package installed. We used packages available in the more recent
“sid” distribution of Debian, and leveraged Debian’s build infrastructure to build each package with
IOC and to run any tests included as part of the Debian packaging. In this way we were able to look
at a large number of packages automatically.
Most of the 10,000 packages we analyzed were not valid for purposes of this experiment: 1560
failed to complete the build process successfully when using our compiler, and of the remaining,
only 3371 contained invocations of code built by our compiler. We determined this by modifying
IOC to add to every translation unit processed a global constructor that writes a log entry when
and if the resulting code is loaded. This log entry includes details of the command line used to
run this software (as read from /proc/self/cmdline ). Using this modiﬁcation, we found many
packages only loaded instrumented code as part of tests used during the configure process. To
only count overﬂows reported in the software itself, we further ﬁltered the set of valid packages
(and the errors considered for each package) by those that load instrumented code outside of the
conﬁgure step, leaving 1172 packages that contained C/C++ code that was successfully built and
had some semblance of being tested.
11http://clang.debian.net/
12http://popcon.debian.org/sourcemax/by_vote
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:21
Table V . Summary of Overﬂows in Top Debian Packages
Overﬂow Type Count % of Overﬂowing % of All
Signed Overﬂow 74 17% 6%
Shift Errors 175 42% 14%
Signed Negation 18 4% 1%
Division Errors 1 0% 0%
Unsigned Overﬂow 356 85% 30%
Unsigned Negation 65 15% 5%
Any Undeﬁned Overﬂow 198 47% 16%
Any Overﬂow 414 100% 35%
Total Packages 1173
6.6.2. Results. A summary of our ﬁndings for these 1172 packages is shown in Table V, and a
more detailed list of packages is available online13or upon request.
We found that 413 (35%) of the packages triggered one of the recognized overﬂows, with 197
(16% overall) involving undeﬁned integer behavior. Unsigned overﬂow was found to be the most
common overﬂow type, representing 85% of the overﬂowing packages and 30% overall. These num-
bers are a lower bound on the true prevalence of overﬂows as they represent only those overﬂows
that occurred during the packaging process and is further limited by the often minor amount of
testing this involves.
Of the packages listed in the top 10,000, we found undeﬁned overﬂows other than shift errors
in 78 packages. Errors found in each are shown in Table VI, broken down by type of undeﬁned
behavior encountered. Division errors did not occur in any of these packages. After shift errors,
the most common type of undeﬁned integer behavior was signed multiplication (64), followed by
signed addition (32), signed negation (17), and signed subtraction (15).
We have not yet ﬁled bugs for these, but plan to do so after more investigation. Undeﬁned behavior
in these packages is particularly important to address due to the potentially high impact should these
errors be the source of bugs or vulnerabilities.
In summary, we conducted a broad automated investigation of integer overﬂows in 1172 of the
top Debian packages and found 35% triggered integer overﬂows and 16% invoked undeﬁned integer
behavior. Moreover, these errors were discovered using only the relatively few test cases included
with the packages during installation , without any serious testing for overﬂows. This highlights the
prevalence of integer overﬂows in real software, as well as how dangerously common undeﬁned
integer behavior is in software used every day by many users.
7. PERFORMANCE EVALUATION
As discussed in the previous section, incorrectly handling integers is a prevalent problem even in
mature applications and it is all too easy for a skilled developer to introduce a dangerous overﬂow
bug. Similar to how tools such as Valgrind are commonly used today to mitigate the prevalence
of often-subtle memory safety errors, we believe tools like IOC are critical to helping developers
understand and mitigate the insidious occurrences of integer overﬂows.
One important measure of such a tool’s utility is the impact it has on performance. To evaluate
the overheads a developer can expect to see when using IOC, in this section we report the overhead
incurred on the SPEC CPU 2006 benchmarks and on two popular server applications, using a variety
of checking conﬁgurations.
For all runs we used IOC as it is most commonly used: recoverable checks, detailed reporting
enabled, deduplication enabled. One result of this is that repeated overﬂows at the same source
location include the costs of marshaling the details of the failed check, calling into the runtime,
using an atomic exchange operation to handle deduplication, and printing details about an error
the ﬁrst time it is encountered. This differs from the experiments done in Section 4.2.1 in that we
are evaluating the performance impact a user might experience, not evaluating alternative check
13http://wdtz.org/files/ioc-debian.log
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:22 W. Dietz et al.
Table VI. Occurrences of Non-Shift Undeﬁned Behavior in Debian Packages
Package SAdd SSub SMul SNeg Package SAdd SSub SMul SNeg
anthy 6 6 libonig 6
apcalc 6 6 libversion-perl 6 6
apr 6 libzip 6
babl 6 lighttpd 6
ccrypt 6 llvm-3.1 6
clamav 6 lsof 6
curl 6 m4 6 6
dpkg 6 matplotlib 6 6
dvipsk-ja 6 mono 6
eina 6 mysql-5.5 6 6 6 6
erlang 6 6 ncbi-blast+ 6
ffcall 6 neko 6
ﬂex-old ocaml 6 6 6 6
ftnchek 6 openafs 6
gap 6 orc 6 6 6
gauche 6 6 pari 6 6
gcc-4.6 6 6 6 6 pcb 6
gcc-4.7 6 6 6 6 pcre3 6 6 6
gcc-avr 6 6 6 pdl 6
gcc-msp430 6 6 perl 6 6 6 6
gcj-4.6 6 6 6 6 pixman 6 6
gcj-4.7 6 6 6 6 postgresql-9.1 6 6 6 6
glib2.0 6 protobuf-c 6 6
gnome-keyring 6 psensor 6
gnuradio 6 python2.6 6 6
gpsd 6 qhull 6
gsl 6 racket 6 6
gst-plugins-base0.10 6 6 ruby1.9.1 6 6
gst-plugins-base1.0 6 6 scm 6
guile-1.6 6 6 sqlite3 6
guile-1.8 6 sqlite 6
guile-2.0 6 texlive-bin 6 6
haveged 6 tla 6 6 6
lcms2 6 6 vavoom 6
libdap 6 vim 6 6
libgda5 6 wireshark 6
libimager-perl 6 zsh-beta 6
libmcrypt 6 zsh 6
liboggz 6
implementations. These experiments were conducted on an otherwise idle 2.5 Ghz i7-2860QM with
16 GB RAM, with all dynamic scaling and multicore features disabled. Reported numbers are the
median of at least three runs; we observed negligible variance within each set of runs.
7.1. Compiler
The compiler used for these experiments was chosen to be similar to that we expect users to have
available. At the time of the experiment not all features from our research prototype had been incor-
porated in the mainstream version of Clang, so for these experiments we used a modiﬁed version of
LLVM/Clang based on r170089 (Dec 13th, 2012). Since then, full support has been added.
7.2. Check conﬁgurations
The ﬁve check conﬁgurations used are as follows:
—Full: All checks supported: signed, unsigned, shift, division, and both implicit and explicit con-
version checks.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:23
Table VII. Performance overhead of IOC on the SPEC CPU 2006 benchmark suite
Benchmark Baseline Full Full-Shift Full-Exp Default Undeﬁned
Name Time (s) Raw O/H Raw O/H Raw O/H Raw O/H Raw O/H
400.perlbench 460:1 657:1 42 :8% 669:7 45:6% 666:4 44 :8% 551:7 19 :9% 490:5 6 :6%
401.bzip2 641:4 926:2 44 :4% 940:4 46:6% 954:0 48 :7% 842:7 31 :4% 749:4 16 :8%
403.gcc 361:7 407:6 12 :7% 406:0 12:2% 402:8 11 :4% 399:1 10 :3% 379:1 4 :8%
429.mcf 326:4 363:1 11 :3% 363:3 11:3% 362:4 11 :0% 361:5 10 :8% 361:3 10 :7%
445.gobmk 574:6 816:0 42 :0% 815:6 41:9% 811:3 41 :2% 734:5 27 :8% 735:7 28 :0%
456.hmmer 821:1 1120 :4 36 :5% 1120 :4 36:4% 1135 :5 38 :3% 1124 :3 36 :9% 1117 :4 36 :1%
458.sjeng 629:8 860:6 36 :7% 859:7 36:5% 861:6 36 :8% 851:9 35 :3% 837:5 33 :0%
462.libquantum 416:6 570:4 36 :9% 602:3 44:6% 570:5 37 :0% 569:0 36 :6% 569:0 36 :6%
464.h264ref 682:9 1515 :9 122 :0% 1163 :0 70:3% 1513 :9 121 :7% 1507 :9 120 :8% 1503 :0 20 :1%
471.omnetpp 320:7 335:9 4 :8% 339:2 5:8% 334:1 4 :2% 334:0 4 :2% 335:1 4 :5%
473.astar 482:5 560:2 16 :1% 572:0 18:5% 559:5 16 :0% 552:4 14 :5% 566:0 17 :3%
483.xalancbmk 271:6 305:3 12 :4% 305:4 12:4% 296:8 9 :3% 292:3 7 :6% 282:4 4 :0%
433.milc 392:7 482:0 22 :7% 481:7 22:7% 481:9 22 :7% 481:1 22 :5% 480:5 22 :3%
444.namd 481:4 555:9 15 :5% 556:1 15:5% 556:0 15 :5% 557:3 15 :8% 555:5 15 :4%
447.dealII 376:6 574:2 52 :5% 584:3 55:2% 570:8 51 :6% 565:8 50 :2% 369:6 1:8%
450.soplex 271:2 318:7 17 :5% 317:7 17:1% 316:8 16 :8% 316:8 16 :8% 317:4 17 :0%
453.povray 211:4 234:7 11 :0% 233:2 10:3% 235:7 11 :5% 233:5 10 :4% 235:7 11 :5%
470.lbm 388:2 439:7 13 :3% 439:8 13:3% 440:8 13 :6% 439:8 13 :3% 440:7 13 :5%
482.sphinx3 691:7 928:9 34 :3% 927:6 34:1% 826:4 19 :5% 826:4 19 :5% 828:4 19 :8%
Geometric Mean 28:8% 27:8% 28:0% 24:6% 19:9%
—Full-Shift : All checks other than shift checking, as shifts are frequently misused which can lead
to high overheads or a large number of false positives. In conjunction with Full, this also helps
demonstrate the cost of checking these shifts.
—Full-Explicit : All check types other than explicit conversions. These are often less interesting
because they are well-understood due to straightforward semantics and clear visibility at the
source level.
—Default : Signed, unsigned, shift, and division checks. This conﬁguration is important as it is the
default set of checks enabled when integer checking is enabled on a recent version of Clang.
Support for conversion checks has not yet been added at the time of writing, and the default
checks may change to include value-losing implicit conversions in the future.
—Undeﬁned : Only checks for undeﬁned integer behavior: signed, shift, and division. Developers
are generally most interested in seeing these kinds of errors reported.
7.3. SPEC CPU2006
The SPEC CPU benchmarks are CPU-bound, arithmetic-intensive programs, which means that they
are likely to incur higher checking overheads than do many other common applications that are
network-, disk- or UI-intensive. We instrumented the C/C++ benchmarks of SPEC CPU2006 with
all ﬁve conﬁgurations of IOC, as well as a baseline conﬁguration. Our results are shown in Fig. VII.
The measurements used the ref inputs, as required for ofﬁcial performance measurements with
SPEC. Each reported number is the median of at least three runs; with a relative standard deviation
(i.e., the coefﬁcient of variation) less than 0.08%. Depending on the checks enabled, the geometric
mean overhead was between 20.0% (undeﬁned only) and 28.8% (all checks enabled).
Comparing the Full and Default conﬁgurations, we observed that disabling all conversion checks
improved performance by 4.2%. Removing the explicit conversion checks (Full vs. Full-Explicit)
resulted in only 0.8% improvement. Disabling shift checks (Full vs. Full-Shift) only improved per-
formance overall by 1%, but it had a signiﬁcant impact on 464.h264ref because this program fre-
quently misuses shift operations. Enabling only the undeﬁned checks incurs an average overhead
of less than 20%, with no benchmark incurring over 37% overhead. 464.h264ref saw a signiﬁcant
improvement here as well due to its use of unsigned overﬂow in tight loops. Overall, other than
464.264ref, all overheads were less than 60%.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:24 W. Dietz et al.
Table VIII. Mean response times of Apache’s httpd under different IOC conﬁgurations
Baseline Full Default Undeﬁned
Req. Size Sec/Req Raw O/H Raw O/H Raw O/H
1 kB 0:780 0:807 3 :461% 0:780 0:077% 0:778 0:256%
10 kB 2:528 2:491 1:479% 2:515 0:514% 2:520 0:340%
100 kB 22:034 22:035 0 :003% 22:035 0 :002% 22:034 0:001%
1 MB 224:633 224:648 0 :007% 224:647 0 :006% 224:653 0 :009%
10 MB 2252 :290 2253 :480 0 :052% 2253 :170 0 :039% 2252 :890 0 :026%
Table IX. Performance overhead of ﬁle copy using instrumented OpenSSH server
File Size Baseline Full Full-Shift Full-Explicit Default Undeﬁned
100 MB 3:09 3:23 4 :54% 3:22 4 :34% 3:22 4 :24% 3:12 1 :00% 3:10 0 :26%
1 GB 20:73 22:06 6 :40% 21:97 5 :93% 22:00 6 :13% 21:02 1 :40% 20:63 0:50%
10 GB 189:60 204:00 7 :59% 203:10 7 :12% 202:30 6 :69% 190:60 0 :53% 190:30 0 :37%
7.4. Server Applications
In addition to the integer-intensive scenario presented by CINT2006, we evaluated the performance
impact of IOC on two popular server applications: Apache httpd and OpenSSH’s sshd. For httpd, we
measured average response time while under load for various ﬁle sizes using the three main check-
ing conﬁgurations. Response times were measured over a gigabit link using the abtool shipped with
httpd, using 25 concurrent connections making as many requests as possible for 200 seconds. The
experiment was repeated ﬁve times for each ﬁle size and conﬁguration, with the mean values re-
ported in Fig. VIII. The coefﬁcients-of-variation for the 1 KB experiments were 2.5%; others were
less than 0.12%. Experiments for ﬁle sizes over 100 KB were limited by the network, hence the
lack of change across check conﬁgurations for these. However, even on the smaller ﬁle sizes the
check conﬁgurations had only a minor impact, with the performance differences comparable to the
standard deviation for the 1KB and 10KB runs.
With sshd, we measured the performance impact by copying ﬁles from an instrumented server
across a gigabit network using scp. Fig. IX shows the median of ﬁve runs for each conﬁguration and
ﬁle size. Coefﬁcients-of-variation for the 100 M experiments were less than 0.8%; the others were
less than 1.6%. Under all conﬁgurations the server was CPU-bound (ﬁles were likely cached), while
the client was not. Here the instrumentation slowed the transfer rates at most by 8%. No checks
included in the “Default” or “Undeﬁned” conﬁgurations triggered dynamically while conducting
our scp experiments.
7.5. Performance Summary
We observed minimal performance impact on server applications regardless of the check conﬁgura-
tion. Even on the CPU-intensive SPEC benchmarks, average overheads were relatively low (20.0%
to 28.8%), making IOC suitable for use in nightly testing or as a debugging aid. We expect these
overheads can be reduced more by further improving LLVM’s handling of overﬂow intrinsics in its
optimization passes and by removing or simplifying checks through use of a range analysis. Re-
gardless, we believe the overheads are already sufﬁciently low to make IOC usable for most C/C++
software today.
8. PRIOR WORK
Integer overﬂows have a long and interesting history. The popular Pac-Man game, released in 1980,
suffered from two known integer overﬂows that generate surprising, user-visible artifacts [Hodges
2008; Wikipedia 2011b]. More recently, as buffer overﬂows in C and C++ programs have been
slowly brought under control, integer overﬂows have emerged as an important root cause of ex-
ploitable vulnerabilities in Internet-facing programs [Christey et al. 2011; Christey and Martin
2007].
Solutions to integer overﬂow are almost as old as the problem. For example, the IBM 702
provided a hardware-based implementation of variable-precision integers more than 50 years
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:25
ago [Wikipedia 2011a]. MacLisp, in the 1960s, provided the ﬁrst widely-available software im-
plementation of arbitrary precision arithmetic. Even so, for a variety of reasons, today’s low-level
programming languages eschew well-known integer overﬂow solutions, forcing programmers to
deal with modulo integers and undeﬁned behaviors.
Although there has been extensive work, especially during the last decade or so, on tools and
libraries for mitigating integer-based security vulnerabilities, none of these tools have been used
to understand the patterns of integer numerical overﬂows in real-world programs and benchmarks ,
which is the main focus of our work. Instead, those efforts have focused primarily on developing new
tools and libraries and evaluating their efﬁcacy. In particular, none of these projects has speciﬁcally
attempted to examine the prevalence of undeﬁned behaviors, although there is data in some of
these papers about speciﬁc bugs. Moreover, none of these projects has attempted to examine the
prevalence of intentional wraparound behaviors, or the idioms for which they are used, except the
limited data in the paper on RICH.
The RICH paper [Brumley et al. 2007] presents two relevant pieces of data. First, it classiﬁes
integer numerical errors from MITRE’s CVE database [MITRE Corporation 2013] as overﬂow,
signedness, and truncation errors. This classiﬁcation does not show how prevalent numerical errors
are across programs because the survey only looks at cases where overﬂows have already been
reported, not a general collection of programs. Second, they brieﬂy discuss some benign overﬂow
behaviors that are ﬂagged as errors by their tool, and discuss for what algorithms those overﬂows are
used. That study provides limited data about the prevalence and patterns of intentional uses because
their goal was different—to evaluate false positives from RICH. We study the empirical questions
systematically and in more detail.
Other prior research on mitigating integer-based security vulnerabilities is more tangential to our
work. We brieﬂy discuss that work to illustrate the solutions available. The tools vary from static
analysis and dynamic instrumentation to libraries with various strategies to mitigate the problem.
RICH is a compiler-based tool that instruments programs to detect signed and unsigned overﬂows
in addition to lossy truncations and sign-conversions [Brumley et al. 2007]. BRICK [Chen et al.
2009] detects integer overﬂows in compiled executables using a modiﬁed Valgrind [Nethercote
and Seward 2003]. The runtime performance is poor (50X slowdown) and the lack of C-level type
information in executable code causes both false positives and false negatives. SmartFuzz [Molnar
et al. 2009] is also based on Valgrind, but goes further by using whitebox testing to generate inputs
leading to good test coverage. IntScope [Wang et al. 2009] is a static binary analysis tool for integer
vulnerabilities.
The As-if Inﬁnitely Ranged (AIR) integer model [Dannenberg et al. 2010] is an ambitious so-
lution that is intended to be used in deployed software. It simply provides well-deﬁned semantics
for most of C/C++’s integer-related undeﬁned behaviors. AIR provides a strong invariant—every
integer operation either produces the mathematically correct result or else traps—while being care-
fully designed to minimally constrain the optimizer. An alternative online solution is provided by
libraries such as SafeInt [LeBlanc 2004] and IntegerLib [CERT 2006], where checked operations
must be explicitly invoked and overﬂows explicitly dealt with. SafeInt, however, is quite easy to use
because it exploits C++’s exceptions and operator overloading.
9. CONCLUSION
We have conducted an empirical study of the prevalence and patterns of occurrence of integer over-
ﬂows in C and C++ programs, both well-deﬁned and undeﬁned, and both intentional and inadver-
tent. We ﬁnd that intentional uses of wraparound behaviors are much more common than is widely
believed, e.g., over 200 distinct locations in SPEC CINT2000 alone. We identify a wide range of
algorithms for which programmers use wraparound intentionally.
Unfortunately, we observe that some of the intentional uses are written with signed instead of
unsigned integer types, triggering undeﬁned behaviors in C and C++. Compilers are free to generate
arbitrary results for such code. In fact, we identiﬁed a number of lurking “time bombs” that happen
to work correctly with some of today’s compilers but may fail with future compiler changes, such
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .A:26 W. Dietz et al.
as more aggressive optimizations. Finally, we identiﬁed a number of previously unknown numerical
bugs in widely used open source software packages (and even in safe integer libraries!), many of
which have since been ﬁxed or acknowledged as bugs by the original developers. Even among
mature programs, only a small fraction are free of integer numerical errors.
Overall, based on the locations and frequency of numerical errors, we conclude that there is
widespread misunderstanding of the (highly complex) language rules for integer operations in
C/C++, even among expert programmers. Our results also imply that tools for detecting integer nu-
merical errors need to distinguish intentional from unintentional uses of wraparound operations—a
challenging task—in order to minimize false alarms.
Acknowledgments
We thank Tennessee Carmel-Veilleux, Danny Dig, Ganesh Gopalakrishnan, Alex Groce, Mary Hall,
Derek Jones, Swarup Sahoo, and the ICSE 2012 reviewers for their insightful comments on drafts
of this paper. This research was supported, in part, by an award from DARPA’s Computer Science
Study Group, and by the Air Force Research Laboratory (AFRL).
REFERENCES
BRUMLEY , D., C HIUEH , T., J OHNSON , R., L IN, H., AND SONG , D. 2007. RICH: Automatically protecting against integer-
based vulnerabilities. In Proc. of the Symp. on Network and Distributed Systems Security (NDSS) . San Diego, CA,
USA.
CERT. 2006. IntegerLib, a secure integer library. http://www.cert.org/secure-coding/IntegerLib.zip .
CHEN, P., W ANG , Y., X IN, Z., M AO, B., AND XIE, L. 2009. Brick: A binary tool for run-time detecting and locating
integer-based vulnerability. In Proc. of the 4th Intl. Conf. on Availability, Reliability and Security . Fukuoka, Japan,
208–215.
CHRISTEY , S. AND MARTIN , R. A. 2007. Vulnerability type distributions in CVE. Tech. report, MITRE Corporation. May.
http://cwe.mitre.org/documents/vuln-trends.html .
CHRISTEY , S., M ARTIN , R. A., B ROWN , M., P ALLER , A., AND KIRBY , D. 2011. 2011 CWE/SANS Top 25 Most Danger-
ous Software Errors. Tech. report, MITRE Corporation. September. http://cwe.mitre.org/top25 .
CLANG . 2011. clang: a C language family frontend for LLVM. http://clang.llvm.org/ ; accessed 21-Sept-2011.
DANNENBERG , R. B., D ORMANN , W., K EATON , D., S EACORD , R. C., S VOBODA , D., V OLKOVITSKY , A., W ILSON ,
T.,AND PLUM , T. 2010. As-if inﬁnitely ranged integer model. In Proc. of the 21st Intl. Symp. on Software Reliability
Engineering (ISSRE 2010) . San Jose, CA, USA, 91–100.
DIETZ , W., L I, P., R EGEHR , J., AND ADVE, V. 2012. Understanding integer overﬂow in c/c++. In Proceedings of the 2012
International Conference on Software Engineering . ICSE 2012. IEEE Press, Piscataway, NJ, USA, 760–770.
HODGES , D. 2008. Why do Pinky and Inky have different behaviors when Pac-Man is facing up? http://donhodges.
com/pacman_pinky_explanation.htm ; accessed 21-Sept-2011.
INTEL . 2013. Intel VTune Ampliﬁer XE 2013. http://software.intel.com/en-us/intel-vtune-amplifier-xe .
LATTNER , C. AND ADVE, V. 2004. LLVM: A compilation framework for lifelong program analysis & transformation. In
Proc. of the 2004 Intl. Symp. on Code Generation and Optimization (CGO’04) . Palo Alto, CA, USA.
LEBLANC , D. 2004. Integer handling with the C++ SafeInt class. http://msdn.microsoft.com/library/default.
asp?url=/library/en-us/dncode/html/secure01142004.asp .
LEBLANC , D. 2011. Author’s blog: Integer handling with the C++ SafeInt class. http://safeint.codeplex.com/ .
LEVESON , N. G. AND TURNER , C. S. 1993. An investigation of the Therac-25 accidents. Computer 26, 7, 18–41.
MITRE C ORPORATION . 2002. CVE-2002-0639: Integer overﬂow in sshd in OpenSSH. http://cve.mitre.org/cgi-
bin/cvename.cgi?name=CVE-2002-0639.
MITRE C ORPORATION . 2010. CVE-2010-2753: Integer overﬂow in Mozilla Firefox, Thunderbird and SeaMonkey.
http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2753.
MITRE C ORPORATION . 2013. Common Vulnerability and Exposures. http://cve.mitre.org/ .
MOLNAR , D., L I, X. C., AND WAGNER , D. A. 2009. Dynamic test generation to ﬁnd integer bugs in x86 binary Linux
programs. In Proc. of the 18th USENIX Security Symposium . 67–82.
NETHERCOTE , N. AND SEWARD , J. 2003. Valgrind: A program supervision framework. In Proc. of the 3rd Workshop on
Runtime Veriﬁcation . Boulder, CO.
WANG , T., W EI, T., L IN, Z., AND ZOU, W. 2009. IntScope: Automatically detecting integer overﬂow vulnerability in x86
binary using symbolic execution. In Proc. of the 16th Network and Distributed System Security Symp. San Diego, CA,
USA.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .Understanding Integer Overﬂow in C/C++ A:27
WIKIPEDIA . 2011a. Arbitrary-precision arithmetic. http://en.wikipedia.org/wiki/Arbitrary-precision_
arithmetic ; accessed 21-Sept-2011.
WIKIPEDIA . 2011b. Pac-Man. http://en.wikipedia.org/w/index.php?title=Pac-Man&oldid=450692749#
Split-screen ; accessed 21-Sept-2011.
ACM Transactions on Software Engineering and Methodology, V ol. V , No. N, Article A, Pub. date: January YYYY .