Automated Veriﬁcation of Pa ttern-Based Interaction
Invariants in Ajax Applications
Yuta Maezawa
The University of Tokyo
Tokyo, Japan
maezawa@nii.ac.jpHironori Washizaki
Waseda University
Tokyo, Japan
washizaki@waseda.jpYoshinori Tanabe
National Institute of Informatics
Tokyo, Japan
y-tanabe@nii.ac.jpShinichi Honiden
The University of Tokyo
National Institute of Informatics
Tokyo, Japan
honiden@nii.ac.jp
Abstract —When developing asynchronous JavaScript and
XML (Ajax) applications, developers implement Ajax designpatterns for increasing the usability of the applications. However,unpredictable contexts of running applications might concealfaults that will break the design patterns, which decreasesusability. We propose a support tool called JSVeriﬁer that auto-matically veriﬁes interaction invariants; the applications handletheir interactions in invariant occurrence and order. We alsopresent a selective set of interaction invariants derived from Ajaxdesign patterns, as input. If the application behavior breaks thedesign patterns, JSVeriﬁer automatically outputs faulty executionpaths for debugging. The results of our case studies show thatJSVeriﬁer can verify the interaction invariants in a feasibleamount of time, and we conclude that it can help developersincrease the usability of Ajax applications.
Index Terms —Ajax; Reverse Engineering; Model Checking;
Design Pattern;
I. I NTRODUCTION
Asynchronous JavaScript and XML (Ajax) applications
have become essential platforms for daily life [1] and are an
integral part of Google services, Facebook, and Twitter. Asyn-
chronous technologies, such as Ajax, make Web applications
responsive [2] and are credited with the 500% increase in Webusers compared to a decade ago [3].
A key factor in attracting Web users is usability of Web
applications [4]; the ease of using Websites corresponds towell designed navigation [5]. When developing Ajax appli-
cations, developers can implement Ajax design patterns [6]
for increasing the usability of the applications. Although
developers intend to correctly implement the design patterns,
unpredictable contexts while running applications might con-ceal faults that will break the d esign patterns. We claim
that such faults decrease usability; therefore, a technique for
verifying whether the applica tion correctly runs according to
the implemented design patterns is required.
Several studies have been conducted on state-based analysis
and testing of Ajax applications. Some have succeeded inleveraging dynamic analysis t echniques because Ajax appli-
cations can interactively mani pulate an interface by using the
document object model (DOM)
1[7], [8], [9], [10]. Although
these dynamic techniques can leverage actual DOMs as the
states, DOM-based testing does not help verify the correctness
1http://www.w3.org/DOM/in execution paths that are not part of the scenarios and envi-
ronments given by the developers. As a static approach, Guha
et al. presented a technique for extracting the behavior relevantto asynchronous communications using a control-ﬂow analysis
[11]. This technique can be used for detecting runtime server
requests that do not match the extracted behavior; however,it is presumed that developers can correctly understand and
implement this behavior.
Since developers might incorrectly implement their require-
ments such as Ajax design patterns ( Implementing ), we
previously presented a method for extracting state machinesfocusing on interactions with applications in order to sup-
port program understanding [12]. We assume the interactions
as triggers that can change the states of the applications,as described in Section III. However, developers needed to
manually determine whether th e extracted state machines
satisfy interaction invariants, which does not enable them to
exhaustively ﬁnd faulty execution paths.
For this study, we propose a support tool called JSVeriﬁer ,
which automatically veriﬁes interaction invariants in Ajax
applications using the Spin
2model checker. The veriﬁcation
method of JSVeriﬁer is mainly divided into the following threesteps:
Step1: JSVeriﬁer translates the extracted state machines
into an application model that Spin can interpret. To simulatethe application behavior, JSVeri ﬁer also generates an interac-
tion model ( Extractor ).Step2: When developing appli-
cations, developers can store information about implemented
Ajax design patterns ( IADP information ) into a reposi-
tory. By obtaining the information via the repository, JSVeriﬁerdetermines interaction invariants based on Ajax design pat-
terns and property patterns and generates veriﬁcation formulas
(Formulator ).Step3: JSVeriﬁer runs Spin for verifying
the correctness of the application behavior with the invariants.
If the application behavior does not satisfy the invariants,
JSVeriﬁer suggests faulty execution paths ( Verifier ). We
assume that developers can debug the applications using these
suggestions ( Debugging ). Figure 1 gives an overview of this
veriﬁcation method.
We address the following research questions.
2http://spinroot.com/978-1-4799-0215-6/13/$31.00 c2013 IEEE ASE 2013, Palo Alto, USA158
ExtractorVerifier
… 
… … … 
… … … 
… … … 
… … … … … … … … … … … … … … Implementing 
Debugging State machines 
Faulty execution paths 
Faulty source code  Debugged source code JSVerifier  
can support Ajax design patterns 
Formulator 
Interaction invariants Repository IADP information 
Fig. 1. Overview of veriﬁcation method used in JSVeriﬁer
RQ1 Can JSVeriﬁer automatically verify interaction in-
variants with given IADP information?
RQ2 Can JSVeriﬁer output veriﬁcation results in a feasible
time?
Our contributions are as follows:
An automated veriﬁcation of interaction invariants in
Ajax applications.
A selective set of interaction invariants based on Ajaxdesign patterns and property patterns.
Implementation of the veriﬁcation method of JSVeriﬁer.
An evaluation experiment with case studies that showsthat JSVeriﬁer can verify the invariants in a feasible
amount of time.
Actual faults that JSVeriﬁer can expose in real-world Ajax
applications. Some of the faults are difﬁcult to be exposed
using testing techniques.
The remainder of this paper is organized as follows. First,
we provide background on Ajax application development and
give a brief example to explain our work in Section II. In
Section III, we describe our proposed tool, JSVeriﬁer. We then
discuss our evaluation in Section IV and discuss related work
in Section V. Finally, we conclude our work in Section VI.
II. B ACKGROUND
In this section, we note how developers develop Ajax
applications focusing on interactions and increase usability of
the applications based on Ajax design patterns. We then give a
brief example that illustrates an issue of interaction invariantsin Ajax applications.
A. Ajax Applications Developments
Asynchronous JavaScript and XML (Ajax) are breed ap-
proaches in Web applications [1 3]. Our research target is the
interactions with Ajax applications as shown in Figure 2. By
leveraging an Ajax engine on the client side, the applications
can asynchronously receive necessary data from servers and
partially update a Web page without page transitions, so that
User
InteractionsUser
ClientWeb pageRequests
ServerInteractions
Self
Interactions
Research
targetServer side
scripts
Web page
dataDynamically
generate
according to
requestsServer
S
S
Fig. 2. Interactions with Ajax applications
it can continuously process user requests on the client side.Thus, this approach makes Web applications responsive [2].
When developing and maintaining rich Internet applications
containing Ajax applications, interactions with the applicationsneed to be considered in order to improve user experience
[14]. Since the applications are primarily aimed at providing
rich user experience [15], developers are concerned with the
following.
Interactions that the application can handle. We argue thatinteractions can be classiﬁed into user, server, and self
interactions corresponding to nondeterministic elements
such as user events, asynchronous server responses, and
timeouts, as shown in Figure 2.
Application behavior when handling interactions.
Developers can also control whether the application will
handle certain interactions. For determining the application
behavior, developers need to recognize the effects of enablingand disabling these interacti ons [11]. Hence, we can argue that
the following is also a concern for developers.
Application behavior when enabling and disabling inter-
actions.
Unfortunately, developers have difﬁculties in correctly im-
plementing interactions while considering all possible exe-
cution paths because an interac tion-based behavior depends
on unpredictable contexts at runtime. Despite their greatestefforts, developers may miss certain paths to be executed,
which can result in unexpected behavior. Therefore, a support
tool is helpful to extract st ate machines from applications
and to determine whether the extracted model contains any
unexpected behavior.
B. Ajax Design Patterns
The success of Ajax applications lies in their asynchronous
technologies in e-commerce, social networking services, and
enterprise systems [16]. These applications can provide rich
user experience derived from their asynchronous nature. Toattract an increasing number of Web users, Web usability is a
key factor in Web applications [4]. Fortunately, Ajax design
patterns [6] contain seventy comprehensive ﬁndings in termof usability by surveying many real-world Ajax applications.
Thus, developers can leverage the Ajax design patterns for
increasing usability of applications. For this study, we leverage
the ﬁndings relevant to an interaction-based behavior in Ajax
applications.1591<html><head>
2<script type= ”text / javascript”
3 src =”./ js / prototype . js” ></script >
4<script type= ”text / javascript” ><!−−//
5 window . onload = setEventHandler ;
6function setEventHandler () {
7$ ( ” r e g
 type ”) . onchange = calcPrice ;
8$ ( ” r e g
 attendee ”) . onchange = calcPrice ;
9$ ( ” r e g
 payment ”) . onchange = calcPrice ;
10 $ ( ” r e g
 addcart ”) . onclick = addCart ; };
11function calcPrice () {
12 / ∗calculate and display total price ∗/};
13function addCart () {
14 /∗ disableAddCard () ; // proper control ∗/
15 if(i s V a l i d I n p u t( )) {
1 6 reqRunTrans () ;
17 }else {
1 8 alert (” Invalid user inputs ”) ;
19 /∗ enableAddCart () ; // proper control ∗/}};
20function reqRunTrans () {
21 new Ajax . Request (” runTrans .php” , {
2 2 method: ”G E T”, parameters : getParams () ,
23 onSuccess : su cceeded });};
24function enableAddCart () {
2 5 $(” addcart ”) . disabled = false ;};
26function disableAddCart () {
2 7 $(” addcart ”) . disabled = true ;};
28function succeeded () {
29 d i s a b l e A l l ( ) ;
30 jumpToConfirm () ; };
31 //−−></script >
32</head><body>...
33 P r i c e : $ <span id=”price” >500</span>
34<div>Type</div>
35<select id= ”reg
 type” >
36<option id =” a l l ” value =”350” >All days </option >
37<option id =” cnf ” value =”250” >Conference </option >
38<option id =”wsp” value =”100” >Workshop </option >
39</select >
40<div>Attendee ... </ select >
41<div>Payment... </ select >
42<span>Quantity : </span>
43<input id=”quantity” type=”text” value=”1” / >
44<input id=”addcart ”
4 5 type=”submit” value=”Ad d to Cart” / >
46</body></html>
Fig. 3. Source code of our brief example: Shopping Website.
Duplicate 
orderUser interaction 
prohibited during transaction
(i) Page load
(ii) Option select
(iii) Add to cart (iv) Disabled add to cart
Fig. 4. Screenshots of our brief example shown in Figure 3
However, unpredictable contexts of running applications
might conceal faults that will break the design patterns.
Although developers test whether the application expectedlyruns according to the design patterns, testing techniques do
not help verify the correctness of all execution paths. For
example, the User Action design pattern suggests that
applications should register user events at page load; we
call such property as a “ user event registration ”i n
Section III-C. This is because executing user event callback
functions before displaying Web page elements might cause
erroneous behavior. The current implementation immediatelycompletes the loading of all page elements; however, iterative
and incremental development might lengthen the loading time,
causing unexpected behavior. Since such software evolution
over time might break design patterns [17], we address a
challenging issue of automatically verifying whether Ajax ap-plication behavior contains fau lts that are currently concealed
but will be exposed.
C. Brief Example
We give the source code and screenshots of an Ajax
application as a brief example
3in Figures 3 and 4. This is a
3Running examples are available from http://goo.gl/JE9Vdtypical Ajax application for shopping on a website where users
(i, ii) select item options and (iii, iv) add the item to their cart.
This application has a fault th at may cause duplicate orders
on e-commerce websites such as Amazon4and eBay5.W e
illustrate how developers implement and test this application
using Ajax design patterns.
First, developers implement the option selection function-
ality based on the user event registration property. (i) Page
load: Anonload event is ﬁrst evaluated when users visit the
Website (line 5). Then, the application calls back a function
setEventHandler (lines 6-10). (ii) Option select: When
users select options of an item, the browser evaluates an
onchange event corresponding to the option widget (lines
7-9). In the interface, users can see the total price according
to their selections which is calculated at a callback function
calcPrice of the events (lines 11-12). Then, developers
visit the Website and select the options for testing whether
this functionality satisﬁes the property. Since the application
displays the correct price, this test is successful.
Next, developers iteratively implement the item addition
functionality. To avoid the dupli cate order problem, developers
4Amazon Help: http://goo.gl/Mkbfc
5eBay Answer Center: http://goo.gl/WVXqO160require the application of handling the add-to-cart click only
once. The User Action design pattern also suggests that
Ajax applications can prevent multiple calls of speciﬁc userevent handlers; we call such property as a “ user event
handler singleton ” in Section III-C. (iii) Add to cart:
Users can also add the item to their cart by clicking a submit
button labeled Add to Cart . When the button is clicked, an
onclick event occurs (line 10) and the application processes
anaddCart function (lines 13-19). If the selections are valid
(line 15), the application sends an asynchronous request to
run a transaction for taking inventories on the server side(lines 16 and 20-23). Otherwise, an alert box appears for
users to give valid inputs (lines 17-18). Finally, the application
asynchronously receives a server response (lines 23 and 30-
32) and jumps to a conﬁrmation page (line 32). To test
this property, developers click the button with valid inputsand see that the application cannot handle the click due to
the immediate jump. Since a previous test case also passed,
developers ﬁnally conﬁrm that the application expectedly runsaccording to two properties derived from the User Action
design pattern.
However, the duplicate order problem arises when users
unexpectedly double-click the add-to-cart button. As we men-
tioned in the previous section, it is difﬁcult to expose this du-
plicate order problem using a testing technique that leveragesexecution results. This is because the current implementation
does not execute such faulty paths in a reliable network and
quickly processes the lightweight transaction. Otherwise, the
duplicate order problem will be revealed. (iv) Disabled add to
cart: To avoid the duplicate order problem, developers need
to implement the appropriate enabling and disabling of the
click so that users cannot interact with the button while the
transaction is running (lines 14 and 19).
In summary, an interaction-based behavior in Ajax applica-
tions is important but difﬁcult for developers to ﬁgure out
due to unpredictable contexts. Hence, if developers intendto implement and test Ajax design patterns for increasing
usability, unpredictable contexts might conceal faults, result-
ing in an erroneous behavior. Therefore, we investigated theautomated veriﬁcation of inter action invariants based on Ajax
design patterns in Ajax applications for revealing faults that
are currently concealed but will be exposed.
III. A
PPROACH AND IMPLEMENTATION
JSVeriﬁer automatically 1) extracts state machines from
Ajax applications, as shown in Figure 5, and 2) veriﬁes the
correctness and suggests faulty execution paths of interaction
invariants, as shown in Figure 6. We present a selective set of
interaction invariants based on Ajax design patterns.
A. Extracting State Machines from Ajax Applications
JSVeriﬁer extracts interaction-based state machines from
Ajax applications using a rule-b ased static analysis technique.
To show that JSVeriﬁer deals with nondeterministic behavior
of Ajax applications, we explain how it works, although this
technique has been proposed in our previous study [12].Extracting state machines 
Rule-based extending call graph 
Abstracting extended call graph Distinguishing 
rulesURL
Extended 
call graph 
State machines (E1)
(E2)
Refining relationships among interactions En/disabling 
statements 
End(E3)
Fig. 5. Flowchart for extracting state machines
Verifying interaction invariants 
Translating into Promela model 
Generating LTL formulas 
EndVerifying correctness Suggesting faulty exec. path Extracted state 
machines 
Information 
via repository Application and 
interaction models 
(Promela) 
Clue to 
debugging (V1)
(V2)
(V3)
Satisfy Not satisfy Running Spin 
Fig. 6. Flowchart for verifying interaction invariants
setEventHandler init
addCart
reqRunTrans 
Ajax.Request 
succeeded 
disableAll onload
onclick
[isValidInput()] 
onSuccess (i)
(iii)
(ii)
(a) Part of extended call graph (b) Abstracted call graph (c) Refined interaction relationships setEventHandler init
reqRunTrans 
succeeded onload
onclick
[isValidInput()] 
onSuccess (iv)addCartsetEventHandler init
reqRunTrans 
succeeded onload
onclick
[isValidInput()] 
onSuccess addCart
(v)onclick
(vi)
Fig. 7. Partial example of extending, ab stracting, and reﬁning call graph of
our brief example in Figure 3
We assume the interactions shown in Figure 2 act as triggers
that can change the states of applications. The interaction
that we focus on in this study corresponds to a function callin response to an event ﬁring. Hence, states and transitions
in the extracted state machines represent function calls and
the relationships between them. Our analysis technique for
extracting state machines consists of three steps, as shown in
Figure 5 (E1, E2, and E3).
First, developers input a URL of an Ajax application and
rules for distinguishing interaction-related code fragments
(distinguishing rules) into JSVeriﬁer, and then it analyzes
the source code of the application. Since HTML, CSS, and
JavaScript parsers cannot distinguish event attributes, callbackobjects, event handling functions, and control attributes (for
example, onchange ,onSuccess ,Ajax.Request ,a n d
disabled ) from other syntax elements, developers need to
deﬁne these elements relevant to the interactions (interaction
elements) in the distinguishing rules. However, state machines
constructed by combining the interactions might contain many
impossible execution paths, resulting in a state space explo-
sion.161TABLE I
DEFINITIONS OF ELEMENTS IN OUR PROMELA MODEL
Element of Promela model
 Deﬁnition
active proctype App
 An application process that expresses behavior of an Ajax application
active proctype Interaction
 An interaction process that interacts with App
App_state
 A state in which an application process is
App_event
 An event that an application process handles
Int_event
 An event that an interaction process randomly occurs
App_ch
 A channel for passing messages of interactions be tween application and interaction processes
flg_exit
 An application process that is set to true when it transitions to an exit state
goto_ App
 state
 A goto label expressing an App
 state of an application
d_step
 An atomic process for simultaneously setting the state of an application and making events empty
Rule-based extending call graph (E1): To obtain possible
relationships among the interactions (interaction relationships),JSVeriﬁer leverages a call graph that represents caller-callee
relationships. The call graph does not contain the interaction
relationships (e.g., event ﬁring and callback), but JSVeriﬁer
extends the call graph in terms of interactions. By parsing
the source code and ﬁnding event attributes and callbackobjects, JSVeriﬁer creates relationships between invoked func-
tions ( setEventHandler ) and their corresponding call-
back functions ( addCart ) and assigns the corresponding
event types ( onclick ) to the relationships (lines 6 and
10 in Figure 3 and (i) in Figure 7). In cases of event
handling functions, JSVeriﬁer makes connections from the
functions ( Ajax.Request ) to the corresponding callback
functions ( succeeded ) with the corresponding event types
(onSuccess ) (lines 21 and 23 in Figure 3 and (ii) in Figure
7). Thus, by statically analyzing the source code with the
distinguishing rules, it can extend the call graph to containinteraction relationships.
Abstracting extended call graph (E2): Since the extended
call graph might have many relationships irrelevant to the
interactions, JSVeriﬁer then abstracts the extended call graph
focusing on the interaction elements. For example, our briefexample runs from reqRunTrans toAjax.Request with-
out any interactions ((iii) in Figure 7). In this case, our tool
abstracts this caller-callee relationship into the corresponding
invoked function of reqRunTrans ((iv) in Figure 7). Thus, it
can obtain possible interaction relationships from the extendedcall graph.
Reﬁning relationships among interactions (E3): Ad-
ditionally, developers can implement enabling and disabling
of interactions in Ajax applications. For example, in Figure
3, the add-to-cart button is enabled on line 27 and disabledon line 29. These statements in the application that set
parameters on control attributes of DOM elements (en/dis-
abling statements) can be distinguished with the distinguishingrules, similar to the interaction elements. By analyzing the
en/disabling statements, JSVeriﬁer adds possible interaction
relationships and removes impossible ones. For example, in
Figure 7(c), JSVeriﬁer adds an onclick relationship from
reqRunTrans toaddCart ((v) in Figure 7). However,it does not add any relationship at succeeded ((vi) in
Figure 7), because all interactions are disabled there (line31 in Figure 3). As for branch nodes such as addCart ,
JSVeriﬁer skips this analysis b ecause the relationships from the
branch nodes are irrelevant to the interactions. By constructing
state machines based on the reﬁned interaction relationships,
JSVeriﬁer automatically extracts real stateful behavior fromAjax applications, as shown in Figure 9.
In addition to reading the source code, developers can lever-
age the extracted state machines to understand the stateful be-havior of Ajax applications. Although developers may be able
to ﬁnd faults relevant to the interactions using the extracted
state machines, the cost may not be negligible for developers to
manually and carefully check th e behavior when they modify
the source code. Additionally, the more interactions developersimplement in the applications, t he larger the scale of the state
machines JSVeriﬁer extracts. Therefore, we can argue that a
model checking technique is helpful for revealing erroneousbehavior because it can automati cally verify the behavior of
the applications with given ﬂexible invariants.
B. Verifying Interaction Invariants in Ajax Applications
JSVeriﬁer leverages a widely known model checker, Spin ,
for verifying interaction invar iants in the extracted state ma-
chines. Given ﬂexible invariants expressed as linear temporallogic (LTL) formulas, Spin veriﬁes the correctness of non-
deterministic automata described in Process Meta Language
(Promela). Accordingly, the model checker is suitable forverifying the extracted state machines that model nondetermin-
istic elements of Ajax applica tions. Our veriﬁcation technique
consists of three steps, as shown in Figure 6 (V1, V2, andV3).
Translating into Promela model (V1): JSVeriﬁer ﬁrst
translates the extracted stat e machines into a Promela model.
Figure III-B shows the code of a Promela model translated
from part of the extracted stat e machines in Figure 7. Table I
lists the deﬁnitions of the elements in the Promela model.
In this model, JSVeriﬁer outputs an active proctype
named App (lines 5-45) for representing application behavior
extracted in the state machines. The active proctype
is a process that Spin initially instantiates. App_state ,1621mtype ={/∗define all labels ∗/};
2mtype App
 state , App
 event , Int
 event ;
3chan App
 ch = [0] of {mtype };
4bool flg
 exit = false ;
5active proctype A p p() {
6 d
step {
7A p p
 state = init ;
8A p p
 event = empty ; / ∗two statements are ∗/
9I n t
 event = empty; / ∗”set e m p t y” ∗/}
1 0 goto
 init :
11 do // start of initial do loop
12 : : App
 ch? Int
 event −>
13 if :: Int
 event == onload −>
14 App
 event = onload ;
15 d
step {
16 A p p
 state = setEventHandler ;
17 / ∗set empty ∗/}
1 8 goto
 setEventHandler :
19 do
20 : : App
 ch? Int
 event −>
21 if :: Int
 event = = onclick −>
22 App
 event = onclick ;
23 d
step {
24 A p p
 state = addCart ;
25 / ∗set empty ∗/}
2 6 goto
 addCart :
27 do
28 : : App
 ch? Int
 event −>
29 if :: Int
 event == onSuccess −>
30 App
 event = onSucess ;
31 d
step {
32 A p p
 state = exit ;
33 / ∗set empty ∗/}
34 goto goto
 exit ;
35 : : I n t
 event = = onclick −>
36 App
 event = onclick ;
37 d
step {
38 A p p
 state = addCart ;
39 / ∗set empty ∗/}
40 goto goto
 addCart ;
4 1 ...
42 od; // e n d of initial do loop
4 3 goto
 exit :
44 f l g
 exit = true ;
45};
46active proctype Interaction () {
47 do ::
48 if :: flg
 exit −>break ;
49 : : e l s e −>
50 if
51 : : s k i p −>App
 ch! onload ;
52 : : s k i p −>App
 ch! onclick ;
53 : : s k i p −>App
 ch! onSuccess ;
5 4 ... };
Fig. 8. Partial example of application and interaction models in Promela
App_event ,a n d Int_event variables are deﬁned for re-
quirement descriptions (line 2). Additionally, the App process
nondeterministically r eceives messages via App_ch (line 3),
andflg_exit is set to true when the process exits (lines 4
and 43-44).
States in the state machines ar e represented in assignment
statements to the App_state variable (lines 7, 16, 24, 32,
and 38). To represent transitions in the state machines, JSVer-iﬁer leverages goto functionalities, because Promela unfortu-
nately does not allow describing function calls. By searching
all states from an initial one in the state machines, JSVeriﬁer
creates goto labels if the states initially appear (lines 10, 18,
and 26). Otherwise, it assigns goto statements to correspondinglabels (line 40). JSVeriﬁer is exceptionally designed to deals
with an exit state in such a way that Spin makes the application
process exit (lines 34 and 43-44).
The application model alone is not sufﬁcient to verify the
application behavior because th e application changes its state
as it handles interactions. Therefore, JSVeriﬁer also outputs an
active proctype named Interaction as an interac-
tion model that represents interactions of the application withthe user, server, and the application itself (lines 46-54). This
process randomly selects an interaction that the application
can handle and sends the message of the interaction to theApp process (lines 47, 51-53). When the App process reaches
the exit state, Spin also makes the Interaction process
exit (line 48). Thus, JSVeriﬁer can apply Spin to simulate the
stateful behavior of the Ajax application with the application
and interaction models.
To verify whether the application model correctly behaves
according to implemented Ajax de sign patterns, it is difﬁcult
for developers to deﬁne properties to be veriﬁed and to cor-rectly express them in veriﬁcation formulas. Since developers
have information about the implemented Ajax design patterns,
JSVeriﬁer supports the difﬁcult task by generating correctveriﬁcation formulas using the information.
C. Mapping Interaction Invariants using Property Patterns
We show a selective set of interaction invariants in Table II.
JSVeriﬁer leverages the interaction invariants for generating
correct veriﬁcation formulas so that developers only input
information about implemented Ajax design patterns.
Generating LTL formulas (V2): Since Ajax design
patterns contain comprehensive ﬁndings for increasing us-
ability of Ajax applications, we ﬁrst deﬁne properties interms of the interactions from the ﬁndings ( Ajax design
properties ). These Ajax design properties consist of a
property name and description; for example, the user event
registration (name) property explains that Ajax applications
should register user events at an onload callback (description).
To express these properties in correct veriﬁcation formulas,
we also leverage the property pattern mappings for LTL
[18], which classiﬁes raw property speciﬁcations of a GUI,concurrency logic, and communication protocol, into occur-
rence and order patterns. These property patterns contain
template veriﬁcation formulas with given states and events ofrunning applications. By relating these property patterns to the
Ajax design properties, we can describe LTL templates using
App_state ,App_event ,a n d Int_event in Table I for
JSVeriﬁer. Note that Spin requires a negative property against
the expected application behavior. For example, a negativeproperty of the user event registration property means that a
user event occurrence (Var 2) precedes that of a page load (Var
1). Therefore, we relate the Precedence property pattern in
the order pattern to the user event registration (P1 in Table II).
For the user event handler singleton property, the Existence
property pattern in the occurrence pattern is related because
the existence of multiple calls (Var 1) of the user event (Var 2)
negates the design property (P2 in Table II). Thus, developers163TABLE II
ASELECTIVE SET OF INTERACTION INV ARIANTS OF AJAX DESIGN PROPERTIES
P# Property Ajax design pattern Prop. pattern LTL template with Var 1 andVar 2 used in Table III
1 User ev. registration User Action Precedence App
 event != PageLoadEv U App
 event == UserEv
2 User ev. handler singleton User Action Existence <>(App
 state == PreventFunc && A p p
 event == UserEv )
3 Sever resp. before activation On-Demand JavaScript Precedence App
 event != SvrResp U App
 state == ActivateFunc
4 User ev. before submission Explicit Submission Precedence App
 event != UserEv U App
 state == SubmitFunc
5 Process before submission Live Form Precedence App
 state != ProcFunc U App
 state == SubmitFunc
i) select Ajax design properties and ii) input variables in the
LTL templates, and then JSVeriﬁer can generate correct LTL
formulas using the relationships listed in Table II..
Here, we explain Ajax design properties leveraged in our
case studies in Section IV. An On-Demand JavaScript
Ajax design pattern suggests that Ajax applications should
activate speciﬁc functionalities (Var 2) using results of the
asynchronous data retrieval after the server responses (Var1) (a server response before activation prop-
erty). Additionally, Explicit Submission andLive
Form Ajax design patterns suggest that Ajax applica-
tions should require an explicit users operation (Var 1
in the former) and should process form data (Var1 inthe latter) before data submission (Var 2 in both) ( user
event before submission andprocess before
submission properties). These properties are related to
the Precedence property pattern similar to the user event
registration property (P3, P4, and P5 in Table II).
Running Spin (V3): When developers implement and
test Ajax applications based on Ajax design patterns, they
can input information about implemented Ajax design patterns
(IADP information) into a repository of JSVeriﬁer. Developers
can input function and event names in the source code asvariables for selected Ajax design properties. If the names
do not appear in the extracted state machines, JSVeriﬁer
can ﬁnd corresponding states because it stores abstractioninformation. This information contains to which states the
functions are abstracted. Therefore, developers do not need
to deeply understand how it works.
By obtaining the information via the repository, as input,
JSVeriﬁer automatically generates correct LTL formulas repre-
senting the design properties. Then, Spin traverses in the state
space of the Promela model and veriﬁes whether the model sat-isﬁes the formulas. This veriﬁcation of correctness can assure
developers that the applicatio n correctly behaves according
to their intentions. Otherwise, Spin outputs a counterexampleof the LTL formula as a fault oracle, and then JSVeriﬁer
extracts an execution path contai ning the fault from the oracle.
Finally, JSVeriﬁer automatically suggests a debugging clue to
the developers as output.
D. Use Scenario and Results of Our Brief Example
We explain a use scenario of JSVeriﬁer and results of our
brief example in Figure 9. We assume that JSVeriﬁer can
be used in the context of test-driven development, where
developers ﬁrst give test cases of additional functionalities thenimprove the source code to pass the test cases. Developers
ﬁrst input interaction invariants of implemented Ajax design
patterns into the repository of JSVeriﬁer, then they can debuguntil the invariants are veriﬁed as correct.
We now illustrate a JSVeriﬁer use scenario with our brief
example. We assume that developers implement functionalities
in Ajax applications based on Ajax design patterns. Developers
ﬁrst select the user event registration property and input itsvariables when implementing the option selection function-
ality (i, ii). Then, JSVeriﬁer veriﬁes the correctness of this
implementation. Next, developers implement the item additionfunctionality (iii) and give the information for this additional
functionality. At this time, JSVeriﬁer determines that the
current implementation does not satisfy the additional invariant
and suggests a corresponding faulty execution path on the
extracted state machines. We assume that developers candebug using the faulty execution path (iv). Finally, developers
conﬁrm that the application c orrectly runs according to the
invariants.
IV . E
VA L UAT I O N
To answer the following research questions, we conducted
case studies and evaluated JSVeriﬁer.
RQ1 Can JSVeriﬁer automatically verify interaction in-
variants with given IADP information?
RQ2 Can JSVeriﬁer output veriﬁcation results in a feasible
time?
A. Case Studies
We used two real-world Ajax applications; sForm6is
an Ajax application for form validation and Login With
Ajax (LWA)7is an Ajax application plugin on WordPress8
for replacing a login widget. These applications are runnableand their source codes are available for debugging. Ad-ditionally, we prepared a sample Ajax application called
FileDLer
9. We had implemented this application for mo-
tivating our previous study. Table III shows HTML, CSS,and JavaScrip lines of codes in these applications ( LoC ). The
100-1K LoC range represents the small-medium size in Ajax
applications.
6http://www.chains.ch/2008/01/26/ajax-form-validation-sform/
7http://wordpress.org/extend/plugins/login-with-ajax/
8http://wordpress.org/
9http://maezawa.honiden.nii.ac.jp/yuta/research/ex/fd/164Faulty execution pathsDeveloper
Implementing RepositoryIADP information
DebuggingJSV erifier
D
 l(iii) Implement item addition functionality
(iv) Debug using
suggested faulty execution path(i, ii) Implement option selection functionality
...
…
…
……
…
………
……
……
Higher usability
Ajax applications
...
...
Faulty execution path
init
setEventHandler onload
calcPriceonchange onchange onchange
addCartonclick  onchange  onchange  onchange 
onclick
reqRunTrans [isValidInput()]
BLOCK_994 [!(isValidInput())]onchange onchange onchange
onclick
succeededonSuccess
alertUser Clickonchange onchange onchange
onclickFaultyexe
init
ventHandl eronload 
calcPric enchan geonchange onchan ge
addCartonclick  onchange  oncha
onclick
isValidInput()]VV  [!(isValidInpVVangeonchan ge
onclic k
Fig. 9. JSVeriﬁer use scenario and results of our brief example
B. Evaluation Methodology
In our case studies, we ﬁrst determined properties to be
veriﬁed and corresponding variables in the three applications,
as shown in Table III. Since we did not know the intent ofthe original developers of sForm and LW A, we conducted the
determinations based on the source code fragments. Here, we
explain the representative determinations.
10In the source code
of sForm, we found a validateIt function for validating
form data and a submit function for submitting the data.
We inferred that the validation process should be executed
before the form submission, and then we determined the
process before submission property and the functions as thevariables in sForm. As for LW A, we determined the user event
registration property because of a jQuery.ready
11frag-
ment in the source code. The ready is usually implemented
for attaching all other event handlers as an alternative to an
onload event. Therefore, we infe rred that the application
should register all user events at the ready. Note that we
had known expected behavior and injected faults in FileDLer,
therefore, we determined appropriate properties and variablesaccording to our intentions. We stored the properties and the
variables as IADP information into a repository of JSVeriﬁer.
Next, we ran JSVeriﬁer with the repository. JSVeriﬁer
measured the extraction and veriﬁcation times ( T
eandTv).
Additionally, JSVeriﬁer outputte d the extracted state machines,
veriﬁcation results and faulty execution paths. We debugged
the applications using the paths, and then ran JSVeriﬁer again.
Finally, we conﬁrmed whether JSVeriﬁer could verify thecorrectness.
10All the determinations are available from http://goo.gl/4fQ0d
11http://api.jquery.com/ready/C. Results and Discussion
Automated veriﬁcation (RQ1): JSVeriﬁer could automati-
cally verify the correct and wr ong application behavior. We
tested sForm according to the faulty execution path, and
then found that sForm actually handled the form submission
without any user inputs in the form. Then, we debuggedsForm to initially disable the submit button and conﬁrmed
that JSVeriﬁer veriﬁed the co rrectness. These results repre-
sent that JSVeriﬁer could expose executable faults in Ajaxapplications. Additionally, we searched the user events on the
faulty execution in LW A, and then found them in the HTML
source code. These implementations conformed to undesirable
ones shown in the User Action Ajax design pattern. We
debugged them according to a so lution suggested in the design
pattern so that JSVeriﬁer could output the correct results. Note
that this faulty execution path could not be executed in the
current implementation. These res ults represent that JSVeriﬁer
could also expose inexecutable but concealed faults. As for
FileDLer, we had already had correct and faulty version of
the applications. We conﬁrmed that JSVeriﬁer could suggest
the faulty execution paths as e xpected. Therefore, we argue
that JSVeriﬁer correctly works for our veriﬁcation method.
Feasible veriﬁcation time (RQ2): In our case studies,
JSVeriﬁer could automatically extract state machines from
our case studies and verify pattern -based interaction invariants
within several seconds, as shown in Table III. Most of the run-time was required for initializing HTML, CSS, and JavaScript
parsers. These extraction and ve riﬁcation times increase lin-
early with the number of implemented interactions in Ajax
applications. We conﬁrmed that the applications contained the
sufﬁcient number of the interactions for using JSVeriﬁer in our165TABLE III
RESULTS OF OUR CASE STUDIES
LoC
 P# Property
 Var 1
 Var 2
 Te(msec)
 Tv(msec)
 Result
sForm
 314
 1 User event registration
 onload
 onblur
 3170
 1013
 Correct
onload
 onclick
 750
 Correct
5 Process before submission
 validateIt
 submit
 992
 Fault
4 User event before submission
 onclick
 submit
 672
 Correct
LWA
 2084
 1 User event registration
 ready
 submit
 6487
 543
 Correct
ready
 click
 533
 Correct
ready
 onfocus
 752
 Fault
ready
 onblur
 686
 Fault
FileDLer
 251
 1 User event registration
 onload
 onkeyup
 5144
 840
 Correct
onload
 onclick
 743
 Correct
3 Server response before activation
 onSuccess
 inputFormText
 1035
 Fault
4 User event before submission
 onclick
 doSubmit
 718
 Correct
2 User event handler singleton
 doDownload
 onkeyup
 827
 Fault
doDownload
 onclick
 690
 Correct
case studies. Additionally, JSVeriﬁer could expose the actual
faults in real-world Ajax applications in a feasible amount of
time. Therefore, we argue that JS Veriﬁer can be applicable for
real-time use.
Costs for debugging faults: Although JSVeriﬁer can
suggest faulty execution paths on extracted state machinesas clues to debugging, developers need to locate faults in
the source code using the clues. As our future work, we
plan to leverage solutions in Ajax design patterns for faultlocalization.
D. Threats to Validity
Internal validity threats: We considered two external
factors that might affect results in our case studies. We found
sForm and LW A via the Web, so these applications do not
affect the internal of JSVeriﬁer, and the results from using
these applications represent the usefulness of JSVeriﬁer forour veriﬁcation method. However, we implemented FileDLer
ourselves to contain the faults relevant to interaction invariants,
which may be a threat to internal validity. Therefore, weintend to conduct additional case s tudies using real-world Ajax
applications such as sForm and LW A.
Additionally, we deﬁned Ajax design properties from Ajax
design patterns and related property patterns to the properties.
Although these deﬁnitions and rel ationships might affect the
internal validity of JSVeriﬁer, results of our case studiesshowed that JSVeriﬁer could verify the correct and wrong
behavior of the applications and expose the actual faults in
the real-world applications. As our future work, we intend to
present an exhaustive set of Ajax design properties and to
evaluate the usefulness of JSVeriﬁer for exposing actual faultsin the additional case studies.
External validity threats: With regards to the generality
of our approach, JSVeriﬁer leveraged Spin, so it could only
deal with requirements that were expressed in LTL formulas.
However, there are requirements that are beyond the descrip-
tive capability of LTL, for example, the reachability of certainstates from any other states. To verify such behavior, we con-
sider leveraging SMV
12, which can verify the correctness using
computation tree logic (CTL) formulas. CTL formulas allowdevelopers to express requirements involving the reachability.
Additionally, we are currently working on outputting timed
automata for Uppaal
13using JSVeriﬁer.
Moreover, in our case studies, although we could leverage
LWA that were sufﬁciently practical, sForm andFileDLer
were simple Ajax applications. We need to obtain more
experimental results from analy zing large-scale and practical
Ajax applications.
E. Limitations
Data-intensive impossible execution paths: JSVeriﬁer
analyzes only enabling and disabling statements to determine
whether an Ajax application can handle the interactions. In
fact, developers can implement s uch interaction controls also
using data ﬂows. In our brief example in Figure 3, user inputs
for selecting options can never be invalid (line 15), whichmeans that the application can never proceed to the state
corresponding to invalid user inputs (lines 17-19). Such data-
intensive impossible execution paths can be dealt with byDOM-based dynamic analysis [7], [8], [9], [10]. Hence, we
will extend JSVeriﬁer to leverag e contributions of these related
work in order to construct a hybrid approach.
However, we want to claim that the impossible execution
paths would be executable fault candidates, for example, in
case that other developers modify the source code of open
source Ajax applications or that users install other applicationplug-ins. Therefore, we argue that our pessimistic analysis is
valuable to verify the application behavior containing the fault
candidates.
Additional Ajax design patterns: We assume that inter-
action invariants in Ajax applications derive from Ajax design
12http://www.cs.cmu.edu/˜modelcheck/smv.html
13http://www.uppaal.com/166patterns. In fact, developers have their original Ajax design
pattern and ﬂexible requirements. When adding new design
patterns, developers need to deﬁne veriﬁcation properties inthe design patterns and to relate appropriate property patterns
to the properties. Otherwise, developers can use JSVeriﬁer with
raw LTL veriﬁcation formulas.
V. R
ELATED WORK
Our approach leverages a reverse engineering technique and
a model checking technique. The former aims to provide alter-
native views of software artifacts, such as for redocumenting
programs and recovering design patterns [19]. Especially, aview of state machines can improve the code understandability
of developers [20]. The latter is an approach for verifying
ﬁnite state machines representin g concurrent systems, such as
sequential circuit designs and communication protocols [21].
Ricca et al. introduced state-based analysis and testing of
Web applications [22]. Although they regarded Web pages as
states, an Ajax technology allows the applications to change
their states in a single page. Hence, Marchetto et al. presenteda state-based testing technique for Ajax applications [7], [23].
Their tool called ReAjax could trace execution results of
actual DOMs, extract ﬁnite state machines from the trace data,
and generate test cases based on the state machines. However,
developers needed to manually and exhaustively execute Ajaxapplications for tracing sufﬁcient execution logs.
Mesbah et al. implemented Crawljax that could simulate
user events by ﬁnding ﬁreab le DOM elements and extract
ﬁnite state machines from Ajax applications [8]. To detect
DOM-based faults such as dead clickable elements, the toolanalyzed invariants of the DOM structure. Additionally, they
ran the tool on multiple browser environments for cross-
browser compatibility testing [24]. Moreover, their extendedtool called Cilla could ﬁnd faults relevant to the presenta-
tion of the applications during crawling [25]. Although they
mentioned that static analysis techniques had limitations for
revealing faults of Ajax applications due to interactive DOM
manipulations, we can apply a static approach for extractingand verifying state machines by focusing on the interactions
with the applications.
Amalﬁtano et al. proposed several Ajax application-
independent state change criteria and an interactive process
for extracting ﬁnite state machines [9]. They constructed a tool
called CreRIA that could suggest state changes based on the
criteria and developers coul d accept or reject the suggestions
during executing Ajax applications. Although CreRIA effec-tively leveraged the heuristics of developers, this interactive
process was less contribution to the automation.
The above dynamic approaches leveraging execution results
cannot verify the correctness of the application behavior
because these tools may not execute all possible paths in theapplications. Our motivation for constructing JSVeriﬁer is that
Ajax applications may have inexecutable faults to be exposed.
Additionally, Arzti et al. presented a method for prioritizing
event sequences using historical execution results to improve
code coverage [10]. This approach also dealt with DOM-basedfaults because HTML, CSS and J avaScript errors are deﬁned
in their language speciﬁcations. As for valid event sequences,
there is no general deﬁnition of correct or wrong behavior.Therefore, developers leverage Ajax design patterns to deﬁne
Ajax application-independent invariant occurrence and order
among interactions as interaction invariants.
Guha et al. proposed a static approach for testing vulnerabil-
ity of Ajax applications [11]. Their framework could analyzecontrol ﬂows in the JavaScript code and extract the request
graph containing sequences of asynchronous communica-
tions. Developers can use this framework for detecting runtimeserver requests that do not match the sequences. However,
their approach was presumed that developers can correctly
understand and implement the app lication behavior. Addition-
ally, they addressed existing faults to be detected. Consid-
ering that developers will modify the source code of opensource Ajax applications and that users will install Ajax
application plugins, we claim that developers should debug
fault candidates that will be exposed. JSVeriﬁer can verifythe application behavior containing such the fault candidates.
Furthermore, as a limitation of their approach, they pointed
out that it is necessary to analyze disabling event handlers
to precisely monitor Ajax application behavior. Our analysis
scope covers the application beh avior containing such enabling
and disabling interactions.
Blewitt et al. conducted detection of GoF design patterns
in Java using semantic constraints [17]. Their concern wasthat software evolution over time would cause breaking the
design patterns in their original forms on the implementations.
Additionally, Ghabi et al. addressed an issue of maintaining
requirements-to-code traces [26] because the software evolu-
tion also causes invalidating a requirements traceability matrix.In this study, we assume that information about implemented
Ajax design patterns are correct, and it would be interesting
to how JSVeriﬁer works with the invalid information.
VI. C
ONCLUSIONS AND FUTURE WORK
We presented a support tool, JSVeriﬁer, and a selective set
of interaction invariants based on Ajax design patterns and
property patterns. Our aim was to automatically verify thecorrectness of an interaction-based stateful behavior in Ajax
applications according to imple mented Ajax design patterns.
The results of our case studies showed that JSVeriﬁer couldverify the application behavior and could expose the actual
faults in the real-world Ajax applications in a feasible amount
of time. We concluded that JSVeriﬁer could help developers
increase the usability of Ajax applications.
As our future work, we plan to provide an exhaustive set
of the interaction invariants. We are going to exhaustively
deﬁne interaction-related properties from Ajax design patterns
and relate property patterns to the properties. Additionally, weintend to support developers to debug Ajax applications using
the suggested faulty execution paths. We are considering using
solutions in the design patterns to suggest debugging methods.
Moreover, we will conduct additional case studies using real-
world, large-scale, and practical Ajax applications.167REFERENCES
[1] B. Stearn, “Xulrunner: A new approach for developing rich internet
applications,” IEEE Internet Computing , vol. 11, no. 3, pp. 67–73, 2007.
[2] L. D. Paulson, “Building ric h web applications with ajax,” Computer ,
vol. 38, no. 10, pp. 14–17, 2005.
[3] Internet World Stats. (2011, Dec.) World internet usage
statistics news and world population stats. [Online]. Available:www.internetworldstats.com/stats.htm
[4] J. Nielsen and H. Loranger, Prioritizing Web Usability .B e r k e l e y , C A :
New Riders Press, 2006.
[5] C. E. Downing and C. Liu, “Assessing web site usability in retail
electronic commerce,” in Proc. Computer Software and Applications
Conf. (COMPSAC’11) , Jul. 2011, pp. 144–151.
[6] M. Mahemoff, Ajax Design Patterns . O’Reilly Media, Inc., 2006.
[7] A. Marchetto, P. Tonella, and F. Ricca, “State-based testing of ajax web
applications,” in Proc. Int’l Conf. on Software Testing, Veriﬁcation and
Validation (ICST’08) , Apr. 2008, pp. 121–130.
[8] A. Mesbah and A. van Deursen, “Invariant-based automatic testing
of ajax user interfaces,” in Proc. Int’l Conf. on Software Engineering
(ICSE’09) , May 2009, pp. 210–220.
[9] D. Amalﬁtano, A. R. Fasolino, and P. Tramontana, “An iterative ap-
proach for the reverse engineering of rich internet application userinterfaces,” in Proc. Int’l Conf. on Internet and Web Applications and
Services (ICIW’10) , May 2010, pp. 401–410.
[10] S. Artzi, J. Dolby, S. H. Jensen, A. Moller, and F. Tip, “A framework for
automated testing of javascript web applications,” in Proc. Int’l Conf.
on Software Engineering (ICSE’11) , May 2011, pp. 571–580.
[11] A. Guha, S. Krishnamurthi, and T. Jim, “Using static analysis for ajax
intrusion detection,” in Proc. Int’l World Wide Web Conf. (WWW’09) ,
Apr. 2009, pp. 561–570.
[12] Y . Maezawa, H. Washizaki, and S. Honiden, “Extracting interaction-
based stateful behavior in rich internet applications,” in Proc. European
Conf. on Software Maintenance and Reengineering (CSMR’12) ,M a r .
2012, pp. 423–428.
[13] Garrett, Jesse James. (2005, Feb.) Ajax: A new approach to web
applications. [Online]. Available: www.adaptivepath.com/ideas/ajax-new-approach-web-applications[14] J. Duhl, “White paper: Rich internet applicationb,” IDC, Tech. Rep.,
Nov. 2003.
[15] M. Driver, R. Valdes, and G. Phifer, “Rich internet application are the
next evolution of the web,” Gartner, Inc., Tech. Rep., May 2005.
[16] J. Farrell and G. S. Nezlek, “Rich internet applications the next stage of
application development,” in Proc. Int’l Conf. on Information Technology
Interfaces (ITI’07) , Jun. 2007, pp. 413–418.
[17] A. Blewitt, A. Bundy, and I. Stark, “Automatic veriﬁcation of design
pattern in java,” in Proc. Int’l Conf. on Automated Software Engineering
(ASE’05) , Nov. 2005, pp. 224–232.
[18] Alavi, Hamid and Avrunin, George and Corbett, James and
Dillon, Laura and Dwyer, Matt and Pasareanu, Corina. (2013,
May) Property pattern mappings for ltl. [Online]. Available:
patterns.projects.cis.ksu.edu/do cumentation/patterns/ltl.shtml
[19] G. Canfora and M. D. Penta, “New frontiers of reverse engineering,”
inProc. Future of Software Engineering (FOSE’07) ,M a y2 0 0 7 ,p p .
326–341.
[20] S. S. Som´ e and T. C. Lethbridge, “Enhancing program comprehension
with recovered state models,” in Proc. Int’l Workshop on Program
Comprehension (IWPC’02) , Jun. 2002, pp. 85–93.
[21] E. M. Clarke, Jr., O. Grumberg, and D. A. Peled, Model Checking .
Cambridge, MA, USA: MIT Press, 1999.
[22] F. Ricca and P. Tonella, “Analysis and testing of web applications,” in
Proc. Int’l Conf. on Software Engineering (ICSE’01) , May 2001, pp.
25–34.
[23] A. Marchetto, P. Tonella, and F. Ricca, “Reajax: a reverse engineering
tool for ajax web applications,” Software, IET , vol. 6, no. 1, pp. 33–49,
2012.
[24] A. Mesbah and M. R. Prasad, “Automated cross-browser compatibility
testing,” in Proc. Int’l Conf. on Software Engineering (ICSE’11) ,M a y
2011, pp. 561–570.
[25] A. Mesbah and S. Mirshokraie, “Automated analysis of css rules to
support style maintenance,” in Proc. Int’l Conf. on Software Engineering
(ICSE’12) , May 2012, pp. 408–418.
[26] A. Ghabi and A. Egyed, “Code patterns for automatically validating
requirements-to-code traces,” in Proc. Int’l Conf. on Automated Software
Engineering (ASE’12) , Sep. 2012, pp. 200–209.168