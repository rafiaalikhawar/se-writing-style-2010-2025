See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/234842627
Variability points and design pattern usage in architectu ral tactics
Conf erence Paper  · No vember 2012
DOI: 10.1145/2393596.2393657
CITATIONS
21READS
436
3 author s:
Mehdi Mir akhorli
Association f or Computing Machiner y
107 PUBLICA TIONS    1,703  CITATIONS    
SEE PROFILE
Patrick Mäder
Technische Univ ersität Ilmenau
236 PUBLICA TIONS    6,257  CITATIONS    
SEE PROFILE
Jane Cleland-Huang
DeP aul Univ ersity
313 PUBLICA TIONS    8,765  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Patrick Mäder  on 10 No vember 2019.
The user has r equest ed enhanc ement of the do wnlo aded file.Variability Points and Design Pattern Usage
in
Architectural Tactics
Mehdi Mirakhorli
DePaul University
Chicago, IL, 60604, USA
m.mirakhorli@acm.orgPatrick Mäder
Johannes Kepler University
Linz, Austria
patrick.maeder@jku.atJane Cleland-Huang
DePaul University
Chicago, IL, 60604, USA
jhuang@cs.depaul.edu
ABSTRACT
Architectural tactics are important building blocks of soft-
ware architecture. Tactics come in many shapes and sizes,
describe solutions for addressing speciﬁc quality concerns,
andareprevalentacrosshigh-performancefault-tolerantsys-
tems. Once a decision is made to utilize a tactic, the devel-
oper must generate a concrete plan for realizing the tactic
in the design and code. Unfortunately, the variability points
found in individual tactics can make this a challenging task.
To address this knowledge gap, we conducted a study to in-
vestigate how design patterns were used to implement var-
ious tactics. Data mining techniques were used to identify
potential pattern instances within tactic implementations.
Our manual analysis of the retrieved data identiﬁed a dis-
tinct set of variability points for each tactic, as well as corre-
sponding design patterns used to address them. From these
observations we construct tactic-level decision trees depict-
ing variability points of a tactic and generate a reference
model which provides implementation guidance.
Categories and SubjectDescriptors
D.2.0 [Software Engineering ]: Object Oriented Design
Methods; D.2.1 [Software Architectures ]: Patterns
Keywords
Architecture, design patterns, tactics
1. INTRODUCTION
The architecture of a complex software intensive system is
carefullydesignedanddevelopedtosatisfydiverseandsome-
times competing concerns related to dependability, safety,
security, performance, usability, and other important qual-
ities [6]. To satisfy such concerns, architects often utilize
architectural patterns (sometimes referred to as styles) and
architectural tactics to design an overall solution [22,23].
An architectural tactic serves as a building block of soft-
ware architecture and is used to satisfy a speciﬁc quality
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bearthisnoticeandthefullcitation ontheﬁrstpage. Tocopyotherwise, to
republish,topostonserversortoredistributetolists,requirespriorspeciﬁc
permission and/or afee.
SIGSOFT/FSE’12, November11 - 16 2012,Cary,NC, USA
Copyright2012ACM 978-1-4503-1614-9/12/11$15.00..attribute [4,6,18,26]. Architectural tactics come in many
diﬀerent shapes and sizes and describe solutions for a wide
range of quality concerns [6]. They are particularly preva-
lent across high-performance and/or fault tolerant software
systems. For example, reliability tactics such as redundancy
with voting, heartbeat, and check pointing provide solutions
for fault mitigation, detection, and recovery; while perfor-
mance tactics such as resource pooling andscheduling help
optimize response time and latency [18].
The importance of implementing architectural tactics rig-
orously and robustly was highlighted by a small study we
conducted as a precursor to this work. We investigated
tactic implementations in Hadoop [1] and OFBiz [2] and
evaluated their degree of stability during the maintenance
process. For each of these projects we retrieved a list of
bug ﬁxes from the change logs (Nov. 2008 - Nov. 2011 for
Hadoop, and Jan. 2009 - Nov. 2011 for OFBiz). Our anal-
ysis showed that tactic-related classes incurred 2.8 times as
many bugs in Hadoop, and 2.0 times as many bugs in OF-
Biz as non-tactic related classes, suggesting that tactic im-
plementations, if not developed correctly, are likely to con-
tribute towards the well-documented problem of architec-
tural degradation [14,15,20,30].
The work described in this paper focuses on implementing
proven solutions for such tactics. Less experienced develop-
ers sometimes ﬁnd this challenging, primarily because of the
variability points that exist in a tactic, and the numerous
design decisions that need to be made in order to implement
a tactic in a robust and eﬀective way. Figure 1 illustrates
this point with two concrete examples of developers posting
requests for help to online forums because they did not un-
derstand how to implement speciﬁc tactics. We found many
examples of such requests.
Unlikedesignpatternswhicharedescribedintermsofspe-
ciﬁc classes and associations, tactics are deﬁned at a higher
conceptual level of roles and responsibilities [6]. Developers
must understand the nuances of the tactic, take into con-
sideration a wide range of project-speciﬁc factors that serve
as forces upon the tactic, consider various implementation
options, and ultimately derive a suitable design solution.
For example, the heartbeat tactic is a relatively simple
tactic used to monitor the availability of a critical compo-
nent. However, in a previous study of over 20 open source
systems [24] we observed numerous variations in how the
tactic could be implemented. These included (i) direct com-
munication between the emitter and receiver roles, (ii) use
of the observer pattern in which the receiver registered as a
listener to the emitter, (iii) the decorator pattern in which
1h
ttp://stackoverflow.com/questions/751622/pattern-to-im plement-heartbeat-between-server-and-the-client 
http://www.coderanch.com/t/99812/patterns/Connection-pooling-design-pattern 
Figure 1: Developers seek help in online forums to
imple
ment architectural tactics.
the heartbeat functionality was added as a wrapper to a
core service, and ﬁnally (iv) in numerous proprietary for-
mats that did not follow any speciﬁc design pattern. While
a good developer can certainly come up with a functioning
implementation, it is diﬃcult for any but the most experi-
enced developers to have a complete understandingof all the
issues and trade-oﬀs, that might go into making an informed
implementation decision.
This paper reports the results from an extensive study of
36opensourcesystems, inwhichweinvestigatedthewayde-
velopers used design patterns within the implementation of
architectural tactics (from now on referred to as tactic/pat-
tern overlaps ). Our ﬁndings show that design patterns are
often used to address variability points of a tactic in order
to make the tactic more maintainable, scalable, or reliable;
or to otherwise increase its quality and robustness. Based
on our observations, we identify variability points for each
tactic, highlight the issues that a developer should consider
during the tactic implementation process, and document the
solutionspreviousdevelopershavemade. Eachofthemodels
we present was derived from observing and analyzing several
uses of design patterns for implementing each of the studied
tactics and then selecting a prevalent design option which
we judged to best follow the fundamental principles of good
design [16]. Based on the identiﬁed variability points and
proposed designs we oﬀer prescriptive guidelines for helping
developers implement architectural patterns. In the case
of thescheduler tactic we also present a combined design
which integrates relevant design patterns into a single refer-
ence model.The preparatory phase of our work in which we identify
examples of design pattern use within tactic implementa-
tions utilizes tools we previously developed for tactic detec-
tion [24] and design pattern detection [25]. The new contri-
butionofthispaperisthein-depthanalysisofdesignpattern
usage in architectural tactics, the extrapolation of variabil-
ity points in each tactic, and the resulting decision trees and
reference models.
The remainder of this paper is laid out as follows. Sec-
tion 2 describes the process and techniques that were used
to mine open source projects for instances of tactic/pattern
overlaps. Section 3 describes the analysis and assessment of
pattern usage in tactics. Sections 4 to 6 describe our results
for three diﬀerent tactics, namely the scheduler ,resource
pooling, and heartbeat tactics . For each of these tactics we
identify variability points and implementation solutions in
the form of design patterns. Section 7 then describes our
approach for merging individual design patterns into a com-
bined, tactic-speciﬁc reference model,while Section 8 pro-
vides an illustrative example showing how the model might
be used to help the developer make tactic implementation
decisions. Section 9 discusses threats to validity for our
study. Section 10 describes related work, and ﬁnally Sec-
tion 11 summarizes our contributions and outlines our plans
for ongoing work.
2. MINING TACTIC IMPLEMENTATIONS
Findingarepresentativesampleoftactic/patterninstances
is far from trivial. We therefore developed a semi-automated
process for retrieving candidate instances of tactic-related
classes implemented using the gang-of-four (GoF) design
patterns [16].
The process involves several steps depicted in Figure 2,
including: (1) building a software repository, (2) extracting
instances of architectural tactics, (3) extracting instances of
design patterns, (4) computing the overlap between tactics
and design patterns to identify tactic/pattern instances, and
ﬁnally (5) manually inspecting the results to remove false
positives and to clearly delimit the boundaries of each tactic
and each identiﬁed pattern. The output from this process
provides the raw data needed in the remainder of our study.
2.1 Building a software repository
We downloaded 500 open source projects using Sourcerer
[28], which is an automated crawling application designed to
extract projects from publicly available open source repos-
itories such as Apache, Java.net, Google Code and Source-
forge.
2.2 Extracting architectural tactics
To identify architectural tactics, we utilized a previously
developed tactic detection algorithm and tool [11,24]. The
tool had previously been trained to identify ﬁve diﬀerent
architectural tactics, namely heartbeat, scheduler ,resource
pooling, authentication, and audit trail, and in a series of
previously reported experiments was able to correctly reject
approximately 77-99% of unrelated code classes (depending
on tactic type), to recall 100% of the tactic related classes in
most cases, but only 70% in the case of the authentication
tactic, and to achieve precision at these recall levels of 19%
and 31% in the cases of the scheduler and authentication,
and from 65% to 88% for other tactics. While this approach
does not return entirely precise results, it does signiﬁcantly
2 
 
Manual  
evaluation 
and 
assessment  Tactic extraction & project selection 
5
00 Open source 
pr
ojects De
sign  
Pa
ttern Detection: 
Candidate 
classes mapped 
onto tactics Pattern Detection 
C
andidate 
pa
tterns C
andidate 
ta
ctics T
actic  
Det
ector:  
T
actic 
ri
ch 
projects 
n
ualO
verlap Analysis  
Id
entify variability points and design 
pattern solutions. 
D
ecision 
tr
ees 
Tactic 
reference 
models X Y Z 
[ 
\ 
Figure 2: An Overview of our semi-automated pro-
ce
ss for mining open source repositories to retrieve
samples of tactic/pattern code, identifying tactic-
speciﬁc variability points, and generating reference
models
reduce the search space and assist with the task of retrieving
candidate tactic/pattern overlap classes. This imprecision is
tolerable, because our process includes an evaluation phase
in which false positive results are manually eliminated.
For purposes of this paper, we trained the classiﬁer to
identify the additional tactics of active redundancy, check
pointing,kerbrose,loadbalancing,PBAC,pingecho,RBAC,
and secure session [7] , for a total of 13 tactics. These tac-
tics were selected because they represent common tactics for
fault tolerance, performance, and security.
The tactic classiﬁer includes the three phases of prepara-
tion, training, and classifying. Due to space constraints we
provide only an informal description of each of these phases;
however a more complete description of the approach, in-
cluding its related formulas, is provided in other publica-
tions [11,12,24].
During the preparation phase all of the data that is to
be used for training and classiﬁcation purposes is prepro-
cessed according to standard information retrieval methods.
Preprocessing steps include splitting source code variable
names into primitive parts, removing stop words (i.e. unim-
portant words), and stemming words to their root forms.
The resulting terms are then stored for future processing.
Thetraining phase takes a set of textual descriptions ofthe tactic as input, and produces a set of weighted indica-
tor terms that are considered representative of each tactic
type. For example, a term such as priority, is found more
commonly in code related to the scheduling tactic than in
other kinds of code, and therefore receives a higher weight-
ing with respect to that tactic. For training purposes we
used ten textbook, journal, or whitepaper descriptions of
each tactic as input to the classiﬁer.
Finally during the classiﬁcation phase , the indicator
terms learned in the training phase are used to compute
the likelihood that a given class is associated with a given
tactic. Each class is assigned a score for each tactic, and
classes scoring over a pre-deﬁned threshold (in this case 0.5
based on results from our earlier work) are labeled as being
associated with the relevant tactic. In this way, it is possible
for a class to be simultaneously associated with more than
one tactic.
Given the fact that the study described in later parts of
this paper involved manually inspecting each tactic and pat-
tern instance in order to understand how and why the pat-
tern was used in the tactic, it was important to reduce the
original dataset to a smaller, tactic-rich set of projects. The
tactic detector was therefore run against all 500 previously
downloaded projects. Projects were then ranked according
to the number of detected tactics, and the top 36 scoring
projects were carried forward into the next stage of the anal-
ysis.
The ﬁnal projects are listed in Table 1. For each project
we report its name, the number of classes in the system,
the number of tactic types covered (maximum 13), number
of candidate design patterns detected (maximum 20), and
the ﬁnal count of pattern/tactic overlaps as predicted by
our automated tools. As depicted in this table, most of
the included projects provided coverage of 5 or more tactic
types; however in order to ensure coverage of all the studied
tactics, we included a couple of additional projects simply
because they included the targeted tactic type, even though
their overall tactic coverage was low.
2.3 Detecting Design Patternsin the Code
Pattern detection was performed on the selected projects
using an algorithm and tool developed previously by one
of the authors [25]. The approach incorporates a catalog
of user-customizable pattern deﬁnitions, supports pattern
variationsandalternatives, andappliesmultiplesearchtech-
nologies during the matching process. The underlying algo-
rithm is based on the concept of a feature type, deﬁned as
an elementary property of a design pattern likely to recur
across diﬀerent pattern types (e.g., an aggregation relation
between two classes or a method return and the instance of
the class that contains it). Pattern deﬁnitions can be cre-
ated through composing feature types. A set of 44 feature
types was deﬁned and enabled the detection of all 23 so-
called Gang of Four (GoF) patterns [16] as well as several of
their variants.
Each of these feature types is assigned to a search tech-
nology that allows for its precise but eﬃcient detection. By
combining these feature types into the deﬁnition of a pat-
tern, search technologies are also combined and contribute
to the matching process. The approach currently uses three
diﬀerent search technologies: SQL queries to retrieve infor-
mation from a class model of the analyzed source code, regu-
lar expressions matching constructs in the class model or the
3Table 1: Studied Projects: Size, identiﬁed tactics,
de
tected design patterns and observed overlaps
# of Tactic Pattern Over-
Ar
ea Name classes types types laps
Enterprise
ER
P/CRMApache OFBiz 1987 11 14 44
Apache Tobago 632 9 7 3
Compiere ERP 1476 10 13 27
Enterprise 5920 11 3 0
Jpos 430 7 13 16
Neogia 3667 11 12 25
nomadpim 4364 10 18 105
Open SubSystem 8201 13 17 130
PaperDog 347 6 7 8
QuickFix 2291 6 3 1
Frameworks/
Mi
ddlewareApache Cocoon 2945 10 14 62
Apache DS 1324 9 13 22
Jboss 5703 13 15 99
LuntBuild 412 7 7 9
nomadpim 4364 10 18 105
open3ds 66 4 1 0
Oracle CAC 720 10 12 38
Posit 2545 8 13 22
vt-middleware 898 9 6 12
Commun-
ic
ations
etc.Arsenal-1 3065 9 10 19
Charliebot 180 8 7 11
icemud 93 5 3 0
Projectvianet 1056 9 11 36
Operating
Sys
temsMVctrl 43 2 0 0
tinyOS 6244 11 16 31
Internetarchive-crawler 757 11 12 38
Sino 3055 11 14 42
Content
Man
agementApache Lenya 3661 10 16 65
mdﬁction 227 5 9 11
Distributed
Comp
utingApache Hadoop 2735 12 14 81
Apache Triplesec 375 9 9 32
Mobicents-parlay-ra 2813 6 10 18
mx4j 891 8 13 40
OpenJMX 313 7 11 14
pfc 541 5 13 7
Spumoni 75 5 10 3
source code, and parser modules performing sophisticated,
sta
tic code analyses for matching a single feature type.
We originally applied this approach in two stages to a
set of ﬁve benchmark applications with partly known and
agreed design pattern detection results. In stage one, pat-
tern deﬁnitions were iteratively optimized to the best pos-
sible extent and we were able to achieve high recall and
precision rates of 96-100% for the ﬁrst three systems. In
stage two, we used the pattern catalog optimized in stage
one without further customization and found that the qual-
ity of results decreased. We reached 94% precision and 98%
recall for one system, for the last system we had several false
and missing recognitions, but could not compute recall and
precisions due to an insuﬃcient baseline.
To detect patterns in the 36 open source projects, we used
our existing catalog of pattern deﬁnitions [25]. However, the
size, complexity, and scope of the datasets used in this study
was far more extensive that that of our previous study, and
so we discovered design pattern mechanisms not covered by
the existing catalog. As a result, we tweaked the perfor-
mance in order to handle the larger systems, updated fea-
ture types and pattern deﬁnitions in order to make them
more eﬃcient, and updated the parsers so that they could
handle the latest Java versions correctly. We made the de-
cision to report results from the State and the Strategy pat-
tern together because their structural representation is hard
to diﬀerentiate. We also completely omitted results for the
Abstract Factory and the Facade pattern as we felt that
additional rules and evaluation were needed to detect thesecorrectly. As a result, our pattern detection algorithm was
run for 20 GoF design patterns.
Results from the 36 projects are reported in Table 1. Col-
umn 5, labeled ‘Pattern Types’, reports the number of dis-
tinct design patterns found in each of the projects. Numbers
range from zero, meaning that no patterns were detected, to
18, meaning that 18 of the possible 20 pattern types were
discovered.
2.4 ComputingOverlap
Thetacticclassiﬁeranddesignpatterndetectoralgorithms
wererunindependentlyacrosseachoftheselected36projects.
The classes detected by the tactic classiﬁer were compared
against those detected by the design pattern detector in or-
der to identify tactic/pattern overlaps. If a pattern and
tactic shared at least one class then a candidate overlap was
declared. For example, in one case, a decorator design pat-
tern added heartbeat functionality to an http service, and
was identiﬁed as a decorator/heartbeat instance despite the
fact that only a single class overlapped.
ThisoverlapanalysisproducedtheresultsreportedinFig-
ure 3. These results show the un-vetted occurrences of each
pattern within each of the tactics following the automated
overlap analysis. The numbers in each cell represent the
percentage of times a tactic of the given type overlapped
with the speciﬁed class. For example, the top left hand cell
shows that in 60% of the occurrences of the redundancy
tactic, there was overlap with a class from the adapter pat-
tern. Similarly, the bridgepattern overlapped with the re-
dundancy tactic in 25% of its occurrences. It is important to
remember that these are raw values computed automatically
by our tools and therefore not guaranteed to be accurate un-
til they are evaluated in the next phase.
The color scheme of Figure 3, shows stronger overlaps
in red or orange, and lesser ones in paler colors. It high-
lights several interesting trends. Certain design patterns are
clearly used more prevalently in tactics than others. For
example, adapter,ﬂyweight, memento andstrategy are the
four most commonly occurring patterns. This is not really
surprising as these patterns contribute to scalability, ﬂex-
ibility, and state restoration, all of which are important in
high-performance systems. Unsurprisingly there are no indi-
vidual tactics that implement a high percentage of patterns.
Column 6 in Table 1 shows the number of overlapping
tactic/pattern pairs per project. These numbers range from
zero, inprojectsinwhichnodesignpatternsoverlappedwith
the identiﬁed tactics, to 130 in the OpenSubsystem project.
Given the hugesearchspaceof classesin theseopen source
systems, our automated approach signiﬁcantly reduces the
amount of human eﬀort needed to ﬁnd tactic/pattern over-
laps. Nevertheless it is still necessary to manually inspect
the results in order to eliminate the incorrectly identiﬁed
instances. This process is described in Section 3.
3. ASSESSMENTPROCESS
As previously discussed, the potential beneﬁts of utiliz-
ing architectural tactics are often only fully realized when
the tactics are ﬁne-tuned to meet project speciﬁc needs. In
the following sections of this paper we report on three dif-
ferent tactic types, and the design patterns that were used
to implement them. These tactics are scheduling, resource
pooling, and heartbeat. We do not claim to have identiﬁed
all possible patterns that could be used to implement these
4Adaptor
Bridge
Builder
Chain of Resp.
Command
Composite
Decorator
Factory Method
Flyweight
Interpreter
Iterator
Mediator
Memento
Observer
Prototype
Proxy
Singleton
State/ Strategy
Template
Visitor
Ac
tive Redundancy0.600.25 0.15 0.00 0.00 0.10 0.00 0.10 0.40 0.00 0.05 0.00 0.35 0.00 0.20 0.10 0.10 0.50 0.30 0.00
Audit 0.67 0.42 0.25 0.00 0.00 0.00 0.00 0.17 0.58 0.00 0.00 0.00 0.58 0.00 0.33 0.17 0.08 0.67 0.50 0.00
Authenticate 0.69 0.26 0.23 0.09 0.00 0.11 0.11 0.49 0.77 0.00 0.06 0.00 0.69 0.06 0.26 0.14 0.29 0.51 0.37 0.00
CheckPointing 0.56 0.33 0.17 0.06 0.00 0.00 0.06 0.17 0.44 0.00 0.00 0.06 0.33 0.00 0.17 0.06 0.06 0.50 0.17 0.00
HeartBeat 0.63 0.31 0.25 0.00 0.00 0.00 0.06 0.38 0.50 0.00 0.00 0.00 0.38 0.13 0.06 0.19 0.25 0.56 0.44 0.00
Kerbrose 0.13 0.00 0.00 0.00 0.00 0.00 0.00 0.13 0.38 0.00 0.00 0.00 0.13 0.00 0.00 0.00 0.00 0.13 0.00 0.00
Load Balancing 0.35 0.35 0.13 0.04 0.00 0.04 0.04 0.17 0.48 0.00 0.13 0.04 0.35 0.00 0.09 0.13 0.04 0.30 0.30 0.00
PBAC 0.64 0.41 0.18 0.23 0.00 0.09 0.18 0.36 0.68 0.00 0.09 0.05 0.68 0.05 0.32 0.14 0.18 0.55 0.45 0.00
PingEcho 0.57 0.24 0.19 0.00 0.00 0.00 0.00 0.24 0.43 0.00 0.00 0.00 0.33 0.00 0.05 0.10 0.14 0.38 0.24 0.00
Resource Pooling 0.69 0.34 0.29 0.11 0.00 0.11 0.09 0.34 0.74 0.00 0.09 0.03 0.66 0.06 0.26 0.31 0.26 0.66 0.43 0.06
RBAC 0.53 0.40 0.20 0.17 0.00 0.10 0.10 0.33 0.70 0.00 0.07 0.00 0.67 0.07 0.33 0.27 0.30 0.63 0.50 0.03
Scheduler 0.74 0.35 0.26 0.10 0.00 0.03 0.06 0.39 0.74 0.00 0.06 0.03 0.58 0.03 0.29 0.23 0.16 0.68 0.39 0.03
Session 0.38 0.25 0.13 0.17 0.00 0.08 0.13 0.21 0.38 0.00 0.08 0.00 0.33 0.00 0.21 0.21 0.04 0.33 0.33 0.00
Figure 3: Overlaps produced automatically and reported prior to human evaluation
tactics, after all it is likely that a creative developer could
ﬁgure out a way to incorporate almost any design pattern in
any tactic. However, what we do claim is that we have iden-
tiﬁed many common uses of design patterns in the studied
tactics.
We adopted a multi-phase process that was designed to
identify correct instances of patterns for deeper analysis.
Our process involved initially skimming the pattern instance
and eliminating obviously incorrect classiﬁcations (i.e. the
pattern detector claimed a group of classes to be the heart-
beat pattern where clearly they were not). Analysis con-
tinued until we found three correct uses of the pattern in
the tactic, ran out of cases to evaluate, or searched through
10 tactic/pattern instances without ﬁnding a correct use of
the pattern. Instances that were not initially ruled out were
thencheckedmorecarefullytoconﬁrmthattheyrepresented
the claimed pattern and tactic. As part of this process we
evaluated approximately 300 instances, and attempted to
disperse our eﬀorts equally across the diﬀerent tactic/pat-
tern pairs. The following steps were then followed:
1. For each correct tactic/pattern instance we evaluated
the pattern to answer the question ‘what purpose does
this pattern play in the tactic?’
2. In cases where the same pattern was implemented for
diﬀerent purposes we studied additional pattern in-
stances until we gained understanding of the multiple
contributions the pattern played in the tactic.
3. For each pattern/purpose pair in a tactic, we con-
structed a generalized class diagram, capturing the
classes and their associations needed to implement the
design pattern in the context of the tactic.
4. Finally we documented speciﬁc factors which might
trigger a decision to utilize a speciﬁc pattern in the
tactic.
On average we found that approximately one tactic/pat-
tern pair was correct for every ﬁve evaluated. This is ex-
pected, given the precision of the two underlying tools, plusthe additional step of combining results [24,25]. The tac-
tic/pattern overlaps for which we identiﬁed correct uses of
both the pattern and tactic are depicted in Figure 3 with a
bold border.
4. TACTIC # 1: SCHEDULING
The ﬁrst tactic studied was the scheduler . This tactic is
commonly adopted to improve system performance in the
face of resource contention. It is deﬁned in terms of ele-
ments to be scheduled, the scheduler responsible for schedul-
ing them, and a scheduling policy such as FIFO (First in
ﬁrst out), ﬁxed-priority, or dynamic priority scheduling [4,
6,31]. Bachman et al. identify ﬁve independent parameters
that must be considered when designing and implementing
a scheduler. These include the execution times of units of
concurrency, arrival distribution, number of units of con-
currency, number of processors, and number of processors.
These parameters are used to ﬁne-tune the performance of
the scheduler in order to satisfy a response measure such as
worst-case latency; however they say nothing about how the
scheduler must actually be implemented. As with all design
solutions, there are numerous trade-oﬀs to consider. In the
case of the scheduler these center around latency, scalability,
and code maintainability.
Weidentiﬁedseveraldesignpatternswhichwereusedquite
prevalently to implement the scheduler tactic. These in-
cludedadaptor,bridge,composite, ﬂyweight, memento ,ob-
server,proxy, andstrategy. To more fully understand the
purpose of these patterns in the tactic, we analyzed their
implementations following the steps outlined in section 3.
As a result, six primary reasons were identiﬁed for adopt-
ingdesignpatternsinschedulerimplementations. Wetermed
thesevariability points because, in most cases, they could be
added as additional features to augment the basic behavior
of the tactic. Each variability point is described below.
1. Many tasks: If the scheduler is responsible for schedul-
ing a large number of tasks, incurred memory costs may
be high and it may be necessary to minimize memory us-
5C
oncreteTask
-
 initialSettings
+
 taskOperation()S
cheduler
+
 schedule()T
ask
+
 taskOperation()T
askFactory
+
 createTask()t
asks
(a) Many Tasks: FlyweightC
oncreteTask
+
 taskOperation()«
interface»
T
ask
+
 taskOperation()S
cheduler
+
 schedule()
T
askProxy
+
 taskOperation()
(b) High Resource Demand: Proxy
T
askFactory
-
 state
+
 createTaskState()
+ 
setTaskState()T
askState
-
 state
+
 getState()
+ 
setState()S
cheduler
T
askState
(c) Stateful tasks: MementoT
askProgressMonitor
+
 update()T
ask
+
 notify()
+ 
register()
C
oncreteTask
+
 notify()
+ 
register()P
rogressMonitor
+
 update()
(d) Task Monitoring: Observer
T
askProgressMonitor
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCancled()
+ started()
P
rogressDistributor
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCancled()
+ started()P
rogressMonitor
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCancled()
+ started()
(e) Hierarchy of Monitors: CompositeS
cheduler
+
 getTaskID()
+ 
schedule()«
interface»
T
ask
+
 getTaskID()
+ 
taskOperation()
C
oncreteTask
+
 getTaskID()
+ 
taskOperation()C
oncreteTask2
+
 getTaskID()
+ 
taskOperation()t
ask
(f) Many task types: Bridge
Figure
4: Design Patterns used to address variability points in the Scheduler Tactic
age. Tasks share intrinsic state such as task priority or task
type, whilealsoexhibitingindividualpropertiessuchasstart
time, resources required, and so on. The ﬂyweight pattern
reduces the memory resource requirements, and also reduces
time needed to start a task. This concept is generalized in
Figure 4(a).
2. High resource demand: When individual tasks have
high resource demands (e.g. high memory), it is more eﬃ-
cient to create them immediately prior to use and destroy
them immediately afterwards. The proxypattern can be
used so that a proxy object serves as a stand-in for the task
while it waits in the queue. The scheduler is unaware that
the proxy exists. However, the proxy creates, invokes, and
destroys the task as soon as it is scheduled for execution.
This is depicted in Figure 4(b).
3. Stateful tasks: When the state of the task needs to be
preserved between scheduled runs, the memento pattern
is used to preserve state at the end of a run, and restoreprevious state at the beginning of the next run. This is
depicted in Figure 4(c).
4. Task monitoring: Tasks often need to be monitored to
ensure that they are active and progressing. The observer
pattern allows a task progress monitor (which could be the
scheduler itself) to register as an observer of the task and re-
ceive status update notiﬁcations. In more complex systems,
it may be necessary to have hierarchies of monitors. In this
case the composite pattern can be used to compose mon-
itors into hierarchies. These uses of patterns are depicted in
Figures 4(d) and 4(e) respectively.
5. Remote tasks: Theproxypattern can be used to
provide a local object as a stand-in for a task that is running
remotely. This is not shown in the Figure.
6. Multiple task types: When a scheduler is responsible
for managing multiple types of tasks i.e. MapTask, Reduc-
eTask, DFSTask, etc, and new types of tasks may be added
in the futureand/orbehaviorof thosetasksmay changeover
6M
any tasks 
H
igh resource demand 
S
tateful tasks 
T
ask 
mo
nitoring S
imple 
mo
nitoring 
C
omplex 
mo
nitoring 
R
emote task 
M
ultiple task types S
cheduling F
lyweight 
P
roxy 
M
emento 
O
bserver 
C
omposite 
P
roxy 
B
ridge 
A
dapter M
ulti-stepped 
sc
heduling 
Figure 5: Decision tree for the scheduler tactic
La
zy load 
S
ingle point 
of
 access 
C
omplex steps 
R
eset before use R
esource 
po
oling P
rototype 
S
ingleton 
S
trategy 
F
actory Method 
C
hain of responsibility 
M
emento N
ew resource 
ty
pes likely M
ultiple kinds 
of
 resources T
emplate 
P
rototype O
R 
Figure 6: Decision tree for Resource Pooling
time,
then the bridgepattern can be used to create a ﬂexi-
ble environment in which both the tasks and their behavior
can change independently. This is depicted in Figure 4(f).
When there are multiple types of tasks to be scheduled, and
diﬀerent types of tasks involve diﬀerent steps (i.e. retrieving
data, checking priorities etc) then the adapter pattern can
be used to adapt each task with the required steps. In this
case a generic schedule method is invoked for all tasks and
this method is then adapted according to task type.
The identiﬁed patterns used in the scheduler are modeled
as the decision tree shown in Figure 5. A developer needing
to implement the scheduler tactic could use the decision tree
to examine the variability points of the tactic with respect
to the speciﬁc project.
5. TACTIC # 2: RESOURCE POOLING
The second tactic evaluated was resource pooling. This
tactic allows limited resources to be shared between clients
if neither exclusive nor continual access is needed to the re-
source. Pooling is typically used to share threads, database
connections, sockets, and other such resources [5]. Based on
our analysis of resource pooling implementations, we iden-
tiﬁed several design patterns which were used quite preva-
lently to implement the tactic. These included prototype,
singleton, template method ,strategy,factory method ,chain
of responsibility , andmemento . The following variability
points were identiﬁed.
1. Lazy load: Shared resources are typically created ei-
ther at start-up time or upon demand. When the cost of
creating a resource in the standard way is high, the proto-W
rap around 
P
iggy backing 
D
ifferent monitor types 
M
ass creation H
eartbeat D
ecorator 
T
emplate 
C
omposite 
B
ridge 
F
lyweight M
any 
mo
nitored 
components H
eartbeat 
mo
nitor O
bserver 
S
tate M
any tasks 
Figure 7: Decision tree for Heartbeat
typ
epattern can be used to eﬃciently create a clone of a
prototypical object.
2. Single point of access: Access to a resource pool is
managed by a poolerrole. If many diﬀerent components
need to access the pool there can be signiﬁcant overhead for
establishing and managing a sharing scheme. The problem
can be addressed through using singleton to ensure that
there is only one instance of the pooler at runtime.
3. Multiple kinds of resources: When there are multi-
ple types of resources (i.e. thread pooling, connection pool-
ing, session pooling), and if the types are stable, i.e. it is
unlikely that new types will be introduced, the template
method can be used to customize resource management ac-
cording to resource type. When new types are expected to
be introduced the factory pattern can be used to create the
pools and their associated resources (sometimes referred to
as ponds), while the strategy pattern can be used to select
the appropriate factory method according to type.
4. Complex steps: When the task of creating, managing,
and using a resource pool is complex, the chain of respon-
sibility pattern can be used to decouple the sender of a
request from its receiver. For example a series of requests
for checking the existence of the pool, checking the number
of objects, or checking the maximum allowed number of ob-
jects, can be passed as a command along a chain of objects
until the request is handled.
5. Reset before use: A resource pool recycles resources.
Before a recycled resource can be reused it needs to be re-
set to its original state. Use either memento to reset the
resource to its original state, or prototype to create a new
clone before each use.
These variability points and their associated design solu-
tions are modeled in the decision tree shown in Figure 6.
However, due to space constraints we do not provide class
diagrams for each design pattern.
6. TACTIC # 3: HEARTBEAT
The third tactic studied was the heartbeat tactic. This
is used to monitor the availability of a critical component.
The monitored component emits a periodic heartbeat mes-
sage while another component listens for the message. The
originalcomponentisassumedtohavefailediftheheartbeat
fails [6].
Our study identiﬁed six diﬀerent patterns used to im-
plement the heartbeat. These included decorator, template
method,observer,composite, Bridge, ﬂyweight, and state.
From these we derived the following variability points.
7«
StatefulTasks»
T
askState
-
 state
+
 getState()
+ 
setState()
«
HighResourceD...
T
askProxy
+
 taskOperation()T
askProgressMonitor
«
ComplexMonitoring»
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCanceled()
+ started()
«
TaskMonitoring»
+
 update() C
oncreteTask
-
 initialSettings
+
 taskOperation()
«
MultipleTaskTypes»
+
 getTaskID()
«
TaskMonitoring»
+
 notify()
+ 
register()«
MultipleTaskTypes»
C
oncreteTask2
-
 initialSettings
+
 taskOperation()
«
MultipleTaskTypes»
+
 getTaskID()
«
TaskMonitoring»
+
 notify()
+ 
register()S
cheduler
+
 createTask()
+ 
schedule()
+ monitorTask()P
rogressMonitor
«
ComplexMonitoring»
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCanceled()
+ started()
«
TaskMonitoring»
+
 update()P
rogressDistributor
«
ComplexMonitoring»
+
 addMonitor()
+ 
done()
+ removeMonitor()
+ setCanceled()
+ started()T
askFactory
«
StatefulTasks»
-
 state
«
ManyTasks, StatefulTasks»
+
 createTask()
«
StatefulTasks»
+
 createTaskState()
+ 
setTaskState(TaskState)T
ask
+
 taskOperation()
«
MultipleTaskTypes»
+
 getTaskID()
«
TaskMonitoring»
+
 notify()
+ 
register()
T
askStatet
asks
Figure 8: A reference model for the scheduler tactic. Variabilit y points are marked as stereotypes. These
stereotypes are used to reduce the model to deliver only the functionality speciﬁed by the user.
1. Wrap around: The heartbeat tactic often needs to be
added onto other services or functions which have availabil-
ity concerns. The decorator pattern can be used to wrap
those services with heartbeat functionality without the need
to modify the services themselves.
2. Piggybacking: Sending periodic messages such as a
heartbeat can add signiﬁcant communication overhead and
impact system performance. The heartbeat can therefore
be piggybacked on other messages such as logging messages
used for check-pointing. The template pattern can be used
to construct a message which carries diﬀerent kinds of infor-
mation.
3. Heartbeat monitor: When multiple components emit
heartbeats that need monitoring, the observer pattern can
be used to register one or more monitors with the heartbeat
emitter. In more complex systems where hundreds or thou-
sands of components are being monitored, the composite
pattern can be used to establish a hierarchy of monitors. In
this case a low level monitor checks the health of a group of
threads, while its own health is checked by a higher level of
monitor.
4. Diﬀerent monitor types: When diﬀerent types of
componentarebeingmonitored, thefaultmonitormustsup-
port diﬀerent monitoring techniques (HTTPS, HTTP, FTP,
etc). In this case, the Bridge pattern can be used to mon-
itor diﬀerent types of heartbeat messages, and also check
the health of diﬀerent heartbeat senders in ways that are
appropriate for their type.
5. Mass Creation: When the heartbeat connection ser-
vice requires mass creation of the same service speciﬁcation
for many clients, the Flyweight pattern can be used to cre-
ate multiple objects in an eﬃcient way. For example, this
approach is appropriate if a HTTP connection is heartbeat
enabled in a given project, there are many requests for such
connections, and connections and heartbeat services exhibit
common properties across all the client requests, then ﬂy-weight pattern can be used to create and share multiple
HeartbeatHTTP objects.
6. Many tasks: The heartbeat receiver’s responsibilities
vary based on the status of heartbeat sender. For example
the receiver could be in (i) steady-state, i.e. receiving reg-
ular messages at predeﬁned intervals from the sender, (ii)
compromised-state, when one or more senders is failing to
transmit, or in (iii) recovery-state when steps are taken to
remediate the problem of the unavailable sender. The state
pattern can be used to manage these various states.
7. REFERENCE MODELS
In sections 4 - 6 we presented individual patterns imple-
mented in scheduling, resource pooling, and heartbeat pat-
terns respectively. We also presented a decision tree for each
of the tactics, depicting the factors driving the adoption of
each design pattern.
These factors and their associated implementation solu-
tions can be seen as variability points of the tactic. As
in a product line, features can be mandatory, optional, or
variants. Mandatory features represent the essence of the
product. In the case of architectural tactics, the core roles,
responsibilities, and interactions that deﬁne the tactic can
be seen as its mandatory features [29]. For example, in the
scheduling tactic, there must be a scheduler and one or more
schedulees , while in the heartbeat tactic there must mini-
mally be an emitterand areceiver. Optional features are
those features which can be added to the product to bring
additional value. Finally a variant feature is an abstrac-
tion of a group of mandatory or optional features, which
provides alternate methods of delivering the functionality.
In the case of architectural tactics, the identiﬁed variabil-
ity points of the tactic represent a mixture of optional and
variant features.
Figure 8 shows the reference model we developed for the
8Da
ta NodeN
ame Node
T
ask TrackerSec
ondary 
Nam
e Node
Job
 TrackerSch
eduler
T
ask Tracker
T
ask Tracker
T
ask Tracker
T
ask TrackerDa
ta Node
Da
ta Node
Da
ta Node
Da
ta NodeDF
S Layer Para llelization Layer
Figure 9: The high level architecture of the Parallel
Computing
Infrastructure used in our Case Study
M
any tasks 
H
igh resource demand 
S
tateful tasks 
T
ask 
mo
nitoring S
imple 
mo
nitoring 
C
omplex 
mo
nitoring 
R
emote task 
M
ultiple task types S
cheduling F
lyweight 
P
roxy 
M
emento 
O
bserver 
C
omposite 
P
roxy 
B
ridge 
A
dapter 
3 
3 
3 
3 
3 
M
ulti-stepped 
sc
heduling
Figure 10: In this case study, the developer selects
de
sired variability points for the PCI system
scheduler tactic. All of the design patterns discussed in sec-
tion 4 are integrated into this model. However, we do not
claim that this is the only possible way of combining the
design patterns into a holistic solution, nor do we claim that
it is the best way. We merely present this solution as one
possible design given the variability points of the tactic and
their related design patterns.
This reference model can help developers to implement
the tactic. Although our longer-term goal is to automate the
generation of a customized reference model from a decision
tree, we currently provide only the static reference model,
where each variability point is labeled with a unique stereo-
type. This is depicted in Figure 8 which shows stereotypes
attached to classes, attributes, and to methods. Stereotypes
on attributes and methods are shown above the element and
refer to all elements underneath. A stereotype on a class
means that the whole class with all its attributes and meth-
ods contributes to a single variability point and could simply
be removed if this variation is not part of the desired conﬁg-
uration. For classes that contribute to multiple variations,«Mult
iStepSchedul,
     Remot
eTask» 
TaskProxy
+
 taskOperation()T
askProgressMonitor
«
TaskMonitoring»
+
 update()
C
oncreteTask
-
 initialSettings
+
 taskOperation()
«
MultipleTaskTypes»
+
 getTaskID()
«
TaskMonitoring»
+
 notify()
+ 
register()S
cheduler
+
 createTask()
+ 
schedule()
+ monitorTask()P
rogressMonitor
«
TaskMonitoring»
+
 update()T
askFactory
«
ManyTasks»
+
 createTask()T
ask
+
 taskOperation()
«
MultipleTaskTypes»
+
 getTaskID()
«
TaskMonitoring»
+
 notify()
+ 
register()t
asks
Figure 11: In this case study, the reference model is
mo
diﬁed to retain only desired variability points
the elements inside the class are stereotyped and will be re-
moved if not needed in the desired conﬁguration. If these re-
ductions result in elements without attributes and methods,
then the class itself must be removed and its associations
replaced with associations that connect source and target
directly. All core elements, e.g., Task, ConcreteTask, task-
Operation(), initialSettings, are not stereotyped and will ac-
cordingly form the mandatory elements of all conﬁgurations,
even if all variations are removed.
8. AN ILLUSTRATIVEEXAMPLE
In this section we present an illustrative example of a
system, which we will refer to as Parallel Computing In-
frastructure (PCI) . PCI is a development environment in
which developers can write and/or run parallelized comput-
ing tasks. A high-level architectural view is depicted in Fig-
ure 9. This example is loosely built upon the architecture
and implementation of the Hadoop system [1] and the Mi-
crosoft Compute Cluster Pack [3]. PCI has two main layers,
the distributed ﬁle system (DFS) layer and the paralleliza-
tion layer. In the DFS layer, Datanodes components are
responsible for managing and storing data chunks while Na-
meNode is a central control point responsible for managing
the ﬁle system namespace and controlling access by external
clients. It keeps track of datachunks managed by datanode
and also is responsible for distributing replicated data. The
parallelization layer is designed to execute tasks through a
map reduce paradigm. Operations are submitted by a client
andthenstartedby jobtracker .Jobtracker isalsoresponsible
for creating a set of taskTrackers to track and report on task
status. Job scheduling is a critical function of process par-
allelization so that the system can achieve high throughput
and low response times. The system is expected to handle
thousands of concurrent requests.
To explore the possible design space of the scheduler, the
architect and/or developers use the scheduler decision tree
from section 4, and mark the variability points of interest.
Their choices are summarized in Figure 10. The ﬁrst key
characteristicofthePCIsystemisitneedstoscheduleavery
large number of tasks. We therefore check oﬀ Many Tasks to
9increase parallelization and decrease the performance time.
T
hePCIarchitectureiscloud-basedinwhichphysicalredun-
dancy and parallelization are achieved through distributing
tasks on diﬀerent machines. The scheduler therefore needs
to manage remote tasks running in diﬀerent address spaces.
Wethereforecheckoﬀ Remote Task. Schedulinguserdeﬁned
tasks requires customized initialization across the Map
Reduce schema, therefore we check multiple task types and
multi-stepped scheduling. Finally we opt for simple monitor-
ingof tasks and check simple monitoring. Armed with these
decisions, the developer utilizes the stereotypes provided in
the reference model to remove unwanted parts of the design
and customize the reference model for the PCI project. The
end result is shown in Figure 11.
9. THREATS TO VALIDITY
There are several primary threats to the validity of this
work. The tactic/pattern overlap datasets were created us-
ing two data-mining techniques, neither of which is 100%
precise. Ommissionerrorswerereducedbysettingthethresh-
olds in both mining tools quite low in order to favor high
recall over high precision. However this also increased the
manual evaluation eﬀort which could have resulted in failure
to identify instances of correct tactic/pattern implementa-
tions. As a result, we clearly cannot claim that we have
identiﬁed all common cases of design pattern usage in archi-
tectural tactics. Instead we claim to have identiﬁed many of
the common uses. Commission errors were reduced signiﬁ-
cantly by manually inspecting the resulting overlaps. This
task was performed by one author of this paper and vali-
dated by the other two. Nevertheless, this is a non-trivial
task which sometimes involves deep understanding of the
source code. While we are conﬁdent that the use of patterns
was correctly identiﬁed, it is possible that we misinterpreted
the intent of using the pattern in a particular context. This
danger was somewhat mitigated by examining multiple in-
stances of each pattern use.
Second, our work studies the actual use of design pat-
terns for implementing architectural tactics in open source
systems. However, just ﬁnding a pattern use does not nec-
essarily mean it was used correctly. Developers may choose
less than eﬀective design solutions. To mitigate this problem
we only included a pattern in our framework if we found it
used in a similar way across three or more systems, or else
found its use particularly convincing. Given the nature of
open-source development, a pattern that is used in several
systemssuggestscommunityconsensusthatit isa solididea.
Finally, an additional threat to validity arises in the con-
struction of the reference models. These models represent
a synthesis of designs found across multiple projects as well
as standard knowledge of design patterns available in text
books and other material [16]. We have presented our ap-
proach as applicable to a broad range of patterns; however
due to the time-consuming nature of our study, we have
only developed such models for the three tactics discussed
in detail in this paper. Based on our study of the other tac-
tics described in this paper, we see no reason to believe this
approach is not generalizable.
10. RELATED WORK
The concepts of architectural styles [27],(also referred to
as architectural patterns) [9], tactics [4,6,18], and designpatterns [16] have a long and respected history. Bass de-
scribes tactics as architectural building blocks from which
architectural patterns such as layers, pipe-and-ﬁlter, black-
board, and Model-View-Controller are constructed [6]. Nu-
merous authors have shown the usefulness of architectural
tactics for addressing performance, reliability, maintainabil-
ity and other such quality concerns [26].
Some researchers have explored the interactions between
architectural tactics and architectural patterns. For exam-
ple, HarrisonandAvgeriousconductedastudyentitled‘How
do architecture patterns and tactics interact?’ [19]. How-
ever, their study focused on the contribution and interaction
of architectural tactics to higher level patterns (i.e. styles),
and did not investigate the use of design patterns for imple-
menting architectural tactics. Champagne and Gagne de-
scribe an approach that utilizes a design assistant to auto-
mate architectural tactics [10], while De Bruin et. al. de-
scribe a top down decompositional approach for deriving an
architecture from tactics [13]. Neither of these approaches
explores the speciﬁc use of design patterns to implement
architectural tactics.
Numerous architectural assessment techniques such as the
Attribute Driven Design [31] and Quality-Driven Architec-
ture development [8] for designing architectural solutions;
however such approaches focus more upon high-level archi-
tectural design drive by quality attributes.
Other authors have presented techniques for improving
designs through adopting design patterns [21]. Gueheneuc
et al. proposed a recommender system which recommends
which design patterns might be useful to support speciﬁc
problems contexts [17].
Finally, although we did ﬁnd some practice-oriented web-
sites which addressed the implementation of various tactics,
to the best of our knowledge, this paper is the ﬁrst attempt
to systematically document developers actual uses of design
patterns in tactics.
11. CONCLUSIONS
This paper has presented the results of an extensive study
we conducted into the industrial use of design patterns for
implementing architectural tactics. Our study revealed in-
teresting usage trends from which we were able to identify
variability points, associate speciﬁc design pattern solutions
with each variability point, and construct a tactic-speciﬁc
reference model. In its current form a developer can man-
ually transform the reference model into a customized class
diagramshowingonlythedesiredfeaturesofthetactic. This
provides guidance to developers as they implement architec-
tural tactics.
In future work we plan to adopt concepts from the fea-
ture modeling domain so that each tactic and its variability
points will be speciﬁed as a feature model from which we can
automatically generate a class diagram. We will also extend
our work on reference models by adding dynamic views.
The work in this paper examined a broadly representative
set of tactics and patterns. However due to the time and
eﬀort needed to manually evaluate pattern/tactic overlaps
we identiﬁed variability points for the scheduler ,resource
pooling, and heartbeat tactics only. In our ongoing work we
thereforeintendtodevelopreferencemodelsforafarbroader
range of tactics.
1012. ACKNOWLEDGMENTS
Th
e work in this paper was partially funded by the US
National Science Foundation grant # CCF-0810924, and by
the Austrian Science Fund (FWF): M1268-N23.
13. REFERENCES
[1]Apache-Hadoop Design documents .
http://hadoop.apache.org
/common/docs/current/hdfs-design.html.
[2] Apache ofbiz. http://ofbiz.apache.org/.
[3]Microsoft Compute Cluster Pack.
http://msdn.microsoft.com/en-
us/library/cc136762(v=vs.85).aspx˘ a.
[4] F. Bachmann, L. Bass, and M. Klein. Deriving
Architectural Tactics: A Step Toward Methodical
Architectural Design. Technical Report, Software
Engineering Institute, 2003.
[5] P. Bachmann. Deferred cancellation: a behavioral
pattern. In Proceedings of the 15th Conference on
Pattern Languages of Programs, PLoP ’08, pages
18:1–18:17, New York, NY, USA, 2008. ACM.
[6] L. Bass, P. Clements, and R. Kazman. Software
Architecture in Practice. Adison Wesley, 2003.
[7] K. Birman. Security options for distributed settings.
InGuide to Reliable Distributed Systems, Texts in
Computer Science, pages 543–569. Springer London,
2012.
[8] J. Bosch. The Design and Use of Software
Architectures . Addison-Wesley, 2000.
[9] F. Buschmann, R. Meunier, H. Rohnert,
P. Sommerlad, and M. Stal. Pattern-oriented software
architecture: a system of patterns. John Wiley & Sons,
Inc., New York, NY, USA, 1996.
[10] R. Champagne and S. Gagne. Towards automation of
performance architectural tactics application. In
Proceedings of the IEEE/IFIP Conference on Software
Architecture, 2011.
[11] J. Cleland-Huang, R. Settimi, X. Zou, and P. Solc.
The detection and classiﬁcation of non-functional
requirements with application to early aspects. In RE,
pages 36–45, 2006.
[12] J. Cleland-Huang, R. Settimi, X. Zou, and P. Solc.
Automated detection and classiﬁcation of
non-functional requirements. Requir. Eng. ,
12(2):103–120, 2007.
[13] H. de Bruin and H. van Vliet. Top-down composition
of software architectures. In ECBS, pages 147–, 2002.
[14] D.E.Perry and A.L.Wolf. Foundations for the study of
software architecture. SIGSOFT Software Eng. Notes ,
17(4):40–52, 1992.
[15] S. Eick, T. Graves, A. Karr, J. Marron, and
A. Mockus. Does code decay? assessing the evidence
from change management data. Software Engineering,
IEEE Transactions on, 27(1):1 –12, jan 2001.[16] E. Gamma, R. Helm, R. Johnson, and J. Vlissides.
Design patterns, software engineering, object-oriented
programming. Addison-Wesley, 1994.
[17] Y. Gueheneuc and M. Rabih. A simple recommender
system for design patterns. In Proceedings of the 1st
European PLoP Focus Group on Pattern Repositories,
2007.
[18] R. Hanmer. Patterns for Fault Tolerant Software.
Wiley Series in Software Design Patterns, 2007.
[19] W. Harrison and H. Ossher. Subject-oriented
programming: a critique of pure objects. SIGPLAN
Not., 28(10):411–428, Oct. 1993.
[20] C. Izurieta and J. M. Bieman. How software designs
decay: A pilot study of pattern evolution. In ESEM,
pages 449–451, 2007.
[21] J. Kerievsky. Refactoring to Patterns . Addison-Wesley,
2005.
[22] M. Mirakhorli and J. Cleland-Huang. A
decision-centric approach for tracing reliability
concerns in embedded software systems. In
Proceedings of the Workshop on Embedded Software
Reliability (ESR), held at ISSRE10, November 2010.
[23] M. Mirakhorli and J. Cleland-Huang. Tracing
architectural concerns in high assurance systems: (nier
track). In Proceedings of the 33rd International
Conference on Software Engineering, pages 908–911,
2011.
[24] M. Mirakhorli, Y. Shin, J. Cleland-Huang, and
M. Cinar. A tactic centric approach for automating
traceability of quality concerns. In International
Conference on Software Engineering, ICSE (1), 2012.
[25] G. Rasool and P. M ¨ader. Flexible design pattern
detection based on feature types. In ASE, pages
243–252, 2011.
[26] J. Scott and R. Kazman. Realizing and reﬁning
archituctural tactics: Availability. Technical Report,
CMU/SEI-2009-006, ESC-TR-009-006 , 2009.
[27] M. Shaw and D. Garlan. Software Architecture:
Perspectives on an Emerging Discipline. In: Andrea
Zisman, Jane Cleland-Huang and Olly Gotel. Software
and Systems Traceability., Springer-Verlag., 2011.
[28] I. University of California. The sourcerer project.
sourcerer.ics.uci.edu.
[29] J. van Gurp, J. Bosch, and M. Svahnberg. On the
notion of variability in software product lines. In
WICSA, pages 45–54, 2001.
[30] J. van Gurp, S. Brinkkemper, and J. Bosch. Design
preservation over subsequent releases of a software
product: a case study of baan erp: Practice articles. J.
Softw. Maint. Evol. , 17:277–306, July 2005.
[31] R. Wojcik, F. Bachmann, L. Bass, P. Clements,
P. Merson, R. Nord, and B. Wood. Attribute-driven
design (add), version 2.0, 2006-023. 2006.
11
View publication stats