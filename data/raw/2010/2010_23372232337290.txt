PartialModels:TowardsModelingandReasoningwithUncertainty
Michalis Famelis, Rick Salay, and Marsha Chechik
University of Toronto, Canada
Abstract—Models are good at expressing information about
software but not as good at expressing modelers’ uncertainty
aboutit.Thehighlyincrementalanditerativenatureofsoftware
development nonetheless requires the ability to express uncer-
tainty and reason with models containing it. In this paper, we
buildonourearlierworkonexpressinguncertaintyusingpartial
models, by elaborating an approach toreasoningwith such
models.Weevaluateourapproachbyexperimentallycomparing
it to traditional strategies for dealing with uncertainty as well
as by conducting a case study using open source software. We
conclude that we are able to reap the beneﬁts of well-managed
uncertaintywhileincurringminimaladditionalcost.
I. INTRODUCTION
Software engineering is a highly incremental and iterative
endeavorwhereuncertaintycanexistatmultiplestagesofthe
development process. Consequently, systematic approaches
to handling uncertainty are essential throughout the software
life-cycle.
Models are used pervasively in software engineering, and
their ability to express information about different aspects of
software has been studied by many researchers [25]. How-
ever, models seldom provide the means for expressing the
uncertainty that the modeler hasabout this information. In
thispaper,by“uncertainty”wemean“multiplepossibilities”.
This notion of uncertainty is often used in behavioral mod-
eling [10], but we expand it to arbitrary modeling languages.
For example, a modeler of a class diagram may be uncertain
about which of two attributes to include in a particular class
becausetheyrepresentdifferentdesignstrategies,anditistoo
early to know which is correct.
Uncertainty can be introduced into the modeling process
in many ways: alternative ways to ﬁx model inconsisten-
cies [14], [5], [24], different design alternatives (e.g., the
above example) [26], problem-domain uncertainties [27],
multiplestakeholderopinions[18],etc.Ineachcase,thepres-
ence of uncertainty means that, rather than having a single
model, we actually have aset of possiblemodels and we are
not sure which is the correct one. Living with uncertainty
requires us to keep track of this set and use it within mod-
eling activities wherever we would use an individual model;
however,thiscanbechallengingsincemodelingactivitiesare
typically intended for individual models, not sets of them.
Also, managing a set of models explicitly is impractical as
its size might be quite large. E.g., in Sec. VI we give a case
study in which two inconsistencies lead to several hundred
possible models. On the other hand, if uncertainty is ignored
and one particular possible model is chosen prematurely, we
risk having incorrect information in the model.
Figure1. (a-f)Sixalternativedesignsforapeer-to-peerﬁlesharingsystem;
(g) a partial modelM efor the six alternatives.
Our approach to handling uncertainty is to use annotations
with well-deﬁned semantics that change a model into apar-
tialmodel, i.e., one that compactlyyet preciselyencodes the
entire set of possible models. This representation allows us
to work with a set of models as if it were a single model
and do reasoning efﬁciently with all the possible models
simultaneously.
Motivating Example.To help motivate and explain our
approach, we use the example of a team engaged in the
developmentofasimplepeer-to-peerﬁlesharingapplication.
The team uses UML State Machine diagrams to model the
behavior of this application. Its states areIdle,Leeching
(downloading a ﬁle) andSeeding(sharing a complete local
copy). Downloading always starts from theIdlestate, and
SeedingandLeechingcan always be canceled. We assume
that at this stage of development, the team has not ﬁnalized978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 573
theexactbehavioroftheprogram,duetovaguerequirements
given to them by their client. The team has drafted three
alternative behavioral designs:
1) “Benevolent”:Oncetheﬁleisdownloaded, theprogram
automatically startsSeeding, as shown in Fig. 1(a).
2) “Selﬁsh”: Once the ﬁle is downloaded, the program
becomesIdle, and the user can choose whether to start
Seedingor not – see Fig. 1(c).
3) “Compromise”: Once the ﬁle is downloaded, the pro-
gram stops accepting new peers. It doesn’t discon-
nect from peers that were already connected during
theLeechingstage, but rather waits while they are
Finishingbefore it becomesIdle– see Fig. 1(e).
Theteamisalsounsurewhethertheprogramshouldallowthe
user torestarta ﬁnished download (i.e., download the ﬁle
again). The three alternatives with this feature are shown in
Fig. 1(b, d, e), respectively.
Untiltheclientclariﬁestherequirements,theteamisfaced
with uncertainty over which design decision to choose. At
this point, it is probably useful to be able toreason about
the available choices,bothtoensurethatthemodelsconform
to the desired constraints and to explore their properties. For
example,assume thatthe teamis usinga codegenerator that,
inordertoensuredeterminism,requirestwohardconstraints:
HC1: No two transitions have the same source and target.
HC2: No state is a sink.
Additionally, the team is interested in two “nice-to-have”
properties, i.e., soft constraints that are not strictly required
but are desirable:
SC1: Users can share ﬁles they already have, (i.e.,Seeding
is directly reachable fromIdle).
SC2: Userscanalwayscancelanyoperation(i.e.,everynon-
idle state has a transition toIdleoncancel()).
In order to reason effectively about any of these properties
over the entire set of alternatives, the team may want to ask
the following questions:
Does the property hold for all, some or none of the alter-
natives?This can help determine how critical some property
is in selecting alternatives when uncertainty is lifted. For
example, HC2 holds for all alternatives, and therefore is not
going to be a main reason in selecting one, once uncertainty
is resolved. Moreover, if some property does not hold for
any alternative, it may be an indication that the team needs
to revisit the designs, sooner rather than later. For example,
knowing early on that HC1 does not hold for the alternatives
in Fig. 1(c, d) may be an indication that the team needs to
reconsider the design of the “selﬁsh” scenario.
If the property does not hold for all alternatives, why is
it so?This form of diagnosis can help guide development
decisions even before uncertainty is lifted. Developers may
beinterestedinﬁndingonecounter-exampleofanalternative
where the property gets violated (or if they expected that the
property would be violated – an example where it holds) to
helpthemdebugthesetofalternatives.Forexample,locating
the alternative in Fig. 1(e) might be sufﬁcient for the team
to understand why SC2 does not hold for all alternatives.
Figure 2. Simpliﬁed metamodel used for deﬁning State Machines.
In other cases, we may prefer to calculate the entire subset
of alternatives that violate the property, to explore whether
there is a common underlying cause, as with the alternatives
in Fig. 1(c, d) that violate the hard constraint HC1.
If the property is a necessary constraint, how to ﬁlter out
the alternatives for which it gets violated?Developersmaybe
interested in this sort of property-driven reﬁnement of the set
ofalternatives.E.g.,iftheteamdecidesthatSC2isnecessary,
theyshouldbeabletorestricttheirworkingsetofalternatives
to those that satisfy it, i.e., those in Fig. 1(a-d).
Contributions.Inthispaper,weelaborateandevaluateakey
component of our broad research agenda for managing un-
certainty within models [7]: reasoning with models contain-
ing uncertainty. Speciﬁcally, we deﬁne partial models, show
how to construct them and then describe the three reasoning
operators aimed to answer the questions posed by the moti-
vating example. We then extensively evaluate our approach
by experimentally comparing it to conventional strategies for
dealingwithuncertaintyaswellasbyconductingacasestudy
of an open source software project.
Organizationoftherestofthepaper.InSec.II,weprovide
the necessary background. In Sec. III, we formally deﬁne
partial models. Sec. IV develops the core methods of reason-
ing with partial models. These are experimentally evaluated
in Sec. V and then applied to a case study in Sec. VI. We
discuss related work in Sec. VII and conclude the paper with
asummaryandsuggestionsforfurtherresearchinSec.VIII.
II. BACKGROUND
In this section, we establish the notation and introduce
concepts used in the remainder of the paper. Speciﬁcally, we
groundourapproachtograph-basedmodelinglanguagesand
propositional logic.
Modeling Formalisms.In this paper, a model is atyped
graphthatconformstosomemetamodelrepresentedbyadis-
tinguishedtype graph. Our approach is domain-independent,
inthesensethatitcanhandlearbitrarygraph-basedmodeling
languages. The deﬁnitions that follow are based on [6].
Deﬁnition 1:AgraphisatupleG=�V, E, s, t�,whereV
is a set of nodes,Eis a set of edges, ands, t:E→Vare
the source and target functions, respectively, that assign each
edge a source and target node.
Deﬁnition 2:Atyped graph(model) of typeTis a triple
�G, type, T�consisting of a graphG, a metamodelTand
a typing functiontype:G→Tthat assigns types to the
elements ofG.
Forexample,themodelsshowninFig.1aretypedwiththe
metamodel shown in Fig. 2.574Deﬁnition 3:Thescope(orvocabulary) of a model�G=
�V, E, s, t�, type, T�is the setS=V∪Eof its typed nodes
and edges.
For example, the scope of the model in Fig. 1(a) consists
of the statesIdle,LeechingandSeedingand the edges
start(),completed(), etc.
Inthefollowing,weoftenrefertonodesandedgesthatare
in the scope of a model aselementsoratomsof the model.
From models to formulas and back.To encode a model
in propositional logic, we ﬁrst map elements in its scope
intopropositionalvariablesandthenconjointhem.Toensure
that this operation is reversible, we deﬁne speciﬁc naming
conventions for the propositional variables:
•A node elementNof typeTis mapped to a proposi-
tional variable “N T”.
•An edge elementEof typeTwith source nodeN 1and
target nodeN 2is mapped to a propositional variable
“EN1N2T”.
E.g., the propositional encoding of the model in Fig. 1(b) is:
Idle_State∧Leeching_State∧Seeding_State∧
start_Idle_Leeching_Transition∧
cancel_Leeching_Idle_Transition∧
completed_Leeching_Seeding_Transition∧
cancel_Seeding_Idle_Transition∧
restart_Seeding_Leeching_Transition
Given a propositional encodingP(m), of a modelm,
we can uniquely reconstruct the modelmusing the naming
conventions. First, for every propositional whose name ﬁts
the patternN T, we create a node of typeT, namedN.
Then, for every propositional variable whose name follows
the patternE N1N2T, we create an edge of typeTbetween
the nodesN 1andN 2, with the labelE.
This propositional encoding also allows us to embed mod-
els into larger scopes, by negating all the variables not in the
original scope. For example, the model in Fig. 1(a) can be
expressed in the scope of the model in Fig. 1(b) as:
Idle_State∧...∧cancel_Seeding_Idle_Transition
∧ ¬restart_Seeding_Leeching_Transition
Using the propositional representation, we also deﬁne a
simpleformofmodel union.Assumingtwoelementswiththe
samenameareconsideredidentical,theunionoftwomodels
is a model that corresponds to a formula that is a conjunction
of all the variables in the union of their scopes. For example,
the union of the models in Fig. 1(b, d) is:
Idle_State∧...∧
restart_Seeding_Leeching_Transition∧
completed_Leeching_Idle_Transition∧
share_Idle_Seeding_Transition
Ausefulextendedscopeistheembeddingofasparsegraph
into the scope of its corresponding complete graph. In the
union of models with extended scopes, variables only appear
negated if they are negated in both input models.
Properties.We consider properties expressed in ﬁrst order
logic (FOL) or in a similar language such as the Object
Constraint Language (OCL) [15]. For example, the property
HC1 is expressed in FOL as:
∀t1, t2:Transition·(Source(t 1) =Source(t 2)∧
Target(t 1) =Target(t 2))⇔(t 1=t2)AnFOLformulacanbegroundedoverthevocabularyofa
particular model that is encoded in a propositional formula.
E.g., grounding HC1 over the vocabulary of the model in
Fig. 1(a), given that it contains 4 transition elements and that
HC1 is a universal property, results inΦ HC1– a conjunction
of 10 unique terms of the form(S i=S j∧T i=T j)⇔
Ei=E j,whereE i,jarepropositionalvariablesrepresenting
transitions,S i,j, Ti,jare variables representing their respec-
tive source and target states, and “=” signiﬁes identity.
III. PARTIALMODELPRELIMINARIES
In this section, we formally deﬁne partial models and their
associated operations. Semantically, a partial model repre-
sents a set ofclassical(i.e., non-partial) models.
PartialModels.The particular type of partiality we consider
in this paper is the one that allows a modeler to express
uncertainty as to whether particular model atoms should be
present the model. The model is accompanied by a proposi-
tional formula, calledmay formula, which explicates allow-
able combinations of such atoms.
Deﬁnition 4:APartial Modelis a tuple�G, vm, em, φ�,
whereG=��V, E, s, t�, type�is acompletetyped graph,
vm:V→ Bandem:E→ B, whereBis the set
{True,False,Maybe}, are functions for annotating atoms
inG, andφis a propositionalmayformula over the scope
S=V∪E, built as described in Sec. II.
In the above deﬁnition, an annotationTrue(False) means
that the atom must (must not) be present in the model,
whereasMaybeindicatesuncertaintyaboutwhethertheatom
should be present in the model. In other words, a partial
modelconsistsofacompletetypedgraphwhoseelementsare
annotated withTrue,FalseorMaybe, and a may formula
thatdescribestheallowedconﬁgurationsofitselements.The
annotation functions are often omitted for brevity.
ModelM ein Fig. 1(g) is an example of a partial model.
The elements annotated withTrue, e.g., the stateIdleand
thetransitionstart(),appearwithsolidlines,anditsMaybe
elements, e.g. the stateFinishing, with dashed lines. The
edges that are not shown (e.g. any edge between the states
FinishingandLeeching) are annotated withFalse.M eis
accompanied by the may formulaφ e, shown next to it in the
ﬁgure. We used capital letters as shortcuts for the full names
of the propositional variables that correspond toMaybeele-
ments. E.g.,Fstands for the variableFinishing State.
Given a partial modelM, letC(M)be the set of classical
(orconcrete) models that it represents, calledconcretiza-
tions. For example,C(M e)consists of the models shown in
Fig.1(a)-(f).Apartialmodelwithanemptysetofconcretiza-
tions is calledinconsistent. In what follows, we only assume
consistent partial models.
Thesizeofthesetofconcretizationsreﬂectsthemodeler’s
degreeofuncertainty.Uncertaintycanbereducedbyreducing
the set of concretizations viareﬁnement. A partial model is
reﬁnedbychangingtheannotationsofitselementstoincrease
the level of certainty:Maybeelements can be assigned to
True,FalseorMaybe;TrueandFalseannotations must
remain unchanged since information about them is already575Figure 3. Normal forms of the modelM¬HC1
e, shown in Fig. 4(a): (a)
Graphical Normal Form (GNF) (b) Propositional Normal Form (PNF).
certain. Changes toMaybeelements must not violate the
formula of the original partial model, and thus produce a
(nonempty) subset of concretizations allowed by it.
Deﬁnition 5:GiventwopartialmodelsM 1andM 2,where
Mi=�G i, vm i, em i, φi�, withG 1=G 2, we say thatM 2
reﬁnesM 1(or thatM 1ismore abstractthanM 2), denoted
M2�M 1iffC(M 2)⊆ C(M 1)over the same scopeS.
E.g., the modelMHC1
ein Fig. 4(b) is more reﬁned thanM e
in Fig. 1(g). In particular,C(M e)consists of the models in
Fig. 1(a)-(f), whereasC(MHC1
e)consists of the models in
Fig. 1(a,b,e,f). Thus, the modelMHC1
ehas less uncertainty.
A partial model withoutMaybeelements has exactly one
concretization.ThenamingconventionsinSec.IIallowusto
deﬁne a unique conversion between a classical model and a
corresponding partial model with a unique concretization.
Normal Forms.Given a set of classical models, there is no
uniquewaytorepresentthemasapartialmodel.Forexample,
M¬HC1
e in Fig. 4(a) represents the models in Fig. 1(c, d).
However, the same set of concretizations could be expressed
by:(a)removingfromthescopeofM¬HC1
e extraneousFalse
elements, such as the stateFinishing, and (b) rewriting its
propositional formula only in terms of itsMaybeelements.
In the case ofM¬HC1
e , the partial model has only one
Maybeelement (the transition onrestart()), which can be
eitherTrueorFalse,andtherefore,theattachedpropositional
formulaφ¬HC1
e is a tautology.
Deﬁnition 6:Two partial modelsM 1,M2areequivalent,
denotedM 1∼M 2, iffC(M 1) =C(M 2). Obviously,M 1∼
M2iffM 1�M 2andM 2�M 1.
To help represent models, we deﬁne two normal forms:
Graphical Normal Form(GNF) andPropositional Normal
Form(PNF). Intuitively, a model in GNF represents most
information in the graph, whereas in PNF it represents all
the information in the formula. For example, the GNF and
PNF forM¬HC1
e are shown in Fig. 3(a-b), respectively. In
the latter, we did not representFalseedges which would
otherwise be represented by negated variables.
As partial models are complete graphs, the normal form
ofMshould be restricted to its largest complete subgraph
that only containsTrueandMaybenodes. We call the scopeof this subgraphminimal. In the following, the symbol�
signiﬁes logical entailment.
Deﬁnition 7:Given a partial modelM=�G, φ�, its GNF
is a partial modelMGNF=�GGNF, φGNF�, constructed as
follows:
•GGNF⊆Gand the scopeSofMGNFis minimal.
•ForeveryatomainG,ifφ�a,thenaisannotatedwith
TrueinGGNF.
•For every atomainG, ifφ�¬a, thenais annotated
withFalseinGGNF.
•φGNFis speciﬁed only in terms of elements annotated
withMaybeinGGNF.
•φ�φGNF.
Proposition 1:LetMbe a partial model andMGNFbe a
result of applying Deﬁnition 7. Then,M∼MGNF.
Deﬁnition 8:Given a partial modelM=�G, φ�, its PNF
is a partial modelMPNF=�GPNF, φPNF�constructed as
follows:
•GPNF⊆Gand the scopeSofMPNFis minimal.
•All elements inGPNFare annotated withMaybe.
•φPNF�φ.
Proposition 2:LetMbe a partial model andMPNFbe a
result of applying Deﬁnition 8. Then,M∼MPNF.
Properties of Partial Models.The result of checking a
property on a partial model can beTrue,FalseorMaybe.
Truemeans that the property holds for all concretizations,
Falsethat it does not hold for any of them, andMaybe
that it holds for some, but not all concretizations. This is
calledthoroughchecking [2]. Moreover, by Deﬁnition 5,
reﬁnement preservesTrueandFalseproperties. That is, as
uncertaintygetsreduced,valuesofpropertiesaboutwhichwe
were certain remain unaffected.
IV. REASONING WITH PARTIALMODELS
In this section, we describe how to facilitate decision
deferralinthepresenceofuncertaintybyusingpartialmodels
toreasonwithsetsofalternatives.Inparticular,wedeﬁnefour
reasoning operations:
OP1:Construction: how to create a partial model to (pre-
cisely) represent a set of alternatives.
OP2:Veriﬁcation: how to check whether a partial model
satisﬁes a property.
OP3:Diagnosis: how to ﬁnd out which alternatives violate
the property.
OP4:Reﬁnement: how to ﬁlter out the alternatives that
violate the property.
OP1: Construction.Construction of partial models is
achieved by merging the alternatives and annotating the el-
ementsthatvarybetweenthembyMaybe.Additionally,may
formulaisconstructedtocapturetheallowableconﬁgurations
of theMaybeelements.
Algorithm 1 shows how to create a partial modelMfrom
a setAof alternatives. By construction,C(M) =A, which
establishes the algorithm’s correctness.
In our motivating example, the six alternative behavioral
designs can be represented using the partial model shown576Algorithm1Construction of partial models.
Input:SetAofnconcrete modelsm i, i∈[0..n−1].
Output:A partial modelM=�G M,ΦM�
1:ConstructG Mas the union of allm i∈A.
2:Annotate non-common elements inG MbyMaybe.
3:CreateΦ M:=False
4:forallm i∈A,e x∈G Me annotated withMaybedo
5:Createφ i=e0∧ ¬e 1∧. . .∧e k,
6:where ife x�∈m i, it appears negated.
7:ΦM:= Φ M∨φi
8:endfor
9:returnM=�G M,ΦM�
in Fig. 1(g). In the ﬁgure, elements annotated asMaybe
appear dashed. For example, the stateFinishingexists in
only two alternatives, and the transition onrestart()– in
three; therefore, both are represented asMaybe. The rest of
theelementsarepresentinallofthealternatives,andthusare
representedasTrueandappearsolid.Thecorrespondingmay
formula is shown in Fig. 1(g).
OP2: Veriﬁcation.The purpose of the veriﬁcation task is to
answer the question ”Does the desired property hold?”.
In order to facilitate reasoning, we put the partial model in
PNF and appropriately combine its PNF may formula with
the formula representing the property we want to check. A
SATsolveristhenusedtocheckwhethertheencodingofthe
model entails that of the property.
Speciﬁcally,theveriﬁcationenginereceivesapartialmodel
Mthat is represented in PNF by the propositional formula
ΦMand a property expressed as a propositional formulaΦ p.
We then check satisﬁability of the expressionsΦ M∧ ¬Φ p
andΦ M∧Φ p, using two queries to a SAT solver, combining
the results to determine the outcome of the property on the
partialmodelasdescribedinTableI.Forexample,ifboththe
property and its negation are satisﬁable, then there is at least
one concretization of the partial model where the property
holds and another – where it does not. Thus, in the partial
model the property has valueMaybe.
Returning to our running example, in order to check
whether the property HC1 holds for the partial modelM ein
Fig. 1(g), we ﬁrst putM ein PNF to get the propositional
formulaΦ e. Then we express HC1 as a propositional for-
mulaΦ HC1, by grounding it over the vocabulary ofM e, as
described in Sec. II. Checking the property means checking
satisﬁabilityΦ e∧ ¬Φ HC1andΦ e∧Φ HC1. The SAT solver
returns one of the two models from Fig. 1(c, d) as the
satisfying assignment forΦ∧ ¬Φ HC1, and one of those in
Fig. 1(a, b, e, f) forΦ∧Φ HC1. Thus, the value of HC1 is
uncertain (Maybe) on the model.
OP3:Diagnosis.IftheresultoftheveriﬁcationtaskisFalse
orMaybe, the next step is to do diagnosis, i.e., to answer the
question ”Why does the property of interest not hold?”. Or,
conversely,iftheoutcomewasMaybewhereitwasexpected
to beFalse, to answer the question ”Why is the property not
violated?”. Three forms of feedback can be returned:Table I
CHECKING PROPERTY pON THE PARTIAL MODEL M.
ΦM∧Φp ΦM∧ ¬Φ p Propertyp
SAT SAT Maybe
SAT UNSAT True
UNSAT SAT False
UNSAT UNSAT(InconsistentM)
1) Return one counter-example – a particular concretiza-
tion for which the property does not hold(OP3a):Such
a counter-example is provided “for free” as a by-product
of SAT-based veriﬁcation. In particular, if the property is
False, the SAT solver produces a satisfying assignment for
ΦM∧ ¬Φ p.
This assignment is a valuation for all propositional vari-
ables that correspond to elements in the scope ofMand
can thus be visualized as a classical model for presentation
to the user. To create the visualization, we conjoin all vari-
ables, negating those that had valueFalsein the satisfying
assignment. Provided the naming conventions in Sec. II are
followed,thisconjunctionuniquelycorrespondstoaclassical
model, which is then presented as the feedback.
In our running example, verifying SC2 on the modelM e
involves checking the satisﬁability ofΦ e∧ ¬Φ SC2. This
formula is satisﬁable, and the SAT solver returns one of the
concretizations in Fig. 1(e, f) as a satisfying assignment.
2) Return a concretization where the property does hold
(OP3b):Thisis alsoa by-productofthe veriﬁcationstage: if
the result of checking the property isMaybe, the SAT solver
produces a satisfying assignment for the formulaΦ M∧Φ p.
This valuation is expressed as a model (as discussed above)
and provided to the user.
In the case of verifying SC2, the SAT solver returns a
valuation that corresponds to one of the concretizations in
Fig. 1(a,b,c,d) as a satisfying assignment to the formula
Φe∧Φ SC2.
3) Return a partial model representing the set ofallcon-
cretizations for which the property does not hold(OP3c):
TheseconcretizationsarecharacterizedbytheformulaΦ M∧
¬Φ p. In our example, the concretizations ofM ethat violate
HC1arethosethatsatisfytheformulaΦ e∧¬Φ HC1,i.e.,those
in Fig. 1(c,d).
Inordertocreateusefulfeedbacktotheuser,weconsidera
new partial modelM¬pwith the same vocabulary asM, that
isrepresentedinPNFbytheformulaΦ M∧¬Φ p.Wevisualize
M¬pbyputtingitintoGNF.Inourexample,thepartialmodel
M¬HC1
e that represents the set of concretizations ofM ethat
violate HC1 is shown in Fig. 4(a).M¬HC1
e is expressed in
termsofthelargerscopeofM eandthereforecertainelements
are tagged asFalseand omitted from the diagram. The
overall process is described in Algorithm 2. As the resulting
model is constructed by the formulaΦ M∧ ¬Φ p, its set of
concretizations is exactly the subset of concretizations of the
originalpartialmodelforwhichthepropertywasviolated.In
other words,M¬p�M.
OP4: Property-driven reﬁnement.If the result of veriﬁca-
tion of an important property isMaybe, the developer may577Figure4. (a)PartialmodelM¬HC1
e representingallconcretizationsofM e
that violate HC1. (b) Partial modelMHC1
erepresenting all concretizations
ofM ethat satisfy HC1.
want to reﬁne the partial model to a constrained version
such that all of its concretizations satisfy the property. This
subsetofconcretizationsexactlycharacterizedbytheformula
ΦM∧Φ p. We use it to construct the partial modelMpin the
same manner as we did for constructingM¬p.
Inourexample,thesetofconcretizationsofM ethatsatisfy
HC1 consists of those in Fig. 1(a, b, e, f). Constructing the
partial modelMHC1
ethat represents these is done using the
same method (shown in Algorithm 2) as for constructing its
complement,M¬HC1
e . Namely, the formulaΦ e∧Φ HC1 is
constructed and then put into GNF. The result is shown in
Fig. 4(b).
AsMpis constructed using the formulaΦ M∧Φ p, its set
of concretizations is exactly the subset of concretizations of
theoriginalMforwhichthepropertyholds;thus,Mp�M.
V. EXPERIMENTS
We conducted a preliminary empirical study to assess the
feasibility and scalability of our approach to reasoning using
partialmodels.Morespeciﬁcally,weattemptedtoanswerthe
following research questions:
RQ1: Howfeasibleis reasoning with sets of models with
the partial model representation in comparison to the
classical approach?
RQ2: Howsensitiveare the partial modeling representation
and reasoning techniques to the varying degree of
uncertainty?
To get answers to RQ1 and RQ2, we set up experiments
with parameterized random inputs to simulate various cate-
gories of realistic reasoning settings.
Experimental setup.The reasoning tasks described in
Sec. IV are operationalized using two fundamental tasks:
T1:Check the satisﬁability of the formulasΦ M∧Φ Pand
ΦM∧ ¬Φ P(for OP2, OP3a and OP3b).
T2:Construct a new partial model in GNF that has a PNF
formulaΦ M∧Φ P(for OP3c with¬Φ Pand OP4).Algorithm 2Get all concretizations that violate (satisfy) a
property.
Input:A partial modelM inand a propertyC
Output:A partial modelM outabstracting exactly the con-
cretizations ofM inthat violate (satisfy)C.
1:PutM inin PNF, to getΦ in.
2:GroundC, to getΦ c
3:ConstructΦ out:= Φ in∧ ¬Φ c(Φout:= Φ in∧Φ c)
4:CreateM outwith the same vocabulary asM inand PNF
formulaΦ out
5:PutM outin GNF andreturnit
We focus our experimental evaluation on T1 and T2 be-
cause they require the use of SAT-solving technology, as op-
posedtoConstruction(OP1)whichislineartothenumberof
input classical models and their elements (see Algorithm 1).
Speciﬁcally, to answer RQ1, we conducted two experiments:
E1 Compare the relative performance of doing reasoning
by running the task T1 to the performance of classical
reasoningbyconsideringthesetofconcretizationsrepre-
sented byM.
E2 Compare the relative performance of running T2 to get
a partial model representing the subset of concretizations
that satisfy a property, to the performance of incremen-
tally collecting all the classical models as satisfying as-
signments of the formulaΦ M∧Φ P.
ToanswerRQ2,weexecutedtheexperimentsE1andE2with
randomlygeneratedexperimentalinputsthatwereparameter-
ized to allow for different sizes, both with respect to model
size and the size of the set of concretizations.
Experimental inputs.The metamodel of typed models cor-
responds to additional constraints in their propositional en-
coding. This makes the problem easier for the SAT solver,
as it constrains the search space. We chose to use untyped
modelsforinputstoourexperiments,astheleastconstrained
and thus the most difﬁcult for the SAT solver.
We considered the following experimental parameters:
1) size of the partial model, 2) size of its set of concretiza-
tions, 3) quantiﬁcation (e.g., existential, universal, mixed) of
theproperty,and4)resultofpropertychecking(True,False,
Maybe). To manage the multitude of possible combinations
of these, we discretized the domain of each parameter into
categories.
We deﬁned four size categories, based on the total number
of elements (nodes and edges) in the partial model: Small
(S), Medium (M), Large (L) and Extra-Large (XL). Based
on pilot experiments, we deﬁned ranges of reasonable values
foreachsizecategoryandselectedarepresentativeexemplar.
The ranges of the categories and the selected exemplars for
each category are shown in Table II.
In a similar manner, we deﬁned four categories (S, M, L,
XL) for the size of the set of concretizations of the generated
model. The size of this set reﬂects the degree of uncertainty
encoded in the partial model, so that the category S corre-
sponds to little uncertainty over which alternative to chose,578Table II
CATEGORIES OF THE SIZE OF MODELS .
Size of Model S M L XL
Nodes (0,10] (10, 20] (20, 40] (40, 80]
Elements (0,110] (110, 420] (420, 1640] (1640, 6480]
Exemplar 30 240 930 2550
Table III
CATEGORIES OF THE SIZE OF THE CONCRETIZATION SET .
Size of Set S M L XL
Concretizations (0,10] (10, 75] (75, 150] (150, 300]
Exemplar 5 50 100 200
and the category XL corresponds to extreme uncertainty.
Based on pilot experiments, we deﬁned reasonable ranges
and selected a representative exemplar for each category, as
shown in Table III.
We also deﬁned four property types (based on the quan-
tiﬁcation of FOL formulas): “fully existential” (E), “fully
universal” (A) and two “mixed” categories: “exists-forall”
(EA) and “forall-exists” (AE). Additionally, we considered
the three possible results that can be yielded by property
checking –True,MaybeandFalse.
Implementation.We implemented tooling support to ran-
domly generate inputs based on the experimental properties
outlined in Sec. V. Speciﬁcally, we generate propositional
formulas expressed in the input format of the MathSAT 4
SMT Solver [3]. Each such propositional formulaΦ ris
a conjunction of the formΦ r= Φ a∧Φ c∧Φ p, where
Φarepresents the annotations of the elements of the partial
model,Φ c– its set of concretizations andΦ p– the property
being checked. We describe these below.
For each random partial model, we considered a complete
graph whose elements are in the model’s ﬁnite vocabulary of
N1nodesandN2
1edges.Eachelementisrandomlyannotated
asTrueorFalse, andN 2elements are annotated asMaybe.
Each element in the model is represented by a boolean vari-
able. The formulaΦ acaptures the set of variables that make
upthemodelaswellastheirannotations.Inparticular,Φ aisa
conjunctionofN 1(N1+ 1)terms,oneforeachelement.Ifan
elementαis annotated asTrue, its corresponding term is the
non-negated variablev α. If it is annotated asFalse, its term
is¬v α, and if it is annotated asMaybe–(v α∨ ¬v α). This
tautological disjunction is necessary forv αto be considered
by the SAT solver even if it doesn’t appear elsewhere inΦ r.
Each model is accompanied by the formulaΦ cthat cap-
tures its set of concretizations.Φ cis a disjunction ofN 3
unique sub-formulas representing individual concretizations.
Each one is a conjunction of theN 2Maybevariables, a ran-
domnumberofwhichisnegated.Thisway,eachsub-formula
deﬁnes an allowable conﬁguration ofMaybeelements.
Deﬁning speciﬁc values forN 1andN 3, we were able to
generate models for each of the combinations of the parame-
ters in Tables II and III.
To generate formulasΦ pthat simulate grounded FOL
properties, we used property “templates”. For example, to
capture the FOL formulaφ ex=∃x, y:x⇒y, we createdVAR v0, v1, v2, v0_v0, v0_v1, v0_v2, v1_v0,
v1_v1, v1_v2, v2_v0, v2_v1, v2_v2 : BOOLEAN
FORMULA
# Start ofΦa
v0 and (v1 or (not v1)) and (v2 or (not v2)) and
(not v0_v0) and (not v0_v1) and (v0_v2 or
(not v0_v2)) and (not v1_v0) and (not v1_v1) and
(not v1_v2) and (not v2_v0) and (not v2_v1) and
(not v2_v2) and (
# Start ofΦc
((v1 and v2 and (not v0_v2)) or
(v1 and (not v2) and (not v0_v2)) or
((not v1) and v2 and v0_v2)))
# Start ofΦp
and not (
(not v0 implies not v1_v0) and (not v1_v0 implies not v2)
and (not v1 implies not v0_v2))
Figure 5. A randomly generated input in MathSAT’s encoding language.
the template“X implies Y”. Given a partial model with
elements represented by the set of variables{v 1, v2, v3, v4},
the propositional formula that corresponds to groundingφ ex
over the vocabulary of the model is created as a randomly
instantiated disjunction of copies of the template, e.g.,“(v3
implies v2) or (v1 implies v4)”. To run experiments, our goal
was creating templates for realistic properties such as the
ownership relationship. E.g., the template“(not X) implies
(not Y)”indicates thatYcannot exist without its “owner”
element,X.
Each template was repeatedN 6times, withN 6large
enough so thatΦ pcontainsN 4variables, out of which
N5correspond toMaybeelements. Preliminary results by
pilot experiments indicated that these parameters did not
signiﬁcantly affect the observed times and therefore in the
generated inputs we ﬁxed them toN 4= 0.1×N 1and
N5=min(N 2,0.05×N 1).
TocreatepropertiesintheFE(“fullyexistential”)category,
the template is repeated as a series ofN 6disjunctions and
for FA properties – as a series ofN 6conjunctions. EA
propertiesweregeneratedasN 7disjunctionsofconjunctions
ofN 8instantiations of the template, whereN 7andN 8were
randomnumberss.t.N 7×N 8=N 6.Similarly,AEproperties
were comprised ofN 7conjunctions of disjunctions ofN 8
instantiations of the template.
Fig. 5 shows an example of an input formula generated
randomly using a FA “ownership property” .
Methodology.We conducted a series of experiments gen-
erating inputs along the dimensions speciﬁed by three pa-
rameters: model size, size of set of concretizations and type
of property. For each combination of the parameters, we
produced inputs using the selected exemplar values shown in
Tables II and III.We did multiple runs for each combination
and then picked at least 3 runs for each data-point that
produced results in each of the three possible return values
(True,Maybe,False).
For each run, we used the generated input to execute the
two experiments, E1 and E2. For each, we recorded the
speedupS p=Tc
Tpm, whereT candT pmwere the times to do
a task with sets of classical models and with partial models.579Figure 6. Speedup versus model size for different degrees of uncertainty: (a) experiment E1, (b) experiment E2.
Results.Theexperiments1didnotshowdramaticdifferences
in speedup between the different property and return types.
The biggest difference in speedup for E1 was recorded in the
AE category between properties that returnMaybe(21.65)
and those that returnFalse(29.13), for M-sized models with
L sets of concretizations. For E2, the biggest difference in
speedup was recored for S-sized models with XL sets of
concretizations, for properties that returnMaybe, between
the EA (0.36) and AE categories (5.62). This indicates that
property and return types are not the prime determinants for
the performance of our approach.
The size of the partial model and the size of the set of
concretizations had a much larger effect on the recorded
variance of speedup. The ranges of speedups for E1 and E2
are shown in Fig. 6(a, b), respectively. The plotted values are
averages for type of property and return value for each com-
binationofmodelsizeandsizeofsetofconcretizations.This
indicatesthattheseparametersarethemostimportantfactors
for studying the effectiveness of partial model reasoning.
Fig. 6(a) shows that for veriﬁcation and simple diagnos-
tic tasks, such as producing a counter-example, there is a
signiﬁcant speedup from using partial models. The smallest
speedups were observed in the inputs with S sets of con-
cretizations(between2.45forS-sizedmodelsand2.59forL-
sized models). The increase from these values was dramatic
forM,LandXLsetsofconcretizations.Forthesecategories,
the smallest speedup was 19.72 for XL-sized models with M
setsofconcretizationsandthebiggestspeedupwas30.49for
M-sized models with XL sets of concretizations.
For more complex tasks, such as property-driven reﬁne-
ment, the effect of the size of concretizations, as shown in
Fig. 6(b), seems to be the determinant parameter, as the
technique offers a speedup greater than 1 for larger sets of
concretizations. Our approach was signiﬁcantly slow for S
setsofconcretizations(thelargestspeedupbeing0.05forM-
sizedmodels).ModeratespeedupswereonlyrecordedforXL
sets of concretizations and smaller models (3.30 for S, 2.25
for M and 1.78 for L). This points to the conclusion that for
more complex tasks, speedup is best for smaller models with
larger sets of concretizations.
1All results available at http://www.cs.toronto.edu/∼famelis/icse12.htmlThese observations, lead us to the conclusion that, regard-
ing RQ1 (feasibility), there is a signiﬁcant net gain from
using our approach for tasks like veriﬁcation and counter-
example guided diagnosis, whereas for tasks like property-
drivenreﬁnementtherearecertaincaseswhereitispreferable
to use the classical approach.
Regarding RQ2 (sensitivity to degree of uncertainty), the
observations point to the conclusion that the speedup offered
by our approach is positively correlated to the degree of
uncertainty. In fact, the greatest speedups were observed for
inputs that had bigger sizes of sets of concretizations. For
smaller levels of uncertainty, explicitly handling the set is
more efﬁcient.
Threats to Validity.The most important threat to validity
stemsfromtheuseofexperimentalinputsthatwererandomly
generated. The formulas that we created for properties were
randomlygroundedandweregeneratedfromafewarbitrarily
deﬁned templates.
Another threat to validity is induced by our choice to use
a few exemplar values of the experimental parameters in
order to manage the combinatorial explosion of options. It is
evident that more experimentation is required, to generalize
our results and further investigate effects of the experimental
parameters that may not have been made obvious by our set
of experiments.
Tocompensateforthesethreatstovalidity,weadditionally
conducted a Case Study, to triangulate our experimental re-
sults with experience from applying our technique to a real
world application. The size of the models that we extracted
from the Case Study fell in the XL category, with M and L
sets of concretizations, whereas the properties were in the
FE category and returnedTrueandMaybe. The observed
speedups (detailed in the next section) )were consistent with
our experimental results.
VI. CASESTUDY
ProblemDescription.In this case study, we aim to illustrate
thefollowingMDEsoftwaremaintenancescenario:Anengi-
neerisgiventhetaskofﬁxingasoftwaredefectbymodifying
its UML model which will subsequently be used to construct
the modiﬁed software (e.g., via a transformation). However,580after creating the modiﬁcations to the model, the engineer
ﬁnds that some model constraints are violated and thus the
software cannot be constructed. For example, she may have
modiﬁedasequencediagramwithoutproperlysynchronizing
it with the structural aspects (e.g., classes) of the model.
To help her resolve these constraint violations, she uses a
tool that can automatically propose different model repair
alternatives (e.g., [12]). Suppose the engineer is uncertain
aboutwhichalternativetochoosebecausetheirrelativemerits
are unclear – and thus she would like to reason with the set
of alternatives to help her make the choice and possibly even
defer the decision until more information is available. In this
case study, we apply the partiality techniques developed in
this paper to show how they could help her in this scenario
and to illustrate the feasibility of the approach.
We use an open source project UMLet [23], which is a
simple Java-based UML editor, as the software on which our
user is requested to perform a maintenance task. This project
has also been used by Van Der Straeten et al. for ﬁnding
model inconsistencies with a model ﬁnder [24]. The goal of
the maintenance task is to ﬁx the following bug, referred to
asIssue10ontheonlineissuelog[22]:“copieditemsshould
haveahigherz-order priority”.Thatis,iftheusercopiesand
then pastes an item within the editor, it is not the topmost
item if it overlaps with other existing items. Thus, any ﬁx to
the bug must satisfy the following property P1: “Each item
that is pasted from the clipboard must have z-order = 0.” The
pastefunctionalityisimplementedinUMLetbyinstantiating
the classPasteand invoking itsexecuteoperation. Fig. 7
shows a fragment of the sequence diagram, generated from
the code using the Borland TogetherJ tool [1] forexecute
with the circled portion representing a bug ﬁx we propose.
The full sequence diagram has 12 objects, 53 messages and
8 statement blocks. Although UMLet has 214 classes in
total, we restrict ourselves to a slice that covers the sequence
diagramforexecuteconsistingof6classes(plus5Javalibrary
classes)with44operations.Ofthe12objectsinthesequence
diagram, 5 are instances of Java library classes and 7 – of
UMLetclasses.Inthefragmentshown,theforloopstatement
block iterates through every item in the clipboard (indexed
by variablee) and adds it to the editor window (represented
by the objectpnl:DrawPanel). When an entity is added to a
DrawPanel, the z-order is not set to 0 by default, causing the
bug.Inourproposedﬁx(showninthedashedcircle),wecre-
ate a transient objectpositionerand tell it tomoveToTop(e),
using the Swing operationsetComponentZOrder.
InconsistenciesandthePartialModel.Ourﬁxisconceptu-
ally correct but it violates two consistency rules required for
code generation:
1)ClasslessInstance:Everyobjectmusthaveaclass.Pos-
sible repairs:
•RC1:Remove the object.
•RC2:(obj) Replace the object with an existing object
objthat has a class.
•RC3:(cls) Assign the object to the existing classcls.
•RC4:Assign the object to a new class.
self
e:GridElement
elem:AddElement
pnl:DrawPanel
positioner
1:execute(handler)
1.36:getX()
1.38:getY()
1.37:*
1.39:*
1.40:AddElement(e,x,y,zoom)
1.41:execute(handler)
1.42:new
1.43:moveToTop(self, e)
1.44:setComponentZOrder(e,0)
handler:DiagramHandler
for
[GridElement e:this.entities]
sd:Paste.executeFigure 7. Our ﬁx for theexecuteoperation of the UMLet paste function.
2)DanglingOperation:The operation used by a message
in a sequence diagram must be an operation of the class
of the receiving object. Possible repairs:
•RD1:Put the operation into the receiving object’s
class.
•RD2:(op) Change the operation to the operationop
that is already in the receiving object’s class.
•RD3:Remove the message.
ClasslessInstance and DanglingOperation are both based
on [21]. In our case, thepositionerobject violates Class-
lessInstance and the message with operationmoveToTopvio-
latesDanglingOperationbecauseitisnotinpositioner’sclass
(sincepositionerhas no class).
If we apply all possible repairs, we get a set of alternative
ways to ﬁx the inconsistency, summarized as follows:
1)Positionercan be removed (RC1), can be replaced by
one of the existing 7 objects (RC2), can be assigned to
oneoftheexisting6classes(RC3),orcanbeaninstance
of a new class (RC4).
2) The operationmoveToTopcan be added to theposi-
tioner’sclass (RD1), can be changed to one of the other
44 operations depending onpositioner’sclass (RD2), or
can be removed (RD3).
Only certain repairs are mutually compatible – for example,
RC1cannot be used withRD2since the latter depends on
positioner’s class but the former removespositionerentirely.
There are 220 alternatives in total for all valid combinations.
If we construct a partial model to represent this set of
alternatives, all the model elements in the proposed ﬁx in
Fig. 7 becomeMaybesince they are present in some al-
ternatives and absent in others. Furthermore, based on the
compatible combinations of repairs, themayformula portion
of the partial model is expressed as
φM=Choose((φ RC1 ∧φRD3),
(φRC2(e) ∧φRD1),(φ RC2(e) ∧φRD2(getX) ), . . .),
whereChoose(φ 1, . . . , φ n) is a logical function that holds
when exactly one of{φ i}1≤i≤n hold. Each of the formulas581for the individual repairs can be further expanded and ex-
pressedintermsoftheUML2metamodel[16].Forexample,
φRC2(e) represents the condition that objectpositioneris
replaced by objectein Fig. 7, expressed as
φRC2(e) =covered(receiveEvent(Message 1.43)) =Lifeline e
which says that the lifeline covered by the receiving event of
message 1.43 is the one for objecte:GridElement.
Analysis.Having deﬁned a partial model whose set of con-
cretizations are the possible alternative ways of making our
bug ﬁx consistent with the required rules, we can use the
techniques discussed in Sec. IV to reason about the alterna-
tives using properties. The ﬁrst question is whether any of
the alternatives “break” the paste functionality. For example,
considerthepropertyP2:“Wheneveranitemispasted,anew
itemiscreatedintheeditorwindow”whichshouldholdifthe
paste functionality is implemented correctly. To check this
against the partial model, we encode it into a propositional
formulaφ P2over the UML metamodel in the same way as
the repair formulas. Due to lack of space, we limit ourselves
to a high-level description of the encoding: “φ P2holds iff
in the sequence diagram forexecutethere exists an iteration
over the items in the clipboard (e.g., aforblock) that creates
a copy of each item using the operationCloneFromMe() and
later adds the item to the editor window using the command
AddElement”. Only theAddElementportion is visible in the
fragment in Fig. 7.
WeusedtheMathSATimplementationdescribedinSec.V
toverifythisproperty(OP2),checkingthequeriesφ M∧φP2
andφ M∧ ¬φ P2. The result wasTrue,indicating that all con-
cretizations satisfy the property. We also did the comparison
with doing this task using classical models as in Sec. V and
found a speedup of 30.68. Next we considered the critical
property P1 that is required for any ﬁx to our bug. In this
case, OP2 yieldedMaybeindicating that some but not all
concretizations are acceptable bug ﬁxes. In this case, we
found a speedup of 31.23.
To investigate why some concretizations did not ﬁx the
bug, we used our diagnosis technique (OP3c) to produce
the partial model representing the counterexamples to P1 by
setting themayformula toφ M∧ ¬φ P1and computing the
GNF. In the resulting may model, themoveToTopoperation
is absent and thusmoveToTopis necessary for P1 to hold.
This is reasonable since if this operation is not invoked, then
the z-order is never set to 0. In a similar way, we used
property-guided reﬁnement (OP4) to reﬁne our partial model
to represent only the satisfying concretizations by setting the
mayformulaφ M∧φP2andcomputingtheGNF.Thespeedup
for these two tests were 0.19 and 0.05, respectively.
VII. R ELATEDWORK
Anumberofpartialbehavioralmodelingformalisms,have
been studied in the context of abstraction (for veriﬁcation) or
for capturing early design models [9]. For example, Modal
Transition Systems (MTSs) [10] allow introduction of uncer-
taintyabouttransitionsonagivenevent,whereasDisjunctive
Modal Transition Systems (DMTSs) [11] add an additionalconstraint that at least one of the possible transitions must be
taken in the reﬁnement. These approaches compactly encode
an over-approximation of the set of possible LTSs and thus
reasoningoverthemsuffersfrominformationloss.Moreover,
the MTS and DMTS reﬁnement mechanism allows resulting
LTS models to have an arbitrary number of states which is
different from the treatment provided in this paper, where
we concentrated only on “structural” partiality and thus state
duplication was not applicable.
Another relevant area is product line software develop-
ment [17] which captures the set of potential models by
identifying their commonalities and variabilities. Most ap-
proaches keep the expressions of variability in a separate
feature model but some incorporate these directly into the
model using notational extensions in the metamodel [13].
Featured Transition Systems (FTSs) [4] are most closely
relatedtothenotionofpartialmodelspresentedinthispaper.
FTSs encode a set of products by annotating transitions with
speciﬁc features from a feature diagram (much like ourmay
formula), and differ from MTSs and DMTSs in that they
supportpreciserepresentation and reasoning with a set of
models.
Our approach is distinct from related work in a number of
important ways. First, it applies toanykind of modeling lan-
guage(notjustbehavioralmodels)thatcanbedeﬁnedusinga
metamodel.Second,ourviewpointisthecomprehensivehan-
dlingofuncertaintyratherthanjustreasoningovervariability.
In this context, partial models support changes in the level
of uncertainty, with tasks such as property-driven (OP4) and
more generallyuncertainty-removingreﬁnement [19]. Third,
partialmodelsareﬁrst-classdevelopmentartifactsthatcanbe
manipulated throughout the software engineering life cycle
withdetail-addingtransformationsthatdonotaffectthelevel
ofuncertainty[8].Finally,thenotionofpartialitystudiedhere
(wheremodelelementscanbeoptionalormandatory)isonly
one of several kinds of partiality, developed in [20].
VIII. C ONCLUSION AND FUTUREWORK
This paper presented an approach for reasoning in the
presence of uncertainty. We showed how to construct partial
models to represent sets of alternatives and how to use them
for reasoning. We evaluated the approach by running experi-
ments using randomly generated inputs and triangulated our
results with a case study dealing with alternative repairs to
inconsistency for a real world software project. Our evalua-
tion, while preliminary, showed that in the presence of high
degrees of uncertainty, using partial models offers signiﬁcant
improvements for reasoning tasks.
Our work is part of a broader research agenda, outlined
in [7]. Our next steps include studying how partial models
canbeusedasﬁrst-classdevelopmentitems.Inparticular,we
wanttoinvestigatemodeltransformationofpartialmodels,as
well as the effects of transformation on the properties of the
concretizations.582REFERENCES
[1] Borland TogetherJ.website :
http://www.borland.com/us/products/together/, accessed 03-
20-2012.
[2] G. Bruns and P. Godefroid. “Model Checking Partial State
Spaces with 3-Valued Temporal Logics”. InProc. of CAV’99,
pages 274–287, 1999.
[3] R. Bruttomesso, A. Cimatti, A. Franzen, A. Griggio, and
R. Sebastiani. “The MathSAT 4 SMT Solver”. InProc. of
CAV’08, pages 299–303, 2008.
[4] P. Classen, A.and Heymans, P. Schobbens, A. Legay, and
J. Raskin. “Model Checking Lots of Systems: Efﬁcient Ver-
iﬁcation of Temporal Properties in Software Product Lines”.
InProc. of ICSE’10, pages 335–344, 2010.
[5] A. Egyed, E. Letier, and A. Finkelstein. “Generating and
EvaluatingChoicesforFixingInconsistenciesinUMLDesign
Models”. InProc. of ASE’08, pages 99–108, 2008.
[6] H.Ehrig,K.Ehrig,U.Prange,andG.Taentzer.Fundamentals
of Algebraic Graph Transformation. EATCS. Springer, 2006.
[7] M. Famelis, S. Ben-David, M. Chechik, and R. Salay. “Partial
Models: A Position Paper”. InProc. of MoDeVVa’11, pages
1–6, 2011.
[8] M. Famelis, R. Salay, and M. Chechik. “The Semantics of
Partial Model Transformations”. InProc. of MiSE’12, 2012.
To appear.
[9] D. Fischbein, G. Brunet, N. D’ippolito, M. Chechik, and
S. Uchitel. “Weak Alphabet Merging of Partial Behaviour
Models”.ACM TOSEM, 21, 2012.
[10] K. G. Larsen and B. Thomsen. “A Modal Process Logic”. In
Proc. of LICS’88, pages 203–210, 1988.
[11] P. Larsen. “The Expressive Power of Implicit Speciﬁcations”.
InProc. of ICALP’91, volume 510 ofLNCS, pages 204–216,
1991.
[12] T. Mens and R. V. D. Straeten. “Incremental Resolution of
Model Inconsistencies”. InProc. of WADT’06, 2007.
[13] B.Morin,G.Perrouin,P.Lahire,O.Barais,G.Vanwormhoudt,
and J. M. J ´ez´equel. “Weaving Variability into Domain Meta-
models”.J. Model Driven Engineering Languages and Sys-
tems, pages 690–705, 2009.[14] C. Nentwich, W. Emmerich, and A. Finkelstein. “Consistency
ManagementwithRepairActions”. InProc. of ICSE’03,pages
455–464, 2003.
[15] Object Management Group.Object Constraint Language
OMG Available Speciﬁcation Version 2.0, 2006.
[16] OMG.UML Superstructure Speciﬁcation Version 2.3, 2010.
[17] K. Pohl, G. B ¨ockle, and F. Van Der Linden.Software Product
Line Engineering: Foundations, Principles, and Techniques.
Springer-Verlag New York Inc, 2005.
[18] M. Sabetzadeh, S. Nejati, M. Chechik, and S. Easterbrook.
“Reasoning about Consistency in Model Merging”. InProc.
of LWI’10, 2010.
[19] R. Salay, M. Chechik, and J. Gorzny. “Towards a Method-
ology for Verifying Partial Model Reﬁnements”. InProc. of
VOLT’12, 2012. To appear.
[20] R. Salay, M. Famelis, and M. Chechik. “Language Indepen-
dentReﬁnementusingPartialModeling”. InProc. of FASE’12,
2012.
[21] R. V. D. Straeten, T. Mens, J. Simmonds, and V. Jonckers.
“Using Description Logic to Maintain Consistency between
UML Models”. InProc. of UML’03, pages 326–340, 2003.
[22] UMLet.UMLet Issue List :
http://code.google.com/p/umlet/issues/list, accessed 03-20-
2012.
[23] UMLet.UMLet website : http://www.umlet.com/,accessed03-
20-2012.
[24] R. Van Der Straeten, J. Pinna Puissant, and T. Mens. “Assess-
ing the Kodkod Model Finder for Resolving Model Inconsis-
tencies”.Modelling Foundations and Applications, 6698:69–
84, 2011.
[25] A.VanDeursen,P.Klint,andJ.Visser. “Domain-SpeciﬁcLan-
guages: An Annotated Bibliography”.ACM Sigplan Notices,
35(6):26–36, 2000.
[26] A.vanLamsweerde.Requirements Engineering - From System
Goals to UML Models to Software Speciﬁcations. Wiley,2009.
[27] H. Ziv, D. Richardson, and R. Kl ¨osch. “The Uncertainty
Principle in Software Engineering”, 1996.583