Automated Domain-SpeciÔ¨Åc C VeriÔ¨Åcation with mbeddr
Zaur Molotnikov
Fortiss Institute
Guerickestra√üe 25
Munich, Germany
molotnikov@fortiss.orgMarkus V√∂lter
independent/itemis
Oetztaler Stra√üe 38
Stuttgart, Germany
voelter@acm.orgDaniel Ratiu
Fortiss Institute
Guerickestra√üe 25
Munich, Germany
ratiu@fortiss.org
ABSTRACT
When verifying C code, two major problems must be ad-
dressed. One is the speciÔ¨Åcation of the veriÔ¨Åed systems
properties, the other one is the construction of the veriÔ¨Å-
cation environment. Neither C itself, nor existing C veriÔ¨Å-
cation tools, oer the means to eciently specify application
domain-level properties and environments for veriÔ¨Åcation.
These two shortcomings hamper the usability of C veriÔ¨Åca-
tion, and limit its adoption in practice. In this paper we
introduce an approach that addresses both problems and re-
sults in user-friendly and practically usable C veriÔ¨Åcation.
The novelty of the approach is the combination of domain-
speciÔ¨Åc language engineering and C veriÔ¨Åcation. We apply
the approach in the domain of state-based software, using
mbeddr and CBMC. We validate the implementation with an
example from the Pacemaker Challenge, developing a func-
tionally veriÔ¨Åed, lightweight, and deployable cardiac pulse
generator. The approach itself is domain-independent.
Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program VeriÔ¨Åca-
tion‚ÄîCorrectness proofs, Model checking; D.2.6 [Software En-
gineering]: Programming Environments‚ÄîIntegrated environ-
ments; D.3.2 [Programming Languages]: Language ClassiÔ¨Å-
cations‚ÄîExtensible languages, Specialized application languages
Keywords
VeriÔ¨Åcation; Domain-SpeciÔ¨Åc Languages; mbeddr; CBMC
1. INTRODUCTION
The C programming language is used in many dierent ap-
plication domains. On the one hand, engineers beneÔ¨Åt from
its Ô¨Çexibility and the lightweight execution environment. On
the other hand, the low abstraction level of C makes C code
hard to verify against requirements speciÔ¨Åed in application
domain terminology. With existing C veriÔ¨Åcation tools, the
veriÔ¨Åcation has to be performed at the abstraction level of C
itself, which is tedious and error-prone. An example of an ap-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642938.plication domain-level requirement that must be fulÔ¨Ålled by
software is given below (it applies to the cardiac pacemaker
used as an example throughout this paper):
The pacer is conÔ¨Ågured with two timeout parameters, VRP and
LRI. LRI varies between 500 and 1.500 in increments of 20, and
VRP is at most 20% of LRI. In a given period of time (the tick), the
pacer either senses a signal representing a natural heartbeat, or it
does not. Before the VRP timeout such signals are to be ignored,
after VRP they must be registered. If within the LRI timeout no
heartbeat was registered, an artiÔ¨Åcial pacing must be performed.
Requirements like this describe the properties the system
should have. To make them veriÔ¨Åable by tools, they have
to be expressed formally. A (not necessarily correct) imple-
mentation of this pacing logic is given in Listing 1. This code
could be veriÔ¨Åed using C veriÔ¨Åcation tools such as CBMC [10],
SATABS [11] or CPAchecker [7]. Working at the abstraction
level of C, they can be used to, for example, check assertions or
error-label reachability. This makes it impractical to directly
represent the application domain-level semantics implied by
requirements such as those described above [13, 31].
int t = 0;
bool makePace(Event e) {
switch(e) { case Sense:
case Tick: if(t < VRP) {
if(t < LRI) { return false;
++t; } else {
return false; t = 0;
}else { return false;
t = 0; }
return true; }
} }
Listing 1: Sample pacing logic implementation in C
Another problem of veriÔ¨Åcation on the level of the imple-
mentation language is the lack of language abstractions for
specifying environments [36, 14]. The environment is the
code (or more generally, a system) with which the system
under veriÔ¨Åcation (SUV) interacts; in particular the environ-
ment may represent the relevant aspects of the real world in
which the SUV is designed to operate. The environment must
be modeled as well. This model encodes assumptions under
which the veriÔ¨Åcation is performed. Such environments are
usually nondeterministic (e.g., the heart may or may not beat
at any given time) and constrained (i.e., the behavior is some-
how bounded, usually as a consequence of characteristics of
the real world; for example, there are physical limits as to
how fast a human heart can beat). A well-deÔ¨Åned environ-
ment can reduce the number of spurious counterexamples,
and speed up the veriÔ¨Åcation as a consequence of state space
539
reduction [14]. Finally, assuming the veriÔ¨Åcation conditions
and the environment have been speciÔ¨Åed, the question re-
mains of how to integrate them with the SUV to perform the
veriÔ¨Åcation. In other words, veriÔ¨Åcation schemas must be
speciÔ¨Åed. A veriÔ¨Åcation schema can serve as a reusable, au-
tomated veriÔ¨Åcation method that can be used with multiple
dierent SUVs and their properties.
Listing 2 shows the system from Listing 1, implemented
and veriÔ¨Åed using domain-speciÔ¨Åc C extensions. These exten-
sions are developed with mbeddr, an extensible version of C
introduced in Section 2.2. The SUV is expressed as a state
machine, which adds additional structure and domain-level
semantics to the C code, while still containing C expressions
and statements to cover the details. mbeddr‚Äôs state machines
have states as well as internal variables, jointly representing
thetotal state of the state machine. The environment Heart is
explicitly speciÔ¨Åed and contains nondeterministic code that
interacts with the SUV. The SUV parameters lriandvrpare
nondeterministically assigned and constrained, as speciÔ¨Åed
in the requirements.
An inductive proof schema is used to verify whether a
given SUV satisÔ¨Åes a set of veriÔ¨Åcation conditions, starting
from the initial set of total states I. The veriÔ¨Åcation condition
is speciÔ¨Åed using an after/before/exists temporal pattern,
which is much closer to the original prose requirement (to
pace at LRI) than the low-level encoding in C.
state machine Pacer {
inTick; state Init {
inSense; onTick->Wait {c=0;}
inConfig(lri, vrp); onConfig->Init {
out MkPace; LRI = lri;
int c, LRI, VRP; VRP = vrp;
state Wait { }
onSense[c<VRP]->Wait }
onTick[c>=LRI]->Pace state Pace {
onTick[c<LRI]->Wait{++c;} entry {send MkPace;}
onSense[c>=VRP]->Wait { onTick->Wait {c=0;}
c=0; } }
} }
environment Heart { nondet smTrigger(Sense); }
assign lri: 500 <= lri <= 1500 && lri % 20 == 0;
assign vrp: 0 <= vrp <= 0.2 *vrp;
total state set Ifor Pacer: smInState(Wait)
&& c == 0 && LRI == lri && VRP == vrp;
inductive for Pacer onTick
from: I
environment: Heart
conditions: after smInState(Wait)
before smInState(Pace)
exists c == LRI;
Listing 2: Sample pacing logic in mbeddr
We call the approach to use domain-speciÔ¨Åc extensions of C,
tailored to veriÔ¨Åcation purposes, domain-speciÔ¨Åc C veriÔ¨Åca-
tion (DSCV). Translation to veriÔ¨Åable C is used to perform
the veriÔ¨Åcation itself. Figure 1 compares our approach to the
state of the practice in C veriÔ¨Åers such as CBMC. Today, a
practicing developer has to manually bridge the abstraction
gap between the application domain and the implementa-
tion by manually encoding the system and the to-be-veriÔ¨Åed
properties in C (with the exception of some property-speciÔ¨Åc
tools, see Section 6). He also has to interpret the low-level
veriÔ¨Åcation results in the context of the application domain.
DSCV, in contrast, provides language extensions for these
Figure 1: Todays C veriÔ¨Åcation in practice (left ) vs. DSCV
tasks. The SUV is encoded as a domain-speciÔ¨Åc model1, and
the veriÔ¨Åcation conditions as well as the environment are ex-
pressed relative to the abstractions in the model. However,
since the model is implemented using C extensions (and not
with a separate modeling language), the full expressiveness
of C is available to the developer when needed. The veriÔ¨Å-
cation results, obtained from the C-level veriÔ¨Åcation tool, are
lifted to the abstractions relevant to application domain, clos-
ing the cycle. DSCV requires the following steps to obtain a
veriÔ¨Åcation tool tailored to a speciÔ¨Åc application domain:
1. Create language extensions to model the system
2. Create extensions for veriÔ¨Åcation conditions
3. Create extensions for the veriÔ¨Åcation environment
4. Create a veriÔ¨Åcation schema
5. Implement the interaction with the veriÔ¨Åer
The use of language workbenches (discussed in Section 2.1)
makes it straightforward to develop extensions for program-
ming languages to support veriÔ¨Åcation. Once built, the ver-
iÔ¨Åcation extensions can be reused to support veriÔ¨Åcation of
similar systems. New veriÔ¨Åcation extensions can be built
for fundamentally dierent systems in a modular way, i.e.,
without invasively modifying C or existing extensions.
Contribution This paper makes three contributions:
The DSCV approach that simpliÔ¨Åes veriÔ¨Åcation of pro-
grams by using domain-speciÔ¨Åc language extensions. It
combines existing C veriÔ¨Åcation approaches with lan-
guage engineering techniques
An instantiation of DSCV for state-based software in C,
relying on the CBMC veriÔ¨Åcation tool and the extensible
version of C provided by mbeddr
A validation of DSCV based on the implementation and
veriÔ¨Åcation of a cardiac pacemaker pulse generator
From a user‚Äôs perspective, the beneÔ¨Åt of DSCV is that the
expression, validation and maintenance of the SUV, the ver-
iÔ¨Åcation conditions and the environment is simpliÔ¨Åed due to
closer alignment with the application domain. VeriÔ¨Åcation
schemas support automated and reusable domain-speciÔ¨Åc
veriÔ¨Åcation methods. From the perspective of the veriÔ¨Å-
cation developer, our approach enables modular, domain-
speciÔ¨Åc veriÔ¨Åcation in which new constructs for modeling
1In this paper, the term model always refers to the SUV ex-
pressed with application domain abstractions.
540SUVs, environments, veriÔ¨Åcation conditions and for veriÔ¨Åca-
tion schemas can be added in a modular way. DSCV lever-
ages the advances in C-level veriÔ¨Åcation tools and brings
them closer to the end-users through language engineering.
Previous Work This work builds on our previous research
on using language engineering techniques for improving the
usability of C-level veriÔ¨Åcation [33, 32]. This paper advances
our research by introducing an end-to-end veriÔ¨Åcation ap-
proach that combines high-level properties, advanced envi-
ronments, and veriÔ¨Åcation schemas to accomplish the com-
plete veriÔ¨Åcation of an executable and deployable subsystem.
Structure To implement DSCV we rely on a number of tech-
nologies, described in Section 2. Our implementation is based
on the JetBrains MPS language workbench. It provides state-
of-the-art language engineering facilities and is discussed in
Section 2.1. To supply a version of C that can be easily ex-
tended towards veriÔ¨Åcation we use mbeddr. A brief overview
over mbeddr is provided in Section 2.2. We introduce CBMC
and the connection between mbeddr and CBMC-based veri-
Ô¨Åcation in Section 2.3. In Section 3 we describe how we have
implemented DSCV for the domain of state-based software.
This section is organized along the Ô¨Åve steps required for im-
plementing DSCV mentioned above. In Section 4 we discuss
our DSCV-based contribution to the Pacemaker Challenge.
Section 5 contains a discussion of the resulting veriÔ¨Åcation
tool and compares DSCV to other veriÔ¨Åcation approaches.
Section 6 discusses related work in the veriÔ¨Åcation domain.
We conclude the paper with a summary and a short outlook
on our future work in Section 7.
Reproducing the Results Our work and results are repro-
ducible since all components are open source software. MPS
can be downloaded from JetBrains.2The mbeddr source code
can be obtained from the public Github repository.3The
pacemaker example code is a part of mbeddr, it is in the
code/applications/Pacemaker folder in the mbeddr sources.
CBMC can be obtained from the CBMC website.4We also
provide an installer5that ties all the components together,
installing MPS, CBMC and building mbeddr from sources.
2. TECHNOLOGICAL BASELINE
2.1 Language Engineering with MPS
Our work relies on language engineering [38], which refers to
deÔ¨Åning, extending and composing programming languages
and their integrated development environments (IDEs). Lan-
guage workbenches [19] are tools that support ecient lan-
guage engineering. Our implementation relies on the Jet-
Brains MPS language workbench, which, unlike most other
language workbenches [18], uses projectional editing.
Projectional Editing The conventional approach for lan-
guage implementation relies on deÔ¨Åning a grammar and then
deriving a parser, which recognizes structure in the program
text and materializes it into an abstract syntax tree (AST). An
IDE is essentially a text editor which runs the parser incre-
mentally to maintain the AST. The IDE also provides services
such as syntax highlighting, navigation or code completion,
2http://jetbrains.com/mps
3http://github.com/mbeddr/mbeddr.core
4http://www.cprover.org/cbmc/
5http://mbeddr.fortiss.org/download/
Figure 2: Fragment of language structure deÔ¨Ånition
and directly integrates the type checker and a compiler, if any.
Many of these services rely on the AST. As discussed in [24],
most grammar-based language engineering approaches and
tools are limited in terms of modular extensibility or com-
posability of grammars, because, depending on the grammar
class, grammars are not closed under composition. While [24]
also points out that purely declarative syntax deÔ¨Ånitions can
address this challenge to a degree, there are still important
cases where composability remains limited.
Projectional editing is a dierent approach to deÔ¨Åning, ex-
tending and composing languages and IDEs. A projectional
editor does not rely on a parser. Instead, as a user edits a
program, the AST is modiÔ¨Åed directly6. Projection rules cre-
ate a representation of the AST with which the user interacts,
and which reÔ¨Çects the resulting changes (Figure 3 steps 1 and
2). As the user edits the program, program nodes are created
as instances of language concepts. Concepts are the kinds of
AST nodes, similar to metaclasses in traditional modeling ap-
proaches. In the editor, a code completion menu lets users
create instances based on a text string entered in the editor
called the alias. The valid aliases (and thus the concepts
available for instantiation) are determined by the language
deÔ¨Ånition. Importantly, every next alias must be recognized as
it is entered, so there is never any parsing of a structured text
sequence. In contrast to parser-based systems, where dis-
ambiguation is performed by the parser after a (potentially)
complete program has been entered, in projectional editing,
disambiguation happens at the time when the user picks a
concept from the code completion menu: if two concepts
deÔ¨Åne the same alias, the user resolves the ambiguity.
In a projectional editor every program node has a unique
identiÔ¨Åer and also points to its deÔ¨Åning concept. So once a
node is created, there is never any ambiguity what it repre-
sents, irrespective of its syntax. References between program
elements are represented as references to the identiÔ¨Åer. These
references are also established during program editing by di-
rectly selecting reference targets from the code completion
menu. This is in contrast to parser-based systems, where a
reference is expressed as a string in the source text and a sep-
arate name resolution phase resolves the target AST element.
DeÔ¨Åning and Extending a Language Projectional editing
makes it simple to deÔ¨Åne languages and IDEs, or extend them with
new constructs. Implementing a new language starts with the
language structure, deÔ¨Åning language concepts. Figure 2A
shows the example of an IfStmt that consists of a list of
statements in its body and an Expression as the condition.
Figure 2B shows that the ifstatement and the forstatement
concepts inherit from Stmt. Similar to an object-oriented
framework, MPS supports polymorphism for language con-
cepts. Consequently, IfStmt andForStmt can be used in lo-
cations where a Stmt is expected, for example, in the body of
6The editors manipulating an AST directly date back to 1970‚Äôs
and are known also as structured editors, see e.g. [15].
541Figure 3: Projectional editing and code generation
anIfStmt. In addition to concepts and their relationships, a
language deÔ¨Ånition contains scoping rules, a type system and
further structural constraints (not discussed here; see [37]).
Each language concept also has projection rules to deÔ¨Åne
its representation in the editor. The notation can be textual,
tabular, symbolic or graphical; mixing these notations is also
possible, and a single concept can have several independently
deÔ¨Åned editors so that the notation of a program can be cho-
sen by the user. In this paper we use mostly textual notations,
because these are natural for C code. The textual notation of
an AST in MPS should not be confused with real textual edit-
ing, however: it still uses the projectional approach. Exam-
ples of other notations used in mbeddr can be found in [39].
The particular details of deÔ¨Åning projection rules are beyond
the scope of this paper and are described in [38].
It is possible to extend languages without invasively chang-
ing their deÔ¨Ånition. An extending language deÔ¨Ånes new
concepts and their relationship to existing concepts of the
extended language, as in Figure 2. Consider extending C
with an unless statement: we create a new language that
contains an UnlessStmt concept that has a condition and a
body as children, similar to the IfStmt, in Figure 2A. Next
we make UnlessStmt inherit from the existing Stmt concept.
We then deÔ¨Åne a projection rule that renders UnlessStmt as
unless (cond ) {body }. A typing rule ensures that the con-
dition is Boolean. Since language deÔ¨Ånition in MPS always
implies IDE deÔ¨Ånition, the unless statement will beneÔ¨Åt from
the same IDE services as the base language ‚Äì the extensions
integrate seamlessly. A systematic exploration of language
extension and composition with MPS can be found in [37].
Generation and Transformation MPS languages are usu-
ally generated to real text at some point so they can be passed
to existing compilers or veriÔ¨Åcation tools. For this purpose,
the deÔ¨Ånition of a base language such as C contains a text
generator (Figure 3, step 3). For extensions, such as the
UnlessStmt, no text generator is necessary because exten-
sions are reduced to a semantically equivalent C representa-
tion before text generation is performed. Such transforma-
tions are deÔ¨Åned between ASTs where nodes can be replaced
with other nodes, additional nodes can be created and nodes
can be removed. The unless (cond ) {body }statement is
reduced to if (! cond ) {body }.
The set of transformations can form a cascade, which in-
crementally transforms extensions into C, then into C header
and implementation Ô¨Åle modules, and Ô¨Ånally into text Ô¨Åles.
The existing mbeddr generators deal with many details of tex-
tual C. For example, headers are automatically generated and
name collisions are avoided by a name mangling mechanism.
Since extensions are transformed to mbeddr C, extension de-
Figure 5: mbeddr concepts that act as extension points.
velopers do not have to care about these details. For details
about deÔ¨Åning transformations please refer to [38].
2.2 mbeddr
mbeddr is an open source project for embedded software de-
velopment based on incremental, modular, domain-speciÔ¨Åc
extension of C using language engineering technologies. Fig-
ure 4 shows an overview, details can be found in [39] and [40].
mbeddr and MPS mbeddr builds on MPS‚Äô language engi-
neering facilities to deÔ¨Åne an ecosystem of over 60 languages.
mbeddr speciÔ¨Åcally relies on language extension [37], where
extending languages depend on an existing C base language
and add additional constructs in a modular way.
mbeddr Languages As illustrated in Figure 4, mbeddr comes
with an extensible implementation of C at its core. On top of
that, mbeddr provides a library of reusable extensions useful
for developing embedded software. As a user writes a pro-
gram, he can import language extensions from the library.
The main extensions include test cases, interfaces and com-
ponents, state machines, decision tables and physical units
for types and literals. For many of these extensions mbeddr
provides an integration with veriÔ¨Åcation tools (in particular,
CBMC [10]). mbeddr also supports three important aspects of
the software engineering process: requirements speciÔ¨Åcation
and tracing [41], product line variability, and documentation.
We return to the requirements and tracing support when we
brieÔ¨Çy discuss validation of veriÔ¨Åed systems in Section 4.
mbeddr Extension Points To make typical language ex-
tensions simple to build, mbeddr comes with a set of abstract
concepts and interfaces that act as extensions points: domain-
speciÔ¨Åc extensions inherit from one of these extension point
concepts (Figure 5). In the following we use state machines
to illustrate some of these extension points because state ma-
chines play an important role in the pacemaker example.
IModuleContent is a base for various module-level, or Ô¨Åle-
level in terms of C, abstractions (Figure 5A). For example,
struct declarations and functions, as well as mbeddr state
machines inherit from IModuleContent.
The imperative behavior of C is expressed as statement
lists. If a new kind of statement is required, the Statement
concept must be used as the parent (Figure 5B). For example,
mbeddr provides the smTrigger(event )statement which
triggers a state machine with an in-event. Lists of statements
can also be contained in other extensions, typically module
contents or other statements. For example, state machines
contain statement lists in entry actions of states. C expres-
542Figure 4: Layered architecture of mbeddr. It is based on MPS and provides a set of modular extensions to C (the ones most
relevant for this paper are highlighted). At the back-end, it relies on established compilers and analysis tools.
sions represent values.7New expressions can be created by
extending Expression. For example, all binary operators in
mbeddr C (like +,-, etc.) extend Expression transitively via
BinaryExpression (Figure 5D). mbeddr supports a number
of expressions related to state machines. One of them is the
smInState(state )Boolean expression which tests whether
a state machine is in the state passed as the argument. Expres-
sions are used also in the veriÔ¨Åcation, as shown in Figure 7A
and Figure 7C. Finally, every expression and variable in C has
a type. Whenever the type system of C has to be extended,
a new type is deÔ¨Åned that inherits from the Type concept
(Figure 5C) and a typing rule is added.
2.3 C VeriÔ¨Åers and Language Engineering
C veriÔ¨Åers such as CBMC [10], SATABS [11] or CPAchecker [7]
are powerful enough to perform veriÔ¨Åcation of subsystems.
However, they are not used in practice to their full potential
due to, among other reasons, usability challenges.
C veriÔ¨Åers are designed to reason about properties of C
code including built-in robustness checks, user-deÔ¨Åned as-
sertions as well as checking the reachability of error labels.
The abstraction gap between application-level properties and
C code makes it practically hard to verify application-level
properties using C veriÔ¨Åers (cf. the requirements speciÔ¨Åcation
problem [12]). Encoding application-level properties, which
are usually directly derived from application requirements
and expressed with application domain terminology, as error
labels or assert statements is tedious and error-prone [13,
31]. An additional obstacle in the context of C veriÔ¨Åcation
is the diculty to deÔ¨Åne the boundary of a SUV, because C
lacks eective means to deÔ¨Åne module boundaries.
Additionally, an environment for veriÔ¨Åcation must be spec-
iÔ¨Åed (the problem is discussed for Java in [36]). Such environ-
ments are often nondeterministic. C veriÔ¨Åcation tools oer
ways to introduce nondeterminism typically via calls to non-
deÔ¨Åned functions, uninitialised variables or unset function
parameters. assume statements can be used to constrain non-
determinism and specify assumptions on the environment.
However, just like the speciÔ¨Åcation of the veriÔ¨Åcation condi-
tions, these abstractions are code-oriented and do not relate
to the application domain. Examples of application domain-
related environment speciÔ¨Åcation primitives include ranges
for parameters, a nondeterministic choice construct, nonde-
terministic state machines or regular expressions to specify
event sequences. Language extension can be used to de-
7Even tough they are not pure because the evaluation of ex-
pressions can have side eectsÔ¨Åne new, application domain-speciÔ¨Åc language concepts for
specifying veriÔ¨Åcation conditions and environments.
However, these still have to be used in a way that actually
leads to a veriÔ¨Åcation of the conditions, and hence proves
the SUV correct relative to the environment (or not, illus-
trated with a counterexample). A speciÔ¨Åcation is required
which makes this process explicit. Problems like this one
are typical for theorem proving: how to get from a set of
explicit hypotheses to a proof of an implied conclusion? We
have explained above that, using C veriÔ¨Åers, it is hard to ex-
press the hypotheses (an environment) and the conclusion
(the given conditions hold). It is even harder to express a
veriÔ¨Åcation procedure and argue for its correctness, since C
is not designed for such purposes. Based on the application
domain-level veriÔ¨Åcation conditions and environments, ad-
ditional language extensions can be used to express veriÔ¨Å-
cation schemas.
Finally, tool integration must be provided that simpliÔ¨Åes
understanding of counterexamples and enables Ô¨Åxing of de-
fects detected by the veriÔ¨Åcation. First, the veriÔ¨Åcation tool
has to be invoked and multiple invocations have to be orches-
trated, combining their results. Second, the counterexample
obtained from the C veriÔ¨Åcation tool has to be presented at
the level of the application domain, enabling users to trace
the origin of a problem and perform the necessary Ô¨Åxes.
Summing up, we identify the following problems with
state of the art C veriÔ¨Åcation: speciÔ¨Åcation of the veriÔ¨Åcation
conditions, the environment and the veriÔ¨Åcation schema, as
well as tool integration. These challenges can be resolved by
application domain-speciÔ¨Åc C extensions targeted towards
veriÔ¨Åcation, and by providing a deep integration with C ver-
iÔ¨Åers. To be able to formulate the veriÔ¨Åcation conditions and
the environment on the level of the application domain, it
is also necessary to describe the SUV itself at that level, and
corresponding C extensions have to be provided. These rep-
resent application domain semantics directly, as opposed to
hiding them behind low-level C details. We do not see this
as a disadvantage, though, because this makes the system
implementation more maintainable, and the implementation
can be validated more easily against the requirements.
3. DOMAIN-SPECIFIC C VERIFICATION
This section describes the implementation of DSCV on top of
mbeddr for state-based software, illustrated with the pace-
maker example. The description is organized along the steps
introduced in Section 1. A detailed discussion of the pace-
maker logic itself is beyond the scope of this paper, and we
543Figure 6: Left: An example SUV model expressed as a state machine. Right: The translation of the state machine to C.
refer to the Pacemaker Challenge speciÔ¨Åcation by Boston Sci-
entiÔ¨Åc [8]. Pacemakers have dierent pacing modes; the VVI
mode is used in this section because of its simplicity. We ver-
ify the more complex DDD pacing mode with mbeddr-based
DSCV as well; see Section 4 for details.
3.1 Modeling the System under VeriÔ¨Åcation
The Ô¨Årst step when implementing DSCV is preparing lan-
guage extensions to implement the SUV. This is necessary to
align the abstraction level of the SUV with the application
domain-level veriÔ¨Åcation conditions and environment.
In many domains, requirements can be reÔ¨Åned to Ô¨Ånite-
state automata; the pulse generator of a cardiac pacemaker is
an example. We use mbeddr‚Äôs existing state machine exten-
sion, so we do not have to deÔ¨Åne our own language exten-
sions to model the SUV. In addition to enabling veriÔ¨Åcation
conditions at the abstraction level of state machines, the state
machine also acts as the boundary of the SUV. An explicit
system boundary is important for several reasons: it allows
veriÔ¨Åcation independent of the context in which the system
is used; it makes reuse in a dierent context easier; and most
importantly, the boundary makes explicit the SUV state space
relevant for the veriÔ¨Åcation processes. The boundary can be
enforced via structural constraints and data Ô¨Çow checks, both
available to the language engineer in MPS.
Figure 6 shows an example state machine and its (slightly
simpliÔ¨Åed) translation to C that serves as an executable im-
plementation and as a veriÔ¨Åcation target for CBMC. States are
translated to an enum, and variables represent internal data
and the current state (the total state). The execute() function
encodes the transition function. In the VVI pacing mode, the
two parameters LRIandVRPspecify when a pace should take
place. They are set with the incoming config event (cf. the
textual requirement at the beginning of the paper). An outgo-
ingpevent is bound to a function doPace(), which drives the
pacer hardware. The reaction to incoming events depends on
the current state, and the value of a counter cthat is used in
the transition guards; these are translated to ifcascades.
When state machines of mbeddr do not Ô¨Åt the domain
and can not be reused, new domain-speciÔ¨Åc extensions (incl.
their transformation to C), have to be deÔ¨Åned Ô¨Årst. Section 2.1
explains how to do this and Section 2.2 introduces the typical
extension points in mbeddr.
3.2 VeriÔ¨Åcation Conditions
The second step in applying DSCV is providing language ex-
tensions to specify veriÔ¨Åcation conditions. They should bealigned with the kinds of properties relevant for the SUV ac-
cording to the requirements. Like the modeling extensions,
the extensions for veriÔ¨Åcation conditions should express ap-
plication domain semantics, as opposed to C implementation
details. The extensions have to be translated to constructs
known to the C veriÔ¨Åer, typically assertions or error labels.
If the model is a state machine, veriÔ¨Åcation conditions usu-
ally relate to event sequences and states, as expressed by
linear temporal logic (LTL) [6]. We have implemented direct
support for a subset of the well-known speciÔ¨Åcation patterns
for Ô¨Ånite-state veriÔ¨Åcation introduced in [16]. These patterns
are translated to monitor code blocks in C, veriÔ¨Åed by CBMC.
Some examples of mbeddr‚Äôs temporal patterns are:
after puntil qmust: expr
before pexists: expr
between pand qexists: expr
Figure 7A shows a pattern expressing the property that the
counter chas to become the value LRI while in the Wait
state, before the machine transitions into Pace state. In the
translation to C (on the right side of the arrow), the Ô¨Çag qis
used to start and stop setting the eÔ¨Çag, which in turn encodes
the existential quantiÔ¨Åer from the veriÔ¨Åcation condition.
To support veriÔ¨Åcation of state-based software, mbeddr
provides abstractions to specify total state sets, nondetermin-
istic initialization of state machines into a speciÔ¨Åed total state
set as well as assertions on a machine state. We developed the
history extension to store and query the event history of state
machines speciÔ¨Åcally for the pacemaker. When verifying the
more complex DDD pacing mode [8], these languages are all
used together. Figure 7 shows examples.
The extensions for the veriÔ¨Åcation conditions also rely on
the extension points introduced in Section 2.2. For example,
the temporal patterns inherit from the Statement concept.
IModuleContent is used as the basis for the history language
concepts and total state set deÔ¨Ånitions. Whenever new ex-
tensions for implementing SUVs are created, they can be ac-
companied by new extensions to express SUV‚Äôs properties.
3.3 VeriÔ¨Åcation Environments
Implementing and verifying software that works in an ar-
bitrary environment is dicult and usually not necessary,
because most software systems only have to work in a (more
or less) well-deÔ¨Åned environment. However, the assump-
tions and constraints implied in the environment must be
made explicit. So the third step in implementing DSCV is the
development of extensions for specifying environments.
544Figure 7: A:A veriÔ¨Åcation condition using a temporal pattern B:A veriÔ¨Åcation environment using nondeterministic choices
C:A veriÔ¨Åcation schema element that uses nondeterministic initialization of a state machine.
Environments, by their nature, often exhibit nondetermin-
ism. Unfortunately, C lacks language constructs to eectively
deÔ¨Åne a nondeterministic yet constrained environment. And
as with the system modeling and the veriÔ¨Åcation conditions,
the speciÔ¨Åcation of the environment depends on the applica-
tion domain: for a new domain mbeddr C must be extended
with appropriate constructs.
For the pacemaker state machine, the following simple con-
structs are enough to create an overapproximation8of the real
environment‚Äôs behaviors. Figure 7B shows a nondeterminis-
tic choice construct, which either triggers an incoming event
son the state machine, or does nothing. This reÔ¨Çects the
behavior of a human heart, which at any given time may pro-
duce a beat or not, nondeterministically. The nondet_choice
construct is translated to a call to an undeÔ¨Åned function, re-
stricted by assumptions (illustrated below). A set of ifstate-
ments execute behaviors based on the result of the choice.
A state machine with a nondeterministic choice in the tran-
sition guard could be used to specify a nondeterministic en-
vironment, which is itself state-based. The corresponding
constructs are already available in mbeddr. Another useful
mbeddr environment speciÔ¨Åcation construct is a nondeter-
ministic but constrained assignment of a variable, e.g., nondet
assign xconstraint: x >= 10 . In the case of the pace-
maker, the parameters are set (nondeterministically) by the
medical doctor to a value that respects constraints deÔ¨Åned by
the system. Such an assignment is translated to a call to an
undeÔ¨Åned function and an assume statement. The code below
shows the translation of the nondet assign given above:
x = nondet _int(); __CPROVER _assume (x >= 10);
Like other veriÔ¨Åers, CBMC provides function prototypes that
can be called from user code to obtain nondeterministic data.
These functions are implemented by CBMC itself.
3.4 VeriÔ¨Åcation Schemas
The ability to model the SUV and to specify its environment
and the properties does not automatically lead to a proof of
the properties: the ingredients have to be used together in a
consistent way to formulate a property proof obligation for
the underlying veriÔ¨Åer. Traditionally this is implied in the
way the environment interacts with the SUV and the way
the veriÔ¨Åcation conditions are asserted. DSCV uses language
extensions to specify the proof obligation in an explicit and
reusable way. We call this a veriÔ¨Åcation schema.
The construction of the veriÔ¨Åcation schema is also driven
by the application domain. For a pacemaker, we assume a
8Overapproximated environments can exhibit more behav-
iors than the real environment. They can be easier to express,
e.g., as an underspeciÔ¨Åcations of the real environments. Prov-
ing a property Pfor the overapproximated environment leads
to the conclusion that Pholds also for the real environment.cyclic system where, in an interrupt service routine, a tick
counter is incremented, an environment state is read, the
events are triggered on the state machine accordingly, and
then the conditions are checked. This process repeats forever.
Figure 8 shows the veriÔ¨Åcation schema for the pacemaker, as
well as its translation to lower level veriÔ¨Åcation primitives9.
Bounded C veriÔ¨Åers such as CBMC can only verify a Ô¨Å-
nite number of these read/trigger/check cycles. This means
that the conditions are veriÔ¨Åed only for a limited execution
path of the system after its initialization. Additional eort is
needed to verify the properties during the unbounded exe-
cution path. The veriÔ¨Åcation schema for the pacemaker uses
induction to achieve this:
1. An initial set of total states Iis deÔ¨Åned for the SUV
2. The SUV is nondeterministically initialized into I
3. In a loop, the environment interaction is performed and
the properties are asserted
4. After a number of iterations, either the veriÔ¨Åcation bound
is met and the veriÔ¨Åcation fails (because CBMC is a
bounded model checker), or the SUV returns into I, mean-
ing that the induction has succeeded.
If the CBMC bound was met, then one of the following steps
can be taken: either the bound has to be increased, letting
CBMC "try harder" to prove the induction. Alternatively,
Imust be redeÔ¨Åned to be more limited, shrinking the state
space the veriÔ¨Åer must explore. Meeting the bound may also
mean that the system really is notcyclic (i.e., a problem has
been found). If the SUV returns to I, then, by induction,
the asserted properties hold along any unbounded execution
path of the SUV, given that it starts from a total state in I.
The last step in making the inductive proof valid is to show
that the precondition (that the execution starts in I) is met.
In the simplest case, the system is in Iright after a regular,
deterministic initialization. Otherwise it must be proven sep-
arately that the properties hold along the execution path that
leads into Ifrom the SUV‚Äôs initial total state, into which the
system is (deterministically) initialized during the actual ex-
ecution. In such a case the veriÔ¨Åer may have to be invoked
more than once, and the tool integration (discussed in Sec-
tion 3.5) must take care of orchestrating these invocations.
The inductive veriÔ¨Åcation schema for the pacemaker (Fig-
ure 8) resembles an inductive proof on the state machine, as
the translation on the right side of the Ô¨Ågure shows. The in-
duction is performed on the tick event t. First, a state machine
9This is an example of a transformation cascade. The schema
is not translated to C directly. Instead, it is translated to lower-
level veriÔ¨Åcation extensions which are themselves reduced to
C by downstream transformations.
545Figure 8: Left: Inductive veriÔ¨Åcation schema example and
Right: Its translation
is initialized nondeterministically10to a set of total states
Initial, from which an inductive step starts, represented
as a loop. The loop body consists of triggering nondetermin-
istically the sevent, which is equivalent to a nondet_choice
from Figure 7B. Second, the veriÔ¨Åcation condition is asserted,
see Figure 7A, and, Ô¨Ånally, tis triggered again. The MAX_LRI
constant deÔ¨Ånes the maximum number of loop iterations un-
til the induction step should converge, bringing the state ma-
chine back to the Initial set of total states. This is ensured
with an assertion that checks that that the state machine is
back in the Initial set of total states at some step.
As this example demonstrates, veriÔ¨Åcation schemas can be
used to step beyond the capabilities of the underlying veriÔ¨Åcation
tool, proving more or stronger properties. For example, the
veriÔ¨Åcation schema for the pacemaker described above over-
comes the bounded nature of CBMC.
For the end user the schema implementation is hidden and
veriÔ¨Åcation is truly performed at the application domain-
level. Once created, the veriÔ¨Åcation schema can be reused
with other SUVs, initial states and conditions. This reuse
leads to lower eort for the veriÔ¨Åcation of similar systems,
making veriÔ¨Åcation more feasible for the practitioner. In the
case of the pacemaker veriÔ¨Åcation, multiple pulse generator
modes can be veriÔ¨Åed with the same veriÔ¨Åcation schema.
3.5 Interfacing with the C VeriÔ¨Åer
We have shown how application domain-speciÔ¨Åc languages
such as state machines enable us to deÔ¨Åne higher level veriÔ¨Å-
cation conditions, veriÔ¨Åcation environments, and veriÔ¨Åcation
schemas. To perform the proofs we use the external C-level
model checker CBMC. Two steps are necessary for integrat-
ing the veriÔ¨Åer tool into mbeddr.11First, the veriÔ¨Åer must be
parametrized and invoked. Second, the C-level counterex-
amples produced by the veriÔ¨Åer in the case where a property
fails, must be lifted to the abstraction level of the domain.
Invoking the VeriÔ¨Åer The problem of invocation and con-
Ô¨Åguration is addressed with analysis conÔ¨Ågurations, imple-
mented as another language extension. In addition to holding
CBMC-related conÔ¨Åguration parameters, they also identify
the entry point, a function from which the veriÔ¨Åcation starts.
Since CBMC performs only relatively simple and isolated
checks (e.g., based on label reachability), the tool integration
also orchestrates the potentially multiple invocations neces-
sary for verifying application domain-level properties.
To implement a new analysis conÔ¨Åguration for CBMC, one
can inherit from the CBMCBasedAnalysisConfiguration con-
10Figure 7C deÔ¨Ånes a total state set Initial and shows a
nondeterministic initialization of a state machine. Initial
requires the state to be Pace, but keeps the values of c,LRI,
andVRPunspeciÔ¨Åed, assuming that VRP < LRI .
11We consider here only non-interactive veriÔ¨Åers, which can
run in a batch mode, CBMC is one of these.
Figure 9: Lifted counterexample in mbeddr
cept. A subclass of Analyser is created to orchestrate the
calls to the veriÔ¨Åcation tool. This is a rather mechanical task;
however, a framework is provided to support extensibility.
Counterexample Lifting The actual veriÔ¨Åcation happens on
C level, and the counterexample obtained from the veriÔ¨Åer
is also expressed in terms of C. To make it meaningful to the
user, it has to be lifted to the level of the SUV expressed as a
model, its environment and veriÔ¨Åcation conditions. Figure 9
illustrates how the counterexample is shown to the user: the
view contains the failed property as well as the counterexam-
ple represented as a debug trace on the model level. Techni-
cally, the steps are bound to lines in the C code. As part of
the lifting process, we shorten the CBMC output considering
only the data that is relevant for showing the execution trace
on the level of the application domain extensions: typically,
several execution steps at the C-level can be lifted to a single
execution step at the domain-speciÔ¨Åc language (DSL) level.
The veriÔ¨Åcation tool output is thus compressed, becoming
more accessible to the user (the highlighted assignment in
Figure 9 corresponds to over 25 lines of XML veriÔ¨Åer output).
Relying on MPS, mbeddr keeps track of the mapping of the
original program nodes to the Ô¨Ånal line numbers in the tex-
tual C representation. This enables us to bind the trace steps
to the program nodes of the SUV. The UI supports navigation
from the trace to the SUV code.
4. DSCV AND PACEMAKER CHALLENGE
Over the last years there have been many approaches to ad-
dress the Pacemaker Challenge [8] by using high-level mod-
eling languages and veriÔ¨Åcation at the model level. However,
none uses C directly to implement the pulse generator. The
work in [30] demonstrates a tool chain that enables the trans-
lation of a veriÔ¨Åed UPPAAL model to StateÔ¨Çow and then to
C, applying it to a Pacemaker case study. In [26] the Vienna
Development Method (VDM) is applied. In [34], the pace-
maker is modeled using PROMELA and veriÔ¨Åed using the
SPIN model checker; the corresponding C code, however, is
hand-written based on a set of guidelines. In [21] Z is used
to specify the pacemaker and to subsequently synthesize C
code via the Perfect Developer tool.12Event-B is employed
in [27] to formally model the pulse generator, EB2C generates
C code from the Event-B model. In [25] the AADL language
with BLESS annotations are used to model and verify a pace-
maker VVI pacing mode. In all cases listed above, the generated
executable code, when obtained, is not veriÔ¨Åed. The veriÔ¨Åcation
is performed only at the model level, and testing is used to
check the C code. With DSCV, while supporting application
domain-level models for the SUV, the veriÔ¨Åcation conditions
and the environment, always verify the generated C code.
12http://www.eschertech.com/
546Figure 10: Pacemaker parameters table with ranges, as
taken from the requirements document [8].
Deployment We used DSCV and mbeddr to implement and
verify one of the more complex pacing modes, called DDD,
verifying all the functional properties it must fulÔ¨Ål. We then
deployed13the generated and veriÔ¨Åed code to an Arduino-
based system, performing hardware in the loop tests. These
tests revealed no faults in the implementation.
The ability to deploy the veriÔ¨Åed code shows that the code
is ecient enough to run on the intended target platform;
this is critically important for real-world use. To the best
of our knowledge, we are the only group in the Pacemaker
Challenge that has implemented a fully functionally veriÔ¨Åed,
executable, deployable, and lightweight DDD pacing logic.
Validating the System VeriÔ¨Åcation, as discussed in this pa-
per, refers to the automated checking of formally speciÔ¨Åed
veriÔ¨Åcation conditions relative to a system implementation
and a well-deÔ¨Åned environment. However, in the end, a sys-
tem must be validated, not just veriÔ¨Åed. Validation ensures
that the system reÔ¨Çects the original requirements, typically
speciÔ¨Åed as prose. In the context of veriÔ¨Åcation this means
that the veriÔ¨Åcation conditions must reÔ¨Çect the requirements.
DSCV and mbeddr help with this aspect via application do-
main alignment and requirements tracing.
DSCV-based models, conditions and environment are eas-
ier to validate than the corresponding C code would be, be-
cause they are aligned more closely with the application do-
main. However, this can be taken further: the primitives
for specifying environments can be combined to create more
high-level environment constructs. For example, in the Pace-
maker speciÔ¨Åcation [8] many parameters are described in
tables (Figure 10). Since mbeddr supports tabular notations,
it is possible to create such tables in mbeddr and transform
them into the primitives presented above. For instance, the
Ô¨Årst row of the table can be translated to:
nondet assign LRI constraint:
(LRI >= 30 && LRI < 50 && LRI % 5 == 0)
|| (LRI >= 50 && LRI < 90)
|| (LRI >= 90 && LRI <= 175 && LRI % 5 == 0)
In addition, the physical units provided by mbeddr could be
used to enhance the type system checks.
mbeddr supports a language for requirements speciÔ¨Åca-
tion that Ô¨Çexibly combines prose text and formal speciÔ¨Åca-
tions [41]. For example, the tables mentioned in the previ-
ous paragraph can be embedded into a requirements docu-
ment. Even in this case they can be translated into veriÔ¨Åcation
conditions. mbeddr also supports ubiquitous tracing. Any
program node (expressed in any language) can be traced to
requirements (speciÔ¨Åed using mbeddr or external tools such
as DOORS14). This way any modeling, veriÔ¨Åcation or envi-
ronment artifact can be directly linked to the requirements,
further aiding with validation.
13With the kind help of our colleague Thomas B√∂hm.
14http://ibm.com/software/products/en/ratidoor5. DISCUSSION
On the trustworthiness of veriÔ¨Åcation results. DSCV re-
lies on extending C with speciÔ¨Åc constructs for veriÔ¨Åcation,
translating them to C and running a C veriÔ¨Åer subsequently.
The code that is generated from the SUV will subsequently be
executed on the target platform (the veriÔ¨Åcation conditions
and the environment will not be deployed, of course). As a
consequence, all C details are veriÔ¨Åed to the degree they are
addressed by the veriÔ¨Åer. At the same time, the speciÔ¨Åcation
is more concise and closer to the application domain, which
makes it easier to validate (see previous section).
Despite deploying the veriÔ¨Åed code, errors in the trans-
formation of the extensions to C may lead to undiscovered
problems and hence, bugs in the executing code. However,
the separate translation of the model, the conditions and the
environment increases the conÔ¨Ådence in the veriÔ¨Åcation re-
sult, since, for a systematic mistake, all three translations have
to be consistently wrong. Providing veriÔ¨Åed transformations
would be the ultimate solution. This is unlikely to be practi-
cally feasible today, e.g. because mbeddr does not formally
deÔ¨Åne semantics for its languages.
On hiding low-level details about the veriÔ¨Åcation. The ex-
tension developer has to deal with the details of the low-level
veriÔ¨Åcation, since he has to develop the transformations and
the lifting of the results. However, from the perspective of
the application developer the extensions hide the low-level
details, with one exception: a developer still has to provide
the correct parameters for executing CBMC. Failing to do so
may lead to faulty veriÔ¨Åcation, as a consequence of, for exam-
ple, too short path lengths. So users still have to understand
what CBMC does and how it has to be parametrized ‚Äì but
specifying and maintaining the model, the conditions and the
environment is simpliÔ¨Åed. In addition, since the veriÔ¨Åcation
veriÔ¨Åes C code, the scalability issues of C-level veriÔ¨Åcation
apply: depending on the structure and the size of the SUV,
the veriÔ¨Åcation may suer from state explosion.
On the eorts for building the extensions. Once the
domain-speciÔ¨Åc extensions are available for a given appli-
cation domain, expressing models, conditions and environ-
ments becomes more ecient. However, the extensions have
to be built Ô¨Årst. Building the state machines extensions took
the mbeddr team a few weeks. Development of the exten-
sions for conditions and environments to verify state ma-
chines can be done in a few days. Both requires developers
who have experience with developing languages with MPS;
this in itself requires a few weeks to learn. Whether these
few weeks and days are feasible in a given domain must be
judged in each case separately. Like with all reusable assets,
the decision depends on how often a set of extensions are ex-
pected to be used. Considering that the pacemaker contains
many dierent pacing modes (implemented with dierent
state machines and veriÔ¨Åcation conditions) we think that the
trade-o makes sense in this particular case.
On the end-user workÔ¨Çow. Assuming the extensions are
available, we expect developers to use veriÔ¨Åcation-driven de-
velopment: the model, the conditions and the environment
are evolved iteratively, in parallel. This is similar in spirit to
test-driven development [4], and has two advantages. First,
after each iteration, the SUV, the conditions and the environ-
ment are in sync, and the trust in the SUV builds over time.
Similar to test-driven development, the repeated veriÔ¨Åcation
547drives the design of the SUV to be modularized in a way that
makes the veriÔ¨Åcation feasible in terms of complexity and
performance (smaller modules, well-deÔ¨Åned interfaces). In
contrast, experience tells us that it is often infeasible to verify
a system after it has been implemented fully, without consid-
eration for veriÔ¨Åcation during the implementation process.
On using DSCV with other domain-speciÔ¨Åc constructs. We
have shown that state machines are a good basis for DSCV.
However, the approach is not restricted to state machines. We
are currently using DSCV for checking component contracts
(discussed in [33]) and for checking the consistency of data
Ô¨Çow models (as a part of a commercial tool for Siemens PL
(LMS); we cannot disclose the details here).
On applicability to other base languages. We have inte-
grated CBMC with mbeddr, leading to more domain-speciÔ¨Åc,
and hence more usable veriÔ¨Åcation. This is made possible by
two ingredients. The Ô¨Årst one is a veriÔ¨Åcation tool (such as
CBMC) that supports label reachability analysis and assertion
checking in the target language. Reachability and assertions
are useful because they support encoding of many other ver-
iÔ¨Åcation goals in the target language. The second ingredient
is a way to eciently deÔ¨Åne modular extensions (for mod-
els, conditions and environments) for the desired base lan-
guage (C in our case). We conjecture that the same approach
can be used for other languages if these two ingredients are
available. For example, Java PathÔ¨Ånder [22] can be used to
perform reachability analysis for Java, and SugarJ [17] can be
used to extend Java (and its IDE).
6. RELATED WORK
Code-level veriÔ¨Åcation and speciÔ¨Åcation: Compared to ex-
isting ways of specifying veriÔ¨Åcation conditions [3, 20, 9],
DSCV enables their expression at the level of the application
domain. DSCV directly addresses the fourth challenge from
[23]: [..] to Ô¨Ånd eective ways to structure software such that
formal veriÔ¨Åcation techniques [..] become simpler to use and more
eective in identifying potential violations of correctness properties
in executable code. mbeddr is extensible to dierent domains or
formalisms; extensions can be used together in an integrated
fashion, in the same IDE, and together with non-veriÔ¨Åed parts
of a system. DSCV and mbeddr eliminates for the user the
overhead in using and integrating dierent languages and
tools. Next, there is no need to annotate the implementation
code with additional veriÔ¨Åcation-speciÔ¨Åc information (such
as loop invariants in Frama-C [3]), the semantics are implied
in the extensions. This enables the clean separation of im-
plementation and veriÔ¨Åcation concerns and makes the ver-
iÔ¨Åcation more accessible. In [28] C program properties are
encoded using a language that allows expressing LTL formu-
las with C boolean expressions over global variables. From
these properties a monitor thread is generated and a model-
checker is used for veriÔ¨Åcation. An algorithm drives the
interleaving between the monitor thread and the program to
ensure that property checks are performed at all meaningful
program locations. In contrast, DSCV requires the user to take
care of interleaving monitors correctly with the code. DSCV
is not restricted to LTL properties: users are encouraged to
create their own high-level property speciÔ¨Åcation extensions.
Thus, the results of [28] could be exploited using DSCV by
adding new languages for properties and generating monitor
threads as in [28], and using a suitable model-checker. In [2],
the low-level C-like SLIC speciÔ¨Åcation language is used to ex-press potential library misuse problems in C programs. SLIC
makes it easy to encode simple temporal patterns. C code
is generated from SLIC, and veriÔ¨Åcation is used to detect
property violations. Our approach diers by providing an
extensible way to build and verify programs on the applica-
tion domain abstraction level, rather than checking programs
for a speciÔ¨Åc category of bugs.
High-level speciÔ¨Åcation languages: When compared to
tools for verifying models expressed in high-level speciÔ¨Åca-
tion languages such as Z [35] or Isabelle/HOL [29], DSCV
beneÔ¨Åts from close integration with C. First, the the veriÔ¨Åed
C program is a strict superset of the artifact that is deployed
on the target device; some of the auxiliary code required for
veriÔ¨Åcation is not deployed. This reduces the speciÔ¨Åcation
and implementation eort (since it has to be done only once)
and also reduces the potential for mismatches between spec-
iÔ¨Åcation and implementation. Second, in contrast to separate
languages with downstream code generation, DSCV beneÔ¨Åts
from the close integration with C: low level code can be used
where necessary and no semantic and tool integration prob-
lems arise when combining the to-be-veriÔ¨Åed code with the
rest of the system.
Existing modeling and veriÔ¨Åcation tools: In comparison to
modeling and veriÔ¨Åcation tools such as Scade [1], Simulink15
or UPPAAL [5], DSCV is focused on C-level veriÔ¨Åcation. It
supports modular extensions of C for dierent application
domains, and for each extension it provides suitable veriÔ¨Å-
cation mechanisms including rich veriÔ¨Åcation environments
and schemas. In addition, since the conditions and environ-
ments are implemented as C extensions, it is possible to use
C-code seamlessly together with the high-level extensions, as
long as the SUV boundary remains intact (see Section 3.1).
7. CONCLUSION AND FUTURE WORK
The constantly improving C veriÔ¨Åcation tools are not used at
their full potential. In this paper we presented a novel ap-
proach that improves the practicality of these tools by using
language engineering. We addressed the problems of specify-
ing the veriÔ¨Åcation conditions and veriÔ¨Åcation environments
in a way that is aligned with the application domain and pro-
vided veriÔ¨Åcation schemas to specify proof obligations. We
implemented our approach using mbeddr and CBMC in the
domain of state-based software. We validated our DSCV im-
plementation by building a functionally veriÔ¨Åed, lightweight,
deployable cardiac pulse generator.
mbeddr‚Äôs extensibility supports straightforward adapta-
tion to other domains as well as other kinds of veriÔ¨Åcation
conditions, environments and schemas. Our approach can
be used with other languages as long as modular language
extension is possible and a veriÔ¨Åcation tool is available sup-
porting assertions and label reachability analysis.
Our future work will proceed along the following lines:
First, we will investigate the degree to which partial environ-
ment assumptions that are targeted towards the veriÔ¨Åcation
of individual properties can be speciÔ¨Åed. Second, we will
investigate veriÔ¨Åcation schemas and environments for com-
position of systems. Third, we will experiment with a ver-
iÔ¨Åcation cloud where remote veriÔ¨Åcation agents execute the
veriÔ¨Åer continuously. Finally, we will use MPS‚Äô new support
for graphical notations to represent state machines graphi-
cally, further simplifying validation.
15http://www.mathworks.de/products/simulink
5488. REFERENCES
[1] P . A. Abdulla, J. Deneux, G. St√•lmarck, H. √Ögren, and
O. √Ökerlund. Designing Safe, Reliable Systems using
Scade. In Leveraging Applications of Formal Methods,
pages 115‚Äì129. Springer, 2006.
[2] T. Ball, B. Cook, V . Levin, and S. K. Rajamani. SLAM
and Static Driver VeriÔ¨Åer: Technology Transfer of
Formal Methods inside Microsoft. In Integrated Formal
Methods, volume 2999 of Lecture Notes in Computer
Science, pages 1‚Äì20. Springer, 2004.
[3] P . Baudin, J. Filliatre, C. Marche, and et al. ACSL:
ANSI/ISO C SpeciÔ¨Åcation Language.
http://frama-c.com/acsl.html, 2012.
[4] K. Beck. Test-driven Development : by Example.
Addison-Wesley, 2003.
[5] J. Bengtsson, K. G. Larsen, F. Larsson, P . Pettersson, and
W. Yi. UPPAAL - a Tool Suite for Automatic VeriÔ¨Åcation
of Real-Time Systems. In Hybrid Systems, volume 1066
ofLecture Notes in Computer Science, pages 232‚Äì243.
Springer, 1995.
[6] B. B√©rard, M. Bidoit, A. Finkel, F. Laroussinie, A. Petit,
L. Petrucci, and P . Schnoebelen. Systems and Software
VeriÔ¨Åcation: Model-Checking Techniques and Tools.
Springer, 1st edition, 2010.
[7] D. Beyer and M. E. Keremoglu. CPAchecker: A Tool for
ConÔ¨Ågurable Software VeriÔ¨Åcation. In Proceedings of the
23rd International Conference on Computer Aided
VeriÔ¨Åcation, volume 6806 of Lecture Notes in Computer
Science, pages 184‚Äì190. Springer, 2011.
[8] S. Q. R. L. Boston ScientiÔ¨Åc. PACEMAKER System
SpeciÔ¨Åcation, http://sqrl.mcmaster.ca/pacemaker.htm,
2007.
[9] P . Chalin, J. R. Kiniry, G. T. Leavens, and E. Poll.
Beyond Assertions: Advanced SpeciÔ¨Åcation and
VeriÔ¨Åcation with JML and ESC/Java2. In Proceedings of
the 4th International Conference on Formal Methods for
Components and Objects, pages 342‚Äì363. Springer, 2006.
[10] E. Clarke, D. Kroening, and F. Lerda. A Tool for
Checking ANSI-C Programs . In Tools and Algorithms for
the Construction and Analysis of Systems, volume 2988 of
Lecture Notes in Computer Science, pages 168‚Äì176.
Springer, 2004.
[11] E. Clarke, D. Kroening, N. Sharygina, and K. Yorav.
SATABS: SAT-based Predicate Abstraction for ANSI-C .
InTools and Algorithms for the Construction and Analysis
of Systems (TACAS 2005), volume 3440 of Lecture Notes
in Computer Science, pages 570‚Äì574. Springer, 2005.
[12] J. C. Corbett, M. B. Dwyer, J. Hatcli, and Robby. A
Language Framework for Expressing Checkable
Properties of Dynamic Software. In 7th International
SPIN Workshop, volume 1885 of Lecture Notes in
Computer Science, pages 205‚Äì223. Springer, 2000.
[13] L. Cordeiro, B. Fischer, H. Chen, and J. Marques-Silva.
Semiformal VeriÔ¨Åcation of Embedded Software in
Medical Devices Considering Stringent Hardware
Constraints. In International Conferences on Embedded
Software and Systems, pages 396‚Äì403, 2009.
[14] P . Dhaussy, F. Boniol, J.-C. Roger, and L. Leroux.
Improving Model Checking with Context Modelling.
Advances in Software Engineering, 2012, 2012.
[15] V . Donzeau-Gouge, G. Huet, G. Kahn, and B. Lang.
Programming Environment Based On StructuredEditors: The MENTOR Experience.
http://bat8.inria.fr/ lang/papers/RR-0026.pdf, 1980.
[16] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns
in property speciÔ¨Åcations for Ô¨Ånite-state veriÔ¨Åcation. In
Proceedings of the 21st International Conference on Software
Engineering, pages 411‚Äì420. ACM, 1999.
[17] S. Erdweg, T. Rendel, C. K√§stner, and K. Ostermann.
SugarJ: Library-based Syntactic Language Extensibility.
InProceedings of the 26th Annual ACM SIGPLAN
Conference on Object-Oriented Programming, Systems,
Languages, and Applications, volume 46, pages 391‚Äì406.
ACM, 2011.
[18] S. Erdweg, T. van der Storm, M. V√∂lter, M. Boersma,
R. Bosman, W. R. Cook, A. Gerritsen, A. Hulshout,
S. Kelly, A. Loh, et al. The State of the Art in Language
Workbenches - Conclusions from the Language
Workbench Challenge. In Software Language
Engineering, pages 197‚Äì217. Springer, 2013.
[19] M. Fowler. ‚ÄúLanguage Workbenches: The Killer-App
for Domain SpeciÔ¨Åc Languages?‚Äù.
http://www.martinfowler.com/articles, 2005.
[20] A. A. E. Ghazi, M. Ulbrich, C. Gladisch, S. S.
Tyszberowicz, and M. Taghdiri. JKelloy: A Proof
Assistant for Relational SpeciÔ¨Åcations of Java
Programs. In 6th Symposium, NASA Formal Methods,
pages 173‚Äì187, 2014.
[21] A. O. Gomes and M. V . Oliveira. Formal Development
of a Cardiac Pacemaker: From SpeciÔ¨Åcation to Code. In
Proceedings of the 2nd World Congress on Formal Methods,
pages 692‚Äì707. Springer, 2009.
[22] K. Havelund and T. Pressburger. Model Checking JAVA
Programs using JAVA PathFinder. International Journal
on Software Tools for Technology Transfer, 2(4):366‚Äì381,
2000.
[23] G. J. Holzmann, R. Joshi, and A. Groce. New
Challenges in Model Checking. In 25 Years of Model
Checking, volume 5000 of Lecture Notes in Computer
Science, pages 65‚Äì76. Springer, 2008.
[24] L. C. L. Kats and E. Visser. The Spoofax Language
Workbench: Rules for Declarative SpeciÔ¨Åcation of
Languages and IDEs. In Proceedings of the 25th Annual
ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications,
pages 444‚Äì463. ACM, 2010.
[25] B. Larson, P . Chalin, and J. Hatcli. BLESS: Formal
SpeciÔ¨Åcation and VeriÔ¨Åcation of Behaviors for
Embedded Systems with Software. In 5th Symposium,
NASA Formal Methods, pages 276‚Äì290, 2013.
[26] H. D. Macedo, P . G. Larsen, and J. S. Fitzgerald.
Incremental Development of a Distributed Real-Time
Model of A Cardiac Pacing System using VDM. In 15th
Intl. Symp. on Formal Methods, pages 181‚Äì197, 2008.
[27] D. M√©ry and N. K. Singh. Formal Development and
Automatic Code Generation : Cardiac Pacemaker. In
International Conference on Computers and Advanced
Technology in Education, 2011.
[28] J. Morse, L. Cordeiro, D. Nicole, and B. Fischer.
Context-Bounded Model Checking of LTL Properties
for ANSI-C Software. In In Intl. Conf. on Software
Engineering and Formal Methods, volume 7041 of Lecture
Notes in Computer Science, pages 302‚Äì317. Springer,
2011.
549[29] T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL:
a proof assistant for higher-order logic. Springer, 2002.
[30] M. Pajic, Z. Jiang, I. Lee, O. Sokolsky, and
R. Mangharam. From VeriÔ¨Åcation to Implementation:
A Model Translation Tool and a Pacemaker Case Study.
InIEEE 18th Real-Time and Embedded Technology and
Applications Symposium, pages 173‚Äì184. IEEE, 2012.
[31] H. Post, C. Sinz, F. Merz, T. Gorges, and T. Kropf.
Linking Functional Requirements and Software
VeriÔ¨Åcation. In 17th IEEE International Requirements
Engineering Conference, pages 295‚Äì302. IEEE Computer
Society, 2009.
[32] D. Ratiu, M. Voelter, Z. Molotnikov, and B. Sch√§tz.
Implementing Modular Domain SpeciÔ¨Åc Languages
and Analyses. In Proceedings of the 9th Workshop on
Model-Driven Engineering, VeriÔ¨Åcation and Validation,
pages 35‚Äì40. ACM, 2012.
[33] D. Ratiu, M. V√∂lter, B. Kolb, and B. Sch√§tz. Using
Language Engineering to Lift Languages and Analyses
at the Domain Level. In 5th Symposium, NASA Formal
Methods, pages 465‚Äì471, 2013.
[34] A. Sharma. Technical Report: Towards A VeriÔ¨Åed
Cardiac Pacemaker.
http://www.comp.nus.edu.sg/√£sankhs/pdf/, 2010.
[35] J. M. Spivey and J. Abrial. The Z Notation. Prentice Hall
Hemel Hempstead, 1992.[36] O. Tkachuk, M. B. Dwyer, and C. S. Pasareanu.
Automated Environment Generation for Software
Model Checking. In 18th IEEE International Conference
on Automated Software Engineering, pages 116‚Äì129. IEEE
Computer Society, 2003.
[37] M. Voelter. Language and IDE Development,
Modularization and Composition with MPS. In
Generative and Transformational Techniques in Software
Engineering 4, Lecture Notes in Computer Science,
pages 383‚Äì430. Springer, 2011.
[38] M. Voelter, S. Benz, C. Dietrich, B. Engelmann,
M. Helander, L. Kats, E. Visser, and G. Wachsmuth.
DSL Engineering ‚Äì Designing, Implementing and Using
Domain-SpeciÔ¨Åc Languages. CreateSpace Publishing
Platform, 2013.
[39] M. Voelter, D. Ratiu, B. Kolb, and B. Sch√§tz. mbeddr:
Instantiating a Language Workbench in the Embedded
Software Domain. Journal of Automated Software
Engineering, 20(3):339‚Äì390, 2013.
[40] M. Voelter, D. Ratiu, B. Sch√§tz, and B. Kolb. mbeddr: an
extensible C-based programming language and IDE for
embedded systems. In Proc. of Conference on Systems,
Programming, and Applications: Software for Humanity,
pages 121‚Äì140. ACM, 2012.
[41] M. Voelter, D. Ratiu, and F. Tomassetti. Requirements as
First-Class Citizens. In Proc. Modellbasierte Entwicklung
eingebetteter Systeme IX, Schloss Dagstuhl, pages 44‚Äì49,
2013.
550