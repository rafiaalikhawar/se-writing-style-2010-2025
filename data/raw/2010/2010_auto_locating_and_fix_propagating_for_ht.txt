Auto-Locating and Fix-Propagating for HTML
Validation Errors to PHP Server-side Code
Hung Viet Nguyen, Hoan Anh Nguyen, Tung Thanh Nguyen, Tien N. Nguyen
Electrical and Computer Engineering Department
Iowa State University
{hungnv,hoan,tung,tien }@iastate.edu
Abstract —Checking/correcting HTML validation errors in
Web pages is helpful for Web developers in ﬁnding/ﬁxing bugs.
However, existing validating/ﬁxing tools work well only on static
HTML pages and do not help ﬁx the corresponding server code if
validation errors are found in HTML pages, due to several chal-
lenges with dynamically generated pages in Web development.
We propose PhpSync, a novel automatic locating/ﬁxing tool
for HTML validation errors in PHP-based Web applications.
Given an HTML page produced by a server-side PHP program,
PhpSync uses Tidy, an HTML validating/correcting tool to ﬁnd
the validation errors in that HTML page. If errors are detected,
it leverages the ﬁxes from Tidy in the given HTML page and
propagates them to the corresponding location(s) in PHP code.
Our core solutions include 1) a symbolic execution algorithm on
the given PHP program to produce a single tree-based model,
called D-model , which approximately represents its possible client
page outputs, 2) an algorithm mapping any text in the given
HTML page to the text(s) in the node(s) of the D-model and
then to the PHP code, and 3) a ﬁx-propagating algorithm from
the ﬁxes in the HTML page to the PHP code via the D-model
and the mapping algorithm. Our empirical evaluation shows that
on average, PhpSync achieves 96.7% accuracy in locating the
corresponding locations in PHP code from client pages, and 95%
accuracy in propagating the ﬁxes to the server-side code.
Index Terms —Fix Propagation, Bug Localization, PHP Dy-
namic Web Applications, Validation Errors
I. I NTRODUCTION
Web applications have become a critical infrastructure in
our society. The World Wide Web Consortium (W3C) has
developed several standards to ensure the development of
high-quality and reliable Web applications [1]. An important
quality criterion for a Web application is Markup Validity [2],
which deﬁnes the validity of a Web document in HTML and
other client-side markup Web languages according to their
corresponding grammar, vocabulary, and syntactical rules.
Although modern Web browsers handle very well the pars-
ing of even not well-formed HTML pages, some software
defects in Web applications are not always easily caught due to
the client-server and dynamic nature of Web contents. Check-
ing HTML validation errors could really help the process of
ﬁnding and ﬁxing bugs in Web development. In a survey
conducted by W3C [3], a majority of Web professionals stated
that validation errors is the ﬁrst thing they check whenever
they run into a Web styling or scripting bug. Creating Web
pages according to a widely accepted standard also makes
them easier to maintain and evolve, even if the maintenance
and evolution is performed by different developers [3].Recognizing the importance of markup validity for Web
pages, several organizations/individuals have produced auto-
matic Web page validating tools (also called HTML valida-
tors). Some HTML validators (e.g. Tidy [4]) also provide
automatic support for ﬁxing markup errors to convert an
HTML page into a well-formed one that conforms to HTML
grammar and syntax. However, such auto-ﬁxing tools work
well only on static HTML pages and do not address several
challenges in current Web development. The ﬁrst challenge is
that in a Web application, a client-side HTML page is often
dynamically generated from the server-side code, which is
written in different languages. For example, the server code is
written in PHP, ASP, Perl, SQL, etc., while a client-side page is
in HTML, JavaScript, CSS, and so on. The generated HTML
code is embedded within the string literals or the values of
variables in the server code. Moreover, those values are also
scattered in multiple locations in server pages. For example,
to produce an HTML table, multiple variables and string con-
stants in different functions in the server code can be involved.
Importantly, because the server code dynamically produces
different client pages depending on run-time situations, if a
validation error is found and reported in a Web page (e.g. via
Tidy), it is challenging for its developers to manually map the
buggy location(s) back to its source(s) in the server-side code.
We propose PhpSync, an auto-locating and ﬁx-propagating
tool for HTML validation errors in PHP-based Web applica-
tions. Given an HTML page produced by a PHP server page,
PhpSync uses Tidy, an HTML validating/correcting tool to ﬁnd
any validation errors on the HTML page. If errors are detected,
PhpSync leverages the ﬁxes from Tidy in the given HTML
page and propagates them to the corresponding location(s) in
the PHP code. In the cases that Tidy cannot provide the ﬁxes,
the auto-locating function in PhpSync will help developers to
quickly locate the corresponding buggy locations in PHP code
from the buggy HTML locations found by Tidy. PhpSync does
not require the input that produces the erroneous page.
The dynamic nature of a Web application is addressed via
our symbolic execution algorithm that symbolically executes
the given PHP program to create a single tree-based represen-
tation, called D-model , which approximates its possible HTML
client page outputs. Each D-model represents a symbolic,
string-based value that is resulted from the symbolic execution
of any PHP expression(s). The D-model for the entire PHP
server page or function is composed by the D-models resultedfrom the intermediate computations during the symbolic exe-
cution of the expressions in that page/function. Symbols in a
D-model represent users’ inputs, data retrieved from databases,
or unresolved values. A node in a D-model represents either 1)
a determined value (e.g. a string literal), 2) a non-determined
data value (e.g. a user’s input), 3) a concatenation operation,
4) a selection operation, or 5) a repetition operation on other
nodes/values. This allows PhpSync to model the multi-valued
and scattered server-side data and the multiple versions of
client-side code generated from the server code.
Another fundamental technique in PhpSync is CSMap,
an algorithm that maps any text in the given HTML page
produced by the given PHP program to the corresponding
PHP code location by mapping that text to the node(s) of the
corresponding D-model. Then, our ﬁx-propagating algorithm
derives the ﬁxing changes from Tidy to the given HTML page
and propagates them to the locations in PHP via the established
client-to-server mappings. CSMap is generic and can be used
in other applications such as locating the corresponding buggy
PHP places for other types of errors found in an HTML page.
Our empirical evaluation on real-world Web applications
shows that PhpSync achieves on average 96.7% accuracy in
locating the corresponding locations in PHP code from client
pages, and 95% accuracy in ﬁx-propagating to server code.
The key contributions of this paper include:
1) PhpSync, an auto-locating and ﬁx-propagating tool for
HTML validation errors in PHP-based Web applications;
2) CSMap, a mapping algorithm from an HTML page
(produced by a PHP page) to the corresponding PHP locations;
3) an empirical evaluation on several real-world Web appli-
cations to show PhpSync’s correctness and efﬁciency.
Section II presents a motivating example. Section III dis-
cusses our representation model. Associated algorithms are de-
scribed in Sections IV and V . Section VI is for our evaluation.
Related work is in Section VII. Conclusions appear last.
II. M OTIVATING EXAMPLE AND APPROACH OVERVIEW
This section presents an example that illustrates a bug
caused by an HTML validation error and the challenges in
ﬁxing such errors in PHP-based Web applications.
A. An Example of a Bug on an Ill-formed Web Page
This example is inspired from an online social network
system in which users are able to connect with peers/friends
via posting and sharing news, pictures, and videos in their
daily activities. In this system, a user can view and provide
comments on the posts from his/her friends’ pages. Figure 1a
displays such a page when a short news item on ASE 2011 is
posted. Each post is followed by one or multiple comments and
a textbox along with a submission button for a user to enter a
new comment. After the comment is provided and the button
is pressed, the new comment is expected to appear at the end
of the comments’ list, and the textbox and the button would
be positioned at the bottom of the page for another comment
as in Figure 1b. However, when a user entered a comment,
the textbox and the submission button appeared before that
Fig. 1. Output of PHP Page in Browser
Page index.php
1<html><head>
2<script language=’javascript’ src=’ajax.js ’ ></script>
3<link rel =”stylesheet” type=”text/css” href=”style.css” / >
4</head><body>
5<div class =’out’>
6<div class =’inImg’><img src =ASElogo.gif width =’40’ /></div>
7<div class =’inPost’ >ASE 2011 <br>Submission is now open. </div>
8</div>
9<div id =’divComments’ class =’out’>
10<div class =’inComment’ >Hung Nguyen: Great news! </div>
11<!−−miss closing the divtag on line 9−−>
12<div class =’out’>
13<input id =’txtComment’ type=’text’>
14<input type =’button ’value =’Comment’ onclick =’comment()’ >
15</div>
16</body></html>
Fig. 2. HTML Client-side Code for Figure 1
newly input comment (see Figure 1c). Assume that this bug
was found and reported by a user on that page.
From the point of view of the developer of this Web-based
social network application, in order to understand and ﬁx this
bug, (s)he would naturally ﬁrst examine the HTML code of
that Web page (Figure 2) to see if there was any error in its pre-
sentation structure. (S)He could do this veriﬁcation manually
or use an automatic HTML validator such as Tidy [4]. Assume
that (s)he found that the code missed a closing tag </div>for
the opening tag <div>at line 9. Therefore, (s)he discovered
that the bug was caused by the missing </div>: the last page
division (lines 12-15) is included within the page division
starting at line 9, making the textbox and button belong to
the same page division for the comment list. When the user
submitted a comment, it was appended to the end of the page
division for comments and appeared below the textbox.
B. Challenges for Validation and Bug Fixing on Web Pages
The ﬁx in the HTML code would be straightforward as the
developer should add a </div>closing tag at line 11 for the
corresponding open tag at line 9. However, that HTML page
wasdynamically generated from PHP-based server code (Fig-
ure 3). With a PHP-based Web application, (s)he must locate
and ﬁx the corresponding buggy code in the server. Doing this
task manually is challenging in general due to several reasons.1) The mapping/tracing from a client HTML page to server-
side code is not straightforward. A Web application is a client-
server one and generally developed in multiple languages . The
server code could be written using a scripting language, e.g.
PHP, while the client-side code is in HTML for presentation
and JavaScript (JS) for data processing and event handling.
2) When the server-side code executes at the server, client-
side code is generated and sent to a browser to execute there.
That is, PHP-based server-side code dynamically produces
different HTML pages depending on different inputs. For
example, depending on the login information of a user at
run-time, different ﬁles are included, different functions are
executed, different execution paths in PHP code are taken in
order to generate a particular client page. In this motivating
example, to ﬁx the bug, the developer would start examining
the ﬁle index.php on the server side (Figure 3a) because (s)he
found the error in the client page index.php . However, the bug
is not within the ﬁle index.php of the server side. That PHP
ﬁle is responsible for checking if a user has logged in (line 3,
Figure 3a) via islogged infunction in the ﬁle functions.php (line
2), which also contains other utility and formatting functions in
the system (Figure 3d). The ﬁle main.php (Figure 3b) contains
the code handling the cases of correct logins, while error.php
(Figure 3c) handles the incorrect cases. In practice, validation
errors are found in a client page via an HTML validation
tool [4] and reported without corresponding input and action
steps to produce that page. Thus, to ﬁx them, a developer might
have to check many server-side ﬁles and execution paths to
ﬁnd the right execution path that produces that client page.
3) Due to the dynamic nature of PHP/HTML/JS and the
generation of client-side code, in a Web application, code and
data tend to be mixed, especially client-side code is often
embedded in server-side data . For example, the code of the
divtags are embedded within PHP string literals. Moreover, a
piece of HTML code might be generated via many PHP string
literals, variables, and functions that are scattered in different
places in the server-side code. In this example, the <body>
element of the main HTML page is generated from the values
of several scattered literals, variables, and function calls. To
locate the right place to ﬁx the <div>tag, the developer needs
to check several literals and differentiate between many tags
with the same name <div>that appear in several places in
main.php and functions.php . In this example, the developer must
determine that the error is in the addComments function in
functions.php (line 12, Figure 3d). In reality, the numbers of
included ﬁles, functions, variables, literals, and execution paths
might be very high and they are scattered, thus making it
challenging for a developer to manually locate the bug.
4) In this example, the PHP statement that prints out
the erroneous HTML line is line 8 of Figure 3b: echo add-
Comments(...) . However, to ﬁx that error, a developer in fact
must change line 12 of Figure 3d ( $output .= “ \n”;) where the
erroneous HTML line is composed and manipulated.
This example shows that HTML validation errors could
cause run-time bugs even when a browser can still display the
page. As a user submitted a comment by clicking the button,a) File index.php
1<?php
2 include ”functions.php”;
3 if(! islogged in()) include ”error.php”;
4?>
5<html><head>
6<script language=’javascript’ src=’ajax. js ’ ></script>
7<linkrel=”stylesheet” type=”text /css” href=”style .css” / >
8</head><body>
9<?php include ”main.php”; ? >
10</body></html>
b) File main.php
1<?php
2// connect to the database to get the content of the post and its
comments
3// and store them to the variables $post and $comments, respectively
4echo ”<div class=’out’ >” .
5 ”\n ” . addImage(”ASElogo.gif”) .
6 ”\n ” . addPost($post) .
7 ”\n</div>\n”;
8echo addComments($comments);
9echo ”<div class=’out’ >” .
10 ”\n<input id=’txtComment’ type=’text’ >” .
11 ”\n<input type=’button’ value=’Comment’ onclick=’comment()’ >” .
12 ”\n</div>\n”
13?>
c) File error.php
1<html><body><?php
2 $msg = ”User not logged in”;
3 echo $msg;
4 exit;
5?></body></html>
d) File functions.php
1<?php
2function is logged in(){...}
3function addImage($src) {...}
4function addPost($post) {return ”<div class=’inPost’ >”.$post.”</div>”;}
5function addComment($comment) {
6 return ”<div class=’inComment’ >” . $comment . ” </div>”;
7}
8function addComments($comments) {
9 $output = ” <div id=’divComments’ class=’out’ >”;
10 foreach ($comments as $comment)
11 $output .= ”\n ” . addComment($comment);
12 $output .= ”\n”; // miss closing the div tag on line 9
13 return $output;
14}
15?>
Fig. 3. PHP Server-side Code Example
the JS function comment (not shown) was invoked (line 11,
Figure 3b). Due to the missing <div>tag, it incorrectly updated
the corresponding division in the page via Ajax framework,
thus, causing the incorrect page as in Figure 1c.
C. Approach Overview
We propose PhpSync, an auto-locating and ﬁxing tool for
validation errors in PHP-based Web applications. Given an
HTML page produced by a server-side PHP program, PhpSync
uses Tidy [4] to ﬁnd the validation errors on the page. If errors
are found, it propagates the ﬁxes from Tidy on that HTML
page to the corresponding location(s) in PHP code. The ideas
are as follows: 1) PhpSync performs a symbolic execution to
approximately represent all possible client-side HTML outputs
of a server page Swith a single tree-based model, called D-modelD; 2) it maps the given HTML page C, i.e. a concrete
HTML output, to the D-model, and then, to the server-side
codeS; 3) it uses Tidy to validate/ﬁx the page Cinto a well-
formed page and recovers the ﬁxes applied to C; and 4) it
ﬁnally propagates these ﬁxes to Svia the mapping established
betweenCandS(viaD). Let us describe our approach.
III. D- MODEL : REPRESENTATION OF CLIENT PAGES
A. D-model Representation
D-model is a tree-based representation for any symbolic,
string-based value resulted from a symbolic execution on
any portion of server-side PHP code. The D-model for the
entire PHP server page/function is composed by the D-models
resulted from the intermediate computations during a symbolic
execution of the PHP expressions of that page/function. That
is, PhpSync also creates D-models to represent possible values
of intermediate computations and combines them into larger
D-models for later computations. A D-model often contains
symbols to represent user inputs, data retrieved from databases,
or unresolved values. By performing a symbolic execution on
a PHP page, PhpSync approximates all possible outputs/client
pages with a single D-model. Let us explain it in details.
First, the string outputs for a portion of PHP code are
stream-like, i.e. are produced via sequential writing or con-
catenation operations on PHP string values. The string value
Tof a data-related PHP expression or the string value resulted
from a string computation in PHP can be produced using the
following context-free production rules [5]:
Rule 1. T →t
Rule 2. T →T . T
Rule 3. T →T|T
Rule 1 says that, the value of a PHP expression can be a
string literal. Rule 2 means that the value of a PHP expression
can be concatenated from the values of two PHP expressions.
Rule 3 speciﬁes that a PHP expression can have either one of
two values depending on the actual execution path at runtime.
For example, in Figure 3a, the output of the page index.php is
produced using Rule 3 due to the ifstatement at line 3 (i.e. it
is either one of two strings), while the string output at line 9
ofmain.php is produced using Rule 2 (i.e. it is concatenated by
four strings). Both production processes use Rule 1. Rules 2
and 3 are also used to repeatedly produce a value. For example,
the value of variable $output of the function addComments in
functions.php is produced by repeatedly using a foreach loop
via Rule 2 (lines 10-11, Figure 3d). Those rules for output
production of PHP code suggest the following structure.
Deﬁnition 1: AD-model is a labeled, ordered tree, in
which the leaf nodes represent the values, and the inner-nodes
represent the operations for combining those values.
1. There are two kinds of leaf nodes:
•Aliteral node represents a determined string value (e.g.
a PHP literal), and
•Asymbolic node represents an undetermined/unresolved
string value (e.g. a user input).
2. There are three types of inner nodes, representing three
kinds of operations on D-models:•AConcat node represents a value that is concatenated
from the values corresponding to the sub-trees of that
node. The order of the sub-trees represents the order of
the concatenation operation.
•ASelect node represents a value that could be selected
from the values corresponding to its sub-trees.
•ARepeat node represents a value that could be repeat-
edly concatenated from the values corresponding to the
sub-trees of the only child node of that Repeat node.
3. The nodes on D-models have their attributes describing
additional information, such as the PHP expressions associated
with literal and symbolic nodes.
Figure 4 illustrates a D-model that represents the output of
the page index.php in Figure 3a. As seen, the root node of the
D-model is a Select node, representing that the corresponding
output of this PHP page is selected from the two values
of two corresponding sub-trees of that root node. The left
and right subtrees correspond to the outputs if error.php or
main.php is executed, respectively. The root node of the right
subtree is a Concat node representing the concatenation of the
values of multiple literals (represented as literal nodes), e.g. the
string literal “</div></ div>”, the variables $post and $comment
(represented as symbolic nodes), and the return values from
different function calls. The return value of function call
addComments is represented as the D-model rooted at the
second Concat node, with its child node Repeat representing
the repetition in the foreach loop. Consecutive string literals
are combined for a compact D-model representation.
Note that a D-model approximates all possible symbolic
outputs of PHP code by symbolically executing all of its exec-
ution paths. However, it does not represent all possible paths.
B. Building D-model via Symbolic Execution
We develop an algorithm to evaluate/compute the symbolic
value for the output of any PHP code by building its D-
model. It takes as an input the code of a PHP server page,
and performs a symbolic execution to create a D-model for a
special variable $Output , to represent the output of that page.
During execution, it creates the D-models for the intermediate
results and updates the D-models for encountered variables.
The algorithm recursively evaluates all statements in all
branches, updates/creates small D-models, and combines them
into larger ones. It processes the PHP statements as follows:
1.E→scalarValue : As a scalar/string value is encountered,
a literal node is created to contain the corresponding string.
2.E1→$V=E2: Since a variable might have different
values at different points in execution, PhpSync maintains for
each variable Va D-model corresponding to its most recent
value during the execution. When meeting an assignment
expression, PhpSync computes the D-model for the expression
E2, and assigns that D-model as the most recent value of V.
3.E→$V: When a variable Vis retrieved for a computation,
its latest D-model is used. However, if Vdoes not have any
D-model, PhpSync returns a symbolic node representing an
undetermined value. This corresponds to the cases of user in-
puts, data values from databases, or unresolved computations.Repeat <div id='divComments'
class='out'>Concat
<html><head>
<script language='javascript' src='ajax.js'></script>
<link rel="stylesheet" type="text/css" href="style.css" />
</head><body>
<div class='out'>
<div class='inImg'><img src=ASElogo.gif width='40' /></div>
<div class='inPost '></div>
</div>$postSelect
<html><body>
User not logged in
</body></html>
Concat
<div class='inComment '> </div> $comment<div class='out'>
<input id='txtComment' type='text'>
<input type='button'
value='Comment' onclick='comment()'>
</div>
</body></html>$Output
Concat
Fig. 4. D-model Representation for the Outputs of the PHP Page index.php of Figure 3a.
4.E1→E2.E3: For an expression with a concatenation,
PhpSync processes the sub-expressions to produce their D-
models, and then creates the resulting D-model with its root
node being a Concat node. The sub-trees of that root node are
the computed D-models of the sub-expressions. Those subtrees
are connected in the same order as the appearance order of the
corresponding sub-expressions. PhpSync also performs other
standard string and arithmetic operations in a similar process.
Un-resolved results are represented as symbolic nodes.
5.S→echo E : When seeing an echo/print statement, PhpSync
concatenates the current D-model of the variable $Output and
the D-model of Eto produce the new D-model for $Output .
Note that $Output holds the current output of the PHP page.
6.S1→ if(E) S2 elseS3: For an ifstatement, PhpSync
executes both branches, and collects into a set V*all variables V
modiﬁed in either branch. Let us use VS2.Dand VS3.Dto denote
the D-models of Vafter executing each branch, respectively.
For each VinV*, PhpSync updates its value with a new D-
model. The new D-model is rooted at a new Select node whose
children are VS2.Dand VS3.D. If the elsebranch is empty, the
latest D-model for Vbefore the ifstatement is used in place
ofVS3.D. The same treatment is for Switch statements.
7.S1→while (E) S2 : First, PhpSync executes statement S2
once and collects all modiﬁed variables Vinto V*. Typically,
the string value of a variable is appended during the execution
of a loop. Let us use DVto denote the D-model that represents
the symbolic string value appended to V. For a variable VinV*,
PhpSync updates its value with a new D-model. The new D-
model is rooted at a new Concat node whose children are V.D
and a new Repeat node (Figure 4). The Repeat node has DV
as its only child. If the value of Vis not appended in the loop,
PhpSync currently does not handle it and retains the old value
ofVbefore the loop. The same treatment is for a forstatement.
8.S→return E : When PhpSync meets a return statement, the
D-model of Eis computed and collected into a set retValues of
all possible returned values of the current function/ﬁle.
9.function call . When a function is called, PhpSync assigns
the D-models of the actual arguments to the formal parameters
of the function, and then performs a symbolic execution on theTABLE I
SYMBOLIC EXECUTION RULES ON PHP C ODE TO BUILD D-MODELS
PHP Syntax Evaluation Rule To Build D-model
E→scalarValue E.D = new LiteralNode(scalarValue)
E1→$V = E2 V .D = E2.D, E1.D = E2.D
E→$V if V .D<> null then E.D = V .D
else E.D = new SymbolicNode($V)
E1→E2.E3 E1.D = new Concat (E2.D, E3.D)
S→echo E $Output.D = new Concat ($Output.D, E.D)
S1→if (E) S2 ∀V∈V*, V .D = new Select (VS2.D, VS3.D)
else S3
S1→while (E) S2 ∀V∈V*, V .D = new Concat (V .D, new Repeat (DV))
S→return E curfunc.retValues = cur func.retValues ∪E.D
or cur ﬁle.retValues = cur ﬁle.retValues ∪E.D
E→func({argi}) func.retValues = ∅,∀ifunc.param i.D = arg i.D,
execute func, E.D = new Select (func.retValues)
E1→include E2 ﬁle = computeValue(E2.D), ﬁle.retValues = ∅,
execute ﬁle, E1.D = new Select (ﬁle.retValues)
E→exit() curprog.outputValues =
curprog.outputValues ∪$Output.D
prog→ { Si} prog.outputValues = ∅, execute {Si},
prog.outputValues = prog.outputValues ∪$Output.D
$Output.D = new Select(prog.outputValues)
function’s code. After executing the function, it creates a new
D-model with its root being a new Select node to describe the
possibly multiple returned values of the function. The children
of that Select node are the D-models in the retValues set of the
function. If the function has only one returned value, the D-
model of that returned value is used. If global variables and
reference parameters are modiﬁed during the execution of the
function, their D-models also updated accordingly. If the code
of the called function is unavailable (e.g. library functions), it
represents the returned value by a symbolic node.
10. E1→include E2 : PhpSync computes the string value
from the D-model of E2and considers it as a ﬁle name fname .
Then, it continues the execution on that ﬁle. Finally, the D-model of E1is assigned with a new D-model whose root is at
a new Select node with its children being all returned values
after executing fname as in the case of a function call.
11.exit(): If PhpSync meets an exitfunction call, the D-model
of$Output is collected into outputValues set of the current page.
12.block of statements: After executing all statements in the
PHP program/page, PhpSync creates a new D-model with its
root being a new Select node to describe the possibly multiple
outputs of the page . The children of that Select node are the
D-models in the set outputValues of the page.
While building the D-models, PhpSync also keeps the map-
ping between the D-model leaf nodes and their corresponding
PHP fragments. For example, the literal node <div class=... >
under the lowest Concat node in Figure 4 is mapped to the
fragment <div class=... >on line 6 of Figure 3d. For the mapping
of a symbolic node, PhpSync also keeps its execution trace.
For example, the node $post of Figure 4 is mapped to line 4 of
Figure 3d (inside the function’s body), and the trace includes
line 4 of Figure 3d, line 6 of Figure 3b, and lines 2-3 of
Figure 3b. That trace is useful for developers in examining
the output corresponding to $post (i.e. line 7 of Figure 2).
The limitation of PhpSync lies in the approximation of the
symbolic executions of ifand for/while statements. The condition
of an ifis not evaluated and only string-appending operations
on variables are handled in a loop. PhpSync also does not han-
dle well library function calls if the source code is unavailable.
IV. CSM AP: M APPING TEXTS OF CLIENT PAGE TO
SERVER PAGE VIA D-MODEL
Let us present CSMap algorithm that maps any text in an
HTML page to the corresponding location in a server page. It
takes as inputs an D-model Dand a string C, divides Cinto
proper sub-strings and maps them to the corresponding literal
or symbolic nodes in D, and then to PHP literals or variables.
A. Algorithm Design Strategies
A D-model Dfor a server page can be considered as a
context-free grammar (CFG) and a string Cis one of its
concrete sentences. However, the traditional CFG parsing/-
compiling techniques [6] are not suitable and efﬁcient here
because the D-model always contains multiple symbols (i.e.
symbolic values) that correspond to user inputs, etc. Therefore,
we design CSMap with the following heuristic strategies:
1. Top-down and divide-and-conquer: with the goal of map-
ping texts to the leaf nodes in D, it is natural to perform the
mapping of the substrings in Cto the sub-trees in D. CSMap
follows the top-down process as in top-down parsers [6].
2. Pivoting: despite that the HTML pages are dynamically
generated, the shared/static HTML code portions among (some
of) those outputs of a PHP page occur very often. CSMap
attempts to map the string Cto these shared code portions
inDﬁrst, and then uses them as the already-mapped pivots
for further dividing and conquering. That is, the process will
continue on the substrings of Cdivided by those pivots.
3. Local best-matching: Since there may exist many selec-
tion nodes, CSMap could face the combinatorial explosion if it1function CSMap (C, D)
2StrToDModel(C, r←D.root)
3end
4//−−−−−−−−− Handling Literal Nodes −−−−−−−−−−−−−−−−
5function StrToDModel(String str, LiteralNode literal )
6substring←str.FindFirstOccurence(literal.val)
7 if(substring is found)
8 substring.MapLocation ←literal
9end
10//−−−−−−−−− Handling Concat Nodes −−−−−−−−−−−−−−−
11function StrToDModel(String str , Concat concat)
12 if(concat.numChildren == ∅)return
13 if(concat.numChildren == 1) StrToDModel(str, concat.ﬁrstChild); return ;
14 Pivot = FindPivot(str , concat.children)
15 if(Pivot<>null)
16 str . Split (Pivot, ﬁrstSubStr , secondSubStr)
17 concat.Split (Pivot, ﬁrstHalfNodes, secondHalfNodes)
18 StrToDModel(ﬁrstSubStr, ﬁrstHalfNodes)
19 StrToDModel(secondSubStr, secondHalfNodes)
20 else
21 StrToDModel(str, concat. ﬁrstChild )
22 StrToDModel(str.GetUnmapped(), concat.removeFirstChild())
23end
24function FindPivot(String str , DModelList list )
25 list .RetainOnlyLiteralDModels()
26 for(dmodel∈list)
27 count = FindOccurrences(str, dmodel.stringVal)
28 if(count == 1) return dmodel
29 end
30 return null
31end
32//−−−−−−−−− Handling Symbolic Nodes −−−−−−−−−−−−−−
33function StrToDModel(String str, SymbolicNode node)
34 Siblings←node.Parent.ChildNodes
35 if(node.GetRightSibling(Siblings) is a Pivot)
36 str .MapLocation←node
37end
38//−−−−−−−−− Handling Select Nodes −−−−−−−−−−−−−−−−
39function StrToDModel(String str, Select select)
40 TString←FString←str
41 StrToDModel(TString, select.trueBranch)
42 StrToDModel(FString, select.FalseBranch)
43 if(TString.MappedLength >FString.MappedLength)
44 str .MapLocation←TString.MapLocation
45 else str .MapLocation←FString.MapLocation
46end
47//−−−−−−−−− Handling Repeat Nodes −−−−−−−−−−−−−−−−
48function StrToDModel(String str, Repeat repeatNode)
49 Before←str.MappedLength
50 StrToDModel(str, repeatNode.ChildNode)
51 After←str.MappedLength
52 if(Before<After)
53 StrToDModel(str.GetUnmapped(), repeatNode)
54end
Fig. 5. CSMap Algorithm: Mapping from HTML page to D-model
tries to exhaustively explore all combinations of their branches
and perform optimal matching. Thus, for a selection node,
CSMap uses a local best-matching strategy by ﬁrst exploring
all branches of the selection node and mapping to the branch
with more matched characters. This choice is made locally for
each selection without considering globally optimal matching.
B. Detailed Algorithm
Figure 5 shows the pseudo-code for CSMap algorithm. It
is designed as the recursive function StrToDModel whose inputs
are a string Cand the root node rof a D-model. There are
ﬁve overloading functions StrToDModel corresponding to ﬁve
types of D-model nodes. During the execution, the attribute
MapLocation of each substring in Cis assigned with at most
one reference to a node in the D-model (i.e. its mapped node).
CSMap handles each of the ﬁve node types as follows:1. Ifris a literal node, rhas a value val. Ifvalappears in
str(i.e. is its substring), then the characters of that substring
are mapped to r. However, since strmight have several occu-
rrences of val, by a greedy strategy, CSMap maps the ﬁrst occu-
rrence of valinstrtor, i.e. favoring the leftmost mapped string.
2. Ifris a Concat node, CSMap considers stras a
concatenation of the values corresponding to the sub-trees
ofr. To ﬁnd the optimal mapping, one might need to divide
strinto all possible sub-strings and map each of them to the
corresponding sub-tree of r. However, to simplify the divide-
and-conquer step, CSMap uses the pivoting strategy. It ﬁnds a
pivot by checking the string of a literal node among the sub-
trees ofrto see if it occurs only once in str. If such a pivot
exists, it is used to divide strinto two sub-strings, and the
list of child nodes of rinto two sub-lists rooted at two new
Concat nodes for further mapping (lines 16-19). If such a node
does not exist, CSMap maps strto the ﬁrst subtree of rand
recursively maps the remaining texts in str(after the already-
mapped portions) to the other subtrees of r(lines 21-22).
3. Ifris a symbolic node, CSMap checks whether the
sibling node of ris a pivot. If it is, CSMap considers the string
stras the value generated from r, thus, maps all characters of
strtor. If a pivot does not exist, CSMap does not map strto
rbecause it tries to map strwith other sibling nodes of r.
4. Ifris a Select node, stris considered to be produced
from one of the D-models corresponding to the sub-trees of
r. Thus, CSMap recursively maps strto each sub-tree of r,
and chooses the sub-tree with the higher number of mapped
characters as the mapping for str(lines 43-45).
5. Ifris a Repeat node,Cis considered as the concate-
nation of the values produced by the sub-trees of D after
some number of iterations. CSMap attempts to map strto the
child node of r, which represents the appendix string in one
iteration. It will continue to map the remaining of struntil no
more mapping is gained (lines 52-53).
Finally, after determining the mapping between the client-
pageCand the D-model Dvia CSMap, PhpSync uses the
mapping from Dto PHP code established during building D
to map the texts in Cto PHP literals, variables, or statements.
Example. Let us revisit the example in Figure 2 with the
D-model in Figure 4 to illustrate CSMap. CSMap starts by
mapping the entire HTML page to the D-model rooted at a
Select node. For a Select node, CSMap ﬁrst attempts to map
the code to each branch separately. In this case, the ﬁrst branch
is the string “... User not logged in ...” , which does not exist in the
HTML code, thus it remains unmapped. The second branch,
however, starts at a Concat node with several pivot nodes that
are helpful for the mapping. In particular, its ﬁrst, third, and
ﬁfth child nodes are string literals that occur exactly once in
the HTML code, hence CSMap maps the corresponding sub-
strings in the HTML code to those literal nodes.
The remaining sub-strings “ASE 2011 <br>Submission is now
open.” (line 7) and lines 9-10 of Figure 2, are mapped re-
spectively to the remaining child nodes (i.e. the symbolic
node $post and the next Concat node). For that Concat
node, CSMap again ﬁnds that its ﬁrst child node ( “<divid=’divComments’...” ) corresponding to line 9 (Figure 2) is a pivot.
Therefore, it maps the remaining substring on line 10 to the
Repeat node (Figure 4). For a Repeat node, its contained
D-model rooted at the child node Concat is mapped to the
substring repeatedly until no further mapping is found. In this
example, the substring can be mapped to the two literal nodes
and the symbolic node $comment after one iteration. Even if
line 10 were repeated several times, CSMap would still map
the text to the D-model with the Repeat node.
At this point, CSMap has evaluated both branches of the
Select node at the root of the top-level D-model. Comparing
the mapping results, it returns the mapping given by the second
branch where all of the HTML code is successfully mapped.
Since CSMap works heuristically, it is important that the
mapping is done correctly in the top-level steps of the divide-
and-conquer stack. A client page typically contains large
chunks of texts that are likely to remain unchanged for
different executions of the server page. This nature of client
pages makes it likely for CSMap to ﬁnd correct pivots in the
early mappings. Incorrect mappings may occur at a later stage
of the execution but produce less impact on the overall result
since remaining texts to be mapped get much smaller.
V. A UTO-LOCATING AND FIX-PROPAGATING TO PHP
This section describes how PhpSync helps in auto-locating
and ﬁx-propagating for the validation errors to PHP code. The
inputs include a given HTML page Cproduced by a PHP
pageS. PhpSync uses Tidy [4], an HTML validator/corrector,
to check Cfor HTML validation errors. If errors are found,
it uses Tidy to produce the corrected version C′ofC.
Auto-Locating. There exist the cases in which Tidy is not
able to provide the ﬁxes [4]; however, it points out the buggy
locations in the HTML page C. In such cases, for each error
location in C, PhpSync uses CSMap to automatically locate
the corresponding literal node(s) in the D-model of Sand then
locate the PHP literal(s) in S. For example, via CSMap, the
<div>opening tag on line 9 of Figure 2 is mapped to the ﬁrst
literal node of the second Concat in Figure 4, therefore, is
correctly traced back to line 9 of Figure 3d.
Fix-Propagating. If Tidy can ﬁx those errors, PhpSync will
propagate those ﬁxes through the mapping between Sand
Cestablished by CSMap. Because Tidy does not provide the
operations of the ﬁxes but produces only the corrected version
C′, we developed CCMap algorithm to map the texts between
CandC′to derive the ﬁxing changes. The output of the
algorithm is all the changes at the character level between C
andC′, which are then used to propagate to the server code.
We design CCMap with three strategies:
1. Token-based processing: CCMap treats the client code C
as a sequence of tokens, instead of syntactic units because C
might not be fully parsable due to its validation errors.
2. Divide-and-conquer: Due to the nature of validation
errors (missing closing tags, missing tag brackets, invalid tags,
etc.), the ﬁxes from Tidy leave the majority of Cun-changed,
i.e.,CandC′share similar texts. CCMap maps the unchanged
portions in CandC′, and uses them as pivots as in CSMap.1function CCMap(C, C’)
2T = Tokenize(C, D) // D is the set of delimiters
3T’ = Tokenize(C’, D) // D= {’<’,’>’,’ ’ , ’\r’ , ’\n’, ’\t’ , ’\f’ , ’ ; ’ , ’=’}
4LCS Exact(T, T’)
5foreach two successive already mapped elements T[l] andT[r]
6 l ’ = T[l ]. map r ’ = T[r ]. map // use mapped elements as pivots
7 LCS Sim(T[l+1..r−1], T’[l’+1..r ’−1], 0.8) // map similar elements
8 for each mapped pair of tokens T[i] and T’[ i ’ ]
9 LCS Exact(T[i], T’[ i ’ ]) // map characters in tokens
10 for each two successive already mapped characters C[l] and C[r]
11 l ’ = C[l ]. map r ’ = C[r ]. map // use mapped characters as pivots
12 LCS Exact(C[l+1..r−1, C’[l’+1..r ’−1]) // map the delimiters only
13function LCS Sim(T, T’, σ)
14 P = array [0.. T.length, 0..T’.length]
15 fori = 1 toT.length
16 forj = 1 toT’.length
17 if (sim(T[i ]. value, T’[ j ]. value) ≥σ)
18 P[i ][ j ]. score = P[i ][ j ]. score + sim(T[i ]. value, T’[ j ]. value);
19 P[i ][ j ]. trace = ‘‘ LU’’
20 else ... // Standard LCS algorithm
Fig. 6. CCMap Algorithm: Deriving Fixes from Tidy
3. Similar-matching: to capture the replacement operations
betweenCandC′, we modify the standard longest common
sub-sequence (LCS) to support the mapping of similar texts.
The pseudo-code of CCMap is in Figure 6. It ﬁrst tokenizes
CandC′into two sequences of tokens TandT′, respectively
(lines 2-3). Then, it uses the standard LCS algorithm LCS Exact
to ﬁnd the pivot tokens (line 4). For each two successive
mapped tokens T[l]andT[r],l < r , and their corresponding
mapped tokens T′[l′]andT′[r′], it uses LCS Sim to ﬁnd
the similar not-yet-mapped tokens in the aligned sequences
T[l+1..r−1]andT′[l′+1..r′−1](lines 5-7). LCS Sim, at lines
13-20, is almost the same as the standard LCS except the way
it compares the elements between two sequences (line 17). In
LCS Sim, two elements can be mapped if their string similarity
exceeds a threshold σ. Function sim(.) measures the similarity
of two strings by the ratio between the length of their LCS and
their average length. For each mapped pair of token T[i]and
T′[i′](both exact and similar ones), CCMap runs LCS Exact
on the two sequences of characters to map the corresponding
characters (lines 8-9). To map all the characters in the code,
it then translates the mapping results of the characters in the
tokens in TandT′to the characters in CandC′. It maps the
previously-removed delimiters in CandC′using LCS Exact
taking already-mapped characters as pivots (lines 10-12).
All mapped characters are considered as unchanged. The
un-mapped ones in CandC′are considered as deleted and
added, respectively. Finally, from those derived changes to C,
PhpSync ﬁnds the corresponding D-model’s literal nodes and
then applies them to the corresponding PHP string literals in
S. For example, PhpSync uses CCMap to detect that </div>is
added by Tidy at line 11 of Figure 2, i.e. is inserted after the
“\n”character between lines 10 and 11. That string is mapped
by CSMap to the literal “\n”at line 12 of Figure 3d. Thus,
PhpSync will make the change at line 12: “$output .= \n</div>”;.
VI. E MPIRICAL EVALUATION
This section presents our empirical evaluation on PhpSync.
Our research questions are 1) how accurately PhpSync mapsTABLE II
SUBJECT SYSTEMS AND D-M ODELS
Subject Systems D-models
Name Files KLOCs ExFiles Nodes Control Time(s)
SchoolMate-1.5.4 63 8 60 5357 885 0.6
TimeClock-1.4 69 23 7 886 101 0.1
WebERP-4.0.2 654 220 16 59338 14841 2.8
UPB-2.2.7 400 105 6 8383 1621 0.7
AddressBook-6.2.12 103 19 10 1789 320 0.3
Manhali-1.3.2 299 52 17 7952 2353 0.6
TABLE III
MAPPING AND FIXING RESULT ON SCHOOLMATE 1.5.4
# Navi Steps Mapping Fix-Propagating
Fragments Characters (×1000 )Err. Tidy PS
All Auto Man Corr. All Corr. Acc.
1 Login 15 12 3 15 7.0 7.0 100% 38 4 4
2 School 42 27 15 42 11.8 11.8 100% 50 19 19
3 Terms 45 31 14 43 12.2 12.1 99% 52 22 22
4 Semesters 51 35 16 49 12.5 12.4 99% 50 20 20
5 Classes 96 64 32 96 12.9 12.9 100% 57 27 27
6 Users 87 58 29 85 13.1 12.9 99% 64 34 34
7 Teachers 56 38 18 56 12.0 12.0 100% 50 20 20
8 Students 105 68 37 105 13.0 13.0 100% 50 20 20
9 Registration 102 69 33 102 12.4 12.4 100% 49 19 19
10 Attendance 73 50 23 72 11.8 11.6 99% 50 20 20
11 Parents 68 44 24 68 12.1 12.1 100% 50 20 20
12 Announce 45 31 14 43 12.3 12.2 99% 50 20 20
13 Terms/Add 19 15 4 19 10.3 10.3 100% 47 18 18
14 Terms/Edit 27 19 8 27 10.0 10.0 100% 47 18 18
15 Sem./Add 30 22 8 30 10.3 10.3 100% 47 18 18
16 Sem./Edit 43 30 13 43 10.4 10.4 100% 47 18 18
17 Classes/Add 47 32 15 47 11.0 11.0 100% 47 18 18
18 Classes/Edit 42 30 12 40 10.9 10.7 98% 47 18 18
19 Classes/Grid 22 17 5 22 9.8 9.8 100% 53 20 20
20 Users/Add 19 15 4 19 10.6 10.6 100% 48 19 19
21 Users/Edit 26 18 8 25 10.6 10.3 98% 48 19 19
1060 725 335 1048 236.9 235.8 99.5% 1041 411 411
HTML code to server code, and 2) how accurately it propa-
gates the ﬁxes from Tidy to server code. All experiments were
carried out on a Windows 7 Home Premium 64-bit computer
with CPU Intel Core i3-370M 2.40 GHz and 6GB RAM.
We collected six PHP systems from sourceforge.net in dif-
ferent sizes and domains (Table II). We read the code to
gain the knowledge and set up those systems on our server
with required databases and sample data. For each system, we
selected multiple server pages for testing and built their D-
models. Column ExFiles shows the average number of executed
server ﬁles for a page. Columns Nodes and Control show the
average number of all nodes and that of control nodes ( Se-
lect/Repeat ) in a D-model. Running time is in column Time.
A. Accuracy of Mapping Client Code and Server Code
To evaluate PhpSync’s accuracy in mapping the texts in
HTML to PHP code, we ﬁrst collected the HTML test pages
from the subject systems by navigating through several HTML
pages within that system on a Web browser. We recorded each
page as an HTML test page by saving its corresponding HTML
code and the navigation steps to get to that page (for later
reproducing the page and checking). For each subject system,
we selected the HTML pages with different presentations to
have the samples of client pages with diverse page structures.TABLE IV
ACCURACY OF MAPPING AND FIX-PROPAGATING ON ALLSUBJECT SYSTEMS
Mapping Fix-Propagating
System Test Fragments Characters (×1000 ) Complexity Err. Tidy PhpSync Miss Acc. Time (s)
Pages All Auto Man Corr. All Corr. Acc. Files Time (s)
SchoolMate-1.5.4 21 1060 725 335 1048 236.9 235.8 99.5% 6 4.4 1041 411 411 0 100.0% <0.2
TimeClock-1.4 14 2511 2103 408 2484 164.1 162.7 99.1% 5 1.2 422 136 136 0 100.0% <0.2
WebERP-4.0.2 10 2736 1910 826 2564 78.5 75.8 96.7% 5 8.0 284 188 176 12 93.6% <1.0
UPB-2.2.7 10 1234 866 368 1191 56.7 53.9 95.0% 4 0.6 129 49 47 2 95.9% <0.2
AddressBook-6.2.12 10 1853 1341 512 1841 78.9 77.5 98.1% 8 0.3 64 51 48 3 94.1% <0.2
Manhali-1.3.2 10 3717 2616 1101 3610 115.1 105.9 92.0% 9 3.8 607 189 164 25 86.8% <0.2
Our evaluation method is to use PhpSync to map every
character in an HTML test page Cto the corresponding
character in a PHP literal or PHP variable, and then to verify
those mappings for all characters by the combination of a
checking tool and human subjects. Remind that given an
HTML test page, PhpSync divides its HTML contents into
several text fragments and maps each fragment into the PHP
literals/variables (Section 4). Because all of those fragments
cover the entire HTML test page, to verify PhpSync’s mapping
for each character, one can check the mapping for each
of those fragments (called test fragments ). The unmapped
fragments are considered to have incorrect mappings.
To reduce the effort of manual veriﬁcation from human sub-
jects, we wrote an evaluation program that checks PhpSync’s
mapping from every test fragment fof the test page to a PHP
literall. Iffis mapped to a PHP variable, we examine the
mapping manually. Otherwise, that program replaces only the
ﬁrst character in the literal lin the PHP code Swith a special
character (SC) that does not appear in the page C. We then
executed the instrumented PHP code S′and followed the same
recorded navigation steps to produce the new HTML page C′.
If inC′, the ﬁrst character position in fis replaced with that
SC and all other positions in C′are un-changed, we consider
it as a correct mapping for that character . Moreover, in such
a case of correct mapping for that character, if fis exactly
identical to l, we consider the mapping ( f→l) correct for
all characters in the fragment f, and consider fas a correctly
mapped fragment . When other positions in C′besidesfhave
been changed, the evaluation tool cannot conclude that the
mapping is incorrect. For instance, there may exist a correct
mapping from some client code to a PHP literal inside a
for/while loop. When the client code C′is produced, the SC
character may appear multiple times in C′due to the execution
of the loop. Thus, in all other cases, we manually veriﬁed the
mapping from ftolby understanding the program semantics.
In Table III, column Mapping shows the result on SchoolMate
v1.5.4. We collected a total of 21 HTML test pages. In column
Fragments , the sub-columns All,Auto,Man, and Corr. respectively
show the number of all test fragments in the test page, the
numbers of auto-evaluated, manually-evaluated, and correctly
mapped fragments. In column Characters , the sub-columns All
and Corr. show the numbers of all characters and correctly
mapped ones in a test page. Acc.shows accuracy , i.e. the ratio
of the number of correctly mapped characters over the total.Column Mapping of Table IV shows the results for all subject
systems. Processing time is in column Time. As seen, PhpSync
achieves very high accuracy (an average of 96.7%) in character
mapping with a small processing time (an average of 3 seconds
for a test page of about 10,000 characters). Column Files shows
us that on average a test page is produced by 6 PHP ﬁles.
Thus, our tool could help reduce developers’ effort in ﬁnding
the PHP locations for a given HTML text.
B. Accuracy of Fix-Propagating to Server Code
We used the same set of HTML test pages in those systems
for an experiment to evaluate PhpSync’s accuracy in ﬁx
propagation. For each test page C, we used Tidy to detect
validation errors. If errors were found and Tidy was able to
ﬁx the page into C∗, PhpSync would be used to derive the
ﬁxing changes between CandC∗and propagate them to ﬁx
the PHP code SintoS∗. Then, we executed the ﬁxed PHP
codeS∗and followed the same recorded navigation steps to
produce the new HTML page C+. Tidy was used to check on
C+for validation errors again. After that, the lists of errors
that Tidy had ﬁxed ( C→C∗) and PhpSync had ﬁxed via
ﬁx-propagation ( C→C+) were automatically compared to
determine how well PhpSync propagated those ﬁxes. Accuracy
is measured as the ratio between the number of correctly
propagated ﬁxes over the total propagated ﬁxes. For the cases
that Tidy uncovered validation errors but could not ﬁx, one
could use CSMap to auto-locate the erroneous PHP code. The
quality of such mapping was evaluated as in Section VI.A.
The columns Fix-Propagating in Tables III and IV display the
ﬁx-propagation results. Columns Err.,Tidy, and PSshow the
number of total HTML validation errors found by Tidy, that of
errors ﬁxed by Tidy, and that of errors ﬁxed by PhpSync via
ﬁx-propagation. As shown, PhpSync achieves high accuracy
(an average of 95%) in ﬁx propagation with small processing
time. Importantly, it did not introduce any new validation error.
Threats to Validity. Our experiments were on only 6 systems
with 74 test pages. The selected systems and test pages might
not be representative. However, the number of test fragments is
very large (13,111), of which 3,550 were manually checked in
15 hours. During that process, human errors could occur. Cur-
rently, PhpSync does not completely handle object-oriented
PHP, thus most of the selected systems do not contain many
classes. Four out of six systems have only reasonable sizes and
do not contain many loops for complex computational logics.VII. R ELATED WORK
Artzi et al. [7] introduced Apollo, a method to ﬁnd bugs
in Web applications by combining concrete and symbolic
execution. It executes a Web application on an initial empty or
randomly-chosen input. Additional inputs are derived by solv-
ing path constraints and conditions extracted from exercised
control ﬂow paths [7]. Failures during such executions are
reported as bugs. In [8], they extended Apollo to also model
interactive user inputs in a Web application. However, it does
not pinpoint the buggy PHP statements that cause such errors.
To support such fault localization, in [9], they combined a
variation of Tarantula [10] with the use of a dynamic output
mapping technique. For each statement, Tarantula associates
it with a suspiciousness rating that indicates the likelihood
for the statement to contribute to a fault. The rating is
computed based on the percentages of passing and failing tests
that execute that statement. However, they reported that in a
Web application, a signiﬁcant number of statements/lines are
executed in both cases, or only in failing executions. Thus, they
combined Tarantula with a dynamic output mapping technique,
which instruments a shadow interpreter to create a mapping
between the lines in PHP and HTML code by recording the
line number of the originating PHP statement whenever output
is written out using the echo and print statements [9].
In comparison, while their output mapping technique is
based on dynamic analysis with run-time instrumentation into
an interpreter, PhpSync relies on symbolic execution. Their
technique is lightweight, however, PhpSync is better suited
for this auto-locating and ﬁx-propagating problem. First, for
an erroneous HTML line detected by an HTML validator,
their tool will map it to the PHP statement responsible for
printing it out. However, that PHP print/echo statement might
not always be the line that needs to be ﬁxed because the
erroneous content of the HTML line might be composed
and manipulated in string variables in previous statement(s)
(see the motivating example in Section II.B.4). Second, in
practice, validation errors could be found in a client page
via Tidy and reported without corresponding input and action
steps to produce that page. Thus, their dynamic mapping
technique cannot be applied. In this case, a ﬁxer can still
use PhpSync to ﬁx the errors. Finally, for ﬁx-propagation,
PhpSync performs mapping at the character level, while for
the debugging purpose, their tool maps at the line level.
Tidy [4], an HTML validator/corrector, works mostly on
static HTML pages. For PHP code, it ﬁlters all the code
within a ’<?php’ and the corresponding ’?>’and considers the
remaining as HTML code. That scheme does not work well
because HTML code is embedded within multiple scattered
PHP literals and variables (see Section II). Similar to Tidy,
other validating tools [11], [12], [2] are limited to support
validating or correcting only client pages in XML/HTML/CSS.
Minamide’s string analyzer [5] takes a PHP program and
a regular expression describing all of its possible inputs,
and then statically approximates and validates the output
via a context-free grammar. In comparison, his goal is tovalidate approximated HTML outputs from a PHP program
without ﬁxing support . Moreover, PhpSync performs symbolic
execution requiring an input speciﬁcation as in Minamide’s.
Using a string analyzer, Wang et al. [13] compute the ap-
proximated output of a PHP program and identify the constant
strings visible from the browser for translation purpose.
Several string-taint analysis techniques were built for soft-
ware security problems [14], [15], [16]. Gould et al. [17] use
string analysis to guarantee well-typed SQL queries generated
by a Java program. The type system in [18] is based on regular
expressions with string concatenation and pattern matching. A
CFG-based type system for string analysis is presented in [19].
PhpSync complements to PHP debuggers [20], however it does
not need the inputs of PHP programs with symbolic execution.
VIII. C ONCLUSIONS
We propose PhpSync, an auto-locating and ﬁx-propagating
tool for validation errors. Given an HTML page produced by
PHP code, PhpSync uses Tidy to ﬁnd its validation errors, and
propagates Tidy’s ﬁxes to PHP code. Our core solutions in-
clude a symbolic execution algorithm on PHP code to produce
an D-model, which approximates all possible client pages, and
the client-server mapping and ﬁx-propagating algorithms. Our
evaluation shows that it achieves high accuracy in both tasks.
ACKNOWLEDGMENTS
This project is funded in part by NSF CCF-1018600 grant.
The ﬁrst author was funded in part by a fellowship from
Vietnamese Education Foundation (VEF).
REFERENCES
[1] “World Wide Web Consortium,” http://www.w3.org/, W3C.
[2] “W3C Markup Validation Service,” http://validator.w3.org/, W3C.
[3] “Why Validate,” http://validator.w3.org/docs/why.html, W3C.
[4] “HTML Tidy Project,” http://tidy.sourceforge.net/, Source Forge.
[5] Y . Minamide, “Static approximation of dynamically generated Web
pages”. WWW’05: Int. Conference on World Wide Web . ACM, 2005.
[6] A. Aho, J. D. Ullman, and M. S. Lam, Compilers: Principles, Tech-
niques, and Tools . Pearson Education Inc., 2006.
[7] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and M. Ernst.
Finding bugs in dynamic Web applications. In ISSTA, pp 261-272, 2008.
[8] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, and M. Ernst.
“Finding bugs in Web applications using dynamic test generation and
explicit-state model checking”. IEEE TSE, 36(4): 474-494. July, 2010.
[9] S. Artzi, J. Dolby, F. Tip, and M. Pistoia. “Practical fault localization
for dynamic Web applications”. In ICSE’10, pp. 265-274. ACM, 2010.
[10] J. Jones and M. Harrold. “Empirical evaluation of the Tarantula auto-
matic fault-localization technique”. In ASE’05, pp 273-282. ACM, 2005.
[11] “WDG HTML Validator,” http://htmlhelp.com/tools/validator/, WDG.
[12] “CSE HTML Validator,” http://www.htmlvalidator.com/.
[13] X. Wang, L. Zhang, T. Xie, H. Mei, J. Sun, “Locating need-to-translate
constant strings in Web applications”. FSE’10 , pp. 87–96. ACM, 2010.
[14] G. Wassermann and Z. Su, “Static detection of cross-site scripting
vulnerabilities”. In ICSE’08 , pp. 171–180. ACM Press, 2008.
[15] Y . Xie and A. Aiken, “Static detection of security vulnerabilities in
scripting languages”. In USENIX Security Symposium - Volume 15 , 2006.
[16] A. Kieyzun, P. J. Guo, K. Jayaraman, M. D. Ernst, “Automatic creation
of SQL injection and cross-site scripting attacks”. ICSE’09 , IEEE CS.
[17] C. Gould, Z. Su, and P. Devanbu, “Static checking of dynamically
generated queries in database applications”. ICSE’04 , IEEE CS, 2004.
[18] N. Tabuchi, E. Sumii, A. Yonezawa, “Regular expression types for
strings in a text processing language”. In Types in Programming , 2002.
[19] P. Thiemann, “Grammar-based analysis of string expressions”. In ACM
workshop on Types in languages design and implementation ACM, 2005.
[20] “DBG PHP Debugger,” http://www.php-debugger.com/dbg/.