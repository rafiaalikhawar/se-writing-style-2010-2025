PiE: Programming in Eliza
Xiao Liu
College of Information Sciences and Technology
The Pennsylvania State University
xvl5190@ist.psu.eduDinghao Wu
College of Information Sciences and Technology
The Pennsylvania State University
dwu@ist.psu.edu
ABSTRACT
Eliza, a primitive example of natural language processing, adopts
a rule-based method to conduct simple conversations with people.
In this paper, we extend Eliza for a novel application. We pro-
pose a system to assist with program synthesis called Programming
in Eliza (PiE). According to a set of rules, PiE can automatically
synthesize programs from natural language conversations between
Eliza and users. PiE is useful for programming in domain-speciÔ¨Åc
languages. We have implemented PiE to synthesize programs in the
LOGO programming language, and our experimental results show
that, on average, the success ratio is 88.4% for synthesizing LOGO
programs from simple conversations with Eliza. PiE also enables
end-users with no experience to program in LOGO with a smoother
learning curve.
Categories and Subject Descriptors
I.2.2 [Automatic Programming]: [Program synthesis]; I.2.7 [Natural
Language Processing]: [Language generation]; H.5.2 [User In-
terfaces]: [Natural language]
General Terms
Design, Languages
Keywords
Eliza, LOGO, program synthesis, natural language, rule-based
1. INTRODUCTION
Eliza is an early example of natural language processing that
serves as a psychotherapist to interact with patients [22]. Based on
a rule-based method, Eliza makes simple conversations with people
in natural language. Flexibly, people try to communicate with Eliza
in sentences with few constraints and Eliza responds according to
a set of rules based on keywords. With such a system of ‚Äúintel-
ligence‚Äù, we make an extension for a new application called Pro-
gramming in Eliza (PiE), with the assistance of which, programs in
target programming languages will be synthesized from the natural
language commands provided by users. PiE demonstrates a new
way for program synthesis.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15‚Äì19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642967.Program Synthesis is a concept that comes from the earlier au-
tomatic programming, the fundamental of which relies on the me-
chanical theorem-proving techniques [21]. However, the problem
of automatic programming is much broader than expected since
the proof of theorems involving existential quantiÔ¨Åers scarcely suc-
ceeds. In this case, some constraints have been appended to the
automatic programming, which is gradually considered as program
synthesis [15]. Program synthesis is more likely a concept that de-
Ô¨Ånes the automation of programs in some speciÔ¨Åc domains, such as
robotics [11, 14], and spreadsheet programming [7].
Because of the versatility and applicability, natural language pro-
gramming has been widely discussed as an easy way for novices to
learn how to program [1, 5, 3]. However, the realization of natural
language programming is based on ‚ÄúAI Complete‚Äù which means
that the machine is required to understand every natural language
description. DeÔ¨Ånitely, this goal has not been achieved yet but it is
feasible for machine to partially understand people [13], especially
in a typically area. Thus, in a speciÔ¨Åc domain, programming in
natural language is viable.
Additionally, smart devices perform better with natural language
as the input. V oice input has indeed advanced gradually in recent
years. However, the accuracy of recognition for programming lan-
guages is still low [2]. For example, ‚Äúfor int i equals zero i less
than ten i plus plus‚Äù which should be translated into ‚Äúfor (int i= 0;
i <10;i+ +)‚Äù is usually recognized as ‚Äú4 int eye equals 0 aye
less then ten i plus plus‚Äù. In this case, when we target at coding
with smart devices, the accuracy of voice recognition of program-
ming language cannot meet the bottom line. But things may change
when you say ‚ÄúLet‚Äôs start a loop with integer i from 0 to 9, add 1
in each turn‚Äù. The recognition accuracy can be much higher. Thus,
the demand for programming in natural language arises again.
Aiming at lowering the entrance bar for novice programmers or
children who cannot program, we propose a domain-speciÔ¨Åc pro-
gram synthesis system called Programming in Eliza (PiE). PiE in-
teractively takes natural language conversations from users, and
synthesizes programs in the LOGO programming language to draw
graphs. Figure 1 illustrates the working Ô¨Çow of the PiE system.
The system consists of three parts: Eliza, PiE script and LOGO.
The core lies in the PiE script which can be seen as a connector be-
tween the other two. This script processes the natural language de-
scriptions from users and synthesizes programs in the LOGO pro-
gramming language which will be executed by the LOGO module.
Meanwhile, it provides a feedback in natural language to users via
the Eliza module. With the proposed system, we make the follow-
ing contributions:
We propose a novel way for domain-speciÔ¨Åc program syn-
thesis based on Eliza and recall the importance of natural
language programming with gradually mature techniques in
NLP and easy access to programming devices for end-users.
We have realized program synthesis in the LOGO program-
ming language from English conversations between users and
computers. Programs can be synthesized with few constraints
on the input natural language commands.
695
Figure 1: The PiE system architecture
We have achieved a preliminary step in natural language pro-
gramming for education use. Program logic can be learned
by end-users with no experience during the interaction with
the PiE system regardless of using complicated programming
languages like C++ or Java.
The rest of this paper is structured as follows. We Ô¨Årst summa-
rize the background of the PiE system: Eliza and LOGO. Then we
demonstrate an example to illustrate a complete working Ô¨Çow of
the PiE system. Next we introduce the PiE script used in this spe-
ciÔ¨Åc domain that we design, and elaborate the key techniques for
program synthesis in our system. To evaluate the system, we use
Learning EfÔ¨Åciency and Success Ratio. Related work and conclu-
sion are presented in the last two sections.
2. BACKGROUND
In this section, we introduce the background on Eliza and the
LOGO programming language.
2.1 Eliza and Rule-base method
Eliza, a primitive prototype of natural language processing, plays
the role of a psychotherapist to communicate with patients [22].
The input sentences are processed with a pre-deÔ¨Åned script, where
there are two basic types of rules: the decomposition rules and re-
assemble rules. Decomposition rules are made up of different com-
binations of keywords, and for each decomposition rule there are a
couple of reassemble rules corresponding to it. When a sentence
is typed in, it will be decomposed into pieces according to the de-
composition rules and then based on one of the reassemble rules, a
response in natural language will be generated automatically. Fol-
lowing is an example of how Eliza works:
Input It seems that you hate me.
Decomposition Rule (Any Words) (you) (Any Words) (me).
Decomposition (1)It seems that (2)you (3)hate (4)me.
Reassemble Rule (What makes you think I) (3) (you).
Output What makes you think I hate you?
Although Eliza belongs to the Ô¨Årst-generation NLP techniques
using a rule-based method to understand users, it works quite well
in speciÔ¨Åc domains. In this paper, we extend Eliza for a novel ap-
plication: program synthesis in the LOGO programming language.
2.2 LOGO
LOGO is a graphic-oriented education programming language [6].
The well-known application of LOGO is the Turtle Graphics [16],
in which there is a turtle on the screen and commands from users
will move the turtle in various ways and the trace left will be a
special designed graph. For example, if a child wants the turtle to
move forward 10 steps, she may use the command FORWARD 10.
Table 1 shows the program with four lines of commands that can
draw a square with the Turtle.
In this paper, we aim at building a system to automatically gener-
ate programs in the LOGO programming language. To demonstrate
the idea, we have implemented a prototype called PiE (Program-
ming in Eliza) with Python Turtle to synthesize LOGO programs
from natural language conversations in Eliza.English LOGO Commands
Draw with a Black Pen COLOR BLACK
DO this 4 Times: REPEAT 4 [
Move Forward 10 Paces, Drawing FORWARD 10
Turn Right 90 Degrees RIGHT 90 ]
Table 1: Web Turtle tutorial example: draw a square
3. EXAMPLE
In this section, we motivate our system with the same example
from a web turtle tutorial [10] as described in Table 1. The objec-
tive is to generate LOGO programs when the input are sentences in
natural language with few constraints.
As described in Table 1, the user would like to draw a square in
black with the turtle, but it is her Ô¨Årst time to program with LOGO.
However, she knows that if she wants to draw a square in black, she
needs to pick up a black pen to draw four straight lines and make a
90 degree turn after each line. Thus, if she is allowed to manipulate
the turtle in a natural language, one possible description is:
1.Draw with a Black Pen
2.Do this 4 times:
>>1.Move Forward 10 Paces, Drawing
>>2.Turn Right 90 Degrees
Every time a command in natural language is received by PiE,
it will be decomposed word by word into text chunks, denoted
w1;w2;:::;w n[Step 1]. In the next step [Step 2], the lexical anal-
ysis will be conducted with the assistance of the PiE script. Each
of these text chunks will be tagged with a pre-deÔ¨Åned Token in the
PiE script, for example, the Predicate Token or the Number Token,
by adopting regular expression matching. Then, the analyzed sen-
tence will be easily parsed into a structure. For instance, if all the
descriptive sentences in the example are analyzed, the structure of
each sentence will be like this:
Draw with a Black Pen
(PredicateTok)+(RedundantTok)+(NumberTok)
Do this 4 times:
(PredicateTok)+(RedundantTok)+(NumberTok)+(KeywordTok)
Move Forward 10 Paces, Drawing
(RedundantTok)+(PredicateTok)+(NumberTok)+(RedundantTok)
Turn Right 90 Degrees
(PredicateTok)+(KeywordTok)+(NumberTok)+(RedundantTok)
In the following step [Step 3], the LOGO program will be syn-
thesized based on the structure. It is a many to one mapping from
the natural language structures to a particular predicate in LOGO.
For each Predicate Token, which can be treated as the key function
words, we can select the class of mapping rules. Mapping rules in
one class contain the same predicate.
However, there are more than one LOGO command for each
predicate. To synthesize the correct LOGO command for the in-
put natural language instruction, the structure of the sentence then
plays a part. The last step [Step 4] for the LOGO program synthesis
is the substitution of parameters in the incomplete programs from
[Step 3]. In this step, incomplete programs will be parsed by rule
sequence, and meanwhile, the parameters in these commands will
be substitute with the tokens from the input sentences.
4. PIE SCRIPT
We have designed the PiE Script from an extensive study of the
descriptions in natural language for each command in the Web Tur-
tle from various online LOGO language tutorials. Note a script is a
set of decomposition and reassemble rules deÔ¨Åned in Eliza.
4.1 PiE-LOGO
PiE-LOGO is a domain-speciÔ¨Åc language that can be ported to
other platforms via syntax-directed translation. PiE-LOGO main-
tains the context-free feature of the LOGO programming language.
The syntax of PiE-LOGO is shown in Figure 2. In PiE-LOGO, we
useSto denote a complete statement which consists of two parts:
Predicateand Parameter I. The Parameter can be numbers, di-
rectors or color names extracted from the natural language. It can
be ‚ÄúOmit" when users forget to include some parameters in their
descriptions. Such as ‚ÄúDraw a line" with no mention of the length
696StatementS ::= (jT)(IjT)
ParameterI ::= numberjdirectionjcolor
|
Omission 
 ::= numberjdirectionjcolor
Predicate ::= Predicate (a 1,a2,...,an)
RepeatR ::=S
j foreachx2a,
doS1;S2;...;Sn; od
TransformT ::=t1;t2; ...;tn
t ::= transform(a)jtransform(I )
Argumenta ::= input(a 1,a2,...,an)
Figure 2: The syntax of PiE-LOGO
or ‚ÄúMake a right turn" without a concrete degree. The Transformer
T, a part of the Eliza mechanism, transforms predicates or param-
eters with the same meaning into a regular expression. The Repeat
Rdenotes loops in PiE-LOGO and adenotes input arguments.
The following examples describe the natural language commands
and their corresponding synthesized scripts, according to which we
can achieve a better understanding of the PiE script that we deÔ¨Åned.
4.1.1 Statement
[Color of the Pen]
>Use a blue pen!
S:= pencolor blue
transform(blue ) := [0,0,255]
4.1.2 Function
[DeÔ¨Åne Functions]
>Go forward 200 steps, turtle!
>Then turn left.
>Let STEP1 include the last two commands!
S1:= forward number
number := 200
S2:= turn direction
direction := left
STEP := last[number ]
number := 2
last[2]:= foreach ninnumber ,STEP =STEP1 +last[n]
4.1.3 Repeat
[Start Loops]
>repeat STEP1 four times
S:= foreach ninnumber , doSTEP1
number := 4
4.2 Key Components
Normally, in each statement, there are three key components:
Predicate, Parameter, and Transform.
Predicate: The predicate is one of the most important compo-
nents in the script and it represents the predicates in the LOGO
programming language. These predicates correspond with verbs
in natural language commands, for instance,‚ÄúMove ahead‚Äù will be
translated to ‚ÄúFORWARD‚Äù; ‚ÄúLet the color of the pen be‚Äù will be
translated to ‚ÄúPENCOLOR‚Äù. These predicates in the PiE script are
later mapped into the operators in the target languages using pre-
deÔ¨Åned rules.
Parameter: The parameter represents the object of the related
predicate or the status of the object. For example, ‚Äú100‚Äù in ‚ÄúFOR-
WARD 100‚Äù; or ‚Äúblue‚Äù in ‚ÄúPENCOLOR blue‚Äù. Parameters are
identiÔ¨Åed using regular expression matching.
Transform: This component comes from the Eliza mechanism
as it categorizes predicates or parameters with the same meaning
into a dedicated one. For example, ‚ÄúMove ahead‚Äù ‚ÄúGo forward‚Äù
‚ÄúMove on‚Äù will all be translated to ‚ÄúFORWARD‚Äù. This component
plays an important role in the semantic analysis of natural language
commands.
5. SYNTHESIS TECHNIQUES
Our goal is to map commands in natural language into PiE-
LOGO, which means (1) after the decomposition of each sentenceToken Regular Expression
Number Token (\d)*
Color Token ((\d)* \s){3}
Direction Token (leftjright)
Predicate Token (forwardjbackwardjrepeatj...)
Table 2: Regular expression matching
Move forward 100 steps!
Please go forward 100 steps!
Can you go straight on for 100 steps!
Move ahead 100 steps little turtle!
Turtle, go ahead for 100 steps!
Move forth 100 steps!
Let‚Äôs go forth 100 steps!
Move to the front 100 steps!
Go up for 100 steps!
Table 3: Natural command mapped to predicate ‚ÄúForward‚Äù
in natural language, every chunk can be mapped into a token in our
script; (2) when we parse the sequence of tokens, which is the re-
sult from the syntax analysis, PiE script is capable of handling all
the possible syntax structures. Both tasks are quite complicated to
be tackled. This section elaborates on the techniques adopted in the
PiE system and the design of the PiE script.
5.1 Regular Expression Matching
To perform lexical analysis, we adopt Regular Expression Match-
ing. Taking advantage of regular expressions, we are able to extract
tokens like Predicate Token orParameter Token in each command
in English. A set of regular expressions are designed manually to
match all the structures consist of tokens. In Eliza, the system rec-
ognize a sentence by using keywords, but our system adopts reg-
ular expressions. The regular expression matching in PiE assists
the system to analyze the syntax of the natural language and then
each chunk of the natural commands is mapped into a token in the
PiE-LOGO. To some extent, keywords matching can be seen as a
special regular expression matching; however, Eliza does not parse
the input natural sentences into structures. Another advantage of
regular expression matching in PiE is that, without a strictly de-
signed ranking of the rules, the matching process can be completed
in linear time with respect to the size of the input sentence. Some
examples of regular expressions and their corresponding tokens are
shown in Table 2.
5.2 Mapping Rules
We have designed a set of rules to map natural language com-
mands into PiE-LOGO. As we described in the example, programs
in PiE-LOGO can be synthesized based on the parsed structure.
We generate a group of natural language commands by ourselves
for each predicate. Table 3 shows some speciÔ¨Åc examples of the
natural commands that can be mapped into the ‚ÄúFORWARD‚Äù func-
tion class. As far as the contents in this table are considered, it in-
dicates that there are many expressions in natural language which
have the same semantic meaning because of synonyms. Different
verbs in natural language are used in these sentences but the struc-
tures are similar. Under this circumstance, we adopt transform T
which is borrowed from the Eliza system to categorize predicates
or parameters with the same meaning into a dedicated one. Take
the ‚ÄúFORWARD‚Äù class as an example, Move forward, Go forward,
Move ahead, Go ahead, Go forth, Move to the front, and Go up
are of the same semantic meanings. Thus, they can be categorized
into the same ‚ÄúFORWARD‚Äù class and they can be replaced by the
predicate‚Äúforward‚Äù.
Based on the 1987 Penguin edition of Rogers Thesaurus of En-
glish Words and Phrases [17], we maintain a dictionary of words
that can be transformed to tackle the challenge from synonyms.
The design enables PiE to process Ô¨Çexible natural language syntax.
5.2.1 Rule Ranking
Since the number of the rules for the mapping function is large, it
is desirable to apply some ranking in the rule sequence to improve
697(n:) forward a line of (nd) (n:) in length
(n:) forward a line of (nd) (n:) long
(n:) (nd) (n:) forward(n:)
(n:)forward(n:) (nd) (n:)
(n:) (nd) forward(n:)
(n:) (nd) (n:) forward
(n:)forward (n:) (nd)
(n:)forward (nd) (n:)
Table 4: Mapping rules to the ‚ÄúFORWARD‚Äù class
the effectiveness of the PiE system. We rank the rules in two steps:
(1) by Predicate Order; (2) by Complex Order.
Predicate Order: Rules with the same predicate will be cat-
egorized into a class and then, we sort the classes according to
the frequency of the predicate occurrence. We collected 484 real
LOGO commands from 20 different LOGO programs among the
most popular ones from Web-Turtle and count the frequencies of
each predicate. For example, by frequency order, ‚Äúforward‚Äù stays
ahead of ‚Äúpencolor‚Äù, and thus, the rule ‚ÄúMove forward (nd)* (n:)*‚Äù
stays before the rule ‚Äú(n:)* color of the pen (n:)*(n:)*‚Äù.
Complexity Order: Rules in the same class are sorted by the
complexity order. The rule with more tokens or Redundant To-
kens are of more Complexity. For example, for the ‚ÄúFORWARD‚Äù
class, ‚ÄúMove forward (nd)* (n:)*‚Äù stays before ‚Äú((n:)* forward
(nd)* (n:)*)‚Äù. This ranking algorithm not only helps shorten the
time, but also improves the accuracy of mapping.
5.2.2 Rule Prune
At the very beginning, we used the descriptions of online LOGO
tutorials as the data set, together with our own experience, accord-
ing to which we designed the Ô¨Årst set of rules. However, there
are many redundant rules in this set. For example, ‚ÄúMove forward
(nd)* (n:)*‚Äù and ‚ÄúGo forward (nd)* (n:)*‚Äù are two rules at the very
beginning. After the Rule Prune, these two can be merged into one:
‚Äú(n:)* forward (nd)* (n: )*‚Äù.
To prune the rules, we Ô¨Årstly sort the rules in a predicate class
byComplexity. Here, the rules with more Tokens or Redundant
Tokens are of more complexity. In this case, the ‚ÄúFORWARD‚Äù
class is arranged as shown in Table 4.
Then, we test if there exists any rule of less complexity that can
replace the one of more complexity. For example: any sentence
that can be matched with the rule ‚Äú(n:) forward a line of (nd)
(n:) in length‚Äù and ‚Äú(n:) forward a line of (nd) (n: ) long‚Äù can
also be matched with ‚Äú(n:)forward(n:) (nd) (n:)‚Äù. Since this
meets the prune requirement, the former two can be pruned.
5.3 Rule Adaptation
There are in total 87 rules in the original library which are self-
generated. However, to handle all the possible descriptions to ma-
nipulate the turtle, the library should be made adaptable. We real-
ize this function by making the Transform Table adjustable. The
system will collect the natural language descriptions that cannot
be matched up with any rule. Based on these left-behind descrip-
tions, new words will be appended to the Transform Table which
possess equal meaning as the words in the original table. Thus,
we can make new rules as an extension to improve the success ra-
tio. Meanwhile, in addition to maintaining the rule library, users
can add words in any predicate class via communicating with PiE‚Äôs
function deÔ¨Ånition. Thus, the rules in PiE are extensible.
In the future, with the increasing number of people that play with
PiE, we would like to use crowd sourcing to improve the rule set.
Whenever the system cannot understand the user, it will ask the
user to say in another way. Typically, the user would change some
words but not the whole sentence structure. Under this premise, we
may Ô¨Ånd out the transformable tokens in our rules and adaptively
complete the library using this crowd sourcing method. However,
there is still a chance when the sentence structure is changed. To
solve these problems, PiE will pop up with several words belong to
different predicate classes. The user will be asked whether or not
adding a new word to one of these classes.
Figure 3: Output graph of demo
5.4 Dialog Interaction
To make the interface more interesting, we also present a rule-
based natural language response as the feedback to each input sen-
tence. For each synthesized PiE-LOGO command, there is one and
only natural language feedback corresponding to it. This feedback
serves as the conÔ¨Årmation of program synthesized as well as the
reminder of the mistakes, if any. In some cases, when PiE fails
to respond to the user‚Äôs command, the interaction system will re-
quest an alternative description.The interaction between users and
PiE system makes this interface more user‚Äìfriendly.
6. EV ALUATION
In this section, we Ô¨Årst provide an demonstration to show the pro-
cess and result when playing with PiE. We then present evaluation
in terms of (1) Learning EfÔ¨Åciency for non-programmers, novices
and experienced users in learning to program with PiE-LOGO and
(2)Success Ratio for synthesized programs. We have implemented
our system using the Python Turtle, which is a standard library
embedded in Python 2.7. Each command in PiE-LOGO is imple-
mented in Python to move the turtle.
6.1 Demonstration
We choose a popular example: the Koch Curve among many
latest drawings from users who draw with Turtle on the website,
papertlogo in your browser (http://logo.twentygototen.org/). The
input natural language is not case-sensitive and by using regular ex-
pression matching, the system can tolerate some spelling mistakes
as well. This demonstration is designed to show how complex tasks
that PiE can handle. The program goes a little bit further than a be-
ginner can understand, but with a designed algorithm in hand, she
could make simple conversations with PiE and draw a Koch Curve
without much difÔ¨Åculty.
The interaction between the user and the PiE system is shown
in Figure 4 and the output graph is Figure 3. This demonstration
shows a normal pattern of using recursion in drawing. Consider
the education use of the PiE system, when using this system to
learn how to program, the non-experienced learners, especially for
children, may experience a better interaction than coding directly
on their own. The users enjoy the Ô¨Çexibility of natural languages
without being required to memorize the strict and rigid syntax of
programming languages.
6.2 Learning EfÔ¨Åciency
Back to the original intention of the PiE system: in addition to
the purpose to simplify the process of learning to code, we are aim-
ing at describing a novel way for program synthesis. Nevertheless,
there is no benchmark for evaluation of the easiness to master a
programming language. We develop a notion called Learning Ef-
Ô¨Åciency for learning how to program. Here, we deÔ¨Åne Learning
EfÔ¨Åciency as, the extent to which time is well used for the intended
programming task using a new programming language. We pro-
vide users equal time to learn both the LOGO programming lan-
guage and PiE-LOGO and test the time they spent on a certain task.
The less time they spent on programming, the higher Learning Ef-
Ô¨Åciency of a speciÔ¨Åc language.
Six volunteers participated in our experiment. Among them, two
are non-programmers (graduate students who have learned logic
in the previous math studies), two are novices (Ô¨Årst-year learners
of the Java programming language) and the remaining two are ex-
perienced programmers (with four and Ô¨Åve years of programming
698User Descriptions PiE Responses LOGO Program
[PiE Start] Thanks for trying PiE. How can I help you?
>Let‚Äôs Ô¨Årst draw a line Okay, what is the length of that line?
>Oh, I mean, to deÔ¨Åne a function called line I see, what are the arguments of the function Line?
>They are count and n Okay, I have designed a function called Line with input arguments
called count and n. Then?toline :count :n
>let the turtle move ahead n steps when the count
equals to oneOkay, if the Count is 1, turtle will forward N steps ifelse :count = 1 [fd :n]
>In other cases, do the following things: I see. do what else?
>let count decrease by one Okay, Count equals to Count -1 make "count :count - 1
>repeat the line function with new count I see. Function Line is called with the new argument count line:count :n
>turn left 60 degrees Okay, the turtle turns 60 degrees to the left lt60
>repeat the function line Okay, Function Line is called line:count :n
>turn right 120 degree and repeat function line I see, the turtle turns 120 degrees to the right. Function Line is called. rt120line:count :n
>Again turn but left 60 degrees and repeat the
function lineOkay, the turtle turns 60 degrees to the left. Function Line is called lt60line:count :n
>That is all for the function I see, Function Line is end. end
>Start another function called Koch I see, what are the arguments of the function Koch?
>still count and n Okay, I have designed a function called Koch with input arguments
called count and n. Then?tokoch :count :n
>Ô¨Årst turn right 30 degrees and execute the func-
tion lineI see. The turtle turns 30 degrees to the right. Function Line is called. rt30line:count :n
>turn right 120 degrees and execute the function
lineI see. The turtle turns 120 degrees to the right. Function Line is
called.rt120line:count :n
>repeat the last command I see. The turtle turns 120 degrees to the right. Function Line is
called.rt30line:count :n
>Let‚Äôs call it Koch I see, Function Koch is end. end
>Clear everything Okay, the canvas is clean. clear
>let the turtle start from point (45,370) I see, turtle is moved to point (45,370). setxy 45 370
>Begin the function Koch Okay, but what are the arguments?
>count is 5 and n is 5 Okay, function Koch is called with the argument Count=5 and n=5. koch 5 5
>Quit Okay, Done! Done
Figure 4: Interaction with PiE for Demo
experiences, respectively). All of them are not involved in the sys-
tem design and they have not learned the LOGO programming lan-
guage before. Before the experiment, we start with six examples
as the tutorial, which include simply drawing an ‚ÄúL-shape", deÔ¨Ån-
ing a function, and drawing repeated patterns. It takes Ô¨Åve minutes
on average for them to go through the tutorial. Then, equal time
is provided to go through the tutorial of the LOGO programming
language provided by the online tutorial as introduced in ¬ß3.
After reviewing both the tutorials of our PiE system and the
LOGO programming language, the six participants are asked to
draw a target shape as shown in Figure 5. They need to draw a
base unit recursively and the base unit is a diamond as shown in
Figure 6. The edge length of the diamond is 100 steps and the two
different angles are of 60 and 120 degrees, respectively. The angle
between the two dash lines is 10 degrees.
Given these indications on how to draw a graph in Figure 4, the
testers are asked to use both PiE-LOGO and LOGO to complete the
task. Testers are separated into two groups, one does PiE-LOGO
Ô¨Årst and the other does LOGO Ô¨Årst. The average time consumed
is shown in Table 5. PiE saves 43:8%, 21:8% and22:4%of time,
respectively, for non-programmers, novices and experienced pro-
grammers to draw the same graph. The preliminary results indicate
that PiE creates a platform for them to program in a new language
with a smoother learning curve. In addition, we may Ô¨Ånd that, PiE
saves the most time for the non-programmers, in which case, we
could say that PiE performs well as an introduction tutorial for
those who want to learn basic programming skills.
Another interesting fact in the experiment is that, every experi-
enced programmer checked the tutorial of the original LOGO dur-
ing the programming task but that does not happen when using PiE.
As a result, PiE relieves the burden of memorizing strict syntax and
checking language references and tutorials to some extent.
6.3 Success Ratio
We further evaluate the PiE system in terms of Success Ratio
for the synthesized program. Success Ratio is deÔ¨Åned as the ratio
of the descriptions that successfully accepted by our system and
the corresponding LOGO commands are correctly generated. We
collected 877 descriptions when the six participants use our system
to go through the example-oriented tasks and the test as presented
Figure 5: Learning efÔ¨Åciency test
 Figure 6: Base unit
Experienced Novices Non-programmer
Original LOGO 67s 69s 130s
PiE 52s 54s 73s
Time Saving 22.39% 21.74% 43.85%
Table 5: Time used in the Programming with LOGO and PiE
in ¬ß6.2, and to just play with the turtle. The collection includes
19 types of commands as shown in Table 6 and we set these 19
types as the benchmark. We ask the users to describe these types
of commands in their own way and collect another 1,000 pieces
of descriptions. Thus in total, we have 1,877 natural command
descriptions, about 100 for each type.
In total, we have constructed 96 rules in the PiE script, including
87 from the original library and 9 adapted, to understand the natu-
ral language descriptions. Typically, we make rules for the system
without ranking. To test the effectiveness of the ranking algorithm
described in ¬ß5.2.1, we Ô¨Årst test our system with unranked rules to
get the Success Ratio. Then, after applying our ranking algorithm
with the rules, we test the system again to get another set of Success
Ratio and compare with the previous unranked results.
In Figure 7, we show the Success Ratio in two cases when the
rules are ranked or not, to synthesize the benchmark commands
from the natural expressions. From the Ô¨Ågure we can see that with
ranked rules, higher Success Ratios are achieved. Our system per-
forms well as it achieves average success ratio of 88.4% in most of
the commands that supported by the LOGO language. PiE works
in most cases but there are still some exceptions. For example,
descriptions which are too oral, such as ‚Äúhow about 40 steps" or
‚Äúmove! turtle!", cannot be understood by our system. The former
requires a context which we will address in the future; the latter is
a partial command which needs a length parameter. It is our goal
to improve further in the future.
699Benchmarks Natural Descriptions
1 Clear the screen
2 The turtle move forward a few steps and a line is drawn
3 The turtle move backward a few steps and a line is drawn
4 The turtle rotate a degree clockwise
5 The turtle rotate a degree anti-clockwise
6 The turtle move directly to a pointed place
7 The turtle‚Äôs color is changed and the line is in the decided color
8 Put up the turtle and no trace will be left when move the turtle
9 Put the turtle back to the paper
10 Undo several previous commands
11 Change the width of the pen to a decided value
12 Let the turtle face a decided direction
13 DeÔ¨Åne a function with a name that includes several commands
14 Repeat several previous commands or a function
15 Draw a circle with a certain radius
16 Draw a triangle with certain lengths of the edges
17 Draw a square with certain lengths of the edges
18 Draw a diamond with a certain length of the edge
19 Quit the system
Table 6: Benchmarks for synthesis
Figure 7: Success ratios for synthesis
7. RELATED WORK
7.1 Rule-based ArtiÔ¨Åcial Intelligence
Rule-based systems are alternative to statistic-based ones, to store
and manipulate knowledge. The rules are usually based on the lin-
guistic theories. Rule-based method is more efÔ¨Åcient in speciÔ¨Åc
domains since it does not require many computational resources;
and error analysis is easier to perform.
Many researchers utilized the rule-based methods for their study
into the natural language. Bill [4] adopts the rules for automatically
tag speeches and it works as well as the stochastic tagger as proved
by the author. Vlas [20] develops a rule-based natural language
technique for classiÔ¨Åcation of open-source software according to
the informal documents. Le [12] is a case that programs can be syn-
thesized for the windows phone commands using the rule-based re-
lation detection algorithm to map the natural language descriptions
to the relationship between incidents. Compared with statistical-
based methods, the data ‚Äútraining" in the rule-based methods are
often more efÔ¨Åcient. In this paper, the rule-based method as Eliza
does to synthesize programs performs quite well in the speciÔ¨Åc do-
main that we implement.
7.2 Program Synthesis & Applications
Program synthesis has been widely used in many domains. Gul-
wani [7] presents an application of program synthesis based on
examples for the Microsoft spreadsheet. He also demonstrates a
rule-based programming environment for spreadsheet data analy-
sis [9]. Singh [19] shows the utilization of program synthesis as
a method to generate feedback for simple coding assignments of
introductory programming courses. After the Ô¨Årst try, Singh again
[18] applies the program synthesis method to automatically gener-
ate algebra problems. Besides the synthesis of algebra problems,
Gulwani [8] displays a method to automatically solve ruler based
geometry construction problems. In this paper, we present a system
called Programming in Eliza (PiE) which automatically generatesLOGO programs using conversations between users and the com-
puter. It demonstrates a novel way for program synthesis.
8. CONCLUSION AND FUTURE WORK
In this paper, we have developed a system called Programming
in Eliza (PiE) to synthesize LOGO programs from natural language
conversations between users and computer. We adopts Eliza for a
novel application on program synthesis. Our preliminary experi-
ence shows that PiE can assist and enhance programming experi-
ence of novices as well as experiences programmers.
In the future, we will design more experiments to test the PiE
system with a more complete feedback. We also plan to experiment
with PiE in the context of K-12 education as the Ô¨Årst programming
system for children. Furthermore, it would be interesting to apply
PiE to domains other than LOGO.
9. REFERENCES
[1] B. W. Ballard and A. W. Biermann. Programming in natural
language: ‚ÄúNLC" as a prototype. In Proc. of the 1979 annual
conference. ACM, 1979.
[2] A. Begel. Programming by voice: A domain-speciÔ¨Åc
application of speech recognition. In AVIOS Speech Tech.
Symposium‚ÄìSpeechTek West, 2005.
[3] A. W. Biermann, B. W. Ballard, and A. H. Sigmon. An
experimental study of natural language programming.
International J. of man-machine studies, 1983.
[4] E. Brill. A simple rule-based part of speech tagger. In Proc.
of the workshop on Speech and Natural Language, 1992.
[5] E. W. Dijkstra. On the foolishness of ‚Äúnatural language
programming". Program Construction, 1979.
[6] W. Feurzeig and S. Papert. LOGO. ODP-Open Directory
Project, 1967.
[7] S. Gulwani. Automating string processing in spreadsheets
using input-output examples. In POPL, 2011.
[8] S. Gulwani, V . A. Korthikanti, and A. Tiwari. Synthesizing
geometry constructions. In PLDI, 2011.
[9] S. Gulwani and M. Marron. NLyze: Interactive programming
by natural language for spreadsheet data analysis and
manipulation. In SIGMOD, 2014.
[10] B. Kendrick. Web turtle, 1997. sonic.net/Àúnbs/webturtle.
[11] H. Kress-Gazit, T. Wongpiromsarn, and U. Topcu. Correct,
reactive, high-level robot control. Robotics & Automation
Magazine, IEEE, 2011.
[12] V . Le, S. Gulwani, and Z. Su. SmartSynth: Synthesizing
smartphone automation scripts from natural language. In
Proc. of the 11th annual int‚Äôl conf. on Mobile systems,
applications, and services. ACM, 2013.
[13] H. Lieberman and H. Liu. Feasibility studies for
programming in natural language. In End User Development,
pages 459‚Äì473. Springer, 2006.
[14] M. R. Maly, M. Lahijanian, L. E. Kavraki, H. K. Gazit, and
M. Y . Vardi. Iterative temporal motion planning for hybrid
systems in partially unknown environments. In Proc. of Int‚Äôl
conf. on Hybrid systems: computation & control, 2013.
[15] Z. Manna and R. Waldinger. A deductive approach to
program synthesis. ACM TOPLAS, 1980.
[16] S. Papert. A computer laboratory for elementary schools.
ArtiÔ¨Åcial Intelligence Memo, 1971.
[17] Roget. Roget‚Äôs Thesaurus. Longman Group, 1982.
[18] R. Singh, S. Gulwani, and S. K. Rajamani. Automatically
generating algebra problems. In AAAI, 2012.
[19] R. Singh, S. Gulwani, and A. Solar-Lezama. Automated
feedback generation for introductory programming
assignments. In PLDI. ACM, 2013.
[20] R. Vlas and W. N. Robinson. A rule-based natural language
technique for requirements discovery and classiÔ¨Åcation in
open-source software development projects. In System
Sciences (HICSS), 2011 44th Hawaii Int‚Äôl Conf. on, 2011.
[21] R. J. Waldinger and R. C. Lee. PROW: A step toward
automatic program writing. In IJCAI, 1969.
[22] J. Weizenbaum. ELIZA‚Äîa computer program for the study
of natural language communication between man and
machine. Communications of the ACM, 1966.
700