Tracking Down Root Causes of Defects in Simulink Models
Johanna Schneider
Daimler AG
Boeblingen, Germany
johanna.schneider@daimler.com
ABSTRACT
Being confronted with a defect in software leads to the well
known task: correcting the software such that the defect
does not occur anymore. Here, the location of the defect
and the corresponding root cause do not have to be identi-cal. Thus, before any correction can be done, the reviewer
has to detect the root cause for the defect. In order to re-
duce the reviewing eﬀort, this paper presents a method toautomatically narrow down possible root causes for defects
found in Simulink models. Starting at a defect location,
a backward search is applied to detect all paths leading tothat defect. Each path is weighted by previously determined
weights depending on the block types contained in the re-
spectivepath. Thisweightingcorrelateswiththeprobabilityof a path containing the root cause.
Categories and Subject Descriptors
D.2.5 [Testing and Debugging ]: Debugging aids
General Terms
Veriﬁcation
Keywords
root cause detection; run-time errors; Simulink models
1. INTRODUCTION
Consider the defect Index exceeds matrix dimensions
displayed by Matlab when calling a 3 ×1 array at index
4. In this case one possible root cause for the returned de-fect is obvious: index 4 is larger than the size of the array.The same defect becomes quickly more complicated. If the
index is not given explicitly as a constant value anymore,
but calculated during several mathematical steps, it mightbe complicated to locate the root cause for the index being
larger than 3. Another possible root cause may also be the
size of the array. There might have happened a fault while
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, orrepublish, to post on servers or to redistribute to lists, requires prior speci ﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.ASE ’14, September 15 - 19 2014, Vasteras, Sweden
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642943
Figure 1: Two-stage process.
generating the array. During studies of Simulink models in
the automotive industry it turned out that several defectsare related and so are their root causes. Thus, the idea is
to learn from defects in already existing models and their
known root causes. This paper describes two processes:
1) oﬄine phase: calculation of block weights using al-
ready analyzed models,
2) online phase: tracking down root causes for defects in
currently analyzed models.
For the given models, defects and root causes in process 1),
all paths leading to the respective defect are determined.
There are two kinds of paths: those containing root causesand the remaining ones. Here, the paths consist of Simulinkblocks having diﬀerent block types like Addition, Switch
etc. The found paths are now weighted. The weight of apath depends on its length and the contained block types.Thus, the block types shall be weighted such that those
paths containing root causes get a higher weight than the
remaining ones. This calculation is formulated in form ofa nonlinear optimization problem. In process 2), again all
pathsarefoundleadingtothecurrentdefectandalsoweight-
ed. The higher a path weight, the higher the probability ofthe path containing the root cause. The aim of this process
is to reduce the manual eﬀort while reviewing a Simulink
model. During the whole process, the model is not exe-cuted, thus the process is a static one. After giving some
599
general information about Simulink, the two-stage process
presented in Figure 1 is described. The ﬁrst stage is the cal-culationof the block weights, the second one the detection ofthe most likely root cause. The second stage is then applied
to two examples: a simple one to demonstrate the method
and a second one taken from the automotive industry. Sec-tion 2 ﬁnishes with remarks to the described method. In
section 3, the results of the overall application are given. It
is shown that the eﬀort of narrowing down the root causescan be reduced by 99.86% compared to the worst case man-
ual analysis. Related work is presented in section 4. Finally,
a summary is given combined with future work in section 5.
2. DETERMINING ROOT CAUSES
As already mentioned, Simulink models are analyzed. Si-
mulink (by MathWorks) is a block diagram environment for
multidomain simulation and Model-Based Design. It sup-
ports system-level design, simulation, automatic code gener-
ation, and continuous test and veriﬁcation of embedded sys-tems[3]. In general, a Simulink model consists of blocks and
lines. The blocks represent actions like mathematical opera-tions (addition, multiplication, etc), ﬁlter operations and soon. One special kind of blocks is a Subsystem.T h e yh e l p
the developer to keep a system clearly structured, i.e. the
system-level design . The blocks are connected by lines, the
signalﬂow. Withinthispaper, abackwarddepth-ﬁrstsearch
is applied. To do this, the model is seen as a directed graph:
the blocks in the model become the nodes in the graph, the
signals become the directed edges. In order to get one con-nected graph instead of several connected components, some
block types like Subsystem orGoto/From have to be treated
in a special way. When talking about the backward depth-
ﬁrst search, the expression pathoccurs. Within this paper,
a path is a sequence of nodes with a directed edge in be-tween. Thus, in a Simulink model a path consists of blocksand signal lines, in the graph of nodes and edges. For thesake of simplicity, the lines or edges are not mentioned when
describing a path. Two additional deﬁnitions are necessary
here as well: defectand root cause . A defect is a weakness
of the software that leads to unintended or unexpected be-
havior. The root cause is the reason for this defect. As an
example: a division by zero is a defect, whereas the rootcause may be the command when the divisor becomes zero.
2.1 Determining the Defects
Before the search for the root cause can be applied, de-
fects and their location must be found. There are severalapproachesingettingthosedefectsliketestingorstaticanal-ysis. Here, the latter one is chosen. Thus, also the way ofdetermining the defects is a static process. In this case, C
code is generated from the Simulink model using the tool
TargetLink by dSPACE [1]. This generated code is ana-lyzed by Polyspace (MathWorks). Polyspace helps to detect
and prove the absence of overﬂow, divide-by-zero, out-of-bounds array access, and other run-time errors in sourcecode. Polyspace products use static code analysis and formal
methods (with abstract interpretation) to verify C and C++
or Ada code. You can use Polyspace static analysis toolsto verify both handwritten and generated code for embedded
software [4]. Polyspace returns four kinds of messages dur-
ing the analysis:•green: no run-time error found at this location,
•red: actual run-time error found at this location,
•orange: potential run-time error found (may be be-
cause of imprecision of the tool since it overapproxi-mates the code),
•gray: deadorineﬀectivecode(i.e. thosedefectstreatedwithin this paper).
Note that dead code is not a defect like array out of bounds
or division by zero. However, the maintainability is inﬂu-
enced in a negative way since there are redundant blocksused. Furthermore, more memory is used than necessary.
There are also situations when a false block property leads
to dead code. Thus, it may help to ﬁnd such defects. Some-times dead code is desired, for example in variant handling.The location of the defect can be mapped onto the corre-
sponding block in the Simulink model. Nowadays, Math-
Works supports this mapping [2]. Otherwise, the commentsof the code generator TargetLink can be used in order to get
the block name. Based on the blocks obtained in this way,
the detection of the most likely root causes can be applied.
2.2 Weighting of the Blocks
Before the weights of the blocks can be determined, al-
ready analyzed models of the automotiveindustryare taken.
Thus, the list of defects is known. Comparing the respective
modelversionwithitssuccessor, bugﬁxesbecomevisibleandthereby the root causes for the defects. The defects are then
mapped to the Simulink model. The mapped blocks are
now taken as the starting blocks for the modiﬁed backwarddepth-ﬁrst search findPaths:
findPaths(u,path,allPaths)
Input:node u, current path path,a l lp a t h s allPaths
Output: all paths allPaths
adj = Adj(u) % adjacency list of node u
ifadj = {} % u does not have adjacent nodes
allPaths = [allPaths,path]
else
for(i=1tolength(adj))
v = adj(i)
if(v not in path) % v not yet in path
path = [path,v]
allPaths = findPaths(v,path,allPaths)
else % v already in path
path = [path,v]allPaths = [allPaths,path]
end
end
end
This algorithm is based on the pseudo code described in
[8] and modiﬁed such that a block can be visited several
times and such that the paths are saved. The aim of this
search is to determine all paths leading to the respectivedefect block. When a loop is detected inside one path, the
search ﬁnishes for this path. Otherwise, the search would be
inﬁnite. However, the block closing the loop is added to thepath to give the path an additional weight. As an example:
in case of the defect type overﬂow, the iterative addition of
several signals within a loop may cause the defect with a
higher probability than outside a loop.
600Figure 2: Example oﬄine phase - environment.
Figure 3: Example oﬄine phase - subsystem.
There are two kinds of paths: those containing the actual
root cause and the remaining ones. For both kinds a matrix
is generated respectively: R(root causes) and P(remaining
paths). While a row depicts a path, each column represents
ab l o c kt y p e :
R(i, j)=# blocks of type jin path i
#b l o c k si np a t h i.(1)
Thus, each entry in the matrix is divided by the respec-tive path length. Otherwise, long paths would dominate thecalculation. Consider the example model in Figure 2 andFigure 3. The corresponding code part is shown in Fig-
ure 4. The message reported by Polyspace is: if-condition
always evaluates to false (marked by the cross), i.e. at the
block LogOp_A. Because of the description of the bugﬁx, it
is known that the corresponding root cause (denoted by the
bug) is the block Memory_U. There are four paths leading to
the defect within the model:
p
1=LogOp_A →LogOp_N →u→u1,
p2=LogOp_A →Switch_R →IV→IV1,
p3=LogOp_A →Switch_R →R→R1,
p4=LogOp_A →Switch_R →Memory_U →u→u1.
Figure 4: Example oﬄine phase - code.block type weight
Constant 93.9244
EnablePort 0.3812
Gain0.6871
Logic 25.7269
Switch 0
Table 1: Extract of the scaled solution of (6).
The path p4is the one containing the root cause for this
defect, i.e. this path has to be described by the matrix R:
R=/parenleftbigLogOp Switch Inport UnitDel Const
p41/51 /52 /51 /50/parenrightbig
.
(2)
The matrix Pis built analogously:
P=⎛
⎝LogOp Switch Inport UnitDel Const
p12/40 2 /40 0
p21/41 /41 /40 1 /4
p31/41 /42 /40 0⎞⎠.
(3)
Letxbe the array containing the weights for the blocks,
thus unknown yet. For this example it yields
x=⎛
⎜⎜⎜⎝w(LogOp)
w(Switch)
w(Inport)
w(UnitDel )
w(Const)⎞
⎟⎟⎟⎠. (4)
The idea is to calculate xin a way such that each entry of
R·xis larger than each entry of P·x, i.e.
(R·x)
min >(P·x)max. (5)
Here, (R ·x)minrepresents the minimal entry of the matrix
vector multiplication, analogous is ( P·x)maxthe maximal
value of the array P·x. The equation states that the paths
containing root causes shall get a higher weight than the
remaining ones. A solution for xis obtained by formulating
this as a nonlinear optimization problem:
max
x{(R·x)min−(P·x)max}≡
min
x{(P·x)max−(R·x)min}(6)
with constraint
xi≥0∀1≤i≤n
where nis the length of array x. The nonlinear optimiza-
tion problem (6) is solved using the Matlab command fmin-
con. The resulting array is subsequently scaled to 100 which
still satisﬁes (5). Until now, 27 defects of type unreach-able/ineﬀective code in models of the automotive industry
are used for the calculation of the block weights. There
are 19,328 paths leading to those 27 defects, thereof 27paths containing the respective root cause. The matricesRandPare built like shown before: R∈R
27×33,P∈
R19,301× 33. The number of columns is 33 since there are
33 diﬀerent block types contained within the 19,328 paths.With those two matrices, the nonlinear optimization prob-
lem (6) is solved. An extract of the solution is presented in
Table 1.
601Figure 5: Example model.
2.3 Detecting the Most Likely Root Causes
In the previous section it is described how the weights
for the diﬀerent block types are calculated. This is done
only once during the oﬄine phase. Thus, these weights shall
be valid for all models to be analyzed for a certain kindof defect. In order to determine the most likely root causeswithin the online phase, the ﬁrst steps are the same like dur-
ing the calculation of the block weights. First, the defects
are determined and mapped to the corresponding Simulinkblocks. The following is done for each of these blocks suc-
cessively. Again, the backward depth-ﬁrst search is applied
to the current block in order to detect all paths leading to it.In contrast to the process of the calculation of the weights,
only one matrix Pis created now (it is not yet known which
of these paths contain the root causes). Most important is
to keep the order of the block types, i.e. the columns, the
same as during the calculation of x. Now the matrix Pis
multiplied by the weights x:
w=P·x. (7)
The entry iofwcorresponds to the weight of path p
i.T h i s
multiplication is equivalent to the expression
w(i)=/summationtext
bl∈p iw(bl)
|pi|(8)
with bl∈pia block in pi,w(bl) the weight of block bland
|pi|t h en u m b e ro fb l o c k si np a t hp i. The paths leading
to the highest entry of the returned array are the pathscontaining the most likely root cause. As a last step, the
reviewer himself has to decide the ﬁnal root cause. Thus,the presented method reduces the reviewing eﬀort in a huge
dimension. Since this method is a heuristic process it may
happen that the search for a root cause is not successful.
2.4 Application
Consider the Simulink model in Figure 5. Polyspace re-
turns a gray message for the code if(0): if-condition al-
ways evaluates to false . A mapping to the model leads
to the block Enablein the subsystem called Enabled Sub-
system(the symbol at the top within Enabled Subsystem ).
This means that the signal leaving the block Switchalways
has the same value (in this example always 0). Thus, the
Enableblock becomes the starting block for the described
method. First, all paths leading to that block are detected:
p1=Enable→Switch→Gain→Constant ,
p2=Enable→Switch→Constant1 ,
p3=Enable→Switch→Logical Operator
→Constant2 .Figure 6: Environment of Figure 7.
Thematrix Pdescribingtheblocktypesineachpathisbuilt
like shown before. Due to lack of space, only a reduced ma-trixˆPispresentedhere(theoriginalmatrixhas33columns).
Thus, only the columns representing block types containedwithin the path are shown:
ˆP=⎛
⎝Const Enable Gain Logic Switch
p
111 1 01
p211 0 01
p311 0 11⎞⎠.(9)
Dividing each row by its sum leads to the matrix
ˆP
1=⎛⎝Const Enable Gain Logic Switch
p
11/41 /41 /40 1 /4
p21/31 /30 0 1 /3
p31/41 /40 1 /41 /4⎞⎠.
(10)
This matrix is now multiplied by the reduced array
ˆ x=⎛
⎜⎜⎜⎝w(Const)
w(Enable)
w(Gain)
w(Logic)
w(Switch)⎞
⎟⎟⎟⎠(11)
with weights taken from Table 1:
ˆP
1·ˆ x=ˆP1·⎛
⎜⎜⎜⎝93.9244
0.3812
0.6871
25.7269
0⎞
⎟⎟⎟⎠=⎛
⎝23.7482
31.435230.0081⎞
⎠=⎛⎝w(p
1)
w(p2)
w(p3)⎞⎠.(12)
Thus, the path with highest path weight is p
2. Indeed, this
is the path inﬂuencing the result of the Switchblock, i.e.
the decision signal. Since the signal is constant, always the
same signal leaves the Switchblock: the outgoing signal of
the block Logical Operator . This signal is also constant
and therefore the entry into to the Enableblock is always
the same. Hence, path p2together with path p3, i.e. the
path with second highest weight, contain the root cause forthe ineﬀective model part.A more complex example is presented in Figure 6. Thecontained subsystem TurnOffDelayTime is taken from the
automotive industry and shown in Figure 7. The environ-ment in Figure 6 is built up similar to a real model. InTable 2, the returned messages by Polyspace are presented.
Since the blocks Switch_R1 and Switch_R2 depend on the
outgoing signal of the block LogOp_R, only the latter one is
taken for the analysis. This situation is described in detailin section 2.5. Applying the presented method to the block
LogOp_R leads to 12 paths with length of 3 up to 9. The
minimum of the returned path weights is 2.7007, the maxi-
mal weight is 40.0081 followed by the weight 30.1138. The
path having the maximal weight is the one containing themarked blocks in Figure 6 and 7: LogOp_R →R→Constant .
602Figure 7: Subsystem TurnOﬀDelayTime of Figure 6 .
Block Corresponding Code Polyspace Message
LogOp_R if (0 && R) if-condition always evaluates to false
Switch_R1 if (LogOp_R >= 1) if-condition always evaluates to false
Switch_R2 if (LogOp_R >= 1) if-condition always evaluates to false
Table 2: Defects in Figure 6 and Figure 7.
Because of the value 0of the Constant block, the result of
theANDoperation is always 0. Thus, the root cause is the
Constant block which is contained within the path found by
the presented method. The average time (based on 10 runs)
of applying the method to this example is approximately0.05 seconds.
2.5 Outliers
In the previous example only one reported message is pur-
sued although three messages are reported. The reason isthat the outgoing signal of LogOp_R is the decision signal
of the two Switchblocks Switch_R1 and Switch_R2.T h u s ,
if the signal of LogOp_R does not change, always the same
signal is chosen within the Switchblocks. This yields to the
messages by Polyspace presented in line 2 and 3 in Table
2. So in this case it is useful to apply a kind of dependence
analysis: before a root cause is searched for a defect, it is
checked whether the reported message may arise because ofa preceding defect. Using a breadth-ﬁrst search, a path from
a defect xto a defect yis searched. If such a path exists,
the defect yis negligible. In the example above there exist
paths from the block LogOp_R to both Switchblocks and
therefore the two blocks are not considered. The most im-portant thing to keep in mind when applying the presented
method: the root cause does not have to be unique and it
is also possible that several paths contain parts of the rootcause like the paths p
2and p3in Figure 5.
3. RESULTS
As described in section 2.2, 27 defects with overall 19,328
paths leading to them are taken for the calculation of 33block weights during the oﬄine phase. During the onlinephase, the presented process is applied to 12 Simulink mod-
elsdescribingcomfortsystemswithincarslikepowerwindow
controlorseatheatercontrol. Thosemodelscontainapprox-imately between 1,000 and 22,000 blocks. First, C code is
generated for all models using TargetLink. The analysis of
this code by Polyspace yields 129 defects of kind unreach-able code. Example reasons for reported unreachable code
messages are the command a& &! a or a constant decision
signal entering a Switchblock. After the mapping to the
Simulink models, all paths leading to those 129 defects are
Figure 8: Distribution of paths per defect.
path p#p a t h s
reviewed# found root
causes% of total
paths
max 54 45⇒83.3% 0.11%
2ndmax 63 49⇒90.7% 0.13%
3rdmax 68 54⇒100% 0.14%
Table 3: Review eﬀort/success during the online
phase.
found. Thereare48,326paths, wherebythenumberofpaths
found per defect ranges between 1 and approximately 5,000.
The precise distribution is presented in Figure 8. There are
75 defects with only one path leading to it, so their pathcontaining the root cause is obvious. Thus, those defectsare neglected here. Hence, 54 defects and 48,251 paths are
remaining. Now the paths are weighted using the weights
calculated during the oﬄine phase. Afterwards, the pathsare sorted by descending weight for each defect respectively.
The results of the review process is shown in Table 3. For
each defect the path with highest weight (path p=max)i s
reviewed. Within those 54 paths, 45 root causes are found,
i.e. 83.3%. There are 9 defects left with unknown root
causes. So, for those 9 defects, also the paths with sec-ond highest weight (path p=2
ndmax) are reviewed. This
leads to 4 additional root causes and 5 left defects. Here,the paths with third highest weight ( path p=3
rdmax)a r e
additionally reviewed, leading to all root causes. Overall,
60368 paths (54+9+5) are reviewed in order to ﬁnd all root
causes. Comparing this to the number of all found paths:this method only takes 68/48,251 = 0.14% of the worst casereview eﬀort in searching for the root causes.
4. RELATED WORK
In [9] and [10], the authors search for root causes why a
test case makes a program fail. The ﬁrst step is to eliminateeverything irrelevant for this failure. This is nearly similarto the search for all paths leading to a defect presented in
my approach. Then there is searched for a passing test case.
The diﬀerence between the failing and the passing test casesshall be minimal since this diﬀerence is declared to be theroot cause for the failure. Another approach to determine
root causes is presented in [6]. The authors describe the
cause of an UNSAT part as the union of all minimal un-satisﬁable subsets (MUS). Papers like [7] or [11] are about
regression failures or software changes. Within those papers
I found ideas which may help during the oﬄine phase. Untilnow, the diﬀerent versions of the same model are compared
manually in order to detect the corrections and root causes.
IfitispossibletotransferthepresentedmethodstoSimulinkmodels, this procedure can be automated and reduces the
manual eﬀort again.
5. CONCLUSION
This paper introduced a method to narrow down root
causes for defects in Simulink models in a static way. First,
within the oﬄine phase weights for diﬀerent block types arecalculated based on experience of already analyzed models
and nonlinear optimization. This is done once independent
from the current model. For the current model the onlinephase is applied. The defects are determined using abstractinterpretation for the generated code of the model. Then a
mapping from the defects in the code to the corresponding
blocks in the Simulink model is done. Now, all paths lead-ing to such a block are found using a backward depth-ﬁrst
search. Each path is weighted depending on the contained
kinds of block types and the length of the path. The pathswith highest weight are presented to the reviewer such that
he ﬁnally has to decide which one(s) to choose. So he only
has to review a few paths instead of the whole model. Thismethod is successfully applied to several Simulink models
from the automotive industry with respect to the defect un-
reachable/ineﬀectivecode. Pleasenotethatthereisnoguar-antee that the method leads to the actual root cause because
thedescribedprocessisbasedonaheuristicapproach. Addi-
tionally, it may be possible that more information is neededin order to ﬁnd the root cause, like requirements which arenot given within the model. This method has been devel-
oped since several defects and their root causes are related.
Thus, another approach would be to search for certain kindsof patterns instead of paths leading to the defects. An ad-
ditional aim is to extend this method to other kinds of run-
time errors which can be found by Polyspace like array outofbounds, divisionbyzeroandso on. Here, probablyorange
messages by Polyspace have to be analyzed in order to de-
cide whether the message is an actual defect. To reduce themanual eﬀort, abstract interpretation can be combined with
bounded model checking like in [5]. If this method can be
applied successfully also to those kinds of defects, the maingoal is to develop an automated correction of the defects.Another extension is a reﬁnement of the block weights: af-ter each successful application of this process, the analyzeddefects and paths are added to the list of defects for whichthe root causes are already known. Thus, the nonlinear op-
timization can be applied again to obtain reﬁned values for
the block weights.
6. REFERENCES
[1] dSPACE. TargetLink - Automatic production code
generator.
http://www.dspace.com/en/ltd/home/products
/sw/pcgs/targetli.cfm, 2014. [Online; accessed31-March-2014].
[2] MathWorks. Polyspace Code Prover.
http://www.mathworks.com/products/polyspace-code-prover/index.html, 2014. [Online; accessed02-April-2014].
[3] MathWorks. Simulink - Simulation and Model-Based
Design.
http://www.mathworks.com/products/simulink/,
2014. [Online; accessed 31-March-2014].
[4] MathWorks. Static Analysis with Polyspace Products.
http://www.mathworks.com/products/polyspace/,
2014. [Online; accessed 01-April-2014].
[5] H. Post, C. Sinz, A. Kaiser, and T. Gorges. Reducing
false positives by combining abstract interpretation
and bounded model checking. In Proceedings of the
2008 23rd IEEE/ACM International Conference onAutomated Software Engineering, pages 188–197.IEEE Computer Society, 2008.
[6] A. Reder and A. Egyed. Determining the cause of a
design model inconsistency. IEEE Transactions on
Software Engineering , 39(11):1531–1548, November
2013.
[7] R. Sukkerd, I. Beschastnikh, J. Wuttke, S. Zhang, and
Y. Brun. Understanding regression failures through
test-passing and test-failing code changes. In
Proceedings of the 2013 International Conference on
Software Engineering , pages 1177–1180. IEEE Press,
2013.
[8] Wikipedia. Depth-ﬁrst search.
http://en.wikipedia.org/wiki/Depth-ﬁrst
search#Pseudocode, 2014. [Online; accessed
15-April-2014].
[9] A. Zeller. Why Programs Fail. dpunkt.verlag,
Ringstraße 19B, 69115 Heidelberg, 2006.
[10] A. Zeller and R. Hildebrandt. Simplifying and
isolating failure-inducing input. Software Engineering,
IEEE Transactions on , 28(2):183–200, 2002.
[11] T. Zimmermann, A. Zeller, P. Weissgerber, and
S. Diehl. Mining version histories to guide softwarechanges. Software Engineering, IEEE Transactions on,
31(6):429–445, 2005.
604