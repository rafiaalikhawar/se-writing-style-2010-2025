A History-Based MatchingApproachtoIdentiﬁcationof Fram eworkEvolution
Sichen Meng1,2, Xiaoyin Wang1,2, Lu Zhang1,2, Hong Mei1,2
1Key Laboratory of High Conﬁdence Software Technologies, Mi nistry of Education
2School of Electronics Engineering and Computer Science, Pe king University, Beijing, 100871, China
{mengsc11,wangxy06,zhanglu,meih }@sei.pku.edu.cn
Abstract—In practice, it is common that a framework and
its client programs evolve simultaneously. Thus, develope rs of
client programs may need to migrate their programs to the
new release of the framework when the framework evolves. As
framework developers can hardly always guarantee backward
compatibility during the evolution of a framework, migrati on
of its client program is often time-consuming and error-pro ne.
To facilitate this migration, researchers have proposed tw o cat-
egories of approaches to identiﬁcation of framework evolut ion:
operation-based approachesand matching-based approaches.To
overcome the main limitations of the two categories of ap-
proaches, we propose a novel approach named HiMa, which is
based on matching each pair of consecutive revisions record ed
in the evolution history of the framework and aggregating
revision-level rules to obtain framework-evolution rules . We
implemented our HiMaapproach as an Eclipse plug-in target-
ing at frameworks written in Java using SVN as the version-
control system. We further performed an experimental study
onHiMatogether with a state-of-art approach named AURA
using six tasks based on three subject Java frameworks. Our
experimental results demonstrate that HiMaachieves higher
precision and higher recall than AURAin most circumstances
and is never inferior to AURAin terms of precision and recall
in any circumstances, although HiMais computationally more
costly than AURA.
Keywords -framework evolution; software migration; mining
version history; natural language processing
I. INTRODUCTION
Nowadays, many developers choose to use software
frameworks to reduce the cost and/or improve the quality
of application development. Just as other software product s,
software frameworks also need evolution to obtain new
featuresand/orimprovequality.As a result, when a softwar e
framework evolves, developers of client programs of the
framework may need to migrate their client programs to the
new release of the framework to take advantage of the new
release. Ideally, developersof a frameworkshould guarant ee
that the new release be backwardly compatible with each
release before the new release, so that developers of any
client program using an old release of the framework are
able to immediately migrate to the new release without
further modifying the client program. However, researcher s
(e.g., Chow and Notkin [1], Steyaert et al. [2], Balaban
et al. [3], and Dig and Johnson [4]) have identiﬁed the
pervasive existence of backward incompatibility between
a new release and an old release in frameworks. Wu et
al. [5] presented an example of backward incompatibility ina widely used framework (i.e., between JHotDraw 5.2 and
5.3).Thus,migrationfromanoldreleaseofaframeworktoa
newreleasemayimplyextramodiﬁcationsoftheclientcode.
These modiﬁcations may typically be tedious and require a
lot of effort [5]. To alleviate the backward incompatibilit y
problem, it is necessary to identify the evolution rules
between the two releases of the framework.
In particular, researchers(e.g., Wu et al. [5]) have demon-
strated the necessity of automatically identifying four ty pes
of evolution rules: one-to-one (i.e., one method in the old
release replaced by anothermethod in the new release), one-
to-many(i.e.,onemethodintheoldreleasereplacedbymore
than one method in the new release), many-to-one (more
than one method in the old release replaced by one method
in the new release), and simply-deleted (i.e., methods in the
old release not appearing and having no replacements in the
new release).
In fact, identiﬁcation of framework evolution has become
a research focus in recent years. Roughly speaking, there
are mainly two categories of approaches to identiﬁcation of
framework evolution.
First, researchers (e.g., Henkel and Diwan [6]) have
proposed operation-based approaches, which use Integrated
Development Environments (IDEs) to record change op-
erations related to framework evolution and replay the
recorded operations to identify framework evolution. Thes e
approaches typically are able to achieve both high recall
and highprecision1, but the requirementofusing specialized
IDEsmakestheminapplicableformostexistingframeworks.
Second, researchers (e.g., Wu et al. [5]) have proposed
matching-based approaches, which compute evolution rules
via matching the source code of the two releases. Due
to the independence of IDEs, matching-based approaches
are applicable for more existing frameworks. But matching-
based approaches can hardly always achieve high precision
without compromising recall due to the inability to sufﬁ-
cientlyuse ﬁnerinformationduringframeworkevolution.A s
a sub-category of matching-based approaches, there are also
approaches (e.g., Sch¨ afer et al. [7]) that analyze adaptat ions
inonlyinstantiationcodetoinferframework-evolutionru les.
1Recall refers to the ratio of correctly identiﬁed rules to al l genuine rules
and precision refers to the ratio of correctly identiﬁed rul es to all identiﬁed
rules.The use of instantiation code2may help improve precision,
but the reliance on only instantiation code makes these
approaches difﬁcult to obtain rules related to Application
Programming Interfaces (APIs) not used in instantiation
code.
In this paper, we propose a hi story-based ma tching ap-
proach (named HiMa) to identiﬁcation of framework evo-
lution. The basic idea of HiMais to identify change rules
related to framework evolution via matching each pair of
consecutive revisions of the framework stored in its versio n-
control system (e.g., SVN3), and aggregate the revision-
level rules to obtain the evolution rules between the two
releases. To achieve wide applicability, HiMarelies on
only information stored in common software-development
infrastructure. To achieve both high precision and high
recall,HiMaanalyzes all revisions between the two releases
during the evolution history of the framework. Moreover,
as our empirical investigation has identiﬁed that comments
associated with revisions often contain information about
framework evolution, we also utilize these comments in
HiMato further improve precision and recall.
To evaluate our HiMaapproach, we conducted an exper-
imental study of HiMatogether with a recently proposed
matching-based approach (i.e., AURA[5]) using six tasks
based on three subject Java frameworks. Our experimental
results demonstrate that HiMaachieves higher precision
and higher recall than AURAin most circumstances and is
never inferior to AURAin any circumstances, although the
computational cost of HiMais higher than that of AURA.
This paper makes the following main contributions:
•Anovelapproach,whichovercomesmainlimitationsof
both categories of existing approaches, to identiﬁcation
of framework evolution.
•A technique based on natural language processing to
identify change rules from comments associated with
framework revisions.
•An experimental comparison of our approach with
AURAtodemonstratetheeffectivenessofourapproach.
The remaining of this paper is organized as follows. Sec-
tion II reviews existing research related to ours. Section I II
presents our approach. Section IV reports an experimental
study of our approach. Section V discusses further issues.
Section VI concludes with pointers to future work.
II. RELATEDWORK
A. Identiﬁcation of Framework Evolution
For the ease of presentation, we classify existing ap-
proaches to identiﬁcation of framework evolution into two
categories: operation-based approaches and matching-based
approaches.
2Researchers typically refer to the code invoking framework APIs as
instantiation code when investigating framework-evoluti on identiﬁcation.
3subversion.apache.org, accessed in March 20121) Operation-Based Approaches: The basic idea of
operation-based approaches is to record change operations
performedonthe frameworkin anIDE andreplaythe opera-
tionsto identifyframeworkevolution.Henkel andDiwan [6]
proposed CatchUP! , which uses a specialized IDE to record
refactoring operations performed on APIs of the framework
and replay these operations to update client code. More-
over, Dig et al. [8] proposed a refactoring-aware software
conﬁguration management tool named MolhadoRef , which
also utilizes recordingand replaying of change operations to
merge versions. Although MolhadoRef does not explicitly
target at identiﬁcation of framework evolution, it can be
adapted for this purpose.
As API refactoring operations can accurately characterize
how the framework evolves, operation-based approaches
are typically very accurate. That is to say, both recall
and precision of operation-based approaches can be very
high. However, recording and maintaining API refactoring
operationsalong the evolution historyof the frameworkmay
be a burden for framework developers. Thus, although some
widely used IDEs (e.g., JBuilder [9]) already provide the
capability of recording change operations, many existing
frameworks are developed with IDEs not providing (or
switching off) the capability of recordingchange operatio ns.
As a result, operation-based approaches are not widely
applicable for existing frameworks.
To overcome limitations of existing operation-based ap-
proaches, our approach is based on revisions instead of
operations in the evolution history of the framework. Due to
the wide adoption of version-control systems (e.g., SVN)
in practice, there may typically exist a large number of
revisions between two releases of a framework. Of course,
information in revisions is still less ﬁne than information
in operations. But the availability of revisions is much
higher than that of operations. Moreover, as developers
often provide a summary of change in the form of plain
texts associated with a revision, our approach also uses thi s
information to further improve accuracy.
2) Matching-Based Approaches: The basic idea of
matching-based approaches is to compare the source code
of the two releases, and ﬁgure out evolution rules from the
differences between the two releases using some heuristics .
In particular, researchers have investigated the followin g
typesof heuristics: heuristicsbased on call dependency[1 0],
[11], [12], [13], [5], [14], heuristics based on text simi-
larity [15], [11], [12], [16], [17], [18], [5], [14], heuris tics
based on structure similarity [16], and heuristics based on
metrics [19], [11], [12], [20], [18], [14]. Some approaches
even use more than one type of heuristics. Godfrey and
Zou [11] proposed to use origin analysis, which relies on
heuristics based on text similarity, call dependency, and
metrics, to infer evolution rules. As Godfrey and Zou’s
approach is semi-automatic, S. Kim et al. [12] further pro-
posedtoautomatetheirapproach.WeißgerberandDiehl[20]proposed to use metrics based on syntactical differences
to infer candidate refactorings from changes between ﬁle
versions and use clone analysis to rank the candidate
refactorings. Xing and Stroulia [16] proposed Diff-Catchup ,
which matches two models written in the Uniﬁed Modeling
Language (UML) using heuristics based on text similarity
andstructuresimilarity.M.Kimetal.[17]summarizedsome
patterns for name changes during framework evolution and
used these patterns to infer rules of framework evolution.
The most advanced matching-based approach is AURA[5],
which involves multiple rounds of iteration using heuristi cs
based on call dependency and text similarity. According to
Wu et al. [5], the AURAapproach is able to overcome sev-
eral limitations of previous approaches and vastly improve
recall. However, AURAtypically concedes some decrease in
precisionand in some special cases the decrease in precisio n
may be signiﬁcant.
It should be noted that some of the preceding heuristics
canbeextendedtoinstantiationcodetoexplorehowinstant i-
ation code of the framework adapts to framework evolution.
Sch¨ afer et al. [7] proposed to infer rules of framework
evolutionfromthe changesin client code for migratingfrom
onereleasetoanother.DagenaisandRobillard[21]propose d
SemDiff, which infers rules of framework evolution via an-
alyzing how the framework changes itself in response to its
evolution. Due to the abundance of adaptation examples for
framework evolution, using instantiation code can improve
precision due to the capability to corroborate between adap -
tationexamples.Moreover, SemDiffconsidersadaptationsin
the evolution history between the two releases. The use of
adaptationinformationinaﬁnergranularityfurtherimpro ves
its accuracy. However, rules inferred from instantiation c ode
do not include those related to APIs not used in instantiatio n
code. That is to say, using only instantiation code may even
decrease recall. Note that frameworks typically contain co ld
spots[22],whichareAPIsseldomusedininstantiationcode .
As matching-based approaches do not rely on recorded
operations, applicability of matching-based approaches i s
typically higher than operation-based approaches. Howeve r,
matching-based approaches can hardly always be very ac-
curate due to the inability to sufﬁciently use ﬁner evolutio n
information. In fact, matching-based approaches typicall y
need to balance between precision and recall. In general, th e
AURAapproach makes a good trade-off between precision
and recall, but some complex changes inside method bodies
may mislead AURA[5].
To overcome limitations of existing matching-based ap-
proaches, our approach uses ﬁner information recorded in
revisions together with their comments recorded in the
evolution history of the framework. Because of the abun-
dance of information, our approach is able to use strict
criteria to identify enough rules and corroborate among the
information to discard incorrect rules. Note that, althoug hWeißgerber and Diehl’s approach4[20] also utilizes ﬁle
versions in version-control systems, their approach aims t o
infer possible refactorings from one transaction committe d
to a framework but not to further aggregate refactorings
inferred from multiple transactions to obtain evolution ru les
between two releases of the framework. Furthermore, their
approachdoesnot utilizecommentsassociated with version s
and requires human intervention to check the ranked list.
B. Natural Language Processing for Software Engineering
Sawyer et al. [23] proposed REVERE, which combines
part-of-speech (POS) [24] tagging and semantic tagging
to synthesize requirements from documents. Fantechi et
al. [25] proposed to analyze use case descriptions in natura l
languagesusing natural languageparsing [26]. Kof [27] pro -
posed to use POS taggingto analyzerequirementdocuments
to obtain missing objects and actions. Shepherd et al. [28]
proposed to locate and understand action-oriented concern s
in programs using a combination of several Natural Lan-
guageProcessing(NLP) techniques.Tan et al. [29] proposed
iComment , which combines NLP and other techniques to
extract explicit program rules and detects inconsistencie s
between comments and source code. On top of iComment ,
Tan et al. [30] proposed aComment , which combines NLP
with call-graph analysis to infer speciﬁcations for inter-
ruptions and detects interruption-related bugs. Zhong et
al. [31] proposed Doc2Spec , which combines named entity
recognition (NER) [32] and class-hierarchy analysis to inf er
implicit speciﬁcations from object-oriented API document s.
Abebe and Tonella [33] proposed to use natural language
parsing to extract concepts from source code.
To our knowledge, our approach, which uses specialized
NLP techniques with natural language parsing [26] to infer
change rules from revision comments, is the ﬁrst approach
that applies NLP for framework-evolution identiﬁcation.
III. OURAPPROACH
A. Basic Idea
The basic idea of our approach is to identify change rules
between each pair of consecutive revisions and aggregate
these change rules to obtain the evolution rules between the
two releases. Note that a mainstream version control system
such as SVN typically records every revision (subversion)
of the entire software system under development.
Intuitively, these revisions provide more information of
changesmade in the evolution history of the framework.For
example, Struts 1.1 and Struts 1.2.4 correspond to revision s
50638 and 51732 in its corresponding SVN repository with
1073 revisions containing code changes in between.
Furthermore, according to our empirical evidence, frame-
work developersoftensummarizethe main changesbetween
a revision and its predecessor revision in the comment for
4Weißgerber and Diehl’s approach actually targets at refact oring identiﬁ-
cation, which is slightly different from framework-evolut ion identiﬁcation.
Pleaserefer toSch¨ afer etal. [7]forfurther discussion on themaindifference
between the two problems.checkingin the successor revision.When identifyingchang e
rules between two revisions, we use the comment associated
with the successor revision as our initial clues.
B. Matching Two Consecutive Revisions
We use the following two main steps to identify change
rules between two revisions. First, we analyze the comment
of the successor revision to identify some raw change rules,
and validate the raw change rules against the source code to
obtain a set of initial change rules. Second, we expand the
set of identiﬁed initial change rules to obtain change rules
for other changes between the two revisions. Unlike AURA,
to reduce computational cost, we do not use iteration.
1) IdentifyingInitialChangeRules: We usethefollowing
ﬁve sub-steps to identify initial change rules.
First, we split the entire comment into sentences. In
natural language processing, delimiter punctuation marks
(e.g., ‘?’, ‘!’, and ‘.’) serve as separations of sentences.
We also rely on these delimiters, but we need to handle
the following two special cases. The ﬁrst case is the dot
mark serving as a connector of a class and its member (e.g.,
Circle.toString() ).To deal with this case, we use a dot
together with a following space instead of mere a dot as a
delimiter. The second case is the hard new-line symbol. As
developers may directly use a hard new-line symbol to start
a new sentence, we also count hard new-line symbols as
delimiters.
Second,weﬁlter outirrelevantsentencesasfollows.Here,
we are primarily interested in words and phrases meaning
either addition, deletion, or replacement, which are refer red
to aschange identiﬁers in this paper. In fact, we maintain
three synonym lists (which we put on our project website
to keep them always consistent with our implementation),
each representing a change type , which could be addition,
deletion,orreplacement .Furthermore,we arealso interested
in sentences containing entity names (i.e., class names or
method names). In particular, we deem the following cases
as entitynames: 1)a wordafterthe word“class” orthe word
“method”, 2) a pair of empty parenthesis or a pair of paren-
thesis inside which the text matches the syntax of method
signatures, 3) a word immediately following a dot (e.g.,
ResizeinCircle.Resize ), and 4) a word composed of
several words throughunderlinesor capitalization of the f ol-
lowing words (e.g., ContentTransferEncodingField ).
Thus, we keep only those sentences that contain at least one
change identiﬁer and at least one entity name. Note that
the criteria for entity names considered here may not be
very accurate. The aim of using these criteria is to ﬁlter out
irrelevant sentences, and we further validate entity names in
the ﬁnal sub-step.
Third, for each remaining sentence after the ﬁltering in
the second sub-step, if all the change identiﬁers are of the
samechangetype (denotedas T),we extractonerawchange
rule of change type Tconsisting of all the entity names
in the sentence. For example, if a sentence contains threeentity names (denoted as Name1,Name2andName3) and
thechange type isaddition, we denote the change rule as
<addition, {Name1,Name2,Name3}>.
Fourth, if such a sentence contains change identiﬁers
of more than one change type , we extract more than one
change rule for this sentence. To achieve this goal, we
use a natural language parser to identify the verbs in the
sentence and all the words associated with each verb. If
such a verb is a change identiﬁer , we extract a rule for the
verb considering only entity names associated with the verb
in a way similar to the third sub-step. For example, from
sentence “we added method A() and changed method B()
to B1()”, our comment analysis is able to identify two raw
rules:<addition, {A}>and<replacement, {B},{B1}>.
According to our experience, there are only a few sentences
containing change identiﬁers of two or more change types.
Thus, the heavy-weight natural language parsing would not
be of too much a burden.
Finally, we validate and reﬁne the raw change rules
identiﬁed in the third and the fourth sub-steps against the
source code of the two revisions. In particular, we use the
following strategies for our validation and reﬁnement.
•If the raw rule type is addition, for each entity name
(denoted as n) in this rule, we check whether nexists
in the successor revision and does not exist in the
predecessor revision. If so, we keep nin the rule; and
otherwise, we remove nfrom the rule. If nis a method
name, we deem nas annewly-added method. If nis a
class name, we deem all methods in class nasnewly-
addedmethods.
•If the raw rule type is deletion, for each entity name
(denoted as n) in this rule, we check whether nexists
in the predecessor revision and does not exist in the
successor revision. If so, we keep nin the rule; and
otherwise, we remove nfrom the rule. If nis a method
name, we deem nas asimply-deleted method. If nis a
class name, we deem all methods in class nassimply-
deletedmethods.
•Iftherawruletypeis replacement ,foreachentityname
(denoted as n) in this rule, we check whether nexists
in the predecessor revision or exists in the successor
revision. Here, we demand that all the entity names
in this rule are class names or all the entity names
are method names; otherwise, we ignore this raw rule
due to uncertainty of whether it is class replacement or
method replacement. We also ignore all entity names
not appearing in either the predecessor revision or
the successor revision. Among the remaining entity
names, we deem entity names appearing only in the
successor revision as target entities, and we deem
the other entity names as source entities. According
to Dig et al. [13] and Sch¨ afer et al. [7], developers
may keep both the source entity and the target entity
in the successor revision for backward compatibility.Predecessor Revision Successor Revision 
MimeBoundaryInput
Stream.parentEOF()
MimeBoundaryInput
Stream.consume()StreamCursor.adv 
anceToBoundary()StreamCursor.
isEnded()StreamCursor.adv 
anceToBoundary()StreamCursor.
isEnded()
MimeBoundaryInput
Stream.eof()
Figure 1. Example for Caller Analysis
Similarly, we transform class replacement to method
replacement: a one-to-one rule for each pair of exactly
matched methods and one replacement rule for all the
remaining methods. Thus, depending on the number
of the source methods and the number of the target
methods, each resulting change rule can be of one of
the following types: one-to-one ,many-to-one ,one-to-
many, or even many-to-many .
2) Expanding Initial Set of Change Rules: To expand the
initial set of change rules identiﬁed in the ﬁrst main step,
similar to existing matching-based approaches, we also rel y
on call-dependency analysis. However, as the differences
between two consecutive revisions are typically very small ,
we are able to use strict criteria without thresholds for our
expansion.
First, we analyze the source code of the two revisions
to obtain the set of source methods (i.e., methods in the
predecessor revision but not in the successor revision ) and
the set of target methods (i.e., methods in the successor
revisionbut notinthe predecessorrevision).We also remov e
methods already appearing in the initial set of change rules
from the two sets. We denote the resulting set of source
methods as MSand the resulting set of target methods as
MT.
Second, based on MS,MTand change rules identiﬁed
in the ﬁrst main step, we use caller analysis to expand
changerulesasfollows.The intuitionis that methodsalway s
invoked in the same contexts may have correspondence.
Given method sin the predecessor revision and method tin
the successor revision, we call tmatchessthroughone-to-
onerelationships (denoted as M↔(s,t)), if and only if the
signature of tis exactly the same as that of sor there is
aone-to-one rule identiﬁed in the ﬁrst main step between
sandt. For a set of methods in the predecessor revision
(denotedas S) anda set ofmethodsin thesuccessor revision
(denoted as T), we extend the deﬁnition of M↔(s,t)to
deﬁneM↔(S,T)as Formula 1.
M↔(S,T) =

true,∀s∈S∃t∈T M↔(s,t)∧
∀t∈T∃s∈S M↔(s,t);
false,otherwise.(1)Predecessor Revision Successor Revision 
VFSBrowser.handle 
Message() 
VFSBrowser.pro 
pertiesChanged() BrowserView.up 
dateFileView() 
EditPlugin.upda 
tePopupMenu() VFSBrowser.m 
aybeReload 
Directory() VFSBrowser.pro 
pertiesChanged() BrowserView.up 
dateFileView() 
EditPlugin.upda 
tePopupMenu() VFSBrowser.handle 
PropertiesChanged() VFSBrowser.han 
dleBufferUpdate() 
VFSBrowser.hand 
lePluginUpdate() VFSBrowser.han 
dleVFSUpdate() 
VFSBrowser.m 
aybeReload 
Directory() 
Figure 2. Example for Callee Analysis
Thus, given a method (denoted as ms) inMSand a
method (denoted as mt) inMT, let us denote the set of
callers of msin the predecessor revision as Caller(ms)
and the set of callers of mtin the successor revi-
sion asCaller(mt). We deem that there is a replace-
ment relationship between mtandms, if and only if
M↔(Caller(ms),Caller(mt)). Note that we rely on only
identiﬁed one-to-one relationshipsbetween methodsto guar-
antee precision. Due to our deﬁnition of M↔, it is likely for
us to identify a subset (denoted as M′
S) ofMSand a subset
(denoted as M′
T) ofMTsuch that there is a replacement
relationship between each method in M′
Tand each method
inM′
S. That is to say, one expanded change rule may be
either aone-to-one rule, amany-to-one rule, aone-to-many
rule, or even a many-to-many rule, dependingon the number
of methods in M′
Sand the number of methods in M′
T.
Figure 1 depicts an example (from Mime4J) for ex-
pansion with caller analysis . In the ﬁgure, methods
advanceToBoundary() andisEnded() appear in both
the predecessor revision and successor revision. We need to
identify the relationships between methods parentEOF()
andconsume() appearing in only the predecessor revision
and method eof()appearing in only the successor revision.
As both parentEOF() andeof()are called by only
isEnded() , we identify a one-to-one rule:parentEOF()
replaced by eof(). We identify no rule for consume() in
this sub-step.
Third, based on MS,MTand change rules identiﬁed in
the ﬁrst main step, we also use callee analysis to expand
change rules. The intuition is that methods sharing very
similar calling structures in implementation may have corr e-
spondence.Similarto our calleranalysis ,ourcalleeanalysis
is also based on existing one-to-one relationships. However,
we also need to further consider unaligned matching of
callees in callee analysis . Given a subset (denoted as M′
S)
ofMSand a subset (denoted as M′
T) ofMT, we deem
that there is a replacement rule between M′
SandM′
Tif and
only ifM↔(/uniontext
ms∈M′
SCallee(ms),/uniontext
mt∈M′
TCallee(mt)),
whereCallee(m)denotes the set of callees of method m.
To ensure the atomicity of the identiﬁed replacement rule,we also demand that there is no replacement rule identiﬁed
in this sub-step between any subset other than M′
Sitself and
any subset other than M′
Titself.
Figure 2 depicts an example (from jEdit) for expansion
withcallee analysis . In this ﬁgure, the following four meth-
odsappearinboththepredecessorrevisionandthesuccesso r
revision: propertiesChanged() ,updateFileView() ,
updatePopupMenu() , and maybeReloadDirectory() .
In the predecessor revision, all the four methods are called
byhandleMessage() , but in the successor revision, each
of the four method is called by only one method. Using
the preceding callee analysis , we are able to identify the
splitting of the method for handling all messages into four
methods, each handling a speciﬁc type of messages.
Fourth, among the remaining methods in MSandMT,
we further use some mapping conditions (which are ac-
tually inspired by Weißgerber and Diehl’s conditions for
local refactorings [20]) to identify one-to-one replacement
between methods that have no calling relationships with
other methods. Let us use N(m),R(m), andP(m)to
denote the name, the return type, and the parameters of
m, respectively. If there exist m1∈MSandm2∈MT
such that m1andm2are in the same class and satisfy
one of the following conditions: 1) N(m1)/ne}ationslash=N(m2)∧
R(m1) =R(m2)∧P(m1) =P(m2), 2)N(m1) =
N(m2)∧R(m1)/ne}ationslash=R(m2)∧P(m1) =P(m2), or 3)
N(m1) =N(m2)∧R(m1) =R(m2)∧P(m1)/ne}ationslash=P(m2),
we deem that there is a one-to-one rule in the form of m1
replaced by m2.
Finally, if there are still methods in MSassociated with
no change rules, we deem them as simply-deleted . Similarly,
if there are still methods in MTassociated with no change
rules, we deem them as newly-added . It should be noted
that, if a simply-deleted methodmin class Xactually
overrides another method m′deﬁned in a super class of
X, we adjust the rule for deleting mto a replacement rule
(i.e.,mreplaced by m′), because the semantics of deleting
min object orientation is to direct calls of mtom′.
C. Aggregating Change Rules
Supposing that we have nrevisions (denoted as R1,
R2,...Rn, whereR1andRnare two releases) of the frame-
work, and we have identiﬁed a set of change rules be-
tween each pair of consecutiverevisions, we aggregatethes e
change rules as follows. We aggregate rules for changing
fromR1toR2with rules for changing from R2andR3to
obtain rules for changing from R1toR3. We continue this
aggregation process until we get rules for changing from
R1toRn. For the ease of presentation, we focus on how
we aggregate change rules between R1andR2with change
rules between R2andR3below.
First, we deem either a rule for a newly-added method
or a rule for a simply-deleted rule as a rule for method
replacement. That is to say, a change rule is in the formof a set of methods (denoted S) in the predecessor revision
replaced by a set of methods(denotedas T) in the successor
revision. If Sis empty, the rule is a rule for newly-added
methods.In such a case, we break the rule into several rules,
each of which is about one newly-added method. If Tis
empty, the rule is a rule for simply-deleted methods. In such
a case, we also break the rule into several rules, each of
whichisaboutone simply-deleted method.Thus,anychange
ruleris in the form of Source(r)replaced by Target(r).
Let us denote the set of rules for changing R1toR2as
RS1→2={a1,a2,...ak}and the set of rules for changing R2
toR3asRS2→3={b1,b2,...bm}.
Second, we deem both change rules in RS1→2not related
to any change rules in RS2→3and change rules in RS2→3
not related to any change rules in RS1→2as rules for
changing from R1toR3. Change rule ainRS1→2and
change rule binRS2→3are related to each other (denoted
asRelate(a,b)), if and only if Target(a)∩Source(b)/ne}ationslash=∅.
Third, among the remaining related change rules in
RS1→2andRS2→3, we rewrite these change rules as
follows. For such a rule (denoted as a) inRS1→2, we
calculate the set of rules that are transitively related
toa. Two rules (denoted as xandy) inRS1→2∪
RS2→3are transitively related to each other (denoted
asTranRelate (x,y)), if and only if Relate(x,y)or
∃c1,c2,...cp∈RS1→2∪RS2→3,(c1=x)∧(cp=
y)∧Relate(ci,ci+1)(1≤i < p). Supposing that
the set of rules that are transitively related to ais
RS′
1→2∪RS′
2→3(whereRS′
1→2⊆RS1→2andRS′
2→3⊆
RS2→3), we have the following rule for changing from
R1toR3:/uniontext
c∈RS′
1→2Source(c)∪(/uniontext
c∈RS′
2→3Source(c)−/uniontext
c∈RS′
1→2Target(c))replaced by/uniontext
c∈RS′
2→3Target(c)∪
(/uniontext
c∈RS′
1→2Target(c)−/uniontext
c∈RS′
2→3Source(c)). We con-
tinue to rewrite the remaining rules until we have rewritten
all the change rules in RS1→2∪RS2→3.
Supposing that we have the rule of “A replaced by B1
and B2” for changing from revision R1to revision R2and
the rule of “B2 and B3 replaced by C” for changing from
revisionR2to revision R3, the preceding rule rewriting
enables us to identify the rule of “A and B3 replaced by
B1 and C” for changing from revision R1to revision R3.
Fourth, we further resolve conﬂicts between change rules.
In particular, we consider the following two cases of con-
ﬂicts. The ﬁrst case is a conﬂict between a rule for a simply-
deletedmethod and a rule for a newly-added method. This
conﬂict occurs when a method already deleted in R2is
added back in R3. For such a case, we drop both rules. The
second case is a conﬂict between a rule for a simply-deleted
method and a rule for method replacement. This conﬂict
occurs when a method is replaced by another method in R2
but still kept for backward compatibility, and the obsolete
method is deleted in R3. For such a case, we drop the rule
for thesimply-deleted method.
Finally, after we have obtained the change rules betweenTable I
BASIC INFORMATION OF THE SUBJECTS
Framework Release SizePackages Classes Methods
(KLOC)
4.1 114 28 341 3891
jEdit 4.2 141 31 394 4500
4.3 177 38 531 5868
1.1 176 51 720 5939
Struts 1.2.4 161 52 798 6070
1.2.7 157 52 777 6527
0.3 11 17 74 431
Mime4J 0.4 23 32 144 989
0.5 24 32 156 1080
R1andRn, we validate the rules against the source code
ofR1andRnin the same way as the validation of rules in
Section III-B1. Note that, as rules between some revisions
may not be fully accurate, we need to check the resulting
rules to get rid of invalid rules.
D. Implementation
We implemented our HiMaapproach as an Eclipse plug-
in for Java frameworks that use SVN as the version-control
system. As mentioned previously, HiMarelies on SVN to
locate each revision of the framework. Our implementa-
tion further utilizes features of SVN and Java to avoid
unnecessary code analysis. First, SVN enables us to focus
on only the changed ﬁles when matching two revisions.
Second, as classes in Java programs correspond to ﬁles, our
implementation directly derives information for addition or
deletion of classes when encounteringaddedor deleted ﬁles .
Furthermore, we implemented our comment analysis on top
of an open-source tool for NLP named OpenNLP5.
IV. EXPERIMENTAL STUDY
To evaluate our HiMaapproach, we conducted an ex-
perimental study on HiMa. In our experimental study, we
investigated the following two research questions.
•RQ1: How effective is our HiMaapproach in compar-
ison with existing approaches?
•RQ2: How do the four main techniques in our HiMa
approach contribute to the overall effectiveness?
The ﬁrst research question is concerned with whether
HiMais competitivewith existingapproachesto framework-
evolution identiﬁcation. The second research question is
concerned with how the main techniques in HiMaimpact
the effectiveness of HiMa.
A. Experimental Design
As there exist quite a few approaches to framework-
evolution identiﬁcation, we compared our HiMaapproach
withAURA6in our experimental study when investigating
the effectiveness of HiMa. There are mainly two reasons
for us to choose AURAfor comparison. First, AURAis a
state-of-art approach to framework-evolution identiﬁcat ion
andAURAprovides several advanced features that previous
5opennlp.sourceforge.net/projects.html, accessed in Mar ch 2012
6www.ptidej.net/downloads/experiments/icse10b, access ed in March
2012Table II
OVERALL EFFECTIVENESS
Framework& HiMa AURA
Task Ide.Cor. Pre. Ide.Cor.Pre.
jEdit&Task1 43241696.3 42031775.5
jEdit&Task2 10571043 98.7105988183.2
Struts&Task1 18418399.5 18417997.3
Struts&Task2 8484100.0 856981.2
Mime4J&Task1 20820598.6 20618488.4
Mime4J&Task2 9898100.0 988788.8
approaches do not provide (please refer to our discussion in
SectionV). Second,Wu et al. [5]haveempiricallycompared
AURAwith several existing approaches (i.e., M. Kim et al.’s
approach[17], Sch¨ afer et al.’s approach [7], and the SemDiff
approach [21]) and demonstrated the competitiveness and
even superiorness of AURA.
Inourexperimentalstudy,we usedthreeopen-sourceJava
frameworks as subjects: Struts7, jEdit8, and Mime4J9. Struts
is a framework for developing Java web applications; jEdit
is a text editor with APIs for users to develop plug-ins;
and Mime4J is a framework for developingapplications that
analyze email messages. The reasons for choosing these
three Java frameworks are as follows. First, all the three
subjects are frameworks of medium sizes, and thus it is
feasible for us to manually inspect whether each identiﬁed
rule is correct. Second, some of the subjects (e.g., jEdit an d
Struts) have been used in previous studies (e.g., M. Kim et
al. [17], Sch¨ afer et al. [7], and Wu et al. [5]), and thus it is
helpful to compare our experimental results with theirs.
For each subject, we applied HiMaandAURAfor two
tasksinvolvingthreereleases. That is to say,foreach subj ect
the ﬁrst task is based on the ﬁrst two releases and the second
task is based on the last two releases. Thus, we are able
to check whether the experimented approaches performed
consistently on each subject. For example, based on jEdit,
we formed the following two tasks for framework-evolution
identiﬁcation: from release 4.1 to release 4.2 and from
release 4.2 to release 4.3. Note that, to avoid basing our
experiments in a scenario in favor of our approach, we did
not use the task based on the ﬁrst and the third releases for
each subject. Table I depicts the basic information of the
three releases of each subject.
For each subject and each task, either HiMaorAURA
identiﬁed a set of evolution rules. As AURAidentiﬁes only
four types of rules (i.e., simply-deleted ,one-to-one ,one-to-
many, andmany-to-one ), we considered rules of only these
four types in our experimental study. We adopted a way
similar to Wu et al. [5] to determine the correctness of
identiﬁed rules. That is to say, for each set of identiﬁed
evolution rules, we manually inspected whether each rule in
the set is correct with the help of framework documentation.
In particular, the ﬁrst and the second authors of this paper
7struts.apache.org, accessed in March 2012
8www.jedit.org, accessed in March 2012
9james.apache.org/mime4j, accessed in March 2012Table III
OVERALL EFFECTIVENESS FOR DIFFERENT TYPES OF RULES
Framework& Simply-Deleted One-to-One One-to-Many Many-to-One
Task HiMa AURA HiMa AURA HiMa AURA HiMa AURA
Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.Ide.Cor.Pre.
jEdit&T1 20619293.212611591.321421299.126419072.099100.013969.233100.017317.7
jEdit&T2 16915792.91489765.588388199.888478188.411100.013215.444100.01417.1
Struts&T1 7676100.0797797.510810799.110510297.100-00-00-00-
Struts&T2 6666100.05050100.0 1818100.0351954.300-00-00-00-
Mime4J&T1 171694.114642.919118999.019117893.200-00-00-100.0
Mime4J&T2 1515100.08675.08383100.0888192.000-200.000-00-
Table IV
DETAILED COMPARISON OF IDENTIFIED RULES
Framework& HiMa&AURA OnlyHiMa OnlyAURA
Task Ide. Cor.Ide.Cor.Ide.Cor.
jEdit&Task1 310 307122109110 10
jEdit&Task2 870 869187174189 12
Struts&Task1 177 176 7773
Struts&Task2 68 68161617 1
Mime4J&Task1 187 184 212119 0
Mime4J&Task2 87 87111111 0
togetherwithanothertwostudents(notauthorsofthispape r)
participated in the manual inspection, and we ensured that
each identiﬁed rule was inspected by at least two inspectors .
In case of conﬂicts, all the related inspectors discussed fa ce
to face to resolve the conﬂicts. In our manual inspection, we
payed special attention to the rules identiﬁed by only HiMa
andtherulesidentiﬁedbyonly AURA,becausehumanerrors
made on determining the correctness of such rules would
affectHiMaandAURAdifferently. We put the detailed
information of the identiﬁed rules on our project website10.
As ourHiMaapproach contains several techniques, to
investigate how the main techniques in HiMacontribute to
itsoveralleffectiveness,wefurtherexperimentallycomp ared
ﬁve combinations of the main techniques in HiMa. That
is to say, besides HiMaitself, we also experimented with
another four combinations, each turning off one technical
component.Similar to the experimentalcomparisonbetween
HiMaandAURA, we manually inspected the correctness of
each identiﬁed rule and put the detailed information on our
project website.
We also recorded the execution time for either HiMa
orAURAto perform each task on each subject. All the
execution time is based on executing HiMaandAURAon
Windows 7 with an Intel Core i5 2.53GHz CPU and 6GB
memory. We used the execution time of HiMaandAURA
as an indicator for their performance.
B. Results and Analysis
1) RQ1: Overall Effectiveness: Table II depicts the over-
all effectiveness of HiMaandAURA. In this table, columns
2-4 depict the number of rules identiﬁed by HiMa, the
numberofcorrectrulesidentiﬁedby HiMa,andtheprecision
ofHiMain percentagepointsfor each subject and each task.
Similar to columns 2-4, columns 5-7 depict these numbers
forAURA.FromTableII,wehavethefollowingobservation.
10sourceforge.net/projects/himaFor each subject and each task, HiMaconsistently
achieves higher precision than AURAand asHiMais able
to always identify more correct evolution rules, HiMaalso
consistently achieves higher recall than AURA, although
AURAalso achieves competitive results. For example, for
the ﬁrst task on Mime4J, HiMaidentiﬁes 21 more correct
rules and achieves ten percentage points higher in precisio n
thanAURA. Note that, as we do not know the exact number
of correct evolution rules in total for each of the six tasks,
we are not able to calculate the exact recall values for HiMa
andAURA.
We further compare the overall effectiveness of HiMa
andAURAin terms of each rule type in Table III. Similar
to Table II, columns headed by “ Ide.” depict the numbers
of identiﬁed rules, columns headed by “ Cor.” depict the
numbers of correctly identiﬁed rules, and columns headed
by “Pre.” depictthe valuesof precision in percentagepoints.
From Table III, we have the following observations.
First,thetrendofoveralleffectivenessof HiMaandAURA
in terms of each rule type is similar to the trend of overall
effectiveness for all types. That is to say, HiMaachieves
both precision and recall no less than AURAfor all circum-
stances. This observation demonstrates HiMa’s consistent
superiorness over AURAfor each rule type. Furthermore,
HiManever achieves poor precision for any circumstances,
while there are some circumstances for AURAto perform
unsatisfactorily (e.g., the second task for AURAto identify
one-to-one rules for Struts and the ﬁrst task for AURAto
identify rules of simply-deleted methods for Mime4J). It
should be noted that there are 10 correct rules (i.e., 7 in the
second task for jEdit and 3 in the ﬁrst task for Struts) that
HiMaandAURAidentiﬁed as different types. The reason is
thatHiMadeems the deletion of an overridden method in a
class as redirecting calls to a method in a superclass.
Second, neither HiManorAURAidentiﬁes many rules for
one-to-many ormany-to-one replacement. We suspect the
reason to be that frameworksare not commonto evolvewith
one-to-many ormany-to-one replacement. However, iden-
tiﬁng rules for one-to-many andmany-to-one replacement
may still be important, because migration tasks concerned
withAPIsinvolvedin one-to-many andmany-to-one replace-
ment may be more difﬁcult than other migration tasks.
Typically, there are some rules that can be identiﬁed
by both HiMaandAURA. To analyze the relationshipsTable V
CONTRIBUTIONS OF THE MAIN TECHNIQUES TO THE OVERALL EFFECTIV ENESS
Framework& Without Comment Without Caller Without Callee Without Mapping HiMa(ALL)
Task Ide.Cor. Pre. Ide.Cor. Pre. Ide.Cor.Pre. Ide.Cor. Pre. Ide.Cor. Pre.
jEdit&Task1 43238488.9 43632273.9 43240293.1 43240293.1 43241696.3
jEdit&Task2 10571042 98.6105792987.9105785981.3105799594.110571043 98.7
Struts&Task1 18417394.0 18418298.9 18418399.5 18418399.5 18418399.5
Struts&Task2 8484100.0 8484100.0 846678.6 8484100.0 8484100.0
Mime4J&Task1 20820297.1 20819392.8 20818990.9 20820598.6 20820598.6
Mime4J&Task2 989799.0 989698.0 989799.0 9898100.0 9898100.0
between rules identiﬁed by HiMaand rules identiﬁed by
AURA, we further provide a detailed comparison of rules
identiﬁed by HiMaandAURAin Table IV. In this table,
for each subject and each task, columns 2-3 depict the
number of rules identiﬁed by both HiMaandAURA, and the
numberof correct rulesamongthem; columns4-7 depict the
information for rules identiﬁed by only HiMabut notAURA
and rules identiﬁed by only AURAbut notHiMa. Here, we
deem the 10 correct rules that HiMaandAURAclassiﬁed
into different types as correctly identiﬁed by both HiMaand
AURA. From Table IV, we have the following observations.
First, the majority of correct rules can actually be iden-
tiﬁed by both HiMaandAURA. This observation thus
conﬁrms the effectiveness of both approaches. Second, very
few correct rules are identiﬁed by AURAbut not by HiMa,
while there are quite some correct rules identiﬁed by HiMa
but not by AURA. This observation indicates that, although
HiMaandAURAcan complement each other in practice,
HiMashould be preferred if only one approach can be used.
2) RQ2: Contributions of the Four Main Techniques: To
compare the ﬁve combinations of the four main techniques
in ourHiMaapproach, each column in Table V depicts
the results of one combination. For example, “Without
Comment” denotes HiMawithout using comment analysis
and “HiMa(ALL)” denotes HiMaitself. From Table V, we
have the following observation concerning the contributio ns
of the main techniques in our HiMaapproach.
HiMawithout using either comment analysis ,callee anal-
ysis,caller analysis , ormapping conditions would typically
identify fewer evolutionrules that can be correctlyidenti ﬁed
byHiMausing all the techniques in some circumstances.
This observation indicates that all of the techniquesin HiMa
are useful. Furthermore, as turning off any of the four
techniques in HiMamay not always result in signiﬁcant
decrease in the number of correctly identiﬁed evolution
rules, the effects of the four techniques may somehow
overlap with each other for a speciﬁc framework.
It should be noted that the need for using all the four
techniques in HiMaactually lies in the way for HiMato use
them. As HiMauses all the four techniques to match each
pair of consecutive revisions, slight loss in accuracy indu ced
in matching some pair of revisions may affect the overall
effectiveness.Thus,it is preferableforusto employmulti ple
techniques to identify as many correct rules as possible for
each pair of revisions. Supposing that we have one rule forTable VI
EXECUTION TIME (IN MINUTES )
Framework Task 1 Task 2
#Rev. HiMa AURA #Rev. HiMa AURA
jEdit 58688.89 0.612672208.06 1.81
Struts 1074156.62 1.48 415100.88 0.76
Mime4J 18526.88 0.44 252.70 0.34
changing revision R1to revision R2in the form of “method
A replaced by method B” and one rule for changingrevision
R2to revision R3in the form of “method B replaced by
method C”, failure to identify either of the two rules would
result in failure to identify the rule “method A replaced by
method C” for changing revision R1to revision R3.
C. Performance
Table VI lists the execution time of HiMaandAURAfor
thesixtasks.Columnsheadedby“ #Rev.”depictthenumbers
of pairs of revisions used by HiMa. From this table, we can
observe that the execution time of HiMais always much
longer than that of AURA. In particular, HiMais typically
100-150 times more costly than AURAcomputationally. We
suspect the reason to be that HiManeeds to analyze too
much more revisions than AURA. For example, for the
ﬁrst task on jEdit, HiMaanalyzed 586 pairs of revisions
butAURAanalyzed only one pair of revisions. As the
aim of framework-evolution identiﬁcation is to facilitate
the migration of client code and one framework may have
a large number of clients, the extra computational cost
ofHiMawould not be a big burden for its application.
Furthermore, as the execution time of HiMamay be more
sensitive to the number of revisions, HiMamay not be
signiﬁcantly less scalable than AURAin response to the
increaseof the frameworksize. Of course,moreexperiments
on large frameworks are necessary to further investigate
HiMa’s scalability.
D. Threats to Validity
1) Construct Validity: Threats to construct validity are
concerned with whether the measurement in the study re-
ﬂects real-world situations. The main threat to construct
validity in our study is the way of validating identiﬁed rule s.
Asweadoptedamanualprocesstocheckwhethereachiden-
tiﬁed rule to be correct, errors made in this manual process
would bias our experimental results. To reduce this threat,
four human inspectors carefully determined the correctnes s
oftheidentiﬁedrulesensuringeachruleinspectedbyatlea st
two inspectors. Note that existing studies (e.g., M. Kim etal. [17], Sch¨ afer et al. [7], and Wu et al. [5]) typically ado pt
manual inspection of identiﬁed rules to evaluate approache s
to framework-evolution identiﬁcation.
2) Internal Validity: Threats to internal validity are con-
cerned with the uncontrolled factors that may also be
responsible for the experimental results. In our study, the
main threat to internal validity is the possible faults in th e
implementation of our approach. To reduce this threat, we
reviewed all the code before conducting the study.
3) External Validity: Threats to external validity are
concerned with whether the experimental results are gener-
alizable for other situations. In our study, the main threat
to external validity lies in the representativeness of our
subjects. To reduce this threat, we chose three subjects
(including two subjects used in previous research [17], [5] ).
However, as we experimented with frameworks written in
only Java using only SVN as the version-control system,
our experimental results may be speciﬁc to Java and SVN.
Further reduction of this threat may require evaluation of
our approach on frameworks written in other languages
using other version-control systems. Note that our approac h
requires the version-control system to support locating ea ch
framework revision.
V. DISCUSSION
In this section, we discuss the following issues related
to ourHiMaapproach: the strength and weakness of using
revisions and comments, the ability to identify plentiful
types of rules, the ability to avoid thresholds, and the need
to assist client migration.
Use ofrevisionsand comments .Themainstrengthofus-
ing revisions is that the differencesbetween two consecuti ve
revisions are much smaller than the differencesbetween two
releases. Thus, rule identiﬁcation between two consecutiv e
revisions could be more accurate than rule identiﬁcation
between two releases. The main strength of using comments
isthattheinformationincommentsisorthogonaltoinforma -
tion in source code. Thus, conceding NLP’s inaccuracy, we
are ableto use sourcecodeofrevisionsto validate andreﬁne
raw rules identiﬁed from comments. The main weakness
of using revisions and comments is that the abundance of
information may incur too much computational cost to use
deep code analysis. However, our empirical results indicat e
that shallow analysis on abundance of information may still
be superior to deep analysis on scarceness of information.
Automatic identiﬁcation of plentiful types of rules .
In the literature, researchers (e.g., Wu et al. [5]) have
demonstrated that it is necessary to automatically identif y
the four types(i.e., simply-deleted ,one-to-one ,one-to-many ,
andmany-to-one ) of evolution rules. In fact, AURAis the
ﬁrst approach that satisﬁes this requirement. Our HiMa
approach is able to not only satisfy this requirement but
also outperform AURAfor each type of rules. In fact, HiMa
can also identify many-to-many rules, which AURAcannot
identify.Avoiding threshold tuning . According to Wu et al. [5],
not using thresholds is also a key feature of approaches
to framework-evolution identiﬁcation, because the use of
thresholds implies tedious tuning for different contexts.
Among all the existing automatic matching-based ap-
proaches, AURAis the only approach that does not use any
threshold. In particular, AURAemploys a procedure to cal-
culate the conﬁdence of each identiﬁed rule and keeps only
rules with 100% conﬁdence. Unlike AURA, as differences
between two consecutive revisions are very small, HiMais
able to naturally avoid using any threshold by just keeping
rules that satisfy our strict criteria.
Assisting client migration . It should be noted that the
ﬁnal goal of framework-evolution identiﬁcation is to auto-
mate the migration of client code. To achieve this goal, it
is necessary to further identify framework-evolution-rel ated
usage patterns. In fact, Zhong et al. [34] and Nyuyen et
al. [14] have investigated techniques that may help obtain
such patterns.
VI. CONCLUSION AND FUTUREWORK
In this paper, we have proposed a novel approach named
HiMato identiﬁcation of framework evolution. The dis-
tinctive feature of our HiMaapproach is to match each
pair of consecutive revisions in the evolution history of
the framework and aggregate revision-level rules to form
evolution rules between the two releases. To evaluate our
HiMaapproach,we empiricallycompared HiMawithAURA
using three Java frameworks as subjects. Our empirical
results indicate that, for both precision and recall, HiMais
superiorto AURAinmostcircumstancesandisneverinferior
toAURAin any circumstances. Due to the use of a large
number of revisions, HiMais computationally more costly
thanAURA. However, the higher cost in computation would
not be an inhibitive factor for the application of HiMa.
Infuturework,weplantoinvestigatethefollowingissues.
First, we plan to implement HiMafor other languages and
other version-control systems, and conduct further exper-
iments to address the main threats to the validity of our
experimentalstudy. Second, as client code providesa sourc e
of information not utilized in our approach, we plan to
incorporate analysis of client code into our approach to
further improve the accuracy of our approach. Finally, we
plan to further investigate optimization of the matching
between each pair of revisions so as to incorporate deeper
analysis for higher accuracy.
ACKNOWLEDGMENTS
This research is sponsored by the National 973 Program
of China No. 2009CB320703 and the Science Fund for
CreativeResearchGroupsofChinaNo.61121063.We thank
the authors of AURAfor providing their implementation of
AURApublicly. We thank Mr. Chun Zhang for his valuable
suggestions for this research, and Mr. Tian Lan and Mr.
Muyao Zhu for their assistance in our empirical evaluation.REFERENCES
[1] K. Chow and D. Notkin, “Semi-automatic update of applica -
tions in response to library changes,” in Proc. ICSM , 1996,
pp. 359–368.
[2] P. Steyaert, C. Lucas, K. Mens, and T. D’Hondt, “Reuse
contracts: Managing theevolutionofreusable assets,”in Proc.
OOPSLA, 1996, pp. 268–285.
[3] I. Balaban, F. Tip, and R. Fuhrer, “Refactoring support f or
class library migration,” in Proc. OOPSLA , 2005, pp. 265–
279.
[4] D. Dig and R. Johnson, “How do APIs evolve? A story of
refactoring,” JSME, vol. 18, no. 2, pp. 83–107, March 2006.
[5] W. Wu, Y. Gu´ eh´ eneuc, G. Antoniol, and M. Kim, “AURA:
A hybrid approach to identify framework evolution,” in Proc.
ICSE, 2010, pp. 325–334.
[6] J. Henkel and A. Diwan, “Catchup!: Capturing and replayi ng
refactorings to support API evolution,” in Proc. ICSE , 2005,
pp. 274–283.
[7] T. Sch¨ afer, J. Jonas, and M. Mezini, “Mining framework
usage changes from instantiation code,” in Proc. ICSE , 2008,
pp. 471–480.
[8] D. Dig, K. Manzoor, R. Johnson, and T. N. Nguyen,
“Refactoring-aware conﬁguration management for object-
oriented programs,” in Proc. ICSE , 2007, pp. 427–436.
[9] C. Kemper and C. Overbeck, “What’s new with JBuilder,” in
Proc. JavaOne , 2005.
[10] G. Malpohl, J. J. Hunt, and W. F. Tichy, “Renaming detec-
tion,”ASEJ, vol. 10, no. 2, pp. 183–202, April 2003.
[11] M. W. Godfrey and L. Zou, “Using origin analysis to detec t
merging and splitting of source code entities,” IEEE TSE ,
vol. 31, no. 2, pp. 166–181, February 2005.
[12] S. Kim, K. Pan, and E. J. Whitehead, Jr., “When functions
change their names: Automatic detection of origin relation -
ships,” in Proc. WCRE , 2005, pp. 143–152.
[13] D. Dig, C. Comertoglu, D. Marinov, and R. Johnson, “Auto -
mated detection of refactorings in evolving components,” i n
Proc. ECOOP , 2006, pp. 404–428.
[14] H. A. Nguyen, T. T. Nguyen, G. Wilson, Jr., A. T. Nguyen,
M. Kim, and T. N. Nguyen, “A graph-based approach to API
usage adaptation,” in Proc. OOPSLA , 2010, pp. 302–321.
[15] G. Antoniol, M. D. Penta, and E. Merlo, “An automatic
approach to identify class evolution discontinuities,” in Proc.
IWPSE, 2004, pp. 31–40.
[16] Z. Xing and E. Stroulia, “API-evolution support with Di ff-
CatchUp,” IEEETSE ,vol. 33, no. 12, pp. 818–836, December
2007.
[17] M. Kim, D. Notkin, and D. Grossman, “Automatic inferenc e
of structural changes for matching across program versions ,”
inProc. ICSE , 2007, pp. 333–343.[18] K. Taneja, D. Dig, and T. Xie, “Automated detection of AP I
refactorings in libraries,” in Proc. ASE , 2007, pp. 377–380.
[19] S. Demeyer, S. Ducasse, and O. Nierstrasz, “Finding ref actor-
ings via change metrics,” in Proc. OOPSLA , 2000, pp. 166–
177.
[20] P. Weißgerber and S. Diehl, “Identifying refactorings from
source-code changes,” in Proc. ASE , 2006, pp. 231–240.
[21] B. Dagenais and M. P. Robillard, “Recommending adaptiv e
changes for framework evolution,” in Proc. ICSE , 2008, pp.
481–490.
[22] S. Thummalapenta and T. Xie, “SpotWeb: Detecting frame -
work hotspots and coldspots via mining open source code on
the web,” in Proc. ASE , 2008, pp. 327–336.
[23] P. Sawyer, P. Rayson, and R. Garside, “REVERE: Support
for requirements synthesis from documents,” Information
Systems Frontiers , vol. 4, no. 3, pp. 343–353, March 2002.
[24] M. Asahara and Y. Matsumoto, “Extended models and tools
for high-performance part-of-speech,” in Proc. COLING ,
2000, pp. 21–27.
[25] A.Fantechi,S.Gnesi,G.Lami,andA.Maccari,“Applica tions
of linguistic techniques for use case analysis,” Requirement
Engineering , vol. 8, no. 3, pp. 161–170, March 2003.
[26] M. J. Collins and T. Koo, “Discriminative reranking for
natural language parsing,” Computational Linguistics , vol. 31,
no. 1, pp. 25–70, March 2005.
[27] L. Kof, “Scenarios: Identifying missing objects and ac tions
by means of computational linguistics,” in Proc. RE , 2007,
pp. 121–130.
[28] D. Shepherd, Z. Fry, E. Hill, L. Pollock, and K. Vijay-
Shanker, “Using natural language program analysis to locat e
and understand action-oriented concerns,” in Proc. AOSD ,
2007, pp. 212–224.
[29] L. Tan, D. Yuan, G. Krishna, and Y. Zhou, “/* iComment:
Bugs or bad comments? */,” in Proc. SOSP , 2007, pp. 145–
158.
[30] L. Tan, Y. Zhou, and Y. Padioleau, “aComment: Mining
annotations from comments and code to detect interrupt
related concurrency bugs,” in Proc. ICSE , 2011, pp. 11–20.
[31] H. Zhong, L. Zhang, T. Xie, and H. Mei, “Inferring resour ce
speciﬁcations from natural language API documentation,” i n
Proc. ASE , 2009, pp. 307–318.
[32] Z. Kozareva, ´O. Ferr´ andez, A. Montoyo, R. Mu˜ noz,
A. Su´ arez, and J. G´ omez, “Combining data-driven systems
for improving named entity recognition,” DKE, vol. 61, no. 3,
pp. 449–466, June 2007.
[33] S. L. Abebe and P. Tonella, “Natural language parsing of
program element names for concept extraction,” in Proc.
ICPC, 2010, pp. 156–159.
[34] H.Zhong, S.Thummalapenta, T.Xie,L.Zhang,andQ.Wang ,
“Mining API mapping for language migration,” in Proc.
ICSE, 2010, pp. 195–204.