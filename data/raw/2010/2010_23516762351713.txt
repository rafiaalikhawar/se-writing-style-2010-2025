Slicing and Replaying Code Change History
Katsuhisa Maruyama1, Eijiro Kitsu2, Takayuki Omori1, Shinpei Hayashi3
1Department of Computer Science, Ritsumeikan University, Japan
2Graduate School of Science and Engineering, Ritsumeikan University, Japan
3Department of Computer Science, Tokyo Institute of Technology, Japan
maru@cs.ritsumei.ac.jp, {kitsu, takayuki}@fse.cs.ritsumei.ac.jp,
hayashi@se.cs.titech.ac.jp
ABSTRACT
Change-aware development environments have recently become fea-
sible and reasonable. These environments can automatically recordﬁne-grained code changes on a program and allow programmers toreplay the recorded changes in chronological order. However, they
do not always need to replay all the code changes to investigate
how a particular entity of the program has been changed. There-fore, they often skip several code changes of no interest. This skip-ping action is an obstacle that makes many programmers hesitate inusing existing replaying tools. This paper proposes a slicing mech-
anism that can extract only code changes necessary to construct a
particular class member of a Java program from the whole historyof past code changes. In this mechanism, ﬁne-grained code changesare represented by edit operations recorded on source code of a pro-gram. The paper also presents a running tool that implements theproposed slicing and replays its resulting slices. With this tool,
programmers can avoid replaying edit operations nonessential to
the construction of class members they want to understand.
Categories and Subject Descriptors
D.2.6 [ Programming Environments ]: Integrated environments;
D.2.7 [ Distribution, Maintenance, and Enhancement ]: Version
control; D.2.3 [ Coding Tools and Techniques ]: Program editors
General Terms
Algorithms, Human Factors
Keywords
Software maintenance and evolution, Program comprehension, Pro-
gram slicing, Code change, Integrated development environments
1. INTRODUCTION
In software maintenance, many programmers (mainly maintain-
ers) must often understand existing source code that someone elsehas written or modiﬁed before [ 12]. To make such understanding
easier, change-based support has recently become popular [3,9]. In
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for proﬁt or c ommercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, torepublish, to post on servers or to redist ribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE ’12, September 3-7, 2012, Essen, Germany
Copyright 2012 ACM 978-1- 4503-1204-2/12/ 09 ...$15.00.general, programmers do not only concentrate on examining source
code but would look at its time-series data such as a chronologicalsequence of its snapshots. This enables them to obtain knowledgeof how the source code has been ever changed. For example, Spy-Ware [10], Syde [7], and OperationRecorder [8] are embedded intomodern integrated development environments (IDEs) and capture
all ﬁne-grained code changes performed on the editors provided
by their respective IDEs. In addition, these recording tools col-laborate with tools visualizing, ﬁltering, and/or replaying recordedcode changes.
Using these tools helps programmers keep track of ﬁne-grained
code changes individually stored in the repository. In particular,
a replaying tool can reenact past programming scenes in front of
programmers’ faces. This makes them to image what other pro-grammers have gone through in the past. Moreover, the historyof past code changes provides hints at programmers’ understand-ing how to revert undesired code changes based on their decisions
made in the past. For example, a controlled experiment conducted
by Hattori et al. [6] demonstrated that chronologically replaying ofﬁne-grained code changes outperforms existing commit-based ver-sioning systems on helping programmers ﬁnd answers to questionsrelated to software evolution.
Although chronologically replaying of ﬁne-grained code changes
of a program is useful for understanding its evolution, we empha-
size the possibility of improvement in assistance for replaying. Ingeneral, replaying is a time-consuming task. If huge amount ofcode changes were recorded, it takes a long time to replay everychange. In most cases, programmers do not need to investigate thewhole evolution of source code. They incrementally obtain knowl-
edge on past code changes by partially replaying the code changes
depending on their interests. To encourage programmers to exploitexisting replaying tools, automatic extraction of code changes tobe replayed is required. This helps them efﬁciently understand theevolution of a particular part of source code. Here, careful read-ers might think that edit operations not related to a program entity
of interest can be ﬁltered out by checking its name. Unfortunately,
simple ﬁltering provided by the conventional tools does not addressﬁne-grained tracking of code changes resulting from the renaming,splitting, or merging of program entitie s (e.g., methods of a Java
program), or the moving or copying of part of their bodies through
a cut-paste or copy-paste action.
This paper proposes a mechanism that automatically extracts a
collection of ﬁne-grained code changes all of which may be relatedto a particular program entity from the recorded change history.This mechanism is inspired by the concept of program slicing [13].Program slicing is used to extract from code of a program a set
of statements that may affect (the calculation of) the value of a
variable of interest at a speciﬁed program point. Here, the princi-Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
246
pal concern is simpliﬁcation when slicing to assist program com-
prehension [5] although much of application of slicing has been
provided. Our idea exploits this simpliﬁcation power of slicing inreplaying past code changes.
In the mechanism, ﬁne-grained code changes are represented by
edit operations on source code of a Java program. Moreover, a spe-cial graph, called an edit operation graph (OpG hereafter), is in-
troduced. It links class members (methods and ﬁelds) within snap-
shots of program code via edit operations performed on their re-spective snapshots. By traversing vertices and edges of an OpG, themechanism can extract only edit operations necessary to construct(create, remove, and modify) a class member of interest from thehistory consisting of all recorded edit operations. Such extraction
process and a collection of the extracted edit operations are called
anoperation history slicing and an operation history slice , respec-
tively. This paper also presents a running tool,
OperationSliceRe-
player , which implements operation history slicing and replays its
resulting slices.
The important feature of the proposed slicing is that the contents
restored by replaying only edit operations included in an operation
slice for a target class member on an arbitrary snapshot of sourcecode are likely to be always the same as the original contents of thetarget class member. Due to this feature, if a programmer wants tounderstand a particular class member in his/her task, only edit oper-ations included in its operation history slice would be replayed. In
other words, programmers can avoid any nonessential action skip-
ping edit operations of class members they have no interest in. Con-sequently,
OperationSliceReplayer has the potential to make their
program understanding tasks more efﬁcient.
2. OPERATION HISTORY SLICING
It is obviously assumed that all edit operations with respect to
manual and automatic code changes performed on the editor are
completely collected. We adopt OperationRecorder [8] as a record-
ing tool, which can automatically record edit operations that affectsource code in Eclipse’s Java editor. The operations include man-ual typing (insertion, deletion, and replacement of a text), editingvia a clipboard (copy, cut, and paste of a text), undo/redo actions,
and code changes by automatic transformation (code completion,
quick ﬁx, formatting, and refactoring).
1
This section ﬁrst describes a graph that represents relationships
among class members of source code and recorded edit operations,and then deﬁnes operation history slicing using this graph.
2.1 Edit Operation Graph
To collect all edit operations constructing a particular class mem-
ber of source code without omission, it is necessary to formulate therelationships between edit operations and code fragments affectedby them. An edit operation graph (OpG) is a multipartite graph that
indicates which edit operation affects the code fragment(s) within
a target class member.
In this paper, S
0indicates the initial snapshot of (the contents of)
the source code that an edit operation was never performed on. Thesubscript number is incremented by one once each edit operation isapplied. Here, p
idenotes the i-th edit operation, and Siindicates
the snapshot of the source code generated immediately after piwas
applied to its precedent snapshot ( Si−1). In other words, Sican be
obtained after all edit operations between p1andpiare chronolog-
ically applied to S0. Moreover, a snapshot consisting of only code
fragments with no syntax error is called a parseable one.
1The current version of OperationRecorder excludes recording of
actions related to ﬁle renaming and removing.LetM(Si)be a set of all class members (methods and ﬁelds)
within a parseable snapshot Si. If the contents of Siis not parseable,
M(Si)is empty ( M(Si)=∅).Vis a set that collects both all ver-
tices for class members within every snapshot and all vertices forevery edit operation. Vis deﬁned as follows:
V={v.m|m∈M(S
i)∧0≤i≤z}∪
{v.p|p=pi∧1≤i≤z}.
Theiis the index number represents a subscript of a snapshot or an
edit operation. The zis the index number represents a subscript of
the latest snapshot Szand one of the latest edit operation pz.T h e
v.m denotes a vertex corresponding to the class member m,a n d
thev.pdenotes a vertex corresponding to the edit operation p.
Next consider edges which link between two vertices included in
V. We ﬁrst deﬁne two adjacent snapshots SiandSj(i<j ) both
of which are parseable. There is no parseable snapshot Skthat
satisﬁes i<k<j since SiandSjare adjacent. To be precise,
there is no snapshot Skbetween SiandSjunder j=i+1or every
snapshot Skthat satisﬁes i<k<j is not parseable. Edges of an
OpG are divided into the following four types.
(a) Let pk(i<k≤j) be one of edit operations that change Si
intoSj.I fpkis an edit operation and its inserted or deleted
text contains any code fragment included in a class member
mwithin Si,pkcan be considered to affect mbackwards.
Ifpkis a copy operation and its copied text is (partially)
extracted from m,pkcan be also considered to affect m.
In these cases, v.m (∈V)a n d v.pk(∈V) are linked by a
backward-change edgev.m→bv.pkin the OpG G.
(b) Consider pkunder the same situation as the aforementioned
(a). If the inserted or deleted text of an edit operation pk
contains any code fragment included in a class member m
within Sj,pkcan be considered to affect mforwards. In this
case, v.pk(∈V)a n d v.m (∈V)a r el i n k e db ya forward-
change edgev.pk→fv.m in the OpG G.
(c) Consider a situation that the contents of a class member m
within Siremains in a class member m/primewithin Sjwithout
any change. If mhas no forward-change edge, m/primehas no
backward-change edge, and the full names of mandm/primeare
the same, v.m (∈V)a n d v.m/prime(∈V)a r el i n k e db ya no-
change (unchanged) edge v.m→nv.m/primein the OpG G.
The full name is a unique identiﬁable name constructed byconcatenating the fully qualiﬁed name of a class, a specialcharacter “
#”, and the signature of a method or the name of
a ﬁeld. For example, “ fqn#sig ”a n d“ fqn#vn ”a r et h ef u l l
names for a method with the signature “ sig”a n daﬁ e l dw i t h
the variable name “ vn” of a class “ fqn”, respectively.
(d) Let pxbe a cut or copy operation that inserts any text into a
clipboard from a snapshot Sx−1,a n dpybe a paste operation
that inserts the text stored in the clipboard into a snapshotS
y.Sx−1andSymay be adjacent or may not. If the deleted
or copied text of pxis equal to the inserted text of py,a n d
neither cut nor copy operation was performed between px
andpy,v.pi(∈V)a n d v.pj(∈V) are linked by a ccp-
change (cut-copy-paste) edge v.pi→cv.pjin the OpG G.
Eis a set of all edges that satisfy one of the above four types
of edges ( →b,→f,→n,o r→c). An OpG is a directed graph
consisting of a set of vertices ( V) and a set of directed edges ( E),
which is represented by G=(V,E).
Figure 1 depicts part of an OpG representing the construction of
a sample Java program with 26 lines of code. The OpG contains all247Figure 1: Part of an operation history graph (OpG). The whole OpG consists of 239 vertices and 243 edges.
65 edit operations performed during the construction and all class
members appearing in its snapshots. Each triangle indicates a ver-
tex corresponding to an edit operation. For example, p30,p31,p45,
p46,a n d p47are normal edit operations. Moreover, p28is a copy
operation and p29is a paste operation. Each oval indicates a vertex
corresponding to a class member. A dotted rectangle indicates asnapshot that a class member belongs to. Arrows marked with thelabels
b,f,n,a n d cindicate the four types of edges: a backward-
change edge, a forward-change edge, a no-change edge, and a ccp-
change edge, respectively.
To detect backward-change and forward-change edges between
an edit operation and a class member of an OpG, their offset val-ues are compared. The offset value is stored into information oneach edit operation, which locates the starting point of its inserted,
deleted, or copied text. In this detection, several offset values would
be adjusted according as the length of the inserted or deleted text oftheir neighboring edit-operations. For example, for the OpG shownin Figure 1, S
44andS47are adjacent parseable snapshots (i.e., S45
andS46are not parseable). Thus, the offset values of p45,p46,
andp47between S44andS47are candidates to be adjusted. In
fact, the offset value of p46was adjusted. After the detection of all
backward-change and forward-change edges, no-change and ccp-change edges will be detected. These edges can be easily detected.For example, p
28andp29can be linked via a ccp-change edge.
2.2 Operation History Slice
By traversing vertices and edges of an OpG, the proposed mech-
anism can extract edit operations necessary to construct a classmember of interest from the history consisting of all edit opera-tions. Here, G
Sis an OpG for source code S.L e tR(GS,v. m )be
a set of vertices of GSthat reach a vertex v.m corresponding to a
class member mwithin a snapshot of S.
R(GS,v. m )={u∈V(GS)|u→∗v.m}.
V(GS)is a set of all vertices of GS. The relation →∗means the
reﬂexive and transitive closure of the relation →, which indicates
one of the four types of edges ( →b,→f,→n,o r→c)o fGS.
Here, there exists sometime an edit operation having no forward-
change edge in the OpG. For example, this occurs when an editoperation deletes or cuts the whole contents of a method or a ﬁeld.Since such edit operation will be properly replayed, R
/prime(GS,v. m )
was newly derived from R(GS,v. m ).R/prime(GS,v. m )=R(GS,v. m )∪
{w∈V(GS)|u→bw∧u∈R(GS,v. m )}.
A reachable set of edit operations Op(GS,v. m )is deﬁned as
follows:
Op(GS,v. m )={u∈Vp(GS)|u∈R/prime(GS,v. m )}.
Vp(GS)is a set of vertices with respect to all edit operations.
Next consider a sequence of edit operations to be replayed. Let
Q(S)be a sequence that lists all edit operations for S.
Q(S)=/angbracketleftp1, ..., p z/angbracketright.
For every recorded edit operation, p1is the ﬁrst (earliest) one
andpzare the last (latest) one. The above sequence is drawn up
in their chronological order. In other words, the time when piwas
performed is earlier than or equal to the time when pj(i<j )
was done.2In case that there exists only one edit operation for S,
Q(S)=/angbracketleftp1/angbracketright.
An operation slice Sq(S, m )is a minimal sub-sequence of Q(S)
that satisﬁes the following condition:
∀v.pk∈Op(GS,v. m )[pk∈Sq(S, m )∧
Sp(S, m )/subsetsqequalQ(S)∧#Op(GS,v. m )=# Sq(S, m )].
Q1/subsetsqequalQ2means that Q1is a sub-sequence of Q2.#Op(GS,v. m )
indicates the number of elements included in Op(GS,v. m )and
#Sq(S, m )indicates the number of elements included in Sq(S, m ).
These numbers are always equal. The mis a slicing criterion that
denotes a class member of interest within a snapshot S.
The snapshot S65(the ﬁnal code) for the OpG shown in Fig-
ure 1 has eight class members (three ﬁelds and ﬁve methods). For a
method setX() within S65, its operation history slice is as follows:
Sq(G,setX@ S65)=/angbracketleft13,14,15,16,17,18,19,20,28,60,61/angbracketright.
The slice contains 11 edit operations. Thus, its ratio to the total
number of the recorded edit operations is 16.9% ( =1 1/65).
Figure 2 shows the screenshot of the OperationSliceReplayer per-
spective in Eclipse. OperationSliceReplayer chronologically restores
2If two edit operations are performed at the same time, their
chronological order is not uniquely determined. Although this hap-pens, OperationRecorder suitably orders and records them.248Figure 2: OperationSliceReplayer perspective in Eclipse.
the contents of a source ﬁle of interest and presents an animated
movie tracking its changes, on the left view of the perspective.
When a programmer wants to see the growth of a particular classmember, he/she can activate a slicing menu presenting all classmembers existing in currently restored source code. If it is notparseable,
OperationSliceReplayer tries to ﬁnd an immediately prece-
dent parseable snapshot and presents its class members. Recorded
edit operations are listed on the right view. In this view, edit op-
erations included in the operation history slice are displayed in theblack, and ones not included in the slice are displayed in the grey.He/She can replay one-by-one (plus rewind and fast-forward) thewhole history of the recorded edit operations, and also skip unnec-
essary edit operations by pushing each of the replay buttons.
3. RELATED WORK
Obviously, our goal is in agreement with that of the study by
Hattori et al. [6,7], and the concept of operation history slicing canbe applied to their replaying tool.
Regarding the change relation and its graph representation, a few
challenges are closely related to our study. Alam et al. [1] pro-posed the concept of a time dependence relation between two struc-tural changes on source code, which indicates that one change to asource code entity follows (depends on) another change. In addi-tion, a change impact graph (CIG) [4] or a genealogy of changes [2]
is based on the concept almost the same as the time dependence.
They all represent information on the temporal dependence be-tween code changes. From this point of view, our OpG can beconsidered a variant of the aforementioned graphs. A big differ-ence is what is the unit of code change. The OpG represents a
dependence relation between ﬁner-grained and more accurate code
changes, which is built by using the offset-level mapping instead ofthe entity-level mapping.
History slicing [11] is the closest study. It extracts a set of lines
of code of interest from its whole history. The concept of the his-tory slicing and that of our operation history slicing are the same
but their mechanisms are vastly different. Our operation history
slicing uses the OpG built by offset-level mapping instead of thehistory graph built by line-level mapping. As a result, the historyslice is simply a set of lines of code, whereas the operation historyslice is a set of edit operations each of which contains informationon past code addition and/or deletion. In other words, our slice is
applied to code as an edit script and then can be replayed.4. CONCLUSION
Replaying past edit operations for source code is useful for un-
derstanding its growth but is often a time-consuming task. This pa-
per has presented a mechanism of operation history slicing that can
automatically eliminate nonessential skipping of edit operations forclass members of no interest. We have still no ﬁrm evidence forthe beneﬁts of its use during program comprehension. To checkwhether operation history slicing can reduce program comprehen-sion effort, we must make a large number of comparative experi-
ments with and without introducing this slice.
The development of
OperationSliceReplayer is continuing. Two
immediate issues mainly remain in its enhancement. It currentlytreats inner classes as a part of class members (methods to be ex-act) including these classes. To se parate such classes from their
respective outer class members, nesting offset ranges of class mem-
bers and classes enclosed by them is considered. Moreover,
Opera-
tionSliceReplayer should support renaming of classes. The current
implementation cannot detect non-change edges in this situation.
5. ACKNOWLEDGMENTS
This work was partially sponsored by the Grant-in-Aid for Sci-
entiﬁc Research (23700030, 24500050, 24700034) from the Japan
Society for the Promotion of Science (JSPS).
6. REFERENCES
[1] O. Alam, B. Adams, and A. E. Hassan. Measuring the
progress of projects using the time dependence of code
changes. In Proc. ICSM’09 , pages 329–338, 2009.
[2] I. I. Brudaru and A. Zeller. What is the long-term impact of
changes? In Proc. RSSE’08 , pages 30–32, 2008.
[3] P. Ebraert, J. Vallejos, P. Costanza, E. V . Paesschen, and
T. D’Hondt. Change-oriented software engineering. In Proc.
ICDL’07 , pages 3–24, 2007.
[4] D. M. German, G. Robles, and A. E. Hassan. Change impact
graphs: Determining the impact of prior code changes. InProc. SCAM’08 , pages 184–193, 2008.
[5] M. Harman, S. Danicic, and Y . Sivagurunathan. Program
comprehension assisted by slicing and transformation. In UK
Program Comprehension Workshop . Durham Univ., 1995.
[6] L. Hattori, M. D’Ambros, M. Lanza, and M. Lungu.
Software evolution comprehension: Replay to the rescue. In
Proc. ICPC’11 , pages 161–170, 2011.
[7] L. Hattori and M. Lanza. Syde: A tool for collaborative
software development. In Proc. ICSE’10 , pages 235–238,
2010.
[8] T. Omori and K. Maruyama. A change-aware development
environment by recording editing operations of source code.InProc. MSR’08 , pages 31–34, 2008.
[9] R. Robbes and M. Lanza. A change-based approach to
software evolution. Electronic Notes in Theoretical
Computer Science (ENTCS) , 166:93–109, January 2007.
[10] R. Robbes and M. Lanza. SpyWare: A change-aware
development toolset. In Proc. ICSE’08 , pages 847–850,
2008.
[11] F. Servant and J. A. Jones. History slicing. In Proc. ASE’11 ,
pages 452–455, 2011.
[12] A. von Mayrhauser and A. M. Vans. Program comprehension
during software maintenance and evolution. IEEE Computer ,
28:44–55, 1995.
[13] M. Weiser. Program slicing. IEEE TSE , 10(4):352–357,
1984.249