Slicing MATLAB Simulink Models
Robert Reicherdt and Sabine Glesner
Technische Universit ¨at Berlin – Germany
reicherdt |glesner@cs.tu-berlin.de
Abstract —MATLAB Simulink is the most widely used in-
dustrial tool for developing complex embedded systems in
the automotive sector. The resulting Simulink models often
consist of more than ten thousand blocks and a large number
of hierarchy levels. To ensure the quality of such models,
automated static analyses and slicing are necessary to cope with
this complexity. In particular, static analyses are required that
operate directly on the models. In this article, we present an
approach for slicing Simulink Models using dependence graphs
and demonstrate its efﬁciency using case studies from the
automotive and avionics domain. With slicing, the complexity
of a model can be reduced for a given point of interest by
removing unrelated model elements, thus paving the way for
subsequent static quality assurance methods.
Keywords -Slicing, Simulink, Dependence Analysis, MATLAB
I. I NTRODUCTION
In the development of embedded systems, MATLAB
Simulink[1] is the most widely used industrial tool in the
automotive industry. Modeling real world problems like
braking systems or engine controllers result in Simulink
models containing several ten thousands of blocks and more.
These embedded systems are often deployed in safety critical
areas which requires comprehensive quality assurance mea-
sures. In practice, quality assurance methods like testing are
well established in the development of embedded systems
with Simulink. But static methods are often limited to
manual reviews and syntactical checks or are performed on
the code generated from models. Due to complex structural
hierarchies and model referencing, it is hard to recognize
data and control ﬂow when reviewing complex Simulink
models manually.
We address the problem of reducing the complexity of a
model by developing static slicing techniques for Simulink.
Therefore we remove those parts of the model that do not
affect a block b. We require our slicing method to preserve
the semantics of the model for being suitable for subsequent
automatic quality assurance measures. It also has to maintain
the models structure and hierarchy so that it can support
manual reviews by visualization. The slice has to be as
precise as possible since Simulink models may consist of
a huge number of blocks where each irrelevant block results
in unwanted complexity.
In this paper we present a novel static slicing method for
MATLAB Simulink models using a dependence graph based
approach. The main contributions of this paper are:1) A dependence analysis for MATLAB Simulink models
for control and data dependence.
2) A slicing approach for Simulink that preserves hierar-
chy and semantics within the slice.
For the dependence analysis we show that in Simulink
models control dependence can be derived from Conditional
Execution Contexts (CEC) . CECs are an internal represen-
tation, which
•cannot be accessed (neither from the model ﬁle nor by
MATLAB commands) and
•can be propagated to other blocks and different levels
through hierarchy.
This requires us to calculate CECs in Simulink models to
perform a dependence analysis.
Our slicing approach eases model comprehension for
manual reviews and allows impact analyses for Simulink
models. In addition slicing results as well as results from
our dependence analysis can be used for further quality
assurance methods that were infeasible before due to the
complexity of the models. To evaluate our approach, we
use a case study provided by an industrial partner from
the automotive industries as well as several models of the
Simulink demo library which are also from automotive and
avionics domain.
The rest of this paper is structured as follows: In Sec-
tion II, we brieﬂy introduce slicing and present Simulink.
In Section III we investigate control and data ﬂow in
Simulink models. In Section IV we present our approach for
calculating Conditional Execution Contexts and the slicing
of Simulink models. We give results from our case studies
in Section V and discuss related work in Section VI. Finally,
in Section VII we give a conclusion and outline our plans
regarding future work.
II. B ACKGROUND
A. Slicing
Program slicing is a technique for extracting statements
of a program that affect or are affected by the values of a
set of variables at a speciﬁc point in the program. These
extracted statements are called a slice. The point in the
program and the variables of interest are usually referred
to as a slicing criterion . Slices are either static ordynamic
as well as executable ornot executable . An overview for
program slicing is given by Tip in [2] and Silva in [3].978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 551
1read(n);
2i = 1:
3 sum = 0;
4mul = 1;
5while( i≤n)
6 sum = sum + i;
7 mul = mul * i;
8 i = i + 1;
9 write(sum);
10 write(mul);
(a) A Example Program
 (b) CFG
Figure 1. A Example Program and its CFG
While the original slicing approach[4] was based on
solving data ﬂow equations, slicing algorithms nowadays are
using program dependence graphs (PDG) [5][6]. A PDG is
a directed, rooted graph with nodes representing statements
and edges representing dependences. Using PDGs, slicing
can be mapped to a reachability problem.
Depending on the direction of edge traversal, a slice is
called a forward orbackward slice. While backward slices
extract the statements that inﬂuence the program point given
by the slicing criterion, forward slices contain the statements
that are inﬂuenced by the slicing criterion in the further
execution of the program.
To build the dependence graph for a program, a depen-
dence analysis has to be done ﬁrst. A PDG consists of two
types of dependence relations: data andcontrol dependence.
These dependence relations are deﬁned in terms of the
control ﬂow graph of a program.
Data dependence is usually given by DEF-REF-relations
of variables during the traversal of the control ﬂow graph
(CFG) on all paths.
Deﬁnition 1 (Data Dependence) .A node jis data dependent
on a node iif there exists a variable xwith
(i)xis deﬁned at i
(ii)xis referenced at j
(iii) there exists a path from itojwhere xis not redeﬁned
at any node in that path.
Control dependence between nodes in the CFG is usu-
ally given in terms of post-dominance. A node iis post-
dominated by a node jif all paths from ito the exit node
pass through j. In Figure 1b node 5postdominates node 4.
Deﬁnition 2 (Control Dependence) .A node jis control
dependent on a node iif
(i) there exists a path from itojsuch that jpost-
dominates every node in the path excluding i
(ii)iis not post-dominated by j
In other words, a node jis control dependent on a node
iifihas at least two outgoing edges and jis not in all
of the paths to the exit node starting from these edges. In
Figure 1b the node 7is control dependent on node 5.
Figure 2. Environment for Fig. 3
Figure 3. Simulink Model corresponding to Figure 1a
Control dependence can be determined by calculating
the post-dominator tree for a CFG or for programming
languages with a well structured control ﬂow directly from
the abstract syntax tree.
In Figure 1a, we give a small example program that is
often used to demonstrate slicing. It calculates the sum as
well as the product of the ﬁrst npositive integers. The
highlighted statements are contained in a backward slice for
the slicing criterion C(10, mul )where line 10is the program
point and multhe variables of interest.
B. Simulink
Simulink [7], [8] is an add-on to the MATLAB IDE
by MathWorks that allows for the graphical modeling and
simulation of synchronous reactive systems. Simulink is a
data ﬂow oriented notation where blocks are connected by
lines . A Simulink block either represents functionality or is552used for structuring the model. Lines represent signal ﬂow
and are connected to the inputs oroutputs of blocks.
Simulink provides many different blocks that implement
e.g. arithmetical and logical functions, relational operators
or various tasks from electrical engineering. There exists
blocks used for structuring the model as e.g. Subsystem
orPort blocks and for structuring the signal ﬂow such
asBus orMux blocks, too. Blocks used to structure the
model are generally virtual . Virtual blocks do not inﬂuence
the behavior of a model.
Subsystems in Simulink are either virtual subsystems
oratomic subsystems . Virtual subsystems are only used
for structuring the model by introducing visual layers of
hierarchy. Atomic subsystems require all contained blocks
to be executed as one atomic operation.
Example 1. Figure 3 shows a Simulink model that corre-
sponds to the program in Figure 1a. It calculates the sum
and the product of the ﬁrst npositive integers up to a given
n. This is modeled using a WhileIterator subsystem.
AWhileIterator subsystem is executed as long as the
signal supplied to the cond port is greater than zero. A
WhileIterator requires an initial condition (IC) which
is used to determine if the subsystem is executed at least
once. This IC has to be supplied from outside of the
WhileIterator subsystem. Thus we have embedded the
WhileIterator subsystem in an environment (Figure 2)
where nis supplied by a Ramp function which increases n
by1in each simulation step and ICis aConstant .
We have named the blocks corresponding to the state-
ments of our example program. The initialization of the
variables (Line 2-4) is done with the initial values of the
UnitDelay (1
z) blocks. A UnitDelay block holds the
value of a signal for a simulation step. We have named the
UnitDelay blocks like the variables they correspond to.
The read andwrite operations are mapped to the Inport
andOutport blocks of the subsystem.
Only Subsystem blocks can contain other blocks. The
ports of a Subsystem block correspond to Port blocks
within the subsystem. A number is assigned to each Inport
orOutport block which corresponds to the vertical posi-
tion of the input of the Subsystem block. The inputs of the
Subsystem block in Figure 2 are mapped to the Inport
blocks (rounded rectangles) read(n) (No. 2) and IC(No. 1)
in Figure 3 according to their numbering (top to down).
Loops in Simulink can be executed multiple times within
one simulation step. Thereby loops do not consume simu-
lation time and it is up to the modeler to ensure that the
execution time of the loop is within the sampling rate of
the model. Loops also allow state changes of the blocks
contained in the loop subsystem. Hence a UnitDelay
block holds the value of the signal only for an iteration step
of the loop.C. Simulation of a Model
Even though the graphical notation in Simulink models
is concurrent, the simulation of models is deterministic and
sequential. The Simulink simulation environment determines
a schedule for the execution of blocks. Basically, the execu-
tion order is calculated according to the direct signal ﬂow
dependences between the blocks. For more information to
block scheduling we refer to [8].
Simulink uses execution contexts (EC) to store and exe-
cute the calculated schedules. An execution context contains
a sorted list of blocks and nested execution contexts. Once
an execution context is entered, all elements contained in
this context have to be executed before the context is left.
When scheduling the blocks, the simulation environment
creates one execution context for the whole model and one
for each atomic subsystem within the model. The execution
are nested according to the hierarchy of the atomic subsys-
tems within the model. All blocks contained in an atomic
subsystem (and the virtual subsystems below) are added to
the execution context for the corresponding subsystem. The
elements in the ECs are scheduled locally within the context.
In the following sections, we refer to the execution context
created for the model as root context .
The simulation is done for a ﬁnite number of steps. The
time span between the simulation steps depends on the solver
used to simulate the model and can be ﬁxed or of variable
size. Solvers can be continuous which is required for models
containing continuous blocks or discrete for models only
containing discrete blocks. For embedded systems, usually
a discrete solver is used that executes the model at a constant
sampling rate. In each simulation step, the environment starts
with the ﬁrst block of the root context and executes all the
blocks within this context in the calculated order.
III. D EPENDENCE IN SIMULINK MODELS
Simulink is a data ﬂow oriented graphical notation where
data ﬂow is given by structure and control ﬂow has to be
calculated. In this section, we present how we determine
data and control dependence for Simulink models.
A. Data Dependence
Data ﬂow in Simulink is given by signal lines. So data
dependence can easily be derived by following signal lines.
The general case for specifying data ﬂow in Simulink is
by deﬁning a line Lconnecting two blocks b1andb2. This
means that an output signal lofb1is used as an input signal
forb2.lis deﬁned in b1, referenced in b2and transmitted
viaL. In this case b2is directly data dependent on b1.
Deﬁnition 3 (Data Dependence (Simulink)) .A block b2is
data dependent on a block b1if
i)b1andb2are connected by a line Land
ii)Lstarts in an output of b1and ends in an input of b2.553Figure 4. A MultiPortSwitch
B. Control Flow in Simulink
Before presenting how control dependence is calculated
for Simulink, we summarize the different ways of modeling
control ﬂow in Simulink models. Basically control ﬂow in
Simulink is modeled by
a)conditional subsystems or
b)loop subsystems or
c)MultiPortSwitch andSwitch blocks.
We explain these constructs in the subsequent paragraphs.
1) Conditional Subsystems: Conditional subsystems
areEnabled ,Triggered ,Enabled & Triggered ,
Action andFunction-Call subsystems. Conditional
subsystems are atomic and characterized by a special port on
which controls the execution of the subsystem. Dependent
on the type of the subsystem, the signal connected to the
special port is checked for a speciﬁc property, e.g. if it is
greater than 0in case of a Enabled or for a falling or
rising edge in case of a Triggered subsystem. Blocks
contained in a conditional subsystem are only executed if the
condition given by the special port is fulﬁlled. This behavior
is analogous to an if-statement with an empty else branch
known from imperative programming languages. Although
there exist Switch-Case andIf-Then blocks, these are
only specialized blocks that drive Action subsystems. The
actual conditional execution is done by Action subsystems.
2) Loop Subsystems: Loops like while and for in
Simulink are realized by atomic subsystems, too. Similar
to conditional subsystems they contain a special block
which controls the execution of the subsystem. This block
is either a WhileIterator or a ForIterator . A
WhileIterator block triggers the execution of the sub-
system as long as a condition is true. A ForIterator
block triggers the execution of the subsystem for a given
number of times.
3) Switches: Switch orMultiPortSwitch (e.g. Fig-
ure 4) blocks can also be used to model control ﬂow in
Simulink. These blocks offer a control port (the topmost
input in Figure 4) and a number of data ports. Depending
on the value provided to the control port, the signal attached
(a) The Conditional Subsystem S
within m
(b) Contents of the Conditional Subsystem S
Figure 5. The model m
to the corresponding data port is forwarded to the output port
of the Switch orMultiPortSwitch block. To optimize
the simulation of a model, the Simulink environment offers
Conditional Execution Behavior to avoid the unnecessary
execution of model parts. If Conditional Execution Behav-
ior is set active, the Simulink environment only executes
those blocks that supply data to the selected input port
of the Switch orMultiPortSwitch block. To realize
the conditional execution of these blocks, the simulation
environment internally creates Enabled subsystems for
each data port.
As one can see, all control ﬂow, i.e. the conditional
execution of blocks, in Simulink is realized by conditionally
executed atomic subsystems. To determine control depen-
dence, we have to investigate how Simulink internally treats
conditional subsystems.
C. Control Dependence and Conditional Execution Contexts
In this section we show how control dependence can be
determined by analyzing the execution contexts given by the
conditional subsystems in a Simulink model.
As mentioned in Section II-C, for each atomic subsystem
a new execution context is created. Due to all conditional and
loop subsystems being atomic, an execution context (EC) is
created for each of these and the blocks contained in each
of these subsystems are assigned to its EC and scheduled
within. All other blocks are assigned to the root context of
the model and ordered according to their data dependences.
The ECs of the atomic subsystems are scheduled according
to the data dependences of the corresponding subsystem
blocks within the EC of the corresponding parent subsystem.
Conditional subsystems and loops are only executed if the
condition given by the special port or iterator block evaluates
to true. Hence the corresponding ECs are called conditional
execution contexts (CEC) . In the following, we refer to this
special port or iterator block as predicate block .
Example 2. To demonstrate the calculation of control
dependence, we use the model mcontaining a block v554Figure 6. CFG with execution contexts
which is connected to a conditional subsystem S(Figure 5).
Scontains a number of blocks and has one Outport
block bnconnected to a block w. The blocks v, w and the
conditional subsystem Sare on the root level of the model.
The subsystem Scontains the Enable block cond that
triggers the execution of subsystems and in turn also the
execution of the blocks b1. . . bn within S. The block vis
connected to the input of Sthat corresponds to cond .
When scheduling the blocks of the model m, Simulink
creates two execution contexts: the root context of the model
and one for the conditional subsystem S, namely CEC S.
This results in the schedule:
Sched (m) =/angbracketleftbigg
v,{b1, . . . , b n}if cond
∅else, w/angbracketrightbigg
A control ﬂow graph corresponding to this schedule of mis
given in Figure 6. The execution contexts are indicated by
the dashed lines.
Simulink is used to model reactive systems that are
potentially non-terminating. Nevertheless, Simulink models
generally have the following execution behavior:
(1) A model is simulated for a given number of clock cycles.
In each of these time steps, the model is executed as long
as no runtime error occurs. The simulation of a Simulink
model stops if the simulation loop is left after executing
the model for a given number of clock cycles.
(2) Once an EC is entered, allblocks within the EC have
to be executed. This also holds for the root context.
Hence, it follows that there is a simulation loop (1) and
a model is always completely (2) executed in a simulationstep. So there exists one start and one exit node in the CFG
of a model. In Figure 6 these nodes are drawn dotted. Due
to the existence of an exit node, the deﬁnition of control
dependence of imperative languages becomes applicable
for Simulink models which is based on post-dominance.
Also there is a relationship between conditional execution
contexts and control dependence. Our deﬁnition of control
dependence in Simulink makes use of this observation.
In general, concerning the root context, it holds that every
node nof the root context is control dependent on the
simulation loop because it post-dominates all predecessors
in the schedule but not the simulation loop and itself.
Analogously, every other node mof an arbitrary conditional
execution context (e.g. CEC S) is control dependent on the
nodecond representing the predicate block that controls the
execution of this CEC. Even though the cond node itself
is contained in the subsystem mit has be to executed to
determine if mhas to be executed. So cond has to be
assigned to the parent execution context and is therefore
control dependent on the parent predicate block.
Deﬁnition 4 (Control Dependence (Simulink)) .In a model
mwith the root context emcontaining the blocks b1andb2,
b2is control dependent on block b1if
1)b2is within a conditional EC e/negationslash=emand
2)b1is the predicate block controlling the execution of e.
The blocks contained in emare control dependent on the
simulation loop.
In this section we have presented our deﬁnitions for data
and control dependence in Simulink models. While data
dependence is given by signal lines, control dependence can
be derived from the nested conditional execution contexts
within the model. In the next section, we show how we
calculate data and control dependence to build up the
dependence graph and slice the model.
IV. S LICING SIMULINK MODELS
In this section we present our slicing approach for
Simulink models using dependence graphs. First we deﬁne
the slicing criterion and the slice of a Simulink model. Then
we show how we calculate dependences which includes the
calculation of the conditional execution contexts. Finally we
show how we build up the dependence graph and compute
static slices for the model.
A. Approach and Basic Deﬁnitions
When slicing Simulink models, we are faced with both
theoretical and practical problems:
1) Subsystem blocks as nodes in the dependence graph
may lead to imprecise slices due to their use to imple-
ment hierarchy.
2) The CECs computed by Simulink are displayed but not
accessible via the API.5553) Even if they were accessible, those CECs do not contain
virtual blocks such as ports and buses that are needed
for keeping structural information.
Subsystem blocks in Simulink resemble procedures in im-
perative programming languages. For a number of input
values, a number of output values is produced. Most of
the subsystem blocks are only used to implement hierarchy,
which is comparable to procedures that are only called once.
Therefore, to deal with 1), we have decided to inline the
subsystems instead of using a System Dependence Graph
(SDG) [6] based approach that would generate lots of
unneeded nodes and edges in the graph.
To deal with 2) and 3), we have to calculate the condi-
tional execution contexts to derive control dependence.
Deﬁnition 5 (Simulink Slicing Criterion) .A slicing criterion
Cis a set of blocks B:C(B). The set Bcan contain any
virtual or non-virtual block except subsystem blocks.
The slicing criterion may be empty which results in the
slice also being empty. To slice for a subsystem block, we
use the corresponding Inport orOutport blocks of this
subsystem as slicing criterion.
A block cis relevant to a block bifcis directly or
transitively data or control dependent on b. This also holds
for virtual blocks that are connected by lines which in turn
allows us to preserve hierarchy.
Deﬁnition 6 (Simulink Slice) .A slice of a Simulink model
mis a model m/primethat
1) only contains those blocks that are relevant to the
slicing criterion C(backward) or
2) only contains those blocks to wich the slicing criterion
Cis relevant and that
3) preserves the hierarchical structure of the Simulink
model.
B. Computing Coditional Execution Contexts
In Section III-C we have shown that control dependence
can be derived from conditional execution contexts. Un-
fortunately, although each conditional and loop subsystem
creates its own conditional execution context, we cannot
use a syntax-directed approach for the calculation of control
dependence because Simulink allows the propagation of
conditional execution contexts.
In Simulink a CEC can be propagated across subsystem
boundaries. This means that a block bcan be added to the
CEC of a conditional subsystem Seven though the block bis
not contained in S. This is a mechanism for the optimization
of the simulation by executing only those blocks that are
required to be executed in a simulation step. The propagation
is done in both directions: forward propagation to determine
those blocks that only require data calculated in the CEC as
well as backward propagation to determine blocks that are
only executed to provide data for the CEC.
Figure 7. Propagation of the execution context 2to the Gain block
Example 3. Figure 4 shows a MultiPortSwitch block
and the CECs calculated by the Simulink environment. The
small numbers e:p{. . .}in the top right corner indicate
the execution context eand position pof the block in the
schedule of e. In case of the Switch block in Figure 4,
theMultiPortSwitch block itself is in the CEC 4.
The numbers in the curly brackets {e1, . . . , e n}represents
the execution contexts produced by this block. For the
MultiPortSwitch the execution contexts 1,2and3are
generated for the internally created Enabled subsystems
for each data input. These CECs are propagated to the blocks
connected to the data inputs of the MultiPortSwitch .
Figure 7 shows the surrounding subsystem of Figure 4.
The CEC 2from Figure 4 is propagated across subsystem
boundaries to a Gain block connected to the input that
corresponds to the Inport block In3in Figure 4.
There are two cases where a propagation of conditional
execution contexts is necessary:
•A conditional subsystem has its PropExecContextOut-
sideSubsystem parameter set to ONor
•Conditional Execution Behavior is set active for
a model and the model contains Switch and
MultiPortSwitch blocks.
MathWorks speciﬁes the following rules for the propagation
of execution contexts:
Deﬁnition 7 (Conditional Execution Context
Propagation[8]) .A block can be added to an execution
context if
1) its output is required only by a conditionally executed
subsystem or its input changes only as a result of the
execution of a conditionally executed subsystem, and
2) its sample time is inherited, and
3) the output of the block is not a testpoint, and
4) the block is allowed to inherit its conditional execution
context, and
5) the block is not a multirate block.
According to these conditions, the Simulink environment
calculates the execution context for each block. While 1) re-
quires us to analyze the paths leading to or from a block that
propagates its execution context, 3) and 4) can be directly5561 reassingSignalsToPortBlocks(model);
2 ﬁndExecutionContexts(model, root context);
3
4 function ﬁndExecutionContexts(parent, current ec){
5 for(block b in parent.childs) {
6 if(b is subsystem) {
7 if(b is conditional or loop) {
8 new ec := new EC(b.predicateBlock);
9 current ec.add(b.predicateBlock);
10 ﬁndExecutionContexts(b, new ec);
11 if( b.PropExecContextOutsideSubsystem == on) {
12 for(signal in b.insignals)
13 propagateBackward(signal, new ec);
14 for(signal in b.outsignals)
15 propagateForward(signal, new ec);
16}}else{
17 ﬁndExecutionContexts(b, current ec);
18}}else{
19 current ec.add(b);
20}}
21 if(Conditianal Execution Behavior == on) {
22 for(block b in parent.childs) {
23 if(b is MultiPortSwitch or Switch) {
24 for( signal of b.data in){
25 new ec := new EC(new node(signal.dstPortNr));
26 propagateBackward(signal, new ec);
27}}}}}
Figure 8. Algorithm for CEC-Calculation
taken from the parameters of the blocks and ports. For now,
we defer the aspects 4) and 5) for two reasons: First, the
Simulink documentation lacks for information which blocks
are not allowed to inherit an execution context. It only gives
two examples. Second, the Simulink documentation does not
specify exactly what a multirate block is.
Deferring 4) and 5) weakens the conditions for the
propagation of the conditional execution context such that
additional blocks may be added to a execution context in
some very rare cases. This leads to an overapproximation of
the existing control dependences and, hence, preserves the
correctness of the slices computed by our approach.
To compute the conditional execution contexts, we re-
cursively traverse the model top-down as shown by the
algorithm in Figure 8. First, after parsing the model, we
inline the subsystems by reassigning the signals connected
to the ports of the subsystems to the corresponding Inport
andOutport blocks (Line 1). Then we traverse the model
starting at the root level and with the root context (Line 2).
For each child block, we check whether it is a subsystem or
not. If not, the block can be added to the current execution
context (Line 19). If it is a non-conditional subsystem, it is
recursively traversed using the current execution context of
the parent subsystem or model (Line 17). For a conditional
or loop subsystem, we create a new CEC (Line 8) and add
the predicate block to the parent execution context (Line 9).
The recursive traversal of this subsystem is then continued
with the new CEC for its child blocks (Line 10). Subsystem
blocks are not added to the execution contexts. The recursive
traversal stops if the lowest hierarchy level is reached.For each conditional subsystem found during the traversal,
we check if the parameter PropExecContextOutsideSubsys-
temis set (Line 11). If so, we traverse the model starting
from the Inport andOutport blocks of this subsystem to
propagate the execution context (Line 12-15) in forward and
backward direction. Also, if Conditional Execution Behavior
is enabled for the model, we create an execution context for
each data port of a Switch orMultiPortSwitch block
(Line 25). Then these new execution contexts are propagated
to the blocks connected to the respective data port (Line 26).
The propagation of the execution contexts ( propagateFor-
ward() andpropagateBackward() ) is basically implemented
in a work-list algorithm that iterates over the input or output
connections of blocks. The traversal of a path starting from a
block that propagates an execution context is stopped if one
of the conditions 1) to 3) in Deﬁnition 7 is not fulﬁlled. The
blocks along this path are added to the execution context.
This algorithm can easily be extended for 4) and 5) in future.
C. Building the Dependence Graph
After all blocks have been added to an execution context,
we build the dependence graph. First we create nodes for
each block that is not a subsystem. We iterate over all signals
contained in the model and add the data dependence to the
nodes. Then, for each identiﬁed execution context, we add
the control dependence edges from the node that caused the
CEC to the nodes within.
If the CEC is caused by a MultiPortSwitch or
Switch block, an additional node is created per possi-
ble choice. This reﬂects the EnablePort block of the
internally created Enabled subsystem. The nodes within
the CECs are set control dependent on the corresponding,
virtual Enable node. The Enable nodes are set control
dependent to the switch because they are only evaluated if
the corresponding data input is selected.
In Figure 9, the dependence graph for the Simulink
model from Figure 3 and 2 is shown. After calculating the
CECs we have two CECs: the root context and a CEC for
the WhileIterator subsystem. In this ﬁgure, dotted edges
represent control dependence and gray solid edges data
dependence.
D. Computing the Simulink Slice
We compute the slice for a model by performing a
reachability analysis in forward or backward direction and
marking relevant nodes. Then we remove the unmarked
blocks and ﬁnally all empty subsystems from the model.
In Figure 3 and 2, we present a Simulink model that
corresponds to the example program in Figure 1a. Per-
forming a backwards reachability analysis for the slicing
criterion C(write (mul))leads to the marked dependence
graph shown in Figure 9. The bold nodes and lines belong
to the slice. As we can see in Figure 10, all blocks that are
not contained in the slice calculate the sum.557write(sum)Mux
ICWhile Iterator
write(mul) sum + i sum read(n)Relational
OperatorConstant
Constant1 i+1Scope
i mul *i mulRamprootFigure 9. Marked dependence graph for C(write (mul ))
Figure 10. Sliced model from Figure 3
E. Summary
In this section we have presented our approach to cal-
culate control and data dependence for Simulink models.
While we can derive data dependence from signal lines,
the determination of control dependence requires us to
calculate the conditional execution contexts ﬁrst. This also
includes execution context propagation. In contrast to the
execution contexts calculated by the simulation environment
of Simulink, our calculated ECs also contain virtual blocks.
This allows us to preserve the structure of the models.
V. E VALUATION
We have implemented our slicing approach in a tool that
parses a model, calculates the control and data dependences
and builds up a PDG corresponding to the model. We have
implemented our forward and backward slicing algorithm
that performs the reachability analysis by marking nodes in
the graph. Our tool is able to print the graph as well as to
color or remove the blocks in the model using a script in
M-language which can be executed in the MATLAB IDE.We have evaluated our tool on ten case studies. Eight of
these case studies were taken from the Simulink demo mod-
els which are shipped out with every MATLAB Simulink
distribution. From these we have selected those models with
the highest number of blocks and from different domains.
These models often demonstrate the various possibilities of
Simulink, and are therefor feasible to evaluate our approach,
but may not reﬂect real world models where guidelines
constrain the number of allowed modeling constructs.
Furthermore, we have used the model distance warning
which is a model provided by a project partner from auto-
motive industries and implements a system that monitors the
distance to vehicles driving ahead. Finally, our model con-
trol ﬂow consists of synthetic data. It is created by ourselves
during the development of our slicing approach and contains
nested conditional subsystems and a MultiPortSwitch
block. We have resolved model references to other models
such as the Simulink standard block library by replacing
these references with the subsystem they point to. Only m10
uses some libraries that are not accessible to us.
In Table I, we summarize the characteristics of the ten
models. All models contain between 57and 394 blocks
and between 47and 418 signal lines. These models have
a maximum hierarchy depth of 5. We distinguish these
models whether they contain large feedback loops or not.
Models that contain feedback loops use values calculated
in a previous step as input for the subsequent calculation
which result in cyclic data dependences. The models 3to
10contain those feedback loops.
In Table II we show the average size of the slices of the ten
models. In [9] the average slice size is deﬁned as the average
of the size of all slices when using every node that represents
a statement in the PDG as slicing criterion. Analogously we
deﬁne the average slice size AVG of a Simulink model m
where |m|is the number of blocks, ba block in m,S(b)a
slice with the criterion band|S(b)|
|m|percentage of the slice
size as:
AV G (m) =1
|m|/summationdisplay
b∈m|S(b)|
|m|
The average size of the forward and backward slices in
Table II are generated by our tool using only data depen-
dence (dd) and both data and control dependence (dd+cd) .558Table I
CASE STUDIES
Number Number Hierarchy Number of Feedback Percentage of
Model of Blocks of Lines Depth Subsystems Loops Port Blocks
m1 control ﬂow 57 47 3 8 NO 38.5%
m2 distance warning 227 259 4 24 NO 43.2%
m3 sldemo clutch if 103 112 3 10 YES 39.8%
m4 aero guidance airframe 140 154 3 9 YES 39.3%
m5 slAccelDemoF14 78 76 2 7 YES 35.9%
m6 sldemo auto climatecontrol 102 111 1 11 YES 31.5%
m7 sldemo enginewc 114 120 2 12 YES 32.5%
m8 Fuelsys 229 244 5 25 YES 40.2%
m9 aero guidance 338 381 4 27 YES 38.8%
m10 powerwindow03 394 418 3 32 YES 32.7%
total 1782 1922 40.9%
Table II
AVERAGE SLICE SIZES
A VG FW A VG FW A VG BW A VG BW
Model dd dd+cd dd dd+cd
m1 18,04 33,06 18,40 33,67
m2 35,73 36,02 35,39 35,82
m3 35,55 69,90 36,10 68,60
m4 50,43 50,43 50,45 50,45
m5 52,12 52,12 52,12 52,12
m6 45,62 52,85 45,46 52,45
m7 65,27 83,48 65,44 83,51
m8 55,14 61,99 55,11 61,97
m9 80,44 81,86 80,45 81,86
m10 21,97 22,22 21,84 22,11
total 46,03 54,39 46,08 54,26
As one can see, the size of the slices produced for models
using control and data dependence are greater or equal to
the size using only data dependence. Models with equal
sized ddand dd+cd average do not contain any control
ﬂow structures. The slice size increases for two reasons:
First, the predicate port block of conditional subsystems is
in most cases not connected by a line to any of the other
blocks contained in the subsystem (see Figure 5). Second,
blocks that feed a data input of a MultiPortSwitch or
Switch block require the execution of this Switch block if
Conditional Execution Behavior is enabled. In both cases
considering control dependence causes additional blocks,
namely those that are necessary to calculate the predicate
for the conditional execution, to be contained in the slice.
These results show that slicing based on data ﬂow without
considering control leads to semantically incorrect slices.
By performing empirical studies, Binkley and Harman
reported [9] an average backward slice size of about 28%
and an average forward slice size of 26% on slicing var-
ious programs. Androutsopoulos [10] reported an average
backward slice size of between 39.42% and 67.99% on
slicing extended ﬁnite state machines for different deﬁnitions
of control dependence. Our results (Table II) show a total
average of 54.26% for backward and 54.39% for forward
slices wich is signiﬁcantly larger than reported in [9]. But
Table II also shows that the majority of the blocks (around
46%) contained in a slice is caused by data dependences.
This is caused by two reasons: The ﬁrst one is the largenumber of virtual blocks in the models. Table I shows that
more than a third of the blocks are Inport orOutport
blocks that are only used for forwarding signals through
the hierarchy levels. This leads to large chains of data
dependences which have to be included in the slice. The
second reason are the large feedback loops contained in the
models m3tom10. These loops on can lead to cyclic data
dependences for a large number of blocks.
Taking a closer look on Table II shows that the difference
between the forward and backward slice sizes is very small.
Binkley and Harman reported backward slices being around
2%larger than forward slices, in our approach they are
0.13% smaller. In [11] they stated that control dependence
has a large impact on the difference in average slice sizes
of static forward and backward slices. Simulink models
usually do not contain much control dependence so this
explains that the difference between forward and backward
slices of simulink is smaller. Furthermore, in some models
the average forward slice using only data dependences is
larger than the average backward slice. Often these models
contain Constant blocks or large feedback loops. These
loops result in a absence of the small forward slices which
mentioned in [11]. But those models can still contain some
small backward slices ending in Constant blocks.
When comparing our approach to [9] and [10], we have
to take into account that the case studies used in these
publications differ a lot from each other. The programs
used by Binkley are not used to implement reactive systems
which usually run in loops waiting for an event or sampling
sensor values. So it is unlikely that there are cyclic data
dependences of the same size than they usually are in
Simulink models. The models used by Androutsopoulos
on the other hand are state-based models where control
dependence has much more inﬂuence on the slice size than
in Simulink models where there exist models without any
control dependence (e.g. m4,m5).
In this section we have presented the evaluation results
for our case studies. Although it is hard to compare results
for imperative languages to more abstract models as well
as to compare results for control ﬂow-oriented models to559data ﬂow-oriented models, all of these approaches have
used similar characteristics like average slice size or average
forward-backward difference. Based on these characteristics
we have investigated our results and have given reasons for
the observed deviations to the other approaches.
VI. R ELATED WORK
In the past ten years, a number of approaches have been
published on slicing various kinds of models. Most of these
publications are on slicing state-based models such as ex-
tended ﬁnite state machines or Statecharts. A comprehensive
overview about slicing techniques for state-based models is
given in [12]. To the best of our knowledge, no approach
for slicing Simulink has been published yet.
In 2000, the tool sliceMDL [13] was developed by Krogh.
Since this was a project for an industrial sponsor who wanted
to retain the rights to this work, we have not been able to
evaluate our approach against this tool. There are also no
publications on this work but only a little documentation on
the web page. According to this, sliceMDL uses the signal
ﬂow between blocks to slice a model but does not consider
execution context propagation and control dependence.
Simulink is a notation for the modeling of reactive
systems. There are some techniques for slicing other lan-
guages used to model reactive systems like Esterel ,Argos ,
(UML)Statecharts andextended ﬁnite state machines .
Kulkarni et al. [14] presented a technique for slicing
Esterel . Their approach is based on a synchronous threaded
program dependence graph which extends the threaded
dependence graph introduced by Krinke [15] by time and
stop dependence. While in Esterel there exists concurrency,
Simulink schedules all blocks to be executed sequentially.
This allows us to ignore interference dependences.
Argos and UML Statecharts are graphical notations that
allow the modeling of hierarchical state machines. Ganap-
athy et al. introduced slicing for Argos [16]. Wang et al.
presented an approach [17] for slicing UML Statecharts
based on a transformation to extended hierarchical automata
which later was improved by van Langenhove [18]. Both
approaches do not use dependence graphs.
Korel [19] and Androutsopoulos [20], [10], [21] intro-
duced slicing for extended ﬁnite state machines (EFSMs) .
Both adapt the control dependence as deﬁned for imperative
programming languages to EFSMs. While [19] requires an
exit state, [20], [10] used control dependence which is non-
termination insensitive. For slicing they use dependence
graphs. In [21] another approach for slicing of EFSMs is
presented where the EFSMs are reduced according to input
variables from environment. In [10], slice sizes for EFSMs
are compared for different deﬁnitions of control dependence.
They also compare the average slice sizes of EFSMs to
average slice sizes for imperative programming languages
[9] and report a larger average size for EFSMs.VII. C ONCLUSION AND FUTURE WORK
In this article, we have presented our method for slicing
MATLAB Simulink models which is the ﬁrst approach
for slicing Simulink. Our slicing technique works on the
block level and is based on dependence graphs. We have
shown how to derive data and control dependence from
Simulink models. We have presented how the construction
of the dependence graph is done for the different Simulink
constructs that cause control dependence. Finally, we have
shown results for our approach, which compared to slicing
approaches for other modeling notations are promising.
In future work we will further improve the propagation
of execution contexts in Simulink to get more precise
slices. Therefore we will reﬁne our algorithm for execution
context propagation to support the rules 4) and 5) from
the MATLAB Simulink documentation (Deﬁnition 7). We
plan to extend our algorithm to detect multirate blocks and
those that are not allowed to inherit execution contexts. We
assume multirate blocks to be virtual blocks like buses and
subsystems containing signals with different sampling rates
but need to verify this assumption by more experimental
models. Since the sampling rates often are inherited, we have
to study sample time propagation in Simulink to determine
blocks with hybrid sampling rates.
Another point to increase the precision is the treatment of
buses. Lines in Simulink do not reﬂect the number of signals
they carry. Simulink uses signal propagation to determine the
signals carried by a line at runtime. Therefore we need to
study this mechanism to determine relevant signals through
bus blocks to increase the precision in data dependences.
We plan to extend our slicing approach to Stateﬂow to
develop a comprehensive slicing technique for Simulink
including Stateﬂow which again should lead to more precise
slices. Stateﬂow models are a mix of UML Statecharts and
ﬂow charts. In our current approach we treat Stateﬂow
models as black boxes by assuming that each ingoing
signal is relevant to each outgoing signal. Developing a
slicing algorithm for Stateﬂow would allow the calculation
of the relevant outputs of a Stateﬂow block according to the
relevant inputs and vice versa.
Also, we want to extend our case study suite with larger
models and to compare slices generated by our approach
to slices on the code generated from the model by an
industrially used code generator.
In future, we plan to integrate our slicing approach into a
quality assurance framework for MATLAB Simulink models
where it will be used to reduce the complexity of the
models for various error and quality analyses as well as for
visualization purposes.
ACKNOWLEDGMENTS
This work is funded by the Investitionsbank Berlin (IBB)
within the EFRE (European Fund for Regional Develop-
ment) program of the European Union.560REFERENCES
[1] MathWorks, “Mathworks MATLAB Simulink.” [Online].
Available: http://www.mathworks.com/products/simulink/
[2] F. Tip, “A survey of program slicing techniques,” Journal of
Programming Languages , vol. 3, pp. 121–189, 1995.
[3] J. Silva, “A vocabulary of program-slicing based techniques,”
ACM Comput. Surv. , to appear.
[4] M. Weiser, “Program slicing,” in Proceedings of the 5th Inter-
national Conference on Software Engineering . Piscataway,
NJ, USA: IEEE Press, 1981, pp. 439–449.
[5] K. J. Ottenstein and L. M. Ottenstein, “The program de-
pendence graph in a software development environment,” in
Proceedings of the ﬁrst ACM SIGSOFT/SIGPLAN Software
Engineering Symposium on Practical Software Development
Environments , 1984, pp. 177–184.
[6] S. Horwitz, T. W. Reps, and D. Binkley, “Interprocedural
slicing using dependence graphs,” ACM Transactions on
Programming Languages and Systems , vol. 12, no. 1, pp. 26–
60, 1990.
[7] MathWorks, Simulink getting started guide , The MathWorks
Inc. [Online]. Available: http://www.mathworks.com/help/
pdfdoc/simulink/sl gs.pdf
[8] MathWorks, Using Simulink , The MathWorks Inc.
[Online]. Available: http://www.mathworks.com/help/pdf
doc/simulink/sl using.pdf
[9] D. Binkley, N. Gold, and M. Harman, “An empirical study
of static program slice size,” ACM Transactions on Software
Engineering and Methodology , vol. 16, no. 2, Apr. 2007.
[10] K. Androutsopoulos, N. Gold, M. Harman, Z. Li, and L. Tratt,
“A theoretical and empirical study of EFSM dependence,”
in25th IEEE International Conference on Software Mainte-
nance , 2009, pp. 287–296.
[11] D. Binkley and M. Harman, “Forward slices are smaller than
backward slices,” in Proceedings of the Fifth IEEE Interna-
tional Workshop on Source Code Analysis and Manipulation .
Washington, DC, USA: IEEE Computer Society, 2005, pp.
15–24.
[12] K. Androutsopoulos, D. Clark, M. Harman, J. Krinke, and
L. Tratt, “Survey of slicing ﬁnite state machine models,”
Technical Report RN/10/07, University College London,
Tech. Rep., 2010.[13] B. H. Krogh, “sliceMDL.” [Online]. Available: http:
//www.ece.cmu.edu/∼webk/TVG/downloads.html
[14] A. R. Kulkarni and S. Ramesh, “Static slicing of reactive pro-
grams,” in Proceedings of the 3rd IEEE International Work-
shop on Source Code Analysis and Manipulation (SCAM) ,
2003, pp. 98–107.
[15] J. Krinke, “Static slicing of threaded programs,” in Proceed-
ings of the 1998 ACM SIGPLAN-SIGSOFT Workshop on
Program Analysis for Software Tools and Engineering . New
York, NY , USA: ACM, 1998, pp. 35–42.
[16] V . Ganapathy and S. Ramesh, “Slicing synchronous reactive
programs,” Electronic Notes in Theoretical Computer Science ,
vol. 65, no. 5, pp. 50 – 64, 2002, sLAP’2002, Synchronous
Languages, Applications, and Programming (Satellite Event
of ETAPS 2002).
[17] J. Wang, W. Dong, and Z.-C. Qi, “Slicing hierarchical au-
tomata for model checking UML statecharts,” in Proceedings
of the 4th International Conference on Formal Engineering
Methods: Formal Methods and Software Engineering . Lon-
don, UK, UK: Springer-Verlag, 2002, pp. 435–446.
[18] S. Van Langenhove and A. Hoogewijs, “Sv tl: System veriﬁ-
cation through logic tool support for verifying sliced hierar-
chical statecharts,” Recent Trends in Algebraic Development
Techniques , pp. 142–155, 2007.
[19] B. Korel, I. Singh, L. Tahat, and B. Vaysburg, “Slicing of
state-based models,” in Proceedings of the 19th International
Conference on Software Maintenance (ICSM) , sept. 2003, pp.
34 – 43.
[20] K. Androutsopoulos, D. Clark, M. Harman, Z. Li, and
L. Tratt, “Control dependence for extended ﬁnite state ma-
chines,” in Proceedings of the 12th International Conference
on Fundamental Approaches to Software Engineering , 2009,
pp. 216–230.
[21] K. Androutsopoulos, D. Binkley, D. Clark, N. Gold, M. Har-
man, K. Lano, and Z. Li, “Model projection: simplifying
models in response to restricting the environment,” in Pro-
ceedings of the 33rd International Conference on Software
Engineering . New York, NY , USA: ACM, 2011, pp. 291–
300.561