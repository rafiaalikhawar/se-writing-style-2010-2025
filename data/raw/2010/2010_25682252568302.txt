Mining Interprocedural, Data-Oriented
Usage Patterns in JavaScript Web Applications
Hung Viet Nguyen
hungnv@iastate.eduHoan Anh Nguyen
hoan@iastate.eduAnh Tuan Nguyen
anhnt@iastate.eduTien N. Nguyen
tien@iastate.edu
Electrical and Computer Engineering Department
Iowa State University
Ames, IA 50011, USA
ABSTRACT
A frequently occurring usage of program elements in a pro-
gramming language and software libraries is called a usage
pattern . In JavaScript (JS) Web applications, JS usage pat-
terns in their source code have special characteristics that
pose challenges in pattern mining. They involve nested data
objects with no corresponding names or types. JS functions
can be also used as data objects. JS usages are often cross-
language ,inter-procedural , and involve control and data ow
dependencies among JS program entities and data objects
whose data types are revealed only at run time due to dy-
namic typing in JS. This paper presents JSModel, a novel
graph-based representation for JS usages, and JSMiner, a
scalable approach to mine inter-procedural, data-oriented JS
usage patterns. Our empirical evaluation on several Web
programs shows that JSMiner eciently detects more JS
patterns with higher accuracy than a state-of-the-art ap-
proach. We conducted experiments to show JSModel's use-
fulness in two applications: detecting anti-patterns (buggy
patterns) and documenting JS APIs via pattern skeletons.
Our controlled experiment shows that the mined patterns
are useful as JS documentation and code templates.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement
General Terms
Algorithms, Design, Documentation, Languages
Keywords
Usage Patterns, Mining, JavaScript, Web Applications
1. INTRODUCTION
When writing code, developers often use the program ele-
ments in a programming language and the APIs of software
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05 ...$15.00.libraries in a specic order to realize a certain task. For ex-
ample, in a task of writing a number to a data le in C, a
variable of type FILE must be opened (via the fopen func-
tion) before another variable of type intcan be written to
the le (via the fwrite function), and nally the le should
be closed to conclude the task (via the fclose function). Mul-
tiple programs could share a common task, and software de-
velopers repeat the code to realize it, following the usage of
the program elements for that task. A frequently occurring
code for a common task is called a usage pattern .
Several methods for mining usage patterns from code repo-
sitories have been proposed. The resulting usage patterns
have been shown to be useful in many software engineering
tasks, e.g., usage documentation [2], code smell and anomaly
detection [7], defect and vulnerability detection [4, 5, 6, 11,
24], code search [16], code completion [28], evolution adapta-
tion [3], etc. However, existing usage pattern mining meth-
ods are limited in the context of JavaScript (JS) Web code.
The usage patterns in JS have characteristics that pose
several challenges in pattern mining. First, JS usage pat-
terns involve control and data ow dependencies among pro-
gram entities and data objects whose data types are often
revealed only at run time due to dynamic typing in JS. This
creates great challenges since existing mining algorithms re-
quire named types for matching the entities in the usages [2].
Second, JS usage patterns can involve aggregated and
nested data objects , which are often inline code, i.e., hav-
ingno corresponding named entities in the program. Thus,
a mining algorithm must match the structures/prototypes of
objects, and cannot rely solely on the type names. Despite
recent advance in data clone detection for spreadsheets [30],
data objects have never been considered in existing pattern
mining approaches for the traditional typed languages since
they can be abstracted with their types. Third, a JS pat-
tern may cross the boundary of functions due to a pop-
ular programming style in JS for event handlers . Several
static analysis-based mining techniques could not handle
suchinter-procedural patterns due to their scalability.
Additional complexity is from the fact that JS functions
can be used as data objects . Finally, JS code is used to pro-
vide the control logic for Web pages, thus, JS patterns often
involve HTML elements. No existing mining approach can
handle all those properties in JS patterns yet.
This paper presents JSMiner, a static approach to mine in-
ter-procedural, data-oriented JS usage patterns in Web appli-
cations. A JS usage is modeled by a novel graph-based repre-
sentation, called JSModel . In addition to function calls, eld
accesses, and control nodes as in existing usage models [2, 7],Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the author/owner(s). Publication rights licensed to ACM.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
ACM 978-1-4503-2756-5/14/05
http://dx.doi.org/10.1145/2568225.2568302
791
JSModel has (un)named data nodes for variables, object lit-
erals, JS functions, and HTML elements. The structure of an
object is captured via (un)named data nodes and edges that
represent their containment relations. Edges are also used
to model control and data ow dependencies among nodes.
A data node for a JS function, which has an edge to its body,
can be connected as an input of any operation, e.g., as an
argument of a function call. This facilitates the mining of
inter-procedural patterns and the patterns with anonymous
functions in event handlers. Our graph-based mining tool,
JSMiner, is tailored toward JS to be ecient and scalable for
large usage graphs. It relies on graph structures and labels
for matching, rather than data types as in existing tools.
Our empirical evaluation on several Web programs shows
that JSMiner can detect more JS patterns with higher accu-
racy and eciency than the state-of-the-art tool GrouMiner
[2]. Other experiments also showed JSModel's usefulness in
two applications: detecting buggy patterns and document-
ing JS APIs via patterns. Our key contributions include:
1. JSModel, a graph-based representation model for JS us-
ages and patterns in JS Web applications (Sections 3-4),
2. JSMiner, a scalable JS pattern mining tool (Section 5),
3. An empirical evaluation on its scalability and accuracy in
pattern mining in Web programs, and JSModel's usefulness
in anti-pattern detection and JS documentation (Section 6).
2. MOTIVATING EXAMPLES
Let us present a few usage scenarios that share JS usage
patterns, and then discuss the challenges in mining them.
2.1 Usage Scenario 1
Figure 1 shows the HTML/JS code of an example from
the website of the Google Maps JS API library [1]. The li-
brary allows developers to embed Google Maps applications
in their websites by providing a variety of utilities for manip-
ulating maps and adding content to the maps. This exam-
ple Web page displays a map at a given location on the left
panel. When a user selects two points Aand Bon the map,
the optimal driving directions from AtoBwill be calculated
and highlighted, and the direction details will be displayed
on the right panel. To provide that function using Google
Maps, a developer would need to implement four main steps:
Step 1. Creating two HTML panels for the content of the
map and the direction information: In Figure 1, the HTML
<div>tags map canvas and directionsPanel on lines 36-37
serve as the place holders for the map and direction panels.
Step 2. Creating a JS Map object (provided by the API)
and displaying it on the HTML panel for the map: This step
is realized in lines 6-13 of the function initialize , which will
be called to create the actual map as the web page is loaded
(line 35). The variable myOptions is rst initialized with an
object literal storing the properties of the map (lines 7-12).
(A JS object literal is an unnamed list of property-value pairs
of an object, enclosed in curly braces.) Then, the variable
myOptions is passed as the second argument to a function
that creates a Map object (line 13). To display the map
on the map panel, document.getElementById( \map canvas" )
is passed as the rst argument of that function (line 13).
Step 3. Creating a JS DirectionsRenderer API object to
highlight the route on the map and displaying the direction
on the HTML direction panel (lines 5, 14-15): The variable
directionsDisplay is rst initialized as a DirectionsRenderer ob-http://gmaps-samples-v3.googlecode.com/svn/trunk/grabbag/israel-map.html
1<html><head>...
2<script type =``text/ javascript " >...
3var directionsService = new google.maps.DirectionsService() ; ...
4function initialize () f
5 directionsDisplay = new google.maps.DirectionsRenderer();
6 var center = new google.maps.LatLng(31.768318, 35.213711);
7 varmyOptions = f
8 zoom: 14,
9 mapTypeId: google.maps.MapTypeId.ROADMAP,
10 center : center ,
11 streetViewControl : false
12 g
13 map= new google.maps.Map(document.getElementById(``
map canvas" ), myOptions);
14 directionsDisplay .setMap(map);
15 directionsDisplay . setPanel(doc.getElementById("directionPanel " ) );
16 google.maps.event.addListener(map,` click ', function (event) f...
17 calcRoute() ; ...
18 g);
19g...
20 function calcRoute() f
21 var request = f
22 origin : origin ,
23 destination : destination ,
24 waypoints: waypoints,
25 travelMode: google.maps.DirectionsTravelMode.DRIVING,
26 g;
27 directionsService . route(request , function (response, status ) f
28 if( status == google.maps.DirectionsStatus.OK) f
29 clearMarkers () ;
30 directionsDisplay . setDirections (response);
31 g
32 g);
33g...
34</script ></head>
35<body onload =`` initialize () " ... >...
36 <div id =``map canvas" style =``... width:398px; ..." ></div>
37 <div id =`` directionsPanel " style =``... width:240px; ..." ></div>..
38</body></html>
Figure 1: Usage scenario 1: nding directions
ject (line 5), which contains direction details between two
points. Functions setMap and setPanel are called to display
the direction on the map and direction panels (lines 14-15).
Step 4. Updating the directions when the user selects or
updates two locations: The API function addListener (lines 16-
18) is called to declare a handler for the event when a user
clicks to select two points on the map.
2.2 Usage Scenario 2
We also found a Google Maps API example on [1] that
allows users to mark an area on a map with a polygon (Fig-
ure 2). The web page example has dierent functionality
but shares the map displaying task with the previous exam-
ple. Following the Google Maps API usage, the authors of
that web page example realized that task with the same four
steps. Step 1 was implemented on lines 18-19, step 2 on lines
4-9, step 3 on line 11, and step 4 on line 13.
Observations. From the two above usage scenarios, we
have the following observations:
O1. A library provides usages for dierent tasks in dif-
ferent scenarios. A usage for one task can be shared among
multiple scenarios. The frequently occurring usage for a
common task is called a usage pattern . As writing code in
a usage, developers need to follow specic steps and use pro-
gram elements in specic orders. That is, there are control
ow dependencies among the actions in those usages. For
example, the Map object needs to be created before it can be
attached to another object via the function setMap . There792http://gmaps-samples-v3.googlecode.com/svn/trunk/poly/poly edit.html
1<script type =``text/ javascript " >
2var poly, map; ...
3function initialize () f
4 var uluru = new google.maps.LatLng(  25.344, 131.036);
5 map = new google.maps.Map(document.getElementById(``map" ), f
6 zoom: 14,
7 center : uluru ,
8 mapTypeId: google.maps.MapTypeId.SATELLITE
9 g);
10 poly = new google.maps.Polygon(...);
11 poly.setMap(map);
12 poly.setPaths( new google.maps.MVCArray([path]));
13 google.maps.event.addListener(map, ` click ', addPoint);
14g
15 function addPoint(event) f...
16g
17</script >...
18<body ...onload =`` initialize ()" >...
19 <div id =``map" ... ></div>
20</body></html>
Figure 2: Usage scenario 2: creating polygons
are also data ow dependencies among actions, e.g. the data
resulted from an action can be the input of another. More-
over, the code for a pattern is not necessarily contiguous
since it can be intermixed with the code for other tasks.
O2. A JS usage pattern often involves not only function
calls but also JS data objects and JS functions that are re-
quired for the intended usage. For instance, a JS object lit-
eral is needed to initialize the properties of the Map object,
and a JS event handler (whether anonymous or named) is
used as an argument of addListener . Multiple objects can
be aggregated as the values of the properties of an unnamed
object literal . Note that JS functions are treated as data and
can be passed as arguments to other functions.
O3. A JS usage pattern can involve code written in dif-
ferent languages, and there are cross-language dependencies
among those code fragments. For instance, the HTML ele-
ment<body onload= \initialize()" ... >species a call to the
JS function initialize on its onload event, whereas the JS code
document.getElementById( \map canvas" ) accesses an HTML
element with the id map canvas .
O4. The same usage pattern might have implementation
variants (written in slightly dierent ways). For example, in
Figure 1, the object literal describing the map's properties is
assigned to variable myOptions , and myOptions is passed as
an argument to google.maps.Map (lines 7-13), while at lines
5-9 of Figure 2, the object literal is directly passed as an ar-
gument. The event handler at line 16 of Figure 1 is anonym-
ous, while the one at line 13 of Figure 2 is a named function .
O5. JS is a dynamically typed language. The data types
of JS variables can be determined/changed automatically as
needed during the execution. For instance, the variables poly
and map(line 2, Figure 2) are declared with JS keyword var,
without their types being specied in the code. At run time,
map wil be initialized as a Map object (line 5, Figure 2).
2.3 Usage Scenario 3
Figure 3 displays another Google Maps example, which
shares the same route calculation/displaying task as in the
rst usage scenario except for a few details, e.g., the source
and destination locations are now pre-dened. The usage
for that task is inside the function calcRoute (lines 2-15,
Figure 3), similar to the one on lines 20-33, Figure 1.http://gmaps-samples-v3.googlecode.com/svn/trunk/draggable-directions/
draggable-directions.html
1var directionsService = new google.maps.DirectionsService() ;...
2function calcRoute() f
3 var start = `48 Pirrama Road, Pyrmont NSW';
4 varend = `Bondi Beach, NSW';
5 var request = f
6 origin : start ,
7 destination :end,
8 travelMode: google.maps.DirectionsTravelMode.DRIVING
9 g;
10 directionsService . route(request , function (response, status ) f
11 if( status == google.maps.DirectionsStatus.OK) f
12 directionsDisplay . setDirections (response);
13 g
14 g);
15g...
Figure 3: Usage scenario 3: draggable directions
O6. A usage pattern can involve inter-procedural depend-
encies . For example, the route calculation usage pattern in-
volves both the code from outside an event handler (lines 3-
10) and its function body (lines 11-12). This type of inter-
procedural pattern occurs in JS event handling code, which
is popular in Web applications to enhance interactivity. Thus,
all or parts of such a JS callback function belong to a usage.
2.4 Challenges in Mining JS Usage Patterns
These examples illustrate new challenges in mining us-
age patterns in JS-based Web code. First, a pattern may
contain (aggregated) data objects including unnamed object
literals ( O2). Worse, some JS variables might not have de-
clared types ( O5). Thus, pattern mining that relies solely on
matching type names for program entities would not work.
The prototypes of data objects must be considered during
entity matching to nd patterns. Data objects, which are
crucial parts of JS usage patterns, have never been consid-
ered in existing mining approaches for the traditional typed
languages since they can be abstracted with their types. Sec-
ond, a JS pattern often contains inter-procedural dependen-
cies due to event handling code ( O6). Anonymous functions
are used both as functions and as data when passed as ar-
guments to another function. Thus, mining inter-procedural
patterns is needed in JS code. However, this not only creates
the scalability issue, but also increases the complexity in a
mining tool to represent such complex relationships. More-
over, in some applications, anonymous functions/objects are
used, and in others, the named ones are ( O4). A mining
tool must be able to detect patterns despite that dierence.
Finally, a JS pattern involves also non-JS web code ( O3).
3. REPRESENTATION OF JS USAGES
To address those challenges, we present JSModel, a graph
representation, and JSMiner, a pattern miner for JS usages.
Definition 1 (JSModel). A JSModel is a labeled, di-
rected graph representing a usage in a JS program. In a
JSModel, the nodes represent program actions, data, and
control structures; and the edges represent control and data
ows, and inclusion relationships among them.
All types of JSModel nodes and edges are listed in Table 1.
There are 3 types of nodes: action, data, and control nodes.
1. Action nodes (N1-N3). Program actions in a JS us-
age include function invocations ,variable assignments , and793Table 1: Types of nodes and edges in a JSModel
Type Sub-Type Description
NODES
N1. Action FuncCall ( m)mis a function invocation
N2. Action Assignment (=)A value assignment to a variable
N3. Action Operation ( OP)A data operation (+, !=, ...)
N4. Data Variable ( x)xis a variable or a eld of an object
N5. Data Function A function (used as data)
N6. Data ObjLit An object literal
N7. Data HTML An HTML tag element
N8. Control A control structure ( if,for,while )
EDGES ( x!y)
E1. Control Control-ow dependency from xtoy
E2. Data Data-ow dependency from xtoy
E3. Inclusion xhas a block of code including y
Node Types
Edge TypesAction
Data
Control
Control Flow
Data Flow
InclusionroutedirectionsService
obj= request outinObjLitinclorigin
destinationincl
waypointsincl=
= waypoints inout
outdestination in
arg
Function
(anonymous )argorigin = out in
IF OP cond
responseparamstatus param
in
in...OK
directionsDisplay
setDirectionsobjargincl
clearMarkerstravelMode = ...DRIVING in out
incl
inclL21
L27
L30L28
L29incl
Figure 4: JSModel for the body of calcRoute in Figure 1
data operations (e.g., `+', `==', `!=', etc). Those actions
are represented by action nodes in a JSModel. The label of
an action node is either \="for an assignment, the function
name for a function invocation, or the notation OPfor a data
operation. For example, the action nodes at L21 and L27 in
the JSModel in Figure 4 correspond to the assignment and
the function invocation route on lines 21 and 27 in Figure 1.
2. Data nodes (N4-N7). Data nodes are used to rep-
resent the data involved in the actions of a JS usage. JS-
Model has four types of data nodes: Variable ,Function , and
Object Literal for representing JS data objects, and HTML
data nodes for HTML elements. The label of a data node
contains the name/ID of the corresponding data entity (i.e.,
variable, function, object literal, or HTML element) if it has
a name/ID. Otherwise, a label \anonymous" is used.
3. Control nodes (N8). Control nodes model control
structures such as branches and loops that are required for
the intended usage. The label of a control node is the name
of its corresponding control structure (e.g. IForWHILE ).There are three edge types (control, data, and inclusion):
1. Control-ow edges (E1). Control-ow edges repre-
sent the control ows (orders) among the actions and control
structures in a usage. Such edges have no labels. For exam-
ple, in Figure 1, variable request is initialized (line 21), then
is passed to function route (line 27). In Figure 4, the order
is modeled as a control-ow edge from \="toroute .
2. Data-ow edges (E2). Data-ow edges with their
labels model dierent types of data ow dependencies be-
tween the actions and data entities in a usage, e.g., 1) an
argedge from a variable node xto a function call node m
indicates that xis an argument ofm; or 2) an objedge be-
tween mand xmeans that mis a function call on the object x.
For instance, the data-ow edge labeled outfrom the action
node \="to the data node request in Figure 4 means that a
value is assigned to variable request .
3. Inclusion edges (E3). Aninclusion edge (labeled as
incl) from a node xto a nodeyindicates that xhas a block of
code directly containing y, wherexcan be a function, object
literal, or control structure. In Figure 4, the control node IF
has two inclusion edges to the two actions clearMarker and
setDirections to indicate that those two function calls need
to be placed inside an ifstatement (lines 28-31, Figure 1).
A function node also has incledges to its body's statements.
Let us explain in detail dierent node and edge types in a
JSModel and our design rationale, and illustrate how those
design ideas address the challenges discussed in Section 2.
3.1 Representing Data Objects
We introduce three data node types (namely Variable ,
Function , and Object Literal ) to represent those JS data ob-
jects, and HTML nodes to represent HTML elements.
Variable nodes (N4, Table 1). AVariable node is used
to model a variable or a eld of an object. If the data is an
object eld, the corresponding JSModel will have a data
node representing the object, a data node representing the
object's eld, and a data-ow edge between them.
Object literal nodes (N6). In JS usages, object literals
are unnamed. They must be matched via their prototypes
(structures). Thus, JSModel uses an ObjLit node. Each ob-
ject literal has one or multiple elds, each of which has a
name and an initial value. Thus, an ObjLit has inclusion
edges referring to the object's elds. The value initializa-
tion of each eld is modeled by the \="action nodes. For
example, the ObjLit node in Figure 4 represents the object
literal at line 21 (Figure 1). The eld of an object literal
can in turn be assigned with another object literal, i.e. ob-
ject literals can be nested . JSModel can model a usage with
nested object literals, as in the following example.
ObjLit radius incl = out circle = {
   radius : getRadius (),
   center : {
      x: 1,
      y: 2
   } 
}centergetRadius in
= ObjLit out inx
yincl
incl
incl
JSModel for the value of circle
Besides the above data types, a JS usage may also contain
primitive types. Since data values might vary in dierent us-
ages of the same pattern, JSModel does not represent them.
HTML nodes (N7). We also represent HTML elements
as data nodes of type HTML . Information about an element's
properties (e.g., its type, name, and ID) is recorded, so that
when it is accessed from JS code, the corresponding HTML
node can be used to represent the referred element.794Function nodes (N5). We represent a function as a
data node of type Function . To support inter-procedural us-
age pattern, a Function node is linked via inclusion edges to
the JSModels describing its body code (the Function node in
Figure 4 connects to the inside of the JSModel for its body).
There are two ways that a function can be used. First, a
function is invoked via a function call . Thus, an action node
FuncCall (N1, Table 1) is connected via a data-ow edge to
its corresponding Function node (N5), if the declaration of
that function is found in the current source code, so that
inter-procedural dependencies in a JS usage can be recog-
nized. Second, if a JS function is used as a data object , the
Function node will connect to other nodes. For example, in
Figure 4, the Function node connects via a data-ow edge to
the action node route since the function is an argument of
route . A function could also have a name and be referred to,
as in the following code from Figure 2, where the function
addPoint is used as an argument of addListener :
13 google.maps.event.addListener(map, ` click ', addPoint);
14g
15 function addPoint(event) f...
16g
In such cases, the declared function and its references are
represented by a single Function node as in the model below.
...addListener argFunction 
(addPoint )map arg
eventparam
Body of addPoint
(not shown )incl
Function nodes and incledges are needed in JSModel because
in many common cases in JS code where an event handling
function is used (anonymously or not), a usage pattern in-
volves (part of) the function's body (see Section 2.3). Even
if the handler is named, using only its name is not enough
since a dierent usage of the same pattern might use dif-
ferent names which are assigned to the same body. This is
possible since a function is treated as a data entity. Function
types cannot be used either due to JS dynamic typing.
3.2 Interprocedural & Inclusion Dependencies
As explained on the Function node, the inclusion edges
support inter-procedural usage patterns. Moreover, inclu-
sion edges are also dened for all actions, data, and control
structures that interact across the boundary of a block of
code (enclosed by curly braces). For example, the ObjLit
in Figure 4 has incledges connecting itself to the four data
nodes origin ,destination ,waypoints , and travelMode . This
allows JSModel to maintain the elds of an object literal.
Such connections among nodes also allow a usage pattern to
be recognized even though it involves actions and data that
are inter-procedural or nested at multiple levels of blocks.
3.3 Implementation Variants & Dynamic Types
JS variables have dynamic types, and the same usage pat-
tern may be written using dierent variable names. A func-
tion can be used anonymously or as a named entity. To add-
ress such implementation variants , JSMiner recognizes a us-
age pattern based on the values of the variables in the usages
rather than their types or names, and based on the bodies
of the functions , rather than their names. This helps us de-
tect a pattern both when the values are assigned to variablesand when they are inlined directly in code (e.g., as unnamed
object literal), without being assigned to any variables.
To achieve that, JSMiner analyzes the program's state-
ments in their order of execution and records the propaga-
tion of variables' values through assignments. When there
is a data ow dependency from a variable to an action or
another data entity, we use the variable's value for that de-
pendency. For example, in Figure 1, the variable request is
assigned with an object literal (line 21), and is passed to the
function call route (line 27). Thus, that object literal is the
value of request and is used as an argument of the function
call route . To model that, in Figure 4, an argedge connects
theObjLit node (representing the value of request ) to route .
When building a JSModel, the variables' names are needed
to recognize data ow dependencies with the actions and
other data entities in a JS usage. However, dierent usages
of the same pattern may use dierent variable names. Thus,
during the pattern mining step, the labels of the respective
Variable nodes are anonymized so that usages are compared
by their graph structures rather than the variables' names.
For instance, the node request in Figure 4 will be anonymized.
If the value of a variable or the declaration of a function
cannot be resolved, JSMiner keeps its name in JSModel.
The rationale is that such a variable/function is usually from
alibrary and its name remains the same for all usages of the
same pattern. Thus, it is sucient to match them by names.
3.4 Cross-language Dependencies
There are two types of cross-language dependencies be-
tween JS and HTML entities. First, an HTML element is
dened with an ID and referred to from JS code via an
HTML DOM access. For example, in Figure 1, an HTML
<div>with ID= \map canvas" is dened at line 36, and ac-
cessed by document.getElementById( \map canvas" ) at line 13.
In such cases, HTML data nodes are created and connected
to the corresponding action nodes as in the JSModel below:
google .maps .MapHTML
(id=map _canvas )
myOptionsarg
argmap = out in
Second, the dependency between HTML and JS code also
occurs when JS code is embedded in an HTML event han-
dler. The code below from Figure 1 illustrates this case.
function initialize () f...g // JS code
<body onload =`` initialize () " ... > // HTML code
As seen, the handler for the onload event of the HTML
<body>tag has a call to the JS function initialize , which
is declared in JS code. To model this dependency, we lever-
age the fact that HTML elements and their properties can
be created/modied dynamically from JS code. Thus, the
above HTML/JS code is equivalent to the following JS code:
function initialize () f...g // JS code
document .body .onload =function ()finitialize () ; g// JS code
Since the two ways of assigning an event handler to the
<body>tag are interchangeable, we represent it as follows:
HTML
(type =body )Function
(anonymous )
obj=
outin
onloadFunction
(initialize )
initializeBody of initialize
(not shown )inclincl is-decl795Table 2: JSModel building rules
JS Stmt/Syntax JSModel Building RulesExpr
1. Variable V Variable(V)
2. Field E:F J(E)obj  !Variable(F)ifEis dened,
Access orVariable(E:F)otherwise
3. Assign V=EJ(E)in  !Action(=)out  !J(V)
4. ObjectfF1:E1;ObjLit()incl   !J(Fi),
Literal F2:E2:::g J(Ei)in  !Action(=)out  !J(Fi)
5. BlockfS1:::S ngJ(Si)control     ! J(Sj);8i<j
6. FuncDecl function J(Pi)param     ! Function(N)incl   !J(B)
N(fPig)B
7. FuncCall [ E:]m=Action(N),mis decl     ! Function(N),
N(fEig)J(Ei)arg     !m,J(E)obj  !m
8. Pre/Post/ op E ,E op ,J(Ei)in  !Action( OP)
Inx Expr E1op E 2
9. While while ( E)SJ(E)cond   ! Control( WHILE )incl   !J(S)
10. If if ( E)S1if=Control( IF),J(E)cond   !if
elseS2 ifincl(T)     !J(S1);ifincl(F)     !J(S2)
4. BUILDING JSModel
The JSModel for a JS code portion is composed of the JS-
Models for the smaller portions of that code, and the edges
connecting those JSModels represent their dependencies. A
JSModel has a designated core node . Connecting two JSMod-
elsJ1andJ2means that the core node of J1is connected to
that ofJ2. To build a JSModel, we parse the given JS code
using Eclipse's JS parser. Table 2 shows the building rules
for dierent AST structures. Core nodes are highlighted in
bold. JS statements/expressions are processed as follows.
1. Variable. For a JS variable, we either create a new
Variable node with the variable's name as its label or reuse
theVariable node if a node was already created for a variable
with the same name and in the same program scope.
2. Field access. For a eld access E:F, we rst check
whether the expression Eis a variable that has been initial-
ized. If it is, JSMiner connects the JSModel of E,J(E), to a
Variable node modeling the eld Fvia an objdata-ow edge.
Otherwise, JSMiner assumes that the eld access is a quali-
ed name from a library (e.g., google.maps.MapTypeId.ROAD-
MAP ) and models it by a Variable node with the qualied
name as its label. An array access is handled similarly.
3. Assignment. For a variable assignment, JSMiner
connects the JSModels for the left-hand-side and right-hand-
side expressions to an Assignment node via data-ow edges.
Since JSMiner aims to recognize usage patterns based on
variables' values, it stores the JSModel J(E) representing
the value of variable V. Then, when the JSModel of Vis
needed to compose other JSModels, J(E) is used instead.
4. Object literal. JSMiner creates an ObjLit node and
connects it to the JSModels of the object elds by inclusion
edges. The initialization of a eld Fiwith an expression Eiis
modeled by an Assignment node linking to J(Ei) andJ(Fi).
5. Block. JSMiner connects the statements in their ap-
pearance order in a block to form a closure by control-ow
edges. For nested code blocks, only the statements in the
same level are connected. The core nodes of a block include
those of the statements in that block.6. Function declaration. AFunction data node is built
with the function's name as its label. It is connected to the
JSModels of the parameters via data-ow edges and to those
of the function's body statements via inclusion edges.
7. Function call. A function call or object creation
(e.g., new Map() ) is modeled by a FuncCall action node with
the function's name as its label. Data-ow edges are used to
connect the FuncCall node to the JSModels of the function's
arguments and that of the object whose function is invoked.
Moreover, if the function's declaration is found in the code, a
FuncCall node will be linked to the respective Function node
via an is-decl data-ow edge. JSMiner models special control
statements, e.g., break and return , as special FuncCall nodes.
8. Pre-/Post-/Inx expression. This expression is mo-
deled by an OPaction node. The sub-expressions of this expr-
ession are linked to the OPnode via data-ow edges.
9. While statement. AWHILE control node is created
for this statement. It is connected to the JSModel of the
while 's condition via a data-ow edge and to the JSMod-
els of its body statements via inclusion edges. Other loop
statements, e.g. doand for, are handled similarly.
10. If statement. A process similar to case 9 is applied.
JSMiner further annotates the inclusion edges with either T
andFto distinguish between two branches. Switch state-
ments and conditional statements are handled similarly.
Building JSModel for embedded JS code. The pro-
cess has three steps. First, JSMiner parses the HTML code,
and for each HTML tag, it creates a corresponding HTML
data node, and stores the tag's name, type, and ID. Second,
it identies any JS code embedded within HTML <script>
tags. JS les that are included by the srcproperty of HTML
<script>tags are not extracted since they are considered as
libraries. For JS code embedded in an HTML event handler,
e.g., onload and onclick , it builds the JSModel as described in
Section 3.4. Finally, it builds the JSModels for the extracted
JS code portions. In the process, when JS code accesses an
HTML element, the corresponding HTML node created in
step 1 will be used in the JSModel for that JS code.
5. JS PATTERN MINING ALGORITHM
Given the JSModels built from various JS usages, our pat-
tern mining algorithm, JSMiner, identies usage patterns
that frequently appear in their JS code. It is inspired from
GrouMiner [2] with two key ideas. First, small patterns are
extended to detect larger patterns. Second, the expansion is
done based on the specic characteristics of JSModel nodes
and edges to improve performance and detect meaningful JS
patterns. Figure 5 shows the pseudo code of the algorithm.
To handle implementation variants of the same usage pat-
tern, JSMiner rst removes the labels of the JSModel nodes
of certain variables and functions (Section 3.4) so that the
JSModels for the same usage pattern are isomorphic even
if its instances use dierent variables or functions' names
(line 2). Then, it collects all patterns of size 1 (having one
node) into the set Sof discovered patterns (line 3). For each
size-1 pattern p, it calls the recursive function ExtendPattern
to extendpand discover patterns of larger sizes (line 4).
To identify patterns of size k+1 from a pattern pof sizek,
JSMiner rst generates candidate instances of size k+1 from
the instances of p(line 7). Then, it clusters these instances
into groups of isomorphic graphs (the Cluster function in
line 8), in which a group qrepresents a candidate pattern.
Since detecting isomorphic subgraphs is NP-complete, we7961function MineUsagePatterns(JSModelSet J)
2 AnonymizeVariablesandFunctionsNames( J)
3S fSize 1 patterns fromJg
4 for each PatternpinSdoExtendPattern( p,S)
5returnS
6function ExtendPattern(Pattern p, PatternSetS)
7C GenerateCandidates( p)
8 for eachqinCluster (C)do
9 ifFreq(q)>andq =2S
10S S[q
11 ExtendPattern( q,S)
12 end
13 function GenerateCandidates(Pattern p)
14C ;
15 for each Instanceiofpdo
16 for each NodeninNextNodes(i)do
17 C C[(iLn)
18 returnC
19 function NextNodes(Instance i)
20 PriorityList L ;
21 switch LastExtendedNode( i)
22 case Action.Assignment: L GetNodes(` in',` out')
23 case Action.FuncCall: L GetNodes(`is decl')
24 case Action.OP: L GetNodes(` in')
25 case Data.ObjLit, Data.Function: L GetNodes(`incl ')
26 case Data.Variable , Data.HTML: L Neighbors(i)
27 case Control:L GetNodes(`incl ')
28L L[(Neighbors(i) /L)
29 returnL
Figure 5: JSModel usage pattern mining algorithm
use a vector-based approach, Exas [2], in which a subgraph
has a characteristic vector computed from the occurrences of
the sequences of its nodes and edges' labels and types. Two
graphs are considered isomorphic if they have the same vec-
tors. If the frequency of a candidate pattern qis larger than
a threshold andqis not a discovered pattern, qis identied
as a new pattern and used to mine larger ones (lines 9-11).
When extending a pattern pto identify larger patterns,
JSMiner generates candidate pattern instances from p(lines
13-18). To do this, it extends each instance of pby adding
to it the nodes returned by the NextNodes function (line 16).
A new instance cgenerated from an instance iand a node n
(denoted as iLn) is a graph containing n, all the nodes
and edges in i, and all edges connecting ntoi(line 17).
The NextNodes function (returning a list of nodes, lines
19-29) is used to prioritize the list Lof the nodes that will
be added to an instance ito generate new candidate pattern
instances. Since we traverse in a depth-rst search order, the
prioritization aims to detect meaningful JS patterns, and to
help reduce the detection time. Specically, for a given node
xin the current instance, it determines the key edges that
should be included rst in the extended instance based on
the node type of x. Then, the key nodes that are connected
toxvia those key edges are set with top priorities (lines
22-27). For example, for an action node of type FuncCall ,
JSMiner prioritizes its data-ow edge is-decl , which points to
aFunction node containing the body of the invoked function
(line 23), attempting to detect an inter-procedural pattern.
Similarly, for an ObjLit , it uses incledges to set high priorities
to the nodes for the object literal's elds (line 25). Finally,
the other neighboring nodes of the instance iare added to
Lwith lower priorities than the key nodes (line 28).
6. EMPIRICAL EVALUATION
To evaluate JSMiner's performance, we conducted empir-
ical experiments on various subject codebases (column CodeBase in Table 3). The rst set of subjects is taken from real-
world code examples of several JS libraries, which are avail-
able on the Web sites of those libraries or in their code repos-
itories. For the second set, we ran Crawljax [25], a Web
crawling tool, (with depth 2) to retrieve various pages from
several popular Web sites. Columns Files and JS Funcs show
the numbers of extracted HTML/JS les and JS functions.
6.1 JSMiner‚Äôs Accuracy Sensitivity Analysis
First, we aimed to evaluate JSMiner's pattern detection
accuracy in response to the threshold of the occurrence
frequencies of the usages. For each codebase, we varied 
and ran it to detect patterns. We then manually examined
the detected patterns and identied the (in)correct patterns
according to the documentation and specications of the cor-
responding JS libraries. Precision is measured by the ratio
of the correctly detected patterns over all detected ones.
In Figures 6a-c-e, for the three selected codebases ( Google
Maps ,Closure Library , and D3.js ), as the frequency threshold
decreases, the number of correctly detected patterns tends
to be higher, i.e. recall increases . Asincreases, the number
of incorrect patterns decreases, and precision tends to rise
and reaches 100% when is suciently large (Figures 6b-d-
f). For example, in Google Maps , whenwas at 6, JSMiner
detected a total of 70 patterns with 70% precision, and when
was 17, it detected 7 patterns with 100% precision. The
running time ranges from a few seconds to a few minutes and
generally decreases with higher thresholds (Figures 6b-d-f).
6.2 JSMiner‚Äôs Performance Evaluation
To evaluate the quality and complexity of the patterns
detected by JSMiner, we repeated the above process for
all other subject codebases. For each subject, we chose a
frequency threshold such that it produced a set of high-
quality patterns (with at least 80% precision) while obtain-
ing as many patterns as possible. Among all of those pat-
terns, the sets of correctly detected patterns are reported in
Table 3. Column is for the frequency threshold, and fmax
is the highest frequency of the detected patterns. The total
number of patterns ( Total ) includes those of dierent sizes
with 5-8, 9-15, or more than 15 nodes (see the respective
columns). To see the characteristics of the detected patterns,
we counted those that contain inclusion edges ( incl), func-
tions being used as data ( func), object literals ( objlit ), cross-
language dependencies ( cross), and control structures ( ctrl).
As seen, JSMiner detected a total of 246 correct JS pat-
terns with high complexity. The size of the patterns is typ-
ically 5-15 nodes, with 14 patterns of size larger than 15.
The majority have inter-procedural dependencies (163/246
patterns) and use JS functions as data objects (132/246).
Many patterns involve cross-language dependencies between
JS and HTML (36), control structures (67), and object liter-
als (15). Importantly, JSMiner is capable of handling code-
bases with over 200 les and 3,600 JS functions (columns Files
and JS Funcs ) and large graphs, some having more than
44,000 nodes and edges (column JSModel Size ), and with e-
cient time (<50 seconds) and memory usage ( <500MB). The
complete results can be found on JSMiner's Web site [29].
6.3 Comparison with GrouMiner
We conducted another experiment to compare JSMiner
with GrouMiner [2], which is a general, graph-based, us-
age pattern mining algorithm. Its tool is for Java. We797020406080
6789101112131415161718192021(a) Number of Patterns (Google Maps)
Incorrect
Correct
010203040
0%20%40%60%80%100%120%
6 8 10 12 14 16 18 20
Time (seconds)Precision(b) Precision/Time (Google Maps)
Precision Time
020406080100
4 6 8 10 12 14 16 18 20 22 24(c) Number of Patterns ( Closure Library)
Incorrect
Correct
050100150200250300
0%20%40%60%80%100%120%
4681012141618202224
Time (seconds)Precision(d) Precision/Time (Closure Library)
Precision Time
020406080
16 18 20 22 24 30 40 50 70 90(e) Number of Patterns (D3.js)
Incorrect
Correct
0510152025
0%20%40%60%80%100%120%
16 18 20 22 24 30 40 50 70 90
Time (seconds)Precision(f) Precision/Time (D3.js)
Precision TimeFigure 6: JSMiner's detection results with dierent pattern frequency thresholds 
0204060
6 810 12 14 16 18 20
Pattern Frequency Threshold œÉ(a) Correct Patterns
JSMiner
GrouMiner
0%20%40%60%80%100%
6 810 12 14 16 18 20
Pattern Frequency Threshold œÉ(b) Precision
JSMiner
GrouMiner
Figure 7: Comparison with GrouMiner
thus re-implemented its algorithm for JS. We followed the
same process as in the sensitivity analysis. Figure 7 shows
their comparison results on Google Maps . As the frequency
thresholdincreases, the precision of both GrouMiner and
JSMiner increases (Figure 7b). However, at any given ,
JSMiner detected more correct patterns (Figure 7a) with
higher precision (Figure 7b). Examining the result, we found
that GrouMiner could not detect JS patterns having cross-
language and inter-procedural dependencies, and functions
being used as data. Variables without declared types caused
it to incorrectly detect patterns. Since JSMiner built larger
graphs, its running time was almost double that of GrouMiner.
6.4 Case Studies
Let us present some JS usage patterns detected by JSMiner.
1. \Sending an AJAX request"pattern in MooTools
(Figure 8). Figure 8a shows a JS usage for sending an AJAX
request to a server (lines 4-6) as a user clicks on a loaded Webpage. The code is wrapped by an anonymous function and
attached to the click event of an HTML element via func-
tion addEvent (line 2). addEvent itself is wrapped by another
anonymous handler (line 1). As seen, the detected pattern
(Figure 8b) involves inter-procedural dependencies at mul-
tiple levels (with two nested event handlers). The event
handlers arepassed as data to other functions ( addEvent on
lines 1 and 2). Several instances of this pattern occurred for
other types of the objects that send the AJAX requests.
2. \Logging" in Closure Library (Figure 9). This
usage contains a pattern (highlighted) that outputs message
logs on an event. First, a Logger and event types are dened
(lines 1, 4-5). Then, a function to output the logs is declared
(lines 6-8). Finally, that function is attached to the event of
an HTML element (line 11). As seen, the pattern involves
the interaction of multiple objects ( logger ,EVENTS , and lo-
gEvent ). The declaration of the function logEvent (including
its body) (lines 6-8) and its use as a data object (line 11) are
parts of the pattern. JSMiner detected this inter-procedural
pattern even though it is intermixed with other code.
3. \Resetting zoom level" in jqPlot (Figure 10).
This pattern (highlighted) demonstrates cross-language in-
teraction between HTML and JS code. In the JS code, a plot
variable is initialized (line 5) on the event that the HTML
document is ready (line 2). In the HTML code, as a button is
clicked, resetZoom will be invoked (line 8). That function
embedded in HTML takes plotdened in JS as its argument.
4. \Playing video" in www.apple.com (Figure 11).
Figure 11 shows two usages of the pattern to play a video.798Table 3: JSMiner's pattern mining results
JS JSModel Size Patterns Mem Time
Code Base Files Func avg max  f max Total 5-8 9-15 >15 incl func objlit cross ctrl (MB) (s)
Closure Library 117 594 327 4,744 10 26 14 10 3 1 7 7 0 0 0 428 37
D3.js 168 1,126 335 2,876 25 38 29 27 2 0 1 1 0 0 0 283 11
Flotr2 24 71 181 295 4 5 3 2 0 1 3 3 0 0 2 16 2
Google Maps 74 834 778 9,580 13 17 16 7 6 3 13 11 9 11 0 461 14
InfoVis 27 231 559 2,340 5 8 9 4 4 1 9 8 1 1 1 22 7
jqPlot 82 182 170 1,460 2 3 10 4 3 3 9 8 1 2 2 20 5
JQuery 211 204 35 192 2 4 31 23 7 1 27 26 0 0 4 16 5
MooTools 50 99 118 528 2 2 16 14 2 0 13 12 0 0 3 15 3
Polymaps 66 135 547 12,877 5 7 9 2 4 3 1 1 0 4 1 21 4
Three.js 151 1,053 1,749 12,410 100 110 7 3 4 0 5 5 0 0 0 442 49
Visualization 28 87 357 9,454 2 2 4 1 3 0 4 4 2 2 0 17 2
www.amazon.com 184 1,038 321 6,477 4 31 17 13 3 1 16 15 0 8 6 40 6
www.apple.com 101 3,666 2,503 34,220 6 22 27 23 4 0 22 11 0 0 21 111 16
www.microsoft.com 134 2,061 1,375 18,121 8 10 20 19 1 0 13 9 1 0 11 100 19
www.paypal.com 73 2,084 2,306 21,261 8 12 19 16 3 0 9 3 0 1 9 93 29
www.youtube.com 75 2,324 3,196 44,238 8 15 15 10 5 0 11 8 1 7 7 70 7
Total 1,565 15,789 246 178 54 14 163 132 15 36 67
a) A usage:
1window.addEvent(`domready', function() f
2 $(`makeRequest').addEvent(`click', function(event) f
3 event.stop();
4 new Request.HTML( f
5 url : `/echo/html/', ...
6 g).send();
7 g);
8g);
b) Detected pattern (Skeleton):
1window.addEvent(val1, function () f
2 $(val2) .addEvent(val3, function (var1) f
3 var1.stop() ;
4 var2.send();
5 g);
6g);
Figure 8: Sending an AJAX request in MooTools
1var logger = goog.debug.Logger.getLogger(`demo');
2 var logconsole=new DivConsole(goog.dom.getElement(`log'));
3 logconsole . setCapturing(true);
4var EVENTS=goog.object.getValues(goog.Component.EventType);
5logger.ne(`Listening for: ' + EVENTS.join(`, ') + `.');
6function logEvent(e) f
7 logger.info( \`' +e.target.getCaption()+`" dispatched: '+e.type);
8g
9 var b1 = new goog.ui.Button(`Hello !') ;
10 b1.render(goog.dom.getElement(`b1')); ...
11 goog.events.listen(b1, EVENTS, logEvent);
Figure 9: Logging messages in Closure Library
The pattern involves an ifstatement and inter-procedural
dependencies (between the statements at lines 4 and 6, Fig-
ure 11a). The code in Figure 11b is similar; however, the
instance is in an assignment (line 1), whereas the instance in
Figure 11a is in the eld buer of an object literal (line 2).
5. \Loading page" in www.microsoft.com (Fig-
ure 12). This pattern involves the interaction among three
elds of an object literal: nextDelay for delay time (line 2),
nextto load contents (line 9), and onload to invoke next(line
4). The elds next and nextDelay are used inside an anony-
mous function (line 7) and declared outside (lines 2 and 9).
6.5 Anti-pattern Detection
To show a useful application of our representation, we
also conducted a study using JSModel to identify JS misuse.
First, we collected code examples showing JS programming1<script type= \text/javascript" language= \javascript" >
2$(document).ready(function() f
3 $. jqplot . cong . enablePlugins = true;
4 var goog = [[``2009/6/22 2:12" ,425.32], ...];
5 plot = $.jqplot(`chart', [goog], f
6 title : `Google, Inc .', ...
7 g);g);</script>...
8<button...onclick= \$.jqplot.Cursor.resetZoom(plot)" >...</button>
Figure 10: Resetting zoom level in jqPlot
a) Usage 1:
1 AC.Ambient.Content.Mixins = f...
2 buer : function () f
3 if ( !! this. video && this.canPlayVideo()) f
4 var a = this. video;
5 window.setTimeout(function () f
6 a.play()
7 g, 0); ...
8 a.observe ("play " , b) ... g g, ...g
b) Usage 2:
1 g.ambientVideo.play = function () f
2 if ( !! this. video && this.canPlayVideo()) f
3 var a = this. video;
4 window.setTimeout(function () f
5 a.play();
6 a.pause(); ...
7 g, 100);
8 Event. re ( this . video , "video : startedPlaying " ) ... g g;
Figure 11: Playing video in www.apple.com
mistakes ( anti-patterns ) and their xes ( correct patterns )
from various JS guides and forums. We then selected 30 JS
applications from Google Code relating to the patterns by
using keyword searching. For a system, we ran a subgraph-
matching algorithm on the JSModels built for the patterns
and those for the JS code of the system to determine if it has
any anti-patterns. We were able to identify 11 errors relating
to 4 anti-patterns. For example, the JS usage (receiving an
AJAX response) is missing a check for the elds readyState
and status of the XMLHttpRequest object (Figure 13).
6.6 Usefulness as Documentation & Templates
Let us outline our controlled experiment to evaluate if pat-
terns mined by JSMiner are useful as documentation and
code templates to help in understanding and using JS APIs.
We recruited 15 (under)graduate students at Iowa State Uni-7991 window.MSCOM.Helper.Content = f...
2 nextDelay: 100,
3 logenabled : !1, ...
4 onload: function () f
5 this . log ("window.MSCOM.Helper.Content: Body Onload" );
6 this .isBodyLoaded = !0;
7 setTimeout($.proxy(this.next, this), this.nextDelay)
8 g, ...
9 next: function () f...
10 a.type == " doc" && this.loadDocument(a) ... g, ... g;
Figure 12: Loading page in www.microsoft.com
1 // http://pyv8.googlecode.com/svn/trunk/demos/env.js
2 var xhr = new XMLHttpRequest(); xhr.open(``GET" , url);
3 xhr.onreadystatechange = function() f
4 // BUG: Missing if (xhr.readyState == 4 && xhr.status == 200 )
5 ... window.document = xhr.responseXML; ...
6g; xhr.send();
Figure 13: Anti-pattern detection
versity with mixed JS programming experience. Each per-
son was randomly given 9 questions in 3 categories (3 ques-
tions in each). (1) In the rst category, a correctly mined
JS pattern was shown in the skeleton form (e.g., the bold
texts in Figure 8b). A participant has 4 options (and a
\not sure") to select the description that best describes the
shown pattern. Among those four, there is one correct an-
swer (e.g., \sending a request as a user clicks on a loaded
page"). This category aims to evaluate the understandabil-
ityof the mined patterns as documentation expressed in our
skeleton form. (2) For 3 questions in the second category,
they were asked to rate the usefulness as JS documentation
of the mined pattern shown earlier in the rst category. We
used the following rating scheme: a) very useful (\I will use
it as-is, or modify it slightly"), b) somewhat useful (\It is a
good starting point, but I will need to make signicant modi-
cations"), c) not useful (\I will not use it at all"), and d) not
sure. (3) For the third category, we also aim to evaluate use-
fulness of the mined patterns but as the recommended code
templates . We simulated the practice of selecting code tem-
plates. We gave a participant a JS programming task and
asked him/her to select one among the three mined patterns
to complete the task, or indicate \not sure". There is only
one correct answer. We manually graded all 135 answers.
Table 4 shows our results. Among 45 questions in cate-
gory 1, 31 (69%) were correctly chosen (column Corr/Useful ).
Only 14 of them were incorrect or \not sure". This result
shows that most patterns mined by JSMiner are understand-
able. Moreover, as seen in the result for category 2, 38 of
45 answers (84.4%) are positive with 24 \very useful" ones,
conrming the mined patterns are useful as JS usage docu-
mentation . As seen, in category 3, the participants were able
to select many correct patterns for the given tasks (27 of 45
answers). The result shows that our mined patterns are use-
ful as code templates for users to perform a task. This also
indicates a promising application of the patterns in source
code completion for JS programming.
Threats to Validity & Limitations. The chosen projects
might not be representative. Human verication could have
errors. Our study suers from selection bias, as all partici-
pants are students. If we use professional developers, we may
get dierent results. There is possible construct bias as we
chose the tasks and patterns. Regarding limitations, key sour-Table 4: Results on usefulness as JS documentation
Corr/Useful Inc/Not Useful Not Sure Total
Category 1 31 (69%) 13 (29%) 1 (2%) 45
Category 2 38 (84%) 6 (13%) 1 (2%) 45
Category 3 27 (60%) 17 (38%) 1 (2%) 45
ces of inaccuracy include our graph matching approxima-
tion, symbolic execution for implementation variants, simple
data ow analysis, and low-frequency usages. Sub-patterns
are sometimes combined into a larger one but meaningless.
We used a simple symbolic execution for JS for evaluating
the variables' values and cannot handle dynamic execution
of JS code using functions such as evalordocument.write .
7. RELATED WORK
Our prior work, GrouMiner [2], models a usage by a graph
called Groum with two types of nodes: action nodes for
method calls and eld accesses, and control nodes for control
structures. In Groum's later version [4], data nodes model
the types of variables . JSMiner has several advances. First,
GrouMiner models only variables' types and cannot model
nested, aggregated data objects in a pattern, especially with
JS functions treated as objects (O2). Second, it is for single-
language programs and cannot support cross-language pat-
terns (O3). Third, it cannot work with JS where types might
notstatically be determined (O5). Finally, its mining algo-
rithm cannot detect inter-procedural patterns (O6).
Chang et al. [5] and Li et al. [6] aim to nd patterns and
clones on Program Dependence Graph (PDG). Chang et al.
use a frequent subgraph mining algorithm to nd patterns on
condition nodes on PDGs and detect neglected conditions.
Liet al. [6] detect cloned buggy code on PDG. Although
with PDG, they can address the challenges in O1 (data/-
control dependencies in patterns) and O6 (inter-procedural
patterns), it cannot overcome the challenges in O2-O5.
Other static pattern mining methods model a usage pat-
tern via a set of pairs, a sequence, or a partial order of
method calls [7, 9, 10, 15, 8, 16, 11], a set of entities [14],
CTL formulas [17], or a usage template [13, 12]. None of
them supports data objects and anonymous functions.
There are dynamic-analysis-based pattern mining meth-
ods to detect bugs [26, 27]. They mine execution traces to
construct the patterns in terms of FSAs [18, 20], associa-
tion rules [19], behavioral patterns [21], function precedence
[22], probabilistic model [23], and message sequences [19].
8. CONCLUSIONS
This paper addresses a usage pattern mining problem in
JS Web applications where JS usages involve unnamed data
objects whose types are not statically revealed. We introduce
JSModel, a graph representation for JS usages, and JSMiner,
a JS usage pattern miner that mines inter-procedural, data-
oriented JS usage patterns with untyped data objects. Our
evaluation shows that JSMiner detects JS usage patterns
with higher accuracy than a state-of-the-art approach. Our
experiments showed JSModel's usefulness in detecting anti-
patterns and serving as JS documentation and templates.
9. ACKNOWLEDGMENTS
This project is funded in part by US NSF grants: CCF-
1018600, CNS-1223828, CCF-1349153, and CCF-1320578.80010. REFERENCES
[1] \Google Maps JavaScript API,"
https://developers.google.com/maps.
[2] T. Nguyen, H. Nguyen, N. Pham, J. Al-Kofahi, T. N.
Nguyen, \Graph-based Mining of Multiple Object
Usage Patterns", Proceedings of the 7th joint meeting
of the European software engineering conference and
the ACM SIGSOFT symposium on the foundations of
software engineering ,ESEC/FSE'09 , pp. 383{392.
ACM, 2009.
[3] B. Dagenais and M. Robillard, \Recommending
adaptive changes for framework evolution", in
Proceedings of the International Conference on
Software Engineering ,ICSE'08 , pp. 481{490, ACM.
2008.
[4] N. Pham, T. Nguyen, H. A. Nguyen, T. N. Nguyen,
\Detection of Recurring Software Vulnerabilities", in
Proceedings of the International Conference on
Automated Software Engineering , ASE '10, pp.
447{456, ACM, 2010.
[5] R.-Y. Chang, A. Podgurski, and J. Yang, \Discovering
neglected conditions in software by mining dependence
graphs", IEEE Trans. Softw. Eng. , vol. 34, no. 5, pp.
579{596, 2008.
[6] J. Li and M. Ernst, \CBCD: Cloned buggy code
detector", in Proceedings of the International
Conference on Software Engineering , ICSE'12, pp.
310{320, IEEE CS, 2012.
[7] A. Wasylkowski, A. Zeller, and C. Lindig, \Detecting
object usage anomalies", Proceedings of the 6th joint
meeting of the European software engineering
conference and the ACM SIGSOFT symposium on the
foundations of software engineering , ESEC/FSE'07,
pp. 35{44. ACM. 2007.
[8] B. Livshits and T. Zimmermann, \DynaMine: nding
common error patterns by mining software revision
histories", in Proceedings of the 10th European
software engineering conference held jointly with 13th
ACM SIGSOFT international symposium on the
foundations of software engineering , ESEC/FSE'05,
pp. 296{305, ACM. 2005.
[9] C. C. Williams and J. K. Hollingsworth, \Automatic
mining of source code repositories to improve bug
nding techniques", IEEE Trans. Softw. Eng. , vol. 31,
no. 6, pp. 466{480, 2005.
[10] M. Acharya, T. Xie, J. Pei, and J. Xu, \Mining API
patterns as partial orders from source code: from
usage scenarios to specications", in Proceedings of the
6th joint meeting of the European software engineering
conference and the ACM SIGSOFT symposium on the
foundations of software engineering , ESEC/FSE'07,
pp. 25{34. ACM. 2007.
[11] S. Thummalapenta and T. Xie, \Alattin: Mining
alternative patterns for detecting neglected
conditions", in Proceedings of the International
Conference on Automated Software Engineering ,
ASE'09. pp. 283{294. IEEE CS, 2009.
[12] D. Hovemeyer and W. Pugh, \Finding bugs is easy", in
Proceedings of ACM SIGPLAN International
Conference on Object-Oriented Programming,
Systems, Languages, and Applications , OOPSLA'04,
pp. 132{136. ACM. 2004.[13] C. Liu, E. Ye, and D. J. Richardson, \Software library
usage pattern extraction using a software model
checker", in Proceedings of the International
Conference on Automated Software Engineering ,
ASE'06. pp. 301{304. IEEE CS, 2006.
[14] Z. Li and Y. Zhou, \PR-Miner: automatically
extracting implicit programming rules and detecting
violations in large software code", in Proceedings of the
10th European software engineering conference held
jointly with 13th ACM SIGSOFT international
symposium on the foundations of software engineering ,
ESEC/FSE'05. pp. 306{315. ACM, 2005.
[15] S. Thummalapenta and T. Xie, \ParseWeb: a
programmer assistant for reusing open source code on
the web", in Proceedings of the International
Conference on Automated Software Engineering ,
ASE'07. ACM, pp. 204{213.
[16] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei,
\MAPO: Mining and recommending API usage
patterns", in Proceedings of European Conference on
Object-Oriented Programming , ECOOP'09, pp.
318{343, Springer-Verlag, 2009.
[17] A. Wasylkowski and A. Zeller, \Mining temporal
specications from object usage", in Proceedings of the
International Conference on Automated Software
Engineering , ASE'09, pp. 295{306. IEEE CS, 2009.
[18] M. Pradel and T. R. Gross, \Automatic generation of
object usage specications from large method traces",
inProceedings of the International Conference on
Automated Software Engineering , ASE'09, pp.
371{382. IEEE CS, 2009.
[19] S. Kumar, S.-C. Khoo, A. Roychoudhury, and D. Lo,
\Mining message sequence graphs", in Proceedings of
the International Conference on Software Engineering ,
ICSE '11. pp. 91{100. ACM, 2011.
[20] M. Gabel and Z. Su, \Javert: fully automatic mining
of general temporal properties from dynamic traces",
inProceedings of International Symposium on the
Foundations of Software Engineering , FSE-16. pp.
339{349. ACM, 2008.
[21] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and
M. Das, \Perracotta: mining temporal API rules from
imperfect traces", in Proceedings of the International
Conference on Software Engineering , ICSE'06. pp.
282{291. ACM, 2006.
[22] M. K. Ramanathan, A. Grama, and S. Jagannathan,
\Path-sensitive inference of function precedence
protocols", in Proceedings of the International
Conference on Software Engineering , ICSE'07. pp.
240{250. IEEE CS, 2007.
[23] T. Kremenek, P. Twohey, G. Back, A. Ng, and
D. Engler, \From uncertainty to belief: inferring the
specication within", in Proceedings of the 7th
symposium on Operating systems design and
implementation , OSDI '06, pp. 161{176. USENIX
Association, 2006.
[24] M. Pradel and T. R. Gross, \Leveraging Test
Generation and Specication Mining for Automated
Bug Detection without False Positives", in Proceedings
of the International Conference on Software
Engineering , ICSE'12, pp. 288{298. IEEE CS, 2012.
[25] Crawljax. http://crawljax.com/801[26] V. Dallmeier, C. Lindig, and A. Zeller, \Lightweight
Defect Localization for Java", in Proceedings of
European Conference on Object-Oriented
Programming , ECOOP'05, pp. 528{550.
Springer-Verlag, 2005.
[27] W. Weimer and G. C. Necula, \Mining temporal
specications for error detection", in Proceedings of the
International Conference on Tools and Algorithms for
the Construction and Analysis of Systems , TACAS'05,
pp. 461{476. Springer-Verlag, 2005.
[28] A. T. Nguyen, T. T. Nguyen, H. A. Nguyen,
A. Tamrawi, H. V. Nguyen, J. Al-Kofahi, and T. N.Nguyen, \Graph-based pattern-oriented,
context-sensitive source code completion", in
Proceedings of the International Conference on
Software Engineering , ICSE'12. IEEE CS, 2012.
[29] http://home.engineering.iastate.edu/ /tildelowhungnv/
Research/JScan
[30] F. Hermans, B. Sedee, M. Pinzger, and A. van
Deursen, \Data clone detection and visualization in
spreadsheets", in Proceedings of the International
Conference on Software Engineering , ICSE'13, pp.
292{301. IEEE CS, 2013.802