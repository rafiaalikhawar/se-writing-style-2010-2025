Path Exploration based on Symbolic Output
Dawei Qi, Hoang D.T . Nguyen, Abhik Roychoudhury
School of Computing, National University of Singapore
{dawei,nguyend1,abhik}@comp.nus.edu.sg
ABSTRACT
EfÔ¨Åcient program path exploration is important for many software
engineering activities such as testing, debugging and veriÔ¨Åcation.However, enumerating all paths of a program is prohibitively ex-
pensive. In this paper, we develop a partitioning of program paths
based on the program output. Two program paths are placed inthe same partition if they derive the output similarly, that is, thesymbolic expression connecting the output with the inputs is thesame in both paths. Our grouping of paths is gradually created by
a smart path exploration. Our experiments show the beneÔ¨Åts of the
proposed path exploration in test-suite construction.
Our path partitioning produces a semantic signature of a program
‚Äî describing all the different symbolic expressions that the output
can assume along different program paths. To reason about changes
between program versions, we can therefore analyze their semanticsignatures. In particular, we demonstrate the applications of ourpath partitioning in debugging of software regressions.
Categories and Subject Descriptors
D.2.5 [Software Engineering]: Testing and Debugging‚ÄîTestingtools, Symbolic execution
General Terms
Experimentation, Performance, Reliability
Keywords
Path Exploration, Relevant Slice Condition, Symbolic Execution
1. INTRODUCTION
Programs follow paths. Indeed a program path constitutes a
‚Äúunit‚Äù of program behavior in many software engineering activi-ties, notably in software testing and debugging. Use of program
paths to capture underlying program behavior is evidenced in tech-
niques such as Directed Automated Random Testing or DART [8]- which try to achieve path coverage in test-suite construction.
Why do we attempt to cover more paths in software testing? The
implicit assumption here is that by covering more paths, we are
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copiesbear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE‚Äô11, September 5‚Äì9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.1 int x,y,z; // input variables
2 int out; // output variable3 int a;
4 i n tb=2 ;
5 scanf("%d %d %d",&x,&y,&z);
6 i f ( x-y>0 )//b1
7 a=x ;8 else
9 a=y ;
1 0i f ( x+y>1 0 )//b21 1 b=a ;
12 if(z *z > 3) //b3
13 printf("square(z) > 3 \n");14 else
15 printf("square(z) <= 3 \n");16 out = b; //slicing criteria
Figure 1: Sample program
likely to cover more of the possible behaviors that can be exhibited
by a program. However, as is well known, path enumeration is ex-tremely expensive. Hence any method which covers various possi-ble behaviors of a given program while avoiding path enumeration,
can be extremely useful for software testing.
We note that software testing typically involves checking the pro-
gram output for a given input - whether the observed output is same
as the ‚Äúexpected‚Äù output. Hence, instead of enumerating individual
program paths, we could focus on all the different ways in which
the program output is computed from the program inputs. In otherwords, we can deÔ¨Åne an output as a symbolic expression in termsof the program inputs. Thus, given a program P, we seek to enu-
merate all the different possible symbolic expressions which de-
scribe how the output will be computed in terms of the inputs. Of
course, the symbolic expression deÔ¨Åning the output (in terms of theinputs) will be different along different program paths. However,we expect that the number of such symbolic expressions to be sub-
stantially lower than the number of program paths. In other words,
a large number of paths can be considered ‚Äúequivalent‚Äù since thesymbolic expressions describing the output are the same.
To illustrate our observation, let us consider the program in Fig-
ure 1. The output variable out can be summarized as follows.
‚óèIfx‚àíy>0andx+y>10, thenout==x
‚óèIfx‚àíy‚â§0andx+y>10, thenout==y
‚óèIfx+y‚â§10, thenout==2
The summary given in the preceding forms a ‚Äúsemantic signa-
ture‚Äù of the program as far as the output variable out is concerned.
Note that there are only three cases in the semantic signature -
278
whereas there are eight paths in the program. Thus, such a se-
mantic signature can be much more concise than an enumeration
of all paths.
In this paper, we develop a method to compute such a semantic
signature for a given program. Our semantic signature is computed
via dynamic path exploration. While exploring the paths of a pro-gram, we establish a natural partitioning of paths on-the-Ô¨Çy based
on program dependencies - such that only one path in a partitionis explored. Thus, for the example program in Figure 1 only threeexecution traces corresponding to the three cases will be explored.For test-suite construction, we can then construct only three tests
corresponding to the three cases in the semantic signature.
How do we partition paths? The answer to this question lies in
the computation of the output variable. We consider two program
paths to be ‚Äúequivalent‚Äù if they have the same relevant slice [9] with
respect to the program output. A relevant slice is the transitive clo-
sure of dynamic data, control and potential dependencies. Data and
control dependencies capture statements which affect the output bygetting executed; on the other hand, potential dependencies capturestatements which affect the program output by not getting executed.
In Figure 1, even if line 11 is not executed, the output statement inline 16 is potentially dependent on the branch in line 10. This is tocapture the fact that if line 10 is evaluated differently, the assign-ment in line 11 will be executed leading different values Ô¨Çowing tothe output out. We base our path partitioning on relevant slices to
capture all possible Ô¨Çows into the output variable - whether by theexecution of certain statements or their non-execution.
The contributions of this paper can be summarized as follows.
We present a mechanism to partition program paths based on the
program output. The grouping of paths is done by efÔ¨Åcient dynamic
path exploration - where paths sharing the same relevant slice natu-rally get grouped together. We show that our smart path explorationis much more time efÔ¨Åcient as opposed to full path exploration viapath enumeration. Our efÔ¨Åcient path exploration method has im-
mediate beneÔ¨Åts in software testing. Since our path exploration
naturally groups several paths together - it is much more efÔ¨Åcientthan the full path exploration (as in Directed Automated RandomTesting or DART) as evidenced by experiments. Moreover, since
several paths are grouped as ‚Äúequivalent‚Äù in our method (meaning
that these paths compute the output similarly), the test-suite gener-ated from our path exploration will also be concise.
Secondly, we show the application of our path partitioning method
in reasoning about program versions, in particular, for debugging
the root-cause of software regressions. While trying to introduce
new features to a program, existing functionality often breaks; thisis commonly called as software regression. Given two program ver-sionsP,P
‚Ä≤and a test twhich passes in Pwhile failing in P‚Ä≤‚Äîw e
seek to Ô¨Ånd a bug report explaining the root cause of the failure of t
inP‚Ä≤. In an earlier work [14], we presented the DARWIN approach
for root causing software regressions. The DARWIN approach con-structs and composes the path conditions of test tin program ver-
sionsP,P
‚Ä≤in trying to come up with a bug report explaining an
observed regression. In this work, we show that computing andcomposing the logical condition over a relevant slice (also calledrelevant-slice condition throughout the paper) produces more pin-
pointed bug reports in a shorter time ‚Äî as opposed to computing
and composing path conditions. The reason for obtaining shorter
bug reports in lesser time comes from the path conditions contain-ing irrelevant information which are Ô¨Åltered out in relevant-slice
conditions. Hence relevant-slice conditions are smaller formulae,
which are constructed and solved (via SatisÔ¨Åability Modulo Theory
solvers) more efÔ¨Åciently.2. OVERVIEW
We begin with a few deÔ¨Ånitions.
DEFINITION 1( P A TH CONDITION ).Given a program Pand
a test input t, letœÄbe the execution trace of tinP. The path
condition of œÄ, saypcœÄis a quantiÔ¨Åer free Ô¨Årst order logic formula
which is satisÔ¨Åed by exactly the set of inputs executing œÄin program
P. Clearly, t‚äßpcœÄ.
The path condition is computed through symbolic execution. Dur-
ing symbolic execution, we interpret each statement and update thesymbolic state to represent the effects of the statements (such as as-
signments) on program variables. At every conditional branch, we
compute a branch constraint, which is a formula over the program‚Äôsinput variables which must be satisÔ¨Åed for the branch to be evalu-ated in the same direction as the concrete execution. The result of
symbolic execution is a path condition, which is a conjunction of
constraints corresponding to all branches along the path. Any in-put that satisÔ¨Åes the path condition generated by executing an inputtis guaranteed to follow the same path as t. We take the follow-
ing example to show that the effect of assignments is also consid-
ered in path conditions. The path condition for input ‚ü®x==0‚ü©
is¬¨(x‚àí1>0), that is, the effect of the assignment in line 4 is
considered.
1 int x; //input variable
2i n ta=0 ;3 scanf("%d",&x);
4x=x-1 ;
5i f ( x>0 )6 a=1 ;
7o u t=a ;
Figure 2: Example to show path condition and relevant-slice con-
dition computation
We now deÔ¨Åne slice conditions, which are path conditions com-
puted over slices.
D
EFINITION 2( D YNAMIC SLICE CONDITION ).Given a pro-
gramP, a test input tand a slicing criteria C‚Äî letœÄbe the exe-
cution trace of tinP. LetœÄ‚à£Cdenote the projection of œÄw.r .t. the
dynamic slice of CinœÄ. In other words, a statement instance sinœÄ
is included in the projection œÄ‚à£Cif and only if sis in the backward
dynamic slice of ConœÄ. The dynamic slice condition of CinœÄis
the path condition computed over the projected trace œÄ‚à£C.
Slice conditions are weaker than path conditions, that is, pcœÄ‚áí
dsc(œÄ,C)wheredsc(œÄ,C)is the dynamic slice condition of any slic-
ing criteria CinœÄ(see our technical report [13] for a simple proof
of this claim). We now reÔ¨Åne dynamic slice condition to relevant-
slice condition - the central concept behind our path partitioning.
But Ô¨Årst, let us recall the notion of potential dependencies and rel-
evant slices [1, 9].
DEFINITION 3( P OTENTIAL DEPENDENCE [1]). Given an ex-
ecution trace œÄ,l e tsbe a statement instance and brbe a branch
instance that is before sinœÄ. We say that sis potentially depen-
dent onbriff. there exists a variable vused inssuch that (i) v
is not deÔ¨Åned between brandsin traceœÄbut there exists another
pathœÉfrombrtosalong which vis deÔ¨Åned, and (ii) evaluating br
differently may cause this untraversed path œÉto be executed.
An example of potential for the program in Figure 1 is shown in
Figure 3.
We now introduce the notion of a relevant slice, and relevant-
slice condition, a logical formula computed over a relevant slice.
279	






Figure 3: Example of potential dependence. The solid arrows de-
note the execution path. According to DeÔ¨Ånition 3, (i) the variablebis not deÔ¨Åned between line 10 and line 16 but there exists a path
(though line 11) along which bis deÔ¨Åned, and (ii) evaluating the
branch at line 10 differently may cause the path through line 11 tobe executed. Therefore, line 16 is potentially dependent on line 10.
D
EFINITION 4( R ELEV ANT SLICE ).Given an execution trace
œÄand a slicing criteria CinœÄ, the relevant slice in œÄw.r .t.Ccon-
tains a statement instance sinœÄiff.C‚Üùswhere‚Üùdenotes the
transitive closure of dynamic data, control and potential depen-dence.
Note that our deÔ¨Ånition of relevant slice is slightly different from
the standard deÔ¨Ånition of relevant slice [1, 9]. In standard relevantslicing algorithm, if a statement instance Ais included only by po-
tential dependence, the statement instances that are only control
dependent by Aare not included in the relevant slice. We have re-
moved this restriction to simplify the deÔ¨Ånition of relevant slice, it
is simply the transitive closure of three kinds of program dependen-cies ‚Äî dynamic data dependencies, dynamic control dependencies
and potential dependencies. In the rest of the paper, all appearances
of relevant slice and relevant-slice condition refer to this simpliÔ¨Åed
deÔ¨Ånition of relevant slice.
D
EFINITION 5( R ELEV ANT SLICE CONDITION ).Given an ex-
ecution trace œÄand a slicing criteria CinœÄ, the relevant slice con-
dition inœÄw.r .t. criterion Cis the path condition computed over
the statement instances of œÄwhich are included in the relevant slice
ofCinœÄ.
We take the example program in Figure 2 to show that the ef-
fect of assignments is also considered in relevant-slice condition
computation (just as assignments are considered in path condition
computation). Let the slicing criteria be the value of out in line
7. The relevant slice for input ‚ü®x==0‚ü©is {2,3,4,5,7} and the cor-
responding relevant-slice condition is¬¨(x‚àí1>0). That is, the
effect of the assignment in line 4 is considered.
We use the simple program in Figure 1 to illustrate the advantage
of using relevant-slice condition in dynamic path exploration. The
slicing criteria is the variable out at line 16. Since each statement
is executed once, we do not distinguish between different execution
instances of the same statement in this example.
We use the executed branch sequence annotated with directions
to represent an execution trace. For example, the trace for input‚ü®x==6,y==2,z==2‚ü©of the program in Figure 1 is denoted
as[b1
t,b2f,b3t]. Let us take the input ‚ü®x==6,y==2,z==2‚ü©
to see the differences between path condition, dynamic slice con-
dition and relevant-slice condition. Given the trace [b1t,b2f,b3t]corresponding to input ‚ü®x==6,y==2,z==2‚ü©, the path condition
along this execution is (x‚àíy>0)‚àß¬¨(x+y>10)‚àß(z‚àóz>3).
For the execution path of ‚ü®x==6,y==2,z==2‚ü©, the dynamic
backward slice result w.r.t. the slicing criteria at line 16 is {4,16}
- it contains no branches. The path condition computed over thestatements in the dynamic slice (or the dynamic slice condition) issimply the formula true.
Different from dynamic backward slicing, relevant slicing also
includes the statement instances that could potentially affect theslicing criteria. For example, if evaluating a branch differentlycould affect the slicing criteria ‚Äî such a branch is included inthe relevant slice, even though it is not contained in the dynamic
backward slice. In the example program, the branch at line 10 can
potentially affect the value of out in the slicing criteria. This is
because if the branch in line 10 is evaluated differently (to true),the variable bis re-deÔ¨Åned (in line 11) which affects the output
variableout. Hence the relevant slice contains line 10. The entire
relevant slice is {4,5,10,16}, and the relevant-slice condition on it
is¬¨(x+y>10) . Any input tsatisfying the relevant-slice condi-
tion¬¨(x+y>10) has the same symbolic expression for the output
out, which in this case turns out be the constant value 2.
As mentioned earlier, program paths can be partitioned based on
the input-output relation. Relevant-slice condition perfectly serves
this purpose. If two paths have the same relevant slice with outputbeing the slicing criteria, then they have the same input-output re-lation. The path partitions of the program in Figure 1 are shown
in Figure 4. The grey nodes in Figure 4 are the statements that are
contained in the relevant slice w.r.t. to the unique slicing criteriaat line 16 in Figure 1. As we can see from Figure 4, based on therelevant slice, we can group the eight program paths into three path
partitions.
Just like the DART approach [8] uses path conditions to dynam-
ically
explore paths in a program, relevant-slice condition can be
used to explore the possible symbolic expressions that the program
output can be assigned to. How would such an exploration pro-
ceed? Suppose we simply use relevant-slice condition to replace
path condition in DART‚Äôs path exploration. Given a relevant-slice
condition œà1‚àßœà2‚àß...‚àßœàk‚àí1‚àßœàk‚Äî we construct ksub-formulae
of the form of œà1‚àßœà2...‚àßœài‚àí1‚àß¬¨œài, where 1‚â§i‚â§k. The path
exploration is done by solving these formulae to get new inputsand iteratively applying this process to the new inputs. Note that
each sub-formula shares a common preÔ¨Åx with the relevant-slice
condition. Now, we examine the effectiveness of this simple solu-tion on the program in Figure 1. Depth-Ô¨Årst exploration strategy is
used, and path exploration terminates when no new sub-formulae
are generated. Let the initial input be ‚ü®x==6,y==2,z==2‚ü©, the
path for this input is [b1
t,b2f,b3t]. The entire path exploration
process is shown in Table 1. The ‚Äúfrom‚Äù column of Table 1 can beunderstood as follows. If the ‚Äúfrom‚Äù column contains Œ±.Œ≤ , it means
that the current input is generated by negating the Œ≤th branch con-
straint of the relevant-slice condition in theŒ±th row.
Recall from Section 1 that we expect the following three sym-
bolic expressions for out to be explored.
‚óèx‚àíy>0‚àßx+y>10:out ==x
‚óè¬¨ (x‚àíy>0)‚àßx+y>10:out ==y
‚óè¬¨ (x+y>10) :out ==2
As we can see from Table 1, no path having relevant-slice condition
¬¨(x‚àíy>0)‚àß(x+y>10) is explored. Therefore, this feasible
relevant-slice condition is missed by the exploration process. In
addition, the relevant-slice condition ¬¨(x+y>10) is explored
280	



	


	
 
	


	


	
 
	



	

	
 

  
Figure 4: Path partitions of the example in Figure 1
several times. Thus, we cannot simply replace path condition with
relevant-slice condition in DART‚Äôs path exploration.
Let us examine closely what went wrong in the path exploration
of Table 1. In particular, the input in the third row is generated bynegating the second branch condition of the relevant-slice condi-
tion in second row in Table 1. That is, when we solve (x‚àíy>
0)‚àß¬¨(x+y>10) , we get an input‚ü®x==6,y==2,z==2‚ü©whose
relevant-slice condition is¬¨(x+y>10) . The branch condition
(x‚àíy>0)disappears in the new relevant-slice condition because
the corresponding branch is not contained in the relevant slice any-more. In contrast, DART follows certain path-preÔ¨Åxing properties‚Äîi fœà
1‚àßœà2...‚àßœài‚àí1‚àßœàiis the preÔ¨Åx of a path condition (for
some program input), the path condition of any input satisfyingœà
1‚àßœà2...‚àßœài‚àí1‚àß¬¨œàiwill have œà1‚àßœà2...‚àßœài‚àí1‚àß¬¨œàias a
preÔ¨Åx. Such a property does not hold for relevant-slice condition.
Hence, simply replacing path condition with relevant-slice condi-
tion in DART not only causes redundant path exploration but also
makes the exploration incomplete (in terms of possible symbolicexpressions that the output variable may assume).
We have developed a path exploration method which avoids the
aforementioned problems. While exploring (groups of) paths basedonrelevant-slice condition, our method re-orders the constraints in
the relevant-slice condition. The path exploration is based on re-
ordered relevant-slice condition. A reordered relevant-slice condi-
tion satisÔ¨Åes the following property (which also holds for path con-
ditions): if œà
1‚àßœà2...‚àßœài‚àí1‚àßœàiis a preÔ¨Åx of a reordered relevant-
slice condition, the reordered relevant-slice condition of any input
satisfying œà1‚àßœà2...‚àßœài‚àí1‚àß¬¨œàihasœà1‚àßœà2...‚àßœài‚àí1‚àß¬¨œài
as a preÔ¨Åx.
3. OUR APPROACH
In this section, we give our path exploration algorithm based
onrelevant-slice condition . We then give theorems on the com-
pleteness of our path exploration algorithm. Throughout the paper,we assume that the slicing criteria is in a basic block that post-dominates the entry of the program.
First we introduce the following notations.
Notations. We useCto denote the unique slicing criteria. When
used in a dynamic context, Crefers to the last executed instance
of the slicing criteria. Given a test case t, we use œÄ(t)to denotethe execution path of t. We use rs(sc,œÄ)to denote the relevant
slice on path œÄw.r.t. slicing criteria sc. We use rsc(sc,œÄ)to de-
note the relevant slice condition on path œÄw.r.t. slicing criteria sc.
We usereordered_rsc(sc,œÄ)to denote the reordered sequence
ofrsc(sc,œÄ).W e u s e br(œà)to denote the branch instance of a
branch condition œà.
3.1 Path exploration algorithm
We now present our path exploration method which operates on
a given program P. All relevant slices and relevant-slice conditions
are calculated on the same program Pwith respect to a slicing cri-
teriaC(which refers to the program output).
We group paths based on relevant-slice condition. As explained
in the last section, a DART -like search based on relevant-slice con-
ditions is incomplete, that is, not all possible symbolic expressions
that the output may assume will be covered. For this reason, wereorder the relevant-slice conditions.
Our path exploration algorithm is shown in Algorithm 1. The
core of the algorithm is the reorder procedure, which reorders the
relevant-slice conditions. When we compute the relevant-slice con-
dition, we get a sequence of branch conditions ‚Äì ordered accordingto the sequence in which they are traversed. We use the reorder
function to reorder the branch conditions, after which the path ex-ploration will be performed based on the reordered sequence ofbranch conditions.
Thereorder procedure is given in Algorithm 1. The reordering
works in a quick-sort-like fashion. In each call to reorder, we split
the to-be-reordered sequence into two sub-sequences. Suppose thelast branch condition in the sequence is from branch instance b
k.
Thenbkis used as the ‚Äúpivot‚Äù in the splitting process. If a branch
instancebis in the backward relevant slice of bk, then the branch
condition of bis placed before the branch condition of bk. Other-
wise, the branch condition of bis placed after the branch condition
ofbk. Then we recursively call the reorder procedure to reorder the
two sub-sequences.
We show the reorder procedure in action in Figure 5. Note that
our reordering is done on branch conditions in a relevant-slice con-
dition. Since there is a unique branch condition for each branch in-stance in the execution trace, the example in Figure 5 is on branchinstances for simplicity. On the left of Figure 5, the dependencies
among all the branch instances are provided. If there is an arrow
281No. from input path RSC
1‚ü®6,2,2‚ü©[b1t,b2f,b3t]¬¨(x+y>10)
2 1.1‚ü®6,5,2‚ü©[b1t,b2t,b3t](x‚àíy>0)‚àß(x+y>10)
3 2.2‚ü®6,2,2‚ü©[b1t,b2f,b3t]¬¨(x+y>10)
4 2.1‚ü®2,6,2‚ü©[b1f,b2f,b3t]¬¨(x+y>10)
Table 1: Path exploration based on relevant-slice conditions for example in Figure 1
No. from input path RSC reordered RSC
1‚ü®6,2,2‚ü©[b1t,b2f,b3t]¬¨(x+y>10) ¬¨(x+y>10)
2 1.1‚ü®6,5,2‚ü©[b1t,b2t,b3t](x‚àíy>0)‚àß(x+y>10)(x+y>10)‚àß(x‚àíy>0)
3 2.2‚ü®5,6,2‚ü©[b1f,b2t,b3t]¬¨(x‚àíy>0)‚àß(x+y>10)(x+y>10)‚àß¬¨(x‚àíy>0)
Table 2: Path exploration with reordered relevant-slice conditions for example in Figure 1
Algorithm 1 Path exploration using relevant-slice condition
1:Input:
2:P: The program to test
3:t: An initial test case for P
4:C: A slicing criterion
5:Output:
6:T: A test-suite for P
7:
8:Stack=null // The stack of partial rsc to be explored
9:Execute(t,0)
10:whileStack is not empty do
11: let‚ü®f,j‚ü©=pop(Stack)
12: iffis satisÔ¨Åable then
13: let Œºbe one input that satisÔ¨Åes f
14: put ŒºintoT
15: Execute(Œº,j)
16: end if
17:end while
18:returnT
19:
20:procedure Execute (t,n )
21: execute tinPand compute relevant-slice condition rsc
w.r.t.C
22: let rsc=œà1‚àßœà2‚àß...‚àßœàm‚àí1‚àßœàm
23: let rsc‚Ä≤=reorder(rsc)
24: suppose rsc‚Ä≤=œà‚Ä≤
1‚àßœà‚Ä≤
2‚àß...‚àßœà‚Ä≤
m‚àí1‚àßœà‚Ä≤
m
25: for all i from n+1 to m do
26: let h=(œà‚Ä≤
1‚àßœà‚Ä≤
2‚àß...‚àßœà‚Ä≤
i‚àí1‚àß¬¨œà‚Ä≤
i)
27: push‚ü®h,i‚ü©intoStack
28: end for
29: return
30:end procedure
31:
32:procedure reorder (seq )
33: if‚à£seq‚à£==0then
34: returnseq
35: end if
36: let seq beœà1‚àßœà2‚àß...‚àßœàk‚àí1‚àßœàk
37:seq1=true,seq2=true
38: for all i from 1 to k-1 do
39: ifbr(œài)is in relevant slice of br(œàk)then
40: seq1=seq1‚àßœài
41: else
42: seq2=seq2‚àßœài
43: end if
44: end for
45: returnreorder(seq1)‚àßœàk‚àßreorder(seq2)
46:end procedureb1 b2 b3 b4 b5 b6
b1 b3 b6 b5 b4 b2b1 b3b2 b4 b5
b5 b4 b2b2 b4
b4 b2b1 b2 b3 b4 b5 b6
b1 b3 b6 b2 b4 b5
b1 b3b5 b2 b4
Figure 5: Reorder algorithm in action
frombjtobi, thenbiis in the relevant slice of bj. The ‚Äúpivot‚Äù
in each reorder step is marked in dark; the other branches are re-
ordered w.r.t to the ‚Äúpivot‚Äù. For example, initially b6 is the pivot
and we reorder b1,...b5 depending on whether they are in the
relevant slice of b6.
In Algorithm 1, we use a stack to maintain the to-be-explored
partial relevant-slice conditions. The main algorithm keeps on pro-
cessing the formulae in the stack when it is not empty. In eachiteration, the algorithm pops out one partial relevant-slice condi-
tion from the stack, and checks whether it is satisÔ¨Åable or not. If
it is satisÔ¨Åable, we get a new input Œºby solving the formula. The
new input Œºcould lead to some unexplored relevant-slice condi-
tion. The relevant-slice condition for the execution trace of input
Œºis then explored, as shown by the procedure Execute in Algo-
rithm 1. Given the execution trace of Œº, the relevant-slice condition
over this trace w.r.t. the slicing criteria Cis Ô¨Årst computed. The
relevant-slice condition is reordered using the reorder procedure,
and the to-be-explored partial relevant-slice conditions are pushed
into the stack.
The second parameter of Execute is used to avoid redundancy
in path search. When Execute is called with parameters tandn,
let the reordered relevant-slice condition reordered_rsc(C,œÄ(t))
beœà
‚Ä≤
1‚àßœà‚Ä≤
2‚àß...‚àßœà‚Ä≤
m‚àí1‚àßœà‚Ä≤
m. For any partial relevant-slice condition
œïi=œà‚Ä≤
1‚àßœà‚Ä≤
2‚àß...‚àßœà‚Ä≤
i‚àí1‚àß¬¨œà‚Ä≤
i,1‚â§i‚â§n‚â§m, we know that
œïihas been pushed into the stack a-priori. So the for-loop in the
Execute procedure starts from n+1to avoid these explored partial
relevant-slice conditions.
282The path exploration of Algorithm 1 when employed on the pro-
gram in Figure 1 leads to the relevant-slice conditions shown in Ta-
ble 2. If the ‚Äúfrom‚Äù column of Table 2 contains Œ±.Œ≤ , it means that
the current input is generated by negating the Œ≤th branch constraint
of the reordered relevant-slice condition in theŒ±th row. The path
exploration based the reordered relevant-slice condition explores
all possible relevant-slice conditions of the program.
3.2 Theorems
Due to space limit, the proofs of the theorems are omitted in this
paper. The readers can refer to our technical report [13] for the
proofs.
Assumptions. We assume that the SMT solver used to solve
relevant-slice conditions is sound and complete. As mentioned ear-
lier, we assume that the slicing criteria is in a basic block that post-
dominates the entry of the program ‚Äî this is the location of the
program output. If the program contains multiple outputs, the slic-
ing criteria can simply be a set of of primitive criteria of the form
‚ü®output variable,output location‚ü©
Note that slicing can be performed on such a criteria (which is a
set) without any change to our method.
THEOREM 3.1. If the relevant-slice conditions of two paths œÄ1
andœÄ2w.r .t.Care the same, then the variables used in the slicing
criteriaChave the same symbolic values in œÄ1andœÄ2.
In Theorem 3.1, we show that the relevant-slice condition de-
termines the symbolic values of variables used in the slicing cri-teria ‚Äî if the relevant-slice conditions of two paths are the same,
the variables in the slicing criteria have the same symbolic values.Symbolic value can be computed by dynamic symbolic execution.Each symbolic value is an expression in terms of the program in-puts. Let sbe a statement instance in the path of input t, andvbe a
variable used in s. The symbolic value of vinsis an expression in
terms of input variables. If the symbolic value of vis concretized
witht, it must be the same as the value of vinswhen the program
is run concretely with input t.
T
HEOREM 3.2. Given a program Pand an execution trace œÄ(t)
for inputtinP, Algorithm 1 must explore an execution trace œÄ(t‚Ä≤)
for some input t‚Ä≤such that œÄ(t)andœÄ(t‚Ä≤)share the same relevant-
slice condition (irrespective of the initial test input with which Al-gorithm 1 is started) ‚Äî provided the total number of relevant-sliceconditions in Pis bounded.
In Theorem 3.2, given any feasible path œÄ, we show that our
path exploration algorithm is guaranteed to explore a path œÄ
‚Ä≤that
shares the same relevant-slice condition withœÄ. This establishes
the completeness of our path search.
4. IMPLEMENTATION
In this section, we discuss our combined infra-structure for sym-
bolic execution and dependency analysis of Java programs.
Our implementation is based on JSlice [17]1. JSlice is an open-
source dynamic slicing tool on Java bytecode. We have extendedJSlice to compute relevant-slice conditions. The architecture of our
extended JSlice is shown in Figure 6.
JSlice keeps the collected trace in a compressed form to achieve
scalability. The compression is online ‚Äî as the trace is gener-ated it is simultaneously compressed and then slicing is done on
1http://jslice.sourceforge.net/Slicing 
Criteria Input
Relevant Slice 
ConditionCustomized 
Kaffe JVMStatic 
Analysis
Relevant 
Slicing
Update 
OperStackUpdate 
PathCond Tree
Complete 
PathCond TreeCFG & CDGJava 
Class File
Relevant Slicing
Symbolic ExecutionBytecode
SliceCompressed 
Trace 
Figure 6: Architecture of relevant-slice condition computation
the compressed trace. The slicing algorithm works directly on thecompressed trace. We design our extension of JSlice to retain thisfeature (of analyzing compressed traces without decompression).
In Figure 6, relevant slicing and symbolic execution are sepa-
rated for ease of understanding. However, we do not need the entire
relevant slicing result to start computing relevant-slice condition
in the implementation. The process of constructing the relevant-
slice condition is done along with the backward relevant slicing to
achieve efÔ¨Åciency. Since the relevant slicing process is backward,we also compute the relevant slice condition via a backward sym-
bolic execution which starts from the slicing criteria and stops atthe beginning of the trace.
For backward symbolic execution, we keep a set of symbolic
values which need to be explained. The symbolic value of a vari-
ablevis explained by either an assignment to vor by program
input tov. Let us take the sample program in Figure 1 to show
our backward symbolic execution on a relevant slice. Note that
although we show this example at the source code level, our im-
plementation is at the Java bytecode level. Suppose the input is
‚ü®x==6,y==5,z==2‚ü©. The relevant slice for the execution trace
of this input is[5,6,7,10,11,16] . Backward symbolic execution
along this trace is shown in Table 3.
To construct the relevant-slice conditions, we need to precisely
represent the semantics of each bytecode type in the generated for-mula. There are more than 200 different bytecode types in the JavaVirtual Machine instruction set, and all of them are handled in ourimplementation. Our implementation also handles native method
calls (more details in the next paragraph). However, due to the
JSlice version that our implementation is based on, currently wecannot handle programs with multi-threading and reÔ¨Çection.
In the original implementation of JSlice, the concrete operand
values of most executed instructions are not stored in the com-
pressed trace as they are not needed in the slicing process. How-
283Relevant slice Symbolic To be explained Relevant slice condition
values variables
16 out = b; {out‚Üíb} {b} true
1 1b=a ; {out‚Üía,b‚Üía} {a} true
10 if(x+y > 10) {out‚Üía,b‚Üía} {x,y} x+y>10
7a=x ; {out‚Üíx,b‚Üíx,a‚Üíx} {x,y} x+y>10
6 if(x-y >0) {out‚Üíx,b‚Üíx,a‚Üíx} {x,y}x‚àíy>0‚àßx+y>10
5 scanf("%d %d %d",&x,&y,&z); {out‚Üíx,b‚Üíx,a‚Üíx} {x,y}x‚àíy>0‚àßx+y>10
Table 3: Backward symbolic execution example
ever, these values are needed when the semantics of some oper-
ations cannot be precisely modelled. In such cases, we have to
under-approximate the generated path condition/relevant-slice con-
dition by concretizing certain symbolic values in the relevant-slice
condition. For example, Java allows a program to use libraries writ-ten in other languages through native method call. Since the native
calls cannot be traced in Java Virtual Machine, the symbolic return
values from native calls cannot be precisely modelled. In this case,we simply concretize the symbolic return value from a native callusing the concrete return value of the native call (therefore, the con-crete return value of native calls are traced in our implementation).
In our implementation, we use the concept of execution index
[20] to uniquely identify a statement instance across different paths.Two statement instances in different paths are the same iff. theyhave exactly the same ‚Äúexecution index". In its simplest form, we
can use the path from root to a statement instance sin the Dy-
namic Control Dependence Graph of path œÄas the execution index
of statement instance sin pathœÄ.
As mentioned in Section 3, we need to reorder the branch condi-
tions in a relevant-slice condition in our path exploration process.
Letrs(C,œÄ)be the relevant slice on trace œÄw.r.t. the slicing cri-
teriaC. Letrsc(C,œÄ)be the relevant-slice condition computed
onrs(C,œÄ). To reorder the branch conditions in rsc(C,œÄ)using
the reorder procedure shown in Algorithm 1, we need to compute
a relevant slice using each branch instance in rs(C,œÄ)as the slic-
ing criteria. Suppose there are mbranch instances in rs(C,œÄ),
our implementation traverses the trace œÄformtimes to compute
themrelevant slices. In future, we plan to speed up this process,
by computing all mrelevant slices at the same time of computing
rs(C,œÄ). We also observe that there are a lot similarities among
the slices w.r.t. different branch instances (used as slicing criteria)
in the same trace. For example, if a branch instance b
iis in the
relevant slice of branch instance bj, then the relevant slice w.r.t. bi
is a subset of the relevant slice w.r.t. bj. In future, we could exploit
the similarities among these slices to further reduce the cost of ourreorder procedure.
Our execution engine is a combined infra-structure for dynamic
dependency analysis and dynamic symbolic execution. Thus, apart
from computing relevant-slice conditions, we can simply disable
the dependency analysis in our engine to compute path conditions.
The path conditions and relevant-slice conditions generated from
our tool are in the format of SMT2
2, which can be solved by var-
ious SatisÔ¨Åability Modulo Theory or SMT solvers. In our imple-mentation, we choose Z3 [4]
3as the SMT solver for our tool.
5. EXPERIMENTS
In the following, we Ô¨Årst compare our relevant-slice condition
based path exploration method with Directed Automated Random
2http://combination.cs.uiowa.edu/smtlib/
3http://research.microsoft.com/en-us/um/redmond/
projects/z3/Testing (DART). We then present an application of relevant-slice
conditions in the debugging of evolving programs.
5.1 Path exploration
We compare our path exploration algorithm with DART. The
subject programs shown in Table 4 are from SIR [5] repository.The lines of code (LOC) in each program are also shown.
Recall that our path search is complete as supported by Theorem
3.2. However, the completeness is difÔ¨Åcult to achieve in practice for
several reasons. Two of the main reasons are the limited power of
current SMT solvers and imprecise modelling of program seman-tics. Because of these reasons, our technique may miss a certainrelevant-slice condition rsc
iwhen DART can explore a path whose
relevant-slice condition isrsci. The example below explains how
imprecise modelling of array can cause our implementation to benot as complete as DART in terms of relevant-slice condition cov-
erage.
1 int x, y; //input
2 int out; //output
3 int a[2] = {0,1};4 scanf("%d %d", &x, &y);5 if(x > 0)6 printf("x is greater than zero\n");
7 if(a[x]>0){
8 if(y > 0)9 o u t=1 ;10 else
11 out = -1;12 }else{
13 out = 0;14 }15 printf("%d\n", out);//slicing criteria
In our current implementation, we concretize symbolic array index
using the value observed at execution time. Suppose the initial in-put for our method and DART are both ‚ü®x==0,y==0‚ü©. Due to the
concretization of symbolic array index, the branch at line 7 cannot
contribute a branch condition to either path condition or relevant-
slice condition. The path condition and relevant-slice condition for
‚ü®x==0,y==0‚ü©are¬¨(x>0)andtrue respectively. Since the
relevant-slice condition for the initial input ‚ü®x==0,y==0‚ü©is
true (containing no branch condition), our technique terminates.
However, some relevant-slice conditions are missed by our tech-
nique. In particular, the relevant-slice conditions of paths that eval-
uate branch at line 7 to false are missed. In contrast, DART could
explore all feasible paths (hence all relevant-slice conditions) of the
above program. Although the branch at line 5 cannot directly affectthe computation of out, it can help DART to negate the branch at
line 7 due to the correlation between the two branches. If arrays aremodelled precisely, this problem will disappear.
The ‚ÄúCompleteness‚Äù column in Table 4 measures how much
incompleteness in relevant-slice condition coverage is introduced
284Subject prog. Size (LOC) Completeness Time #Testcases Avg. formula size #Solver calls
RSC DART RSC DART RSC DART RSC DART
Tcas 113 100% 6.3s 13.1s 29 88 5744 64810 412 939
BinarySearchTree 175 75% 6.1s 58.6s 64 453 3836 49266 163 3188
OrdSet 211 79% 2.1s 7.4s 12 59 6444 55461 96 293
Schedule 257 100% 0.3s 15.4s 3 75 1808 13728 13 932
DisjointSet 102 100% 20.8s 64.8s 69 278 7643 170533 1192 3855
Table 4: Experiments in full program exploration
0 %10 %20 %30 %40 %50 %60 %70 %80 %90 %100 %
 0  2  4  6  8  10  12  14  16
Time (seconds)Algorithm 1
DART
(a) Tcas0 %10 %20 %30 %40 %50 %60 %70 %80 %90 %100 %
 0  10  20  30  40  50  60  70
Time (seconds)Algorithm 1
DART
(b) BinarySearchTree0 %10 %20 %30 %40 %50 %60 %70 %80 %90 %100 %
 0  1  2  3  4  5  6  7  8
Time (seconds)Algorithm 1
DART
(c) OrdSet
0 %10 %20 %30 %40 %50 %60 %70 %80 %90 %100 %
 0  2  4  6  8  10
Time (seconds)Algorithm 1
DART
(d) Schedule0 %10 %20 %30 %40 %50 %60 %70 %80 %90 %100 %
 0  10  20  30  40  50  60  70
Time (seconds)Algorithm 1
DART
(e) DisjointSet
Figure 7: Relevant-slice condition coverage comparison
by the imprecise modelling of program semantics in our imple-
mentation. The numbers in the ‚ÄúCompleteness‚Äù column are com-
puted as follows. Let the program being explored be P. We em-
ploy DART on Pto explore program paths and construct a test-
suiteTDART‚àíALL which contains the set of all paths in Pcov-
ered by DART. For each test case tinTDART‚àíALL , we compute
the relevant-slice condition on the execution trace of tand put this
relevant-slice condition into a set SDART‚àíALL . Similarly, we gen-
erate a test-suite TRSC for program Pusing our path exploration
method. For each test case tinTRSC , we compute the relevant-
slice condition on the execution trace of tand put this relevant-
slice condition into a set SRSC . Then the ‚ÄúCompleteness‚Äù column
in Table 4 is‚à£SRSC‚à£
‚à£SDART ‚àíALL‚à£. As shown in Table 4, our method can-
not always achieve 100 percent relevant slice coverage as compared
to DART due to the imprecise modelling of program semantics in
our implementation. Note that this does not affect the validity of
the completeness claim in Theorem 3.2, the incompleteness is onlyin the implementation.
In columns 4-11 of Table 4, we compare the time, number of
generated test cases, formula size and number of solver calls be-tween our method and DART. The formula size is measured bythe number of bytes in the SMT2 formula Ô¨Åle. For getting thesenumbers, both our method (RSC) and the DART method are run to
completion, and the running time is recorded. Note that the time
reported in Table 4 includes the time taken in every steps of ourmethod and DART. For example, the time taken by our method
includes the time for program execution, relevant slicing, relevant-
slice condition computation, branch condition reordering, formula
solving, etc. As shown in Table 4, our technique takes much lesstime than DART. The efÔ¨Åciency comes from several sources. First,since we use relevant-slice condition instead of path condition, the
formula size of our approach is much smaller than that of DART.
This reduces the time taken by the solver. Second, the number of
different relevant-slice conditions is considerably smaller than the
number of path conditions. This reduces both the number of exe-cutions and the number of solver calls.
Figure 7 compares the relevant-slice condition coverage of our
Algorithm 1 with Directed Automated Random Testing (DART)under the same time limit. Note that DART intends to achieve pathcoverage. However, as we have observed - several paths may havethe same input-output relationship, and testing is always done by
checking outputs. We check the number of relevant-slice condi-
tions that are covered by the paths explored in DART search. As
shown in Figure 7, our technique gets higher relevant-slice condi-
tion coverage then DART when the given time is short.
5.2 Debugging of evolving programs
The obvious application of relevant-slice conditions is in soft-
ware testing - it groups program paths and can be used to efÔ¨Åciently
generate a concise test-suite. We now show another application of
relevant-slice conditions namely in the debugging of evolving pro-
285Subject prog. Stable version Buggy version Diff Time Debugging results
PC RSC PC RSC
JLex 1.2.1 (7290 LOC) 1.1.1 (6984 LOC) 518 LOC 543 min 15 min 50 LOC 3 LOC
JTopas 0.8 (4514 LOC) 0.7 (5754 LOC) 2489 LOC 81 min 5 min 4 LOC 4 LOC
Table 5: DARWIN debugging results (LOC stands for Lines of Code)
grams. As a program evolves, functionality which worked earlier
breaks. This is commonly known as software regressions. For any
large scale software development, debugging the root-case of re-gressions is an extremely time consuming activity.
We applied our relevant-slice conditions on the DARWIN method
for debugging evolving programs [14]. Given two program ver-sionsPandP
‚Ä≤, and a test case twhich passes in Pbut fails in
P‚Ä≤, the work in [14] tries to Ô¨Ånd the root cause of the failure of t
inP‚Ä≤. The debugging proceeds by computing and composing the
path conditions of tinPandP‚Ä≤, as follows.
First, the path conditions fandf‚Ä≤oftinPandP‚Ä≤are computed.
We then compute the formula f‚àß¬¨f‚Ä≤as follows. Suppose f‚Ä≤is
f‚Ä≤=(œà1‚àßœà2‚àß...‚àßœàm)whereœàiare primitive constraints. The
following mformulae{œïi‚à£0‚â§i<m} are then solved where
œïidef=f‚àßœà1‚àß...œài‚àß¬¨œài+1. We invoke a SatisÔ¨Åability Modulo
Theory or SMT solver to solve the mformulae{œïi‚à£0‚â§i<m} .
Finally, for every œïiwhich is satisÔ¨Åable, we can Ô¨Ånd a single line in
the source code which is a potential error root cause ‚Äî the branchcorresponding to œà
i+1(which is negated in œïi).
We observe that the path conditions fandf‚Ä≤in the above method
can be replaced by relevant-slice conditions. Path condition is not
‚Äúgoal-directed‚Äù ‚Äî it contains the constraints of branches which are
not ‚Äúrelated‚Äù to the observable error. In particular, a path condi-
tion will typically contain constraints for branches which are not in
the dynamic or relevant slice of the observable error. Consider thefollowing example program
1 ... // input inp1, inp2
2 if (inp1 > 0)3 x=i n p 1+1 ;
4 else
5 x=i n p 1-1 ;
6 if (inp2 > 0)
7 y=i n p 2+18 else
9 y=i n p 2-1 ;
10 ... // output x, y
Suppose the observed value of xis unexpected for inp1 ==
inp2 == 0 because of a ‚Äúbug‚Äù in line 2 (say, the condition should
beinp1 >= 0). The path condition is ¬¨(inp1>0)‚àß¬¨(inp2>
0). Clearly, the constraint ¬¨(inp2>0)corresponding the the
branch in line 6 is unrelated to the observable error (unexpected
value of x). Indeed, line 6 is not in the dynamic slice or relevant
slice of the slicing criterion corresponding to the output value of x
in line 10.
Thus, due to the inherent parallelism in sequential programs,
path conditions contain constraints for branches which are not inthe slice of the observed error. Composing these path conditions
for debugging then allows for such ‚Äúunrelated‚Äù branches to be in-
corporated into the bug report (which is output by the debuggingmethod). Indeed including these ‚Äúunrelated‚Äù branch constraints in-creases the burden on the SMT solvers invoked by the DARWIN
method, both in terms of the size of the formulae and the num-
ber of the formulae to solve. In addition, these ‚Äúunrelated‚Äù branchconstraints also introduce some false positives into the bug reportproduced by the DARWIN method.
Replacing path condition with relevant-slice condition in the DAR-
WIN method resolves these issues. Thus, given a test case tthatpasses in the old version program Pbut fails in the new version
programP
‚Ä≤‚Äî we now compute gandg‚Ä≤, the relevant-slice con-
dition oftinPandP‚Ä≤respectively. We then solve g‚àß¬¨g‚Ä≤in a
manner similar to the solving of f‚àß¬¨f‚Ä≤in DARWIN (where f,f‚Ä≤
were the path conditions of tin programs P,P‚Ä≤).
We compare the debugging result of DARWIN using relevant-
slice conditions with the original DARWIN method (which uses
path conditions) in Table 5.
Both methods are fully automated. We did not use the same SIR
programs as used in Section 5.1 because debugging regression er-rors for SIR programs are usually trivial. This is because the differ-
ence between two SIR program versions is usually small. The Ô¨Årst
subject program being used is JLex
4.JLex is a lexical analyzer
generator written in Java. We use version 1.2.1 of JLex as the sta-
ble version, and version 1.1.1 as the buggy version. There are 6984
and 7290 lines of code in version 1.1.1 and version 1.2.2 respec-
tively. The changes across version 1.1.1 and version 1.2.1 consistof 518 lines of code. In particular, the version 1.1.1 of JLex can-
not recognize ‚Äò\r‚Äô as the newline symbol, while in version 1.2.1 thisbug is Ô¨Åxed. We use an input Ô¨Åle manifesting this bug.
The experimental results from DARWIN using relevant-slice con-
ditions vs. the original DARWIN method appears in Table 5. The
original DARWIN method, which uses path conditions, takes 543minutes (or 9 hours) to perform the debugging. The result of DAR-
WIN is a bug report containing 50 lines of code, which are high-
lighted to the programmer as potential root-causes of the observ-able error. In contrast, DARWIN using relevant-slice condition
takes only 15 minutes. The result is a bug report containing only3 lines of code ‚Äî potential root causes of the observed error. In-
deed, the actual error root-cause lies in one of these three lines of
code. Thus, by using relevant-slice conditions inside our DARWIN
debugging method - we could avoid 47 false positives among thepotential error causes which are reported to the programmer. More-
over, there is a huge savings in the debugging time (15 minutes vs 9
hours) which comes from the relevant-slice conditions being much
smaller than path conditions.
We also conducted experiments using JTopas
5as the subject
program. JTopas is a Java library for parsing arbitrary text data.
We use version 0.8 of JTopas as the stable version, and ver-
sion 0.7 as the buggy version. There are 5754 and 4514 lines ofcode in version 0.7 and version 0.8 respectively. JTopas allows
users to customize whitespace characters (i.e. characters that are
considered as whitespace characters) by using function setWhites-
paces. JTopas also uses a boolean Ô¨Åeld _defaultWhitespaces to
control whether the default whitespace characters are used or the
user-customized whitespace characters are used. To use the cus-tomized whitespace characters, _defaultWhitespaces has to be set
tofalse. Unfortunately, the buggy JTopas-0.7 does not reset
the member _defaultWhitespaces leading to the default whitespace
characters still being used instead of the customized ones althoughthe user has speciÔ¨Åed the custom whitespace characters. In our
experiment, we customize whitespace characters to {‚Äò ‚Äô, ‚Äò\r‚Äô,‚Äò\t‚Äô}
({‚Äò ‚Äô, ‚Äò\n‚Äô, ‚Äò\r‚Äô,‚Äò\t‚Äô} by default) and use an input Ô¨Åle manifesting
4http://www.cs.princeton.edu/~appel/modern/java/JLex/
5http://jtopas.sourceforge.net/jtopas/index.html
286the aforementioned bug. The debugging results of DARWIN us-
ing path condition and DARWIN using relevant-slice condition are
shown in Table 5. The results from the original DARWIN method(using path condition) and DARWIN using relevant-slice condi-
tion are both four lines of code. They both contain the location
where ‚Äò\n‚Äô is treated differently between the two versions. The pin-pointed location shows that the stable version does not consider
‚Äò\n‚Äô as a whitespace. In contrast, the buggy version still treats ‚Äò\n‚Äô
as a whitespace because _defaultWhitespaces istrue (even though
whitespace characters have already been customized). From thisclue, the programmer could easily infer that the member _default-
Whitespaces was not assigned to the correct value. Although using
relevant-slice condition does not eliminate any false positives in the
debugging result, it does reduce the time taken by DARWIN from81 minutes to 5 minutes.
6. THREATS TO V ALIDITY
Our path exploration does not try to cover all paths. Instead, we
try to group paths based on symbolic outputs. This is done with
the goal of test-suite construction, where testing will expose pos-
sible failures in the program. However, failure of a test case doesnot only come from unexpected outputs - it can also come fromprogram crashes. Thus, for the paths which we do not explore if
they contain program crashes - these will not be exposed by the
test-suite computed by our technique. Realistically, our test-suiteconstruction could be supplemented by techniques to statically de-tect possible program crashes, such as memory error detection [19].
Due to the conservative nature of static analysis used in comput-
ing relevant slice, our technique may under-approximate relevant-
slice conditions in some situations. In that case, we may explore
more than one paths that have the same relevant-slice condition.
Consider the following program
101 if(x > 0){
102 p.num = 0;103 }104 out = q.num;
Suppose pandqnever alias to each other. If the static analysis can-
not determine the non-alias between pandq, line 104 is potential
dependent on line 101 when the branch at line 101 is evaluated to
false. Therefore, the branch at line 101 is included in relevant slice
and our technique will try to explore both directions of the branch atline 101, which is unnecessary. Note that this under-approximationofrelevant-slice condition only causes duplicated exploration of
some relevant-slice conditions , it does not affect the completeness
claim of our technique.
Although our technique considerably improves the efÔ¨Åciency of
the path exploration, the path explosion problem still exist. In theworst case, the number of relevant-slice conditions grows exponen-
tially with the size of the program.
7. RELATED WORK
The technique proposed in this paper is based on dynamic path
exploration [8, 16] and relevant slicing [1, 9, 17]. Our techniqueimproves existing dynamic path exploration techniques by group-ing several paths together using relevant-slice condition. Existing
dynamic path exploration tries to achieve path coverage. In con-trast, our technique only selects one path from each relevant-slice
condition to explore.
There are several works which focus on improving the efÔ¨Åciency
of dynamic path exploration. In [6], function summaries are gen-
erated and exploited. In [7], the grammar of the input is used toavoid generating large percentage of invalid inputs. Our approach
is orthogonal to these approaches, therefore, our approach can becombined together with any of these approaches to further improvethe efÔ¨Åciency of the path search.
In [15], a program is statically decomposed into several path
families, where each path family contains several paths that sharesimilar behavior. Instead of analyzing each path individually, a pro-gram can be analyzed at the granularity of path family. The authors
of [15] also compute a ‚Äúpath family condition‚Äù for each path fam-
ily, which could characterize that path family. The path partitionbased on relevant-slice condition is different from the notion of
‚Äúpath family‚Äù in [15] in the sense that ‚Äúpath family‚Äù is more gen-eral. For example, all program paths in Figure 1 can be grouped
into one path family, but they are grouped into three partitions by
our technique. At the same time, ‚Äúpath family condition‚Äù doesnot guarantee the same input-output relationship, whereas relevant-
slice condition does. The main difference between our work and
[15] lies in the static vs. dynamic nature of the two techniques. Thework in [15] statically computes their path family conditions, whilewe dynamically explore the relevant-slice conditions. Because of
the dynamic nature of our method, we can under-approximate therelevant-slice conditions , while [15] over-approximates their ‚Äúpath
family conditions" if needed. Clearly, the dynamic nature of ourmethod makes it more suitable for test generation. Note that theeffect of program statements written in real-life programming lan-guages are hard to precisely model as symbolic formulae. In such
a situation, under-approximation is a practical simpliÔ¨Åcation, since
it amounts to concretizing parts of the formula.
Other researches have also used the notion of ‚Äúpath equivalence‚Äù
to alleviate the path explosion problem. However, what paths areconsidered equivalent are different between our work and earlier
works. The difference in the deÔ¨Ånition of path equivalence origi-
nates from the different goals of our work and earlier works. In [2],the goal is to explore all possible program states. Based on thisgoal, two paths are equivalent if the symbolic states of all live vari-
ables are the same. In contrast, we only consider the variables that
can affect the output ‚Äì two paths are equivalent if they have thesame symbolic expression for the output. In [11], the goal is toreach some critical locations in a program. Therefore, two pathsare equivalent if they cannot reach any critical locations for the
same reason (blocked by the same condition).
Apart from the application of relevant-slice condition in debug-
ging mentioned in Section 5, there are many other path condition
based techniques that could beneÔ¨Åt from relevant-slice condition.
Our relevant-slice condition can be used to minimize an existing
test-suite [10, 18]. If a test-suite contains two test cases that havethe same relevant-slice condition, these two test cases compute the
output in the same way. Therefore, we can choose to eliminate oneof them to make the test-suite smaller.
The work in [3] explores paths to generate program invariants.
For each path explored, the path condition serves as a pre-conditionand the symbolic program output is treated as a post-condition.Thus, each explored path produces a program invariant which is
deÔ¨Åned as such a (pre-condition, post-condition) pair. Similar ap-
proaches are used in [6, 12] to generate method summaries. In-stead of using path condition, we can generate such program in-variants using relevant-slice conditions ‚Äî the relevant-slice condi-
tion is the pre-condition and for each relevant-slice condition ex-
plored, there is a unique symbolic output which serves as the post-condition. Moreover, the invariants generated using relevant-slice
conditions will be simpler (as relevant-slice conditions are smaller
than path conditions) and fewer (since a single relevant-slice con-
dition groups more paths).
2878. DISCUSSION
In this paper, we have presented a novel path exploration method
based on symbolic program outputs. Our path exploration dynam-
ically groups paths on-the-Ô¨Çy, where two paths that have the samesymbolic output are grouped together. Given such a path partition-ing, we can generate a test case from each partition. This enables usto efÔ¨Åciently obtain a concise test-suite which stresses all possibleinput-output relationships in the program.
Our path exploration method is complete, that is, it covers all
possible symbolic outputs in a given program. We also experimen-
tally compare the efÔ¨Åciency and coverage of our method with re-
spect to Directed Automated Random Testing, another path searchmethod based on symbolic execution.
Apart from testing, the path partitioning computed by our method
can be exploited in other software engineering activities. We haveshown its use in the debugging of errors introduced by programchanges, that is, in root-causing observable software regressions.By comparing the path partitioning in two program versions, weinfer the semantic differences across the versions, leading to pre-
cise root cause identiÔ¨Åcation.
Acknowledgements. This work was partially supported by a
Ministry of Education research grant MOE2010-T2-2-073 (R-252-
000-456-112 and R-252-100-456-112), as well as a Defence In-novative Research Programme (DIRP) grant (R-252-000-393-422)
from Defence Research and Technology OfÔ¨Åce (DRTech).
9. REFERENCES
[1] H. Agrawal, J. R. Horgan, E. W . Krauser, and S. London.
Incremental regression testing. In Proceedings of the
Conference on Software Maintenance, ICSM ‚Äô93, pages348‚Äì357, Washington, DC, USA, 1993. IEEE Computer
Society.
[2] P . Boonstoppel, C. Cadar, and D. Engler. Rwset: Attacking
path explosion in constraint-based test generation. Tools and
Algorithms for the Construction and Analysis of Systems,
pages 351‚Äì366, 2008.
[3] C. Csallner, N. Tillmann, and Y . Smaragdakis. Dysy:
dynamic symbolic execution for invariant inference. In
Proceedings of the 30th international conference onSoftware engineering, ICSE ‚Äô08, pages 281‚Äì290, New Y ork,NY , USA, 2008. ACM.
[4] L. De Moura and N. Bj√∏rner. Z3: An efÔ¨Åcient smt solver.
Tools and Algorithms for the Construction and Analysis ofSystems, pages 337‚Äì340, 2008.
[5] H. Do, S. Elbaum, and G. Rothermel. Supporting controlled
experimentation with testing techniques: An infrastructureand its potential impact. Empirical Software Engineering,
10(4), 2005.
[6] P . Godefroid. Compositional dynamic test generation. In
Proceedings of the 34th annual ACM SIGPLAN-SIGACTsymposium on Principles of programming languages, POPL‚Äô07, pages 47‚Äì54, New Y ork, NY , USA, 2007. ACM.
[7] P . Godefroid, A. Kiezun, and M. Y . Levin. Grammar-based
whitebox fuzzing. In Proceedings of the 2008 ACM
SIGPLAN conference on Programming language design and
implementation, PLDI ‚Äô08, pages 206‚Äì215, New Y ork, NY ,
USA, 2008. ACM.
[8] P . Godefroid, N. Klarlund, and K. Sen. DART: directed
automated random testing. In Proceedings of the 2005 ACM
SIGPLAN conference on Programming language design andimplementation, PLDI ‚Äô05, pages 213‚Äì223, New Y ork, NY ,USA, 2005. ACM.
[9] T. Gyim√≥thy, A. Besz√©des, and I. Forg√°cs. An efÔ¨Åcient
relevant slicing method for debugging. In Proceedings of the
7th European software engineering conference held jointly
with the 7th ACM SIGSOFT international symposium on
F oundations of software engineering, ESEC/FSE-7, pages303‚Äì321, London, UK, 1999. Springer-V erlag.
[10] M. J. Harrold, R. Gupta, and M. L. Soffa. A methodology for
controlling the size of a test suite. ACM Trans. Softw. Eng.
Methodol., 2:270‚Äì285, July 1993.
[11] K. McMillan. Lazy annotation for program testing and
veriÔ¨Åcation. In Computer Aided V eriÔ¨Åcation, pages 104‚Äì118.
Springer, 2010.
[12] S. Person, M. Dwyer, S. Elbaum, and C. Pasareanu.
Differential symbolic execution. In Proceedings of the 16th
ACM SIGSOFT International Symposium on F oundations of
software engineering, pages 226‚Äì237. ACM, 2008.
[13] D. Qi, H. D. T. Nguyen, and A. Roychoudhury. Path
exploration based on soymbolic output. Technical report,
http://dl.comp.nus.edu.sg/dspace/handle/1900.100/3347, March 2011.
[14] D. Qi, A. Roychoudhury, Z. Liang, and K. V aswani.
DARWIN: an approach for debugging evolving programs. In
Proceedings of the the 7th joint meeting of the European
software engineering conference and the ACM SIGSOFTsymposium on The foundations of software engineering,ESEC/FSE ‚Äô09, pages 33‚Äì42, New Y ork, NY , USA, 2009.
ACM.
[15] R. Santelices and M. J. Harrold. Exploiting program
dependencies for scalable multiple-path symbolic execution.
InProceedings of the 19th international symposium on
Software testing and analysis, ISST A ‚Äô10, pages 195‚Äì206,New Y ork, NY , USA, 2010. ACM.
[16] K. Sen, D. Marinov, and G. Agha. Cute: a concolic unit
testing engine for c. In Proceedings of the 10th European
software engineering conference held jointly with 13th ACMSIGSOFT international symposium on F oundations ofsoftware engineering, ESEC/FSE-13, pages 263‚Äì272, NewY ork, NY , USA, 2005. ACM.
[17] T. Wang and A. Roychoudhury. Dynamic slicing on Java
bytecode traces. ACM Trans. Program. Lang. Syst.,
30:10:1‚Äì10:49, March 2008.
[18] W . E. Wong, J. R. Horgan, S. London, and A. P . Mathur.
Effect of test set minimization on fault detectioneffectiveness. In Proceedings of the 17th international
conference on Software engineering , ICSE ‚Äô95, pages 41‚Äì50,
Ne
w Y ork, NY , USA, 1995. ACM.
[19] Y . Xie, A. Chou, and D. Engler. Archer: using symbolic,
path-sensitive analysis to detect memory access errors. InProceedings of the 9th European software engineeringconference held jointly with 11th ACM SIGSOFT
international symposium on F oundations of software
engineering, ESEC/FSE-11, pages 327‚Äì336, New Y ork, NY ,USA, 2003. ACM.
[20] B. Xin, W . N. Sumner, and X. Zhang. EfÔ¨Åcient program
execution indexing. In Proceedings of the 2008 ACM
SIGPLAN conference on Programming language design and
implementation, PLDI ‚Äô08, pages 238‚Äì248, New Y ork, NY ,
USA, 2008. ACM.
288