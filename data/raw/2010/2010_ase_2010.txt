PLASMA: A Plan-based Layered Architecture
for Software Model-driven Adaptation
Hossein Tajalli, Joshua Garcia, George Edwards, and Nenad Medvidovic
Computer Science Department
University of Southern California
Los Angeles, CA 90089-0781, USA
{tajalli,joshuaga,gedwards,neno}@usc.edu
ABSTRACT
Modern software-intensive systems are expected to adapt, often
while the system is executing, to changing requirements, failures,and new operational contexts. This paper describes an approach todynamic system adaptation that utilizes plan-based and architecture-
based mechanisms. Our approach utilizes an architecture descrip-
tion language (ADL) and a planning-as-model-checking technol-ogy to enable dynamic replanning. The ability to automaticallygenerate adaptation plans based solely on ADL models and an ap-plication problem description simpliﬁes the speciﬁcation and use of
adaptation mechanisms for system architects. The approach uses a
three-layer architecture that, while similar to previous work, pro-vides several signiﬁcant improvements. We apply our approachwithin the context of a mobile robotics case study.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and
Techniques; D.2.11 [ Software Engineering ]: Software Architec-
ture
General Terms
Design, Management, Reliability
Keywords
Self-*, software adaptation, software architecture, software evolu-tion, planning, model-driven software, component-based software
1. INTRODUCTION
Modern software systems are increasingly expected to satisfy
high reliability and availability requirements. In particular, thesesystems are expected to alter and extend their functionality, handle
failures of software and hardware components, and apply updates
and bug ﬁxes while the system is executing.
To provide these capabilities, several software architecture-based
self-adaptive and self-aware systems [6, 12, 21, 9] have beenproposed in the literature. A software architecture-based approach
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, torepublish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.to dynamic system adaptation has several advantages. Architecture-
based approaches utilize composition, hierarchy, and abstractionto reduce complexity and increase scalability. Furthermore, a richarea of existing work on software architecture modeling and anal-ysis can be exploited. For example, architecture description lan-guages (ADLs) [23] can be used to specify a system that must un-
dergo runtime adaptation, and architectural analysis techniques can
be used to examine the implications of system adaptations.
Previous work in self-adaptive and self-managing systems can
be categorized across two prevalent adaptation mechanisms: poli-cies and plans. Policies are sets of condition-action rules that spec-ify how the system should be modiﬁed when a speciﬁc condition
is met. An example is the policy-based approach to architectural
adaptation management (PBAAM) [9]. On the other hand, plansare sequences of actions that achieve a high-level goal. Plans areautomatically generated by ﬁnding a path from the current systemstate to a goal state in a model of the system domain. Sykes et al.’s
three-layer model [21] is an example of a plan-based approach.
Thus far, plan-based approaches have been limited to pre-
computed plans for application adaptation and have lacked the abil-ity to dynamically generate new plans when system requirementschange. Furthermore, planning mechanisms have only been ap-plied to core application functionality, and have not been applied
to application architecture adaptation. These approaches are, thus,
unable to dynamically compute new adaptation plans that are usedto modify application architectures in response to unforeseeable
events, such as new system requirements, a change in the executionenvironment, or an unexpected type of failure.
In this paper, we introduce PLASMA (a Plan-based Layered Ar-
chitecture for Software Model-driven Adaptation). PLASMA uti-
lizes an ADL and a planning-as-model-checking technology [10] toenable dynamic replanning in the architectural domain. We utilizeADL models and system goals as inputs for generating plans. Inparticular, our solution has the ability to generate new plans in re-sponse to changing system requirements and goals and in the case
of unforeseeable component failures.
The contributions of our paper are twofold. First, we show how
planning techniques can be applied not only to application func-tionality, but to application architecture adaptation, which resultsin the ability to automatically modify application architectures in
order to achieve a system goal when the current architecture is in-
adequate. Second, we show how dynamic replanning can be usedwhen the application domain or system goal changes, which resultsin the ability to automatically handle unexpected circumstances.
The rest of the paper is organized as follows. Section 2 describes
our framework’s architecture and PLASMA’s use of domain mod-
els, component models, and planning. Section 3 details PLASMA’s
design and implementation. Section 4 demonstrates how we ap-1 2 3 4unlock lock load
lock unload unlock
Ø Loaded LockedLoaded
ȁLocked(a)
unload
1 2 3 4unlocklockload
lock unload unlock
Loaded
ȁLocked5
adjust
Ø LoadedMisplaced(b)
Lockedload
Figure 1: (a) An example application domain model. (b) The
example extended with an additional capability.
plied PLASMA in a mobile robotics case study and discusses the
beneﬁts observed. Section 5 covers the related work , and Section 6concludes the paper.
2. APPROACH
In this section, we provide a high-level summary of the PLASMA
approach to automated self-adaptation and self-management forsoftware systems; the details of PLASMA’s design and implemen-
tation are then provided in Section 3. First, we explain the two
types of domain models that are utilized in PLASMA: applicationdomain models and adaptation domain models. Second, we de-scribe how PLASMA leverages an adaptive layered architectureto achieve a high-degree of autonomy and a clear separations ofconcerns. Third, we discuss the role of architectural modeling in
PLASMA. Lastly, we describe how PLASMA applies planning
techniques to realize dynamic replanning in a self-adapative sys-tem.
2.1 Domain Models
PLASMA is based on the novel application of planning mecha-
nisms to two different types of models: application domain mod-
elsandadaptation domain models . Application domain models
capture the possible states of application components and actionsthat those components may perform. Each action modiﬁes the ap-
plication state in a deﬁned way. Analogously, adaptation domain
models capture architectural states and actions: each state in theadaptation domain model corresponds to a particular architecturalconﬁguration, and actions in the adaptation domain model corre-spond to architectural modiﬁcations, such as the addition, removal,
and replacement of components. While previous work has applied
planning to application domains, PLASMA is unique in its usageof adaptation domains.
Both application domain models and adaptation domain models
consist of the states of the domain, available actions in the domain,
and the state transitions caused by those actions. Therefore, a do-
main model is formally deﬁned as a 4-tuple < F,S,A,R> in which,
Fis a ﬁnite set of ﬂuents which represent the state variables of the
system, S⊆2
Fis a ﬁnite set of states, Ais a ﬁnite set of actions
andR:S×A/mapsto−→Sis a transition function.
Figure 1 depicts two example application domain models. The
ﬁrst application domain model represents a system where an item
can be loaded/unloaded to/from a container which, in turn, can belocked/unlocked. Figure 1(a) is a graphical presentation of the do-
main model for this example in which Loaded andLocked are the
ﬂuents of the domain, circles represent the states, and arrows rep-resent the actions as well as system transitions in the model. Thelabel assigned to each state in this ﬁgure is the conjunction of theﬂuents which are true in that state. For the case where a system re-quirements change occurs, consider the domain model depicted in
Figure 1(b). In this ﬁgure, a new ﬂuent called Misplaced and a new
state are added to handle the case where an item may be misplaced.
Figure 2 depicts an example adaptation domain model. In this
example domain, software components can be instantiated/killed,added/removed to/from an architecture, and connected/disconnect-ed to/from another component in that architecture. The states of
this adaptation domain model are the various architectural conﬁg-
urations involving C1 and C2. For example, state 7 corresponds toan architecture in which C1 and C2 exist but are not connected.
In the remainder of this section, we show how these two types
of domain models are utilized for software adaptations in PLASMA.
2.2 Adaptive Layered Architecture
In our approach, we leverage the adaptive layered architectural
style which was introduced in our previous work [5]. Tradition-
ally, layering implies that components at a given layer invoke the
services of components at the layer below. In contrast, compo-
nents at a given layer in the adaptive layered style monitor, man age,
and adapt components at the layer below. Adaptive layered sys-
tems consist of application-level components and meta-level com-
ponents. Application-level components implement functionality
that achieves the application goals. Meta-level components aredesigned to handle operations that deal with monitoring, analysis,and adaptation. Meta-level components can be one of three types:Collectors ,Analyzers ,o rAdmins .Collectors monitor components,
Analyzers evaluate adaptation policies or plans based on monitored
data, and Admins actually modify components.
Although the adaptive layered style allows for layering of arbi-
trary depth, PLASMA employs three adaptive layers, as shown inFigure 3. Application-level components reside in the bottom appli-
cation layer . The middle layer, called the adaptation layer moni-
tors, manages, and adapts components in the application layer. The
topmost planning layer manages the adaptation layer and the gen-
eration of plans based on user-supplied goals and component speci-ﬁcations. The plans generated by the planning layer deﬁne both thetarget architecture for the application layer (the adaptation plan )
and the actions to be carried out by the application layer (the appli-
cation plan ). Therefore, the planning layer is capable of responding
to changing system requirements or operational environments by
regenerating plans. This three-layered architecture enforces a clearseparation of concerns, whereby each layer in the system providesa different form of adaptation capability, and enables a high-degreeof autonomy.
In PLASMA, the only inputs provided by the system architect
are (1) the application problem description, (2) component spec-iﬁcations written in an ADL, and (3) executable implementationsof the components. The problem description consists of an initialstate and a goal. The component ADL models are used by the ADL
Model Parser components in the planning layer to generate appli-
cation and adaptation domain model descriptions , as depicted in
Figure 3. A domain model description presents a domain modelin a standard language which is required for planning. Domainmodel descriptions, along with the problem description, are pro-vided to the Application Planner andAdaptation Planner compo-
nents depicted in the planning layer in Figure 3. Each of these two
components generates a plan for one of the two bottommost lay-Instantiate(C1)
12
45
3 67 8Kill(C1)Add(C1)
Remove(C1)
Kill(C2)Instantiate(C2)
Remove
(C2)Add
(C2)Kill(C2)Instantiate
(C2)
Instantiat(C1)
Kill(C1)Remove
(C2)Add
(C2)
Add(C1)
Remove(C1)Disconnect(C1,C2)Connect(C1,C2)
Exist(C1)
ȁExist(C2)Ø
Exist(C2)Exist(C1)
Exist(C1)
ȁExist(C2)
ȁArchIncludes(C2)Exist(C1)
ȁExist(C2)
ȁArchIncludes(C1)
Exist(C1)
ȁExist(C2)
ȁArchIncludes(C1)
ȁArchIncludes(C2)Exist(C1)
ȁExist(C2)
ȁArchIncludes(C1)
ȁArchIncludes(C2)
ȁConnected(C1,C2)
Figure 2: An example adaptation domain model.
Sensor
(sense)Executor
(compute)Loader (control)Domain
stateAdaptation
Analyzer
(compute)Analyzer
(compute)Arch
StateAction
Req
Application
ComponentApplication
LayerAdaptation
LayerPlanning
Layer
Key: Event
Collector Analyzer AdminLocker (control)Adaptation Planner
Arch
stateAction
Req
Action
ReqAction
ReqCollector
(sense)
ReferenceApplication Planner
Admin
(control)Adaptation Layer
ArchitectureADL Model
ParserADL Model
Parser
Adaptation
ProblemAdaptation Domain
DescriptionApplication Domain
DescriptionApplication
ProblemApplication Layer
ADL ModelsAdaptation Layer
ADL Models
Admin
(control)
Collector
(sense)
Adaptable
Entity
Figure 3: The PLASMA adaptive layered architecture.
ers: the Application Planner generates a plan for the application
layer which speciﬁes how to achieve the application goal, whiletheAdaptation Planner generates a plan for the adaptation layer
which speciﬁes how to arrive at the target application architecture.
Each of the two bottommost layers contain a special component
that executes the plans generated by the top layer’s planner compo-nents. The adaptation layer contains an Adaptation Analyzer that
executes plans generated by the Adaptation Planner .The Adap-
tation Analyzer uses the plan to determine how and under what
conditions components in the application layer should be added,
removed, replaced, or otherwise altered. The application layer con-tains a special component called the Executor , which executes plans
generated by the Application Planner . The Executor examines the
state of application components and, based on their state and theplan received from the Application Planner , invokes the function-
ality of application components to perform tasks.2.3 Architectural Modeling
As previously noted, components in PLASMA must be speciﬁed
in an ADL and passed to the ADL Model Parsers in the topmost
layer in Figure 3. ADL models are used to generate domain model
descriptions which are required for planning. To be able to gen-
erate domain models from ADL models, the ADL used must carryenough information from which a 4-tuple domain model,<F,S,A,R>, can be extracted. Consequently, component descrip-
tions in the selected ADL should include the ability to specify (1)attributes, (2) required and provided interfaces, and (3) pre- and
post-conditions of each interface. This information is used by the
ADL Model Parsers to generate domain model descriptions which
are passed to the appropriate Planner component. In particular, the
ADL Model Parser will generate a domain model by mapping at-
tributes to ﬂuents F, interfaces to actions Aand by utilizing pre- and
post-conditions of interfaces to determine states Sand the transition
function R. Instead of explicitly (and possibly rigidly) specifying
the structure of the application’s architecture, PLASMA infers thetopology of the application layer from the plan and the componentADL models. To this end, required and provided interfaces are usedto discover component dependencies and, thus, determine required
components in the architecture. We should point out that any ADL
that includes this information can be used with PLASMA, giventhe appropriate ADL Model Parser .
The use of ADL models in PLASMA results in several bene-
ﬁts. First, whenever components are added, removed, or replaced,new plans can be automatically generated to achieve the goals of
the system. In particular, ADL model changes result in domain
model changes, which in turn, initiate replanning. Second, changesto requirements represented in changes to component model de-scriptions can be handled during runtime. This particular beneﬁt isobtained because the domain models that are generated from ADLmodels serve as a requirements speciﬁcation of the system.
In the next section, we describe how the planners in Figure 3 use
domain model descriptions to create plans for both the applicationand adaptation layers.
2.4 Planning
The behavior of the application and adaptation layers in
PLASMA are planned in order to achieve the high level goal ofthe application layer, speciﬁed by the system architect (i.e., thePLASMA user). The two bottommost layers receive the plans fromthe planning layer. The planning layer generates different kinds ofplans for the application and adaptation layers. Each of these plans
is generated from its own domain model description. The plannercomponents in the top layer accept the domain model description
and a planning problem as inputs to generate a plan. We maintain
a clear separation of application and adaptation concerns by sep-arating planning among the two different kinds of planners in theplanning layer.
A planning problem is the problem of arriving at a goal from an
initial state. The goal is represented by a set of conditions on the
domain model ﬂuents, and corresponds to a set of goal states where
those conditions are true. The generated plan is a set of state-actionrules which specify the actions to be taken from each state to reacha goal state. The plan is sufﬁcient to determine a path from anypossible initial state to a goal state.
The application goal is a set of conditions provided by the sys-
tem architect. The Application Planner ﬁrst ﬁnds an application
plan that speciﬁes how to achieve the application goal from a givencurrent application state. The Application Planner then derives
the target architecture topology of the application layer requiredto run that plan, using an algorithm speciﬁed in Section 3. The cur-rent architectural topology and the target architecture topology of
the application layer form the inital and goal states of the Adapta-
tion Problem , respectively. Consequentely, the Adaptation Planner
ﬁnds an adaptation plan that transforms the current architecture ofthe application layer to the desired architecture.
The application plan and adaptation plan are executed in the fol-
lowing way. Recall that the adaptive layered style includes meta-
level components— Collectors ,Analyzers , and Admins —that re-
spectively monitor, analyze, and modify components in the layerbelow (see Figure 3).
1. The Collector at the planning layer determines the current ar-
chitecture of the adaptation layer (which is initially empty).The planning layer Analyzer computes an architecture for the
adaptation layer (i.e., what Collectors ,Analyzers , and Ad-
mins are needed). The planning layer Admin instantiates and
deploys the adaptation layer components. Unlike the appli-cation layer, the topology of the adaptation layer is providedto the ADL Model Parser component in the planning layer
(i.e., it is not planned, but is rather pre-deﬁned as shown in
Figure 3).
2. The instantiated adaptation layer architecture will include an
Adaptation Analyzer that contains the adaptation plan and
logic for executing it. The Adaptation Analyzer executes the
plan by instructing the adaptation layer Admin to make modi-
ﬁcations to the application layer architecture by instantiatingcomponents, establishing connections, etc. Adaptation layerCollectors monitor the application architecture; if it changes
unexpectedly, the Adaptation Analyzer can use the adapta-
tion plan to return to the target application architecture.
3. The instantiated application layer architecture will include an
Executor that contains the application plan and logic for ex-
ecuting it and one or more Sensors .Sensors monitor the cur-
rent state of the system (i.e., the domain ﬂuents) and pass thisinformation to the Executor . The Executor uses the values of
the ﬂuents to determine the appropriate action to perform,
according to the application plan.
Adaptation in our approach is achieved automatically through
dynamic replanning and is not pre-programmed by the system ar-chitect. Dynamic replanning can be initiated either by the systemarchitect or by unexpected changes to the domain models (e.g., dueto component failures). Adaptation of the application layer oc-
curs whenever the adaptation goal and/or adaptation domain modelFigure 4: The high-level design of Prism-MW.
change. These changes could, in turn, be caused by a change to
the application goal and/or the application domain model. The ﬁrstcase (application goal change) is initiated by the system architect,who may provide a new application goal to the system at any time.In the second case (application domain model change), a new com-
ponent becomes available (e.g., a new version is introduced) or a
component becomes unavailable (e.g., due to a failure).
The planning and adaptation layers achieve a high degree of au-
tonomy and ﬂexibility, and also reduce the burden on the architect.The adaptation layer maintains a high degree of autonomy by uti-lizing automatically generated plans to adapt the application layer.
Placing the onus of automatic adaptation onto the adaptation layer
reduces the burden of design on the architect because she need notmanually specify plans for each adaptation scenario. Moreover,our approach offers signiﬁcant ﬂexibility by giving the architectthe ability to specify the adaptation requirements via ADL modelsof speciﬁc components in the adaptation layer.
3. DESIGN AND IMPLEMENTATION
In this section we describe the detailed design and implementa-
tion of PLASMA. In particular, we discuss the middleware, ADL,and ADL tool support we utilized, as well as the tools we leveragedfrom the planning domain.
3.1 Adaptive Layered Architectures in
PLASMA
As mentioned in 2.2, we leveraged the adaptive layered style in-
troduced in our previous work [5]. As described in [5], we extendedanarchitectural middleware platform called Prism-MW [13] to sup-
port adaptive layered architectures. Prism-MW is a lightweight
middleware implemented in Java and C++. The high-level design
of Prism-MW is given in Figure 4. The key building blocks ofPrism-MW are the Architecture ,Component andConnector classes.
AnArchitecture object serves as a run-time container for a topology
ofComponents andConnectors .Components implement applica-
tion services, while Connectors implement interaction-oriented ser-
vices. Components andConnectors communicate by exchanging
Events via Ports . Prism-MW is particularly well-suited to
PLASMA because it natively supports dynamic system adaptationby decoupling components via (dynamically instantiable) ports andevent-based interaction. The full description of this platform is be-yond the scope of the current paper and may be found in [13].
The extended version of Prism-MW which is introduced in [5]Figure 5: The SADEL speciﬁcation for the Loader component.
includes three specialized meta-level component types: Collectors ,
Analyzers , and Admins . Meta-level components have access to the
internal representation of a currently running architecture. We callcomponents with this kind of access architecturally aware. Collec-
torsandAnalyzers have read-only access to the architecture, while
Admins have read/write access and are allowed to adapt the archi-
tecture. Moreover, the extended version of Prism-MW deﬁnes a
meta-level architecture type which is used as a container for the
meta-level components. Each meta-level component in a meta-level architecture possesses a reference to the architecture that im-plements the layer immediately below it.
We evolved and extended the meta-components of the adaptive
layered style to run application and adaptation plans in PLASMA.
As envisioned in [5], Analyzers evaluate the adaptation policies
based on monitoring data and triggered adaptation operations whenrequired. These policies and plans were designed and implementedby application developers and were hard-coded in the Analyzer .
Therefore, Analyzers were not very ﬂexible and did not provide
a high degree of automation. Furthermore, they tended to be com-
plex, which made them time consuming and error-prone to gener-
ate. In contrast, the Adaptation Analyzer in PLASMA is an ex-
tended version of the one in [5]; it is capable of running automat-ically generated plans. We also modiﬁed the Collector andAdmin
components to match the interfaces of our Adaptation Analyzer .
3.2 Architectural Modeling in PLASMA
To support architectural modeling in PLASMA, we adapted and
extended C2SADEL, an ADL introduced in [15]. We chose thislanguage because it meets the requirements discussed in 2.3. More-over, it supports system analysis and evolution. This language wasoriginally designed to support the C2 architectural style, a layered
and event-based style. Furthermore, we modiﬁed the component-
based DRADEL environment [15] used to support modeling, anal-ysis, evolution, and implementation of architectures described inC2SADEL. DRADEL supports component evolution via subtyp-ing, architectural consistency- and type-checking, and code gener-ation.
We extended C2SADEL and created SADEL as the ADL forPLASMA. As discussed in 3.1, Prism-MW supports the implemen-
tation of the layered component-based architecture of PLASMA.
Therefore, we designed SADEL to support the event-based stylewhich is the basic style supported in Prism-MW. Compared to C2,the event-based style covers a wider range of applications and pro-vides a higher degree of ﬂexibility in architectural design (thoughat the cost of some analyzability, as discussed in [23]). Just like
in C2SADEL, an architectural model in SADEL has three major
parts: component types, connector types and a topology . The topol-
ogy deﬁnes the component and connector instances and their in-terconnections. Components deﬁne state variables, interfaces, andprovided and required operations. Each interface is mapped toan operation. In turn, each operation speciﬁes the pre- and post-
conditions of its invocation in terms of ﬁrst-order logic expressions
involving state variables. Operation deﬁnitions in SADEL spec-ify conditional and non-deterministic post-conditions, which arerequired for the generation of domain models. Component mod-els in SADEL also include version information, which allows theplanning layer to distinguish between evolved/updated components
and adapt the architecture accordingly.
An example SADEL speciﬁcation of the Loader component is
given in Figure 5. Loader has two interfaces: load() and
unload() . These interfaces are mapped to actions Ain the
application domain model. Loader has two Boolean state variables
called loaded andlocked . These variables are mapped to ﬂu-
entsFin the domain model. Finally, pre- and post-conditions are
speciﬁed for the load() andunload() interfaces. For example,
load() has the pre-condition (\not(loaded))\and(\not
(locked)) and post-condition loaded .
PLASMA provides support for modeling, analysis, evolution and
implementation of components and architectures described in
SADEL by enhancing DRADEL [15] and integrating it with otherPLASMA components. We ported DRADEL’s components toPRISM-MW and adapted their interfaces to match PLASMA com-ponents in the planning layer. The enhanced DRADEL compo-nents integrated into PLASMA support modeling and analysis in
the event-based (as opposed to C2) style and code generation for
PRISM-MW (as opposed to C2’s custom-built architecture imple-mentation framework). Incorporation of the extended DRADELcomponents enables PLASMA to perform consistency- and type-analysis on application layer architectures; further explanation ofDRADEL’s analysis capabilities can be found in [15]. These com-
ponents also provide additional features not supported by DRADEL
originally. For example, PLASMA supports component evolutionvia subtyping and version control.
3.3 Planning in PLASMA
We used the Model Based Planner (MBP), a planning tool for
non-deterministic domains [3], to support planning in PLASMA.
MBP implements the planning-as-model-checking technique intro-
duced in [10]. The fundamental idea behind planning-as-model-checking is to generate plans by checking the correctness of for-mulas in a model. To ﬁnd a plan to reach a goal state in a do-main, MBP uses a problem description and a domain model de-scription speciﬁed in NPDDL, an extended planning domain de-
scription language. The problem description determines what kind
of plan (Weak, Strong, Strong Cyclic, etc. [10]) is required for theapplicaion.
In the rest of this section, we describe how planning occurs at the
application and adaptation layers. More speciﬁcally, we describehow PLASMA deals with initialization of architectures, topology
determination, and goal or ADL model changes.Figure 6: An NPDDL domain model description for the exam-
ple domain.
3.3.1 Application Planning
In PLASMA, the NPDDL application problem description (ini-
tial state and goal) is provided by the user, while the NPDDL ap-plication domain model description is created automatically from
the SADEL models of application components by the ADL Model
Parser (recall Figure 3). For illustration, the NPDDL speciﬁca-
tion of the application domain model depicted in Figure 1(a) isshown in Figure 6. This NPDDL spec is derived from the SADELmodels of the Loader andLocker . For example, the loaded and
locked state variables of the Loader in Figure 5 are mapped to the
loaded andlocked predicates in Figure 6, while the load()
andunload() interfaces are mapped to the load andunload
actions. Similarly, the NPDDL pre-conditions and effects of theseactions are mapped from the pre- and post-conditions of the respec-tive SADEL interfaces.
Once the NPDDL application domain model has been generated,
it is passed, along with the NPDDL problem description, to the
Application Planner , which generates the application plan if there
is a path from the initial state to the goal state in the applicationdomain model. If there is no such path, PLASMA notiﬁes the ar-chitect so that she can modify the problem or the set of avaliablecomponents. In our example domain, assume an initial state in
which no item is loaded in the container and the container is not
locked (¬Loaded∧¬Locked ). This state is shown as state 2 in
Figure 1(a). Also assume that the application goal is to load anobject into the container and lock it. This goal is represented asstate 4 ( Loaded∧Locked ) in Figure 1(a). The Application Plan-
nergenerates a plan in the form of a set of state-action rules which
should be followed to arrive at the goal. In this example, the plancontains the following pairs: {{1,unlock} {2,load} {3,lock}}. Thisplan is interpreted as follows: to get to state 4 the following actionsmust occur—unlock action on state 1, load action in state 2, andlock action in state 3. Although this is a simple example, richer
applications have much longer plans and may have multiple plans
to reach a goal. PLASMA reduces the burden on the architect bydetermining these plans automatically.
Next, to be able to run the application plan in the application
layer, the required components for the plan and their topology mustbe determined. The responsibility of determining the topology of
the application layer is placed upon the Application Planner com-ponent. The Application Planner determines the components which
are required to complete the plan by examining the actions used in
the plan. The Application Planner computes all the components’
possible dependencies by matching their required and provided in-terfaces and creates a topology according to those dependencies.As a result, the architect no longer bears the burden of specifyingthe topology of the system.
In the example domain from Figure 1(a), the Application Plan-
nerdetermines the target application layer architecture in the fol-
lowing way. As previously mentioned, to get to state 4 from state 2the following plan P1should be run: {{1,unlock}{2,load}
{3,lock}}. The Loader andLocker have the load() ,lock() ,
andunlock() interfaces that match the actions of P1, so these
components are included in the architecture. Recall that the appli-
cation layer always includes an Executor that runs the application
plan by invoking the interfaces of application components, such asLoader andLocker . Consequently, the Loader andLocker are con-
nected to the
Executor . Finally, the Executor must know the val-
ues of domain ﬂuents in order to determine the appropriate actions.
Consequently a Sensor is added to the architecture to monitor each
ﬂuent, and each Sensor is connected to the Executor . This target
architecture, produced by the Application Planner , is passed to the
Adaptation Planner in the form of an adaptation problem (initial
architecture and goal architecture).
An application plan runs in the following manner. The Sensor
component tracks the domain ﬂuents, i.e., locked andloaded
in our example. Changes to these values are pushed to the Execu-
tor. The Executor uses the values of the ﬂuents to determine the
appropriate action to run based on the plan. The actions are per-formed by invoking the interfaces of either the Loader orLocker
components. This process is repeated until a goal state is reached.
A high degree of autonomy is maintained since the plan is run bytheExecutor without any involvement from the architect.
While the previous discussion describes plan execution in the
case where the goal of the system remains the same, a change to thegoal requires replanning. Application replanning followed by soft-
ware adaptation occurs automatically in PLASMA. In Figure 1(a),
the application layer goal can be changed from (Loaded∧Locked )
to(¬Loaded∧Locked ). This change initiates replanning which
results in the following application plan: {{4,unlock} {3,unload}{2,lock}}. The adaptation layer updates the Executor component
in the application layer to run the new plan.
To reiterate, the application layer and its key components are
designed to ease the burden of design on the architect, maintain ahigh degree of autonomy for the software system, and handle non-deterministic domains.
3.3.2 Adaptation Planning
Adaptation plans are generated by the Adaptation Planner in
the planning layer. Adaptation plans describe how to initialize the
architecture, which includes the creation and connection of com-
ponents. The Adaptation Planner requires an NPDDL adaptation
problem, generated automatically by the Application Planner , and
an NPDDL adaptation domain description, speciﬁed by the systemarchitect, to create an adaptation plan. Adaptation plans are alsocomputed by MBP using the same algorithm used to compute ap-
plication plans.
Figure 2 shows an example adaptation domain model with two
components. In our implementation, we utilized meta-level com-ponents, Admin andCollector , to perform the actions and monitor
the ﬂuents in the adaptation domain model. More speciﬁcally inthe speciﬁc example depicted in Figure 2, the Admin component
performs the Instantiate ,Kill,Add,Remove ,Connect , and Discon-Figure 7: NPDDL domain model description for the example
adaptation domain.
nect actions in the adaptation domain and the Collector detects the
Exist ,ArchInclude , and Connected ﬂuents.
The adaptation plan is executed and managed by the Adapta-
tion Analyzer from Figure 3. The Adaptation Analyzer executes an
adaptation plan autonomously by reading ﬂuents from the Collec-
torin the layer it resides in and by sending appropriate adaptation
actions to be performed by the Admin . Therefore, adaptation plan-
ning and adaptation take place automatically and the application
architects only deal with the adaptation layer requirements and de-
sign. In situations where a new Adaptation Analyzer is needed,
e.g., in the case of an adaptation plan change, the planning layerinstantiates a new Adaptation Analyzer for the adaptation layer.
An adaptation plan in our running example executes in the
following manner. The application layer is initially empty and the
goal state of the application plan has a Loader ,aLocker , and a Sen-
sor whose interfaces are connected to the Executor
component. Thus, the adaptation plan contains actions, such as In-
stantiate(Locker) ,Instantiate(Executor) ,Instantiate(Sensor) ,
connect(Locker,Executor) to connect component interfaces, and so
on. Figure 3 gives the instance of our layered architecture after the
adaptation plan was run and the application layer was set up.
Once an initial application layer architecture has been instan-
tiated, two situations may result in adaptations to the applicationlayer: modiﬁcations to the component SADEL models and com-ponent failures during runtime (which may result in changes to the
NPDDL domain models). PLASMA supports these dynamic adap-
tations through replanning.
The ﬁrst cause of replanning is a SADEL model change, which
occurs when system requirements evolve. For example, to handlea new requirement to perform adjustments to the container, a newcomponent called Adjuster is added to the system with an inter-
face to perform the adjust action. The SADEL model is changed
to reﬂect the addition of the Adjuster component. This SADEL
model change generates a new NPDDL application domain modeldescription, which initializes replanning. A new application planis found automatically and the Application Planner from Figure 3
uses the new plan to derive a new application layer architecture
that contains the Adjuster component. At this point, a new adapta-
Figure 8: Robots convoying in the case study.
tion problem is generated and passed to the Adaptation Planner .I n
this adaptation problem, the initial state is the current applicationlayer architecture and the goal is the new target architecture. Con-sequently, the Adaptation Planner creates a new adaptation plan
which changes the architecture from the current topology to the
new topology. This plan contains an action to add the Adjuster .
The second cause of replanning is a failure of an application
component. As an example, the Adjuster component may fail at
run-time. In this case, the Executor fails to successfully run the
plan and the adaptation layer detects the component failure throughitsCollector . The Adjuster is removed from the ADL model, result-
ing in a change to the NPDDL application domain model descrip-
tion which, in turn, initiates replanning and the deployment of anew architecture that does not rely on the failed component. How-ever, if a component failure makes it impossible to achieve the goal,PLASMA reports the failure to the architect.
PLASMA aims to reduce the burden of design placed upon the
architect by preventing the architect from having to directly deal
with architectural topology and adaptation plan speciﬁcation. Thearchitect does not need to anticipate all possible adaptation scenar-ios or pre-program adaptation plans. PLASMA is independent ofthe adaptation requirements and allows the user to provide any setof meta-level components for the adaptation layer. The meta-level
components in the adaptation layer can be different for different
adaptation domains, which provides further ﬂexibility for the sys-tem’s design. For example, a domain requirement can enforce dis-connection of components in a particular order to ensure minimumdisturbance to the system during runtime adaptation. PLASMA isable to natively include support for such a requirement.
4. CASE STUDY
In order to demonstrate the contributions and effectiveness of
PLASMA, we have leveraged a family of robot-based systems de-
veloped in collaboration with a third-party organization [14]. In
this section we ﬁrst describe how component model changes, goalchanges, and failures in a selected application scenario result insystem adaptations.
4.1 Application Scenario
Our robotic application consists of three or more robots that form
a convoy and follow a leader robot. The leader robot is providedwith a path to follow in the form of a series of spatial coordinatescalled waypoints . Each follower robot uses on-board sensors to
track the robot immediately ahead of it in the convoy and followAdaptation LayerDesktop Computer
Planning Layer
Application LayerRobot 1 Robot 5
ExecuterColorFollower RoleNegotiatorRobotActuatorAdaptation Layer
Application Layer
ExecuterColorFollower RoleNegotiatorRobotActuator
Figure 9: The deployment view of the case study architecture.
Figure 10: A snippet of the generated application plan for the
robot following case study.
it. This type of autonomous convoy is a common use-case for mo-
bile robotics, having applications in transportation [11], inventorymanagement [24], automated farming [4], and other areas.
Each robot in our case study consists of an iRobot Create mobile
programmable robot, an attached eBox 3854 embedded computer
running Fedora Linux, a camera, a GPS receiver, an infrared (IR)
receiver, and an IR transmitter. Also, the iRobot platform includesa front bumper sensor that detects when the robot has run into anobstacle, while the eBox includes a 802.11 wireless LAN adapter.A picture of the robots is shown in Figure 8.
Initially, we provided PLASMA with the SADEL models of the
following components: RoleNegotiator ,WaypointFollower ,Cam-
eraFollower ,GPSFollower ,GPSLeader ,IRFollower ,IRLeader ,
andObstacleAvoider . The RoleNegotiator implements a distributed
negotiation to assign a role (leader or follower) to all robots in theconvoy. The negotiation protocol ensures that only one robot can
be assigned the leader role. Assignment of a role is a precondi-
tion for using any of the following components. Only the leadermay use waypoint following and only followers may use the othertypes of following. GPSFollower andIRFollower require trans-
missions from a GPSLeader andIRLeader in the followed robot,
respectively. GPSLeader transmits coordinates over the wireless
LAN, while IRLeader emits an IR signal; these components arepulled into the target architecture as required interfaces of their
respective follower components. As long as the robots are suc-cessfully following waypoints or another robot, they set the ﬂuentIsFollowing =true. Whenever a robot gets stuck behind an ob-
stacle, BehindAnObstacle =true, and the ObstacleAvoider is
invoked, which implements an algorithm to move around an obsta-cle and bring the leader back into view. In addition to the abovecomponents, seven other sensor and actuator components are spec-iﬁed in SADEL. The interfaces of these components are requiredto read sensor values, steer the robot wheels, etc.
We speciﬁed an NPDDL problem description in which the goal is
(IsFollowing ∧¬BehindAnObstacle ). The PLASMA planning
layer (recall Figure 3), which is deployed on to a laptop, generatesan NPDDL application domain model, application plan, adaptationdomain model, adaptation goal (target architecture), and adaptationplan. The planning layer also automatically generates and com-
piles implementation code for an Adaptation Analyzer andExecu-
tor. The PLASMA planning layer then deploys compiled binaries
of all required components (application components provided bythe architect, Adaptation Analyzer ,Admins ,Collectors , etc.) and
instantiates an identical adaptation layer on each robot. The adap-
tation layer on each robot instantiates the application layer and the
Executor begins execution of the application plan, in which the ﬁrst
step is role negotiation. The deployed architecture is depicted inFigure 9.
As long as all robots are successfully following, the application
remains in the goal state and the Executor does nothing. When an
obstacle is encountered, the application is moved out of its goal
state and the Executor invokes the ObstacleAvoider component.
Furthermore, basic types of adaptations are automatically handledby the Executor . For example, if a robot is using camera following,
and the area becomes too dark, the
Executor can use the applica-
tion plan to automatically switch to GPS or IR following. Similarly,
GPS following does not work indoors, while IR following does not
work at large distances. The Executor automatically handles these
situations according to the application plan. A snippet of the ap-plication plan is shown in Figure 10. This small part of the planshows instances in which the robot is assigned a leader, an obstacleis avoided during waypoint following, and robots start camera or IR
following. The complete plan included 790 state-actions and took
300ms to generate on a mid-range computer. The initial adaptationplan was generated in 1.59s and included 1353 state-actions and 15components.
More powerful forms of adaptation require dynamic replanning.
Consider the case where a new system requirement is introduced at
run-time in which the robots are required to recharge their batter-ies using docking stations along the route. If any robot has batterypower less than 10%, the convoy is required to temporarily halt
while that robot leaves the convoy, docks at the station, charges,
and returns. To satisfy this requirement, we speciﬁed new SADELmodels for a BatteryMonitor and StationDocker . Adding these
SADEL models evolves the NPDDL application domain modeldescription. At this point, the architect can either initiate replan-ning or let the current plans continue to run. However, the cur-
rent goal of the system does not imply that charging should be
performed, so replanning does not change the application. There-fore, we also speciﬁed a new application goal, (IsFollowing ∧
¬BehindAnObstacle ∧¬BatteryIsLow ), and then initiated re-
planning. PLASMA computed new plans and regenerated and re-deployed the Adaptation Analyzer andExecutor components, along
with the other required application components. Extending the re-
quirements of the application in this way increased the number ofstate-actions in the application plan to 2318 and increased the gen-eration time to 1.2s. The adaptation plan contained 4390 differentstate-actions and took 5.89s to generate.
Different types of failures can also cause adaptation and/or re-
planning within the application and adaptation layers, depending
on the type and severity of each failure. For example, if the Ob-
stacleAvoider component unexpectedly terminates due to a tran-
sient software bug, the current architecture of the application layerchanges and is no longer equivalent to the target architecture. TheCollector in the adaptation layer detects this and notiﬁes the Adap-
tation Analyzer , which directs the Admin to perform an Instanti-
ate(ObstacleAvoider) action according to the adaptation plan. Thus,
this particular failure results in automatic adaptation without re-planning. However, if the camera on one of the robots fails, theCameraFollower cannot be reinstantiated. In this case, the NPDDL
application domain model is regenerated without the CameraFol-
lower component, resulting in new application and adaptation plans
that do not utilize the camera. The new application plan for thisscenario was generated in 400ms and included 856 state-actions;the corresponding adaptation plan had 3110 state-actions and wasgenerated in 3.74s.
4.2 Discussion
Our case study demonstrates how PLASMA-enabled applica-
tions transparently adapt to both foreseeable andunforeseeable con-
ditions and requirements. Foreseeable conditions requiring adapta-tion, such as the failure of an unreliable component or the abilityto perform object following in the dark, are built into applicationand adaptation plans. Consequently, adaptations that handle theseconditions are automatically realized without incurring the perfor-
mance penalties of replanning. Unforeseeable conditions and re-
quirements, such as an unexpected type of failure or the need torecharge, are addressed through replanning directed by the systemarchitect. Replanning incurs a performance penalty, but the situa-tions where it is required are relatively rare, and the alternative –
shutting down the application for an upgrade, for example – may
be worse. The replanning times of <6s in all cases (and <1s in somecases) were well within the acceptable bounds for our case study.The ability to handle unforeseeable conditions and requirements inthis manner sets PLASMA apart from similar approaches.
PLASMA is also designed to simplify the task of specifying
when and how the system should adapt. Automatically generated
plans in our case study ranged from 790 to 4390 state-actions. Man-ually specifying policies of this size would be tedious and cumber-some for the architect. To handle the goal change in the rechargingexample of our case study, for example, we only needed to specifytwo additional SADEL models (55 lines total) and a new NPDDL
problem description (1 line of change), along with the implemen-tations of the two new components. Moreover, the system architect
maintains control over the process. The adaptations that result from
new architect requirements are realized transparently, but the adap-tations are only performed when the architect decides it is safe andappropriate to do so. Other types of adaptations, such as foresee-able adaptations and failures, are handled without architect inter-vention.
The use of planning within PLASMA has a number of natu-
ral beneﬁts, which can be seen in the case study. First, a policy-based approach can result in policies that conﬂict with each otheror collectively make it impossible for the system to achieve itsgoal. Both of these situations cannot arise in PLASMA’s planning-based approach: if system constraints make the goal unachievable,
PLASMA automatically notiﬁes the architect before any adapta-
tions are performed. Second, the adaptation plans generated inPLASMA preserve all software adaptation restrictions and require-ments speciﬁed in the adaptation domain model. These require-ments restrict architectural adaptation based on platform or appli-cation constraints. For example, the adaptation plan in our case
study removes the CameraFollower after disconnection from the
Executer in order to avoid a dangling port in the Executer , which
can lead to communication failures.
5. RELATED WORK
Oreizy et al. introduced the concept of runtime software adap-
tation for architecture-based systems in 1998 [16]. In their follow-up work [17, 22], they reviewed and examined a larger number of
adaptation approaches suggested in the decade hence. In this sec-
tion we restrict ourselves to architectural approaches that rely onplans or policies. Readers are encouraged to refer to [17, 22] formore related work.
Among the policy-based approaches to self-adaptive systems,
the most closely related approaches are PBAAM [9] and AURA [7].
AURA is a task-oriented (as opposed to PLASMA’s goal-oriented)
self-adaptive approach that considers qualities of service as pri-mary factors to determine when to adapt a system. Besides usingmanually-speciﬁed policies rather than automatically-generatedplans, AURA does not utilize ADLs. Georgas et al. [8, 9] intro-duced the PBAAM approach to self-adaptive systems. PBAAM is
unique in its ability to dynamically evolve policies during runtime.
However, the user is still required to manually specify architecturaladaptations, which places more burden on the architect as com-pared to the automatically generated plans by PLASMA.
Salehie et al. [18] provide a taxonomy for self-adaptation and
discuss opportunities for novel research in that area. They point
out that few approaches utilize AI planning techniques for self-
adaptive systems. Srivastava and Kambhampati [20] discuss theuse of planning techniques for installing and running applicationsautonomously. However, their suggested use of planning for self-adaptive systems does not take an architectural perspective (specif-
ically, their work does not cover addition, removal, or replace-
ment of components or connectors). Arshad et al. [1] provide aplanning-based framework for failure recovery in distributed sys-tems. Although PLASMA also aids in failure recovery, Arshad etal.’s technique utilizes a dependency model to determine the ex-tent to which a failure may propagate through a system. However,
their framework requires the architect to directly work with domain
models, while PLASMA extracts domain models from ADL mod-els. Furthermore, dynamic addition of new components or servicesis not supported by their technique. In a follow-up approach, Ar-shad et al. [2] provide a framework called Planit for deploymentand reconﬁguration of distributed systems using AI planning. Sim-
ilar to PLASMA, Planit takes an architectural perspective by usingcomponents and connectors for deployment and reconﬁguration.
However, Planit only handles starting, stopping, and connecting of
components and connectors, but not their addition, removal, and re-placement. Furthermore, like their previous approach, Planit mod-els components and connectors directly in domain model descrip-tions.
The most closely related approach to PLASMA is the approach
of Sykes et al. in [21]. Both Sykes’ and our approaches are capa-
ble of selecting an appropriate topology for the software system’sarchitecture during runtime from an ADL model. PLASMA andSykes’ approach also both use planning-as-model-checking tech-niques. PLASMA differs from Sykes’ approach in several keyways, however. First, their proposed system is not capable of re-
planning in the case of a domain description change or system goal
change. Second, their approach generated plans for application-speciﬁc functionality, but those plans cannot handle replacement,addition, or removal of components. Third, Sykes’ approach uti-lized pre-programmed adaptation plans, while our approach gener-ates such plans on-the-ﬂy. Fourth, Sykes’ approach and PLASMA
differ in their utilization of domain models: domain models must
be speciﬁed in Sykes’ approach, while PLASMA generates thesemodels from ADL models. Consequently, the architect does notdirectly deal with domain models in PLASMA.
6. CONCLUSION AND FUTURE WORK
In this paper, we introduced an approach to software adaptation
that utilizes modeling and planning techniques in a meta-layeredarchitecture for self-adaptation. Our approach simpliﬁes the spec-iﬁcation and use of adaptation mechanisms for system architectsby freeing them from having to design the application architecturetopology and plan for speciﬁc adaptations. As a result, the archi-
tect avoids the difﬁculty of designing plans for unforeseeable con-
ditions such as changing requirements and runtime failures.
One of the beneﬁts provided by MBP is planning for tempo-
rally extended goals. These kind of goals not only specify the de-sired ﬁnal state of the domain but also specify the conditions whichshould hold during the execution of the plan. In the future, we
will study and leverage this property to address non-functional re-
quirements and quality properties more rigorously in PLASMA. Inaddition, we will investigate how to leverage contingent planningtechniques [19] to reduce the frequency of replanning.
7. ACKNOWLEDGMENTS
The authors would like to thank the Test Resource Management
Center (TRMC) Test and Evaluation / Science and Technology
(T&E/S&T) Program for their support. This material is based inpart upon work supported by the Department of Defense, UnitedStates Army, White Sands Missile Range, NM under Contract No.W9124Q-09-P-0230. This work has also been supported by theNational Science Foundation under grant numbers 0312780 and
0820170, and by Bosch Research and Technology Centers.
8. REFERENCES
[1] N. Arshad et al. A Planning Based Approach to Failure
Recovery in Distributed Systems. In 1st ACM SIGSOFT
Workshop on Self-managed Systems , 2004.
[2] N. Arshad et al. Deployment and Dynamic Reconﬁguration
Planning for Distributed Software Systems. Software Quality
Journal , 15(3):265–281, 2007.
[3] P. Bertoli et al. MBP: a model based planner. In Workshop on
Planning under Uncertainty and Incomplete Information ,
2001.[4] R. Eaton et al. Autonomous Farming: Modeling and Control
of Agricultural Machinery in a Uniﬁed Framework. In
Mechatronics and Machine Vision in Practice , 2008.
[5] G. Edwards et al. Architecture-driven Self-adaptation and
Self-management in Robotics Systems. In Int. Workshop on
Software Engineering for Adaptive and Self-managing
Systems , 2009.
[6] D. Garlan et al. Rainbow: Architecture-based Self-adaptation
with Reusable Infrastructure. Computer , pages 46–54, 2004.
[7] D. Garlan et al. Task-based Self-adaptation. In ACM
SIGSOFT Workshop on Self-managed Systems , 2004.
[8] J. C. Georgas and R. N. Taylor. Towards a knowledge-based
approach to architectural adaptation management. In 1st
ACM SIGSOFT Workshop on Self-managed Systems , 2004.
[9] J. C. Georgas and R. N. Taylor. Policy-based self-adaptive
architectures: A feasibility study in the robotics domain. In
Int. Workshop on Software Engineering for Adaptive and
Self-managing Systems , 2008.
[10] F. Giunchiglia et al. Planning as Model Checking. In 5th
European Conference on Planning: Recent Advances in AI
Planning , 1999.
[11] C. Henke et al. Advanced Convoy Control Strategy for
Autonomously Driven Railway Vehicles. In IEEE Conf. on
Intelligent Transportation Systems , 2006.
[12] J. Kramer and J. Magee. Self-managed Systems: an
Architectural Challenge. In Future of Software Engineering ,
pages 259–268. IEEE Computer Society, 2007.
[13] S. Malek et al. A style-aware architectural middleware for
resource-constrained, distributed systems. IEEE Trans.
Softw. Eng. , 31(3):256–272, 2005.
[14] S. Malek et al. An architecture-driven software mobility
framework. Journal of Systems and Software , In Press,
Corrected Proof, 2009.
[15] N. Medvidovic et al. A language and environment for
architecture-based software development and evolution. In
21st Int. Conf. on Software Engineering , 1999.
[16] P. Oreizy et al. Architecture-based runtime software
evolution. In 20th Int. Conf. on Software Engineering , 1998.
[17] P. Oreizy et al. Runtime software adaptation: framework,
approaches, and styles. In Companion of the 30th Int. Conf.
on Software Engineering , pages 899–910. ACM, 2008.
[18] M. Salehie et al. Self-adaptive software: Landscape and
research challenges. ACM Trans. Auton. Adapt. Syst. ,
4(2):1–42, 2009.
[19] D. Shaparau et al. Contingent planning with goal
preferences. In 21st National Conf. on Artiﬁcial Intelligence ,
pages 927–934. AAAI Press, 2006.
[20] B. Srivastava and S. Kambhampati. The Case for Automated
Planning in Autonomic Computing. In IEEE International
Conf. on Autonomic Computing , 2005.
[21] D. Sykes et al. From Goals to Components: A Combined
Approach to Self-management. In Int. Workshop on Software
Engineering for Adaptive and Self-managing Systems , 2008.
[22] R. N. Taylor et al. Architectural styles for runtime software
adaptation. In WICSA/ECSA , pages 171–180, 2009.
[23] R. N. Taylor et al. Software Architecture: Foundations,
Theory, and Practice . Wiley Publishing, 2009.
[24] P. Wurman et al. Coordinating Hundreds of Cooperative,
Autonomous Vehicles in Warehouses. AI Magazine ,
29(1):9–20, 2008.