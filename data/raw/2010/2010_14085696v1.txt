Synthesis of Component and Connector Models from
Cr
osscutting Structural Views
Shahar Maoz
School of Computer Science
Tel Aviv University, IsraelJan Oliver Ringert, Bernhard Rumpe
Software Engineering
RWTH Aachen University, Germany
ABSTRACT
We present component and connector (C&C) views, which
specify structural properties of component and connector
models in an expressive and intuitive way. C&C views pro-
vide means to abstract away direct hierarchy, direct con-
nectivity, port names and types, and thus can crosscut the
traditional boundaries of the implementation-oriented hier-
archical decomposition of systems and sub-systems, and re-
Ô¨Çect the partial knowledge available to diÔ¨Äerent stakeholders
involved in a system‚Äôs design.
AsaprimaryapplicationforC&Cviewsweinvestigatethe
synthesis problem: given a C&C views speciÔ¨Åcation, consist-
ing of mandatory, alternative, and negative views, construct
a concrete satisfying C&C model, if one exists. We show
that the problem is NP-hard and solve it, in a bounded
scope, using a reduction to SAT, via Alloy. We further ex-
tend the basic problem with support for library components,
speciÔ¨Åcation patterns, and architectural styles. The result
of synthesis can be used for further exploration, simulation,
and reÔ¨Ånement of the C&C model or, as the complete, Ô¨Ånal
model itself, for direct code generation.
A prototype tool and an evaluation over four example
systems with multiple speciÔ¨Åcations show promising results
and suggest interesting future research directions towards a
comprehensive development environment for the structure
of component and connector designs.
Categories and Subject Descriptors
D.2.1 [Software Engineering ]: Requirements/SpeciÔ¨Åca-
tions; D.2.2 [Software Engineering ]: Design Tools and
Techniques
General Terms
Design, Languages
Keywords
component and connector models, synthesis1. INTRODUCTION
Componentandconnector(C&C)modelsareusedinmany
applicationdomains, fromcyber-physicalandembeddedsys-
tems to web services to enterprise applications. The struc-
ture of a C&C model consists of components at diÔ¨Äerent
containment levels, their typed input and output ports, and
the connectors between them.
A system‚Äôs C&C model is typically complex; it is not de-
signed by a single engineer and is not completely described
in a single document. Moreover, some C&C models may be
bound to reuse library or third-party components designed
anddocumentedelsewhere. Thus, weconsiderasetupwhere
many diÔ¨Äerent, incomplete, relatively small fragments of the
model are provided by architects responsible for subsystems,
for the implementation of speciÔ¨Åc features, use cases, or
functionality, which crosscut the boundaries of components.
Such fragments may be developed by separate, distributed
teams, each focusing on only some aspects of the system and
its development and having only partial knowledge of the
system as a whole. Moreover, a team may have several, al-
ternative solutions that address the same concern, and some
knowledge about designs that must not be used. To move
forward in the development process and enable implemen-
tation, these partial models and the intentions behind them
should be integrated and then realized into a single, com-
plete design. However, such an integration is a complex and
challenging task.
In this paper we present component and connector views ,
which specify structural properties of component and con-
nectormodelsinanexpressiveandintuitiveway. C&Cviews
provide means to abstract away direct hierarchy, direct con-
nectivity, port names and types. SpeciÔ¨Åcally, C&C views
may not contain all components and connectors (and typ-
ically indeed contain only a small subset of the set of all
components and connectors of the system, related only to
a speciÔ¨Åc use case or set of functions or features). They
may contain (abstract) connectors between components at
diÔ¨Äerent, non-consecutive containment levels, and they may
provide incomplete typing information, that is, components‚Äô
ports may be un-typed. While the standard structural ab-
straction and speciÔ¨Åcation mechanisms supported by exist-
ing languages and tools for C&C models rely on the tradi-
tional, implementation-oriented hierarchical decomposition
of systems to sub-systems, we have deÔ¨Åned C&C views to
allow one to specify properties that crosscut the boundaries
of sub-systems. Most importantly, this makes them espe-
cially suitable to reÔ¨Çect the partial knowledge available to
diÔ¨Äerent stakeholders involved in a system‚Äôs design.
[MRR13] S. Maoz, J. O. Ringert, B. Rumpe: 
Synthesis of Component 
and Connector Models from Crosscutting Structural Views. 
Joint Meeting of the European Software Engineering Conference and the 
ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE'13), 
Eds.: B. Meyer, L. Baresi, M. Mezini, pages 444-454, ACM New York, 2013. 
www.se-rwth.de/publicationsAsaprimaryapplicationforC&Cviewsweinvestigatethe
synthesis problem: given a C&C views speciÔ¨Åcation, consist-
ing of mandatory, alternative, and negative views, construct
a concrete satisfying C&C model, if one exists.
We show that the synthesis problem for C&C views spec-
iÔ¨Åcations is NP-hard and solve it, in a bounded scope, using
a reduction to SAT, via Alloy [20] (since the problem is NP-
hard, the use of Alloy/SAT to solve it is justiÔ¨Åed). The
generated Alloy module is translated to a Boolean formula
and solved by a SAT solver. If a satisfying assignment is
found, we translate it back to a complete C&C model and
present it to the engineer; this design is ready for code gener-
ation. All analysis is fully automated and is internally done
using Alloy‚Äôs APIs and embedded SAT solver. The engineer
need not see the generated Alloy module.
The input for the synthesis is a C&C views speciÔ¨Åcation.
Its output is a single C&C model that satisÔ¨Åes the speciÔ¨Åca-
tion and is complete, to allow implementation. When more
than one solution exists, the engineer can explore diÔ¨Äerent
alternatives. When no solution exists (within a bounded
scope), the technique reports that the input speciÔ¨Åcation is
unsatisÔ¨Åable.
As a concrete language for C&C models we use Mon-
tiArc [2,16], a textual ADL developed using MontiCore [23],
with support for direct Java code generation (including in-
terfaces, factories, etc.). Its expressive power is compara-
ble to that of other ADLs, e.g., MathWorks Simulink [26],
AADL [9], and UML Component diagrams. The C&C views
are deÔ¨Åned as an extension to general C&C models. The
concrete syntax used in our implementation is an extension
of MontiArc.
To further increase the usefulness of C&C views synthesis
in practice, we have extended the basic synthesis problem
with support for three advanced features. First, support for
integration with pre-deÔ¨Åned or library components. Second,
support for several high-level speciÔ¨Åcation patterns. Third,
support for synthesis subject to several architectural styles.
We report on these advanced features in Sect. 5.
We have implemented C&C views synthesis, including the
more advanced extensions mentioned above, and evaluated
it by applying it to four example systems. We report on our
implementation and evaluation in Sect. 6. The implementa-
tion and example speciÔ¨Åcations reported on are available in
supporting materials [3].
Some previous work deal with the analysis and synthesis
of component and connector structures, mainly in the con-
text of architectures [6,7,13,19,21]. Other work deal with
synthesizing behavior rather than structure [17,24,31,32].
We discuss these and other related work in Sect. 7.
Sect. 2 gives a semi-formal overview of C&C views and
synthesis using examples. Sect. 3 provides formal deÔ¨Ånitions
and Sect. 4 describes our solution. Advanced support for in-
tegration of library components, speciÔ¨Åcation patterns, and
several architectural styles, is described in Sect. 5. The im-
plementation and evaluation are presented in Sect. 6. Sect. 7
discusses related work. Sect. 8 concludes.
2. OVERVIEW
We present an overview of C&C views synthesis using an
example, adopted from an industrial model of a robot arm1,
which is typical to a cyber-physical or an embedded system.
1We thank Ali Muhammad, Remote Operation and VirtualWe focus here on a single joint of this arm. The example
is discussed semi-formally. Formal deÔ¨Ånitions are given in
Sect. 3.
2.1 Example I
Fig. 1 shows the C&C views speciÔ¨Åcation S1, consisting of
six views. The C&C view RJFunction describes the system
architecture from the point of view of the team responsible
for its function: the RotationalJoint contains a Cylinder
and aSensorthat is connected to an Actuator . As a C&C
view,RJFunction ispartial, soitmaynotcontainallthesys-
tem‚Äôs components. Moreover, while the components shown
inside the joint must actually be inside the joint, they may
be nested within some of its subcomponents (not shown in
this model). On the other hand, the C&C view speciÔ¨Åes
that the three subcomponents, Cylinder ,Sensor, andAc-
tuatorare not nested within one another. Finally, Sensor
andActuator must be connected, but their connection is
not necessarily direct and the port names and types are not
given in the view.
The C&C views BodySensorIn andBodySensorOut de-
scribe two alternatives for the C&C model from the point of
view of the team responsible for a component named Body
and focus on its internal structure. The Ô¨Årst speciÔ¨Åes four
subcomponents of Body(not necessarily direct sub compo-
nents, not necessarily all of them) and the connections be-
tween them (again, not necessarily all connections, not nec-
essarily direct ones). The second suggests an alternative,
whereSensoris outside Body.
The C&C view SensorConnections describes the point of
view of the engineer responsible for Sensor. It shows that
Sensoris connected to Cylinder and to a component named
JointLimiter . Again, the C&C view is partial, thus in the
complete model the connections shown may be indirect and
Sensormay be connected to additional components.
The C&C view RJStructure provides a high-level descrip-
tion of the RotationalJoint structure, some of the com-
ponents it contains and the connections between them. It
describes the knowledge of the senior engineer responsible
for the joint. It also shows the name angleand type float
of an incoming port of the Cylinder for a connection (not
necessarily direct) coming from Body.
Finally, the C&C view ASDependence shows the Actua-
torand theSensorinsideBody. It describes some domain
knowledge concerning a requirement for independence be-
tweenActuator andSensor. Thus, it is used in the speci-
Ô¨Åcation (see below) in a negated form, to not allow an ar-
chitecture where Actuator andSensorare both inside the
same component, in our case, Body.
The Boolean expression for the C&C views speciÔ¨Åcation
S1isRJFunction ‚àß(BodySensorIn ‚à®BodySensorOut )‚àß
SensorConnections ‚àß ¬¨ASDependence ‚àßRJStructure . Is
thereacompleteC&CmodelthatsatisÔ¨ÅesthisspeciÔ¨Åcation?
Our work provides a fully automated and constructive an-
swer to this question. SpeciÔ¨Åcally, given this speciÔ¨Åcation,
our tool provides a positive answer and outputs the com-
plete C&C model shown in Fig. 2. For readability, we omit
some port names, types, and internal connectors from the
diagram.
Reality Group, VTT Tampere, Finland, for allowing us to
use this model.
	


	

	



		

	



		
			


 	

 
	




	
	
	




	

	

 		
 
		
 
			
 


 
 
Figure 1: A C&C views speciÔ¨Åcation S1. Note that the speciÔ¨Åcation states that BodySensorIn andBodySensorOut
are alternatives (at least one needs to be satisÔ¨Åed) and that ASDependence is negated, so it must not be satisÔ¨Åed
by the model.

	




	
		

		
Figure 2: A C&C model with 19 ports satisfying the
C&C view speciÔ¨Åcation S1.
2.2 Example II
Consider now the additional C&C view OldDesign and
revised speciÔ¨Åcation S2shown in Fig. 3. The view speciÔ¨Åes
thatActuator is connected to Cylinder and that both com-
ponents are contained inside Body(although not necessarily
directly). It also shows the name angleand type intof the
Cylinder ‚Äôs incoming port for a connection (not necessarily
direct) coming from Actuator .
Is there a complete C&C model that satisÔ¨Åes the revised
speciÔ¨Åcation S2(consisting of S1after adding OldDesign as
another conjunct)?
OurtoolidentiÔ¨Åesthat S2isunsatisÔ¨Åableandinformsthat
a complete C&C model that satisÔ¨Åes it does not exist. One
reason relates to the containment relation between Bodyand
Cylinder : according to the Structure C&C view, the two
components are not contained within one another; according
to theOldDesign C&C view, the latter is contained within	
 
		
Figure 3: A C&C views speciÔ¨Åcation S2extends
speciÔ¨Åcation S1(Fig. 1) with the additional view Old-
Designshown here, added as another conjunct.
the former. Another reason is the type conÔ¨Çict floatvs.
intfor theCylinder ‚Äôs incoming port angle.
3. DEFINITIONS
We deÔ¨Åne the structure of C&C models and views as used
in this paper (we give shortened deÔ¨Ånitions, for complete
deÔ¨Ånitions see the technical report available from [3]).
3.1 Component and Connector Models
A C&C model is a structure
cncm=/an}bracketle{tCmps,Ports,Cons,Types,subs,ports,type /an}bracketri}htwhere
‚Ä¢Cmpsis a set of named components, each of which
has a set of ports ports(cmp)‚äÜPortsand a (possibly
empty) set of immediate subcomponents subs(cmp)‚äÇ
Cmps,
‚Ä¢Portsis a disjoint union of input and output ports
Ports=PortsIn ‚à™PortsOut where each port p‚àà
Portshas a name, a type type(p)‚ààTypes, and be-
longs to exactly one component p‚ààports(cmp),
‚Ä¢Consis a set of directed connectors, each of which
connects two ports of the same type, which belong to
two sibling components or to a parent component and
one of its immediate subcomponents, and
‚Ä¢Typesis a Ô¨Ånite set of type names.Some additional well-formedness rules apply, e.g., that
the subcomponents relation is a strict partial order, that
every port has at most one incoming connector, and that
port names are unique within their component. In addition,
without loss of generality, we consider only C&C models
with exactly one top component.
3.2 C&C views
A C&C view is a structure view=
/an}bracketle{tCmps,Ports,AbsCons,Types,subs,ports,type /an}bracketri}htwhere
‚Ä¢Cmpsis a set of named components, each of which has
a (possibly empty) set of ports ports(cmp)‚äÜPorts
and a (possibly empty) set of subcomponents
subs(cmp)‚äÇCmps,
‚Ä¢Portsis a disjoint union of sets of input and output
portsPorts=PortsIn ‚à™PortsOut where each port
p‚ààPortshas a (possibly unknown) name, a (possibly
unknown) type type(p)‚ààTypes‚à™ ‚ä•, and belongs to
exactly one component p‚ààports(cmp),
‚Ä¢AbsCons is a set of abstract connectors, each of which
connectscomponents(optionally)viaportsofthesame
type or an unknown type, and
‚Ä¢Typesis a Ô¨Ånite set of type names.
Note that in a C&C view, abstract connectors are not
required to connect only two sibling components or a par-
ent component and one of its immediate subcomponents.
Again, the subcomponents relation is a strict partial order,
but we do not restrict C&C views to have exactly one top
component. We are now ready to deÔ¨Åne the semantics of
our C&C view and C&C model, and speciÔ¨Åcally, when does
the second satisfy the Ô¨Årst.
A C&C model satisÔ¨Åes a C&C view iÔ¨Ä the types, com-
ponents, and ports mentioned in the second are contained
in the Ô¨Årst, the Ô¨Årst respects the subcomponent relation in-
duced by the second, two ports connected by an abstract
connector in the second are connected by a chain of con-
nectors in the Ô¨Årst (respecting direction, names, and types),
and all ports of a component in the second belong to the
same component in the Ô¨Årst with corresponding name, type
and direction. More formally:
Definition 1 ( cncm|=view).A C&C model cncmsat-
isÔ¨Åes an C&C view viewiÔ¨Ä:
‚Ä¢view.Types ‚äÜcncm.Types ,view.Cmps ‚äÜcncm.Cmps ,
view.Ports ‚äÜcncm.Ports ,
‚Ä¢ ‚àÄcmp1,cmp2‚ààview.Cmps :cmp1‚ààview.subs (cmp2)
iÔ¨Äcmp1‚ààcncm.subs+(cmp2)(we use+to denote the
transitive closure),
‚Ä¢ ‚àÄac‚ààview.AbsCons ‚àÉchain of connectors in cncm,
c1,...,c nwithac.srcCmp =c1.srcCmp and
ac.tgtCmp =cn.tgtCmp with matching port names
and types, if speciÔ¨Åed, and
‚Ä¢ ‚àÄcmp‚ààview.Cmps :
(1)view.ports (cmp)‚äÜcncm.ports (cmp), and
(2)‚àÄp‚ààview.ports (cmp):p‚ààview.PortsIn iÔ¨Äp‚àà
cncm.PortsIn ‚àßview.type (p)‚àà {‚ä•,cncm.type (p)}
(similarly for unknown and given port names).
Definition 2 ( viewsemantics). The semantics of a
C&Cviewconsists of the possibly inÔ¨Ånite set of C&C models
that satisfy it. Formally:
sem(view) ={cncm|cncm|=view}.A C&C views speciÔ¨Åcation Sconsists of a Boolean expres-
sion over a set ofC&C views V. By simple extension, a C&C
modelcncmsatisÔ¨Åes a speciÔ¨Åcation S, denoted cncm|=S,
iÔ¨Ä replacing each view vinSwith the value of cncm|=v
makesStrue:cncm|=S‚áîS[v/(cncm|=v)]v‚ààV.
3.3 Problem DeÔ¨Ånition
The C&C views synthesis problem is deÔ¨Åned as follows:
given a C&C views speciÔ¨Åcation S, Ô¨Ånd a C&C model cncm
s.t.cncm|=Sif such a model exists.
4. C&C VIEWS SYNTHESIS
4.1 Is C&C Views Synthesis Hard?
We show that the C&C views synthesis problem (even
withoutconnectors)isNP-hard, usingareductionfrom3SAT.
We give an overview below.
Given a 3SAT formula over variables x1,...,x nin clauses
c1,...,c mwe construct the following C&C views speciÔ¨Åca-
tion. First, for each variable xiwe deÔ¨Åne two components
xTiandxFiand two C&C views vTiandvFisuch that in
vTi,xFicontains xTi, and in vFi,xTicontains xFi. Intu-
itively,vTi(vFi) represents a positive (negative) valuation
forxi. Obviously, a given C&C model can only satisfy one
of them. Second, for each clause cjwe create an C&C views
clausecVjthat includes a disjunction of three C&C views,
vTiorvFifor each variable xiincj: ifxiappears positive
incjwe usevTi, if it appears negative we use vFi.
We create a Boolean expression for the C&C views spec-
iÔ¨Åcation consisting of a conjunction of (1) xTi‚à®xFifor all
1‚â§i‚â§n, and (2) C&C views clauses cVjfor all 1‚â§j‚â§m.
It is easy to see that the 3SAT formula has an assignment
iÔ¨Ä the C&C views speciÔ¨Åcation has a satisfying C&C model.
4.2 Formulating the Problem in Alloy
Our solution is based on a reduction to Alloy. The Alloy
module is analyzed using a SAT solver. If an assignment is
found, we translate it back to a satisfying C&C model. The
formulation of the C&C views synthesis problem in Alloy
consists of four parts: (1) a Ô¨Åxed set of signatures and facts
describing a meta-model for C&C models, (2) a Ô¨Åxed set
of predicates used as a language to specify the semantics of
C&C views, (3) a set of signatures and predicates derived
from the speciÔ¨Åc input C&C views, and (4) the speciÔ¨Åca-
tion‚Äôs Boolean expression.
List. 1 shows (part of) the Alloy code describing the meta-
model for C&C models. For example, note the signatures
Component andPort. A component has a set of ports, a
set of sub components, and at most one parent. The fact
subComponentsAndParents speciÔ¨Åes the value for the Ô¨Åeld
parent, and the fact subComponentsAcyclic speciÔ¨Åes that
thesubcomponentrelationisacyclic. Finally, thefact port-
sOfComponentHaveUniqueNames speciÔ¨Åes that no two ports
of the same component have the same name.
List.2shows(partof)theAlloycodeusedasalanguageto
specify the semantics of C&C views. For example, the predi-
catecontains istrueifthechildisinthetransitiveclosureof
the parent‚Äôs sub component relation, and the predicate in-
dependentSet deÔ¨Ånes the semantics of a set of components
where no two components contain each other. The predi-
cateconnected deÔ¨Ånes directed connectedness based on the
transitive closure of the receiving port relation. The remain-1abstract sig Component {
2ports : setPort,
3subComponents : setComponent,
4parent : loneComponent }
5
6factsubComponentsAndParents {
7allch, par : Component |
8(chinpar.subComponents iffch.parent =par) }
9
10factsubComponentsAcyclic {
11nocomp : Component |
12 compincomp.^subComponents }
13
14sigPort {
15type : oneType,
16name:onePortName,
17direction: oneDirection,
18receivingPorts : setPort,
19owner : oneComponent,
20sendingPort : lonePort }
21
22factportsOfComponentHaveUniqueNames {
23allc:Component | alldisj p1, p2 : c.ports |
24 p1.name !=p2.name }
Listing 1: Excerpts from the meta-model for C&C models
in Alloy (see Sect. 4.2)
ing predicates in List. 2 are used to express the semantics of
abstract connectors and untyped ports.
For the third part, we collect from the input C&C views
thecomponentnames, portnames, andtypesintosignatures
extending Component ,PortName , andType. We then derive
a set of predicates, each of which expresses the semantics
of one of the views using the ‚Äòlanguage‚Äô deÔ¨Åned earlier. As
an example, List. 3 shows the predicates for the C&C views
RJFunction andRJStructure taken from speciÔ¨Åcation S1
(Fig. 1).
Finally, we construct a predicate specrepresenting the
speciÔ¨Åcation‚ÄôsBooleanexpressionovertheC&Cviews‚Äôpred-
icates.
4.3 Synthesis
We run the module deÔ¨Åned above with a command that
tries to satisfy the specpredicate. Note that Alloy analy-
sis must be done within a user-deÔ¨Åned, given scope, which
speciÔ¨Åes an upper bound for the number of instances per
signature. In our case, the upper bound for the number
of components is derived from the speciÔ¨Åcation. The up-
per bound for the total number of ports and the maximal
number of ports per component, however, cannot be derived
from the speciÔ¨Åcation. We thus let the user choose the scope
for ports (we can only derive a lower bound for the number
of necessary ports).
If an Alloy instance is found, we translate it back to the
problem domain, that is, to a complete C&C model. The
translation back is straightforward and is linear in the size of
the solution. However, if an Alloy instance is not found, in
the general case, we do not know whether the speciÔ¨Åcation
could be satisÔ¨Åable in a larger scope, that is, using more
ports. As stated before, our solution is indeed sound but
incomplete(althoughitiscompletewithinthegivenscopes).
5. ADV ANCED FEATURES
5.1 Library Components
Most C&C models reuse library components, pre-deÔ¨Åned
or existing components adopted from other systems. Thus,1predcontains [parent: Component,
2 child: Component] {
3childinparent.^(subComponents) }
4
5predindependentSet [components : setComponent] {
6alldisj c1, c2 : components |
7( (noc1.subComponents) or
8 (notcontains[c1, c2]) ) }
9
10predconnected[sender: Component,
11 receiver: Component] {
12somep : receiver.ports |
13 pinsender.ports.^receivingPorts }
14
15predconnectedWithPortNames[sender: Component,
16 sendName : PortName, receiver: Component,
17 recvName: PortName] {
18somesp : sender.ports |
19 somerp : receiver.ports |
20 rp.name =recvName and
21 rpinsp.^receivingPorts and
22 sp.name =sendName and
23 spinrp.^~receivingPorts }
24
25predconnectedWithReceiverPortName[
26 sender: Component, receiver: Component,
27 recvName : PortName] {
28somesendName : sender.ports.name |
29 connectedWithPortNames[sender, sendName,
30 receiver, recvName] }
31
32preduntypedPort[cmp : Component, dir: Direction,
33 portName : PortName] {
34someport : cmp.ports |
35 port.direction =dirand
36 port.name =portName }
Listing 2: Excerpts from the ‚Äòlanguage‚Äô for C&C views‚Äô
semantics (see Sect. 4.2)
it is crucial that our technique would allow the engineer to
import such components and apply an integrated synthesis
solution.
SpeciÔ¨Åcally, C&C views synthesis supports the integration
of library components or similar components at two levels.
First, the engineer can extend the speciÔ¨Åcation with a list of
imported library component deÔ¨Ånitions. A component deÔ¨Å-
nition is complete: it speciÔ¨Åes the complete interface (port
names and types) of the component. If a component deÔ¨Å-
nition for component Cmpis imported, we check that none
of the C&C views mentioning Cmpexplicitly speciÔ¨Åes a sub-
component for Cmp, and we add its interface (and the re-
quirement that it is complete) as an additional constraint
to the generated Alloy module. This ensures that a synthe-
sized design that uses Cmp, if any, would be consistent with
its interface and use it as is.
As an example, consider the ServoValve component in
speciÔ¨Åcation S1from Fig. 1 to be an imported library com-
ponent. In the library, the complete interface of ServoValve
is given. Importing it to the speciÔ¨Åcation S1ensures its in-
terface is used as is in the synthesized design and rules out
solutions that put other components that are mentioned in
the C&C views as its subcomponents. For example, a solu-
tion where ServoValve contains Sensorwill not be possible.
The additional Alloy predicates we use to support library
components are shown in List. 4 and List. 5. We instan-
tiate these predicates with every library component in the
speciÔ¨Åcation, as shown in List. 6 for the ServoValve .
Note that the synthesis considers an imported component
as a black-box: it uses its interface and needs no knowledge
of its subcomponents. This is meant to support encapsula-1predRJFunction {
2oneRotationalJoint
3and one Actuator
4and one Sensor
5and one Cylinder
6andindependentSet[Sensor + Actuator + Cylinder]
7andcontains[RotationalJoint, Sensor + Actuator
8 + Cylinder]
9andconnected[Sensor, Actuator] }
10
11predRJStructure {
12oneRotationalJoint
13and one Body
14and one ServoValve
15and one Cylinder
16andindependentSet[ServoValve + Body + Cylinder]
17andcontains[RotationalJoint, ServoValve + Body
18 + Cylinder]
19andportOfComponent[Cylinder, IN, my_float,
20 angle]
21andconnected[RotationalJoint, ServoValve]
22andconnected[ServoValve, Body]
23andconnectedWithReceiverPortName[Body,
24 Cylinder, angle]
25andconnected[Cylinder, Body] }
Listing 3: Predicates for two C&C views, RJFunction and
RJStructure , from speciÔ¨Åcation S1(see Sect. 4.2)
1predlibraryComponent[cmp: Component] {
2nocmp.subComponents }
Listing 4: Predicate to specify that a library component
must have no subcomponents (see Sect. 5.1)
tion and modularity: as long as the interface is kept Ô¨Åxed,
the implementation of imported library components can be
replaced without aÔ¨Äecting the synthesized design.
Second, thedesignercanstrengthenaC&Cviewbydeclar-
ing some of the components mentioned in it as interface
complete (technically, using a stereotype). This is useful
when the designer knows the complete interface of a compo-
nent she is using although this component is not a black-box
librarycomponent. Forexample, consideraddingthestereo-
type interface complete to the Sensorin theSensorConnec-
tionsmodel (Fig. 1). This would mean that in the synthe-
sized design, Sensormust have exactly the set of ports and
corresponding types shown in this model. As Sensoris not
imported as a library component, it is still possible that in
the synthesized solution it will include subcomponents from
the set of components already mentioned in the models.
The additional Alloy predicate we use to support interface
completecomponentsisshowninList.5. Weinstantiatethis
predicate with every component that is speciÔ¨Åed as interface
complete in a model in the speciÔ¨Åcation.
5.2 SpeciÔ¨Åcation Patterns
The use of a Boolean expression in C&C views speciÔ¨Åca-
tions makes them very expressive. However, for the engineer
who constructs the speciÔ¨Åcation, using only low level basic
Boolean connectives may be inconvenient and error prone.
Thus, we look for higher-level speciÔ¨Åcation patterns, which
can be used to express the required semantics more intu-
itively, and can be reused across diÔ¨Äerent speciÔ¨Åcations.
BasedonourexperiencewithcreatingspeciÔ¨Åcations, some
examples of simple patterns are: [ALT], given a set of C&C
views, specifying that the synthesized design must satisfy
at least one of the models in the set; [XALT], given a set
of views, specifying that the synthesized design must satisfy1predinterfaceComplete[cmp:Component,
2 portNames: setPortName] {
3cmp.ports.name =portNames }
Listing 5: Predicate to specify that a component‚Äôs interface
is complete, technically, by stating that the set of its port
names, as appearing in the model, is exactly its complete set
of port names (see Sect. 5.1)
1factlibraryComponents {
2libraryComponent[ServoValve]
3someServoValve implies (
4portOf[ServoValve, IN, my_float, portIn]
5andportOf[ServoValve, OUT, my_float, portOut]
6andinterfaceComplete[ServoValve,
7 portIn + portOut]) }
Listing 6: A fact stating that servoValve is a library com-
ponent (see Sect. 5.1). If servoValve is used in the design its
interface is completely speciÔ¨Åed.
exactly one of the views in the set; [IMP], given two views, if
the design satisÔ¨Åes the Ô¨Årst, it should also satisfy the second;
and [NOCOMP], a given component should not be present
in the synthesized design. Note that the last three patterns
depend on the use of negation in the language.
As an example, recall speciÔ¨Åcation S1(Fig. 1). Assume
that the engineer responsible for Sensorknows that if it
is located outside Body, then it must use an inner ampliÔ¨Åer
Amplifier . Toexpressthisknowledge, thearchitectcancre-
ate the C&C view SensorHasAmp shown in Fig. 4 (left) and
add the implication IMP(BodySensorOut,SensorHasAmp) to
the speciÔ¨Åcation‚Äôs Boolean expression (as another conjunct).
To make sure the ampliÔ¨Åer is not used when it is not neces-
sary, the engineer can create the view Ampshown in Fig. 4
(right), and add the implication IMP(BodySensorIn, ¬¨Amp)
(since the model Ampconsists of the single component Am-
plifier, the expression ¬¨Ampused here is an instance of the
patternNOCOMPmentioned above).
As another example, the choice between BodySensorIn
andBodySensorOut inS1can be strengthened by the engi-
neer toXALT(BodySensorIn,BodySensorOut) without loos-
ing or adding possible implementations, that is, as a form of
refactoring. The semantics of the two views entails that no
design can satisfy both and their use in the speciÔ¨Åcation S1
entails that at least one of them must be satisÔ¨Åed.
SpeciÔ¨Åcationpatternsdonotaddexpressivepower. Rather,
they are only meant to improve the readability and usability
of C&C views speciÔ¨Åcations. Indeed, as part of our proto-
typeimplementation, wehavedevelopedgraphicalinterfaces
to add and edit the speciÔ¨Åcation‚Äôs Boolean expression, in-
cluding support for several patterns. Our ideas on speciÔ¨Åca-
tion patterns for architecture structures are inspired by pre-
vious works on patterns of temporal speciÔ¨Åcations (e.g., [8]).
	
	
	
 	

Figure 4: The additional C&C views SensorHasAmp
andAmp, to be added to the speciÔ¨Åcation S1with the
implications IMP(BodySensorOut,SensorHasAmp) and
IMP(BodySensorIn, ¬¨Amp)(see Sect. 5.2).1facthierarchicalArchitecture {
2noc: Component |
3cin^(Talker.talksTo).c }
4
5one sig Talker {
6talksTo : Component ->Component
7} {allc1, c2: Component |
8c2intalksTo.c1 iffendToEndConnection[c1,c2]}
9
10predendToEndConnection[senderC : oneComponent,
11 receiverC: oneComponent] {
12somesenderP : senderC.ports |
13 somereceiverP : receiverC.ports |
14 nosenderP.sendingPort and// no forward
15 noreceiverP.receivingPorts and// no forward
16 receiverP insenderP.^receivingPorts }
Listing 7: Excerpts from the Alloy code for the hierarchical
style (see Sect. 5.3)
5.3 C&C Views Synthesis with Styles
Architectural styles systematize successful architectural
design practices in terms of constraints on architectural el-
ements and their composition into systems [29]. Some ex-
amples of well-known architectural styles that are relevant
to C&C models include the pipe-and-Ô¨Ålter style, the client-
server style, and the layered style (an overview can be found
in Chap.4 of [30]). We have extended C&C views synthesis
with support for three architectural styles. As applicable,
style speciÔ¨Åc constraints are added to the synthesis input so
that the synthesized design, if any is found, obeys the rules
of the style. We give three examples below.
First, a hierarchical style , whose essence is to forbid the
C&C models from having directed cycles of connected com-
ponents. This style is important, because hierarchical ar-
chitectures are suitable for behavioral synthesis: while the
problem of synthesizing a Ô¨Ånite-state distributed reactive
system over a given architecture is in general undecidable,
it is decidable for the class of hierarchical architectures [28].
To enforce the hierarchical style of the synthesized model
we add to the generated Alloy module a fact that requires
that no directed cycles exist (see List. 7). More technically,
this is implemented using the helper relation talksTo of the
signature Talker. A pair of components C1,C2is in this
relation iÔ¨Ä there exists a connection that starts at C1(not
only forwarded) and ends at C2. If a hierarchical solution
exists, it will be found. If no solution exists, it might be
possible to Ô¨Ånd a solution that is not hierarchical.
Second, a client-server style , whose essence is to identify
one of the components as a single server and to forbid any
direct communication between clients. Also, the server and
the clients are assumed all to be independent in terms of
containment; a client is not contained within the server or
another client etc. To integrate this style with our synthesis
solution we add the identities of the server and the client
components, as deÔ¨Åned by the engineer, as additional input
to the speciÔ¨Åcation. We replace the constraint of a single top
component (see Sect. 3.1), with a constraint that speciÔ¨Åes
that the server and the clients are the top components. We
then use a fact to enforce additional style constraints on the
synthesized design (see List. 8). More technically, the fact
uses a parametrized predicate that deÔ¨Ånes when two compo-
nents are directly connected, and two generated functions,
myServer andmyClients , returning the server component
and the client components resp. Again, if a design that sat-
isÔ¨Åes the speciÔ¨Åcation together with the additional restric-tionsexists, itisfound. Ifnot, itmeansthatthesemanticsof
the speciÔ¨Åcation cannot be satisÔ¨Åed within the client-server
style, e.g., without direct client to client connectors (or that
it cannot be satisÔ¨Åed at all).
Third, a layered style , which forces a partition of the com-
ponents into a sequence of layers, and allows direct connec-
tors only within layers and between consecutive layers. To
integrate this style with our synthesis solution we add the
partition of the components into layers, as deÔ¨Åned by the
engineer, as additional input to the speciÔ¨Åcation. As in the
client-server style, we replace the constraint of a single top
component with a constraint that speciÔ¨Åes that the layers
are the top components. We then use several parametrized
predicates to enforce the style‚Äôs constraints on the synthe-
sized design. If a design that satisÔ¨Åes the speciÔ¨Åcation to-
gether with the additional restrictions induced by the parti-
tion of the layers exists, it is found. If not, it means that the
partitionintolayers conÔ¨Çicts with the semantics of the speci-
Ô¨Åcation(orthatthespeciÔ¨Åcation, evenwithoutthestylecon-
straints, is not satisÔ¨Åable, at least within the given scope).
It is important to note that each of the C&C views in
the speciÔ¨Åcation is independent of and does not have to be
compliant, by itself, with the constraints induced by the
architectural style. For example, even though a layered ar-
chitecture is enforced, abstract connectors in a view may
connect components from nonconsecutive layers. The syn-
thesis is responsible to implement these abstract connectors
through chains of concrete connectors that obey the lay-
ered architecture. As another example, what looks like a
communication cycle in a given view (and thus apparently
violates a hierarchical style), may end up implemented in
the synthesized design without creating a cycle. For exam-
ple, recall speciÔ¨Åcation S1of Fig. 1 where view Structure
seems to contain a cycle between BodyandCylinder . In the
synthesized design, shown in Fig. 2, we see that the imple-
mentation contains no concrete end-to-end cycle. Thus, the
C&C views and the architectural style are speciÔ¨Åed indepen-
dently. The synthesis is responsible for Ô¨Ånding a design that
satisÔ¨Åes both, if one exists.
Finally, the use of architectural styles adds expressive
power to C&C views speciÔ¨Åcations and makes it applica-
ble to a wide range of systems. In our prototype plug-in
for C&C views synthesis, we have added graphical user in-
terfaces to select a style and edit its properties, including
support for the three styles described above.
1factclientServerArchitecture {
2allclient : myClients |
3 immediatelyConnectedNoOrder[myServer, client]
4 and no c : (myClients-client) |
5 immediatelyConnectedNoOrder[client, c] }
6
7predimmediatelyConnectedNoOrder[c1: Component,
8 c2: Component] {
9somep : c1.ports |
10 ( pinc2.ports.receivingPorts or
11 pinc2.ports.sendingPort ) }
Listing 8: Excerpts from the Alloy code for the client-server
style. myServer andmyClients are generated Alloy functions
returning the server component and the client components
resp. (see Sect. 5.3)6. IMPLEMENTATION AND EV ALUATION
Theplug-inimplementationandallspeciÔ¨Åcationsreported
on below are available in supporting materials [3], together
with screen captures and relevant documentation. All speci-
Ô¨Åcations can be inspected and all experiments can be repro-
duced. We encourage the interested reader to try it out.2
6.1 Implementation
We implemented C&C views synthesis in an Eclipse plug-
in prototype. The input consists of a C&C views speciÔ¨Å-
cation. The speciÔ¨Åcation ‚Äî selection of C&C views and
components, deÔ¨Ånition of the Boolean formula, scope, and
optional parameters about styles ‚Äî is edited using a ded-
icated graphical UI. The concrete syntax used is adapted
from MontiArc [2]. At the back end, the plug-in imple-
ments the translation to Alloy using MontiCore APIs [23]
and FreeMarker [10]. The SAT solver we use is MiniSat [27].
When a design is synthesized, it is presented as a MontiArc
document to the engineer, who can inspect it andfurther use
it for code generation (to Java or to MathWorks Simulink).
We tested the implementation over C&C views speciÔ¨Åca-
tions for four systems from diÔ¨Äerent sources and of diÔ¨Äerent
domains. We experimented with several diÔ¨Äerent speciÔ¨Åca-
tions for each system, in order to test and evaluate the use
of diÔ¨Äerent features (e.g., library components, speciÔ¨Åcation
patterns, architectural styles). For validation, we have also
implemented a polynomial algorithm that checks whether a
given C&C model satisÔ¨Åes a given C&C view. As part of
our experiments, we ran this algorithm on the results of all
successful synthesized designs and their source views. This
check is available with the prototype plug-in too.
6.2 Evaluation
We evaluated C&C views synthesis on four systems, taken
from diÔ¨Äerent sources.
Avionics system. We evaluated C&C views synthesis on
an AADL architecture of an avionics system, taken from [4]
(speciÔ¨Åcally Avionics_System.aadl of the OSATE AADL
Project). The avionics system architecture is a high-level
model of several avionics system subsystems.
Based on various use cases related to interactions between
system‚Äôs components, we created 9 C&C views, 1-6 compo-
nents each. For example, one view gives an overview of
the complete data Ô¨Çow in the system, declared using ab-
stract connectors. This view does not provide additional
information such as port names or types. Another view pro-
vides more details about the communication between the
Pilot_Display and it‚ÄôsPage_Content_Manager , showing in-
coming and outgoing ports with their names and connectors.
We deÔ¨Åned 7 satisÔ¨Åable and unsatisÔ¨Åable C&C views speci-
Ô¨Åcations, using 3 to 9 views, some extended with styles.
Pump station. We further experimented with a pump sta-
tion design taken from an example system provided with the
AutoFocus tool, developed at TU Munich [1,18]. The phys-
ical pump station system consists of two water tanks con-
nected by a pipeline system with a valve and a pump. The
water level in the Ô¨Årst water tank can rise (this is controlled
by the environment). When the water level of the Ô¨Årst tank
rises to a critical level, the water has to be pumped to the
the second water tank. The second water tank has a drain.
2The supporting materials have been successfully evaluated
by the ESEC/FSE artifact evaluation committee and found
to meet expectations.Based on several design decisions and relations we wanted
to highlight and document, we created 10 C&C views, each
with 2-5 components. For example, one view gives an over-
view of the basic structure of the system and omits details
about interfaces and connectors. Another view documents
partoftheconnectionsbetweentheactuatorsandtheirenvi-
ronment, hiding hierarchies and omitting elements not con-
nected to the actuators. An additional C&C view shows an
undesired design where the simulation component is placed
inside the pumping system.
WedeÔ¨Åned8satisÔ¨ÅableandunsatisÔ¨ÅableC&Cviewsspec-
iÔ¨Åcations. Two speciÔ¨Åcations specify the optional existence
ofanemergencysystemanditsimplications, usingthe[ALT]
and[IMP]patterns. AnotherspeciÔ¨Åcationprohibitsanemer-
gency system. Other speciÔ¨Åcations combine models of the
function of the pump station with ones that specify the sep-
aration of the pumping system from the simulation part.
Robotic arm. We evaluated C&C views synthesis on a
robotic arm architecture ‚Äì speciÔ¨Åcally a rotational joint,
taken from an industrial system by VTT Tampere, Finland
(the system used as running example in this paper). The
main components of the rotational joint‚Äôs model are a cylin-
der, a servo valve, a sensor, a joint limiter, and an actuator.
The rotational joint is a subsystem of a robotic arm contain-
ing 8 rotational (identical copies) and translational joints.
Based on several requirements and partial knowledge or
particular features, we created 11 C&C views, each with
1-5 components. Some views highlight the components nec-
essary for the function of the joint while others document
design alternatives on the placement of sensor and actua-
tor components. Some of the views give an overview over
related components with only few details of their interfaces
or connectedness. Other views document complete inter-
faces of relevant components and some of their connections.
Moreover, we created 8 C&C views speciÔ¨Åcations, each com-
bining 6-8 C&C views to express design alternatives (pat-
tern [ALT]), undesired designs, and implications of design
decisions (pattern [IMP]).
Lunar lander. We evaluated C&C views synthesis on the
lunar lander model, which is used by Taylor et al. as a run-
ning example in their book on software architecture [30] and
presented in a related work by Bagheri and Sullivan [6]. The
lunar lander is space ship with various sensors, a controller,
and actuators. The objective of the lunar lander is to land
safely on the surface of the moon.
Based on the natural language description of the lunar
lander consisting of three components presented in [30, pp.
201] we have created 8 C&C views, each with 1-3 compo-
nents. Each C&C view covers parts of the natural language
description. Since this description is formulated positively,
the C&C views speciÔ¨Åcation is a conjunction of the 8 views.
Based on a shorter natural language description of the
same lunar lander with 8 components (4 sensors, one con-
troller, and 3 actuators) from [6] we have created 2 views
and again the C&C views speciÔ¨Åcation is a conjunction of
these 2 views. Both original examples from [30] and [6] con-
tained neither port names nor types, and no hierarchy. We
introducedportnamesintheC&Cviews of the3component
lunar lander example.
6.3 Observations and Lessons Learned
Performance. For some speciÔ¨Åcations, synthesis took only
a few seconds, while for others it took up to a minute tocomplete (on a regular laptop computer). Our experience
shows that relatively minor changes in a speciÔ¨Åcation, such
as ones that add no C&C views or components but only
further constrain the speciÔ¨Åcation with library components
or statements of interface completeness, and even ones that
do not aÔ¨Äect the semantics (such as diÔ¨Äerent ordering of the
models in the Boolean formula), sometimes have a signiÔ¨Å-
cant eÔ¨Äect on performance. Indeed, it is known that Alloy‚Äôs
performance, and SAT solvers‚Äô performance in general, are
sensitive to the order of variables in their input.
Since C&C views synthesis is NP-hard, one cannot expect
it to be instantaneous. Thus, we consider the resulting times
to be reasonable. As we have not made special eÔ¨Äorts to
optimize the implementation, we believe there is much room
for improvement in this regard. Also, interestingly, deciding
that a speciÔ¨Åcation is not satisÔ¨Åable was typically (but not
always) much faster than deciding that it is satisÔ¨Åable and
providing the synthesized design.
Language expressiveness. We found that the use of a
Boolean formula over C&C views, together with the pat-
terns, in particular the use of alternatives, negations, and
implications, is both expressive and easy to read and write.
We thus believe that C&C views‚Äô ‚Äòby example‚Äô characteris-
tics is attractive to engineers (our belief is supported also by
the analogous use of scenarios in behavioral speciÔ¨Åcations).
On the other hand, the use of C&C views to specify some
properties was not always natural and intuitive. Instead,
sometimes we wished to have a more Ô¨Åne-grained, Ô¨Çexible,
and powerful language that allows one to write symbolic,
succinct speciÔ¨Åcations (e.g., using quantiÔ¨Åcation). We leave
this topic for future work.
Multiple solutions. A C&C views speciÔ¨Åcation may have
more than one satisfying design. For example, consider the
speciÔ¨Åcation S1of Fig. 1. Fig. 2 shows a possible solu-
tion. An alternative satisfying design may be an architec-
ture which is identical to the Ô¨Årst except that ServoValve
contains Sensor. If this is not an acceptable design, the ar-
chitect can disallow it (e.g., by adding it, or a smaller C&C
views consisting of the ServoValve and the Sensor, in a
negated form to the speciÔ¨Åcation), and run synthesis again.
Most of our speciÔ¨Åcations had many satisfying solutions.
So, we found that it may be useful to have a better way
of choosing between solutions, e.g., by optimizing some cost
functions (hierarchy depth, ports‚Äô number, connector chains
length). This however cannot be eÔ¨Éciently done using our
current technique. We leave this issue for future work.
Handling unsatisÔ¨Åable speciÔ¨Åcations. A C&C views
speciÔ¨Åcation may be unsatisÔ¨Åable. In addition to identi-
fying unsatisÔ¨Åability, one may be interested in presenting
the root cause of conÔ¨Çicts to the engineer, i.e., to identify a
minimal subset of the speciÔ¨Åcation (Boolean formula) that is
unsatisÔ¨Åable. Note that unsatisÔ¨Åability may have more than
one cause, for example, as explained earlier in Sect. 2.2, the
speciÔ¨Åcation S2is unsatisÔ¨Åable both because of a conÔ¨Çict in
component‚Äôs containment and a port type mismatch.
Heuristics may be used to detect some simple patterns
of unsatisÔ¨Åability in linear or polynomial time. A complete
but ineÔ¨Écient solution to Ô¨Ånd a minimal subset would re-
quire an exponential number of synthesis runs. We believe
that providing tools to handling unsatisÔ¨Åable speciÔ¨Åcations
eÔ¨Éciently is an important direction for future work. One
may be able to build these on top of existing technologies for
UNSAT core, as supported by some SAT solvers. However,in order to be eÔ¨Äective, the identiÔ¨Åed core must be lifted
and presented to the engineer back using the abstractions
deÔ¨Åned by the C&C views.
7. RELATED WORK
We discuss related work in the areas of component and
connector modeling and analysis and in the area of behav-
ioralspeciÔ¨Åcations. TheuniquefeaturesofourworkonC&C
views and synthesis are its support for hierarchy, its sup-
port for abstraction of direct hierarchy, direct connectivity,
names and types, its focus on structure, and its goal, to au-
tomatically construct a satisfying C&C model from a given
set of constraints which are expressed as views and cross-
cut the implementation oriented decomposition of systems
to sub-systems.
Some previous works deal with the analysis or synthesis of
component and connector structures, mainly in the context
of architectures [6,7,13,19,21]. We discuss these works and
compare them to our work below.
Bagheri and Sullivan [6] present an approach to synthesize
style speciÔ¨Åc architecture descriptions from a style indepen-
dent application description. Our work includes support for
architecture styles too (see Sect. 5.3). Unlike our work, the
input of their Alloy-based synthesis is a single and complete
application description and not a speciÔ¨Åcation over multi-
ple, incomplete and crosscutting models like C&C views.
In [6], the application description is mapped to multiple
possible architecture descriptions in a speciÔ¨Åc style. It is
unclear whether the mapping (synthesis) can fail (besides
from choosing too small an Alloy scope). Finally, unlike our
support for hierarchical structures, the application descrip-
tion and architecture styles presented in [6] do not support
hierarchy.
Bagheri and Sullivan [6] use the lunar lander example as
a case study. Although this example is small and Ô¨Çat (and
thus does not take advantage of the unique features of our
approach), we use it in our evaluation too, for the purpose
of comparison (see Sect. 6).
Kim and Garlan [21] present formal analysis of C&C mod-
els within architectural styles, using Alloy. Unlike our work,
however, their work does not support hierarchical decom-
position of components (their conÔ¨Ågurations are Ô¨Çat). One
analysis supported is ‚Äúchecking the constructability of spe-
ciÔ¨Åc architectural conÔ¨Ågurations‚Äù (Sect. 7.2): the input is
a (partial) architecture conÔ¨Åguration and the output is an
instance of an architecture in the given style that contains
the input conÔ¨Åguration. The input in [21] consists of a single
conÔ¨Åguration and not a set of separated views as supported
in our work. Moreover, [21] does not support abstraction of
hierarchy or connectivity as is available in our work.
Issarny et al. [19,22] present a development environment
for the composition of middleware architectures. The in-
put for composition are two C&C models. The output of
the directed composition operator is a single C&C model
where possibly multiple copies of components of the sec-
ond model are connected with components of the Ô¨Årst. A
valid composition preserves communication order of the in-
put models and CTL properties checked against PROMELA
implementations of components, both speciÔ¨Åed by the user.
The work may be viewed as similar to ours, as it translates
a C&C model composition problem into a model checking
problem. It diÔ¨Äers signiÔ¨Åcantly, since the input in [19,22]
consists of concrete models without common elements, with-out hierarchies (they are Ô¨Çat) or abstraction mechanisms as
supported by C&C views. Moreover, their composition is bi-
nary and directed while ours supports Boolean speciÔ¨Åcations
over C&C views, including negation, alternatives etc.
Bouck¬¥ e et al. [7] present composition operators for C&C
modelstoavoidtherepetitionofelementsinintegratedmod-
els. The integration of sets of architecture models is based
on a user speciÔ¨Åed uniÔ¨Åcation relation (marking identical el-
ements across input models) and a submodel relation (e.g., a
component is detailed in another model). This model com-
position is thus an imperative composition of concrete C&C
models rather than a declarative one as in our approach.
We believe that our work may beneÔ¨Åt as well from a more
complex and maybe user speciÔ¨Åed uniÔ¨Åcation relation across
C&C views as suggested in [7].
Giese and Vilbig [13] discuss separation of non-orthogonal
concerns in software architecture and design. The work
deals with composition of structure as well as of behavior
from architectural views. Architectural views are deÔ¨Åned
as directed graphs representing components and connectors
extended with behavior contracts. According to [13], the
structural part of their architectural view synthesis can be
handled by superposition of these directed graphs. In con-
trast, the synthesis problem for our C&C views speciÔ¨Åca-
tions is more complex because of its rich abstraction mecha-
nisms (of direct hierarchy and connectivity) and its support
for the speciÔ¨Åcation of negative or alternative designs, which
prohibit simple superposition.
AADL [9] includes under-speciÔ¨Åcation mechanisms simi-
lar to the ones available in our work. For example, AADL
supports speciÔ¨Åcations with incomplete information of port
types and with abstract Ô¨Çows, which show the source and
sink of Ô¨Çows but not their complete path through the sys-
tem. In [9], Feiler et al. explain that the motivation be-
hind AADL‚Äôs support for partial speciÔ¨Åcations is to allow
some analysis (e.g., computing some metrics, checking syn-
tactic correctness) already during early design, before all
implementation details are known. However, a synthesis of
a complete architecture from a set of partial speciÔ¨Åcations,
as is done in our work, is not discussed.
Acme [12] allows one to specify Ô¨Årst-order predicates on
the structure of architectures, dealing, e.g., with connected-
ness between components. In AcmeStudio [5], these predi-
cates are automatically evaluated against the architecture.
The predicates are written as logical formulas, not as ab-
stract models such as C&C views. Moreover, we have not
seen any work that suggests to use these predicates as input
for synthesis of a satisfying architecture.
AspectualAcme [11] extends Acme with the modular rep-
resentation of architectural aspects and their multiple com-
position forms. The extension allows special aspectual com-
ponents to be connected to other components via special
aspectual connectors, characterized by aspectual glues of
before, after, and around types (with a semantics similar
to that of advice composition in AspectJ). This work and
ours are remotely related, speciÔ¨Åcally in the idea of crossing
the hierarchical boundaries of components and subcompo-
nents. However, the works are also very diÔ¨Äerent, as Aspec-
tualAcme deals with the extension of a given base architec-
ture and its Ô¨Åxed structure with crosscutting concerns, while
our work focuses on using declarative views as speciÔ¨Åcation
for the structure of the model and on the use of these views
for its synthesis.Previous work in our group by Gronniger et al. [14,15]
described the use of views in the context of product lines,
with a focus on the automotive domain, using SysML in-
ternal block diagrams. Like AADL, these provide under-
speciÔ¨Åcation mechanisms, e.g., to specify abstract connec-
tors. Synthesis from views was not discussed in these works.
Finally, from a broader, higher-level perspective, variants
of synthesis from partial views have been extensively stud-
ied in the area of behavioral speciÔ¨Åcations (see, e.g., the
works of Harel and Segall., Maoz and Sa‚Äôar, Uchitel et al.,
and Whittle and Schumann on synthesizing behavior models
from scenarios [17,24,31,32]). Most importantly, however,
these works assume the structure of the systems to be given;
only the behavior is synthesized!
Our work on C&C views deals with the synthesis of struc-
tures, not behaviors, and may be viewed as complementing
some of these works. As future work one may develop inte-
grated structural and behavioral synthesis techniques.
8. CONCLUSION
Wepresentedcomponentandconnectorviews, whichspec-
ify structural properties of component and connector mod-
els in an expressive and intuitive way. C&C views provide
means to abstract away direct hierarchy, direct connectivity,
port names and types, and thus can crosscut the traditional
boundaries of the implementation-oriented hierarchical de-
composition of systems and sub-systems, and reÔ¨Çect the par-
tial knowledge available to diÔ¨Äerent stakeholders involved in
a system‚Äôs design.
As a primary application for C&C views we investigated
the synthesis problem: given a C&C views speciÔ¨Åcation,
consisting of mandatory, alternative, and negative views,
construct a concrete satisfying C&C model, if one exists.
We showed that the problem is NP-hard and solved it, in
a bounded scope, using a reduction to SAT, via Alloy. We
further extended the basic problem with support for library
components, speciÔ¨Åcation patterns, and architectural styles.
The result of synthesis can be used for further exploration,
simulation, and reÔ¨Ånement of the C&C model or, as the
complete, Ô¨Ånal model itself, for direct code generation.
Several future research directions arise from our evalua-
tion in Sect. 6, including strengthening the expressiveness
of C&C views with parametrized component instantiation
or quantiÔ¨Åcation, and better handling the case where the
speciÔ¨Åcation is unsatisÔ¨Åable by providing directions to the
root cause of unsatisÔ¨Åablity (as is done in the behavioral
case when a set of scenarios is unrealizable, see [25]).
We believe that all the above can be deÔ¨Åned and imple-
mented on top of the C&C views language and the synthesis
solution presented in our work. Our ultimate future work
goal is to integrate structural and behavioral synthesis into a
single, comprehensive solution for C&C models speciÔ¨Åcation
and implementation.
9. ACKNOWLEDGMENTS
We thank S. Szekely and G. Weiss for advice on Eclipse
plug-in development. We thank A. Haber for discussions on
C&C views and help with MontiArc API. J.O. Ringert is
supported by the DFG GK/1298 AlgoSyn.10. REFERENCES
[1] AutoFocus3 website.
http://autofocus.informatik.tu-muenchen.de/ .
Accessed 2/2013.
[2] MontiArc website.
http://www.monticore.de/languages/montiarc/ .
[3] Supporting materials on C&C views synthesis.
http://www.se-rwth.de/materials/cncviews/ .
[4] AADL website. http://www.aadl.info/ . Accessed
2/2013.
[5] The ACME Studio Homepage.
http://www.cs.cmu.edu/~acme/AcmeStudio/ .
Accessed 2/2013.
[6] H. Bagheri and K. J. Sullivan. Monarch: Model-based
development of software architectures. In MoDELS
(2), volume 6395 of LNCS, pages 376‚Äì390. Springer,
2010.
[7] N. Bouck¬¥ e, D. Weyns, and T. Holvoet. Composition of
architectural models: Empirical analysis and language
support. Journal of Systems and Software ,
83(11):2108‚Äì2127, 2010.
[8] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett.
Patterns in property speciÔ¨Åcations for Ô¨Ånite-state
veriÔ¨Åcation. In ICSE, pages 411‚Äì420, 1999.
[9] P. H. Feiler, D. P. Gluch, and J. J. Hudak. The
architecture analysis & design language (AADL): An
introduction. Technical report, Software Engineering
Institute, Carnegie Mellon University, 2006.
[10] FreeMarker website.
http://freemarker.sourceforge.net/ . Accessed
2/2013.
[11] A. Garcia, C. Chavez, T. V. Batista, C. Sant‚ÄôAnna,
U. Kulesza, A. Rashid, and C. J. P. de Lucena. On the
modular representation of architectural aspects. In
V. Gruhn and F. Oquendo, editors, EWSA, volume
4344 ofLecture Notes in Computer Science , pages
82‚Äì97. Springer, 2006.
[12] D. Garlan, R. T. Monroe, and D. Wile. Acme:
Architectural description of component-based systems.
InFoundations of Component-Based Systems , pages
47‚Äì68. Cambridge University Press, 2000.
[13] H. Giese and A. Vilbig. Separation of non-orthogonal
concerns in software architecture and design. Software
and Systems Modeling , 5(2):136‚Äì169, 2006.
[14] H. Gr ¬®onniger, J. Hartmann, H. Krahn, S. Kriebel,
L. Rothhardt, and B. Rumpe. Modelling automotive
function nets with views for features, variants, and
modes. In ERTS, 2008.
[15] H. Gr ¬®onniger, J. Hartmann, H. Krahn, S. Kriebel,
L. Rothhardt, and B. Rumpe. View-centric modeling
of automotive logical architectures. In MBEES,
volume 2008-2 of Informatik-Bericht , pages 3‚Äì12. TU
Braunschweig, Institut f ¬®ur Software Systems
Engineering, 2008.
[16] A. Haber, J. O. Ringert, and B. Rumpe. Montiarc -architectural modeling of interactive distributed and
cyber-physical systems. Technical Report
AIB-2012-03, RWTH Aachen, February 2012.
[17] D. Harel and I. Segall. Synthesis from scenario-based
speciÔ¨Åcations. J. Comput. Syst. Sci. , 78(3):970‚Äì980,
2012.
[18] F. H ¬®olzl and M. Feilkas. Autofocus 3 - a scientiÔ¨Åc tool
prototype for model-based development of
component-based, reactive, distributed systems. In
Model-Based Engineering of Embedded Real-Time
Systems, volume 6100 of LNCS, pages 317‚Äì322.
Springer, 2007.
[19] V. Issarny, C. Kloukinas, and A. Zarras. Systematic
aid for developing middleware architectures. Commun.
ACM, 45(6):53‚Äì58, 2002.
[20] D. Jackson. Alloy: a lightweight object modelling
notation. ACM Trans. Softw. Eng. Methodol. ,
11(2):256‚Äì290, 2002.
[21] J. S. Kim and D. Garlan. Analyzing architectural
styles.Journal of Systems and Software ,
83(7):1216‚Äì1235, 2010.
[22] C. Kloukinas and V. Issarny. SPIN-ning Software
Architectures: A Method for Exploring Complex. In
WICSA, pages 67‚Äì76. IEEE Computer Society, 2001.
[23] H. Krahn, B. Rumpe, and S. V ¬®olkel. MontiCore: a
framework for compositional development of domain
speciÔ¨Åc languages. STTT, 12(5):353‚Äì372, 2010.
[24] S. Maoz and Y. Sa‚Äôar. Assume-guarantee scenarios:
Semantics and synthesis. In R. B. France,
J. Kazmeier, R. Breu, and C. Atkinson, editors,
MoDELS , volume 7590 of Lecture Notes in Computer
Science, pages 335‚Äì351. Springer, 2012.
[25] S. Maoz and Y. Sa‚Äôar. Counter play-out: executing
unrealizable scenario-based speciÔ¨Åcations. In ICSE,
pages 242‚Äì251. IEEE / ACM, 2013.
[26] MathWorks Simulink website.
http://www.mathworks.com/products/simulink/ .
Accessed 2/2013.
[27] MiniSat website. http://minisat.se/ . Accessed
2/2013.
[28] A. Pnueli and R. Rosner. Distributed reactive systems
are hard to synthesize. In FOCS, pages 746‚Äì757. IEEE
Computer Society, 1990.
[29] M. Shaw and D. Garlan. Software architecture -
perspectives on an emerging discipline . Prentice Hall,
1996.
[30] R. N. Taylor, N. Medvidovic, and E. Dashofy.
Software Architecture: Foundations, Theory, and
Practice. Wiley, 2009.
[31] S. Uchitel, G. Brunet, and M. Chechik. Behaviour
model synthesis from properties and scenarios. In
ICSE, pages 34‚Äì43, 2007.
[32] J. Whittle and J. Schumann. Generating statechart
designs from scenarios. In ICSE, pages 314‚Äì323. ACM,
2000.