Supporting Domain-Speciﬁc State Space Reductions 
through Local Partial-Order Reduction 
P´eter Bokor 
TU Darmstadt 
Darmstadt, Germany
pbokor@cs.tu-darmstadt.deJohannes Kinder
EPFL
Lausanne, Switzerland
johannes.kinder@epﬂ.chMarco Seraﬁni
Yahoo! Research 
Barcelona, Spain
seraﬁni@yahoo-inc.comNeeraj Suri
TU Darmstadt 
Darmstadt, Germany
suri@cs.tu-darmstadt.de
Abstract —Model checkers offer to automatically prove safety 
and liveness properties of complex concurrent software systems, 
but they are limited by state space explosion. Partial-Order 
Reduction (POR) is an effective technique to mitigate this burden. 
However, applying existing notions of POR requires to verify 
conditions based on execution paths of unbounded length, a 
difﬁcult task in general. To enable a more intuitive and still 
ﬂexible application of POR, we propose local POR (LPOR).
LPOR is based on the existing notion of statically computed 
stubborn sets, but its locality allows to verify conditions in single 
states rather than over long paths. 
As a case study, we apply LPOR to message-passing systems. 
We implement it within the Java Pathﬁnder model checker using 
our general Java-based LPOR library. Our experiments show 
signiﬁcant reductions achieved by LPOR for model checking rep- 
resentative message-passing protocols and, maybe surprisingly, 
that LPOR can outperform dynamic POR.
I. I NTRODUCTION 
The use of formal veriﬁcation methods can avoid failures 
in the design or implementation of a system and is thus of 
growing importance for the development processes of complex 
software. A successful and widely used method is model 
checking [8], which allows the fully automated veriﬁcation 
of temporal properties. Model checking is limited by state 
explosion, however, a fundamental problem in veriﬁcation, 
especially of concurrent systems. 
The state space explosion problem can be greatly mitigated 
by Partial-Order Reduction (POR) [8], a general concept for 
reducing the model checking resources such as memory and 
time. Several notions of POR implement this concept [8], [23], 
[11], differing from each other in ﬂexibility and efﬁciency. 
The commonality of these approaches is that the developer of 
a model checker is expected to verify complex conditions to 
guarantee soundness. This hurdle can prevent developers from 
implementing POR or even lead to erroneous implementations. 
In this paper, we propose an approach that simpliﬁes the
conditions to be veriﬁed, but gives up neither the ﬂexibility nor
theefﬁciency of POR. Next, we explain why previous notions 
of POR are difﬁcult to use and how our approach improves 
on them. 
The general concept of POR lies in the commutativity 
of non-interfering transitions. Conceptually, a transition is a 
Research supported in part by EC FP7 INDEXYS, LOEWE TUD CASED, 
and DFG TUD GKMM GRK 1362.Fig. 1. Non-interfering transitions t1andt2. States s12 ands3are deadlocks.
mechanism to change the state of the system, e.g., a Java 
method, or the delivery of a message. POR is based on the sim- 
ple observation that the execution of non-interfering transitions 
leads to the same state irrespective of which of these transitions 
is executed ﬁrst. In Figure 1, t1andt2are non-interfering
because both paths st1− →s1t2− →s12 andst2− →s2t1− →s12 
lead to s12 . Therefore, it is sufﬁcient to explore the execution 
of these transitions in a single representative order, reducing 
memory and time required for model checking.
POR is sound if no state is missed that is relevant for 
verifying the target property. For example, although t1andt2
are non-interfering, it is an unsound reduction to explore only 
the pathst1− →s1t2− →s12 if the property states the reachability 
of s3. Existing notions of POR deﬁne necessary conditions 
of soundness that are hard to check in general because they 
require global knowledge about the state graph, which limits
the applicability of POR. This problem is usually addressed 
by ﬁxing the application of POR to a particular speciﬁcation 
language and computational model, such that soundness is 
guaranteed by construction. As a result, existing speciﬁcation 
languages with POR support are few and restrictive in dif- 
ferent ways: they consider restricted computational models, 
for example FIFO-based message-passing [14], [13], Petri 
nets or process algebras [23], they only allow models with 
deterministic transitions [11], [8] or acyclic state graphs [10], 
[21], they preserve only invariants [12], [10], [15], or they 
only support bug ﬁnding [15]. 
We present a novel take on POR, to ease its application to 
rich speciﬁcation languages. We call our approach local POR(LPOR) because locality is key to simplify the veriﬁcation 
of POR conditions for designing new model checkers; in 
fact, the simplicity of LPOR allows an easy development 
of new PO reductions. LPOR consists of an input interface 
(accessible by the user of LPOR) and a POR algorithm 
(hidden from the user).1At the interface of LPOR, the user 
deﬁnes locally “interfering” transitions, whose soundness can
be veriﬁed more easily than the global (path-based) soundness 
conditions in other POR approaches. This local information 
is sufﬁcient for our LPOR algorithm to efﬁciently compute 
sound partial-order reductions. In the example of Figure 1, the 
user can deﬁne and verify the following local interferences: 
t2can enable t3(when executed in s), and t1is dependent 
on (is disabled by) t3(when executed in s2). Based on this 
information, the LPOR algorithm knows that t1andt2are
non-interfering and can establish that exploring only the paths 
st2− →s2t1− →s12 andst2− →s2t3− →s3preserves all deadlock 
states, a fundamental preservation property used by LPOR to 
preserve more complex speciﬁcations. 
In the following, we further detail our main contributions. 
LPOR stubborn set algorithm. LPOR’s interface (Sec- 
tion II) contains two intuitive relations between transitions, 
namely can-enable and dependency . Each of these relations 
is local, i.e., they are deﬁned given paths of at most length 
two. Transitions that are not included in these relations are 
considered to be non-interfering and are used by LPOR to 
achieve reduction. The user has to prove the non-interferences 
correct, but it is sound to declare transitions as interfering 
even when they are not. An important feature of LPOR is that 
non-interfering transitions are completely conﬁgurable, while
other approaches conservatively assume certain transitions to 
be interfering, e.g., transitions executed by the same process 
[8]. LPOR also supports necessary enabling transitions , which 
we generalize from [11]. Although the deﬁnition of such 
transitions does involve paths, they naturally appear in high- 
level languages. 
The LPOR algorithm (Section III) computes stubborn sets
statically [23] and supports general transition systems without
assumptions about the state graph or transitions. Intuitively, a 
stubborn set is a large enough subset of the transitions enabled 
in the current state, e.g., {t2}in sin Figure 1, such that no 
deadlock state remains unvisited if only transitions in stubborn 
sets are executed. LPOR leverages stubborn sets to preserve 
properties in the temporal logic CTL ∗
−X. LPOR is fast thanks 
to a novel pre-computation scheme, which allows to compute 
information needed by LPOR once, before model checking, 
and then to repeatedly use it in every new state. 
Applying LPOR to message-passing. We instantiate the 
relations at LPOR’s interface for general message-passing 
systems (Section IV). This example also shows that the use of 
LPOR is straightforward for domain experts. 
We brieﬂy discuss two additional LPOR application exam- 
ples. First, we use a Petri net example in explaining the LPOR 
1In the remainder of this paper, by user we mean the user of LPOR and 
not necessarily the end-user of the model checker. algorithm (Section III-B). Second, we show how the POR 
approach used in the SPIN model checker can be expressed 
in LPOR terms (Section VII). 
Experiments and comparison with DPOR. We implement 
LPOR as an openly available Java library called Java-LPOR 
(Section V) that easily integrates with existing model checkers. 
As an example use case of Java-LPOR, we implement our 
message-passing instantiation of LPOR in the Java Pathﬁnder- 
based model checker MP-Basset [5]. 
We evaluate the efﬁciency of LPOR using message-passing 
examples. Our experiments with MP-Basset show that LPOR 
achieves signiﬁcant (up to 94%) time and space reductions 
for model checking real-world fault-tolerant message-passing 
protocols (Section VI). Furthermore, countering current no-
tions of dynamic POR being superior to static POR [10], we 
also show that LPOR (implementing static POR) competitively 
improves upon dynamic POR without entailing the constraints 
of dynamic POR. 
II. T HE LPOR I NTERFACE 
The typical application scenario of LPOR is adding POR 
to the analysis of systems written in some speciﬁcation 
language. Assume that a model checker implementing the 
LPOR algorithm (Section III) is available for this language. 
We will show in Section V how we support the integration 
of LPOR into existing model checkers. Now, the user, an 
expert in the domain of the language, must provide two inputs 
at LPOR’s interface. First, unless it is not already available, 
she must deﬁne the semantics of the language in terms of 
a state transition system (Section II-A). Second, based on 
her domain-speciﬁc knowledge, she deﬁnes and proves two 
intuitive relations containing pairs of interfering transitions 
(Section II-B). These relations are local considering paths of 
length at most two. LPOR leverages a third optional relation, 
which is not strictly local, but naturally appears in high-level 
languages.
A. Non-deterministic State Transition Systems 
A state transition system (STS) is a triple (S,T,S 0)where
Sis the set of states, Tis the set of transitions, and S0⊆S
is the set of initial states. Every transition t∈Tis a relation 
t⊆S×S. A transition tis enabled in s∈Siff there is an 
s′∈Ssuch that (s,s ′)∈t. Otherwise, tis disabled in s. The 
set of all enabled transitions in sis denoted by enabled (s). A 
states∈Sis called a deadlock if enabled (s) = ∅. We write 
s0t1t2...t n− −−−− → snand say that there is a path from s0to sniff 
for every 0≤i < n we have that (si,s i+1 )∈ti+1 . In this 
case, we say that snis reachable froms0. If s0∈S0, then 
we say that snis reachable. A transitions tis said to be in a
paths0t1t2...t n− −−−− → snif tis among t1,t 2,...,t n.
Our approach allows transitions to be non-deterministic , i.e., 
given t∈Tands∈S, there might be multiple s′∈Ssuch
that(s,s ′)∈t. Other approaches, e.g., [11], [8], are restricted 
to deterministic transitions. On the one hand, while a transition 
system always allows to reﬁne a non-deterministic transition 
into several deterministic transitions, an implementation of such a reﬁnement is not necessarily straightforward for a 
particular system model. Furthermore, the performance of 
POR algorithms can be adversely affected by an increase in 
|T|, the number of all transitions. On the other hand, reﬁning 
transitions can improve space reduction, since only some of 
the reﬁned transitions might have to be contained in a stubborn 
set [11], [5]. Not requiring deterministic transitions leaves 
a larger design space for exploring trade-offs in transition 
reﬁnement.
B. Interfering Transitions 
A transition tcan enable another transition t′, if in at least 
one state where t′is disabled, executing tresults in a state 
wheret′is enabled. We say that a relation is can-enabling if 
it is a superset of all pairs (t,t ′)of transitions such that tcan
enablet′.
Deﬁnition 1: A relation ce ⊆T×Tis can-enabling iff 
ce ⊇ { (t,t ′)|∃ s,s ′∈S:st− →s′∧t′/\⌉}atio\slash∈ enabled (s)∧t′∈
enabled (s′)}.
We deﬁne that t′is dependent on tif both tandt′are
enabled in some state ( tandt′are co-enabled) and either (a)
tcan disable t′or (b) their subsequent execution in different 
orders results in different states ( tandt′do not commute). 
By convention, tis not dependent on itself. We say that two 
transitions are dependent (independent) if one (none) of them 
is dependent on the other. Note that the following relation is 
not necessarily symmetric.
Deﬁnition 2: A relation dep ⊆T×Tis a dependency
relation, iff dep ⊇ { (t,t ′)|t/\⌉}atio\slash=t′∧ ∃ s,s ′∈S:t,t ′∈
enabled (s)∧st− →s′and either (a) t′/\⌉}atio\slash∈ enabled (s′)or (b) 
∃s′′∈S:stt ′
− →s′′and notst′t− →s′′}.
Next, we deﬁne a relation that contains a pair of transitions 
tandt′if t′is a necessary enabling transition (NET) fort, i.e., 
t′must be executed at least once for tto be enabled (adapted 
from necessary enabling sets [11]). Note that this relation is 
based on paths. It is purely optional though as it is sound to not 
include pairs of transitions in a NET relation or, in particular, 
to deﬁne an empty one. Similarly, it is always sound to include 
a pair of (even non-interfering) transitions in can-enabling and 
dependency relations. 
Deﬁnition 3: A relation net ⊆T×Tis a necessary
enabling transition (NET) relation, iff net ⊆ { (t,t ′)|∀ s0∈
S0,∀s∈S, ∀t1,...,t n∈T:if s0t1t2...t n− −−−− → s∧t∈
enabled (s), then t′=tifor some 1≤i≤n}.
Note that the transitive closure of every NET relation is also 
a NET relation. Every user-provided NET relation can thus be 
extended to its closure. 
III. T HE LPOR S TUBBORN SET ALGORITHM 
Now we present LPOR, our local partial-order reduction al- 
gorithm. Formally, LPOR computes stubborn sets [23], which 
are subsets of enabled (s)in a state ssuch that it is sufﬁcient to 
explore transitions in such a subset. LPOR can be conﬁgured to 
preserve properties from simple deadlock-freedom to arbitrary 
LTL −Xand CTL∗
−Xspeciﬁcations. LPOR can be adapted to 
similar POR semantics such as ample [8] or persistent sets [11]. We chose stubborn sets because they allow the most 
relaxed system model. For example, both persistent and ample 
sets assume deterministic transitions.
LPOR is a static POR algorithm, i.e., given a state sof 
the system, LPOR outputs a stubborn set in swithout further
exploration (as opposed to dynamic POR [10]). Therefore, 
LPOR can be implemented in stateful (even parallel [22]) 
explicit-state model checking. We present a simpliﬁed variant 
of the LPOR algorithm that assumes that the search path, i.e., a 
path from an initial state to s, is available. The search path can 
be obtained by depth-ﬁrst search. However, a generalized form 
of LPOR makes no assumption about the search path and is 
compatible with both depth and breadth-ﬁrst search. Therefore,
it is amenable to symbolic (Binary Decision Diagram-based) 
implementations [3] as well. For space reasons, the generalized 
LPOR algorithm is presented Appendix I. 2
We ﬁrst review stubborn sets (Section III-A), then we 
present the core LPOR algorithm and sketch its correctness, 
i.e., LPOR indeed computes stubborn sets (Section III-B).
Then, we discuss some optimizations of LPOR (Section III-C) 
and the preservation of general temporal properties (Section 
III-D).
A. Preliminaries: Stubborn Sets 
Given a state s0, a set stub (s0)of transitions is (weakly)
stubborn if the two properties D1 and D2 are satisﬁed [23]. 
D1 veriﬁes the commutativity of transitions in the stubborn set 
with transitions outside the stubborn set. D2 ensures that there 
is at least one transition that cannot be disabled by transitions 
outside the stubborn set.
D1 ∀t∈stub (s0),∀t1,t 2,...,t n∈T\stub (s0),∀sn∈S:
if s0t1t2...t nt− −−−−− → snthens0tt 1t2...t n− −−−−− → sn.
D2 If enabled (s0)/\⌉}atio\slash=∅ then∃t∈
stub (s0),∀t1,t 2,...,t n∈T\stub (s0) : if 
s0t1t2...t n− −−−− → snthent∈enabled (sn). Such a transition 
tis called key transition .
A stubborn set is called strong if every t∈stub (s0)∩
enabled (s0)is a key transition. Note that a key transition is 
always enabled in s0. The unreduced state graph is explored 
by starting from an initial state and executing every transition 
in enabled (s)when a new state sis visited. The reduced state 
graph is obtained by executing only the enabled transitions 
fromstub (s). If t∈stub (s)andtis non-deterministic, then 
every s′with(s,s ′)∈tis visited. D1 and D2 guarantee 
that all deadlocks of the unreduced state graph are contained 
in the reduced one. In order to preserve properties other 
than deadlock-freedom, stub (s0)needs to satisfy additional 
constraints [23], [16]. Note that transitions in stub (s)are
not necessarily enabled in s. Although disabled transitions 
cannot be executed, they can ease the design of stubborn set 
algorithms [11] and even result in smaller stubborn sets when 
used to preserve certain temporal properties [23]. 
2Appendices are included in the technical report version of this paper 
available online [6]. function FwdEnableSetIdx (t,t ′)
1 forall (t′′ ,en )∈FwdEnableSet (t)do 
2 if (t′′ ,t ′)∈dep then return true;
3 return false ;
function FwdEnableSet (tr )
4Tr ′←{ (tr ,∅)};
5 do 
6 Tr ←Tr ′;
7 forall t1∈Tdo 
8 forall (t, en )∈Tr do 
9 if (t,t 1)∈ce then
10 en 1←en ∪{ t2|(t1,t 2)∈net };
11 Tr ′←Tr ′∪{ (t1,en 1)};
whileTr /\e}atio\slash=Tr ′;
12 return Tr ;
Algorithm 1: FwdEnableSet (t) and
FwdEnableSetIdx (t,t ′)are pre-computed for every 
t,t ′∈T.
13 Stub ←{ tI};
14 Trans ←{ tI};
15 whileTrans /\e}atio\slash=∅do 
16 chooset∈Trans ;
17 Trans ←Trans \{ t};
18 forall t1∈enabled (s)\Stub do 
19 if (t1,t )∈dep then
20 Stub ←Stub ∪{ t1};
21 if dep is non-transitive thenTrans ←Trans ∪{ t1};
22 else if FwdEnableSetIdx (t1,t )then
23 if ∃(tdep ,en )∈FwdEnableSet (t1) : ( tdep ,t )∈dep 
24 ∧(en =∅∨∀ t2∈en : ( t2/\e}atio\slash∈ Stub ∨t2∈τ)) then
25 Stub ←Stub ∪{ t1};
26 Trans ←Trans ∪{ t1};
27 return Stub ;
Algorithm 2: The LPOR (tI,s,τ )stubborn set algorithm
for a state s∈S, an initial transition tI∈enabled (s), and 
a current search path τ∈T∗.
B. The Stubborn Set Algorithm 
As stated before, the use of NET in LPOR is optional. 
We therefore start out by explaining the LPOR algorithm 
(Algorithm 2) without the NET optimization where net =∅.
1) Forward enable sets: LPOR uses two helper functions 
FwdEnableSetIdx (t,t ′)andFwdEnableSet (t)(Algorithm 1),
whose return values can be pre-computed (before model 
checking), because they are independent of the state. The 
ﬁrst function returns true if tcan be the ﬁrst in a sequence 
of enabling transitions that enables another transition t′′on 
whicht′is dependent (lines 1-3). FwdEnableSetIdx is deﬁned 
based on the forward enable set FwdEnableSet (t)of t,
which contains those transitions that can be enabled through 
a sequence of enabling transition starting with t(lines 4-12).
More precisely, the set contains all transitions t′such that
(t,t ′)is in the transitive closure of a can-enabling relation 
ce . The set contains tuples of the form (t, en )wheretis a 
transition and en is a set of transitions, which is used in the 
NET-optimized version of LPOR. If the NET relation is empty, 
en is also empty (line 10). We now explain how LPOR uses 
these two functions to compute stubborn sets. 
2) Stubborn set computation: In addition to the relations 
ce ,dep , and net , LPOR has three parameters: (1) a transition 
tI∈enabled (s), called initial transition , which is in the stubborn set, (2) the current state s, and (3) the search path 
τ∈T∗(for Algorithm 2, it sufﬁces that τis a set containing 
t1,...,t n). From D2, no stubborn set in scan be empty unless 
enabled (s) = ∅. Conceptually, LPOR proceeds, similarly to 
other static POR algorithms, by applying different rules of the 
form “iftis in the stubborn set, then transitions t1,t 2,... must
also be in the set”. In this case, we say that t1,t 2,... are added
on behalf of t. LPOR maintains two sets of transitions: Stub,
which represents the stubborn set (line 13) and Trans , which 
contains a transition tin Stub such that new transitions might 
be added to Stub on behalf of t(line 14). Therefore, LPOR
adds transitions to Stub until Trans is empty (lines 15-26) and 
Stub is returned (line 27). We now explain how transitions are 
added on behalf of a transition tin Trans .
First, we add those enabled transitions t1thattis dependent 
on (lines 19-21). We add t1if either t1andtdo not commute 
(disallowed by D1) or it can disable t(which can violate D2).
Note that dep does not have to be symmetric as D1 allows 
thattandt1do not commute. We will show an example of 
this case in a message-passing instance of LPOR (Section IV). 
There is another way to violate the stubborn set conditions: 
an enabled transition t1outside the stubborn set can start a
sequence of enabling transitions that enables another transition 
on which tis dependent (D1). This can only happen if 
FwdEnableSetIdx (t1,t )is true (line 22). In this case, we 
addt1to the stubborn set (line 25). Note that the condition 
in lines 23-24 is trivially true if LPOR is run without NET 
optimization because the en -sets are empty.
In both previous cases, t1is added to Trans (line 21 and 
26) so that LPOR can verify whether new transitions must 
be added on behalf of t1. We discuss the optimization for 
transitive dependency relations (line 21) in Section III-C. 
3) NET optimization: Stubborn set computation can beneﬁt
from the NET relation if more than one transition t2is 
necessary for some transition t1to be enabled. In this case, a 
stubborn set does not need to contain allsucht2but only one
that has not been executed yet. The NET optimization cannot 
be fully pre-computed as the check whether “a transition has 
not been executed yet” can only be carried out during the 
search. However, we can store these t2transitions in the en -
ﬁeld associated with t1. It is key to our NET optimization that 
the content of en -ﬁelds is propagated along the can-enabling 
relation, i.e., if tcan enable t1and(t, en )and(t1,en 1)are in 
a forward enable set, then en ⊆en 1(line 10). This is because 
the transitions necessary to be executed for tto be enabled 
are, transitively, also necessary to be executed for t1to be 
enabled.
Then, using the notation of Algorithm 2, if some t2is in 
theen -ﬁeld associated with a transition tdep , we can verify, 
given the current state s, that “ t2has not been executed yet”. 
Assume that (tdep ,en )is in the forward enable set of t1and
the conditions in lines 22-23 are true. Then, we only add t1
to the stubborn set if either t2is not in the stubborn set or 
t2has already been executed, i.e., is contained in the model 
checker’s current search path τ(line 24). Note that, for some
transition t,(t, en )can be in a forward enable set multiple Fig. 2. A Petri net example. 
times with different en . This is possible if tcan be enabled 
by different sequences of transitions. 
4) Example: We illustrate the LPOR algorithm on 
a simple Petri net example (Figure 2). For this net, 
ce ={(t3,t 2),(t4,t 3),(t5,t 3)},dep ={(t1,t 2),(t2,t 1)},
net ={(t4,t 3),(t5,t 3)}are valid enabling, dependency, and 
NET relations, respectively. Note that we omit the possible 
(t3,t 2),(t4,t 2), and (t5,t 2)fromnet for this example. Figure 
2 depicts the initial token marking s; the set of enabled 
transitions in sis {t1,t 4,t 5}. Consider a run of LPOR in s
with initial transition t1, i.e., LPOR (t1,s, ()) . As t2is disabled 
in s, no transition is added to the stubborn set in lines 19-21. 
Supposed that transitions are processed by ascending index, 
t4is added to the stubborn set because FwdEnableSet (t4) = 
{(t4,∅),(t3,{t4,t 5}),(t2,{t4,t 5})},(t2,t 1)∈dep , and 
t4andt5are both not in the stubborn set. However, 
thanks to the NET optimization t5is not added because 
FwdEnableSet (t5) = {(t5,∅),(t3,{t4,t 5}),(t2,{t4,t 5})},t4
already is the stubborn set, and τis empty. As a result, 
LPOR(t1,s, ()) = {t1,t 4} ⊂ enabled(s).
5) Correctness: The next theorem states that LPOR indeed 
generates stubborn sets. The proof of the theorem can be found 
in Appendix II. A sketch of the proof is given below. 
Theorem 1: Let(S,T,S 0)be an STS and ce ,dep , and net 
a can-enabling, dependency, and NET relation, respectively. 
Then, for all s∈S,tI∈enabled (s), and τ∈T∗with
∃s0∈S0:s0τ− →s, LPOR(tI,s,τ )is a stubborn set. 
Proof sketch.: A key property of LPOR is that, when 
executed in a state s=s0, every transition tin LPOR (tI,s,τ )
is independent of all transitions t1,t 2,...,t nthat are in a path 
starting from sand that are outside LPOR (tI,s,τ ). To show 
that D1 and D2 hold, consider the paths starting from s0, as 
illustrated in Figure 3. 
We ﬁrst show that tis a key transition (D2). Indirectly, 
assume that tifor some 1≤i≤ncan disable t, i.e., 
t/\⌉}atio\slash∈ enabled (si). Therefore, tmust be dependent on ti, a 
contradiction by the previous property. 
As tis a key transition, t∈enabled (si)for every 1≤i≤
n. Let s′
nbe a state such that sn−1tn− →snt− →s′
n. From the Fig. 3. Illustration of the proof of Theorem 1. 
above property, tis independent of tn, so there exists s′
n−1
such that sn−1t− →s′
n−1tn− →s′
n. Repeating this rule ntimes,
we obtain a path st− →s′t1− →s′
1t2− →... tn−1− −− →s′
n−1tn− →s′
n,
which proves D1. 
6) Worst-case complexity: Algorithm 2 is guaranteed to 
terminate (proof in Appendix II) and has worst-case time 
complexity O(|T|32|T|)with and O(|T|2)without NET opti-
mization. Despite the worst-case exponential overhead of the 
NET optimization, our experiments show that LPOR with NET 
can achieve signiﬁcant reductions of model checking time 
(Section VI).
We now sketch the idea behind the above complexity results. 
Assume that checks for set inclusion and adding/removing
elements to/from sets take constant time. The basic quadratic 
time complexity in |T|is due to (1) Trans containing at most 
|T|transitions (line 15), and (2) adding at most |T|transitions
to the stubborn set on behalf of every transition in Trans (line
18). Note that every transition in Trans is also in Stub and no 
transition is ever removed from Stub. Therefore, the condition 
in line 18 and that enabled (s)is ﬁxed throughout an execution 
of Algorithm 2 guarantee that every transition is added at most 
once to Trans . Without NET optimization, the condition in 
lines 23-24 is always true. Therefore, no computation overhead 
is added in this case. With NET optimization, the condition 
requires to range through possibly each element in a forward 
enable set and check if this element is in the stubborn set. As 
elements of the forward enable set are tuples of a transition 
and a subset of transitions, the maximum size of such a set is 
|T|2|T|.
C. Further Optimizations and Possible Extensions 
First, if the dependency relation is transitive, then the 
enabled transition t1does not have to be added to Trans (line
21). This is sound because all transitions that would be added 
to the stubborn set on behalf of t1are also added on behalf 
of t.
LPOR is a non-deterministic algorithm with three main 
sources of non-determinism, each of them possibly affecting 
the size of the stubborn set: (1) the selection of the initial 
transition, (2) the selection of tin line 16, and (3) the order 
in which forall iterates through the transitions in line 18. The 
tuning of these parameters in such a way that they result in 
small stubborn sets depends on the analyzed system. 
We improve the NET-optimization by making it state- 
conditional, i.e., t′is a NET for tin a state sif tis not 
enabled in sandt′must be in any path starting from sbeforetcan be enabled. The details of this optimization can be found 
in Appendix I. While state-conditionality can increase the 
achieved state-reduction, it also increases the time-overhead 
by limiting the possibilities for pre-computation. 
The NET optimization can be generalized to necessary 
enabling sets, i.e., for each transition ta set T′of transitions 
such that at least one transition in T′must be executed for t
to be enabled. This gives more ﬂexibility compared to LPOR 
whereT′contains at most one transition. 
LPOR computes strong stubborn sets, which implies that
all transitions that can disable a transition tin the stubborn 
set are also included in the set. In general, it is possible that 
a transition is removed from a strong stubborn set such that 
the resulting set is stubborn in the weak but not in the strong 
sense. However, an algorithm computing weak stubborn sets 
can incur a higher time overhead; in LPOR, this would require 
to reﬁne dependency in terms of “can disable” and “might not 
commute” relations.
D. Preserving Temporal Logics with LPOR 
The reduced search using stubborn sets preserves all dead- 
locks of the unreduced state graph. In order to preserve other 
properties such as invariants or liveness, stubborn sets must 
satisfy constraints in addition to D1 and D2. LPOR can be 
conﬁgured to preserve a general class of properties written in 
CTL∗
−X(Computational Tree Logic without the next operator) 
[8], [16]. Subclasses of this logic include simple invariants or 
LTL −X(Linear Temporal Logic without the next operator). 
For details of how LPOR can be used to preserve CTL ∗
−X
properties, we refer the reader to Appendix III. 
IV. A C ASE STUDY : LPOR FOR MESSAGE -P ASSING 
We now brieﬂy introduce a general language for message- 
passing systems (with detailed formalization in Appendix V) 
and deﬁne suitable LPOR relations (from Section II). The
simplicity of these deﬁnitions shows that the use of LPOR 
is indeed straightforward for domain experts. 
A. Specifying Message-Passing Systems 
A message-passing (MP) system (or protocol) consists of 
processes that communicate via messages . Every process 
maintains a local state that is updated by executing local, 
guarded transitions from a set T. A transition tis executed 
by process id (t)if the guard of tevaluates to true; the guard 
depends on the incoming messages and the local state of the 
process. The execution of a transition is an atomic event which 
consumes zero or more messages received by the executing 
process, changes the local state, and sends multiple messages
on behalf of the process. A transition is called a quorum tran-
sition if it can consume multiple messages. Transitions can be 
non-deterministic. For example, if a transition can be executed 
for two different incoming messages, then the ﬁrst message 
to be consumed by the transition is non-deterministically 
selected. The global state of the system consists of the 
local process states and all undelivered messages. An STS 
corresponding to an MP protocol can be naturally deﬁned such thatS,T andS0are the sets of states, transitions, and initial 
states of the MP system, respectively. 
So far, the language resembles the usual formalization 
of message-passing systems [2], [4]. Now, we extend the 
syntax with some special transitions. Every transition tcan
be associated with t.M I(andt.M O), the set of messages 
possibly received (sent) by t, and t.I (andt.O ), the set of 
processes that tcan receive (and send) messages from (to). 
We assume the local state of a process to be an assignment 
of values to local variables . Given a variable x,tis a write 
transition with respect to xand we write x∈W(t)if tcan
change the value of xin some state. Similarly, tis called 
aread transition ( x∈R(t)) if the guard of tdepends on 
the value of x. As a special case, a write transition tis an 
increment transition ( x∈Inc (t)) if talways increases the 
value of x. Increment transitions are relevant in the context 
of timestamp-compare read transitions t(x∈CompTS (t)), a 
class of transitions common in concurrent systems, e.g., [17]. 
Such a transition tusesxto store a “timestamp” and compare 
it with the timestamps of incoming messages. The guard of 
tcan be true only if the timestamp of the message is greater 
or equal than the current value of x. The sets R(t),W(t),
Inc (t), and CompTS (t)can be conservatively determined by 
lightweight static analysis.
B. LPOR Relations for Message-Passing Systems 
1) Can-enable relation: We say that a transition tcan
locally enable another transition t′of the same process if tis a 
write and t′is a read transition with respect to some common 
variable x. An exception to this rule is if tis an increment 
andt′is a timestamp-compare transition with respect to x.
In this case tcannot enable t′because a process sends no 
new message to itself and the timestamp xis increased by t.
Formally, can-local-enable = {(t,t ′)|id (t) = id (t′)∧ ∃ x∈
W(t)∩R(t′) : x/\⌉}atio\slash∈ Inc (t)∩CompTS (t′)}, where id (t)
denotes the process executing transition t.
A transition tcan remotely enable a transition t′if it 
may send messages that can be received by t′. A necessary 
condition for this to happen is that tandt′are executed by 
different processes ( id (t)/\⌉}atio\slash=id (t′)), that transition tcan send
a message to the process executing t′(id (t′)∈t.O ), that 
transition t′can receive a message from the process executing 
t(id (t)∈t′.I ), and that tcan send a message that can be 
received by t′(t.M O∩t′.M I/\⌉}atio\slash=∅). Therefore, we deﬁne 
that can-remote-enable = {(t,t ′)|id (t)/\⌉}atio\slash=id (t′)∧id (t′)∈
t.O ∧id (t)∈t′.I ∧t.M O∩t′.M I/\⌉}atio\slash=∅} .
Deﬁnition 4: Given an MP system, MP-can-enable =
can-remote-enable ∪can-local-enable.
2) Dependency relation: A transition t′is dependent on t
if both are executed by the same process or if tcan remotely
enablet′. The intuition is that local transitions may change the 
state of the same process and, if tcan remotely enable t′, then 
tcan send a message that is processed by t′. Our dependency 
relation can be reﬁned by excluding pairs of transitions that 
are executed by the same process and access a disjunct set 
of variables. This is a reﬁnement that we do not consider in this paper. Note that the following relation can be asymmetric, 
which enables LPOR to compute smaller stubborn sets. 
Deﬁnition 5: Given an MP system, MP-dependency =
{(t,t ′)|t/\⌉}atio\slash=t′∧id (t) = id (t′)}∪ can-remote-enable.
3) NET relation: The following NET relation is based on 
the observation that a transition twitht.I /\⌉}atio\slash=∅cannot be 
enabled unless a process sends a message to process id (t).
For example, imagine that trepresents a function that requires 
input from a majority of processes. This implies that |t.I |=
⌈n
2⌉, i.e., a majority of the number of all processes n. Then, 
tcan be enabled only after each of these processes has sent a 
message to process id (t).
Note that we have to check two additional conditions to 
make sure that a transition is indeed a NET for t. Firstly, tis 
required to be input-deterministic , i.e., talways consumes a 
message from every process in t.I . Otherwise, tcan possibly
be enabled even if a process in t.I sends no message to process 
id (t). Secondly, it is possible that i∈t.I and process ihas
multiple transitions, say t′andt′′, that can enable t(formally,
id (t′′) = id (t′)∧t′′/\⌉}atio\slash=t′∧ { (t′,t ),(t′′,t )} ⊆ can-remote-
enable). In this case, neither t′nort′′is necessarily a NET 
fort.
The NET relation is deﬁned below. In Appendix I, an 
example is shown of how the content of the channels can 
be used to make this relation state-conditional. 
Deﬁnition 6: Given an MP system, MP-NET
={(t,t ′)|tis input-deterministic ∧id (t′)∈t.I ∧∀ (t′′,t )∈
can-remote-enable: t′′=t′∨id (t′′)/\⌉}atio\slash=id (t′)}.
The next theorem states that the above relations are indeed 
LPOR relations as of Section II-B, a task that must be carried 
out by the user. The proof of this theorem can be found in 
Appendix IV.
Theorem 2: Given an MP system, MP-can-enable ,MP-
dependency andMP-NET are can-enabling, dependency, and 
NET relations, respectively. 
V. J AVA -LPOR: A NLPOR I MPLEMENTATION 
We implement LPOR in a Java library, called Java-LPOR. 
Java-LPOR can be integrated into any explicit state model 
checker. The LPOR algorithm currently implemented by Java- 
LPOR computes stubborn sets satisfying D1, D2, and an 
additional constraint regarding visible transitions [8], i.e.,
transitions that might interfere with the target property. This 
constraint of visible transitions allows LPOR to preserve 
invariants , i.e., state-local assertions that must hold in every 
reachable state. The source code of Java-LPOR is available 
for download 3.
The main steps of integrating Java-LPOR are as follows. 
As a running example, we show how we used Java-LPOR to 
implement message-passing LPOR from Section IV.
1) Specifying the transitions: Before the search can start,
the transitions of the system must be provided as Java 
classes. For example, the input language of MP-Basset [5], our 
model checker for message-passing protocols, is an extension 
3http://www.deeds.informatik.tu-darmstadt.de/peter/Java-LPOR.jar of Java and implements the language from Section IV-A. 
Within MP-Basset, transitions are represented by the class 
TransitionMP .
2) Implementing the LPOR relations: Java-LPOR exports 
LPOR’s relations via the following interface. This generic 
interface is parametric in the class Tof transitions. 
public interface LPORRelations<T> {
public boolean dep(T t1,T t2);
public boolean canEnable(T t1,T t2);
public boolean net(T t1,T t2);
}
For example, the following snippet shows the implementa- 
tion of our dependency relation for message-passing systems 
(compare with Deﬁnition 5). The method t1.isLocal(t2)
returns true iff id (t1) = id (t2).
public boolean dep(TransitionMP t1,TransitionMP t2){
return !t1.equals(t2) && 
t1.isLocal(t2) || canRemoteEnable(t1, t2); 
}
3) Setting up LPOR: For the preservation of invariants, 
Java-LPOR requires to identify visible transitions. In our 
current implementation, the user is required to annotate visible 
transitions using the following interface.
public interface VisibilityChecker<T> {
public boolean isVisible(T t);
}
Given the list of all transitions trans , the LPOR rela- 
tionsrel, and a class vis for checking visible transitions,
an LPOR utility instance can be created. Its constructor is 
responsible for pre-computing the forward enable sets. The
instance of LPORUtil can then be used to compute stubborn 
sets for a particular state by invoking the LPOR method. As 
arguments, the method requires an initial transition and the list 
of enabled transitions. Transitions are identiﬁed by their index 
in trans .
public class LPORUtil<T>{
public LPORUtil(List<T> trans,
LPORRelations<T> rel,
VisibilityChecker<T> vis){
this.trans=trans;
this.rel=rel;
this.vis=vis;
precompute();
}
public int[] LPOR(int t_I, int[] enabledTrans){
...
}
...
}
4) Computing stubborn sets: Finally, the following snippet 
shows how the set of transitions that must be executed in a 
state is pruned by a call to the LPOR method of an LPORUtil
instance. This is also how we integrated Java-LPOR into MP- 
Basset.
enabledTrans=lporUtil.LPOR(initTrans, enabledTrans);
VI. LPOR E XPERIMENTS 
In this Section, we present our results of using LPOR to 
model check various fault-tolerant message-passing protocols. TABLE I 
PERFORMANCE RESULTS OF LPOR IMPLEMENTED WITHIN MP-B ASSET USING JAVA -LPOR. 
Unreduced DPORLPORProtocol Res. Stateless LPOR only LPOR + NET (# processes) States Time States Time States Time (on-line) States Time (on-line) States Time (on-line) 
Paxos (6) OK >38mil>192h 3,305,752 22h53m 1,118,341MJI 6h14m (6h19m)1,130,234MJI 6h59m (7h1m)548,061MJI 3h18m (3h21m)
Mod. 8h51m (28h32m) Mod. 8h51m (24h10m) Mod. 4h45m (18h52m)
F-Paxos (6) CE 238,790 1h34m 2,028 50s 3489 MJI 1m16s 3489 MJI 1m43s 3415 MJI 1m40s
F-Paxos2 (7) CE >16mil>192h 21,177 12m31s 175,725 MJI 1h24m 173,414 MJI 1h25m 173,414 MJI 1h28m
Register (5) OK 287,638 47m 27,763 6m50s 27,763MJI 5m57s (5m59s)18,451MJI 4m32s (4m32s)18,451MJI 4m36s (4m36s)
Mod. 6m17s (9m23s) Mod. 5m3s (7m1) Mod. 4m55 (7m52s)
Register (5) CE 7,619 1m52 2,344 40s 4,654 MJI 1m4s 3,497 MJI 55s 3,497 MJI 58s
Register (6) CE 24,939,222 181h 11,235 3m56s 11,235 MJI 3m37s 6,987 MJI 2m32s 6,987 MJI 2m34s
Multicast (5) OK 7,279 1m34s 7,945 1m46s 2,674MJI 38s (38s)6,607MJI 1m29s (1m30s)2178MJI 37s(37s)
Mod. 1m2s (1m47s) Mod. 2m7s (2m7s) Mod. 59s (1m46s)
Multicast (6) OK 102,058 28m13s 183,265 44m45s 24,382MJI 6m12s94,186MJI 26m26s12,494MJI 3m34s
Mod. 7m8s (11m2s) Mod. 29m32s (31m15s) Mod. 5m4s (9m32)
Multicast (6) CE 7,543 3m32s 4,890 2m8s 4,890 MJI 1m57s 2,139 MJI 1m4s 2,139 MJI 1m47s
A. Target Protocols and Properties 
We selected the following representative protocols: 
Paxos [17], a widely-used [24], [26] crash-tolerant consensus 
protocol, the Byzantine-tolerant Echo Multicast protocol [20],
and a crash-tolerant regular storage protocol in the style 
of [1]. We assume meaningful ﬁnite protocol instances where 
at least one process fault is tolerated. 
We consider the main safety properties of these protocols, 
namely Paxos must not return different values (consensus), 
Echo Multicast sends the same value to each recipient (agree- 
ment), and a read operation returns a value not older than the 
one written by the latest preceding write operation (regularity). 
Each of these properties can be expressed by invariants, a 
class of properties preserved by LPOR. For evaluating the 
bug-ﬁnding capabilities of LPOR, we inject faults into both 
the protocols and the properties.
A detailed description of these speciﬁcations can be found 
in Appendix VI. 
B. Comparison with Dynamic POR 
We compare LPOR with dynamic POR (DPOR) [10]. We 
explain how DPOR differs from static POR (SPOR) in Section 
VII. In general, the beneﬁt of DPOR is that it needs to be 
less conservative about the selection of paths that are explored 
in the reduced search. However, our experiments show the 
efﬁciency of LPOR over DPOR, improving on the reductions 
of a message-passing DPOR implementation. 
Like any SPOR algorithm, LPOR can be soundly combined 
with DPOR for further reduction [10]. This must respect the
restrictions imposed by DPOR, however. For example, DPOR 
assumes the absence of cycles in the state space. We only 
consider protocol examples with acyclic state spaces for a fair 
comparison.
We compare LPOR with the original DPOR algorithm by 
Flanagan and Godefroid [10] because this preserves (with the 
visibility constraint) the properties of our example protocols. 
For example, the DPOR variant in [21] only guarantees that 
every transition executed in the unreduced search is also 
executed in the reduced one. 
In order to preserve invariants, Java-LPOR prevents non- 
trivial stubborn sets from including visible transitions [23], [8].This constraint can also be implemented in DPOR such that if 
a visible transition is executed in a state during the search, 
then all enabled transitions in this state will be executed. 
For comparing LPOR with DPOR, we use the Basset model 
checker [18], which implements an adaptation of Flanagan and 
Godefroid’s DPOR algorithm for actor programs. The actor 
semantics used in Basset is similar to our model of message- 
passing except that quorum transitions are not supported. 
Therefore, we extended Basset’s DPOR implementation with 
quorum transitions: when a process executes a quorum tran- 
sition, the vector clock of the process will be updated to be 
the maximum of (1) its current value and (2) the values of the 
vector clocks of the senders of the messages, where the values 
correspond to the time of sending the message. In Basset this 
computation involves one sender as every transition consumes 
a single message. 
C. Experimental Setup 
We run our experiments in a DETERlab testbed [29] on 
2GHz Xeon machines. We compare LPOR with the unreduced 
models and DPOR, our extension of Basset’s DPOR imple- 
mentation as explained above. We integrated both this DPOR 
algorithm and LPOR (as described in Section V) within the 
MP-Basset model checker [5]. The source of this version of 
MP-Basset is available online [28]. For fair comparison, both 
of our POR implementations use the same heuristic for initial 
transitions. We refer the reader to Appendix VI for details of 
this heuristic. DPOR is run as stateless search because DPOR 
can be unsound if state comparison is used [10]. 
We use three versions of the LPOR algorithm. First, we 
run the full-ﬂedged algorithm but switch off state comparison 
(stateless). Second, we run a stateful search but switch off 
the NET optimization (LPOR only). Third, we run stateful 
search and LPOR with (state-conditional) NET support (LPOR
+ NET). We also count the number of visited states in the 
stateless searches, for both LPOR and DPOR.
D. Our Reduction Results 
The results of our experiments are shown in Table I. We 
write OK if the model checker ﬁnds no bug, otherwise (in case 
of faulty protocols or wrong speciﬁcations) a counterexample (CE) is returned. F-Paxos and F-Paxos2 are two faulty versions 
of Paxos. We used wrong speciﬁcations for the other protocols. 
The best result for each protocol instance is written in bold. 
In buggy instances the search is stopped after ﬁnding the ﬁrst 
bug, i.e., the search is non-exhaustive. Therefore, the number 
of visited states depends on the order in which transitions are 
executed in a state. This schedule can be different in DPOR 
and LPOR.
We observe that: 
•The POR-based search ﬁnds bugs faster than unreduced 
search and there is no clear winner between DPOR and 
LPOR.
•LPOR is highly efﬁcient as shown by the exhaustive 
search results (OK) reducing the number of states by up 
to to 94% and search time by up to 90% – see register 
example. 
•Although the additional online checks in the NET op- 
timization slow down LPOR (as discussed in Section 
III-B), e.g., 74 states/sec versus 59 states/sec for exhaus- 
tive Multicast (5), the additional state reduction can add 
up to reducing the total model checking time. Indeed, 
the NET optimization can be very efﬁcient by achieving 
additional space and time reductions of up to 87% – see 
Multicast (6) exhaustive search result. 
•LPOR outperforms DPOR in allexhaustive search experi- 
ments, even in stateless search where the beneﬁt of LPOR 
is not biased by the stateful optimization. In addition, 
LPOR proves to be more time efﬁcient than DPOR, i.e., 
the time overhead of LPOR is smaller. For example, the 
stateless exhaustive runs of Register (5) visit the same 
number of states but LPOR is faster. 
E. Execution Time Issues 
In this Section, we discuss the trade-offs affecting the time 
overhead of LPOR as implemented within MP-Basset. 
MP-Basset is an extension of Basset [18], a model checker 
for actor programs. Basset, in turn, builds on Java Pathﬁnder 
(JPF) [27], a stateful model checker for Java. Similarly to 
Basset, MP-Basset is a Java application run by JPF. As such, 
it can run Java code at two levels [27]: ﬁrst, in the modeled 
layer, which is a JPF-simulated JVM; second, in the host 
JVM (where JPF also runs), which is accessible from the 
modeled layer via an interface called Model Java Interface 
(MJI). Roughly speaking, JPF explores the state space of the 
application run in the modeled layer. Due to the indirection 
of the modeled layer, execution in this layer is slower than in 
the host JVM. The modeled application can always execute 
code in the host JVM using MJI. However, as there is a speed 
penalty of using MJI, time efﬁcient JPF applications should 
use MJI with care. One source of this time overhead is that MJI 
converts parameters of MJI method calls between the modeled 
and the host JVM’s object model. 
To explore this trade-off, we created and compared two 
architectures, one where the LPOR algorithm runs in the 
modeled layer and another one where it runs in the host JVM. 
In our experiments, the MJI-based implementation was faster. This meets our expectations for (state-unconditional) “LPOR 
only” because no state information is passed (and thus con- 
verted) to Java-LPOR, whereas in (state-conditional) “LPOR 
+ NET”, the NET relation is a function of a small fraction 
of the current state (see Section IV-B). For our message- 
passing instantiation of LPOR, the MJI overhead turns out 
to be more time efﬁcient than executing the LPOR algorithm 
in the modeled layer even in the “LPOR + NET” case. This 
does not necessarily generalize. In other LPOR applications, 
particularly where the entire state has to be converted for MJI, 
the execution time penalties may trade off differently. 
Table I shows the model checking time of both implemen- 
tations (MJI and Mod. stands for the implementation in the 
modeled and the host JVM layer, respectively). For space 
reasons, we omit the modeled layer times for the CE results 
as they show similar trends as for OK. 
We also measure the beneﬁt of using pre-computation. 
The times where forward enable sets are computed on-line
(no pre-computation) are written in parentheses. Otherwise, 
the times shown include the time of pre-computation. The 
beneﬁt of pre-computation is signiﬁcant in the modeled layer 
implementation. We observe a higher relative gain of using 
pre-computation in NET optimized LPOR. The reason is that 
forward enable sets containing non-empty en -ﬁelds (in the
NET optimized case) tend to be larger, thus, their computation 
takes longer. The reason why the MJI implementation does 
not greatly beneﬁt from pre-computation for our particular
protocol examples is two-fold: ﬁrst, lines 22-26 in LPOR 
(Algorithm 2) are executed in a relative small number of states; 
second, the body of the do-while loop in the forward enable set 
computation (Algorithm 1) is executed only a few (1-2) times 
during an average invocation of FwdEnableSet . We leave the 
investigation of other protocols, which could very well show 
a completely different proﬁle, for future work. 
VII. R ELATED WORK 
The basic structure of the LPOR algorithm is similar to 
Godefroid’s stubborn (and persistent) set algorithms [11], 
which start with a transition and keep adding new transitions 
using the dependency and can enabling relations until the 
current set of transitions is not stubborn. An application of 
these algorithms to new languages is only possible after a 
translation into a speciﬁc language used in [11] that speciﬁes 
processes communicating via shared objects. Transitions in 
this language are assumed to be deterministic. Furthermore, 
the algorithms in [11] do not support pre-computation. The 
ample set algorithms in [8], [14], [13] also restrict to process- 
based systems and deterministic transitions. Moreover, they 
conservatively assume that a non-trivial ample set consists of 
all enabled transitions of a particular process. 
Promela is a general language with explicit support for 
multi-process systems and message-passing. SPIN is a widely- 
used model checker for speciﬁcations written in Promela [13]. 
SPIN supports a speciﬁc form of POR, which is based on 
the observation that transitions t1andt2are independent if 
they are from different processes and t1is the only transition writing to (or reading from) a FIFO channel (exclusive write 
or read, respectively) [14], [13]. Such interferences can be 
easily expressed in LPOR by excluding (t1,t 2)and(t2,t 1)
from the dependency relation. We note that in the description 
of [14], t1andt2are considered “independent” only in states 
where the channel is non-empty (non-full). This is because 
their deﬁnition of dependency includes that a transition can 
enable another transition. In fact, t1can enable read (send)
transitions but t1andt2are always (state-unconditionally) 
independent in the sense of Deﬁnition 2. 
It is possible to give a graph theoretic implementation of 
LPOR as proposed in [23]. In this approach, the vertices of the 
graph are transitions and tis connected to t1if t1needs to be 
added to the stubborn set on behalf of t. Then, certain vertices 
of this graph, e.g., included in properly selected strongly 
connected components, correspond to stubborn sets. 
Dynamic POR (DPOR) [10] is a POR implementation 
which computes a persistent set in some state sgradually while
the successors of sare explored. In this way the persistent set 
algorithm can learn about interfering transitions and needs not
to guess them as in static POR. In other words, DPOR explores 
future paths instead of guessing them. However, DPOR also 
makes static assumptions about co-enabled dependent transi- 
tions. Furthermore, DPOR is inherently a depth-ﬁrst search, it 
needs to know the sequence of transitions in the current path 
(which is not straightforward in parallel model checking [22]) 
and can be unsound with stateful model checking [25]. 
In recent work [5], we propose a heuristic to translate from 
one transition system to another to maximize the reduction of 
POR and apply it to message-passing systems. This translation 
is orthogonal to LPOR, which requires a transition system at 
its input.
The input relations of LPOR can be partly or entirely 
derived automatically using a SAT solver, an approach similar 
to [7]. Moreover, SAT-based bounded model checking can be 
used to compute more accurate enabling sequences than our 
forward enable sets. For example, given transitions t1,t 2,t 3,
it is possible that t1can enable t2, and t2can enable t3, but 
t2cannot enable t3if t2was enabled by t1.
VIII. C ONCLUSIONS 
We have proposed LPOR, a framework for easy-to-use, 
ﬂexible, and efﬁcient POR implementations. While existing 
POR implementations trade ﬂexibility for ease-of-use and 
efﬁciency, e.g., SPIN’s POR limits to exclusive write/read 
FIFOs or DPOR prohibits cycles, the strength of LPOR is that 
it provides these features at the same time. In ongoing work, 
we study if state-conditional can-enabling and dependency 
relations can improve on LPOR’s reductions. For example, a 
state-conditional can-enabling relation can be used to rule out 
transitions t1in line 22 of Algorithm 2 that cannot enable any 
transition in the current state. Another possible extension is to 
add symmetry reduction to LPOR. Although PO and symmetry 
reductions are compatible in theory [9], no implementation of their combination is available nor its efﬁciency was tested on 
real examples. 
Acknowledgement. We thank Gerard Holzmann for his in- 
sights of the POR theory as implemented by SPIN to enable 
an objective comparison across LPOR and SPIN. 
REFERENCES 
[1] H. Attiya, A. Bar-Noy, D. Dolev. Sharing Memory Robustly in Message- 
Passing Systems. J. ACM , 42(1):124–142, 1995. 
[2] H. Attiya, J. Welch. Distributed Computing . John Wiley and Sons, 2004. 
[3] R. Alur, R. Brayton, T. Henzinger, S. Qadeer, S. Rajamani. Partial-Order 
Reduction in Symbolic State-Space Exploration. FMSD , 18(2): 97–116, 
2001.
[4] P. Bokor, M. Seraﬁni, N. Suri. On Efﬁcient Models for Model Checking 
Message-Passing Distributed Protocols. FORTE , pp. 216–223, 2010. 
[5] P. Bokor, J. Kinder, M. Seraﬁni, N. Suri. Efﬁcient Model Checking of 
Fault-Tolerant Distributed Protocols. DSN-DCCS , pp. 73–84, 2011. 
[6] P. Bokor, J. Kinder, M. Seraﬁni, N. Suri. Supporting Domain- 
Speciﬁc State Space Reductions through Local Partial-Order Re- 
duction. Technical Report, Technische Universit ¨at Darmstadt, 
TR-TUD-DEEDS-07-01-2011, 2011. (http://www.deeds.informatik.tu-
darmstadt.de/peter/papers/LPOR.pdf)
[7] R. Bhattacharya, S. German, G. Gopalakrishnan. Exploiting Symmetry 
and Transactions for Partial Order Reduction of Rule Based Speciﬁca- 
tions. SPIN , pp. 252-270, 2006. 
[8] E. Clarke, O. Grumberg, D. Peled. Model Checking . MIT Press, 2000. 
[9] E. Emerson, S. Jha, D. Peled. Combining Partial Order and Symmetry 
Reductions. TACAS , pp. 19–34, 1997. 
[10] C. Flanagan, P. Godefroid. Dynamic Partial-Order Reduction for Model 
Checking Software. POPL , pp. 110–121, 2005. 
[11] P. Godefroid. Partial-Order Methods for the Veriﬁcation of Concurrent 
Systems: An Approach to the State-Explosion Problem . Springer, 1996. 
[12] G. Gueta, C. Flanagan, E. Yahav, M. Sagiv. Cartesian Partial-Order 
Reduction. SPIN , pp. 95–112, 2007. 
[13] G. J. Holzmann. The SPIN Model Checker . Addison-Wesley, 2004. 
[14] G. J. Holzmann, D. Peled. An Improvement in Formal Veriﬁcation. 
FORTE , pp. 197–211, 1994. 
[15] V . Kahlon, C. Wang, A. Gupta. Monotonic Partial Order Reduction: An 
Optimal Symbolic Partial Order Reduction Technique. CAV , pp. 398–413, 
2009.
[16] L. M. Kristensen, K. Schmidt, A. Valmari. Question-guided Stubborn 
Sets for State Properties. FMSD , 29(3):215-251, 2006. 
[17] L. Lamport. The Part-time Parliament. ACM Trans. Comp. Sys. ,
16(2):133–169, 1998.
[18] S. Lauterburg, M. Dotta, D. Marinov, G. Agha. A Framework for State- 
Space Exploration of Java-Based Actor Programs. ASE, pp. 468–479, 
2009.
[19] R. Nalumasu, G. Gopalakrishnan. A New Partial Order Reduction 
Algorithm for Concurrent System Veriﬁcation. CHDL , pp. 305-314, 1997. 
[20] M. K. Reiter. Secure Agreement Protocols: Reliable and Atomic Group 
Multicast in Rampart. CCS, pp. 68–80, 1994. 
[21] K. Sen, G. Agha. Automated Systematic Testing of Open Distributed 
Programs. FASE , pp. 339–356, 2006. 
[22] U. Stern, D.L. Dill. Parallelizing the Mur ϕVeriﬁer. FMSD , 18(2): 
117–129, 2001.
[23] A. Valmari. The State Explosion Problem. Petri Nets I: Basic Models ,
pp. 429-528, 1998.
[24] J. Yang, T. Chen, M. Wu, Z. Xu, X. Liu, H. Lin, M. Yang, F. Long, 
L. Zhang, L. Zhou. MODIST: Transparent MC of Unmodiﬁed Distributed 
Systems. NSDI , pp. 213–228, 2009. 
[25] Y . Yang, X. Chen, G. Gopalakrishnan, R.M. Kirby. Efﬁcient Stateful 
Dynamic Partial Order Reduction. SPIN , pp. 288–305, 2008. 
[26] http://hadoop.apache.org/zookeeper/
[27] http://babelﬁsh.arc.nasa.gov/trac/jpf
[28] http://www.deeds.informatik.tu-darmstadt.de/peter/mp-basset/
[29] http://www.isi.deterlab.net/