Automatic Testing of Sequential
and Concurrent Substitutability
Michael Pradel
Department of Computer Science
ETH Zurich, SwitzerlandThomas R. Gross
Department of Computer Science
ETH Zurich, Switzerland
Abstract ‚ÄîLanguages with inheritance and polymorphism as-
sume that a subclass instance can substitute a superclass instance
without causing behavioral differences for clients of the super-
class. However, programmers may accidentally create subclasses
that are semantically incompatible with their superclasses. Such
subclasses lead to bugs, because a programmer may assign a
subclass instance to a superclass reference. This paper presents
an automatic testing technique to reveal subclasses that cannot
safely substitute their superclasses. The key idea is to generate
generic tests that analyze the behavior of both the subclass and
its superclass. If using the subclass leads to behavior that cannot
occur with the superclass, the analysis reports a warning. We Ô¨Ånd
a high percentage of widely used Java classes, including classes
from JBoss, Eclipse, and Apache Commons Collections, to be
unsafe substitutes for their superclasses: 30% of these classes
lead to crashes, and even more have other behavioral differences.
I. I NTRODUCTION
A. Substitutability
Classes extend and reÔ¨Åne other classes through subclassing.
Polymorphism allows a reference of a superclass type to point
to a subclass instance. To ensure that using a superclass
reference gives the expected behavior, each subclass should
behave like the superclass when being used through the
superclass type. This requirement is called substitutability and
can be enforced through behavioral subtyping [1], [2]. We
call a subclass that fulÔ¨Ålls this property a safe substitute for
its superclass and an unsafe substitute otherwise.
Substitutability is crucial for object-oriented programming.
It allows a programmer to reason about the behavior of an
object based on the object‚Äôs statically declared type, that is,
without knowing its runtime type. What if a programmer
that uses objects of declared type Super could not assume
subclasses to be safe substitutes? A prudent programmer
would have to study all subclasses of Super , Ô¨Ågure out
which of them are compatible with the intended usage, and
add runtime type checks before each use of an object with
an unknown runtime type. Since this approach would add
boilerplate code and runtime overhead, it obviously reduces
the beneÔ¨Åts of subclassing and polymorphism. To avoid these
problems, substitutability is widely accepted as one of the
bedrock principles of object-oriented programming.
Despite the importance of substitutability, programmers get
little help from existing languages and tools to ensure that
subclasses are safe substitutes. Popular languages, such asTreeMap m = newTreeMap () OR newFastTreeMap ();
m.put(23, m);
m.pollLastEntry ();
m.hashCode ();
Result:OK if misTreeMap
StackOverflowError ifmisFastTreeMap
Figure 1. A sequentially used class that is an unsafe substitute.
Java, enforce substitutability only on the type level but not on
a deeper, semantic level. While the type system ensures that
an overriding method is type-compatible with the overridden
method, it does not guarantee that the overriding method
semantically substitutes the overridden method. SpeciÔ¨Åcation
and veriÔ¨Åcation techniques to ensure substitutability through
behavioral subtyping have been proposed [2]‚Äì[6], but none
of them has found its way into mainstream programming.
Furthermore, we are not aware of any practical tool that helps
programmers Ô¨Ånd substitutability problems.
As a result of this lack of support, programmers are sus-
ceptible to creating subclasses that are unsafe substitutes. For
example, consider FastTreeMap from the Apache Commons
Collections library. FastTreeMap is a subclass of TreeMap
and therefore should behave like a TreeMap when being
referred to as a TreeMap . Figure 1 shows a usage of these
classes that reveals that FastTreeMap is an unsafe substitute
forTreeMap .1Executing the code succeeds if mis aTreeMap
but raises an exception if mis aFastTreeMap . This difference
may crash a client program that expects a TreeMap reference
to behave like a TreeMap . We reported this problem to the
developers, who acknowledged our report.2
B. Substitutability in Concurrent Programs
Substitutability, which traditionally has been considered
in sequential programs, is equally important in concurrent
programs. Similar to sequential programs, a subclass instance
referenced through a superclass type and shared by multiple
concurrent threads should behave like a superclass instance.
In particular, subclasses of a thread-safe class must be thread-
safe as well. That is, if multiple threads are allowed to call
1We use the syntax new A() OR new B() to say that either of the
constructors can be executed.
2See issue 394 in the Commons Collections bug tracker. The class will be
removed in the next version of the library.Properties p = newProperties () OR newPropertyMap ();
p.setProperty("a", "b");
p.remove("a"); p.clear ();Thread 1 Thread 2
Result:OK if pisProperties
NullPointerException ifpisPropertyMap
Figure 2. A concurrently used class that is an unsafe substitute.
methods of a shared object without synchronization, then this
property must be preserved by subclasses.
Unfortunately, existing languages and tools do not support
programmers in ensuring substitutability for thread-safe
classes. Figure 2 shows a substitutability problem in
PropertyMap from JBoss. The class extends Properties ,
a thread-safe class from the Java standard library, and
therefore, should also support concurrent usage. However,
PropertyMap causes an exception in a concurrent usage,
whereas the same usage succeeds with the superclass. We
reported this problem to the developers, who Ô¨Åxed the bug.3
C. Our Approach
How can developers Ô¨Ånd unsafe substitutes, such as Fig-
ures 1 and 2? This paper presents an automatic testing tech-
nique that detects subclasses that cannot safely substitute their
superclasses. Given two classes Super andSub, the technique
generates test cases that can test both Super instances and
Sub instances. Then, the analysis uses the behavior of Super
as an oracle for Sub and reports a warning if Sub behaves
differently from its superclass. We present two variants of
this oracle: the output oracle , which reports any difference
in the visible output, and the crash oracle , which reports a
warning only if Subleads to a crash that does not occur with
Super . The analysis checks substitutability for sequentially and
concurrently used classes and, among many others, Ô¨Ånds the
bugs in Figures 1 and 2.
Our analysis is easy to apply, precise, and incomplete. It is
easy to apply, because the only input are the classes to test,
possibly accompanied by auxiliary classes to create method
arguments. The approach is precise, because all reported warn-
ings point to classes that are unsafe substitutes.4Furthermore,
each warning comes with a concrete test case showing how
the subclass behavior differs from the superclass behavior. On
the downside, the analysis is incomplete, that is, it cannot
guarantee that a subclass is a safe substitute. Incompleteness
is the price we pay for an easy to apply and precise analysis.
We apply the analysis to 145 pairs of widely used and well-
tested Java classes and have two main Ô¨Åndings.
1) We Ô¨Ånd that surprisingly many subclasses are unsafe
substitutes: 30% of the analyzed subclasses lead to
3See issue 126 in the JBoss Common bug repository.
4Precision is guaranteed only to the degree that constructor mappings
(Section III-C) are precise. In practice, the crash oracle (Section III-D2) has
no false positives during our evaluation.crashes that do not occur with their superclass and even
more subclasses (42%) produce output that differs from
the output of their superclass.
2) We Ô¨Ånd that developers care about substitutability prob-
lems: We reported ten bugs, out of which seven got Ô¨Åxed
after a short time. Moreover, at least three other bugs
detected by our analysis have been Ô¨Åxed independently
of us.
D. Contributions
In summary, this paper contributes the following:
An automatic and precise analysis to Ô¨Ånd subclasses that
cannot safely substitute their superclasses.
We consider substitutability, which has traditionally been
studied in sequential programs, in concurrent programs.
Empirical evidence that the problem of ensuring substi-
tutability is not yet solved and that our analysis is a step
towards solving it.
II. B ACKGROUND : THEPERILS OF POLYMORPHISM
Polymorphism and subclassing are part of most popular,
class-based, object-oriented programming languages. This sec-
tion brieÔ¨Çy discusses problems emerging when these two
language features interact and describes how substitutability
helps to avoid these problems.
Polymorphism allows a reference of type Super to point
to an object of any subtype Sub ofSuper . Polymorphic
references that point to subtype instances occur in various
situations, for example, when a method with declared return
typeSuper returns a Sub instance, when a Sub argument is
passed to a method expecting a Super parameter, or when a
Sub instance is stored in a Ô¨Åeld of type Super .
In many languages, a subtype is created by creating a sub-
class and restrictions apply on how the subclass can adapt the
superclass. For example, Java imposes type-level restrictions
on overriding methods to ensure that an overriding method
accepts at least all parameters accepted by the overridden
method. Despite these restrictions, a subclass can signiÔ¨Åcantly
change the superclass behavior. For example, a subclass may
override a method that performs a complex computation with
an empty method, or replace a side effect-free method with a
method that has side effects.
The ubiquity of polymorphic references combined with the
power of subclassing leads to a problem: A subclass Sub that
behaves differently from its superclass Super can surprise a
client of Super that unconsciously works with an instance of
Sub. For example, consider a client that calls a method on a
variable with static type Super , where the variable is the return
value of a call to a third-party library. The client cannot foresee
the runtime type of the returned object and decides to call the
method based on the variable‚Äôs static type. If the behavior of
the call depends on the object‚Äôs runtime type, the programmer
is caught off guard and may have to deal with a bug that she
is not responsible for and that she cannot foresee.
To avoid surprises because of subtype instances hidden by
polymorphic references, subclasses should not diverge fromthe superclass behavior. This idea, coined as substitutabil-
ity [1], has become textbook knowledge [7], [8] and is widely
accepted by object-oriented programmers.
III. F INDING UNSAFE SUBSTITUTES
Although substitutability is crucial for object-oriented pro-
gramming, programmers have little support for testing whether
a subclass is a safe substitute for a superclass. This section
presents an automatic analysis to Ô¨Ånd subclasses that cannot
safely substitute their superclasses.
A. Terminology
In the following, we deÔ¨Åne when a subclass is a safe
substitute for a superclass and describe two ways in which
a subclass can be an unsafe substitute. When saying subclass,
we mean both direct and indirect subclass relationships. The
deÔ¨Ånitions build upon the notion of a usage , which describes
how a class is used in a client program. We denote usages that
apply to both a superclass and a subclass as generic usages .
DeÔ¨Ånition 1 (Generic usage) .A generic usage w.r.t. classes
Super andSub is a partial order of constructor calls, method
calls, and Ô¨Åeld accesses that use an object of runtime type
Super orSub through the interface offered by Super .
For a generic usage u, we write uSuper if the object has
runtime type Super anduSubif the object has runtime type
Sub.
A generic usage can describe both sequential and concurrent
usages of objects. For a sequential usage, the partial order of
calls and Ô¨Åeld accesses is a total order. For a concurrent usage,
the partial order reÔ¨Çects multiple concurrent threads.
DeÔ¨Ånition 2 (Safe substitute) .A subclass Sub is a safe
substitute for a superclass Super if and only if for each
generic usage u, the visible behavior of uSuper is equivalent
to the visible behavior of uSub.
By visible behavior we mean application-level behavior,
such as return values of method calls, exceptions, text written
to the console, and network packets sent to other machines. We
ignore machine-level behavior, such as memory accesses and
CPU usage. In the following, we deÔ¨Åne two kinds of unsafe
substitutes, which differ in the way the visible behavior of the
subclass diverges from the visible behavior of the superclass.
DeÔ¨Ånition 3 (Output-diverging (unsafe) substitute) .A subclass
Sub is an output-diverging substitute for a superclass Super
if and only if there exists a generic usage uso that there exists
an output of uSubthat is not an output of uSuper .
By output we mean the sequence of return values of method
calls on the used object. For sequential and deterministic
usages, there exists exactly one output per usage. If the
subclass output is different from the superclass output, then
the subclass is an output-diverging substitute. For concurrent
usages, there can be multiple outputs for a single usage, for
example, due to scheduling non-determinism. If the set of
subclass outputs contains an output that is not in the set ofTest generator
Superclass oracleSubclass, superclass, auxiliary classes
Warning about unsafe substitute, or nothingGeneric, sequential and concurrent tests
Figure 3. Overview of the approach.
superclass outputs, then the subclass is an output-diverging
substitute.
DeÔ¨Ånition 4 (Crashing (unsafe) substitute) .A subclass Sub
is a crashing substitute for a superclass Super if and only
if there exists a generic usage uso that uSub can lead to
an uncaught exception or to a deadlock that cannot occur
withuSuper .
Of the unsafe substitutes considered here, crashing substi-
tutes are the more severe kind of unsafe substitutes, because
they lead to certainly undesired behavior in clients using a Sub
instance through type Super . Output-diverging substitutes
may or may not be a problem in practice (Section V).
B. Overview of the Analysis
How can a programmer check whether a subclass is an
unsafe substitute? In the following, we present a fully auto-
matic analysis to reveal subclasses that are unsafe substitutes.
The input to our analysis are a subclass Sub and a superclass
Super , possibly accompanied by classes that the other classes
depend on. The output of the analysis are warnings that show
with concrete test cases how using a subclass instance through
the superclass type leads to visible behavior that is impossible
with a superclass instance.
Our approach to reveal unsafe substitutes combines two
techniques (Figure 3). First, a test generator creates generic
tests that exercise sequential and concurrent behavior (Sec-
tion III-C). The generated tests are generic in the sense that
they can test the behavior of Sub as well as the behavior
ofSuper . Generic tests simulate how clients of Sub and
Super use these classes, that is, they represent generic usages.
The test generator considers only public methods, Ô¨Åelds, and
constructors, because these are accessible to clients.
Second, an analysis called the superclass oracle checks
for each test whether the test exposes behavior that occurs
when using Sub but that cannot occur when using Super
(Section III-D). If the superclass oracle detects such behavior,
it reports a warning to the developer. By construction, each
warning comes with a concrete test case showing how the
subclass behavior diverges from the superclass behavior. We
present two variants of the superclass oracle that search
for output-diverging substitutes (Section III-D1) and crashing
substitutes (Section III-D2), respectively.C. Test Generation
In the following, we present our approach for generating
generic tests for sequentially and concurrently used classes.
The test generator builds upon a previously presented tech-
nique for generating concurrent tests [9]. We adapt the existing
technique to generate generic tests and to generate both
sequential and concurrent tests.
1) Generic Tests: Tests are assembled from calls . A call
consists of a method name, a list of input variables, and an
optional output variable. For an instance call, the Ô¨Årst input
variable represents the receiver of the call; the other input
variables are the arguments given to the call. If the output
variable is deÔ¨Åned, it represents the return value of the call. We
model constructor calls as calls without a receiver variable and
where the output variable refers to the newly created object.
Similarly, we model Ô¨Åeld accesses as calls without arguments
and where the output variable represents the value of the Ô¨Åeld.
The calls in a test are centered around a particular object,
called the object under test (OUT). The OUT is created by
one of the calls in a test and subsequently used as the receiver
of other calls. Tests can create other objects, for example, to
pass them as arguments to methods of the OUT.
To compare Super andSub, we require tests that can check
the behavior of OUTs of both runtime types Sub andSuper .
We call such a test a generic test . In a generic test, the
static type of the variable vOUT , which represents the OUT,
isSuper . The dynamic type of vOUT can be either Super
orSub. Using the static type Super for the OUT ensures
that each call involving the OUT is type-compatible with both
Super andSub. A generic test has two parts. One part creates
the OUT and therefore decides on the OUT‚Äôs runtime type.
This part has two variants, one that instantiates Super and
one that instantiates Sub. The other part uses the OUT and is
independent of the OUT‚Äôs runtime type.
2) Constructor Mappings: Because we compare the be-
havior of Super andSub instances, it is crucial that the
constructors used for creating these instances are semantically
equivalent. Finding pairs of Super andSub constructors that
create semantically equivalent objects is non-trivial in Java and
cannot be fully automated for two reasons. First, constructors
are not inherited [10]. For example, Sub may have a single
constructor expecting an int parameter, while Super offers
only the parameterless default constructor. Second, calling a
Sub constructor that leads to the same inherited state as calling
aSuper constructor does not guarantee that the resulting
objects are semantically equivalent. For example, a superclass
may store a length in meters in a Ô¨Åeld, whereas the subclass
uses the same Ô¨Åeld to store the length in yards.
To address the problem of Ô¨Ånding equivalent constructors,
we use constructor mappings that specify how calling a
constructor of Sub can be transformed into a semantically
equivalent call to a constructor of Super . We provide a
heuristic that automatically generates constructor mappings
under the assumption that Super andSub constructors that ex-
pect the same types of arguments are semantically equivalent.
Alternatively, a user of the approach can specify constructormappings explicitly. In the evaluation, we use automatically
generated constructor mappings.
For example, consider the following constructor mappings:
Sub(Foo; Bar )!Super (1;2)
Sub(int; boolean )!Super (2)
The Ô¨Årst mapping speciÔ¨Åes that calling new Sub(someFoo,
someBar) is semantically equivalent to calling new
Super(someFoo, someBar) . In practice, most constructor
mappings are similar to the Ô¨Årst example, which is why
our heuristic generates this mapping automatically. The
second mapping speciÔ¨Åes that we can replace a call to
new Sub(someInt, someBoolean) with a call to new
Super(someBoolean) , that is, we pass the second argument
ofSub‚Äôs constructor as the only argument to Super ‚Äôs
constructor and omit the int parameter as it is not required
bySuper . If necessary, a user can specify the second
mapping in addition to or instead of generated constructor
mappings.
3) Generating Sequential and Concurrent Tests: The test
generator can be conÔ¨Ågured to produce either sequential tests,
concurrent tests, or both kinds of tests, depending on the kind
of usage the tested class is intended for. A sequential test is a
sequence of calls executed in a single thread. A concurrent test
is a partially ordered set of calls that are executed in multiple
concurrent threads. We focus on concurrent tests that consist of
asequential preÔ¨Åx followed by two parallel sufÔ¨Åxes , where the
preÔ¨Åx is a call sequence executed in a single thread, and where
each sufÔ¨Åx contains a single method call executed in a separate
thread that runs concurrently with the other sufÔ¨Åx thread. The
rationale for this choice is twofold. First, a recent study on
real-world concurrency bugs shows that most bugs (96%) can
be reproduced with two threads [11]. Second, the execution of
concurrent sufÔ¨Åxes with a single method call can be efÔ¨Åciently
explored and still reveals many real-world bugs [12].
To create a generic test, the Ô¨Årst step is to generate calls that
create the OUT. The generator selects a constructor mapping
and generates two call sequences with calls to instantiate
Super andSub, respectively. These two sequences give two
variants of the test, which allows us to test both Super and
Sub. The second step is to generate the part of the test that
uses the OUT. For a sequential test, the generator repeatedly
appends calls to the OUT. For a concurrent test, the generator
appends calls to the OUT to obtain the preÔ¨Åx of the test. Then,
the generator creates sufÔ¨Åxes by spawning two threads and by
adding a call to each of them.
Calling methods often requires method arguments. The test
generator chooses among three ways to obtain an argument
of a particular type: (1) Use an existing variable of the
required type, for example, the return value of an existing
call in the test; (2) Call a method that returns a value of the
required type; (3) For primitive types, randomly create a value.
When searching for arguments, the test generator may need
further arguments. In this case, it recursively applies the above
procedure. If a maximum recursion depth is reached, the testInput: Generic test tfor classes Super andSub
Output: Warning about an unsafe substitute, or nothing
1:OSub execute (tSub)
2:OSuper execute (tSuper )
3:OSubOnly O Sub O Super
4:ifOSubOnly6=;then
5:reportWarning (t;OSubOnly )
Figure 4. Output oracle. Checks whether Sub is an output-diverging substitute
forSuper .
generator gives up and tries to call a method that requires other
types of arguments.
Calls made to obtain arguments for calls in the sufÔ¨Åx of a
concurrent test are added to the preÔ¨Åx instead of the sufÔ¨Åx.
For example, to call a method m(A) in the sufÔ¨Åx, the test
generator adds calls to obtain an instance of Ato the preÔ¨Åx.
The rationale for pushing calls back to the preÔ¨Åx is to keep
the sufÔ¨Åx as short as possible, which in turn, reduces the time
for exploring the interleavings of a concurrent test.
Most decisions of the test generator on how to explore
the space of possible tests are taken randomly and based on
feedback from executions of partial tests [13]. For example,
when choosing which constructor or method to call, or how to
obtain an argument, the test generator randomly selects from
all available options. Whenever a call is added to a partial
test, the test generator executes the extended test and checks
whether adding the call leads to an exception or to a deadlock.
If adding a call leads to a failure, the call is discarded and
another call is added instead. For executing tests during test
generation, we use the variant of the test that exercises a Sub
instance. The reason is that partial tests that fail with Sub
can be passed to the crash oracle (Section III-D2), which will
check whether the test also fails with Super .
4) Examples: Figures 1 and 2 are examples of generic tests
for sequentially and concurrently used classes, respectively.
Thenew A() OR new B() syntax expresses the two variants
of the tests. Depending on which of the two constructors
is used, the tests exercise either a superclass instance or a
subclass instance.
D. The Superclass Oracle
Given a generic test for two classes Super andSub, the
superclass oracle checks whether the test exposes that Sub
is an unsafe substitute for Super . The oracle uses Super
as an executable speciÔ¨Åcation of the correct behavior of Sub
and compares the visible behavior of both classes. The visible
behavior of a subclass can diverge in different ways from the
visible behavior of a superclass. In the following, we present
two variants of the superclass oracle, the output oracle and
the crash oracle, which focus on revealing output-diverging
substitutes and crashing substitutes, respectively. The input to
both oracles is a generic test t. Similar to generic usages, we
denote a test working with an OUT of runtime type Super as
tSuper and likewise for Sub.1) The Output Oracle: The output oracle checks whether a
generic test exposes that Sub is an output-diverging substitute
forSuper . The oracle executes both tSuper andtSuband stores
the sequences of return values in the output sets OSuper and
OSub(Figure 4). Assuming deterministic execution, sequential
tests have exactly one output sequence. In contrast, concurrent
tests can have multiple output sequences due to scheduling
non-determinism. If there exists a sequence of return values
that occurs only with Sub, the oracle reports a warning,
because Sub is an output-diverging substitute for Super . The
analysis explores all possible interleavings of concurrent tests
to avoid missing an output sequence (Section III-D4).
To compare output sequences of test executions, the oracle
transforms the return values into an execution-independent
format. For primitive values and Strings, the output sequence
contains the actual return value. For reference values, the
oracle stores whether the value is null or not. For example,
the output sequence of executing the sequential test in Figure 1
with an instance of TreeMap is the following (values are
separated with ‚Äú‚Äî‚Äù):
(1) null ‚Äî non-null ref. value ‚Äî int:0
The Ô¨Årst value, null, is the return value of m.put(23,m) ,
the second value, a non-null reference value, is the return value
ofm.pollLastEntry() , and the last value, the integer zero,
is returned by m.hashCode() . Executing the concurrent test
in Figure 2 with an instance of Properties gives two output
sequences:
(2) null ‚Äî String:‚Äúb‚Äù
(3) null ‚Äî null
Alternatively to this encoding of return values, the output
oracle could compare reference values with their equals()
method, compare the String representations obtained via
toString() , or compare the hash codes. Unfortunately, with
these approaches objects often appear to be different even
though they are semantically the same. The reason is that
the default implementations of equals() ,toString() , and
hashCode() refer to object identity. As a result, many of the
warnings reported by the output oracle would be spurious,
because the difference in output is not a bug.
To avoid false warnings caused by calls to equals() ,
toString() , and hashCode() in the generated tests, the
oracle ignores return values of those methods. With this
reÔ¨Ånement, the output sequence for Figure 1 with an instance
ofTreeMap is not (1) but the following:
(4) null ‚Äî non-null ref. value ‚Äî ignored
The output oracle compares the visible behavior of Super
andSub in a strict way. In practice, subclasses often change
the return value of methods in ways that are considered to be
in line with substitutability (we give examples in Section V-D).
Our experiments show that many of the warnings produced by
the output oracle are benign differences (Section V-B). In the
following, we address this imprecision of the output oracle
and present a precise oracle that reports only true bugs.
2) The Crash Oracle: The crash oracle checks whether
a test exposes that a subclass is a crashing substitute. Each
warning reported by the crash oracle shows how a usage ofInput: Generic test tfor classes Super andSub
Output: Warning about an unsafe substitute, or nothing
1:FSub execute0(tSub)
2:ifFSub6=;then
3:FSuper execute0(tSuper )
4: ifFSuper =;then
5: reportWarning (t;FSub)
Figure 5. Crash oracle. Checks whether Sub is a crashing substitute for
Super .
the subclass can lead to an uncaught exception or a deadlock
in a situation where using the superclass works Ô¨Åne. Since
program crashes are certainly undesired behavior, each of the
reported warnings points to a severe substitutability problem.
Given a generic test t, the crash oracle Ô¨Årst executes it
withSub‚Äôs constructor (Figure 5). The execute0()function
returns a set of failures observed while executing the test.
A failure is either an exception or a deadlock. If executing
the test with Sub‚Äôs constructor leads to one or more failures,
this does not necessarily mean that Sub is implemented
incorrectly. Since tests are generated, they may use the class
incorrectly, for example, by passing arguments that cause an
IllegalArgumentException . To check whether the ob-
served failures are part of the expected behavior of Sub, the
oracle executes the test with Super ‚Äôs constructor. If Super
also causes a failure, the oracle does not report a warning,
because the behavior of the subclass does not diverge from
the behavior of the superclass. In contrast, if the set of failures
from Super is empty, the oracle reports a warning, because
Sub leads to a crash not possible with Super .
The crash oracle can be seen as a Ô¨Ålter of all generated
tests that trigger a failure. With feedback-directed, random
test generation, many generated tests crash but only few of
them correspond to bugs in the tested code. The crash oracle
avoids overwhelming the user with crashing tests by focusing
on crashes caused by a substitutability problem.
3) Distinguishing Concurrent from Sequential Problems:
We reÔ¨Åne the algorithms in Figures 4 and 5 to identify prob-
lems that occur only in concurrent tests, and not sequentially.
This reÔ¨Ånement matters when checking for concurrent substi-
tutability problems without reporting sequential problems.
Before reporting a warning for a concurrent test, the output
oracle checks whether the output sequences OSubOnly are
also possible when linearizing the test into a single thread.
A linearization of a concurrent test is a sequence of calls that
contains all calls from the test while preserving the partial
order of calls from the test. Since we generate concurrent
tests with two sufÔ¨Åxes that each contain a single call, there
are exactly two linearizations for each concurrent test: One
where the call from thread 1 comes Ô¨Årst and one where the
call from thread 2 comes Ô¨Årst. If all output sequences in
OSubOnly also occur with linearizations of the concurrent test,
then the substitutability problem is sequential and not speciÔ¨Åc
to concurrently using Sub andSuper .The crash oracle executes the linearizations of a concurrent
test before executing tSub. If the execution of at least one lin-
earization fails, then the oracle does not explore the concurrent
execution of the test and instead treats the failing linearization
like a sequential test obtained from the test generator.
4) Exploring Executions: Theexecute ()function in Fig-
ure 4 and the execute0()function in Figure 5 explore all
possible executions of a test. execute ()returns the set of out-
put sequences produced by these executions, and execute0()
returns the set of failures observed during the executions.
For sequential tests, the execution functions simply run the
test in a single thread of execution. We assume sequential
executions to be deterministic. Sequential tests that do not
behave deterministically, for example, because their behavior
depends on the current system time, can be made deterministic
by controlling the execution environment [14].
For concurrent tests, the analysis faces the challenge that
different executions may expose different behavior due to non-
deterministic scheduling. If the oracle does not consider all
behaviors from executing a test with Super ‚Äôs constructor, the
oracle might report false warnings. For example, the oracle
may observe that Sub raises an exception but may miss that
the exception is also possible with Super because the oracle
does not observe the ‚Äúright‚Äù interleaving of Super ‚Äôs test.
To avoid false warnings due to missed interleavings, the exe-
cution functions explore all possible executions of a concurrent
test. The analysis uses the stateful software model checker Java
PathFinder (JPF) [15]. JPF systematically explores all possible
interleavings of the concurrent sufÔ¨Åxes of the test, that is, all
possible behaviors (output sequences or failures) of a con-
current test despite the non-determinism introduced through
scheduling. Checking all interleavings of concurrent calls faces
the problem of combinatorial explosion. By focusing on two
concurrent sufÔ¨Åxes that each have a single call, we ensure that
the oracle terminates in reasonable time (Section V-G).
5) Examples: Figures 1 and 2 are two examples of prob-
lems detected by the crash oracle. In both examples, executing
the test with the superclass constructor succeeds, while exe-
cuting it with the subclass constructor leads to an exception. A
client that calls methods in the same way as in the generated
tests will be surprised about a program crash, because the
superclass does not show this behavior. Section V-C reports
examples of warnings from the output oracle.
IV. I MPLEMENTATION
We implemented the approach presented in Section III into
a fully automatic testing tool for Java classes. The implemen-
tation takes source code or byte code as input and reports
unsafe subclasses as output. We implemented a helper tool to
Ô¨Ånd all superclass-subclass pairs in particular packages and to
generate constructor mappings as described in Section III-C.
Together with this helper tool, the implementation offers a
push button technique to analyze entire class libraries.
To implement the superclass oracle we build upon JPF
(version r615) for exploring concurrent executions. JPF is a
mature and well-tested research tool but has some limitations,for example, when analyzing native code. Another problem is
that testing even only two concurrent threads that each have
a single method call can take a signiÔ¨Åcant amount of time.
We deal with these problems by Ô¨Åltering the errors raised by
JPF and by canceling JPF after a conÔ¨Ågurable timeout. If JPF
crashes or if it cannot analyze a concurrent test within the
timeout, we consider the test to be inconclusive. The superclass
oracle does not report any warnings for inconclusive tests.
That is, we risk missing some unsafe substitutes but avoid
false warnings caused by JPF limitations. For the experiments
reported in Section V, we set the timeout to ten seconds per
test, which is sufÔ¨Åcient for 96% of all concurrent tests. The
timeout does not affect the detection of deadlocks because
deadlocks are reported by JPF immediately when they occur.
The test generator creates tests with a conÔ¨Ågurable number
of calls. For sequential tests, we set the maximum number of
OUT calls after instantiating the OUT to Ô¨Åve. For concurrent
tests, the preÔ¨Åx contains at most Ô¨Åve calls to the OUT.
V. E VALUATION
We evaluate our approach with well-tested and widely used
Java classes. Our main results are:
Many classes are crashing substitutes (43/145=30%). All
these unsafeties correspond to bugs that should be Ô¨Åxed,
because they may cause exceptions and deadlocks in
clients.
Even more classes are output-diverging substitutes
(61/145=42%). We classify most of them (57/61) as
false positives.
Developers care about crashing substitutes. At least ten
bugs found by the analysis have been Ô¨Åxed by now.
For reproducibility, all experimental data are available for
download at http://mp.binaervarianz.de/icse2013.
A. Experimental Setup
We apply the analysis to sequentially and concurrently used
classes. As sequentially used classes, we consider classes from
three popular Java libraries (Table I). We select libraries,
instead of closed programs because every usage simulated by
the test generator may happen in some client program. Table I
shows the number of analyzed superclass-subclass pairs. We
consider all pairs of public and concrete classes that are in a di-
rect or indirect subclass relationship, excluding the superclass
Object and classes without public constructors‚Äîin total, 116
class pairs. As auxiliary classes for generating tests, we pass
common classes from the Java standard library and all classes
from the respective library. The test generator automatically
selects those classes that provide required arguments.
As concurrently used classes, we consider subclasses of 30
classes from the Java standard library that are known to be
thread-safe. We consider all 323,107 classes included in the
Qualitas Corpus [16] and select a class if it has a thread-safe
superclass, if it is public and concrete, and if it has a public
constructor. This selection yields 29 subclasses to analyze.
We analyze each class pair until a maximum number of tests
has been generated: 500 tests for sequentially used classes andArrayList l = newArrayList () OR newChapter ();
Set empty = newHashSet ();
boolean b = l.addAll(empty );
Result:
b==false iflisArrayList
b==true iflisChapter
Figure 6. An output-diverging substitute that we classify as a bug.
3,000 tests for concurrently used classes. We set a larger limit
for the latter, because a single concurrent test checks only two
methods against each other. To reach the maximum number of
tests, we run the analysis with different random seeds, where
the number of tests generated per seed increases with the
number of seeds used (similar to [9]). All experiments are done
on an eight-core machine with 3GHz Intel Xeon processors
and 8GB memory, running 32-bit Ubuntu Linux and the Java
Hotspot VM version 1.6.0 27, giving 2GB memory to the VM.
We manually inspect all warnings reported by the analysis
and classify them as bugs or false positives. A warning is
a bug if the subclass behavior should be changed to avoid
unexpected behavior in client programs, and it is a false
positive otherwise. We distinguish between two kinds of false
positives: (1) Differences in behavior that we deem to be
acceptable, for example, methods where clients expect that
the outcome depends on the runtime type of the receiver. (2)
Generic tests where the superclass and subclass constructors
are not semantically equivalent, that is, the heuristic construc-
tor mapping (Section III-C) is incorrect.
B. Overview of Unsafe Substitutes Found
Table I shows for both the crash oracle and the output
oracle how many warnings the analysis Ô¨Ånds and how we
classify them. For both oracles, a large percentage of the
analyzed subclasses are unsafe substitutes: 30% are crashing
substitutes and 42% are output-diverging substitutes. For the
crash oracle, all reported warnings correspond to bugs, which
is not surprising, because the crash oracle focuses on certainly
undesired behavior. In contrast, for the output oracle, most
reported warnings are false positives. Two of the four bugs
detected by the output oracle are also found by the crash
oracle, because the diverging subclass behavior manifests both
through different output and through a crash.
Which oracle should developers use? We recommend the
crash oracle as a default, because it Ô¨Ånds 96% of all detected
bugs and because it does not report false positives. In contrast,
the output oracle has a high false positive rate and Ô¨Ånds few
additional bugs.
C. Examples of Unsafe Substitutes
Figures 1 and 2 are bugs found by the crash oracle.
Figure 6 shows a bug found exclusively by the output oracle.
Chapter , a subclass of ArrayList , modiÔ¨Åes the meaning
of the return value of addAll() in a subtle way: While the
superclass returns whether the content of the list has changed,
the subclass returns whether the operation was successful.
The difference matters when an empty collection is passed toTable I
SUMMARY OF RESULTS
Subject Description Seq./ Class Crash oracle Output oracle
Conc. pairs Warnings Bugs False pos. Warnings Bugs False pos.
Accept. diff Constr. Accep. diff Constr.
Commons Collections 3.2.1 Container classes Seq. 12 5 5 0 0 3 2 0 1
dom4j 2.0.0-alpha-2 XML processing Seq. 46 12 12 0 0 26 0 24 2
iText 5.2.0 PDF editing Seq. 58 21 21 0 0 30 1 9 20
Qualitas 20101126r Subclasses of thread- Conc. 29 5 5 0 0 2 1 1 0
safe classes
Sum 145 43 43 0 0 61 4 34 23
Namespace ns = newDefaultNamespace("a", "b");
boolean b = ns.supportsParent ();
Result:
b==false ifnsisNamespace
b==true ifnsisDefaultNamespace
Figure 7. An output-diverging substitute that we classify as a false positive.
addAll() , as illustrated in the Ô¨Ågure. We reported this bug
and the developers Ô¨Åxed it.5
Figure 7 is a false positive reported by the output oracle.
The subclass DefaultNamespace adds a functionality, sup-
port for a parent relationship, to its superclass Namespace .
Both classes provide a method supportsParent() to check
in a reÔ¨Çection-like manner whether an object supports this
functionality. This behavioral difference is documented and
should not surprise clients, because the only purpose of the
supportsParent() method is to Ô¨Ånd out whether an object
supports the functionality, which is known to depend on the
runtime type of the object.
D. Root Causes for Unsafe Substitutes
The large percentage of unsafe substitutes raises the ques-
tion why subclasses extend their superclasses in an unsafe
way. For unsafe substitutes that correspond to bugs, the most
common root causes are:
Stronger precondition for method arguments . An overrid-
ing method imposes a stronger precondition for method
arguments than the overridden method. For example,
some overriding methods expect only a subset of all
subtypes of the declared parameter type [17], and passing
another compatible type raises a ClassCastException .
Stronger precondition for method receiver . An overriding
method has a stronger precondition on the state of the
receiver object than the overridden method. For example,
some overriding methods access a Ô¨Åeld that is not used
by the overridden method.
Removed methods . A subclass explicitly ‚Äúinvalidates‚Äù
a method of the superclass by throwing an
UnsupportedOperationException and thereby
breaks the type system‚Äôs safety guarantee that each
method call is understood.
5See issue 3548434 in the iText bug tracker.Propagated unsafety . A class extends a class that itself is
an unsafe substitute, and the unsafety propagates down
the inheritance hierarchy. Given a class Awith an unsafe
substitute A0, a subclass A00ofA0is also an unsafe
substitute for A, unless A00Ô¨Åxes the problem of A0.
For example, several unsafe substitutes in iText are the
result of extending Properties , which is an unsafe sub-
stitute for Hashtable . The problem is that Properties
assumes to map String s to each other but extends
Hashtable<Object,Object> , from which it inherits
methods to put arbitrary objects into the table. Some
methods of Properties , such as propertyNames() ,
cast entries to String , which fails if the table con-
tains entries of other types. Although this problem of
Properties is documented, it not only may surprise
clients of Hashtable that refer to a Properties in-
stance, but it also affects subclasses of Properties .
Missing synchronization . A subclass of a thread-safe class
overrides a method without providing the synchroniza-
tion guarantees that the overridden method provides.
For example, some methods override a synchronized
method and remove the synchronized keyword without
ensuring synchronization in another way.
One subclass, NonSynchronizedVector from Eclipse,
obviously removes synchronization on purpose.
While this may increase performance, it poses a
signiÔ¨Åcant risk at clients of Vector , because such
clients may unconsciously refer to an instance of
NonSynchronizedVector .
For unsafe substitutes that we classify as false positives, the
most common root causes are:
Ad hoc reÔ¨Çection . A method provides hints on the runtime
type of an object and on the functionalities supported by
this type (for example, see Figure 7). These methods are
an ad hoc form of reÔ¨Çection, and clients calling them
should be aware that superclass behavior and subclass
behavior may differ.
String representations . A method returns a String repre-
sentation of the receiver object and the String contains
type-speciÔ¨Åc information. The output oracle Ô¨Ålters calls
totoString() to avoid more false positives of this kind,
but it does not handle application-speciÔ¨Åc methods that
return String representations.Table II
BUGS REPORTED TO DEVELOPERS .
Issue Status
Castor 2729 Fixed within a day (reported by others)
Commons Collections 394 Fixed by removing the class
Commons Collections 423 Fixed by removing the class
Commons Collections 424 Acknowledged, working on it
dom4j 3547635 Reported
dom4j 3547784 Reported
iText 3547811 Fixed within a day
iText 3547812 Fixed within a day
iText 3548434 Fixed within a day
JBoss Common 126 Fixed within a week
OpenJPA 2243 Fixed within a day
E. Failures Observed by the Crash Oracle
The crash oracle depends on signs of certainly undesired
behavior, such as exceptions and deadlocks. This dependence
may raise the question to what extent our results depend
on a defensive programming style, where illegal state and
illegal arguments are made explicit by throwing exceptions.
We categorize the failures that expose crashing substitutes
as either explicit or implicit. A failure is explicit if it is an
exception raised in the analyzed code base. In contrast, a
failure is implicit if it is an exception raised by the JVM or
by the Java standard library, or if it is a deadlock. 84% of the
failures that expose crashing substitutes in Table I are implicit,
that is, independent of a defensive programming style.
F . Feedback from Developers
Do developers really care about substitutability problems?
To answer this question, we report a subset of the bugs found
by the analysis to the developers (Table II). By the time of
this writing, seven of ten reported bugs have been Ô¨Åxed as a
reaction to our reports. Another bug has been reported and
Ô¨Åxed independently of us. Moreover, at least two other bugs
found by the analysis (not listed in Table II) have been Ô¨Åxed
in iText 5.3.0 independently of us, but we could not Ô¨Ånd a
corresponding issue in the project‚Äôs bug tracker. Many of the
remaining unreported bugs are in deprecated classes that are
likely to be replaced soon. Overall, the feedback from devel-
opers suggests that they care about substitutability problems,
which conÔ¨Årms our expectation that unsafe substitutes that can
surprise clients are not desired and should be Ô¨Åxed.
G. Performance
The runtime performance of our prototype implementation
is acceptable for an automatic analysis. To measure perfor-
mance, we test each class pair until either the maximum
number of tests has been generated or until the subclass has
been found to be a crashing substitute. For sequentially used
classes, the analysis takes on average 41 seconds to Ô¨Ånd
crashing substitutes and 19 seconds to Ô¨Ånd output-diverging
substitutes. For concurrently used classes, it takes on average
21 minutes to Ô¨Ånd crashing substitutes and 108 minutes to
Ô¨Ånd output-diverging substitutes. Concurrent tests take longer
because the analysis explores all interleavings.VI. L IMITATIONS
There are limitations to be addressed in future work. First,
the effectiveness of the approach is bounded by the ability
of the test generator to exercise the analyzed classes. For
some classes, the current test generator may not be able to
trigger an existing substitutability problem, for example, if
the class requires mock objects or external services, such as a
database connection. Second, the approach relies on heuristic
constructor mappings, which account for a large part of the
false positives reported by the output oracle (Table I). One
could improve the heuristic by a static analysis of super()
calls in constructors and of how parameters of subclass con-
structors propagate to the superclass. Third, our results show
the approach to work well for library classes. It remains to
be studied how to apply the analysis to classes from closed
programs, where some of the usages generated for a class may
not match the way the class is used within the program.
VII. R ELATED WORK
Our work relates to behavioral subtyping [2], [18] and
the substitution property [1]. There is a large body of work
on verifying that a class is a behavioral subtype of another
class [2], [3], [5], [6]. In contrast to our work, these approaches
rely on formal speciÔ¨Åcations of the behavior of subclasses
and superclasses, which is not available for most real-world
classes. Offutt et al. propose a model for bugs related to
inheritance and polymorphism [19]. They describe nine kinds
of anomalies, such as a subclass that modiÔ¨Åes state deÔ¨Åned by
the superclass in a way not expected by the superclass. Our
analysis automatically detects these kinds of problems.
America proposes an object-oriented language that distin-
guishes between subclassing and subtyping [4]. Most popular
languages, including Java, blend these two concepts into
one, giving rise to the problems revealed by our approach.
Taivalsaari gives a good overview of the various notions of
inheritance and their respective beneÔ¨Åts [20].
There are various techniques for generating sequential tests,
such as random test generation [13], [21], [22], techniques
based on model checking [23], and techniques based on
symbolic execution [24]‚Äì[26]. Our test generator differs from
these approaches by creating both sequential and concurrent
tests and by creating generic tests. We use a feedback-
directed, random approach [13], but in contrast to [13], our test
generator does not call methods in a random order. Instead,
the test generator selects methods that may provide arguments
for future method calls or that may modify the state of the
object under test. The test generator builds upon an approach
for generating concurrent tests [9] and extends it to produce
generic tests that can compare the behavior of a subclass and
a superclass. This work also differs from [9] by considering a
different kind of bug.
Tillmann and Schulte propose parameterized unit tests,
where all objects involved in a test are parameters to the
test [27]. Their approach generates concrete tests from manu-
ally written, parameterized tests through symbolic execution.Generic tests and parameterized tests share the idea of apply-
ing the same test to different objects. In contrast to their work,
we generate tests fully automatically and use them to check a
subclass against its superclass.
McKeeman proposes to test supposedly equivalent pro-
grams, such as multiple compilers for the same language, by
comparing them with each other [28]. This idea, called differ-
ential testing, has also been used to test system programs [26]
and refactoring engines [29]. Our approach analyzes software
at a Ô¨Åner level of granularity, namely at the class-level instead
of the program-level. As a result, our analysis is more widely
applicable: Most Java classes extend at least one other class
(in addition to Object ) [30], whereas few programs have a
supposedly equivalent program to compare with. A related
idea is to compare an old and a new version of a program and
to warn developers about regressions [31], [32]. In contrast
to these approaches, our analysis reveals problems within a
single version of a program.
We use Java PathFinder [15], which unsoundly considers
concurrent executions to be sequentially consistent. This limi-
tation may cause the superclass oracle to report a false warning
if a subclass crashes with sequentially consistent execution,
while its superclass crashes only with a weak memory model.
We did not encounter this case during our evaluation. An
extension of JPF to address this problem is described in [33].
VIII. C ONCLUSION
We present a practical approach to detect subclasses that are
unsafe substitutes for their superclasses. Unsafe substitutes are
a severe problem for large-scale object-oriented development
because a programmer may not know the runtime type of an
object and because a programmer may not be aware of all sub-
classes of a class. Our approach automatically reports usages
of a superclass reference that lead to surprising behavior, such
as crashes, when the reference points to a subclass instance.
The approach applies to sequentially and concurrently used
classes, addressing the need to ensure correctness in both kinds
of programs. Our experimental results demonstrate that unsafe
substitutes are a prevalent problem in real-world software and
that our analysis effectively addresses it.
ACKNOWLEDGMENTS
Thanks for Zoltan Majo and the anonymous reviewers for
feedback on this paper. This work was partially supported by
the Swiss National Science Foundation under grant number
200021-134453.
REFERENCES
[1] B. Liskov, ‚ÄúData abstraction and hierarchy,‚Äù in OOPSLA , 1987, pp. 17‚Äì
34.
[2] B. Liskov and J. Wing, ‚ÄúA behavioral notion of subtyping,‚Äù ACM T
Progr Lang Sys , vol. 16, no. 6, pp. 1811‚Äì1841, 1994.
[3] G. T. Leavens and W. E. Weihl, ‚ÄúReasoning about object-oriented
programs that use subtypes,‚Äù in OOPSLA/ECOOP , 1990, pp. 212‚Äì223.
[4] P. America, ‚ÄúDesigning an object-oriented programming language with
behavioural subtyping,‚Äù in REX Workshop , vol. 489, 1990, pp. 60‚Äì90.[5] K. K. Dhara and G. T. Leavens, ‚ÄúForcing behavioral subtyping through
speciÔ¨Åcation inheritance,‚Äù in ICSE , 1996, pp. 258‚Äì267.
[6] C. Ruby and G. T. Leavens, ‚ÄúSafely creating correct subclasses without
seeing superclass code,‚Äù in OOPSLA , 2000, pp. 208‚Äì228.
[7] C. Szyperski, Component Software: Beyond Object-Oriented Program-
ming , 2002.
[8] C. Ghezzi, M. Jazayeri, and D. Mandrioli, Fundamentals of Software
Engineering (2nd edition) , 2002.
[9] M. Pradel and T. R. Gross, ‚ÄúFully automatic and precise detection of
thread safety violations,‚Äù in PLDI , 2012, pp. 521‚Äì530.
[10] J. Gosling, B. Joy, G. Steele, and G. Bracha, Java Language SpeciÔ¨Åca-
tion, 3rd Edition , 2005.
[11] S. Lu, S. Park, E. Seo, and Y . Zhou, ‚ÄúLearning from mistakes: a
comprehensive study on real world concurrency bug characteristics,‚Äù
inASPLOS , 2008, pp. 329‚Äì339.
[12] A. Nistor, Q. Luo, M. Pradel, T. R. Gross, and D. Marinov, ‚ÄúBallerina:
Automatic generation and clustering of efÔ¨Åcient random unit tests for
multithreaded code,‚Äù in ICSE , 2012, pp. 727‚Äì737.
[13] C. Pacheco, S. K. Lahiri, M. D. Ernst, and T. Ball, ‚ÄúFeedback-directed
random test generation,‚Äù in ICSE , 2007, pp. 75‚Äì84.
[14] H. Patil, C. Pereira, M. Stallcup, G. Lueck, and J. Cownie, ‚ÄúPinPlay: a
framework for deterministic replay and reproducible analysis of parallel
programs,‚Äù in CGO , 2010, pp. 2‚Äì11.
[15] W. Visser, K. Havelund, G. P. Brat, S. Park, and F. Lerda, ‚ÄúModel
checking programs,‚Äù Autom Software Eng , vol. 10, no. 2, pp. 203‚Äì232,
2003.
[16] E. Tempero, C. Anslow, J. Dietrich, T. Han, J. Li, M. Lumpe, H. Melton,
and J. Noble, ‚ÄúQualitas Corpus: A curated collection of Java code for
empirical studies,‚Äù in APSEC , 2010.
[17] M. Pradel, S. Heiniger, and T. R. Gross, ‚ÄúStatic detection of brittle
parameter typing,‚Äù in ISSTA , 2012, pp. 265‚Äì275.
[18] A. Snyder, ‚ÄúEncapsulation and inheritance in object-oriented program-
ming languages,‚Äù in OOPSLA , 1986, pp. 38‚Äì45.
[19] J. Offutt, R. T. Alexander, Y . Wu, Q. Xiao, and C. Hutchinson, ‚ÄúA fault
model for subtype inheritance and polymorphism,‚Äù in ISSRE , 2001, pp.
84‚Äì95.
[20] A. Taivalsaari, ‚ÄúOn the notion of inheritance,‚Äù ACM Comput Surv ,
vol. 28, no. 3, pp. 438‚Äì479, 1996.
[21] C. Csallner and Y . Smaragdakis, ‚ÄúJCrasher: an automatic robustness
tester for Java,‚Äù Software Pract Exper , vol. 34, no. 11, pp. 1025‚Äì1050,
2004.
[22] I. Ciupa, A. Leitner, M. Oriol, and B. Meyer, ‚ÄúARTOO: adaptive random
testing for object-oriented software,‚Äù in ICSE , 2008, pp. 71‚Äì80.
[23] W. Visser, C. S. Pasareanu, and S. Khurshid, ‚ÄúTest input generation with
Java PathFinder,‚Äù in ISSTA , 2004, pp. 97‚Äì107.
[24] P. Godefroid, N. Klarlund, and K. Sen, ‚ÄúDART: directed automated
random testing,‚Äù in PLDI , 2005, pp. 213‚Äì223.
[25] T. Xie, D. Marinov, W. Schulte, and D. Notkin, ‚ÄúSymstra: A framework
for generating object-oriented unit tests using symbolic execution,‚Äù in
TACAS , 2005, pp. 365‚Äì381.
[26] C. Cadar, D. Dunbar, and D. R. Engler, ‚ÄúKLEE: Unassisted and auto-
matic generation of high-coverage tests for complex systems programs,‚Äù
inOSDI , 2008, pp. 209‚Äì224.
[27] N. Tillmann and W. Schulte, ‚ÄúParameterized unit tests,‚Äù in ESEC/FSE ,
2005, pp. 253‚Äì262.
[28] W. M. McKeeman, ‚ÄúDifferential testing for software,‚Äù Digit Techn J ,
vol. 10, no. 1, pp. 100‚Äì107, 1998.
[29] B. Daniel, D. Dig, K. Garcia, and D. Marinov, ‚ÄúAutomated testing of
refactoring engines,‚Äù in ESEC/FSE , 2007, pp. 185‚Äì194.
[30] E. D. Tempero, J. Noble, and H. Melton, ‚ÄúHow do Java programs use
inheritance? An empirical study of inheritance in Java software,‚Äù in
ECOOP , 2008, pp. 667‚Äì691.
[31] S. McCamant and M. D. Ernst, ‚ÄúPredicting problems caused by com-
ponent upgrades,‚Äù in ESEC/FSE , 2003, pp. 287‚Äì296.
[32] W. Jin, A. Orso, and T. Xie, ‚ÄúAutomated behavioral regression testing,‚Äù
inICST , 2010, pp. 137‚Äì146.
[33] K. Kim, T. Yavuz-Kahveci, and B. A. Sanders, ‚ÄúPrecise data race
detection in a relaxed memory model using heuristic-based model
checking,‚Äù in ASE, 2009, pp. 495‚Äì499.