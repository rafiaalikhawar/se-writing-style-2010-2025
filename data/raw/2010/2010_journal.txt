29
Automated Detection of Client-State Manipulation Vulnera bilities
ANDERS MØLLER and MATHIAS SCHWARZ , Aarhus University
Web application programmers must be aware of a wide range of p otential security risks. Although the most
common pitfalls are well described and categorized inthe li terature, it remainsa challengingtask to ensure
that all guidelines are followed. For this reason, it is desi rable to construct automated tools that can assist
theprogrammers intheapplicationdevelopment process byd etectingweaknesses.Manyvulnerabilitiesare
related to web application code that stores references to ap plication state in the generated HTML docu-
ments to work around the statelessness of the HTTP protocol. In this article, we show that such client-state
manipulation vulnerabilities are amenable to tool-suppor ted detection.
We present a static analysisfor the widely used frameworks J ava Servlets, JSP, and Struts. Given a web
application archive as input, the analysis identiﬁes occur rences of client state and infers the information
ﬂow between the client state and the shared application stat e on the server. This makes it possible to check
how client-state manipulation performed by malicious user s may affect the shared application state and
causeleakage ormodiﬁcations of sensitiveinformation.Th e warningsproduced by thetool help the applica-
tionprogrammer identifyvulnerabilitiesbefore deployme nt. The inferred information can also be applied to
conﬁgureasecurity ﬁlterthatautomaticallyguards agains tattacksatruntime.Experimentson acollection
of open-source web applications indicate that the static an alysis is able to effectively help the programmer
prevent client-state manipulation vulnerabilities. The a nalysis detects a total of 4,802 client-state parame-
ters in the 10 applications, whereof 4,437 are classiﬁed as s afe and 241 reveal exploitable vulnerabilities.
Categories and Subject Descriptors: D.2.5 [ Software Engineering ]: Testing and Debugging
General Terms: Languages, Veriﬁcation
Additional Key Words and Phrases: Web application security , information ﬂow analysis, static analysis
ACM Reference Format:
AndersMøllerandMathiasSchwarz2014.Automateddetectio nofclient-statemanipulationvulnerabilities.
ACM Trans. Softw. Eng. Methodol. 23, 4, Article 29 (August 20 14), 30 pages.
DOI: http://doi.acm.org/10.1145/2531921
1. INTRODUCTION
Errors in web applications are often critical. To protect we b applications against ma-
licious users, the programmers must be aware of numerous kin ds of possible vulner-
abilities and countermeasures. Among the most popular guid elines for programming
safe web applications are those in the OWASP Top 10 report tha t covers “the 10 most
critical web application security risks” [Open Web Applica tion Security Project 2010].
Many security properties depend on the ﬂow of untrusted data in the programs. This
ﬂow is often not explicit in the program code, so it can be difﬁ cult to ensure that sen-
sitive data is properly protected. Although tool support ex ists for detecting and pre-
venting some risks, manual code review and testing remain cr ucial to ensure safety.
This work was supported by Google, IBM, and the DanishResear ch Council for Technology and Production.
Authors’ address: Department of Computer Science, Aarhus U niversity,Aabogade 34, Aarhus, Denmark.
Permission to make digital or hard copies of part or all of thi s work for personal or classroom use is granted
without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that
copies show this notice on the ﬁrst page or initialscreen of a display along with the full citation. Copyrights
for components of this work owned by others than ACM must be ho nored. Abstracting with credit is per-
mitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any component
of this work in other works requires prior speciﬁc permissio n and/or a fee. Permissions may be requested
from Publications Dept., ACM, Inc., 2 Penn Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212)
869-0481, or permissions@acm.org.
c/circlecopyrt2014 ACM 1049-331X/2014/08-ART29 $15.00
DOI 10.1145/2531921 http://doi.acm.org/10.1145/253192 1
ACM Transactionson Software Engineering and Methodology, Vol. 23, No. 4, Article 29, Pub. date: August 2014.However,code reviewand testing are tedious and error-pron emeans, so it is desirable
to identify classes of vulnerabilities that are amenable to tool support.
Asan example,considerthe category A4 -InsecureDirectObjectReferences fromthe
2010 OWASP Top 10 list. A direct object reference is a referen ce to an internal imple-
mentation object, such as a database record, that is exposed to the user as a form ﬁeld
or a URL parameter in an HTML document. Such references are ex amples of client
state, which is used extensively in web applications to work aroun d the statelessness
of the HTTP protocol, for example, to store session state in t he HTML documents at
the clients.
Figure1showstwoexcerptsofsourcecodefromawebapplicat ionnamed JSPChat1.
Part (a) shows a JSP page containing an HTML form for saving pe rsonal information
in a chat service, and part (b) shows the servlet code that is e xecuted when the form
dataissubmittedbytheuser.Theﬁrstthingtonoticeisthat thenickname formﬁeldon
line 20 in the JSP page functions as a direct object reference that refers to aChatRoom
objectandaChatter objectstoredontheserver.Astheapplicationprogrammerc annot
trust that the user does not modify such references in an atte mpt to access resources
that belong to other users, it is important to ensure that obj ect references are pro-
tected. This can be done, for example, using a layer of indire ction (i.e., using a map
stored on the server from client-state values to the actual o bject references), via cryp-
tographic signatures or encryption of the client state, or b y checking that the user is
authorized to access the resources being referenced in the r equests. This is, however,
easy to forget when programming the web application. In the e xample, the servlet
reads thenickname parameter, stores it in a ﬁeld in the servlet object, and then uses it
– withoutany security measures – to look up the correspondin gChatRoom andChatter
objects in the shared application state on lines 47 and 49. Ob viously, a malicious user
could easily forge the parameter value and thereby access an other person’s data. (The
careful reader may have noticed another vulnerability in th e program code; we return
to that in Section 7.)
Asdocumentedinsecurityalertsandreportsby,e.g.,ISS[I nternetSecuritySystems
2000], MSC [Brussin 1998], Advosys[AdvosysConsulting200 0], and Sanctum [ZDNet
2001], vulnerabilities of this kind have been known—and exp loited—for more than
a decade. A study of several hundred penetration test report s conducted by Imperva
between 2000 and 2003 placed it as the most common kind of web a pplication vul-
nerability [Cerf and Shulman 2004]. However, it remains wid espread, as evidentfrom
the 2010 OWASP report. A recent study shows that web applicat ion developers are
stillunawareofcommonclassesofrelatedvulnerabilities ,despiteawarenessprograms
provided by, for example, OWASP, MITRE, and SANS Institute [ Scholte et al. 2011].
A notable recent example of client-state manipulation is th e attack on the Citigroup
website that allowed hackers to disclose account numbers an d transaction history for
200,000 credit cards [Moran 2011].
According to OWASP, “automated tools typically do not look f or such ﬂaws because
they cannot recognize what requires protection or what is sa fe or unsafe”. Neverthe-
less, in this article we show that it is possible to develop au tomated tools that can
detect many of these ﬂaws. Our approach is based on a simple ob servation: Vulner-
ability involving client-state manipulation is strongly c orrelated to information ﬂow
from hidden ﬁelds or other kinds of client state to operation s involving the shared ap-
plicationstate on the server. This approachis along the lines of previousworkon static
taint analysis [Livshits and Lam 2005; Tripp et al. 2009], ho wever,with crucial differ-
encesin howwecharacterize the sourcesand sinks of the info rmationﬂow.We discuss
related work in Section 8.
1http://www.web-tech-india.com/software/jsp_chat.php
21<% ChatRoomList roomList =
2(ChatRoomList)application.getAttribute("chatroomlis t");
3ChatRoom chatRoom = roomList.getRoomOfChatter(nickname );
4Chatter chatter = chatRoom.getChatter(nickname); %>
5<html><head>
6<meta http-equiv="pragma" content="no-cache">
7<title>
8Edit your (<%=chatter.getName()%>’s) Information
9</title>
10<link rel="stylesheet" type="text/css"
11href="<%=request.getContextPath()%>/chat.css">
12</head>
13<body bgcolor="#FFFFFF">
14<form name="chatterinfo" method="post"
15action="<%=request.getContextPath()%>/servlet/saveI nfo">
16<table width="80%" border="0" cellspacing="0"
17cellpadding="2" align="center" bordercolor="#6633CC">
18<tr><td valign="top"><h4>Nickname:</h4></td>
19<td valign="top"><%=chatter.getName()%></td>
20<input type="hidden" name="nickname"
21value="<%=chatter.getName()%>">
22</tr>
23<tr><td valign="top"><h4>Email:</h4></td>
24<td valign="top"><input type="text" name="email"
25value="<%=chatter.getEmail()%>">
26</td></tr>
27<tr><td valign="top">
28<input type="submit" name="Submit" value="Save">
29</td></tr></table></form></body></html>
(a)editInfo.jsp
30public class SaveInfoServlet extends HttpServlet {
31String nickname = null;
32String email = null;
33HttpSession session = null;
34String contextPath = null;
35
36public void doGet(HttpServletRequest request,
37 HttpServletResponse response)
38throws IOException, ServletException {
39nickname = request.getParameter("nickname");
40contextPath = request.getContextPath();
41email = request.getParameter("email");
42session = request.getSession(true);
43ChatRoomList roomList = (ChatRoomList)
44getServletContext()
45.getAttribute("chatroomlist");
46ChatRoom chatRoom =
47roomList.getRoomOfChatter(nickname);
48if (chatRoom != null) {
49Chatter chatter = chatRoom.getChatter(nickname);
50chatter.setEmail(email);
51...
52}
53}
54}
(b)SaveInfo.java
Fig. 1. A simpliﬁed version of the JSPChat web application.
3In summary, the main contributions of this article are as fol lows:
—Our starting point is a characterization of client-state manipulation vulnerabilities
(Section2)thathasconsiderableoverlapwithcategoryA4f romtheOWASP2010list
ofthemostcriticalrisks. Inparticular,wedescribesafet yconditionsunderwhichthe
use of client state is likely not to cause vulnerabilities.
—Based on this characterization, we present an automated ap proach to detecting oc-
currencesofclientstateinagivenwebapplicationandtoch eckingwhetherthesafety
conditions are satisﬁed (Sections 3–6).
—Throughexperimentsperformedon10open-sourcewebappli cationswithaprototype
implementationofouranalysis,weshowthattheapproachis effectiveforhelpingthe
programmer detect client-state manipulation vulnerabili ties (Section 7). On a total
of 1,575 servlets, JSP pages, and Struts actions, our tool id entiﬁes 4,802 possible oc-
currencesofhiddenﬁeldsandotherclient-stateparameter s.Aftercustomization,the
toolclassiﬁes4,437 oftheseoccurrencesassafe.Ofthe365 warningsbeingproduced,
241 cases reveal exploitable vulnerabilities involving 59 differentﬁeld names.
The static analysis that underlies our automated approach t o detecting client-state
manipulation vulnerabilities consists of three component s. The ﬁrst component (Sec-
tion 4) infers the dataﬂow between the individual servlets a nd pages that constitute
the application in order to identify the client-state parameters . This requires a static
approximation of the dynamically constructed output of the servlets and pages and
extractionof relevantURLs and parameterﬁeldsin formsand hyperlinks. The second
component (Section 5) analyzes the program code to ﬁnd out wh ich objects represent
sharedapplicationstate ,i.e.,serverstatethatispersistentorsharedbetweenmul tiple
clients, as opposed to session state or transient state. The third component(Section 6)
performsan information ﬂow analysis to identify the possib le ﬂow of user-controllable
input from client-state parameters to shared application s tate objects. The vulnerabil-
itywarningsbeingproducedbythetoolareusefulforguidin gtheprogrammertoapply
appropriate countermeasures by modifying the application source code. Alternatively,
the information obtained by the analysis can be used for auto matically conﬁguring a
security ﬁlter that guards against client-state manipulat ion attacks at runtime (Sec-
tion 8.2).
Our goal is not to develop a technique that can fully guarante e absence of client-
state manipulation vulnerabilities. Rather, we aim for a pr agmatic approach that can
detectmanyrealvulnerabilitieswhileproducingasfewspu riouswarningsaspossible.
Since authorization checks and other countermeasures come in many different forms,
the information ﬂow analysis component may require some cus tomization, but the
analysis is otherwise fully automatic.
2. CLIENT-STATE MANIPULATION VULNERABILITIES
In a web application, client state comprisesinformationthatis stored within a dynam-
ically generated HTML document in order to be transmitted ba ck to the server at a
subsequentinteraction,forexample,whena formissubmitt ed. Sincethe HTTP proto-
col is stateless, client state is widely used for keeping tra ck of users and session state
that involve multiple interactions between each client and the server. Storing session
state at the client instead of at the server can have several b eneﬁts. Most importantly,
it decreases the load on the server and avoids the need for a se ssion-state expiration
mechanism. Client state appears as hidden ﬁelds in HTML form s (as in the example
in Section 1) and as URL query parameters in hyperlinks. Such state is not intended
to be modiﬁed by the user, but nothing prevents malicious use rs from doing so, and
this is easy to forget when programming web applications. A r elated situation occurs
4editInfo.jsp
SaveInfo.javaserver client
HTML document
in browsernickname
nickname
Fig. 2. Dataﬂow of client state from a JSP page to a servlet via an HTM L document. The nickname param-
eter is sent from editInfo.jsp toSaveInfo.java via the HTML document.
with HTML selectmenus, radio buttons, and checkboxes, whic h also contain ﬁxedsets
of values that the user is intended to choose from. We commonl y refer to HTTP GET/-
POST request parameters that contain such state as client-state parameters . Cookies
provide a related mechanism; in this article, we focus on ord inary HTTP request pa-
rameters, but our approach in principle also works for cooki es.
For the discussion, we consider Java-based web application s, speciﬁcally ones based
on Java Servlets, JSP, or Struts. We use the general term pageto refer to a servlet
instance, a JSP page, or a Struts action instance; each produ ces an HTML document
when executed.
Figure 2 illustrates the dataﬂow of client state for the JSPChat example. The value
ofnickname ispassed asclientstate froma JSPpage, editInfo.jsp ,to aservlet,Save-
Info.java ,using a hidden ﬁeld in the HTML document.
The following characterization is our key to automating det ection of the vulnerabil-
ities we consider: A web application is vulnerable to client-statemanipulation if users,
by modifying client state, can gain additional capabilitie s to access or change shared
application state. Note that by this deﬁnition, if all parts of the application state that
can be accessed or changed by modifying client state can also be accessed by other
means, for example, via another page in the application, it i s not considered vulnera-
ble to this kind of attack.
Thisclass ofvulnerabilitiesiscloselyrelatedto MITRE’s weaknesscategoriesCWE-
472 (External Control of Assumed-Immutable Web Parameter)2and CWE-639 (Au-
thorization Bypass Through User-ControlledKey)3—and, as discussed in the previous
section, to OWASP’s risk category A4 (Insecure Direct Objec t References). Moreover,
the page for CWE-472 mentions that it “is a primary weakness f or many other weak-
nesses and functional consequences, including XSS, SQL inj ection, path disclosure,
and ﬁle inclusion”. Descriptions of the categories are show n in Figure 3.
All client-state parameters—most importantly, those that originate from hidden
ﬁeldsinHTMLforms—arepotentialsourcesofclient-statem anipulationvulnerability.
On the otherhand, we observe that uses of clientstate are safe, that is, not vulnerable
to client-state manipulation, if at least one of the followi ng conditions is satisﬁed.
1) The client-state parameter value stored in the HTML docum ent is encrypted us-
ing a key that is private to the server. The server then decryp ts the value when it
is returned. A variant is to leave the value unencrypted but a dd an extra hidden
ﬁeld or URL parameter containing a digital signature (or MAC , message authen-
tication code) computed from the client-state value and the server’s private key.
The server then veriﬁes that the client-state value is unalt ered by checking the
2http://cwe.mitre.org/data/definitions/472.html
3http://cwe.mitre.org/data/definitions/639.html
5CWE-472 (External Control of Assumed-Immutable Web Parame ter)
“If a web product does not properly protect assumed-immutab le values from modiﬁcation in hid-
den form ﬁelds, parameters, cookies, or URLs, this can lead t o modiﬁcation of critical data. Web
applicationsoftenmistakenlymakethe assumptionthat dat apassedtotheclientinhiddenﬁelds
or cookies is not susceptible to tampering. Improper valida tion of data that are user-controllable
can lead to the application processing incorrect, and often malicious, input.”
CWE-639 (Authorization Bypass Through User-Controlled Ke y)
“Retrievalofauserrecordoccursinthesystembasedonsome keyvaluethatisunderusercontrol.
The key would typically identify a user related record store d in the system and would be used to
lookup that record for presentation to the user.”
OWASP A4 (Insecure Direct Object References)
“A direct object reference occurs when a developer exposes a reference to an internal implemen-
tation object, such as a ﬁle, directory, or database key. Wit hout an access control check or other
protection, attackers can manipulate these references to a ccess unauthorized data.”
Fig. 3. Weakness categories from MITRE and OWASP that are related t o client-state manipulation.
signature when the form data is returned. To prevent against replay attacks and
impersonation attacks, a timestamp and a client ID can be inc luded in the encryp-
tion or signature generation. A drawback of this approach is that extra work is
neededwhen producing and receiving the client state.
2) Theclientstateentirelyconsistsoflargerandomvalues thatarepracticallyimpos-
sible to predict by attackers. A typical example is the use of session IDs : in many
web applications, all session state is stored on the server, and the only client state
being used consists of session IDs, that is, references to th e session state on the
server. A drawback of this approach is that it requires extra space on the server to
store the session state.
3) An indirection is used. The client state consists of, for e xample, only numbers be-
tween 1 and some small constant, and these numbers are then ma pped to the
actual application state on the server. This approach is par ticularly useful for se-
lect menus, radio buttons, and checkboxes. In this way, clie nt-state manipulation
cannotprovideaccesstodatabeyondwhatisaccessiblefrom thismap.Adrawback
of this approach is the burden involved in maintaining the in direction map.
4) The client-state parameter is treated as untrusted input , no different from other
kindsof parameters, and anyaccess to application state inv olvingthe givenclient-
state value is guarded by an authorization check.
5) Finally,asufﬁcientconditionforsafetyaccordingtoth eprecedingdeﬁnitionisthat
all the shared application state that can be accessed throug h client-state manipu-
lation is already available by other means, that is, the info rmation should not be
considered sensitive.
We see uses of several of these techniques in the web applicat ionsHipergate ,
Pebble, andJWMA that we study in Section 7. OWASP’s ESAPI4library con-
tains support for implementing techniques 1–4. As an exampl e, to apply the
ESAPI encryption approach to the JSPChat web application from Figure 1, the
programmer would wrap the expression chatter.getName() on line 21 into a
call toESAPI.httpUtilities().encryptHiddenField( ...)and insert a matching call
todecryptHiddenField on line 39. The decryptHiddenField method throws an
IntrusionException if tampering is detected. In .NET, the LosFormatter5class pro-
4https://www.owasp.org/index.php/Category:OWASP_Ente rprise_Security_API
5http://msdn.microsoft.com/en-us/library/system.web. ui.losformatter.aspx
6vides support for MAC protection of client state (or view sta te, as it is called in .NET).
The use of encryption and signatures to prevent manipulatio n of hidden form ﬁelds
was originally suggested by MSC [Brussin 1998] and Advosys [ Advosys Consulting
2000]. Thus, the countermeasuresare well known; the goal of our analysis is to detect
when they are applied inadequately.
3. OUTLINE OF THE ANALYSIS
We adapt the well-known approach to static information ﬂow a nalysis for identify-
ing the possible dataﬂow from sources tosinksthat does not pass through sanitiz-
ers[Huang et al. 2004; Livshits and Lam 2005; Tripp et al. 2009; W assermann and Su
2008; Xie and Aiken 2006; Jovanovic et al. 2010].
—The sources in our setting are the locations in the code wher e client-state param-
eters are read. With common web application frameworks, suc h as Java Servlets,
JSP, and Struts, it is not explicit in the application source code which parameters
contain client state, so we need a static analysis to infer th is information.
—Thesinksaretheoperationsinthesourcecodethatinvolve sharedapplicationstate.
We conservativelyassumethatthisapplicationstate isnot accessedbyothermeans
(cf. condition 5 in Section 2). This assumption may lead to fa lse positives, which we
consider experimentally in Section 7. As is it not explicit i n the source code which
operations involve shared application state (compared to s ession state or transient
state), we need another static analysis componentto extrac t this information.
—The sanitizers correspond to the various kinds of protecti on described in Section 2.
For example, decrypting an encrypted client-state value is one kind of sanitization.
Our analysis tool has built in mechanisms for identifying si nks and sanitizers, inde-
pendently of the applications. The user can customize the an alysis by providing addi-
tional application speciﬁc patterns.
We propose the following procedure for analyzing a given web application: (1) Run
the analysis on the application, with only the default sink a nd sanitizer patterns; (2)
study the warnings being producedand add customization rul es to those that are con-
sidered false positives to enable the analysis to reason mor e precisely about the rele-
vant parts of the application; (3) run the analysis again, us ing the new customization.
Provided that the analysis is sufﬁciently precise, most war nings now indicate actual
exploitable vulnerabilities.
Itis, inprinciple,possiblefora programmerto specifyinc orrectcustomizationrules,
which may affect soundness of the analysis output. However, we trust that the cus-
tomization rules are correct. The purpose of our analysis is to alert the programmer
to potential vulnerabilities, notto formally verifycorre ctnessof,for example,low-level
operationsfor digital encryptionor MAC checking. Moreove r,the customization mech-
anism is easy to use, as we shall see in Sections 6 and 7.
One approach to remedy vulnerabilities detected by the anal ysis is that the pro-
grammer manually incorporates appropriate countermeasur es into the web applica-
tion source code, as discussed in Section 2. Another option i s to feed the vulnerability
report to a security ﬁlter, which we describe in Section 8.2, for automatic protection.
Ourexperiments(Section7)indicatethattheburdenofthec ustomizationstepisman-
ageable. However, we note that a fully automatic approach to protect against client-
state manipulation can be obtained by omitting customizati on entirely and applying
the security ﬁlter without having eliminated false positiv es. Compared to the more
manual approach involving customization, the price is a mod est runtime overhead in-
curred by the security ﬁlter, since it may protect some clien t state unnecessarily.
7Customization
Web Application 
ArchiveVulnerability 
ReportClient State 
Analysis
(Section 4)
Application 
State Analysis
(Section 5)Information 
Flow Analysis
(Section 6)
Fig. 4. Structure of the analysis.
The following sections explain how we identify client-stat e parameters and applica-
tion state and perform the information ﬂow analysis. The str ucture of the combined
analysis is illustrated in Figure 4.
4. IDENTIFYING CLIENT STATE
When a page preads an HTTP parameter, for example, on lines 39 and 41 in Fig ure 1,
the only way we can ﬁnd out whether that is a client-state para meter is to analyze
every page qof the application that dynamically constructs HTML docume nts with
links or forms referring to p. Speciﬁcally, we need to recognize the construction of the
hidden ﬁeld named nickname on line 20 ineditInfo.jsp ,and via theactionattribute
of the<form>elementineditInfo.jsp ,establish the connectionfrom editInfo.jsp to
line 39 in the servlet SaveInfo.java .
The goal of this phase is to analyze every page in the applicat ion to ﬁnd out which
client-state parameters appear in the generated HTML docum ents and which refer-
ences exist to other pages. For each page qin the web application, we ﬁrst generate
a context-free grammar Gqthat conservatively approximates the set of HTML doc-
uments that may be generated by q. This can be done as in our previous work on
analysis of dynamically generated HTML documents [Møller a nd Schwarz 2011]. To
ﬁnd the client-state parameters in the HTML documents gener ated by q, we iden-
tify all elements that deﬁne hidden ﬁelds, select boxes, rad io buttons, and links
inGqand collect the corresponding parameter names. Since these names may be
generated dynamically in the program, we approximate them c onservatively by a
regular language Cout(q). In the JSPChat example from Figure 1, this step identi-
ﬁesnickname as the only client-state parameter originating from editInfo.jsp , thus
Cout(editInfo.jsp ) ={nickname }. We also infer the references between the pages by
identifyinghrefattributes in<a>elements andactionattributes in<form>elements
inGq. This results in a map Sthat holds the set of possible successor pages for each
page. For example, SaveInfo.java ∈S(editInfo.jsp ). Section 4.1 explains in more
detail how to infer this information from the web applicatio n code.
Combined with information extracted from the deployment de scriptors (web.xml in
Servlets andstruts.xml in Struts), this results in a page graph in which nodes cor-
respond to pages and edges correspond to S, describing the possible links and form
actions. In the example in Figure 1, this step identiﬁes the e dge fromeditInfo.jsp
toSaveInfo.java . Figure 5 shows the page graph for the six pages in JSPChat that
involve ﬂow of client state.
8editInfo.jsp SaveInfo.java{nickname}listrooms.jsp
logout.jspfind.jsp{submitted}
sendMessage.jsp{n, nickname}
{n, nickname}{n, nickname}
Fig. 5. The automatically constructed page graph for the parts of JSPChat that involve client state.
Thenamesofthe incomingclient-state parametersto a page pcan nowbeexpressed
asCin(p) =∪qiCout(qi)for each page qiwherep∈S(qi). For the example, we get
Cin(SaveInfo.java ) ={nickname }. This tells us that when SaveInfo.java reads the
nickname parameter, as in request.getParameter("nickname") on line 39 in Figure 1,
that should be treated as a source in the subsequent informat ion ﬂow analysis, in
contrast to theemailparameter that is read on line 41. Section 4.2 explains more
generallyhowtouse Cinforlocatingoperationsintheapplicationcodethatreadcl ient-
state parameters.
The result of these steps is a set of method calls in the applic ation code that will
serve as sources of client-state values in the information ﬂ ow analysis in Section 6.
All of the steps can be done soundly in the sense that every cal l togetParameter and
related operations that may return client state is always in cluded in the statically
inferred set of client-state value sources. In our experime nts, we never observe any
imprecision of this phase.
4.1. Analyzing HTML Output
As previously outlined, we analyze the source code of the web application to ﬁnd the
hidden ﬁelds, URL parameters, links, and form actions that m ay appear in the gen-
erated HTML pages. With Java Servlets, output is generated b y printing string frag-
mentsto an output stream. JSP and Struts compileto Servlets , so we can handle each
of these frameworks by focusing on Servlets. We assume that t he HTML documents
beinggenerateddonotuseJavaScriptcodeinwaysthatinter ferewithformsandlinks.
Starting from the Java bytecode of the web application, the ﬁ rst step is to construct
anoutput stream ﬂow graph , which is a representation of the program that abstracts
away everythingnot directly relevantfor generatingoutpu t to the output stream. The
notion of output stream ﬂow graphs originates from previous work [Kirkegaard and
Møller 2006; Møller and Schwarz 2011]; here we give a more for mal description, in-
cluding a precise description of the connection to context- freegrammars.
An output stream ﬂow graph Fis a directed graph given as a tuple (N,E,C,L ).
—Nis a ﬁnite set of nodes, divided into three disjoint subsets.
—Nappendareappend nodes representinginstructions that print strings to the out-
put stream.
—Ninvokeareinvoke nodes correspondingto method calls.
—Nreturnarereturn nodes correspondingto method returns.
—E⊆(Nappend∪Ninvoke)×Nis a set of intra-procedural edges.
—C⊆Ninvoke×Nis a set of calledges.
—L:Nappend→ Rgives a regular string language (represented by a regular ex pres-
sion or a ﬁnite-state automaton over the Unicode alphabet) f or every append node.
9Fig. 6. Excerpt from the output stream ﬂow graph for editInfo.jsp . Dashed edges indicate places where
additional nodes exist in the full graph.
Output stream ﬂow graphs are abstract machines. Intuitivel y, the nodes correspond
to primitive instructions in the program being analyzed, an d edges correspond to con-
trol ﬂow between those instructions. An append node abstrac tly writes to the output
stream and then continues execution nondeterministically at a successor node. An in-
voke node pushes a successor node to the call stack and then en ters one of its target
methods. A return node exits the currentmethod, pops a node f rom the call stack, and
continues executionfrom that node. We deﬁne the language LF(n0)ofFrelative to an
entry node n0∈Nas the set of strings that may appear as output when Fis executed
startingfrom n0withanemptystackandendingatareturnnodewithanemptyst ack.
Ourimplementationconstructsoutputstreamﬂowgraphsfro mJavabytecodeusing
the Sootprogramanalysis framework[Vallee-Raietal. 1999 ] and the JSA string anal-
ysis tool [Christensen et al. 2003; Feldthaus and Møller 200 9]. From Soot, we use the
Jimple intermediate representation, the built-in class-h ierarchy analysis for obtain-
ing call graphs, and the Spark points-to analysis to ﬁnd the o perations that affect the
HTTP output stream. JSA gives us the regular string language s for the invoke nodes.
The resulting output stream ﬂow graph has one entry node in Ffor each page in the
web application.
Figure 6 showsa part ofthe outputstream ﬂowgraphfor editInfo.jsp .Since there
are no control-ﬂowstructures in the source code of the page, the graph becomes linear
andcontainsanappendnodeforeachoperationthatmayemito utputtotheclient.The
hiddenﬁeldnickname isgeneratedbytheappendnode n4.Alsonoticethattheanalysis
approximates the possible value of chatter.getName() from line 8 in Figure 1 as any
string,Σ∗. In the subsequent analysis, we choose to ignore the fact tha t this may in
principlealterthesyntacticstructureoftheHTMLdocumen t,whichmaycauseinvalid
HTML as well as other kinds of vulnerabilities.
Acontext-free grammar Gis a tuple (V,Σ,s,P)where the following hold.
—Vis a set of nonterminals.
—Σis the terminal alphabet where V∩Σ =∅.
—s∈Vis a start nonterminal.
—Pis a ﬁnite set of productions of the form v→θwherev∈Vandθ∈(V∪Σ)∗.
10v0→<html><head><metahttp-equiv="pragma"content="no-cac he">
<title>Edit your ( v1
v1→Σ∗v2
v2→’s) Information</title>
<linkrel="stylesheet"type="text/css"href=" ...v3
v3→Σ∗v4
v4→></td>
<inputtype="hidden"name="nickname"value=" ...v5
v5→ǫ
Fig. 7. Excerpt of the context-free grammar for editInfo.jsp corresponding to the output stream ﬂow
graph from Figure 6.
For convenience,we also allow right-hand sides of producti onsinPto be symbols that
denote regular string languages over Σ. (In principle, these can always be reduced to
regulargrammars.)We deﬁnethelanguage LG(v0)ofGrelativeto a nonterminal v0as
the set of strings over Σthat can be derived starting from v0using the productions in
P. In particular we are interested in the language relative to the start nonterminal s,
writtenL(G) =LG(s).
We now construct a family of context-free grammars {Gq1,...,G qk}, one for each
page in the web application, from the output stream ﬂow graph F. All the grammars
have the same nonterminals, terminals, and productions; on ly the start nonterminal
differs. The nonterminals are the nodes from F, that is, V=N, andΣis the Unicode
alphabet.Thestartnonterminalfor Gqistheentrynodeofthepage q.Theproductions
are constructed such that LGq(n) =LF(n)for alln∈N. Although output stream
ﬂow graphs have an operational ﬂavor and context-free gramm ars are a declarative
formalism, this construction of the productionsis straigh tforward:
—for each n∈Nappendand(n,m)∈E, add a production n→rnmtoPwhere the
symbolrndenotes L(n),
—for each n∈Ninvoke,(n,m)∈Eand(n,p)∈C, add a production n→p mtoP, and
—for each n∈Nreturn, add a production n→ǫtoP.
The correctness of this translation from output stream ﬂow g raphs to context-free
grammars follows from the observation that the semantics of both formalisms can
be expressed as the smallest solution to the following const raints where Lassigns a
language over the Unicode alphabet to each node or nontermin al:
∀n∈Nappend,(n,m)∈E:L(n)L(m)⊆ L(n)
∀n∈Ninvoke,(n,m)∈E,(n,p)∈C:L(p)L(m)⊆ L(n)
∀n∈Nreturn:ǫ∈ L(n)
We now have a family of context-free grammars where L(Gq)is an over-
approximation of the set of strings that the web application pageqmay possibly pro-
duceasoutput.As anexample,Figure7 showsan excerptofthe context-freegrammar
foreditInfo.jsp .
Recall that the goal of this phase is to identify speciﬁc elem ents and attributes that
hold client state, in particular, names of hidden ﬁelds, and URLs that point to other
applicationpages.Asthecontext-freegrammarswehavepro ducedworkatthelevelof
individual characters, we need to analyze each Gqto produce an annotated grammar
G′
qthat shows how the characters group into HTML elements and at tributes.
To see how this can be done, consider the way an HTML parser per forms a left-
to-right scan through the characters of an ordinary HTML doc ument. The parser is
initially in a state contents . When it encounters a <character, it switches to another
11statetagname , meaning that it now expects to see a tag name. It stays in this state
until it encounters, for example, a whitespace character, w hich causes a switch to the
stateattname meaning that it is now prepared to see an attribute name. Simi larly, it
recognizes the different kinds of attribute value syntax, e ntity references, comments,
etc.,asdifferentparsestates.Let Hdenotethesetofallparsestatesthatarenecessary
for parsing HTML documents, H={contents ,tagname ,...}, and let δ:H×Σ→H
denote the transition function that determines the next sta te after each character is
read. An actual HTML parser also maintains a stack to keep tra ck of the nesting of
elements;forour purposes,onlythe δfunctionisrelevant. We nowgeneralizethis pro-
cesstooperateonacontext-freegrammar Gq,whichdeﬁnesasetofHTMLdocuments,
ratherthan onindividualHTML documents.Theresultisa fun ctionρ:P×N→ P(H)
that assigns a set of HTML parse states to each position in the productions of Gq. As
an example, for a production p3=v7→v8<ul> v9</ul> , where v7,v8,v9are
nonterminals, we may have ρ(p3,0) =ρ(p3,1) ={contents }andρ(p3,2) ={tagname },
wherethe numbers 0,1, and2correspondto the position at the beginningof the right-
hand-side of the production, the position immediately afte rv8, and the position after
the ﬁrst<character, respectively. We construct the function ρas the least solution to
the following constraints:
—for each production p=v→θwherevis the start nonterminal: contents ∈ρ(p,0)
—for each production p=v→θand each i= 1,...,|θ|, letaibe theith terminal or
nonterminal in θ,
—ifaiis a terminal: h∈ρ(p,i−1)⇒δ(h,ai)∈ρ(p,i)
—ifaiis a nonterminal and p′=ai→θ′is a production:
ρ(p,i−1)∈ρ(p′,0)∧ρ(p′,|θ′|)∈ρ(p,i)
The least solution can be computed using a simple ﬁxpoint alg orithm. Intuitively, the
ﬁrst constraint ensures that generated strings start in the contents state, and the
other constraints apply the transition function δfrom left to right on the characters in
the strings to ﬁnd the possible parse states at the different positions.
We now deﬁne the annotated grammar G′
q= (Gq,ρ). Each set ρ(p,i)is usually a
singleton, meaning that the parse context has been determin ed uniquely, however,
in situations where a piece of program code generates output that may result, for
example, either in contents between HTML tags or in attribut e values, the sets may
contain multiple parse states.
The last step of the static analysis of the dynamically gener ated HTML output con-
sists of a simple traversal through the annotated grammar G′
q, looking for speciﬁc ele-
mentsandattributes. To construct Cout,thatis, therequiredinformationaboutnames
of hidden ﬁelds and URL parameters, we look for the nameattributes in<input> el-
ements that have a typeattribute with value hiddenand forhrefattributes in<a>
elements. To construct the page graph edges Swe look for the actionattributes in
<form>elements and for hrefattributes in<a>elements.
After annotating the grammar from Figure 7, we can determine that the produc-
tion onv4can generate an element named inputwith attributestype="hidden" and
name="nickname" ,soCout(editInfo.jsp )containsnickname .
4.2. Analyzing Input Parameters
Parameter values in the Java Servlet framework are read usin g thegetParameter
method of theHttpServletRequest object. We conservatively assume that all objects
of typeHttpServletRequest are relevant. The Servlet framework instantiates all re-
quest objects and provides no implementation of the HttpServletRequest interface to
the programmer, so this assumption is unlikely to result in f alse positives in practice.
Since the request parameter name that is given as an argument to this method may
12not be a constant in the source code, we approximate for each c all togetParameter
the possible values as a regular language. We obtain this inf ormation using the JSA
string analysis tool as in Section 4.1. If the language overl aps with Cin(p), we mark
the method call as a client-state value source . This step will mark the method call on
line39 in Figure1 assuch a source.Thecall online 41 will not be marked,since email
is not in Cin(SaveInfo.java ).
Most JSP pages that read request parameters use the underlyi ng mechanism from
Servlets, although the expression language (EL) and the JST L tag library may also be
involved.In the Struts framework, parameters are read in a d ifferentmanner. Rather
than retrieving the values from a request object, Struts pop ulates a Java bean object
with the parameter values. In each case, we can identifypara meter read operationsin
the code using simple pattern matching on Soot’s Jimple code .
5. IDENTIFYING SHARED APPLICATION STATE
Toﬁndtheoperationsinthecodethataffectsharedapplicat ionstate,thatis,statethat
is shared between all requests, we ﬁrst identify the applica tion state that is stored in
memory,which we call the internal application state. This includes:
(1) allHttpServlet objects (and hence the value of thisinside servlet classes) and
ServletContext objects, and all values of static ﬁelds,
(2) all valuesof ﬁelds of objectsthat have been classiﬁed as internal application state,
and conversely, all objects that have non-static ﬁelds cont aining internal applica-
tion state, and
(3) all values returned from static methods or from methods o n internal application
state objects.
Notice that in situations where session state or transient s tate points to shared ap-
plication state or vice versa, the second rule may conservat ively classify such state as
application state.
Finding all expressions in the code that may yield internal a pplication state accord-
ingtotheserulescanbedonewithasimpleiterativeﬁxpoint algorithmcombinedwith
an alias analysis, such as the points-to analysis provided b y the Soot tool that we also
used in Section 4.1. We ﬁrst deﬁne a set of abstract locations K=Field∪Local,
whereFieldandLocaldenote the ﬁelds in classes and the local variables and metho d
parameters, respectively, in the application code. For a ﬁe ldf∈Field, the abstract
location fcorresponds to the set of ﬁelds named fin objects at runtime. Similarly, a
local variable or method parameter x∈Localcorresponds to all occurrences of xat
runtime. Every name in FieldandLocalis implicitly qualiﬁed by the signature of the
surrounding class and method, respectively, to distinguis h between variables of the
same name in different contexts. We assume that nested expre ssions have been lin-
earized by Soot using extra local variables, and the keyword thisis treated as a local
variable. The points-to analysis gives us a may-alias equiv alence relation ∼ ⊆K×K
such that k1∼k2ifk1andk2may point to the same object at runtime. We now ﬁnd
the internal application state by computing a subset of the a bstract locations A⊆K
as the least solution to the following constraints, where x,y∈Local,f∈Field,cis a
class, and mis a method:
—for every abstract location kthat has typeHttpServlet orServletContext or is a
static ﬁeld: k∈A,
—for every ﬁeld read operation x=y.f:y∈A⇒x∈A,
—for every ﬁeld write operation x.f=y:y∈A⇒x∈A,
—for every static method call operation x=c.m(...):x∈A,
—for every non-static method call operation x=y.m(...):y∈A⇒x∈A,
—for every pair of abstract locations, k1andk2, wherek1∼k2:k1∈A⇔k2∈A.
13this∈A
t1∈A
t1∈A⇒roomList ∈A
roomList ∈A⇒chatRoom ∈A
chatRoom ∈A⇒chatter ∈A
Fig. 8. Constraints for computing the internal application state for the classSaveInfo . The local variable
t1corresponds to the sub-expression getServletContext() on line 44 in Figure 1.
The ﬁrst condition correspondsto rule (1) from before, the n ext two correspondto rule
(2), and the two after those correspond to rule (3). The last c ondition takes aliasing
into account. This computation of Acaptures all internal application state, although
obviously as an approximation. As already mentioned, we may conservatively classify
some session state or transient state as application state. The coarse heap abstraction
andaliasanalysis, aswellasthelackof,forexample,ﬂow-a ndcontext-sensitivitymay
also contribute to imprecision. Nevertheless, the experim ents described in Section 7
indicate that this simple analysis is sufﬁcient.
Continuing the JSPChat example from Figure 1, the variables nickname ,email,
session, andcontextPath inSaveInfo.java are ﬁelds in the servlet class, so their
values are correctlyclassiﬁed as internal application sta te. (That is, however,presum-
ably not intended by the programmer, which we return to in Sec tion 7.) TheroomList
variable gets its value froman attribute in the servletcont extobjectusing the method
callsgetServletContext().getAttribute( ...), so its value is also classiﬁed as inter-
nal applicationstate. In contrast, thevariables request andresponse arenotincluded
as internal application state. The constraints being gener ated are shown in Figure 8.
The alias analysis is not neededin this simple example.
We also ﬁnd the external application state stored in ﬁles and databases. Such state
is read and written using special API functions. The analysi s treats all parameters to
all methodsfromthestandard Javalibrariesassinks, excep tforabuilt-in collectionof
method parameters that have a special meaning for the inform ation ﬂow. We describe
these exceptions and a customization mechanism in Section 6 .
Web applications often rely on libraries, such as Hibernate or Apache Commons,
whichare typicallyprovidedin separate jarﬁles. We allow l ibrariesto beomitted from
the analysis for analysis performance reasons. This will si mply cause the analysis
to treat all method calls to those libraries conservatively as operations on external
application state.
The result of this analysis componentis an over-approximat ion of the set of expres-
sionsinthecodethatyieldinternalapplicationstateando fthesetofmethodcallsthat
involve external application state. We use this informatio n in the following section.
6. INFORMATION FLOW FROM CLIENT STATE TO SHARED APPLICATION STATE
As outlined in Section 3, we use an information ﬂow analysis t o identify ﬂow of the
client-state valuesin the programto the sharedapplicatio n state. In general,informa-
tion ﬂow analysis considers two kinds of ﬂow: explicitandimplicit ﬂow [Denning and
Denning 1977]. Explicit ﬂow is caused by assignments and par ameter passing. Other
formsofexplicitﬂowmaybe describedusing customizedderi vationrules, as described
next. Implicit ﬂow arises when the value of a variable depend s on a branch condition
involvinganother variable. Other work involvinginformat ionﬂow in web applications
typically disregards implicit ﬂow [Livshits et al. 2009; Tr ipp et al. 2009]. According to
Tripp et al. [2009], “experience shows that attacks based on control dependence are
rareand complex,andthus less importantthan directvulner abilities.”To simplifyour
analysis, we also choose to consider only the explicit ﬂow.
14Information ﬂow analysis requires a characterization of so urces, sinks, and sanitiz-
ers. The sources in our analysis are the client-state value s ources that were identiﬁed
inSection4. Thesinksareoperationsinthecodewheretheap plicationwritesto ﬁelds
of internal application state objects or invokes methods th at involve external applica-
tion state, which we found in Section 5.
Sanitizers can be methodsthat determinewhethera givencli ent-state value is safe,
for example,by performingaccess control or MAC checking, a nd methodsthat convert
unsafe values to safe ones, for example, by decrypting the va lues. An example is the
ESAPI methoddecryptHiddenField mentioned in Section 2. As sanitizers are highly
application speciﬁc, they are provided through customizat ion, and none are built into
the analysis.
The information ﬂow analysis we use is a simple whole-progra m dataﬂow analysis.
It is ﬂow sensitive, meaning that different information is o btained at different pro-
gram points. It is context sensitive using one level of call- site sensitivity. The state
abstraction uses the same deﬁnition of abstract locations, K, as the analysis in Sec-
tion 5. Each abstract state provides a set of client-state pa rameter names for each
abstract location. For example, at the program point after t he assignment on line 39
in Figure 1, the abstract state maps the emailﬁeld of the servletclass to the singleton
set{nickname }, and all other locations are mapped to the empty set. Our impl emen-
tation uses Soot, as in the other analysis components, with c lass-hierarchy analysis
for call-graph construction. The analysis scales well sinc e it only tracks client-state
parameters, and relatively few ﬁelds and variables involve client state in typical web
applications. Another important factor is that the analysi s skips library code.
The information ﬂow analysis can be customized to improve pr ecision for sanitizers
and sinks. As already mentioned, calls to library methods ar e treated as sinks by de-
fault. This behavior can be changed by specifying derivatio n rules, each consisting of
a method signature and a description of the relevant informa tion ﬂow between argu-
ments,thebaseobject,andthereturnvalue.Suchderivatio nrulescanalsobeprovided
for methods in application code to override the ordinary ana lysis of information ﬂow
between calls to those methods and their bodies, typically f or describing sanitizers
that convert unsafe values to safe ones. Another variant of c ustomization rules allow
description of sanitizers that return a boolean indicating whether the given value is
safe ornot. When this booleanis used as a branch condition,t he analysis will consider
the sanitized value as safe in the true branch.
The customization rules can be given either as annotations i n the code or in a sepa-
rate ﬁle. Application-speciﬁc rules can be added by the user of the analysis. Examples
of such customizations are presented in Section 7. Addition ally, we provide a collec-
tion of predeﬁned rules for the Java standard library. Figur e 9 shows some examples.
The ﬁrst four rules involve operations on strings that propa gate client-state informa-
tion from parameters to return values or to the base value. Fo r theaddmethod on a
Listobject, theListobject is marked as client-state if the object being added to the
list has that status. All Iterator objects being produced from such Listobjects also
become marked as client state, and similarly for objects tha t are returned from the
nextmethod on these Iterator objects. This accounts for the common pattern of in-
formationﬂow to and from Listcontainers. Other containers, such as HashMap objects,
are treated similarly. The last rule shown in the list tells t he analysis that creating a
Fileobject is harmless—in fact, such objects are often used in au thentication checks
(cf. condition 4 in Section 2)—so the Fileconstructor should not be treated as a sink.
However, we specify information ﬂow from the parameter to th e constructed object,
since that object may later be used for constructing, for exa mple,FileWriter objects,
which are treated as sinks.
15java.lang.String.replace(java.lang.CharSequence,jav a.lang.CharSequence):
Flow from parameters 1 and 2 to return value
java.lang.StringBuffer.append(java.lang.String):
Flow from parameter 1 to base and return value
java.lang.Integer.parseInt(java.lang.String):
Flow from parameter 1 to return value
java.io.Writer.write(java.lang.String):
Flow from parameter 1 to base value
java.util.List<E>.add(E):
Flow from parameter 1 to base value
java.util.List<E>.iterator():
Flow from base value to return value
java.util.Iterator<E>.next():
Flow from base value to return value
java.util.HashMap<K,V>.put(K,V):
Flow from parameters 1 and 2 to base value
java.util.HashMap<K,V>.get(java.lang.Object):
Flow from base value to return value
java.io.File(java.lang.String):
Flow from parameter 1 to return value
Fig. 9. Examples of predeﬁned derivation rules for the informatio n ﬂow analysis.
For the example in Figure 1, the information ﬂow analysis ﬁnd s out how the hidden
ﬁeld values appearing at the source on line 39 may affect the a pplication state, which
triggers a vulnerability warning. This is explained in more detail in Section 7.1.
7. EVALUATION
Our prototype implementation, WAR LORD6, reads in a Java web archive (.war) ﬁle
containing a web application built with Java Servlets, JSP, or Struts, togetherwith an
analysis customization ﬁle, and performs the analysis desc ribed in Sections 3–6. As
mentioned in previous sections, the implementation is base d on the Soot analysis in-
frastructure [Vallee-Rai et al. 1999], the JSP compiler fro m Tomcat7, and our tools for
HTML grammaranalysis [MøllerandSchwarz2011] andstring a nalysis [Christensen
et al. 2003; Feldthaus and Møller 2009]. With this implement ation, we aim to answer
the following research questions:
Q1: Istheanalysispreciseenoughtodetectclient-statevu lnerabilitieswithalownum-
ber of false positives? Speciﬁcally, can it identify the com mon uses of client state,
and is it capable of distinguishing between safe and unsafe u ses of client state in
the sense described in Section 2?
Q2: Are the warning messages produced by the tool useful to th e programmer for de-
ciding whether they are false positives or indicate exploit able vulnerabilities?
Q3: Insituationswheretheprogrammerdecidesthatavulner abilitywarningisa false
positive, is it practically feasible to exploit the customi zation mechanism to elimi-
nate the false positive?
Q4: Is the analysis fast enough to be practically useful duri ng web application devel-
opment?
6http://www.brics.dk/WARlord/
7http://tomcat.apache.org/tomcat-7.0-doc/jasper-howt o.html
16Frameworks
Pages
Client-stateparameters
Unique names
JSPChat Servlets, JSP 16193
Hipergate JSP 7602,680264
Takatu JSP, Struts 5581,840 31
Pebble Servlets, JSP 122 2211
Roller JSP, Struts 538627
JWMA Servlets, JSP 264010
JsForum Servlets, JSP 10148
JavaLibrary JSP 209235
BodgeIt Servlets, JSP 966
WebGoat Servlets 111
Fig. 10. List of benchmarks. The ‘Frameworks’ column shows which we b frameworks are used in each
benchmark; ‘Pages’ is the total number of JSP pages, servlet classes, and Structs action classes; ‘Client-
state parameters’ is the number of client-state parameters inferred by the analysis, and ’Unique names’ is
the number of distinct names of such parameters.
To answer these questions, we experiment with a collection o f web applications. For
each application, we go through the process suggested in Sec tion 3: We ﬁrst run the
WARLORDtool on the application with no customization. After a manua l study of the
warnings being produced, appropriate customization is add ed, if possible, to address
the false positives.
If any exploitable vulnerabilities are found after running the analysis again, this
time with the new customization, we ﬁx them manually using on e of the techniques
mentionedin Section 2.
Our experiments are based on 10 open-source web application s found on the web:
JSPChat1(the small chat application mentioned in Section 1), Hipergate8(a customer
resourcemanagementapplicationwrittenentirelyinJSP), Takatu9(alargetaxadmin-
istration system), Pebble10(awidelyusedbloggingapplication), Roller11(anotherblog-
ging application), JWMA12(a web mail application), JsForum13(a forum application),
JavaLibrary14(a book library management application), BodgeIt15(a web shop writ-
ten to demonstrate common security problems in web applicat ions), and WebGoat16
(another web application that has been made to demonstrate t ypical security prob-
lems, written by OWASP). The benchmarks were selected as the ﬁrst 10 applications
weencounteredthatusesomeformofclientstate andarebase donJava Servlets,JSP,
or Struts. Our prototype supports Struts 2 but not version 1, so we do not include the
fulllistofbenchmarksfromStanfordSecuriBench[Livshit s2005].Thebenchmarkson
8http://hipergate.sourceforge.net/
9http://takatu.sourceforge.net/
10http://pebble.sourceforge.net/
11http://roller.apache.org/
12http://jwma.sourceforge.net/
13http://sourceforge.net/projects/jsforum/
14http://sourceforge.net/projects/javalibrary/
15http://code.google.com/p/bodgeit/
16https://www.owasp.org/index.php/Category:OWASP_WebG oat_Project
17Writeof client-statevalue ’nickname’to applicationstat e
on line 23 of sukhwinder.chat.servlet.SaveInfoServlet
Trace:
sukhwinder.chat.servlet.SaveInfoServlet:
void doGet(HttpServletRequest,HttpServletResponse)
Fig. 11. Output from the WAR LORDtool for the JSPChat benchmark.
our list cover a variety of application kinds of differentsi ze, they are written by differ-
ent programmers, and they use different web frameworks. The TakatuandJsForum
projects do not appear to be active but represent interestin g snapshots of incomplete
web applications. Some characteristics of the benchmarks a re listed in Figure 10. The
column ’Client-state parameters’ shows the total number of client-state parameters
computed as/summationtext
p|Cin(p)|for all pages p. Although Cin(p)may in principle be inﬁnite,
each of the sets is ﬁnite and usually small. Note that client- state values appear in all
the benchmarks. The number of distinct names of the paramete rs,|/uniontext
pCin(p)|, shown
in the last column gives an indication of how many different k inds of client state that
occur.
7.1. Experiments
JSPChat .Theanalysisidentiﬁesusesof19 client-state parameters, andonly1 warn-
ing is produced about potential client-state manipulation vulnerability. The single
warningisshowninFigure11:ashintedinSection1,theappl icationispronetoatim-
ing attack since the values of the request variables are stor ed in ﬁelds on the servlet
object, which the analysis reveals. Since this is indeed sha red application state, such
a vulnerability falls within our characterization of clien t-state manipulation vulnera-
bilities. Notice that the analysis output includes a trace f rom the source to the sink,
which can make it easier to conﬁrm or dismiss the error by manu al inspection. If we
manually correct this error by changing the ﬁeld into a local variable, the analysis
ﬁnds another error: the application is also prone to a classi cal client-state manipula-
tion attack, since a malicious user may change the nickname request parameter and
consequently change the information for another user. This error can be corrected by
fetching the nickname from the session instead of a client-s tate parameter. After also
correcting this error, WAR LORDgives no more warnings. A manual inspection con-
ﬁrms that the remaining occurrences of client-state parame ters are indeed safe. No
customization is necessary for this application.
Hipergate .Client-state parameters are used massively in this web appl ication; in
fact,all client-speciﬁcvaluesarepassedaroundusinghid denﬁelds.Runningtheanal-
ysis yields 197 warnings. With 14 customizations, this numb er is broughtdown to 132
warnings, almost all of which are caused by client-state par ameter values that ﬂow
into parameterized database queries without any checks. We have inspected all of the
warnings, and many of them correspond to code that is vulnera ble to attacks, as ex-
plained in the following. The main source of false positives originates from a use of
randomly generated ID strings for database rows. Such strin gs are hard to guess and
we do not consider this as vulnerable. If we exclude warnings involving these random
strings, 71 warnings remain.
All in all, 40 of the warnings reveal exploitable client-sta te manipulation vulner-
abilities. One of the warnings reveals that a ﬁle can be read f rom the disk using a
ﬁlenameoriginatingfroma client-state parameterin wb_style_persist.jsp .Thispa-
rameter can be exploited to change ﬁles on the disk. Although the programmer has
carefully inserted authorization checks to ensure that the user should be granted ac-
18cesstothe pageinquestion, nochecksare madeforanyofthe c lient-state parameters,
and they can therefore be manipulated by the client. The tool also gives a warning on
the pagedocrename_store.jsp , which can be exploited to rename ﬁles. The program-
merhasinsertedachecktoensurethattheuserhasrightstor enametheﬁles,butthis
isperformedonanotherparameterthantheoneholdingtheﬁl ename,andanattacker
can therefore create an exploit that changes only the ﬁle nam e. Furthermore, the tool
emits 4 warnings for the page reference.jsp where parameters can be injected into
an SQL string. 1 warning on the page catusrs_store.jsp reveals that a client-state
parameter can give access to update permissions for any user , and 2 warnings reveal
a similar problem for catgrps_store.jsp .Similarly, 31 warningsin 18 other pagesre-
veal places where client-state values give direct access to the database. In all cases,
data is queried or changed in the database using a client-sta te parameter.
For the remaining 31 warnings, we found that they could not be exploited. In three
cases, the parameters control settings for querying the dat abase without affecting the
result,forexample,thenumberofrowsqueriedatatime.Ina dditionalthreecases,the
values are referencesto objects that are owned by the user an d changing these values
does not give access to new information. In the remaining cas es, values ﬂow to the
database API, but the queries are only used for logging clien t actions or for retrieving
data that is used for access control. The current customizat ion mechanism is not able
to express the precise behavior of SQL expressions that are e xecuted through calls
to the JDBC API, and therefore the analysis considers all suc h calls as sinks. The
analysis is able to classify 2,548 out of 2,680 uses of client -state parameters as safe.
Takatu.The analysis identiﬁes 1,840 client-state parameters. 184 warnings are is-
sued, all but 14 are caused by reading from the database using IDs that come from
hidden ﬁelds. These IDs are used for querying objects from th e database. After manu-
allyinspectingthewarnings,wecanseethat162 ofthemcanb eexploitedtochangeor
read data on the server. Other 8 warnings indicate places whe re values are read from
the database in ways that are not vulnerable, for example, fo r searching for values in
the database. The remaining 14 warnings indicate places whe re a client-state param-
eter holds the value of a log ﬂag that is used to query the datab ase but none of them
can be exploited. No customization is required for this appl ication.
Interestingly, this web application at multiple places ask s the user to conﬁrm the
deletion of an object. The ID of the object is stored in a hidde n ﬁeld that is not pro-
tected,so the client can deleteany objectof the same type by modifyingthe ID used as
objectreference.Theerrorsareeasilycorrected,forexam ple,bysigningthevulnerable
parametersand checking the signature whenthe parameter is sent back to the server.
Pebble.WARLORDidentiﬁes 22 uses of client-state parameters and initially pro-
duces 4 warnings. This web application uses a dispatcher, so all requests except those
toJSPpagesgothroughasingle servlet.The numberofclient -state parametersseems
small because of this structure, but the classes being dispa tched to make heavy use of
the client-state parameters.
Thewebapplicationstoresﬁlesonthedisksuchthateachblo ghasitsowndirectory,
and it uses the value of a parameter from a hidden ﬁeld to deter mine the name of
the ﬁle to save to, which is the cause of 2 warnings. However, e ach value used this
way is veriﬁed to be a child of the blog folder, so the folder st ructure ensures that
users cannot overwrite each other’s ﬁles. The two ﬁrst custo mization rules shown in
Figure 12 handle this check of the parent folder.
Only 1 warning is produced after the customization. It is cau sed by the page where
a new blog is added. This page uses an idparameter originating from a hidden ﬁeld
to set the database ID of the newly created blog and to create a directory for the ﬁles
belongingto the blog. The idparameter is veriﬁedto only contain letters, and another
19net.sourceforge.pebble.util.FileUtils.underneathRoo t(File,File):
Sanitizer for arg 2
net.sourceforge.pebble.domain.FileManager.isUnderne athRootDirectory(File):
Sanitizer for arg 1
net.sf.ehcache.Element.get(Serializable):
Not a sink
net.sourceforge.pebble.index.StaticPageIndex.getSta ticPage(String):
Not a sink
net.sourceforge.pebble.util.FileUtils.getContentTyp e(String):
Not a sink
Fig. 12. Customization rules for the Pebblebenchmark.
check ensures that the ID is not already in use. Together, the se two checks mean that
there are no exploitable vulnerabilities related to the 4 wa rnings. The safety depends
on a subtle invariant about the directory structure where ﬁl es are stored on the disk.
While this invariant is beyond what we can express with the cu stomization mecha-
nism, extracting the relevantcode into a separate method wo uld make the code easier
to read, less prone to become vulnerable as a result of future changes, and it would
become expressible as a sanitizer using the customization m echanism.
Roller.The developersof this web application have systematically reviewedthe code
for the class of vulnerabilities we are trying to detect. All client-state parameters are
protected with authorization checks that are well document ed in the code. Running
WARLORDinitiallyresultsin53warningsonthe53pages.Weadded14c ustomization
rules, which mainly describe information ﬂow for a few strin g manipulation functions
and information about queries of public information such as blog comments. Those
functions are part of the Apache Commons API, so these rules a re generally useful in
all applications that use this API.
Only 1 warning remains after adding these rules. That warnin g refers to a page
that allows blog comments to be deleted using a client-state parameter to identify
the blog comments. All comments belong to a blog, and user rig hts are deﬁned for
each blog. The page checks whether each comment belongs to th e blog and refuses
any attempt to delete comments on other blogs in a way that can not be modeled with
our customization mechanism. However, if the code were rewr itten slightly to use a
separate method to check the ownership directly, this metho d could be marked as a
sanitizer. That would also make it possible to check that fut ure changes to this code
would not create vulnerabilities, and it would make the code more readable.
JWMA.This web application acts as a frontend for an email server us ing the Java
Mail API, and it stores almost all data in the session state. I t has little shared appli-
cation state, but it does use client state.
The HTML view is generated through JSP pages and form data is h andled using
servlets.Thebehaviorofthereceivingservletisdetermin edbyoneoftwohiddenﬁelds,
actonandtodo.Thebehaviordependsonlyonimplicitinformationﬂowfrom thesetwo
parameters, and no warnings are issued in relation to them. I nspecting the use of the
parameter values manually does not reveal any vulnerabilit ies either.
With no customizations, WAR LORDproduces 3 warnings. Two of them are spurious
warnings related to reading and using the values of the clien t-state parameters paths
andcontact.id in the servletJwmaController . Request parameters are read using a
method on the class JwmaSession and WAR LORDis unable to analyze this precisely
enough to determine that these two parameters are not read by JwmaController .
20The third warning relates to the client-state parameter numbers, which is used for
moving and deleting messages in JwmaController . Through manual inspection we
have found that this parameter is not vulnerable, since it on ly allows manipulation
of data in the client’s own folder.
JsForum .This web application uses a combination of JSP pages for gene rating the
HTML view and Servlets for updating data in the database. The database connection
uses the standard JDBC API for accessing a MySQL database.
Client-state parameters are primarily used for storing dat abase identiﬁers. WAR-
LORDreveals that the programmershave not protected the applica tion against client-
state manipulationattacks. Withoutcustomization, WAR LORDproduces12 warnings,
allofwhichrelatetotheuseofdatabaseidentiﬁers.Inthes ervletAddThread ,theanal-
ysis warnsthat the client-state parameters lastThread_id andforum_id are stored in
an application state object. This happens because the servl et generates an SQL query
based on these parameters and stores the query string in a ﬁel d reachable from the
servlet class. The methods are not synchronized and another request might therefore
overridethe value before it is sent to the database. Other wa rnings reveal that clients
can change the values of forum_id andlastThread_id to post to a different forum
and to manipulate the identiﬁer of a newly created thread. Fu rthermore, the servlet
AddThread allows the client to post as a different user by changing the v alue of the
hidden ﬁeld named user.
Further inspection of the other pages reveals similar vulne rabilities in the servlets
ChangeMessage ,AddReply ,andAddForum .InDeleteForum ,however,theapplicationcode
checks that the client is an administrator beforedeleting a forum. We thereforedo not
consider that servlet to be vulnerable. The customization m echanism is not able to
express such a property. Of the 12 warnings, 11 corresponded to actual client-state
manipulation vulnerabilities. No customization was used.
JavaLibrary .ThisisasmallJSPapplicationformanagingbookreservatio nsandlists
ofuserswithvaryinglevelsofprivileges.WAR LORDdetects92client-stateparameters
in the application and deems 65 of them safe. Of the remaining 27 parameters, 22 are
read by the servlet FormProcess .
JavaLibrary uses a bean for representing all values related to users. This bean
is updated from client-state values when a user is added or ed ited. The JSP page
user_form.jsp is used for creating and editing users. Depending on the righ ts of the
user, the page preﬁlls the HTML form with hidden ﬁelds. The FormProcess does not
checkforclient-statemanipulation,anditisthereforepo ssibletomodifymanyofthese
parameterstogainprivilegessimilartothatofanadminist ratorwhencreatingoredit-
ing users. This accounts for 7 of the 22 warnings. Furthermor e, client-state manipula-
tion through other forms can be exploited to change reservat ion dates and due dates
for borrowed books and to borrow books for other users. All of the 22 parameters can
be exploited for attacks.
The remaining 5 warnings that are not related to FormProcess result from client-
state in JSP pages. According to comments in the code, state i s saved in these ﬁelds to
allow the client to return to the page later and complete the d ata entry. Similarly to
JSPChat , this creates a possibility of a timing attack, and in this ap plication, it also
allows clients to read values entered by other clients.
No customization was necessary for this web application.
BodgeIt .This web application was written as a benchmark for penetrat ion testing
tools. It contains what the authors call “hidden (but unprot ected) content” and “inse-
cure object references”, which are within our deﬁnition of c lient-state vulnerability. It
thereforeserves well as a test for our static analysis.
21home.jsp product.jsp{prodid}{prodid}
basket.jsp{price}
{prodid}contact.jsp{anticsrf, Guest user, (Any name)}advanced.jsp{q}
Fig. 13. An excerpt of the page graph for BodgeIt showing the nodes and edges that involve client state.
com.thebodgeitstore.util.AES.hexStringToByteArray(j ava.lang.String):
Flow from parameter 1 to return value
com.thebodgeitstore.util.AES.decryptCrt(java.lang.S tring):
Not a sink (the method returns a safe value)
Fig. 14. Customization rules for the BodgeIt benchmark.
Figure 13 shows the part of the page graph for BodgeIt that involves client state.
Beforecustomization, WAR LORDreports5 warnings.We addedthe twocustomization
rules shown in Figure 14. They relate to the use of an encrypte dtoken incontact.jsp
for protecting against cross-site request forgery. One war ning refers to a parameter
namedprodidintheJSPpageproduct.jsp .ThevalueoriginatesfromaURLparame-
terandisusedtoquerythedatabaseforaproductwiththecor respondingdatabaseID.
While this page demonstrates the possibility for client-st ate manipulation, changing
the parameter does not give the client access to additional i nformation. Consequently,
there is in fact no vulnerability in this case. Another warni ng, which originates from
the URL parameter typeid, is also used for a database query. Manipulating this pa-
rameter does not give access to new information either.
In the JSP page contact.jsp , WAR LORDdetects a hidden ﬁeld. Rather unusually,
the name of this hidden ﬁeld can be arbitrary, because it is se t to the name of the
current user. This causes WAR LORDto consider all parameters in the successor page,
whichiscontact.jsp itself,asclient-stateparameters,whichresultsinafals epositive
when storing the value of the comments parameter. Although this warning does not
indicate a possible client-state manipulation vulnerabil ity, it reveals the possibility of
a name clash if a user is registered with the name “ comments ”.
The JSP pagebasket.jsp page places an item in a shopping basket along with the
price of the item. WAR LORDgives a warning for the productid parameter. The client
is able to arbitrarily change this parameter to add any item t o the basket, however,
we classify this as another false positive because the clien t is already able to add any
item to the basket without client-state manipulation. The i tem price is stored in a
hiddenﬁeldcalled price,butthisﬁeldis neverread,so theusercannotgain anyextra
privileges by changing its value, and WAR LORDcorrectly yields no warning in this
case.
In conclusion, weﬁnd that thereare, surprisingly,no explo itableclient-state manip-
ulation vulnerabilities in this web application.
22WebGoat .We have analyzed a single servlet in this web application. Th e purpose of
theservlet,whichusesasinglehiddenﬁeld,istodemonstra tevulnerabilitiesofexactly
the kind we want to detect. Unlike the other benchmarks, this application generates
output using a custom DOM-like framework and we decided to ma nually create the
set of parameters that may hold client-state values.
Perhaps surprisingly, our tool reports 0 warnings for this a pplication. The reason
is that the servlet does not use the input variable for anythi ng else than selecting a
message to send back to the client. This usage does not violat e any of the safe usages
presented in Section 2 and we therefore conclude that while t he illustrative servlet
of course mimics the behavior of a vulnerable piece of server code, it is actually not
vulnerable to any attack. A manual inspection of the code con ﬁrms that the client is
indeed not able to change the shared application state in any way by changing the
value of the hidden ﬁeld.
As an additional experiment related to Q1, we test whether th e client-state analy-
sis component (Section 4) is really necessary. If we disable that component and run
WARLORDin a mode where all parameters are conservatively assumed to contain
client state, we observe a drastic increase in the number of f alse positives, even with
all customization enabled. As an example, in JSPChat from Figure 1, this will treat
theemailparameter as client state, such that line 41 becomes a source for the infor-
mation ﬂow analysis and a spurious vulnerability warning is triggered on line 50 (in
the version where the timing vulnerability has been ﬁxed by c hanging the ﬁelds into
localvariables, asdiscussedinSection7.1). Fortheother benchmarks,hundredsofad-
ditional warnings appear without revealing any new actual c lient-state manipulation
vulnerabilities,which demonstratesthat the clientstate analysiscomponentis useful.
7.2. Summary of Results
Figure 15 summarizes the benchmark results from the previou s section. The ﬁrst col-
umn,’Client-stateparameters’,isthesameasinFigure10. Thenextcolumnsshowthe
number of warningsbefore customization, the number of cust omization rules, and the
number of warnings after customization. The tool produces a t most one warning for
each of the client-state parameters from the ﬁrst column (ho wever,each warning may
contain multiple traces from sources to sinks). The next col umn, ’Exploitable’, shows
how many of the warnings we could manually verify to be exploi table by malicious
clientsperformingclient-state manipulation attacks. Th e column’Safe client-state pa-
rameters’ shows the number of client-state parameters that the analysis after cus-
tomizationdeterminesnotto be vulnerable.The ﬁnal column showsthe time spentfor
thefullanalysis.Thenumbersinparenthesesshowtheresul tsaftergroupingtogether
datathatinvolveparametersofthesamename,whichindicat esthatthewarningsand
vulnerabilities involve many differentuses of client stat e.
The tests have been performed on a 2.4GHz Core i5 laptop runni ng OS X. The JVM
wasgiven1GBofheapspaceforeachbenchmark.Thetimeandme morywasprimarily
used by the Soot framework for loading classes and performin gthe pointer analysis.
With this, we are able to answer the research questions:
Q1: A manual inspection of the application code conﬁrms that the client-state anal-
ysis succeeds in ﬁnding all client-state value sources. Thi s amounts to a total of
4,802 client-state parameters. The analysis determines th at 4,437 (92%) of those
parameters are safe, that is, they are not presentin any warn ings. Moreover,after
customization, 241 (66%) of the 365 warnings that are produc edin total reveal ex-
ploitable vulnerabilities. The false positives are not eve nly distributed among the
benchmarks, and they are concentrated on a small number of di fferent parameter
23Client-stateparameters
Warnings beforecustomization
Customizationrules
Warnings aftercustomization
Exploitable
Safe client-stateparameters
Time
JSPChat 19 10111830 s
(3) (1) (0) (1)(1) (2)
Hipergate 2,680 197 14132402,548116 m
(264) (99) (14) (75)(30)(189)
Takatu 1,840 184 01841621,656 20 m
(31) (10) (0) (9)(9)(22)
Pebble 22 45102110 m
(11) (4) (5) (1)(0)(10)
Roller 865314 10854 m
(27) (1)(14) (1)(0)(26)
JWMA 40 3030373 m
(10) (3) (0) (3)(0) (7)
JsForum 1412 01211 21 m
(8) (7) (0) (7)(7) (1)
JavaLibrary 9227 02727652 m
(35) (22) (0)(22)(22) (13)
BodgeIt 8524042 m
(8) (5) (2) (4)(0) (4)
WebGoat 10000130 s
(1) (0) (0) (0)(0) (1)
Fig. 15. Summary of experimental results.
names.Theexperimentsalsodemonstratethattheclientsta teanalysiscomponent
is critical for the analysis precision.
Q2: Based onthe warningsgivenby thetool, especially thetr ace information,it wasin
each case possible for us to quickly determine whether it ind icated a vulnerability
or not. The entire process of classifying the warnings and ad ding customization
rules for all 10 benchmarks took one person less than a day, de spite having no
prior knowledgeof the benchmark code.
Q3: Adding customization rules in many cases reduced the num ber of spurious warn-
ingsconsiderably.Asdiscussedfortheindividualbenchma rks,theremainingcases
typically involve subtle, undocumented invariants. Moreo ver, if allowing simple
refactorings, such as extracting a safety check to a separat e method, most of these
cases could be captured within the existing customization f ramework. In the case
ofHipergate ,however,some uses of client state are safe for reasonsthat go beyond
the currentcapabilities ofcustomization. The decisionme ntionedin Section 3 that
the analysis ignores condition 5 from Section 2 results in a f ew false positives in
BodgeIt,Hipergate , andTakatu.
Q4: The tool analyzes between 10 and 200 pages per minute. Pag es can be analyzed
individually, so when a programmer is modifying the applica tion, it is possible to
run the tool only on pages that have changed.
248. RELATED WORK
Client-state manipulation vulnerabilities, in particula r the kind involving hidden
ﬁelds, have been known for many years, as described in Sectio ns 1 and 2. Likewise,
automated techniques for protecting against security vuln erabilities in web applica-
tions have a long history. Here we explain the connections be tween our approach and
the most closely related alternatives that have been propos ed.
8.1. Static Analysisof Web Applications
The ﬁrst phase of our analysis that identiﬁesthe client-sta te parameters applies tech-
niquesfromour earlier work on static analysis of HTML outpu tofJava-based web ap-
plications [Kirkegaard and Møller 2006; Møller and Schwarz 2011]. The analysis tools
WAM,WAM-SE,WAIVE,andASCENDbyHalfondetal.[2009;2008; 2012]checkthat
the names and possible values of HTTP request parameters in d ynamically generated
HTML documentsare consistent with the program code that rec eivesthe parameters.
As in WAR LORD, this involves static analysis of the dynamically generate d HTML
documents and of the dataﬂow of HTTP request parameters in th e server code; how-
ever, those tools do not identify which parameters contain c lient state, for example,
originating from hidden ﬁelds.
Anessentialconstituentofourapproachistheobservation thatclient-statemanipu-
lationvulnerabilitiesarecorrelatedtoinformationﬂowf romclientstate toapplication
state. Togetherwith automatic inferenceofclient state (S ection4) and shared applica-
tionstate(Section5),thisallowsustodetectlikelyerror slargelywithoutrequiringthe
programmers to provide any speciﬁcations. Some applicatio n speciﬁc customization is
required though, as seen in Section 7. For future work, it may be interesting to apply
probabilistic speciﬁcation inference [Livshits et al. 200 9] to automate this phase.
The WebSSARI tool by Huang et al. [2004] pioneered the use of s tatic information
ﬂowanalysistoenforcewebapplicationsecurity,andnumer ousresearchershavesince
followedthatpath,asdiscussedinthefollowing.WebSSARI wasdesignedforintrapro-
ceduraltaint analysis of PHP programswithoutconsidering client-state manipulation
vulnerabilitiesspeciﬁcally.Relatedtechniquesfordete ctinginjectionvulnerabilitiesin
PHP programs include the bottom-up analysis by Xie and Aiken [2006] and the top-
down ﬂow-sensitive dataﬂow analysis used in the Pixy tool by Jovanovic et al. [2010].
The PQL language by Martin et al. [2005] has been designed to s upport succinct
speciﬁcation of information ﬂow queries. Their notion of de rivation descriptors corre-
sponds to our use of customization rules. Their static analy sis is based on a context-
sensitive but ﬂow-insensitive pointer alias analysis usin g Datalog. In principle, the
information ﬂow that we consider is expressible within PQL, but we found it easier
for our proof-of-concept implementation to use the simple i nformation ﬂow analysis
described in Section 6. Livshits and Lam [2005] have used PQL for specifying and im-
plementing a range of vulnerability analyses. Hidden ﬁeld m anipulation is among the
list of vulnerabilities they consider. However, their tech niques does not perform any
client state analysis (Section 4) or shared application sta te analysis (Section 5); in-
stead they use a ﬁxed set of source and sink descriptors that c annot precisely identify
the hidden ﬁeldsor the operationsthat involveshared appli cation state. PQL has also
been combined with explicit state model checking using Java PathFinder for detect-
ing injection vulnerabilities [Martin and Lam 2008; Lam et a l. 2008]. The TAJ tool by
Tripp et al. [2009] has similar goals as that of Livshits and L am, but uses an alterna-
tive technique called hybrid thin slicing for obtaining a pr ecise and scalable analysis.
Other related work uses string analysis for detecting web ap plication injection vul-
nerabilities. The AMNESIA tool by Halfond and Orso [2005] ap plies string analysis to
build models of legitimate SQL queries and then uses these mo dels for runtime mon-
25itoring. Wassermann and Su [2007] similarly use string anal ysis to reason about dy-
namically constructed SQL queries with fragments that orig inate from HTTP request
parameters and then check whether those fragments may alter the syntactic struc-
ture of the queries, all using static analysis. In later work , Wassermann and Su [2008]
use the same string analysis technique to detect whether unt rusted input from HTTP
request parameters may ﬂow to the generated HTML documents a nd thereby inject
JavaScript code. In comparison, our primary use of string an alysis is for approximat-
ingtheHTMLoutputtobeabletolocateclient-stateparamet ers,whereaswetrackthe
HTTP request parameters with a simple information ﬂow analy sis without modeling
their possible values.
Balzarotti et al. [2007] propose a pragmatic approach for ﬁn ding stored SQL in-
jection and XSS vulnerabilities that arise when a page store s user input in applica-
tion state and another page later reads and uses this data. Ap plication state is recog-
nized using signatures of database API methods without cons idering potential alias-
ing. Their tool performs a simple scan of the application sou rce code to detect links
between pages and tracks the ﬂow of user input values using a m odel-checking ap-
proach with a limited search space.
Detection of access control vulnerabilities with static an alysis has been studied by
Sun et al. [2011], among others. Their approach uses string a nalysis to statically con-
struct sitemaps for different user roles, which are then com pared to look for inconsis-
tent access control. These sitemaps are reminiscent of our p age graphs (Section 4) but
do not consider client-state parameters.
Providing comprehensive support for diverse web applicati on frameworks, such as
Java Servlets, JSP, and Struts, is a challenging endeavor. A general framework, F4F,
hasbeenproposedbySridharanetal.[2011];however,wehav efoundthatitisnotsuf-
ﬁciently ﬂexible for our setting, in particular for the clie nt-state identiﬁcation phase.
Still, the ideas in F4F may be adapted in future work to enable support for additional
web application frameworks.
8.2. Dynamic Techniquesfor VulnerabilityDetection
The approach of using MACs to protect against client-state m anipulation attacks that
we discussed in Section 2 can be implemented with a generic se rvlet ﬁlter that in-
tercepts all HTML documents generated by the application at runtime and all HTTP
requests that are sent by the clients, without modifying the web application code. For
every use of client state in the HTML documents, an additiona l hidden ﬁeld or query
parametercontaining the MAC is automatically inserted. Wh eneveran HTTP request
is received from a client, the MAC check is performed on the ap propriate request pa-
rameters. Scott and Sharp [2002] exempliﬁed this as part of a more general security
gateway.Givenamanuallyconstructedsecuritypolicy,the irgatewaycan,forexample,
automatically attach MACs to hiddenﬁelds. Using such a secu rity ﬁlter can be viewed
as an alternative or supplementto manually eliminating the vulnerabilities by appro-
priately patching the application source code. In contrast , the idea in our approach is
to inform the programmer—using static analysis of the appli cation source code—that
protection may be inadequate.
It is possible to combine the ﬁlter and analysis approaches: A security ﬁlter needs
to be conﬁgured with information about which ﬁelds and param eters contain client
state that shouldnotbe manipulated,andthisinformationi spreciselywhatourstatic
analysis can provide. It is of course important that the clie nt-state analysis is precise
enough to correctly distinguish between parameters that ca rry client state and ones
that do not. It is less critical that the information ﬂow anal ysis is able to correctly dis-
tinguish between safe and unsafe uses of client state. Howev er, to avoid the overhead
26ofgeneratingandcheckingMACsforparametersthatarealre adysafebyothermeans,
it is neverthelessuseful that also this analysis component is as precise as possible.
Numerousothertechniqueshavebeendevelopedforpreventi ngwebapplicationvul-
nerabilities at runtime, in some cases leveraging static an alysis to increase precision,
although without focusing on client-state manipulation vu lnerabilities in particular.
Dynamic taint analysis has been used for detecting various k inds of attacks, includ-
ing hidden ﬁeld tampering, for example, by Haldar et al. [200 5]. The WASP tool by
Halfondetal. [2008]usesamoreﬁne-grainedtaintanalysis totrack stringsthatorigi-
natefromclientinputandmaybeinjectedinSQLqueries.Thi shasbeenusedtogether
with the static analysis tool WAM that infers web applicatio n inferfaces to automate
penetration testing [Halfond et al. 2011].
Another variant of attacks involving tampering of form para meters is to bypass
client-side input validation or manipulate client state, w hich is the focus of several
tools including NoTamper, WAPTEC, and TamperProof [Bisht e t al. 2010; Bisht et al.
2011;Skrupskyetal.2013].NoTamperandWAPTECdynamicall yinferconstraintson
HTTPparametersfromtheHTML andJavaScriptcode.Paramete rvaluesthatviolate
theseconstraintsarethensubmittedtotheserver,andthes erver-sideinputvalidation
is then tested by comparing server response pages that are ge nerated by submitting
thetamperedparameterstoresponsepagesthatoriginatefr ombenigninput.Tamper-
Proof is a ﬁlter-based variant similar to Scott and Sharp’s.
The black-box vulnerability scanning technique by Doupé et al. [2012] uses fuzzing
based ondynamicallyinferredstate machines, whichresemb leour useof pagegraphs.
This approach can in principle also detect client-state man ipulation vulnerabilities,
althoughthatisnotexplicitlythetargetoftheirwork.The Waler toolbyFelmetsgeret
al. [2010]usesdynamicexecutionto inferlikely speciﬁcat ionsoftheintendedprogram
behavior followed by symbolic execution to detect violatio ns of those speciﬁcations.
Among their examples is a client-state manipulation vulner ability, which is found as
a violation of a proposed invariant about the value of a hidde n ﬁeld. In comparison,
we proposea fully static approach that directly considerst he ﬂow of client state in the
application code.
Finally, we note that several commercial tools are capable o f detecting security vul-
nerabilitiesin web applications. Accordingto a 2007 IBM wh ite paper[IBM 2007], the
AppScan tool is capable of detecting vulnerabilities invol ving hidden ﬁeld manipula-
tion and parameter tampering. The latest version uses techn iques from TAJ [Tripp
et al. 2009]; however,we have been unable to performa proper comparison and obtain
further information about the techniques applied by AppSca n. Microsoft’s CAT.NET17
also uses static information ﬂow analysis, but it cannot det ect client-state manipula-
tion vulnerabilities without detailed speciﬁcations prov ided by the user. Other com-
mercial tools include NTOSpider18from NT OBJECTives, WebInspect19from Forti-
fy/HP, and CodeSecure20and HackAlert21from Armorize. To our knowledge, most of
these tools (with the exception of CodeSecure, which is deve loped from WebSSARI)
employ crawling [Doupé et al. 2010; Bau et al. 2010], not stat ic analysis. We believe
static analysis can be a promising supplement to dynamic app roaches, as it may pro-
vide better coverage of the web application source code.
17http://blogs.msdn.com/b/securitytools/archive/2010/ 02/04/cat-net-2-0-beta.aspx
18http://www.ntobjectives.com/ntospider
19https://www.fortify.com/products/web_inspect.html
20http://armorize.com/index.php?link_id=codesecure
21http://armorize.com/index.php?link_id=hackalert
279. CONCLUSION
We have demonstrated that it is possible to provide tool supp ort that can effectively
helpprogrammerspreventclient-statemanipulationvulne rabilitiesinwebapplication
code. The static analysis we have presented is capable of pre cisely identifying client
state, in particular, state stored in hidden ﬁelds, and help distinguishing between safe
and unsafe use of such state. With WAR LORD, our prototype implementation of the
analysis, we quickly discovered 241 exploitable weaknesse s in 10 web applications.
The analysis has high precision: after customization, 66% o f the warnings revealed
vulnerabilities.
Ourexperimentsalsoindicatepotentialforimprovements. Speciﬁcally,althoughan-
alyzing the Hipergate benchmark revealed a large number of weaknesses, it also re-
sulted in some false positives, which originate from a small group of client-state pa-
rameters.Itappearsthatmanyofthesefalsepositivescanb eavoidediftheanalysisis
extendedto also infer the provenanceof the client-state va lues, which can be a subject
for future work. It may also be worthwhile to extend the techn ique to reason about
client state stored in cookies.
REFERENCES
ADVOSYS CONSULTING . 2000. Preventing HTML form tampering. http://advosys.ca/tips/form-
tampering.html .
BALZAROTTI , D., C OVA, M., F ELMETSGER , V.,ANDVIGNA, G. 2007. Multi-module vulnerability analysis
of web-based applications. In Proc. 2007 ACM Conference on Computer and Communications Se curity.
BAU, J., BURSZTEIN ,E., GUPTA, D.,ANDMITCHELL ,J. C.2010.Stateof theart: Automatedblack-box web
application vulnerability testing. In Proc. 31st IEEE Symposium on Security and Privacy .
BISHT,P.,HINRICHS ,T.,SKRUPSKY ,N.,BOBROWICZ ,R.,ANDVENKATAKRISHNAN ,V. N.2010.NoTamper:
automatic blackbox detection of parameter tampering oppor tunities in web applications. In Proc. 17th
ACM Conference on Computer and Communications Security .
BISHT,P.,HINRICHS ,T.,SKRUPSKY ,N.,ANDVENKATAKRISHNAN ,V.N.2011.WAPTEC:whiteboxanalysis
of web applications for parameter tampering exploit constr uction. In Proc. 18th ACM Conference on
Computer and Communications Security .
BRUSSIN, D. I. 1998. A white paper analyzing the MSC hidden form ﬁeld w eb site vulnerability. Miora
Systems Consulting.
CERF, M.ANDSHULMAN , A. 2004. How safe is it out there? http://www.klab.caltech.edu/~moran/files/
safeout/ .
CHRISTENSEN ,A. S.,M ØLLER,A.,ANDSCHWARTZBACH ,M. I.2003.Preciseanalysisofstringexpressions.
InProc. 10th International Static Analysis Symposium .
DENNING , D. E. ANDDENNING , P. J. 1977. Certiﬁcation of programs for secure informatio n ﬂow.Commu-
nications of the ACM 20, 7, 504–513.
DOUPÉ, A., CAVEDON ,L., KRUEGEL ,C.,ANDVIGNA,G.2012.Enemyof thestate:A state-awareblack-box
vulnerability scanner. In Proc. 21st USENIX Security Symposium .
DOUPÉ, A., C OVA, M.,ANDVIGNA, G. 2010. Why Johnny can’t pentest: An analysis of black-box web
vulnerability scanners. In Proc. 7th International Conference on Detection of Intrusi ons and Malware,
and Vulnerability Assessment .
FELDTHAUS , A.ANDMØLLER, A. 2009. The Big Manual for the Java String Analyzer . Department of Com-
puter Science, Aarhus University.
FELMETSGER , V., CAVEDON , L., K RUEGEL , C.,ANDVIGNA, G. 2010. Toward automated detection of logic
vulnerabilities in web applications. In Proc. 19th USENIX Security Symposium .
HALDAR,V.,CHANDRA ,D.,ANDFRANZ, M.2005.DynamictaintpropagationforJava.In Proc.21stAnnual
Computer Security Applications Conference .
HALFOND , W. G. J. 2012. Automated checking of web application invoca tions. In Proc. 23rd IEEE Interna-
tional Symposium on Software Reliability Engineering .
HALFOND , W. G. J., A NAND, S.,ANDORSO, A. 2009.Precise interface identiﬁcationto improve testi ng and
analysis of web applications. In Proc. 18th International Symposium on Software Testing and Analysis .
HALFOND , W. G. J., C HOUDHARY , S. R., ANDORSO, A. 2011. Improving penetration testing through static
and dynamic analysis. Software Testing, Veriﬁcation & Reliability 21, 3, 195–214.
28HALFOND ,W. G.J. ANDORSO,A.2005.AMNESIA:Analysisandmonitoringforneutralizin gSQL-injection
attacks. In Proc. 20th IEEE/ACM International Conference on Automated Software Engineering .
HALFOND , W. G. J. ANDORSO, A. 2008.Automatedidentiﬁcationof parameter mismatches inweb applica-
tions. In Proc. 16th ACM SIGSOFT International Symposium on Foundati ons of Software Engineering .
HALFOND , W. G. J., O RSO, A.,ANDMANOLIOS , P. 2008. WASP: Protecting web applications using positive
tainting and syntax-aware evaluation. IEEE Transactions on Software Engineering 34, 1, 65–81.
HUANG, Y.-W., Y U, F., HANG, C., TSAI, C.-H., L EE, D.-T., ANDKUO, S.-Y. 2004. Securing web application
code by static analysisand runtime protection. In Proc. 13th International World WideWeb Conference .
IBM. 2007. The dirty dozen: preventing common application- level hack attacks. ftp://ftp.software.ibm.
com/software/rational/web/whitepapers/r_wp_dirtydoz en.pdf.
INTERNET SECURITY SYSTEMS. 2000. Form tampering vulnerabilities in several web-base d shopping cart
applications. ISS E-Security Alert, http://www.iss.net/threats/advise42.html .
JOVANOVIC ,N., K RUEGEL , C.,ANDKIRDA,E. 2010. Staticanalysisfor detecting taint-stylevulner abilities
in web applications. Journal of Computer Security 18, 5, 861–907.
KIRKEGAARD , C.ANDMØLLER, A. 2006. Static analysis for Java Servlets and JSP. In Proc. 13th Interna-
tional Static Analysis Symposium .
LAM, M. S., M ARTIN,M. C., L IVSHITS ,V. B., ANDWHALEY, J. 2008. Securing web applications withstatic
and dynamicinformation ﬂowtracking. In Proc. ACMSIGPLAN Symposium onPartial Evaluation and
Semantics-based Program Manipulation .
LIVSHITS , B. 2005. Deﬁning a set of common benchmarks for web applicat ion security. In Workshop on
Deﬁning the State of the Art in Software Security Tools .
LIVSHITS , V. B. ANDLAM, M. S. 2005. Finding security vulnerabilities in Java appli cations with static
analysis. In Proc. 14th USENIX Security Symposium .
LIVSHITS , V. B., N ORI, A. V., R AJAMANI , S. K., ANDBANERJEE , A. 2009. Merlin: speciﬁcation inference
for explicit information ﬂow problems. In Proc. ACM SIGPLAN Conference on Programming Language
Design and Implementation .
MARTIN, M. C. ANDLAM, M. S. 2008. Automatic generation of XSS and SQL injection at tacks with goal-
directed model checking. In Proc. 17th USENIX Security Symposium .
MARTIN,M. C., L IVSHITS ,V. B., ANDLAM, M. S.2005.Finding application errors and security ﬂawsus ing
PQL: a program query language. In Proc. 20th Annual ACM SIGPLAN Conference on Object-Oriente d
Programming, Systems, Languages, and Applications .
MØLLER, A.ANDSCHWARZ , M. 2011. HTML validation of context-free languages. In Proc. 14th Interna-
tional Conference on Foundations of Software Science and Co mputation Structures .
MORAN, L. 2011. How Citigroup hackers broke in ’through the front d oor’ using bank’s website.
http://www.dailymail.co.uk/news/article-2003393/How -Citigroup-hackers-broke-door-using-
banks-website.html .
OPENWEBAPPLICATION SECURITY PROJECT.2010. OWASP top 10. https://www.owasp.org/ .
SCHOLTE ,T., BALZAROTTI ,D.,ANDKIRDA,E. 2011.Quovadis?a studyof the evolutionof inputvalidat ion
vulnerabilities in web applications. In Proc. 15th International Conference on Financial Crypto .
SCOTT, D.ANDSHARP, R. 2002. Abstracting application-level web security. In Proc. 11th International
World Wide Web Conference .
SKRUPSKY , N., B ISHT, P., HINRICHS , T., VENKATAKRISHNAN ,V. N., ANDZUCK, L. D. 2013. TamperProof:
a server-agnostic defense for parameter tampering attacks on web applications. In Proc. 3rd ACM Con-
ference on Data and Application Security and Privacy .
SRIDHARAN ,M., A RTZI, S., PISTOIA, M., G UARNIERI ,S., TRIPP, O.,ANDBERG, R. 2011. F4F: Taint anal-
ysis of framework-based web applications. In Proc. 26th ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications .
SUN, F., XU, L.,ANDSU, Z. 2011. Static detection of access control vulnerabiliti es in web applications. In
Proc. 20th USENIX Security Symposium .
TRIPP,O.,PISTOIA,M., F INK, S. J., S RIDHARAN ,M.,ANDWEISMAN,O.2009.TAJ:effective taintanalysis
of web applications. In Proc. ACM Conference on Programming Language Design and Imp lementation .
VALLEE-RAI, R., H ENDREN , L., SUNDARESAN , V., LAM, P., GAGNON, E.,ANDCO, P. 1999. Soot – a Java
optimization framework. In Proc. IBM Centre for Advanced Studies Conference . IBM.
WASSERMANN ,G.ANDSU, Z. 2007.Soundand precise analysisof web applications for injectionvulnerabil-
ities. In Proc. 28th ACM SIGPLAN Conference on Programming LanguageD esign and Implementation .
WASSERMANN , G.ANDSU, Z. 2008. Static detection of cross-site scripting vulnera bilities. In Proc. 30th
International Conference on Software Engineering .
29XIE,Y.ANDAIKEN,A.2006.Staticdetectionof securityvulnerabilitiesins criptinglanguages.In Proc. 15th
USENIX Security Symposium .
ZDNET. 2001. New e-rip-off maneuver: Swapping price tags. http://www.zdnetasia.com/
new-e-rip-off-maneuver-swapping-price-tags-21187583 .htm.
30