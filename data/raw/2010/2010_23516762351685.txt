To What Extent Could We Detect Field Defects?
An Empirical Study of False Negatives in Static Bug Finding T ools
Ferdian Thung1, Lucia1, David Lo1, Lingxiao Jiang1,
Foyzur Rahman2, and Premkumar T. Devanbu2,
1Singapore Management University, Singapore
2University of California, Davis, USA
{ferdianthung,lucia.2009,davidlo,lxjiang}@smu.edu.s g,
{mfrahman,ptdevanbu}@ucdavis.edu
ABSTRACT
Software defects can cause much loss. Static bug-ﬁnding
tools are believed to help detect and remove defects. These
tools are designed to ﬁnd programming errors; but, do they
in fact help prevent actual defects that occur in the ﬁeld
and reported by users? If these tools had been used, would
they have detected these ﬁeld defects, and generated warn-
ings that would direct programmers to ﬁx them? To answer
these questions, we perform an empirical study that investi -
gates the eﬀectiveness of state-of-the-art static bug ﬁndi ng
tools on hundreds of reported and ﬁxed defects extracted
from three open source programs: Lucene, Rhino, and As-
pectJ. Our study addresses the question: To what extent
could ﬁeld defects be found and detected by state-of-the-ar t
static bug-ﬁnding tools? Diﬀerent from past studies that are
concerned with the numbers of false positives produced by
such tools, we address an orthogonal issue on the numbers
of false negatives. We ﬁnd that although many ﬁeld defects
could be detected by static bug ﬁnding tools, a substantial
proportion of defects could not be ﬂagged. We also analyze
the types of tool warnings that are more eﬀective in ﬁnding
ﬁeld defects and characterize the types of missed defects.
Categories and Subject Descriptors
D.2.5 [ Testing and Debugging ]: Debugging aids/Testing
tools
General Terms
Experimentation, Measurement, Reliability
Keywords
Static bug-ﬁnding tools, ﬁeld defects, false negatives
1. INTRODUCTION
Bugs are prevalent in many software systems. The Na-
tional Institute of Standards and Technology (NIST) has
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE ’12, September 3–7, 2012, Essen, Germany
Copyright 12 ACM 978-1-4503-1204-2/12/09 ...$15.00.estimated that bugs cost the US economy billions of dollars
annually [47]. Bugs are not merely economically harmful;
they can also harm life & property when mission critical sys-
tems malfunction. Clearly, techniques that can detect and
reduce bugs would be very beneﬁcial. To achieve this goal,
many static analysis tools have been proposed to ﬁnd bugs.
Static bug ﬁnding tools, such as FindBugs [28], JLint [5],
and PMD [14], have been shown to be helpful in detecting
many bugs, even in mature software [8]. It is thus reason-
able to believe that such tools are a useful adjunct to other
bug ﬁnding techniques such as testing and inspection.
Although static bug ﬁnding tools are eﬀective in some set-
tings, it is unclear whether the warnings that they generate
are really useful. Two issues are particularly important to
be addressed: First, many warnings need to correspond to
actual defects that would be experienced and reported by
users. Second, many actual defects should be captured by
the generated warnings. For the ﬁrst issue, there have been
a number of studies showing that the numbers of false warn-
ings (or false positives) are too many, and some have pro-
posed techniques to prioritize warnings [23–25, 43]. While
the ﬁrst issue has received much attention, the second is-
sue has received less. Many papers on bug detection tools
just report the number of defects that they can detect. It
is unclear how many defects are missed by these bug de-
tection tools. While the ﬁrst issue is concerned with false
positives, the second focuses on false negatives. We argue
that both issues deserve equal attention as both have impact
on the quality of software systems. If false positives are no t
satisfactorily addressed, this would make bug ﬁnding tools
unusable. If false negatives are not satisfactorily addres sed,
the impact of these tools on software quality would be min-
imal. On mission critical systems, false negatives may even
deserve more attention. Thus, there is a need to investigate
the false negative rates of such tools on actual ﬁeld defects .
Our study tries to ﬁll this research gap by answering the
following research question, and we use the term “bug” and
“defect” interchangeably both of which refer to errors or
ﬂaws in a software:
To what extent could state-of-the-art static bug ﬁnding
tools detect ﬁeld defects?
To investigate this research question, we make use of abun-
dant data available in bug-tracking systems and software
repositories. Bug-tracking systems, such as Bugzilla or JI RA,
record descriptions of bugs that are actually experienced a nd
reported by users. Software repositories contain informat ion
on what code elements get changed, removed, or added atPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
50
diﬀerent periods of time. Such information can be linked to-
gether to track bugs and when and how they get ﬁxed. JIRA
has the capability to link a bug report with the changed code
that ﬁxes the bug. Also, many techniques have been em-
ployed to link bug reports in Bugzilla to their correspondin g
SVN/CVS code changes [19,50]. These data sources provide
us descriptions of actual ﬁeld defects and their treatments .
Based on the descriptions, we are able to infer root causes
of defects (i.e., the faulty lines of code) from the bug treat -
ments. To ensure accurate identiﬁcation of faulty lines of
code, we perform several iterations of manual inspections
to identify lines of code that are responsible for the defect s.
Then, we are able to compare the identiﬁed root causes with
the lines of code ﬂagged by static bug ﬁnding tools, and to
analyze the proportion of defects that are missed or capture d
by the tools.
In this work, we perform an exploratory study with three
state-of-the-art static bug ﬁnding tools, FindBugs, PMD,
and Jlint, on three reasonably large open source Java pro-
grams, Lucene, Rhino, and AspectJ. Lucene, Rhino, and
AspectJ have 58, 35, and 9 committers respectively1. We
use bugs reported in JIRA for Lucene version 2.9, and the
iBugs dataset provided by Dallmeier and Zimmermann [19]
for Rhino and AspectJ. Our manual analysis identiﬁes 200
real-life defects that we can unambiguously locate faulty
lines of code. We ﬁnd that many of these defects could
be detected by FindBugs, PMD, and JLint, but a number
of them remain undetected.
The main contributions of this work are:
1. We examine the number of real-life defects missed by
various static bug ﬁnding tools, and evaluate the tools’
performance in terms of their false negative rates.
2. We investigate the warning families in various tools
that are eﬀective in detecting actual defects.
3. We characterize actual defects that could not be ﬂagged
by the static bug ﬁnding tools.
The paper is structured as follows. In Section 2, we present
introductory information on various static bug ﬁnding tool s.
In Section 3, we present our experimental methodology. In
Section 4, we present our empirical ﬁndings and discuss in-
teresting issues. In Section 5, we describe related work. We
conclude with future work in Section 6.
2. BUG FINDING TOOLS
In this section, we ﬁrst provide a short survey of diﬀerent
bug ﬁnding tools that could be grouped into: static, dy-
namic, and machine learning based. We then present the
3 static bug ﬁnding tools that we evaluate in this study,
namely FindBugs, AspectJ, and JLint.
2.1 Categorization of Bug Finding Tools
Many bug ﬁnding tools are based on static analysis tech-
niques [38], such as type systems [36], constraint-based an al-
ysis [51], model checking [10, 15, 26], abstract interpreta -
tion [16, 17], or a combination of various techniques [9, 22,
29, 48]. They often produce various false positives, and in
theory they should be free of false negatives for the kinds
of defects they are designed to detect. However, due to im-
plementation limitations and the fact that a large program
often contains defect types that are beyond the designed ca-
1These are counted based on information available on their
respective websites and GitHub on June 28, 2012.pabilities of the tools, such tools may still suﬀer from fals e
negatives with respect to all kinds of defects.
In this study, we analyze several static bug ﬁnding tools
that make use of warning patterns for bug detection. These
tools are lightweight and can scale to large programs. On the
downside, these tools do not consider the speciﬁcations of a
system, and may miss defects due to speciﬁcation violations .
Other bug ﬁnding tools also use dynamic analysis tech-
niques, such as dynamic slicing [49], dynamic instrumenta-
tion [37], directed random testing [12,21,44], and invaria nt
detection [11,20]. Such tools often explore particular par ts
of a program and produce no or few false positives. How-
ever, they seldom cover all parts of a program; they are thus
expected to have false negatives.
There are also studies on bug prediction with data mining
and machine learning techniques, which may have both false
positives and negatives. For example, Sliwerski et al. [45] an-
alyze code change patterns that may cause defects. Ostrand
et al. [39] use a regression model to predict defects. Nagap-
panet al. [35] apply principal component analysis on the
code complexity metrics of commercial software to predict
failure-prone components. Kim et al. [32] predict potential
faults from bug reports and ﬁx histories.
2.2 FindBugs
FindBugs was ﬁrst developed by Hovemeyer and Pugh [28].
It statically analyzes Java bytecode against various famil ies
of warnings characterizing common bugs in many systems.
Code matching a set of warning patterns are ﬂagged to the
user, along with the speciﬁc locations of the code.
FindBugs comes with a lot of built-in warnings. These in-
clude: null pointer dereference, method not checking for nu ll
argument, close() invoked on a value that is always null, tes t
for ﬂoating point equality, and many more. There are hun-
dreds of warnings; these fall under a set of warning families
including: correctness, bad practice, malicious code vuln er-
ability, multi-threaded correctness, style, internation aliza-
tion, performance, risky coding practice, etc.
2.3 JLint
JLint, developed by Artho et al. , is a tool to ﬁnd de-
fects, inconsistent code, and problems with synchronizati on
in multi-threading applications [5]. Similar to FindBugs,
JLint also analyzes Java bytecode against a set of warning
patterns. It constructs and checks a lock-graph, and does
data-ﬂow analysis. Code fragments matching the warning
patterns are ﬂagged and outputted to the user along with
their locations.
JLint provides many warnings such as potential deadlocks,
unsynchronized method implementing ‘Runnable’ interface ,
method ﬁnalize() not calling super.ﬁnalize(), null refere nce,
etc. These warnings are group under three families: syn-
chronization, inheritance, and data ﬂow.
2.4 PMD
PMD, developed by Copeland i.e.et al., is a tool that ﬁnds
defects, dead code, duplicate code, sub-optimal code, and
overcomplicated expressions [14]. Diﬀerent from FindBugs
and JLint, PMD analyzes Java source code rather than Java
bytecode. PMD also comes with a set of warning patterns
and ﬁnds locations in code matching these patterns.
PMD provides many warning patterns, such as jumbled
incrementer, return from ﬁnally block, class cast exceptio n51with toArray, misplaced null check, etc. These warning pat-
terns fall into families, such as design, strict exceptions ,
clone, unused code, String and StringBuﬀer, security code,
etc., which are referred to as rule sets .
3. METHODOLOGY
We make use of bug-tracking, version control, and state-
of-the-art bug ﬁnding tools. First, we extract bugs and the
faulty lines of code that are responsible for them. Next, we
run bug ﬁnding tools for the various program releases before
the bugs get ﬁxed. Finally, we compare warnings given by
bug ﬁnding tools and the real bugs.
3.1 Extraction of Faulty Lines of Code
We analyze two common conﬁgurations of bug tracking
systems and code repositories to get historically faulty li nes
of code. One conﬁguration is the combination of CVS as the
source control repository, and Bugzilla as the bug tracking
system. Another conﬁguration is the combination of Git as
the source control repository, and JIRA as the bug tracking
system. We describe how these two conﬁgurations could be
analyzed to extract root causes of ﬁxed defects.
Data Extraction: CVS with Bugzilla. For the ﬁrst
conﬁguration, Dallmeier and Zimmermann have proposed
an approach to automatically analyze CVS and Bugzilla to
link information [19]. Their approach is able to extract bug
reports linked to corresponding CVS entries that ﬁx the cor-
responding bugs. They are also able to download the code
before and after the bug ﬁx. The code to perform this has
been publicly released for several software systems. As our
focus is on defects, we remove bug reports that are marked
asenhancements (i.e., they are new feature requests), and
the CVS commits that correspond to them.
Data Extraction: Git cum JIRA. Git and JIRA have
features that make it preferable over CVS and Bugzilla.
JIRA bug tracking systems explicitly links bug reports to
the revisions that ﬁx the corresponding defects. From these
ﬁxes, we use Git diﬀ to ﬁnd the location of the buggy code
and we download the revision prior to the ﬁx by append-
ing the “ ∧” symbol to the hashcode of the corresponding
ﬁx revision number. Again we remove bug reports and Git
commits that are marked as enhancements .
Identiﬁcation of Faulty Lines. The above process gives
us a set of real-life defects along with the set of changes tha t
ﬁx them. To ﬁnd the corresponding root causes, we perform
a manual process based on the treatments of the defects.
Kawrykow and Robillard have proposed an approach to re-
move non-essential changes [30] and convert “dirty” treat-
ments to “clean” treatments. However, they still do not re-
cover the root causes of defects.
Our process for locating root causes could not be easily
automated by a simple diﬀoperation between two versions
of the systems (after and prior to the ﬁx), due to the fol-
lowing reasons. First , not all changes ﬁx the bug [30]; some,
such as addition of new lines, removal of new lines, changes
in indentations, etc., are only cosmetic changes that make
the code aesthetically better. Figure 1 shows such an ex-
ample. Second , even if all changes are essential, it is not
straightforward to identify the defective lines from the ﬁx es.
Some ﬁxes introduce additional code, and we need to ﬁnd the
corresponding faulty lines that are ﬁxed by the additional
code. We show several examples highlighting the processof extracting root causes from their treatments for a simple
and a slightly more complicated case in Figures 2 & 3.
Figure 2 describes a bug ﬁxing activity where one line of
code is changed by modifying the operator == to !=. It is
easy for us to identify the faulty line which is the line that
gets changed. A more complicated case is shown in Figure 3.
There are four sets of faulty lines that could be inferred
from the diﬀ: one is line 259 (marked with *), where an
unnecessary method call needs to be removed; a similar fault
is at line 262; the third set of faulty lines are at lines 838-
340, and they are condition checks that should be removed;
the fourth one is at line 887 and it misses a pre-condition
check. For this case, the diﬀis much larger than the faulty
lines that are manually identiﬁed.
Figure 3 illustrates the diﬃculties in automating the iden-
tiﬁcation of faulty lines. To ensure the ﬁdelity of identiﬁe d
root causes, we perform several iterations of manual inspec -
tions. For some ambiguous cases, several of the authors
discussed and came to resolutions. Some cases that are still
deemed ambiguous (i.e., it is unclear or diﬃcult to manu-
ally locate the faulty lines) are removed from this empirica l
study. We show such an example in Figure 4. This example
shows a bug ﬁxing activity where an if block is inserted into
the code and it is unclear which lines are really faulty.
At the end of the above process, we get the sets of faulty
lines Faulty for all defects in our collection. Notation-
wise, we refer to these sets of lines using an index notation
Faulty[] . We refer to the set of lines in Faulty that corre-
spond to the ithdefect as Faulty[i] .
3.2 Extraction of Warnings
To evaluate the static bug ﬁnding tools, we run the tools
on the program versions before the defects get ﬁxed. An
ideal bug ﬁnding tool would recover the faulty lines of the
program—possibly with other lines corresponding to other
defects lying within the software system. Some of these
warnings are false positives, while others are true positiv es.
For each defect, we extract the version of the program
in the repository prior to the bug ﬁx. We have such infor-
mation already as an intermediate result for the root cause
extraction process. We then run the bug ﬁnding tools on
these program versions. Because 13.42% of these versions
could not be compiled, we remove them from our analysis,
which is a threat to validity of our study (see section 4.3).
As described in Section 2, each of the bug ﬁnding tools
takes in a set of rules or the types of defects and ﬂags them
if found. By default, we enable all rules/types of defects
available in the tools, except that we exclude two rule sets
from PMD: one related to Android development, and the
other whose XML conﬁguration ﬁle could not be read by
PMD (i.e., Coupling).
Each run would produce a set of warnings. Each warning
ﬂags a set of lines of code. Notation-wise, we refer to the
sets of lines of code for all runs as Warning , and the set of
lines of code for the ithwarning as Warning[i] . Also, we
refer to the sets of lines of code for all runs of a particular
toolTasWarning T, and similarly we have Warning T[i].
3.3 Extraction of Missed Defects
With the faulty lines Faulty obtained through manual
analysis, and the lines ﬂagged by the static bug ﬁnding tools
Warning , we can look for false negatives, i.e., actual reported
and ﬁxed defects that are missed by the tools.52AspectJ-file name= org.aspectj/modules/org.aspectj. ajdt.core/src/org/aspectj/ajdt/internal/compiler/as t/ThisJoinPointVisitor.java
Buggy version Fixed version 
Line 70:       } 
Line 71:  } //insert a line between line 70 and 71 in the buggy v ersion 
Line 72: //System.err.println("done: " + method); 
Line 78: //System.err.println("isRef: " + expr + ",  " + binding); Line is deleted 
Line 87: else if (isRef(ref, thisJoinPointStaticPart Dec)) Line 89: } else if (isRef(ref, thisJoinPointSt aticPartDec)) { 
Figure 1: Example of Simple Cosmetic Changes
Lucene 2.9 - file name=src/java/org/apache/lucene/se arch/Scorer.java 
Buggy version Fixed version 
*Line 90:    return doc == NO_MORE_DOCS Line 90:   r eturn doc != NO_MORE_DOCS; 
Figure 2: Identiﬁcation of Root Causes (Faulty Lines) from T reatments [Simple Case]
AspectJ - file name= org.aspectj/modules/weaver/src/o rg/aspectj/weaver/bcel/LazyMethodGen.java 
Buggy version Fixed version 
*Line 259:       lng.setStart(null); Line is deleted 
*Line 262:       lng.setEnd(null); Line is deleted 
*Line 838:      if (i instanceof LocalVariableInstr uction) { 
*Line 839:         int index = ((LocalVariableInstr uction)i).getIndex(); 
*Line 840:         if (lvt.getSlot() == index) { 
Line 841:            if (localVariableStarts.get(lv t) == null) { 
Line 842:               localVariableStarts.put(lvt , jh); 
Line 843:            } 
Line 844:            localVariableEnds.put(lvt, jh) ; 
Line 845:        } 
Line 846:      } Line 836: if (localVariableStarts.get(lvt) == null)  { 
Line 837:    localVariableStarts.put(lvt, jh); 
Line 838: }
Line 839: localVariableEnds.put(lvt, jh); 
Line 882: keys.addAll(localVariableStarts.keySet()) ; 
Line 883: Collections.sort(keys,new Comparator() { 
Line 884: public int compare(Object a,Object b) { 
Line 885:        LocalVariableTag taga = (LocalVariab leTag)a; 
Line 886:        LocalVariableTag tagb = (LocalVariab leTag)b; 
*Line 887:        return taga.getName().compareTo(t agb.getName()); 
Line 888:     }}); 
Line 889:    for (Iterator iter = keys.iterator(); it er.hasNext(); ) { Line 870:   keys.addAll(localVariableStarts.keySet( )); 
Line 871-874: //these lines are commented codes 
Line 875:    Collections.sort(keys, new Comparator( ) { 
Line 876:       public int compare(Object a, Object b) { 
Line 877:          LocalVariableTag taga = (LocalVari ableTag) a; 
Line 878:          LocalVariableTag tagb = (LocalVari ableTag) b; 
Line 879:          if (taga.getName().startsWith("a rg")) { 
Line 880:              if (tagb.getName().startsWit h("arg")) { 
Line 881:                 return -taga.getName().co mpareTo(tagb.getName()); 
Line 882:              } else { 
Line 883:                 return 1; // Whatever tag b is, it must come out before 'arg'
Line 884:              } 
Line 885:          } else if (tagb.getName().starts With("arg")) { 
Line 886:                 return -1; // Whatever ta ga is, it must come out before 'arg'
Line 887:             } else { 
Line 888:                  return -taga.getName().c ompareTo(tagb.getName()); 
Line 889:              } 
Line 890:          } 
Line 891:      }); 
Line 892-894: //these lines are commented codes 
Line 895: for (Iterator iter = keys.iterator(); iter. hasNext(); ) {
Figure 3: Identiﬁcation of Root Causes (Faulty Lines) from T reatments [Complex Case]
AspectJ - org.aspectj/modules/weaver/src/org/aspectj/ weaver/patterns/SignaturePattern.java 
Buggy version Fixed version 
Line 87: }
Line 88: if (!modifiers.matches(sig.getModifiers()))  return false; 
Line 89: 
Line 90: if (kind == Member.STATIC_INITIALIZATION) { // Insert these 2 lines between line 87and 88 in th e buggy version
Line 88: if (kind == Member.ADVICE) return true; 
Line 89: <new line> 
Figure 4: Identiﬁcation of Root Causes (Faulty Lines) from T reatments [Ambiguous Case]
To get these missed defects, for every ithwarning, we
take the intersection of the sets Faulty[i] and Warning[i]
from all bug ﬁnding tools, and the intersection between
Faulty[i] with each Warning T[i]. If an intersection is an
empty set, we say that the corresponding bug ﬁnding tool
misses theithdefect. If the intersection covers a true sub-
set of the lines in Faulty[i] , we say that the bug ﬁndingtool partially captures theithdefect. Otherwise, if the in-
tersection covers all lines in Faulty[i] , we say that the bug
ﬁnding tool fully captures theithdefect. We diﬀerentiate
the partial and full cases as developers might be able to re-
cover the other faulty lines, given that some of the faulty
lines have been ﬂagged.533.4 Overall Approach
Our overall approach is illustrated by the pseudocode in
Figure 5. Our approach takes in a bug repository (e.g.,
Bugzilla or JIRA), a code repository (e.g., CVS or Git), and
a bug ﬁnding tool (e.g., FindBugs, PMD, or JLint). For
each bug report in the repository, it performs three steps
mentioned in previous sub-sections: Faulty lines extracti on,
warning identiﬁcation, and missed defect detection.
The ﬁrst step corresponds to lines 3-8. We ﬁnd the bug
ﬁx commit corresponding to the bug report. We identify
the version prior to the bug ﬁx commit. We perform a diﬀ
to ﬁnd the diﬀerences between these two versions. Faulty
lines are then extracted by a manual analysis. The second
step corresponds to lines 9-11. Here, we simply run the
bug ﬁnding tools and collect lines of code ﬂagged by the
various warnings. Finally, step three is performed by lines
12-19. Here, we detect cases where the bug ﬁnding tool
misses ,partially captures , or fully captures a defect. The
ﬁnal statistics is output at line 20.
Procedure IdentifyMissedDefects
Inputs:
BugRepo : Bug Repository
CodeRepo : Code Repository
BFTool : Bug Finding Tool
Output:
Statistics of Defects that are Missed and
Captured (Fully or Partially)
Method:
1: Let Stats ={}
2: For each bug report brinBugRepo
3:// Step 1: Extract faulty lines of code
4: Let ﬁxC =br’s corresponding ﬁx commit in CodeRepo
5: Let bugC = Revision before ﬁxC inCodeRepo
6: Let diﬀ= The diﬀerence between ﬁxC andbugC
7: Extract faulty lines from diﬀ
8: Let Faulty br= Faulty lines in bugC
9:// Step 2: Get warnings
10: Run BFTool onbugC
11: Let Warning br= Flagged lines in bugC byBFTool
12:// Step 3: Detect missed defects
13: Let Common =F aulty br∩W arning br
14: If Common ={}
15: Add /an}bracketle{tbr,miss /an}bracketri}httoStats
16: Else If Common =Faulty br
17: Add /an}bracketle{tbr,full/an}bracketri}httoStats
18: Else
19: Add /an}bracketle{tbr,partial /an}bracketri}httoStats
20: Output Stats
Figure 5: Identiﬁcation of Missed Defects.
4. EMPIRICAL EV ALUATION
In this section we present our research questions, datasets ,
empirical ﬁndings, and threats to validity.
4.1 Research Question & Dataset
We would like to answer the following research questions:
RQ1: How many real-life reported and ﬁxed defects
from Lucene, Rhino, and AspectJ are missed
by state-of-the-art static bug ﬁnding tools?
RQ2: What types of warnings reported by the tools
are most eﬀective in detecting actual defects?
RQ3: What are some characteristics of the defects
missed by the tools?
We evaluate three static bug ﬁnding tools, namely Find-
Bugs, JLint, and PMD, on three open source projects: Lucene,Rhino, and AspectJ. Lucene is a general purpose text search
engine library [1]. Rhino is an implementation of JavaScrip t
written in Java [2]. AspectJ is an aspect-oriented extensio n
of Java [3]. The average sizes of Lucene, Rhino, and AspectJ
are around 265,822, 75,544, and 448,176 lines of code (LOC)
respectively. We crawl JIRA for defects tagged for Lucene
version 2.9. For Rhino and AspectJ, we analyze the iBugs
repository prepared by Dallmeier and Zimmermann [19]. We
show the numbers of unambiguous defects that we are able
to manually locate root causes from the three datasets in
Table 1 together with the total numbers of defects available
in the datasets and the average faulty lines per defect.
Table 1: Number of Defects for Various Datasets
Dataset # of # of Avg # of
Unambiguous Defects Faulty Lines
Defects Per Defect
Lucene 28 57 3.54
Rhino 20 32 9.1
AspectJ 152 350 4.07
4.2 Experimental Results
We answer the three research questions as follows.
4.2.1 RQ1: Number of Missed Defects
We show the number of missed defects by each and all of
the three tools, for Lucene, Rhino, and AspectJ in Table 2.
We do not summarize across software projects as the num-
bers of warnings for diﬀerent projects diﬀer greatly and any
kind of summarization across projects may not be meaning-
ful. We ﬁrst show the results for all defects, and then zoom
into subsets of the defects that span a small number of lines
of code, and those that are severe. Our goal is to evaluate
the eﬀectiveness of state-of-the-art static bug ﬁnding too ls
in terms of their false negative rates. We would also like to
evaluate whether false negative rates may be reduced if we
use all three tools together.
4.2.1.1 All Defects.
Lucene. For Lucene, as shown in Table 2, we ﬁnd that with
all three tools, 35.7% of all defects could be fully identiﬁe d
(i.e., all faulty lines Faulty[i] of a defect iare ﬂagged).
An addition of 14.3% of the defects could also be partially
identiﬁed (i.e., some but not all faulty lines in Faulty[i]
are ﬂagged). Still, 50% of the defects could not be ﬂagged
by the tools. Thus, the three tools are eﬀective but are
not very successful in capturing Lucene defects. Among the
tools, PMD captures the most numbers of bugs, followed by
FindBugs, and ﬁnally JLint.
Rhino. For Rhino, as shown in Table 2, we ﬁnd that with
all three tools, 95% of all defects could be fully identiﬁed.
Only 5% of the defects could not be captured by the tools.
Thus, the tools are very eﬀective in capturing Rhino defects .
Among the tools, FindBugs captures the most numbers of
defects, followed by PMD, and ﬁnally JLint.
AspectJ. For AspectJ, as shown in Table 2, we ﬁnd that with
all three tools, 70.4% of all defects could be fully captured .
Also, another 27.6% of the defects could be partially cap-
tured. Only 1.9% of the defects could not be captured by
any of the tools. Thus, the tools are very eﬀective in cap-54Table 2: Percentages of Defects that are Missed, Partially C aptured, and Fully Captured. The numbers in
the parentheses indicate the numbers of actual faulty lines captured, if any.
Tools vs. Lucene Rhino AspectJ
Programs Miss Partial Full Miss Partial Full Miss Partial Full
FindBugs 71.4% 14.3%(5) 14.3%(8) 10.0% 0% 90.0%(179) 33.6% 19.7%(91) 46.7%(137)
JLint 82.1% 10.7%(3) 7.1%(4) 80.0% 10.0%(2) 10.0%(3) 97.4% 1.3%(2) 1.3%(2)
PMD 50.0% 14.3%(11) 35.7%(13) 15.0% 5.0%(18) 80.0%(157) 3.9% 27.6%(251) 68.4%(196)
All 50.0% 14.3%(11) 35.7%(13) 5.0% 0% 95.0%(181) 1.9% 27.6%(203) 70.4%(262)
turing AspectJ defects. PMD captures the most numbers of
defects, followed by FindBugs, and ﬁnally JLint.
Also, to compare the bug ﬁnding tools, we show the av-
erage number of lines in one defect program version (over
all defects) that are ﬂagged by the tools for our subject pro-
grams in Table 3. We note that PMD ﬂags the most numbers
of lines of code, and likely produces more false positives th an
others, while JLint ﬂags the least numbers of lines of code.
With respect to the average sizes of programs (see Column
“Avg # LOC” in Table 4), the tools may ﬂag 0.2% to 56.9%
of the whole program as buggy.
Table 3: Average Numbers of Lines Flagged Per De-
fect Version by Various Static Bug Finding Tools.
Tools vs.
ProgramsLucene Rhino AspectJ
FindBugs 33,208.82 40,511.55 83,320.09
JLint 515.54 330.6 720.44
PMD 124,281.5 42,999.3 198,065.51
All 126,367.75 52,123.05 220,263
Note that there may be many other issues in a version
besides the defect in our dataset in a program version, and
a tool may generate many warnings for the version. These
partially explain the high average numbers of lines ﬂagged i n
Table 3. To further understand these numbers, we present
more statistics about the warnings generated by the tools
for each of the three programs in Table 4. Column “Avg
# Warning” provides the average number of reported warn-
ings. Column “Avg # Flagged Line Per Warning” is the
average number of lines ﬂagged by a warning. Column “Avg
# Unﬁxed” is the average number of lines of code that are
ﬂagged but are not buggy lines ﬁxed in a version. Column
“Avg # LOC” is the number of lines of code in a particu-
lar software system (across all buggy versions). We notice
that the average number of warnings generated by PMD is
high. FindBugs reports less warnings but many warnings
span many consecutive lines of code. Many ﬂagged lines do
not correspond to the buggy lines ﬁxed in a version. These
could either be false positives or bugs found in the future.
We do not check the exact number of false positives though,
as they require much manual labor (i.e., checking thousands
of warnings in each of the hundreds of program versions),
and they are the subject of other studies (e.g., [25]). On the
other hand, the high numbers of ﬂagged lines raise concerns
with the eﬀectiveness of warnings generated by the tools:
Are the warnings eﬀectively correlated with actual defects ?
To answer such a question, we create random“bug”ﬁnding
tools that would randomly ﬂag some lines of code as buggy
according to the distributions of the number of the lines
ﬂagged by each warning generated by each of the three bug
ﬁnding tools, and compare the bug capturing eﬀectiveness of
such random tools with the actual tools. For each version of
the subject programs and each of the actual tools, we run arandom tool 10,000 times; each time the random tool would
randomly generate the same number of warnings by follow-
ing the distribution of the numbers of lines ﬂagged by each
warning; then, we count the numbers of missed, partially
captured, and fully captured defects by the random tool; ﬁ-
nally, we compare the eﬀectiveness of the random tools with
the actual tools by calculating the p-values as in Table 5. A
value xin each cell in the table means that our random tool
would have x×100% chance to get at least as good results
as the actual tool for either partially or fully capturing th e
bugs. The values in the table imply the actual tools may
indeed detect more bugs than random tools, although they
may produce many false positives. However, some tools for
some programs, such as PMD for Lucene, may not be much
better than random tools. If there is no correlation between
the warnings generated by the actual tools with actual de-
fects, the tools should not perform diﬀerently from the ran-
dom tools. Our results show that this is not the case at least
for some tools with some programs.
Table 5: p-values among random and actual tools.
Tool Program Full Partial or Full
FindBugsLucene 0.2766 0.1167
Rhino <0.0001 0.0081
AspectJ 0.5248 0.0015
JLintLucene 0.0011 <0.0001
Rhino <0.0001 <0.0001
AspectJ 0.0222 0.0363
PMDLucene 0.9996 1
Rhino 0.9996 1
AspectJ 0.9996 <0.0001
4.2.1.2 Localized Defects.
Many of the defects that we analyze span more than a
few lines of code. We further focus only on defects that
can be localized to a few lines of code (at most ﬁve lines
of code, which we call localized defects ), and investigate the
eﬀectiveness of the various bug ﬁnding tools. We show the
numbers of missed localized defects by the three tools, for
Lucene, Rhino, and AspectJ in Tables 6.
Lucene. Table 6 shows that the tools together fully identify
47.6% of all localized defects and partially identify anoth er
14.3%. This is only slightly higher than the percentage for
all defects (see Table 2). The ordering of the tools based on
their ability to fully capture localized defects is the same .
Rhino. As shown in Table 6, all three tools together could
fully identify 93.3% of all localized defects. This is sligh tly
lower than the percentage for all defects (see Table 2).
AspectJ. Table 6 shows that the tools together fully capture
78.9% of all localized defects and miss only 0.8%. These are
better than the percentages for all defects (see Table 2).55Table 4: Unﬁxed Warnings by Various Defect Finding Tools
Software Tool Avg # Warning Avg # Flagged Line Per Warning Avg # Unﬁxed Avg # LOC
RhinoFindBugs 177.9 838.72 40,502.6
75,543.8JLint 34 1 330.35
PMD 11,864.95 21.12 42,990.55
All 12,385.85 32.32 52,114.3
LuceneFindBugs 270.25 469.4 33,208.36
265,821.75JLint 685.21 1 515.29
PMD 39,993.68 11.74 124,280.64
All 40,949.14 14.58 126,366.89
AspectJFindBugs 802.29 381.76 83,318.59
448,175.94JLint 3,937 1 720.41
PMD 73,641.86 2.94079 198,062.57
All 78,381.15 3.05921 220,260.31
Table 6: Percentages of Localized Defects that are Missed, P artially Captured, and Fully Captured
Tools vs. ProgramsLucene Rhino AspectJ
Miss Partial Full Miss Partial Full Miss Partial Full
FindBugs 66.7% 14.3% 19.0% 13.3% 0% 86.7% 32.0% 14.8% 53.1%
JLint 80.9% 9.5% 9.5% 86.7% 0% 13.3% 96.9% 1.6% 1.6%
PMD 38.1% 14.3% 47.6% 20.0% 0% 80.0% 2.3% 21.1% 76.6%
All 38.1% 14.3% 47.6% 6.7% 0% 93.3% 0.8% 20.3% 78.9%
4.2.1.3 Severe Defects.
Diﬀerent defects are often labeled with diﬀerent severity
levels. We further focus only on defects at severe levels:
blocker ,critical , and major , which we collectively call
severe defects , and investigate the eﬀectiveness of the vari-
ous bug ﬁnding tools on detecting severe defects. We show
the numbers of missed severe defects by the three tools, for
Lucene, Rhino, and AspectJ in Table 7.
Lucene. As shown in Table 7, all three tools together could
fully identify 58.3% of all severe bugs. This is higher than
the percentage for all bugs (see Table 2). Considering sever e
defects in Lucene only, FindBugs is equally good as JLint.
Rhino. As shown in Table 7, all three tools together could
fully identify all severe defects. Note that although the pe r-
centage is very good, there are only two severe defects in the
Rhino dataset, and JLint misses both of these two defects.
AspectJ. As shown in Table 7, all three tools together could
fully capture 61.3% of all severe defects and only miss 3.2%.
The relative performance of the three tools is the same as
the relative performance for all defects (see Table 2): PMD,
followed by, FindBugs, followed by JLint. JLint could not
fully capture any severe defect in the AspectJ dataset.
4.2.1.4 Stricter Defects.
We also perform a stricter analysis that requires not only
that the faulty lines are covered by the warnings, but also
the type of the warnings must be directly related to the
faulty lines. For example, if the faulty line is a null pointe r
dereference, then the warning must explicitly say so. Again
we manually analyze to see if the warnings strictly captures
the defect. We focus on defects that are localized to one line
of code due to limited manpower. There are 7 bugs, 5 bugs,
and 66 bugs for Lucene, Rhino, and AspectJ respectively
that can be localized to one line of code.
We show the results of our analysis for Lucene, Rhino,
and AspectJ in Table 8. We notice that under this stricter
requirement, very few of the defects fully captured by thetools (see Column “Full”) are strictly captured by the same
tools (see Column “Strict”). Thus, although the faulty line s
might be ﬂagged by the tools, the warning messages from the
tools may not have suﬃcient information for the developers
to understand the defects.
Table 8: Numbers of One-Line Defects that are
Strictly Captured versus Fully Captured
Tool Lucene Rhino AspectJ
Strict Full Strict Full Strict Full
FindBugs 0 4 1 4 5 42
PMD 0 7 0 5 1 65
JLint 0 0 0 1 1 2
4.2.2 RQ2: Effectiveness of Different Warnings
We show the eﬀectiveness of various warning families of
FindBugs, PMD, and JLint in ﬂagging defects in Tables 9,
10, and 11 respectively. We highlight the top-5 warning
families in terms of their ability in fully capturing the roo t
causes of the defects.
FindBugs. For FindBugs, as shown in Table 9, in terms of
low false negative rates, we ﬁnd that the best warning fami-
lies are: Style, Performance, Malicious Code, Bad Practice ,
and Correctness. Warnings in the style category include
switch statement having one case branch to fall through to
the next case branch, switch statement having no default
case, assignment to a local variable which is never used, un-
read public or protected ﬁeld, a referenced variable contai ns
null value, etc. Warnings belonging to the malicious code
category include a class attribute should be made ﬁnal, a
class attribute should be package protected, etc. Further-
more, we ﬁnd that a violation of each of these warnings
would likely ﬂag an entire class that violates it. Thus, a
lot of lines of code would be ﬂagged, making it having a
higher chance of capturing the defects. Warnings belonging
to the bad practice category include comparison of String ob -
jects using == or !=, a method ignores exceptional return
value, etc. Performance related warnings include method56Table 7: Percentages of Severe Defects that are Missed, Part ially Captured, and Fully Captured
Tools vs. ProgramsLucene Rhino AspectJ
Miss Partial Full Miss Partial Full Miss Partial Full
FindBugs 83.3% 0% 16.7% 0% 0% 100.0% 35.5% 25.8% 38.7%
JLint 83.3% 0% 16.7% 100.0% 0% 0% 96.8% 3.2% 0%
PMD 33.3% 8.3% 58.3% 0% 0% 100.0% 3.2% 35.5% 61.3%
All 33.3% 8.3% 58.3% 0% 0% 100.0% 3.2% 35.5% 61.3%
concatenates strings using + instead of StringBuﬀer, etc.
Correctness related warnings include a ﬁeld that masks a
superclass’s ﬁeld, invocation of toString to an array, etc.
Table 9: Percentages of Defects that are Missed,
Partially Captured, and Fully Captured for Diﬀer-
ent Warning Families of FindBugs
Warning Family Miss Partial Full
Style 46.5% 9.5% 44.0%
Performance 62.0% 9.0% 29.0%
Malicious Code 68.5% 7.5% 24.0%
Bad Practise 73.5% 4.5% 22.0%
Correctness 74.0% 6.5% 19.5%
PMD. For PMD, as shown in Table 10, we ﬁnd that the
warning categories that are the most eﬀective are: Code
Size, Design, Controversial, Optimization, and Naming. Co de
size warnings include problems related to a code being too
large or complex, e.g., number of acyclic execution paths is
more than 200, method length is long, etc. Code size is cor-
related with defects but does not really inform the types of
defects that needs a ﬁx. Design warnings identify subopti-
mal code implementation; these include the simpliﬁcation o f
boolean return, missing default case in a switch statement,
deeply nested if statement, etc which may not be correlated
with defects. Controversial warnings include unnecessary
constructor, null assignment, assignments in operands, et c.
Optimization warnings include best practices to improve th e
eﬃciency of the code. Naming warnings include rules per-
taining to the preferred names of various program elements.
Table 10: Percentages of Warnings that are Missed,
Partially Captured, and Fully Captured for Diﬀer-
ent Warning Families of PMD
Warning Family Miss Partial Full
Code Size 21.5% 5.0% 73.5%
Design 30.0% 8.5% 61.5%
Controversial 27.5% 19.5% 53.0%
Optimization 38.5% 23.0% 38.5%
Naming 60.0% 23.0% 17.0%
JLint. For JLint, as shown in Table 11, we have three cat-
egories: Inheritance, Synchronization, and Data Flow. We
ﬁnd that inheritance is more eﬀective than data ﬂow which
in turn is more eﬀective than synchronization in detecting
defects. Inheritance warnings relate to class inheritance is-
sues, such as: new method in a sub-class is created with iden-
tical name but diﬀerent parameters as one inherited from
the super class, etc. Synchronization warnings relate to er -
roneous multi-threading applications in particular probl ems
related to conﬂicts on shared data usage by multiple threads ,
such as potential deadlocks, required but missing synchro-
nized keywords, etc. Data ﬂow warnings relate to problems
that JLint detects by performing data ﬂow analysis on Javabytecode, such as null referenced variable, type cast misus e,
comparison of String with object references, etc.
Table 11: Percentages of Defects that are Missed,
Partially Captured, and Fully Captured for Diﬀer-
ent Warning Families of JLint
Warning Family Miss Partial Full
Inheritance 93.0% 5.0% 2.0%
Data Flow 93.5% 5.0% 1.5%
Synchronization 99.5% 0% 0.5%
4.2.3 RQ3: Characteristics of Missed Defects
There are 19 defects that are missed by all three tools.
These defects involve logical or functionality errors and t hus
they are diﬃcult to be detected by static bug ﬁnding tools
without the knowledge of the speciﬁcation of the systems.
We can categorize the defects into several categories: meth od
calls (addition, removal of method calls, changes to param-
eters passed in to methods), pre-condition checks (additio n,
removal, or changes to pre-condition checks), assignment
operations (wrong value being assigned to variables), and
others (missing type cast, etc). Often, one defect can be
classiﬁed into diﬀerent categories.
A sample defect missed by all three tools is shown in Fig-
ure 6, which involves an invocation of a wrong method.
4.3 Threats to Validity
Threat to internal validity includes experimental bias. We
manually extract faulty lines from changes that ﬁx them
that might have error prone. To reduce this threat, we have
checked and reﬁned the result of the analysis several times.
We also exclude the defects that ambiguously localize to a
set of faulty lines of code. Also, we exclude some versions
of our subject programs that cannot be compiled. There
might also be implementation errors in various scripts and
code used to collect and evaluate bugs.
Threat to external validity is related to the generalizabil -
ity of our ﬁndings. In this work, we only analyze three static
bug ﬁnding tools and three open source Java programs. We
analyze only one version of Lucene dataset; for Rhino and
AspectJ, we only analyze defects that are available in iBugs .
Also, we investigate only defects that get reported and ﬁxed .
In the future, we could analyze more programs and more de-
fects to reduce selection bias. Also, we plan to investigate
more bug ﬁnding tools and programs in various languages.
5. RELATED WORK
We summarize related studies on bug ﬁnding, warning
prioritization, bug triage, and empirical study on defects .
5.1 Bug Finding
There are many bug ﬁnding tools proposed in the litera-
ture [12, 21, 26, 36, 38, 44, 45]. A short survey of these tools57Rhino - mozilla/js/rhino/xmlimplsrc/org/mozilla/javas cript/xmlimpl/XML.java 
Buggy version Fixed version 
Line 3043:      return createEmptyXML(lib); Line 304 3:      return createFromJS(lib, ""); 
Figure 6: Example of A Defect Missed By All Tools
has been provided in Section 2. In this study, we focus on
three static bug ﬁnding tools for Java, including FindBugs,
PMD, and JLint. These tools are relatively lightweight, and
have been applied to large systems.
None of these bug ﬁnding tools is able to detect all kinds
of bugs. To the best of our knowledge, there is no study on
the false negative rates of these tools. We are the ﬁrst to
carry out an empirical study to answer this issue based on
a few hundreds of real-life bugs from three Java programs.
In the future, we plan to investigate other bug ﬁnding tools
with more programs written in diﬀerent languages.
5.2 Warning Prioritization
Many studies deal with the many false positives produced
by various bug ﬁnding tools. Kremenek et al. use z-ranking
to prioritize warnings [33]. Kim et al. prioritize warning
categories using historical data [31]. Ruthruﬀ et al. predi ct
actionable static analysis warnings by proposing a logisti c
regression model that diﬀerentiates false positives from a c-
tionable warnings [43]. Liang et al. propose a technique
to construct a training set for better prioritization of sta tic
analysis warnings [34]. A comprehensive survey of static
analysis warnings prioritization has been written by Heck-
man and Williams [25]. There are large scale studies on the
false positives produced by FindBugs [6,7].
While past studies on warning prioritization focus on cop-
ing with false positives with respect to actionable warnings,
we investigate an orthogonal problem on false negatives .
False negatives are important as it can cause bugs to go
unnoticed and cause harm when the software is used by end
users. Analyzing false negatives is also important to guide
future research on building additional bug ﬁnding tools.
5.3 Bug Triage
Even when the bug reports, either from a tool or from
a human user, are all for real bugs, the sheer number of
reports can be huge for a large system. In order to allo-
cate appropriate development and maintenance resources,
project managers often need to triage the reports.
Cubranic et al. [18] propose a method that uses text cat-
egorization to triage bug reports. Anvik et al. [4] use ma-
chine learning techniques to triage bug reports. Hooimeije r
et al. [27] construct a descriptive model to measure the qual-
ity of bug reports. Park et al. [41] propose CosTriage that
further takes the cost associated with bug reporting and
ﬁxing into consideration. Sun et al. [46] use data mining
techniques to detect duplicate bug reports.
Diﬀerent from warning prioritization, these studies ad-
dress the problem of too many true positives . They are also
diﬀerent from our work which deals with false negatives.
5.4 Empirical Studies on Defects
Many studies investigate the nature of defects. Pan et
al. investigate diﬀerent bug ﬁx patterns for various softwa re
systems [40]. They highlight patterns such as method calls
with diﬀerent actual parameter values, change of assignmen t
expressions, etc. Chou et al. perform an empirical study of
operating system errors [13].Closest to our work is the study by Rutar et al. on the
comparison of number of warnings generated by various bug
ﬁnding tools in Java [42]. However, no analysis have been
made as to whether there are false positives or false nega-
tives. The authors commented that: “An interesting area of
future work is to gather extensive information about the ac-
tual faults in programs, which would enable us to precisely
identify false positives and false negatives.” In this stud y,
we address the false negatives mentioned by them.
6. CONCLUSION AND FUTURE WORK
Defects can harm software houses and end-users. A num-
ber of bug ﬁnding tools have been proposed to catch the
defects. In this work, we empirically study the eﬀective-
ness of several state-of-the-art static bug ﬁnding tools in
preventing real-life defects. We investigate 3 bug ﬁnding
tools, FindBugs, JLint, and PMD, on 3 programs, Lucene,
Rhino, and AspectJ. We analyze 200 ﬁxed defects and ex-
tract faulty lines of code responsible for these defects fro m
their treatments. We ﬁnd that for Rhino and AspectJ, most
defects could be partially or fully captured by combining the
bug ﬁnding tools. For Lucene, a substantial proportion of
defects (i.e., 50%) are missed . We ﬁnd that FindBugs and
PMD are the best among the three bug ﬁnding tools in pre-
venting false negatives. However, these two tools ﬂag more
lines of code than JLint. Our stricter analysis sheds light
that although many of these warnings cover faulty lines, of-
ten the warnings are too generic and developers need to
inspect the code to ﬁnd the defects. We ﬁnd that some bugs
are not ﬂagged by any of the three bug ﬁnding tools – these
bugs involve logical or functionality errors that are diﬃcu lt
to be detected without any speciﬁcation of the system.
As a future work, we would like to build a new static
analysis tool that automatically extracts the faulty lines of
code responsible for the defects from their symptoms.
7. ACKNOWLEDGMENT
We thank the researchers creating and maintaining the
iBugs repository which is publicly available at http://www.
st.cs.uni-saarland.de/ibugs/ . We appreciate very much
the valuable comments from anonymous reviewers and our
shepherd Andreas Zeller for improving this paper.
8. REFERENCES
[1] Apache Lucene—Apache Lucene Core.
http://lucene.apache.org/core/ .
[2] Rhino—JavaScript for Java.
http://www.mozilla.org/rhino/ .
[3] The AspectJ Project.
http://www.eclipse.org/aspectj/ .
[4] J. Anvik, L. Hiew, and G. C. Murphy. Who should ﬁx
this bug? In ICSE , pages 361–370, 2006.
[5] C. Artho. Jlint - ﬁnd bugs in java programs.
http://jlint.sourceforge.net/, 2006.
[6] N. Ayewah, D. Hovemeyer, J. D. Morgenthaler,
J. Penix, and W. Pugh. Using static analysis to ﬁnd
bugs. IEEE Software , 25(5):22–29, 2008.58[7] N. Ayewah and W. Pugh. The google ﬁndbugs ﬁxit. In
ISSTA , pages 241–252, 2010.
[8] N. Ayewah, W. Pugh, J. D. Morgenthaler, J. Penix,
and Y. Zhou. Evaluating static analysis defect
warnings on production software. In PASTE , pages
1–8, 2007.
[9] T. Ball, V. Levin, and S. K. Rajamani. A decade of
software model checking with slam. Commun. ACM ,
54(7):68–76, 2011.
[10] D. Beyer, T. A. Henzinger, R. Jhala, and
R. Majumdar. The software model checker blast.
STTT , 9(5-6):505–525, 2007.
[11] Y. Brun and M. D. Ernst. Finding latent code errors
via machine learning over program executions. In
ICSE , pages 480–490, 2004.
[12] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and
D. R. Engler. EXE: Automatically generating inputs
of death. ACM Trans. Inf. Syst. Secur. , 12(2), 2008.
[13] A. Chou, J. Yang, B. Chelf, S. Hallem, and D. R.
Engler. An empirical study of operating system errors.
InSOSP , pages 73–88, 2001.
[14] T. Copeland. PMD Applied . Centennial Books, 2005.
[15] J. C. Corbett, M. B. Dwyer, J. Hatcliﬀ, S. Laubach,
C. S. Pasareanu, Robby, and H. Zheng. Bandera:
extracting ﬁnite-state models from java source code.
InICSE , pages 439–448, 2000.
[16] P. Cousot and R. Cousot. An abstract interpretation
framework for termination. In POPL , pages 245–258,
2012.
[17] P. Cousot, R. Cousot, J. Feret, L. Mauborgne,
A. Min´ e, and X. Rival. Why does astr´ ee scale up?
Formal Methods in System Design , 35(3):229–264,
2009.
[18] D. Cubranic and G. C. Murphy. Automatic bug triage
using text categorization. In SEKE , pages 92–97, 2004.
[19] V. Dallmeier and T. Zimmermann. Extraction of bug
localization benchmarks from history. In ASE, pages
433–436, 2007.
[20] M. Gabel and Z. Su. Online inference and enforcement
of temporal properties. In ICSE , pages 15–24, 2010.
[21] P. Godefroid, N. Klarlund, and K. Sen. Dart: directed
automated random testing. In PLDI , pages 213–223,
2005.
[22] GrammaTech. Codesonar. http://www.grammatech.
com/products/codesonar/overview.html .
[23] S. S. Heckman. Adaptively ranking alerts generated
from automated static analysis. ACM Crossroads ,
14(1), 2007.
[24] S. S. Heckman and L. A. Williams. A model building
process for identifying actionable static analysis alerts .
InICST , pages 161–170, 2009.
[25] S. S. Heckman and L. A. Williams. A systematic
literature review of actionable alert identiﬁcation
techniques for automated static code analysis.
Information & Software Technology , 53(4):363–387,
2011.
[26] G. J. Holzmann, E. Najm, and A. Serhrouchni. Spin
model checking: An introduction. STTT ,
2(4):321–327, 2000.
[27] P. Hooimeijer and W. Weimer. Modeling bug report
quality. In ASE, pages 34–43, 2007.
[28] D. Hovemeyer and W. Pugh. Finding bugs is easy. In
OOPSLA , 2004.
[29] IBM. T.J. Watson Libraries for Analysis (WALA).
http://wala.sourceforge.net .
[30] D. Kawrykow and M. P. Robillard. Non-essential
changes in version histories. In ICSE , 2011.[31] S. Kim and M. D. Ernst. Prioritizing warning
categories by analyzing software history. In MSR ,
2007.
[32] S. Kim, T. Zimmermann, E. J. W. Jr., and A. Zeller.
Predicting faults from cached history. In ISEC , pages
15–16, 2008.
[33] T. Kremenek and D. R. Engler. Z-ranking: Using
statistical analysis to counter the impact of static
analysis approximations. In SAS, 2003.
[34] G. Liang, L. Wu, Q. Wu, Q. Wang, T. Xie, and
H. Mei. Automatic construction of an eﬀective
training set for prioritizing static analysis warnings. In
ASE, 2010.
[35] N. Nagappan, T. Ball, and A. Zeller. Mining metrics
to predict component failures. In ICSE , pages
452–461, 2006.
[36] G. C. Necula, J. Condit, M. Harren, S. McPeak, and
W. Weimer. Ccured: type-safe retroﬁtting of legacy
software. ACM Trans. Program. Lang. Syst. ,
27(3):477–526, 2005.
[37] N. Nethercote and J. Seward. Valgrind: a framework
for heavyweight dynamic binary instrumentation. In
PLDI , pages 89–100, 2007.
[38] F. Nielson, H. R. Nielson, and C. Hankin. Principles
of Program Analysis . Springer, 2005.
[39] T. J. Ostrand, E. J. Weyuker, and R. M. Bell.
Predicting the location and number of faults in large
software systems. IEEE Trans. Softw. Eng. ,
31:340–355, April 2005.
[40] K. Pan, S. Kim, and E. J. W. Jr. Toward an
understanding of bug ﬁx patterns. Empirical Software
Engineering , 14(3):286–315, 2009.
[41] J.-W. Park, M.-W. Lee, J. Kim, S. won Hwang, and
S. Kim. CosTriage: A cost-aware triage algorithm for
bug reporting systems. In AAAI , 2011.
[42] N. Rutar, C. B. Almazan, and J. S. Foster. A
comparison of bug ﬁnding tools for java. In ISSRE ,
pages 245–256, 2004.
[43] J. R. Ruthruﬀ, J. Penix, J. D. Morgenthaler, S. G.
Elbaum, and G. Rothermel. Predicting accurate and
actionable static analysis warnings: an experimental
approach. In ICSE , pages 341–350, 2008.
[44] K. Sen, D. Marinov, and G. Agha. CUTE: a concolic
unit testing engine for C. In ESEC/SIGSOFT FSE ,
pages 263–272, 2005.
[45] J. ´Sliwerski, T. Zimmermann, and A. Zeller. When do
changes induce ﬁxes? SIGSOFT Softw. Eng. Notes ,
30:1–5, 2005.
[46] C. Sun, D. Lo, X. Wang, J. Jiang, and S.-C. Khoo. A
discriminative model approach for accurate duplicate
bug report retrieval. In ICSE , pages 45–54, 2010.
[47] G. Tassey. The economic impacts of inadequate
infrastructure for software testing. National Institute
of Standards and Technology. Planning Report
02-3.2002 , 2002.
[48] W. Visser and P. Mehlitz. Model checking programs
with Java PathFinder. In SPIN , 2005.
[49] D. Weeratunge, X. Zhang, W. N. Sumner, and
S. Jagannathan. Analyzing concurrency bugs using
dual slicing. In ISSTA , pages 253–264, 2010.
[50] R. Wu, H. Zhang, S. Kim, and S.-C. Cheung. Relink:
recovering links between bugs and changes. In
SIGSOFT FSE , pages 15–25, 2011.
[51] Y. Xie and A. Aiken. Saturn: A scalable framework
for error detection using boolean satisﬁability. ACM
Trans. Program. Lang. Syst. , 29(3), 2007.59