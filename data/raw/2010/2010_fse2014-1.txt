EfÔ¨Åcient Runtime-Enforcement Techniques
for Policy Weaving
Richard Joinery, Thomas Repsy;z, Somesh Jhay, Mohan Dhawan[, Vinod Ganapathy\
yUniversity of Wisconsin-Madison, USAzGrammaTech, Inc., Ithaca, NY , USA
[IBM Research, New Delhi, India\Rutgers University, Piscataway, NJ, USA
fjoiner,reps,jhag@cs.wisc.edu, mohan.dhawan@in.ibm.com, vinodg@cs.rutgers.edu
ABSTRACT
Policy weaving is a program-transformation technique that rewrites
a program so that it is guaranteed to be safe with respect to a stateful
security policy. It utilizes (i) static analysis to identify points in the
program at which policy violations might occur, and (ii) runtime
checks inserted at such points to monitor policy state and prevent
violations from occurring. The promise of policy weaving stems
from the possibility of blending the best aspects of static and dy-
namic analysis components. Therefore, a successful instantiation
of policy weaving requires a careful balance and coordination be-
tween the two.
In this paper, we examine the strategy of using a combination of
transactional introspection andstatement indirection to implement
runtime enforcement in a policy-weaving system. Transactional
introspection allows the state resulting from the execution of a
statement to be examined and, if the policy would be violated,
suppressed. Statement indirection serves as a light-weight runtime
analysis that can recognize and instrument dynamically generated
code that is not available to the static analysis. These techniques
can be implemented via static rewriting so that all possible program
executions are protected against policy violations. We describe
our implementation of transactional introspection and statement
indirection for policy weaving, and report experimental results that
show the viability of the approach in the context of real-world
JavaScript programs executing in a browser.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program VeriÔ¨Åcation
General Terms
Security, veriÔ¨Åcation
Keywords
Security policy enforcement, dynamic runtime veriÔ¨Åcation, trans-
actional introspection, statement indirection, speculative execution
Supported, in part, by DARPA under cooperative agreement HR0011-
12-2-0012. Any opinions, Ô¨Åndings, and conclusions or recommendations
expressed in this publication are those of the authors, and do not necessarily
reÔ¨Çect the views of the sponsoring agencies. T. Reps has an ownership
interest in GrammaTech, Inc. Thanks to M. Zhivich, S. Maddi, and M. Rabe
at MIT Lincoln Laboratory for invaluable feedback on our implementation.
Thanks to the anonymous reviewers for many good suggestions.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from permissions@acm.org.
FSE‚Äô14 , November 16‚Äì22, 2014, Hong Kong, China.
Copyright c2014 ACM 978-1-4503-3056-5/14/11. . . $15.00.
http://dx.doi.org/10.1145/1. INTRODUCTION
Policy weaving for security-policy enforcement is a program-
rewriting approach oriented towards striking a balance between
static and runtime analysis techniques [1, 19]. It is:
Sound for policy violations : Each program trace that is prevented
is one that violates the policy.
Complete for policy violations : All program traces that violate
the policy are prevented.
Transparent : The rewritten program has the same semantics as
the original program, modulo policy violations.
We refer collectively to these properties as correctness . The policy-
weaving approach is motivated by the acknowledgment that in non-
trivial scenarios, static analysis alone cannot prove that a program
adheres to a policy [7, 16]. In contrast, runtime analyses such as in-
lined reference monitoring (IRM) [10, 11, 24] can be complete for
policy violations by testing properties of concrete states at runtime,
but at the cost of degraded performance. In addition, they may
not be sound because it may be difÔ¨Åcult from a pragmatic stand-
point to exclude only policy-violating traces. To address these lim-
itations, policy weaving is a hybrid approach that (i) attempts to
statically identify sections of the program that can be proven safe,
and (ii) rewrites the program to include runtime checks at locations
where policy state may be affected. This approach, while harness-
ing the best of both worlds, also creates a new challenge: that of
coordinating the interoperability of‚Äîand managing the trade-offs
between‚Äîthe static and runtime analyses. Our goal in this paper is
to present and evaluate a runtime policy-enforcement mechanism
that is well-suited to be the target of a static weaving algorithm.
SpeciÔ¨Åcally, we investigate the utility of transactional intro-
spection applied to a program through static rewriting of source
code, and an additional statement-indirection transformation to en-
able just-in-time transactional introspection of code that is gen-
erated at runtime. We describe the resulting end-to-end policy-
enforcement system, and present experimental data that shows the
viability of this approach when applied to real-world JavaScript ap-
plications in a browser context.
Transactional introspection is a straightforward and powerful
tool for securing untrusted code. Transactions allow speculative
execution, meaning that the effects of an execution can be com-
puted and examined prior to the application of those effects to the
environment. The ability to introspect on actions without commit-
ting their effects is necessary when dealing with programs that per-
form irrevocable actions, such as the initiation of an HTTP request.
Rollback of communication and other I/O actions is not possible in
general, so a security-policy-enforcement mechanism that aims to
mediate such actions must recognize and potentially suppress such
events prior to their occurrence, rather than reacting after the fact.
Transactions provide this capability to ‚Äúpeek into the future‚Äù and
take preventive action to avoid policy violations.
Transactional introspection has been studied in prior security
work [4, 9, 15, 23], and some difÔ¨Åculties have been identiÔ¨Åed:Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
FSE‚Äô14 , November 16‚Äì21, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11...$15.00
http://dx.doi.org/10.1145/2635868.2635907
224Performance overhead of speculative execution can be pro-
hibitive [6, 17].
Correct placement of transactional instrumentation is a nontrivial
task [15, 23, 25].
Implementation of introspection logic to recognize and prevent
policy violations can be error-prone [23].
In this paper, we address each of the concerns that have been raised.
In particular, the complexity of both manually placing individual
transactions and manually constructing introspection code is re-
placed by the requirement to formulate an explicit security policy
as an automaton. Security-policy automata allow programmers to
state their intentions and goals explicitly in a typically small and
self-contained artifact. Moreover, the use of transactions produces
substantial beneÔ¨Åts in terms of performance and Ô¨Çexibility when
compared to other enforcement mechanisms.
We also incorporate statement indirection , a concept introduced
by Yu et al. [28], as a supplemental enforcement primitive. This
mechanism allows us to apply transactional semantics to gener-
ated code , which is code that is created at runtime and is there-
fore unavailable to the static analysis. We use statement indirection
to recognize higher-order scripts , language constructs that gener-
ate code (to be run immediately or at a later time), and to ensure
that this code is executed inside a transaction. Examples of higher-
order scripts abound in modern scripting languages, such as Java-
Script ( eval ,Function ), Python ( eval ,exec ,compile ), and Perl
(eval ). The use of statement indirection serves two purposes:
The static analysis is freed from the generally impossible task
of precisely modeling all possible executions of dynamically
generated code.
Indirection serves as a light weight but special-purpose alterna-
tive to the use of hard-coded transactions.
Our work makes use of and synthesizes several techniques from
prior work:
Runtime veriÔ¨Åcation [1, 5, 12, 14, 19]: the monitoring and en-
forcement of safety properties during program execution
Policy/aspect weaving [13, 20, 26, 27]: the use of static analysis
and rewriting for Ô¨Åne-grained placement of instrumentation
Transactional introspection [4, 9, 15, 23]: a powerful monitoring
and enforcement tool that allows effects of program execution to
be examined before being committed
Statement indirection [20, 28]: a light-weight monitoring tool
that can apply instrumentation to dynamically generated scripts
However, integrating these diverse techniques is challenging. The
speciÔ¨Åc contributions of our work are as follows:
We show how a policy-weaving algorithm can be used to auto-
matically weave sound, complete, and transparent transactional
instrumentation into a program.
We describe the automatic translation of a security-policy spec-
iÔ¨Åcation into introspection code, which substantially reduces the
number of opportunities for implementation errors.
We describe how statement indirection can be used to propagate
transactional introspection to all dynamically generated scripts.
We present JAMScript, a simple, general-purpose extension of
the JavaScript language that implements transactional semantics
with properties suited to security-policy enforcement.
We present experimental results that demonstrate that our ap-
proach performs well compared to manual placement of trans-
actions and other types of enforcement mechanisms that could be
targeted by a policy-weaving algorithm.
Organization:x2 presents a speciÔ¨Åcation of the program-
rewriting algorithm, the semantics of transactional introspection,
the mechanism of indirection, and how these techniques Ô¨Åt together
conceptually.x3 discusses implementation challenges encountered
0 1 
F 
set(_, ‚Äúprivate‚Äù, false)  get(_o, _ ) && _o[‚Äúprivate‚Äù]  == true  call(httpRequest)  
true 
true 0,1: get(_o, _) && _o["private"] == true
1,F: call(httpRequest)
0,F: set(_, "private", false)
Figure 1: Policy automaton (and its textual representation) that speci-
Ô¨Åes a set of disallowed traces, namely, ones that ‚Äúset the private prop-
erty of any object to false ‚Äù (the bottom path in the automaton) or
‚Äúread any property of an object whose private property is true and
subsequently make a network request‚Äù (the top path). set,get and
call are special event predicates that unify their arguments with val-
ues. ois a variable constrained to be the same value at each occur-
rence, and underscore ( ) matches any value. httpRequest references
a speciÔ¨Åc function, and other values are literals. In the textual repre-
sentation, self-loops with the predicate true are implicit.
when applying our approach to JavaScript, and the solutions we
devised.x4 evaluates the performance of JAMScript on a set of
real-world applications. x5 examines related work and discusses
various design choices we made that differ from other systems that
share the same goals.
2. TECHNICAL OVERVIEW
In this section, we examine the properties that a runtime enforce-
ment mechanism must satisfy to meet the requirements of a policy-
weaving system. We identify transactional introspection and state-
ment indirection as two key primitives of an enforcement strat-
egy that meet these requirements. We then incorporate this two-
part mechanism as the targeted enforcement platform used by a
language-independent program-rewriting algorithm.
2.1 Enforcement Primitives
Three principles to be considered when choosing a runtime en-
forcement mechanism are as follows:
Runtime overhead induced by the mechanism should be minimal
to maintain an acceptable user experience.
The mechanism should enable correct policy enforcement (i.e.
sound complete, and transparent).
The mechanism should be general-purpose and extensible, so that
it can be used in arbitrary runtime environments.
Our thesis is that a policy-weaving strategy can, in effect, bring the
enforcement mechanism closer to satisfying each of these princi-
ples, compared to manually placing instrumentation or relying on
an automated modular partitioning strategy as suggested in other
work [9, 23]. When used with an enforcement mechanism based on
transactional introspection, policy weaving produces the following
beneÔ¨Åts:
Fewer program statements are run within transactions, thereby
reducing the performance overhead of enforcement (as shown in
x4).
The policy automaton provided as input to the static analysis is
automatically translated to introspection code that implements
policy monitoring and enforcement at runtime. Examples are
presented inx3, and the beneÔ¨Åts are quantiÔ¨Åed in x4.
By placing transactions via static rewriting, policy weaving can
ensure certain restrictions on the semantics of introspection, such
as sequential execution and a lack of side-effects. (We say more
about these beneÔ¨Åts later in this section.)
We now introduce an example program and a security policy,
and explain how the policy can be enforced via transactional intro-
spection and statement indirection. The policy shown in Figure 1
asserts that network communication should not occur after reading2251config =frequest: "standard" g;
2
3fun getRemoteConfig() f
4param = config.request
5url = "http://config.example.com?" + param;
6reply = httpRequest(url);
7config.remote = eval(reply);
8g
9
10fun getUserConfig() f
11 opt, val = readConfigFromUser();
12 config[opt] = val;
13 config.done = askIfDone();
14g
15
16while (!config.done) f
17 getRemoteConfig();
18 getUserConfig();
19g
...
(a) Original code for a program that reads conÔ¨Åguration data from
an untrusted server and from the user. It is vulnerable to code
injection by the server, and to data leakage to the server.1config =frequest: "standard" g;
2
3fun getRemoteConfig() f
4introspect(policy0_1) fparam = config.request; g
5url = "http://config.example.com?" + param;
6reply = indirect(CALL, [httpRequest, [url]] , policy1_F);
7config.remote = indirect(CALL, [eval, [reply]] , null);
8g
9
10fun getUserConfig() f
11 opt, val = readConfigFromUser();
12 introspect(policy0_F) fconfig[opt] = val; g
13 config.done = askIfDone();
14g
...
(b) Secured code. Gray highlights indicate code introduced by rewrit-
ing. Instrumentation consists of two primitives: (i) calls to indirect
(lines 6 and 7) wrap statements that may invoke higher-order scripts,
and (ii) introspect blocks (lines 4 and 12) are parameterized by a
function that examines actions that occur during speculative execution.
Implementation of the instrumentation functions is shown in Figure 3.
Figure 2: (a) A program that may violate the policy depicted in Figure 1, and (b) a secured version.
1fun indirect(type, parts, ispect) f
2 if (type == CALL) f
3 fun = parts[0]; args = parts[1];
4 if (fun == eval)
5 ispect = policyFull;
... cases for other higher-order scripts ...
7 if (ispect != null)
8 introspect(ispect) fret = fun.apply(args); g
9 else
10 ret = fun.apply(args);
11 return ret
12g
... cases for other expression types ...
14g
15
16fun policy0_1(tx) f
17 for (r in tx.getReadSequence()) f
18 if (!policyStates[1] && r.object.private == true)
19 policyStates[1] = true;
20 commitAction(r);
21g
22g
23
24fun policy1_F(tx) f
25 for (c in tx.getCallSequence()) f
26 if (policyStates[1] && c.target == httpRequest)
27 throw new ViolationException();
28 commitAction(c);
29g
30g31policyStates = [true, false, false];
32
33fun policy0_F(tx) f
34 for (r in tx.getWriteSequence()) f
35 if (r.property == "private" && r.value == false)
36 throw new ViolationException();
37 commitAction(r);
38g
39g
40
41fun policyFull(tx) f
42 for (a in tx.getActionSequence()) f
43 if (!policyStates[1] && a.type == GET && r.object.private == true)
44 policyStates[1] = true;
45 if (policyStates[1] && a.type == CALL && a.target == httpRequest)
46 throw new ViolationException();
47 if (a.type == SET && r.property == "private" && r.value == false)
48 throw new ViolationException();
49 commitAction(a);
50g
51g
52
53fun commitAction(a) f
54 if (a.type == CALL && a.target == eval)
55 a.args[0] = "introspect(policyFull)"
56 + "f" + a.args[0] + " g";
... cases for other higher-order scripts ...
58 a.target.apply(a.args);
59g
Figure 3: Implementation of the functions used to enforce the policy at runtime. The policyfunctions examine actions that occur within an
introspect block to potentially (i) update the policy state (maintained in the global policyStates list) or (ii) throw an exception to prevent a
violation. The parameter txprovides access to sequences of actions recorded during speculative execution. policyFull implements introspection for
the entire policy, while the other policyfunctions are specialized to examine a subset of policy transitions. Each action is passed to commitAction ,
which (i) recognizes higher-order scripts, (ii) applies introspection to generated code, and (iii) applies the effects of the action to the program state.
The indirect function (lines 1‚Äì14) dynamically determines the level of introspection to apply to a statement. If a higher-order script is detected
(such as eval ), the policyFull introspector is used. Otherwise, the input parameter ispect , if non-null, is applied when the original statement
needs specialized introspection (as with line 6 of Figure 2(b)).
from objects marked ‚Äúprivate,‚Äù and that the ‚Äúprivate‚Äù property can-
not be set to false. The program shown in Figure 2(a) potentially
exhibits behaviors that violate the policy. We use a conservative
static analysis to identify statements that may cause policy transi-
tions. (The details of this analysis are outside of the scope of this
paper.) This information is used to rewrite the statements, resulting
in a transformed program, shown in Figure 2(b), having the follow-
ing properties:
All statements that may directly affect the policy state‚Äînot
through invocation of a higher-order script‚Äîare enclosed in
transaction blocks , indicated by the keyword introspect .Anintrospector function is passed as the parameter to each trans-
action block; these functions are deÔ¨Åned in Figure 3.
Each introspector evaluates a unique combination of policy pred-
icates, and they each have read and write access to the global
policyStates array.
This rewriting results in the following runtime behavior:
During execution of a transaction block, all actions (reads, writes,
and calls) are recorded sequentially, and the effects of writes
are postponed. Calls to native functions may trigger transaction
suspension (described in x2.3).2261RewriteIntrospect( P,,	):
Data :P: source code of the program being analyzed
: policy automaton as a set of transitions
	=f(s0;0);:::; (sm;n)g: a policy-violating witness
Result :Prewritten to prevent 	
2foreach (s;)2	do
3 LetTsbe the set of policy transitions for which sis already
instrumented inP
4 Letsorigbe the original, uninstrumented statement corresponding to s
5 ifis not null then
6Ts Ts[fg
7 ifTs=;then
8 ispects null
9 else
10 Generate or retrieve ispects, the introspector function that
implements Algorithm 2 for all 02Ts
11 ifsorigpotentially invokes a higher-order script then
12P RewriteIndirect (P;;sorig;ispects)
13 else
14 Lets0beintrospect (ispects)fsorigg
15 Replaceswiths0inP
16returnP
Algorithm 1: RewriteIntrospect speciÔ¨Åes the static-rewriting step of
a policy-weaving algorithm that applies direct transactional intro-
spection or calls RewriteIndirect (see Algorithm 3) for statements that
may invoke higher-order scripts. Each element (s;)of the witness
	consists of a program statement sand a policy transition .is
either null (indicating that the statement does not directly induce a
transition in this witness, but may invoke a higher-order script that
does) or a triple ('pre;';' post)consisting of a policy state 'pre, a
policy state'post, and a predicate 'that induces the transition.
When the closing brace of the transaction block is reached, the in-
trospector is invoked with a transaction-object argument, through
which all security-relevant information about the recorded ac-
tions can be accessed.
The introspector examines the action sequence and determines
whether to commit or suppress the recorded actions.
In addition to the direct weaving of transaction blocks described
above, we deÔ¨Åne a second type of rewriting, called statement in-
direction , by which any statements that potentially invoke higher-
order scripts are transformed so that transactional introspection can
be selectively applied at runtime. Statement indirection is achieved
by statically decomposing a statement that may invoke a higher-
order script so that the individual constituents can be examined
to determine their runtime values. The static analysis may iden-
tify statements that are candidates for both transactional introspec-
tion and statement indirection, such as line 6 in Figure 2 (assuming
that the identiÔ¨Åer httpRequest can target a higher-order script,
in addition to the function of that name speciÔ¨Åed in the policy
in Figure 1). In this case, introspection is subsumed into the in-
direction mechanism. The indirect function, shown in lines 1‚Äì
14 of Figure 3, determines whether to use the specialized intro-
spector ( policy1 Fin this example) or the full-policy introspector
(policyFull ) if a higher-order script is detected.
Delaying the decision to perform full introspection on these
statements serves as an important optimization in languages (in-
cluding each of those previously mentioned) in which higher-order
scripts can be invoked through indirect function calls or writes to
object properties. In moderately large systems written in languages
with these features, construction of a conservative call graph can be
very imprecise. The use of statement indirection allows a rewriter
to avoid enclosing a large percentage of all statements in transac-
tion blocks, in favor of performing a runtime check to determine
whether a given statement needs to be evaluated within a transac-
tion.1Introspect( Ts,Actions ,Reached ,ispect all):
Data :Ts: sequence of policy transitions potentially induced by the
introspected statement(s)
Actions : sequence of recorded actions
Reached : set of policy states reached during the current execution
ispect all: introspector function that enforces all policy transitions
Result : Terminate execution if a policy violation is detected, or update
Reached and commit each a2Actions otherwise
/* Examine each action in the order it was recorded */
2foreacha2Actions do
/* Evaluate each policy transition */
3 foreach ('i;';' j)2Tsdo
/* If the policy-transition pre-state has been
reached and the post-state has not */
4 if'i2Reached^'j=2Reached then
/* If the policy-transition predicate holds */
5 ifaj='then
/* If the post-state is final */
6 if'jis Ô¨Ånal then
7 Throw an exception and quit
8 else
9 Reached Reached[f'jg
/* Apply introspection to dynamically generated code */
10 ifainvokes a higher-order script then
11 Identify the text \t"of the code being generated
12 Replace \t"with\introspect (ispect all)ftg"
13 ifacan affect the program state then
14 Commita
Algorithm 2: Introspect examines an action sequence at runtime and
either commits or suppresses the effects. The condition aj='is
true if action asatisÔ¨Åes'. This algorithm also identiÔ¨Åes higher-order
scripts and encloses the generated code within a transaction block.
2.2 A Formalization of Rewriting
The rewriting that occurs between Figure 2(a) and Figure 2(b) is
accomplished via a modiÔ¨Åed and extended version of the rewrit-
ing step of the SafetyWeave algorithm formalized by Fredrik-
son et al. [13]. While that paper focuses primarily on the static
policy-weaving algorithm, it assumes that the enforcement mech-
anism is an inlined reference monitor that evaluates the pre-image
pre(s;'violation )of the subsequent statement sand policy predi-
cate'violation with respect to the current program state pre, and
terminates the program if Jpre(s;'violation )K(pre) =true (i.e.,
the execution of the statement could cause a policy violation).
A key insight that led us to integrate SafetyWeave with a trans-
actional enforcement mechanism is that the semantics of introspec-
tion allows predicates constituting the policy to be directly eval-
uated in the context of the (speculative) program state. Viewed
another way, a code fragment that consists of a transaction block
containing a statement simplements the post-state operator post,
which maps the program state preencountered at transaction en-
try and the enclosed statement sto the post-state postthat results
from the execution of s:post(pre;s) =post. A policy pred-
icate'violation can then be directly evaluated in this post-state.
Formally, the condition for policy violation is post(pre;s)j=
'violation .
The observations above allow the rewriting step of SafetyWeave
to be replaced by a transactional-enforcement mechanism. More-
over, despite their similar goals, the implementations of the two ap-
proaches are quite different. Computation of the pre-image involves
the static construction of a potentially complicated symbolic predi-
cate to characterize the set of dangerous program states. In contrast,
the post-state operator that we describe in this paper is available as
a built-in feature of the interpreter, and it produces a single program
state in which 'violation is evaluated.
A policy-weaving algorithm may utilize arbitrary (conservative)
static-analysis techniques to investigate a program‚Äôs behavior with
respect to a security policy . However, in a departure from tradi-2271RewriteIndirect(P,,s,ispects):
Data :P: source code of the program being analyzed
: policy automaton as a set of transitions
s: a program statement
ispects: introspector function that implements Algorithm 2
for all policy transitions that smay directly affect
Result :Pwithsrewritten by statement indirection
over all policy transitions to higher-order scripts invoked by s
3 3Letebe the Ô¨Årst subexpression of s(according to execution order) that
(i) may affect the policy state, directly or by invoking a higher-order script
(ii) is not already within an indirection expression
4ifeis not null then
5 Lettypeebe the expression type of e
6 Letpartsebe an array of subexpressions comprising e
7 Retrieve ispect all, the introspector function that implements
Algorithm 2 for all transitions 2
8 Lete0beIndirect (typee;partse;ispect all;ispects)
9 Lets0be the result of replacing ewithe0ins
10 Replaceswiths0inP
11 return RewriteIndirect (P;;s0;ispects)
12returnP
Algorithm 3: RewriteIndirect speciÔ¨Åes the transformation that ap-
plies indirection to statements that potentially invoke higher-order
scripts. Each subexpression that potentially causes a policy transition
(as determined by the static analysis) is replaced by a runtime call to
Indirect , which is deÔ¨Åned in Algorithm 4.
tional static veriÔ¨Åcation methodology, policy weaving uses a rewrit-
ing step, which serves as the interface between the static and run-
time analyses. Rewriting is invoked in two situations.
A valid execution trace that violates the policy is identiÔ¨Åed.
An invalid execution trace is identiÔ¨Åed, and a conÔ¨Ågurable re-
source bound on how much effort is to be expended on reÔ¨Åning
the program abstraction has been met.
Here, a ‚Äúvalid‚Äù execution trace is one that is realizable in the con-
crete program, as determined via symbolic execution, and an ‚Äúin-
valid‚Äù trace is one that cannot occur in the concrete program, but
is extracted from the abstract model of the program due to impre-
cision. In the Ô¨Årst case, rewriting the program allows the policy-
weaving algorithm to convert a program that can generate policy
violations into a safe, instrumented program. In the second case,
rewriting allows the algorithm to terminate in bounded time and to
use as much information as can be acquired by static analysis while
staying within the resource bound. (The worst-case complexity of
the static analysis would normally preclude its use if the results of
a ‚Äúfull‚Äù static analysis were required.)
The nature of the runtime-enforcement mechanism (the primi-
tive inserted into the program by the SafetyWeave rewriting step) is
discussed in formal but generic terms in [13]. We now develop pre-
cise speciÔ¨Åcations of both the static rewriting step, which consists
of calls to routine Algorithm 1 and subroutine Algorithm 3, and the
procedures Algorithm 2 and Algorithm 4, which implement trans-
actional introspection and statement indirection at runtime.
In Algorithm 1, the ‚Äúpolicy-violating witness‚Äù 	represents
an execution trace along which the policy may be violated in an ab-
stract model of the (partially instrumented) program.1The program
is rewritten by Algorithm 1 to include transactional introspection
for each statement sin the trace that can directly induce a policy
transition. Ifscan invoke a higher-order script, the statement-
indirection transformation is applied by Algorithm 3 so that the in-
1More precisely, 	represents a collection of traces. It is a sequence of
(statement, policy-transition) pairs and thus does not include the statements
in the concrete trace that do not affect the policy state. In general, there
will be many ways in which the ‚Äúgaps‚Äù between policy-transitions could
be Ô¨Ålled in to create a speciÔ¨Åc concrete trace. The rewriting step serves to
prevent all of these traces.1Indirect(typee,partse,ispect all,ispects):
Data :typee: expression type of e
partse: array of values of the subexpressions that comprise e
ispect all: introspector function that enforces all policy transitions
ispects: introspector function (possibly null ) originally applied to s
Result : Value of expression e, or terminate execution in case of a policy
violation
2ifeinvokes a higher-order script (determined by typeeandpartse)then
3 Letispect effective beispect all
4else
5 Letispect effective beispects
6Reassemble expression efrom partse
7ifispect effective isnull then
8 Evaluate expression r=e
9else
10 Evaluate expression introspect (ispect effective )fr=eg
11Return r
Algorithm 4: Indirect is the runtime target of expressions rewritten
by Algorithm 3. It examines typeeandpartseto recognize higher-
order scripts, and determines the function ispect effective to use
for introspection. By construction, ispect allsubsumes ispects, so
the detection of a higher-order script effectively results in a security
upgrade.
trospector (if any) can be chosen as needed at runtime. As the static
analysis proceeds, witnesses that are not prevented by previously-
applied instrumentation are identiÔ¨Åed and the constituent state-
ments are rewritten. Eventually, no more witnesses will be found
because, in the degenerate case, every statement in the program will
be guarded by instrumentation that monitors the full policy. When
no witnesses can be found, the analysis system has proven that no
policy-violating execution trace is realizable in the program.
In contrast to the rewriting step speciÔ¨Åed in past work on policy
weaving [13], which requires an implementation of the pre-image
operator to determine when swill cause a policy transition, the for-
mulation described here relies on the inherent properties of trans-
actional introspection to effectively apply the post-state operator
in the form speciÔ¨Åed in Algorithm 2 (i.e., as a sequence of action
commits).
2.3 Transaction Suspension
While the term ‚Äútransaction‚Äù often implies atomic execution of a
block of code, our goal of security-policy enforcement does not im-
pose this requirement. In fact, we Ô¨Ånd that maintaining both atom-
icity and security‚Äîin the presence of actions that have externally
visible or unpredictable results‚Äîis impractical at best. In an im-
perative language with a built-in I/O interface, for example, it may
be impossible to execute I/O actions speculatively while allowing
for the possibility of suppression of such actions. Therefore, we use
transaction suspension [9] as a means of escaping execution of the
transaction block into the introspection code where the speculative
state can be evaluated and committed prior to resumption. Due to
this process, a transaction may end up being committed as a suc-
cession of partial commits, rather than as an atomic unit.
The introduction of transaction suspension does not require
alteration of Algorithm 2. Upon suspension, the action sequence
available through the transaction object will be a consistent preÔ¨Åx
of the full action sequence for the entire transaction that would be
available in the absence of suspension. Therefore, these actions can
be examined, and the policy state updated, just as before.
We restrict the application of transaction suspension to pre-
dictable circumstances; in particular, it is useful for suspension to
occur at all invocations of native or externally-linked functions. A
whitelist of functions that are free of side-effects‚Äîand therefore
do not need to trigger a suspension‚Äîcan be maintained to reduce
overhead. We discuss speciÔ¨Åc scenarios in which transaction sus-
pension is useful in x3, but we maintain that some form of sus-228pension will be necessary to support transactions in any imperative
language that incorporates external interfaces.
2.4 Correctness
The speciÔ¨Åcation of indirection developed by Yu et al. [28] is ac-
companied by proofs of completeness for policy violation (which
that paper refers to as soundness) and transparency with respect to
a formal semantics of CoreScript, a language subset of JavaScript.
Proofs for the JAMScript framework with respect to the full Java-
Script language would follow a similar trajectory, but are outside
the scope of this paper.
Intuitively, completeness‚Äîprevention of all policy violations
by the top-level script and any generated scripts‚Äîcan be estab-
lished by Ô¨Årst noting that any higher-order script invoked within
anintrospect block will trigger a suspension of the currently ex-
ecuting transaction, at which point the generated script is extracted
and wrapped in another transaction block (see lines 10‚Äì12 of Al-
gorithm 2). Likewise, all higher-order scripts will be instrumented
with statement indirection by the rewriting speciÔ¨Åed in Algorithm 3
so that transactional introspection over the full policy is applied at
runtime to the generated script. In this way, introspection is prop-
agated transitively to all scripts that are executed directly or indi-
rectly in an environment.
Soundness and transparency‚Äîmaintenance of correct program
semantics in the absence of policy-violating execution traces‚Äîcan
be established informally by inspecting the deÔ¨Ånitions of transac-
tional introspection and statement indirection. Transactional intro-
spection implemented by Algorithm 2 and woven by Algorithm 1 is
guaranteed, by construction, to (i) have no visible side-effects, and
(ii) maintain sequential execution up to policy violation. That is, the
execution of a transaction block always produces the same results
as a preÔ¨Åx of the original unprotected code. Statement indirection
implemented by Algorithm 4 and woven by Algorithm 3 is a sim-
ple syntactic transformation that delays execution of an expression
to allow inspection of its constituents. Its only function is to apply
transactional introspection, which results in sound, complete, and
transparent policy enforcement, as shown above.
3. IMPLEMENTATION
This section discusses the implementation of the JAMScript exten-
sion to the JavaScript language, and the integration of its primitives
as the target of a policy weaver. Source code and documentation for
the two components are available online: (i) the JAM policy weaver
is athttps://github.com/blackoutjack/jamweaver and (ii)
the JAMScript enforcement mechanism is at https://github.
com/blackoutjack/jamscript .
3.1 A Strawman Approach
An initial attempt we made to implement speculative execution,
which we refer to as ForkIsolate, failed to have acceptable perfor-
mance to serve as a policy-weaving enforcement mechanism. As
the name indicates, each time speculative mode was entered, the
browser process was duplicated via a fork. The protected code was
then executed in the new branch, and the resulting state was re-
ported back to the original process. Despite copy-on-write seman-
tics for a forked process, the overhead incurred by this mechanism
caused some applications to run 3 orders-of-magnitude slower than
unprotected execution. As an example, decrypting a block of text
in the unprotected snote application takes about 13ms; with a ver-
sion monitored by ForkIsolate instrumentation, this same action
took 16659ms! (With our current implementation, decryption takes
around 17ms.)
Our experience with ForkIsolate also showed the difÔ¨Åculty of
developing a speculative-execution framework that can achieve
correct enforcement of JavaScript embedded in the browser envi-
ronment. We found that due to the underlying mechanism of isola-tion used by ForkIsolate, several classes of statements, for example
those involving calls to DOM methods that expected access to a
GUI (such as window:alert ), resulted in non-transparent behav-
ior, including freezes and crashes. A wide range of such scenarios
would have required special handling to avoid all unexpected and
unpredictable behaviors.
The task of performing complete enforcement in ForkIsolate
was also a struggle. As constructed, the mechanism was incomplete
because only the Ô¨Ånal state of the speculative execution was consid-
ered, so it was possible for the analyzed code to violate the policy
and then revert to a non-violating state, in which case the policy vi-
olation would be undetected. Completeness, like transparency, was
also hindered by environment-speciÔ¨Åc complications. For example,
if the HTMLElement :prototype:appendChild DOM method is
called during speculative execution, it is necessary to identify all
HTML script elements contained in the argument and instrument
the JavaScript code within. Given the architecture of the ForkIso-
late system, these cases had to be recognized and handled by hard-
coded logic.
Consequently, converting ForkIsolate from a prototype into a
fully correct enforcement mechanism for policy weaving would
have required (i) special handling for a wide range of scenarios,
and (ii) a Ô¨Åner granularity of state monitoring. In response to these
challenges, we developed JAMScript, an enforcement mechanism
that (i) is extensible by allowing specialized enforcement capabili-
ties to be loaded as necessary for each embedding system, and (ii)
uses transactions to record a sequence of all actions that occur dur-
ing speculative execution.
3.2 Description of JAMScript
With JAMScript, we adopt transactional introspection as the key
enforcement component for static policy weaving. We have imple-
mented the mechanism as an extension to the JavaScript language
in accordance with the formalization described in x2. The extension
consists of one new keyword, introspect , to indicate the opening
of a transaction block that protects a given fragment of code (de-
limited by enclosing curly braces). A function value is passed as a
parameter to the block to provide the introspection logic.
Additional utilities for runtime enforcement, such as the imple-
mentation of the indirect function described in x2, are provided
as part of the JAM library. This code is written in JavaScript and
is loaded prior to loading the rewritten program, and after loading
the policy logic that is generated at rewriting time by Algorithm 1.
Because the JAM library methods are accessible as source code,
rather than being built into the interpreter, they can be extended
in a straightforward manner to handle constructs provided by em-
bedding systems (such as the browser). We have developed a fully
functional version of this library for the core JavaScript language,
and a prototype implementation that accounts for DOM and other
Web API constructs provided by a browser environment.
In accordance with x2.3, invocation of methods provided by
systems outside of the core JavaScript language, for example the
DOM, causes suspension of a running transaction to allow the
ambient memory state to ‚Äúcatch up‚Äù to the speculative state. In
light of this approach, external systems that utilize our modiÔ¨Åed
JavaScript interpreter do not need to make special accommodations
for the potentially transactional nature of what is occurring in
the JavaScript heap. A complementary consequence is that the
JavaScript interpreter does not need to be aware of the systems
into which it is integrated. JAMScript‚Äôs simple model of suspension
decouples the transactional semantics of the JavaScript interpreter
from the semantics of the embedding system.
To achieve correct enforcement of scripts generated by calls
todocument:write , our implementation includes a few modiÔ¨Åca-
tions to source Ô¨Åles that implement DOM functionality. As noted by
Yu et al. [28], document:write (orwriteln ) can be used to out-2291Object.defineProperty(this, "JAM", fvalue: (function() f
2 var _eval = eval;
3 var _call = Function.prototype.call;
4 var _document_write = HTMLDocument.prototype.write;
5 var _Array_slice = Array.slice;
6
7 returnf
8 policy: policy,
9
10 commitAction: function(a) f
11 if (a.type === "call") f
12 var fun = a.target, args = a.args, obj = a.object;
13 if (fun === _eval) f
14 args[0] = "introspect(JAM.policy.full)"
15 + "f" + args[0] + "g";
16gelse if (fun === _document_write) f
17 JAM.pushDynamicIntrospector(JAM.policy.full);
18 var ret = fun.apply(obj, args);
19 JAM.popDynamicIntrospector();
20 return ret;
21g
22 return fun.apply(obj, args);
23g
24g,
25
26 call: function(f, rec, args, ispect) f
27 if (f === _call) f
28 f = rec; rec = args[0];
29 args = _Array_slice(args, 1);
30 return JAM.call(f, rec, args);
31g
32
33 if (f === _eval || f === _document_write)
34 ispect = JAM.policy.full;
35
36 if (ispect !== undefined)
37 return introspect(ispect) ff.apply(rec, args); g
38 else
39 return f.apply(rec, args);
40g,
41g /* end JAM object literal */
42g()) /* end anonymous function call */
43g); /* end call to Object.defineProperty */
44Object.freeze(JAM);
Figure 4: Initialization of the JAM library and deÔ¨Ånition of the call
andcommitAction methods that implement statement indirection and
instrumentation of code generated by expressions that invoke eval ,
HTMLDocument :prototype:write , and Function:prototype:call .
(Cases for other higher-order scripts, error cases, and additional li-
brary methods are elided to conserve space.) Lines 2‚Äì5 deÔ¨Åne private
references to native objects. The policy object (deÔ¨Åned in Figure 5) is
incorporated (line 8), and the JAM library object is frozen (line 44) so
that its properties cannot be overwritten.
put an HTML script element in pieces over multiple calls. There-
fore, the full text of the generated code may not be available to
the JAMScript instrumentation at any point. We address this issue
with two new native functions, JAM:pushDynamicIntrospector
andJAM:popDynamicIntrospector , that respectively add to and
remove function values from a stack. The modiÔ¨Åed DOM imple-
mentation associates these functions with new scripts as they are
created. When such a script begins execution, the JavaScript inter-
preter runs it as if it were enclosed in (nested) transaction blocks
with the associated functions as the introspectors. Lines 16‚Äì21 in
Figure 4 show how the JAMlibrary makes use of this facility.
3.3 Protecting the Instrumentation
A concern when developing a runtime security technique is to pro-
tect the instrumentation itself from being modiÔ¨Åed or bypassed.
The JAMScript framework leverages JavaScript‚Äôs lexical scoping
and closures to create immutable and self-enclosed enforcement
code. All native objects that will be referenced during policy mon-
itoring are statically known, so the instrumentation is packaged as
objects with methods that close over these references when created.
Both the JAM library (Figure 4) and the policy object (Figure 5)1var policy = (function() f
2var _HTMLImageElement = HTMLImageElement;
3
4function policy0_F(tx) f
5 var commit = true;
6 var ws = tx.getWriteSequence();
7 for (var i=0; i<ws.length; i++) f
8 var a = ws[i];
9 if (a.type === "write" && a.id === "src"
10 && a.object instanceof _HTMLImageElement)
11 commit = false; break;
12g
13 if (commit) JAM.commit(tx);
14 else JAM.prevent(tx);
15g
16
17 returnf
18 policy0_F: policy0_F,
19 full: policy0_F
20g;
21g());
22Object.freeze(policy);
Figure 5: DeÔ¨Ånition of a single-transition policy object prevent-
ing writes to the src property of HTMLImageElement objects.
HTMLImageElement on line 2 is a private reference needed for con-
sistent evaluation at line 10. If no violation is detected, JAM:commit is
called (line 13, deÔ¨Ånition not shown) to commit the effects of write ac-
tions and instrument higher-order scripts with the JAM:commitAction
method (deÔ¨Åned in Figure 4).
are initialized by an anonymous function with local variables and
nested functions that reference these variables. The nested func-
tions become methods of the returned enforcement object, and
JavaScript‚Äôs lexical scoping ensures that the private state is acces-
sible only from within these trusted methods.
We must also ensure that the methods of the JAM library can-
not be reassigned by untrusted code as a means of subverting the
enforcement. Therefore, we deÔ¨Åne the JAM property of the global
object with the Object:defineProperty method in Figure 4 to
set the writable andconfigurable attributes to false , and use
Object:freeze to render all properties immutable (line 44). Java-
Script also allows variable shadowing, which is another potential
way of subverting the instrumentation: a malicious guest program
can declare its own JAMvariable whose value overrides, or ‚Äúshad-
ows,‚Äù the instrumentation itself. This possibility is addressed by
a simple static rewriting step (not shown) that renames declared
variables that could shadow the global JAMidentiÔ¨Åer.
The instrumentation-protection methodology described above
requires that the enforcement code be initialized before the execu-
tion of any untrusted JavaScript. This requirement is easily met in
the browser context by including the scripts that deÔ¨Åne the policy
andJAMobjects prior to any others.
3.4 Statement Indirection in JAMScript
The problem of applying a security-enforcement mechanism to
code that is interpreted by the eval function or Function con-
structor has led many security researchers to limit their tools to lan-
guage subsets [3]. However, surveys have shown that higher-order
scripts are commonly used in existing JavaScript programs [22].
Indeed, the browser context provides many additional methods of
generating dynamic scripts, such as the setTimeout function and
assignment to the HTMLElement :innerHTML property. In this sec-
tion, we describe statement indirection, a program transformation
that propagates transactional introspection to scripts generated at
runtime. We focus on indirection applied to invocations of eval ,
but the technique is also applicable to function calls and property
writes that target the higher-order scripting mechanisms mentioned
above, among others.
Consider the callsite in Figure 6(a). If static analysis cannot ex-
clude that obj:meth references the eval function, we must con-2301var ret = obj.meth(arg);
(a)A statically-indeterminate callsite in the original program.
1var ret = JAM.call(obj.meth, obj, [arg]);
(b)Transformed callsite after statement indirection is applied.
Figure 6: Example of statement indirection to extend the policy to
dynamically generated code. If obj:meth references a function that can
generate code dynamically, such as eval , the JAM:call method (lines
26‚Äì40 in Figure 4) applies the security policy at runtime.
sider the possibility that the value of argmay be executed as code.
The statement-indirection transformation passes the function, re-
ceiver, and arguments for each relevant callsite to the JAM:call
method, which implements Algorithm 4. (Rather than using a type
parameter, as in line 1 of Figure 3, the expression type is en-
coded into the method that is called: we also implement analogous
JAM:new andJAM:set methods for the corresponding types.) The
call produces the same effects as the original method-invocation
expression, except that it is instrumented to monitor the policy state
and prevent violations.
The core JavaScript language deÔ¨Ånes the call ,apply , and
bind methods of function objects, which allow indirect invocation
of functions. JAM:call must also detect and handle these con-
structs in case they are used to invoke higher-order scripts indi-
rectly. When one of these methods is detected at runtime within
JAM:call , we rearrange the arguments in a way that maintains
correct semantics, and recursively call JAM:call . (Lines 27‚Äì31
of Figure 4 show how Function:prototype:call is handled.)
This recursive approach protects against (presumably malicious)
attempts to obfuscate a call to a higher-order script within mul-
tiple nested invocations of call andapply . Additionally, the
defineProperty ,defineGetter , and defineSetter
methods of the Object class may be used to indirectly invoke a
higher-order script that is assigned as a property getter or setter.
In a typical, well-intentioned JavaScript program, this situation is
likely to be very rare, but such a technique could be used by mali-
cious code to attempt to subvert a policy. JAMScript handles the
cases mentioned above along with many additional constructs pro-
vided by the Web API in the browser.
4. EXPERIMENTAL RESULTS
In this section, we present an evaluation of the performance of
JAMScript on a suite of real-world applications. Our experiments
were designed to answer the following questions:
How well does transactional introspection perform when applied
to real-world applications? Is the overhead acceptable?
Does the policy-weaving approach provide performance beneÔ¨Åts
over a naive placement of transactional instrumentation?
What are the savings to the user in terms of conceptual complex-
ity? In particular, how does the size of a security-policy automa-
ton compare to the generated introspection code?
To validate the correctness of our implementation, we worked with
an independent team at MIT Lincoln Laboratory, who probed the
system from an attacker‚Äôs point of view and provided invaluable
feedback.
4.1 Setup and Methodology
To answer the questions posed above, we collected a set of
27 distinct JavaScript applications, and an additional 51 sub-
applications of the SMS2 DNA analysis suite (found at http:
//www.bioinformatics.org/sms2/ ). A list of applications is
shown in Figure 7. With the goal of increasing the signal-to-noise
ratio of our performance measurements, we intentionally sought
applications that perform computationally intensive tasks, such as# of transaction # of statements
AST blocks woven rewritten
Application Nodes by Algorithm 1 by Algorithm 3
squirrelmail 110 0 0
portscanner 195 1 5
doubleclick-loader 271 0 0
userprefs 375 15 15
sunspider 407 6 2
kraken 414 8 4
beacon 787 35 33
plusone 1195 34 35
imageloader 3991 47 68
jswidgets-menu 6288 74 84
sms2-* 6656.7 317.2 321.9
snote 6852 146 139
piwik 7132 229 224
mwwidgets 7504 150 144
midori 9018 19 250
greybox 9914 346 426
googiespell 11603 63 398
ga 13236 388 398
jsqrcode 16407 361 355
hulurespawn 30269 1496 1501
colorpicker 32653 413 1048
adsense 37709 268 431
Ô¨Çickr 38018 1122 1139
jsbench-amazon 59192 32 6966
puzzle 104486 332 391
jsbench-facebook 112823 149 5786
jsbench-google 144453 145 9556
phylojive 166473 8542 8344
Figure 7: Catalog of the applications and policies provided as input
to the analysis, and counts of the different types of instrumentation
inserted. The ‚Äúsms2-*‚Äù item represents the average over a set of 51
applications from the Sequence Manipulation Suite for DNA analysis.
decoding a QR code or processing a DNA sequence. We developed
policies ranging from simple properties, like preventing calls to
window:open , to compound policies that reÔ¨Çect higher-level goals,
such as preventing all external network communication. The bench-
mark applications and policies were paired for one of two general
reasons: (i) to test the scalability and robustness of the system, and
(ii) to demonstrate effectiveness of the system in preventing real
exploits. A few cases ( jsqrcode ,snote , and mwwidgets ) were
developed and contributed by the team at MIT Lincoln Laboratory.
We do not present data related to the strawman implementation
described inx3.1, because it performed too poorly to serve as a rea-
sonable point of comparison. (Instrumented code ran 3‚Äì4 orders-
of-magnitude slower than the original, uninstrumented code.) In-
stead, we compare the performance of the applications secured
by policy weaving (referred to as the ‚ÄúÔ¨Åne-grained‚Äù approach, be-
cause individual statements are speculatively executed) to that of
applications secured in a whole-program fashion (referred to as the
‚Äúcoarse-grained‚Äù approach) in which transaction blocks are used to
secure entire scripts. The latter approach approximates prior work
[9, 23] in which transaction boundaries are determined by individ-
ualscript tags or by the browser‚Äôs same-origin policy. Addition-
ally, to test the absolute performance of transactions as an enforce-
ment mechanism for policy weaving, we compare the running time
of the secured applications to that of the original program.
The static analysis was performed by the JAM policy weaver
[13], modiÔ¨Åed to use the rewriting technique presented in Algo-
rithm 1 and Algorithm 3. JAMScript is implemented in the Spider-
Monkey JavaScript interpreter, version 1.8.5, which is embedded in
the Firefox browser, version 17.0.5esr. Experiments were run on a
Dell Inspiron E6520 laptop computer with an 8-core Intel Core i5-
2540M 2.60GHz CPU with 8GB RAM, running the 64-bit Ubuntu
12.04 LTS operating system.
4.2 Runtime Performance
The plot shown in Figure 8 shows that in most cases, and particu-
larly for test cases that involve computationally-heavy processes, a
program woven with Ô¨Åne-grained transactions outperforms the cor-
responding program protected by a coarse-grained strategy. This
result was not a foregone conclusion, because the two approaches
represent opposite ends of a performance trade-off between trans-
action start-up time and in-transaction processing time. A weav-2310.1 1.0 10.0 100.0
execution time (ms) for unprotected program0.11.0exec. time ratio: fine-grained / coarse-grained page load
other actionsFigure 8: Log-log plot of the execution times of programs with Ô¨Åne-
grained transactional enforcement applied through weaving compared
to coarse-grained whole-program transactions. The ratio of the two ap-
proaches is plotted against the execution time of the original unpro-
tected program. Most points are below the line y=1when the original
execution time is non-trivial, which indicates an overall performance
beneÔ¨Åt from policy weaving, compared to the coarse-grained approach.
ing strategy that uses many Ô¨Åne-grained transactions for policy en-
forcement relies on the assumption that most of the overhead of
speculative execution is incurred during the course of the transac-
tion, rather than in the initialization of the transaction. Our ex-
periments bear out this assumption: we measured an overall 23%
speed-up for program actions instrumented with Ô¨Åne-grained trans-
actions versus coarse-grained transactions, when summarized by
the geometric mean. The speed-up breaks down into a 7% speed-
up for page-load actions, which includes the time taken to load the
JavaScript policy object and the JAM library, and a 33% speed-up
for other program actions. Moreover, there are no prospects for re-
ducing the observed overhead with the coarse-grained approach,
whereas policy weaving provides the opportunity to exert addi-
tional effort during static analysis to rule out spurious instrumenta-
tion to further reduce the runtime overhead.
Similarly, Figure 9 shows the ratio of the execution time for pro-
grams protected by woven transactions versus the original unpro-
tected program, plotted as a function of the original execution time.
When summarized by the geometric mean, the measured execution
time for actions other than the initial page load protected by Ô¨Åne-
grained transactions is 231% of the time for the unprotected pro-
gram. (This number can be compared to 343% for coarse-grained
transactions.) Loading the page took 20.8 and 22.3 times longer
for the instrumented programs (Ô¨Åne-grained and coarse-grained, re-
spectively), which must load the policy object and the JAMlibrary
prior to the program itself. However, the absolute time represented
by this slowdown ranges from 8.5ms to 24.2ms, which is imper-
ceptible to human users.
4.3 Policy Complexity
A substantial beneÔ¨Åt of the automated policy-weaving approach to
program security is that it permits policies to be speciÔ¨Åed declar-
atively. The rewriting framework converts the declarative policy
into imperative code that makes use of the introspection capabil-
ities of JAMScript to enforce the policy at runtime. An example of
this translation appears in the relationship between the input policy
in Figure 1 and the policyfunctions in Figure 3. These func-
tions constitute a ‚Äúspecialized policy‚Äù in which each introspector
evaluates a unique combination of policy transitions to correspond
to the Ô¨Åne-grained instrumentation placed by policy weaving. The
0.1 1.0 10.0 100.0
execution time (ms) for unprotected program0.11.010.0100.0exec. time ratio: fine-grained / unprotectedpage load
other actionsFigure 9: Log-log plot of the ratio of the execution times of programs
with Ô¨Åne-grained transactional enforcement applied through weaving
compared to unprotected execution, plotted as a function of the ex-
ecution time of the original unprotected program. Page-load actions
include the time to initialize the policy object and JAMScript library,
which becomes less of a factor as the overall page-load time increases.
The overall trend decreasing to the right indicates that the percent-
age overhead of security-policy enforcement is less dramatic for more
computationally-intensive applications.
Input Baseline Specialized
Description Policy Policy Policy
Application of Applied Policy (nodes) (nodes) (nodes)
googiespell disallow document.write 7 103 196
imageloader disallow document.write 7 103 196
jsbench-facebook disallow XMLHttpRequest.open 11 103 196
sunspider disallow XMLHttpRequest.open 11 103 196
squirrelmail disallow access to src property 11 103 105
jsbench-amazon disallow XMLHttpRequest.open 11 103 196
jsbench-google disallow XMLHttpRequest.open 11 103 196
kraken disallow XMLHttpRequest.open 11 103 196
puzzle prevent creation of script elements 13 143 256
hulurespawn disallow local storage access 13 146 331
greybox prevent creation of script elements 13 143 256
jswidgets-menu prevent creation of script elements 13 143 256
midori prevent modiÔ¨Åcation of cookie 13 139 330
Ô¨Çickr prevent external pop-up creation 16 135 240
portscanner disallow setting src property 18 126 226
doubleclick-loader prevent navigation 18 128 130
phylojive isolate document from cookie 19 162 356
piwik isolate document from cookie 19 162 356
beacon isolate document from cookie 19 162 356
userprefs disallow appendChild and eval 22 121 229
ga prevent script creation, document edits 24 140 356
plusone prevent script creation, document edits 24 140 356
adsense isolate document from cookie 29 163 690
colorpicker prevent navigation, src/cookie access 33 151 574
snote certain elements write-once/read-only 92 285 1329
mwwidgets certain elements write-once/read-only 92 285 1247
sms2-* prevent all network communication 457 953 1981.9
jsqrcode prevent all network communication 457 953 2566
Figure 10: Size of the input policy versus the automatically generated
enforcement code, given by abstract-syntax-tree nodes. ‚ÄúInput policy‚Äù
refers to the automaton provided to the static analysis (see Figure 1).
The ‚Äúbaseline policy‚Äù is a single introspector that checks all policy
transitions (e.g., policyFull in Figure 3) needed for coarse-grained
protection of the full program. The ‚Äúspecialized policy‚Äù represents
introspection code produced for Ô¨Åne-grained protection of the woven
program (e.g., all of the policyfunctions in Figure 3), and is generally
larger because multiple introspector functions are needed to evaluate
different combinations of policy predicates.
policyFull function in Figure 3 is an example of a ‚Äúbaseline pol-
icy‚Äù that monitors all transitions of the input policy and can be used
with a coarse-grained transaction strategy. The policy weaver that
we have integrated with JAMScript provides a language for spec-
ifying a policy automaton as a list of edges labeled by predicates.
Each predicate is written in a dialect of JavaScript that can refer-
ence calls to native functions (and corresponding arguments), reads232and writes to properties of native objects, reference (in)equality,
and string matching with regular expressions.
To quantify the beneÔ¨Åts provided by the automated production
of introspection code, Figure 10 compares the size of the input
policy to the size of the generated code. Summarized by the ge-
ometric mean, the code for the baseline policy is 7.4x larger than
the input policy for our benchmarks, and the code for the special-
ized policy is 15.8x larger. The size of the representation is admit-
tedly only an indirect measure of implementation complexity, but
we also believe that the input policy automaton provides an intu-
itive interface for specifying a set of disallowed execution traces.
These factors together provide strong support for the usability of
the policy-weaving approach to security-policy enforcement.
5. RELATED WORK
Aspect Weaving and Runtime VeriÔ¨Åcation. Runtime veriÔ¨Åca-
tion systems [1, 5, 19] monitor safety properties over execution
traces produced by an instrumented runtime environment. Runtime
enforcement is additionally charged with preventing violations of
safety properties during the execution. We have described a for-
mulation of runtime enforcement suited for securing untrusted pro-
grams written in interpreted languages that provide a mechanism
for evaluating dynamically generated code.
Oftentimes, aspect weaving is the methodology used to place
the instrumentation that a runtime-veriÔ¨Åcation system uses. This
approach may be limited to interposition on predeÔ¨Åned threshold
events, such as system calls or library method calls [2, 12, 14]. In
contrast, our work pursues a more invasive but powerful technique:
policy weaving through program rewriting. This approach enables
enforcement at a Ô¨Åner granularity (for example, individual property
reads and writes). Policy weaving also departs from standard
aspect weaving by enabling semantics-based‚Äîrather than syntax-
based‚Äîrewriting.
Runtime Enforcement for JavaScript. A number of prior
works investigate the enforcement of security policies for Java-
Script in a browser. In general, the solution for runtime enforcement
that we describe in this paper is distinguished from prior work by
the choice of transactional introspection as the enforcement mech-
anism, and the resulting ability to handle safely the full JavaScript
language, rather than a restricted subset.
Fredrikson et al. [13] describe the JAM policy weaver for Java-
Script as an implementation of their general technique. That paper
focuses primarily on the static-rewriting methodology, and leaves
the nature of the runtime-enforcement mechanism largely unspeci-
Ô¨Åed. In a complementary manner, we investigate the desirable prop-
erties of the runtime component, while allowing for the possibility
of integrating a wide range of static-analysis techniques.
Yu et al. [28] present a rewriting scheme that uses indirection to
apply security policies to dynamically generated JavaScript code.
Their method actively rewrites this code as it is encountered at run-
time. In contrast, we avoid structural manipulation of code at run-
time by applying transactional introspection to the generated code
as it is encountered. Their system is built entirely in JavaScript
without interpreter modiÔ¨Åcations, and they express concern that
this approach can allow a malicious script to alter the instrumen-
tation during execution. While we implement much of the func-
tionality of transactional introspection in the interpreter, we also
introduce JavaScript code that must be protected. Our method of
doing so, based on lexical closures, could be employed in their im-
plementation.
Several systems, including Caja [21], ADsafe [8], ConScript
[20], and Maffeis et al. [18], use wrappers or object-capability mod-
els (often in addition to rewriting) as a means of enforcing policies
on untrusted JavaScript code. In these schemes, references to na-
tive objects are redirected to secure implementations that can Ô¨Ålterunsafe runtime behaviors. Wrappers and statement indirection both
enable intervention on security-sensitive actions, but statement in-
direction is a rewriting technique and wrappers are an alteration to
the runtime environment. Therefore, indirection can be used at a
per-statement granularity, while wrappers are typically employed
per-module. For this reason, statement indirection is a more natural
target for policy weaving, which aims to apply instrumentation pre-
cisely where it is needed. Each of the wrapper-based approaches
limits the analyzed programs to some subset of the JavaScript lan-
guage, often to prohibit higher-order scripts, thereby sacriÔ¨Åcing
transparency. Transactional introspection in JAMScript is crucial
to provide complete enforcement for dynamically generated code.
Transaction-Based Policy Enforcement. The use of transac-
tional introspection for security-policy enforcement can be viewed
as an evolution of inlined reference monitoring, which was devel-
oped around 2000 by Schneider and Erlingsson [10, 11, 24]. The
primary difference is that the semantics of introspection enables
a more direct examination of the effects of the monitored program
statements, rather than relying on a calculation of the effects. When
higher-order scripts (or just complicated statements) are used in the
analyzed program, this ability to observe concrete effects is needed
for sound and complete policy enforcement.
Transcript [9] is an extension to the JavaScript language that
implements speculative execution with introspection for security-
policy enforcement. As presented in [9], each untrusted ‚Äúguest‚Äù
module, delineated as different source-code Ô¨Åles included in a web
page via HTML script tags, is executed within a transaction. In
contrast, JAMScript was developed to be the target of a static weav-
ing process that results in Ô¨Åne-grained transactions applied to the
full program, including the host code. Also, while Transcript relies
on a complex conÔ¨Çict-resolution system to maintain the consistency
of the DOM during a transaction, JAMScript uses a relatively sim-
ple suspend mechanism that is oblivious to the context in which the
core JavaScript interpreter is running.
Richards et al. [23] apply speculative-execution semantics (re-
ferred to as ‚Äúdelimited histories‚Äù) to untrusted code in an automatic
but coarse-grained fashion based on the browser‚Äôs same-origin pol-
icy. In their approach, the entirety of the third-party code is exe-
cuted speculatively, and the host code is trusted to execute without
protection. In contrast, we argue for an approach in which allcode
is subjected to the security policy, and the scope of instrumenta-
tion is focused by using the results of a conservative static analysis.
Trusting the host code may be reasonable in some contexts, but this
assumption leaves open the possibility for clever attackers to ma-
nipulate the environment and coerce the host code into violating the
intended policy. Another difference between their work and ours is
that the introspection code in [23] is written manually on a case-
by-case (albeit reusable) basis in C++ modules, with the intent of
shielding the instrumentation from manipulation. In contrast, our
system automatically produces introspection code as a translation
of the policy automaton, and we make use of a relatively simple
scheme for protecting the integrity of the instrumentation.
Various systems use transactional introspection for policy en-
forcement in other contexts. Transactional Memory Introspection
(TMI) [4] applies transactional instrumentation to multithreaded
server software. The JavaScript language does not exhibit true mul-
tithreaded behavior, so TMI addresses issues that are orthogonal
to the ones addressed in this paper. TxBox [15] uses transactions
to enforce operating-system-level policies that limit the access of
applications to system resources. In contrast, JAMScript enforces
application-level policies and can restrict internal program behav-
ior. Our approach is also distinguished by the use of static analysis
for runtime-performance beneÔ¨Åts, as well as by the techniques we
use for securing dynamically generated scripts.2336. REFERENCES
[1] C. Allan, P. Avgustinov, A. S. Christensen, L. Hendren, S. Kuzins,
O. Lhot ¬¥ak, O. De Moor, D. Sereni, G. Sittampalam, and J. Tibble.
Adding trace matching with free variables to AspectJ. In Proceedings
of the 20th Annual ACM SIGPLAN Conference on Object Oriented
Programming Systems Languages and Applications , pages 345‚Äì364.
ACM, 2005.
[2] A. Bauer, J.-C. K ¬®uster, and G. Vegliach. Runtime veriÔ¨Åcation meets
Android security. In NASA Formal Methods , pages 174‚Äì180. Springer,
2012.
[3] N. Bielova. Survey on JavaScript security policies and their enforce-
ment mechanisms in a web browser. The Journal of Logic and Alge-
braic Programming , 82(8):243‚Äì262, 2013.
[4] A. Birgnisson, M. Dhawan, U. Erlingsson, V . Ganapathy, and
L. Iftode. Enforcing authorization policies using transactional memory
introspection. In Proceedings of the 15th ACM Conference on Com-
puter and Communications Security , pages 223‚Äì234. ACM, 2008.
[5] E. Bodden and L. Hendren. The Clara framework for hybrid typestate
analysis. International Journal on Software Tools for Technology
Transfer , 14(3):307‚Äì326, 2012.
[6] C. Cas ¬∏caval, C. Blundell, M. Michael, H. W. Cain, P. Wu, S. Chiras,
and S. Chatterjee. Software transactional memory: Why is it only a
research toy? ACM Queue , 6(5), September 2008.
[7] B. Chess and G. McGraw. Static analysis for security. IEEE Security
and Privacy , 2(6):76‚Äì79, 2004.
[8] D. Crockford. ADsafe: Making JavaScript safe for advertising. http:
//www.adsafe.org .
[9] M. Dhawan, C. Shan, and V . Ganapathy. Enhancing JavaScript with
transactions. In European Conference on Object Oriented Program-
ming , pages 383‚Äì408. Springer, 2012.
[10] U. Erlingsson. The Inlined Reference Monitor Approach to Security
Policy Enforcement . PhD thesis, Computer Sciences Department,
Cornell University, January 2004.
[11] U. Erlingsson and F. B. Schneider. SASI enforcement of security
policies: a retrospective. In Proceedings of the 1999 Workshop on
New Security Paradigms , pages 87‚Äì95. ACM, 2000.
[12] Y . Falcone, S. Currea, and M. Jaber. Runtime veriÔ¨Åcation and enforce-
ment for Android applications with RV-Droid. In Runtime VeriÔ¨Åcation ,
pages 88‚Äì95. Springer, 2013.
[13] M. Fredrikson, R. Joiner, S. Jha, T. Reps, P. Porras, H. Sa ¬®ƒ±di,
and V . Yegneswaran. EfÔ¨Åcient runtime policy enforcement using
counterexample-guided abstraction reÔ¨Ånement. In Computer Aided
VeriÔ¨Åcation , pages 548‚Äì563. Springer, 2012.
[14] S. Hussein, P. Meredith, and G. Ros ¬∏u. Security-policy monitoring
and enforcement with JavaMOP. In Proceedings of the 7th Workshop
on Programming Languages and Analysis for Security , page 3. ACM,
2012.[15] S. Jana, D. E. Porter, and V . Shmatikov. TxBox: Building secure, ef-
Ô¨Åcient sandboxes with system transactions. In Symposium on Security
and Privacy , pages 329‚Äì344. IEEE, 2011.
[16] W. Landi. Undecidability of static analysis. ACM Letters on Program-
ming Languages and Systems , 1(4):323‚Äì337, 1992.
[17] M. E. Locasto, A. Stavrou, G. F. Cretu, and A. D. Keromytis. From
STEM to SEAD: Speculative execution for automated defense. In
USENIX Annual Technical Conference , pages 219‚Äì232, 2007.
[18] S. Maffeis, J. C. Mitchell, and A. Taly. Isolating JavaScript with Ô¨Ålters,
rewriting, and wrappers. In European Symposium on Research in
Computer Security , pages 505‚Äì522. Springer, 2009.
[19] P. O. Meredith, D. Jin, D. GrifÔ¨Åth, F. Chen, and G. Ros ¬∏u. An overview
of the MOP runtime veriÔ¨Åcation framework. International Journal on
Software Tools for Technology Transfer , 14(3):249‚Äì289, 2012.
[20] L. A. Meyerovich and B. Livshits. ConScript: Specifying and en-
forcing Ô¨Åne-grained security policies for JavaScript in the browser.
In2010 IEEE Symposium on Security and Privacy , pages 481‚Äì496.
IEEE, 2010.
[21] M. S. Miller, M. Samuel, B. Laurie, I. Awad, and M. Stay. Safe active
content in sanitized JavaScript. Technical report, Google, Inc, 2008.
[22] G. Richards, S. Lebresne, B. Burg, and J. Vitek. An analysis of the
dynamic behavior of JavaScript programs. In Proceedings of the 2010
ACM SIGPLAN Conference on Programming Language Design and
Implementation , pages 1‚Äì12. ACM, 2010.
[23] G. Richards, C. Hammer, F. Z. Nardelli, S. Jagannathan, and J. Vitek.
Flexible access control for JavaScript. In Proceedings of the 2013
ACM SIGPLAN International Conference on Object Oriented Pro-
gramming Systems Languages and Applications , pages 305‚Äì322,
2013.
[24] F. B. Schneider. Enforceable security policies. ACM Transactions on
Information and System Security , 3(1):30‚Äì50, 2000.
[25] M. Song and E. Tilevich. TAE-JS: Automated enhancement of Java-
Script programs by leveraging the Java annotations framework. In
Proceedings of the 2013 International Conference on Principles and
Practices of Programming on the Java Platform: Virtual Machines,
Languages, and Tools , pages 13‚Äì24. ACM, 2013.
[26] R. Toledo, P. Leger, and ¬¥E. Tanter. AspectScript: Expressive aspects
for the web. In Proceedings of the 9th International Conference on
Aspect-Oriented Software Development , pages 13‚Äì24. ACM, 2010.
[27] H. Washizaki, A. Kubo, T. Mizumachi, K. Eguchi, Y . Fukazawa,
N. Yoshioka, H. Kanuka, T. Kodaka, N. Sugimoto, Y . Nagai, et al.
AOJS: Aspect-oriented JavaScript programming framework for Web
development. In Proceedings of the 8th Workshop on Aspects, Com-
ponents, and Patterns for Infrastructure Software , pages 31‚Äì36. ACM,
2009.
[28] D. Yu, A. Chander, N. Islam, and I. Serikov. JavaScript instrumen-
tation for browser security. In Proceedings of the 34th Annual ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Lan-
guages , volume 42, pages 237‚Äì249. ACM, 2007.234