Diagnosys: Automati c Generation of a
Debugging Interface t o the Linux Kernel
TegawendéF.Bissyand é,
LaurentRéveillère
UniversityofBordeaux ,France
{bissyande,reveillere}@ labri.frJuliaL.Lawall,
GillesMuller
INRIA/LIP6-Regal,Fran ce
{Julia.Lawall,Gilles.Mul ler}@lip6.fr
ABSTRACT
TheLinuxkerneldoes notexportastable,we ll-deﬁnedker-
nel interface, complica ting the development of kernel-level
services,suchasdevice driversandﬁlesystems . Whilethere
does exist a set of fun ctions that are export ed to external
modules, this set of fu nctions frequently cha nges, and the
functions have implici t, ill-documented prec onditions. No
speciﬁcdebuggingsup portisprovided.
WepresentDiagnosys,anapproachtoautom aticallycon-
structingadebugging interfacefortheLinux kernel. First,
a designated kernel m aintainer uses Diagnos ys to identify
constraintsontheuse oftheexportedfunctio ns. Basedon
thisinformation,devel opersofkernelservices canthenuse
Diagnosys to generate a debugging interface specialized to
theircode. Whenaser viceincludingthisinte rfaceistested,
itrecordsinformationa boutpotentialproblem s. Thisinfor-
mation is preserved fo llowing a kernel crash or hang. Our
experiments show tha t the generated debug ging interface
providesusefulloginfo rmationandincursalo wperformance
penalty.
CategoriesandSubject Descriptors
D.2.5[Software Engineerin g]: TestingandDebugg ing—
Debugging aids;D.4.5[Operating Systems]: Reliability
GeneralTerms
Design,Experimentati on,Reliability
Keywords
Diagnosys,Debugging, Wrappers,Linux,Devi cedrivers
1. INTRODUCTION
Debugging is diﬃcult. And debugging an ope rating sys-
temkernel-levelservice ,suchasadevicedrive r,ﬁlesystem,
or network protocol, i s even more diﬃcult. When a crash
occurs,theservicedev eloperispresentedwit habacktrace,
Permission to make digi tal or hard copies of all or part of this work for
personal or classroom us e is granted without fee provided that copies are
not made or distributed fo r proﬁt or commercial ad vantage and that copies
bearthisnoticeandthe fu llcitationontheﬁrstpag e. Tocopyotherwise,to
republish,topostonserve rsortoredistributetolist s,requirespriorspeciﬁc
permission and/or a fee.
ASE’12, September 3–7, 201 2, Essen, Germany
Copyright 12 ACM 978-1 -4503-1204-2/12/09 ...$1 5.00.containing the location of the instruction that caused the
crash and the pending return pointers on the stack. This
information may be u nreliable or incomplet e. Even when
the backtrace informa tion is present and co rrect, it does
notcapturecontextin formationsuchasthe valuesoflocal
variablesandtheeﬀect ofrecentdecisionsthat areoftenes-
sentialtoidentifythe problem. Indeed,kern elservicecode
containsmanyexecuti onpaths, takingcondi tionsfromthe
operatingenvironment intoaccount, andisdi ﬃculttotest
deterministically. Supp ortisneededforprovi dingmorein-
formation at the time of the crash, without introducing a
substantial performanc e penalty or imposing an additional
burdenonthedevelop er.
AsLinuxisbecomingm oreandmorewidelyus ed,inplat-
forms ranging from em bedded systems to sup ercomputers,
there is an increasing interest from third-par ty developers,
havinglittleexpertise inLinuxinternals,ind evelopingnew
Linuxkernelservices. Suchservicesmustinte gratewiththe
Linux kernel via the v arious kernel-level API s. Developing
code at this level is a challenging task. Inde ed, the Linux
kerneldevelopmentpro cessisbasedontheass umptionthat
thesourcecodeofallk ernel-levelservicesisav ailablewithin
the publicly available kernel source tree, an d thus kernel
APIsare,foreﬃciency ,onlyasrobustasreq uiredbytheir
internalclientservices . Furthermore,kernel developerscan
freelyadjustthekerne lAPIs,aslongasthey arewillingto
updatealloftheaﬀecte dservicecode. Theker nelimplemen-
tationisthus,bydesig n,maximallyeﬃcient andevolvable,
enablingittorapidly meetnewperformance requirements,
address security issues , and accommodate ne w functionali-
ties. But these assump tions complicate the ta sk of the de-
velopers of new servic es who require more s afety and help
indebugging. Advance sinbug-ﬁndingtools[3 ,18,19],spe-
cializedtestingtechniq ues[17,20],andcodeg enerationfrom
speciﬁcations[29]have easedbutnotyetfully solvedthese
diﬃculties. Currentap proachesputsubstanti aldemandson
thedeveloper,bothto learnhowtousetheap proachandto
eﬀectivelyintegrateit intohisdevelopmentp rocess.
We concretize the diﬃ culty confronting a Li nux service
developerininteractin gwiththeLinuxkerne lasthenotion
of asafety hole. We deﬁne a safety h ole as a fragment of
code that introduces t he potential for a fau lt to occur in
theinteractionbetween akernel-levelservicean dtherestof
the kernel. For examp le, code in the deﬁniti on of a kernel
APIfunctionthatdere ferencesaparameterw ithouttesting
its value represents a safety hole, because a service could
invoke the function w ithNULLas the corresponding argu-
ment. Likewise, code in the deﬁnition of a k ernel internalPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
60
API function that ret urnsNULLas the result represen ts a
safetyhole, becausea callingservicecouldd ereferencethis
resultwithoutchecking itsvalue.
Toaddresstheproblem ofsafetyholesinLinux kernelin-
ternalAPIfunctions,w eproposeanapproach, namedDiag-
nosys,thatautomaticallyge neratesadebuggingint erfaceto
theLinuxkerneltailore dforaparticularkerne l-levelservice
under development, ba sed on a prior static a nalysis of the
Linuxkernelsourcecod e. Thisdebugginginter faceamounts
toawrapperontheke rnelexportedfunctions ,thatlogsin-
formation about poten tially dangerous uses of these func-
tions. Localizingthein terfaceinthisway,at theboundary
oftheinteractionbetw eentheserviceandthe OSkernel,en-
suresthatthefeedback providedbytheinterfa ceisinterms
ofthecodethatthed eveloperhaswritten, a ndisthusex-
pected to be familiar with. Because the int erface is only
visibletotheservice, i thasnoimpactonth eperformance
ofcodewithinthekern el,evencodethatuses functionsthat
contain safety holes. W hen the service execut es, the inter-
facegenerateslogmess ageswheneverservicec odeinvokesa
kernelAPIfunctionco ntainingasafetyholei napotentially
risky way. Such a deb ugging interface requir es no manual
interventionfromthes ervicedeveloperuntilt hereisacrash
orhang,andisthuswe ll-suitedtointensivese rvicedevelop-
ment,whenthedevelo perismodifyingtheco defrequently,
and bugs are likewise frequent. Because the debugging in-
terfaceisautomatically generated,itcanbere generatedfor
each new version of th e Linux kernel, as the properties of
thekernelAPIschange .
Diagnosysiscomposed oftwotools: SHAna(S afetyHole
Analyzer),whichstati callyanalyzesthekern elsourcecode
to identify safety hole s in the deﬁnitions of the kernel ex-
portedfunctions,and DIGen(DebuggingInt erfaceGenera-
tor),whichusesthein formationabouttheid entiﬁedsafety
holestoconstructade bugginginterfacetailo redtoagiven
service. Diagnosysalso includesaruntimesyst em,provided
as a kernel patch. SH Ana is run by a Linux kernel main-
taineronceforeachLi nuxversion,totakein toaccountthe
current deﬁnitions of the Linux kernel inter nal API func-
tions. DIGen is run b y a service developer as part of the
service compilation pr ocess. During the exe cution of the
resulting service, the d ebugging interface use s the runtime
system to log informa tion in a crash-resilien t buﬀer about
any unsafe uses of fun ctions containing safet y holes. On a
kernelcrashorhang,th eservicedevelopercan subsequently
consultthebuﬀertoo btaintheloggedinform ation.
Themaincontribution softhispaperareasf ollows:
•Weidentifytheinterf aceofkernelexported functions
asasweetspotatwhic hitispossibletointer posethe
generation of debuggi ng information, in a way that
improvesdebuggability butdoesnotintroduce anex-
cessiveruntimeoverhe ad.
•Weidentifysafetyhol esasasigniﬁcantprob leminthe
interface between a se rvice and the kernel. Indeed,
ofthe703Linux2.6co mmitsforwhichthech angelog
refersexplicitlytoafun ctionexportedinLinux 2.6.32,
38% corrected faults that are related to on e of our
identiﬁedsafetyholes.
•Weproposeanapproa chtoallowaservicedev eloperto
seamlesslygenerate,in tegrate,andexploitak ernelde-
bugginginterfacespeci alizedtotheserviceco de. Thisapproach has a low le arning curve, and in p articular
doesnotrequireanypa rticularLinuxkernelex pertise.
•Using fault-injection experiments on 10 Lin ux kernel
services, we demonstra te the improvement in debug-
gability provided by o ur approach. We ﬁnd that in
90%ofthecasesinwh ichacrashoccurs,the logcon-
tains information relev ant to the origin of th e defect,
and in 95% of these c ases, a message releva nt to the
crashisthelastpiece ofloggedinformation. Wealso
ﬁndthatin93%ofthe casesinwhichacrash orhang
occurs,theloginforma tionreducesthenumbe rofﬁles
thathavetobeconsult edtoﬁndthecauseof thebug.
•Weshowthatthegen erateddebugginginterf aceincurs
onlyaminimalruntime overheadonserviceexe cution,
allowingittobeused upthroughearlydeplo yment.
The rest of this paper is organized as follows . Section 2
illustrates problems in kernel development th at have been
related to safety holes and gives an overview of kinds of
safety holes that we ta ke into account. Sectio n 3 discusses
thechallengesinkerne ldebugging,focusingo ncrashesand
hangs derived from sa fety holes. Section 4 presents Diag-
nosys,includingthepr ocessofcollectinginfor mationabout
theoccurrencesofsafe tyholesandtheassoci atedprecondi-
tions, and the process of generating a debugg ing interface.
Section 5 evaluates ou r approach. Finally, S ection 6 dis-
cussesrelatedwork,an dSection7concludes.
2. SAFETYHOLES
To understand the cha llenges posed by safet y holes, we
ﬁrstconsidersometyp icalexamplesinLinux kernelinternal
API functions and the problems that these ex amples have
caused, as reﬂected by Linux patches. Then, we present
amethodologyforiden tifyingkindsofsafety holes,anduse
thismethodologytoen umeratethekindsofsa fetyholescon-
sidered in the rest of the paper. Finally, we consider how
tostaticallyidentifyp reconditionsontheses afetyholes,to
limitthegenerationof logmessagesinthedeb ugginginter-
facetocasesthatmay actuallycauseacrash orhang.
2.1 ExamplesofSafety Holes
BecausetheLinuxkern eldoesnotdeﬁneapre ciseinternal
API, we focus on the set of functions that a re made avail-
able to dynamically lo adable kernel modules using either
EXPORT_SYMBOLorEXPORT_SYMBOL_GPL. Dynamically load-
ablekernelmodulespr ovideaconvenientmea nstodevelop
newservices,astheya llowtheservicetobelo adedintoand
removed from a runni ng kernel for the testi ng of new ser-
vice versions. We refe r to kernel functions t hat are made
availabletosuchmodu lesaskernel exported functio ns.
Fig. 1a shows an exce rpt of the deﬁnition o f the kernel
exported functionskb_put, which dereferences it s ﬁrst ar-
gumentwithoutﬁrstc heckingitsvalue. Man ykernelfunc-
tionsarewritteninthis way,assumingthatalla rgumentsare
valid. Thiscoderepres entsasafetyhole,beca usethederef-
erenceisinvalidifthec orrespondingargument isNULL.Such
afaultoccurredinLinu x2.6.18intheﬁledrivers/net/force-
depth.c. Inthefunctionnv_loopback_test,skb_putiscalled
withitsskbargumentbeingtheres ultofcallingdev_alloc_-
skb, which can beNULL. The ﬁx, as impleme nted by the
patch shown in Fig. 1b , is to avoid callingskb_putin this
case.skb_putremainsunchanged.611unsigned char*skb put(structsk buﬀ*skb,unsigned intlen)
2{unsigned char*tmp=skb tailpointer(skb);
3 SKB LINEAR ASSERT(skb);
4 skb−>tail+=len; ...
5}
a) Excerpt of the deﬁn ition ofskb_put
1commit 46798c897e 235e71e1e9c46a5e6e9 adfffd8b85d
2 tx skb=dev allocskb(pktlen);
3+if(!tx skb){...gotoout;}
4 pkt data=skb put(txskb,pktlen);
b) Excerpt of the bug ﬁx patch
Figure 1: Bug ﬁx of the usage ofskb_put
Fig. 2a shows an exce rpt of the deﬁnition o f the kernel
exported functionopen_bdev_exclusive, which returns a
valueconstructedusing thekernelfunctionERR_PTRwhenan
errorisdetected. Dere ferencingsuchavalue willcrashthe
kernel. Thus,thisretu rnstatementalsorepre sentsasafety
hole. InLinux2.6.32,i ntheﬁlefs/btrfs/volumes.c,thefunc-
tionbtrfs_init_new_devi cecalledopen_bdev_exclusive
and compared the res ult toNULLbefore dereferencing the
value. Thistest, howe ver, doesnotpreventa kernelcrash,
because anERR_PTRvalue is diﬀerent fromNULL. Fig. 2b
showsapatchﬁxingth efault.
1structblock device*open bdevexclusive(
2 constchar*path,fmode t mode,void*holder)
3{
4...
5returnERR PTR(error);
6}
a) Excerpt of the deﬁn ition ofopen_bdev_exclusive
1commit 7f59203abe af18bf3497b308891f9 5a4489810ad
2 bdev=open bdevexclusive(...);
3−if(!bdev)return−EIO;
4+if(IS ERR(bdev))returnPTR ERR(bdev);
b) Excerpt of the bug ﬁx patch
Figure 2: Bug ﬁx of error handling code
In the previous cases, the safety hole is appa rent in the
deﬁnitionofakernelex portedfunction. Asafe tyhole,how-
ever, may also be inte rprocedural, making th e danger that
it poses more diﬃcult to spot. For example, as shown in
Fig. 3(a,b), the kernel exported functionkmap, deﬁned in
arch/x86/mm/highmem 32.c,passesitsargumentto thefunc-
tionpage_zonevia the macroPageHighMem, which in turn
forwardsthepointer,a gainwithoutensuring itsvalidity,to
thefunctionpage_to_nid. Thisfunctionthend ereferences
it,unchecked. Thissaf etyholeresultedinafa ult,whichwas
ﬁxedbythepatchshow ninFig.3c.
1void*kmap(structpage*page)
2{might sleep();
3if(!PageHighMem(pag e))
4...
5}
a) Excerpt ofkmap1staticinlineintpage tonid
2(structpage*page){
3return(page–>ﬂags>>...)
4&NODES MASK;
5}
b) Excerpt ofpage_to_nid
1commit 649f1ee6c7 05aab644035a7998d7b 574193a598a
2 page=read mapping page(...);
3+if(IS ERR(page)){...gotoout;}
4 pptr=kmap(page);
c) Excerpt of the bug ﬁx patch
Figure 3: Bug ﬁx of a use ofkmap2.2 TaxonomyofSafet yHoles
AsillustratedinSectio n2.1,somefragments ofcodeexe-
cutedbykernelexport edfunctions,whilethe mselvesbeing
correct,canprovokeke rnelcrashesorhangsw henthefunc-
tionisusedincorrectly. Wedistinguishbetweenentrysafety
holes,inwhichthecra shorhangisprovoked withintheex-
ecution of the kernel e xported function, due to an invalid
argument provided by the service, andexitsafety holes, in
whichthecrashorhan gisprovokedwithinth esubsequent
execution of the servic e due to a possible eﬀ ect of the ker-
nel exported function that the service has n ot taken into
account.
Asaﬁrstsourceofkin dsofsafetyholes,wec onsiderthe
faultkindsidentiﬁedb yChouet al.intheir2001studyo f
Linuxcode[5]. Afault isnotinitselfasafety hole,because
thefaultycodecanbe completelycontainedw ithinasingle
functiondeﬁnition. Lik ewise,asafetyholeis notinitselfa
fault,asillustratedby theaboveexamples. N onetheless,we
observethatmanyfaul tkindsinvolvemultipl edisjointcode
fragments. Whensom eofthesefragmentsa representina
kernelexportedfunctio nandtheremainderm aybepresent
inaserviceimplementa tion,wesaythattheke rnelexported
functioncontainsasafe tyhole. Forexample,aNULLpointer
dereferencefaulttypica llyinvolvesaninitializa tionofavari-
abletoNULLfollowedbyaderefere nceofthisvariable. R e-
turningNULLfrom a kernel exporte d function can cause i t
tobedereferencedins ervicecode,andreceiv ingNULLasan
argument in a kernel e xported function can l ead to aNULL
pointerdereferencein thekernelexportedfun ctioncode.
Theseobservationssug gestamethodologyfor translating
faultkindsintokinds ofsafetyholes. When thesuﬃxofa
sequence of code fragm ents associated with a fault kind is
foundinakernelexpor tedfunctionanddepen dsinsomeway
onthecallingcontext,e.g.,viaargumentsofthat function,
then that suﬃx repres ents an entry safety h ole. Likewise,
whenapreﬁxofsucha sequenceisfoundinak ernelexported
functionandhassome impactonthefunction ’sresult,then
thatpreﬁxrepresentsa nexitsafetyhole.
Table1summarizesth efaultkindsidentiﬁed byChouet
al., as well as the entry and exit safety hole ki nds that we
havederivedfromthes efaultkindsaccording totheabove
methodology. Forexam ple,giventheabovean alysisofthe
structureofaNullfaul t,thecorrespondingen trysafetyhole
isadereferenceofanun checkedpointerparame ter,whilethe
correspondingexitsafe tyholeisareturnofaNULLvalue.
2.3 SafetyHolePrecon ditions
From a collection of s afety holes, our goal is to create
adebugginginterface thatinformstheservic edeveloperof
possiblydangeroususe sofkernelexportedfu nctionswithin
his code. Nevertheless , merely invoking a ke rnel exported
functionthatcontains anentryorexitsafety holedoesnot
necessarily cause a fau lt. Instead, some pro perties of the
argument or return va lues, such as the prese nce of aNULL
value, must typically b e satisﬁed. Thus, we require infor-
mationnotjustabout safetyholes,butalsoa boutthepre-
conditionsthatmustb esatisﬁedtoensureth atnofaultcan
occur[16]. Wefurtherm oredistinguishbetween safetyholes
that arecertain, if violation of the pr econdition is guaran-
teed to result in a cra sh or hang within the execution of
thekernelexportedfu nction,orpossible,ifviolationofthe
preconditionmaycaus eacrashorhangonat leastonepos-62Table 1: Categoriza tion of common fau lts in Linux [5]. EF refers to theexported function.
Category Actions to avoid faults safety hole safety hole descript ion Analysis type
BlockToavoiddeadlock,do notcallblockingfunct ionsentryEFcallsablo ckingfunction(functio nreferencingGFP KERNEL) interproc edural
withinterruptsdisable doraspinlockheldexitEFre turnsafterdisablingin terruptsorwhileholdi ngalock intra/inter procedural
NullCheckpotentiallyNUL L/ERRPTRpointersentryEFd ereferencesanargumen twithoutcheckingits validity interprocedu ral
returnedfromroutines exit EFreturnsaNULL/E RRPTRpointer interpro cedural
VarDonotallocatelarges tackvariables(>1K)entryEF allocatesanarraywho sesizedependonapa rameter intraprocedu ral
ontheﬁxed-sizekerne lstack exit EFreturnsalargevalu e interprocedural
INullDonotmakeinconsist entassumptionsaboutentryEFd ereferencesanargumen twithoutcheckingits validity interprocedu ral
whetherapointerisN ULL/ERRPTRexit EFreturnsaNULL/E RRPTRpointer interpro cedural
RangeAlwayscheckboundso farrayindicesentr yEFuse sanuncheckedparame tertocomputeanarra yindex intraprocedu ral
andloopboundsderiv edfromuserdataexit EFreturnsavalueobt ainedfromuserlevel interprocedural
Lock Released acquiredlocks;donot double-acquirelocksentry EFacquiresalockder ivedfromaparameter interprocedural
exit EFreturnswithoutrel easinganacquiredlock interprocedural
Intr Restored isabledinterruptsentry EFcallsablockingfun ction interprocedural
exit EFreturnswithinterr uptsdisabled intrapr ocedural
Free Donotus efreedmemoryentry EFdereferencesapoin ter-typedparameterva lue none
exit EFfreesmemoryderiv edfromaparameter interprocedural
Float Donotus eﬂoatingpointinthe kernel These fault kinds depen ds on local properties a nd are thereforenone
RealDonotleakmemoryb yupdatingpointers not relevant to the inte rface between a servicenone
withpotentiallyNULL reallocreturnvalues and the kernel exported functions
Param Donotde referenceuserpointersentry EFdereferencesapoin ter-typedparameter none
exitEF returnsapointer-typed valueobtainedfromus erlevel interprocedu ral
SizeAllocateenoughmemo rytoholdtheentr yEF allocatesmemoryofa sizedependingonapa rameter intraprocedu ral
typeforwhichyouare allocatinge xit EFreturnsaninteger value none
sible execution path. All exit safety holes a repossible, as
theusagecontextofth efunctionresultisunk nown.
3. KERNELDEBUGG ING
Each of the examples presented in Section 2 could crash
thekernel. Whenthis occurs,thekernelgene ratesanoops
report, consisting of t he reason for the cras h, the values
ofsomeregistersanda backtrace,listingthef unctioncalls
pendingonthestack. Usingthisinformation indebugging
raisestwoissues: 1)th ereliabilityoftheprov idedinforma-
tion,and2)therelevan ceoftheprovidedinfor mationtothe
actualfault. Debuggin gkernelhangsraisesfu rtherissues.
Reliabilityofkerneloops reports. Linuxkernelbacktrace s
suﬀer from the proble m ofstale pointers,i.e., addresses
within functions that have actually already returned. To
illustrate this problem , we consider a crash occurring in
the functionbtrfs_init_new_devi cepreviously shown in
Fig.2. Thecrashoccur redbecausethekernele xportedfunc-
tionopen_bdev_exclusivereturnsanERR_PTRvalueincase
ofanerror,whilebtrfs_init_new_devi ceexpectsthatthe
valuewillbeNULL.Thiscausedasubsequ entinvalidpointer
dereference.
To replay the crash, w e installed a version o f thebtrfs
module from just befo re the application of t he patch. To
causeopen_bdev_exclusivetofailweﬁrstcreatean dmount
abtrfsvolume and then atte mpt to add to this vol ume a
newdevicethatisnoty etcreated. Thisoperat ionishandled
bythebtrfs_ioctl_add_devioctlwhichcallsbtrfs_init_-
new_devicewiththedevicepatha sanargument. Thispa th
valueisthenpassedtoopen_bdev_exclusivewhichfailsto
locatethedeviceandre turnsanERR_PTRvalue. Fig.4shows
an extract of the resul ting oops report. Line 1 shows that
thecrashisduetoan attempttoaccessanin validmemory
address. Line 5 shows that the faulty operat ion occurred
in the functionbtrfs_init_new_devi cea priori during a
calltobtrfs_ioctl_add_dev(line8). Sourceﬁlesa ndline
numberscanbeobtain edbyapplyingthestan darddebugger
gdbtothecompiledmodu leandtothecompiled kernel.1[847.353202]BUG:unable to handle ke rnel paging request at
2 ﬀﬀ ﬀee
3[847.353205]IP: [<fbc722d9>]btrfs initnewdevice+0xcf/0x5c5
4[btrfs]
5[847.353229] *pdpt= 00000000007ee001 *pde= 00000000007ﬀ067
6[847.353233]Oops: 0000 [#1] ...
7[847.353291]EIP is at btrfs initnewdevice+0xcf/0x5c5 [btrfs] ...
8[847.353298]Process btrfs−vol(pid: 3699, ...
9[847.353312]Call Trace:
10[847.353327] [<fbc7b84e>] ?btrfs ioctladddev+0x33/0x74 [btrfs]
11[847.353334] [<c01c52a8>] ?memdup user+0x38/0x70 ...
12[847.353451]−−−[end trace69edaf4b4d3762ce ]−−−
Figure 4: Oops re port following abtrfs ERR_PTR
pointer dereference crash.
This backtrace contain s possibly stale pointe rs, as indi-
catedbythe?symbolonlines8and 9. Whilebtrfs_ioctl-
_add_devreally does callbtrfs_init_new_devi ce, this is
not the case ofmemdup_user. Since it cannot be k nown a
priori whether a funct ion annotated with?is really stale,
theservicedeveloperh astoﬁndandstudyth edeﬁnitionsof
allofthefunctionsatt hetopofthebacktrace ,untilﬁnding
the reason for the cra sh, including the deﬁn itions of func-
tionsthatmaybecom pletelyunrelatedtoth eproblem. A
goal of the kernel deb ugger kdb,1which was merged int o
the mainline in Linux 2.6.35, was to improv e the quality
of backtraces. Nevert heless, backtrace quali ty remains an
issue.2
Relevance of kernel oops reports. A kernel oops back-
trace contains only th e instruction causing the crash and
thesequenceoffunctio ncallsconsideredtobe onthestack.
The actual reason for a crash, however, may occur in pre-
viouslyexecutedcode thatisnotrepresented . Forthefault
shown in Fig. 2, the o ops report mentions a dereference of
the variablebdevin the functionbtrfs_init_new_devi ce,
but the real source of the problem is at the initialization
ofbdev,totheresultofcallin gopen_bdev_exclusive. This
1https://kgdb.wiki.ke rnel.org/
2https://lkml.org/lkm l/2012/2/10/12963Figure 5: The steps in using Diagnosys
call has returned and thus no longer appears on the stack.
Suchsituationsmaked ebuggingmorediﬃcult asthedevel-
opermustthoroughlyc onsultkernelandservi cesourcecode
tolocalizeimportanti nitializationcodesites .
Kernel hangs. Bydefault,theLinux kernelgivesnofeed-
backinthecaseofak ernelhang. Itcan,how ever,becon-
ﬁgured to panic when it detects no progress over a certain
period of time. When the hang is due to an inﬁnite loop,
thebacktraceresulting fromthepaniccanocc uranywhere
within this loop; the p oint of the panic may thus have no
relationtotheactuals ourceoftheproblem.
4. DIAGNOSYS
ThegoalofDiagnosys istoimprovethequali tyofthein-
formation available wh en a crash or hang oc curs and this
crash or hang results from a safety hole in a kernel ex-
portedfunction. Theu seofDiagnosysinvolve sthreephases
(Fig.5): 1)identiﬁcati onofsafetyholesinke rnelexported
functionsandinference oftheassociatedpreco nditions,us-
ingthestaticanalysis toolSHAna,2)automa ticgeneration
ofadebugginginterfac eusingDIGenbasedo ntheinferred
preconditions,and3)t estingservicecodewit hthesupport
of the debugging inter face. The ﬁrst phase is carried out
only once by a kernel maintainer, for each n ew version of
the mainline Linux ke rnel,3and the remaining ph ases are
carriedoutbyeachser vicedeveloperwhowo uldliketouse
Diagnosys.
4.1 IdentifyingSafety HolesandPreconditions
SHAnaﬁrstsearchesth ekernelcodeforoccurr encesofthe
kindsofsafetyholeslis tedinTable1,andthen computesthe
preconditionsthatare requiredtoholdtoens urethatthese
safetyholesdonotcau seakernelcrashorhan g. Theanaly-
sisfocusesonunsafeop erationsthatoccurinc odethatisin
orisreachablefroman exportedfunction. For eachsuchoc-
currence,abackwarda nalysisamountingtoa simpleversion
ofHoarelogic[16]pro ducestheweakestprec onditiontobe
satisﬁedonentrytoth efunction,forentrysa fetyholes,and
onexitfromthefunctio n,forexitsafetyholes, suchthatthe
safetyholewillnotcau seacrash. SHAnaisim plementedus-
ingtheCoccinelleprog ramanalysistool[24],w hichanalyzes
all of the code, regard less of the code’s targ eted hardware
platform,makingitpo ssibletoﬁndallsafety holesinasin-
glerun. Theresultof SHAnaisalistmappi ngeachkernel
3Each Linux distribut ion may add some sp eciﬁc patches to the Linux
kernel. These are u nlikely to aﬀect the kernel API. Further more a
service that should u ltimately be integrat ed into the mainline kernel
must be developed a gainst the API supp orted by that kernel .exportedfunctioniden tiﬁedascontainingsafe tyholestothe
associatedprecondition s.
The analysis starts fr om the deﬁnition of a n exported
function, recognized a s one declared usingEXPORT_SYMBOL
orEXPORT_SYMBOL_GPL.Table1indicatesfor eachcategory
of safety hole whether intraprocedural, interp rocedural or
noanalysisisused. In searchscenariosthato nlyrequirein-
traprocedural analysis, the analyzer scans the deﬁnition of
the exported function to identify code fragm ents that rep-
resent safety holes. Fo r example, in searchin g for Intr exit
safetyholes,SHAnaon lylooksforinterruptdi sablingopera-
tionsinthekernelexpo rtedfunctionitself,bec auseinterrupt
stateﬂagsshouldnotb epassedfromonefunct iontoanother
[28]. In the case of int erprocedural analysis, SHAna starts
from the deﬁnition of an exported function a nd iteratively
analyzesallcalledfunc tions.4Forexample,insearch ingfor
Null entry safety holes , SHAna searches thro ugh both the
kernelexportedfunctio nitselfandallcalledf unctionsthat
receiveaparameterof thekernelexportedfun ctionasanar-
gumenttoﬁnduncheck eddereferences. SHAn afurthermore
includesuncheckedder eferencesofvaluesthat somehowde-
pendonthevalueofa nuncheckedparameter .
4.2 GeneratingandIn tegratingaDebugging
Interface
Basedontheresultsof SHAna,DIGengenerat esadebug-
ginginterfaceasacolle ctionofwrapperfunct ionsthataug-
ment the deﬁnitions o f kernel exported func tions with the
necessary checks and calls to logging primit ives, to detect
and record violations of safety hole precond itions. Ideally,
thekernelmaintainerw horunsSHAnawoulda lsogeneratea
singledebugginginterf acefortheentirekerne lthatcouldbe
used by all service dev elopers. Unfortunately , many kernel
sourceﬁlestargetspeci ﬁchardwareplatforms, andthushave
mutually incompatible header ﬁle dependenci es, making it
impossibletocompilea singledebugginginterf acewrapping
allofthekernelexport edfunctionsatonce. A ccordingly,we
shift the interface gene ration process into the hands of the
servicedeveloper,who generatesaninterface speciﬁctohis
service. Because the f unctions invoked by a single service
can necessarily be com piled together, this ap proach avoids
allcompilationdiﬃcul ties,whileproducinga debuggingin-
terfacethatissuﬃcient foranindividualservic e’sneeds. We
nowdescribethegener ationofthedebugging interfaceand
howitisintegratedint oaserviceunderdevel opment.
Generating a debugging interface. For each kernel ex-
ported function that i s used in the service and for which
SHAnaidentiﬁedatlea stonesafetyhole,DIG engeneratesa
wrapperfunction. The generalstructureofsuc hawrapperis
showninFigure6. Bas edontheargumentval ues,thewrap-
perﬁrstcheckseache ntrysafety-holeprecon dition(line4)
andthen,iftheprecon ditionisnotsatisﬁed,l ogsamessage
indicating the violatio n. This message inclu des the safety
hole category, which s peciﬁes the kind of sa fety hole and
whether the violation iscertainorpossible(line 5), as de-
ﬁned in Section 2.3. The wrapper then cal ls the original
function. If the origin al function has a retu rn value, this
valueisstoredinaloc alvariable,__ret,andthenthepre-
conditionsonanyexit safetyholesarechecked basedonthis
4Theanalysisstopsatf unctionpointers.641staticinline�rtype� debug�kernel function�(...){
2�rtype� ret;
3/* Check precon ditions for entry saf ety holes */
4if�an entry safety−hole precondition is violated�
5 diagnosys log(�EF id�,�SH cat�,�info(e.g.,arg number)�);
6/* Invocation of the intended kernel function */
7ret=�call to kernel functio n�;
8/* Check precon ditions for exit safe ty holes */
9if�an exit safety−hole precondition is violated�
10 diagnosys log(�EF id�,�SH cat�,�info(e.g.,err ret type)�);
11/* Forward the return value */
12return ret;
13}
14#deﬁne�kernel function� debug�kernel function�
Figure6: Wrappers tructureforanon-v oidfunction
information(lines9-10 ). Finally,thereturnv alue,ifany,of
theoriginalfunctionis returnedastheresult (line12).
Integrating a debugging interface into a service. The
generated debugging i nterface is implemente d as a header
ﬁletobeincludedint heservicecode. Once compiledwith
theinterfaceincluded, theserviceusesthewra pperfunctions
insteadofthecorrespo ndingkernelexported functions.
Diagnosysprovidesan automatedscript,dmake,thatman-
ages the generation of a debugging interface. This script
(1)compilestheorigin alservicecode,(2)ide ntiﬁestheker-
nel exported functions referenced by the resu lting object
ﬁles,(3)generatesani nterfacededicatedtot hesefunctions,
and(4)recompilesthe servicewiththeinterfa ceincluded.
4.3 RunningServiceC odewithDiagnosys
TobeabletouseaDia gnosys-generateddebu gginginter-
face, theservicedevelo permustuseaversion oftheLinux
kernelprovidingsuppo rtfortheDiagnosysru ntimesystem.
Thissupportisexpres sedasakernelpatch, whichwehave
implementedforLinux 2.6.32,thatextendsth ekernelwith
acrashresilientlogging system. Thepatchadd itionallycon-
ﬁguresthekerneltose ndallcrashesandhan gs(Linuxsoft
and hard lockups) to the kernel panic funct ion, which the
patch extends to rebo ot into a specialcrash kernelif Di-
agnosys is activated o r to continue with a normal panic,
otherwise. Finally,the Diagnosysruntimesyst emincludesa
toolthatcanberunfr omuserspacetoinstal lacopyofthe
Diagnosyskernelasac rashkernel,initializeth ereservedlog
buﬀer,andactivatean ddeactivatelogging.
Once the Diagnosys lo gging system has been activated,
theservicedeveloperm aytesthiscodeasusua l. Duringser-
viceexecution,ifawra pperfunctiondetectsa safetyholefor
which the precondition is violated, the wrapp er logs infor-
mationaboutthesafet yholeinareservedar eaofmemory,
annotatedwithatime stampandincludingth ememoryad-
dressofthecallsite. T hereservedareaofme moryisman-
aged through a ring b uﬀer that retains infor mation about
onlythemostrecentv iolations.
On a kernel crash or hang, the Diagnosys r untime sys-
tem uses a Kexec-bas ed [23] mechanism to reboot into a
new instance of the D iagnosys-enabled kerne l. The Kexec-
basedmechanismperfo rmstherebootwithou treinitializing
anyhardware,includin gthememory,thusens uringthatthe
accumulatedDiagnosy slogisstillavailable. T heservicede-
velopermaythenacces sthelogmessagesthro ughapseudo
character device. The messages are made av ailable in the
orderinwhichtheyw eregenerated. Whena crashoccurs,Table 2: Diagnosys prototype code size
Diagnosyscomponent Tool C odesize(LOC) Language
Kernelcodeanalyzer SHAna 2438+1331 SmPL[2 4]+OCaml
Wrappergeneratordmake+DIGen 49+1301 s h+OCaml
Loggingsystemuser-space 115+3 55 sh+an siC
kernel-space 645 ansiCcodepatch
the Diagnosys runtime system also inserts the kernel stack
traceintotheDiagnos yslogbeforerebooting .
4.4 Implementation
Table 2 gives the code sizes of the various pa rts of our
prototype Diagnosys im plementation. The im plementation
includes the SHAna a nalysis of Linux kerne l, DIGen and
dmakefor generating and c ompiling wrappers for a given
service,andthepatch fortheruntimesystem .
5. EVALUATION
In designing Diagnosy s, we have chosen to f ocus on the
interfacebetweenthes ervicecodeandtheke rnel. Weﬁrst
assessthenumberofs afetyholesinthisinte rfaceandtheir
pastimpactonkernel robustness,asevidence dbycommits
totheLinuxkernel. W ethenassessthediﬃc ultyofdebug-
gingkernelfaultsderiv edfromsafetyholes,b ystudyingthe
feedbackmadeavailab letotheservicedevelo peronacrash
or hang without Diag nosys, namely the ker nel backtrace.
Then, we assess the co verage of Diagnosys w ith respect to
thepossiblecrashesan dhangsthataretrigge redbymisuse
oftheinterfacebetween theservicecodeandth ekernel,and
showthattheDiagnos yslogmessagesallowt heservicede-
velopertoﬁndthecaus eofacrashorhangmor erapidlythan
whenrelyingonakern elbacktracealone. Fin ally,weshow
thatDiagnosysincursa suﬃcientlylowruntime overheadto
beembeddedinaservi ce,uptotheearlydepl oymentphase.
Our experiments use c ode from Linux 2.6.32 , which was
releasedinDecember2 009. Thisversionisus edinthecur-
rent Long Term Supp ort version of UbuntuR�(10.04), in
RedHatEnterpriseLin ux6,inOracleLinux, etc. Ourper-
formance experiments are carried out on a D ell 2.40 GHz
IntelR�CoreTM2 Duo with 3.9 GB of RAM. Unless other-
wiseindicated,theOS isrunningaLinux2.6. 32kernelthat
hasbeenmodiﬁedtos upporttheDiagnosys logginginfras-
tructure. 1MBisreser vedforthecrash-resili entlogbuﬀer.
5.1 PrevalenceandIm pactofSafetyHoles
Diagnosysisonlybeneﬁ cialifSHAnaidentiﬁes safetyholes
infunctionsthatareu sedbyawiderangeof driversandif
thesefunctionsarelike lytobeusedinaninc orrectway. In
this section, we assess the number of safety h oles collected
bySHAnaandthenstu dytheimpactthesesaf etyholeshave
hadontherobustness oftheLinuxkernelitse lf.
In Linux 2.6.32, SHA na reports 22,940 safe ty holes in
7,505exportedfunctio ns. Table3summarize sforeachkind
ofsafetyholethenumb eroffunctionsthatSH Anaidentiﬁes
ascontainingatleast oneoccurrenceofthat kindofsafety
hole. Inthelargestca tegory,INull/Null,abo ut94%ofthe
reportedfunctionsperf ormunsafedereference sdirectly,and
5%forwardtheparam etervaluetootherfun ctionsthatun-
safelyusethemwithno priorcheck. Around1% performun-
safe dereferences on va riables whose validity are indirectly
correlated to that of pointer parameters. D efects due to65safetyholesinthelatte rtwocategoriesaremo rediﬃcultfor
theservicedevelopert oidentify.
Table 3: Prevalence of safety holes in Li nux 2.6.32
SafetyholeNumberofexportedfu nctionscollectedinthe
entrysub-category exitsub-category
Block 367 815
INull/Null 7,220 1,124
Var 5 11
Lock/Intr/LockIntr 815 23
Free - 11
Size 8 -
Range - 8
Static analysis is neces sarily approximate, as it does not
havecompleteaccesst orun-timevalues. Th ismayleadto
falsepositives,inwhich asafetyholeisreporte dthatinfact
cannotleadtoacrash. Suchfalsepositivescan increasethe
logging time and clutt er the log with irrelev ant messages.
Nevertheless,havingst udiedthecompleteset ofresultsfor
Linux 2.6.32, we have found only 414 false p ositives, out
ofthe22,940reported safetyholes. 405ofth esearedueto
thepresenceofmultiple ,conﬁguration-speciﬁc, deﬁnitionsof
somefunctions. SHAn aannotatessafetyhole sderivedfrom
calls to such functions with the ﬁle in which the relevant
function instance is de ﬁned, so that the serv ice developer
canremovethosethat arenotrelevanttohis conﬁguration.
Of the 147,403 call sit es across the entire ke rnel source
codewhereexportedfu nctionsareused,halfi nvokeafunc-
tioncontaininganiden tiﬁedsafetyhole. This suggeststhat
the kernel exported fu nctions containing saf ety holes are
likelytobeusefulton ewservices.
Toassessthepastimpa ctoftheidentiﬁedsafet yholesover
the course of the deve lopment of Linux, we have searched
through the 278,078 c ommits to Linux 2.6,5from 2.6.12
to2.6.39.3,toidentify thosewhosechangelog mentionsthe
nameofatleastoneker nelfunctionexportedin Linux2.6.32,
ignoringchangelogsin whichthefunctionnam eisusedasa
commonword(e.g.,“sort”,“panic”,etc.). Linuxcommitsby
convention make only a single logical change , thus making
theanalysisprecise.6703ofthesecommitsc ontainbugsde-
scribed in kernel chang elogs7that are related to the usage
ofexportedfunctions. 267ofthem,i.e.,38%arerelatedto
thecategoriesofsafety holesthatweconsider inthispaper.
5.2 KernelDebugging withDiagnosys
As discussed in Sectio n 3, kernel debugging is made dif-
ﬁcultbyunreliablebac ktracesandbytheque stionablerel-
evance of the informa tion in crash reports. To assess the
qualitativebeneﬁtsof Diagnosys,wehavere playedacrash
andahangreportedin kernelcommitlogs.
Replayingakernelcrash. Asanexampleofkerne lcrash,
we again consider thebtrfsexample of Fig. 2. Study of
the corresponding cras h report in Fig. 4 sho wed that the
sourceoftheproblem wasnotreadilyavailab leintheback-
trace. We have therefo re replayed the same e xecution sce-
nario when using Diag nosys. A typical Diag nosys log line
contains the timestam p of the log, the sourc e ﬁle and line
number where the uns afe call was performed , the name of
the exported function, the category of the sa fety hole and
5git://git.kernel.org/p ub/scm/linux/kernel /git/torvalds/linux.g it.
6Documentation/Sub mittingPatches in th e Linux kernel sourc e tree,
http://www.kernel.o rg
7http://www.kernel.o rg/pub/linux/kernel /v2.6/possibly the name of a relevant argument or a n unsafe re-
turn value. In the ca se of the replay of th ebtrfscrash,
Fig. 5.2 shows the la st line added to the Diagnosys log
before the crash, whi ch is the line that th e developer is
likely to consult ﬁrst. This line shows that the function
open_bdev_exclusiveactivatedanInullexit safetyholeby
returninganERR PTR.Italsoreportst heruntimetimes-
tamp and the call site where the safety hole was violated.
Combiningthisinform ationwiththeinforma tionaboutthe
crash site in the oops report and the service source code
shows that the proble m is the inadequate e rror handling
codeafteropen_bdev_exclusive.
1[4294934950]|@/var/diagnosys/tests/my btrfs/volumes.c:1441|
2 open bdevexclusive|INULL(EXITED)|ERR PTR|
Figure7: Diagnosys loglineintheexecu tionofbtrfs
Replaying a kernel hang .Kernel hangs are noto riously
hardtodebug8asthepanic,whichocc urslongaftertheac-
tualfault,canproduce abacktracethatishar dtocorrelate
tothesourceofthepro blem. Diagnosysrecord sinformation
aboutpreviouspotenti allydangerousoperatio ns.
Just before the release of Linux 2.6.33, thenouveau_drm
nVidiaR�graphics card driver c ontained a hang resul ting
from the use of the ke rnel exported functionttm_bo_wait.
Thisfunctionexhibits aLockentrysafetyho leandaLock
exitsafetyhole,asitﬁr stunlocksandthenrel ocksalockre-
ceivedviaitsﬁrstargu ment. Thenouveau_drmdrivercalled
thisfunctionwithouth oldingthislock,hangin gthekernel.
In Fig. 8a, the last lin e of the Diagnosys log shows that
ttm_bo_waithasbeencalledwithou ttheexpectedlockheld .
Correlating this inform ation with the source code suggests
takingthelockbefore thecallandreleasingi tafterthecall,
asshownintheLinux patchinFig.8b.
1[437126]|@/var/diagnosys/tests/nouveau/nouveau gem.c:929|
2 ttm bowait|LOCK/ACQUIRE(POSSIBLE)|bo−>lock|
a) Diagnosys log line in the execution ofnouveau_drm.
1commit f0fbe3eb5f 65fe5948219f4ceac68 f8a665b1fc6
2+spin lock(&nvbo−>bo.lock);
3 ret=ttm bowait(&nvbo−>bo,false,false,no wait);
4+spin unlock(&nvbo−>bo.lock);
b) Bug ﬁx related to t he usage ofttm_bo_wait.
Figure 8: Fault invo lving a Lock safety hole in
nouveau_drm
5.3 QuantifyingtheDe buggingBeneﬁt
Tobeuseful, Diagnosy smustcoverahighpe rcentageof
the misuses of kernel exported functions. W e ﬁrst evalu-
atethisbyartiﬁciallyc reatingandactivating misusesofex-
portedfunctionsinker nelservicesandmeasu ringhowmany
aretrappedbyDiagno sys. Additionally,Diag nosysmustbe
able to produce log m essages that ease the d ebugging pro-
cess. We evaluate the debugging eﬀort by m easuring the
numberofﬁlesandfun ctionsthathavetobes tudiedtoiden-
tifythecauseofacras h,withandwithoutD iagnosys. Our
experiments involve a number of commonly used kinds of
services: networkingco de,USBdrivers,multim ediadrivers,
and ﬁle systems. Serv ices of these kinds ma ke up over a
8http://www.linuxjou rnal.com/article/574 966third of the Linux 2.6 .32 source code. We h ave selected a
rangeofservicesthatr unonourtesthardwa re(Table4).
Table 4: Tested Lin ux 2.6.32 services
Category Servic e module DescriptionUsed functions
with safety holes
Networkinge1000e Ethernetadapter 57
iwlagn Intel WiFiNextGenAGN 57
btusb Bl uetoothgenericdriver 26
USB driversusb-storage Mass storagedevicedriver 51
ftdisio USBt oserialconverter 31
Multimediauvcvideo Webcamdevicedriver 28
device driverssnd-intel8x0 ALSAdriver 35
File systemsisofs ISO9660ﬁlesystem 26
nfs Networkﬁlesystem 198
fuse Fi lesysteminuserspace 86
CoverageofDiagnosys. Todeterminethecover ageofDi-
agnosys,weﬁrstmutat eexistingservicessoas toartiﬁcially
createbugs. Then,wei njectfaultsatrun-time topotentially
causethemutationto triggeracrash.
Sincethelargestperce ntageofouridentiﬁed safetyholes
are related toNULLandERR_PTRdereferences, we focus on
thesesafetyholes. One prominentsourceofsu chvaluesisas
theresultofacalltoa functionthathasfailed inperforming
somesortofallocation . Robustkernelcodec hecksforthese
values and aborts the ongoing computation. Nevertheless,
omission of these tests is common. For exam ple, in Linux
2.6.32,evenforthesta ndardkernelmemorya llocationfunc-
tionskmalloc,kzalloc, andkcalloc, over 8% of the calls
thatmayfaildonotte sttheresultbeforeder eferencingthe
returnedvalueorpassi ngittoanotherfuncti on.
Based on these observ ations, our experimen ts focus on
missingNULLandERR_PTRtests in the service c ode. Our
mutations remove such tests from the service code, one by
one,andusethefailslabfeatureoftheLinuxf aultinjec-
tioninfrastructure[6] withintheinitializatio nofthetested
value to inject failures into the execution of any call to a
basicmemoryallocatio nfunctionthatthisin itializationin-
volves. Becausethein itializationcaninvoke basicmemory
allocationfunctionsmu ltipletime,asinglemu tationexper-
imentmayinvolvemul tipleinjectedfaults.
One possible result is that there is no obser vable eﬀect.
This occurs when the called function does n ot involve a
memoryallocation,wh enthefailureofmemo ryallocations
doesnotleadtoaNULLorERR_PTRresult,orwhenthesaf ety
holeispossibleandisnotencountere dintheactualexecu-
tion. Anotherpossibili tyisthatthereisacr ash,butthere
isnorelevantinformat ionintheDiagnosyslo g. Inthiscase,
eithertheloginformat ionhasbeenoverwritte n,SHAnahas
notdetectedthesafety hole,orthecalltoake rnelexported
function occurs in a h eader ﬁle that, for tech nical reasons,
hastobeincludedbefo retheDiagnosyswrapp erdeﬁnitions.
Athirdpossibilityist hatthereisacrashan dtheinforma-
tionislogged,represen tingasuccessforDiag nosys.
We have evaluated the coverage of Diagnosys on the 10
serviceslistedinTable 4. RemovingtheNULLandERR_PTR
tests one by one leads to 555 mutated servic es. For each
mutated service, we h ave exercised the vari ous execution
paths of the aﬀected module in order to ex ecute the mu-
tated code. The result s are shown in Table 5 . 56% of the
mutations resulted in a kernel crash. After r eboot, in 90%
ofthecrashes,thelog containedinformation relevanttothe
crashoriginandin86% ofthecrashes,alogwa spresentand
itwasadditionallyint helastposition. Foron eservice,thelatteronlyholdsfor66 %ofthecrashes,butth isamountsto
onlyonemissinglog,a sthisservicehasfewm utationsites.
Table 5: Results of the mutation exper iments
CategoryKernel
module# of
mutations# of crashes with
Coverage
nologlogis
notlastlogis
last
Networkinge1000e 57 0 0 20 100%
iwlagn 18 1 0 8 88.9%
btusb 9 1 0 7 87.5%
USB driversusb-storage 11 0 0 3 100%
ftdisio 9 0 0 6 100%
Multimediasnd-intel8x0 3 1 0 2 66.7%
device driversuvcvideo 34 3 3 17 73.9%
File systemsisofs 28 3 0 9 75.0%
nfs 309 13 9 157 87.7%
fuse 77 3 1 41 91.1%
Ease of the debugging p rocess. Provided with an oop s
reportcontainingaba cktraceanddebugging toolsthatcan
translate stack entries into ﬁle names and lin e numbers, a
developertypicallysta rtsfromthepointofth ecrash,visit-
ingallﬁlesandcallerf unctionsuntiltheorigi nofthecrash
is localized. When the crash occurs deep in t he execution,
thenumberoffunction sandﬁlestovisitcan becomelarge.
We have considered 1 99 of the mutations p erformed in
ourcoverageteststhat leadtocrashes,fromb tusb,nfs,and
isofs. We also conside r 31 mutations in nfs code that add
statements for arbitra rily acquiring and rele asing locks in
servicesinordertopro vokekernelhangs,focu singonlocks
thatarepassedbetwee nfunctionsastheycan triggersafety
holesincorekernelcod e.
We have compared the 230 oops reports with the corre-
spondingDiagnosyslog s. In92%ofthesecras hes,theDiag-
nosyslogcontainsinfor mationontheoriginof thefault. For
thosecases,debugging withtheoopsreporta lonerequired
consulting1to14func tions,includingonaver ageonepossi-
blystalepointer,inup to4diﬀerentﬁlesdistr ibutedacross
kernel and service cod e. In 73% of the cases for which the
Diagnosys log contain s relevant information , we ﬁnd that
usingDiagnosysreduce sbyatleast50%then umberofﬁles
andfunctionstoconsu lt. In19%ofthecases forwhichthe
Diagnosys log contains relevant information, t he crash oc-
curredinthesameﬁle asthemutation, butt heDiagnosys
log made it possible to more readily pinpoint the fault by
providinglinenumbers thatareclosertothem utationsite.
5.4 Overhead
Introducingwrapperso nkernel-exportedfunc tionsincurs
aperformanceoverhea donserviceexecution. Toassessthe
impactofthisoverhead ,weexecutevariousrea l-worldkernel
serviceswithandwith outadebugginginterfa ce.
Networkdriverperf ormance.Ourﬁrsttestinvolves a
GigabitEthernetdevic ethatrequiresbothlo wlatencyand
high throughput to gu arantee high performa nce. We eval-
uate the impact of a d ebugging interface by exercising the
e1000eLinuxdevicedri verusingtheTCP STREAM,UDP -
STREAMandUDP RRtestsfromthenetp erfbenchmark.9
Fortheseexperiments, thenetperfutilitywas conﬁguredto
reportresultsaccurate to5%with99%conﬁd ence. Table6
summarizestheperform anceforthee1000edri verwhenrun
withoutandwithade bugginginterface. The debuggingin-
terfaceonlyreducesth ethroughputby0.4% to6.4%.
9http://www.netperf. org67Table 6: Performan ce of thee1000edriver
Test Without Diagnosys With Diagnosys O verhead
TCP_STREAMThroughput 9 07.91Mb/s 9 04.32Mb/s 0 .39%
UDP_STREAMThroughput 9 51.00Mb/s 9 47.73Mb/s 0 .34%
UDP_RRThroughput 7371.69Tx/s 6902.81Tx/s 6.36%
File system perform ance.Our second test inv olves
theNFSﬁlesystem,w hoseimplementationu sesaround200
exportedfunctionsexh ibitingsafetyholes. Th eexperiment
consistsofsequentialb lockreadandwriteph asesaccessing
records of a given size based on patterns gen erated by the
IOzone ﬁle system ben chmark.108G of data are accesse d.
Forthisexperiment, th eclientandserverrun onthesame
machine, connected us ing a loopback interfa ce. Read and
writeoperationsarepe rformedinthedirectI/ Omodewith
varyingrecordsizes. W ithadebugginginterfa ceintegrated
intothenfsﬁlesystem,wehavere cordedaround16milli on
callstotheinterfacew rapperfunctionswhen usingarecord
size of 512 Kb. As sh own in Table 7, the o verhead varies
between3%and11%, dependingontherecor dsize.
Table 7: Performan ce of the NFS ﬁle sy stem
Record blockWithout Diagnosys With DiagnosysOverhead(Accessrate: K/sec) (Accessrate: K/sec)
size(Kb) read/w rite read/ write read/wr ite
128 45309 /31672 4214 1/28072 6.99%/1 1.36%
256 49780 /36577 4819 6/32900 3.18%/1 0.05%
512 49764 /39957 4576 5/37981 8.03%/ 4.94%
6. RELATEDWORK
In the last decade, stu dies have shown that kernel-level
services,inparticulard evicedrivers,arerespo nsibleforthe
majority of OS crashe s. Ganapathiet al.have found that
65%ofallWindowsXP crashesareduetodevic edrivers[14].
Tenyearsago,Chouetal.foundthatthefaultra teinLinux
drivers is 3–7 times hi gher than that of othe r parts of the
kernel[5]. Palixet al.haveshownthatwhile thiserrorrate
is decreasing, Linux dr ivers still contain man y defects [25].
Theyhavealsofound thatﬁlesystemshave recentlyhada
highfaultrate,indeed evenhigherthanthat ofdrivers.
System robustness testing .Fault injection has be en ap-
pliedtotheLinuxkern eltoevaluatetheimpa ctofvarious
fault classes [1, 7]. Ou r work identiﬁes the s afety holes in
kernelinterfacesthate xplaintheirobservatio ns. Marinescu
and Candea [20] focus on the returns of erro r codes from
userspacelibraryfunct ions. Theseareanalogo ustoourNull
exitsafetyholes. Their approach,however,isn otapplicable
toothertypesofsafety holes.
Static bug ﬁnding. Modelchecking,theore mproving,and
programanalysishave beenusedtoanalyzeO Scodetoﬁnd
thousands of bugs [3, 9, 18, 26]. Neverthele ss, these tools
taketimetorunandt heresultsrequiretime andexpertise
to interpret. Thus, th ese tools are not well suited to the
frequent modiﬁcations and tests that are typ ical of initial
codedevelopment. Nu merousapproacheshav eproposedto
statically infer so-calle dprotocols, describing expected se-
quences of function ca lls [9, 18, 19, 27]. The se approaches
havefocusedonsequen cesoffunctioncallstha tareexpected
toappearwithinasin glefunction, ratherth anthespeciﬁc
interactionbetweenas erviceandtherestoft hekernel.
10http://www.iozone.o rg/Someofourkindsofs afetyholescouldbeel iminatedby
the use of advanced t ype systems. For exa mple, Bugrara
andAikenproposean analysistodiﬀerentiat ebetweensafe
and unsafe userspace p ointers in kernel code [4]. They fo-
cus,however,ontheen tirekernel,andthusm ayinformthe
servicedeveloperabou tfaultsincodeothert hanhisown.
Logging. Runtime logs are frequ ently insuﬃcient for fa il-
ure diagnosis especiall y in case of unexpecte d crashes [8].
LogEnhancer[31]enricheslogmessa geswithextrainforma -
tion, butdoesnotcrea tenewmessages. Diag nosyscreates
newlogmessagesalon gthekernel-servicebo undary,where
theycanbemosthelpf ultoservicedeveloper s.
Robust interfaces. LXFI [30] isolates kern el modules and
includestheconceptofAPIintegrity,whichallowsdevelop-
ers to deﬁne the usage contract of kernel inte rfaces by an-
notating the source co de. LXFI, however, ai ms at limiting
thesecuritythreatpos edbytheprivilegesgra ntedtokernel
modules, while Diagno sys focuses on various categories of
commonfaultsencoun teredinkernelcode.
Healers automatically generates a robust int erface to a
user-levellibrarywitho utaccesstothesource code[11]. It
relies on fault injectio n to identify the set o f assumptions
thatalibraryfunction makesaboutitsargum ents. Healers
canobtaininformation aboutruntimevalues, suchasarray
bounds,thatmaybed iﬃculttodetectusing staticanalysis.
However,Healersdoes notaddresssafetyhole kindssuchas
Lock that require calli ng-context information . Supporting
Lock would require te sting the state of all a vailable locks,
whichwouldbeexpens iveandarelikelyunkn own.
Programming with contra cts.Asoftwarecontractrepre-
sentstheagreementbe tweenthedeveloperof acomponent
anditsuseronthecom ponent’sfunctionalbeh avior[13,15,
21,22]. Contractsincl udepre-andpost-cond itions,aswell
asinvariants. Asafety holeisessentiallythed ualofacon-
tract,inthatacontract describespropertiestha tthecontext
shouldhave,whileasa fetyholedescribespro pertiesthatit
shouldnothave.
Contractinferenceisan alogoustotheexecutio nofSHAna.
ArnoutandMeyerinfe rcontractsbasedonex ceptionsfound
in .NET code [2]. Dai kon infers invariants d ynamically by
runningtheprogramw ithmultipleinputsand generalizing
theobservations[10]. D iagnosystargetssituati onsthatlead
tounhandledexception s,eitherinthekernel ortheservice
code. Linux kernel ex ecution is highly depe ndent on the
particulararchitecture anddevicesinvolved,a ndthusaser-
vicedeveloperwouldh avetoactivelyuseDai koninhisown
environment. SHAna allows the collection o f safety holes
tobecentralized. Fina lly,onlyoneoftheinv ariantsinthe
Daikoninvariantlist,11NonZero,maycorrespo ndtooneof
our safety hole kinds, namely INull. Daikon does nothan-
dlecommonsafetyhole kindssuchasFree,ork ernel-speciﬁc
safetyholekindssuch asParam,foruser/poi nterbugs.
TheExtendedStaticC heckerforJava(ESC/J ava)[13]re-
liesonprogrammeran notationstocheckmet hodcontracts.
Annotationassistantss uchasHoudini[12]aut omatethein-
ferenceofannotations. Houdinisupportsvario usexceptions
involvingarguments,s uchasNullPointerExc eptionandIn-
dexOutOfBoundsExcep tion, but does not pro vide tests for
thevalidityofallocate dmemory.
11http://groups.csail.m it.edu/pag/daikon, D ocumentation, Sec. 5 .5687. CONCLUSION
Defects in kernel-level services can cause the demise of
theentiresystem,often leavingdeveloperswith outanyclue
as to what went wron g. Debugging such pr oblems is par-
ticularlychallengingea rlyinservicedevelopm ent,whenthe
codechangesfrequentl yandthedeveloperis notnecessarily
aware of the usage pr econditions of kernel i nterfaces. We
havedesignedDiagnos ys,atoolthatdetects safetyholesin
Linuxkernelexportedf unctionsandsupports thegeneration
ofadebugginginterfac e,tailoredforaparticu larservice,ac-
cordingtothisinforma tion. AtruntimeDiagn osysprovides
a crash-resilient loggin g system for recording information
aboutriskyusesofker nelfunctionscontainin gsafetyholes.
Using fault injection t ests on 10 Linux kern el-level ser-
vices,wehaveshownt hatourinterfacealerts thedeveloper
tothecriticaldefectsi nhiscode. Usingadri verforaGiga-
bit Ethernet device an d a NFS ﬁle system, w e have shown
thattheperformancei mpactofourapproach iswithinthe
limitsofwhatisaccep tablewhentestingak ernel-levelser-
vice in the initial stag es of development, and can even be
useduptothephaseo finitialdeployment.
8. ACKNOWLEDGM ENTS
Thisworkwassupport edinpartbytheANR grantABL.
Source code and resu lts from this work ca n be found at
http://momentum.labr i.fr/projects/diagno sys.
9. REFERENCES
[1] A.Albinet,J.Arla t,andJ.-C.Fabre.Cha racterization
oftheimpactoffaulty driversontherobustne ssofthe
Linuxkernel.InDSN’04,pages867–876.
[2] K.ArnoutandB.M eyer.Uncoveringhidde ncontracts:
The.NETexample.Computer,36:48–55,2003.
[3] T.Ball,E.Bounim ova,B.Cook,V.Levin ,
J.Lichtenberg,C.McG arvey,B.Ondrusek,S. K.
Rajamani,andA.Ustu ner.Thoroughstatica nalysis
ofdevicedrivers.InEuroSys’06,pages73–85.
[4] S.BugraraandA. Aiken.Verifyingthesa fetyofuser
pointerdereferences.InIEEE Symposium on Security
and Privacy,pages325–338,Oakla nd,CA,USA,2008.
[5] A.Chou,J.Yang, B.Chelf,S.Hallem,an dD.Engler.
Anempiricalstudyof operatingsystemserro rs.In
SOSP’01,pages73–88,Banﬀ,C anada.
[6] J.Corbet.Injecting faultsintothekernel.
http://lwn.net/Artic les/209257/,November2004.
[7] D.Cotroneo,R.Na tella,andS.Russo.As sessment
andimprovementofha ngdetectionintheLin ux
operatingsystem.InSRDS’09,pages288–294.
[8] Y.Ding,M.Haohu i,X.Weiwei,T.Lin,Z .Yuanyuan,
andP.Shankar.Sherlo g: Errordiagnosisby
connectingcluesfrom run-timelogs.InASPLOS’10,
pages143–154,Pittsbu rgh,PA,USA.
[9] D.Engler,D.Y.C hen,S.Hallem,A.Cho u,and
B.Chelf.Bugsasdevi antbehavior: agenera l
approachtoinferringe rrorsinsystemscode. In
SOSP’01,pages57–72,Banﬀ,A lberta,Canada.
[10] M.D.Ernst,J.H .Perkins,P.J.Guo,S .McCamant,
C.Pacheco,M.S.Tsch antz,andC.Xiao.The Daikon
systemfordynamicde tectionoflikelyinvaria nts.Sci.
Comput. Program.,69:35–45,December2 007.
[11] C.FetzerandZ.X iao.Healers: atoolkit forenhancingtherobustnessandsec urityofexistingapplic ations.In
DSN’03,pages317–322,SanF rancisco,CA,USA.
[12] C.FlanaganandK .R.M.Leino.Houdini ,an
annotationassistantfo rESC/Java.InFME’01,pages
500–517,London,UK.
[13] C.Flanagan,K.R .M.Leino,M.Lillibrid ge,
G.Nelson,J.B.Saxe, andR.Stata.Extende dstatic
checkingforJava.InPLDI’02,pages234–245.
[14] A.Ganapathi,V. Ganapathi,andD.Pat terson.
WindowsXPkernelcr ashanalysis.InLISA’06,pages
49–159,Washington,D C,USA.
[15] R.Hirschfeld,M. Perscheid,C.Schubert ,and
M.Appeltauer.Dynam iccontractlayers.InSAC’10,
pages2169–2175.ACM ,2010.
[16] M.HuthandM.R yan.Logic in Computer Sc ience:
Modelling and reasonin g about systems.Cambridge
UniversityPress,2000.
[17] V.Kuznetsov,V. Chipounov,andG.Ca ndea.Testing
closed-sourcebinaryde vicedriverswithDDT .In
USENIX Annual Techn ical Conference,June2010.
[18] J.L.Lawall,J.Br unel,N.Palix,R.R.H ansen,
H.Stuart,andG.Mul ler.WYSIWIB:Adecl arative
approachtoﬁndingAP Iprotocolsandbugsin Linux
code.InDSN’09,pages43–52,Lisbon, Portugal.
[19] Z.LiandY.Zhou .PR-miner: automatic ally
extractingimplicitpro grammingrulesandde tecting
violationsinlargesoftw arecode.InESEC/FSE-13,
pages306–315,Lisbon ,Portugal,2005.
[20] P.Marinescuand G.Candea.Eﬃcientte stingof
recoverycodeusingfau ltinjection.ACM Transactions
on Computer Systems (TOCS),29(3),Nov.2011.
[21] B.Meyer.Object-Oriented Softw are Construction.
Prentice-Hall,Inc.,1st edition,1988.
[22] C.Mills.Using Design by Cont ract in C.
OnLamp.com,O’Reilly ,1stedition,October2 004.
[23] H.Nellitheertha.R ebootLinuxfasterusin gkexec.
http://www.ibm.com/d eveloperworks/linux/
library/l-kexec/ind ex.html,2004.
[24] Y.Padioleau,J.L .Lawall,R.R.Hansen ,and
G.Muller.Documentin gandautomatingcolla teral
evolutionsinLinuxdev icedrivers.InEuroSys’08,
pages247–260,Glasgo w,Scotland.
[25] N.Palix,S.Saha, G.Thomas,C.Calv` es, J.L.Lawall,
andG.Muller.Faults inLinux: Tenyearslat er.In
ASPLOS’11,pages305–318.
[26] H.PostandW.K ¨uchlin.Integratedstat icanalysisfor
Linuxdevicedriverver iﬁcation.InIFM’07,pages
518–537,Oxford,UK.
[27] M.K.Ramanatha n,A.Grama,andS.J agannathan.
Path-sensitiveinferenc eoffunctionprecedenc e
protocols.InICSE’07,pages240–250.
[28] A.RubiniandJ. Corbet.Linux Device Drivers,page
109.O’ReillyMedia,s econdedition,2001.
[29] L.Ryzhyk,P.Chu bb,I.Kuz,andG.Hei ser.Dingo:
Tamingdevicedrivers. InEuroSys’09,pages275–288.
[30] M.Yandong,C.H aogang,Z.Dong,W.X i,Z.Nickolai,
andK.M.Frans.Softw arefaultisolationwith API
integrityandmulti-pri ncipalmodules.InSOSP’11.
[31] D.Yuan,J.Zheng ,S.Park,Y.Zhou,and S.Savage.
Improvingsoftwaredia gnosabilityvialog
enhancement.InASPLOS’11,pages3–14.69