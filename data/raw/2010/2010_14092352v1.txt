ADDiff: Semantic Differencing for Activity Diagrams
Shahar Maoz, Jan Oliver Ringert, Bernhard Rumpe
Software Engineering
RWTH Aachen University, Germany
http://www.se-rwth.de/
ABSTRACT
Activity diagrams (ADs) have recently become widely used
in the modeling of workows, business processes, and web-
services, where they serve various purposes, from documen-
tation, requirement denitions, and test case specications,
to simulation and code generation. As models, programs,
and systems evolve over time, understanding changes and
their impact is an important challenge, which has attracted
much research eorts in recent years.
In this paper we present addi , a semantic dierencing
operator for ADs. Unlike most existing approaches to model
comparison, which compare the concrete or the abstract syn-
tax of two given diagrams and output a list of syntactical
changes or edit operations, addi considers the semantics
of the diagrams at hand and outputs a set of di witnesses ,
each of which is an execution trace that is possible in the
rst AD and is not possible in the second. We motivate the
use of addi , formally dene it, and show two algorithms
to compute it, a concrete forward-search algorithm and a
symbolic xpoint algorithm, implemented using BDDs and
integrated into the Eclipse IDE. Empirical results and ex-
amples demonstrate the feasibility and unique contribution
ofaddi to the state-of-the-art in version comparison and
evolution analysis.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques; D.2.4 [ Software Engineering ]: Software/Program
Verication
General Terms
Documentation, Verication
S. Maoz acknowledges support from a postdoctoral Min-
erva Fellowship, funded by the German Federal Ministry for
Education and Research. J.O. Ringert is supported by the
DFG GK/1298 AlgoSyn.Keywords
software evolution, activity diagrams, dierencing
1. INTRODUCTION
Activity diagrams (ADs) have recently become widely used
in the modeling of workows, business processes, and web-
services, where they serve various purposes, from documen-
tation, requirement denitions, and test case specications,
to simulation and code generation. Specically, we are in-
terested in a variant of the standard UML 2 ADs, which is
rich and expressive, supporting guarded branches, parallel
(interleaving) process executions, inputs, assignments, etc.
As models, programs, and systems evolve over time, dur-
ing the development lifecycle and beyond it, eective change
management and controlled evolution are major challenges
in software development, and thus have attracted much re-
search eorts in recent years (see, e.g., [1, 2, 6, 11, 14, 21,
23, 32]). Fundamental building blocks for tracking the evo-
lution of software artifacts are di operators one can use to
compare two versions of a program or a model. Most ex-
isting approaches to dierencing concentrate on matching
between model elements using dierent heuristics related to
their names and structure and on nding and presenting
dierences at a concrete or abstract syntactic level. While
showing some success, most of these approaches are also
limited. Models that are syntactically very similar may in-
duce very dierent semantics (in the sense of `meaning' [10]),
and vice versa, models that semantically describe the same
system may have rather dierent syntactic representations.
Thus, a list of syntactic dierences, although accurate, cor-
rect, and complete, may not be able to reveal the real im-
plications these dierences may have on the correctness and
potential use of the models involved. In other words, such
a list, although easy to follow, understand, and manipulate
(e.g., for merging), may not be able to expose and represent
the semantic dierences between two versions of a model, in
terms of the bugs that were xed or the features (and new
bugs. . . ) that were added.
In this paper we present addi , a semantic di operator
for ADs. Unlike existing dierencing approaches, addi is a
semantic di operator . Rather than comparing the concrete
or the abstract syntax of two given diagrams, and outputing
a list of syntactical changes or edit operations, addi con-
siders the semantics of the diagrams at hand and outputs
a set of di witnesses , each of which is an execution trace
that is possible in the rst AD and is not possible in the sec-
ond. These traces provide concrete proofs for the meaning
[MRR11d] S. Maoz, J. O. Ringert, B. Rumpe 
ADDiff: Semantic Differencing for Activity Diagrams 
In: Proc. Euro. Soft. Eng. Conf. and SIGSOFT Symp. on the Foundations of Soft. Eng. (ESEC/FSE'11), pp. 179-189, ACM, 2011. 
se-rwth.de/publicationsof the change that has been done between the two compared
versions and for its eect on the use of the models at hand.
We specify ADs using a variant of standard UML 2 ADs [24],
which can also be given textually using a grammar dened
in MontiCore [13, 22]. The syntax of an AD consists of ac-
tion nodes, pseudo nodes (initial, nal, decision, merge, fork,
join), transitions, input variables, and local variables. Tran-
sitions outgoing decision nodes are guarded with Boolean
expressions over the input and local variables. Input vari-
ables values are set by the environment. Action nodes are
labeled with action names and may include assignments to
local variables.
We dene the operational semantics of an AD using a
translation to a nite automaton with variables over nite
domains. This induces a trace-based semantics, i.e., a set
of action traces from an initial node to a nal node, consid-
ering also the values of input variables. Branches outgoing
fork nodes describe parallel executions; they are used to suc-
cinctly specify concurrent interleaving traces. An overview
of the syntax and semantics of our ADs is given in Sect. 3.
Given two ADs, ad1andad2,addi (ad1; ad 2) is roughly
dened as the set of execution traces possible in the rst AD
and not possible in the second. As there may be exponen-
tially many di traces, we are specically interested in the
shortest ones, i.e., ones that do not have a prex which is
a dierentiating trace. In addition, we restrict the operator
to provide only a single shortest di trace for each possi-
ble assignment to input variables. To compute addi we
transform each of the ADs into a module in SMV, the input
language of the SMV model checker [29]. We then present
two algorithms: a concrete forward-search algorithm and a
symbolic xpoint algorithm. The second algorithm relies on
the technologies of symbolic model checking [3] in order to
address the state explosion problem of the rst. We present
them both in order to allow their comparison. The formal
denition of addi and the two algorithms are described in
Sect. 4.
We have implemented the two algorithms for addi using
binary decision diagrams (BDDs), and integrated them into
an Eclipse plug-in. The plug-in allows the engineer to com-
pare two selected ADs, to check if they are equivalent, and
to textually and visually browse the di witnesses found, if
any. We describe the plug-in implementation in Sect. 5. We
have evaluated the plug-in against all examples shown in this
paper and many other ADs. The results of our evaluation,
including a performance comparison of the two algorithms,
appear in Sect. 6.
In addition to nding concrete di witnesses (if any ex-
ist), which demonstrate the meaning of the changes that
were made between one version and another, addi can be
used to compare two ADs and decide whether one AD se-
mantics includes the other AD semantics (the latter is a
renement of the former), are they semantically equivalent,
or are they semantically incomparable (each allows execu-
tions that the other does not allow). When applied to the
version history of a certain AD, as can be retrieved from
a version repository, such an analysis provides a semantic
insight into its evolution, which is not available in existing
syntactic approaches.
Model and program dierencing, in the context of soft-
ware evolution, has attracted much research eorts in recent
years. In contrast to our work, however, most studies in this
internalhire.v1 register
assign to 
projectadd to 
website
manager interview!internal
assign to 
projectget welcome pack
authorize paymentmanager reportinternalhire.v2 register
assign to 
projectadd to 
website
manager interview!internal
assign to 
projectget welcome pack
authorize paymentmanager reportassign
keysFigure 1: Versions 1 and 2 of the hire activity
area present syntactic dierencing, at either the concrete or
the abstract syntax level. We discuss related work in Sect. 7.
Finally, our work on semantic dierencing does not come
to replace existing syntactic dierencing approaches. Rather,
it is aimed at augmenting and complementing existing ap-
proaches with capabilities that were not available before.
We discuss the combination of syntactic and semantic dif-
ferencing as well as other future work directions in Sect. 6.
The next section presents motivating examples demon-
strating the unique features of our work. Sect. 3 provides
preliminary denitions of the AD language syntax and se-
mantics as used in our work. Sect. 4 introduces addi and
the two algorithms to compute it. Sect. 5 presents the imple-
mentation, Sect. 6 presents an evaluation and a discussion,
Sect. 7 considers related work, and Sect. 8 concludes.
2. EXAMPLES
We start o with motivating examples for semantic dif-
ferencing of ADs. The examples are inspired by real-world
ADs we have obtained from several sources (see Sect. 6).
2.1 Example I
ADhire:v 1 of Fig. 1 describes a company's workow when
hiring a new employee. Roughly, rst the employee is reg-
istered. Then, if she is an internal employee, she gets a
welcome package, she is assigned to a project and added to
the company's computer system (in two parallel activities
branching o a fork node), she is interviewed and gets a
manager report, and nally her payments are authorized.
Otherwise (note the decision node at the beginning of the
AD), if the new employee is external, she is only assigned to
a project before her payments are authorized.
After some time, the company deployed a new security
system and every employee had to receive a key card. A
revised workow was created, as shown in hire:v 2 of Fig. 1.
Later, a problem was found: sometimes employees are
assigned to a project but cannot enter the building since they
do not have a key card yet. This bug was xed in the next
version, hire:v 3, shown in Fig. 2. Finally, the company has
decided that external employees should report to managers
too. Thus, the merge between the two branches for internal
and external new employees has moved `up', in between theinternalhire.v3 register
assign to 
projectadd to 
website
manager interview!internal
assign to 
projectget welcome pack
authorize paymentmanager reportassign
keysinternalhire.v4 register
assign to 
projectadd to 
website
manager interview!internal
assign to 
projectget welcome pack
authorize paymentmanager reportassign
keysFigure 2: Versions 3 and 4 of the hire activity
interview and the report nodes. The resulting 4th version
of the workow, hire:v 4, is shown in Fig. 2
Given these four versions of the activity, an evolution
analysis is called for. Comparing hire:v 1 and hire:v 2 us-
ingaddi reveals that they are semantically incomparable:
some executions of hire:v 1 are no longer possible in hire:v 2,
and some executions of hire:v 2 were not possible in hire:v 1.
Moreover, it reveals that handling of internal employees has
changed, but handling of external ones remained the same
between the two versions.
Comparing hire:v 2 and hire:v 3 reveals that the latter
is a renement of the former: hire:v 3 has removed some
traces of hire:v 2 and did not allow new traces. In partic-
ular, addi (hire:v 2; hire:v 3) shows that the trace where a
person is assigned to a project before she gets a key card
was possible in hire:v 2 and is no longer possible in hire:v 3,
i.e., it demonstrates that the bug was xed.
Finally, comparing hire:v 3 and hire:v 4 using addi re-
veals that although hiring of external employees has changed
between the two versions, hiring of internal employees did
not: addi (hire:v 3; hire:v 4) contains a single trace, where
the employee is external, not internal. That is despite the
syntactic change of moving the merge node from after to
before the report node, which is also part of the trace of
handling internal employees.
2.2 Example II
ADproj:v 1 of Fig. 3 describes a company's workow when
receiving a new project. Roughly, rst the project is regis-
tered. Then, the required work is dened, the oce work is
done, the clients work is done, and a report is written. If
the project is of type small, the activity continues to nal
report and is completed. If the project is of type large, a
second phase of the required work is dened, the oce work
is done, the clients work is done, and a report is written,
before continuing to the nal report and completion.
After some time, the activity designer suggested a refac-
toring: instead of the explicit duplication of the four work
actions in the diagram, a loop will be dened. The designer
added a local variable c, which is initialized when the project
is registered and is incremented when writing the report.
proj.v1
register 
project
define
work
office 
work
clients 
work
final 
reportoffice 
work
clients 
workproj.v2
register 
project
define
work
office 
work
clients 
work
final 
reportproj.v3
define
work
office 
workclients 
work
final 
reportdefine
work
report reportreportreportC=0
c=c+1
    c<2 & 
type=large
c=2|type=smallregister 
project
C=0
c=c+1
c=2|type=smalltype=large
type=small c<2 & 
type=largeFigure 3: Versions 1-3 of the new project activity
The guards of the decision node were changed accordingly.
The resulting AD is proj:v 2, shown in the same gure.
Before committing the new activity to the models reposi-
tory, the designer used addi to compare proj:v 1 and proj:v 2.
Indeed, she found that addi (proj:v 1; proj:v 2) =
addi (proj:v 2; proj:v 1) =;. This proves that the refactor-
ing did not change the semantics of the activity and the new
version can be safely committed to the repository.
Finally, a consultant has examined the new project activ-
ity and suggested that in some cases, clients work can be
done before the oce work. Following this recommenda-
tion, the designer added fork and join nodes to the activity,
to dene the oce work action and the clients work action
on separate branches of a fork. The resulting AD is proj:v 3,
shown in the same gure.
Comparing proj:v 2 and proj:v 3 using addi revealed that
the new version has introduced several new traces that were
not possible before: traces where clients work is done be-
fore oce work (in the rst or in the second iteration of
the loop). Thus, the comparison demonstrated that the re-
quired enhancement was added. Moreover, the comparison
showed that all traces of proj:v 2 are still possible in proj:v 3
(because addi (proj:v 2; proj:v 3) =;). Thus, it proved that
no behavior was lost.
The above examples are simple and thus immediately re-
veal the dierences when looking at them. We use them in
order to demonstrate our ideas. However, we have also done
experiments with larger, synthetic and real-world AD's, where
dierences were manually much harder to nd. See Sect. 6.
3. PRELIMINARIES
We dene the AD language syntax and semantics as used
in our work.
3.1 AD Language Syntax
An Activity Diagram is a structure
AD=hA; Vinp; Vloc; AN; PN; Tiwhere:
Ais a set of action names.Vinpis a (possibly empty) set of immutable input vari-
ables over nite domains.
Vlocis a (possibly empty) set of local variables over
nite domains.
ANis a set of action nodes an1; : : : ; an k. Each action
node anis labeled with an action name acname (an) =
ac2A, and a (possibly empty) set of assignment ex-
pressions to the variables in Vloc.
PNis a set of pseudo nodes, consisting of initial nodes
PNinit, nal nodes PNfin, decision nodes PMdec,
merge nodes PNmer, fork nodes PNfork, and join
nodes PNjoin.
Tis a set of transitions of the form t=hnsrc; ntrg; guardi
where nsrc; ntrg2(AN[PN) and guard is a Boolean
expression over the variables in Vinp[Vloc. Unless
nsrcis a decision node, guard =true.
We do not formally capture here obvious well-formedness
rules and context conditions such as: initial nodes have no
incoming transitions, nal nodes have no outgoing transi-
tions, fork nodes must be followed by join nodes to remove
all concurrency when reaching a nal node, actions should
not repeat in dierent forked branches, etc.
In addition, we assume that the Boolean expressions used
as guards on transitions outgoing decision nodes are seman-
tically exclusive, that is, no assignment to the diagram vari-
ables makes more than one of them true. Thus, the input
variables provide external non-determinism, while except for
forked branches, our ADs are internally deterministic.
We consider two concrete syntax denitions for ADs: a
concrete visual syntax based on UML 2 ADs and a concrete
textual syntax dened using MontiCore [13, 22]. We omit
the concrete syntax denitions from this paper.
The implementation we present in Sect. 5 supports a sub-
set of full UML 2 ADs: it supports action nodes and pseudo
nodes: initial, nal, fork, join, decision and merge; each
AD has exactly one initial node but may have multiple nal
nodes. For simplicity reasons but without loss of generality,
in our implementation no two pseudo nodes can follow each
other directly. In addition, local and input variables have
to be declared as such in the rst action node; all variables'
nite domains need to be given as SMV types or enumera-
tions; and each local variable needs to be assigned a value
in the rst action node. We support Boolean guards speci-
ed in the rich SMV expression language [4]. Assignments
to local variables can be made from any action node using
values from SMV expressions.
3.2 AD Language Semantics
We distinguish operational semantics and trace-based se-
mantics. The operational semantics is based on the deni-
tion of a state machine step, taking the AD from one state
to another, where a state consists of a set of current action
nodes and an assignment to all input and local variables.
The main idea of our operational semantics is to concep-
tually translate each ad2ADinto a nite state machine
(FSM). Each state is a conguration containing the values
of all local variables and input variables (recall that vari-
ables range over nite domains), the executed action, and
some extra variables with information on the control ow of
the AD. Based on this state and evaluated guards possible
transitions are computed that lead to the next state with anexecuted action, possibly changed local variables values, and
a new conguration of the control ow tracking variables.
We formally dene the operational semantics using a trans-
formation of an AD to a module of SMV, the language of the
SMV model checker [20, 29]. Our translation is inspired by
the work of [7], but extends this previous translation with
support for data. The complete translation, together with a
detailed example, appears in a separate document [17].
Local variables assist the AD engineer together with guards
to control the execution sequences of actions, e.g., by den-
ing loops or activating/disabling branches of decision nodes.
Input variables, in contrast to local variables, are initialized
by the environment and do not change during the run of
an AD. The runs of two ADs are compared with the same
input, i.e., where common input variables of both ADs have
the same values. We consider all possible input values of
both ADs when comparing them.
Our semantics of ADs is rather expressive: it considers
values of input variables to be set by the environment (ex-
ternal non-determinism). However, we only support inter-
nal non-determinism through interleaved execution of forked
branches, and not through non-deterministic decision nodes;
the current conguration and the next executed action de-
termine the next conguration. Thus, for each assignment
to the input variables there could be many possible execu-
tions due to the interleaving semantics of fork nodes.
We dene a trace-based semantics that is induced by the
operational semantics. Traces are sequences of states from
the state space of the AD's FSM.
Definition 1 (AD state). A state of an AD adis an
assignment to all variables dened in the VAR section of its
SMV module. This includes the last executed node acnode
and its action name ac, the values of variables v2ad:Vinp[
ad:Vlocand the values of control ow tracking variables.
AD states have a nite number of possible successor states
that can be reached within one step. By construction, each
such step executes an action or reaches a nal node. We
dene the successors of an AD state sassuccessors (s).
Definition 2 (Successor states). For every AD state
s,successors (s)is the set of AD states reachable from sin
one step of the SMV module.
Each run of an AD starts with an initial state in the initial
node. A sequence of successor states that describe a legal
execution of the AD's FSM is a trace. A trace from the
initial to a nal node of the AD is an accepting trace.
Definition 3 (AD traces). A sequence of AD states
tr=s0; s1; : : : ; s kof AD adwithsi+12successors (si)and
s0:acnode2ad:PNinitis called a trace. The set of all traces
of an AD adis denoted by traces (ad). A trace is called an
accepted trace if its last state's node is a nal node of the
AD. The set of all accepted traces of an AD adis denoted
byacceptedTraces (ad).
4. ADDIFF
4.1 Deï¬nitions
Given two AD states, s12ad1ands22ad2, we say that
s1ands2arecorresponding , i the action names and values
of equally named input variables of the two states are the
same. Formally:Definition 4 (corresponding states). Given two ADs,
ad1andad2, and two states s12ad1ands22ad2, we say
thats1ands2are corresponding, denoted s1s2, i the
following conditions hold:
1.s1:ac=s2:ac;
2.8v2Vinp
1\Vinp
2,s1:val(v) =s2:val(v).
The denition of corresponding states punctually extends to
traces in a natural way.
Given two ADs, a trace of the rst AD is a di trace
i there exists a trace of the second AD where all states
except the last correspond to the states of the rst trace,
but the last state of the rst trace does not correspond to
any possible successor state of the second trace. Formally:
Definition 5 (diff trace). Given two ADs, ad1and
ad2, a di trace is a sequence of states tr1=s0
1; s1
1; : : : ; sk
1; sk+1
1
s.t.
1.tr12traces (ad1)
2.9tr2=s0
2; s1
2; : : : ; sk
2s.t.tr22traces (ad2)
^8i;0ik; si
1si
2
^@sk+1
2s.t.sk+1
2sk+1
1^s0
2; s1
2; : : : ; sk
2; sk+1
22traces (ad2).
tr2is called a corresponding di trace of tr1.
We denote the set of all di traces of ad1vs.ad2by
diTraces (ad1; ad 2). Note that diTraces is not symmetric.
We are now ready to present the denition of addi . Note
that we are interested only in shortest di traces: we restrict
addi to di traces that do not have another di trace as
prex. Moreover, to make the set addi succinct, for each
initial state of ad1, if there is a di trace that starts at this
initial state, we want only one such trace to be in addi .
Formally:
Definition 6 (addiff). addi (ad1; ad 2)is a subset
of diTraces (ad1; ad 2)s.t.
1.8tr2addi (ad1; ad 2);@tr0s.t.tr02addi (ad1; ad 2)^
tr0<tr;
2.8s0
12ad1:initials;
if9tr2diTraces (ad1; ad 2)s.t.trstarts at s0
1
thenjftr2addi (ad1; ad 2)jtrstarts at s0
1gj= 1.
Finally, note that we do notrequire that di traces can be
extended into accepting traces (ones that end at a nal node,
see Def. 3). For an alternative denition, see the discussion
in Sect. 6.
4.2 Computing ADDiff
We present two dierent algorithms, a concrete forward-
search algorithm and a symbolic xpoint algorithm.
4.2.1 Algorithm I
We compute addi (ad1; ad 2) using a BFS-like traversal
of the state space of ad1that is used to `guide' a BFS-like
traversal of the state space of ad2. Roughly, the algorithm
uses a queue for corresponding states-pairs that have been
reached but whose successors have not yet been traversed
(the use of the queue guarantees that shortest paths will be
found rst). It also maintains a list of visited corresponding
state-pairs and a list of rejecting state-pairs. Initially, all
corresponding initial states-pairs are inserted in the queue,
and all initial states of ad1that do not have a correspondinginitial state in ad2are added to the list of rejecting state-
pairs. Then, for each state-pair taken out from the queue,
the algorithm checks that each successor state of the rst ele-
ment in the state-pair (the state in ad1), has a corresponding
successor state of the second element in the state-pair (the
state in ad2). Every corresponding pair found, if not visited
before, is inserted to the queue. If no corresponding suc-
cessor is found, we know we have found the end state of a
(shortest) di trace: we add it to the list of rejecting state-
pairs and we remove from the queue all the state-pairs whose
input variables values for ad1are the same as the ones for
the state we have found. When the queue is empty, the list
of visited state-pairs is used to construct the traces leading
back from the rejecting state-pairs to the initial states.
A pseudo-code for the algorithm is given in Proc. 1, which
uses Proc. 2 and 3. We describe these procedures below.
The algorithm uses a structure Pair made of two pairs
of states: predecessor and current state in ad1,pre 1and
cur 1, and predecessor and current state in ad2,pre 2and
cur 2. Two pairs are considered equal if their current states
are equal (ignoring predecessor states). Pair is used to keep
track of pairs of visited states, one state from each AD, and
of their predecessors, as found during the traversal of the
state space. The predecessors are used in the reconstruction
of the traces from the lists of rejecting and visited pairs.
Proc. 1 denes the required structures (l. 1-3): a queue
of pairs, a list of visited pairs, a list of rejecting pairs, and a
list of list of pairs, which will hold the computed di traces.
It iterates over all initial states of ad1, and for each of them,
looks for a corresponding initial state in ad2. If a correspond-
ing state is found, the new pair is inserted to the queue and
to the visited list (l. 8). If no corresponding state is found,
a pair where only the ad1current state is dened is added
to the list of rejecting state pairs (l. 13).
After initialization, the algorithm calls traverse (Proc. 2),
to iterate on the queue until it is empty. For each dequeued
pair, the procedure iterates over all the successors of its cur-
rentad1state. For each successor, it tries to nd a corre-
sponding successor of the current ad2state. If a correspond-
ing state is found, the new pair is inserted to the queue and
to the visited list (l. 9). If no corresponding state is found,
a pair where only the ad1current state is dened is added to
the list of rejecting states (l. 15). In addition, all state-pairs
whose current ad1state agrees with the current ad1state in
the rejecting pair on input variables, are removed from the
queue (l. 16-17). This ensures that no further searching of
di traces outgoing the same initial state will be done.
Finally, trace (Proc. 3) is used to reconstruct the traces
leading from initial states to the rejecting states that have
been found. The procedure works backward: it starts from
the rejecting pairs and uses the predecessor states to build
the required traces, from the rejecting states back to the
initial states, using the pairs saved in the visited list. It
continues as long as their predecessor states are dened, i.e.,
as long as it has not reached an initial state.
4.2.2 Algorithm II
We compute addi (ad1; ad 2) using a symbolic least-xpoint
algorithm. The algorithm relies on the technologies of sym-
bolic model checking [3], and is inspired by the classic x-
point algorithm to compute a maximal simulation relation,
and, more specically, by the synthesis algorithm of [26],Procedure 1 concrete-addi( ad1,ad2)
1:dene queuePairs as queue of Pair
2:dene visited ,rejects as list of Pair
3:dene traces as list of lists of Pair
4:for all ini12ad1:initials do
5: foundCorresponding  false
6: for all ini22ad2:initials do
7: ifcorresponding (ini1; ini 2)then
8: addPair ( ; ini 1; ; ini 2)toqueuePairs ,visited
9: foundCorresponding  true
10: end if
11: end for
12: if not foundCorresponding then
13: addPair ( ; ini 1; ; )torejects
14: end if
15:end for
16:visited ,rejects traverse( ad1,ad2)
17:traces trace( visited ,rejects )
18:return traces
Procedure 2 traverse( ad1,ad2)
1:while queuePairs is not empty do
2: p pairfrom queuePairs
3: for all suc12p:cur 1:successors do
4: foundCorresponding  false
5: for all suc22p:cur 2:successors do
6: ifcorresponding (suc1; suc 2)then
7: newPair Pair (p:cur 1; suc 1; p:cur 2; suc 2)
8: ifnewPair =2visited then
9: addnewPair toqueuePairs ,visited
10: end if
11: foundCorresponding  true ,break
12: end if
13: end for
14: if not foundCorresponding then
15: addPair (p:cur 1; suc 1; p:cur 2; )torejects
16: remove all pairfrom queuePairs
17: where p:cur 1:inputs =pair:cur 1:inputs
18: end if
19: end for
20:end while
21:return visited; rejects
where intermediate values from the xpoint computation are
used in the construction of a concrete winning strategy.
Roughly, our symbolic algorithm starts with a represen-
tation of all non-corresponding states. It then moves `back-
ward', and adds to the current set of states, states from
which there exists a successor in ad1such that for all suc-
cessors in ad2, the resulting successor pair is in the current
set of states. Most importantly, to help in the construction
of di traces later, at each step backward, the algorithm re-
members the newly computed set of added states. The steps
`backward' continue until reaching a least xpoint, that is,
until no more states are added.
When the xpoint is reached, the algorithm checks whether
the last computed set (the xpoint set) includes initial states.
For each such initial state, if any, the algorithm uses the
sets of states computed during the backward steps to move
forward (from the minimal position it can start from) and
construct shortest di traces.
We present our algorithm in general set notation, with the
set-operations of union, intersection, and complementation.
In the pseudo code below, sets with no subscript are sets
of states over the union of all variables from ad1andad2.
Fori2f1;2g, sets with subscript iare sets of states overProcedure 3 trace( visited ,rejects )
1:for all rejectingPair2rejects do
2: dene tras list of Pair
3: curPair rejectingPair
4: while curPair is not null do
5: addcurPair totr
6: ifcurPair:pred 1is not null then
7: curPair 
getV isited (curPair:pred 1; curPair:pred 2; visited )
8: else
9: break
10: end if
11: end while
12: addtrtotraces
13:end for
14:return traces
Procedure 4 symbolic-addi( ad1,ad2)
1:dene traces as list of lists of Set
2:dene mem as array of Set
3:mem least-xpoint-with-mem( ad1,ad2)
4:ifmem:last\initials6=;then
5: traces build-traces-from-mem( ad1,ad2,mem )
6:end if
7:return traces
the variables of adi. The operator Sjadiis used to restrict
the variables of the set Sto the variables of adi(all other
variables are existentially quantied out). The operation
choose one relates to choosing a single element from the
relevant set (a single concrete assignment to the variables).
The sets corr andinitials are the set of corresponding states
and the set of joint initial states, respectively. When inter-
secting a set Siover the variables of adiwith a set Sover
the union of all variables from both ADs, the result is a set
over the union of variables where the variables of adiagree
with their possible assignments in the set Si.
In the implementation, the sets are represented using BDDs.
A pseudo-code for the algorithm is given in Proc. 4, which
uses Proc. 5 and 6.
Note that in the nal iteration of the loop in Proc. 6,
reached with i= 1, the assignment to next 2is guaranteed
to set next 2 ;, because the rst location in the memory
array equals corr. This guarantees that the last state in each
di trace assigns no values to the variables of ad2: indeed,
the last ad1state in the trace should have no corresponding
ad2state in the trace.
If the user is interested only in checking the existence of
dierences but not in the set of all witnesses, we can stop
the steps backward as soon as the set of added states in-
cludes an initial state (by checking whether p\initials =;
already after line 9 in Proc. 5). In some cases, as our eval-
uation shows (see Sect. 6), this is indeed much faster than
waiting for the xpoint to be reached and for all traces to be
enumerated. Note that trace enumeration is not symbolic
and thus may not scale well.
Finally, for both algorithms, the concrete and the sym-
bolic, correctness and completeness are proved by induction
on the length of the traces and rely on the fact that the ADs
are internally deterministic.
5. IMPLEMENTATION AND USES
We have implemented addi and integrated it into a pro-
totype Eclipse plug-in. The input for the implementation areProcedure 5 least-xpoint-with-mem( ad1,ad2)
1:dene mem as array of Set
2:dene p; z; oldz asSet
3:dene iasnumber
4:z corr,oldz ;
5:i 0
6:mem [i] z
7:while z6=oldzdo
8: oldz z
9: p f(s1; s2)js12ad1^s22ad2^9suc12s1:successors
s.t.8suc22s2:successors (suc1; suc 2)2zg
10: z z[p
11: i i+ 1
12: mem [i] z
13:end while
14:return mem
Procedure 6 build-traces-from-mem( ad1,ad2,mem )
1:for all ini12(mem:last\initials )jad1do
2: dene tras list of Set
3: nd minimal js.t.ini1\mem [j]6=;
4: ini2 choose one from (ini1\initials )jad25: CS CombinedState (ini1; ini 2)
6: addCStotr
7: fori=jdown to 1do
8: next 1 choose one from
(CSjad1:successors\mem [i 1]jad1)
9: next 2 choose one from
(next 1\corr\mem [i 1])jad2\(CSjad2:successors )
10: CS CombinedState (next 1; next 2)
11: addCStotr
12: end for
13: addtrtotraces
14:end for
15:return traces
UML 2 ADs, drawn and parsed using Eclipse UML 2 APIs.
The plug-in transforms the input ADs into SMV format. It
then computes addi via the APIs of JTLV [27], a frame-
work for the development of verication algorithms, using
bdd-based symbolic mechanisms. The underlying BDD pack-
age used is CUDD [30]. Both algorithms are implemented
and the engineer can choose which one to use. The plug-in,
together with all the example ADs we used in the evaluation,
is available from [28].
5.1 Browsing diff traces
The plug-in allows the engineer to compare two selected
ADs, and to textually and visually browse the di traces
found, if any. Fig. 4 shows an example screenshot, where the
engineer has selected to compare diagrams hire:v 2 (top) and
hire:v 4 (middle) (presented in Sect. 2), and is browsing one
of the two di traces that were found. Note the numbered
and highlighted action nodes, which visually show the states
along one of the di traces that the plug-in has found: the
trace register ,get welcome pack ,assign to project is
possible in hire:v 2 and is not possible in hire:v 4.
A textual representation of the di trace is displayed on
the lower pane. This representation of a trace is a special
case of a model-based trace (see [15, 16]). It shows the details
of each state in the current di trace in both ADs, consisting
of the action name and all variable values. This textual
representation is important because it is more detailed and
because it scales better than the visual representation when
handling long traces.Clicking Check Difference checks whether the seman-
tics of the second AD includes the semantics of the rst.
Clicking Compute Witnesses computes the di traces and
shows a message telling the engineer how many traces were
found, if any. The Next and Previous buttons browse for
the next and previous di traces. The Switch Direction
button switches the order of comparison. The Concrete and
Symbolic buttons toggle between the two addi algorithms.
5.2 High-level evolution analysis
Another application enabled by the plug-in is high-level
evolution analysis. The plug-in supports a compare com-
mand: given two ADs, ad1andad2, the command checks
whether one AD is a renement of the other, are the two
ADs semantically equivalent, or are they semantically in-
comparable (each allows traces the other does not allow).
Formally, compare (ad1; ad 2) returns one of four answers:
< ifaddi (ad1; ad 2) =;and addi (ad2; ad 1)6=;
> ifaddi (ad1; ad 2)6=;and addi (ad2; ad 1) =;
 ifaddi (ad1; ad 2) =;and addi (ad2; ad 1) =;
<> ifaddi (ad1; ad 2)6=;and addi (ad2; ad 1)6=;
Given a reference to a series of historical versions of an
AD, as can be retrieved from the AD's entry in a revision
repository (e.g., SVN), the plug-in can use the compare com-
mand to compute a high-level analysis of the evolution of
the AD: which new versions have introduced new behaviors
relative to their predecessors, which new versions have elim-
inated behaviors relative to their predecessors, and which
new versions included only syntactical changes that have not
changed the semantics of the AD. For example, applying this
evolution analysis to the ADs presented in Sect. 2 reveals:
hire:v 1<> hire:v 2,hire:v 2> hire:v 3,hire:v 3<> hire:v 4,
proj:v 1proj:v 2 and proj:v 2< proj:v 3.
6. EV ALUATION AND DISCUSSION
6.1 Evaluation
We have tested our implementations of addi against
synthetic ADs and against real-world ADs, selected and
adapted from several sources: (1) selected ADs from a li-
brary of more than 700 business process models by IBM [8]
(our selection is representative of the size and complexity
statistics of the models in this library, as described in [8]),
(2) several models (with version history) we have obtained
from Nokia Corp., Test Management, and (3) from a third
company (which requested to remain unnamed). The IBM
models did not include version history information so we
have manually added some mutations (e.g., action additions
and removals, change of branching conditions). The models
from Nokia and the third company included version history.
All the models we have used are available in a dedicated
evaluation project that is attached to the plug-in so that all
experiments we report on below can be reproduced. The
experiments were performed on a regular laptop computer,
Intel Dual Core CPU, 2.8 GHz, with 4 GB RAM, running
Windows Vista. Running times are reported in milliseconds.
6.1.1 Quantitative evaluation
Table 1 (upper part) shows results from executing addi
over the examples presented in Sect. 2 and selected real-
world ADs from the sources mentioned above. For each
two versions we report the number of nodes, the size of theFigure 4: The prototype plug-in, comparing two ADs, hire:v 2and hire:v 4. The highlighted and numbered
nodes show one of the two di traces found by addi : for an internal employee, the trace register ,get
welcome pack , and assign to project is possible in hire:v 2and is not possible in hire:v 4. A detailed textual
representation of this di trace is provided in the lower pane.
(reachable) state space, the number of di traces found, the
length of the shortest and longest di traces found, and the
times it took the concrete and the symbolic algorithms to
(1) decide the existence of at least one di trace and (2) to
compute all di traces.
To examine scalability, we used synthetic ADs of compa-
rable or much larger size (in both number of action nodes
and state space), divided into two families of `worst case'
ADs: a family of `forking ADs' with concurrent section of
length Land growing width W, and a family of `linear ADs'
with two linear fragments of length Lseperated by a single
decision over a domain of increasing size D. The lower part
of Table 1 shows results from executing addi on these ADs,
with versions created using synthetic mutations: replacing,
deleting, or moving of actions.
These results suggest the following observations. First,
on small ADs, the two algorithms show similar performance
results. However, as the ADs grow, the symbolic algorithm
performs much better than the concrete one. On the largest
ADs, the concrete algorithm performance is not practical
while the symbolic algorithm stays within less than 4 seconds
(on all real-world ADs). We believe this means addi can
be used by engineers in practice.
Second, checking for the existence of a dierence is some-
times much faster than listing all di traces, specically
when there are many di traces or when the shortest one
is much shorter than the longest one. Again, as the ADs
grow, the symbolic algorithm outperforms the concrete one.
That said, we do have synthetic `worst case' examples
where the symbolic algorithm is not better than the concrete
one. This happens, e.g., in the extreme case of a long linear
AD with no branches or forks. It also happens when the
number of di traces is large and enumerating them takesmuch time. Moreover, the specic change done between the
two ADs may have signicant eect on both algorithms'
performance: two very syntactically similar mutations (e.g.,
a rename in one branch or in another), may induce dramatic
changes in the number of di traces. Complete results of and
models used in our experiments are available from [28].
6.1.2 Qualitative evaluation
As mentioned above, we have obtained several real-world
ADs with version history information from Nokia Corp.,
Test Management, and from another company. We used
our plug-in to compare dierent versions and analyze the
evolution of these ADs. We have also used other publicly
available di tools (Eclipse default dierencing mechanism
and EMFCompare [5]) in the analysis and compared them
with addi . Screen captures from our analysis sessions are
available from [28].
Classical textual dierencing was, as expected, not help-
ful in comparing the ADs, as it merely compared their XMI
representations. EMFCompare [5] reported correct addition
and removal of actions and transitions and presented them
on the abstract syntax tree structures of the two ADs. Still,
this was not so helpful in understanding the dierences be-
tween the ADs because (1) the comparison was done on
the AST level and abstracted the control ow away, and
(2) the results were shown on the AST and not on the
ADs themselves: we saw the changes in the AST and had
to manually search for their concrete manifestation on the
ADs. Moreover, in many cases, the list of additions and
removals reported by EMFCompare was too large to be use-
ful, e.g., when comparing hire:v 2 and hire:v 4 (presented
earlier), EMFCompare reported 23 additions and removals,
much more than one would intuitively expect for these twoAD names # Nodes Reachable state spaces # Wit. Shortest/Longest Alg. I decide/all (ms) Alg. II decide/all (ms)
hireV1/hireV2 14/15 18/26 1 6/6 69/80 57/75
hireV2/hireV3 15/15 26/21 1 4/4 53/69 53/68
hireV3/hireV4 15/15 21/22 1 4/4 50/60 54/61
projV1/projV2 13/9 22/22 0 0/0 52/52 44/47
projV2/projV3 9/11 22/28 0 0/0 53/53 41/50
IBM3561-1/2 18/18 121/122 2 7/61 105/173 113/243
IBM2905-1/2 39/39 2680/2680 80 9/10 3010/7360 911/3667
IBM2568-1/2 50/50 3834/3834 128 5/5 2725/4503 1328/3508
IBM0863-1/2 23/23 1136/1136 76 5/8 1186/2970 200/844
IBM3735-1/2 16/15 118/99 5 4/9 57/101 57/89
IBM2557-1/2 17/15 275/175 6 7/7 66/95 74/120
NokiaAV1/2 15/17 38/44 4 4/9 48/67 47/71
NokiaAV2/3 17/23 44/96 4 7/7 71/101 76/111
NokiaAV3/4 23/23 96/76 4 7/7 84/119 98/137
AnonV1/2 15/15 37/37 2 6/6 50/64 47/61
AnonV2/3 15/19 37/80 1 8/8 67/72 57/70
forking(W1/L6)/mutated 12/12 11/11 1 9/9 57/79 49/58
forking(W2/L6)/mutated 18/18 89/89 1 15/15 121/135 100/138
forking(W3/L6)/mutated 24/24 887/887 1 21/21 1293/1332 496/667
forking(W4/L6)/mutated 30/30 8237/8237 1 27/27 88878/89399 5892/7757
lbl(L12/D16)/mutated 34/34 496/496 1 15/15 367/608 373/507
lbl(L12/D32)/mutated 34/34 992/992 1 15/15 698/1377 678/895
lbl(L12/D64)/mutated 34/34 1984/1984 1 15/15 2242/4874 1651/2161
lbl(L12/D128)/mutated 34/34 3968/3968 1 15/15 9867/23529 5789/6685
Table 1: Results from computing addi for selected example, real-world, and synthetic ADs (see Sect. 6.1.1).
For each two versions we report the number of nodes, the reachable state space, the number of di traces
found, the length of the shortest and longest di traces found, and the times it took the concrete and the
symbolic algorithms to (1) decide the existence of at least one di trace and (2) to compute all di traces.
ADs ( addi reports a total of three di witnesses for this
example (two in one direction, one in the other)).
In contrast, our plug-in computed di traces and high-
lighted them, visually, on the ADs themselves. Thus, in
addition to the semantic characteristics of the comparison,
which shows the actual meaning of the changes that were
done, we have also experienced the advantages of language-
specic dierencing over language-agnostic dierencing as
well as the advantage of showing the dierences directly on
the original diagrams rather than in a separate list.
The following lessons learned are noteworthy. First, in
some cases the number of traces returned by addi was
large and the usefulness of the results was limited. To ad-
dress this in the future we consider adding lters, e.g., to
group together traces that agree on the list of actions and
dier in the values of input variables, and present only a
representative trace from each group. Similarly, we consider
user interaction: the engineer would choose a node of inter-
est and the plug-in would limit the results to di traces that
include/exclude this node.
Second, some of the ADs we have analyzed included `swim
lanes', which relate action nodes with roles. It seems that
`swim lanes', which are optional in the UML standard [24],
are rather popular, so in the future it may be useful to add
the role information to the semantics of ADs and consider
it in computing the dierences.
Finally, some of the ADs we have investigated were only
semi-formal or included minor changes in action names, which
seem to indeed be `renames' rather than new actions with
similar names. addi considers such `renames' as new ac-
tions, and we had to manually identify these cases and `cor-
rect' them. To better address these cases in the future, a
matching heuristics needs to be employed, based perhaps not
only on syntactic structural similarity matching but also on
natural language and domain-specic ontology.6.2 Discussion
6.2.1 Alternatives and extensions
Our current denition of di traces does not require that
they can be extended into accepting traces (ones that end
at a nal node, see Def. 3). We have chosen not to require
this, in order to support the comparison of incomplete and
perhaps inconsistent ADs, ones where not all executions are
eventually accepted. Such ADs may exist, mainly at the
early stages of the version history of a model (indeed in our
evaluation we have seen such `incomplete' ADs). We could
have given a more restrictive denition that limits di traces
to ones that can be extended to accepted traces. Adapting
the algorithms we have presented to this restricted denition
is not dicult.
Moreover, we have chosen to compute only a single short-
est representative of the di traces outgoing each initial AD
state (that is, a single shortest di trace for each assignment
to input variables of the rst AD). We consider this to be
a good choice, as it keeps the addi results relatively suc-
cinct and thus easy to read and understand by engineers,
in most typical cases. Alternatively, one may suggest to
compute a larger set, containing all di traces. Adapting
the algorithms to this more permissive denition is possible,
however, as there may be exponentially many such traces,
performance may be a problem. On the other hand, and in
contrast, following the lesson learned in our evaluation we
consider an alternative that would limit the number of di
traces to present: group them according to the list of ac-
tions they include and present a single representative trace
of each group together with a predicate that describes the
input variable values that are common to the traces in the
group. We believe this may be computed symbolically, i.e.,
while avoiding the enumeration of all traces in the compu-
tation. We leave this for future work.Finally, our current work supports a subset of the UML
2 AD language. In particular, we do not yet support struc-
tured activity nodes, which allow hierarchical nesting of ac-
tion nodes or reference from a node to another activity. Hi-
erarchy is useful in medium and large scale designs, so sup-
porting it is important. Moreover, a hierarchy induces an
abstraction mechanism, which a semantic comparison may
take advantage of. Additional language features may be
added. We leave these for future work.
6.2.2 Syntactic differencing and matching
Semantic dierencing in general, and addi in particular,
do not come to replace existing syntactic dierencing ap-
proaches. Rather, they are aimed at augmenting and com-
plementing existing approaches with capabilities that were
not available before. Thus, combining addi with exist-
ing approaches to matching and syntactic dierencing (see,
e.g., [14, 32]), is an important direction for future work. For
example, we may extend the applicability of semantic dif-
ferencing in comparing diagrams whose elements have been
renamed or moved in the course of evolution, by applying
a syntactic matching before running the semantic dierenc-
ing. The result of such an integrated solution would be a
mapping plus a set of di traces. As another example, we
may use information extracted from syntactic dierencing
as a means to localize and improve the presentation and
performance of the semantic dierencing computation.
7. RELATED WORK
We discuss related work on AD formal semantics and anal-
yses, and on model and program comparisons.
Eshuis [7] presents symbolic model checking of ADs. The
work transforms ADs into SMV and uses the NuSMV model
checker to verify LTL properties. The semantics given is
partly inspired by the semantics of STATEMATE [9]. Our
translation of ADs into SMV is somewhat similar to the two
translations suggested in [7]. [7] does not handle data while
our work does. The motivation of [7] is model checking while
our motivation is model comparison. St orrle [31] denes a
denotational semantics for UML 2 ADs as a mapping to
procedural Petri nets. He also surveys and compares several
previous studies that deal with a semantics for ADs, in terms
of their semantic domain and expressiveness. Knieke and
Goltz [12] present an executable semantics for UML 2 ADs
with step semantics adapted from [9]. The works of [7, 12]
support object nodes and several types of action nodes, while
our current work supports only basic action nodes. Our work
can be extended to support object nodes and other types
of action nodes. Our focus is not on the dierent possible
variants of ADs and their semantics but on the denition
and the computation of the semantic di operator we have
presented, and on its use in evolution related tasks.
Model and program dierencing, in the context of software
evolution, has attracted much research eorts in recent years
(see [1, 6, 14, 21, 23, 32]). In contrast to our work, almost all
studies in this area, however, present syntactic dierencing,
at either the concrete or the abstract syntax level.
Alanen and Porres [1] describe the dierence between two
models as a sequence of elementary transformations, such
as element creation and deletion and link insertion and re-
moval; when applied to the rst model, the sequence of
transformations yields the second. Kuster et al. [14] inves-
tigate dierencing and merging in the context of processmodels, focusing on identifying dependencies and conicts
between change operations. Engel et al. [6] present the use
of a model merging language to reconcile model dierences.
Comparison is done by identifying new/old MOF IDs and
checking related attributes and references recursively. Re-
sults include a set of additions and deletions, highlighted in
a Di/Merge browser. Mehra et al. [21] describe a visual dif-
ferentiation tool where changes are presented using editing
events such as add/remove shape/connector etc. Xing and
Stroulia [32] present an algorithm for object-oriented design
dierencing whose output is a tree of structural changes,
reporting dierences in terms of additions, deletions, and
moves of model elements, assisted by a set of similarity met-
rics. Ohst et al. [23] compare UML documents by traversing
their abstract-syntax trees, detecting additions, deletions,
and shifts of sub-trees.
As the above shows, some works go beyond the concrete
textual or visual representation and have dened the com-
parison at the abstract-syntax level, detecting additions, re-
movals, and shifts operations on model elements. However,
to the best of our knowledge, no previous work considers
model comparisons at the level of the semantic domain, as
is done in our work.
Some works, e.g. [5, 32], use similarity-based matching be-
fore actual dierencing. As our work focuses on semantics,
it assumes a matching is given. Matching algorithms may
be used to suggest a matching before the application of se-
mantic dierencing. The result of such an integration would
be a mapping plus a set of dierentiating traces.
We are aware of only a few studies of semantic dierenc-
ing between programs. Jackson and Ladd [11] summarise
the semantic di between two procedures in terms of ob-
servable input-output behaviors. Apiwattanapong et al. [2]
present a behavioral di for object-oriented programs based
on an extended control-ow graph, and a tool that imple-
ments it in the context of Java. Finally, Person et al. [25]
suggest to compute a behavioral characterization of a pro-
gram change using a technique called dierential symbolic
execution. We focus on model comparison and not on pro-
gram comparison. Also, while our work is somewhat similar
to these works in terms of motivation, it is very dierent in
terms of technology.
8. CONCLUSION
We presented addi , a semantic dierencing operator for
activity diagrams. Unlike existing approaches to model com-
parison, addi performs a semantic comparison and outputs
a set of di witnesses, each of which is an execution trace
that is possible in the rst AD and is not possible in the
second. We have formally dened addi , described two al-
gorithms to compute it, a concrete one and a more scalable
symbolic one, and demonstrated its application in compar-
ing ADs within the Eclipse IDE. addi can help developers
to understand and evaluate the dierences between versions
of ADs so that they can reason about the impact of changes.
When applied to the version history of a given AD, addi
provides a semantic insight into its evolution, which is not
available in existing syntactic approaches.
We suggested a number of future work directions in Sect. 6,
among them, the development of more succinct, symbolic,
or task-oriented representation of di traces, the integration
ofaddi with existing approaches to matching and syntac-
tic dierencing, and the extension of addi to cover a largersubset of the UML 2 AD language, in particular, handling
hierarchical actions, which are useful when considering the
specication of medium and large scale activities.
Finally, addi is part of a larger project that applies the
idea of semantic dierencing and computation of di wit-
nesses to several modeling languages [19]. We have recently
presented our work on semantic dierencing for class dia-
grams [18] and hope to report additional results from this
project in future papers.
Acknowledgements We are grateful to Tuula P aakkonen
for help in obtaining the models from Nokia Corp., to Dirk
Fahland for suggesting the use of the library of process mod-
els by IBM, to Yaniv Sa'ar for advice on the implementation
of the algorithms in JTLV, and to Smadar Szekely and Guy
Weiss for advice on Eclipse plug-in development.
9. REFERENCES
[1] M. Alanen and I. Porres. Dierence and union of
models. In P. Stevens, J. Whittle, and G. Booch,
editors, Proc. 6th Int. Conf. on the UML , volume 2863
ofLNCS , pages 2{17. Springer, 2003.
[2] T. Apiwattanapong, A. Orso, and M. J. Harrold. JDi:
A dierencing technique and tool for object-oriented
programs. Autom. Softw. Eng. , 14(1):3{36, 2007.
[3] J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill,
and L. J. Hwang. Symbolic model checking: 1020
states and beyond. Inf. Comput. , 98(2):142{170, 1992.
[4] R. Cavada, A. Cimatti, C. A. Jochim, G. Keighren,
E. Olivetti, M. Pistore, M. Roveri, and A. Tchaltsev.
NuSMV User Manual, 2005.
[5] EMF Compare.
http://www.eclipse.org/modeling/emft/?project=compare.
[6] K.-D. Engel, R. F. Paige, and D. S. Kolovos. Using a
model merging language for reconciling model
versions. In A. Rensink and J. Warmer, editors,
ECMDA-FA , volume 4066 of LNCS , pages 143{157.
Springer, 2006.
[7] R. Eshuis. Symbolic model checking of UML activity
diagrams. ACM Trans. Softw. Eng. Methodol. ,
15(1):1{38, 2006.
[8] D. Fahland, C. Favre, B. Jobstmann, J. Koehler,
N. Lohmann, H. V olzer, and K. Wolf. Instantaneous
soundness checking of industrial business process
models. In U. Dayal, J. Eder, J. Koehler, and H. A.
Reijers, editors, BPM , volume 5701 of LNCS , pages
278{293. Springer, 2009.
[9] D. Harel and A. Naamad. The STATEMATE
Semantics of Statecharts. ACM Trans. Softw. Eng.
Methodol. , 5(4):293{333, 1996.
[10] D. Harel and B. Rumpe. Meaningful modeling:
What's the semantics of \semantics"? IEEE
Computer , 37(10):64{72, 2004.
[11] D. Jackson and D. A. Ladd. Semantic di: A tool for
summarizing the eects of modications. In H. A.
Muller and M. Georges, editors, ICSM , pages 243{252.
IEEE Computer Society, 1994.
[12] C. Knieke and U. Goltz. An executable semantics for
UML 2 activity diagrams. In Proc. Int. Workshop on
Formalization of Modeling Languages (FML) , 2010.[13] H. Krahn, B. Rumpe, and S. V olkel. MontiCore: a
framework for compositional development of domain
specic languages. Int. J. on Software Tools for
Technology Transfer (STTT) , 12(5):353{372, 2010.
[14] J. M. K uster, C. Gerth, and G. Engels. Dependent
and conicting change operations of process models.
In R. F. Paige, A. Hartman, and A. Rensink, editors,
ECMDA-FA , volume 5562 of LNCS , pages 158{173.
Springer, 2009.
[15] S. Maoz. Model-based traces. In M. R. V. Chaudron,
editor, MoDELS Workshops , volume 5421 of LNCS ,
pages 109{119. Springer, 2008.
[16] S. Maoz. Using model-based traces as runtime models.
IEEE Computer , 42(10):28{36, 2009.
[17] S. Maoz, J. O. Ringert, and B. Rumpe. An
Operational Semantics for Activity Diagrams using
SMV. Technical Report AIB 2011-07, RWTH Aachen
University, Germany, 2011.
[18] S. Maoz, J. O. Ringert, and B. Rumpe. CDDi:
Semantic dierencing for class diagrams. In
M. Mezini, editor, Proc. 25th Euro. Conf. on Object
Oriented Programming (ECOOP'11) , volume 6813 of
LNCS , pages 230{254. Springer, 2011.
[19] S. Maoz, J. O. Ringert, and B. Rumpe. A manifesto
for semantic model dierencing. In J. Dingel and
A. Solberg, editors, MoDELS Workshops , volume 6627
ofLNCS , pages 194{203. Springer, 2011.
[20] K. McMillan. Symbolic Model Checking . Kluwer
Academic Publishers, 1993.
[21] A. Mehra, J. Grundy, and J. Hosking. A generic
approach to supporting diagram dierencing and
merging for collaborative design. In ASE, pages
204{213. ACM, 2005.
[22] MontiCore project. http://www.monticore.org/.
[23] D. Ohst, M. Welle, and U. Kelter. Dierences between
versions of UML diagrams. In Proc. ESEC /
SIGSOFT FSE , pages 227{236. ACM, 2003.
[24] OMG. UML, version 2.2, OMG Specication, 2009.
[25] S. Person, M. B. Dwyer, S. G. Elbaum, and C. S.
Pasareanu. Dierential symbolic execution. In
SIGSOFT FSE , pages 226{237. ACM, 2008.
[26] N. Piterman, A. Pnueli, and Y. Sa'ar. Synthesis of
reactive(1) designs. In E. A. Emerson and K. S.
Namjoshi, editors, VMCAI , volume 3855 of LNCS ,
pages 364{380. Springer, 2006.
[27] A. Pnueli, Y. Sa'ar, and L. Zuck. JTLV: A framework
for developing verication algorithms. In T. Touili,
B. Cook, and P. Jackson, editors, CAV , volume 6174
ofLNCS , pages 171{174. Springer, 2010.
[28] Semantic di project.
http://www.se-rwth.de/materials/semdiff/.
[29] SMV model checker.
http://www.cs.cmu.edu/~modelcheck/smv.html.
[30] F. Somenzi. CUDD: CU Decision Diagram package.
http://vlsi.colorado.edu/~fabio/CUDD/, 1998.
[31] H. St orrle. Semantics of control-ow in UML 2.0
activities. In VL/HCC , pages 235{242. IEEE
Computer Society, 2004.
[32] Z. Xing and E. Stroulia. Dierencing logical UML
models. Autom. Softw. Eng. , 14(2):215{259, 2007.