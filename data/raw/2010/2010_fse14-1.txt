HAL Id: hal-01087789
https://inria.hal.science/hal-01087789v1
Submitted on 26 Nov 2014
HAL is a multi-disciplinary open access
archive for the deposit and dissemination of sci-
entific research documents, whether they are pub-
lished or not. The documents may come from
teaching and research institutions in F rance or
abroad, or from public or private research centers.Lâ€™archive ouverte pluridisciplinaire HAL , est
destinÃ©e au dÃ©pÃ´t et Ã  la diffusion de documents
scientifiques de niveau recherche, publiÃ©s ou non,
Ã©manant des Ã©tablissements dâ€™enseignement et de
recherche franÃ§ais ou Ã©trangers, des laboratoires
publics ou privÃ©s.
Counterexample Guided Abstraction Refinement of
Product-Line Behavioural Models
Maxime Cordy , Patrick Heymans, Axel Legay , Pierre-Y ves Schobbens, Bruno
Dawagne, Martin Leucker
T o cite this version:
Maxime Cordy , Patrick Heymans, Axel Legay , Pierre-Y ves Schobbens, Bruno Dawagne, et al.. Coun-
terexample Guided Abstraction Refinement of Product-Line Behavioural Models. FSE 2014 : Interna-
tional Symposium on F oundations of Software Engineering, Nov 2014, Hong Kong, Hong Kong SAR
China. pp.190-201, ï¿¿10.1145/2635868.2635919ï¿¿. ï¿¿hal-01087789ï¿¿Counterexample Guided Abstraction Reï¬nement of
Product-Line Behavioural Models
Technical Report
Maxime Cordy
PReCISE Research Center
University of Namur, Belgium
mcr@info.fundp.ac.bePatrick Heymans
PReCISE Research Center,
University of Namur, Belgium.
phe@info.fundp.ac.beAxel Legay
INRIA Rennes, France
axel.legay@inria.fr
Pierre-Yves Schobbens
PReCISE Research Center,
University of Namur, Belgium.
pys@info.fundp.ac.beBruno Dawagne
PReCISE Research Center,
University of Namur, Belgium.
bdawagne@student.fundp.ac.beMartin Leucker
University of LÃ¼beck, Germany
leucker@isp.uni-
luebeck.de
ABSTRACT
The model-checking problem for Software Products Lines
(SPLs) is harder than for single systems: variability con-
stitutes a new source of complexity that exacerbates the
state-explosion problem. Abstraction techniques have suc-
cessfully alleviated state explosion in single-system models.
However, they need to be adapted to SPLs, to take into
account the set of variants that produce a counterexample.
In this paper, we apply CEGAR (Counterexample-Guided
Abstraction Renement) and we design new forms of ab-
straction specically for SPLs. We carry out experiments to
evaluate the eciency of our new abstractions. The results
show that our abstractions, combined with an appropriate
renement strategy, hold the potential to achieve large re-
ductions in verication time, although they sometimes per-
form worse. We discuss in which cases a given abstraction
should be used.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation| Model checking
Keywords
Software Product Lines, Model Checking, CEGAR, Abstrac-
tion, Features
1. INTRODUCTION
Variability is ubiquitous in today's systems, be it in the
form of conguration options or extensible architectures. By
FNRS Research Fellow
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
FSE 2014, November 16â€“22, Hong Kong
.mastering variability, developers can adapt their system to
changing requirements without having to develop entirely
new applications. Software Product Lines (SPLs) are a pop-
ular form of variability-intensive systems. They are fami-
lies of similar software systems developed together to make
economies of scale [19]. SPL engineering aims to facilitate
the development of the members of a family (called products
orvariants ) by identifying upfront their commonalities and
dierences. Variability in SPLs is commonly represented in
terms of features ,i.e., units of dierence between products
that appear natural to stakeholders. Each product of an
SPL is therefore dened by its set of features. Hierarchies of
features and dependencies between features ( e.g., requires,
excludes) are typically captured in a Feature Model (FM),
i.e.a tree-like structure that species which combinations
of features are valid [30, 38] (see Figure 3 in Section 2 for
an example).
Nowadays, SPL engineering is widespread in industry, in-
cluding critical areas like automotive and avionics. The
emergence and the increasing popularity of SPLs have raised
the need for SPL-specic quality assurance techniques. In-
deed, engineers have to provide solid evidence that allthe
products they build satisfy their intended requirements. Mo-
reover, in case of failure, they should identify which features,
or combinations of features, are responsible for the errors in
order to facilitate repair.
Model checking is an automated technique to verify a be-
havioural model of a system against a property expressed
in temporal logic [12, 5]. It relies on an exhaustive ex-
ploration of the model in search for counterexamples, i.e.,
executions that violate the property to verify. Due to its
exhaustiveness, model checking is costly in time and mem-
ory. When applied to real systems with a typically huge
state space, model checking faces a combinatorial blow-up
called state explosion . The model-checking problem is even
harder for SPLs: in this case, the model checker must ei-
ther prove the absence of errors or nd a counterexample
foreach variant that can produce a violation. Given that
the worst-case number of products of an SPL is exponential
in the number of features, variability dramatically exacer-
bates state explosion. As a consequence, it is not feasible
to apply single-system model checking to the thousands ofvariants that can compose real-world SPLs.
In recent years, many variability-aware techniques have
been designed to address the SPL model checking prob-
lem [28, 18, 17, 2, 4]. These techniques keep track of vari-
ability information contained in an SPL behavioural model
to associate each execution path to the exact set of variants
able to produce it. By doing so, they are able to identify the
set of products that violate a given property, and to report
a counterexample of violation for each of them. Moreover,
being aware of variability allows them to check behaviour
common to several products only once. This is a clear im-
provement over an enumerative application of single-system
model checking, which veries a behaviour as many times as
there are products that can exhibit it.
Although earlier experiments suggest that these techni-
ques bring substantial performance gains [16, 3], further im-
provements are required to verify industrial SPLs. First,
SPL model-checking methods still suer from the state-explo-
sion problem inherent to model checking. Second, their prac-
tical time complexity still grows more than linearly with the
number of features [14]. In single-system verication, one
of the most eective answers to state explosion is model ab-
straction , which creates more concise { therefore easier to
verify { models of the system, typically by merging similar
states. This reduced size often comes at the cost of inaccu-
racies in the models, thereby aecting the properties they
satisfy. A reported counterexample can therefore be spuri-
ous, that is, it exists within the abstract model but the not
in the real, concrete model. In this case, the abstraction
must be rened to eliminate this false positive. Common
methods to achieve this renement make use of the spurious
counterexample itself. They give rise to Counterexample
Guided Abstraction Renement (CEGAR), i.e.abstraction
techniques that iteratively rene an abstract model until ei-
ther they nd a real counterexample or they can prove the
absence of violation [11].
In spite of their success in single-system model checking,
abstraction techniques for SPLs have received little atten-
tion (see more in Section 6). In this paper, we ll this gap
and propose SPL-specic abstraction procedures based on
CEGAR. Applying CEGAR to SPLs is more tedious be-
cause a counterexample can be real for some products and
spurious for others. This observation leads us to two rene-
ment strategies: one renes the model as soon as it nds
a spurious counterexample, whereas the other performs the
spuriousity check and the renement after the discovery of
all the counterexamples. As for the abstraction of the model,
we distinguish between (1) state abstraction that only merge
states as in single-model abstraction, (2) feature abstraction
that modies only the variability information contained in
the model, and (3) mixed abstraction that combines the pre-
vious two types. This latter type is the most complicated to
implement, as spuriousness can originate from the merging
of states, the abstraction of features, or both. Through-
out the paper, we systematically prove the correctness of
our approach on the basis of mathematical relations such
as simulation relations. We implemented both abstractions
and their combination in ProVeLines, an SPL model checker
we developed [15, 23]. We carried out experiments to eval-
uate the eciency of dierent combinations of renement
strategies and abstractions. Our results tend to show that
state abstraction brings performance gains most of the time,
whereas feature abstraction generally results in small losses
87513closechangesodaserveSoda2payopenFigure 1: A TS modelling a vending machine
of performance but achieve huge decreases of verication
time in some cases. Preliminary experiments on mixed ab-
straction tend to show that its performance is comparable
to that of state abstraction, although slightly worse on av-
erage. Other abstractions of this kind could, however, be
designed as part of future work and yield better results.
The structure of the paper is as follows. Section 2 recapit-
ulates essential background. We present an overview of our
CEGAR procedures and renement strategies in Section 3.
In Section 4, we show how to build the three forms of ab-
straction functions and to detect spurious counterexample
in each case. We describe our implementation and report
evaluation results in Section 5. Finally, we discuss related
work in Section 6.
2. BACKGROUND
In this section, we recapitulate established concepts re-
lated to the verication and abstraction of single-system be-
havioural models. We also recall some denitions of our
previous work that are needed in this paper.
2.1 Counterexample Guided Abstraction Re-
ï¬nement
Model checking is an established technique for verifying
both hardware and software against temporal properties [12,
5]. Basically, given the model of a system Mand a temporal
property , a model-checking algorithm determines whether
or notMsatises , written Mj= . For single systems, a
transition system (TS) is commonly used as a model for the
system. It is dened as follows.
Denition 1 [5]A TS is a tuple (S;Act;trans;I;AP;L )
whereSis a set of states, Actis a set of actions, trans
SActSis the transition relation, ISis a set of initial
states,APis a set of atomic propositions, and L:S!2AP
is a labelling function that associates every state with the
set of atomic propositions satised by this state. We assume
that every TS has no terminal state, i.e. a state without
outgoing transition.
Figure 1 shows a TS representing a soda vending machine.
For clarity, we did not display the atomic propositions sat-
ised by each state.
In what follows, we also denote ( s;;s0)2trans bys  !
s0. An execution of the model is an alternating innite se-
quence of states and actions that satises the transition re-
lation, i.e.a sequence s00s11:::withsii !si+1for any
i0. A trace (also called behaviour ) of the system is the
sequence of atomic propositions satised during one of its
executions. The semantics of a TS, noted [ [ ts] ]TS, is then its
set of behaviours:
[ [ts] ]TS=fL(s0);L(s1);:::js02I^(sii !si+1)g:
After building a TS, one can verify it against a prop-
erty expressed in temporal logic. In this paper, we par-
ticularly focus on Linear Time Logic (LTL) [36]. For in-
stance, a desired property for the vending machine is that itwill eventually serve soda each time soda is ordered, noted
(sodaordered)sodaserved ) in LTL. Given a TS and a
property , a model checker reports either that the property
holds in the model or a counterexample ,i.e.an execution of
the model that violates the property. In our example, the
TS indeed satises the aforementioned property since it will
necessarily reach state 7 after state 5.
TS can model a software product at dierent abstraction
levels. If a more abstract (that is, smaller) model preserves
the properties of a larger model, it is more ecient to check
the properties on the abstract model. It is therefore essential
to relate two models from dierent abstraction levels. For
single systems, this information is formally captured by a
simulation relation [33].
Denition 2 [33, 5] LetTSi= (Si;transi;Ii;AP;Li);i2
f1;2gbe two TS over AP. A simulation for (TS1;TS 2)is
a binary relation RS1S2such that
1.8s12I19s22I2(s1;s2)2R and
2.8(s1;s2)2R it holds that L1(s1) =L2(s2)and8s0
12
Post (s1)9s0
22Post (s2)(s0
1;s0
2)2R.
wherePost (s) =fs0j9s  !s0gdenotes the set of states
that can be reached from s. Then,TS2simulatesTS1, de-
noted byTS14TSTS2i there exists a simulation for
(TS1;TS 2).
According to this denition, if TS2simulatesTS1, thenTS2
can reproduce any behaviour of TS1. Simulation can char-
acterise the behaviour of an abstract transition system bts
with regard to an original model ts. Informally, an abstract
transition system is obtained by merging states for which a
so-called abstraction function returns the same value. The
abstraction may add or remove behaviour, depending on the
chosen abstraction function. However, a relevant analysis re-
quires to have either ts4TSbts,bts4TStsor both. Under
this condition, the abstraction preserves the (un)satisability
of properties expressed in particular logics. In particular, an
LTL formula satised by the simulating TS is preserved in
the simulated one.
Property 3 [33, 5] LetTS1andTS2be two transition sys-
tems and an LTL property. Then,
TS14TSTS2)(TS2j= )TS1j= ):
In other words, if TS1does not satisfy , neither does TS2.
In particular, if TS2is an abstraction of TS1, proving that
the abstract TS2veries an LTL formula suces to ensure
that the formula holds for TS1. Therefore, abstraction can
drastically shorten the time and space cost of verication.
In this paper, we consider existential abstraction functions.
Denition 4 [11] An existential abstraction his a surjec-
tionh:S!bSsuch thath(s) =h(s0))L(s) =L(s0).
An abstraction of a TS under hisTSh= (bS; Act ,transh;
Ih; AP; Lh)wherebS=fh(s)js2Sg,Ih=fh(s0)js02Ig,
Lh(h(s)) =L(s), andtranshis dened such that s  !s0)
h(s)  !h(s0).
Existential abstractions can facilitate verication thanks
to two interesting properties. First, TShis such that TS4TS
TSh[11]. Second, they can be dened such that bSis sig-
nicantly smaller than S. Therefore, for a given LTL for-
mula  we can prove that the concrete TS satises  by
876513cancel / creturn / cclosechangefree / fsoda / sserveSoda / stea / t24serveTea / tpay / Â¬fopenFigure 2: A FTS modelling a vending machine SPL
proving that TShsatises . However, if TShdoes not sat-
isfy  then TSmay still satisfy , that is, the reported
counterexample is spurious . This may occur when TShhas
strictly more behaviour than TS. In this case, it is required
torene the abstraction in order to eliminate the spurious
counterexample. From the renement, we obtain a new ab-
straction function h0which is less coarse than h, that is,
TS4TSTSh04TSTSh.
Counterexample Guided Abstraction Renement (CEGAR)
is an established renement method that consists in using a
spurious counterexample to rene the abstraction [11]. From
the concrete TS, we build an initial abstraction based on a
given existential abstraction function. We then feed the ab-
stract model into the model checker together with the prop-
erty to check. If the abstraction satises the formula, then
so does the concrete TS. Otherwise, we replay the coun-
terexample on the concrete system to determine whether it
is spurious. If it is not, then the concrete TS violates the
formula. Otherwise, we rene the abstraction on the basis
of the counterexample and we repeat the process.
2.2 Featured Transition Systems
Although TS are suitable to model the behaviour of indi-
vidual systems, they cannot represent the behaviour of an
SPL and link each behaviour to the exact set of products
able to execute it. To overcome this, we dened Featured
Transition Systems (FTS) [18]. Basically, an FTS is a TS
where each transition receives an additional label that spec-
ies which combinations of features are required to trigger
the transition. These features are declared in an FM that
establishes the set of legal feature combinations [30, 38], i.e.
thevalid products of the SPL. For this paper, it is enough
to know that the semantics of a FM ddened over a set of
featuresFis the set of all the valid products, that is a set of
sets of features, denoted by [ [ d] ]FM2F. For a more formal
denition of FMs, see Schobbens et al. [38]. Formally, FTS
are dened as follows.
Denition 5 [17]An FTS is a tuple (S;Act;trans;I;AP;L;
d; ), whereS;Act;trans;I;AP;L are dened as in Deni-
tion 1,dis a FM over features F, and:trans!B(F)
is a total function labelling each transition with a feature
expression , i.e. a Boolean function over the set of features.
By[ [(t)] ], we denote the set of products that satisfy (t).
Figure 2 shows an FTS modelling a vending machine SPL
which includes the vending machine presented in Figure 2.
We observe that transition 1free   ! 3 is labelled with feature
f, meaning that feature fis required to trigger the transi-
tion. On the contrary, 1pay  ! 2 is labelled with :f, meaning
that feature fmust not be present to trigger the transition.
Note that a feature model can also be regarded as a fea-
ture expression, i.e., the formula encoding all the constraints
it expresses. Henceforth, we use dto denote this feature ex-VendingMachinevTeatFreeDrinksfCancelPurchasecSodasBeveragesbLegend:aa= and= ora= optionalProducts from Figure 1:(a) Basic = {v, b, s}(b) Tea and soda = {v, b, s, t}(c) Cancel function = {v, b, s, c}(d) Soda for free = {v, b, s, f}Figure 3: The FM modelling the variability of the vending
machine SPL
pression as well. Thanks to the labelling function , an
FTS encodes the behaviour of a set of products. More pre-
cisely, the TS modelling a given product p, notedFTSjp, is
obtained by removing all the transitions that pcannot ex-
ecute. This operator is called projection [18]. For instance,
the TS shown in Figure 1 is the projection of the vend-
ing machine FTS onto product fv;sg. The semantics of an
FTS, noted [ [ :] ]FTS, is therefore a function that associates
each valid product with the semantics of the projection of
the FTS onto that product. In this paper, we use FTS to
model the behaviour of SPLs; being a fundamental formal-
ism, it can be regarded as a unied semantics for higher-level
SPL behavioural modelling languages.
The model checking problem for SPLs is dierent from its
single-system counterpart. Its objective is indeed to identify
allthe product variants that can execute a counterexample.
We previously designed ecient algorithms to check an FTS
against LTL formulae [18, 16]. During an exploration, these
algorithms keep track of the feature expressions met along
the transitions. This means that they separate the veri-
cation of dierent sets of products only if they discover a
behavioural discrepancy between them. This optimisation is
called late splitting [3]. Furthermore, the accumulated fea-
ture expressions allow to associate a found counterexample
to the exact set of products that execute it. An immediate
consequence is that the model checker may have to discover
multiple counterexamples to identify all the violating prod-
ucts. Unlike single-system model checking, the search thus
cannot stop after one counterexample is found. This is a
fundamental dierence that has a real importance in the
design of abstraction methods for SPL model checking.
It may happen that a property is relevant only to a subset
of the products. Hence, we extended LTL with a feature
quantier [18]. A formula of the resulting logic, called fLTL,
has the form [ ] whereis a feature expression and  is
an LTL formula. Intuitively, it means that  has to hold
only for valid products described by . Formally, the set of
products satisfying [ ] is
[ [FTSj= []] ] =fp2[ [d] ]FMjp2[ [] ])FTSjpj= g:
As a simulation relation is a prerequisite to prove the cor-
rectness of abstraction-based model checking, we need to
extend this concept to make it applicable to FTS and aware
of variability. This new relation, named F-simulation , is
dened as follows.
Denition 6 [21]Letftsi= (Si,Acti,transi,Ii,AP,Li,d,i),i2f1;2g, be two FTS. Then, the set of valid products
for whichfts 1is simulated by fts 2, is
[ [fts 14FTSfts 2] ] =fp2[ [d] ]FM:fts 1jp4TSfts 2jpg:
fts 1is simulated by fts 2i[ [fts 14FTSfts 2] ] = [ [d] ]FM.
Iffts 2simulatesfts 1, then for each valid product pevery
behaviour of pinfts 1is also a behaviour of pinfts 2. There-
fore, any fLTL formula satised in fts 2is also satised in
fts 1. Ecient computation algorithms are found in [22].
For this paper, we just need its denition.
3. CEGAR STRATEGIES IN SPL MODEL
CHECKING
The only way to apply existing abstraction techniques [27,
11, 13] to SPLs is to execute them either product by product
or on a product simulator [2]. These methods thus cannot
address the SPL model-checking problem as we dened it in
the previous section. There are two fundamental dierences
between single-system and SPL model checking. First, a
model for multiple products, viz.an FTS, is checked as op-
posed to a single-system model, viz.a TS. This implies that
(1) an appropriate abstraction function must preserve the
behaviour of all the products modelled by the FTS, and (2)
this function can modify the labelling function . To pro-
duce FTS abstractions, we can thus either merge states as
in single-system abstraction, weaken feature expressions to
make transitions available to more products, or both. These
three solutions, shown in Figure 4, are respectively called
state abstraction ,feature abstraction , and mixed abstraction .
A second requirement is that the CEGAR process cannot
stop after only one real counterexample is found if this coun-
terexample is not executable by all products. If it does stop,
the model checker could ignore violations performed by other
products; the SPL model checking problem would thus not
be answered appropriately. To address these requirements,
we rst extend the denition of existential abstraction, a
common abstraction method that does not remove existing
behaviours, and we provide property preservation proofs.
Then we present two SPL-specic CEGAR procedures that
can verify all the products.
As before, we consider existential abstraction functions as
these guarantee behaviour preservation. To transpose this
concept to FTS while maintaining the preservation property,
we add another requirement to the abstraction function: any
product that can execute a concrete transition must be able
to execute the corresponding abstract transition. This leads
to the following new denition of existential abstraction.
Denition 7 An F-abstraction is a surjection h:S!bS
such thath(s) =h(s0))L(s) =L(s0). An abstraction of a
FTS under hisFTSh= (bS;Act ,transh;Ih;AP;Lh;d;h)
wherebS; Act ,transh; Ih; AP; Lhare as in Denition 4 and
his such that
 _
s2h 1(bs);s02h 1(bs0)s  !s0(s;;s0)
)h(bs;;bs0) (1)
or equivalently
 [
s2h 1(bs);s02h 1(bs0)s  !s0[ [(s;;s0)] ]
[ [h(bs;;bs0)] ]:87513cancel / creturn / cclosechangefree / fsoda / sserveSoda / stea / t24serveTea / tpay / Â¬fopen(a) State abstraction
876513cancelreturnclosechangefreesodaserveSodatea24serveTeapayopen
(b) Feature abstraction
87513cancelreturnclosechangefreesodaserveSodatea24serveTeapayopen
(c) Mixed abstraction
Figure 4: Examples of the three forms of abstraction.
Intuitively, his responsible for state abstractions, whereas
hcreates feature abstractions. Any FTS obtained from an
F-abstraction simulates the concrete FTS for all products.
Theorem 8 Lethbe an F-abstraction function. Then we
have [ [FTS4FTSFTSh] ] = [ [d] ]FM.
Proof. Since existential abstractions from TS preserve
the behaviour of the concrete TS modulo simulation (see Sec-
tion 2), any given transition of FTS is also a transition of
FTSh. It thus remains to prove that this transition is avail-
able inFTShfor at least the same set of products, that is,
for any states s;s0we have
(s;;s0)2transjp)(bs;;bs0)2(transh)jp
wheretransjpand(transh)jpdenote the transitions of FTSjp
and(FTSh)jp, respectively. This property directly follows
from the denition of h:
 _
s;s0s  !s0(s;;s0)
)h(bs;;bs0)
,^
s;s0s  !s0(s;;s0))h(bs;;bs0)
)^
s;s0s  !s0p2[ [(s;;s0)] ])p2[ [h(bs;;bs0)] ]
,8s;s0(s;;s0)2transjp)(bs;;bs0)2(transh)jp
withs2h 1(bs)ands02h 1(bs0). Hence [ [FTS4FTS
FTSh] ] = [ [d] ]FM. 
We are now ready to present our CEGAR procedures for
FTS. Given that an FTS model checker may return sev-
eral counterexamples, two renement strategies can be fol-
lowed. The rst strategy, called Find All Before Rening
(FABR) consists in waiting for the model checker to nd all
the counterexamples it should return, then checking the spu-
riousity of each of them, and rening the model if need be.
Conversely, the second strategy, Rene When Found One
(RWFO) , checks spuriousity and possibly renes the model
as soon as the model checker nds one counterexample.
Build initialabstraction
Model Checker
Satisfying products
 Are spurious? 
Re/f_ine abstraction
FMViolating products                +CounterexamplesSpuriouscounterexamplesUpdate PropertyReal violatingproducts
[ 0] [ ] 
[ 0] Is quanti/f_ier satis/f_iable?Violating productsNoYes
Satisfying productsFigure 5: Overview of FABR
Figure 5 gives an overview of FABR. First, we apply an
initial F-abstraction ( h;h) to obtain an abstract FTS which
is given to the model checker along with the FM and an fLTL
formula []. The initial abstraction is built according to
a chosen abstraction technique (see Section 4). The model
checker returns (1) the set of products satisfying the formula,
and (2) the set of products violating the formula together
with counterexamples. We then check whether some of these
counterexamples are spurious. If that is the case, we rene
the abstraction to build a new F-abstraction ( h0;h0) such
that
[ [FTSh04FTSFTSh] ] = [ [d] ]FM (2a)
[ [FTS4FTSFTSh0] ] = [ [d] ]FM (2b)
[ [FTSh4FTSFTSh0] ][ [d] ]FM (2c)
and we verify FTSh0against the property. During this new
search, we can safely ignore the products that were pre-
viously recognized as satisfying. Indeed, by denition of
F-simulation any product that satises [ ] inFTShalso
satises the formula in FTSh0andFTS . We can also ignore
products that can execute a realcounterexample, since the
new check will report them as violating as well. To prevent
the model checker to consider these products, it suces to
transform the feature quantier into0=^:whereis
the feature expression characterizing the products to ignore.
We repeat the process until the model checker returns no
spurious counterexample, or equivalently while the updated
feature quantier 0is satisable. As a result, we pinpoint
the products that satisfy the formula and those that do not.
The RWFO strategy is illustrated in Figure 6. As before,
we build an initial abstraction and model-check it. If all the
products satisfy the formula, we stop. Otherwise, we stop
the verication as soon as the model checker nds a coun-
terexample. If this counterexample is spurious, we rene the
abstraction and start the model checking again. Otherwise,
we update the formula to ignore the products that can exe-
cute the counterexample. If the resulting feature quantier
0is satisable, we carry on the verication procedure from
when the counterexample was found . We repeat the process
until there is no more counterexample or the feature quanti-
er becomes unsatisable. In the latter case, it means thatBuild initialabstraction
Model Checker
Satisfying products...
FM Is spurious? 
Re/f_ine abstractionNoYes
CounterexampleUpdate PropertyIs quanti/f_ier satis/f_iable?
All products violateNoYes[ ] [ 0] [ 0] Figure 6: Overview of RWFO
all the products violate the formula.
The following theorem establishes the termination and the
correctness of our CEGAR strategies.
Theorem 9 Lethbe an existential abstraction function,
andh0be a renement procedure. For any FTS, if Equa-
tions 2 hold then the CEGAR strategies terminate, are sound
and are complete.
Proof .(Termination) At the end of a verication, the
CEGAR procedures either terminate, update the feature quan-
tierinto0, or trigger a renement. Given that [ [0] ]
[ [] ]the number of updates is nite. By Equations 2, the
number of renement is also nite.
(Correctness) Letpbe a valid product. After a verica-
tion, three cases may occur:
1.pis reported as satisfying the formula. By Denitions 6
and 7,psatises the formula in the concrete FTS as well.
2.pis associated to a real counterexample, and thus vio-
lates the formula in the concrete FTS as well.
3.pis associated to spurious counterexamples only. In
this case,pwill be checked again after the renement.
Furthermore, the denition of 0guarantees that only prod-
ucts that are known to satisfy or violate the formula are
ignored in upcoming verications. 
The strategies are agnostic to the actual abstraction and
renement functions being used, as long as these satisfy Def-
inition 7 and Equations 2. In the following section, we show
how to actually build dierent types of abstraction from a
concrete model.
4. BUILDING FTS ABSTRACTIONS
Existing abstraction techniques generally do not work di-
rectly on TS. Instead, they rely on higher-level representa-
tions that include an explicit notion of variable [11]. These
are commonly named program graphs [5]. In the context of
SPLs, the products will be represented by a set of programs
that share commonalities. In order to specify all these pro-
grams in a single compact model, one can borrow the con-
cept of feature expression introduced in FTS and apply it to
program graphs [14].
Denition 10 (recalled from [14]) Let V=fv1;:::;vngbe
a set of variables, :V!Types a type function, Pred (V)
the set of predicates over V,Asgn (V)the set of assignments
overV, andEval (v1:::;vn) =(v1)(vn)the set
of variable valuations. A Featured Program Graph (FPG)is a tuple (Loc;V;;Act;Loc 0;init;trans;d; )whereLoc is
a set of locations; Act=Pred (V)[Asgn (V)is the set of
actions;Loc 0is the initial location; InitEval (V)are the
set of possible initial valuations; transLocActLoc
is the transition relation; dis an FM over features F; and
:trans!B(F)associates each transition with a feature
expression.
One can dene the semantics of an FPG in terms of FTS
(see [14] for details). Intuitively, given an FPG the state
space of the underlying FTS is LocEval (V), that is, an
FTS state is dened as a location and a variable valuation.
The set of initial states is Loc 0Init. Transitions are de-
termined according to the variable values of source state, as
well as to the predicates and assignments that label the tran-
sitions of the current FPG location. Formally, the transition
relation is the smallest relation satisfying:
lp  !l0^vj=p
(l;v)p  !(l0;v)
lx:=expr     !l0^v0= [x:=expr]v
(l;v)x:=expr     ! (l0;v0)
where [x:=expr]visvafter assigning to xthe value given
byexpr, andpis a predicate over the variables. Given a
formula to check, the set APof atomic propositions is the
set of predicates over Vthat occur in the formula. Feature
expressions are directly obtained from . In what follows,
we interchangeably use to denote the transition labelling
function of both an FPG and its underlying FTS. We now
present two families of methods to build and rene abstrac-
tions of FPG, and discuss their implications on the CEGAR
strategies presented above.
4.1 Feature Abstraction
The rst abstraction type we propose consists in abstract-
ing from the variability between the products. Concretely,
we replace each feature expression (t) labelling a transi-
tiontby another feature expression h(t) such that [ [ (t)] ]
[ [h(t)] ]. The set of states and transitions are, however, left
untouched. The existential abstraction is thus dened as
h:S!S:h(s) =s. This transformation does not remove
behaviours from the products, by Denition 7 and Theo-
rem 8.
For the initial abstraction, we propose to completely ab-
stract all the feature expressions of the FPG, that is, each of
them is replaced by >. This comes down to associating to
every product of the underlying FTS ( S;Act;trans;I;AP;
L; d;  ) the semantics of the TS ( S; Act; trans; I; AP; L ).
An undeniable advantage of this abstraction is that single-
system model checking algorithms can perform the verica-
tion. If the initial abstraction satises a given formula then
all the products satisfy it. Otherwise, the model checker re-
turns a counterexample. Given that the F-abstraction did
not modify the state space, the counterexample is necessar-
ily an existing execution in the aforementioned TS. It may
happen that no product can execute it (e.g., due to incom-
patible feature expressions), though; indeed, the TS seman-
tics subsumes the union of the semantics of the projection
of the FTS onto all valid products [18]. For instance, an ex-
ecution that triggers transitions tandt0, with(t),:(t0)
would be executed in the abstract FTS but not in the con-
crete FTS. Even if at least one product can execute thecounterexample, it does not mean that all the products can.
More generally, if bh(resp.b) is the feature expression char-
acterizing the set of products that can execute the coun-
terexample in FTSh(resp.FTS ), then the counterexample
is spurious for products in ([ [ b] ]n[ [bh] ])\.
If the counterexample is spurious for at least one prod-
uct, the abstraction must be rened. Here, the renement
consists in replacing the abstract feature expression of each
FPG transition that is executed during the counterexample
by its concrete feature expression. This implies that for each
FTS transition t, the feature expression labelling t, noted
h0(t), is such that [ [ h0(t)] ][ [h(t)] ]. Hence, the result-
ing abstraction function h0guarantees that [ [ FTSh04FTS
FTSh] ] = [ [d] ]FMand [ [FTS4FTSFTSh0] ] = [ [d] ]FMwhere
his the initial F-abstraction. Since we updated the fea-
ture expression of at least one transition, it follows that
[ [FTSh4FTSFTSh0] ][ [d] ]FM. Equations 2 are thus satis-
ed, which guarantees the termination and the correctness
of the aforementioned CEGAR procedures.
4.2 State Abstraction
Unlike the rst one, the second abstraction type relies on
transposing the principles of classical abstraction functions
to SPL CEGAR. More precisely, we consider predicate ab-
straction , one of the most applied methods for program ab-
straction [27, 11, 13]. Let Pred =fp1;:::;pngPred (V)
be the set of predicates that occur in the FDG or in the
formula to check. Let h: (LocEval (V))!(Loc2Pred)
be an existential abstraction function such that h(l;v) =
(l;fpi2Predvj=pig). Intuitively, FDG locations are
preserved in abstract states but a variable valuation is ab-
stracted by the exact subset of predicates it satises. Since
the predicates of the formula to check are included in Pred
and thus contribute to the denition of h, we haveh(s) =
h(s0))L(s) =L(s0) andL(h(s)) =L(s). The abstract
transition relation transhis dened as the smallest relation
satisfying:
lp  !l0^p2P
(l;P)p  !(l0;P)
lx:=expr     !l0^([P]^wp(x:=expr; [P0])6j=?)
(l;P)x:=expr     ! (l0;P0)
where [P] =V
p2Pp^V
q2PrednP:qandwp(x:=expr; )
iswith each occurrence of xreplaced by expr. Intuitively,
P0is the set of predicates that are satisable after assigning
expr toxgiven that every predicate in Pwas satisable
before the assignment and that every predicate not in P
was not satisable. In this abstraction, we do not change the
feature expressions, that is, h(t) =(t) for any transition
t. Therefore we have [ [ FTS4FTSFTSh] ] = [ [d] ]FM.
Technically, the denition of state abstraction is very sim-
ilar to state-of-the-art predicate abstractions. The dierence
rather lies in the detection and the analysis of counterexam-
ples, which now depends on variability. Indeed, the notion
of spuriousness is more subtle in this case. First, a spurious
counterexample may not correspond to an existing sequence
of transitions in the concrete FTS. Second, it can be an ex-
isting execution but only for a subset of the products. We
thus propose a method to detect spurious counterexamples
that can be represented as nite sequences. This method is
inspired by the SplitPATH algorithm used in single-system
CEGAR [11]. It consists in identifying a set of states whosemerging has yielded a spurious counterexample, and then
splitting this set so as to make the counterexample disap-
pear. We can also extend our technique with support for any
kind of counterexample using unwinding techniques along
the lines of Clarke et al. [11]. The key idea of our method is
to remember, while replaying the counterexample, for which
products we can execute each step of the replay. Formally,
let=h(s0)0:::h(sm) be a counterexample and bthe
feature expression characterizing the products able to exe-
cute it. Let S0=f(i;)ji2Igand
Si=f(s;b)2h 1(h(si))B(F)j
(s0;b0)2Si 1^ 
b= (b0^_
s0i 1   !s(s0;i 1;s))
g:
Intuitively, if ( s;b)2Sithenscan be reached by products in
[ [b] ] by replaying the rst isteps of the counterexample. If for
a productpthere does not exist ( s;b)2Siwithp2[ [b] ] then
pcannot execute the counterexample. Thus is spurious
for productsfp2[ [b] ]j@(s;b)2Smp2[ [b] ]g, or equiva-
lently [ [b^:(W
(s;b)2Smb)] ]. We also name these products
spurious. The correctness of this detection procedure is de-
rived from the proof of SplitPATH [11] and the denition of
projection [16].
To rene the abstraction, we rst have to identify the exe-
cution steps during which products are discovered not to be
able to execute the counterexample. Let b0(i) present the
products that can execute the counterexample in the con-
crete FTS up to step i, withb0(0) =. Then for any i>0
the feature expression b^:b0(i) characterizes the products
that are spurious at step i, andb^b0(i)^:b0(i+ 1) rep-
resents the products that became spurious exactly at step
i. If the latter feature expression is satisable, a renement
should be performed at step i.
In predicate abstraction, a renement consists in adding
a new predicate in the construction of the abstraction func-
tion. An abstract state will therefore contain more infor-
mation and the abstraction function will be able to produce
ner abstractions. The predicate to add can be determined
by means of Craig interpolation [24]. Given two formulae
and with^ j=?, a Craig interpolant is a formula
0written using the intersection of the vocabularies of ; 
such that)0and0^ j=?. Loosely speaking, 0can
be seen as an explanation of why ^ is not satisable.
The occurrence of a spurious product means that the ab-
straction has created a transition between a state si2Si
and a state si+12Si+1that does not actually exist. To
eliminate this spurious counterexample, the new abstrac-
tion has to make the distinction between siand the states
inSithat actually have a transition to si+1. We thus com-
pute a Craig interpolant betweenV
v2Vv=eval(si;v) andW
(sjsj  !si+1)V
v2Vv=eval(sj;v). This yields the new
predicate to add as a renement to the abstraction. Once
the rened abstraction is obtained, we perform a new veri-
cation limited to the spurious products.
Leth0be the rened abstraction yielded by that method.
Thenh0(s) =h0(s0))h(s) =h(s0) and the abstract transi-
tion relation in FTSh0is ner than in FTSh. Furthermore,
the renement method removes from at least one product
the ability to execute the ith step of the spurious counterex-
ample. Hence Equations 2 hold.
4.3 Mixed AbstractionGiven that the above two abstraction methods do not
modify the same constructs, we can combine them to form
coarser abstractions. Thereby, we obtain an initial existen-
tial abstraction function has dened in Subsection 4.2 to-
gether with an abstract labelling function has presented in
Subsection 4.1. Although the construction of the abstraction
is straightforward, the detection of spurious counterexam-
ples and the renement process become more complex. In-
deed, spurious products may originate from dierent factors,
viz.the abstraction of feature expressions, the predicate ab-
straction, or their combination. This raises the questions of
how to associate spuriousness cases with their appropriate
origin(s), and how to guide the renement process in case of
multiple origins.
As before, we will compute sets of states Sithat give the
states that can be reached upon the execution of the rst i
steps of the counterexample, together with the products able
to reach them. The actual denition of Siis as previously.
However, since we have to take into account that feature
expressions are abstracted as well, the detection algorithm
should determine the reason why a product became spurious
and rene either the labelling function or the state space
abstraction.
Procedure IsSpurious formalizes our detection and rene-
ment method. It consists in replaying the counterexample
step by step, and check during each step whether we dis-
cover spurious products (Lines 5{19). At each iteration, b
represents the products that violate the property in ftsh
and have not been discovered to be spurious, whereas b0
represents the products that can execute the counterexam-
ple inftsup to the current step. For a given step i, we rst
check whether there are new spurious products due to the
abstraction of feature expression (Lines 6{12). To achieve
that, we compute the feature expression that would label the
abstract transition should the feature abstraction not have
been applied, add it to b0and compare the result with b.
The condition at line 8 means that any product in [ [ b] ]n[ [b0] ]
is a spurious product. If there is at least one such product,
a renement of the feature abstraction function is needed.
Accordingly, we modify the feature expression labelling the
abstract transition. Next, we check whether predicate ab-
straction yielded additional spurious products at step iby
using the method presented in Subsection 4.2 (Lines 13{18).
If it did (Lines 15{18), we compute and register the inter-
polant that will act as a renement of the current predicate
abstraction. The algorithm ends up returning either true if
no renement was needed, or a new F-abstraction together
with the set of really violating products (Lines 21{22). This
F-abstraction is built according to the renement procedures
of the previous two abstractions.
5. IMPLEMENTATION AND EV ALUATION
In order to compare and evaluate the potential benets of
our CEGAR procedures and our F-abstractions, we imple-
mented them on top of our previous model checking algo-
rithms [18, 16]. In this section, we describe our implemen-
tation, present the results of experiments we carried out,
and attempt to infer general cases where it is particularly
rewarding to apply CEGAR instead of standard FTS algo-
rithms.
ProVeLines [23] is a product line of model checkers for
SPLs, which constitutes the realization of a four-year re-Input :ftsandftshsuch that
[ [fts4FTSftsh] ] = [ [d] ]FM, a quantier ,
=bs00:::csmandb2B(F) such that
2Prefix ([ [(ftsh)jp] ]TS) for allp2[ [b] ].
Output :True if2Prefix ([ [(ftsh)jp] ]TS) for all
p2[ [^b] ], (h0;b0) such that Equations 2
hold and2Prefix ([ [(ftsh)jp] ]TS) for all
p2[ [^b] ] otherwise.
1b0 ^d;
2refined ?;
3Pred0 Pred ;
4h0 h;
5fori= 1tomdo
6h0(dsi 1;i 1;bsi) W
si 12h 1(dsi 1);si2h 1(bsi)(si 1;i 1;si);
7b0 b0^h0(dsi 1;i 1;bsi);
8 ifb6)b0then
9h(dsi 1;i 1;bsi) h0(dsi 1;i 1;bsi);
10b b^b0;
11refined >;
12 end
13b0 b0^W
(s;b)2Sib;
14 ifb6)b0then
15Pred0 Pred0[fCraig (dsi 1^i 1;bsi)g;
16b b^b0;
17refined >;
18 end
19end
20ifrefined then
21 (h0;h0) abstract (fts;h;Pred0;h0);
22 return (h0;h0);
23else
24 return>;
25end
Procedure IsSpurious( fts;ftsh;;;b)
search eort. It allows one to verify the behaviour of an
SPL modelled as (an extension of) FTS against properties
expressed in dierent logics. The variants of ProVeLines
are semi-symbolic model checkers: they encode the SPL
products symbolically as feature expressions, but explore the
state space explicitly. Among the input languages accepted
by ProVeLines one nds fPromela [14], a feature-aware ex-
tension of Promela [29]. fPromela provides constructs to
declare variables and statements, as well as to label the lat-
ter with feature expressions. It can thus be regarded as a
concrete syntax for featured program graphs, and is conse-
quently appropriate as an input to our CEGAR procedures.
On the basis of our implementation, we carried out ex-
periments to evaluate in which cases and to what extent our
CEGAR-based verication methods are more ecient than
a plain application of the FTS algorithms presented in our
previous work [18, 16]. The benets of CEGAR originate
from two factors. First, the existential abstraction reduces
the size of the state-space, and thus the number of states
to explore before discovering a counterexample. Second, the
abstraction of feature expressions increases the commonal-
ity between the behaviour of the products and thereby aug-
ments the potency of SPL-specic optimizations such as late
splitting (see Section 2). However, the approximation due
to abstraction and the consequent needs for renement maycancel these benets, or even worsen the verication time.
Indeed, after applying a renement, a completely new ver-
ication must be performed on the rened model. After
several renements, the number of states explored by all
the verications altogether can exceed that of the standard
algorithms. The performance of the CEGAR procedures
thus depends on several factors including the topology of
the model, the chosen F-abstractions, and the property.
As an attempt to estimate the impact of these factors, we
computed the time needed by both CEGAR strategies com-
bined with dierent F-abstractions and implemented on top
of the FTS algorithms to verify three systems against a set of
properties. We systematically compare the results with the
time needed by the FTS algorithms without CEGAR to ver-
ify the same systems against the same properties. The rst
system is a minepump system SPL which has to draw water
from a mine while there is no methane within it (see [31, 18,
16] for more information). This SPL consists of 11 features
and 128 valid products. To explore the FTS modelling its be-
haviour, visiting 250,561 states is required. The second SPL
is an elevator model inspired from Plath and Ryan [35, 17].
It is composed of eight features, which can be combined into
256 dierent products, and its FTS has 58,945,690 states to
explore. The third and last SPL is a case study inspired by
the CCSDS File Delivery Protocol (CFDP) [20], which has
been reengineered as a product line [8]. The FTS modelling
the protocol consists of 1,801,581 states to explore and 56
products.
We focus rst on the minepump SPL. We checked the
corresponding FTS against 20 properties, including deadlock
freedom, safety and liveness properties. Due to lack of space,
we do not display detailed results for the other properties
and case studies. However, all the results together with
our case studies and implementation are available on our
website1. All benchmarks were run on a MacBook Pro with
a 2,8 GHz Intel Core i7 processor and 8 GB of DDR3 RAM
running Mac OS 10.7. We coded an automated script to
execute them. To avoid random variations, we repeated each
experiment ve times and computed the average. We discuss
the results in terms of speedup ,i.e. the verication time
using a given abstraction divided by the verication time of
the standard FTS algorithm. The verication time includes
the time to parse the fPromela model, to build the initial
FTS, and to run the verication procedure.
The results are presented in Figure 7, which shows the
speedup of each CEGAR strategy and abstraction with re-
spect to the standard algorithm. When feature abstrac-
tion is applied together with the FABR strategy, the model
checker performs signicantly better than the standard FTS
algorithm (i.e. with a speedup comprised between 1.38 and
11.07) in ve cases out of 20; it has almost no eect (speedup
between 0.9 and 1.1) in eight cases; and it performs slightly
worse (speedup between 0.77 and 0.86) in the last seven
cases. The results are very similar when the RWFO strat-
egy is followed instead. In both cases, after an in-depth
analysis of the returned counterexamples we noticed that
the cases where the abstraction does not improve the per-
formance occur when every feature has to be known for
the counterexamples to be triggered. This means that af-
ter several renements the model checker ends up verifying
the original concrete FTS. The small loss of performance is
1http://info.fundp.ac.be/ftsdue to the verications performed before the last renement.
An impressive speedup of more than nine is achieved when
the property is satised by all products (three cases); when
only a few features are needed to nd the counterexamples
(three cases), the abstraction still brings nice performance
gains (speedup between 1.38 and 1.91). A change of strat-
egy brings but small variations in the result; this factor thus
does not seem to impact the overall eciency of feature ab-
straction.
The topology of the system, however, substantially aects
the eciency of this form of abstraction. In the elevator sys-
tem, each feature leads to behavioural variations that occur
at the beginning of the execution of the system; yet all the
products have a lot of common behaviour. This implies that
late splitting occurs early in the verication and that the
algorithm has to explore more than once a large part of
the state space. By abstracting feature expressions, we can
drastically reduce these re-explorations. Concretely, the ab-
straction performed signicantly better when verifying six
properties out of 19, achieving impressive speedups (82.12
and 93.38) in the two cases where the property is satised
by all products. In these cases, the verication time was
reduced from 293.17 and 984.32 to 3.57 and 10.54 seconds,
respectively. As for the remaining 13 properties, almost no
variation with respect to the standard algorithm were re-
ported. On the contrary, the CFDP case study gives a lot of
trouble to feature abstraction. The FTS modelling the pro-
tocol is uncommon, as a very large part of the state space is
available to only one product. Abstracting feature expres-
sion results in the addition of such a large behaviour to all
the other products, which will be explored for each of them.
For one property out of six, this inconvenience did not aect
the results. However, it led to a signicant decrease in e-
ciency in the ve other cases, with a speedup between 0.14
and 0.46.
State abstraction appears more invasive than feature ab-
straction. When combined with the FABR strategy, it had
no signicant eect on the performance for only four prop-
erties of the minepump SPL; it improved it nine times, and
worsened it seven times. In the latter cases, the loss in
eciency is substantial (speedup between 0.12 and 0.79),
whereas the improvements yield speedups between 1.17 and
2.50. Our observations tend to indicate that RWFO is more
appropriate for state abstraction. Indeed, the performance
of the abstraction is always increased when combined with
this strategy. With respect to the standard algorithm, the
verication is improved for 15 properties (speedup between
1.35 and 2.57), worsened for four properties (speedup be-
tween 0.27 and 0.68), and almost unchanged for one prop-
erty. These conclusions are conrmed by the elevator and
CFDP case studies, from which we gathered similar results.
It is noteworthy that the above two abstractions have both
a negative impact on verication time for only one prop-
erty. Moreover, it happened several times that one form
of abstraction was very inecient but not the other. This
implies that (1) there almost always exists a good choice
regarding the abstraction to apply and (2) their combined
eects cannot be inferred from their individual performance
results. Therefore we carried out additional experiments
on mixed abstraction. It turned out that the results follow
the same trend as in the case of state abstraction, although
mixed abstraction is slightly less ecient on average. State
abstraction thus seems to cancel the eect of feature ab-img/cegar-minepump-speedup.pdf
Figure 7: Speedups for the minepump case study.straction, be it negative or positive. This corroborates our
previous observation that state abstraction has more impact
on performance. An in-depth look at the execution times
revealed that the computation of successor states in state
abstraction is far more costly than the re-exploration of al-
ready computed states. Since feature abstraction improves
the latter but not the former, its eects are not apparent
in mixed abstraction. The other two case studies tend to
conrm these conclusions. In particular, the negative eects
of feature abstraction on the CFDP model are oset by the
benets of state abstraction, although mixed abstraction re-
mains seemingly less ecient than state abstraction alone in
this case.
Conclusions . All these experiments allow us to draw
conclusions regarding which abstraction to use. State ab-
straction brings substantial benets in most cases and should
be the preferred form of abstraction. Still, feature abstrac-
tion can achieve dramatic reductions in verication time in
particular situations, notably when the property to check is
(expected to be) satised by all products (see, e.g., property
#8). The performance of our mixed abstraction is of the
same order as state abstraction, but is less ecient on aver-
age. Yet, mixed abstractions oer the highest level of cus-
tomization; it could thus be possible to dene other mixed
abstractions that are more ecient than the one we used.
We leave that for future work.
6. RELATED WORK
This work is at the intersection of CEGAR and product-
line model checking. Clarke et al. [11] were the rst to
introduce CEGAR. They presented the principles we reca-
pitulated in Section 2, designed the SplitPATH algorithm
used to detect spurious counterexamples, and proposed a
renement algorithm. Several model checkers make use of
predicate abstraction to speed up the verication. At the
last TACAS software verication competition [6], UFO [1],
LLBMC [25], CPAChecker [7], and ESBMC [34] were nomi-
nated the fastest model checkers for product lines. Unlike us,
these tools do not treat features as rst-class citizens. This
means that either they rely on an enumerative approach or
their analysis procedure consists in verifying a model that
includes the behaviour of all products (i.e. based on a prod-
uct simulator [2] or on conguration lifting [37]). In the
rst case, abstraction can be applied to the models of the
individual products but the commonality between these is
not exploited. The second case oers interesting perspec-
tives regarding an ecient application of abstraction on all
products. However, this approach can determine whether
or not allproducts satisfy the property, while we want to
identify which products are error-prone. Outside the scope
of model checking, Liebig et al. [32] designed a type check-
ing and data-ow analysis procedure that abstracts from the
validity of products. This is also a form of feature abstrac-
tion, although ours goes further by completely abstracting
features.
Regarding SPL model checking, there exist other methods
that are not based on FTS. Fischbein et al. [26] proposed
to use Modal Transition Systems (MTS) to model the be-
haviour of SPLs. MTS are TS where transitions are either
mandatory ( i.e. executable by all valid products) or op-
tional ( i.e.executable by only a subset of valid products).
A fundamental dierence between MTS and FTS is that
the former cannot link a given execution to the exact set ofproducts able to produce this execution. It is thereby im-
possible to identify the exact set of products that violate a
given property. To overcome this limitation, Asirelli et al. [4]
equipped MTS with a modal logic which permits to restrain
the execution of actions to specic combination of features.
Grumberg et al. studied an abstraction-renement model
checking procedure for modal -calculus, whose principles
could be reused to design CEGAR methods for standard
MTS. However, such a method would not benet from the
modal logic of Asirelli et al. and would thus be inappropriate
to address the SPL model checking problem.
Apel et al. [2] developed SPLVerier, a tool chain for
product-line model checking. Features are specied in sep-
arate modules written in C or Java. Like [1, 25, 7, 34],
the advantage of their approach over FTS is that they can
verify actual code. However, the properties they can check
do not extend to logics as expressive as LTL. In [3], they
showed that approaches relying on symbolic interpretation
of features are more ecient than sample-based approaches,
thereby corroborating our previous results [14, 16].
Gruler et al. [28] showed that multi-valued model checking
can address the SPL model checking problem. Multi-valued
TS generalise TS in that the transition relation is not bi-
nary and the atomic propositions are not Boolean [10, 9].
FTS can be regarded as a particular type of multi-valued
TS. There currently exists no algorithm to eciently verify
LTL formulae on multi-valued models (see [16] for a thor-
ough comparison). Given the close relation between FTS
and multi-valued models, the principles presented in this pa-
per can be applied to design CEGAR procedures for multi-
valued model checking.
7. CONCLUSION
We presented SPL-specic abstraction methods that tackle
the state explosion problem in SPL model checking. Our
evaluation tends to show substantial performance gains in
a majority of cases, from which we derived general rules as
to when our heuristics should be applied. In the future, we
plan to design an automated method to build appropriate
mixed abstractions given the topology of the model to check
and a history of previous verications. We will also combine
this work with our fully symbolic SPL model checking algo-
rithms and implement the resulting approach on top of our
NuSMV extension [17]. This will allow us to assess whether
or not our conclusions are still valid in that case.8. REFERENCES
[1] A. Albarghouthi, Y. Li, A. Gurnkel, and M. Chechik.
Ufo: A framework for abstraction- and
interpolation-based software verication. In CAV ,
pages 672{678, 2012.
[2] S. Apel, H. Speidel, P. Wendler, A. von Rhein, and
D. Beyer. Feature-interaction detection using
feature-aware verication. In ASE'11 , pages 372{375.
IEEE, 2011.
[3] S. Apel, A. von Rhein, P. Wendler, A. Gr olinger, and
D. Beyer. Strategies for product-line verication: case
studies and experiments. In ICSE'13 , pages 482{491,
2013.
[4] P. Asirelli, M. H. ter Beek, A. Fantechi, and S. Gnesi.
Formal description of variability in product families.
InSPLC'11 , pages 130{139. Springer-Verlag, 2011.
[5] C. Baier and J.-P. Katoen. Principles of Model
Checking . MIT Press, 2007.
[6] D. Beyer. Second competition on software verication
- (summary of sv-comp 2013). In TACAS '13 , pages
594{609, 2013.
[7] D. Beyer and M. E. Keremoglu. Cpachecker: A tool
for congurable software verication. In CAV '11 ,
pages 184{190, 2011.
[8] Q. Boucher, A. Classen, P. Heymans, A. Bourdoux,
and L. Demonceau. Tag and prune: A pragmatic
approach to software product line implementation. In
ASE'10 , pages 333{336. ACM, 2010.
[9] G. Bruns and P. Godefroid. Model checking with
multi-valued logics. In ICALP '04 , pages 281{293,
2004.
[10] M. Chechik, B. Devereux, and A. Gurnkel.
Model-checking innite state-space systems with
ne-grained abstractions using spin. In SPIN '01 ,
pages 16{36, 2001.
[11] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith.
Counterexample-guided abstraction renement. In
E. Emerson and A. Sistla, editors, Computer Aided
Verication , volume 1855 of LNCS , pages 154{169.
Springer Berlin / Heidelberg, 2000.
[12] E. Clarke, O. Grumberg, and D. Peled. Model
Checking . MIT Press, 1999.
[13] E. Clarke, D. Kroening, N. Sharygina, and K. Yorav.
Predicate abstraction of ansi-c programs using sat.
Form. Methods Syst. Des. , 25(2-3):105{127, Sept.
2004.
[14] A. Classen, M. Cordy, P. Heymans, A. Legay, and
P.-Y. Schobbens. Model checking software product
lines with SNIP. STTT , 14(5):589{612, 2012.
[15] A. Classen, M. Cordy, P. Heymans, P.-Y. Schobbens,
and A. Legay. Snip: An ecient model checker for
software product lines. Technical report, University of
Namur (FUNDP), 2011.
[16] A. Classen, M. Cordy, P.-Y. Schobbens, P. Heymans,
A. Legay, and J.-F. cois Raskin. Featured transition
systems: Foundations for verifying variability-intensive
systems and their application to LTL model checking.
Transactions on Software Engineering , pages
1069{1089, 2013.
[17] A. Classen, P. Heymans, P.-Y. Schobbens, and
A. Legay. Symbolic model checking of software
product lines. In ICSE'11 , pages 321{330. ACM, 2011.[18] A. Classen, P. Heymans, P.-Y. Schobbens, A. Legay,
and J.-F. Raskin. Model checking lots of systems:
ecient verication of temporal properties in software
product lines. In ICSE'10 , pages 335{344. ACM, 2010.
[19] P. C. Clements and L. Northrop. Software Product
Lines: Practices and Patterns . SEI Series in Software
Engineering. Addison-Wesley, August 2001.
[20] Consultative Committee for Space Data Systems
(CCSDS). CCSDS File Delivery Protocol (CFDP):
Blue Book, Issue 4 . NASA, 2007.
[21] M. Cordy, A. Classen, P. Heymans, P.-Y. Schobbens,
and A. Legay. Managing evolution in software product
lines : A model-checking perspective. In VaMoS'12 ,
pages 183{191. ACM, 2012.
[22] M. Cordy, A. Classen, G. Perrouin, P. Heymans, P.-Y.
Schobbens, and A. Legay. Simulation-based
abstractions for software product-line model checking.
InICSE'12 , pages 672{682. IEEE, 2012.
[23] M. Cordy, P.-Y. Schobbens, P. Heymans, and
A. Legay. Provelines: A product-line of veriers for
software product lines. In SPLC'13 , pages 141{146.
ACM, 2013.
[24] W. Craig. Three Uses of the Herbrand-Gentzen
Theorem in Relating Model Theory and Proof Theory.
The Journal of Symbolic Logic , 22(3):269{285, 1957.
[25] S. Falke, F. Merz, and C. Sinz. The bounded model
checker llbmc. In ASE '13 , pages 706{709, 2013.
[26] D. Fischbein, S. Uchitel, and V. Braberman. A
foundation for behavioural conformance in software
product line architectures. In ROSATEA'06, ISSTA
2006 workshop , pages 39{48. ACM Press, 2006.
[27] S. Graf and H. Sa di. Construction of abstract state
graphs with pvs. In Proceedings of the 9th
International Conference on Computer Aided
Verication , CAV '97, pages 72{83, London, UK, UK,
1997. Springer-Verlag.
[28] A. Gruler, M. Leucker, and K. Scheidemann. Modeling
and model checking software product lines. In
FMOODS'08 , pages 113{131. Springer, 2008.
[29] G. J. Holzmann. The SPIN Model Checker: Primer
and Reference Manual . Addison-Wesley, 2004.
[30] K. Kang, S. Cohen, J. Hess, W. Novak, and
S. Peterson. Feature-oriented domain analysis (FODA)
feasibility study. Technical Report
CMU/SEI-90-TR-21, 1990.
[31] J. Kramer, J. Magee, M. Sloman, and A. Lister.
Conic: an integrated approach to distributed
computer control systems. Computers and Digital
Techniques, IEE Proceedings E , 130(1):1{10, 1983.
[32] J. Liebig, A. von Rhein, C. K astner, S. Apel, J. D orre,
and C. Lengauer. Scalable analysis of variable
software. In ESEC/SIGSOFT FSE '11 , pages 81{91,
2013.
[33] R. Milner. An algebraic denition of simulation
between programs. Technical report, Stanford
University, Stanford, CA, USA, 1971.
[34] J. Morse, L. Cordeiro, D. Nicole, and B. Fischer.
Handling unbounded loops with esbmc 1.20 -
(competition contribution). In TACAS , pages 619{622,
2013.
[35] M. Plath and M. Ryan. Feature integration using afeature construct. SCP, 41(1):53{84, 2001.
[36] A. Pnueli. The temporal logic of programs. In
FOCS'77 , pages 46{57, 1977.
[37] H. Post and C. Sinz. Conguration lifting: Verication
meets software conguration. In ASE'08 , pages
347{350. IEEE CS, 2008.
[38] P.-Y. Schobbens, P. Heymans, J.-C. Trigaux, and
Y. Bontemps. Feature Diagrams: A Survey and A
Formal Semantics. In RE'06 , pages 139{148, 2006.