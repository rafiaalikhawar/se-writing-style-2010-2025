Round-Up: Runtime Checking Quasi Linearizabilityof Concurrent Data StructuresLu Zhang, Arijit Chattopadhyay, and Chao WangDepartment of ECE, Virginia TechBlacksburg, V A 24061, USA{zhanglu, arijitvt, chaowang}@vt.eduAbstract—We propose a new method for runtime checkingof a relaxed consistency property calledquasi linearizabilityforconcurrent data structures. Quasi linearizability generalizes thestandard notion oflinearizabilityby intentionally introducingnondeterminism into the parallel computations and exploitingsuch nondeterminism to improve the performance. However,ensuring the quantitative aspects of this correctness conditionin the low level code is a difﬁcult task. Our method is theﬁrst fully automated method for checking quasi linearizabilityin the unmodiﬁed C/C++ code of concurrent data structures. Itguarantees that all the reported quasi linearizability violationsare real violations. We have implemented our method in asoftware tool based on LLVM and a concurrency testing toolcalled Inspect. Our experimental evaluation shows that thenewmethod is effective in detecting quasi linearizability violations inthe source code of concurrent data structures.I. INTRODUCTIONConcurrent data structures are the foundation of many multi-core and high performance software systems. By providing acost effective way to reduce the memory contention and in-crease the scalability, they have found increasingly widespreadapplications ranging from embedded computing to distributedsystems such as the cloud. However, implementing concurrentdata structures is not an easy task due to the subtle interactionsof low level concurrent operations and often astronomicallymany thread interleavings. In practice, even a few hundredlines of highly concurrent low level C/C++ code can posesevere challenges for testing and debugging.Linearizability [1], [2] is thede factocorrectness conditionfor implementing concurrent data structures. It requires thatevery interleaved execution of the methods of a concurrentobject to be equivalent, in some sense, to a sequential ex-ecution. This is extremely useful as a correctness conditionfor application developers because, as long as their programis correct when using the standard (sequential) data structure,switching to a concurrent version of the same data structurewould not change the program behavior. Although being lin-earizable alone does not guarantee correctness of the program,not satisfying the linearizability requirement often indicatesthat the implementation is buggy.In this paper, we propose the ﬁrst fully automated methodfor checkingstandardandquasilinearizability violations ofconcurrent data structures. Quasi linearizability [3] is aquanti-tative relaxation of linearizability, which has attractedal o to fattention in recent years [4], [5], [6], [7], [8]. For many highlyparallel applications, the standard notion of linearizability im-poses unnecessary restrictions on the implementation, therebyleading to severe performance bottlenecks. Quasi linearizabil-ity preserves the intuition of standard linearizability whileproviding some additional ﬂexibility in the implementation.For example, the task queue used in the scheduler of a threadpool does not need to follow the strict FIFO order. One canuse a relaxed queue that allows some tasks to be overtakenoccasionally if such relaxation leads to superior performance.Similarly, concurrent data structures used for web cache neednot follow the strict semantics of the standard versions, sinceoccasionally getting the stale data is acceptable. In distributedsystems, the unique id generator does not need to be a perfectcounter; to avoid becoming a performance bottleneck, it isoften acceptable for the ids to be out of order occasionally,as long as it happens within a bounded time frame. Quasilinearizability allows the concurrent data structures to havesuch occasional deviations from the standard semantics inexchange of higher performance.While quasi linearizable concurrent data structures havetremendous performance advantages, ensuring the quantitativeaspects of this correctness condition in the actual implemen-tation is not an easy task. To the best of our knowledge, theredoes not yet exist any method for checking, for example,thedeqoperation of a relaxed queue is not over-taken byotherdeqoperations for more thanktimes. Existing methodsfor detecting concurrency bugs focus primarily on simplebug patterns such as deadlocks, data-races, and atomicityviolations, but not this type of quantitative properties.Broadly speaking, existing methods for checking lineariz-ability fall into three groups. The ﬁrst group consists ofmethods based on constructing mechanical proofs [9], [10],which require signiﬁcant user intervention. The second groupconsists of automated methods based on model checking [11],[12], [13], which work on ﬁnite state models or abstractionsof the concurrent data structure. The third group consists ofruntime tools that can directly check the source code, but onlyfor standard linearizability.Our method is the ﬁrst runtime method for checking quasilinearizability in the source code of concurrent data structures.It does not require the user to provide speciﬁcations orannotate linearization points. It takes the source code of aconcurrent objecto,at e s tp r o g r a mPthat useso,a n daq u a s ifactorKas input, and returns eithertrueorfalseas output.It guarantees to report only real linearizability violations.We have implemented the method in a software tool calledRound-Upbased on the LLVM compiler and Inspect [14]. Itcan check C/C++ programs that use the POSIX threads and7KUHDG 7KUHDG 7KUHDGRHQT7LPHOLQHRHQTRHQTRGHTRGHTRGHTRHQTRGHT
Fig. 1. A 3-threaded program that uses objecto.T h r e a d1s t a r t sb ya d d i n gvalues 1 and 2 to the queue before creating two child threads.Then it waitsfor the child threads to terminate before removing another three data items.Hereenq(3)runs concurrently withenq(4)anddeq()in Thread 3.GNU built-in atomic functions. Our experiments on a largeset of concurrent data structure implementations show thatthenew method is effective in detecting both quasi linearizabilityviolations. We have found several real implementation bugsin theScalsuite [15], which is an open-source package thatimplements some of the most recently published concurrentdata structures. The bugs that we found in theScalbenchmarkshave been conﬁrmed by theScaldevelopers.The remainder of this paper is organized as follows. Weprovide a few motivating examples in Section II and explainthe main technical challenges in checking quasi linearizability.We establish notation in Section III and then present the overallalgorithm in Section IV. We present the detailed algorithm forchecking quasi linearizability in Section V. Our experimentalresults are presented in Sections VI. We review related workinSection VII, and ﬁnally give our conclusions in Section VIII.II. MOTIVATINGEXAMPLESIn this section, we illustrate the standard and quasi lin-earizability properties and outline the technical challengesin checking such properties. Fig. 1 shows a multithreadedprogram that invokes theenq/deqmethods of a queue. IfThread 2 executesenq(3)atomically, i.e., without interferencefrom Thread 3, there will be three interleaved executions, all ofwhich behave like a single-threaded execution. The sequentialhistories, shown in Fig. 2, satisfy the standard semantics oft h equeue. Therefore, we call them thelegal sequential histories.If the time interval ofenq(3),w h i c hs t a r t sa ti t si n v o c a t i o nand ends at its response, overlaps with the time intervalsofenq(4)anddeq(),t h ee x e c u t i o ni sn ol o n g e rs e q u e n t i a l .In this case, the interleaved execution is called aconcurrenthistory.W h e nt h ei m p l e m e n t a t i o no ft h eq u e u ei sl i n e a r i z a b l e ,no matter how the instructions ofenq(3)interleave with theinstructions ofenq(4)anddeq(),t h ee x t e r n a lb e h a v i o ro fthe queue would remain the same. We say that the queue islinearizableif the sequence ofdeqvalues of anyconcurrenthistorymatches one of the three legal sequential histories inFig. 2. On the other hand, if the sequence ofdeqvaluesis 3,2,1,4 in a concurrent history, we say that it has a+LVWRU\ +LVWRU\ +LVWRU\7LPHOLQHRHQTRHQTRHQT
RGHT RGHT RGHT RHQTRGHT RHQTRHQTRHQT
RGHT RGHT RGHT RHQTRGHT  RHQTRHQTRHQT
RGHT RGHT RGHT RHQTRGHT 
Fig. 2. The set oflegal sequential historiesgenerated by the program inFig. 1. These legal sequential histories form thesequential speciﬁcation.
7$,/+($'+D+E+F+GFig. 3. An example implementation of1-quasi linearizablequeue, whereeach of the linked list item is a segment that holds two data items. The ﬁrstdeqrandomly returns a value from the set{1,2}and the seconddeqreturnsthe remaining one. Then the thirddeqrandomly returns a value from the set{3,4}and the fourthdeqreturns the remaining one.linearizability violation, because the object no longer behaveslike a FIFO queue.However, being linearizable often means that the imple-mentation has signiﬁcant performance overhead when it isused by a large number of concurrent threads. For a quasilinearizable queue, in contrast, it is acceptable to have thedeqvalues being out of order occasionally, if such relaxation ofthe standard semantics can help improve the performance. Forexample, instead of using a standard linked list to implementthe queue, one may use a linked list of 2-cell segments toimplement the 1-quasi linearizable queue (Fig. 3). Thedeqoperation may remove any of the two data items in the headsegment. By using randomization, it is possible for two threadsto remove different data items from the head simultaneouslywithout introducing memory contention.Assume that the relaxed queue contains four values 1,2,3,4initially. The ﬁrst twodeqoperations would retrieve either 1,2or 2,1, and the next twodeqoperations would retrieve either3,4 or 4,3. Together, there are four possible combinations asshown in Fig. 3. Among them,H1-ais linearizable. The7$,/+($'
+D+E+F+GFig. 4. An alternative implementation of1-quasi linearizablequeue, whichis based on the random-dequeued queue. The ﬁrstdeqrandomly returns avalue from{1,2}and the seconddeqreturns the remaining one. Then thethirddeqrandomly returns a value from the new window{3,4}and thefourthdeqreturns the remaining one.other three are not linearizable, but are considered as1-quasi linearizable,m e a n i n gt h a tdeqvalues in these concurrenthistories are out-of-order by at most one step.However, implementing quasi linearizable data structuresisad i f ﬁ c u l tt a s k .S u b t l eb u g sc a nb ei n t r o d u c e dd u r i n gb o t ht hedesign phase and the implementation phase.Consider an alternative way of implementing the 1-quasilinearizable queue as illustrated in Fig. 4, where the ﬁrst twodata items are grouped into a virtual window. Adeqoperationmay retrieve any of the ﬁrst 2 data items from the head basedon randomization. Furthermore, only after both data items inthe current window are removed, will thedeqoperation moveon to retrieve data items in the next window. The resultingbehavior of this implementation should be identical to thatofthe segmented queue.However, a subtle bug would appear if one ignores the useof thevirtual window.F o re x a m p l e ,i fdeqalways returnsone of the ﬁrst two data items in the current queue, theimplementation would not be 1-quasi linearizable. In this case,it is possible for some data item to be over-taken indeﬁnitely,thereby making the data structure unsuitable for applicationswhere a 1-quasi queue is desired. For example, if every timethedeqoperation removesthe second data item in the list,w ewould get a sequence ofdeqvalues as follows: 2,3,4,..., wherevalue 1 is left in the queue indeﬁnitely.The last example demonstrates the need for a new methodthat can help detect violations of such quantitative properties.Existing concurrency bug checking tools focus primarily onsimple bug patterns such as deadlocks and data-races. Theyare not well suited for checking quantitative properties inthelow level code that implements concurrent data structures.Tothe best of our knowledge, the method proposed in this paperis the ﬁrst method for detecting quasi linearizability violationsin the code of concurrent data structures.III. PRELIMINARIESA. LinearizabilityWe follow the notation in [1], [2] to deﬁnehistoryas asequence of events, denotedh=e1e2...en,w h e r ee a c he v e n tis either a method invocation or a response of an object. Whenthere are multiple objects, letρ=h|odenote the projectionof historyhto objecto,w h i c hi st h es u b s e q u e n c eo fe v e n t srelated to that object. When there are multiple threads, letρ|Tdenote the projection of historyρto threadT,w h i c hi st h esubsequence of events of that thread. Two historiesρandρ/primeare equivalent, denotedρ−ρ/prime,i fa n do n l yi fρ|Ti=ρ/prime|Tifor all threadTi,w h e r ei=1,...,k.T w oe q u i v a l e n th i s t o r i e shave the same set of events, but the events may be arrangedin different orders.Asequential historyis one that starts with a method invo-cation, and each method invocation is followed immediatelyby the matching response; in other words, no two methodcall intervals are overlapping. Otherwise, the history is calledaconcurrent history.L e t<ρbe the precedence relation ofevents in historyρ.Deﬁnition 1:Alinearizationof a concurrent historyρis asequential historyρ/primesuch that (1)ρ/prime−ρ,m e a n i n gt h a tt h e yshare the same set of events, and (2)→ei,ej:ei<ρejimpliesei<ρ/primeej.I no t h e rw o r d s ,t h en o n - o v e r l a p p i n gm e t h o dc a l l si nρretain their execution order inρ/prime,w h e r e a st h eo v e r l a p p i n gmethod calls may take effect in any order.Asequential speciﬁcationof objecto,d e n o t e dspec(o),i sthe set of alllegalsequential histories – histories that conformto the semantics of the object. For example, a legal sequentialhistory of a queue is one where all theenq/deqvalues followthe FIFO order.Deﬁnition 2:Ac o n c u r r e n th i s t o r yρis linearizable withrespect to a sequential speciﬁcationspec(o)if and only if ithas a linearizationρ/primesuch thatρ/prime∈spec(o).I no t h e rw o r d s ,as long as the concurrent historyρcan be mapped to at leastoneρ/prime∈spec(o),i ti sc o n s i d e r e da sl i n e a r i z a b l e .B. Quasi LinearizabilityThe notion of quasi linearizability relies on the permutationdistance between two sequential histories. Letρ/prime=e/prime1e/prime2...e/primenbe a permutation ofρ=e1e2...en.L e t∆(ρ, ρ/prime)be thedistance betweenρandρ/primedeﬁned asmaxe−ρ{|ρ[e]−ρ/prime[e]|}.We useρ[e]andρ/prime[e]to denote the index of eventeinρandρ/prime,respectively. Therefore,∆(ρ, ρ/prime)is the maximum distancethat some event inρhas to travel to its new position inρ/prime.Quasi linearizability is often deﬁned on a subset of theobject’s methods. LetDomain(o)be the set of all op-erations of objecto.L e td⊂Domain(o)be a subset.LetPowerset(Domain(o))be the set of all subsets ofDomain(o).Deﬁnition 3:Thequasi-linearization factor(or quasi factor)for a concurrent objectois a functionQo:D→N,w h e r eD⊂Powerset(Domain(o))andNis the set of naturalnumbers.For example, a queue whereenqoperations follow the FIFOorder, butdeqvalues may be out-of-order by at mostKsteps,can be speciﬁed as follows:Denq={/a\}bracketle{to.enq(x),vo i d/a\}bracketri}ht|x∈X}Ddeq={/a\}bracketle{to.deq(),x/a\}bracketri}ht|x∈X}Qqueue(Denq)=0Qqueue(Ddeq)=KDeﬁnition 4:Ac o n c u r r e n th i s t o r yρisquasi linearizable [3]with respect to a sequential speciﬁcationspec(o)and quasifactorQoiffρhas a linearizationρ/primesuch that,•eitherρ/prime∈spec(o),m e a n i n gt h a tρis linearizable andhence is also quasi linearizable, or•there exists a permutationρ/prime/primeofρ/primesuch that–ρ/prime/prime∈spec(o);a n d–∆(ρ/prime|d, ρ/prime/prime|d)≤Qo(d)for all subsetd∈D.In other words,ρ/primeneeds to be a legal sequential history,or within a bounded distance from a legal sequential his-tory. Linearizability is subsumed by quasi linearizabilityw i t hQo:D→0.From now on, given a sequential historyρ/prime,w ec a l lΨ={ρ/prime/prime|∆(ρ/prime|d, ρ/prime/prime|d)≤Qo(d)for alld∈D}the set ofquasi-permutationsofρ/prime.Quasi linearizability is compositional in that a historyhis quasi linearizable if and only if subhistoryh|o,f o re a c hobjecto,i sq u a s il i n e a r i z a b l e .T h i sa l l o w su st oc h e c kq u a s ilinearizability on each individual object in isolation, whichreduces the computational overhead.C. Checking (Quasi) LinearizabilityThere are at least three levels where one can check the(quasi) linearizability property.•L1:check if a concurrent historyρis linearizable:∃linearizationρ/primeof historyρ:ρ/prime∈spec(o).•L2:check if a concurrent programPis linearizable:→concurrent historyρofP:ρis linearizable.•L3:check if a concurrent objectois linearizable:→programPthat uses objecto:Pis linearizable.L3 may be regarded as the full ﬂedged veriﬁcation of theconcurrent object, whereas L1 and L2 may be regarded asruntime bug detection. In this paper, we focus primarily onthe L1 and L2 checks. That is, given a terminating programPthat uses the concurrent objecto(called the test harness),we systematically generate the set of concurrent historiesofPand then check if all of these concurrent histories are(quasi) linearizable. Our main contribution is to propose anew algorithm for deciding whether a concurrent historyρis is quasi linearizable.IV . OVERALLALGORITHMThe overall algorithm for checking quasi linearizability con-sists of two phases (see Fig. 5). In Phase 1, we systematicallyexecute the test programPtogether with a standard datastructure to construct a sequential speciﬁcationspec(o),w h i c hconsists of all the legal sequential histories. In Phase 2, wesystematically execute the test programPtogether with theconcurrent data structure, and for each concurrent historyρ,check whetherρis quasi linearizable.For data structures such as queues, stacks, and priorityqueues, a sequential version may serve as the golden modelin Phase 1. Alternatively, the user may use a speciﬁcallyconﬁgured concurrent data structure as the golden model, e.g.,by setting the quasi factor of a relaxed queue to 0, whicheffectively turns it into a normal queue.In Phase 1, we use a CHESS-like systematic con-currency testing tool called Inspect [14] to computeall the legal sequential histories. We have modiﬁed In-spect to automatically wrap up every method call in alock/unlock pair. For example, method callo.enq()becomeslock(lk);o.enq();unlock(lk),w h e r ew ea s s i g nal o c klktoeach objectoto ensure that context switches happen only atthe method call boundary. In other words, all method callsof objectoare executed serially. Furthermore, Inspect canguarantee that all the possible sequential histories of thisform are generated. Our new method leverages theselegalsequential historiesto construct the sequential speciﬁcationspec(o).In Phase 2, we use Inspect again to compute the set ofconcurrent histories of the same test program. However, thistime, we allow the instructions within the method bodiesto interleave freely. This can be accomplished by invokingInspect in its default mode, without adding the aforementionedlock/unlock pairs. In addition to handling the POSIX threadsfunctions, we have extended Inspect to support the set of GNUbuilt-in functions for atomic shared memory access, which arefrequently used in implementing concurrent data structures.Our core algorithm for checking whether a concurrenthistoryρis quasi linearizable is invoked in Phase 2.•For each concurrent historyρ,w ec o m p u t et h es e tΦoflinearizationsofρ(see Deﬁnition 1). If anyρ/prime∈Φmatches a legal sequential history inspec(o),b yd e ﬁ n i -tion,ρis linearizable and also quasi linearizable.•Otherwise, for each linearizationρ/prime∈Φ,w ec o m p u t ethe setΨofquasi-permutationsofρ/primewith respect to thequasi factor (see Deﬁnition 4), which deﬁnes the distancebetweenρ/primeand eachρ/prime/prime∈Ψ.–If there exists a quasi permutationρ/prime/primesuch thatρ/prime/prime∈spec(o),t h e nρis quasi linearizable.–Otherwise,ρis not quasi linearizable and hence isnot linearizable.The pseudo code for checking quasi linearizability is shownin Algorithm 1, which takes a concurrent historyρand a quasifactorKas input and returns either TRUE (quasi linearizable)or FALSE (not quasi linearizable). The main challenge is togenerate the setΦof linearizations of the given historyρandthe setΨof quasi permutations of eachρ/prime∈Φ.T h eﬁ r s tstep, which is straightforward, will be explained in this section.The second step, which is signiﬁcantly more involved, will beexplained in the next section.We now explain the detailed algorithm for computing the setΦof linearizations for the given historyρ.T h ec o m p u t a t i o ni scarried out by Subroutinecompute_linearizations(ρ). Lethistoryρ0=ϕinv1inv2φresp1ψresp2...whereϕ, φandψare arbitrary subsequences andinv1,inv2are theinvocation events of the ﬁrst two overlapping method calls.We will replaceρ0inΦwith the new historiesρ1andρ2.In other words, for any two method call pairs(invi,respi)and(invj,respj)inρ,i ft h e yd on o to v e r l a p ,m e a n i n gt h a teitherrespi<ρinvjorrespj<ρinvi,w ew i l lk e e pt h i sexecution order. In they overlap, we will generate two newPhase 1:deterministicFIFO queue(golden model)
(under test)Phase 2:quasi−linearizablequeueit belongs tospec(o){ρ}sequential speciﬁcationconcurrent historiesspec(o)for eachρ,g e n e r a t ea l llinearizations{ρ/prime}quasi permutations{ρ/prime/prime}For eachρ/prime,g e n e r a t ea l lFor eachρ/prime/prime,c h e c ki f
Fig. 5. The overall ﬂow of our new quasi linearizability checking algorithm.
Algorithm 1Checking the quasi linearizability of the concur-rent historyρwith respect to the quasi factorK.
1:check_quasi_linearizability(ρ, K)2:{3:Φ←compute_linearizations(ρ);4:for each(ρ/prime−Φ){5:if(ρ/prime−spec(o))returnTRUE;6:Ψ←compute_quasi_permutations(ρ/prime,K);7:for each(ρ/prime/prime−Ψ){8:if(ρ/prime/prime−spec(o))returnTRUE;9:}10:}11:returnFALSE;12:}13:compute_linearizations(ρ)14:{15:Φ←{ρ};16:while(∃ac o n c u r r e n th i s t o r yρ0−Φ){17:Letρ0=ϕinv1inv2φresp1ψresp2...;18:ρ1←ϕinv1resp1inv2φψresp2...;19:ρ2←ϕinv2resp2inv1φresp1ψ. . .;20:Φ←Φ∪{ρ1,ρ2}\{ρ0};21:}22:returnΦ;23:}24:compute_quasi_permutations(ρ/prime,K)25:{26:Ψ←{};27:state
stack←first_run(ρ/prime,K);28:while(T R U E){29:ρ/prime/prime←backtrack_run(s t a t e
stack,ρ/prime);30:if(ρ/prime/prime==n u l l)break;31:Ψ←Ψ∪{ρ/prime/prime};32:}33:returnΨ;34:}
histories, where one hasrespi<ρinvjand the other hasrespj<ρinvi.Example.Consider the history in Fig. 6 (left). The ﬁrst twooverlapping calls start withinv1andinv2,r e s p e c t i v e l y .•First, we construct a new history where(inv1,resp1)is moved ahead of(inv2,resp2).T h i si ss t r a i g h t f o r w a r dbecause, by the time we identifyinv1andinv2,w ec a ncontinue to traverse the event sequence to ﬁndresp1inρ0and then move it ahead of eventinv2.S i n c et h er e s u l t i n gHistory 1still has overlapping method calls, we repeatthe process in the next iteration.•Second, we construct a new history by moving(inv2,resp2)ahead of(inv1,resp1).T h i si sal i t t l em o r einvolved because there can be many other method callsof ThreadT1that are executed betweeninv2andresp2.LQYUHVSLQY
UHVSLQYUHVS+LVWRU\
LQYUHVS+LVWRU\+LVWRU\UHVSLQYLQYUHVSLQYUHVSLQYUHVSLQYUHVS
Fig. 6. Example: Computing thelinearizationsof the given concurrent historyby repeatedly sequentializing the ﬁrst two overlapping method calls denotedby(inv1,resp1)and(inv2,resp2).We take all these events betweeninv1andresp2,a n dmove them afterresp2.I nt h i se x a m p l e ,t h en e wh i s t o r yisHistory 2.According to Deﬁnition 1, when at least one of the lineariza-tionsρ/prime∈Φis a legal sequential history,ρis linearizable,which means that it is also quasi linearizable. Otherwise,ρisnot linearizable (but may still be quasi linearizable).V. CHECKING FORQUASILINEARIZABILITYTo check whether historyρ/prime∈Φis stillquasi linearizable, we need to invoke Subroutinecompute_quasi_permutations(ρ/prime,K). As shown inAlgorithm 1, the subroutine consists of two steps. Inthe ﬁrst step,first_runis invoked to construct a doublylinked list to hold the sequence of states connected by eventsinρ/prime,d e n o t e dstate_stack:s1e1−→s2e2−→...snen−→.E a c hstatesi,w h e r ei=1,...,n,r e p r e s e n t sa na b s t r a c ts t a t eo fthe objecto.S u b r o u t i n efirst_runalso ﬁlls up the ﬁeldsof each state with the information needed later to generatethe quasi permutations. In the second step, we generatequasi permutations ofρ/prime∈Ψ,o n ea tat i m e ,b yc a l l i n gbacktrack_run.A. Example: Constructing Quasi PermutationsWe generate the quasi permutations by reshufﬂing the eventsinρ/primeto form new histories. More speciﬁcally, we computeVVVGHT GHTGHTGHTVGHT2ULJLQDOKLVWRU\«
3HUPXWDWLRQ«GHTVGHTVGHT3HUPXWDWLRQ«Fig. 7. An example search tree for generating all1-quasi permutations of theinput sequencedeq(1);deq(2);deq(3).all possible permutations ofρ/prime,d e n o t e d{ρ/prime/prime},s u c ht h a tthe distance betweenρ/primeandρ/prime/primeare bounded by the quasifactorK.O u rm e t h o df o rc o n s t r u c t i n gt h eq u a s ip e r m u t a t i o n sfollows thestrict out-of-ordersemantics as deﬁned in [3], [4].Consider queues as the example. Astrict out-of-orderk-quasipermutation consists of two restrictions:•Restriction 1:e a c hdeqis allowed to return a value thatis at mostksteps away from the head node.•Restriction 2:t h eﬁ r s td a t ae l e m e n t( i nh e a dn o d e )m u s tbe returned by one of the ﬁrstkdeqoperations.History 0: deq(1) --> deq(2) --> deq(3)Res1 Res2History 1: deq(2) --> deq(1) --> deq(3) ok okHistory 2: deq(1) --> deq(3) --> deq(2) ok okHistory 3: deq(3) --> deq(1) --> deq(2) NO okHistory 4: deq(2) --> deq(3) --> deq(1) ok NOHistory 5: deq(3) --> deq(2) --> deq(1) NO NOTo illustrate thestrict out-of-orderdeﬁnition, consider the1-quasi queue above. Assume that the input historyρ/primeisdeq()=1,deq()=2,deq()=3.T h eh i s t o r yc a nb ea r b i t r a r i l yr e -shufﬂed into ﬁve additional histories, of which only History1and History 2 satisfy the above two restrictions. They are thedesired quasi permutations ofρ/primewhereas the others are not. Inparticular, History 3 violates Restriction 1 because the ﬁrstdeqreturns the value that is two steps away from the head. History4v i o l a t e sR e s t r i c t i o n2b e c a u s et h eh e a dv a l u ei sr e t u r n e dbythe thirddeqoperation, which is too late. History 5 violatesboth restrictions.We compute the quasi permutations using a depth-ﬁrstsearch (DFS) of the abstract states. For the above example,this process is illustrated in Fig. 7, where the initial run isassumed to bes1deq(1)−→s2deq(2)−→s3deq(3)−→.•In the ﬁrst run, we construct the state stack that holdsthe initial history. Then we ﬁnd the last backtrack state,which is states2,a n de x e c u t edeq(3)instead ofdeq(2).This leads to the second runs1deq(1)−→s2deq(3)−→s/prime3deq(2)−→.•In the second run, we again ﬁnd the last backtrack state,which iss1,a n de x e c u t edeq(2)instead ofdeq(1).T h i sleads to the third runs1deq(2)−→s/prime/prime2deq(1)−→s/prime/prime3deq(3)−→.•In the third run, we can no longer ﬁnd any backtrack state.Therefore, the procedure terminates. We cannot generatean e wr u nb yc h o o s i n gdeq(3)in states1,b e c a u s ei twould violate Restriction 1. We cannot generate a newrun by choosingdeq(3)in states/prime/prime2either, because itwould violate Restriction 2.B. Elementary Data StructuresTo enforce the restrictions imposed by thestrict out-of-ordersemantics, we need to add some ﬁelds into each state.In particular, we add anenabledﬁeld into each state to helpenforce Restriction 1, and we add alatenessattribute into eachenabled event to enforce Restriction 2.state
stack:W es t o r et h es e q u e n c eo fs t a t e so ft h ec u r r e n tr u nin a doubly linked list called state
stack. Executing a methodcall event moves the object from one state to another state.Each stateshas the following ﬁelds:•s.enabled is the set of events that can be executed ats;•s.select is the event executed by the current history;•s.done is the set of events executed atsby somepreviously explored permutations in the backtrack search;•s.newly
enabled is the set of events that become enabledfor the ﬁrst time along the given historyρ/prime.T h eﬁ e l di sinitialized by the ﬁrst run, and is used to compute thes.enabled ﬁeld in the subsequent runs.Example 1:s.newly_enabled.T h ei n i t i a ls t a t eh a sa tm o s t(K+1 )events in its newly
enabled ﬁeld, whereKis the quasi factor. Every other state has at most oneevent in this newly
enabled ﬁeld. For the given historydeq(1);deq(2);deq(3)and quasi factor 1, we have
s1.newly
enabled={deq(1),deq(2)}
≥1e v e n t si nt h ei n i t i a ls t a t e
s2.newly
enabled={deq(3)}
at most one event
s3.newly
enabled={}
at most one event
In other words, each event will appear in the newly
enabledﬁeld of the state that is preciselyKsteps ahead of its originalstate inρ/prime.W ew i l le n f o r c eR e s t r i c t i o n1w i t ht h eh e l po ft h enewly
enabled ﬁeld.Example 2:s.enabledands.done.F o rt h ea b o v ee x a m p l e ,
s1.enabled={deq(1),deq(2)}
s1.done={deq(1)}
s2.enabled={deq(2),deq(3)}
s2.done={deq(2)}
s3.enabled={deq(3)}
s3.done={deq(3)}
Bothdeq(1)anddeq(2)are ins1.enabled, but onlydeq(1)is ins1.done because it is executed in the current run.Since the set (s.enabled\s.done) is not empty for boths1ands2,w eh a v et w ob a c k t r a c ks t a t e s .A f t e rb a c k t r a c k -ing tos2and executingdeq(3),w ec r e a t ean e wp e r m u -tationdeq(1);deq(3);deq(2).S i m i l a r l y ,a f t e rb a c k t r a c k i n gtos1and executingdeq(2),w ec r e a t ean e wp e r m u t a t i o ndeq(2);deq(1);deq(3).For permutationdeq(2);deq(1);deq(3),t h ee n a b l e da n dd o n eﬁelds will be changed to the following:
s1.enabled={deq(1),deq(2)}
s1.done={deq(1),deq(2)}
s/prime/prime2.enabled={deq(1),deq(3)}
s/prime/prime2.done={deq(1)}
s/prime/prime3.enabled={deq(3)}
s/prime/prime3.done={deq3}
Although (s/prime/prime2.enabled\s/prime/prime2.done) is not empty, we cannot createthe new permutationdeq(2);deq(3);deq(1)becausedeq(1)would be out-of-order by two steps. We avoid generating suchpermutations by leveraging the lateness attribute that is addedinto every enabled event.lateness attribute:Each event ins.enabled has a latenessattribute, indicating how many steps this event is later thanits original occurrence inρ/prime.I tr e p r e s e n t sh o wm a n ys t e p st h i sevent can be postponed further in the current permutation.s[i-k] lateness(e) = -k...s[i].select = e lateness(e) = 0...s[i+k] lateness(e) = kExample 3: Consider the example above, where eventeisexecuted in statesiof the given history. Fork-quasi permuta-tions, the earliest state whereemay be executed issi−k,a n dthe latest state whereemay be executed issi+k.T h el a t e n e s sattribute of eventein statesi−kis−k,m e a n i n gt h a ti tm a ybe postponed for at mostk−(−k)=2ksteps. The lateness ofein statesi+kisk,m e a n i n gt h a tehas reached the maximumlateness and therefore must be executed in this state.Must-select event:This brings us to the important notion ofmust-select event. Ins.enabled, if there does not exist anyevent whose lateness reachesk,a l lt h ee n a b l e de v e n t sc a nb epostponed for at least one more step. In this case, we canrandomly choose an event from the set (s.enabled\s.done)t oexecute. If there exists an event ins.enabled whose latenessisk,t h e nw em u s te x e c u t et h i se v e n ti ns t a t es.Example 4: If we backtrack from the current historydeq(1),deq(2),deq(3)to states1and then executedeq(2),eventdeq(1)will have a lateness of 1 in states/prime/prime2,m e a n i n gthat it has reached the maximum delay allowed. Therefore, ithas to be executed in states2.
s1.lateness={deq(1):lateness=0, deq(2):lateness=-1}
s/prime/prime2.lateness={deq(1):lateness=1, deq(3):lateness=-1}
s/prime/prime3.lateness={deq(3):lateness=0}
The initial lateness is assigned to each enabled event whenthe event is added tos.enabled byfirst_run.E v e r yt i m ea nevent is not selected for execution in the current state, it willbe inherited by the enabled ﬁeld of the subsequent state. Thelateness of this event is then increased by 1.An important observation is that, in each state, there can beat most onemust-selectevent. This is because the ﬁrst runρ/primeis a total order of events, which gives each event a differentlatenessvalue – by deﬁnition, theirexpiration timesare alldifferent.C. Algorithm: ConstructingK-Quasi PermutationsThe pseudo code for generating quasi permutations ofhistoryρ/primeis shown in Algorithm 2. Initializing the late-ness attributes of enabled events is performed by Sub-routineinit_enabled_and_lateness,w h i c hi sc a l l e db yfirst_run.T h el a t e n e s sa t t r i b u t e sa r et h e nu p d a t e db yupdate_enabled_and_lateness.Each call tobacktrack_runwill return a new quasi per-mutation ofρ/prime.I n s i d et h i ss u b r o u t i n e ,w es e a r c hf o rt h el a s tbacktrack statesin state
stack. If such backtrack statesexists, we prepare the generation of a new permutation byresetting the ﬁelds of all subsequent states ofs,w h i l ek e e p i n gtheir newly
enabled ﬁelds intact. Then we choose a previouslyunexplored event ins.enabled to execute.The previously unexplored event ins.enabled is chosen bycallingpick_an_enabled_event.I ft h e r ee x i s t sam u s t - s e l e c tevent ins.enabled whose lateness reachesk,t h e ni tm u s tb echosen. Otherwise, we choose an event from the set (s.enabled\s.done) arbitrarily. We useupdate_enabled_and_latenessto ﬁll up the events ins.enabled. For events that are inheritedfrom the previous state’s enabled set, we increase their late-ness’ by one. We iterate until the last state is reached. At thistime, we have computed a new quasi permutation ofρ/prime.D. DiscussionsOur method is geared toward bug hunting. Whenever weﬁnd a concurrent historyρthat is not quasi linearizable, itis guaranteed to be a real violation. However, recall thatour method implements the L1 and L2 checks but not theL3 check as deﬁned in Section III. Therefore, even if allconcurrent histories of the test program are quasi linearizable,we cannot conclude that the concurrent data structure itselfi squasi linearizable.Furthermore, when checking for quasi linearizability, ourruntime checking framework has the capability of generatingtest programs (harness) that arewell-formed;t h a ti s ,t h enumber ofenqoperations is equal to the number ofdeqoperations. If the test program is provided by the user, thenitis the user’s responsibility to ensure this well-formedness. Thisis important because, if the test program is not well-formed,there may beout-of-thin-airevents. Below is an example.Thread 1 Thread 2 Hist1 Hist2 Hist3-------- --------enq(3) enq(5) enq(3) enq(5) enq(3)enq(4) deq() ... ... enq(4)... ... ... ... enq(5)-------- -------- deq()=3 deq()=5 deq()=4Here, the sequential speciﬁcation is{Hist1,Hist2}.I nb o t hhistories, eitherdeq()=3ordeq()=5.H o w e v e r ,t h edeqvaluecan never be 4. This is unfortunate becauseHist3is 1-quasi linearizable but cannot match any of the two legalsequential histories (Hist1orHist2)b e c a u s ei th a sdeq()=4.This problem can be avoided by requiring the test program tobe well-formed. For example, by adding two moredeqcalls tothe end of the main thread, we can avoid the aforementionedout-of-thin-airevents.VI. EXPERIMENTSWe have implemented our new quasi linearizability check-ing method in a software tool based on the LLVM platformfor code instrumentation and based onInspectfor system-atically generating interleaved executions. Our tool, calledRound-Up,c a nh a n d l eu n m o d i ﬁ e dC / C + +c o d eo fc o n c u r r e n tdata structures on the Linux/PThreads platform. We haveimprovedInspectby adding the support for GNU built-inatomic functions for direct access of shared memory, sincethey are frequently used in the low level code for implementingconcurrent data structures.Algorithm 2GeneratingK-quasi permutations for historyρ/prime.
1:first_run(ρ/prime,K){2:state
stack←empty list;3:for each(e v e n tevin the sequenceρ/prime){4:s←new state;5:state
stack.append(s);6:s.select←ev;7:s.done←{ev};8:init_enabled_and_lateness(s, ev, K);9:}10:returnstate
stack;11:}12:init_enabled_and_lateness(s, ev, K){13:lateness←0;14:while(1){15:s.enabled.add(/a\}bracketle{tev,lateness/a\}bracketri}ht);16:if(l a t e n e s s= =−k||s.prev == null ){17:s.newly
enabled.add(/a\}bracketle{tev,l a t e n e s s/a\}bracketri}ht);18:break;19:}20:lateness–;21:s←s.prev in state
stack;22:}23:}24:backtrack_run(s t a t e
stack,ρ){25:Letsbe the last state in state
stack such that26:pick_an_enabled_event(s)/\e}atio\slash=null;27:if(s u c hsdoes not exist )28:returnnull;29:for each(s t a t ea f t e rsin state
stack ){30:resets.select,s.done, ands.enabled,31:but keeps.newly
enabled;32:}33:while(s/\e}atio\slash=null ){34:ev←pick_an_enabled_event(s);35:s.select←ev;36:s.done←{ev};37:s←s.next;38:update_enabled_and_lateness(s);39:}40:return(sequence of selected events in state
stack);41:}42:pick_an_enabled_event(s){43:if(∃/a\}bracketle{tev, lateness/a\}bracketri}ht−s.enabled &&lateness=k){44:if(ev/\e}atio\slash−s.done ) // must-select event45:returnev;46:else47:returnnull;48:}49:if(∃/a\}bracketle{tev, lateness/a\}bracketri}ht−s.enabled &&ev/\e}atio\slash−s.done) )50:returnev;51:else52:returnnull;53:}54:update_enabled_and_lateness(s){55:p←s.prev;56:if(sorpdo not exist )57:return;58:s.enabled←{};59:for each(/a\}bracketle{tev, lateness/a\}bracketri}ht−p.enabled &&ev/\e}atio\slash−p.done){60:s.enabled.add(/a\}bracketle{tev, lateness--/a\}bracketri}ht);61:}62:for each(/a\}bracketle{tev, lateness/a\}bracketri}ht−s.newly
enabled ){63:s.enabled.add(/a\}bracketle{tev, lateness/a\}bracketri}ht);64:}65:}
We have conducted experiments on a set of concurrent datastructures [3], [6], [8], [5], [6], [4] including both standardand quasi linearizable queues, stacks, and priority queues.F o rsome data structures, there are several variants, each of whichuses a different implementation scheme. The characteristicsof these benchmark programs are shown in Table I. The ﬁrstthree columns list the name of the data structure, a shortdescription, and the number of lines of code. The next twocolumns show whether it is linearizable and quasi linearizable.The last column provides a list of the relevant methods.Table II shows the experimental results for checking stan-dard linearizability. The ﬁrst four columns show the statisticsof the test program, including the name, the number of threads(concurrent/total), the number of method calls, and whetherlinearizability violations exist. The next two columns showt h estatistics of Phase 1, consisting of the number of sequentialhistories and the time for generating these sequential histo-ries. The last three columns show the statistics of Phase 2,consisting of the number of concurrent histories (buggy/total),the total number of linearizations, and the time for checkingthem. In all test cases, our method was able to correctly detectthe linearizability violations.Table III shows the experimental results for checking quasilinearizability. The ﬁrst four columns show the statisticsofthe test program. The next two columns show the statisticsof Phase 1, and the last three columns show the statisticsof Phase 2, consisting of the number of concurrent histories(buggy/total), the total number of quasi permutations, andthetime for generating and checking them. In all test cases, wehave set the quasi factor to 2.Our method was able to detect all real (quasi) linearizabilityviolations in fairly small test programs. This is consistentw i t hthe experience of Burckhartet al.[16] in evaluating their Line-Up tool for checking standard (but not quasi) linearizability.This is due to the particular application of checking theimplementation of concurrent data structures. Although thenumber of method calls in the test program is small, theunderlying low-level shared memory operations can still bemany. This leads to a rich set of very subtle interactionsbetween the low-level memory accessing instructions. In suchcases, the buggy execution can be uncovered by checking atest program with only a relatively small number of threads,method calls, and context switches.We have also conducted experiments on a set of re-cently released high-performance concurrent objects in theScalsuite [15]. Table IV shows the characteristics of thesebenchmark programs and Table V shows the experimentalresults. We have successfully detected two real linearizabilityviolations in theScalsuite, one of which is a known violationwhereas the other is a previously unknown programmingerror. In particular,sl-queueis a queue designed for highperformance applications, but it is not thread safe and thereforeis not linearizable.k-stack,o nt h eo t h e rh a n d ,i sd e s i g n e dt obe quasi linearizable. However, due to an ABA bug, the datastructure is not quasi linearizable.Our tool is able to quickly detect the linearizability violationinsl-queueand the quasi linearizability violation ink-stack.Furthermore, it generates detailed execution traces to illustratehow the violations can be reproduced during debugging. Interms of the ABA bug ink-stack,f o re x a m p l e ,o u rt o o lshows that the bug occurs when one thread executes thepushoperation while another thread is executing thepopoperation concurrently. Due to erroneous thread interleaving,it is possible for the same data item to be added to the stacktwice, although thepushoperation is executed only once. Wehave reported the bug ink-stackto theScaldevelopers, whohave conﬁrmed that it is indeed a bug.It is worth pointing out that existing concurrency bug ﬁndingtools, such as data-race and atomicity violation detectors,a r eTABLE ITHE STATISTICS OF THE BENCHMARK EXAMPLES.
Class
Description
LOC
Linearizable
Quasi-Lin
Methods checked
IQueue
buggy queue, deq may remove null even if not empty
154
No
NO
enq(int), deq()
Herlihy/Wing queue
correct normal queue
109
YES
YES
enq(int), deq()
Quasi Queue
correct quasi queue
464
NO
YES
enq(int), deq()
Quasi Queue b1
deq removes value more than k away from head
704
NO
NO
enq(int), deq()
Quasi Queue b2
deq removes values that have been removed before
401
NO
NO
enq(int), deq()
Quasi Queue b3
deq null even the queue is not empty
427
NO
NO
enq(int), deq()
Quasi Stack b1
pop null even if the stack is not empty
487
NO
NO
push(int), pop()
Quasi Stack b2
pop removes values move than k away from the tail
403
NO
NO
push(int), pop()
Quasi Stack
linearizable, and hence quasi linearizable
403
YES
YES
push(int), pop()
Quasi Priority Queue
implementation of quasi priority queue
508
NO
YES
enq(int, int), deqMin()
Quasi Priority Queue b2
deqMin removes value more than k away from head
537
NO
NO
enq(int, int), deqMin()
TABLE IIRESULTS OF CHECKING STANDARD LINEARIZABILITY ON CONCURRENTDATA STRUCTURES.
Test Program
Phase 1
Phase 2
Class
threads
calls
violation
history
time (seconds)
history (buggy/total)
linearization
time (seconds)
IQueue
2/3
2*2+0
YES
3
0.1
2/6
13
0.3
Herlihy/Wing queue
2/3
2*2+0
NO
3
0.1
0/4
9
0.2
Quasi Queue
2/3
2*2+4
YES
6
0.2
16/16
61
2.5
Quasi Queue
2/3
3*3+4
YES
20
1.1
64/64
505
43.7
Quasi Queue
2/3
2*3+3
YES
10
0.4
24/32
169
8.3
Quasi Queue
2/3
3*3+2
YES
20
0.8
108/118
1033
1m23s
Quasi Queue
2/3
3*4+1
YES
35
1.6
149/198
2260
5m8s
Quasi Queue
2/3
4*4+0
YES
70
2.6
274/476
8484
37m34s
Quasi Queue b1
2/3
2*2+4
YES
6
0.3
91/91
409
17.8
Quasi Queue b2
2/3
2*2+4
YES
6
0.3
91/91
409
18.1
Quasi Queue b3
2/3
2*2+4
YES
6
0.3
141/141
653
26.9
Quasi Stack b1
2/3
2*2+4
YES
6
0.3
9/9
34
1.6
Quasi Stack b2
2/3
2*2+4
YES
6
0.3
16/16
61
2.5
Quasi Stack
2/3
2*2+4
NO
6
0.3
0/16
61
2.5
Quasi Priority Queue
2/3
2*2+4
YES
6
0.5
16/16
61
4.9
Quasi Priority Queue b2
2/3
2*2+4
YES
6
0.5
125/125
532
27.0
TABLE IIIRESULTS OF CHECKING QUASI LINEARIZABILITY ON CONCURRENT DATAS T R U C T U R E S.
Test Program
Phase 1
Phase 2
Class
threads
calls
violation
history
time (seconds)
history (buggy/total)
permutation
time (seconds)
Quasi Queue
2/3
2*2+4
NO
6
0.2
0/16
1708
2.9
Quasi Queue
2/3
3*3+4
NO
20
1.1
0/64
73730
5m33s
Quasi Queue
2/3
2*3+3
NO
10
0.4
0/32
4732
9.6
Quasi Queue
2/3
3*3+2
NO
20
0.8
0/118
28924
1m34s
Quasi Queue
2/3
3*4+1
NO
35
1.6
0/198
63280
5m40s
Quasi Queue
2/3
4*4+0
NO
70
2.6
0/476
237552
40m56s
Quasi Queue (qfactor=3)
2/3
2*3+3
NO
10
0.4
0/32
8112
14.9
Quasi Queue (qfactor=3)
2/3
3*3+2
NO
20
0.8
0/118
49584
2m36s
Quasi Queue (qfactor=3)
2/3
3*4+1
NO
35
1.6
0/198
108480
10m15s
Quasi Queue (qfactor=3)
2/3
4*4+0
NO
70
2.6
0/476
407232
69m32s
Quasi Queue b1
2/3
2*2+4
YES
6
0.3
41/91
11452
20.1
Quasi Queue b2
2/3
2*2+4
YES
6
0.3
91/91
11452
20.2
Quasi Queue b3
2/3
2*2+4
YES
6
0.3
73/141
18284
31.0
Quasi Stack b1
2/3
2*2+4
YES
6
0.3
9/9
2108
3.5
Quasi Stack b2
2/3
2*2+4
YES
6
0.3
6/16
1708
2.8
Quasi Stack b3
2/3
2*2+4
NO
6
0.3
0/16
1708
2.8
Quasi Priority Queue
2/3
2*2+4
NO
6
0.5
0/16
1708
4.7
Quasi Priority Queue b2
2/3
2*2+4
YES
6
0.5
54/125
6384
20.0
TABLE IVTHE STATISTICS OF THESCAL[15]BENCHMARK EXAMPLES(TOTALLOCOFScalIS5,973).
Class
Description
LOC
Linearizable
Quasi-Lin
Methods checked
sl-queue
singly-linked list based single-threaded queue
73
NO
NO
enq, deq
t-stack
concurrent stack by R. K. Treiber
109
YES
YES
push, pop
ms-queue
concurrent queue by M. Michael and M. Scott
250
YES
YES
enq, deq
rd-queue
random dequeued queue by Y . Afek, G. Korland, and E. Yanovsky
162
NO
YES
enq, deq
bk-queue
bounded k-FIFO queue by Y . Afek, G. Korland, and E. Yanovsky
263
NO
YES
enq, deq
ubk-queue
unbounded k-FIFO queue by C.M. Kirsch, M. Lippautz, and H. Payer
259
NO
YES
enq, deq
k-stack
k-stack by T. A. Henzinger, C. M. Kirsch, H. Payer, and A. Sokolova
337
NO
NO
push, pop
TABLE VRESULTS OF CHECKING QUASI LINEARIZABILITY FOR THESCAL[15]BENCHMARK EXAMPLES.
Test Program
Phase 1
Phase 2
Class
threads
calls
violation
history
time (seconds)
history (buggy/total)
permutation
time (seconds)
sl-queue (enq+deq)
2/3
1*1+10
NO
2
0.1
0/2
438
0.5
sl-queue (enq+enq)
2/3
1*1+10
YES
2
0.06
1/2
438
0.54
sl-queue (deq+deq)
2/3
1*1+10
YES
2
0.07
4/8
2190
2.29
t-stack (push+pop)
2/3
1*1+10
NO
2
0.16
0/8
2190
2.6
t-stack (push+push)
2/3
1*1+10
NO
2
0.1
0/8
2190
2.45
t-stack (pop+pop)
2/3
1*1+10
NO
2
0.12
0/8
2190
2.34
ms-queue (enq+deq)
2/3
1*1+10
NO
2
0.11
0/3
730
0.96
ms-queue (enq+enq)
2/3
1*1+10
NO
2
0.12
0/31
8906
10.78
ms-queue (deq+deq)
2/3
1*1+10
NO
2
0.13
0/12
3358
3.68
rd-queue (enq+deq)
2/3
1*1+10
NO
2
0.25
0/7
1898
2.63
rd-queue (enq+enq)
2/3
1*1+10
NO
2
0.2
0/31
8906
11.23
rd-queue (deq+deq)
2/3
1*1+10
NO
2
0.13
0/6
1606
2.04
bk-queue (enq+deq)
2/3
1*1+10
NO
2
0.23
0/1
146
0.22
bk-queue (enq+enq)
2/3
1*1+10
NO
2
0.18
0/12
3358
3.94
bk-queue (deq+deq)
2/3
1*1+10
NO
2
0.19
0/8
2190
2.74
ubk-queue (enq+deq)
2/3
1*1+10
NO
2
0.85
0/1
146
0.25
ubk-queue (enq+enq)
2/3
1*1+10
NO
2
0.65
0/12
3358
6.55
ubk-queue (deq+deq)
2/3
1*1+10
NO
2
0.28
0/8
2190
3.2
k-stack (push+pop)
2/3
1*1+10
YES
2
0.82
11/69
20002
27.35
k-stack (push+push)
2/3
1*1+10
NO
2
0.26
0/12
3358
4.86
k-stack (pop+pop)
2/3
1*1+10
NO
2
0.34
0/8
2190
3.85
not effective for checking low-level C/C++ code that imple-ments most of the highly concurrent data structures. Thesebug detectors are designed primarily for checking applicationlevel code. Furthermore, they are often based on the locksetanalysis and condition variable analysis. Although locks andcondition variables are widely used in writing applicationlevelcode, they are rarely used in implementing concurrent datastructures. Synchronization in concurrent data structuresm a ybe implemented using atomic memory accesses. To the best ofour knowledge, no prior method can directly check quantitativeproperties in such low level C/C++ code.VII. RELATEDWORKOur new method can detect quasi linearizability violationsin the code of concurrent data structures. A closely relatedwork is a model checking based approach for formally ver-ifying quantitative relaxations of linearizability in models ofconcurrent systems, which we have published recently [17].However, the method is not designed for checking the C/C++code. Another closely related work is Line-Up [16], which cancheck the code of concurrent data structures fordeterministiclinearizabilitybut cannot check for quasi linearizability.There exists a large body of work on verifying standardlinearizability. For example, Liu et al. [11] verify standardlinearizability by proving that an implementation model re-ﬁnes a speciﬁcation model. Vechev et al. [12] use the SPINmodel checker to verify linearizability in a Promela model.Cern´ y et al. [13] use automated abstractions together withmodel checking to verify linearizability properties in Javaprograms. There also exists work on proving linearizabilityb yconstructing mechanical proofs, often with signiﬁcant manualintervention [9], [10]. However, none of these methods cancheck quantitative relaxations of linearizability.There also exist runtime checking methods for other typesof consistency conditions such as sequential consistency [18],quiescent consistency [19], and eventual consistency [20].Some of these consistency conditions, in principle, may beused to ensure the correctness of concurrent data structures.However, none of these correctness conditions is as widelyused as linearizability. Furthermore, they do not involve anyquantitative properties.For checking application level code, which has signiﬁcantlydifferent characteristics from the low level code that imple-ments concurrent data structures,serializabilityandatomicityare the two frequently used correctness properties. There alsoexists a large body of work on detecting violations of theseproperties (e.g. [21], [22], [23] and [24], [25], [26], [27],[28], [29], [30], [31], [32], [33], [34], [35], [36], [37], [38],[39], [40], [41], [42], [43]). These bug ﬁnding methods differfrom our new method in that they are checking for differenttypes of properties. In practice, atomicity and serializabilityhave been used primarily at the shared memory read/writelevel. Whereas linearizability has been used primarily at themethod API level. Furthermore, existing tools for detectingserializability violations and atomicity violations do notc h e c kfor quantitative properties.VIII. CONCLUSIONSWe have presented a new algorithm for runtime checking ofstandard and quasi linearizability in concurrent data structures.Our method works directly on the C/C++ code and is fullyautomated, without requiring the user to write speciﬁcationsor annotate linearization points. It guarantees that all thereported violations are real violations. We have implementedthe new algorithm in a software tool calledRound-Up.O u rexperimental evaluation shows thatRound-Upis effectivein detecting quasi linearizability violations and generatinginformation for error diagnosis.ACKNOWLEDGMENTThe authors would like to thank Christoph Kirsch andMichael Lippautz of University of Salzburg for making theScalbenchmarks available and for promptly answering ourquestions. Our work is supported in part by the NSF grantCCF-1149454 and the ONR grant N00014-13-1-0527.REFERENCES[1] M. Herlihy and J. M. Wing, “Linearizability: A correctness condition forconcurrent objects,”ACM Trans. Program. Lang. Syst.,v o l .1 2 ,n o .3 ,pp. 463–492, 1990.[2] M. Herlihy and N. Shavit,The art of multiprocessor programming.Morgan Kaufmann, 2008.[3] Y . Afek, G. Korland, and E. Yanovsky, “Quasi-Linearizability: Relaxedconsistency for improved concurrency,” inInternational Conference onPrinciples of Distributed Systems,2 0 1 0 ,p p .3 9 5 – 4 1 0 .[4] T. A. Henzinger, A. Sezgin, C. M. Kirsch, H. Payer, and A. Sokolova,“Quantitative relaxation of concurrent data structures,”inACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages,2 0 1 3 .[5] A. Haas, M. Lippautz, T. A. Henzinger, H. Payer, A. Sokolova, C. M.Kirsch, and A. Sezgin, “Distributed queues in shared memory:m u l t i c o r eperformance and scalability through quantitative relaxation,” inConf.Computing Frontiers,2 0 1 3 ,p .1 7 .[6] C. M. Kirsch, H. Payer, H. R¨ ock, and A. Sokolova, “Performance,scalability, and semantics of concurrent ﬁfo queues,” inInternationalConference on Algorithms and Architectures for Parallel Processing,2012, pp. 273–287.[7] C. M. Kirsch and H. Payer, “Incorrect systems: it’s not thep r o b l e m ,it’s the solution,” inProceedings of the Design Automation Conference,2012, pp. 913–917.[8] H. Payer, H. R¨ ock, C. M. Kirsch, and A. Sokolova, “Scalability versussemantics of concurrent ﬁfo queues,” inACM Symposium on Principlesof Distributed Computing,2 0 1 1 ,p p .3 3 1 – 3 3 2 .[9] V . Vafeiadis, “Shape-value abstraction for verifying linearizability,” inInternational Conference on Veriﬁcation, Model Checking,and AbstractInterpretation.B e r l i n , H e i d e l b e r g : S p r i n g e r - V e r l a g , 2 0 0 9 , p p . 3 3 5 – 3 4 8 .[10] V . Vafeiadis, M. Herlihy, T. Hoare, and M. Shapiro, “Proving correctnessof highly-concurrent linearisable objects,” inACM SIGPLAN symposiumon Principles and practice of parallel programming.N e w Y o r k , N Y ,USA: ACM, 2006, pp. 129–136.[11] Y . Liu, W. Chen, Y . A. Liu, and J. Sun, “Model checking linearizabilityvia reﬁnement,” inProceedings of the 2nd World Congress on FormalMethods.B e r l i n , H e i d e l b e r g : S p r i n g e r - V e r l a g , 2 0 0 9 , p p . 3 2 1 – 3 3 7 .[12] M. T. Vechev, E. Yahav, and G. Yorsh, “Experience with model checkinglinearizability,” inInternational SPIN Workshop on Model CheckingSoftware,2 0 0 9 ,p p .2 6 1 – 2 7 8 .[13] P. Cern´ y, A. Radhakrishna, D. Zufferey, S. Chaudhuri,and R. Alur,“Model checking of linearizability of concurrent list implementations,”inInternational Conference on Computer Aided Veriﬁcation,2 0 1 0 ,p p .465–479.[14] Y . Yang, X. Chen, and G. Gopalakrishnan, “Inspect: A runtime modelchecker for multithreaded C programs,” University of Utah,Tech. Rep.UUCS-08-004, 2008.[15] U. Salzburg, “Scal: High-performance multicore-scalable data structures.URL: http://scal.cs.uni-salzburg.at/.”[16] S. Burckhardt, C. Dern, M. Musuvathi, and R. Tan, “Line-up: a completeand automatic linearizability checker,” inACM SIGPLAN Conferenceon Programming Language Design and Implementation,2 0 1 0 ,p p .3 3 0 –340.[17] K. Adhikari, J. Street, C. Wang, Y . Liu, and S. Zhang, “Verifying aquantitative relaxation of linearizability via reﬁnement,” inInternationalSPIN Symposium on Model Checking of Software.B e r l i n , H e i d e l b e r g :Springer-Verlag, 2013, pp. 24–42.[18] L. Lamport, “How to make a multiprocessor computer thatcorrectlyexecutes multiprocess programs,”IEEE Trans. Computers,v o l .2 8 ,n o .9 ,pp. 690–691, 1979.[19] J. Aspnes, M. Herlihy, and N. Shavit, “Counting networks,”J. ACM,vol. 41, no. 5, pp. 1020–1048, 1994.[20] W. V ogels, “Eventually consistent,”Commun. ACM,v o l .5 2 ,n o .1 ,p p .40–44, 2009.[21] C. Flanagan and S. Qadeer, “A type and effect system for atomicity,”inACM SIGPLAN Conference on Programming Language Design andImplementation,2 0 0 3 ,p p .3 3 8 – 3 4 9 .[22] A. Farzan and P. Madhusudan, “Causal atomicity,” inInternationalConference on Computer Aided Veriﬁcation,2 0 0 6 ,p p .3 1 5 – 3 2 8 .[23] A. Sinha, S. Malik, C. Wang, and A. Gupta, “Predictive analysisfor detecting serializability violations through trace segmentation,” inFormal Methods and Models for Codesign,2 0 1 1 ,p p .9 9 – 1 0 8 .[24] C. Flanagan and S. N. Freund, “Atomizer: A dynamic atomicity checkerfor multithreaded programs,” inParallel and Distributed ProcessingSymposium,2 0 0 4 .[25] M. Xu, R. Bod´ ık, and M. D. Hill, “A serializability violation detectorfor shared-memory server programs,” inACM SIGPLAN Conference onProgramming Language Design and Implementation,2 0 0 5 ,p p .1 – 1 4 .[26] S. Lu, J. Tucek, F. Qin, and Y . Zhou, “A VIO: detecting atomicityviolations via access interleaving invariants,” inArchitectural Supportfor Programming Languages and Operating Systems,2 0 0 6 ,p p .3 7 – 4 8 .[27] L. Wang and S. D. Stoller, “Runtime analysis of atomicityf o rm u l -tithreaded programs,”IEEE Trans. Software Eng.,v o l .3 2 ,n o .2 ,p p .93–110, 2006.[28] F. Chen and G. Rosu, “Parametric and sliced causality,”inInternationalConference on Computer Aided Veriﬁcation.S p r i n g e r , 2 0 0 7 , p p . 2 4 0 –253.[29] A. Farzan and P. Madhusudan, “Monitoring atomicity in concurrentprograms,” inInternational Conference on Computer Aided Veriﬁcation,2008, pp. 52–65.[30] C. Flanagan, S. N. Freund, and J. Yi, “Velodrome: a soundandcomplete dynamic atomicity checker for multithreaded programs,” inACM SIGPLAN Conference on Programming Language Design andImplementation,2 0 0 8 ,p p .2 9 3 – 3 0 3 .[31] C. Wang, S. Kundu, M. Ganai, and A. Gupta, “Symbolic predictive anal-ysis for concurrent programs,” inInternational Symposium on FormalMethods,2 0 0 9 ,p p .2 5 6 – 2 7 2 .[32] Y . Yang, X. Chen, G. Gopalakrishnan, and C. Wang, “Automatic dis-covery of transition symmetry in multithreaded programs using dynamicanalysis,” inSPIN workshop on Software Model Checking,2 0 0 9 .[33] C. Wang, R. Limaye, M. Ganai, and A. Gupta, “Trace-basedsymbolicanalysis for atomicity violations,” inInternational Conference on Toolsand Algorithms for Construction and Analysis of Systems,2 0 1 0 ,p p .328–342.[34] C. Wang, M. Said, and A. Gupta, “Coverage guided systematic con-currency testing,” inInternational Conference on Software Engineering,2011, pp. 221–230.[35] A. Sinha and S. Malik, “Using concurrency to check concurrency:Checking serializability in software transactional memory,” inParalleland Distributed Processing Symposium,2 0 1 0 .[36] N. Sinha and C. Wang, “On interference abstractions,” inACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages,2 0 1 1 ,pp. 423–434.[37] M. Said, C. Wang, Z. Yang, and K. Sakallah, “Generating data racewitnesses by an SMT-based analysis,” inNASA Formal Methods,2 0 1 1 ,pp. 313–327.[38] C. Wang and M. Ganai, “Predicting concurrency failuresin generalizedtraces of x86 executables,” inInternational Conference on RuntimeVeriﬁcation,S e p .2 0 1 1 .[39] V . Kahlon and C. Wang, “Universal Causality Graphs: A precisehappens-before model for detecting bugs in concurrent programs,” inInternational Conference on Computer Aided Veriﬁcation,2 0 1 0 ,p p .434–449.[40] J. Huang and C. Zhang, “Persuasive prediction of concurrency accessanomalies,” inInternational Symposium on Software Testing and Anal-ysis,2 0 1 1 ,p p .1 4 4 – 1 5 4 .[41] V . Kahlon and C. Wang, “Lock removal for concurrent tracep r o g r a m s , ”inInternational Conference on Computer Aided Veriﬁcation,2 0 1 2 ,p p .227–242.[42] T.-F. Serbanuta, F. Chen, and G. Rosu, “Maximal causal models forsequentially consistent systems,” inInternational Conference on RuntimeVeriﬁcation,2 0 1 2 ,p p .1 3 6 – 1 5 0 .[43] J. Huang, J. Zhou, and C. Zhang, “Scaling predictive analysis ofconcurrent programs by removing trace redundancy,”ACM Trans. Softw.Eng. Methodol.,v o l .2 2 ,n o .1 ,p .8 ,2 0 1 3 .
View publication stats