Querying Sequential Software Engineering Data
Chengnian SunyHaidong ZhangxJian-Guang LouxHongyu Zhangx
Qiang WangxDongmei ZhangxSiau-Cheng Khooz
yUniversity of California, Davis, USA
xMicrosoft Research, Beijing, China
xNational University of Singapore, Singapore
cnsun@ucdavis.edu, khoosc@nus.edu.sg
{haidong.zhang, jlou, honzhang, qiang.wang, dongmeiz}@microsoft.com
ABSTRACT
We propose a pattern-based approach to eectively and e-
ciently analyzing sequential software engineering (SE) data.
Dierent from other types of SE data, sequential SE data
preserves unique temporal properties, which cannot be eas-
ily analyzed without much programming eort. In order
to facilitate the analysis of sequential SE data, we design a
sequential p attern q uery l anguage ( SPQL ), which species
the temporal properties based on regular expressions, and
is enhanced with variables and statements to store and ma-
nipulate matching states. We also propose a query engine
to eectively process the SPQL queries.
We have applied our approach to analyze two types of
SE data, namely bug report history and source code change
history. We experiment with 181,213 Eclipse bug reports
and 323,989 code revisions of Android. SPQL enables us to
explore interesting temporal properties underneath these se-
quential data with a few lines of query code and low match-
ing overhead. The analysis results can help better under-
stand a software process and identify process violations.
Categories and Subject Descriptors
H.2.3 [ Database Management ]: Languages| Query lan-
guages ; D.2.9 [ Software Engineering ]: Management|
Software quality assurance (SQA)
General Terms
Languages, Management
Keywords
sequential data, pattern matching, query, mining software
repository
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
FSE â€™14, November 16â€“22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.1. INTRODUCTION
Over the years of software practice, there is a plethora of
software engineering (SE) data produced by dierent pro-
cesses and tools. These data include source code, bug re-
ports, change logs, metric data, etc. Many organizations are
now maintaining large software repositories and are willing
to mine or even share their SE data to facilitate the exchange
of results and to improve their current practices by learn-
ing from others. The construction of software repositories
is further facilitated by the open-source software movement,
which also oers a vast amount of SE data to the public. The
increase in number and size of software repositories brings
both opportunities and challenges for researchers and prac-
titioners.
There is a great variability in SE data. Many existing
approaches (e.g., [19, 22, 32, 34]) focus on the relational
aspect of SE data and treat SE data as structured data in
a database. Other approaches (e.g., [5, 7, 23, 28, 27, 30,
33, 31]) focus on the textual aspect of SE data and treat SE
data as a set of documents. We nd that many kinds of SE
data also have the sequential nature , which is often displayed
as a sequence of activity records. For example, during the
lifetime of a bug report from its initially creation to nal
close, there is usually a series of status changes. During
the lifetime of a source code le, there is often a series of
revisions. The sequential nature of data provides invaluable
insight into the software maintenance process, and opens up
the possibility of conducting more holistic study of software
projects in ways previously unexplored.
In this paper, we propose a highly-adaptable pattern-
matching approach for eective and ecient query of se-
quential SE data. With our query language SPQL (sequential
pattern q uery l anguage), a user can specify a query describ-
ing the characteristics of sequential SE data. The matching
results can be returned by the SPQL query engine.
Query Language The language is a hybrid of regular ex-
pressions and several constructs from imperative program-
ming languages (i.e., variables, if-statement, assignment state-
ments and function calls). This design choice makes the lan-
guage capable of expressing complex queries, and also easy
to learn, especially for developers with experience on regular
expressions.
Query Engine The query engine is powered by a proposed
extension of non-deterministic automata (NFA) simulation
algorithm that supports variables and actions. The classicalNFA simulation algorithm for regular expression matching
over strings is stateless, that is, no matching state is main-
tained. In contrast, in our engine a user can store necessary
information in variables that can be used later in subse-
quence matching. The query engine is designed indepen-
dent of the sequential data under analysis, and therefore it
is highly adaptable to new data sources.
Our technique can be applied to analyze sequential SE
data such as bug report history and source code change his-
tory. These analysis have real-world motivations. Consid-
ering the following example that was given by a test team
leader in Microsoft during an interview with the authors:
The bug report histories are recorded in bug track-
ing systems, but currently no tool is available to
analyze them. This type of information can be
important. For example, a bug can be reopened
multiple times after it is xed before it is even-
tually closed, and such a bug often indicates a
problematic bug, or the ignorance of the assigned
developers.
There is no easy way for current bug tracking systems
to retrieve such bug reports. Often a user can query bug
reports of which a bug status was changed to the current
value, but cannot query if the bug status was ever changed
to a temporary value in a sequence of revisions.
In our approach, we can write the query in Figure 1, with
one auxiliary variable, three revision events of interest, a
pattern body described in the syntax of regular expressions
(specifying the pattern of \initially resolved, then reopened
one or more times, and nally closed"), and a where clause
specifying that we are only interested in bug reports that
are reopened more than twice.
int counter = 0;
/*an event defines an element of interest
*in a sequence , indicated by the expression
*surrounded by the brackets. */
event resolved (status == "resolved") {}
event reopened (status == "reopened") {
// an action to update the variable
counter = counter + 1;
}
event closed (status == "closed") {}
// the following is the pattern body
resolved reopened+ closed $ where counter > 2
Figure 1: SPQL query to retrieve bug reports which
are resolved rst, then reopened more than twice
and nally closed
Current bug tracking systems do not support this query.
Even if we have direct access to the back-end database, it is
hard for us to express this query in SQL, as the query in-
volves temporal properties among rows of the table, exceed-
ing the expressiveness of SQL. In order to fulll the same
task, we need to write a program to directly interact with
the back-end database. Assume that the revision history of
each report is already read into a list seq, we need to manu-
ally write the following Java code, which implements exactly
the behavior of the SPQL query in Figure 1. Note that the
code is simplied for illustration purpose. Besides the func-
tion match , the whole program should also implement otherfunctions to retrieve the bug reports into memory by execut-
ing SQL statements, and construct a list of revision history
for each bug report.
boolean match(List<Revision> seq) {
int index = -1;
boolean fixed = false ;
while (++index < seq.size()) {
Revision r = seq.get(index);
if(r.field.equals("status")
&& r.new_value.equals("resolved")) {
fixed = true ;
break ;
}
}
// whether the report is fixed before?
if(!fixed) return false ;
int counter = 0;
while (++index < seq.size()) {
Revision r = seq.get(index);
if(r.field.equals("status")
&& r.new_value.equals("reopened")) {
++counter;
}
}
// whether it is reopened more than twice?
if(counter <= 2) return false ;
Revision last = seq.get(seq.size() - 1);
// whether the last status is closed?
return last.field.equals("status")
&& last.new_value.equals("closed");
}
Figure 2: A sample Java program implementing the
query in Figure 1 (partial)
We have implemented the proposed language and its run-
time engine, and applied it to analyze the evolution of 181,213
Eclipse bug reports between 2001 and 2007, and 323,989
code revisions of Android between 2010 and 2012. The case
studies reveal that the proposed approach can enable stake-
holders to investigate complex sequential SE data in a repos-
itory with a few lines of code, and the matching overhead is
low. The results show that the proposed language and tool
can complement the searching functionality of the existing
software repository management systems, and can help im-
prove software engineering practice.
We summarize our contributions as follows:
1. We propose a new pattern-matching based approach
for analyzing sequential software engineering data. We
design a query language SPQL and a matching algo-
rithm for retrieving the data records that satisfy spec-
ied sequential patterns.
2. We implement an ecient runtime engine to support
SPQL , and the retrieval overhead is negligible.
3. We explore the application scenario of the proposed
approach in software development and maintenance
process.
This paper is organized as follows. Section 2 describes nec-
essary background. Section 3 introduces the syntax and the
semantics of the SPQL query language. Section 4 describes
the design of query engine that supports SPQL. Section 5
describes the overview of the tool implementation. Section 6describes the case studies that illustrate the application sce-
narios of the proposed query tool. Section 7 surveys related
work, followed by Section 8 that concludes the paper with
future work.
2. BACKGROUND
Many kinds of SE data exhibit the sequential nature. A
series of revisions can be made to these data. Each revision
may update the values of certain elds in the data records.
We refer to the current value of the data records as a snap-
shot of the evolution history. Specically, the sequential SE
data can be expressed as a series of snapshots,
seq=he1;e2;;eni
whereei(1in) is a snapshot and is sorted in chronolog-
ical order. Notation-wise, we use jseqjto denote the number
of snapshots in seq,seq[i] to denote the i-th snapshot ei, and
seq[i;j] (where 1ijjseqj) to denote the subsequence
ofseqhei;ei+1;;eji.
In this paper, we use two types of SE data, bug report
history and source code change history, to illustrate the pro-
posed query approach.
2.1 Bug Report History
Nowadays, bug tracking systems such as Bugzilla [2] and
JIRA [3] have been widely adopted in software development
and maintenance processes. They enable developers, testers
and users to track the bug status. Initially, when a bug is
found by a tester or user, he/she can le a new report in the
system. If reproducible, the bug is accepted and assigned to
a developer. After the bug is xed, the tester veries and
closes it. All these status transitions are recorded in the
repository. Moreover, stakeholders can update the elds of a
report at any time. During the lifetime of a bug report from
its being initially opened to nally closed, there is usually
a series of such revisions, referred to as evolution of bug
reports. Such history information is an essential indicator
of software process maturity in an organization [14, 13].
Table 1 shows the evolution of the Eclipse Bug Report
#1749. This bug report was originally led on October 11
2001 and went through 7 following-up revisions. Therefore
the history of bug report has 8 snapshots. Each row in the
table represents one snapshot, and the changed elds are
highlighted in bold. For example, in the second snapshot,
the severity of the bug was promoted from normal tocritical
and the priority was promoted from P3 toP1.
Table 1: The evolution history of Eclipse bug report
#1749, containing 8 snapshots
Date Product Comp. Severity Pri. Status
101-10-11 jdt debug normal P3 new
201-11-28 jdt debug critical P1 new
301-11-30 jdt debug critical P1 assigned
401-11-30 platform ui critical P1 assigned
501-11-30 platform ui critical P1 new
601-11-30 platform debug critical P1 new
701-11-30 platform ui critical P1 new
801-12-03 platform ui critical P1 resolved
2.2 Source Code Change History
Software is constantly evolving due to changing user re-
quirements, new product features, bug xes, or refactoring.Changes to software are inevitable. The developers are as-
signed a new feature or a defect to work on upon a change
request. After coding is complete they commit the changes
for integration via a version control system (such as SVN
or Git). During a long period of software evolution, many
developers could be involved in modifying a same le [10].
Table 2 shows a segment of the revision history of the
le core/java/android/webkit/WebView.java in Android Git
repository. This le went through 5 revisions. Each row rep-
resents a revision to the le. Note that the table only shows
three attributes of each revision and the other attributes are
hidden due to space constraint.
Table 2: A segment of the revision history of Web-
View.java in Android
Date Committer Log
110-01-03 Leon Scroggins If the DOM changes texteld ...
210-01-03 Nicolas Roard layers support
310-01-04 Cary Clark extract selected text from ...
410-01-05 Leon Scroggins Show label information as ...
510-01-06 Leon Scroggins info only when accessing a ...
3. QUERY LANGUAGE
We design a s equential p attern q uery l anguage ( SPQL ), to
query sequential software engineering data. In this section
we introduce the syntax of SPQL and its dynamic semantic
model.
3.1 Language Syntax
The SPQL language is designed to be similar to regular ex-
pression, and the underlying matching is performed based on
non-deterministic nite automata (NFA). However, the ex-
pressiveness of regular expressions is limited as the matching
is simple character-equality testing and stateless. In order to
meet the requirements of SE data analysis, our pattern lan-
guage incorporates complex matching predicates, and also
introduce global variables, which can save necessary infor-
mation during matching and such information can be used
in the later matching tests.
Generally, a pattern denition consists of the following
four components,
1.Variable Declaration . Variables are globally acces-
sible in all matching predicates. They can be used to
store necessary information or to evaluate matching
predicates.
2.Event Denition . Each event denition species the
condition under which a snapshot is matched, and the
actions to update global variables if the matching is
successful.
3.Pattern Body . The body denes the sequential pat-
tern. The syntax is similar to regular expressions.
4.Where Clause . This clause species the last crite-
rion whether the SE data evolves in the given pattern.
After matching the pattern body against a sequence of
snapshots, the global variables are updated with new
values. This clause tests whether the valuation of the
global variables satises a certain condition.
Figure 3 displays the Backus-Naur Form (BNF) grammar
of our query language. As shown in the rule htypei, thehtypei ::= ` int'j`string 'j`bool'j`float '
j`list'j`set'
hvardecli::=htypeihvarnamei`='hexpi`;'
heldi ::= the attributes dened in the schema
harglisti::= (hexpi(`,'hexpi)*)?
hlistexpi::= ` ['harglisti`]'
hsetexpi::= ` {'harglisti`}'
hexpi ::=hintijhstringijhboolijhoatijhchari
j hlistexpijhsetexpi
j heldijhvarnamei
j huopihexpijhexpihbopihexpi
j hfunc namei`('harglisti`)'
hstmti ::=hvarnamei`='hexpi`;'
heventi::= ` event 'hevent namei`('hexpi`)'
`{'hstmti* `}'
hregexpi::=hevent nameij`.'jhregexpihkleenei
j hregexpihregexpij`('hregexpi`)'
j hregexpi`|'hregexpi
hkleenei::= ` *'j`+'j`?'
hwherei::= ` where 'hexpi
hpatterni::=hvardecli*heventi+
`^'?hregexpi`$'?
hwherei?
Figure 3: BNF Grammar of SPQL Language
language supports four primitive types and two aggregate
types of data, types frequently used in software engineering
data, matching predicates and statistics computation. A
variable declaration hvardeclispecies the type and the
name of a variable with its initial value. An expression hexpi
evaluates to a value from a string/boolean/number literal,
a read from a variable, a eld of a snapshot, compositional
computation over expressions with binary operators hbopi
(e.g., `+', ` ', `', `>') or unary operators huopi(e.g., `!'
and ` '), or a function call.
The language is independent of domain-specic snapshots.
The production rule heldiis a list of attribute names de-
ned in the provided schema le.
An eventheventirepresents a specic snapshot of inter-
est in sequential SE data, and species the following two
components,
Matching Predicate is the expressionhexpienclosed
within the brackets, the condition under which a snap-
shot is matched.
Post Action . Ifhexpiis evaluated against a snapshot
totruethen the statements within the curly braces are
executed subsequently. We refer to these statements
aspost action , and they update the variables according
to the current values of global variables and the elds
of the snapshot under matching.
The pattern body follows the syntax of regular expressions
to specify temporal properties. A pattern body can be:asingle event
hregexpihregexpi,concatenation of pattern bodies
hregexpijhregexpi,alternative between two pattern
bodies
hregexpihkleenei,Kleene structures
Moreover, it supports the operator `^' to force the matching
to start from the very beginning of the data, `$' to force the
matching to end at the last snapshot of the data, operator
`.' to match any single snapshot. It also supports `?', `+'
and `' to postx a pattern p:p? to match zero or one p,p+
to match one or more p, andpto match zero or more p.
int start_day = 0;
int end_day = 0;
// event definitions
event non_p1 (priority != "P1") {}
event first (priority == "P1") {
start_day = date;
}
event other (priority == "P1") {}
event last (priority == "P1"
&& status == "closed") {
end_day = date;
}
^ non_p1* first other* last $ //pattern body
where (end_day - start_day) <= 10 //where clause
Figure 4: A query to retrieve high-priority bug re-
ports xed within 10 days
Figure 4 shows an example query. It retrieves bug re-
ports, which are xed within 10 days after their priorities
become the highest level P1. Given an evolution history of
a bug report h=he1;e2;;eni, this pattern requires the
following:
1. the matching should start from the rst snapshot e1
ofh(indicated by \^"),
2. zero or more snapshots from the start of h(i.e., none or
h[1;i] where 0<i<jhj) can be with non- P1 priority
(indicated by \non p1*"),
3. the rest of the snapshots must be with P1 priority and
the last snapshot must be closed (indicated by \rst
other* last$")
4. the global variable start daystores the date when the
bug report is assigned with P1, and the variable end day
stores the date when the bug report is closed.
5. the where clause species that the time span between
the date when the report becomes P1 priority and the
date when it is closed should not exceed 10 days.
3.2 Dynamic Semantic Model
In order to facilitate describing the execution model, we
rst formulate necessary concepts for matching predicates,
post actions and where clause dened in pattern queries.
Given a pattern query q, let Pred denote the set of match-
ing predicates, Actdenote the set of post actions dened in
the event denitions, and where denote its where clause.Definition 1 (Valuation). Lethv1;;vnibe the list
ofnvariables dened in q, and the cartesian product of the
variable domains is denoted as D(q),
D(q) =dom(v1)dom(vn)
then a valuation of qis an element ofD(q)
hval1;;val ni2D (q)
where8i2[1;n],dom(vi)denotes the domain of variable vi
andvali2dom(vi).
Note that a valuation is not a value of a single variable. It
is a vector dened over the whole set of global variables,
and an element in the vector is a value corresponding to a
distinct variable.
Let  denote the set of snapshots, the matching predicates
pred2Pred can be formally dened as
pred : D(q)!ftrue;falseg(Matching Predicate)
where true represents that a snapshot s2 matches the
predicate pred under the variable valuation v2D(q),false
otherwise. Similarly, a post action act2Actcan be formally
dened as
act: D(q)!D(q) (Post Action)
which takes as input a snapshot and a variable valuation
and returns a new valuation after computation. The where
clause can be formalized as
where :D(q)!ftrue;falseg (Where Clause)
testing whether a variable valuation satises a criterion.
The dynamic semantics of our query language is based on
the interpretation of NFA. Each pattern query is compiled
into an execution model. The pattern body is translated
into an NFA by Thompson's method [29], and the match-
ing predicates and post actions in the event denitions are
compiled as the labels of the transitions.
Definition 2 (NFA). The NFA corresponding to the
pattern body is dened as a tuple F=hQ;E;;;;'i,
where
Q: a set of vertices, referred to as states
E:QQ: a set of directed transitions between states
:E!Pred[fg, a function assigning a matching
predicate in Pred to a transition. An transition can
be taken without consuming a bug report snapshot from
an evolution history. It is introduced when we compile
pattern bodies containing alternatives orkleene struc-
tures by Thompson's method [29].
:E!Act[f"g, a function associating each tran-
sition with an action. An "action simply returns the
input valuation without modication.
: the start state of this NFA.
': the accepting/nal state of this NFA.
The special symbols `^' and `$' are not encoded into the
model, but handled in Algorithm 1.
Figure 5 shows the execution model compiled from the
query in Figure 4. Graphically, we represent a transition as(spred   !
actt), wheresis the source state, tis the sink state,
pred above the arrow is the matching predicate, and act
below the arrow is the post action. If pred is evaluated to
true, then the action actis executed; otherwise not. If pred
oractis empty, we just leave it blank.
Figure 5: The NFA compiled from the query in Fig-
ure 4. This NFA is associated with two variables
and one where clause. The labels for predicates or
"post actions are omitted.
Similar to the standard interpretation of NFA with strings,
given a sequence of bug report snapshots he1;e2;;eni, we
interpret the NFA from the start state with the sequence,
and at each non- transition ( spred   !
actt) we consume a snap-
shotefrom the sequence and test whether the current valu-
ationvof global variables and ecan satisfy pred(e;v). If yes,
we set the global variable valuation with act(e;v). During
matching, if the nal state 'is reached and the valuation
of global variables satises the where clause, we report that
the given snapshot sequence matches the pattern query.
4. QUERY ENGINE
This section describes the algorithm underneath the run-
time engine for implementing query matching testing. The
proposed matching algorithm is based on the concept of NFA
simulation. Nonetheless dierent from the classic NFA sim-
ulation for regular expressions over simple strings, SPQL
queries support global variables which can not only partici-
pate in the matching predicates but also be updated during
matching. Section 4.2 describes the details of this pattern
matching algorithm, and Section 4.3 analyzes its time and
space complexity.
4.1 Main Algorithm
Algorithm 1 lists the main algorithm for the pattern query
matching. Given a set of sequential SE data seqand a pat-
tern query q, this algorithm returns true ifseqmatchesq.
It rst compiles the query into an NFA nfa, and then del-
egates the matching test to the function Match dened in
Algorithm 2. Generally, Match tests whether a subsequence
seq[i;j] (where 1ijjseqj) can be accepted by nfa.
Ifqhas been specied that the matching should start from
the head of seqwith the symbol `^', then Match is called at
line 4 with the whole seq. Otherwise, the algorithm iterates
through seqat line 5, and invokes Match for each subse-
quence seq[i;jseqj] until it nds a match.
The queryqis likely specied with the symbol `$' that the
matching must end at the tail of seq, i.e., matchingEnd , and
this part is handled in the function Match .Algorithm 1: Main Algorithm
Input :seq, the sequential SE data
Input :q, the pattern query
Output :trueifseqmatchesq,false otherwise
1letnfadenote the NFA compiled from the query q
2letmatchingEnd denote whether qhas `$'
3 ifqhas `^' then
/* matching starts from the head of seq */
4 return Match (nfa;seq;matchingEnd )
5 fori:= 1 tojseqjdo
6 if Match (nfa;seq[i;jseqj];matchingEnd )then
7 return true
4.2 Matching Algorithm
In classic regular expressions, each pattern is rst trans-
lated into an NFA before matching. Due to the nondeter-
minism of NFA, there are three ways to test whether a string
can be accepted by the NFA. The rst way is to convert
an NFA to a deterministic nite automata (DFA), as for a
character at each state in DFA there is at most one avail-
able transition to take as the next step. The second way is
backtracking, such as the implementation of regular expres-
sion in Perl programming language. It searches for a valid
path from the start state of NFA to the nal state. If a
path becomes not feasible, it backtracks to a previous state
and branches to another path. Since the number of paths in
an NFA can be exponential, this implementation may suf-
fer from severe performance overhead. The last approach is
multiple-state simulation of NFA proposed in [29]. It main-
tains a setSof reached states. Initially Scontains the start
state. GivenSand a character, the algorithm searches the
NFA for a set S0of next states reachable from the states in
S. In the next iteration, the algorithm uses S0as the start-
ing point to search for the reachable states. It repeats this
process until the accepting state is reached. Compared to
the backtracking approach, as the multiple-state simulation
does not need to maintain a path, it is much ecient. Sup-
pose the length of the string is mand the number of states
in NFA isn, then the time complexity is O(mn).
In our runtime engine, we opt for the simulation approach
mainly for its eciency. The reason that we do not choose
the rst approach is the diculty in converting the NFA
ofSPQL to DFA. Dierent from regular expressions, our
query language involves complex matching predicates, and
it is possible that two matching predicates may partially
overlap. For example, say there is one NFA state with two
outgoing matching predicates , x>0 andx<2. To convert
this NFA, we need to analyze these two predicates and sep-
arate them into three disjoint predicates x0, 0< x < 2
andx2. This separation process is complex and expen-
sive as a matching predicate can be a compound of multiple
predicates. Moreover, a matching predicate can be associ-
ated with a post action, and this further complicates the
DFA approach.
Algorithm 2 implements the core matching algorithm. It
takes as input an NFA nfacompiled from the query, a list
of report snapshots and a boolean value matchingEnd indi-
cating whether the matching should end at the tail of the
list. If matchingEnd is true, this algorithm returns true if
the whole listcan be accepted by nfa. If matchingEnd isAlgorithm 2: Match (nfa;list;matchingEnd )
Input :nfa, NFA compiled from the query
Input :list, a list of snapshots
Input :matchingEnd , whether to match the end of list
Output : whether listmatchesq
1prev :=f(;init)g
/* whereis the start state of nfaand init is
the initial valuation of global variables */
2 fori:= 1 tojlistjdo
3 snapshot :=list[i]
4 current :=?
5 foreach (state;valuation )in prev do
6 trans := the set of non- transitions reachable
from state via 0 or more transitions
7 foreach spred   !
acttin trans do
8 if pred(snapshot;valuation ) =false then
/*snapshot and valuation dissatisfy
the matching predicate pred */
9 continue
10 valuation0:=act(snapshot;valuation )
11 current :=current[f(t;valuation0)g
12 if t6='_:where (valuation0)then
/*tis not final state or where
clause is not satisfied */
13 continue
/*tis the final state and where
clause is satisfied */
14 if matchingEnd then
15 if i=jlistjthen return true
16 else
17 return true
18 prev :=current
19 return false
false, it returns true if there exists a subsequence list[1;i]
(i1) which can be accepted by nfa.
As aforementioned, the multiple-state simulation in reg-
ular expression matching maintains a set of reached NFA
states. Dierently this algorithm maintains a set of pairs, as
our approach supports global variables. In particular in each
pair ( state;valuation ), the rst element is an NFA state, and
the second element is a valuation of global variables. A pair
means that there exists at least one path from the start state
to the state, such that the list of post actions associated
to this path updates the global variables to the valuation .
The set prev declared at line 1 is stores the reached state-
valuation pairs. Initially, it only contains the pair ( ;init)
whereis the start state of nfaand initis the initial valua-
tion of global variables. The loop at line 2 iterates through
thelistfrom the head to the tail and advances the matching
innfa. The set current declared at line 4 is the set storing
the next state-valuation pairs by consuming the snapshot
list[i], initially ?. The loop at line 5 implements the logic
to propagate current from prev. After the propagation is
done, the set prev iscleared and assigned with the content
ofcurrent at line 18 for the next iteration of propagation.
The following generally describes the process to propagate
current . For each pair ( state;valuation ) inprev (i.e. line 5),the algorithm searches nfato collect all the non- transi-
tions, which are reachable from the state via zero or more
transitions. For each spred   !
acttof such transitions, if the
current snapshot and the variable valuation can satisfy the
matching predicate pred, then we compute a new variable
valuation valuation0by executing the associated post action
actover snapshot and the old valuation . (i.e. line 10).
4.3 Complexity Analysis
This section analyzes the complexity of Algorithm 2. Given
a sequence listof bug report snapshots, a SPQL queryqand
the NFA nfacompiled from q, we use the symbols in Table 3
to facilitate the analysis of time and space complexity.
Table 3: Symbols for Complexity Analysis
L the length of list,L=jlistj
m the number of non- transitions in nfa
D(q)as dened in Denition 1, it denotes the set of all
possible valuations for variables in the query q
c We assume that for each NFA state, it has a con-
stant number c>0 of reachable non- transitions
via 0 or more transitions, i.e.,jtransj=cat
line 6. In the worse case, c=m.
Based on the loop at line 5, for each pair in prev, it is pos-
sible that the cnon-transitions in trans at line 7 generate
cdistinct state-valuation pairs. Assuming prev hasxpairs,
then after the loop at line 5, prev will have (cx) pairs.
Initially, the set prev contains only 1 element at line 1. For
the rst snapshot in list,prev grows to (c1) elements. For
the second snapshot, prev grows toc2elements. Then c3,
c4,and for the last snapshot, prev hascLelements in
the worst case. The total number of pairs ever in prev is
O(c+c2++cL). Hence, the time complexity is O(L)
whenc= 1 and isO(cL) whenc>1.
The space complexity is O(cL), which is the maximum size
of the set prev. As each element in prev is a pair of an NFA
state and a valuation, the size is also bounded by mD(q).
Again, similar to time complexity, the space complexity is
also manageable.
5. TOOL IMPLEMENTATION
We have implemented the proposed language SPQL and
the runtime engine in Java. Figure 6 displays the overall
framework of our tool. Its core is the query engine, which
accepts as input SPQL queries from users, searches the un-
derlying databases, and returns the matching results to the
users.
The tool is designed to be independent of specic SE data
sources, and is adaptable to new data sources and applica-
tion domains (e.g., behavior logs). When applying SPQL
to a domain, users only need to prepare the following two
components:
Schema, which describes the attributes of data in a
domain. Each attribute has an associated type and
name. For example, the schema of bug report includes
creation date, product, severity, priority, etc.
Adaptor: The query engine abstracts and models data
as sequences of snapshots. An adaptor is an interme-
diate layer between this abstraction and the domain-
specic database. It allows the engine to access the
Figure 6: The overall framework of our tool
database without knowing the details and design of the
database. The adaptor must be implemented consis-
tently with the corresponding schema. That is, when
the adaptor converts a data record in the database
into a snapshot in a sequence, all the attributes of the
snapshot must conform to the schema.
6. APPLICATION SCENARIOS
In order to evaluate the eectiveness and eciency of the
proposed approach in querying dierent types of SE data,
we describe two studies in this section and show how the
proposed approach can be used to accomplish them.
The case studies are conducted on a laptop with Intel Core
i7 @ 2.70GHz and 8 Gb memory.
6.1 Detecting Violations in Bug Management
Process
In this task, we use SPQL to express several violation pat-
terns in the bug management process. These violation pat-
terns are learnt from historical process execution data using
a contrasting pattern mining algorithm [26]. They are mean-
ingful to the bug management process of a specic commer-
cial bank introduced in [14, 13]. However, we believe that
even though they may not be deemed as anomalous to bug
management processes of other organizations, they can still
provide some hints to further improve the process quality.
Moreover, our query language is general, and stakeholders
can always deploy their own organization-specic violation
patterns to monitor their bug-handling process.
In this study, we collect the Eclipse bug reports from 2001
to 2007. For each bug report, its evolution history is recov-
ered by crawling its modication history page. After remov-
ing the reports with no revision history or required elds
(product ,component ,severity etc.), we get 181,213 bug re-
ports in total.
Table 4: Distribution of Evolution History Length
Range [0;5) [5;10) [10;20) [20;30) [30;40]
Number 138903 39652 2619 36 3
Percent. 76.65% 21.88% 1.45% 0.02% 0%
Table 4 shows the statistics on the number of bug report
snapshots. The rst row is the range of number, the secondrow is the total number of bug reports within that range,
and the last row is the percentage. The results show that
around 23.35 % bug reports' status have been updated more
than 5 times (5 snapshots). The maximum number of bug
report snapshots is 40.
6.1.1 Closed Right After Assigned
When a bug report is assigned to a developer, the devel-
oper needs to set the report status to resolved before closes
it. A violation pattern is that a bug report is closed right
after it is assigned [14, 13] without any other status in be-
tween, which is not allowed by the Eclipse Bugzilla Usage
Guide [1] either. We use the following query to fulll this
task.
event closed(status == "closed") {}
event assigned(status == "assigned") {}
assigned closed
This query takes 0.78 second to nish, and returns 4 match-
ing reports. We manually read the returned bug reports and
conrmed their validity. For example, Bug Report #173785
was initially new, then assigned to a developer and later
directly closed without being resolved. According to the
Eclipse Bugzilla Usage Guide [1], there should exist at least
one state of resolved before the bug is closed. Therefore, the
handling process of these 4 bug reports violates the guide-
lines.
We could integrate our tool to a bug tracking system to
automatically detect the violation patterns in a bug repos-
itory. Such an integration can also automatically alert the
users when they try to directly close the bug without resolv-
ing it, thus avoiding a process violation. This could be an
interesting application of our approach in future.
6.1.2 Product Change Analysis
In this task, we analyze the following problem: how many
bug reports' Product eld is changed? The Product eld
is important for bug triage [5, 17]. It is set by the bug
reporter and supposed not to change frequenly over time.
However, the reporter may not thoroughly understand the
bug at the beginning, and may assign the bug to a wrong
product. When developers get to know the bug better, they
can change this eld accordingly. We use the following query
to fulll this task.
string prev_product = "";
event first (true) {prev_product = product;}
event change (prev_product != product) {
prev_product = product;
}
event no_change(prev_product == product){}
^first (no_change* change* no_change*) *$
Table 5: Distribution of Product Changes
Changes No. Pct. Changes No. Pct.
0 171489 94.63% 5 13 0.01%
1 8503 4.69% 6 1 0
2 977 0.54% 7 0 0
3 182 0.10% 8 1 0
4 47 0.03% >8 0 0The distribution of product changes returned by this query
is displayed in Table 5. The column Changes shows the num-
ber of changes made to the product eld, the column No.
shows the absolute number of reports with the correspond-
ing changes, and the column Pct. shows the percentage.
The results show that around 5.5 % of bug reports (9,724)
have their Product status changed at least once.
6.2 Analyzing File Revision History
In this section, we show how SPQL can be applied to an-
alyze le revision history. Previous empirical studies found
that when more people work on a le, it has more failures [9,
10]. Thus it is interesting to know the number of people who
have ever touched a particular le. This could help project
teams identify potential problematic code and design better
source code change policies.
Table 6: Distribution of Revision History Length
Range [0;10) [10;20) [20;30) [30;40) [40;1)
Number 266448 7138 3654 1570 4177
Percent. 94.16% 2.52% 1.29% 0.55% 1.48%
We collected the revision history of the Android source
code les between 2010 and 2012. There are 282,987 les,
and each le is associated with a sequence of revisions. In
total, there are 323,989 code revisions. Table 6 shows the
statistics of the length of each le revision history. There are
5.84 % les that have gone through more than 10 revisions.
We apply SPQL to nd out which les are revised by mul-
tiple developers within a period of time. The following query
searches for the Android les that are modied by more than
10 developers within a month. The variable authors stores
the committer names and the where clause tests whether the
retrieved segment of the le revision sequence satises the
criterion.
int first_day = 0;
int last_day = 0;
set authors = {};
event first_event(true) {
first_day = committer_date;
authors = add(authors, committer);
}
event other_event(true) {
last_day = committer_date;
authors = add(authors, committer);
}
first_event other_event+
where (last_day - first_day) < 31
&& size(authors) > 10
It takes 43 seconds to execute this query, and 14 les
are returned, including the le WebView.java in Table 2.
Compared to the experiments on Eclipse bug report evolu-
tion, querying Android le revision history takes longer time.
This is because of the larger amount of the le revision data.
Figure 7 shows the details of the runtime performance.
The x-axis is the length of the revision sequences, and the y-
axis is the average time taken to match the query against the
sequences. From the plot, we can draw the conclusion that in0 200 400 600 800 1;0001;20005001;000
Length of SequencesRuntime (ms)
Figure 7: Runtime (millisecond) of matching w.r.t
length of revision sequences
general, the runtime performance increases with the length
of sequences, and the maximum time is around 1 second
even for sequences containing more than 1,000 snapshots.
6.3 Discussions
Our language is a general language that can be applied
to many application scenarios. We have shown how SPQL
can be used to analyze temporal properties beneath the bug
report and le revision data. All the queries are concise,
and most of them are within 10 lines of code. The follow-
ing discusses how SPQL is related to the SQL-based and
programming-based approaches.
SQL. The backend of a bug repository is a relational database.
Assume we have direct access to the backend database, we
could perform queries in SQL. However, we do not believe
this is a good solution. First, as illustrated by Figure 1, not
all queries, especially those involving temporal properties,
can be expressed in SQL. Second, the bug tracking system
needs to expose the implementation details to the user and
the users are required to master advanced SQL features such
as table joins and group clauses.
Programming-based approach . All of the queries de-
scribed in this paper can be answered via programming.
However, it could cost much more time than writing a short
SPQL query. For example, the program in Figure 2 is much
longer than the SPQL query in Figure 1. Our approach pro-
vides users a simple and lightweight method for answering
complex queries.
6.4 Threats to Validity
Our case studies are subject to two threats to validity.
Internal Validity . The rst is threat to internal valid-
ity, which is the possible aws in the implementation of
theSPQL runtime engine. To minimize this threat, we
rst wrote and executed considerable unit and system test
cases to explore dierent aspects of the runtime engine. Sec-
ond, in addition to the queries used in this paper, we also
wrote other queries to investigate bug report history. Lastly,
we implemented a variant of the matching algorithm Algo-
rithm 2, specially optimized for queries without variables.
This variant runs faster, and also serves as a reference to
check the correctness of the implementation of Algorithm 2.
External Validity . Our empirical evaluation is subject
to threat to external validity, with regard to the concern
that the experimental results might not generalize to other
queries or datasets. Regarding the runtime, as the evolution
history of a bug report in the Eclipse repository is usuallynot long, our engine can respond quickly within 2 seconds.
The experiment on Android le revision history takes longer
time, which is mainly due to the longer sequences and the
retrieval of all qualied segments within a sequence. We be-
lieve this could be alleviated by conning the length of a seg-
ment to search, as people are mostly interested in revisions
within a nite interval of time. The runtime performance
also depends on the complexity of queries.
7. RELATED WORK
This section surveys three lines of research related to our
work: querying software repository, software process evalu-
ation, and program matching and monitoring.
7.1 Querying Software Repository
Many software repository management tools provide users
with searching functionalities. For example, in Bugzilla [2]
and JIRA [3], a user can specify predicates on elds in bug
reports and the two systems return the bug reports satis-
fying the conditions to the user. A predicate could be like
"the eld summary should contain a specic word" or "the
eld product should be a specic value". Both systems also
provide support for retrieving bug reports with evolution
history predicates. Especially JIRA has an advanced and
expressive query language JQL [4] to retrieve bug reports
with predicates on revision histories. For example, JQL has
a keyword\ was"to retrieve bug reports which currently have
or previously had the specied value for the specied eld.
The other keyword \ changed " is used to retrieve bug reports
having a value which had been changed for the specied
eld.
From an evolutionary perspective, the expressiveness of
JQL is still limited. It only supports querying the modi-
cation in a single bug report revision, but cannot capture
temporal properties involving multiple revisions, such as the
analysis task in Figure 1. Moreover, it does not support
variables in queries, and therefore it is impossible to collect
information during matching for complex analysis tasks.
In contrast, our query language SPQL supports global
variables and is able to express complex temporal patterns
involving multiple revisions. The variables and the where
clause make SPQL capable of fullling considerable types
of analysis tasks, as shown in our case studies. Regarding
the implementation, JQL translates queries into SQL state-
ments and uses its database system as the runtime engine,
whereas SPQL bases its runtime engine on NFA to capture
temporal properties in a sequence of revisions. However,
SPQL is not a replacement but a good complement of JQL.
We believe that incorporating SPQL into the current bug
tracking systems will further improve their searching func-
tionalities.
Kenyon is a system that extracts source code change his-
tories from SCM systems such as CVS and Subversion [8].
Kenyon automatically checks out the source code for each
revision and extracts change information such as the change
log, author, change date, etc. Kim et al. proposed TA-
RE as an exchange language for mining software reposi-
tories [19]. It is envisioned that TA-RE can support the
representation and integration of software change, transac-
tion and project data mined from SCM (software cong-
uration management) systems. Researchers have also pro-
posed semantic web based approaches to integrate and query
software engineering data collected from dierent softwarerepositories [20, 18]. However, the above related work does
not provide features for users to perform temporal properties
related queries. Hindle and German [16] proposed SCQL, a
rst-order temporal logic based query language for source
control repositories. SCQL is able to represent the temporal
relationships such as \before" and \after". SCQL requires a
formal model of source control repositories, while our SPQL
species the temporal properties using regular expressions.
SPQL is also enhanced with variables and statements to
store and manipulate matching states.
In particular, our work is dierent from DebugAdvisor [6]
and BOA [15]. In DebugAdvisor, when a developer is diag-
nosing a bug, he/she can issue a fat query containing natu-
ral language description of the bug, core dumps, execution
traces etc. to the system, and the system returns all the
associated artifacts including patches of similar bugs which
have been xed before. In this way, the developer may nd
a clue or hint quickly to solve the bug. BOA is a language
and infrastructure to ease the analysis of software reposi-
tories. Users can write small BOA programs to implement
complex analysis tasks in research on software repository
mining. Similar to these work, our work also proposes a
language and tool for querying software repository. How-
ever, we focus more on the temporal properties and enable
users to analyze sequential SE data.
7.2 Software Process Evaluation
Chen et al. [14, 13] propose a machine learning approach
to evaluating a software defect management process. In de-
tail, the lifetime of a bug report corresponds to an execu-
tion of defect management process, and such an execution
is represented as a sequence of status transitions of the bug
report. Based on the process specication and process eval-
uators' expertise, each execution is classied as normal or
anomalous . Their approach rst learns a binary classica-
tion model from the historical evaluation results, and then
applies the model to classify future process executions. Sun
et al. [26] further improves this approach by mining explicit
evaluation rules from evaluation history. Each rule is ca-
pable of explaining why a process execution is evaluated as
normal oranomalous .
Our query language can be used to express the mined
evaluation rules as violation patterns, which can be deployed
to monitor the running process execution. If an execution
matches a violation pattern, the defect process monitor can
inform stakeholders of the anomalous state of the execution.
7.3 Program Matching and Monitoring
A line of remotely related research is program matching
and monitoring. Brunel et al. [11] propose an extension to
computation tree logic with variables and use this logic ex-
tension to match code snippets in system code of Linux in
order to perform collateral code evolutions [25]. Martin et
al. [21] propose Program Query Language to check whether
runtime behavior of an application conforms to specied de-
sign rules. Meredith et al. [24] propose to use parametric
context free grammars to express desired program behaviors,
and base the runtime monitor on LR(1) parsing algorithm
to check property conformance.
Our work is dierent from these studies. First the ap-
plication domains are dierent. Second, the declaration of
variables in SPQL is more exible, and the variables can
be used to aggregate information. But those variables usedin these studies are mainly for selecting runtime events of
interest.
8. CONCLUSIONS AND FUTURE WORK
Many types of software engineering data have the sequen-
tial nature and preserve temporal properties. In this paper,
we propose a pattern-based approach to eectively and e-
ciently analyzing sequential software engineering data. We
have presented a query language SPQL as well as the as-
sociated query engine. We have shown that the proposed
approach can be used to analyze dierent types of sequen-
tial SE data, including bug evolution, source code revisions,
and user logs. The analysis results can help users better
understand a software process and identify violations.
There are many interesting directions we would like to
explore in future work. For example:
Parametric Queries . In a parametric query, a user can use
parameters in initial values of variable declarations, match-
ing predicates, post actions and where clauses. Before exe-
cuting the query, the user instantiates the parameters, and
the parametric query becomes non-parametric. With this
feature, a category of analysis tasks can be further simpli-
ed by varying parameters.
More Query Languages . It would be interesting to sup-
port more types of query languages. Similar to [12], we can
allow users to write queries in dierent logics. For example,
a query can be written in regular expressions, linear tem-
poral logic, computation tree logic or even more expressive
context free grammars. Due to dierent degrees of expres-
siveness and dierent design purposes of these logics, this
feature will provide users with more freedom for expressing
their intentions.
Intgeration . Our approach can be integrated into existing
bug tracking systems and version control systems to help
users identify problems in software development and main-
tenance process.
User Studies . Although SPQL is designed to be a lightweight
query language and the tool is designed to be adaptable to
new data sources, the usability of the language and tool
should be evaluated. In future, we will perform user stud-
ies to further evaluate the eectiveness of the proposed ap-
proach in practice.
9. ACKNOWLEDGMENTS
We are grateful to Dr. Shao Jie Zhang at Singapore Uni-
versity of Technology and Design for her insightful comments
on the initial draft. We also thank the anonymous reviewers
for their valuable comments and suggestions.
10. REFERENCES
[1] Eclipse Bugzilla Usage Guide. http://wiki.eclipse.
org/Development_Resources/HOWTO/Bugzilla_Use ,
Aug. 2013.
[2] Bugzilla. http://www.bugzilla.org/ , Aug. 2013.
[3] Jira. https://www.atlassian.com/software/jira ,
Aug. 2013.
[4] JIRA Query Language. https://confluence.
atlassian.com/display/JIRA/Advanced+Searching ,
Aug. 2013.
[5] J. Anvik, L. Hiew, and G. C. Murphy. Who Should
Fix This Bug? In ICSE , pages 361{370, 2006.[6] B. Ashok, J. Joy, H. Liang, S. K. Rajamani,
G. Srinivasa, and V. Vangala. DebugAdvisor: A
Recommender System for Debugging. In ESEC/FSE ,
pages 373{382, 2009.
[7] N. Bettenburg, S. Just, A. Schr oter, C. Weiss,
R. Premraj, and T. Zimmermann. What Makes a
Good Bug Report? In ESEC/FSE , pages 308{318,
2008.
[8] J. Bevan, E. J. Whitehead, Jr., S. Kim, and
M. Godfrey. Facilitating Software Evolution Research
with Kenyon. In ESEC/FSE , pages 177{186, 2005.
[9] C. Bird, N. Nagappan, P. Devanbu, H. Gall, and
B. Murphy. Does distributed development aect
software quality?: An empirical case study of windows
vista. Commun. ACM , 52(8):85{93, Aug. 2009.
[10] C. Bird, N. Nagappan, B. Murphy, H. Gall, and
P. Devanbu. Don'T Touch My Code!: Examining the
Eects of Ownership on Software Quality. In
ESEC/FSE , pages 4{14, 2011.
[11] J. Brunel, D. Doligez, R. R. Hansen, J. L. Lawall, and
G. Muller. A Foundation for Flow-based Program
Matching: Using Temporal Logic and Model
Checking. In POPL , pages 114{126, 2009.
[12] F. Chen and G. Ro su. Java-MOP: A Monitoring
Oriented Programming Environment for Java. In
TACAS , pages 546{550, 2005.
[13] N. Chen, S. Hoi, and X. Xiao. Software Process
Evaluation: a Machine Learning Framework with
Application to Defect Management Process. Empirical
Software Engineering , pages 1{34, 2013.
[14] N. Chen, S. C.-H. Hoi, and X. Xiao. Software Process
Evaluation: A Machine Learning Approach. In ASE,
pages 333{342, 2011.
[15] R. Dyer, H. A. Nguyen, H. Rajan, and T. N. Nguyen.
Boa: A Language and Infrastructure for Analyzing
Ultra-Large-Scale Software Repositories. In ICSE ,
pages 422{431, 2013.
[16] A. Hindle and D. M. German. Scql: A formal model
and a query language for source control repositories.
InProceedings of the 2005 International Workshop on
Mining Software Repositories , MSR '05, pages 1{5,
New York, NY, USA, 2005. ACM.
[17] G. Jeong, S. Kim, and T. Zimmermann. Improving
Bug Triage with Bug Tossing Graphs. In ESEC/FSE ,
pages 111{120, 2009.
[18] C. Kiefer, A. Bernstein, and J. Tappolet. Mining
software repositories with isparol and a software
evolution ontology. In Proceedings of the Fourth
International Workshop on Mining Software
Repositories , MSR '07, pages 10{, 2007.
[19] S. Kim, T. Zimmermann, M. Kim, A. Hassan,
A. Mockus, T. Girba, M. Pinzger, E. J. Whitehead,
Jr., and A. Zeller. Ta-re: An exchange language for
mining software repositories. In Proceedings of the2006 International Workshop on Mining Software
Repositories , MSR '06, pages 22{25, 2006.
[20] Y.-F. Li and H. Zhang. Integrating software
engineering data using semantic web technologies. In
Proceedings of the 8th Working Conference on Mining
Software Repositories , MSR '11, pages 211{214, 2011.
[21] M. Martin, B. Livshits, and M. S. Lam. Finding
Application Errors and Security Flaws Using PQL: A
Program Query Language. In OOPSLA , pages
365{383, 2005.
[22] T. Menzies, J. Greenwald, and A. Frank. Data mining
static code attributes to learn defect predictors. IEEE
Trans. Softw. Eng. , 33(1):2{13, Jan. 2007.
[23] T. Menzies and A. Marcus. Automated Severity
Assessment of Software Defect Reports. In ICSM ,
pages 346{355, 2008.
[24] P. Meredith, D. Jin, F. Chen, and G. Ro su. Ecient
Monitoring of Parametric Context-Free Patterns. In
ASE, pages 148{157, 2008.
[25] Y. Padioleau, J. Lawall, R. R. Hansen, and G. Muller.
Documenting and Automating Collateral Evolutions
in Linux Device Drivers. In Eurosys , pages 247{260,
2008.
[26] C. Sun, J. Du, N. Chen, S.-C. Khoo, and Y. Yang.
Mining Explicit Rules for Software Process
Evaluation. In ICSSP , pages 118{125, 2013.
[27] C. Sun, D. Lo, S.-C. Khoo, and J. Jiang. Towards
More Accurate Retrieval of Duplicate Bug Reports. In
ASE, pages 253{262, Nov 2011.
[28] C. Sun, D. Lo, X. Wang, J. Jiang, and S.-C. Khoo. A
Discriminative Model Approach for Accurate
Duplicate Bug Report Retrieval. In ICSE , pages
45{54, 2010.
[29] K. Thompson. Programming Techniques: Regular
Expression Search Algorithm. Commun. ACM ,
11(6):419{422, June 1968.
[30] Y. Tian, D. Lo, and C. Sun. Information Retrieval
based Nearest Neighbor Classication for Fine-grained
Bug Severity Prediction. In WCRE , pages 215{224,
2012.
[31] Y. Tian, D. Lo, and C. Sun. DRONE: Predicting
Priority of Reported Bugs by Multi-Factor Analysis.
InICSM , pages 200{209. IEEE, 2013.
[32] J. Wang and H. Zhang. Predicting Defect Numbers
based on Defect State Transition Models. In ESEM ,
pages 191{200, 2012.
[33] R. Wu, H. Zhang, S. Kim, and S.-C. Cheung. ReLink:
Recovering Links Between Bugs and Changes. In
ESEC/FSE , pages 15{25, 2011.
[34] T. Zimmermann, R. Premraj, and A. Zeller.
Predicting defects for eclipse. In Proceedings of the
Third International Workshop on Predictor Models in
Software Engineering , PROMISE '07, pages 9{, 2007.