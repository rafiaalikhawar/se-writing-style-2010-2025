Automated Concolic Testing of Smartphone Apps
Saswat Anand
Georgia Tech
saswat@gatech.eduMayur Naik
Georgia Tech
naik@cc.gatech.eduHongseok Y ang
University of Oxford
hongseok.yang@cs.ox.ac.uk
Mary Jean Harrold
Georgia Tech
harrold@cc.gatech.edu
ABSTRACT
We present an algorithm and a system for generating in-
put events to exercise smartphone apps. Our approach is
based on concolic testing and generates sequences of events
automatically and systematically. It alleviates the path-
explosion problem by checking a condition on program exe-
cutions that identies subsumption between dierent event
sequences. We also describe our implementation of the ap-
proach for Android, the most popular smartphone app plat-
form, and the results of an evaluation that demonstrates its
eectiveness on ve Android apps.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging|
Symbolic execution, Testing tools
Keywords
GUI testing, testing event-driven programs, Android
1. INTRODUCTION
Mobile devices with advanced computing ability and con-
nectivity, such as smartphones and tablets, are becoming
increasingly prevalent. At the same time there has been a
surge in the development and adoption of specialized pro-
grams, called apps, that run on such devices. Apps per-
vade virtually all activities ranging from leisurely to mission-
critical. Thus, there is a growing need for software-quality
tools in all stages of an app's life-cycle, including develop-
ment, testing, auditing, and deployment.
Apps have many features that make static analysis chal-
lenging: a vast software development kit (SDK), asynchrony,
inter-process communication, databases, and graphical user
interfaces (GUIs). Thus, many approaches for analyzing
apps are based on dynamic analysis (e.g., [7, 9, 10]).
A question central to the eectiveness of any dynamic
analysis is how to obtain relevant program inputs. The most
indivisible and routine kind of inputs to an app are events . A
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
SIGSOFTâ€™12/FSE-20, November 11â€“16, 2012, Cary, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1614-9/12/11 ...$15.00.tap on the device's touch screen, a key press on the device's
keyboard, and an SMS message are all instances of events.
This paper presents an algorithm and a system for gener-
ating input events to exercise apps. Apps can have inputs
besides events, such as les on disk and secure web content.
Our work is orthogonal and complementary to approaches
that provide such inputs.
Apps are instances of a class of programs we call event-
driven programs : programs embodying computation that
is architected to react to a possibly unbounded sequence
of events. Event-driven programs are ubiquitous and, be-
sides apps, include stream-processing programs, web servers,
GUIs, and embedded systems. Formally, we address the fol-
lowing problem in the setting of event-driven programs in
general, and apps in particular.
Branch-coverage Problem: Given a constant bound
k1, eciently compute a set of event sequences that
execute each branch of an event-driven program that can
be executed by some event sequence of length up to k.
The above problem poses two separate challenges: (1) how
to generate single events and (2) how to extend them to
sequences of events. We next look at each of these in turn.
Generating Single Events. Existing approaches for
generating all events of a particular kind use either capture-
replay techniques to automatically infer a model of the app's
GUI [22, 31] or model-based techniques that require users to
provide the model [34, 36]. These approaches have limita-
tions. Capture-replay approaches are tailored to a particular
platform's event-dispatching mechanism but many apps use
a combination of the platform's logic and their own custom
logic for event dispatching. For example, where the plat-
form sees a single physical widget, an app might interpret
events dispatched to dierent logical parts of that widget
dierently. In contrast, model-based approaches are general-
purpose, but they can require considerable manual eort.
In this paper, we present a new approach, which is both
general and automatic, to address this problem. The ap-
proach builds on a systematic test-input generation tech-
nique called concolic testing [6, 15, 30] (also known as dy-
namic symbolic execution) which has made signicant strides
in recent years. Our approach symbolically tracks events
from the point where they originate to the point where they
are ultimately handled. The approach is thus oblivious to
where and how events are dispatched.
Generating Event Sequences. Our concolic-testing
approach for generating single events can be extended nat-
urally to iteratively compute sets of increasingly longer se-
quences of events. An algorithm, hereafter called AllSeqs ,can generate all event sequences of length up to ksuch that
each event sequence executes a unique program path. How-
ever, AllSeqs does not scale as the value of kis increased
because typical programs have a large number of program
paths. For instance, for a simple music player app writ-
ten for the Android mobile app platform, AllSeqs gener-
ates 11 one-event sequences, 128 two-event sequences, 1,590
three-event sequences, and 21K four-event sequences. This
problem is known as the path-explosion problem [12], and,
in practice, AllSeqs may fail to solve the aforementioned
branch-coverage problem within a time budget for a high
value ofk.
Although several techniques have been developed in recent
years to address the path-explosion problem (e.g., [1, 4, 12{
14, 17, 19, 20, 29]), the problem is still intractable for real-
world software. In this paper, we present a new technique,
ACTEve (stands for A utomated C oncolic T esting of Eve nt-
driven programs), to alleviate the path-explosion problem.
ACTEve is tailored to event-driven programs such as smart-
phone apps. The key insight underlying ACTEve is a no-
tion of subsumption between two event sequences. If an
event sequence issubsumed by another event sequence
0, then ACTEve avoids generating sequences that are ex-
tensions of , and instead generates extensions of 0only.
Such pruning of results in compounded savings as longer
event sequences are generated. We show that ACTEve is
relatively complete with respect to AllSeqs . Specically,
ACTEve covers the same set of branches as AllSeqs for a
given upper bound on the length of event sequences.1
ACTEve computes subsumption between event sequences
by checking for simple data- and control-ow facts of each
program execution in isolation. Compared to existing tech-
niques for the path-explosion problem, ACTEve has at least
four distinctive characteristics that greatly improves its ap-
plicability to real-world software such as Android apps. First,
it does not impose any unrealistic assumption (e.g., meth-
ods are free of side eects) about the program. Second, it
does not store and match program traces or program states,
which can dramatically increase memory overhead. Third,
it does not require powerful (e.g., support for quantiers)
or specialized constraint solvers to reason about path con-
straints of multiple program paths simultaneously. Fourth,
it does not require static analysis of real-world code that
often contain parts that are beyond the scope of static anal-
ysis. Despite its above-mentioned simplicity, in our empir-
ical study, ACTEve produced signicant savings because
subsumption between event sequences exists frequently in
real apps. For example, for the previously-mentioned music
player app, using k= 4, our algorithm explores only 16% of
the inputs (3,445 out of 21,117) that AllSeqs explores.
We have implemented ACTEve in a system for Android
apps. Our system instruments and exercises apps in a mobile
device emulator that runs an instrumented Android SDK.
This enables our system to be portable across mobile de-
vices, leverage Android's extensive tools (e.g., to automat-
ically run the app on generated inputs), and exploit stock
hardware; in particular, our system uses any available par-
allelism, and can run multiple emulators on a machine or
a cluster of machines. Our system also builds upon recent
advances in concolic testing such as function summariza-
1ACTEve can also be used for bounded verication of safety prop-
erties, by converting a given assert(e) statement to if (!e) as-
sert(false) and checking reachability of the assert(false) statement.tion [12], generational search [16], and Satisability Modulo
Theories (SMT) solving [8]. We show the eectiveness of
our system on ve Android apps.
The primary contributions of this work are as follows.
1. A novel approach to systematically generate events to
exercise apps. Our approach, based on concolic test-
ing, is fully automatic and general, in contrast to exist-
ing capture-replay-based or model-based approaches.
2. An ecient algorithm, ACTEve , to solve the branch-
coverage problem. Our key insight is a subsumption
condition between event sequences. Checking the con-
dition enables ACTEve to prune redundant event se-
quences, and thereby alleviate path explosion, while
being complete with respect to AllSeqs .
3. An implementation and evaluation of ACTEve in a
system for Android apps. Our system is portable, ex-
ploits available parallelism, and leverages recent ad-
vances in concolic testing.
2. OVERVIEW OF OUR APPROACH
In this section, we illustrate our approach using an ex-
ample music player app from the Android distribution. We
rst describe the app by discussing its source code shown in
Figure 1 (Section 2.1). We then describe how we generate
events to exercise this app (Section 2.2) and how we extend
them to sequences of events (Section 2.3).
2.1 The Music Player App
Android apps are incomplete programs: they implement
parts of the Android SDK's API and lack a main method.
When the music player app is started, the SDK creates an in-
stance of the app's main activity MainActivity , and calls its
onCreate() method. This method displays the main screen,
depicted in Figure 2(a), which contains six buttons: rewind ,
play,pause ,skip,stop, and eject. The method also sets the
main activity as the handler of clicks to each of these but-
tons. The app waits for events once onCreate() nishes.
When any of the six buttons is clicked, the SDK calls
the main activity's onClick() method, because the main
activity was set to handle these clicks. If the eject button
is clicked, this method displays a dialog, depicted in Fig-
ure 2(b), that prompts for a music le URL. If any of the
other buttons is clicked, the onClick() method starts a ser-
vice MusicService with an argument that identies the but-
ton. The service processes clicks to each of the ve buttons.
For brevity, we show only how clicks to the rewind button
are processed, in the processRewind() method. The service
maintains the current state of the music player in mState .
On start-up, the service searches for music les stored in
the device, and hence the state is initialized to Retrieving .
Clicks to each button have eect only in certain states; for
instance, clicking the rewind button has no eect unless the
state is Playing orPaused , in which case processRewind()
rewinds the player to the start of the current music le.
2.2 Generating Single Events
Our rst goal is to systematically generate single input
events to a given app in a given state. For concreteness, we
focus on tap events, which are taps on the device's touch
screen, but our observations also hold for other kinds of
events (e.g., key presses on the device's keyboard).public class MainActivity extends Activity {
Button mRewindButton, mPlayButton, mEjectButton, ...;
public void onCreate(...) {
setContentView(R.layout.main);
mPlayButton = findViewById(R.id.playbutton);
mPlayButton.setOnClickListener(this);
... // similar for other buttons
}
public void onClick(View target) {
if (target == mRewindButton)
startService(new Intent(ACTION_REWIND));
else if (target == mPlayButton)
startService(new Intent(ACTION_PLAY));
... // similar for other buttons
else if (target == mEjectButton)
showUrlDialog();
}
}
public class MusicService extends Service {
MediaPlayer mPlayer;
enum State { Retrieving, Playing, Paused, Stopped, ... };
State mState = State.Retrieving;
public void onStartCommand(Intent i, ...) {
String a = i.getAction();
if (a.equals(ACTION_REWIND)) processRewind();
else if (a.equals(ACTION_PLAY)) processPlay();
... // similar for other buttons
}
void processRewind() {
if (mState == State.Playing || mState == State.Paused)
mPlayer.seekTo(0);
}
}
Figure 1: Source code snippet of music player app.
Our goal is to generate tap events such that each widget
on the displayed screen of the app is clicked once. In An-
droid, the widgets on any screen of an app are organized in
a tree called the view hierarchy , where each node denotes
the rectangular bounding box of a dierent widget, and the
node's parent denotes its containing widget. Figure 3 shows
the view hierarchy for the main screen of the music player
app depicted in Figure 2(a). Given this hierarchy, we can
achieve our goal of clicking each widget once, by generating
Cartesian coordinates inside each rectangle in the hierarchy
and outside its sub-rectangles.
As we discussed in the Introduction, existing approaches
either infer the hierarchy automatically (via capture-replay
[22, 31]) or require users to provide it (model-based tech-
niques [34, 36]); both have limitations. We present a new
approach that is general and fully automatic. Our approach
is based on concolic testing, and symbolically tracks events
from the point where they originate to the point where they
are handled. For this purpose, our approach instruments
the Android SDK and the app under test. In the case of tap
events, whenever a concrete tap event is input, this instru-
mentation creates a fresh symbolic tap event and propagates
it alongside the concrete event. As the concrete event ows
through the SDK and the app, the instrumentation tracks a
constraint on the corresponding symbolic event which eec-
tively identies all concrete events that are handled in the
same manner. This not only lets our approach avoid gen-
erating spurious events but also enables it to exhaustively
generate orthogonal events. For the main screen of our mu-
sic player app, for instance, our approach generates exactly
11 tap events, one in each of the rectangles (and outside
sub-rectangles) in the screen's view hierarchy depicted in
Figure 3. Section 3 describes how our approach generates
these events in further detail.
(a) Main screen.
 (b) Eject dialog.
Figure 2: Screen shots of music player app.
FrameLayout1	 Â FrameLayout2	 Â TextView	 Â LinearLayout2	 Â LinearLayout1	 Â Bu5on1	 Â (rewind)	 Â Bu5on2	 Â (play)	 Â Bu5on3	 Â (pause)	 Â Bu5on4	 Â (skip)	 Â Bu5on5	 Â (stop)	 Â Bu5on6	 Â (eject)	 Â 
Figure 3: View hierarchy of main screen.
2.3 Generating Event Sequences
Our concolic testing approach for generating single events
can be extended naturally to iteratively compute sets of in-
creasingly longer sequences of events. However, as we dis-
cussed in the Introduction, the AllSeqs concolic testing ap-
proach [15, 30] causes the computed sets to grow rapidly|
for the above music player app, AllSeqs produces 11 one-
event sequences, 128 two-event sequences, 1,590 three-event
sequences, and 21K four-event sequences.
We studied the event sequences produced by AllSeqs for
several Android apps and found a signicant source of redun-
dancy, namely, that a large fraction of events do not have any
eect on the program state. We call such events read-only
because we identify them by checking that no memory loca-
tion is written when they are dispatched and handled. Upon
closer inspection, we found diverse reasons for the prevalence
of read-only events, which we describe below.
First, many widgets on any given screen of any app never
react to any clicks. As shown in the view hierarchy of the
main screen of the music player app (Figure 3), these in-
clude boilerplate widgets (e.g., FrameLayout and Linear-
Layout ), which merely serve to layout other actionable wid-
gets (e.g., Button ), and informational widgets that display
non-editable texts (e.g., TextView ). Thus, only 6 of 11 wid-
gets on the main screen of the music player app (namely,
the six buttons) are actionable, and clicks to the remaining
5 widgets constitute read-only events.
Second, many widgets that are actionable might be dis-
abled in certain states of the app. This situation often occurs
when apps wish to guide users to provide events in a certain
order or when they wish to prevent users from providing
undened combinations of events.
Third, GUI-based programs are conservative in updating
state. In particular, they avoid unnecessary updates, to sup-
press needlessly re-drawing widgets and notifying listeners.
For instance, if an event wishes to set a widget to a state, then the event handler for that widget reads the current
state of the widget, and does nothing if the current state is
already, eectively treating the event as read-only.
Based on the above observations, we developed ACTEve
that does not extend event sequences that end in a read-
only event. Pruning such sequences in a particular itera-
tion of our approach prevents extensions of those sequences
from being considered in future iterations, thereby provid-
ing compounded savings, while still ensuring completeness
with respect to AllSeqs . We show that the read-only pat-
tern is an instance of a more general notion of subsumption
between event sequences. An event sequence that ends in
a read-only event is subsumed by the same event sequence
without that nal event.
For our example music player app, using read-only sub-
sumption, our approach explores 3,445 four-event sequences,
compared to 21,117 by the AllSeqs approach, which does
not check for subsumption but is identical in all other re-
spects. Besides clicks to many passive widgets in this app
(e.g., LinearLayout ) being read-only, another key reason for
the savings is that even clicks to actionable widgets (e.g.,
Button ) are read-only in many states of the app. For in-
stance, consider the two-event sequence [ stop,rewind ]. The
rst event ( stop) writes to many memory locations (e.g.,
elds mPlayer and mState in class MusicService shown in
Figure 1). However, the second event ( rewind ) does not
write to any location, because the processRewind() method
of class MusicService that handles this event only writes if
the state of the music player is Playing orPaused , whereas
after the rst stopevent, its state is Stopped . Thus, our ap-
proach identies the rewind event in sequence [ stop,rewind ]
as read-only, and prunes all sequences explored by AllSeqs
that have this sequence as a proper prex.
Section 4 presents a formal description of subsumption,
the read-only instantiation of subsumption, and the formal
guarantees it provides.
3. GENERATING SINGLE EVENTS
In this section, we describe how our approach systemati-
cally generates single events. We use tap events in Android
as a proof-of-concept. Tap events are challenging to generate
because they are continuous and have more variability than
discrete events such as incoming phone calls, SMS messages,
battery charging events, etc. Moreover, tap events are of-
ten the primary drivers of an app's functionality, and thus
control signicantly more code of the app than other kinds
of events. The principles underlying our approach, however,
are not specic to tap events or to Android.
We begin by describing how Android handles tap events.
Figure 4 shows the simplied code of the dispatchEvent()
method of SDK class android.view.ViewGroup . When a
tap event is input, this method is called recursively on wid-
gets in the current screen's view hierarchy, to nd the inner-
most widget to which to dispatch the event, starting with
the root widget. If the event's coordinates lie within a wid-
get's rectangle, as determined by the contains() method of
SDK class android.graphics.Rect , then dispatchEvent()
is called on children of that widget, from right to left, to de-
termine whether the current widget is indeed the innermost
one containing the event or if it has a descendant contain-
ing the event. For instance, any tap event that clicks on
thepause button on the main screen of our example music
player app results in testing for the event's containment inpublic class android.view.ViewGroup {
public boolean dispatchEvent(Event e) {
float x = e.getX(), y = e.getY();
for (int i = children.length - 1; i >= 0; i--) {
View child = children[i];
if (child.contains(x, y))
if (child.dispatchEvent(e))
return true;
}
return false;
}
}
public class android.graphics.Rect {
public boolean contains(float x, float y) {
return x >= this.left && x < this.right &&
y >= this.top && y < this.bottom;
}
}
Figure 4: Source code snippet of Android SDK.
the following widgets in order, as the event is dispatched
in the view hierarchy depicted in Figure 3. We also indi-
cate whether or not each test passes: FrameLayout1(yes)!
FrameLayout2(yes)!LinearLayout2(no)!LinearLayout1
(yes)!Button4(no)!Button3(yes).
Our approach uses concolic testing to generate a sepa-
rate tap event to each widget. This requires symbolically
tracking events from the point where they originate to the
point where they are handled. Let ($ x;$y) denote vari-
ables that our approach uses to symbolically track a con-
crete tap event ( x;y). Then, for each call to contains (x;y)
on a rectangle in the view hierarchy specied by constants
(xleft; xright; ytop; ybottom ), our approach generates the fol-
lowing constraint or its negation, depending upon whether
or not the tap event is contained in the rectangle:
(xleft$x<x right)^(ytop$y<y bottom )
Our approach starts by sending a random tap event to the
current screen of the given app. For our example app, sup-
pose this event clicks the pause button. Then, our approach
generates the following path constraint :
(0$x <480)^(0$y <800) ==c1
^ (0$x <480)^(38$y <800) ==c2
^ $x0= $x^$y0= ($y 38) ==p1
^ : ((128$x0<352)^(447$y0<559)) ==c3
^ (16$x0<464)^(305$y0<417) ==c4
^ $x00= ($x0 16)^$y00= ($y0 305) ==p2
^ : ((344$x00<440)^(8$y00<104)) ==c5
^ (232$x00<328)^(8$y00<104) ==c6
Constraints c1andc2capture the fact that the event is
tested for containment in FrameLayout1and FrameLayout2,
respectively, and the test passes in both cases. The event is
then tested against LinearLayout2but the test fails (notice
the negation in c3). Constraints c4throughc6arise from
testing the event's containment in LinearLayout1,Button4
(the skipbutton), and Button3(the pause button). We ex-
plain constraints p1andp2below.
Our approach next uses this path constraint to generate
concrete tap events to other widgets. Specically, for each
ci, it uses an o-the-shelf constraint solver to solve the con-
straint (Vi 1
j=1cj)^:cifor $xand $y. If this constraint is
satisable, any solution the solver provides is a new concrete
tap event guaranteed to take the path dictated by this con-
straint in the view hierarchy. That path in turn generates
a new path constraint and our approach repeats the above
process until all widgets in the hierarchy are covered.(condition label) l2Label
(input variable) a
(global variable) g2GVar =fg1;:::;gmg
(expression) e::=ajgjaop(e)
(boolean expression) b::=bop(e)jTruejFalsej
:bjb^bjb_b
(program)s::=skipjg=ejs1;s2j
ifbls1elses2jwhilebls
Figure 5: Syntax of programs.
We now explain the role of constraints p1andp2in the
path constraint depicted above. These constraints introduce
new symbolic variables $ x0, $y0, $x00, and $y00. They arise
because, as a tap event is dispatched in the Android SDK,
various osets are added to its concrete xandycoordinates,
to account for margins, convert from relative to absolute po-
sitions, etc. The already-simplied path constraint depicted
above highlights the complexity for concolic execution that
a real platform like Android demands: we instrument not
only the SDK code shown in Figure 4 but allSDK code,
as well as the code of each app under test. Dropping any
of the above constraints due to missed instrumentation can
result in the path divergence problem [16] in concolic testing,
where the concrete and symbolic values diverge and impair
the ability to cover all widgets.
4. GENERATING EVENT SEQUENCES
In this section, we describe how our approach generates
sequences of events. To specify our approach fully and to ex-
press and prove the formal guarantee of the approach, we use
a simple imperative language, which includes the essential
features of Android apps. We begin with the explanation
of our language and the associated key semantic concepts
(Sections 4.1 and 4.2). We then describe our algorithm,
proceeding from the top-level routine (Section 4.3) to the
main optimization operator (Sections 4.4 and 4.5). Finally,
we discuss the formal completeness guarantee of our algo-
rithm (Section 4.6). Appendix B in [2] presents the proofs
of all lemmas and the theorem discussed in this section.
4.1 Core Language
Our programming language is a standard WHILE lan-
guage with one xed input variable aand multiple global
variablesg1,. . . ,gmfor some xed m. A program smod-
els an Android app, and it is meant to run repeatedly in
response to a sequence of input events provided by an ex-
ternal environment, such as a user of the app. The global
variables are threaded in the repetition, so that the nal val-
ues of these variables in the i-th iteration become the initial
values of the variables in the following ( i+1)-th iteration. In
contrast, the input variable ais not threaded, and its value
in thei-th iteration comes from the i-th input event. Other
than this initialization in each iteration, no statements in
the program scan modify the input variable a.
The syntax of the language appears in Figure 5. For sim-
plicity, the language assumes that all the input events are
integers and stored in the input variable a. It allows such an
event inato participate in constructing complex expressions
e, together with global variable gand the application of an
arithmetic operator aop(e), such asa+g. Boolean expres-
sionsbcombine the expressions using standard comparison
operators, such as = and , and build conditions on pro-
gram states. Our language allows ve types of programming(integer)n2 Integers
(global state) ::= [g1:n1;:::;gm:nm]
(symbolic global state)   ::= [ g1:e1;:::;gm:em]
(branching decision) d::=hl;truei j hl;falsei
(instrumented constraint) c::=bd
(path constraint) C::=c1c2:::ck
(concolic state) !::=h; ;Ci
(input event sequence) ::=n1n2:::nk
(set of globals) W fg1;:::;gmg
(trace)::=hC1;W 1i:::hCk;Wki
Figure 6: Semantic domains.
constructs with the usual semantics: skipfor doing nothing;
assignments to global variables g=e; sequential composi-
tions (s1;s2); conditional statements ( ifbls1elses2) with
anl-labeled boolean b; and loops ( whilebls). Note that
although the input variable acan appear on the RHS of an
assignment, it is forbidden to occur on the LHS. Thus, once
initialized, the value of anever changes during the execu-
tion of a program. Note also that all boolean conditions are
annotated with labels l. We require the uniqueness of these
labels. The labels will be used later to track branches taken
during the execution of a program.
Example 1. The following program is a simplied version
of the music player app in our language:
if(g==Stopped )l0f
if(a==Play )l1fg=Playing g
else if (a==Skip )l2fg=Skipping gelsefskipg
gelsef
if(a==Stop )l3fg=Stopped gelsefskipg
g
To improve the readability, we use macros here: Stopped =
Stop = 0, Playing =Play = 1, and Skipping =Skip = 2.
Initially, the player is in the Stopped state (which is the value
stored ing), but it can change to the Playing orSkipping state
in response to an input event. When the player gets the Stop
input event, the player's state goes back to Stopped .
We write Globals (e) and Globals (s) to denote the set of
free global variables appearing in eands, respectively.
Throughout the rest of the paper, we x the input pro-
gram and the initial global state given to our algorithm, and
denote them by sinandin.
4.2 Semantic Domains
We interpret programs using a slightly non-standard op-
erational semantics, which describes the concolic execution
of a program, that is, the simultaneous concrete and sym-
bolic execution of the program. Figure 6 summarizes the
major semantic domains. The most important are those for
concolic states !, input sequences , and traces .
Aconcolic state !species the status of global variables
concretely as well as symbolically. The state consists of the
three components, denoted by !:,!: , and!:C, respec-
tively. The component keeps the concrete values of all
the global variables, while the   component stores the sym-
bolic values of them, specied in terms of expressions. We
require that global variables do not occur in these symbolic
values; only the input variable ais allowed to appear there.
TheCcomponent is a sequence of instrumented constraints
c1c2:::ck, where each ciis a boolean expression bannotated
with a label and a boolean value. As for symbolic values,we prohibit global variables from occurring in b. The an-
notation indicates the branch that generates this boolean
value as well as the branching decision observed during the
execution of a program.
Aninput event sequence is just a nite sequence of
integers, where each integer represents an input event from
the environment.
Atraceis also a nite sequence, but its element consists
of a path constraint Cand a subset Wof global variables.
The elementhC;Wiofexpresses what happened during
the concolic execution of a program with a single input event
(as opposed to an event sequence). Hence, if is of length k,
it keeps the information about event sequences of length k.
TheCpart describes the symbolic path constraint collected
during the concolic execution for a single event, and the W
part stores variables written during the execution. As in the
case of concolic state, we adopt the record selection notation,
and write ( i):Cand (i):Wfor theCandWcomponents
of thei-th element of . Also, we write hC;Wito mean
the concatenation of with a singleton trace hC;Wi.
Our operational semantics denes two evaluation rela-
tions: (1)hs;n;!i#!0. W and (2)hs;;i+0. :
The rst relation models the run of swith a single input
eventnfrom a concolic initial state !. It says that the out-
come of this execution is !0, and that during the execution,
variables in Ware written. Note that the path constraint
!0:Crecords all the branches taken during the execution of
a program. If the execution encounters a boolean condition
blthat evaluates to True, it still adds Truehl;trueito theC
part of the current concolic state, and remembers that the
true branch is taken. The case that blevaluates to False is
handled similarly.
The second relation describes the execution of swith an
input event sequence. It says that if a program sis run re-
peatedly for an input sequence starting from a global state
, this execution produces a nal state 0, and generates a
trace, which records path constraints and written variables
during the execution. Note that while the rst relation uses
concolic states to trace various symbolic information about
execution, the second uses traces for the same purpose.
The rules for the evaluation relations mostly follow from
our intended reading of all the parts in the relations. They
are described in detail in Appendix A in [2].
Recall that we xed the input program and the initial
global state and decided to denote them by sinandin.
We say that a trace isfeasible ifcan be generated by
runningsinfrominwith some event sequences, that is,
9;0:hsin;; ini +0. : Our algorithm works on
feasible traces, as we explain next.
4.3 Algorithm
ACTEve takes a program, an initial global state, and an
upper bound kon the length of event sequences to explore.
By our convention, sinandindenote these program and
global state. Then, ACTEve generates a set  of traces of
length up to k, which represents event sequences of length
up tokthat achieve the desired code coverage. Formally, 
satises two correctness conditions.
1. First, all traces in  are feasible. Every 2 can be
generated by running sinwith some event sequence 
of length up to k.
2. Second,  achieves the full coverage in the sense that
if a branch of sinis covered by an event sequence ofAlgorithm 1 Algorithm ACTEve
INPUTS: Programsin, global state in, boundk1.
OUTPUTS: Set of traces of length up to k.
0=  0=fg
fori= 1to kdo
i=symex (sin;in;i 1)
i=prune (i)
end for
returnSk
i=0i
length up to k, we can nd a trace in  such that
every event sequence 0satisfying(i.e.,0j=) also
covers the branch.
The top-level routine of ACTEve is given in Algorithm 1.
The routine repeatedly applies operations symex and prune
in alternation on sets  iand iof traces of length i, starting
with the set containing only the empty sequence . Figure 7
illustrates this iteration process pictorially. The iteration
continues until a given bound kis reached, at which pointSk
i=0iis returned as the result of the routine.
The main work of ACTEve is done mostly by the op-
erations symex and prune . It invokes symex (sin;in;i 1)
to generate all the feasible one-step extensions of traces in
i 1. Hence,
symex (sin;in;i 1) =
fhC;Wij2i 1andhC;Wiis feasibleg;
wherehC;Wimeans the concatenation of with a single-
step tracehC;Wi. The symex operation can be easily im-
plemented following a standard algorithm for concolic ex-
ecution (modulo the well-known issue with loops), as we
did in our implementation for Android.2In fact, if we
skip the pruning step in ACTEve and set  ito ithere
(equivalently, prune () returns simply ), we get the stan-
dard concolic execution algorithm, AllSeqs for exploring
all branches that are reachable by event sequences of length
kor less.
The goal of the other operation prune is to identify traces
that can be thrown away without making the algorithm
cover less branches, and to lter out such traces. This lter-
ing is the main optimization employed in our algorithm. It
is based on our novel idea of subsumption between traces,
which we discuss in detail in the next subsection.
Example 2. We illustrate our algorithm with the music
player app in Example 1 and the bound k= 2. Initially, the
algorithm sets  0=  0=fg. Then, it extends this empty
sequence by calling symex , and obtains  1that contains the
following three traces of length 1:
=hTruehl0;truei(a==Play)hl1;truei;fggi;
0=hTruehl0;truei(a==Play)hl1;falsei(a==Skip)hl2;truei;fggi;
00=hTruehl0;truei(a==Play)hl1;falsei(a==Skip)hl2;falsei;;i:
Tracedescribes the execution that takes the true branches
ofl0andl1. It also records that variable gis updated in
this execution. Traces 0and00similarly correspond to
executions that take dierent paths through the program.
2When sincontains loops, the standard concolic execution can fail to
terminate. However, symex is well-dened for such programs, because
it is not an algorithm but a declarative specication.fg=  0symex   ! 1prune   !
1symex   ! 2prune   !
2symex   !:::
Figure 7: Simulation of our ACTEve algorithm.
Next, the algorithm prunes redundant traces from  1. It
decides that 00is such a trace, lters 00, and sets  1=
f;0g. This ltering decision is based on the fact that the
last step of 00does not modify any global variables. For
now, we advise the reader not to worry about the justi-
cation of this ltering; it will be discussed in the following
subsections.
Once  1and  1are computed, the algorithm goes to the
next iteration, and computes  2and  2similarly. The trace
set  2is obtained by calling symex , which extends traces in
1with one further step:
2=fhTruehl0;falsei(a==Stop)hl3;truei;fggi;
hTruehl0;falsei(a==Stop)hl3;falsei;;i;
0hTruehl0;falsei(a==Stop)hl3;truei;fggi;
0hTruehl0;falsei(a==Stop)hl3;falsei;;ig
Among these traces, only the rst and the third have the last
step with the nonempty write set, so they survive pruning
and form the set  2.
After these two iterations, our algorithm returnsS2
i=0i.
4.4 Subsumption
For a feasible trace , we dene
nal() =f0j9:hsin;; ini+0. g;
which consists of the nal states of the executions of sinthat
generate the trace .
Letand0be feasible traces. The trace is subsumed
by0, denotedv0, if and only if nal()nal(0). Note
that the subsumption compares two traces purely based on
their nal states, ignoring other information like length or
accessed global variables. Hence, the subsumption is ap-
propriate for comparing traces when the traces are used to
represent sets of global states, as in our algorithm ACTEve .
We lift subsumption on sets T;T0of feasible traces in a stan-
dard way:TvT0() 82T:902T0:v0. Both the
original and the lifted subsumption relations are preorder,
i.e., they are reexive and transitive.
A typical use of subsumption is to replace a trace set Tnew
by a subset Toptsuch thatTnewvTopt[Toldfor someTold.
In this usage scenario, Tnewrepresents a set of traces that a
concolic testing algorithm originally intends to extend, and
Toldthat of traces that the algorithm has already extended.
ReducingTnewtoToptentails that fewer traces will be ex-
plored, so it boosts the performance of the algorithm.
Why is it ok to reduce TnewtoTopt? An answer to this
question lies in two important properties of the subsumption
relation. First, the symex operation preserves the subsump-
tion relationship.
Lemma 1. For setsT;T0of feasible traces,
TvT0=)symex (sin;in;T)vsymex (sin;in;T0):
Second, ifTis subsumed by T0, running symex withT0
will cover as many branches as what doing the same thing
withTcovers. Let
branch (C) =fdjbd=Cifor somei2f1;:::;jCjgg:Algorithm 2 The rprune operation
INPUTS: Set  of traces.
OUTPUTS: Set  =f2jjj1)(jj):W6=;g
The formal statement of this second property appears in the
following lemma:
Lemma 2. For all sets T;T0of feasible traces, if TvT0.
Sfbranch ((jj):C)j2symex (sin;in;T)g
Sfbranch ((jj):C)j2symex (sin;in;T0)g:
In the lemma, jjmeans the last element in the trace
and (jj):Cchooses the Ccomponent of this element.
So, the condition compares the branches covered by the last
elements of traces.
Using these two lemmas, we can now answer our original
question about the subsumption-based optimization. Sup-
pose thatToptis a subset of TnewbutTnewvTopt[Told
for someTold. The lemmas imply that every new branch
covered by extending Tnewfor the further k1 steps is also
covered by doing the same thing for Topt[Told. More con-
cretely, according to Lemma 1, the extension of Tnewfor the
furtherk 1 or smaller steps will continue to be v-related
to that ofTopt[Told. Hence, running symex with such ex-
tendedTnewwill cover only those branches that can also be
covered by doing the same thing for the similarly extended
Topt[Told(Lemma 2). Since we assume that the kor smaller
extensions of Toldare already explored, this consequence of
the lemmas means that as long as we care about only newly
covered branches, we can safely replace TnewbyTopt, even
whenToptis a subset of Tnew.
4.5 Pruning
The goal of the pruning operator is to reduce a set  of
feasible traces to a subset  , such that  is subsumed
by  and all strict prexes of :3
v[sprex (); (1)
where sprex () =fj90:j0j1^02g. The re-
duction brings the gain in performance, while the subsump-
tion relationship (together with an invariant maintained by
ACTEve ) ensures that no branches would be missed by this
optimization.
Our implementation of pruning adopts a simple strategy
for achieving the goal. From a given set , the operator l-
ters out all traces whose last step does not involve any writes,
and returns the set  of remaining traces. The implemen-
tation appears in Figure 2, and accomplishes our goal, as
stated in the following lemma:
Lemma 3. For all sets of feasible traces, rprune () is a
subset of and satises the condition in (1).
Note that the pruning operator can be implemented dier-
ently from rprune . As long as the pruned set  satises the
subsumption condition in (1), our entire algorithm ACTEve
remains relatively complete, meaning that the optimization
with pruning will not introduce new uncovered branches.
Appendix C in [2] shows another implementation of pruning
that uses the notion of independence.
3This condition typechecks because all prexes of feasible traces are
again feasible traces so that the RHS of vcontains only feasible
traces.4.6 Relative Completeness
Fori0, let symexi(sin;in;T) be thei-repeated applica-
tion of symex (sin;in; ) to a setTof feasible traces, where
the 0-repeated application symex0(sin;in;T) is dened to
beT. Also, lift the branch operation to a trace set:
branch (T) =[
fbranch ((i):C)j2T^i2f1;:::;jjgg
Theorem 4 (Completeness) .For everyk1,
branch (ACTEve (sin;in;k))
=branch (Sk
i=0symexi(sin;in;fg)):
The RHS of the equation in the theorem represents branches
covered by running the standard concolic execution without
pruning. The theorem says that our algorithm covers the
same set of branches, hence same program statements, as
the standard concolic execution.
5. EMPIRICAL EVALUATION
In this section, we present the empirical evaluation of
our technique. First, we describe the implementation of
ACTEve (Section 5.1). Next, we present the studies, in-
cluding the subjects used, the empirical setup, and the study
results (Sections 5.2{5.4). Finally, we discuss threats to the
validity of the studies (Section 5.5).
5.1 Implementation
The implementation of our system uses the Soot frame-
work [32], and consists of 11,000 lines of Java code. Fig-
ure 8 shows a dataow diagram of our system. Our system
inputs Java bytecodes of classes in Android SDK and App
under test . Java bytecodes of a class are obtained by either
compiling its source code (as done in our empirical evalu-
ation) or converting Android's Dalvik bytecode into Java
bytecodes [25]. Our system outputs a set of tests, Test in-
puts, each of which denotes an event sequence. The script
shown in the inset box is an example of a test that our sys-
tem can generate. Each line in the script corresponds to an
event. Tapgenerates a tap event on the screen at the spec-
ied Xand Ycoordinates. Tests similar to the one in this
script can be automatically executed using Monkey|a tool
in the Android SDK.
Tap(248.0,351.0)
Tap(279.0,493.0)Our system has four components:
Instrumenter, Runner, Concolic test-
ing engine, and Subsumption ana-
lyzer. We explain each in turn.
Instrumenter inputs Android SDK , and the Java class
les of the App under test , and outputs Instrumented
(SDK+App) . This component instruments the Java byte-
codes of each class of the App under test and any third-party
libraries that the App uses. It also instruments classes in
the Android framework (e.g., android.* ) but this step is
performed only once because the way in which a class is
instrumented does not depend on any other class.
Instrumenter operates on a three-address form of Java
bytecode produced by Soot, called Jimple. Instrumenter
performs three types of instrumentations. First, it instru-
ments App for concolic execution, which involves two main
steps: (1) adds a meta variable (eld) that stores the sym-
bolic value corresponding to each variable (eld); (2) inserts
a new assignment before every assignment such that the new
assignment copies the content of meta variable (eld) cor-
responding to the r-value of the original assignment to themeta variable (eld) corresponding to l-value of the origi-
nal assignment. Second, Instrumenter instruments App to
record elds of Java classes that are written only during the
handling of the last event in the sequence of events corre-
sponding to a test. Third, Instrumenter ensures that in In-
strumented (SDK+App) , user-specied method summaries
are symbolically executed instead of the original methods.
Runner inputs Instrumented (SDK+App) . The rst time
the component is called, it generates a test randomly; there-
after, it inputs tests from either the Concolic testing engine
or the Subsumption analyzer. Runner outputs Test inputs
that includes the randomly-generated test and tests that it
inputs. For each of those tests in Test inputs , it also outputs
aPath constraint and a Write set , which are used internally
by the other two components.
Runner executes Instrumented (App) with the test on an
emulator that uses Instrumented (SDK) . Besides these An-
droid framework classes, no other components of the frame-
work, such as Dalvik virtual machine of the Android execu-
tion environment, are modied. This feature of our system
makes it easily portable to dierent versions of Android.
Execution of a test generates the path constraint of the
path that the Apptakes and Write set , which is a set of elds
of Java classes that are written during the last event in the
input event sequence. Writes to array elements are recorded
as writes to one distinguished eld. Runner uses a set of
(typically 16) emulators each of which can execute a dierent
test at any time. Such parallelism enables our system to
perform systematic testing of realistic apps. Execution of
an app in a realistic environment, such as an emulator or
an actual device, takes orders of magnitude more time than
execution of similar desktop applications.
Concolic testing engine inputs Path constraint of a path,
and outputs New tests for current iteration . The component
rst computes a set of new path constraints by systemati-
cally negating each atomic constraint (i.e., conjunct) of the
input path constraint, as in standard concolic testing. Then,
it checks satisability of each of those new path constraints,
and generates and outputs new tests corresponding to sat-
isable path constraints using the Z3 SMT solver [8].
Subsumption analyzer inputs Write set , a set of elds of
Java classes that are written when App responds to the last
event in the event sequence corresponding to a specic test.
It may output one Seed test for next iteration .
Subsumption analyzer implements the rprune operator in
Algorithm 2. It outputs the test that corresponds to its
input Write set ifWrite set is non-empty. The output test
is called the seed test because new tests are generated in
the next iteration by extending this test with new events. If
Write set is empty, Subsumption analyzer outputs no test.
One important feature of Subsumption analyzer is that it
can be congured to ignore writes to a given set of elds.
This feature is useful because, in Android, many events lead
to writes to some memory locations, which fall into two
classes: (1) locations that are written to and read from dur-
ing the same event of an event sequence (i.e., never written
and read across events); (2) locations that result from An-
droid's low-level operations, such as optimizing performance
and memory allocation, and correspond to elds of Android
classes that are irrelevant to an app's behavior. Subsump-
tion analyzer ignores writes to these two classes of writesConcolic	 Â tes+ng	 Â engine	 Â Subsump+on	 Â analyzer	 Â Runner	 Â 	 Â 	 Â 	 Â 	 Â 	 Â 
EMU	 Â EMU	 Â â€¦	 Â EMU	 Â EMU	 Â â€¦	 Â EMU	 Â EMU	 Â â€¦	 Â Instrumenter	 Â 
Test	 Â inputs	 Â Instrumented	 Â 	 Â (SDK	 Â +	 Â App)	 Â Android	 Â SDK	 Â App	 Â under	 Â test	 Â Path	 Â constraint	 Â Write	 Â set	 Â Seed	 Â test	 Â for	 Â next	 Â itera+on	 Â New	 Â tests	 Â for	 Â current	 Â itera+on	 Â Figure 8: Dataow diagram of our system.
because they are irrelevant to an app's behavior in subse-
quent events of an event sequence.
5.2 Subject Apps
We used ve open-source Android apps for our studies.
Random Music Player (RMP) is the app that is used as the
example in Section 2. Sprite is an app for comparing the
relative speeds of various 2D drawing methods on Android.
Translate is an app for translating text from one language
to another using Google's Translation service on the Web.
Timer is an app for providing a countdown timer that plays
an alarm when it reaches zero. Ringdroid is an app for
recording and editing ring tones.
5.3 Study 1
The goal of this study is to measure the improvement
in eciency of ACTEve overAllSeqs . First, we per-
formed concolic execution for each subject using ACTEve
andAllSeqs . We usedk=4 for RMP, Translate, and Sprite.
However, because AllSeqs did not terminate for the other
two apps when k=4 in our 12-hour time limit, we used k=3
for Timer and k=2 for Ringdroid. Note that ACTEve ter-
minated for all ve apps even for k=4. In this step, we
used 16 concurrently running emulators to execute tests and
compute path constraints for corresponding program paths.
Second, for each algorithm, we computed three metrics:
1. The running time of the algorithm.
2. The number of feasible paths that the algorithm nds.
3. The number of satisability checks of path constraints
that the algorithm makes.
We measure the running time of the algorithms (metric
(1)) because comparing them lets us determine the eciency
ofACTEve overAllSeqs . However, by considering only
running time, it may be dicult to determine whether the ef-
ciency of our algorithm will generalize to other application
domains and experimental setups. Furthermore, we need to
verify that the savings in running time is due to the reduc-
tion provided by our algorithm. Thus, we also compute the
other two metrics (metrics (2) and (3)).
Figure 9 shows the results of the study for our subjects. In
the gure, the horizontal axis represents the three metrics,
where each cluster of bars corresponds to one metric. Within
each cluster, the ve bars represent the corresponding metric
 0 20 40 60 80 100
    Running time
   (hours)      #feasible paths
    (x 1000)         #constraint checks
       (x 1000)ACTEve  as % of AllSeqsRMP
2.7 4.0 6.7Translate
1.5 1.7 4.1Sprite
1.0 1.11.9Timer
0.4 0.6 1.8Ringdroid
0.3 0.31.2Figure 9: Results of Study 1: Running time, number
of feasible paths explored, and number of constraint
checks made by ACTEve normalized with respect to
those metrics for AllSeqs .
for the ve subjects. In the rst cluster, the height of each
bar represents the normalized ratio (expressed as a percent-
age) of the running time of ACTEve to that of AllSeqs .
The number at the top of each bar in this cluster is the run-
ning time of ACTEve measured in hours. Similarly, in the
second and third clusters, the height of each bar represents
the normalized ratio of the number of feasible paths explored
and the number of constraint checks made, respectively, by
ACTEve to the corresponding entities for AllSeqs . The
number at the top of each bar in the second and third clus-
ters is the number of feasible paths explored and the number
of constraint checks made, respectively, by ACTEve . For
brevity, these numbers are rounded, and shown as multiples
of a thousand. For example, the rst cluster shows the ratio
of the running time of ACTEve to that of AllSeqs : RMP
is 18%; Translate is 15%; Sprite is 5%; Timer is 11%; Ring-
droid is 36%. This cluster also shows that the running time
ofACTEve is 2.7 hours for RMP, 1.5 hours for Translate,
1 hour for Sprite, 0.4 hours for Timer, and 0.3 hours for
Ringdroid.
The results of the study show that ACTEve is signi-
cantly more ecient than AllSeqs .ACTEve requires only
a small fraction (5%{36%) of the running time of AllSeqs
to achieve the same completeness guarantee. Thus, us-
ingACTEve provides signicant savings in running time
overAllSeqs (64%{95%). The results also illustrate why
the running time for ACTEve is signicantly less than for
AllSeqs :ACTEve explores only 4.4%{35.5% of all feasible
paths that AllSeqs explores; ACTEve checks signicantly
fewer constraints (6.2%{33.1%) than AllSeqs .
5.4 Study 2
The goal of this study is to record the number of paths
pruned by ACTEve because this reduction in the number
of paths explored highlights why ACTEve is more ecient
thanAllSeqs . To do this, we performed concolic execution
of each app for k=4, and we recorded the following informa-
tion for each iteration of ACTEve andAllSeqs :
1. The number of feasible paths that symex explores; re-
call that symex explores new feasible paths.
2. The number of feasible paths that remain after prune . 1 10 100 1000 10000 100000
symex(1) prune(1) symex(2) prune(2) symex(3) prune(3) symex(4)# feasible program paths
(using log scale)Translate
AllSeqs
ACTEveFigure 10: Results of Study 2 for translate app: The
number of paths (using a logarithmic scale) after
symex and prune operations in each iteration.
Figure 10 shows the results of the study for one subject
app; the results for the remaining apps are similar, and are
shown in Appendix D in [2]. In each graph, the horizontal
axis represents the symex and prune operations performed in
each iteration. The vertical axis shows the number of paths
using a log scale. For example, the graph for Translate in
Figure 10 shows that ACTEve explores 274 paths in itera-
tion 3. The subsequent pruning step lters out 149 paths.
Thus, only the remaining 125 paths are extended in iteration
4. In contrast, AllSeqs explores 1,216 paths in iteration 3,
all of which are extended in iteration 4.
The results clearly show the improvement achieved by the
pruning that ACTEve performs. First, the graphs show
thatACTEve explores many fewer paths than AllSeqs ,
and the rate of improvement increases as the number of it-
erations increases. For example, in the fourth iteration of
symex ,ACTEve explores 1,402 paths and AllSeqs has ex-
plored 13,976 paths. Second, the graphs also show that, at
each iteration of prune , the number of paths that will then be
extended decreases: the descending line in the graphs repre-
sents the savings that prune produces. In contrast, the hor-
izontal line for the same interval corresponding to AllSeqs
shows that no pruning is being performed.
5.5 Threats to Validity
There are several threats to the validity of our studies.
The main threat to internal validity arises because our sys-
tem is congured to ignore writes to certain elds that do not
aect an app's behavior (see Section 5.1 under \Subsump-
tion analyzer"). We mitigate this threat in two ways. First,
our implementation ignores only elds of Android's inter-
nal classes that are clearly irrelevant to an app's behavior;
it never ignores elds of app classes, third-party libraries,
or elds of Android classes (e.g., widgets) that store values
that can be read by an app. Second, we ran our system
using the AllSeqs algorithm (that performs no pruning),
and checked if any ignored eld is written in one event and
read in a later event of an event sequence. Most of the elds
that our system is congured to ignore are never read and
written across events. For the few that were, we manually
conrmed that it is safe to ignore them.
Threats to external validity arise when the results of the
experiment cannot be generalized. We evaluated our tech-
nique with only ve apps. Thus, the eciency of our tech-
nique may vary for other apps. However, our apps are rep-
resentative of typical Android apps considering the problem
that our technique addresses.6. RELATED WORK
Memon [21] presented the rst framework for generating,
running, and evaluating GUI tests. Several papers (e.g.,
[5, 23, 24, 35]) present components and extensions of this
framework. Most existing GUI testing approaches either use
capture-replay to infer the GUI model automatically [22, 31]
or require users to provide the GUI model [34, 36]. An ex-
ception is the work of Ganov et al. [11], which uses symbolic
execution to infer data inputs to GUI components. Our
work also uses symbolic execution but focuses on event in-
puts. Our techniques for eciently generating sequences of
events are complementary to the above approaches.
Signicant advances have been made in recent years to
alleviate path explosion in concolic testing. These in-
clude compositional testing (e.g., [1, 12]), using program
dependence information to avoid analyzing redundant paths
(e.g., [4, 20, 27, 28]), using input grammars (e.g., [14]), using
models of library classes (e.g., [18]) or constraint solvers that
support higher-level program abstractions (e.g, [3, 33]), and
using path-exploration heuristics that cover deep internal
parts of a program (e.g., [19, 26]). Our input subsumption
idea is complementary to the above ideas for taming path
explosion. Our system indeed leverages some of the above
ideas. It uses (1) method summaries and models for certain
Android framework classes, (2) a grammar to specify input
events, and (3) state-of-the-art constraint solving provided
by the Z3 SMT solver.
7. CONCLUSION AND FUTURE WORK
In this paper, we presented a technique, ACTEve to au-
tomatically and systematically generate input events to ex-
ercise smartphone apps. We described our system that im-
plements ACTEve for Android, and presented the results
of our empirical evaluation of the system on ve real apps.
The results showed that for our subjects, ACTEve is sig-
nicantly more ecient than the naive concolic execution
technique, referred to as AllSeqs .
We have at least three important directions for future
work. First, ACTEve only alleviates path explosion. The
improved eciency of ACTEve overAllSeqs may not be
sucient to handle apps that have signicantly more paths
than our subjects. An example of such an app is one that has
many widgets (e.g., a virtual keyboard). We plan to study
other subsumption patterns besides the read-only pattern
that we currently exploit to tame path explosion. The inde-
pendence pattern described in Appendix C in [2] is an ex-
ample. Second, our system currently handles only one type
of events (i.e., tap events). There are many other types of
events such as incoming phone calls and gestures. Extend-
ing our system to handle other types of events will widen its
applicability to more apps. Third, we intend to conduct a
more exhaustive empirical evaluation with more subjects to
further conrm ACTEve 's improvement over AllSeqs .
Acknowledgments
We thank the anonymous reviewers for insightful comments,
and Xin Zhang for helpful discussions. This work was sup-
ported in part by a faculty research award from Google,
grants from EPSRC and BIS London, and NSF CCF-
0541048, NSF CCF-0964647, NSF CCF-1116210, ABB Inc.,
and an IBM Software Quality Innovation Award.References
[1] S. Anand, P. Godefroid, and N. Tillmann. Demand-
driven compositional symbolic execution. In TACAS ,
pages 367{381, 2008.
[2] S. Anand, M. Naik, H. Yang, and M. J. Harrold. Au-
tomated concolic testing of smartphone apps. Number
GIT-CERCS-12-02, March 2012.
[3] N. Bjrner, N. Tillmann, and A. Voronkov. Path fea-
sibility analysis for string-manipulating programs. In
TACAS , pages 307{321, 2009.
[4] P. Boonstoppel, C. Cadar, and D. R. Engler. RWset:
Attacking path explosion in constraint-based test gen-
eration. In TACAS , pages 351{366, 2008.
[5] R. C. Bryce, S. Sampath, and A. M. Memon. Develop-
ing a single model and test prioritization strategies for
event-driven software. TSE, 37(1):48{64, 2011.
[6] C. Cadar, D. Dunbar, and D. R. Engler. KLEE: Unas-
sisted and automatic generation of high-coverage tests
for complex systems programs. In OSDI , pages 209{
224, 2008.
[7] B.-G. Chun, S. Ihm, P. Maniatis, M. Naik, and A. Patti.
Clonecloud: elastic execution between mobile device
and cloud. In EuroSys , pages 301{314, 2011.
[8] L. M. de Moura and N. Bjrner. Z3: An ecient SMT
solver. In TACAS , pages 337{340, 2008.
[9] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox,
J. Jung, P. McDaniel, and A. Sheth. Taintdroid: An
information-ow tracking system for realtime privacy
monitoring on smartphones. In OSDI , pages 393{407,
2010.
[10] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner.
Android permissions demystied. In CCS, pages 627{
638, 2011.
[11] S. R. Ganov, C. Killmar, S. Khurshid, and D. E. Perry.
Event listener analysis and symbolic execution for test-
ing GUI applications. In ICFEM , pages 69{87, 2009.
[12] P. Godefroid. Compositional dynamic test generation.
InPOPL , pages 47{54, 2007.
[13] P. Godefroid. Higher-order test generation. In PLDI ,
pages 258{269, 2011.
[14] P. Godefroid, A. Kiezun, and M. Y. Levin. Grammar-
based whitebox fuzzing. In PLDI , pages 206{215, 2008.
[15] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed
automated random testing. In PLDI , pages 213{223,
2005.
[16] P. Godefroid, M. Y. Levin, and D. A. Molnar. Auto-
mated whitebox fuzz testing. In NDSS , 2008.
[17] P. Godefroid and D. Luchaup. Automatic partial loop
summarization in dynamic test generation. In ISSTA ,
pages 23{33, 2011.
[18] S. Khurshid and Y. L. Suen. Generalizing symbolic
execution to library classes. In PASTE , pages 103{110,
2005.
[19] R. Majumdar and K. Sen. Hybrid concolic testing. In
ICSE , pages 416{426, 2007.[20] R. Majumdar and R.-G. Xu. Reducing test inputs using
information partitions. In CAV , pages 555{569, 2009.
[21] A. M. Memon. A comprehensive framework for testing
graphical user interfaces . Ph.D., Univ. of Pittsburg,
2001.
[22] A. M. Memon, I. Banerjee, and A. Nagarajan. GUI
ripping: Reverse engineering of graphical user inter-
faces for testing. In Working Conference on Reverse
Engineering , pages 260{269, 2003.
[23] A. M. Memon, M. E. Pollack, and M. L. Soa. Au-
tomated test oracles for GUIs. In FSE, pages 30{39,
2000.
[24] A. M. Memon and M. L. Soa. Regression testing of
GUIs. In ESEC/FSE , pages 118{127, 2003.
[25] D. Octeau, S. Jha, and P. McDaniel. Retargeting an-
droid applications to java bytecode. In FSE, 2012.
[26] C. S. Pasareanu, P. C. Mehlitz, D. H. Bushnell,
K. Gundy-Burlet, M. R. Lowry, S. Person, and M. Pape.
Combining unit-level symbolic execution and system-
level concrete execution for testing NASA software. In
ISSTA , pages 15{26, 2008.
[27] D. Qi, H. D. T. Nguyen, and A. Roychoudhury. Path
exploration based on symbolic output. In FSE, pages
278{288, 2011.
[28] R. A. Santelices and M. J. Harrold. Exploiting pro-
gram dependencies for scalable multiple-path symbolic
execution. In ISSTA , pages 195{206, 2010.
[29] P. Saxena, P. Poosankam, S. McCamant, and D. Song.
Loop-extended symbolic execution on binary programs.
InISSTA , pages 225{236, 2009.
[30] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic
unit testing engine for C. In ESEC/FSE , pages 263{
272, 2005.
[31] T. Takala, M. Katara, and J. Harty. Experiences of
system-level model-based GUI testing of an Android
application. In ICST , pages 377{386, 2011.
[32] R. Vall ee-Rai, L. Hendren, V. Sundaresan, P. Lam,
E. Gagnon, and P. Co. Soot - A Java optimization
framework. In Conference of the Centre for Advanced
Studies on Collaborative Research , pages 125{135, 1999.
[33] M. Veanes, P. de Halleux, and N. Tillmann. Rex: Sym-
bolic regular expression explorer. In ICST , pages 498{
507, 2010.
[34] L. J. White and H. Almezen. Generating test cases
for GUI responsibilities using complete interaction se-
quences. In ISSRE , pages 110{123, 2000.
[35] X. Yuan, M. B. Cohen, and A. M. Memon. GUI in-
teraction testing: Incorporating event context. TSE,
37(4):559{574, 2011.
[36] X. Yuan and A. M. Memon. Generating event sequence-
based test cases using GUI runtime state feedback.
TSE, 36(1), 2010.APPENDIX
This appendix consists of the four parts. In Appendix A,
we explain the rules for deriving the evaluation relations in
our operational semantics. In Appendix B, we prove the
lemmas and the theorem presented in the main text of the
paper. In Appendix C, we present another implementation
of pruning that uses the notion of independence. Finally, in
Appendix D, we present the rest of the graphs for the results
in Study 2.
A. RULES FOR EVALUATION
RELATIONS
Rules for the evaluation relations are given in Figure 11.
Most of the rules in the gure follow from our intended read-
ing of all the parts in the evaluation relations. For example,
the rst rule for the conditional statement says that if the
boolean condition bevaluates to true, we extend the Ccom-
ponent of a symbolic state with the result b0of symbolically
evaluating the condition b, and follow the true branch.
The only unusual rule is the second one in (3) for eval-
uating input event sequences. This rule describes how to
thread the iterative execution of a program. One unusual
aspect is that the symbolic global state and the path con-
straint are reset for each input event. This ensures that
the path constraint of a nal concolic state restricts only
the current input event, not any previous ones, in the input
sequence.
B. PROOFS OF LEMMAS AND THEOREM
In this part of the appendix, we provide proofs of Lem-
mas 1 and 2 stated in Section 4.4 and Lemma 3 and Theo-
rem 4 stated in Section 4.5 in the main text of the paper.
B.1 Proof of Lemma 1
Lemma 1.For setsT;T0of feasible traces,
TvT0=)symex (sin;in;T)vsymex (sin;in;T0):
Proof. Pickfrom symex (sin;in;T). We show show that
some0insymex (sin;in;T0) satisesv0. By the de-
nition of symex (sin;in;T), there exist a feasible trace , a
path constraint C, and a setWof global variables such that
2T^=hC;Wi:
By assumption that TvT0, the rst conjunct above implies
the existence of 02T0satisfyingv0.
We now claim that 0hC;Wiis the desired trace 0. To
show this claim, it is sucient to prove that nal(hC;Wi)
is a subset of nal(0hC;Wi). The feasibility of 0hC;Wi
follows from this. Pick 1from nal(hC;Wi). Then, there
exist02nal(),n, and   such that
hsin;n;h0;0;ii # h1; ;Ci. W: (4)
Since nal()nal(0), the global state 0must be in
nal(0), meaning that for some 0,
hsin;0;ini +0. 0: (5)
From (5) and (4) follows that
hsin;0n;ini +0. 0hC;Wi:
Hence,1is in nal(0hC;Wi), as required.B.2 Proof of Lemma 2
Lemma 2.For all sets T;T0of feasible traces, if TvT0,
we have that
Sfbranch ((jj):C)j2symex (sin;in;T)g
Sfbranch ((jj):C)j2symex (sin;in;T0)g:
Proof. We will show that for all 2symex (sin;in;T), there
exists02symex (sin;in;T0) satisfying
branch ((jj):C)branch ((0
j0j):C):
Pickfrom symex (sin;in;T). Then,is feasible and has
length at least 1. Also, there exist a feasible trace , a path
constraintC, and a set of global variables Wsuch that
=hC;Wi ^2T:
SinceTvT0, there should be 02T0with
v0:
Let0=0hC;R;Wi. It is sucient to prove that 0is
feasible. Since is feasible and it is hC;Wi, there exist n,
0,1, and   1such that
02nal()^ hsin;n;h0;0;ii+h1; 1;Ci.W: (6)
Sincev0,0is also in nal(0). This and the second
conjunct of (6) imply that 0hC;Wiis feasible.
B.3 Proof of Lemma 3
Lemma 3.For all sets of feasible traces, rprune () is
a subset of and satises the condition in (1).
Proof. Let  = rprune (). Because of the denition of
rprune ,  has to be a subset of . It remains to prove that
the condition in (1) holds for  and . Pick in . We
should nd 0in [sprex () such that v00. Ifis in
, we can choose itself as00. The condition v00holds
because of the reexivity of v. Ifis not in , we must
have thatjj1 and (jj):W=;. Letbe the prex of 
that has lengthjj 1. Then,is feasible, and it belongs to
sprex (). Furthermore, nal()nal(), since the addi-
tional last step of denotes read-only computations. Hence,
v. From what we have just shown follows that is the
desired feasible trace.
B.4 Proof of Theorem 4
Theorem 4.For everyk1,
branch (ACTEve (sin;in;k))
=branch (Sk
i=0symexi(sin;in;fg)):
Proof. The LHS of the equation is a subset of the RHS,
because
ACTEve (sin;in;k)k[
i=0symexi(sin;in;fg)
and the branch operator is monotone with respect to the
subset relation. In the remainder of this proof, we show
that the RHS is also a subset of the LHS.hs; n; !i #!0. W
hskip; n; !i #! .;
hg=e; n; !i # h!:[g:n0]; !: [g:e0]; !:Ci.fgg[where JeK(n;!) =n0and JeKs(!) =e0]
hs1; n; ! [C: (!:C)b0hl;truei]i #!0. W
hifbls1elses2; n; !i #!0. W[ifJbK(n;!) =true and JbKs(!) =b0]
hs2; n; ! [C: (!:C)(:b0)hl;falsei]i #!0. W
hifbls1elses2; n; !i #!0. W[ifJbK(n;!) =false and JbKs(!) =b0]
hs1; n; !i #!0. Whs2; n; !0i #!00. W0
hs1;s2; n; !i #!00. W[W0
hs; n; ! [C: (w:C)b0hl;truei]i #!0. W0hwhilebls; n; !0i #!00. W00
hwhilebls; n; !i #!00. W0[W00[ifJbK(n;!) =true and JbKs(!) =b0]
hwhilebls; n; !i #![C: (w:C)(:b0)hl;falsei].;[ifJbK(n;!) =false and JbKs(!) =b0]
hs;;i +0. 
hs;;i + . (2)
hs;n;h;;ii #! . Whs;;!:i +0. 0
hs;n;i +0.h!:C;Wi0(3)
Figure 11: Concolic execution semantics.
LetFbe a function on sets of traces given by F(T) =
symex (sin;in;T). Dene the operator lbranch on such trace
sets by:
lbranch (T) =[
fbranch ((jj):C)j2T^jj1g:
Intuitively, this operator collects every branch covered by
the last step of some trace in T.
We will use the following three facts that hold for all jin
f0;:::;k 1g:
Sj
i=0ivSj
i=0i;Sj
i=0Fi(fg)vSj
i=0i;
branch (Sj+1
i=0Fi(fg)) = lbranch (Sj+1
i=1Fi(fg)):
Here iand iare the trace sets that ACTEve computes.
We prove all of these facts simutaneously by induction on j.
The base cases are immediate from the denitions of Fi, i
and i.
The inductive case of the rst fact is proved as follows:
Sj+1
i=0i= (Sj
i=0i)[j+1
v(Sj
i=0i)[sprex (j+1)[j+1
(Sj
i=0i)[j+1
v(Sj
i=0i)[j+1= (Sj+1
i=0i):
The sprex (j+1) in the rst line is the set of all strict pre-
xes of  j+1(i.e., sprex (j+1) =fj90:j0j1^02
j+1g). The derivation proves (Sj+1
i=0i)v(Sj+1
i=0i), be-
causeTT0impliesTvT0and the subsumption vis reexive and transitive. Also, the derivation uses only
true steps, as it should. The second step holds because
prune (j+1) = j+1, the result of the prune operation sat-
ises the subsumption relationship in (1) (Section 4.4), and
the union operator is monotone with respect to v. The third
step holds because sprex (j+1)Sj
i=0i. The fourth
step follows from the induction hypothesis.
For the inductive case of the second fact, we notice that
Fj+1(fg)F(Sj
i=0Fi(fg))vF(Sj
i=0i)
=Sj
i=0F(i) =Sj+1
i=1i
Sj+1
i=0ivSj+1
i=0i
The rst step uses the monotonicity of Fwith respect to the
subset relation, and the second uses the induction hypothe-
sis and the fact that Fpreserves subsumption (Lemma 1).
The third holds because Fpreserves union. The fourth
step follows the denition of  i, and the last step from
the inductive step of the rst fact, which we have already
proved. Since the relation vincludes the subset relation and
is reexive and transitive, the above derivation shows that
Fj+1(fg)vSj+1
i=0i. Combining this and the induction
hypothesis, we get the desired
j+1[
i=0Fi(fg) =Fj+1(fg)[j[
i=0Fi(fg)vj+1[
i=0i:
Here we use the fact that the union operator is monotone
with respect tov.Algorithm 3 The iprune operation
INPUTS: Set  of traces.
OUTPUTS: Set  of traces.
 =;
forevery2do
ifthere is some trace ( 0)2 such that
(1)=0and
(2)i:R\0
j:W=i:W\0
j:R=i:W\0
j:W=;
for alliandj
then
skip
else
 = [fg
end if
end for
return 
For the inductive case of the third fact, we observe that
branch (Fj+2(fg)) is a subset of
branch (Fj+1(fg))[lbranch (Fj+2(fg)):
This superset itself is included in
lbranch (j+1[
i=1Fi(fg))[lbranch (Fj+2(fg))
because of the induction hypothesis. Using this observation
and the induction hypothesis again, we complete the proof
of this inductive case as follows:
branch (Sj+2
i=0Fi(fg))
=branch (Sj+1
i=0Fi(fg))[branch (Fj+2(fg))
lbranch (Sj+1
i=1Fi(fg))[lbranch (Fj+2(fg))
=lbranch (Sj+2
i=1Fi(fg)):
The two equalities here use the fact that lbranch preserves
the union operator.
Using the three facts just shown, we can complete the
proof of this theorem as follows:
branch (Sk
i=0Fi(fg)) = lbranch (Sk
i=1Fi(fg))
= (lbranchF)(Sk 1
i=0Fi(fg))
(lbranchF)(Sk 1
i=0i)
=lbranch (Sk 1
i=0F(i))
=lbranch (Sk
i=1i)
lbranch (ACTEve (sin;in;k)):
The rst step is by the third fact, and the second and fourth
steps hold because Fpreserves the union operator. The
third step follows from the second fact and Lemma 2. The
last two steps are just the unrolling of the denitions of  i
and the result of ACTEve (sin;in;k).C. INDEPENDENCE-BASED PRUNING
Algorithm 3 gives another implementation of prunning,
called iprune , which exploits a form of independence. This
implementation assumes that the evaluation relations track
a set of read global variables, in addition to written ones.
This means that the forms of evaluation relations are
changed to
hs;n;!i#!0. W;Rhs;;i+0. ;
whereRis a set of read variables and is now a sequence
of triplesC;W;R . Also, the rules for these relations are
changed appropriately. Lemmas 1 and 2 in Section 4.4
and Theorem 4 in Section 4.6 remain valid even with these
changes.
The iprune operator detects two traces ;0in  such
thatcan be obtained by swapping independent consecu-
tive parts in 0. In Figure 3, 0corresponds to 0, and
and0represent consecutive independent parts. Although
theiprune operator is not implemented in our system, it il-
lustrates the generality of using our subsumption condition.
The following lemma shows that iprune satises the condi-
tion.
Lemma 5. The result of iprune is a subset of its input trace
set, and it always satiss the subsumption relationship in (1)
(Section 4.5).
Proof. Consider a set  of feasible traces, and let  =
iprune (). From the denition of iprune , it is immediate
that  is a subset of . To prove that  also satises the
condition in (1), pick from . We will have to nd 0in
 such that v0. Ifis aleady in , we can just use 
for0. Suppoes that is not in . Then, by the denition
of our algorithm, there must be a feasible trace ( 0) in 
such that (1) =0and (2) for all iandj,
(i):R\(0
j):W= (i):W\(0
j):R= (i):W\(0
j):W=;:
Since  is a subset of  throughout the execution of iprune ,
we know that 0is a feasible trace. Furthermore, the two
properties of this trace above imply that
nal() =nal(0);
sov(0). From what we have just proven so far follows
that0is the trace 0that we are looking for.
D. RESULTS OF STUDY 2
In Study 2 (Section 5.4), we presented the results for one
of the subject apps. In this part of the Appendix, we present
the results for the rest of the subject apps.
The graphs in Figure 12 provide these results. As the
graphs show, the results are similar to those discussed in Sec-
tion 5.4, and show the same reduction in feasible paths ex-
plored and constraints checked of ACTEve overAllSeqs . 1 10 100 1000 10000 100000
symex(1) prune(1) symex(2) prune(2) symex(3) prune(3) symex(4)# feasible program paths
(using log scale)RMP
AllSeqs
ACTEve
 1 10 100 1000 10000 100000
symex(1) prune(1) symex(2) prune(2) symex(3) prune(3) symex(4)# feasible program paths
(using log scale)Sprite
AllSeqs
ACTEve
 1 10 100 1000 10000 100000
symex(1) prune(1) symex(2) prune(2) symex(3) prune(3) symex(4)# feasible program paths
(using log scale)Timer
AllSeqs
ACTEve
 10 100 1000 10000 100000
symex(1) prune(1) symex(2) prune(2) symex(3)# feasible program paths
(using log scale)Ringdroid
AllSeqs
ACTEveFigure 12: Results of Study 2: The number of paths
(using a logarithmic scale) after symex and prune op-
erations in each iteration. Because AllSeqs does
not terminate for Timer and Ringdroid when k=4,
the reported nal numbers of paths for those two
apps correspond to the time when the time-limit
(12-hours) was met.