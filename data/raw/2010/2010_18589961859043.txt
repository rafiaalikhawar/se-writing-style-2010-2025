A Bounded Statistical Approach for Model Checking
of Unbounded Until Properties
Ru He
Dept. of Computer Science
Iowa State University
rhe@iastate.eduPaul Jennings
Dept. of Computer Science
Iowa State University
poj@iastate.eduSamik Basu
Dept. of Computer Science
Iowa State University
sbasu@iastate.edu
Arka P . Ghosh
Dept. of Statistics
Iowa State University
apghosh@iastate.eduHuaiqing Wu
Dept. of Statistics
Iowa State University
isuhwu@iastate.edu
ABSTRACT
We study the problem of statistical model checking of proba-
bilistic systems for PCTL unbounded until property
P1p(ϕ1Uϕ2) (where 1∈{<,≤,>,≥}) using the computa-
tion ofP≤0(ϕ1Uϕ2). The approach is ﬁrst proposed by Sen
et al. in CAV’05 but their approach suﬀers from two draw-
backs. Firstly, the computation of P≤0(ϕ1Uϕ2) requires for
its validity, a user-speciﬁed input parameter δ2which the
user is unlikely to correctly provide. Secondly, the validity
of computation of P≤0(ϕ1Uϕ2) is limited only to proba-
bilistic models that do not contain loops. We present a new
technique which addresses both problems described above.
Essentially our technique transforms the hypothesis test for
the unbounded until property in the original model into a
new equivalent hypothesis test for bounded until property in
our modiﬁed model. We empirically show the eﬀectiveness
of our technique and compare our results with those using
the method proposed by Sen et al.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
ﬁcation— Model Checking ; G.3 [ Probability and statis-
tics]: [Probabilistic Algorithms]
General Terms
Veriﬁcation
Keywords
Hypothesis Testing, DTMC, PCTL
1. INTRODUCTION
Statistical model checking techniques ([19, 11, 16]) based
on Monte Carlo simulations have been proposed and de-
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.veloped for verifying probabilistic systems (Discrete Time
Markov Chains, DTMC; Continuous Time Markov Chains,
CTMC; semi-Markov Chains [5]) where traditional (numer-
ical) veriﬁcation may become unusable due to state-space
explosion problem. The state-space explosion problem is
addressed eﬀectively by statistical methods because these
methods only require some succinct representation [11] of
the system being model checked instead of storing its state
space. The central theme of statistical model checking is
that the veriﬁcation of properties is based on only a ﬁnite
set of sample simulation paths of the system and the result
is computed within a pre-speciﬁed error limit.
One of the main challenges in the eﬀective application of
the statistical model checking for probabilistic systems is the
veriﬁcation problem of PCTL/CSL([9, 1]) until properties of
the form P1p(ϕ1Uϕ2), where 1∈{≤,≥,<,>}andp∈
[0,1]. This is to verify whether a path starting from a state
in the system satisﬁes ϕ1Uϕ2with probability 1p. A path
satisﬁesϕ1Uϕ2if and only if there exists some state sj
in the path (of any length) that satisﬁes ϕ2and in all the
states before sjin the path ϕ1is satisﬁed. The challenge
stems from the fact that statistical methods rely on pre-
speciﬁed ﬁnite length simulations and this may lead to the
existence of some ﬁnite simulation where every state satisﬁes
ϕ1but no states satisfy ϕ2. As a result it cannot be inferred
(decided ) whetherϕ1Uϕ2is satisﬁed or not along such a
simulation path. In this paper, we will also refer to until
path property ϕ1Uϕ2asunbounded until path property.
To counter this problem, Sen et al. [16] propose a statis-
tical model checking algorithm based on Monte Carlo sim-
ulation and hypothesis testing. The key aspect of their ap-
proach is the introduction of a basis procedure which is re-
peatedly used to verify P1p(ϕ1Uϕ2) within a given error
bound. The basis procedure is essentially a speciﬁc statis-
tical hypothesis test: P≤0(ϕ1Uϕ2), i.e., whether a state is
the root of some path satisfying ϕ1Uϕ2.
It is worth mentioning here that before Sen et al. propose
their statistical-version solution, the numerical method for
verifying PCTLproperty P≤0(ϕ1Uϕ2) [9] has already existed,
which is equivalent to verifying ¬E(ϕ1Uϕ2) (non proba-
bilisticCTLproperty) using traditional (non-probabilistic)
model checking method [6]. The underlying reason is be-
cause zero or non-zero probabilistic check depends only on
the topology of the transitions and not on the actual values
of the transition probabilities, which is similar to the fact
225
mentioned by Hart et al. [10] in early 1980’s. However, the
traditional model checking algorithm for ¬E(ϕ1Uϕ2) suﬀers
from state-space explosion problem, the main target that all
the statistical methods intend to address. Therefore, since
the statistical solution for P≤0(ϕ1Uϕ2) proposed by Sen
et al. really avoids the corresponding state-space explosion
problem, it has its importance and usefulness.
The basis procedure proposed by Sen et al. relies on the
transformation of the model Mwhere a terminal state is
introduced such that it is reachable from every state in one
step with a small stopping probability ps. This transforma-
tion forces every simulation in the modiﬁed model to eventu-
ally terminate with a decided result, i.e., ϕ1Uϕ2is satisﬁed
or not satisﬁed.
An important user-speciﬁed parameter δ2, necessary for
the validity of the basis procedure as proposed in [16], de-
pends directly on the actual probability of satisfying the
given until property ϕ1Uϕ2by any state. As it is impossi-
ble for the user to know this probability value a priori, it is
also not possible to appropriately choose δ2. Furthermore,
as the basis procedure is iteratively applied by the general
procedure for verifying the general unbounded until prop-
ertyP1p(ϕ1Uϕ2), invalidity of the basis procedure will be
accumulated and will result in the invalidity of the veriﬁ-
cation result for the general unbounded until property as
well. Another important and more severe drawback of the
basis procedure is that in general it is not valid for models
containing loops; Younes and Simmons [20] point out this
ﬂaw in the validity of the proof of Theorem 2 in [16] (see
Section 2.2 for our discussion).
We acknowledge the usefulness of the statistical method
developed by Sen et al. [16] and address the above draw-
backs by proposing a new method for solving the basis pro-
cedure. The main idea of our solution is to update the tran-
sition probabilities of the model Mto obtainM/primeinstead of
introducing a terminal state and changing the model struc-
ture as proposed in [16]. For any state swith an outgo-
ing branching factor ds, our update amounts to changing
the probability of each outgoing transition to 1 /ds. We
prove that the original hypothesis testing applied to veri-
fyingP≤0(ϕ1Uϕ2) at a state sinMis exactly equivalent
to a modiﬁed hypothesis testing in M/prime. We establish that
testing inM/primerequires every simulation to run till a ﬁnite
boundN−1, whereNis the number of states in the model.
That is, in essence, we reduce the veriﬁcation of unbounded
until property in Mto a veriﬁcation problem for bounded
(≤N−1) until property in M/prime. We present a procedure for
the hypothesis testing within any user-speciﬁed error limit.
Our method eliminates the requirement of providing psorδ2
(as in [16]) and is applicable to models with any structure.
Furthermore, like other statistical methods [19, 11, 16], our
proposed method only requires a succinct representation of
the model M, does not store any state while exploration,
and therefore avoids state-space explosion problem (at the
cost of computing results within a pre-speciﬁed error limit).
Contributions.
1. We present a new statistical procedure to check the
PCTLunbounded until formula P≤0(ϕ1Uϕ2), which is
applicable to any models and can be seamlessly used
by the general procedure in [16] for the veriﬁcation of
general property P1p(ϕ1Uϕ2).
2. We transform a hypothesis testing problem of unbounded
until properties in a model Minto an exactly equiva-lent hypothesis testing problem in a modiﬁed model
M/primeand ensure that each simulation path length is
bounded by the number of states in the model. To
the best of our knowledge, none of the existing statis-
tical methods are able to provide such a ﬁnite bound
for verifying unbounded until property.
3. Our hypothesis testing is based on a modiﬁed model
M/primeofMwhere the modiﬁcation is independent of the
transition probabilities of M. As such, the testing re-
sult forM/primeis applicable not only for the original model
Mbut also for all other models (a) with the same tran-
sition structure as Mand (b) with the same proposi-
tions labeling each state as in M. This aspect allows
for the re-use of the veriﬁcation result of our basis pro-
cedure for the class of similar models. Re-use, in turn,
reduces the veriﬁcation eﬀort when a large number of
these similar models are being veriﬁed against the same
probabilistic until property.
Organization. Section 2 provides an overview of the pre-
liminary concepts and deﬁnitions that will be used in the
rest of the paper. Section 3 describes our solution method-
ology, while Section 4 discusses the theoretical bounds of
simulations in our method. Section 5 presents our experi-
mental results and empirically shows the eﬀectiveness of our
techniques. Finally, Section 6 discusses related work and
Section 7 discusses some future avenues of research.
2. BACKGROUND
For the purpose of explaining and establishing the theoret-
ical results, we will consider the veriﬁcation of probabilistic
transition systems modeled as DTMC against the proper-
ties expressed by PCTL. The results are directly extensible to
other modeling paradigms (CTMC and semi-Markov chain)
and the corresponding property logics ( CSL) representing un-
til properties.
2.1 Probabilistic Transition Systems and PCTL
Deﬁnition 1 (Probabilistic Transition Systems).
A probabilistic transition system [11] PTS = (S,sI,T,L),
whereSis a ﬁnite set of states, sI∈Sis the initial or start
state,T:S×S→[0,1]is a transition probability function
such that∀s:/summationtext
s/prime∈ST(s,s/prime) = 1, andL:S→P(AP)is the
labeling function which labels each state with a set of atomic
propositions⊆APwhich hold in that state.
Paths and Probability Measures. A path in PTS, de-
noted byπ, is a ﬁnite or inﬁnite sequence of states ( s0,s1,s2,
s3,...) such that for all i≥0 :si∈SandT(si,si+1)>0.
We denote the set of all inﬁnite paths starting from sas
Path(s).π[i] denotes the i-th state in the path πand|π|
is the length of πin terms of the number of transitions in
π. For example, for an inﬁnite path π,|π|=∞, while for
a ﬁnite path π= (s0,...,s n),|π|=n,n≥0. The cylin-
der set, denoted by Cs(π), for a state s, whereπis a ﬁnite
length path starting from s, is deﬁned as Cs(π) ={π/prime:π/prime∈
Path(s)∧πis preﬁx of π/prime}. Essentially, Cs(π) is the set of
all inﬁnite paths ∈Path(s) with the common ﬁnite length
preﬁxπ. For any ﬁnite path πwith|π|=nwe deﬁne
P(π) =/braceleftbigg
1 ifn= 0
T(π[0],π[1])×...×T(π[n−1],π[n]) otherwise
226For a cylinder Cs(π), we deﬁne Pr(Cs(π)) =P(π). It is well-
known that this probability measure Pr(·) extends uniquely
over all sets in the relevant σ−algebra [4].
PCTL Syntax and Semantics. Properties of PTS can
be expressed using PCTL, an extension of standard CTL aug-
mented with probabilistic speciﬁcations. Let ϕrepresent a
state formula and ψrepresent a path formula. Then PCTL
syntax is deﬁned as follows:
ϕ→tt|a∈AP|¬ϕ|ϕ∧ϕ|P1r(ψ)
ψ→ϕUϕ|ϕU≤kϕ
In the above, 1∈{≤,≥,<,>},r∈[0,1] andk∈{0,1,...}.
We always use state formulas ( ϕ) to specify the properties
of a PTS and path formulas ( ψ) only occur inside P1r(.).
A states(or a path π) satisfying a state formula ϕ(or a
path formula ψ) is denoted by s|=ϕ(orπ|=ψ), and is
inductively deﬁned as:
s|=tt for alls∈S
s|=a⇔a∈L(s)
s|=¬ϕ⇔s/negationslash|=ϕ
s|=ϕ1∧ϕ2⇔s|=ϕ1ands|=ϕ2
s|=P1r(ψ)⇔P(s,ψ)1r
In the above, P(s,ψ) =Pr({π∈Path(s) :π|=ψ}). In
other words, s|=P1r(ψ) holds if and only if the probability
thatψis true for an outgoing inﬁnite path from state sis
1r. For any inﬁnite path π:
π|=ϕ1U≤kϕ2⇔∃0≤i≤k:π[i]|=ϕ2∧∀j <i:π[j]|=ϕ1
π|=ϕ1Uϕ2⇔∃i≥0 :π[i]|=ϕ2∧ ∀j <i:π[j]|=ϕ1
We will refer to ϕ1U≤kϕ2as a bounded until path formula
and refer to ϕ1Uϕ2as an unbounded until path formula (or
an until path formula).
Succinct Representation of PTS Model. As in other
statistical methods, our method only requires a succinct rep-
resentation of the model being veriﬁed. The succinct rep-
resentation (see [11]) of a PTS is such that given a state s
in the PTS, the representation allows the generation of the
set of its next states tsuch thatT(s,t)>0. Such represen-
tation typically has a space requirement in the same scale
as the number of variables in the system. Liberatore in
[14] explains a succinct representation of a probabilistic sys-
tem capturing the behavior of ﬂipping ncoins. The DTMC
model of this PTS system contains O(2n) transitions; while
the succinct representation of the same model only considers
2npossible transition relations each capturing the event of
randomly selecting one of the ncoins and tossing it (while
other coins remain unaltered).
2.2 Verifying P1p(ϕ1Uϕ2)usingP≤0(ϕ1Uϕ2)
We present the method proposed by Sen et al. [16] in Al-
gorithms 1 and 2. Algorithm 1, which captures the main
idea of the general procedure, computes the estimate of
P(s,ϕ1Uϕ2) by performing Jsimulations from state sand
computing the proportion of the simulations that satisfy the
given until property (Line 15). If a state in the simulation
path does not satisfy ϕ2, Algorithm 2 (the basis procedure)
is invoked to decide whether the state is the root of any path
satisfyingϕ1Uϕ2(Line 8). Algorithm 2 executes on a mod-
iﬁed model M/primewhere every state can reach a terminal stateAlgorithm 1 Compute P(s,ϕ1Uϕ2)
Require:J(the number of simulations starting from sin
M)
1:X←0
2:for(each simulation πofJsimulations from sinM)
do
3:i←0
4:while (true) do
5: if(π[i]|=ϕ2)then
6:X←X+ 1
7: break
8: else if (Decideπ[i]|=P≤0(ϕ1Uϕ2))then
9: break
10: else
11:i←i+ 1
12: end if
13:end while
14:end for
15: returnX/J
Algorithm 2 Decidet|=P≤0(ϕ1Uϕ2)
Require:α(Type I error limit), δ2
1:K0←log(α)/log(1−δ2)
2:for(each simulation π/primeofK0simulations from tinM/prime)
do
3:if(π/prime|=ϕ1Uϕ2)then
4: return false
5:end if
6:end for
7: return true
(which satisﬁes¬ϕ1∧¬ϕ2) in one step with a pre-speciﬁed
probability ps; all the existing probabilities are accordingly
modiﬁed by multiplying with (1 −ps) such that the sum of
the probabilities of the outgoing transitions of any state is
equal to 1 (see Deﬁnition 1). If Algorithm 2 returns false,
i.e., there exists a path from π[i] inM/primethat satisﬁes ϕ1Uϕ2,
then the process is iterated starting from the next state of
the simulation path (the index of πincrements in Line 11).
There are two problems in Algorithm 2. First, the num-
ber of simulations K0required for Algorithm 2 (Line 1) de-
pends onδ2, a user-speciﬁed parameter. We show that the
correct pre-speciﬁcation of δ2is diﬃcult, if not impossible.
A pre-condition (condition C2 in [16]) necessary for the va-
lidity of the procedure in [16] states that for every state sin
modelM, the probability that a path starting from ssat-
isﬁesϕ1Uϕ2must not lie in the range (0 ,δ2/(1−ps)N],
whereNis the number of states in M, andδ2andpsare
user-speciﬁed positive parameters. In other words, if the
probability of any path satisfying ϕ1Uϕ2isp(>0), then
δ2must be selected such that p > δ 2/(1−ps)N. As it is
unlikely for the user to know p, i.e., P(t,ϕ1Uϕ2) (tbeing
the input state of Algorithm 2), it is not possible to choose
a suitableδ2for the computation of the corresponding K0.
Second , Algorithm 2 is not valid in general for models with
loops. For the validity of Algorithm 2, Sen et al. prove
in their Theorem 2 that for any value of ps(0< p s<1,
pre-speciﬁed by user)
p/prime≥(1−ps)N·p (1)
whereNis the number of states in the original model M;p
22701
2S0 S3S1
f1f1f2q
q
q
02q20q
23q3211
S
Figure 1: Model showing invalidity of [16]
andp/primeare the probabilities that a path satisﬁes ϕ1Uϕ2from
any statetin the original and modiﬁed model respectively.
Here we present a model (Fig. 1) proving the invalid-
ity of the above claim. The states s0ands2satisfyϕ1
and the state s3satisﬁesϕ2; transitions are annotated with
the corresponding probabilities. Let pi=P(si,ϕ1Uϕ2).
Observe that for Fig. 1, p0=q02·p2+q01·p1,p1= 0,
p2=q23·p3+q20·p0, andp3= 1. Therefore, p0=
q02·q23/(1−q02.q20). For the modiﬁed model (with stopping
probability ps),p/prime
0=q02·(1−ps)·p/prime
2+q01·(1−ps)·p/prime
1,
p/prime
1= 0,p/prime
2=q23·(1−ps)·p/prime
3+q20·(1−ps)·p/prime
0, andp/prime
3= 1.
Therefore,p/prime
0=q02·q23·(1−ps)2
1−q02·q20·(1−ps)2. For Equation 1 to
hold, i.e., for satisfying p/prime
0≥(1−ps)4·p0for any value of ps,
the following must hold for any ps:q02.q20≤1
1 + (1−ps)2.
Clearly, this is not true for all psand as such, Theorem 2 in
[16] does not hold. In the following section, we will present
an alternative for Algorithm 2 which solves the above two
problems. That is, our method does not depend on the ac-
tual probability of satisfying ϕ1Uϕ2, and is valid for any
model transition structure (including loops).
3. VERIFYING P≤0(ϕ1Uϕ2): ALTERNATE
FOR ALGORITHM 2
3.1 Balanced Model
We proceed with the deﬁnition of graph-structured equal-
ity between PTS models. Informally, two PTSs are said to
be graph-structured equal if they diﬀer only in the proba-
bilities (/negationslash∈{0,1}) associated with each transition.
Deﬁnition 2 (GS-Equality). For any two PTSs M=
(S,sI,T,L)andM/prime= (S/prime,s/prime
I,T/prime,L/prime),Mis said to be graph-
structured equal to M/prime, denoted as M≡GSM/prime, if and only
if the following holds: S=S/prime,sI=s/prime
I,L=L/prime; and for all
s,t∈SorS/prime:T(s,t) = 0⇔T/prime(s,t) = 0,T(s,t) = 1⇔
T/prime(s,t) = 1, and 0<T(s,t)<1⇔0<T/prime(s,t)<1.
It can be immediately shown that the above relation ≡GS
is an equivalence relation (reﬂexive, symmetric and transi-
tive).
3.1.1 GS-Equivalent Transformation.
The central theme of our technique relies on a speciﬁc
transformation of the original PTS model Msuch that the
transformed model M/primeis GS-equivalent to M. Given a
modelM= (S,sI,T,L), the transformed model M/primeis a
tuple (S,sI,T/prime,L) such that the domain of T/primeis the same
as the domain of T,∀s,t∈S,T(s,t) = 0⇒T/prime(s,t) = 0
and∀s,t∈S,T(s,t)>0⇒T/prime(s,t) = 1/ds; whereds=|{t:T(s,t)>0}|, i.e.,dsis equal to the number of states
reachable from sin one step with the original transition
probability >0. This transformation results in M/primewhich is
GS-equivalent to M(Deﬁnition 2). Note that there are in-
ﬁnitely many GS-Equivalent models of M. We will refer to
M/prime, generated by the above transformation, as the balanced
GS-equivalent of M(see Remark 1 in Subsection 3.2), one
where it is equally likely to traverse in all possible directions
from any state in M/prime. We will show that such a property of
the modelM/primeis ideal for our method.
3.2 Derivation of Equivalent Hypothesis Test
Our method for model checking the PCTLproperty formula
P≤0(ϕ1Uϕ2) in a PTS model Mis based on a hypothesis
testing problem (referred to as H) where
H0(Null Hypothesis) : p>0 versus
H1(Alternative Hypothesis) : p= 0
In the above, p=P(s,ϕ1Uϕ2) =Pr({π∈Path(s) :π|=
ϕ1Uϕ2}). As noted in Sections 1 and 6, the conventional
statistical methods which run Monte Carlo simulations to
directly perform the above test Hcan suﬀer from the draw-
back that some simulations may not lead to a decided result
for any pre-speciﬁed simulation path length. Therefore, the
results ofHmay not be restricted appropriately within the
user-speciﬁed error range. In our approach we ﬁrst obtain
a GS-equivalent M/primeusing the transformation described in
Section 3.1.1. Let N=|S|be the number of the states in
Manddmaxbe the maximum (or some upper bound) of
the out-degrees of all the states in M.1Then we consider a
new hypothesis testing problem (referred to as H/prime) inM/primeas
follows:
H/prime
0:p/prime≥(1/dmax)N−1versusH/prime
1:p/prime= 0
In the above, p/primeis deﬁned as the probability that a ﬁnite
random path of length N−1 starting from ssatisﬁesϕ1Uϕ2
inM/prime. Note that the length bound N−1 has been explicitly
imposed in our new H/prime. In short,
p/prime=P(s,ϕ1U≤N−1ϕ2) (2)
Proposition 1.For any path πinM(orM/prime) satisfying
PCTLpath formula ϕ1Uϕ2, there exists a corresponding path
πsimple which satisﬁes the same formula and πsimple does not
contain any repetition of states.
Proof. The proposition holds due to the fact that π|=
ϕ1Uϕ2iﬀ∃j≥0 :π[j]|=ϕ2∧∀i<j:π[i]|=ϕ1, i.e., there
exists a ﬁnite path π/primewhich is a preﬁx of πsuch that|π/prime|=j
andπ/prime|=ϕ1Uϕ2. Proceeding further, πsimple can always
be constructed from π/primein the following fashion. For every
0≤k<l≤j, ifπ/prime[k] =π/prime[l], every state between π/prime[k+ 1]
andπ/prime[l] (both inclusive) is removed. Note that the path
after each removal still satisﬁes the invariant ϕ1Uϕ2since
ϕ1andϕ2are both state formulas according to the PCTL
syntax. Finally, the path obtained after all the removals
results inπsimple, the one where there is no repetition of
states.
Theorem 1.The hypothesis testing problem HinMis
equivalent to the hypothesis testing problem H/primeinM/prime.
1Note thatNanddmaxare the same across MandM/primesince
M≡GSM/prime.
228Proof. (1) To prove: H0is true inM⇒H/prime
0is true in
M/prime.
H0is true inM
⇒p>0
⇒Pr({π∈Path(s)|π|=ϕ1Uϕ2})>0
⇒There exists a πinM:π[0] =s∧π|=ϕ1Uϕ2
⇒πsimple inM∧πsimple|=ϕ1Uϕ2(Proposition 1)
⇒πsimple inM/prime∧πsimple|=ϕ1Uϕ2(Deﬁnition 2 )
We have established the existence of a simple path πsimple
that satisﬁes ϕ1Uϕ2and|πsimple|≤N−1 (sinceπsimple
contains no repetition of states). Next, let us denote |πsimple|
asj0and consider the probability of any random path πin
M/primeof lengthN−1, which has πsimple as its preﬁx.
j0−1/productdisplay
i=0T/prime(π[i],π[i+ 1]) =j0−1/productdisplay
i=0(1/dπ[i])≥(1/dmax)N−1(3)
In the above dπ[i]denotes the outgoing branching factor of
thei-th state in the path πanddmaxis the maximum out-
going branching factor. Next, consider the following events.
E1={π1:π1is a random path of length N−1 inM/prime
which has the preﬁx πsimple}
E2={π2:π2is a random path of length N−1 inM/prime
which starts at sand satisﬁes ϕ1Uϕ2}
From Equation (3), Pr(E1)≥(1/dmax)N−1. Observe that
paths inE1andE2satisfyϕ1Uϕ2and paths in E1have the
additional constraint that they must have πsimple as the pre-
ﬁx. Therefore, E1⊆E2and in turn, Pr(E2)≥Pr(E1)≥
(1/dmax)N−1. Recall that Pr(E2) =p/prime(Equation 2). Pro-
ceeding further,
H0is true inM
⇒πsimple inM/prime∧πsimple|=ϕ1Uϕ2
⇒p/prime≥(1/dmax)N−1
⇒H/prime
0is true inM/prime
(2) To prove: H/prime
0is true inM/prime⇒H0is true inM:
H/prime
0is true
⇒p/prime≥(1/dmax)N−1
⇒There exists a random path π/primeinM/prime:|π/prime|=N−1∧
π/prime[0] =s∧π/prime|=ϕ1Uϕ2
⇒π/primeis inM∧π/prime|=ϕ1Uϕ2(Deﬁnition 2)
⇒P(s,ϕ1Uϕ2)>0⇒p>0⇒H0is true inM
(3) To prove: H1is true inM⇔H/prime
1is true inM/prime.
The proof is straightforward. H1is true inMif and only
ifp= 0, which in turn ensures that there exists no path
starting from sthat satisﬁes ϕ1Uϕ2. AsM≡GSM/prime(Def-
inition 2), there exists no path in M/primestarting from sthat
satisﬁesϕ1Uϕ2. Therefore, H/prime
1is true inM/prime. The reverse
can be proved in a similar fashion.
There are two important consequences of the validity of
Theorem 1. First, it allows us to transform the Hproblem in
Mto an equivalentH/primeproblem in M/primebased on the existence
of a simple path πsimple inMandM/prime. As|πsimple|≤N−1,whereNis the number of states in the model, simulation
runs of length N−1 is suﬃcient to test H/primeand therefore,H.
Observe that, we do not care whether each simulation path
of length at most N−1 is a simple path or not. In the proof
of Theorem 1 we have already shown that the probability
that a ﬁnite path of length N−1 fromssatisﬁesϕ1Uϕ2in
M/primeis at least (1 /dmax)N−1. This addresses the problem of
identifying the simulation length bounds for statistically ver-
ifying unbounded until properties of the form P≤0(ϕ1Uϕ2).
Second, the family of models which are graph-structured
equivalent to Mwill be mapped to one M/primeusing our trans-
formation. The result of testing H/primeforM/primeis, therefore,
applicable to testing Hfor every member of the family.
Remark 1.We choose M/prime, thebalanced GS-equivalent
ofM, because this is an important feature to have for both
the correctness and the eﬀective application of our statistic al
technique. First, for the correctness, only when the original
modelMis modiﬁed in such a balanced way, the particular
real number (1/dmax)N−1can be derived for our new hypoth-
esis such that our new hypothesis test is exactly equivalent
to the original hypothesis test. In other words, the valid-
ity of the proof for Theorem 1 relies on our balanced way
of modiﬁcation. Second, our balanced way of modiﬁcation
can safeguard against some worst-case simulations. For ex-
ample, if the property is true in the model Mwith a small
probability pdue to certain valuations of transition proba-
bilities, a typical statistical method needs to run many times
until the path witnessing the satisﬁability is found in the sim-
ulations. Our most “balanced” GS-equivalent M/primeis able to
safeguard against this extreme but important possibility. Of
course, it is possible that our method has higher computa-
tion cost compared to any method that deals with Mdirectly
(e.g., Sen’s method in [16]) when the true pinMis large.
But since this value of pis not known a priori, we introduce
our method based on M/primewhich performs equally well for all
possible values of unknown p.
3.3 Testing for the Transformed Model
The hypothesis testing of H/primeinM/primeis performed as follows.
Letp/primebe the probability of a ﬁnite random path π(with
|π|≤N−1 andπ|=ϕ1Uϕ2) starting from a given state s.
We require Ksimulations of length at most N−1 starting
from statesinM/prime. For each simulation i∈{1,2,...,K}, we
deﬁne the corresponding binary random variable Xias fol-
lows: if simulation isatisﬁesϕ1Uϕ2thenXi= 1; otherwise
(i.e.,ϕ1Uϕ2is either not satisﬁed or undecided for simu-
lationiwithinN−1 steps),Xi= 0. Note that each Xiis
independently and identically distributed as a Bernoulli ran-
dom variable with parameter p/prime. If/summationtextK
i=1Xi= 0: we reject
H/prime
0and conclude H/prime
1ofH/prime(and equivalently we reject H0
and conclude H1ofH). On the other hand, if/summationtextK
i=1Xi>0:
we conclude H/prime
0ofH/prime(and equivalently we conclude H0of
H).
Stop-Early Strategy. A common computation saving
strategy used in this type of testing is the stop-early strat-
egy. While conducting Ksimulations, if the m-th simulation
path satisﬁes ϕ1Uϕ2(i.e.,Xm= 1), the process can stop-
early, immediately infer that/summationtextK
i=1Xi>0 and conclude H/prime
0.
(This stop-early saving strategy is also applied to the basis
procedure in [16].)
Samples from succinct representation. The above
method of testing does not require the construction of the
229original model Mor its transformation M/prime. Instead we
only require that some succinct representation of the orig-
inal model Mbe available (see Section 2). The simulation
runs can be easily obtained as follows. For each simulation
path, at each currently visited state salong the path, we
select the next state tto proceed according to the evenly
distributed transition probability 1 /dsinstead of the origi-
nal transition probability T(s,t), wheredsis the number of
states reachable from sin one step. The value of dsis di-
rectly available from the succinct representation of M. For
instance, for the coin-ﬂipping example discussed in Section 2
([14]), for any state ds= 2n. For the property P≤0(ϕ1Uϕ2),
the simulation of a path is terminated (a) when ϕ2is sat-
isﬁed in the current state (i.e., the path satisﬁes ϕ1Uϕ2);
(b) when¬ϕ1∧¬ϕ2is satisﬁed in the current state (i.e., the
path does not satisfy ϕ1Uϕ2); or (c) when the length of
sample path is equal to N−1 (Nbeing the upper-bound of
the number of states in M). This upper bound can be esti-
mated from the number of variables present in the succinct
representation of the model.
Type I and Type II Errors. Consider that the user
speciﬁes that the Type I Error (the error that H0is true
but the test incorrectly rejects H0) must be no greater than
α.
α= maxProb(rejectH/prime
0|H/prime
0is true)
= maxProb(/summationtextK
i=1Xi= 0|p/prime≥(1/dmax)N−1)
= (1−(1/dmax)N−1)K
Therefore, to control Type I Error within α, we could set K
to⌈log(α)/log[1−(1/dmax)N−1]⌉. For controlling the Type
II Error (the error that H0is false but the test incorrectly
acceptsH0) withinβ, similarly we have
β= maxProb(concludeH/prime
0|H/prime
0is false)
= maxProb(/summationtextK
i=1Xi>0|p/prime= 0)
= 0
Therefore, Type II Error of our test is always 0.
In our analysis, we assume that ϕ1Uϕ2does not include
any nested probabilistic operators, i.e., the checking of ϕ1
andϕ2can be done without any error. For the nested prob-
abilistic operators, the mechanism to control the error prop-
agation has already been described in [19] and later used
in the checking framework presented in [16]. As our proce-
dure is an alternative basis procedure that can replace the
one proposed in [16], the same mechanism to control error
propagation can be applied to our method.
4. THEORETICAL BOUNDS ON
SIMULATION
The product of mean simulation length and sample size
(the number of simulations) is a uniﬁed measurement of the
computation cost of a simulation-based statistical method.
We will compare between the computation costs of the method
proposed by Sen et al. [16] ( Method A ) and the method
proposed in this paper ( Method B ).
Bound on the Simulation Length. As noted before,
Method A ensures the ﬁniteness of every simulation because
in every simulation, each step has the probability psto end in
the terminating state. As a result, the number of steps (i.e.,
the simulation length) has a geometric distribution with the1−r1S0 S2SnSok Serr
.....q
1−rr
1−rr r r1−q
S
Figure 2: Model of Ipv4 zeroconf protocol.
parameter no less than ps. Though it is not possible to pro-
vide an upper bound on the simulation length, the average
length of simulation can be inferred to be less than or equal
to 1/ps. In [16], the authors suggested that psbe set toc/N
wherecis a positive constant and Nis the number of states
in the model. Therefore, on average, the length of the sim-
ulations for Method A is O(N). On the other hand, as per
Method B, each simulation may proceed up to N−1 steps.
Therefore, in the worst case, the length of the simulations
for Method B is O(N).
Bound on the Number of Simulations. The worst case
of the sample size for any method occurs when H1:p= 0 is
true (i.e.,s|=P≤0(ϕ1Uϕ2)). For Method A, Sen et al. [16]
state that the required sample size KA=⌈log(α)/log(1−
δ2)⌉, whereδ2is a user-speciﬁed positive parameter (Recall
thatδ2cannot be chosen correctly due to the invalidity of the
Method; see Section 2.2). On the other hand, for Method
B, the sample size KB=⌈log(α)/log[1−(1/dmax)N−1]⌉.
WhenH0:p >0 is true (i.e., s/negationslash|=P≤0(ϕ1Uϕ2)), both
Method A and Method B may still require all the simu-
lation runs. However, for Method B, the probability that
the worst-case sample size occurs is close to α, the toler-
ance limit for Type I Error. In this situation, we ﬁnd it
important to analyze the expected number of simulations
at which point the testing procedure can stop early before
the pre-speciﬁed (worst-case) number of simulations is ex-
hausted. Let πmbe the ﬁrst simulation path that satisﬁes
ϕ1Uϕ2, i.e., the testing procedure can be stopped after m
simulation runs ( m≤K,K∈{KA,KB}). For Method A,
mhas a geometric distribution with parameter θ. There-
fore, the expectation of m,E(m) = 1/θ. As claimed in [16],
θlies in [p(1−ps)N,p], wherep=P(s,ϕ1Uϕ2) inM. How-
ever, due to the invalidity of Method A for general models
(see Section 2.2), the lower bound of θcannot be speciﬁed
asp(1−ps)N, i.e., the only conclusion that can be made is
E(m)≥1/p.
For Method B, malso has a geometric distribution with
parameter p/primeso thatE(m) = 1/p/prime≤dN−1
max, wherep/prime=
P(s,ϕ1U≤N−1ϕ2) in our modiﬁed model M/prime. Therefore,
whenpis small enough so that 1 /p > dN−1
max, on average,
Method B will obtain a simulation path satisfying ( ϕ1Uϕ2)
earlier than Method A.
Complexity of our proposed method. We have es-
tablished that our method requires simulation length O(N)
and the sample size in the worst case is KB. Therefore the
computation cost of our method is bounded by O(N K B).
5. CASE STUDY
We validate our theoretical results empirically using a case
230 Probability
0 5000 10000 15000 20000 25000 30000 350000.00000 0.00010 0.00020 0.00030
 Probability
0 1000 2000 3000 4000 50000.000 0.001 0.002 0.003 0.004 0.005
(a)m: Method A (b)m: Method B
Figure 3: mvaluations for 100 runs of test procedure.
study of IPv4 zeroconf protocol modeled as PTS (Fig. 2); the
same model is used in [16]. The model contains N=n+ 3
states{s0,s1,...,s n,sok,serr}wheres0is the start state
and the proposition error holds only in the state serr. We
will verify whether s0|=P≤0(ttUerror). Observe that, for
positive values of qandr, the correct inference is s0/negationslash|=
P≤0(ttUerror). Furthermore, the real probability p(i.e.
P(s0,ttUerror)) is a function of N,qandr. For ﬁxed q
andr,pis a decreasing function of N. For ﬁxed N,pis an
increasing function of qandr.
Experimental Setup & Evaluation Parameters. We
use the simulation engine in PRISM [12] to get all the simu-
lation traces and then use our own Java programs2to parse
all the traces and perform the corresponding analysis. We
set the parameter psto be 0.1 needed for Method A across
various cases, which is the same as the value used by Sen
et al. in their experiments in [16]. For both methods, we
keep running the simulations until we obtain one simulation
which satisﬁes ( ttUerror) (recall that in the example case
studys0/negationslash|=P≤0(ttUerror)). For Method A, it is equivalent
to assuming that a suﬃciently small δ2is provided from the
user so that its corresponding sample size is large enough to
include the ﬁrst simulation path satisfying ( ttUerror).
We evaluate the computation cost of the methods with
respect tom, the ﬁrst simulation that satisﬁes ( ttUerror);
andTCS(Total Computation Steps), the total number of
transitions of all the required simulations in the test. The
quantitymprovides an estimate regarding the number of
simulations after which the test procedure can be stopped
with a valid result (stop-early), while the quantity TCSpro-
vides valuable insights into the computation cost of the test
procedure. Note that both quantities are random variables
in the test procedure, i.e., they can take diﬀerent values if
the same test is performed multiple times.
Validity Analysis of Test Procedures. We setn= 6,
q= 0.3, andr= 0.3 in the example model (Fig. 2) and
ﬁx the Type I error bound α= 1×10−4. We evaluate
the validity of Method A and Method B. Figure 3 presents
the results of our experiments. The histograms present the
probability (proportion in 100 runs) of mvalues for both
methods. We proceed with the discussion on the impact of
the selection of δ2for the validity of the results obtained
2Refer tohttp://www.cs.iastate.edu/ ∼rhe/probupdate/ .using Method A. Following the suggestion from [16], if we
setδ2= 0.01, then the maximum number of simulations
that will be used in Method A is KA=⌈log(α)/log(1−
δ2)⌉= 917. In Fig. 3(a), the vertical line marks this value.
Observe that the valuation of m(the ﬁrst simulation that
satisﬁes ( ttUerror)) is greater than 917 in 89 out of 100 test
experiments. Therefore, if δ2(0.01 in this case) provided
by the user is not small enough, then insuﬃcient number of
simulations (917) will be examined in Method A so that the
majority of the test runs would have resulted in the incorrect
inference, i.e., p=P(s,ttUerror) = 0.
On the other hand, in our method, Method B, the ap-
propriate number of simulations KBis calculated using the
pre-speciﬁed Type I error limit, α, the branching factor of
the model-states, dmax, and the number of states N. Here
N=n+ 3 = 9 and dmax= 2 in the model. Therefore,
KB=⌈log(α)/log[1−(1/dmax)N−1]⌉≤2,354 (marked by
the vertical line in Fig. 3(b)). Observe that, all the 100 test
experiments has the valuation of m≤2,354. That is, with
the choice of 2,354 simulations, all the experiments with
Method B can lead to the valid inference P(s0,ttUerror)>
0. Also note that each mis far below the worst-case value
KBso that there is really a lot of computation saving from
ourstop-early strategy.
Eﬃciency & Stability Analysis. In order to compare
the eﬃciency and the stability of Method A and Method
B, as before, we conduct experiments with suﬃciently large
sample size for Method A such that it always includes the
ﬁrst simulation path satisfying ( ttUerror) (i.e., Method A
is always valid).
First, we obtain ﬁve diﬀerent test cases by ﬁxing q= 0.3,
r= 0.3, and increasing nfrom 1 to 10. Table 1(a) shows the
values ofp=P(s0,ttUerror), and the corresponding results
for the sample means and standard deviations (SDs) of m
andTCSfor both methods (with 10 runs per each test case).
Observe that the sample means and standard deviations of
mandTCSof Method B (our method) are smaller than those
of Method A. This experiment empirically shows the lower
average and the higher stability of the computation cost of
Method B for the case study. The results can be explained
as follows. As discussed in Section 4, E(m) for Method A is
at least 1/p, whileE(m) for Method B is 1 /p/prime≤dN−1
max. With
the increase in nand for the ﬁxed valuations of q= 0.3 and
r= 0.3, the decrease in the valuation of pin Method A is
231n pMethod A Method B
mean( m) SD(m) mean(TCS) SD(TCS)mean( m)SD(m)mean(TCS)SD(TCS)
1 0.1139 15.8 8.6 141.1 66.2 1.4 1.0 3.2 2.9
2 0.0371 37.1 33.7 405.8 397.5 8.8 6.0 34.2 24.1
3 0.0114 152.7 153.2 1,517.8 1,508.5 21.3 13.2 105.5 65.9
4 0.0035 439.1 389.7 4,310.8 3,820.2 23.2 22.4 138.2 134.3
5 0.0010 2,086.2 1,564.7 20,817.2 15,624.9 111.3 104.1 778.1 728.9
6 3.12E-04 5,734.8 4,386.8 57,116.2 43,616.5 129.2 150.7 1,032.6 1,205.7
7 9.37E-05 9,084.5 7,032.8 91,157.8 70,111.1 359.3 293.9 3,232.7 2,644.9
8 2.81E-05 65,091.4 55,533.2 651,267.0 555,451.7 414.6 438.2 4,145.0 4,382.5
9 8.44E-06 330,465.6 324,067.8 3,303,374.1 3,241,259.9 926.2 805.2 10,187.2 8,857.5
10 2.53E-06 1,922,723.0 1,789,107.0 19,228,101.0 17,892,495.0 2,490.0 2,011.1 29,879.0 24,133.1
(a)
(q, r) pMethod A Method B
mean( m) SD(m) mean(TCS) SD(TCS)mean( m)SD(m)mean(TCS)SD(TCS)
(0.1, 0.1) 1.11E-6 847,073.4 1,319,903.0 8,470,795.4 13,199,276.0
111.3 104.1 778.1 728.9(0.25, 0.1) 3.33E-6 739,477.3 888,451.2 7,395,761.8 8,884,764.1
(0.15, 0.15) 1.34E-5 107,157.3 85,527.6 1,071,463.7 855,301.8
(0.75, 0.1) 3.00E-5 54,476.7 56,948.4 544,470.2 569,270.5
(0.2, 0.2) 8.00E-5 23,780.8 20,175.5 237,757.8 202,198.4
(0.25, 0.25) 3.25E-4 6,819.8 6,207.3 68,424.9 62,713.4
(0.25, 0.3) 8.09E-4 1,708.2 1,743.5 17,047.5 12,430.1
(0.3, 0.3) 0.0010 2,086.2 1,564.7 20,817.2 15,624.9
(0.35, 0.35) 0.0028 617.4 626.6 6,148.4 6,219.7
(0.4, 0.4) 0.0068 227.5 247.4 2,297.9 2,479.9
(0.75, 0.3) 0.0072 502.3 384.2 5,032.8 3,930.6
(0.45, 0.45) 0.0149 182.5 161.9 1,780.3 1,617.1
(0.5, 0.5) 0.0303 102.3 96.1 1,007.8 923.0
(0.25, 0.7) 0.0531 28.4 29.0 309.8 342.1
(0.75, 0.5) 0.0857 30.4 39.7 288.8 386.7
(0.25, 0.5) 0.1031 83.3 69.4 844.0 733.6
(0.6, 0.6) 0.1044 23.1 21.7 207.9 229.0
(0.25, 0.9) 0.1644 12.3 9.8 112.2 78.6
(0.7, 0.7) 0.2817 7.3 4.9 67.0 37.2
(0.75, 0.7) 0.3352 6.8 2.9 65.9 31.2
(0.8, 0.8) 0.5672 3.2 2.7 31.1 29.8
(0.75, 0.9) 0.6392 2.2 1.7 15.6 13.2
(0.9, 0.9) 0.8416 3.4 2.4 17.7 12.7
(b)
Table 1: Means and Standard Deviations of mandTCSfor Method A and Method B for diﬀerent valuations
of (a)nand (b) (q,r).
more than the decrease in the valuation of p/primein Method B. In
fact, the valuation of p/primeis independent of various valuations
ofqandr(recall that testing based on modiﬁed model M/prime
does not consider qandr, Section 3.1.1).
In the second set of experiments (Table 1(b)), we ﬁxed n=
5 and used diﬀerent qandrvalues between 0 .1 and 0.9 (with
10 runs per each test case). The sample means and standard
deviations of mandTCSfor Method B remain unchanged.
This is because our hypothesis test does not depend on qand
r; in fact, one test is suﬃcient to infer the results for all the
models with diﬀerent valuations of qandr(∈(0,1)). On the
other hand, the valuation of pdecreases with the decrease
in the valuations of qandr, and as a result, the means
and standard deviations of mandTCSincrease in Method
A. Observe that, for large values of qand/orr(>0.5), the
sample mean of m(mean(m)) for Method A is smaller than
that for Method B as the simulations have higher chance to
reach the state serr(Fig. 2) and satisfy ( ttUerror). In other
words, for models where the probability pfor satisfying a
desired property decreases dramatically with the transition
probability variations, Method A may suﬀer from the higher
mean and variability of computation cost. On the other
hand, our method is based on a transformed balanced model
(see Remark 1), one where the valuation of p/primeis not aﬀected
by the transition probabilities of the original model. Assuch, the eﬃciency and the stability of the computation in
Method B do not depend on the transition probabilities.
6. RELATED WORK
6.1 Model Checking Probabilistic Systems
Younes and Simmons [19] introduce a statistical method
based on the Monte Carlo simulation and sequential hypoth-
esis testing [17] for verifying CSL formulas in CTMC. How-
ever, their method excludes the unbounded until properties,
and is only applicable to (time) bounded until properties.
Techniques for bounded until properties are also discussed
in [18].
Herault et al. [11] also propose a statistical method based
on Monte Carlo simulation. The technique uses estimation
from Chernoﬀ-Hoeﬀding inequality [13] to verify a subset of
LTL formula and includes the checking of unbounded until
properties. However, it fails to completely control the error
in the procedure. The reason is as follows. The simulation
path length used in the procedure has a pre-speciﬁed upper
bound. If a simulation reaches that bound and fails to infer
a decided result, the technique assumes that the simulation,
if allowed to proceed, will eventually have results defend-
ing the null hypothesis H0of the testing. This assumption
allows the procedure to control Type I Error within a pre-
speciﬁed limit. However, as admitted in [11], the proposed
232technique cannot determine the appropriate upper bound of
simulation path length to control the number of the unde-
cided simulations. As such, the method loses the control
of Type II Error. The popular probabilistic model checker
PRISM [12] includes a variation of the method described
in [11]. The distinguishing feature is that, unlike [11] which
allows the undecided simulations, PRISM requires that ev-
ery simulation terminates with a decided result.
To control both Type I Error and Type II Error of check-
ing unbounded until properties, Sen et al. [16] introduce
the new statistical model checking algorithm (discussed in
Section 1). However, the technique is invalid in general due
to the invalidity of their basis procedure (see Section 2).
Zapreev [21] also proposes a statistical technique for veri-
fying unbounded until properties. This technique assumes
some prior knowledge of the model structure and requires
the users to provide the appropriate parameters such as sim-
ulation length.
Rabih and Pekergin [15] propose a new statistical ap-
proach to model check both steady-state and unbounded
until properties based on perfect simulation. Perfect sim-
ulation has been proven a valid technique to generate the
samples according to the stationary distribution of the tar-
get DTMC model. An important constraint that is imposed
on the target DTMC is that it should be ergodic (i.e., irre-
ducible and aperiodic). In other words, if the DTMC model
is not guaranteed to be ergodic, then the proposed method
could not be proven to hold. On one hand, it is, therefore,
necessary to ﬁrst verify that the DTMC model, under con-
sideration, is ergodic before the application of the method;
and on the other hand, the assumption restricts the appli-
cation of the proposed method if such veriﬁcation is not
possible (e.g., for black-box DTMC systems) or fails.
In our prior work [2], we discuss a two-phase method to
verify unbounded until properties P(s,ϕ1Uϕ2). In the ﬁrst
phase, we use statistical sampling technique to estimate a
suitable bound k0such that P(s,ϕ1U≤k0ϕ2) is agoodesti-
mate of P(s,ϕ1Uϕ2). In the second phase, P(s,ϕ1U≤k0ϕ2)
is estimated using the statistical method proposed in [11].
This technique, however, suﬀers from the drawback that for
certain models k0may not be computable in which case the
ﬁrst phase will fail to terminate.
Unlike the above techniques, we present a statistical model
checking technique which is valid for any model structure
and also does not require prior knowledge of the probability
of the satisfaction of the property under consideration. We
establish an upper bound (with respect to the size of the
modelM) on the simulation path length that is suﬃcient
for checking speciﬁc unbounded until property of the form
P≤0(ϕ1Uϕ2). In essence, we reduce the original hypothesis
test for the unbounded until property in a model Mto the
equivalent hypothesis test for a bounded until property in a
transformed model M/prime.
6.2 Probabilistic Methods for Model Check-
ing Non-Probabilistic Properties
We have presented a method that can be used as the basis
procedure to verify the probabilistic property P1p(ϕ1Uϕ2)
following the methodology proposed by Sen et al. [16]. The
basis procedure is essentially verifying P≤0(ϕ1Uϕ2) or a
pure non-probabilistic property ¬E(ϕ1Uϕ2). As such, any
method capable of verifying ¬E(ϕ1Uϕ2) is a candidate al-
ternate for the basis procedure.In contrast to traditional model checking of ¬E(ϕ1Uϕ2)
[6] which has a space complexity polynomial to the number
of states in the model, our method, being based on statistical
sampling, has a considerable less space requirement (of the
order of the size of the succinct representation of the model).
Grosu and Smolka [8] have discussed a statistical-sampling
based model checking of non-probabilistic models against
LTL properties. Their technique also has a space require-
ment linear to the size of the model, which is the same as
the one required by the traditional method for model check-
ing¬E(ϕ1Uϕ2) [6]. I.e., their technique will have the same
kind of state-space explosion problem as the the traditional
model checking method.
Brim et al. [3] propose a probabilistic approach to achieve
space reduction in the depth ﬁrst search (DFS) based LTL
model checking of non-probabilistic systems. The work is
based on two main observations made in [7]: (a) that it is
necessary to cache the states on the search stack for the
correctness of DFS based LTL model checking and (b) that
caching of states outside the DFS stack such that the over-
all size of cache is above some threshold (usually between
1/2 and 1/3 of the entire state space) is likely to gain the
good space saving without the explosion in time. In this
context, authors in [3] use randomness to decide the states
that should be cached during DFS. Experiments on two ex-
amples (dining philosophers and Peterson algorithm) in [3]
show that there is often a good tradeoﬀ point where the
space requirement can be reasonably reduced without in-
curring large penalty in terms of time. For example, experi-
ments on Peterson algorithm show that 33% saving in space
can be achieved with a 44% increase in time usage. However,
it is diﬃcult to identify a good tradeoﬀ point for any given
model in advance. Beyond the good tradeoﬀ point, the in-
tention to further save space may dramatically increase the
time cost. For instance, experiments on dining philosophers
in [3] reveal that while a saving of 15% in space can be
achieved at the cost of 83% increase in time, subsequent
gains of 28% and 32% in space increase the time usage by
662% and 6 ,939% respectively. Finally, as the technique is
based on DFS, minimum space that holds the stack is al-
ways required, and the maximum stack size depends on the
model being explored.
While our technique has a considerably less space require-
ment compared to the above techniques, it suﬀers from high
computation cost (in terms of the number of simulations and
simulation path lengths). However, it should be noted that
the worst computation cost corresponds to the case when
probability of satisfying ( ϕ1Uϕ2) is actually 0. In all other
situations, it is likely that the number of simulations ( m)
considered until the ﬁrst simulation satisfying ( ϕ1Uϕ2) is
explored is much smaller than the total number of simula-
tions (KB) required to be examined in the worst case (i.e.,
that our method will be able to stop early). Therefore, our
technique is a viable alternate not only for the basis proce-
dure but also for traditional model checking of ¬E(ϕ1Uϕ2),
especially when the model under consideration is large and
branching factor from each state is small.
7. SUMMARY & DISCUSSION
To the best of our knowledge, our work for the ﬁrst time
provides a road-map to obtain the computation complexity
of a statistical technique for verifying P≤0(ϕ1Uϕ2) under the
requirement of controlling both Type I Error and Type II
233Error within the pre-speciﬁed limits and under the condition
that only succinct representation of the model is available
prior to the test. The worst-case computation complexity of
our method is O(NK B), whereKBis of the order O(dN
max).
We concur with the statement in [11], “Unfortunately, this
bound might be exponential in the number of states”, and
conjecture that the above computation complexity is the
asymptotic lower bound for the complexity of a statistical
technique for verifying P≤0(ϕ1Uϕ2) under the above re-
quirement and condition.
In future, we will ﬁrst investigate whether a better bound
(/lessmuchdN
max) on the number of simulations required for the
validity of hypothesis testing can be obtained in the basis
procedure by minimally relaxing the conditions. Especially,
the objective will be to identify a minimal set of structural
information of the system model that may be exploited for
this purpose. We have made preliminary study involving
loop-detection and on-the-ﬂy removal of edges to avoid, in
turn, loops, where each state in the loops satisﬁes ϕ1∧¬ϕ2.
Such removal of edges progressively reduces the branching
factor of each state and, therefore, signiﬁcantly increases the
likelihood of identifying a path that satisﬁes ϕ1Uϕ2(if such
a path exists). We plan to further this line of research and
identify the class of models where the proposed technique
can be eﬀectively applied.
We also intend to obtain a bound on the number of in-
vocations to the basis procedure required for the statistical
veriﬁcation of the general P1p(ϕ1Uϕ2). This objective is to
signiﬁcantly reduce the overhead of verifying P≤0(ϕ1Uϕ2)
at every state without compromising the correctness and the
eﬀectiveness of the method.
Acknowledgment
This work is supported in part by NSF grant CCF0702758.
8. REFERENCES
[1] A. Aziz, K. Sanwal, V. Singhal, and R. Brayton.
Verifying continuous time markov chains. In
Proceedings of Computer Aided Veriﬁcation , volume
1102, 1996.
[2] S. Basu, A. P. Ghosh, and R. He. Approximate model
checking of pctl involving unbounded path properties.
In11th International Conference on Formal
Engineering Methods , pages 326–346, 2009.
[3] L. Brim, I. Cerna, and M. Necesal. Randomization
helps in LTL model checking. In Proceedings of the
Joint International Workshop on Process Algebra and
Probabilistic Methods, Performance Modeling and
Veriﬁcation , pages 105 – 119, London, UK, 2001.
Springer-Verlag.
[4] G. Casella and R. L. Berger. Statistical Inference .
Duxbury, 2002.
[5] E. Cinlar. Introduction to Stochastic Processes .
Prentice Hall, 1975.
[6] E. M. Clarke, E. A. Emerson, and A. P. Sistla.
Automatic veriﬁcation of ﬁnite-state concurrent
systems using temporal logic speciﬁcations. ACMTransactions on Programming Languages and
Systems, 8(2), 1986.
[7] P. Godefroid, G. J. Holzmann, and D. Pirottin.
State-space caching revisited. Formal Methods in
System Design, 7(3):227–241, 1995.
[8] R. Grosu and S. A. Smolka. Monte carlo methods for
process algebra. In Electronic Notes in Theoretical
Computer Science , volume 162. Springer, 2006.
[9] H. Hansson and B. Jonsson. A logic for reasoning
about time and reliability. Formal Aspects of
Computing , 6(5):512–535, 1994.
[10] S. Hart, M. Sharir, and A. Pnueli. Termination of
probabilistic concurrent program. ACM Trans.
Program. Lang. Syst. , 5(3):356–380, 1983.
[11] T. Herault, R. Lassaigne, F. Magniette, and
S. Peyronnet. Approximate probabilistic model
checking. In 5th International Conference on
Veriﬁcation, Model Checking, and Abstract
Interpretation , volume 2937. Springer, 2004.
[12] A. Hinton, M. Kwiatkowska, G. Norman, and
D. Parker. Prism: A tool for automatic veriﬁcation of
probabilistic systems. In International Conference on
Tools and Algorithms for the Construction andAnalysis of Systems , volume 3920, 2006.
[13] W. Hoeﬀding. Probability inequalities for sums of
bounded random variables. Journal of the American
Statistical Association , 58, 1963.
[14] P. Liberatore. On polynomial sized MDP succinct
policies. Journal of Artiﬁcial Intelligence Research,
21:551–577, 2004.
[15] D. Rabih and N. Pekergin. Statistical model checking
using perfect simulation. In ATVA ’09: Proceedings of
the 7th International Symposium on Automated
Technology for Veriﬁcation and Analysis , pages
120–134, Berlin, Heidelberg, 2009. Springer-Verlag.
[16] K. Sen, M. Viswanathan, and G. Agha. On statistical
model checking of stochastic systems. In Proceedings
of Computer Aided Veriﬁcation , volume 3576, 2005.
[17] A. Wald. Sequential tests of statistical hypotheses.
The Annals of Mathematical Statistics , 16(2), 1945.
[18] H. L. S. Younes. Error control for probabilistic model
checking. In 7th International Conference on
Veriﬁcation, Model Checking and AbstractInterpretation , volume 3855, 2006.
[19] H. L. S. Younes and R. G. Simmons. Probabilistic
veriﬁcation of discrete event systems using acceptancesampling. In Proceedings of Computer Aided
Veriﬁcation, volume 2404. Springer, 2002.
[20] H. L. S. Younes and R. G. Simmons. Statistical
probabilistic model checking with a focus on
time-bounded properties. Information and
Computation , 204(9), 2006.
[21] I. S. Zapreev. Model Checking Markov Chains:
Techniques and Tools . PhD thesis, University of
Twente, The Netherlands, 2008.
234