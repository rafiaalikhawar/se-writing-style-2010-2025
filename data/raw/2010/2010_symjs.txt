SymJS: Automatic Symbolic Testing of JavaScript Web
Applications
Guodong Li
Fujitsu Labs of America,
Sunnyvale, CA, USA
gli@ï¬‚a.fujitsu.comEsben Andreasen
Dept. of Computer Science,
Aarhus University, Denmark
esbena@cs.au.dkIndradeep Ghosh
Fujitsu Labs of America,
Sunnyvale, CA, USA
ighosh@ï¬‚a.fujitsu.com
ABSTRACT
We present SymJS, a comprehensive framework for auto-
matic testing of client-side JavaScript Web applications. The
tool contains a symbolic execution engine for JavaScript,
and an automatic event explorer for Web pages. With-
out any user intervention, SymJS can automatically dis-
cover and explore Web events, symbolically execute the as-
sociated JavaScript code, rene the execution based on dy-
namic feedbacks, and produce test cases with high coverage.
The symbolic engine contains a symbolic virtual machine,
a string-numeric solver, and a symbolic executable DOM
model. SymJS's innovations include a novel symbolic virtual
machine for JavaScript Web, symbolic+dynamic feedback
directed event space exploration, and dynamic taint analy-
sis for enhancing event sequence construction. We illustrate
the eectiveness of SymJS on standard JavaScript bench-
marks and various real-life Web applications. On average
SymJS achieves over 90% line coverage for the benchmark
programs, signicantly outperforming existing methods.
Categories and Subject Descriptors: D.2.5 [Software
Engineering]: Testing and Debugging
General Terms: Reliability, Experimentation
Keywords: JavaScript, Web, Symbolic Execution, Auto-
matic Software Testing, Event Sequence, Taint Analysis
1. INTRODUCTION
Traditionally, software quality has been assured through
manual testing which is tedious, dicult, and often gives
poor coverage especially when availing of random testing
approaches. This has led to much recent work in the area of
formal validation and testing. One such technique is sym-
bolic execution [5] which can be used to automatically gen-
erate test inputs with high structural coverage.
Symbolic execution treats input variables to a program as
unknown quantities or symbols [10]. It then creates com-
Contributed to this work during a summer intership pro-
gram at Fujitsu Labs of America
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
FSE â€™14, November 16â€“22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.plex equations by executing all possible nite paths in the
program with the symbolic variables. These equations are
then solved through an SMT (Satisability Modulo Theories
[11]) solver to obtain test cases and error scenarios, if any.
Thus this technique can reason about all possible values at
a symbolic input in an application. Though it is very pow-
erful, and can nd specic input values to uncover corner
case bugs, it is computationally intensive.
Symbolic execution poses specic challenges to the domain
of JavaScript based Web applications which are quite dier-
ent from traditional programs [19]. Web applications are
usually event driven, user interactive, and string intensive.
Also, unlike traditional programming languages JavaScript
is a dynamic, untyped and functional language.
Some symbolic execution tools have been presented for
C/C++ [23, 4], Java [18], and low level code [25, 8]. It
has been reported that they can nd corner case bugs and
produce test cases with very high coverage. SymJS targets
JavaScript Web applications, which so far has received much
less attention. To make such a symbolic execution tool us-
able in practice, the tool should be fully automatic, highly
ecient, and able to handle general JavaScript Web appli-
cations. This not only requires an ecient and customizable
engine with start-of-the-art solving techniques addressing
JavaScript language semantics, but also a smart automatic
driver builder that explores the user event sequence and in-
put value space exhaustively during the dynamic execution
and subsequent test generation phases.
Though there are a few symbolic execution tools for Java-
Script such as Kudzu [21] and Jalangi [22], such compre-
hensive testing capabilities as described above are lacking.
Kudzu uses fuzzing and symbolic string reasoning to ana-
lyze security vulnerabilities in Web applications. Jalangi
instruments the source JavaScript code to collect path con-
straints and data for replaying. While Jalangi works for
pure JavaScript programs and not general Web applications,
Kudzu focuses on only one specic testing need - nding se-
curity issues. In this paper, we show that the event-driven
nature of Web applications poses a bigger challenge than
JavaScript itself. Unfortunately, neither Kudzu [21] nor
Jalangi [22] pays much (if any) attention to this problem.
The following table shows how well random and symbolic
testing work for pure JavaScript (JS) programs and Web ap-
plications. For pure JavaScript benchmarks manipulating
numbers, random testing can easily achieve over 90% line
coverage; the coverage drops to around 55% for string in-
tensive programs. SymJS employs symbolic execution with
a powerful string solver to achieve more than 96% averagecoverage. Covering the rest requires better drivers. This be-
comes more prominent for Web applications: random test-
ing achieves 76% coverage, primitive symbolic execution gets
over 88%, while symbolic execution with optimizations can
cover the corner cases that are very dicult to hit. More
details are presented in Section 5.
Random Sym. +Opt.
Pure JS>90%(num.)55%(str.) >96% {
JS Web 76% 88 :7% 90:8%
In practice, JavaScript programs are used primarily in the
Web context, hence the main task is to develop a symbolic
engine for Web, and automatically construct good drivers
while curbing space explosion. This requires novel meth-
ods to perform symbolic execution and construct event se-
quences. Specically, we present how to (1) implement a
symbolic virtual machine supporting both symbolic and taint
analysis; (2) perform feedback-directed symbolic execution
to explore the event state space; and (3) use taint analysis
to optimize event sequence construction.
SymJS uses a symbolic virtual machine to execute Java-
Script code. The source code is not instrumented but a
symbolic virtual machine is implemented (similar to [4, 16]
and [18]). Unlike Kudzu which separates event exploration
with symbolic execution, SymJS includes a powerful event
explorer that builds and renes the drivers automatically
during symbolic execution. The novel features and achieve-
ments of SymJS are as follows:
The execution engine performs symbolic execution for Java-
Script within a virtual machine. It supports all language
features and most built-in libraries of JavaScript, and vari-
ous execution modes. It incorporates crucial optimizations
such as state merging for property accesses. It is the rst
to (1) use a parametrized-array string-numeric solver with
various optimizations, and (2) implement a symbolic DOM
model with model and executable classes. (Section 3)
For many benchmark programs the execution engine is
able to achieve 100% line coverage, with over 96% on aver-
age. This will be apparent in Section 5.1.
The automatic event explorer relieves a user from the bur-
den of building drivers and manually controlling the execu-
tion. It uses dependency and feed-backs to explore the event
state space more eciently. (Section 4.1)
The symbolic engine supports taint analysis through dy-
namic symbolic execution, which can be used to signicantly
enhance event sequence construction. (Section 4.2)
For various Web applications, SymJS is able to achieve
over 90% average coverage in reasonable time, which is sig-
nicantly better than some prior automatic Web testing
tools such as [1]. (Section 5.2)
2. MOTIVATION AND OVERIEW
Figure 1 shows a simplied version of a shopping cart ex-
ample, where the Web page contains three input text boxes
(for quantity, customer name and credit card number) and
ve buttons for manipulating the cart: add \book", add
\pencil", clear cart, set quantity, and purchase.
Event purchase invokes function check . Its rst branch
checks whether the name input equals to \fujitsu", and the
second one checks whether the name consists of a rst name
and a last name. The third branch uses a regular expres-
sion to ensure that the card number contains 16 digits, and
items = [{name: "Book", price: 2000},
{name: "Pencil", price: 30}];
cart = {}; emptyCart = true;
totalPrice = 0; quant = 1;
function e(x) // get a DOM element
{ return document.getElementById(x); }
function getItem(name) { // search item
for (item in items)
if (items[item].name == name)
return items[item];
}
function addItem(name) { // add item with price
emptyCart = false;
if (cart[name]) cart[name] += quant;
else cart[name] = quant;
totalPrice += getItem(name).price * quant;
updateCart(); updatePrice(); // update display
}
function updatePrice() {
if (totalPrice<100) price = totalPrice + " cents";
else price = totalPrice/100 + " dollars";
e("price").innerHTML = "Price: " + price;
}
function purchase() { // for button Buy
if (totalPrice == 0) return;
var name = e("name").value;
var visa = e("visa").value;
return check(name, visa);
}
function check(name,visa) {
name = name.trim(); var errors = [];
if (name == "fujitsu") return true; // P1
if (name.split(" ").length != 2)
errors.push("Need last and first name");// P2
else if (!visa.match(/\d{16}/))
errors.push("Visa: need 16 digits"); // P3
else if (parseInt(visa[15]) % 2 != 0)
errors.push("Visa: even last digit"); // P4
if (errors.length > 0) return false; // P5
else return true; // P6
}
function clearCart() { // for Delete Cart
if (emptyCart) return;
emptyCart = true; cart = {}; updateCart();
totalPrice = 0; updatePrice();
}
Figure 1: Motivating example \Demo Cart".Figure 2: Main Components of SymJS.
the fourth one checks the last digit. The path conditions are
shown below, where P2' = (trim(name) 6=\fujitsu"^trim(name).
split(\ ").length = 2) . Test cases can be produced by solving
these path conditions, e.g.a valid solution for P4 is: name
= \a b" and visa = \0000000000000001" . SymJS applies
symbolic execution to explore all paths, and uses an e-
cient string-numeric solver [13] to determine path feasibility
and produce test cases.
P1 : trim(name) = \fujitsu"
P2 : trim(name)6= \fujitsu"^trim(name).split(\ ").len 6= 2
P3 :P20^:visa.match(\ndf16g")
P4 :P20^visa.match(\ndf16g")^parseInt(visa[15]) % 2 6= 0
P5 :P2_P3_P4
Function check will be executed only when totalPrice6= 0.
Directly clicking Purchase after loading the page will not
invoke check . To execute this function, we can construct
and execute the following 2-event sequence.
1. click Add to Cart on ``book'' (invoke addItem);
2. click Purchase (invoke purchase)
In this sequence, function addItem modiestotalPrice to
a value greater than 0. Then function purchase can pass the
check ontotalPrice and invoke check . Note that addItem
contains a branch with condition cart[name ] =undef . To
visit the right side of this branch, we can use another se-
quence [ AddItem; AddItem ]. In general, many event sequences
may be needed for exhaustive testing. SymJS constructs
these sequences automatically based on dynamic analysis.
Overview. As shown in Figure 2, SymJS consists of three
main components: front-end (parser), middle-end (sequence
manager), and back-end (symbolic executor). The front-end
obtains Web pages ( e.g. through HTTP requests), parses
them, and stores data in local format. We add pre-processing
in the front-end to collect information for the middle-end.
Currently the front-end uses a frame-less browser HTMLU-
nit1. We extend HTMLUnit's DOM and Browser API model
to support symbolic execution.
The middle-end creates, schedules and manages event se-
quences. It symbolizes the inputs and executes a sequence
event by event. It monitors the execution and collects feed-
backs information to construct and rene event sequences.
It contains various sequence construction schemes, one of
which is our implementation of the main algorithm of a con-
crete testing tool Artemis [1].
1http://htmlunit.sourceforge.net/l :=l1;l2;::: label
uop := not;neg;::: unary operation
bop := add;mul;rshift;::: binary operation
cop := gt;ge;eq;::: condition operation
instr := pushv add value into frame
juopjbop unaryjbinary operation
jcop comparison operation
jgotol unconditional jump
jifeqljifnel conditional jump
jgetpropjsetprop getjset property
jcalljret function calljreturn
Push value into the frame: push v :
(l;pc; J~ vK;G),!(l+ 1; pc; Jv;~ vK; G)
Unary Operation: uop:
(l;pc; Jv1;~ vK;G),!(l+ 1; pc; Juop(v1);~ vK; G)
Binary/Comparison Operation: opforop2fbop;copg:
(l;pc; Jv1;v2;~ vK;G),!(l+ 1; pc; Jv1opv2;~ vK; G)
Conditional Jump: ifeql0:
(l;pc; Jv1;~ vK;G),!
f(l0; pc^v1;J~ vK); Gg [ f (l+ 1; pc^:v1;J~ vK: G)g
Property Get: getprop :
(l;pc; JS;v1;~ vK;G),!S
i2dom(S)(l+ 1; pc^i=v1;JShii;~ vK; G)
[f(l+ 1; pc^V
i2dom(S)i6=v1;Jundef ;~ vK); Gg
Optimized Property Get: getprop :
(l;pc; JS;v1;~ vK;G),!(l+ 1; pc; Jvnew;~ vK; G)
wherevnew=ite(v1=i1;Shi1i;ite(v1=i2;Shi2i;:::))
fori1;i2;2 dom(S)
Property Set: setprop :
(l;pc; JS;v1;v2;~ vK;G[x7!S;y7!S0]),!S
S02pts(S)^i2dom(S0)(l+ 1;pc^i=v1;J~ vK; G 1[y7!S0[i7!v2]])
[f(l+ 1; pc^V
i2dom(S)i6=v1;J~ vK; G 2[x7!S[i7!v2]])g
whereG1=G[x7!S] andG2=G[y7!S0]:
Figure 3: Syntax and operational semantics of core
Rhino bytecode (excerpt).
The back-end is the symbolic virtual machine for Java-
Script, which extends the Rhino2JavaScript engine for sym-
bolic execution. It interprets each Rhino Icode symbolically,
forks states on feasible branches, and manages the states. It
does not reuse any existing symbolic executor. The back-end
and middle-end share the state management component to
control the state and sequence execution.
3. SYMBOLIC EXECUTION ENGINE
Similar to [4, 18], the engine works on intermediate repre-
sentations (bytecode, i.e.Rhino Icode) rather than source
programs. This lessens the burden of handling complex
source syntax, and leads to a more robust tool implementa-
tion. Figure 3 shows the bytecode's syntax and semantics.
An execution state consists of the current label l(or in-
struction counter), path condition pc, frameF, and global
scopeG. A frame is a stack of values. It also maintains
a pointer to its parent frame pertaining to the function
caller. We use Jv;~ vKto denote a frame with vat the top
and~ vrepresenting the rest values. Pushing a new value
v1into this frame results in Jv1;v;~ vK, and popping vre-
2https://developer.mozilla.org/en-US/docs/Rhinosults in [~ v]. A scope maps properties to values ( e.g. con-
stants or objects), and may embed other scopes. For a
scope object S, we useS[x] to denote the value at address
x, andS[x7!v] the state mapping address xto valuev.
Clearly, a read after a write satises the following property:
(S[x7!v])[y] =ite(x=y;v;S[y]), (itemeans\if-then-else").
A JavaScript object may have a prototype chain for its
parent objects. A scope Scan access the properties of its
prototype scopes. We use Shxito denote reading property
xfrom scope Sdynamically, and show below a formal de-
nition. Here dom(S) gives the domain ( i.e.property names)
ofS;prototype (S) returnsS's direct prototype. Similarly,
we introduce notation pts(S) for all the prototype objects
ofS(includingS); and dom(S) for the domain of pts(S).
Shxi=8
<
:S[x] ifx2dom(S)
S0hxiifS0=prototype (S)^S0hxi6=undef
undef otherwise
Figure 3 shows the execution of some instructions over
symbolic values. Other instructions such as object and prop-
erty creation and deletion, various function call types, ex-
ception handling, scopes and literals are not included. We
show how a state transits ( ,!) to a new state when execut-
ing an instruction. For example, instruction negincreases
the label by 1, pops value v1from the frame, and puts v1's
negation back into the frame. A comparison instruction is
always followed by a conditional jump. New states may also
be spawned if the condition and its negation are satisable
under the current path condition. Here we use set operations
(e.g.set union) to depict state spawning.
When a property is read from a scope S, if the property's
id is symbolic, then we match it with existing properties
indom(S), and spawn a new state for each match i=v1
(more precisely, the rst match in the order of Sand thenS's
prototypes). When no match exists, the path condition is
updated and undef is returned as the result. We will discuss
an optimization later. For property set, Sand its prototypes
are searched, and the rst S0containing a matched property
will be updated. If no match is found, then Sis updated.
For illustration, we show below the state transitions for
statement \cart[name] += quant;" in the motivating exam-
ple. Suppose that (1) variables \name" and \quant" have
symbolic values nandqrespectively; and (2) in the global
scopeG, property \cart" maps to scope S, which in turn
maps \book" to q1, and \pencil" to q2,i.e.the quantities of
pencil and book are q1andq2respectively.
(l;Jn;:::K; G[\cart"7!S]),! push \cart"
(l+ 1;J\cart";n;:::K; G[\cart"7!S]),! pushG
(l+ 2;JG;\cart";n;:::K; G[\cart"7!S]),! getprop
(l+ 3;JS;n;:::K; G0),! getprop
fstate 1 : (l+ 4;(p1:n= \book");Jq1;:::K; G0);
state 2 : (l+ 4; n= \pencil";Jq2;:::K; G0);
state 3 : (l+ 4; n =2f\pencil";\book"g;Jundef ;:::K; G0)g
whereG0=G[\cart"7!S] andp1= (n= \book")
state 1,! pushq
(l+ 5; p1;Jq;q1;:::K; G0),! add
(l+ 6; p1;Jq1+q;:::K; G0),! pushn
(l+ 7; p1;Jn;q1+q;:::K; G0),! push \cart"
(l+ 8; p1;J\cart";q1+q;:::K; G0),! push G0
(l+ 9; p1;JG0;\cart";n;q1+q;:::K; G0),! getprop
(l+ 10; p1;JS;n;q1+q;:::K; G0),! setprop
(l+ 11; p1;J:::K; G[\cart"7![\book"7!q1+q]])
The \property get" instruction leads to three states. In
state 1, the path condition species that the name matchesproperty \book", and value q1is fetched from the scope and
pushed into the stack. The subsequent computation adds
qinto the book's quantity, and updates scope Swith the
new quantity. Here type conversion will be applied to the
operands according to the ECMA standard. The computa-
tions for the other two states are similar.
SymJS applies crucial optimizations to mitigate state ex-
plosion, especially for symbolic property gets and sets. SymJS
uses iteexpressions to merge the states if possible. In the
above example, the 3 states produced by getprop can be
combined to the following one. Our string solver is good at
handling string-numeric iteexpressions.
(l+ 4; true; [q0;:::]; G0)
whereq0=ite(x= \book";q1;ite(x= \pencil";q2;undef ))
SymJS provides two methods for spawning new states. As
in [4, 18], the rst method clones states for new execution
paths. The second one is easier to implement but has bigger
overhead: it restarts the execution from the beginning. This
is a fuzzing mode similar to [23, 8] but it is performed within
a symbolic stack-based virtual machine.
In the fuzzing mode, a state contains a L/R sequence
recording the sides (Left or Right) taken for the feasible
branches so far, which is used to \replay" the execution dur-
ing a restart. For instance, function check alone leads to
the following 6 states, where tname is the short-hand for
trim(name ). For each state, the executor rst replays the
execution by taking all the specied sides, then continues
the usual symbolic execution from there.
State PC L/R Seq
1P1 :tname = \fujitsu" l
2:P1^(P2: split(tname ):len6= 2) r;l
3:P1^:P2^(P3::visa.match( =ndf16g=)) r;r;l
4:P1^:P2^:P3^(P4:visa[15]%26= 0) r;r;r;l
5:P1^(P2_P3_P4) r;r;r;r;l
6:P1^:P2^:P3^:P4 r;r;r;r;r
These path conditions are solved to produce test cases.
The test cases can be replayed in the same engine. For ex-
ample, the following statement introduces a symbolic string
for variable s. When replaying, SymJS assigns the test value
(e.g.\fujitsu") to s, then the engine performs concrete ex-
ecution over this value. We use replaying to conrm test
validity and coverage. Supporting random testing is triv-
ial: this function returns a random string, then the engine
performs concrete execution.
// s = symb. value in sym. exec. and test value in replay.
var s = symjs_mk_sym_string(``s'');
String-Numeric Solver. One key for practical symbolic
execution is constraint solving since the solver may be in-
voked hundreds of thousands of times for a non-trivial appli-
cation. It is the advances in constraint solving (SMT solving
[11] became over 1000 times faster in the last decade) that
make symbolic execution practical and more popular.
Symbolic numeric constraints can be solved through SMT
solvers (Yices [6] in our case). However, JavaScript fea-
tures extensive String operations, which are not supported
by most modern SMT solvers. Thus SymJS introduces the
PASS solver [13] to handle string constraints. PASS sup-
ports integers, bit-vector numbers, oating point numbers,
and strings. In particular, it supports a majority of the
JavaScript string operations, including string comparisons,
string-numeric conversions, and regular expressions.PASS is the rst to use parameterized arrays (PArrays)
as the main data structure to model strings, and converts
string constraints into quantied expressions that are solved
through an ecient and sound quantier elimination algo-
rithm. In particular, similar to [7], it can identify unsatis-
able cases quickly. For example, constraints s.contains( \ab" )
^s.match( \a+" ) can be disproved in the automaton domain.
Consider the path condition of state 4 shown above, where
name not equals to \fujitsu" and can be split into two parts,
and variable visa should have 16 digits, with the last digit
modulo 2 not equal to 0. PASS rst introduces PArrays
forname andvisa, then creates an automaton from the
regular expression ndf16gto constrain visa's value. The
automaton is encoded into PArray formulas, which enforces
thatvisa's length is 16. Then the quantier eliminator in-
stantiates the PArrays to obtain a solution, e.g.visa =
\0000000000000001" and name = \A A".
Multiple optimizations are adopted when we incorporate
PASS into SymJS. The engine utilizes dependency solving,
cache solving and expression simplication to reduce the
burden on the solver. They work for both numeric and string
constraints. For example, in the check function, when ex-
amining condition \!visa.match(/ ndf16g/)", we do not need
to consider the constraints associated with variable name .
We apply a dependency analysis for this. Caching can speed
up the solving too, e.g.implement incremental solving im-
plicitly [5]. Similar techniques have been used in KLEE [4]
and SAGE [8], but for pure numeric constraints only. The
following shows the main steps in the optimized PASS.
JavaScript Library and Symbolic DOM. JavaScript
has a built-in library for common data structures and oper-
ations. SymJS interprets them symbolically, and optimizes
the calls so as to reduce the overhead in symbolic execu-
tion. Some optimizations are similar to those described in
[14]. The processed libraries include Number, String, Array,
Global, String, Math, and Regular Expression.
HTMLUnit contains a quite comprehensive model for HTML
DOM and Browser APIs. HTMLUnit models Chrome, Fire-
Fox, IE 8-11, and some older browsers. Since the HTMLUnit
model allows only concrete values, SymJS revises the entire
model (including hundreds of model and executable classes)
to support symbolic values.
4. AUTOMATIC WEB EVENT EXPLORER
The event explorer is essentially an automatic driver gen-
erator for Web applications. Since these applications are
event-driven, and expect user inputs, an automatic tool is
required to create scenarios that simulate user inputs and
dispatch the events automatically. The main challenge is to
curb state explosion: nevents may produce O(nk) event se-
quences of length k; the situation becomes worse when each
sequence incurs multiple paths w.r.t symbolic inputs. This
problem exists even for unit-testing since an event may de-
pend on other events. For example, an event may be created
or enabled only after a sequence is executed.
Figure 4: Main components in the event explorer.
executed states  ex=fg;
priority queue Q=f[evt]jevtis enabledg;
while Q6=fgdo
// the following executes an iteration
state= (seq;B) =Q.remove head();  new=fg;
load page; replay branch decisions recorded in B;
forall the remaining instruction instr2seqdo
executeinstr , fork new states if needed;
add new forked states into  new;
update L/RSeq and WS info for ;
update RS information for the current event;
end
ex=  ex[fg// markas executed;
Q=Q[new; // add all new/forked states
// add sequences for new events
foreach new discovered evt1do
add ([seq;evt1];B) with priority 1 into Q;
end
// add new sequences for existing events
foreach enabled event evtdo
if([seq;evt];B)=2exthen
priorityi=sizeof ((seq;B);wrevt);
add state ([ seq;evt];B) into Qwith priority i;
end
end
// reorder existing sequences
foreach ([seq;evt ];B)2Q: evt's RS is changed do
recalculate ([ seq;evt ];B)'s priority;
end
end
Algorithm 1: Feedback-directed event sequence construc-
tion during symbolic execution.
Figure 4 shows the main procedure. At each iteration,
the rst state in the priority queue Qis executed. During
the execution, the information about how the events and the
sequences read and write shared variables is recorded in the
dependency analyzer. The analyzer can be enhanced using
taint analysis. When the current state forks new states,
e.g. at feasible branches, these new states will be added
intoQ. Whennishes execution, a test case is generated,
and the New Sequence Generator constructs new sequences
based on dependency information collected so far.
4.1 Dynamic+Symb. Sequence Construction
Consider the Demo Cart example. After the page is loaded,
ve events are enabled: Clear Cart , two Add to Cart ,Set Quan-
tity,Purchase . Composing these events arbitrarily may lead
to a large number of sequences. We apply various analysis
to identify duplicate sequences so as to reduce the sequence
state space. The rst one is Write-Read (WR) analysis,which relates events according to how they write and read
shared variables. For example, the WR information of these
events is as following (due to space constraint we only show
a portion of this information).
Event Read Set Write Set
clearCart femptyCart = ftruegg
purchase ftotalPrice = f0gg
ftotalPrice = f0g, femptyCart = false,
add(\book") cart.book = fundef g, cart.book = 1,
. . .g totalPrice = 2000, . . . g
Inadd( \book" ) 's write set, variable totalPrice has value
2000, which is dierent from that in purchase 's read set.
Hence we can construct a new sequence [add( \book" );purchase] .
Here [evt1;evt2;:::] denotes a sequence containing events
evt1,evt2, . . . . In contrast, we do not build sequence [clearCart;
purchase] since clearCart does not alter the value of any vari-
able, i.e.this sequence is the same as [purchase] .
We construct sequences and collect WR information dy-
namically during symbolic execution. Algorithm 1 describes
the feed-back directed event explorer. The rst state of
the queue is rst replayed to the last forked point according
to its L/RSeq B, then continues regular symbolic execution.
The L/R sequence B(see Section 3) records the branch sides
taken so far by this sequence. We do not present Bif it is
empty. Note that the path condition is not shown here since
it will not be used explicitly. New states forked by are
recorded in  newand will be added into the queue. The
WR information of both the current sequence seqand all
executed events is updated during the execution. When 
nishes execution, if there are new discovered events, then
they will be appended to with priority 1 (indicating that
these events haven't been executed). Then for each enabled
event, SymJS uses the WR information to infer dependency
and assign priorities. The priority is the size of the shared
variable set determined by ;wr. Finally, for each each state
([seq;evt ];B), ifevt's RS information is updated, then to re-
ect the feed-backs, the scheduler recalculate this state's
priority w.r.t. the relation of seqandevt.
More formally, notations RS() and WS() return's read
set and write set respectively. The RS and WS record the
rst read value and last written value of each variable re-
spectively. In a sequence's WS, each variable has a single
value; while in an event's RS, a variable may have multiple
values collected from dierent executions of this event.
Event Chain := seqarray of events
Sequence State := seqL=RSeq
Sequence Write Set := WS=[id7!V]
Event Read Set := RS[id7!setofV]
When a sequence state = (seq;B) is nished, we gen-
erate new sequences by appending the enabled events to .
If the analyzer determines that an event evtis related to
, then a new state ([ seq;evt];B) will be created. Con-
sider the following example: state containing sequence
seqwrites variable awith symbolic value v; eventsevt1and
evt2readawith valuesf1gandf2;vgrespectively. An event
read may have multiple values corresponding to its dierent
invocations. Here andevt1are related since evt1may
read a dierent value from the one written by seq,i.e.con-
straintv= 1 is satisable. Hence we generate a new state
([seq;evt1]; l;r), which inherits seq's L/R sequence. On the
other hand, andevt2are unrelated since vis already in
evt2's RS. That is, appending evt2toseqmay fail to explore
new state space.= (seq; l ;r)evt1 evt2
WS=fa=vgRS=fa=f1ggRS=fa=f2;vgg
Dynamic Write-Read Analysis. We use;wrevtto
measure the dependency relation between sequence state
and eventevtregarding shared variables. Dependency
and data-ow analysis prevails in traditional program anal-
ysis; however the dynamic feature of JavaScript makes it
more dicult to statically calculate dependency informa-
tion. Hence we collect this information dynamically.
Named WR :;wrevt=fxjx2WS()^x2
RS(evt)g,i.e.the variables written by and read by
evt.
Valued WR :;wrevt=fxjx2WS()^x2
RS(evt)^WS()[x]=2RS(evt)[x]g,i.e.a variablexis
included if's write value to xis not in the read set of
xin . If the values are symbolic, the solver is used to
determine whether the values can be dierent. This is
the default analysis that SymJS uses.
Conditional Valued WR : the path condition is also
recorded for a read or write, and is used to determine
inequality. However our experience indicates that this
does not outperform Valued WR in practice.
An important point here is to identify shared variables at
run-time. Roughly, we name a DOM element with a unique
id, and a JavaScript shared object through traversing its
prototype chains till the global ( e.g. window) scope. A
property or variable xis named \s.x" where sis the name of
x's scope. For example, the fth element of an array object
Ain the top scope is named \window.A.5". We an skip the
\window"when the context is clear. This scheme is not 100%
accurate, but it is sucient for WR analysis in practice.
Example. Continue with the Demo Cart example. The
explorer rst adds 5 initial states into the state queue, then
executes them one by one with the Valued WR analyzer.
Supposed that the current sequence is [add( \book" )] . The
analyzer assigns priority 1 to sequence [add( \book" );purchase]
based on variable totalPrice , and to [add( \book" ); clearCart]
based onemptyCart . Similarly [add( \book" ); add( \book" )] has
priority 2. If the current sequence is [clearCart] , then the
priority of both [clearCart; purchase] and [clearCart; add( \book" )]
is 0 (meaning \unrelated"). All these sequences are added
into the queue. We show below the WR information of two
new sequences. More sequences can be constructed until a
pre-dened bound is reached.
Sequence RS WS
[add(\book"); ftotalPrice= f0g, femptyCart=false,
purchase] name.value= fsymv1g, totalPrice=2000
cart.book = fundef g, . . . g item=1, . . . g
[add(\book"); femptyCart= ftrueg, femptyCart=true,
clearCart] totalPrice= f0g,. . .g totalPrice=0, . . . g
The analyzer is able to avoid creating useless sequences
such as [clearCart; add( \pencil" );] and [add( \book" ); clearCart; pur-
chase] . In other words, SymJS implicitly prunes duplicate
sequences using the analysis. This often leads to signicant
reduction of the explored state/sequence space.
4.2 Sequence Construction via Taint Analysis
The WR analysis maintains shared variables in WR sets.
However, some variables may be irrelevant to the branches
in subsequent computations. If line/branch coverage is themain goal, then we can apply an optimization to rule out
irrelevant variables from the WR sets, and use coverage in-
formation to guide event sequence construction.
We apply a taint analysis to calculate how shared variables
ow into unvisited branches. For an event function f, the
analysis builds a map from f's branches to used variable
sets. For example, in function clearCart , the branch involves
variableemptyCart only, i.e.emptyCart is tainted w.r.t
the branch. To cover this branch, we can consider only this
variable in the WR sets.
We use symbolic execution with a shadow data-ow calcu-
lation to obtain taint information. That is, data-ow infor-
mation is collected and updated during symbolic execution
runs. The executor introduces symbolic values for input
variables, propagates values to path conditions, and checks
termination at backward control ow points. At each control
ow point, set Vsymstores all the symbolic inputs known so
far by all runs. The calculation terminates when a x-point
ofVsymon all points is reached. This mimics the traditional
use-def calculation for C or Java, except that our method is
based on dynamic symbolic execution. A traditional method
to collect taint information is to start from all sinks and cal-
culate the relevant variables by exploring the control ow
backwards. Here we show a dierent approach. For illustra-
tion, consider the following function with a loop.
function f(a,b) {
1: for (a > 0) { // use {a}
2: e = a - 2; // use {a}, def {e}
3: if (A.d > e + a) { // branch br: use {e,a,A.d}
4: a += c; ...; // use {a,c}, def {a}
5: }
6: }
}
Initially, the Vsymat each control ow point is empty.
Since the loop header uses variable a, we introduce a shadow
symbolic value to aand storesainVsym. In the rst iter-
ation of the loop, line 2 uses a, which is already in Vsym.
Then two execution states 1and2(see below, where
V0=fa;c;A:dg) are spawned at the \if" branch br, with
A:dadded into Vsym. Here property access access A:dis
resolved using the property get method presented in Section
3. Only the variable or property of a primitive type will be
made symbolic. We dynamically instantiate the type of a
shadow symbolic variable. For variable A, we use its origi-
nal value when it turns out to be an object at line 3. Hence
our analysis is not precise, but it is sucient for our data-
ow calculation.
state Selected steps with executed lines and associated Vsym
1 1 :fag; 3 :fa;A:dg; 4 :V0; 5 :V0; 1 :V0;:::; 1 :V0
2 1 :fag; 3 :fa;A:dg; 5 :V0:
The branch now uses fa;A:dg. State1executes line 4
and uses variable c. Herecis used the rst time, thus a
shadow symbolic value is assigned to c. State2takesbr's
right side and uses no variable. Their control-ows converge
at line 5. Suppose 1reaches this line rst. It updates
Vsym's new value tofa;c;A:dgfrom its old value, i.e.empty
set. SinceVsym's value is changed, state 1continues the
execution. Now, supposed 2reaches line 5. The old and
new values of Vsymare the same, hence 2terminates. Next,
1goes back to line 1 (another convergence point) and the
second iteration begins. Here Vsymat line 1 is updated to
fa;c;A:dgfromfag. Then the execution goes on as shownabove. Finally, branch bruses variablefa;c;A:dg, indicating
that variable bis not relevant to br.
The following shows more formally the calculation. For a
state, we use a set def() to record the locally dened vari-
ables (so that no symbolic values are introduced for them).
Assume that = (l;pc; [S;v1;v2;~ v];G). At a branch br,
we fork states, and record in use(br) the free symbolic vari-
ables in the path condition. When a property get or set
occurs, defandVsymare updated. Convergence points are
recorded in Lconv,e.g. the target of a jump will be added
intoLconv. An optimization is to consider only immediate
post-dominators. When such a point is reached, we check
whether ifVsymis unchanged. If yes then terminate .
Instruction Taint Operation
br:ifeql0
use(br)[=fxjx2free vars(pc)g
Lconv[=fl0g
gotol0Lconv[=fl0g
getprop
def()[=fS:v 1g ^Vsym[=fS:v 1g
ifS:v 1=2def()
setprop def ()[=fS:v 1g
l2Lconv
terminate ifVsymold=Vsym
Vsymold[=Vsym otherwise
The following shows some taint operations for state 1.
At line 1, Lconv is updated tofl1gsince the loop jumps
back tol1, and a shadow symbolic value for ais introduced.
NowVsymcontainsa,i.e.the symbolic input known so far
isa. At line 2, no new symbolic value is introduced since
ais already in def. The execution goes on till the sec-
ond iteration begins. The second loop iteration adds cinto
use(br). When the iteration nishes, this state terminates
due toSsymold=Vsym =fa;A:d;cg. Similarly other states
terminate after the second iteration, leading to a xed-point
where use(br) =fa;c;A:dgcontains all the variables rele-
vant to the target br.
line instr. Vsymolddef Vsym
1 (l1)getprop;ifeqfg f ag f ag
2 (l2)get=setpropfg f a;eg f ag
3 (l3)getprop;ifeqfg f a;e;A:dg fa;A:dg
4 (l4)get=setpropfg f a;e;A:d;cg fa;A:d;cg
1 (l1)l12Lconvfag f a;e;A:d;cg fa;A:d;cg
:::
1 (l1)l12Lconvfa;A:d;cg fa;e;A:d;cg fa;A:d;cg
It is trivial to use taint information to optimize sequence
construction: we simply exclude irrelevant variables in the
WR sets when constructing new sequences. SymJS also con-
siders only unvisited branches in the event. As shown below,
the Named WR relation between sequence state and event
evtcan be extended using taint information. The denition
of Taint Valued WR is analogous.
Taint Named WR :;taint
wrevt=fxjx2WS()^
9unvisitedbr2evt:x2use(br)g,i.e. the vari-
ables written by and relevant to at least an unvisited
branch inevt.
Example. Continue with the Demo Cart example in Sec-
tion 4.1. Supposed that sequences [purchase] and [add( \book" );
purchase] have been executed, hence the two sides of the
branch \totalPrice = 0" have been covered. Consider se-
quence [add( \pencil" )] with the following WS. Variables price
anditem do not appear in any program branch. The taint
analyzer (TA) makes use of this information, and can fur-ther rule out sequences pertaining to variable totalPrice by
analyzing the coverage.
Sequence Write Set (WS)
[add(\pencil")] ftotalPrice=30, emptyCart=false,
price=\30 cents", item=1, . . . g
The following event purchase also reads variable totalPrice .
Pure WR analysis produces a new sequence [add( \pencil" );
purchase] with priority 1, which is useless since this new se-
quence behaves the same as [purchase] in terms of branch
coverage. Specically, the two sides of \totalPrice = 0" have
been covered, and the uncovered branches in function check
do not invovle totalPrice . In contrast, the TA infers that no
variables in [add( \pencil" )] 's WS are relevant to the uncovered
branches in purchase , hence discards this new sequence.
Event ReadSet (RS)
purchase ftotalPrice = f0, 2000 g, name.value= symv1, . . . g
We also apply a simple optimization that records the path
conditionpcof an uncovered branch if pckeeps the same
during taint calculation, e.g.when the branch is not within
a loop. For example, consider the branch in function up-
datePrice . Obviously sequence [add( \book" )] covers the right
side, and sets totalPrice = 2000 . To cover the left side, the
TA infers that [add( \book" );add( \book" )] is useless since path
conditiontotalPrice < 100is falsied by totalPrice = 2000 .
Many other similar sequences are excluded.
5. EVALUATION
We evaluate both the execution engine and the event ex-
plorer. All experiments are performed on a machine with
Intel(R) Xeon(R) CPU @ 2.67GHz and 4GB memory.
5.1 Evaluating Pure JavaScript Programs
We evaluate the SymJS executor on the Sunspider 1.0.1
benchmark suite and the V8 JavaScript benchmark suite
(v7) in the latest WebKit version ( http://www.webkit.org/ ).
These benchmark programs use core JavaScript language
only, not the DOM or other browser APIs. For each program
we create a driver, where the inputs are assigned symbolic
numbers, strings, or untyped values. We intentionally write
simple drivers without investigating the programs.
Table 1 compares the results of random, manual, and
symbolic testing. The programs in the upper half of the
table are from Sunspider, and the bottom ones are from
V8. For Sunspider, we analyze representative programs, e.g.
access-fannkuch from 4 access programs. We exclude libraries
when counting the lines. For instance, after excluding \pro-
totype.js", raytrace has 918 source lines, among which 404
are executable. While each program is not large, it usually
contains expensive computations, e.g.containing embedded
loops and involving extensive bit-wise operations.
Random testing can achieve reasonable coverage but may
miss corner cases. For example, for 3d-cube , random test-
ing achieves 96 :2% line and 77% branch (taken) coverage
with 100 runs combined. For random testing, we use n=
max(100;m) runs where mis the number of tests produced
in the symbolic case. Using the tests in the original bench-
mark suite results in 92 :3% and 65:7% respectively. As in-
dicated by earley-boyer and regexp , random performs much
worse when string inputs are involved.
In contrast, SymJS produces 9 valid test cases in 6 :1 sec-
onds for 3d-cube . Among this execution time, 1% ( i.e.0:061second) is spent on solving. The coverage is increased to
98:1% (line) and 81% (branch taken). Although the en-
gine explores 9 paths, all branches can be covered by only
one test. SymJS is able to perform coverage-preserving test
reduction to exclude duplicate tests. Consider another ex-
ample | program string-validate-input that checks the name
and zip code. Its 702 tests can be safely reduced to 5.
We investigate why SymJS does not achieve full coverage
for some programs. The reasons include (1) the program
contains expensive operations (EO), especially non-linear
operations; (2) the driver is too restrictive (DR); and (3)
state explosion (SE). We mark the reasons for non-fully-
covered programs in Table 1. Specically, SymJS's con-
cretizing non-linear operations may miss paths, and expen-
sive bit-wise operations often lead to time-out of the SMT
solver and therefore the termination of the path. We some-
times need to restrict the drivers to avoid SE and EO.
Program early-boyer parser takes 1663 paths to achieve 86 :9%
branch coverage. Increasing the number of tests does not
help because the new paths contain expensive bit-wise oper-
ations that the solver fails to handle. The coverage for ray-
trace is relatively low because the code related to the\canvas"
object is unreachable in the pure JavaScript mode.
For many programs in the Table, constraint solving con-
tributes to most of the total execution time. On average,
the solver optimizations described in Section 3 can lead to
10 20% improvement on solving time. The improvement
is marginal since PASS [13] has used various inner optimiza-
tions, e.g.applying early termination and incremental solv-
ing, as well as using the automaton model lazily.
Since SymJS has achieved very high coverage for stan-
dard benchmark programs (which are typically small), and
the uncovered code is due mainly to the driver problem, we
do not perform coverage comparison of SymJS with other
JavaScript symbolic tools such as Jalangi.
5.2 Evaluating the Tool on Web Applications
Table 2 shows the results of running SymJS on 10 Web
applications, some of which are used by Artemis [1] ( www.
brics.dk/artemis ). These applications are o-line, with
all (client-side) source code stored in the local disk. We
compare random testing, symbolic testing with or without
WR analysis, and the extension with taint analysis. For each
application, we give its number of source lines (excluding
JavaScript libraries such as JQuery), the line and branch
coverage, the number of iterations (#I, see Algorithm 1),
the maximal sequence length L, the total execution time
along with the solving time percentage.
For example, application demo-cart contains 93 executable
lines. Note that some statements such as large array dec-
laration and initialization are not counted. With 100 iter-
ations, random testing can achieve 91 :3% line and 68 :7%
branch coverage with or without using WR analysis. With
naive symbolic execution we can get 98 :9% line and 93 :7%
branch coverage with 93 iterations; executing 7 more will
not increase the coverage ( e.g. many useless sequences are
explored). Applying WR analysis reduces the iteration num-
ber to 48. The entire execution takes 1 :9 seconds, 13% of
which is spent on solving. We use a 1-second wait time for
an event with timers. The maximum sequence length is 3.
Taint analysis takes 0 :4 second to run; it can help to reduce
the iteration number to 30. For some programs, taint time
\|" indicates the failure to get a valid xed-point in 2 min-Table 1: Evaluation Results on Sunspider 1.0.2 (Upper) and V8 (Bottom) Benchmark Suite
Program #Lines Random Cov. Suite Cov. Symbolic Cov.
Source Exec. Line/Br Line/Br #Tests Line/Br Cov. Exec. T Sol.% Impr.
access-fannkuch 74 44 100%/91.1% 97.7%/91.1% 12 (1) 100%/93.3% 47.6s 12% DR,EO
3d-cube 369 216 96.2%/77% 92.3%/65.7% 9 (1) 98.1%/81% 6.1s 1% EO,DR
math-cordic 85 26 100%/100% 91.8%/87.5% 30 (1) 100%/100% 0.6s 75% |
string-validate-input 99 51 92.1%/88.8% 92.5%/92.3% 702 (5) 100%/100% 9.3s 87% |
splay 386 151 90%/75.7% 91.2%/74.2% 48 (7) 92.7%/81.4% 1.5s 79% DR
richards 523 230 97.3%/96.4% 95.1%/91% 16 (3) 97.3%/96.4% 9.6s 37% DR
regexp 353 206 55.8%/50% 100%/100% 185 (92) 100%/100% 5.3s 79% |
earley-boyer(parser) 618 294 39.7%/19.1% { 1663 (52) 91.4%/86.9% 26.9s 87% DR,SE
deltablue 874 355 91.8%/70.2% 94%/70.8% 100 (4) 97.1%/82.2% 2.9s 9% DR
raytrace 918 404 84.9%/76.4% 84.6%/68.8% 11 (8) 84.9%/76.4% 65s 47% DR,EO
average 84.8%/74.5% 93.2%/82.4% 96.2%/89.8%
Table 2: Evaluation results on oine Web applications.
Program #Lines Random Symbolic (Max #I = 100)
Source Exec. #I=100 -WR +WR +WR+Taint Cov. (L/B)
Cov. (L/B) #I Cov. (L/B) #IL Time #ILTnt T. Cov.
demo-cart 146 93 91.3%/68.7% 93 98.9%/93.7% 48 31.9s(13%) 30 3 0.4s 98.9%/93.7%
form-validator 95 54 62.9/30% 71 100%/95% 71 13.6s(37%) 71 1 0.3s 100%/95%
simp-calculator 243 138 87%/74.3% 73 90.5%/80% 73 12.6s(36%) 73 1 2.1s 90.5%/80%
ball-poll 263 150 93.3%/87% 18 96%/85.1% 19 141s(17%) 19 1 { 96.6%/90.7%
3D-model 4745 227 63.8%/59.5% 45 100%/97.6% 45 1121s(1%) 45 1 69s 100%/97.6%
shopping-cart 809 400 84.6%/78.6% 49 93.1%/82.7% 49 5 6.4s(9%) 25 3 0.2s 93.1%/82.7%
maze 187 140 86.5%/63.8% 54 87.8%/69.4% 49 2 1.8s(4%) 51 2 3.4s 90%/77.7%
tetris 1396 637 59%/30.2% 89 61.8%/35% 57 3 45s(1%) 13 3 3.7s 79.1%/57.6%
fractal-viewer 1585 752 86.5%/75% 18 87.2%/76.7% 20 6142s(1%) 18 2 32s 87.6%/77%
google-pacman 3231 1454 46%/25.8% 24 72%/54.2% 24 2268s(1%) 24 2 { 72%/54.2%
average 76.1%/59.3% 88.7%/76.9% 90.8%/80.6%
Random Symbolic (+WR) Taint (+WR)
0 20 406080100demo-cart
0 5 10 156080100ball-poll
010 20 30 4060801003D-model
0 20 406080100shopping-cart
0 20 406080100maze
0 20 406080100tetris
0 5 10 15 206080100fractal-viewer
0 10 20406080100google-pacman
Figure 5: Coverage (y-axis) as a function of the iterations (x-axis) for some benchmarks.
utes, which may be caused by path explosion or exceptions
related to introduced symbolic values.
Typically, 10 to 70 iterations are required to achieve good
coverage. After that, exploring the remaining states is mostly
fruitless. The sequence lengths are from 1 to 6. Partic-
ularly, 4 applications require only singleton sequences, i.e.
the events are symbolically unit-tested.
Table 5 shows plot charts measuring the coverage over it-
erations. In most cases, we can get over 50% using a few
iterations; and the coverage improvement becomes slowerwhen #I becomes larger, e.g., for these applications, the lat-
ter half of the iterations bring <30% new coverage. Here,
complex event sequences may be needed to cover more, and
more state space reduction will be required to eliminate use-
less states so as to go deeper into the state space.
From these charts, it is clear that the symbolic method
can get higher coverage with fewer iterations than the ran-
dom method. The major advantage of symbolic+taint is to
reduce the iteration number substantially. It can also hit
corner cases that a pure symbolic method fails to nd.Clearly, it is important to use WR analysis to increase
the coverage, and taint analysis to reduce the number of
sequences. Interestingly, pure WR without taint analysis
may perform worse. Table 3 shows more information, where
various versions of demo-cart are obtained by adding list-
ing items. Consider \demo-cart2", the no-WR, Named WR,
Valued WR and taint methods need 87, 99, 49 and 36 itera-
tions to achieve the same 98 :9% coverage. For shopping-cart
(-RFS) , only the WR+taint method can beat the no WR
one. Here RFS (Restricting Shared Attributes) is a tech-
nique that considers only a subset of attributes of a DOM
element when building WR sets, e.g. it excludes unimpor-
tant attributes such as \window.height" so as to increase the
accuracy of a WR analysis. We predene this subset through
an empirical study. This experience leads us to develop an
automatic taint analyzer to identify these attributes. When
this option is turn o, pure WR analysis may perform poorly
since it considers too many irrelevant variables. In contrast,
the taint analysis is insensitive to RSV and can always iden-
tify relevant variables. Hence, in practice, taint analysis is
amust rather than an optional optimization.
Table 3: Comparing various analysis w.r.t. the iter-
ation number to achieve the same target coverage.
Program No WR +WR +Taint
Named Valued
demo-cart1 49 93 27 20
demo-cart2 87 99 49 36
demo-cart3 >100 >100 >100 28
shopping-cart (-RSV) 49 >100 >100 25
shopping-cart1 (-RSV) >100 >100 >100 19
dynamic-articles >100 >100 54 22
Table 4 compares SymJS with Artemis [1] on some shared
benchmarks. We do not include other Artemis benchmarks
which HTMLUnit cannot parse properly ( e.g.PHP les) or
SymJS cannot introduce symbolic inputs into. In general,
SymJS achieves better coverage with fewer iterations. For
example, SymJS uses 18 iterations to obtain 87 :6% line cov-
erage for program fractal-view , while Artemis obtains 75% at
iteration 80 and cannot improve the coverage further. One
reason is that SymJS does not need to guess input values
since SymJS performs symbolic execution. We could not
compare SymJS with Kudzu [21] as the end-to-end Kudzu
tool is not publicly available.
Table 4: Comparing SymJS with Artemis [1] in term
of the best coverage achieved.
Program Artemis SymJS
Cov. #Iter. Cov. #Iter.
3D-model(+lib.) 74%15 78.6% 45
ball-poll 90%65 96.6% 18
fractal-viewer 75%80 87.6% 18
google-pacman 44%15 72% 24
The coverage can be improved using various enhancements.
First of all, some browser dependent code (typically 1  
3%) in the benchmarks can be covered by simulating other
browsers. Second, currently we introduce symbolic values
for specic elements such as text inputs and radio boxes.
We observed that the coverage could be increased with more
symbolic inputs for some applications. Finally, executing
longer sequences may explore new state space. For example,
the uncovered code of tetris is due mainly to the \gameOver"
function, which will be invoked with a long sequence.On-line Applications. We have run SymJS on various
on-line Web applications including Google and Yahoo on-
line services, and popular electronic commerce sites. SymJS
communicates with the server to fetch the pages, and ex-
plores them dynamically. Preliminary results show that
SymJS can obtain 65  90% line coverage. However, excep-
tions may occur when symbolic data are sent to the server.
We leave better interactions with the server as future work.
6. DISCUSSIONS AND CONCLUSION
Additional Related Work. Feedback-directed testing has
been used for API calls in Randoop [17], and for JavaScript
in Artemis [1]. Kudzu [21] constructs event scenarios from
random testing (in a separate phase) but does not utilize
feed-backs. Unlike these tools, SymJS performs feedback-
directed event construction during symbolic execution.
WR set based analysis [2] has been used to reduce state
space for whole C programs (hence no drivers are needed).
This technique can be adopted to improve the symbolic exe-
cution of pure JavaScript programs. The approach in [9]
builds event sequences for Android applications. It also
uses WR set based dependency to connect events. The se-
quences are constructed back-ward from a model obtained
by random exploration. In contrast, our method discovers
the model during symbolic execution, constructs sequences
in a forward way, and uses taint analysis to connect events
(we have shown that pure WR is insucient). In another do-
main, [20] symbolically executes classes through a read/write
analysis to track possible changes between methods.
Regarding state explosion, we may adopt advanced state
merging techniques ( e.g. [12]) and duplicate state elimina-
tion ( e.g. [3]). For example, [3] uses dynamic slicing and
symbolic reasoning to detect duplicate states. Coverage-
directed search and reduction used in [16] may be adopted
to handle the concurrent nature of event execution. In ad-
dition, it is possible to apply symbolic encoding and loop
abstraction as in [15] to avoid explicitly enumerating all in-
teractions between dependent units such as events.
Taint analysis techniques [26, 24] use dynamic+static anal-
ysis to nd violations in Web applications. Our light-weight
method reuses symbolic execution to collect data-ow infor-
mation. More sophisticated taint analysis may help reduce
the state/sequence space further.
Conclusion. We present SymJS, a symbolic framework for
both pure JavaScript and client-side Web programs. To the
best of our knowledge, this push-button tool is the rst to
implement a symbolic virtual machine for JavaScript and
automatic driver construction with dynamic symbolic taint
analysis. The approximate development size of major com-
ponents in SymJS is 27,000 lines of Java code (counting only
our development), with around 10%, 35% and 55% for the
front-end, middle-end, and back-end respectively.
Compared to Kudzu [21] (whose focus is on string rea-
soning and security checking) and Jalangi [22] (whose focus
is on light-weight source instrumentation), SymJS aims to
provides an end-to-end, fully automatic, and comprehensive
symbolic executor. We have demonstrated how to build en-
hancements such as taint analysis in the framework. In ad-
dition to performance improvement, we plan to enhance the
interactions between the tool and Web servers. We are also
interested in detecting security vulnerabilities in websites.7. REFERENCES
[1]Artzi, S., Dolby, J., Jensen, S. H., Moller, A.,
and Tip, F. A framework for automated testing of
JavaScript Web applications. In International
Conference on Software Engineering (ICSE) (2011).
[2]Boonstoppel, P., Cadar, C., and Engler, D. R.
RWset: Attacking path explosion in constraint-based
test generation. In International Conference on Tools
and Algorithms for the Construction and Analysis of
Systems(TACAS) (2008).
[3]Bugrara, S., and Engler, D. R. Redundant state
detection for dynamic symbolic execution. In USENIX
Annual Technical Conference (USENIX ATC) (2013).
[4]Cadar, C., Dunbar, D., and Engler, D. R.
KLEE: Unassisted and automatic generation of
high-coverage tests for complex systems programs. In
USENIX Symposium on Operating Systems Design
and Implementation (OSDI) (2008).
[5]Cadar, C., and Sen, K. Symbolic execution for
software testing: three decades later. Commun. ACM
56, 2 (2013), 82{90.
[6]Dutertre, B., and Moura, L. D. The Yices SMT
Solver. Tech. rep., Computer Science Laboratory, SRI
International, 2006.
[7]Ghosh, I., Shafiei, N., Li, G., and Chiang, W.-F.
JST: An automatic test generation tool for industrial
Java applications with strings. In International
Conference on Software Engineering (ICSE) (2013).
[8]Godefroid, P., Levin, M. Y., and Molnar, D.
Sage: Whitebox fuzzing for security testing. Commun.
ACM 10 , 1 (2012), 20.
[9]Jensen, C. S., Prasad, M. R., and Mller, A.
Automated testing with targeted event sequence
generation. In International Symposium on Software
Testing and Analysis (ISSTA) (2013).
[10]King, J. Symbolic execution and program testing.
Communications of the ACM 19 , 7 (1976), 385{394.
[11]Kroening, D., and Strichman, O. Decision
Procedures: An Algorithmic Point of View . Springer
Publishing Company, Incorporated, 2008.
[12]Kuznetsov, V., Kinder, J., Bucur, S., and
Candea, G. Ecient state merging in symbolic
execution. In ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI) (2012).
[13]Li, G., and Ghosh, I. PASS: String solving with
parameterized array and interval automaton. In Haifa
Verication Conference (HVC) (2013).
[14]Li, G., Ghosh, I., and Rajan, S. P. KLOVER : A
symbolic execution and automatic test generation tool
for C++ programs. In International Conference on
Computer Aided Verication (CAV) (2011).
[15]Li, G., and Gopalakrishnan, G. Scalable
SMT-based verication of GPU kernel functions. InACM SIGSOFT International Symposium on the
Foundations of Software Engineering (SIGSOFT FSE)
(2010).
[16]Li, G., Li, P., Sawaga, G., Gopalakrishnan, G.,
Ghosh, I., and Rajan, S. P. GKLEE: Concolic
verication and test generation for GPUs. In ACM
SIGPLAN Symposium on Principles and Practice of
Parallel Programming (PPoPP) (2012).
[17]Pacheco, C., Lahiri, S. K., Ernst, M. D., and
Ball, T. Feedback-directed random test generation.
InInternational Conference on Software Engineering
(ICSE) (2007).
[18]Pasareanu, C. S., and Rungta, N. Symbolic
PathFinder: symbolic execution of Java bytecode. In
IEEE/ACM International Conference on Automated
Software Engineering (ASE) (2010).
[19]Richards, G., Lebresne, S., Burg, B., and Vitek,
J.An analysis of the dynamic behavior of JavaScript
programs. In ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI) (2010).
[20]Rizzi, E. F., Dwyer, M. B., and Elbaum, S. Safely
reducing the cost of unit level symbolic execution
through read/write analysis. ACM SIGSOFT Software
Engineering Notes 39 , 1 (2014).
[21]Saxena, P., Akhawe, D., Hanna, S., Mao, F.,
McCamant, S., and Song, D. A Symbolic
Execution Framework for JavaScript. In IEEE
Symposium on Security and Privacy (Oakland) (2010).
[22]Sen, K., Brutch, T., Gibbs, S., and Kalasapur,
S.Jalangi: A selective record-replay and dynamic
analysis framework for JavaScript. In ACM SIGSOFT
International Symposium on the Foundations of
Software Engineering (SIGSOFT FSE) (2013).
[23]Sen, K., Marinov, D., and Agha, G. CUTE: a
concolic unit testing engine for C. In European
Software Engineering Conference and the ACM
SIGSOFT Symposium on the Foundations of Software
Engineering (ESEC/FSE) (2005).
[24]Sridharan, M., Artzi, S., Pistoia, M.,
Guarnieri, S., Tripp, O., and Berg, R. F4F: taint
analysis of framework-based Web applications. In
ACM International Conference on Object Oriented
Programming Systems, Languages and Applications
(OOPSLA) (2011).
[25]Tillmann, N., and De Halleux, J. PEX: white box
test generation for .net. In International Conference
on Tests and Proofs (TAP) (2008).
[26]Tripp, O., Pistoia, M., Fink, S. J., Sridharan,
M., and Weisman, O. TAJ: eective taint analysis of
Web applications. In ACM SIGPLAN Conference on
Programming Language Design and Implementation
(PLDI) (2009).