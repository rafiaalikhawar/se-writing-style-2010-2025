Manual Refactoring Changes with Automated
Refactoring Validation
Xi Ge Emerson Murphy-Hill
Department of Computer Science
NC State University, Raleigh, NC, USA
xge@ncsu.edu, emerson@csc.ncsu.edu
ABSTRACT
Refactoring, the practice of applying behavior-preserving changes
to existing code, can enhance the quality of software systems.
Refactoring tools can automatically perform and check the cor-
rectness of refactorings. However, even when developers have
these tools, they still perform about 90% of refactorings manually,
which is error-prone. To address this problem, we propose a tech-
nique called GhostFactor separating transformation and correctness
checking: we allow the developer to transform code manually, but
check the correctness of her transformation automatically. We im-
plemented our technique as a Visual Studio plugin, then evaluated
it with a human study of eight software developers; GhostFactor
improved the correctness of manual refactorings by 67% .
Categories and Subject Descriptors
D.2.3 [ Software Engineering ]: Coding Tools and Techniques
General Terms
Design, Experimentation, Languages, Human Factors
Keywords
Refactoring, Restructuring, Tool, IDE
1. INTRODUCTION
Refactoring is the process of altering software’s internal structure
without modifying its external behavior [13]. Studies show refac-
toring can improve cohesion [20], maintainability [20], evolvabil-
ity [31], and reusability [24] of existing software systems. Because
of these beneﬁts, refactoring is an important part of modern soft-
ware development. According to Cherubini and colleagues’ survey
of427developers at Microsoft, developers consider refactoring as
important as or more important than understanding code and pro-
ducing documentation [10]. Refactoring is also an integral part of
agile development processes such as Extreme Programming [9].
Developers can perform refactorings manually or with auto-
mated tools. Manual refactorings are error-prone: according to our
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’14, May 31 – June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.previous study of twelve professional developers, one third of their
manually performed refactorings inserted defects to the software
system [15]. Automated refactoring tools will perform refactorings
for developers and automatically check their correctness, enabling
developers to quickly and safely refactor their code.
Although automated refactoring tools refactor more correctly
than developers do, developers rarely use them. According to exist-
ing studies, only 11% of145refactorings in real-world open source
systems were performed automatically [27, 37].
To solve this underuse problem, researchers have proposed novel
tools to encourage developers to refactor automatically. For in-
stance, BeneFactor and WitchDoctor automatically ﬁnish refactor-
ings after developers start refactoring manually [15, 12]. These
tools signiﬁcantly reduce, but do not completely remove, the bar-
riers to using refactoring tools. For instance, developers must still
explicitly invoke most refactoring tools. In addition, researchers
found that developers do not trust automatic refactorings to be cor-
rect [25, 11]. Existing tools remove neither of these barriers: de-
velopers are unlikely to change their behavior to use a tool they
distrust [25].
To address these problems, in this paper, we propose a novel
static analysis technique. We make the following contributions:
●A technique called GhostFactor that can detect manually per-
formed refactorings and check their correctness. GhostFac-
tor is novel for combining light-weight static analysis with
refactoring detection algorithms to quickly detect refactoring
errors. Section 4 describes the design of GhostFactor.
●We implemented our technique in an open-source plug-in for
the Visual Studio IDE [5]. This plugin, also called Ghost-
Factor, instantly notiﬁes developers when they refactor in-
correctly and suggests ways to ﬁx the error. Unlike previous
refactoring tools, GhostFactor integrates into the IDE’s noti-
ﬁcation system, a familiar mode of interaction for develop-
ers. Section 5 describes the implementation.
●We evaluated GhostFactor by conducting a human study with
eight developers. In this study, we compared how partic-
ipants refactored with or without GhostFactor. GhostFac-
tor improved the correctness of their manual refactorings by
67% . Section 6 presents the design and results of the study.
Before describing our technique, we ﬁrst provide further motiva-
tion for the technique in Section 2 and describe related work in
Section 3.
2. MOTIV ATION
One desirable property of software development tools, such as
refactoring tools, is that they should accommodate the developer,Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE’14 , May 31 – June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568280
1095
void m( bool b, int a) {
 // Do something.
}void m( int a, bool b) {
 // Do something.
}(a) A developer changes a method declaration.
m(1, true); 
m(2, false); 
m(3, false); m( true, 1);
m(2, false); 
m(3, false); m( true, 1);
m( false, 2);
m( false, 3);m(1, true); 
m(2, false); 
m(3, false); 
(b) A developer relies on compiler errors to update call sites.
Figure 1: Refactoring with compiler warnings.
rather than the developer having to accommodate the tools. In this
section, we give two common patterns developers use when refac-
toring, show how existing refactoring tools do not accommodate
this behavior, and describe how our proposed approach accommo-
dates this behavior.
Developers’ Refactoring Patterns. Our previous work found two
common patterns in developers’ refactoring behavior. We found
developers transformed their code manually nine out of ten times,
rather than using a refactoring tool [27]. Part of the reason for this is
that developers do not trust the changes refactoring tools make [25].
The second pattern we found in developers’ refactoring behav-
ior was using compiler errors to guide and check the correctness
of manual refactorings [27]. For example, suppose a developer is
going to change the signature of method m() in Figure 1a by ex-
changing the positions of its ﬁrst and second parameters. She might
ﬁrst change the method declaration, as illustrated in Figure 1a. The
compiler raises errors at all the method’s call sites, because the
types of their arguments no longer match the declared type signa-
ture. The developer can use these compiler errors to ﬁnd all the
call sites, then correct them to ﬁnish the refactoring, as illustrated
in Figure 1b.
In some cases, such as the example in Figure 1, developers
can use this pattern to ﬁnish refactorings completely and correctly.
However, this is not always the case. For example, changing the
parameters of void n(int a, int b) tovoid n(int b,
int a) will not raise any compiler errors because the exchanged
parameters share the same type. Our previous study found devel-
opers who rely on such compiler errors make more refactoring er-
rors [15].
Existing Tools Do Not Accommodate These Patterns. Existing
refactoring tools do not accommodate these common refactoring
patterns: they require developers to manually invoke them, so de-
velopers must change their workﬂow to use them. However, we
found some developers do not know what refactoring tools are
available. Even when they do, developers sometimes complete part
of a refactoring before realizing they are refactoring. They often
choose to simply complete the refactoring manually, rather than un-
doing previous changes and invoking a tool [15]. Thus, requiring
explicit invocation is a barrier to the use of traditional refactoring
tools.
The refactoring tools BeneFactor [15] and WitchDoctor [12] ad-
dress these awareness problems, but do not accommodate develop-
ers’ existing refactoring patterns. Speciﬁcally, both tools require
the developer to trust the transformations the tools make. As men-
tioned previously, many developers do not trust tools to make cor-
rect changes [25].
Our New Approach Accommodates These Patterns. GhostFac-
tor ﬁts into more developers’ workﬂows because it does not assume
that developers know about refactoring tools or trust automatic
code transformations. Our approach separates automatic transfor-
Checker2
Checker4Checker1
Checker3Conditon
Checking
History
SavingDetector1
Refactoring
Detection
Detector3Detector2
Detector4Violation/Pass 
Code 
SnapshotSnapshot
ListDetected
Refactoring Refactoring
Warning 
Active
EditorAdd/Remove
Warnings Figure 2: GhostFactor components.
mations from automatic correctness checks so developers can ben-
eﬁt from the second without adopting the ﬁrst. GhostFactor uses
familiar notiﬁcations, similar to compiler warnings, to inform the
developer of errors made while manually refactoring.
3. RELATED WORK
Before delving into the detail of GhostFactor, we ﬁrst review the
existing research related to our work. There is a huge body of ex-
isting works related to ours. We brieﬂy summarize them in the fol-
lowing categories: refactoring studies, improvement of refactoring
tools, and refactoring detection.
Refactoring Studies. Researchers have conducted multiple
studies related to refactorings. Kim and colleagues’ study sug-
gested that developers avoid refactoring tools in spite of the fact
that they know their intended refactorings can be automated [19].
Murphy-Hill and colleagues showed how refactoring tools are used
and that they are signiﬁcantly underused [27]. Based on this study,
Vakilian and colleagues further investigated how refactoring tools
are misused in various situations [35]. The study conducted by
Tokuda and Batory suggested that software evolution could be sig-
niﬁcantly accelerated by applying a set of general-purpose refactor-
ings [34]. In contrast to these studies, our study in this paper inves-
tigates whether developers can perform manual refactorings more
correctly with assistance of enhanced compiler-like warnings.
Improvement of Refactoring Tools. Researchers have pro-
posed various ways to improve automated refactoring. For in-
stance, Mens and colleagues formalize refactoring by using graph
transformations [23]. Bavota and colleagues automatically iden-
tify method chains and refactor these method chains to cohesive
classes [6]. Extending refactoring to the aspect-oriented program-
ming, Hannemann and colleagues introduced an interactive way of
transforming code base[17]. To improve the quality of refactoring
tools, Daniel and colleagues proposed an automatic testing frame-
work [11]. Lee and colleagues proposed a drag-and-drop refactor-
ing tool that liberates developers from remembering different refac-
toring types [21]. The aim of these approaches is to provide more
powerful refactoring capabilities or user interfaces; the aim of our
approach is to align refactoring tools with the way developers man-
ually refactor.
BeneFactor [15] and WitchDoctor [12] can both detect manual
refactorings and ﬁnish them automatically, relieving the program-
mer from having to recognize that the task she is about to per-
form is a refactoring. To further reduce the barriers of automatic
refactorings, GhostFactor can check the correctness of manually
performed refactorings without being invoked explicitly. Although
GhostFactor and BeneFactor share similar user interfaces, they are
signiﬁcantly different from each other. Firstly, BeneFactor looks
for incomplete manual refactorings; GhostFactor, to the contrary,
detects manually ﬁnished refactorings. Secondly, BeneFactor ap-1096Snapshot 1 Snapshot 4 Snapshot 3 Snapshot 2 
distance = 2 ...distance = 1 distance = 3 Figure 3: Snapshots compared in a snapshot list.
plies quick ﬁx changes to ﬁnish refactorings, whereas GhostFactor
applies quick ﬁxes to remedy existing refactoring errors.
Drag-and-drop refactoring tool infers developers’ refactoring in-
tention by the source and the destination of their drag-and-drop ac-
tions and ﬁnishes the intention automatically [21]. Different from
the tool, GhostFactor seeks to correct manual refactorings, instead
of eliminating the obstacle to invoking automatic refactorings.
Refactoring Detection. Researchers have proposed many refac-
toring detection techniques for various purposes. Prete and col-
leagues proposed REF-FINDER to identify complex refactorings
by using template logic rules [30]. Bavota and colleagues pro-
posed refactoring detection techniques by using semantic measure-
ment [7] and game theory [8]. BeneFactor [15] and WitchDoc-
tor [12] detect ongoing manual refactorings in order to ﬁnish them
automatically. Although in this paper we implemented algorithms
for detecting refactorings from scratch, reusing these existing tech-
niques is an alternative way to implement the refactoring detection
component of GhostFactor.
Refactoring Conditions. Conventional refactoring tools adopt
a heuristic-based technique to ensure the correctness of automatic
refactorings, namely refactoring condition checking [4]. As alter-
natives, Schäfer and colleagues proposed the concepts of depen-
dency notions and microrefactorings to implement automatic refac-
torings more understandably and correctly [32, 33]; Overbey and
colleagues proposed a language-agnostic technique called differen-
tial precondition checking [29]. In contrast, this paper applies the
conventional technique of refactoring condition checking to detect
defects introduced by manual refactorings.
4. APPROACH
GhostFactor detects developer-introduced defects to ensure the
correctness of manual refactorings. In this section, we describe its
design. GhostFactor has several independent components, each of
which handles a different task. Figure 2 illustrates these compo-
nents and how they interact with each other.
The ﬁrst component is the history saving component. This com-
ponent records the change history of different ﬁles that a developer
has worked on. It registers a listener to content change events is-
sued from the active editor. When an event occurs, the component
takes a snapshot of the source ﬁle currently opened in the active ed-
itor and saves its content in memory. The change history of a spe-
ciﬁc source ﬁle is maintained as a snapshot list to facilitate sequen-
tial access, where the head of the list is the most recent snapshot.
After saving the source ﬁle’s content and updating its snapshot list,
the component feeds the list to the next component.
The refactoring detection component detects refactorings that
the developer completes manually. This component takes the snap-
shot list for a source ﬁle as input, then dynamically loads available
refactoring detectors and applies them to the snapshot list. This
component uses each detector to compare the latest snapshot in the
snapshot list with one of the previous snapshots. For instance, Fig-
ure 3 depicts a snapshot list where the latest node is Snapshot 4 .
We show the compared snapshots by drawing arcs between them.
In this ﬁgure, we also label the distance between compared snap-
shots, where the distance is one more than the number of snapshots
between the two. GhostFactor does not compare snapshots if thedistance between them is larger than some constant maximum; we
have set this maximum 30in our implementation. This constraint
helps ensure that the detection ﬁnishes before another snapshot ar-
rives.
All the refactoring detectors share a common interface that de-
velopers can use to implement their own detectors. The interface
takes two abstract syntax trees (ASTs) of the same source ﬁle as
inputs and generates outputs that indicate whether a refactoring is
detected, the detected refactoring’s type, and the AST nodes af-
fected by the refactoring. For example, the affected AST nodes of
an extract method refactoring are the newly declared method and
the invocations of that method.
If GhostFactor detects a manual refactoring, it feeds the refac-
toring to the condition checking component . This component dy-
namically loads available condition checkers for the given refac-
toring’s type. These condition checkers can check for both pre-
conditions and post-conditions for the given refactoring [28]. All
of the condition checkers for a refactoring type share a common in-
terface with which developers can implement their own condition
checkers to add to GhostFactor. The inputs of this interface include
the detected refactoring and the ASTs in which the refactoring is
detected. The output indicates whether the refactoring violates or
passes the condition.
The last component, refactoring warning component , keeps
track of detected condition violations. Taking a condition viola-
tion as input, the component ﬁrst checks whether a warning has
already been issued for this violation. If one has, this component
discards the redundant violation; otherwise, the component saves it
and issues a new refactoring warning. Taking a passing condition
as input, the component will check whether this passing condition
resolves an existing refactoring warning. If it does, the component
dismisses this warning. For each refactoring warning, GhostFactor
also provides quick ﬁxes with which the violation can be automat-
ically resolved.
To illustrate how the last component works, we next give an ex-
ample. Suppose a developer is refactoring on a source ﬁle F, con-
secutively generating four different snapshots F1,F2,F3, andF4.
F1is the original ﬁle; F2contains an erroneous refactoring Rthat
violates a condition C;F3also contains Rviolating the condi-
tionC;F4contains the corrected Rthat ﬁxed its violation of C.
In this example, the refactoring warning component will consecu-
tively receive three different condition checking results, which are
R’s violation of C,R’s violation of Cagain and ﬁnally R’s pass of
C. According to the mechanism of the refactoring warning com-
ponent, GhostFactor will issue a refactoring warning at F2andF3,
while removing the warning at F4.
5. IMPLEMENTATION
Built on the Microsoft Roslyn project [3], we implemented
GhostFactor as a plug-in for the Visual Studio IDE to help refactor
C# software; the source code of this plug-in is open to the public1.
In this section, we describe this implementation.
5.1 Supported refactoring types
The GhostFactor plug-in currently supports the following three
refactoring types.
●Extract method : According to Fowler’s refactoring catalog,
extract method is a type of refactoring that “turns a set of
statements into a new method whose name clearly explains
that purpose of the method” [13], as illustrated in Figure 4a.
1https://github.com/nkcsgexi/GhostFactor21097void m() {
 n();
}
void n(){
 // Do something.
}void m() {
 // Do something.
}(a) Extract method.
void m() {
 n();
}
void n() {
 // Do something.
}void m() {
 // Do something.
} (b) Inline Method.
int m( int b, int a) {
 return a - b;
}int m( int a, int b) {
 return a - b;
}// ...
c=m(1, 2);
// ...// ...
c=m(2, 1);
// ...
(c) Change method signature.
Figure 4: Refactoring examples.
Fowler recommends Extract method to eliminate code smells
such as long method and duplicated code [18].
●Change method signature : Change method signature is a
refactoring type that changes the parameter list of a given
method without modifying the method’s functionality, as il-
lustrated in Figure 4c. According to Fowler’s list, change
method signature can be further divided into subcategories
such as add parameter, remove parameter, and introduce pa-
rameter object [13]. Change method signature is mainly for
eliminating code smells such as long method signature, data
clumps, and long method [18].
●Inline method : The opposite of extract method, inline
method is a refactoring type that “puts a method body into
its caller and remove the method” [13], as illustrated in Fig-
ure 4b. The refactoring is intended to eliminate methods that
are short and unnecessary [18].
We selected these refactoring types for two reasons: (1) accord-
ing to Murphy-Hill and colleagues’ previous study of refactoring
tool usage, these refactoring types are among the most frequently
performed ones [27]; and (2) in our previous study about manual
refactorings, developers introduced the most defects when manu-
ally performing extract method and change method signature [15].
For inline method, although we do not have evidence, we speculate
that it is as error-prone as extract method because of both refactor-
ings’ similar complexity.
5.2 Refactoring Detectors
To check the correctness of refactorings, GhostFactor needs to
detect them ﬁrst. Taking two versions of a source ﬁle as an in-
put, each detector outputs whether a refactoring is performed and
describes the detected refactoring for later analysis. In this subsec-
tion, we present our currently implemented detectors.
Extract Method. Our detecting algorithm for extract method
is based on the observation that after a refactoring ﬁnishes, a
new method declaration will contain part of a previously existing
method. By comparing the new method against the removed part of
the previously existing method, this detector determines whether an
extract method refactoring took place. The details of this detection
algorithm could be found in Appendix [16].
Change Method Signature. For change method signature,
GhostFactor warns developers about call sites that fail to be up-
dated after a method signature changes. In most cases, conven-
tional compiler warnings are enough to achieve this, as the exam-
ple in Section 2 illustrated. However, when the changed signature
has exactly the same parameter count and types with its previous
version, conventional compiler warnings are not able to help, as
illustrated in the manual refactoring study [15]. Our algorithm de-
tects these situations; the detail of the algorithm can be found in
Appendix [16].Inline Method. Our inline method detection algorithm is based
on the observation that simply replacing the invocations of nwith
n’s method body in m’s body before the refactoring will result in
a method that is similar to mafter the refactoring. Details of this
algorithm can be found in Appendix [16].
5.3 Condition Checkers
After detecting a manual refactoring, we next check whether
the refactoring preserves the software’s external behavior. Multi-
ple ways exist to check correctness, such as formal veriﬁcation,
testing, and checking refactoring conditions [28]. Formal veriﬁ-
cation proves the behavior-preserving of software before and after
refactorings, however this technique is prohibitively heavy, poten-
tially jeopardizing the goal of providing developers instant feed-
back [14]. Testing, or more speciﬁcally regressing testing, can ex-
pose software’s behavior changes, though a recent study from Kim
and colleagues shows that the test cases associated with a project
are often insufﬁcient to expose refactoring errors [19]. As another
option, automatically generating tests instead of using the existing
ones likely leads us to the other problems like the object-creating
issue [36].
Therefore, we chose to use similar condition checking to existing
refactoring tools [4]. Checking refactoring conditions, although ad
hoc in nature, has two advantages that other ways do not: (a) check-
ing refactoring conditions is more time efﬁcient, aligning with the
requirement of instant feedback; and (b) condition checking allows
us to issue informative refactoring warnings convenient for devel-
opers to resolve, rather than only telling that the external behavior
of the software has been changed.
Similar to the refactoring tools integrated into the mainstream
IDEs, condition checkers in GhostFactor check whether a given
manual refactoring violates a predeﬁned set of conditions. How-
ever, not every condition requires an implementation in GhostFac-
tor, because some violations can trigger conventional compiler er-
rors. Before implementing GhostFactor, we categorized the refac-
toring conditions into three categories: (1) those whose violations
trigger conventional compiler errors; (2) those whose violations do
not; (3) those whose violations sometimes do and sometimes do
not. Interested readers can ﬁnd the categorization in our project
website2. In summary, we manually surveyed the 10most fre-
quently used refactoring types, and none of them have all its con-
ditions in category (1).
GhostFactor dynamically loads condition checkers at runtime to
allow developers to easily add new checkers by implementing our
predeﬁned interfaces. We selected three refactoring conditions to
implement. The criteria for selecting these conditions were: (1)
the condition should be associated with a refactoring type that our
implementation can detect; (2) violation of the condition does not
trigger conventional compiler errors; and (3) violation of the condi-
tion should happen frequently according to our previous study [15].
In the rest of this section, we present the implementation of the
checkers for these three conditions.
5.3.1 Return Value Checker
When performing extract method, statements to extract may
modify the values of some local variables that are accessed after the
extracted statements. The modiﬁed values of these variables need
to be returned from the extracted method; otherwise the code after
the extracted statements in the original method will get incorrect
values for these variables. Take the code in Figure 5 as an exam-
ple, if we intended to extract statements from line 4to line 8, the
2https://sites.google.com/site/
ghostfactorstudy/10981  private double InternalFunction( double[] X) {
2   // ...
3   for (int i = 0; i < this._SimplexVariableList.Length; i++) {
4    if (this._SimplexVariableList[i].Fixed == false) {
5     this._ExternalVariables[i] = X[varFreeVarIndex] * this.
6      _SimplexVariableList[i].ScaleFactor; 
7     varFreeVarIndex++; 
8    } 
9   } 
10  // ...
11 }Figure 5: Code before extract method refactoring.
1 private double InternalFunction( double[] X) {
2  // ...
3   for (int i = 0; i < this._SimplexVariableList.Length; i++) {
4    LoopBody(X, varFreeIndex); 
5   } 
6   // ...
7  }
8  private void LoopBody( double[] X, int varFreeIndex) {
9   if (this._SimplexVariableList[i].Fixed == false) {
10   this._ExternalVariables[i] = X[varFreeVarIndex] * this.
11    _SimplexVariableList[i].ScaleFactor; 
12   varFreeVarIndex++; 
13  }
14 }
Figure 6: Missing return value error.
updated value of varFreeVarIndex needs to be returned and
assigned back to the local variable varFreeVarIndex . Without
returning this value, as illustrated in Figure 6, although incorrect
as a refactoring, the change will not result in compiler errors. To
help developers recognize such errors, we implement a checker for
missing return values.
The idea of the return value checker is straightforward: (1) it
ﬁrst applies data ﬂow analysis to ﬁnd local variables accessed by
the code after the extracted statements in the original method; (2)
it applies data ﬂow analysis to ﬁnd local variables written in the
extracted statements; and (3) local variables that are found in both
steps (1) and (2) need to be returned from the extracted method.
Finally, we check whether the manually extracted method has all
these variables returned and assigned back. If not, GhostFactor
will issue a refactoring warning for a missing return value at the
extracted method’s declaration.
GhostFactor provides a quick ﬁx option with the warning. After
the developer invokes the quick ﬁx, a return statement will be added
automatically and the returned value will also be assigned back to
the modiﬁed local variable, as illustrated in Figure 7. If multiple
return values are needed, GhostFactor makes the parameters pass-
by-reference.
5.3.2 Parameter Checker
When performing the extract method refactoring, the newly ex-
tracted method needs to have correct parameters. Taking the pro-
gram in Figure 5 as an example, to extract code from line 4to line
8, the extracted method needs to take Xas a parameter. Failing
to do so changes the code’s external behavior. In most cases, if
the extracted method accesses variables that are not passed, the un-
deﬁned symbols will trigger compiler errors. However, compiler
errors are not always reliable; consider the case when the extracted
method needs a parameter whose name is identical to a ﬁeld of the
containing class. Code in Figure 8 illustrates this situation.
To ensure the extracted method has the correct parameters, the
parameter checker gets the needed parameters by applying data
ﬂow analysis to the extracted statements. Next, it checks if the
extracted method has all of these needed variables as parameters.
If not, GhostFactor issues a refactoring warning for the missing pa-
rameters.
Similar to the return value warnings, a warning for missing pa-
rameters comes with a quick ﬁx option. After the developer invokes
1  private double  InternalFunction( double[] X) {
2   // ...
3   for (int i = 0; i < this._SimplexVariableList.Length; i++) {
4    varFreeVarIndex = LoopBody(X, varFreeIndex); 
5   } 
6   // ...
7  }
8  private int  LoopBody( double[] X, int varFreeIndex) {
9   if (this._SimplexVariableList[i].Fixed == false) {
10   this._ExternalVariables[i] = X[varFreeVarIndex] * this.
11    _SimplexVariableList[i].ScaleFactor; 
12   varFreeVarIndex++; 
13  }
14  return varFreeVarIndex;
15 }Figure 7: Extract method errors ﬁxed.
1 private double [] X; // A field named X exists.
2  private double InternalFunction( double[] X) {
3   // ...
4   for (int i = 0; i < this._SimplexVariableList.Length; i++) {
5    varFreeIndex = LoopBody(varFreeIndex); 
6   } 
7   // ...
8  }
9  private int  LoopBody( int varFreeIndex) {
10  if (this._SimplexVariableList[i].Fixed == false) {
11   this._ExternalVariables[i] = X[varFreeVarIndex] * this.
12    _SimplexVariableList[i].ScaleFactor; 
13   varFreeVarIndex++; 
14  }
15  return varFreeIndex;
16 }
Figure 8: Missing parameter error.
the quick ﬁx, the correct parameters will be added to the declaration
of the extracted method and the correct arguments will be added to
its call sites. Figure 7 illustrates the code after ﬁxing the error.
5.3.3 Stale Invocation Checker
The change method signature detector described in Section 5.2
detects signature changes of a method declaration where a com-
piler will not issue errors. The stale invocation checker for the
change method signature refactoring simply ﬁnds invocations of
the changed method, and issues warnings to those that have not
been updated. The warning also has a quick ﬁx option that can
automatically update all of these invocations.
5.3.4 Modiﬁed Variable Checker
This checker aims at identifying two kinds of errors when per-
forming inline method refactorings, which are incorrectly updated
variables andincorrectly non-updated variables .
When performing the inline method refactoring, after the de-
veloper replaces the invocation(s) of the inlined method with its
method body, any variable updates that were inside the method
body may now change variables’ values in its caller, possibly caus-
ing the modiﬁcation to the caller’s behavior. We illustrate this in-
correctly updated variable error in Figure 9. Notice that in the
method body of GoToDefinitionCPlusPlus , the parameter
target is updated at line 15. Suppose a developer tries to inline
the method GoToDefinitionCPlusPlus , after she replaces
its invocation in method GoToDefinition with its method
body, the logged value of target at line 6may differ from its pre-
vious version (when target == null andspan.IsSome()
== true ), introducing a subtle bug that compiler warnings will
not alert the developer about. Line 8in Figure 10 illustrates this
refactoring error.
Another error in inline method refactorings is incorrectly non-
updated variables . Also taking the code in Figure 9 as an ex-
ample, the return value of GoToDefinitionCPlusPlus is
assigned to a local variable successful at line 3. To guar-
antee the semantic equivalence, after replacing the invocation
with its method body, the developer needs to assign the value of10991  public void GoToDefinition() {
2   // ...
3   successful = GoToDefinitionCPlusPlus(text, target ); 
4   // ...
5   if (successful)
6    logger.Info(target); 
7  }
8  private bool  GoToDefinitionCPlusPlus( ITextView textView, 
9  string target) {
10   if (target == null) {
11   // ...
12   var span = wordUtil.GetFullWordSpan( WordKind .NormalWord, 
13    caretPoint); 
14   // Update parameter.
15   target = span.IsSome() ? span.Value.GetText() : null; 
16  }
17  // ...
18  return SafeExecuteCommand(CommandNameGoToDefinition);
19 }Figure 9: Code before inline method refactoring.
1  public void  GoToDefinition() {
2   // ...
3   if (target == null) {
4    // ...
5    var span = wordUtil.GetFullWordSpan( WordKind .NormalWord, 
6    caretPoint); 
7   // Error 1.
8    target = span.IsSome() ? span.Value.GetText() : null; 
9   } 
10  SafeExecuteCommand(CommandNameGoToDefinition); // Error 2.
11  // ...
12  if (successful)
13   logger.Info(target); 
14 }
Figure 10: Inline method errors.
SafeExecuteCommand tosuccessful . Failing to do so may
also cause unintentional changes to the logged message. Line 10in
Figure 10 illustrates this inline method error.
To help developers identify these inline method errors, the mod-
iﬁed variable checker again performs data ﬂow analysis, the detail
of which can be found in Appendix [16]. After identifying any of
these errors, GhostFactor presents a refactoring warning to the de-
veloper with the problem declaration, and also provides a quick ﬁx
option to help him automatically resolve this issue. After the de-
veloper clicks the quick ﬁx option, GhostFactor performs the fol-
lowing changes:
●For any incorrectly updated variable v, GhostFactor intro-
duces a new local variable v′to store the value of vbefore
the inlined statements, and assigns the value of v′back to v
after the inlined statements. Line 3and Line 12in Figure 11
illustrate how GhostFactor resolves the problem in Figure 10.
●For any incorrectly non-updated variable , GhostFactor ﬁrst
ﬁnds out return statements in the inlined method body be-
fore refactoring; next, GhostFactor ﬁnds the local variables
that are supposed to save these returned values after refac-
toring; ﬁnally, GhostFactor inserts statements that assign the
returned values to these local variables at proper positions.
Line 11in Figure 11 illustrates how GhostFactor resolves
this problem in Figure 10.
5.4 Limitations
In this subsection, we summarize the known limitations of
GhostFactor.
Snapshots. GhostFactor’s detection of manual refactorings re-
lies on the snapshots taken from the developer’s code changes,
which in turn rely on IDEs’ notiﬁcations of such event [4, 5]. Dif-
ferent IDEs notify plugins about source code changes at different
frequency. If the frequency is too low, some signiﬁcant snapshots
may be missing, leading to manual refactorings remaining unde-
tected. To deal with this limitation, we plan to investigate mech-
anisms that optimize the likelihood of manual refactorings being
1  public void GoToDefinition() {
2   // ...
3   var originalTarget = target; // Fixing error 1.
4   if (target == null) {
5    // ...
6    var span = wordUtil.GetFullWordSpan( WordKind .NormalWord, 
7    caretPoint); 
8    target = span.IsSome() ? span.Value.GetText() : null;
9   } 
10   // Fixing error 2. 
11  successful = (SafeExecuteCommand(CommandNameGoToDefinition));
12  target = originalTarget; // Fixing error 1.
13  // ...
14  if (successful)
15   logger.Info(target); 
16 }Figure 11: Inline method errors ﬁxed.
detected without losing signiﬁcant computing resources. Another
limitation is that currently GhostFactor only compares the snap-
shots of a single ﬁle to detect refactoring. For some refactoring
types, such as move method, the refactorings can only be detected
by synergically comparing snapshots across ﬁle boundaries. We
plan to add this feature in future work.
False Positives. Like most static analysis techniques, false posi-
tives happen in GhostFactor. Especially when developers interleave
their refactoring changes with non-refactoring changes, a violation
detected by GhostFactor may actually be what the developer in-
tended [27]. False positives may also lead to stubborn warnings. As
we show in Section 4, the removal of a refactoring warning relies
on the successful detection of a corrected refactoring. If GhostFac-
tor successfully detects an erred refactoring while failing to detect
its later correction, a refactoring warning may persist longer than
appropriate.
To deal with these false positives, we plan to improve GhostFac-
tor in the following two ways: (1) add a user interface affordance
that allows developers to dismiss false positive warnings and (2)
design more sophisticated algorithms for refactoring detection uti-
lizing data collected in (1).
When developers dismiss false positives in GhostFactor, the
refactoring detection algorithms could adapt future violations ac-
cordingly. For instance, when several refactoring errors are con-
secutively accepted by the developer, she is likely performing root-
canal refactorings where non-refactoring code changes are less of-
ten interleaved [27]. In that situation, GhostFactor can more ag-
gressively assume detected refactorings are actual refactorings. On
the other hand, if refactoring errors consistently marked by the de-
veloper as false positives, GhostFactor should lower the sensitivity
of refactoring detection to maintain the developer’s conﬁdence in
future error messages.
False Negatives. Developers may perform multiple refactor-
ings together, which may hinder GhostFactor from detecting some
of them. One example is when a developer ﬁrst extracts some
statements to a new method and afterwards renames the variables
used in these statements. Because GhostFactor detects the extract
method refactoring by measuring text similarity, the detection com-
ponent may not recognize this as a refactoring.
5.5 Example
We next use an example to illustrate how GhostFactor works.
Suppose Susan is a C# developer working on the DotNumeratic
open source project [2]. She has installed GhostFactor into her IDE.
One day, Susan noticed that the method in Figure 12 was undesir-
ably long. Therefore, she decided to extract part of the method into
a new method. After she manually extracted the code in the box,
Susan transformed the code in Figure 12 to the code in Figure 13.
Susan thought she had ﬁnished the refactoring correctly. Right be-
fore she started coding somewhere else, GhostFactor detected the1100Figure 12: Original code.
Figure 13: Code after manually extracting method.
refactoring by comparing the code in Figure 13 and Figure 12. Fur-
ther analysis performed by the return value checker of GhostFac-
tor found that the extracted method failed to return s. After that,
GhostFactor issued a refactoring warning to the newly extracted
method, as illustrated in Figure 14.
Susan noticed this warning message and was aware of this refac-
toring error. So she invoked the quick ﬁx options associated with
the refactoring warning, as illustrated in Figure 15. GhostFactor
automatically added a return statement and assigned sback to the
proper local variable, resulting in the code shown in Figure 16,
where the code automatically changed by GhostFactor is in boxes.
Susan refactored correctly this time with the help of GhostFactor,
which afforded her the beneﬁt of refactoring tools without requiring
her to explicitly use these tools.
6. EV ALUATION
To evaluate the effectiveness of GhostFactor in improving man-
ual refactoring’s correctness, we conducted a study with partici-
pants from both academia and industry. With this study, we intend
to answer the following three research questions:
●Q1. When manually refactoring, can GhostFactor help de-
velopers to refactor more correctly compared to not using it?
●Q2. When manually refactoring, can GhostFactor help de-
velopers achieve correct refactorings more quickly?
●Q3.How can we improve GhostFactor to better assist devel-
opers with manual refactorings?
Our study consists of three parts: (1) a pre-study questionnaire
that collects participants’ demographic data, (2) several refactor-
ing tasks for participants to manually ﬁnish, either with or without
GhostFactor, and (3) a post-study questionnaire that collects par-
ticipants’ opinions on GhostFactor. In this section, we present the
design of the study and summarize the study results.
Figure 14: GhostFactor error message.
Figure 15: GhostFactor quick ﬁx.
6.1 Pre-study Questionnaire
In total, we recruited 8participants, 6from the computer science
department of North Carolina State University and 2from local IT
companies. We required the participants have a college degree in
computer science. As compensation, each participant received a
10dollar gift card after ﬁnishing the study. Before we asked them
to perform any refactorings, we asked participants to complete a
pre-study questionnaire. The questions collected demographic data
relevant to our study. These questions include:
1. How many years have you been a programmer?
2. How familiar are you with Java programming language?
Please rate yourself from 1to5,1for not at all and 5for
expert.
3. How familiar are you with C# programming language?
Please rate yourself from 1to5,1for not at all and 5for
expert.
4. How familiar are you with refactoring practices? Please rate
yourself from 1to5,1for not at all and 5for “I refactor
every time I program”.
5. What is the percentage of your programming time involving
with refactoring? Please specify the percentage.
6. What is the percentage of your refactorings ﬁnished by ap-
plying refactoring tools? Please specify the percentage.
Table 1 presents the participants’ responses, where the number
of opaque stars indicates participants’ ratings on scales from 1to1101Figure 16: Code after GhostFactor ﬁxes.
5. The participants had a median of 5:5years for programming ex-
perience, a median Java proﬁciency of /uni2600/uni2600/uni2600/uni2600/whitestar.alt1 , a median C#
proﬁciency of /uni2600/uni2600/whitestar.alt1/whitestar.alt1/whitestar.alt1 , and a median refactoring proﬁciency of
/uni2600/uni2600/uni2600/uni2600/whitestar.alt1 . All participants considered refactoring an integral
part of their programming. Two participants, one in the treatment
group and one in the control group, indicated that they do not use
refactoring tools at all.
6.2 Refactoring Tasks
After participants ﬁnished the pre-study questionnaire, we asked
them to manually ﬁnish a set of refactoring tasks in Visual Studio
2010 . We did not mention that the purpose of the study is to evalu-
ate our tool; we only informed participants that we were interested
in how correct manual refactorings are. Afterwards, we randomly
assigned participants to the treatment group (T in Table 1) or the
control group (C in Table 1). The treatment group refactored with
GhostFactor’s assistance, while the control group refactored with-
out it. The only difference between these two groups’ development
environments was whether GhostFactor was running. Both groups
of participants were allowed to use conventional compiler warn-
ings. We also disabled GhostFactor’s quick ﬁx options to avoid
the bias introduced by automatic code completion, which could en-
able participants in the treatment group achieve correct refactorings
faster.
We selected real code examples from an open source project
called DotNumerics [2]. Written in C#, DotNumerics implements
multiple algorithms for linear algebra, differential equations and
optimization problems. We selected this project for two reasons:
(1) DotNumerics has a non-trivial code base of over 10K lines
of code, in which we easily found real refactoring opportunities;
and (2) DotNumerics contains procedures for solving well-known
mathematical problems that we expected participants to easily un-
derstand.
We selected 6code examples from DotNumerics where refactor-
ing could be properly performed. We selected these code examples
based on ﬁve criteria: (1) refactoring these code examples should
be particularly error-prone; (2) the refactorings to be performed on
these code examples should be of the types detectable by Ghost-
Factor (mentioned in Section 5.2); (3) the errors that participants
may make when refactoring these code examples should include
those checkable by GhostFactor (mentioned in Section 5.3); (4) the
code examples should not be too complex to refactor manually; and
(5) the code examples should not manifest any syntactic differences
between C# and Java, as all 8participants had less experience in C#
than in Java.Table 1: Pre-study questionnaire results for both treatment (T)
and control (C) group.
Years as
programmerJava
proﬁciencyC#
proﬁciencyRefactoring
proﬁciency
T 4 /uni2600/uni2600/uni2600/uni2600/whitestar.alt1 /uni2600/uni2600 /whitestar.alt1 /whitestar.alt1/whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
5 /uni2600/uni2600/uni2600/uni2600/whitestar.alt1 /uni2600 /whitestar.alt1 /whitestar.alt1 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
4 /uni2600/uni2600/uni2600/uni2600/uni2600 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
4 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600/uni2600/whitestar.alt1
C 9 /uni2600/uni2600/uni2600/uni2600/uni2600 /uni2600/uni2600 /whitestar.alt1 /whitestar.alt1/whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
6 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
3 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600 /whitestar.alt1 /whitestar.alt1/whitestar.alt1 /uni2600/uni2600/uni2600/uni2600/whitestar.alt1
4 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1 /uni2600/uni2600 /whitestar.alt1 /whitestar.alt1/whitestar.alt1 /uni2600/uni2600/uni2600 /whitestar.alt1 /whitestar.alt1
For all of the code examples used in our study, we refer readers
to our project website for detail. Of these 6code examples, we
asked participants to perform the extract method refactoring on 4
and the inline method refactoring on 2. We chose more examples
for the extract method refactoring because we have implemented
twice as many checkers for that refactoring. We did not include any
refactoring tasks for the change method signature refactoring. In
exploratory iterations of this study, although participants correctly
performed change method signature refactorings with GhostFac-
tor’s assistance, they refactored exactly as though they were using
compiler warnings. This indicated that including these tasks in the
study may not produce interesting results, hence we excluded them
from the study described here.
The ﬁrst author led participants through the code examples se-
quentially and asked the participants to manually complete the
refactoring tasks as correctly as possible. Before a participant
started to refactor, we reminded her or him of the deﬁnition of
refactoring correctness mentioned previously in Section 5.2. We
recorded the screencast of participants’ manual refactorings using
CamStudio [1]. We used these recordings to compare the treatment
and the control group’s refactorings to answer research questions
Q1andQ2.
Q1. With GhostFactor, can developers refactor more cor-
rectly? We answer this research question by comparing the cor-
rectness of refactorings assisted by GhostFactor and those that were
not. Figure 17a shows the number of correct refactorings for each
task performed by participants in each group. EM stands for extract
method and IM stands for inline method. Overall, we collected 24
refactoring assisted by GhostFactor, and 24refactorings performed
without GhostFactor’s assistance.
23of the 24refactorings performed with GhostFactor were cor-
rect. In contrast, only 7of the 24refactorings performed with-
out GhostFactor were correct. GhostFactor performed especially
well when assisting inline method refactoring which no participant
in the control group did correctly. GhostFactor improved our par-
ticipants’ likelihood of performing correct manual refactorings by
66:7%((23−7)/slash.left24). To further evaluate the improvement, we
performed the Mann-Whitney U test on the collected data, which
is a statistic test that assumes neither that the data follows the nor-
mal distribution nor the minimum sample size [22]. We found p
to be:001(<:01), which indicates that GhostFactor signiﬁcantly
improves the correctness of manual refactorings .
Q2. With GhostFactor, can developers achieve correct refac-
torings more quickly? We answer this research question by com-
paring the time needed to perform correct refactorings with and
without GhostFactor. Figure 17b plots the average time, in seconds,
taken by participants in each group to correctly ﬁnish tasks. Since
no participant in the control group performed the inline method
refactoring correctly, Figure 17b does not include these tasks for
participants in the control group. According to this data, the par-
ticipants who used GhostFactor ﬁnished faster in three out of four110201234
IM2 IM1 EM4 EM3 EM2 EM14 4 4 4 4
3
1 123
0 0Correct counts(a)Refactoring Correctness.
050 100150200250 Control Treatment 
IM2 IM1 EM4 EM3 EM2 EM1237244
211252
169160 158163
142
57 Average time in seconds (b)Refactoring Time.
Figure 17: Study results summary.
tasks. To further evaluate the time difference, we again apply the
Mann-Whitney U test. We found pto be:343(>:01), suggesting
thatGhostFactor may not signiﬁcantly shorten the time needed
to perform correct manual refactorings .
6.3 Post-study Questionnaire
After participants completed the refactoring tasks, we asked
them to take a post-study questionnaire. The post-study question-
naires, administered to participants in the treatment group, col-
lected participants’ opinions about their experiences with Ghost-
Factor. Before they answered these questions, we used the screen-
cast of their refactorings to show the participants which “IDE warn-
ings” they encountered were issued by GhostFactor. This ensured
that participants differentiated GhostFactor’s warnings from other
warnings in the Visual Studio IDE, such as those for undeﬁned vari-
ables and syntax errors.
The post-study questionnaire asked participants to rate their
agreement (from 1to5,1for not at all and 5for totally agree)
with the following statements:
●Refactoring warnings are useful in identifying refactoring er-
rors.
●Refactoring warnings are a desirable feature in IDEs.
Overall, the median rating for participants’ agreement with each
of these statements was 4, suggesting that developers found Ghost-
Factor useful in helping manual refactorings and that GhostFactor
may be a desirable feature in IDEs.
The second part of the post-study questionnaire was an open
question about how we could improve refactoring warnings. Par-
ticipants raised several interesting points. We use their answers to
answer the research question Q3.
Q3. How can we improve GhostFactor? One participant
suggested that “refactoring warnings are not intuitively under-
standable”. Like error messages from conventional refactoring
tools [26], the warning messages issued by GhostFactor are dif-
ﬁcult to understand in the current implementation. One way to
tackle this problem is by giving developers code examples, or by
visualizing these errors. To meaningfully compare the time to ﬁn-
ish the refactorings, we intentionally disabled GhostFactor’s quick
ﬁx suggestions during our study, but when developers use Ghost-
Factor in the wild, the quick ﬁx preview (as shown in the gray boxin Figure 15) may help developers understand refactoring warnings
better. However, better ways to convey warnings’ meaning remains
an open question for future exploration.
Another participant suggested that “refactoring warnings should
come earlier than the refactoring’s end”. He would prefer if refac-
toring warnings reminded him of possible refactoring pitfalls be-
fore or while he refactored, instead of providing corrective mes-
sages after he has already made an error. While we agree that show-
ing potential refactoring errors early may help developers perform
correct refactorings faster, knowing a developer’s intent to refactor
before he actually starts refactoring is technically difﬁcult, if not
impossible.
To better answer this research question, we also examined the
refactoring videos of those participants who used GhostFactor, but
did not refactor correctly. One participant in the treatment group
failed to complete IM2 correctly, as illustrated in Figure 17a. Delv-
ing into the causes of her error, we found that she accidentally
deleted a statement in the method where another method should
be inlined to. Even though her refactoring passed all of GhostFac-
tor’s condition checkers, our tool failed to detect that the mistakenly
deleted statement changed the program’s behavior. This observa-
tion suggests a need for new condition checkers that guarantee no
code has been unintentionally removed by a manual refactoring.
6.4 Discussion
Our study showed that GhostFactor can effectively improve the
correctness of manual refactorings. We next discuss some other
interesting observations.
Learning Effects. The data in Figure 17 suggests that partic-
ipants generally performed later refactoring tasks more correctly
and faster than earlier ones. This observation holds for participants
in both study groups. We speculate that this performance enhance-
ment was due to learning effects: participants may have applied
knowledge gained from earlier tasks to the later ones. The knowl-
edge gained might include what code elements need more attention
during manual refactoring, the meanings of refactoring warnings,
and how to resolve refactoring warnings.
Attitude towards GhostFactor. We observed that participants
sometimes over rely on GhostFactor warnings. One participant,
when refactoring manually with GhostFactor, told the ﬁrst author
that“[Warning] messages are quite informative, I feel like I am1103not really thinking”. This statement suggests that she feels Ghost-
Factor warnings are guiding her refactorings, rather than correcting
them. Ironically, one of the reasons we designed GhostFactor was
to decrease developers’ reliance on conventional compiler warn-
ings in refactoring; for this developer, GhostFactor became the tool
that she relied on too much. We believe that manually inspecting
GhostFactor warnings before addressing them is a better strategy
than totally relying on them while refactoring.
In contrast to the over-reliant participant, another participant be-
came much more careful when performing refactoring tasks after
GhostFactor ﬁrst warned him of a refactoring error. He manually
examined the correctness of each complete refactoring even when
GhostFactor found no errors. We speculate that using GhostFactor
increased his awareness of the error-prone nature of manual refac-
toring. We did not anticipate this beneﬁt to using GhostFactor.
Refactoring Time Improvement. Although the refactoring data
we collected suggests that GhostFactor does not improve the time
taken to refactor manually, we speculate that, as developers become
expert GhostFactor users, they can use GhostFactor’s assistance to
refactor faster. Also, to reduce bias introduced by quick ﬁxes, we
disabled them in the study. We postulate that developers can cor-
rect refactoring errors faster by applying quick ﬁxes. Furthermore,
GhostFactor helps developers assess the correctness of refactor-
ings, potentially saving time spent testing and inspecting refactored
code. We believe that a more comprehensive, long-term study of
GhostFactor use may show that using GhostFactor can improve the
efﬁciency of manual refactorings.
6.5 Threats to Validity
Although the study gives us conﬁdence about the usefulness of
GhostFactor, several threats need to be considered when interpret-
ing the study results.
The ﬁrst threat is the limited number of refactoring tasks as well
as the recruited participants ( 6tasks for each of 8participants),
which externally threatens the results’ generalizability to other de-
velopers’ refactoring tasks in the wild. Also, by solely studying
extract method and inline method refactorings, we cannot conclude
that GhostFactor can perform equally well when helping develop-
ers perform other types of refactorings.
Another threat is that the tasks we picked can always lead to
refactoring mistakes that GhostFactor detects. In spite that these
mistakes, according to our previously collected data, are frequent
among developers, failing to consider other refactorings performed
in the wild may lead to the hasty conclusion [15].
The third threat lies in other reasons why participants in two
groups refactor with varied correctness and speed. GhostFactor
may not be the only reason for the differences. Since we randomly
assign participants to the two groups, the participants in the treat-
ment group may by themselves have better programming skills than
those in the control group, allowing them to refactor more correctly
and quickly regardless of GhostFactor’s existence. To eliminate
this threat, in the future, we plan to assign participants according to
their reported expertise to the groups under study so that the knowl-
edge gap between the groups are minimized.
7. FUTURE WORK
We have implemented the GhostFactor technique as a plug-in Vi-
sual Studio IDE. Although the initial study yields promising results,
we plan to further explore the possibility of adopting GhostFactor
as an integral part of modern IDEs. In this section, we summarize
possible future work.
Better tool. At this point, GhostFactor only supports three types
of refactorings, namely extract method, change method signatureand inline method. Existing IDEs usually support more than 20
different refactoring types [4]. To improve the usefulness of Ghost-
Factor, adding more refactoring types is necessary. Also, as the
cornerstone of GhostFactor, we plan to improve the refactoring de-
tection algorithms in terms of reducing the false negative and the
false positive rates; thus developers can beneﬁt from the tool more
often without being frequently disrupted by spurious warnings.
Currently, GhostFactor only supports checkers for refactoring
errors that were manifested in our previously conducted studies.
However, these errors may be only a small fraction of all the refac-
toring errors developers could make. In order to better guarantee
refactoring correctness, we need to investigate more refactoring er-
ror patterns. We plan to apply data mining techniques to software
repositories to ﬁnd these error patterns. In the future, we also plan
to summarize a catalog for frequent refactoring errors like Find-
Bugs does for commonly occurring defects.
Richer Study. To evaluate GhostFactor, we conducted an in-lab
study session participated by 8developers and collected limited
amount of data. To further investigate the beneﬁt of GhostFactor as
well as its limitations, a ﬁeld study to observe what happens when
professional developers use GhostFactor under in real-world devel-
opment can be beneﬁcial. In such a setting, developers frequently
interleave refactorings with non-refactorings, potentially leading to
GhostFactor’s false positives and false negatives; measuring these
two indicators are important to evaluate GhostFactor’s effective-
ness.
Another goal of this richer study is to investigate the refactor-
ing detection algorithms. In our controlled human study, the de-
tection algorithms successfully detected all of the manual refactor-
ings performed by the participants. However, when used in the
wild, the detection algorithms’ performance is still an open ques-
tion, such as their precision and recall. The richer study may also
compare GhostFactor with other tools assisting developers’ refac-
torings, such as DNDRefactoring [21] and WitchDoctor [12], in
terms of the usability and the usefulness. Although these tools as-
sist refactoring in different ways, such a study could compare de-
velopers’ effort saved during refactoring.
8. CONCLUSION
Manual refactorings are error-prone. Although refactoring tools
are available to help, they require the developer to adapt herself to
the tool. To help create a tool that is adapted to the developer, we
proposed and implemented a novel technique called GhostFactor
that runs in the background of IDEs and warns developers about
refactoring errors in the same manner of compiler warnings, a way
that most developers accustom to. GhostFactor allows developers
to beneﬁt from refactoring tools without explicitly invoking these
tools, and works independent of how developers refactor by hand.
To evaluate the effectiveness of GhostFactor, we conducted a hu-
man study with eight software developers who performed manual
refactorings with or without the help of GhostFactor. Our evalua-
tion results provide evidences that GhostFactor improves the cor-
rectness of manual refactorings and suggests promising future di-
rections.
9. ACKNOWLEDGMENTS
We thank the study participants for participating. We also thank
the comments from the Development Liberation Front group mem-
bers Titus Barik, Michael Bazik, Brittany Johnson, Kevin Lubick,
John Majikes, and Yoonki Song. Special thanks to Jim Witschey.
This work is funded by a Microsoft Software Engineering Innova-
tion Foundation Award and a Google Research Award.110410. REFERENCES
[1] CamStudio: Free Streaming Video Software.
http://camstudio.org/, 2013.
[2] DotNumerics Open Source Project.
http://www.dotnumerics.com/, 2013.
[3] Microsoft Roslyn CTP. http://goo.gl/u5XHgq, 2013.
[4] The Eclipse Foundation. http://www.eclipse.org/, 2014.
[5] The Visual Studio IDE. http://www.visualstudio.com/, 2014.
[6] G. Bavota, A. De Lucia, A. Marcus, and R. Oliveto. A
two-step technique for extract class refactoring. In
Proceedings of the international conference on Automated
software engineering , pages 151–154, 2010.
[7] G. Bavota, A. De Lucia, and R. Oliveto. Identifying extract
class refactoring opportunities using structural and semantic
cohesion measures. Journal of Systems and Software ,
84(3):397–414, 2011.
[8] G. Bavota, R. Oliveto, A. De Lucia, G. Antoniol, and
Y . Gueheneuc. Playing with refactoring: Identifying extract
class opportunities through game theory. In Proceedings of
the International Conference on Software Maintenance ,
pages 1–5, 2010.
[9] K. Beck. Extreme programming explained: embrace change .
Addison-Wesley Longman Publishing Co., Inc., 2000.
[10] M. Cherubini, G. Venolia, R. DeLine, and A. J. Ko. Let’s go
to the whiteboard: how and why software developers use
drawings. In Proceedings of the SIGCHI Conference on
Human Factors in Computing Systems , pages 557–566, 2007.
[11] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated
testing of refactoring engines. In Proceedings of the ACM
SIGSOFT symposium on The foundations of software
engineering , pages 185–194, 2007.
[12] S. R. Foster, W. G. Griswold, and S. Lerner. WitchDoctor:
IDE support for real-time auto-completion of refactorings. In
Proceedings of the International Conference on Software
Engineering , pages 222–232, 2012.
[13] M. Fowler. Refactoring: improving the design of existing
code . Addison-Wesley Longman Publishing Co., Inc.,
Boston, MA, USA, 1999.
[14] A. Garrido and J. Meseguer. Formal speciﬁcation and
veriﬁcation of java refactorings. In Proceedings of the
International Workshop on Source Code Analysis and
Manipulation , pages 165–174, 2006.
[15] X. Ge, Q. L. DuBose, and E. Murphy-Hill. Reconciling
manual and automatic refactoring. In Proceedings of the
International Conference on Software Engineering , pages
211–221, 2012.
[16] X. Ge and E. Murphy-Hill. Appendix to Manual Refactoring
Changes with Automated Refactoring Validation.
http://goo.gl/0ty6J1, 2014.
[17] J. Hannemann, T. Fritz, and G. C. Murphy. Refactoring to
aspects: an interactive approach. In Proceedings of the
OOPSLA workshop on eclipse technology eXchange , pages
74–78, 2003.
[18] Joshua Kerievsky. Refactoring to Patterns . Pearson Higher
Education, 2004.
[19] M. Kim, T. Zimmermann, and N. Nagappan. A ﬁeld study of
refactoring challenges and beneﬁts. In Proceedings of the
International Symposium on the Foundations of Software
Engineering , pages 50:1–50:11, 2012.
[20] R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi. A case
study in refactoring a legacy component for reuse in aproduct line. In Proceedings of International Conference on
Software Maintenance , pages 369–378, 2005.
[21] Y . Y . Lee, N. Chen, and R. E. Johnson. Drag-and-drop
refactoring: Intuitive and efﬁcient program transformation.
InProceedings of the International Conference on Software
Engineering , pages 23–32, 2013.
[22] H. B. Mann and D. R. Whitney. On a test of whether one of
two random variables is stochastically larger than the other.
Annals of Mathematical Statistics , 18:50–60, 1947.
[23] T. Mens, N. Van Eetvelde, S. Demeyer, and D. Janssens.
Journal of software maintenance and evolution: Research
and practice. J. Softw. Maint. Evol. , 17(4):247–276, 2005.
[24] R. Moser, A. Sillitti, P. Abrahamsson, and G. Succi. Does
refactoring improve reusability? In Proceedings of
International Conference on Reuse of Off-the-Shelf
Components , pages 287–297, 2006.
[25] E. Murphy-Hill. Programmer-friendly refactoring tools.
Dissertation Proposal, 2007.
[26] E. Murphy-Hill and A. P. Black. Programmer-friendly
refactoring errors. IEEE Transactions on Software
Engineering , 38(6):1417–1431, 2012.
[27] E. Murphy-Hill, C. Parnin, and A. P. Black. How we refactor,
and how we know it. IEEE Transactions on Software
Engineering , 38(1):5–18, 2012.
[28] W. F. Opdyke. Refactoring object-oriented frameworks . PhD
thesis, University of Illinois at Urbana-Champaign, 1992.
[29] J. L. Overbey and R. E. Johnson. Differential precondition
checking: A lightweight, reusable analysis for refactoring
tools. In Proceedings of the International Conference on
Automated Software Engineering , pages 303–312, 2011.
[30] K. Prete, N. Rachatasumrit, N. Sudan, and M. Kim.
Template-based reconstruction of complex refactorings. In
Proceedings of the International Conference on Software
Maintenance , pages 1–10, 2010.
[31] J. Ratzinger, M. Fischer, and H. Gall. Improving evolvability
through refactoring. In Proceedings of the international
workshop on Mining software repositories , pages 1–5, 2005.
[32] M. Schäfer and O. de Moor. Specifying and implementing
refactorings. In Proceedings of the International Conference
on Object Oriented Programming Systems Languages and
Applications , pages 286–301, 2010.
[33] M. Schäfer, M. Verbaere, T. Ekman, and O. de Moor.
Stepping stones over the refactoring rubicon – lightweight
language extensions to easily realise refactorings. In
Proceedings of the European Conference on Object-Oriented
Programming , pages 369–393, 2009.
[34] L. Tokuda and D. Batory. Evolving object-oriented designs
with refactorings. Automated Software Engineering ,
8(1):89–120, 2001.
[35] M. Vakilian, N. Chen, S. Negara, B. A. Rajkumar, B. P.
Bailey, and R. E. Johnson. Use, disuse, and misuse of
automated refactorings. In Proceedings of the International
Conference on Software Engineering , pages 233–243, 2012.
[36] X. Xiao, T. Xie, N. Tillmann, and J. de Halleux. Precise
identiﬁcation of problems for structural test generation. In
Proceedings of the International Conference on Software
Engineering , pages 611–620, 2011.
[37] Z. Xing and E. Stroulia. Refactoring practice: How it is and
how it should be supported - an eclipse case study. In
Proceedings of the International Conference on Software
Maintenance , pages 458–468, 2006.1105