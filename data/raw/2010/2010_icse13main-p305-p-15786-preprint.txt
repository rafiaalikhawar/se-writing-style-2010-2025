Coupling Software Architecture and Human
Architecture for Collaboration-Aware System
Adaptation
Christoph Dorn∗†
∗Distributed Systems Group
Vienna University of Technology, Austria
dorn@infosys.tuwien.ac.atRichard N. Taylor†
†Institute for Software Research
University of California, Irvine, USA
{cdorn|taylor}@uci.edu
Abstract—The emergence of socio-technical systems charac-
terized by signiﬁcant user collaboration poses a new challenge
for system adaptation. People are no longer just the “users”
of a system but an integral part. Traditional self-adaptation
mechanisms, however, consider only the software system and
remain unaware of the ramiﬁcations arising from collaboration
interdependencies. By neglecting collective user behavior, an
adaptationmechanismisunﬁttoappropriatelyadapttoevolution
of user activities, consider side-e ﬀects on collaborations during
the adaptation process, or anticipate negative consequence up on
reconﬁguration completion.
Inspired by existing architecture-centric system adaptation
approaches,weproposelinkingtheruntimesoftwarearchitectur e
to the human collaboration topology. We introduce a mapping
mechanism and corresponding framework that enables a system
adaptation manager to reason upon the e ﬀect of software-level
changes on human interactions and vice versa. We outline the
integration of the human architecture in the adaptation process
and demonstrate the beneﬁt of our approach in a case study.
Index Terms —collaboration topology, software architecture,
runtime mapping, architecture reconﬁguration, dynamic adap-
tation
I. Introduction
In 2006, Northrop et al. [1] identiﬁed Ultra-Large-Scale
(ULS) systems as the major future software engineering chal -
lenge. Among the deﬁning characteristics of ULS systems are
decentralized control, conﬂicting and changing requireme nts,
continuous evolution, heterogeneous and dynamic system el -
ements, ubiquitous failures, and erosion of the people /system
boundary. This paper focuses primarily on the implication o f
that last aspect on system (self-) adaptation. People are no
longer just the “users” of a system but an integral part [1] p1 3.
Consequently human interactions are highly relevant to the
design and adaptation of ULS systems ([1] p31 ﬀ). We believe
that this is true not only for ULS systems but also for tradi-
tional medium and large-scale systems. Any system heavily
relying upon signiﬁcant user collaboration needs to explic itly
addresshumaninteractionimplicationsduringdesign-tim eand
runtime.
Among the many adaptation approaches, architecture-drive n
techniques appear to be the most applicable to systems ex-
hibiting ULS characteristics. Kramer and Magee [2] arguethat an architecture-based approach provides (i) concepts and
principles applicable across domains, (ii) su ﬃcient abstraction
from the algorithmic and network level while still capturin g
dynamic change, and (iii) scalability through hierarchica l
composition, thereby facilitating the speciﬁcation of sys tems
of systems. In addition, architecture-driven adaptation t ech-
niques are among the earliest [3] and continuously relevant
approaches [4] as demonstrated by successful application t o
mobile environments [5], robotics systems [6], and adaptiv e
service compositions [7].
Current architecture-driven adaptation mechanisms, how-
ever, consider only the software system and remain unaware o f
the ramiﬁcations arising from collaboration interdepende ncies.
A system neglecting the collective user behavior might su ﬀer
from some of the following example weaknesses:
•The system is unable to support the e ﬃcient operation
and evolution of user behavior. For example, failing
to provide appropriate coordination mechanisms when
groups of users change their behavior from sequential
resource access to simultaneous resource access.
•Conversely, the system cannot anticipate the conse-
quences of particular software adaptations. Disregarding ,
for example, user proximity, user role, or user capacity
might result in reconﬁgurations that jeopardize a team’s
performance due to increasing the likelihood of informa-
tion overload, information delay, information scarcity, o r
resource access conﬂicts.
•Likewise,thesystemisunabletoreasonaboutside-e ﬀects
during the software reconﬁguration process. A database
schema update, for example, might have the implicit
assumption that humans are in a state of quiescence
upon commencing an update, potentially interrupting all
ongoing interactions.
•The system remains unaware of users becoming bot-
tlenecks. Unavailable or overloaded users slow down
critical processes when they are responsible for manually
triggering key tasks.
We propose linking the system’s software architecture to
humaninteractions.Speciﬁcallywedescribethesystem’su sers978-1-4673-3076-3/13 c2013 IEEE ICSE 2013, San Francisco, CA, USA
Accepted for publication by IEEE. c2013 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including reprinting/
republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this work in other works.53in terms of human components and collaboration connectors
along with their means of communication and coordination.
To this end, we apply the human Architecture Description
Language (hADL) introduced in our previous work [8] for
specifying a system’s underlying collaboration topology, and
the eXtensible Architecture Description Language (xADL [9 ])
for specifying the software architecture. Explicit non-tr ivial
design-time mappings between hADL and xADL elements
allow, during runtime, the matching of software component
(and connector) instances to users and their interactions.
Adaptation rules can subsequently utilize the hADL model,
for example, for prioritizing the replication of component s
associated with key collaborators.
The main contributions of this paper are
•a model for mapping from software architecture to human
collaboration patterns and vice versa
•a framework for detecting runtime software architecture
changes andreﬂectingthosechanges inthehumancollab-
oration topology according to the predeﬁned mappings.
•a discussion on integrating human architecture and soft-
ware architecture for system adaptation.
•a case study demonstrating the beneﬁt of turning soft-
ware architecture-centric self-adaptation strategies to be
collaboration-aware.
The remainder of this paper is structured as follows. Sec-
tionIIandIIIprovideamotivationscenarioandadiscussio nof
related work, respectively. Section IV summarizes backgro und
information, an overview of our approach, and the architect ure
mapping rationale. Section V details the design-time mappi ng
speciﬁcation and the runtime mapping process. We discuss th e
application of our framework for collaboration-aware syst em
self-adaptation in Section VI. A case study in Section VII
demonstrates actual adaptation beneﬁts. Finally, Section VIII
gives an outlook on future work and concludes this paper.
II. Motivating Scenario
Monitoring and safety systems range in scope from a
small security team handling an o ﬃce building to thousands
of personnel in back o ﬃces and on site at geographically
distributed locations to secure critical infrastructure. These
systems tightly interweave people and software components
and hence need co-adaptation of collaboration structures a nd
software architectures. In the building monitoring case, b ack
oﬃce operators utilize high deﬁnition video streams, ﬂoor
plans, building sensor feeds, occupancy logs, and communic a-
tion channels with on-site security sta ﬀ. Reassigning observa-
tion tasks among team members, reacting to non-responding
team members, or adding new team members are examples of
collaboration-driven adaptations that result in changes t o the
underlying software structure.
The adaptation mechanism needs to react to software-level
events such as failing components, congested data links, an d
emergence of new information sources. At the same time it
requires maintenance of various QoS metrics such as accept-
able video delay, video stream availability, and bandwidth costthrough continuous adaptation of video relay replication a nd
video stream rerouting.
In the presence of scarce resources, the adaptation mech-
anism has to prioritize the adaptation of particular relays
and video streams. To this end, it requires awareness of the
collaboration topology and user roles. Consider the softwa re
architecture in Figure 1 consisting of components for Strea m-
ingServers, VideoSources, GUIs for each role, and connecto rs
for coordinating video publishing, subscribing, and deliv er-
ing activities. This architecture may serve as the underlyi ng
communication infrastructure for two, quite distinct coll abo-
ration topologies (Fig. 2 and Fig. 3). The publish /subscribe
human architecture in Figure 2 speciﬁes the following human
components: FieldAgents provide video streams ( PubStreams ),
whereasBackoﬃce Agents ,Assistants , andTeam leaders sub-
scribe to video streams ( SubStreams ).VideoPubSub collabo-
ration connectors—typically but not necessarily implement ed
as software entities—manage video stream publication and
subscription. Video feeds may be replicated across multipl e
VideoPubSub connectors in accordance with the software
architecture. All users have access to a WallScreen (a collab-
oration object of type Shared Artifact) for displaying rele vant
video streams. The collaboration topology in Figure 3 lacks
such a ﬂat organizational hierarchy and instead features a
pipes/ﬁlters-style collaboration structure. Individual agents re-
ceivetheirvideofeedsasdeemedrelevantbytheirpredeces sor.
A Backoﬃce Agent, for example, routes a PipeStream to an
Assistant. Ultimately only the Team leader has access to the
WallScreen.
Suppose an adaptation mechanism reconﬁgures the soft-
ware architecture to maintain system reliability by avoidi ng
individual StreamingServers from becoming overloaded. Si -
multaneously, it should ensure that the team leader has (the
most) reliable streams. Without a mapping between software
and collaboration structure, it would be unable to make an
informed decision between adaptation action “replicate team
leader video streams” (suitable for the human architecture in
Fig. 2) or action “equal component replication along the video
relay chain” (suitable for the human architecture in Fig. 3).
We will be using these conﬁgurations throughout the paper fo r
explaining the mapping process at runtime and design-time,
the adaptation process, and the ﬁnal evaluation.
III. RelatedWork
Our work builds on the insights of architecture-based adap-
tation research. As early as 1999, Orzeiy et al. [3] outlined
the process for reﬂecting runtime changes in an architec-
tural model as the basis for dynamic adaptation. Subsequent
work focused predominately on architecture-based adaptat ion
techniques such as the Rainbow framework [10], the K-
Component Architecture Meta-model [11], Model-based de-
velopment [12], or Object-oriented design adaptation [13] . In
line with such previous work, our framework also features
an architecture runtime manager and the adaptation mecha-
nism follows the feedback loop described by the autonomic54Fig. 1. Software Architecture: Surveillance Video Monitor ing.
Fig. 2. Collaboration Architecture: Publish /Subscribe-style Surveillance Team. Information ﬂows from le ft to right along collaboration links. Each link
connects two collaboration actions (3-letter abbreviated :send,forward,receive,display).
Fig. 3. Collaboration Architecture: Pipes /Filters-style Surveillance Team. Information ﬂows from left to right along collaboration links. Each link connects
two collaboration actions (3-letter abbreviated: send,forward,receive,display).
computing MAPE-K model: Monitoring, Analysis, Planning,
Execution, and Knowledge.
As we pointed out in the introduction, these techniques
focus exclusively on adapting the software architecture. U ser
preferencesandusercontextdriveadaptationinmobilesce nar-
ios (e.g., the MADAM architecture model [5]) but the applied
techniques still remain unaware of collaboration dependen cies.
The novel aspect of our research is mapping the human
architecture (hADL) to the software architecture (xADL) at
designtimeandruntime.AswewilldemonstrateinSectionVI ,
having two distinct, but constantly synchronized views on t he
system gives rise to unique adaptation opportunities.
Note that linking of the xADL and hADL architecture
models should not be mistaken for the three-layer architect uremodel [14], typically applied for self-adaptation in the ro botics
domain [6]. The three-layer model describes a strict hierar chi-
cal separation of goal management, change management, and
change execution. In contrast, we propose to apply software
architecture and human architecture simultaneously acros s all
steps of the MAPE-K model.
Enhancing software architecture models with domain spe-
ciﬁc properties enables analysis beyond structural consis tency.
Edwards and Medvidovic [15] apply multi-model composition
in their XTEAM framework to simulate reliability, power
consumption, and performance. Di Ruscio et al. [16] utilize
model mapping and transformation techniques for integrat-
ing multiple architecture concerns (e.g., fault tolerance and
activity ﬂow). The SASSY framework [17] provides service55activity schemas and service sequence scenarios to specify
QoS requirements in service-oriented architectures. Fina lly,
Bhave et al. [18] augment software architectures with phys-
ical properties and behavioral annotations, thus enabling an
integrated speciﬁcation of cyber-physical systems such as
quadrotors. The main di ﬀerence compared to our approach
is the extremely tight coupling of the various architectura l
views such that no separate mapping and tracing is foreseen
or required during runtime.
The business process modeling domain traditionally in-
cluded some aspects of human involvement. Business Process
Model and Notation BPMN [19] consists of constructs for
describing activities in business processes, their depend encies,
artifacts, and involved events. BPMN processes typically m ap
to BPEL, the Business Process Execution Language, for
execution. The BPEL4People [20] extension utilizes human
tasks for integrating users into otherwise Web-service bas ed
workﬂows. Human tasks support assignment to generic roles,
ownership delegation, and coordination mechanisms such as
four eyes ,nomination , orescalation . Both languages pri-
marily target service-oriented architectures with limite d or
no support for other common architectural styles such as
Peer-to-Peer, Components and Connectors (C2), or Publish-
Subscribe. Likewise, support for collaboration is limited to
isolated execution of individual task items from a work list .
Dynamic patterns for joint work on shared artifacts, publis h-
subscribe information distribution, organizational cont rol, or
request routing in social networks and thus also the pattern s’
adaptation implications [21] remain outside the scope of
BPMN and BPEL. The Human-provided Service framework
(HpS) [22] oﬀers more ﬂexible user collaboration but lacks
support for structural patterns at the human level and the
software level.
As a ﬁnal note for clariﬁcation and caution: we cannot
rely on insights from Conway’s Law [23] or socio /technical
congruence [24] when describing the mapping between col-
laboration structure and software architecture. We model t he
structure of the users’ organization rather than the develo pers’
organization.
IV. Approach
A. Background
We ﬁrst proposed linking software architecture and human
collaboration models in our 2012 ICSE New Ideas and Emerg-
ing Results track paper [25]. It describes the general idea
and approach to achieve co-adaptation and introduces basic
concepts. In this paper we focus in detail on the models
and mechanism for reﬂecting runtime software architecture
changes in collaboration topologies and how to apply these
synchronized views for sophisticated system adaptation.
The co-adaptation of software architecture and human col-
laboration requires models for specifying the involved run time
elements and their relations. Components and connectors
are the primary building blocks of a software architecture.
Components are the loci of computation and data manage-
ment whereas connectors facilitate and control the interac tionsbetween components. Based upon Malone and Crowston’s
observation that human collaboration and software systems
share similar coordination requirements [26], we argue for
a similar distinction among humans according to work-
focused and coordination-focused roles. Along these lines
we recently introduced the human Architecture Description
Language (hADL) for describing collaboration topologies in
terms of human components and collaboration connectors [8]
(see Fig. 2 and Fig. 3 for examples). Software architecture a nd
human architecture models are thus the core artifacts of our
approach.
MAPE Steps Adaptation 
Knowledge
Runtime 
Mapping
Runtime 
SystemSoftware 
ArchitectureMapping 
TemplatesCollaboration 
TopologyHuman 
Architecture
Domain-specific 
Probes/Sensorsref
ref
Software 
Artifactsrefref
+MonitoringAnalysisPlanningExecutionDesign-time Runtime
[hADL ] [hADL]
[xADL]Runtime SW 
Architecture
[xADL]
Fig. 4. Reﬂecting software architecture changes in the human architecture
for collaboration-aware system adaptation.
B. Mapping and Adaptation Overview
Given the software architecture and human architecture
description, a software architect speciﬁes at design-time how
software elements map to collaboration elements and vice-
versa. Software architecture-centric events are the prima ry
source for creating a runtime view of the overall system. Our
approach aims to leverage these events as much as possible fo r
inferring the collaboration topology (Fig. 4 middle). The m ap-
ping speciﬁcation identiﬁes conﬁgurations where software -
centric events are insu ﬃcient. An event, for example, may
describe a new link between an AgentGUI component and a
StreamingServer component hosting multiple video streams .
While such an event provides su ﬃcient information at the
software architecture level, additional information is re quired
to unambiguously connect the respective human agent to a
particular SubStream. We thus embed not only software archi -
tecture but also human architecture and mapping speciﬁcati on
in the software artifacts (Fig. 4 left).
System adaptation typically requires additional domain-
speciﬁc events besides architecture-centric changes. Whil e
independent from the software architecture and collaborat ion
topology,suchinformationdescribesruntimesoftwareand col-
laboration elements in further detail. Eventually, an adap tation56manager utilizes the runtime software architecture, runti me
mapping, and collaboration topology in each adaptation ste p
(monitoring, analysis, planning, and execution) to detect and
react to critical situations (Fig. 4 right).
C. The Case for an Explicit Architecture Mapping
Multiple generic, extensible, and domain-speciﬁc
architecture description languages already exist (e.g.,
ACME [27], xADL [9]) and one could argue that collaboration
structures should be embedded at the software architecture
level. There are multiple reasons, however, why a separate
human architecture model, and thus an explicit, non-trivia l
mapping, is a better choice:
•Collaboration patterns are su ﬃciently independent from
their implementing software architecture style, and even
more so from the detailed software topology. For example,
a collaboration system for a rescue task force can be
realized as a peer-to-peer system for environments without a
communication infrastructure. Alternatively, the client /server
style is suitable when a reliable communication infrastruc ture
is available. A collaboration pattern based on supervisors
assigning tasks to workers and subsequently collecting the ir
feedback, however, remains in both cases the same. Similarl y,
the same software architecture style supports di ﬀerent
collaboration patterns as demonstrated in the motivating
scenario in Section II.
•Software architectures are typically more ﬁne-grained tha n
collaboration structures. Spreading collaboration struc ture
descriptions as annotations across software elements make s
it hard to obtain a clear picture of the overall human
architecture.
•Structural changes at the collaboration level rarely
correspond to structurally equivalent changes at the softw are
level and vice versa. Hence, collaboration changes would
remain unnoticed in the software structure, while software
topology changes would require additional analysis whethe r
the human architecture remained the same.
•Adaptation relevant properties potentially ﬁt more natura lly
with hADL elements and thus allow for devising more
understandable and manageable adaptation triggers, analy sis
logic, and adaptation strategies.
•An explicit human architecture keeps the focus on the
user and team perspective and thus gives stake-holders an
additional model for communicating requirements during th e
design process. This also enforces a structured approach to
explicitly deﬁning adaptation and evolution capabilities at the
collaboration level.
V. TheArchitecture MappingProcess
A. Design-Time Mapping Speciﬁcation
Synchronizing software architecture and collaboration
topology at runtime requires the software architect to spec ify
how software elements map to collaboration elements and
vice versa. Our framework utilizes the eXtensible Architec ture
Description Language (xADL [9]) for describing softwarecomponent types, connector types, interface types, and con -
tainment hierarchies. On the collaboration level, we apply
the human Architecture Description Language (hADL [8]) for
specifying human component types, collaboration connecto r
types, collaboration object types, collaboration action t ypes,
and substructure patterns.
Large-scale systems are typically too dynamic and complex
for completely specifying all involved elements and their
precise wiring at design-time. Thus, we can neither a-prior i
fully describe the runtime software structure in xADL nor
the collaboration topology in hADL. Consequently, we ﬁrst
deﬁne templates that specify for xADL and hADL separately
how the various model elements are correctly assembled and
connected at runtime. For example, Figure 5 displays on the
left a software architecture blueprint for connecting vide o
sources, connectors, streaming server, and video sinks. Th e
dotted frames and lines represent individual templates. Th e
corresponding collaboration topology and templates for th e
publish/subscribe (human) collaboration pattern are given on
the right. We subsequently need additional mapping informa -
tion to identify which xADL template corresponds to what
hADL template (dash-dotted lines in Figure 5).
In other words, a set of xADL, respectively hADL, tem-
plates behaves similar to a set of jigsaw pieces: we arrange
all pieces according to their shape (i.e., signatures /actions)
and obtain a valid overall picture (i.e., architecture). To know
which two xADL and hADL pieces go together and where
they are supposed to interlock within their respective puzz le,
we also need to deﬁne matching tabs /blanks (i.e., an Interlock
Point Pair ). See for example the two jigsaw pieces for the
Mapping Speciﬁcation 2 in Fig. 6 left.
Given a software architecture blueprint and collaboration
pattern as input, a complete software-to-collaboration ma pping
speciﬁcation thus consists of four main parts:
•a set ofxADL elements (e.g., a StreamingServer component,
PublishVideo connector, SubscribeVideo connector, and li nks
from both connectors to the component). The speciﬁcation
refers to the architecture blueprint elements and not the ac tual
element type deﬁnition. A type potentially occurs multiple
times in a template such as the ReceiveVideoAgent connector
and ReceiveVideoWallScreen connector which are both de-
rived from the ReceiveVideo connector type.
•a set ofhADL elements (e.g., VideoPubSub collaboration
connector, SubStream collaboration object, and the link be -
tween).
•a set ofInterlock Point Pairs deﬁnes the intersection of two
mappings in the software architecture, and where to locate t he
corresponding interlink at the human architecture level.
A single interlock point pair identiﬁes exactly one xADL
interface and exactly one hADL collaboration action. The
xADL interface establishes joint points of two xADL puzzle
pieces, the hADL action speciﬁes the joint points between tw o
hADL puzzle pieces. Consider the mapping template x1h1 in
Fig. 5: the VideoSource’s sendPubStream interface pairs up
with the PubStream’s forwardaction.
•theMappingType determines how many instances of the57Fig. 5. Example mappings between video streaming architecture blueprint (xADL) and publish /subscribe collaboration pattern (hADL). Mapping 1, for
example, consists of xADL element set x1 and hADL element set h1. Mappings for Assistant and Teamleader and corresponding xAD L elements are omitted
for sake of clarity.
xADL elements may map to how many instances of the hADL
elements. In many cases a simple one-to-one mapping will
be insuﬃcient. A xADL template instance (e.g., a Stream-
ingServer incl. Connectors) may represent multiple hADL
elements (e.g., VideoPubSub collaboration connectors inc l.
SubStreams). Hence, the following mapping types exist: exa ct
1-to-1such as the VideoSource to FieldAgent +PubStream
(e.g.,x1h2 inFig.5),aggregating 1-to-M(e.g.,x3h3 inFig.5),
replicating N-to-1for providing the same video stream on
many servers, or a combination thereof ( N-to-M).
Note that the mapping speciﬁcation includes only elements
that are needed to maintain an unambiguous mapping to col-
laboration elements. Thus, a software architect typically omits
software elements irrelevant to the collaboration topolog y and
vice versa (e.g., the link between the AgentGUI component
and the SubscribeVideo connector). For the example in Fig-
ure 5, a total of 13 mapping deﬁnitions link the software
architecture and the collaboration structure (including t he six
mappings for Assistant and Teamleader not shown).
Our framework leverages software architecture-centric
events as much as possible. However, we determine the need
for additional disambiguation events already at design-time
when we derive from the mapping speciﬁcation that software-
level events won’t allow for conclusive mapping execution
at runtime. At runtime, the link between a VideoSource
component and a PublishVideo connector, for example, maps
1-to-Mto the PubStream-to-VideoPubSub link (mapping x5h5
in Fig. 5). Here we need a disambiguation event to deﬁne
which VideoPubSub (among the many hosted by the Stream-
ingServer) the hADL link should connect to. Applying the
jigsaw analogy: non 1-to-1mappings result in stacked puzzle
pieces, for example, mapping instances 1a and 1b in Figure 6.
A new mapping instance 4needs to decide whether linking
its hADL piece to mapping 1aor1b. A disambiguation event
merely needs to identify any one xADL element involved in
the completed hADL piece 4xand any one hADL element
from the targeted, existing hADL piece 1a.Identifying at design-time where disambiguation events ar e
required is straightforward: every Interlock PointPair in volved
in a1-to-MorN-to-Mmapping highlights the need for a
corresponding disambiguation event. The developer can the n
select from the hADL and xADL sets which information
will be provide in the disambiguation event. Before system
deployment, type information from xADL and hADL models
and disambiguation event requirements become embedded in
the software artifacts. The exact means (e.g., through sour ce
code annotations, middleware conﬁguration, or sensor con-
ﬁguration) remains outside the scope of this paper (see, for
example, [28], [3], [6]).
Mapping Specification 2
321
x x
x4
x4
H3
H21Comp
Obj
Conn
CompH
X2
H H
?hADL part1a1b
New 
Mapping 
Instance
xADL part Interlock
PointPair A
Interlock
PointPair B
Fig. 6. Utilizing interlock point pair deﬁnitions to insert hADL and xADL
mappings correctly.
B. Runtime Template Matching and Execution
Atruntime,the SoftwareArchitectureManager receivessys-
tem events describing the type and identity of newly deploye d
software elements, their wiring, respectively their termi nation,
and translates them into software architecture change even ts
(i.e., new/deleted component /connector/link) (Fig. 7 1).
For removal of existing elements, the Mapping Template
Matcher takes these architecture change events and merely
retrieves the respective mapping instance (Fig. 7 2a). For n ew
elements, however, it determines a set of candidate mapping s
(Fig. 7 2b). Each xADL element type is potentially part of58Fig. 7. Artifacts and Steps involved in the Mapping Template M atching process.
multiple mapping deﬁnitions (e.g., the link between Stream -
ingServer and ReceiveVideo connectors is of the same type fo r
AgentGUI, AssistantGUI, TeamLeaderGUI, and WallScreen),
but ultimately only part of a single mapping instance. The
Mapping Template Matcher keeps adding architecture change
events to mapping candidates until at least one candidate
contains all required xADL elements (Fig. 7 3a). All re-
maining candidates are discarded. Matching of interlock po int
pairs with existing neighboring mappings selects the corre ct
mapping in case of multiple simultaneously fulﬁlled mappin g
candidates (Fig. 7 3b).
For each completed mapping speciﬁcation and su ﬃcient
disambiguation data, the Mapping Template Matcher dis-
patches collaboration change events for each mapped hADL
element (Fig. 7 4a). When adding new elements, a runtime
mapping instance stores references to all involved xADL
and hADL instances. 1-to-Mmappings typically accumulate
multiple hADL reference sets, respectively N-to-1multiple
xADL reference sets, and N-to-Mmultiples of both. The
Mapping Template Matcher also records interlock point pair
instances to track neighboring mapping instances (Fig. 7 4b ).
Ultimately, the Human Architecture Manager processes the
collaboration change events to maintain a consistent view o f
the collaboration topology.
VI. UtilizinghADLforSystemSelf-Adaptation
Correlating software architecture and human architecture
oﬀers immense opportunities for sophisticated system sensin g,
monitoring, analysis, and adaptation (Fig. 8). A system arc hi-
tect utilizes insight into the underlying collaboration pa ttern
at design-time for selecting the appropriate adaptation ev ents,
metrics, triggers, and strategies. Later at runtime, the hu man
architecture serves as the data source for exactly those eve nts,
metrics, and triggers. Human to software mapping instances
subsequently identify the exact software elements requiri ng
reconﬁguration.
In this section, we discuss the exemplary application of the
runtime human architecture model and its mapping to softwar e
architecture elements for system self-adaptation. In line with
the motivating scenario, we focus on two exemplary non-
functional system requirements and the respective high-le vel
Fig. 8. Collaboration-aware system adaptation process.
adaptation approach:
1) Quality: video streams should be available in high resolu-
tion:⇒limiting the maximum bandwidth usage per Stream-
ingServer component and host.
2) Resilience: system failures should have limited impact on
the team’s monitoring ability (especially the team leader) :
⇒replicating StreamingServer components and strategicall y
routing streams to avoid single points of failure.
Such adaptation goals require introducing domain-speciﬁc
data sources. We include xADL hosts that group collocated
components and connectors. They also keep track of availabl e
bandwidth capacity and consumption. Capturing and process -
ing such additional data remains completely independent of
the xADL-to-hADL mapping process.
Sensing
Both architecture views may become carriers of sensor data
suchasbandwidth constraints.Tothisend, weextended xADL
and hADL with capabilities to store arbitrary system proper -
ties. We thus gain the ability to associate sensor data with
a particular xADL element, hADL element, or combination
thereof.59Video stream bandwidth is an excellent example for a
collaboration level property that is relevant for software
level adaptation. The software architecture by itself o ﬀers no
straightforward means for specifying which components, co n-
nectors, and links carry a particular video stream. Capturi ng
bandwidth for individual StreamingServer components pro-
vides little assistance in determining how to rewire publis hers
and subscribers to remain within given bandwidth threshold s.
Tracking bandwidth usage for individual hADL PubStreams or
Substreams, on the other hand, provides promptly the number
of consumers, the role of consumers, and via runtime mapping
instance data, also the software elements’ bandwidth usage .
Tracking a host’s bandwidth capacity and utilization
complements human architecture-centric bandwidth change s.
Hence, changes in (i) video stream bandwidth usage, (ii) a
stream’s subscription base, and (iii) available host bandw idth
may serve as triggers for system adaptation.
Monitoring
Software system monitoring oversees structural and proper ty
changes in the software architecture and human architectur e.
Monitoring can thus enable reassessment of a component’s
bandwidth usage upon the stream’s bandwidth ﬂuctuations as
well as changes in the stream’s subscriber base.
A system architect applies the mapping speciﬁcation when
creating the monitoring logic to reason how to accurately
derive a component’s properties. In the case of the Stream-
ingServer’s bandwidth usage, the architect aggregates the
bandwidth properties of all associated PubStreams and Sub-
Streams multiplied by their subscriber base. Ultimately, m on-
itoring output consists of high-level events and facts such as
component bandwidth usage.
Analysis
Software system analysis determines the impact of high-lev el
events such as components exceeding a given bandwidth
threshold. Similar to monitoring, system analysis accesse s
hADL and xADL structures for determining high-level system
metrics used later in the planning phase for deciding what
adaptation strategies are most suitable. The analysis step
ultimately decides whether adaptation is necessary or not.
When a component exceeds its granted bandwidth quota,
system analysis collects system properties such as the rema in-
ingbandwidthacrossallhosts.Collaboration-awarealgor ithms
may additionally consider whether the a ﬀected component
serves streams mainly to the Team leader in a publish /sub-
scribe structure. For the pipes /ﬁlter case, an algorithm may
determine whether the component becomes a single point of
failure when serving streams at the same hop distance from
the video source.
For our scenario, system analysis will trigger an adaptatio n
request for a StreamingServer component, supplying inform a-
tion on hosts with su ﬃcient bandwidth capacity, and — de-
pending on the underlying collaboration pattern — determin es
the component’s tendency towards team leader subscription s
or single-point-of-failure, respectively.e.
Planning
The goal of keeping a component’s or host’s bandwidth usagebelow a particular threshold applies tothe softwarelevel a nd is
therefore independent of the underlying collaboration pat tern.
To this end, the system supports the following ﬁne-grained
adaptation actions plans:
1) Replicate the stream at another component and move a
(subset of) subscription(s).
2) Move a stream including all subscriptions to another
component.
3) Move a subscription to another component already serv-
ing the particular stream.
4) Drop a subscription.
The former two plans require a host with su ﬃcient remaining
bandwidth ( hostsAvail ), whereas the latter two plans apply
when the available bandwidth across all available hosts is
exhausted ( hostsFull).
Given the system analysis’ output, planning determines the
best adaptation strategy. The particular underlying colla bora-
tion pattern constrains how to best perform system reconﬁg-
uration while achieving resilience. The runtime collabora tion
topology determines the applicable set of hosts, component s,
streams, and subscriptions as input to the adaptation strat egies.
Due to page constraints we need to limit our discussion
of suitable collaboration-aware adaptation strategies to the
publish/subscribe pattern.
1) When hostsAvail , try separating StreamingService com-
ponents dedicated to the team leader from regular user
components, i.e., a combination of relocating team
leader subscriptions to a streaming component serving
primarily team leaders and likewise relocating regular
subscriptions to components serving regular users.
2) When hostsFull, try relocating any team leader sub-
scriptions to an existing stream at another component,
otherwise rank streams by their number of subscriptions,
and recommend regular subscribers of the most popular
streams (i.e., the actual users) to drop their subscription .
Thelaststrategyhighlightsthepotentialuseofcollabora tion
topologies to include the relevant users in the adaptation o f
the system when automatic reconﬁgurations no longer su ﬃce.
Again the user selection is collaboration pattern speciﬁc:
users pull video stream according to a set of properties such
as location, quality, or relevance in the publish /subscribe
pattern. Hence, recommendations target primarily the stre am
subscribers to reduce their selection. On the other hand,
the pipes/ﬁlter pattern has users push video streams to the
next consumer. Here recommendations address the stream
publishers to be more selective what to forward.
Execution
Enforcing adaptation plans is domain and infrastructure de -
pendent. Research in the domain of autonomic computing and
adaptive systems has focused on the execution of software
changesformorethanadecade(e.g.,[6]forarchitecture-b ased
reconﬁguration). On the other hand, autonomous mechanisms
and techniques for achieving desired reconﬁgurations on th e
collaboration level are limited to a few niche domains (e.g. ,
automatic task management in Amazon Mechanical Turk).60It will require extensive research for evaluating reliabil ity,
timeliness, quality, user acceptance, and associated priv acy
concerns of such adaptation plans. We thus believe that the
aspect of actively adapting the human collaboration struct ure
(through autonomic actions, recommendations, or combina-
tions thereof) cannot be su ﬃciently addressed in the scope
of this paper. Nevertheless, we provide a case study in the
next section demonstrating the e ﬀectiveness approach limited
to software system adaptation.
VII. CaseStudy
In this section we evaluate the added beneﬁt of integrat-
ing detailed human architecture knowledge in the adaptatio n
process for a particular scenario. Speciﬁcally we are inter -
ested in the achievable reliability improvement when apply ing
adaptation strategies tailored to the underlying collabor ation
topologycomparedtocollaboration-unaware adaptation.I nthe
following, we focus on the publish-subscribe style collabo ra-
tion topology of the motivating example detailed in Figure 2 .
The scenario setup consists of 20 remote high deﬁnition
video streams at 20 Mbit /s that are randomly connected to
nine StreamingServer components; three components per hos t,
three hosts in total (see Fig. 9 for an schematic overview
of the software architecture). Agents subsequently subscr ibe
at StreamingService components to receive the desired vide o
streams. The number of subscriptions a ﬀects a component’s
reliability, respectively failure probability. For sake o f sim-
plicity we assume a StreamingServer’s failure rate pfailto be
0.05 for no subscriptions, linearly increasing to 0 .10 when
reaching the bandwidth threshold of 150 Mbit /s. Exceeding
this threshold triggers adaptation in the form of moving
subscriptions (including source streams) among component s
or spawning new components as long as a host’s load remains
within a 400 Mbit/s bandwidth limit.
Vid1
SSvr1 SSvr3 SSvr4 SSvr8 SSvr SSvrVid2 Vid3 Vid18 Vid19
... ... ...... Vid20
Agent
2Agent
3Agent
4Agent
5Agent
6Agent
13 Hosts, each  
400Mbit/s max20 Video 
sources, each 
stream 20Mbit/s
6 Agents + 
1 Leader, each
4 subscriptions 
(=total 80Mbit/s)LeaderStreamingServer 
component
(dynamic deployed )
Fig. 9. Schematic case study conﬁguration (omitting connecto rs, interfaces,
and most links). Dotted lines depict streams to the team leader .
Starting with no subscribers, we gradually increase the
number of subscribing agents to six. Each new agent randomly
selects two components and chooses two streams each (4
streams total). In-between the regular agent subscription s, a
singleteamleaderconnectstoasinglestreamfromarandoml y
selected component for ultimately a total of 4 streams. We
assume that suﬃcient network bandwidth is available.
The adaptation manager observes the component load while
the number of subscriptions increases. The collaboration-aware adaptation strategy focuses on moving leader subscri p-
tions to reduce component load as outlined in the previous
section. The baseline collaboration-unaware strategy sel ects
subscriptions randomly.
We measure a strategy’s impact by determining the average
reliability of leader associated streams (dotted lines in F ig. 9).
The individual stream reliability rel(s) is determined by the
number of stream replicas and the component failure proba-
bility of the respective StreamingServer pfail(comp).
rel(s)=1−n/productdisplay
i=1pfail(comp(si))where n=replica(s) (1)
Figure 10 compares the achieved average stream reliability
for both adaptation strategies as bandwidth usage increase s.
The chart displays the reliability before and after adaptat ion
for each of the 12 performed reconﬁgurations (averaging dat a
from multiple experiment runs). The initial spike results f rom
the replication of the ﬁrst leader subscription. Both adapt ation
strategies cannot avoid degradation of reliability as the b and-
width load on components and hosts increases. Collaboratio n-
aware adaptation, however, achieves consistently higher r e-
liability through prioritizing leader subscriptions, ave raging
0.972 compared to unaware adaptation at 0 .952.
Fig. 10. Average Stream reliability for collaboration-(un )aware adaptation
for increasing bandwidth usage.
The adaptation strategies in this case study have been
kept simple on purpose, rewiring only the minimum number
of subscriptions to bring the bandwidth usage below the
threshold. As the results demonstrate, consideration of th e
human architecture provides signiﬁcant improvements alre ady
for such a simple adaptation approach. We expect algorithms
performing even better when taking advantage of the full
extent of the collaboration topology.
VIII. Conclusions
We presented our approach for linking software architectur e
and collaboration topology for enabling more sophisticate d61system adaptation. System adaptation remains unaware of
collaboration interdependencies without such mapping inf or-
mation. To this end, we provided a software architecture to
human architecture mapping speciﬁcation at design-time an d
a framework for reﬂecting software architecture events in t he
human architecture at runtime. We further make the case
for integrating the collaboration topology at all stages of the
MAPE-K adaptation cycle. Our case study demonstrates the
beneﬁt of our approach.
Next steps will focus on supporting the mapping process
in detecting inconsistencies and incomplete coverage as th e
prerequisite to providing adaptation guarantees. While our cur-
rent work focused primarily on adapting the software system ,
future research will address the challenge of adapting also
the human architecture. We will investigate how autonomic
adaptation actions and recommendations can be combined
for achieving desirable system conﬁgurations. Simultaneo usly,
we propose applying the MAPE-K process on the human
architecture for addressing undesirable human collaborat ion
situations. A collaboration-centric adaptation mechanis m may
observe, for example, how many users access the wall screen
and recommend a suitable access coordination mechanism.
Acknowledgment
This work is supported in part by the Austrian Science Fund
(FWF) under Grant No. J3068-N23 and the National Science
Foundation under Grant No. 0917129.
References
[1] L. Northrop, P. Feiler, R. P. Gabriel, J. Goodenough, R. L inger,
T. Longstaﬀ, R. Kazman, M. Klein, D. Schmidt, K. Sullivan, and
K. Wallnau, “Ultra-Large-Scale Systems - The Software Chall enge of
the Future,” Software Engineering Institute, Carnegie Mel lon, Tech.
Rep., June 2006.
[2] J. Kramer and J. Magee, “Self-managed systems: an architect ural
challenge,” in International Conference on Software Engineering , 2007,
pp. 259–268.
[3] P. Oreizy, M. M. Gorlick, R. N. Taylor, D. Heimbigner, G. Jo hnson,
N. Medvidovic, A. Quilici, D. S. Rosenblum, and A. L. Wolf, “An
architecture-based approach to self-adaptive software,” IEEE Intelligent
Systems, vol. 14, pp. 54–62, May 1999.
[4] B. Cheng, R. de Lemos, H. Giese, P. Inverardi, J. Magee et al.,
“Software engineering for self-adaptive systems: A researc h roadmap,”
inSoftware Engineering for Self-Adaptive Systems , ser. Lecture Notes
in Computer Science, B. Cheng, R. de Lemos, H. Giese, P. Inverar di,
and J. Magee, Eds. Springer, 2009, vol. 5525, pp. 1–26
[5] J. Floch, S. Hallsteinsen, E. Stav, F. Eliassen, K. Lund, and E. Gjorven,
“Using architecture models for runtime adaptability,” Software, IEEE ,
vol. 23, no. 2, pp. 62 – 70, march-april 2006.
[6] J. C. Georgas and R. N. Taylor, “Policy-based architectu ral adaptation
management: Robotics domain case studies,” in Software Engineering
for Self-Adaptive Systems , B. H. Cheng, R. Lemos, H. Giese,
P. Inverardi, and J. Magee, Eds. Springer, 2009, pp. 89–108.
[7] D. A. Menasce, J. a. P. Sousa, S. Malek, and H. Gomaa,
“Qos architectural patterns for self-architecting softwa re systems,”
inProceedings of the 7th international conference on Autonom ic
computing , ser. ICAC ’10. New York, NY, USA: ACM, 2010, pp.
195–204.
[8] C. Dorn and R. N. Taylor, “Architecture-driven modeling o f adaptive
collaboration structures in large-scale social web applic ations,” in Int.
Conf. on Web Information Systems Engineering (WISE) , Nov. 2012.
[9] E. M. Dashofy, A. v. d. Hoek, and R. N. Taylor, “A comprehens ive
approach for the development of modular software architectur e
description languages,” ACM Trans. Softw. Eng. Methodol. , vol. 14, pp.
199–245, April 2005.[10] D. Garlan, S.-W. Cheng, A.-C. Huang, B. Schmerl, and P. St eenkiste,
“Rainbow: architecture-based self-adaptation with reusa ble infrastruc-
ture,”Computer , vol. 37, no. 10, pp. 46 – 54, oct. 2004.
[11] J.DowlingandV.Cahill,“Thek-componentarchitecture meta-modelfor
self-adaptive software,” in REFLECTION ’01: Proceedings of the Third
International Conference on Metalevel Architectures and S eparation of
CrosscuttingConcerns . London,UK:Springer-Verlag,2001,pp.81–88.
[12] J.ZhangandB.H.C.Cheng,“Model-baseddevelopmentofd ynamically
adaptive software,” in ICSE ’06: Proceedings of the 28th international
conference onSoftware engineering . New York, NY, USA: ACM, 2006,
pp. 371–380.
[13] W. Cazzola, A. Ghoneim, and G. Saake, “Software evolutio n through
dynamic adaptation of its oo design,” in Objects, Agents and Features:
Structuring Mechanisms for Contemporary Software, Lectur e Notes in
Computer Science . Springer-Verlag, 2004, pp. 69–84.
[14] D. Sykes, W. Heaven, J. Magee, and J. Kramer, “From goals t o
components: a combined approach to self-management,” in Proceedings
ofthe2008internationalworkshoponSoftwareengineering foradaptive
and self-managing systems , ser. SEAMS ’08. New York, NY, USA:
ACM, 2008, pp. 1–8.
[15] G. Edwards and N. Medvidovic, “A methodology and framewor k for
creating domain-speciﬁc development infrastructures,” in Automated
Software Engineering, International Conference on . Los Alamitos,
CA, USA: IEEE Computer Society, September 2008, pp. 168–177.
[16] D. Di Ruscio, I. Malavolta, H. Muccini, P. Pelliccione, and
A. Pierantonio, “Developing next generation adls through md e
techniques,” in Proceedings of the 32nd ACM /IEEE International
Conference on Software Engineering - Volume 1 , ser. ICSE ’10. New
York, NY, USA: ACM, 2010, pp. 85–94.
[17] N. Esfahani, S. Malek, J. a. P. Sousa, H. Gomaa, and D. A.
Menasc´e, “A modeling language for activity-oriented composition of
service-oriented software systems,” in Int. Conf. on Model Driven
Engineering Languages and Systems , MODELS ’09. Springer, 2009,
pp. 591–605.
[18] A. Bhave, D. Garlan, B. Krogh, A. Rajhans, and B. Schmerl, “Augment-
ing software architectures with physical components,” in Proceedings
of the Embedded Real Time Software and Systems Conference (E RTS2
2010), 2010.
[19] P. Wohed, W. van der Aalst, M. Dumas, A. ter Hofstede, and N . Russell,
“On the suitability of bpmn for business process modelling,” i nBusiness
Process Management , Lecture Notes in Computer Science, Springer,
2006, vol. 4102, pp. 161–176.
[20] M. Ford, A. Endpoints, and C. Keller, “Ws-bpel extension for people
(bpel4people), version 1.0,” 2007.
[21] C. Dorn and R. N. Taylor, “Analyzing runtime adaptabilit y of collabora-
tion patterns,” in International Conference on Collaboration Technolo-
gies and Systems (CTS) . CO, USA: IEEE Computer Society, 2012.
[22] D. Schall, H.-L. Truong, and S. Dustdar, “Unifying human and software
services in web-scale collaborations,” IEEE Internet Computing , vol. 12,
no. 3, pp. 62–68, 2008.
[23] M. Conway, “How do committees invent,” Datamation , vol. 14, no. 4,
pp. 28–31, 1968.
[24] M. Cataldo, P. A. Wagstrom, J. D. Herbsleb, and K. M. Carle y,
“Identiﬁcation of coordination requirements: implications for the design
of collaboration and awareness tools,” in Proceedings of the 2006 20th
anniversary conference on Computer supported cooperative work, ser.
CSCW ’06. New York, NY, USA: ACM, 2006, pp. 353–362.
[25] C. Dorn and R. N. Taylor, “Co-adapting human collaborati ons and soft-
ware architectures,” in Proceedings of the 34th international conference
on Software engineering (ICSE) , 2012, pp. 1277–1280.
[26] T. W. Malone and K. Crowston, “The interdisciplinary st udy of
coordination,” ACM Comput. Surv. , vol. 26, pp. 87–119, March 1994.
[27] D. Garlan, R. Monroe, and D. Wile, “Acme: an architecture description
interchange language,” in Proceedings of the 1997 conference of the
Centre for Advanced Studies on Collaborative research , ser. CASCON
’97. IBM Press, 1997, pp. 7–.
[28] P. Oreizy, N. Medvidovic, and R. N. Taylor, “Architectu re-based
runtime software evolution,” in International Conference on Software
engineering , ICSE ’98. Washington, DC, USA: IEEE, 1998, pp.
177–186.62