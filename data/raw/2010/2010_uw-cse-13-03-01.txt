University of Washington Technical Report UW-CSE-13-03-01
Unifying FSM-Inference Algorithms through
Declarative Speciﬁcation
Ivan Beschastnikh
 , Yuriy Brun
 , Jenny Abrahamson
 , Michael D. Ernst
 , and Arvind Krishnamurthy
Computer Science and Engineering
 School of Computer Science
University of Washington University of Massachusetts
Seattle, WA, USA Amherst, MA, USA
fivan,jabrah,mernst,arvind g@cs.washington.edu brun@cs.umass.edu
Abstract —Logging system behavior is a staple development
practice. Numerous powerful model inference algorithms have
been proposed to aid developers in log analysis and system under-
standing. Unfortunately, existing algorithms are difﬁcult to under-
stand, extend, and compare. This paper presents InvariMint, an
approach to specify model inference algorithms declaratively. We
apply InvariMint to two model inference algorithms and present
evaluation results to illustrate that InvariMint (1) leads to new fun-
damental insights and better understanding of existing algorithms,
(2) simpliﬁes creation of new algorithms, including hybrids that ex-
tend existing algorithms, and (3) makes it easy to compare and
contrast previously published algorithms. Finally, InvariMint’s
declarative approach can outperform equivalent procedural algo-
rithms.
I. I NTRODUCTION
Understanding a system’s behavior is a difﬁcult development
task that is required when a system behaves in an unexpected
manner or when a developer must make changes to code they did
not write. Logging and log analysis of captured system behavior
is one of the most ubiquitous, simple, and effective tools for
system understanding. Unfortunately, the size and complexity
of logs often exceed a developer’s ability to navigate and make
sense of the captured data. For example, production systems
at Google log billions of events each day; these are stored for
weeks to help diagnose errant future behavior [29].
Model inference is one promising approach to help users
make sense of large and complex executions. The goal of model-
inference algorithms is to produce a model, typically a ﬁnite state
machine, that accurately and concisely represents the system that
produced the log. Numerous such algorithms and corresponding
tools already exist to help debug, verify, and validate systems [ 1],
[6], [14], [15], [18], [19], [21], [22], [23], [26], [30].
Unfortunately, it is challenging to apply and build on top
of this rich body of work. This is because model-inference
algorithms are primarily expressed procedurally — as algorithms
that iteratively modify a representation of the log (e.g., a graph)
to infer and output a model that can be shown to a user. The
procedural speciﬁcation of these algorithms makes them difﬁcult
to understand, extend, and compare:
1. Understand. For most algorithms, it is difﬁcult to under-
stand which temporal and structural properties of the log are
preserved in the inferred model. For example, if an inferred
Property minerPropertycompositionPropertyinstancesCompositionfunctionLogPropertytypesInvariMint algorithmAlgorithmspeciﬁcationModelFig. 1. An overview of the InvariMint approach. An InvariMint algorithm is
parameterized by an algorithm speciﬁcation, which consists of a set of property
types and a composition function. The resulting InvariMint algorithm is a model-
inference algorithm — it takes a log of traces as input and outputs an inferred
model which describes the process that generated the input log. Internally, the
algorithm uses property types to mine property instances, and then applies the
composition function to the property instances to derive the model.
model of an email client requires each login event to be imme-
diately followed by a check mail event, a developer may wish
to know whether that property is true for all traces in the log, or
is an artifact of the model-inference algorithm.
2. Extend. It is difﬁcult to modify or to compose existing
model-inference algorithms to create interesting hybrids. For
example, a developer may use two inference algorithms: one to
model exceptional executions and another that identiﬁes execu-
tions with sequences of library calls not observed during testing.
The developer may want to compose these two algorithms to
generate a single model, but combining the existing algorithms
may require a complete algorithm redesign. Further, it is difﬁcult
or impossible to exclude a speciﬁc instance of a log property
from a speciﬁc invocation of the algorithm. If a log has every
login event followed by a check mail event and if the devel-
oper decides that this property is an artifact of an incomplete log,
the developer may want the model-inference algorithm to not
preserve this property. However, because a procedural algorithm
deﬁnition does not explicitly specify properties, such exclusions
may be difﬁcult.
3. Compare. Previously published algorithms lack a
common form to aid comparison and juxtaposition. Instead, re-
searchers must reason about pseudocode and work out complex
proofs. A declarative approach, in which a model-inference
algorithm is speciﬁed in terms of log properties that the inferred
model will satisfy, allows researchers to, for example, identify
1University of Washington Technical Report UW-CSE-13-03-01
when two algorithms with vastly different procedural deﬁnitions
produce models with identical, or overlapping, sets of properties.
This paper proposes InvariMint, a technique to specify model-
inference algorithms declaratively . InvariMint has two key fea-
tures: (1) it explicitly speciﬁes the types of properties that will be
enforced in the ﬁnal model, and (2) it decouples the mechanism
of property mining from property speciﬁcation . We illustrate
the advantages of InvariMint by specifying three procedural al-
gorithms declaratively. We ﬁnd that InvariMint alleviates the
above problems:
1. Understand. InvariMint expresses an algorithm in terms
of the properties that the inferred model must satisfy. With
this formulation, algorithms become more clear, concise, and
comprehensible. Further, this formulation makes evident cer-
tain complexities that may otherwise be hidden, such as non-
determinism.
2. Extend. With InvariMint, it is easy to add, remove, and
modify both (1) the instances of properties in a speciﬁc infer-
ence execution (e.g., each login event must be followed by a
check mail event), and (2) the types of properties the algo-
rithm preserves (e.g., an event may only follow another event
if it did so in the log). New algorithms can be created, and
multiple algorithms can be trivially composed to create hybrid
approaches. For example, the Synoptic [ 5] algorithm uses the
kTails algorithm as a ﬁnal (coarsening) step to derive a more
compact ﬁnal model. Synoptic’s InvariMint speciﬁcation ex-
presses this by simply merging the kTails property types into the
Synoptic speciﬁcation.
3. Compare. InvariMint makes it easier for those using
and developing model-inference algorithms to compare and
improve on those algorithms. For example, algorithms with
incomparable procedural deﬁnitions may enforce overlapping
sets of properties on their inferred models. InvariMint makes
this overlap evident.
A model-inference algorithm outputs a model that accepts a
formal language. The model’s language is smaller than S: it
is limited by certain temporal or structural properties that the
algorithm mined from the log. Some of these properties may
be explicit in the algorithm deﬁnition, whereas others may be
implicit and deeply hidden in the procedural deﬁnitions.
InvariMint (Figure 1) represents a model-inference algorithm
with the types of properties that are expected to be true of the
inferred model. InvariMint mines instances of these properties
from the log, represents each property as a DFA, and composes
the DFAs using standard DFA operations (such as DFA union
and intersection). Well-understood work on formal languages
allows InvariMint to perform these operations efﬁciently and to
produce minimal models [16].
To evaluate InvariMint, we applied it to two previously-
published algorithms. First, we used InvariMint to declaratively
and exactly specify the well-known kTails [ 6] algorithm. From
our past experiences with kTails, we know that this algorithm be-
haves non-trivially on large log inputs. For instance, it is neither
apparent which states will be merged, nor what synthetic tracesthe ﬁnal kTails-inferred model will accept. The InvariMint for-
mulation decomposes a kTails execution into a set of properties
that are easy to inspect to better understand the characteristics
of the ﬁnal kTails-inferred model. The InvariMint kTails spec-
iﬁcation also provides the user with more ﬁne-grained control
over the execution of the algorithm — the user may remove
a particular merge (by modifying a property instance) without
having to modify the algorithm implementation.
Second, we used InvariMint to approximate Synoptic [ 5].
Synoptic is a more recent algorithm constructed with explicit
log properties in mind. Although Synoptic attempts to make
certain properties explicit, we found that it in fact preserves a set
of implicit, or hidden, properties in its procedural declaration.
Speciﬁcally, Synoptic allows a log event type to be immediately
followed by another type only if such following occurred in the
observed log. For example, Synoptic forbids a login event from
being immediately followed by a compose mail event if, in the
log,login wasalways immediately followed by a check mail .
Synoptic’s procedural declaration does not allow this property to
be removed, altered, or relaxed, and hides this property from the
user. In contrast, an InvariMint formulation of Synoptic makes
this property explicit and allows a user to remove all properties
of this type or to select individual instances of this property for
speciﬁc log event types to enforce. More importantly, InvariMint
makes the algorithm’s user and developer explicitly aware of the
properties it enforces.
Finally, Synoptic is a non-deterministic algorithm. Depend-
ing on the order with which Synoptic satisﬁes the mined log
properties, the algorithm might produce a different ﬁnal model.
Although our InvariMint Synoptic formulation is an approxi-
mation of Synoptic, its advantage is that it is deterministic and
highly predictable. In particular, it is easier to check whether
two different logs produce identical models.
As an added beneﬁt, the InvariMint versions of kTails and
Synoptic with efﬁcient property mining scale linearly with log
size and greatly outperform their procedural counterparts.
The rest of this paper is structured as follows: Section II uses
an example model-inference algorithm to explain the InvariMint
approach. Sections III and IV present InvariMint speciﬁcations
of kTails and Synoptic, respectively. Section V discusses impli-
cations of our work. Section VI covers related prior research,
and Section VII concludes.
II. T HEINVARI MINT APPROACH
This section describes a model-inference algorithm named
SimpleAlg and then overviews the InvariMint approach by out-
lining the InvariMint steps in specifying an example algorithm,
called SimpleAlg. Sections III and IV extend SimpleAlg’s spec-
iﬁcation to derive the kTails and Synoptic algorithms.
A. SimpleAlg
A model-inference algorithm’s input is a log— a set of traces
of a system’s execution. Each trace is an ordered sequence of
events (elements of a ﬁnite alphabet) that occur during execution.
SimpleAlg’s output is a model — a ﬁnite state machine whose
language is a set of traces. (Figure 2 shows example input and
2University of Washington Technical Report UW-CSE-13-03-01
logincheckcomposesendlogout(b) Output models1logins2s3s4checkchecklogouts6composesendlogincheckchecklogout(a) Input logtrace 2:trace 1:s5logout
Fig. 2. (a)An example log of an email client with two traces. (b)The model
inferred with SimpleAlg (Figure 3) for the input log in (a).
output.) The language corresponding to the model accepts all
the traces in the log, as well as other traces. A model-inference
algorithm’s goal is to infer a model that accurately describes and
generalizes the log: the extra accepted traces should be ones that
are likely to be generated by the system that produced the log.
SimpleAlg is a model-inference algorithm. It generalizes in
the following way: if SimpleAlg ever observes an event e1to be
immediately followed by an event e2in the log, then whenever
the system being modeled produces or consumes an e1event,
SimpleAlg assumes that it is legal for the system to then produce
or consume an e2event.
Pseudocode for SimpleAlg appears in Figure 3. In the gener-
ated model, each state represents an event that has just occurred.
1 Input: Log L
2 let M= new FSM model
3
4 // Create states
5M.addState (init)
6 foreach (Trace tinL):
7 foreach (Event eint):
8 let y= Event type of e
9 if (:M.hasState (sy)) :M.addState (sy)
10
11 // Add transitions among the states.
12 foreach (Trace tinL):
13 // Add transition from init state to ﬁrst event.
14 let f= Event type of ﬁrst event in t
15 M.addTransition (src= init, dst= sf, label= f)
16
17 // For each pair of adjacent events, add a transition
18 // between states of corresponding event types.
19 foreach (Event eint):
20 if ( e.hasNext()):
21 let y= Event type of e
22 let z= Event type of e.next()
23 if (:M.hasTransition (sy,sz)):
24 M.addTransition (src= sy, dst= sz, label= z)
25
26 Output: M
Fig. 3. Procedural pseudocode of the SimpleAlg algorithm.The model contains one state for each unique event type that
occurs in the log, plus one “initial” state. The model contains a
transition from the state for event type e1to the state for event
type e2, with the label e2, iff there exists a trace in the log in
which an e2event immediately follows an e1event.
Figure 2(a) lists an email client log with two traces. The
event alphabet isflogin ,check mail (shortened to check ),
compose ,send ,logoutg. Figure 2(b) shows the model Sim-
pleAlg infers for this input log. The model has six states, one
for each event type (e.g., s4 corresponds to compose ) plus the
initial state (s1).
SimpleAlg’s models are compact — the number of states
is one more than the number of unique event types in the log,
which is independent of the total number of events in the log.
The running time is asymptotically linear in the size of the log.
The inferred model’s language always contains every trace in
the input log, plus other traces SimpleAlg deemed likely.
B. InvariMint overview
InvariMint is an approach — or a common language — for
describing model-inference algorithms, such as SimpleAlg. Fig-
ure 1 overviews the InvariMint approach. Like other model-
inference algorithms, an InvariMint algorithm takes as input a
logof traces to be modeled, and outputs a model . The common
language InvariMint uses to specify an algorithm is: a set of
property types that describe properties to be mined from the
log to derive property instances ; and a composition function
that combines the mined property instances into a ﬁnal model.
Different model-inference algorithms take different ap-
proaches to generalizing the traces in the log to infer traces
likely traces that are not in the log. What constitutes reasonable
generalization is often subjective and depends on features of the
system, its environment, and the speciﬁc development task that
the model will be used for. While typical model-inference algo-
rithms hard-code these features as assumptions in their procedu-
ral deﬁnitions, InvariMint uses property types and the composi-
Eval(LogL,hx=a, Y=Bi)=8<:true :8t2L,9b2B,⌃(a! b)i nt^8b2B,9t2L,⌃(a! b)i ntfalse : otherwise(a) Property type  (PFSM and Eval)Compose(Pro p1,...,Pr o pn)=Minimize(\Pro pi)(b) Composition functions1s2Yxs3Y⌃\⌃{x}⌃\
Fig. 4. An InvariMint speciﬁcation of SimpleAlg. This is equivalent to the
pseudocode in Figure 3. (a)The property type “event xcan be immediately
followed by an event from set Y”, represented as a parameterized FSM (PFSM)
and a corresponding evaluation function ( Eval). Given an input log, Eval deter-
mines the validity of bindings of parameters in the PFSM to event types. (b)The
composition function, which InvariMint uses to compose a model from mined
property instances.
3University of Washington Technical Report UW-CSE-13-03-01
...s1s2checklogins3s1s2check,logout,composechecks3send,loginsend,login,logout,composesend,check,logout,composesend,login,logout,composePro p1Pro p2sendlogin,check,logout,composesend,login,check,logout,compose
Fig. 5. Property instances mined by InvariMint from the log in Figure 2(a),
based on property types in Figure 4(a). Prop1represents “event login can be
immediately followed by an event from set fcheckg”.Prop2represents “event
check can be immediately followed by an event from set fcheck ,logout ,
composeg”.
tion function to generalize the model-inference process. Property
types deﬁne desirable properties of the ﬁnal model. For exam-
ple, the SimpleAlg-inferred model preserves log properties, such
as “event xcan be immediately followed by an event from set
Y”. A property type consists of a parameterized FSM (PFSM)
— an FSM with variable-labeled transitions (e.g., top portion
of Figure 4(a)) — and an evaluation function to decide which
bindings of PFSM variables to event types are valid in the log
(e.g., bottom portion of Figure 4(a)). Together, the PFSM and
evaluation function encode relationships between event types.
Using these evaluation functions, InvariMint mines the log for
property instances , which are instantiations of the corresponding
PFSM. InvariMint then combines the derived property instances
into a model using the composition function (e.g., Figure 4(b)).
TheMinimize procedure referenced in this composition is the
FSM minimization algorithm [ 16], which guarantees that the
ﬁnal model will be minimal.
We now illustrate InvariMint on the SimpleAlg example.
C. Specifying SimpleAlg with InvariMint
InvariMint’s formulation of SimpleAlg has only a single prop-
erty type: “event xcan be immediately followed by an event
from set Y”. Figure 4 shows the InvariMint speciﬁcation of
SimpleAlg. Figure 4(a) shows the property type (a PFSM and an
evaluation function). The PFSM is an FSM with variable labels
that accepts all traces that relate event xand a set of events Y.
The evaluation function deﬁnes which bindings of variables to
log events result in valid property type instances. We use LTL to
compactly specify evaluation functions. LTL statements use the
operators always (),eventually (),until (U), and next ().
For example, the evaluation function in Figure 4(a) returns true
for event aand events set Bwhenever acan be immediately
followed by only events from Bacross all traces in the log —
that is, there is a trace for every b2Band there is a b2Bfor
every trace such that eventually ( ), if we observe an aevent,
then we will observe a bas the next () event.
By indicating how to evaluate a binding of xandYto event
types, the evaluation function speciﬁes how xandYmust relate:
an event of type xmust be immediately followed by one event
from the set Y.
While all bindings can create property instances, the evalua-
tion function determines which instances are valid for a given
log. Figure 5 lists two of the property instances that are valid1 Input: Log L,
Property typeshPFSM 1;Eval 1i;:::;hPFSM n;Eval ni
2 let Props =fg
3 foreach (Property type hPFSM i;Eval ii)
4 foreach (Binding of variables in PFSM i;B)
5 if ( Eval i(L,B)):
6 Props =Props[fPFSM i(B)g
7 Output: Props
Fig. 6. The generic property miner algorithm.
1 Input: Property instances Prop1;:::; Propn,
Composition function C
2 let Model =C(Prop1;:::; Propn)
3 Output: Model
Fig. 7. The generic property composition algorithm.
for the log in Figure 2(a): hx;Yi=fhlogin ;fcheckgi, and
hx;Yi=hcheck ;fcheck ;logout ;composegi. In addition to
these two property instances, there are three others (one for
each of compose ,send , and logout ). Note thathlogout ,/0iis
necessary to prevent allowing all events to follow logout in the
inferred model.
Finally, InvariMint composes property instances using the
composition function in Figure 4(b) to produce the ﬁnal model.
For SimpleAlg, the composition function returns the minimized
version of the intersection of the property instances. Therefore,
the resulting model is compact and includes only those traces
that satisfy all of the mined property instances. This ﬁnal model
is identical to the one produced by SimpleAlg (Figure 2(b)).
This paper mostly focuses on composition functions that involve
only intersections and minimizations, but this limitation is not
inherent to InvariMint. More complex functions may include
unions, set differences, and other set operations. For example,
an algorithm that uses positive and negative trace example may
subtract the model of negative traces from one of positive traces.
D. InvariMint beneﬁts
The InvariMint formulation of SimpleAlg provides three ben-
eﬁts over the SimpleAlg pseudocode: (1)The InvariMint formu-
lation helps us understand the key properties of the ﬁnal model
derived with SimpleAlg by decoupling these properties from
the mining and composition procedures, while the pseudocode
mixes all three. (2)We can more easily add new constraints
to the model by deﬁning new property types, and eliminate
behavior from the model by omitting property instances. For
example, if we do not want login to only be immediately fol-
lowed by check , we can simply omit Prop1in Figure 5. (3)We
can, and will, extend the InvariMint formulation of SimpleAlg
to construct InvariMint speciﬁcations for kTails and Synoptic.
The pseudocode for these algorithms looks completely different
from SimpleAlg’s pseudocode, yet the InvariMint speciﬁcation
reveals that both kTails and Synoptic are based on the same
property type (Figure 4(a)) used by SimpleAlg. The fact that all
4University of Washington Technical Report UW-CSE-13-03-01
1 Input: Log L;intk
2 let M=initial FSM model of traces in L
3
4 let merged =true
5 while ( merged ):
6 merged =false
7 foreach (States s1;s2inM):
8 if ( s1;s2arek-equivalent):
9 M.merge (s1;s2)
10 merged =true
11
12 Output: M
Fig. 8. The kTails algorithm. Section III-A deﬁnes k-equivalence.
three algorithms share this property type is one of the insights
gained from specifying these algorithms with InvariMint.
InvariMint’s goal is not to produce models, per se , but rather
to provide a common language for expressing, or specifying,
model-inference algorithms. Specifying different algorithms
with the same language allows us to understand, combine, and
compare the algorithms. InvariMint’s common language is prop-
erty types and composition functions. Once speciﬁed, the re-
sulting property mining and property composition procedures
(Figure 1) are straightforward. Figures 6 and 7 list the unop-
timized pseudocode for these two procedures. Note that in
practice, both of these algorithms can be further optimized and
tailored to speciﬁc choices of property types and composition
functions.
Next, we describe and evaluate the InvariMint speciﬁcation of
two previously-published model-inference algorithms — kTails
and Synoptic.
III. E XPRESSING K TAILS WITH INVARI MINT
kTails [ 6] is an extremely popular algorithm that has served as
the basis for many modern model-inference algorithms. Unfor-
tunately, there are many procedural descriptions of kTails, and it
is difﬁcult to tell if they produce identical or different models.
This section deﬁnes the kTails algorithm (Section III-A ),
demonstrates its InvariMint declarative speciﬁcation (Sec-
tionIII-B ), discusses the insights about kTails that InvariMint
reveals (Section III-B ), and reports on our empirical compari-
son of the procedural and declarative implementations of kTails
(Section III-C).
A. kTails
kTails is a state-merging algorithm. kTails takes a log and
a parameter k. It represents the log as a DFA composed of linear
sub-DFAs, one per trace, that are joined in a parallel fashion,
with a single initial state transitioning to the start of each trace,
and all traces ﬁnishing by transitioning to a single terminal
state. kTails then iteratively merges states in the DFA that are
“k-equivalent”. Two states are k-equivalent if their kTails are
identical. A state’s kTail is the set of strings, of length kor
(b) kTails(k = 2) property typeEval(LogL,hx=a, y=b, Z=Ci)=8<:true :8t2L,9c2C,⌃(a^ b!   c)i nt^8c2C,9t2L,⌃(a^ b!   c)i ntfalse : otherwise⌃s1s2yZxs4s3{x}⌃\{y}⌃\Z⌃\Eval(LogL,hx=a, Y=Bi)=8<:true :8t2L,9b2B,⌃(a! b)i nt^8b2B,9t2L,⌃(a! b)i ntfalse : otherwise(a) kTails(k = 1) property types1s2Yxs3Y⌃\⌃{x}⌃\Fig. 9. (a)kTails( k=1) property type. (a+b) kTails( k=2) property types. Each of
these is equivalent to the pseudocode in Figure 8 for the speciﬁc value of k.
shorter, that map to valid paths starting from that state. The algo-
rithm terminates and outputs the model when no two remaining
states are k-equivalent. Figure 8 lists the kTails pseudocode.
The intuition behind kTails is that if two execution points
have identical, k-long sequences of observed events following
them, then those points likely represent the same program state.
Therefore, to infer a concise model, kTails merges execution
points that it considers to represent the same program state. The
process stops once all points deemed equivalent are merged. The
parameter kdetermines the size and generality of the inferred
model — a smaller kleads to more merges and produces more
compact (and more general) models, while a greater krestricts
state equivalence.
In InvariMint kTails we introduce a pre- and a post-processing
step. We modify each input trace to include an aandwsymbols
at the start and end of each of the traces, respectively. After the
property instances are composed into a ﬁnal model we update
states in the model with incoming atransition to be initial states,
update states with outgoing wtransition to be accept states, and
also remove all aandwtransitions from the model.
InvariMint uses property types to capture tail-equivalence and
to specify kTails. Figure 9(a) lists the k=1property type for
kTails. For k=2, InvariMint requires two property types — the
property type for k=1in Figure 9(a) and a new property type
shown in Figure 9(b). Note that the property type for k=1kTails
in Figure 9(a) is identical to the “can be immediately followed by”
property type in Figure 4(a). This equality is not a coincidence
— the kparameter generalizes the “can be immediately followed
by” property type to ksteps into the future.
The greater kis, the ﬁner the granularity of the properties
kTails enforces. For example, the property type in Figure 9(b)
says that an event x, followed by an event y, must be followed by
one — any one — of the events in the set Z. In other words, it
corresponds to merging all x;ytails together. Section V discusses
in more detail the granularity of properties and how the wrong
granularity may cause the algorithm to overﬁt to the input log.
An important feature of the InvariMint kTails speciﬁcation is
5University of Washington Technical Report UW-CSE-13-03-01
⌃Z⌃\Z⌃\x0x1xi+1t0t1tixi+2t0...⌃\t1...xgtg 1tg⌃\tg
Eval(LogL,ha0,...,ai,Ci)=8>>>>>>>>>><>>>>>>>>>>:true :8t2L,9c2C,⇤⇥a0^ a1···^( 1··· iai)! 1··· i c⇤int^8c2C,9t2L,⇤⇥a0^ a1···^( 1··· iai)! 1··· i c⇤intfalse : otherwise
Fig. 10. The kTails( k=i) property type.
that it is deterministic. This feature helped us better understand
the kTails algorithm and helped to reveal a bug in our procedural
implementation, which happened to be non-deterministic.
B. Comparing procedural and InvariMint formulations of kTails
The model produced by the kTails algorithm behaves identi-
cally to the model produced by the InvariMint formulation of
kTails. Next, we formally deﬁne the kTails algorithm based on
the formulation in [10], and provide a proof of equivalence.
LetSkdenote the set of all strings of length kor less. Let a
trace be a string over alphabet S[fa;wg, and let a log Lbe a set
of traces, each of which starts with an asymbol and terminates
with the wsymbol. Let PFLbe the set of all preﬁxes of strings
inL. We use ptto denote concatenation of string ttop, and
refer to tas the tail.
For example, consider the log L=
faabcw;aabw;acdwg. Then, the corresponding
PFL=faew;aaw;aabw;aabcw;acw;acdwg. And, the
string aabcw=aabcw, in which bcwis a tail.
Deﬁnition 1 (kTails FSM FkTails).The kTails algorithm takes
a log Land an integer kas inputs and generates a kTails FSM
FkTails. The states ofFkTails correspond to equivalence classes of
preﬁxes from PFL. An equivalence class Eis a set of preﬁxes
such that:
8(p;p0)2E;8t2Sk;(pt)2PFL,(p0t)2PFL
That is, all preﬁxes in a class Ehave the same set of tails of
length kor less, and every preﬁx in PFLis assigned to some
equivalence class.
Thetransition function Dfor equivalence classes, or states,
inFkTails is deﬁned as follows. Given a state Eiand a symbol
a2S,
D(Ei;a) =[
E[pa];8p2Ei
where E[pa]is the equivalence class of pa.
Theinitial state ofFkTails isE[e], and an equivalence class Ei
is an accept state ofFkTails if9s2L, such that s2Ei.
Deﬁnition 2 (InvariMint kTails FSM FInvMint ).For a log Land
an integer k, letFInvMint be the FSM derived using the InvariMint
algorithm speciﬁed by the kTails( k) property types and the inputlogL. We can express FInvMint as a composition of property
instances1:
FInvMint =\
(P1
1;:::; P1
n1;:::; Pk
1;:::; Pk
nk)
where Pi
1;:::; Pj
niare the property instances for the PFSM corre-
sponding to kTails( k=i) property type. Figure 10 shows this
generalized property type.
Deﬁnition 3 (Terminal rejection) .LetFbe an FSM. Ftermi-
nally rejects sif69tsuch that stis accepted by F.
Observation 1. FInvMint does notterminally reject strings in
PFL.
Proof: Consider a string s2PFL. Choose a tail tsuch that
stis a trace in L. Such a tail must exist since sis a preﬁx for
some trace in L. By construction, FInvMint accepts all strings in
L. Therefore, FInvMint accepts (st)2L, and does not terminally
reject s.
Theorem 1 (InvariMint speciﬁcation of kTails is exact) .For
an input log Land an integer k, letFkTails be the corresponding
kTails FSM and let FInvMint be the InvariMint kTails FSM. Then,
the languages of the two FSMs are equivalent, or:
L(FkTails) =L(FInvMint )
Proof: We prove the two directions of equality in Theorem 1
separately.
1)L(FkTails)L(FInvMint )
Proof by contradiction:
Assume that9s2L(FkTails)ands62L(FInvMint ).
Because s62L(FInvMint )there is a non-empty set of rejecting
(non-accepting) property instances Â. That is,8P2Â;s62L(P).
Letrbe the shortest preﬁx of sto be rejected by some property
instance Pi
j2Â, with ik.
Now consider the preﬁx string r, which is rejected by Pi
j. We
can express rasr=uafor some a2S. The property instance
Pi
j(in Figure 10) can reject rin two ways:
(1a) Pi
jrejects rby terminating in state xi+2, because a62Z.
In this case, rmust be at least i+1symbols long, and can
be expressed as r=vt0tia. Consider the equivalence class
Ev=E[v]. This class must be non-empty because there exists
a transition on t0from EvtoE[vt0]. Since Evis non-empty,
consider a preﬁx p2Ev. Because i<k, and since t0tiais a
tail of v, by deﬁnition of equivalence classes, pt0tia2PFL.
However, because t0;:::; timatches the tail corresponding to Pi
j,
a2Z. Contradiction ( a62Z).
(1b) Pi
jrejects rby terminating in xh,0<hi+1, and s=r.
Note that the LTL formula of the general kTails property type
evaluation function (in Figure 10) mandates that each ambound
totmmust be followed by some am+1in some trace. Since wis
the last symbol in any trace, it cannot be bound to any amin the
evaluation function.
The above implies that 8g,0<gi+1there is no transition
onwintoxg. Since every trace terminates with w, we can express
1We omit FSM minimization as it does not change the FSM’s language.
6University of Washington Technical Report UW-CSE-13-03-01
rasr=vw. But, this contradicts Pi
jrejecting rin state xh, since
Pi
jcan only terminate on vwin states xi+2orx0.
We have shown that Pi
jcannot reject rsince it cannot terminate
onrin any non-accepting states. Therefore, by contradiction,
s2L(FInvMint )andL(FkTails)L(FInvMint ).
2)L(FInvMint )L(FkTails)
Note that s2L(FInvMint )implies that sis accepted by all
property instances that make up FInvMint .
Lets=a0an. By induction on kandn, we will show that
ifs2L(FInvMint )then there exists a valid and accepting path of
equivalence classes, [E0;:::; En], that corresponds to s, and thus
s2FkTails.
Base case (k =1):We prove this base case by induction on n,
assuming k=1.
Base case (n =2):Show that s=a0a1a2=aa1wmaps
to an accepting path E0;E1;E2;E3inFkTails.
LetE0=E[e].
Since a2S, there must be a property instance P1
j, of the
property type in Figure 9(a), that binds t0toa. This P1
jaccepts
aa1, and therefore P1
jmust bind Yto a set B, such that a12B.
Next, the LTL formula corresponding to P1
jtells us that9t2L
such that (a! a1). Since ais the ﬁrst symbol for any trace,
this means that aa1is a preﬁx for this t. Since ais a valid
preﬁx, there must exist a non-empty equivalence class E1=E[a].
E0has a transition to E1ona, because ais a valid preﬁx for
traces in L.
Now, consider the string a1w. Since a1appears in some
trace there must be a corresponding property instance P1
m. By
the same reasoning as above, P1
mbinds t0toa1and binds Yto a
setB0such that w2B0. The LTL formula corresponding to P1
m
tells us that9t02Lsuch that (a1! w). We can represent
thist0ast0=pa1w.
Note that p(a preﬁx of t0) andahave identical 1-tails, namely
fa1g. By construction of FkTails this means that pandabelong
to the same equivalence class E1. Since, pa1is a valid preﬁx,
there must exist an equivalence class E2=E[pa1], and there
must be a transition from E1toE2ona1.
Finally, we will use t0to construct E3. Since pa1maps to E2,
there must be a transition on wtoE3. This E3must be terminal
because it contains the trace t0.
As a result, we have constructed an accepting path
E0;E1;E2;E3for the string s.
Inductive hypothesis (n =i):Assume that a0aimaps to
a valid path E0;:::; Ei. Show that a0ai+1maps to a valid path
E0;:::; Ei+1.
Consider the string aiai+1. Since aiappears in some trace
there must be a corresponding property instance P1
j. By the
reasoning in the base case, P1
jbinds t0toaiand binds Yto a set
Bsuch that ai+12B. The LTL formula corresponding to P1
jtells
us that9t2Lsuch that (ai! ai+1). We can represent this
tast=paiai+1.
Based on our induction assumption, there exists an equiva-
lence class Ei 1that corresponds to ai 1. Since the preﬁx pis
followed by aiint,pmust also map to Ei 1. Therefore, we can
 0 200 400 600 800 1000
 5  10  15  20  25  30  35  40  45  50Time (s)
Log length (thousands of events)kTails
InvariMint kTailsFig. 11. The running time of procedural kTails and the declarative InvariMint
version of kTails for different log input sizes. The number of property instances
true of the log was held constant at 182.
extend E0;:::; Ei 1with E0
iandEi+1, where E0
i=E[pai]and
Ei+1= [paiai+1].
Inductive hypothesis (k =j):We prove this by induction on n.
We assume that the proof statement is true for k=jand perform
induction on nto show that the statement is true for k=j+1.
Base case (n =2):Show that s=a0a1a2=aa1wmaps
to an accepting path E0;E1;E2;E3inFkTails.
Since k=j>1,FInvMint includes property instances corre-
sponding to the kTails( k=1) property type (Deﬁnition 2). This
means that we can re-use the base case for k=1above and
construct the path E0;E1;E2;E3corresponding to sinFkTails in
the same manner. This construction also holds for k=j+1.
Inductive hypothesis (n =i):Assume that a0aimaps to
a valid path E0;:::; Ei. Show that a0ai+1maps to a valid path
E0;:::; Ei+1.
Consider the string t=ai jai. Each symbol in tcorre-
sponds to a property P, for a particular kvalue, that makes up
FInvMint and which accepts all of the symbols at the tail of tin
front of the symbol.
For example, ai jcorresponds to some property Pj, which
accepts the tail ai j+1aioft. Using the base case construction
of overlapping preﬁxes, we construct a path E0;:::; Ei+1that
corresponds to a0ai+1.
C. Empirical evaluation
We implemented InvariMint and the kTails algorithm in Java
and evaluated their relative performance in two experiments.
Both experiments were executed on an OS X 10.8 machine with
a 2.8GHz Intel i7 processor and 8GB of RAM. In all experiments
the bottleneck resource was the CPU. Our experiments used logs
with tens of thousands of events. From our previous studies [5]
we consider this to be a representative log size for logs generated
by developers during debugging sessions.
In the ﬁrst experiment, we ran both algorithms on logs that
ranged in size from 5K to 50K events, but maintained a constant
number of property instances per log. Each log ranged over
an alphabet of 5 event types, and each log was partitioned into
20 traces of equal length. The number of property instances
true for each log was held constant at 182. We performed this
experiment three times. Figure 11 plots the average runtime of
the three runs for each log size.
7University of Washington Technical Report UW-CSE-13-03-01
In the ﬁgure, as the log size increases the standard kTails al-
gorithm scales poorly because it needs to perform more merges.
The InvariMint kTails algorithm maintains an almost constant
running time. This is because for a constant number of prop-
erty instances InvariMint kTails composes property instances
in constant time — composing 182 property instances used in
the experiment took about 10 seconds. Although the time to
mine property instances does increase linearly with log size, it
remains insigniﬁcant (for a 50K event log, all property instances
are mined in under one second).
In the second experiment, we varied the number of property
instances for the log from 108 to 1,480, but maintained a constant
log size of 25K events. Logs were drawn from an alphabet that
had between 9 and 37 event types. As above, each run was
repeated three times and Figure 12 plots the average for each set
of three running times. Overall InvariMint kTails had a lower
running time than procedural kTails. However, the relative ratio
between the two running times indicates that InvariMint kTails
scales worse than procedural kTails as the number of property
instances increases.
Overall we found that our declarative InvariMint kTails im-
plementation outperforms kTails on large logs with few property
instances, while procedural kTails scales better with increasing
number of property instances.
IV. E XPRESSING SYNOPTIC WITH INVARI MINT
This section describes the Synoptic model-inference algo-
rithm, formulates it with InvariMint, and evaluates the resulting
formulation.
A. Synoptic and its shortcomings
Synoptic is a model-inference algorithm that explicitly infers
properties from the log, then constructs a model that satisﬁes
them.2Synoptic ﬁrst infers an overly-general model of the log,
which accepts too many traces. Then, Synoptic progressively
reﬁnes the model until every trace in the language of the model
satisﬁes speciﬁc properties mined from the log. Because Syn-
optic models enforce these observed properties, prior work has
found that the models accurately describe the underlying system
and can improve understanding and aid debugging [5].
The Synoptic algorithm has four steps: (1)Mine three kinds
of properties from the log — “ xAlwaysFollowedBy y” (when-
ever event xoccurs in a trace, event yalso occurs later in the
same trace), “ xAlwaysPrecedes y” (whenever event yoccurs in a
trace, event xalso occurs earlier in the same trace), and “ xNever-
FollowedBy y” (whenever event xoccurs in a trace, event ynever
occurs later in the same trace). (2)Build an initial model by
merging all anonymous3states with the same outgoing event into
a single state. (3)Iteratively apply counterexample-guided ab-
straction reﬁnement (CEGAR) [ 9] to derive a model that satisﬁes
2For simplicity, and despite minor differences, we use “property” where the
Synoptic literature uses the term “invariant”.
3Synoptic uses an event-based graph model with nodes representing event
types and unlabeled edges representing observed event orderings in the log. This
model is equivalent to an FSM with anonymous states, which is the model type
we use in this paper.
 5 10 15 20 25 30 35 40 45 50
 0  200  400  600  800  1000  1200  1400  1600Time (s)
Property instanceskTails
InvariMint kTailsFig. 12. The running time of procedural kTails and the declarative InvariMint
version of kTails for logs with different number of property instances. The size
of the log was held constant at 25K events.
all of the mined properties. Synoptic does this by model check-
ing the current (e.g., initial) model against the mined properties
to ﬁnd counterexample traces in the model’s language, which
falsify one or more of the properties. Synoptic then traces the
found counterexample in the model to ﬁnd the ﬁrst state respon-
sible for falsifying the property, and reﬁnes (splits) that state to
remove the counterexample path. Synoptic repeatedly reﬁnes the
model to eliminate counterexamples until it reaches a model that
satisﬁes all of the properties. (4)Finally, to compact the model,
Synoptic applies kTails( k=1) to the reﬁned model, but only per-
forms a merge if it does not un-satisfy any of the properties.4
While empirically shown to help developers improve their sys-
tem understanding and ﬁnd bugs [ 5], Synoptic has two features
that may cause its users difﬁculty.
First, Synoptic is non-deterministic. The order in which it
resolves the counterexamples may affect the language of the ﬁnal
model it produces. (More generally, the problem Synoptic tries
to solve is NP-complete [ 9], [13], [2], so the non-deterministic
algorithm attempts to balance running time against the size of
the ﬁnal model.) If a user makes a change to the input log and
Synoptic produces a different model, the user does not know
if the input log difference explains the change in the returned
model. This makes it difﬁcult to apply Synoptic to verify a bug
ﬁx or to check how a new feature impacts the model.
Second, while signiﬁcantly more efﬁcient on large traces than
kTail-based model inference, Synoptic may still be slow. This is
because Synoptic must maintain all of the parsed log traces in
memory, and it makes repeated model checking invocations and
repeatedly traverses the model.
Next, we present an InvariMint formulation that approximates
Synoptic. We show that the InvariMint algorithm resolves the
above two issues of non-determinism and performance, and
discuss insights that we gained about Synoptic through this
formulation.
B. Modeling Synoptic with InvariMint
Synoptic’s use of well-deﬁned properties simpliﬁes the task of
declaratively specifying it with InvariMint — each of the three
4In an event-based model, Synoptic uses kTails( k=0) to merge nodes with
identical event labels. This is equivalent to kTails( k=1) in a state-based model.
8University of Washington Technical Report UW-CSE-13-03-01
(a) x AlwaysFollowedBy y property typeEval(LogL,hx=a, y=bi)=⇢true :8t2L,⇤(a!⌃b)i ntfalse : otherwises1s2yx{x}⌃\{y}⌃\
(b) x AlwaysPrecedes y property types1s2yxs3{x,y}⌃\⌃⌃Eval(LogL,hx=a, y=bi)=⇢true :8t2L,(⌃b!¬bUa)i ntfalse : otherwise
(c) x NeverFollowedBy y property types1yxs3s2⌃{x}⌃\{y}⌃\Eval(LogL,hx=a, y=bi)=⇢true :8t2L,⇤(a!⇤¬b)i ntfalse : otherwise
Fig. 13. Three of the four property types used by InvariMint to model the
Synoptic algorithm. Figure 4(a) shows the fourth property type, which captures
Synoptic’s initial model.
mined properties in Synoptic (AlwaysFollowedBy, AlwaysPre-
cedes, and NeverFollowedBy) has a corresponding property type,
shown in Figure 13.
However, while Synoptic explicitly speciﬁes some of the log
properties that the inferred models will enforce, its original pro-
cedural deﬁnition imposed a property that was unknown both
to Synoptic users and to us, the researchers who developed the
algorithm. The process of specifying Synoptic declaratively
with InvariMint revealed this property. We found that the initial
Synoptic model is not captured by the three explicit properties
and the InvariMint formulation requires the additional “immedi-
ately followed by” property type, which is exactly SimpleAlg’s
property type (Figure 4(b)).
To compose Synoptic property instances, InvariMint
uses a composition formula that is similar to Sim-
pleAlg: Compose (Prop1;:::; Propn) = Minimize (
(Minimize (Prop1\Prop2)\)\Propn). This composi-
tion minimizes intermediate models so as to maintain a small
model in memory at runtime. For a large number of property
instances, this composition yields a faster algorithm.
Next, we evaluate this InvariMint formulation of Synoptic.
C. Theoretical evaluation
We were already intimately familiar with Synoptic. Nonethe-
less, when we modeled Synoptic with InvariMint, we discovered
a new feature, demonstrating how InvariMint can improve algo-
rithm understanding. The InvariMint formulation of Synoptic
is, in fact, an approximation of the Synoptic algorithm. A key
InvariMint SynopticSynopticModel 1SynopticModel 2LogFig. 14. The inclusion relationships between an input log, the language of the
model derived from the log with InvariMint Synoptic, and the languages of two
potential non-deterministically-derived Synoptic models for the log.
feature of Synoptic models is that they have no spurious transi-
tions. That is, every transition in the model is associated with
some event in the log — there are no uncovered, or spurious ,
transitions. The reason for this feature is that Synoptic models
are deﬁned in terms of traces — a transition between two states
in the model exists only if there are two observed states in the
log that map to the model states and have this transition.
InvariMint models, on the other hand, are speciﬁed in terms
of event types, so the particular trace-speciﬁc constraints are
absent from an InvariMint model unless they are explicitly
speciﬁed with property types. Therefore, InvariMint models
may contain spurious transitions. Figure 14 summarizes the
relationships between the language of the model derived us-
ing an InvariMint formulation of Synoptic, the languages of
possible non-deterministically-derived Synoptic models, and
the input log. The InvariMint formulation is more permissive
than Synoptic, and includes the language of all possible non-
deterministically-derived Synoptic models. Here, we prove that
a Synoptic model’s language is a subset of the model derived
using InvariMint Synoptic algorithm. We also show that the
InvariMint model does not satisfy any Synoptic property in-
stances that are not true of the input log. This result is analogous
to Theorem 3 in [5].
Theorem 2 (InvariMint speciﬁcation of Synoptic encompasses
Synoptic) .LetLbe a log. Let FSynoptic andFInvMint be the FSMs
produced by the Synoptic algorithm and the InvariMint Synoptic
algorithm on L, respectively. Let L(FSynoptic )andL(FInvMint )be
the languages of those models. Then L(FSynoptic )L(FInvMint ).
Proof: Lettbe a trace in L(FSynoptic ). By construction, Synoptic
terminates when all traces accepted by its inferred model satisfy
all instances of the AlwaysFollowedBy, AlwaysPrecedes, and
NeverFollowedBy property instances mined from L. Therefore,
tmust satisfy all such property instances.
Consider each of the property instances intersected to form
FInvMint . First, each property instance of the three types de-
scribed in Figure 13 is mined from L, and therefore must be true
in each trace in L. Since tsatisﬁes all such property instances,
the language of each of these instance FSMs must contain t. Sec-
ond, each property instance of the type described in Figure 4(a)
accepts all traces whose transitions are pairs of consecutive
events observed in L. Since each transition in FInvMint maps to at
least one pair of consecutive events in at least one trace in L, a
property instance FSM must accept t.
Since every property instance intersected to form FInvMint
accepts t,t2L(FInvMint ). Therefore, L(FSynoptic )L(FInvMint ).
9University of Washington Technical Report UW-CSE-13-03-01
 20 40 60 80 100 120 140 160 180
 5  10  15  20  25  30  35  40  45  50Time (s)
Log length (thousands of events)Synoptic
InvariMint Synoptic
Fig. 15. The running time of procedural Synoptic and the declarative Invari-
Mint version of Synoptic for different log input sizes. The number of property
instances true of the log was held constant at 19.
Theorem 3 (Models produced by InvariMint Synoptic do not
include false property instances) .LetLbe a log and let FInvMint
be the FSM produced by the InvariMint Synoptic algorithm on
L. More speciﬁcally, let F InvMint =Compose (P1;:::;Pn).
LetPf alse be a setof property instances, such that 8Pf2
Pf alse,Pfis an instantiation of some Synoptic property type
hPFSM ;Evali, such that9a binding Bf,Pf=PFSM (Bf)and
Eval(L;Bf)isf alse . That is, Pf alsecontains well formed prop-
erty instances that are not true for the input log L.
Then8i;Pi62Pf alse.
Proof:
We present a proof by contradiction. Assume the opposite —
9Pi,Pi2Pf alse.
Since Piis used to construct FInvMint , it must correspond to
some property type hPFSM ;Evali, and by the pseudocode in
Figure 6,9B,Pi=PFSM (L;B)andEval(L;B)istrue.
However, by deﬁnition of the set Pf alse,Eval(L;B)must be
false. Contradiction.
As discussed in Section IV-A , Synoptic is non-deterministic
and executing Synoptic on two similar logs may produce differ-
ent models, even when using identical random number generator
seeds. The InvariMint formulation of Synoptic removes this
non-determinism because FSM intersection and minimization
are commutative. This, in turn, makes it possible to use the
algorithm to assist in other development tasks, such as to verify
a bug ﬁx or to check how a new feature impacts the model.
D. Empirical evaluation
We compared the performance of procedural Synoptic against
the declarative InvariMint Synoptic implementation. Both algo-
rithms are implemented in Java and we use the same experimen-
tal setting as in the kTails experiments (Section III-C).
We carried out two experiments to compare algorithm per-
formance across different log sizes (Figure 15), and across logs
with varying number of property instances (Figure 16). As with
the kTails algorithm, Figure 15 indicates that the declarative ver-
sion of Synoptic outperforms procedural Synoptic on large logs.
As the number of property instances increases (in Figure 16),
InvariMint Synoptic continues to outperform Synoptic.
 0 100 200 300 400 500 600 700
 5  10  15  20  25  30  35  40  45Time (s)
Property instancesSynoptic
InvariMint SynopticFig. 16. The running time of procedural Synoptic and the declarative InvariMint
version of Synoptic for logs with different number of property instances. The
size of the log was held constant at 25K events.
V. D ISCUSSION
Although this paper has presented insights derived from ex-
pressing existing model-inference algorithms with InvariMint,
there are other beneﬁts to the InvariMint formulation. If the
model is used for model checking or runtime veriﬁcation, a
declarative speciﬁcation can be more efﬁciently checked (e.g., in
parallel) against a property, and can yield more efﬁcient runtime
conformance checking of a trace. A violated property instance
can also be more helpful than a path counterexample in under-
standing why the property does not hold or why a trace does not
conform to the model.
As an example of the generality and expressiveness of our
approach, an evaluation function may deem a property valid
if it is true in most of the traces. This can be useful when the
properties are probabilistic or the log is incomplete, as when it is
not feasible to capture a log from a live, online system’s start of
execution to its end. For example, some traces at the start may be
missing the login event while others at the end may be missing
thelogout event. InvariMint can still mine the property that
all traces start with login and end with logout , as long as an
overwhelming fraction of the traces satisfy that property. Other
kinds of property types include conditional properties (e.g., an
event is present only if the username is root ), properties on
resource usage (e.g., time or space), and anomaly-detecting
properties (e.g., two events co-occur rarely).
In this paper we use LTL to compactly specify evaluation func-
tions. As a result, in all of the presented examples the PFSM
could be automatically derived from the LTL — the PFSM is a
parameterized version of the b ¨uchi automaton corresponding to
the LTL formula. However, this is not possible for the alterna-
tive evaluation functions mentioned above, as these cannot be
expressed with LTL.
InvariMint can be robust to speciﬁcations with overlapping or
conﬂicting property types. For example, an evaluation function
that intersects property instances will ignore overlapping prop-
erty instances, and will immediately reveal conﬂicting property
instances as their intersection would be the empty set.
A. Tips for declaratively expressing algorithms with InvariMint
First, identify the right property-type granularity. Do not sim-
ply simulate the procedural version of the algorithm with the
10University of Washington Technical Report UW-CSE-13-03-01
property types. Instead, consider the properties that the procedu-
ral algorithm enforces. Property types that are too ﬁne-grained
and too close to the input traces (e.g., union of positive exam-
ple trace DFAs) lead to models that overﬁt the log, rather than
describe the algorithm. Property types can describe algorithm
operations. For example, Section III showed how a single prop-
erty type describes merging of all states with the same k-tail.
If the procedural algorithm deals with positive examples of
traces (as both kTails and Synoptic do), starting from a formula-
tion that produces a model that is a generalization of the desired
model may be easier, as this model may enforce fewer properties.
Then, reﬁne this model towards the desired model by introducing
new property types or by reﬁning the existing properties.
If the procedural algorithm deals with both positive and nega-
tive examples of traces (we have not shown such an algorithm
in this paper), consider building separate models, one for the
positive examples and one for the negative examples. Then, in
the composition function, subtract the negative-example model
from the positive-example model.
VI. R ELATED WORK
The kTails algorithm [ 6] is the basis for numerous model-
inference algorithms [ 10], [21], [18], [19], [22], [8], [26], [27].
Many of these algorithms can be modeled with InvariMint to bet-
ter understand, extend, combine, and compare them. At least two
of the techniques require richer models than the standard FSM
models we use in this paper. GK-Tails [ 22] requires EFSMs, and
RPNI [8] requires Probabilistic FSMs.
There are numerous algorithms to mine temporal properties,
like the ones we have used in this paper [ 3]. Data-value proper-
ties that relate internal program variables can encode method pre-
and post-conditions, as well as class-level properties. Automat-
ically inferring these properties from program executions [ 11]
can improve model inference [ 22]. Combining data-value and
temporal properties can improve scenario-based speciﬁcation
mining [ 20]. Recent work by Gabel and Zhendong can also
be applied to validate property instances during an InvariMint
execution [12].
Model-inference frameworks can facilitate algorithm compar-
ison [ 24]. However, to date, these frameworks have been used
to compare model performance and accuracy, not properties
of model inference. Further, much of the kTail-based model-
inference work compares the recall and precision of inferred
models against manually-speciﬁed ground-truth models. This
process is manual, error-prone, and, again, compares model
quality, as opposed to model-inference properties. Model qual-
ity is a notoriously challenging aspect of model inference [ 18].
QUARK, a comparison framework, allows for comparing the
quality of models generated by algorithms such as kTails [ 6]
and sk-strings [ 25]. InvariMint is complementary to these frame-
works, as it aims to unify model-inference algorithms with a
declarative speciﬁcation language, facilitating algorithm com-
parison, and model property comparison.
Non-FSM model inference (e.g., of UML sequence dia-
grams [ 31], communicating automata [ 7], and symbolic message
sequence graphs [ 17]) can also aid developer tasks. Some of thiswork is similar to kTails, and we believe InvariMint can be ex-
tended to accommodate such algorithms. Similarly, InvariMint
may be extendable to other types of properties, such as those
used to infer behavioral models of web-services [4].
Walkinshaw et al. [ 28] propose a model-inference technique
in which the user provides a model-inference algorithm with
LTL formulae, which are then checked by a model checker and
are used as constraints on feasible state merges in the infer-
ence algorithm. InvariMint uses LTL differently. Our intent is
generalize the speciﬁcation of model-inference algorithms. To
this end, LTL formulae encode valid bindings of variables in a
parameterized FSM to event types for a particular log input.
VII. C ONCLUSION
Model-inference algorithms can automatically mine models
of complex systems. Such models aid numerous development
tasks, such as program understanding and debugging. Unfortu-
nately, existing model-inference algorithms are deﬁned procedu-
rally, making them difﬁcult to understand, extend, and compare
to one another. We have presented InvariMint, a declarative
speciﬁcation approach for model-inference algorithms. Invari-
Mint enables speciﬁcation of algorithms in terms of the types
of properties they enforce in the models they infer. InvariMint’s
declarative speciﬁcations (1)provide insight into how inference
algorithms work and how the model relates to the underlying
system, (2)allow for easy extension of existing algorithms to
construct hybrid alternatives, and (3)provide a common lan-
guage for comparing and contrasting the essential aspects of
model-inference algorithms. We demonstrated the beneﬁts of
InvariMint by declaratively specifying two existing algorithms,
kTails and Synoptic. For example, the InvariMint versions of
these algorithms greatly outperform their procedural analogs.
We look forward to applying InvariMint’s declarative approach
more broadly and bringing these beneﬁts to additional algo-
rithms. InvariMint is available as an open-source tool:
http://synoptic.googlecode.com
VIII. A CKNOWLEDGMENTS
We would like to acknowledge Joseph Devietti, who proposed
an early version of the InvariMint idea in a conversation. We
also thank the anonymous reviewers for their helpful feedback.
InvariMint is supported by Google, DARPA grant FA8750-12-2-
0107, and NSF grants CNS-0963754 and CCF-1016701.
11University of Washington Technical Report UW-CSE-13-03-01
REFERENCES
[1]M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API Patterns as Partial
Orders from Source Code: From Usage Scenarios to Speciﬁcations. In
ESEC/FSE , 2007.
[2]D. Angluin. Finding Patterns Common to a Set of Strings. Journal of
Computer and System Sciences , 21(1):46–62, 1980.
[3] C. M. Antunes and A. L. Oliveira. Temporal Data Mining: An Overview.
InKDD 2001 Workshop on Temporal Data Mining , 2001.
[4]A. Bertolino, P. Inverardi, P. Pelliccione, and M. Tivoli. Automatic Synthe-
sis of Behavior Protocols for Composable Web-Services. In ESEC/FSE ,
pages 141–150, 2009.
[5]I. Beschastnikh, Y . Brun, S. Schneider, and M. D. Ernst. Leveraging
Existing Instrumentation to Automatically Infer Invariant-Constrained
Models. In ESEC/FSE , pages 267–277, 2011.
[6]A. W. Biermann and J. A. Feldman. On the Synthesis of Finite-State
Machines from Samples of Their Behavior. IEEE TC , 21(6):592–597,
1972.
[7]B. Bollig, J.-P. Katoen, C. Kern, and M. Leucker. Learning Communicating
Automata from MSCs. IEEE TSE , 36(3):390–408, 2010.
[8]R. C. Carrasco and J. Oncina. Learning Stochastic Regular Grammars by
Means of a State Merging Method. In ICGI , 1994.
[9]E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith. Counterexample-
guided Abstraction Reﬁnement. In Computer Aided Veriﬁcation , pages
154–169, 2000.
[10] J. E. Cook and A. L. Wolf. Discovering Models of Software Processes
from Event-Based Data. ACM ToSEM , 7(3):215–249, 1998.
[11] M. D. Ernst, J. Cockrell, W. G. Griswold, and D. Notkin. Dynamically
Discovering Likely Program Invariants to Support Program Evolution. In
ICSE , pages 213–224, 1999.
[12] M. Gabel and Z. Su. Testing Mined Speciﬁcations. In FSE, 2012.
[13] E. M. Gold. Language Identiﬁcation in the Limit. Information and Control ,
10(5):447–474, 1967.
[14] S. Hangal and M. Lam. Tracking Down Software Bugs Using Automatic
Anomaly Detection. In ICSE , 2002.
[15] J. Hatcliff and M. Dwyer. Using the Bandera Tool Set to Model-Check
Properties of Concurrent Java Software. In CONCUR , 2001.
[16] J. E. Hopcroft. An nlognAlgorithm for Minimizing States in a Finite
Automaton. Technical report, Stanford Univ., 1971.
[17] S. Kumar, S.-C. Khoo, A. Roychoudhury, and D. Lo. Inferring Class Level
Speciﬁcations for Distributed Systems. In ICSE , 2012.
[18] D. Lo and S.-C. Khoo. QUARK: Empirical Assessment of Automaton-
based Speciﬁcation Miners. In WCRE , 2006.
[19] D. Lo and S.-C. Khoo. SMArTIC: Towards Building an Accurate, Robust
and Scalable Speciﬁcation Miner. In FSE, 2006.
[20] D. Lo and S. Maoz. Scenario-Based and Value-Based Speciﬁcation Mining:
Better Together. In ASE, pages 387–396, 2010.
[21] D. Lo, L. Mariani, and M. Pezz `e. Automatic Steering of Behavioral Model
Inference. In ESEC/FSE , 2009.
[22] D. Lorenzoli, L. Mariani, and M. Pezz `e. Automatic Generation of Software
Behavioral Models. In ICSE , 2008.
[23] L. Mariani and M. Pezz `e. Dynamic Detection of COTS Component
Incompatibility. IEEE Software , 24(5):76–85, 2007.
[24] M. Pradel, P. Bichsel, and T. R. Gross. A Framework for the Evaluation of
Speciﬁcation Miners Based on Finite State Machines. In ICSM , 2010.
[25] A. V . Raman and J. D. Patrick. The sk-strings Method for Inferring PFSA.
InAIGILA , 1997.
[26] S. P. Reiss and M. Renieris. Encoding Program Executions. In ICSE ,
2001.
[27] N. Walkinshaw and K. Bogdanov. Inferring Finite-State Models with
Temporal Constraints. In ASE, pages 248–257, 2008.
[28] N. Walkinshaw and K. Bogdanov. Inferring Finite-State models with
temporal constraints. pages 248–257, Sept. 2008.
[29] W. Xu, L. Huang, A. Fox, D. Patterson, and M. Jordan. Experience Mining
Google’s Production Console Logs. In SLAML , 2010.
[30] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M. Das. Perracotta: Mining
Temporal API Rules from Imperfect Traces. In ICSE , 2006.
[31] T. Ziadi, M. da Silva, L. Hillah, and M. Ziane. A Fully Dynamic Approach
to the Reverse Engineering of UML Sequence Diagrams. In ICECCS ,
pages 107–116, 2011.
12