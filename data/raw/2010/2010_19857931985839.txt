VerifyingMulti-threadedSoftwareusingSMT-based
Context-BoundedModelChecking
Lucas Cordeiro
University of Southampton
lcc08r@ecs.soton.ac.ukBernd Fischer
University of Southampton
b.ﬁscher@ecs.soton.ac.uk
ABSTRACT
We describe and evaluate three approaches to model check
multi-threaded software with shared variables and locks us-
ing bounded model checking based on Satisﬁability Modulo
Theories (SMT) and our modelling of the synchronization
primitives of the Pthread library. In the lazy approach, we
generate all possible interleavings and call the SMT solver
on each of them individually, until we either ﬁnd a bug, or
have systematically explored all interleavings. In the sched-
ule recording approach, we encode all possible interleavings
into one single formula and then exploit the high speed of
the SMT solvers. In the underapproximation and widening
approach, we reduce the state space by abstracting the num-
ber of interleavings from the proofs of unsatisﬁability gener-
ated by the SMT solvers. In all three approaches, we bound
the number of context switches allowed among threads in
order to reduce the number of interleavings explored. We
implemented these approaches in ESBMC, our SMT-based
bounded model checker for ANSI-C programs. Our experi-
ments show that ESBMC can analyze larger problems and
substantially reduce the veriﬁcation time compared to state-
of-the-art techniques that use iterative context-bounding al-
gorithms or counter-example guided abstraction reﬁnement.
CategoriesandSubjectDescriptors
D.2.4 [ Software/Program Veriﬁcation ]: Model check-
ing; F.3.1 [ Specifying and Verifying and Reasoning
about Programs ]: Mechanical veriﬁcation
GeneralTerms
Computer-Aided Veriﬁcation
Keywords
Formal Software Veriﬁcation, SAT Modulo Theories, Sym-
bolic and Explicit Model Checking, Multi-threaded systems
Permissiontomakedigitalorhardcopiesofallorpartofthisw orkfor
personalorclassroomuseisgrantedwithoutfeeprovidedth atcopiesare
notmadeordistributedforproﬁtorcommercialadvantageandth atcopies
bearthisnoticeandthefullcitationontheﬁrstpage.Tocop yotherwise,to
republish,topostonserversortoredistributetolists,re quirespriorspeciﬁc
permissionand/orafee.
ICSE’11,May21–28,2011,Waikiki,Honolulu,HI,USA
Copyright2011ACM978-1-4503-0445-0/11/05...$10.00.1. INTRODUCTION
Bounded model checking (BMC) has already been suc-
cessfully applied to verify software and to discover subtle
errors in real systems [3]. In an attempt to cope with grow-
ing system complexity, Boolean Satisﬁability (SAT) solvers
are increasingly replaced by Satisﬁability Modulo Theories
(SMT) solvers to prove the generated veriﬁcation conditions
(VCs) [1, 8, 12]. There have also been attempts to extend
BMC to the veriﬁcation of multi-threaded software [13, 16,
17, 25]. The main challenge here is the state space explosion,
as the number of possible interleavings grows exponentially
with the number of threads and program statements. How-
ever, most concurrency bugs in real applications have been
found to be shallow so that only a few context switches are
required to expose them [23]. We can thus use a context-
bounded analysis [18, 28] that limits the number of context
switches it explores. Also, SAT and SMT solvers produce
unsatisﬁable cores that allow us to remove possible undesired
models of the system in order to satisfy a given property [19].
Grumberg et al. [15] showed that the unsatisﬁable cores can
also be used to control the number of allowed interleavings of
the given set of threads. They proposed a SAT-based BMC
method to model check a multi-threaded system using a se-
ries of under-approximated models. However, their method
does not use SMT solvers and does not combine context-
bounded analysis with symbolic algorithms, which limits its
usefulness for verifying multi-threaded software.
In our prior work [8], we extended the encodings from pre-
vious SMT-based BMC [1, 12] to provide more accurate sup-
port for variables of ﬁnite bit width, bit-vector operations,
arrays, structures, unions and pointers, and implemented
these in the ESBMC tool, which is built on top of the CBMC
model checker [5]. Here, we continue this work and develop
and evaluate three related approaches for model checking
multi-threaded ANSI-C software. In contrast to previous
fully symbolic approaches (e.g., [13, 16, 17, 25, 15]), we
combine symbolic model checking with explicit state space
exploration. In particular, we explicitly explore the possible
interleavings (up to the given context bound) while we treat
each interleaving itself symbolically. This approach is simi-
lar to the recent ESST approach by Cimatti et al. [4], but
we handle ANSI-C instead of SystemC, use BMC instead of
predicate abstraction, and place no restrictions on the sched-
uler. Our approaches all implicitly use the reachability tree
(RT) derived from the system, but diﬀer in the way they ex-
ploit it. In the lazyapproach, we traverse the RT depth-ﬁrst,
and simply call the single-threaded BMC procedure on the
interleaving whenever we reach an RT leaf node. We stop thePermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00
331
RT traversal either when we ﬁnd a bug, or have systemat-
ically explored all interleavings. In the scheduling recording
approach, we use the RT to encode all the possible execu-
tion paths into one single formula, which is then fed into
the SMT solver. In a third approach, we extend the under-
approximation and widening (UW) algorithm [15] with the
purpose of addressing the veriﬁcation of real-world C code
using diﬀerent background theories and SMT solvers.
We make two major novel contributions. First, we exploit
SMT to improve BMC of multi-threaded software. We de-
scribe a comprehensive SMT-based BMC procedure to sup-
port the checking of multi-threaded C programs that use
the synchronization primitives of the POSIX Pthread Li-
brary [20]. Second, we describe and evaluate three related
approaches to SMT-based BMC. This work also marks the
ﬁrst application of the UW algorithm in combination with
context-bounded model checking to verify non-trivial multi-
threaded C software. Experiments obtained with the ex-
tended ESBMC show that our approaches can analyze larger
problems and substantially reduce the veriﬁcation time over
state-of-the-art techniques that use iterative context-bounding
algorithms and others that implement counter-example guided
abstraction reﬁnement (CEGAR) techniques.
2. PRELIMINARIES
In the widely adopted interleaving paradigm for multi-
threaded programs, the notion of concurrency is represented
by that of interleaving, i.e., the non-deterministic choice be-
tween activities of the simultaneously acting threads [2]. An
interleaving thus represents a possible execution of the pro-
gram where all of the concurrent events are arranged in a
linear order. Any change of the active thread in an inter-
leaving is a context switch.
The interleaving paradigm relies on a scheduler, which
selects the concurrently executing threads according to a
given strategy. This abstracts from the speed of the par-
ticipating threads and thus models any possible realization
by a single-core machine or by several cores with arbitrary
speeds. However, in order to fully verify a multi-threaded
program against a given speciﬁcation, all possible interleav-
ings must be considered. This results in a large state space
that must be explored by a model checker.
2.1 GotoPrograms
We consider multi-threaded ANSI-C programs in asyn-
chronous mode and assume that all threads in the program
only communicate through shared global variables. ESBMC
handles full ANSI-C, but for presentation, we use a min-
imal language similar to the internal goto-language of the
CBMC model checker [5]. It is expressive enough to model
multi-threaded programs:
Fml::=Var|true|false|Fml∧Fml|...|Exp=Exp|...
Exp::=Var|Const |Var[Exp]|Exp +Exp|...
Cmd ::=skip|Var=Exp|Var=∗ |assume Fml
|assert Fml |gotol|if Fml goto l|begin atomic
|endatomic |begin thread Id |endthread
|Var =start thread Id |join thread Var
Prog ::=Cmd ;...;Cmd
A goto-program is a (numbered) list of commands. Com-
mands include assignments, nondeterministic assignments
(Var =∗), blocking statements ( assume ) to cut oﬀ sub-sequent executions paths, and assertion statements ( assert )
to indicate user-speciﬁed properties. All control structures
are represented by explicit (conditional) jumps to a state-
mentl∈ {1,...,n }. A threadtis a sublist of commands be-
tween begin thread andendthread . Threads are created via
asynchronous procedure calls ( start thread ), which return
an integer that can be used as thread identiﬁer for synchro-
nization ( join thread ); hence, dynamic thread creation is al-
lowed. Atomic statements ( atomicbegin andatomicend)
indicate that a code segment cannot be preempted by an-
other thread. Figure 1 shows an example of a multi-threaded
C program and its representation.
2.2 FormalModelofMulti-threadedSoftware
The multi-threaded software to be analyzed is modelled
as a tupleM=/a\}bracketle{tS,S 0,T,V/a\}bracketri}ht, where:
•Sis a ﬁnite set of states, with initial states S0⊂S;
•T=t0,t1,...,t nis the set of threads, where nrepre-
sents the total number of threads;
•V=Vglobal ∪/uniontextVjwhereVglobal is the set of global
variables and Vjis the set of local variables of tj.
We assume that each variable ranges over a ﬁnite domain.
A states∈Sconsists of the values of the global and local
variables, including a local program counter for each thread.
Each thread jis a tupletj= (Rj,lj), where:
•Rj⊆S×Sis the transition relation of thread tj;
•lj=/angbracketleftbig
lj
i/angbracketrightbig
is the sequence of thread locations lj
iat time
stepi.
The execution of the instructions of each thread tjis mod-
elled by means of transition relations and we use the notation
Rj
i(s,s′) to denote that s′is a successor of sobtained by ex-
ecuting at time step ian instruction of thread tj. Finally, a
particular program location, denoted by lj
0is designated as
the entry point of thread tj.
3. CONTEXT-BOUNDEDMODELCHECK-
INGOFMULTI-THREADEDSOFTWARE
3.1 ExploringtheReachabilityTree
In order to describe reachable states of a multi-threaded
goto program, we use a reachability tree (RT) that is ob-
tained by unfolding the set of running threads. For a multi-
threaded program with nactive threads, each node in the
RT is a tuple ν= (Ai,Ci,si,/a\}bracketle{tlj
i,Gj
i/a\}bracketri}htn
j=1)ifor a given time
stepi, where:
•Airepresents the currently active thread;
•Cirepresents the context switch number;
•sirepresents the current state;
•lj
irepresents the current location of thread j;
•Gj
irepresents the control ﬂow guards accumulated in
threadjalong the path from lj
0tolj
i.
Since threads only communicate via global variables, we
only need to consider context switches at visible instructions,
i.e., synchronization points and statements containing global
variables. As in [13], we do not model context switches in-
side individual visible statements. This is safe as long as the
statements only read or write a single global variable, but in3321#include <pthread . h >
2int x=0;
3void ∗t1 (void ∗arg ) {
4 x++;
5 i f(x>1) x −−;
6 return NULL;
7}
8void ∗t2 (void ∗arg ) {
9 Bool y ;
10 x++;
11 y = (x >1);
12 i f( y ) x −−;
13 return NULL;
14}
15int main ( void ){
16 pthread t id1 , id2 ;
17 pthread create (&id1 ,NULL, t1 ,NULL) ;
18 pthread create (&id2 ,NULL, t2 ,NULL) ;
19 p t h r e a d j o i n (&id1 ,NULL) ;
20 p t h r e a d j o i n (&id2 ,NULL) ;
21 assert ( x==1)
22 return 0 ;
23}
(a)int x = 0 ;
begin thread t1 ;
x = x + 1 ;
i f! ( x>1) then goto L6 ;
x = x −1 ;
L6 : end thread ;
begin thread t2 ;
Bool y ;
x = x + 1 ;
y = x >1;
i f! ( y ) then goto L13 ;
x = x −1 ;
L13 : end thread ;
id1 = s t a r t t h r e a d t1 ;
id2 = s t a r t t h r e a d t2 ;
join thread id1 ;
join thread id2 ;
assert ( x==1);
return 0 ;
(b)L3: x = x +1
L4: if !(x > 1)
L5: x = x - 1L2: START_THREAD 1
L6: END_THREADFALSE
TRUEL9: x = x +1
L11: if !y
L12: x = x - 1L7: START_THREAD 2
L13: END_THREADFALSE
TRUEL8: _Bool y
L10: y = x>1
(c)
Figure 1: (a) A multi-threaded C program with an assertion viola tion. (b) The C program of (a) converted
into goto form. (c) Control-ﬂow graph of two threads of the goto program in (b).
general it is an under-approximation. However, we have not
encountered any problems in the benchmarks we have used.
Additionally, we do not model context switches between a
visible control-ﬂow test and the next visible statement, since
the test cannot inﬂuence the state. We can simulate the ef-
fect of a context switch right after a visible test by hoisting
the test out of the conditional, and assigning its result to a
new auxiliary variable, as shown in thread t2in Figure 1(a).
ESBMC can be conﬁgured to automatically insert such aux-
iliary variables. We also assume sequential consistency, as
is common in model checking multi-threaded systems.
In order to expand the RT and explore all possible in-
terleavings, we symbolically execute each instruction of the
multi-threaded goto-program. This takes as input the pro-
gram and the current RT node, and generates its children ac-
cording to the set of rules described below. We assume that
we expand an RT node νat time step iand that the guard
GAi
iof the thread tAiis enabled in state si(i.e., that the
corresponding formula is satisﬁable), so that the thread can
potentially execute the instruction Iat location lAi
i. Note
that our current implementation does not check the satisﬁ-
ability of the accumulated guards, and simply assumes that
all running threads are enabled, unless they have explicitly
been blocked. Implementing this could further reduce the
size of the RT to be explored.
R1: IfIis an assignment x=e, then we symbolically ex-
ecute I, which generates a new state si+1. We then add as
child toνa new node ν′= (Ai,Ci,si+1,/a\}bracketle{tlj
i+1,Gj
i/a\}bracketri}ht)i+1, where
the active thread remains unchanged. We increment the lo-
cation of the active thread only (i.e., lAi
i+1=lAi
i+ 1) and
leave all other locations and all guards unchanged; however,
note that the evaluation of the guards can change under the
new statesi+1, and hence threads may become enabled.
We have fully expanded νif
•lAi
iis within an atomic block; or
•Icontains no global variable (since we allow context
switches only at visible instructions); or•we have reached the upper bound of context switches
to be explored (i.e., Ci=C).
Ifνis not yet fully expanded, we then also explore all context
switches, up to the given context bound C. For each thread
j/\e}atio\slash=AiwhereGj
iis enabled in si+1, we thus create a new
child node ν′
j= (j,Ci+ 1,si+1,/a\}bracketle{tlj
i,Gj
i/a\}bracketri}ht)i+1. Inν′
jwe then
continue the RT exploration with thread jexecuting in the
state produced by the current thread Ai.
R2: IfIis askip-statement or an unconditional goto-state-
ment with target l, then we simply increment (resp. set)
the location of the current thread and continue with it. We
explore no context switches, i.e., we only add a single child
nodeν′= (Ai,Ci,si,/a\}bracketle{tlj
i+1,Gj
i/a\}bracketri}ht)i+1, wherelj
i+1=lj
i+1 (resp.
lj
i+1=l) ifj=Aiandlj
i+1=lj
iotherwise.
R3: If Iis a conditional goto-statement with test cand
targetl, then we create two child nodes ν′andν′′for both
possible outcomes of the test. For ν′, we assume that cis
true and proceed with the target instruction of the jump,
similar to unconditional jumps. However, we also add cto
the guards of all other threads, since it may contain global
variables, and may thus enable or disable other transitions.
Hence, we construct ν′= (Ai,Ci,si,/a\}bracketle{tlj
i+1,c∧Gj
i/a\}bracketri}ht)i+1(where
lj
i+1=lifj=Aiandlj
i+1=lj
iotherwise). For ν′′, we add
¬cto the guards and continue with the next instruction in
the current thread, i.e., ν′′= (Ai,Ci,si,/a\}bracketle{tlj
i+1,¬c∧Gj
i/a\}bracketri}ht)i+1
(wherelj
i+1=lj
i+ 1 ifj=Aiandlj
i+1=lj
iotherwise).
We prune one of the nodes if the condition is determined
in the current state (i.e., either evalutes to true or to false).
Note that we are not exploring any possible context switches
(even ifIis visible), since the condition cannot change the
global state.
R4: IfIis an assume - orassert -statement with argument
c, then we proceed similar to the way described in R1. We
continue with the unchanged state sibut addcto all guards,
as described in R3. If Iis an assume , andc∧Gj
ievaluates
tofalse, we prune the execution paths and if Iis an assert ,
we generate a VC to check the validity of c.333R5: IfIis astart thread instruction, we just add the indi-
cated thread to the set of active threads, i.e., we add a node
ν′= (Ai,Ci,si,/a\}bracketle{tlj
i+1,Gj
i+1/a\}bracketri}htn+1
j=1)i+1, whereln+1
i+1is the initial
location of the indicated thread, and Gn+1
i+1=GAi
i, i.e., the
thread starts with the guards of the currently active thread.
R6: IfIis ajointhread instruction with argument Id, then
we add a child node ν′= (Ai,Ci,si,/a\}bracketle{tlj
i+1,Gj
i/a\}bracketri}ht)i+1, (where
lj
i+1=lAi
i+ 1) only if the joining thread Idhas exited. We
model this by an additional variable exit jthat is set to false
when begin thread Id is called. When endthread is reached,
we setexit jtotrue to indicate that thread Idhas exited.
The remaining instructions ( begin atomic ,endatomic ,be-
ginthread , and endthread ) are just scoping constructs and
do not contribute to the expansion of the RT. As example,
we consider the C program with two threads and the cor-
responding goto-program, as shown in Figure 1(a) and (b).
This example is modiﬁed slightly from [14], where it is used
to check (by increasing the number of increments) the scala-
bility of diﬀerent context-bounded analysis algorithms. Both
threads increment a global variable x, and then, depending
on the value of x, decrement it again. t2uses a local variable
yto store the value of xand uses this in the test (cf. lines
12–13). This simulates a possible context switch between
the evaluation of the guard and the execution of the next
statement. Figure 1(c) shows the CFG representation of the
two threads t1andt2. Note that this example contains an
assertion violation in line 23, where the invariant x= 1 does
not hold under speciﬁc thread interleavings.
Figure 2 shows a fragment of the reachability tree for
threadst1andt2. We build this by ﬁrst executing the goto-
program of Figure 1(b) sequentially, i.e., in the same order
that the threads are created. In this case, we ﬁrst execute the
statements of t1(i.e., lines 3-5), followed by the statements
oft2(i.e., lines 8-12). The initial node of the RT fragment is
ν0= (t0,0,s0,/a\}bracketle{t(L16,true ),(L2,true ),(L7,true )/a\}bracketri}ht), i.e., the
main thread t0is active at line 16, the program is before the
ﬁrst context switch, the state s0hasx= 0 andyundeﬁned,
and both threads t1andt2have just been started, i.e., are
at their initial location with guards true. To expand the RT,
we check which threads are enabled from ν0. Sincet1and
t2are both enabled and since our approach always expands
the enabled thread with the smallest index, we expand the
transitions of t1. The transition relation R1
1(s0,s1) oft1that
represents the assignment x=x+ 1 is deﬁned as follows:
R1
1(s0,s1)⇔l1
1=L3∧x1=x0+ 1
∧∀v∈V\ {x}:v1=v0
The ﬁrst term corresponds to the unconditional edge from
line 2 to 3 (see Figure 1(c)). The second term deﬁnes the new
value of the shared variable x. The third term ensures that
the values of V, but notx, do not change in the transition
froms0tos1. To create node ν1, we apply rule R1, which
gives usν1= (t1,1,s1,/a\}bracketle{t(L16,true ),(L3,true ),(L7,true )/a\}bracketri}ht).
We then check again which threads are enabled and expand
t1as the enabled thread with the smallest index. The transi-
tion relation that represents the branch at program location
L4 is deﬁned by a case-split on the value of xin states1.
R1
2(s1,s2)⇔l1
2=/braceleftbigg
L6 :¬(x1>1),
L5 :otherwise
∧∀v∈V:v2=v1
The transition does not aﬀect the global state (as the con-dition ¬(x1>1) holds), so we only increment the program
location but do not create a new node in the RT (described
in rule R3). Therefore, to expand the next node from ν1, we
check again which threads are enabled and since t1has exe-
cuted all its statements, we then expand the ﬁrst instruction
of threadt2. The transition relation R2
3(s2,s3) oft2is sim-
ilar toR1
1(s0,s1). We thus apply rules R1 and R2 to derive
ν2= (t2,2,s2,/a\}bracketle{t(L16,true ),(L6,true ),(L9,true )/a\}bracketri}ht).ν3andν4
are derived in the same way. After creating ν4, botht1and
t2do not have enabled transitions and we backtrack to ex-
plore pending transitions from previous nodes; in this case,
we have already explored ν3andν2and continue the RT
exploration at ν1.
3.2 LazyApproach
The idea of the lazy approach to verify multi-threaded
software is to traverse the RT depth-ﬁrst, and to call the
single-threaded BMC procedure on each interleaving when-
ever we reach an RT leaf node. We stop the RT traversal ei-
ther when we ﬁnd a bug, or have systematically explored all
interleavings. Figure 3 details how the lazy approach works.
Formally, given an RT Υ = {ν1,...,ν N}that represents the
program unfolding for a context bound Cand a bound k,
and a property φ, we derive a VC ψπ
kfor a given interleaving
(or computation path) π={ν1,...,ν k}such thatψπ
kis sat-
isﬁable if and only if φhas a counterexample of depth kthat
is exhibited by π. The VCψπ
kis a quantiﬁer-free formula in
a decidable subset of ﬁrst-order logic, which is checked for
satisﬁability by an SMT solver. The model checking problem
associated with SMT-based BMC of a given πis formulated
by constructing the logical formula [1, 12]:
ψπ
k=constraints/bracehtipdownleft /bracehtipupright/bracehtipupleft /bracehtipdownright
I(s0)∧R(s0,s1)∧...∧R(sk−1,sk)∧property/bracehtipdownleft/bracehtipupright/bracehtipupleft/bracehtipdownright
¬φk (1)
Here,φkrepresents a safety property φin stepk,Iis the
set of initial states and R(si,si+1) is the transition relation
at time steps iandi+ 1, as described by the states in the
nodes ofπ. In order to check if the logical formula (1) is
satisﬁable or unsatisﬁable, the SMT solver constrains some
symbols by a given background theory (e.g., the theory of
arithmetics restricts the interpretation of symbols such as
+,≤, 0, and 1) [10]. If (1) is satisﬁable, then φis violated
and the SMT solver provides a satisfying assignment, from
which we can extract the values of the program variables
to construct a counterexample, i.e., a sequence of states
s0,s1,...,s kwiths0∈S0, andR(si,si+1) for 0 ≤i<k . If
(1) is unsatisﬁable, we can conclude that no error state is
reachable in length kalongπ.
Step 1: Initialize the stack with the initial node ν0and the
initial path π0=/a\}bracketle{tν0/a\}bracketri}ht.
Step 2: If the stack is empty, terminate with “no error”.
Step 3: Pop the current node νand current path πoﬀ the
stack and compute the set ν′of successors of νusing rules
R1-R6.
Step 4: Ifν′is empty, derive the VC ψπ
kforπusing for-
mula (1), and call the SMT solver on it. If ψπ
kis satisﬁable,
terminate with “error”; otherwise, goto step 2.
Step 5: Ifν′is not empty, then for each node ν∈ν′, addν
toπ, and push node and extended path on the stack. Goto
step 3.
Figure 3: Algorithm of the lazy approach.
On the face of it, the lazy approach seems to be naive:334ν0: t0, 0, x=0, y
(L16,true), (L2,true), 
(L7,true)
ν1: t1,1, x=1,y
(L16,true), (L3,true), 
(L7,true)
ν2: t2, 2, x=2,y=false
(L16,true), (L6,true),
(L9,true)
ν3: t2, 3, x=2,y=true
(L16,true), (L6,true),
(L10,true)
ν4: t2, 4, x=1,y=true
(L16,true), (L6,true),
(L12,false)ν5: t2, 2, x=2,y=false
(L16,true), (L3,true),
(L9,true)
ν6: t1, 3, x=1,y=false
(L16,true), (L5,false),
(L9,true)
ν7: t2, 4, x=1,y=false
(L16,true), (L5,false),
(L10,true)ν8: t2, 3, x=2,y=true
(L16,true), (L3,true),
(L10,true)
ν9: t1, 4, x=1,y=true
(L16,true), (L5,false),
(L10,true)
ν10: t2, 5, x=0,y=true
(L16,true), (L5,false),
(L12,false)ν12: t2,1, x=1,y=false,
(L16,true),(L2,true),
(L9,true)
ν13: t1, 2, x=2,y=false
(L16,true),(L3,true),
(L9,true)
ν14: t1, 3, x=1,y=false
(L16,true), (L5,false),
(L9,true)
ν15: t2,4,x=1,y=false
(L16,true), (L5,false),
(L10,true)ν16: t2, 3, x=2,y=true
(L16,true), (L3,true),
(L10,true)
ν17: t1, 4, x=1,y=true
(L16,true), (L5,false),
(L10,true)
ν18: t2, 5, x=0,y=true
(L16,true),(L5,false),
(L12,false)ν20:t2, 2, x=1,y=false
(L16,true), (L2,true),
(L10,true)
ν21: t1, 3, x=2,y=false
(L16,true), (L3,true),
(L13,true)
ν22: t1, 4, x=1,y=false
(L16,true), (L5,false),
(L13,true)ν11: t2, 4, x=1,y=true
(L16,true), (L5,true),
(L12,false)ν19: t2, 4, x=1,y=true
(L16,true), (L3,true),
(L12,false)
Figure 2: Fragment of the reachability tree of the multi-thre aded goto-program of Figure 1(b). Nodes with
dashed line represent program locations that violate the asserti on statement in line 18 of Figure 1(b).
despite the context-bounding, the RT and thus the num-
ber of interleavings can grow very quickly, and we need to
invoke the SMT solver several times to check the satisﬁabil-
ity of formula (1), which might slow down the veriﬁcation
process. However, there are several observations that make
this approach worthwhile. First, if the program contains any
errors at all, they will often be exhibited in a substantial
fraction of the interleavings (cf. [23] for experience on real
applications), so that in practice we only need to explore a
small part of the search space until we ﬁnd the ﬁrst error.
In our running example, the invariant x= 1 does not hold
for the two nodes ν10andν18and if we traverse the RT
depth-ﬁrst and left-to-right, the error already shows up in
the third interleaving. Second, we do not need to actually
build the entire RT; instead, we only keep in memory nodes
on computation paths that are still unexplored and expand
them one path at a time. We then construct the VC for the
chosen computation path and feed it into the SMT solver to
check for satisﬁability. Third, and most important, we can
leverage the optimizations from the CBMC front-end (e.g.,
constant propagation and folding) to exploit which transi-
tions are enabled in a given state to drive the exploration of
the interleavings and to reduce both the number of interleav-
ings to be explored and the size of the formulas sent to the
SMT solver. For example, if we continue to explore thread
t1from nodeν1, the front-end exploits the fact that x= 1 to
infer that the guard in line 4 holds. t1thus continues in line
6, and terminates, so that the exploration continues with a
context switch to thread t2, as shown in node ν2.
In summary, the lazy approach guides the symbolic ex-
ecution between the threads and systematically explore all
the possible interleavings in a lazy way. This approach can
ﬁnd bugs fast, but as the front-end invokes the SMT solver,
once for each possible computation path, it can suﬀer perfor-
mance degradation, in particular for correct programs where
we explore all possible interleavings.
3.3 ScheduleRecordingApproach
State-of-the-art SMT solvers are built on top of eﬃcientSAT solvers to speed up the performance on large prob-
lems by exploiting the support for conﬂict clauses and non-
chronological backtracking. In the schedule recording ap-
proach we leverage this and avoid invoking the SMT solver
repeatedly. We build the RT as before to systematically ex-
plore the interleavings, but we now add schedule guards [17]
to record in which order the scheduler has executed the pro-
gram. Figure 4 shows how schedule guards are added to the
program during the exploration of the left-hand side of the
RT in Figure 2. We then encode all interleavings into a single
formula, which is ﬁnally passed to the SMT solver.
L2: (t1, #0) 
L7: (t2, #0)
L3: (t1, #1)
ts1==1 -> x = x+1
L9: (t2, #2)
ts2==2 -> x = x+1
L10: (t2, #3)
ts3==2 -> y = x>1
L12: (t2, #4)
ts4==2 -> x = x-1L9: (t2, #2)
ts2=2 -> x = x+1
L5: (t1, #3)
ts3==1 -> x = x-1
L10: (t2, #4)
ts4==2 -> y=x>1L10: (t2, #3)
ts3==2 -> y = x>1
L5: (t1, #4)
ts4==1 -> x = x-1
L12: (t2, #5)
ts5==2 -> x = x-1L12: (t2, #4)
ts4==2 -> x = x-1
Figure 4: Schedule recording applied to the left-
hand side of the RT in Figure 2.
Since control-ﬂow tests cannot inﬂuence the state, we only
need to add guards to eﬀective statements , i.e., assignments
and assertions. Similarly, we only need to record eﬀective
context switches (ECS), i.e., context switches to an eﬀective
statement. Each eﬀective program statement is then preﬁxed
by a schedule guard tsi=jwheretsiis the thread selection
variable for the i-th ECS and jis the thread identiﬁer. Its335intuitive interpretation is that the statement can only be
executed if thread jis scheduled to run after the i-th ECS.
For example, the schedule guard ts1= 1 atL3encodes that
x=x+1 can only be executed if t1runs after the ﬁrst ECS.
The schedule guards are added when program statements
are executed symbolically and become part of the produced
VCs. They can be derived from the RT nodes, i.e., for node
νiwe construct the guard tsCi=Ai. The thread selection
variables are free variables that the SMT solver will instan-
tiate with concrete values. The instantiation of all thread se-
lection variables corresponds to the choice of a speciﬁc inter-
leaving. In our example, if the SMT solver chooses ts1= 1,
ts2= 2,ts3= 2, andts4= 2, then the model checker
simulates the eﬀect of executing the program statements at
L3,L9,L10, andL12(in that order). Note that the ordering
of statements within a thread is of course still ensured by
the program order semantics, so that program statement at
L10will not be executed before program statement at L9.
We further deﬁne a schedule SCH to determine which in-
terleavings are considered and encode the guards in (2) as:
ψk=constraints/bracehtipdownleft /bracehtipupright/bracehtipupleft /bracehtipdownright
I(s0)∧R(s0,s1)∧...∧R(sk−1,sk)∧property/bracehtipdownleft/bracehtipupright/bracehtipupleft/bracehtipdownright
¬φk
∧scheduler/bracehtipdownleft /bracehtipupright/bracehtipupleft /bracehtipdownright
SCH (s0)∧...∧SCH (sk) (2)
HereSCH (si) represents a constraint on the schedule guard
of statesi. If we do not add any constraints, then we formu-
late/logicalandtextk
i=0SCH (si) =true and all possible interleavings are
considered. However, if we want to apply aggressive reduc-
tions (for example by exploiting the proofs of unsatisﬁability
as described in the next subsection), we can add constraints
toSCH to force the removal of interleavings that do not
contribute to checking a given property. Although, we can
bound the number of preemptions and exploit which transi-
tions are enabled in a given state when we build formula (2),
the number of threads and context switches can still grow
very large quickly, and easily “blow-up” the solver.
3.4 UWApproach
The core idea of the under-approximation and widening
(UW) approach is to check models with an increasing set
of allowed interleavings [15]. We start from an underap-
proximation describing a single interleaving and widen the
model by adding more interleavings incrementally based on
the proof objects generated from an SMT solver [10]. We
deﬁneψ′as an underapproximated model of ψ, i.e.,ψ′=
ψ∧SCH (s0)∧...∧SCH (sk), where we introduce constraints
on the schedule guards. We can see that if ψis unsatisﬁable,
thenψ′is also unsatisﬁable; however, it is possible that ψ
is satisﬁable while ψ′is not, due to the constraints on the
schedule. Thus, ψ′can be thought of as an underapprox-
imation of ψand each satisfying assignment of ψ′is also
a satisfying assignment to ψ. The main steps of the UW
algorithm are shown in Figure 5.
The additional literals clijintroduce constraints on the
schedule guards (e.g., clij→tsi=j), which allow us to
guide the widening process according to the variables that
participate in the proof of unsatisﬁability produced by the
SMT solver. This means that the schedule is now updated
based on the information extracted from the proof, which
aims to remove interleavings that are not relevant for check-
ing a given property [15, 19]. Note that the way that we en-Step 1: Add control literals clij(whereiis the ECS number
andjis the thread identiﬁer) to the VC ψk.
Step 2: Add negated control literals ¬clijto the schedule
SCH, except those enabling the ﬁrst interleaving.
Step 3: Check satisﬁability of ψk; ifψkis satisﬁable, then
terminate with “error”.
Step 4: Check whether the proof objects generated by the
SMT solver contains any control literals; if not terminate
with “no error”.
Step 5: Remove literals that are contained in the proof
objects from the schedule SCH and go to step 3.
Figure 5: Algorithm of the UW approach.
code the underapproximation diﬀers from [15]. The authors
in [15] encode an underapproximation using m×ncontrol
literals, where mis the number of control points that guard
each program statement and nis the number of processes.
In our encoding, we use e×ncontrol literals, where eis
the number of ECS (with e≤m) andnis the number of
threads. If we were to include a control literal for each state-
ment as in [15], then our solution might not scale in practice
to large multi-threaded software systems.
4. MODELLINGSYNCHRONIZATION
PRIMITIVESINPTHREAD
This section presents our modelling of the synchronization
primitives of the Pthread library [20]. We assume that the
library function implementations are correct and focus our
eﬀort on verifying only the client programs that use them.
We thus provide an instrumented model of the Pthread func-
tions and use this to model check the client code.
4.1 ModellingMutexLockingOperations
The Pthread library supports two functions to implement
mutual exclusion between threads, pthreadmutexlockand
pthreadmutexunlock . Both functions take as argument a
data structure called mutex that has two states, “locked”
and “unlocked”. pthreadmutexlock locks the mutex if it
is unlocked; otherwise it blocks the current thread until
the mutex is unlocked and can successfully be locked again.
pthreadmutexunlock simply unlocks a locked mutex. Com-
putation paths are blocked on a mutex when a thread tries
to lock a mutex that has already been locked by another
thread. As an example, consider the threads tAandtB,
which both lock and unlock the same mutex m, as shown
in Figure 6. The paths A0;A1;B0;B1andB0;B1;A0;A1
are non-blocking or wait-free while the other two paths are
blocked.
A0A1
B0
B1B0
A0B0
A0 A1B1
A1
B1START_THREAD
A0: lock(*m)
A1: unlock(*m)
END_THREADSTART_THREAD
B0: lock(*m)
B1: unlock(*m)
END_THREAD
Figure 6: Computation paths blocking on a mutex.
A strategy to model mutex operations based on the notion
of wait-free paths was proposed in [24, 25]. Instead of block-
ing the computation paths starting with A0;B0andB0;A0,336they are simply ignored by modelling pthreadmutexlockas
atomic {assume (∗m== 0); ∗m= 1}, where the statement
assume (∗m== 0) cuts oﬀ subsequent paths if the mutex is
already locked. pthreadmutexunlock is then modelled as
atomic {assert (∗m== 1); ∗m= 0}, which simply checks if
the mutex is already locked. If so, the lock is released; oth-
erwise, a thread tries to unlock a mutex that has not been
locked previously, and we have detected an error.
This is suﬃcient to ﬁnd bugs related to data races and lock
acquisition ordering, but not to detect local and global dead-
locks [24, 25]. We thus model pthreadmutexlock in such
a way that we can detect global and local deadlock caused
by the wrong use of the mutexes; pthreadmutexunlock
remains unchanged. For this, we ﬁrst need to look in more
detail at the diﬀerent possible states that our model allows
for a thread: (i) Join state: the thread is waiting for another
thread to terminate; (ii) Lock state: the thread is waiting
for a mutex to be unlocked; (iii) Wait state: the thread is
waiting for a signal or broadcast to wake up; (iv) Exit state:
the thread has already exited; (v) Free state: the thread is
not in any of the above four states and is free to execute its
instructions. A thread is blocked if it is in one of the join,
lockorwait states, and is supposed to be running if it is not
inexitstate. Global deadlock occurs when all threads wait
for a mutex and a local deadlock occurs when some of the
threads form a waiting cycle. In both cases, we can detect
the deadlock if there is no running thread in the free state,
i.e., the number of blocked threads is equal to the number of
running threads. Figure 7 presents our modelling to detect
global and local deadlock with mutexes, which maintains
counts on both blocked and running threads with global
variables.
1int pthread mutex lock ( pthread mutex t∗m){
2extern uint t r d s i nr u n , c l o c k =0;
3 atomic {
4 unlocked = ( m u t e x l o c k f i e l d ( ∗m)==0);
5 i f( unlocked ) m u t e x l o c k f i e l d ( ∗m) = 1 ;
6 else cl o c k = c l o c k + 1 ;
7 }
8 atomic {
9 i f( m u t e x l o c k f i e l d ( ∗m)==0)
10 cl o c k = c l o c k −1 ;
11 i f( ! unlocked ) {
12 deadlock mutex = ( c lock<t r d s i nr u n ) ;
13 assert ( deadlock mutex ) ;
14 assume ( ! deadlock mutex ) ;
15 }
16 }
17 return 0 ;
18}
Figure 7: Modelling mutex lock operation.
mutexlockfield retrieves the state of the mutex. We also
use the variable clockto count the number of threads that
are in the lock state due to mutex m, andtrdsinrunto
count the number of threads that are currently running.
Initially, the mutex is unlocked and we only lock it after
the ﬁrst call to pthreadmutexlock. In subsequent calls,
we increase the value of the variable clock, allow context
switches, check if the mutex mwas unlocked, and then as-
sertclock < trds inrun. If the assertion fails, a deadlock
was detected: a thread is blocked by a lock operation on a
mutex and the required mutex never gets unlocked by the
thread that owns it, either because the locking thread has
exited or because it has been blocked by another operation.If the assertion holds, we then eliminate this execution as
described above.
4.2 ModellingConditionalWaiting
We model functions pthread cond wait,pthread cond signal ,
andpthread cond broadcast from the Pthread library that
implement conditional waiting. All functions take as argu-
ment a condition variable cthat has also two states, “locked”
and “unlocked”; pthread cond wait also takes a mutex ar-
gument. Our modelling of the conditional waiting opera-
tion again employs the notion of wait-free execution paths.
pthreadcondwait is used to block the thread on a condi-
tion variable; the blocked thread is woken up only if an-
other thread calls signal or broadcast. If several threads are
blocked on a condition variable, then pthreadcondsignal
non-deterministically unblocks at least one of them while
pthreadcondbroadcast unblocks all threads blocked on the
speciﬁed condition variable.
Figure 8 shows our modelling for the wait-operation. We
use the variable cwait to count the number of threads that
are in the wait state due to condition c. Whenever a thread
callspthreadcondwait, we atomically lock the condition
variablec, assert that the mutex mis currently locked, re-
lease the mutex (so that other threads that access it can
make progress), and then increment the number of threads
in wait state (i.e., threads that are waiting for a signal or
broadcast to wake up). We then allow context switches be-
fore we check whether the number of threads in wait state is
less than the total number of the threads that are currently
running with the assertion cwait<trds inrun. If the as-
sertion holds or the variable cis locked, we simply eliminate
this execution as described above.
1int pthread cond wait ( pthread cond t∗c ,
2 pthread mutex t∗m){
3extern uint t r d s i nr u n , c wait =0;
4 atomic {
5 c o n d l o c k f i e l d ( ∗c ) = 1
6 assert ( m u t e x l o c k f i e l d ( ∗m) )
7 m u t e x l o c k f i e l d ( ∗m) = 0
8 cwait = c wait + 1
9 }
10 atomic {
11 deadlock wait = ( c wait<t r d s i nr u n )
12 assert ( deadlock wait ) ;
13 assume ( ! deadlock wait
14 | |c o n d l o c k f i e l d ( ∗c )==0);
15 cwait = c wait −1
16 }
17 m u t e x l o c k f i e l d ( ∗m) = 1
18 return 0 ;
19}
Figure 8: Modelling conditional waiting operation.
To model signal-operations, we simply release the condi-
tion variable, i.e., c= 0. To model broadcast-operations, we
create a global variable called broadcastid, which records
the number of broadcast operations that have executed and
which gets incremented inside pthreadcondbroadcast . In
the wait-operation, the thread records the current value of
broadcastidbefore it is forced to make context switches to
other threads. When the context is switched back to the
current thread, an assertion checks if a broadcast opera-
tion has occurred by checking whether the current value of
broadcastidis greater than the recorded value. The dead-
lock is detected if there is no path with broadcast operations.3375. EXPERIMENTALEVALUATION
We have implemented the lazy, schedule recording, and
UW approaches described in Section 3 in our ESBMC tool
that supports the SMT logics QF AUFBV and QF AUFLIRA
as speciﬁed in the SMT-LIB [27]. In our experiments, we
have used ESBMC v1.15.1 together with Z3 v2.11 [10], which
was the most eﬃcient SMT solver in our previous exper-
iments [8]. ESBMC and the benchmarks are available at
http://users.ecs.soton.ac.uk/lcc08r/esbmc/ . All exper-
iments were conducted on an otherwise idle Intel Pentium
Dual CPU with 4 GB of RAM running Windows and Linux
OS respectively. For all benchmarks, the time limit has been
set to 3600 seconds to check all properties at once. All times
given are wall clock time in seconds as measured through
a single execution. In our experiments, we chose CHESS
v0.1.30626.0 [21] and SATABS v2.5 [6] as two of the most
widely used veriﬁcation tools.
5.1 ComparisontoCHESS
CHESS is a concurrency testing tool for C# programs.
It implements iterative context-bounding and explores the
various thread schedules deterministically [21]. CHESS re-
quires idempotent unit tests that it repeatedly executes in
a loop, exploring a diﬀerent interleaving on each iteration.
In this respect, it is similar to our lazy approach; however,
CHESS is a purely dynamic, test-based tool and originally
employed a stateless search technique, but its latest version
(v0.1.30626.0) performs state hashing based on a happens-
before graph to avoid exploring the same state repeatedly.
Table 1 shows the detailed results of the comparison be-
tween ESBMC and CHESS on a 2GHz machine. reorder ,
twostage , and wrong lock are diﬀerent versions of a read-
er/writer program [26]. The numbers ( x,y) indicate that
we have xinstance(s) of thread tsetandyinstance(s) of
threadtreader . According to [26], increasing the number of
instances of a given thread while keeping constant the num-
ber of instances of the other thread, substantially increases
the “semantic hardness” of the error discovery. Note that all
these benchmarks only check for a single, violated property.
micro is a synthetic micro-benchmark [14] which checks a
single valid property. It is used to check the scalability of
multi-threaded software veriﬁcation tools. The number in
brackets indicates the total number of visible statements on
each thread. In the table, Lis the size of the code (in lines),
andTthe total number of threads. Bis the number of BMC
unrolling steps for each loop, while Cis the context switch
bound. Except for reorder 6bad,Cis set to the minimum
number of context switches required to expose the error.
Time is the time in seconds until the error is found; time-
outs are denoted by TO. For ESBMC, Iis the total number
of generated interleavings, while FIis the total number of
failed interleavings. The column itergives the number of it-
erations required to prove or disprove the property in the
UW approach. For CHESS, Tests reports the approximate
number of tests executed, which is not related to the number
of interleavings. Both tools identify the property violation
(resp. conﬁrm that it holds) in all cases where they do not
run out of time or memory.
As we can see in Table 1, CHESS is eﬀective for programs
where there are a small number of threads, but it does not
scale that well and consistently runs out of time when we in-
crease the number of threads. In general, CHESS times out
when the number of threads increases beyond six. The rela-tively poor scalability of CHESS has already been observed
by [26]. In contrast, our lazy algorithm is able to ﬁnd bugs
quickly even when we increase the number of threads and
the context bound, and consistently outperforms CHESS as
well as the schedule recording and UW approaches. How-
ever, note that it runs out of memory for test cases 16 and
18 when we increase the number of context switches to 18
and 13 respectively.
5.2 ComparisontoSATABS
SATABS is an ANSI-C model checker which supports the
veriﬁcation of multi-threaded software with shared variables
using the CEGAR technique. We compare our approaches
against SATABS v2.5 [6] based on Cadence SMV using a
number of multi-threaded programs taken from standard
benchmark suites. Table 2 shows the results achieved on a
3Ghz machine. Programs that end on “bad” contain an error
(i.e., at least one of the properties is satisﬁable) while those
that end on “ok” are correct. Here, #P gives the number of
properties to be veriﬁed for each program, which includes
array bounds, pointer safety, division by zero, deadlock and
order violations checks. A context bound of ∞means that we
did not specify a bound. A “-” result indicates that the tool
failed with an error such as internal ( †) and reﬁnement (RF)
failure, memory overﬂow (MO), time-out (TO), or failed to
detect errors in the program. A “+” indicates that the tool
detected the error or proved all VCs.
Programs 1-6 are concurrent implementations of stack,
queue, and circular buﬀer data structures; programs 1 and
2 are extracted from an embedded application [7]. Programs
7-14 are from the INSPECT benchmark [29] and use mutex
and condition synchronization primitives from the Pthread
library. Programs 15-17 are from the VV-lab benchmarks [26]
and contain common concurrency bugs such as data races,
atomicity and order violations. Programs 18-20 are embed-
ded applications that run on a dual core processor; they
are implemented in a commercial set-top box product from
NXP semiconductors [22]. Program 21 is the same synthetic
micro-benchmark described in Section 5.1, but here we in-
crease further the number of context switches to check the
scalability of our approaches.
As we can see in Table 2, SATABS produces reﬁnement
failures (RF) for most programs. These programs contain
linear arithmetic operations with arrays and the predicate
abstraction technique implemented in SATABS seems to suf-
fer from a lack of precision when dealing with arrays. How-
ever, the ability of a veriﬁcation tool to check such programs
is particularly important as many real-world multi-threaded
programs belong to this class. SATABS also times out for
large programs or for programs with many threads (cf. pro-
grams 7, 8, 9, 13, and 21). Additionally, SATABS gives false
positives on programs 14-16, which contain known bugs re-
lated to data races, atomicity and order violations. Note that
SATABS uses predicate abstraction and reﬁnement, and in
some sense tries to solve a harder problem than BMC. How-
ever, the results in Table 2 indicate that this problem may
still be too hard for multi-threaded applications, as SATABS
is unable to prove the required properties.
We can also see in Table 2 that if the program contains
errors at all, these errors indeed generally occur in most in-
terleavings explored; consequently, the lazy approach is very
fast for these cases. The notable exception is wronglock bad,
where less than 0.1% of the interleavings expose the error338CHESS Lazy Schedule UW
Test Program #L #T BC
Time
Tests
Time#FI / #I
Time
Time
Iter
1reorder 3bad (2,1) 84 3 34 1 200 <1 1/29 <1<14
2reorder 4bad (3,1) 84 4 45 98 13000 <1 1/82 1 45
3reorder 5bad (4,1) 84 5 56TO 429000 <1 1/277 4 18 6
4reorder 6bad (5,1) 84 6 67TO 396000 <1 1/853 36 72 7
5reorder 6bad (5,1) 84 6 68TO 371000 <1 1/2810 225 592 7
6reorder 6bad (5,1) 84 6 69TO 367000 <1 1/8124 MO MO 1
7twostage 3bad (2,1) 128 3 34 4 500 1 1/35 1 35
8twostage 4bad (3,1) 128 4 44215 27000 2 1/42 1 45
9twostage 5bad (4,1) 128 5 54TO 384000 2 1/44 1 55
10twostage 6bad (5,1) 128 6 64TO 366000 2 1/45 2 55
11wronglock 4bad (1,3) 110 4 48 21 3000 5 2/489 10 89 9
12wronglock 5bad (1,4) 110 5 58724 93000 10 3/2869 50 408 9
13wronglock 6bad (1,5) 110 6 68TO 356000 18 4/12106 225 2060 9
14wronglock 7bad (1,6) 110 7 78TO 330000 34 5/39100 MO MO 1
15micro 2ok (100) 247 2 12316 35855 <1 0/4 <1<11
16micro 2ok (100) 247 2 117 TO 400000 1095 0/131072 MO MO 1
17micro 3ok (100) 365 3 12TO 272000 <1 0/9 <1<11
18micro 3ok (100) 365 3 112 TO 290000 1021 0/121393 MO MO 1
Table 1: Results of the comparison between ESBMC (v1.15.1) and C HESS (v0.1.30626.0).
SATABS Lazy Schedule UW
Test Program #L #T #P B C
Time
Result
Time
Result#FI / #I
Time
Result
Time
Result
Iter
1circular buﬀer ok [7] 111 2 9 8∞ †− 477 + 0/12870 MO − MO −1
2circular buﬀer bad [7] 109 2 8 8 5 †−<1+ 3/32 2+ 11+6
3queue ok [9] 147 2 12 41 ∞ RF − 3+ 0/6 3+ 3+1
4queue bad [9] 153 2 15 41 8 †− 3+ 91/256 50+ 373 +7
5stack ok [9] 105 2 5 11 12 †− 225 + 0/4094 1026 +1097 +1
6stack bad [9] 106 2 6 11 4 RF −<1+ 4/16 2+ 6+4
7fsbench ok [29] 81 26 47 26 2 †− 252 + 0/676 304 + 301 +1
8fsbench bad [29] 80 27 48 27 2 †−<1+ 729/729 360 + 786 +2
9indexer ok [29] 77 13 21 129 4 TO − 595 + 0/17160 220 + 218 +1
10stateful20 ok [29] 60 2 3 20 10 †− 95 + 0/1024 487 + 518 +1
11sync02 ok [29] 74 2 6 21 21 RF − 44 + 0/121 60+ 60+1
12sync02 bad [29] 74 2 6 21 21 RF − 8+ 5/186 132 + 383 +3
13aget-0.4 bad [29] 1233 3 279 200 23346 + 137 + 1/1 127 + 125 +1
14bzip2smp ok [29] 6366 38568 1 9 TO −1800 + 0/1294 MO − MO −1
15reorder 10bad (9,1) [26] 84 10 7 10 11 1−<1+1/154574 MO − MO −1
16twostage 100bad (99,1) [26] 128 100 13 100 4 2− 88+ 1/139 93+ 195 +5
17wronglock 8bad (1,7) [26] 110 8 8 8 8 2− 90+6/104015 MO − MO −1
18exStbHDMI ok [22] 1060 2 24 16 20 TO + 229 + 0/1 226 + 213 +1
19exStbLED ok [22] 425 2 45 10 10 RF − 73 + 0/11 73+ 787 +1
20exStbThumbs bad [22] 1109 2 249 2 1 317 + 95+ 3/3 14+ 12 +1
21micro 10ok (100) [14] 1171 10 10 117 TO − 254 + 0/29260 MO − MO −1
Table 2: Results of the comparison between SATABS (v2.5) and ESB MC (v1.15.1).
and SATABS is substantially faster than ESBMC (but fails
to ﬁnd the error); however, even here the lazy approach out-
performs both the schedule recording and UW approaches.
Similarly, the lazy approach is capable of handling safe pro-
grams in which the number of threads and context switches
grows quickly, which makes the formula harder and often
“blows up” the SMT solver. The UW approach is typically
slower than schedule recording. We suspect that the proof
generation of the SMT solver (which is required to produce
the unsatisﬁable cores) causes memory overhead and corre-
sponding slowdowns; this was also reported previously [11].
6. RELATEDWORK
SMT-based BMC is gaining popularity in the formal veri-
ﬁcation community [10]. However, most work focuses on se-
quential software, uses only restricted sets of theories (e.g.,
integer and real arithmetic) that do not precisely reﬂect the
ANSI-C semantics [12] or does not address important lan-guage constructs [1].
Cimatti et al. [4] describe an approach to verify SystemC
that similarly combines explicit state space exploration (i.e.,
the explicit exploration of the diﬀerent possible interleav-
ings) with symbolic model checking (i.e., the symbolic rep-
resentation and updates of the state). However, we use BMC
instead of predicate abstraction, and we implement a real-
istic scheduler, i.e., our scheduler may preempt a thread at
any visible instruction in its execution, whereas [4] encodes
the semantics of the non-preempting SystemC scheduler. We
also exploit the SMT techniques on large problems by en-
coding all possible interleavings into a single formula.
Qadeer and Rehof present a pragmatic method to discover
bugs in concurrent software in which the program analysis
is restricted to executions with a bounded number of con-
text switches [23]. However, they do not apply it to realis-
tic concurrent software benchmarks and the integration of
the context-bounded algorithm into the explicit state model339checker ZING is left for future work. Rabinovitz and Grum-
berg describe an extension of CBMC to concurrent C pro-
grams [25], which translates each C thread individually into
SSA form and adds constraints for a bounded number of
context-switches, as in [23]. This approach, however, is lim-
ited to two threads, and requires the user to run CBMC
twice in order to detect diﬀerent types of bugs (“regular”
and concurrency bugs). It is also only evaluated on a con-
current bubblesort, but not on a set of realistic applications.
Ganai and Gupta describe a lazy method for modelling
multi-threaded concurrent systems using shared variables [13],
but this again is restricted to two threads. Gupta et al. [17]
extend [13, 16] by supporting more than two threads and
by combining dynamic partial order reduction with sym-
bolic state space exploration. The benchmarks that have
been reported are a parameterized version of the dining
philosophers model, which are untypical multi-threaded C
programs. Grumberg et al. propose an algorithmic method
based on SAT and BMC to model check a multi-process
system based on a series of under-approximated models [15].
This approach, however, does not integrate context-bounded
analysis and it does not address the problem of model check-
ing multi-threaded C software.
7. CONCLUSIONSANDFUTUREWORK
We have presented the lazy, schedule recording, and UW
algorithms to model check multi-threaded ANSI-C software
with shared variable communication between the threads.
We have also presented our modelling of the synchroniza-
tion primitives of the Pthread library that allows us to de-
tect not only atomicity and order violations, but also local
and global deadlock, that previous attempts are unable to
ﬁnd [13, 16, 17, 25]. Surprisingly, our approach to check con-
straints lazily is extremely fast for programs that contain
errors and to a lesser extent even for safe programs in which
the number of threads and context switches grows quickly.
The experimental results also show that the lazy approach
generally outperforms not only the schedule recording and
UW approaches, but also CHESS [21] and SATABS [6] tools
on several non-trivial benchmarks. As far as we are aware,
there is no other work that considers a comprehensive SMT-
based BMC procedure to verify multi-threaded ANSI-C soft-
ware by combining symbolic model checking with explicit
state space exploration. In future, we plan to explore the
use of Craig interpolants to prove non-interference of con-
text switches, and to develop an eﬃcient method on top of
ESBMC to localize faults in multi-threaded programs.
8. REFERENCES
[1] A. Armando, J. Mantovani, and L. Platania. Bounded
model checking of software using SMT solvers instead
of SAT solvers. STTT , vol. 11 (1), pp. 69–83, 2009.
[2] C. Baier and J.-P. Katoen. Principles of Model
Checking . MIT Press, 2008.
[3] A. Biere. Bounded model checking. In Handbook of
Satisﬁability , pp. 457–481. 2009.
[4] A. Cimatti et al. Verifying SystemC: a software model
checking approach. FMCAD , 2010.
[5] E. Clarke, D. Kroening, and F. Lerda A tool for
checking ANSI-C programs. TACAS ,LNCS 2988, pp.
168–176, 2004.
[6] E. Clarke, D. Kroening, N. Sharygina, and K. Yorav
SATABS: SAT-based predicate abstraction forANSI-C. TACAS ,LNCS 3440, pp. 570–574, 2005.
[7] L. Cordeiro et al. Agile development methodology for
embedded systems: A platform-based design
approach. ECBS , pp. 195–202, 2007.
[8] L. Cordeiro, B. Fischer, and J. Marques-Silva.
SMT-based bounded model checking for embedded
ANSI-C software. ASE, pp. 137–148, 2009.
[9] T. H. Cormen et al. Introduction to algorithms .
Second edition, 2001.
[10] L. M. de Moura and N. Bjørner. Z3: An eﬃcient SMT
solver. TACAS ,LNCS 4963, pp. 337–340, 2008.
[11] L. M. de Moura and N. Bjørner. Proofs and
refutations, and Z3. In LPAR Workshops, 2008.
[12] M. K. Ganai and A. Gupta. Accelerating high-level
bounded model checking. ICCAD , pp. 794–801, 2006.
[13] M. K. Ganai and A. Gupta. Eﬃcient modeling of
concurrent systems in BMC. SPIN ,LNCS 5156, pp.
114–133, 2008.
[14] N. Ghafari, A. Hu, and Z. Rakamaric.
Context-bounded translations for concurrent software:
An empirical evaluation. SPIN ,LNCS 6349, pp.
227–244, 2010.
[15] O. Grumberg et al. Proof-guided
underapproximation-widening for multi-process
systems. POPL , pp. 122–131, 2005.
[16] V. Kahlon et al. Semantic reduction of thread
interleavings in concurrent programs. TACAS ,LNCS
5505, pp. 124–138, 2009.
[17] V. Kahlon, C. Wang, and A. Gupta. Monotonic
partial order reduction: An optimal symbolic partial
order reduction technique. CAV,LNCS 5643, pp.
398–413, 2009.
[18] A. Lal and T. Reps. Reducing concurrent analysis
under a context bound to sequential analysis. Form.
Methods Syst. Des. , 35(1):73–97, 2009.
[19] K. L. McMillan and N. Amla. Automatic abstraction
without counterexamples. TACAS ,LNCS 2619, pp.
2–17, 2003.
[20] F. Mueller. A library implementation of posix threads
under unix. USENIX , pp. 29–41, 1993.
[21] M. Musuvathi and S. Qadeer. Iterative context
bounding for systematic testing of multithreaded
programs. PLDI , pp. 446–455, 2007.
[22] http://www.nxp.com/, 2009.
[23] S. Qadeer and J. Rehof. Context-bounded model
checking of concurrent software. TACAS ,LNCS 3440,
pp. 93–107, 2005.
[24] S. Qadeer and D. Wu. Kiss: keep it simple and
sequential. In PLDI , pp. 14–24, 2004.
[25] I. Rabinovitz and O. Grumberg. Bounded model
checking of concurrent programs. CAV,LNCS 3576,
pp. 82–97, 2005.
[26] N. Rungta and E. G. Mercer. Clash of the titans:
tools and techniques for hunting bugs in concurrent
programs. PADTAD , pp. 1–10, 2009.
[27] SMT-LIB. The Satisﬁability Modulo Theories Library .
http://combination.cs.uiowa.edu/smtlib, 2009.
[28] S. L. Torre, P. Madhusudan, and G. Parlato. Reducing
context-bounded concurrent reachability to sequential
reachability. CAV, LNCS 5643, pages 477–492, 2009.
[29] http://www.cs.utah.edu/, 2010.340