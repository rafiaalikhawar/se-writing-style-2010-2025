See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/234842625
A tactic-centric approach for automating traceability of quality concerns
Conf erence Paper    in  Proceedings - Int ernational Conf erence on Softw are Engineering  · June 2012
DOI: 10.1109/IC SE.2012.6227153
CITATIONS
97READS
351
4 author s, including:
Mehdi Mir akhorli
Association f or Computing Machiner y
107 PUBLICA TIONS    1,703  CITATIONS    
SEE PROFILE
Yonghee Shin
22 PUBLICA TIONS    1,658  CITATIONS    
SEE PROFILE
Jane Cleland-Huang
DeP aul Univ ersity
313 PUBLICA TIONS    8,765  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Mehdi Mir akhorli  on 14 F ebruar y 2019.
The user has r equest ed enhanc ement of the do wnlo aded file.A Tactic-Centric Approach for Automating Traceability of Quality Concerns
Mehdi Mirakhorli, Yonghee Shin, Jane Cleland-Huang, and Murat Cinar
School of Computing
DePaul University, Chicago, IL 60604
m.mirakhorli@acm.org, yshin@cdm.depaul.edu, jhuang@cs.depaul.edu, murat.cinar87@gmail.com
Abstract —The software architectures of business, mission, or
safety critical systems must be carefully designed to balance
an exacting set of quality concerns describing characteristics
such as security, reliability, and performance. Unfortunately,
software architectures tend to degrade over time as maintainers
modify the system without understanding the underlying archi-
tectural decisions. Although this problem can be mitigated by
manually tracing architectural decisions into the code, the cost
and effort required to do this can be prohibitively expensive.
In this paper we therefore present a novel approach for au-
tomating the construction of traceability links for architectural
tactics. Our approach utilizes machine learning methods and
lightweight structural analysis to detect tactic-related classes.
The detected tactic-related classes are then mapped to a Tactic
Traceability Information Model. We train our trace algorithm
using code extracted from ﬁfteen performance-centric and
safety-critical open source software systems and then evaluate it
against the Apache Hadoop framework. Our results show that
automatically generated traceability links can support software
maintenance activities while helping to preserve architectural
qualities.
Keywords -Architecture; traceability; tactics; traceability in-
formation models
I. I NTRODUCTION
Software traceability provides critical support for a broad
range of software engineering activities including impact
analysis, regression testing, and compliance veriﬁcation.
Unfortunately, the cost and effort required to establish and
maintain effective and accurate traceability links can be
inhibitively expensive [6], [16], often resulting in organi-
zations implementing only the minimal traceability needed
to comply to regulatory or process guidelines.
This problem is especially evident when it comes to
tracing quality concerns, which describe system level at-
tributes such as security, reliability, performance, and safety.
Such concerns are often addressed in the solution domain
through the strategic adoption of architectural tactics [5],
[20], [23], which we informally deﬁne as re-usable solutions
for satisfying a quality concern. A more formal deﬁnition is
provided by Bachman et al. who deﬁne a tactic as “a means
of satisfying a quality-attribute-response measure by manip-
ulating some aspects of a quality attribute model through
architectural design decisions” [4]. There are many different
kinds of tactics. For example, a system with high reliability
requirements might implement the heartbeat tactic [5] to
monitor availability of a critical component, or the votingtactic [5] to increase fault tolerance through integrating and
processing information from a set of redundant components.
Unfortunately, unless these architectural decisions are fully
documented, architectural knowledge can be lost over time
[12], [30], and as a result there is a tendency for system
quality to degrade as developers modify components without
fully understanding the underlying design decisions.
Current software engineering tools, practices, and sup-
porting traceability techniques contribute to this problem
through failing to make underlying design decisions and
their related quality concerns visible to software engineers
[7]. At the same time quality concerns tend to have a cross-
cutting impact on the solution, and can therefore affect nu-
merous components and exhibit complex interdependencies,
[20], [27]. This introduces a dilemma. On one hand it can
be difﬁcult and costly to trace quality concerns into the
architectural design, as the end result may involve creating
and maintaining an almost impossible number of traceability
links; but on the other hand, failing to trace architectural
concerns leaves the system vulnerable to problems such as
architectural degradation.
This paper therefore presents a novel and cost-effective
approach for tracing architecturally signiﬁcant concerns,
speciﬁcally those concerns which are implemented through
the use of common architectural tactics. The proposed
process involves the steps depicted in Figure 1. First, a tactic-
classiﬁer identiﬁes all classes related to a given tactic, and
then establishes tactic-level traceability through mapping
those classes to the relevant tactic. Second, a more ﬁnely-
tuned classiﬁer is used in conjunction with lightweight
structural analysis to identify the subset of classes which
play clearly deﬁned roles in the tactic. For example, in
the case of the heartbeat tactic, the classiﬁer attempts to
identify heartbeat emitter and heartbeat receiver roles, or
in the case of the voting tactic, it attempts to identify voting
coordinators andvoters . The detected tactic-related classes
are then mapped to tactic Traceability Information Models
(tTIMs) which anchor the traceability process and connect
the classiﬁed classes to a relevant set of design rationales,
requirements, and other related artifacts [26], [28].
The novel contribution of this work is twofold. First, it
introduces and evaluates a set of algorithms and processes
designed to automatically reconstruct traceability links for
architectural tactics. This builds on our prior work [26]–[28],978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 639Tactic- related 
code snippets  
Role -related 
classes  Indicator 
terms  
Role -related  
code snippets  Training Phase:  
Fine -Grained  
Classification 
Phase:  
Fine -Grained  
Lightweight 
structural  
analysis  Tactic- related 
classes  
Training Phase: 
Coarse -Grained  
System to 
be traced  
Classification 
Phase:  
Coarse -Grained  
Indicator 
terms  Identified classes mapped 
to proxies in tTIMs  
Trace 
matrix  Classes 
Classes Coarse -
grained: 
Class to tactic mapping 
Role  Grained: Class to tactic mapping Links generated, automatically from mappings  
Classes Code  
Code  Classes 
Links evaluated upon first -
use. Figure 1. An Overview of the Tactic-Related Trace Reconstruction Process
which required all traces to be created manually. Second, we
contextualize our work through an extended study showing
the use of architectural tactics in performance-centric, fault-
tolerant software systems.
The remainder of this paper is laid out as follows. Section
II provides a more detailed explanation of architectural
tactics, and introduces the concept of tactic Traceability In-
formation Models. Sections III, IV, and V describe our tactic
classiﬁer and the approach we took to identify tactic related
classes and their associated tactic roles. Section VI presents
a case study in which traceability links were automatically
reconstructed for tactics in the Apache Hadoop framework
and then used to support a simulated software maintenance
problem. The paper concludes with a discussion of threats
to validity, related work, and conclusions.
II. A RCHITECTURAL TACTICS
Architectural tactics come in many different shapes and
sizes and describe solutions for a wide range of quality con-
cerns [5]. For example, reliability tactics provide solutions
for fault mitigation, detection, and recovery; performance
tactics provide solutions for resource contention in order
to optimize response time and throughput, and security
tactics provide solutions for authorization, authentication,
non-repudiation and other such factors [18]. Table I depicts
the architectural tactics we identiﬁed through inspecting
the code and supporting documentation of 15 performance-
centric, fault-tolerant, open-source software systems. Our
analysis focused on 16 different tactics and clearly high-
lighted the pervasive nature of architectural tactics in the
examined systems.
A. Tactics Selected for Study
Due to the signiﬁcant cost and effort of manually con-
structing the ‘answer sets’ needed to evaluate our approachagainst non-trivially sized projects, we limited the work
described in this paper to the heartbeat ,scheduling ,resource
pooling ,authentication , and audit trail . These tactics were
selected because they represented a variety of reliability,
performance, and security concerns. The tactics are deﬁned
as follows [5]:
Heartbeat : One component emits a periodic heartbeat mes-
sage while another component listens for the message. The
original component is assumed to have failed if the heartbeat
fails. This tactic is used to achieve reliability goals.
Scheduling : Resource contentions are managed through
scheduling policies such as FIFO (First in ﬁrst out), ﬁxed-
priority, and dynamic priority scheduling.
Resource pooling : Limited resources are shared between
clients that do not need exclusive and continual access to
a resource. Pooling is typically used for sharing threads,
database connections, sockets, and other such resources.
Authentication : Ensures that a user or a remote system is
who it claims to be. Authentication is often achieved through
passwords, digital certiﬁcates, or biometric scans.
Audit trail : A copy of each transaction and associated iden-
tifying information is maintained. This audit information can
be used to recreate the actions of an attacker, and to support
functions such as system recovery and nonrepudiation.
B. Tactic Traceability Information Models
Our approach to tracing architectural tactics builds upon
the fundamental concept of tTIMs described in our earlier
work [28]. The tTIM concept emerged as a result of an
earlier study of tactical architectural decisions which we
conducted across a wide range of software intensive systems
including the Airbus A320/330/340 family, Boeing 777,
Boeing 7J7, NASA robots, and also performance centric
systems such as Google Chromium OS [24]. Each tTIM640Table I
ANANALYSIS OF TACTICS ACROSS SEVERAL OPEN-SOURCE PROJECTS
Fault tolerant, performance-centric software systems from SourceForge
Heartbeat
Scheduling
Authentication
Audit Trail
Resource Pool.
Active Repl.
Recovery
Passive Repl.
Authorization
Permiss. Check
CRC
Encryption
Process Monitor
Rem. Service
Fault Detection
V oting
1 RIFE: a Web application engine with support for content management. •••◦◦◦
2 Fault-Tolerant Corba: (OMG Document ptc/2000-04-04) ••••◦◦◦ ◦◦◦◦
3 CARMEN: Robot Control Software, with navigation capabilities • ◦◦
4 Rossume: an open-source robot simulator for control and navigation. ••• ◦◦
5 jworkosgi: implementation of the JMX and JMX Remote API into OSGI bundles. ••••◦◦◦◦◦
6 SmartFrog: Distributed Application Development Framework •••••◦◦◦ ◦
7 CarDamom: Real-time, distributed and fault-tolerant middleware ••••◦◦◦ ◦◦◦◦
8 ACLAnalyser: Tool suit to validate, verify and debug Multi Agent Systems •••• ◦ ◦
9 Jfolder: Web-based application development and management tool. ••• ◦
10 Enhydra shark: XPDL and BPMN Workﬂow Server ••••◦◦◦
11 Chat3: An instant messenger. •• ◦
12 ACE+TAO+CIAO: Framework for high-performance, distributed, real-time systems. •••◦◦◦◦◦◦
13 Google Chromium OS: •••••◦◦◦◦
14 x4technology tools: Framework Enterprise application software. •••◦◦
15 OpenAccountingJ: web-based Accounting/ERP system. •• ◦
Legend:•= Included in the code-snippet dataset and used for experiments described in this paper, ◦= For information purposes only
describes the elements needed to trace an individual archi-
tectural tactic back to its contribution structures (i.e. quality
goals, rationales, intents), and forward to the elements that
realize the tactic in both the design and the code. The tTIM
includes a set of roles describing the essence of the tactic,
a set of semantically typed links that deﬁne relationships
between pairs of artifacts, and a set of trace proxies which
provide mapping points for establishing traceability links.
The tactic itself is modeled as a set of interrelated roles.
For example, the heartbeat tactic, which is depicted in
Figure 2, includes the primary roles of receiver ,emitter , and
fault monitor . Additional roles, not shown in this ﬁgure but
described in our earlier work [28], include parameters such
as the heart beat rate and the heartbeat checking interval . In
this paper we focus only on the primary roles of each tactic.
In addition to roles, the tTIM also includes a set of reusable,
semantically-typed traceability links. These include internal
links such as/lessmuchsends pulse/greatermuchwhich deﬁne relationships
between roles in the tactic, as well as a set of external links
which are used to establish traceability to the code or the
design. Finally, the tTIM contains a set of trace proxies
which are used to transform the traceability task to a simple
mapping task. A developer or analyst has to simply map the
proxy onto one or more elements in the architecture and/or
code in order to establish traceability. Once these mappings
are accomplished, all of the traceability information embed-
ded in the tTIM is automatically inherited by the project.
As a result, tTIMs have been shown to reduce the cost and
effort of traceability [28].
Traceability can be established at different levels of
granularity [13]. Coarse-grained traceability links take less
effort to construct and maintain but provide less accurate
Quality  
Concern  Requirement  
(FR or NFR) 
Reliability  Availability  Rationale  
Heartbeat Tactic 
<<Component>> 
Heartbeat Emitter  
<<Component>> 
Heartbeat Receiver  
<<Component>> 
Fault Monitor  <<sends pulse>> 
<<monitors fault>> Code  
<<Proxy>> 
Heartbeat Emitter  
<<Proxy>> 
Heartbeat Receiver  
<<Proxy>> 
Fault Monitor  <<Tactic -Link>>  
<<Role- Link>>  
<<Role- Link>>  
<<Role- Link>>  Figure 2. Tactic Traceability Information Model for Heartbeat Tactic
information than ﬁner-grained links when actually used [11].
Our approach therefore supports traceability at either the
tactic level or the role-level, as depicted in Figure 2.
III. I DENTIFYING TACTIC -RELATED CLASSES
Although the tactic-detection problem may initially appear
to be a special case of design pattern recognition, it turns out
to be more challenging. Unlike design patterns which tend to
be described in terms of classes and their associations [15],
tactics are described in terms of roles and interactions [5].
This means that a single tactic might be implemented using
a variety of different design patterns or proprietary designs.641For example we observed the heartbeat tactic implemented
using (i) direct communication between the emitter and
receiver roles (found in Chat3 and Smartfrog systems) , (ii)
the observer pattern [15] in which the receiver registered as
a listener to the emitter found in the Amalgam system , (iii)
the decorator pattern [15] in which the heartbeat function-
ality was added as a wrapper to a core service (found in
Rossume and jworkosgi systems) , and ﬁnally (iv) numerous
proprietary formats that did not follow any speciﬁc design
pattern.
As a tactic is not dependent upon a speciﬁc structural for-
mat, we cannot use structural analysis as the primary means
of identiﬁcation. Our approach therefore relies primarily on
information retrieval (IR) and machine learning techniques
to train a classiﬁer to recognize speciﬁc terms that occur
commonly across implemented tactics, however we also use
light-weight structural analysis to support the differentiation
of speciﬁc tactic roles.
To classify classes according to various tactics we utilized
an algorithm that we had previously developed to detect non-
functional requirements (NFRs) [10] and to trace regulatory
codes [9]. Prior studies demonstrated that this algorithm
matched or outperformed standard classiﬁcation techniques
including the naive bayes classiﬁer, standard decision tree
algorithm (J48), feature subset selection (FSS), correlation-
based feature subset selection (CFS), and various combina-
tions of the above for the speciﬁc task of classifying NFRs
in the studied datasets [19].
The classiﬁer includes three phases of preparation, train-
ing, and classifying which are deﬁned as follows:
A. Preparation
All data is preprocessed using standard information re-
trieval techniques, and each class and/or tactic description
is transformed into a vector of terms.
B. Training
The training phase takes a set of preclassiﬁed code
segments as input, and produces a set of indicator terms
that are considered representative of each tactic type. For
example, a term such as priority , is found more commonly
in code related to the scheduling tactic than in other kinds of
code, and therefore receives a higher weighting with respect
to that tactic.
More formally, let qbe a speciﬁc tactic such as heart
beat. Indicator terms of type qare mined by considering
the set Sqof all classes that are related to tactic q. The
cardinality of Sqis deﬁned as Nq. Each term tis assigned a
weight score Prq(t)that corresponds to the probability that
a particular term tidentiﬁes a class associated with tactic q.
The frequency freq (cq, t)of term tin a class description c
related with tactic q, is computed for each tactic descriptionTable II
INDICATOR TERMS LEARNED DURING TRAINING
Tactic Name Document trained indicator
termsCode trained indicator
terms
Heartbeat heartbeat, fault, detect, mes-
sag, period, watchdog, send,
tactic, failur, alivheartbeat, ping, beat, heart,
hb, outbound, puls, hsr, pe-
riod, isonlin
Scheduling prioriti, schedul, assign,
process, time, queue, robin
higher, weight, dispatchschedul, task, prioriti, prcb,
sched, thread, , rtp, weight, tsi
Authentication authent, password, kerbero,
sasl, ident, biometr, veriﬁ,
prove, ticket, purportauthent, credenti, challeng,
kerbero, auth, login, otp, cred,
share, sasl
Resource Pooling thread, pool, number, worker,
task, queue, executor, creat,
overhead, minpool, thread, connect, spar-
row, nbp, processor, worker,
timewait, jdbc, ti
Audit Trail audit, trail, record, activ, log,
databas, access, action, moni-
tor, useraudit, trail, wizard, pwriter,
lthread, log, string, categori,
pstmt, pmr
inSq.Prq(t)is then computed as:
Prq(t) =1
Nq/summationdisplay
cq∈Sqfreq (cq, t)
|cq|∗Nq(t)
N(t)∗NPq(t)
NPq(1)
C. Classiﬁcation
During the classiﬁcation phase, the indicator terms com-
puted in Equation 1 are used to evaluate the likelihood
(Prq(c)) that a given class cis associated with the tactic
q. LetIqbe the set of indicator terms for tactic qidentiﬁed
during the training phase. The classiﬁcation score that class
cis associated with tactic qis then deﬁned as follows:
Prq(c) =/summationtext
t∈c∩IqPrq(t)
/summationtext
t∈IqPrq(t)(2)
where the numerator is computed as the sum of the term
weights of all type qindicator terms that are contained in
c, and the denominator is the sum of the term weights for
all type qindicator terms. The probabilistic classiﬁer for a
given type qwill assign a higher score Prq(c)to class c
that contains several strong indicator terms for q.
Classes are considered to be related to a given tactic qif
the classiﬁcation score is higher than a selected threshold.
IV. T ACTIC LEVEL LINKRECONSTRUCTION
The ﬁrst step of reconstructing tactic-related traceability
links utilizes the classiﬁer described in Equations 1 and
2 to detect classes that implement the targeted tactic. For
experimental purposes we investigated two different train-
ing methods. The ﬁrst method trained the classiﬁer using
textual descriptions of each tactic, while the second method
trained the classiﬁer using code snippets taken from classes
implementing each of the tactics.
A. Datasets
Two datasets were developed to support the task of
training and evaluating the tactic-grained classiﬁer.6420 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Scheduling 
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Resource Pooling  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Heartbeat  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Audit Trail  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Authentication  
0.001 0.005 0.01 0.05 0.1 Term thresholds  (a) Trained using Tactic Descriptions
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Scheduling 
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Resource Pooling  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Heartbeat  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Audit Trail  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Authentication  
0.001 0.005 0.01 0.05 0.1 Term thresholds  
(b) Trained using Code Snippets from Tactics implemented in Open Source Systems
Figure 3. Results for Coarse-Grained Detection of Tactic-related Classes at various Classiﬁcation and Term Thresholds for ﬁve Different Tactics
1)Tactic Descriptions Dataset :For each of the ﬁve
targeted tactics i.e. heartbeat ,resource pooling ,scheduling ,
audit trail , and authentication , we retrieved ten descriptions
of tactics taken from text books, online descriptions, and
publications. For training purposes, the dataset also included
20 descriptions of non-tactic-related IT documents. The
following text provides an excerpt from a tactic description
for the audit trail tactic:
A record showing who has accessed a computer system and
what operations he or she has performed during a given
period of time. Audit trails are useful both for maintaining
security and for recovering lost transactions.....
2)Code Snippets Dataset :For each of the ﬁve targeted
tactics we identiﬁed 10 different open-source projects, or
parts of a large project, in which the tactic was implemented.
For each of these projects we retrieved code segments
that were closely related to the tactic. We also retrieved
four additional non tactic-related classes for training and
testing purposes. The following code represents two methods
extracted from a code snippet for the audit tactic.
public boolean isAuditUserIdentifyPresent(){
return(this.auditUserIdentify != null);
}
public BigDecimal getAuditSequenceNumber(){
return this.auditSequenceNumber;
}
B. Experiments
Experiments were conducted to determine whether the
classiﬁcation method described in Equations 1 and 2 could
be used to identify tactic-related classes for the ﬁve targeted
tactics, and also to determine whether the tactic descriptions
or the code snippets produced better classiﬁcation results.We hypothesized that the code-trained classiﬁer would be
more effective for retrieving tactic-related classes.
1)Method 1: Training with Tactic Descriptions :In the
ﬁrst experiment, we trained the classiﬁer using the tactic
descriptions and then tested the trained classiﬁer against the
code snippets . The experiment was repeated using a variety
of term thresholds and classiﬁcation thresholds.
2)Method 2: Training with Code Snippets :In the
second experiment we trained the classiﬁer using code
snippets. Because of the time-consuming nature of ﬁnding
and retrieving architectural tactics from large open-source
systems, we adopted a standard 10-fold cross-validation
process in which the code-snippets dataset served as both
the training and testing set. In each execution, the data
was partitioned by project such that in the ﬁrst run nine
projects, each including one related and four unrelated code-
snippets, were used as the training set and one project was
used for testing purposes. Following ten such executions,
each of the projects was classiﬁed one time. The experiment
was repeated using the same pairs of term thresholds and
classiﬁcation thresholds used in the previous experiment.
Table II shows the top ten indicator terms that were
learned for each of the ﬁve tactics using the two training
techniques. While there is signiﬁcant overlap, the code-
snippet approach unsurprisingly learned more code-oriented
terms such as ping,isonlin , and pwriter .
C. Evaluation Metrics
Results were evaluated using four standard metrics of
recall, precision, f-measure, and speciﬁcity computed as
follows where code is short-hand for code snippets .643Table III
A S UMMARY OF THE HIGHEST SCORING RESULTS
Tactic Training
MethodFMeasure Recall Prec. Spec. Term/
Classi-
ﬁcation
threshold
AuditDescript. 0.758 1 0.611 0.972 0.001 / 0.3
Code 0.758 1 0.611 0.833 0.001 / 0.5
AuthenticationDescript. 0.588 1 0.416 0.945 0.005 / 0.2
Code 0.956 1 0.916 0.977 0.005 / 0.4
HeartbeatDescript. 0.75 0.6 1 1 0.01 / 0.4
Code 0.689 1 0.526 0.775 0.001 / 0.2
PoolingDescript. 0.695 0.8 0.615 0.98 0.005 / 0.6
Code 0.9 0.818 1 1 0.05 / 0.7
SchedulingDescript. 0.705 0.545 1 1 0.05 / 0.8
Code 0.88 1 0.785 0.931 0.01 / 0.4
Recall =|RelevantCode∩RetrievedCode|
|RelevantCode|(3)
while precision measures the fraction of retrieved code
snippets that are relevant and is computed as:
Precision =|RelevantCode∩RetrievedCode|
|RetrievedCode|(4)
Because it is not feasible to achieve identical recall values
across all runs of the algorithm the F-Measure computes the
harmonic mean of recall and precision and can be used to
compare results across experiments:
FMeasure =2∗Precision∗Recall
Precision +Recall(5)
Finally, speciﬁcity measures the fraction of unrelated and
unclassiﬁed code snippets. It is computed as:
Specificity =|NonRelevantCode |
|TrueNegatives|+|FalsePositives|
(6)
D. Results
Figure 3 reports the f-measure results for classifying
classes by tactic using several combinations of threshold
value. In four of the ﬁve cases, namely scheduling ,au-
thentication ,audit , and pooling the code-trained classiﬁer
outperformed the description-trained classiﬁer. In the case of
heartbeat , the description-trained classiﬁer performed better
at term threshold values of 0.05 and classiﬁcation thresholds
of 0.3 to 0.4. One phenomenon that needs explaining in these
graphs are the horizontal lines in which there is no variation
in f-measure score across various classiﬁcation values. This
generally occurs when all the terms scoring over the term
threshold value also score over the classiﬁcation threshold.
Table III reports the optimal results for each of the tactics
i.e. a result which achieved high levels of recall (0.9 or
higher if feasible) while also returning as high precisionTable IV
INSTANCES OF ARCHITECTURAL TACTICS IN APACHE HADOOP
Tactic Class
CountExplanation Package Name
or Subsystem
Heartbeat 27HDFS uses a master/slave architecture
with replication. All slaves send a heart-
beat message to the master server indi-
cating their health status. Master server
replicates a failed node (slave).MapReduce
Subsystem
The MapReduce subsystem uses heart-
beat with piggybacking to check the
health and execution status of each task
running on a cluster.HDFS Subsys-
tem
Resource
Pooling36 MapReduce uses Thread pooling to im-
prove performance of many tasks e.g. to
run the map function.mapred pack-
age
7 A global compressor/decompressor pool
used to save and reuse codecs.compress
package
47 Block pooling is used to improve per-
formance of the distributed ﬁle system.HDFS subsys-
tem
5 Combines scheduling & job pooling .
Organizes jobs into “pools”, and shares
resources between pools.MapReduce
subsystem
Scheduling 88 Scheduling services are used to exe-
cute tasks and jobs. These include fair-,
dynamic-, & capacity-schedulingcommon &
MapReduce
Audit Trail 4 Audit log captures users’ activities and
authentication events.mapred pack-
age
Authent-
ication35 Uses Kerberos authentication for direct
client access to HDFS subsystems.security pack-
age
The MapReduce framework uses a
DIGEST-MD5 authentication scheme.MapReduce &
HDFS subsys.
as possible. The results show that in four cases the code-
trained classiﬁer recalled all of the tactic related classes,
while also achieving reasonable precision. The description-
trained classiﬁer achieved recall of 1 for only two of the
tactics.
V. R OLE LEVEL LINKRECONSTRUCTION
To train a classiﬁer to differentiate between various tactic
roles, we constructed a Role Snippets Dataset . This dataset
was a modiﬁcation of the code snippets dataset in which
each of the tactic-related code snippets was replaced by
separate code snippets for each of the tactic’s roles. For
example, each project for the scheduling tactic included one
code segment implementing the scheduler role, one code
segment implementing the scheduled by role, as well as four
unrelated code segments.
The previously described 10-fold cross-validation exper-
iment was repeated with the role-based code snippets to
see if we could effectively retrieve classes according to
their role in the project. Results from this experiment (not
otherwise reported) showed that the terms used across roles
in a given tactic were quite similar and so differentiation
was poor. To address these problems we conducted an
extensive exploratory investigation to determine how best to
classify classes by roles; however we report only the ﬁnal
technique that was adopted. The ﬁrst two steps in the process
utilize the previously described classiﬁer, while steps three
to six utilize light-weight structural analysis. The heuristics
of this analysis were derived through analyzing the tactic-644related code found in Fault Tolerant CORBA, the Google
Chromium OS and the ROSSUME robotic system. We
hypothesized that utilizing class hierarchy information and
class dependencies caused by method calls could improve
the quality of tactic traceability.
Our approach includes includes the following steps:
1. The tactic-grained classiﬁer is ﬁrst run against the entire
set of classes in order to identify an initial set of tactic-
related classes for each tactic.
2. The role-grained classiﬁer is then run against the subset
of classes returned by the tactic-grained classiﬁer. Following
this step, each of these classes is assigned a probability with
respect to each of the tactic related roles.
3. Based on observations that tactic related-behavior is
often speciﬁed in base classes, probabilities are propagated
across/lessmuchextends/greatermuchrelationships if the probability in the
base class for a speciﬁc tactic role is higher than that
of the derived class. Values are not propagated across
/lessmuchimplements/greatermuchrelationships because classes that imple-
ment an interface deﬁne their own behavior.
4. Based on observations that most tactics require com-
munication between roles, dependency analysis is performed
to eliminate classes that do not interact with other tactic-
classiﬁed classes. For example, a class assigned some prob-
ability of being a heartbeat receiver is in fact unlikely to ac-
tually play that role unless it is associated with other classes
which are also classiﬁed as heartbeat-related. However, this
heuristic is not valid for all tactics, as some tactics might
implement roles using inbuilt class libraries. For example
resource pooling might be implemented using the classes
from Java.util.concurrent, meaning that it is possible to
have a tactic-related, yet isolated class. Furthermore, in the
case that standard library functions are used in this way, it
becomes relatively trivial to identify the occurrence of such
a tactic. For purposes of our study, we therefore apply this
heuristic to all tactics apart from resource pooling .
5. Wherever feasible, classes are placed into functional
groupings according to their associations, so that different
instances of the same tactic can be separated out.
6. Finally, classes are classiﬁed according to the role with
the highest probability score, as long as that score is higher
than a predetermined threshold.
We explored other options for structural analysis. For
example, while it might seem reasonable to differentiate
between a heartbeat sender and receiver according to the
direction of the heartbeat message, the variety of implemen-
tations made this quite difﬁcult.
Unfortunately, it was not feasible to evaluate this light-
weight structural approach against the previously used code
snippets, as they did not carry associated structural infor-
mation. We therefore conducted an initial evaluation of this
approach within the richer context of the following case-
study. Speciﬁc results are reported in Section VI-C.VI. A C ASE STUDY
The goal of the case study is to reconstruct tactic-
related traceability links in the Apache Hadoop software
framework, a system which supports distributed processing
of large datasets across thousands of computer clusters. The
Hadoop library includes over 1,700 classes and provides
functionality to detect and handle failures in order to deliver
high availability service even in the event that underlying
clusters fail.
A. Tactics in Apache Hadoop
The ﬁrst step of the case study involved building an
‘answer set’ for evaluation purposes by manually identifying
heartbeat ,resource pooling ,scheduling ,audit trail , and
authentication tactics in Hadoop. This was accomplished by
(i) reviewing the available Hadoop literature [1] to look for
any references to speciﬁc tactics, and then manually hunting
for the occurrences of those tactics in the source code,
(ii) browsing through the Hadoop classes to identify tactic-
related ones, (iii) using Koders (search engine) to search
through the code using key terms (to reduce bias, this search
was performed by two researchers in our group prior to
viewing the indicator terms generated during the classiﬁ-
cation training step), and ﬁnally (iv) posting a question on
the Hadoop discussion forum describing the occurrences of
tactics we found and eliciting feedback. As a result of the
forum discussions one additional instance of the heartbeat
tactic was identiﬁed. Table IV documents the occurrences
of the ﬁve tactics we identiﬁed in Hadoop, and which were
then used as the ‘answer set’ for the remainder of the case
study. Our analysis showed that 1,557 classes were not
tactic related, 145 classes implemented one tactic only, 14
classes implemented two tactics, two classes implemented
one tactic, and one class implemented four tactics.
Figure 4. Results for Coarse-Grained Tactic Traceability in Hadoop
B. Reconstructing Coarse-Grained Links
The code-trained classiﬁer developed in our previous
experiments was used to classify all 1,700 classes in Hadoop
according to the ﬁve targeted tactics. Based on an initial
analysis of the results we established relatively low thresh-
old levels (i.e. term threshold of 0.001 and classiﬁcation
threshold of 0.5) in order to achieve high recall levels.6450 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Scheduling  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Authentication  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Heartbeat  
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Resource Pooling 
0 0.2 0.4 0.6 0.8 1 
0.1 0.3 0.5 0.7 0.9 F-Measure  
Classification Threshold  Audit Trail  
Scheduler  
Scheduled by Client  
Authenticator  Receiver  
Emitter  Resource 
pooler  Resource user  Audit performer  Figure 5. Results for Fine-Grained Tactic Traceability in Hadoop
Results, reported in terms of Recall, Precision, Speciﬁcity,
and F-Measure are depicted in Figure 4 and show that we
were able to correctly reject approximately 77-99% of the
unrelated code snippets in each of the cases. In four cases,
namely scheduling ,audit ,resource pooling , and heartbeat
we were able to recall all of the related code snippets;
however for authentication we were only able to recall 70%
of the related code snippets. An analysis of the missing
snippets suggested that the training set did not provide
sufﬁcient coverage of the concept, and therefore extending
the scope of the training set might mitigate this problem. In
all ﬁve cases precision ranged from 19% to 87%.
C. Role-grained Trace Links
The augmented role-grained classiﬁer, described in Sec-
tion V, was used to classify the tactic-related classes by
role, with the structural analysis performed utilizing the
Understand tool (scitools.com). Based on initial analysis of
results, the classiﬁcation threshold was set at 0.5. Results
are reported in Figure 5. In each case, the ﬁne-grained
classiﬁer was able to classify one dominant role better than
the other one. For example in the scheduling tactic the
“scheduler” role tended to contain more tactic-speciﬁc terms
than the “scheduled by” role, and was therefore classiﬁed
more accurately.
To illustrate these results we present a more detailed
example of one of the heartbeat instances in Hadoop. Figure
6 depicts the role-based classiﬁcation for the heartbeat
tactic used in Hadoop’s HDFS subsystem. Tactic roles are
depicted as/lessmuchemitter/greatermuchor/lessmuchreceiver/greatermuchstereotypes and are
also shaded in gray. For example DataNode which imple-
ments DatanodeProtocol sends the heartbeat message to the
NameNode, therefore each of them has the /lessmuchemitter/greatermuch
stereotype. In Figure 6, roles are ordered according to
probability for each class, and if all probabilities fall below
the classiﬁcation threshold an additional unclassiﬁed role
is added. All classes with bold borders have been correctly
classiﬁed either as a speciﬁc tactic role or as unclassiﬁed. As
depicted in the diagram, we were able to correctly classify
two out of three receivers, one out of two emitters, and
to correctly reject eight out of 11 unclassiﬁed classes. The
missed emitter was in fact an interface and not a fully deﬁned
class. Classes originally misclassiﬁed by the tactic-grained
classiﬁer as heartbeat related are marked with an X.D. Trace Reconstruction
In Figure 7 we show how the subset of role-classiﬁed
classes are mapped to speciﬁc roles in a tTIM, while
other unclassiﬁed classes are mapped at the tactic level.
These mappings are performed automatically as part of
the classiﬁcation process, and as a result, the classiﬁed
classes are traced to other tactic-related classes, to quality
goals, and to related requirements. For example, in this case
the mapping of DataNode.java as a Heartbeat emitter and
FSNamesystem.java as a Heartbeat receiver establishes a
relationship between them of type Sends Pulse . Similarly
it establishes that both java classes contribute to achieving
the reliability requirement that “HDFS must store reliability
even in the presence of failures.”
E. Utilizing Coarse-Grained Links
An important, yet often unexplored research question
addresses the issue of whether automatically reconstructed
traceability links are good enough for use. We therefore
designed an experiment to evaluate the usefulness of the
generated coarse-grained traceability links for supporting
software maintenance. This task is of particular interest to
our work, because of the previously discussed problems
of architectural degradation. The experiment utilized the
Hadoop change logs for the past four releases, and simulated
the scenario in which the generated tactic-level traceability
links were used to determine whether a modiﬁed class was
tactic-related. If it was, we simulated the generation of
a message to inform the developer about the underlying
architectural tactic. For example, a modiﬁcation made to the
Datanode.java class might result in the notiﬁcation message
shown in Figure 8 which utilizes traceability to provide
useful architectural information.
Table V(a) reports the numbers of successfully generated
notiﬁcations (true positives), unnecessary notiﬁcations (false
positives), missed notiﬁcations (false negatives), and cor-
rectly ignored maintenance tasks (true negatives). It also
computes recall (the fraction of changes that were tactic-
related for which messages were actually sent), precision
(the fraction of sent messages that were for tactic-related
classes), and speciﬁcity (the fraction of changes that were
unrelated to any tactics and for which no notiﬁcations were
sent). Recall of 1.0 was achieved for four of the tactics,
and 0.97 for the Authentication tactic. Speciﬁcity was over646Figure 6. Reverse Engineered Role-Grained Traces for a Heartbeat Tactic in Hadoop
Figure 7. Trace Reconstruction through Mapping Classiﬁed Classes at both Tactic and Role Granularities to a tactic Traceability Information Model
0.93 in all cases except for the scheduling tactic; however
precision ranged from 0.35 to 0.96. Table V(b) reports on
a second scenario in which we assume that the developer
rejects incorrect notiﬁcation messages, in effect rejecting the
underlying traceability link and leading to its removal. This
relevance feedback results in improved recall, precision, and
speciﬁcity for all ﬁve tactics. In fact all metrics are over
0.92 except the precision for the scheduling tactic which
remains at 0.73. These results demonstrate the viability of
our approach for supporting architectural preservation during
the software maintenance effort.
VII. T HREATS TO VALIDITY
There are several threats to validity that may have im-
pacted our work. One threat is related to the correctnessof the training and test sets used in this study. The task of
locating and retrieving over 100 samples of tactic-related
code snippets, and 400 unrelated code snippets was con-
ducted primarily by two members of our research team and
was then reviewed by two additional members. This was
a very time-consuming task that was completed over the
course of three months. The systematic search process we
followed, including the careful peer-review process, gave
us conﬁdence that each of the code snippets was a correct
example of its relevant tactic.
Another threat to validity is that the search for spe-
ciﬁc tactics was limited by the preconceived notions of
the researchers, and that additional undiscovered tactics
existed that used entirely different terminology. However we647Figure 8. A Notiﬁcation Message Generated from an Automated Trace
partially mitigated this risk through locating tactics using
searching, browsing, and expert opinion. In the case of
the Hadoop project, we elicited feedback from Hadoop
developers on the open discussion forum. This type of study
is always concerned with generalizability of the results. To
address this problem we created our initial code-snippets
datasets from tactics found in 16 different open source
systems. The leave-one-out cross-validation experiments we
conducted are a standard approach for evaluating results
when it is difﬁcult to gather larger amounts of data. Further-
more, the Hadoop case study was designed to evaluate the
tactic classiﬁer on a large and realistic system. Hadoop has
three major subsystems and many hundreds of programs.
We therefore expect it to be representative of a typical
software engineering environment, which suggests that it
could generalize to a broader set of systems. On the other
hand, IR approaches are inherently dependent upon the use
of terminology and so there are no guarantees that our
classiﬁer will recognize all instances of a particular tactic.
VIII. R ELATED WORK
Several researchers have developed techniques for man-
aging design decisions [23], [27], [28], or capturing and
tracing architectural knowledge [8], [21]. However, these
approaches are manual in nature and fail to provide guidance
on how to create and manage the potentially large number
of traceability links needed to make the design knowledge
available to a wide group of project stakeholders during
software maintenance activities. Other researchers have de-
veloped techniques that are designed to increase program
comprehension by reconstructing various architectural views
[22], [31], however these techniques tend to emphasize
reconstruction of the high-level structure of the system and
not the underlying architectural decisions.
The signiﬁcant body of prior work in the area of design
pattern detection [3], [14], [29]; provided a basis for the
structural analysis techniques described in our approach;
however, the problem of design pattern detection is fun-
damentally different from the problem of tactic detection
because a single tactic can often be implemented in numer-
ous different ways. Therefore we cannot primarily rely upon
structural analysis techniques.Table V
ACCURACY OF GENERATED NOTIFICATION MESSAGES DURING
SIMULATED MODIFICATIONS TO HADOOP
(a) Notiﬁcation Messages with no User Feedback
True
Pos.False
Pos.True
Neg.False
Neg.Recall Prec. Spec.
Audit 159 5 4405 0 1 0.96 0.99
HeartBeat 256 57 4256 0 1 0.81 0.98
Scheduling 709 1301 2559 0 1 0.35 0.66
Res. Pooling 315 19 4235 0 1 0.94 0.99
Authentication 259 266 4037 7 0.97 0.49 0.93
(b) Notiﬁcation Messages with User Feedback
True
Pos.False
Pos.True
Neg.False
Neg.Recall Prec. Spec.
Audit 159 1 4409 0 1 0.99 0.99
HeartBeat 256 9 4304 0 1 0.96 0.99
Scheduling 709 262 3598 0 1 0.73 0.93
Res. Pooling 315 4 4250 0 1 0.98 0.99
Authentication 259 19 4284 7 0.97 0.93 0.99
Finally, our work is a special case of automated trace
retrieval, which can be used to generate traces between docu-
ments and source code. There are many different approaches
including the vector space model, probabilistic network
(PN) models, latent semantic analysis (LSA) [2], [17], and
orthogonal IR based models [25]; however these techniques
assume that the source of the trace, i.e. the requirement or
use-case, is unique in each project, and therefore utilize basic
information retrieval techniques. Finally, in our own prior
work we utilized the machine learning techniques described
in this paper to trace regulatory codes to requirements [9],
and to differentiate between functional and non-functional
requirements [10]; however neither of these techniques in-
corporated the richer contextual information provided by the
tactic Traceability Information Models.
IX. C ONCLUSIONS
This paper has presented a technique for automating
the reconstruction of traceability links between classes and
architectural tactics. Integrating the concept of tTIMs with
existing notions of trace retrieval and classiﬁcation intro-
duces a novel approach to tracing architectural concerns. It
minimizes the human effort required to establish traceability
and produces traces which can be used to support critical
software engineering tasks such as software maintenance, in
order to help mitigate the pervasive problem of architectural
erosion.
Future work will investigate additional tactics, reﬁne the
trace reconstruction algorithms, and evaluate our approach
against a broader set of software systems. In addition, we
are developing an Eclipse plug-in which will allow us to
study this, and related techniques, within the context of an
ongoing project.
ACKNOWLEDGMENTS
The work in this paper was partially funded by the US
National Science Foundation grant # CCF-0810924.648REFERENCES
[1]Apache-Hadoop Design documents . http://hadoop.apache.org
/common/docs/current/hdfs-design.html.
[2] G. Antoniol, G. Canfora, G. Casazza, A. De Lucia, and
E. Merlo. Recovering traceability links between code and
documentation. IEEE Trans. Softw. Eng. , 28(10):970–983,
2002.
[3] G. Antoniol, G. Casazza, M. D. Penta, and R. Fiutem. Object-
oriented design patterns recovery. Journal of Systems and
Software , 59(2):181–196, 2001.
[4] F. Bachmann, L. Bass, and M. Klein. Deriving Architectural
Tactics: A Step Toward Methodical Architectural Design .
Technical Report, Software Engineering Institute, 2003.
[5] L. Bass, P. Clements, and R. Kazman. Software Architecture
in Practice . Adison Wesley, 2003.
[6] B. Berenbach, D. Gruseman, and J. Cleland-Huang. Applica-
tion of just in time tracing to regulatory codes. In Proceedings
of the Conference on Systems Engineering Research , 2010.
[7] G. Booch. Draw me a picture. IEEE Software , 28:6–7, 2011.
[8] R. Capilla, F. Nava, S. P ´erez, and J. C. Due ˜nas. A web-based
tool for managing architectural design decisions. SIGSOFT
Softw. Eng. Notes , 31, Sept. 2006.
[9] J. Cleland-Huang, A. Czauderna, M. Gibiec, and J. Eme-
necker. A machine learning approach for tracing regulatory
codes to product speciﬁc requirements. In ICSE (1) , pages
155–164, 2010.
[10] J. Cleland-Huang, R. Settimi, X. Zou, and P. Solc. Automated
detection and classiﬁcation of non-functional requirements.
Requir. Eng. , 12(2):103–120, 2007.
[11] J. Cleland-Huang, G. Zemont, and W. Lukasik. A hetero-
geneous solution for improving the return on investment of
requirements traceability. In RE, pages 230–239, 2004.
[12] D.E.Perry and A.L.Wolf. Foundations for the study of soft-
ware architecture. SIGSOFT Software Eng. Notes , 17(4):40–
52, 1992.
[13] A. Egyed, S. Bifﬂ, M. Heindl, and P. Gr ¨unbacher. De-
termining the cost-quality trade-off for automated software
traceability. In ASE, pages 360–363, 2005.
[14] F. A. Fontana, M. Zanoni, and S. Maggioni. Using design
pattern clues to improve the precision of design pattern
detection tools. Journal of Object Technology , 10:4: 1–31,
2011.
[15] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design
patterns, software engineering, object-oriented programming .
[16] O. Gotel and A. Finkelstein. Extended requirements trace-
ability: Results of an industrial case study. In RE ’97:
Proceedings of the 3rd IEEE International Symposium on
Requirements Engineering , page 169, Washington, DC, USA,
1997. IEEE Computer Society.[17] M. Grechanik, K. S. McKinley, and D. E. Perry. Recovering
and using use-case-diagram-to-source-code traceability links.
InESEC/SIGSOFT FSE , pages 95–104, 2007.
[18] R. Hanmer. Patterns for Fault Tolerant Software . Wiley Series
in Software Design Patterns, 2007.
[19] A. Jalaji, R. Goff, N. Jones, and T. Menzies. Making sense of
text: Identifying nonfunctional requirements early. Technical
Report, West Virginia University .
[20] A. Jansen and J. Bosch. Software architecture as a set of
architectural design decisions. In WICSA , pages 109–120,
2005.
[21] A. Jansen, J. S. van der Ven, P. Avgeriou, and D. K. Hammer.
Tool support for architectural decisions. In WICSA , page 4,
2007.
[22] R. Koschke. Architecture reconstruction. In ISSSE , pages
140–173, 2008.
[23] P. Kruchten, R. Capilla, and J. C. Dueas. The decision
view’s role in software architecture practice. IEEE Software ,
26(2):36–42, 2009.
[24] M. Mirakhorli and J. Cleland-Huang. A decision-centric
approach for tracing reliability concerns in embedded soft-
ware systems. In Proceedings of the Workshop on Embedded
Software Reliability (ESR), held at ISSRE10 , November 2010.
[25] Malcom Gethers, Rocco Oliveto, Denys Poshyvanyk and
Andrea De Lucia. On integrating orthogonal information
retrieval methods to improve traceability link recovery. In
International Conferences on Software maintenance , 2011.
[26] M. Mirakhorli and J. Cleland-Huang. A pattern system
for tracing architectural concerns. In Proc. of the Pattern
Languages of Programming , 2011.
[27] M. Mirakhorli and J. Cleland-Huang. Tracing architectural
concerns in high assurance systems: (nier track). In Pro-
ceedings of the 33rd International Conference on Software
Engineering , pages 908–911, 2011.
[28] M. Mirakhorli and J. Cleland-Huang. Using tactic traceabil-
ity information models to reduce the risk of architectural
degradation during system maintenance. In Proc. of the
International Conf. on Software Maintenance, ICSM , pages
123–132, 2011.
[29] N. Pettersson, W. L ¨owe, and J. Nivre. Evaluation of accuracy
in design pattern occurrence detection. IEEE Trans. Software
Eng., 36(4):575–590, 2010.
[30] J. van Gurp, S. Brinkkemper, and J. Bosch. Design preser-
vation over subsequent releases of a software product: a case
study of baan erp: Practice articles. J. Softw. Maint. Evol. ,
17:277–306, July 2005.
[31] H. Verjus, S. C ˆımpan, A. Razavizadeh, and S. Ducasse.
Beeeye: A framework for constructing architectural views.
InECSA , pages 376–383, 2010.649
View publication stats