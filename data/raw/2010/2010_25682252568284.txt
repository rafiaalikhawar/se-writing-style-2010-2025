Transition from Cen tralized to Decentralized  Version Control 
Systems : A Case Study on Reasons , Barriers, and Outcomes  
Kıvanç Muşlu  
University of Washington  
Seattle, WA, USA  
kivanc@cs.washington.edu  Christian Bird, Nachi appan  Nagappan  
Microsoft Research  
Redmond, WA, USA  
{cbird, nachin}@microsoft.com  Jacek Czerwonka  
Microsoft  
Redmond, WA, USA  
jacekcz@microsoft.com  
ABSTRACT  
In recent  years, software development has started to transition from 
centralized version control systems (CVCSs) to decentralized ver-
sion control systems  (DVCSs) . Although CVCSs and DVCSs have 
been studied extensively, there has been little research  on the tran-
sition across these systems . 
This paper investigates the transition process, from the developer’s 
view, in a large company. The paper c aptures the transition reasons , 
barriers, and outcomes  through 10 developer interviews, and inves-
tigates  these findings th rough  a survey, participated by 70 develop-
ers. The paper  identifi es that the majority of the developers need  to 
work incrementally and offline, and manage multiple contexts effi-
ciently.  DVCSs fulfill these developer needs;  however the transi-
tion comes with a cost depending on the previous development 
workflow. The paper  discusses  the transition reasons, barriers and 
outcomes, and provides recommendations for teams planning such 
a transition. The paper shows  that lightweight branches , and local 
and incremental commits were the main reasons for developers 
wanting to move t o a DVCS. Further , the paper identifies  the main 
problem s with the transition process  as: steep DVCS learning 
curve; incomplete DVCS integration with the rest of the develop-
ment workflow ; and DVCS scaling issues.  
Categories and Subject Descriptors  
D.2.7  [Software Engineering ]: Distribution, Maintenance, and 
Enhancement – version control  
General Terms  
Measurement, Human Factors.  
Keywords  
Version control system, DVCS, CVCS , distributed, centralized, 
productivity, barriers, empirical , transition . 
1. INTRODUCTION  
Version control systems (VCS s) help developers to implement and 
maintain large systems by letting them collaborate and work on the 
same project  at the same time. A centralized VCS (CVCS) keeps 
all development  history in a central server whereas a decentralized 
VCS (DVCS) keeps the development  history on each development 
machine  locally . Historically, DVCS s came later than CVCS s, try-ing to address the limitations of CVCS s, such as enabling light-
weight branching , local VCS operations, and easier collaboration 
between developers  [1]. 
Although CVCS s and DVCS s have been available for quite a while , 
to the best of our knowledge , there is little research on  why devel-
opers transition from a CVCS to a DVCS. For a developer, who is 
already proficient with a CVCS, transitioning to an unknown 
DVCS would require considerable effort, which would only make 
sense if the benefits of using the DVCS would eventually out weigh 
this transition  effort . Barr et al. [2]  investigated how the transition 
affects the project branching structure and the way the developers 
use branches  in open -source  software  (OSS) . de Alwis and Sillito 
[1] investigated the transition process, challenges, and anticipated 
benefits for four OSS. To our best knowledge, there is no study that 
investigates the transition process  from the developer ’s view in a 
large commercial  company . This paper aims  to understand transi-
tion reasons, barriers, and outcomes from a qualitative perspective 
to expand  the scientific knowledge for the whole  transition process.  
To identify  the transition reasons , barriers, and outcomes , this paper 
uses interviews of  10 developers who transitioned from a CVCS to 
a DVCS within the same project . The paper also investigates and 
quantifies the findings through  a comprehensive survey, partici-
pated by 70 developers. The paper  identified  that, at Microsoft, 
DVCSs are preferred  for some simple but key operations, such as 
incremental workflow through small  and local commits, and effi-
cient context switching through lightweight branches . This raises 
the q uestion whether all DVCS features – and specifically being 
distributed  – are essential for large, commercial companies.  Section 
7 discusses this question in -depth . 
The paper makes  the following contributions:  
 A novel, qualitative study with professional  developers 
who transitioned from a CVCS to a DVCS within the same 
project (Section  3), 
 
 Identification of the key c oncepts for transition reasons,  
barriers, and outcomes  through 10 semi -structured devel-
oper interviews , and quantification  of these findings 
through a comprehens ive survey, participated by 70 devel-
opers (Sections 4, 5, and 6), 
 
 In-depth discussion of the DVCS features that are favored 
by the developers to understand whether these feat ures are 
essential  to DVCSs. This discussion  concludes with  guide-
lines to people  who consider  transitioning (Section 7). 
The reminder of the paper is organized as follows: Section 2 defines 
VCS  termi nology. Section  3 explains the methodology. Section s 4, 
5, and 6 explain transition reasons , barriers, and outcomes , respec-
tively. Section 7 discusses some of our finding in -depth and pro-
vides guidance to people  who consider transitioning . Section 8 dis-
cusses threats to validity  in the findings . Section 9 puts the paper in 
the context of the related work. Section 10 concludes. 
Permission to make digital or hard copies of all or part of this work for 
personal or classroom  use is granted without fee provided that copies are 
not made or distributed for profit or commercial advantage and that copies 
bear this notice and the full citation on the first page. To copy otherwise, 
or republish, to post on servers or to redistribute  to lists, requires prior 
specific permission and/or a fee.  
ICSE ’14, May 31 –June 7, 2014 , Hyderabad , India . 
Copyright 2 014 ACM 978-1-4503 -2756 -5/14/05 …$15.00.  
 Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE’14 , May 31 – June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568284
334
2. DEFINITIONS  
This section defines VCS  terminology used throughout the paper.  
A version control system ( VCS ) is a tool that helps the developers 
manage the source code and the development history of a product with  
the following core functionality: (1) backing up the source code seam-
lessly, and (2) letting multiple developers  collaborate effic iently . 
A repository  is the combination of the source code and metadata – 
including all previous version s – stored in a VCS. To work on the  
source code, the developer check s-out a version of the history from 
a repository  to a local workspace . The developer  makes changes to 
the workspace and checks -in these changes to the VCS to make the 
changes accessible to other developers . During a check -in, the de-
veloper’s changes might conflict  with changes check ed-in by other 
developers . All VCSs provide a textual merge algorithm that finds 
the closest common ancestor for conflicting  changes and show s the 
conflicts  as a 3 -way diff.  A VCS branch  is a systematic way  to 
provide isolation by diverging  from the development hi story at a 
specific point. By default, the development in a VCS starts in a 
branch called ‘ trunk ’. Later, the developers can create other 
branches from existing branches. 1 
A centralized VCS (CVCS)  (e.g., CVS [3], SVN [4]) is a VCS that 
stores the development history in a central server. Most CVCS s 
only store one snapshot (typically the latest) of the repository lo-
cally at any given time . Consequently, CVCSs scale well regardless 
of the development history . However, VCS  operations that need 
access to history that is not available locally, such as merge, must 
execute on the server.   
A distributed VCS (DVCS)  (e.g., Mercurial  [5], Git [6]) is a VCS  
that stores the whole development history  as a local repository. A 
commit is a ch eck-in to this local repository, which i s not accessible 
to other developers, by default. DVCSs execute  most VCS  opera-
tions – except synchronization  with another repository – locally.  
A bridg e is some tooling between a CVCS and a DVCS that lets the 
developers use the DVCS, but stores the history in the CVCS.  The 
bridge offers bidirectional  synchronization between the CVCS and 
the DVCS . Figure 2 depicts the ar chitectural diagram  of a bridged 
VCS (BVCS) , which consists of one CVCS, one DVCS, and a 
bridge implementation . This paper uses the terms bridge and BVCS 
interchangeably.  The re st of the paper does not distinguish between 
                                                                 
1 The paper uses the terms check -in and check -out instead of  commit and 
clone , which have different meaning for DVCSs and CVCSs.  a BVCS and a DVCS since  a developer uses only DVCS operations 
in both. The term ‘B/DVCS’ stands for BVCS or DVCS.  The term 
‘transition’ stands for the transition from a CVCS to a B/DVCS.  
3. METHODOLOGY  
To understand the transition reasons , barriers, and outcomes, we 
conducted 10 semi-structured developer interviews  and a survey 
participated  by 70 developers . This section explains the methodol-
ogy for the interviews, and the survey . The results are presented in 
Sections 4, 5, and 6. The results are based on our interviews only; 
we use d the survey to quantify and generalize these results . We 
only report the survey results for the whole developer po pulation 
since two -tailed  heteroscedastic  Student’s t -test (based on factors 
such as age and experience) showed no statistical significance be-
tween sub -populations with p > 0.05.  
For the interviews, we selected developers who transitioned  within 
the same project, as they have a better chance to c ompare a CVCS 
to a B/DVCS.  We sent a preliminary questionnaire  to two internal 
B/DVCS mailing lists to find candidates . Depending on the ques-
tionnaire results, we sent individual e-mails to recruit developers . 
Each developer went through a semi -structured interview  (as de-
scribed in [7]) where the interviewer had several questions  that tried 
to capture the developer’s familiarity and workflow  patterns with 
different VCS s, and the transition  reasons , barriers,  and outcomes. 
The questions  were general to prevent introducing bias . For exam-
ple, instead of asking whether the developer likes lightweight 
DVCS bra nches , we asked which DVCS aspects th e developers 
likes and dislikes . The developers were encouraged  to talk in detail 
for any question , or any part of the transition that the questions did  
not cover . Each interview lasted about  an hour  and was recorded . 
After the last interview was completed, we coded  the re cordings. 
For each coded interview, we  generated 25 to 55 cards containing 
the key points . At the end, we printed  a total of  378 cards. W e sorted 
these cards to categorize the responses for thematic similarity (as 
illustrated in LaToza et al.’s study [8]). The se themes that emerged 
during the sort were not chosen beforehand . Finally, we went over 
each theme and categorized  the cards  in that theme  into sub -themes . 
Figure 1 shows the cards – with themes and sub -themes written on  
yellow stickers.  
Figure 1: Card sorting. Yellow stickers represent a (sub) theme.  
Figure 2: The architectural diagram for Git -P4. The developers 
on the left use Git. They synchronize with either the main  Git 
repository (Git logo at the top left) or their peer’s private Git 
repositories (small Git logo s at the bottom left ). The developers 
on the right use Perforce a nd only interact with the main  Per-
force repository . Git -P4 synchronizes the main  Git and Per-
force repositor ies in both directions.  335We designed a survey to quantify our findi ngs from the interviews. 
Kitchenham and Pfleeger [9] discuss the design and construction of 
personal opinion surveys using the following steps: searching the 
relevant literature; construct an instrument; evaluate the i nstrument; 
document the instrument. In our survey, as suggested by Kitchen-
ham and Pfleeger, we use f ormal notations, limit our res pondents ’ 
responses to numerical, Yes/No type, Likert -scale, and short free 
form answ ers. Respondents were anonymous.  We f ollowed Kitch-
enham and Pflee ger’s advice  [9] on the need to understand whether 
the respondents had enough knowledge to answer the questions in 
an appropriate manner. For this, we restricted the people invited to 
partic ipate in the survey to people who had registered in the 
B/DVCS mailing lists . Additionally , even if the developers  had 
never used a CVCS or a B/DVCS, they could skip the related parts 
of the survey and still be included in the drawing2, ensuring that no 
one felt compelled to take the survey for the chance to win the gift.  
We piloted our survey within researchers before making it available 
to 150 candidate developers  in Microsoft . 70 developer  took and 
completed the survey. 57 participants (81%) and all participants 
used a B/DVCS and a CVCS at Microsoft, respectively. 47  partici-
pants (82%) continue using a B/DVCS. Table 1 summarizes the re-
maining  demographical properties for the survey participants.  
4. TRANSITION REASONS  
This section focuses on the following four  main transition  reasons : 
the ability to  (1) work  offline, (2) work  incrementally, (3) context 
switc h efficiently , and (4) do exploratory coding  efficiently . Figure 
3 summarizes the related survey results.  
(i) The ability to work offline: All developers  we interviewed  fo-
cus on the importance of being able to work offline.  The majority 
of the survey partici pants  (56% vs. 34%) agree  with this observa-
tion. Some CVCSs require the developer to be connected to the 
server before editing a file for the first time , which makes it more 
difficult to work offline . The manual workaround s are tedious. For 
example, the developer could ignore this requirement, start editing 
                                                                 
2 Survey respondents could e -mail us separately outside of their 
survey responses to enter a drawing for four $10 rewards . the file  and attempt to check -in changes  when s/he is connected to 
the serve r in the future . At this point, the CVCS  would attempt to 
replay developer’s actions . If any step fails due to other check -ins, 
developer’s c heck -in fails. Moreover , developers cannot work eas-
ily when the central server is down or having bandwidth problems .  
The developers believe that with a B/DVCS they can work offline. 
When using a B/DVCS, the developers  need to interact with the 
central server only when they need to check -in their changes  to or 
check -out new changes from the server.  
(ii) The ability to w ork incrementally: In our interviews , all de-
velopers except one focus on the importance of incremental and fre-
quent commits . 97% of the survey participants support this observa-
tion by favori ng small, frequent  commits  to one large check -in. 
CVCSs do not support  commits . The moment a developer  checks -in 
to the server, the changes are  accessible to everyone. Some  develop-
ment practices suggest  that the developers should  check -in complete 
and working code,  which makes it more difficult for  the developer s 
to create checkpoints  for their current work . These check points are 
useful for understand ing how a recent code  has evolved in time and 
return ing back to a previous version quickly.  
Microsoft p roducts use continuous integration : checked -in changes 
go through ‘quality gates’ where they are built and tested . Before 
checking -in, most developers also go through a simplified quality 
gate, called Check -in Wizard, which builds and tests the modified 
components locally  to get an early assessment of software quality . 
One execution of the Check -in Wizard can occasionally take a long 
time, which discourages the developers to do frequent check -ins. 
The survey participants  have mixed feelings ( 46% agree  vs. 28% 
disagree) on whether the quality gates affect  the development work-
flow negatively or not. Nonetheless, t he developers believe that  
DVCS s would let them work incrementally  and go through the  
Check -in Wizard less frequently  via commits . 
(iii) The ability to context switch efficiently : All developers  we 
interviewed  focus on the fact  that CVCSs make it very difficult to 
work on multiple tasks simultaneously . Working on multiple tasks, 
such as developing a new feature or fixing a bug, is common for 
the developers. Figure 4 summarizes  the most popular CVCS tech-
niques for context switching. Top two of these techniques is to  
check -out the code multiple times on different file system locations  
(multiple enlistments) and create a delta for each different change 
and manually manage these deltas ( patches ). Checking -out the code 
multiple times  increase  the storage space  needed for development 
0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
CVCS workflow is non-optimal as I have to be online.
CVCS workflow is non-optimal as quality gates are too slow.
CVCS workflow is non-optimal as context switching is hard.
I prefer frequent and small check-ins to one large check-in.
At Microsoft, creating a branch is an organizational decision.
I would prefer using VCS branches for context switching.
Strongly Agree Agree Neutral Disagree Strongly Disagree N/AFigure 3: Survey results related to transition reasons (colored). The second and last questions are answered by 36 and 54 qualifying 
developers. More than 50% of the developers agree that they cannot work efficiently with the current CVCSs at Microsoft becaus e 
they have to be online and cannot context switch easily. Most developers prefer to work with small, incremental commits and u se 
VCS branches for context switching. 81% of the developers agree that creating and deleting branches is an organizational decision 
at Microsoft. Finally, the developers have mixed  feelings ( 46% agree vs. 28% disagree) on whether quality gates affect their devel-
opment workflow neg atively.  
Table 1: Survey demographics  
Demographic Property  Average Value  
Development experience  11.0 years  
Experience at Microsoft  6.2 years  
Experience with CVCSs at Microsoft  5.9 years  
Experience with DVCSs at Microsoft  1.5 years  
 336linearly . More importantly, each time  the developer checks -out new 
changes from the server , every code location  needs to be rebuilt 
even if their content s are mostly the same . When using patches, the 
developer needs to create and  manually maintain these patches. 
One developer mentions:  
I use other tools, beside [VCS] , to s ave bits and pie ces of 
my work. U sing one of these  [tools] , I can take a snapshot 
of [my changes] … I try naming  [the snapshot ] meaning-
fully, e.g.,  bugid_1, bugid_2 , but I don't do a good job.  
76% of t he survey participants agree that CVCS s they use do not 
provide efficient ways to context switch.  The fact that  all of the 
survey participants, except one,  do not use private branches  as a 
standalone technique  was surprising for us.  However, at Microsoft, 
the branches for a product  is often an organizational  decision.  81% 
of the survey participants agree with this observation.  All check -ins 
need  to go through quality gates, which means that all branches 
need infrastructure support, such as build and test labs. Therefore, 
it is not easy for a developer to create and delete private branches 
as s/he sees fit. On the other hand, with DVCS s, a developer could  
create a pri vate branch, do changes, check -in locally, merge her/his  
branch to one of the organizational  branches, and check -in the 
changes on the organizational  branch. For other developers, and for 
the central server, it is as if the private  branch never existed. Ther e-
fore, t he developers believe that they can context s witch efficiently  
using DVCS branches.  
(iv) The ability to do exploratory coding efficiently : Half of the 
developers  we interviewed , mentioned that CVCS s limit  their abil-
ity to do exploratory coding . Exploratory coding is  when develop-
ers pursue a new feature/protot ype development to explore its fea-
sibility without complete knowledge of its ability to be successful 
or not.  Exploratory coding can be seen as a task that requires a new  
context , however differs  from the usual context switches  in two as-
pects: (1) explorat ory coding might take a long time before it be-
comes a prototype that can be checked -in, and (2) some exploratory 
coding never make s to the product. Therefore, exploratory coding 
might be viewed as a longer and potentially disposable context 
switch. With st rict and pre-defined branches , the developer has to 
manually manage any exploratory coding , which makes it more dif-
ficult and not worthwhile. The developers believe  that DVCS  
branches  will let them do exploratory coding efficiently.  
This section identifie d four important CVCS drawbacks. We  dis-
cuss how a DVCS can remove  these drawbacks  in Section 6.1. 
5. TRANSITION BARRIERS  
This section focuses on three major problems  faced  by the devel-
opers during the transition. Section 5.1 discusses the  steep DVCS  learning curve, Section 5.2 discusses incomplete DVCS integration 
with the rest of the development workflow , and Section 5.3 dis-
cusses the DVCS scalin g issues  with huge  products  with long his-
tories.  These barriers can be viewed as downsides of DVCSs since 
workarounds require developer effort (learning curve and incom-
plete integration ) and changes in  the development workflow ( scal-
ing issues). Figure 5 summarizes the survey results . 
5.1 Learning Curve  
Most DVCSs have higher learning curves compared to CVCSs be-
cause of three  reasons: (1) the centralized model – where all devel-
opment goes through a central repos itory – is easier conceptually, 
(2) DVCSs have advanced concepts, such as rebasing [10] and trans-
planting  [11], which have no CVCS correspondence , and (3) the 
conflicting terminology between CVCSs and DVCSs . 58% of the 
survey participants agree that DVCSs have h igher learning curve . 
(i) Centralized vs. decentralized model:  In CVCSs, the develop-
ers interacts with one central repository. All developers synchro-
nize through this  central repository . On the other hand, in DVCSs, 
developer s have local repositories . The developers commits  their 
changes to their local reposito ries first, and then check -in to a glob-
ally accessible  repository . The content of the global repository  can 
be different than the content of the developers’ local repositories, 
which can be different than the content of the developers’ work-
spaces. Although  not frequently used in big projects  [2], the devel-
opers can directly synchronize through  another developer’s local 
repository. With increased number of repositories and multiplied 
possibilities for sharing  code, DVCSs are harder to reason about . 
(ii) Advanced DVCS concepts:  CVCSs do not let developers mod-
ify the development history easily. Once a change  is checked -in to 
the central server, it is remembered indefinitely. DVCSs give more 
control  to the develo pers in terms of history management. How-
ever, with great power, comes great responsibility: a developer can 
modify the development history in an irrevocable way us ing ad-
vanced DVCS commands. A developer mentions:  
[DVCSs are]  so open ended … If people do wh atever the y 
want, [they]  can irrevocably lose data . 
(iii) Conflicting terminology:  Another difficultly in learning a 
DVCS – for a developer who already knows a CVCS – is the con-
flicting terminology. DVCSs have some commands that have the 
same name as a CVC S command, but have  a different meaning. For 
example, in CVCSs when a developer commits , her/his  changes are 
checked -in to the central repository. However, in DVCSs, when a 
developer commits , her/his  changes are only stored in  her/his  pri-
vate local reposit ory. Unless the developer shares her/his  local re-
pository with other developers , these changes are not accessible un-
til the developer pushes  them  to a globally accessible repository . 
Learning curve due to conflicting terminology is bidirectional; the 
developers who learn a DVCS first might also experience similar 
problems. For the same example, the developer who switches  from 
a DVCS  to a CVCS , would be surprised that her/his  changes are  
accessible to other developers when  s/he commits .  
In addition to the higher DVCS learning curve, three  developers  we 
interviewed  mentioned that the BVCS increases the learning curve 
since the developers need to understand how the bridge interacts 
with bo th VCS s and learn brid ge-specific commands.  
The t ransition process requires the developers to change their per-
ception of how VCSs work, learn a new VCS , and potentially  learn 
a bridge  tooling . A part of DVCS learning curve is non -essential 
since any new te chnology has some learning curve. Three develop-
ers we interviewed  mentioned that  the Internet contains  tremendous 
Figure 4: CVCS techniques that are used for context switching 
(colored). Most of the ‘other’ techniques boil down to careful 
management of multiple changes manually.  337amount of docu mentation for the popular DVCSs , which might  mit-
igate the le arning curve. One developer notes : 
Another thing I like about [DVCSs]  is there is so much 
documentation available online.  
5.2 Incomplete Integrati on 
The developer s might not  fully appreciate the B/DVCS features due 
to two major reasons:  (1) incomplete bridge implementation, and 
(2) missing tooling around the B /DVCS s. This section focuses on  
the bridge s (BVCS s) between DVCSs  and the CVCSs  in Microsoft, 
and discusses these problems in detail.  Although 61% of the survey 
participants do not think th at B/DVCS s are missing important fea-
tures , the participants have mixed feelings ( 41% agree, 46% disa-
gree) on whether B/DVCS s are integrated well with the rest of the 
development workflow.   
(i) Incomplete bridge implementation:  Some BVCSs at Mi-
crosoft do not support all feat ures available in the surrounding 
VCSs they bridge . A developer states:  
[DVCS]  and [CVCS]  have  power individually, howe ver 
these powers are not exposed  by [the BVCS] . 
A particular BVCS  uses the same file system location as a DVCS  
and a CVCS  repository at the same time , which causes interaction 
problems between VCSs . A develope r mentions:  
[BVCS]  looked like something between two worlds. Some 
tools would [detect]  a [CVCS  repository ] in the work-
space, sometimes [DVCS]  operations would not work . 
(ii) Missing tooling around B/DVCS:  For developers in large 
companies,  the code involves in additional steps before it  is shipped 
in a p roduct. For example, the developer s run tests and do code re-
views before the code  is shipped . These s teps may require addi-
tional  tooling, such as  VCS integration with code reviews.  
CVCSs at Microsoft are  integrated very tightly and seamless ly with  
the whole development process – from  implementation to shipping . 
There are teams whose main responsibility is to  create and maintain 
CVCS integration tools . When a developer uses a CVCS , all stages 
of the development workflow just works. However, the same is not 
true for some BVCSs , yet. Some BVCSs are maintained only by a 
sub-team and are integrated  to the particular development flow of 
that sub -team, wh ich may be different from the other teams. If a 
developer from a nother team wants to use this BVCS , s/he sacri-
fices existing tooling for the rest of the  development workflow , and 
needs  to do these steps  manually. For example, some BVCSs are  not integrated wit h the Check -in Wizard. For some teams, it is re-
quired to commit the code  through the Check -in Wizard, which 
means that the deve lopers who use such BVCSs  cannot check -in 
their changes  directly . These developers c reate a patch for the 
changes , apply this patch  to and check -in from  another CVCS  re-
pository . In other words, the development is done on BVCS , how-
ever the code is checked -in through  CVCS . A developer mentions:  
I cannot use [BVCS]  to check -in changes to [the CVCS] , 
because we use C heck-in Wizard, a nd [BVCS]  does not 
support it. I create [a patch]  and apply it on a  [CVCS]  
repository to  check -in. 
Using existing mature open -source BVCSs do not solve the tooling 
problem . The se BVCSs have no knowledge of the development 
workflows and additional tools use d by Microsoft . 
Tool immaturity is non -essential to DVCSs since any new technol-
ogy will lack tool support for an existing development workflow. 
Still, we believe that BVCSs will be useful only when  the BVCS is 
integrated with the rest of the development workflow as well as 
they are integrated with the CVCS and DVCS they bridge . All de-
velopers  we interviewed  felt that the BVCSs in Microsoft were 
missing important features and external tool support, which makes 
it too early to su ggest for a team wise adoption . 
5.3 Scaling  
At Microsoft, there are large codebase s that have  been developed 
for more than a decade . DVCSs check -out the complete history – 
all source code and every change that has been happened – to every 
development machine by default. For a product that is tens of GB s 
in size and has been developed for many years, using a DVCS can 
cause scaling problems. This section focuses on three  main causes 
of the scaling problems: (1) checked -in, large binaries, (2) compo-
site products,  and (3) long development histo ry. Only 39% of the  
survey  participants agree that their product scales to B/DVCSs by 
default whereas the agreement increases to 62% after an initial 
setup  (see Figure 5). 
(i) Checked -in large binaries:  One of the major causes of the scal-
ing problem is the large binaries checked -in to the VCS.  Ten survey 
participants believe that DVCS scaling can be achieved if the bi-
nary dependencies were not checked -in to the VCS.  VCSs only rec-
ord the difference  with respect to the latest version in the history. 
For text files, the overhead of recording this difference is  very low. 
On the contrary , VCS s record  all versions of a binary  file. Deleting 
the previous version s does not  solve the problem  since  the VCS has 
0% 20% 40% 60% 80% 100%
B/DVCSs have high learning curve.
B/DVCSs are missing important features.
B/DVCSs are integrated well with the dev. workflow.
B/DVCSs scale to our product by default.
After an initial setup, B/DVCSs scale to our product.
B/DVCSs let me work offline.
B/DVCSs let me work incrementally with local commits.
B/DVCSs let me context switch efficiently with branches.
Strongly Agree Agree Neutral Disagree Strongly Disagree N/AFigure 5: Survey results related to transition barriers and outcomes (colored). These questions were answered by 57 participants, 
who have used a B/DVCS at Microsoft. 58% of t he participants note the learning curve with B/DVCSs. 61% of the participants do 
not believe that B/DVCSs are missing important features. Participants have mixed feelings ( 46% agree, 41% disagree) on whether 
B/DVCSs are not integrated well with the rest of the development workflow. Only 39% of the participants agree that their product 
scales to B/DVCSs by default whereas the agreement increases to 62% if the participants are permitted to do an initial setup. More 
than 95% of the participants agree that B/DVCSs let them work more efficiently using local commits and l ightweight branches.  338to keep the previous version s just in case a developer needs to ac-
cess some  previous version.  DVCSs check -out the whole develop-
ment history, which causes  scaling issues for binary files.  On the 
other hand, CVCSs  check -out the latest version  and therefore do 
not experience similar scaling issues . 
At Microsoft, developers mainly  check -in binaries to the repository  
so that external dependencies  required to build and test  the product  
– from the compiler to the external libraries – are available , when  a 
developer checks -out the repository . This workflow is convenient 
for the developer s as they can start working immediately without  
any product -specific setup . A developer confirms this observation, 
but questions whether the binaries really belong in the VCS:  
At Microsoft, the entire tool chain  [is] in the repository. 
This is very useful becau se [the developer] has all de-
pendencies . However, I wonder if [those dependencies]  
really belong to the [repository] ? It may be better to con-
figure  and version  the dependency without checking it in.  
(ii) Composite products:  Another cause for DVCS scaling p rob-
lem is large composite products. Seven survey  participants agree 
that composite products affect DVCS scaling negatively. Some Mi-
crosoft products contains multiple sub-products . For example, Mi-
crosoft Office contains Microsoft Word, Excel, PowerPoint, an d 
OneNote in all versions. Storing  all these products inside one re-
pository makes it easier to share code and dependencies between 
these products. On the downside, the repository  contains the devel-
opment history for four products instead of one, which caus es a 
scaling problem when DVCSs check -out the whole history. CVCSs 
do not suffer from  the same overhead as whole history is stored on 
the server  only, which scale s better than development machines.  
(iii) Long development history:  The final scaling problem is due 
to the long development history for the product s. Four survey  par-
ticipants believe that scaling can be achieved by limiting the local 
history checked -out from the repository . Some  Microsoft products  
are developed longer than a decade . It is very rare that a developer 
needs the history from a decade  ago to understand or resolve a prob-
lem. Most of the time, the develop ers use very recent history , 
maybe from a miles tone back. DVCSs check -out the whole devel-
opment history by default, which increases the initial check -out 
time. In general, developers seem to start experiencing scaling is-
sues when the repository is larger than a few GB s and has a history 
longer than several years. Considering  that this is a one -time cost, the developers generally tolerate it as long as the process completes 
overnight. A developer states:  
In my case [the initial check -out] was ten hours with one 
interruption and that was okay for me.  
Since DVCSs check -out and maintain the complete development 
history , the problems  described in this section are essential to 
DVCSs. Figure 6 shows that 53 (88%) survey part icipants believe 
that DVCS scaling can be achieved for Microsoft products by solv-
ing some  of these issues. Section 7.2 will discuss alternative work-
flows and advanc ed DVCS operations that help with mitigation .   
6. TRANSITION OUTCOMES  
This section  discusses the transition outcomes. Section 6.1 revisits 
the transition expectations and problems with CVCSs , and dis-
cusses how DVCSs meet these expectations. Section 6.2 discusses 
the transition’s effect on developers’ perception for p roductivity. 
For the survey  (Figure 5), we asked the developers to limit their 
answer only to their experience at Microsoft.  
6.1 Reality Meets Expectations  
This section re visits the transition expectations described in Section 4 and 
discusses which DVCS features are used to meet these expectations.  
(i) Ability to work offline:  DVCSs check -out the whole history , 
which makes it possible to execute  all operations , except synchro-
nization with  another repository, offline . The developers  can check-
point their  work with  commits , create a private local branch for an-
other ta sk, or learn who modified  some file recently . Figure 5 shows 
that 95% of the survey participants agre e that B/DVCSs let them 
work offline.  
(ii) Incremental workflow:  Figure 5 shows that 97% of the survey 
participants agree that using B/DVCSs let them work in crementally 
though commits . Commits  act as  checkpoints ; the developer  can 
revert back to a recent version  if some c hange  causes a problem . 
The ability to create  checkpoints makes debugging ea sier. For ex-
ample, a developer states:  
Frequent [ly], you want to see your recent [changes] … 
With [DVCS] , It is likely that I had several commits  in the 
morning and I can go back to see what is broken.  
Incremental workflow with frequent  commits  raises a de bate on 
whether the developer s should check -in these commits  directly or 
transform t hese commits into a few  larger  and logical  commits  first, 
and check -in these logical commits . Most DVCSs provide ad-
vanced history manipulation  commands, such as rebasing  [10], to 
squash multiple commits into one. One developer states:  
I use rebase often. I think th e history is a code deliverable.  
Although the developers change the history to replace many small 
commits with one larger, logical c ommit, s ome developers  we inter-
viewed  felt that changing history is wrong. One alternative approach 
would abstract  the visualization of the  development hist ory rather 
then re -write  it. Another developer agrees with this observation:  
Rebasing  should  not be used for making [the history]  
more r eadable . The VCS should  know about the deltas, the 
[readability]  is just a representation problem.  
(iii) Fast and easy context switches:  Figure 5 shows that 98% of 
the survey participants agree that  lightweight branches in B/DVCSs 
let them context switch  efficient ly. Unlike most CVCSs, DVCS  
branches record deltas with respect to an ancestor in the history. So, 
switching to a branch brn requires the DVCS to check -out the an-
cestor of brn and apply the deltas. When the developer completes 
the task, s/he can merge brn to dev, a globally accessible  devel-
Figure 6: Major reasons for DVCS scaling issues for Microsoft 
products (colored). ‘No issues’ represents the case where DVCS 
scales by default. The survey also had options ‘Other reasons’ 
and ‘Impossible to scale’ which are selected by 4 and 0 partici-
pants, respec tively.  339opment  branch  and check -in the changes from  dev. For other de-
velopers, brn has negligible overhead and does not matter ; it is a s 
if the developer worked on  dev the whole time.  
All developers  we interviewed,  except one , confirmed that DVCS  
branches provide fast and easy context switching in large products 
at Microsoft. One developer points the following quirk:  
Benefit of using multiple branches were detrimental be-
cause  of the long build times between branch switching . 
This developer points out the following problem: when a developer 
switches to a branch, the code  changes and needs to  be rebuilt . For 
incremental builds, assuming that the difference betwee n two 
branches is small , this is not an issue. However, if the build is not 
incremental and a full build requires several minutes, then the de-
veloper cannot switch branches very frequently.  In such cases, hav-
ing one repository for each task and manually managing these re-
positories might be more efficient.  
(iv) Fast and easy  exploratory coding : Similar to context switch-
ing, the developers can do exploratory coding efficiently  using 
DVCS branches. When the developer has an idea, s/he creates a 
private branch , exp, and commits a few changes . Then, the devel-
oper switches  back to  other branches to work on other issues and 
forgets exp. If the work in exp becomes important in the future , 
the developer switches  back to exp, merges it with the trunk , and 
continue s the implementation from where  s/he left. DVCS branches 
encourage the developers to try out difficult and complex tasks that 
might not ship immediately without the fear of failure. A developer 
confirms this observation:  
Logistics of doing [exploratory coding]  was effortless. I 
create a branch … I can make changes without wo rrying. 
A B/DVCS can improve a developer’s workflow with local history 
and lightweight branching. However, these advantages will be use-
ful only if the developer’s project scales to the B/DVCS and the 
developer can use the existing external tools in her/his  workf low. 
If the obstacles overweigh  the benefits, it is less likely that the de-
veloper will be willing to change her/his  current workflow.  The sur-
vey shows that out of 59 participants who transitio ned, 12 of them 
are no longer using a B/DVCS . The most popular reasons for re-
turning to CVCSs are: (1) limited integration with the rest of the  
development workflow, (2) scaling issues, and (3) the fact that the 
rest of the team uses a CVCS.   
Being offline  and working on a  private  branch could  diverge the 
developer from the trunk  and cause severe conflicts when the de-
veloper merges the se changes into the trunk . In our interviews, only 
one developer raised this concern.  Microsoft developers synchro-
nize with each other frequent ly, which might mitigate the severity 
of future merge conflicts.  We leave in -depth investigation of tran-
sition’s effects on the severity of merge conflicts as future work.  6.2 Perception for Productivity  
During developer interviews, we specifically asked the developer s 
whether their perception for the following productivity metrics 
have changed after the transition: (1) code volume produced daily , 
(2) implementation speed, (3)  code  velocity , (4) and code quality . 
Figure 7 summaries the survey results . 
(i) Code volume:  Half of the developers  we interviewed  and 52% 
of the survey participants  felt producing more code after the transi-
tion whereas the other half felt no difference in terms of the code 
volume produced daily (Our question was used as a measure to 
identify developer’s perception towards  code volume  and had no 
implications on develope r productivity).  The most popular expla-
nation for the increase in volume  is commits in  B/DVCSs.  The de-
velopers could produce more code because they were able work 
more (offline) and they could commit frequently without worrying 
about going through quality gates each time.  
(ii) Implementation speed:  Six developers  we interviewed  and 
60% of the survey participants  felt faster after the transition 
whereas four developers  we interviewed and 13 % of the survey par-
ticipants  felt no difference in terms of implementation speed. The 
most popular explanation for the increase in implementation speed  
is using lightweight B/DVCS  branches for context switching . The 
developers spent less time on manually managing the context  for 
each task, which  lets them do the same work faster .  
(iii) Code velocity  (transit time) : Code  velocity is  the time that it 
takes for an edit to reach to one of the main branch es from the  
branch it was checked into [12]. Although, the developers  we inter-
viewed  felt no difference , 59% of the survey participants felt that 
their code vel ocity has increased after the transition.  Most  develop-
ers we interviewed made a transition to a BVCS. Therefore, once 
the developers synchronize with the CVCS, their check -ins would 
still go through the  same integration process  to reach to  one of the 
main branch es. A developer states:  
[Shipping code]  is a team process, it does not change with 
the VCS you use.  
(iv) Code quality : All developers  we interviewed,  except one, felt 
no difference in terms of code  correctness after the transition.  Sim-
ilarly, only 33% of the survey participants agreed that their code 
correctness  increased after the transition.  Similar to code velocity, 
the developers seems to believe that the code correctness  depends 
on personal practices and the q uality gates used by the team , rather 
than the VCS used during the development . 
Regardless of the VCS used to store  the product, using a DVCS 
seems to make the developers write more code, faster without re-
ducing the qu ality of the code or  the frequency of  deployment . The 
developers get more productive because the DVCS s support  some 
development workflows  better , such as frequent and incremental 
commits , and efficient context switching, which leaves  the devel-
opers more time to  work  on the actual implementation.  
7. DISCUSSION  
This section discusses the findings in -depth. Section 7.1 investi-
gates  whether the benefits provided by the DVCSs are e ssential . 
Section 7.2 revisits the DV CS scaling issues and presents alterna-
tive workflows and advanced DVCS features to mitigate these is-
sues. Section 7.3 discusses the importance of a fine -grained se cu-
rity model for commercial companies. Section 7.4 discusses a 
B/DVCS workflow for incubation projects that can be  adopted by 
existin g CVCS products , immediately . Section 7.5 concludes the 
discussion with recommendations  for the people  who consider tran-
sitioning . Figure 8 presents the re lated s urvey results . 
0% 20% 40% 60% 80% 100%
I implement more code.
I implement code faster.
My code velocity is faster.
My code is more correct.
S. Agree Agree Neutral Disagree S. Disagree N/AFigure 7: Transition’s effect on developer’s perception of code 
quality (colored). Half of the developers agree that, after the 
transition, they implement more code faster and their code has 
higher velocity. However, for code correctness, the developers 
have mixed feelings ( 33% agree vs. 19% disagree).  3407.1 Essential versus Non-Essential  
Section 6.1 identified two  DVCS features  that let the developer s meet 
the expectations outlined  in Section 4: (1) o ffline commits that enable  
incremental workflow, and (2) l ightweight branches that enable  effi-
cient context sw itching and exploratory coding.  This section inves-
tigates whether these fea tures are essential to DVCSs or not.  
(i) Offline commits:  DVCSs offer offline commits  easily  because 
each developer  has access to a local, private repository , which rec-
ords all information, s uch as  commit’s parent and branch , required 
to check -in this comm it to a another  repository . We believe that 
CVCSs could offer ad -hoc offline commits where the developers 
can only commit on top of the existing checked -out versions (most 
of the time only the latest version). However, we also believe that 
the CVCSs are bu ilt on the philosophy where a change in the re-
pository should be  accessible  to othe r developers  immediately . 
Therefore, we  identify  incremental workflow  via offline commits 
as essential to DVCSs.  
(ii) Lightweight branches:  Most CVCSs use file -system based 
heavyweight branches compared to pointer -based lightweight 
DVCS branches.  For example, when a new branch is created, Per-
force creates a symbolic link from each file in the new branch to 
the actual files  [13]. Using symbolic links is quite efficient in gen-
eral since Perforce only materialize s the files that are modified in 
the new branch. However, if a product has a very large number of 
files, creating lots of symbolic links might take considerable 
amount of time and introduce  substantial overhead to the server, 
where all met adata is stored. Conversely, most DVCS  branches are 
pointers to specific points in the development history, which makes 
branch creation instant. We believe that  CVCS  branch creation, de-
letion, and switching  would have been equivalently efficient if 
CVCSs implemented pointer -based branches . Consequently, we 
identify  lightweight branches as non-essential  to DVCSs.  
7.2 Revisiting DVCS Scaling Issues 
Section 5.3 explained  three major causes for DVCS scaling issues  
that the developers face . This section discuss es alternative work-
flows and DVCS operations that can mitigate these issues .  
(i) Checked -in binary dependencies:  One way to resolve  DVCS 
scaling issues due to  checked -in binary dependencies is to use a 
project  manager, similar to Maven  [14]. With a project  manager , 
the developers can specify the product dependencies using a declar-
ative language. To use a project  manager, Microsoft would setup 
an internal server that contains and serves product dependencie s. 
Now, the developers can update the product specification instead 
of checking -in the dependent binaries. When a developer checks -
out the product, s/he will not immediately have all the dependencies 
to build and test the product. However, most  project  managers  in-
tegrate with the build and test systems seamlessly, so the moment 
the developer wants to build the product, the project  manager  would 
download (or update) all dependencies, and then build the product . 
A project  manager  can purge binary dependencies  from the product 
repository  without changing the development workflow drastically.  (ii) Composite products:  To resolve the composite products prob-
lem, the product needs to be re -architected, which requires consid-
erable work. DVCSs encourage the developers  to store each prod-
uct – even each module – in a separate repository and share code 
between these repositories. For example, Git provides Submodules  
[15]: a systematic way to create a dependency to a particular point 
in another Git repository’s history. Using code sharing between 
DVCS repositories , the developers could re -architect the product so 
that the common code is stored in one DVCS  repository and the 
top-level products are stored in other DVCS  repositories. Then, the 
common repository would code share with each top -level product  
repositories . After this  re-architect ure, a developer who needs to 
work on a product, checks out the complete history for that product, 
which contains only one version of the common code . Decomposi-
tion solves  the scaling issues due to composite product s. 
(iii) Long development history:  DVCS scaling issues  for products 
with very long histories can be mitigated by check ing-out the his-
tory partially. For example, Git allows shallow clones  [16], where 
the developer limits the number of versions checked -out by a depth. 
One big disadvantage of checking -out a partial history  is that the 
developer  might not be able to  check -in her/his  changes back to 
another reposito ry if the local repository cannot perform the check -
in operation  due to missing history . In this case, the developer 
might try to check -out more of the history and retry, which is  a 
manual and tedious  process . Thus, checking -out the history par-
tially is not ideal and we do not recommend it unless the scaling 
issue becomes unbearable.  
It is possible to solve most of the scaling  problems by following 
some DVCS workflows and using advanced DVCS operations. 
However, applying thes e solutions takes time and lengthens the 
transition period, d epending on the previous development work-
flow. Therefore, we suggest the people  to consider about the 
changes that needs to be done for mitigating  the scaling problems 
and account for this cost b efore the transition.  
7.3 Fine -grained Security  in CVCS  
Four developers  we interviewed  mentioned for lar ge commercial 
companies , it is mandatory for the VCS to provide a finer -grained 
security model. Currently , DVCSs provide security only at the  re-
pository  level. If a developer has access to a repository, then s/he 
has access to all files in that repository.  Commercial software com-
panies  sometime s have  sensitive features in their products where 
only a limited number of developer should ha ve access to. These 
features  are generally stor ed inside an existing product repository , 
where other developers have access to. CVCSs let the administra-
tors update the access rules  at file -level granularity , so that the files 
related to the sensitive  feature are only accessible by the d evelopers 
who are working on that feature .  
Providing the same finer -grained security model in a DVCS is more 
difficult as DVCSs check -out the whole development history. To 
provide the finer -grained security model, the DVCS s should strip a 
0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
If supported properly, I would use a B/DVCS at Microsoft.
Advanced B/DVCS features are critical for dev. workflow.
B/DVCSs are good for incubation as sharing code is easier.
Strongly Agree Agree Neutral Disagree Strongly Disagree N/AFigure 8: Remaining survey results (colored). 96% of the developers agree that they would prefer to use a B/DVCS at Microsoft if it 
was fully supported. 80% of the developers agree that B/DVCSs are good for incubation since they make code sharing between 
developers easier. Developers have mixed feelings ( 28% agree, 23% neutral, 46% disagree) whether advanced DVCS features are 
non-critical for their workflow at Microsoft or not.  341portion of the history – depending on the access rights of the devel-
oper – before checking out. Stripping the history, similar to check-
ing-out the history partially , might create problems with some of 
the operations.  Alternatively, t he finer -grained security model  
would also work with DVCSs if the  sensitive  feature could be 
stored  in a new  repository, which would use the main product  re-
pository via DVCS code sharing . Then, t he repository for the  sen-
sitive  feature  would  be accessible by the de velopers working on 
that feature  only. 
7.4 Incubation with B/DVCS  
Four developers  we interviewed  suggested that a B/DVCS can be 
used immediately  for incubation  in an existing product that uses a 
CVCS.  Figure 8 shows that 80% of the survey participants agree 
with this suggestion.  During the incubation of a new feature , sev-
eral developers work in an agile fashion to quickly prototype and 
test the new feature. DVCS  workflow practices, such as small and  
frequent commits, and lightweight  branches, work  well with a gile 
development  [17]. Usin g a B/DVCS help s these developer imple-
ment the prototype quickly and go through the quality gates only 
once at the end , when the prototype is complete. Finally , the feature 
can be  integrated into the product’s  CVCS repository,  through 
BVCS mirroring or  transferring the DVCS history  manually . 
One particular aspect that DVCSs shine for incubation is the ability 
to share code between developers’ private local repositories. While 
developing a new feature i n an agile fashion, most of the time,  the 
developer’s changes are not ready to be checked -in to a globally 
accessible  repository. H owever , the developer s might need other  
developer s’ changes . Sharing these incomplete changes through  a 
globally accessible  repository would pollute  the development his-
tory with incomplete – and possibly non -building – versions.  
Therefore, the developers prefer to  synchronize with  another devel-
oper’s private repository directly.  Seven developers  we interviewed  
confirmed that DVCS ’s peer -to-peer sharin g works seamlessly and 
efficiently for sharing non-building and incomplete changes  be-
tween developers.  
7.5 Recommendations  
We conclude the section by providing some recommendations  for 
the developers, teams, and managers  who consider  transition ing. 
Identify the product and developer  needs carefully:  For large 
products in large companies, it is rare to use advanced DVCS oper-
ations , such a s modifying a globally accessible  history or trans-
planting a portion of the history from one branch to another. Almost all developers mentioned that DVCSs provide advanced operations  
and give  more power to the developer s compared to CVCSs, how-
ever, during the interviews,  only a few developers stress ed that 
these advanced operations are critical for their workflow . Figure 9 
summarizes the related survey results. 55 (77%)  survey  participants 
confirmed that extendin g the existing CVCSs with some offline op-
erations and lightweight branches would make the transition for 
their workflow at Microsoft unnecessary.  
If most developers are interested in only lightweight branches , 
CVCS s might be modified to provide lightweight  branches. If the 
developers a re interested in the offline commits, then a BVCS could 
be as good as a DVCS . As most of the products are already stored 
in a CVCS, transitioning to a BVCS should be less expensive than 
transitioning to a DVCS.  If the developers want to use agile p ro-
gramming for a particular feature , then using B/DVCS temporarily 
for the development of this feature might be easier than  a complete 
transition . We would like to remind the reader that w e are not sug-
gesting that the transition is inevitable  or unnecessary, rather  we 
stress  that the  transition  comes with a cost. Thus,  we hope that the  
benefits of DVCS s, alternative solutions, and the transition  cost is 
weighed correctly and in -depth  before the transition.  
Consider the tooling around VCS carefully:  Section 5.2 identi-
fied incomplete bridge implementations as one of the biggest bar-
riers for the transition. Software in large compani es are not limited 
to programming. The development process contains external tools 
for code reviews, quality controls, and packaging before a piece of 
code gets shipped in a product. Considering the external tools’ in-
tegration with the new DVCS and making sure that the new DVCS 
can interact with the existing  tools in a similar fashion the old 
CVCS did, will  increase the chance  of the transition by reducing 
the problems faced by the developers  during the transition.  Figure 
8 shows that 65% of the survey participants agree with this obser-
vation and would switch to a B/DVCS if there were proper support.   
Transition  on a team  basis:  When  transitioning to a new tool for 
an existing product , it is generally a good idea to let  a few develop-
ers – early adopte rs – do this transition first, to ensure that the ex-
isting development workflow  does not change considerably with 
the new tool. Teams an d managers might  have the same intuition 
for the transition to a DVCS where only a few developers use the 
DVCS in the team whereas the rest continue to use the existing 
CVCS.  Although the intuition is correct , this strategy creates an un-
seen barrier for th e early adopters . The developers  within the same 
team  share code and interact with each other frequently. Being an 
early adopter makes it more difficult to intera ct and share code with 
the rest of the team. Consequently, the early adopters might per-
ceive  the transition negat ively. Therefore , we suggest that all de-
velopers in a team  should  make the transition simultaneously . A 
developer confirms this observation:  
While using [a BVCS], I still need to use [CVCS]  because 
I have to  apply other developer s’ [patches] , which cannot 
be done with [ the BVCS] . 
8. THREATS TO VALIDITY  
This section outlines the internal and external threats to validity in 
the study and discusses how these threats  might affect the findings 
and their generalizability.  
Internal validity:  This study conducted a semi -structure d inter-
view with the developers. The interview questions could have bi-
ased the developers to focus on some topics  more than the others. 
We prepared  the interview questions as general as possible hoping 
that the develope rs would focus on the parts that they cared most. 
Figure 9: Survey results for the question: “Which of the follow-
ing would make the transition unnecessary for your  work at 
Microsoft?” (colored). ‘No change’ is the developers who are 
already satisfied with CVCSs for their work at Microsoft . 342Since the interviews were recorded, the developers might have be-
haved differently.  We made  the recording optional  (no one de-
clined)  to reduce any behavioral change . Finally, the card conten ts 
were created f rom our notes and recordi ngs, which might be sub-
jective . To reduce biasing our results in one way, non-authors  
helped during card sorting.   
External validity:  This study summarizes the findings  at Microsoft 
using 80 developers (across interviews and surveys). O ur findings 
might not generalize outside of Microsoft. However, during the in-
terviews, we realized that the developers were focusing on the same 
high-level topics and had very similar conc erns and comments . 
Therefore, we believe that our findings should generalize to other 
developers and products at Microsoft.  To mitigate the low number 
of interviews, we have conducted a web survey to a larger devel-
oper audience to quantify our findings fro m the interviews.   
This paper focuses  on the developers and products at Microsoft. 
The developers were  selected from multiple teams and had  varying 
levels of  familiarity with CVCSs and DVCSs. Therefore,  we be-
lieve that our findings will (partially) general ize to the developers 
and products in large companies similar to Microsoft . We think that 
the extend of this  generalization will depend on the particulars of 
the team and the product . The findings might not generalize to 
open -source software, start -ups, or  smaller products. It is future 
work to expand our study to other development settings to general-
ize the findings. We plan to use the diversity me trics introduced by 
Nagappan et  al. [18] to expand the results as much as possible.  In 
general, for empirical studies, it is necessary to build an empirical 
body of knowledge  [19]. Towards this end, we hope that our study 
helps to contribute to this body of knowledge on VCS s. 
9. RELATED WORK  
To the best of our knowledge, the closest work that compares 
CVCSs and DVCSs is Barr et al.’s [2] investigation on how the use 
of branches  and development history change  after the transition of 
large open -source software (OSS). They combine  the interviews 
with the lead devel opers in OSS projects with mined  data from 60 
OSS projects and find  that the developers started using VCS 
branches more frequently and effectively after the transition to 
DVCS, specific ally for  collaborating on the same task . de Alwis 
and Sillito [1] summarize s the transition challenges and anticipated 
benefits  for four OSS  projects  using the developer notes and docu-
mentation related to the transit ion. Our work  focuses on the transi-
tion process  at a large commercial company,  from the developer’s 
point of view and tries to identify the transition reasons, barriers, 
and outcomes .  
O’Sullivan [20] discusses the advantages and disadvantages of 
DVCSs to help developers make an informed choice of VCS.  
O’Sullivan stresses offline commits and ease of branching as some 
of the DVCS advantages, and scaling issues with large binary files 
as a DVCS disadvantage . Our work qualifies so me of  O’Sullivan’s 
claims via professional developers’ experience on the transition  
process.  Simultaneous to our study, Brindescu et al.  [21] investi-
gated how a VCS type affects the developer behavior and the de-
velopment proce ss through a survey on 820 developers and mined 
data on 132 OSS repositories.  They identify  offline commits and 
low learning curve as the top reasons to prefer DVCSs and CVCSs , 
respectively . Our work investigates  the transition process with a  fo-
cus on developers ’ experience  in a large commercial company.  
VCS s, the idea to store the development history in a structured way 
for future access and creating back -ups, have  been used  for a long 
time. Rochkind  proposed Source Code Control System (SCCS) as 
one of the earliest VCSs [22]. Initial VCSs, including SCCS,  Revi-
sion Control System  [23], ClearCase  [24], and Concurrent Version System [3] versioned each file separately . Aide -de-Camp intro-
duced the change -set notion that bundles all changes into an atomic 
entity [25]. Consecutive CVCSs, such as Subversion [4], including 
the commercial ones, such as Perforce  [26] and Team Foundation 
Server  [27], continued  using change -set notion.  
BitKeeper  [28] and Bazaar  [29] were two of the earliest  DVCS s. 
DVCSs, including Git  [6] and Mercurial  [5], aimed to impr ove the 
limited branching and merging capabilities offered by CVCSs and 
offer an easier development workflow for collaboration, especially 
in OSS  projects , where developers join to and leave from , periodi-
cally . Existing research investigated the effects of  branching [30] 
and merging  [31] on software development.  This paper investigates 
the importance of the new features added by DVCSs in large com-
mercial products that have been using CVCSs for a long time.  
Previous research showed that software quality can be improved  by 
mining software repositories and VCS histo ry to predict  files that 
have higher chance of generating defects  [32, 33] . This papers  in-
vestigates  transition reasons , barriers,  and outcomes.  
10. CONCLUSIONS  
This paper is one of the first  attempts to understand  the transition 
costs and benefits to  a DVCS in a large company. This paper pre-
sents a study  investigating such a transition based on qualitative  
interviews  and survey data . This paper identifies  ability to work of-
fline and incrementally, and managing multiple contexts efficiently 
as the major transition expectations . These expectations are satis-
fied by  commits and  lightweight branches , available on most 
DVCSs . However, the transition comes with so me barriers  due to 
steep DVCS learning curve, limited DVCS integration with the rest 
of the development workflow, and DVCS scaling issues.  An in -
depth investigation of the DVCS scaling issues  identifies  checked -
in binary dependencies, composite products, a nd long development 
history as the major  reasons. The paper discusses  how these scaling 
issues can be mitigated with alternative development workflows 
and advanced DVCS commands.  
We conclude this discussion by providing some guidelines for the 
developers , teams,  and managers who consider transitioning . We 
hope that our findings and gui delines will help those people  to make 
a better decision, and if they decide to transition, plan for the tran-
sition better and face fewer  problems.  Additionally, we hope that  
our findings for transition expectations and barriers will help re-
searchers to i dentify future research areas on  VCSs that address 
these problems and shape the future VCS design . In future, we plan 
to perform controlled studies where a reasonably sized pr oject is 
developed concurrently using DVCS and CVCS in order to com-
pare and contrast productivity and quality metrics in a comparable 
experimental scenario.  
11. ACKOWLEDGEMENTS  
We thank the anonymous reviewers,  and Caius Brindescu  and Or-
egon State SEUPL  lab for their feedback on the initial submission. 
We thank the developers at Microsoft for their interest, input, and 
help with the study. Thomas Zimmermann helped us with the de-
sign, distribution  and the analysis of the survey. Emerson Murphy -
Hill, Thomas Zi mmermann, Gifford Cheung , and Thomas Debeau-
vais helped during the card sorting. Emerson Murphy -Hill provided 
insight for Section 7. 
12. REFERENCES  
 
[1]  B. de Alwis and J. Sillito, "Why Are Software Projects Moving 
From Centralized to Decentralized Version Control Systems?," 343in the Workshop on Cooperative and Human Aspects on 
Software Engineering , Vancouver, BC, Canada, 2009.  
[2]  E. T. Barr, C. Bird, P. C. Rigby, A. Hindle, D. M. German and D. 
Premkumar, "Cohesive and Isolated Development with 
Branches," in the 15th International Conference on Fundamental 
Approaches to Software Engineering , Tallinn, Estonia, 2012.  
[3]  D. Grune, "Concurrent Versions System, a Method for 
Independent Cooperation," Vrije Universiteit, Amsterdam, 
The Netherlands, 1986.  
[4]  B. Collins -Sussman, "The Subversion Project: Buiding a 
Better CVS," Linux Journal, no. 94, p. 3, February 2002.  
[5]  "Mercuria l," [Online]. Available: http://mercurial.selenic.com. 
[Accessed 13 September 2013].  
[6]  "Git," [Online]. Available: http://git -scm.com. [Accessed 13 
September 2013].  
[7]  C. Wohlin, P. Runeson, M. Höst, M. C. Ohlsson, B. Regnell 
and A. Wesslén, Experimentation in Software Engineering, 
Springer, 2012.  
[8]  T. D. LaToza, G. Venolia and R. DeLine, "Maintaining 
Mental Models: A Study of Developer Work Habits," in the 
28th Int ernational Conference on Software Engineering , 
Shanghai, China, 2006.  
[9]  F. Shull, J. Singer and D. I. K. Sjøberg (Editors), Guide to 
Advanced Empirical Software Engineering, 2008.  
[10]  "Git Branching - Rebasing," [Online]. Available: http://git -
scm.com/book/en/Git -Branching -Rebasing. [Accessed 13 
September 2013].  
[11]  "Mercurial: Transplant Extension," [Online]. Available: 
http://mercurial.selenic.com/wiki/TransplantExtension. 
[Accessed 13 September 2013].  
[12]  C. Bird and T. Zimmermann, "Assessing the Value of 
Branches with What -if Analysis," in the 20th Symposium on 
the Foundations of Software Engineering , Research Triangle 
Park, NC, USA, 2012.  
[13]  R. Cowsam, "Introduction to Branching in Perforce," [Online]. 
Available: http://www.vaccaperna.co.uk/scm/branching.html. 
[Accessed 13 September 2013].  
[14]  "Maven," 2002. [Online]. Available: http://maven.apache.org. 
[Accessed 13 September 2003].  
[15]  "Git Tools - Submodules," [Online]. Available: http: //git-
scm.com/book/en/Git -Tools -Submodules. [Accessed 13 
September 2013].  
[16]  "Git: Clone," [Online]. Available: http://git -scm.com/docs/git -
clone. [Accessed 13 September 2013].  
[17]  L. Milanesio, "Go Agile with Git," January 2013. [Online]. 
Available : https://www.open.collab.net/media/pdfs/get -
agile -with-git-part1.pdf. [Accessed 23 February 2014].  
[18]  M. Nagappan, T. Zimmermann and C. Bird, "Diversity in 
Software Engineering Research," in the 9th Joint Meeting of the European Software Engineering C onference and the 
ACM SIGSOFT Symposium on the Foundations of Software 
Engineering , Saint Petersburg, Russia, 2013.  
[19]  V. R. Basili, F. Shull and F. Lanubile, "Building Knowledge 
through Families of Experiments," Transactions on Software 
Engineering, vol. 25, no. 4, pp. 456 -473, 1999.  
[20]  B. O'Sullivan, "Making Sense of Revision -control Systems," 
Communications of ACM, pp. 56 -62, September 2009.  
[21]  C. Brindescu, M. Codoban, S. Shmarkatiuk and D. Dig, 
"How Do Centralized and Distributed Version Control 
Systems Impact Software Changes?," in the 36th 
International Conference on Software Engineering , 
Hyderabad, India, 2014.  
[22]  M. J. Rochkind, "The S ource Code Control System," 
Transactions on Software Engineering, vol. 1, no. 4, pp. 364 -
370, December 1975.  
[23]  W. F. Tichy, "RCS - a System for Version Control," 
Software: Practice and Experience, vol. 15, no. 7, pp. 637 -
654, July 1985.  
[24]  "Rational ClearCase," [Online]. Available: http://www -
03.ibm.com/software/products/us/en/clearcase. [Accessed 
13 September 2013].  
[25]  J. Estublier (Editor), Software Configuration Management: 
ICSE SCM -4 and SCM -5 Workshops Selected Papers, J. 
Estublier,  Ed., London, UK: Springer -Verlag, 1995.  
[26]  "Perforce," [Online]. Available: http://www.perforce.com. 
[Accessed 13 September 2013].  
[27]  "Team Foundation Service," [Online]. Available: 
http://tfs.visualstudio.com. [Accessed 13 September 2013].  
[28]  "BitKeeper," [Online]. Available: http://www.bitkeeper.com. 
[Accessed 13 September 2013].  
[29]  "Bazaar," [Online]. Available: http://bazaar.canonical.com. 
[Accessed 13 September 2013].  
[30]  C. Walrad and D. Strom, "The Importance of Branching 
Mod els in SCM," Computer, vol. 35, no. 9, pp. 31 -38, 
September 2002.  
[31]  T. Mens, "A State -of-the-Art Survey on Software Merging," 
Transactions on Software Engineering, vol. 28, no. 5, pp. 
449-462, May 2002.  
[32]  N. Nagappan, A. Zeller, T. Zimmermann, K. Herzig and B. 
Murphy, "Change Bursts as Defect Predictors," in the 21st 
International Symposium on Software Reliability Engineering , 
San Jose, CA, USA, 2010.  
[33]  E. Shihab, A. Mockus, Y. Kamei, B. Adams and A. E. 
Hassan, "High -Impact Defects: A Study of Breakage and 
Surprise Defects," in the 7th joint meeting of the European 
Software Engineering Conference and the ACM SIGSOFT 
Symposium on the Foundations of Softwar e Engineering , 
Szeged, Hungary, 2011.  
  344