Views: Object-Inspired Concurrency Control
Brian Demsky
University of California, Irvine
bdemsky@uci.eduPatrick Lam
University of Waterloo
p.lam@ece.uwaterloo.ca
ABSTRACT
We present views, a new approach to controlling concur-
rency. Fine-grained locking is often necessary to increase
concurrency. Correctly implementing ﬁne-grained locking
with today’s concurrency primitives can be challenging—
race conditions often plague programs with sophisticated
locking schemes. Views ease the task of implementing so-
phisticated locking schemes and provide static checks to au-
tomatically detect many data races.
Views consist of view declarations that describe which
views of an object may be simultaneously held by diﬀer-
ent threads, which object ﬁelds may be accessed through
a given view, and which methods can be called through a
given view. A set of view annotations specify which code re-
gions hold a view of an object. Our view compiler performs
simple static checks which eliminate many data races.
We have ported three benchmark applications to use
views: portions of Vuze, a BitTorrent client; Mailpuccino,
a graphical e-mail client; and TupleSoup, a database. Our
experience indicates that views are easy to use, make imple-
menting sophisticated locking schemes simple, and can help
eliminate concurrency bugs.
Categories and Subject Descriptors
D.3.3 [ Programming Languages ]: Language Con-
structs and Features— Concurrent programming structures ;
D.1.3 [ Programming Techniques ]: Concurrent Program-
ming— Parallel programming ; D.2.4 [ Software Engineer-
ing]: Software/Program Veriﬁcation— Reliability
General Terms
Languages, Design, Reliability
Keywords
concurrency, language design, static veriﬁcation
1. INTRODUCTION
With the wide-scale deployment of multi-core processors,
developers must write parallel software to realize the ben-
eﬁts of continued improvements in microprocessors. Using
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’10, May 2-8 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.existing concurrency primitives such as locks can be diﬃ-
cult and error-prone, since these primitives force developers
to specify implementation, not policy. Currently, developers
must manually and painstakingly state how locking is to be
implemented in a software system, not why locks exist.
This paper presents a new approach to concurrency con-
trol. Instead of providing low-level concurrency primitives,
our approach raises the abstraction level of concurrency con-
trol to the level of object interfaces. A view speciﬁes both
a partial object interface and a list of incompatible object
views. A partial object interface lists a subset of the object’s
methods and ﬁelds; a thread must hold the given view to ac-
cess the part of the object’s interface protected by the view.
Additionally, the view mechanism provides concurrency con-
trol by enforcing incompatibility of views—two views are
incompatible if two diﬀerent threads cannot simultaneously
hold the two views on the same object.
Views have two primary beneﬁts. First, views enable de-
velopers to easily implement sophisticated concurrency con-
trol mechanisms which can maximize an application’s con-
currency. Views accomplish this goal by providing a simple
language mechanism which allows developers to protect sub-
sets of an object’s ﬁelds and methods. They also provide a
uniform mechanism which supports advanced concurrency
primitives such as read-write locks. Second, views can stati-
cally detect many data races. Our view compiler can analyze
view speciﬁcations and objects’ uses of views to detect and
warn about possible race conditions and unprotected ﬁeld
and method accesses.
1.1 Contributions
This paper makes the following contributions:
•View Concept: It presents a new concurrency prim-
itive that expresses concurrency control as acquisition
of partial object interfaces, or views. Views provide a
simple, natural abstraction that support a wide range
of advanced locking approaches. Views make the con-
nection between the concurrency primitive and the
data it protects explicit.
•Automatic Lock Synthesis: It presents an algo-
rithm that uses standard locks to implement views.
Our compiler uses a greedy algorithm to synthesize an
optimized implementation of views using locks.
•Static Checking: It presents several static checks
that automatically detect possible concurrency bugs.
These checks can detect view speciﬁcations that allow
race conditions on data. These checks can also detect
ﬁeld and method accesses in which the developer ne-
glected to acquire the proper object view.•Experience with Views: It presents our experi-
ence porting three signiﬁcant benchmarks to use views.
This experience indicates that it is relatively simple to
use views, that views make supporting advanced lock-
ing straightforward, and that views can help to stati-
cally detect potential concurrency bugs.
The remainder of the paper is structured as follows. Sec-
tion 2 presents an example to illustrate our approach. Sec-
tion 3 presents the view extensions to Java. Section 4 de-
scribes how we compile views. Section 5 presents our experi-
ence using views with three existing applications. Section 6
discusses related work. Finally, Section 7 concludes.
2. EXAMPLE
We present an example that illustrates the use of views.
Figure 1 presents a single-threaded implementation of the
Vector class. This Vector class contains a set() method
to set elements of the vector, a get() method which returns
the current value of an element, and a resize() method
which resizes the Vector . We omit remove() for space
reasons; its implementation would mirror that of resize() .
Views consist of two parts: view declarations, which iden-
tify the members of each view, and view annotations to Java
source code, which acquire views as needed throughout the
implementation. Figure 2 presents modiﬁcations to lines 28
through 31 of the existing Vector code to support views.
Figure 3 presents view declarations for Vector .
2.1 View Annotations
Our system allows threads to acquire views in two ways:
1) a thread may explicitly acquire a view using the acquire
statement, and 2) a thread may implicitly acquire a view by
calling a preferred method.
The statement acquire(this@resize) in Figure 2
causes the thread to acquire the resize view of the ob-
ject referenced by this before executing lines 29–30 and
then to release this view in line 31. Note how acquire gen-
eralizes Java’s synchronized construct. The relevant view
declaration (see below) explains what the view protects.
When a thread makes a call to a preferred method, such
asget() for theread view, without already holding a view
that provides access to that method, the thread will auto-
matically acquire the appropriate view and then execute the
method. A non-preferred method is only callable by threads
that already hold a view that contains the method.
2.2 View Declarations
Figure 3 declares ﬁve views: read,write ,xclRead ,
resize andcapacity . Each view, except resize and
xclRead , corresponds to a method of Vector , and states
the ﬁelds and methods required to execute that method.
The views xclRead andresize support the resize()
operation’s two phases—an exclusive-read phase, in which
resize() copies the Vector ’s contents, followed by the
resize phase, which atomically writes to the Vector .
View declarations include a view’s name and its body.
Figure 3 begins with the read view. A view body ﬁrst
lists views that are incompatible with the current view. For1public class Vector {
2intsize;
3intcapacity;
4Object[] array;
5
6publicVector() {
7size = 0; capacity = 10;
8array = new Object [capacity];
9}
10
11public Object get(inti) {
12if(i < size) returnarray[i];
13else return null ;
14}
15
16public void set(inti,Objecto) {
17if(i < capacity()) {
18array[i] = o;
19size = ((i+1)>size) ? (i+1) : size;
20}
21}
22
23public void resize(intnewcapacity) {
24Object[] newarray = new Object [newcapacity];
25for(inti=0; i < newcapacity && i < size; i++) {
26newarray[i] = array[i];
27}
28
29array = newarray; capacity = newcapacity;
30size = (size<newcapacity) ? size : newcapacity;
31
32}
33
34public int capacity() {
35returncapacity;
36}
37}
Figure 1: Sequential Vector Example.
28acquire (this@resize) {
29array = newarray; capacity = newcapacity;
30size = (size<newcapacity) ? size : newcapacity;
31}
Figure 2: Changes to Vector to support views.
example, line 2 declares that the read view is incompat-
ible with the write andresize views: no thread may
acquire an object’s read view while any other thread holds
thewrite orresize views of that object.
The view’s body also contains the view’s ﬁeld and method
declarations. A ﬁeld declaration begins with a comma-
separated list of ﬁelds followed by an access description.
Field access descriptions are one of none,readonly , or
readwrite . Line 3 declares that threads holding the read
view of aVector object may read its size,capacity , and
array ﬁelds. Note that the readonly declaration ensures
read-only access to the ﬁeld in the same sense as the Java
final modiﬁer: it does not prevent line 18 of Vector from
writing to the Vector ’s underlying array object, but only
prevents writes of the array ﬁeld itself. A method declara-
tion gives the method’s name and the types of its parame-
ters, optionally followed by the keyword preferred . Line 4
declares that the read view contains the get() method
with an integer parameter as a preferred member.1viewread {
2incompatible write, resize;
3size, capacity, array: readonly ;
4get(inti)preferred ;
5capacity();
6}
7
8viewwrite {
9incompatible read, write, resize, xclRead;
10size:readwrite ;
11capacity, array: readonly ;
12set(inti,Objecto)preferred ;
13capacity();
14}
15
16viewxclRead {
17incompatible write, resize, xclRead;
18size, capacity, array: readonly ;
19capacity();
20resize(inti)preferred ;
21}
22
23viewresize {
24incompatible read,write,resize,capacity,xclRead;
25size, capacity, array: readwrite ;
26}
27
28viewcapacity {
29incompatible resize;
30capacity: readonly ;
31capacity() preferred ;
32}
Figure 3: View Declarations for Vector Example.
All classes contain a base view, which is usually implicit.
Thebase view contains methods and ﬁelds which may be
accessed without acquiring any view. An implicit base view
contains all methods and ﬁelds not declared in other views.
However, developers may also explicitly declare a base view,
in which case the compiler includes only ﬁelds and methods
declared to belong to the base view. The base view is im-
portant for supporting object inheritance (see Section 4.2).
2.3 Checking Views
We have implemented an extension to the Polyglot exten-
sible compiler framework [14] to support view annotations,
prevent incorrect accesses to view-protected object inter-
faces, and generate executable code from the view-annotated
sources. The compilation process proceeds in three steps.
First, the compiler veriﬁes that a program properly uses
view declarations, as described below. Next, it uses the view
declarations to synthesize a lock allocation: the acquisition
of each view corresponds to the acquisition of a set of locks.
Finally, it uses the lock allocation to generate code.
We next describe how our view compiler works on our
Vector example on a method-by-method basis. The com-
piler grants constructors full access to objects. We expect
developers to follow the standard practice of not exposing
the object being constructed in the constructor.
The compiler next veriﬁes that the get() andset()
methods respect the view declaration. The compiler ob-
serves that the get() method accesses the size andarray
ﬁelds of the this object. Both of the ﬁelds have readonly
access in the read view. Because the get() method be-read
write resize
xclRead capacity
Figure 4: Incompatibility Graph GforVector .
longs only to the read view,this must have the read view
insideget() , so the compiler accepts these reads of size
andarray . The fact that get() is a preferred method is ir-
relevant to checking the implementation of get() —it only
aﬀects callers to get() , which will automatically acquire
theread view if they do not already possess it. The veriﬁ-
cation ofset() proceeds similarly. However, the compiler
also checks that the write view possesses write permissions
for thesize ﬁeld. (Recall that set() does not require
write permissions to array because it is not assigning to the
array ﬁeld itself, only to the array object.) Additionally,
becauseset() calls thecapacity() method, the com-
piler checks that the write view contains the capacity()
method. All checks succeed in our example.
We ﬁnally discuss how the compiler veriﬁes the resize()
method. Note that we chose not to add the resize method
to theresize view. Because resize() belongs to the
xclRead view, the compiler permits the read of ﬁeld array
on line 261. The method then explicitly acquires the resize
view on line 28 of the modiﬁed version of Vector , granting
it permission to write to the array ,capacity , andsize
ﬁelds. No other thread may execute any method of Vector
in parallel with the resize view—a thread attempting to
access the Vector must wait until the resize completes.
2.4 Code Generation
To generate code, the compiler must be able to reason
about relationships between views, since these relationships
determine the set of locks that it must create. It therefore
starts by generating a view incompatibility graph. Figure 4
presents the incompatibility graph Gfor our running exam-
ple. Graph vertices represent views, while edges between
two views indicate that they are incompatible. The edge in
Gbetween the read vertex and the write vertex implies
incompatibility of the read andwrite views.
Given an incompatibility graph, the lock synthesis algo-
rithm allocates locks by ﬁnding a clique covering of the
graph: we will associate a lock with each clique. To ac-
quire a view, a thread must acquire locks for all cliques that
the view belongs to. The compiler uses read-write locks2
when a clique has exactly one view vwhich is compatible
1The compiler correctly displays an error message if
resize() does not belong to any view granting access to
array , as in an earlier version of this paper.
2A read-write lock [12] can be held by any number of threads
in read mode but by only one thread in write mode.with itself. Such a situation indicates that vallows concur-
rent access to the resource being protected (corresponding
to the read mode of the read-write lock), while any views v′
in the same clique require exclusive access to the resource
(write mode). If no views in a clique are compatible with
themselves, the compiler uses an ordinary (exclusive) lock.
In our example, the three cliques C1=
{read,write ,resize },C2= {write ,resize ,xclRead },
andC3={capacity ,resize }cover the graph G. The com-
piler therefore generates three locks, ℓ1,ℓ2, and ℓ3, one per
clique. Cliques C1andC3contain exactly one view which is
compatible with itself, so the compiler uses read-write locks
for them. A thread may acquire the capacity view by
acquiring ℓ3in read mode, since capacity is compatible
with itself; similarly, it may acquire read by acquiring ℓ1
in read mode. A thread may acquire write by acquiring ℓ1
in write mode (since write is incompatible with itself) as
well as the ordinary lock ℓ2. To acquire the resize view, a
thread must acquire write locks on both ℓ1andℓ3, plus ℓ2.
The compiler generates code by applying the lock
allocation to the view acquisition statements. Intu-
itively, the compiler will translate a statement like
acquire(this@resize) into a virtual call to a method
onthis which acquires the resize view by requesting the
proper locks as per the lock allocation; the virtual call en-
sures that the thread gets the appropriate locks for the run-
time type of this, in the presence of inheritance.
To handle preferred methods, the compiler generates
a wrapper for the method which requests the view and
delegates to the original implementation. In our exam-
ple, the compiler renames the preferred method get() to
get$view() and generates a new wrapper get() , which
will hold the read view for the duration of the call to
get$view() . Should a caller to get() already hold the
read view, the compiler simply generates a call to the orig-
inal method get$view() instead of calling the wrapper.
3. VIEW LANGUAGE EXTENSIONS
Figure 5 presents the grammar for view declarations, while
Figure 6 presents the syntax extensions to Java for view an-
notations. As seen in Section 2, view declarations contain a
list of incompatible views followed by a list of view members,
which may be ﬁelds or methods. Field members have associ-
ated access descriptions ( none,readonly orreadwrite ).
Developers must unambiguously identify methods which be-
long to a view, and may optionally specify that a method is
preferred for a view. We support two kinds of view anno-
tations in Java code: 1) types may be decorated with views
(i.e.Vector@get ); and 2) our new acquire statement
generalizes Java’s synchronized statement.
4. COMPILING VIEWS
We next describe in detail how we type check views, check
consistent use of views, and automatically generate a locking
strategy that enforces view incompatibility constraints.
4.1 View Types
We have extended the Java type system to support viewviewDecl :=viewname {incompDecl
ﬁeldMethodDecls }
incompDecl :=incompatible ﬁeldList ;
ﬁeldList :=ﬁeldList ,ﬁeld |ﬁeld
ﬁeldMethodDecls :=ﬁeldMethodDecls ,ﬁeldMethodDecl |
ﬁeldMethodDecl
ﬁeldMethodDecl :=ﬁeldDecl |methodDecl
ﬁeldDecl :=ﬁeldList :accessdesc ;
accessdesc :=none |readonly |readwrite
methodDecl :=name(formallist )optpreferred ;
optpreferred :=preferred |ε
Figure 5: View Declaration.
viewtype :=typename @viewname
formal :=. . . |viewtype varname
varDecl :=. . . |viewtype varname
statement :=. . . |acquire (varname @viewname )block
Figure 6: View Annotations.
types for method parameters and local variable declarations.
A view type consists of a pair of a reference type and view.
For example, the view type Vector@write indicates a ref-
erence to a Vector object for which the executing thread
holds the write view. The type checker does not allow a
local variable or a method parameter with a non-base view
type to be re-assigned to reference a diﬀerent object.
The view type of the this variable of a virtual method m
is equal to the set of views that contain the method m. The
type checker must ensure that ﬁelds and methods accessed
through the this variable are permitted by all views that
declare the method.
Both the left and right hand sides of assignments to local
variables or method formal parameters with view types must
have the exact same view type. New views of an object can
only be acquired through an explicit acquire or through
an implicit acquisition via a call to a preferred method of a
view. A method may not have a view type as its return type,
nor may ﬁelds or arrays have view types. Collectively, these
constraints ensure that threads cannot hold a view reference
to an object after the release of a view acquired through an
acquire statement or a preferred method.
4.2 Static Checks
Compilation begins with several static checks on the view
speciﬁcations, ﬁeld accesses, and method calls. Our compiler
performs the following checks on the view declarations:
•Read/Write Hazards on Fields: For each pair of
compatible views ( v1, v2) and each ﬁeld f, the com-
piler ﬂags the ﬁeld fifv1has write access to the ﬁeld
fandv2has read or write access to f. If a view is
compatible with itself, this check ﬂags all ﬁelds thatare declared readwrite. Uncontrolled access to ﬂagged
ﬁelds may lead to race conditions. However, we antic-
ipate that developers may choose to use external locks
or other mechanisms to protect such ﬁelds. The com-
piler therefore only produces warning messages for the
read/write hazards that it detects.
•Field Read Checks: For each ﬁeld read x.f, the
compiler checks that all possible views of the receiver
expression xallow reads of ﬁeld f.
•Field Write Checks: For each ﬁeld write x.f =
y, the compiler checks that all possible views of the
receiver expression xallow writes of ﬁeld f.
•Method Call Checks: For each method call site
x.m(a 1, ..., a N)to method m(f1, ..., f N),
the compiler checks that each argument aiat the
call site matches the view type of the corresponding
method formal parameter fi, iffihas a view type.
The compiler also checks that the view of the refer-
ence to the receiver object xcontainsmor thatmhas
a preferred view.
•Assignments: The compiler checks that the pro-
gram does not make assignments to local variables or
method formal parameters with view types other than
at their initial declarations.
•Field Inheritance Check: The compiler ensures
that an object’s ﬁelds cannot be accessed through up-
casts, in violation of view constraints. To ensure ﬁeld
access safety, the compiler checks that if a ﬁeld fis de-
clared in a super class of Cand is a member of a view
vin the super class, then ﬁeld fmust be a member of
viewvin class C, with at least as permissive access.
•Method Inheritance Check: The compiler must
ensure that methods cannot be accessed through up-
casts in violation of view constraints. To ensure
method invocation safety, the compiler checks that if
a method mis declared in a super class of Cand is a
member of a view vin the super class, then method m
must also be a member of view vin class C, with at
least as permissive access. We make an exception to
this check when vis the base view, if mhas a preferred
view in class C. Note that if a method mis declared
in an interface that class Cimplements, the method
mmust either be in the base view of class Cor have
a preferred view in class C.
It is possible that a call to method o.m() may occur
such that the declared type of owould require acquir-
ing a preferred view to call m(), but the run-time type
ofoindicates that the executing thread must already
hold the appropriate view. In this case, a dynamic
check would avoid needlessly acquiring the preferred
view.
4.3 Lock Synthesis
We next describe how we synthesize a locking strategy
that enforces the view incompatibility speciﬁcation. For
each class, the lock synthesis algorithm begins by construct-
ing an undirected view incompatibility graph G. The graphGcontains a vertex vfor each view in c. For each pair of
views viandvj, ifvilistsvjas incompatible, or vilistsvj
as incompatible, Gcontains an edge between viandvj.
Consider a subgraph GCofGthat is a clique—that is,
GCcontains edges between every pair of vertices in GC.
One lock can enforce all of the view incompatibility con-
straints between views in GC. Because views can be incom-
patible with themselves, self-edges may occur in the view
incompatibility graph. We handle self-edges by using diﬀer-
ent kinds of locks. If all views but one in the clique have
self-edges, we use an implementation of a reentrant read-
write lock for the clique; we identify the read mode of the
read-write lock with the view with no self-edges, and the
write mode with all other views in the clique. This corre-
sponds to the situation where any number of threads may
hold view vwith no self-edges, but only one thread may
hold a view v′with self-edges or any of the views v′′that
are incompatible with v′. If all views in the clique contain
self-edges, then we use the normal reentrant lock class from
java.util.concurrent.locks . If more than one view
in the same clique lacks a self-edge (which we expect to be
rare in practice—views without self-edges typically only read
data, so two views without self-edges should typically not
conﬂict with each other), we would use a generalized imple-
mentation of a read-write lock which would permit multiple
mutually-incompatible read locks and a single write lock.
The lock synthesis algorithm computes a clique cover of
G. Minimizing the number of cliques in the cover minimizes
the number of locks we must generate and the number of
locks that must be acquired in a view. However, ﬁnding
a minimum clique covering for a graph is an NP-complete
problem [10]. We therefore use a greedy algorithm to com-
pute a non-minimal clique covering in polynomial time. Our
greedy algorithm selects an uncovered edge to cover to start
the clique and adds vertices that will cover other uncovered
edges. We expect that, in practice, many view incompati-
bility speciﬁcations will be simple enough that our greedy
algorithm will generate a minimal covering.
4.4 Acquiring Views
We next describe how the compiled application ac-
quires and releases views at runtime. For each view,
the compiler generates three view acquisition methods:
thetryacquireView method tries to acquire the view,
theacquireView method acquires the view, and the
releaseView method releases the view.
To acquire view v, a thread must acquire all of the locks
forv. Ifvhas a self edge in the incompatibility graph, the
thread must acquire all readwrite locks in write mode and
lock the normal reentrant locks. If vdoes not have a self
edge, the thread must acquire all locks, which will be read-
write locks, in read mode. The tryacquireView method
tries to acquire each lock. If it successfully acquires all locks,
it returns true. If it fails to acquire any of the locks, it re-
leases the locks it has already acquired, and returns false .
TheacquireView method must block until it can ac-
quire a view. To avoid the potential for internal deadlocks,
the thread cannot hold any of the component locks while
blocking. Figure 7 presents an example of an acquire method
that our compiler generates for ncomponent locks. Concep-
tually, the acquireView method arranges the locks in a
circular list. It locks the ﬁrst component lock in the list,1public void acquireView() {
2intstartindex = 0;
3while(true) {
4// Block on the first lock
5switch(startindex) {
6case0:
7 lock0.lock();
8 break;
9...
10casen-1:
11 lock(n-1).lock();
12 break;
13}
14// Try to acquire the rest of the locks
15inti;
16loop:
17for(i=1; i<n; i++) {
18 if((++startindex) == n)
19 startindex = 0;
20 switch(startindex) {
21 case0:
22 if(!lock0.trylock())
23 breakloop;
24 break;
25 ...
26 casen-1:
27 if(!lock(n-1).trylock())
28 breakloop;
29 break;
30 }
31}
32// Return if we hold all locks
33if(i == n)
34 return;
35// Release locks if we failed to get one
36intunlockindex = startindex;
37for(; i>0; i--) {
38 if((--unlockindex) < 0)
39 unlockindex = n-1;
40 switch(unlockindex) {
41 case0:
42 lock0.unlock();
43 break;
44 ...
45 casen-1:
46 lock(n-1).unlock();
47 break;
48 }
49}
50// Repeat, trying to first blocking-acquire
51// the lock that we failed to get this time.
52}
53}
Figure 7: Locking Code to Acquire A View.
waiting until this lock becomes available. It then tries to
lock the remaining component locks without blocking. If it
fails to acquire any of these locks, it releases all of the locks
and then repeats the process starting with the lock it failed
on. Once it acquires all of the locks, it has acquired the view
and returns to the caller. Of course, our compiler generates
optimized methods for the single-lock case.
Releasing views is straightforward: the releaseView
methods simply releases all locks corresponding to a view.
4.5 Simultaneously Acquiring Multiple Views
Our language supports simultaneously acquiring multi-ple views. We expect that developers will ﬁnd this mecha-
nism useful for locking multiple shared data structures while
avoiding the possibility of deadlock. The generated code for
acquiring multiple views would use the same basic strategy
as the code in Figure 7 does on component locks, but instead
uses this strategy on views.
4.6 Defaults
We have carefully designed the defaults for views to mini-
mize instrumentation overhead. Our compiler automatically
generates the base view if the developer does not explicitly
declare a base view, according to the following rules:
1. A ﬁeld is present in the base view with readwrite
access if no other view declares that ﬁeld.
2. A method is present in the base view if no other view
declares that method.
Object constructors often write to many object ﬁelds that
would be protected by views and call methods that require
access to views. If treated like other methods, object con-
structors would have to acquire a number of views to access
these ﬁelds. However, it is relatively rare for object con-
structors to make the object being constructed accessible to
other threads before the constructor exits. Our implemen-
tation therefore allows the constructor to access ﬁelds and
methods of the object being constructed without holding
the necessary views. We believe that this is a reasonable
tradeoﬀ between usability and detecting possible races.
5. EXPERIENCE
We next discuss our experience adding views to several ap-
plications: Vuze, a ﬁle-sharing (BitTorrent) client; Mailpuc-
cino, a graphical e-mail client; and TupleSoup, a database.
5.1 Methodology
We have developed a prototype implementation of views
as an extension to the Polyglot extensible compiler infras-
tructure [14]. The source code for our extension is available
athttp://demsky.eecs.uci.edu/views/ .
5.2 Vuze Buddy Plugin
Our ﬁrst benchmark is a subsystem of the open-source
Vuze ﬁle-sharing client. The source distribution of Vuze is
available at http://azureus.sourceforge.net . While
Vuze contains 194,000 lines of code in all, we chose to con-
centrate on the buddy plugin of Vuze, which consists of
13,500 lines of code. This plugin is implemented in the
com.aelitis.azureus.plugins.net.buddy package.
Parts of the buddy plugin contain a rich locking struc-
ture. After inspecting the code, we chose to annotate the
BuddyPluginTracker andBuddyPlugin classes. The
other classes in the plugin use locking solely to protect data
structure accesses: before an access to a non-thread-safe
data structure (typically a MaporList), Vuze acquires the
lock on that data structure. Views interoperate smoothly
with ordinary Java synchronized statements implement-
ing such simple locking strategies.1viewread_state {
2incompatible write_state;
3current_publish, latest_publish, buddies,
4buddies_map, config_dirty,
5republish_delay_event, last_publish_start,
6unauth_bloom, ygm_unauth_bloom,
7bogus_ygm_written, write_bogus_ygm: readonly ;
8}
9
10viewwrite_state {
11incompatible read_state, write_state;
12current_publish, latest_publish, buddies,
13buddies_map, republish_delay_event,
14last_publish_start, unauth_bloom,
15ygm_unauth_bloom, config_dirty,
16bogus_ygm_written, write_bogus_ygm: readwrite ;
17}
18
19viewpd_queue {
20incompatible pd_queue;
21pd_queue: readwrite ;
22}
23
24viewpublish_write_contacts {
25incompatible publish_write_contacts;
26publish_write_contacts: readwrite ;
27}
Figure 8: Views for BuddyPlugin class.
BuddyPlugin annotations.
We added 4 views to BuddyPlugin : general read and
write views read_state andwrite_state , for mutable
ﬁelds previously protected by the lock on the BuddyPlugin
object itself (i.e. synchronized(this) ), as well as views
to protect the pd_queue andpublish_write_contacts
data structures. Our compiler found a few ﬁeld reads that
were inconsistently unprotected in the original code.
Our change preserves the existing lock structure and also
provides static guarantees that the program doesn’t attempt
to access protected state without the protecting lock.
BuddyPluginTracker annotations.
We found that the tracker.BuddyPluginTracker
class contained the most interesting locking structure
in the buddy plugin. This class contains 5 dif-
ferent locks: online_buddies ,actively_tracking ,
tracked_downloads ,buddy_peers , and on the this
object. We carefully studied the ﬁelds that the class ac-
cessed under each lock and encoded this information in our
view declarations.
Figure 9 presents the view declarations for the
tracker.BuddyPluginTracker class. We converted the
5 locks into 6 views, splitting accesses to this into read-
only and read-write views read_internal_state and
write_internal_state , respectively, and changing the
other locks into views.
Theactively_tracking view protects accesses to the
actively_tracking Set . Its access pattern is similar to
that of the other data structures in the buddy plugin.
Theonline_buddies view protects two correlated
data structures: the online_buddies Set and the
online_buddy_ips Map . Our view annotations there-
fore express the formerly-implicit connection between the
online_buddies lock and the online_buddy_ips data
structure and statically ensure that the program always fol-1viewactively_tracking {
2incompatible actively_tracking;
3actively_tracking: readwrite ;
4}
5
6viewonline_buddies {
7incompatible online_buddies;
8online_buddies, online_buddy_ips:
9readwrite ;
10}
11
12viewtracked_downloads {
13incompatible tracked_downloads;
14tracked_downloads, last_processed_download_set_id,
15last_processed_download_set, download_set_id,
16full_id_map, short_id_map: readwrite ;
17}
18
19viewread_internal_state {
20incompatible write_internal_state, buddy_peers;
21online_enabled, old_plugin_enabled,
22plugin_enabled, old_tracker_enabled,
23tracker_enabled, old_seeding_only, seeding_only,
24consecutive_fails, last_fail, network_status,
25buddy_send_speed, buddy_receive_speed: readonly ;
26}
27
28viewwrite_internal_state {
29incompatible read_internal_state,
30write_internal_state, buddy_peers;
31online_enabled, old_plugin_enabled,
32plugin_enabled, old_tracker_enabled,
33tracker_enabled, old_seeding_only, seeding_only,
34consecutive_fails, last_fail: readwrite ;
35}
36
37viewbuddy_peers {
38incompatible read_internal_state, buddy_peers,
39write_internal_state;
40seeding_only: readonly ;
41buddy_peers, buddy_stats_timer, network_status,
42buddy_send_speed, buddy_receive_speed:
43readwrite ;
44}
Figure 9: Views for BuddyPluginTracker class.
lows the proper locking discipline.
Thetracked_downloads ﬁeld protects six related
ﬁelds, including two sets and two maps. In the original
version of the BuddyPluginTracker , the application al-
ways acquired the tracked_downloads lock before access-
ing any of these ﬁelds.
Finally, the three views read_internal_state ,
write_internal_state andbuddy_peers all protect
miscellaneous internal state of the BuddyPluginTracker .
Both the write_internal_state andbuddy_peers
views provide write access to diﬀerent parts of the tracker.
Theread_internal_state view is not incompatible with
itself, so multiple threads may simultaneously read internal
state. Each of the write views is incompatible with itself
and with the read_internal_state view.
We found that views enable developers to conﬁdently use
ﬁne-grained concurrency patterns. Using the view declara-
tions, our compiler statically veriﬁes that the code always
acquires the appropriate locks.1viewlookup {
2incompatible modify;
3KeyValues: readonly ;
4getAsByteArray( ObjectKey)preferred ;
5get(Objectkey)preferred ;
6flush() preferred ;
7getKeys() preferred ;
8close() preferred ;
9}
10
11viewmodify {
12incompatible modify, lookup;
13KeyValues: readwrite ;
14put(ObjectKey,ObjectValue)preferred ;
15remove(ObjectKey)preferred ;
16keepOnlyThese(Vector Keys) preferred ;
17compact() preferred ;
18getAsByteArray( ObjectKey);
19}
20
21viewfile {
22incompatible file;
23Data:readwrite ;
24DataFile: readonly ;
25}
26
27viewindexfile {
28incompatible indexfile;
29IndexFile: readonly ;
30}
Figure 10: Mailpuccino Cache Views
5.3 Mailpuccino
Mailpuccino is an open-source graphical mail client writ-
ten in Java that supports the POP3 and IMAP protocols.
Mailpuccino is available at http://www.kingkongs.
org/mailpuccino/ . It contains over 14,000 lines of code.
Mailpuccino maintains separate cache data structures for
the message headers, message ﬂags, message parts, and the
message structure. The locking for the original cache objects
used synchronized methods. The original coarse-grained
locking structure only allowed one thread to read from the
message cache at a time.
Figure 10 presents the views that we wrote for Mailpuc-
cino’sCache object. We created four views in all, belonging
to two sets of two views each.
The ﬁrst set of views includes the lookup view and
modify view for the Mailpuccino cache. The lookup view
provides read-only access, enabling methods to safely read
the cache, while the modify view provides read-write ac-
cess, allowing methods to safely modify the cache. Multiple
threads may simultaneously read from Cache objects, so the
lookup view is compatible with itself. However, while any
thread is modifying the Cache object, no other threads can
safely access that Cache object at the same time. There-
fore, themodify view is incompatible with both itself and
thelookup view. Note that our use of views enables the
Cache object to potentially support multiple simultaneous
lookup operations.
The second set of views includes the file and
indexfile views. Each cache is backed by two ﬁles: the
DataFile ﬁle and its index, IndexFile . Cache misses
are served from these ﬁles. While the lookup view con-
ceptually protects these accesses and prevents simultaneous
writes, Java’s RandomAccessFile object does not supportatomic reads from a speciﬁc ﬁle oﬀset, so Mailpuccino per-
forms a seek followed by a read. We must therefore ensure
that no other thread accesses the ﬁle object between the
seek and the read operations. To do so, we created two
more views to protect the ﬁle objects. Only threads which
have acquired these self-incompatible views may access the
ﬁelds that reference the corresponding ﬁles. This ensures
that only one thread may seek and read from a ﬁle at a
time. While we have described our changes to Cache , we
also modiﬁed the MsgPartsCache class in a similar fashion.
We next modiﬁed the synchronized methods in the
MonitoredInputStream class to use views. This class
contained two synchronized methods: the mark method and
thereset method. The “synchronized” annotations led us
to believe, at ﬁrst, that the class was designed to be safely
shared between threads. The mark andreset methods ac-
cess only two ﬁelds: MarkedBytesRead andBytesRead .
We wrote a view that allowed access to these ﬁelds and
added the mark andreset methods to the view.
At this point, we believed that we had distilled
MonitorInputStream ’s old synchronization pattern into
views. We therefore attempted to compile the modiﬁed
class. Surprisingly, the compiler threw error messages warn-
ing thatMonitorInputStream ’sread method accesses
theByteRead ﬁeld without holding an appropriate view.
However, the read method contained no synchronization!
Closer examination revealed that the
MonitoredInputStream class is not thread safe and
itsmark andreset methods are never called. We modiﬁed
the class to remove these methods and added comments to
make it clear that the class is not thread safe.
5.4 TupleSoup
TupleSoup is an open-source database library written in
Java. TupleSoup is available at http://sourceforge.
net/projects/tuplesoup/ . TupleSoup contains over
6,600 lines of code. We rewrote all of the synchronization in
TupleSoup to use views.
TupleSoup contains three index classes: a MemoryIndex
class, aPageIndex class, and a FlatIndex class. The
original index classes only permitted one thread to search
the index at a time. We created two views per index class:
anaccess view and a modifying view. Multiple threads
can simultaneously hold the access view. If one thread
holds themodifying view of an index, no other thread can
hold themodifying oraccess views of the index.
TheDualFileTable class implements a cached table
backed by two separate ﬁles. The original version of
DualFileTable contained four separate locks: one lock
for each of the two data ﬁles, a lock for the cache, and a
lock for the statistics counters. We ﬁrst examined the code
to see if we could modify the class to allow multiple simul-
taneous calls to the getCacheEntry cache lookup method.
Unfortunately, this method actually mutates a list of least-
recently-used cache entries that is used to determine which
entries to evict. Therefore, it is not safe to allow multiple
threads to simultaneously call the getCacheEntry method.
We ﬁnally used a straightforward translation to views,
shown in Figure 11, which replaces each lock with a cor-
responding view, and synchronized methods with preferred
views for methods. Such a translation is quite straightfor-
ward to carry out and enables developers to explicitly ex-1viewfilea {
2incompatible filea;
3fileastream, filearandom,
4fca, fileaposition: readwrite ;
5updateRowA(Row row) preferred ;
6addRowA(Row row) preferred ;
7}
8viewfileb {
9incompatible fileb;
10filebstream, filebrandom, fcb, filebposition:
11readwrite ;
12updateRowB(Row row) preferred ;
13addRowB(Row row) preferred ;
14}
15
16viewindexcache {
17incompatible indexcache;
18indexcache, indexcacheusage, indexcachefirst,
19indexcachelast: readwrite ;
20addCacheEntry(TableIndexEntry entry) preferred ;
21updateCacheEntry(TableIndexEntry entry)
22preferred ;
23removeCacheEntry(String id) preferred ;
24getCacheEntry(String id) preferred ;
25}
26
27viewstat {
28incompatible stat;
29stat_add, stat_update, stat_delete,
30stat_add_size, stat_update_size,
31state_read, stat_read_size,
32stat_cache_hit, stat_cache_miss,
33stat_cache_drop: readwrite ;
34readStatistics();
35}
Figure 11: TupleSoup DualFileTable Views
press the correlations between ﬁelds that the locking struc-
ture implicitly encoded. In other words, the views explicitly
label the data that each lock protects, and our view com-
piler provides static assurances that the code never accesses
protected ﬁelds without holding an appropriate view.
5.5 Discussion
We used the following process for annotating an existing
class with views. First, we studied an existing class’s locking
structure. Next, we proposed a view structure which would
protect a related group of ﬁelds and methods, typically with
a read-only view for accessing state and a read-write view
for updating state. We fed this view structure to our com-
piler, which guaranteed that accesses to protected ﬁelds and
methods only occur when holding appropriate views.
We found that it was straightforward to replace the tradi-
tional Java locking structure with view acquisitions; it suf-
ﬁced to replace synchronized(x) withacquire(x@v)
and synchronized methods with preferred view methods.
Each benchmark took a couple of hours to annotate; the
crux was in understanding the existing locking structures.
Our process typically results in an application with in-
creased potential for concurrency. Many of our annotated
benchmarks allow multiple threads to simultaneously read
state, while ensuring that only one thread can write state.6. RELATED WORK
We discuss three threads of work related to expressing
Java concurrency patterns: type systems which ensure the
absence of races; static and dynamic race detection tools;
and automatic generation of locking schemes.
Many teams have developed diﬀerent type systems which
ensure that well-typed programs are free of data races. Boy-
apati, Lee and Rinard have developed type systems which
ensure the absence of data races by tracking object owner-
ship [3, 2]. Abadi, Flanagan and Freund have developed
RaceFreeJava [7], where developers associate a lock with
each shared ﬁeld and express this information via the type
system; the compiler infers additional type annotations and
veriﬁes that programs conform to the speciﬁed type-based
discipline. Bacon, Strom and Tarafdar propose the Guava
race-free dialect of Java [1], which forces all members of
shared objects to synchronized. Views generalize RaceFree-
Java by allowing developers to specify the locking policy for
a set of related ﬁelds and methods, not just for one ﬁeld at
a time as in the RaceFreeJava case. That is, views allow
developers to explicitly express, in one place, the state and
methods protected by each lock. Moreover, unlike previ-
ous approaches, views are not limited to using simple Java
locks to guarantee race-freedom; they can leverage read-
write locks and other more sophisticated approaches to con-
currency control. Views provide developers with a ﬂexible
mechanism that can be used to implement sophisticated ap-
proaches to concurrency control.
An alternate approach to statically ensuring that pro-
grams are free of races is to detect these races, either stat-
ically or dynamically. The Eraser dynamic race detection
tool computes lock sets for memory locations and warns if
a memory location is not protected by a lock [15]. Choi
et al. have developed a runtime approach that records ac-
cess events and uses several optimizations to minimize over-
heads [4]. Marino et al’s LiteRace tool uses sampling to min-
imize overheads [13]. Other dynamic approaches use static
analysis to lower the instrumentation overhead [17]. While
dynamic race detection is useful, it requires adequate test
suites to detect bugs. RacerX instead uses interprocedural
static analysis to detect race conditions and deadlocks [6].
Other static analysis include Warlock [16] and Sema [11].
Race detection tools are, in general, useful for detecting bugs
in programs. However, they provide developers with little
guidance about which ﬁelds need to be protected by locks.
Any solution requires developers to formulate a suitable con-
currency control policy for their system. Views enable devel-
opers to express concurrency control policies; the compiler
then automatically computes a mechanism for implementing
the policy. Views therefore diﬀer from race detection and
race-free type systems approaches because those approaches
only verify that implemented solutions are free of races.
Another technique related to ours is that of automatically
generating locking schemes for critical regions [8, 5, 9]. Typ-
ically, such approaches allow developers to specify critical or
atomic sections of their programs. Zhang et al. state a min-
imal lock assignment problem that is similar to the problem
of lock synthesis for views, but diﬀers in that it contains
information about non-conﬂicting critical sections that are
never executed concurrently and therefore can share locks
without limiting concurrency [18]. This body of work must
rely on static analysis to generate locks and therefore maygenerate overly conservative locking schemes. Furthermore,
this work does not attempt to detect possible data races aris-
ing from accessing shared state outside of critical regions.
Views instead start with a data-centric approach: develop-
ers declare certain ﬁelds (and methods) as belonging to a
view, and specify when threads acquire views; the compiler
then ensures that the program always acquires appropriate
views, and synthesizes a locking strategy which respects the
view annotations.
7. CONCLUSION
Views can be an eﬀective tool for implementing sophisti-
cated concurrency control and statically detecting possible
concurrency bugs. A developer using views writes a set of
view declarations and annotates code with view acquisitions.
A view declaration describes which views of an object may
be simultaneously held by diﬀerent threads and the parts of
the object interface that the view controls. The partial ob-
ject interface speciﬁes which ﬁelds can be read, which ﬁelds
can be written, and which methods can be called through
the view. Our compiler performs static checks of the view
speciﬁcations and the program’s use of views to detect many
concurrency bugs. Our compiler automatically synthesizes
a locking scheme that enforces the view compatibility con-
straints. Our experience indicates that views are simple
to program with, support sophisticated ﬁne-grained access
control, and can detect concurrency bugs. Our approach
promises to ease the diﬃcult task of implementing locking
schemes for ﬁne-grained concurrency.
Acknowledgments.
This research was partially supported by the National
Science Foundation under grants CCF-0846195 and CCF-
0725350. We would like to thank the anonymous reviewers
for their helpful comments and attention to detail, espe-
cially with respect to the resize() implementation of the
Vector class.
8. REFERENCES
[1] D. F. Bacon, R. E. Strom, and A. Tarafdar. Guava: A
dialect of Java without data races. In Proceedings of
the International Conference on Object-Oriented
Programming, Systems, Languages, and Applications ,
2000.
[2] C. Boyapati, R. Lee, and M. Rinard. Ownership types
for safe programming: Preventing data races and
deadlocks. In Proceedings of the ACM Conference on
Object-Oriented Programming, Systems, Languages,
and Applications , 2002.
[3] C. Boyapati and M. Rinard. A parameterized type
system for race-free Java programs. In Proceedings of
the ACM Conference on Object-Oriented
Programming, Systems, Languages, and Applications ,
2001.
[4] J. Choi, K. Lee, A. Loginov, R. O’Callahan, V. Sarkar,
and M. Sridharan. Eﬃcient and precise datarace
detection for multithreaded object-oriented programs.
InProceedings of the ACM Conference on
Programming Language Design and Implementation ,
2002.[5] M. Emmi, J. S. Fischery, R. Jhala, and R. Majumdar.
Lock allocation. In Proceedings of the 34th Annual
ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages , 2007.
[6] D. Engler and K. Ashcraft. RacerX: Eﬀective, static
detection of race conditions and deadlocks. In
Proceedings of the Nineteenth ACM Symposium on
Operating Systems Principles , 2003.
[7] C. Flanagan and S. N. Freund. Type-based race
detection for Java. In Proceedings of the International
Conference on Programming Language Design and
Implementation , 2000.
[8] R. L. Halpert, C. J. Pickett, and C. Verbrugge.
Component-based lock allocation. In Proceedings of
the 16th International Conference on Parallel
Architecture and Compilation Techniques , 2007.
[9] M. Hicks, J. S. Foster, and P. Pratikakis. Lock
inference for atomic sections. In TRANSACT , 2006.
[10] R. Karp. Reducibility among combinatorial problems.
InProceedings of a Symposium on the Complexity of
Computer Computations , 1972.
[11] J. A. Korty. Sema: A lint-like tool for analyzing
semaphore usage in a multithreaded UNIX kernel. In
Proceedings of the USENIX Winter Technical
Conference , 1989.
[12] Y. Lev, V. Luchangco, and M. Olszewski. Scalable
reader-writer locks. In Proceedings of the twenty-ﬁrst
annual symposium on Parallelism in algorithms and
architectures , pages 101–110, New York, NY, USA,
2009. ACM.
[13] D. Marino, M. Musuvathi, and S. Narayanasamy.
LiteRace: Eﬀective sampling for lightweight data-race
detection. In Proceedings of the 2009 ACM SIGPLAN
conference on Programming Language Design and
Implementation , 2009.
[14] N. Nystrom, M. R. Clarkson, and A. C. Myers.
Polyglot: An extensible compiler framework for Java.
InProceedings of the 12th International Conference on
Compiler Construction , 2003.
[15] S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, and
T. Anderson. Eraser: A dynamic data race detector
for multi-threaded programs. In Proceedings of the
Symposium on Operating Systems Principles , 1997.
[16] N. Sterling. Warlock: A static data race analysis tool.
InProceedings of the USENIX Winter Technical
Conference , 1993.
[17] C. von Praun and T. Gross. Object-race detection. In
Proceedings of the International Conference on
Object-Oriented Programming, Systems, Languages,
and Applications , 2001.
[18] Y. Zhang, V. C. Sreedhar, W. Zhu, V. Sarkar, and
G. R. Gao. Minimum lock assignment: A method for
exploiting concurrency among critical sections. In
Proceedings of the International Workshop on
Languages and Compilers for Parallel Computing ,
2007.