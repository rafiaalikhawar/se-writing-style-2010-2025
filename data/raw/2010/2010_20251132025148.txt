Version-consistent Dynamic ReconÔ¨Åguration
of Component-based Distributed Systems
Xiaoxing May, Luciano Baresi, Carlo Ghezzi, Valerio Panzica La Manna, Jian Luy
xxm|lj@nju.edu.cn, baresi|ghezzi|panzica@elet.polimi.it
Politecnico di Milano, Dipartimento di Elettronica e Informazione, 20133 Milano, Italy
yNanjing University, State Key Laboratory for Novel Software Technology, 210093 Nanjing, China
ABSTRACT
There is an increasing demand for the runtime recongura-
tion of distributed systems in response to changing environ-
ments and evolving requirements. Reconguration must be
done in a safe and low-disruptive way. In this paper, we pro-
pose version consistency of distributed transactions as a safe
criterion for dynamic reconguration. Version consistency
ensures that distributed transactions be served as if there
were operating on a single coherent version of the system de-
spite possible recongurations that may happen meanwhile.
The paper also proposes a distributed algorithm to maintain
dynamic dependences between components at architectural
level and enable low-disruptive version-consistent dynamic
recongurations. An initial assessment through simulation
shows the benets of the proposed approach with respect to
timeliness and low degree of disruption.
Categories and Subject Descriptors
D.2.7 [ Distribution, Maintenance, and Enhancement ]
General Terms
design, reliability, management
Keywords
Dynamic reconguration, Version-consistency, Component-
based distributed system
1. INTRODUCTION
Oftentimes component-based distributed systems (CBDSs)
must cope with changes in the environment in which they
are embedded and in the requirements they must satisfy.
Such changes may be hard to predict at design time or they
may be too expensive to identify and handle by the initially
designed software. It is therefore necessary to modify exist-
ing parts of the implementation or add new functionality at
runtime without blocking the system.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE‚Äô11, September 5‚Äì9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.Compared to o-line maintenance, dynamic modications
are more dicult since in addition to the correctness of the
new version, they must also preserve the correct completion
of on-going activities. At the same time, they should also
minimize the interruption of system's service (usually called
disruption ) and the delay with which the system is updated
(also called timeliness ).
Dynamic recongurations (of CBDSs) are not trivial [15,
25, 27]. A safe approach that avoids the direct manipula-
tion of application-specic states enables the recongura-
tion of components after they have reached a quiescence
status [15]. This approach has the advantage of a clear sep-
aration of concerns between computation and architectural
(re)conguration. But since reconguration is oblivious to
application states, it must be conservative. It blocks all
potentially dependent computations before enabling any re-
conguration to ensure consistency, and thus it may bring
more disruption than necessary.
The quiescence-based approach only considers static de-
pendences between components specied by architectural
congurations. Since these dependences pessimistically in-
clude all potential constraints among transactions, one can
reduce disruption by considering dynamic dependences. The-
se are temporal relationships between components caused
by on-going transactions, and they only indicate the current
constraints on the recongurability of the system. Multi-
ple transactions are allowed to run during reconguration,
thus reducing the degree of disruption and improving the
timeliness of the reconguration.
Existing proposals ( [4, 7, 25]) only use dynamic depen-
dences to ensure some local consistency properties. In con-
trast, the approach presented in this paper exploits them
to ensure the \global" consistency of multi-party distributed
transactions through the notion of version consistency . Dy-
namic recongurations are seen as (sequences of) runtime
updates of components; version consistency ensures that ev-
ery transaction be entirely served by either the old versions
of system's components or by the new ones, no matter when
the reconguration happens. This approach introduces less
disruption than the quiescence-based one since a component
can be updated even when it is not quiescent, but it has not
been used yet or it will not be used anymore by any on-going
transaction.
Besides version consistency as a new criterion for the safe
dynamic reconguration of CBDSs, the paper also proposes
a management framework for multi-party distributed trans-
actions. The framework exploits dynamic dependencies, a
distributed algorithm to update the dependency model ac-
245
cordingly at runtime, and a locally checkable condition that
is sucient to ensure version-consistent dynamic recongu-
rations.
The rest of the paper is organized as follows. Section 2
introduces our model of CBDS and the challenges posed by
dynamic reconguration. Section 3 highlights the limita-
tions of the two most representative approaches and paves
the ground for our proposal. Section 4 presents version con-
sistency and the management framework. Section 5 summa-
rizes the main results of the assessment conducted to evalu-
ate the proposal. Section 6 surveys related approaches and
Section 7 concludes the paper.
2. PROBLEM SETTING
Similarly to UML component diagrams, a component-
based distributed system may be described as a set of com-
ponents (nodes ) with in-ports and out-ports. Components
are linked by directed edges from out-ports to in-ports. The
resulting directed graph is called the system's static cong-
uration , where each node is tagged with the current version
of the component it represents. A static conguration can
be described as follows:
Denition 1 (Static Configuration). A static con-
guration of a component-based distributed system is a di-
rected graph whose nodes represent versioned components
with in-ports and out-ports. A directed edge, from the out-
port of a given node Nto the in-port of other node M, rep-
resents a static dependence, that is, the possibility for Nto
require a service provided by M.
	

Figure 1: Our example system.
Figure 1 shows an example system used throughout the
paper. A portal component ( Portal) interacts with an au-
thentication component ( Auth) and a business processing
component ( Proc), while Proc interacts with both Auth and
a database component ( DB). This means that Portal stati-
cally depends on Proc andAuth, and Proc depends on Auth
andDB.
Our approach supports the dynamic recongurations of
CBDSs with transactional behavior, that is, systems whose
execution evolves through atomic, separate tasks (transac-
tions). This model is largely adopted in many applications:
from systems implemented on top of component-based in-
frastructures (like EJBs or Spring) to service-oriented appli-
cations.
Atransaction is a sequence of actions executed by a com-
ponent that completes in bounded time. Actions include lo-
cal computations and message exchanges. Transactions are
described by the rectangles T0..T4in the sequence diagram
shown in Figure 2, which is used hereafter as an example.
A transaction Tcan be initiated by an outside client or by
PortalAuthProcDBBgetT oken(cred)
return token
process(token, data)
verify(token)
OK
dbOperation() T0T1
T2T3
T4A
C
DFigure 2: Detailed scenario.
another transaction T0.Tis called a root transaction in the
former case and a sub-transaction (ofT0) in the latter case.
If a transaction Tinitiates sub-transactions, T, along with
its sub-transactions, is said to be a distributed transaction .
For example, T4is a sub-transaction of T2in the sequence
diagram of Figure 2. The host component (node) of trans-
actionTis denoted as hT.
The termsub(T 1;T2) denotes that T2is a direct sub-
transaction of T1. A transaction can only be a direct sub-
transaction of one transaction. The set ext(T) =fxjx =
T_sub+(T;x)gis the extended transaction set ofT, which
containsTand all its direct and indirect sub-transactions.
The extended transaction set of a root transaction models
the concept of distributed transaction that can span over
multiple components. By denition, a root transaction is
not a sub-transaction of any other transaction. A root trans-
action has a unique, system-wide identier. For each trans-
actionT,hTmust know root(T), which is the identier of
the root transaction of T.
A transaction can initiate a sub-transaction on a neigh-
bor component only when the host component of the ini-
tiating transaction is statically dependent on the neighbor
component in charge of executing the sub-transaction. For
example, the sequence diagram of Figure 2 illustrates a dis-
tributed transaction, where root transaction T0initiatesT1
andT2. In turn transaction T2initiatesT3andT4. We also
assume that transactions are also always notied of the com-
pletion of their sub-transactions and that a transaction can-
not end before the termination of its sub-transactions. The
other messages exchanged between hTandhTi|because of
Tand its direct sub-transaction Ti| are temporally scoped
between the two corresponding messages that initiate Tiand
notify its completion.
Figure 2 shows a detailed usage scenario for the example
system. The Portal rst gets an authentication token from
Auth and then uses it to require the service from Proc.Proc
veries the token through Auth and then starts computing,
and interacting with DB. If we consider the root transac-
tionT0atPortal, its extended transaction set is ext(T0) =
fT0;T1;T2;T3;T4g, whereT1atAuth is in response to the
getToken request,T2atProc in response to process ,T3at
Auth in response to verify , andT4atDBforT2's request of
database operations.
Dierent transactions may run concurrently in the system.
246If the executions of two transactions on the same component
do not interfere with each other, we assume they are safe.
In contrast, if they compete for some resources, we rely on
theisolation [11] provided by components to regulate the
access.
2.1 Runtime updates
A dynamic reconguration policy denes when the update
can be performed and how it must be accomplished to keep
the system consistent.
A dynamic reconguration is an atomic sequence of run-
time updates of components1. More rigorously, an update
is specied as a tuple <;!;!0;T;s>, where  is the orig-
inal system's conguration and !is the set of components
that must be substituted by the new versions in !0. The
update happens when the system is in state s, and the state
transformerTtrasformssintos0=T(s), which is a state of
the updated system with conguration 0= [!0=!]2. The
system is expected to continue from s0with no externally-
visible erroneous behavior. The (global) state of a CBDS
comprises the local states of all components and all messages
in transit. The state transformer is dened on global states,
but in practice one can hardly manipulate states other than
those local to the to-be-updated components.
We assume that given a runtime update <;!;!0;T;s>,
the corresponding o-line update <;!;!0>is correct.
This means that the transactions running on  satisfy the
old system specication Sand the transactions on 0=
[!0=!] satisfy the new specication S0. Given the distrib-
uted nature of these transactions we can only adopt a weak
denition of correctness of a runtime update , which is de-
ned as follows:
The transactions that end before the update satisfy S;
The transactions that begin after the update satisfy
S0;
The transactions that begin before the update, and
end after it, satisfy either SorS0.
For example, if we consider the running example, one may
assume that Auth be updated to exploit a stronger encryp-
tion algorithm to prevent security threats. Although the
new algorithm is incompatible with the old one, the other
components need not to be updated because all encryp-
tion/decryption operations are done within Auth. The spec-
ication of all other transactions remains unchanged; the
o-line update would be \easy" and we assume it to be cor-
rect. The problem is that if we update Auth at runtime, we
should ensure that all running transactions execute correctly
before and after the update. If the update were allowed to
happen any time, it would be dicult to ensure it [12]. An
obvious restriction on when the update can happen is to
impose that components targeted for update be idle.
Denition 2 (Idle Component). A component is idle
i it is not currently hosting transactions and its current lo-
cal state is equivalent to the initial one.
1We consider any architectural change that can be treated
as a replacement of components. For example, service re-
bindings can be seen as updates of the components that
implement the services.
2This is to say that 0is equal to  where all components
in!have been substituted by the new versions in !0.Note that if we restrict updates to occur when components
are idle thenTonly needs to be locally dened on the initial
state of all substituted components. The initial state of the
new component is assumed to be \equivalent" to the current
state of the idle component being replaced.
The assumption that components can only be updated
when they are idle is often insucient to guarantee safe
runtime updates. In fact, if we consider the scenario of
Figure 2, and substitute Auth when idle, but after serving
getToken (after time C), the resulting system would behave
incorrectly since the security token would be created with
an algorithm and validated by another.
Since the correctness of arbitrary runtime updates is unde-
cidable (even if the corresponding o-line update is correct
and the runtime update only happens when to-be-updated
components are idle [17]), we can only derive some auto-
matically checkable conditions that are sucient for the cor-
rectness by scoping the class of updates we consider. These
conditions must be: (a) strong enough to ensure the cor-
rectness of runtime updates, (b) weak enough to allow for
low-disruptive and timely changes, and (c) automatically
checkable in a distributed setting (without enforcing unnat-
ural centralized solutions).
3. QUIESCENCE AND TRANQUILLITY
In a seminal paper, Kramer and Magee [15] proposed a
criterion called quiescence as a sucient condition for a
node to be safely manipulated in dynamic recongurations.
They also model a distributed system as a directed graph,
and dene a transaction as \an exchange of information be-
tween two and only two nodes, initiated by one of the nodes.
Transactions are the means by which the state of a node is
aected by other connected nodes in the system. Transac-
tions consist of a sequence of one or more message exchanges
between the two connected nodes. It is assumed that trans-
actions complete in bounded time and that the initiator of a
transaction is aware of its completion". A transaction Tmay
also depend on other (consequent) transactions Ti: the com-
pletion ofTdepends on the completion of all the Ti. This
denition of transaction corresponds to our denition of dis-
tributed transaction between only two nodes. Through the
notion of dependency between transactions, however, they
also capture the concept of a distributed transaction involv-
ing multiple nodes.
Denition 3 (Quiescence). A node is quiescent if:
1. It is not currently engaged in a transaction that it ini-
tiated;
2. It will not initiate new transactions;
3. It is not currently engaged in servicing a transaction;
4. No transactions have been or will be initiated by other
nodes which require service from this node.
A node satisfying the rst two conditions is said to be pas-
sive. A node is required to respond to a passivate command
from the conguration manager by driving itself into a pas-
sive state in bounded time. The last two conditions further
make the node independent of all existing or future transac-
tions, and thus it can be manipulated safely. To drive a node
into a quiescent status, in addition to passivating it, all the
nodes that statically depend on it must also be passivated
to ensure the last two conditions.
247According to this approach, a node cannot be quiescent
before the completion of all the transactions initiated by
statically dependent nodes. This means that the actual up-
date could be deferred signicantly. In our example, Auth
cannot be quiescent before the end of the transactions hosted
byPortal and Proc (T0andT2). Moreover, all the other
nodes that could potentially initiate transactions, which re-
quire service from Auth, directly or indirectly, are passivated,
and their progress blocked till the end of the update. Again,
in our example Portal and Proc are to be passivated before
changing Auth. This means that the adoption of this ap-
proach could introduce signicant disruption in the service
provided by the system.
To reduce disruption, Vandewoude et al. [25] proposed the
concept of tranquillity , as alternative to quiescence. The idea
is that there is no need for waiting a transaction to complete
if it will not request the service provided by the node tar-
geted for update, even if the node has been involved in the
transaction. It is also permitted to update a node even if
some on-going transactions will require the service provided
by the node in the future, but they have not interacted with
it yet.
Denition 4 (Tranquillity). A node is tranquil if:
1. It is not currently engaged in a transaction that it ini-
tiated;
2. It will not initiate new transactions;
3. It is not actively processing a request;
4. None of its adjacent nodes are engaged in a transaction
in which it has both already participated and might still
participate in the future.
While claimed to be \a sucient condition for application
consistency during a dynamic reconguration" [25], the no-
tion of tranquillity is based on a rather strong assumption.
If we used the denition of tranquillity in our model, the no-
tion of distributed transaction could not be fully expressed
as dened in Section 2. In fact, under the assumption im-
posed by tranquility, a distributed transaction initiated by
a root transaction Tat nodeN, could only contain sub-
transactions hosted by (adjacent) nodes directly connected
toN. This means that a sub-sub-transaction (i.e., a sub-
transaction initiated by another sub-transaction), hosted by
a node that is not directly connected to N, would not be
part of the distributed transaction, and thus it could use
any version of the components since it is an independent
entity.
This limitation would permit unsafe updates in the sce-
nario of Figure 2. In fact, after Auth returns the token to
Portal, it will not participate in the session initiated by Por-
talanymore. In addition, before the request for verication
is sent, Auth has not participated in the session initiated
byProc, and so Auth is tranquil at time C. However, if
Auth were updated at this time, the verication would fail
because the token was issued by the old version of Auth,
which might use a dierent encryption algorithm to validate
the security token. This failure would not happen if the sys-
tem entirely complied with either the old or the new system
conguration.
To conclude, we can say that the quiescence-based ap-
proach is a general and safe solution, but it can be highly
disruptive. The tranquillity-based approach is less disrup-
tive, but its assumption is too restrictive to be applicableto a wide set of systems (e.g., our example). Our goal is
to get the best of the two proposals and add eciency and
timeliness to safety.
4. DYNAMIC RECONFIGURATION
The notion of version consistency is proposed as a su-
cient condition for the safety of dynamic recongurations.
Denition 5 (Version Consistency). Transaction T
is version consistent with respect to an update <;!;!0;
T;s > i@T1;T22ext(T)jhT12!^hT22!0. A dy-
namic reconguration caused by an update <;!;!0;T;s>
is version consistent if all transactions hosted by the current
conguration are version consistent.
The denition is justied by the fact that we assume the
new conguration to be correct and by the fact that any
extant transaction with all its (direct and indirect) sub-
transactions is entirely executed in the old or in the new
conguration. Also note that a transaction that ends before
(starts after) the update cannot have a direct or indirect sub-
transaction hosted by the new (old) version of a component
being updated.
For our example, if the update of Auth happens after
transaction T0begins but before it sends a getToken request
toAuth (time A), all transactions in ext(T 0) (i.e., all trans-
actions in Figure 2) are served in the same way as if the
update happened before they all began. If it happens at
any time after Auth replies to the verify request issued by
Proc (time D), all transactions in ext(T0) are served the
same way as if the update happened after they all ended.
However, if it happens at time C, thenhT1=Auth, but
hT3=Auth0. As bothT1andT32ext(T0),T0would not be
version-consistent.
In general, the tranquillity-based approach is not sucient
for version-consistent dynamic recongurations. It is equiva-
lent to limiting the extended transaction set to exttran(T) =
fxjx =T_sub(T;x )g. It only ensures a kind of local con-
sistency, but not the global consistency of entire distrib-
uted transactions. The quiescence-based mechanism |if one
takes dependent transactions into account| ensures version
consistency because no distributed transactions depending
on the node to be updated can exist when the node is qui-
escent. However, it would take a too pessimistic attitude.
4.1 Dynamic dependences
Since version consistency is not directly checkable, we need
to identify a condition that is checkable on a component (or
a set of components) and ensure that its (their) runtime up-
date does not break version consistency; this condition must
also allow for low-disruptive and timely recongurations.
Dynamic dependences are the means to dene such a con-
dition, and they can easily be added to the diagram of Fig-
ure 1 through properly-labelled edges. Dynamic edges, rep-
resented as dashed arcs, are added and removed dynamically
and they are labelled as either future orpast. A future edge
represents the possibility for the source node to initiate a
transaction on the target node; a past edge witnesses the
fact that a transaction initiated by the source node has al-
ready been executed on the target node. Future and past
edges are also labelled with the identier of a root transac-
tion. We use Cfuture( past)        !
TC0to denote a future (past)
248edge labelled with the identier of root transaction T, from
component Cto component C0.
Denition 6 (Valid Configuration). A static con-
guration decorated with edges representing dynamic depen-
dences between corresponding components, hereafter, a con-
guration, is valid i future and past edges are created and
removed at runtime according to the following constraints:
1.(host-validity )The hosting component Cof a trans-
action T is augmented with a pair of edges Cfuture     !
root(T)
CandCpast     !
root(T)Cas soon as Tis initiated and till
it ends;
2.(locality )Any future edgeCfuture    !
TC0(orpast edge
Cpast   !
TC0) cannot exist without a static edgeC  !C0
connecting the same two nodes;
3.(future-validity )Afuture edgeCfuture    !
TC0must
be added before the rst sub-transaction T02ext(T),
withT06=T, is initiated, and it cannot be removed as
long as transactions hosted by Cwill initiate further
T002ext(T )onC0.
4.(past-validity )Apast edgeCpast   !
TC0must be added
at the end of a transaction T02ext(T)onC0, initiated
by a transaction hosted on a statically dependent node
Cand cannot be removed at least until the end of T.
Figure 3 shows some congurations of the example sys-
tem (two concentric cycles correspond to a pair of local fu-
ture/past edges labelled with T0). The conguration of Fig-
ure 3(a) corresponds to time Ain Figure 2: transaction T0
just began on Portal. The dynamic edges indicate that (i)
there may be a transaction in ext(T0) running on Portal; (ii)
in order to serve transactions in ext(T0),Portal might use
Auth and Proc in the future, and also Proc might use Auth
and DB. Figure 3(b) corresponds to time Band says that
a transaction in ext(T0) (T1) is currently running on Auth,
but no further transactions in ext(T 0) hosted by Portal will
initiate any sub-transaction on Auth anymore because there
is noT0-labelled future edge between the two nodes. Fig-
ure 3(c), which corresponds to time Cin Figure 2, indicates
that Auth might have hosted transactions in ext(T 0) initi-
ated by Portal in the past, and might host other transactions
inext(T0) initiated by Proc in the future. Figure 3(d) corre-
sponds to time Din Figure 2 and shows that Auth, although
it might have hosted transactions in ext(T0), is not hosting
and will not host them anymore.
Note that to keep a conguration valid, and consider al-
ternative execution ows, one can adopt a conservative man-
agement of future/past edges between components. For ex-
ample, ifT2onProc needed to evaluate the results from
DBbefore deciding whether to ask Auth for verication, one
could keep the future edge from Proc toAuth tillT2does
not need Auth anymore. In the worst case, this could be till
the end ofT2.
On the other hand, with the validity of the conguration
preserved, future (past) edges should be removed (created)
as early (late) as possible to reduce spurious dependencies
between components that could hinder actually legitimate
dynamic recongurations. For instance, the future edge
from Portal toAuth in Figure 3(a) is removed once Portal
	








	







	






	


Figure 3: Some congurations of the example sys-
tem with explicit dynamic dependences.
realizes that T0will not initiate sub-transactions on Auth
anymore | this happens just after T0initiatesT1.
Given a valid conguration, we can identify a locally check-
able condition that is sucient for the version consistency
of dynamic recongurations.
Denition 7 (Freeness). Given a conguration , a
component C(or a set of components !) is said to be free
of dependences with respect to a root transaction Ti there
does not exist a pair of T-labelled future/past edges entering
C(or!).C(or!) is said to be free in i it is free with
respect to all the transactions in the conguration.
Auth is free of dependences with respect to T0in the con-
gurations of Figure 3(a) and 3(d), while the local dynamic
edges at Auth trivially falsify its freeness in the conguration
of Figure 3(b). Intuitively, for a valid conguration , the
freeness of a component Cwith respect to a root transaction
Tmeans that the distributed transaction modeled by ext(T)
either has not used Cyet (otherwise there should be a past
edge), or will not use Canymore (otherwise there should be
a future edge). This leads to the following proposition.
Proposition 1.Given a valid conguration of a sys-
tem, a dynamic reconguration of a set of its components !
is version consistent if it happens when !is free in .
Proof. If we suppose that version consistency does not
hold, there is a transaction Tthat is not version-consistent,
that is,9T1;T22ext(T)jhT12!^hT22!0.
1. There is no ongoing transaction hosted by any C2!
when the update happens. This follows from the host-
validity of  and the freeness of components in !.
2. Let !be the set of unchanged components. Because
Tbegins no later than T1andT1begins before the
update since hT12!,Tbegins before the update.
SimilarlyTends after the update because of T2. Since
no transaction is hosted by any components in !when
the update happens, hTmust be in  !.
(a) Consider the sub-transaction chain from TtoT1.
There must be such TiandTjthatsub(T i;Tj)^
hTi2!^hTj2!. According to the past-
validity of  and the fact that Tjmust have al-
ready ended when the update happens (see point
1), there is a past T-labelled edge entering hTj.
249(b) Because of the validity of the static conguration
after the update, !0must inherit all the incoming
static dependence edges from !. Without any
loss of generality, let T2be the rst transaction in
ext(T) initiated on a component in !0. Consider
the sub-transaction chain from TtoT2. There
must be aTksuch thatsub(T k;T2)^hTk2!.
BeforeTkinitiatesT2, all transactions from Tto
Tkin the chain will not be aected by the update
because they are independent of transactions not
inext(T ), andT2is the rst transaction in ext(T )
hosted by a component in !0. According to the
future-validity of  and the fact that T2is still to
be initiated when the update happens, there is a
futureT-labelled edge from hTkto a component
in!.
So there is a pair of T-labelled past/future edges entering !.
This contradicts the freeness of !.
4.2 Distributed management of dependences
An advantage of specifying dynamic dependences with fu-
ture and past edges is that the validity of a conguration can
be achieved through the cooperation of components. Each
component makes its decisions locally with limited informa-
tion about the application logic; checking for freeness is also
local to the part of the system to be updated.
The denition of valid conguration gives lower bounds for
the time intervals during which dynamic dependence edges
should exist to keep a conguration valid. One can satisfy all
the conditions straightforwardly by creating all the dynamic
edges at the beginning of a root transaction and by removing
them at the end of it. However, although version consistency
would be ensured, disruption could be too high.
We assume that given a transaction T, its host component
hTknowsf(T), the set of static edges through which it
might initiate sub-transactions on neighbor components in
the future, and p(T), the set of static edges through which
it has initiated sub-transactions in the past3.
The overall conguration with dynamic dependences is
maintained in a distributed way. Each component only has a
local view of the conguration that includes itself and its di-
rect neighbors. A component is responsible for the creation
and removal of the dynamic edges leaving from it, but it is
also always notied of the creation and removal of the dy-
namic edges entering it. Components exchange management
messages, besides those related to transactions, to keep the
consistency among the views of neighbor components. The
maintenance of the distributed conguration may slightly
delay the execution of the actual transactions, but it guar-
antees that no transactions will be blocked forever.
4.2.1 Management algorithm
The management of dynamic edges for dierent distrib-
uted transactions is independent of each other since these
edges are labelled with the identiers of the correspond-
ing root transactions. If we consider a distributed transac-
3It is safe to over estimate f(T) andp(T), but better accu-
racy means better timeliness and less disruption in the dy-
namic reconguration. This information can be extracted
automatically from the component, but also by monitoring
its transactions; the degree of accuracy of this information is
up to the user. Note that similar information is also required
to decide the actual tranquillity of components [25].tionext(T ), our algorithm consists of three steps: set up ,
progress , and clean up. Through these steps, the local-
ity of the conguration is ensured by only creating dynamic
edges that pair the existing static ones, and the host validity
is preserved by always creating local future and past edges
(if they do not already exist) when a transaction is initiated
and by removing them only after the end of the transaction
(if there are no other on-going transactions that need these
edges).
In more detail, the three steps carry out the following
actions and help preserve future and past validity as follows:
Set up: This step is carried out when the root transac-
tionTis initiated and before it initiates any sub-transaction.
During this phase, hTcreates a future edge for each of
its out-going static edges that Tmight use to initiate sub-
transactions according to f(T), noties corresponding neigh-
bor components, and waits for their acknowledgements. Only
after receiving all these acknowledgements, Tis allowed to
initiate its sub-transactions.
As soon as a component Cis notied of the creation of
an incoming future edge fe=C0future    !
TCbyC0, it starts
creating its own future edges, noties neighbor components,
waits for their acknowledgements, and then acknowledges
C0back. The rationale is that by accepting the creation
offe,C\promises" C0to host some TC2ext(T) in the
future, but to make such a promise Crst needs to get the
promises from those components that TCmight need to use.
Note that loops in the static conguration can be handled
by avoiding the creation and notication of duplicated edges.
This conservative way creates future edges to achieve a valid
conguration with respect to Twhen the set up step nishes.
Figure 3(a) shows the result of setting up future edges for
transaction T0of Figure 2.
Progress: Due to the execution of transactions in ext(T),
future edges are gradually removed as soon as the algorithm
knows that a component will-not-use another one anymore,
and past edges are created to register have-used relation-
ships.
In more detail, new will-not-use information can be avail-
able at various time instants including (1) when a trans-
action inext(T ) hosted by Csuccessfully initiates a sub-
transaction on a neighbor component; (2) when a transac-
tion inext(T) hosted by Cends; and (3) when Cis notied
of the removal of a T-labelled incoming future edge. No
matter when the information is acquired, a non-local fu-
ture edgefe=Cfuture    !
TC0is removed only when: (1)
no on-going T02ext(T) hosted by Cwill initiate any sub-
transaction on C0throughCstatic    !C0anymore; and (2)
there is no incoming T-labelled future edge entering C, that
is, no further T002ext(T) will be initiated on Canymore.
This condition ensures future validity because once feis re-
moved, no sub-transactions in ext(T) need to be initiated
throughCstatic    !C0anymore.
To record the have-used information, when a sub-trans-
actionToriginally initiated by T0ends, a corresponding
past edgepe=hT0past     !
root(T)hTis created immediately . This
is done by letting hTrst notify hT0the end of T, and
by removing the corresponding local edges only when peis
created byhT0. This hand-shaking ensures that past validity
holds despite the asynchrony of messages.
250In our example scenario, Portal removes the future edge
toAuth after it initiates T1onAuth as it is sure that T0will
not initiate such transactions anymore (Figure 3(b)). When
T1ends, Portal immediately creates a past edge to record
the fact that it has used Auth (Figure 3(c)). Eventually, the
system reaches the conguration of Figure 3(d), where Auth
is free with respect to T0.
Clean up: This step is carried out only when Tends.
The algorithm recursively removes all remaining past and
future edges. This step does not aect the validity of the
conguration.
For the sake of readability, the algorithm has been de-
scribed by taking the viewpoint of a distributed transaction,
but the actual algorithm runs on each component without
any centralized control. The underlying message delivery
is assumed to be reliable, and the messages between two
components are kept in order. Interested readers can refer
to [17] for all details. Also note that since tracking dynamic
dependences across the whole system can be expensive and
unnecessary, a user can specify a portion of the system as
scope for version consistency if the impact of the update is
known to be limited. More details on this issue are also
discussed in [17].
4.2.2 On-demand set up
The above algorithm assumes that congurations are al-
ways kept up-to-date no matter whether there is a request
for dynamic reconguration. However, conguration man-
agement could introduce signicant overhead. If recongu-
rations are rare, a valid conguration can be set up on de-
mand only when a request is planned or expected. To this
end, dynamic edges must be created both for new transac-
tions and for on-going ones.
The set up works as follows. The working mode of each
component can be: NORMAL, ONDEMAND, or VALID. NOR-
MAL means that the component is not supposed to man-
age dynamic dependences, while VALID requires it. ON-
DEMAND imposes that the component: (1) manages the
dynamic dependences for all the new root transactions ini-
tiated locally, (2) blocks the initiation and termination of
locally hosted sub-transactions temporarily, and (3) for each
locally-hosted ongoing root transaction T, creates future
(past) edges towards the components that might host in the
future (might have hosted in the past) transactions in ext(T )
in a way similar to the one described above.
At the beginning, all components operate in mode NOR-
MAL. When a component targeted for update receives a re-
quest for reconguration, it sends a request for set up to
itself and waits for its mode to become VALID before using
the approach we describe next to achieve freeness. Upon
receiving a request for set up, a component Cswitches to
mode ONDEMAND and sends set up requests to all the com-
ponentsCithat statically depends on it. Once Chas n-
ished the set up of dynamic edges for its local root transac-
tions, and has received all the acknowledgements from Ci, it
switches to mode VALID, resumes all blocked transactions,
and sends conrmations to all the nodes from which it re-
ceived requests for set up. The whole on-demand set up
procedure completes when the targeted component becomes
VALID.
On-demand set up of dynamic dependencies also makes
dealing with dynamic recongurations resulting in new de-
pendencies straightforward, and thus multiple recongura-tion steps in sequence are supported. However, although
our approach allows multiple components to be updated to-
gether (in a single reconguration step), it does not currently
support concurrent recongurations, meaning independent
updates of dierent components happening at same time
without coordination.
4.3 Achieving freeness
Given a valid conguration maintained at runtime, check-
ing for the freeness of !|the set of components targeted
for update| is straightforward since the condition is local
to!, but freeness can be achieved in dierent ways.
The rst strategy, called waiting for freeness (WF) , is
simply opportunistic. The system just waits for freeness to
manifest itself. This strategy has no extra overhead other
than setting up and maintaining the valid conguration and
checking for the freeness of !. However, although every
transaction completes in nite time, the freeness of !could
never be reached |for example, there could always be trans-
actions running on some components in !.
To ensure the timeliness of runtime updates, a second
strategy, called concurrent versions (CV) , lets the compo-
nents in!and!0co-exist during the update process. The
use of multiple versions of the same components is not new
(e.g., HERCULES [8] and Upstart [1] adopt it), but our pro-
posal can add version consistency as means to choose which
version must serve a request and to decide when a version
can be deleted. Given a valid conguration, one can choose
a component C2!to serve the requests that come from a
transaction Tonly ifChas already an incoming past edge
labeled with root(T), and let the components in !0serve
the others. This means that components in !cannot have
incoming past edges labelled with new root transactions,
and these components will eventually become free since old
transactions will reach a stage where they will not use com-
ponents in!anymore. As soon as these components become
free, they can be safely removed from the system.
However, if multiple versions cannot coexist, or it is prefer-
able not to do it, the third strategy is called blocking for
freeness (BF) . It requires that some of the requests to the
components in !be temporally blocked to avoid creating
past edges labelled with new root transactions. These com-
ponents will eventually become free when all existing trans-
actions do not use them anymore. More precisely, the initi-
ation of any transaction on any component in !is blocked
unless it belongs to an extended transaction set in which a
member transaction has already been hosted by a compo-
nent in!. This comes from the fact that the rst T-labelled
past edge entering a component C2!is created the rst
time a transaction in ext(T) is being initiated on C. As
soon as all components in !become free, they are substi-
tuted by the new versions in !0, and all blocked transactions
are resumed.
Back to our example, if Auth receives the request for up-
date before T0onPortal initiatesT1onAuth, the initiation
ofT1is blocked because there is no T0-labelled past edge
entering Auth. Note that there can be T0-labelled future
edges entering Auth (e.g., see Fig. 3(a)), but by blocking the
initiation of any T2ext(T 0) on Auth, the freeness of this
component will not be hindered by T0since noT0-labelled
past edge needs to be created. However, if the request for
update arrived at time C, the initiation of T3byT2onProc
would be allowed because there is already a T0-labelled past
251edge entering Auth (created when T1ended). In this case,
Auth must wait all T0-labelled future edges to be removed,
that is, at time D, which corresponds to the conguration
presented in Fig. 3(d).
This last strategy relies on the assumption that execut-
ing transactions are independent of each other. If they are
not, that is, the progress of a transaction in an extended
transaction set can be blocked by a transaction in another
extended transaction set, we may have deadlocks. For ex-
ample, this happens when two transactions are concurrently
hosted on the same component and need to access a shared
resource protected by a mutual exclusion lock. If one blocked
the transaction that holds the lock (to avoid creating new
past edges to the component-to-update), the other would be
blocked as well (since it does not hold the lock), blocks would
never be released, and the system would enter a deadlock.
However we do not expect this situation to be very com-
mon because modern systems often use ne grained locks to
avoid blocking a transaction to serve other business-irrelevant
transactions. Even when this situation does occur, reme-
dies are possible. One can rely on existing mechanisms for
the avoidance, prevention, or detection of distributed dead-
locks. For example, according to the Wait-for Graph used
for deadlock detection [18], one can resume the initializa-
tion of blocked transactions if their initializers are waited
for by some transactions that must proceed to free the tar-
geted components. Note that such a mechanism is very
likely already provided by the infrastructure since distrib-
uted deadlocks are an important, potential problem in dis-
tributed systems with shared resources protected by coarse-
grained locks. One can also use a more conservative block-
ing policy, and delay the creation of future edges |instead
of past edges| labelled with new root transactions. This
method prevents the initialization of any new root transac-
tion that may use the targeted component, thus introducing
more disruption. In practice, one may rst take an opti-
mistic approach by ignoring the deadlock problem and ex-
ploit these remedies when the freeness is not achieved after
a reasonable time interval.
Generally, CV is preferred when applicable. WF and CV
do not introduce disruption to system's service other than
that caused by setting up and maintaining the valid cong-
uration, while BF imposes extra disruption due to its tem-
poral blocking of some transactions. As for timeliness, CV
and BF strategies are essentially equivalent.
5. SIMULATIONS
Besides ensuring safety, dynamic reconguration is ex-
pected to be timely and to cause limited disruption. This is
why the objective of this section is to assess the timeliness
and degree of disruption of our approach and to compare
them with those oered by the quiescence-based solution.
We also aim to evaluate the impact of dierent levels of net-
work latency on both approaches. The tranquillity-based
approach was not included in the comparisons because it
only ensures a local consistency property while the two ap-
proaches above ensure global consistency. Timeliness is mea-
sured as the time span between receiving a request for dy-
namic reconguration and entering a state where the system
is ready for the changes. The degree of disruption is mea-
sured as the loss of working time for business transactions
with respect to the execution of these transactions without
dynamic reconguration.Figure 4 shows the framework we used for the experi-
ments4. To make our simulation realistic, the topologies of
the systems we wanted to simulate are directed scale-free
graphs5randomly generated by means of the JUNG frame-
work6. The behavior of a CBDS is mimicked through a
discrete event simulator based on the DEUS framework [2].
Events from the simulator drive the management framework
to maintain the conguration according to the algorithm
described in the previous section. Congurations are main-
tained on demand, and components are assumed to have ac-
curatef(T) andp(T) for each locally-hosted ongoing trans-
actionT, but no information other than static dependences
for transactions that have already completed or have not
started yet. The quiescence-based approach is implemented
on top of the same framework by recursively passivating
all components that statically depend on the to-be-updated
ones.
!"#"$%&%#'()*"&%+,*-(./0123"4%5(16&78"',*(9,#:$7*";,#(+6'<(.=#"&6>(.%?%#5%#>%(9@.1(@%<"A6,*(5*6A%(46&78"'%(&"#"$%(*%B%>'(C0DE(E*"?<(E%#%*"',*(1'";>((9,#:$7*";,#4($%#%*"'%(74%5(3=(74%5(3=(
Figure 4: Simulation framework.
We also injected root transactions in all components with
an activation pattern that satises Poisson distribution. Lo-
cal processing times of transactions (not including the pro-
cessing time of their sub-transactions) are normally distrib-
uted within a range of (0 ;2) with a standard deviation of
=5, where is the mean local processing time. Transactions
randomly initiate sub-transactions on the neighbor compo-
nents of their host components. On average a transaction
initiates one sub-transaction through each of its static out-
going edges. The actual system's workload for a particular
conguration is given by the mean time interval between the
activation of two root transactions at each component and
the mean processing time of local transactions.
This framework allowed us to simulate systems with a dif-
ferent number of components and dierent workloads. The
goal was to assess: (a) the impact of the system's size on the
actual capabilities of ensuring version consistency, and (b)
the performance of dierent strategies in achieving freeness
with respect to dierent workloads.
5.1 Experiments
In our rst experiment, we compared the timeliness and
disruption of our approach7against those of the quiescence-
based approach with systems of four dierent sizes: we gen-
erated 100 congurations of systems with 4, 8, 16, and 32
4The code of our experiments is available at: http://vcsim.
googlecode.com .
5Scale-free graphs have been proposed as generic, universal
models of network topologies that exhibit power law distri-
butions in the connectivity of network nodes.
6http://jung.sourceforge.net/index.html .
7We used strategies CV and BF. For BF, the extended trans-
action sets are independent of each other as for liveness.
252components. The mean processing time for local transac-
tions was set to 50 time units8, and the mean arrival inter-
val between two root transactions at each component was
set to 25 time units. The message delay between two neigh-
bor components was set to 5 time units since the network
delay between servers is often about an order of magnitude
lower than the local processing time [14]. For each cong-
uration, we randomly selected a component that had other
components depending on it as the target for update, and
probed the timeliness and disruption in the two cases.
313 ¬†610 ¬†1008 ¬†1589 ¬†
243 ¬†520 ¬†783 ¬†1252 ¬†
0200400600800100012001400160018002000
481632Time ¬† ¬†to ¬†be ¬†ready ¬†for ¬†update ¬†
Number ¬†of ¬†components ¬†QuiescenceVC-¬≠‚ÄêCV/BF
Figure 5: Timeliness of dynamic reconguration.
Figure 5 presents the mean timeliness of the two approaches
and shows that freeness is achieved in a time that is some
20% less than the one needed to obtain quiescence.
Figure 6 shows that the degree of disruption of our ap-
proach with strategy BF is only about a half of that for the
quiescence approach. With strategy CV, our approach only
introduces negligible disruption, which is mainly due to the
on-demand set up and maintenance of congurations. The
standard errors of these values (shown by the error bars in
the two gures) are relatively high, which indicates that the
timeliness and disruption of both approaches are sensitive
to the dierence in the components targeted for update, the
distribution of transactions on components, and the actual
progressing of these transactions. However we observed that
given the same conguration, even with strategy BF, our ap-
proach outperformed the quiescence-based one in 95% of the
runs. These results then indicate that version-consistent dy-
namic reconguration, even with the overhead of handling
dynamic edges introduced by the management algorithm,
can be signicantly less disruptive and more timely than
the quiescence-based one.
The results also conrm the intuition that, for both ours
and the quiescence-based approach, maintaining the consis-
tency of dynamic recongurations becomes more and more
expensive when the system scale increases.
Our second experiment was designed to evaluate the im-
pact of network latency on the performance of the two ap-
proaches. In this experiment, we used the same settings
introduced above with a couple of dierences: we only show
systems with 16 components |since the other congurations
manifested the same trends| and message delay varied from
0 to 100. The results in Figure 7 show that our approach is
consistently better than the quiescence-based one as far as
8Since the time is simulated, all time-related values in this
section are in virtual time units unless otherwise specied.
3337 ¬†18515 ¬†70103 ¬†226961 ¬†
1650 ¬†10858 ¬†35157 ¬†113789 ¬†102 ¬† ¬†411 ¬† ¬†1009 ¬† ¬†1865 ¬† ¬†050000100000150000200000250000300000
481632Loss ¬†of ¬†working ¬†time ¬† ¬†
Number ¬†of ¬†components ¬†QuiescenceVC-¬≠‚ÄêBFVC-¬≠‚ÄêCVFigure 6: Disruption of dynamic reconguration.
disruption is concerned, but its gain in timeliness diminishes
while message delay increases.
05101520253035404550
0500100015002000250030003500400045005000
015102550100Loss ¬†of ¬†working ¬†time ¬†(x10000) ¬†Time ¬†to ¬†be ¬†ready ¬†for ¬†update ¬†
Message ¬†Delay ¬†Quiescence ¬†TimelinessVC-¬≠‚ÄêCV/BF ¬†TimelinessQuiescence ¬†DisruptionVC-¬≠‚ÄêBF ¬†DisruptionVC-¬≠‚ÄêCV ¬†Disruption
Figure 7: Impacts of network latency.
The third experiment presented here was aimed to analyze
the impact of dierent strategies in achieving freeness on
the timeliness of the actual reconguration. Especially, we
want to see when strategy WF (simply based on waiting)
can be applied and when we must use strategies CV (using
concurrent versions) or BF (based on blocking). Intuitively
the timeliness of strategy WF would be highly sensitive to
the actual workload |more running transactions mean less
opportunity for freeness. Figure 8 gives the time to freeness
for strategies WF and CV/BF. The strategies were applied
on the same 16-node conguration, and the same node was
chosen as the target for update. The average local processing
time was xed to 50 time units, but with dierent intervals
as for the arrival of root transactions, and thus dierent
levels of workload. Figure 8 shows the average timeliness
of 100 runs for each of the 9 dierent arrival intervals we
selected (e.g., 1600 means that a new root transaction is
initiated every 1600 time units). The results suggest that
WF is preferable when the workload is rather light, but when
it increases CV or BF ensures better timeliness.
6. RELATED WORK
The dynamic update of running applications has been ex-
tensively studied in multiple areas including programming
languages [12, 13, 22, 23], operating systems [3, 10, 16], and
software engineering [6,21]. A common theme of these works
253!"#!!!"$!!!!"$#!!!"%!!!!"%#!!!"&!!!!"&#!!!"
$'!!"(!!")!!"'!!"#!!"*!!"&#!"&!!"%#!"!"#$%&'%()$$*$++
,$-*%-))".-/%"*&$).-/+,-,+./0"+,-10"Figure 8: Timeliness: waiting vs. blocking.
is the selection of proper time points when the state of the
system is steady and ready for applying a user-specied state
transformation. The result is a new valid state from which
the system is able to continue its evolution. Since generally
the validity of the resulting state is undecidable [12], most
research eorts focus on: (a) human-assisted identication
of proper time points and state transformers by providing
the necessary runtime support and (b) improving the time-
liness of updates by automatically deriving further safe time
points from those specied or known by the user.
Instead of switching from the old to the new version of
the application, some works proposed intermediate versions
to smooth the adaptation process. For example, Zhang and
Cheng [27] proposed a model-based approach for the de-
velopment of adaptive software. The behaviors of the dif-
ferent versions of an application are modeled by dierent
state machines, and the adaptation behavior is rendered
through states/transitions that connect them. Biyani and
Kulkarni [5] used adaptation lattices to model transition
paths from old to new programs, and introduced the con-
cept of transitional-invariant lattice to verify the correctness
of adaptations.
As for CBDSs, it is desirable and possible to avoid the
direct manipulation of application-specic states of compo-
nents and to maintain a clear separation of concerns be-
tween reconguration management and application logic.
The focus is often on identifying suitable conditions (ab-
stract states) under which components can be safely manip-
ulated. The concept of quiescence by Kramer and Magee [15]
is a prominent early work, but it may impose too high dis-
ruption on system's service. Subsequently, the dynamic re-
conguration service for CORBA by Bidan et al. [4], the
proposal by Chen [7], and the idea of tranquillity by Vande-
woude et al. [25] reduced disruption by means of consider-
ations based on dynamic dependences, but they only guar-
antee some local consistency properties or impose stringent
restrictions on the systems that can be updated.
It is also widely recognized that the dynamic adaptation
of software systems should be modeled, analyzed, and man-
aged at architectural level [9,20]. Architectural models pro-
vide abstract global views of systems and explicitly spec-
ify system-level integrity constraints that must be preserved
by reconguration. However, these models do not usually
provide information about the runtime dynamic dependen-
ces needed to perform safe and low-disruptive runtime re-
congurations. Wermelinger [26] et al. proposed a cate-gory theory-based approach for the uniform modeling of the
computations performed by components and their architec-
tural congurations. This proposal can be used as a for-
mal foundation for the specication of and reasoning about
dynamic recongurations. However its complexity prevents
it from being directly used in any concrete runtime man-
agement framework. Taentzer et al. [24] proposed the use
of distributed graph transformation to model congurable
distributed systems, but the dynamic dependences among
components are not specied directly. We chose to add fu-
ture and past edges to architectural congurations because
they provide a simple but powerful abstraction for dynamic
dependences, and provide a good separation of concerns be-
tween application-specic computation and reconguration
management.
As the name suggests, our version consistency criterion
is inspired by the work on transactional version consistency
by Neamtiu et al. [19]. This work focuses on the dynamic
update of centralized applications at code level, and its no-
tion of transaction is a user-dened scope in the code. Their
approach ensures that the execution of the code in the scope
complies with the same, single version, no matter when the
update happens. However, in our work the notion of ver-
sion consistency is dened for a distributed system model.
Neamtiu et al.'s approach [19] relies on global static pro-
gram analysis and cannot be used in a distributed setting.
Moreover, we use the notion of version consistency as a suf-
cient condition for the correctness of dynamic recongura-
tions, while they use it as a user-specied pre-requisite for
dynamic updates.
7. CONCLUSIONS AND FUTURE WORK
Dynamic reconguration is widely desired but its applica-
tion in practice is still limited, partly because of the com-
plexity in balancing consistency (of changes) and disruption
(of system's service). This is why we propose the use of ver-
sion consistency as a criterion for safe dynamic recongura-
tions of CBDSs. The approach does not compromise the cor-
rectness of distributed transactions, but it allows for better
timeliness and lower disruption than previous approaches.
The paper also proposes a distributed mechanism to man-
age dynamic dependences between components at runtime,
and thus to support version consistent dynamic recongura-
tions.
As for our on-going and future work, we are working on an
implementation of our framework on top of a BPEL engine.
We also have plans to explore to what extent our approach
can be paired with other optimizations of dynamic recon-
gurations, such as supporting the coordinated abortion of
re-triable transactions.
Acknowledgment
This research has been partially funded by the European
Commission, Programme IDEAS-ERC, Project 227977 SM-
Scom. Xiaoxing Ma is also partially supported by the NSFC
(60973044, 60736015, 61021062) and the 973 Program of
China (2009CB320702).
8. REFERENCES
[1] S. Ajmani, B. Liskov, and L. Shrira. Modular software
upgrades for distributed systems. In European
Conference on Object-Oriented Programming
(ECOOP) , July 2006.
254[2] M. Amoretti, M. Agosti, and F. Zanichelli. DEUS: a
discrete event universal simulator. In Simutools '09:
Proceedings of the 2nd International Conference on
Simulation Tools and Techniques , pages 1{9, ICST,
Brussels, Belgium, Belgium, 2009. ICST (Institute for
Computer Sciences, Social-Informatics and
Telecommunications Engineering).
[3] A. Baumann, G. Heiser, J. Appavoo, D. D. Silva,
O. Krieger, R. W. Wisniewski, and J. Kerr. Providing
dynamic update in an operating system. In ATEC '05:
Proceedings of the annual conference on USENIX
Annual Technical Conference , pages 32{32, Berkeley,
CA, USA, 2005. USENIX Association.
[4] C. Bidan, V. Issarny, T. Saridakis, and A. Zarras. A
dynamic reconguration service for CORBA. In CDS
'98: Proceedings of the International Conference on
Congurable Distributed Systems , page 35,
Washington, DC, USA, 1998. IEEE Computer Society.
[5] K. N. Biyani and S. S. Kulkarni. Assurance of
dynamic adaptation in distributed systems. J. Parallel
Distrib. Comput. , 68(8):1097{1112, 2008.
[6] H. Chen, J. Yu, R. Chen, B. Zang, and P.-C. Yew.
POLUS: A powerful live updating system. In ICSE
'07: Proceedings of the 29th international conference
on Software Engineering, pages 271{281, 2007.
[7] X. Chen and M. Simons. A component framework for
dynamic reconguration of distributed systems. In CD
'02: Proceedings of the IFIP/ACM Working
Conference on Component Deployment , pages 82{96,
London, UK, 2002. Springer-Verlag.
[8] J. E. Cook and J. A. Dage. Highly reliable upgrading
of components. In ICSE '99: Proceedings of the 21st
international conference on Software engineering,
pages 203{212, New York, NY, USA, 1999. ACM.
[9] D. Garlan, S.-W. Cheng, A.-C. Huang, B. Schmerl,
and P. Steenkiste. Rainbow: Architecture-based
self-adaptation with reusable infrastructure.
Computer , 37(10):46{54, 2004.
[10] C. Giurida and A. S. Tanenbaum. Cooperative
update: a new model for dependable live update. In
HotSWUp '09: Proceedings of the Second International
Workshop on Hot Topics in Software Upgrades , pages
1{6, New York, NY, USA, 2009. ACM.
[11] J. Gray and A. Reuter. Transaction Processing:
Concepts and Techniques . Morgan Kaufmann
Publishers Inc., San Francisco, CA, USA, 1992.
[12] D. Gupta, P. Jalote, and G. Barua. A formal
framework for on-line software version change. IEEE
Transactions on Software Engineering , 22(2):120{131,
1996.
[13] M. Hicks and S. Nettles. Dynamic software updating.
ACM Trans. Program. Lang. Syst. , 27(6):1049{1096,
2005.
[14] U. Hoelzle and L. A. Barroso. The Datacenter as a
Computer: An Introduction to the Design of
Warehouse-Scale Machines . Morgan and Claypool
Publishers, 2009.
[15] J. Kramer and J. Magee. The evolving philosophers
problem: Dynamic change management. IEEE
Transactions on Software Engineering ,
16(11):1293{1306, 1990.
[16] K. Makris and K. D. Ryu. Dynamic and adaptiveupdates of non-quiescent subsystems in commodity
operating system kernels. In EuroSys '07: Proceedings
of the 2nd ACM SIGOPS/EuroSys European
Conference on Computer Systems 2007 , pages
327{340, New York, NY, USA, 2007. ACM.
[17] X. Ma, L. Baresi, C. Ghezzi, V. Panzica La Manna
and J. Lu. Version-consistent Dynamic
Reconguration of Component-based Distributed
Systems. Technical Report, 2010. Available at
http://home.dei.polimi.it/baresi/docs/vcdu-TR.pdf
[18] D. P. Mitchell and M. J. Merritt. A distributed
algorithm for deadlock detection and resolution. In
Proceedings of the third annual ACM symposium on
Principles of distributed computing 1984 (PODC '84) ,
pages , 282{284, New York, NY, USA, 1984. ACM.
[19] I. Neamtiu, M. Hicks, J. S. Foster, and P. Pratikakis.
Contextual eects for version-consistent dynamic
software updating and safe concurrent programming.
InPOPL '08: Proceedings of the 35th annual ACM
SIGPLAN-SIGACT symposium on Principles of
programming languages , pages 37{49, 2008.
[20] P. Oreizy, N. Medvidovic, and R. N. Taylor. Runtime
software adaptation: framework, approaches, and
styles. In ICSE Companion '08: Companion of the
30th international conference on Software engineering,
pages 899{910, New York, NY, USA, 2008. ACM.
[21] S. C. Previtali. Dynamic updates: another middleware
service? In MAI '07: Proceedings of the 1st workshop
on Middleware-application interaction , pages
49{54,2007.
[22] G. Stoyle, M. Hicks, G. Bierman, P. Sewell, and
I. Neamtiu. Mutatis mutandis: Safe and predictable
dynamic software updating. ACM Trans. Program.
Lang. Syst. , 29(4):22, August 2007.
[23] S. Subramanian, M. Hicks, and K. S. McKinley.
Dynamic software updates: a vm-centric approach. In
PLDI '09: Proceedings of the 2009 ACM SIGPLAN
conference on Programming language design and
implementation , pages 1{12.
[24] G. Taentzer, M. Goedicke, and T. Meyer. Dynamic
change management by distributed graph
transformation: Towards congurable distributed
systems. In TAGT'98: Selected papers from the 6th
International Workshop on Theory and Application of
Graph Transformations , pages 179{193, London, UK,
2000. Springer-Verlag.
[25] Y. Vandewoude, P. Ebraert, Y. Berbers, and
T. D'Hondt. Tranquility: A low disruptive alternative
to quiescence for ensuring safe dynamic updates.
IEEE Transactions on Software Engineering ,
33(12):856{868, 2007.
[26] M. Wermelinger, A. Lopes, and J. L. Fiadeiro. A
graph based architectural (re)conguration language.
InESEC/FSE-9: Proceedings of the 8th European
software engineering conference held jointly with 9th
ACM SIGSOFT international symposium on
Foundations of software engineering , pages 21{32.
[27] J. Zhang and B. H. C. Cheng. Model-based
development of dynamically adaptive software. In
ICSE '06: Proceedings of the 28th international
conference on Software engineering, pages 371{380,
2006.
255