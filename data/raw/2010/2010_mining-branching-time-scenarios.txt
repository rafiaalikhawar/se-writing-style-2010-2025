Mining Branching-Time Scenarios
Dirk Fahland1, David Lo2, and Shahar Maoz3
1Eindhoven University of Technology, The Netherlands
2Singapore Management University, Singapore
3Tel Aviv University, Israel
d.fahland@tue.nl, davidlo@smu.edu.sg, maoz@cs.tau.ac.il
Abstract —Speciﬁcation mining extracts candidate speciﬁcation
from existing systems, to be used for downstream tasks such
as testing and veriﬁcation. Speciﬁcally, we are interested in the
extraction of behavior models from execution traces.
In this paper we introduce mining of branching-time scenarios
in the form of existential, conditional Live Sequence Charts,
using a statistical data-mining algorithm. We show the power
of branching scenarios to reveal alternative scenario-based be-
haviors, which could not be mined by previous approaches.
The work contrasts and complements previous works on
mining linear-time scenarios. An implementation and evaluation
over execution trace sets recorded from several real-world appli-
cations shows the unique contribution of mining branching-time
scenarios to the state-of-the-art in speciﬁcation mining.
I. I NTRODUCTION
Speciﬁcation mining methods, which extract candidate spec-
iﬁcations from source code or execution traces, have attracted
much research efforts in recent years. The mined speciﬁcations
serve as input for downstream tasks such as testing, formal
veriﬁcation, and program comprehension. Speciﬁcally, we
are interested in mining scenario-based speciﬁcations, where
the mined speciﬁcations consist of a set of typically short
sequences of events, intuitively depicted using variants of
classic sequence diagrams.
In recent work [23], [25], [28], two of the co-authors of
the present paper have presented mining of scenario-based
speciﬁcations in the form of universal Live Sequence Charts
(LSC) [5], [18]. Universal LSCs specify rules of the form
“whenever a sequence of events happens, eventually another
sequence of events will happen”. That is, they specify a
universal linear temporal logic property.
However, a speciﬁcation of the behavior of a system may
often be characterized not only by linear invariants but also
by possible choices. In the context of scenario-based speciﬁ-
cations, these are best represented using existential conditional
LSCs, as deﬁned in [37]. Such a branching LSC speciﬁes a
rule of the form “when a sequence of events happens, another
sequence of events is a possible continuation”. That is, they
specify a conditional branching temporal logic property.
In this work we present mining branching time scenario-
based speciﬁcations in the form of the branching, existential
conditional LSCs described in [37]. The input for our tech-
nique are a set of execution traces (a log) that have been
recorded from a running application, and two parameters: a
support threshold sets how often a particular LSC has to
occur in the log (i.e., when it is “relevant” enough), and aconﬁdence threshold sets the fraction of times the property
speciﬁed in the discovered LSC has to hold (allowing the
LSC to be violated on some occurrences). The output consists
of a set of existential conditional LSCs that is correct and
complete with regard to the support and conﬁdence: the given
log satisﬁes each returned existential conditional LSC, and
any other existential conditional LSC occurs less often than
the given support threshold, or the log violates the LSC more
often than allowed by the conﬁdence threshold.
To better understand the difference between mining linear
LSCs and mining branching LSCs, and thus motivate our
work, consider the following two example LSCs, Delete
andDownload , shown in Fig. 1 and Fig. 2 respectively. Both
LSCs were mined in our experiments from an execution trace
set of crossFTP , an open-source FTP server (see Sect. V for
details). As these are branching LSCs, each speciﬁes a possible
continuation to the onConnect call, a continuation which was
observed with high support and conﬁdence in the trace set,
executing the Delete or the Download FTP commands
(we mined several additional LSCs with the same pre-chart
onConnect , all together covering several additional commands
of the FTP protocol). However, when mining for linear LSCs
(as in [28]), from the same trace set, none of these LSCs is
found, because in the trace set, onLogin is not always followed
by the setDelete command, by the setDownload command,
or by any other single FTP command. Instead, only linear
invariants are mined with high support and conﬁdence, such as
the linear LSC shown in Fig. 3, which speciﬁes that “whenever
onConnect is called in the trace, eventually there will be
calls to onLogin ,setUser , and setLogout ” (in this order). This
example shows the difference between (mined) linear and
branching scenarios in terms of their expressiveness and their
ability to explain and reveal the behaviors embedded in an
execution trace set.
We have implemented our ideas and evaluated them on
execution trace sets recorded from two applications. All trace
sets and mining results are available at [14].
We summarize the contribution of our work as follows:
•Deﬁnition and algorithm for mining branching-time sce-
narios;
•Evaluation over a number of trace sets, including a dis-
cussion and comparison of branching vs. linear scenarios
in the context of speciﬁcation mining;
•Implementation for mining of linear and of branching
scenarios available for download with all trace sets data,
1LSC-B Delete
setUser()onLogin()onDeleteStart()STATREQCONTPASSDELE
setDelete()onDeleteEnd()setLogout()onConnect()REQHFig. 1. The branching LSC Delete , specifying one possible contin-
uation after login, dealing with the FTP delete command.
LSC-B Download
setUser()onLogin()onDownloadStart()STATREQCONTPASSRETR
setDownload()onDownloadEnd()setLogout()getFileOffset()REQH
getDataType()transfer()onConnect()
Fig. 2. The branching LSC Download , specifying one possible
continuation after login, dealing with the FTP download command.
setUser()onLogin()REQCONTPASSRETRonConnect()LSC-L Login
setLogout()
Fig. 3. The linear LSC Login , specifying that “whenever onCon-
nect is called, eventually there will be calls to onLogin ,setUser ,
setLogin , and setLogout ” (in this order).
to allow readers to reproduce our experiments.
The formal methods community has had a long debate about
the relative merits of linear vs. branching-time logic as they
are used for system speciﬁcations; which one is easier for
engineers to formulate and understand, which one may have
better performing synthesis and veriﬁcation algorithms, which
one allows compositional reasoning etc. (see, e.g., [8], [39]).
One may view our present work as another contribution to this
long debate, speciﬁcally in the context of speciﬁcation mining.The paper is organized as follows. Sect. II provides back-
ground and deﬁnitions. The mining algorithm is presented in
Sect. III. An extension to leverage additional user inputs to
improve the mining process is presented in Sect. IV. Sect. V
presents an evaluation, Sect. VI discusses related works, and
Sect. VII concludes.
II. B ACKGROUND AND DEFINITIONS
We recall the semantics of branching LSCs and their formal
relation to execution trees. We further deﬁne a number of
measures required in the context of scenario mining.
A. Branching LSCs and traces
1) Branching LSCs: We use the branching LSCs deﬁned
in [37], with totally ordered events. An LSC consists of life-
lines representing participating objects and of events between
them. Events are partitioned into pre-chart and main-chart
events, with the following conditional branching semantics:
“whenever a sequence of events in the pre-chart happens,
the sequence of events in the main-chart must be a possible
continuation”. Syntactically, pre-chart events use blue, dashed
lines, and main-chart events use red, solid lines. Figures 1-3
show examples.
Fig. 4 shows an example of an execution tree , which
illustrates the semantics of branching LSCs. The tree rep-
resents three different merged execution traces all starting
with onConnect and ending with setLogout . The tree satisﬁes
the branching LSC Delete (Fig. 1): whenever its pre-chart
onConnect occurs, there exists a continuation with its main-
chart (including onDeleteStart etc). Like a linear LSC, a
branching LSC abstracts from events not mentioned in its pre-
or main-chart as illustrated by the occurrence of Delete
in the right branch of Fig. 4. For the same reason, the
branching LSC Download (Fig. 2) is satisﬁed. There are even
two different traces that continue with the main-chart of the
branching LSC Delete , as highlighted in Fig. 4. In contrast,
the tree violates branching LSC Rename2 (Fig. 5). There is
no trace that continues every occurrence ofonDeleteEnd with
event onRenameStart etc. (the right branch does continue with
Rename2 whereas the left branch does not).
2) Branching LSCs vs. Linear LSCs: Intuitively, to be
counted for branching, an LSC needs to occur on one branch,
and to be counted for linear it has to occur on allbranches. The
tree of Fig. 4 illustrates this difference. If we would interpret
Download of Fig. 2 as a linear LSC, then the tree of Fig. 4
would violate this LSC, because one trace continues without
completing the occurrence of the main-chart of Delete . More
precisely, the occurrence of setLogout at the right-most branch
of the tree will violate the main-chart of LSC Download
which requires (in a linear interpretation) getFileOffset to occur
after setUser .
Thus, branching LSCs allow one to describe alternative
continuations of a pre-chart. In contrast, linear LSCs, such
asLogin of Fig. 3, specify invariants of each trace. The
tree of Fig. 3 satisﬁes Login , which speciﬁes that each call
toonConnect leads to a subsequent setLogout (along the
sequence of events speciﬁed in the chart).
2onLogin()setUser()getFileOffset()onDownloadStart()getDataType()transfer()setDownload()onDownloadEnd()setLogout()onConnect()onDeleteStart()setDelete()onDeleteEnd()1234567891011161718onDeleteStart()setDelete()onDeleteEnd()setLogout()12131415onRenameEnd()setLogout()19202122onRenameStart()getRenameFrom()
LSC-B DeleteLSC-B DownloadLSC-L RenameFig. 4. Execution tree of a trace set from crossFTP (represents 3
merged traces), highlighting occurrences of the LSCs of Figures 1-3.
LSC-L RenameonRenameStart()REQCONTRNTOsetRenameFrom()onRenameEnd()
onRenameStart()REQCONTRNTOsetRenameFrom()onRenameEnd()LSC-B Rename2DELEonDeleteEnd()
Fig. 5. Linear LSC Rename and Branching LSC Rename2 specify-
ing renaming in different contexts.
3) Basic notions: LSCs, traces, and positive witnesses:
More formally, an LSC event is deﬁned by a triple (s, r, m )
where sdenotes the sender object (method caller), rthe
receiver object (callee), and mthe method that sinvoked
to communicate with r. If all events of an LSC are totally
ordered, an LSC L=(pre,main )can be formalized as
two sequences of events describing the pre-chart preand
the main-chart main . For example, LSC Login reads as
(h(RETR ,PASS ,onConnect )i,h(PASS ,CONT ,onLogin )...
(RETR ,REQ,setLogout )i).
In the following we abstract from the inner structure of
events and treat each triple a=hs, r, m ias a single letter
a. In this abstract setting, we consider traces over a ﬁnitealphabet ⌃= {a, b, c, . . . }of events. The symbol ++denotes
the concatenation of two ﬁnite words. Then, an LSC L=
(pre,main )induces a word w=pre++main . Let ⌃Ldenote
the alphabet of “visible” events appearing in w.
Semantics of linear LSCs intuitively require that in every
execution, an occurrence of the pre-chart preis followed by
an occurrence of the main-chart main . We formalize these
occurrences as positive witnesses as follows. A (possibly
empty) word pispreﬁx ofu, written pvuiff there is a
(possibly empty) word u0s.t.u=p++u0. A word sis a
subword of a word uif there are (possibly empty) words u0
andu00s.t.u=u0++s++u00. For a word sand a set ⌃0✓⌃
of “visible” events, the projection of sonto ⌃0is written s|⌃0.
Apositive witness of a word wwrt. the visible events ⌃0in a
word uis alength-minimal subword sofusuch that w=s|⌃0.
4) Execution trees and branching-time semantics: The
branching time semantics of LSCs [37] requires that each
positive witness of preis followed by a positive witness
ofmain in some run , which is naturally expressed on the
semantic domain of execution trees. An execution tree (over
alphabet ⌃) is a rooted, labeled T=(V,E,v 0,`)with nodes
V, edges E, root v0, and a labeling `of nodes and edges such
that
1)`(v0)="(the empty word), and
2)for each edge (v,v0)2Eholds: `(v,v0)=a2⌃such
that`(v)+ +a=`(v0).
Each node node v2Vdescribes a run `(v)from the root v0
tov. A node v2Vis a leaf ofTif for no node v02V,
(v,v0)2E. A node v0is reachable from a node v, written v
v0iff(v,v0)2E⇤(the reﬂexive-transitive closure of E).Tis
deterministic iff for any two edges (v,v0),(v,v00)2Ewith
`(v,v0)=`(v,v00)holds v0=v00. Fig. 4 shows an example of
a deterministic execution tree with three leaf nodes 11,15,22.
The semantics of branching LSCs as deﬁned in [37] reads
on execution trees as follows. Let L=(pre,main )be an
LSC. A word uends with the pre-chart preiffuhas a sufﬁx
s,u=pre++s, such that sis a positive witness of prewrt.
⌃Linu. Let T=(V,E,v 0,`)be an execution tree. A node v
is apositive witness ofpreiff`(v)ends with pre.Tsatisﬁes
Liff for each positive witness vofpreexists a node v02V,
vv0, such that `(v0)is a positive witness of pre++main
wrt. ⌃L; we call v0apositive witness ofLinT. Thus, note
that the semantics of branching LSCs (and of linear LSCs) do
not constrain events not appearing in the LSC to appear or
not to appear in the tree (and trace set), including in between
events that do appear in the LSC.
For example, node 2of Fig. 4 is a positive witness of the
pre-charts of the LSCs of Figures 1-3. Node 11is a positive
witness of Download (Fig. 2) and Login (Fig. 3), 15and
22are positive witness of Delete (Fig. 1) and Login . Node
21is a positive witness of Rename2 (Fig. 5).
In the following we consider weighted execution trees T=
(V,E,v 0,` , )where the weight function assigns each node
v2Va positive integer (v).
3B. Relating execution trees and traces
A weighted deterministic tree represents a (multi-)set of
traces: if two traces share the same preﬁx w, then this preﬁx
is represented in the tree only once by a node v,`(v)=w.W e
use the weight of vto represent how many times `(v)occurs
as a preﬁx of a trace in this set. The weights will be relevant
to discover how many times a particular scenario occurs in a
set of traces.
Atrace Tis a ﬁnite word over ⌃;alogLis a ﬁnite multi-
setof traces, the natural number L(T)describes how often T
occurs in L. Each log Lhas a canonical representation as a
tree: the unique deterministic tree Twhere each leaf represents
exactly one distinct trace. The number of occurrences of traces
inLis captured by node weights of T.
The formal deﬁnition requires an auxiliary notion: for any
word p, let cont(p,L)= {T2T | pvT}denote the
set of traces of Lthat continue a preﬁx p. Now a weighted
treeT=(V,E,v 0,` , )represents the log Liff (1) for each
T2L, exists node v2Vwith `(v)= T, (2) for each
leaf vofV,`(v)2L, (3) `(v1)=`(v2)implies v1=v2,
for all nodes v1,v22V, and (4) for each v2V, holds
(v)=P
T2cont (`(v),L)L(T). Condition (3) implies that Tis
deterministic. Condition (4) states that the weight of each node
is the sum of all occurrences of all traces that “run through
it”; note that this implies (v) (v0)for all (v,v0)2E.
In the following, we assume that all traces in Lstart with the
same event, that is, v0ofThas exactly one outgoing edge.
For example, the tree of Fig. 4 represents three traces
(induced by its leaf nodes). Nodes 1-4have weight 3, nodes
5-10have weight 2, and all other nodes have weight 1. The
weight function allows us to see that the pre-chart onConnect
of Fig. 1 occurs 3 times in the tree. We use the weight function
to deﬁne measures on scenarios, as follows.
C. Measures for LSCs on execution trees
Our goal is to discover from a given log of execution traces
a set of LSCs that describe the behavior in the log according to
the branching-time semantics given in Sect. II-A. We introduce
basic measures that express how good a set of (discovered)
LSCs may describe the behavior recorded in a log.
1) Negative witnesses, support, and conﬁdence: Support
measures the number of times an LSC L=(pre,main )occurs
in the execution tree Tthat represents the log. Conﬁdence
measures the likelihood that a positive witness of preis
followed by a positive witness of main in some branch of
T.
For this, we introduce (weak and strong) negative witnesses .
Anegative witness of Lis a witness of prethat is not followed
by a witness of pre++main . The witness is weak negative if
some trace could be extended to a witness of pre++main (by
adding missing events), and strong negative otherwise (e.g.,
events occur out of order).
Formally, let T=(V,E,v 0,`)be an execution tree and
L=(pre,main )be an LSC.
1)Aweak negative witness ofLinTis a positive witness
v2Vofpresuch that for no node v02V,vv0holds`(v0)is a positive witness of pre++main .
2)Astrong negative witness ofLinTis a positive witness
v2Vofpresuch that for every leaf v02Vand every
ﬁnite word wholds: `(v0)+ +wisnota positive witness
ofpre++main .
Support and conﬁdence measures are based on the weights
of all witnesses. Let pos(L,T),wneg (L,T), and sneg(L,T)
denote the positive, negative, and strong negative witnesses
ofLinT, respectively; pos(pre,T)denotes the positive
witnesses of pre-chart pre. The weight of a witness vinT
is(v). For a set Wof witnesses, let (W)=P
v2W(v)
be the sum of all weights of all witnesses.
1)The support of LinTissup(L,T)=(pos(L,T)),
2)the conﬁdence of LinTis
conf(L,T)=(pos(L,T))+(wneg (L,T)) (sneg (L,T))
(pos(pre,T)).
To account for incomplete traces, conﬁdence only penalizes
strong negative witnesses of L, as weak negative witnesses of
Lcould be extended to positive ones.
For example, in the tree of Fig. 4, LSC Delete (Fig. 1)
has support 2and conﬁdence 1.0, LSC Download (Fig. 2)
has support 1and conﬁdence 1.0, linear LSC Login (Fig. 3)
has support 3and conﬁdence 1.0. In contrast, LSC Rename2
(Fig. 5) has support 1and conﬁdence 0.5. Its pre-chart has
a positive witness at nodes 14and18, but its main-chart has
only a witness at node 21. Thus, 14is a weak negative witness
forRename2 as the trace could be extended (after node 15)
to a positive witness of Rename2 . If the edge from 14to
15was labeled with setRenameFrom ,14would be a strong
negative witness as event onRenameStart would be missing.
As in the case of linear LSCs, the support measure for
the branching case is monotonic. For an execution tree
T, an LSC L, and a word w:|pos(pre++main ,T)| 
|pos(pre++main ++w,T)|[28]. This monotonicity extends
to(pos(pre++main ,T)) (pos(pre++main ++w,T))
because (v) (v0), for all edges (v,v0)ofT. We take
advantage of this monotonicity to prune search when support
falls below a threshold.
Note that the weight function is needed for mining branch-
ing scenarios because the tree merges preﬁxes of traces into
the same node. When mining linear scenarios, one can count
the scenarios in the trace set and no weight function is needed.
2) Two notions of coverage: Finally, the branching se-
mantics of LSCs gives rise to another measure. A setof
LSCs is comprehensive if it can explain every branch in
the execution tree. We formally capture this property in two
coverage measures: the fraction of tree nodes covered by an
LSC (pre- and main-chart), and the fraction of nodes only
covered by main-chart events.
For example, the tree of Fig. 4 is completely covered by
LSCs Delete (Fig. 1), Upload (Fig. 2), and Rename
(Fig. 5 top). When considering main-chart coverage, node
19is not covered , neither by Delete nor by Rename , as
event onRenameStart is not a main-chart event of these LSCs.
We can cover node 19with LSC Rename2 (Fig. 5 bottom).
Main-chart coverage measures the fraction of events in the
4tree that are not explained as the consequence of some pre-
chart . For example, Rename2 explains onRenameStart as
the consequence of onDeleteEnd whereas Rename assumes
onRenameStart to be given. More formally:
1)A node v6=v0of an execution tree Tiscovered by
an LSC L=(pre,main ), written vcovLiff there exist
nodes v1,v22V,v1vv2such that v2is a positive
witness of LinT,v1is the corresponding positive
witness of preinT, and the incoming edge (v0,v)2E
is labeled with an event `(v0,v)2⌃LofL;vismain-
chart covered byL,vcovmL, iff(v0,v)2Eis labeled
with a main chart event of L.
2)For a set Sof LSCs, we write vcovS(vcovmS) iff
vcovL(vcovmL) for some L2S.
3)Thecoverage andmain-chart coverage ofTbySare de-
ﬁned as cov(S,T)=|{v2V|vcovS|}
|V\{v0}|andcovm(S,T)=
|{v2V|vcovmS|}
|V0|, respectively, where V0=V\({v0}[{v|
(v0,v)2E}|).
We use these notions of coverage as a yardstick for the quality
of the mined branching LSCs1.
III. M INING ALGORITHM
We now present the main contribution of this paper: a
mining algorithm for branching LSCs. Sect. III-A introduces
measures to characterize the output of a mining algorithm and
discusses variants of mining. Sect. III-B explains the basic
algorithmic idea and Sect. III-C presents the actual algorithm.
In Sect. III-D we discuss correctness and complexity.
A. Characterizing mining results
A mining algorithm Mextracts from a given log La
ﬁnite set Sof LSCs. One can impose properties on Sto
characterize desirable results of a mining algorithm. For the
branching semantics, three properties are of interest: correct-
ness, completeness, and coverage. We state these properties
in terms of the execution tree Tthat represents L. Intuitively,
a set Sof LSCs is correct wrt. Tif each LSC exceeds a
given conﬁdence threshold c(has no or only a speciﬁed ratio
of negative witnesses in T) and its support exceeds a given
threshold s(occurs often enough). Sis complete wrt. Tif for
any other LSC Lthat is satisﬁed by T(conﬁdence exceeds
threshold c) the support of Lis below threshold s. Finally, a
set of LSCs covers Tif a given percentage of nodes of the
execution tree is explained by at least one LSC. Formally:
1)A set Sof LSCs is correct with respect to Tand thresh-
olds sandciff each L2Shas support sup(L,T) s
and conﬁdence conf(L,T) cin the execution tree T
that represents L.
2)A set Sof LSCs is complete with respect to Tand thresh-
olds sandciff for each LSC Lholds: sup(L,T)<sor
conf(L,T)<corL2S.
1Note that our deﬁnition of coverage relates a set of (mined) branching LSCs wrt.
a set of traces, as it is represented in the execution tree. We do not consider here how
well does the set of traces cover the behaviors of the application from which they were
extracted.3)A set Sof LSCs covers Twith respect to threshold kiff
cov(S,T) k.
The mining algorithm’s objective is to return a set of LSCs
that is correct and complete wrt. the chosen thresholds.
B. Algorithm idea and monotonicity
The mining algorithm proposed in this paper builds on
the mining algorithm for universal LSCs that was proposed
ﬁrst in [28]. The algorithm has two major steps. In the
ﬁrst step, the set of candidate words that exceed the chosen
support threshold sare discovered. In the second step, each
candidate word wis split into all possible pre- and main-
charts pre++main =w; each splitting gives rise to a unique
candidate scenario L=(pre,main )for which the conﬁdence
is checked, that is, whether each occurrence of preis followed
by an occurrence of main (up to the chosen conﬁdence thresh-
old). All LSCs that reach the chosen conﬁdence threshold are
returned, the others are discarded.
The key to efﬁciently ﬁnd a complete set of LSCs above a
certain threshold is a monotonicity property on the number of
positive witnesses of words. For two ﬁnite non-empty words
w,u, the word w++uwill occur at most as often in a tree T
as the word w, because not each occurrence of wis followed
by an occurrence of u. Thus, the discovery starts with single
events that are extended to words by exhausting all possible
event combinations. Once an explored word woccurs less
often than the support threshold s, exploration stops for w,
as no extension w++uwill occur more often than stimes.
Hence, every LSC L=(pre,main )that can be built from a
discovered word w=pre++main will satisfy sup(L,T) 
s, and any other LSC has a support <sinT.
C. Mining algorithm
In the following we consider only LSCs L=(pre,main )
where in pre++main each event occurs at most once.
The algorithm’s main procedure MineLSC is shown in
Fig. 6. It contains the two main steps described above (discover
candidate words, and discover LSCs from candidate words).
Its input consist of the tree and of thresholds for support
and conﬁdence. Its output is a correct and complete set of
statistically signiﬁcant LSCs, i.e., exactly all branching LSCs
that meet the thresholds.
Discovering candidate words begins with discovering the
frequent events that each occur in Tmore often than the
support threshold s(an event occurring less than stimes
cannot be part of an LSC that exceeds s), see procedure
MineSupportedWords . Then procedure MineRecurse recur-
sively builds candidate words from frequent events as follows.
Extend a word wwith each frequent event eto a word w++e.
Ifw++eoccurs more often than threshold s, then w++eis
a candidate word, and then continue recursively with w++e.
Eventually w++efalls below the threshold (or wrepresents
a complete trace ending at a leaf of T), and the recursion
terminates.
The main difference between our branching LSC mining
algorithm and the original linear LSC mining algorithm of [28]
5Procedure MineLSC
Inputs: T: Input Tree; min sup: Min. Sup. Thresh.;
min conf: Min. Conf. Thresh.
Output: A set of statistically signiﬁcant LSCs
LetWSet = MineSupportedWords( T,m i n sup)
LetLSCResult ={}
For every word w2WSet
For every preﬁx preofw
Letmain s.t.pre++main =w
LetNewLSC = Create new LSC ( pre,main )
If (conf (NewLSC ,T) min conf)
Add NewLSC toLSCResult
Return LSCResult
Procedure MineSupportedWords
Inputs: T: Input Tree; min sup: Min. Sup. Thresh.
Output: A set of supported words
LetEV= Single-events occurring  min supinT
LetWSet ={}
For every ev2EV
Call MineRecurse( T,min sup,EV,e v ,WSet )
Return WSet
Procedure MineRecurse
Inputs: T: Input Tree; min sup: Min. Sup. Thresh.;
EV: Frequent Events;
curW : Current word considered;
WSet : Current set of supported words
Output: Updated set of supported words ( WSet )
Add curW toWSet
For every ev2EVwith evnot in curW
LetnxtW =curW ++ev
If(|pos(nxtW ,T)| min sup)
Call MineRecurse( T,min sup,EV,nxtW ,WSet )
Fig. 6. Mining algorithm
lies in the computation of positive and negative witnesses of
an LSC L=(pre,main ), which has to be performed on the
canonical tree Tto determine L’s support and conﬁdence.
Function conf(L,T)called in MineLSC is straightforward.
Find all nodes v1,v2,... ofTwhere `(vi),i > 0ends
with pre. Then for each vi, perform a depth-ﬁrst search
onTstarting at vito ﬁnd a positive witness of main .
Collect all positive and (weak) negative witnesses to compute
conf(NewLSC ,T).
D. Correctness and complexity
The mining algorithm of Fig. 6 is correct: the set
LSCResult returned by MineLSC is correct and complete
w.r.t. the given tree Tand given support and conﬁdence
thresholds min supandmin conf. The proof holds by the
same arguments as for the linear case [28] as follows.
First, MineSupportedWords returns in WSet each word
wwith support  min sup. This proposition holds as Mine-
SupportedWords recurses over all variations (permutations of
subsets) of events that occur at least min suptimes (weighted
occurrences). Recursion stops only for every word wwith
support <min sup, and by the monotonicity of support no
word w++uhas support  min sup.
Second, all LSCs that can be built from WSet (as as-
sumed, all LSCs where each event occurs at most once), willbe considered in MineLSC . Thus, each LSC with support
 min supis considered.
Third, LSCResult contains only those LSCs with conﬁ-
dence  min conf. Thus, LSCResult is the set of all LSCs
having support  min supand conﬁdence  min conf.
Regarding complexity, let nbe the number of single events
occurring at least min suptimes in T(weighted occurrences).
Then up toPn
k=1n!
(n k)!supported words can be found. Each
supported word wof length k> 1gives rise to k 1
LSCs L(pre,main )with pre++main =w. Thus, in worst
casePn
k=2k·n!
(n k)!candidate LSCs have to be checked
for conﬁdence. Checking conﬁdence of one candidate LSC
requires basically one depth-ﬁrst search on T. Thus, if Thas
mnodes, the check succeeds in O(2·m)steps. Altogether, this
gives a worst case complexity of O(Pn
k=1n!
(n k)!+Pn
k=2k·
n!
(n k)!·m)=O(Pn
k=2k·n!
(n k)!·m). This is a very coarse
approximation. By far not each possible variation of events is
a supported word and recursion stops as soon as the support
drops. Also, heuristics allow to prune the search space (number
of recursions) signiﬁcantly. The complexity of the branching
case deviates from the linear case in the ﬁnal step when
checking conﬁdence of LSCs. The linear case has to consider
the entire log (number of cases times average length of all
cases), which is usually larger than the tree.
IV . M INING TRIGGERS AND EFFECTS
In addition to ﬁnding a complete set of LSCs, discovery can
also be driven by the questions “Which triggers are needed
to observe a given behavior main ?” and “What behaviors are
triggered by a given pre-chart pre?”. These two questions lead
totrigger andeffect mining, respectively [23]. Here, the goal is
to ﬁnd for a given pre-chart pre(main-chart main ) the correct
and complete subset Sof LSCs that have this pre-chart (main-
chart).
Mining scenarios given triggers and effects can be beneﬁcial
for two reasons. First, the number of mined scenarios is
typically small and users are presented only with scenarios
of interest. Second, the efﬁciency of the mining process could
be improved signiﬁcantly. This section shows how to extend
the basic mining algorithm of Fig. 6 to solve this problem
variant.
As an example of trigger and effect mining, users can
provide the pre-chart (or main-chart) of the scenario shown
in Fig. 1 as a trigger (or an effect). The mining algorithm
would then only return the set of branching scenarios with
pre-charts matching the given trigger (or main-chart matching
the given effect). This would include the scenario shown in
Fig. 1 and possibly many others, but exclude other scenarios
that are not of interest, e.g., the one shown in Fig. 5 (bottom).
We ﬁrst describe a straightforward solution and give a more
efﬁcient one afterwards. To mine from a given tree Tscenarios
that are triggered by a given pre-chart pre(or have the given
effect main ) with support sand conﬁdence c, we can compute
S=MineLSC (T,s ,c)and then ﬁlter Sby the given pre-
chart or main-chart:
trigger (S,pre)= {(pre,main0)|(pre,main0)2S } and
6e↵ect (S,main )= {(pre0,main )|(pre0,main )2S } . The
result is correct and complete in the following sense.
1)Siscorrect with respect to tree T, support s, conﬁdence
cand pre-chart pre(main-chart main ) iff Scorrect
with respect to T,s, and c(as before) and additionally
(pre0,main0)2Simplies pre0=pre(main0=main ).
2)Siscomplete wrt. T,s,candpre(main ) iff for each
LSC L=(pre0,main0)62 S, one of the following holds:
sup(L,T)sorconf(L,T)corpre 6=pre0
(main 6=main0).
Note that in trigger/effect mining, a given pre-chart predeﬁnes
its own support value sup(pre,T)as upper bound for the
support threshold s. Ifs> sup(pre,T)then the resulting
setS=;. A similar observation is also valid when mining
triggers for a main-chart main .
To improve efﬁciency, we adapt procedure MineSupport-
edWords of Fig. 6 for trigger and effect mining. For a given
pre-chart prewe call MineRecurse with preas ﬁrst supported
word (if preis supported in T). For a given main-chart
main callMineRecurse with main as ﬁrst supported word
(ifmain is supported in T) and compute the next word as
nextW =ev++curW in the recursion step (to build up the
pre-chart for main ). In Sect. V, we show that this improves
the efﬁciency of the mining process signiﬁcantly.
V. I MPLEMENTATION AND EVA L UAT I O N
We report on experimental evaluation of mining branching
scenarios, in particular compared to linear-time scenarios.
A. Experiment design
The main aim of our experiments was threefold: to show the
feasibility of our algorithm to discover branching-time scenar-
ios on actual data sets, to gain insights on how branching-time
scenarios relate to linear ones on actual data , and to evaluate
the beneﬁt of trigger and effect mining for branching scenarios.
We thus formulated four research questions.
RQ I: In what ways is mining of branching scenarios dif-
ferent than mining of linear ones?
RQ II: Which properties of traces impact mining branching
or linear scenarios? Is it possible to estimate useful
support/conﬁdence thresholds from the traces prior
to mining?
RQ III: Is there an advantage to mine both linear and branch-
ing scenarios from the same set of traces?
RQ IV: Could we improve the efﬁciency of the mining pro-
cess by allowing users to specify triggers (or effects)
of interest? What insights can be gained with this
technique?
B. Experiment setup
1) Implementation: We implemented the mining algorithm
of Sect. III (as well as the linear mining algorithm of [23]) in
the Java-based command-line tool Sam that is available at
https://github.com/scenario-based-tools/sam/wiki. Sam takes
as input a log ﬁle in XES format [38] and support and
conﬁdence thresholds and returns the discovered scenarios asTABLE I
BASIC DATA ON THE LOGS .
max.
log traces |⌃| nodes degree width depth
CrossFTP 54 50 921 7 51 64
Columba 104 79 2028 6 70 210
modal UML sequence diagrams [18]. The results are shown on
an HTML page, scenarios are grouped by equivalence classes
sharing the same pre-charts. Sam also visualizes occurrences
of the discovered scenarios on the execution tree of the given
log similar to Fig. 4.
The implementation improves over the algorithm of Sect. III
in two ways. (1) We use a heuristics to prune the search for
supported words as follows. Instead of extending a found sup-
ported word wwith all supported events, we prefer extending
wwith the successor events of all occurrences of wthat have
been found in the tree. When wcannot be extended further, we
return to naive recursive search and also check each subword
ofw(by removing single events) that allows for further
extension not possible for w. We found this heuristics to
greatly reduce the search space and hence the runtime needed
to identify candidate words. (2) We ﬁlter from the resulting
set of LSCs all LSCs that are subsumed by some other LSC.
Intuitively, LSC Lsubsumes LSC KifKholds whenever
Lholds. Formally, LSC L=(preL,main L)subsumes LSC
K=(preK,main K)iff either preLis a subword of preKand
main Kis a subword of main L(Lrequires less in the pre-chart
and provides a larger main-chart), or preK++main Kis a
subword of main LandpreLis not a subword of main K(K’s
pre-chart and main-chart occur while L’s main-chart occurs,
and not earlier). In both cases, every positive witness of preK
succeeds a positive witness of preL(hence Loccurs on some
branch), and every positive witness of Lsucceeds a positive
witness of K(hence an occurrence of Limplies an occurrence
ofK). As a consequence, all smaller LSCs contained in some
larger LSC are omitted from the results.
2) Data: We validated our approach on logs obtained by
tracing method calls of running applications, where each
method call was logged as an event (calling class, called
class, called method). For the experiment, we used logs
obtained from CrossFTP server [4] and from Columba mail
client [3]. Tracing was repeated several times from a well-
deﬁned start state (for CrossFTP: no open connections, for
Columba: showing the main screen of the application), which
yielded several traces per log. The logs are available at [14];
Tab. I shows basic data.
3) Experiment execution: For each log, we mined branch-
ing LSCs and linear LSCs for several support and conﬁdence
thresholds on a standard Laptop at 2.4GHz and 4GB RAM.
The resulting LSCs were grouped by equivalence classes of
identical pre-charts and classiﬁed as strictly branching (if an
LSC was found by the branching miner of this paper and
not by the linear miner), strictly linear (vice versa), and both
otherwise. Additionally, we measured (main-chart) coverage
of the tree for all kinds of scenarios.
7C. Results and analysis
As expected, we did not ﬁnd any strictly linear scenario:
each scenario found by the linear miner was also found by the
branching miner. All results for both logs are available [14];
Tab. II gives a summary.
1) Research question I: As each linear-time scenario is
also a branching-time scenario (each LSC satisﬁed according
to linear-time semantics of LSC is also satisﬁed according
to branching-time semantics), we focused our evaluation on
strictly branching-time scenarios (ones that are not mined
as linear-time scenarios). In all the execution trace sets we
analyzed, we were able to mine linear as well as branching-
time scenarios. For all logs and parameters the branching
miner returned at least the scenarios that also the linear miner
returned, plus additional, strictly branching-time scenarios.
We observed in all logs that strictly branching-time sce-
narios have a lower support than linear scenarios; for high
enough support thresholds, only linear LSCs are found (see ‘#
LSCs’ in Tab. II). For given support and conﬁdence thresholds,
the maximal and average number of events and number of
participating objects in the mined branching LSCs was higher
than those in the mined linear LSCs; however pre-charts of
linear LSCs tend to be longer (see length pre-/main-chart in
Tab. II). Moreover, we often found linear LSCs to abstract
from many behaviors between two events whereas branching
LSCs tended to contain more contiguous sequences of events
without abstraction. These observation make sense, as the
branching ones are in a sense ‘weaker’ than the linear ones:
for a behavior to be counted for branching, it is enough if
it appears on one branch; to be counted for linear, it has to
occur on all branches. As a concrete example, recall the two
branching LSCs, Delete (Fig. 1) and Download (Fig. 2),
and the linear LSC Login (Fig. 3).
Linear and branching scenarios also differ regarding the
coverage measure. Branching-time scenarios yield at least the
same coverage as linear-time scenarios and the lower the
support value, the higher the coverage. We observed consis-
tently higher main-chart coverage for branching-time scenarios
(see ‘coverage’ in Tab. II). Depending on the log, linear
scenario can cover the entire log with pre- and main-charts
(e.g., CrossFTP for support 20). However, linear scenarios are
unable to give complete main-chart coverage with conﬁdence
1.0if the tree has width  2. As a consequence, reasons
for occurrences of a particular branch cannot be discovered
with linear scenarios. For branching scenarios, main-chart
coverage with conﬁdence 1.0 is possible but not guaranteed,
as discussed in Sect. V-C2.
We found the branching scenarios most informative when a
number of mined branching LSCs share an identical pre-chart
and thus the overall interpretation is that of several alternative
continuations. For example, for the traces of crossFTP and
support 14, we rediscovered the six main commands the
server can handle: upload, download, delete, and rename a
ﬁle, create, delete, and rename a directory. For instance, LSCs
Delete andDownload , shown in Fig. 1 and Fig. 2 have
77a3b2a11bc421bc4c1e1ea1e1f1h1g7abc
1d342abc114bcad2113b2a1e1b1e2b1e1f44ca1c11c1hgTbranchingpoints of TFig. 7. Branching diversity in execution trees (node weights inscribed).
been mined. In contrast, the linear miner was only able to
discover the invariants of each individual FTP command and
returned only the LSCs corresponding to Rename of Fig. 5,
which provide no context of their occurrences relative to
each other. The main commands of Columba were harder to
rediscover as we discuss next.
2) Research question II: We observed that for given support
and conﬁdence thresholds, some execution trace sets revealed
relatively more branching LSCs than others. While simple
tree properties such as maximum out degree or width did
not explain the relative share of branching LSCs compared to
linear LSCs, we found the “consistency of branching” in the
tree to have a signiﬁcant effect on branching scenarios. Tree
Tof Fig. 7(left) shows an example: ais always followed by b
andcand only occasionally by d(as alternatives), whereas c
never has the same successor. Thus, only bandcfollow awith
conﬁdence 1.0. However by lowering conﬁdence thresholds,
also dbecomes a possible continuation of a.
This variation with respect to branching can be quantiﬁed
in a measure on the weighted tree T=(V,E,`,v 0,).
For any two events a, b, let (a)=P
v2V(a)(v)where
V(a)= {v|(v0,v)2E,`(v0,v)= a}(number of
occurrences of a) and 1(a, b)=P
(v,v0)2E(a,b)(v)where
E(a, b)={(v,v0)2E|v2V(a),v02V(b)}(number of
a’s having bas successor) and 2(a, b)=P
(v,v0)2E(a,b)(v0)
(number of b’s having aas predecessor). A branching LSC that
contains aandbhasat most conﬁdence 1(a, b)/(a)andat
least support 2(a, b). By the branching points of Tshown in
Fig. 7(right), 2(a, b)=2(a, c) = 13 /13 = 1 .0,2(a, d)=
4/13⇡.31,2(b, e)=6 /6=1 .0,2(b, a)=3 /6= .5,
2(b, f)=2 /6⇡.33, and 2(c, h)=1 /6⇡0.17.
Letconf(a)=( 1(a, b1)/(a),...,1(a, bn)/(a))be the
vector of conﬁdence estimates for direct successors b1,...,b n
ofain descending order. Also, let supp (a)=( 2(a, b1),...,
2(a, bn))be the corresponding support vector. In Fig. 7,
conf(a)=( 1 ,1,.31),supp (a)=( 6 ,6,1)(forb,c,d),conf(b)
=( 1 ,.5,.33),supp (b)=( 3 ,2,1)(for e,a,f),conf(c)=
(.67,.17,.17),supp (c)=( 4 ,1,1)(fora,g,h).
This proﬁle lifts to entire Tby the vectors conf(T)
and supp (T)with conf(T)i= max a2⌃conf(a)iand
supp (T)i=supp (a)iifconf(T)i=conf(a)i, for 1i
max outdegree of T. In Fig. 7, conf(T)=( 1 ,1,.33),
supp (T)=( 6 ,6,1)telling that we ﬁnd two alternative
scenarios with conﬁdence 1and support 6(bandcafter a)
and three alternatives with conﬁdence .33and support 1(e,a,f
after b).
8TABLE II
RESULTS OF THE MINING ALGORITHMS FOR BRANCHING AND LINEAR MINER .
log supp. conf. # LSCs length pre-chart length main-chart coverage runtime
all (⇥103) non-subsumed avg. max. avg. max. all main-chart
CrossFTP 20 1.0 0/26 0/7 -/ 1 -/1 -/6.6 -/23 -/1.0 -/.9 2.5s/3.5s
14 1.0 103/125 12/9 1/2.3 1/7 13.3/5.4 21/23 1.0/1.0 .95/.9 26s/31s
10 1.0 6675/4055 18/9 1/2.3 1/7 18.2/5.4 33/23 1.0/1.0 .95/.9 685s/1008s
Columba 40 1.0 0/.7 0/10 -/1 -/1 -/2 -/5 -/.49 -/.34 <2s /<2s
20 1.0 5/157 1/57 1/1.3 1/2 9/4.1 9/14 .93/.90 .71/.70 154s / 159s
10 1.0 1136/1601 53/205 1.9/1.8 3/3 9.3/5.7 20/18 .95/.91 .75/.72 2055s / 2191s
10 .5 1097/3742 44/163 1/1.4 1/3 6.3/5.7 26/20 .97/.93 .84/.78 2125s / 2256s
all values: strictly branching LSCs / linear LSCs
TABLE III
BRANCHING PROFILE OF THE LOGS .
k=2 3 4 5 6 7 8 9
CrossFTP
supp 9 9 9 9 9 1
conf 1.0 1.0 1.0 1.0 1.0 0.45
Columba
supp 33 19 14 15 11 2 2 1
conf 1.0 1.0 .8 .52 .5 .25 .15 .12
Table III shows the vectors for the two logs. We can
clearly see distinct characteristics of the two trees regarding
consistency of branching.
Intuitively, setting conﬁdence and support to conf(T)k
andsupp (T)kallows to ﬁnd at least kdifferent branching
scenarios that contain the same event (as for these thresholds,
there is some event having kdifferent successors). We could
conﬁrm on our data that conf(T)and supp (T)roughly
correlates with the number of branching scenarios having
the same pre-chart. For CrossFTP, we found for support 10
and conﬁdence 1.0, two equivalence classes each having 6
branching scenarios with the same pre-chart. We did not ﬁnd
any branching scenario for support values >12. For Columba,
we found 1 branching scenario for support 20and conﬁdence
1.0. Support 10and conﬁdence 1.0yielded 2 classes of 2
branching LSCs and 1 class of 3 branching LSCs with the
same pre-chart each. When lowering conﬁdence to .5(see
Tab. II), we discovered among others 1 class of 9 branching
LSCs with the same pre-chart which also revealed the main
uses case of Columba: read message, send message, view
account, view sub-folder, and variations of these; see [14] for
details.
Asconf(T)andsupp (T)can be computed by a depth-
ﬁrst search on T, this proﬁle allows to quickly check whether
the tree branches consistently enough to allow mining relevant
branching scenarios. If branching is too diverse, mining linear-
time LSCs (with high conﬁdence) is preferable over mining
branching-time LSCs with low conﬁdence. The branching
diversity of a tree is not necessarily inherent to the original
application; branching diversity may also be high if some
branches were “just not recorded” in the log. This is com-
parable to a log having only few traces. Then discovering
linear-time LSCs with high support is also impossible.
3) Research question III: Our experiments show that min-
ing both branching and linear scenarios from the same trace
set is indeed valuable, as the two sets of mined scenarios
reveal different, somewhat complementary, information about
the behaviors of the application at hand.TABLE IV
MINING ALL LSC SV S.TRIGGER AND EFFECT MINING ON CROSS FTP AT
SUPPORT 10,CONFIDENCE 1.0,RESULTS FOR STRICTLY
BRANCHING /LINEAR SCENARIOS .
Setting # LSCs # LSCs max. Runtime
all red. length
All 6.6/4.1 ( ⇥106) 34 18/9 685s/1008s
Trigger 1 101/3 ( ⇥103) 26 12/1 18s/18s
Trigger 2 0/17 9 0/1 <1s/<1s
Trigger 3 53/0 15 1/0 <1s/<1s
Effect 1 0/1 4 0/1 <1s/<1s
Effect 2 2290/20 4 9/6 27s/27s
Effect 3 16/17 6 4/1 1s/1s
Trigger/Effect 1 = honConnect i, Trigger/Effect 2 = hsetLogOut i,
Trigger/Effect 3 = honRenameStart ,setRenameFrom ,onRenameEnd i
This is particularly evident when considering sets of branch-
ing and linear scenarios that share the same pre-chart. The
branching scenarios usually show alternative continuations of
the same behavior, such as the 6 commands of crossFTP.
Often, these branching scenarios are accompanied by one or
more linear scenarios describing invariants that hold in all
alternative scenarios. There may be several such invariants.
The two branching LSCs Delete andUpload (Fig. 1 and
2) and the linear LSC Login (Fig. 3) illustrate this.
Usually, the linear scenarios capture the behaviors that are
identical and common to all alternative scenarios. We found
this combination helpful to quickly understand where alterna-
tives do differ. In addition to invariants across all alternatives,
we often could ﬁnd for each strictly branching-time scenario a
shorter linear-time scenario that describes the “essence” of the
branch; for instance Rename (Fig. 5). By combining both, the
linear-time scenarios give insight into “framework” behaviors
and “core” behaviors of an application ( Login (Fig. 3)
and Rename (Fig. 5) are respective examples), while the
branching-time scenarios “glue” the linear-time ones together.
4) Research question IV: Finally, we investigated the pro-
posed extension of mining scenarios with given a trigger or
an effect of interest in the context of branching scenarios.
First, we checked whether efﬁciency was improved by reduced
runtime and smaller, and more focused sets of scenarios.
For this, we chose 3 triggers and effects for the CrossFTP
log shown in Tab. IV (based on the LSCs in Figs. 1-5)
and employed trigger and effect mining at support 10and
conﬁdence 1.0. Table IV compares the number of found
scenarios and runtimes to the case of discovering all LSCs
of given support and conﬁdence.
The number of mined LSCs reduced signiﬁcantly from
9onRenameStart()CONTRNTOREQsetRenameFrom()onRenameEnd()LSC-B Rename-DeleteDELESTAT
onDeleteStart()setDelete()onDeleteEnd()Fig. 8. Branching LSC Rename-Delete specifying subsequent
occurrences of rename and delete operations.
10.7⇥106scenarios (strictly branching and linear) to about
1-104⇥103scenarios in total. This comes with a signiﬁcant
reduction of runtime down to a few seconds. After removing
subsumed scenarios, result sets are of similar size, but scenar-
ios are shorter (see “max. length” in Tab. IV) which allows to
analyze behavior of interest in a more focused way.
Because of signiﬁcant improvements in running time, trig-
ger/effect mining allows to drill down in the given log and
investigate less frequent behaviors. Based on the branching
proﬁle of CrossFTP (Tab. III), we ran a trigger/effect analysis
for support 1and conﬁdence .45for Trigger/Effect 3 (Tab. III).
This allowed us to ﬁnd branching scenarios that were not
found before at support 10. In particular, we found Rename2
of Fig. 5 and Rename-Delete of Fig. 8. Together, these two
strictly branching scenarios describe that the FTP operation
rename can follow the FTP operation delete, and delete can
follow rename (at conﬁdence .45). In other words, we see that
one FTP command can follow another FTP command without
logging out, which was not observable at support 10.
VI. D ISCUSSION AND RELATED WORK
Linear vs. branching-time scenarios. The formal methods
community has had a long debate about the relative merits of
linear vs. branching-time logic as they are used for system
speciﬁcations; which one is easier for engineers to formu-
late and understand, which one may have better perform-
ing synthesis and veriﬁcation algorithms, which one allows
compositional reasoning etc. (see, e.g., [8], [39]). Linear and
branching-time logics correspond to two distinct views of
time [33], and the logics LTL and CTL are expressively
incomparable [8]. Thus, we consider also the choice between a
universal, linear semantics for LSC, as presented in [5], [18],
and a branching semantics for LSC, as presented in [37], to
be open, and depend on the speciﬁc way one wishes to use
the scenarios. One may view our present paper as another
contribution to this long debate: speciﬁcally in the context of
speciﬁcation mining it makes sense to consider both, linear-
time and branching-time behavior, together .
Two of the three authors of the present paper have intro-
duced mining of (linear) scenario-based speciﬁcations in [28].
Several variants and extensions of this initial work have been
presented [23]–[27]. The present work is different from all
of the above as it mines for branching scenarios. Some of thevariants and extensions applied to mining linear scenarios may
be applied to branching-time scenarios as well. Other notions
of branching (existential conditional) scenarios exist [11]–[13],
though these cannot be discovered by our approach as they are
based on partial-order semantics.
A possible use of (mined) linear and branching scenarios
is formal veriﬁcation. Recently, Ben-David et al. [2] have
presented a translation of branching scenarios into CSSL,
a new logic based on an extension of LTL with limited
branching expressiveness, with an efﬁcient model-checking
procedure, speciﬁcally suitable for branching scenarios. Our
mined branching scenarios may be used for model-checking
using the logic and procedure presented in [2].
Other approaches to speciﬁcation mining. Speciﬁcation
mining has attracted much research efforts in recent years;
many approaches and techniques have been suggested. The
different approaches vary and can be roughly categorized
along two dimensions.
Some works use static speciﬁcation mining and learn candi-
date speciﬁcations from source code (see, e.g., [1], [9], [17],
[21], [32], [36], [41]), while others, like our present work,
use dynamic speciﬁcation mining, i.e., look for candidate
speciﬁcations in execution traces (see, e.g., [6], [7], [10], [16],
[19], [20], [29]–[31], [34], [35], [40], [42]). An advantage
of the former is that it does not depend on the quality or
coverage of a speciﬁc set of executions. On the other hand,
like other static analysis methods, it may only provide an over
approximation of the actual behaviors the program may exhibit
at runtime. As future work, we consider the use of source code
for mining branching-time scenarios on the one hand, as well
as advancing the results of our present dynamic approach by
using techniques that can improve the coverage of the set of
executions we use as input.
Some works look for value-based invariants that hold at
speciﬁc points in the program (see, e.g., [10]), while others,
like our present work, look for temporal, behavioral rules,
regarding the order of program actions over time (see, e.g.,
[15], [22], [31], [42]). As shown in [26], these two approaches
may be combined. As future work, we consider such a
combination in the context of branching-time scenarios.
VII. C ONCLUSION
We introduced mining of branching-time scenarios in the
form of existential, conditional live sequence charts, using
a statistical data-mining algorithm. We showed the power
of branching scenarios to reveal alternative behaviors, which
could not be mined by previous approaches. Our work con-
trasts and complements previous works on mining linear-time
scenarios. An implementation and evaluation over execution
trace sets recorded from several real-world applications shows
the unique contribution of mining branching-time scenarios
to the state-of-the-art in speciﬁcation mining. We consider
several directions for future research. First, the integration of
our present work with value-based invariants, following the
ideas presented in [26]. Second, a parametric extension of our
present work, following the ideas presented in [20], [24].
10REFERENCES
[1]M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API patterns as partial
orders from source code: from usage scenarios to speciﬁcations. In
ESEC/SIGSOFT FSE , pages 25–34, 2007.
[2]S. Ben-David, M. Chechik, A. Gurﬁnkel, and S. Uchitel. CSSL: a logic
for specifying conditional scenarios. In SIGSOFT FSE , pages 37–47,
2011.
[3]Columba, Java Email Client. http://sourceforge.net/projects/columba.
[4]CrossFTP Server. sourceforge.net/projects/crossftpserver/.
[5]W. Damm and D. Harel. LSCs: Breathing life into Message Sequence
Charts. J. on Formal Methods in System Design , 19(1):45–80, 2001.
[6]F. C. de Sousa, N. C. Mendonc ¸a, S. Uchitel, and J. Kramer. Detecting
implied scenarios from execution traces. In WCRE , pages 50–59, 2007.
[7]M. El-Ramly, E. Stroulia, and P. G. Sorenson. From run-time behavior
to usage scenarios: an interaction-pattern mining approach. In KDD ,
pages 315–324. ACM, 2002.
[8]E. A. Emerson and J. Y . Halpern. “sometimes” and “not never” revisited:
on branching versus linear time temporal logic. J. ACM , 33(1):151–178,
1986.
[9]D. R. Engler, D. Y . Chen, and A. Chou. Bugs as inconsistent behavior:
A general approach to inferring errors in systems code. In SOSP , pages
57–72, 2001.
[10] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin. Dynamically
discovering likely program invariants to support program evolution. TSE,
27(2):99–123, 2001.
[11] D. Fahland. Oclets - scenario-based modeling with Petri nets. In
PetriNets 2009 , volume 5606 of LNCS , pages 223–242. Springer, 2009.
[12] D. Fahland. From Scenarios To Components . PhD thesis, Humboldt-
Universit ¨at zu Berlin, 2010.
[13] D. Fahland and A. Kantor. Synthesizing Decentralized Components
from a Variant of Live Sequence Charts. In Modelsward 2013 - 1st
International Conference on Model-driven Engineering and Software
Development - Proceedings , pages 25–38. INSTICC, 2013. ISBN:
9789898565426.
[14] D. Fahland, D. Lo, and S. Maoz. Mining Branching LSCs:
CrossFTP, Columba traces and results. 3TU.DataCentrum, 2013.
doi:10.4121/uuid:aa7db920-aae6-4750-8975-cb739262f432.
[15] M. Gabel and Z. Su. Symbolic mining of temporal speciﬁcations. In
ICSE , pages 51–60, 2008.
[16] M. Gabel and Z. Su. Online inference and enforcement of temporal
properties. In ICSE , pages 15–24, 2010.
[17] N. Gruska, A. Wasylkowski, and A. Zeller. Learning from 6, 000
projects: lightweight cross-project anomaly detection. In ISSTA , pages
119–130, 2010.
[18] D. Harel and S. Maoz. Assert and negate revisited: Modal semantics for
UML sequence diagrams. Software and Systems Modeling , 7(2):237–
252, 2008.
[19] S. Kumar, S.-C. Khoo, A. Roychoudhury, and D. Lo. Mining message
sequence graphs. In ICSE , pages 91–100, 2011.
[20] C. Lee, F. Chen, and G. Rosu. Mining parametric speciﬁcations. In
ICSE , pages 591–600, 2011.
[21] Z. Li and Y . Zhou. PR-Miner: automatically extracting implicit pro-
gramming rules and detecting violations in large software code. In
ESEC/SIGSOFT FSE , pages 306–315, 2005.[22] D. Lo and S.-C. Khoo. SMArTIC: towards building an accurate, robust
and scalable speciﬁcation miner. In SIGSOFT FSE , pages 265–275,
2006.
[23] D. Lo and S. Maoz. Mining scenario-based triggers and effects. In ASE,
pages 109–118, 2008.
[24] D. Lo and S. Maoz. Speciﬁcation mining of symbolic scenario-based
models. In S. Krishnamurthi and M. Young, editors, PASTE , pages 29–
35. ACM, 2008.
[25] D. Lo and S. Maoz. Mining hierarchical scenario-based speciﬁcations.
InASE, pages 359–370, 2009.
[26] D. Lo and S. Maoz. Scenario-based and value-based speciﬁcation
mining: better together. In ASE, pages 387–396, 2010.
[27] D. Lo and S. Maoz. Towards succinctness in mining scenario-based
speciﬁcations. In ICECCS , pages 231–240, 2011.
[28] D. Lo, S. Maoz, and S.-C. Khoo. Mining modal scenario-based
speciﬁcations from execution traces of reactive systems. In R. E. K.
Stirewalt, A. Egyed, and B. Fischer, editors, ASE, pages 465–468. ACM,
2007.
[29] D. Lorenzoli, L. Mariani, and M. Pezz `e. Automatic generation of
software behavioral models. In W. Sch ¨afer, M. B. Dwyer, and V . Gruhn,
editors, ICSE , pages 501–510. ACM, 2008.
[30] L. Mariani, S. Papagiannakis, and M. Pezz `e. Compatibility and regres-
sion testing of COTS-component-based software. In ICSE , pages 85–95.
IEEE Computer Society, 2007.
[31] L. Mariani and M. Pezz `e. Behavior capture and test: Automated analysis
of component integration. In ICECCS , pages 292–301, 2005.
[32] T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, and T. N.
Nguyen. Graph-based mining of multiple object usage patterns. In
ESEC/SIGSOFT FSE , pages 383–392, 2009.
[33] A. Pnueli. Linear and branching structures in the semantics and logics
of reactive systems. In ICALP , volume 194 of LNCS , pages 15–32.
Springer, 1985.
[34] M. Pradel and T. R. Gross. Automatic generation of object usage
speciﬁcations from large method traces. In ASE, pages 371–382. IEEE
Computer Society, 2009.
[35] J. Quante and R. Koschke. Dynamic protocol recovery. In WCRE , pages
219–228, 2007.
[36] S. Shoham, E. Yahav, S. Fink, and M. Pistoia. Static speciﬁcation mining
using automata-based abstractions. In ISSTA , pages 174–184, 2007.
[37] G. Sibay, S. Uchitel, and V . A. Braberman. Existential live sequence
charts revisited. In ICSE , pages 41–50, 2008.
[38] W. M. P. van der Aalst. Process Mining - Discovery, Conformance and
Enhancement of Business Processes . Springer, 2011.
[39] M. Y . Vardi. Branching vs. linear time: Final showdown. In TACAS ,
volume 2031 of LNCS , pages 1–22. Springer, 2001.
[40] N. Walkinshaw and K. Bogdanov. Inferring ﬁnite-state models with
temporal constraints. In ASE, 2008.
[41] A. Wasylkowski and A. Zeller. Mining temporal speciﬁcations from
object usage. Autom. Softw. Eng. , 18(3-4):263–292, 2011.
[42] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M. Das. Perracotta:
mining temporal API rules from imperfect traces. In ICSE , pages 282–
291, 2006.
11