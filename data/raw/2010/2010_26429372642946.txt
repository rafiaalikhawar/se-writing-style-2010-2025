From Out-Place Transformation Evolution to
In-Place Model Patching
Alexander Bergmayr, Javier T roya, and Manuel Wimmer
Vienna University of T echnology , Austria
[lastname]@big.tuwien.ac.at
ABSTRACT
Model transformation is a key technique to automate software en-
gineering tasks. Like any other software, transformations are notresilient to change. As changes to transformations can invalidatepreviously produced models, these changes need to be reﬂected onexisting models. Currently, revised out-place transformations arere-executed entirely to achieve this co-evolution task. However,this induces an unnecessary overhead, particularly when compu-tation-intensive transformations are marginally revised, and if ex-isting models have undergone updates prior the re-execution, theseupdates get discarded in the newly produced models.
To overcome this co-evolution challenge, our idea is to infer
from evolved out-place transformations patch transformations that
propagate changes to existing models by re-executing solely theaffected parts based on an in-place execution strategy. Thereby,existing models are only updated by a patch instead of newly pro-
duced. In this paper, we present the conceptual foundation of ourapproach and report on its evaluation in a real-world case study.
1. INTRODUCTION
Model transformation is a key technique to automate software
engineering tasks [6, 25]. Transformations enable reverse-engi-neering and forward-engineering scenarios and facilitate exchang-ing models between tools [2]. They are often implemented as out-
place transformations [19], where the output models are built from
scratch by executing the transformation on the input models.
Like any other software, transformations change over time [23,
27, 30]. As changes to transformations can invalidate previouslyproduced models, these changes need to be propagated to existingmodels. We refer to this challenge as transformation/output model
co-evolution, where changes to a transformation imply an evolu-tion. Consequently, output models need to co-evolve. Currently,revised out-place transformations have to be entirely re-executedto achieve this co-evolution task. However, this induces an unnec-essary overhead, particularly when computation-intensive transfor-mations are marginally revised, and if existing models have un-dergone manual updates prior the re-execution, these updates getdiscarded in the newly produced models. Furthermore, if mod-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributedfor proﬁt or commercial advantage and that copies bear this notice and the full cita-tion on the ﬁrst page. Copyrights for components of this work owned by others thanACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-publish, to post on servers or to redistribute to lists, requires prior speciﬁc permissionand/or a fee. Request permissions from Permissions@acm.org.ASE’14, September 15-19, 2014, V asteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.http://dx.doi.org/10.1145/2642937.2642946.els reference each other based on identiﬁers, re-creating the output
models from scratch can break these inter-model references.
To tackle the challenge of co-evolving output models with chang-
es in transformations, we propose to infer in-place patch transfor-
mations from evolved out-place transformations for existing output
models. A patch transformation enables propagating changes ofan evolved out-place transformation to the pertinent output modelswithout re-creating them from scratch. Hence, a patch transfor-mation only updates existing models [19] according to an evolvedtransformation by an in-place execution strategy that enables thepatching of these models. Our approach ﬁlls the gap between cur-
rent research on incremental transformations [9, 11, 13, 16, 21, 22]
for propagating changes in input models to already existing outputmodels and metamodel/transformation co-evolution for propagat-
ing changes in metamodels to transformations [10, 12, 18, 24].
In Section 2, we present dimensions of model transformation
evolution, summarize work related to our approach, and formu-late the statement of the transformation/output model co-evolution
problem. The conceptual foundation for our approach and the gen-eration of in-place patch transformations for out-place transforma-tions implemented in A TL [15] is discussed in Section 3. Finally,we report on evaluation results gained from a real-world case studyfor translating Java models to UML models in Section 4 before weconclude in Section 5 with an outlook on future work.
2. PROBLEM STATEMENT
The background of this work is the model transformation pat-
tern [8]. It describes the systematic transformation of input models
conforming to input metamodels into output models conforming
tooutput metamodels. To implement transformations, several lan-
guages with different characteristics emerged in the last decade.Most importantly, their underlying paradigm can be classiﬁed indeclarative, imperative, and hybrid. Furthermore, the executionpossibilities of transformations is of major interest. While somelanguages enable uni-directional execution only, others are capable
to transform in both directions and to match and synchronize exist-ing input models and output models. In this paper, we set the focuson uni-directional languages and present our approach accordingto A TL, which is one of the most prominent hybrid languages cur-rently used in academia and industry.
To establish the basis for our investigations, we discuss the evo-
lution dimensions one is confronted with in the ﬁeld of model trans-formation engineering. Each evolution dimension we discuss hasaninitial evolution step and an associated co-evolution step. Re-
cently, two evolution dimensions as depicted in Figures 1(a) & 1(b)have been investigated.
There are approaches that consider the evolution of metamod-
els based on which transformations are deﬁned (cf. Figure 1(a)).
647
InputModels OutputModels TransformationInputMetamodels OutputMetamodels
conforms to conforms to
Transformation’co-evolvesdefined with
respect toInputMetamodels’ OutputMetamodels’
evolves evolves
InputModels OutputModels TransformationInputMetamodels OutputMetamodels
conforms to conforms to defined with
respect to
InputModels’ OutputModels’evolves co-evolves
InputModels OutputModels Transformation
Transformation’evolves
OutputModels’co-evolvesInputMetamodels OutputMetamodels
conforms to conforms to defined with
respect to(a)
(b)
(c)
Figure 1: Dimensions of model transformation evolution: (a) meta-
model/transformation co-evolution, (b) input/output co-evolution,(c) transformation/output co-evolution.
Metamodels contribute important parts to the type system of trans-
formations. Consequently, if they change, the transformations arealso inﬂuenced and may require co-evolution actions. This evo-lution dimension is often referred to as metamodel/transformationco-evolution and is supported by [10, 12, 18, 24]. The main goal ofthese approaches is to (semi-)automatically adapt transformationsto new metamodel versions while preserving their behavior.
The evolution at model level poses another challenge. If input
models evolve, the respective output models have to co-evolve (cf.Figure 1(b)). This could be straightforwardly achieved by execut-ing the entire transformation in batch mode for new versions of in-put models. Due to several reasons, such as reducing computationtime, e.g., in case of minor changes on large models or preserv-ing manual updates in the output models, an incremental execu-tion of the transformation is preferred. Thereby, only changes ininput models are propagated by the transformation to output mod-els. There are several approaches that allow incremental executionof model transformations with respect to changes in input mod-els; consider [9] for a survey and [11, 13, 16, 21, 22] for speciﬁcapproaches. The main idea behind incremental transformations isthat the runtime complexity of a transformation is no longer propor-tional to the size of input models but instead to the size of changesperformed on them. A related approach refers to change-driventransformations [3] that react to changes in one model by propagat-ing them to other models.
Besides these two evolution dimensions, which received already
attention in research, we identiﬁed a third one (cf. Figure 1(c)) thatcan be considered as the intersection of the two discussed dimen-sions and, to the best of our knowledge, has not yet been tackled.Assuming that a transformation based on which output models havealready been produced from input models evolves, e.g., due to ﬁx-ing a bug in the transformation, all transformation executions haveto be reproduced to turn existing output models into valid trans-formation results. Clearly, the same beneﬁts incremental transfor-mations provide for propagating changes in input models to outputmodels are desirable for reﬂecting changes in transformations topreviously produced output models. This leads to the followingproblem statement of our work: How can we achieve incrementaltransformation execution that propagates changes in transforma-tions to existing output models?
3. PATCH TRANSFORMATIONS
We now discuss how the challenge of propagating changes in
transformations to previously produced output models is tackled.The general idea of our approach is to reformulate changes done inout-place transformations as in-place transformations that are capa-ble of propagating these changes to the respective output models.
3.1 Approach at a glance
Figure 2 gives an overview of our approach. The upper part con-
siders the model transformation pattern as discussed in Section 2.Filled lines represent inputs and outputs while thick dashed linesrepresent optional inputs and outputs. Thin dashed lines representconceptual and conformance relationships, and indicate evolution.Regarding the upper part, a model transformation receives a set ofmodels as input and produces a set of models as output. Option-ally, it can automatically produce a special kind of output model,namely a trace model. It captures the relationships between ele-
ments of input models and output models by deﬁning trace links.Each trace link corresponds to the execution of a transformationrule as we will see later in more detail.
The lower part describes the evolution of transformations and
captures the main steps of our approach. Here, evolution meansthat at least one change has occurred in the original transformation.The set of change types that we consider in this paper is describedin Section 3.3. With the original transformation and the evolvedone, we produce a so-called diff model [17] that describes the dif-
ferences between the two transformation versions. Subsequently,aHigher-Order Transformation (HOT)
1[1, 26, 28] takes this diff
model and the two transformation versions as input and produces anew transformation called Patch Transformation (PT). It deﬁnes the
transformation rules required to co-evolve existing output modelsaccording to changes in the transformation that has been executedto produce these models.
APT can have up to three (sets of) input models. Output models
produced from the original transformation are considered as inputmodels of a PT because they are evolved according to the changes
indicated by a PT. The trace model and existing input models of
the original transformation are optional inputs for a PT. Evidently,
the more information is provided as input, the more accurate theevolved output models can be. In this work, we consider the casewhere all three inputs are available. Thereby, a PT is capable of
producing results, i.e., output models and trace models, that are
1According to [26], “a HOT is a model transformation such that its
input and/or output models are themselves transformation models”.
InputModelsOutputModels
TransformationInputMetamodels OutputMetamodels
conforms toconforms to
Transformation’
OutputModels’evolves
Patch
TransformationHigherͲOrderTransformationdefined with
respect to
TraceModel
DiffModel
TraceModel’conforms to
Figure 2: Patch transformation generation at a glance.
648equal compared to results gained from entirely re-executing the
changed transformation for which a PT has been generated.
3.2 Transformation Language Elements
We have selected the A TL language as a proof-of-concept for our
approach. It is a hybrid model transformation language containinga mixture of declarative and imperative constructs. A TL transfor-mations are unidirectional, operate on read-only input models andproduce write-only output models. As we will see later, this is animportant property of A TL to facilitate patch transformations. Inthis paper, we set our focus on A TL ’s declarative part. The meta-model depicted in Figure 3(a) summarizes the main concepts.
ATransformation is composed of declarative MatchedRules.I t
gets passed Models as input and produces output Models, which
conform to a metamodel (cf. Figure 3(b)). A MatchedRule con-
tains one InPattern and one OutPattern. The former is a query on
the input model and gathers the set of InPatternElements that rep-
resent the input model elements of the rule. It can also contain aFilter. If the conditions of such a Filter are satisﬁed by the InPat-
ternElements, the respective rule is applied. Filters are speciﬁed by
means of OCL (Object Constraint Language) expressions. OutPat-
terns describe the creation of elements in the output model. Such
elements are of type OutPatternElements. Each OutPatternElement
is composed of a set of Bindings. Their values are expressed and
computed by OCL expressions that are used to initialize the fea-tures of output model elements.
Concerning the semantics of A TL, the order in which the rules
are deﬁned does not affect the computation of output models, dueto a two-phase process. In the ﬁrst phase, matching conditions ofrules, i.e., InPatterns, are evaluated. Then, A TL ’s execution en-
gine allocates the set of output model elements that correspond toOutPatterns declared in evaluated rules. In the second phase, these
output model elements are initialized by feature values obtained byBindings.
Listing 1 depicts an excerpt of the Java2UML transformation.
It is currently developed and continuously revised in the ARTISTproject [4]. The transformation consists of 29 rules that are deﬁnedaccording to the Java metamodel (JMM ) provided by MoDisco [7]
and the UML metamodel (UMLMM ), which comes with the Eclipse
modeling distribution. Basically, Java packages and class decla-rations are transformed to their UML correspondences. For thepurpose of demonstrating a running example, we assume that onlyclass declarations contained by certain packages, i.e., domain and
web, are considered. This behavior is achieved by the deﬁned Fil-
(a)
TransformationMatchedRule
name :String
rules 1..*1..1inPattern
InPattern
InPatternElement
name :String1..*elementsFilter0..1filter
OutPatternoutPattern
1..1
OutPatternElement
name :Stringelements
1..*
1..*bindings
Binding
(b)
Class Feature
Reference Attribute0..*featuresclass
1..1 1..1 featureclass
1..1OCLExp1..1 condition
value
Metamodel0..*classesin out
(c)
TraceLink
ruleName : StringTraceElement
patternName :String0..*inElements
Trace0..*
links0..*outElements1..* 1..*Model
conformsTo 1..11..1
ModelElementclass 1..1
value
1..1
Figure 3: Metamodel excerpts: (a) transformation language, (b)metamodeling language, and (c) trace language.ter of the InPattern in the second MatchedRule. The Bindings of
the two rules ensure that the names of the packages and classes aswell as the references in-between are pushed from the Java (input)models to the produced UML (output) models. For demonstrationpurposes, we assume a revision of the shown transformation thatrefers to the Filter condition of the second rule. Thereby, class
declarations contained by the service package instead of the web
package are expected in the produced UML model.
Listing 1: Java2UML A TL transformation evolution.
rule Pack2Pack {
from s:JMM !Package
tot:UMLMM !Package (
name <−s.name ,
packagedElement <−s.ownedElements )}
rule Class2Class {
from s:JMM !ClassDeclaration (
Set{’domain’,’web’}->includes(s.package.name)
Set{’domain’,’service’}->includes(s.package.name) )
tot:UMLMM !Class (name <−s.name )}
Let us comment on a feature of transformation languages that
we call inter-rule dependencies. In our transformation, the return
type of the value expression s.ownedElements is of type Sequence(
JMM!AbstractTypeElement). Thus, it may also contain classes asJMM!ClassDeclaration is a subtype of JMM!AbstractTypeElement.
For that reason, when the Binding is computed, packagedElement
will reference, among others, those elements created in the secondrule
2. It is important that we explicitly deal with these dependencies
when creating patch transformations. In case of our transformation,a modiﬁcation in the second rule may cause the re-computation ofthe second Binding in the ﬁrst rule. To deal with such situations, we
perform a static analysis on the revised transformation. It consistsof using a HOT to determine the return types of value expressionsofBindings. Then, we calculate the dependencies between Bind-
ings and transformation rules. As we explain in Section 3.3, we
use these explicit dependencies when generating patch transforma-tions.
Finally, we use in our approach an explicit trace metamodel (cf.
Figure 3(c)). In fact, we automatically obtain a trace model from atransformation execution, e.g., by using Jouault’s TraceAdder [14].
ATrace is composed of TraceLinks.A TraceLink captures the
name of applied MatchedRule and contains TraceElements. These
elements contain the name of the corresponding InPatternElement
orOutPatternElement and reference to the input model elements
or output model elements that have been queried or generated, re-spectively. To sum up, trace models explicitly capture transforma-tion rule executions and information about input model elementsthat contributed to the generation of output model elements. Anexample trace model for a possible execution of the Java2UMLtransformation is shown in Figure 4.
:TraceLink
ruleName=
“Pack2Pack“:Trace
:TraceLink
ruleName=
“Class2Class“:TraceElement
patternName=“t“:TraceElement
patternName=“t“:TraceElement
patternName=“s“
:ClassDeclaration
name=“Order“:Package
name=“domain”
:Class
name=“Order“:Package
name=“domain“InputModel TraceModel OutputModel
:TraceElement
patternName=“s“owned
Elementspackaged
Elementsvalue
value valuevalue inEl.
inEl. outEl.linkslinks
outEl.
Figure 4: Example trace model fragment for Java2UML.
2A TL performs a transparent lookup of output model elements for
given input model elements when executing Bindings. Hence, it
automatically retrieves corresponding UML elements for queried
JMM elements.
6493.3 Change Types and Patch Requirements
The types of changes we have considered for the evolution of a
transformation and their co-changes for existing output models are
summarized in Table 1. We aim for completeness of our approachby systematically considering the addition and deletion of instancesfor any metaclass in the transformation metamodel (cf. Figure 3(a))and modiﬁcations of their features.
MatchedRule. Adding or deleting a MatchedRule implies to add
or delete the elements that the rule creates. A change of the rulename is propagated to the trace model, to keep it properly updated.
InPatternElement.I f a n InPatternElement is added or deleted,
the matches of a rule for a given input model may change as well.For instance, if we had only one InPatternElement and we add an-
other one, the match is realized now with the cartesian product ofboth element types. Contrarily, if we remove an InPatternElement,
the number of matches for a rule may decrease. Furthermore, theaddition or deletion of an InPatternElement may lead to a change
of the OutPattern in the rule provided that the variable referring to
the new/old InPatternElement is used in one or several Bindings.
As a result, we delete all the changes produced by the rule and ex-ecute it. Similarly, when the class feature of an InPatternElement
changes, we consider it as an addition and a deletion. As for themodiﬁcation of its name feature, we need to propagate the change
to the trace model.
Filter. The effect of adding, deleting, or modifying a Filter is
equally treated. Even if a Filter is not deﬁned, we can still consider
one whose condition is set to true. Similarly, if a Filter is removed,
it is the same as changing it to true. Consequently, we consider the
three cases as if the Filter is modiﬁed. In a ﬁrst step, elements are
added to the output model that are created from elements in the in-put model that now satisfy the Filter, whereas, in a second step, el-
ements are deleted in the output model that correspond to elementsin the input model that do not satisfy Filter anymore. Finally, the
the corresponding Bindings are executed.
OutPatternElement. Adding or deleting an OutPatternElement
implies to add or delete the respective elements in the output modeland to re-execute corresponding Bindings. If the class feature is
changed, we consider it as addition and deletion of the OutPatter-
nElement, whereas the modiﬁcation of the name feature is propa-
gated to the trace model.
Binding. In case a Binding is added or deleted, the effect is to
compute its value or delete the value that was previously computed.If the value expression of a Binding changes, it has to be recom-
puted and reassigned, whereas if the target feature is changed, we
consider it as an addition and a deletion of the Binding.
Apart from the co-changes described above, we also have to take
into account
the dependencies between bindings and rules as ex-
plained in Section 3.2. If changes occur in MatchedRules, InPat-
ternElements, Filters and OutPatternElements (except for modiﬁ-
cation of name features), we need to check if such changes are in-
volved in explicit dependencies. If they are, generated patch trans-formations ensure that the pertinent Bindings are recomputed.
The way patch transformations are executed to produce evolved
output models follow the same semantics A TL applies for full exe-cution (cf. Section 3.2). In a ﬁrst phase, the output model elementsare appropriately added or deleted. Subsequently, in the secondphase, feature values of the output model elements are computed ifnecessary. The latter implies the execution of affected bindings.
Listing 2 presents the patch transformation inferred from the re-
vision of the original out-place transformation in Listing 1. It isdeﬁned in A TL ’s reﬁning mode that enables an in-place transfor-
mation strategy [29].Table 1: Change types and co-changes.
Concept Change type CoͲchangeinoutputmodel
Addition Execution ofMatchedRule
Deletion Deletion ofpreviously produced elements
Modification
(namefeature)Propagation ofnamechangetotracemodel
(ruleName feature)
AdditionDeletion1.Deletionofpreviously produced elements
2.Execution oftheMatchedRule
Modification
(class feature)Considered asAdditionandDeletionof
InPatternElement
Modification
(namefeature)Propagation ofnamechangetotra
cemodel
(patternName feature)
FilterAdditionDeletionModification
(condition feature)1.Deletionofelements that donotsatisfythe
Filter
2.Creationofelements thatsatisfytheFilter
3.Execution ofBindings
Addition1.Creationofelements
2.Execution ofitsBindings
Deletion Deletion ofpreviously produced elements
Modification
(class feature)Considered asAdditionandDeletionof
OutPatternElement
Modification(nam efea
ture)Propagation ofnamechangetotracemodel
(patternName feature)
Addition Execution ofadded Binding
Deletion Deletion offeaturevalues
Modification
(value feature)ReͲexecution ofchangedBinding
Modification
(featurefeature)Considered asAdditionandDeletionof
BindingMatchedRule
InPattern
Element
OutPattern
Element
Binding
Listing 2: Patch transformation in A TL reﬁning mode.
rule PatchFilterDelete {
from s:UMLMM !Class (thisModule .rems−>includes (s))}
rule PatchFilterAdd {
from s:JMM !ClassDeclaration (thisModule .adds−>
includes (s))
tot:UMLMM !Class (name <−s1 .name )}
rule Pack2Pack {
from ps:UMLMM !Package
using {s:JMM !Package =thisModule .tls−>any (e|e.
outElements −>exists (f|f.value =ps)).
inElements −>any (e|e.patternName =’ t ’ ) .
value ;}
to
t:UMLMM !Package (
packagedElement <−ps .packagedElement −>union (
JMM !ClassDeclaration .allInstances ()−>
select (e|s.ownedElements −>includes (e)and
thisModule .adds−>includes (e))))}
In the ﬁrst rule, produced elements of existing models that do
not satisfy the revised ﬁlter condition are deleted, whereas in the
second rule, elements that have previously not satisﬁed the ﬁltercondition but satisfy the revised one are produced. In our example,these elements refer to UML classes of the original output model.The pertinent UML classes are computed prior to the execution ofthe patch rules and provided by the respective sets, i.e., rems and
adds. They are accomplished by executing the original and revisedﬁlter conditions against the original input model and calculatingtheir differences. The third rule is dedicated to the re-execution ofbindings affected by transformation revisions. Even though in ourexample the binding itself has not been explicitly revised, its re-execution is required to ensure that newly added UML classes areappropriately referenced by their containing UML packages. Assuch packages can already contain classes, the union operator needs
to be applied to accomplish the expected result. In this respect, thepertinent Java packages are required as well. They are queried fromthe trace model in the using part of the patch transformation.
6503.4 Implementation
We have implemented our approach as an experimental proto-
type in the Eclipse environment. It is available at our project web
site [20]. To compute the differences between A TL transforma-tion versions, we ﬁrst inject the transformation code into a modelrepresentation by using the A TL injector component. This model-based representation of the transformations allows us to employEMF Compare
3for computing the differences between them. To
get a more concise diff model for our purposes, we provide someaggregation of diff elements as post-processing step of the compar-ison. As a result, we get a solid basis for producing patch transfor-mations. To generate them from diff models, Xtend
4is employed.
Patch transformations are expressed in A TL code. We use the re-ﬁnement mode of A TL to realize them in terms of in-place transfor-mations. Finally, to execute the patch transformations, we use theA TL/EMF Transformation Virtual Machine [29] due to some ad-vanced features and support for true in-place execution instead ofentirely copying the input model as it is performed by the standardA TL virtual machine.
4. EV ALUATION
To evaluate our approach, we investigated the Java2UML re-
verse-engineering case study that is developed and continuouslyevolved in the ARTIST project by means of model transformations.With this case study, we aim to answer the two research questions:
RQ1: Are patch transformations equally effective as the revised
transformations based on which they are inferred?
RQ2: How is the speed-up of executing patch transformations
compared to re-executing the pertinent revised transformation?
4.1 Case Study Setup
For the purpose of our case study, we selected a Java2UML
transformation that shows an extensive and well-documented evo-lution. As input models for this transformation, we selected a refer-ence application of the ARTIST project, which is based on the JavaPetstore
5, and a framework that is of high relevance in this respect:
EclipseLink6. The main rational behind the reverse-engineering
of frameworks is to provide their annotations at the model levelin terms of corresponding UML proﬁles [5]. To generate the re-spective Java models for the reference application and EclipseLink,we employed MoDisco. We selected six different revisions of theJava2UML transformation that have been performed throughout its
development to cover the presented change types and the core ef-fects of patch transformations. Based on these revisions, we in-ferred the corresponding patch transformations.
To answer RQ1, in a ﬁrst step, we executed both the revised
transformations and the inferred patch transformations. The pro-duced output models of the transformations are the basis to investi-gate on the effectiveness of patch transformations compared to theircorresponding revised transformations. Then, in a second step, wepassed the respective pairs of output models to EMF Compare toautomate the comparison task. Clearly, the diff model computedby EMF Compare needs to be empty to show that the producedoutput models are equal. It is important to note that the elementidentiﬁers can be different in the output models as patch transfor-mations preserve them while they are newly produced if revisedout-place transformations are re-executed.
3www.eclipse.org/emf/compare
4www.eclipse.org/xtend
5www.oracle.com/technetwork/java
6www.eclipse.org/eclipselinkTo answer RQ2, we measured and compared the pertinent exe-
cution times of patch transformations and their respective revisedtransformations. For obtaining the measures, we executed the trans-formations in the Eclipse environment on commodity hardware:Intel Core i5-2520M CPU, 2.50 GHz, 8,00 GB RAM, 64 Bit OS.Thereby, a ﬁrst impression of possible performance improvementsby executing patch transformations instead of entirely re-executingrevised transformation is given. All relevant artifacts of our casestudy are available at our project website [20].
4.2 Case Study Results
Considering the output models of the revised transformations
and the patch transformations (RQ1), their comparison shows thatour approach produces effective results. In fact, the updates of ourpatch transformations to the output models reﬂect exactly the in-tended effects of the revisions performed to the original transfor-mation. Clearly, as patch transformations only update the outputmodels based on an in-place execution strategy, identiﬁers of ex-isting elements and possible manual changes to elements that neednot to be patched are preserved.
Turning now the focus to the runtime efﬁciency of our approach
(RQ2), generally, our inferred patch transformations execute lessrules compared to the revised transformations. The number of re-quired rules of a patch transformation slightly varies dependingon the considered change type. In our case study, one up to sixrules were required to build-up a patch transformation. Clearly,this number increases if certain rules need to be re-executed as aresult of revising another rule (cf. inter-rule dependencies). Suchdependencies lead to patch transformations covering not only re-vised rules but also rules that are affected by the performed revi-sions, e.g., bindings, as shown in Listing 1. Finally, the adaptationof the trace model requires also additional rules in the patch trans-formation, e.g., when matched rules are added. While the numberof rules have certainly an impact on the execution time of patchtransformations, our results show that their need to traverse andquery the traces of the original transformation produces an over-head compared to the revised transformations. Still, in our casestudy, for the majority of patch transformations a speed-up can beobserved, as summarized in Table 2. In fact, only in one case, sucha speed-up could not be achieved as the input and output modelsof the reference application are rather small and the inferred patchtransformation for this case is more complex compared to otherones. However, the beneﬁt of patch transformations to guarantee
ChangeType Revised Patch Revised Patch
MatchedRule
Addition0,076 0,067 1,134 6,698 4,766 1,405
MatchedRule
Deletion0,057 0,014 4,071 6,114 1,417 4,315
Filter
Modification0,066 0,079 0,835 5,854 4,987 1,174
OutPattern
Element
Addition0,066 0,058 1,138 7,531 3,149 2,392
Binding
Addition0,063 0,010 6,300 6,687 0,104 64,298
Binding
Deletion0,064 0,009 7,111 6,882 0,058 118,655SpeedͲUp SpeedͲUpEclipseLink
(>100.000 Elements)Reference Appliction
(>1000Elements)
Transformation Transformation
Table 2: Re-execution vs. patch execution (time measures in sec.)
651a non-invasive update to the output models is in our case study al-
ways given.
Threats to validity. We focussed on the Java2UML case study
and applied patch transformations on small to large models thatrepresent real-world applications and frameworks. Concerning in-ternal validity, we need to further explore different combinations ofchanges and investigate if they can be correctly detected and efﬁ-ciently propagated. Concerning external validity, we cannot claimany results outside of our performed case study concerning othertransformation languages or transformations. We leave these con-siderations as subject to future work.
5. CONCLUSION AND FUTURE WORK
In this paper, we presented the problem of transformation/out-
put model co-evolution and tackled it by reformulating changes onout-place transformations in terms of in-place patch transforma-tions for existing output models. We demonstrated our approachfor the declarative part of A TL and showed its beneﬁts in a real-world case study. While our results are already promising, severallines of future work remain. First, we plan to tackle the problemof re-calculating trace models in cases where they are missing bytransforming out-place transformations to match transformations.Second, we want to explore the extreme case where input modelsare missing for existing output models. In this respect, the questionarise to which extent the output models can be kept conform to newtransformation versions.
Acknowledgement
This work is co-funded by the European Commission under theICT Policy Support Programme, grant no. 317859.
6. REFERENCES
[1] C. Amelunxen, E. Legros, and A. Schürr. Generic and
reﬂective graph transformations for the checking andenforcement of modeling guidelines. In VL/HCC, 2008.
[2] M. Amrani, J. Dingel, L. Lambers, L. Lúcio, R. Salay,
G. Selim, E. Syriani, and M. Wimmer. Towards a modeltransformation intent catalog. In Analysis of Model
Transformations Workshop @ MODELS, 2012.
[3] G. Bergmann, I. Ráth, G. V arró, and D. V arró. Change-driven
model transformations - change (in) the rule to rule thechange. SoSyM, 11(3):431–461, 2012.
[4] A. Bergmayr, H. Bruneliere, J. L. Cánovas Izquierdo,
J. Gorroñogoitia, G. Kousiouris, D. Kyriazis, P . Langer,A. Menychtas, L. Orue-Echevarria Arrieta, C. Pezuela, andM. Wimmer. Migrating Legacy Software to the Cloud withARTIST. In CSMR, 2013.
[5] A. Bergmayr, M. Grossniklaus, M. Wimmer, and G. Kappel.
JUMP—From Java Annotations to UML Proﬁles. InMODELS, 2014.
[6] M. Brambilla, J. Cabot, and M. Wimmer. Model-Driven
Software Engineering in Practice. Morgan & Claypool,2012.
[7] H. Bruneliere, J. Cabot, F. Jouault, and F. Madiot. MoDisco:
A Generic and Extensible Framework for Model DrivenReverse Engineering. In ASE, 2010.
[8] K. Czarnecki and S. Helsen. Feature-based survey of model
transformation approaches. IBM Systems Journal,
45(3):621–646, 2006.
[9] J. Etzlstorfer, A. Kusel, E. Kapsammer, P . Langer,
W . Retschitzegger, J. Schoenboeck, W . Schwinger, andM. Wimmer. A Survey on Incremental ModelTransformation Approaches. In Models & Evolution
Workshop @ MoDELS, 2013.
[10] J. García, O. Díaz, and M. Azanza. Model Transformation
Co-evolution: A Semi-automatic Approach. In SLE, 2012.
[11] D. Hearnden, M. Lawley, and K. Raymond. Incremental
Model Transformation for the Evolution of Model-DrivenSystems. In MoDELS, 2006.
[12] L. Iovino, A. Pierantonio, and I. Malavolta. On the Impact
Signiﬁcance of Metamodel Evolution in MDE. JOT,
11(3):3:1–33, 2012.
[13] S. Johann and A. Egyed. Instant and incremental
transformation of models. In ASE, 2004.
[14] F. Jouault. Loosely Coupled Traceability for A TL. In
Workshop Proceedings of ECMDA, 2005.
[15] F. Jouault, F. Allilaire, J. Bézivin, and I. Kurtev. A TL: A
model transformation tool. SCP, 72(1-2):31–39, 2008.
[16] F. Jouault and M. Tisi. Towards Incremental Execution of
A TL Transformations. In ICMT, 2010.
[17] D. S. Kolovos, D. Di Ruscio, A. Pierantonio, and R. F. Paige.
Different models for model matching: An analysis ofapproaches to support model differencing. In CVSM
Workshop @ ICSE, pages 1–6, 2009.
[18] T. Levendovszky, D. Balasubramanian, A. Narayanan, and
G. Karsai. A Novel Approach to Semi-automated Evolutionof DSML Model Transformation. In SLE, 2009.
[19] T. Mens and P . V . Gorp. A taxonomy of model
transformation. ENTCS, 152:125–142, 2006.
[20] Patch Transformations.
http://code.google.com/a/
eclipselabs.org/p/patch-transformations , 2014.
[21] I. Ráth, G. Bergmann, A. Ökrös, and D. V arró. Live Model
Transformations Driven by Incremental Pattern Matching. InICMT, 2008.
[22] A. Razavi and K. Kontogiannis. Partial Evaluation of Model
Transformations. In ICSE, 2012.
[23] A. Rentschler, Q. Noorshams, L. Happe, and R. Reussner.
Interactive Visual Analytics for Efﬁcient Maintenance ofModel Transformations. In ICMT, 2013.
[24] D. D. Ruscio, L. Iovino, and A. Pierantonio. A
Methodological Approach for the Coupled Evolution ofMetamodels and A TL Transformations. In ICMT, 2013.
[25] S. Sendall and W . Kozaczynski. Model transformation: The
heart and soul of model-driven software development. IEEE
Software, 20(5):42–45, 2003.
[26] M. Tisi, F. Jouault, P . Fraternali, S. Ceri, and J. Bézivin. On
the Use of Higher-Order Model Transformations. InECMDA-F A, 2009.
[27] M. van Amstel and M. G. J. van den Brand. Model
Transformation Analysis: Staying Ahead of the MaintenanceNightmare. In ICMT, 2011.
[28] D. V arró and A. Pataricza. Generic and meta-transformations
for model transformation engineering. In UML, 2004.
[29] D. Wagelaar, M. Tisi, J. Cabot, and F. Jouault. Towards a
General Composition Semantics for Rule-Based ModelTransformation. In MODELS, 2011.
[30] M. Wimmer, G. Kappel, J. Schönböck, A. Kusel,
W . Retschitzegger, and W . Schwinger. A Petri Net BasedDebugging Environment for QVT Relations. In ASE, 2009.
652