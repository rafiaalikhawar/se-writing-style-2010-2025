MIT Open Access Articles
Synthesizing data-structure manipulations from storyboards
The MIT Faculty has made this article openly available. Please share
how this access benefits you. Your story matters.
Citation: Rishabh Singh and Armando Solar-Lezama. 2011. Synthesizing data structure 
manipulations from storyboards. In Proceedings of the 19th ACM SIGSOFT symposium and the 
13th European conference on Foundations of software engineering (ESEC/FSE '11). ACM, New 
York, NY, USA, 289-299.
As Published: http://dx.doi.org/10.1145/2025113.2025153
Publisher: Association for Computing Machinery (ACM)
Persistent URL: http://hdl.handle.net/1721.1/72660
Version: Author's final manuscript: final author's manuscript post peer review, without 
publisher's formatting or copy editing
Terms of use: Creative Commons Attribution-Noncommercial-Share Alike 3.0
Synthesizing Data-structure Manipulations from
Storyboards
Rishabh Singh
MIT CSAIL
Massachusetts, USA
rishabh@csail.mit.eduArmando Solar-Lezama
MIT CSAIL
Massachusetts, USA
asolar@csail.mit.edu
ABSTRACT
We present the Storyboard Programming framework, a new
synthesis system designed to help programmers write im-
perative low-level data-structure manipulations. The goal
of this system is to bridge the gap between the \boxes-and-
arrows"diagrams that programmers often use to think about
data-structure manipulation algorithms and the low-level
imperative code that implements them. The system takes
as input a set of partial input-output examples, as well as
a description of the high-level structure of the desired solu-
tion. From this information, it is able to synthesize low-level
imperative implementations in a matter of minutes.
The framework is based on a new approach for combin-
ing constraint-based synthesis and abstract-interpretation-
based shape analysis. The approach works by encoding both
the synthesis and the abstract interpretation problem as a
constraint satisfaction problem whose solution denes the
desired low-level implementation. We have used the frame-
work to synthesize several data-structure manipulations in-
volving linked lists and binary search trees, as well as an
insertion operation into an And Inverter Graph.
Categories and Subject Descriptors
D.1.2 [ Programming Techniques ]: Automatic Program-
ming; I.2.2 [ Articial Intelligence ]: Program Synthesis
Keywords
Program Synthesis, Storyboard Programming, Data struc-
ture manipulations
1. INTRODUCTION
When implementing complex data-structure manipulations,
programmers must bridge the gulf that separates their in-
tuitive understanding of how the manipulation works from
the low-level code that actually implements it. The intuition
behind these manipulations often takes the form of \boxes-
and-arrows" diagrams which programmers might draw on a
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE‚Äô11, September 5‚Äì9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.whiteboard to illustrate the evolution of the data-structure
as it is manipulated. Unfortunately the visual intuition re-
ected in these diagrams is absent from the low-level pointer
updates that make up the implementation. This seman-
tic gap between intuition and implementation makes data-
structure manipulations dicult to write and maintain.
To illustrate this gap, consider the example in Figure 1.
Part (a) of the gure shows a graphical description of the re-
moval of a node from a doubly linked-list. The diagram|we
call it a storyboard |communicates very clearly the eect of
the manipulation. By contrast, the imperative code in Fig-
ure 1(b) is short but not self-explanatory; understanding this
code essentially requires one to mentally recreate the image
from the storyboard in part (a). The system presented in
this paper bridges this gap by using constraint-based syn-
thesis technology to automatically implement data-structure
manipulations that are provably correct with respect to high-
level descriptions like the one illustrated by Figure 1.
a) Graphical intuition:
b x next  
prev  a next  
prev  next  
prev  next  
prev  
b next  
prev  a next  
prev  next  
prev  v 
b) Code:
void dllRemove (Node v ) f
v . n . p = v . p ;
v . p . n = v . n ;
g
Figure 1: Doubly linked list deletion example
Our system is not yet a graphical programming system|
it lacks a graphical user interface|but it brings closer to
reality the promise of an eective graphical programming
model for data-structure manipulations. It does so by sup-
porting a form of Programming by Example (PBE) [6] where
the manipulations are synthesized from partial descriptions
of their eects. The main input to the system is a set of
descriptions of the state of a data-structure before and after
manipulation|essentially text descriptions of storyboards
like the one in Figure 1. Two important features, however,
distinguish our system from traditional PBE systems. Therst is the ability to abstract away those parts of the data-
structure that are not relevant to the manipulation, as is
done in Figure 1 through the use of ellipsis. This form of ab-
straction gives our system a lot of expressive power, because
it allows a single gure to succinctly describe the behavior
of the algorithm on an innite number of concrete inputs,
turning a simple input-output pair into a partial specica-
tion. The second dierence with PBE is that our system
asks the user to provide information about the control-ow
structure of the solution; this information reduces the space
of possible implementations that the system needs to con-
sider and makes it less likely that the system will produce
a solution that only works for the given examples. These
two features allow us to synthesize complex data-structure
manipulations from relatively simple storyboards.
The system is made possible by a new synthesis algorithm
that combines previous work on constraint-based synthe-
sis [24, 29] with abstract interpretation. Our algorithm is
not the rst to do this [29], but it is the rst to scale to the
very large and complex abstract domains required to reason
about data-structure manipulations. The key idea behind
the algorithm is to use quantication to eliminate operations
that require complex set-based reasoning, and to use the
Sketch solver [24] to solve these formulas(Section 5). The
new synthesis algorithm allows us to combine constraint-
based synthesis with a form of shape-analysis loosely based
on TVLA [15]. The shape analysis algorithm used by our
system is not as powerful as many of those found in the lit-
erature [21], but it is powerful enough to reason about most
operations involving trees and lists. The strength of our par-
ticular form of shape analysis, however, lies in the ease with
which we can take the abstractions expressed as part of the
storyboard and use them as the basis for an abstract domain
that is then used to verify each candidate implementation.
In summary, the key contributions of the paper are:
Development of a new model of interaction between
the synthesizer and the programmer, targeted at the
domain of data-structure manipulations (Section 2).
A novel synthesis algorithm that combines constraint-
based synthesis with abstract interpretation to bridge
the gap between high-level graphical specications and
their low-level implementation (Section 5).
The development and evaluation of a tool to automat-
ically synthesize data-structure manipulations involv-
ing linked lists and trees from high-level graphical spec-
ications (Section 6).
So far, we have used our system to successfully synthe-
size several data structure manipulations such as insertion,
deletion, search, reversal and rotation operations over singly
linked list, doubly linked list and binary search tree data
structures. We have also used our framework to synthe-
size small puzzle problems as well as some manipulations
involving a tricky real-world And Inverter Graph [18] data-
structure used in the ABC solver [3].
2. OVERVIEW: LINKED LIST REVERSAL
In this section, we present an overview of our framework
through a textbook data-structure manipulation example:
in-place linked list reversal. Reversing a list with a loop
and using only a constant amount of additional memory isnon-trivial; in fact, the algorithm for this manipulation is
a common question in technical interviews. In the remain-
der of the section, we describe how the user describes this
data-structure manipulation to the framework, and provide
a high-level view of how the synthesizer uses this input to
derive an implementation.
2.1 Storyboard
In order to synthesize the manipulation, our system takes
as input a storyboard composed of three elements: a set of
scenarios , each of which corresponds to an abstract input-
output pair; a set of foldand unfold denitions, and a skele-
ton of the looping structure of the desired algorithm.
A scenario in our system is an input-output pair describ-
ing the eect of the manipulation on a potentially abstract
data-structure, where abstraction is used to elide details of
the data-structure that are not considered relevant. For ex-
ample, Figure 2 below shows the main scenario describing
the eect of reversing a linked list. Like the more informal
f emid 
a b
e‚Äô f‚Äômid‚Äô
a bhead 
next next 
next next head 
Figure 2: Graphical description of linked-list reverse
example in Figure 1, the scenario uses ellipses to abstract
away part of the list. In our notation, however, the ellipses
are formalized by using the concept of summary nodes . For
this example, the scenario uses a summary node midto rep-
resent the middle part of the list, which may vary in size for
dierent runs of the algorithm. Out of all the nodes in the
sub-list represented by mid, the rst and last node deserve
special attention because other nodes outside the sub-list
midmay point to them. We call these special nodes attach-
ment points of the summary node, and as we shall see, they
play an important role in reasoning about scenarios.
Figure 3 shows the complete set of scenarios needed for
this example, including scenarios to describe the behavior
of the algorithm on lists of length zero, one and two. Fig-
ure 3(a) presents the text notation used by our system to
describe one of the scenarios on the right. The storyboard
consists of an environment description and a sequence of
scenario descriptions. The environment denes the set of
variables used in the implementation, the set of elds in the
objects that make up the data-structure (which are called
selectors in the shape analysis literature), and the set of
concrete and summary locations. For this example there are
only four program variables ( head, temp1, temp2 and temp3 ),
one selector corresponding to the eld next, and eight con-
crete locations a, f, e, b, f' and e'. The concrete locations f
and e(resp. f'and e') represent the two attachment points
of the summary node mid(resp. mid'). The environment de-
scription also states a global invariant that the next pointers
of locations fand f'point to midand mid'respectively with a
value of 1/2 in a 3-valued logic similar to TVLA [21]. Each
scenario description, in turn, uses variable predicates, se-Environment
vars Node head, temp1, temp2, temp3
selectors (Node,Node) next
locations Node a, f, e, b, f', e'
summary Node (mid,f,e), (mid',f',e')
invariant next(f,mid)=1/2, next(f',mid')=1/2
Scenario 1
input
head(a) //vars
next(a,f),next(e,b),next(b,null) //sels
output
head(b) //vars
next(b,f'), next(e',a), next(a,null) //sels
(a)
a b next  head  a b head  
next  
a head  a head  
head  head  f e mid 
a b head  
next  next  
e‚Äô f‚Äô mid‚Äô  
a b next  next  head  (b)
Figure 3: Storyboard for in-place linked list reversal
lector predicates and data constraint predicates to dene a
pair of input-output state congurations. The variable pred-
icates of the form var(loc) denote that variable varpoints to
location loc, and the selector predicates of the form sel(loc 1,
loc2)denote that the seleld of location loc1points to loca-
tion loc2. The data constraint predicates dene additional
constraints involving the data values of locations.
In order to make scenarios precise, it is often necessary to
provide additional information about the structure of sum-
mary nodes. For example, in Figure 2, the summary node
midrepresents a set of nodes with a very particular struc-
ture; specically, the scenario only makes sense under the
assumption that node eis reachable from node f. Our sys-
tem allows the user to provide this structural information
through foldand unfold predicates. For example, Figure 4
shows the foldand unfold predicates used to describe the re-
cursive structure of the midsummary node. The predicates
describe the structure of summary nodes in terms of their
attachment points, in a similar way as Fradet et al. [7] used
context-free graph grammars to describe shape types.
The exact syntax and semantics of the predicates will be
discussed in detail in Section 4.1; for now, it is enough to
understand that the predicates in Figure 4(a) are precise
text representations of the recursive denitions illustrated
in Figure 4(b). For example, the unfold rule shows two al-
ternatives for the summary node mid: either the attachment
points fand eare actually the same node x', and this is the
only node in mid, orfis a node x'whose nextpointer points
to the attachment point f'of another similar summary node
mid'. For this example, foldis an inverse of unfold and could
be derived automatically, but Section 4.1 will show other
examples where it is useful to dene foldand unfold inde-
pendently as a way to guide the solver to a specic solution.
The scenarios and the foldand unfold denitions together
describe the eects of the desired manipulation, but recall
that our running example included some non-functional re-
quirements, such as the requirement that the implementa-
tion use of a single loop. This requirement is expressed by
providing a skeleton of the looping structure of the desired
algorithm. Figure 5 shows the skeleton for list reverse, which
states that the implementation should contain exactly one
while loop with some blocks of code before and after it. The
code produced by the synthesizer will have each of theseblocks replaced by a series of guarded assignments of the
form if(COND) then STMT . The conditional COND corre-
sponds to expressions EXP op EXP , where EXP is either an
expression of the form var(.sel?) ornulland opranges over
the set of comparison operators. The set of assignment state-
ments STMT corresponds to assignments of the form LHS =
EXP where LHS is the same set as EXP but excluding null.
Each of these elements|the scenarios, the loop skeleton
and the foldand unfold denitions|comprise a partial speci-
cation of the desired function. For example, the storyboard
above is a partial specication because the abstraction does
not dene the relationship between midin the input and
mid' in the output. In this case, asking the synthesizer to
produce a solution with a small number of statements is suf-
cient to ensure the correct answer, but sometimes the user
may have to provide the system with additional informa-
tion. In keeping with the PBE model, this additional infor-
mation usually takes the form of additional scenarios with
concrete examples, but it can also include providing inter-
mediate state congurations, adding predicates in scenarios
or providing a more detailed implementation sketch in place
of the simple loop skeletons. The strength of our synthesis
approach is that it can combine these dierent constraints
into a concrete implementation. Moreover, as shown in Sec-
tion 6, the constraints imposed by the storyboards are strong
enough that in the few cases where the specication has to
be strengthened, it only takes a few additional concrete sce-
narios or an intermediate state conguration to guide the
framework to synthesize the correct implementation.
2.2 Synthesizing code from storyboards
Our synthesis strategy is based on constraint-based syn-
thesis [24, 29]. The key idea behind this form of synthesis is
to dene a space of possible solutions to the synthesis prob-
lem and to represent it as a parameterized program. For
example, in our case, each unknown assignment can be rep-
resented as a switch statement where an unknown parameter
determines which assignment is actually performed. This
means that the entire solution space can be represented as a
programP(in;c) whereinis the input to the program and c
is a vector of control parameters that determines which com-
putations are performed. The goal of the synthesis processunfold (f,f(f;in;x0);(e;out;x0)g,[true] ) ;
unfold (f,f(f;in;x0);(e;out;e0)g,[x0:next=f0] ) ;
fold(x,f(x;in;f0);(x;out;e0)g,[true] ) ;
fold(x,f(x;in;f0);(e;out;e0)g,[x:next=f] ) ;
( a )
f e mid 
f‚Äô e‚Äô mid 
x‚Äô next  x‚Äô x‚Äô = f  
x‚Äô= e  
x‚Äô = f  
e = e‚Äô  
f e mid 
f‚Äô e‚Äô mid 
x‚Äô next  x‚Äô x‚Äô = f  
x‚Äô= e  
x‚Äô = f  
e = e‚Äô  Unfold:  
Fold: (b)
Figure 4: Unfold and fold predicate denitions for mid summary node
void l l R e v e r s e ( Node head )f
/1/
while (/2/)f/3/g
/4/
return head ;
g
Figure 5: Control ow sketch for list reversal. Each
number corresponds to an unknown block of code.
is then to nd a value csolsuch that the program P(in;c sol)
meets the storyboard specication for all inputs in.
This view of the synthesis problem is common to all con-
straint based synthesis approaches [24, 29]. In our frame-
work, we derive these constraints from the storyboard by
interpreting the input-output states in each scenario of the
storyboard as abstract states in a specially crafted abstract
domain. This allows us to use the theory of abstract in-
terpretation [5] to frame the correctness condition as a set
of equations. The fold/unfold predicates can be understood
in the context of abstract interpretation as a way of den-
ing instrumentation predicates for summary nodes. Once
the correctness condition has been framed as a set of equa-
tions, the translation to constraints follows with only a small
amount of eort.
2.2.1 From storyboards to equations
Our framework uses a powerset domain as an abstract do-
main where the state is represented as a set of shapes. Each
shape, in turn, is represented as a set of predicates, following
a formalism similar to TVLA [15, 21]. Given this abstract
domain, the next step is to use the control ow sketch to
derive a set of equations relating the abstract states at pro-
gram points as described by Sharir and Pnueli in [23]. In
these equations, each one of the unknown blocks of code in
the control ow sketch is represented by a parameterized
transition function Fm(ti;c) that maps an abstract state to
an output abstract state for a given control value c. The
control ow sketch then denes a set of equations involv-
ing the transition functions. For example, the control ow
sketch in Figure 5 induces the following equations, where thetransition function Ficorresponds to block iin the sketch.
t0=F1(in;c); (1)
t1=F3(t0[t2;c); (2)
t2=F2(t1;c); (3)
t3=F2(t0[t2;c); (4)
out=F4(t3;c); (5)
If these equations came from a verication problem, each
of theFiwould be a transition function, and we could use an
iterative approach to nd the least xed point solution to the
equations and check that outmatched the solution required
by the storyboard. But for synthesis, each Firepresents an
unknown block of code, and the cvalues we are interested
in nding do not form a lattice, so we cannot use a standard
iterative solver nd csol. Instead, we provide an ecient
way to encode the problem in a form that an o-the-shelf
constraint solver can eciently solve.
Transition Functions: Each transition function Fm(ti;c)
encodes the behavior of set of possible sequences of guarded
assignments that can be used to complete the control ow
skeleton. In addition to conditional statements, a transition
function can also include two special kinds of statements:
unfold var and fold var . The semantics of unfold and fold
correspond to no-ops in the concrete domain; their sole pur-
pose is to allow the abstract interpretation to reach a xed
point while allowing for very precise reasoning within the
abstract domain. Figure 6 shows the role of the unfold and
fold functions in materializing abstract nodes [21] to allow
for more precise reasoning, and then collapsing multiple ab-
stract shapes into a single one to allow the abstract inter-
pretation to reach a xed point. The semantics of fold and
unfold will be described in detail in Section 4 after we for-
malize the overall abstract interpretation framework.
2.2.2 Equations to Constraints
So far, we have described how to encode the problem in
terms of the least xed point solution of a set of equations.
Our framework translates these equations into a 2QBF for-
mula, which in principle could be solved by any 2QBF solver,
although in practice we have found that only our Sketch
solver scales to large synthesis problems. As we will show
in Section 5, the key idea in the translation to constraints
is that instead of having the transfer functions produce sets
of states, we make the functions non-deterministically pro-
duce one element in the set. Therefore, by exploring allFigure 6: unfold and fold operations in action
Node l l R e v e r s e (Node head ) f
Node temp1 = null , temp2 = n u l l ;
Node temp3 = n u l l ;
temp1 = head ;
while ( temp1 != n u l l ) f
// u n f o l d temp1 ;
head = temp1 ;
temp1 = temp1 . next ;
head . next = head ;
head . next = temp3 ;
temp3 = head ;
// f o l d head ;
g g
Figure 7: Synthesized list reverse implementation
non-deterministic choices, we guarantee that the entire set
is considered.
2.3 Synthesized Implementation
From a satisfying assignment to the constraints, the frame-
work derives the imperative implementation shown in Fig-
ure 7 for the linked list reverse manipulation. The condi-
tionals (all true) from the conditional assignment statements
have been removed for better readability of the code. It can
be noted that the implementation did not use the program
variable ( temp2 ) and the loop body includes an extra dead
store assignment statement ( head.next = head ). Aside from
the additional assignment, the code is an ecient imple-
mentation of the desired algorithm, and the entire synthesis
process takes only a couple of minutes.
3. DATA STRUCTURE CONFIGURATIONS
In this section we present the formalism used by our frame-
work to encode and reason about the storyboard description.
The formalism is based on abstract interpretation, and is
similar to that of TVLA; the primary dierence is our treat-
ment of summary nodes with attachment points. But before
we describe the abstract interpretation, we need to dene the
concrete domain over which programs operate. In this con-
crete domain, the state of the program is dened by a xed
set of local variables and a set of memory locations (also
called nodes), where each location can have a number of
elds pointing to other memory locations. Our framework
currently does not support the allocation of memory by a
synthesized routine, so the set of nodes that the program
has to reason about does not grow as the routine executes.
LetL#represent the set of memory locations the syn-
‚â° f e mid 
a b next  next  x0 a b next  next  
x0 a x1 next  next  b next  
next  next  x0 a x1 next  next  x2 b Figure 8: An abstract list representing innite con-
crete lists
thesized program will operate on. Then, the state of the
program is captured by two sets of predicates. First, for
every variable vand location l2L#there is a predicate
v(l) that indicates whether vpoints to location l. Then, for
every eld sel, there is a predicate sel(l1;l2) that indicates
whether a location l1has a eld selthat points to location l2.
These two sets of predicates encode a concrete shape which
denes the instantaneous conguration of the heap at any
point in the execution.
Shapes in the abstract domain.
The abstract domain consists of sets of abstract shapes ,
where each abstract shape itself represents a set of concrete
shapes. The abstract shapes are dened in terms of a set of
locationsL. Each location loc2Lcan be either a summary
location or a concrete location; we use the predicate sm(loc)
to indicate that locis a summary location, so :sm(loc) indi-
cates that the location is concrete. As we have stated before,
a concrete location locmay serve as an attachment point for
a summary location u, which we express with the notation
loc2A(u); we use the predicate apt(loc) to indicate the role
oflocas an attachment point.
f e mid 
n1 n2 head  
next  next  temp1 temp2 
Figure 9: State conguration for a singly linked list
Example 1.The state conguration in Figure 9 is en-
coded as follows. The set of locations is given by
L=fl1,mid;f;e; l2g, with a summary node mid and at-
tachment pointsA(mid) =ff;eg. The set of program vari-
ables areV=fhead ,temp1,temp2g. The variable predicates
head(l1),temp1(f)and temp2(l2)are true. The next selector
predicates next(l1;f),next(e;l2)and next(l2;null)are true,
and next(f;mid) = 1=2.To make the denition of the abstract domain more for-
mal, consider a concrete shape S#with a set of nodes L#,
a selector predicate sel#and a variable predicate var#, to-
gether with an abstract shape Swith a set of nodes L, selec-
torseland variable predicate var. We say that shape S#is
in the concretization of S(S#2(S)) when there exists a
relationM:L#Lthat satises the following conditions.
Every node in S#maps to some node in Sand vice versa:
i.e.8l12L#9n12Ls:t:M(l1;n1) and8n12L9l12
L#s:t:M(l1;n1)
Nodes that do not map to summary nodes map to a single
concrete node: i.e.for anyl12L#, if:9n2s:t:sm (n2)^
M(l1;n2) thenM(l1;na)^M (l1;nb))na=nb.
Summary nodes do not overlap: i.e.
sm(na)^M(l1;na)^M(l1;nb))(na=nb_nb2A(na)).
Edges between concrete nodes are preserved: i.e.given
l1;l22L#andn1;n22Lwhere:sm(n1) and:sm(n2),
letM(l1;n1) andM(l2;n2); then,
sel#(l1;l2),sel(n1;n2) and var#(l1),var(n1).
Summary nodes own their associated attachment points:
i.e.ifM(l1;n2) andn22A(u) thenM(l1;u)
Any edge pointing to a summary node from the outside
must point to one of its attachment points: i.e.let
sel#(l1;l2)^M(l2;nb)^sm(nb), then eitherM(l1;nb) or
9na2A(nb)s:t:M(l2;na), and for variables, var#(l2)^
M(l2;nb)^sm(nb), then9na2A(nb)s:t:M(l2;na)
Selector edges for summary nodes not originating in an
attachment point are ignored: i.e.ifsm(na)_sm(nb) then
sel(na;nb) = 0_na2A(nb).
Selector edges from an attachment point to its enclosing
summary node will have value 1 =2:i.e.ifna2A(nb) and
9l1;l22L#s:t:sel#(l1;l2)^M (l1;na)^M (l2;nb), and
:9ncs:t:M(l2;nc)^:sm(nc), then sel(na;nb) = 1=2.
In shape analysis it is common to use 3-valued logic to
represent the values of selector and variable predicates in
abstract shapes. However, notice that the rules above specif-
ically require us to ignore most selector edges involving sum-
mary nodes. The restrictions imply that the only selector
edges that will potentially have value equal to 1 =2 are edges
from an attachment point to its corresponding summary
node; that is why we have next(f;mid) = 1=2 in the earlier
example. As we shall see in the next section, the transition
rules in the abstract semantics are dened in such a way
that if the algorithm under analysis ever tries to dereference
a eld corresponding to one of these half edges, it will tran-
sition into an error state. This makes the analysis simpler at
the expense of added imprecision, but our analysis compen-
sates for this imprecision by relying on the unfold predicates
tomaterialize [21] summary nodes.
4. ABSTRACT INTERPRETATION
Having dened the structure of the abstract domain, we
now describe the transition rules used to model statements
and conditionals, focusing on those aspects unique to our
framework. Figures 10 and 11 show respectively the state-
ments and conditionals considered by the synthesizer. Thegures also show the formal denitions of the transition
rules associated with each construct. The transition rules
relate the state before the transition|the pre-state repre-
sented with non-primed predicates|with the post-state rep-
resented with primed predicates. It is assumed that the val-
ues of all other predicates not mentioned in the transition
rule remain unchanged.
Statement Transition rule
x = null8l2L:x0(l) = 0
x = t8l2L:x0(l) =t(l)
x = t.sel assert:9l1;l22L:t(l1)^sel(l1;l2)^sm(l2)
8l2L:x0(l) =9l1t(l1)^sel(l1;l)
x.sel = null assert:9l1;l22L:x(l1)^sel(l1;l2)^sm(l2)
8l1;l22L:sel0(l1;l2) =:x(l1)^sel(l1;l2)
x.sel = t8l1;l22L:sel0(l1;l2) =sel(l1;l2)_(x(l1)^t(l2)))
unfold xunfoldPred (E;M;C)^x(E) =)
((8l1in!l22M:fresh(l2)^
8v2V:v0(l2) =v(l1)^v0(l1) = 0^
8l2L:sel0(l;l2) =sel(l;l1)^sel0(l;l1) = 0)^
(8l1out!l22M:fresh(l2)^
8l2L:sel0(l2;l) =sel(l1;l)^sel0(l1;l) = 0)^C)
fold xfoldPred (E;M;C)^(x(E)^C) =)
((8l1in!l22M:fresh(l2)^
8v2V:v0(l2) =v(l1)^v0(l1) = 0^
8l2L:sel0(l;l2) =sel(l;l1)^sel0(l;l1) = 0)^
(8l1out!l22M:fresh(l2)^
8l2L:sel0(l2;l) =sel(l1;l)^sel0(l1;l) = 0))
Figure 10: Abstract semantics of statements manip-
ulating pointers and pointer-valued elds
The rules follow a convention from shape analysis to as-
sume that every statement of the form exp = t is preceded
by a statement of the form exp = null , where expis either
xorx.sel. This assumption simplies the rules because the
transition rule for exp = t does not have to worry about de-
stroying the value previously stored at exp[21]. The other
important observation about the rules is the use of asser-
tions for the two rules that do eld dereferences. These as-
sertions ensure that the system will transition into an error
state when it tries to dereference a selector that points to
a summary node, which in turn guarantees that 1 =2 values
corresponding to these selector predicates will not propagate
through the representation.
The abstract semantics for the class of conditionals is
shown in Figure 11. It can be noted that although the as-
signment statements in our target language of programs ig-
nore data elds of the data-structure ( .data as opposed to
.sel), the conditionals can reason about the data constraints.
We store data predicates using gt;gte;eqetc., which encode
data constraints over the data values of locations. We do
not consider conditionals involving selector dereferencing of
variables, e.g. of the form x.next == null , as they can be
reduced into a conditional of the form y == null where the
variable yis rst assigned by the statement y = x.next .
4.1 Fold/Unfold semantics
The unfold operation is described with a triple unfoldPred
(E,M,C). The rst argument Eis called the enabling node,
and it represents the summary node that is being expanded.
The transition rule for the unfold x statement performs the
unfold operation only if the variable xpoints to the enabling
node E. The second argument Mis the location mapping
M:loc!loc, which describes how nodes before expansion
relate to nodes after expansion. There are two kinds of loca-tion mappings in M:in!mappings andout!mappings. Anin!
mapping maps a location loc1toloc2such that all variables
and selector edges pointing to loc1in the pre-state should
point to loc2in the post-state. Anout!mapping maps a loca-
tion loc1toloc2such that all outgoing selector edges from
loc1in the pre-state emanate from loc2in the post-state.
Finally, the description of unfold also includes a set of
constraints C. These constraints describe how the new nodes
will be connected together, and are asserted to hold in the
post-state after unfolding. The transition rule for fold x
statement works similarly to the unfold rule. The dierence
is that the foldoperations are enabled only if the constraints
Care also satised by the state conguration in addition to
the requirement of xpointing to the enabling node E. The
unfold and fold predicate denitions on the summary node
midare shown in Figure 4.
Another set of fold-unfold examples for the binary search
tree (bst) case studies is shown in Figure 12. The goal of bst
search is to search for a value xin the tree where rrepresents
its root. The bst search (contains) manipulation assumes
that the value xalways exists in the tree. The three cases of
bst search (contains) unfold are: i) x<y:val , ii)x=y:val
and iii)x > y:val as shown in Fig 12(a), where ydenotes
the root node of the subtree being unfolded. The unfold
denition for the more general case of bst search is shown
in Figure 12(b). The tree summary nodes labeled stu are
given without any unfold rules, which means they cannot
be materialized, so the verier will not be able to reason
about any implementation that tries to visit them. In this
way, the unfold rule is providing algorithmic insights, telling
the synthesizer that a given region of the tree should not be
visited or manipulated.
One important thing to note about unfold is that a given
shape can be expanded in many dierent ways, as illustrated
in Figure 4. This is expressed by having multiple unfoldPred
triples with the same enabling node. As a consequence, ev-
ery abstract shape in the pre-state of an unfold operation
may be expanded into a setof abstract shapes. This expan-
sion allows the analysis to maintain precision, but having to
represent sets of abstract shapes in the abstract interpreter
will pose an interesting challenge when we turn the problem
into a constraint satisfaction problem.
Another very important aspect about unfold is that the
presence of unfold changes the concretization relation be-
tween abstract and concrete shapes. In the absence of un-
fold, any arbitrary set of concrete nodes can be mapped to
a summary node by the relation Mdescribed in the previ-
ous section, but unfold has the eect of placing some struc-
tural constraints on the set of nodes that can be mapped
to a summary node. This is a result of the requirement
that unfold correspond to skipin the concrete domain; this
means that if a given abstract shape Scan be transformed
by unfold into any shape in the set fSig, then the set of con-
crete shapes (S) should equalS
i(Si). So we can rene
the earlier denition of the concretization function to say
thatS#2(S) if it satises the requirements stated before
andifS#2S
i(Si), whereSiare all the shapes that can
be derived from Sthrough the application of unfold . The
next section elaborates on how this denition relates to the
instrumentation predicates used by TVLA to describe the
structure of summary nodes.Conditional Transition rule
x == null8l2L::x(l)
x != null9l2L:x(l)
x == t8l2L:x(l)()t(l)
x.data>t.data8l1;l22L:x(l1)^t(l2) =)gt(data;l1;l2)
x.datat.data8l1;l22L:x(l1)^t(l2) =)gte(data;l1;l2)
x.data == t.data 8l1;l22L:x(l1)^t(l2) =)eq(data;l1;l2)
x.data != t.data 8l1;l22L:x(l1)^t(l2) =) : eq(data;l1;l2)
Figure 11: Abstract semantics of the conditionals
involving the pointer variables
4.2 Relationship with TVLA
In order to understand some of the more subtle aspects of
our formalism, it is useful to understand how it relates to the
formalism in TVLA [15]. The two most apparent dierences
between the two formalisms are the use of attachment points
as part of summary nodes and the use of foldand unfold .
In our system, the unfold denition serves two purposes:
it provides a mechanism to convey structural properties of
summary nodes, and it is also used to materialize summary
nodes, i.e.to produce a set of more rened shapes that to-
gether represent the same set of concrete congurations as
the original conguration. In TVLA, by contrast, structural
properties are described through instrumentation predicates .
These predicates are also used for materialization, but not
directly; instead, a focus operation rst expands a summary
node into a set of possible shapes, and then a coerce oper-
ation uses the instrumentation predicates to rene the new
shapes and to remove those that do not satisfy the required
structural properties.
One can understand the unfold rules in our framework as
a specialized way of describing instrumentation predicates.
For example, from the unfold rule for midwe can derive the
following instrumentation predicate:
isMid (f;e) = (f=e)_9f0(f:next =f0^isMid (f0;e)) (6)
The predicate isMid encodes that every node in midis reach-
able from the front attachment point, and therefore that
the sub-list between fandeis acyclic. When we say that
a summary node satises this predicate, it means that the
summary node can only represent sets of nodes where we
can nd two nodes f and e that satisfy the predicate. The
unfold operation induces this predicate because we want the
eect of unfold in the abstract domain to be equivalent to
the eect of skip in the concrete domain, and this will only
be true if the summary nodes satisfy this predicate. It is in-
teresting to see, however, that the structure of the predicate
is very close to the structure of the unfold rules, with the
attachment points serving as convenient parameters to the
predicate.
Given such an instrumentation predicate, we can map
our summary nodes with attachment points to a shape in
TVLA; for example, Figure 13 shows how mid would look
like as a shape in TVLA. Our unfold operation is equiva-
lent to rst applying materialization to partially concretize
the summary node and then coerce to remove invalid shapes
obtained after materialization.
The use of unfold in place of instrumentation predicates
and the use of attachment points both have a number of
advantages for the purpose of our framework. The rst im-
portant advantage is that it simplies the transition rules,
because it eliminates the need to track instrumentation pred-r 
b stree  
stuff  y 
stuff‚Äô  u u ùë•=ùë¶.ùë£ùëéùëô stuff  y 
r‚Äô 
b‚Äô stree  u ùë•>ùë¶.ùë£ùëéùëô 
y 
stuff‚Äô  r‚Äô 
b‚Äô stree  u ùë•<ùë¶.ùë£ùëéùëô 
Unfold  (a) bst search (contains x) unfold
r 
b stree  stuff  y 
stuff‚Äô  u u stuff  y 
u 
y 
stuff‚Äô  u stuff  y 
r‚Äô 
b‚Äô stree  u 
y 
stuff‚Äô  r‚Äô 
b‚Äô stree  u 
ùë•<ùë¶.ùë£ùëéùëô ùë•>ùë¶.ùë£ùëéùëô 
ùë•=ùë¶.ùë£ùëéùëô ¬¨ùëñùë†ùëÉùëüùëíùë†ùëíùëõùë° (ùë•) 
¬¨ùëñùë†ùëÉùëüùëíùë†ùëíùëõùë° (ùë•) ùëñùë†ùëÉùëüùëíùë†ùëíùëõùë° (ùë•) 
Unfold  
(b) bst search (may not contain x) unfold
r 
l stree  
y 
stuff‚Äô  r‚Äô 
l‚Äô stree  y 
stuff‚Äô  u 
u 
Unfold  r = y = l  
r = y, l=l‚Äô  
(c) bst minimum unfold
r‚Äô 
b‚Äô stree  
stuff  y y 
stuff‚Äô  r 
b stree  
y 
stuff‚Äô  r 
b stree  
stuff  y 
u u 
u u Fold 
(d) bst search fold
Figure 12: Unfold and fold operations for dierent
data structure manipulations
f e 
next  next  
next  
isMid  isMid  isMid  isMid  isMid  isMid  
f‚Äô next  
isMid  isMid  
isMid  isMid  f e 
next  next  
next  
isMid  isMid  
isMid  isMid  isMid  isMid  Figure 13: unfold in 3-valued shape analysis
icates. Another important benet of using summary nodes
with attachment points is that it simplies the graphical
representations, as can be readily appreciated by comparing
Figure 13 with Figure 4. One clear dierence between the
two representations is that Figure 13 includes a number of
selector edges with value 1 =2 which are not present in the
diagrams in Figure 4. This is partly by convention, since we
omit from our representation the selector edges within sum-
mary nodes, and partly because the assumptions in Section 3
ensure that references from concrete to summary nodes al-
ways point to their attachment points.
Compared to TVLA, out formalism allows for a simpler
analysis and more concise graphical representations. The
downside, of course, is reduced expressive power. If one were
trying to verify arbitrary programs, the shortcuts taken by
our system would make the analysis impractical|it would
be too easy for the user to write a program that could not
be veried because it violated one of our assumptions. On
the other hand, as Vechev et al. have pointed out [31], the
combination of synthesis with abstract interpretation means
that the synthesizer can work around the limitations of the
abstract interpreter by producing programs that are easy
to verify. In our case, the way the synthesizer works around
the limitations imposed by our assumption is by using unfold
statements to materialize nodes at the right time and ensure
that the assumption is never violated.
5. CONSTRAINT BASED SYNTHESIS
Having dened our basic abstract interpretation frame-
work, we can now describe how we frame the synthesis prob-
lem as a set of constraints whose solution will describe the
implementation we are looking for. The starting point for
this process is the control ow sketch together with the sto-
ryboard.
The control ow sketch Skconstitutes the control ow
graph of the implementation; unlike a CFG, however, the
vertices are not just basic blocks because they can contain
conditional assignments. More formally, we represent the
control ow sketch Skas a directed graph Sk=G(V;E)
whereVrepresents a set of blocks of code which can ei-
ther be a sequence of conditional assignment statements or
a conditional (for loop exit conditions); Ein turn repre-
sents potential transitions between these blocks of code. By
convention, we say that vertex v0is the entry point of the
graph node and vNis the exit point; neither the entry nor
the exit blocks contain any code. As for scenarios, each of
them is represented as a pair of input and output states
Si= (Ini;Out i).
We use standard techniques to encode each block of un-
known statements as a parameterized function Fi(in;c i),
where the parameter ciselects which block of code out ofthe set of possible blocks of code Fiwill represent. The in-
puts and outputs of Fiare elements of the abstract domain,
which happen to be sets of shapes. Now, the set of possible
sequences of conditional assignments is innite, but bound-
ing the maximum length of the statement sequence makes
the set nite as there are a nite number of assignment state-
ments and conditionals of the form shown in Figure 10 and
Figure 11 respectively.
The goal of the synthesis process is to nd values of ci
such that for each scenario Sk, the least xed point solution
to the following equation satises tN=Outk:
t0=Ink^ 8vi2(Vnv0)ti=Fi([
j2pred (vi)tj;ci) (7)
The function pred(vi) in the equation above indicates the
set of predecessors of node vi. The equation above is fairly
simple, but two challenges prevent us from solving it directly
with an SMT solver. First, the equation above requires us to
nd not just any solution, but the least xed point solution.
Additionally, the tiin the equation above are elements in
the abstract domain, which is composed of sets of shapes.
Such sets can get quite big given the nature of our domain,
so representing them na vely in an SMT solver is infeasible.
In the rest of this section, we describe how our framework
addresses both of these problems.
5.1 Computing Least Fixed Points
In order to nd a least xed point solution to Equation (7),
we start from the assumption that an iterative method can
reach a least xed point after visiting each vertex in Skat
mostKtimes. Now, let PKbe the set of all paths in Skthat
visit each vertex at most Ktimes.For each path pi2PK,
we can dene a path transformer pi(in;~C) which is just the
composition of all the transfer functions Ft(in;c t) of all the
verticesvtin the path, where ~C= [c0;:::;c N]. Then, the
least xed point solution to the value of tNin Equation (7)
will be given by
[
pi2PKpi(Ink;~C)
The equivalence follows from the distributivity of F(i.e.
the fact that F(a[b) =F(a)[F(b)). Given a solution to
the equation above, it is easy to check the assumption of K
convergence by simply checking the solution against Equa-
tion 5.
5.2 Dealing with sets of abstract shapes
As we said before, in order to feed the constraints into a
solver, we would like to avoid having to reason about sets
of abstract shapes. Our strategy will be as follows. First,
from a transfer function F, we can dene a function Fj
that returns a singleton set containing the jthelement of
the set returned by F, or an empty set if there is no jth
element. Thus, F(a) =[jFj(a), where each Fjproduces
either singleton or empty sets.
The strategy even works when composing functions thanks
to the distributivity of F. Because of this property, if we
have a function F(a) and a function T(a), then the compo-
sitionF(T(a)) can be computed as [i;jFj(Ti(a)).
In the case of our transfer functions Fi(in;c), it is rel-
atively easy to derive the functions Fj
i(in;c). For exam-ple, one of the statements that can produce multiple shapes
from a single one is unfold , so if we want a function to re-
turn only the jthshape produced by unfold, we only use
thejthunfoldPred instead of using all of them. Composing
the transfer functions for each block into path expressions,
we get a path expression p~j
i(Ink;~C), where instead of com-
posing functions Fi(in;c i) in the path, we compose func-
tionsFji
i(in;c i). With this transformation, the constraint
we need to solve becomes:
9~C(Outk=[
~j[
pi2Pp~j
i(Ink;~C))
The set unions in the equation above can be turned into
universal quantiers to produce the following equation:
9~C(8~j8pi2Pp~j
i(Ink;~C)2Outk^
9~j9pi2Pp~j
i(Ink;~C) =Outk)
The universally quantied part of the equation forces the
union of the path transformers to be a subset of Outk, while
the existentially quantied part of the constraint ensures
that the singleton Outkis a subset of the union of the path
transformers. The equation above no longer has to reason
about sets with more than one element, but in exchange for
that, it has to cope with 98quantier alternation. However,
theSketch system is very eective in dealing with such
doubly quantied formulas, so our system actually translates
the above equation into a sketch and uses the Sketch solver
to nd a solution to all the unknowns.
5.3 Termination
Equation 5 only ensures partial correctness, so there is no
termination guarantee for the synthesized implementation.
However, we have found that adding a few additional con-
straints was enough to guarantee terminating solutions for
all the examples we examined. The additional constraint
was to require that for every state reachable inside any loop
in the program it is possible to satisfy the loop exit condition
in an additional Kloop unrollings. If the unfold and fold
predicates satisfy well-formedness constraints [19] and with
the restriction of using only one unfold and fold operation
per loop, the framework can guarantee termination of the
synthesized implementation using a reasoning similar to [4].
This restriction works for data-structure manipulations that
perform a single pass over the data-structure.
6. EXPERIMENTS
In our experiments with the Storyboard framework, the
key questions we explored were: i) how does it scale for syn-
thesizing reasonably complex data-structure manipulations,
ii) how much additional information is required to be pro-
vided in the storyboards other than just the input-output
scenarios, iii) how much having abstraction in the scenarios
help and iv) can we use it to synthesize user-dened data-
structure manipulations.
Table 1 presents the experimental results of the case stud-
ies that we performed with the framework. The experiments
were run on an Intel Core-i7 1.87GHz CPU with 4GB of
RAM . The rst column in the table shows the name of the
manipulation where ll refers to singly linked-list, dll refersto doubly linked-list and bst refers to binary search tree.
The table presents the details about number of scenarios
used in storyboard, the total time it took to synthesize the
implementation, the number of clauses in the SAT transla-
tion of the constraints and the memory used. Even though
this is not the most ecient encoding of the constraints, we
were able to synthesize all the manipulations in less than 6
minutes using less than 1 GB of memory.
For reducing the search space in our experiments, we had
to restrict the usage of unfold and foldstatements to at most
once at the beginning and end locations inside the loop re-
spectively; which works well for single-pass algorithms. The
case studies with the Interm column marked yesin Table 1
required some additional intermediate state conguration,
e.g.in the storyboard for linked list insertion , we also had to
provide intermediate state conguration after the loop body
in the skeleton for helping the synthesizer to converge faster.
These intermediate congurations present a natural inter-
face for providing hints about the manipulation. Some case
studies also required composition of storyboards (marked
with a *), e.g.the bst-deletion storyboard required compo-
sition of bst-search and bst-nd-min storyboards.
In some cases like bst-deletion, we found that the abstract
input-output specication was too weak and allowed many
undesired solutions; but it was easily xed by providing a
couple of concrete input-output bst instances. We also per-
formed an experiment where we only provided concrete ex-
amples for these manipulations, the synthesizer either gen-
erated an undesired solution or got timed out and never
converged for most of these case studies. This experiment
shows the ability of abstract input-output examples to prune
a big search space of undesired programs.
We have used our framework to synthesize manipulations
for a complicated real-world AIG data structure. AIG is
a DAG that encodes the structural implementation of the
logical functionality of a circuit [18] using two-input AND
gates and inverters. Each internal node of AIG represents
anandgate and has two parents corresponding to the two
inputs of the gate. The child list information for each node
is overlayed inside the node itself by keeping a pointer to the
rst child and pointers to the sibling nodes. Even though
our framework currently can not synthesize arbitrary graph
manipulations, we exploit the listness property of the child
lists of AIG nodes for synthesizing its manipulations.
Even for complicated data-structures like red-black trees,
where it is dicult to draw a simple storyboard expressing
the complex invariants about the data-structure, we found
the storyboard framework helpful for synthesizing fragments
of low-level code of dierent cases individually and then
manually composing the synthesized code to obtain a com-
plete implementation. Figure 14 shows the storyboard for
red-black tree fixInvariant method (part of the insertion
procedure) that we obtained from an online lecture note [1].
We used the framework to synthesize low-level code for the
four cases, which were then easily composed manually inside
the complete algorithm. Our tool and more details about the
case studies can be found at the storyboard website [2].
7. RELATED WORK
Software synthesis has been an active research area at
least since the early 80s when Waldinger and Manna [17,
16] did seminal work on deductive synthesis. A more algo-
rithmic approach to synthesis was pioneered by Pnueli and
Figure 14: Red-black tree fixInvariant storyboard
Manipulation #Scens Time #Clauses Memory Loops Interm
ll-insertion 4 2m9s 1.99M 0.75GB 1 Yes
ll-deletion 4 1m48s 1.88M 0.54GB 1 Yes
ll-reversal 4 1m49s 1.3M 0.35GB 1 No
ll-nd-last 4 0m56s 1.02M 0.29GB 1 No
ll-swap-rst-last 4 4m18s 1.08M 0.31GB 1 Yes
dll-traversal 4 1m58s 1.72M 0.88GB 1 No
dll-reversal 4 3m47s 2.04M 0.49GB 1 No
bst-search(contains) 1 1m02s 0.62M 0.37GB 1 No
bst-search 1 6m07s 0.77M 0.45GB 1 No
bst-nd-min 1 0m58s 0.63M 0.18GB 1 No
bst-nd-max 1 0m23s 0.57M 0.16GB 1 No
bst-left-rotate 3 3m18s 1.41M 0.50GB 0 No
bst-right-rotate 3 3m15s 1.47M 0.43GB 0 No
bst-insertion3 1m52s 1.04M 0.46GB 1 Yes
bst-deletion6 3m13s 0.63M 0.62GB 2 Yes
aig-insertion4 1m04s 0.17M 0.31GB 1 Yes
Table 1: Experimental results for case studies
Rosner in the context of nite state controllers [20]. More
recently, some of the ideas from the eld of controller synthe-
sis have been applied to software, for example, to synthesize
program repairs [14]. For a recent survey, see [8].
The idea of using abstract interpretation for synthesis was
recently introduced by Vechev, Yahav and Yorsh [31], as a
follow up to earlier work on synthesis of concurrent data-
structures [30]. Their system is designed to synthesize e-
cient synchronization for concurrent programs, and is very
dierent from ours, both in its scope and in the algorithms it
uses. Unlike their system, our synthesizer is based on a more
general constraint-based approach that allows us to handle
extremely large search spaces with no apparent structure.
The idea of using a constraint-based approach for ab-
stract interpretation was previously introduced by Gulwani
et al. [10]. Recently, their group has used similar tech-
niques to synthesize invariants [11] and even complete pro-
grams [29]. Some important distinctions between their work
and ours are the use of storyboards to capture insights, as
well as our path-based representation of the constraints to
support a very large and complex abstract domain.
The idea of using a sketch to dene the structure of the im-
plementation was adapted from the original work on sketch
based synthesis [25]. The idea was originally applied to the
domain of bit-stream manipulations [27], such as ciphers and
error correction codes, and has been applied more recently to
scientic programs [25] and concurrent data-structures [26].
Although Sketch can synthesize some of the data-structure
manipulations, it requires the programmer to provide de-
tailed sketches and only provides bounded guarantees for thesynthesized implementation. Additionally, writing speci-
cations for data-structure manipulations tend to be harder,
because they have to be written as tricky test harnesses.
Recent work in data representation synthesis [12] auto-
matically synthesizes ecient data-structure representations
for a given set of data usage patterns. The representations
are built from a library of data-structure building-blocks
and support only a xed set of common interface methods.
Our framework supports the implementation of more gen-
eral data-structure manipulations, such as our list reverse
example. The price of the generality is a more involved in-
teraction model compared with the push-button interface
provided by that system.
Pins [28] introduced the idea of focusing on individual
paths when generating constraints. Their approach does not
build upon abstract interpretation as ours and our frame-
work lets the synthesizer select interesting paths automat-
ically using the Cegis algorithm unlike a heuristic tech-
nique used by Pins. Gulwani et al. [9, 13] have proposed
component-based synthesis techniques for synthesizing tricky
(but loop-free) code snippets from a given multi-set of com-
ponents. These techniques are not applicable in our setting
as we deal with loopy programs.
8. ACKNOWLEDGMENT
We would like to thank Rastislav Bodik, Zhilei Xu and
the anonymous reviewers for their valuable comments and
suggestions. This research was supported by the National
Science Foundation grant CCF-1049406 and by MIT's Com-
puter Science and Articial Intelligence Lab (CSAIL).
9. REFERENCES
[1] http://cs.wellesley.edu/~cs231/fall01/red-black.pdf.
[2] http://people.csail.mit.edu/rishabh/storyboard/.
[3] Robert K. Brayton and Alan Mishchenko. ABC: An
Academic Industrial-Strength Verication Tool. In
CAV , pages 24{40, 2010.
[4] James Brotherston, Richard Bornat, and Cristiano
Calcagno. Cyclic proofs of program termination in
separation logic. In POPL , pages 101{112, 2008.
[5] Patrick Cousot and Radhia Cousot. Abstract
interpretation: A unied lattice model for static
analysis of programs by construction or approximation
of xpoints. In POPL , pages 238{252, 1977.
[6] Allen Cypher, Daniel C. Halbert, David Kurlander,
Henry Lieberman, David Maulsby, Brad A. Myers,
and Alan Turransky, editors. Watch what I do:
programming by demonstration . MIT Press,
Cambridge, MA, USA, 1993.
[7] Pascal Fradet and Daniel Le Metayer. Shape types. In
POPL , pages 27{39. ACM Press, 1997.
[8] Sumit Gulwani. Dimensions in program synthesis. In
PPDP , pages 13{24, 2010.
[9] Sumit Gulwani, Susmit Jha, Ashish Tiwari, and
Ramarathnam Venkatesan. Synthesis of loop-free
programs. In PLDI , pages 62{73, 2011.
[10] Sumit Gulwani, Saurabh Srivastava, and
Ramarathnam Venkatesan. Program analysis as
constraint solving. In PLDI , pages 281{292, 2008.
[11] Sumit Gulwani, Saurabh Srivastava, and
Ramarathnam Venkatesan. Constraint-based invariant
inference over predicate abstraction. In VMCAI , 2009.[12] Peter Hawkins, Alex Aiken, Kathleen Fisher, Martin
Rinard, and Mooly Sagiv. Data representation
synthesis. In PLDI , pages 38{49. ACM, 2011.
[13] Susmit Jha, Sumit Gulwani, Sanjit A. Seshia, and
Ashish Tiwari. Oracle-guided component-based
program synthesis. In ICSE , pages 215{224, 2010.
[14] Barbara Jobstmann, Andreas Griesmayer, and
Roderick Bloem. Program repair as a game. In CAV ,
pages 226{238, 2005.
[15] Tal Lev-Ami and Shmuel Sagiv. Tvla: A system for
implementing static analyses. In SAS, 2000.
[16] Z. Manna and R. Waldinger. Synthesis: Dreams = >
programs. IEEE Transactions on Software
Engineering , 5(4):294{328, 1979.
[17] Zohar Manna and Richard Waldinger. A deductive
approach to program synthesis. ACM Trans. Program.
Lang. Syst. , 2(1):90{121, 1980.
[18] A. Mishchenko, S. Chatterjee, R. Jiang, and R. K.
Brayton. FRAIGs: A unifying representation for logic
synthesis and verication. Technical report, EECS,
UC Berkeley, 2005.
[19] Huu Hai Nguyen, Cristina David, Shengchao Qin, and
Wei ngan Chin. Automated verication of shape and
size properties via separation logic. In In VMCAI .
Springer, 2007.
[20] Amir Pnueli and Roni Rosner. On the synthesis of an
asynchronous reactive module. In ICALP , pages
652{671, London, UK, 1989. Springer-Verlag.
[21] Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm.
Parametric shape analysis via 3-valued logic. In
POPL , pages 105{118. ACM, 1999.
[22] Horst Samulowitz and Fahiem Bacchus. Binary clause
reasoning in qbf. In SAT, pages 353{367, 2006.
[23] M. Sharir and A. Pnueli. Two approaches to
interprocedural data ow analysis. In S. Muchnick, N.
Jones (Eds.), Program Flow Analysis: Theory and
Applications , pages 189{234, 1981.
[24] Armando Solar-Lezama. Program Synthesis By
Sketching . PhD thesis, EECS, UC Berkeley, 2008.
[25] Armando Solar-Lezama, Gilad Arnold, Liviu Tancau,
Rastislav Bodik, Vijay Saraswat, and Sanjit Seshia.
Sketching stencils. In PLDI , pages 167{178, 2007.
[26] Armando Solar-Lezama, Chris Jones, Gilad Arnold,
and Rastislav Bod k. Sketching concurrent
datastructures. In PLDI , 2008.
[27] Armando Solar-Lezama, Rodric Rabbah, Rastislav
Bodik, and Kemal Ebcioglu. Programming by
sketching for bit-streaming programs. In PLDI , 2005.
[28] Saurabh Srivastava, Sumit Gulwani, Swarat
Chaudhuri, and Jerey S. Foster. Path-based
inductive synthesis for program inversion. In PLDI ,
pages 492{503. ACM, 2011.
[29] Saurabh Srivastava, Sumit Gulwani, and Jerey
Foster. From program verication to program
synthesis. POPL , 2010.
[30] Martin Vechev and Eran Yahav. Deriving linearizable
ne-grained concurrent objects. SIGPLAN Not. ,
43(6):125{135, 2008.
[31] Martin Vechev, Eran Yahav, and Greta Yorsh.
Abstraction-guided synthesis of synchronization. In
POPL , New York, NY, USA, 2010. ACM.