On Software Component Co-Installability
Jérôme Vouillon
CNRS, PPS UMR 7126
Univ Paris Diderot, Sorbonne Paris Cité
F-75205 Paris, France
jerome.vouillon@pps.jussieu.frRoberto Di Cosmo
Univ Paris Diderot, Sorbonne Paris Cité
PPS, UMR 7126 CNRS
F-75205 Paris, France
roberto@dicosmo.org
ABSTRACT
Modern software systems are built by composing compo-
nents drawn from large repositories , whose size and com-
plexity is increasing at a very fast pace. A fundamental
challenge for the maintainability and the scalability of suc h
software systems is the ability to quickly identify the com-
ponents that can or cannot be installed together: this is the
co-installability problem, which is related to boolean sat-
isﬁability and is known to be algorithmically hard. This
paper develops a novel theoretical framework, based on for-
mally certiﬁed. semantic preserving graph-theoretic trans-
formations, that allows to associate to each concrete com-
ponent repository a much smaller one with a simpler struc-
ture, but with equivalent co-installability properties. Thi s
smaller repository can be represented graphically, giving a
concise view of the co-installability issues in the original
repository, or used as a basis for various algorithms related
to co-installability, like the eﬃcient computation of stron g
conﬂicts between components. The proofs contained in this
work have been machine checked in Coq.
Keywords
component, dependencies, conﬂicts, co-installability, p ack-
age management, open source
General Terms
Algorithms, Theory, Veriﬁcation
Categories and Subject Descriptors
D.2.4 [Software Engineering ]: Software/Program Veriﬁ-
cation— Formal Methods ; G.2.2 [ Mathematics of Com-
puting]: Graph Theory— Hypergraphs
Partially supported by the European Community’s 7th Framework Programm e
(FP7/2007-2013), grant agreement n◦214898, “Mancoosi” project.
Work performed at the IRILL center for Free Software Research and Innova tion
in Paris, France.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ESEC/FSE’11, September 5–9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.1. INTRODUCTION
The mainstream adoption of free and open source soft-
ware (FOSS) has widely popularised component-based soft-
ware architectures, maintained in a distributed fashion and
evolving at a very quick pace. Components are typically
made available via a repository , and each of these compo-
nents is equipped with metadata, such as dependencies and
conﬂicts, used to specify concisely the contexts in which a
component can or cannot be installed.
A typical example of the metadata attached to a com-
ponent, taken from the Debian GNU/Linux distribution, is
shown in Example 1: the logical language used for express-
ing dependencies and conﬂicts is quite powerful, as it allows
conjunctions (symbol ‘ ,’), disjunctions (symbol ‘ |’) and ver-
sion constraints.
Example 1.The inter-package relationships of postfix,
an Internet mail transport agent in the Debian GNU/Linux
distribution ( http://www.debian.org ) currently reads:
1Package : postfix
2Version : 2.5.5-1.1
3Depends : libc6 (>= 2.7), libdb4.6, ssl-cert,
4libsasl2-2, libssl0.9.8 (>= 0.9.8f-5),
5debconf (>= 0.5) | debconf-2.0,
6netbase, adduser (>= 3.48), dpkg (>= 1.8),
7lsb-base (>= 3.0-6)
8Conflicts : libnss-db (<< 2.2-3), smail,
9mail-transport-agent, postfix-tls
10Provides : mail-transport-agent, postfix-tls
In most frameworks, determining whether a single com-
ponent can be installed at all is already an NP-Complete
problem, albeit the concrete instances arising in real-world
systems, like GNU/Linux distributions, Eclipse plugins or
OSGI component repositories, turn out to be tractable [1, 2,
3]. For the maintenance of component repositories, though,
moresophisticatedanalysesarerequired. Thisincludesiden-
tifying for each component the other components in the
repository that it absolutely needs [4], and those that it can
never be installed with [5].
More generally, a fundamental challenge for component
based software maintainability is the study of the problem
ofco-installability of components, that involves identifying
and visualising the relevant sets of components that can or
cannot be installed together.
Indeed, from a maintenance point of view, one needs to
identify which components cannot be installed together, in
order to check whether these incompatibilities are justiﬁed
or due to erroneous dependencies. The dependency grapha
b ce
f∨
#d
#g
Figure 1: Graphical depiction of a repository
is also too rich for end users, which are interested in hav-
ing a given set of functionalities provided by some compo-
nents (for instance, they want a word processor and a Web
browser) but do not care about the additional components
also installed. This is illustrated by the fact that some pack-
age managers keep track of these additional components and
automatically remove them when they are no more needed.
The sheer size of current mainstream repositories, with
tens of thousands of components and hundreds of thousands
of relations, makes it completely unfeasible to study such
properties of a repository directly: visualising such large
graphs is both technically challenging, and of little interes t,
as one would need to follow recursively a large number of
dependency and conﬂict relations to understand how com-
ponents relate to one other.
In this paper, we develop a novel theoretical framework,
based on formally certiﬁed. semantic preserving graph-theo-
retic transformations, that allows to associate to each con-
cretecomponentrepositoryamuchsmallerrepositorywitha
simpler structure, but with equivalent co-installability prop -
erties. This smaller repository can be represented graphi-
cally, giving a concise view of the co-installability issue s in
the original repository, or used as a basis for various algo-
rithms related to co-installability, like the eﬃcient compu-
tation of the strong conﬂicts deﬁned in [5].
WeidentiﬁedseveralbugsintheDebiandistributionusing
the present work. For instance, the harden-servers pack-
age, meant to prevent the installation of unsafe packages,
was in conﬂict with packages proftpd etsendmail but did
not prevent the installation of the corresponding binaries
which were in fact in packages proftpd-base etsendmail-
bin(the ﬁrst two packages were actually transitional pack-
ages used to ease the upgrade from a previous release).
The paper is organised as follows: Section 2 recalls the ba-
sic notions about packages and dependencies, and overviews
the repository transformation developed in the paper, which
achieves impressive results on real-world GNU/Linux dis-
tributions (Section 3). The technical development follows:
repositories are equipped with a partial order in Section 4,
put into a ﬂattened form in Sections 5, 6 and 7, simpliﬁed by
removing irrelevant dependencies and conﬂicts in Section 8
and quotiented in Section 9. Finally, we show how to draw
a simpliﬁed graph of the kernel of a repository in Section 11.
We discuss related works, and conclude in Section 13.
2. OVERALL APPROACH
While the concrete details may vary from one technology
to the other, the core metadata associated to component
based systems always allows to express a few fundamental
properties: a component, called package in the following,
maydependon a combination of components, expressed as a
conjunction of disjunctions of components, and a componentmayconﬂictwith a combination of components, expressed
as a conjunction of components.
Extra properties like provides (e.g.postfix-tls in Ex-
ample 1), or versioned constraints (e.g.libc6 (>= 2.7)
in Example 1) can be easily preprocessed out [1], so that
one can focus on a core dependency system that contains a
binary symmetric conﬂict relation, and a dependency func-
tionD(π) ={{π1
1,...,π1
n1},...,{πk
1,...,πk
nk}}that is satisﬁed
when for each iat least one of the πi
jis installed.
An example repository in this core dependency system is
depictedinFigure1, thatalsointroducesthegraphicalnota-
tion used in the paper: package ahas two dependencies, and
can be installed only if, ﬁrst, either package bor package cis
installed, and second, package fis installed; package ccon-
ﬂicts with bandf: neither packages bandc, nor packages c
andf, can be installed simultaneously; package ddepends
on package e, which in turn depends on both fandg.
2.1 Repositories
Wefollowthenotationsofearlierworks[1, 6, 7, 8], thatwe
recall here. A repository is a tuple R= (P,D,C) wherePis
a ﬁnite set of packages ,D:P→P(P(P)) is the dependency
function (we writeP(X) for the set of subsets of X), and
C, a symmetric irreﬂexive relation over P, is the conﬂict
relation. Aninstallation I of a repository ( P,D,C) is a
subset of P. An installation Iishealthywhen the following
holds:
•abundance : everypackagehaswhatitneeds. Formally,
for every package π∈I, and for every dependency
d∈D(π), we have d∩I/\e}atio\slash=∅.
•peace: notwopackagesconﬂict, thatis, C∩(I×I) =∅.
We calldependency a set of packages dincluded in D(π) for
some package π∈P.
One can give a logical interpretation of the dependency
function and the conﬂict relation. The logical variables are
the packages π∈P. A set of packages d∈P(P) is inter-
preted as a disjunction:
/llbracketd/rrbracket=/logicalordisplay
π∈dπ.
A set of set of packages D(π)∈P(P(P)) is interpreted as a
conjunction:
/llbracketD(π)/rrbracket=/logicalanddisplay
d∈D(π)/llbracketd/rrbracket.
A dependency function Dis then interpreted as the set of
formulas of the shape:
π=⇒/llbracketD(π)/rrbracket
whereπranges over P, which can also be written:
π=⇒/logicalanddisplay
1≤i≤n/logicalordisplay
1≤j≤miπi,j
withD(π) ={di|1≤i≤n}anddi={πi,j|1≤j≤mi}.
A conﬂict relation Cis interpreted as the set of formulas
¬π∨¬π′for (π,π′)∈C. A healthy installation is an assign-
ment which simultaneously satisﬁes all these formulas.
2.2 Co-Installability
A package πisinstallable in a repository if it is included in
a healthy installation Iof this repository. A set of packagesa
∨
c1d1cidicndn... ... b1 bi bn
Figure 3: Repository that blows-up when ﬂattened
Π areco-installable in a repository if they are all included
in some healthy installation Iof the repository.
Checking co-installability has been shown equivalent to
SAT by taking advantage of the logical interpretation of
repositories[1]. However, ourexperienceisthatthisproblem
iseasyinpractice: SAT-solverbasedtoolsarecurrentlyused
routinely to identify non-installable components on reposi-
tories that contains dozens of thousands of packages, and
hundreds of thousands of dependencies and conﬂicts.
2.3 Extracting a Co-Installability Kernel
Identifying all the sets of components that cannot be in-
stalled together is way more complex: even if we limit our-
selves to the simplest case of sets of non co-installable com -
ponents of size 2 (also known as strong conﬂicts ), testing all
possible pairs of packages is not a viable option, as the pack-
age number is in the tens of thousands. Even using all the
optimisations described in [5], the computation takes almos t
a week on a modern workstation.
In the present work, we lay down the essential theoret-
ical basis and algorithmic insight for tackling this non co-
installability problem: the fundamental idea is to extract
from the component repository a kernelrepository which is
equivalent to the original one, as far as co-installability is
concerned, but which turns out in practice to be orders of
magnitude smaller, and easily manageable.
The key steps of our approach are now summarised. The
eﬀect of each step on the example repository of Figure 1 is
shown in Figure 2.
Flattening.
The recursive nature of dependencies is convenient for
package developers, as it allows them to describe the de-
pendencies among the diﬀerent packages very concisely, in
a modular way. To study the properties of a repository,
though, it is way more convenient to use only a special ﬂat-
tenedform/hatwideDofdependencyfunctionsthat directlydescribes
all dependencies of each package: if
/hatwideD(π) ={{π1
1,...,πk1
1},...{π1
n,...,πkn
n}},
then the packages πj
iare all the packages relevant for in-
stalling package π, and only them.
Any dependency function can be converted in this form
by a sort of transitive closure that expands the dependencies
of each intermediate package, and then converts the result
again in a conjunction of disjunctions using distributivity:
on our running example, this amounts to adding a depen-
dency from dtof, and one from dtog(Figure 2b).
This transformation has some similarity with the conver-
sion of logical formulae to conjunctive normal form, and is
likewise subject toexponential blow-up(see for instance [9] ):
the dependency function of the repository in Figure 3 has
size 3n, and when expanded, gives rise to a repository whose
dependency function has size 2n.This is a strong limiting result, but we are only inter-
ested in studying co-installability of packages, so we need
not fully maintain the logical equivalence of repositories. In
particular, we can prune the expanded dependency function
by removing any dependency containing a package with no
conﬂicts without changing the co-installability property. I n
practice, this suﬃces to avoid the exponential blow-up. On
our running example, this pruning phase removes the de-
pendencies from dtoe, fromdtogand from etog, leading
to the repository of Figure 2c.
We take a further action to render the repository more ho-
mogeneous: we add a self dependency to each package with
conﬂicts. This sort of reﬂexive closure will be very useful
when quotienting the repository, in a later phase. (There
is no point in adding self dependencies to other packages as
they would be removed by pruning.) We then ﬁnd it con-
venient to draw the repository using a two-level structure:
on the top, we have all packages; on the bottom, we have
packages with conﬂicts; dependencies connects the top laye r
to the bottom layer; conﬂicts are between packages on the
bottom layer. On our running example, this leads to the
repository of Figure 2d.
The three phases of expansion, pruning and addition of
self dependencies can be performed in a single pass, and we
thereafter use the term ﬂattening to denote all of them.
Elimination of irrelevant dependencies and conﬂicts.
As asecondphase, weidentify several classes of dependen-
cies and conﬂicts that are irrelevant as far as co-installabilit y
isconcerned, andremovethem. InFigure4, we cansee some
interesting examples (more are given in Section 8), in all of
which the disjunctive dependency connecting package ato
packages bandccan be dropped:
(a) ifsomebranchesofadisjunctionareforcedbyastronger
dependency, all other branches can be dropped;
(b) a package with no conﬂict can be added to any instal-
lation, so dependencies on such a package are always
satisﬁable and all disjunctive dependencies containing it
can be simpliﬁed out (this is the pruning deﬁned above);
(c) if a package has a disjunctive dependency containing a
package (here, b) that conﬂicts only with other packages
in this dependency (here, c), this dependency is always
satisﬁable and can be dropped: either a package con-
ﬂicting with package bis installed, or package bcan be
installed; in both cases, the dependency can be satisﬁed.
In Figure 5, the conﬂict between packages aandbis implied
bytheconﬂictbetweenpackages canddandcanbedropped.
Proving the soundness of such simpliﬁcations is far from
trivial: in general, one has to rely on a peculiar structure of
the repository to justify that a dependency can be removed,
but removing a dependency may modify this very structure.
Therefore, a suitable invariant has to be found, that allows
to remove most, if not all, irrelevant dependencies.
On our example repository, the disjunctive dependency
from package ato packages bandc, corresponding to Fig-
ure 4c, can be removed, yielding the repository of Figure 2e.
Quotienting equivalent packages.
It is now quite evident looking at Figure 2e, that packages
a,d,eandfare, as far as co-installability is concerned, re-
allyequivalent: theysharetheverysamesetofdependenciesa
b ce
f∨
#d
#g
(a) Original repositorya
b ce
f∨
#d
#g
(b) Transitivitya
b cd
f∨
#e
#g
(c) Pruninga
b cd
f∨
#e
#f g b c
(d) Self dependency addition
a
b cd
f#e
#f g b c
(e) Simpliﬁcationb c a,d,e,f# #g b c a,d,e,f
(f) Quotientb c a,d,e,f# #g
(g) Drawing
Figure 2: Transformations of a repository (added dependencies are in bold, dotted ones are removed in the n ext phase)
a
b c
d∨
# #
(a) Implied
dependencya
b c d∨
#
(b) Dependency
on package with
no conﬂicta
b c d∨
# #
(c) Dependency on
package with only
internal conﬂicts
Figure 4: Some irrelevant dependencies
a b
c d##
Figure 5: A redundant conﬂict
(notice that this fact is easily detectable on the graph thanks
to the self dependency of package fintroduced during the
ﬂattening phase).
As many packages in a repository share the same be-
haviour with respect to co-installability, it is useful to quo-
tient the ﬁnal repository, identifying these packages; this
step contributes greatly in reducing the size of the reposi-
tory, as can be seen on our running example in Figure 2f.
After removing self dependencies, one gets the ﬁnal repos-
itory of Figure 2g, where it is now quite easy to see which
package can be installed with which other package, and
which package cannot.
3. EXPERIMENTAL RESULTS
The transformations described in this paper have been
proven correct, and all the proofs have been certiﬁed in
Coq [10]. An OCaml program implementing these transfor-
mations has been run on several mainstream GNU/Linux
distributions: Debian testing (full suite, amd64, snapshot
taken August 22, 2010), Ubuntu 10.10 (main suite, x386)
and Mandriva 2010.1 (main suite, x386). Running time were
measured on a machine using a Intel Core 2 Duo Processor
E6600 at 2.4GHz. The relevant statistics of the results are
given on Table 1.
We can notice that the number of packages is greatly
reduced: many packages share the same behaviour as far
as co-installability is concerned, and the quotienting phase
identiﬁes them. In particular, many packages can alwaysbe
installed, which is good news for the GNU/Linux distribu-
tions; they are thus mapped to a single equivalence class.
The number of dependencies is reduced even more: manyTable 1: Repository sizes
Debian Ubuntu Mandriva
before after before after before after
Packages 28919 1038 7277 100 7601 84
Dependencies 124246 619 31069 29 38599 8
Conﬂicts 1146 985 82 60 78 62
Median cone size 38 1 38 1 59 1
Avg. cone size 66 1.7 84 1.3 153 1.1
Max. cone size 1134 15 842 4 1016 5
Running time (s) 10.6 1.19 11.6
050100150200250300
0 10000 20000Cone size
Package count
(a) before0246810121416
0200 400 600 800 1000Cone size
Package count
(b) after
Figure 6: Distribution of cone size (Debian testing)
dependencies are not relevant to co-installability, and are re-
moved by our transformations. The simpliﬁcation shown in
Figure 4c turns out to be essential; for example, in Debian,
thousands of packages depend on debconf which depends
on either debconf-i18n ordebconf-english , these two last
packages being mutually exclusive: removing the disjunctive
dependency hugely reduces the size of the ﬁnal repository.
As for conﬂicts, we notice that distributions contain only
few of them, which explains that ﬂattening is practical; most
of them cannot be removed.
Finally, toeachpackage pinarepositoryonecanassociate
itscone, the set of packages that are reachable from pby fol-
lowing the dependency relations; the cone size of a package
is typically quite large (Figure 6): two third of the packages
have a cone of more than a hundred packages. On the other
hand, after simpliﬁcation, two third of the package equiva-
lence classes have a cone of size one, meaning that they do
not depend on any other package than themselves.
After simpliﬁcation, the Ubuntu distribution ﬁts on a let-
ter size paper (see Figure 14 in Section 12) and can be eas-
ily inspected visually for errors. The corresponding graph
for the Debian distribution is much larger, but it is our
experience that it can still be displayed in a usable way
with a suitable graph viewer: the visualisation of the De-a
b c∨
(a)D(a) ={{b},{b,c}}⊑a
b c
(b)D′(a) ={{b}}
Figure 7: An example of dependency functions re-
lated by the preorder
bian co-installability kernel can be tested online at http:
//ocsigen.org/js_of_ocaml/graph/ .
As a consequence of the small size of the kernel extracted
from a repository, many analyses can be performed very
quickly. For example, it is easy to compute on the co-
installability kernel of a repository the pairs of packages that
canneverbeinstalledtogether, knownas strong conﬂicts [5],
which is the simplest case of co-installability. On the same
data as [5], the computation takes a few seconds, instead of
the several days reported there. This time is in fact included
in the running times of Table 1 as we use this information
when drawing the simpliﬁed repository to emphasise pack-
ages that prevent the installation of many other packages.
4. ORDERING REPOSITORIES
A large part of our work consists of ﬁnding constraints
that can be removed while leaving co-installability invarian t.
Wemaketheideaofremovingconstraintsprecisebydeﬁning
a preorder on repositories.
We ﬁrst deﬁne a preorder on dependency functions: D⊑
D′iﬀ for every package π, for every dependency d∈D(π),
there exists a dependency d′∈D′(π) such that d′⊆d. As
an example, the dependency function Dof the repository
shown in Figure 7a is subsumed by the dependency function
D′of the repository shown in Figure 7b.
This preorder corresponds exactly to the converse of logi-
cal implication: D⊑D′if and only if the formulas /llbracketD′(π)/rrbracket
=⇒/llbracketD(π)/rrbracketcan be derived for all packages π∈P.
The preorder induces an equivalence relation over depen-
dency functions, and a canonical representative of an equiv-
alence class can be deﬁned by taking the element which is
point-wise the smallest. Given a dependency function D, its
canonical representative can be explicitly deﬁned as:
D′(π) ={d∈D(π)|∀d′∈D(π),d′⊆d=⇒d′=d}.
Thisprovidesaﬁrstwaytosimplifythedependencyfunction
(illustrated by Figure 4a), and our implementation aggres-
sively put all dependencies in canonical form.
We cannow deﬁnea preorder onrepositories: ( P,D,C)⊑
(P′,D′,C′) if and only if:
P=P′,D⊑D′,C⊆C′.
Given two repositories related under this preorder, going
fromtherighthandsideonetothelefthandsideoneconsists
in removing conﬂicts or relaxing dependencies, thus making
it easier to install packages.
Theorem 2.When(P,D,C)⊑(P′,D′,C′), any healthy
installation I of repository (P′,D′,C′)is also a healthy in-
stallation of repository (P,D,C).
5. FLATTENING DEPENDENCIESTheﬂattened form of a dependency function, whose intu-
ition has been given in the introduction, is formally deﬁned
as follows; given a repository ( P,D,C), theﬂattened depen-
dency function /hatwideDis the smallest function (with respect to
point-wise inclusion) such that:
Refl
(π,π′)∈C
{π}∈/hatwideD(π)Trans
{π1,...,π n}∈D(π)
d1∈/hatwideD(π1)... d n∈/hatwideD(πn)/uniondisplay
1≤i≤ndi∈/hatwideD(π)
Astheaboverulesaremonotonous, suchafunction /hatwideDexists.
The rule Transexpands the intermediate dependencies of
a package πand converts the result back into a conjunction
ofdisjunctions; thisrulesilentlydropscirculardependencie s:
adding a dependency {π}∈D(π) has no eﬀect on /hatwideD(π).
The rule Reflis designed to capture precisely the two
properties we have outlined informally in the introduction:
on one hand, we want to keep in /hatwideD(π) only dependencies on
packageswithatleastaconﬂict(weproveinthenextsection
that they are enough for keeping co-installability invariant );
on the other hand, we want /hatwideD(π) to contain explicitly all the
packages that are needed to install package π(so, ifπhas a
conﬂict, it will also be an explicit dependency of itself).
The application of the transformation on the repository of
Figure 1 gives the following result (illustrated by Figure 2e):
D /hatwideD
a{{b,c},{f}} {{b,c},{f}}
b∅ {{ b}}
c∅ {{ c}}
d{{e}} {{ f}}
e{{f},{g}} {{ f}}
f∅ {{ f}}
g∅ ∅
Packages d,eandfnow have the same dependencies,
which reﬂects the intuition that they behave the same way
as far as co-installability is concerned.
6. STRONGLY FLAT REPOSITORIES
A ﬂattened repository satisﬁes two properties (Theorem 3
below): a reﬂexivity property (if a package has a conﬂict,
then it depends on itself), and a transitivity property (de-
pendencies are stable under composition). Co-installabili ty
in such repositories, that we call strongly ﬂat , can be shown
equivalent to a more convenient property, that we call weak
co-installability (Theorem 4); this is instrumental to prove
the key result of this section: a set of packages are co-
installableinarepositoryifandonlyiftheyareco-installab le
in the corresponding ﬂattened repository (Theorem 6).
We deﬁne precisely these two properties and study repos-
itories that satisﬁes them.
We deﬁne the composition D ;D′of two dependency func-
tions over a set of packages Pas the smallest function (with
respect to point-wise inclusion) such that for every package
π∈P, for every set{π1,...,π n}∈D(π), for every sets
di∈D′(πi), we have/uniontext
1≤i≤ndi∈(D;D′)(π).
To any conﬂict relation C, we associate a dependency
function ∆ Cdeﬁned as follows:
∆C(π) =/braceleftbigg
{{π}}if (π,π′)∈Cfor some π′∈P
∅otherwiseA repository ( P,D,C) isstrongly ﬂat when the following
conditions hold:
•reﬂexivity : ∆C⊑D(every package with conﬂict de-
pends on itself);
•transitivity :D;D⊑D(dependencies are closed under
composition).
The ﬂattening transformation produces strongly ﬂat repos-
itories.
Theorem 3.Let(P,D,C)be a repository. Let /hatwideD be the
corresponding ﬂattened dependency function. The reposito ry
(P,/hatwideD,C)is strongly ﬂat.
Intuitively, strongly ﬂat repositories have a two level struc-
ture. Looking for instance at Figure 2e, we ﬁnd all packages
on the top layer, and typically only packages with conﬂicts
(that we refer to as features in the following) at the bottom
layer: thanks to transitivity, everything a package πmay
need to be installed is fully described by D(π), without re-
cursive traversal of dependencies; and thanks to reﬂexivity,
conﬂicts need only be considered on the image of D.
We can take advantage of this to deﬁne a more convenient
way of capturing co-installability:
Aconﬁguration is a pair ( I,F) of a set Iof packages and a
setFof features; we say that it is healthywhen the following
conditions hold:
•abundance : everypackagehaswhatitneeds. Formally,
for every package π∈I, and for every dependency
d∈D(π), we have d∩F/\e}atio\slash=∅.
•peace: notwofeaturesconﬂict, thatis, C∩(F×F) =∅.
This is subtly diﬀerent from the homonymous deﬁnitions
regarding installations. Conﬂicts are only checked in F, and
abundance only checked for packages in Iw.r.t.F; the sets
FandImight as well be disjoint, here.
A set of packages Π are weakly co-installable if there exists
a set of features F⊆Psuch that the conﬁguration (Π ,F)
is healthy. In general, this is a weaker notion. In strongly
ﬂat repositories, though, the two notions are equivalent.
Theorem 4.Any set of packages Πweakly co-installable
in a strongly ﬂat repository are also co-installable.
It is interesting to remark that the result of the ﬂattening
operation can be mathematically characterised as follows.
Lemma 5.The ﬂattened dependency function /hatwideD associ-
ated to a repository (P,D,C)is the least dependency func-
tion D′(for preorder⊑, and up to equivalence) such that:
•∆C⊑D′
•D;D′⊑D′.
The essential result of this section is that co-installabili ty
is left invariant by ﬂattening.
Theorem 6.Let(P,D,C)be a repository. Let /hatwideD be the
corresponding ﬂattened dependency function. Let Πbe a set
of packages. The following propositions are equivalent:
1.Πis co-installable in (P,D,C);
2.Πis weakly co-installable in (P,/hatwideD,C);
3.Πis co-installable in (P,/hatwideD,C).a∨b
cd
e#
#
#
Figure 8: Illustration of monotony requirement
7. FLAT REPOSITORIES
In this section, we focus on a particular class ∇C⊆P(P)
of dependencies that can be safely removed (Theorem 11).
Removing these dependencies may destroy the strongly ﬂat
structure of a repository, but we introduce the weaker no-
tion ofﬂatrepository which is preserved (Theorem 11), and
for which co-installability and weak co-installability sti ll co-
incide (Theorem 10), thus enabling further simpliﬁcations
introduced in Section 8.
We want to capture in the class ∇Ca set of dependencies
that have the following two key properties:
always satisﬁable any healthy conﬁguration in the
repository can be extended to satisfy these dependen-
cies, so they are irrelevant for co-installability and we
can remove them; formally, this means that if d∈∇C,
then for all F∈P(P) maximal with respect to set in-
clusion such that C∩(F×F) =∅, we have d∩F/\e}atio\slash=∅;
monotony a dependency which is in ∇Cmust still be
alwayssatisﬁableevenifweremovesomeconﬂictsfrom
the repository; formally, if C′⊆C, then∇C⊆∇C′.
Themonotony property is necessary, because in the next
section we introduce further simpliﬁcations that remove re-
dundant conﬂicts. We want to be sure that removing a
conﬂict later on does not invalidate the decision taken here
of removing a dependency, as illustrated in Figure 8: the
disjunctive dependency on packages bandccan always be
satisﬁed because the conﬂict between dandeprevents the
simultaneous installation of dande; but this dependency
is not in∇Csince it is no longer satisﬁable if the conﬂict
between dandeis removed. This leads to the following:
Definition 7.Given a repository (P,D,C), the set∇C
is the largest set such that d∈∇Cif and only if, for all C′⊆
C, for all F∈P(P)maximal with respect to set inclusion
such that C′∩(F×F) =∅, we have d∩F/\e}atio\slash=∅.
We can give a more explicit characterisation of the ele-
ments of∇C: these are exactlythe dependencies that con-
tain at least a package having only internal conﬂicts, like in
Figure 4c.
Theorem 8.Let(P,D,C)be a repository. The set ∇C
is the set of dependencies dsuch that there exists a package
π∈dsuch that, for all pairs (π,π′)∈C, we have π′∈d.
Notice that, if a dependency dcontains a package πwith
no conﬂict, then it is in ∇C; so∇Calso contains the redun-
dant dependencies shown in Figure 4b.
As we shall see, weak co-installability is left invariant by
thetransformationthatremovestheelementsofset ∇Cfrom
a dependency function Dof a strongly ﬂat repository. But,
in general, the strongly ﬂat property is lost, so we need a
weaker notion that is preserved by this simpliﬁcation. We
start by deﬁning a coarser preorder on dependency functions
that ignores dependencies in ∇C:D≺CD′if and only if for every package π, for
every dependency d∈D(π),eitherd∈∇Cor
there exists a dependency d′∈D′(π) such that
d′⊆d.
A repository ( P,D,C) isﬂatwhen it satisﬁes the follow-
ing properties:
•reﬂexivity : ∆C≺CD;
•transitivity :D;D≺CD.
Flat repositories have a series of good properties: they in-
clude strongly ﬂat repositories, co-installability and weak
co-installability still coincide, removing ∇Cpreserves ﬂat-
ness and keeps co-installability invariant.
Lemma 9.Any strongly ﬂat repository is ﬂat.
Theorem 10.Any set of packages Πweakly co-installable
in a ﬂat repository are co-installable in this repository.
Theorem 11.Let(P,D,C)be a ﬂat repository and D′
be the dependency function such that D′(π) =D(π)\∇C
for allπ∈P. The repository (P,D′,C)is ﬂat, and co-
installability is left invariant by this transformation.
One can still reason on ﬂat repositories, as far as co-
installability is concerned, as if their dependency function
was transitive: just choose installations ( I,F) where Fis
maximal, and then any dependency obtained by composi-
tion is satisﬁed, even when it is not explicitly in the depen-
dency function. (For strongly ﬂat repositories, this holds for
arbitrary sets F.)
8. IRRELEV ANT CONSTRAINTS
We review now several classes of dependencies and con-
ﬂicts that are redundant and can be simpliﬁed out.
8.1 Clearly Irrelevant Dependencies
The results of the previous section let us remove the de-
pendencies in∇Cfrom a ﬂat repository while leaving weak
co-installability invariant and keeping the repository ﬂat.
8.2 Conﬂict Covered Dependencies
An example of another very interesting class of irrelevant
dependencies is shown in Figure 9, where the dependency
for package acan always be satisﬁed despite the conﬂict
between packages eandf(we assume the other packages
in this dependency also have conﬂicts, not explicited, so th e
dependency cannot be obviously removed): indeed, for this
conﬂict to be relevant for the dependency, fneeds to be
installed; but if fis installed, at least one of packages cand
dis installed as well, and thus the dependency is satisﬁed
without needing to install e. This generalizes to the case
where package eis in conﬂict with several packages with the
same property as package f.
More formally, we say that a dependency disconﬂict
covered at πif it contains a package πsuch that for all
(π,π′)∈C, there exists a dependency d′∈D(π′) such
thatd′⊆d\{π}. Removing one such dependency leave
co-installability invariant.
Lemma 12.Let(P,D,C)be a ﬂat repository, dbe acon-
ﬂict covered dependency, and D′be the dependency func-
tion obtained by removing dfrom D. Any set of packages
weakly co-installable in (P,D′,C)is weakly co-installable in
(P,D,C).e fa
∨
c d#
∨ b#
# #
Figure 9: Dependency
covered by the conﬂict
requirements.b c
d e##a# #
Figure 10: Redundant
conﬂict belonging to a
clique
Unfortunately, removing such dependencies may destroy
the ﬂatness of the repository, so we remove them one af-
ter another, in a greedy way, and only after checking that
ﬂatness is preserved by using the following result.
Lemma 13.Let(P,D,C)be a ﬂat repository. Let π∈P
andd∈D. Let D′be the dependency function D where the
dependency dof package πhas been removed. If the following
two conditions hold, then (P,D′,C)is ﬂat.
•d/\e}atio\slash⊆{π};
•for alld′∈(D′;D′)(π), we have d/\e}atio\slash⊆d′.
In practice, it can be simpler to get all possible dependen-
ciesd′above by taking all dependencies d′′∈D(π)\{d,{π}}
and composing them with dependencies in D.
Thegraphreductionruledeﬁnedbythissimpliﬁcationhas
unsolvable critical pairs, so the result of this simpliﬁcation
could depend on the order of removal. In practice, though,
we remove all instances present in the initial repository.
8.3 Redundant Conﬂicts
We consider some of the conﬂicts that can be removed
from a repository while leaving co-installability invariant. A
conﬂicting pair ( π1,π′
1)∈Cisredundant if there exists a
dependency d∈D(π1) such that for all π2∈d, there exists
a package π′
2such that:
•(π2,π′
2)∈C;
•{π1,π′
1}/\e}atio\slash={π2,π′
2};
•there exists d′∈D(π2) such that d′⊆{π′
2}.
Redundant conﬂicts can be removed, but only one at a
time: for example, if two conﬂicts are considered redundant
thanks to the existence of one another, then removing both
of them simultaneously is incorrect.
Lemma 14.Let(P,D,C)be a repository. Let (π1,π2)be
a redundant conﬂict in this repository. Any healthy instal-
lation of repository (P,D,C\{(π1,π2),(π2,π1)})is healthy
in repository (P,D,C).
Removing redundant conﬂicts involves a trade oﬀ. On one
side, it may allow to remove some additional dependencies;
on the other, it can also break some interesting structures.
In Figure 10, the conﬂict between bandcis redundant, but
removing it breaks the clique a,b,c, which is useful when
drawing a simpliﬁed graph.
8.4 Dependence on Conﬂicting Packages
A special conﬁguration may surface in the repository dur-
ingsimpliﬁcationwhentheinitialrepositorycontainsbroken
packages, as depicted in Figure 11: clearly, package acannota b#
Figure 11: Dependence on conﬂicting package
be installed, and leaving such a conﬁguration in the repos-
itory would pollute the graphical representation. In this
case, we mark explicitly package aas broken by replacing
its dependencies by the empty dependency ∅. All conﬂicts
involving acan then be also removed, as they are redundant
(Section 8.3). The transformation preserves healthiness.
Lemma 15.Letπbe a package not installable in some
repository (P,D,C). Let D′be the dependency function that
coincide with D for all packages but πand such that D′(π) =
{∅}. Any healthy installation of repository (P,D,C)is also
healthy in repository (P,D′,C).
The ﬂatness of the repository may be destroyed, as some of
the removed dependencies may be involved in transitivity.
Thus, after applying such simpliﬁcation, ﬂattening should
be performed again.
9. QUOTIENTING THE SET OF PACKAGES
In real-world repositories, many packages share the same
behaviour as far as co-installability is concerned: for ex-
ample, a lot of packages can always be installed, and some
groups of packages only conﬂicts with a single other package.
In this section, we deﬁne an equivalence relation between
packages, and show that the quotient w.r.t. this relation
preserves all the good properties of a repository. We deﬁne
two packages as equivalent in a repository ( P,D,C) if they
have the same dependencies:
π≡π′if and only if D(π) =D(π′).
We write [ π] for the equivalence class of package π, and
extend this deﬁnition to set of packages: [Π] = {[π]|π∈
Π}. Thequotient repository (P′,D′,C′) of a repository
(P,D,C) is naturally deﬁned as follows:
•P′is the set of all equivalence classes: P′=P/≡=
{[π]|π∈P};
•the dependency function D′is such that D′([π]) =
{[d]|d∈D(π)}for allπ∈P;
•the conﬂict relation C′is deﬁned by
C′={([π],[π′])|(π,π′)∈C}.
If the original repository does not contain dependencies
of the form of Figure 11 nor redundant conﬂicts, then the
quotient repository is indeed a repository (the key point to
check is irreﬂexivity of the conﬂict relation).
Lemma 16.Let(P,D,C)be a ﬂat repository such that,
for allπ∈P and for all d∈D(π), ifd⊆{π′}for some
π′∈P, then(π,π′)/\e}atio\slash∈C. Its quotient is indeed a repository.
Quotienting preserves ﬂatness and keeps co-installability
invariant.
Theorem 17.A set of packages Πis weakly co-installable
in the ﬂat repository (P,D,C)if and only if the set [Π]is
weakly co-installable in the associated quotient reposito ry.
Theorem 18.If a repository is ﬂat, then the correspond-
ing quotiented repository is ﬂat as well.repeat
(P,D,C)←ﬂatten(P,D,C)
(P,D,C)←canonise (P,D,C)
(P,D,C)←(P,D,C)\∇C
(P,D,C)←remove-clearly-broken (P,D,C)
(P,D,C)←remove-redundant-conﬂicts (P,D,C)
untilthe last two steps above have no eﬀect
(P,D,C)←remove-conﬂict-covered-deps (P,D,C)
return quotient(P,D,C)
Figure 12: Simplifying the repository.
10. REFLEXIVE TRANSITIVE REDUCTION
It would not be suitable to graph directly a repository af-
ter ﬂattening as it would be polluted by dependencies which
are not informative: due to reﬂexivity, we have packages
πwhere{π}∈D(π), and some dependencies can be de-
duced from others by transitivity. Thus, we perform a kind
of reﬂexive transitive reduction of the dependency function:
given a repository ( P,D,C), we ﬁnd a minimal dependency
function D′with the same ﬂattening (that is, /hatwideD=/hatwiderD′).
Because of disjunctive dependencies, the complexity of
ﬁnding an optimal solution is high [11, 12], in constract with
the case of reﬂexive transitive reduction for graphs. As this
ismostlyacosmeticissueforus, weuseasimplenon-optimal
algorithm. As a ﬁrst step, we iteratively remove dependen-
cies which are implied from other dependencies by transi-
tivity, in a greedy way. The second step is to remove all
self dependencies, that is, dependencies d∈D(π) such that
π∈d. Co-installability is left invariant by these operations.
Lemma 19.Let(P,D,C)be a repository. Let π∈P be a
package and d∈D(π)be a dependency of this package. Let
D′=D\{π/mapsto→d}be the dependency function D where the
dependency has been removed. If d∈(D′;D′)(π)then any
healthy installation I of repository (P,D′,C)is a healthy
installation of repository (P,D,C).
Lemma 20.Let(P,D,C)be a repository. Let D′be the
dependency function deﬁned by D′(π) ={d∈D|π/\e}atio\slash∈d}.
Any healthy installation I of repository (P,D′,C)is also a
healthy installation of repository (P,D,C).
11. PUTTING ALL TOGETHER
We now have all the ingredients at handto performon any
repository ( P,D,C) the transformations that allow to pro-
duce the ﬁnal repository, which is suitable both for drawing
a simpliﬁed graph, or performing eﬃciently various analysis
related to co-installability.
11.1 Extracting a Co-Installability Kernel
The complete algorithm is shown in Figure 12. We ﬁrst
ﬂatten the initial repository (Section 5), canonise the depen -
dency function (Section 4), and remove the clearly irrelevant
dependencies in∇C(Section 7). In our implementation, all
these operations are performed simultaneously: this is sig-
niﬁcantly more eﬃcient, as we have less dependencies to
consider while ﬂattening. Then, we set the dependencies of
broken packages of the form of Figure 11 to the empty de-
pendency∅(Section 8.4), and we remove redundant conﬂicts
(Section 8.3). As changing the dependencies of broken pack-
ages may break ﬂatness and removing may grow ∇C, thesea b
c d##
# ##
#
(a) Explicit representationa b c d
#
(b) Compact representation
Figure 13: Conﬂict clique
ﬁves steps are iterated until no change occurs. The process
terminates as at each iteration either D(π) is set to{∅}for
a package πor a conﬂict is removed. In practice, only two
iterations are performed: more iterations are only needed in
unlikely conﬁgurations where dealing with a broken pack-
age exposes another package as broken. Finally, we remove
the conﬂict covered dependencies that can be safely dropped
(Section 8.2) and the repository is quotiented (Section 9).
By combining the results of the previous sections, we ob-
tain the fundamental result on the simpliﬁcation performed
by the algorithm.
Theorem 21.The transformation performed by the sim-
pliﬁcation algorithm leaves co-installability invariant . This
algorithm produces a ﬂat repository.
As noticed above, on a repository with no broken package,
it is not necessary to iterate the ﬂattening phase, so the al-
gorithm could run slighly faster; but ﬁnding all broken pack-
ages is slower than performing the whole simpliﬁcation, as it
requires to call a SAT solver repeatedly on large problems.
On the other hand, repositories with good quality control
should contain no broken packages, and a simpler version of
the simpliﬁcation algorithm could be used on them.
11.2 Drawing a Simpliﬁed Graph
Before drawing the ﬁnal repository, we perform the tran-
sitive reﬂexive reduction of Section 10. The structure of the
graph is then passed as input to the dotprogram of the
Graphviz toolkit [13] that performs the layout.
It is important to name nodes using meaningful represen-
tatives of each equivalence class: we give preference to pack-
agesπthat are directly involved in conﬂicts, as they have
more chances to be relevant for the repository maintainers;
these are easy to ﬁnd by checking if {π}∈D(π).
There can be many packages all mutually in conﬂict. For
instance, this is the case of all mailer agents in Debian. We
identify maximal such cliques and draw them in a more con-
cise way, as shown in Figure 13.
We compute strong conﬂicts [5] (non-coinstallable pairs
of packages) and use this information to emphasise packages
that prevent the installation of many other packages.
12. VISUALIZING UBUNTU
In Figure 14 we can see the result of applying the sim-
pliﬁcations described in this paper to the main section of
release 10.10 of the Ubuntu GNU/Linux distribution; solid
arrows indicate dependencies, dotted lines indicate conﬂict s,
and conﬂict cliques are represented with a node containing
a#connected with dotted lines to all packages in the clique.
Of the thousands of packages, and dozens of thousands of
relationships, only a handful are left, and it is possible to
readinteresting information directly on the graph.
We give here just a couple of examples. The isolated
node in the middle left stands for 7049 packages that arealwaysinstallable. The ﬁve conﬂict cliques are justiﬁed, as
they all correspond to incompatible implementations of li-
braries which are compiled with diﬀerent backends. One
can see that package libjpeg8-dev is in conﬂict with 28
other packages, which is likely to make it unconvenient to
use. The core package ubuntu-desktop is in conﬂict with
a number of packages. These packages should either be re-
moved from the main section, or the dependencies should be
revised. For instance, packages foomatic-db andlibgd2-
noxpmshould probably be removed. On the other hand,
package libsdl1.2debian-all provides a superset of the
functionalities of libsdl1.2debian-pulseaudio . Thus, it
should not be in conﬂict with ubuntu-desktop . Overall,
there are few issues with this repository. Our tool is most
useful for detecting issues proactively when the distribution
is in ﬂux (during alpha and beta stages).
13. RELATED AND FUTURE WORK
Many relevant research issues stem from the concrete and
widespread applications of software component repositories:
identifying components that can never be installable has
been shown NP-complete, but tractable in practice [1], and
there is currently very active research on computing instal-
lations that optimise some given objective functions, or-
ganised around the Mancoosi International Solver Compe-
tition (http://www.mancoosi.org/misc-2010/ ); determin-
ing what other components a package will always need [4]
and what pairs of packages are incompatible [5] have been
shown to be relevant for quality assurance in package reposi-
tories; ﬁnally, since feature diagrams, used in software prod-
uct lines, can be encoded as component repositories [14], all
the problems related to conﬁguration management can be
equivalently stated in terms of repositories.
Connections between component repositories and boolean
satisﬁability and constraint solving have been made only a
few years ago in the framework of GNU/Linux distributions
[1, 2] and the Eclipse platform [3], but these connections,
and other recent developments such as [4, 5] do not exploit
thespecial structure of the dependencies and conﬂicts found
in a repository.
The underlying structure of software component reposi-
tories exposed here can also be seen as a generalisation of
some known mathematical structures : prime event struc-
ture [16] correspond to repositories without loops and dis-
junctions; directed hypergraphs [11] correspond to reposi-
tories without conﬂict arcs, and Dual Horn theories corre-
spond to repositories with conﬂicts [17]. In this paper, we
have developed a theory and algorithms to extract from a
repository a co-installability kernel, which can be seen as a
minimal representation of the dependency and conﬂict re-
lations: despite the apparent simplicity of the deﬁnition of
the problem, and the intuitive appealing of the hypergraph
transformations we have developed, the proofs of the crucial
properties turned out to be surprisingly complex, so we de-
cided to machine check them using Coq [10], and a long ver-
sion of this paper containing all the proofs is available onlin e
ashttp://hal.archives-ouvertes.fr/hal-00605491/ .
The results presented here pave the way to attacking sig-
niﬁcantly more complex problems concerning software com-
ponent repositories. More generally, we believe this work
clearlyshowstheinterestofthemathematicalobjectsunder-
lying software repositories, which turn out to be amenableto an elegant formal treatment and of high practical interest.
Artifact evaluation: the tool coinstimplemeting the
analysis described in this article has been evaluated by the
ESEC/FSE Artifact Evaluation Committee, and it has be
found to exceed expectations ; more information on this tool
can be found online at http://coinst.irill.org .
14. REFERENCES
[1] F. Mancinelli, J. Boender, R. Di Cosmo, J. Vouillon,
B. Durak, X. Leroy, and R. Treinen,“Managing the
complexity of large free and open source
package-based software distributions.”in ASE. IEEE
Computer Society, 2006, pp. 199–208.
[2] C. Tucker, D. Shuﬀelton, R. Jhala, and S. Lerner,
“Opium: Optimal package install/uninstall manager,”
inICSE. IEEE Computer Society, 2007, pp. 178–188.
[3] D. L. Berre and A. Parrain,“On sat technologies for
dependency management and beyond,”in SPLC (2) ,
S. Thiel and K. Pohl, Eds. Lero Int. Science Centre,
University of Limerick, Ireland, 2008, pp. 197–200.
[4] P. Abate, J. Boender, R. Di Cosmo, and S. Zacchiroli,
“Strong dependencies between software components,”
inESEM. IEEE Press, Oct. 2009, pp. 89–99.
[Online]. Available: http://ieeexplore.ieee.org:
80/search/wrapper.jsp?arnumber=5316017
[5] R. Di Cosmo and J. Boender,“Using strong conﬂicts
to detect quality issues in component-based complex
systems,”in ISEC ’10: Proceedings of the 3rd India
software engineering conference . New York, NY,
USA: ACM, 2010, pp. 163–172.
[6] R. Treinen and S. Zacchiroli,“Solving package
dependencies: from EDOS to Mancoosi,”in DebConf8
(9th annual conference of the Debian project)
DebConf8 , Argentine, 08 2008, pp. 18–43. [Online].
Available:
http://hal.archives-ouvertes.fr/hal-00340581/en/
[7] R. Di Cosmo, F. Mancinelli, J. Boender, J. Vouillon,
B. Durak, X. Leroy, D. Pinheiro, P. Trezentos,
M. Morgado, T. Milo, T. Zur, R. Suarez, M. Lijour,
and R. Treinen,“Report on formal mangement of
software dependencies,”EDOS, Tech. Rep., Apr. 2006,
eDOS project Deliverable 2.2, available as
http://www.edos-project.org/xwiki/bin/download/
Main/Deliverables/edos-wp2d2.pdf.
[8] R. Di Cosmo, B. Durak, X. Leroy, F. Mancinelli, and
J. Vouillon,“Maintaining large software distributions:
new challenges from the FOSS era,”in Proceedings of
the FRCSS 2006 workshop , 2006, eASST Newsletter.
[9] H. K. Buning and T. Lettmann,“Propositional logic:
Deduction and algorithms,” Studia Logica , vol. 71, pp.
247–258, 2002.
[10] The Coq Development Team, The Coq Proof Assistant
Reference Manual – Version V8.2 , 2008. [Online].
Available: http://coq.inria.fr
[11] G. Ausiello, A. D’Atri, and D. Sacc` a,“Graph
algorithms for functional dependency manipulation,”
J. ACM, vol. 30, no. 4, pp. 752–766, 1983.
[12] G. Ausiello, A. D’Atri, and D. Sacc´ a,“Minimal
representation of directed hypergraphs,” SIAM J.
Comput. , vol. 15, no. 2, pp. 418–431, 1986.[13] J. Ellson, E. Gansner, L. Koutsoﬁos, S. North, and
G. Woodhull,“Graphviz - open source graph drawing
tools,”in Graph Drawing , ser. Lecture Notes in
Computer Science, P. Mutzel, M. J ¨unger, and
S. Leipert, Eds. Springer Berlin / Heidelberg, 2002,
vol. 2265, pp. 594–597. [Online]. Available:
http://dx.doi.org/10.1007/3-540-45848-4 57
[14] R. Di Cosmo and S. Zacchiroli,“Feature diagrams as
package dependencies,”in SPLC, ser. Lecture Notes in
Computer Science, J. Bosch and J. Lee, Eds., vol.
6287. Springer, 2010, pp. 476–480.
[15] C. A. Gunter,“Abstracting dependencies between
software conﬁguration items,” ACM Trans. Softw. Eng.
Methodol. , vol. 9, pp. 94–131, January 2000. [Online].
Available: http://doi.acm.org/10.1145/332740.332743
[16] G. Winskel,“Event structures,”in Petri Nets:
Applications and Relationships to Other Models of
Concurrency , ser. Lecture Notes in Computer Science,
W. Brauer, W. Reisig, and G. Rozenberg, Eds.
Springer Berlin / Heidelberg, 1987, vol. 255, pp.
325–392. [Online]. Available:
http://dx.doi.org/10.1007/3-540-17906-2 31
[17] W. F. Dowling and J. H. Gallier,“Linear-time
algorithms for testing the satisﬁability of propositional
horn formulae,” J. Log. Program. , vol. 1, no. 3, pp.
267–284, 1984.
[18] S. K. Shukla, H. B. Hunt, III, and D. J. Rosenkrantz,
“HORNSAT, model checking, veriﬁcation and games
(extended abstract),”in CAV ’96: Proceedings of the
8th International Conference on Computer Aided
Veriﬁcation . London, UK: Springer-Verlag, 1996, pp.
99–110.
[19] G. Ausiello, P. G. Franciosa, D. Frigioni, and
R. Giaccio,“Decremental maintenance of reachability
in hypergraphs and minimum models of horn
formulae,”in Proceedings of the 8th International
Symposium on Algorithms and Computation , ser.
ISAAC ’97. London, UK: Springer-Verlag, 1997, pp.
122–131. [Online]. Available:
http://portal.acm.org/citation.cfm?id=646340.686570
[20] R. J. van Glabbeek and G. D. Plotkin,“Conﬁguration
structures,”in LICS. IEEE Computer Society, 1995,
pp. 199–209.ubiquity-slideshow-kubuntu ubiquity-slideshow-ubuntu
tk8.4-doc tk8.5-doc tcl8.4-doc tcl8.5-docopenbsd-inetd xinetd
network-manager-kde plasma-widget-networkmanagement (x 2)
libstdc++6-4.4-doc libstdc++6-4.5-doc libstdc++6-4.4-dbg libstdc++6-4.5-dbg# libsdl1.2debian-all
libsdl1.2debian-alsa
libsdl1.2debian-esdlibsdl1.2debian-oss
libsdl1.2debian-pulseaudio
libreadline6-dev (x 6) libreadline5-devlibjpeg62-dev (x 23) libjpeg8-dev
libgd2-noxpmlibgd2-xpm (x 10)
libdb4.8-dev (x 5) libdb4.7-dev (x 2)libcurl4-gnutls-dev (x 4) libcurl4-openssl-devfoomatic-db-compressed-ppds (x 4) foomatic-db
apache2-prefork-devapache2-threaded-devlibecore-dev
libedje-dev (x 2)libgd2-noxpm-devlibgd2-xpm-dev
librdf0-dev
librpm-devubuntu-desktop
ubuntu-netbooklibreadline5-dbg libreadline6-dbglibqt4-dbg (x 24) qt-x11-free-dbg
libneon27-dev libneon27-gnutls-devlibjack-jackd2-0 (x 2) libjack0 (x 3)
libiodbc2-dev unixodbc-dev
libgpod4 (x 9) libgpod4-nogtk (x 2)libgl1-mesa-glx (x 8) libgl1-mesa-swx11 (x 3)#libclutter-1.0-0 (x 2)
libclutter-eglx-es11-1.0-0 (x 2)
libclutter-eglx-es20-1.0-0 (x 2)libclutter-1.0-dev (x 2)
libclutter-eglx-es11-1.0-dev
libclutter-eglx-es20-1.0-devlibelf-dev (x 3) libelfg0-dev
libdb4.7-java (x 3) libdb4.8-java (x 3)lib64stdc++6-4.4-dbg lib64stdc++6-4.5-dbg
lib64readline5-dev lib64readline6-dev
hunspell-tools myspell-toolshunspell-fr (x 3) myspell-fr
hunspell-de-de (x 3) myspell-de-de-oldspellhello hello-debhelper
grub grub-legacy-ec2
#grub-efi-amd64
grub-efi-ia32 (x 2)
grub-pc
flex flex-oldexim4-daemon-heavy (x 2)
exim4-daemon-light (x 2)exim4-config (x 5) postfix (x 9)emacs23 emacs23-nox
debconf-english debconf-i18n#bacula-common-mysql (x 3)
bacula-common-pgsql (x 3)
bacula-common-sqlite3 (x 3)
#apache2-mpm-event
apache2-mpm-prefork (x 2)
apache2-mpm-workereucalyptus-nc ∨
abrowser (x 7049)
Figure 14: Output graph for Ubuntu 10.10 (main)