Proving Programs Robust
Swarat Chaudhuri
Rice University
swarat@rice.eduSumit Gulwani
Microsoft Research
sumitg@microsoft.comRoberto Lublinerman
Pennsylvania State University
rluble@psu.edu
Sara Navidpour
Pennsylvania State University
ssn123@psu.edu
ABSTRACT
We present a program analysis for verifying quantitative ro-
bustness properties of programs, stated generally as: \If the
inputs of a program are perturbed by an arbitrary amount
, then its outputs change at most by K, whereKcan de-
pend on the size of the input but not its value." Robustness
properties generalize the analytic notion of continuity|e.g.,
while the function exis continuous, it is not robust. Our
problem is to verify the robustness of a function Pthat is
coded as an imperative program, and can use diverse data
types and features such as branches and loops.
Our approach to the problem soundly decomposes it into
two subproblems: (a) verifying that the smallest possible
perturbations to the inputs of Pdo not change the cor-
responding outputs signicantly, even if control now ows
along a dierent control path; and (b) verifying the robust-
ness of the computation along each control-ow path of P.
To solve the former subproblem, we build on an existing
method for verifying that a program encodes a continuous
function [5]. The latter is solved using a static analysis that
bounds the magnitude of the slope of any function computed
by a control ow path of P. The outcome is a sound program
analysis for robustness that uses proof obligations which do
not refer to -changes and can often be fully automated using
o-the-shelf SMT-solvers.
We identify three application domains for our analysis.
First, our analysis can be used to guarantee the predictable
execution of embedded control software, whose inputs come
from physical sources and can suer from error and un-
certainty. A guarantee of robustness ensures that the sys-
tem does not react disproportionately to such uncertainty.
Second, our analysis is directly applicable to approximate
computation , and can be used to provide foundations for
a recently-proposed program approximation scheme called
loop perforation . A third application is in database privacy:
This research was supported by NSF CAREER Award
#0953507 (\Robustness Analysis of Uncertain Programs:
Theory, Algorithms, and Tools").
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee. This paper is a minor revision of the paper of the
same name published in
ESEC/FSE‚Äô11, September 5‚Äì9, 2011, Szeged, Hungary.
Copyright 2011 ACM 978-1-4503-0443-6/11/09 ...$10.00.proofs of robustness of queries are essential to dierential
privacy , the most popular notion of privacy for statistical
databases.
Categories and Subject Descriptors
F.3.2 [ Logics and Meanings of Programs ]: Semantics of
programming languages| Program analysis .; F.3.1 [ Logics
and Meanings of Programs ]: Specifying and Verifying
and Reasoning about Programs| Mechanical verication ;
G.1.0 [ Numerical Analysis ]: General| Error analysis
General Terms
Theory, Verication
Keywords
Lipschitz, Continuity, Quantitative Program Analysis, Sen-
sitivity, Robustness, Uncertainty, Perturbations, Program
Approximation.
1. INTRODUCTION
Uncertainty in computation [12] has long been a topic of
interest to computer science. Depending on the context,
uncertainty in the operation of programs can be a curse
or a blessing. On one hand, uncertain operating environ-
ments may cause system failures|consider, for example, an
aircraft controller that reacts unpredictably to noisy sensor
data and causes a crash. On the other hand, randomized
and approximate algorithms deliberately inject uncertainty
into their data to trade o quality of results for better per-
formance. Uncertainty of both forms is rife in a world where
cyber-physical systems are ubiquitous [15] and applications
suited to approximation and randomization are ascendant.
Love or hate uncertainty, you increasingly cannot ignore it.
Robustness is a system property critical to reasoning about
program behavior under uncertainty. A program is robust
(in the sense of this paper) if a perturbation to its inputs can
only lead to proportional changes in its outputs. This means
that a robust avionic controller reacts predictably to noise
in the measurements made by the plane's sensors. Also, if
a program Pis robust, then the output P(x) ofPon an
inputxcan be approximated \safely" by P(x0), wherex0is
a value close to x|asxandx0are close, so must be P(x)
andP(x0). If uncertainty is our enemy, a proof of robustness
shows that our program is relatively safe from it; if we want
to introduce uncertainty in our computation for performance
gains, robustness ensures that it is safe to do so.Dijk (G: graph;src: node)
1foreach nodevinG
2d[v] :=?;prev[v] :=undef ;
3d[src] := 0; WL:= set of all nodes in G;
4while WL6=;
5 choose node w2WLsuch thatd[w] is minimal;
6 remove wfrom WL;
7 foreach neighbor vofw
8 z:=d[w] +G[w;v];
9 ifz<d [v]
10 thend[v] :=z;prev[v] :=w
Figure 1: Dijkstra's shortest-path algorithm
A system to formally verify the robustness of everyday
programs would then seem to be of considerable practical
importance. A step to this end was taken by Chaudhuri
et al [5], who presented a program analysis to verify that a
program encodes a continuous function . A function is con-
tinuous if innitesimal |or arbitrarily small|changes to its
inputs can only cause innitesimal changes to its outputs.
This makes such a function robust in a sense. Such a formu-
lation of robustness is particularly valuable in the setting of
programs, where violation of robustness is often due to dis-
continuities introduced by control constructs like branches
and loops. A provably continuous program is free from vio-
lations of this sort. At the same time, continuity is too weak
a robustness property for many settings, as a small but non-
innitesimal change to the inputs of a continuous function
can create disproportionately large changes to its outputs.
For example, while the function exis continuous, there is no
bound on the change in its output on a small nite change
to its input x.
In this paper, we investigate a stronger, quantitative for-
mulation of robustness of programs that does not suer from
this limitation. We believe that this formulation, based on
the analytic notion of Lipschitz continuity , is a canonical
notion of robustness for programs. By this denition, a pro-
gram is robust if a change of to its inputs, for any ,
results in a change of Kto its outputs, where Kdoes
not depend on the values of the input variables. The multi-
plierK|known as the robustness parameter |quanties the
extent of this robustness.
For example, consider the implementation Dijk of Dijk-
stra's shortest-paths algorithm in Fig. 1|here Gis a graph
with real-valued edge-weights and Nedges, and srcis the
source node. The output of the program is the table dof
shortest-path distances in G. We note that Dijk is robust
with a robustness parameter N(from now on, N-robust ):
if each edge-weight in Gchanges by, then each output
d[i] changes at most by N. But how do we verify the
above robustness property from the text of programs like
Dijk, which use features like branches, loops, and arrays?
One way is to rst prove that Dijk computes shortest
paths, and then to establish that the costs of these paths
change proportionally on changes to the edge-weights of G.
Such a proof, however, would be highly specialized and im-
possible to automate. Our goal, instead, is to develop a
proof system that reasons about robustness without having
to prove full functional correctness, is applicable to a wide
range of algorithms, and is mostly automated.
To see how we achieve this goal, consider programs like
Dijk whose inputs and outputs are from dense domains. Keyto our analysis of robustness for such programs Pis the
following metatheorem: PisK-robust if, rst, Pencodes
a continuous function, and, second, each control ow path
ofPcomputes a function that is linear in the values (but
not the size) of the input, and the magnitude of the slope
of this line is bounded by K. The rst property accounts
for the possibility of dierent control ow on the perturbed
and unperturbed input, and can be veried using an existing
analysis [5]. As for the latter property, we oer a new static
analysis for it. The nal outcome is a program analysis that
can verify the robustness of programs over continuous data
types, can be automated using o-the-shelf SMT-solvers (we
provide an implementation on top of the Z3 solver), and
can verify the robustness of many everyday programs. For
example, we establish the property for the program Dijk by
showing that: (1) The eect of each loop iteration on the
arraydcan be written as d[v1] :=c1d[v2] +c2a+c3;
whereais the weight of some edge of G,d[v1] andd[v2] are
elements of d, andc1,c2,c3are constants with jc1j1 and
jc2j1; and (2) Each edge-weight of the input graph Gis
used only once as an operand during an addition.
We identify three application domains for our analysis.
First, our analysis can be used to guarantee the predictable
execution of embedded control programs, whose inputs come
from physical sources and can therefore be noisy or uncer-
tain. Second, we investigate the application of our system in
approximate computations that trade o accuracy of results
for resource savings. In particular, we demonstrate that a
robustness analysis can be used to provide foundations for
a recently-proposed program approximation heuristic called
loop perforation [20]. Third, our analysis can be used in the
synthesis of information release mechanisms that satisfy dif-
ferential privacy [10], perhaps the most popular denition of
privacy for statistical databases.
Summary of contributions and organization
Now we summarize this paper's contributions:
We give a canonical, quantitative denition of robust-
ness of programs (Sec. 2).
We present a sound program analysis that can be used
to verify the robustness of a given program (Sec. 3).
(Sec. 5).
We present a prototype implementation of our proof
system, built on top of the Z3 SMT-solver (Sec. 5).
We identify three application domains for our analysis.
(Sec. 4)
2. ROBUSTNESS OF PROGRAMS
Now we formalize our notion of robustness of programs.
We begin by xing a language Impof imperative arithmetic
programs. For simplicity, we allow Imponly two data types:
reals ( real) and arrays of reals ( realarr ). Other popular
types such as records, tuples, and functional lists/trees can
be added without changing the analysis signicantly. Our
robustness analysis can be extended to programs with dis-
crete typed inputs such as integers. We intend to present
this extension in a future work. Also, we assume that re-
als in Impare innite-precision rather than oating-point,
and treat arithmetic and comparison operations on them
as unit-time oracles. Thus, our programs are equivalent to
Blum-Shub-Smale Turing machines [2]. While this idealized
semantics rules out reasoning about oating-point rounding
errors, we can use it to prove the absence of robustness bugsdue to awed logic (arguably, it is this semantics that forms
the mental model of programmers as they design numerical
algorithms). We intend to pursue a oating-point modeling
of continuous data in future work.
As for perturbations, they can change the value of a datum
but not its type or size, the latter being 1 if the datum is a
real, andNif it is an array of length N. We assume, for each
typeand sizeN, ametric1d;N. An-change to a value x
of typeand sizeNis assumed to result in a value y, of type
and sizeN, such that d;N(x;y) =. In particular, the
type real is associated with the Euclidean metric, dened as
dreal;1(x;y) =jx yj:We let an-change to an array consist
of-changes to any number of its elements. Formally, the
metric over arrays of length Nwhose elements are of type 
is theL1-norm :
darray of;N(A;B) = max
ifd(A[i];B[i])g:
Now we oer the syntax of arithmetic expressions e, boolean
expressions b, and programs PinImp:
e::=xjcje1+e2je1e2jA[i]
b::=e>0je= 0jb1^b2j:b
P::=skipjx:=ejA[i] :=ejifbthenP1elseP2
jwhilebdoP1jP1;P2
Herexis a variable, cis a constant, Ais an array variable,
ian integer variable or constant, and the arithmetic and
boolean operators are as usual. We let each statement be
annotated with a distinct label.
As for semantics, let us only consider programs Pthat
terminate on all inputs . The semantics of Pis the standard
denotational semantics [27] for imperative programs (except
as mentioned earlier, we assume unit-time operations on re-
als). Formally, let us associate with each variable xa set
Cloc(x) ofconcrete memory locations . Astate ofPis a map
that assigns a value in Valto each program variable x
of type. We denote the set of all states of Pby (P).
Each state induces, in the usual way, an assignment of con-
tents to each location y2Cloc(x), for each variable x. We
use the notation (y) to denote the content of location yat
state. The semantics of the program P, and an expression
eof typeappearing in it, are now dened by two func-
tions [ [P] ] : (P)!(P) and [ [e] ] : (P)!Val, where
Valis the set of values of type . Intuitively, [ [ e] ]() is the
value ofeat state, and [ [P] ]() is the state at which P
terminates after starting execution from . In addition, we
assume denitions of control ow paths (sequences of labels)
and executions (sequences of states) of P. These denitions
are all standard, and hence omitted.
Robustness of programs. Our denition of robustness
of programs is based on the analytic notion of Lipschitz con-
tinuity [1]. Intuitively, a program PisK-robust if any addi-
tive-change to the input of Pcan only change the output
ofPbyK. Note that is arbitrary, so that the output of
aK-robust program changes proportionally on anychange
to the inputs, and not just small ones.
As a program can have multiple inputs and outputs, we
dene robustness with respect to an input variable xinand
anoutput variable xout. IfPis robust with respect to xinand
1Recall that a metric over a setSis a function d:SS!
R[f1g such that for all x;y;z , we have: (1) d(x;y)0,
withd(x;y) = 0 ix=y; (2)d(x;y) =d(y;x); and (3)
d(x;y) +d(y;z)d(x;z).xout, a change to the initial value of any xin, while keeping
the remaining variables xed, must only cause a proportional
change to the nal value of xout. Variables other than xout
can change arbitrarily.
Also, we allow robustness parameters that are not just
constants, but depend on the size of the input . For example,
suppose the size of xinisN, and an-change to it changes
the output by N. ThenPisN-robust with respect to xin.
We model this by letting a robustness parameter Kbe a
function of type N!R, rather than just a real.
Finally, our denition allows a program to be robust only
within a certain subset 0of the input space, without asser-
tions about the eect of perturbations on states outside 0
(capturing the fact that many realistic programs are robust
only within certain regions of their input space).
Formally, for a variable x(say of type ) and a state , let
Size(x;) be the size of the value of xat. Now let2R+;
also let02(P) such that (x;) = Size(x;0) =N.
The state0is an (;x)-perturbation of, and is denoted
byPert;x(;0), ifd;N((x);0(x))< , and for all other
variablesy, we have(y) =0(y). The states and0are
(;x)-close (written as ;x0) ifd;m((x);0(x))< .
Now we dene:
Definition 1 (Robustness of programs). Consider
a functionK:N!Rand a set of states 0. The pro-
gramPisK-robust within 0with respect to the input xin
and the output xoutif for all;020and2R+, we have
Pert;xin(;0) =)[ [P] ]()m;x out[ [P] ](0)
wherem=K(Size(xin;)):
Definition 2 (Continuity of programs [5]). The pro-
gramPis continuous within 0with respect to the input
xinand the output xoutif for all2R+;20, there exists
a2R+such that for all 020,
Pert;xin(;0) =)[ [P] ]();xout[ [P] ](0):
IfPis continuous by the above, then innitesimal pertur-
bations toxin(that keep the state within the set 0) can
only cause innitesimal changes to xout. Not all continuous
programs are robust. For example, a program computing
x2, given arbitrary x2R, is continuous but non-robust.
Now we consider a few everyday programs that are robust
or continuous by the above denitions:
Example 1 (Sorting). Consider a correct implemen-
tationPof a sorting algorithm that takes in an array Ain
of reals, and returns a sorted array Aout. The program is
1-robust, with respect to input Ainand output Aout, within
(P): for any>0, if each element of Ainis perturbed at
most by, then the maximum change to an element of the
outputAoutisas well. Note that this observation is not
at all obvious, as we are speaking of arbitrary changes to
Ainhere, and as even the minutest change to Aincan alter
the position of a given item in Aoutarbitrarily.
Example 2 (Shortest paths, MSTs). Let SP be a cor-
rect implementation of a shortest-path algorithm (e.g., Dijk;
Fig. 1). We view the graph Gon which SP operates as a
perturbable array of reals such that G[i]is the weight of the
i-th edge. An -change to Gthus amounts to a maximumKruskal (G: graph)
1foreach nodevinGdoC[v] :=fvg;
2WL:= set of all edges in G; cost:= 0;T:=;;
3while WL6=;
4 choose edge ( v;w)2WL
such thatG(v;w) is minimal;
5 remove ( v;w) from WL;
6 ifC[v]6=C[w]then
7 add edge ( v;w) toT;
8 cost:=cost+G(v;w);
9 C[v] :=C[w] :=C[v][C[w];
Figure 2: Kruskal's algorithm
change ofto any edge-weight of G, while keeping the node
and edge structure intact.
One output of SP is the array dof shortest-path distances
inG|i.e.,d[i]is the length of the shortest path from the
source node src to the i-th nodeuiofG. A second output
is the array whosei-th element is a sequence of nodes
forming a minimal-weight path between src and ui. Let the
distance between two elements of be 0 if they are identical,
and1otherwise.
As it happens, SP is N-robust everywhere within (P)
with respect to the output d|if each edge weight in Gchanges
by an amount , a shortest path weight can change at most
by(N). However, an -change to Gmay add or subtract
elements from |i.e., perturb by the amount1. There-
fore, SP is not K-robust with respect to the output for any
K.
Similar arguments apply to a program MST computing
minimum spanning trees in a graph G(Kruskal's algorithm;
Fig. 2). Suppose the program has two outputs: a sequence T
of edges forming a minimum spanning tree, and the cost of
this tree. MST is N-robust within (MST )if the output is
cost, but not robust if the output is T.
3. VERIFYING ROBUSTNESS
In this section, we present our program analysis for robust-
ness. The inputs of the analysis are a program P, symbolic
encodings of a set 0of (P) and a function K:N!R, an
input variable xin, and an output variable xout. Our goal is
to soundly judge P K-robust within 0with respect to xin
andxout.
3.1 Piecewise K-robustness and K-linearity
Consider, rst, the simple scenario where Phas a single
real-valued variable x. Note that each control ow path of
Pcomputes a dierentiable function over the inputs. Now
suppose we can show that each control ow path of Prep-
resents a robust computation (in this case, Pis said to be
piecewiseK-robust ). Piecewise robustness does not entail
robustness: a perturbation to the initial value of xcan cause
Pto execute along a dierent control ow path, leading to a
completely dierent nal state. However, if Piscontinuous
as well as piecewise K-robust, then PisK-robust as well,
e.g. the function abs(x) =jxj, wherex2R, is continuous
as well as piecewise 1-robust|hence 1-robust. On the other
hand, the continuous function \ if(x > 0)thenx2elsex" is
nonrobust because x2is not piecewise robust within x2R.
The above observation can be generalized to settings wherePhas multiple variables of dierent types. Our analysis ex-
ploits it to decompose the problem of robustness analysis
into two independent subproblems: that of verifying conti-
nuity and piecewise K-robustness of P.
For any program Pand any set of states 0ofP, let 0
(i)
denote the set of states 20such that starting from ,P
executes along its i-th control ow path (we assume a global
order on control ow paths). Let us now dene:
Definition 3 (Piecewise K-robustness). LetPbe
a program, 0(P)a set of states, Ka function of type
N!R, andxin;xout2Var(P).PispiecewiseK-robust
within 0(P)with respect to input xinand output xout
if for alli,PisK-robust within (i)with respect to xinand
xout.
We establish piecewise robustness using the weaker property
ofpiecewiseK-linearity , which says that the function com-
puted by each control ow path of Pis a linear function,
and that the absolute value of its slope is bounded by K:
Definition 4 (Piecewise K-linearity). LetPbe a
program, 0(P)a set of states, Ka function of type
N!R, andxin;xout2Var(P).PisK-linear within 0
w.r.t. input xinand output xoutif for each z2Cloc(xin),
y2Cloc(xout),20, we have the relationship
([ [P] ]())(y) =0
@X
z2Cloc (xin)cz;yz1
A+;
whereis an expression whose free variables range over the
setS
x06=xinCloc(x0), andP
zjcz;yjK(Size(xin;)).Pis
piecewiseK-linear within 0(P)with respect to input
xinand output xoutif for alli,PisK-linear within (i)
with respect to xinandxout.
It is not hard to see that:
Theorem 1.IfPis piecewise K-linear, then Pis piece-
wiseK-robust.
Example 3 (Dijkstra's algorithm). Consider, once
again, the procedure Dijk in Fig. 1. While the dependence
betweenGanddis complex, Dijk is piecewise N-robust inG
andd. To see why, consider any control ow path of Dijk
and view it as a straight-line program. Suppose the addition
operation in Line 8 of Dijk is executed Mtimes in this pro-
gram. As we only remove elements from the worklist WL,
a specic edge G[w;v]is used at most once as an operand
of this addition. Consequently, we have MN, whereN
is the size of G. LetM0be the number of times Line 10
assigns the result of this addition to an element of d. We
haveM0MN. It is easy to see that this means that 
isN-linear with respect to input Gand output d. As the set
of control ow paths in Dijk is countable and each path is
N-linear with respect to Gandd, Dijk is piecewise N-robust
within (Dijk)with respect to Gandd.
3.2 Robustness
Now we apply the notion of piecewise robustness and
piecewise linearity in the analysis of robustness.
Theorem 2.LetPbe a program, 0(P), andxin
andxoutbe variables of dense types. PisK-robust withinInsertion-Sort (A: realarr)
1fori:= 1to(jAj 1)
2z:=A[i];j:=i 1;
3 whilej0 andA[j]>z
4 A[j+ 1] :=A[j];j:=j 1;
5A[j+ 1] :=z;
Figure 3: Insertion sort
0with respect to input xinand output xoutif and only if:
(1)Pis continuous within 0w.r.t. input xinand output
xout; and (2)Pis piecewise K-robust within 0with respect
to inputxinand output xout.
By Theorem 2, the problem of robustness analysis can be
decomposed soundly and completely into the problems of
verifying continuity and piecewise robustness. We establish
these conditions independently. The rst criterion is proved
using a sound program analysis due to Chaudhuri et al [5]
(from now on, we call this system Cont ). To prove the sec-
ond property, we prove Pto be piecewise K-linear, and use
Theorem 1. However, for reasons outlined later, no exist-
ing sound abstraction that we know of is suited to precise
and ecient analysis of piecewise linearity|a new solution
is needed.
Piecewise linearity using arithmetic-freedom
It is sometimes possible to establish piecewise linearity us-
ing traditional dataow analysis. Let a program Qbe free
of arithmetic operations|i.e., if x:=eis an assignment in
the program, then the evaluation of edoes not require arith-
metic. In this case, each control ow path in Qencodes a
1-linear function, which means that Qis piecewise 1-linear.
Generalizing, let a program Pbearithmetic-free with re-
spect to input xinand outputs xoutif all data ows from
xintoxoutare free of arithmetic operations. A program can
be shown arithmetic-free in this sense using standard slicing
techniques. We can use a program like Qabove as an ab-
straction of P. Application in the verication of piecewise
robustness stems from the fact that:
Theorem 3.If a program Pis arithmetic-free within 0
(P)with respect to input xinand output xout, thenPis
piecewise 1-linear within 0with respect to input xinand
outputxout.
Example 4 (Sorting). The seemingly trivial abstrac-
tion of arithmetic-freedom can in fact be used to prove the
robustness of several challenging, array-manipulating algo-
rithms. Consider Insertion Sort (Fig. 3), where the array
Ais the input as well as the output. A lightweight anal-
ysis can prove this algorithm arithmetic-free, at all input
states, with respect to the input Aand output A. While
arithmetic does occur in the program, it only updates the in-
dexi, whose value does not depend on the original contents
ofA. Other algorithms like Mergesort and Bubblesort can
be proved arithmetic-free in the same way. Separately, we
prove these algorithms continuous using Cont , which gives
us a proof of 1-robustness.
Piecewise linearity with robustness matrices
In most realistic programs, however, arithmetic-freedom will
not suce, and some form of quantitative reasoning will be(Skip)skip`I
(Assign)xi:=e`rwhere
8j;k:rjk=8
>>><
>>>:@e
@xkifj=iand@e
@xkis constant
1 ifj=iand@e
@xkdepends on the xm-s
1 ifj=k6=i
0 otherwise
(Weaken)P0`r 8i;j:rijr0
ij
P0`r0
(Sequence)P1`r 1P2`r 2
P1;P2`r 2r1
(Ite)P1`r 1P2`r 2
ifbthenP1elseP2`max(r1;r2)
(While-1)P0=whilebdoP00P00`r00Bound+(P0;M)
8i;j: (r00
ij= 0_r00
ij1)
P0`(r00)M
(While-2)P0=whilebdoP00P00`r00Bound (P0;M)
8i;j:r00
ij<1
P0`(r00)M
Figure 4: System Robmat for propagating robust-
ness matrices
necessary. A natural rst question is: can we use a tradi-
tional numerical abstract domain|such as polyhedra [9]|
for such reasoning? The answer, unfortunately, seems to be
no. Consider the program
if(x+y>0)thenz:=x+yelsez:= x y
Our goal is to prove this program piecewise 1-linear with
respect to input xand output y. Unfortunately, the best
invariant that we can establish at the end of the branch using
the polyhedra domain is ( zx+y)^(z x y). These
constraints permit zto be a linear function of xwith slope
equal to1|hence the best we can say is that the program
is1-robust! The key issue here is that we need a form
ofdisjunctive reasoning to track quantities (absolute values
of slopes) computed along dierent paths. While there is a
plethora of abstract domains for disjunctive reasoning about
programs [6, 7], none of them, so far as we know, is suitable
for this purpose. Now we present a simple static analysis
that fulls our needs.
Here, an abstract state|known as a robustness matrix |
tracks, for each pair of memory locations xandy, a bound
on the slope of the expression relating the current value of
xto the initial value of y. This information is propagated
through the program using an abstract interpretation.
For brevity, we make a few simplifying assumptions in
this presentation. First, we assume that all variables of P
are real valued. The analysis that we have actually imple-
mented can handle arrays by abstracting each unbounded
array using a nite number of abstract memory locations.
As this array abstraction is standard but adds signicantly
to the notation, we omit its details. Also, we only show
how to derive piecewise linearity judgments holding over
the entire space ( P). A generalization to judgments con-
ditioned by 0(P) is, however, easy to construct. Fi-
nally, we view a program state not as a map but as a vector
hr1;:::;rni, whereriis the value of the i-th variable xi. The
denotational semantics of any program Qis thus a function1x:=afrx;a= 1g
2y:=bfrx;a= 1,ry;b= 1g
3if(xy)
4 thenz:= 2x+y
frx;a= 1;ry;b= 1;rz;x= 2;rz;y= 1;rz;a= 2;rz;b= 1g
5 elsez:= 3y+x;frx;a= 1;ry;b= 1;rz;x= 1,
rz;y= 3;rz;a= 1;rz;b= 3g
frx;a= 1;ry;b= 1;rz;x= 2;rz;y= 3;rz;a= 2;rz;b= 3g
Figure 5: Piecewise robustness using robustness ma-
trices
[ [Q] ] :Rn!Rn. Now we dene a robustness matrix rforP
to be annnmatrix whose elements rijare non-negative
reals.
To understand the interpretation of this matrix, we re-
call the classic denition of a Jacobian from vector calcu-
lus. The Jacobian of a function f:Rn!Rnwith inputs
xin
1;:::;xin
n2Rand outputs x1;:::;xn2Ris the matrix
Jf=0
B@@x1
@xin
1:::@x1
@xinn
::: :::
@xn
@xin
1:::@xn
@xinn1
CA
Iffis a dierentiable function, then for each xiandxin
j, it
isK-robust with respect to input xjand output xi, where
Kis any upper bound on j@xi
@xin
jj. In our setting, the expres-
sion relating the inputs and outputs of a single control ow
path is dierentiable; consequently, we can verify the ro-
bustness of this expression by propagating a Jacobian along
it (strictly, entries in the actual matrix that we carry are
constant upper bounds on the absolute values of the terms
@xi=@xin
j). It is possible to carry out this propagation using
the chain rule of dierentiation. Of course, due to branches,
a program Pneed not be dierentiable. This is where ab-
stract interpretation comes handy|we merge multiple Jaco-
bians propagated along dierent paths into a robustness ma-
trixthat overestimates the robustness parameter of P. Such
a merge demands an abstract join operator t: for robust-
ness matricesrandr0, we dene (rtr0) to be the matrix
Msuch that for all i;j, we haveMij= max(rij;r0
ij):
Note that with the above strategy, we will infer robustness
matrices even for discontinuous programs. This is, of course,
acceptable, as the present analysis only veries piecewise
robustness|continuity is judged separately by Cont .
The goal of our analysis|call it Robmat |is to syntac-
tically derive facts of the form P0`r, read as: \ris the
robustness matrix for the subprogram P0." The structural
rules for the analysis are shown in Fig. 4. Here, Iis the iden-
tity matrix. The assertion Bound+(P0;M) states that Mis
an upper bound on the number of iterations of the while-
loopP0; likewise, Bound (P0;M) states that the symbolic
or numeric constant Mis a lower bound on the number of
iterations for which P0executes. These conditions can be
established either via an auxiliary checker or by manual an-
notation.
We observe that the robustness matrix for P1;P2obtained
by multiplying the matrices for P1andP2|this rule follows
from the chain rule of calculus. This rule is now generalized
into the rule While-1 for while-loops. As the loop may
terminate after M0<M iterations, we require the following
extra condition for the rule to be sound: ( r00)i(r00)i+1P::=hall syntactic forms in Impijhthe formQbelowi
l:whileb
:= nondeterministically chosen u2U;
R(U;;xin[];xout)
Figure 6: The language Limp (Prepresents pro-
grams).
for alli < M . This property is ensured by the condition
8i;j: (r00
ij= 0_r00
ij1). Note that in the course of a
proof, we can weaken anyrobustness matrix that does not
satisfy this condition to one that does, using the Weaken
rule. On the other hand, the While-2 rule applies to the
special case when all matrix elements are less than 1|that
is, the matrix represents a contraction.
We have:
Theorem 4.If the system Robmat derives the judgment
P`r , then for all i;j,Pis piecewiserij-linear within
(P)with respect to the input xjand the output xi.
Example 5.Fig. 5 shows the result of applying a dataow
analysis based on Robmat to a simple program. The anno-
tations depict the robustness matrices rpropagated to the
various program points|we use the more readable notation
ry;zto refer to the matrix entry rijifyandzare respec-
tively thei-th andj-th variables. Observe, in particular,
how the robustness matrices from the two branches of the
program are merged.
Piecewise linearity with linear loops
A problem with the robustness matrix abstraction is that
it does not satisfactorily handle loops iterating over un-
bounded data structures. For example, let us try to use it
to prove Dijkstra's algorithm (Fig. 1) piecewise linear w.r.t.
inputGand output d. Here, each iteration makes multi-
ple assignments to dand is consequently piecewise K-linear
forK2. As the main loop iterates Ntimes, the com-
plete algorithm is then piecewise O(2N)-robust. However,
by the reasoning in Ex. 3, Dijkstra's algorithm is piecewise
N-linear. Now we present an abstraction that can establish
this and similar facts. A key insight here is to treat the loca-
tions of the input variable xinasresources , and to establish
an assertion of the form\Each location of xinis used at most
once during the execution of the loop."
To express our conservative abstractions, we extend the
language Impwith a syntactic form for loops with restricted
nondeterministic choice. We call this extended language
Limp . Its syntax is as in Figure 6. Here:
Uis a set|the iteration space for the loop in the syn-
tactic form Q. Its elements are called choices .
xinis an unbounded data structure (e.g. an array).
is a special variable, called the current choice vari-
able. Every iteration starts by picking an element of
Uand storing it in .
xoutis the output variable.
R(U;;xin[];xout) (henceforth R) is an Impprogram
that does not write to , or use elements of xinother
thanxin[], but can read and read or update the
iteration space U, elementxin[], and the output xout.(LinLoop)UseOnce (;U;Q )
PLin (R;k;xin[];xout)PLin (R;1;xout;xout)
PLin (Q;k:N;xin;xout)
Figure 7: Proof rule LinLoop (Qis an abstract loop)
We call a program of form Qanabstract loop |henceforth,
Qdenotes an arbitrary, xed abstract loop. For simplicity,
we only consider the analysis of abstract loops|an extension
to all Limp programs involves a combination of the present
abstraction with the previous abstractions. As before, we
restrict ourselves to programs that terminate on all inputs.
The main loops in Figs. 1 and 2 are abstract loops. For
example, the workset WL, the graph G, the nodeu, and the
arraydin Figure 1 respectively correspond to the iteration
spaceU, the input variable xin, the choice variable , and
the output variable xout.
Now we present a rule (Fig. 7) for proving piecewise N-
linearity of Limp programs. As before, for brevity, we only
derive robustness judgments that hold over the entire ( P).
We denote by PLin (P;k:N;xin;xout) the judgment \ Pis
piecewisek:N-linear within ( P) with respect to xinand
xout."
A key premise for the rule is the assertion UseOnce (;U;Q ),
which states that the values ofchosen during a complete
execution of Qare all distinct . As the variable is used to in-
dex the data array xin, we can also see this assertion to mean
that each memory location in xinis used at most once dur-
ing a run of Q. We establish the property UseOnce (;U;Q )
using a few syntactic sucient conditions that apply to sev-
eral common classes of programs. For example, if Qis a
for-loop over the indices of xin, andis the (monotoni-
cally increasing or decreasing) index variable, then we have
UseOnce (;U;Q ). For another example, consider Dijkstra's
algorithm (Fig. 1), where an element wis removed from the
workset WLin each iteration, never to be re-inserted again.
In this case, letting QDijkbe the main loop (Lines 4-10) of
the program, we have UseOnce (w;WL;QDijk). Another ex-
ample in this class is Kruskal's algorithm (Fig. 2), where
we iterate over a workset that initially contains all edges of
the input graph. Because edges are removed from but never
added to this set, we have a use-once invariant similar to that
inDijk. Lastly, observe the premises PLin (R;k;xin[];xout)
andPLin (R;1;xout;xout). These are typically derived using
one of our other abstractions|e.g., robustness matrices.
To see the intuition behind the rule LinLoop , consider the
simple case where xoutis areal. By the premises, the eect
of each iteration on xoutcan be summarized by assignments
xout:=c1xout+c2xin[] +c3
wherec1,c2, andc3are constants with jc1j1 andjc2jk.
As each location in xinis used only once and our norm over
arrays isL1, this means the complete loop is piecewise k:N-
linear with respect to output xout.2We can show that:
Theorem 5 (Soundness). If the rule LinLoop infers
the judgment PLin (Q;N;xin;xout), then the abstract loop Q
is piecewise N-linear within (Q)with respect to input xin
and output xout.
2Interestingly, if the metric for arrays were the L1-
norm rather than the L1-norm, then the rule LinLoop
would be sound even if we changed its conclusion to
PLin (Q;k;xin;xout).calc trans slow torques (angle : real;speed : real)
1 limit := 29; pressure1 := 0; pressure2 := 0;
2if(angle27^angle<35)then limit :=41;
3elseif (angle35^angle<50)then limit :=63;
4elseif (angle50^angle<65)then limit :=109;
5elseif (angle65)then limit := 127;
6if(3 * speedlimit)
7 then gear := 3; pressure1 := 1000;
8 else gear := 4; pressure1 := 1000;
9if(gear3)then pressure2 := 1000
Figure 8: Code from a car transmission controller
Example 6 (Kruskal's algorithm). For an applica-
tion of the rule LinLoop , consider Kruskal's algorithm (2),
whose main loop can be abstracted using an abstract loop.
To analyze this loop, we establish the use-once property as
discussed earlier. All that is left is to show that the loop body
(Line 5-9) is piecewise 1-linear. This is easy to do using the
robustness matrix abstraction. A similar strategy applies to
several other examples, such as Dijkstra's or Bellman-Ford's
shortest-path algorithms.
4. APPLICATIONS
In this section, we identify three motivating application
domains for our analysis. As this paper is primarily a foun-
dational contribution, our discussions here use small, illus-
trative code fragments. The challenges of scaling to large
real-world benchmarks is left for future work.
4.1 Robustness of embedded control software
Robustness is a critical system property for many embed-
ded control systems. The sensor data that drives these sys-
tems is often prone to noise and errors, and unpredictable
changes to system behavior due to this sort of uncertainty
can have catastrophic consequences. A proof that the sys-
tem reacts predictably to perturbations in its inputs is there-
fore of crucial practical importance. Unsurprisingly, control
theorists have studied the problem of robust controller de-
sign thoroughly [28]. However, approaches to the problem
in control theory are concerned with deriving abstractly de-
ned laws for robust control, rather than proving the ro-
bustness of the software that ultimately implements them.
This is a gap that a program analysis of robustness a la our
paper can ll.
As an example of how to apply our analysis to this space,
we consider the code fragment in Fig. 8, derived from a
software implementation of a transmission shift control sys-
tem [3]. Robustness of this fragment, under a dierent def-
inition of robustness, was previously studied by Majumdar
and Saha [16]. Given the car speed and the throttle angle,
the operator calc_trans_slow_torques computes a pair of
pressure values pressure1 and presure2 , which are applied
to actuators related to the car transmission system. A care-
ful analysis reveals that the output pressure1 is constant,
which means the function is 1-robust in that output. On
the other hand, it is not continuous in the second output
pressure2 , hence is not K-robust for any K. Sec. 5 reports
on the results of our implementation on this example.
4.2 Robustness in approximate computation
Another application for our analysis is in approximate
computation , where the goal is to trade o the accuracy of a1while (H(i))
2 if(y7!P(y)), wherey2[x[i] ;x[i] +], is in table
3 thent:= look up P(y);G(y;z;t;i )
4 elset:=P(x[i]);
5 tabulate ( x[i]7!P(x[i]));G(x[i];z;t;i )
Figure 9: Approximate memoization for loops
computation for resource savings. Rather than approximate
solutions for specic problems, language-based program ap-
proximation [20] involves program transformations that are
just like traditional compiler optimizations but, when ap-
plied to a program, lead to an approximately equivalent pro-
gram. Such approaches are especially applicable to domains
like image and signal processing, where programs compute
continuous values with negotiable accuracy.
While such approximation schemes have been much dis-
cussed of late, very little is understood at this time about
their theoretical foundations. Now we show that a robust-
ness analysis such as ours can provide foundations for one
such scheme, called loop perforation [20, 19]. The loop per-
foration optimization is applicable to expensive computa-
tional loops over large datasets; what it does is simply skip
every alternate iteration in certain long-running loops. The
empirical observation in many cases, this bizarre and obvi-
ously unsound optimization does not signicantly aect the
accuracy of the nal output. In [20], a proling compiler is
proposed that exploits this fact and identies loop iterations
that can be skipped.
As for the theoretical foundations of loop perforation, a
recent paper [19] shows that if the loop under consideration
follows certain computational patterns and the dataset on
which the loop operates follows certain probability distribu-
tions, then loop perforation is\probabilistically sound"|i.e.,
the output of loop perforation is guaranteed to be within
reasonable bounds with high probability. Now we show that
such a guarantee is available for anyloop that satises cer-
tain robustness requirements of the sort studied in this pa-
per. This means that our analysis can be used to identify
loops that can be correctly perforated, and can serve as a
static guidance mechanism for a perforating compiler.
Approximate memoization. Before we show how ro-
bustness relates to loop perforation, let us oer a more gen-
eral approximation scheme. Consider a loop Qof form
while (H(i))ft:=P(x[i]);G(x[i];z;t;i )g:
Herexis a large, read-only array that is the \input variable"
for the loop (for simplicity, we let elements of xto be reals).
The variable zis the\output variable," tis a temporary vari-
able,HandPare side-eect-free computations, and G(:::)
is an imperative procedure that can only read the element
x[i] out ofx, but can have other eects. The function Pis
expensive, and we would like to eliminate calls to it.
Our rst approximation of Qconsists of a sort of approx-
imate memoization ofP. Suppose that, in a loop iteration,
prior to making a call to P(x[i]), we nd that Pwas pre-
viously evaluated on some x[j] such that x[j]x[i]. Then
rather than evaluating P(x[i]), we simply use the (cached)
valueP(x[j]). The pseudocode for the optimized loop is
given in Fig. 9.
Robustness of Qis needed for this approximation to be
\sound." Denote by Q(x) the nal value of zon inputx;also, suppose QisK-robust with respect to the input xand
outputz. In that case, the scheme in Fig. 9 is equivalent to
a transformation that replaces Qby a program Q0that, on
any inputx: (1) perturbs xby an amount , resulting
in an array x0; and (2) computes Q(x0).
By the robustness of Q, the outputs Q(x) andQ(x0) on
xandx0dier at most by K. If this value is suitably
small (and we can make it be, by selecting suitably), the
optimization approximately preserves the semantics of Q.
But ifQis non-robust, the outputs of the optimization may
be very dierent from the idealized output.
Loop perforation. One obvious objection to the above
scheme is that the complexity of table lookup will make it
impractical. However, we now demonstrate that under some
extra assumptions, this scheme reduces to a scheme that is,
almost exactly, loop perforation. First, let us restrict our-
selves to for-loops iterating over an array x|i.e., we assume
Qto have the form
for0i<N dot:=P(x[i]);G(x[i];z;t)
whereN=jxj, and the imperative procedure Gdoes not
modify the induction variable iof the loop.
Second, let us assume that the input dataset xexhibits
locality |i.e., any two successive elements in xare approxi-
mately equal with high probability. Note that this property
holds in most multimedia datasets|for example, in most
images neighboring pixels, for the most part, have similar
colors. We formalize the above using a model dened in Mi-
sailovic et al [19] that views xas a random variable that is
generated by a random walk with independent increments.
In more detail, the variable x[0] is a xed constant, and
zi=x[i+ 1] x[i] follows a normal distribution Nwith
meanand variance 2.
As successive elements in xare likely to be close in value,
we can replace Qby a program bQthat usesx[i] as a proxy
for the value x[i+1], and the cached value P(x[i]) as a proxy
forP(x[i+1]), in the iteration ( i+1). Observe that we have
now arrived at an approximation scheme that is quite like
loop perforation!
There is, however, an important distinction between this
scheme and the version of loop perforation presented in prior
work [20, 19]. As the latter scheme skips loop iterations
entirely, it is not applicable when the loop body performs
discrete computations, pointer updates, etc., in addition to
callingP(these computations are encapsulated within the
routineG). Perforating these loops may lead not only to
inaccurate results but to system crashes. Our approach, on
the other hand, does not skip any iterations, but only the call
toPinside the iterations, and can be viewed as executing
Qon a perturbed input. Therefore, if the original program
Qdoes not crash on any input, then neither does bQ.
As for the analysis of error produced by the above trans-
formation, let us dene the output error for the transfor-
mation to be ErrQ(x) =d(Q(x);bQ(x)):Now observe that
bQ(x) =Q(x0) where for all i, (x[i] x0[i])N(;2). Be-
cause we use the L1norm as the distance measure over
arrays, we have, for every a>0, the property
P[d(x;x0)>a] = P[9i:jx[i] x0[i]j>a]
NP[jx[i] x0[i]j>a]
N(1 (N(a) N( a)))
where Nis the cumulative distribution function of N.InsideError (FGmap: BinaryImage)
1 samples :=0; error := 0;
2forcam:= 1 tonCams
3 forcylndr := 0 tonParts
4 s 1,s2:= vectors on sides of body part;
5 m := vector connecting midpoints of s 1and s 2;
6 n 1:=jmj/ vStep; n 2:=jmj/ hStep;
7 fori := 1 ton1
8 1 =i=n1;
9 p 1:= cylndr[0] + (s 1.x *1, s1.y *1);
10 p 2:= cylndr[3] + (s 2.x *1, s2.y *1);
11 m := p 2- p1;
12 forj := 1 ton2
13 2:= j/n 2;
14 p 3:= p 1+ (m.x *2, m.y *2);
15 error := error + (1-FGmap(p 3));
16 samples++;
17return error/samples;
Figure 10: Bodytrack's InsideError function
Let= 1 (N(a) N( a)). Note that for decreases
asaincreases, and is approximately 0 :03 fora= 3. By
theK-robustness of Q, we have:
P[ErrQ(x)>Ka]N:
The above can be seen as a\probabilistic"soundness result
for loop perforation: if the loop Qis robust with a low ro-
bustness parameter, then the probability of loop perforation
introducing a signicant error is low. Indeed, one can give
an intuitive interpretation to perforation here: it amounts to
sampling the dataset xat a lower frequency, which is accept-
able if the process is robust. What all of this means is that
one can use a robustness analysis such as ours to determine
whether a given loop is suitable for perforation.
For a concrete example, consider the code fragment in
Fig. 10, from the computer vision application called Body-
track in the Parsec benchmarks [21]. (Perforation of this
application was studied in [20].) The goal of this application
is to track the major body components of a moving subject;
the code in Fig. 10 performs a sampling computation inside
a cylinder (a projected body part). In this code, the loops at
lines 2, 3, 7, and 12 can be perforated with good results [20].
However, we observe that the reason behind this is that the
sampling process performed between lines 4 to 17 is robust.
This robustness property can be proved by our analysis.
4.3 Differential privacy
Robustness analysis can also be helpful in guaranteeing
privacy in statistical databases, where a trusted party wants
to disseminate aggregate data about a population while pre-
serving the privacy of individual members of the population.
The dominant notion of privacy in this setting is dieren-
tial privacy [10], which asserts that the result of a statistical
query should not be aected substantially by the presence
or absence of a single individual. A known strategy to \pri-
vatize" statistical queries is to add some noise to the result;
the amount of noise needed is related to how sensitive is the
query to individual changes of the data set. Our notion of
K-robustness can be used to establish the sensitivity of the
query. Suppose we have a query over_six_feet (Fig. 11)
which returns the number of individuals that are over sixfeet tall in a population. Let us represent the set of rows
in the database as two arrays of the same size: heights ,
an array of reals and rows, an array of reals whose element
values will range over [0,1] representing its presence or ab-
sence in the populations. The rst array, heights , contains
the height of the individual while the second, rows species
whether a certain row is present or not in the set. The row
is present in the database if its corresponding array element
(in the rst array representing the rows) is 1 and absent if
it is 0; note that we allow all real values between 0 and 1.
To compute the amount of noise to be used for -dierential
privacy, one rst needs to determine the robustness param-
eter of the query with respect to a suitable metric. In dif-
ferential privacy, we are only interested in determining the
robustness of over_six_feet with respect to the rst pa-
rameter, rows. Note that for this case we will need to use
theL1-norm on the type realarray . With this norm we
can prove that over_six_feet is 1-robust, as removing or
adding an element to the set will imply a change to only one
of the elements of the rows array by 1, making the L1norm
of the dierence to be 1. The rules needed for this proof can
be obtained by a simple modication of the rules that we
have presented (which assume the L1norm). According to
[10] random noise with variance 1/ will be needed so that
the query over_six_feet is-dierentially private. Thus,
our analysis can guide the amount of noise that needs to be
added to ensure the dierential privacy guarantee.
over sixfeet (rows : realarray;heights : realarray)
1 result := 0;
2fori := 0 ton
3 if(heights[i]>6)
4 then result := result + row[i];
Figure 11: A 1-robust query
5. EXPERIMENTS
We implemented our robustness analysis on top of the Z3
SMT-solver, and used the tool to verify the robustness of
several classic algorithms from an undergraduate computer
science textbook, as well as the code fragments in Section 4.
Now we report on some experiments using this tool.
Sorting Algorithms. Our tool was able to verify the ro-
bustness of several classic sorting algorithms that take an
arrayAinand return the sorted array Aout. In particular,
we considered InsertionSort, BubbleSort, SelectionSort and
MergeSort . In [5] those four algorithms where proved con-
tinuous with respect to AinandAoutusing proof system
Cont . This time we proved that the computation of Aout
is arithmetic free, hence 1-robust due to continuity.
Shortest Path Algorithms. We veried the robustness of
several shortest path algorithms. Recall that single source
shortest path is N-robust with respect to the input array
of edge weights. The proof for the particular shortest path
algorithms such as Dijk and Bellman-Ford , consists of the
following. In [5] we have proved these algorithms continu-
ous on the input array. To prove piecewise N-robustness of
the loop we prove that the loop body is piecewise 1-robust
with respect to the array variable, and with respect to out-
put variable. This is done using the rule RobMat on an
abstraction of loop body. It follows from our method thatafter executing the loop, the output variable disN-linear
with respect to the array of edge waits. Given that it is
piecewiseN-linear and continuous we can conclude that it
isN-robust. It must be noted that the nested loop struc-
ture in Dijk can be abstracted as one single loop in Limp .
Our proof system is unable to prove N-robustness for some
shortest path algorithms such as Floyd-Warshall .
Minimum Spanning Tree Algorithms. The minimun
spanning tree problem is N-robust, as explained in Exam-
ple 2. The proofs for the particular spanning tree algorithms,
Kruskall and Prim , are similar to that of the shortest path
algorithms. Continuity is proved using the Cont proof sys-
tem of [5]. Piecewise N-linearity follows by expressing the
loop in Limp and proving piecewise 1-robustness of the loop
body. Now we conclude that the aforementioned algorithms
areN-robust. Again our proof system can not prove N-
robustness for some spanning tree algorithms like Boruvka's .
Knapsack Algorithms. The integer-knapsack algorithm
takes as input a weight array cand a value array v, and
a knapsack capacity Budget and returns the set of items
with maximum combined value totvsuch that their com-
bined weight is less than the knapsack capacity. Clearly
value of totvisN-robust inv. To prove N-robustness of
our recursive Knapsack implementation we rst prove the
algorithm continuous using Cont [5]. The prover uses a x-
point procedure to prove piecewise K-robustness assuming
K-robustness for the recursive function calls, while probing
for dierent values of K(0,1 andn). In order to prove
piecewiseN-linearity, the function was manually rewritten
to make it explicit the array partitioning operation at each
recursive call, where the input arrays are partitioned in two,
one containing only the rst element, and the other contain-
ing the rest. The tool keeps track of this partitioning to
proveN-linearity for the addition operation in line 5. At
each xpoint iteration linearity of the function body is es-
tablished using proof system Robmat .
Car Transmission Controller Example (Fig. 8). The
algorithm produces two outputs in two variables, pressure1
and pressure2. The tool determines 1-robustness on pres-
sure1, and non robust on pressure2. To arrive to that con-
clusion the tool uses the proof system Robmat in conjunc-
tion to the SMT solver to discharge proof obligations for
each discontinuity. These proof obligations arise due to the
proof rule Ite-Con presented in continuity analysis [5].
Loop perforation examples. Our proof rules are able to
establish robustness proofs for several other code segments
from the Parsec Benchmark Suite [21] where loop perfora-
tion is empirically successful [20].
In particular, our rules can prove the robustness of the
loops for the ImageMeasurement class in the Bodytrack ap-
plication (including the one shown in Fig. 10), where loop
perforation is reported to work. A second example comes
from x264, a media application that performs H.264 encod-
ing on a video stream. Two outermost loops in function
pixel_satd_wxh are claimed to be amenable to perforation
with good results by [20]. We looked at the code snippet
inside the body of the nested loops: similar to the example
in bodytrack, perforating these loops will result in sampling
less points in a coarser way, and the computation inside the
body of the loop is a robust computation.
However, not all loops that are empirically amenable toExample Time #
SMT
proofsProof method
BubbleSort 0.250 1 continuity + arithmetic freedom
InsertionSort 0.098 1 continuity + arithmetic freedom
SelectionSort 0.293 3 continuity + arithmetic freedom
MergeSort 0.560 3 continuity + arithmetic freedom + array
partitioning
Dijkstra 0.454 3 continuity + robustness matrix + linear
loops
Bellman-Ford 0.316 1 continuity + robustness matrix + linear
loops
Kruskal 1.198 1 continuity + robustness matrix + linear
loops
Prim 0.547 3 continuity + robustness matrix + linear
loops
Knapsack 1.480 3 continuity + robustness matrix + array
partitioning
Controller 8.770 60 continuity + robustness matrix
Table 1: Benchmark Examples
loop perforation are provably robust by our analysis. Exam-
ples include the loop in the pFL() routine in the StreamClus-
ter application, and a loop in the ParticleFilter::Update
method in Bodytrack. We leave for future work a proof prin-
ciple that can explain why these (and similar) loops can be
successfully perforated.
Implementation and Experimental Setup. Our tool
is implemented in C#, relying on the Z3 SMT solver to dis-
charge proof obligations and the Phoenix Compiler Frame-
work to process the input program. The bulk of the new
analysis computes facts about linear dependences between
variables and parameters and is implemented as a xpoint
computation that nds the solution of dataow equations
derived from the proof rules. Some proof obligations are dis-
charged in the process by the SMT-solver. In the future we
plan to use an optimization toolbox to have better guesses
for the minimum bound. Some proofs involving arrays, e.g.
MergeSort , requires to keep track of the accesses to the ar-
ray, with purpose to ensure disjoint access to elements of the
array. Finally, as mentioned earlier, we manually rewrote
some of the programs to t the abstraction language LIMP.
The performance results reported in table 1 were obtained
on a Core2 Duo 2.53 Ghz with 4GB of RAM.
6. RELATED WORK
Robustness is a standard correctness property in control
theory [22, 23], and there is an entire subeld of control
theory studying the design and analysis of robust (control)
systems. However, the systems studied by this literature
methods are abstractly dened using dierential equations
and hybrid automata, rather than programs. As far as we
know, the only eort to generally dene and study the ro-
bustness of embedded control software can be found in [16,
17] on test generation for robustness. There, robustness is
formulated as: \If the input of the program Pchanges by
an amount less than , whereis axed constant, then the
output changes by only slightly." In contrast, we verify the
stronger property that anyperturbation to the inputs will
change the output proportionally. Many applications (e.g.,
dierential privacy) demand this stronger formulation.
In addition, there are many eorts in the abstract inter-
pretation literature that, while not verifying robustness ex-
plicitly, reason about the uncertainty in a program's behav-ior due to oating-point rounding and sensor errors [11, 18,
8, 6, 7]. Several of these approaches have been success-
fully applied to large embedded code bases. However, none
of them reason systematically about divergent control ow
caused due to uncertainty, which we can thanks to our con-
tinuity analysis. Also, none of the abstractions developed in
this space seem suitable for an analysis of piecewise robust-
ness that is needed to verify robustness.
So far as we know, Hamlet [13] was the rst to argue
for a testing methodology for Lipschitz-continuity of soft-
ware. However, he failed to oer new program analysis
techniques. Reed and Pierce [25] have since given a type
system that can verify the Lipschitz-continuity of functional
programs, as a component of a new language for dierential
privacy [24]. While the system can seamlessly handle func-
tional data structures such as lists and maps, it does not,
unlike our analysis, handle control ow, and would deem any
program containing a conditional branch to be nonrobust.
Also, this work does not consider any application other than
dierential privacy.
Robustness and stability of numerical algorithms are also
well-studied topics in the numerical analysis literature [14].
However, the proofs studied there are manual, and special-
ized to specic numerical algorithms. Other related liter-
atures include that on automatic dierentiation (AD) [4],
where the goal is to transform a program Pinto a program
that returns the derivative of Pwhere it exists. But AD
does not attempt verication|no attempt is made to cer-
tify a program as dierentiable or Lipschitz.
Finally, language-based approaches to program approxi-
mation are still very new [20, 19, 26]. In particular, there is
only one existing paper [19] studying the theory of language-
based program approximation.
7. CONCLUSION
We have presented a program analysis to quantify the ro-
bustness of a program to uncertainty in its inputs. Our
analysis is sound, and decomposes the verication of robust-
ness into the independent subproblems of verifying continu-
ity and piecewise robustness.
In future work, we intend to extend our robustness anal-
ysis to programs that manipulate discrete data types like
integers and boolean arrays in addition to continuous ones
(like the ones studied here). This extension is especially im-
portant as discrete types are often used in real-world appli-
cations, in particular embedded control code. Another inter-
esting question is the generation of test inputs that trigger
robustness bugs|i.e. pairs of inputs that are close in value,
but on which the program behaves very dierently. A third
interesting direction is a notion of robustness for reactive
programs , where we must consider perturbations not only in
the program inputs, but also in the environment with which
the program interacts.
8. REFERENCES
[1] L. Ambrosio and P. Tilli. Topics on analysis in metric
spaces . Oxford University Press, 2004.
[2] L. Blum, M. Shub, and S. Smale. On a theory of
computation over the real numbers; np completeness,
recursive functions and universal machines (extended
abstract). In FOCS , 1988.[3] D. Bostic, W. P. Milam, Y. Wang, and J. A. Cook.
Smart vehicle baseline report.
http://vehicle.berkeley.edu/mobies, 2001.
[4] M. Bucker, G. Corliss, P. Hovland, U. Naumann, and
B. Norris. Automatic dierentiation: applications,
theory and implementations . Birkhauser, 2006.
[5] S. Chaudhuri, S. Gulwani, and R. Lublinerman.
Continuity analysis of programs. In POPL , pages
57{70, 2010.
[6] L. Chen, A. Min e, J. Wang, and P. Cousot. Interval
polyhedra: An abstract domain to infer interval linear
relationships. In SAS, pages 309{325, 2009.
[7] L. Chen, A. Min e, J. Wang, and P. Cousot. An
abstract domain to discover interval linear equalities.
InVMCAI , pages 112{128, 2010.
[8] P. Cousot, R. Cousot, J. Feret, L. Mauborgne,
A. Min e, D. Monniaux, and X. Rival. The ASTRE E
analyzer. In ESOP , pages 21{30, 2005.
[9] P. Cousot and N. Halbwachs. Automatic discovery of
linear restraints among variables of a program. In
POPL , pages 84{96, 1978.
[10] C. Dwork. Dierential privacy. In ICALP , 2006.
[11] E. Goubault. Static analyses of the precision of
oating-point operations. In SAS, pages 234{259,
2001.
[12] J. Halpern. Reasoning about uncertainty . The MIT
Press, 2003.
[13] D. Hamlet. Continuity in sofware systems. In ISSTA ,
2002.
[14] F. Iavernaro, F. Mazzia, and D. Trigiante. Stability
and conditioning in numerical analysis. Journal of
Num. Analysis, Industrial and Applied Math. ,
1(1):91{112, 2006.
[15] E. Lee. Cyber physical systems: Design challenges. In
ISORC , pages 363{369, 2008.
[16] R. Majumdar and I. Saha. Symbolic robustness
analysis. Real-Time Systems Symposium, IEEE
International , 0:355{363, 2009.
[17] R. Majumdar, I. Saha, and Zilong Wang. Systematic
testing for control applications. In Formal Methods
and Models for Codesign (MEMOCODE), 2010 8th
IEEE/ACM International Conference on , pages 1 {10,
2010.
[18] A. Min e. Relational abstract domains for the detection
of oating-point run-time errors. In ESOP , pages
3{17, 2004.
[19] S. Misailovic, D. M. Roy, and M. Rinard.
Probabilistically accurate program transformations. In
SAS, 2011.
[20] S. Misailovic, S. Sidiroglou, H. Homan, and
M. Rinard. Quality of service proling. In ICSE , 2010.
[21] The Parsec benchmark suite.
http://parsec.cs.princeton.edu, 2009.
[22] S. Pettersson and B. Lennartson. Stability and
robustness for hybrid systems. In Decision and
Control , pages 1202{1207, Dec 1996.
[23] Andreas Podelski and Silke Wagner. Model checking
of hybrid systems: From reachability towards stability.
InHSCC , pages 507{521, 2006.
[24] J. Reed, A. Aviv, D. Wagner, A. Haeberlen, B. Pierce,and J. Smith. Dierential privacy for collaborative
security. In Eurosec , 2010.
[25] J. Reed and B. Pierce. Distance makes the types grow
stronger: A calculus for dierential privacy. In ICFP ,
2010.
[26] S. Sidiroglou, S. Misailovic, H. Homan, and
M. Rinard. Managing performance vs. accuracy
trade-os with loop perforation. In FSE, 2011.
[27] G. Winskel. The formal semantics of programming
languages . The MIT Press, 1993.
[28] G. Zames. Input-output feedback stability and
robustness, 1959-85. IEEE Control Systems , 16(3),
1996.