Making OfÔ¨Çine Analyses Continuous
Kƒ±van√ß Mu¬∏ slu
 , Yuriy Brun
 , Michael D. Ernst
 , David Notkin
Computer Science & Engineering
 School of Computer Science
University of Washington University of Massachusetts
Seattle, WA, USA Amherst, MA, USA
{kivanc, mernst}@cs.washington.edu brun@cs.umass.edu
ABSTRACT
Developers use analysis tools to help write, debug, and understand
software systems under development. A developer‚Äôs change to the
system source code may affect analysis results. Typically, to learn
those effects, the developer must explicitly initiate the analysis. This
may interrupt the developer‚Äôs workÔ¨Çow and/or the delay until the
developer learns the implications of the change. The situation is
even worse for impure analyses ‚Äî ones that modify the code on
which it runs ‚Äî because such analyses block the developer from
working on the code.
This paper presents Codebase Replication, a novel approach to
easily convert an ofÔ¨Çine analysis ‚Äî even an impure one ‚Äî into a
continuous analysis that informs the developer of the implications
of recent changes as quickly as possible after the change is made.
Codebase Replication copies the developer‚Äôs codebase, incremen-
tally keeps this copy codebase in sync with the developer‚Äôs codebase,
makes that copy codebase available for ofÔ¨Çine analyses to run with-
out disturbing the developer and without the developer‚Äôs changes
disturbing the analyses, and makes analysis results available to be
presented to the developer.
We have implemented Codebase Replication in Solstice, an open-
source, publicly-available Eclipse plug-in. We have used Solstice to
convert three ofÔ¨Çine analyses ‚Äî FindBugs, PMD, and unit testing
‚Äî into continuous ones. Each conversion required on average 436
NCSL and took, on average, 18 hours. Solstice-based analyses
experience no more than 2.5 milliseconds of runtime overhead per
developer action.
Categories and Subject Descriptors:
D.2.6 [Software Engineering]: Programming Environments
D.2.3 [Software Engineering]: Coding Tools and Techniques
General Terms: Design
Keywords: Continuous analysis, Codebase Replication, Solstice
1. INTRODUCTION
Many program analysis tools exist that can inform developers
about the code they write. The sooner the developer learns the
implications of a code change, the more useful the feedback is; a
delay between making the change and learning the analysis result
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ESEC/FSE ‚Äô13, August 18‚Äì26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.can lead to wasted effort or confusion [1, 17, 24]. Ideally, the de-
veloper learns the implications of a change as soon as the change
is made. For example, modern IDEs, such as Eclipse and Visual
Studio, continuously compile the code and inform developers about
a compilation error as soon as the developer causes one. Similarly,
continuous testing informs the developer as soon as possible after a
change breaks a test [24], speculative conÔ¨Çict detection informs de-
velopers of conÔ¨Çicts soon after they commit their changes locally [5],
and speculative quick Ô¨Åx informs developers of the implications of
making compilation-error-Ô¨Åxing changes before the change even
takes place [19].
This paper introduces Codebase Replication, an approach that
enables a tool builder to easily convert an ofÔ¨Çine analysis that de-
velopers must run manually, into a continuous analysis that runs
constantly and always provides the developer with up-to-date results.
Our goal is not to make an analysis run faster nor incrementally,
but to run it more frequently and to simplify the developer‚Äôs work-
Ô¨Çow ‚Äî all without requiring a redesign of the analysis tool. This
allows developers to rely on the continuous analysis tool to notify
the developer if, and when, something relevant happens, instead
of the developer having to interrupt their work to run the analyses
and examine the results. These notiÔ¨Åcations may display analysis
results, indicate that potentially interesting information is available,
or cue other relevant analyses or tools to run.
Making an analysis continuous ‚Äî executing quickly after each
code change to identify problems in a timely manner ‚Äî is chal-
lenging. This explains why few continuous analyses exist, despite
their beneÔ¨Åts. Two major challenges are isolation andcurrency .
Isolation requires that the analysis should not prevent the developer
from making new changes, and that code changes made by an im-
pure analysis should alter the code neither visibly nor functionally
while the developer is working. Currency requires that an analysis
is optionally restarted and old results are marked as stale when the
developer makes an edit, and that analysis results are made available
as soon as the analysis completes.
We have addressed these challenges with Codebase Replication,
an approach that enables conversion of ofÔ¨Çine analyses ‚Äî even im-
pure ones ‚Äî into continuous analyses that inform the developer of
the implications of recent changes as quickly as possible after those
changes are made. Codebase Replication employs four principles
to overcome the challenges of isolation and currency: replication ‚Äî
keeping a separate, in sync copy of the program on which the anal-
ysis executes, buffer-level synchronization ‚Äî including the latest
changes in the analysis, exclusive ownership ‚Äî allowing analyses
to request exclusive write access to the program under analysis, and
invalidation detection ‚Äî identifying results made stale by new devel-
oper changes. We demonstrate Codebase Replication by converting
three previously ofÔ¨Çine analyses into continuous-analysis plug-insPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE‚Äô13 , August 18‚Äì26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2491460
323for Eclipse. Each plug-in uses the ofÔ¨Çine analysis internally.
The key idea underlying Codebase Replication is to create and
maintain a copy of the developer‚Äôs codebase. This allows the under-
lying ofÔ¨Çine analysis to run on the copy codebase without the devel-
oper‚Äôs changes affecting analysis execution. Further, if the analysis
needs to alter the copy codebase, it can do so without affecting the
developer‚Äôs codebase (and without distracting the developer). The of-
Ô¨Çine analysis can start quickly because the copy codebase is always
in sync; it does not need to make a fresh copy of the code before ex-
ecuting. If the developer edits the code while the analysis is running,
Codebase Replication allows the analysis to: terminate and restart
the ofÔ¨Çine analysis, so that the results are always accurate at the mo-
ment they are delivered; defer propagating the developer‚Äôs edits until
the analysis is Ô¨Ånished, so that the analysis can complete, in case the
results are useful even when a little stale; or complete the analysis
and use analysis-speciÔ¨Åc logic to invalidate parts of the results.
The main contributions of our work are:
The identiÔ¨Åcation of isolation andcurrency as challenges to
the creation of continuous analyses.
Codebase Replication: An approach to using a copy codebase
to meet the challenges with little overhead (~2.5 milliseconds
per developer action).
Solstice, an open-source, publicly-available implementation
of Codebase Replication within Eclipse.
Three new, publicly-available continuous-analysis Eclipse
plug-ins, each based on an existing analysis: FindBugs [14],
PMD [22], and unit testing.
An evaluation of the effort needed to create these plug-ins,
demonstrating that Solstice, and therefore Codebase Replica-
tion, signiÔ¨Åcantly reduces the programmer effort needed to
develop continuous-analysis Eclipse plug-ins.
A preliminary case study, in which one of the authors used a
Solstice-based continuous testing plug-in on a small program
(7 KLoC), showing that the plug-in is fast, stable, and useful.
Computing analysis results early and often means that more accu-
rate results are available sooner after the developer changes the code.
The results could be shown to the developer immediately to reduce
wasted time [1, 17, 24], or less frequently to avoid distracting and
annoying the developer [2]. Codebase Replication supports both.
The rest of this paper is structured as follows. Section 2 formally
deÔ¨Ånes continuous analysis. Section 3 introduces Codebase Repli-
cation and explains how it addresses the challenges of isolation
and currency for continuous analysis implementation. Section 4
introduces Solstice, a Codebase Replication implementation for
Eclipse. Section 5 evaluates Solstice‚Äôs performance and our expe-
rience implementing three proof-of-concept continuous analyses
with Solstice. Section 6 places our work in the context of related
research. Finally, Section 7 summarizes our contributions.
2. DEFINITIONS
In order to explain Codebase Replication, we Ô¨Årst deÔ¨Åne several
concepts, including what it means for an analysis to be continuous.
Asnapshot is the state of a software program at a point in time.
Ananalysis is a computation on a snapshot that produces a result.
AnofÔ¨Çine analysis is an analysis that requires no user input. A
continuous analysis is one that automatically computes an up-to-
date result without user intervention. Finally, a pure analysis is one
that does not modify the snapshot on which it runs, while an impure
analysis does. More formally:
DeÔ¨Ånition 1 (Snapshot) .Asnapshot is a single developer‚Äôs view of
a program at a point in time, including the latest Ô¨Åle contents from
unsaved editor buffers, if any, or from the disk otherwise.Each of a developer‚Äôs changes (e.g., made via an IDE) creates a
new snapshot.
In this paper, we limit ourselves to considering analyses that run
on a single developer‚Äôs codebase. Some analyses, e.g., conÔ¨Çict
detection [5, 6], may need multiple developers‚Äô codebases of the
same program. Our work is applicable to such analyses as well,
although the deÔ¨Ånition of a snapshot would need to be modiÔ¨Åed.
DeÔ¨Ånition 2 (Analysis) .Ananalysis is a function A:S!R, that
maps a snapshot s2Sto a result r2R:A(s) =r.
DeÔ¨Ånition 3 (OfÔ¨Çine analysis) .AnofÔ¨Çine analysis is an analysis
that requires no human input during execution.
As an example, a rename refactoring is not an ofÔ¨Çine analysis
because each execution requires specifying a programming element
(e.g., a variable), and a new name for this element. An ofÔ¨Çine
analysis may require human input for one-time setup, such as con-
Ô¨Åguration parameters or the location of a resource.
DeÔ¨Ånition 4 (Analysis implementation) .Ananalysis implementa-
tionIAis a computer program that, on input snapshot s, produces
r=A(s).
LetTIA(s)be the time it takes an analysis implementation IAto
compute Aon a snapshot s.
It is our goal to convert an ofÔ¨Çine analysis implementation IAinto
a continuous analysis implementation Ic
Athat executes IAinternally.
A user may edit the program faster than an analysis implementa-
tion is able to complete ‚Äî that is, faster than TIA(s). In this case, Ic
A
should be responsive to changes in the program and the completion
of the analysis in two ways: computing the analysis on the latest
snapshot, and notifying the developer that previous analysis results
are stale.
There are multiple policy choices for what Ic
Amay do in terms of
computing the analysis on the latest snapshot. For example, Ic
Amay
terminate IA, since it is running on a stale snapshot, and restart it on
the current snapshot. Or Ic
Amight permit IAto complete, to deliver
the results, even if somewhat stale. Other options include restarting
IAonly during a sufÔ¨Åciently-long pause in user edits, or computing
whether a speciÔ¨Åc user edit might affect the results (ignoring edits
to comments, for example).
Similarly, there are multiple policies Ic
Acould follow in notifying
the developer about possibly outdated results. For example, Ic
Acould
remove the possibly-stale results from developer‚Äôs view, or merely
mark them as stale. When an analysis completes the computation of
a new result, Ic
Acould display those results immediately, or could
delay to reduce churn and give users a chance to save work (such as
marking analysis results as inspected).
For simplicity of presentation, our deÔ¨Ånition of a continuous
analysis assumes the most eager policies. It could be extended to
accommodate other policy choices.
DeÔ¨Ånition 5 (e-continuous analysis implementation) .LetAbe an
ofÔ¨Çine analysis, and let tsbe the time at which snapshot scomes
into existence. An analysis implementation Ic
Athat uses IAise-
continuous if9ea;eiesuch that for all snapshots s, both of the
following are true:
1.Ic
Amakes r=A(s)available no later than ts+TIA(s) +eaif no
new snapshot is created before this time.
eais the analysis delay: the time it takes to terminate an
ongoing analysis (execution of IA), apply any pending edits to
the copy codebase, restart the analysis, and deliver the results
(e.g., to a UI or a downstream analysis).3242.For all times after ts+ei,Ic
Aindicates that all results for sand
snapshots prior to sare stale.
eiis the invalidation delay: the time it takes to invalidate the
displayed results after the moment they become stale.
We often refer to e-continuous analyses as simply continuous ,
implying that appropriately small eaand eiexist.
It is particularly challenging to convert an impure ofÔ¨Çine analysis
to a continuous analysis. Our approach handles both pure and
impure analyses.
DeÔ¨Ånition 6 (Pure analysis implementation) .An analysis imple-
mentation IAispure iff its computation on a snapshot sdoes not
alter s. An impure analysis implementation may alter s.
Running a test suite is an example of a pure analysis because
it does not alter the source code. Mutation analysis ‚Äî applying
a mutation operation to the source code and running tests on this
mutant ‚Äî is an impure analysis.
3. CODEBASE REPLICATION
Codebase Replication converts an ofÔ¨Çine analysis IAinto a con-
tinuous analysis Ic
Awhile addressing the two major challenges in
creating continuous analysis tools: isolation and currency. The
developer should be isolated from Ic
A:Ic
Ashould neither block the
developer nor change the code as the developer is editing it (which
could happen for an impure IA). Additionally, Ic
Ashould be isolated
from the developer: Developer edits should not alter the snapshot
in the middle of an IAexecution, potentially affecting the results.
Despite isolation between the developer and Ic
A, currency requires Ic
A
to react quickly to developer edits and to IAresults. Whenever the
developer makes an edit, Ic
Ashould be notiÔ¨Åed so that it can mark
old results as stale, terminate and restart IA, or take other actions.
Ic
Ashould react to Ô¨Åne-grained changes in the developer‚Äôs buffer,
without waiting until the developer saves the changes to the Ô¨Åle
system or commits them to a repository. Ic
Ashould also react quickly
toIAresults, making them promptly but unobtrusively available to
the developer or to a downstream analysis.
Most IDEs have a unique UI thread, so simply executing IAin a
continuous loop would block the developer from interacting with
the IDE whenever IAruns. Unless IAis nearly instantaneous, this
would render the IDE unusable. Running IAin a separate thread
requires synchronizing with the UI thread, which may interact with
the code and may still block the developer. As a consequence, and to
our best knowledge, none of the existing continuous analysis tools
follow this approach, and neither does Codebase Replication.
Codebase Replication addresses the isolation challenge of convert-
ingIAintoIc
Aby creating, and maintaining, a copy of the developer‚Äôs
codebase. The goal of this copy codebase is to provide a stable
snapshot for IAto use without affecting the developer, and without
being affected by the developer. Codebase Replication addresses the
currency challenge by providing notiÔ¨Åcations for events that occur
in the developer‚Äôs IDE and in Ic
A; these events can trigger terminating
and restarting IAand updating the UI.
Figure 1 shows Codebase Replication‚Äôs high-level overview. The
IDE API generates events for all developer actions, including devel-
oper‚Äôs changes to the code. Codebase Replication keeps a queue of
these events, and applies them to the copy codebase. Meanwhile,
Ic
Acan pause the queue, run IAon the copy snapshot, compute IA
results, resume the queue, and modify the developer‚Äôs editor UI
based on the results. Codebase Replication also notiÔ¨Åes Ic
Aabout
new developer actions, so that Ic
Amay decide to interrupt, alter, or
continue IA‚Äôs execution.
Figure 1: A high-level Codebase Replication overview. Code-
base Replication (turquoise) facilitates communication between Ic
A
(green) and a developer‚Äôs IDE (purple) via asynchronous events.
Codebase Replication supports multiple Ic
Ausing the same copy
codebase, managing locks and parallel execution. However, in this
paper, for exposition, we focus on the simpler case of a single Ic
A
running at a time.
Codebase Replication employs four principles to overcome the
challenges of isolation and currency:
1.Replication: Instead of running IAdirectly on the developer‚Äôs
snapshot, Codebase Replication provides a separate copy of the
snapshot by maintaining an in-sync copy of the codebase. This
ensures that the developer‚Äôs codebase is never affected by IA. This
principle is based on the idea of sandboxing. If IAmodiÔ¨Åes the
copy snapshot, or crashes in the middle of the execution, the effects
are conÔ¨Åned to the copy, and the developer may continue to edit
unaffected by the modiÔ¨Åcations and crashes. Further, this approach
separates the UI logic from the analysis logic, which is a good
design principle that improves the tool‚Äôs maintainability.
2.Buffer-level synchronization: One of the goals of Ic
Ais to
provide feedback on the latest possible snapshot. This snapshot
often resides in the IDE buffer, and not on disk. Unfortunately,
most existing IAexecute on Ô¨Åles or even on binaries. Codebase
Replication synchronizes the copy snapshot with the developer‚Äôs
IDE‚Äôs unsaved buffers, allowing IAto run on the latest snapshot, or
binary compiled from that snapshot, without without affecting the
developer‚Äôs buffer, Ô¨Åles, and binaries.
Some IAare incremental, computing results based on code changes
since the last snapshot, as opposed to on an entire snapshot. For most
IA, creating an incremental version presents a signiÔ¨Åcant obstacle,
and amounts to developing a brand new IA. Codebase Replication‚Äôs
goal is to minimize the cost of building Ic
Aby allowing developers to
create continuous tools by using existing IAimplementations with-
out modifying or redesigning those implementations. While easing
the process of building Ic
A(Section 5.2 will empirically evaluate the
effort required to develop Ic
Ausing a prototype implementation of
Codebase Replication), we should note that one disadvantage of
Codebase Replication over developing incremental IAis the extra
runtime overhead incurred by listening for buffer changes, identi-
fying and discarding duplicated Ô¨Åle system changes, and detecting
discarded buffers. Meanwhile, the incremental approach needs to
only listen for Ô¨Åle system changes. Nevertheless, Section 5.1 will
show that for our prototype Codebase Replication implementation,
this overhead is no more than 2.5 milliseconds per developer action.
3.Exclusive ownership: Most IAassume the snapshot does not
change while they execute. Thus, changing the snapshot in the325Figure 2: High-level Solstice overview. Eclipse (purple) generates events for developer actions, including edits. Solstice Server (turquoise)
listens for these events, serializes them and sends them to Solstice Client (turquoise), and notiÔ¨Åes Ic
Aof the actions. Solstice Client
stores these actions temporarily in the event queue, deserializes them, applies the edits to the copy workspace, notiÔ¨Åes Ic
Aof these actions, and
provides pause-resume API for managing the exclusive ownership of the copy workspace. An example Ic
A(green) interacts with the developer‚Äôs
editor, Solstice, and the copy workspace by: Analysis Client runs IAon the copy workspace, generates and serializes the results, and
sends those results to Analysis Server .Analysis Server deserializes the results, modiÔ¨Åes developer‚Äôs editor accordingly, and implements
invalidation logic.
middle of an execution may cause IAto crash or fail in other ways.
The situation is worse if multiple IArun on the same code at once,
and at least one of them is impure. Codebase Replication allows
oneIc
Aat a time to claim exclusive write access to a copy snapshot
while its IAexecutes, pausing all other analyses and synchronization
updates with the developer‚Äôs buffer. This allows IAto complete with
expected behavior.
4.Invalidation detection: Developer‚Äôs changes may invalidate
theIAresults on an old snapshot. If the change occurs while IA
executes, the result may already be invalid by the time IAcompletes.
Codebase Replication allows Ic
Ato terminate IA, or to let if Ô¨Ånish
and to examine the change to determine whether the results, or parts
of the results are valid.
These principles allow Codebase Replication to convert IAinto
Ic
Awhile ensuring isolation and currency. Multiple Ic
Acan use a
single copy snapshot, amortizing the already-low overhead (see
Section 5.1). Multiple impure Ic
Acan each take turns exclusively
owning the copy snapshot to provide fast, accurate results with
buffer-change-level precision. The changes the impure IAmake to
the copy snapshot remain completely hidden from the developer‚Äôs
copy. (Codebase Replication does require Ic
Ausing impure IAto
implement a mechanism to revert the IAchanges, and the correctness
of the copy synchronization is only guaranteed if the reverting works
properly. However, most impure IAalready implement this logic.
For those that do not, since the copy codebase issaved on the Ô¨Åle
system, Ic
Acan implement a simple revert mechanism using version
control. Embedding such a mechanism in Codebase Replication is
future work.)
Finally, we impose three performance requirements on Codebase
Replication: First, Codebase Replication must have nearly negligi-
ble computational overhead in maintaining the copy codebase. Ic
A
is already computation intensive, and Codebase Replication should
not consume more of that resource. Second, the copy codebase
should be synchronized with the developer‚Äôs codebase as quickly as
possible, to facilitate IAexecuting on the most up-to-date version
of the code. Third, Codebase Replication should be easy to use tocreate Ic
Avia a comprehensive API. Section 5 will revisit how well
our implementation satisÔ¨Åes these requirements.
4. SOLSTICE: CODEBASE REPLICATION
FOR ECLIPSE
To evaluate Codebase Replication, we have built Solstice, an
Eclipse-based, open-source prototype. Solstice is publicly-available
at https://bitbucket.org/kivancmuslu/solstice. This section describes
Solstice (Section 4.1), explains how to implement continuous anal-
ysis tools using Solstice (Section 4.2), and then demonstrates one
such implementation with an example (Section 4.3). Later, Sec-
tion 5.2 will describe our experience using Solstice to develop three
continuous analysis tools.
4.1 Solstice Implementation
This section explains the Solstice implementation, reÔ¨Ånes Code-
base Replication with Eclipse-speciÔ¨Åc concerns, and discusses Sol-
stice design choices.
Figure 2 details Solstice‚Äôs architecture, and an example Solstice-
based continuous analysis tool. Solstice consists of two main parts:
Solstice Server runs on developer‚Äôs Eclipse and is responsible
for listening to the developer actions. Solstice Client runs on
a background copy of Eclipse and is responsible for keeping the
copy codebase in sync and managing the ownership of the copy
codebase. Solstice-based continuous analysis tools use Solstice
Client for their computation logic and Solstice Server for their
visualization logic and to interact with the developer.
The Eclipse API allows each instance of Eclipse to be associated
with (and have access to) only one workspace. Solstice manages
two copies of Eclipse running at once: The developer‚Äôs normal copy
of Eclipse manages the developer‚Äôs workspace ( Solstice Serv-
erdeals with this workspace), and a second, background copy of
Eclipse runs Solstice Client and maintains the copy workspace
(and with it, the copy codebase). The background Eclipse is headless
‚Äî it has no UI elements and the developer never sees it. The copy
workspace also resides in a hidden folder on disk. That folder name326includes a hash of the absolute path to the developer‚Äôs workspace,
to guarantee uniqueness, with high probability.
Each time the developer starts Eclipse, Solstice executes an ini-
tialization protocol that blocks the developer and makes sure that
the copy workspace is in sync with the developer‚Äôs workspace be-
fore the development begins. First, Solstice Client connects
toSolstice Server through localhost. Then, the initialization
synchronization protocol executes. The Ô¨Årst time the developer
uses Solstice, initialization synchronization protocol acts as a full
synchronization and creates a complete copy of the developer‚Äôs
workspace on disk. The future executions, on the other hand, only
verify the integrity of the Ô¨Åles in the copy workspace through check-
sums, and update the Ô¨Åles that are added, removed, or changed in
the developer‚Äôs workspace outside the IDE.
After the initialization synchronization protocol, Solstice Serv-
erattaches multiple listeners (see Figure 2) to the developer‚Äôs
Eclipse to keep track of all developer‚Äôs events: actions and ed-
its to the source code. Currently, in addition to all edits developers
make to the code, Solstice listens to the following developer actions:
current cursor location, current selected Ô¨Åle, current selected Eclipse
project, invocations of Quick Fix, the proposals offered for a Quick
Fix invocation, and selected Quick Fix proposals and completions
and cancellations of Quick Fix. Solstice Server catches the de-
veloper‚Äôs events, serializes them, and sends them to the Solstice
Client , which, in turn, deserializes the incoming events, makes
them available to the continuous analysis tool through simpliÔ¨Åed
observer patterns, and applies developer edits to the copy workspace.
Solstice Client keeps track of all developer edits ‚Äî through the
events sent by Solstice Server ‚Äî and applies them to the copy
workspace in the order they are generated, guaranteeing that the de-
veloper‚Äôs workspace will always be in sync with the copy workspace,
with the exception of the events currently being processed.
Instead of the localhost connection, Solstice could use either
the Java Remote Method Invocation (RMI)1or the Ô¨Åle system for
Solstice Server andSolstice Client to communicate. RMI
abstracts away the underlying networking protocol, which can al-
low for a cleaner design. Meanwhile, using the Ô¨Åle system enables
higher Ô¨Çexibility for the serialization and communication protocols,
but requires these inter-process protocols to be implemented from
scratch. Solstice (see architecture in Figure 2) has two requirements
for inter-process communication: (1) the ability to send messages
(events) between the components running on different Eclipses, and
(2) the Ô¨Çexibility of pausing and resuming event processing (for
exclusive ownership) within a component. Localhost connection
abstracts the underlying inter-process communication protocol, and
gives Solstice the Ô¨Çexibility to implement the event-based execution
‚Äî with the ability to pause and resume the event queue ‚Äî immedi-
ately over the Java networking layer. As a result, Solstice and the
continuous analysis tool can completely abstract away the underly-
ing event-based execution, leading to a cleaner logic. We chose to
use the localhost connection mechanism because of the combination
of abstraction and Ô¨Çexibility it provides.
4.2 Building Solstice-Based Tools
This section explains how to use Solstice to build a continuous
analysis tool Ic
Abased on an ofÔ¨Çine analysis implementation IA. We
refer to the author as the person developing Ic
A, and to the developer
as the person later using Ic
A.
To implement Ic
A, the author has to accomplish three tasks: sep-
arate the Ic
Acomputation and interaction logic, formalize the Ic
A
communication, and write the result-invalidation logic.
1http://www.oracle.com/technetwork/java/javase/tech/index-
jsp-136424.htmlFirst, the author needs to separate Ic
Acomputation logic ‚Äî how IA
runs and produces results ‚Äî and interaction logic ‚Äî how Ic
Ashows
results and interacts with the developer. The computation logic
is implemented as a Solstice Client extension, represented as
Analysis Client in Figure 2. The interaction logic is implemented
as aSolstice Server extension, represented as Analysis Server
in Figure 2. The same way Eclipse manages the life-cycle of its
extending plug-ins, Solstice manages the life-cycle of the extending
Ic
A: they start after Solstice starts (when the developer opens Eclipse)
and terminate before Solstice terminates (when the developer closes
Eclipse). The author does not need to create and manage a thread
forIc
Aas Solstice takes care of these low-level details. The computa-
tion logic always runs on the background Eclipse and on the copy
workspace, and the interaction logic always runs on the developer‚Äôs
Eclipse and workspace. For the rest of the section, we assume that
Ic
Ainteracts with the developer. Continuous analysis tools that do
not interact with the developer (e.g., observational Ic
Athat only log
developer actions), do not need a Solstice Server component as
Solstice Client duplicates all developer edits and Ic
Acan access
all those events directly from Solstice Client via listeners.
Next, the author needs to formalize the communication between
Analysis Client andAnalysis Server . The analysis results gen-
erated by Analysis Client need to be sent to Analysis Server
to be displayed to the developer, as shown in Figure 2. However,
the communication does not have to be one-sided (although the
example communication shown in Figure 2 is one-sided). For ex-
ample, the Analysis Server can allow the developer to modify
Ic
Asettings, which it would then send to the Analysis Client . As
theAnalysis Client and the Analysis Server run on different
Eclipses, all communication between them occurs through serializ-
able objects. Solstice provides wrappers that reduce the inter-process
communication code. The author needs to implement the analysis
logic, via the runAnalysis(..) method that returns a serialized
AnalysisResult object, which is then transparently sent to Anal-
ysis Server . The sent object arrives as an event, received via the
processAnalysisResult(..) method.
Finally, the author needs to write the logic for invalidating an IA
result based on developer edits. Solstice timestamps every developer
action and edit, IAstart, and IAÔ¨Ånish, to ensure that no event is
lost and that Solstice knows exactly to which snapshot an IAresult
applies. Using these timestamps transparently, Analysis Client
may either kill the ongoing IAcomputation and start a new one
‚Äî after applying the developer edits to the copy workspace ‚Äî or
allow the current IAcomputation Ô¨Ånish, possibly producing stale
results. The Analysis Server may erase the current IAresults or
mark them as stale. For common scenarios, such as clearing IA
results with each developer edit, Solstice provides built-in APIs
that reduce the code that needs to be written for keeping track
of developer changes. For example, if Ic
Awants to immediately
invalidate IAresults after all source code changes, that Ic
Aneeds to
only implement the EditInvalidator.invalidate(..) method.
In contrast, without Solstice, to get the same outcome through pure
Eclipse API, Ic
Awould need to implement one IResourceChange-
Listener to keep track of the resources being added and deleted,
oneIDocumentListener for the current editor Ô¨Åle to keep track of
the buffer changes, and one IPartListener to keep track of the
current editor when using Eclipse API. At the very least, a complete
implementation without Solstice would require implementing nine
methods. Finally, the implementation needs to process these events
and decide whether the current event invalidates the results. For
example, each keystroke generates a DocumentEvent , which should
invalidate the results. However, when the developer saves the current
Ô¨Åle, it generates a ResourceChangedEvent , which needs to be327ignored as it is already subsumed by the previous DocumentEvent s.
Solstice takes care of all these low-level details.
4.3 Example Solstice Usage
Suppose an author wants to use Solstice to build an Ic
Ausing an IA.
For simplicity, the author decides that when the developer makes a
change while IAexecutes, IAmight as well Ô¨Ånish, but Ic
Ainvalidates
stale results and does not display them to the developer.
The author would have to write the following interaction logic
forIc
A(Analysis Server ):
class Server extends AnalysisServer {
public Server() {
super (true );
}
void processAnalysisResult(AnalysisResult r) {
// Update results.
}
}
// Invalidation logic
class Invalidator extends EditInvalidator {
void invalidate() {
// Invalidate results.
}
}
Server passes true toAnalysisServer , which represents that Ic
A
only wants to process recent IAresults. Solstice pre-processes all IA
results received from Analysis Client , compares their timestamps
with the current timestamp, and only propagates the recent results
toprocessAnalysisResult(..) .
The author would also have to write the following computation
logic for Ic
A(Analysis Client ):
class Analysis extends ResourceBasedAnalysis {
AnalysisResult runAnalysis() {
AnalysisResult result = // compute the result.
return result;
}
}
Analysis extends ResourceBasedAnalysis , which tells Solstice
to call resumeAnalysis(..) each time it processes an event that
modiÔ¨Åes the copy workspace. The resumeAnalysis(..) call is
a no-op while IAis running. However, when IAis paused, invok-
ingresumeAnalysis(..) wakes up the Ic
Athread, which even-
tually calls Solstice.pause(..) ,runAnalysis(..) , and Sol-
stice.resume(..) . The author does not need to do anything
special to manage the exclusive ownership of the copy; Solstice
manages that transparently.
5. EV ALUATION
To evaluate Solstice, we empirically measured its performance
overhead (Section 5.1), observed the ease of using Solstice while
implementing three proof-of-concept continuous analysis tools (Sec-
tion 5.2), and compared Solstice to other methods of implementing
IDE-integrated continuous analyses (Section 5.3).
5.1 Solstice Performance Evaluation
To be effective, Solstice has to meet the following requirements:
R1: The start up time should not block the developer for an unrea-
sonable amount of time.
R2: The overhead to synchronizing developer actions with the copy
codebase should be close to zero.Workspace Codebase Sync Time (ms)
Content Size (MB) KLoC KNCSL Full Inc.
CrosswordSage 1.3 3.6 3.1 131 133
Asmx 11 43 26 611 292
V oldemort 28.4 160 115 1,809 656
JDT 176 1,890 1,362 2.9 m 6.9 s
Figure 3: Solstice initial synchronization protocol performance.
Each cell is the mean of 20 experimental executions. Full synchro-
nization starts with an empty copy workspace, whereas incremental
synchronization starts with an in-sync copy codebase, and Solstice
only veriÔ¨Åes the copies are in-sync.
R3: While using the IDE, the developer should experience negligi-
ble delay in performing actions.
This section presents the results of Solstice performance experiments
addressing these three requirements. We ran all experiments on a
modern laptop (MacBook Pro, i7 2.3 GHz quad core, 16 GB RAM,
SSD); Solstice ran with 512 MB RAM limitation for each of the
server and client applications.
5.1.1 Initial Synchronization Protocol Cost
As Section 3 explained, when the IDE starts, Solstice needs to
either install Ô¨Åle-system-level resource listeners, or go through an
initial synchronization protocol to make sure that the copy codebase
and the developer‚Äôs codebase are in sync. Without this precaution,
if the developer (or some other application) modiÔ¨Åes the codebase
when the IDE is not running, the copy codebase would become
out-of-sync. Solstice makes the latter choice (recall Section 4). To
satisfy requirement R1, the blocking incurred by the initial synchro-
nization protocol must be reasonable.
We have tested Solstice‚Äôs initial synchronization protocol on four
different workspace settings (Figure 3). For each setting, we created
a workspace with one program (a program may consist of many
Eclipse projects; for example, JDT consists of 50), and invoked
the initial synchronization protocol for two extreme cases: full and
incremental. In the full case, the copy workspace is empty, which
requires Solstice to copy the entire workspace. In the incremental
case, the copy workspace is already in-sync, which requires Solstice
to only verify that the copies are in-sync with checksums. We
expect the most common use case to resemble the incremental case,
with the full case only applying on the Ô¨Årst time the developer runs
Solstice. Figure 3 shows that Solstice has negligible overhead for
small programs: CrosswordSage [8], asmx2, and V oldemort [32].
Even for large programs, such as JDT, Solstice‚Äôs incremental
synchronization overhead is several (6.9) seconds, which we believe
to be reasonable, considering JDT3has ~10K Ô¨Åles. However, for
even larger programs, the incremental synchronization may become
an issue. It is possible to make the initial synchronization protocol
lazy, only processing the active Eclipse project and its dependencies.
For industrial products composed of many Eclipse projects, this
approach would block the developer for only a few seconds each
time the developer changes which project is active, and only once
for each project per IDE restart. Consequently, amortizing the
incremental synchronization cost for the workspace to independent,
smaller components would improve the developer experience. We
leave this improvement to future work.
5.1.2 Synchronization Overhead
2Extended asm, a byte code manipulator: http://asm.ow2.org
3Our JDT evaluation includes four products: eclipse.jdt.core,
eclipse.jdt.debug, eclipse.jdt, and eclipse.jdt.ui328Operation Initial File IDE Sync
Name Size Size (chars) Overhead (ms) Delay (ms)
Text
Insert10 1.0 1.5
100 1.1 1.8
1,000 1.1 1.7
10,000 2.4 1.9
1000 1.2 1.7
100 1.0 2.0
1,000 1.1 2.1
10,000 2.3 2.5
Text
Delete11 0.8 1.5
101 1.1 1.8
1,001 1.2 1.6
10,001 2.5 1.7
1001 0.8 1.6
101 1.1 1.9
1,001 1.1 2.1
10,001 2.3 2.4
Text
Edit1100 1.0 1.7
1,000 1.0 1.9
10,000 2.2 2.2
100100 0.9 1.9
1,000 1.0 1.9
10,000 2.2 2.2
Text Edit Summary 2:52:5
File
Add1
1,0001.2 1.1
100 102 157
1,000 1,464 1,305
File
Remove1
1,0000.5 1.4
100 56 106
1,000 566 2,491
File Edit Summary grows linearly with size
Figure 4: The Solstice-induced overhead on developer edits for
keeping the copy workspace in-sync. Text operations of size 1 are
single keystrokes, and text operations of size 100 represent cut, paste,
and tool applications, such as applying a refactoring. File operations
of size 1 are manual Ô¨Åle generation, copy, and removal, and Ô¨Åle
operations of size 100 and 1,000 represent copying, removing, or
importing a directory or an entire Eclipse project. ‚ÄúIDE Overhead‚Äù
measures the overhead imposed on the responsiveness of the IDE,
and ‚ÄúSync Delay‚Äù measures the delay before the copy workspace
to be up-to-date. Text operations are means over 20,000 executions.
File operations are means over 200 executions.
To satisfy requirement R2, and to allow Ic
Ato access the most
recent version of the developer‚Äôs code, Solstice must quickly syn-
chronize the copy workspace. Figure 4 shows the delay Solstice
incurs during synchronization for the most common developer op-
erations. Except for importing and deleting large Eclipse projects,
synchronization takes no more than 2.5 milliseconds. Thus, Solstice
provides Ic
Aaccess to the developer‚Äôs code that is no more than 2.5
milliseconds old. Since importing and deleting large Eclipse projects
is fairly rare, and the operations already take several seconds for
Eclipse to execute, the Solstice delay should be acceptable.
5.1.3 Developer Action Delay
As Solstice keeps track of all developer changes at the buffer
level, it listens to each keystroke. To satisfy requirement R3, it is
important that the overhead and delay experienced by the developer
are close to zero so the developer is not adversely affected by Sol-stice. Figure 4 shows, for the most common developer actions, the
IDE overhead that Solstice introduces when the action is initiated
programmatically. One of the most common developer actions is
editing a Ô¨Åle with keystrokes. Figure 4 represents such text edits as
size 1. The IDEs also support complex operations, such as refactor-
ing, auto-complete, etc. that execute multiple edits at once. Figure 4
represents such text edits as size 100. The results show that the
overhead is independent of the edit size, and even for large Ô¨Åles
(10,000 characters), the overhead is no more than 2.5 milliseconds.
Manually adding and removing Ô¨Åles to an Eclipse project are
represented as 1-, 100-, and 1,000-sized Ô¨Åle operations. Results
suggest that the overhead for Ô¨Åle operations increase linearly with
operation size, as expected. Removals are faster than additions, and
even for large operations, the overhead never exceeds a few seconds.
Since Eclipse already takes several seconds to import a project with
1,000 Ô¨Åles, the results suggest that Solstice introduces negligible
IDE overhead.
Our performance analysis demonstrates that Solstice introduces
negligible overhead to the IDE, almost never interrupts the develop-
ment process ‚Äî except during the initial synchronization protocol ‚Äî
and provides access to a recent copy codebase with negligible delay.
5.2 Solstice Usability Evaluation
We have used Solstice to build three proof-of-concept Ic
AEclipse
plug-ins, each using one of three existing IAimplementations. This
section describes these implementations and reports on our expe-
rience. Sections 5.2.1, 5.2.2, and 5.2.3 describe the continuous
FindBugs, the continuous PMD, and the continuous testing plug-
ins, respectively. Figure 5 summarizes the implementation and
evaluation details of each plug-in.
5.2.1 Continuous FindBugs
FindBugs is a static analysis tool that Ô¨Ånds common developer
mistakes and bad practices in Java code, such as incorrect bitwise
operator handling, and incorrect casts. FindBugs has found bugs in
open-source software, is useful to developers, and is extensible with
new bug patterns [14]. It is available as a command-line and a GUI
tool, an ant task extension, and an Eclipse plug-in [11].
The FindBugs ant task extension and Eclipse plug-in can automate
FindBugs invocations but both fall short of being e-continuous
(recall DeÔ¨Ånition 5 in Section 2): The ant task extension executes
only with each ant build. Meanwhile the plug-in has a setting to run
whenever Eclipse‚Äôs incremental build runs, which typically happens
when the developer saves the Ô¨Åle, and analyzes only that saved Ô¨Åle.
Both tools require the developer to perform an action to run, either
execute the build script or save a Ô¨Åle, and neither reacts to changes
made only to the buffer. Further, since changes to one Ô¨Åle may affect
the analysis results of another, a Solstice-based implementation may
Ô¨Ånd warnings missed by the FindBugs plug-in.
We have used Solstice to build a proof-of-concept, continuous
FindBugs Eclipse plug-in [29]. The plug-in uses the command-line
FindBugs to analyze the .class Ô¨Åles for all the classes in the currently
active Eclipse project, and of all the libraries on which they depend.
The plug-in‚Äôs simple visualization displays the FindBugs warnings
in an Eclipse view4, which is a conÔ¨Ågurable window similar to the
Eclipse Console. The plug-in invalidates the warnings whenever the
developer makes an edit or makes another project active. Figure 6
shows two continuous FindBugs plug-in screenshots, one before
(left) a developer makes a change that removes a FindBugs warning,
and one (right) after.
4http://help.eclipse.org/topic/org.eclipse.platform.doc.isv/
reference/extension-points/org_eclipse_ui_views.html329AnalysisLines of Code Dev. Evaluation Subject Program Analysis ea ei
UI IPC Core Other Total Time Name Version KLoC KNCSL Runtime (ms) (ms)
FindBugs 196 39 138 16 389 25 hoursV oldemort 1.1.2 160 11558.6 s 59 2
PMD 226 37 110 18 391 4 hours 8.7 s 67 2
Testing 297 136 327 18 778 25 hours Commons CLI 1.3 10.5 5.8 294 ms 56 3
Figure 5: Summary of three Solstice-based proof-of-concept tools. Each tool consists of ‚ÄúUI‚Äù code for result visualization and pretty printing,
‚ÄúIPC‚Äù code for serialization, ‚ÄúCore‚Äù code for setting up and running the IA, and ‚ÄúOther‚Äù code for extension points. PMD IAuse is similar to
FindBugs, and PMD Ic
Awas implemented after FindBugs Ic
A, which led to a signiÔ¨Åcant reduction in development time. In calculating evalues,
we used PMD‚Äôs java-basic ruleset and all of Commons CLI‚Äôs 361 tests. Each evalue is the max observed value over at least 10 executions.
Figure 5 summarizes the implementation and evaluation details
for the continuous FindBugs plug-in. The implementation is fewer
than 200 LoC, excluding the code for visualization. It is also e-
continuous, with empirically computed values: ea=59milliseconds
and ei=2 milliseconds.
5.2.2 Continuous PMD
PMD [22] is a static Java source code analysis that Ô¨Ånds code
smells and bad coding practices, such as, unused variables and empty
catch blocks. It is available for download as a standalone executable,
and as plug-ins for several IDEs, including Eclipse. Like FindBugs,
it is popular, and well maintained. Unlike FindBugs, PMD works
on source code, and applies different kinds of analyses. The existing
Eclipse plug-in is not continuous; the developer must right-click on
a project and run PMD manually.
We have used Solstice to build a proof-of-concept, continuous
PMD Eclipse plug-in [30]. The plug-in uses the command-line
PMD to analyze the .java Ô¨Åles for the currently active Eclipse
project. The plug-in‚Äôs simple visualization displays the PMD results
in an Eclipse view. The plug-in invalidates the results whenever the
developer makes an edit or makes another project active. Figure 7
shows two continuous PMD plug-in screenshots, one before (left) a
developer makes a change that removes a PMD warning, and one
(right) after.
Figure 5 summarizes the implementation and evaluation details
for the continuous PMD plug-in. The implementation is fewer
than 200 LoC, excluding the code for visualization. It is also e-
continuous, with empirically computed values: ea=67milliseconds
and ei=2 milliseconds.5.2.3 Continuous Testing
Continuous testing uses otherwise idle CPU cycles to run tests to
let the developer know as soon as possible when a change breaks
a test. Continuous testing can reduce development time up to
15% [24]. There are Eclipse [27] and Emacs plug-ins for continuous
testing. The Eclipse plug-in modiÔ¨Åes Eclipse core plug-ins, making
it difÔ¨Åcult to update the implementation for new Eclipse releases;
in fact, the plug-in does not support the recent versions of Eclipse.
By contrast, Solstice requires no modiÔ¨Åcations to the Eclipse core
plug-ins and would apply across many Eclipse versions.
We have used Solstice to build a proof-of-concept, continuous test-
ing Eclipse plug-in [31]. The plug-in runs the tests of the currently
active Eclipse project, and invalidates the test results whenever the
developer makes an edit. The plug-in‚Äôs simple visualization displays
the test results in an Eclipse view. Figure 8 shows two continuous
testing plug-in screenshots, one before (left) a developer makes a
change that breaks a test, and one (right) after.
Figure 5 summarizes the implementation and evaluation details
for the continuous testing plug-in. The implementation is fewer
than 500 LoC, excluding the code for visualization. It is also e-
continuous, with empirically computed values: ea=56milliseconds
and ei=3 milliseconds.
5.2.4 Solstice Continuous Testing Case Study
One of the authors used the Solstice continuous testing plug-in
(Solstice CT) in a personal B IBTEX management project, consisting
of 7 Java KLoC. Before starting using Solstice CT, the project was
exhibiting RuntimeException crashes on a speciÔ¨Åc input. The case
study took place while removing the bug that was resulting in this
crash by writing tests and using Solstice CT. The bug turned out to
Figure 6: Continuous FindBugs running on V oldemort. Both images show the top four warnings. The left screenshot shows the original
V oldemort implementation; its Ô¨Årst FindBugs warning suggests that .equals(..) is too restrictive. The developer changes .equals(..)
with instanceof (right screenshot) and the top warning disappears without the developer saving the Ô¨Åle or invoking FindBugs.330Figure 7: Continuous PMD running on V oldemort. Both images show the top four warnings. The left screenshot shows the original V oldemort
implementation; its second PMD warning suggests that the parentheses around neware unnecessary. The developer removes these parentheses
(right screenshot) and the second warning disappears, without the developer saving the Ô¨Åle or invoking PMD.
be signiÔ¨Åcant and required an extension to the project‚Äôs architecture
and writing more than 100 LoC. The case study lasted for 3 days
and resulted in a successful removal of the bug.
At the start of the case study, the subject program had no tests.
The author wrote two tests: a regression test to validate that nothing
was broken while Ô¨Åxing the bug, and another test for the failing
input to observe the presence of the bug. The case study led to the
following 3 observations:
1.Solstice CTcan speed up discovering unknown bugs: The
subject program parsed several Ô¨Åles, speciÔ¨Åed as program argu-
ments. When the speciÔ¨Åed path did not exist, the program threw a
FileNotFoundException . This behavior made the program frag-
ile, crashing on invalid or improperly formatted arguments, instead
of failing gracefully. This bug was unknown prior to the case study.
The author discovered this bug early, right after starting implement-
ing the regression test, by initially entering an invalid path and
before encoding the rest of the test. This intermediate step during
writing the test caused the regression test to fail with a FileNot-
FoundException . Consequently, the author was able to detect and
Ô¨Åx this bug immediately, as opposed to after implementing the entire
test. Because the test needed to encode the expected output, and that
output was large, Solstice CTcaused the bug to be discovered much
earlier than it would have been through traditional testing.
2.Solstice CTmakes debugging information available sooner:
While debugging, developers often use print statements to view the
intermediate program state and assist in understanding the behavior
of faulty executions. Based on self-discovered feedback during
this case study, we augmented Solstice CTto make the continuous
testing console output and error streams available to the developer.
As a result, the developer was able to get near-instant feedback on
how changes to the code affected the print statements, even if the
changes did not affect the test result. The author felt this information
signiÔ¨Åcantly simpliÔ¨Åed the debugging task.
3.Solstice CTis unobtrusive: In the course of this, albeit small
case study, the author never experienced a noticeable slowdown in
Eclipse‚Äôs operation and never observed a stale or wrong test result.
5.3 Discussion
There are ways other than maintaining a copy codebase to convert
ofÔ¨Çine analyses into continuous ones. Very fast ofÔ¨Çine analyses
can run in the IDE‚Äôs UI thread. While technically, such an analysis
would block the developer, because of its speed, the developer would
never notice the blocking. Of course, having a negligible running
time is infeasible for many analyses.
It is possible to reduce the running time of ofÔ¨Çine analyses by
making them incremental [23]. An incremental code analysis uses
the analysis result on an earlier snapshot of the code and the editsmade since that snapshot. There are many examples for incremen-
tal analyses, such as differential static analyses [18], differential
symbolic checking [21], and incremental checking of data structure
invariants [28]. When the differences are small, incremental analy-
ses can be signiÔ¨Åcantly faster. With this speed increase, incremental
analyses may be used continuously by blocking the developer when-
ever the analysis runs. Incremental code compilation [17] is one
such popular incremental, continuous analysis integrated into many
IDEs. However, many analyses cannot be made incremental efÔ¨Å-
ciently because small code changes may force these analyses to
explore large, distant parts of the code. Further, making an analysis
incremental can be challenging, requiring a complete analysis re-
design. The process is similar to asking someone to write a greedy,
efÔ¨Åcient algorithm that solves a problem for which only an inefÔ¨Å-
cient algorithm that requires global information is known. For some
such analyses (e.g., analyses that solve NP-complete problems), this
task is likely impossible (unless P=NP).
While many analyses cannot be made incremental or efÔ¨Åcient
enough to run continuously while blocking the developer, those
that can still beneÔ¨Åt from being built using Solstice. An impure
analysis is freed from the burden of maintaining a copy codebase
manually, or through working copies, as Solstice maintains the
copy codebase and lets the analyses own it exclusively. For many
analyses, the slightly stale results of recent development snapshots
are useful. For example, the test results of a development snapshot
from several minutes ago could help the developer realize a test
failure that otherwise would not surface until the next scheduled
test run. For such, slow analyses, Solstice allows processing recent
snapshots and producing results, whereas other approaches would
invalidate the result with every edit.
6. RELATED WORK
IDE-integrated continuous analyses are not new. Incremental
code compilation [17] has been integrated in most modern IDEs,
such as Eclipse5. Eclipse Java compiler warnings and errors6, in-
cluding the Nullness type system, are closely integrated into the
incremental compiler. These continuous analyses are implemented
by the IDE developers. For third party analyses, Eclipse provides
project builders: An analysis author can implement the analysis
logic as a project builder extension so that the analysis is executed
with each incremental build. Eclipse FindBugs [11], Checkstyle [9],
and Metrics [10] plug-ins are example continuous analyses imple-
5http://www.eclipse.org/jdt/core/index.php
6http://help.eclipse.org/topic/org.eclipse.jdt.doc.user/reference/
preferences/java/compiler/ref-preferences-errors-warnings.htm331Figure 8: Continuous testing running on Apache commons.cli. The
left screenshot shows the original commons.cli implementation, for
which all tests pass. The developer deÔ¨Ånes the id of an option to
be its second character (right screenshot) and immediately sees that
this change causes an existing test to fail.
mented using project builders. Solstice and its API provides a richer,
alternative way to integrate third party analyses into the IDE.
In addition to project builders, Eclipse ‚Äî and some other IDEs ‚Äî
provide the analysis authors with a working copy7: the in-memory
state of a compilation unit (e.g., a Java Ô¨Åle). Working copies are
useful for fast, impure analyses that make small changes, such as
refactoring, quick Ô¨Åx, and auto complete. The analysis authors can
modify a compilation unit without changing the developer‚Äôs copy.
The developer changes to the same compilation unit are reported to
the working copy, and the analysis author may reconcile the working
copy with the developer‚Äôs copy. Solstice, in some sense, elevates the
working copy concept to the workspace level, with other features,
such as being able to access a stable development snapshot.
Speculative analysis [4] is a general concept of an impure analysis
that calculates actions a developer is likely to perform soon, per-
forms those actions in the background, evaluates the consequences
of those actions, and reports on those consequences. Speculative
analysis over version control can identify and prevent collaborative
conÔ¨Çicts [5, 6, 12] by creating and managing a copy codebase for
the analysis to use. Meanwhile, speculative analysis over Eclipse
Quick Fixes [19] creates and maintains its copy codebase inside the
developer‚Äôs workspace. Solstice removes the burden of creating and
maintaining the copy codebase, and relying on external operations
from such impure analyses. Similarly, live programming focuses on
providing continuous feedback to developers for the tasks they are
working on [3, 33] by making the behavior of a program visible as
that program is being developed [7]. Solstice enables continuous
analyses that facilitate live programming practices.
Integrating continuous analyses into the IDE facilitates continu-
ous development. Continuous development is not a new concept;
a programming environment, modeled on spreadsheets, can con-
tinuously execute the program as it is being developed [13, 16].
Similarly, continuous testing [24, 25, 26] executes the tests available
for a program as it is being developed. Meanwhile, continuous data
testing applies the same ideas to data debugging: discovering system
errors caused by well-formed but incorrect data [20]. While contin-
uous testing is integrated into Eclipse [27] and IntelliJ [15], Solstice
provides a generic framework for converting ofÔ¨Çine analyses into
continuous ones, integrated into the IDE.
7http://wiki.eclipse.org/FAQ_What_is_a_working_copy%3F7. CONTRIBUTIONS
Codebase Replication is a novel approach for converting ofÔ¨Çine
analyses that developers must run manually into continuous analyses
that run constantly and always provide the developer with up-to-date
results. Codebase Replication solves two major challenges of build-
ing continuous analyses: isolation andcurrency . Isolation requires
that the analysis does not prevent the developer from making new
changes, and code changes made by an impure analysis neither alter
the code visibly nor functionally while the developer is working.
Currency requires that analysis results are made available quickly,
and that stale results are marked as stale. To solve these challenges,
Codebase Replication maintains an in-sync copy of the developer‚Äôs
codebase, allowing multiple analyses to use, and even temporarily
exclusively own, the copy. Codebase Replication tracks developer
changes at the buffer level, works with analyses that require either
source code or compiled binaries to run, and can even be used to
convert impure ofÔ¨Çine analyses into continuous ones.
Solstice, our prototype implementations of Codebase Replica-
tion, facilitates converting ofÔ¨Çine analyses into continuous-analysis
Eclipse plug-ins. We have used Solstice to build three such proof-
of-concept plug-ins. Each plug-in, on average, required writing only
519 LoC (436 NCSL) and took 18 hours to write. The Solstice-based
plug-ins incurred 2.5 milliseconds overhead on the developer‚Äôs IDE
and experienced a 2.5 milliseconds delay before synchronizing the
copy codebase with the developer‚Äôs latest edits.
Overall, the cost to converting ofÔ¨Çine analyses to continuous ones
with Codebase Replication is low, as compared to the alternative
of redesigning the ofÔ¨Çine analyses to work continuously. Further,
the beneÔ¨Åts of continuous analysis tools greatly outweigh the cost
of building them with Codebase Replication. Since continuous
analyses reduce the delay between the time when a developer makes
a change and when the effects and implications of this change
become known, by reducing the cost to implement IDE-integrated
continuous analyses, we believe Codebase Replication will bring
more continuous analyses into existence. Consequently, developers
will no longer need to interrupt development to get analysis feedback.
Instead, continuous analysis feedback will be integrated into the
software development process.
8. ACKNOWLEDGMENTS
This work is funded by NSF grants CCF-0963757 and CCF-
1016701. Ezgi Mercan worked on an early stage of the Solstice
prototype implementation. We thank Deepak Azad, Daniel Megert,
and Stephan Herrmann for their help with the Eclipse internals
throughout Solstice development, and the anonymous reviewers for
their comments and feedback.
9. REFERENCES
[1]B. W. Boehm. Software Engineering Economics . Prentice Hall
PTR, Upper Saddle River, NJ, USA, 1981.
[2]C. Boekhoudt. The big bang theory of IDEs. Queue , 1(7): 74‚Äì82 ,
October 2003.
[3]J. Brandt, M. Dontcheva, M. Weskamp, and S. R. Klemmer.
Example-centric programming: Integrating web search into
the development environment. In the 28th Conference on Hu-
man Factors in Computing Systems , CHI‚Äô10, pages 513‚Äì522 ,
Atlanta, GA, USA, April 2010.
[4]Y . Brun, R. Holmes, M. D. Ernst, and D. Notkin. Speculative
analysis: Exploring future states of software. In the Workshop
on the Future of Software Engineering Research , FoSER‚Äô10,
pages 59‚Äì63, Santa Fe, NM, USA, November 2010.332[5]Y . Brun, R. Holmes, M. D. Ernst, and D. Notkin. Proactive
detection of collaboration conÔ¨Çicts. In the 8th joint meeting
of the European Software Engineering Conference and the
Symposium on the Foundations of Software Engineering , ES-
EC/FSE‚Äô11, Szeged, Hungary, September 2011.
[6]Y . Brun, R. Holmes, M. D. Ernst, and D. Notkin. Early detec-
tion of collaboration conÔ¨Çicts and risks. IEEE Transactions on
Software Engineering , 2013.
[7]M. M. Burnett, J. W. Atwood Jr., and Z. T. Welch. Imple-
menting level 4 liveness in declarative visual programming
languages. In Symposium on Visual Languages , VL‚Äô98, pages
126‚Äì133, September 1998.
[8]Crossword sage. http://sourceforge.net/projects/crosswordsage,
2005.
[9]Eclipse-Checkstyle integration. http://eclipse-cs.sourceforge.
net, 2002.
[10] Eclipse Metrics plug-in. http://sourceforge.net/projects/metrics,
2002.
[11] FindBugs. http://Ô¨Åndbugs.sourceforge.net, 2003.
[12] M. L. Guimar√£es and A. R. Silva. Improving early detection of
software merge conÔ¨Çicts. In the 34th International Conference
on Software Engineering , ICSE‚Äô12, pages 342‚Äì352 , Zurich,
Switzerland, June 2012.
[13] P. Henderson and M. Weiser. Continuous execution: The
VisiProg environment. In the 8th International Conference
on Software Engineering , ICSE‚Äô85, pages 68‚Äì74 , London,
England, August 1985.
[14] D. Hovemeyer and W. Pugh. Finding bugs is easy. In the
19th Conference on Object-Oriented Programming Systems,
Languages, and Applications , OOPSLA‚Äô04, pages 132‚Äì136 ,
Vancouver, BC, CANADA, October 2004.
[15] InÔ¨Ånitest. http://inÔ¨Ånitest.github.io, 2010.
[16] R. R. Karinthi and M. Weiser. Incremental re-execution of
programs. In Symposium on Interpreters and Interpretive Tech-
niques , SIIT‚Äô87, pages 38‚Äì44, St. Paul, MN, USA, 1987.
[17] H. Katzan Jr. Batch, conversational, and incremental compil-
ers. In the American Federation of Information Processing
Societies , AFIPS‚Äô69, pages 47‚Äì56 , Boston, MA, USA, May
1969.
[18] S. K. Lahiri, K. Vaswani, and C. A. R. Hoare. Differential
static analysis: Opportunities, applications, and challenges. In
the Workshop on the Future of Software Engineering Research ,
FoSER‚Äô10, pages 201‚Äì204 , Santa Fe, NM, USA, November
2010.
[19] K. Mu¬∏ slu, Y . Brun, R. Holmes, M. D. Ernst, and D. Notkin.
Speculative analysis of integrated development environmentrecommendations. In the 3rd Conference on Object-Oriented
Programming Systems, Languages, and Applications , OOP-
SLA‚Äô12, pages 669‚Äì682, Tucson, AZ, USA, October 2012.
[20] K. Mu¬∏ slu, Y . Brun, and A. Meliou. Data debugging with contin-
uous testing. In the 9th joint meeting of the European Software
Engineering Conference and the Symposium on the Founda-
tions of Software Engineering, new ideas track , ESEC/FSE‚Äô13,
Saint Petersburg, Russia, August 2013.
[21] S. Person, M. B. Dwyer, S. Elbaum, and C. S. P ÀáasÀáareanu.
Differential symbolic execution. In the 16th Symposium on the
Foundations of Software Engineering , FSE‚Äô08, pages 226‚Äì237 ,
Atlanta, GA, USA, November 2008.
[22] PMD. http://pmd.sourceforge.net, 2003.
[23] G. Ramalingam and T. Reps. A categorized bibliography on
incremental computation. In the 20th Symposium on Princi-
ples of Programming Languages , POPL‚Äô93, pages 502‚Äì510 ,
Charleston, SC, USA, January 1993.
[24] D. Saff and M. D. Ernst. Reducing wasted development time
via continuous testing. In the 14th International Symposium on
Software Reliability Engineering , ISSRE‚Äô03, pages 281‚Äì292 ,
Denver, CO, USA, November 2003.
[25] D. Saff and M. D. Ernst. Continuous testing in Eclipse. In
the 2nd Eclipse Technology Exchange Workshop , eTX‚Äô04,
Barcelona, Spain, March 2004.
[26] D. Saff and M. D. Ernst. An experimental evaluation of contin-
uous testing during development. In International Symposium
on Software Testing and Analysis , ISSTA‚Äô04, pages 76‚Äì85 ,
Boston, MA, USA, July 2004.
[27] D. Saff and M. D. Ernst. Continuous testing in Eclipse. In
the 27th International Conference on Software Engineering ,
ICSE‚Äô05, pages 668‚Äì669, St. Louis, MO, USA, May 2005.
[28] A. Shankar and R. Bod√≠k. Ditto: Automatic incrementaliza-
tion of data structure invariant checks (in Java). In Confer-
ence on Programming Language Design and Implementation ,
PLDI‚Äô07, pages 310‚Äì319, San Diego, CA, USA, June 2007.
[29] Solstice: Continuous FindBugs. https://bitbucket.org/kivanc
muslu/solstice-continuous-Ô¨Åndbugs, 2013.
[30] Solstice: Continuous PMD. https://bitbucket.org/kivancmuslu/
solstice-continuous-pmd, 2013.
[31] Solstice: Continuous testing. https://bitbucket.org/kivancmuslu/
solstice-continuous-testing, 2013.
[32] V oldemort. http://www.project-voldemort.com/voldemort, 2009.
[33] E. M. Wilcox, J. W. Atwood Jr., M. M. Burnett, J. J. Cadiz, and
C. R. Cook. Does continuous visual feedback aid debugging
in direct-manipulation programming systems? In the Confer-
ence on Human Factors in Computing Systems , CHI‚Äô97, pages
258‚Äì265, Atlanta, GA, USA, March 1997.333