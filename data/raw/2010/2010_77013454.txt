Self-Adaptive Software Meets Control Theory:
A Preliminary Approach Supporting Reliability
Requirements
Antonio Filieri, Carlo Ghezzi, Alberto Leva, Martina Maggio
Dipartimento di Elettronica e Informazione, Politecnico di Milano
Piazza L. da Vinci, 32; 20133 Milano, Italy
fÔ¨Ålieri, ghezzi, leva, maggio g@elet.polimi.it
Abstract ‚ÄîThis paper investigates a novel approach to derive
self-adaptive software by automatically modifying the model of
the application using a control-theoretical approach. Self adap-
tation is achieved at the model level to assure that the model‚Äî
which lives alongside the application at run-time‚Äî continues
to satisfy its reliability requirements, despite changes in the
environment that might lead to a violation. We assume that
the model is given in terms of a Discrete Time Markov Chain
(DTMC). DTMCs can express reliability concerns by modeling
possible failures through transitions to failure states. Reliability
requirements may be expressed as reachability properties that
constrain the probability to reach certain states, denoted as
failure states.
We assume that DTMCs describe possible variant behaviors
of the adaptive system through transitions exiting a given state
that represent alternative choices, made according to certain
probabilities. Viewed from a control-theory standpoint, these
probabilities correspond to the input variables of a controlled
system‚Äîi.e., in the control theory lexicon, ‚Äúcontrol variables‚Äù.
Adopting the same lexicon, such variables are continuously
modiÔ¨Åed at run-time by a feedback controller so as to ensure
continuous satisfaction of the requirements despite disturbances,
i.e., changes in the environment. Changes at the model level
may then be automatically transferred to changes in the running
implementation.
The approach is methodologically described by providing
a translation scheme from DTMCs to discrete-time dynamic
systems, the formalism in which the controllers are derived. An
initial empirical assessment is described for a case study. Con-
jectures for extensions to other models and other requirements
concerns (e.g., performance) are discussed as future work.
Keywords -Adaptive software; control theory; dynamic systems;
non-functional requirements; reliability; run-time veriÔ¨Åcation.
I. INTRODUCTION
Software systems are increasingly required to be self-
adaptive. If certain requirements change, they must be able to
adapt their behavior to keep satisfying them. Moreover, they
should be able to detect changes in the environment in which
they are embedded and automatically adapt their behavior
to prevent violations of the expected quality attributes‚Äî
functional and nonfunctional‚Äîthey must fulÔ¨Åll.
In this paper we focus on systems that must guarantee
certain reliability requirements , expressed quantitatively as
constraints on the probability of reaching certain failure states.
Furthermore, we focus on changes that occur in the environ-
ment in which the application is situated, which may lead toreliability vulnerabilities. The typical scenario we implicitly
refer to is a service-oriented application (SOA) that composes
a number of existing internal or external services through a
workÔ¨Çow ( service orchestration ). The external services may
have their own failure proÔ¨Åles, which affect the overall re-
liability of the composite application. External services are
viewed as part of the environment, since they are not under
control of the application and may evolve autonomously. For
example, their failure proÔ¨Åle may change dynamically, due to
the upload of a new version of the application or changes in
the delivery infrastructure.
User proÔ¨Åles are another possible environment phenomenon
affecting the application. In our context, user proÔ¨Åles can be
modelled as the probability that different options are selected
by the user, whenever there are choices in the interaction with
the composite service.
In this paper, we focus on self adaptation at the model
level. That is, we assume that a model of the application
is kept alive at run-time [1], [2]. We further assume that
adaptation is performed at the model level, and then reiÔ¨Åed
at the implementation level. We assume that the composite
application is formally modeled by a Discrete Time Markov
Chain (DTMC). DTMCs are known as a useful formalism
to describe systems from the reliability viewpoint and to
support reasoning about it. Since a DTMC is just a Ô¨Ånite state
machine with probabilities attached to transitions, it can easily
model service invocations that may fail‚Äîby two transitions
exiting a certain state, respectively representing success and
failure‚Äîand user proÔ¨Åles‚Äîby transitions exiting a given state
and representing different choices made by users. Reliability
requirements may be typically expressed as reachability prop-
erties , i.e., as a relational formula constraining the probability
of reaching certain states that represent failure situations.
To support self-adaptation, this paper explores a novel
approach based on control theory (see Figure 1). We assume
that our goal is to maintain a certain reliability proÔ¨Åle for
the application being designed. For simplicity, let us assume
the proÔ¨Åle to simply be a certain target value of the overall
probability of failure. The output is a sequence of events
that represent successes or failures. The sequence of events
is transformed into the actual probability of failure by the
Learning Block . This block transforms a sequence of failureevents into a probability (typically, using a Bayesian approach,
as discussed in [3]). Blocks System andController in Figure 1
represent the modeled system and the controller, respectively.
The goal of the controller is to provide input values to the
system so that the resulting output (the observed sequence of
failure and success events) does not violate the requirement
expressed by the target, despite disturbances .
Controller System 
Learning 
Block Target 
Actual Input Output 
Fig. 1. Block diagram of the controlled system.
To understand what inputs and disturbances are in our
context, we must Ô¨Årst discuss how we deal with adaptation
at the model level. We assume that the software model
describes all possible variations that may be chosen to support
adaptation. That is, the modeler anticipates a number of ways
through which the system may self adapt its behavior. In
a DTMC framework, choices can be expressed by using
probabilities, which label transitions corresponding to the
choice of different behaviors. By changing these probabilities
it is possible to either increase or decrease the chance that
a certain functionality is selected. In the extreme case, by
setting a probability to 0 (or 1) a certain functionality is either
excluded or included. These probabilities are inputs of our
controlled system, generated by the controller. By changing
them, the controller tries to ensure continuous satisfaction
of the target reliability despite disturbances. Disturbances, in
turn, are changes in the independent variables, also modeled
by transition probabilities, that represent physical phenomena,
like changes in the failure probability of external services or
in the user proÔ¨Åles.
To the best our knowledge, the control-theoretical approach
illustrated in this paper is a novel contribution to self-adaptive
system models. In this paper, we illustrate the approach
and provide an initial experimental assessment. The paper is
organized as follows. Section II introduces the claims of this
work and sketches the use of software models and abstractions
for dynamic adaptation and control. In Section III a DTMC
model for reliability is described and the case study used in
the rest of this paper is presented. Section IV proposes a
way to translate DTMC models into discrete time dynamic
systems. The control of the resulting dynamic system is shown
in Section V, that provides formal properties assessment
and shows the application of the proposed technique to the
chosen case study, evaluated in Section VI. Related works
are described in Section VII while section VIII concludes the
paper.II. C ONTROL THEORY AND SOFTWARE MODELING
The dynamics of software execution are very complex.
Nonetheless, being able to control those dynamics would mean
having a software capable to adapt and on-line tune itself
to meet the speciÔ¨Åed requirements. However, the presence
of intrinsic non linearities, the variety of usage proÔ¨Åles, the
distribution process and the interconnection of heterogeneous
components are some of the reasons why it is so hard to
directly provide a comprehensive behavioral model suitable for
control. At the same time, the need for continuous veriÔ¨Åcation
of speciÔ¨Åc properties lead to the deÔ¨Ånition of simpler models.
These models are simple enough to allow the systematic syn-
thesis of controllers capable of driving the modeled dynamics
and still able to capture a number of aspects of the running
software that signiÔ¨Åcantly characterize the software behavior
and support assessment of some of its properties.
In this paper we refer to a controller as any system that,
properly coupled to the software system, makes it fulÔ¨Åll its
requirements whenever they are feasible. Requirements can
be strict constraints on the behavior (e.g. reliability equal to a
certain value) or related to the optimization of certain metrics
on the observed software executions (e.g. minimization of
outsourcing costs or maximization of throughput).
This work is aimed at supporting the claim that control
theory provides a number of instruments that software engi-
neers can exploit to ensure the achievement of extra-functional
design goals in presence of changes in the environment. To
do so, we focus on the following main kinds of ‚Äúreaction‚Äù the
controlled system should be able to provide:
1)change of the target requirements. If for some reason
the required nominal value of the overall reliability of
the composed system changes, the controller should be
able to drive the system toward a new operative state
satisfying the requirements.
2)robustness to sudden changes or Ô¨Çuctuations around
the nominal operative point assumed at design-time for
the environment phenomena. Interdependence among
software parts and components involves the use of third-
party services, remote storage, computing resources
out of the control of each company, and so on. All
these parts are characterized by the values of certain
QoS metrics, usually stated in convenient service level
agreements. During normal execution those values may
deviate from nominal values because of external factors
hardly predictable a priori (e.g. load conditions or hard-
ware failures). Actual values can be estimated on line
via monitoring.
3)robustness to accuracy errors in measurement and mon-
itoring. To capture relevant metrics of the execution we
rely on monitoring and/or other measurement proce-
dures. Each of these might get stuck into temporary bias
or might require a certain time to produce an appropriate
accuracy. We look for a controller able to provide a
reasonable behavior even in presence of transitory errors
on measured values. Such an ability, besides reducingthe sensitivity to measurement errors, allows for the
use of less invasive monitoring instruments sometimes
required for high accuracy, but expensive as performance
overhead.
In the following we provide a formal assessment of these
properties, based on mathematical modeling and we show the
practical implications with a case study.
III. C ONTROL -ORIENTED RELIABILITY MODELING
In this paper we focus on reliability, to ground the exposition
with a practical example of the application of the proposed
methodology. The approach can be extended to similar ana-
lytical models for performance and costs [4] (see Section V).
Reliability is an intrinsically probabilistic property, since it
depends on the usage of the system and on external resources,
whose characteristics are often uncertain [5]. In order to
capture the behavior of the system a widely adopted model
is a Discrete Time Markov Chain (DTMC) [6]‚Äì[9]. A DTMC
can be used to represent all the relevant states of a software
execution and the probability to move from each state to
another. Among all the states, one state is the initial state1.
Among the other states, one or more represent the successful
completion of the execution or the occurrence of a failure.
In this paper we assume there is a single success state sR
. Such an assumption does not reduce the expressiveness
of the model2. Failure and success states are modeled as
absorbing states , i.e. states with a self-loop transition labeled
with probability 1. The rationale here is is that we view success
and failure as deÔ¨Ånitive conditions: as the system reaches
either condition, it cannot progress any more. All states that
are not absorbing are called transient states .
Formally, a (Ô¨Ånite) DTMC is a tuple (S; s0;P; L)where:
Sis a Ô¨Ånite set of states
s0is the initial state
P:SS![0;1]is a stochastic matrix (i.e. 8si2S‚àë
sj2SP(si; sj) = 1 )
L:S!2APis a labeling function that marks every
state siwith the Atomic Propositions (AP) that are true
insi.
We will interchangeably use both the notation P(si; sj)and
pijto refer to the entry (i; j)of the matrix P, corresponding
to the probability of moving from state sito state sj. A path
through a DTMC is a (possibly inÔ¨Ånite) sequence of states
=s0s1s2:::, where si+1is reachable from sithrough a
transition. The probability Pinduces a probability space on
the set of all possible paths [10]. The probability of a path 
with length ncan be deÔ¨Åned as:
1It is also possible to extend the deÔ¨Ånition by introducing an initial
distribution dproviding for each state sithe probability dithat the process
will start there. The same effect can be achieved in our case by introducing
a special initial state s0such that 8siP(s0; si) =di.
2In fact, one could add a single success state reachable with probability 1
by every other state considered as successful in the general case and obtain
the mentioned case.8
>>>><
>>>>:P r() = 0
ifn= 0i.e.=s0
P r() =P(s0; s1)P(s1; s2):::P(sn 2; sn 1)
ifn > 0
For the purposes of this analysis, an execution of a software
is completely described by its trace , that is, the corresponding
path through the DTMC.
Reliability is the probability of successfully accomplishing
an assigned task. In our setting it can be deÔ¨Åned as the proba-
bility of reaching the state representing successful completion
(sR) given that the execution started from its initial state ( s0).
Thus reliability is deÔ¨Åned as‚àë
2P r(), where is the
set of all possible paths starting from s0and ending in sR.
Given that sRis an absorbing state, reliability can be para-
phrased as the probability of reaching sR, since, once reached,
sRcannot be left. Properties of a DTMC can be expressed
using the PCTL probabilistic temporal logic language [11].
Our reliability property is a particular kind of reachability
property expressed by the PCTL formula true U state =sR,
where Uis the Until temporal operator.
The vector xwhose entries xicorrespond to the probabil-
ities of reaching sRfrom state siis computed as solution of
the linear equation system in variables fxijsi2Sg:
xi=8
>><
>>:1 ifsi=sR
0 ifsiÃ∏=sRis absorbing‚àë
sj2SP(si; sj)xjotherwise(1)
thus the item x0corresponds to the probability of the PCTL
formula true U state =sRevaluated in the initial state.
In our DTMC model, some transitions are labeled with
variable probability values. These transitions belong to two
classes. One class represents unknown or changing behaviors
exhibited by the environment, which may inÔ¨Çuence the overall
behavior of the application, and hence satisfaction of the
overall requirements. An example may be the set of transitions
exiting a given state, which represent different options that a
user may select in an interactive state, whose labels represent
the probabilities that different choices are selected. In the
realistic case where user proÔ¨Åles may change, transition prob-
abilities are labeled as variables. The value of such variables
(representing the disturbances) is dynamically computed by
monitoring the application at run-time, collecting concrete real
values, and then inferring the associated probability through a
learning component like the one introduced in Figure 1. The
other class represents control variables (already introduced
earlier), whose value is generated by the controller and is input
to the system‚Äôs model (see also Figure 1). These variables can
be assigned any value compatible with design requirements
and the constraints determined by their nature. That is, every
control variable can assume a value in the set [0;1]and the
sum of the probabilities of the transitions leaving a certain
state must be one.Our objective is thus to design a controller that decides
system‚Äôs settings (i.e. decides control variables) given the
current situation (i.e. knowledge of system structure and
measures or estimates of environment situation) in order to
keep the system satisfying its requirements. This objective can
be achieved by exploiting well established control theoretical
instruments, with a number of additional features relevant for
the assessment of actual software quality, as will be explained
in Sections IV and V.
A. A Representative Example
In this section we introduce a simple running case study,
consisting of a model for an image processing application.
The high level software model is shown in Figure 2. The
purpose of the system is to apply a Ô¨Ålter to incoming images,
followed by a beautifying post-processing phase. It is equipped
with three different implementations of the Ô¨Ålter: 1) direct
Ô¨Åltering via internal software, 2) iterative Ô¨Åltering via internal
software, and 3) direct Ô¨Åltering via outsourcing to an external
service. The DTMC system model is provided in Figure 3. The
Ô¨Ågure shows that all operations have a certain probability of
failure (represented by transitions entering state SF). State S1
represents the point of choice between the different Ô¨Åltering
options. The probabilities that govern this choice and the
probability of applying one more iteration after the execution
of the iterative Ô¨Ålter (represented by state S2) are the control
variables in our setting. Control variables are indicated by
probability variables Ciin Figure 3 (referring to Figures 2
and 3, c1ais the probability of choosing the iterative Ô¨Ålter ,
c1bis the probability of choosing the internal direct Ô¨Ålter
and thus 1 c1a c1bthe probability of outsourcing; c5is
the probability of requesting another iteration of the iterative
Ô¨Ålter). These values can be changed online by the controller
while the software is executing. The controller in fact observes
the overall behavior (i.e., the overall probability of success or
failure) and tries to guarantee the requested global reliability
requirement by adjusting the invocation probabilities.
Image 
Filtering 
Service Iterative 
Filter 
Internal 
Direct Filter 
External 
Filter Post- 
processing 
Fig. 2. Schema of the software system.
We assume that all the alternatives are implemented by
black-box services that can be invoked and observed from
outside only. For each of these services, a run-time monitor
collects failure (or success) rates and estimates its reliabilityas the probability that a invocation to the service will fail3.
It is necessary to postulate in the environment the existence
of monitoring instruments . In fact, the reliability of the
computational units is time-varying and the overall reliability
depends on these values. Even if their nominal values are
known at design time, unpredictable events could alter them,
altering as a consequence also the software behavior. This is
not uncommon, since the alteration could for example simply
come from sharing components with other customers, so that,
at different times, their availability depends on load conditions
of computational resources. Service reliability for each server
are thus just observable values subject to variations during
time (disturbances).
s0 s1s2
s3
s4s6 sR
sFr0
1- r0c1a 
c1b 
1- c1a -c1b r2
1- c5
r61-r 2
1- r3
1- r4
1- r6s5
c5
r4r3
Fig. 3. DTMC mode for the example system.
By solving the equation system (1) for x0it is possible to
obtain a closed formula that describes the explicit dependency
of reliability ( s) on control variables ( c) and measured relia-
bilities ( r).
s=r0r6(c1a( 1 +c5)r2
 1 +c5r2+c1br3+ (1 c1a c1b)r4)
(2)
The formula of sshown in the Equation will be later used to
design the controller in Sections IV and V4.
IV. S OFTWARE MODELS AS DYNAMIC SYSTEMS
In this section we show how the dynamic evolution of the
running software, as observed via the corresponding DTMC
model, can be cast in the simple control-theoretical framework
of discrete-time dynamic systems [15], through which we
achieve self-adaptation of the behavior to react to changing
conditions in the environment. Due to space limitations, the
background theory can not be fully stated here, but the
3Estimates are here assumed to be statistically correct [12] and repre-
sentative of the average or worst case, depending on the desired analysis
scenario. Interested readers can refer to [3] for a deeper discussion about
DTMC parameters estimation at runtime, which is out of the scope of this
paper.
4The same formula can be obtained by exploiting state of the art techniques
from parametric model-checking and DTMC analysis in [13], [14]interested reader can refer to books such as [16]. A discrete-
time dynamic system is described by the equations
{x(k+ 1) = f(x(k); u(k); dx(k))
y(k) = g(x(k); u(k); dy(k))(3)
where x2 ‚Ñúnx,u2 ‚Ñúnuandy2 ‚Ñúnyare called respectively
the state, input and output vectors, dx2 ‚Ñúnxanddy2 ‚Ñúny
the state and output disturbance vectors (being those zeros if
there are no variations with respect to the nominal conditions),
f(;;)andg(;;)are real-valued vector functions of con-
venient dimensions, and kis an integer index counting the
instants ‚Äì not necessarily evenly spaced in time ‚Äì when the
system undergoes an evolution step. In a more general form,
f(;;)andg(;;)could depend on an arbitrary number of
real-valued parameters, possibly time-varying. The term ‚Äústep
k‚Äù denotes the time span between the k-th and the (k+ 1)-th
instant.
Vector dxrepresents disturbances corresponding to observ-
able values in the environment that affect the system‚Äôs state.
Vector dyaccounts for measurement errors of the controlled
variables.
The Ô¨Årst equation in (3) is called the state equation , and
dictates what the system state will be at the end of step kgiven
what it was at the beginning, and given also the actions exerted
on the system in that step, that are assumed to be correctly
summarized by the values of uanddxat its beginning. The
state equation represents the dynamic system‚Äôs character as
difference equations, i.e., owing to the contextual presence of
two subsequent index values. In other words, the state equation
gives the system ‚Äúmemory of the past‚Äù, and explains why the
same action generally yields different effects depending on
the system condition when it is applied. The input vector u
represents manipulated variables , that can be used to inÔ¨Çuence
the system‚Äôs behavior, while the state disturbance dxaccounts
for any action other than u, i.e., for any external entity that
actually inÔ¨Çuences the system state, and that in some cases
can possibly be measured, but never manipulated.
The second equation in (3) is instead called the output equa-
tion. It is not dynamic, as shown by the presence of a single
index value, and in most problems of interest it describes what
one measures (vector y) to appreciate the system‚Äôs behavior.
The disturbance vector dyrepresents possible alterations of
said measurements, due e.g. to noise, but notof the actual
evolution of the system state.
A key concept of control theory is that modeling an object
in the form (3) improves per se insight into that object by
providing a formal model for its dynamic evolution. In fact,
doing so naturally leads to distinguishing whether the same
action yielded a different outcome than the previous time it
was applied because the modeled object was in a different
state, or something other than that affected it, or some of its
parameters changed, or any combination thereof [15], [17]. As
is well known for control system design, such a distinction
is of paramount importance when controlling the system, as
trying to ‚Äúcounteract the wrong cause‚Äù for an undesired effect
can simply be disruptive. Also, models like (3) inherently givea quantitative and generally tractable meaning to the idea that
‚Äúthe system‚Äôs reaction to a stimulus is related to its previous
conditions‚Äù.
On a similar front, observe that a model like (3) is concerned
not only with the condition that the system can possibly reach
under constant inputs as k! 1 , but also with the way the
system ‚Äúmoves‚Äù in time. More generally, in the absence of
disturbances and assuming complete knowledge of the system
(i.e., of f(;;),g(;;)), the initial state x(k0)and the
input trajectory u(k),kk0, uniquely determine the state
trajectory x(k)and the output trajectory y(k)forkk0.
Disturbances and/or time-variances may alter that nominal
behavior, and ultimately motivate the use of feedback, as
explained in the next section.
Let us now specialize the general framework to the case
of control-oriented software modeling. Suppose that the adap-
tation mechanism, no matter how designed, acts at instants
identiÔ¨Åed by an index k, as in (3). Also, let the average
duration of a step be signiÔ¨Åcantly longer than the time scale of
the controlled system‚Äôs dynamics. Translating from the control
jargon to the case of interest, this means for example that if at
the beginning of a step some controller altered the transition
probabilities of the DTMC, then at the end of the same step
the effects of our actions can be measured . Hence, in this case
model (3) reduces to
s(k+ 1) = ~f(r(k) + ‚àÜ r(k); c(k)) (4)
where s(k+1)is the reliability in step k(the state, as deÔ¨Åned
in the general model of Equation 3), c(k)are the control
variables set for step k(i.e., decided at its beginning and kept
constant through the step), r(k)the expected reliabilities for
step k(which in this example are estimated via monitoring,
but in other case may also be nominal and possibly constant
values), and ‚àÜr(k)accounts for any discrepancy between the
real and expected reliabilities in step k. The form of function
~fstems from the DTMC model solving the associated linear
system (1), as for equation (2) in Section III-A.
Although model (4) is nonlinear and time-varying, it has the
very interesting property of being a ‚Äúpure delay‚Äù system, i.e.,
the state vector does not appear on the right hand side of the
state equation, the output being sitself. In system-theoretical
terms, what is here done is taking the steady-state model
coming from DTMCs and using it in a dynamic framework
under the assumption that any action at the beginning of a step
has exhausted its effect at the end of that step.
V. C ONTROLLING THE SYSTEM ‚ÄôSDYNAMICS BY
FEEDBACK
In a nutshell, the idea of feedback can be summarized as
plugging the controlled system into a larger one where its input
is made dependent on its measured output, possibly its state or
an estimation of it in the case it cannot be measured, and on
the desired behavior for the controlled system. Additionally,
disturbance measurements can be brought into play if avail-
able. Recalling model (3), this means in general setting up a
control law in the form:8
<
:xc(k+ 1) = fc(
xc(k); w(k+ 1);by(k);
bx(k);bdx(k);bdy(k))
u(k+ 1) = gc(xc(k); w(k+ 1);by(k))(5)
where the hat symbol recalls that in the real world only
measurements (or estimates) of some quantities are available
(i.e., from now on, bqmeans a measured or estimated value of q,
for any variable q). In (5) xcis the controller‚Äôs state vector ( x
in Equation 3 that refers to a general system), wtheset point ‚Äì
i.e., the desired behavior for (part of) the controlled system‚Äôs
state and output, e.g. the desired reliability. Notice that the
controller state and the desired behavior are assumed to be
known exactly, which is mere common sense. The control law
can be deÔ¨Åned explicitly or, as it is the case here, implicitly,
stating the controller‚Äôs state and output to be the solution of
an optimization problem. Notice also that the effect of the
control applied at the k-th step is measurable and visible in
the feedback signal at time k+ 1.
By joining (3) and (5) we obtain a closed-loop system. Its
inputs are the set point wand the disturbances dxanddy, its
state is the union of xandxc, and its output can be taken as
the set of variables for which a desired behavior is speciÔ¨Åed.
If the controller is properly designed, formal guarantees can
be provided on the behavior of the closed loop, also in the
presence of time variances and/or disturbances. Due to the lack
of space, it is impossible here to report the underlying theory,
therefore we move directly to the application for the solution
of the addressed problem, for further theoretical details the
reader can refer to [18]‚Äì[20].
Referring to the DTMC model as the software application
model, there are transition probabilities that can be controlled
(the control variables) and others that are not dependent on
any action but are observable and measurable during software
execution (disturbances), e.g. software failures. As previously
anticipated, in the following the controllable transition prob-
abilities are identiÔ¨Åed by variables c(k), i.e., the control
variables. At the same time the reliabilities r(k)are (disturbed)
non controllable transition probabilities.The obtained model is
therefore in the form (4) and wis the target value for s.
Based on the current value s(k), an estimation of the future
value ^s(k+ 1) is available. Such an estimation is obtained
by substituting the estimated or measured reliabilities in the
function fand using the control variables computed for step
k(notice that any measurements of sinclude the effect of dy):
^s(k) =f(^r(k);c(k)): (6)
Now let J(k) = fj(c)be a cost function on the control
variables c(k). For example, consider the two control variables
c1a(k); c1b(k)that stand for the probabilities of sending the
incoming request to three different services (the third one is
constrained to be 1 c1a(k) c2b(k)), the cost of those values
could be the cost of sending the request to each of the available
services. When there is no mapping between the software the
DTMC is modeling and a cost function naturally derived fromthe domain of the application5, the designer can introduce a
non informative cost function (such as a constant value) to
indicate no preferences among all the feasible solutions.The
controller comes into play by solving the optimization problem
minJ(c) (7)
subject to the constraints
jjw ^s(k)jj jjw s(k 1)jj
8ci(k);0ci(k)1(8)
where is a value in the range (0;1)that affects the conver-
gence rate of the solution, that is in the next step we expect
the absolute error to be reduced by a factor . The set of
constraints has to be extended with probabilistic constraints
(the sum of outgoing transitions from each state has to be 1),
as done for the control variables ci.
Formal assessment
To start, notice that for each step kwhere a solution of
the optimization problem (7) exists, the error w s(k)has
an exponential decay. This is obtained by construction, based
on how the controller was designed (Ô¨Årst constraint in (8)).
Moreover, under the same assumption, the time to converge
to the desired solution is known. Let e(0)be the initial error
w s(0), then e(k) =ke(0), according to the exponential
decay. If one assumes the system converged when the error
e(k)", then in nominal conditions this happens when:
klog"
e(0): (9)
If the system is no more in nominal conditions, i.e., if ^r(k)
is not the value for r(k)expected at design-time, the proposed
solution is robust whenever a solution is found for the opti-
mization problem. In fact, in such a case, the Ô¨Årst constraint
of (8) holds. In the ideal case, s(k) = ^s(k). Suppose now that
there is an additive term, due to a difference in the estimation
ofr(k) =^r(k) + ‚àÜ r(k), and therefore s(k) = ^s(k) + ‚àÜ s(k).
The error norm becomes jjw ^s(k) ‚àÜs(k)jjand the following
equations hold
jjw ^s(k) ‚àÜs(k)jj  jj w ^s(k)jj+jj‚àÜs(k)jj
jjw ^s(k)jj jjw s(k 1)jj:(10)
Notice that the second equation of (10) comes from the
existence of a solution for the optimization problem. As a
consequence, in the presence of a solution the stability still
holds, while the convergence time equation does not hold
anymore. However, if
jj‚àÜs(k)jj<(1 )jjw s(k 1)jj (11)
the error norm is guaranteed to diminish, albeit not at the
(unfeasible) desired rate.
Some words deserve to be spent on the role of . The
closer is to zero, the faster is the system convergence.
However, when the error is closer to zero there could be
5Cost estimation methodologies in the context of software reliability is an
open research Ô¨Åeld. The interested reader could refer, for example, to [21].oscillations when changes occur, as testiÔ¨Åed by the inequality
(11). On the contrary, when approximates one the system
convergence is slow, the oscillations could occur potentially
before the error approaches zero, but are less intense. Notice
however, that the performed analysis is very powerful and we
are using the triangle inequality to upper estimate the norm
of the difference with the sum of the norms. This is deÔ¨Ånitely
a coarse overbound, and makes the proposed assessment re-
markably conservative. Such a characteristic is however shared
by numerous robustness-related control-theoretical results, and
historically accepted in exchange for easily applicable criteria.
The interested reader can Ô¨Ånd a discussion in [22].
The situation in which the optimization problem has no
feasible solutions triggers the intervention of a higher level
controller (or even a human operator) because there is no
control variable assignment that can further reduce the error.
However, the employed solver goes as close as possible
to the unfeasible constraint, therefore reaching the optimum
value that is reachable in the system conditions. Although a
complete treatment of the matter is deferred to future works,
an intermediate ‚Äì and all in all effective ‚Äì solution can be
to employ reliability estimates to possibly recompute the set
point as the feasible value nearest to the desired one. If this
is done, the previously devised results apparently apply, and
permit a possibly suboptimal but very simple management of
the situation.
VI. E XPERIMENTAL EVALUATION
As anticipated, the design of the control system starts from
the closed formula expression deÔ¨Åned in equation (2). For the
proposed case study the control system acts minimizing
J(c) = ( J1ac1a+J1bc1b+J5c5)2(12)
where J1a; J1bandJ5are equal to one, therefore assuming
all costs are equals. In the case study, the Ô¨Årst constraint of
equation (8) is considered with an equal sign, supposing that
the requirement is that the system expose exactly a certain
reliability.
In our Ô¨Årst experiment, the reliability required over time is
changed to show how the controller reacts to changes in the
desired value. The simulation is divided into four different
slots, each having 25time units. During the Ô¨Årst slot, the
reliability requirement is set to 0:7, while in the following
one it is 0:8. In the third slot, the desired reliability is 0:5
and it increases to 0:6in the last slot. All these numbers are
feasible, considering the reliabilities of the involved services.
Figure 4 depicts the overall system reliability (s)over time.
Figure 5 shows the control signals, c1ais represented with a
dashed line, while c1bis the continuous curve; the dashed
dotted line shows how c5changes over time.
Perturbations to the nominal model were added in the form
of disturbances to the services reliabilities ri, in order to show
the controller convergence previously formally proved. The
expressions of the reliabilities are
0 25 50 75 1000.50.60.70.80.91
Time unitsReliabilityFig. 4. Reliability of the system: set point (dashed) and achieved value
(solid).
r0= 0 :95 + 0 :02stp(k 25) 
0:20stp(k 50) + 0 :10stp(k 75)
r2= 0 :95 + 0 :02stp(k 20) 
0:20stp(k 70) + 0 :15stp(k 85)
r3= 0 :95 + 0 :02stp(k 15) 
0:97stp(k 55) + 0 :50stp(k 65)
r5= 0 :95
r8= 0 :95 + 0 :05stp(k 95)(13)
where stprepresents the step function6andkcounts the time
units. The changes in the reliabilities are introduced to test the
control system ability to respond to external variations. Notice
thatr3goes to zero in the time interval 55k65therefore
accounting for the complete failure of the internal non-iterative
Ô¨Ålter. The control system sharply counteracts the failure of the
internal direct Ô¨Ålter , changing the control variables as can be
noted in Figure 5 at time k= 55 .
0 25 50 75 10000.20.40.60.81
Time unitsControl variables
Fig. 5. Control variables of the system: c1adashed, c1bsolid and c5dashed
dotted.
This experiment allows us to test the response to both
transient behaviors, e.g., small variations of the operating
conditions, and to changes of the operative scenario, e.g., the
complete failure of a service.
6stp(k) = 1 ifk0and0otherwise.One may also consider the cost of a service as a time
varying parameter of the control system. We tested the same
system where the cost of the iterative Ô¨Ålter, J1b, becomes 100
in the interval 70k90. Figure 6 shows the control
variables in this case. Notice that the reliability set point is
attained, obtaining the same results shown in Figure 4. With
this test we demonstrated that the system is able to attain the
set point speciÔ¨Åcation and to minimize the cost of the overall
solution, also in the presence of different operating conditions;
for example changes of service costs.
Fig. 6. Control variables of the system: c1adashed, c1bsolid and c5dashed
dotted.
Notice that, intuitively, Figures 5 and 6 are equal except
for the mentioned interval where costs are modiÔ¨Åed. In Figure
6 the control system changes the transition probabilities (to
make the software system perform as in Figure 4) according
to the differences in the cost function for the diverse software
stages. The overall cost is therefore minimized.
VII. R ELATED WORK
Adaptation is playing a key role in the development of
software applications [23], [24]. Compiler-level advancements
have been developed to support adaptive implementations for
performance [25], [26] or power [27], [28], and low level
architectures are dynamically adjusted and targeted [29]‚Äì[32].
Control theory [33], [34] is capturing an increasing interest
from the software engineering community that looks at self-
management as a means to meet QoS requirements despite en-
vironmental changes and Ô¨Çuctuations of external phenomena.
Examples of this trend can be seen in research on control of
web servers [35], [36], data centers and clusters management
[37], [38], and operating systems [39]‚Äì[43].
Self-management techniques are also prominent in industry;
e.g., companies like IBM [44] (see projects like the IBM
Touchpoint Simulator, the K42 Operating System [40]), Oracle
(Oracle Automatic Workload Repository [45]), and Intel (Intel
RAS Technologies for Enterprise [46]).
The application of control theory in software engineering,
however, is still in a very preliminary stage. Developing
accurate system models for software is in fact hard. Moreover,
strong mathematical skills are needed in order to deal withcomplex non-linear dynamics of real systems [33], [47], [48].
These difÔ¨Åculties usually lead to the design of controllers
focused on particular operating regions or conditions and ad
hoc solutions that address a speciÔ¨Åc computing problem using
control theory, but do not generalize [36], [49], [50]. For
example, in [51] the speciÔ¨Åc problem of building a controller
for a .NET thread pool is addressed.
To the best of our knowledge, control of software through a
DTMC model capturing its reliability-related properties was
not explored previously. Moreover, the approach proposed
in this paper in general for any reachability property over
DTMCs, regardless of the speciÔ¨Åc application. Hence it can
be applied in general.
Concerning the control of Markov processes, most of the
approaches in literature cover only special cases. A gen-
eral control approach for Continuous Time Markov Chains
(CTMCs) has been proposed by Brockett in 2008 [52]. The
goal of the controller is to set the value of control transition
rates in order to control selected transition rates, through
minimizing a quadratic cost function over the controls. We
are considering Brockett‚Äôs model to apply the methodology
presented in this paper for performance-driven adaptation of
software systems.
VIII. C ONCLUSIONS
The application of control theory to the systematic construc-
tion of adaptive software is a challenging and potentially very
valuable approach. This paper has just scratched the surface by
focusing on adaptation of a speciÔ¨Åc class of models (Discrete
Time Markov Chains‚ÄîDTMCs) for a speciÔ¨Åc class of require-
ments that need to be preserved (global reliability expressed
through a reachability property), speciÔ¨Åc phenomena whose
changes may lead to requirements violations (changes that
may be expressed as updates in certain probabilities associated
with transitions), and a speciÔ¨Åc way to attempt adaptation
by controlling the model (generating new values for other
probabilities, which represent control variables).
Future research will need to generalize beyond all the
‚ÄúspeciÔ¨Åcs‚Äù. For example, future research should be dealing
with other formal models that may address other classes
of non-functional properties (e.g., Continuous Time Markov
Chains to deal with performance or Markov Reward Models
to deal with costs) and with multi-objective goals to achieve
and preserve. Moreover, on the modeling side, the overall
chain could be modeled introducing also other aspects of the
software execution, e.g. service rates. The resulting model
would become nonlinear since the state is directly affected by
the control variables (the inputs) in a multiplicative way. This
brings into play more complex control solutions and opens
interesting perspectives also for control researchers.
ACKNOWLEDGMENT
This research has been partially funded by the European Com-
mission, Programme IDEAS- ERC, Project 227977-SMScom.REFERENCES
[1]L. Baresi and C. Ghezzi, ‚ÄúThe disappearing boundary between
development-time and run-time,‚Äù in FSE/SDP - Future of software
engineering research . New York, NY, USA: ACM, 2010, pp. 17‚Äì22.
[2]G. Blair, N. Bencomo, and R. France, ‚ÄúModels@ run.time,‚Äù Computer ,
vol. 42, no. 10, pp. 22 ‚Äì27, 2009.
[3]I. Epifani, C. Ghezzi, R. Mirandola, and G. Tamburrelli, ‚ÄúModel
evolution by run-time parameter adaptation,‚Äù in ICSE , 2009.
[4]C. Baier and J.-P. Katoen, Principles of Model Checking . The MIT
Press, 2008.
[5]R. C. Cheung, ‚ÄúA user-oriented software reliability model,‚Äù IEEE TSE ,
vol. 6, no. 2, pp. 118‚Äì125, 1980.
[6]L. Cheung, R. Roshandel, N. Medvidovic, and L. Golubchik, ‚ÄúEarly pre-
diction of software component reliability,‚Äù in ICSE, Leipzig, Germany,
May 10-18, 2008 . ACM, 2008, pp. 111‚Äì120.
[7]A. Filieri, C. Ghezzi, V. Grassi, and R. Mirandola, ‚ÄúReliability analysis
of component-based systems with multiple failure modes,‚Äù in CBSE ,
2010, pp. 1‚Äì20.
[8]K. Goseva-Popstojanova and K. S. Trivedi, ‚ÄúArchitecture-based approach
to reliability assessment of software systems,‚Äù Performance Evaluation ,
vol. 45, no. 2-3, pp. 179‚Äì204, 2001.
[9]R. Reussner, H. W. Schmidt, and I. Poernomo, ‚ÄúReliability prediction
for component-based software architectures,‚Äù JSS, vol. 66, no. 3, pp.
241‚Äì252, 2003.
[10] J. Kemeny, J. Snell, and A. Knapp, Denumerable Markov chains .
Springer, 1976.
[11] H. Hansson and B. Jonsson, ‚ÄúA logic for reasoning about time and
reliability,‚Äù FAC, vol. 6, no. 5, pp. 512‚Äì535, 1994.
[12] W. Pestman, Mathematical statistics: an introduction . Walter de
Gruyter, 1998.
[13] A. Filieri, C. Ghezzi, and G. Tamburrelli, ‚ÄúRun-time efÔ¨Åcient probabilis-
tic model checking,‚Äù in ICSE , 2011.
[14] E. Hahn, H. Hermanns, and L. Zhang, ‚ÄúProbabilistic reachability for
parametric markov models,‚Äù Model Checking Software , pp. 88‚Äì106,
2009.
[15] W. Levine, The control handbook . CRC Press, 2005.
[16] G. F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control
of Dynamic Systems, 6th Edition . Pearson, 2009.
[17] J. Doyle, B. Francis, and A. Tannenbaum, Feedback control theory .
Basingstoke, UK: MacMillan, 1992.
[18] K.ÀöAstr¬®om and T. H ¬®agglund, Advanced PID Control . Research Triangle
Park, NC: ISA - The Instrumentation, Systems, and Automation Society,
2005.
[19] A. O‚ÄôDwyer, Handbook of PI And PID Controller Tuning Rules , 2nd ed.
Imperial College Press, 2006.
[20] F. Lewis and V. Syrmos, Optimal Control , 2nd ed. John Wiley & Sons,
2004.
[21] H. Pham, ‚ÄúSoftware reliability and cost models: Perspectives, compari-
son, and practice,‚Äù EJOR , vol. 149, no. 3, pp. 475‚Äì489, 2003.
[22] M. Morari and E. ZaÔ¨Åriou, Robust process control . Upper Saddle River,
NJ: Prentice Hall, 1989.
[23] J. Kramer and J. Magee, ‚ÄúSelf-managed systems: an architectural
challenge,‚Äù in FOSE , 2007, pp. 259 ‚Äì268.
[24] B. Cheng, R. de Lemos, H. Giese, P. Inverardi, J. Magee, J. Andersson,
B. Becker, N. Bencomo, Y. Brun, B. Cukic, G. Di Marzo Serugendo,
S. Dustdar, A. Finkelstein, C. Gacek, K. Geihs, V. Grassi, G. Karsai,
H. Kienle, J. Kramer, M. Litoiu, S. Malek, R. Mirandola, H. Mller,
S. Park, M. Shaw, M. Tichy, M. Tivoli, D. Weyns, and J. Whittle, ‚ÄúSoft-
ware engineering for self-adaptive systems: A research roadmap,‚Äù in
Software Engineering for Self-Adaptive Systems , ser. LNCS, B. Cheng,
R. de Lemos, H. Giese, P. Inverardi, and J. Magee, Eds. Springer Berlin
/ Heidelberg, 2009, vol. 5525, pp. 1‚Äì26.
[25] N. Thomas, G. Tanase, O. Tkachyshyn, J. Perdue, N. M. Amato, and
L. Rauchwerger, ‚ÄúA framework for adaptive algorithm selection in
STAPL,‚Äù in ACM PPoPP . New York, NY, USA: ACM, 2005, pp.
277‚Äì288.
[26] J. Ansel, C. Chan, Y. L. Wong, M. Olszewski, Q. Zhao, A. Edelman, and
S. Amarasinghe, ‚ÄúPetaBricks: A language and compiler for algorithmic
choice,‚Äù in ACM PLDI , 2009.
[27] W. Baek and T. Chilimbi, ‚ÄúGreen: A framework for supporting energy-
conscious programming using controlled approximation,‚Äù in ACM PLDI ,
2010.[28] J. Sorber, A. Kostadinov, M. Garber, M. Brennan, M. D. Corner, and
E. D. Berger, ‚ÄúEon: a language and runtime system for perpetual
systems,‚Äù in SenSys , 2007, pp. 161‚Äì174.
[29] R. Bitirgen, E. Ipek, and J. F. Martinez, ‚ÄúCoordinated management of
multiple interacting resources in chip multiprocessors: A machine learn-
ing approach,‚Äù in MICRO 41: Proceedings of the 41st annual IEEE/ACM
International Symposium on Microarchitecture . Washington, DC, USA:
IEEE Computer Society, 2008, pp. 318‚Äì329.
[30] M. A. Suleman, O. Mutlu, M. K. Qureshi, and Y. N. Patt, ‚ÄúAccelerating
critical section execution with asymmetric multi-core architectures,‚Äù in
ASPLOS , 2009, pp. 253‚Äì264.
[31] R. Kumar, K. Farkas, N. Jouppi, P. Ranganathan, and D. Tullsen,
‚ÄúProcessor power reduction via single-isa heterogeneous multi-core
architectures,‚Äù Computer Architecture Letters , vol. 2, no. 1, pp. 2‚Äì2,
2003.
[32] E. Ipek, M. Kirman, N. Kirman, and J. F. Martinez, ‚ÄúCore fusion:
accommodating software diversity in chip multiprocessors,‚Äù SIGARCH
Comput. Archit. News , vol. 35, no. 2, pp. 186‚Äì197, 2007.
[33] J. L. Hellerstein, ‚ÄúSelf-managing systems: A control theory foundation,‚Äù
IEEE LCN , vol. 0, pp. 708‚Äì708, 2004.
[34] J. Hellerstein, Y. Diao, S. Parekh, and D. Tilbury, Feedback Control of
Computing Systems . Wiley, 2004.
[35] M. Kihl, A. Robertsson, M. Andersson, and B. Wittenmark, ‚ÄúControl-
theoretic analysis of admission control mechanisms for web server
systems,‚Äù The World Wide Web Journal, Springer , vol. 11, no. 1-2008,
pp. 93‚Äì116, 2007.
[36] C. Lu, Y. Lu, T. Abdelzaher, J. Stankovic, and S. Son, ‚ÄúFeedback control
architecture and design methodology for service delay guarantees in web
servers,‚Äù IEEE TPDS , vol. 17, no. 9, pp. 1014‚Äì1027, 2006.
[37] X. Dutreilh, A. Moreau, J. Malenfant, N. Rivierre, and I. Truck, ‚ÄúFrom
data center resource allocation to control theory and back,‚Äù IEEE
CLOUD , vol. 0, pp. 410‚Äì417, 2010.
[38] D. Kusic and N. Kandasamy, ‚ÄúRisk-aware limited lookahead control
for dynamic resource provisioning in enterprise computing systems,‚Äù
Cluster Computing , vol. 10, pp. 395‚Äì408, 2007, 10.1007/s10586-007-
0022-y.
[39] C. Cascaval, E. Duesterwald, P. F. Sweeney, and R. W. Wisniewski,
‚ÄúPerformance and environment monitoring for continuous program
optimization,‚Äù IBM J. Res. Dev. , vol. 50, no. 2/3, pp. 239‚Äì248, 2006.
[40] O. Krieger, M. Auslander, B. Rosenburg, R. W. J. W., Xenidis, D. D.
Silva, M. Ostrowski, J. Appavoo, M. Butrico, M. Mergen, A. Waterland,
and V. Uhlig, ‚ÄúK42: Building a complete operating system,‚Äù in EuroSys
‚Äô06: Proc. of the 1st ACM SIGOPS/EuroSys Euro. Conf. on Computer
Systems , 2006.
[41] S. Oberth ¬®ur, C. B ¬®oke, and B. Griese, ‚ÄúDynamic online reconÔ¨Åguration
for customizable and self-optimizing operating systems,‚Äù in EMSOFT
‚Äô05: Proceedings of the 5th ACM international conference on Embedded
software . New York, NY, USA: ACM, 2005, pp. 335‚Äì338.
[42] C. Karamanolis, M. Karlsson, and X. Zhu, ‚ÄúDesigning controllable
computer systems,‚Äù in Proceedings of the 10th conference on Hot Topics
in Operating Systems . Berkeley, CA, USA: USENIX Association, 2005,
pp. 9‚Äì15.
[43] M. Maggio, H. Hoffmann, M. D. Santambrogio, A. Agarwal, and
A. Leva, ‚ÄúControlling software applications via resource allocation
within the heartbeats framework,‚Äù in CDC , 2010, pp. 3736‚Äì3741.
[44] IBM Inc., ‚ÄúIBM autonomic computing website,‚Äù
http://www.research.ibm.com/autonomic/, 2009.
[45] Oracle Corp., ‚ÄúAutomatic Workload Repository
(AWR) in Oracle Database 10g,‚Äù http://www.oracle-
base.com/articles/10g/AutomaticWorkloadRepository10g.php.
[46] Intel Inc., ‚ÄúReliability, availability, and serviceability for the always-on
enterprise,‚Äù www.intel.com/assets/pdf/whitepaper/ras.pdf, 2005.
[47] R. Dorf and R. Bishop, Modern control systems . Prentice Hall, 2008.
[48] X. Zhu, M. Uysal, Z. Wang, S. Singhal, A. Merchant, P. Padala, and
K. Shin, ‚ÄúWhat does control theory bring to systems research?‚Äù SIGOPS
Oper. Syst. Rev. , vol. 43, pp. 62‚Äì69, 2009.
[49] M. Tanelli, D. Ardagna, and M. Lovera, ‚ÄúLPV model identiÔ¨Åcation for
power management of web service systems,‚Äù in IEE MSC . Boston,
MA: IEEE Control Systems Society, 2008, pp. 1171‚Äì1176.
[50] Q. Sun, G. Dai, and W. Pan, ‚ÄúLPV model and its application in web
server performance control,‚Äù in CSSE , vol. 3. Washington, DC, USA:
IEEE Computer Society, 2008, pp. 486‚Äì489.[51] J. Hellerstein, V. Morrison, and E. Eilebrecht, ‚ÄúApplying control theory
in the real world: Experience with building a controller for the .net thread
pool,‚Äù Sigmetrics Performance Evaluation Review , pp. 38‚Äì42, 2009.[52] R. Brockett, ‚ÄúOptimal control of observable continuous time markov
chains,‚Äù in Decision and Control, 2008. CDC 2008. 47th IEEE Confer-