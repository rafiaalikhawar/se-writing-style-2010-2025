Unbounded Data Model Verication Using SMT Solver s
Jaideep Nijjar and TevkBultan
University ofCalifornia,Santa Barbar a
{jaideepnijjar ,bultan}@cs .ucsb .edu
ABSTRA CT
Thegrowinginﬂuence ofwebapplications ineveryaspectof
societymakestheirdependabilit yanimmense concern. A
fundamen talbuilding blockofwebapplications thatusethe
Model-View-Con troller (MVC)pattern isthedatamodel,
whichspeciﬁes theobjectclasses andtherelations among
them. Wepresen tanapproac hforunbounded, automated
veriﬁcation ofdatamodelsthat1)extracts aformal data
modelfromanObjectRelational Mapping, 2)convertsver-
iﬁcation queries aboutthedatamodeltoqueries aboutthe
satisﬁabilit yofformulasinthetheory ofuninterpreted func-
tions, and3)usesaSatisﬁabilit yModuloTheories (SMT)
solvertocheckthesatisﬁabilit yoftheresulting formulas.
Weimplemen tedthisapproac handapplied ittoﬁveopen-
source Rails applications. Ourresults demonstrate thatthe
proposedapproac hisfeasible, andismore eﬃcien tthan
SAT-based bounded veriﬁcation.
Categories andSubject Descriptors
D.2.4 [SoftwareEngineering ]:Software/Program Veriﬁ-
cation— Formal metho ds;D.2.11 [SoftwareEngineering ]:
SoftwareArchitectures— Data abstr action
General Terms
Veriﬁcation
Keywords
Unbounded veriﬁcation, MVCframew orks,SMT solvers
1.INTR ODUCTION
Thewebhasevolvedintoanubiquitous medium forcom-
puting andcomm unication services thatbothbusinesses and
individuals relyonextensiv ely.There isreason tobecon-
cerned aboutthisever-increasing reliance onwebapplica-
tions: webapplication developmen tisanerror-prone pro-
cessthatproduces acomplicated distributed softwaresys-
temwithcomplex interactions among manycomponents.
Moreo ver,duetotheextensiv euseofscripting languages in
Permission tomakedigital orhard copies ofallorpart ofthisworkfor
personal orclassroom useisgranted without feeprovided thatcopies are
notmade ordistrib uted forprot orcommercial advantage andthatcopies
bear thisnotice andthefullcitation ontherstpage. Tocopyotherwise, to
republish, topost onserversortoredistrib utetolists, requires prior specic
permission and/or afee.
ASE'12, September 3-7,2012, Essen, German y
Copyright 2012 ACM978-1-4503-1204-2/12/09... $15.00.!"#$%&
'()*+,-".&!"#$%&'()*$
/$*01,+-".&+&(,-.$/-0-$,&/*.$
1(&1*(2*%$
+&(,'.-$34%0-4)*$
&($'4%-0$5*(36)-2&4$(*%'.0%$
Figure 1:ToolArchitecture
webapplication developmen t,static analysis ofwebsoftware
isverydiﬃcult.
Onepositiveadvancemen tinwebapplication developmen t
hasbeentheadoption oftheModel-View-Con troller (MVC)
pattern [14]. Manypopular webapplication developmen t
framew orkssuchasRubyonRails (Rails forshort), Zend
forPHP,CakePHP,Django forPython, andSpring forJ2EE
arebased ontheMVCpattern. Thispattern facilitates the
separation ofthedatamodel(Model)fromtheuserinterface
logic(View) andthecontrolﬂowlogic(Controller). The
modularit yandseparation ofconcerns principles imposed
bytheMVCpattern provideopportunities fordeveloping
customized veriﬁcation andanalysis techniques.
Ourworkfocuses ontheveriﬁcation ofdatamodelsinweb
applications. Adatamodelspeciﬁes thetypesofobjects
(e.g.,user,photo, proﬁle, etc.)andtherelations among the
objects(e.g.,therelations betweenusers andphotos and
proﬁles) inawebapplication. Adatamodelalsospeciﬁes
constrain tsonthedatamodelrelations (e.g.,therelation
betweenusers andproﬁles mustbeone-to-one).
Inthispaperwepresen tanunbounded, automated veriﬁ-
cation technique andtool(Figure 1)fordatamodelveriﬁ-
cation ofMVC-based webapplications. MVC-based frame-
worksuseanobject-relational mapping (ORM) tomapthe
datarepresen tation ofthewebapplication totheback-endPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
210
database. Thefront-end ofourtoolautomatically extracts
aformal datamodelfromtheORM speciﬁcation ofthein-
putwebapplication. Curren tly,ourfront-end onlysupports
ORM speciﬁcations ofRubyonRailswebapplications. The
back-end ofourtoolconvertsveriﬁcation queries toformu-
lasinthetheory ofuninterpreted functions andthenuses
aSatisﬁabilit yModuloTheories (SMT) solvertodetermine
thesatisﬁabilit yofthequeries. Based ontheoutput ofthe
SMT solver,ourtoolreportswhether thepropertyholds or
fails,andforfailing assertions italsoreportsadatamodel
instance asacounter-example. OurSMT-based veriﬁcation
approac hdoesnotbound thesizesoftheobjectclasses or
therelations, soifourveriﬁcation toolreportsthatanas-
sertion holds, itisguaran teedtoholdforanydatamodel
instance.
Weapplied ourapproac htoﬁveopen-source RubyonRails
applications andidentiﬁed avarietyofdatamodelerrors.
Ourresults showthatourveriﬁcation technique isfeasible
anduseful inanalyzing real-w orldapplications. Wealso
compared theperformance ofourapproac hwithabounded-
veriﬁcation approac hbased onSATsolvers,andourexper-
imentsdemonstrate that, inaddition toguaran teeing cor-
rectness forveriﬁed properties (whichisnotpossible with
bounded veriﬁcation), surprisingly ,ourunbounded veriﬁca-
tionapproac hismore eﬃcien tthanbounded veriﬁcation
when theboundontheclasssizeexceeds 10.
Ourcontributions inthispaperinclude: 1)Anautomated
translation ofdatamodelveriﬁcation queries toformulasin
thetheory ofuninterpreted functions. 2)Anewdatamodel
veriﬁcation technique forMVC-based webapplications that
usesSMT solversandcanhandle unbounded datamodels.
3)Atechnique forreducing thesizeofthedatamodelspec-
iﬁcation byprojecting itbased onthepropertythatisbeing
veriﬁed. 4)Experimen talevaluation oftheproposedap-
proachonﬁvereal-w orldapplications.
Therestofthepaperisorganized asfollows:Section 2dis-
cusses datamodelsinwebapplications andgivesaformal-
ization ofthedatamodelveriﬁcation problem. Section 3
presen tsthetranslation ofdatamodelveriﬁcation queries
tothetheory ofuninterpreted functions. Section 4explains
ourdatamodelprojection technique. Section 5presen tsour
experimen talresults. Related workisdiscussed inSection 6
andSection 7concludes thepaper.
2.WEB APPLICA TION DATAMODELS
Thedatamodelforms thefoundation ofanMVC-based web
application. Anyerrorinthisfoundation canhaveasigniﬁ-
cantimpact ontheentireapplication. Thedatamodelpro-
vides anabstraction betweentheapplication codeandthe
backenddatastore inawebapplication. Typically ,fromthe
backenddatastore’s pointofviewthedataisstored inare-
lational database, whereas fromtheperspectiveoftheappli-
cation codethedataisrepresen tedusing anobject-orien ted
datamodel.TheORM provided bytheMVC-based web
application developmen tframew orkshandles thetranslation
betweenthese twoviews, sothattheapplication codeand
thebackenddatastore caninteract witheachother while
preserving theirownviews ofthedata.1 class User <ActiveRecord::Base
2 has_and_belongs_to_many :roles
3 has_one :profile, :dependent =>:destroy
4 has_many :photos, :through =>:profile
5 end
6 class Role <ActiveRecord::Base
7 has_and_belongs_to_many :users
8 end
9 class Profile <ActiveRecord::Base
10 belongs_to :user
11 has_many :photos, :dependent =>:destroy
12 has_many :videos, :dependent =>:destroy,
13 :conditions =>"format=’mp4’"
14 end
15 class Photo <ActiveRecord::Base
16 belongs_to :profile
17 has_many :tags, :as =>:taggable
18 end
19 class Video <ActiveRecord::Base
21 belongs_to :profile
22 has_many :tags, :as =>:taggable
23 end
24 class Tag <ActiveRecord::Base
25 belongs_to :taggable, :polymorphic =>true
26 end
Figure 2:Adatamodelexample
TheORM usedintheRubyonRails framew orkiscalled
ActiveRecords. Figure 2showsasimple ActiveRecords
speciﬁcation forasocialnetworking application where users
haveproﬁles whichstore theirphoto andvideo ﬁles. The
photos andvideos canbetagged byusers, andusers can
havediﬀeren troles. Below,weexplain diﬀeren ttypesof
declarations supported byActiveRecords using thisexam-
ple,andwediscuss howthesedeclarations canbeformalized
asrelational constrain tsonaformal datamodel.
Wedeﬁne adatamodelasatuple M=/angbracketleftS,C,D/angbracketrightwhere Sis
thedatamodelschema identifying thesetsandrelations of
thedatamodel, Cisasetofrelational constrain ts,and D
isasetofdependency constrain ts.Theschema Sidentiﬁes
thenames oftheobjectclasses andthenames anddomains
oftherelations inthedatamodel.Forexample, theschema
fortheexample showninFigure 2willidentifythefollowing
setofobjectclasses {User, Role, Proﬁle, Photo, Video, Tag}
andtherelations among these objectclasses {photo-proﬁle,
photo-tag, photo-user, proﬁle-user, proﬁle-video, role-user,
tag-video },Therelational constrain tsinCexpress thecon-
straintsontheserelations thatareimposedbytheirdeclara-
tions. Ifagivenrelation rsatisﬁes agivenconstrain t,then
wewouldstatethat r|=C.
Basic Relation Declar ations. Rails supportsthree basic
typesofrelations among objects: 1)one-to-one ,2)one-to-
many,and3)many-to-many .Thehas_one andbelongs_to
declarations inlines3and10inFigure 2deﬁne aone-to-one
relation betweentheUserandProﬁle classes. More accu-
rately,thisisaone-to-zero-or-one relation anditdeclares
thateachUserobjectmustbeassociated withzeroorone
Proﬁle object,andeachProﬁle objectmustbeassociated
withexactly oneUserobject.Inorder toformalize thisre-
lation asaconstrain t,letususe oUand oPtodenote theset
ofobjectsfortheUserandProﬁle classes and rU−Ptode-
notetherelation betweenUserobjectsandProﬁle objects.211Then theconstrain tthatcorresp ondstothisrelation isfor-
malized as:
(∀p∈oP,∃u∈oU,(u,p)∈rU−P)
∧ (∀p,p/prime∈op,∀u∈oU,
((u,p)∈rU−P∧(u,p/prime)∈rU−P)⇒p=p/prime)
∧ (∀p∈op,∀u,u/prime∈oU,
((u,p)∈rU−P∧(u/prime,p)∈rU−P)⇒u=u/prime) (1)
Next, letusconsider theone-to-man yrelation betweenthe
Proﬁle andPhoto classes, whichisdeclared intheRails
datamodelinFigure 2using thehas_many andbelongs_to
declarations inlines11and16.Using oPand oPhtodenote
thesetofobjectsfortheProﬁle andPhoto classes and rP−Ph
todenote theproﬁle-photo relation, theformal datamodel
constrain tthatcorresp ondstothisdeclaration is:
(∀ph∈oPh,∃p∈oP,(p,ph)∈rP−Ph)
∧ (∀p,p/prime∈oP,∀ph∈oPh,
((p,ph)∈rP−Ph∧(p/prime,ph)∈rP−Ph)⇒p=p/prime)(2)
Finally ,amany-to-man yrelation canbeexpressed inRails
using thehas_and_belongs_to_many declaration onbothsides
oftherelation asshowninlines2and7inFigure 2.This
declares amany-to-man yrelation betweentheUserandRole
classes. Forsuchdeclarations wedonothavetocreate any
additional constrain tssinceanyrelation isamany-to-man y
relation.
Extensions. Rails provides asetofoptions thatcanbe
usedtoextend thethree basic relations mentioned above.
Theﬁrstoption isthe:through option forthehas_many and
has_one declarations. The:through option enables thedec-
laration ofnewrelations thatarethecomposition oftwo
other relations. Consider line4inFigure 2whichendswith
:through =>:profile anddeclares arelation betweenUser
andPhoto objects. When thisdeclaration iscombined with
thedeclarations oftherelation betweenUserandProﬁle ob-
jects(lines 3and10)andProﬁle andPhoto objects(lines 11
and16),itspeciﬁes thattherelation betweentheUserand
Photo objects(rU−Ph)isthecomposition oftherelations
betweentheUserandProﬁle objects(rU−P)andtheProﬁle
andthePhoto objects(rP−Ph).Thiscanbeformalized as:
∀u∈oU,∀ph∈oPh,(u,ph)∈rU−Ph⇔
(∃p∈oP,(u,p)∈rU−P∧(p,ph)∈rP−Ph) (3)
Thesecond option thatcanbeusedtoextend relations isthe
:conditions option, whichcanbesetonallofthefourdecla-
rations (has_one ,has_many ,belongs_to , and
has_and_belongs_to_many ).The:conditions option limits the
relation tothose objectsthatmeetacertain criteria. Forex-
ample, based ontherelation declaration inlines12and13in
Figure 2,Video objectsareonlyrelated toaProfile objectif
theirformat ﬁeldismp4.(Note thatthecondition statemen t
needs tobeintheformoftheWHERE clause ofaSQL
query.)Theformalization ofthisconstrain tdeﬁnes asetof
objects(oV/prime)thatisasubset oftheVideo objects(oV)(cor-
responding toVideo objectswithformat ﬁeld“mp4” )and
restricts therelation betweentheProﬁle andVideo objects
(rP−V)tothatsubset. Formally:
oV/prime⊆oV∧(∀p∈oP,∀v∈oV,(p,v)∈rP−V⇒v∈oV/prime)(4)Rails alsosupportsthedeclaration ofpolymorphic associ-
ations. Thisissimilar totheideaofinterfaces inobject
orienteddesign, where dissimilar things mayhavecommon
characteristics thatareembodiedintheinterface theyim-
plemen t.InRails, polymorphic associations aredeclared by
setting the:polymorphic option onthebelongs_to declara-
tionandthe:asoption onthehas_one orhas_many declara-
tions. Weseetheuseofthe:polymorphic option inFigure 2
betweenTags,Photos andVideos (lines 17,22,25).Photos
andVideos donothaveasub-class relationship butthey
bothcanhaveTags.Theuseofthe:polymorphic option in
theTagclasscreates arelationship whichallowsanyclassto
actasaTaggable objectandrelate totheTagclassviathis
relation. Thisisformalized bydeﬁning asetofobjectsfor
thesupersetandthenexpressing inheritance using subset
constrain ts.Fortheexample above,wedeﬁne anewsetof
objectscalled Taggable (oT),thesuperset, anddeclare that
Video objects(oV)andPhoto objects(oPh)aremutually
exclusiv esubsets oftheTaggable objectsasbelow.Then a
relation canbeformally speciﬁed betweenTagandTaggable
objectsusing ideas discussed earlier.
oV⊆oT∧oPh⊆oT∧oV∩oPh=∅ (5)
Dependency Constr aints. TheﬁnalRails construct we
wanttodiscuss addssome dynamism tothedatamodel.
Itallowsthemodeling ofobjectdeletion atthedatamodel
level.TheRails construct forthisisthe:dependent op-
tion,whichcanbesetforalltherelation declarations ex-
cept:has_and_belongs_to_many .Normally when anobjectis
deleted, itsrelated objectsarenotdeleted. However,byset-
tingthe:dependent option to:destroy or:delete (:delete_all
forhas_many ),deleting anobjectwillalsodelete theasso-
ciated objects. Although there areseveraldiﬀerences be-
tween:destroy and:delete ,theonethatisimportantfor
ourpurposesisthat:delete willdirectly delete theasso-
ciated objectsfromthedatabase without looking attheir
dependencies, whereas :destroy ﬁrstcheckswhether theas-
sociated objectsitselfhasassociations withthe:dependent
option set.
InFigure 2weseethattheUserclasshasthe:dependent
option setfortherelation withtheProﬁle class(line3).
Thus,when aUserobjectisdeleted, theProﬁle objectthat
isassociated withthatUserwillalsobedeleted. Further,
sincethe:dependent option issetto:destroy ,anyrelations
oftheProﬁle classwiththe:dependent option setwillcause
those associated objectstobedeleted aswell.
Formal modeling ofthedependency constrain tsrequires us
tomodelthedelete operation. Consider therelation between
theUserandProﬁle objects. Inorder tomodelthedelete
operation wehavetospecifythesetofUserobjects, the
setofProﬁle objectsandtherelation betweentheUserand
Proﬁle objectsbothbefore andafterthedelete operation
(oU,o/prime
U,oP,o/prime
P,rU−P,and r/prime
U−P,respectively). Then we212needtospecifythatwhen aUserobjectisdeleted, theProﬁle
objectsrelated tothatUserarealsodeleted. Formally:
o/prime
P⊆oP∧o/prime
U⊆oU∧r/prime
U−P⊆rU−P
∧ (∃u∈oU,u/negationslash∈o/prime
U∧(∀u/prime∈oU,u/prime/negationslash=u⇒u/prime∈o/prime
U)
∧ (∀p∈oP,(u,p)∈rU−P⇒p/negationslash∈o/prime
P)
∧ (∀p∈oP,(u,p)/negationslash∈rU−P⇒p∈o/prime
P)
∧ (∀u/prime∈oU,∀p∈oP,((u/prime,p)∈rU−P∧(u,p)/negationslash∈rU−P)
⇒(u/prime,p)∈r/prime
U−P)) (6)
Theconstructs wehavediscussed aboveformtheessence
ofRails datamodels.Similar constructs arealsosupported
byother ORMs suchasCakePHP,whichhastheequivalent
ofthefourbasic Rails association declarations andalldec-
laration options except forthe:polymorphic ,andDjango,
whichhastheabilitytocreate allthree basic relations and
:through relations likeinRails, butnoneoftheremaining
features. Using suchconstructs, adevelopercanspecify
complex relations among objectsofanapplication. Since
atypical application wouldcontaindozens ofobjectclasses
withmanyrelations among them, itispossible tohaveer-
rorsandomissions inthedatamodelspeciﬁcation thatcan
result inunexp ected behaviorsandbugs. Hence, itwouldbe
worthwhile toautomatically verifythedatamodels.Below,
weformalize thedatamodelveriﬁcation problem.
Formalizing Verication Queries. Inorder toformalize
veriﬁcation queries, weﬁrstdeﬁne datamodelinstances and
whatitmeans forthedatamodelinstance tosatisfy agiven
setofdatamodelconstrain ts.
Adatamodelinstance isatuple I=/angbracketleftO,R/angbracketrightwhere O={o1,
o2,...onO}isasetofobjectclasses and R={r1,r2,...rnR}
isasetofobjectrelations andforeachri∈Rthere exists
oj,ok∈Osuchthat ri⊆oj×ok.
Givenadatamodelinstance I=/angbracketleftO,R/angbracketright,wewrite R|=Cto
denote thattherelations inRsatisfy theconstrain tsinC.
Similarly ,giventwoinstances I=/angbracketleftO,R/angbracketrightand I/prime=/angbracketleftO/prime,R/prime/angbracketright
wewrite (R,R/prime)|=Dtodenote thattherelations inRand
R/primesatisfy theconstrain tsinD.
Adatamodelinstance I=/angbracketleftO,R/angbracketrightisaninstanc eofthedata
model M=/angbracketleftS,C,D/angbracketright,denoted byI|=M,ifandonlyif1)
thesetsinOandtherelations inRfollowtheschema S,
and2)R|=C.
Givenapairofdatamodelinstances I=/angbracketleftO,R/angbracketrightand I/prime=
/angbracketleftO/prime,R/prime/angbracketright,(I,I/prime)isabehavior ofthedatamodel M=/angbracketleftS,C,D/angbracketright,
denoted by(I,I/prime)|=Mifandonlyif1)Oand Rand O/prime
and R/primefollowtheschema S,2)R|=Cand R/prime|=C,and3)
(R,R/prime)|=D.
Givenadatamodel M=/angbracketleftS,C,D/angbracketright,wewilldeﬁne fourtypes
ofproperties: 1)state assertions (denoted byAS):these
areproperties thatweexpecttoholdforeachinstance of
thedatamodel;2)behavior assertions (denoted byAB):
these areproperties thatweexpecttoholdforeachpairof
instances thatformabehaviorofthedatamodel;3)state
predicates(denoted byPS):these arepredicates weexpect
toholdinsome instance ofthedatamodel;and,ﬁnally ,4)
behavior predicates(denoted byPB):these arepredicatesweexpecttoholdinsome pairofinstances thatform a
behaviorofthedatamodel.Wewilldenote thatadata
modelsatisﬁes anassertion orapredicate asM|=Aor
M|=P,respectively.Then, wecanusethefollowingformal
deﬁnitions forthese fourtypesofproperties:
M|=AS⇔∀I=/angbracketleftO,R/angbracketright,I|=M⇒R|=AS
M|=AB⇔∀I=/angbracketleftO,R/angbracketright,∀I/prime=/angbracketleftO/prime,R/prime/angbracketright
(I,I/prime)|=M⇒(R,R/prime)|=AB
M|=PS⇔∃I=/angbracketleftO,R/angbracketright,I|=M∧R|=PS
M|=PB⇔∃I=/angbracketleftO,R/angbracketright,∃I/prime=/angbracketleftO/prime,R/prime/angbracketright),
(I,I/prime)|=M∧(R,R/prime)|=PB
Toperform veriﬁcation ofdatamodels,weusetheformal-
ization presen tedabovetoconvertveriﬁcation queries about
thedatamodeltosatisﬁabilit yofformulasinthetheory of
uninterpreted functions. WethenuseanSMT solvertoan-
swertheveriﬁcation queries, aswediscuss next.
3.TRANSLA TION TOSMT
SMT-LIB isthestandard input language forSMTsolvers[18].
Wehaveimplemen tedatranslator thattakesRails Active
Record ﬁlesdescribing thedatamodelasinput andgen-
erates anSMT-LIB speciﬁcation forthedatamodel.The
generated SMT-LIB speciﬁcation consists ofaconjunction of
constrain tsinthetheory ofuninterpreted functions. Inthis
section wedescrib ehowdiﬀeren tActiveRecord constructs
thatdeﬁne thedatamodelcanbetranslated toconstrain ts
inthetheory ofuninterpreted functions.
SMT-LIB speciﬁcations arewritten assequences of
s-expressions. Uninterpreted functions aredeclared using
thedeclare-fun command andtypesaredeclared using the
declare-sort command. Forexample, thespeciﬁcation
(declare-sort Video 0)
(declare-fun isMp4Video (Video) Bool)
declares aVideo type(thattakes0parameters) andaboolean
function calledisMp4Video thataccepts avalueoftypeVideo.
SMT-LIB supportsthebasic boolean operators (not,and,
or),equalit y(=),implication (=>),andif-then-else (ite).
Quantiﬁers areexpressed using theforall andexists op-
erators. Constrain tsarespeciﬁed using thekeywordassert .
After thisshort overview oftheSMT-LIB language syntax,
wenowexplain howwetranslate theformal modelcon-
straintsdiscussed inSection 2toSMT-LIB. Letusﬁrstcon-
siderconstrain t(3)fromSection 2whichcharacterizes the
seman ticsofaone-to-man yrelation declaration. Wetrans-
latetheone-to-man yrelation betweentheProﬁle andPhoto
classes toSMT-LIB using anuninterpreted function as:
(declare-sort Profile 0)
(declare-sort Photo 0)
(declare-fun profile_photo (Photo) Profile)
where aPhoto andaProﬁle objectarerelated ifandonlyif
theprofile_photo function maps onetotheother.
Constrain t(1)inSection 2represen tstheseman ticsofaone-
to-one relation declaration. Wetranslate sucharelation to213SMT-LIB using anuninterpreted function likeabove,but
adding anextra constrain trestricting thecardinalit yofthe
relation. Forexample, theone-to-one relation betweenUser
andProﬁle istranslated as:
(declare-sort User 0)
(declare-sort Profile 0)
(declare-fun user_profile (Profile) User)
(assert (forall ((p1 Profile)(p2 Profile))
(=> (not (=p1p2))
(not (=(user_profile p1) (user_profile p2) ))
)))
Notethattheaboveconstrain tspeciﬁes eachUserisasso-
ciated withoneornoProﬁle andeachProﬁle isassociated
withexactly oneUserasweexpectbased ontheseman tics
oftheone-to-one relation declaration.
Since uninterpreted functions mapeachinput valuetoasin-
glevalueintherange, itisnotpossible torepresen tamany-
to-man yrelation betweentwosetsusing anuninterpreted
function withoneparameter aswedidfortheone-to-one
andone-to-man yrelations. Instead, wetranslate amany-
to-man yrelation declaration toSMT-LIB bydeclaring an
uninterpreted boolean function withtwoargumen tsthatre-
turns trueifandonlyifthetwoobjectspassed inasargu-
mentsarerelated. Forinstance, amany-to-man yrelation
betweentheUserandRoleclasses istranslated as:
(declare-sort User 0)
(declare-sort Role 0)
(declare-fun user_role (User Role) Bool)
Asdiscussed inSection 2,relations thatarethecomposition
ofother relations canbedeclared inadatamodelusing the
:through keywordandconstrain t(4)providesaformalization
ofsuchdeclarations. Forexample, assume thatUsers are
associated withProﬁles, Proﬁles areassociated withPhotos
andthedatamodeldeclares athird relation betweenUsers
andPhotos suchthatitisthecomposition oftheother two
relations. Thisistranslated toSMT-LIB as1:
(declare-sort Profile 0)
(declare-sort Photo 0)
(declare-sort User 0)
(declare-fun profile_photo (Photo) Profile)
(declare-fun user_profile (Profile) User)
(declare-fun user_photo (Photo) User)
(assert (forall ((u User)(ph Photo))
(iff (=u(user_photo ph)) (exists ((p Profile))
(and (=u(user_profile p)) (=p(profile_photo ph)) ))
)))
The:conditions option isusedtoexpress arelationship be-
tweenonesetofobjectsandthesubset ofanother setofob-
jectsandisformalized inconstrain t(5)ofSection 2.Since
there isnosupportforsubtyping orinheritance intheSMT-
LIBlanguage, wemodelthe:conditions option bycreating
aboolean function thatreturns trueifandonlyiftheargu-
mentobjectisinthedesignated subset. Togiveaconcrete
example, sayVideos areassociated withaProﬁle onlyif
theProﬁle isactive.TheSMT-LIB translation ofsucha
declaration wouldbe:
1Theifandonlyifoperator,iff,isusedhereforclarity.
Thiscaneasily beconverted intoadouble implication to
conform totheoﬃcial SMT-LIB setofoperators.(declare-sort Video 0)
(declare-sort Profile 0)
(declare-fun isActive (Profile) Bool)
(declare-fun activeprofile_video (Profile) Video)
(assert (forall ((p Profile)(v Video))
(=> (=v(activeprofile_video p)) (isActive p))
))
Here, theisActive function isusedtocharacterize thesubset
ofProﬁles thatareactive,andtheﬁnalconstrain tensures
thatthefunction activeprofile_video onlyreturns active
Proﬁles.
Next, RailsActiveRecords supportthespeciﬁcation ofpoly-
morphic relations asdiscussed inSection 2andformalized in
constrain t(6).Inorder foronetypetoberelated tomultiple
other types,onecancreate asupertypethattheformer type
canrelate to.Forexample, ifaTagcanberelated toboth
Photos andVideo, wecancreate asupertypeofPhoto and
Video thatTagcanberelated to.Letuscallthissupertype
Taggable andletPhoto andVideo besubtypesofit.As
mentioned earlier, SMT-LIB doesnotsupportsubtyping so
weuseboolean functions tomodelsuchadeclaration. We
alsoaddaconstrain tthatstates theTaggable typeisab-
stract, i.e.allTaggable objectsareeither Photos orVideos,
andthatthese subtypesaremutually exclusiv e:
(declare-sort Tag 0)
(declare-sort Taggable 0)
(declare-fun isPhoto (Taggable) Bool)
(declare-fun isVideo (Taggable) Bool)
(assert (forall ((t Taggable)) (and
(or (isPhoto t)(isVideo t))
(iff (isPhoto t)(not (isVideo t)) )
)))
(declare-fun taggable_tag (Tag) Taggable)
Thisexample showsasimple caseofpolymorphic relations.
Ingeneral, aclassmaybepolymorphically-related tomulti-
pleclasses. Forinstance, Multimedia mayhaveapolymor-
phicrelation withtheVideo andAudio classes. Combined
withthescenario above,Video willnowrequire twosuper-
types(sayTaggable andMultimediaItem). Inourtoolwe
actually create oneultimate supertypecalled Polymorphic-
Class ofwhichanypolymorphically-related typesaresub-
types(suchasPhoto, Video, andAudio) aswellastheir
supertypes(Taggable andMultimediaItem). Allthese sub-
typesareexpressed inSMT-LIB language using boolean
functions. Then anassert isadded whichcontains con-
straintsspecifying whichtypesaresubtypesofwhichsuper-
types,thatsubtypesaremutually exclusiv eofothers inthe
samesupertype,thatthesupertypesthemselv esareabstract
(meaning allelemen tsbelong tooneofitssubtypes),and
thatPolymorphicClass isalsoabstract. Furthermore, since
subtypes(suchasPhoto andVideo) arenottypesoftheir
own(i.e.nosortisdeclared forthem), anynon-p olymorphic
relations withthese classes require anassert thatenforces
therange ofthefunction, similar toconstrain t(5).
Finally ,letusdiscuss delete dependencies thataredeclared
using the:dependent option andformalized withconstrain t
(7)inSection 2.Thistypeofconstrain texpresses achange
fromonestateofthemodel(beforeanobjectisdeleted) to
another (thestateofthemodelaftertheobjectdeleted, i.e.,
post-delete state). Wemodelthepost-delete stateinSMT-
LIBtranslation using boolean functions (denoted withthe
preﬁx “Post”).There isonesuchfunction foreverytype.214Thisfunction returns trueiftheobjectexists afterthedelete
operation. Forexample:
(declare-sort User 0)
(declare-fun Post_User (User) Bool)
There isalsoonesuchboolean function foreveryrelation.
Thisfunction returns trueifandonlyifthetwoobjectsare
stillrelated afterthedeletion occurs. Forinstance:
(declare-fun user_profile (Profile) User)
(declare-fun Post_user_profile (Profile User) Bool)
When onewantstoperform averiﬁcation query abouthow
thedeletion ofanobjectaﬀects other objectsandrelations,
theseboolean functions areusedtoexpress theproperty.For
example, toexpress apropertyaboutdeleting aUser, our
translator generates aconstrain tthatdeﬁnes thePostobject
functions aswellasthePostrelation functions according to
thedependencies expressed inthedatamodel.Thealgo-
rithm togenerate thistakesintoaccoun ttheeﬀect ofdepen-
dencies ontransitiv e,conditional andpolymorphic relations.
Ouralgorithm assumes nocyclic delete dependencies. En-
codingcyclic dependencies requires transitiv eclosure, which
isnotexpressible inthetheory ofuninterpreted functions.
Hereistheconstrain tgenerated byourtranslation algorithm
forthesimple User-Proﬁle scenario ofdeleting aUser, where
xdenotes theUserbeingdeleted:
(assert (not (forall ((x User)) (=> (and
(forall ((a User)) (ite (=ax)
(not (Post_User a)) (Post_User a)))
(forall ((b Profile)) (ite (=x(user_profile b))
(not (Post_Profile b)) (Post_Profile b) ))
(forall ((a Profile) (bUser)) (ite
(and (=b(user_profile a)) (Post_Profile a))
(Post_user_profile ab)
(not (Post_user_profile ab)) ))
);Remaining property-specific constraints gohere
)))
4.DATAMODEL PROJECTION
Ourtoolchecksthecorrectness ofeachveriﬁcation query
separately ,andthiscreates anopportunit yforreducing the
sizeofthegenerated SMT-LIB speciﬁcations. Reducing the
sizeofthegenerated SMT-LIB speciﬁcations reduces the
costofthesatisﬁabilit ycheckandhence increases theper-
formance ofourtool.Thebasicideaisthefollowing: Given
apropertytoverify,wecanreduce thesizeofthegener-
atedSMT-LIB speciﬁcation byremovingthedeclarations
andconstrain tsabouttheparts ofthedatamodelthatdoes
notdependonthepropertythatweareplanning toverify.
Wecallthistechnique property-b aseddata modelprojection.
Weformally deﬁne theproperty-based datamodelprojec-
tionasafunction, denoted byΠ,thattakesadatamodel
andapropertyasinput andreturns anewdatamodel.
Hence, givenadatamodel M=/angbracketleftS,C,D/angbracketrightandapropertyp,
Π(M,p)=Mpwhere Mp=/angbracketleftS,Cp,Dp/angbracketrightistheprojected data
modelsuchthat Cp⊆Cand Dp⊆D.Notethattheprojec-
tionfunction removessomeoftherelational anddependency
constrain tsfromthemodel,therefore reducing thesizeofthe
projected model.Ifthepropertypisastateassertion ora
statepredicate (denoted byASand PSinSection 2),then
theprojection function Πremovesallthedependency con-
straints(i.e., Dp=∅)sincedependency constrain tsareonlyAlgorithm 1DataModelProjection Algorithm
Input: model:Rails ActiveRecords ﬁles; p:property;delclass :the
classname forthedeleted object(only needed when pisabehavior
assertion orpredicate)
Output: Projected SMT-LIB speciﬁcation
pclasses :=listofclasses mentioned in p
prelations :=listofrelations mentioned inp
ifpisabehaviorassertion orpredicate then
Followdependencies fordelclass withrespecttotherelations
giveninprelations
Addanydependen tclasses, andtherelations through which
theyaredependen t,topclasses and prelations
end if
forallclassinpclasses do
Output anuninterpreted function declaration andPostfunction
declaration forclass
ifthere exists arelation inprelations thathasaconditional
relation with class then
Output aboolean function declaration thatmodelsthecon-
ditional subset
end if
end for
Output thepolymorphic constrain tsforthepolymorphic classes in
pclasses
forallrelation inprelations do
Output afunction declaration, anyassociated constrain tsbased
onthedeclaration oftherelation ,andthePostfunction declaration
forthe relation
ifrelation isatransitiv erelation thatisthecomposition of
multiple relations then
Output function declarations, associated constrain ts,and
Postfunction declarations forallrelations thatarepartofthecom-
position
end if
end for
relevantforbehaviorassertions andpredicates (denoted by
ABand PBinSection 2).
Akeypropertyoftheprojection function Πisthatitpre-
servesthecorrectness oftheinput property.Formally ,M|=
p⇔Π(M,p)|=p,foranypropertyp.
Letusnowexplain whythispropertyholds. Inourveri-
ﬁcation approac h,allveriﬁcation queries aretranslated to
satisﬁabilit yqueries. Hence, theabovepropertyisequiva-
lenttostating thattheSMT-LIB speciﬁcation wegenerate
fromtheoriginal model Mandthepropertypissatisﬁable
ifandonlyiftheSMT-LIB speciﬁcation wegenerate from
theprojected modelΠ(M,p)andthepropertypissatisﬁ-
able. Notethat, iftheSMT-LIB speciﬁcation wegenerate
fromthemodelΠ(M,p)andthepropertypisnotsatisﬁable,
thentheSMT-LIB speciﬁcation wegenerate fromtheorigi-
nalmodel Mandthepropertypcannot besatisﬁable since
theprojection operation Π(M,p)onlyremovesconstrain ts,
resulting inalessconstrained SMT-LIB speciﬁcation. How-
ever,ourprojection algorithm alsoguaran teesthatifthe
SMT-LIB speciﬁcation wegenerate fromthemodelΠ(M,p)
andthepropertypissatisﬁable, thentheSMT-LIB spec-
iﬁcation wegenerate from theoriginal model Mandthe
propertypisalsosatisﬁable. Thisistrueduetotworea-
sons: 1)Theconstrain tsthattheprojection function deletes
fromtheoriginal modelcanneverbeself-con tradictory since
theycorresp ondtoclassandrelation declarations, anditis
notpossible todeclare aself-con tradictory datamodelthat
doesnotallowanyinstances using theconstructs weana-
lyze;2)Theconstrain tsthattheprojection function deletes
fromtheoriginal modelcannot contradict withtheveriﬁed
propertypsincetheprojection algorithm onlydeletes aclass215orarelation ifthatclassorrelation hasnoinﬂuence onthe
propertyp.
Weimplemen tedthisproperty-based datamodelprojection
aspartofourveriﬁcation tool.Thealgorithm usedisgiven
inAlgorithm 1.Itrequires asinput theRails datamodel
andthepropertytheuserwishes toverifyaboutthedata
model.Ifthepropertyisabehaviorpredicate orassertion,
italsorequires theclassname fortheobjecttobedeleted.
Theprojected SMT-LIB speciﬁcation output bythetrans-
latorcontainsconstrain tsononlythose classes andrelations
thatareexplicitly mentioned inthepropertyandtheclasses
andrelations thatarerelated tothem based ontransitiv e
relations, dependency constrain tsorpolymorphic relations.
5.EXPERIMENTS
Weusedﬁveopen-source RubyonRailswebapplications for
evaluating theeﬀectiv eness ofourSMT-based unbounded
datamodelveriﬁcation approac h.Wewrote tenproperties
abouteachapplication’s datamodelthatweexpected to
holdbased ontheseman ticsoftheapplication. Then using
ourtool,wegenerated anSMT-LIB speciﬁcation foreach
application. Thisspeciﬁcation isconjoined withaproperty
andthensenttotheSMT solverforsatisﬁabilit ycheck.
WeusedMicrosoft’s SMTsolver,Z3[20],inourexperimen ts.
Inaddition toreturning unsatisﬁable orsatisﬁable, anSMT
solvermayalsoreturn “unkno wn”oritmaytimeout since
thequantiﬁed theory ofuninterpreted functions isknownto
beundecidable [4].Inourexperimen tsthetimeout limit
wassettoﬁveminutes.
Assertions thatareveriﬁed using ourapproac hareguar-
anteedtoholdintheapplication. However,assertions that
failmayormaynotholdintheapplication—the veriﬁcation
results simply indicate thatthepropertywasnotenforced
bytheapplication’s datamodel.Itmaynotbepossible to
observ ethefailure during program execution sincetheprop-
ertymayactually beenforced inpartsoftheapplication that
wedonotmodel(e.g.,intheController code).However,we
consider afailed propertyadatamodelerroriftheproperty
could havebeenenforced statically inthedatamodelbut
wasnot.Ontheother hand, ifafailed propertycannot be
enforced inthedatamodelusing theRubyonRails con-
structs, thenwedonotconsider itadatamodelerror. Thus
forproperties thatfailed weperformed further manualin-
vestigation toidentifywhichfailing properties wereindeed
datamodelerrors.
TheApplications. Table1liststhesizesoftheﬁveappli-
cations interms oflinesofcode,thenumberofclasses, and
thenumberofdatamodelclasses. OpenSourceRails (OSR)
(http://www.op ensourcerails.com) isasocialprojectgallery
application thatallowsusers tosubmit projects, aswellas
bookmark andratethem. Tracks(http://geton tracks.org/)
isanapplication thatletsusers create andmanage to-do
lists,where listscanbeorganized bycontextandproject.
FatFreeCRM (http://www.fatfreecrm.com/) isacustomer
relationship managemen tsoftwarethatorganizes abusiness’
customers, campaigns, opportunities, and accoun ts.
Substruct (http://co de.google.com/p/substruct/) isane-
commerce application where userscanaddproducts tocartandcreate wishlists. LovdByLess (http://lo vdbyless.com/)
isasocialnetworking sitewiththeusual features suchas
userproﬁle withpictures, becoming friends, etc.
Table1:SizesoftheApplications
LOC Classes DataModels
LovdByLess 3787 61 13
Tracks 6062 44 13
OSR 4295 41 15
FatFreeCRM 12069 54 20
Substruct 15639 85 17
Verication Results. Theproperties wecheckedonthese
applications arelisted inTable2,along withtheirtypefrom
Section 2.
Theresults oftheveriﬁcation arealsoshowninTable2.
/checkindicates thatthepropertywasveriﬁed and×indicates
thatitfailed. Atotalofsixteen properties wetriedtoverify
failed. Weinvestigated eachofthese failures manually to
determine iftheycorresp ondtodatamodelerrors.
Forexample, PropertyL5fromLovdByLess doesnothold
duetothelimited expressiv eness inRails constructs. There
isnoconstruct thatallowsyoutoaddaconstrain ttoa
relation expressing thatanobjectcannot berelated toitself.
Thustheapplication programmer inLovdByLess hadtoadd
avalidation function tothemodeltoensure thatauser
cannot create aFriend request forherself. Thusthefailure
ofthepropertyL5doesnotindicate adatamodelerror.
Another propertythatfailed waspropertyO2.Thesetup
inOpenSourceRails isthatausercanbookmark projects,
soaUserhasmanyBookmarks, aBookmark belongs toa
Project,andaProjecthasmanyBookmarks. Theproperty
O2states thataUserisallowedtoBookmark aProjectat
mostonce. However,thedeclarations usedtosetupthesere-
lationships allowthesameusertocreate multiple bookmarks
withthesame Project. Thustheapplication programmer
hadtoenforce thispropertyusing theuserinterface andcode
inthecontroller. However,what theprogrammer desires is
amany-to-man yrelationship betweenUserandProject,as
opposedtotwoone-to-man yrelationships. Onereason for
suchasetup isiftheywantedtoholdextra information in
theBookmark class. Investigation intothisclassshowsthat
thisisnotthecase;hence thiscorresp ondstoadatamodel
errorinthisapplication.
Afailing propertyindicates theapplication’s datamodel
doesnotsatisfy theproperty;however,thepropertymay
stillholdintheoverallapplication because thepropertyis
beingenforced outside ofthedatamodel,asinpropertyO2.
However,thiswasnotthecaseforpropertyO6.Thisprop-
ertyfailed because thedeclaration intheUsermodeldoes
nothavethe:dependen toption set.ThusaUser’s associ-
atedBookmarks arenotdeleted, causing thepropertyto
fail.Because thedeletion ofauserleavesorphaned Book-
marks inthedatabase, propertyO6isanexample ofadata
modelerrorthatisalsoanerrorintheapplication.
Intotalwediscoveredelevendatamodeling errors fromthe
sixteen properties thatfailed. There weretwodatamodel216errors inLovdByLess, three eachinTracksandOSR, onein
Substruct andtwoinFatFreeCRM. Thefactthatwewere
abletodiscoverdatamodelerrors inreal-w orldapplications
isevidence thatourapproac hcanbeaneﬀectiv everiﬁcation
approac hinpractice.
Performance. Tofurther evaluate theeﬀectiv eness ofour
approac h,wemeasured performance oftheveriﬁcation task.
Speciﬁcally ,wemeasured theveriﬁcation timereported by
Z3andthenumberofvariables andclauses produced in
theSMT speciﬁcation. Bynumberofvariables wemean
thenumberofsorts, functions, andquantiﬁed variables. By
numberofclauses wemean thenumberofasserts, quantiﬁers
andoperations intheSMT-LIB speciﬁcation.
Themeasuremen tsweretakenfortheSMT-LIB speciﬁcation
generated foreachproperty.Thevalueswerethenaveraged
overtheproperties foreachapplication. Theresults forthe
veriﬁcation times aregiveninTable3.What weimmedi-
ately noticed isthattheveriﬁcation isextremely fast;the
longest veriﬁcation timeisjust0.025 seconds. Onething to
noteisthatthese values donotinclude thetimes forthose
properties thattimed outduring veriﬁcation. There were
foursuchproperties, allforFatFreeCRM. Soalthough un-
bounded veriﬁcation isveryquick,thedisadv antageisthat
some properties maynotgiveananswertotheveriﬁcation
query.
Thediﬃcult ytheSMT solverishavingwhen ittimes outis
duetothenumberofquantiﬁers intheSMT speciﬁcation.
Tominimize thisnumberwerantheexperimen tsagain, this
timeusing thedatamodelprojection algorithm discussed in
Section 4.With projection wewereabletoobtain answers
toalloftheproperties thattimed out.Furthermore, the
veriﬁcation timedecreased forallproperties, asshownin
Table3.Onaverage theveriﬁcation timedecreased by40%
afterusing datamodelprojection.
Tocompare eﬀectiv eness betweenbounded andunbounded
veriﬁcation, weused theAlloyAnalyzer [13]toverify
thesame setofproperties. Thedatamodelsofallﬁve
applications wererunthrough theActiveRecord toAlloy
translator thatwasimplemen tedinourprevious work[16].
Thesamemeasuremen tsweretakenaswithZ3,butoveran
increasing bound fromatmost10objectsforeachclassto
atmost35objectsforeachclass. These valueswereplotted
alongside theZ3veriﬁcation timeforeachapplication where
thesolverdidnottimeout.AsseeninFigure 3,unbounded
veriﬁcation ismuchfaster thanbounded veriﬁcation, even
forthesmallest bound of10objects. Bounded veriﬁcation
using Alloytookuptotensofseconds whereas Z3,tookless
thanasecond. However,sinceZ3isnotguaran teedtoter-
minate because wearegenerating SMT-LIB speciﬁcations
inthetheory ofuninterpreted functions withquantiﬁcation,
weobserv ethatbounded andunbounded veriﬁcation canbe
complemen taryapproac hessince bounded veriﬁcation can
beusedwhen theunbounded approac hfails.
Since Alloyspecializes intheveriﬁcation ofobjectmodels,
itisrather surprising thatthere issuchadrastic diﬀerence
betweentheveriﬁcation times ofZ3andAlloy.There may
beseveralreasons whyunbounded veriﬁcation didsowell.Table2:Veriﬁcation Results
LovdByLess Prop erties
ASL1.AForum Postisalwaysassociated withaTopic /check
PSL2.AForum TopicmayhavenoForum Posts /check
ASL3.APhoto isalwaysassociated withauserProﬁle /check
ASL4.Proﬁle’s FeedItems =Proﬁle’s Feed’sFeedItems /check
ASL5.AUsercan’tbeherownFriend ×
ABL6.Deleting userProﬁle deletes Photos ×
ABL7.Deleting userProﬁle doesn’tdelete anyFriends /check
ABL8.Deleting auserProﬁle leavesnoorphan Users ×
ABL9.Deleting aMessage doesn’tdelete aUser /check
ABL10.Deleting aForum Topicleavesnodangling
Forum Posts /check
TracksProp erties
AST1.EveryTodohasaContext /check
PST2.AContextmayhavenoTodos /check
PST3.Todocanhavenoassociated Project ×
AST4.Note’s User=Note’s Project’s User ×
AST5.EveryUserhasaPreference ×
ABT6.Deleting aProjectleavesnodangling Notes /check
ABT7.Deleting aPreference leavesnoorphan Users ×
ABT8.Deleting aUserleavesnodangling Contexts /check
ABT9.Deleting aUserleavesnodangling Projects /check
ABT10.Deleting aContextleavesnodangling Todos /check
OSR Prop erties
PSO1.AProjectcanhavemultiple Screenshots /check
PSO2.AUsercanBookmark aProjectatmostonce ×
PSO3.AUsercanBookmark herownsubmitted
Project /check
ASO4.Project’s Bookmark’s User=Project’s User /check
PSO5.AUsercanputmultiple Commen tsonone
Project /check
ABO6.Deleting aUserdeletes herBookmarks ×
ABO7.Deleting aUserdeletes herActivities ×
ABO8.Deleting aUserdoesn’tdelete herCommen ts /check
ABO9.Deleting aProjectdeletes itsRatings ×
ABO10.Deleting aProjectRating doesn’tdelete Project/check
Substruct Prop erties
ASS1.EveryCartisassociated withaUser /check
PSS2.AnProductcanbeonmultiple Wishlists /check
PSS3.AWishlist canbeempty /check
ASS4.AProductisonaUser’s Wishlist atmostonce ×
PSS5.AUsercanhavemultiple Orders /check
ABS6.Deleting aCartdoesn’tdelete itsProducts /check
ABS7.Deleting aProductdeletes itfromallCarts ×
ABS8.Deleting aUserdeletes herOrders ×
ABS9.Deleting Userdoesn’tdelete Items onher
Wishlists /check
ABS10.Deleting aWishlist doesn’tdelete itsItem /check
FatFreeCRM Prop erties
ASF1.EveryTaskmusthaveaUser /check
ASF2.EveryLeadbelongs toexactly oneUser /check
ASF3.Accoun tOpportunit y’sOpportunit y=
Accoun tOpportunit y’sAccoun t’sOpportunit y /check
PSF4.AContactmayhavenoTasks /check
ASF5.User’s Opportunit y=User’s Campaigns’
Opportunit y ×
ABF6.Deleting aLeaddoesnotdelete Contacts /check
ABF7.Deleting Leaddoesnotdelete User /check
ABF8.Deleting anAccoun tdeletes associated Tasks /check
ABF9.Deleting aLeadleavesnodangling Contacts ×
ABF10.Deleting anAccoun tdoesnotdelete Contacts /check
Table3:Z3Veriﬁcation Times inseconds
notprojected projected
LovdByLess 0.025 0.015
Tracks 0.023 0.014
OSR 0.016 0.012
Substruct 0.025 0.011
FatFreeCRM 0.022 0.013217Figure 3:Veriﬁcation Time, AlloyvsZ3
Z3usesmanyheuristics toeliminate quantiﬁers informulas.
ItusesanE-graph toinstan tiatequantiﬁed variables which,
inconjunction withcodetrees, aninverted pathindex and
eager instan tiation, makesitveryeﬀectiv eatdealing with
quantiﬁers [8].Notethatthese heuristics donotaﬀect the
soundness oftheveriﬁcation. Another reason whyZ3per-
formed betterthanAlloymaybeduetotheirimplemen ta-
tionlanguages: Z3isimplemen tedinC++ whereas Alloy
(aswellastheSATsolverituses,SAT4J)isimplemen tedin
Java.Finally ,another likelyreason thatZ3ismoreeﬃcien t
thanAlloyisthatSMT solversoperate atahigher levelof
abstraction thanSATsolvers.ThusSMT solverscanuse
information aboutthestructure andseman ticsofaformula
tomakeinferences aboutsatisﬁabilit ymore accurately as
wellasmore eﬃcien tlythanaSAT-based approac hwhich
convertstheveriﬁcation toSATformulasusing aBoolean
encoding. Infact,duetoincreasing sizeoftheBoolean
encoding, bounded veriﬁcation suﬀers fromanexponential
increase inveriﬁcation timewithincreasing bound.
Besides veriﬁcation time, wealsomeasured thenumberof
clauses andvariables created byAlloy’sSATtranslation.
These measuremen tswereaveraged overtheproperties for
eachapplication andplotted overincreasing scope,asshown
inFigure 5.
Thenumberofclauses andvariables werealsoaveraged over
properties fortheSMT-LIB speciﬁcations foreachapplica-
tion. InFigure 4isaplotofthenumberofclauses and
variables inthespeciﬁcations foreachapplication. Boththe
projected andnon-pro jected versions ofthespeciﬁcations
areshown.Weseeatremendous 80%decrease inthenum-
berofvariables andclauses afterperforming thedatamodel
projection. Although thenumberofvariables andclauses
Figure 4:FormulaSize,SMT
Figure 5:FormulaSize,Alloy
intheSMT speciﬁcation arenotdirectly comparable tothe
ﬁgures produced byAlloy,wecanstillobserv ethattheSMT
formulasizeismuchsmaller thantheoneusedbytheSAT
solver.Wealsoobserv ethatbounded veriﬁcation hasthe
disadv antagethatthesizeoftheformulausedbytheSAT
solverincreases exponentially withrespecttobound.
Overallourexperimen talresults indicate thatunbounded
veriﬁcation using SMTsolversismoreeﬃcien tthanbounded
veriﬁcation. Thisleadsustoconclude thattheapproac hwe
presen tedinthispaperisafeasible andeﬃcien tapproac h
todatamodelveriﬁcation.
6.RELA TED WORK
There hasbeenpriorworkontheveriﬁcation ofdatamod-
els;these workspresen tbounded veriﬁcation approac hesus-
ingtheAlloyAnalyzer. Forexample, mapping relational
database schemas toAlloyhasbeenstudied before[7].Also,
translating ORA-SS speciﬁcations (adatamodeling language
forsemi-structured data) toAlloyandusing Alloyanalyzer
toﬁndaninstance oftheinput datamodelhasbeeninvesti-
gated [19].However,unlikeourwork,these approac hesare
bounded whereas ourtechnique performs unbounded veriﬁ-
cation. Alsothetranslation isnotautomated intheseearlier
eﬀorts. Finally ,Alloyhasalsobeenusedfordiscoveringbugs
inwebapplications related tobrowserandbusiness logicin-
teractions [3].Thisisadiﬀeren tclassofbugsthanthedata
modelrelated bugswefocusoninthispaper.
There hasbeensomerecentworkonunbounded veriﬁcation
ofAlloyspeciﬁcations using SMTsolvers[9],buttothebest
ofourknowledge thisapproac hhasnotbeenimplemen ted
yet.Unbounded veriﬁcation ofAlloyspeciﬁcations maybe
more challenging thanthedatamodelveriﬁcation problem
thatwefocusoninthispapersincetheAlloylanguage pro-
vides powerfulconstructs suchastransitiv eclosure. Such218constructs donotappearinthedatamodelsthatweextract
fromwebapplications.
There hasbeenrecentworkonspeciﬁcation andanalysis of
conceptual datamodels[17,15,11].These eﬀorts followthe
model-driv endevelopmen tapproac hwhereas ourapproac h
isareverseengineering approac hthatextracts themodelof
anexisting application andanalyzes ittoﬁnderrors.
There areearlier results ontheformal modeling ofwebappli-
cations focusing onstatemachine-based formalisms tocap-
turethenavigation behavior(forexample, [12,2,10]).In
contrasttothislineofwork,wearefocusing onanalysis of
thedatamodelrather thanthenavigational aspectsofthe
webapplications.
There hasbeenearlier workonreducing thecostofauto-
mated veriﬁcation byanalyzing dependencies suchascone
ofinﬂuence reduction [1]andprogram analysis based reduc-
tions[5].Compared tothese earlier results, ourprojection
algorithm isaspecialized reduction technique fordatamodel
veriﬁcation thatutilizes thedatamodelseman tics.
Thefactthatveriﬁcation withSMT solverscanbemore
eﬃcien tthanSAT-based bounded veriﬁcation hasbeenob-
servedinother veriﬁcation domains [6].However,thedata
modelveriﬁcation problem weinvestigate inthispaperis
diﬀeren tfromtheproblems studied inthese earlier works.
Thispaperbuilds onourearlier workonbounded veriﬁ-
cation ofRails datamodels[16]. There areseveralsignif-
icantdiﬀerences inthispapercompared totheworkpre-
sentedin[16]:1)Inthispaperweuseanunbounded ver-
iﬁcation approac hbased onSMT-solv ersasopposedtothe
bounded SAT-based veriﬁcation approac husedin[16]. 2)
Thispaperdirectly constructs formulasinthetheory ofun-
interpreted functions fromveriﬁcation queries aboutagiven
Rails datamodel,whereas theapproac hpresen tedin[16]
translates datamodelstoAlloyspeciﬁcations whichAlloy
Analyzer thenconvertstoboolean SATformulas. 3)We
presen tanoveldatamodelprojection technique thatsim-
pliﬁes thegenerated formulabyremovingconstrain tsabout
thedatamodelthatarenotrelevanttothepropertybe-
ingveriﬁed, impro vingtheperformance oftheanalysis. 4)
Wepresen texperimen talanalysis demonstrating theperfor-
mance oftheproposedveriﬁcation approac honﬁveopen
source Rails applications. 5)Weexperimen tallycompare
theunbounded veriﬁcation approac hpresen tedinthispaper
withthebounded veriﬁcation approac hpresen tedin[16]and
showthattheunbounded veriﬁcation approac hpresen tedin
thispaperismore eﬃcien t.
7.CONCLUSION
Wepresen tedanunbounded veriﬁcation approac hforweb
application datamodels.Weautomatically extract aformal
datamodelfromtheORM speciﬁcations inMVC-based web
applications andtranslate veriﬁcation queries aboutthese
modelstosatisﬁabilit yqueries inthetheory ofuninterpreted
functions. WeuseanSMT solvertocheckthesatisﬁabilit y
oftheresulting formulas. Thisapproac hwasimplemen ted
inatoolthatveriﬁes Rails datamodels. Ourexperimen ts
demonstrate thatourapproac hiseﬀectiv einverifying datamodelsofreal-w orldwebapplications, andthatitismore
eﬃcien tthanSAT-based bounded veriﬁcation.
8.REFERENCES
[1]S.Berezin, S.V.A.Camp os,andE.M.Clarke.
Comp ositional reasoning inmodelchecking.InProc.
COMPOS ,pages 81–102, 1997.
[2]M.BookandV.Gruhn. Modeling web-based dialog
ﬂowsforautomatic dialog control.InProc.ASE,
pages 100–109, 2004.
[3]B.Bordbar andK.Anastasakis. MDAandanalysis of
webapplications. InProc.Work. Trends inEnterprise
Appl. Arch.,pages 44–55, 2005.
[4]R.E.Bryant,S.M.German, andM.N.Velev.
Exploiting positiveequalit yinalogicofequalit ywith
uninterpreted functions. InProc.CAV,pages 470–482,
1999.
[5]J.C.Corbett,M.B.Dwyer,J.Hatcliﬀ, andRobby.
Bandera: asource-lev elinterface formodelchecking
javaprograms. InProc.ICSE,pages 439–448, 2000.
[6]L.Cordeiro, B.Fischer,andJ.Marques-Silv a.
SMT-based bounded modelcheckingforembedded
ANSI-C software.InProc.ASE,pages 137–148, 2009.
[7]A.Cunha andH.Pacheco. Mapping betweenAlloy
speciﬁcations anddatabase implemen tations. InProc.
SEFM ,pages 285–294, 2009.
[8]L.M.deMoura andN.Bjørner. Eﬃcien te-matc hing
forSMT solvers.InProc.CADE ,pages 183–198, 2007.
[9]A.A.E.Ghazi andM.Taghdiri. Relational reasoning
viaSMT solving. InProc.FM,pages 133–148, 2011.
[10]S.Hall´e,T.Ettema, C.Bunch,andT.Bultan.
Eliminating navigation errors inwebapplications via
modelcheckingandruntimeenforcemen tofnavigation
statemachines. InProc.ASE,pages 235–244, 2010.
[11]T.Halpin andT.Morgan. Information Modeling and
Relational Datab ases.Morgan Kaufmann, 2008.
[12]M.HanandC.Hofmeister. Relating navigation and
request routing modelsinwebapplications. InProc.
MoDELS ,pages 346–359, 2007.
[13]D.Jackson. Alloy:Alightweightobjectmodelling
notation. ACM Trans. Softw. Eng. Meth. ,
11(2):256–290, 2002.
[14]G.E.Krasner andS.T.Pope.Acookbookforusing
themodel-view controller userinterface paradigm in
smalltalk-80. Jour. Obje ct-Orient. Program.,
1(3):26–49, 1988.
[15]M.J.McGill, L.K.Dillon, andR.E.K.Stirew alt.
Scalable analysis ofconceptual datamodels.InProc.
ISST A,pages 56–66, 2011.
[16]J.Nijjar andT.Bultan. Bounded veriﬁcation ofRuby
onRails datamodels.InProc.ISST A,pages 67–77,
2011.
[17]Y.Smaragdakis, C.Csallner, andR.Subramanian.
Scalable satisﬁabilit ycheckingandtestdata
generation frommodeling diagrams. Autom. Softw.
Eng.,16(1):73–99, 2009.
[18]SMT-LIB. http://www.sm tlib.org/.
[19]L.Wang,G.Dobbie, J.Sun,andL.Groves.
Validating ORA-SS datamodelsusing Alloy.InProc.
ASWEC ,pages 231–242, 2006.
[20]Z3.http://researc h.microsoft.com/pro jects/z3/.219