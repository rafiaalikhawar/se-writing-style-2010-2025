See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/254040877
Improving early detection of software merge conï¬‚icts
Article Â Â  inÂ Â Proceedings - Int ernational Conf erence on Softw are Engineering  Â· June 2012
DOI: 10.1109/IC SE.2012.6227180
CITATIONS
92READS
567
2 author s:
MÃ¡rio Guimar Ã£es
Univ ersity of Lisbon
4 PUBLICA TIONS Â Â Â 163 CITATIONS Â Â Â 
SEE PROFILE
AntÃ³nio Rit o Silv a
Univ ersity of Lisbon
143 PUBLICA TIONS Â Â Â 1,460  CITATIONS Â Â Â 
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y AntÃ³nio Rit o Silv a on 10 July 2014.
The user has r equest ed enhanc ement of the do wnlo aded file.Improving Early Detection of Software Merge Conï¬‚icts
MÂ´ario Lu Â´Ä±s Guimar Ëœaes and Ant Â´onio Rito Silva
Department of Computer Science and Engineering
INESC-ID, IST, Technical University of Lisbon
Lisbon, Portugal
fmario.guimaraes, rito.silva g@ist.utl.pt
Abstract â€”Merge conï¬‚icts cause software defects which if
detected late may require expensive resolution. This is espe-
cially true when developers work too long without integrating
concurrent changes, which in practice is common as integration
generally occurs at check-in. Awareness of othersâ€™ activities was
proposed to help developers detect conï¬‚icts earlier. However, it
requires developers to detect conï¬‚icts by themselves and may
overload them with notiï¬cations, thus making detection harder.
This paper presents a novel solution that continuously
merges uncommitted and committed changes to create a
background system that is analyzed, compiled, and tested to
precisely and accurately detect conï¬‚icts on behalf of developers,
before check-in. An empirical study conï¬rms that our solution
avoids overloading developers and improves early detection of
conï¬‚icts over existing approaches. Similarly to what happened
with continuous compilation, this introduces the case for
continuous merging inside the IDE.
Keywords -version control; merge conï¬‚icts; awareness;
continuous merging
I. I NTRODUCTION
Because of productivity, today almost all software systems
are built by teams of programmers working in parallel.
In this context, software merging concerns the creation of
a version of the system that integrates the intentions of
concurrent changes.
In general, developers modify private working copies of
the system to ensure stability during programming. How-
ever, this prevents them from knowing what co-workers are
doing which may affect private work. Therefore, conï¬‚icts
emerge due to concurrent work, and become more complex
as changes grow without being integrated and as further
developments are made. Consequently, the later conï¬‚icts
are detected, the harder it is to resolve them because more
code must be reworked. Besides, a conï¬‚ict detected late is
generally harder to resolve since the changes that caused it
are no longer fresh in developersâ€™ minds [1], [2].
In a ï¬eld study, Perry et al. [3] concluded that the number
of software defects increase with parallel work, which was
found to be considerable and inadequately supported by
tools. Their conclusions remain valid today as parallel work
increases with the growing distribution of software teams,
which still use tools and processes similar to those found in
their study.In a recent work, Brun et al. [4] studied nine of the
most active open source projects in GitHub (http://github.
com), and concluded that even with modern version control
systems, like Git (http://git-scm.com), merge conï¬‚icts are
â€œfrequent, persistent, and appear not only as overlapping
textual edits but also as subsequent build and test failuresâ€.
Industry experts have proposed several best practices to
control merge conï¬‚icts, like Continuous Integration [2], [5],
which recommends frequent merges and check-ins to avoid
conï¬‚icts staying undetected for too long. Unfortunately,
merging is cumbersome and disrupts programming ï¬‚ow, so
some developers do not merge as frequently as desirable
â€” teams avoid parallel work because of difï¬cult merges
[6], and developers rush their tasks to avoid being the ones
responsible for the merge [7].
To support developers, awareness [8] of co-workersâ€™ ac-
tivities helps break the isolation of private work by informing
developers where in the code their co-workers are currently
making changes. This information can be used by the
developer to detect conï¬‚icts earlier. However, because of the
complex semantics of todayâ€™s programming languages, like
polymorphism and late binding, it is very hard for developers
to detect conï¬‚icts by themselves while they are program-
ming. In addition, awareness may overload developers with
too much information, thus making detection of conï¬‚icts
harder [9], [10], [11].
This paper presents a novel solution that reduces the
amount of information developers have to digest. The
present solution continuously merges uncommitted and com-
mitted changes to create a background system that is an-
alyzed, compiled, and tested to detect conï¬‚icts with high
precision and accuracy on behalf of developers, while they
are programming, that is, before check-in. Detected conï¬‚icts
are then presented to the affected developers inside the IDE.
In comparison to our initial paper [12], this details the
evolution of our solution, presents our full-ï¬‚edged tool, and
its empirical evaluation using controlled user experiments.
The contributions of this paper are the following:
a novel solution that introduces continuous merging
inside the IDE, much like to continuous compilation;
an empirical evaluation which provides quantitative and
qualitative evidence that our solution improves early
detection of conï¬‚icts when compared with existingapproaches based on change and dependency-based
awareness.
Subsequent sections are summarized as follows. Section II
motivates the need to detect conï¬‚icts early. Section III
explains the limitations of existing awareness approaches
to this problem, and Section IV describes our solution.
Section V presents the implementation of our solution in
Eclipse, and Section VI reports an empirical evaluation that
sustains our solution. Section VII lists the related work, and
Section VIII concludes.
II. M OTIVATION
The need to detect conï¬‚icts early was determined by
industry and research and it is illustrated next.
Suppose that Mike, Anne, and Bob check out the same
working copy of the Zoo application from their mainstream
Version Control System (VCS). Mike Â¶changes class
Mammal to extend Animal, and commits. Simultaneously,
AnneÂ·creates class Primate by extending Mammal, and
adds â€œPrimate.move(int x, int y)â€ to move primates to
location â€œ(x,y)â€. Then, she does a clean merge with Mikeâ€™s
changes at the head of the repository, and commits. Mean-
while, Bob Â¸adds method â€œAnimal.move(int dx, int dy)â€ to
move animals by some distance from their current location,
updates his working copy with Mikeâ€™s and Anneâ€™s changes
at the head, and ï¬nally commits. Note that all VCS merges
were clean because the developers changed different ï¬les,
though a merge conï¬‚ict exists in the ï¬nal state at the head,
shown in Fig. 1.
Animal
-px: int
-py: int
+move(int dx, int dy)Mammal
Primate
-x: int
-y: int
+move(int x, int y)1
23
Figure 1. The ï¬nal merge at the head.
The merge conï¬‚ict is an unexpected override between the
methods added by Anne and Bob, and at runtime it will
cause the following bug: when method â€œAnimal.move(int
dx, int dy)â€ is invoked on a primate, this will move to
location â€œ(dx,dy)â€ instead of moving distance â€œ(dx,dy)â€ from
its current location, as expected for all animals.
Note that this conï¬‚ict is very difï¬cult to ï¬nd. Only
Bob could detect it since after merging Mikeâ€™s and Anneâ€™s
changes from the head only his working copy has the
conï¬‚ict. Nevertheless, the VCS told him that the merge was
â€œcleanâ€, so he does not suspect his co-workersâ€™ changes.
Besides, he had to merge other ï¬les, making him overlookthose of Mike and Anne. He even had a test for Animal,
which ran successfully before he checked in. However, it did
not consider primates because Bob did not know about that
class when he wrote the test. Or all he wanted was to rush
his check-in. Unfortunately, the bug will enter production,
and further developments will be made on top of broken
code.
Eventually, the bug will be found and the developers will
have to resolve it. They will have to remember what they
did before, determine the impact of the bug on other parts of
the code, and decide what to do. All this certainly takes time
because the changes are no longer fresh in their minds. At
least they will have to remove one of the duplicated points,
rename one of the â€œmoveâ€ methods, and change where in
the code there are dependencies on the removed point and
renamed method. Although simple, this example shows that
conï¬‚icts can be difï¬cult to detect and are costly to resolve
when found late.
III. P ROBLEM
Would it not be helpful to detect the above conï¬‚ict as it
emerges during programming and avoid all that rework?
Awareness, deï¬ned as â€œan understanding of the activities
of others, which provides a context for your own activityâ€
[8], has been suggested to help developers detect conï¬‚icts
early [13], [14], [15], [16]. In general, these proposals use
presence and change awareness.
Presence awareness informs where others are looking in
the code [13], which may be useful to ï¬nd co-workers for
collaboration, though it does not help with conï¬‚ict detection.
Change awareness informs where changes are being made
in the code, which may help detect conï¬‚icts early. However,
reporting which ï¬les, types, or program elements are being
changed may overload developers with notiï¬cations that
are irrelevant to what they are doing [9], [10], [11]. Some
of these tools use dependency-based awareness [13], [14],
[15], and notify when two ï¬les, types, or program elements,
connected by a path of dependencies (e.g., â€œextendsâ€ and
â€œcallsâ€) with length n0, have been simultaneously
changed by the developer and a co-worker. Their idea is
to reduce the number of notiï¬cations to help developers
focus on the most relevant ones, which may indicate a
conï¬‚ict with co-workers. For example, instead of notifying
concurrent changes in every ï¬le, some tools only notify
concurrent changes to the dependencies of ï¬les changed by
the developer.
Notwithstanding, dependency-based awareness does not
prevent developers from being overloaded, especially when
the choice of granularity in the tool is that of ï¬le or type
level â€” for example, it causes false direct conï¬‚icts ( n= 0)
and false indirect conï¬‚icts ( n > 0) because of concurrent
changes to independent program elements in the same type
or dependent types, respectively. In addition, developers still
have to investigate the notiï¬cations to determine if theybear any conï¬‚ict, thus stealing time from programming.
Unfortunately, it can be difï¬cult for developers to detect
conï¬‚icts by themselves because of the complex interdepen-
dencies between program elements, like polymorphism and
late binding. For example, in Fig. 1, it is unlikely that Mike
upon receiving the notiï¬cations â€œ(Primate, Mammal)â€ and
â€œ(Mammal, Animal)â€ would be able to correlate them to
discover an unexpected override, especially if he is busy
and tired of irrelevant notiï¬cations.
IV. S OLUTION
Our solution continuously merges all uncommitted and
committed changes inside a software team to create a
background system that is analyzed, compiled, and tested
to precisely and accurately detect conï¬‚icts on behalf of
developers before check-in. This introduces the case for
continuous merging inside the IDE, similarly to the current
experience of continuous compilation.
A. Collaborating inside Teams
The model of our solution is that of a team of program-
mers working along a development line (orbranch ) [1] in a
VCS, as shown in Fig. 2.
Outside collaborators
Development
LineAnne Bob
Merged
System
Figure 2. The Team Model.
Ateam comprises a set of members (e.g., Anne and Bob),
a development line, and a special system that merges all un-
committed changes of the members and those committed in
the development line, called the merged system . In addition,
the teamâ€™s development line and its members may receive
code from the outside, that is, from other programmers or
teams participating in a major joint development. (Code
exchanges with outside collaborators go in both directions.
However, we are only interested in those incoming to the
team. They also follow project-speciï¬c policies that are not
relevant to discuss in this paper.)
The ï¬rst member creates the team and associates it with
the development line. This initializes the merged system with
a copy of the system at the head (of the development line).
At any time, members may join and leave the team, which
continues to exist until the last member leaves.
Members modify their working copies of the system
in the development line using common VCS operations
â€” check out, modify, update, merge, check in, pull, andpush. This â€œcopy-modify-mergeâ€ process generates a ï¬‚ow
of changes, from all members and the head, which are
then sent to update the merged system in the background.
Changes in working copies are captured when ï¬les are
saved, and sent automatically or manually. The last allows
members to control when their changes are transmitted as,
for example, when they are stable enough to be shared. Note
that, whether automatic or manual, transmission only occurs
if the working copy has no compilation errors, so the merged
system will not be affected by syntactic errors due to invalid
ï¬les. Additionally, members leaving the team cause their
changes to be removed from the merged system.
Changes in the head (check-ins) are processed automati-
cally. Unlike before, where the model is able to ensure that
changes are only transmitted if ï¬les are syntactically valid,
here the team should follow the recommended practice to
forbid compilation errors from entering the development line
[1], which can be easily supported by modern IDEs and
VCSes (e.g., via pre-commit hooks).
This model is very ï¬‚exible and supports mainstream
VCSes and their workï¬‚ows found today in practice.
B. Merged System
Albeit physically made of folders and ï¬les, the system
under construction and the merged system are abstractly
modeled as a tree of typed and attributed nodes , like in
Fig. 3 for the part that constitutes the ï¬le Primate.java.
/zoo/animals:Folder
Primate.java:File
package=â€zoo.animalsâ€
Primate:Class
visibility=â€publicâ€
extends=â€Mammalâ€
x:Field
visibility=â€privateâ€
type=â€intâ€
initval=â€â€
y:Field
visibility=â€privateâ€
type=â€intâ€
initval=â€â€move(int,int):Method
visibility=â€publicâ€
type=â€voidâ€
body=â€ {. . .}â€
Figure 3. The abstract model of the system.
Every folder, ï¬le, and program element inside a ï¬le is a
node having a type and a set of attributes (none for folders)
in the systemâ€™s tree. The possible types and attributes are
speciï¬ed by the domain, which in the ï¬gure is that of Java.
This system model allows us to compare two states of a
ï¬le to determine differences at node and attribute level. This
is important to track the changes made to the nodes andtheir attributes by every member and at the head, which are
used for background merging and to ï¬nd members to report
conï¬‚icts. Membersâ€™ changes are computed by comparing
working copy ï¬les with their bases in the development line
while headâ€™s changes are computed by comparing successive
ï¬le states at the head. In addition, the model is extended with
edges (not shown for clearness) representing dependencies
between program elements, like the â€œextendsâ€ dependency
from â€œPrimateâ€ to â€œMammalâ€. Thus, it forms an abstract
semantic graph used for analysis of the merged system
(explained later).
The merged system is updated in the background by
merging the most recent changes using structural merging
[17]. This collects the changes of each node in the systemâ€™s
tree, merges them, and returns the new merged state, which
is used to rewrite the node in the merged system. This is
done for every recently changed node in the systemâ€™s tree,
thus resulting in an updated merged system.
Structural merging allows ï¬ne-grained merges of source
ï¬les to be done automatically in places where a textual
merge would require manual intervention. For example,
changes to different program elements or attributes of a
program element in the same line of a source ï¬le are merged
automatically, contrasting with a conï¬‚ict on the line given
by textual merging. For example, Fig. 4 shows the changes
made by Anne and Bob in their working copies of a base
ï¬le F.java (the rectangles and strikes), and the resulting ï¬le
in the merged system. Note that structural merging was
able to merge the changes of the attributes of â€œclass Fâ€
and â€œï¬‚oat piâ€, despite being on the same line. Likewise,
additions of â€œint aâ€ and â€œint bâ€ at the same line are handled
transparently because structural merging recognizes them
as different program elements. The gray color represents
temporary resolutions of structural conï¬‚icts done in the
merged system, as explained next.
C. Detection of Conï¬‚icts
Our solution detects conï¬‚icts of different types, namely,
structural, language, behavior, and test conï¬‚icts.
1) Structural Conï¬‚icts: These conï¬‚icts are detected du-
ring background merging, and they are temporarily resolved
in the merged system using default resolutions to not halt
background merging â€” this does not change the code in the
working copies.
Apseudo direct conï¬‚ict occurs when different attributes
of a node are concurrently changed, or the same attribute
is simultaneously changed to the same value. In fact, it is a
warning that reminds there is no structural conï¬‚ict, but only
the possibility of a semantic conï¬‚ict â€” probably, it may be
detected as a language conï¬‚ict (see below). In Fig. 4, this
conï¬‚ict occurs in â€œclass Fâ€ and â€œï¬‚oat piâ€ after Anne and
Bob changed these program elementsâ€™ attributes.
The attribute change & change conï¬‚ict occurs when the
same attribute of a node is concurrently changed to different
class F {
public float pi;
int q = 1;
int m() {
return 1;
}
}F.java (base)
finalclass F {
public float pi = 3.14 ;
int a = 1;
int q = 2 ;
int m() {
return q;
}
}F.java (Anne)
publicclass F {
public float pi;
intb = 2;
intq = 3 ;
intm() {
return 1;
}
}F.java (Bob)
public final class F {
float pi = 3.14;
int a = 1;
int b = 2;
int q = 0 ;
int m () {
return q;
}
}F.java (merged system)Figure 4. File merging example.
values. One example is the â€œinitvalâ€ attribute of â€œint qâ€,
which was changed by Anne to 2 and by Bob to 3. In this
case, the default resolution is to assign a default value to the
attribute in the merged system. Default values are predeï¬ned
for each attribute type, and for â€œintâ€ it is zero (in gray).
Thenode change & deletion conï¬‚ict occurs when there are
simultaneous changes and deletions to the same node. This
happened with method â€œm()â€ changed by Anne and deleted
by Bob. In this case, the default resolution is to ignore
deletions to preserve changes, so Anneâ€™s change prevails in
the merged system. (We tested this decision with twenty-one
graduate students by exposing them to a â€œchange & deletionâ€
situation, and they all decided to preserve the change.)
The inconsistent node type conï¬‚ict happens when trying
to put nodes of a different type at the same location in the
systemâ€™s tree. For example, a developer adds a ï¬le named
â€œF.javaâ€ while another adds a folder named â€œF.javaâ€. If this
occurs, the default resolution is to remove the node from the
merged system. In practice this bizarre case should never
occur, but the model supports it.
An important advantage of structural merging is that a
direct conï¬‚ict never occurs when different program elements
in a ï¬le are changed, thus reducing overload by avoiding
notiï¬cations of false direct conï¬‚icts.
Note that developers are always alerted to structural
conï¬‚icts, and once they resolve them in their working copies,
the merged system is updated with their resolution: this is
why default resolutions in the merged system are always
temporary.
2) Language Conï¬‚icts: The merged system is automati-
cally compiled every time it is updated. We call the result-
ing compilation errors language conï¬‚icts because they are
caused by invalid combinations of developersâ€™ changes withrespect to the static semantics of the programming language.
One example is the invisible method conï¬‚ict that occurs
when a developer makes a method private while another one
adds a call to it outside that methodâ€™s class. A more complex
example is the undeï¬ned constructor conï¬‚ict that occurs
when a developer adds a constructor with one argument to
a class having no constructors as another developer creates
a subclass of that class.
By leveraging the compiler to detect language conï¬‚icts
we avoid re-implementing complex checks of programming
language rules: we just listen to the compilation output, pro-
cess the errors, and report corresponding language conï¬‚icts
on the user interface (see Section V).
3) Behavior Conï¬‚icts: These conï¬‚icts represent poten-
tially unwanted behavior due to unexpected interactions be-
tween concurrent changes. They are detected after updating
the merged system by searching for conï¬‚ict patterns , that is,
logical conjunctions of facts regarding the program elements
and their dependencies in the abstract semantic graph of the
merged system, which identify unwanted behavior.
The simplest is the dependency-based conï¬‚ict previously
discussed in Section III. Its pattern is
9x; y2G:dep(x; y)
where xandyare nodes changed in the graph Gand have
a transitive dependency dep. More specialized patterns are
generally more interesting because they represent conï¬‚icts
that are more difï¬cult to ï¬nd by developers, like the unex-
pected override conï¬‚ict in Section II, which can be found
using the pattern
9A; B; m 1; m22G:extends(A; B )^method (A; m 1)^
method (B; m 2)^equalSignature (m1; m2)
where Ais a super class of B.
Note that these patterns are deemed as behavior conï¬‚icts
only if the facts correspond to nodes changed by different
team members (we omitted this part in the above deï¬nitions
to avoid complicating them).
An advantage of this model is that conï¬‚ict patterns can
be easily added to support an increasing number of complex
behavior conï¬‚icts (e.g., â€œunexpected dynamic bindingâ€),
and are reusable across projects. Moreover, conï¬‚ict patterns
contrast with tests, which have to be designed and only
detect conï¬‚icts on the features they test.
4) Test Conï¬‚icts: A test conï¬‚ict is a test that fails after
updating the merged system and its execution ï¬‚ow has
reached two or more methods changed by different members.
Taking the Zoo application, imagine that Anne adds
a test to verify if all species have a price returned by
method â€œgetPrice()â€ while Bob creates class Chimpanzee
without such method (because he is not aware of Anneâ€™s
requirement). Afterwards, the merged system is updated with
both changes, and Anneâ€™s test fails when verifying the price
of Chimpanzee, as the following execution ï¬‚ow shows:zoo.testing.ZooTests.setUp() "
zoo.testing.ZooTests.testAnimalGetPrice() " (Anne)
...
zoo.animals.Animal.getPrice(Ljava/lang/Class;) "
zoo.animals.Chimpanzee.getPrice() $ (Bob)
This results in a test conï¬‚ict for â€œtestAnimalGetPrice()â€
because its execution ï¬‚ow has a method changed by Anne
(the test itself) and a method missing in the class created by
Bob. In this example, the test tried to call â€œgetPrice()â€ via
reï¬‚ection on Chimpanzee. Our solution intercepts reï¬‚ection
calls too and checks if missing methods were deleted or
never existed, which was the case for Bob. Consequently,
this test conï¬‚ict is named missing method conï¬‚ict . Tests are
very useful to detect conï¬‚icts involving reï¬‚ection, which are
hard to ï¬nd using conï¬‚ict patterns.
D. Reporting Conï¬‚icts
Each conï¬‚ict is reported to the members that changed
the node or nodes affected by it. For structural conï¬‚icts,
the affected node is that at the location of the conï¬‚ict in
the systemâ€™s tree; for language conï¬‚icts, the affected nodes
are the ones involved in the compilation error; for behavior
conï¬‚icts, they are those that match the corresponding con-
ï¬‚ict pattern; and for test conï¬‚icts they are the nodes which
represent the methods in the failed execution ï¬‚ow. Only the
members that changed the affected nodes and their attributes
are notiï¬ed of the conï¬‚ict. Such members are found by
looking for who changed the affected nodes in the node
change tracking information.
V. I MPLEMENTATION IN ECLIPSE
Our tool, called WeCode, implements our solution for
Java programming inside the Eclipse IDE. WeCode has both
client and server plugins, and at the moment it supports
Subversion (http://subversion.apache.org).1
A. The Server
This plugin runs on Equinox (http://eclipse.org/equinox)
and is responsible for managing teams: it handles membersâ€™
joins and leaves; tracks their changes to the systemâ€™s tree;
does background merges; and updates the conï¬‚icts affecting
the team.
Each team holds a project inside Equinox containing the
code of the teamâ€™s merged system. This is updated every
time changes are received from client plugins or from check-
ins in the teamâ€™s development line, which is monitored by
the server.
The merged system is automatically compiled by the
Eclipse Java Tools installed in Equinox. The server lis-
tens for marker deltas ( IMarkerDelta ) corresponding to
1Subversion was our ï¬rst choice because it had the best plugin for Eclipse
when we started development. Currently, we plan to support other VCSes,
like Git and Mercurial (http://mercurial.selenic.com).Â‚
Âƒ
Â„
Â…
Figure 5. Continuous merging inside the IDE.
errors in the compilation output to update the language
conï¬‚icts affecting the team.
At the same time, the server compares the previous and
the updated states of the merged system to determine how
it was modiï¬ed during background merging. This is done to
ï¬nd out which conï¬‚ict patterns need to be veriï¬ed to update
the behavior conï¬‚icts affecting the team. In what concerns
the detection of behavior conï¬‚icts, we leverage the abstract
semantic graph implemented by the Eclipse Java Tools to
look for instances of conï¬‚ict patterns in the merged system.
Test conï¬‚icts are found by running JUnit test
cases (http://www.junit.org) after updating the merged
system. To support this, we created modiï¬ed versions
of the org.eclipse.junit. fcore, runtime g
plugins to collect the execution ï¬‚ows of running
test cases. In particular, we have a version of
class RemoteTestRunnerClient (core plugin)
installed on the server JVM, and a version of class
RemoteTestRunner (runtime plugin) installed on the
test JVM, which opens a socket connection to the server
and sends back the results as tests are run.
The server launches the test JVM with an agent li-
brary that instruments the methodsâ€™ entry points in all
loaded classes (except those of the Java runtime, JUnit,
and Equinox/Eclipse) with code that logs method calls. Test
execution ï¬‚ows are then collected by logging the method
calls between each test start and end.
Every conï¬‚ict detected by the server contains a detailed
message that describes what happened, the affected programelements, and the affected members that have modiï¬ed those
elements, thus speeding up conï¬‚ict resolution on the client
side. All conï¬‚ict updates are sent to the client plugin of
affected members.
B. The Client
This plugin collects changes to folders and ï¬les in the
developerâ€™s working copy by listening to events sent by the
Subversion plugin and the Eclipse IDE, and sends them
to the server. In addition, it receives from the server the
latest changes of other members and the most recent conï¬‚ict
updates. All these sends and receives are automatic or
by developerâ€™s request. The client plugin also offers the
following two views that constitute the main of WeCodeâ€™s
user interface.
1) The Team View: Following Fig. 5, this view ( Â¸) lists
all members in the team (including the head), and details
their changes to folders, ï¬les, and program elements down
to ï¬elds and methods. This view has buttons that developers
may use to publish their changes (
 ) and receive updates
(
) within their team (located in the server at the URL).
The Team view uses red (
 ) and yellow (
 ) icons to
mark ï¬les simultaneously changed by the developer and
other members. The red icon alerts that there are structural
conï¬‚icts (other than pseudo) inside the ï¬le while the yellow
icon indicates that even though they modiï¬ed the same ï¬le,
none or only pseudo direct conï¬‚icts exist. This color scheme
avoids developers wasting time investigating notiï¬cations by
helping them focus on â€œurgentâ€ ï¬les. In addition, the iconsare kept minimal to avoid overloading the user interface: we
only show them in the developerâ€™s subtree and at folder and
ï¬le nodes. (Supporting icons for other conï¬‚ict types or at
ï¬ner-grained nodes might be distracting in this view but we
need to investigate it further.)
Developers can use this view to compare and exchange
code among them or between them and the head. For
example, they can access the ï¬le compare editor of any
ï¬le node to integrate other membersâ€™ changes, so that they
resolve conï¬‚icts while changes are fresh in their minds or
stay updated with the most recent code within the team.
They can also use a chat view2to ask other members
if their changes are already stable, thus avoiding merging
unï¬nished code. For instance, a true direct conï¬‚ict (red icon)
can be collaboratively resolved by merging other membersâ€™
changes, publishing the locally merged ï¬le, and asking those
members to accept the merged ï¬le, thus turning the icon
yellow.
2) The Team Merge View: This view ( Â¹) lists all lan-
guage, behavior, and test conï¬‚icts affecting the developer,
which in the ï¬gure are those already introduced in the paper.
Every conï¬‚ict has a detailed description that reports
its nature, the affected program elements, the affected
members, and how these changed the affected elements.
The description results from instantiating the placeholders
of the conï¬‚ictâ€™s template. For example, the template for
tests conï¬‚icts includes the message returned by the failure,
which for the test case in the ï¬gure is the message in
assertNotNull("Price not ...); .
Developers can double click a conï¬‚ict in the Team Merge
view to quickly jump to its location, which can be a program
element or a statement inside a method. In addition, conï¬‚icts
are signaled in the Package Explorer ( Â¶), and inside editors
at their location in the affected ï¬les ( Â·) (for an example of
a conï¬‚ict at statement level see line 6 of Fig. 7 in [12]).
All the information is unobtrusively presented to deve-
lopers in a way that resembles the continuous compilation
experience in Eclipseâ€™s Problems view. With these features,
the Team Merge view helps developers speed up resolution,
instead of wasting time investigating many change notiï¬ca-
tions to detect conï¬‚icts, as discussed back in the Problem
section (Section III).
C. Preparing for the Evaluation
To support the evaluation of our tool, we created an
additional view, called Team Alerts (Fig. 6), which uses
dependency analysis to offer a heuristic mode of conï¬‚ict
detection similar to those in [13], [14], [15]. This view
notiï¬es the developer about co-workersâ€™ changes to the
APIs referenced by ï¬les modiï¬ed by the developer. The
notiï¬cations are listed for the ï¬le selected in the Package
Explorer or opened in the active editor.
2The Collaboration view in Eclipse ECF (http://www.eclipse.org/ecf).
Figure 6. Team Alerts view showing notiï¬cations for Feline.java.
Figure 7. Notiï¬cations are signaled in the Package Explorer view.
For example, Fig. 6 lists the notiï¬cations for Feline.java.
The red icons alert that a co-worker changed program
elements used in Feline.java whereas the yellow icons alert
for changes to unused program elements in types referenced
by Feline.java. The notiï¬cations may be double clicked to
open an editor to compare the co-workerâ€™s ï¬le (that in
the â€œResourceâ€ column) with its corresponding local ï¬le.
The icons are also shown for ï¬les in the Package Explorer
(red icons win) to alert developers when they are focused
somewhere else, as shown in Fig. 7.
VI. E VALUATION
The evaluation here described shows that our solution
does not overload developers with notiï¬cations and improves
early detection of conï¬‚icts when compared to existing ap-
proaches based on change and dependency-based awareness.
A. Experimental Design
To show this, we ran several controlled user experiments
comprising three treatments that correspond to different
levels of support for conï¬‚ict detection: the REPOSITORY
had no support, the HEURISTIC was supported by the
Team Alerts view, and the MERGE used the Team Merge
view. Using this scheme we wanted to assess the number of
conï¬‚icts detected in each treatment before check-in, and the
notiï¬cation overload (this one for the last two treatments).
The experiments involved twenty-one graduates in com-
puter engineering from our university, one half being recent
bachelors and the other being PhD students, having enough
experience with the tools used in the experiment, namely,
Eclipse, Java, and Subversion.
The experiment was ran once for each team comprising
one subject and one confederate (the experiment host). The
teams were randomly assigned into the treatments so that
the number of bachelors and PhDs was the same for all
treatments.
Subjects were told they were going to be studied on how
they managed conï¬‚icts between concurrent programming
tasks modifying the Zoo application (a total of 41 classesand 1143 LOCs), which was sent to them at least two days
before their session. At the beginning of their experiment,
they watched a treatment-speciï¬c video showing the tools
using a conï¬‚ict that would not occur during their session.
Then, they were given a guide with six tasks and the code to
type in each task. They were told to follow the task order and
say aloud when a task started or ï¬nished and when a conï¬‚ict
was detected. All sessions were recorded with prior subject
agreement. At the end, a questionnaire containing 10-point
Likert scale and free response questions was given. All this
was designed so that each experiment took less then one
hour and thirty minutes.
The confederate followed a list of concurrent tasks, which
inserted the following indirect conï¬‚icts at about the same
time for all subjects: two undeï¬ned constructor conï¬‚icts
(language), one unexpected override conï¬‚ict (behavior),
and one missing method conï¬‚ict (test). All conï¬‚icts were
inserted before subjects had ï¬nished half of their work so
that they had enough time to detect them before the end.
The confederate also checked in after every task in the
REPOSITORY case; this was unnecessary in the other cases
because the tool was conï¬gured to automatically publish
changes to the teamâ€™s server.
B. Results
1) Quantitative Analysis: Table I shows the number of
conï¬‚icts detected (D) and not detected (ND) in each treat-
ment before subjects checked in at the end of their tasks â€”
a conï¬‚ict was considered detected when (MERGE) subjects
said they had seen it in the Team Merge view, and when
(HEUR. & REPO.) subjects said something like â€œI think
there is a problem: I changed this and my co-worker changed
thatâ€ and the â€œproblemâ€ was a conï¬‚ict.
What is the effect of the awareness mode on the ability
of developers to detect conï¬‚icts early? Table I shows that
REPO. subjects found none of the conï¬‚icts before check-in.
Only one subject synchronized frequently with the reposi-
tory, but he only looked for direct conï¬‚icts at ï¬le level. In
general, all REPO. subjects were observed during check-in
to pay attention only to those ï¬les that they and the confed-
erate also changed, thus missing the indirect conï¬‚icts. The
HEUR. subjects did better, but most only detected conï¬‚icts
after importing changes from their co-worker, mainly â€œto
stay updated with the most recent codeâ€ as one said, thus
producing a compilation error in their working copies that
caught their attention. Only one succeeded in ï¬nding the
unexpected override conï¬‚ict by correlating the additions of
two methods in the hierarchy. In contrast, MERGE subjects
were able to detect all conï¬‚icts early on given the detection
capability provided by this mode. In general, they started
resolution at their best opportunity, generally between their
tasks, and only then they decided to import from their co-
worker as needed to resolve the conï¬‚icts.Table I
NUMBER OF CONFLICTS DETECTED IN EACH TREATMENT . THE EFFECTS
OF THE TREATMENTS ARE STATISTICALLY SIGNIFICANT ACCORDING TO
PEARSON2TEST (p<: 05).
MERGE HEUR. REPO. Pearson2df p
D 28 7 062.4 2.001
ND 0 21 28
The results in Table I provide evidence that repository
support and dependency-based awareness are not sufï¬cient
to support early detection of indirect conï¬‚icts, and that the
continuous merging approach has greater potential.
2) Qualitative Analysis: Table II shows the scores of the
Likert questions in the questionnaire.
Q1â€™s scores show that subjects had a very different per-
ception about the number of false positives presented in the
two modes, which is consistent with the kind of support in
these modes.
Q2â€™s scores express a strong wish of being informed
about conï¬‚icts during programming, and interestingly the
subjects that scored higher in such feature were those who
experienced it, thus reinforcing the usefulness of continuous
merging. When asked to justify their score, the subjects
responded:
â€œ[...] we could avoid spending too much time resolving
conï¬‚icts at the end [check-in]. Additionally, it would
help resolve conï¬‚icts while we still remembered the
code where they happened.â€ (HEUR., Q2=9)
â€œAllows to manage conï¬‚icts as they occur, and does
not let changes grow.â€ (MERGE, Q2=9)
â€œIt allowed me to reduce the time to resolve conï¬‚icts
[...], instead of a slow commit later.â€ (MERGE, Q2=10)
Regarding this question, one said â€œI did not give max-
imum score because I occasionally paused my work to
check if the conï¬‚ict was important to resolve right awayâ€
(MERGE, Q2=9), and another said â€œEarly detection is
crucial to avoid wasting too much time during resolution.
Although it may cause distraction, I believe with practice
it is possible to manage distractionsâ€ (HEUR., Q2=8). In
general, subjects were able to manage interruption by paying
more attention to awareness information after ï¬le saves
and between tasks. Still, we think interruption management
requires further research.
Q3â€™s scores summarize subjectsâ€™ overall experience with
the awareness modes in our tool, suggesting they really
appreciated knowing what was happening around them that
would help coordinate with others. The questionnaire ended
by asking subjects to express their opinion about the tool
and suggest improvements:
â€œI liked to know in real-time who was changing the
code I was using and whereâ€ (HEUR.)
â€œI appreciated being informed about remote changes
with different levels of severityâ€ (HEUR.)Table II
QUESTIONNAIRE SCORES IN 10-POINT LIKERT SCALE (â€œ1-S TRONGLY
DISAGREE â€, 10-â€œS TRONGLY AGREE â€). T HE VALUES ARE SHOWN AS
â€œMEAN (STD.DEV.)â€, AND â€œN.A.â€FOR NOT APPLICABLE .
MERGE HEUR. REPO.
Q1: The modeâ€™s view listed many
false positives, that is, alerts not cor-
responding to real conï¬‚icts, thus dis-
tracting me.2.1 (0.99) 7.6 (1.36) n.a.
Q2: I (liked / would like) to be
informed about conï¬‚icts while I
am programming, instead of being
warned only later at check-in.9.3 (0.70) 7.7 (1.70) 8.00 (1.85)
Q3: I would use this modeâ€™s view and
recommend it to other colleagues.9.0 (0.93) 7.8 (0.75) n.a.
â€œSome changes that appeared as yellow at the beginning
revealed to be problematic [at check-in]â€ (HEUR.)
â€œI liked less the fact that the tool did not signal
the potential compilation error due to the concurrent
addition of constructorsâ€ (HEUR.)
â€œI liked the icon in the editor informing me about the
conï¬‚ict and with whom I was conï¬‚ictingâ€ (MERGE)
â€œI liked most its simplicity of useâ€ (MERGE)
â€œI liked tests being run on the merge of the code of the
entire teamâ€ (MERGE)
This qualitative part shows that subjects deeply appreciate
being informed about conï¬‚icts during programming, and that
there is a tendency to favor continuous merging.
C. Threats to Validity
Every experiment is challenged by threats to its construct,
internal and external validity.
1) Construct validity: We think that the application,
tasks, conï¬‚icts, and questionnaires used in our study are
valid by construction to evaluate our tool and the effect of
the different awareness modes on the ability of developers
to detect conï¬‚icts. Subjects also knew nothing about which
conï¬‚icts would occur or that our tool was being evaluated
so as to avoid inï¬‚uencing them.
2) Internal validity: The confederate was used to prevent
confounds caused by varying behaviors of genuine co-
workers that might have inï¬‚uenced subjectsâ€™ behavior. The
subjects also had no previous experience with our tool, so
there were no learning effects on their performance, and
we neutralized programming skills as much as possible by
giving the code to type in each task. The best we could
do to avoid personal characteristics (e.g., curiosity) from
confusing the results was to randomly select subjects into
treatments. As such, we think our study has internal validity.
3) External validity: The major threat to the general-
ization of our studyâ€™s results is that changing a simple
application, like Zoo, by typing pre-written code is not
representative of real practice. Regarding this, our study didnot cover aspects due to the complexity of real software
development, which may inï¬‚uence how programmers use
and beneï¬t from a conï¬‚ict detection tool. These include
project aspects like size and geographical distribution, and
tool aspects such as usability and interruption management,
so studies in real projects are needed. Our study might be
threatened because of our choice of conï¬‚icts. The results
show that our solution performs better than others for the
chosen conï¬‚icts. However, we think that it will not perform
worse for other conï¬‚icts, especially due to its detailed
detection capability. Even though we need to understand
the kind of merge conï¬‚icts occurring in real projects, it is
reasonable to assume that indirect conï¬‚icts will be at least
as complex and hard to detect as those in the study, so
we think our automatic conï¬‚ict detection solution will be
advantageous in practice. In addition, our choice of tasks
might be threatened in terms of the false positives they did
or did not generate despite our efforts to avoid bias in any
way. The use of students seems reasonable considering one
study reporting students and professionals have no major
difference in understanding dependencies and relationships
in software [18], which is important to ï¬nd conï¬‚icts between
concurrent changes. To sum up, our results are indicative of
the beneï¬ts of our solution and suggest that a longitudinal
study in the industry is necessary to ground a theory of
awareness of software conï¬‚icts.
VII. R ELATED WORK
This section outlines several tools related to our work,
which provide awareness of software changes.
Tools that provide awareness of direct conï¬‚icts at ï¬le
granularity may overload the developer because of changes
to independent program elements inside the same ï¬les [15],
[16], [19], [20]. A ï¬ne-grained solution like ours does not
have this shortcoming.
Other tools go beyond these and support dependency-
based awareness. Tukan [13] signals developers with the
presence of co-workers and the changes they made in
elements near a dependency path from the element focused
on by the developer. Presence signals help ï¬nd co-workers
for collaboration, and change signals help prevent direct and
indirect conï¬‚icts. Signals are ranked according to a dynamic
function of path length and relevance, which by default
emphasizes more the shorter paths as these are assumed
to connect elements having a stronger dependency. This
tool does not have a place where all signals are listed, so
developers are expected to contact co-workers or to inspect
concurrent changes once they see a signal of interest, before
making changes to the focused element; otherwise, it can
be difï¬cult to remember where signals exist in the code for
later investigation.
CollabVS [14] provides presence awareness and notiï¬es
about direct and indirect conï¬‚icts involving elements con-
nected by an unlimited dependency path. There is no rankingmechanism to help developers focus on the most interesting
notiï¬cations. Developers can select the element granularity
at which conï¬‚icts are detected to that of ï¬le, type, or
method, but in practice it can be difï¬cult to determine
which works best at each moment [21]. Developers upon
receiving a notiï¬cation may set a â€œwatchâ€ on the element
edited by the co-worker to remind the developer to check
for conï¬‚icts after some time or after the co-worker removes
focus from the element. However, this mechanism may
provoke disturbance since â€œwatchesâ€ need to be requested
to co-workers, timeouts can be hard to set properly, and co-
workers may enter and leave elements frequently.
Palant Â´Ä±r [15] notiï¬es an indirect conï¬‚ict when a ï¬le mod-
iï¬ed by the developer depends on a ï¬le that had its public
APIs altered by a co-worker. Its main focus is on syntactic
indirect conï¬‚icts. Notiï¬cations carry the modiï¬cations to the
public APIs of types in remotely changed ï¬les. In addition,
a notiï¬cation is a â€œbombâ€ if there is a dependency on a
code element (type or method) that had its public signature
edited in the remote ï¬le, otherwise, they are just a â€œwarningâ€
of possible interesting changes to the remote ï¬leâ€™s public
APIs. This inspired our design of WeCodeâ€™s Team Alerts
view. Notiï¬cations are also â€œredâ€ or â€œyellowâ€ respectively
when the remote ï¬le was checked in or is still being changed
by a co-worker. This tool does not support indirect conï¬‚icts
involving remote ï¬les not present in the developerâ€™s working
copy â€” these are ï¬les created by co-workers or that the
developer did not check out.
Both CollabVS and Palant Â´Ä±r do not notify conï¬‚icts involv-
ing check-ins bypassing the tool or done before developers
checked out via the tool. This is supported by WeCodeâ€™s
model of team work in a development line.
All the above tools only support direct conï¬‚icts and
dependency-based indirect conï¬‚icts. In addition, developers
must investigate notiï¬cations to determine if conï¬‚icts re-
ally exist. In contrast, WeCode considers the unpredictable
semantics that result from merging the changes to an object-
oriented system made by a whole team. Besides using
analysis, WeCode uses a merged system to detect complex
conï¬‚icts via compilation and testing, which is a feature
that awareness tools like the above do not provide. For
example, testing can detect conï¬‚icts which are very hard
or undecidable via analysis, like involving code reï¬‚ection.
YooHoo [22] reports API changes that may break the code
or that are of interest to the developer as determined by the
dependencies within the ï¬les owned (recently committed)
or selected by the developer. This tool is not designed to
detect conï¬‚icts, but to help developers adapt their code to
the evolution of APIs in external projects or in branches of
sub-teams within a large team.
Crystal [4] does separate background merges of pairs of
repositories, comprising that of the developer and that of a
co-worker or a central master. The result is one of â€œtextual
merge failureâ€, â€œbuild failureâ€, â€œtests failureâ€, or â€œtestspassedâ€ relationship for each repository pair. This tells each
pair of developers if their mutual merge is problematic, but
does not tell them which conï¬‚icts are exactly occurring, so
they have to interrupt their work and spend time discovering
conï¬‚icts. In contrast, WeCode does a single background
merge of all developments of a team working on the same
branch and informs inside the IDE about the precise details
of the conï¬‚icts affecting the team as a whole. This allows us
to catch complex conï¬‚icts involving two or more developers,
and avoids duplication of awareness icons caused by the
same conï¬‚ict in multiple merged repository pairs. WeCode
does not distract developers because of textual merge failures
that are easily handled via structural merging. Our solution
also supports uncommitted changes, so conï¬‚icts can be
found as soon as developers want to be informed.
Three studies compared support for early conï¬‚ict dete-
ction against not having such support [14], [16], [23]. Like
them, we concluded that users like to have support for early
conï¬‚ict detection, but unlike them our study also compared
two support levels.
VIII. C ONCLUSION AND FUTURE WORK
The problem of merge conï¬‚icts in collaborative program-
ming is an important one as they are known to cause
software defects. The industry and research recognize this
problem and that a conï¬‚ict detected earlier is much easier to
resolve than when detected later at check-in or production.
Awareness has been proposed to help developers detect
conï¬‚icts earlier. However, all known approaches require de-
velopers to detect conï¬‚icts by themselves and may overload
them with notiï¬cations, hence making detection difï¬cult.
We have proposed a novel solution that precisely and
accurately detects conï¬‚icts on behalf of developers, thus
avoiding overloading them with notiï¬cations. It introduces
the notion of continuous merging inside the IDE, which
enables earlier resolution of conï¬‚icts while developers still
have their changes fresh in their minds, making resolution
easier. An empirical evaluation conï¬rmed that our solution
improves early detection of conï¬‚icts and avoids overloading
developers in comparison with existing approaches.
There are several directions for our future work. First,
we will continue improving WeCodeâ€™s collaborative features
and usability. Second, we want to do a longitudinal study
with professional programmers in an industrial setting to
determine the inï¬‚uence of continuous merging in their
software process, and to check if new collaborative patterns
emerge. Third, we want to measure the overall effect of
continuous merging on software quality.
ACKNOWLEDGMENT
The ï¬rst author was supported by FCT scholarship
SFRH/BD/27652/2006. This work was also supported by
FCT (INESC-ID multiannual funding) through the PIDDAC
Program funds.REFERENCES
[1] S. Berczuk and B. Appleton, Software Conï¬guration Man-
agement Patterns: Effective Teamwork, Practical Integration .
Addison-Wesley, 2002.
[2] M. Fowler. Continuous Integration. [Online]. Available:
http://martinfowler.com/articles/continuousIntegration.html
[3] D. E. Perry, H. P. Siy et al. , â€œParallel changes in large-scale
software development: An observational case study,â€ ACM
Trans. Softw. Eng. Methodol. , vol. 10, pp. 308â€“337, July 2001.
[4] Y . Brun, R. Holmes et al. , â€œProactive Detection of Collabo-
ration Conï¬‚icts,â€ in ESEC/FSE â€™11: Joint Meet. of the Euro.
Softw. Eng. Conf. and the Inter. Symp. on the Foundations of
Softw. Eng. ACM, 2011, pp. 168â€“178.
[5] P. Duvall, S. M. Matyas et al. ,Continuous Integration:
Improving Software Quality and Reducing Risk . Addison-
Wesley Professional, 2007.
[6] R. Grinter, â€œUsing a Conï¬guration Management Tool to
Coordinate Software Development,â€ in COOCS â€™95: Conf. on
Organizational Computing Systems . ACM, 1995, pp. 168â€“
177.
[7] C. de Souza, D. Redmiles et al. , â€œâ€Breaking the codeâ€,
Moving between Private and Public Work in Collaborative
Software Development,â€ in GROUP â€™03: Inter. Conf. on
Supporting Group Work . ACM, 2003, pp. 105â€“114.
[8] P. Dourish and V . Bellotti, â€œAwareness and Coordination
in Shared Workspaces,â€ in CSCW â€™92: Conf. on Computer
Supported Cooperative Work . ACM, 1992, pp. 107â€“114.
[9] D. Damian, L. Izquierdo et al. , â€œAwareness in the Wild: Why
Communication Breakdowns Occur,â€ in ICGSE â€™07: Inter.
Conf. on Global Softw. Eng. IEEE Computer Society, 2007,
pp. 81â€“90.
[10] S. R. Fussell, R. E. Kraut et al. , â€œCoordination, Overload
and Team Performance: Effects of Team Communication
Strategies,â€ in CSCW â€™98: Conf. on Computer Supported
Cooperative Work . ACM, 1998, pp. 275â€“284.
[11] M. Kim, â€œAn Exploratory Study of Awareness Interests
about Software Modiï¬cations,â€ in CHASE â€™11: Workshop on
Cooperative and Human Aspects of Softw. Eng. ACM, 2011,
pp. 80â€“83.
[12] M. L. Guimar Ëœaes and A. Rito-Silva, â€œTowards Real-Time
Integration,â€ in CHASE â€™10: Workshop on Cooperative and
Human Aspects of Softw. Eng. ACM, 2010, pp. 56â€“63.[13] T. Sch Â¨ummer and J. Haake, â€œSupporting Distributed Soft-
ware Development by Modes of Collaboration,â€ in ECSW
â€™01: Euro. Conf. on Computer Supported Cooperative Work .
Kluwer Academic Publishers, 2001, pp. 79â€“98.
[14] P. Dewan and R. Hegde, â€œSemi-Synchronous Conï¬‚ict De-
tection and Resolution in Asynchronous Software Develop-
ment,â€ in ECSCW â€™07: Euro. Conf. on Computer Supported
Cooperative Work . Springer, 2007, pp. 159â€“178.
[15] A. Sarma, G. Bortis et al. , â€œTowards Supporting Awareness
of Indirect Conï¬‚icts Across Software Conï¬guration Manage-
ment Workspaces,â€ in ASE â€™07: Inter. Conf. on Automated
Softw. Eng. ACM, 2007, pp. 94â€“103.
[16] J. T. Biehl, M. Czerwinski et al. , â€œFASTDash: A Visual
Dashboard for Fostering Awareness in Software Teams,â€ in
CHI â€™07: Conf. on Human Factors in Computing Systems .
ACM, 2007, pp. 1313â€“1322.
[17] J. P. Munson and P. Dewan, â€œA Flexible Object Merging
Framework,â€ in CSCW â€™94: Conf. on Computer Supported
Cooperative Work . ACM, 1994, pp. 231â€“242.
[18] M. H Â¨ost, B. Regnell et al. , â€œUsing Students as Subjects â€“
A Comparative Study of Students and Professionals in Lead-
Time Impact Assessment,â€ Empirical Softw. Eng. , vol. 5, pp.
201â€“214, November 2000.
[19] G. Fitzpatrick, P. Marshall et al. , â€œCVS Integration with Noti-
ï¬cation and Chat: Lightweight Software Team Collaboration,â€
inCSCW â€™06: Conf. on Computer Supported Cooperative
Work . ACM, 2006, pp. 49â€“58.
[20] S. Hupfer, L.-T. Cheng et al. , â€œIntroducing Collaboration into
an Application Development Environment,â€ in CSCW â€™04:
Conf. on Computer Supported Cooperative Work . ACM,
2004, pp. 21â€“24.
[21] P. Dewan, â€œDimensions of Tools for Detecting Software
Conï¬‚icts,â€ in RSSE â€™08: Inter. Workshop on Recommendation
Systems for Softw. Eng. ACM, 2008, pp. 21â€“25.
[22] R. Holmes and R. J. Walker, â€œCustomized Awareness: Rec-
ommending Relevant External Change Events,â€ in ICSE â€™10:
Inter. Conf. on Softw. Eng. ACM, 2010, pp. 465â€“474.
[23] A. Sarma, D. Redmiles et al. , â€œEmpirical Evidence of the
Beneï¬ts of Workspace Awareness in Software Conï¬guration
Management,â€ in SIGSOFT â€™08/FSE-16: Inter. Symp. on
Foundations of Softw. Eng. ACM, 2008, pp. 113â€“123.
View publication stats