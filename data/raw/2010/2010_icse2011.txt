Non-Essential Changes in Version Histories
David Kawrykow and Martin P . Robillard
McGill University
Montréal, Canada
{dkawry,martin}@cs.mcgill.ca
ABSTRACT
Numerous techniques involveminingchange data capturedin soft-
ware archives to assist engineering efforts, for example to identify
components that tend to evolve together. We observed that im por-
tant changes to software artifacts are sometimes accompani ed by
numerous non-essential modiﬁcations,suchaslocalvariablerefac-
torings, or textual differences induced as part of arename r efactor-
ing. We developed a tool-supported technique for detecting non-
essential code differences in the revision histories of sof tware sys-
tems. We used our technique to investigate code changes in ov er
24000change sets gathered from the change histories of seven
long-lived open-source systems. We found that up to 15.5%of
a system’s method updates were due solely to non-essential d iffer-
ences. Wealsoreportonnumerousobservations onthedistri bution
of non-essential differences in change history and their po tential
impact on change-based analyses.
Categories andSubject Descriptors
D.2.7 [Software Engineering ]: Distribution, Maintenance, and
Enhancement
General Terms
Measurement, Experimentation, Algorithms
Keywords
Mining software repositories, software change analysis, d ifferenc-
ingalgorithms
1. INTRODUCTION
Sourcecoderepositorysystemshavebeeninusesincethe197 0s
to keep track of the different versions of a system’s artifac ts and,
by extension, of the changes made between versions [22]. Num er-
ous techniques now involve mining change data captured in so ft-
ware archives to assist software engineering efforts. For e xample,
mining change data has been used to measure code decay in agin g
systems [5], to predict defects in modules [10, 16], and to de tect
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
ICSE11, May 21-28 2011, Waikiki, Honolulu, HI,USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.non-obvious relationships between code elements [8, 23, 25 ]. We
refer to approaches operating on change data as change-based ap-
proaches.
Typical version control systems store changes as line-base d tex-
tualdeltasbetweencommittedcodeﬁles. Incontrast,chang e-based
approaches generallyaimtooperate onmore meaningful repr esen-
tationsofchange,suchas,forexample,theindividualmeth odsthat
wereupdatedaspartofadevelopercommittotherepository. More
meaningful representations of software changes support mo re ac-
curate reasoning about software development activityand e ffort.
Acriticalproblem forchange-based approaches isthustobr idge
this conceptual gap between the low-level deltas stored in v ersion
control systems andthe abstractions used torepresent soft ware de-
velopment activity. A ﬁrst step, implemented by most modern
change-based approaches, is to ignore trivial low-level ch anges,
likethoseinducedbywhitespacesorotherformatting-rela tedmod-
iﬁcations. Thegeneralassumptionbehindthisstrategyist hatthese
groups of low-level differences are less likely to yield mea ningful
abstractionsoftheactualdevelopment effortbehindacode change.
Forexample,manychange-basedapproaches ignoretrivialu pdates
when determining the set of methods that were modiﬁed as part of
a code commit.
Aspartofourongoinginvestigationofsoftwarearchives,w eob-
served that manyadditional kinds of minor (or non-essential ) code
changes can also cause change-based approaches to infer ina ccu-
rate high-level representations of software development e ffort. For
example, everytimeadeveloper performsarenamerefactori ng, all
methods that include references to the renamed element will also
be textually modiﬁed; a naive abstraction of these non-esse ntial
rename-inducedstatementupdatescanthenresultinabloat edhigh-
level representation of the change that appears to span many lines
ofcode,methods,andﬁles,despitecorrespondingtoasingl edevel-
oper modiﬁcation (that is generally a very simple tool-assi sted op-
eration). Giventhe growing importance of change analysis i n soft-
wareengineering,ourlong-termgoalistoenablechange-ba sedap-
proaches to incorporate information about the essentiality of code
changes into their analyses. With this information, change -based
approaches willbeabletomorepreciselyselecttheindivid uallow-
level modiﬁcations they use to derive their high-level repr esenta-
tions of development activityor effort.
Weinvestigatedthepotentialimpactofnon-essential diff erences
on the abstractions that are typically analyzed by many chan ge-
based approaches. In particular, we sought i)to characterize the
prevalenceofnon-essentialdifferencesinchangehistory ,and,ii)to
measure their impact on the code churn andmethod updates asso-
ciated with code commits, two facets of code change that are c on-
sidered in existing empirical studies involving change dat a [5, 16]
and change taskoriented analyses [25].Analyzingchangehistorytodetectthekindsofnon-essenti aldif-
ferences mentioned above is far from trivial. An automated d etec-
tionofnon-essential differences requires botha characte rizationof
structural changes occurring within statements and an anal ysis of
their impact on the underlying system. Inaddition, to avoid recon-
structing an entire program snapshot for every committed ch ange,
the impact of changes must be determined given only a change
set, or group of ﬁles that were co-committed by a developer [2 4].
We know of no existing tool that supports this type of precise sub-
statement-level change analysis on partial programs (chan ge sets).
Forexample,althoughexistingstandalonesyntactic-orto ken-based
differencing techniques can be used toprocess change sets a ndde-
tect cases of reference replacements within statements, no ne use
type resolution to precisely infer reference replacements that were
induced speciﬁcallybyrename refactorings.
Wedevelopedtoolsupportfordetectingnon-essentialdiff erences
inchange setsminedfromchange history. Ourtechnique iden tiﬁes
cases where a modiﬁed program statement was updated by one or
more predeﬁned types of ﬁne-grained differences. The non-e ssen-
tiality of candidate statement updates is then veriﬁed by re solv-
ingandoperating onthe types ofrelevant sub-expressions w ithina
statement update. For example, our technique detects cases where
a statement was modiﬁed only because it contained reference s to
one or more renamed program entities. We investigated the pr eci-
sion of our technique and found that 98.8%of the method updates
it identiﬁedasnon-essential were accurately classiﬁed.
We used our technique to analyze over 24000change sets from
therevisionhistoriesofsevenlong-livedopen-sourceJav asystems.
Basedonthesystemsstudied,ourinvestigationfoundthatb etween
2.6%and15.5%of all method updates in a system’s change his-
tory consisted entirely of non-essential differences. We a lso ob-
served that these non-essential method updates can have a si gniﬁ-
cantimpactonthekindofhigher-levelrecommendations pro duced
by certain well-known change-based approaches. Speciﬁcal ly, we
observed that non-essential method updates can interfere w ith the
recommendations that might be produced by a standard method -
pair association-rule mining analysis in 26%of the cases where
the analysis makes at least one recommendation. Furthermor e, we
found that the overall qualityof the recommendations produced in
these cases was signiﬁcantly improved after non-essential method
updates were no longer taken into consideration. These and a ddi-
tional insights regarding the prevalence of non-essential difference
inchange historiesareimportanttokeepinmindwhenmaking de-
cisions basedon change data.
This paper contributes a tool-supported differencing tech nique
for identifying non-essential code modiﬁcations in change histo-
ries, and a number of high-level observations characterizi ng the
prevalence of non-essential differences and their possibl e impact
on change-based approaches. Our observations are supporte d by a
detailedempiricalinvestigationofover 24000changesetsfromthe
revision histories of seven, long-lived, open-source Java systems.
Readers can download a version of our tool and the experiment al
data behind our observations from our website.1
2. MOTIVATINGEXAMPLE
Ourmotivationforstudyingnon-essentialdifferencesste msfrom
ourpreviousworkonchangetaskclustering,wherewenotice dthat
non-essential method updates often generated meaningless associ-
ations betweenchange sets [21].
We illustrate the concept of non-essential differences and their
potential for interfering with higher-level information e xtracted by
1www.cs.mcgill.ca/~swevo/diffcatchange analyses with an actual change set retrieved from the re-
vision history of A ZUREUS, a highly downloaded media sharing
application.2Thechange setincludesmodiﬁcationsto 77methods,
among other structural changes. The modiﬁed methods are spr ead
out across 55classes, which are themselves spread out across 24
packages. Themethodmodiﬁcations allinvolvestructurall ymean-
ingful updates to method invocations, ifstatement conditions, or
variable assignments. Inall, over 700lines of code are affected by
thechange,noneofthemwhitespaceordocumentation-relat ed. All
of this information can be readily extracted using currentl y avail-
able automated differencing techniques.
As the change appears to be quite large, to span a signiﬁcant
number of elements, and to feature non-trivial structural c hanges,
analyses operating at any of these levels of abstraction mig ht infer
that the change is likely tointroduce a bug [16] or be symptom atic
of a decaying system [5]. Other analyses might mine the many
pairwiseassociationsbetweenthemodiﬁedmethodsandeven tually
detectnon-obvious dependencies betweenthem[25]. Howeve r,the
developer who committedthe changes characterizes the comm it in
another way. Their commit comment reads: “[Renamed] az3 con -
stants classtoConstantsV3 tomake iteasier onmybrain.” In deed,
the developer renamed the Constants class toConstantsV3 and
thencommittedallﬁlesthatweretriviallymodiﬁedbecause of ref-
erences tothe Constants class.
Based on this manual assessment, automated interpretation s of
this change set based on lines, ﬁne-grained structural diff erences,
or the set of updated methods, are likely to yield an inaccura te in-
terpretation of the software development activity or effor t behind
the change, and may thereby yield incorrect conclusions abo ut po-
tential bugs, system complexity, or non-obvious associati ons be-
tweenmethodsandchangesets. Inthiscase,adetectionofre name-
induced and other non-essential differences would have sup ported
a more meaningful abstraction of the change set.
3. NON-ESSENTIAL DIFFERENCES
Existing tool-supported techniques can analyze change set s and
detect and eliminate trivialdifferences such as whitespace- and
documentation-related modiﬁcations [7]. Our goal is to mea sure
theimpactof non-essential differencesonchange-basedapproaches.
We deﬁne non-essential differences to be low-level code cha nges
that arei)cosmetic in nature, ii)generally behavior-preserving,
andiii)unlikely to yield further insights into the roles of or rela-
tionships between the program entities they modify. We keep our
deﬁnition open-ended to emphasize that the true “essential ity” of
codechanges stilldepends ontheindividualcontextsinwhi chthey
arestudied. Wefocusononesthatareunlikelytocapturemea ning-
ful informationabout the development effortbehind achang e.
Tohelpcatalogthekindsofnon-essentialdifferenceswest udied,
we refer totwoversions of the same code, shownbelow.
// Version N // Version N+1
Object field = ... Object m_field = ...
void sample() { void sample() {
1. List l = ... java.util.List list = ...
2. l.add(this.field); list.add(m_field);
3. m(l.size()); int size = list.size();
4. return; m(size);
} }
The two versions of the samplemethod exhibit a number of dif-
ferences. In the ﬁrst line of version N, the local variable lis re-
named to listand its declared simple type modiﬁed to its equiv-
alent fully-qualiﬁed type. In the second line, a trivial ins tance of
2http://www.vuze.comthethiskeyword isremoved. Thesecond lineis alsotextuallyal-
tered by the effects of a rename refactoring of the fieldattribute.
The thirdline is modiﬁed by a local variable extraction refa ctoring
that stores the input expression to min a temporary variable size.
Finally, inthe fourth line,a redundant returnkeyword isdeleted.
Although all of these program differences may be of interest in
certain situations, we believe that they are unlikely to con tribute
relevant informationformanychange-based approaches see kingto
measure meaningful software development effort. It would b e un-
likely, for example, for a developer to perform the kinds of m od-
iﬁcations affecting the samplemethod to advance the implemen-
tation of a cohesive change task, such as developing a new fea ture
or ﬁxing a complicated bug. We further justify this reasonin g by
considering eachtype ofnon-essential difference inisola tion.
TrivialTypeUpdates
Textual updates toan entity’s declared type are non-essent ial if the
actual declared type is not affected by the update. Speciﬁca lly, a
trivial replacement of a type’s simple name with its fully-q ualiﬁed
name does notaffect howthedeclaredentityishandled atrun time.
We note that such changes cannot be detected without type res olu-
tion, since without type bindings, it would not be obvious wh ether
Listrefers tojava.util.List or some other Listtype, e.g.,
java.awt.List .
LocalVariableExtractions
Developers may improve the readability of code by using temp o-
raryvariablestostoreexpressionsandusingthosevariabl esinstead
of the expressions in a singlesubsequent program statement. Such
local variable extraction refactorings are cosmetic in nat ure, have
noeffectonaprogram’sbehavior,anddonotneedtobeperfor med
inthe context of arelatedchange task.
Rename-InducedModiﬁcations
Whenever a developer renames a program entity (i.e., class, ﬁeld,
method, parameter, or local variable), any code statement r efer-
encing that entity will be textually modiﬁed as part of the re name.
These secondary textual changes are generally not relevant when
studying program differences, as they are only a necessary b y-
product of existing program structure, which must be adapte d to
avoid compilation or runtime errors. In fact, many IDEs, e.g . E-
clipse, even help developers perform rename refactorings b y auto-
matically updating all references to renamed entities. The se kinds
ofautomatedreferenceupdatesarethusfarlesslikelytoco ntribute
meaningful insight about the development effort behind a ch ange
than the actual renaming of the code element itself. Therefo re, we
consider the actual renaming of the code element to be an esse n-
tialchange, but argue thatthe textual reference updates in duced by
that renaming are non-essential. This argument echoes one m ade
in previous work by Neamtiu et al., which presents a differen cing
technique that reports rename refactorings and all corresp onding
rename-induced updates as a single difference between prog ram
versions [17].
TrivialKeywordModiﬁcations
In our investigations of Java code history, we encountered c ases
wheredevelopersredundantlyinsertordeleteinstancesof thethis
keyword. In Java, prepending the thiskeyword to a program en-
tity only affects program behavior in a limited number of cas es.3
In thesamplemethod, the deletion of the thiskeyword has no
3Speciﬁcally, the thiskeyword is required to reference a ﬁeld inside scopesfound
to declarea localvariablesharing the samenameastheﬁeld.effectonthebehavior ofthatmethod. Whilechanges involvi ngthe
thiskeyword might improve readability, they can be considered
non-essential in most contexts. In this category we also cur rently
also include trivial insertions or deletions of returnstatements at
the end of void-returning methods and trivial insertions or dele-
tions of default superinvocations occurring at the top of default
constructors. In Java, such modiﬁcations have no effect on a pro-
gram’s behavior. We do not currently include other keyword u p-
dates, suchas those involvingaffectingthe visibility,mo diﬁability,
or overridabilityof a code entity.
LocalVariableRenames
Developers may rename local variables only to increase the o ver-
all readability of the code. While a cosmetic change of this n ature
might be interesting for a study of code readability, in the g eneral
caseitistypicallyunimportant toachange taskorbugﬁx. In those
cases where a variable name update truly does imply a change i n
the role of the variable, then this role change will be accomp anied
by other essential code changes, e.g., modiﬁcations to meth od in-
vocations or control ﬂow involvingthat variable.4
WhitespaceandDocumentation-RelatedUpdates
Whitespace and documentation-based modifcations are alre ady ig-
nored by other change analysis tools, such as C HANGEDISTIL-
LER[7]. In our investigation of non-essential differences, we took
steps to eliminate these modiﬁcations from our input data. W e
thus only report on the prevalence and possible impact of the non-
essential differences outlinedabove.
4. DETECTION TECHNIQUE
All of the non-essential differences outlined in Section 3 o ccur
within programming language statements or expressions. Co nse-
quently,todetecttheminchangehistoryrequiresanalyzin gchanges
at a level of granularity ﬁner than statement differences. D etecting
the non-essential differences in our catalog also requires resolving
the type bindings of expressions within statements, a techn ically
challenging taskgiventhattheﬁlesanalyzedarenot partof acom-
plete and compilable system.5For example, to detect trivial this
keyword insertions requires an analysis that detects not on ly the
additional thiskeywords, but also veriﬁes that no type bindings
were altered by their insertion. Detecting non-essential c hanges
in version histories thus requires a differencing techniqu e that is
both ﬁne-grained (working at the level of expressions withi n state-
ments)andtype-sensitive(toreasonabouttheimpactofcha ngeson
the program behavior). Although existingchange analysis t ools al-
readysupportﬁne-graineddifferencingofindividualprog ramstate-
ments, we know of no change differencing tool that is both ﬁne -
grained andtype-sensitive at the expression (sub-stateme nt) level.
To detect non-essential differences, we therefore develop ed a
mining technique that is both ﬁne-grained and type-sensiti ve; we
implemented our technique in a tool called D IFFCAT. Similar to
existing change analysis tools, D IFFCATtakes a group of co-com-
mitted source ﬁles retrieved from a software repository (a c hange
set) and returns as output a description of the various struc tural
modiﬁcations characterizing that change set. In addition t o previ-
ous techniques, however, our technique also uses type resol ution
to further identify and label structural changes that are al so non-
essential. For example, D IFFCATdetects and labels cases where
4In very rare cases, a variable renaming might cause the varia ble to shadow an ex-
isting variable. In these cases, our differencing techniqu e classiﬁes the rename as
non-essentialand theresulting method update asessential .
5Software archivesdonot storeenoughmeta-datatosystemat icallyregenerateafully
built systemto matcheachindividual changein isolation.a program statement was modiﬁed only by the trivial insertio n of
one or more thiskeywords. D IFFCATis currently implemented
tohandle Java code storedinCVSand SVNrepositories.
4.1 Reused Components
Workingwithprogramreferencesrequirestypebindings,or ways
of resolving possibly ambiguous references to a program ele ment
to the corresponding fully-qualiﬁed element name. Type bin dings
are generally unavailable when working with partial progra ms, or
collections of code ﬁles with missing dependencies, like th ose re-
trievedaspartofachangesetfromtypicalversionreposito riessuch
as CVS or SVN. Missing dependencies make it difﬁcult to unam-
biguously identifytheindividual program entitiesbeingr eferenced
in various statements, thus restricting the amount of infor mation
that canbe inferredabout those statements.
Tohelprecovermissingbindings,weusePartialProgramAna ly-
sis(PPA).PPAisageneral technique forresolvingbindings inpar-
tial programs. In the case of Java, a recent implementation o f PPA
has been shown to recover over 90% of missing bindings in par-
tial programs [2]. For example, using PPA allows change anal yses
to conﬁdently determine whether a newly inserted thiskeyword
affects the element reference towhichitwas prepended.
OurreusedPPAimplementationworkswithAbstractSyntaxTr ee
(AST) representations of Java code. AST representations of Java
ﬁles can easily be constructed using existing tool-support , such as
the Eclipse-based JDT-C OREplug-in. Consequently, given PPA’s
AST-based output, we decided to detect non-essential diffe rences
using AST-differencing to more easily incorporate PPA-inf erred
type bindings into our differencing technique. We decided a gainst
using a other kinds of differencing techniques, e.g., token -based
ones, to avoid the conceptual challenge of working with mult iple
program representations.
To further facilitate our detection of ﬁne-grained non-ess ential
differences between ASTs, we use C HANGEDISTILLER , a state-
of-the-art tool that identiﬁes statement-level structura l changes be-
tween Java AST pairs [6, 7]. We enhanced the output computed
byCHANGEDISTILLER withPPA-inferredbindingsandperformed
additional processing todetect non-essential difference s.
4.2 Identifying Modiﬁed Statements
CHANGEDISTILLER expresses differences between two source
code ﬁles as edit scripts, or sequences of edit operations (e .g., in-
sertions, deletions, or updates) involving structuralent ities atvary-
ing levels of granularity. In particular, C HANGEDISTILLER does
not express program updates at granularities ﬁner than indi vidual
program statements. Instead, it relies on a measure of textu al sim-
ilarity between statement versions to detect cases where a s tate-
ment was modiﬁed, rather than inserted or deleted. This mean s
that, given a high enough textual disparity between stateme nts,
CHANGEDISTILLER ﬂags unmatched statements as deletions or
insertions, rather than updates. Although high textual dis paritybe-
tween candidate statement pairs is generally a good indicat ion that
the pair corresponds to an insertion-deletion pair and not a modi-
ﬁed statement, in some cases, high textual disparity betwee n ver-
sions of modiﬁedstatement canalsoarise because of non-ess ential
differences, e.g.,renamerefactoringsinvolvingtextual lydissimilar
names. For example, if a developer renames a ﬁeld called oldto
newValue and a local variable called valtoarg, then the follow-
ingassignment statement pair
this.old = val; //v1 newValue = arg; //v2
exhibits a high degree of textual disparity, despite being f unction-
ally identical. Given that all of the non-essential differe nces out-lined in our catalog occur withinmodiﬁed statements, we wer e re-
quired to address this challenge to avoid mislabeling a pote ntially
large amount of non-essential differences.
4.3 Approach
We observed that the challenge described in Section 4.2 typi -
cally arises because of rename refactorings. Rename refact orings
can increase both the textual disparitybetween individual program
statements and the general difﬁculty of operating on AST-ba sed
representations of code change. For example, discovering t he non-
essentialstatementupdateoutlinedaboveismoredifﬁcult thandis-
coveringthesameupdate minustheeffectsofrename refacto rings:
this.old = val; //v1 old = val; //v2
becausethelatterupdateexhibitsahigherdegreeoftextua lsimilar-
ity, making it easier to identify it as a statement update in t he ﬁrst
place. Furthermore, the latter update only textuallydiffe rs because
ofthiskeyword deletions, which, in our setting, makes it easier
todetect and verifythe non-essentialityof the statement u pdate.
Our technique for detecting non-essential differences is b ased
on the realization that the effects of rename refactorings s hould be
eliminatedwhendifferencingsourceﬁles. Wethususeatwo- phase
tree-differencing technique to identify ﬁne-grained modi ﬁcations
betweensourceﬁlesandtolabelthosethatarenon-essentia l. Inthe
ﬁrst phase, we use C HANGEDISTILLER and our own analyses to
detect rename refactorings. Wethen rollback those renames inthe
ﬁlesweanalyze byresettingthetextual descriptors ofallr enamed-
affectedprogramreferencestodisplaytheiroldnames. Wet henre-
run CHANGEDISTILLER on the modiﬁed ﬁles and further process
thedetectedupdatestoidentifythosethatwereaffectedon lybythe
non-essential differences outlinedinour catalog.
4.4 Implementation
WereuseinfrastructureprovidedbyS EMDIFF[3],achangeanal-
ysistoolforstudyingframeworkevolution. S EMDIFFretrievesand
representschangesetsascollectionsofﬁlepairs. Eachﬁle paircor-
responds to the two versions of a ﬁle found to have been modiﬁe d
aspartofthechangeset. Eachﬁle-pairisprovidedtoD IFFCATasa
pair of ASTs. With D IFFCAT, we then identify ﬁne-grained struc-
turaldifferences(includingnon-essential ones)through asequence
of nine high-level operations. In the description of this se quence,
we assume that identiﬁed differences are stored in a set, whi ch we
refer toas changes. We proceed as follows:
1. We run PPA on all input ASTs to resolve type bindings in
statements and expressions.
2. WeuseC HANGEDISTILLER toidentifystructuraldifferences
between AST pairs. We collect all method and ﬁeld rename
refactorings from these differences.
3. We add to the list of rename refactorings by detecting re-
names of classes and local variables, as well as additional
cases of ﬁeldrenames.
4. WeprocessASTpairsrepresentingrenamedclassestodete ct
rename refactorings withinthe renamedclasses themselves .
5. Alldetected rename refactorings are storedin changes.
6. Usingtherenamesin changes,wetraversetheASTsofeach
modiﬁed ﬁle pair to roll back the textual identiﬁers of all
element references affectedby arename.
7. We re-run C HANGEDISTILLER on the modiﬁed AST pairs
andcollect all reportedstructural differences.
8. We process the structural differences and identify those that
arenon-essential. Westoreallstructuraldifferencesin changes.9. We reconcile changes inferred in Step 2 that were no longer
reported in Step7 because of our rename rollback. We label
these changes as non-essential andadd them to changes.
We provide additional details about our procedure below.
DetectingClassRenames
CHANGEDISTILLER does not identify class renames. We detect
thesebydetectingclassinsert-deletepairssharingahigh proportion
of identical ﬁeldandmethod signatures ( ≥0.5).
DetectingField Renames
CHANGEDISTILLER detectsﬁeldrenamesbycomparingtheirdec-
laration statements using the Levenshtein similarity meas ure. In
certaincases,C HANGEDISTILLER isunabletorecognizearenamed
ﬁeld because of a high textual disparity between its declara tion
pairs. We try to augment the number of detected ﬁeld renames
by iterating over all possible ﬁeld insert-delete pairs wit hin each
class and checking whether references to the old ﬁeldwere al ways
replaced by references to the new ﬁeld. We check this conditi on
in all statement updates found in Step 2. We note that our anal y-
sis rejects a ﬁeld insert-delete candidate if even a single s tatement
update does not satisfyour criterion.
RenameReconciliation
Step9isnecessarytoproperlyidentifyrename-inducednon -essen-
tialdifferencesthatwereeliminatedbytherename rollbac kinStep
6. Forexample, the rename-induced statement update
old = val; //v1 newValue = val; //v2
will be detected in the ﬁrst C HANGEDISTILLER pass because of
the textual disparity between the oldandnewValue entity. How-
ever, after rename rollback, the two statements will be text ually
equivalent and the update will no longer be detected by C HANGE-
DISTILLER in the second pass. To cope with this, we collect all
statement-basedstructuraldifferencesfromStep2andver ifywhether
these were again detected in Step 7. If a change was no longer
detected in the second phase, we conclude that the change was re-
name-induced and add it to our list of detected changes. With out
this additional step,our procedure would missthese update s.
5. EMPIRICALSTUDY
We sought to understand the potential impact of non-essenti al
differences on higher-level abstractions of software deve lopment
effort. To this end, we used D IFFCATto analyze change sets from
seven open-source Java systems and to collect essential and non-
essential differences between committed ﬁle-pairs. We the n deter-
minedi)the relative code churn associated with non-essential dif-
ferences and ii)how often change sets include methods that were
modiﬁed only by non-essential differences. We used our resu lts
to estimate how non-essential differences would interfere with the
information measured bychange-based approaches.
5.1 Set up
Table 1 describes the systems used for our evaluation. Colum ns
inthetableinclude thenumber ofchange setsstudiedforeac hsys-
tem (Chg. Sets) and the number of days spanned by those change
sets (Days). We studied the same systems as those analyzed in a
prior study on change clusters [21] to help us assess the effe cts of
non-essential differencesontheresultsofclientanalyse s. Westud-
iedallchange setsthat occur withinthe ranges reportedinT able 1.
We used D IFFCATto determine the differences within change
sets. Like other differencing tools, D IFFCATdoes not report anyTable1: Characteristics of Target Systems
System First Last Days Chg. Sets
Ant 6Dec 2001 17 Jul 2007 2,048 3,853
Azureus 12 Nov2003 14 Jul 2004 244 3,103
Hibernate 4Dec 2003 19 Aug2005 623 3922
JDT-Core 17 Jan2002 15 Jul 2003 544 4192
JDT-UI 20 Aug2001 15 May2002 268 3081
Spring 1Feb2004 6Feb2006 736 3627
Xerces 17 May2001 8Nov 2007 2366 2681
Total 6463 24459
differences arising from white spaces. We also ignored all d iffer-
ences affecting comments and Javadocs, i.e., we did not consider
whitespace-,documentation-, orcomment-baseddifferenc esinany
of our results . We used the remaining differences to compute each
change set’s total code churn (LOC added, deleted, or modiﬁed)
andtoidentifythemethods thatwere modiﬁedbyeachchange s et.
We then identiﬁed all non-essential differences to compute non-
essential code churn and to identify which methods were modi ﬁed
only bynon-essential modiﬁcations.
We computed code churn by considering the LOCs involved in
each reported structural difference. Our code churn measur e thus
differsslightlyfromthatwhichwouldbe computed bypurely line-
baseddifferencingtechniques. Forexample,becauseofour rename
rollback, D IFFCATmay identify that a LOC was updated, while
other differencing techniques may report this difference a s a LOC
insertion-deletionpair. WechosetouseD IFFCATtocomputechurn
to obtain the most precise estimate of the true churn arising from
non-essential differences.
Achangesetwasconsideredtomodifyamethodifitupdatedth e
bodyofthatmethodviaone ormorestructuraldifferences (i .e.,we
neverconsidered documentation-relateddifferences asup dates toa
method). For simplicity, we refer to the number of methods fo und
to have been updated by a change set as the number of method
updatesfor that change set. We labeled a method update as non-
essential if the method update consisted only of non-essential dif-
ferences. Allother method updates were considered essential. The
total number of method updates for a system corresponds to th e
total number ofmethod updates found across allchange sets.
We explicitly tracked method signature refactorings throu ghout
our evaluation, i.e., we did not treat methods modiﬁed by suc h
refactorings as method insertion-deletion pairs. If a meth od’s sig-
nature and body were both updated by a change set, then we in-
cluded the refactored method within the set of method update s for
that change set. If only the method’s signature was updated, then
we did not include the method within the method update count f or
that change set. We did not include method deletions or inser tions
within the method update count because our investigation fo cused
onthe modiﬁed methods for eachchange set.
WeranPPAand C HANGEDISTILLER ontheir default settings.
5.2 Prevalence ofNon-Essential Differences
Table 2 records the overall code churn for each target system
(in kLOC). The table shows the total number of code lines that
were deleted (-), inserted (+), or modiﬁed (~) for each syste m. It
shows how many of the modiﬁed lines were caused by three ma-
jor classes of non-essential differences detected by our ap proach:
differences induced by renames (R), trivial keyword update s (K),
and local variable refactorings (L). The “L” column aggrega tes lo-
cal variable extractions, local variable renames, and triv ial updates
to local variable declared types. The combined non-essenti al line
modiﬁcations arereportedintheﬁnalcolumn(NonEss.). The per-Table2: Code ChurninTarget Systems (inkLOC)
System - ~ + R K L Non Ess.
Ant 113 35 301 6.8 .8 .4 8.0(22.9%)
Azureus 49 95 108 2.6 .0 .1 2.7( 2.8%)
Hibernate 63 35 196 2.9 .0 .2 3.1( 8.9%)
JDT-Core 47 16 73 1.8 .6 .2 2.6(16.3%)
JDT-UI 72 23 100 1.3 .0 .1 1.4( 6.1%)
Spring 43 27 126 3.8 .6 .2 4.6(17.0%)
Xerces 62 15 196 1.0 .0 .1 1.1( 7.3%)
Total 449 246 1100 20.2 2.0 1.3 23.5(9.6%)
centages displayed in this column correspond to the proport ion of
all modiﬁedcode lines (~) thatwere found tobe non-essentia l.
Table 2helped us derive the following observation:
Between2.8%and22.9%ofmodiﬁedcode lineswere updated
only vianon-essential differences.
This suggests that for some systems, non-essential differe nces can
signiﬁcantlyincreaseline-modiﬁcation-basedabstracti onsofchange.
Fromthetable,wealsoseethatacrossthetargetsystems,ac om-
bined246kLOC were modiﬁed. We see that 23.5(9.6%) of the
total246modiﬁed kLOC were modiﬁed only by non-essential dif-
ferences. Basedonpreviousdeﬁnitionsof totalcodechurn [16],we
alsoseethatonly 23.5(1.7%)oftheoverall( 1100+246 =)1346
churnedkLOC were modiﬁed only by non-essential differences,
because thelargenumber ofaddedcodelinesdwarfstheimpac ton
existing, changed lines. This suggests that the kinds of non -essen-
tial differences studied in our investigation do not affect measures
oftotal code churn (thatinclude added and modiﬁedlines).
Table 2alsoenabled us toinfer the followingproperty:
Out of the non-essential differences currently detected by our
approach, most were induced by rename refactorings or up-
dates involving trivial thiskeywords.
In particular, of the 23.5non-essential kLOC reported inthe table,
86%consisted of rename-induced statement updates, 9%of trivial
keyword updates, and the remaining 5%of local variable refac-
torings. Afurtherbreakdownoftheindividualnon-essenti aldiffer-
enceclassesrevealedthatmorethan 99%ofnon-essentialkeyword
updates consistedoftrivial thiskeywordinsertions anddeletions,
over90%of all detected local variable refactorings consisted of
local variable renames, and that almost no variable refacto rings
(<1%) involved triviallocal variable type updates.
Non-EssentialMethodUpdates
Table 3 records the total number of method updates that were d e-
tected for each target system. The table shows the total numb er
of method updates (Total) and the number of those updates tha t
wereinducedentirelybynon-essentialdifferences(Non-E ssential).
It also records how often different classes of non-essentia l differ-
ences contributed to a non-essential method update. We reco rded
thisnumberforrename-inducedupdates(R-Induced),keywo rdup-
dates (Keyword), and local variable updates (Local). We not e that
thesumacross theindividual columns ishigher thanthetota lnum-
ber of non-essential updates because some non-essential me thod
updates involved multiple classes of non-essential differ ences.
From the table, we see that out of a combined 80378method
updatesacrossthetargetsystems, 7211(9.0%)werenon-essential.Table3: MethodUpdates inTarget Systems
Total Non-Essential R-Induced Keyword Local
Ant 17792 2759 (15.5%) 2227 531 110
Azureus 8731 229 (2.6%) 227 1 5
Hibernate 15881 1153 (7.3%) 1136 6 52
JDT-Core 8837 673 (7.6%) 542 133 98
JDT-UI 9681 426 (4.4%) 424 0 13
Spring 11047 1715 (15.5%) 1508 216 74
Xerces 8409 256 (3.0%) 250 6 5
Total 80378 7211 (9.0%) 6314 893 357
Table4: Non-EssentialMethodsinChangeSets
System Total Non-Essential R-Induced Keyword Local
Ant 2579 283 (11.0%) 263 86 39
Azureus 2866 65(2.3%) 63 1 4
Hibernate 3024 303 (10.0%) 295 6 35
JDT-Core 2015 175 (8.7%) 153 33 45
JDT-UI 2152 145 (6.7%) 143 0 14
Spring 2400 454 (18.9%) 396 100 62
Xerces 2037 77(3.8%) 73 5 5
Total 17073 1502 (8.8%) 1386 231 204
The table alsoenabled us tomake the followingobservation:
In the individual systems analyzed, between 2.6%and15.5%
of all method updates were non-essential.
This suggests that for some systems, non-essential differe nces can
distort method-based abstractions of change span .
Distribution ofNon-EssentialMethodUpdates
Table 4 shows how many of the analyzed change sets included
non-essential method updates. The table records the total n umber
of change sets that included modiﬁcations to at least one met hod
(Total). The remaining columns record the number of change s ets
found to include at least one non-essential method update (N on-
Essential),one non-essentialmethodupdate featuringare name-in-
duced non-essential difference (R-Induced), a keyword dif ference
(Keyword), ora local variable refactoring(Local).
From the table, we see that out of 17073change sets found to
modify at least one method, 1502(8.8%) included at least one
non-essential method update. The table also enabled us to ma ke
the followingobservation:
Insomesystems,non-essentialdifferencesdistortedmeth od-le-
vel change representations of over 10.0%ofchange sets.
This suggests that non-essential differences can impact me thod-le-
vel representations of a non-negligible number of change se ts.
We next observed that method updates in smaller change sets
were less likely to be non-essential than method updates in l arger
change sets. For example, we found that only 2.6%of method up-
dateswithin“small”changesets(e.g.,thosemodifying 1to3meth-
ods) were found to be non-essential. This ratio increases to 7.8%
for “regular” change sets (e.g., those modifying 4to19methods)
and14.2%in“large”changesets(e.g.,thosemodifying 20ormore
methods). We observed similar proportions for other ranges . This
data enabled us todraw the following conclusion:Non-essential differences had the highest impact on method
levelrepresentations of larger change sets.
This observation is important because it means that change- based
approachescouldbotheliminateamajorityofnon-essentia lmethod
updates and mitigate their most signiﬁcant relative impact on me-
thod-levelrepresentationsbyusingalternatedifferenci ngstrategies
for larger change sets. For example, we found that aside from
featuring high densities of non-essential method updates ( 14.2%),
change setsmodifying 20ormoremethods alsocontainedanover-
all majority ( 55.9%) ofalldetected non-essential method updates.
Change-based approaches could exploit this general observ ation
whenscanningchange setsbyﬁrstusingalightweightdiffer encing
technique tocompute achange set’smethodlevel change span and
then switchingto a more sophisticated differencing techni que only
incases wherethe measured change span exceeds a certainthresh-
old, e.g., 20. This kind of strategy is advantageous because larger
change setstendtoappear relativelyinfrequentlyinchang e history
(e.g.,inthe data we analyzed, only 2.4%of allchange sets modify
20ormoremethods),whichmeanschange-basedapproachescoul d
avoidthecomputational burdenofpartialprogramanalysis inmost
cases, while still detecting a relevant proportion of non-e ssential
method updates withinchange sets.
Finally,we observed that non-essential method updates wer ein-
terleaved withother essential method updates in a majority ( 79%)
of cases. This result corroborates ﬁndings of a previous inv esti-
gation by Murphy-Hill et al., which showed that developers o ften
interleavedrefactoringswithothermodiﬁcations[15]. Th eseobser-
vations suggest that in cases of interleaved changes, a ﬁne- grained
detection of non-essential differences can help change-ba sed ap-
proaches obtainpreciserepresentations ofthemeaningful software
development work behind a change (as opposed to capturing th e
effects of tool-assistedrefactorings or trivialkeyword i nsertions).
5.3 Impact ofNon-Essential Differences
Tohelpus furtherasses the possible impactof non-essentia l dif-
ferences on the results of existing change-based approache s, we
implemented a simple method-pair association rule mining a naly-
sis similar to that of Zimmermann et al. [25] and evaluated ho w
thequalityof the recommendations produced by our analysis was
affected by the kinds of method updates used to train the anal ysis.
Speciﬁcally,wesought tocompare thequalityoftherecomme nda-
tions produced when all method updates were used to learn rul es
against their qualitywhen onlyessential updates were used .
Our analysis takes as input a given sequence of change sets,
records the methods that were modiﬁed as part of each change
set, and then uses this information to produce recommendati ons
for a developer. Speciﬁcally, similar to Zimmermann et al.’ s ROSE
tool[25],ouranalysissupportsdeveloperswhohavemodiﬁe dsome
initialmethod miaspartofsomechangeset tkandwhowouldlike
to ﬁnd additional methods mjthat also need to be changed along
with method mi. Our analysis helps developers by inferring rules
(mi→mj)from which we can return a ranked list of methods
mjthatwerefoundtohavebeenfrequentlyco-modiﬁedwith miin
prior change sets Hk:=t0,...,t k−1. We rank recommendations
(mj)forachangeset tkbasedonthe conﬁdence oftheinferredrule
(mi→mj). We use their supportvalues as tie breakers. Finally,
we alsoﬁlterout recommendations withconﬁdence lower than 0.1
and capthe number of recommendations at ten[25].
Tocomparethequalityoftherecommendations producedbyou r
analysis when trained using all methods (the regular setup) against
their quality when we train it only on essential methods (our pro-
posed setup), we compared several metrics used by Zimmerman nTable5: Recommendation Quality
Setup Tot Rec Feedback Prec L3 OnlyErr
Reg93576 10214 0 .219 0.442 0 .220
Prop81162 9242 0 .242 0.475 0 .183
et al. in their evaluation [25]. To compute these metrics, we re-
playedthechange historyintervalsofourseventargetsyst ems(see
Table 1) and determined which ranked recommendations mjour
analysis would have made for method updates miintkw.r.t. rules
learnedupuntilthenfrom Hk.6Wethenrecordedwhether mjwas
alsoupdated as part of tkand used this totag eachranked seed-re-
commendation pair (mi,mj)intkas either “helpful” or not. This
produced two sets of non-empty ranked recommendation lists for
38047different seed methods. We found that the recommenda-
tions were different in 10218cases, or for 26.9%of those38047
seed methods where there was at least one recommendation. We
thencomparedthequalityoftherecommendationsforthese 10218
cases.
Our metricsallowed us totomake the following observation:
Forthosechangedmethodsforwhichatleastonerecommenda-
tionwasmade byour analysis,removing non-essential metho d
updatesimprovedtheoverallprecisionoftherecommendati ons
by10.5%and decreased their recall by 4.2%
Table 5 presents this observation in more detail. For each se tup,
the table records the total number of recommendations made b y
our approach (Tot Rec), the number of method changes for whic h
at least one recommendation was made (Feedback), and the pro -
portion of recommendations that were found to have been help -
ful (Prec). It also records the proportion of changed method s for
which at least one helpful recommendation was found in the to p
3recommendations (L3) and the proportion for which no helpfu l
recommendations were made (OnlyErr).
From the table, we see that the precision of the approach im-
proved by (.242/.219≈) 10.5%and its total number of helpful
recommendations decreased from (.219×93576 =) 20501 to
(.242×81162 =)19631 , orbyaround 4.2%. Wealsoseethatthe
proportionofchangedmethodforwhichatleastonehelpfulr ecom-
mendation was found in the top three recommendations increa sed
by(.475/.442≈)7.5%and that the proportion for which only er-
roneous recommendations were made decreased by (.22/.183≈)
20.2%. Hence, given this general reduction in the number of false
positives produced by our approach, and despite the slight l oss in
recall, we argue that the overall quality of the recommendat ions
produced by our association analysis was improved after we r e-
moved non-essential method updates from consideration.
5.4 Precisionofthe Detection Technique
We performed a manual inspection to verify the precision wit h
which D IFFCATidentiﬁed rename refactorings and non-essential
method updates. We focused on non-essential method updates ,
ratherthanallreportednon-essentialdifferences,becau seerroneous
classiﬁcationsofmethodupdatesaremorelikelytohaveane gative
inﬂuence on the representations used by change-based appro aches
thanerroneous classiﬁcations of isolatedstatement updat es.
To select change sets for a given system, we ﬁrst sorted the sy s-
tem’schange setsaccordingtothenumber ofnon-essentialm ethod
updates theycontained. We then went down this list indescen ding
6Weonlyconsidered essentialmethodupdatesascandidateseedstoeliminateallspu-
riousmethodsthatwereonlyindirectlymodiﬁedviaoneormo rerenamerefactorings,
and hencenotlegitimate candidateseedsfor our experiment .Table6: Characteristics of SelectedChange Sets
System CS NEMs CR MR FR PR VR
Ant 29 1386 0 46 813 208 103
Azureus 4 113 2 28 3 2 31
Hibernate 33 580 30 134 52 88 24
JDT-Core 16 336 1 10 47 135 74
JDT-UI 23 213 29 57 14 42 28
Spring 51 857 44 240 134 469 43
Xerces 11 132 13 103 26 18 1
Total 167 3617 119 618 1089 962 304
Table 7: Precisionof theTechnique(in%)
System NEMs CR MR FR PR VR
Ant 99.9 n/a 95.6 99.9 100 90.3
Azureus 100 100 100 100 100 83.9
Hibernate 99.7 96.7 88.8 94.0 90.9 70.1
JDT-Core 99.1 100 60.0 95.7 100 89.1
JDT-UI 93.3 72.4 73.7 50.0 47.6 67.9
Spring 97.7 93.1 86.7 97.8 91.9 88.4
Xerces 97.7 100 98.1 96.2 94.4 100
Total 98.8 89.9 88.5 98.7 92.8 85.5
order and selected all change sets until we had accounted for half
of all the non-essential method updates within the system. I n this
way, we limited our manual inspection to 167change sets across
the seven systems.
Table6records,foreachsystem,thenumberofchangesetsst ud-
ied(CS)andthenumberofnon-essentialmethodupdatesthat were
detected by D IFFCAT. It alsorecords the number ofclass, method,
ﬁeld, parameter, and variable rename refactorings (CR, MR, FR,
PR, VR) that were detected by D IFFCAT. We investigated the cor-
rectness of these reported refactorings and non-essential method
updates. Weassessedreportedrenamerefactorings bycaref ullyin-
specting all available code, the relative placement of inse rted and
deleted entities within code, documentation, and the commi t com-
ment of each change set. We used our rename classiﬁcations to
judge the correctness of rename-induced statement updates that
were detected by D IFFCAT. We used the correctness of rename-
induced statement updates and other non-essential differe nces to
judge the correctness of each non-essential method update. Based
on our manual investigation, wewere able toassert that:
DIFFCATcorrectly classiﬁed non-essential method updates
98.8%of the time.
Table7presentstheprecisionofourdetectedentityrename sand
non-essentialmethodupdatesinmoredetail. Thetabledisp laysthe
proportion of correct classiﬁcations foreach ofthe result s reported
in Table 6. From the table, we see that the overall precision o f
our approach for rename detection ranges from 85.5%(variable
renames) to 98.7%(ﬁeld renames). The table also shows that our
approachidentiﬁednon-essentialmethodupdateswithinin dividual
systems witha precision ranging from 93.3%to100%.
The precision of non-essential method updates was higher th an
that of detected rename refactorings because only a small nu m-
berofallerroneouslyclassiﬁedinsertion-deletionpairs actuallyre-
sulted in erroneously classiﬁed statement updates, and onl y a few
of those statement updates were sufﬁciently isolated withi n meth-
ods tocause anentire method update tobe erroneously classi ﬁed.5.5 Discussion
Non-EssentialDifferences
The true “essentiality” of code differences, method update s, and
pairwise method associations is tied to the speciﬁc goals of indi-
vidual change-based approaches. We believe that accountin g for
thekindsofnon-essentialmethodupdatesdetectedbyourap proach
will be most useful for change-based approaches that aim to a na-
lyze only speciﬁc classes of software development effort, s uch as
effort related to feature implementations or bug ﬁxes. The u lti-
mate goal of our research is to enable change-based approach es
to more precisely select the low-level modiﬁcations on whic h they
base theirhigher-level change representations.
Our current catalog of non-essential differences did not in clude
a number of additional ﬁne-grained differences that may be c on-
siderednon-essential insomecontexts. Forinstance,chan ge-based
approaches might also be interested in ignoring updates inv olving
trivialfinalkeywords in local variable declarations, redundant
class casts, or other updates to code that are less likely to p ro-
vide meaningful insight into the kind of development work th at is
of interest to these approaches. Ideally, change-based app roaches
should be able to parameterize their change representation s to in-
clude onlythose code changes thataremost relevant forthei ranal-
yses. Because the types of non-essential differences that c an be
detected is open, it should be noted that the numbers we repor t are
anunderestimateofallthepossiblenon-essentialchanges thatmay
exist in the histories of the software systems we studied. Mo re-
over, we did not attempt to estimate the recall of our techniq ue. In
general, we designed the technique tobe precise (i.e.,toch aracter-
ize differences as non-essential only in the presence of str ong evi-
dence). For this reason, hard-to-classify differences tha t may turn
out tobe non-essential inpractice wouldnot have been inclu dedin
ourresults,furthercontributingtoour numbers represent ingalow-
er-bound estimate of the prevalence of non-essential diffe rences.
Our empirical investigation produced a number of observati ons
about non-essential differences thatwebelieve arereleva nttoava-
riety of change-based approaches. For example, we observed that
between2.6%and15.5%ofasystem’smethod updates canbede-
scribed exclusively in terms of non-essential differences , and that
thesekindsofmethodupdatesinterferewithanon-negligib le num-
ber of frequent pairwise method associations supported by c hange
data. Eliminatingnon-essential method updates should thu s have a
positive impact on the results of change-based approaches s eeking
to detect meaningful associations between method pairs. Ba sed on
otherobservations, wealsoexpectnon-essential methodup datesto
be most relevant for change-based approaches that do not spe cif-
ically pre-ﬁlter large or modiﬁcation-intensive change se ts from
their analyses.
GeneralizabilityoftheResults
Our investigation focused on seven open-source Java system s. We
expect our observations on non-essential differences to mo st read-
ily generalize to other systems of similar size and develope d using
similar development practices as those used by the develope rs of
our studied target systems. The systems we analyzed are all d evel-
oped in association with major open-source software distri butors
(Spring, Apache, JBoss, and Eclipse), except for A ZUREUS, the
development of which is coordinated by a digital media techn ol-
ogy company (Vuze). All analyzed systems included code com-
mits from between 10to23contributors, except for JDT C ORE,
whichincludedcommitsfromjustsix. Thesizesoftheinvest igated
projects are in the order of between 100and500kLOC. Our re-
sultsmaythereforenotgeneralizetoprojectsfeaturingsi gniﬁcantlylarger code bases or development teams, or those following m ore
tightly regimented development practices. Systems develo ped in
other programming language may not exhibit similar proport ions
of non-essential differences as those reported inour inves tigation.
6. RELATED WORK
Our investigation of non-essential differences in change h istory
complements existing research that seeks to increase the pr ecision
with which software changes can be abstracted and incorpora ted
intosoftware engineering tools.
DifferencingTools
Ourresearchisrelatedtoexistinggeneral-purposediffer encingtools
that operate on various program representations (e.g., tex t or Ab-
stractSyntaxTrees)andatdifferentlevelsofgranularity (e.g.,lines
orelementreferences)toaligncodeelementsbetweenprogr amver-
sions[12]. Incontrast,ourgoalistoidentifychangesbetw eencode
elements and to also classify them in terms of their relevanc e to
higher-level representations of development effort.
OurdifferencingtoolbuildsspeciﬁcallyonC HANGEDISTILLER ,
a tool-supported differencing technique that identiﬁes st atement-
level differences between ASTs [7]. Like other tools, C HANGE-
DISTILLER ignores whitespace-related differences and identiﬁes
documentation-relatedupdates. Ourapproachextendsitst echnique
by usingtype resolutiontodetect non-essential differenc es.
Other tools have also focused on eliminating spurious textu al
differences between programs. For example, similar to our w ork,
Neamtiuetal. developedanAST-baseddifferencingtechniq uethat
compares program snapshots and detects rename refactoring s and
rename-induced statement updates [17]. In contrast, we des cribe
a more general category of change that includes rename-indu ced
updates and other non-essential differences. We also detec t such
changes inindividual change sets,not between snapshots.
Ouruseofpartialprogramanalysis[2]toinfertypebinding sand
support program differencing at the granularity of referen ced pro-
gramelementsechoespreviousworkbyDagenaisandRobillar don
framework evolution [3]. However, instead of operating on d iffer-
ences between call graphs to detect call-change relations, we work
with ﬁne-grained modiﬁcations to detect non-essential dif ferences
occurring at the sub-statement level.
CodeCloneDetection
Our work on detecting non-essential differences complemen ts re-
search on code clone detection. Similar to clone detection, our
aim is to detect pairs of code fragments (e.g., methods) that are
identical modulo non-essential differences. In particula r, all of the
non-essential differences currentlydetectedbyour appro ach are or
couldbeusedbyexistingcodeclonedetectorstodetectsimi larpro-
gram fragments [1]. However, the converse is not true, i.e., clone
detectors generally ignore additional kinds of difference s that we
consider to be essential. For example, a clone detector migh t de-
tect code fragments that differ only by the insertion of an ad di-
tional method invocation or updated variable assignment, w hereas
we consider such updates tobe essential.
Higher-LevelStructuralPatterns
Our detection of non-essential differences complements ex isting
approaches thatsummarizegroupsoflow-levelchangesinte rmsof
higher-level patterns. Such approaches include performin g origin-
analysis todetect method splits [9], refactoring detectio n tools [4],
or research on identifying recurring bug ﬁxes in change data [18].
Our work complements these approaches by classifying speci ﬁcgroups of low-level changes as non-essential differences. Further-
more, although we currentlypartly relyon C HANGEDISTILLER to
detectrenamerefactorings,wecouldalsoextendourcurren tdetec-
tion of non-essential differences to incorporate renames d etected
by other tools. Other work with goals similar to our research in-
cludes Kim and Notkin’s approach for discovering groups of l ow-
level changes exhibiting logical high-level structural pa tterns [13].
The abstraction of changes used by their tool (LSD IFF)could also
be used tohelpchange-based approaches ignore groups of sys tem-
atic updates involvingonly non-essential differences. Ho wever, L-
SDIFFcurrentlyprocessesonlycoarse-graineddifferencesbetw een
programs and is implemented to handle program snapshots, no t
change sets. A detection of ﬁne-grained type-resolved stru ctural
differences within change sets could enable LSD IFFto extend its
rulegeneration tocoverbroader classesofchanges andenab le itto
operate onindividual developer commits.
ImpactofCodeChanges
Our detection of non-essential differences is related to ap proaches
thatmeasure thepossible impactofchanges onthe underlyin gsys-
tem. Theseapproaches canwarndevelopers aboutchanges tha tare
likely to introduce bugs [14] or affect program behavior [19 ]. Our
differencing technique complements these approaches by id entify-
inglow-levelchanges thatareunlikelytointroduce bugsor require
extensive re-testing.
Differential symbolic execution (DSE) also identiﬁes a pot en-
tiallyunlimitednumber ofclasses of non-essential method updates
byidentifyingupdates thathavenoimpactonamethod’s symb olic
execution summary, e.g., trivial keyword insertions [19]. Alterna-
tively, a detection of non-essential changes could help DSE ignore
certaingroups of modiﬁedmethods.
SigniﬁcanceofLow-LevelChangeTypes
Our investigation of non-essential differences is related to a previ-
ous case study by Fluri and Gall, which showed that an interpr eta-
tion of a change set’s “signiﬁcance” is tied to the particula r repre-
sentation with which its low-level deltas are represented [ 6]. Sim-
ilarly, we also measured how higher-level change represent ations
can be impacted by different low-level change characteriza tions.
In their work, Fluri and Gall speciﬁcally contrasted a purel y line-
based representation of change signiﬁcance against one bas ed on
their taxonomy of ﬁne-grained structural differences. In c ontrast,
wecompared non-essential modiﬁcationsagainstﬁne-grainedstruc-
tural differences and by evaluating impact in the more concr ete
terms of a method level representation, as opposed to a gener al
notion of signiﬁcance. Furthermore, their proposed signiﬁ cance
measure of individual change types is partly based on their l ikeli-
hood of inducing changes in other entities. In contrast, our notion
of non-essential imposes stricter conditions on individua l changes
thatarepartlybasedontypebindings andonthelikelihoodt hatthe
changeisrelevanttohigher-levelrepresentationsofsoft waredevel-
opmenteffort. Wealsoimplementedanoveldifferencingtec hnique
to detect non-essential differences, which we used to furth er char-
acterizetheirimpactinanempiricalinvestigationofalar genumber
of change sets retrievedfrom multiple open-source systems .
ClassiﬁcationsofDevelopmentActivity
Our investigation of non-essential differences is related to existing
approachescharacterizingthedevelopmentactivitybehin dchanges.
TheseincludeanapproachbyRobbesandLanzaforelicitingh igh-
erlevelpropertiesofchangesmadeduringdevelopmentsess ions[20].
As part of this approach, all development activityis direct ly moni-
tored,astrategythatcouldalsobeadaptedtoidentifynon- essentialdifferences as they happen. Other approaches include the us e of
machine learning on commit metadata (e.g., commit comments )
toclassifylargecommits intodifferent maintenance categ ories, in-
cludingcodecleanups[11]. Detectingnon-essentialchang eswithin
change sets could result in a more precise classiﬁcation of c ode
cleanups than one based on commit metadata alone.
7. SUMMARY
Numerous techniques involve mining change data captured in
software archives to assist software engineering efforts. We de-
scribed non-essential differences, or minor modiﬁcations stored in
software archives that can cause inaccuracies in high-leve l inter-
pretations of software development effort. We developed a d iffer-
encing technique that detects non-essential differences i n change
histories andused our technique toconduct anempirical inv estiga-
tionofchangedataretrievedfromsevenopen-source Javasy stems.
Our evaluation found that between 2.6%and15.5%of all method
updates consisted entirely of non-essential modiﬁcations , and that
these affected the association rules that can be mined from c hange
data. These observations should be kept inmindwhen interpr eting
insights derivedfrom change histories.
Acknowledgments
TheauthorsthankBarthélémyDagenais,TristanRatchford, andthe
anonymous reviewers for their helpful comments on earlier d rafts
of this paper. Thiswork isfunded by NSERC.
8. REFERENCES
[1] S.Bellon, R.Koschke, G. Antoniol, J.Krinke, and E.Merl o.
Comparison and evaluation of clone detection tools. IEEE
Transactions onSoftware Engineering , 33(9):577–591, 2007.
[2] B.Dagenais and L.Hendren. Enabling staticanalysis for
partial Java programs. In Proceedings of the 23rd ACM
SIGPLANConference onObject-Oriented Programming
Systems Languages andApplications , pages 313–328, 2008.
[3] B.Dagenais and M.P.Robillard. Recommending adaptive
changes forframework evolution. In Proceedings of the 30th
ACMInternational Conference onSoftware Engineering ,
pages 481–490, 2008.
[4] D.Dig, C.Comertoglu, D. Marinov, and R.Johnson.
Automated detectionof refactorings inevolvingcomponent s.
InProceedings of the 20thEuropean Conference on
Object-Oriented Programming , pages 404–428, 2006.
[5] S.G.Eick,T.L.Graves,A.F.Karr,J.S.Marron, and
A.Mockus. Does code decay? assessing the evidence from
change management data. IEEETransactions onSoftware
Engineering , 27(1):1–12, 2001.
[6] B.Fluriand H.C.Gall.Classifying change types for
qualifying change couplings. In Proceedings of the 14th
IEEEInternational Conference onProgram Comprehension ,
pages 35–45, 2006.
[7] B.Fluri,M. Wursch, M. Pinzger,and H.C.Gall.Change
distilling: Tree differencing for ﬁne-grainedsource code
change extraction. IEEETransactions onSoftware
Engineering , 33(11):725–743, 2007.
[8] H.Gall,M. Jazayeri, and J.Krajewski. CVSrelease histo ry
data for detecting logical couplings. In Proceedings of the
6thInternational Workshop on Principlesof Software
Evolution , pages 13–23, 2003.
[9] M. W.Godfreyand L.Zou. Usingoriginanalysis todetect
merging andsplittingof source code entities. IEEE
Transactions onSoftware Engineering , 31(2):166–181, 2005.[10] T.L.Graves,A.F.Karr,J.S.Marron, and H.Siy.Predict ing
fault incidence usingsoftware change history. IEEE
Transactions onSoftware Engineering , 26(7):653–661, 2000.
[11] A.Hindle, D.M. German, M. W.G,and R.C.Holt.
Automatic classiﬁcationof large changes intomaintenance
categories. In Proceedings of the 17thIEEEInternational
Conference on Program Comprehension , pages 30–39, 2009.
[12] M. Kimand D.Notkin. Program element matching for
multi-versionprogram analyses. In Proceedings of the 3rd
International Workshop onMining Software Repositories ,
pages 64–71, 2006.
[13] M. Kimand D.Notkin. Discovering andrepresenting
systematic code changes. In Proceedings ofthe 31st IEEE
International Conference on Software Engineering , pages
309–319, 2009.
[14] S.Kim,E.J.WhiteheadJr,and Y. Zhang. Classifying
software changes: Cleanor buggy? IEEETransactions on
Software Engineering , 34(2):181–196, 2008.
[15] E.Murphy-Hill, C.Parnin,and A.P.Black. Howwerefact or,
and how we know it. Proceedings of the 31st IEEE
International Conference on Software Engineering , pages
287–297, 2009.
[16] N.Nagappan and T. Ball.Use of relative code churn
measures topredict system defect density. In Proceedings of
the 27thACM International Conference onSoftware
Engineering , pages 292–301, 2005.
[17] I.Neamtiu, J.S.Foster,andM. Hicks. Understanding so urce
code evolutionusing abstract syntax treematching. ACM
SIGSOFTSoftware Engineering Notes , 30(4):5, 2005.
[18] T.T.Nguyen, H.A.Nguyen, N.H.Pham, J.Al-Kofahi, and
T.N.Nguyen. Recurringbug ﬁxesinobject-oriented
programs. In Proceedings of the 32nd ACM/IEEE
International Conference on Software Engineering , pages
315–324, 2010.
[19] S.Person, M.B.Dwyer, S.Elbaum, and C.S.P ˇasˇareanu.
Differentialsymbolic execution. In Proceedings of the 16th
ACMSIGSOFTInternational Symposium onFoundations of
Software Engineering , pages 226–237, 2008.
[20] R.Robbes and M.Lanza. Characterizing andunderstandi ng
development sessions. In Proceedings ofthe 15th IEEE
International Conference on Program Comprehension , pages
155–166, 2007.
[21] M. P.Robillardand B.Dagenais. Recommending change
clusters tosupport software investigation: anempirical s tudy.
Journal of Software Maintenance and Evolution: Research
and Practice ,22(3):143–164, 2010.
[22] Marc J. Rochkind. The source code control system. IEEE
Transactions onSoftware Engineering , SE-1(4):364–370,
1975.
[23] A.T. T.Ying, G.C.Murphy, R.Ng, and M. C.Chu-Carroll.
Predictingsource code changes byminingchange history.
IEEETransactions on Software Engineering , 30:574–586,
2004.
[24] T.Zimmermann andP.Weißgerber. Preprocessing CVSdat a
for ﬁne-grainedanalysis. In Proceedings of the 1st
International Workshop onMining Software Repositories ,
pages 2–6, 2005.
[25] T.Zimmermann, P.Weissgerber, S.Diehl,and A.Zeller.
Mining versionhistories toguide software changes. IEEE
Transactions onSoftware Engineering , 31(6):429–445, 2005.