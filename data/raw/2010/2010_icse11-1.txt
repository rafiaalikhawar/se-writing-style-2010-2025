Mining Message Sequence Graphs
Sandeep Kumar†, Siau-Cheng Khoo†, Abhik Roychoudhury†, David Lo§
†National University of Singapore§Singapore Management University
{sandeep,khoosc,abhik}@comp.nus.edu.sg davidlo@smu.e du.sg
ABSTRACT
Dynamic speciﬁcation mining involves discovering softwar e
behavior from traces for the purpose of program comprehen-
sion and bug detection. However, mining program behavior
from execution traces is diﬃcult for concurrent/distribut ed
programs. Speciﬁcally, the inherent partial order relatio n-
ships among events occurring across processes pose a big
challenge to speciﬁcation mining. In this paper, we pro-
pose a framework for mining partial orders so as to under-
stand concurrent program behavior. Our miner takes in a
set of concurrent program traces, and produces a message
sequence graph (MSG) to represent the concurrent program
behavior. An MSG represents a graph where the nodes of
the graph are partial orders, represented as Message Se-
quence Charts. Mining an MSG allows us to understand
concurrent program behaviors since the nodes of the MSG
depictimportant“phases”or“interactionsnippets”invol ving
several concurrently executing processes. To demonstrate
the power of this technique, we conducted experiments on
mining behaviors of several fairly complex distributed sys -
tems. We show that our miner can produce the correspond-
ing MSGs with both high precision and recall.
Categories andSubject Descriptors
D2.1 [Software Engineering ]: Requirements / Speciﬁca-
tions—Methodologies
General Terms
Algorithms, Design, Experimentation
Keywords
Speciﬁcation Mining, Distributed Systems
1. INTRODUCTION
Software is developed to cater to a speciﬁc set of require-
ments that are dictated by real life problems or business
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
ICSE’11, May 21–28, 2011, Waikiki, Honolulu, HI,USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.needs. However, a formal documentation of the software
speciﬁcation (the intended behaviors that the software is
supposed to capture) is often missing, even though it is es-
sential to the design, implementation and testing phases of
software development. Moreover, formal software speciﬁca -
tions are crucial for the maintenance of legacy software. As
any software project team would agree, the cost for soft-
ware maintenance is usually much higher than the initial
software development cost. The cost of maintaining soft-
ware and managing its evolution is said to account for more
than 90% of the total cost of a software project, prompting
certain authors to call it a“ legacy crisis ”[39].
The absence of any semi-formal and abstract representa-
tion in many development processes makes it diﬃcult for
users of the system to understand and appreciate its ac-
curate behavior. In addition, several systems that follow
recommended requirements gathering and design practises
during early stages deviate from their early speciﬁcations as
development and maintenance progresses. This deviation is
a result of both errors in the implementation and changes in
the requirements themselves. As a result, even if a software
speciﬁcation is available — it may not reﬂect the behaviors
of the latest version of the program.
Dynamic speciﬁcation mining [11] is a dynamic program
analysis method to automatically infer the speciﬁcation of
a program from its execution traces. The mining of various
speciﬁcation formats such as automata [11, 23, 28], and tem-
poralrules[43, 25]hasbeenstudied. Ingeneral, speciﬁcat ion
mining techniques employ data mining or machine learn-
ing techniques on execution traces to generate models that
are useful in program veriﬁcation. However, these speciﬁ-
cation mining techniques have primarily been designed with
sequential programs in mind. In order to apply such tech-
niques on distributed systems the execution of each compo-
nent has to be analyzed in isolation from rest of the system.
In reality, the components of a distributed system do not
function in isolation, but rather communicate and collabo-
rate at several points of their execution. Very often, spec-
ifying how components interact becomes a crucial part of
Input Traces
Dependency Graphs Mined Basic MSCsMSG
Identify
Basic MSCsAutomaton LearningConvert to 
Partial Order
Figure 1: Stages in the proposed mining framework.(a)Sample execution traces (inputs to our MSGMiner)
 (b)Mined MSG (output from our MSGMiner)
Figure 2: Banking System Example
the design of distributed system. In order to express such
behavior, speciﬁcation languages such as UML Sequence Di-
agrams or Message Sequence Charts (MSCs) are commonly
used (e.g., see [14] for an early work on mining Sequence Di-
agrams). However, Sequence Diagrams only represent one
scenario in the execution of a concurrent/distributed soft -
ware — it does not capture the complete speciﬁcation of the
program’s behavior. In this paper, we study this problem.
We propose MSGMiner - a framework to discover speciﬁ-
cations of distributed systems as Message Sequence Graphs
(MSGs). An MSG is a directed graph having an MSC at
each of its vertices. These MSCs (referred to as basic MSCs
) only describe an interaction snippet in the system’s exe-
cution. Figure 1 describes the transformations performed
byMSGMiner to construct an MSG. We convert each ex-
ecution trace to a partial order (or dependency graph) by
(i) considering the individual control ﬂows across diﬀeren t
processes and (ii) marking the dependencies between a send
event and its corresponding receive. We then analyze these
dependency graphs to ﬁnd largest frequently recurring por-
tions — which then appear as the basic MSCs in our mined
model. The basic MSCs constitute the nodes of our mined
MSG model. These nodes are then connected up using au-
tomata learning techniques. Our approach thus involves a
combination of automata learning and mining of partial or-
ders.
Consider a hypothetical distributed banking system in
which a user client interacts with a distant portal that in
turn relies on a database at a separate location. Figure 2(a)
shows threesampletraces collectedfrom executionsofsuch a
system. Figure 2(b) shows what an MSG mined from traces
would appear like. The mined MSG is not an exact repre-
sentation of the set of traces but instead a generalized mode l
of the system suggesting many more possible scenarios.
The main contribution of this paper is our framework
for mining inter-process or inter-component concurrent sy s-
tem speciﬁcations in the form of a Message Sequence Graph
(MSG). Conventional mining methods have focused on ei-
ther intra-process speciﬁcations (where the control ﬂow in -
side each process is mined as an automaton) or rule-based
speciﬁcations (where system behavior is summarized as tem-
poral properties either in textual form or in visual form suc h
as Live Sequence Charts). It is worthwhile to emphasize
that our focus on mining for MSGs involves a fundamen-
tal conceptual shift from mining of Live Sequence Charts
(LSCs). This is because LSCs visually describe properties
which must hold every system execution, whereas MSGs
are a complete description of the global system behavior.
Through the mined MSG model we emphasize the inter-
action snippets or commonly executed protocols across the
processes and these get captured as the nodes or the basic
MSCs in our mined MSG model. By understanding these
Figure 3: A schematic MSC and its partial order.
frequently occurring interaction snippets, a programmer c an
understandthecommon concurrentinteractions andinwhat
sequence they occur — thereby getting a clear ﬁrst-cut un-
derstanding of the behaviors of a concurrent program. We
evaluated our MSG mining framework via case studies on
real-life distributed software. It was found that the min-
ing framework discovers MSG speciﬁcations that are easy
to comprehend. Moreover, the mined MSG models com-
pare favorably (in terms of precision/recall) w.r.t. manua lly
constructed models.
2. BACKGROUND
Message SequenceCharts(MSCs), arecommendationfrom
ITU [4], have traditionally played an important role in soft -
ware developmentandbeenincorporated intomodelling lan-
guages such as ROOM [13], SDL [8] and UML [41]. The ba-
sic MSC syntax consists of a set of vertical lines-each denot -
ing a process or a system component, internal events repre-
sentingintraprocess executionandannotateduni-directi onal
arrows denoting inter processes communication. Figure 3
shows a simple MSC with two processes; m1andm2are
messages sent from ptoq.
Semantically, an MSC denotes a set of events (message
send, message receive and internal events corresponding to
computation)andprescribesapartialorderovertheseeven ts.
This partial order is the transitive closure of (a) the total
order of the events in each process1and (b) the ordering
imposed by the send-receive of each message.2. It is also
understood that arrows depicting the inter process commu-
nication is either a horizontal line or one that is slanting
downwards. The events are described using the following
notation. A send of message mfrom process pto process q
is denoted as /an}bracketle{tp!q,m/an}bracketri}ht. The receipt by process qof a message
msent by process pis denoted as /an}bracketle{tq?p,m/an}bracketri}ht.
Consider the chart in Figure 3. The total order for process
pis/an}bracketle{tp!q,m1/an}bracketri}ht ≤ /an}bracketle{tp!q,m2/an}bracketri}htwheree1≤e2denotes that event
e1“happens-before”event e2. Similarly for process qwe have
/an}bracketle{tq?p,m1/an}bracketri}ht ≤ /an}bracketle{tq?p,m2/an}bracketri}ht. For themessages we have /an}bracketle{tp!q,m1/an}bracketri}ht ≤
/an}bracketle{tq?p,m1/an}bracketri}htand/an}bracketle{tp!q,m2/an}bracketri}ht ≤ /an}bracketle{tq?p,m2/an}bracketri}ht. The transitive closure
of these four ordering relations deﬁnes the partial order of
the chart. Note that it is nota total order since from the
1Time ﬂows from top to bottom in each process.
2The send event of a message must happen before its receive
event.transitive closure we cannot infer that /an}bracketle{tp!q,m2/an}bracketri}ht ≤ /an}bracketle{tq?p,m1/an}bracketri}ht
or/an}bracketle{tq?p,m1/an}bracketri}ht ≤ /an}bracketle{tp!q,m2/an}bracketri}ht. Thus, in this example chart, the
send ofm2and the receive of m1can occur in any order.
The partial order suggested by the MSC in this example is
also shown in Figure 3.
The vertical lines representing the independent processes
or threads whose interactions we capture are also referred
to aslifelines. MSCs can be formally deﬁned as follows.
Definition 2.1 (MSC). An MSC Mcan be viewed as
a partially ordered set of events M= (L,{El}l∈L,≤,γ,Σ),
whereLis the set of lifelines in m,Elis the set of events
in which lifeline ltakes part in M.Σis the alphabet of send
and receive event labels and γ:{El}l∈L→Σis a function
assigning each send or receive event a label. ≤is the partial
order over the occurrences of events in {El}l∈Lsuch that
• ≤lis the linear ordering of events in El, which are
ordered top-down along the lifeline l,
• ≤smis an ordering on message send/receive events
in{El}l∈L. Ifγ(es) =/an}bracketle{tp!q,m/an}bracketri}htand the correspond-
ing receive event is er,withγ(er) =/an}bracketle{tq?p,m/an}bracketri}ht, we have
es≤smer.
• ≤is the transitive closure of ≤L=/uniontext
l∈L≤land≤sm,
that is,≤= (≤L/uniontext≤sm)⋆
Concatenation of MSGs can be deﬁned in two diﬀerent
manners. For a concatenation of two MSCs say M1◦M2,
all events in M1must happen before any event in M2. In
other words, it is as if the participating processes synchro -
nise or hand-shake at the end of an MSC. In MSC literature,
it is popularly known as synchronous concatenation . On the
other hand, asynchronous concatenation performs the con-
catenation at the level of lifelines (or processes). Thus, f or a
concatenation of two MSCs, say M1◦M2, any participating
process (say Interface) must ﬁnish all itsevents in M1prior
to executing any event in M2. For the rest of this paper we
remain faithful to the latter deﬁnition of concatenation.
An MSC of our deﬁnition is suited to specify a single exe-
cution scenario. A complete speciﬁcation of a system would
therefore require multiple MSCs. A large number of MSCs
will be required to describe most non-trivial systems. For
this reason, MSC standards include High Level Message Se-
quence Charts (HMSCs) that make it easy to deﬁne and
visualize large collections of MSCs. HMSCs are hierarchi-
cal graphs that have as nodes either a basic MSC or a lower
level HMSC chart. We limit our mining exercises to the sim-
pler yet semantically equivalent representation of Message
Sequence Graphs [21]. Formally an MSC-graph or MSG is
a directed graph ( V,E,V s,Vf,λ), in which Vis the set of
vertices, Ea set of edges, Vsa set of entry vertices, Vfa
set of accepting vertices and λa labelling function that as-
signs an MSC to every vertex. From any path in an MSG
of the form ( v1,v2...vn), where v1∈Vs∧vn∈Vf, we
can derive one MSC by the concatenation of basic MSCs
λ(v1)◦λ(v2)...λ(vn).
3. MININGALGORITHM
MSGMiner takes in a collection of execution traces of a
system implementation, and produces an MSG describing
the system’s behavior. The main challenge in this process
lies in the ability to discover occurrences of concurrency b e-
haviorfromtraces andspecifyingthemusingMSCs. Werep-
resent MSCs usingdatastructurescalled dependencygraphs
Figure 4: Dependency graphs for MSCs in Figure 2
thatfullycapturethepartialorderrelationshipamongeve nts
in the MSC. Furthermore, we introduce a novel idea of max-
imal connected dependency graph (MCD) for a given trace
set to capture basic MSCs that can be used as the build-
ing blocks for constructing an MSG. The entire mining pro-
cess is thus divided into three stages, which are elaborated
in the rest of the section: (1) Trace processing : Collection
of traces and the transformation of each trace into a de-
pendency graph. (2) MSC mining : Identifying basic MSCs
(in MCD representation) from the dependency graphs, and
transforming each dependency graph into a chain of MSCs.
(3)MSG construction : Merging of chains of MSCs into an
MSG.
3.1 TraceProcessingandDependencyGraphs
Traces are collected by instrumentingand executinga sys-
tem implementation with various inputs. In a distributed
system the trace points are chosen to be at program lo-
cations where processes send or receive messages. A trace
eventiseitherasendorreceivemessage oftheform /an}bracketle{tp!q,m/an}bracketri}ht
or/an}bracketle{tq?p,m/an}bracketri}htrespectively, where mis the message being ex-
changed between a sender named pand a receiver named
q. Furthermore every event must contain a time stamp to
determine the ordering of events.
For presentation clarity, we assume that traces are strings
of events, which are drawn from a trace alphabet Σ. The
collected traces record some linear temporal order in which
events occur during the execution of the system. Our ﬁrst
task is to eliminate temporal ordering of events from diﬀer-
ent lifelines, when they are not explicitly imposed through
messages. With these eliminations, we will have converted
the total ordering of events implied by the traces into a par-
tial ordering that captures concurrent behavior.
Recall from 2.1 that an MSC M= (L,{El}l∈L,≤,γ,Σ)
prescribes the partial ordering ≤among a set of events. ≤
was deﬁned to be a transitive closure of the union of an
ordering relationship between events within each lifeline (≤l)
and the ordering of send and receive events of a message
(≤sm). We observe that only the ordering imposed by ≤l
and≤smare suﬃcient to specify the inherent behavior of
the system, and deﬁne a dependency graph to capture these
behaviors. Speciﬁcally, a dependency graph is a graph data
structure g= (L,{Vl}l∈L,R,γ′,Σ) where:
•eachvi∈Vlcorresponds to an event ei∈El,
•there is a directed edge v1Rv2iﬀ for their correspond-
ing events e1ande2, (e1,e2)∈(∪l∈L≤l)∪ ≤sm
•γ′(vi) =γ(ei) for every event eiand its corresponding
vertexviin the dependency graph.We will use ( V,R,γ) as a shorter representation for depen-
dency graphs whenever the lifelines and event alphabet is
not relevant to the analysis. Note that dependency graphs
are a graphical representation equivalent to ‘traces’ in tr ace
theory [17]. Figure 4 shows the corresponding dependency
graphsg1,g2,g3andg4, for basic MSCs M1,M2,M3andM4
respectively.
Some of the properties of dependency graphs used by the
mining algorithm are as follows.
Definition 3.1 (Equivalence ≡).For dependency
graphsg1= (V1,R1,γ1)andg2= (V2,R2,γ2),g1≡g2iﬀ
there exists a bijection f:V1→V2such that,
∀v1∈V1(γ1(v1) =γ2(f(v1)))and
∀v1,v2∈V1(v1R1v2⇔f(v1)R2f(v2)).
Definition 3.2 (Concatenation ◦).For two graphs,
g1=(L1,{V1l}l∈L1,R1,γ1,Σ)andg2=(L2,{V2l}l∈L2,R2,
γ2,Σ)the concatenation g1◦g2= (L,{Vl}l∈L,R,γ,Σ)such
that
L=L1∪L2
Vl=

V1l∪V2lifl∈L1∩L2
V1lifl∈L1−L2
V2lifl∈L2−L1
γ=γ1∪γ2
R=R1∪R2∪RL∪Rsr
The concatenated graph contains the following new sets of
edges:
1.RL: This enforces the ordering that for a lifeline l,
the events in V1loccur before those in V2l. Let func-
tion first(Vil)return vertex v∈Vilsuch that ∀v′∈
Vil,vRiv′. Similarly let l ast(Vil)return the last event
in lifeline l.
RL={(last(V1l),ﬁrst(V2l))|∀l∈L1∩L2}
2.Rsr: This pairs an unmatched send event in g1with an
unmatched receive event in g2. Since a graph may con-
tain repetitions of the same send/receive event, we re-
solve ambiguity by deﬁning a function ϕl:Vl→N0to
diﬀerentiate between identical events within the same
lifeline. For a vertex v∈Vl,
ϕl(v)=|{v′|v′∈Vl∧(v′,v)∈(RL∪R1∪R2)+∧
γ(v′) =γ(v)}|.
Rsr={(vp,vq)|vp∈V1p∧vq∈V2q∧ ∃ /an}bracketle{tp!q,m/an}bracketri}ht,
/an}bracketle{tq?p,m/an}bracketri}ht ∈Σ :γ(vp) =/an}bracketle{tp!q,m/an}bracketri}ht ∧γ(vq) =/an}bracketle{tq?p,m/an}bracketri}ht ∧
ϕp(vp) =ϕq(vq)}
Figure 5 shows the result of concatenation of dependency
graphsg1,g3andg2of Figure 4. The dotted lines show
newly added edges.
Definition 3.3 (Sub-Graph). A sub-graph relation-
ship among dependency graphs is as follows: g′⊆gif and
only if there exist graphs xandysuch that g≡(x◦g′)◦y.
Definition 3.4 (Prefix and Suffix). A sub-graph
g′⊆gis a preﬁx of giﬀ for some graph y,g≡g′◦y.
Similarly g′is a suﬃx iﬀ for some graph x,g≡x◦g′.
Ourdeﬁnitionofsub-graphfordependencygraphsisstrict-
er thanand not tobe confused with thedeﬁnition commonlyused in graph theory. In Figure 5, gx,gyandgzare sub-
graphs of the concatenated dependency graph. The sub-
graphgxis a preﬁx and gza suﬃx.
Definition 3.5 (Frequency). The frequency of sub-
graphg′in dependency graph gisn, if there exist dependency
graphsg0,g1,...gnsuch that g≡((((g0◦g′)◦g1)◦g′)...)◦gn
andg′/notsubseteqlg0,g1...gn. Note that g0,g1...gnmay be empty.
Informally, the frequency of a sub-graph g′ingis the
number of distinct occurrences of the g′ing. Figure 5 also
shows the frequency of gx,gyandgzin (g1◦g3)◦g2.
Figure 5: Concatenated graph (g1◦g3)◦g2, and some
of its sub-graphs
We deﬁne a function dgraph(t) that accepts a trace tas
parameter and constructs a dependency graph. The depen-
dency graph is constructed by ﬁrst creating a unique vertex
for each occurrence of an event. After this, edges are added
to link up events within a lifeline intoa chain. Subsequentl y,
the send andreceive eventsare linked upin a backwardfash-
ion starting from the bottom of the trace. For example the
last occurrence of event /an}bracketle{tq?p,m/an}bracketri}htis linked to the last occur-
rence of event /an}bracketle{tp!q,m/an}bracketri}htand so on. This manner of construct-
ing a dependency graph gives function dgraphthe property
that given a trace t, for any of its suﬃxes ts,dgraph(ts) is a
suﬃx of dgraph(t). We have made two assumptions about
the system during the construction:
1. No messages are lost in the message channels.
2. The message are sent over FIFO channels.
TheconcatenatedgraphinFigure5isequivalentto dgraph
(t1) constructed from trace t1in Figure 2(a). The algorithm
for function dgraphis detailed in a technical report [22].
3.2 MSC Mining
Using the function dgraph, we convert the available trace
setT={t1,t2,...tn}to a set of dependency graphs G=
{g1,g2,...gn}, where each dependency graph gi∈Gcorre-
sponds to a scenario of system execution. Our next step is
to identify basic sections within these graphs, that recur a t
several places within the same graph or across the graphs
inG. These fundamental blocks are likely to capture the
basic MSCs in an MSG describing the system. There are
many possible ways to break down a graph into fundamen-
tal blocks. Our method aims to discover MSCs which are as
big as possible and yet recurring frequently enough in theinput execution traces (or their corresponding dependency
graphs). Therefore, we introduce the notion of Maximal
Connected Dependency Graphs (MCDs) to signify MSCs.
Formally,
Definition 3.6 (MCD). For a given trace set T={t1,
t2,...tn},gmcd= (V,R,γ)is an MCD iﬀ
1. There is a trace t∈Tsuch that gmcd⊆dgraph(t) .
2.∀g⊂gmcd:freq(gmcd) =freq(g)3
3. For every distinct v1,v2∈V,(v1,v2)∈(R∪R−1)∗.
4. There is no graph g′that satisﬁes conditions 1-3 such
thatgmcd⊂g′.
Criterion 2 guarantees that no part of an MCD (and thus
its corresponding MSC) appears in some context in which
the rest of the MCD does not also appear. Criterion 4 en-
forces the maximality of MSCs. Criterion 3 requires that
events in MCDs be connected with each other. This addi-
tional constraint is introduced to simplify the mining task .
An exhaustive search for graph structures that meet the
conditions speciﬁed above could turn out to be expensive.
Instead, we identify a graph structure termed event tail for
each event, and then successively merge them to arrive at
dependency graphs that will satisfy the frequency, connect -
edness and maximality criteria of MCDs. We describe event
tails and the method of merging graphs in the following sub-
sections.
3.2.1 EventTail
For an event e∈Σ, when given a trace set T⊆Σ∗, its
tail,tail[e], is the largest dependency graph that contains a
single minimal vertex (which is a vertex in the graph with-
out any associated incident edges) labelled eand satisﬁes
conditions 1-3 of deﬁnition 3.6. Apart from the minimal
vertex, it also contains all events that immediately follow s
every occurrence of ein a consistent partial order.
Algorithm 1 outputs an associative array - tail, that maps
every event in Σ to its tail. For an event eand trace set
T,Teis the set of trace suﬃxes that start with e.Tecan
be easily derived from a suﬃx tree[40] constructed from the
trace set. From Tewe obtain a collection of suﬃx graphs, by
identifying dgraph(ts) for every ts∈Te. In such a graph,
letvebe the vertex corresponding to the ﬁrst occurrence of
evente. All vertices vin the graph for which ( ve,v)/ne}ationslash∈R∗
are removed as they do not belong to the tail. After this, the
function getCommonPreﬁx is invoked to identify the largest
preﬁx common to all suﬃx graphs in the collection for event
e. This common preﬁx is the desired event tail tail[e].
Operationally, function getCommonPreﬁx identiﬁes the
largest common preﬁx in a pair of dependency graphs g1
andg2through a simultaneous breadth-ﬁrst traversal over
these two graphs. During the traversal, vertices and edges
are gradually added to the largest common preﬁx g. A ver-
texvwith label eis added to gif and only if 1) there are
verticesv1ing1andv2ing2havingacommonlabel e, and2)
v1andv2have identical incident edges and all vertices from
which there are edges incident to v1,v2have already been
added to g. In addition, getCommonPreﬁx ensures that all
events added to the common graph have identical frequen-
cies. All these operations ensure that conditions 1,2 and 3 o f
3Given a trace set T={t1, t2,...tn},freq(g) is the sum of
the frequency of gin dgraph( t1), dgraph( t2), .. dgraph( tn).Algorithm 1 Find Event Tails
Input: T- The trace set, Σ - set of events appearing in T.
Output: tail[e] that maps every event e∈Σ to its tail.
1:for all e∈Σdo
2:FindTe: the set of all suﬃxes(of traces in T) starting with e
3:letTe={ts1,ts2,...tsne}
4:tail[e]←∅
5:fori= 1...nedo
6: (V,R,γ)←dgraph(tsi)
7: letvebe the vertex corresponding to the ﬁrst event e
8: for all v∈Vs.t. (ve,v)/∈R∗do
9: V←V−{v}
10: end for
11: iftail[e] =∅then
12: tail[e]←(V,R,γ)
13: else
14: tail[e]←getCommonPreﬁx (tail[e] , (V,R,γ))
15: end if
16:end for
17:end for
deﬁnition 3.6 are satisﬁed. Moreover, since the event tail i s
the maximal graph common to all suﬃxes with veas its min-
imal vertex, we have ensured that 1) tail[e] contains atleast
one vertex ve, and 2) tail[e] cannot be extended without vi-
olating conditions 1,2 or 3. Details of getCommonPreﬁx is
presented in [22]. Figure 6(a) shows some of the event tails
derived from traces of the banking system in Figure 2.
3.2.2 CombiningEventTails
Algorithm 2uses themappingfrom eventstotails ( tail[e])
to derive a mapping from events to MCDs - MCD[e]. The
algorithm starts with g1=tail[e]. We know that tail ecan-
not be extended at the end as it is already maximal. Hence
we attempt to grow g1by preﬁxingit with other graphs. For
every event e′we verify if tail[e′] can be merged into g1. Let
tail[e′] be the graph g2. Without loss of generality we can
express the two tails as,
g1≡gpref
1◦gcommand
g2≡(gpref
2◦gcomm)◦gsuﬀ
2
wheregcommis the largest possible such graph. If gcomm
is empty, we do not perform any merging. If gcommis not
empty, we obtain gpref
2◦g1as the merged graph. To sat-
isfy the frequency criterion, we chose to accept the merged
graph only when freq( gpref
2◦g1) = freq( g1). When more than
one preﬁx of g2satisfy the conditions on gpref
2, we select the
largest one. The dependency graph g1is an MCD if no more
event tails can be merged into it. [22] provides a proof for
the claim that for each event e1,MCD[e1] determined by
Algorithm 2 is an MCD.
Figure 6(b) shows the set of MCDs that are obtained by
merging event tails obtained from traces in Figure 6(a).
3.2.3 ConvertingTracetoSequenceofMSCs
Algorithm 2 associates each event with an MCD. Utilizing
this association, we transform every trace from the given
trace set into a sequence of dependency graphs. To achieve
this, we group events in a trace based on their associated
MCDs. For a trace t, we represent each group of events by
a dependency graph giand derive a sequence of the form
(g1,g2,...gi...gm) such that dgraph(t)≡((g1◦g2)...)◦
gm. The order of dependency graphs in the sequence is
constrained by the dependency relationship between events
indgraph(t).
In most cases, we can expect gito be one of the MCDs we
identiﬁed. Certain cases warrant special handling. Firstl y,(a)
 (b)
Figure 6: (a)Event tails and (b)MCDs for events in the traces of the banking system
Algorithm 2 Combine Event Tails
Input: tail[e] for all events e∈Σ
Output: MCD[e] for all events e∈Σ
1:for all e1∈Σdo
2:W←Σ−{e1}
3:g1←tail[e1]
4:while∃e2∈Ws.t. merge( g1,tail[e2])/ne}ationslash=ǫdo
5: g1←merge(g1,tail[e2])
6: W←W−{e2}
7:end while
8:MCD[e1]←g19:end for
merge(g1,g2)
Input: g1,g2- The candidates for merging
Output: The merged graph. ( ǫif merge is not possible).
1:Letgcommbe the largest suﬃx of g1that is a sub-graph of g2.
2:if(gcommis empty) then
3:return ǫ
4:else
5:Find largest gpref
2that satisﬁes:
g2≡(gpref
2◦gcomm)◦gsuff
2∧freq(gpref
2◦g1) = freq( g1)
6:ifno such gpref
2is found then
7: return ǫ
8:else
9: return gpref
2◦g110:end if
11:end if
we may have derived two MCDs that share a common sub
graph. For example, we may have MCD[e1]≡gx◦gand
MCD[e2]≡g◦gy. Since MCDs are maximal, we know that
the merged graph ( gx◦g)◦gymust have a lower frequency
that its sub graphs. In such scenarios, we will drop the
common sub graph gfrom one of the MCDs. Secondly,
two MCDs may not co-exist as they constrain each other
in certain traces. To resolve such cases, we automatically
split one ofthe MCDs intosmaller partswhenever necessary.
This scenario is explained with an example in [22].
While we have deﬁned MCDs as dependency graphs, we
do not require them to correspond to ‘complete MSCs’; ie.,
there may exist a send event in an MCD which does not
contain the matching receive event and vice versa. In order
to guarantee that all vertices of an MSG denote complete
MSCs, we concatenate successive partial graphs in a post-
processing step to ensure that each dependency graph in the
ﬁnal sequence of MSCs will represent a complete MSC. Al-
gorithm 3 performs this transformation. It takes a sequence
of dependency graph gListand creates outputList - a list of
dependency graphs without any unmatched send or receive
events.
At the end of this stage we have deﬁned an alphabet of
basic MSCs and produced strings from this alphabet for the
construction of MSGs.Algorithm 3 Convert to full MSCs
Input: gList- A sequence of dependency graphs
Output: outputList - Sequence of dependency graphs, each repre-
senting a valid MSC
1:outputList←[ ]
2:temp←gList[0]
3:fori←1...gList.size ()do
4:iftemp has an unmatched send event then
5: temp←temp◦gList[i]
6:else
7: outputList.add(temp)
8: temp←gList[i]
9:end if
10:end for
11:return outputList
3.3 Constructing MessageSequence Graphs
There exists a choice of algorithms to learn a ﬁnite state
machine (FSM) from a training set of strings [12, 15]. For
our experiments we implement a variant of the sk-strings al-
gorithm as described in [35]. A shared preﬁx tree is initially
constructedfromthesetofMSCstrings. Thealgorithmthen
identiﬁes a set of nodes that are equivalent. Two nodes are
considered equivalent if their k-futures match. The k-future
of a node is simply the set of all valid paths of length k
or less (if the end node is reached) starting from that node.
Several possible heuristics havebeen suggested tomatch tw o
sets of k-futures. For better precision one could insist on t he
match being exact. Other methods involve matching two
sets of strings if they meet a certain probabilistic thresh-
old. Equivalent nodes are merged to get a more general and
compact model. During the merging process loops are in-
troduced to the model. For a preﬁx tree with nnodes, since
every pair of nodes are compared, the algorithm has a worse
case execution time of O(n2mk), where mis the size of the
trace alphabet. For an operation comparing the k-futures of
any two nodes, the maximum number of nodes to be com-
pared is never greater than the total number of nodes in the
tree. As a result, the algorithm has an execution time not
worse than O(n3) for any value k. Note that nis shorter
than the number of events in the initial traces as we have
transformed them to MSC strings.
Once an MSG has been mined from traces using the FSM
learner, it is reﬁned through a series of state reduction ste ps.
An FSM learner usually produces a Mealy model state ma-
chine which in our setting has to be transformed into a min-
imal Moore model. In the latter state machine each state
corresponds to a basic MSC. The ﬁnal MSG is a structure-
preserving homeomorphic embedding of the Moore model
state machine. The general rule for reduction is that if anystate s is reachable from one and only one state s’ and s is
the only state reachable from state s’, then the MSC in state
s can be concatenated to the MSC in state s’. This concate-
nation yields new basic MSCs. The reduced directed graph
of basic MSCs is our ﬁnaloutput. The MSG canbe exported
as image ﬁles for visualization.
3.4 Extensions
Our work on MSG Mining has relied on a simple def-
inition of MSCs which was suﬃcient to represent partial
order arising from asynchronous message exchanges. This
constraints us from representing more complicated behav-
ior within MSCs. For example, in some systems, a process
may broadcast messages to multiple processes and await re-
sponses from its audience. We refer to such instances as
“message broadcasts”. In such scenarios, the order in which
the messages are sent or the responses received is usually in -
consequential. Furthermore, the actual order of events see n
in traces may be diﬀerent for each realization of such broad-
casts. Without knowledge of“message broadcasts”, the min-
ing process presented thus far may fail to produce a succinct
and comprehensible MSG.
MSG semantics [4] provide features such as coregions or
parinline expressions to capture situations where there may
be no speciﬁc logical ordering between some events within a
lifeline. The parexpression allow us to list a group of MSCs
and imply that they are to be executed in parallel.
To handle such scenarios using these features, we extend
the existing framework to accept additional input that de-
clares speciﬁc behaviour, such as the presence of broadcast
messages. We term this additional input an oracle. Our ex-
tended system when informed by the oracle, will construct
customized dependencygraphs and identify MCDs thatcap-
ture such scenarios; the MSGs produced by the extended
system become less cluttered and much more comprehensi-
ble. The technical report [22] details the use of such oracle s
to extend the system.
4. CASESTUDIES
Through case studies, we attempt to evaluate the practi-
cality of employing MSGMiner on real distributed systems.
In each case, we have also scored the accuracy of mining
by comparing the MSGs mined from traces to hand derived
speciﬁcations. We consider the following distributed sys-
tems: (a) “Center TRACON Automation System” [31] an
air traﬃc control system from NASA, (b) a system of server
and VOiP clients communicating based on the Session Initi-
ation Protocol (SIP) and (c) a system of Server and Clients
that follow the XMPP Instant messaging and Chat proto-
col. In each of these systems, multiple processes perform
asynchronous communication over TCP socket connections.
Timestamped traces were collected by inserting instrumen-
tation code at points were messages are written to or read
from a socket. The traces were ﬁltered and the message
names abstracted with the help of text processing scripts.
4.1 Evaluation
We propose an evaluation technique to validate the mined
model against a known correct model. The correct model is
used only for evaluation and never part of the mining pro-
cess. Given correct and mined models, we derive a precision
and recall score by performing language comparison. Preci-
sion and recall are popular metrics in Information Retrieva land have also been used to quantify the accuracy of mined
state based models [23, 29]. Recall that concatenating basi c
MSCs along any path from a starting vertex to an accept-
ing vertex in the MSG produces an MSC that represents
a valid execution scenario. We say that such an MSC is
‘generated’ by the MSG. Precision is deﬁned as the number
of MSCs generated by the mined model that are accepted
by the correct model divided by the total number of MSCs
generated by the mined model. Similarly recallis the ratio
of the number of MSCs from the correct model that are ac-
cepted by the mined model to the total number of MSCs
generated by the correct model. All possible MSGs can not
be enumerated as inﬁnitely many MSCs can be generated
from an MSG. Instead we use only a ﬁnite sample from the
MSG’s language for evaluation. Our sample consists of all
accepting paths in the MSG with a ﬁnite bound on loops.
This bound is enforced my limiting the number of times any
vertex is revisited in a path. For the dependency graph g
corresponding to each MSC from the generating MSG, we
verify if there is a path in the accepting MSG that forms a
dependency graph identical to g. This is done by an eﬃcient
depth ﬁrst search in the accepting graph.
As our case studies consider reactive systems that con-
tain concurrently executing processes, existing automato n
learning methods can not be applied to their traces. Such
methodscaninsteadbeusedtoinferastatemachinefor each
process iftheoriginal traces areseparatedintotracesloc al to
each of the constituent processes. We compare the accuracy
of our proposed approach with the accuracy of mining this
alternative model of local automata from the same collec-
tion of traces. To do this, we derive a similar precision and
recall score of the learnt automata with respect to the same
correct MSG speciﬁcation that was used to score the mined
MSG. The algorithm used to learn automata is identical to
the method used in the automaton learning phase of MSG
mining (Section 3.3). Precision and recall for automata is
measured as the ratio of the number of traces(rather than
MSCs) generated from one model that is accepted by the
other model to the total number of traces generated. We
generate random sample of traces from the collection of au-
tomata. The parallel composition of the automata may con-
tain accepting paths that create invalid traces(eg: Receiv e
event may appear before the message is sent). To generate
only ‘correct’ traces we simulate the FIFO message channels
between processes. While exploring a path in the composed
automaton, if an edge outputting a send event /an}bracketle{tp!q,m/an}bracketri}htis
chosen, the message mplaced in the buﬀer corresponding
to the channel [ p→q]. An edge outputting a receive event
/an}bracketle{tq?p,m/an}bracketri}htcan be explored only if message mcan be removed
from the front of buﬀer [ p→q]. A path explored in the
composed automaton signiﬁes a valid trace only when an
accepting state is reached and all the message buﬀers are
empty. We impose a bound on the number of loops as be-
fore.
Table 1 tabulates the results from the case studies. It
shows the precision, recall and F 1measure(harmonic mean
of precision and recall) of the mined models obtained from
the two alternatives (automaton learning and MSG Mining)
for each case study. The mining was performed on a JVM
running on an Intel duo core CPU with 1GB of available
memory. The results from the systems considered for case
study suggest that the proposed MSG mining method pro-
vides better mining accuracy.SystemNo of
eventsMined Automata Mined MSG
Prec Rec F1Score Time(s) Prec Rec F1Score Time(s)
SIP 1870 0.50 1 0.67 1.0 0.78 0.87 0.82 3.14
XMPP-Core 3212 0.72 0.44 0.55 8.3 1 0.71 0.83 10.2
XMPP-MUC 5736 1 1 1 22.0 1 1 1 28.7
CTAS 6418 0.95 1 0.97 48.1 1 1 1 45.8
Table 1: Table comparing accuracy of mining for MSG and Autom ata speciﬁcations
4.2 CTAS
CTAS is an Air Traﬃc Control system from NASA. The
CTAS weather control logic speciﬁcation [32] was one of the
case studies recommended by the 3rd International Work-
shop on Scenarios and State Machines (SCESM04). CTAS
is a distributed system having a central Communications
Manager (CM) process to which clientprocesses connect.
The weather control speciﬁcation details how clients shoul d
connect toCM and howagraphical user interface referred to
as the weather control panel (WCP) ought to communicate
with CM to update weather status. As access to the CTAS
systemislimited, weprocureexecutiontracesbyimplement -
ing and executing a simulation of this system in Java. Our
implementation is based on a formal speciﬁcation of the sys-
tem in Promela and high level HMSC that was developed
by a fellow researcher. The MSG mined from the collected
traces is shown in Figure 7.
Our mining on the CTAS system succeeds in identifying
the states of the system that are mentioned in the informal
requirements documents. The narrative in sub-sections of
the document matches neatly with the visual representation
provided by the basic MSCs.
4.3 SessionInitiationProtocol
SIP is a signalling protocol used to establish, manage and
terminate VoIP calls and multimedia sessions in general [7] .
SIP clients interact with servers that perform the neces-
sary call routing and function as gateways to the Public
Switched Telephone Network(PSTN). We attempt to spec-
ify how clients should interact with their proxy server to
achieve some of the basic call features. For this, we set up a
system having three SIP clients connected to a single server .
We use instrumented versions of KPhone [3] - a SIP client
implementation and the Opensips server [5] both of which
are available with source code under a GPL license. We ex-
ecute a set of test cases involving features such as basic cal l
setup, call screening and call forwarding. A set of test case s
for each feature are identiﬁed and a trace set is prepared
by executing them on the system. The test cases involve
three clients or SIP user agents labelled as Alice, Bob and
Carol whose roles were restricted in the following way. In
all test cases, Alice initiates calls and Bob is the intended
recipient. Features such as call screening or forwarding ar e
enabled at the client Bob. Carol is the recipient of diverted
calls. Speciﬁcation mining was performed from the trace
set. A speciﬁcation(that reﬂects allotted client names and
roles) was manually derived by the authors for quantitative
analysis and comparison.
4.4 XMPP
Extensible Message and Presence Protocol is an open In-
stantMessaging standardoriginally developedbytheJabbe r
open source community. The core functionality of the proto-
col is speciﬁed in rfcs 3920 and 3921. XMPP is the protocol
for exchange of instant chat messages and presence informa-
tion between various entities in a network that are addresse dby unique jabber ID. The clients communicate to the server
through structured XML messages. The protocol deﬁnes
how XML nodes known as stanzas are to be exchanged be-
tween various entities. A client connecting to a server is
authenticated through TLS or SASL through special XML
stanzas. We attempt to discover the client server interacti on
protocol from a system having two jabber clients that are
brokered by a single server. In the speciﬁcation, the server
and client processes are the lifelines and the message arrow s
represent the XML stanzas. The Openﬁre XMPP server [2]
and Jeti [1]/Pidgin [6] client implementations were instru -
mented and executed for trace collection. For discovering
the core speciﬁcation as an MSG, we only record stanzas
used for authentication or those having a message orpres-
encetag and ignore rest of the message exchanges.
In addition to the core speciﬁcation, XMPP Standards
Foundation (XSF) has standardised several additional chat
features. We attempt to mine behavioral speciﬁcation for
the Multi User Chat(MUC) functionality[9]. For this we use
a separate set of test cases involving features such as servi ce
discovery, multi-party chat and creation and administrati on
chat rooms. In all test cases user1creates the chat room
therebyacquiringtherole oftheroom owner. Onlymessages
sent from or addressed to the MUC conference service are
recorded.
5. RELATED WORK
Research in speciﬁcation mining has attempted to dis-
cover common speciﬁcation formats like frequent patterns
& rules [24, 38, 10, 43, 25], ﬁnite state machines [11, 23, 28,
30, 16, 42, 34, 20, 10] and Boolean expressions [19].
Approaches that mine frequent patterns highlight statis-
tically signiﬁcant patterns in the execution of the system
whichcanbe interpretedas temporal rules. Whilethemined
set of rules and properties are valuable to processes like
model checking, they provide a limited understanding of the
system as a whole. We mine for MCDs based on a frequency
criterion and use them along with automaton learning meth-
ods to provide a complete sepciﬁcation of the system.
Most methods that mine ﬁnite state machines are built
upon the k-tails learner [12]. In mined state machines, the
transition edges between program states are usually labell ed
with method calls. Ammons et al.propose the use of
automaton mining on execution traces to infer state ma-
chine speciﬁcations for Application Programming Interfac es
(API) [11]. The precision and recall of automaton min-
ing is improved by a trace ﬁltering and clustering method
proposed by Lo and Khoo [23]. Lorenzoli et al.further
combines the work of Daikon[19] with mining ﬁnite state
models [28]. Boolean invariants are attached to transition s
among the nodes in the ﬁnite state machines to express
guards. Ourapproachusesasimilar automatonminingalgo-
rithm, but performs additional steps so as to mine state ma-
chines having MSCs at each node. It is possible to apply the
techniques proposed in the past work on top of our method
to improve the mining accuracy (e.g., by performing traceFigure 7: The Mined MSG for CTAS (left) and the learnt automat a for individual processes
ﬁltering and clustering) and enhance the expressiveness of
the mined model (e.g., by the addition of guards).
In [10], Archaya et al. extract relevent API interaction
scenarios out of static traces generated from program code.
The scenarios are then summarized as compacted partial or-
ders. A collection of work that attempts to infer frequent
partial order from string databases is discussed in [18]. Th e
generic partial order representation that is identiﬁed can be
used to explain multiple sequences occuring in the database .
Louet al.in [29] construct workﬂow models from traces of
concurrent systems by identifying dependency relationshi ps
between pairs of events in interleaved traces. Diﬀerent fro m
the above studies, we express partial orders in the seman-
tics of Message Sequence Charts (MSCs). MSC is a popular
speciﬁcation language and formally speciﬁes the partial or -
der constraints among messages sent between lifelines. Als o,
we compose many partial orders into a message sequence
graph (MSG).
The work of [27, 26] mine Live Sequence Charts (LSC)
that represent rules of the format“If the execution describ ed
by the pre-chart occurs, the execution prescribed by the
main chart must eventually follow”. We emphasize that
our focus on mining for MSGs (a global system model) in-
volves a fundamental conceptual shift from mining of LSCs
(a collection of temporal properties). This is because LSCs
are simply a visual description of temporal properties whic h
must hold in every system execution. In contrast, MSGs
are a complete description of the global system behavior.
Through the mined MSG model we highlight the interac-
tion snippets or commonly executed protocols across the
processes and these get captured as the nodes or the ba-
sic MSCs in our mined MSG model.
Eﬀorts have been made in program visualization by con-
structing UML sequence diagrams from dynamic executions
[14, 33]. Such work constructs a sequence diagram from
dynamic traces traces but does not produce graph-based
models like MSG that include loops and branches. Rountev
et. al. [36], perform a static inter-procedural analysis to
reverse engineer UML Sequence Diagrams from programs.
Such an analysis requires the program source code, whereas
our analysis, being dynamic, only needs execution traces.
We also present a framework that supports mining with syn-
chronous/asynchronous message passing(within MSCs) andsynchronous/asynchronous concatenation(across MSCs) —
making it a fully general framework for mining MSC-based
system models.
6. CONCLUSION ANDFUTURE WORK
In this paper, we have presented a dynamic speciﬁcation
mining framework to mine Message Sequence Graphs from
execution traces of concurrent/distributed programs. Our
focus on Message Sequence Graphs is driven by the view
that the mined speciﬁcation will be used for program com-
prehension. Thus, our mining framework exploits the ease-
of-use of MSCs/MSGs for understanding interactions in a
concurrent/distributed software. As demonstrated by our
experiments, an MSG being a global graph of interaction
snippets — provides a higher-level view of the system be-
havior (and its interactions), as compared to mining the be-
havior of individual processes of a concurrent program as
state machines.
In future, we plan to pursue several avenues to extend
the work. One particular issue relates to the succinctness
of mined MSGs. We observe that many large scale con-
current/distributed programs are essentially parameterized
systemscontaining several processes which are behaviorally
“similar”. For instance, multiple clients in the chat sys-
tem perform many similar actions such as loginandsign
out. This can result in several redundant basic MSCs in
the MSG, that try to explain the same behavior. One way
to manage such complexity would be to automatically iden-
tify such similar basic MSCs during the mining process, and
group them together. This requires us to develop a formal
notion of“roles”and attach distinctroles to the participat-
ing processes in an MSC ( e.g.see [37] for ideas along these
lines). Mining MSC-based system models for large-scale pa-
rameterized distributed software in such a fashion remains
an important direction of our future research. In a broader
perspective, our work can be seen as a precursor of a multi-
view mining framework, in which multiple views of a system
model are mined from the execution traces. In particular,
we envision a mining framework which mines state-based
intra-process style speciﬁcations as well as MSC-based int er-
process style speciﬁcations from the traces of a concurrent
/ distributed system.7. ACKNOWLEDGEMENT
This work was partially supportedbyNUSresearch grants
R-252-000-385-112 and R-252-000-403-112.
8. REFERENCES
[1] Jeti. Version 0.7.6 (Oct. 2006). //jeti.sourceforge.n et/.
[2] Jive software.
//www.igniterealtime.org/projects/openﬁre/.
[3] KPhone. //sourceforge.net/projects/kphone.
[4] Message sequence charts. ITU-TS Recommendation
Z.120, 1996.
[5] Opensips. //www.opensips.org/.
[6] Pidgin. //www.pidgin.im/.
[7] RFC 3261 - Session Inititation Protocol.
//www.ietf.org/rfc/rfc3261.txt/.
[8] Speciﬁcation and description language. ITU-T
Recommendation Z.100.
[9] XEP-0045:Multi-User Chat.
http://xmpp.org/extensions/xep-0045.html.
[10] M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API
patterns as partial orders from source code: from
usage scenarios to speciﬁcations. In ESEC/SIGSOFT
FSE, 2007.
[11] G. Ammons, R. Bodik, and J. R. Larus. Mining
Speciﬁcation. In POPL, 2002.
[12] A. Biermann and J. Feldman. On the synthesis of
ﬁnite-state machines from samples of their behaviour.
IEEE TOC , 21:591–597, 1972.
[13] G. G. Bran Selic and P. T. Ward. Real-Time
Object-Oriented Modeling . John Wiley & Sons, Inc.,
1994.
[14] L. C. Briand, Y. Labiche, and J. Leduc. Toward the
Reverse Engineering of UML Sequence Diagrams for
Distributed Java Software. IEEE TSE , 32(9):642–663,
2006.
[15] J. E. Cook and A. L. Wolf. Discovering models of
software processes from event-based data. TOSEM,
7(3), 1998.
[16] V. Dallmeier, C. Lindig, A. Wasylkowski, and
A. Zeller. Mining Object Behavior with ADABU. In
WODA, 2006.
[17] V. Diekert. The Book of Traces . World Scientiﬁc
Publishing Co., Inc., River Edge, NJ, USA, 1995.
[18] G. Dong and J. Pei. Mining partial orders from
sequences. In Sequence Data Mining , volume 33 of
Advances in Database Systems , pages 89–112. Springer
US, 2007.
[19] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin.
Dynamically Discovering Likely Program Invariants to
Support Program Evolution. IEEE TSE , 27(2):99–123,
2001.
[20] M. Gabel and Z. Su. Online inference and enforcement
of temporal properties. In ICSE, pages 15–24, 2010.
[21] J. G. Henriksen, M. Mukund, K. N. Kumar, and P. S.
Thiagarajan. On message sequence graphs and ﬁnitely
generated regular msc languages. ICALP ’00.
[22] S. Kumar, A. Roychoudhury, S.-C. Khoo, and D. Lo.
Mining message sequence graphs (technical report).
www.comp.nus.edu.sg/ ∼sandeep/msgmining TR.pdf,
2010.[23] D. Lo and S.-C. Khoo. SMArTIC: Towards building
an accurate, robust and scalable speciﬁcation miner.
InSIGSOFT FSE , 2006.
[24] D. Lo, S.-C. Khoo, and C. Liu. Eﬃcient mining of
iterative patterns for software speciﬁcation discovery.
KDD, 2007.
[25] D. Lo, S.-C. Khoo, and C. Liu. Mining temporal rules
for software maintenance. JSME, 20(4):227–247, 2008.
[26] D. Lo and S. Maoz. Mining Scenario Based Triggers
and Eﬀects. In ASE, 2008.
[27] D. Lo, S. Maoz, and S.-C. Khoo. Mining Modal
Scenario-Based Speciﬁcations from Execution Traces
of Reactive Systems. In ASE, 2007.
[28] D. Lorenzoli, L. Mariani, and M. Pezz` e. Automatic
Generation of Software Behavioral Models. In ICSE,
2008.
[29] J.-G. Lou, Q. Fu, S. Yang, J. Li, and B. Wu. Mining
program workﬂow from interleaved traces. In KDD,
2010.
[30] L. Mariani and M. Pezz` e. Behavior capture and test:
Automated analysis for component integration. In
ICECCS , 2005.
[31] NASA. Center TRACON Automation System
(CTAS). //www.aviationsystemsdivision.arc.nasa.gov/
research/foundations/sw overview.shtml.
[32] NASA. CTAS Weather Control Requirements.
//scesm04.upb.de/case-study-2/requirements.pdf.
[33] R. Oechsle and T. Schmitt. Javavis: Automatic
program visualization with object and sequence
diagrams using the java debug interface (jdi). In
Revised Lectures on Software Visualization,
International Seminar , pages 176–190, 2002.
[34] M. Pradel and T. R. Gross. Automatic generation of
object usage speciﬁcations from large method traces.
InASE, 2009.
[35] A. V. Raman and J. D. Patrick. The sk-strings
method for inferring PFSA. In Proc. of the workshop
on automata induction, grammatical inference and
language acquisition , 1997.
[36] A. Rountev and B. Connell. Object naming analysis
for reverse-engineered sequence diagrams. In ICSE,
2005.
[37] A. Roychoudhury, A. Goel, and B. Sengupta. Symbolic
message sequence charts. In ESEC-FSE , 2007.
[38] H. Safyallah and K. Sartipi. Dynamic Analysis of
Software Systems using Execution Pattern Mining. In
ICPC, 2006.
[39] R. Seacord, D. Plakosh, and G. Lewis. Modernizing
Legacy Systems: Software Technologies, Engineering
Processes, and Business Practices . Addison-Wesley,
2003.
[40] E. Ukkonen. On-line construction of suﬃx-trees.
Algorithmica 14 , pages 249–260, 1995.
[41] UML. The Uniﬁed Modeling Language. Available from
//www.omg.org.
[42] N. Walkinshaw, K. Bogdanov, M. Holcombe, and
S. Salahuddin. Reverse engineering state machines by
interactive grammar inference. In WCRE, 2007.
[43] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M.Das.
Perracotta: Mining temporal API rules from imperfect
traces. In ICSE, 2006.