Search-Carrying Code
Ali Taleghani
David R. Cheriton School of Computer Science
University of Waterloo
Ontario, Canada
ataleghani@uwaterloo.caJoanne M. Atlee
David R. Cheriton School of Computer Science
University of Waterloo
Ontario, Canada
jmatlee@uwaterloo.ca
ABSTRACT
In this paper, we introduce a model-checking-based certiÔ¨Åcation
technique called search-carrying code (SCC). SCC is an adaptation
of the principles of proof-carrying code, in which program certiÔ¨Å-
cation is reduced to checking a provided safety proof. In SCC,
program certiÔ¨Åcation is an efÔ¨Åcient re-examination of a program‚Äôs
state space. A code producer, who offers a program for use, pro-
vides a search script that encodes a search of the program‚Äôs state
space. A code consumer, who wants to certify that the program
Ô¨Åts her needs, uses the search script to direct how a model checker
searches the program‚Äôs state space.
Basic SCC achieves slight reductions in certiÔ¨Åcation time, but
it can be optimized in two important ways. (1) When a program
comes from a trusted source, SCC certiÔ¨Åcation can forgo authenti-
cating the provided search script and instead optimize for speed of
certiÔ¨Åcation. (2) The search script can be partitioned into multiple
partial certiÔ¨Åcation tasks of roughly equal size, which can be per-
formed in parallel. Using parallel model checking, we reduce the
certiÔ¨Åcation times by a factor of up to n, fornprocessors. When
certifying a program from a trusted source, we reduce the certiÔ¨Åca-
tion times by a factor of up to 5 n, fornprocessors.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program VeriÔ¨Åcation‚Äî
Model checking ; K.7.3 [ The Computing Profession ]: Testing, Cer-
tiÔ¨Åcation, and Licensing
General Terms
VeriÔ¨Åcation
Keywords
Software CertiÔ¨Åcation, Model Checking
1. INTRODUCTION
Component-based software engineering promises rapid develop-
ment and extension of systems through the assembly of pre-existing
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ASE‚Äô10, September 20‚Äì24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.and third-party components. However, before a code consumer
uses an acquired component in her software product, she must cer-
tifythat the component Ô¨Åts her needs. If a component comes from a
non-trusted source, then the code consumer will want to check that
the component is safe and performs as advertised. Even if a com-
ponent comes from a trusted source, the code consumer may still
want to assess whether the component exhibits additional desired
properties, beyond those claimed by the code producer.
Proof-carrying code (PCC) [18] has been advanced as a means
to ease certiÔ¨Åcation. The premise of PCC is that proof checking
is faster and simpler than theorem proving. In PCC, the code pro-
ducer veriÔ¨Åes via theorem proving that his program satisÔ¨Åes a set
of predeÔ¨Åned safety properties, and provides as evidence a safety
proof . The code consumer certiÔ¨Åes the program by checking the
validity of the accompanying safety proof against the code. How-
ever, PCC certiÔ¨Åcation can only (re)verify the properties that are
substantiated by the safety proof. Also, because reasoning about
general properties of programs is complex, PCC has so far focused
on program-independent security properties (e.g., memory safety,
type safety, resource bounds).
In this paper, we introduce the concept of search-carrying code
(SCC) , in which we apply the goals of PCC to programs and prop-
erties that can be model checked. SpeciÔ¨Åcally, we explore whether
information collected during successful veriÔ¨Åcation of a program
(via explicit-state model checking) could be used to ease subse-
quent certiÔ¨Åcation (via explicit-state model checking) of the same
program. Our approach focuses on paths through a program‚Äôs reach-
ability graph. A reachability graph is a graphical representation
of a program‚Äôs set of possible executions, in terms of execution
states (i.e., program counter, variable values, etc.) and transitions
(i.e., program statements) between execution states. As a code pro-
ducer‚Äôs model checker explores a program‚Äôs reachability graph, it
records its search path as a search script , which effectively acts
as a certiÔ¨Åcate of the veriÔ¨Åcation. The code consumer‚Äôs model
checker takes the script as input and uses it to speed up the task
of re-examining the program.
Basic SCC achieves slight reductions in certiÔ¨Åcation times. Both
traditional model checking and SCC certiÔ¨Åcation check properties
in every state of a program‚Äôs state space. However, whereas tradi-
tional model checking must ascertain a program‚Äôs reachable state
space, SCC certiÔ¨Åcation can simply conÔ¨Årm that the provided script
truthfully reÔ¨Çects the state space. We take advantage of this distinc-
tion and modify the data structures that the model checker uses to
keep track of visited states, thereby realizing a small, up to 5%
speed-up in certiÔ¨Åcation time.
In the special case where a code consumer trusts the code pro-
ducer but wants to check additional properties, and the veracity of
the search script is not in question, SCC certiÔ¨Åcation need not au-
367
thenticate the script and can instead be optimized for speed. In
trustful SCC , the provided search script encodes a perfect search
of a program‚Äôs state space that visits each program state exactly
once, avoiding paths that lead back to already visited states. The
resultant speed-up in certiÔ¨Åcation time depends on the structure of
a program‚Äôs reachability graph: in particular, it depends on the ratio
of the number of transitions to the number of states.
More signiÔ¨Åcantly, SCC certiÔ¨Åcation can be parallelized more ef-
fectively than traditional model-checking tasks can. The main chal-
lenge in parallel model checking is balancing the workload among
parallel processors. However, in SCC, the search task is known
in advance and is encoded in the search script. The search script
can be partitioned into multiple tasks, each covering a cohesive re-
gion of the search space that a processor can explore independently,
thereby avoiding the inter-processor communication that is usually
necessary to balance workloads dynamically.
The contributions described in this paper are as follows:
We propose a model-checking-based certiÔ¨Åcation technique
called search-carrying code (SCC), in which a code producer
provides a search script that a code consumer uses to direct
the search of its model checker. We discuss how the tech-
nique veriÔ¨Åes the veracity of a provided search script. We
also show how SCC certiÔ¨Åcation can be optimized in cases
where the source of a component is trusted and the goal is
simply to check additional properties.
We present a greedy algorithm to partition an SCC search
script into several scripts, which can direct several partial
certiÔ¨Åcations of a program in parallel.
We discuss requirements for the code producer‚Äôs and con-
sumer‚Äôs model checkers. While we have embedded our SCC
algorithm into Java PathÔ¨Ånder (JPF) [27], we expect that
SCC can be applied to other explicit-state model checkers.
We evaluate the performance of SCC on a suite of Java pro-
grams. By combining SCC and parallel model checking, we
achieve an average speed-up of up to nusing nprocessors.
When certifying a program from a trusted source and em-
ploying parallel model checking, we report an average speed-
up of up to 6nusing nprocessors.
This paper is organized as follows. In Section 2, we describe the
basic algorithms and technologies needed to support SCC-based
certiÔ¨Åcation, including the special case of trustful SCC. Section 3
describes how to parallelize SCC to take advantage of parallel model
checking and presents the results of our evaluation. Section 4 dis-
cusses outstanding issues and known limitations of SCC, and Sec-
tion 5 presents related work. We conclude with Section 6.
2. SEARCH-CARRYING CODE
Software model checking exhaustively examines a program‚Äôs
state space, checking conformance with desired properties. Dur-
ing veriÔ¨Åcation of a program, the emphasis is on Ô¨Ånding bugs and
ultimately showing that a program is error-free. For certiÔ¨Åcation,
the goal is to conÔ¨Årm that a program behaves as advertised, and
possibly to check for additional non-advertised properties.
Ideally, it is faster to certify a program than it was to verify it in
the Ô¨Årst place. The goal of search-carrying code (SCC) is to use
information collected during model-checking-based veriÔ¨Åcation of
a program to speed up model-checking-based certiÔ¨Åcation of the
program. A code producer‚Äôs model checker performs a traditional
exhaustive search and veriÔ¨Åcation of a program‚Äôs state space. At thesame time, it constructs a search script that represents its search of
the state space. The search script is a sequence of transitions (i.e.,
program statements) and their resultant execution state IDs (i.e.,
not state encodings); the script corresponds to a depth-Ô¨Årst search
of the program‚Äôs reachability graph. During certiÔ¨Åcation, a code
consumer‚Äôs model checker uses the provided search script to direct
its search of the program‚Äôs state space and certiÔ¨Åes that the pro-
gram satisÔ¨Åes its advertised properties, plus any additional desired
properties. In general, SCC can be used to certify safety properties
of programs, where the properties are expressed as program invari-
ants or assertions, and to conÔ¨Årm absence of deadlocks. We discuss
properties in more detail in Section 4.
Search-carrying code possesses many of the same beneÔ¨Åts of
proof-carrying code. First, the burden of verifying the program
is borne by the code producer, whereas the code consumer simply
re-checks the program. Second, the search script can be generated
automatically by the code producer‚Äôs model checker, as we show
in the next section. Third, SCC certiÔ¨Åcation can detect accidental
or malicious deviations between a program and associated search
script. There are three types of deviation: (1) the script includes
nonexistent transitions, (2) the script omits a transition, or (3) the
script incorrectly claims that a transition leads to an already-visited
state. The Ô¨Årst two types of deviation are easily detected: in the
Ô¨Årst case, the program has no program statement that matches the
script‚Äôs transition instruction; and in the second case, the script says
to end the examination of a state before all of its transitions have
been explored. In both cases, the model checker detects the dis-
crepancy and the certiÔ¨Åcation fails. The third type of deviation is
more menacing because, if undetected, it results in a partial search
of the program‚Äôs state space: the mislabelled state is deemed to
have already been visited, so the model checker does not test the
state and does not explore the state space that is reachable from it.
To detect this third type of deviation, SCC certiÔ¨Åcation must‚Äìin ad-
dition to visiting and testing all of the program‚Äôs states‚Äìexplore all
of the transitions emanating from these states, to see if they lead to
new unvisited states. Thus, the search script encodes the program‚Äôs
entire reachability graph.
Given that SCC certiÔ¨Åcation entails re-exploring a program‚Äôs en-
tire reachability graph, it might seem surprising that SCC achieves
any savings at all. As will be seen, small savings come from be-
ing able to conÔ¨Årm the script‚Äôs encoding of the reachability graph,
rather than determining the reachability graph, as is the case in tra-
ditional model checking. More signiÔ¨Åcant savings come from par-
allelizing SCC certiÔ¨Åcation. We describe parallel SCC in Section 3.
In the special case of trustful SCC certiÔ¨Åcation, the code pro-
ducer and the veriÔ¨Åcation results are trusted. However, the code
consumer wants to certify additional properties of the program, and
the code producer is unable or unwilling to check these. Because
the code producer is trusted, the code consumer may choose not to
check the veracity of the script. As a result, we can aggressively
optimize the certiÔ¨Åcation task for speed. We describe trustful certi-
Ô¨Åcation in Section 2.3.
2.1 Search Script Construction
An SCC search script records all transitions in a program‚Äôs reach-
ability graph and the state ID of each transition‚Äôs destination state.
Consider Figure 1, which depicts the reachability graph of an arti-
Ô¨Åcially simple program. Transition labels abstractly represent the
program statements being executed. The script for this program is:
Trans instr: ‚Äìt1t1Bt2t1Bt2t1BBt3t1BBBBt2B
State ID: S1S2S1S2S3S1S3S4S2S4S3S5S4S5S3S2S1S4S1
where the tis encode program statements (e.g., the byte code in-
struction, or a combination of byte code and thread ID) and Bs rep-
368S1
S4S5S2
S3t1
t2
t3 t1t1
t1t1
t2t2Figure 1: Sample reachability graph of a program
resent backtracks. Reading the script from left to right, the search
starts in the program state labelled S1; it explores the program
statement represented by transition t1, which results in a program
state labelled S2; and so on.
SCC uses encodings of program statements in the script rather
than transition IDs, so that different model checkers interpret the
script in the same way, and search the state space in the same order.
Below is an example partial script in which transition instructions
are expressed as byte-code instructions:
Trans instr: ‚Äìaload _0aload _1Bgetfield #5
State ID: S1 S2 S1 S2 S3
For the remainder of this paper, we will abstract instructions to
transition IDs for the clarity of presentation.
To minimize the size of the search script, destination states are
represented by state ID rather than by explicit state encodings. State
IDs are unique identiÔ¨Åers that the code producer‚Äôs model checker
creates and assigns to states during the course of the veriÔ¨Åcation
search, starting with identiÔ¨Åer S1and incrementing by 1 each time
a new state is discovered. A transition that leads to a new state is
referred to as a productive transition ; its destination state has an
ID that is larger than the largest state ID encountered so far.
2.2 Search Script Usage
During SCC certiÔ¨Åcation, the model checker follows the instruc-
tions given in the provided search script, checking properties and
authenticating the search script on-the-Ô¨Çy. Any discrepancy causes
the certiÔ¨Åcation to fail. Discrepancies are identiÔ¨Åed in three ways
1. The script instructs the model checker to explore a nonexis-
tent transition (i.e., a nonexistent program statement).
2. The script instructs the model checker to backtrack when the
state still has unexplored transitions.
3. The script asserts that two transitions have the same desti-
nation state (with the same state ID), but the model checker
determines that the two program states have different Ô¨Ånger-
prints. To facilitate this check, the model checker maintains
during certiÔ¨Åcation a mapping FP from state IDs to Ô¨Ånger-
prints. A each new state is reached (in order of state ID),
its ID and Ô¨Ångerprint are entered into FP. When a state is
revisited (indicated in the script by a destination state whose
ID that is lower than the highest ID), its previous Ô¨Ångerprint
is retrieved from FP and compared against the new Ô¨Ånger-
print. A mismatch is a discrepancy. Our map FPis slightly
more efÔ¨Åcient than a hash table of visited states because it
grows more gracefully.
2.3 Trustful CertiÔ¨Åcation
In cases where a program comes from a trusted source and the
code consumer trusts the results of the code producer‚Äôs veriÔ¨Åcation,
t2t1
t3
backtrackS1
S2
S3 S4S5
t2Figure 2: Perfect search of a program‚Äôs state space
SCC can still be useful, especially to check additional properties.
Perhaps the code consumer found the program in a trusted soft-
ware repository and is interested in using the program, but only if
some additional properties are met. The code producer might not
be available or willing to perform additional checks.
When the code consumer trusts the source of the program, he
might also trust the veracity of the search script. If so, the certiÔ¨Å-
cation need only examine the program‚Äôs states, to test properties. It
need not explore all of the transitions in the program‚Äôs reachability
graph, checking whether any reachable state has been missed. To
see the difference, consider again the reachability graph in Figure 1.
An exhaustive search of the graph explores all nine transitions, vis-
iting the same states multiple times. In contrast, a perfect search
traverses a spanning tree of a program‚Äôs state space: it explores
only productive transitions and visits each state exactly once1. Fig-
ure 2 depicts a depth-Ô¨Årst, perfect search of the graph from Fig-
ure 1. Solid lines represent productive transitions and dashed lines
represent backtracks to parent states. The corresponding search
script is:
Trans instr: t1t2t2Bt3
The script does not record the transitions‚Äô target state IDs because
trustful certiÔ¨Åcation does not check the veracity of the script.
Trustful SCC effects a perfect search of a program‚Äôs state space.
The code producer provides a program and matching trustful search
script. During certiÔ¨Åcation, the code consumer‚Äôs model checker
uses the search script to direct its search of the program‚Äôs state
space. Neither state Ô¨Ångerprints nor hash-tables of visited states
are created or maintained, resulting in additional speedup.
2.4 Evaluation of SCC
We implemented SCC certiÔ¨Åcation in Java PathÔ¨Ånder (JPF) [17].
JPF is an explicit-state model checker for Java byte-code programs.
We refer to the resulting model checker as JPF-scc . For conve-
nience, we implemented SCC veriÔ¨Åcation and certiÔ¨Åcation in the
same model checker but, in practice, these tasks might be per-
formed by separate tools. JPF, and our modiÔ¨Åed variants, em-
ploy partial-order reduction and two types of symmetry reduction:
(1) states that are identical except for unreferenced objects (i.e.,
garbage) are considered to be equivalent, and (2) states that are
identical except for the order in which classes and objects are loaded
are considered to be equivalent. We discuss the compatibility of
SCC with various state-space reduction techniques in Section 4.
We evaluated our work on a suite of nine Java programs that have
been used in previous empirical studies. Table 1 lists each program
including its source, the parameter values that we used (e.g., in-
stantiating 8 dining philosophers), the numbers of invariants and
assertions that we checked for each program, the number of states
in the reachability graph, the ratio of transitions to states, and the
1Backtracking does not constitute ‚Äúvisiting" a state because the
work of constructing and testing the state is already done.
369Table 1: Java Programs Used for Evaluation
Src Program Parameters Properties #States #Trans Time
#Inv/#Assert #States (sec)
[17] Dining Philosopher (8) #philosophers 1/2 209014 5.2 220
[23] Bounded Buffer (5,4,4) buffersize,#prod,#cons 1/3 786987 7.1 1088
[21] Nasa KSU Pipeline (4,1) stagesize,#listeners 3/4 59512 4.1 45
[23] Nested Monitor (5,4,4) buffersize,#prod,#cons 6/4 71941 6.9 99
[23] Pipeline (7) stagesize 3/3 82011 6.1 101
[23] RWVSN (4,4) #readers,#writers 3/4 227116 5.1 245
[23] Replicated Workers (5,2) #workers,#items 4/5 710022 5.1 860
[7] Sleeping Barber (2,4,3) #barber,#customers,#chairs 4/5 1452194 4.3 1308
[6] Elevator(5,10,10) #elevators,#Ô¨Çoors,#people 4/8 386032 8.4 1167
Table 2: Results for SCC VeriÔ¨Åcation and CertiÔ¨Åcation
SCC certiÔ¨Åcation Trustful SCC certiÔ¨Åcation
Program (size) VeriÔ¨Åcation (sec) Script size(KB) CertiÔ¨Åcation (sec) Speed-up Script size(KB) CertiÔ¨Åcation (sec) Speed-up
Dining Philosopher (4KB) 221 104 213 1.03 25 35 6.3
Bounded Buffer (6KB) 1090 329 1036 1.04 74 130 8.4
NASA KSU Pipeline (2KB) 45 91 44 1.02 22 9 5
Nested Monitor (7KB) 100 45 97 1.01 9 14 7.1
Pipeline (5KB) 102 51 99 1.01 11 15 6.7
RWVSN (9KB) 246 102 236 1.03 29 39 6.3
Replicated Workers (15KB) 862 272 819 1.05 72 140 6.1
Sleeping Barber (8KB) 1310 492 1245 1.05 187 245 5.3
Elevator (29KB) 1169 248 1122 1.04 54 129 9
time to model check the program using JPF. We also checked each
program for deadlock violations. We ran our experiments on an
Intel Pentium 4 3.2GHz machine with 1.5GB of memory, running
Windows XP. We ran each experiment ten times and report the av-
erage of the ten runs.
We evaluate the utility of SCC on the basis of how long it takes
to perform SCC certiÔ¨Åcation, compared to the time it would take
a code consumer to reverify a program. Table 2 shows the results
for SCC certiÔ¨Åcation using JPF-scc. Column VeriÔ¨Åcation shows
the time incurred by the code producer to model check the program
and create the search script, including the time to write the script
to disk. Column CertiÔ¨Åcation reports the time incurred by the code
consumer to certify each program, including the time to read the
search script from disk. Column Speed-up shows the speed-up of
a certiÔ¨Åcation search compared to a traditional JPF search, as re-
ported in Table 1. For example, the time to certify the Sleeping
Barber program and to check the script is 1245 seconds, which is
1.05 times faster than JPF veriÔ¨Åcation of the same program.
The speed-ups of SCC are very small and are mainly due to keep-
ing a map of Ô¨Ångerprints ( FP) instead of a hash table. For our set
of programs, we report an overhead of 2% to 5% for keeping and
maintaining a hash table. SCC saves this small cost. Because of the
way that JPF maintains hash tables and resizes tables as needed, the
savings increase with the size of the program‚Äôs state space.
Table 2 also shows the runtime performance of trustful SCC cer-
tiÔ¨Åcation. For example, the time to certify the Pipeline program
is 15 seconds, which is 6.7 times faster than traditional JPF veri-
Ô¨Åcation of the same program. The speed-up of trustful SCC cer-
tiÔ¨Åcation is proportional to the ratio of the number of transitions
to the number of states in the program‚Äôs reachability graph; this is
also the ratio of unproductive to productive transitions. The speed-
up is slightly better than the ratio because of the savings from not
creating and comparing Ô¨Ångerprints.
2.5 Search Script Size
The feasibility of SCC depends not only on runtime performance
but also on the size of the search script. Given a program whosereachability graph has Sstates and Ttransitions, SCC will pro-
duce a search script containing at most 2Tinstructions ( Tforward
transitions and at most Tbacktracks) and trustful SCC will pro-
duce a search script that has at most 2Sinstructions. Because the
number of states and transitions are exponential in the size of the
program, one might expect that script size is an issue.
Fortunately, search scripts contain lots of replication (e.g., byte
code instructions, backtrack commands), which makes them good
candidates for compression. ZIP data compression [22] reduced the
sizes of our search scripts by factors of 550 to 650. Table 2 shows
the size in KB of the compressed search script for each program,
for both SCC and trustful SCC certiÔ¨Åcation. It also shows the size
of each program‚Äôs class Ô¨Åles along with the program name. The
sizes of compressed scripts are on the order of (T10 4)KB
for SCC and (S10 4)KB for trustful SCC. Extrapolating to
larger programs, with 100 million states and a billion transitions,
the script sizes might be on the order of 100MB for SCC and 10MB
for trustful SCC. Such script sizes are large but are manageable.
3. PARALLEL SCC
The promise of parallel model checking [25] is that we can re-
duce search times by distributing the search among multiple paral-
lel processors. In general, it is difÔ¨Åcult to balance a model-checking
task evenly among processors because the size of the search space
is not known in advance. Attempts to partition the workload in ad-
vance (e.g., assigning states to processors based on state informa-
tion) have resulted in substantial communication overheads, due
to the need to transfer new states to their designated processors.
Even on a shared-memory architecture, this style of parallel model
checking can suffer considerable overhead because processors need
to coordinate their shared access to each others‚Äô worklists.
In SCC, the certiÔ¨Åcation workload is known in advance, in the
form of a search script. As such, it is possible to partition the work-
load into multiple search tasks of roughly equal size. In the follow-
ing sections, we Ô¨Årst describe how to partition an SCC search script
and then explain the optimizations for trustful certiÔ¨Åcation.
370S2
S3 S4 S5
S6S7S8 S9 S10S1
t1
t1
t1
t1t1t1t2
t1 t1t2
t1
t2
t2t2t3 t316
1574021411S1
S2S3S4S5S6S7S8S9
S10
Subgraphs
S1 S10S7 S10S2S8S9S5S9S8S4S8S3S8S2S3S7S6S7S3S4S6S3S6S5S6S4S5S4S3S2 S1S2t2 Bt1 t1 t1 t1 t1 t1 t1t1t1 t2 t2 t2 t2 t3 t3 B B BBB BBB B B BB B B B -Script(16)
(15)
(7) (4)(4) (1) (1)
(1) (0)
(2)Figure 3: Reachability graph with its script and Subgraphs
3.1 Partitioning the State Space
The goal of parallel SCC is to partition the search script into mul-
tiple non-overlapping search tasks, each of which covers a contigu-
ous region of the program‚Äôs reachability graph that can be searched
separately.
LetScript be the full search script of a program, as described in
Section 2.1, and let jScriptjbe the size of the script in terms of the
number of transitions. Prior to certiÔ¨Åcation, the certiÔ¨Åer‚Äôs model
checker constructs a partition P=fp1; :::; p kgofScript intok
search tasks. Each partition region pi2Pcorresponds to a sub-
graph in the program‚Äôs reachability graph, andto a partial search
script Script ithat is a substring of Script . A subgraph piconsists
of all states that can be reached via productive transitions from pi‚Äôs
root and all transitions, productive and unproductive, originating
from those states. For example, consider the reachability graph in
Figure 3, in which thick edges represent productive transitions. In
this example, the subgraph rooted at state S4consists of the states
S4,S5andS6; the subgraph would not include S3because it is
reached via an unproductive transition from S6. The size of each
piis the number of transitions emanating from states in pi.
To facilitate script partitioning, SCC veriÔ¨Åcation generates, along
with the search script, a list Subgraphs that records for each pro-
gram state sthe number of transitions in the subgraph rooted at s.
Basically, during veriÔ¨Åcation, the model checker performs a depth-
Ô¨Årst search of the program state space. As each new state sis en-
countered, an entry indexed by state ID is added to Subgraphs .
Ass‚Äôs child states are explored and the sizes of their subtrees are
computed, the size of sis updated. The Subgraphs list is provided
to the code consumer, along with the program and search script. In
SCC certiÔ¨Åcation, the size of a Subgraphs list is less than 10% of
the size of the search script, and in trustful SCC certiÔ¨Åcation, the
size of Subgraphs is less than 20% of the size of the search script.
Figure 3 shows an example reachability graph with its corre-
sponding Script andSubgraphs . The Subgraphs table shows
for each state s(left column) the size of the subgraph (right col-
umn) rooted at s. For example, the subgraph rooted at state S4
consists of the states S4; S5; S6and has size four (i.e., the four
transitions originating from those states). The value in parenthe-
ses below each state identiÔ¨Åer in the reachability graph in Figure 3
shows the same information.
Figure 4 gives an overview of our partitioning algorithm. It takes
as inputs the search script Script and the Subgraphs list that are
provided by the code producer, and the number of partitions kto
generate (based on the number of available parallel processors). In
theith iteration, the algorithm searches Subgraphs for a subgraph
whose size is closest to 1=k iof the number of transitions not
yet assigned to a partition region (line 6); this subgraph becomes a1 I n p u t : Script ;/s e a r c h s c r i p t e n c o d i n g r e a c h a b i l i t y graph /
2 I n p u t : Subgraphs ;/r o o t and s i z e o f subgraphs i n Script /
3 I n p u t : k;/number o f p a r t i t i o n r e g i o n s t o g e n e r a t e /
4i= 0 ;
5 while {i < k  1}{
6 S e a r c h Subgraphs f o rpiwhose s i z e i s c l o s e s t t ojScriptj
k i;
7 Remove s e a r c h s c r i p t f o rpifrom Script ;
8 Remove a l l s t a t e s i n pifrom Subgraphs ;
9 Update t h e s i z e s of s u b g r a p h s l e f t i n Subgraphs ;
10 Compute p a t h t o i n i t i a l s t a t e of pi;
11 i++;
12 }
Figure 4: Partitioning algorithm
new partition region pi. Next, the partial search script Script ifor
partition region piis extracted from Script (line 7). The algorithm
also removes all states in pifromSubgraphs (line 8). We describe
both processes in Section 3.1.1. The algorithm then updates the
sizes of the remaining subgraphs in Subgraphs (line 9). Note that
only the sizes of ancestor states of pineed be modiÔ¨Åed, and their
sizes are reduced by the size of pi. We describe how ancestor states
are identiÔ¨Åed in Section 3.1.2. Finally, the algorithm constructs the
path from the program‚Äôs initial state to the initial state of search
taskScript i(line 10). We discuss the rationale and process for
constructing this initialization path in Section 3.1.2.
Figure 5 shows the result after one iteration of our partitioning
algorithm as applied to Figure 3, for k= 3. The subgraph p1,
rooted at state S4, is selected for extraction and its subscript is re-
moved from Script (the dark line in Script shows from where the
subscript was extracted). The states in p1have been removed from
Subgraphs and the sizes of S4‚Äôs ancestors ( S1; S2; S3) have been
reduced by S4‚Äôs size. The initialization path for p1is a sequence
of transitions from the program‚Äôs initial state to the subgraph‚Äôs ini-
tial state. Dashed states in each of the resulting partition regions
represent states that do not belong to the region but that are still
reached as part of that region‚Äôs search task; they are reached when
exploring transitions that emanate from states within the region.
Figure 6 shows the Ô¨Ånal partition of the graph from Figure 3 into
three regions. The scripts for p1andp2contain initialization paths
to their respective root states. The resultant search scripts represent
the certiÔ¨Åcation tasks to be distributed among parallel processors.
The complexity of our partitioning algorithm is O(k(S+T)):
steps 6, 8 and 9 each have running times of O(S)for a reachability
graph with Sstates, and steps 7 and 10 each have running times of
O(T). In our experiments, we noticed that this overhead translates
into approximately 0.5% to 3% of the total certiÔ¨Åcation time.
3.1.1 Updating Data Structures
In this section, we discuss how Script andSubgraphs are up-
dated as our partitioning algorithm extracts each partition region
pi. We remove from Script the subscript that represents the search
of region pi. Let sibe the ID of the root state of pi. Because
Script records a depth-Ô¨Årst search of the reachability graph, and
because state IDs reÔ¨Çect the order in which the states are discovered
in this search, the subscript-to-be-removed starts after the leftmost
instance of siand ends before the subsequent backtrack from si
(to a state ID less than si). Thus, the subscript for region p1in
Figure 5, with start state S4, is
p1:t1Bt2t1Bt2BB
S5S4S6S5S6S3S6S4
After discarding trailing backtrack commands, we obtain a search
script Script 1that speciÔ¨Åes the search of region p1, starting from
the initial state of p1:
371S2
S3 S7S8 S9 S10S1
t1
t1
t1t1t2
t1 t1t2
t1 t2t2t3 t312
1131411S1
S2S3S7S8S9
S10
Subgraphs
S1 S7 S10S2S8S9S5S9S8S4S8S3S8S2S3S7S6S7S3S4S3S2t2 t1 t1 t1 t1 t1t1t1 t2 t2 t3 t3B B BBB B BB B -Script 1S4 S5
S6t1
t1t2
S3S6S5S6S4S5t1 t1 t2 t2 B Bp1
Script
Initialization: t 1‚Äì t1‚Äì t1
S3
S6
S4
 S5Figure 5: Result of partitioning after one iteration of algorithm
p1(S4):t1Bt2t1Bt2
S5S4S6S5S6S3
Given a partition region pi, updating Subgraphs entails remov-
ing all entries that correspond to states in the region (line 8 in our
partitioning algorithm). Again, let sibe the ID of the root state
ofpi. Any state in Script iwhose ID is greater than or equal
tosirefers to a state in the region piand must be removed from
Subgraphs . For example, in Script 1, states S4,S5, andS6are
removed from Subgraphs .
Each iteration of the partitioning algorithm produces a script for
a different partition region. When the algorithm terminates, what
remains of Script forms a search script for the kth region. Figure 6
shows the search scripts for each partition region.
S2
S3
S4 S5
S6S7S8 S9
S1p2
p1p3
S10t3
t3t1
t1t1
t2t1t2
t1t1t1 t2
t1t1
t2t2
S3
S5
 S4
 S3
S6
S4
S8
S3S6S5S6S4S5t1 t1 t2 t2 B B
Initialization: t 1‚Äì t1‚Äì t1S5S9S8S4S8S3t1 Bt 1 t2B
Initialization: t 1‚Äì t2t3
S1 S7 S10 S2S3S7S6S7S3S4S3S2t1 t1 t1t1t1 t2 t3 BBB B - t2
S8B
S2
Figure 6: Subgraphs with scripts and initialization paths
3.1.2 ‚ÄúConstructing" Initial States
EachScript istarts at the root state of a partition region pi. We
could attempt to construct the corresponding ‚Äúinitial‚Äù program state
for each search task, but JPF program states are complex and are
difÔ¨Åcult to construct and restore: they comprise not only the vari-
able valuation but also information about threads and the progress
of the search. Instead, we preÔ¨Åx each search script with an initial-
ization path : a sequence of transitions from the program‚Äôs initial
state to the start state of the search task. We discuss in Section 3.4
the overhead incurred by this decision.
To construct the initialization path, the original Script is scanned
from start to end. Every time a transition is reached, it is pushed
onto a stack. Every time a backtrack command is read, the top tran-
sition is popped off the stack. When a state ID sis Ô¨Årst encountered,
the transitions in the stack make up the initialization path from the
program‚Äôs initial state to state s. For example, the initializationpath to p1‚Äôs root state is: t1t1t1. Note that this algorithm does not
construct the shortest path to a given state, but it does construct the
shortest path with respect to the given script.
The states along the initialization path are all ancestor states of
sin the reachability graph. Thus, we can use the same process
to update the sizes of the subgraphs remaining in Subgraphs after
removing all states of pifromSubgraphs (line 9 of the algorithm).
3.1.3 Correctness
Our partitioning algorithm divides a search script in such a way
that the resultant subscripts cover all states and transitions of the
original script. Each iteration of the partitioning algorithm extracts
a search subscript that corresponds to a leaf subgraph piof a pro-
gram‚Äôs reachability graph: the subgraph is rooted at state si, it in-
clude all states that are reachable from sivia productive transitions,
and includes all transitions originating from those states. Thus, the
corresponding subscript is a contiguous substring of the original
search script, starting with the Ô¨Årst occurrence of initial state si
and ending before the Ô¨Årst backtrack from state si.
Because the extracted subscripts correspond to leaf subgraphs in
the original reachability graph, their extractions do not affect the
continuity of what remains of Script . When the algorithm termi-
nates, what remains of Script is a search subscript for a contiguous
kth subgraph: the subgraph is rooted at the program‚Äôs initial state
s1, includes states that are reachable from s1via productive transi-
tions up to and excluding the root states of the extracted partition
regions , and all transitions originating from those states. In this
manner, the algorithm splits Script without removing any states or
transitions (except backtrack transitions).
If the provided Subgraphs is not accurate with respect to the
program‚Äôs reachability graph, the partitioning algorithm will still
produce sub-script that cover disjoint regions and, taken together,
cover the program‚Äôs entire reachability graph. For example, if one
or more entries in Subgraphs list incorrect sizes of subgraphs,
then the algorithm will simply produce partitions whose sizes have
a larger standard deviation. Alternatively, if one or more states are
missing from Subgraphs , this will be detected in line 8 when the
states of a region are removed from Subgraphs . IfSubgraphs
contains extra entries, this will be discovered if the algorithm ever
chooses one of those states to be the root of a region; otherwise, it
will have no effect on the algorithm.
3.2 Parallel CertiÔ¨Åcation
The program and search scripts are distributed to parallel proces-
sors, which run the certiÔ¨Åer‚Äôs model checker. Each processor keeps
its own local copy of FP, mapping state IDs to program-state Ô¨Ån-
gerprints. If a processor detects any discrepancy between its search
372Table 3: Results for Parallel SCC CertiÔ¨Åcation
SCC certiÔ¨Åcation Trustful SCC certiÔ¨Åcation
# sub-scripts 10 50 100 10 50 100
Program Max task Speed up Max task Speed up Max task Speed up Max task Speed up Max task Speed up Max task Speed up
Dining Phil 13% 8 4% 22 2% 38 11% 39 4% 103 3% 133
Bounded Buffer 11% 9 4% 25 3% 30 12% 48 4% 140 2% 270
Nasa KSU Pipe 12% 8 4% 22 3% 25 11% 30 5% 64 3% 104
Nested Monitor 11% 9 5% 18 3% 28 10% 56 4% 136 3% 175
Pipeline 12% 8 6% 15 2% 39 13% 39 5% 96 3% 155
RWVSN 11% 9 4% 22 3% 27 11% 38 5% 80 2% 194
Replicated Workers 12% 8 5% 18 2% 40 12% 34 4% 100 3% 130
Sleeping Barber 11% 9 4% 23 3% 28 11% 31 4% 85 2% 164
Elevator 10% 10 4% 23 2% 45 12% 57 5% 132 4% 160
Average 11% 9 4% 21 3% 33 11% 41 4% 104 3% 165
S2
S3S4 S5
S6S7S8 S9 S1p2
p1p3
S10
p3:  t1-t1-t3-B  -B  -t 3p2: t1‚Äì t2-t3
p1: t1-t1-t1-t1-B  -t 2t3t3
t3t1
t1
t1
t2
Figure 7: Script partition for trustful SCC
script and the program, it raises an error. In addition, once all pro-
cessors have Ô¨Ånished their certiÔ¨Åcation tasks, the processors‚Äô FP
maps are compared to ensure that all processors map state IDs to
the same Ô¨Ångerprints. Any mismatch is reported as an error. This
Ô¨Ånal check on the veracity of the search scripts performs at most
nScomparisons, where nis the number of processors and Sis the
total number of states.
3.3 Parallel Trustful CertiÔ¨Åcation
The algorithm for partitioning a search script for trustful certi-
Ô¨Åcation is similar to the algorithm presented in Figure 4, but is
applied to a trustful Script (which contains no unproductive tran-
sitions). The only difference between the algorithms is that the
partitioning algorithm for trustful certiÔ¨Åcation removes the produc-
tive transitions that span regions (e.g., the transition from S3toS4
in Figure 5). Figure 7 shows the partitions that we obtain for par-
allel trustful certiÔ¨Åcation of the sample reachability graph given in
Figure 3. The regions represent spanning subtrees of the original
reachability graph.
3.4 Implementation and Evaluation
We implemented parallel SCC in Java PathÔ¨Ånder and refer to the
resulting model checker as JPF-pscc . For convenience, JPF-pscc
supports both veriÔ¨Åcation and certiÔ¨Åcation modes. In the veriÔ¨Åca-
tion mode, JPF-pscc generates a search script to be used during
certiÔ¨Åcation. In certiÔ¨Åcation mode, JPF-pscc can be used to parti-
tion the search script into kscripts or to model check the program
using one of kscripts to direct its search. At the end of a certiÔ¨Å-
cation task, JPF-pscc outputs its FP map. At present, a separate
program is needed to compare the FPs from all certiÔ¨Åcation tasks.
To evaluate the performance of parallel SCC, we used JPF-pscc
to partition each program‚Äôs state space into 10, 50 and 100 certi-
Ô¨Åcation tasks (i.e., sub- search scripts). Because the sizes of the
resulting scripts are not exactly equal, we report for each program
the time it takes to examine the largest sub-script. To this time we
have added (1) the time it takes to partition the search script andTable 4: Avg. and Max. Lengths of Initialization Paths
# sub-scripts 10 50 100
Program Avg Max Avg Max Avg Max
path path path path path path
Dining Phil 11 16 13 16 12 18
Bounded Buffer 75 615 217 6742 139 6678
RWVSN 50 495 57 785 101 845
Sleeping Barber 12 25 17 35 25 31
Elevator 50 68 71 75 71 78
Average 31 153 53 877 53 876
(2) the time it takes to compare all FPmaps sequentially. In prac-
tice, the actual time of this latter task would be less because the
search tasks would Ô¨Ånish at different rates and FP maps could be
compared against the current master map as tasks complete.
Table 3 shows the results for parallel SCC certiÔ¨Åcation and par-
allel trustful SCC certiÔ¨Åcation. For each certiÔ¨Åcation method and
the number of partitions (10, 50, or 100), column Max task lists the
size of the largest search script for each program; for SCC certi-
Ô¨Åcation, size is reported as a percentage of the program‚Äôs number
of transitions, and for trustful SCC certiÔ¨Åcation, size is reported as
a percentage of the program‚Äôs number of states. Columns Speed-
upreport the speed-up in certiÔ¨Åcation time over the time to ver-
ify the entire program using JPF, as reported in Table 1. In SCC
certiÔ¨Åcation, the size of the largest sub-script determines the opti-
mum number of processors to use during certiÔ¨Åcation. For exam-
ple, when partitioning the reachability graph of the dining philoso-
phers example into 10 subgraphs for SCC certiÔ¨Åcation, the size of
the largest resulting subgraph is 13%. Thus the optimum number
of parallel processors to use is 8. Taking this into consideration,
the results show that speed up for parallel SCC certiÔ¨Åcation is on
average a factor of n, fornprocessors. Trustful SCC certiÔ¨Åcation
can achieve a speed up of up to a factor of 5n, fornprocessors.
The speed-up factors reported in Table 3 are not simply the prod-
uct of the speed-up factors reported for nonparallel SCC certiÔ¨Åca-
tion (in Section 2) and the number of parallel processors employed.
This is partly because of the time needed to compare FP maps at
the end of certiÔ¨Åcation, and partly because the search tasks vary
in size and we report the timings associated with the largest task.
Most of the certiÔ¨Åcation sub-scripts are prefaced with an initializa-
tion path, which affects the size of the script. Table 4 reports the
average (column Avg path ) and longest (column Max path ) initial-
ization paths for the scripts generated for parallel SCC certiÔ¨Åcation
for Ô¨Åve programs. The initialization paths for the remaining pro-
grams show a similar pattern and are not shown because of space
considerations. The reported average values are for all nine pro-
grams. Most path lengths are relatively short, and JPF-pscc can
373explore approximately 1000 transitions per second. The lengths of
initialization paths for trustful SCC certiÔ¨Åcation are similar.
4. DISCUSSION
In this section we discuss some outstanding issues of SCC, in-
cluding some of our design decisions, restrictions on the properties
that can be checked, requirements on the model checker(s) used,
scalability, and compatibility with search-space reduction techniques.
4.1 Properties
Safety properties play an important role in formal veriÔ¨Åcation
because they assert that the system stays within required bounds
and does not perform any ‚Äúwrong‚Äù actions [14]. SCC can be used
to certify invariants and program assertions, and can also check for
deadlock violations. Because the search script encodes all transi-
tions of a program‚Äôs reachability graph, SCC can also be used to
check invariants over consecutive states, such as the property
(x= 5)!next (x= 8)
which states that if the value of xis 5, then in the next state its value
will be 8. Even when certiÔ¨Åcation is parallelized, each SCC search
task is responsible for covering a set of contiguous states and all of
their outgoing transitions. Thus, every pair of consecutive states is
captured in a search script, making it possible to certify invariants
over consecutive states. In contrast, trustful SCC does not cover
all transitions, so it does not cover all pairs of consecutive states.
Thus, trustful SCC can soundly certify only state properties.
4.2 Scalability
A number of factors affect the scalability of search carrying code.
For one, SCC certiÔ¨Åcation is limited to Ô¨Ånite state programs. How-
ever, this limitation applies in general to explicit-state model check-
ing. Thus, if a program can be veriÔ¨Åed using explicit-state model
checking, then it can be veriÔ¨Åed and certiÔ¨Åed using SCC. If the
code producer uses abstractions to produce a Ô¨Ånite state space for
SCC veriÔ¨Åcation, then the certiÔ¨Åer must use the same abstractions
and must check that the abstractions preserve the properties being
proven.
Another factor is that the results of our experiments (reported
in Table 3) suggest that the beneÔ¨Åts of parallelization diminish as
we increase the number of sub-scripts we divide an SCC script
into. Our partitioning algorithm does not partition a script into sub-
scripts of exactly equal size, plus the resulting sub-scripts are pref-
aced by initialization paths of varying lengths. As such, the speed
up in certiÔ¨Åcation time is bounded by the amount of time it takes
to certify the largest sub-script. In the worst cases, when a script is
partitioned into 50 or 100 sub-scripts, the largest sub-script is 2 to
3 times the size that would be expected if the sub-scripts were truly
equal sized. We do not know whether the observed diminishing of
returns is due to the small sizes of the programs in our test suite, or
is inherent to our approach. More experiments on larger programs
are needed to answer this question.
A more serious issue is the size of the search script that the code
producer provides, likely over a network, to the code consumer.
The size of a compressed script, in number of bytes, is on the order
of the number of states in the program‚Äôs state space ‚Äì which could
be very large in the worst case, where the program‚Äôs state space is
at the limit of what can be model checked. In this paper, we assign
responsibility of partitioning the script to the code consumer, on
the assumption that she knows how many processors are available
and thus knows how many sub-scripts to create. However, in cases
where the script is large, it may be prudent for the code producer
to partition the search script. This would certainly be the case ifit turns out that there is a limit to how evenly the script can be
partitioned into sub-scripts, as discussed above.
4.3 Using Different Model Checkers
In our work, we have shown how SCC can be used when the
certiÔ¨Åer and veriÔ¨Åer use the same model checker. However, ideally,
the code consumer should be able to use a model checker of her
own choosing (adapted to use search scripts), and not be restricted
to using the same model checker as the code producer. We have
not evaluated using SCC with different model checkers, but we ex-
pect that different model checkers can be used for veriÔ¨Åcation and
certiÔ¨Åcation, as long as they satisfy certain requirements. To start,
both model checkers must be explicit-state model checkers, as SCC
does not support symbolic model checking. Second, the two model
checkers must agree on how to interpret transition statements in the
search script (e.g., they must both match a byte-code instruction
to the same instruction in the program being explored). Third, the
certiÔ¨Åer model checker must create unique Ô¨Ångerprints for distinct
states (for checking the veracity of the script), but there are no con-
straints on how this should be done.
If state-space reduction techniques are used, then the situation is
more complicated because the techniques could change the size and
shape of the reachability graph. Discussion of how SCC interacts
with state-space reduction techniques follows.
4.4 Model-Dependent Reduction Techniques
A key question of any new model checking technique is whether
and how it works in combination with existing search-reduction
techniques. We discuss model-dependent reduction techniques in
this section and property-dependent techniques in the next section.
We expect SCC to complement model-dependent reduction tech-
niques, as long as (1) the reduction techniques are applied in ad-
vance or on-the-Ô¨Çy, so that the search script encodes the reduced
reachability graph, and (2) the veriÔ¨Åer and certiÔ¨Åer model check-
ers agree on the abstractions applied. We consider only automated
reduction techniques; techniques that rely on user-input (e.g., ab-
straction functions [5]) are not safe, because a malicious code pro-
ducer could specify an unsound abstraction.
Symmetry Reduction [9] reduces the size of the state space
by exploiting symmetries among states. The idea is that states
are grouped into equivalence classes, and the model checker can
discard a state if an ‚Äúequivalent‚Äù one has been explored before.
There are a number of different techniques for identifying sym-
metries [16], but the ultimate effect is that symmetric states are
assigned the same Ô¨Ångerprint.
In SCC veriÔ¨Åcation, symmetries result in a reduced reachability
graph being explored, and a smaller search script being generated.
If the same model checker is used during SCC certiÔ¨Åcation, it iden-
tiÔ¨Åes the same symmetries, symmetric states are assigned the same
Ô¨Ångerprint, and the shape of the reduced reachability graph matches
the search script. If the code producer and consumer use different
model checkers, the checkers must implement the same reductions.
Currently, it is not realistic to expect different model checkers
to use the exact same symmetry reductions. But if model checkers
were parameterized with respect to their state-space reduction tech-
niques and algorithms, then requiring both model checkers to use
the same symmetry reductions would not be a limitation. In fact,
there has already been some work along these lines [8, 11].
Partial Order Reduction (POR) [10] is an automated path-
reduction technique that Ô¨Ånds transitions that are independent of
each other and whose interleaved executions all lead to the same
state, regardless of the order of their execution. POR executes only
one of the possible interleavings.
374During SCC veriÔ¨Åcation, the model checker detects indepen-
dent transitions, explores only one interleaving, and records only
one interleaving in the search script. The entire interleaving is
recorded as a single transition in the search script. If the same
model checker is used during SCC certiÔ¨Åcation, then the certiÔ¨Åer‚Äôs
model checker identiÔ¨Åes the same sets of independent transitions,
chooses the same interleavings (as long as decisions are determin-
istic), and disables the other interleavings. As a result, the POR
interleavings chosen during certiÔ¨Åcation match the search script.
Because a POR interleaving is treated as a single, compound
transition, it is never partitioned among different subscripts and
during certiÔ¨Åcation, an entire interleaving is assigned to a single
processor. Thus, POR does not interfere with SCC, even after par-
allelization.
If different model checkers are used for SCC veriÔ¨Åcation and
SCC certiÔ¨Åcation, they must both use the same POR heuristics
to (1) determine which transitions are independent and (2) select
which interleaving to explore; and the heuristics must be determin-
istic. It might seem unrealistic for both model checkers to use the
same heuristics, but we believe a parameterized approach to state-
space reductions, as described above, could address this limitation.
4.5 Property-SpeciÔ¨Åc Reduction Techniques
The goal of property-speciÔ¨Åc reduction techniques is to reduce
the search space (and search script) to those program states that
are relevant to the property being checked. Such reductions are
problematic for SCC because the code producer does not know in
advance which properties are of interest to the code consumer and
thus cannot apply the appropriate reductions. Moreover, the code
consumer cannot simply apply the reduction techniques herself be-
cause the resulting reduced program would no longer correspond
to the supplied search script. Such techniques can only be useful if
they can be applied to the search script rather than to the program.
Consider program slicing [28], which is a commonly used property-
speciÔ¨Åc reduction technique that reduces the size of the search space
by ignoring program statements that are not relevant for a given
property. Traditional program slicing cannot be used in conjunc-
tion with SCC for the reasons given above, but it might be possible
for the code consumer to slice the search script instead, given that
the script‚Äôs transition instructions (which are bytecodes) literally
encode the program statements. The certiÔ¨Åer model checker would
need to be able to determine from a transition instruction in the
search script whether the transition is relevant to the property being
checked. It would also need to perform a deÔ¨Ånition-use analysis on
the script, which is a much larger artifact to analyze than the orig-
inal program. Lastly, not all irrelevant transitions can be removed
from the search script because the sliced script must still be a valid
path in the program‚Äôs reachability graph.
We are still investigating the problem of script slicing. Although
it seems to be possible, it is not clear whether the resulting re-
ductions will be signiÔ¨Åcant. In general, the savings achieved by
program slicing cannot be predicted in advance, and it is possible
that slicing provides no signiÔ¨Åcant savings at all ‚Äì especially when
checking a large collection of varied properties, such as during cer-
tiÔ¨Åcation.
5. RELATED WORK
In previous work [26], we suggest using information gathered
during one model checking run to speed up subsequent runs, and
we evaluated a JFP-based prototype on six Java programs. We ex-
tend that work here by evaluating it on more and larger programs,
protecting against tampering of the search script, and parallelizing
the certiÔ¨Åcation searches.Our work is inspired by proof-carying code (PCC) [18]. Signif-
icant infrastructure is needed to support PCC, including inference
rules for reasoning about code, a formal language for expressing
safety properties and proofs, and an algorithm for checking a pro-
gram and its safety proof. Most research on PCC focuses on reduc-
ing the size of proofs [4] and generalizing the kinds of properties
that can be proved [1, 19]. In contrast, SCC-based certiÔ¨Åcation
can be implemented by making modest changes to existing model-
checking technologies. SCC search scripts are created automati-
cally, and can be decomposed into an arbitrary number of smaller
scripts. While a PCC certiÔ¨Åcate encodes the proof of particular
properties, an SCC script is independent of any properties. Thus,
the SCC script can be reused to speed-up checks of newly identiÔ¨Åed
properties.
Techniques most closely related to SCC are abstraction-carrying
code (ACC) [29] and model-carrying code (MCC) [24]. In both
cases, the program to be certiÔ¨Åed is accompanied by an abstract
model of the program. In ACC, this abstract model is an abstract
interpretation of the program. In MCC, the model is an extended
Ô¨Ånite-state automaton over the alphabet of system calls, and is syn-
thesized from the program‚Äôs execution traces. In both cases, the
abstract models are property independent. CertiÔ¨Åcation is a two-
step process: (1) certifying that the model is a faithful abstraction
of the program and (2) certifying that the model respects the desired
properties. In ACC and SCC, certiÔ¨Åcation is done ofÔ¨Çine. In MCC,
model veracity is checked at runtime by monitoring the program,
which incurs a performance penalty of 2% to 30% [24]. ACC and
MCC support richer property languages (e.g., temporal logic) than
SCC does. In addition, ACC and MCC can accommodate inÔ¨Ånite-
state programs. However, ACC and MCC models are conservative
abstractions, which means that they are susceptible to spurious er-
rors. Worse, an MCC model may be unsound if it is synthesized
from a deÔ¨Åcient set of traces. In contrast, an SCC script results in a
sound and complete search of the state space. Importantly, it is not
known whether ACC or MCC can be parallelized.
Lauterburg et al. [15] propose a technique to support incremen-
tal state-space exploration that is based on storing information re-
garding the entire reachability graph. They use the information to
speed up the model checking of subsequent versions of the same
program‚Äìa task that is comparable to our SCC certiÔ¨Åcation. The
maximum reported speed up is a factor of approximately two, and
their technique has not been parallelized.
Early work on parallel model checking tried to speed up the pro-
cess of Ô¨Ånding errors by distributing the model-checking search
among multiple workstations on a network (distributed memory).
The challenge was to distribute the workload evenly among the par-
allel processors. Stern and Dill [25] parallelized Mur ', an explicit-
state veriÔ¨Åer, by pre-assigning states to processors based on a hash
of the Ô¨Ångerprint. However, this approach could result in an im-
balance in workload among the processors. Moreover, substantial
state information must be passed between processors whenever a
new state is discovered and must be transferred to its assigned pro-
cessor. Subsequent works by others investigate how to improve
local and global load balancing [3, 13] and reduce communication
overhead [20].
On a shared memory architecture, communication among pro-
cessors is negligible, but the processors must synchronize their ac-
cess to shared variables, such as when they deposit states into each
other‚Äôs worklist or access a shared hash-table of state Ô¨Ångerprints.
Thus, there is the extra challenge of keeping processors utilized
and not waiting too long to access shared resources. Interestingly,
some researchers report [2, 12] that, beyond an optimal number of
processors, the search time starts to increase with the number of
375additional processors because the synchronization overhead dom-
inates any beneÔ¨Åt from parallelization. Parallelized SCC does not
suffer from this overhead because the reachability graph is parti-
tioned in advance in such a way that no communication or syn-
chronization among processors is necessary. Each processor works
independently of others, and shares information with an adminis-
trator process (which collects and compares Ô¨Ångerprint maps) only
at the end of its search task.
6. CONCLUSION AND FUTURE WORK
We have proposed search carrying code (SCC) as a technique
to certify software that was previously veriÔ¨Åed by software model
checking. We have shown that SCC certiÔ¨Åcation can determine if
the provided search script (i.e., the program‚Äôs certiÔ¨Åcate ) is not a
faithful representation of the program‚Äôs state space, and that SCC
certiÔ¨Åcation can be parallelized to speed up the certiÔ¨Åcation task.
In the special case where the source of a program is trusted, we
show how SCC certiÔ¨Åcation can be further optimized by searching
a spanning-tree representation of the program‚Äôs reachability graph
and eliminating data structures and checks on the search script.
In the future, we would like to continue to address limitations
of SCC. Our current focus is on alternative representations and en-
codings of the information in the search script in order to reduce its
size. We are also investigating in more detail how SCC can be used
in combination with various search reduction techniques. Finally,
we would like to evaluate SCC on industrial-sized programs.
Acknowledgments - We would like to thank Peter Mehlitz and
Willem Visser for helping us understand Java PathÔ¨Ånder. We would
also like to thank the reviewers for their insightful comments that
helped to improve this paper.
7. REFERENCES
[1] A. Ahmed, A. W. Appel, C. D. Richards, K. N. Swadi,
G. Tan, and D. C. Wang. Semantic foundations for typed
assembly languages. ACM Trans. Program. Lang. Syst. ,
32(3):1‚Äì67, 2010.
[2] J. Barnat, L. Brim, and P. Rockai. Scalable multi-core LTL
model-checking. In SPIN , pages 187‚Äì203, 2007.
[3] J. Barnat and P. Ro Àáckai. Shared hash tables in parallel model
checking. Elect. Notes Theor. Comp. Sci. , 198(1):79‚Äì91,
2008.
[4] F. Besson, T. Jensen, and T. Turpin. Small witnesses for
abstract interpretation-based proofs. In Proceedings of the
16th European conference on Programming , pages 268‚Äì283,
2007.
[5] P. Cousot and R. Cousot. Abstract interpretation: a uniÔ¨Åed
lattice model for static analysis of programs by construction
or approximation of Ô¨Åxpoints. In Proc. of Princ. of Prog.
Lang. , pages 238‚Äì252, 1977.
[6] D. Davies. http://ddavies.home.att.net/NewSimulator.html.
[7] M. B. Dwyer, J. Hatcliff, M. Hoosier, V . Ranganath, and
T. Wallentine. Evaluating the effectiveness of slicing for
model reduction of concurrent object-oriented programs. In
Proc. of the Conf. on Tools and Algorithms for the
Construction and Analysis of Systems , pages 73‚Äì89, 2006.
[8] M. B. Dwyer, J. Hatcliff, R. Joehanes, S. Laubach, C. S.
PÀòasÀòareanu, H. Zheng, and W. Visser. Tool-supported program
abstraction for Ô¨Ånite-state veriÔ¨Åcation. In Proc. of Int. Conf.
on Software Engineering , pages 177‚Äì187, 2001.
[9] E. A. Emerson and A. P. Sistla. Symmetry and modelchecking. Form. Meth. System Design , 9(1-2):105‚Äì131,
1996.
[10] P. Godefroid. Partial-order methods for the veriÔ¨Åcation of
concurrent systems: An approach to the state-explosion
problem. In Lecture Notes in Computer Science , volume
1032, 1996.
[11] J. Hatcliff, M. B. Dwyer, C. S. P ÀòasÀòareanu, and Robby.
Foundations of the bandera abstraction tools. In The essence
of computation: complexity, analysis, transformation , pages
172‚Äì203, 2002.
[12] C. P. Inggs and H. Barringer. Ctl* model checking on a
shared-memory architecture. Form. Methods Syst. Des. ,
29(2):135‚Äì155, 2006.
[13] R. Kumar and E. Mercer. Load balancing parallel explicit
state model checking. In Workshop on Parallel and
Distributed Methods in VeriÔ¨Åcation , pages 19‚Äì34, 2005.
[14] O. Kupferman and M. Y . Vardi. Model checking of safety
properties. Form. Methods Syst. Des. , 19(3):291‚Äì314, 2001.
[15] S. Lauterburg, A. Sobeih, D. Marinov, and M. Viswanathan.
Incremental state-space exploration for programs with
dynamically allocated data. In Proc. of 30th Int. Conf. on
Software Engineering , pages 291‚Äì300, 2008.
[16] A. Miller, A. Donaldson, and M. Calder. Symmetry in
temporal logic model checking. ACM Comp. Surv. , 38(3),
2006.
[17] Nasa. Java pathÔ¨Ånder, version 4. In
http://javapathÔ¨Ånder.sourceforge.net , 2007.
[18] G. C. Necula. Proof-carrying code. In Symp. on Prin. of
Programming Languages , pages 106‚Äì119, 1997.
[19] Z. Ni and Z. Shao. CertiÔ¨Åed assembly programming with
embedded code pointers. In 33rd ACM SIGPLAN-SIGACT
Symp. on Principles of Prog. Languages , pages 320‚Äì333,
2006.
[20] D. M. Nicol and G. Ciardo. Automated parallelization of
discrete state-space generation. Journal Parallel Distributed
Computing , 47(2):153‚Äì167, 1997.
[21] D. Park, U. Stern, and D. Dill.
http://verify.stanford.edu/uli/icse/workshop.html.
[22] PKZIP. Zip, 1989.
[23] Santos Laboratory. http://www.cis.ksu.edu/santos/case-
studies/counterexample_case_study.
[24] R. Sekar, V . N. Venkatakrishnan, S. Basu, S. Bhatkar, and
D. C. Duvarney. Model-carrying code: a practical approach
for safe execution of untrusted applications. In Proc. of 19th
Symp. on Operating Sys. Principles , pages 15‚Äì28, 2003.
[25] U. Stern and D. L. Dill. Parallelizing the Mur 'veriÔ¨Åer. In
Proc. of the Conf. on Computer Aided VeriÔ¨Åcation 97 ,
volume 1254, pages 256‚Äì267, 1997.
[26] A. Taleghani. Using software model checking for software
component certiÔ¨Åcation. In Companion Proc. of ACM/IEEE
Int. Conf. on Soft. Eng. , pages 99‚Äì100, 2007.
[27] W. Visser, G. Brat, K. Havelund, and S. Park. Model
checking programs. In Proc. of Int. Conf. on Automated
Software Engineering , pages 3‚Äì12, 2000.
[28] M. Weiser. Program slicing. In Proc. of Int. Conf. on
Software Engineering , pages 439‚Äì449, 1981.
[29] S. Xia and J. Hook. Certifying temporal properties for
compiled C programs. In Proc. of the Conf. on Verif., Model
Check., and Abstr. Interpret. , pages 161‚Äì174, 2004.
376