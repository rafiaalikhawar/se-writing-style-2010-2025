Reuse-Oriented Reverse Engineering of Functional
Components from X86 Binaries
Dohyeong Kim1William N. Sumner2Xiangyu Zhang1Dongyan Xu1Hira Agrawal3
1Department of Computer Science, Purdue University, USA
2School of Computing Science, Simon Fraser University, Canada
3Applied Communication Sciences, USA
1{kim1051,xyzhang,dxu}@cs.purdue.edu2wsumner@sfu.ca
3hagrawal@appcommsci.com
ABSTRACT
Locating, extracting, and reusing the implementation of a
feature within an existing binary program is challenging.
This paper proposes a novel algorithm to identify modular
functions corresponding to such features and to provide us-
able interfaces for the extracted functions. We provide a
way to represent a desired feature with two executions that
both execute the feature but with dierent inputs. Instead of
reverse engineering the interface of a function, we wrap the
existing interface and provide a simpler and more intuitive
interface for the function through concretization and redirec-
tion. Experiments show that our technique can be applied to
extract varied features from several real world applications
including a malicious application.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement| Restructuring, reverse engineering, and
reengineering ; D.2.13 [ Software Engineering ]: Reusable
Software
General Terms
Algorithms
Keywords
Feature Extraction, Reverse Engineering, Dynamic Analysis
1. INTRODUCTION
Developers have long struggled with the desire to reuse
previously implemented features within new code. By reusing
an old implementation, developers can avoid creating new
bugs and can create easier to maintain programs [32, 26,
19, 8]. Implementation reuse can also be crucial when a
new program must replicate features within a legacy sys-
tem, but the specication for the legacy system no longer
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
ICSE â€™14, May 31 - June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/06 ...$15.00.exists. Driven by this desire to reuse existing implementa-
tions, previous research has delved into techniques for both
locating the implementation of a feature within a body of
source code [40, 41, 8, 10, 15, 33, 9, 38, 35, 13, 6, 14, 16] and
extracting that source implementation into a conveniently
reusable function [26, 23, 17, 18, 31, 25, 10].
These techniques generally assume the availability of the
original source code, but in practice the source code itself may
no longer be available or may no longer even exist. Indeed,
facing the maintenance of legacy programs without source
code, DARPA recently called for a solution to this exact
problem [3]. For example, some components are provided to
developers only in the binary form, and the source of these
programs or libraries may not be available due to intellectual
property restrictions [36]. In other cases, companies may have
existing programs that implement de facto specications, but
both the original source code and any documentation of the
specications have been lost over time [3]. Finally, when
reverse engineering the behavior of a foreign program, a
program from a third party, security researchers sometimes
wish to extract certain features, such as encoding/decoding
routines [22] or anti-debugger techniques [20] from a foreign
program in binary form. Reusing these features from foreign
binaries allows the security analysts to gain insight into the
behavior of malicious code and potentially develop defensive
techniques [22]. In each of these scenarios, a developer needs
to locate and extract the existing implementation of a feature
that exists only in binary form within an existing program.
Although source code provides rich information about the
behavior and structure of a program, much of this information
is stripped away when the program is compiled to a binary
form.Thus, techniques for locating and extracting features
that rely on source code analysis and manipulation no longer
apply.
New solutions must be found for both locating and ex-
tracting features. Prior work on locating a desired feature
includes techniques built on statement coverage informa-
tion [41] and dynamic slicing techniques [43]. While both
of these techniques apply to both source code and binaries,
they may both locate features too coarsely, including more
of the original implementation than is necessary or desirable.
Dynamic slicing techniques compute transitive closures over
the dynamic dependence graph of an execution [24, 5, 46].
These closures are known to be large in practice [45]. State-
ment coverage techniques contrast the statements performed
within an execution that exhibits a desired feature against
those performed in an execution that does not exhibit thePermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSEâ€™14 , May 31 â€“ June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568296
1128
feature. The intuition is that statements executed only, or
more frequently, within the execution exhibiting the feature
should implement the feature itself. We observe and later
show that such approaches can be too coarse grained and
identify portions of the original implementation that are
unnecessary for implementing the feature.
Once the functions implementing a feature have been iden-
tied, they may be extracted from the original binary, but
extraction alone is insucient. To reuse the extracted com-
ponent, we must provide an interface through which it may
be invoked, but even state of the art binary analysis tools
have diculty reverse engineering such interfaces. We show
that the original interface for a component can also involve
complex heap structures, and the parameters that correspond
to a feature of interest may be deeply embedded within these
heap structures and subject to subtle constraints. Developers
should not need to deal with such complexities when reusing
an extracted component.
In this paper, we propose a novel approach to locating
modular functions that correspond to a desired feature and
providing a usable interface for the extracted component. We
describe the desired feature through multiple executions that
use the feature. The user executes the feature twice with
dierent inputs, and our technique semantically contrasts the
executions to discover where the dierent input values are
used and which part of the code produces the desired output
from the input. Our technique then isolates the feature
using concretization to replace the original parameters of
the function with values from a real run. Finally, it wraps
the original interface of the binary with a new and simpler
interface for the developer to invoke and then uses redirection
to ensure that the parameters of the new interface are used
consistently throughout the extracted function.
Our main contributions are highlighted as follows.
We provide a way to precisely represent a desired fea-
ture using multiple executions that exhibit the feature.
Providing these executions is intuitive to a user who
knows how to use the existing binary.
We perform a semantic comparison of the provided
executions using dual slicing [39]. This allows us to
precisely locate the desired feature within the code.
We propose a technique called interface casting that
uses concretization to isolate desired parameters for a
function. It then wraps an extracted binary feature
with an adapter and exploits redirection to use the
parameters of the adapter. This provides the developer
a convenient means of invoking the extracted feature.
We implement and evaluate a prototype of the approach.
We apply our technique to 8 applications and extract
10 reusable components from the binaries. We show
that even when there are originally no parameters to
the extracted functions, our technique still applies.
2. MOTIVATING EXAMPLE
Suppose a developer desires to extract and reuse the email
sending feature of pine, an email client. Because pine has
many diverse email features, this reuser must rst locate
the function that contains the desired feature. To reuse the
function, they must also uncover the function's interface or
prototype. Knowing the interface, they can provide parame-
ters such as the sender address, recipient, subject, and body
for a sent email. In this section, we show how to locate thedesired function by using dual slicing. We then show how
to extract the function into an isolated component with a
reusable interface by using concretization and redirection.
2.1 Function Location
Before extraction, we must locate the function responsible
for sending an email. To nd the function, we contrast two
dierent executions of pine, each of which sends a dierent
email. We follow the same steps both times, except that the
sender addresses, recipients, subjects, and bodies of the sent
emails dier. Thus, we choose the same menu items in the
same order, and we provide the same sequence of key strokes
except for the four parameters of interest. As a result, the
two executions follow the same paths through the program
except for dierences related to the diering user input.
Dual slicing is a technique that contrasts two executions
and identies only those instructions that both behave dif-
ferently across the two executions and contribute to their
dierent outputs. Intuitively, the user inputs for the two
executions of pine dier only with respect to the emails sent,
so the two executions should mainly dier in the portion
of code that is responsible for processing and sending the
dierent emails. Thus, the dierences identied by the dual
slice should be the behaviors of pine that we wish to extract.
Next, our technique nd the function that encloses all of
the relevant dierences between the two executions. Fig. 1
shows the part of the dynamic call tree containing the dual
slice. Each node represents a function and each arrow repre-
sents a caller-callee relationship between functions. Shaded
nodes represent those functions containing the relevant in-
structions within the dual slice. The topmost shaded function
iscall_mailer() , and it transitively calls all other shaded func-
tions. Since the shaded functions are necessary for the mail
sending component, we identify call_mailer() and its callees
as the components of pine to extract.
pine rfc822 headerpost rfc822 outputcallmailer
sstrncpycompose mail
smtp mail
pine rfc822 output body
pine header linepine send
rfc822 output full
foldpine rfc822 outputmain
Figure 1: Dual slice of the mail sending feature in
pine. Shaded nodes show the dual slice within the
call tree.
2.2 Interface Casting
We must next extract call_mailer() and provide it with a
usable interface. The new interface is particularly important
because the original interface is complex and does not match
the expectations of reuser.
Suppose that we tried to invoke the extracted function
directly. Fig. 2 presents the original interface of call_mailer() .1129struct BODY {
PARTTEXT contents; /* body part contents */
union{ /* different ways of accessing contents */
PART *part; /* body part list */
MESSAGE *msg; /* body encapsulated message */
} nested;
...
};
struct PART {
BODY body; /* body information for this part */
PART *next; /* next body part */
};
struct MESSAGE {
BODY *body; /* message body */
PARTTEXT text /* body text */
...
};
struct PARTTEXT {
unsigned long offset; /* offset from body origin */
struct {
unsigned char *data; /* text */
unsigned long size; /* size of text in octets */
} text;
}
int
call_mailer(METAENV *header, BODY *body,
char**alt_smtp_servers, intflags,
void(*bigresult_f)( char*,int),
void(*pipecb_f)(PIPE_S *, int,void*))
Figure 2: Interface of call_mailer()
The function has 6 parameters. The rst and the second
arguments are pointers to internal data structures, and we
would need to reverse engineer those data structures to reuse
the original interface. In particular, the body of an email
is stored in body->contents.text.data and the size of the body
is stored in body->contents.text.size . To specify the body, we
would rst need to allocate memory regions for the BODY
structure and its child data structures, e.g. PARTandMESSAGE ,
and specify correct values for both dataandsize. This also
requires understanding the semantic relationship between
dataandsize. To reuse call_mailer() , we would further need
to correctly initialize the entire data structure and identify
the semantics of each eld even if the eld is unrelated to the
four parameters we want to provide . In fact, there is even
more complexity, as email contents may be specied in two
dierent ways: one through the contents eld of BODYand the
other through a further nested eld of BODY. Expecting the
reuser to manage this complexity on their own is unrealistic.
To provide a usable interface for the function, we must
simplify away the unnecessary parameters and introduce
new parameters matching the reuser's intentions. We call
this process interface casting . To simplify existing param-
eters, our technique rst statically concretizes those values
generated outside call_mailer() and used inside call_mailer() .
Thus, if call_mailer() is invoked by the reuser, the parameter
bigresult_f does not actually take a variable argument. In-
stead, we provide it a concrete value observed in one of the
original executions. We concretize not only the values of all
function parameters but any memory values dened outside
call_mailer() . By concretizing all of the direct and indirect
inputs, we hermetically seal the function of interest. That is,
by providing concrete values for all inputs of a function, we
ensure that it behaves the same way every time.
To provide the parameters desired by the reuser, our tech-
nique then relaxes this seal to allow only the chosen param-
eters to again aect the function's behavior. We redirect
accesses of the original inputs to use memory locations for the
new parameters provided by an interface that we construct.
Since we already concretize the parameters and memoryvalues, the location for a parameter is statically xed. For
example, the value of the parameter bodymay be concretized
to0x0408CC00 , and the subject of an email may be con-
cretized to 0x0409DB00 . Thus, the program will always read
the email subject from the same location in memory, and we
can redirect accesses of that memory location to use a new
memory location that contains a new subject string.
Before we can relax and redirect accesses of inputs, we must
rst allow the reuser to determine just which data should
be parameters for the extracted function. Once again, the
reuser can use dual slicing to provide this information. Recall
that in the function identication phase we contrasted two
executions with all desired parameters changed to identify
the code to extract. In contrast, to identify the instructions
that read each input, we need only change one input at a
time. This way the dual slice between the original execution
and the execution with one diering input will capture only
those instructions processing the changed input.
Once we identify all desired parameters of call_mailer() and
create a new interface using concretization and redirection,
we can simply extract the function from its original binary
by using binary rewriting tools[11]. The new interface we
provide acts as a wrapper that invokes this binary function,
allowing the reuser to call it like any other library function.
3. THE REUSE PROCESS
In this section we discuss the details of reusing functions
from binary code. We present algorithms for both locating
the function that contains a feature through dual slicing and
for providing a reusable interface through concretization and
redirection.
3.1 Component Location
We rst present background information on dual slicing
to clarify details of our approach for locating components
within a binary. We then explore our algorithms for locating
components and why they can localize a component to a
more concise portion of code than existing techniques.
Dual slicing. Dual slicing is a slicing technique that con-
trasts two executions and produces a slice containing only
those dierences between the two executions that are re-
sponsible for some observably dierent behavior [39]. Alg. 1
presents the core algorithm. Given a slice criterion (e1;e2)
that identies some output dierences across the two execu-
tions, the algorithm computes a set of dynamic dependences
from both executions. (e1;e2)denotes that two execution
points e1and e2, in the rst and the second executions re-
spectively, align or correspond across the executions [44].
(e1;?)denotes that there is no execution point in the second
execution that aligns with e1in the rst execution.
The algorithm rst ensures that the slice criterion exists
in the rst execution. Lines 2-6 process data dependences
at the slice criterion. Here, f(e1;e2) !(e0
1;e0
2)gdenotes
that e1has a data dependence upon e0
1in the rst execution,
e2has a data dependence upon e0
2in the second execution,
and e0
1aligns with e0
2.e0
2can be?when e0
1does not align
with any point in the second execution or e2is not data
dependent on the alignment of e0
1. On line 3, if the data
dependence exists only in the rst execution or if the values
of two data dependences dier, the data dependence is added
to the dual slice. The algorithm proceeds to include the dual
slice from ( e0
1;e0
2) recursively, similar to traditional dynamic
slicing. Lines 7-10 process the control dependence of the slice1130criterion, denoted as =). Similar to the data dependence,
if the control dependence exists only in the rst execution
or the branch outcomes dier, the control dependence and
the recursive dual slice of the control dependence are added
to the dual slice. So far, the algorithm considers only data
dependences and control dependences when e1is not null.
Lines 12-14 compute the dual slice when e2is not null.
Algorithm 1 Dual Slicing
Input: e1;e2- slice criteria
Output:D- the dual slice, a set of deps in either execution
dualSlice (e1;e2)
1:ife16=?then
2:for all data dep dd f(e1;e2) !(e0
1;e0
2)gdo
3: ife0
2? or values at e0
1and e0
2dier then
4:D D[ dd[dualSlice (e0
1;e0
2)
5: end if
6:end for
7: control dep cd f(e1;e2) =)(e0
1;e0
2)g
8:ife0
2? or branch outcomes at e0
1and e0
2dier
then
9:D D[ cd[dualSlice (e0
1;e0
2)
10: end if
11:end if
12:ife26=?then
13: /* operations symmetric to when e16=?*/
14:end if
15:returnD
Component location using dual slicing. To use dual
slicing to identify the component that corresponds to the
desired feature, we use two executions that each exercise the
desired feature but that use dierent inputs. For example,
in thepine case study, we send an email in both executions,
but the emails have dierent recipients, subjects, and bodies.
The resulting dual slice contains only those instructions that
process the input because all the execution dierences origi-
nate from the diering inputs. The slice also includes only
instructions that help produce the desired output because
slicing excludes instructions unrelated to the output.
Alg. 2 presents the component identication algorithm.
The algorithm requires two executions, E1andE2, which
exercise the same feature but with dierent inputs. Lines 1
and 2 choose the output corresponding to the desired feature
as the slice criterion. In the pine example, we use the
network packet containing the composed email as the slice
criterion. Line 3 computes the dual slice, and line 4 trims o
a prex of the slice that only moves the arguments around
without using them for any computation. Line 5 locates the
function that contains this trimmed dual slice. It chooses the
closest common ancestor function in the dynamic call tree of
those functions whose instructions reside in this dual slice.
Line 6 further selects this common ancestor as well as all
functions that it transitively called in E1andE2as targets
of extraction. In other words, the identied components
comprise nodes of the dynamic call tree with the identied
common ancestor function as their root.
Suppose that we wish to identify the function containing
the `email sending' functionality of the sample program in
Fig. 3 that models pine.load_config() rst initializes global
variables that will be used in pine_send() .menu() waits for an
input from a user with timer of 1 second. If the timer expires,Algorithm 2 Component Location
Input : a pair of executions E1andE2with both exercising
the target functionality but with dierent inputs.
identification (E1,E2)
1:(O1,O2) = outputs corresponding to the desired feature
inE1andE2, resp.
2:(e1,e2) = execution points that emit O1andO2, resp.
3:dse=dualSlice (e1,e2)
4:tse=trim (dse)
5:func = the modular function that encloses tse
6:extract =func and all user functions directly/indirectly
called by func
7:return extract
menu() performs background tasks. If the user instead selects
the send menu option, pine_send() callseditor() to edit the
recipient, subject, and body of an email. Later call_mailer()
composes an email with the information from editor() and
sends it to an SMTP server. In this example, call_mailer() has
the email sending functionality since editor() only stores the
user input into a buer and does not apply any calculation
or transformation to the given inputs.
To get two execution traces for dual slicing, we run the
program twice with dierent recipients, subjects, and body
texts. We run the program in exactly the same way the
second time except for those inputs. Those three parameters
are all that we want our extracted component to require, and
we want to use the same values for other congurations such
as the SMTP server address and sender address.
Fig. 4a and Fig. 4b present the resulting traces. Line 43 is
the slice criterion because it sends the packet containing the
email to the SMTP server. The dual slice includes that line
because the sent packets dier in the two executions. Line 43
further depends on lines 42, 36, 37, and 38. Line 42 uses
the same value of smtp_server in both executions, so the dual
slice excludes it. Because lines 36, 37, and 38 produce value
dierences, the dual slice includes them. Also, line 43 is
(directly or transitively) control dependent upon lines 12, 14,
16, and 18, but those lines do not reect dierences across
the two executions, so the dual slice excludes them.
The dual slice shows that lines 36, 37, 38, and 43 are
important for the mail sending functionality. Note, however,
that lines 36, 37, and 38 simply copy the input to a buer.
Because they only move the input around and do not make
decisions or perform computations with it, these lines form
anirrelevant prex of the desired behavior. They reect
preparatory bookkeeping work rather than behavior of the
desired component itself. We can thus omit them entirely
and still locate the functions containing the behavior we wish
to extract. The trim function removes such instructions
from the front of the dual slice up until the rst decisions or
computations with inputs that dier across the executions.
In practice, this localizes the component to a smaller portion
of code. In our example, the only remaining instruction is
line 43, so the technique identies that the email sending
feature is located within call_mailer() .
Coverage based approaches. Prior work on feature loca-
tion computed the dierence in statement coverage between
two executions: one sending an email and the other not
sending the email [41]. This coverage based comparison can
identify more functions than we desire because the reuser113112 while(true) {
13 c = select(stdin, t);
14 if(c == t)
16 else if (c == stdin)
17 command = read(stdin);
18 if(command == SEND) {
19 pine_send();
28 pine_send() {
31 editor(&env, &body);
35 editor(ENVELOPE* env, BODY* body) {
36 env->recipient = read(stdin);
37 env->subject = read(stdin);
38 body->text = read(stdin);
39 }
32 call_mailer(smtp_server, env, body);
41 call_mailer(...) {
42 s = connect(smtp_server);
43 send_to(s, ... );
46 }
33 }
20 log("send_mail");stdin
SEND
"recipient1"
"subject1"
"body1"
(a) execution 1stdin
SEND
"recipient2"
"subject2"
"body2"12 while(true) {
13 c = select(stdin, t);
14 if(c == t)
16 else if (c == stdin)
17 command = read(stdin);
18 if(command == SEND) {
19 pine_send();
28 pine_send() {
31 editor(&env, &body);
35 editor(ENVELOPE* env, BODY* body) {
36 env->recipient = read(stdin);
37 env->subject = read(stdin);
38 body->text = read(stdin);
39 }
32 call_mailer(smtp_server, env, body);
41 call_mailer(...) {
42 s = connect(smtp_server);
43 send_to(s, ... );
46 }
33 }
20 log("send_mail");
(b) execution 2
Figure 4: Dual slice of the simplied pine example from Fig. 3.
cannot control the program's behavior at a ne-grained level.
That is, a small behavioral dierence to the user may cor-
respond to many dierences in terms of which functions a
program executes, only a few of which may be interesting.
Consider xv, an image viewer that can convert one image
format to another. Suppose our target functionality is con-
verting a BMP format image to JPEG format. To compute
the coverage dierence, we load the same le in both execu-
tions. We convert the le into JPEG format in one execution
but cancel the conversion in the other. Fig. 5a presents the
coverage comparison results. The results show a large call
graph with many functions related to processing the user
interface and handling user input such as mouse clicks in addi-
tion to the important function, writeJPEG() . Furthermore, the
approach misses the function LoadBMP() , which is responsible
for loading a BMP image. In contrast, dual slicing computes
a concise set of functions for the conversion and identies
LoadBMP() as well. Fig. 5b shows the dual slice, which high-
lights only the important functions: writeJPEG() andLoadBMP() .
We later discuss pruning the extracted component to contain
only these two functions and their callees.
The simple coverage dierence includes many non-essential
functions because the reuser cannot control every detail
of program behavior by enabling and disabling the target
feature. Hence, in this paper we use dual slicing[39] to focus
more concisely on the interesting dierences.
3.2 Interface Casting
Once we have located the function the reuser wishes to
extract, we must take the potentially complicated interface
of that original function and compose a simpler alternative
interface with only the reuser's desired parameters. Our
approach to this problem is to rst concretizing all of the
values that feed into the selected function to hermetically
seal and isolate the function's behavior. This makes the
function behave the same way every time it executes. Our
technique then relaxes this seal for only the reuser's desired
inputs by redirecting accesses of the original inputs so that
they instead access inputs of a freshly constructed interface.
Alg. 3 presents an overview of the interface casting pro-
cess. The algorithm takes three parameters: (1) the code to
extract, a result of the component identication algorithm,
(2) an execution Ethat exercises the desired feature, and(3) one additional execution for each parameter we wish to
specify. In the pine case study, if we wished to specify the
recipient, subject, and body of an email, we would need three
additional executions. One would send an email with the
same subject and body as execution Ebut with a dierent
recipient. Another would send the email with a dierent
subject. The last would send the email with a dierent body.
These additional executions identify those instructions that
access each of the dierent specied parameters.
Algorithm 3 Interface Casting
Input :extract denotes the code to extract, which is identied
in the previous section; an execution Eexercising the target
functionality; a list Sof pairs ( Ei; Ti) with Eithe same as E
except that Eihas a dierent value for the ith input (with
typeTi) intended by the user.
interfaceCasting (extract ,E,S)
1:extdep= instruction instances in Ethat are part of
extract and have external dependences
/* Seal off all external dependences */
2:concretize (extract ,extdep)
/* Patch to allow reuser specified inputs */
3:for each (Ei,Ti)2Sdo
4: (e,ei)= instruction instances emitting the feature
related output in EandEi, resp.
5: di=E's instruction instances in dualSlice (e,ei)
6: if= instruction instances in di\extdep
7:redirect (extract ,if,Ti)
8:end for
Line 1 computes the set of instruction instances with ex-
ternal dependences. If an instruction reads a value from
memory that was written outside the modular component,
it is an external dependence. Since the selected component
does not create values for external dependences, they must
be provided for the component to execute correctly. Line 2
concretizes all external memory dependences to seal the be-
havior of the function. This replaces values of accesses with
those observed in E. Extracting the function at this point
would create a new function with no arguments that behaves
as in Eevery time it is called. The loop in lines 3-8 consid-
ers each parameter specied by the reuser and identies all11321main() {
2load_config();
3menu();
4}
5
6load_config() {
7smtp_server = x.x.x.x;
8}
9
10menu() {
11t = timer(1);
12 while(true) {
13 c = select(stdin, t);
14 if(c == t) // timer expired
15 do_something();
16 else if (c == stdin) {
17 command = read(stdin);
18 if(command == SEND) {
19 pine_send();
20 log("send mail");
21 }
22 else if (command == CANCEL)
23 continue ;
24 }
25}
26}
27
28pine_send() {
29ENVELOPE env;
30BODY body;
31editor(&env, &body);
32call_mailer(smtp_server, env, body);
33}
34
35editor(ENVELOPE* env, BODY* body) {
36env->recipient = read();
37env->subject = read();
38body->text = read();
39}
40
41call_mailer( char* server, ENVELOPE* e, BODY* b) {
42s = connect(server);
43send_to(s,
44 compose_mail(e->recipient,
45 e->subject, b->text));
46}
Figure 3: A program modeling `email sending' in pine.
instructions with external dependences upon each parameter.
The loop redirects those accesses to instead use new memory
locations that hold the values of the parameters within a
wrapper function that matches the reuser's demands.
Concretization. To seal the function and remove undesired
inputs from the interface, we concretize the values of those
inputs by monitoring memory accesses. For example, in
Fig. 2, call_mailer() has a variable alt_smtp_servers that holds
alternative SMTP server addresses. We do not want the
function we extract to expose this complex behavior to the
reuser. To provide an interface without this parameter,
we concretize the value of the parameter, so alt_smtp_servers
always holds the same value in the extracted version of the
function. Note that if the reuser intends the SMTP server to
be an input of the extracted component, he/she could simply
provide an additional execution that diers from the original
execution only at the SMTP server address.
Alg. 4 explains the concretization process. Lines 1-5 pro-
cess the instructions with external dependences. By the
denition of an external dependence, we can assume that
the instruction iwill have the form MOVr2, [r1]because
it reads external memory. Lines 3-4 replace the original
instruction with (1) a guard to see if the dynamic instance
of the instruction uses external memory and (2) new MOV
instructions to redirect the memory access to a saved value if
so. Lines 6-13 process the instructions that write to externalLoadBMP
computeScrlVals
Draw3dRectSetDirSaveMode
drawSelRedrawDirWopenFirstPic CreatePSD
SCChangeHandleEvent
DRedrawxvbcopy
BTSetActiveHandleDispModemain
EventLoop
HaveSelection ChangedCtrlListCtrlBoxLSCreate
MBRedrawsetFName
MBTrackChangeCmapMode LSChangeData
CBSetActive
SetTextCursorCreateTextWins
LoadCurrentDirectorySet824Menus
BTRedrawMBClick
DSetValCreateDirWmainLoop
SetBrowseCursorCreateCtrl
CreateBrowse
DrawCtrlNumFiles
CBRedrawCenterMapWindow ScrollToCurrentGenerateEpic
SCSetValMBSelect
ls3dNewCMap
setcursorsscrollToFileName
DSetRangeresizeText
DimRectdimDialChangeCommentText resizeBrowse
SetCursorsBTTrackClickCtrl SCCreate
DSetActive
HDRedraw RedrawNList DrawCtrlStrDCreateJPEGDialog
showFName
ULineStringReadPicFile
RedrawDNamWJPEGCheckEvent
clickJDSCSetRange
LSRedrawAllocColorsNewPicGetColors
ActivePrevNext
writeJPEGhmap2dialsWaitCursorhandleButtonEvent
drawTextWCreateGam
drawJDSetHSVmode
RedrawCtrl
drawThumbLSNewData
RedrawCMapCreateJPEGW
DrawStringGetISTRchangeSux
doCmdKillOldPics
drawArrowClickDirW
SetDirFNameopenPic
RedrawDList
drawButtDirBox
CenterStringDoSave
SCRedraw
drawValStr
(a) Coverage dierence between converting BMP to JPEG and
not converting BMP to JPEG. Shaded nodes are the functions
executed only when converting BMP to JPEG and the lone black
node is writeJPEG , which is important for the conversion.
encode oneblock jpeg fdct islowEventLoop
ush bits
jcopy sample rowswrite letrailer nish pass master
grayscale convertjpeg nish compressmainLoop
HandleEvent
compress data
emit bitsfullsize downsampleencode mcu hudoCmdmain
expand bottom edgeJPEGCheckEvent
process data simple mainclickJD
sepdownsample emit bytewriteJFIF
jpeg write scanlines
nish pass huhandleButtonEvent
preprocess data
expand right edgeforward DCTemit markeropenFirstPic
openPic
ReadPicFile
loadBMP24 getintLoadBMP
writeJPEG
(b) The result of dual slicing. The call graph is concise and
highlights only two functions, LoadBMP() andwriteJPEG() .
Figure 5: Call graph from xvcase study
memory. In other words, such an instruction writes a value
to some location in memory allocated outside the identied
function in the original execution E, implying that the ad-
dress is invalid in the extracted binary. Thus, we rst map
the observed memory address of the access into the address
of a new variable that we create within the data section of
the extracted binary on lines 9-10. Line 12, similar to the
read case, replaces the instruction to use this new mapped
address instead of the original one.
Redirection. In order to redirect parameters, we rst iden-
tify the parameters using dual slicing. The approach is
similar to the one used for locating the desired function.
For each parameter, we use two inputs that dier only with
respect to that parameter. For example, we may use two in-
puts that have dierent recipients to identify the instructions
responsible for the recipient parameter.
After our technique identies these parameter providing
instructions, it redirects the memory accesses in the instruc-
tions to new locations. When an instruction reads a parame-
ter from memory, it instead redirects the memory access to
a new variable or buer prepared to hold the parameter.
Alg. 5 presents the redirection algorithm. Line 1 adds a new
variable to the data section of the binary. This new variable
will hold the input for the extracted version of the function,
so accesses of the original data must be redirected to this
new variable. We break the inputs down into two dierent
categories during the process: (1) scalar variables, which are
always accessed through their starting address, and (2) buer
variables, which have many internal addresses that may be
accessed independently. Lines 2-7 process scalar variables.
On line 3, the algorithm iterates over the instructions ifi
discovered by dual slicing with two inputs that identify one1133Algorithm 4 Patch the extracted code for external depen-
dences through concretization
Input :extract denotes the code to extract; extdepdenoting
instruction instances in Ethat are part of extract and have
external dependence
concretize (extract ,extdep)
/* concretize reads of external dependences */
1:for each unique instruction iinextdepdo
2:letibe 'MOVr2,[r1]'
3:letT=faddr7!valgbe a map from addresses to
the values of i's external dependences
4: replace iwith the following:
ifr12T:
MOV r 2,T[r 1]
else: MOV r 2,[r1]
5:end for
/* patch instructions writing through addresses
derived from external dependences */
6:for each instruction iinextract that may write to an
address that is directly/indirectly computed from an
external dependence in Edo
7:letibe 'MOV[r2],r1'
8:for each external address athatihas written to
do
9: add an entry xato the data section
10: map[a] =xa
11: end for
12: replace iwith the following:
ifr22map:
MOV [map[r 2]],r 1
else: MOV [r 2],r1
13:end for
parameter. On line 6, it replaces the instruction. If the
instruction reads from the location that we identied as
theith parameter, it is redirected to instead read the new
variable prepared for the ith parameter on line 1. External
dependences through registers are handled similarly and
thus elided. Lines 8-14 process a variable holding a buer
that may be read from at any consecutive memory locations
within the buer. Many strings provided by the user fall
into this category, including the body dataparameter in the
pine case study. Similar to scalar variables, the algorithm
iterates over and replaces the discovered instructions. If
the instruction reads from a memory address corresponding
to the ith parameter, it is redirected to read from the new
location. Because the instruction reads from a buer, we
must guard the redirection by checking whether the address
lies between the lowest address observed for the ith parameter
and the size of the new parameter.
Next we use the pine example to illustrate concretization
and redirection. Fig. 6 presents a portion of code from pine
that reads the email subject along with the corresponding
binary code and the rewritten binary after concretization and
redirection. On line 3, call_mailer readsheader->env , on line 14
smtp_mail readsenv->subject , and on line 23 rfc822_output_...()
reads a subject from a buer where subject is pointing.
To nd the instructions that read the email subject in
this example, we slice two executions with dierent subjects.
The resulting dual slice includes only line 23 because that
instruction reads the subject, and the value changes when theAlgorithm 5 Redirect instructions related to the ith input.
Input :extract denotes the code to extract; ifithe instruc-
tions load the ith input; Tithe type of the ith input
redirect (extract ,ifi,Ti)
1:add a global variable viof type Tito the data section
2:ifTiis a scalar type then
3:for each unique instruction xinifido
4: letxbe 'MOVr2,[r1]'
5: letaddr be the address accessed by xinifi
6: replace xwith the following:
ifr1== addr:
r1= &x i
MOV r 2,[r1]
r1= addr
else: MOV r 2,[r1]
7:end for
8:else if Tiis a buer type then
9:for each unique buer access instruction xinifi
do
/*xmust be an instruction repetitively
executed to access a buffer */
10: letxbe 'MOVr2,[r1]'
11: letaddr be the lowest address accessed by xin
ifi
12: replace xwith the following:
ifaddrr1< addr + T i.size:
t = r 1
r1= &x i+ (r 1- addr)
MOV r 2,[r1]
r1= t
else: MOV r 2,[r1]
13: end for
14:end if
user input changes. Although lines 3 and 14 are not in the
dual slice, the values they use come from outside call_mailer() ,
causing external dependences. Hence, our technique auto-
matically concretizes accesses in lines 3 and 14 and redirects
the one in line 23, as shown in lines 5 (for header ), 7 (for
header->env ), 16 (env->subject ), and 25 ( subject ).
The key idea of concretization and redirection is that
the concretized values are used only as keys for redirection
and never actually dereferenced. Concretized pointer values
ensure the same original buer address is accessed and the
accesses can simply be redirected. For example, we concretize
the instruction on line 4 that reads the header parameter. On
line 6,pine readsheader->env through header . Since the ebx
register is already concretized on line 4, ecxis also concretized
on line 6. Note, however, that one instruction may execute
many times, and some instances of the instruction should be
concretized while other instances should not, we ensure that
the instruction performs the original behavior as necessary
through the else branch of the instrumentation.
4. PRACTICAL CHALLENGES
Nondeterminism. In the previous section, we claimed that
the dual slice presents only dierences originating from input
dierences. However, when a program is nondeterministic,
there can also be dierences caused by that nondeterminism.
For example, Fig. 7 shows that two executions of pine that
send an email can have dierences as a result of nondetermin-
ism within an event handling loop controlled by a timer. In
the rst execution, we select the send command of the menu11341call_mailer(METAENV* header, ...) {
2...
3smtp_mail(..., header->env, ...);
4/* 633b98: MOV ebx, [ebp + 0x8]
5!MOV ebx, 0x7ffee00
6633ba0: MOV ecx, [ebx]
7!ifebx == 0x7ffee00:
8 MOV ecx, 0x7ffef40
9 else: MOV ecx, [ebx] */
10...
11}
12smtp_mail(..., ENVELOPE* env, ...) {
13...
14rfc822_output_header_line(..., env->subject);
15/* 642182: MOV eax, [ecx + 8]
16!ifecx + 8 == 0x7ffab40:
17 MOV eax, 0x7fff080
18 else: MOV eax, [ecx + 8] */
19...
20}
21rfc822_output_header_line(..., char* subject) {
22...
23 while(n-- > 0 && (**d = *subject++) != '\0')
24/* 664fc9: MOV eax, [edx]
25!if0x7fff080edx < 0x7fff080 + 10:
26 MOV eax, nSubject[edx-0x7fff080]
27 else: MOV eax, [edx] */
28...
29}
Figure 6: Source code of pine reading subject from
data structure
before the timer expires in iteration A, but in the second
execution, we select the send command after the rst timeout
in iteration B and before a second timeout in iteration C.
Thus, lines 16-20 in the rst execution do not align with
any lines in the second execution. The resulting dual slice
includes lines 16-18 because line 19 control depends upon
lines 16 and 18, and line 18 data depends upon line 17. This
is not a desired result because lines 16-18 also execute in
iteration C of the second execution, and these lines show no
value dierences.
To address this issue, our technique identies possible non-
determinism through a calibration phase. We execute the
program twice with the same input. Dierences between the
two executions show that the program has nondeterministic
behavior, and specic dierences indicate where nondeter-
minism occurs. When an instruction has a value dierence
across the executions, i.e. their occurrences in the two exe-
cutions align but have dierent values, the value dierence
originates from nondeterminism and the instruction can be
ignored during the component location process.
In contrast, control ow dierences, i.e. unaligned instruc-
tion instances, usually arise from nondeterminism in event
handling loops. In our pine example, the send menu item
may be selected in either the rst or second iteration of a
loop depending on the timer. Thus, our technique rst nds
the loop containing the nondeterministic behavior through
calibration. In our example, the while loop starting on line
12 is identied as the nondeterministic event handling loop.
During component identication, when aligning execu-
tions with dierent inputs, our technique does not simply
align each iteration of a nondeterministic loop in order, but
rather based on edit-distance[28]. The technique nds which
alignment of iterations in both executions yields the fewest
misaligned instructions. If multiple iterations align equally
well, the earliest is selected. In Fig. 7, our technique aligns
iterations A of the rst execution and C of the second.
Locating Multiple Components. In some cases, the com-
ponent containing the dual slice includes most of the binary....
12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
16 else i f ( c == stdin )
17 command = read ( stdin ) ;
18 i f(command == SEND) f
19 pine send ( ) ;
20 log ( "send mail " ) ;
......
12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
15 do something ( ) ;
12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
16 else i f ( c == stdin )
17 command = read ( stdin ) ;
18 i f(command == SEND) f
19 pine send ( ) ;
20 log ( "send mail " ) ;
...12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
16 else i f ( c == stdin )
17 command = read ( stdin ) ;
18 i f(command == SEND) f
19 pine send ( ) ;
20 log ( "send mail " ) ; 12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
16 else i f ( c == stdin )
17 command = read ( stdin ) ;
18 i f(command == SEND) f
19 pine send ( ) ;
20 log ( "send mail " ) ;12while (true )f
13 c = s e l e c t ( stdin , t ) ;
14 i f( c == t )
15 do something ( ) ;A B
C
Figure 7: Two executions with nondeterminism. Iter-
ation A should align with iteration C.
For these cases, our technique supports identifying multiple
modular functions to extract instead of just one function,
in order to reduce the size of the component. Recall, for
example, the xvcase in Fig. 5b. Locating a single compo-
nent will extract everything called by the function mainLoop() ,
which is undesirable. Instead, our technique can extract only
writeJPEG() andLoadBMP() , which precisely capture exactly the
behavior of interest.
When extracting multiple functions, the data ow between
the functions must be property connected. For example,
writeJPEG() must use image data generated by LoadBMP() . The
concretization and redirection process handles this. To sim-
plify our discussion, assume two functions AandBare
extracted with Awriting to a chunk of memory m, which is
later read by B. The memory is allocated outside both A
andB. During concretization, instructions writing values to
m(inA) are replaced with writes to a new and valid memory
location. Instructions reading m(inB) are redirected to the
new memory. If data ow between AandBgoes through
another function C, e.g. Cmodies the values between A
andB,Cwill be included in the dual slice as well, and thus
the aforementioned process still applies.
Concretizing Other Resources. During concretization,
accesses to external memory get replaced with valid accesses
to freshly created variables. However, not all external de-
pendences may be on memory. For example, the extracted
component may depend upon a le handle that is not af-
fected by the reuser's chosen parameters. In such cases, we
must identify the external dependences on other necessary
resources and safely acquire them as well. Pragmatically,
our present implementation handles dependences on external
les and sockets, but it can be extended to other resources
once they have been identied.
5. EXPERIMENTS AND RESULTS
We have implemented a prototype of our system using
Pin[30] for tracing, while the dual slicing is written in C. We
use Bistro[11] for extracting the desired components as well as
for binary rewriting to perform concretization and redirection.
Note that Bistro is a robust binary transformation tool. It
can safely extract portions from or patch arbitrary binaries
by correcting internal references in the binary like indirect
jump and call targets. Using our prototype, we were able to
extract 10 components of interest from 7 real world programs
into object les. We were further able to link with and
invoke those components from new programs that reused the
extracted behavior.11355.1 Observations
Table 1 presents the 10 components we examined in our
study. Although we used binaries with debugging information
to clarify the dual slicing results during experimentation,
our technique does not rely on any debugging symbols or
information and can be applied to stripped binaries.
We rst examine results for locating desired features using
the coverage based approach and our dual slicing based
approach. `Cov' is the number of instructions covered by
the execution exhibiting the feature and notcovered by
the execution not exhibiting the feature [41]. These locate
the feature in the coverage based approach. Extracting
the functions located by this approach yields the extracted
component size `Cov F. Size'. In contrast, our approach
uses the dual slice to locate the desired component. `DS'
presents the number of instructions in the dual slice. Note
that it is usually orders of magnitude smaller than `Cov'.
Extracting the functions identied by the dual slice yields
the extracted component size `F. Size'. This is also smaller
than the size of components extracted using coverage based
techniques. We note that in some cases, like Murofet, dual
slicing can locate the desired component even when there are
no coverage dierences. Thus, dual slicing can have greater
generality than a coverage based approach. Also note that
existing coverage based approaches do not inherently support
working on binaries or performing function extraction [41].
The `Funcs' column is the number of the modular functions
ultimately discovered with our algorithm. In one half of cases,
we identied one function, but in the other half, we identied
two modular functions to extract. These numbers do not
include the callees of the identied functions, which are
also extracted. This indicates that many features require
multiple functional components. Extracting such features
requires understanding relationships such as the data ow
between components. Our technique automates this through
concretization as presented in the previous section.
The `C.Size' and `C.Instrs' columns list the sizes of con-
cretized memory and the number of concretized instructions
respectively. Observe that the size of the concretized mem-
ory is relatively high compared to the number of concretized
instructions. The pine case study in the rst row shows that
a concretized instruction reads roughly 32 bytes on average.
This indicates that some of the concretized instructions are in
loops, so they execute multiple times to read additional data.
Moreover, the size of the concretized memory indicates that
the extracted functions require substantial data and that
extracting functions without considering these data is un-
likely to work. This concretized information mostly reects
pointers through data structures and global conguration
data, such as the SMTP server in pine example. The smaller
number of concretized instructions further indicates that the
size overhead caused by concretization is low.
The `R.Instrs' column lists the number of redirected in-
structions. It shows that a very small number of instructions
are responsible for reading the parameters of the extracted
function and must be redirected for the desired interface.
For the centerim and smbc cases, extracting the feature
required two components. For centerim, the login component
does not have practical use. However, the send-message
component relies upon the login component. To locate the
two centerim components, we leveraged experience using
the program. When sending a message with centerim, the
program requires a password. From this, we infer that wemust log into the message server to send a message. Thus,
we use two inputs with dierent login credentials to locate
the login component, and we use another two inputs with
dierent messages to locate the send-message component.
However, this knowledge is not always available. For smbc,
we use two inputs dierent both in login information and
directory name. From the resulting callgraph, we can locate
both login and create-directory components.
5.2 Case Study: Murofet Worm
Many worms such as Torpig[37], Concker[34], and Muro-
fet use a technique called domain ux , which generates a list
of domain names at runtime to hinder analysis of communi-
cation between a worm and the attacker. With domain ux,
the defender cannot simply block IP addresses to stop the
malicious behavior of the worm. Extracting the proprietary
domain ux algorithm helps defend against the worm by
predicting malicious domain names in advance. To further
clarify the use and practicality of our technique, we have
posted a demo of this Murofet case study online [4].
When Murofet executes, it generates a domain name and
connects to the domain to check whether another malicious
payload exists on the server. If the connection fails, the
worm repeats the process until it nds a valid server.
To apply our technique, we need two executions generating
domain names with dierent input. Since the worm does not
provide a user interface for the domain ux algorithm, we
cannot just change the input values. Moreover, we do not
know the inputs for the domain ux algorithm. From multi-
ple executions, we observe that the worm produces dierent
domain names each time it executes, so the worm uses dier-
ent inputs whenever it executes. With two executions that
produce dierent domain names, our technique found the
function responsible for generating domain names. We used
the generated domain name in the DNS lookup packet as the
slice criterion. From the dual slice, our technique found the
modular function corresponding to the domain ux process
and also found that the input for the process came from the
system time by analyzing the data dependences in the slice.
This case study shows that even when a program has no
user interface for providing parameters, our technique can
still identify and extract the target feature. It can create
an interface for parameters as long as the inputs can change
across multiple executions. Once it identies the modular
component, we can also narrow our focus to that component
to ease further manual analysis of the feature.
5.3 Case Study: Word97
Legacy Microsoft Word saves les in a proprietary DOC
format. The format is not well documented, and reading
such les is dicult to implement. Third party applications
support DOC les, but they face limitations. To ensure
that data in such les can be read, we consider the case of
transforming a Word97 DOC le into a plain text le. With
Microsoft Word, this can be achieved by opening a DOC le
and directly saving it as a text le. To identify the function
responsible, we use two dierent DOC les and save these
les as dierent text les. Windows GUI applications have
event handling loops that cause nondeterminism because we
cannot control order of events. However, our calibration
phase eectively identies the events even when they occur
in dierent iterations of event handling loops.1136Table 1: Extraction results
Program Size Feature Cov Cov F. Size DS F. Size Funcs C. Size C. Instrs. R. Instrs.
alpine 5.4MBSend mail 17210 556KB 360350KB 110KB 314 4
Create a directory 5168 508KB 204100KB 24KB 195 2
centerim 2.1MBLogin 21814 414KB 9680KB 290KB 142 2
Send message 11745 529KB 2015KB 24KB 60 2
murofet 3.9MB Domain ux - -1812KB 120KB 19 1
mysql 3.1MB Get a list of databases 1000 116KB 270 39KB 25KB 187 1
ncmpc 1.2MB Add a song to playlist 1245 160KB 65 1KB 1500B 10 1
smbc 7.5MBConnect to samba server 6090 407KB 1609 210KB 14KB 174 2
Create a directory 6090 407KB 1609 110KB 1300KB 354 1
word97 5.3MB Convert DOC to text 19752 754KB 725 52KB 268KB 823 2
xv 2.7MB Convert BMP to JPEG 6083 346KB 3196 50KB 25KB 337 5
The dynamic call tree containing the dual slice forks into
two main branches. The rst reads and stores the le content
into memory. The second then stores this data in a text le.
We thus extracted the common ancestor function within each
branch into a new component that is able to read a DOC
le and write it into a specied text le. Not only that, but
the extracted component is self-contained and works even
across dierent versions of the Windows platform.
This component also exemplies the necessity of concretiz-
ing additional resources as noted in Sec. 4. Word97 creates
many handles that are initialized by the kernel and that are
used by the underlying components that read and write the
DOC les. These external dependences on kernel objects
must be valid in order for the extracted component to run,
so we extended our resource concretization system to handle
these kernel level resources as well in order to create the
kernel objects before we execute the extracted component.
5.4 Limitations
Our technique shows that it is feasible in practice to locate
and extract complex binary features into reusable software
components. However, dynamic analysis imposes some limi-
tations. In particular, we only extract a portion of the full
semantics of a function. For example, the accesses observed
in the provided executions are used by the technique to de-
termine what portions of memory to concretize and make
available to the extracted component. The provided execu-
tions may not access the full range of addresses in a global
table. In this case, we can only guarantee that we extract
the portion of the table observed in the provided executions,
and accesses outside this range lead to undened behavior.
6. RELATED WORK
Most related work within the software engineering com-
munity comes from feature location [40, 41, 8, 10, 15, 33,
9, 38, 35, 13, 6, 14, 16], which identies where a feature is
implemented within source code, and function extraction or
extract method refactoring [26, 23, 17, 18, 31, 25, 10], which
extracts some selected functionality out of existing source
code into a self contained function. Approaches for feature
location range from coverage based techniques [40, 41, 6, 14]
to machine learning techniques [35]. While we showed that
dual slicing can perform better than the former, the latter
often require either source code or many more executions to
be provided by the reuser, which is undesirable. Source code
function extraction simply is not applicable to binaries.
Recent work has focused on identifying and extracting
binary features of existing programs. Manual extraction [1, 2,12] has been used to aid in understanding malware. Dynamic
binary slicing [5, 47] and chopping [21] have been used for
binary analysis. Execution slicing can help identify basic
blocks composing a feature [42]. Chopping can help identify
relationships between given inputs and outputs [27]. These
work in small applications, but in complicated programs
both dynamic slicing and chopping can produce a large set
of instructions. Zhao et al. [48] combined static analysis
and dynamic backward slicing to identify encryption and
decryption logic in malware.
BCR [7] identies interfaces and extracts functions. It
identies parameters through dynamic analysis. Compared
to our technique: (1) BCR identies all parameters, while
we remove unwanted parameters to yield a concise interface.
(2) BCR targets small and well dened functions, but our
technique handles more complex features. As seen in Sec. 5,
such features have many external dependences, and manually
specifying values for each is unrealistic. BCR also does not
address locating the function containing a feature.
Inspector Gadget [22] identies and extracts a gadget with
a desired feature. This work identies gadgets using dynamic
slicing, but recall that this often produces a large set of
instructions. This work also focuses on the replay of the
gadget and does not issues like providing an interface.
Lin et al. [29] extract and reuse functionality of a benign
program within a malicious one. They identify functions by
nding the common ancestor of all functions that produce
the desired output. As shown in the xvcase study, this
approach may produce an undesirably large component.
7. CONCLUSIONS
We presented a novel technique for locating and extracting
a binary fragment that implements a desired feature within
a program. Our technique enables both an intuitive repre-
sentation of the desired feature through executions and an
automated location and extraction process for the feature.
We also presented a technique called interface casting, which
bypasses the problem of reverse engineering the complicated
interface of a function and instead provides a new usable in-
terface. Evaluation on a set of real world applications shows
that our technique can extract various reusable components.
8. ACKNOWLEDGEMENT
This research has been supported in part by DARPA un-
der contract 12011593 and by NSF under awards 0845870,
0917007 and 1320326. Any opinions, ndings, and conclu-
sions in this paper are those of the authors only and do not
necessarily reect the views of DARPA and NSF.11379. REFERENCES
[1]Kraken Encryption Algorithm. http://mnin.blogspot.
com/2008/04/kraken-encryption-algorithm.html ,
2008.
[2]Kraken is nally cracked. http://mnin.blogspot.com/
2008/04/kraken-is-finally-cracked.html , 2008.
[3]Research announcement: Binary executable transforms.
Defense Advanced Research Projects Agency, 2011.
[4] Demo of murofet domain ux extraction.
https://www.youtube.com/watch?v=7GU4b68oWD4 ,
2013.
[5] H. Agrawal and J. R. Horgan. Dynamic program
slicing. In Proceedings of the 1990 ACM SIGPLAN
Conference on Programming Language Design and
Implementation (PLDI) , 1990.
[6] G. Antoniol and Y.-G. Gueheneuc. Feature
identication: a novel approach and a case study. In
Proceedings of the IEEE International Conference on
Software Maintenance (ICSM) , 2005.
[7] J. Caballero, N. Johnson, S. McCamant, and D. Song.
Binary code extraction and interface identication for
security applications. In Proceedings of the 17th Annual
Network and Distributed System Security Symposium
(NDSS) , 2010.
[8] G. Canfora, A. Cimitile, A. De Lucia, and G. A.
Di Lucca. Decomposing legacy programs: a rst step
towards migrating to client-server platforms. In
Proceedings of the 6th IEEE International Workshop on
Program Comprehension (IWPC) , 1998.
[9] K. Chen and V. Rajlich. Ripples: Tool for change in
legacy software. In Proceedings of the IEEE
International Conference on Software Maintenance
(ICSM) , 2001.
[10] F. Cutillo, F. Lanubile, and G. Visaggio. Extracting
application domain functions from old code: a real
experience. In Proceedings of the IEEE Second
Workshop on Program Comprehension (WPC) , 1993.
[11] Z. Deng, X. Zhang, and D. Xu. BISTRO: Binary
Component Extraction and Embedding for Software
Security Applications. In Proceedings of the 18th
European Symposium on Research in Computer
Security (ESORICS) , 2013.
[12] F. Desclaux and K. Kortchinsky. Vanilla Skype part 1.
ReCon , 2006.
[13] B. Dit, M. Revelle, M. Gethers, and D. Poshyvanyk.
Feature location in source code: a taxonomy and survey.
Journal of Software: Evolution and Process , 2013.
[14] D. Edwards, S. Simmons, and N. Wilde. An approach
to feature location in distributed systems. Journal of
Systems and Software , 2006.
[15] T. Eisenbarth, R. Koschke, and D. Simon. Locating
features in source code. IEEE Transactions on Software
Engineering , 2003.
[16] A. Eisenberg and K. De Volder. Dynamic feature
traces: nding features in unfamiliar code. In
Proceedings of the IEEE International Conference on
Software Maintenance (ICSM) , 2005.
[17]R. Ettinger. Program sliding. In Proceedings of the 26th
European conference on Object-Oriented Programming
(ECOOP) , 2012.
[18] R. Ettinger and M. Verbaere. Untangling: a slice
extraction refactoring. In Proceedings of the 3rdInternational Conference on Aspect-Oriented Software
Development (AOSD) , 2004.
[19] W. B. Frakes and K. Kang. Software reuse research:
Status and future. IEEE Transactions on Software
Engineering , 2005.
[20] M. N. Gagnon, S. Taylor, and A. K. Ghosh. Software
protection through anti-debugging. In Proceedings of
the 2010 IEEE Symposium on Security and Privacy
(SP), 2007.
[21] D. Jackson and E. J. Rollins. Chopping: A
generalization of slicing. Technical report, SIGSOFT
Symposium on the Foundations of Software
Engineering (FSE), 1994.
[22] C. Kolbitsch, T. Holz, C. Kruegel, and E. Kirda.
Inspector gadget: Automated extraction of proprietary
gadgets from malware binaries. In Proceedings of the
2010 IEEE Symposium on Security and Privacy (SP) ,
2010.
[23] R. Komondoor and S. Horwitz. Eective, automatic
procedure extraction. In Proceedings of the 11th IEEE
International Workshop on Program Comprehension
(IWPC) , 2003.
[24] B. Korel and J. Laski. Dynamic program slicing.
Information Processing Letters , 1988.
[25]A. Lakhotia and J.-C. Deprez. Restructuring programs
by tucking statements into functions. Information and
Software Technology , 1998.
[26] F. Lanubile and G. Visaggio. Extracting reusable
functions by ow graph-based program slicing. IEEE
Transactions on Software Engineering , 1997.
[27]A. Lanzi, M. I. Sharif, and W. Lee. K-tracer: A system
for extracting kernel malware behavior. In Proceedings
of the 16th Annual Network and Distributed System
Security Symposium (NDSS) , 2009.
[28] V. I. Levenshtein. Binary codes capable of correcting
deletions, insertions, and reversals. Doklady Akademii
Nauk SSSR , 1966. English translation in Soviet Physics
Doklady, 10(8).
[29] Z. Lin, X. Zhang, and D. Xu. Reuse-oriented
camouaging trojan: Vulnerability detection and attack
construction. In Proceedings of the 40th IEEE/IFIP
International Conference on Dependable Systems and
Networks (DSN) , 2010.
[30] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood.
Pin: Building customized program analysis tools with
dynamic instrumentation. In Proceedings of the 2005
ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , 2005.
[31] K. Maruyama. Automated method-extraction
refactoring by using block-based slicing. In Proceedings
of the 2001 Symposium on Software Reusability: putting
software reuse in context (SSR) , 2001.
[32] D. Mcilroy. Mass-produced Software Components.
Software Engineering Concepts and Techniques , 1969.
[33] M. Petrenko and V. Rajlich. Concept location using
program dependencies and information retrieval (depir).
Information and Software Technology , 2013.
[34] P. Porras, H. Sa di, and V. Yegneswaran. A Foray into
Concker's Logic and Rendezvous Points. In
Proceedings of the 2nd USENIX Conference on1138Large-scale Exploits and Emergent Threats: Botnets,
Spyware, Worms, and More (LEET) , 2009.
[35] D. Poshyvanyk, Y.-G. Gueheneuc, A. Marcus,
G. Antoniol, and V. Rajlich. Feature location using
probabilistic ranking of methods based on execution
scenarios and information retrieval. IEEE Transactions
on Software Engineering , 2007.
[36] C. Puttick. Preserving legacy les with ECMA Oce
Open XML (MSOOXML). ODF Europe Action Group,
2007.
[37] B. Stone-Gross, M. Cova, L. Cavallaro, B. Gilbert,
M. Szyd-lowski, R. Kemmerer, C. Kruegel, and
G. Vigna. Your Botnet is My Botnet: Analysis of a
Botnet Takeover. In Proceedings of the 16th ACM
conference on Computer and communications security
(CCS) , 2009.
[38] J. Wang, X. Peng, Z. Xing, and W. Zhao. Improving
feature location practice with multi-faceted interactive
exploration. In Proceedings of the 2013 International
Conference on Software Engineering (ICSE) , 2013.
[39] D. Weeratunge and X. Zhang. Analyzing concurrency
bugs using dual slicing. In Proceedings of the 19th
International Symposium on Software Testing and
Analysis (ISSTA) , 2010.
[40] N. Wilde, J. Gomez, T. Gust, and D. Strasburg.
Locating user functionality in old code. In Proceedings
of the IEEE International Conference on Software
Maintenance (ICSM) , 1992.
[41] N. Wilde and M. C. Scully. Software reconnaissance:
mapping program features to code. Journal of Software
Maintenance , 1995.[42] W. E. Wong, S. S. Gokhale, and J. R. Horgan.
Quantifying the closeness between program components
and features. Journal of Systems and Software , 2000.
[43] W. E. Wong, J. R. Horgan, S. S. Gokhale, and K. S.
Trivedi. Locating program features using execution
slices. In Proceedings of the 1999 IEEE Symposium on
Application-Specic Systems and Software Engineering
and Technology (ASSET) , 1999.
[44] B. Xin, W. N. Sumner, and X. Zhang. Ecient
program execution indexing. In Proceedings of the 2008
ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , 2008.
[45] X. Zhang, N. Gupta, and R. Gupta. Pruning dynamic
slices with condence. In Proceedings of the 2006 ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , 2006.
[46] X. Zhang and R. Gupta. Cost eective dynamic
program slicing. In Proceedings of the 2004 ACM
SIGPLAN Conference on Programming Language
Design and Implementation (PLDI) , 2004.
[47] X. Zhang, R. Gupta, and Y. Zhang. Precise dynamic
slicing algorithms. In Proceedings of the 25th
International Conference on Software Engineering
(ICSE) , 2003.
[48] Z. Zhao, G.-J. Ahn, and H. Hu. Automatic extraction
of secrets from malware. In Proceedings of the 2011
18th Working Conference on Reverse Engineering
(WCRE) , 2011.1139