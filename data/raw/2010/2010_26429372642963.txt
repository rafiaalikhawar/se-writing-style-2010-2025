Language Fuzzing Using Constraint Logic Programming
Kyle Dewey Jared Roesch Ben Hardekopf
University of California, Santa Barbara
{kyledewey, jroesch, benh}@cs.ucsb.edu
ABSTRACT
Fuzz testing builds condence in compilers and interpreters.
It is desirable for fuzzers to allow targeted generation of pro-
grams that showcase specic language features and behav-
iors. However, the predominant program generation tech-
nique used by most language fuzzers, stochastic context-free
grammars, does not have this property. We propose the use
of constraint logic programming (CLP) for program gener-
ation. Using CLP, testers can write declarative predicates
specifying interesting programs, including syntactic features
and semantic behaviors. CLP subsumes and generalizes the
stochastic grammar approach.
Categories and Subject Descriptors
D.3.2 [ Language Classications]: Constraint and logic
languages; D.2.5 [ Testing and Debugging ]: Testing tools
Keywords
Fuzzing; automated program generation; automated testing
1. INTRODUCTION
Language fuzzing is a proven strategy for testing the cor-
rectness of compilers and interpreters. However, existing
language fuzzing techniques are, in general, ad-hoc and lim-
ited in their scope and their eectiveness. We propose a
new method for language fuzzing based on constraint logic
programming (CLP). Our CLP method generalizes and im-
proves upon the existing fuzzing strategies.
Language fuzzing is used to test language implementa-
tions, i.e., compilers and interpreters. A fuzzer automati-
cally generates programs in the language being tested and
feeds them to one or more implementations of that language.
The fuzzer can then use an oracle of correctness or dier-
ential testing [11] to determine if the program was executed
correctly. Fuzzing is often used as a bug-nding tool, but
This work was supported by NSF CCF-1319060.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full cita-
tion on the Ô¨Årst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2642963 .it can also be used to increase condence in the correctness
of a language implementation. For example, if a fuzzer can
generate a million programs that all stress a particular lan-
guage feature in diverse ways without ever triggering a bug,
then the implementor can have a high degree of condence
in the correctness of that language feature. With respect to
both nding bugs and increasing condence in correctness,
the most important part of a language fuzzer is the tech-
nique used to generate programs, because that technique
ultimately determines what is tested and how it is tested.
Program Generation. A desirable property of program
generation for language fuzzing is the ability to target gen-
eration, i.e., to specify particular combinations of syntactic
language features and semantic language behaviors that the
generated programs should all exhibit. For example, sup-
pose that the language implementation has been augmented
with a new optimization or language feature and the imple-
mentor wants to test that the new version of the implemen-
tation is correct. In order to do so, the fuzzer should speci-
cally generate programs that would trigger the optimization
or that would use the new language feature. Purely syn-
tactic specications are not sucient for this purpose; the
fuzzer must be able to specify program behaviors to achieve
the desired results.
Current State of the Art. The predominant program
generation strategy for language fuzzing is based on stochas-
tic context-free grammars [11]. The fuzzer takes a grammar
describing the syntax of the language being tested and an
assignment from the grammar's productions to probabilities.
The resulting probabilistic grammar is used to generate syn-
tactically valid programs whose various expressions conform
to the given probability distribution.
Approaches based on stochastic grammars do not have
the ability to target program generation for specic syntac-
tic features and semantic behaviors. Traditional stochas-
tic grammars are only able to guide program generation by
tuning the grammar's probabilities (often one of the most
laborious aspects of using stochastic grammars). Even us-
ing additional extended features such as conditional proba-
bilities and bounds, stochastic grammars remain rooted in
syntax, preventing testers from directly specifying semantic
behaviors under test.
Key Insight. Our central insight is that constraint logic
programming (CLP) is an ideal vehicle for language fuzzing
that strictly subsumes the stochastic grammar approach;
i.e., using CLP predicates we can specify stochastic gram-
725
mars but we can also specify combinations of syntactic fea-
tures and semantic behaviors in a declarative and ecient
way. The nature of CLP means that these predicates can
be directly used to automatically generate many satisfying
programs, i.e., programs that contain the specied features
and behaviors. CLP is not an alternative approach from
stochastic grammars, but rather a complete replacement
with strictly greater expressiveness.
Contributions. Our specic contributions in this paper are
the following: A general description of how to apply CLP to
language fuzzing in order to yield the benets outlined above
(Section 3); a discussion of how to apply our method to fuzz
JavaScript, a dynamically typed scripting language with ob-
jects, prototype-based inheritence, and higher-order func-
tions (Section 4); and an evaluation of our method that uses
our techniques for fuzzing JavaScript to compare against a
purely stochastic grammar approach (Section 5).
2. RELATED WORK
We review related work with respect rst to language
fuzzing, then with respect to declarative test generation.
Language Fuzzing. The most common technique used to
automatically generate programs for testing is the stochas-
tic grammar approach described in Section 1. State of the
art language fuzzers based on this method include jsfun-
fuzz [13], LangFuzz [5], and CSmith [19]. jsfunfuzz was
developed internally by Mozilla specically for JavaScript
in order to test the Spidermonkey JavaScript engine. Lang-
Fuzz is targeted to dynamic languages, including JavaScript,
but is not restricted to a single language. Langfuzz extends
stochastic generation to include mutation : given an existing
test suite, LangFuzz will randomly mutate the existing pro-
grams in order to generate new ones. CSmith uses stochastic
generation as the basis of a fuzzing tool for C, supplemented
with auxiliary C-specic techniques and analyses to handle
potentially undened behavior and other C-specic prob-
lems. We demonstrate in the rest of the paper that our
proposed CLP method is able to specify the same things
as stochastic grammars and also specify semantic behaviors
and relations between syntactic expressions.
Declarative Test Generation. Our CLP technique uses
declarative specications to generate programs for language
fuzzing. No existing language fuzzers use this approach, but
there are techniques for automatic data structure generation
(e.g., red-black trees) that use similar ideas.
TestEra [10, 16] allows programmers to declaratively spec-
ify data structures using predicates written in Alloy [6]. Al-
loy compiles the specication down to a SAT instance and
uses a SAT solver to generate satisfying data structure in-
stances. UDITA [3] allows users to specify data structure
predicates in Java using a hybrid declarative/imperative style.
It allows for the denition of generators which can be called
nondeterministically, which is a simplication of earlier purely
imperative-style generators (like those in ASTGen [2]). Ko-
rat [1] allows for purely declarative data structure predicates
to be specied in Java. Korat's technique is in some ways
similar to, though distinct from, a logic programming-based
approach. However, it has no ability to solve symbolic con-
straints and cannot employ symbolic reasoning about the
values contained in the data structures.None of the above existing declarative test generation
strategies use constraint logic programming, and none have
been applied to program generation for language fuzzing.
3. CLP FOR PROGRAM GENERATION
In this section we discuss how to use constraint logic pro-
gramming for program generation. We briey review stan-
dard CLP syntax and semantics, but readers unfamiliar with
CLP may wish to consult further references [7, 8]. We will
begin with a syntactic description of a simple arithmetic ex-
pression language and express progressively more interesting
properties for expression generation. Section 4 will then dis-
cuss applying these ideas to program generation specically
for JavaScript.
Syntactic Expressions. We use the following arithmetic
expression language for the examples in this section:
e2ArithExp ::=n2Zje1+e2
An arithmetic expression eis either an integer or an addition
of two expressions. We can describe this grammar in CLP
using Prolog-style syntax as follows:
exp(X) :- INTMIN <= X, X <= INTMAX.
exp(add(Y,Z)) :- exp(Y), exp(Z).
Aclause consists of a head and a body and is terminated by
a period, like so: \ head :-body.". The previous example has
two clauses, both for the predicate exp. The :-can be read
as \if" and a comma stands for conjunction. Labels starting
with capital letters are logical variables. Therefore, the rst
clause states \the value of variable Xis an expif the value
ofXis an integer between intmin andintmax" (where we
assume intmin andintmax are variables that contain the
minimum and maximum integer values, respectively). The
second clause states \ add(Y,Z) is an expifYis an expand
Zis an exp".
We can use this denition in two distinct ways: to recog-
nize valid expressions and to generate valid expressions. In
the rst case, we pass a potential expression as an argument
toexpand it will return either trueif it is a valid expression
orfalse otherwise. The more interesting case for fuzzing is
generation: if we want to generate valid expressions instead,
we can use a query like the following:
:- exp(E), write(E), fail.
The CLP engine will attempt to nd a value for the logical
variable Ethat will make exptrue; once it does it will write
that value to output, then fail. Failure will cause the engine
to backtrack and attempt to nd a dierent value for E; this
process will continue indenitely and generate an innite
stream of valid expressions.
One caveat is that the resulting expressions will not be
concrete; instead, they will contain symbolic variables (stand-
ing for unknown integers) that are subject to a set of con-
straints derived from the clauses. For example, one of the
generated expressions would be add(x,add( y,z))where x,
y, and zare symbolic variables standing for unknown inte-
gers. The CLP engine remembers the constraints intmin
fx; y; zgandfx; y; zgintmax. To get a concrete expres-
sion, we simply ask the CLP engine to label the symbolic
variables, i.e., to nd concrete values that satisfy the con-
straints; the engine guarantees that satisfying values must
726exist. Symbolic variables and constraints are how CLP im-
plements symbolic reasoning, and it is the reason that CLP
is strictly more powerful than logic programming.
Bounding Size. The default search strategy of most CLP
engines is unbounded depth-rst search. This strategy con-
trols the order in which expressions are generated, and for
an innite stream of expressions will control which expres-
sions are generated within a nite amount of time. However,
it is simple to change this search strategy; for example, we
can change the query to:
:- call_with_depth_limit(exp(E), 5, CurrDepth),
CurrDepth \== depth_limit_exceeded, write(E), fail.
where call_with_depth_limit is a library function of the
CLP engine, depth_limit_exceeded is a built-in atom, and
\==means \not equal to". This query bounds the depth of
the CLP engine's search to ve; the generated expression
trees are thus bounded to height ve. We can build on this
primitive to implement an iterative deepening search strat-
egy as well. Using this technique we can guarantee minimal
satisfying test cases, rather than relying on a separate test
case reducer (e.g., [17, 15, 20, 21, 12, 14]) as is common with
other language fuzzing techniques (e.g., [19, 13, 9, 11, 4]).
We can also bound expressions by number of nodes instead
of by depth, and we can specify a minimal size in addition
to a maximal size.
Stochastic Grammar. CLP subsumes the stochastic gram-
mar technique for program generation. This means that we
can specify stochastic grammars using CLP, and do so quite
easily. Here is our expression denition modied to emit
expressions with particular probabilities:
exp(X) :- maybe(0.4), INTMIN <= X, X <= INTMAX.
exp(add(Y,Z)) :- exp(Y), exp(Z).
where maybe is a library function of the CLP engine that
succeeds with the given probability. This denition will
generate expressions whose nodes are numbers 40% of the
time and additions 60% of the time. Note that we can com-
bine bounded size with stochastic grammars to get a pro-
gram generator that randomly generates programs within
the given size bounds.
Arithmetic Overow. One of the most powerful abilities
of CLP is symbolic reasoning, which enables the user to
specify numeric constraints as part of a predicate. These
constraints are handled by an integrated constraint solver
as part of the CLP engine. As an example, we can specify
that we only want to generate expressions that contain at
least one arithmetic overow:
exp(X, X, false) :- INTMIN <= X, X <= INTMAX.
exp(add(Y,Z), N, Over) :-
exp(Y,N1,Over1), exp(Z,N2,Over2), N = N1+N2,
((N > INTMAX, Over = true) ;
(N < INTMIN, Over = true) ;
(N >= INTMIN, N <= INTMAX, or(Over1, Over2, Over))).
where semicolon represents disjunction and orinstantiates
its third argument with the logical orof its rst two ar-
guments. In this example, the rst parameter of expis an
expression, the second parameter of exprepresents the value
of the given expression, and the third parameter indicates
whether the given expression contains an overow. The rstclause states that a constant number expression has a value
equal to that number and it does not contain an overow.
The second clause's rst line says that add(Y,Z) is an ex-
pression if Yand Zare expressions, and in addition it says
that the value of add(Y,Z) is equal to the sum of the values
ofYand Z. The next three lines are a disjunction of three
possibilities: either N, the value of add(Y,Z) , is greater than
intmax and Over is true (i.e., this addition overows), or
Nis less than intmin and Over is true (also meaning that
this addition overows), or, nally, Nis between intmin and
intmax and it contains an overow only if either YorZcon-
tains an overow. To generate all expressions that contain
at least one overow, we would use the following query:
:- exp(E,_,true), write(E), fail.
where underscore means\don't care". It is important to note
that because CLP uses symbolic reasoning, it does not actu-
ally iterate through all possible numbers in order to nd ones
that overow|rather, it generates expressions that contain
symbolic variables, and then uses its constraint solver to
solve for values that satisfy the given numeric constraints.
4. GENERATING JA VASCRIPT
In this section we discuss using CLP to fuzz dynamic lan-
guages. We take JavaScript as representative of that class of
languages. JavaScript is an imperative, dynamically typed
language with objects, prototype-based inheritance, higher-
order functions, and exceptions. JavaScript is designed to
be as resilient as possible and makes liberal use of implicit
conversions and other idiosyncratic behaviors. Object prop-
erties can be dynamically inserted and deleted, and when
performing a property access the specic property being ac-
cessed can be computed at runtime. There are several mech-
anisms available for runtime reection. Object inheritance
is handled via delegation: when accessing a property that is
not present in a given object obj, the property lookup algo-
rithm determines whether objhas some other object proto as
its prototype; if so then the lookup is recursively propagated
toproto . We omit exact details of the CLP predicates that
we use for JavaScript, but they are available in the paper's
supplementary materials.
Stochastic Grammar. It is fairly simple to construct a
CLP predicate describing syntactically valid JavaScript pro-
grams; it is a straightforward extension of the method we
used for the example arithmetic expression language in Sec-
tion 3. Just as we did there, we can add probabilities to the
clauses of that predicate in order to convert it to a stochas-
tic grammar. This yields a program generator equivalent to
the publically-available description of jsfunfuzz [13].
However, a purely stochastic grammar is not really eec-
tive for dynamic languages. The problem is that no matter
what language features are present in a generated program,
it is likely that there will be a runtime type error during
execution before most of those features are ever reached.
For example, any attempt to access a property of the null
orundened JavaScript values will raise an exception and
terminate the program's execution (unless the exception is
caught and handled, which again is unlikely in a randomly
generated program).
Available under the Downloads link at http://www.cs.
ucsb.edu/~pllab .
727`null:nil`x:unk`e1:unk
`e1:e2:unk
Figure 1: A fragment of an unsound type system
for JavaScript to lter out programs that attempt
to directly access a property of the nullvalue.
Absence of Runtime Errors. We can use CLP to specify
JavaScript programs that avoid runtime errors. The idea
is to use CLP to encode a type system and compose the
syntactic JavaScript predicate with a predicate that only
matches on well-typed programs. One nice property of this
technique is that we can incrementally make the type system
more powerful, starting with a simple system and adding
precision as needed. We can also choose to make the type
system either sound (restricting the programs that can be
generated, but ensuring that all such programs will avoid
runtime errors) or unsound (allowing more programs to be
generated, but potentially allowing some kinds of runtime
errors). Thus we have two axes of freedom to work with,
allowing us a great deal of exibility to trade o between the
eort required to write predicates and the kinds of programs
that will be generated.
For example, we could employ a simple, unsound type sys-
tem as a rst eort to help avoid some runtime errors. Fig-
ure 1 shows a fragment of a simple type system that prevents
programs from directly dereferencing the nullJavaScript value;
however, it still allows dereferencing a variable which itself
may have the value null. We can encode this fragment of the
type system using CLP as follows:
type(null, nil).
type(var(X), unk).
type(access(E1, E2), unk) :- type(E1, unk).
The predicate type has two parameters; the rst is an
expression and the second is the type of that expression.
The rst clause states that expression nullhas type nil;
the second clause states that a variable has type unk(i.e.,
unknown ); and the third clause states that an object access
expression has type unkif the type of E1(the object being
accessed) is unk. This predicate would disallow programs
such as \ null.foo ", but still allow programs such as \ var
x = null; x.foo ". If there are too many runtime errors in
the resulting programs we can extend this type system to
track the types of variables more closely, either soundly or
unsoundly depending on how precise we want to be and how
much eort we want to put into it. In the extreme we could
employ a sound, precise type system using partial dependent
types that utilize the CLP engine's symbolic reasoning.
Arithmetic Overow. It turns out that arithmetic over-
ow is an interesting property for testing JavaScript imple-
mentations. JavaScript numeric values are technically oat-
ing point; however for performance reasons most JavaScript
engines try to represent numeric values as integers wher-
ever possible. Therefore, at runtime the engine must detect
all overows and automatically change the numeric repre-
sentation from integers to oating point values. We can
extend the arithmetic overow predicate described in Sec-
tion 3 to generate valid JavaScript numeric expressions that
are guaranteed to contain at least one overow, in order to
test whether the engine performs this optimization correctly.Prototype-based Inheritance. Object are the funda-
mental data structure in JavaScript (even functions and ar-
rays are special kinds of objects), and so testing object inher-
itance is key. To do so, we must generate programs that both
construct and usenon-trivial prototype chains. Stochastic
grammars are unlikely to generate such programs by them-
selves. Using CLP, we can enforce that generated programs
contain the following items in sequence, in the proper scope,
potentially with unrelated code in-between:
A declaration for some function foo.
A statement foo.prototype. d=exp, where dis
some string and expis a valid JavaScript expression,
seeding foo's prototype with the property d.
A statement varx= new foo(), constructing a new
object whose prototype is the same as foo's.
A statement x.d, triggering prototype lookup.
A high-level view of this predicate is the following:
proto(S) :-
inSequence([inherFunction(Name),
optional1(inherPrototypeSet(Name)),
optional1(inherPrototypeAdd(Name)),
=(Rest)], S),
astContains(Rest, inherNew(Name), stmt, stmt).
where the inSequence predicate ensures that its arguments
happen in sequence, however they are not necessarily con-
secutive, i.e., an arbitrary number of other expressions may
occur in-between them. This sequence species a function
declaration with a given name Name, followed by an optional
setting of that function's prototype eld, followed by an op-
tional setting of a eld of that function's prototype, followed
by the rest of the AST.
We can extend this specication in various ways to make
for even more interesting tests: to require a minimum depth
for the prototype chain, to require the use of implicit con-
version to convert non-objects to objects and then perform
prototype lookup on the resulting objects, to construct mul-
tiple interleaved prototype chains, etc.
With + Closures. JavaScript has some very obscure and
idiosyncratic behaviors that implementations must get cor-
rect. One example is the combination of the with expres-
sion with closures. The with expression changes the current
scope, aecting variable lookup. Closures should preserve
the current scope, but closures and with have complex inter-
actions that make the proper behavior unclear and dicult
to get correct. A particularly tricky case is when a closure is
created inside of a with expression, and then subsequently
called outside of that with expression.
We can specify a CLP predicate that generates JavaScript
programs with the following requirements:
The program contains a with expression that itself con-
tains a function denition.
The function denition contains multiple free variables
that are dened in various scopes with respect to the
with scope and the scope outside of the with.
The closure value formed from that function is passed
outside of the with and subsequently called.
728A high-level view of this predicate is the following:
withclo(S) :- inSequence([withCloWith(Name),
withCloCall(Name)], S).
where withCloWith ensures that the generated program con-
tains a with expression containing a closure and withClo-
Call ensures that the closure is called outside of the with.
This is an example of how CLP allows the tester to con-
centrate on a specic set of language features and a specic
interaction between those language features.
5. EVALUATION
In this section we evaluate the eectiveness of CLP-based
program generation versus a stochastic grammar approach.
We rst explain our experimental methodology, then we
present and discuss our results for JavaScript.
5.1 Methodology
We compare two dierent approaches to program gener-
ation for language fuzzing: sto(the stochastic grammar
approach) and clp(our CLP-based approach). The com-
parison is a bit misleading because CLP can implement
stochastic grammars; in fact, all of the approaches are im-
plemented in SWI-Prolog [18], a publically-available Pro-
log engine that contains a constraint solver to implement
CLP. The comparison does showcase the additional expres-
siveness and eciency of CLP over purely stochastic gram-
mars. While we requested implementations of the existing
JavaScript fuzzers jsfunfuzz [13] and LangFuzz [5] from
Mozilla for comparison with our technique, our request was
ignored. Our entire infrastructure, including our imple-
mentation of stochastic grammars and the exact predicates
that we use for JavaScript, is available in the supplemen-
tary materials located under the Downloads link at http:
//www.cs.ucsb.edu/~pllab . Our experiments are run on a
system with 12 Intel Xeon@1.9 Ghz cores and 32 GB mem-
ory. All experiments are single-threaded.
The metric that we use to measure program generation
eectiveness is generation rate , in terms of programs per
second. We measure three distinct kinds of generation rate:
total ,unique , and interesting . The total rate is a mea-
sure of how quickly each approach can generate programs,
without regard to what kinds of programs are being gen-
erated. The unique rate is a measure of how quickly each
approach can generate unique programs, i.e., ignoring dupli-
cate ASTs. For this metric, unless otherwise stated, variable
names and the values of number, string, and boolean liter-
als are irrelevant. For example, the programs x + 6 and y
+ 7would be considered identical. The interesting rate is
a measure of how quickly each approach can generate pro-
grams that match some tester-given criteria for being inter-
esting; in our case, interesting means that the program is
accepted by one of our predicates discussed in Section 4. To
compute the generation rate, we allow each approach to gen-
erate programs for ve minutes and then divide the resulting
number of programs (of each category, total ,unique , and
interesting ) by 300 seconds to get units of programs per
second. We report separate total ,unique , andinteresting
numbers for the stoapproach; the clpapproach only gener-
ates unique, interesting programs and so we only report the
interesting number for that approach.
To be clear, our generation metric is not intended to fo-
cus on how fast programs can be generated by the varioustechniques, but rather to reveal how well the techniques can
be tuned to generate interesting programs for various de-
nitions of \interesting", and how easily they can be targeted
for dierent interesting properties.
Details of the sto Approach. For JavaScript, we create
a predicate expthat describes syntactically valid programs.
We then add probabilities as discussed in Section 3 to cre-
ate a stochastic grammar, carefully tuned to favor the gen-
eration of unique programs. Querying this predicate using
\:- exp(E), write(E), fail. " will yield a stream of ran-
domly generated, syntactically valid programs. This method
is equivalent to the current state of the art for stochastic
grammar-based approaches [2, 5, 13, 19].
Details of the clp Approach. The CLP approach uses
the predicates specifying interesting programs directly in or-
der to generate satisfying programs; thus the generated pro-
grams are guaranteed to be both unique and interesting.
We set the search strategy used by the CLP approach for
all predicates to bounded depth-rst search. Again, while
our experiments treat stoandclpas distinct approaches,
we should be clear that in reality clpsubsumes stoand
that these approaches can all be easily combined together in
various ways.
5.2 JavaScript Program Generation
We evaluate four predicates for generating JavaScript pro-
grams: js-err , generating programs with fewer runtime
errors; js-overflow , generating programs that contain at
least one arithmetic overow; js-inher , generating programs
that construct and use prototype-based inheritance chains;
and js-withclo , generating programs that construct clo-
sures inside of with expressions and then call them outside
of those with expressions. With the js-overflow predicate,
we strengthen our denition of uniqueness to consider pro-
grams which have overows at the same positions to be the
same. For the js-err predicate, we use a simple, unsound
type system (however, one that is more extensive than the
example shown in Section 4) that attempts to ensure that
(1) expressions that are used for property access or as the
subject of a delete are neither null norundefined ; and
(2) expressions that are called as functions, either directly
or via new, are actually function values. Table 1 gives the
generation rates for stocompared to clp.
We can group the predicates based on their behaviors:,
with js-err in one class and js-overflow ,js-inher , and
js-withclo in the other class. For js-err , fully 85% of
the unique programs are interesting. While clpgenerates
slightly fewer total programs than sto, it generates 2.3as
many interesting programs during the same period of time.
This is the best that stodoes in comparison to clp, and the
two major reasons are that (1) for this predicate we are using
an unsound type system, thus it is easier for the stochastic
grammar to generate programs matching the predicate; and
(2) for this predicate we bound the search space for both
stoandclpto programs whose abstract syntax trees are
at most height seven. Both of these facts favor stoin our
experiments; by making the type system more sound or by
increasing the bound on program size, clpwould do pro-
gressively better than sto.
The remaining three predicates have a very dierent story.
Theinteresting generation rate for stois 0 or very close
to 0, while the generation rate for clpfor two of the pred-
729Predicate total unique interesting clpclp
interesting
js-err 53,335 28,614 24,210 56,658 2.3
js-overflow 49,635 22,631 0.303 1,229 4,056
js-inher 20,677 11,195 0304,890 1
js-withclo 31,458 17,132 0.057 302,472 5,306,526
Table 1: Generation rate of sto versus clp, in units of programs per second. We report total, unique, and
interesting separately for sto; they are all the same number for clp. The last column is the ratio between the
clp and sto interesting program generation rates (higher is better for clp).
icates is 10{15higher than sto'stotal generation rate.
The reason that clpis so much faster than stoin this case
is because stois randomly searching the space, i.e., each
time it nds a program it restarts the search from scratch.
In contrast, clpis using bounded depth-rst search, i.e.,
when it nds a program it searches the nearby space to nd
other programs as well. The behavior of stois characteristic
of stochastic grammars, not specic to our implementation.
Theclpgeneration rate for js-overflow is much lower than
theclpgeneration rate for the other predicates because js-
overflow heavily exercises the constraint solver.
6. CONCLUSIONS AND FUTURE WORK
In this paper we have demonstrated that constraint logic
programming is a promising technique to automatically gen-
erate programs for language fuzzing. CLP-based program
generation has several desirable properties, including the
ability to target program generation for specic combina-
tions of syntactic features and semantic behaviors. We have
empirically demonstrated those properties and their benets
in comparison to stochastic grammars, focusing on JavaScript
program generation. Our results show that the CLP-based
approach does signicantly better than stochastic grammars
for generating interesting programs.
There are several avenues for advancing this work in the
future. One idea is to apply CLP to generate interesting
programs in other kinds of languages, such as strongly stati-
cally typed (e.g., Scala) or weakly statically typed (e.g., C).
Another possibility is to modify the CLP engine to replace
the numeric constraint solver with a more powerful SMT
solver, with access to more theories such as the theory of
strings or the theory of bit-vectors. An application of this
improved engine might be to automatically generate inter-
esting hardware designs to fuzz hardware synthesis tools.
7. REFERENCES
[1] C. Boyapati, S. Khurshid, and D. Marinov. Korat: automated
testing based on java predicates. In Proceedings of the 2002
ACM SIGSOFT international symposium on Software testing
and analysis, ISSTA '02, pages 123{133, New York, NY, USA,
2002. ACM.
[2] B. Daniel, D. Dig, K. Garcia, and D. Marinov. Automated
testing of refactoring engines. In Proceedings of the the 6th
joint meeting of the European software engineering
conference and the ACM SIGSOFT symposium on The
foundations of software engineering , ESEC-FSE '07, pages
185{194, New York, NY, USA, 2007. ACM.
[3] M. Gligoric, T. Gvero, V. Jagannath, S. Khurshid, V. Kuncak,
and D. Marinov. Test generation through programming in
udita. In Proceedings of the 32nd ACM/IEEE International
Conference on Software Engineering - Volume 1 , ICSE '10,
pages 225{234, New York, NY, USA, 2010. ACM.
[4] A. Groce, G. J. Holzmann, and R. Joshi. Randomized
dierential testing as a prelude to formal verication. In ICSE,
pages 621{631. IEEE Computer Society, 2007.[5] C. Holler, K. Herzig, and A. Zeller. Fuzzing with code
fragments. In Proceedings of the 21st USENIX conference on
Security symposium , Security'12, pages 38{38, Berkeley, CA,
USA, 2012. USENIX Association.
[6] D. Jackson. Alloy: a lightweight object modelling notation.
ACM Trans. Softw. Eng. Methodol., 11(2):256{290, Apr. 2002.
[7] J. Jaar and J.-L. Lassez. Constraint logic programming. In
Proceedings of the 14th ACM SIGACT-SIGPLAN symposium
on Principles of programming languages , POPL '87, pages
111{119, New York, NY, USA, 1987. ACM.
[8] J. Jaar and M. J. Maher. Constraint logic programming:
A survey. Journal of Logic Programming , 19:503{581, 1994.
[9] Y. Lei and J. H. Andrews. Minimization of randomized unit
test cases. In Proceedings of the 16th IEEE International
Symposium on Software Reliability Engineering , ISSRE '05,
pages 267{276, Washington, DC, USA, 2005. IEEE Computer
Society.
[10] D. Marinov and S. Khurshid. Testera: A novel framework for
automated testing of java programs. In Proceedings of the 16th
IEEE International Conference on Automated Software
Engineering , ASE '01, pages 22{, Washington, DC, USA, 2001.
IEEE Computer Society.
[11] W. M. McKeeman. Dierential testing for software. Digital
Technical Journal , 10(1):100{107, December 1998.
[12] J. Regehr, Y. Chen, P. Cuoq, E. Eide, C. Ellison, and X. Yang.
Test-case reduction for c compiler bugs. In Proceedings of the
33rd ACM SIGPLAN conference on Programming Language
Design and Implementation , PLDI '12, pages 335{346, New
York, NY, USA, 2012. ACM.
[13] J. Ruderman. Introducing jsfunfuzz, 2007.
[14] J. Ruderman. Introducing lithium, a testcase reduction tool,
2007.
[15] M. Sridharan, S. J. Fink, and R. Bodik. Thin slicing. In
Proceedings of the 2007 ACM SIGPLAN conference on
Programming language design and implementation , PLDI '07,
pages 112{122, New York, NY, USA, 2007. ACM.
[16] K. Sullivan, J. Yang, D. Coppit, S. Khurshid, and D. Jackson.
Software assurance by bounded exhaustive testing. In
Proceedings of the 2004 ACM SIGSOFT International
Symposium on Software Testing and Analysis , ISSTA '04,
pages 133{142, New York, NY, USA, 2004. ACM.
[17] F. Tip. A survey of program slicing techniques. J. Prog. Lang.,
3(3), 1995.
[18] J. Wielemaker, T. Schrijvers, M. Triska, and T. Lager.
SWI-Prolog. Theory and Practice of Logic Programming ,
12(1-2):67{96, 2012.
[19] X. Yang, Y. Chen, E. Eide, and J. Regehr. Finding and
understanding bugs in c compilers. In Proceedings of the 32nd
ACM SIGPLAN conference on Programming language design
and implementation , PLDI '11, pages 283{294, New York, NY,
USA, 2011. ACM.
[20] A. Zeller. Isolating cause-eect chains from computer programs.
InProceedings of the 10th ACM SIGSOFT symposium on
Foundations of software engineering , SIGSOFT '02/FSE-10,
pages 1{10, New York, NY, USA, 2002. ACM.
[21] A. Zeller and R. Hildebrandt. Simplifying and isolating
failure-inducing input. IEEE Trans. Softw. Eng.,
28(2):183{200, Feb. 2002.
730