Customized Awareness:
Recommending Relevant External Change Events
Reid Holmes
Department of Computer Science & Engineering
University of Washington
Seattle, WA, USA
rtholmes@cs.washington.eduRobert J. Walker
Department of Computer Science
University of Calgary
Calgary, AB, Canada
walker@ucalgary.ca
ABSTRACT
It is often assumed that developers' view of their system and
its environment is always consistent with everyone else's; in
practice, this assumption can be false, as the developer has
little practical control over changes to the environments in
which their code will be deployed. To proactively respond to
such situations, developers must constantly monitor a ood
of information involving changes to the deployment environ-
ments; unfortunately, the vast majority of this information is
irrelevant to the individual developer, and its sheer volume
makes it likely that infrequent change events of relevance
are overlooked. As a result, errors may arise at deployment
time that the developer does not immediately detect.
This paper presents a recommendation approach for lter-
ing the ood of change events on deployment dependencies
to those that are most likely to cause problems for the indi-
vidual developer. The approach is evaluated for its ability
to drastically lter irrelevant details, while being unlikely
to lter important ones. The relevance of the results is as-
sessed on the basis of deployment problems that would have
historically occurred within a set of industrial systems.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement; K.6.3 [ Management of Computing
and Information Systems ]: Software Management| soft-
ware maintenance ; H.1.2 [ Models and Principles ]: User/
Machine Systems| human factors
General Terms
Human Factors, Reliability, Design, Experimentation
Keywords
Change events, deployment environment, external depen-
dencies, information overload, developer-specic awareness,
customized awareness, recommendation system, YooHoo.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô10, May 2‚Äì8, 2010, Cape Town, South Africa
Copyright 2010 ACM 978-1-60558-719-6/10/05 ...$10.00.1. INTRODUCTION
A basic assumption of many development approaches is that
every member of an organization (or group of organizations)
always has a consistent view of their system, modulo any
changes each developer is currently work on. Because of this
model, it is assumed that any change a developer makes to
their source code will be immediately noticed by everyone
else. Unfortunately, this assumption does not always hold
in practice [ 3,9,8].
As systems are rarely written entirely from scratch, build-
ing instead atop existing frameworks, libraries, and other
systems, changes to this existing code have the potential to
impact the developer. For example, one approach to support
the extension of systems is through a plug-in infrastructure.
The plug-in developer must cede some control over the exter-
nal environment in which the plug-in can be installed: while
the developer created the plug-in in a development environ-
ment that used version nof a framework, a user may try to
deploy the plug-in in an environment that uses version n+k.
If the developer is not aware of the changes between the two
framework versions that will aect their plug-in, the plug-in
may fail and it could take a long time before the developer
hears of, and responds to, the problems.
As a concrete example, the Eclipse Metrics plug-in is de-
pendent on code from 17 external projects; while its devel-
opers made only 643 le revisions to their own code between
2004 and 2008, the systems that Metrics depends on made
135,972 le revisions, an overwhelming volume of changes to
keep abreast of, especially considering the majority of these
changes will not impact the relatively small functionality
from each external project on which Metrics depends.
Current plug-in infrastructures do not suce to eliminate
such issues; at best, the developer can prohibit deployment if
a too-new version of a framework would be used, but devel-
opers are understandably reluctant to prohibit deployment
before they know that a problem actually exists|it would
immediately and often unnecessarily limit who could deploy
their plug-in. Although the plug-in developer may not be
a member of the team that maintains the framework, their
plug-in can still be aected by the actions of an external
framework developer.
The main problem in such situations is that some exter-
nal change may occur that could break the developer's code
when it is deployed, but the developer will not immediately
be aware of it [ 9]. The time delay between the change be-
ing made and the problem being detected exacerbates the
eects of the problem [ 12], as users' opinions of the qual-
ity of the product or the time available for repairing theissues can be severely reduced. Furthermore, such a delay
impedes the developer's ability to inform the author of the
initial change of the detrimental impact of the change, and
to have them respond with a reasonable compromise [ 3].
It has been shown that facilitating communication between
the right people can decrease the time required to resolve
technical problems [ 5].
One way to avoid these situations is for the developer to
monitor all the changes happening to externally depended-
upon projects and to act upon these immediately. Ulti-
mately, keeping track of all these projects and their changes,
while being focused on the repair and extension of the de-
veloper's own product, is an onerous task that is easy to
perform poorly [ 8]. The majority of these external changes
simply are not relevant to the developer's own code; the few
that are relevant can easily be lost in the noise.
To overcome the burden of managing a high volume of
mostly-irrelevant changes, and the eort required to monitor
changes across many dierent projects, we present the Yoo-
Hoo system. YooHoo analyzes each change to a depended-
upon project for its potential impact on the developer's code,
and thereby creates custom change event streams that rec-
ommend change events as relevant to a specic developer.
We evaluated YooHoo's ability to reduce the level of noise
while not suppressing impactful events, by examining the
historical changes to a set of industrial systems. For each
system, we obtained an old version along with its deploy-
ment environment, analyzed its external dependencies, and
used YooHoo to see which change events on these dependen-
cies would have been announced to the system's develop-
ers. To quantify the confusion matrix, we analyzed whether
these events would have caused problems in deployment and
whether they were ever actually acted upon by the system's
developer. We found that the cumulative true positive rate
was 93% and that the cumulative false positive rate was
nearly 0%. In addition, we examine the prospects for reduc-
ing the potential false positives and false negatives in the
rare circumstances where they could conceivably occur.
Section 2describes two problematic scenarios where cus-
tomized awareness of external changes could be benecial.
Related work is provided in Section 3. Our approach is
described in Section 4, while our evaluation is detailed in
Section 5. Remaining issues are discussed in Section 6.
2. MOTIVATION
We illustrate two problematic scenarios involving keeping
appraised of potential deployment problems due to changes
in externally depended-upon projects.
2.1 Large development teams
Large development teams are often split into many sub-
teams, each of which works on an isolated branch of the main
source code repository. Integration engineers integrate these
branches with the head of the repository at regular intervals
and reverse-integrate the head back down into each of the
sub-team branches. For some large teams, their branch may
be integrated with the head of the repository only twice a
month; in these situations, it could take as long as a month
for a change from one team to be distributed to every other
developer on all the sub-teams (two weeks up and two weeks
back down into all other branches).
Consider the situation of Elliott, a developer on the sub-
team that maintains the core component of a large applica-tion. Elliott needs to make a change to the calculate(..)
method's pre-conditions in the core component; he searches
the repository and nding no conicts, makes the change.
One month later Lorenzo, a developer on the UI compo-
nent sub-team, nds that his code has broken. Although he
did not change anything, the integration engineers reverse-
integrated Elliott's changes into his development branch
overnight, and his CalculateAction class breaks; Elliott did
not nd Lorenzo's dependency because his code had not yet
been integrated into his repository. Now, Lorenzo must di-
agnose the problem, le a bug with the core team, and x
Elliott's code temporarily, until the ocial changes are dis-
tributed through another integration cycle.
The time lag in this scenario makes it dicult to assess
the original failure and increases the likelihood that another
developer may take a dependency on the ocial but incor-
rect version of the calculate(..) method, rather than the
version that Elliott will create in response to Lorenzo's bug
report. While this bug may have been avoided if Lorenzo
had noticed Elliott's change to calculate(..) when it
happened, keeping abreast of changes on a single sub-team
is dicult enough, without considering other development
branches.
2.2 Plug-in infrastructures
Consider the situation of Stefania, an Eclipse plug-in de-
veloper. Her plug-in uses functionality from ve dierent
Eclipse plug-ins, two Apache projects, and one system she
found on SourceForge. When Laura installed Stefania's
plug-in into her environment it failed to behave as she ex-
pected. After several frustrating rounds of emails, Stefania
realizes that Laura has new versions of three of the eight
external dependencies that her plug-in uses. Keeping up
on the changes of these eight projects is overwhelming so
Stefania never realized her code was aected by any of the
changes these projects had made; after debugging her plug-
in with the new versions of the dependencies she is able to
resolve Laura's problem.
In this scenario, Laura has changed the external envi-
ronment for Stefania's plug-in in a way that the plug-in
was not designed to accommodate. While Stefania ideally
would have kept herself current on changes within Eclipse,
the Apache projects, and the SourceForge project, the sheer
volume of changes overwhelmed her ability to track them.
2.3 Drinking from the Ô¨Åre hose
In both of our motivational scenarios, environmental
changes, beyond the control of the developer, introduced
errors into his or her system at deployment time. If the de-
veloper kept appraised of these external changes, the code
could have been adapted to work with the modied envi-
ronment; however, keeping appraised can be very expensive.
Figure 1gives a sample of the arcane detail that further ob-
scures the actual signicance of an individual commit mes-
sage; Table 1demonstrates the volume of commit messages
for a 1-year period for several projects. Reading each mes-
sage, interpreting its key content, and analyzing its potential
impact on one's code would be an enormous chore.
3. RELATED WORK
Gross and Prinz [ 16] describe the need to present awareness
information in the context of the user's current work activi-
ties, but do not go beyond a general model; our focus on theSubject: [r9g-cvs] [hg] refactoring.java: #144961: fixing NPE
From: Jan P. <jp... (at) netbeans.org>
Message-id: hg.abbaf0f1ff63.1219918286.1797694213 (at)
hg.netbeans.org
Date: 2008-08-28 12:11:26
changeset abbaf0f1ff63 in main
details: http://hg.netbeans.org/main?cmd=changes baf0f1ff63
description:
#144961: fixing NPE
diffs (12 lines):
diff -r eb7c38562250 -r abbaf0f1ff63
a/refactoring.java/src/org/netbeans/modules/refactoring/java/ui/
UIUtilities.java
b/refactoring.java/src/org/netbeans/modules/refactoring/java/ui/
UIUtilities.java
Aug 28 12:03:58 2008 +0200
@@ -92,7 +92,7 @@ public final class UIUtilities {
headerRenderer = table.getTableHeader().
getDefaultRenderer();
}
Component comp = headerRenderer.
getTableCellRendererComponent(
- null, column.getHeaderValue(), false, false, 0, 0);
+ table, column.getHeaderValue(), false, false, 0, 0);
int width = comp.getPreferredSize().width;
Figure 1: A sample NetBeans commit message.
specic problem of maintaining awareness of environmen-
tal changes allows for a solution that can eliminate details
that are irrelevant to an individual developer. Cataldo
et al. [ 5] demonstrate that developers complete tasks more
quickly when they are able to coordinate with the right peo-
ple; our approach is complementary to theirs, focusing on
inferring relationships between developers from the source
code, rather than explicitly-provided links extracted from
issue tracking systems.
The need for coordination support in software develop-
ment has long been recognized (e.g., [ 19]). Much of this
research has focused around software conguration manage-
ment (SCM) systems as the key interaction point (e.g., [ 15,
1]). Various work has considered the problem of conicting
edits within team development situations (e.g., [ 23]); our
problem is signicantly dierent due to its lack of a single,
consistent repository to analyze.
De Souza et al. [ 9] identied problems in crossing the
boundary from project-private information to project-public
information, that lead to rough transitions even within
teams, despite the application of tools that support it. Co-
ordination and change awareness have moved beyond the
artifacts contained within SCM systems, by also drawing
upon the process-related metadata contained therein [ 10,6,
11]; we continue this trend in our approach.
The Jazz system provides the concept of a feedthat lists
Project Total Daily
FreeBSD 37,843 151
KDE 128,755 515
Linux kernel 39,155 157
MySQL 19,366 77
NetBeans 88,293 353
Open Oce 126,272 505
Table 1: Message trac on the commit mailing
lists for several prominent software systems between
June 1, 2007 and May 31, 2008. Daily average is
based on 5 workdays/week, 50 weeks/year.many recent changes to the system and provides an overview
of what other team members are working on [ 6]; we adapt
the feed concept to a narrow focus on what relevant changes
have occurred. Mylyn elides various elements in an IDE
to help the developer focus on their current task [ 18]; the
developer's current task is largely irrelevant in our context.
Continuous integration (CI) tools can help a project team
stay appraised of changes, builds, and tests; examples of
these systems include Trac1and Cruise Control. Unfortu-
nately, CI tools do not currently address version changes
between organizations (e.g., external changes) or automati-
cally congure new deployment environments. We view our
approach as being complimentary to CI tools and could fore-
see integrating them to deliver project-specic (rather than
developer-specic) notications.
Fitzpatrick et al. [ 13] have examined the coordinated use
of SCM systems, notication lists, and instant messaging in
coordination. All these approaches suer the same issues of
information overload for external developers who depend on
them [ 17,20].
Palant r provides an online view of how developers are
modifying their source before it is committed, enabling de-
velopers to predict future changes [ 24]. FishEye is one of
many commercial products used for visualizing the over-
all activity within an SCM repository. The War Room
Command Console [ 22] and FASTDash [ 2] provide real-
time awareness systems to teams showing who is working
on what code elements at any one time. Each of these ap-
proaches provides a global view that|while useful for vari-
ous purposes|does not meet the needs of developer-specic
support. Sarma et al. have also examined the needs of mul-
tiple teams working in concert on shared artifacts and ex-
tended Palant r to support it [ 26]; Sarma et al. have also
performed notable work in evaluating awareness in SCM sys-
tems [ 27,25]. However, their situation is quite dierent from
our producer{consumer context.
Ideally, we would analyze the precise semantic eects of
the changes made in external projects; unfortunately, this
is not possible in the general case due to formal undecid-
ability [ 21]. Otherwise, we might detect changes in external
application programming interfaces (APIs), and recommend
changes to the developer's client code [ 28,7]; however, for
some projects, such recommendations will not be possible
due to a lack of example transformations to mine. Further-
more, the correct course of action may not be as simple as
replacing one method call with another.
There are a number of techniques for dierencing source
code versions to detect and classify changes|a necessary
step if they are to be ltered on the basis of category; a no-
table, recent representative is the Change Distiller approach
of Fluri et al. [ 14] that we apply in our solution. Canfora and
Cerulo [ 4] demonstrate that ne-grained indexing of change
repositories can help to track which changes were made to
address which bugs; we apply a similar technique to track
ne-grained changes.
4. APPROACH
To combat the volume of irrelevant change notications
we present YooHoo, a system for recommending external
change events as impacting a specic developer.
1We do not provide URLs for tools that are easily located
via a web search.YooHoo has been designed to improve the key shortcom-
ings of general change notication systems by providing the
following three benets. (1) YooHoo only provides develop-
ers with recommendations about changes that are relevant
to them. Every change notication that the developer re-
ceives will be provided because a change was made to a
resource that their code is dependent upon. Through this
ltering mechanism, YooHoo eliminates the vast majority
of change notications. (2) YooHoo categorizes changes by
their potential to impact the specic developer's source code.
This categorization enables them to further reduce the mes-
sage trac that they must consider by enabling them to ig-
nore changes that are unlikely to break their deployed code,
if they so choose. (3) YooHoo integrates the change notica-
tions from many isolated data sources, enabling potentially-
relevant changes to be considered in a single location. Sim-
ply locating and navigating through each repository places
a high burden on developers.
YooHoo has two main kinds of component: generic change
analysis (GCA) engines , each of which delivers a stream of
change events about a project without tailoring to the needs
of an individual developer; and developer-specic analysis
(DSA) engines , each of which selects a set of GCA engines
based on the project dependencies of the developer, and l-
ters and renes the generic change event stream based on
an estimate of the change impact on the developer's code.
As a result, the developer receives recommendations about
changes to his code's deployment environment that are very
likely to cause failure, plus purely informational notications
about API changes and other project-related information
that are estimated to be of interest to him. GCA engines
typically run alongside the SCM that they monitor, while
DSA engines run on the client's machine (typically within an
IDE). A central YooHoo GCA dispatcher connects DSA en-
gines with the GCA engines they require. YooHoo presently
only analyzes changes to Java source code.
4.1 Generic change analysis engines
Each GCA engine monitors a source control repository (ad-
apters for CVS and Subversion are currently supported)
for commit events and alterations to repository tags and
branches. When a change to the repository is detected, it
is analyzed and one or more change events are recorded in
the engine's internal database. When a GCA engine is ini-
tialized it can be set to follow a particular development tree
(e.g., the repository head or a specic branch) to reduce the
number of false positive changes it detects (e.g., to avoid re-
porting changes on an experimental branch that will never
be integrated into the main development tree). Each GCA
engine provides a communication interface for clients to ob-
tain change events based on their generic impact, times-
tamp, and structural name.
The GCA engine can also compare sets of les, instead of
using a source control repository. For example, the changes
between the standard libraries provided by Java 1.5 (J2SE
5.0) and Java 1.6 (Java SE 6) can be inferred by comparing
the source of the two versions. The drawback of performing
an analysis at the le-level is that all the changes are grouped
into a single revision set and the additional metadata pro-
vided by the SCM repository is absent. By not requiring ac-
cess to the SCM repository, the GCA can compute changes
for situations where the SCM repository is unavailable (e.g.,
prior to Java SE 6 the Java standard library SCM repositorywas not publicly accessible). This mechanism also enables
changes to be determined on a release-by-release basis by
only analyzing signicant copies of the repository, rather
than incremental changes as they are made.
Our GCA engine prototype implementation utilizes the
Change Distiller system [ 14] as a preliminary means to an-
alyze the changes. By analyzing the abstract syntax trees
(ASTs) associated with a le before and after a commit,
Change Distiller can classify the change into one of 35 dif-
ferent categories. YooHoo collapses some of these cate-
gories (e.g., \condition change" and \statement change" are
currently treated simply as \implementation change") and
adds others (e.g., \entity deprecated") to announce events
at a granularity that seems most relevant to detecting API
changes that might impact some developer in some situ-
ation. The kinds of change events currently recorded are
listed in Table 2; we currently make no attempt to detect
compound events such as refactoring (e.g., a pull-up refac-
tor would delete a method from one type, and add a new
identical method further up the type hierarchy). We discuss
the costs and benets of such extensions in Section 6.1.
Potentially impactful events
Non-private type/method/eld added
Non-private type/method/eld deleted
Non-private eld type changed
Non-private method result type changed
Type/method/eld visibility increased
Type/method/eld visibility decreased
Type/method/eld deprecated
Type/method/eld undeprecated
Type/method/eld nalized
Type/method/eld unnalized
Supertype added
Supertype removed
Implementation changed
Potentially informative events
New branch
New tag
Javadoc modied
Table 2: Change events announced by GCA engines.
4.2 Developer-speciÔ¨Åc analysis engines
Each DSA engine consists of three subcomponents: code
ownership analysis ,external dependency analysis , and
change impact estimation .
4.2.1 Code ownership analysis
DSA engines can automatically determine the les of rele-
vance to an individual developer. Automatic analysis de-
termines which les a developer has recently committed; a
congurable horizon based on le age or number of interven-
ing revisions can be used to ignore les that have not been
altered by the developer for some time or for which someone
else seems to have taken over the maintenance. The devel-
oper can also indicate individual les, packages, or projects
that are always to be ignored or always to be watched, over-
riding the automated analysis.4.2.2 External dependency analysis
Once the developer's set of watched resources has been iden-
tied, the DSA engine then determines the external depen-
dencies that those resources have. DSA engines are currently
implemented as plug-ins to the Eclipse IDE, allowing them
to utilize project information about depended-upon versions
of external projects. By statically analyzing the source code
and project information, a DSA engine identies all the elds
accessed, methods called, types accessed, and subtype rela-
tionships within the resources of interest.
This set provides YooHoo with a watch list of external
resources that the developer is dependent upon and is au-
tomatically updated on a semi-regular basis to ensure the
correct dependencies are being monitored. Changes made
to resources that are not in this set are ltered by YooHoo
as irrelevant to the developer. YooHoo can then determine
which external resources already have associated GCA en-
gines, and points the developer's DSA engine to these. The
developer is warned about external resources without asso-
ciated GCA engines; by proving a location for the appro-
priate repository|along with the appropriate authentica-
tion credentials where needed|YooHoo automatically con-
structs and populates a new GCA engine for each.
4.2.3 Change impact estimation
DSA engines periodically retrieve change events for the de-
veloper's dependent resources based on their timestamp;
generally since the engine's last access or from a specic date
(if YooHoo is freshly deployed by the developer). Change
events not related to the dependencies in the watch list are
immediately ignored. All other events are further analyzed
to categorize their severity of impact on the developer's code:
Impactful events. AnImpactful event is one that
the DSA estimates is likely to break the specic de-
veloper's code in some way. These generally involve
changes that alter the external appearance of an API.
Uncertain events. These events cannot be ruled out
as breaking the developer's code, though it is unlikely.
Uncertain events arise due to our imprecise analyses.
In some cases a more precise analysis is readily avail-
able that a future version of YooHoo could apply (see
Section 6.1). Other cases involve potential behaviour-
breaking changes that have a remote chance of prop-
agating through an API. Pragmatism suggests that
internal implementation changes will very rarely prop-
agate through the API unless the API itself changes,
which is, after all, the purpose of an API. In the end,
allUncertain events could be recategorized usefully;
we have retained them at this point to study whether
they are really problematic or not (see Section 5).
Information events. Information events indicate a
change that the developer might want to be aware of
if they have the time to consider alternative implemen-
tations, or changes that involve the depended-upon en-
tities that do not denitively have an impact (e.g., up-
dated documentation).
The resulting kinds of events and their severity are listed
in Table 3, where \dependency" is dened as statically mak-
ing reference to the entity in question. The current imple-
mentation does not attempt to be very precise in its impact
analysis: for example, the removal of a supertype relation-
ship is always recommended for attention ( Impactful ) evenImpactful events
Depended-on type/method/eld deleted
Depended-on eld type changed
Depended-on method result type changed
Depended-on type/eld/method deprecated
Depended-on type/eld/method visibility decreased
Uncertain events
Depended-on type/eld/method nalized
Type/method/eld added to depended-upon type
Supertype removed from a depended-on type
Supertype added to a depended-on type
Implementation changed for depended-on method
Information events
Public type added to depended-on package
Depended-on type/method/eld visibility increased
Depended-on type/method/eld undeprecated
Depended-on type/method/eld unnalized
New tag in depended-on project source repository
New branch in depended-on project source repository
Table 3: Developer-specic change events as classi-
ed by default by a DSA engine.
though it will not matter if the original supertype is not
explicitly depended upon (like in a cast expression), if the
methods inherited from it are to be found elsewhere in the
remaining hierarchy, or if the methods inherited from it are
not depended upon at all. We consider the costs and benets
of rening the classication analysis in Section 6.1.
The developer can choose to downgrade or upgrade event
classications on a global or per-project basis. For example,
he may be aware that parts of his code depend tightly on the
current structure of the type hierarchy (such as which type
implements a given method), so changes to the hierarchy
will denitely have to be checked: he would likely make
supertype changes Impactful rather than Uncertain in
such a situation.
Finally, recommendations for relevant change events need
to be announced to the developer. Our current implemen-
tation is simple in this regards, presenting results in an
Eclipse view for each externally depended-upon project (see
Figure 2). As the goal of our prototype implementation is
to evaluate whether such a classication and ltration ap-
proach would actually signicantly reduce the ow of events
without missing many important changes (i.e., the useful-
ness of the approach), this suces. A more usable, real
world deployment could involve in-line notications (like
Eclipse's \lightbulb" marginal annotations) and/or under-
lining annotations (see Figure 3for a mock-up). As YooHoo
knows both how a depended-upon element changed and how
the developer used that element, change notications can
be very specic for the developer. Rather than a generic
statement like \ ITableSelectionListener has been depre-
cated", YooHoo can be more specic and report, \ ITable-
SelectionListener from the jface project has been depre-
cated; your IResultsView interface is impacted." This kind
of message is much more meaningful for the developer and
can even point them in the right direction for resolving the
problem.Figure 2: Developer-specic change awareness view.
Figure 3: Mock-up of an annotation-based notication alternative.
4.3 Application to the motivational scenarios
YooHoo should enable developers to keep appraised of all
the relevant changes happening on multiple branches of a
source code repository, or to follow the development of a
large framework, without being overwhelmed by irrelevant
changes. YooHoo also enables the rationale for the change's
relevance to be viewed by the developer; e.g., in the rst sce-
nario, YooHoo could state to Lorenzo that \Elliott changed
thecalculate(...) method signature: this will cause an
error in your CalculateAction class." In the rst scenario,
Lorenzo's YooHoo notication stream would alert him to
anyImpactful changes made to code that he depends upon
across any development branch in the repository. In this way
he could contact Elliott immediately about how he would
be impacted, or to immediately respond by modifying his
CalculateAction class. For the second scenario, using Yoo-
Hoo Stefania could monitor all the changes in her depen-
dent projects without becoming overwhelmed; rather than
having to sift through thousands of changes, YooHoo would
promote at most tens of changes for her to react to. In
both of these situations the developer is able to act proac-
tively to changes in external resources, rather than reacting
to breakage when it happens.
5. EVALUATION
Our evaluation addresses four main research questions:
RQ1: \How well is the change event stream compressed?"
RQ2: \Are the Impactful events actually impactful?"
RQ3: \Are any impactful events erroneously ltered?"
RQ4: \Would a simple approach to surfacing informational
but non-impactful events again ood the developer?"
We performed a retroactive analysis of 5 deployed projects
to answer the questions. These projects were selected arbi-
trarily from a set of Eclipse-based tools that we were familiar
with that we considered to be somewhat mature. As Eclipsecomprises a large number of plug-ins (more than 400 in ver-
sion 3.5) and also heavily uses many other external projects
(more than 75 in version 3.5) it seemed like an ideal platform
to study. The 5 projects were:
Metrics: source code metric calculator.2
RSSOwl: cross-platform RSS reader.
ASM Plugin: bytecode instrumentation integration.
Colorer: multi-language syntax highlighting.
Checkstyle: coding standard enforcement tool.
Table 4describes the number and kinds of external depen-
dencies in each of the analyzed projects.
5.1 Methodology and results
In order to watch change events on these 5 projects and vari-
ous others that we tested YooHoo on while developing it, we
ultimately created GCA engines for 70 individual projects
(including 47 Eclipse projects and 7 Apache projects). These
repositories consisted of the entire length of history we could
extract from each project's source repository; in the case
of Eclipse this history was generally available from 2001 to
present. This required analyzing more than 210 MLOC of
source code. The GCA repositories ultimately contained in-
formation about 640,000 revisions to 65,000 resources by 370
2http://metrics.sf.net
System External dependencies
Projects Types Methods Fields
Metrics 17 229 736 347
RSSOwl 7 139 502 232
ASM 19 193 461 75
Colorer 13 102 242 58
Checkstyle 10 117 233 64
Table 4: Quantity of external dependencies.Project External Changes YooHoo Recommendations
(or dev.) Start End Rev. sets Revs. Events Impactful Uncertain Info. Irrelevant
Metrics 06/2004 06/2008 29,770 135,972 619,175 12 1,725 396 617,042
sauerf 9 674 273 618,219
donv70 0 790 60 618,325
RSSOwl 06/2004 06/2008 6,137 42,377 98,941 7 2,627 416 95,891
bpasero 3 2,323 375 96,240
ijuma 0 1,068 166 97,707
ASM Plugin 05/2005 06/2008 6,502 119,912 580,810 5 1,347 307 579,151
Colorer 06/2004 06/2008 14,274 73,199 223,527 12 1,004 309 222,202
Checkstyle 06/2004 06/2008 17,183 84,591 382,664 6 604 266 381,788
Table 5: Scale of revision sets and # of external changes made during the evaluation period.
developers resulting in over 2,750,000 change events. While
populating this initial repository took several days, keep-
ing the repository consistent took less than one minute per
indexed project per day (and this is fully parallelizable).
RQ1: Event stream compression.
For each of the 5 analyzed projects, we selected a start and
end date for the analysis. We built each project and ex-
tracted its structural dependencies, as these existed on the
start date. Building these projects correctly several years
after the fact was laborious3; thus, we did not revise our
analysis of the structural dependencies for the project for
the length of the study (ultimately, this choice did not ap-
pear to cause problems with the results of the study). We
generated the DSA change feeds for each project, as well
as at least one specic developer on that project, on the
end date. This list comprised all the impactful, informa-
tion, and uncertain events for the developer or project, as
well as a count of the irrelevant events. These results can
be found in Table 5, clearly demonstrating the answer to re-
search question RQ1 : the cumulative compression of these
change event streams is well over 99%.
RQ2: Correctness of impactful recommendations.
To analyze the accuracy of YooHoo's classications, we ex-
amined the ltered event stream for a putative developer
who \owned" the entire project to be analyzed. The small
number of Impactful events were manually inspected to
determine their nature and whether a corresponding change
was ever made (by August 2009) to adapt to the change.
By building the version of the system from the start of
the study period but with the version of the project's ex-
ternal dependencies at the end of the study period, we were
able to use the code itself as an oracle: any compilation er-
rors that arose should have been recommended as impactful
by YooHoo. We compared the compilation errors against
the YooHoo Impactful events; any error that was not re-
ported as Impactful was considered a false negative. We
also looked at the state of the code to conrm that each
error listed as impactful by YooHoo was also really xed by
a developer; these were considered true positives, while if
the developer did not make the change, or they were not
really impactful, they were considered false positives. Some
events are deliberately recommended for attention although
3Note that this diculty is purely an artifact of our evalua-
tion. YooHoo does not need to build projects to perform its
function.the developer has the option to do nothing about them|
in particular, deprecation events; we always count these as
true positive events, regardless of whether an intervention
ensued, although we did ensure that the deprecation event
really happened and was applicable to the developer.
RQ3: Missing impactful notiÔ¨Åcations.
Negative events were so voluminous that manually deter-
mining if any of these events should have been impactful
was impractical. We made three alternative pragmatic at-
tempts to nd false negatives. (a) We note that the major-
ity of the event kinds that could cause new bugs would also
cause compile-time issues, so compilation was again used
to identify any problems that would have arisen from non-
recommended events without corresponding changes. Imple-
mentation changes that did not aect the structural depen-
dencies of the code base would not have resulted in problems
from the compilation test procedure; errors arising from such
changes cannot be perfectly detected, but we made two at-
tempts to look for them, as follows. (b) We wished to run
the test suites to ensure whether the analyzed projects would
have deployed reliably, but we could not locate non-trivial
test suites for these 5 projects. (c) Instead, we attempted
to run the projects and exercise the functionality manually;
this did not yield any additional false negatives.
The results from these analyses are shown in Table 6,
wherein only Impactful events are considered positives
(true or false). In response to research questions RQ2 and
RQ3 , we estimate that|on average for these 5 systems|
actual positive events are classied as positive 93% of the
time (the true positive rate, TPR) and actual negative
events are misclassied as positive 0.000007% of the time
(the false positive rate, FPR). This means that impactful
change events are almost always recommended by YooHoo
and that non-impactful changes are almost never falsely rec-
ommended by YooHoo. Looking at the detailed results (Sec-
tion 5.2), we can see specic targets for improvement. In
contrast to Table 6, a developer who is not keeping appraised
of any changes would have a precision, recall, and true posi-
tive rate of 0, but would not have to proactively consider any
change events until his code breaks; since YooHoo provides
results with little noise or omissions, this does not seem to
be a good alternative.
RQ4: Volume of information events.
Finally, we can see that, despite a potentially large number
of change events being classied as Information , the de-Project TP FP TN FN TPR FPR
Metrics 10 2 619,163 0 1.00 0
RSSOwl 0 7 98,934 0 | 0
ASM 2 3 580,804 1 0.67 0
Colorer 10 2 223,515 0 1.00 0
Checkstyle 5 0 382,658 1 0.83 0
cumulative 27 14 1,905,074 2 0.93 0
Table 6: Evaluation of the quality of the results pro-
vided by YooHoo for the evaluation period.
veloper would not have been hard-pressed to keep up with
this trickle of information|in the worst case here, 416 In-
formation events in 4 years translates to one message ev-
ery other working day. On the other hand, one would need
to be careful before simply re-categorizing the Uncertain
events as Information : with about 4,000 events combined
in the worst case, this translates to roughly 4 messages every
working day. While not a ood, splitting one's attention be-
tween multiple projects, falling behind on the notications
for a few days could easily turn into an ignored and thus use-
less backlog. Research question RQ4 is answered by saying
that the Information events alone are few enough that they
would not be overwhelming whether or not they are relevant,
but that arbitrarily adding more and more events to this cat-
egory could indeed be overwhelming. Further research into
useful informational recommendations is warranted.
5.2 Detailed results
In this section we provide a qualitative overview of the cus-
tomized change event streams generated during our evalua-
tion for each project.
5.2.1 Metrics
Metrics received the largest number of impactful notica-
tions in our study; at the same time, this project has been
around the longest and the majority of its development was
performed near or prior to the start of the study period. As
such, a large number of its APIs were either deprecated (in-
cluding 2 full classes) or removed from the repository out-
right. In particular, the developers had to migrate from
swt.custom.TableTree to using a new widget that xed
a number of drawbacks in the old implementation. Many
of the deprecation notications (6) were not xed as they
were deprecated after the project went into maintenance-
only mode. At the same time, the impactful event list could
give a new developer a quick list of actions that should be
taken to bring the plug-in up-to-date with the platform.
It is not surprising that sauerf received the majority of
the impactful notications; he was the primary developer
and owned the majority of its dependencies. donv70 owned
a smaller portion of the code (especially at the start of
the study, from which we computed the ownership for his
event stream), and received correspondingly fewer events;
ultimately none of his code needed to be updated to cope
with any external changes.
5.2.2 RSSOwl
All 7 of RSSOwl's impactful events were false positives; in
every case they represented the same condition: a method or
eld was deleted from a subclass and added to a superclass
(that was also often newly added). Interestingly, the dele-tion event and the addition event were often separated by a
surprising period of time (weeks or longer). These same false
positives aected several of the other projects as they were
on common classes (all the SWTwidgets had their dispose()
method moved into a supertype).
The developer-specic feeds again insulated individual
developers from changes that only aected parts of their
project they did not own; in larger projects we would ex-
pect this dierence to be even more pronounced.
5.2.3 ASM Plugin
An interesting false negative appeared within the analysis
of the ASM plug-in. A method, which previously declared
athrows clause, removed this clause, causing a compilation
error in the code. YooHoo had not considered exceptions
and did not capture this change; nor does Change Distiller,
which we build atop. We will be adapting the code to de-
tect this in the future. The ASM developers also changed
their code to adapt to the deletion of SourceMapper.-
fSourceRanges and TrimLayout.addTrim(Control, int) .
5.2.4 Colorer
Colorer also ended up receiving several method and eld
deprecation events but during the course of study period
the project ceased to be regularly updated. That said, as
with Metrics the impactful list has 10 true positive changes
with only 2 false positive changes that the developer could
likely adapt to in a short period of time.
5.2.5 Checkstyle
As one might expect from a project designed to enforce good
coding style, the Checkstyle project is very conservative with
the APIs they depended upon. As such, few of the APIs they
used changed, although they resolved each of the 6 depreca-
tions they encountered. One note of interest for Checkstyle
is that a change in apache.commons.lang.StringUtil was
not detected because we failed to associate the apache.-
commons.lang project with a GCA engine. While YooHoo
detects situations when an appropriate GCA engine cannot
be located, the developer must manually ll-in the details to
get one populated for the missing project. Since such over-
sights on the part of the developer might indeed happen in
practice, we record this as a false negative.
6. DISCUSSION
In this section, we discuss a number of remaining issues
about the approach and ideas for future work.
6.1 Analytic limitations and extensions
YooHoo cannot detect all changes that will denitely impact
the developer's code, and only those changes, as this is un-
decidable in general [ 21]. Instead we take the approach of
ordering and ltering change events in terms of which ones
are most likely to matter to the developer.
YooHoo does not consider the inheritance hierarchy in
many of its analyses. For example, if a developer's code de-
pends on Preferentially but its subtype ConcretePref-
Page is changed, the developer will not be notied. This
decision was made because the developer, by registering a
dependency on the interface, implicitly claims to not be de-
pendent on the concrete class; any changes in these situa-
tions should be hidden by the interface. Of course, interfacesdo not completely shield internal changes from propagat-
ing outwards, so there are situations where internal changes
would be of importance [ 9]. Nevertheless, were we to notify
the developer of this relatively rare occurrence, we would
likely need to also notify her of a plethora of unimportant
changes. Thus, this was a pragmatic design decision.
Instead, there are a number of opportunities for more pre-
cise analyses to help categorize events. For example, we en-
countered false positives a few times in our evaluation when
a method was moved via a pull-up refactoring: YooHoo re-
ported method deletions involving depended-upon methods,
despite the fact that the methods were now inherited by the
original type. Some of our Uncertain events are catego-
rized as such because there can be unusual cases where such
changes could cause compile- or load-time failures; making
a class nal, for example, is only a problem if your code
had been extending that type|this should be simple to de-
tect. The implementation changes that YooHoo frequently
detects can be much more dicult (even impossible) to de-
cide whether they will be impactful or not, but due to de-
velopers' desire to avoid API changes, they should not be
impactful without a signicant accompanying change in the
documentation; more heavyweight impact analyses could be
brought to bear here, but it is not clear that this would
be worth the cost. There are two signicant drawbacks to
adding such analyses: the occasional diculty in correctly
implementing and validating them, and the potential perfor-
mance cost required to run them. The approach, after all,
is intended solely for providing recommendations: keeping
it lightweight matters for practicality.
6.2 Results and threats to validity
The results of our retroactive analysis conrm our hypothe-
sis that the majority of change events are trivial or irrelevant
to a particular developer; thus, these can be elided from a
change event stream customized for them.
The external validity of our experiment is threatened by
the fact that we used 5 specic systems and a particular
4-year period for the analysis; the results may not apply to
other systems or other periods. Each of these systems is
of non-trivial scale and activity. These systems come from
dierent domains and developers, reducing the likelihood
that there is something non-representative about them; they
were also in diering modes of development (maintenance
versus active extension). These systems are used by many
other projects, making them reasonable targets.
The construct validity of our experiment is threatened by
the fact that we performed a post-hoc analysis of change
repository data to determine what would or would not have
been of interest to the developer. The inference needed in
this analysis could have led to false results; however, the
steps we took to determine whether supposed Impactful
events actually would have been, and whether any non-
Impactful events would have caused a failure at deploy-
ment time demonstrates that the results are a reasonable
estimate of the actual true positive rate and false positive
rate for this analysis.
6.3 Performance
Analyzing a changed pair of les takes an average of 500 ms
on a commodity desktop machine. While this results
in a signicant one-time cost for large repositories (e.g.,
org.eclipse.jdt.ui contains 72,128 revisions, requiring10 hours for initial database population), the costs of main-
taining a repository once it is built is relatively low. For
example, YooHoo would take only 6 seconds of analysis per
day to keep the org.eclipse.jdt.ui project current. GCA
engines can be spread arbitrarily across machines; the pri-
mary point of contention is the GCA dispatcher, but this just
maintains a lookup table mapping types to URLs of GCA
engines and can easily scale to tens of millions of types.
6.4 YooHoo for large teams
In many ways, the large-team scenario (Section 2.1) is sim-
ilar to the plug-in developer scenario. Even in large teams
dierent sub-teams have dierent schedules, priorities, and
goals. In these cases, YooHoo can create GSA engines along
with each branch; even though the same pieces of code will
be monitored repeatedly across many branches, the nature
of developer-centric code ownership makes it likely that very
few branches will actually record changes to any specic
resource. The results from these per-branch GSA engines
can then be aggregated to provide a complete view of the
state of the code, to anyone on the team, regardless of what
branch they are working on. This can enable developers to
more quickly nd out about changes, and to contact their
originating author about them, before they are integrated
into the main repository branch, potentially preventing new
problems from arising when the code migrated upstream.
6.5 Maintaining GCA engines
From the user's perspective, YooHoo can transparently han-
dle changes to the underlying kind of repository (e.g., migra-
tion from CVS to Subversion) and changes to the location
of those repositories (e.g., migrating from SourceForge to
Google Code). The GCA dispatcher abstracts the details
of these changes away from the DSA engines. In the back
end, whichever developer congured the GCA engine for a
system that moved from one repository type or location to
another must recongure the GCA engine (a one line param-
eter change). The GCA engine automatically updates to re-
ect the new conguration and noties the GCA dispatcher
of the changes. If a legacy repository is maintained but
commits are applied to a new repository location, a silent
failure would occur. To combat this, the GCA engine can
announce a \cessation of activity" event after some timeout
period has elapsed. Manual investigation of the situation
could then ensue along with appropriate reconguration of
the associated GCA engine.
7. CONCLUSION
Software systems are typically heterogenous: they make use
of software from dierent projects and frameworks, not all
of which have the same development schedule or are a part
of the same organization. Developers do not always have
control over when their external dependencies change; typ-
ically, if one of these changes causes a problem, their re-
sponse is both reactive and late: a bug report is led and
they must scramble to resolve the problem. While respond-
ing to changes in this manner is inecient and increases the
dicult in xing bugs, developers take this route because of
the diculty to keep appraised of relevant changes.
This paper has described the YooHoo relevant change rec-
ommendation system. YooHoo provides aggregate streams
of recommended changes, tailored to a developer or team,
that are customized for their external dependencies. Wehave demonstrated that these streams reduce the number of
change notications a developer need consider by over 99%
while still maintaining a very high true positive rate (over
93%). We have explored the feasibility of also surfacing
certain non-impactful events purely for sake of developer-
specic awareness, and found that the low volume of such
events makes this a promising avenue for further study.
By providing customized change recommendations, devel-
opers can be proactive about ensuring that their system
stays current with their external dependencies while remain-
ing productive in other tasks.
8. ACKNOWLEDGMENTS
We wish to thank Rylan Cottrell and the anonymous review-
ers for their insightful comments. This work was supported
by the Natural Sciences and Engineering Research Council
through a Postdoctoral Fellowship and a Discovery Grant.
9. REFERENCES
[1]D. Bertram, A. Voida, S. Greenberg, and R. Walker.
Communication, collaboration, and bugs: The social
nature of issue tracking in software engineering. In
Proc. ACM Conf. Comput. Support. Coop. Work ,
2010. In press.
[2]J. T. Biehl, M. Czerwinski, G. Smith, and G. G.
Robertson. FASTDash: A visual dashboard for
fostering awareness in software teams. In Proc.
SIGCHI Conf. Hum. Fact. Comput. Sys. ,
pp. 1313{1322, 2007.
[3]F. P. Brooks, Jr. The Mythical Man{Month .
Addison-Wesley, Anniversary edition, 1995.
[4]G. Canfora and L. Cerulo. Fine grained indexing of
software repositories to support impact analysis. In
Proc. Int'l Wkshp. Mining Softw. Repos. , pp. 105{111,
2006.
[5]M. Cataldo, P. Wagstrom, J. D. Herbsleb, and K. M.
Carley. Identication of coordination requirements:
Implications for the design of collaboration and
awareness tools. In Proc. ACM Conf.
Comp.-Supported Coop. Work , pp. 353{362, 2006.
[6]L.-T. Cheng, S. Hupfer, S. Ross, and J. Patterson.
Jazzing up eclipse with collaborative tools. In Proc.
Eclipse Technol. eXchange , pp. 45{49, 2003.
[7]B. Dagenais and M. P. Robillard. Recommending
adaptive changes for framework evolution. In Proc.
Int'l Conf. Softw. Eng. , pp. 599{602, 2008.
[8]D. Damian, L. Izquierdo, J. Singer, and I. Kwan.
Awareness in the wild: Why communication
breakdowns occur. In Proc. Int'l Conf. Glob. Softw.
Eng., pp. 81{90, 2007.
[9]C. R. B. de Souza, D. Redmiles, and P. Dourish.
\Breaking the code": Moving between private and
public work in collaborative software development. In
Proc. ACM SIGGROUP Int'l Conf. Support. Group
Work , pp. 105{114, 2003.
[10]D. Draheim and L. Pekacki. Process-centric analytical
processing of version control data. In Proc. Int'l
Wkshp. Princip. Softw. Evol. , pp. 131{136, 2003.
[11]J. Estublier and S. Garcia. Process model and
awareness in SCM. In Proc. Int'l Wkshp. Softw.
Cong. Mgmt. , pp. 69{84, 2005.
[12]M. E. Fagan. Design and code inspections to reduceerrors in program development. IBM Systems Journal ,
38(2{3):258{287, 1999.
[13]G. Fitzpatrick, P. Marshall, and A. Phillips. CVS
integration with notication and chat: Lightweight
software team collaboration. In Proc. ACM Conf.
Comp. Supported Coop. Work , pp. 49{58, 2006.
[14]B. Fluri, M. Wuersch, M. Pinzger, and H. Gall.
Change distilling: Tree dierencing for ne-grained
source code change extraction. IEEE Trans. Softw.
Eng., 33(11):725{743, 2007.
[15]R. E. Grinter. Supporting articulation work using
software conguration management systems. Comp.
Supported Coop. Work , 5(4):447{465, 1996.
[16]T. Gross and W. Prinz. Awareness in context: A
light-weight approach. In Proc. Europ. Conf. Comp.
Supported Coop. Work , pp. 295{314, 2003.
[17]C. Gutwin, R. Penner, and K. Schneider. Group
awareness in distributed software development. In
Proc. ACM Conf. Comp. Supported Coop. Work ,
pp. 72{81, 2004.
[18]M. Kersten and G. C. Murphy. Using task context to
improve programmer productivity. In Proc. ACM
SIGSOFT Int'l Symp. Foundations Softw. Eng. ,
pp. 1{11, 2006.
[19]R. E. Kraut and L. A. Streeter. Coordination in
software development. Commun. ACM , 38(3):69{81,
1995.
[20]T. D. LaToza, G. Venolia, and R. DeLine. Maintaining
mental models: A study of developer work habits. In
Proc. Int'l Conf. Softw. Eng. , pp. 492{501, 2006.
[21]M. Moriconi and T. C. Winkler. Approximate
reasoning about the semantic eects of program
changes. IEEE Trans. Softw. Eng. , 16(9):980{992,
1990.
[22]C. O'Reilly, D. Bustard, and P. Morrow. The War
Room Command Console: Shared visualizations for
inclusive team coordination. In Proc. ACM Symp.
Softw. Vis. , pp. 57{65, 2005.
[23]D. E. Perry, H. P. Siy, and L. G. Votta. Parallel
changes in large-scale software development: An
observational case study. ACM Trans. Softw. Eng.
Method. , 10(3):308{337, 2001.
[24]A. Sarma, Z. Noroozi, and A. van der Hoek. Palant r:
Raising awareness among conguration management
workspaces. In Proc. Int'l Conf. Softw. Eng. ,
pp. 444{454, 2003.
[25]A. Sarma, D. Redmiles, and A. van der Hoek.
Empirical evidence of the benets of workspace
awareness in software conguration management. In
Proc. ACM SIGSOFT Int'l Symp. Foundations Softw.
Eng., pp. 113{123, 2008.
[26]A. Sarma and A. van der Hoek. Towards awareness in
the large. In Proc. IEEE Int'l Conf. Global Softw.
Eng., pp. 127{131, 2006.
[27]A. Sarma, A. van der Hoek, and D. F. Redmiles. A
comprehensive evaluation of workspace awareness in
software conguration management systems. In Proc.
IEEE Symp. Vis. Lang. Hum. Centr. Comput. ,
pp. 23{26, 2007.
[28]Z. Xing and E. Stroulia. API-evolution support with
Di-CatchUp. IEEE Trans. Softw. Eng. ,
33(12):818{836, 2007.