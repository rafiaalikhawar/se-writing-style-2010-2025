A Critical Review of ‚ÄúAutomatic Patch Generation Learned
from Human-Written Patches‚Äù: Essay on the Problem
Statement and the Evaluation of Automatic Software
Repair
Martin Monperrus
University of Lille & INRIA, France
martin.monperrus@univ-lille1.fr
ABSTRACT
At ICSE'2013, there was the rst session ever dedicated to
automatic program repair. In this session, Kim et al. pre-
sented PAR, a novel template-based approach for xing Java
bugs. We strongly disagree with key points of this paper.
Our critical review has two goals. First, we aim at explain-
ing why we disagree with Kim and colleagues and why the
reasons behind this disagreement are important for research
on automatic software repair in general. Second, we aim
at contributing to the eld with a clarication of the essen-
tial ideas behind automatic software repair. In particular we
discuss the main evaluation criteria of automatic software re-
pair: understandability, correctness and completeness. We
show that depending on how one sets up the repair scenario,
the evaluation goals may be contradictory. Eventually, we
discuss the nature of x acceptability and its relation to the
notion of software correctness.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging
General Terms
Verication; Reliability; Experimentation
Keywords
Bugs; faults; error recovery; automatic patch generation;
automatic program xing; automatic software repair
1. INTRODUCTION
\What one would like ideally [...] is the au-
tomatic detection and correction of bugs" R. J.
Abbott, 1990 [1]
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 - June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.The automatic detection of bugs has been a vast research
eld for decades, with a large spectrum of static and dy-
namic techniques. Active research on the automatic repair1
of bugs is more recent. A seminal line of research started in
2009 with the GenProg system [37, 15], and at the 2013 In-
ternational Conference on Software Engineering, there was
the rst session ever dedicated to automatic program repair.
The PAR system [19] was presented there, it is an ap-
proach for automatically xing bugs of Java code. The re-
pair problem statement is the same as GenProg [15] \given a
test suite with at least one failing test, generate a patch that
makes all test cases passing". PAR introduces a new tech-
nique to x bugs, based on templates. Each of PAR's ten
repair templates represents a common way to x a common
kind of bug. For instance, a common bug is the access to a
null pointer, and a common x of this bug is to add a null-
ness check just before the undesired access: this is template
\Null Pointer Checker".
We strongly disagree with Kim et al.'s paper on PAR.
This is our motivation to present this critical review of their
work. We think that a respectful critical reading and de-
bate is very important in the scientic process. This usually
happens within technical contributions (e.g. in the related
work section), but this is often shallow and biased towards
the new approach. Explicit criticism may sometimes be bet-
ter to clearly see the opposing ideas in the rst place (see
for instance the strong opposition in \A Debate on Teach-
ing Computer Science" in the Communications of the ACM
[10]).
Our critical review has two goals. First, we aim at ex-
plaining why we disagree with Kim and colleagues and why
the reasons behind this disagreement are important for au-
tomatic software repair in general. Second, we aim at con-
tributing to the eld with a clarication of the essential ideas
behind automatic software repair. We will discuss neither
the motivation of automatic software repair (we extensively
work on automatic repair) nor the technical contribution (we
believe in the eciency of templates for xing certain bugs
and the soundness of PAR's ones).
We start by discussing the concept of \defect class" which
is missing in PAR's paper. We show that ignoring this con-
cept has serious consequences on the conclusiveness of eval-
uation protocols in general, and PAR's one in particular.
We propose three dimensions for dening a defect class: the
root cause, the symptom, and the kind of x. This is broad
1or \correction", \xing", \patching", . . .Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568324
234
enough to revisit in the related work recent papers on auto-
matic repair.
Then, we will elaborate on the problem statement of au-
tomatic repair. Beyond the canonical problem statement
[37, 15, 19] which we call test-suite based program repair,
we show that there are diverse repair problems, depending
on whether repair happens online at runtime or oine at
maintenance time, and whether repair happens on the state
of programs or on the behavior expressed in their code.
Naturally, this diversity of problem statements leads to a
diversity of evaluation criteria. For test-suite based program
repair, we emphasize on the need to characterize the inner
quality of test suites. Then, depending on whether one con-
siders software repair as fully automatic code synthesis or as
a recommendation system problem, there are dierent eval-
uation criteria to be considered. Those evaluation criteria
may even be contradictory. For instance, bug x recom-
mendation systems are expected to synthesize understand-
able patches but are allowed to provide partial solutions.
Fully automatic repair systems have no understandability
constraints but should always yield a 100% executable solu-
tion.
Eventually, we explore the foundations of the x accept-
ability question (whether a x is more acceptable than an-
other). Through a thought experiment, we claim that under
certain circumstances, the question\is patch A more accept-
able than patch B?" is fundamentally unanswerable. We n-
ish the discussion by revisiting the relation between repair
and software correctness.
To sum up, we contribute to the eld of automatic repair
with new perspectives using Kim et al.'s paper as starting
point. Our contributions are:
the highlighting of pitfalls in automatic software re-
pair research and the uttermost importance of explicit
defect classes;
the presentation of kinds of software repair and their
characteristics, in particular state repair and behav-
ioral repair;
the identication of important and sometimes contra-
dictory evaluation criteria in the eld: understandabil-
ity; correctness; completeness.
The paper reads as follows. Section 2 gives some back-
ground information on automatic software repair and PAR.
Section 3 is the critical review per se, it exposes what we
think is wrong in Kim et al.'s paper. Section 4 elaborates
on the problem statement of automatic software repair. Sec-
tion 5 discusses the evaluation of automatic software repair
techniques and presents a thought experiment on the notion
of \x acceptability". Section 6 discusses the related work.
Section 7 concludes this paper.
2. BACKGROUND
Before discussing in details Kim et al.'s approach called
PAR [19], let us rst briey discuss what we mean by auto-
matic software repair and then how PAR works.
2.1 Automatic Software Repair
Automatic software repair is the process of xing software
bugs automatically. This denition seems broad enough toencompass diverse approaches from dierent elds of com-
puter science and engineering. In particular, it accepts dif-
ferent notions of xing (e.g. on source code, on binary code,
on execution data) and dierent kinds of bugs (indepen-
dently of the severity and the type of oracle that asserts the
presence of the bug). In a nutshell, automatic software re-
pair consists of several overlapping phases: failure detection
(something wrong has happened), bug diagnosis (why this
has happened), fault localization (what the root cause is,
where the initial faulty module/statement is), repair infer-
ence (what should be done to x the problem). For instance,
an archetypal automatic software repair system takes a bug
report as input and outputs a source code patch that xes
the bug.
It closely relates to what is called \automatic debugging"
[38]: the ultimate goal of debugging is to x bugs and to that
extent automatic software repair is perfect automatic debug-
ging. However, as said above, the term \automatic software
repair" is broader in scope than automatic debugging in the
sense that debugging connotes more the diagnosis phase of
repair than the combination of the aforementioned phases.
Automatic software repair relates to the traditional eld of
software dependability [4], and in its terminology, it spans
both fault tolerance and fault removal. Indeed, automatic
software repair can benet from the clear denitions of \er-
ror", \failure", and \fault" coming from dependable comput-
ing [4], because the term \bug" is vague and refers to those
three concepts indistinctly.
Automatic software repair also much relates to software
testing (w.r.t. the techniques used to detect and diagnose
the bugs), to program synthesis (when it comes to create
a correct piece of code), and to data mining and machine
learning for software engineering (when the repair knowledge
is extracted from existing data { version control systems,
execution traces, etc.). This list of related elds is not meant
to be exhaustive.
2.2 PAR: Template-based Software Repair
PAR is an automatic software repair technique invented
by Kim and colleagues and presented at the 2013 Interna-
tional Conference on Software Engineering [19]. As previous
work [15], it states the problem of automatic repair as fol-
lows: a bug is detected by a failing test case, and the goal is
to change the application code so that, rst the failing test
case now passes and second, the other test cases (forming a
\test suite") still pass.
To do so, PAR uses an existing fault localization tech-
nique, and for each suspicious statement, it tries dierent
repair templates. If the application of a repair template
makes the test suite passing, the bug is considered to be
xed. Each of the ten repair templates represents a common
way to x a common kind of bug. For instance, a common
bug is the access to a null pointer, and a common x of
this bug is to add a nullness check just before the undesired
access (template \Null Pointer Checker"). Some of PAR's
templates use the intrinsic redundancy of software and pick
some code elsewhere in the program under repair to x the
bug [26].
3. A CRITICAL REVIEW OF PAR
In our group, we extensively work on automatic software
repair [25, 26, 8]. In the last months, we have spent much
time in studying Kim et al.'s paper on PAR [19] and its235Table 1: Defect classes can be dened along several dimensions. Automatic repair approaches can be com-
pared only if they address similar defect classes.
Defect class according to. . . Examples of defect class
The root cause Incorrect variable initialization, incorrect conguration, . . .
The symptom Segmentation faults, Null pointer exceptions, memory exhaustion, . . .
The x Adding an input check, changing a method call, restoring an invariant, . . .
dataset. Over weeks, we have isolated two points on which
we strongly disagree. Beyond PAR only, this discussion aims
at being insightful for automatic software repair as a whole.
3.1 What are the addressed defect classes?
By \defect class", we mean a family of bugs that have
something in common (we equate \bug" and \defect", the
former being the colloquial name for the latter). We have
an open understanding of \in common": they can share the
same root cause (e.g. a programmer mistake), the same
symptom (e.g.. an exception) or the same kind of x (e.g.
changing the conditional of an if expression). Table 1 gives
examples of such dened defect classes. There is often a
relation between the root cause and the kind of kind. For
instance, an incorrect initialization can obviously be xed
changing the initialization. But it can be also be xed by
inserting an assignment later. There can be several dierent
x locations (e.g. at line 42 or at line 666) and kinds for
the same root cause (e.g. changing an assignment or chang-
ing a return value). The core of PAR is a collection of 10
templates. What are the addressed defect classes?
PAR doesn't address or clearly identify one or several de-
fect classes. By looking at the template names and descrip-
tions, they seem to address many dierent classes (a null
pointer bug is of dierent nature compared to a incorrect
cast bug). There is no apparent principle behind the collec-
tion of templates. As far as we understand, the templates
seem to have been collected by browsing bug xes and see
whether they would t in their overall approach. Why is
this ad hoc approach a problem?
To us, a contribution on automatic software repair should
answer the following questions: For which defect class does
it work? This names the enemy and enables the community
to answer the related questions: what are the \repairable"
defect classes, why is a defect class easy/hard to repair?
Identifying a defect class in automatic repair is as important
as dening the \fault model" [4] of a testing technique2.
Identifying the target defect classes enables the com-
munity to answer the questions: what are the \re-
pairable" defect classes, why is a defect class easy or
hard to repair?
These are academic questions. The real impact of auto-
matic repair on practitioners is founded are two other ques-
tions: What's the abundance of this defect class? What is
its criticality? Automatically xing a common defect class
would save a lot of maintenance resources, xing critical
crashes would save a lot of production loss. On the contrary,
the automatic repair of minor and rare bugs would only be
2Our goal is not to articulate those two terms. For us, a fault
model consists of several defect classes and may identiy
some relations between the root causes and the symptoms.of academic interest. The lack of explicit defect classes in
PAR's paper hinders the answering to all those questions.
Note that the seminal paper on automatic repair by Weimer
and colleague (GenProg, [37]) does not explicitly address
those questions as well. However, it was a paper opening a
new eld of research. But we note that in the conference
presentation3and in subsequent papers [15], the notion of
defect class is clearly present and hints that GenProg works
best for manipulating defensive code against memory errors
(in particular segmentation faults and buer overruns).
3.2 How conclusive is the evaluation?
Let us now discuss the conclusiveness of PAR's evaluation
[19]. Using 119 real bugs, they evaluate whether PAR xes
more bugs than GenProg [15] and whether the generated
xes are of better quality. We think that the experimental
methodology has several issues. Note that we are not saying
that their approach does not work (actually, we think that
their AST template-based approach may well address some
common bugs). We are only saying that the conclusiveness
of the evaluation as presented is questionable.
3.2.1 On the relation between the dataset creation
methodology and conclusiveness
The rst part of the evaluation is about the number of
xed bugs. In PAR's paper, there are 10 templates, and in
the presented evaluation, PAR is able to x 27 bugs. What is
the distribution of xed bugs by template? Mathematically,
the templates and their associated defect class are evaluated
on average on 2 or 3 bug instances (27 =10 = 2 :7). We asked
the authors about this distribution (i.e. which template xes
which bug ID?): it has been lost. According to our replica-
tion experiments with the 27 xed bugs, it actually seems
that most bugs are xed by the same templates (in particu-
lar\Null Pointer Checker"and\Expression Adder, Remover,
Replacer"), and that others, e.g. \Class cast checker", only
x one bug.
Many empirical evaluations, including some of ours, are
biased or over-conclusive with the proposed approach. The
bias often lies in the way the datasets are constructed. How-
ever, beyond the magnitude of a validation, the dataset con-
struction can impact the internal validity.
Do PAR and GenProg address the same defect classes? If
no, this raises doubts about the conclusiveness of the results.
Let's assume that PAR address defect classes A and B and
GenProg defect classes B and C. In this case, depending on
how one builds the dataset, the results would be totally dif-
ferent: for instance, a dataset 80%(A)-20%(B) would much
favor PAR. This fallacy is partly due to the absence of the
concept of defect class. In PAR's paper, there is no presen-
tation on how the dataset was built and no characterization
3Slide 20 of http://dijkstra.cs.virginia.edu/genprog/
papers/weimer-icse2009-genprog-presentation.pdf236of the kind of bugs it contains. To address this fallacy, one
needs to characterize how the dataset is built and what it
contains.
The way one builds evaluation datasets for automatic
repair has a great impact on the conclusiveness of the
results.
Finally, is PAR better than GenProg? According to our
arguments, as long as one does not clarify the underlying
defect classes and build a well-formed dataset, we do not
know. If PAR and GenProg are proven to address dierent
defect classes, the question can be considered as ill-formed.
The question that then arises is: how to build a valid eval-
uation dataset for automatic repair? At this point in the life
of the research eld, there is no denitive answer. However,
we tend to think that having a explicit target defect class is
again a key to answering this question. The dataset should
contain only bugs from the same defect class. Within a
defect class, the dataset sampling should be stratied from
easy bugs to complex ones. With such a dataset, subsequent
approaches on the same defect class can be meaningfully
compared. Having yet-unxed complex bugs in the dataset
would even foster creativity in other teams, who would in-
vent new ways to x them in an automated manner.
3.2.2 On the meaning of evaluating ‚Äúpatch accept-
ability‚Äù
Let us now examine the second evaluation question on
whether the synthesized patches are of better quality com-
pared to ones synthesized with an other approach, or com-
pared to the real ones. The experimental protocol consists
of asking developers to blindly assess synthesized patches.
They are also asked to assess the original human-written
patch. The experiment says it evaluates \patch acceptabil-
ity". The subjects of the user study are 17 students and 67
developers of local companies. None of them are develop-
ers of the software packages for which bugs are xed. As a
result of this evaluation, it is claimed that \PAR generates
more acceptable patches than GenProg does". What are the
underlying assumptions of this experiment?
First, it is that a developer is able to rate the quality of
a patch without any knowledge about the codebase and do-
main of the bug. Within reasonable time in the experiment
(say 30 minutes per bug), we think it is hardly possible.
For many bugs, understanding the bug report itself, under-
standing the causality chain4, and understanding whether
the patch is correct are all dicult tasks. Given only the
patch and an hyperlink to the bug report, doing this analysis
on an unknown codebase seems really hard. Understanding
the inner quality of a patch requires far more domain-specic
knowledge than the subjects of the user study have. To us,
the subjects of the experiment do not rate the inner quality
of the patch, but more on whether the code \looks good' or
not (Kim et al. use \is acceptable", but as explained above,
to us, we think that \looks good" ts more the reality of the
experiment).
4This often requires executing the program and not only
looking at the program as done in this setup.Evaluating the inner quality of a patch requires a
thorough process involving understanding the bug re-
port itself, understanding the causality chain of the bug,
and understanding the potential consequences and side-
eects of the patch.
4. ON THE PROBLEM STATEMENT OF AU-
TOMATIC SOFTWARE REPAIR
Now, let us step back and discuss the core problem state-
ment of the eld of automatic software repair.
4.1 On Patch Prettiness versus Alien Code
As said above and especially in Section 3.2.2, to our un-
derstanding, PAR's evaluation implicitly reformulates the
automatic repair problem statement as \generate a patch
that makes the test suite passing and that looks good". Be-
yond\looks good", we would say\looks like humanly written
good code".
Automatic software repair is one branch of code synthesis:
according to the literature and our experience, code synthe-
sis often generates surprising code, a kind of alien code. This
is normal since the processes to create this are completely
dierent (biological versus articial). Let us dwell on this.
Automatic software repair is about xing bugs automati-
cally, it is not about xing bugs \as humans are used to".
We should not be afraid of alien ways of reasoning on and
modifying programs (alien in the sense of fundamentally dif-
ferent).
PAR's implicit reformulation of the problem statement of
automatic repair puts up barriers on the way we x bugs
and on the way we design automatic bug xing techniques.
We should not only aim at techniques that mimic human
bug xing.
We should not be afraid of alien ways of writing code.
4.2 Kinds of Software Repair
More generally, the problem statements of automatic soft-
ware repair are not yet clearly identied. In the following,
we rst aim at clarifying the \canonical" repair problem, as
stated by Weimer et al. [37], and we call it \test-suite based
program repair" (Section 4.2.1). We then broaden the scope
of automatic repair and propose to distinguish two fami-
lies of repair techniques: state repair and behavioral repair
(Section 4.2.2).
4.2.1 Test-suite based Program Repair
In both PAR [19] and GenProg [37], the primary problem
statement is\given a test suite with one failing test, generate
a patch that makes them all passing". The failing test case
is the oracle for the bug. The rest of the test suite is the
oracle for regression. This is what can be called \test-suite
based program repair". In the patch quality experiment of
PAR, all the assessed patches pass the whole test suite. It
means that the primary problem statement is solved.
Asking users whether a patch is better than another one
implicitly breaks the well-formedness of the problem state-
ment. Asking the question means that passing the test suite
may not be sucient. Many have raised such points since237Table 2: Two examples of software repair scenarios. Depending on the problem, the evaluation criteria of
automatic software repair are dierent and the evaluation goals may be contradictory.
Facet Fully Automatic System Recommendation System
Who The repair robot or agent The repair system, then the human
When Mostly at runtime Mostly at development and maintenance time
Longevity Solutions may be temporary, disposable Solutions should sustain time
Understandability Anything goes incl. alien code Solutions must be understandable by humans
Correctness Fully automated procedure Pre-ltering then human validation
Completeness Solutions must be 100% executable Solutions may be partial, a human would ll the gaps
GenProg's break-up. With hindsight, we also agree that
this is an important weakness of the original problem state-
ment as done by Weimer and colleagues. However, as shown
above, the answer of PAR yields an implicit reformulation of
the automatic repair problem statement as\generate a patch
that makes the test suite passing and that looks good". We
disagree with it. We think that a better way to reformulate
it is to put the emphasis on assessing the test suite quality:
to what extent is a test suite good? does it well specify its
domain? is it appropriate for automatic repair?
If the research community is able to characterize what
a good test suite is, we can simply clarify the problem
statement as follows, \given a good and trustable test
suite, generate a patch that makes the test suite pass-
ing".
It may happen that the concept of test suite as we under-
stand it today { with test cases and assertions { will never
prove appropriate for automatic repair.
More generally, in test suite based program repair, there
is an important asymmetry between test cases. One sin-
gle failing test case is enough to express the bug, while the
other ones must cover as completely as possible the spec-
ied behavioral space. To this extent, the point \given a
good and trustable test suite" is simply a concrete instance
of the more general problem of being able to characterize
the specication of a program or software component [34].
4.2.2 Behavioral Repair versus State Repair
GenProg [37] focuses on synthesizing code to x bugs of-
ine, the code being meant to be committed into a ver-
sion control system. The visibility and impact of this work
tends to associate the term \repair" with this kind of repair.
However, \repair" has a broader sense than just synthesiz-
ing source code. It may mean repairing a data structure [9],
repairing the register values and memory locations [29], etc.
We think that we can actually distinguish two kinds of au-
tomatic software repair: state repair and behavioral repair.
State repair consists in modifying the program state dur-
ing the execution (the registers, the heap, the stack, etc.).
Demsky and Rinard's work on data structure repair [9] is
an example of such state repair. State repair can be seen
as a kind of data repair (as opposed to code repair), in the
spirit of the data diversity techniques in fault tolerance [2].
Behavioral repair consists in modifying the program exe-
cutable code. According to this denition, synthesizing a
source code patch is indeed behavioral repair. Behavioral
repair is also relevant on binary code when no source code
is available. Behavioral repair can also happen at runtime(when one changes the code part of the memory). To sum
up, state repair is only online (at runtime) while behavioral
repair can be either online or oine at maintenance time.
We will come back on this point in Section 5.
The problem statement of automatic software repair
can be decomposed in: state repair that consists in mod-
ifying the program state during the execution, and be-
havioral repair that consists in modifying the program
code.
5. ON THE EVALUATION OF AUTOMATIC
SOFTWARE REPAIR
According to the broad denition given in Section 2.1, au-
tomatic software repair can be declined in dierent scenar-
ios. Repair involves failure detection, bug diagnosis, fault
localization and repair inference. Even though automatic
software repair contains the word \automatic", it is not rea-
sonable to state that automatic software repair systems are
only those that fully automatically cover all those phases. A
system that produces a patch on which a developer would
build on to write the nal patch indeed goes in the direc-
tion of automatic software repair. One can actually imagine
a broad range of repair scenarios: fully automatic repair
agents at runtime, repair bots taking care of some bug re-
ports and modifying the source code base automatically, or
repair recommendation systems proposing tentative patches
that developers would improve. As we shall see now, de-
pending on the scenario, the evaluation criteria change and
may even be contradictory.
5.1 Evaluation Criteria
We see at least three dimensions of evaluation for which
the evaluation goals dier depending on the automatic repair
scenario.
Understandability.
Let us consider a repair robot that automatically com-
mits patches to a code base where conventional human-based
maintenance takes place. Some complex bugs would be un-
xable by the repair robot and they would consequently be
handled by a human developer. To x those tough bugs,
she may have to understand a patch previously generated by
the repair robot, or even a set of superimposed synthesized
patches, which may be rather dicult. When human-based
maintenance and automatic repair are interleaved, the gen-
erated patches have to be clearly documented, and the repair
approach could also generate an explanation of the repair.
Le Goues et al. refer to this issue as \patch maintainability"238[14]. On the contrary, if the repair happens at runtime as a
temporary solution in order not to crash, there is no need
for documentation at all. In the former case, alien code is
problematic, in the latter code, alien code is welcome. State
repair at runtime have no understandability requirements,
and depending of the scenario of behavioral repair, under-
standability is not mandatory. Synthesizing maintainable
repairs is antagonist to runtime disposable xes.
Correctness.
Those dierent repair scenarios have a direct impact on
the correctness evaluation criteria. To some extent, a repair
system that generates patches is a recommendation system
for software engineering. In the mindset of using a recom-
mendation system, the developer would use the system as
follows. She would consider a synthesized patch, perform ad-
ditional correctness and understandability assessment, and
then decide for the nal patch to be committed to the reposi-
tory. In such a scenario, the repair system is allowed to syn-
thesize partially correct patches. On the contrary, a fully
automatic repair system is liable for synthesizing fully cor-
rect repairs5(according to its correctness oracle). The latter
has a much larger scope and seems more dicult in general.
The value of the repair system may come either from the
fully automated correctness decision procedure or from the
help it provides to the developers.
Completeness.
The same argument applies to the completeness of the
patch. A repair recommendation system can only provide a
partial repair (say 90% of the nal repair), or even a sketch
of the repair. This can nonetheless be very valuable to guide
the developer in writing the nal patch. On the other hand,
at runtime, the repair must be executable, and partialness is
not an option. Partial repair is sometimes a valuable option
and in other cases an unacceptable solution.
Depending on the repair problem statement, the eval-
uation criteria are dierent and the evaluation goals may
even be contradictory.
Table 2 sums up those points. For instance, bug x recom-
mendation systems are expected to synthesize understand-
able patches but are allowed to provide partial solutions.
Fully automatic repair systems have no understandability
constraints but should always yield a 100% executable solu-
tion.
5.2 On Fix Acceptability
Let us consider again the question of x acceptability. We
now go beyond \looks good and humanly written", and more
generally beyond understandability, correctness and com-
pleteness. Beyond those three evaluation criteria, we think
that the question of x acceptability is related to the foun-
dations of software. Let us assume that we have a good and
5Interestingly, there is asymmetry between state repair
and behavioral repair with respect to correctness: assessing
the correctness of a new state (inferred, synthesized) cor-
responds to assessing one point; on the contrary, assessing
the correctness of a behavioral patch requires to assess the
correctness of the path under all anticipated inputs (many
points).// f i x A: code i n s e r t i o n at l i n e 21
+ i f ( x==2)ffoo ( x ) ;g
// f i x B: code i n s e r t i o n at l i n e 21
+ i f (x <=2)ffoo ( x ) ;g
Listing 1: Two possible xes of the same bug (both
satisfy all test cases). There is no unique way to say
that one is more acceptable than the other.
trustable test suite. This test suite completely species the
expected behavior in the sense of \if the repair technique
mixes up the software" then \the introduced bugs will be
detected".
Now, let us assume that for a given bug and its failing test
case, one has two possible xes which are shown in Listing
1. Obviously, both patches x a test case where the value
\2" is involved. This value has a semantics in its domain.
According to the setup, either foo is idempotent for all values
<2 or no values <2 are tested.
In the latter case, since we assume one has a good test
suite, it means that for values <2 , the behavior is unspec-
ied. This can also be formulated as the values <2 are
outside the specied domain (neither a nominal value nor
an expected incorrect value). In both cases, there is no di-
rect answer to the question \which patch is more acceptable
than the other".
Let us now consider the topology of the output domain.
The rst x A (with \ ==") does nothing outside the speci-
ed point of the failing test case. The second x B (with
\with <=") has an impact on the behavior within the un-
specied input domain. Some tend to prefer x A because
it minimizes the impact which is a well-known engineering
value.
However, the rst x A (with \ ==") introduces an irreg-
ularity: something happens only for one point of the input
domain. On the contrary the second x B (with \with <=")
is more \regular", it introduces a kind of phase transition at
x= 2. This ts more to the idea that x= 2 does not repre-
sent an exception, but a boundary, which often happens in
input domains. Some tend to prefer x B because it mini-
mizes the number of irregularities which is also a well-known
engineering value.
Even within our research group, there is no consensus on
which patch is better. What we want to show with this
made-up example is two fold. First, the notion of \x ac-
ceptability" is actually founded on deep concepts and beliefs
on the nature of software. It may depend on the domain it-
self. Second, there may be many concurrent xes for which
there is simply no answer. In other terms, asking the ques-
tion \which patch is more acceptable than the other" must
be done with great care, by explicitly stating that \None" is
a valid and common answer.
This has been done in PAR's experiment: the subjects
could answer \both [patches] are acceptable". However, as
discussed above, the subjects' absence of knowledge about
the domain tends to show that when the subjects answered
this, this had little to do with answering \the patches are
incommensurable".239Fix acceptability may be an unanswerable question.
It is now clear that the question of x acceptability is di-
rectly related to what can be considered as correct or not,
directly related to the nature of software correctness. Pro-
gram repair lies at the conjunction of two dimensions of soft-
ware correctness. It needs an oracle of what is incorrect: an
oracle for the bug. It also needs an oracle on what behavior
should be kept correct for sake of non-regression.
The conventional, common sense, notion of software cor-
rectness is binary: there is a decision procedure that says
whether the software is correct (the procedure outputs\true")
or not (the procedure outputs \false"). Dijkstra says \a pro-
gram with an error is just wrong" [10]. Boolean assertions
in programming languages and testing frameworks embody
this notion. In this perspective, the problem statement of
program repair is easy: the binary oracle of the bug should
be negated and the other binary oracles should be kept pass-
ing. This is the \canonical" problem statement of program
repair, as stated by GenProg.
However, binary software correctness is no longer the norm.
Software correctness exists at dierent scales: e.g. at the
level of expressions (e.g. arithmetic expressions), functions,
modules, systems, etc. Let us dierentiate between the two
extremes as \local correctness" (a few lines of code) and
\global correctness" (at the system level, up to several mil-
lions of lines of code). Small-scale correctness is often bi-
nary. However, when the scale increases, a dierent kind of
correctness emerges. This emerging correctness oers two
new facets: it may be partial as when a system passes 1990
test cases out of 2000; and it may be continuous, as when
one considers the quality of service [27] (many quality of
service attributes are continuous, such as the performance).
Both facets { partialness and continuousness { replace an \is
correct" binary predicate by a \more correct than" relation.
In other terms, there is no direct induction between \local
binary correctness" and \global binary correctness".
This broadening of software correctness has a direct im-
pact on software repair. One may accept a x that par-
tially solves a bug or that partially breaks the existing be-
havior. Those new dimensions of software correctness have
been called \acceptability envelope" and \approximate cor-
rectness" by Rinard et al. [31], \controlled uncertainty" by
Locasto et al. [22] and \sucient correctness" by Shaw [33].
However, both classical binary correctness and those uncon-
ventional kinds of correctness share a common characteristic
with respect to repair: they all implicitly dene x accept-
ability.
A x is acceptable if the system stays in the correct-
ness envelope.
This perspective also gives a new light on the evaluation
criteria discussed in Section 5: the denition of the cor-
rectness envelop denes the evaluation criterion. This point
has been extensively exploited by Rinard and colleagues, for
instance to automatically x security bugs [24] or quality-of-
service bugs [27]. Note that this perspective is independent
from whether repair is state-based of behavior based, and
whether it happens online or oine.6. RELATED WORK
We structure the discussion of the related work on the fol-
lowing points; the notion of defect class, the evaluation and
the risk of fallacy, and the problem statement of automatic
repair.
6.1 On Defect Classes
The notion of \defect class" or \fault class" is really im-
portant in the eld of fault tolerance and software testing.
In fault tolerance, according to foundations of the eld [4],
\the dependability & security specication of a system must
include the requirements [...] for specied classes of faults" .
Indeed, one is tolerant with respect to a certain class of fault.
Avizienis et al.'s elementary dimensions of fault classes [4]
provide a coarse-grain framework for characterizing the bugs
addressed by an automatic repair approach.
In software testing, and in particular in the eld of muta-
tion testing, a \fault class" or \fault model" describes kinds
of programmer mistakes (in a particular language, domain,
etc) [17]. Each mutation operator is intended to simulate
one of those mistakes. Tolerating bugs, simulating faults,
repairing bugs: in all cases, there is a real need to describe
the classes of bugs that are handled by a novel technique.
In the research on self-healing software, which is close to
automatic software repair, the need for a fault model has
been clearly stated by Koopman [20]: \self-healing systems
must have a fault model in terms of what injuries (faults)
they are expected to be able to self-heal. Without a fault
model, there is no way to assess whether a system actually
can heal itself in situations of interest. " ..
Let us now analyze other recent papers on automatic re-
pair under the perspective of the addressed defect class.
Semx [28] is an automatic repair approach by Nguyen and
colleagues based on symbolic execution. As in PAR's pa-
per, there is no clearly addressed defect class. As said above
and summarized in Table 1, a defect class can be dened
in terms of causes, symptoms or kinds of x. With respect
to the last point (kinds of x), Semx targets two clear de-
fect classes: it xes faulty integer initialization and faulty
conditionals that use arithmetic, relational and boolean op-
erators. Carzaniga et al. [6] proposed a repair approach at
runtime. In this paper, the addressed defect class is very
clear, it is unhandled exceptions. Hosek and Cadar [16] also
address a defect class at runtime: segmentation faults (as
dened by the reception of Unix' SIGSEGV signal). The
paper of Logozzo and Ball's paper [23] clearly conveys the
notion of defect classes, up to its structure (e.g. the section
entitled \Repair of Initialization and O-By-One Errors" ).
However, they repair statically generated warnings, which
are \virtual" bugs and not real ones. Although those papers
address defect classes, it is not always explicit. We note that
having an underlying defect class does not remove the risk
of evaluation fallacy if the evaluation is conducted on a bi-
ased dataset (with respect to the defect class) or against a
inappropriate competitor (idem).
Compared to this related work, our paper explicitly states
the importance of defect classes in automatic software repair.
6.2 On Fallacies in Software Engineering
Having sound evaluation methods is essential for science.
In many elds, dierent fallacies have been described (e.g.
[13] in medicine). In software engineering, many authors
discussed potential fallacies, such as Glass in his book [12].240Recently, Bird and colleagues [5] have extensively discussed
the biases of datasets used in bug predication research. Pos-
nett, Filkov and Devanbu [30] have published a paper on
the presence of ecological fallacies in empirical software en-
gineering research (focusing on sample size, zonation, and
class imbalance). Both papers discuss the intimate relation
between the dataset construction and the conclusiveness of
the evaluation.
Our paper makes the same point in a dierent context,
automatic software repair.
6.3 On The Problem Statement of Automatic
Software Repair
Along the two dimensions of state repair and runtime re-
pair, let us now survey important related work. As early
as 1980, Taylor and colleagues [35] introduced \robust data
structures" which are able to repair their own state at run-
time. Demsky and Rinard [9] proposed a similar approach
for data structure repair [9], Perkins et al. [29] invented
a complex repair strategies for register values and memory
locations of x86 binary programs [29], Friedrich et al. [11]
focused on repairing service-oriented software. Lewis and
Whitehead's paper [21] also performs state repair, by run-
time modication of the state of event-driven programs.
On behavioral repair, beyond the now classical work by
Weimer and colleagues [37, 15], there is also earlier (e.g. [18,
3]) and concurrent work on this topic (e.g. [7, 36]). Those
contributions focus on synthesizing source code to x bugs,
the code being meant to be committed into a version control
system. However, behavioral repair is also relevant on bi-
nary code [32]. Moreover, as stated above, behavioral repair
can also happen at runtime, the application communities of
Locasto and colleagues [22], for instance, share behavioral
patches at runtime for xing faults.
7. CONCLUSION
Automatic software repair is a eld of research with some
momentum. It poses hard and interesting problems and may
have a great impact on practitioners. Taking as stepping
stone Kim et al.'s paper published at ICSE 2013 on this
topic, we have discussed the foundations of automatic repair.
First, a meaningful evaluation in automatic software re-
pair requires one to identify and characterize a defect class.
Otherwise, there is a great risk of stating a fallacy. Sec-
ond, the apparently harmless question \is the synthesized
patch correct?" has actually deep roots on how to dene the
problem statements of automatic repair and how to set up
evaluation criteria.
We are only at the beginning of automatic software repair.
We are yet only able to automatically repair some bugs, in
some contexts where it is easy to have a well-formed prob-
lem statement (e.g. test-suite based program repair). But
let us open any issue tracker: how many issues can be xed
in an automated manner? Let us have a look at any bug
x of less than 10 lines in a source code repository, for in-
stance on Github. How many of those small changes can
be synthesized in an automated manner? I would say very
few. There are great inventions to be done on dening bug
oracles, reproducing eld failures, guiding the search for a
correct repair solution, assessing the impact of synthesized
changes for repair, etc.. And all this has to be done at the
scale and complexity of today's software.8. ACKNOWLEDGMENTS
First, I would like to thank Dongsun Kim, Jaechang Nam,
Jaewoo Song, and Sunghun Kim, the authors of \Auto-
matic Patch Generation Learned from Human-Written Pat-
ches" for giving me the opportunity and inspiration to think
on such interesting problems. In particular, I acknowledge
Dongsun Kim for his input on PAR and his insightful opin-
ion of those critical ideas: this is a scientic debate in a
very noble form. Then, I do thank Matias Martinez for his
thorough analysis of PAR and its bug evaluation dataset.
Finally, I wish to express my gratitude to Raphael Marvie,
Favio DeMarco, Tegawend e F. Bissyand e, Jifeng Xuan, Li-
onel Seinturier, Benoit Baudry, Jean-Marc J ez equel, Yves
Le Traon, Friedrich Steimann, and Bertrand Meyer for their
valuable feedback on those ideas or their deeply motivational
encouragement.
This research is done with support from the Erasmus
Mundus Program, the University of Lille PhD Program and
EU Project Diversify FP7-ICT-2011-9.
9. REFERENCES
[1] R. J. Abbott. Resourceful systems for fault tolerance,
reliability, and safety. ACM Computing Surveys
(CSUR) , 22(1):35{68, 1990.
[2] P. Ammann and J. Knight. Data diversity: an
approach to software fault tolerance. IEEE
Transactions on Computers , 37(4):418 {425, 1988.
[3] A. Arcuri and X. Yao. A novel co-evolutionary
approach to automatic software bug xing. In
Proceedings of the IEEE Congress on Evolutionary
Computation (CEC) , 2008.
[4] A. Avizienis, J.-C. Laprie, B. Randell, and
C. Landwehr. Basic concepts and taxonomy of
dependable and secure computing. IEEE Transactions
on Dependable and Secure Computing , 1(1):11{33,
2004.
[5] C. Bird, A. Bachmann, E. Aune, J. Duy,
A. Bernstein, V. Filkov, and P. Devanbu. Fair and
balanced?: bias in bug-x datasets. In Proceedings of
the 7th joint meeting of the European Software
Engineering Conference and the ACM SIGSOFT
Symposium on the Foundations of Software
Engineering , 2009.
[6] A. Carzaniga, A. Gorla, A. Mattavelli, N. Perino, and
M. Pezz e. Automatic recovery from runtime failures.
InProceedings of the 2013 International Conference
on Software Engineering , 2013.
[7] V. Dallmeier, A. Zeller, and B. Meyer. Generating
xes from object behavior anomalies. In Proceedings of
the International Conference on Automated Software
Engineering , 2009.
[8] F. DeMarco, J. Xuan, D. Le Berre, and
M. Monperrus. Automatic repair of buggy if
conditions and missing preconditions with SMT. In
Proceedings of the 6th Workshop on Constraints in
Software Testing, Verication, and Analysis
Co-located with ICSE 2014 , 2014.
[9] B. Demsky and M. Rinard. Automatic detection and
repair of errors in data structures. In Proceedings of
the ACM SIGPLAN conference on Object-Oriented
Programing, Systems, Languages, and Applications
(OOPSLA) , 2003.241[10] P. J. Denning. A debate on teaching computing
science. Commun. ACM , 32(12):1397{1414, Dec. 1989.
[11] G. Friedrich, M. Fugini, E. Mussi, B. Pernici, and
G. Tagni. Exception handling for repair in
service-based processes. IEEE Transactions on
Software Engineering , 36(2):198{215, 2010.
[12] R. L. Glass. Facts and fallacies of software
engineering . Addison-Wesley Professional, 2002.
[13] S. N. Goodman. Toward evidence-based medical
statistics. 1: The p value fallacy. Annals of internal
medicine , 130(12):995{1004, 1999.
[14] C. Goues, S. Forrest, and W. Weimer. Current
challenges in automatic software repair. Software
Quality Control , 21(3), 2013.
[15] C. L. Goues, T. Nguyen, S. Forrest, and W. Weimer.
Genprog: A generic method for automatic software
repair. IEEE Transactions on Software Engineering ,
38:54{72, 2012.
[16] P. Hosek and C. Cadar. Safe software updates via
multi-version execution. In Proceedings of the 2013
International Conference on Software Engineering ,
pages 612{621. IEEE Press, 2013.
[17] Y. Jia and M. Harman. An analysis and survey of the
development of mutation testing. IEEE Transactions
on Software Engineering , 37(5):649{678, 2011.
[18] B. Jobstmann, S. Staber, A. Griesmayer, and
R. Bloem. Finding and xing faults. Lecture Notes in
Computer Science , 3725, 2005.
[19] D. Kim, J. Nam, J. Song, and S. Kim. Automatic
patch generation learned from human-written patches.
InProceedings of the International Conference on
Software Engineering , 2013.
[20] P. Koopman. Elements of the self-healing system
problem space. Technical report, Carnegie Mellon
University, 2003.
[21] C. Lewis and J. Whitehead. Repairing games at
runtime or, how we learned to stop worrying and love
emergence. IEEE Software , 28(5), 2011.
[22] M. E. Locasto, S. Sidiroglou, and A. D. Keromytis.
Software self-healing using collaborative application
communities. In Proceedings of the 2006 Network and
Distributed System Security Symposium (NDSS) , 2006.
[23] F. Logozzo and T. Ball. Modular and veried
automatic program repair. In Proceedings of the ACM
International Conference on Object-oriented
Programming Systems, Languages and Applications ,
pages 133{146. ACM, 2012.
[24] F. Long, V. Ganesh, M. Carbin, S. Sidiroglou, and
M. Rinard. Automatic input rectication. In
Proceedings of the 2012 International Conference on
Software Engineering , 2012.
[25] M. Martinez and M. Monperrus. Mining software
repair models for reasoning on the search space of
automated program xing. Empirical Software
Engineering , -, 2013.
[26] M. Martinez, W. Weimer, and M. Monperrus. Do thex ingredients already exist? an empirical inquiry into
the redundancy assumptions of program repair
approaches. In Proceedings of the International
Conference on Software Engineering, New Ideas and
Emerging Results Track (NIER) , 2014.
[27] S. Misailovic, S. Sidiroglou, H. Homann, and
M. Rinard. Quality of service proling. In Proceedings
of the 32nd ACM/IEEE International Conference on
Software Engineering . ACM, 2010.
[28] H. D. T. Nguyen, D. Qi, A. Roychoudhury, , and
S. Chandra. SemFix: Program Repair via Semantic
Analysis. In Proceedings of the International
Conference on Software Engineering , 2013.
[29] J. H. Perkins, G. Sullivan, W.-F. Wong, Y. Zibin,
M. D. Ernst, M. Rinard, S. Kim, S. Larsen,
S. Amarasinghe, J. Bachrach, M. Carbin, C. Pacheco,
F. Sherwood, and S. Sidiroglou. Automatically
patching errors in deployed software. Proceedings of
the 22nd Symposium on Operating Systems Principles
(SOSP) , 2009.
[30] D. Posnett, V. Filkov, and P. T. Devanbu. Ecological
inference in empirical software engineering. In
Proceedings of the IEEE/ACM International
Conference on Automated Software Engineering , pages
362{371, 2011.
[31] M. Rinard, C. Cadar, and H. H. Nguyen. Exploring
the acceptability envelope. In Companion to the 20th
annual ACM SIGPLAN conference on Object-oriented
programming, systems, languages, and applications ,
pages 21{30. ACM, 2005.
[32] E. Schulte, S. Forrest, and W. Weimer. Automated
program repair through the evolution of assembly
code. In Proceedings of the IEEE/ACM International
Conference on Automated Software Engineering , 2010.
[33] M. Shaw. Self-healing: softening precision to avoid
brittleness. In Proceedings of the rst workshop on
Self-healing systems , WOSS '02, 2002.
[34] M. Staats, M. W. Whalen, and M. P. E. Heimdahl.
Programs, tests, and oracles: the foundations of
testing revisited. In Proceedings of the International
Conference on Software Engineering , pages 391{400.
IEEE, 2011.
[35] D. J. Taylor, D. E. Morgan, and J. P. Black.
Redundancy in data structures: Improving software
fault tolerance. IEEE Transactions on Software
Engineering , (6):585{594, 1980.
[36] Y. Wei, Y. Pei, C. A. Furia, L. S. Silva, S. Buchholz,
B. Meyer, and A. Zeller. Automated xing of
programs with contracts. In Proceedings of the
International Symposium on Software Testing and
Analysis . AC, 2010.
[37] W. Weimer, T. Nguyen, C. L. Goues, and S. Forrest.
Automatically nding patches using genetic
programming. In Proceedings of the International
Conference on Software Engineering , 2009.
[38] A. Zeller. Automated debugging: Are we close?
Computer , 34(11):26{31, 2001.242