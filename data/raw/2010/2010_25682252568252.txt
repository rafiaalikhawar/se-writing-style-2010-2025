Understanding Understanding Source Code with
Functional Magnetic Resonance Imaging
Janet Siegmund,Christian K√§stner!, Sven Apel, Chris Parnin, Anja Bethmann,
Thomas Leich, Gunter Saake, and Andr√© Brechmann
University of Passau, Germany!Carnegie Mellon University, USA
Georgia Institute of Technology, USALeibniz Inst. for Neurobiology Magdeburg, Germany
Metop Research Institute, Magdeburg, GermanyUniversity of Magdeburg, Germany
ABSTRACT
Program comprehension is an important cognitive process that in-
herently eludes direct measurement. Thus, researchers are strug-
gling with providing suitable programming languages, tools, or
coding conventions to support developers in their everyday work.
In this paper, we explore whether functional magnetic resonance
imaging (fMRI) , which is well established in cognitive neuroscience,
is feasible to soundly measure program comprehension. In a con-
trolled experiment, we observed 17 participants inside an fMRI
scanner while they were comprehending short source-code snip-
pets, which we contrasted with locating syntax errors. We found a
clear, distinct activation pattern of Ô¨Åve brain regions, which are re-
lated to working memory, attention, and language processing‚Äîall
processes that Ô¨Åt well to our understanding of program comprehen-
sion. Our results encourage us and, hopefully, other researchers to
use fMRI in future studies to measure program comprehension and,
in the long run, answer questions, such as: Can we predict whether
someone will be an excellent programmer? How effective are new
languages and tools for program understanding? How should we
train programmers?
Categories and Subject Descriptors
H.1.2 [ Information Systems ]: User/Machine Systems
General Terms
Experimentation, human factors
Keywords
Functional magnetic resonance imaging, program comprehension
1. INTRODUCTION
As the world becomes increasingly dependent on the billions
lines of code written by software developers, little comfort can be
taken in the fact that we still have no fundamental understanding of
how programmers understand source code.
Understanding program comprehension is not limited to theory
building, but can have real downstream effects in improving educa-
tion, training, and the design and evaluation of tools and languages
This author published previous work as Janet Feigenspan.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$10.00.
Mirror  Screen  
Head coil 
while ‚Ä¶. 
That‚Äòs  a loop ... 
currValue = 
1‚Ä¶ 2‚Ä¶ 4‚Ä¶  (a) Prestudy (b) fMRI measurement
(c) Activation pattern (d) Cognitive proc. (e) Other fMRI studies
(f) Interpretation for
program comprehension
Figure 1: WorkÔ¨Çow of our fMRI study.
for programmers. If direct measures of cognitive effort and difÔ¨Å-
culty could be obtained and correlated with programming activity,
then researchers could identify and quantify which types of activi-
ties, segments of code, or kinds of problem solving are troublesome
or improved with the introduction of a new language or tool.
In studying programmers, decades of psychological and observa-
tional experiments have relied on indirect techniques, such as com-
paring task performance or having programmers articulate their
thoughts in think-aloud protocols. Each method, when skillfully
applied, can yield important insights. However, these common
techniques are not without problems. In human studies of program-
ming, individual [13] and task variance [19] in performance often
mask any signiÔ¨Åcant effects hoping to be found when evaluating,
say, a new tool. Think-aloud protocols and surveys rely on self-
reporting and require considerable manual transcription and analy-
sis that garner valuable but indeÔ¨Ånite and inconsistent insight.
In the past few decades, psychologists and cognitive neurosci-
entists have collectively embraced methods that measure physio-
logical correlates of cognition as a standard practice. One such
method is functional magnetic resonance imaging (fMRI) , a non-
invasive means of measuring blood-oxygenation levels that change
as a result of localized brain activity.Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568252
378
In this paper, we report on results and experience from applying
fMRI in a program-comprehension experiment. While our experi-
ment is a Ô¨Årst step toward measuring program comprehension with
fMRI, and as such inherently limited, we believe it illuminates a
path for future studies that systematically explore hypotheses and
that will help to build stronger theories of program comprehension.
In our experiment, 17 participants performed two kinds of tasks
inside an fMRI scanner. In the Ô¨Årst kind, referred to as comprehen-
sion tasks , developers comprehended code snippets and identiÔ¨Åed
the program‚Äôs output. In the second kind, referred to as syntax
tasks , developers identiÔ¨Åed syntax errors in code snippets, which
is similar to the comprehension tasks, but does not require actual
understanding of the program. As a result of our study, we found:
evidence that distinct cognitive processes took place when
performing the comprehension tasks,
activation of functional areas related to working memory, at-
tention, and language comprehension, and
a left-hemisphere lateralization.
Our results provide direct evidence of the involvement of work-
ing memory and language processing in program comprehension,
and suggest that, while learning programming, training working
memory (necessary for many cognitive tasks) and language skills
(which Dijkstra already claimed as relevant for programming)
might also be essential for programming skills. Furthermore, our
results can help to validate or invalidate particular theories of pro-
gram comprehension. Although a single study is not sufÔ¨Åcient to
answer general questions, we can raise some further probing ques-
tions: If program comprehension is linked to language compre-
hension, does learning and understanding a programming language
require the same struggles and challenges as learning another nat-
ural language? If program comprehension only activates the left
hemisphere (often referred to as analytical), can we derive better
guidelines on how to train students?
Taking a broader perspective, our study demonstrates the feasi-
bility of using fMRI experiments in software-engineering research.
Although we believe this is only a Ô¨Årst step, our experience and ex-
perimental design is meant to be a template for other researchers to
adopt and improve. With decreasing costs of fMRI studies, we be-
lieve that such studies will become a standard tool also in software-
engineering research.
There are still many interesting, unanswered questions that fol-
low this line of research: How do people use domain knowledge
during comprehension? To what extent is implementing source
code a creative process? Can we train anybody to become an excel-
lent programmer? How should we design programming languages
and tools for optimal developer support? Can software metrics pre-
dict the comprehensibility of source code?
In summary, we make the following contributions:
We designed the Ô¨Årst fMRI study to observe brain activity
during program-comprehension tasks. We share our design
and experiences.
We conducted the study with 17 participants and observed
activation in Ô¨Åve distinct brain regions. This demonstrates
the potential of fMRI studies in software-engineering re-
search.
We interpret how the identiÔ¨Åed cognitive processes con-
tribute to program comprehension and discuss future re-
search directions.
This paper builds on our previous proposal, in which we de-
scribed our planning stage and conducted only preliminary stud-
ies with traditional controlled experiements [71]. In this paper, we
now report on the actual experiments inside an fMRI scanner that
we conducted subsequently.2. FMRI STUDIES IN A NUTSHELL
In this section, we give a high-level view of our study; we de-
scribe the details in Section 3.
Rationale of fMRI Studies. When studying cognitive pro-
cesses in the brain, scientists often follow a pattern of research that
begins with a single case of brain injury that interferes with a cog-
nitive behavior, followed by further studies locating and isolating
brain activity. To identify a region of the brain, scientists use in-
struments with high spatial precision, such as fMRI scanners.
After having established a general idea of where brain activity is
occurring, scientists further try identifying the timing and interac-
tion of brain activity among brain regions. For example, scientists
will try to measure the time to process a color or a word.
Complex behaviors, such as understanding a spoken sentence,
require interactions among multiple areas of the brain. Eventually,
to create a model of behavior, scientists use techniques to dissoci-
ate activated brain areas to understand how a particular brain area
contributes to a behavior. For instance, scientists found that the
left medial extra striate cortex was associated with visual process-
ing of words and pseudo words that obey English spelling, but not
activated by unfamiliar strings of letters or letter-like forms [57].
To reference an identiÔ¨Åed brain location, Brodmann areas have
proved useful as classiÔ¨Åcation system. There are 52 Brodmann
area (some are divided further) [11], each associated with cogni-
tive processes, such as seeing words or retrieving meaning from
memory. Through extensive research in this Ô¨Åeld over the past
twenty years, there is a detailed and continuously growing map
between Brodmann areas and associated cognitive processes (e.g.,
www.cognitiveatlas.org shows an atlas). Due to its success,
we selected fMRI to evaluate whether it is feasible to measure pro-
gram comprehension.
Given such map, if we study a new task, such as program com-
prehension, we can identify which brain regions are activated and
consequently hypothesize which cognitive processes are involved.
For example, we found that one of the activated regions in our study
is related to language recognition, so we can hypothesize that lan-
guage recognition is an integral part of program comprehension,
which was not certain a priori (see Section 5.2).
General Challenges of fMRI Studies. Studies using fMRI
face general challenges due to the technologies involved, which
are very different from, say, controlled experiments in empirical
software engineering.
fMRI measures differences in blood-oxygen levels in the brain.
If a brain region becomes active, its oxygen need increases, and
the amount of oxygenated blood in that region increases, while the
amount of deoxygenated blood decreases‚Äîknown as the BOLD
(blood oxygenation level dependent) effect. Oxygenated and de-
oxygenated blood have different magnetic properties, which are
measured by fMRI scanners to identify active brain regions.
The BOLD effect needs a few seconds to manifest. Typically,
after about 5 seconds, it peaks; after a task is Ô¨Ånished, the oxygen
level returns to the baseline level after 12 seconds. Often, before
returning to the baseline, the oxygen level drops below the base-
line [39]. Thus, the length of the experiment has to be planned
carefully. For optimal measurement of the BOLD effect, task du-
rations between 30 and 120 seconds have proved useful, followed
by a rest condition of about 30 to 60 seconds. A longer task dura-
tion allows the BOLD signal to accumulate, which produces better
differences between tasks. Furthermore, we need several measure-
ments, so an experiment consists of several similar tasks to average3791public static void main(String[] args) {
2String word = "Hello";
3String result = new String();
4
5for (int j = word.length() - 1; j >= 0; j--)
6 result = result + word.charAt(j);
7
8System.out.println(result);
9}
Figure 2: Source code for one comprehension task with ex-
pected output ‚ÄòolleH‚Äò.1public static void main(String[] ) {
2String word = "Hello‚Äô;
3String result = new String();
4
5for (int j = word.length() - 1; j >= 0; j--)
6 result = result + word.charAt(j);
7
8System.out.println{result);
9}
Figure 3: Source code for a syntax task with errors in
Line 1, 2, and 8.
the BOLD effect over all tasks. This way, we can make statistically
sound conjectures about the BOLD effect.
To unambiguously determine the brain region in which the
BOLD effect took place, we need to avoid motion artifacts, that is,
noise that occurs when participants move their head. To this end,
participants are instructed to lie as motionless as possible during
the measurement, and their head is Ô¨Åxed with cushions. Further-
more, communication and interaction with participants is limited,
because speaking or pressing buttons also causes motion artifacts.
In such a restricted setting, the experiment duration should not ex-
ceed one hour, because after that, participants start getting restless.
Additionally, participants can see a relatively small screen re-
Ô¨Çected through a mirror (illustrated in Figure 1b), which cannot
reasonably show more than 20 lines of text.
Finally, we need to distinguish brain activations caused by the
experimental tasks from other activations. In tasks that require par-
ticipants to watch a screen or listen to a signal, there will be activa-
tions caused by visual or audio processing. To Ô¨Ålter activations that
are not speciÔ¨Åc for the experimental tasks, we need to design con-
trol tasks that are as similar as possible to the experimental tasks
and differ only in the absence of the targeted cognitive process.
Requirements for Our fMRI Study. For a study on program
comprehension, the general fMRI challenges translate into a spe-
ciÔ¨Åc set of requirements.
First, due to the small mirror in the fMRI scanner, we can show
only a limited amount of source code at a time. Technically, it
is possible to let participants scroll, but that would cause motion
artifacts, and we wanted to avoid any bias as far as possible.
Second, we need source-code fragments with a suitable difÔ¨Å-
culty. If source code is too easy to understand, participants may
Ô¨Ånish too early, such that the BOLD activation returns to the base-
line before the end of a trial. On the other hand, if source code is too
difÔ¨Åcult, participants cannot Ô¨Ånish understanding it. In this case,
we cannot be sure that the cognitive process actually took place
long enough to be measured. The challenge is to Ô¨Ånd the right level
of difÔ¨Åculty‚Äîshort code fragments that require 30 to 120 seconds
to understand. In a one-hour experiment, we can perform about a
dozen repetitions, for which we need comparable tasks.
Finally, to Ô¨Ålter out irrelevant activation, we need control tasks
that ideally differ from the comprehension tasks only in the ab-
sence of comprehension, nothing else. In our context, control tasks
are different from typical control tasks in software-engineering ex-
periments, where a baseline tool or language is used; in fMRI, the
similarity is deÔ¨Åned at a low, Ô¨Åne-grained level, such that we can
observe the activation caused by comprehension only.
These constraints‚Äîshort code fragments of controlled difÔ¨Åculty
and limited repetitions‚Äîimpair external validity, as we discuss in
Section 7. Results of fMRI studies can be generalized to realistic
situations only with care.Overview of Our fMRI Study. Given the constraints, we
selected short algorithms that are taught in Ô¨Årst-year undergradu-
ate computer-science courses as comprehension tasks , such as the
string-reversal code in Figure 2. We asked participants to deter-
mine the output of the program ("olleH", in our example), which
they can accomplish only if they understand the source code. The
programs we used included sorting and searching in arrays, string
operations, and simple integer arithmetic. To account for differ-
ent domain knowledge of participants, we excluded its inÔ¨Çuence
by obfuscating identiÔ¨Åers and enforcing program comprehension
that required understanding code from the bottom-up, that is, from
syntax to semantics (see Sec 3.1).
As control tasks ( syntax tasks ), we introduced syntax errors, such
as quotation marks or parentheses that do not match and missing
semicolons or identiÔ¨Åers, into the same code fragments as for the
comprehension tasks (illustrated in Figure 3). Then, we asked par-
ticipants to Ô¨Ånd syntax errors (Lines 1, 2, and 8). Comprehension
and syntax tasks are similar, yet sufÔ¨Åciently different: Both require
the participants to look at almost identical pieces of text, but for the
syntax tasks, participants do not need to understand the code.
To Ô¨Ånd suitable comprehension and syntax tasks, we conducted
pilot studies in a computer lab (Figure 1a). We let a total of 50 par-
ticipants solve 23 comprehension tasks and search for more than
50 syntax errors. For the syntax-error tasks, we asked participants
whether they understood the source code to locate the errors, which
occurred only occasionally. Based on our observations, we selected
12 source-code snippets and corresponding syntax errors with suit-
able duration and difÔ¨Åculty.
For the actual study (Figure 1b), we conducted the experiment
with 17 participants inside an fMRI scanner. Although initial fMRI
studies often do not yield conclusive results because of missing
empirical evidence (e.g., related studies, hypotheses about involved
areas), we measured a clear activation pattern (Figure 1c), which is
an encouraging result that we discuss in Section 5.
3. STUDY DESIGN
Having provided a high-level overview, we now present the tech-
nical details of our study. Additional material (e.g., all source-code
snippets) is available at the project‚Äôs website.1Readers interested
only in the big picture and the results may skip Section 3.
3.1 Objective
To the best of our knowledge, we performed the Ô¨Årst fMRI study
to measure program comprehension. Since we are exploring our
options, we do not state speciÔ¨Åc research hypotheses about acti-
vated brain regions, but, instead, pose a research question:
RQ: Which brain regions are activated during program compre-
hension?
1tinyurl.com/ProgramComprehensionAndfMRI/380To answer this question, we need to take a look at the complex-
ity of the comprehension process. There are, roughly, two classes
of comprehension models: top-down comprehension [12, 74] and
bottom-up comprehension [56, 69] (see [18] for an overview
of program-comprehension models). Top-down comprehension
means that, when programmers are familiar with a program‚Äôs do-
main, they use their domain knowledge to understand source code.
During that process, beacons (e.g., familiar identiÔ¨Åer names) help
to form hypotheses about a program‚Äôs purpose. If developers can-
not apply their domain knowledge, they use bottom-up comprehen-
sion, so they understand source code statement by statement. Since
differences in domain knowledge are hard to control, we expect
more noise in top-down comprehension. To avoid any possible ad-
ditional activation, we focus on bottom-up comprehension.
3.2 Experimental Design
All participants completed the experiment in the same order. Be-
fore the measurement, we explained the procedure to each par-
ticipant and they signed an informed consent form. Each session
started with an anatomical measurement stage that lasted 9 min-
utes. This was necessary to map the observed activation to the cor-
rect brain regions. Next, participants solved tasks inside the fMRI
scanner in the Leibniz Institute for Neurobiology in Magdeburg.
We had 12 trials, each consisting of a comprehension task and a
syntax task, separated by rest periods:
1. Comprehension task [60 seconds]
2. Rest [30 seconds]
3. Syntax task [30 seconds]
4. Rest [30 seconds]
The rest periods, in which participants were instructed to do
nothing, was our baseline (i.e., the activation pattern when no spe-
ciÔ¨Åc cognitive processes take place). To familiarize participants
with the setting, we started with a warming-up trial, a hello-world
example that was not analyzed. Instead of saying or entering the
output of source-code snippets, participants indicated when they
have determined the output in their mind or located all syntax er-
rors by using the left of two keys of a response box with their right
index Ô¨Ånger. Directly after the scanning session, participants saw
the source code again on a laptop and entered their answer to ensure
that comprehension took place. With this procedure, we minimized
motion artifacts during the fMRI measurement.
3.3 Material
Initially, we selected 23 standard algorithms that are typically
taught in Ô¨Årst-year undergraduate computer-science education at
German universities. For example, we had algorithms for sorting
or searching in arrays, string operations (cf. Fig. 2), and simple in-
teger arithmetic, such as computing a power function (see project‚Äôs
website for all initially selected source-code snippets). The selected
algorithms were different enough to avoid learning effects from one
algorithm to another, but yet similar enough (e.g., regarding length,
difÔ¨Åculty) to elicit similar activation, which is necessary for aver-
aging the BOLD effects over all tasks.
We created a main program for each algorithm, printing the out-
put for a sample input. All algorithms are written in imperative
Java code inside a single main function without recursion and with
light usage of standard API functions. To minimize cognitive load
caused by complex operations that are not inherent to program
comprehension, we used small inputs and simple arithmetic (e.g.,
2 to the power of 3). To avoid inÔ¨Çuences due to domain knowl-
edge and possible brain activation caused by memory retrieval, we
obfuscated identiÔ¨Åer names, such that participants needed bottom-
up comprehension to understand the source code. For example, inFigure 2, the variable result does not give a hint about its content
(i.e., that it holds the reversed word), but only about its purpose
(i.e., that it contains the result).
We injected three syntax errors into every program to derive con-
trol tasks that are otherwise identical to the corresponding compre-
hension tasks, as illustrated in Figure 3. The syntax errors we in-
troduced can be located without understanding the execution of the
program; they merely require some kind of pattern matching.
In a Ô¨Årst pilot study [71], we determined whether the tasks have
suitable difÔ¨Åculty and length. In a lab session, we asked partici-
pants to determine the output of the source-code snippets and mea-
sured time and correctness. 41 undergraduate computer-science
students of the University of Passau participated. To simulate the
situation in the fMRI scanner, participants were not allowed to
make any notes during comprehension. Based on the response time
of the participants, we excluded six snippets with a too high mean
response time ( >120 seconds) and one snippet with a too low re-
sponse time ( <30 seconds). Regarding correctness, we found that,
on average, 90 % of the participants correctly determined the out-
put, so none of the snippets had to be excluded based on difÔ¨Åculty.
In a second pilot study, we evaluated the suitability of syntax
tasks, so that we can isolate the activation caused only by compre-
hension. Undergraduate students from the University of Marburg
(4) and Magdeburg (4), as well as one professional Java program-
mer located syntax errors. We analyzed response time and correct-
ness to select suitable syntax tasks. All response times were within
the necessary range, and most participants found, at least, two syn-
tax errors. Thus, the syntax tasks had a suitable level of difÔ¨Åculty.
For the session in the fMRI scanner, we further excluded four
tasks to keep the experiment time within 1 hour. We excluded one
task with the shortest and one with the longest response time. We
also excluded two tasks that are similar to other tasks (e.g., adding
vs. multiplying numbers). We deÔ¨Åned a Ô¨Åxed order for the source-
code snippets. Whenever possible, we let participants Ô¨Årst com-
prehend a snippet, then, in a later trial, locate syntax errors in the
corresponding snippets, with a large as possible distance between
both. This way, we minimized learning effects.
Furthermore, we assessed the programming experience of partic-
ipants with an empirically developed questionnaire to assure a ho-
mogeneous level of programming experience [24], and we assessed
the handedness of our participants with the Edinburgh Handedness
Inventory [52], because the handedness correlates with the role of
the brain hemispheres [45] and, thus, is necessary to correctly ana-
lyze the activation patterns.
3.4 Participants
To recruit participants, we used message boards of the University
of Magdeburg. We recruited 17 computer-science and mathemat-
ics students, two of them female, all with an undergraduate level of
programming experience and Java experience (see projects website
for details), comparable to our pilot-study participants. Thus, we
can assume that our participants were able to understand the algo-
rithms within the given time frame. We selected students, because
they are rather homogeneous; this way, the inÔ¨Çuence of different
backgrounds is minimized.
All participants had normal or corrected-to-normal vision. One
participant was left handed, but showed the same lateralization as
right handers, as we determined by a standard lateralization test [7].
The participants gave written informed consent to the study, which
was approved by the ethics committee of the University of Magde-
burg. As compensation, the participants received 20 Euros. The
participants were aware that they could end the experiment at any
time.3813.5 Imaging Methods
The imaging methods are standard procedure of fMRI studies.
Source-Code Presentation. For source-code presentation
and participant-response recording, we used the Presentation soft-
ware ( www.neurobs.com ) running on a standard PC. Source code
was back-projected onto a screen that could be viewed via a mirror
mounted on the head coil (cf. Fig. 1b). The distance between the
participant‚Äôs eyes and the screen was 59cm, with a screen size of
325260mm, which is appropriate for an angle of 15. The
source-code snippets were presented in the center of the screen
with a font size of 18, as deÔ¨Åned in the Presentation software. The
longest source-code snippet had 18lines of code.
Data Acquisition. We carried out the measurements on a
3 Tesla scanner (Siemens Trio, Erlangen, Germany) equipped with
an eight channel head coil. The 3D anatomical data set of the
participant‚Äôs brain ( 192slices of 1mm each) was obtained before
the fMRI measurement. Additionally, we acquired an Inversion-
Recovery-Echo-Planar-Imaging (IR-EPI) scan with the identical
geometry as in the fMRI measurement, to obtain a more precise
alignment of the functional to the 3D anatomical data set.
For fMRI, we acquired 985 functional volumes in 32 minutes
and 50 seconds using an echo planar imaging (EPI) sequence (echo
time (TE), 30 ms; repetition time (TR), 2000 ms; Ô¨Çip angel, 80;
matrix size, 6464; Ô¨Åeld of view, 19:2cm19:2cm;33slices of
3mm thickness with 0:45mm gaps). During the scans, participants
wore earplugs for noise protection.
Data Preparation. We analyzed the functional data with
BrainV oyagerTMQX 2.1.2 ( www.brainvoyager.com ). We started
a standard sequence of preprocessing steps, including 3D-motion
correction (where each functional volume is coregistered to the Ô¨Årst
volume of the series), linear trend removal, and Ô¨Åltering with a high
pass of three cycles per scan. This way, we reduced the inÔ¨Çuence of
artifacts that are unavoidable in fMRI studies (e.g., minimal move-
ment of participants). Furthermore, we transformed the anatomical
data of each participant to a standard Talairach brain [76]. This
way, we can average the BOLD effect over all participants (see
next paragraph).
Analysis Procedure. We projected the functional data set to
the IR-EPI images and co-registered these with the 3D-data set.
Then, we transformed the fMRI data to Talairach space and spa-
tially smoothed them with a Gaussian Ô¨Ålter (FWHM= 4mm). For
the random-effects GLM analysis, we deÔ¨Åned one predictor for the
comprehension tasks and one for the syntax tasks. These were con-
volved with the two-gamma hemodynamic response function using
the default parameters implemented in BrainV oyagerTMQX. We av-
eraged the hemodynamic response for each condition (comprehen-
sion, syntax) across the repetitions. Furthermore, we normalized
the BOLD response to the baseline that is deÔ¨Åned by averaging the
BOLD amplitude 15 seconds before the onset of the comprehension
and syntax condition, respectively. Then, we averaged the BOLD
response over all participants.
Next, we contrasted comprehension with the rest condition using
a signiÔ¨Åcance level of p <0:05(FDR-corrected [5]), to determine
the voxels that indeed showed a positive deÔ¨Çection of the BOLD
response, compared to the rest period (a negative deÔ¨Çection does
not show a real activation, so only the positive deÔ¨Çections are of in-
terest). These voxels comprised a mask, which was used in the sub-
sequent contrast, where we directly compared comprehension withsyntax tasks at a signiÔ¨Åcance level of p <0:01(FDR-corrected)
and a minimum cluster size of 64mm3.
As the last step, we determined the Brodmann areas based on the
Talairach coordinates with the Talairach daemon (client version,
available online at www.talairach.org ). The Talairach space is
used for the technical details of the analysis, and the Brodmann
areas are used to map activated areas to cognitive processes.
4. RESULTS
In Figure 4, we show the resulting activation pattern of the anal-
ysis, including the time course of the BOLD responses for each
cluster. The activation picture and BOLD responses are averaged
over all tasks per condition (comprehension, syntax) and partici-
pants; the gray area around the time courses shows the standard
deviation based on the participants‚Äô averaging.
We included the data of all participants, since all showed com-
prehension of the source-code snippets by one of three ways: en-
tering the correct output of the source code after the experiment,
correctly describing what the source code was doing, or by ensur-
ing that they attempted to comprehend the source code (based on
the questionnaire after the measurement; see project‚Äôs website for
details).
In essence, we found Ô¨Åve relevant activation clusters, all in the
left hemisphere. For each cluster, we show Talairach coordinates,
the size of the cluster, related Brodmann areas, and relevant as-
sociated cognitive processes (note that deciding which cognitive
processes are relevant belongs to the interpretation, not results; see
Section 5). Thus, we can answer our research question:
RQ: During program comprehension, Brodmann areas 6, 21, 40,
44, and 47 are activated.
5. DISCUSSION
Having presented our results, we now interpret the activation pat-
tern. As is standard in fMRI studies, we start with relating relevant
cognitive processes and Brodmann areas (Figure 1d). Next, we
look at tasks of other fMRI studies, in which similar Brodmann
areas have been identiÔ¨Åed, and we relate our Ô¨Åndings to previous
Ô¨Åndings (Figure 1e). Last, we abstract from Brodmann areas and
hypothesize how the cognitive processes involved contribute to pro-
gram comprehension. We conclude with a discussion about what
cognitive processes are relevant for program comprehension, based
on our and other Ô¨Åndings of fMRI studies (Figure 1f).
In our study, we observed activation in Ô¨Åve of the 52 Brodmann
areas that are associated with cognitive processes (cf. Section 2).
Thus, Ô¨Ånding Ô¨Åve activated clusters, which are related to activities
that Ô¨Åt well to our understanding of the comprehension process,
especially in an initial study, is a promising result. However, indi-
vidual Brodmann areas are often associated with multiple cognitive
processes. Thus, as part of the interpretation, we discussed among
the author team (which included a psychologist, a neurobiologist,
a linguist, as well as computer scientists and software engineers)
whether a process is relevant or irrelevant for program comprehen-
sion. For example, Brodmann area 21 is typically activated when
humans give a spoken response. However, our setting did not in-
clude a spoken response, so this process and according studies were
not relevant for us. Still, for completeness and replication, we men-
tion all associated activities.
Note that, since we look only at the difference of activation pat-
tern between the comprehension and syntax tasks, we consider only
activation caused by comprehension. For example, we do not ex-
pect (and did not Ô¨Ånd) activations regarding the visual perception
of source code or locating syntax errors (i.e., syntax-error location382BA21  BA6 BA40  BA47  BA44  BA 6: Middle frontal gyrus
(Talairach coord.: -26, 17, 52; cluster size: 1279)
Time in seconds BOLD signal in % 
0 30 60 0.0 0.2 0.4 
Attention
Division of attention
Language
Silent word reading
Working memory
Verbal/numeric
Problem solving
BA 21: Middle temporal gyrus
(Talairach coord.: -55, -39, -2; cluster size: 4746)
Time in seconds BOLD signal in % 
0 30 60 0.0 0.2 0.4 
Semantic memory retrieval
Categorization
BA 40: Inferior parietal lobule
(Talairach coord.: -51, -49, 41; cluster size: 3368)
Time in seconds BOLD signal in % 
0 30 60 0.0 0.2 0.4 
Working memory
Verbal/numeric
Problem solving
BA 44: Inferior frontal gyrus
(Talairach coord.: -50, 11, 16; cluster size: 698)
Time in seconds BOLD signal in % 
0 30 60 0.0 0.2 0.4 
Working memory
Verbal/numeric
BA 47: Inferior frontal gyrus
(Talairach coord.: -52, 31, 0; cluster size: 546)
Time in seconds BOLD signal in % 
0 30 60 0.0 0.2 0.4 
Language
Silent word reading
Working memory
Problem solving
Figure 4: Observed activation pattern for program comprehen-
sion and time courses of the BOLD response for each cluster.
The gray area around the time courses depicts the standard de-
viation based on the participants. BA: Brodmann area.did not activate any areas that are not activated for program com-
prehension).
5.1 Brodmann Areas 6 and 40
Similar cognitive processes are associated with Brodmann ar-
eas (BA) 6 and 40, so we discuss them together. In the context
of our study, the processes division of attention ,silent word read-
ing,working memory for verbal and/or numerical material , and
problem solving are particularly relevant.2When discussing each
relevant activity, we also describe results of related neuro-imaging
studies and the relationship to program comprehension.
Division of Attention. Division of attention describes that at-
tention has to be distributed among more than one cognitive activ-
ity. Other studies of divided attention also found both, BA 6 and
BA 40, activated. For example, Vandenberghe and others let par-
ticipants discriminate visually presented objects regarding two fea-
tures (orientation and location) [79]. These activities are similar to
what participants did in our study, that is, dealing at the same time
with understanding statements of the source code and the numbers
or words that the source code was manipulating. In the syntax tasks,
participants were looking only for syntax errors and did not have to
divide their attention to hold any values or words.
Silent Word Reading. In our study, participants read words
and, in the comprehension task, needed to understand their mean-
ing (e.g., for denotes a loop). Other studies also found both areas
activated when participants understood the meaning of sentences,
compared to deciding whether a sentence or word is grammatically
correct [10, 62]. This is in line with understanding the meaning of
source-code statements, compared to analyzing syntactical correct-
ness of statements in our syntax tasks.
Verbal/Numerical Working Memory. Working memory is
relevant for many cognitive tasks. One part of working memory,
the phonological loop, allows us to memorize spoken information,
such as telephone numbers, as long as we repeat it (either spoken
aloud or silently) [2]. Numerous studies that let participants use
verbal rehearsal found the same Brodmann areas (6 and 40) acti-
vated. For example, Smith and others let participants keep letters
in mind [73]; Awh and others additionally let participants compare
target letters with letters that have been shown two letters earlier in
a sequence of letters [1]. In our study, participants had to keep the
values of variables that the source code was manipulating in mind
to understand the source code. Additionally, when loops were part
of the source code, participants had to reason and maintain infor-
mation about loop iterations, whether mentally stepping through
the loop or inductively determining its effect on output. Both ac-
tivities were not necessary when identifying syntax errors. Thus,
the phonological loop Ô¨Åts well to our understanding of bottom-up
program comprehension.
Problem Solving. Problem solving is a broad term that is re-
lated to several similar tasks, for example, the Wisconsin Card Sort-
ing test [6] or Raven‚Äôs Progressive Matrices [63]. Both tests require
participants to abstract from presented patterns and discover the
2Other associated activities that do not appear relevant are (a) at-
tention regarding orientation and stimulus-response compatibility,
(b) space/motion perception and imagery, (c) spatial and object-
related working memory, (d) episodic memory encoding of objects
and space, (e) episodic memory retrieval of context information as
well as retrieval effort, and (f) skill learning of unpracticed (non-)
motor skills.383rules that construct the material. This is similar to our comprehen-
sion tasks, in which participants need to abstract from statements
in source code and discover how and why these statements work
together, which is not necessary for locating syntax errors. Other
fMRI studies also found BA 6 and 40, for example, when using
the above-mentioned Wisconsin Card Sorting test [50] or Raven‚Äôs
Progressive Matrices [61].
Overall, BA 6 and 40 Ô¨Åt well into our understanding of program
comprehension. By consulting related studies, we found related
processes that capture the multiple facets of understanding source
code. The remaining three Brodmann areas are often found in
language-based experiments, so we discuss them together.
5.2 Brodmann Areas 21, 44, and 47
In addition to other cognitive processes,3BA 21, 44, and 47 are
related to different facets of language processing. Numerous stud-
ies showed the involvement of all three Brodmann areas in artiÔ¨Å-
cial as well as natural-language processing [3, 58, 72]. In partic-
ular, artiÔ¨Åcial-language processing is interesting, because artiÔ¨Åcial
languages are based on formal grammars and limited sets of sym-
bols, such as words or graphemes, from which letter or word se-
quences are created. Participants of typical artiÔ¨Åcial-language stud-
ies should decide based on their intuition, after a learning period,
whether sequences are grammatical or not, resulting in activation
in BA 21, 44, and 47. ArtiÔ¨Åcial-language processing and program
comprehension are similar, since both usually built on a limited set
of elements and rules; in the syntax tasks, participants had to do
some kind of pattern matching to locate the syntax errors. Based
on the similarity of program comprehension to artiÔ¨Åcial-language
processing, which is in turn similar to natural-language processing,
we conjecture that one part of program comprehension involves
language processing.
Theposterior middle temporal gyrus (MTG) (BA 21) is closely
associated with semantic processing at the word level. Both imag-
ing and lesion studies suggest an intimate relation between the suc-
cess or failure to access semantic information and the posterior
MTG [9, 22, 78]. In our study, participants also needed to identify
the meaning of written words in the source code to successfully un-
derstand the source code and its output, which was not necessary
for the syntax tasks. Thus, we found evidence that understanding
the meaning of single words is a necessary part of program com-
prehension. This may not sound too surprising, but we actually
observed it in a controlled setting.
The inferior frontal gyrus (IFG) (BA 44 and 47) is related to
combinatorial aspects in language processing, for example, pro-
cessing of complex grammatical dependencies in sentences during
syntactic processing [25, 30]. Several studies suggest that real-time
combinatorial operations in the IFG incorporate the current state of
processing and incoming information into a new state of processing
[33, 59]. Hence, the IFG was proposed to be involved in the uni-
Ô¨Åcation of individual semantic features into an overall representa-
tion at the multi-word level [78]. This is closely related to bottom-
up program comprehension, where participants combine words and
statements to semantic chunks to understand what the source code
3Again, all areas are activated during different cognitive processes.
Most likely irrelevant processes are (a) object perception, (b) spo-
ken word recognition, (c) written word recognition with spoken re-
sponse, (d) object-related working memory, (e) episodic memory
encoding of objects, (f) episodic memory retrieval of nonverbal ma-
terial regarding retrieval mode and effort, (g) conceptual priming,
and (h) skill learning of unpracticed motor skills.is doing. In the syntax tasks, participants did not need to group
anything to succeed.
In addition to the individual Brodmann areas, there is evidence
for a direct interaction among the activated areas of our compre-
hension task. Two separate clusters were activated in the IFG, one
in BA 44 and one in BA 47, which is also suggested by other
fMRI studies. BA 44 was mainly associated with core syntactic
processes, such as syntactic structure building [25, 27, 28]. In con-
trast, BA 47 is assumed to serve as a semantic executive system
that regulates and controls retrieval, selection, and evaluation of se-
mantic information [65, 78]. Accordingly, program comprehension
requires the participants to build up the underlying syntactic struc-
tures, to retrieve the meanings of the words and symbols, and to
compare and evaluate possible alternatives; none of these processes
is necessary to locate syntax errors.
Moreover, reciprocal connections via a strong Ô¨Åber pathway be-
tween BA 47 and the posterior MTG‚Äîthe inferior occipito-frontal
fasciculus ‚Äîhave been claimed to support the interaction between
these areas, such that appropriate lexical-semantic representation
are selected, sustained in short-term memory throughout sentence
processing, and integrated into the overall context [78]. Regard-
ing program comprehension, we conjecture that, to combine words
or symbols to statements, and statements to semantic chunks, the
neural pathway between the MTG and IFG is involved.
6. IMPLICATIONS FOR
PROGRAM COMPREHENSION
Having identiÔ¨Åed the clusters and related them to other fMRI
studies and speciÔ¨Åc activities of program comprehension, we now
combine all Ô¨Åndings to a high-level understanding of bottom-up
program comprehension.
Working Memory and Divided Attention. First, we found
areas related to working memory, especially the phonological loop
of verbal/numerical material and problem solving. Regarding the
phonological loop, we assume that participants needed to keep the
value of numbers or words in mind, while going through the source
code statement by statement, dividing their attention during this
process. Furthermore, we found a relationship to problem-solving
activities. In our experiment, we enforced bottom-up comprehen-
sion by obfuscating identiÔ¨Åer names, which shows similarities to
the Wisconsin Card Sorting Test [6] and Raven‚Äôs Progressive Ma-
trices [63]. In both tests, as well as during bottom-up comprehen-
sion, participants need to understand underlying rules; how cards
are sorted, how Ô¨Ågures are created, or how loops terminate and
when, how and where characters or numbers are modiÔ¨Åed. Fur-
thermore, participants need to apply these rules, such that they can
sort cards, continue rows of Ô¨Ågures, or determine the correct out-
put. Thus, our Ô¨Åndings align well with the common understanding
of bottom-up comprehension, in which rules and relationships in
source code have to be discovered and applied.
Consequently, to become excellent in bottom-up comprehension,
we might need to train working memory capacity, divided attention,
and problem-solving ability.
Language Processing. Second, we found a strong relation to
language processing. To understand source code, participants had
to process single words and symbols as well as statements that con-
sist of single words (located in the posterior MTG). For example,
in Figure 2, Line 6, the participants needed to process result ,
=,word ,+, and charAt , and combine all to understand what this
statement does (i.e., adding a single character to the result). Addi-384public static void main (String[] args) {
  String word = "Hello";
  String result = new String ();
  for (int j = word.length() - 1;
         j >= 0; j--)
    result = result + word.charAt(j);
  System.out.println(result);
}40
4744
216
Analyze words and 
symbolsKeep values in mind
Integrate to state -
ments and chunksFigure 5: Visualization of how bottom-up program comprehen-
sion might take place.
tionally, participants had to integrate all statements into a semantic
chunk that reverses a word. Via strong neural pathways, both ar-
eas are connected, which is necessary to integrate words/symbols
to statements and statements to semantic chunks. Hence, our re-
sults support Dijkstra‚Äôs claim that ‚Äúan exceptionally good mastery
of one‚Äôs native tongue is the most vital asset of a competent pro-
grammer‚Äù [21]. Consequently, focus on language learning in early
childhood might facilitate learning programming.
Toward a Model of Bottom-up Comprehension. We can
hypothesize what a cognitive model of bottom-up program com-
prehension can look like: Participants analyze words/symbols of
source code, combine symbols to statements, then statements to
semantic chunks. Simultaneously to comprehending and integrat-
ing words/symbols and statements, participants keep the values of
words and numbers in their phonological loop to correctly under-
stand the source code. In Figure 5, we illustrate this process.
Based on this model, we can hypothesize what inÔ¨Çuences pro-
gram comprehension. For example, if we increase the number of
variables beyond the capacity of the phonological loop, program
comprehension should be impaired (more discussion in Section 8).
7. THREATS TO V ALIDITY
The challenges and requirements of fMRI studies give rise to
several threats to validity. First, we performed several steps to inter-
pret the data. Especially, when deciding which cognitive processes
for each Brodmann area are relevant, we might have missed im-
portant processes. As a consequence, our interpretation might have
led to a different comprehension model. To reduce this threat, we
discussed among the author team, which combines expertise from
psychology, neurobiology, linguistics, as well as computer science
and software engineering, for each process whether it might be re-
lated to our comprehension tasks. Furthermore, we mentioned all
processes that are known to be associated with these Brodmann
areas (Footnotes 2 and 3), so that readers can make their own judg-
ment about relevant processes.
Second, the source-code snippets that we selected were compar-
atively short, at most, 18 lines of code. Furthermore, we focused on
bottom-up comprehension, and we explicitly avoided scrolling or
typing to reduce any noise as far as possible. Thus, we focused on
only one aspect of the complex comprehension process and cannot
generalize our results to programming in the large‚Äîclearly, more
studies have to follow. Nevertheless, it is conceptually possible to
use a more complex setting, even tasks that last for several hours,
and our results encourage us to try such larger settings in future
studies, possibly also with other neuro-imaging techniques (e.g.,
single-photon emission computed tomography).
Furthermore, we cannot be entirely certain to what extent we
ensured bottom-up comprehension. It is possible that participants
recognized some algorithms, as they were taken from typical in-
troductory courses. However, since we obfuscated identiÔ¨Åer names
and the time per source-code snippet was relatively short, partici-pants used bottom-up comprehension most of the time; this conjec-
ture is supported by the fact that we did not observe activation in
typical memory-related areas.
Another threat to external validity is that we kept the background
of our participants, such as their programming experience and cul-
ture, constant to reduce any noise during measurement. Further-
more, we did not control for gender of participants, which might
bias the results, in that women show a tendency to prefer bottom-
up comprehension [26]. Thus, we can generalize our results only
carefully. In the next section, we outline, among others, how such
personal differences might affect program comprehension.
8. FUTURE DIRECTIONS
With our study, we showed that measuring program comprehen-
sion with an fMRI scanner is feasible and can result in a plausible
activation pattern. But, how does our study contribute to software-
engineering research, education, and practice?
Having shown that measuring program comprehension with
fMRI is feasible, we encourage other researchers to apply fMRI
in their research. With careful planning and by consulting ex-
perts, fMRI can be a valuable tool also in software-engineering
research. As the costs and inaccessibility of fMRI studies will de-
crease over time, we believe that they will become a standard tool
in the software-engineering researcher‚Äôs toolbox. We hope that
other researchers can proÔ¨Åt from our experience, learn about re-
quirements and pitfalls of such studies, or even reuse experimental
material, so they do not have to start from scratch.
While our study provides only limited direct answers, it raises
many interesting and substantial questions for future research:
What are the underlying cognitive processes during top-down com-
prehension or the implementation of source code? How should
we train programmers? How should we design programming lan-
guages and tools? Can software metrics capture how difÔ¨Åcult
source code will be to comprehend?
Top-down comprehension. In our experiment, we focused on
bottom-up comprehension to minimize additional activation. In fu-
ture experiments, we shall create more complex source-code snip-
pets in a familiar domain, such that participants use top-down com-
prehension and their memory to understand source code. For ex-
ample, we can show the same source-code snippets without obfus-
cating identiÔ¨Åer names, and observe to what extent they serve as
beacons for participants. Additionally, we shall select programs
that participants are familiar with. In such a setting, we would ex-
pect activation of typical memory areas, such as Brodmann areas
44 and 45 in the inferior frontal gyrus or Brodmann area 10 in the
anterior prefrontal cortex [14]. In conjunction with an eye tracker,
we shall evaluate whether participants Ô¨Åxate on beacons or familiar
elements shorter or longer than unfamiliar statements, and how that
gazing is related to neural activity. Digging deeper, we may ask at
which experience level beginners start using their previous knowl-
edge? To what extent does the knowledge of the domain and other
concepts, such as design patterns, inÔ¨Çuence activation patterns?
Implementing source code. What happens when people im-
plement source code, instead of only understanding it? Writing
source code is a form of synthesizing new information, compared
to analytical program comprehension. Consequently, we might ob-
serve activation of several right-hemispheric regions, such as right
BA 44 and 47 for speech production. It would be interesting to
study whether and how writing source code is similar to and differ-385ent from speech production. Initial evidence suggests that develop-
ers had high levels of subvocal speech while editing code [54].
Training. There are many discussions about the best way to teach
computer science and software engineering [16, 46, 70]. The close
relationship to language processing raises the question of whether
it is beneÔ¨Åcial to learn a programming language at an early age or
to learn multiple programming languages right from the beginning,
which is often a controversial issue in designing computer-science
curricula.
The involvement of working memory and attention may indicate
that both should be trained during programming education. So, it
is certainly worth exploring whether program comprehension can
be improved by training speciÔ¨Åc cognitive abilities (e.g., through
puzzle games). However, researchers disagree to what extent both
can be learned or are rather inborn [23, 75, 82]. Thus, a test prior to
programming education [51, 44] might reveal which students might
struggle with learning programming. Especially, when thinking of
dyslexics, who often have poorer short-term memory and reading
skills compared to non-dyslexics [60], we may expect they strug-
gle; however, many dyslexics report that they can work focused
during programming, for example, because of syntax highlight-
ing [60]. Thus, unraveling the mind of dyslexics might give us
interesting insights into program comprehension.
Having found a strong involvement of language processing sug-
gests that we need excellent language skills to become excellent
programmers. Thus, if we loved learning new languages, we might
also more easily learn new programming languages. It may be
worthwhile to start learning a new (programming) language early
during childhood, because studies showed that learning a second
language early can have beneÔ¨Åts regarding cognitive Ô¨Çexibility,
metalinguistic, divergent thinking skills, and creativity [20]. Simi-
larly, training computational thinking , a fundamental skill for com-
puter scientists [81], prior to learning programming might also give
novices a better start with learning programming, for example, to
correctly specify unexpected states in a program [32].
Furthermore, despite similar education or experience, re-
searchers have observed a signiÔ¨Åcant gap between top developers
and average developers, typically reported as a factor of 10 in terms
of productivity [15, 17, 66]. However, nobody knows exactly how
these top developers became top developers‚Äîthey just areexcel-
lent. This raises many questions about to what extent we can train
programmers at all. Alternatively, we can ask whether it is pos-
sible to predict whether somebody is inclined to become a great
programmer. To answer such questions, we need to know how an
excellent programmer differs from a normal programmer. Interest-
ingly, characteristics of experts have been studied in many Ô¨Åelds.
For example, in an fMRI study, musicians showed a much lower
activation in motor areas when executing hand tapping than non-
musicians [40], and expert golfers, compared to novices, showed
a considerably smaller activation pattern when imagining hitting a
golf ball, because they have somewhat abstracted the activity [48].
In the same rein, excellent programmers may approach program
comprehension differently. Again, understanding the differences
may offer us insights into how to teach beginners, and, in the long
run, develop guidelines for teaching programming.
Programming-Language Design. Traditionally, program-
ming-language design does only marginally involve programmers
and how they work with source code. Instead, experience and
plausibility are used, such as: ‚ÄúAs the world consists of objects,
object-oriented programming is an intuitive way to program‚Äù, ‚ÄúAs
recursion is counter intuitive, recursive algorithms are difÔ¨Åcult tounderstand‚Äù, or ‚ÄúJava shall be similar to C/C++, such that many
developers can easily learn it.‚Äù While experience and common
sense are certainly valuable and may hint some direction on how to
design programming languages, many design decisions that arise
from them have‚Äîto the best of our knowledge‚Äîonly rarely been
tested empirically (e.g., [35]).
In our experiment, we have explored only small imperative code
fragments with only few language constructs. It would be inter-
esting to investigate whether there are fundamentally different ac-
tivations when using more complex language constructs or using
a functional or object-oriented style. For example, when we let
developers understand object-oriented source code, we should ob-
serve activation in typical object-processing areas (e.g., BA 19 or
37), if real-world objects and object-oriented programming are sim-
ilar, which is a frequently stated claim. The design of individual
programming languages as well as entire programming paradigms
may greatly beneÔ¨Åt from insights about program comprehension
gained by fMRI.
Furthermore, having identiÔ¨Åed a close similarity to language pro-
cessing, we can further investigate how different or similar both
processes are. To this end, we envision letting participants read
and comprehend natural-language descriptions as control tasks, in-
stead of Ô¨Ånding syntax errors; computing the difference in activa-
tion pattern, we will see how reading comprehension and program
comprehension differ (if they differ at all). We also envision stud-
ies to explore the impact of natural programming languages [49]
on comprehension, and how comprehension of natural languages,
dead languages (e.g., Latin), and programming languages differ.
Additionally, some researchers believe that the mother tongue
inÔ¨Çuences how native speakers perceive the world (Sapir-Whorf
hypothesis) [67, 80]. Since programming languages are typically
based on English, Western cultures, compared to Asian cultures,
might have a headstart when learning programming [4]. Taking a
closer look at how developers from both cultures understand source
code might give us valuable insights for teaching programming.
Software and Tool Design. Many questions regarding soft-
ware design, modularity, and development tools arise in software
engineering. For instance, the typical approach to hierarchically de-
compose a software system is challenged by the presence of cross-
cutting concerns [77], but the extent to which developers naturally
decompose a software system is unknown. Ostermann and others
argued that traditional notions of modularity assume a model based
on classical logic that differs from how humans process information
(e.g., humans use inductive reasoning, closed-world reasoning, and
default reasoning, which are all unsound in classical logic) [53].
Thus, we may need more natural concepts of modularity.
There has been considerable research in tool-based solutions for
organizing and navigating software [29, 41, 42, 43, 64]. Con-
sidering navigation support, understanding how to support cogni-
tive processes related to spatial abilities and to determine whether
a given tool actually does support those abilities, might improve
comprehension, provide a more disciplined framework for design-
ing tools, and inÔ¨Çuence how we design software.
Software metrics. Many attempts have been made to mea-
sure the complexity of source code. Following initial proposals,
such as McCabe‚Äôs cyclomatic complexity [47] and Halstead‚Äôs dif-
Ô¨Åculty [34], a plethora of code and software metrics has been pro-
posed [38]. Despite some success stories, it is still largely unclear
why a certain metric works in a certain context and how to design
a comprehensive and feasible set of metrics to assist software en-
gineering. Which properties should a metric address? Syntactic386properties, control Ô¨Çow, data Ô¨Çow, semantic dependencies, and so
forth? fMRI may give us a tool to answer these questions, for ex-
ample, by analyzing whether complex data Ô¨Çows (e.g., as targeted
by the DepDegree metric [8]), give rise to distinct or stronger acti-
vations that correspond with complex comprehension activities.
9. RELATED WORK
We are not aware of any fMRI studies examining program com-
prehension. A few studies have used other physiological measures
to study program comprehension, such as eye-tracking [31, 36, 68]
or electromyography [54] to measure the effort during program-
comprehension tasks.
In the neuroscience domain, several studies exist that also study
tasks related to comprehension and detection of syntax errors.
However, these studies, several of which were discussed in Sec-
tion 5, use tasks involving only English words and sentences, not
programs. The following studies are particularly interesting, be-
cause they revealed the same Brodmann areas as our study: In
studies related to reading comprehension and language processing,
participants had to understand text passages or decide whether se-
quences of letters can be produced with rules of a formal gram-
mar [3, 9, 22, 25, 27, 28, 30, 33, 58, 59, 72, 78]. Regarding work-
ing memory, participants had to identify and apply rules or memo-
rize verbal/numerical material [1, 50, 61, 73]. In divided-attention
tasks, participants had to detect two features of objects at the same
time [79].
Further work is needed to distinguish and dissociate brain ac-
tivity related to program comprehension from other similar activi-
ties, such as word comprehension, and to allow us to develop a full
model of program comprehension. Some researchers have already
begun to theorize what a brain-based model of program compre-
hension would look like. Hansen and others propose to use the cog-
nitive framework ACT-R to model program comprehension [37].
Parnin compiled a literature review of cognitive neuroscience and
proposed a model for understanding different memory types and
brain areas exercised by different types of programming tasks [55].
Both approaches are similar to our work by exploring knowledge
of the neuroscience domain.
10. CONCLUSION
To shed light on the process of program comprehension, we used
a relatively new technique: functional magnetic resonance imaging
(fMRI). While in cognitive neuroscience, it has been used for more
than 20 years now, we explored how fMRI can be applied to mea-
sure the complex cognitive process of comprehending source code.
To this end, we selected twelve source-code snippets that partici-
pants should comprehend, which we contrasted with locating syn-
tax errors.
The key results are:
A clear activation pattern of Ô¨Åve different brain regions,
which are associated with working memory (BA 6, BA 40),
attention (BA 6), and language processing (BA 21, BA 44,
BA 47)‚Äîall Ô¨Åt well to our understanding of bottom-up pro-
gram comprehension.
Language processing seems to be essential for program com-
prehension, which Dijkstra already noted. With our study,
we found Ô¨Årst empirical evidence that Dijstra was right,
which may have implications for teaching, such that training
language skills, in addition to working memory and problem
solving, might make programming education more efÔ¨Åcient.
As a further contribution, we shared our experiences and design,
to lower the barrier for further fMRI studies. We hope that fMRIbecomes a standard research tool in empirical software engineer-
ing, so that we and other researchers can understand how devel-
opers understand source code and reÔ¨Åne existing models of pro-
gram comprehension to a uniÔ¨Åed theory, so that we can eventually
tackle the really interesting questions: How do people use domain
knowledge? To what extent is implementing source code a creative
process? Can we train someone to become an excellent program-
mer? How should we design programming languages and tools for
optimal developer support? Can software metrics predict the com-
prehensibility of source code?
11. ACKNOWLEDGMENTS
We thank all participants of our fMRI study and the pilot stud-
ies. Furthermore, we thank J√∂rg Liebig for his is support in con-
ducting the Ô¨Årst pilot study and Andreas F√ºgner for providing pho-
tos. K√§stner‚Äôs work is supported partly by ERC grant #203099 and
NSF award 1318808, and Apel‚Äôs work by DFG grants AP 206/2,
AP 206/4, AP 206/5, and AP 206/6.
12. REFERENCES
[1] E. Awh, J. Jonides, E. Smith, E. Schumacher, R. Koeppe, and
S. Katz. Dissociation of Storage and Rehearsal in Verbal
Working Memory: Evidence from Positron Emission
Tomography. Psychological Science , 7(1):25‚Äì31, 1996.
[2] A. Baddeley. Is Working Memory Still Working? The
American Psychologist , 56(11):851‚Äì864, 2001.
[3] J. Bahlmann, R. Schubotz, and A. Friederici. Hierarchical
ArtiÔ¨Åcial Grammar Processing Engages Broca‚Äôs Area.
NeuroImage , 42(2):525‚Äì534, 2008.
[4] E. Baniassad and S. Fleissner. The Geography of
Programming. In Proc. Int‚Äôl Conf. Object-Oriented
Programming, Systems, Languages and Applications
(OOPSLA) , pages 510‚Äì520. ACM, 2006.
[5] Y . Benjamini and Y . Hochberg. Controlling the False
Discovery Rate: A Practical and Powerful Approach to
Multiple Testing. Journal of the Royal Statistical Society.
Series B (Methodological) , 57(1):289‚Äì300, 1995.
[6] E. Berg. A Simple Objective Technique for Measuring
Flexibility in Thinking. Journal of General Psychology ,
39(1):15‚Äì22, 1948.
[7] A. Bethmann, C. Tempelmann, R. De Bleser, H. Scheich,
and A. Brechmann. Determining Language Laterality by
fMRI and Dichotic Listening. Brain Research ,
1133(1):145‚Äì157, 2007.
[8] D. Beyer and A. Fararooy. A Simple and Effective Measure
for Complex Low-Level Dependencies. In Proc. Int‚Äôl Conf.
Program Comprehension (ICPC) , pages 80‚Äì83. IEEE, 2010.
[9] J. Binder, R. Desai, W. Graves, and L. Conant. Where Is the
Semantic System? A Critical Review and Meta-Analysis of
120 Functional Neuroimaging Studies. Cerebral Cortex ,
19(12):2767‚Äì2796, 2009.
[10] G. Bottini, R. Corcoran, R. Sterzi, E. Paulesu, P. Schenone,
P. Scarpa, R. Frackowiak, and C. Frith. The Role of the Right
Hemisphere in the Interpretation of Figurative Aspects of
Language: A Positron Emission Tomography Activation
Study. Brain , 117(6):1241‚Äì1253, 1994.
[11] K. Brodmann. Brodmann‚Äôs Localisation in the Cerebral
Cortex . Springer, 2006.
[12] R. Brooks. Using a Behavioral Theory of Program
Comprehension in Software Engineering. In Proc. Int‚Äôl Conf.
Software Engineering (ICSE) , pages 196‚Äì201. IEEE, 1978.387[13] R. Brooks. Studying Programmer Behavior Experimentally:
The Problems of Proper Methodology. Commun. ACM ,
23(4):207‚Äì213, 1980.
[14] R. Cabeza and L. Nyberg. Imaging Cognition II: An
Empirical Review of 275 PET and fMRI Studies. J.
Cognitive Neuroscience , 12(1):1‚Äì47, 2000.
[15] E. Chrysler. Some Basic Determinants of Computer
Programming Productivity. Commun. ACM , 21(6):472‚Äì483,
1978.
[16] S. Cooper, W. Dann, and R. Pausch. Teaching Objects-First
in Introductory Computer Science. In Proc. Technical
Symposium on Computer Science Education (SIGCSE) ,
pages 191‚Äì195. ACM, 2003.
[17] D. Darcy and M. Ma. Exploring Individual Characteristics
and Programming Performance: Implications for
Programmer Selection. In Proc. Annual Hawaii Int‚Äôl Conf.
on System Sciences (HICSS) , page 314a. IEEE, 2005.
[18] S. Davies. Models and Theories of Programming Strategy.
Int‚Äôl J. Man-Machine Studies , 39(2):237‚Äì267, 1993.
[19] B. de Alwis, G. Murphy, and S. Minto. Creating a Cognitive
Metric of Programming Task DifÔ¨Åculty. In Proc. Int‚Äôl
Workshop Cooperative and Human Aspects of Software
Engineering (CHASE) , pages 29‚Äì32. ACM, 2008.
[20] R. Diaz. Thought and Two Languages: The Impact of
Bilingualism on Cognitive Development. Review of Research
in Education , 10:23‚Äì54, 1983.
[21] E. Dijkstra. How Do We Tell Truths that Might Hurt? In
Selected Writings on Computing: A Personal Perspective ,
pages 129‚Äì131. Springer, 1982.
[22] N. Dronkers, D. Wilkins, R. Van Valin, Jr, B. Redfern, and
J. Jaeger. Lesion Analysis of the Brain Areas Involved in
Language Comprehension. Cognition , 92(1‚Äì2):145‚Äì177,
2004.
[23] W. Engle, J. Kane, and S. Tuholski. Individual Differences in
Working Memory Capacity and What They Tell us About
Controlled Attention, General Fluid Intelligence, and
Functions of the Prefrontal Cortex. In Models of Working
Memory , pages 102‚Äì134. Cambridge University Press, 1999.
[24] J. Feigenspan, C. K√§stner, J. Liebig, S. Apel, and
S. Hanenberg. Measuring Programming Experience. In Proc.
Int‚Äôl Conf. Program Comprehension (ICPC) , pages 73‚Äì82.
IEEE, 2012.
[25] C. Fiebach, M. Schlesewsky, G. Lohmann, D. von Cramon,
and A. Friederici. Revisiting the Role of Broca‚Äôs Area in
Sentence Processing: Syntactic Integration Versus Syntactic
Working Memory. Human Brain Mapping , 24(2):79‚Äì91,
2005.
[26] M. Fisher, A. Cox, and L. Zhao. Using Sex Differences to
Link Spatial Cognition and Program Comprehension. In
Proc. Int‚Äôl Conf. Software Maintenance (ICSM) , pages
289‚Äì298. IEEE, 2006.
[27] A. Friederici. Towards a Neural Basis of Auditory Sentence
Processing. Trends in Cognitive Sciences , 6(2):78‚Äì84, 2002.
[28] A. Friederici and S. Kotz. The Brain Basis of Syntactic
Processes: Functional Imaging and Lesion Studies.
NeuroImage , 20(1):S8‚ÄìS17, 2003.
[29] W. Griswold, J. Yuan, and Y . Kato. Exploiting the Map
Metaphor in a Tool for Software Evolution. In Proc. Int‚Äôl
Conf. Software Engineering (ICSE) , pages 265‚Äì274. IEEE,
2001.[30] Y . Grodzinsky and A. Santi. The Battle for Broca‚Äôs Region.
Trends in Cognitive Sciences , 12(12):474‚Äì480, 2008.
[31] Y .-G. Gu√©h√©neuc. TAUPE: Towards Understanding Program
Comprehension. In Proc. Conf. Center for Advanced Studies
on Collaborative Research (CASCON) . IBM Corp., 2006.
[32] M. Guzdial. Education: Paving the Way for Computational
Thinking. Commun. ACM , 51(8):25‚Äì27, 2008.
[33] P. Hagoort. On Broca, Brain, and Binding: A New
Framework. Trends in Cognitive Sciences , 9(9):416‚Äì423,
2005.
[34] M. Halstead. Elements of Software Science . Elsevier Science
Inc., 1977.
[35] S. Hanenberg, S. Kleinschmager, and M. Josupeit-Walter.
Does Aspect-Oriented Programming Increase the
Development Speed for Crosscutting Code? An Empirical
Study. In Proc. Int‚Äôl Symposium Empirical Software
Engineering and Measurement (ESEM) , pages 156‚Äì167.
IEEE, 2009.
[36] M. Hansen, R. Goldstone, and A. Lumsdaine. What Makes
Code Hard to Understand? ArXiv e-prints , 1304.5257, 2013.
[37] M. Hansen, A. Lumsdaine, and R. Goldstone. Cognitive
Architectures: A Way Forward for the Psychology of
Programming. In Proc. ACM Int‚Äôl Symposium on New Ideas,
New Paradigms, and ReÔ¨Çections on Programming and
Software (Onward!) , pages 27‚Äì38. ACM, 2012.
[38] B. Henderson-Sellers. Object-Oriented Metrics: Measures of
Complexity . Prentice Hall, 1995.
[39] R. Hoge and G. Pike. Quantitive Measurement Using fMRI.
InFunctional Magnetic Resonance Imaging: An Introduction
to Methods , pages 159‚Äì174. Oxford University Press, 2001.
[40] L. J√§ncke, N. Shah, and M. Peters. Cortical Activations in
Primary and Secondary Motor Areas for Complex Bimanual
Movements in Professional Pianists. Cognitive Brain
Research , 10(1‚Äì2):177‚Äì183, 2000.
[41] C. K√§stner, S. Apel, and M. Kuhlemann. Granularity in
Software Product Lines. In Proc. Int‚Äôl Conf. Software
Engineering (ICSE) , pages 311‚Äì320. ACM, 2008.
[42] M. Kersten and G. Murphy. Mylar: A Degree-of-Interest
Model for IDEs. In Proc. Int‚Äôl Conf. Aspect-Oriented
Software Development (AOSD) , pages 159‚Äì168. ACM, 2005.
[43] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda,
C. Lopez, J.-M. Loingtier, and J. Irwin. Aspect-Oriented
Programming. In Proc. Europ. Conf. Object-Oriented
Programming (ECOOP) , pages 220‚Äì242. Springer, 1997.
[44] T. Klingberg, H. Forssberg, and H. Westerberg. Training of
Working Memory in Children With ADHD. Journal of
Clinical and Experimental Neuropsychology , 24(6):781‚Äì791,
2002.
[45] S. Knecht, B. Dr√§ger, M. Deppe, L. Bobe, H. Lohmann,
A. Fl√∂el, and E.-B. Ringelstein. Handedness and
Hemispheric Language Dominance in Healthy Humans.
Brain , 123(12):2512‚Äì2518, 2000.
[46] M. Knobelsdorf and R. Romeike. Creativity as a Pathway to
Computer Science. In Proc. Annual Conf. Innovation and
Technology in Computer Science Education (ITiCSE) , pages
286‚Äì290. ACM, 2008.
[47] T. McCabe. A Complexity Measure. IEEE Trans. Softw.
Eng., SE-2(4):308‚Äì320, 1976.
[48] J. Milton, A. Solodkin, P. Hlu≈°√≠tk, and S. Small. The Mind of
Expert Motor Performance is Cool and Focused.
NeuroImage , 35(2):804‚Äì813, 2007.388[49] B. Myers, J. Pane, and A. Ko. Natural Programming
Languages and Environments. Commun. ACM , 47(9):47‚Äì52,
Sept. 2004.
[50] Y . Nagahama, H. Fukuyama, H. Yamauchi, S. Matsuzaki,
J. Konish, and H. S. J. Kimura. Cerebral Activation during
Performance of a Card Sorting Test. Brain ,
119(5):1667‚Äì1675, 1996.
[51] K. Oberauer, H.-M. S√º√ü, R. Schulze, O. Wilhelm, and
W. Wittmann. Working Memory Capacity‚ÄîFacets of a
Cognitive Ability Construct. Personality and Individual
Differences , 29(6):1017‚Äì1045, 2000.
[52] R. OldÔ¨Åeld. The Assessment and Analysis of Handedness:
The Edinburgh Inventory. Neuropsychologia , 9(1):97‚Äì113,
1971.
[53] K. Ostermann, P. Giarrusso, C. K√§stner, and T. Rendel.
Revisiting Information Hiding: ReÔ¨Çections on Classical and
Nonclassical Modularity. In Proc. Europ. Conf.
Object-Oriented Programming (ECOOP) , pages 155‚Äì178.
Springer, 2011.
[54] C. Parnin. Subvocalization - Toward Hearing the Inner
Thoughts of Developers. In Proc. Int‚Äôl Conf. Program
Comprehension (ICPC) , pages 197‚Äì200. IEEE, 2011.
[55] C. Parnin and S. Rugaber. Programmer Information Needs
after Memory Failure. In Proc. Int‚Äôl Conf. Program
Comprehension (ICPC) , pages 123‚Äì132. IEEE, 2012.
[56] N. Pennington. Stimulus Structures and Mental
Representations in Expert Comprehension of Computer
Programs. Cognitive Psychologys , 19(3):295‚Äì341, 1987.
[57] S. Petersen, P. Fox, and M. Snyder, A.and Raichle.
Activation of Extrastriate and Frontal Cortical Areas by
Visual Words and Word-like Stimuli. Science ,
249(4972):1041‚Äì1044, 1990.
[58] K. Petersson, V . Folia, and P. Hagoort. What ArtiÔ¨Åcial
Grammar Learning Reveals about the Neurobiology of
Syntax. Brain and Language , 298(1089):199‚Äì209, 2012.
[59] K. Petersson and P. Hagoort. The Neurobiology of Syntax:
Beyond String Sets. Philos. Trans. R. Soc. Lond. B Biol. Sci. ,
367:1971‚Äì1983, 2012.
[60] N. Powell, D. Moore, J. Gray, J. Finlay, and J. Reaney.
Dyslexia and Learning Computer Programming. In Proc.
Annual Conf. Innovation and Technology in Computer
Science Education (ITiCSE) , pages 242‚Äì242. ACM, 2004.
[61] V . Prabhakaran, J. Smith, J. Desmond, G. Glover, and
J. Gabrieli. Neural Substrates of Fluid Reasoning: An fMRI
Study of Neocortical Activation During Performance of the
Raven‚Äôs Progressive Matrices Test. Cognitive Psychology ,
33(1):43‚Äì63, 1996.
[62] C. Price, R. Wise, J. Watson, K. Patterson, D. Howard, and
R. Frackowiak. Brain Activity During Reading: The Effects
of Exposure Duration and Task. Brain , 117(6):1255‚Äì1269,
1994.
[63] J. Raven. Mental Tests Used in Genetic Studies: The
Performances of Related Individuals in Tests Mainly
Educative and Mainly Reproductive. Master‚Äôs thesis,
University of London, 1936.
[64] M. Robillard and G. Murphy. Concern Graphs: Finding and
Describing Concerns Using Structural Program
Dependencies. In Proc. Int‚Äôl Conf. Software Engineering
(ICSE) , pages 406‚Äì416. ACM, 2002.[65] A. Roskies, J. Fiez, D. Balota, M. Raichle, and S. Petersen.
Task-Dependent Modulation of Regions in the Left Inferior
Frontal Cortex During Semantic Processing. J. Cognitive
Neuroscience , 13(6):829‚Äì843, 2001.
[66] H. Sackman, W. Erikson, and E. Grant. Exploratory
Experimental Studies Comparing Online and OfÔ¨Çine
Programming Performance. Commun. ACM , 11(1):3‚Äì11,
1968.
[67] E. Sapir. Culture, Language and Personality . University of
California Press, 1949.
[68] B. Sharif and J. Maletic. An Eye Tracking Study on
camelCase and under_score IdentiÔ¨Åer Styles. In Proc. Int‚Äôl
Conf. Program Comprehension (ICPC) , pages 196‚Äì205.
IEEE, 2010.
[69] B. Shneiderman and R. Mayer. Syntactic/Semantic
Interactions in Programmer Behavior: A Model and
Experimental Results. Int‚Äôl J. Parallel Programming ,
8(3):219‚Äì238, 1979.
[70] M. Shooman. The Teaching of Software Engineering. In
Proc. Technical Symposium on Computer Science Education
(SIGCSE) , pages 66‚Äì71. ACM, 1983.
[71] J. Siegmund, A. Brechmann, S. Apel, C. K√§stner, J. Liebig,
T. Leich, and G. Saake. Toward Measuring Program
Comprehension with Functional Magnetic Resonance
Imaging. In Proc. Int‚Äôl Symposium Foundations of Software
Engineering‚ÄìNew Ideas Track (FSE-NIER) , pages
24:1‚Äì24:4. ACM, 2012.
[72] P. Skosnik, F. Mirza, D. Gitelman, T. Parrish, M. Mesulam,
and P. Reber. Neural Correlates of ArtiÔ¨Åcial Grammar
Learning. NeuroImage , 17(3):1306‚Äì1314, 2008.
[73] E. Smith, J. Jonides, and R. Koeppe. Dissociating Verbal and
Spatial Working Memory Using PET. Cerebral Cortex ,
6(1):11‚Äì20, 1991.
[74] E. Soloway and K. Ehrlich. Empirical Studies of
Programming Knowledge. IEEE Trans. Softw. Eng. ,
10(5):595‚Äì609, 1984.
[75] D. Strayer. Driven to Distraction: Dual-Task Studies of
Simulated Driving and Conversing on a Cellular Telephonen.
Psychological Science , 12(6):462‚Äì466, 2001.
[76] J. Talairach and P. Tournoux. Co-Planar Stereotaxic Atlas of
the Human Brain . Thieme, 1988.
[77] P. Tarr, H. Ossher, W. Harrison, and S. Sutton, Jr. N Degrees
of Separation: Multi-Dimensional Separation of Concerns.
InProc. Int‚Äôl Conf. Software Engineering (ICSE) , pages
107‚Äì119. ACM, 1999.
[78] A. Turken and N. Dronkers. The Neural Architecture of the
Language Comprehension Network: Converging Evidence
from Lesion and Connectivity Analyses. Frontiers in Systems
Neuroscience , 5(1), 2011.
[79] R. Vandenberghe, J. Duncan, P. Dupont, R. Ward, J.-B.
Poline, G. Bormans, J. Michiels, L. Mortelmans, and
G. Orban. Attention to One or Two Features in Left or Right
Visual Field: A Positron Emission Tomography Study. J.
Neuroscience , 17(10):3739‚Äì3750, 1997.
[80] B. Whorf. Language, Thought, and Reality . Chapman and
Hall, 1956.
[81] J. Wing. Computational Thinking. Commun. ACM ,
49(3):33‚Äì35, 2006.
[82] S. Wootton and T. Horne. Train Your Brain . Teach Yourself,
2010.389