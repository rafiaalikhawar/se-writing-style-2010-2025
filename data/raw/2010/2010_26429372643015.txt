Assigning Time Budgets to Component Functions in the
Design of Time-Critical Automotive Systems
Ernest Wozniak
CEA LIST, France and McGill
University, Canada
ernest.wozniak@cea.frMarco Di Natale
Scuola Superiore Santâ€™Anna,
Italy
marco@sssup.itHaibo Zeng
McGill University, Canada
haibo.zeng@mcgill.ca
Chokri Mraidha
CEA LIST, France
chokri.mraidha@cea.frSara Tucci-Piergiovanni
CEA LIST, France
sara.tucci@cea.frSÃ©bastien GÃ©rard
CEA LIST, France
sebastien.gerard@cea.fr
ABSTRACT
The adoption of AUTOSAR and Model Driven Engineering
(MDE) for the design of automotive software architectures
allows an early analysis of system properties and the auto-
matic synthesis of architecture and software implementation.
To select and congure the architecture with respect to tim-
ing constraints, knowledge about the worst case execution
times (WCET) of functions is required. An accurate eval-
uation of the WCET is only possible when reusing legacy
functionality or very late in the development and procure-
ment process. To drive the integration of SW components
belonging to systems with timing constraints, automotive
methodologies propose to assign WCET budgets to func-
tions. This paper presents two solutions to assign budgets,
while considering at the same time the problem of SW/HW
synthesis. The rst solution is a one-step algorithm. The
second is an iterative improvement procedure with a staged
approach that scales better to very large size systems. Both
methods are evaluated on industrial systems to study their
eectiveness and scalability.
Keywords
design; design space exploration; real-time; end-to-end dead-
lines; time budgeting; AUTOSAR; optimization; genetic al-
gorithm
1. INTRODUCTION
Vehicles are today very complex high-technology products
with an increasing number of software features. This evo-
lution is not matched by quality and speed improvements
in the software development processes. The AUTOSAR [1]
automotive standard has been dened to improve the de-
sign and integration of automotive SW components. The
AUTOSAR methodology [3] makes use of model-driven en-
gineering principles (MDE), i.e. the use of models as basic
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full cita-
tion on the ï¬rst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciï¬c permission
and/or a fee. Request permissions from permissions@acm.org.
ASEâ€™14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2643015.building blocks for software and hardware description in a
top-down process, in which the top-most level consists of
the specication of a platform-independent software archi-
tecture (application components and their connections) and
a separate hardware model (dening the network of nodes
and buses). In a renement process, the functional com-
ponents are mapped to the hardware nodes, generating the
node conguration and the denition of the OS tasks. The
result of the mapping is the application deployment, i.e., a
set of communicating tasks running on the nodes and com-
municating through messages sent on buses.
The AUTOSAR methodology is dened according to the
typical automotive supply chain process. The integrator
(car maker) has control over the functional architecture de-
sign at the system-level, and selects the execution platform,
including the (distributed) HW architecture and the basic
SW (RTOS, middleware, drivers). The integrator denes
the SW components that are needed for the implementa-
tion of the functionality and sends the AUTOSAR speci-
cations of their interfaces and behaviors to the suppliers.
Starting from version 4.0, timing constraints become part
of the AUTOSAR standard [2]. This requires the integra-
tor to validate the correctness of the architecture solution
with respect to time constraints (end-to-end deadlines) and
dene the (partitioned) timing constraints that apply to the
component specications for the suppliers .
The validation of timing properties during the develop-
ment is a continuous process. Since renements are top-
down, deadlines can only be validated under assumptions
abstracting the lower-level details, such as the worst-case ex-
ecution times (WCETs) of functions. In AUTOSAR, func-
tions are called runnables and represent the atomic exe-
cutable entities dening the internal behavior of compo-
nents. An application deployment is valid if and only if
the set of tasks that execute the runnables is schedulable.
Unless the implementation of runnables is re-used from pre-
vious systems, precise knowledge of WCETs of runnables is
not available before code implementation in the design pro-
cess. To dene a system architecture supporting functions
with time constraints and provide the specication of its
components to the suppliers, automotive developers and do-
main experts propose a time budgeting activity as part
of the development methodology. The system integrator
species and assigns time budgets. These time budgets
areconstraints on worst-case execution time that must be
respected by the suppliers delivering the component imple-
235
mentation [4]. If all the delivered components fulll their
local constraints, the end-to-end deadlines are satised. In
the meantime, based on the budget assumptions , the sys-
tem integrator can synthesize and optimize an architecture
conguration.
1.1 Related Work
The problem of dening time budgets for components and
runnables is similar to the issue of end-to-end deadline par-
titioning. Several research works have investigated the op-
tion of partitioning the end-to-end deadline into time win-
dows or intermediate deadlines, upon the assumption that
the interaction model allows the composition of the local
response times to compute end-to-end response times. A
graph-based algorithm for deadline partitioning to maximize
the minimum slack is presented in [10], and an approach for
periodic processes in [14]. More recently, deadline partition-
ing schemes for transaction chains scheduled under EDF or
xed priority can be found in [24, 16, 17]. Other eorts have
been specically tailored to automotive architectures. The
TIMMO-2-USE project [25] discusses the need for time bud-
geting in the context of the process stages dedicated to the
renement of the system architecture. The project deliver-
ables discuss a set of guidelines for budgeting the worst-case
response times (WCRTs), based on the designer experience
and do not provide a specic algorithm. Scheickl et al. [23]
considers a similar process in which the denition of the
WCRT budgets is based on the experience of the designer.
Similarly, WCRTs are budgeted in [13], with a discussion
on how dierent activation patterns (event- or time-driven)
inuence the specication of time budgets. Nevertheless, as
in the previous two works, the approach relies on the expe-
rience of the designer.
The methodology of partitioning deadlines on response
times is more suitable to the concept of federated automo-
tive architectures [9], when suppliers provide hardware units
or ECUs with operating systems and tasks, or at the very
least when the responsibility of the task design is delegated
to the suppliers. In the new concept of integrated archi-
tecture , enabled by AUTOSAR, the denition of the tasks
and the design of the hardware architecture pertains to the
integrator. Therefore, budgeting should be performed at the
level of the WCET of the runnables.
The concept of time budgeting in the integration of au-
tomotive systems is among the research topics of the ALL
TIMES project [4]. The approach proposed in the project
deliverables takes as an input an already deployed archi-
tecture, i.e. the software components are already assigned
to tasks and mapped onto the hardware platform. Since
WCETs are not known, the deployment choices (assumed
as predetermined and not subject to optimization) could
very well be suboptimal and aect the nal result (the as-
signed budgets). In [12] the budgeting problem is formulated
and solved by applying Parametric Linear Temporal Logic
(PLTL). A method is presented to automatically decompose
end-to-end deadlines into a set of time budgets. The authors
automatically compute a set of linear constraints for which
they nally nd a valuation (using a solver) that guarantees
all deadlines and maximizes the values of the time budgets.
The proposed solution also integrates the consideration of
non-functional properties related to the ECU utilization [11].
As in all previous works, the authors assume that the de-
ployment, i.e. the integration of the software architecturewith the hardware platform and the design of the task, is al-
ready known. In addition, the deployment choices could not
have been done in a qualitative way as WCETs for certain
runnables were missing.
1.2 Our Contributions
In this paper we incorporate the problem of budgeting
worst-case execution times in the design optimization. All
the other works budget the worst case response time which
does not t well to the idea of the integrated architecture
as supported by the AUTOSAR. Dierent from previous
work [4] on WCET budgeting, we assume that the function
deployment is not known in advance. Accordingly our ob-
jective is to jointly nd the deployment of functions and the
optimal assignment of time budgets given a functional (AU-
TOSAR) model with end-to-end timing constraints and an
execution (hardware+OS) platform. Since time budgeting
and deployment are both NP-hard problems, our solutions
consists of two heuristic approaches, based on evolutionary
algorithms. The rst provides a holistic one-step solution
to the problem, whereas the second divides it into two sub-
problems solved one after the other. On the other hand,
as shown in the experiments, due to the scalability issues,
it is impractical to employ the time budgeting algorithm as
specied in [4] with our algorithm exploring the deployment.
The paper is organized as follows: section 2 formalizes the
model and problem considered by the approach; section 3 de-
tails the proposed technique for time budgeting and section
4 presents its improvement in a form of staged approach; sec-
tion 5 gives experimental evaluation results; nally, section
6 sketches some future work and concludes the paper.
2. FORMALISM
This section starts by introducing basic denitions and
assumptions on the system model. Then, the time budgeting
problem is formalized together with constraints on timing
and deployment.
2.1 System Model
The input system model matches the modeling abstrac-
tions in AUTOSAR. The AUTOSAR functional model
consists of a set of components. Each component has a set
ofrunnables dening its functional behavior and cooperating
by exchanging data and synchronization signals over ports.
Of the possible interaction models allowed by AUTOSAR,
we focus on a model of synchronous transactions , in which
runnables exchange activation signals in a linear sequence.
In addition, even if they are extremely important in the sup-
ply process and as an abstraction mechanism, in the context
of our analysis, components are only containers of runnables
and are therefore omitted.
We assume the runnable interaction model is represented
as a system-level graph. Ge=fVe;Eeg, in which Ve=
fr1;r2;:::;rngis the set of vertices representing the runnables
andEe=fs1;s2;:::;smgis the set of edges or links be-
tween them representing data signals. The length of a data
signalsiis denoted as lsi(in number of bits). The set
of transactions is =f 1; 2;:::; lg. Each transaction is
an ordered interleaving sequence of runnables and signals
 i= [ri1;si1;ri2;si2;:::;sik 1;rik] (e.g. from the runnable
reading sensor data to the runnable communicating with
the actuator). src( i) =ri1is the transaction source, and
snk( i) =rikits sink. The function  ( ri) returns the trans-
236action to which ribelongs. We assume that transactions are
linear and the activation pattern is event-triggered, i.e. each
transaction is triggered by a periodic event of period P i.
This event is then propagated by the runnables, starting
from thesrc( i) through their communication links (each
connection carries an activation event together with the as-
sociated data signal). The response time of the transaction
 iisR iand its deadline D i. Figure 1 shows an example
model (based on the cruise control case study from [5]).
30 ms
Limp home DiagnosisSWC5 SWC6
2Î“DÎ“2Î“Input
acquisitionApplicationSWC1 SWC2 SWC3 SWC4
function
Controller11Î“D
Speed
InputconditionBasic20 ms
interpretationsetpoint
Figure 1: An example of linear transactions for a Cruise
Control [5]
Theexecution platform is represented by an undirected
graphGh=fVh;Ehg. Nodes are computing resources or
(ECUs)Vh=fe1;e2;:::;esgand edges represent the com-
munication links (buses) between them Eh=fb1;b2;:::;bpg.
The function E(bi) returns the set of ECUs connected to bi.
Runnables are partitioned in two sets. RW is the set of
legacy runnables that are simply reused, and for which an
estimate of the WCETs on the available ECUs is known.
RBis the set of runnables under development, for which a
budget assignment must be provided.
The WCET of a generic runnable ribelonging to RW is
represented as a vector ~Cri= (Cri;1;Cri;2;:::;Cri;n), where
Cri;kis the WCET of riwhen executed on ek. The (ex-
ecution) time budget of a runnable ribelonging to RBis
denoted as tbri. We also denote the set of all time budgets
asTB=ftbri;tbrj;:::;tbrkg.
In the deployed architecture, represented with 	, the
code of each runnable entity executes in a context of an
OS task.T=f1;2;:::;tgis the set of tasks. Similarly,
the signal needs to be transmitted in one of the messages
M=fm1;m2;:::;mug, if the communication is between
runnables mapped to dierent ECUs; otherwise, it is consid-
ered as local communication. The function (ri) returns the
task on which runnable riis partitioned and m(si) the mes-
sage transmitting the signal si. The function e(ri) returns
the ECU on which riis allocated whereas b(si) is the bus
through which siis sent. Tasks and messages are assumed
to be scheduled according to a xed-priority mechanism or
transmitted in the order of their priority, respectively. The
automotive standards, e.g. AUTOSAR OS and Controller
Area Network (CAN), are signicant examples of such poli-
cies. The priority of a task i(messagemi) is denoted as i.
Considering the possible bit-stung of the CAN protocol,
the worst-case transmission time (WCTT) of a message mi
is calculated as [8]
Cmi= (g+ 8lmi+ 13 +g+ 8lmi 1
4
)bit (1)
wheregis the number of protocol bits subject to bit-stung
(g= 34 for standard format with 11-bit identiers, or g= 54for extended format with 29-bit identiers), lmiis the data
length of the message ( bytes unit), andbitis the transmis-
sion time for a single bit. The data length of message mi
is the least integer number of bytes between 0 and 8 that is
greater than the sum of the data signals packed in mi,
lmi=&P
sj:m(sj)=milsi
8'
(2)
Figure 2 shows one possible partitioning of runnables into
tasks and assignment of tasks onto ECUs for the functional
model of Figure 1. The index of a task represents its prior-
ity (lower value means higher priority). In the gure, some
signals exchanged between runnables are mapped onto mes-
sages (e.g. the one between "Speed setpoint" and "Applica-
tion condition").
CAN bus3
4
5Input20 ms
interpretation
30 msBody controller ECU
DiagnosisÏ„Engine management ECU
Limp homeÏ„Basic
function conditionApplication
ControllerÏ„Ï„
Speed
setpointInput
acquisition
Ï„1
2
Figure 2: Example of a deployment conguration for a
Cruise Control
2.2 Problem Formulation
The problem tackled in this work consists of four sub-
problems. (1)Placement of runnables on execution nodes
and signals on buses (assigning values to e(ri) andb(si)).
(2)Partitioning , i.e. the denition of the operating sys-
tem tasks (set T) and messages (set M) and the mapping
function that assigns runnables and signals to them. (3)
Scheduling , i.e. assignment of priorities to tasks and mes-
sages. (4)Time budgeting , i.e. the denition of the time
budget values, i.e. nding tbrifor eachri2RB.
These four problems have signicant cross-dependencies.
Ideally, they should be solved as an integral problem, but
this could be very challenging in terms of the computational
eort that is required. Alternatively, the problem can be
solved in stages, with the possibility of early choices re-
stricting the set of available decisions for later stages. In
our work, we try to lessen this problem by wrapping the
staged solution in an iteration loop, in which the rst stage
is performed several times trying to improve on the results
of the previous cycle.
2.3 Deployment Constraints
In order for the placement, partitioning and scheduling
to be correct several constraints need to be respected to
guarantee the functional correctness of the deployed archi-
tecture. We list them according to their purpose without a
formal description (which is straightforward for all of them).
Placement Constraints: (1) resources utilization - den-
ing a maximum capacity utilization for all execution nodes
and buses; (2) each runnable/signal can be placed only on
one ECU/bus; (3) xed placement - the placement of se-
lected runnables is constrained to a subset of all ECUs (e.g.
a runnable responsible for collecting sensor data can be placed
only on ECUs linked to that sensor); (4) software compo-
237nents constraint - all the runnables of the same atomic soft-
ware component need to be placed on the same ECU; (5)
each global signal (i.e. communicated between two runnables
mapped on dierent ECUs) must be transmitted over a bus
connecting the ECUs where its sender and receiver runnables/
tasks are allocated.
Partitioning Constraints: (1) harmonic rate - two runnables/
signals with non-harmonic periods ( PriPrj)Primod
Prj6= 0) cannot be partitioned in the same task/message.
The period of a runnable Prior signalPsiequals the pe-
riod of a transition to which runnable/signal belongs. (2)
functional partitioning - each runnable must be partitioned
exactly in one task. Likewise, each global signal must be
partitioned in one message.
Scheduling Constraints: (1) local order - tasks/messages
allocated on the same ECU/bus must be assigned with unique
priorities; (2) runnables order - the priorities assigned to
tasks must be consistent with the order of execution of the
runnables partitioned on them. That is, if runnables riand
rjare on the same ECU and runnable riprecedes runnable
rjthenrishould be partitioned in a task with priority higher
than that of the task executing rj.
2.4 Timing Constraints
All transactions must complete within their end-to-end
deadlines
8 lR lD l (3)
The verication of this constraint requires the evaluation
of the end-to-end response time R lof each transaction   l,
which equals the WCRT of its sink runnable ri, i.e.R l=
Rriandri=snk( l). We use the response time analysis
with jitter propagation given in [26] and reformulate it to
consider runnables (see equations (4)-(5)), where Jriis the
release jitter of the runnable, W(q)
riis the completion time of
theqthinstance of runnable ri. Instance of a runnable riis
a distinct execution of riafter activation in the busy period.
The function hp(ri) returns the indexes of all the runnables
allocated on the same ECU with a priority higher than that
ofri. The completion time is computed for q= 1;2;::: until
the busy period ends, that is, an instance completes at or
before the activation of the next instance.
W(q)
ri=q(Cri;k+X
rj:(ri)=(rj)Crj;k) +X
rj2hp(r i)&
W(q)
ri+Jri
Prj'
Crj;k
(4)
R l=Rri= max
q=1;2;:::[Wq
ri (q 1)Pri+Jri] (5)
The jitter of runnable riinherits the response time of the
signalsi 1sent by its direct predecessor in the transaction.
Jri=Rsi 1 (6)
If a signalskis local, its response time is the same as its
sender runnable rk 1.
Rsk=Rrk 1 (7)
Otherwise, the WCRT of skis computed as the response
time of the message mp=m(sk) carrying this signal.
Rsk=Rmp (8)
To calculate the response time of message mp, a set of
formulae similar to (4)-(5) is used, except for 1) an addi-
tional term Bmpthat represents the blocking time causedby the impossibility of preempting lower priority messages
(as in a CAN bus); 2) a reduction in the queuing delay
Wmpsincempcannot be preempted. We use the approxi-
mated sucient formulation provided in [8], in which Bmpis
the longest transmission time (largest WCTT) of any mes-
sage that shares the same communication bus (or simply the
longest 64-bit message in the CAN bus). W(q)
mpis the start
time of the q-th instance of message mp.
W(q)
mp=Bmp+ (q 1)Cmp+X
mj2hp(m p)&
W(q)
mp+Jmp
Pmj'
Cmj
(9)
Rmp= max
q=1;2;:::[Wq
mp (q 1)Pmp+Jmp+Cmp] (10)
The queuing jitter of mpis the largest among all the jitters
of signals packed in mp. The jitter Jskof a signalskequals
the response time of a runnable rk 1that sends the signal
sk, i.e.Jsk=Rrk 1.
Jmp= max
sk:m(sk)=mpJsk (11)
2.5 Optimization Objective
We consider an optimization metric expressing the relax-
ation of time budgets within the end-to-end deadline con-
straints. The function ftb(TB) in (12) is dened as the
minimum time budget value for all runnables in RBnor-
malized with respect to the target range ( tbm
ri,tbM
ri). The
optimization objective is to maximize ftb(TB), or equiva-
lently, to maximize the minimum normalized time budget
among runnables in RB. To represent the specic valuation
of time budgets from the set TBwe use the notation TBA .
Henceftb(TBA ) refers to a specic, computed value.
ftb(TB) = min
rk2RBtbrk tbm
rk
tbMrk tbmrk(12)
The designer has the option to provide a minimum value
fortbriastbm
ri(its intuitive meaning is a preliminary evalu-
ation of the minimum required execution time for the func-
tionality, based on the experience of the designer). If it is not
specied, then tbm
ri= 0.tbM
riis the maximum time budget
for the runnable ri. If not set by the designer, it is assigned
with the period of the transaction to which ribelongs.
Providing for a time budget that allows for additional
slack time mitigates the design risks associated with uncer-
tainties about the execution time of the runnable implemen-
tation delivered by the supplier. The authors of [22] propose
a method to derive a certainty of obtaining a feasible sys-
tem conguration under the assumption of uncertain design
parameters such as WCET of new runnables. They dene
an uncertainty function that enables the system integrator
to estimate the risk of obtaining an infeasible design and
consider it in the denition of the contract with a supplier.
Indeed, relaxation of budget values lies in the interest of
the [4]. [4] employs the binary sensitivity analysis [15] which
searches for an upper bound of the runnable execution time
so that the system remains schedulable. The proposed al-
gorithm is designed to consider the relaxation of only one
runnable, which is why the metric of interest does not need
to be normalized. In our case, relaxation should aect all the
runnables in RB. [21] accounts for more than one runnable,
by simply returning a schedulability region of all the possi-
ble combinations of the time budgets for runnables in RB.
238Our proposed metric in (12) instead targets at only the best
combination, i.e. one that equally distributes the budget
constraints among dierent suppliers delivering implemen-
tation of runnables from RB.
3. A ONE-STEP SOLUTION
To solve the time budgeting problem dened in the previ-
ous section, we rst consider a one-step approach and a solu-
tion based on a Genetic Algorithm (GA) and MILP (Mixed
Integer Linear Programming). A genetic algorithm from
[18] was used and slightly modied to nd solutions for the
deployment problem, which includes placement, partition-
ing, and scheduling (the rst three sub-problems dened in
section 2.2). The GA implementation for this particular
problem requires the specication of the encoding and evo-
lution operators along with the tness function, and stop
condition (sections 3.1{3.4).
For a given deployment solution, the time budgets of runnables
(the fourth sub-problem in section 2.2) are assigned using
Algorithm 1, which has as inputs the maximum value of
runnable time budgets. The maximum value of time bud-
gets is formulated and computed by a MILP framework.
These algorithms are described in sections 3.5 and 3.6.
3.1 Encoding
Each solution to the problem is encoded as a chromosome
chj, representing a specic deployment conguration. This
work uses the value encoding, in which each gene gi(subset
of bits) inchjcontains a specic value. A gene relates to
either a runnable entity or a data signal. The sequencing of
genes forming a chromosome is random but the same for all
chromosomes. For a runnable gene, gi=chj(rk) stores the
valueVrk(gi) representing the allocation and partitioning of
rk, that is, the index of the ECU on which it is allocated and
the index of the task (also representing its priority) in which
it is partitioned. NRmaxdenotes the maximum number of
runnables that can be hosted by any ECU without violating
the utilization constraints (WCETs or tbm
riand periods of
runnables are used for computing NRmax). If runnable ri
is allocated to ECU emand partitioned into the task l,
its encoding Vrk(gi) is computed according to the following
Equation (13).
Vrk(gi) = (m 1)NRmax+ (l 1) (13)
For a data signal, Vsk(gi) depends on whether it is a global
or local data signal. The gene for a global signal holds in-
formation about the bus and the message in which it is par-
titioned. For a local signal skthe value will not have any
meaning. The gene value for a data signal is computed in a
similar way (14). NSmaxis the maximum number of signals
that can be transmitted over any BUS without violating the
utilization constraints (WCTTs and periods of signals are
used to compute NSmax).
Vsk(gi) = (m 1)NSmax+ (l 1) (14)
3.2 Evolution
The evolution of a population consists in the generation of
new chromosomes (new solutions) using the crossover and
mutation mechanisms, followed by the selection of chromo-
somes with the highest tness values. The crossover opera-
tor combines information from two parent chromosomes to
generate new ones. We use the OX3 crossover operator [7]with a tournament selector [19] (with size equal to 5). The
tournament selector with size 5 will rst create two sets with
5 randomly chosen chromosomes. The most t chromosome
from each set will be taken and these two chromosomes will
be used as parents for the crossover. Then the OX3 opera-
tor will randomly select the "crossover points", i.e. indexes
of genes that will constitute the boundaries of the crossover
operation. The values between these points are copied from
the rst/second parent to the second/rst child in the same
absolute position. The remaining values are copied from
the rst/second parent to the rst/second child. The mu-
tation operator randomly chooses a gene in a chromosome
to change its value to a new value randomly selected among
those that do not violate the constraints of a correct deploy-
ment (see section 2.3).
3.3 Fitness Function
The tness function denes how much the solution op-
timizes the time budgeting optimization criterion. Chro-
mosomes are ranked according to the result of the metric
function. The higher the value, the higher the probabil-
ity that the chromosome will be chosen as a parent for a
crossover. The tness function requires as an input the de-
ployment specication, i.e. 	 (encoded in the chromosome)
and the time budgets assignment TBA . The time budgets
assignment is obtained by using Algorithm 1.
3.4 Stop Condition
The stop condition determines when the GA will termi-
nate. In our case, the algorithm stops when niterations of
the GA internal loop deliver a maximum t result with the
same tness value (the best solution does not improve in n
rounds).
3.5 Time Budgeting Algorithm
Within the GA optimization cycle, Algorithm 1 is exe-
cuted for each chromosome to compute the corresponding
optimum set of time budgets based on which value for the
metric function ftb(TB) can be calculated.
The time budgeting algorithm has four inputs: 	, RB,
andMRB.is the maximum error on the computed budgets
that controls the terminating condition (line 15). The lower
is the value of , the more accurate are the time budgets,
and the larger is the runtime of the algorithm. MRBis a set
of upper bounds on the runnable budgets computed for a
specic deployment 	, where MRB(i) is the maximum value
forri. The values in MRBare computed before running
Algorithm 1 (see 3.6).
Algorithm 1 tries to relax the time budgets for all the
runnables in RBaccording to the metric (12) using a binary
search algorithm (as in the sensitivity analysis test in [15]).
The upper bound values are tried rst, giving the maximum
possible value of ftb(TB) (lines 6-8). If the corresponding
conguration is schedulable (function isSchedulable() simply
checks the condition from eq. (3)), it is returned as the
optimum value (line 9). If not, then the algorithm assigns
to eachrjinRBa budget value that is the medium value
between the minimum tbm
rjand the upper bound MRB(i)
(lines 11-13).
From this point on, Algorithm 1 continues by iteratively
reducing the range of the time budgets, dened as [ Ltbrj;Utbrj]
for runnable rj. The algorithm works as a binary search. In
each iteration, if the current budget values, at the midpoint
239Algorithm 1 Time Budgeting Algorithm
Require: 	,RB,,MRB
1:for allrj2RBdo
2:Utbrj=MRB(j)
3:Ltbrj=tbm
rj
4:end for
5:ifisSchedulable(	 ;MRB)then
6:for allrj2RBdo
7:TBA:set (rj;MRB(j))
8:end for
9:returnTBA
10:else
11: for allrj2RBdo
12:tbrj= (Utbrj Ltbrj)=2
13: end for
14:end if
15:while9ri2RB Utb rj Ltbrjdo
16: for allrj2RBdo
17:TBA:set (rj;tbrj)
18: end for
19: ifisSchedulable(	;TBA )then
20: forrj2RBdoLtbrj=tbrj
21: else
22: forrj2RBdoUtbrj=tbrj
23: end if
24:tbrj=Utbrj (Utbrj Ltbrj)=2
25:end while
26:returnTBA
between the the upper and lower bounds result in a schedu-
lable solution, the upper bound Utbrjremains the same, and
the lower bound Ltbrjis updated to be midpoint (line 20),
and the range is reduced to be half of the size. If the current
settings result in an unschedulable solution, it means that
the time budget value is too large, and the next iteration
will search wiithin the lower half of the range (line 22).
In [15], budget values are computed for each runnable sep-
arately, in a set of recurrent calls, exploring all the possible
options for the relaxation of each runnable budget, at the
price of higher complexity. However, for the metric (12)
this is not required. Given any optimal solution according
to (12), there exists another solution with the same value
of (12) that is computed by our bisection algorithm, per-
forming an equal relaxation of all time budgets (i.e. propor-
tionally totbm
riandtbM
ri). Of course, the solution computed
by Algorithm 1 can have smaller budget values for those
runnables that are not aecting the value of (12).
3.6 Calculating MRBusing MILP
Finally, the upper bounds MRBthat are required to re-
duce the initial interval of possible budget values in Algo-
rithm 1, are computed using an MILP (Mixed Integer Linear
Programming) formulation. The values in MRBare (op-
timistic) upper bounds and do not guarantee the system
schedulability as the constraints used for their computation
are a linear approximation representing only a necessary
schedulability condition that does not consider interference.
However, they are useful in constraining the search space for
the bisection algorithm.
In the MILP formulation, the problem is represented with
parameters, decision variables, and constraints over the pa-
rameters and decision variables. Moreover, an objective
function is dened to characterize the optimal solution.
Variables: the only set of variables are MRB(ri) where
ri2RB.
Objective function: the objective is to maximize the met-
ric function in Equation (12), with MRB(ri) in place of tbri.Constraints: three types of constraints are considered:
Utilization constraints - a utilization bound applies to
each ECU ( uei). Unless specied, the default limit
value is 1.
8ei2E;X
rj2RB^e(rj)=eiMRB(rj)
P (rj)uei X
rj2RW^e(rj)=eiCrj;ei
P (rj)
(15)
Computation time constraints - are a linear under-
approximation of the deadline constraints, ensuring
that the sum of the execution times and budgets on
each chain is lower than the deadline. These con-
straints do not consider interference and therefore do
not guarantee end-to-end deadlines.
8 i2;X
rj2RB^ (rj)= iMRB(rj)D i X
rj2RW^ (rj)= iCrj;ei
(16)
Minimum and maximum value constraints
8ri2RBtbm
riMRB(ri)tbM
ri(17)
4. STAGED APPROACH
The one-step holistic approach is simple and eective but
does not scale to very large-size problems. Hence, an al-
ternate solution was developed by dividing the four sub-
problems in two stages. The rst stage solves the rst three
sub-problems on deployment (placement, partitioning and
scheduling). The second stage tries to optimize the time
budgeting only. The two stages are computed sequentially
inside a loop until there is no further improvement as shown
in Figure 3. The computation time savings derive from the
execution of Algorithm 1 once for each iteration instead of
once for each chromosome.
The staged algorithm implements an iterative improve-
ment strategy that is in essence a local search. Starting
from an initial solution, the current best solution is ten-
tatively improved in the iterations of an inner cycle that
includes the two optimization stages. If at any iteration,
the two stages fail to produce a better result, the algorithm
terminates and returns the best solution found until that
point. The algorithm starts with the initialization of the
variables storing the population of chromosomes ( ), and
the current best metric values (the rst two blocks from
Figure 3). The second stage (second block in the gure)
initializes the values of time budgets with their minimum
values, i.e.8ri2RB;tbri=tbm
ri(section 5.4). The rationale
for this choice is that we do not want the algorithm (a local
search) to end prematurely and we try to ease schedulabil-
ity (and provide for maximum allocation freedom) as much
as possible in the rst step. In the experiments section,
we discuss the impact of dierent values for the initial time
budgets.
Next, the deployment optimization is performed consid-
ering the current values of the time budgets (the rst time
the loop is entered these are the initial budgets). During the
deployment optimization stage, budgets are xed, the met-
ric function ftb(TB) has a constant value, and cannot be
used to evaluate the quality and drive the selection of the
deployment solutions. Hence, the tness function considered
in this step is based on the end-to-end response times. The
240functionfslack(	;TB ), dened in Equation (18), expresses
the minimum slack time (the dierence between the dead-
line and response time) of each transaction. Now the goal is
to maximize the minimum slack.
fslack(	;TB ) = min
 i2[D i R i] (18)
Maximizing the minimum slack means maximizing the
minimum distance between the response time and deadline
of any transaction, which is an indication of an opportu-
nity for having larger budgets and hence a better deploy-
ment. The function fslack(	;TB ) is computed based on the
schedulability analysis formulas for computing the response
times of runnables and messages (see section 2.4).
At each iteration of the main loop, a new deployment
solution is computed and then evaluated. If the value of
fslack(	;TB ) does not improve on the current best solu-
tion, i.e., the minimum slack is lower, the loop terminates
and the best solution computed up to this point is returned.
Otherwise, Algorithm 1 is executed to compute a new op-
timum set of time budgets (for the current deployment).
Then, the tness value ftb(TB) is computed for the new set
of time budgets and the new tness value is compared with
the current best. If the new deployment/budgets improve on
the current best solution, they are considered for the next
iteration, and the new budget drive the next deployment
optimization step. Otherwise, the algorithm terminates and
returns the best current deployment and time budget solu-
tion. The procedure is summarized in Figure 3.
Besides the dierent optimization metric used during the
deployment, another signicant dierence with the one-step
deployment algorithm described in section 3 is the stop con-
dition. The loop terminates not only if no improvement is
found after ninternal GA iterations, but also when the t-
ness of the best chromosome from the new population is not
better (lower or equal) than the current best tness value
(currentSlackFitness globalSlackFitness ). Finally, the
setdenes the initial population for the GA algorithm.
At each iteration round, preserves the population selected
in the previous run of the deployment algorithm. When the
deployment is run for the rst time and the set is empty,
the deployment procedure initializes with a random initial
set of chromosomes which is consistent with the constraints
that apply to the system conguration.
5. EXPERIMENTAL EV ALUATION
To evaluate the algorithms, a series of experiments have
been performed on a collection of automotive case studies.
First, a set of case studies is used to compare the one-step
approach with the staged approach in terms of the quality
of the results and the required execution time. Next, we
discuss the robustness of the staged approach by evaluating
the inuence on the nal results when replacing the met-
ric in Equation (18) with a dierent function. Then, we
present experiments to see if and by how much dierent ini-
tial assignments of time budget values aect the nal result.
Finally we compare with the work which is closest to ours,
done in the All-Times project [4]. All tests were run on a
machine with 8GB of memory and a single processor run-
ning at 2.4GHz. Also, all the tests assume the maximum
error factor = 0:5 and the stop condition for the GA (re-
gardless of initial population size) is that n= 30 consecutive
iterations compute the same value.
TBA = Initialize Time B udgets
( , ) = Perform Deployment (, currentSlackFitness)
currentSlackFitness = f  ( , TBA)
currentSlackFitness 
globalSlackFitness 
M = Calculate M wi th MILP
TBA = TimeBudgetingA lgorithm
currentTBFitness = f (T BA)
globalSlackFitness = f ( , TBA)globalTBFitness = 0
currentTBFitness = 0
globalSlackFitness = 0
currentSlackFitness = 0
=
>slack
NO
slacktbYES
globalTBFitness = curr entTBFitness
Update , TBAcurrentTBFitness 
globalTBFitness 
YESNO
return , TBARB R Bmain loopÎ»Î»Î¨
Î¨ Î»
Î¨
Î¨
Î¨Î¨â‰¥Figure 3: Iterative improvement loop for the staged ap-
proach
5.1 An Automotive Case Study
We rst apply our technique to an automotive case study
constructed by merging two subsystems consisting of a CCS
(Cruise Control System) [5] and ABS (Anti-lock Braking
System) [20]. Figure 4 shows the input functional architec-
ture together with the hardware topology. The functional
model contains twelve runnables in four transactions with
their deadlines and trigger periods. For ve runnables, i.e.,
Input acquisition, Input interpretation, Basic function, Di-
agnosis 1 and Diagnosis 2 , the WCET information is not
available and time budgets must be assigned (they belong
to the setRB). The other seven runnables are assumed as
reused from legacy libraries and belong to the set RW. The
hardware topology contains four ECUs, each connected to
the single CAN bus. The WCETs of the runnables in RW
are shown on Figure 4 and in Table 1. Table 1 also shows
the minimum and maximum budget values for the runnables
inRB.
Table 1: Results for time budgets assignments and initial
constraints
Runnable WCETtbmtbMtbECU
Input acquisition - 0 40 8.7311
Input interpretation - 0 40 8.7311
Basic function - 0 40 8.7311
Diagnosis 1 - 0 10 2.1814
Diagnosis 2 - 0 10 2.1821
Limp home 1.03 - - -14
Speed setpoint 3.5 - - -11
Application condition 3.92 - - -11
Controller 1.4 - - -12
Data processing 10 - - -13
Anti-lock 1 15 - - -22
Anti-lock 2 15 - - -24
24110ms
Limp home DiagnosisSWC5 SWC6
2Î“D = 10Î“2Î“Input
acquisitionApplicationSWC1 SWC2 SWC3 SWC4
function
Controller11Î“D = 40Speed
InputconditionBasic
interpretationsetpoint40ms
Î“D = 60Î“3
Data Processing Anti-lock 1SWC7 SWC8
Î“D = 100Î“
SWC9 SWC104
Diagnosis Anti-lock 2
CAN busECU1 ECU2 ECU3 ECU4C=3.5 C=3.92
C=1.4
C=1.03 C=10 C=151
2C=1560ms
3
100ms
4Figure 4: Input software and hardware architecture of com-
bined CCS and ABS sub-systems
Input
AcquisitionInput
Interpretation
Speed
SetpointApplication
ConditionBasic
Function
Diagnosis 2Controller
Anti-lock 1
Data 
ProcessingDiagnosis 1
Anti-lock 2Limp HomeÏ„1
Ï„2Ï„1
Ï„2
Ï„1Ï„1
Ï„2CAN BusECU1 ECU2
ECU3 ECU4m1
m2 m3
Figure 5: Deployment conguration for CCS and ABS
The execution of the one-step optimization algorithm re-
sults in the deployment conguration shown in Figure 5.
For simplicity, the software components are omitted in the
gure. The index of a task also represents its priority (the
lower the value, the higher the priority). The task assign-
ments and the computed time budget values are displayed
together with the budgets constraints in Table 1.
5.2 One-step vs. Staged Approach
This subsection presents results of the comparison be-
tween the one-step holistic algorithm and the staged iter-
ative approach. We examine and compare the quality of the
solutions obtained with the two approaches, i.e. the nal t-
ness values - the maximized ftb(TB) and the runtimes that
are required by the two algorithms.
For this purpose, the automotive case study has been ex-
tended with lower and higher complexity examples that have
been generated starting from the 50-runnable case study (in-
dex 9 in our list) presented in [6] and extended to lower and
higher sizes as described in [18]. Table 2 shows a summary
of the fteen system congurations by growing complexity.
The table contains in the rst column an index identify-ing the test case, in the second column the total number of
runnables, in the third column the number of runnables for
which budgets must be assigned, and, nally, the number of
ECUs in the hardware architecture. In all these examples,
we assume a single CAN bus connecting all ECUs. The
original automotive case study is in the fourth row, with
twelve runnables (as shown in the second column) and 5 of
them inRB. Finally, as a further assumption, each soft-
ware component has only one runnable entity. This means
that for each runnable, its placement is independent of any
other runnable's placement, as AUTOSAR requires that all
runnables in the same component must be placed to the
same ECU [1].
Table 2: Properties of the testing input architectures
Test nb RunnablesjRBjECUs
1 5 2 2
2 6 2 2
3 10 4 4
4 12 5 4
5 16 6 6
6 20 8 8
7 32 12 9
8 40 14 9
9 50 17 9
10 60 20 9
11 70 25 10
12 80 27 12
13 90 30 16
14 100 35 18
15 200 70 36
5.2.1 Quality evaluation
Figure 6 shows the nal tness value of the best solution
obtained by the one-step approach, compared with the one
of the staged approach. The size of the initial population
of the GA considered for these tests is 10000. The tness
value of the solutions computed by the two approaches for
tests 1 to 6 is exactly the same, and also the same value
was computed for test 10. For tests 7 to 9 and 11 to 13
the staged approach provided results slightly better than
the one-step algorithm (in detail, 0.33%, 0.34%, 3.48% and
0.54%, 0.53%, 0.66% better, respectively). The problem of
interest is too complex to be eciently solved in one step.
Finally, the one-step approach could not compute the nal
solution for case 14 after more than 24 hours of processing
time. During this time, the GA internal loop performed
76 iterations. The best result obtained after this time was
8.75% worse than the nal result computed by the staged
approach (after 5.86 hours). We also tested the staged ap-
proach on a case (test 15) with 200 runnables, 70 runnables
inRBand 36 ECUs. The best result (tness value of 0.13)
was reached after 28.7 hours. The processing time required
by the one-step algorithm prevented a realistic comparison
in this case.
5.2.2 Runtime evaluation
Not only the staged approach manages to get equal or bet-
ter quality solutions than the one-step approach, but com-
putes them in a much shorter time. The graph in Figure 7
shows a comparison of the execution times required by the
24200,10,20,30,40,50,6
1 (5) 2 (6) 3 (10) 4 (12 ) 5 (16) 6 (20) 7 (32) 8 (4 0) 9 (50) 10
(60)11
(70)12
(80)13
(90)14
(100)Fitness value
Test nb (number of runn ables)One-step Staged ApproachFigure 6: Results for One-step and Staged Approach (GA
Initial Population = 10000)
Figure 7: Runtimes of one-step and staged approach (GA
initial population = 10000)
two algorithms for each experimental case. The runtime of
the one-step and staged approaches increases not only with
the problem size but also with the size of the GA initial
population. Augmenting the size of the GA population is
desirable, as in many cases this leads to a better value for
the nal solution. In our experiments, the nal tness value
was mostly independent from the size of the initial popu-
lation if it has more than 1,000 initial chromosomes. The
runtimes in the gures are shown for an initial population of
10,000 chromosomes. As shown by the graphs, the two algo-
rithms have an execution time that still grows exponentially
with the size of the problem. However, the staged approach
can solve problem congurations of a size comparable with
the typical problems of the industry (approximately 6 hours
for 100 runnables).
5.3 Robustness of the Staged Approach
This subsection evaluates the sensitivity of the staged ap-
proach with respect to the metric used in Equation (18) to
select placement solutions. As an alternative to maximizing
the minimum laxity metric in (18), we used a metric func-
tion (19) that minimizes the sum of the latencies of (a subset
of) the transactions (which is another indication of an op-
portunity for assigning larger budgets). Higher value of (19)
indicates better minimization of latencies. Hence our goal
is to maximize fe2e(	;TB ). Nonetheless please note that
Figure 8: Comparison of two dierent metrics for staged
approach
Figure 9: Comparison of nb of iterations of two dierent
metrics for staged approach
ultimately what matters is the result of metric in (12).
fe2e(	;TB ) =jj X
 lR l
D l(19)
As shown in Figure 8, the original metric (18) provides
better optimization results on the tests from 1 to 14, in the
average by 10.8%. The reason for this is intuitive. Metric
(19) may lead to situations, in which for some transactions
the response time is signicantly reduced, whereas for others
it is close to the deadline. This last set of transactions is
a bottleneck for the relaxation of time budget values that
follows next. This is not the case for the metric (18) which
minimizes the response times with respect to the deadlines
and maximizes the minimum value (does not operate on a
sum of values).
Concerning the runtime, there is no signicant dierence
between the two metrics. The slight dierences in runtimes
are mostly caused by the dierence in the number of itera-
tions of the main loop in the staged approach. However, the
number of iterations (see Figure 9) is mostly similar and so
are the runtimes. The only exception is test 11 where the
use of metric (19) resulted in 138 iterations and a runtime
of 7.6 hours, which is 29.75% higher than the case of a slack
metric (18), but the nal result is slightly better.
2435.4 Inï¬‚uence of Initial Time Budgets
We tried additional test cases to conrm the choice of
starting the iterative improvement algorithm with an ini-
tial setting of time budgets equal to the minimum allowed
value for each runnable in RB. As previously stated, since
the algorithm is a local search and terminates when no fur-
ther improvements are possible, a selection of initial values
that prevents schedulability would likely cause a premature
termination. To verify, we tried initial budget assignments
at 1%; 2%;3%;5%;10% and 20% of the range between the
minimum and maximum values [ tbm
rj;tbM
rj]. In all our exper-
iments, there was no sensible dierence in the quality of the
nal result. However, for the highest values of the initial
budgets (a 20% increase over the minimum value), the algo-
rithm ended prematurely for all cases from 7 to 10. In these
cases, the rst deployment step from the iterative algorithm
was not able to nd any feasible solution.
5.5 Comparison with All-Times approach [4]
In this section we compare our approach with the work
on time budgeting coming from the All-Times project [4].
5.5.1 Budgeting Algorithms
We studied the performance of our time budgeting algo-
rithm (algorithm 1) with respect to the algorithm used in
[4]. Authors of [4] claim that during each manual recong-
uration of deployment, they use the sensitivity analysis to
nd the relaxation of time budget values. The sensitivity
analysis they refer to comes from [15]. This analysis is ap-
plicable if there is only one runnable in RB. The extended
version of this algorithm that can budget multiple runnables
is dened in [21]. Ultimately this is the algorithm that we
implemented. We ported it in the one-step and staged ap-
proach for deployment instead of the algorithm 1 to see if
it can be applied in the automated process of budgets and
deployment specication.
Table 3 presents the runtimes (for the properties of the
tests please refer to the Table 2), which clearly shows that
usage of algorithm 1 leads to shorter runtimes in the context
of both one-step and staged approaches. This dierence is
more signicant for the one-step approach because the calls
to the budgeting algorithm occur much more often. In fact,
starting from test nb 3, usage of algorithm from [21] in the
context of the one-step approach was too time consuming,
i.e. after 24 hours the algorithm did not nish executing.
The reason is that sensitivity analysis from [21] was designed
to construct the map of all budget combinations for which
the system remains schedulable (the schedulability region).
Our algorithm is adapted to the metric of interest which al-
lows to select one single conguration of time budgets, which
equally distributes budget constraints among the suppliers
based on the predened values of tbm
riandtbM
ri. For all the
tests for which algorithms terminated, we obtained the same
tness value, which supports the usage of the algorithm 1 in
the automated process of time budgeting and deployment.
5.5.2 Improvements due to deployment
Interleaving of deployment with time budgeting has pos-
itive impact on the relaxation of budget values. The ap-
proach from [4] assumes that the deployment is known a
priori. On the other hand, our techniques (either one-stepTable 3: Runtimes (seconds) of one-step and staged ap-
proach (GA initial population = 10000) when using dierent
budgeting algorithms
Test nbOne-
stepStagedOne-step
with [21]Staged
with [21]
1 68.474 3.874 2088.665 25.416
2 177.383 4.667 2006.573 31.96
3 1014.547 27.442 >86400 699.729
4 598.003 131.609 >86400 1072.178
5 2565.429 429.153 >86400 84132.114
6 2862.052 685.726 >86400 >86400
or staged) interleave the deployment with budgets speci-
cation. This additional design freedom allows to further
improve on time budget values. To show the gain, we rst
x the deployment for tests 1 to 6 using our deployment
technique (the runnables from RBwere assigned WCETs
equal totbm
ri). Then we run the budgeting algorithm from
[4] and obtained the following values for our metric in Equa-
tion (12): 0.31666666, 0.53333336, 0.178125, 0.088630214,
0.0712207, 0.07819336. By further manipulation of deploy-
ment interleaved with budgets assignment, we managed to
get results: 0%, 0%, 77.78%, 146.15%, 200.7%, 174.52%
better for tests 1 to 6 respectively.
6. CONCLUSIONS AND FUTURE WORK
In this paper, we present two algorithms that apply to
an important problem in modern automotive design ows
based on the AUTOSAR modeling paradigm for integrated
architectures. The objective is to consider end-to-end dead-
lines in time-critical functionality distributed over several
components and to dene the assignment of time budgets
to component functions developed by suppliers, while at the
same time optimizing the ECU and task placement and pri-
ority assignment to the tasks.
Because of the intrinsic complexity of the problem, the
proposed algorithms apply randomized optimization (GA)
techniques. Further, to reduce complexity, we compare a
one-step intuitive solution to the algorithm with an iterative
approach. The iterative (two-stage) approach not only com-
putes results faster, but also (and somewhat surprisingly)
with equal or better quality. The runtime of the algorithm
is already compatible with problems of industrial size, but
we plan to further extend it by a careful evaluation of meth-
ods to adaptively choose the size of the initial population
and possibly to reduce the execution time of the inner loop
in the initial stages of the algorithm. We also intend to ex-
tend our approach to account for architectures which are a
mixture of both event-triggered and time-triggered compo-
nents and allow for non-linear transactions.
7. ACKNOWLEDGMENTS
This paper has been developed as a result of a mobility
stay funded by the Erasmus Mundus Programme of the Eu-
ropean Commission under the Transatlantic Partnership for
Excellence in Engineering - TEE Project.
2448. REFERENCES
[1] Autosar 4.1 specications. http://www.autosar.org/ .
[2] Autosar specication of timing extensions.
http://www.autosar.org/download/R4.0/AUTOSAR_
TPS_TimingExtensions.pdf .
[3] Autosar 4.1 methodology, version 3.1.0.
http://www.autosar.org/download/R4.1/AUTOSAR_
TR_Methodology.pdf , October 2013.
[4] ALL TIMES Partners. ALL TIMES: D2.23.2 Final
prototype of integrated system-level verication
methodology , August 2010.
[5] S. Anssi, S. Tucci-Piergiovanni, S. Kuntz, S. Gerard,
and F. Terrier. Enabling scheduling analysis for
autosar systems. IEEE International Symposium on
Object-Oriented Real-Time Distributed Computing,
pages 152{159, 2011.
[6] E. Azketa, J. Uribe, J. Gutierrez, M. Marcos, and
L. Almeida. Permutational genetic algorithm for the
optimized assignment of priorities to tasks and
messages in distributed real-time systems. In
Proceedings of the 10th IEEE International Conference
on Trust, Security and Privacy in Computing and
Communications , pages 958{965, 2011.
[7] L. Davis. Handbook of Genetic Algorithms . Van
Nostrand Reinhold, 1991.
[8] R. I. Davis, A. Burns, R. J. Bril, and J. J. Lukkien.
Controller area network (can) schedulability analysis:
Refuted, revisited and revised. Real-Time Systems ,
35(3):239{272, 2007.
[9] M. Di Natale and A. L. Sangiovanni-Vincentelli.
Moving from federated to integrated architectures in
automotive: The role of standards, methods and tools.
Proceedings of the IEEE , 98(4):603{620, 2010.
[10] M. Di Natale and J. A. Stankovic. Dynamic
end-to-end guarantees in distributed real time
systems. In Proceedings of the IEEE Real-Time
Systems Symposium , pages 216{227, 1994.
[11] M. G. Dixit, P. Dasgupta, and S. Ramesh. Taming the
component timing: A cbd methodology for real-time
embedded systems. In Proceedings of the Conference
on Design, Automation and Test in Europe (DATE) ,
pages 1649{1652, 2010.
[12] M. G. Dixit, S. Ramesh, and P. Dasgupta.
Time-budgeting: a component based development
methodology for real-time embedded systems. Formal
Aspects of Computing , pages 1{31, March 2013.
[13] N. Feiertag, K. Richter, and C. Ficek. On the
decomposition of end-to-end timing requirements in
distributed partitioned automotive functions. In SAE
World Congress, Detroit, USA , 2012.
[14] R. Gerber, S. Hong, and M. Saksena. Guaranteeing
real-time requirements with resource-based calibration
of periodic processe. In IEEE Transactions on
Software Engineering, volume 21, pages 579{592, July
1995.
[15] R. Henia, A. Hamann, M. Jersak, R. Racu, K. Richter,
and R. Ernst. System level performance analysis - the
symta/s approach. Computers and Digital Techniques,
IEE Proceedings -, 152(2):148{166, Mar 2005.
[16] S. Hong, T. Chantem, and X. S. Hu. Meeting
end-to-end deadlines through distributed localdeadline assignment. In Proceedings of the IEEE
Real-Time Systems Symposium , 2010.
[17] P. Jayachandran and T. Abdelzaher. Delay
composition in preemptive and non-preemptive
real-time pipelines. In Real-Time Systems Journal ,
volume 40, pages 290{320, 2008.
[18] A. Mehiaoui, E. Wozniak, S. T. Piergiovanni,
C. Mraidha, M. D. Natale, H. Zeng, J.-P. Babau,
L. Lemarchand, and S. G erard. A two-step
optimization technique for functions placement,
partitioning, and priority assignment in distributed
systems. In Proceedings of the ACM
SIGPLAN/SIGBED Conference on Languages,
Compilers, Tools and Theory for Embedded Systems
(LCTES) , pages 121{132, 2013.
[19] B. L. Miller and D. E. Goldberg. Genetic algorithms,
tournament selection, and the eects of noise.
Complex Systems , 9:193{212, 1995.
[20] C. Mraidha, S. Tucci-Piergiovanni, and S. Gerard.
Optimum: a marte-based methodology for
schedulability analysis at early design stages. ACM
SIGSOFT Software Engineering Notes, 36(1):1{8,
2011.
[21] R. Racu, A. Hamann, and R. Ernst. A formal
approach to multi-dimensional sensitivity analysis of
embedded real-time systems. In 18th Euromicro
Conference on Real-Time Systems , 2006.
[22] J. Rox, K. Schmidt, A. Winter, T. Spengler, and
R. Ernst. Estimating and mitigating design risk in a
exible distributed design process. IEEE Embedded
Systems Letters , 2(2):35{38, 2010.
[23] O. Scheickl. Timing Constraints in Distributed
Development of Automotive Real-time Systems . PhD
thesis, Technische Universit at M unchen f ur
Informatik, 2011.
[24] N. Serreli and E. Bini. Deadline assignment for
component-based analysis of real-time transactions. In
2nd Workshop on Compositional Real-Time Systems,
Washington, DC, USA , 2009.
[25] TIMMO-2-USE Partners. TIMMO-2-USE Timing
Model - Tools, algorithms, languages, methodology,
USE cases , October 2012.
[26] K. Tindell and J. Clark. Holistic schedulability for
distributed hard real-time systems. Microprocessing &
Microprogramming , 40:117{134, 1994.
245