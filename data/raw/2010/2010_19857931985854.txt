  
Permission to make digital or hard copies of all or part of this work for personal o r
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full
citation on the first page. To copy otherwise, to republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. 
ICSE ‘11, May 21–28, 2011, Waikiki, Honolulu, HI, USA. 
Copyright © 2011 ACM 978-1-4503-0445-0/11/05... $10.00 Refactoring to Role Objects 
Friedrich Steimann 
Lehrgebiet Programmiersysteme 
Fernuniversität in Hagen  
D-58084 Hagen 
steimann@acm.org Fabian Urs Stolz 
Volkswohl Bund Versicherungen 
Südwall 37–41 
D-44137 Dortmund 
Fabian.Stolz@volkswohl-bund.de 
ABSTRACT   
Role objects are a widely recogni zed design pattern for represent-
ing objects that expose different properties in different contexts. 
By developing a tool that automati cally refactors legacy code to-
wards this pattern and by applying this tool to several programs, 
we have found not only that refactoring to role objects as cur-
rently defined produces code that is  hard to read and to maintain, 
but also that the refactoring has preconditions so strong that it is 
rarely applicable in practice. We  have therefore taken a fresh look 
at role objects and devised an alternative form that solves the ex-
act same design problems, yet is much simpler to introduce and to 
maintain. We describe refactoring to this new, lightweight form of 
role objects in informal terms and report on the implementation of 
our refactoring tool for the J AVA programming language, present-
ing evidence of the refactoring’s increased applicability in several 
sample programs. 
Categories and Subject Descriptors   
D.2.3 [ Software Engineering ]: Coding Tools and Techniques – 
object-oriented programming. 
General Terms 
Design, Languages 
Keywords 
refactoring to patterns, roles, delegation, objec t schizophrenia 
1. INTRODUCTION 
Subclassing is a key feature of many object-oriented programming 
languages in widespread use. It allows it that different classes 
share specification and behaviour,  by way of inheritance from a 
common superclass. On the class level, subclassing establishes a 
strong coupling in the sense that  changes to a superclass likely 
have an effect on its subclasses.  While this strong coupling is 
known to cause problems (e.g., th e fragile base class problem 
[18]), it is usually intentional: sharing implies that changes to the shared specification affect all that share. On the instance level, 
however, objects of a subclass are completely independent of the 
objects of its superclass in the sense that changing the state of one 
object does not change the state of the other. This independence is 
usually also intentional: since ob jects represent individuals, their 
state should change individually. 
There are however situations in which the combination of shar-
ing of specification and separation of state turns out to be inade-
quate. These situations usually aris e when it is discovered that in-
stances of sibling subclasses, or of a superclass and a subclass, do 
not represent different individuals, but one logical entity. In these 
cases, not only the specification of state (i.e., the declaration of fields) is to be shared, but also the state itself (i.e., the values of 
the fields). While such sharing of  state is natural for prototype-
based languages such as S
ELF [27], it is foreign to the standard 
class-based langua ges (including J AVA, C#, and C++), and has to 
be emulated with some effort. The notion of role objects  [4, 8] 
captures one such effort. 
In this paper, we report on our findings in devising a fully 
automated refactoring tool that aids the introduction of role ob-
jects. For this, we briefly recapitulate (in Section 2) the notion of 
role objects in class-based object-oriented programming lan-
guages, and revisit the R OLE OBJECT  pattern (ROP) [4] as a stan-
dard solution, elaborating on its intrinsic problems and on refac-
toring legacy code towards using it. Particularly the latter, al-
though reducible to a series of st andard refactorings [7, 10, 15, 
19], seriously questions the utility of the ROP, as it has some very 
strong preconditions and leads to unsatisfactory results. To ad-
dress these problems, Section 3 pr esents a new, lightweight ver-
sion of role objects that evolved out of our attempts to improve 
(refactor) the code resulting from refactoring to the original ROP, 
and that is much easier to refact or to. Sections 4 and 5 describe 
the implementation of tw o refactoring tools, one for each form of 
role objects, and provide some details of their applicability as de-
rived from a comparative evaluation. A discussion of related work 
concludes our contribution. 
2. ROLE OBJECTS 
Today it is widely recognized that many types found in object-
oriented systems represent roles, not entities. For instance, Em-
ployee , Employer , Customer , etc. are all different role types asso-
ciated with the same entity type Person ; just as Product , Stock , and 
Asset  are different role types associated with the entity type Thing . 
While entity types naturally corres pond to classes, role types have 
rather different properties so that representing them with classes 
must be expected to cause problems. Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00
441
As types, roles differ from classes in that the same object can 
have many roles, even at the sa me time, and can pick up and drop 
roles dynamically; whereas an object can have only one class 
(namely the one it is an instance of), and keeps this class for its 
whole lifetime. While depending on author, there are many more 
distinguishing properties associated with roles [22], their ability to 
extend objects with properties offe red and required in certain con-
texts only is central to all of them (and in any case the one we are 
focusing on here). 
There are several competing approaches to implementing roles 
in object-oriented programs [8].  The simplest is implementing 
roles as subclasses, for instance Employee  as a subclass of Person . 
However, while this implementation may seem plausible at first 
glance ( Employee  adds certain, employee-specific properties to 
Person ), it does not scale: as soon as a second role is added to Per-
son (as a second subclass) and as s oon as the same entity must as-
sume both roles (e.g., a person is both an employee and a cus-tomer), this approach hits the wall, since an object cannot be an 
instance of two sibling classes. When this happens, the code is 
usually refactored to role objec ts, more specifically to adopting 
the R OLE OBJECT  pattern (ROP) [4]. 1 /*entity*/ class Person { 
2  private String name, address; 
3  Person(String n, String a) { 
4   name = n; address = a; 
5  } 
6  String getAddress() { return address; } 
7  String getContactInfo() { 
8   return name + ", " + getAddress(); 
9  } 
10  void join(Organization org) { 
11   org.addMember( this); 
12  } 
13 } 
 
14 class Organization { 
15  Set<Person> members = new HashSet<Person>(); 
16  void addMember(Person p) { members.add(p); } 
17  boolean hasMember(Person p) { 
18   return members.contains(p); 
19  } 
20 } 
 
21 /*role*/ class Employee extends Person { 
22  Employer employer; 
23  Employee(String n, String a, Employer e) { 
24   super(n, a); 
25   employer = e; 
26  } 
27  @Override String getAddress() { 
28   return employer.getAddress(); 
29  } 
30 } 
 
31 class Employer { 
32  String address; 
33  Employer(String a) { address = a; } 
34  String getAddress() { return address; } 
35 } 
 
36 /*role*/ class Agent extends Person { 
37  Agent(String n, String a) { super(n, a); } 
38 } 
 
39 class Main { 
40  static void main(String... args) { 
41   Employer gvnmt = new Employer("London"); 
42   Employee bond =  
43    new Employee("Bond", "secret", gvnmt); 
44   assert bond.getContactInfo() 
45    .equals("Bond, London") : "Assertion 1"; 
46   Agent doubleO7 = new Agent("Bond", "secret"); 
47   Organization mi6 = new Organization(); 
48   doubleO7.join(mi6); 
49   assert mi6.hasMember(doubleO7) : "Assertn 2"; 
50   assert mi6.hasMember(bond) : "Assertion 3"; 
51  } 
52 } 
Figure 1: A running example with two role classes imple-
mented as subclasses of an entity class ( public  modifiers have 
been omitted to avoid clutter).  1 interface  Person { 
2  String getAddress(); 
3  String getContactInfo(); 
4  void join(Organization org); 
5  <R extends PersonRole> R addRole 
6    (Class<R> spec, Object... arguments); 
7  …  
8 } 
 
9 class PersonCore implements  Person { 
10  private String name, address; 
11  private Collection<PersonRole> roles =  
12    new HashSet<PersonRole>(); 
13  PersonCore(String n, String a) { 
14   name = n; address = a; 
15  } 
16  String getAddress() { return address; } 
17  String getContactInfo() { 
18   return name + ", " + getAddress(); 
19  } 
20  void join(Organization org) { 
21   org.addMember( this); 
22  } 
23  <R extends PersonRole> R addRole 
24     (Class<R> spec, Object... arguments) { 
25   R role = … 
26   roles.add(role); role.core = this; 
27   return role; 
28  } 
29  … 
30 } 
 
31 abstract  class PersonRole implements  Person { 
32  PersonCore core; 
33  String getAddress() { 
34   return core.getAddress(); 
35  } 
36  String getContactInfo() { 
37   return core.getContactInfo(); 
38  } 
39  void join(Organization org) { 
40   core.join(org); 
41  } 
42  <R extends PersonRole> R addRole 
43     (Class<R> spec, Object... arguments) 
44   return core.addRole(spec, arguments); 
45  } 
46  … 
47 } 
 
48 class Employee extends PersonRole { 
49  … 
50  Employee(Employer e) { employer = e; } 
51 } 
 
52 class Agent extends PersonRole { 
53  Agent() {} 
54 } 
 
55 class Main { 
56  static void main(String... args) { 
57   Person james =  
58     new PersonCore("Bond", "secret"); 
59   Employer gvnmt = new Employer("London"); 
60   Employee bond =  
61     james.addRole(Employee. class, gvnmt); 
62   assert bond.getContactInfo() 
63     .equals("Bond, London") : "Assertion 1"; 
64   Agent doubleO7 = james.addRole(Agent. class); 
65   Organization mi6 = new Organization(); 
66   doubleO7.join(mi6); 
67   assert mi6.hasMember(doubleO7) : "Assertn 2"; 
68   assert mi6.hasMember(bond) : "Assertion 3"; 
69  } 
70 } 
Figure 2: Adoption of the ROP as defined in [4] for the code of 
Figure 1; only changes are shown. 4422.1 The R OLE OBJECT  Pattern 
Figure 1 gives an impression of the problem. In the current design 
of a J AVA program, a class Employee  derives from a class Person  
and adds to it a relationship to class Employer  (modelled as a field 
of the same name). Employee  also overrides the method getAd-
dress()  inherited from Person , returning the address of the em-
ployer. getAddress()  in Person  is complemented by a method get-
ContactInfo()  containing an invocation of the former which, de-
pending on the receiver (the value of this), may bind to the im-
plementation in Person  or Employee . Employee , which represents a 
role of Person , has a sibling class Agent  adding no state or behav-
iour to Person . All three classes share the fields name  and address  
defined in Person . 
The example is completed by a class Organization  whose in-
stances maintain a set of Person  objects representing the members 
of an organization. Persons can be  made to join organizations by 
invoking a method join(.)  on them, which passes this to the add-
Member(.)  method of Organization  (Figure 1, line 11). The 
Main.main(…)  method creates two instan ces, one of (role) class 
Employee , one of (role) class Agent , which are to represent the 
same person in different roles (a s expressed by assigning them the 
same name and address), and lets the latter join mi6, an instance 
of class Organization . The intended meaning of the program is ex-
pressed by three assertions placed in its main method. 
Quite obviously, this sample pr ogram contains a logical bug: 
although the instances named bond  and doubleO7  are meant to 
represent the same entity, they are actually different (and totally 
unrelated) objects. This is evidenced by the failure of Assertion 3, 
testing for the membership of bond  in mi6, to which doubleO7  had 
just been added. It is these situ ations in which the ROP is usually 
adopted. 
Figure 2 shows the code changes implied by a naive adoption 
of the ROP. Except for the omission of the remaining methods 
implementing role management (c f. Figure 3), it corresponds pre-
cisely to the implementation specified in [4]. The general class structure of the ROP (also adopted from [4]) is shown in Figure 3. 
The main difference between the original design and the ROP 
is that the original 
Person  class is now an interface serving as a 
common abstraction (supertype) of a new PersonCore  class and a 
new abstract PersonRole  class. The two new classes form a com-
position in the sense that a core and its role objects together repre-
sent one logical entity, the so-called subject  [4]. Since both classes 
implement the Person  interface, instances of either can represent the subject in a context in which an instance of Person  is expected, 
maintaining the subtyping relations hips of the original program. 
Note that the fields representing the state of the former class Per-
son, which are now defined in PersonCore , are no longer inherited 
by the role classes: their instances share state with the core object 
that is stored in a field named core. For this purpose, access re-
quests to the shared state are redirected to the fields of the core 
through corresponding accessor methods, which must be intro-
duced if not already present. As before, the role classes, which 
must be subclasses of PersonRole , can add their own state and be-
haviour, complementing those of PersonCore . 
Using the ROP, it is now possible to express that the objects 
named bond  and doubleO7  are two roles of the same object james , 
which is itself an instance of class PersonCore  (lines 60–61 and 64 
in Figure 2). Note that the ROP mandates that role objects (here: 
instances of subclasses of PersonRole ) are not created directly by 
clients [4]; rather, clients are to  invoke the factory method of the 
core (here: addRole(…)  of class PersonCore ; note that it is called 
addRole  since it creates the role and adds it to the core in one 
step). 
Executing the so-changed code, one  might expect Assertion 3 
to hold, since the method PersonCore.join(.)  adds this to the or-
ganization (line 21), where this points to an instance of the core, 
which is the same object (namely james ) for both bond  and dou-
bleO7 . However, instead of correcting the bug of the original pro-
gram in Figure 1, all three assert ions now fail! What went wrong? 
2.2 Problems of the R OLE OBJECT  Pattern 
The adoption of the ROP performed in the previous subsection is 
naive because it introduces a change of binding that is revealed by 
the failure of Assertion 1 (line 44 in Figure 1): instead of returning 
the address of the employer as specified in class Employee  (line 
28), getContactInfo()  called on an employee now returns the pri-
vate address (from class PersonCore ; line 16 in Figure 2). Why is 
that? 
The problem is that PersonRole.getContactInfo()  (line 36–38) 
uses forwarding  where it should have used delegation . With dele-
gation [13, 17], this in the delegated method (here: Person-
Core.getContactInfo() ) would refer to the instance of the delegator 
(here: bond , an instance of class Employee ) rather than to an in-
stance of the delegatee (here: james , instance of PersonCore ), and 
calling a method on this would invoke its im plementation in the 
delegator (if it exists) rather than in the delegatee. While delega-
tion is the native inheritance m echanism of prototype-based lan-
guages such as S ELF [27], it is not directly available for instances 
in most mainstream object-orie nted programming languages, in-
cluding J AVA, C#, and C++. 
To fix this problem (which exists  in many design patterns), [9, 
13] suggest adding a parameter to the delegated method that refers 
back to the delegator. In the above example, this would translate 
to the method 
 public String getContactInfo() { 
  return core.getContactInfo( this); 
 } 
replacing the original method in PersonRole  (Figure 2, lines 36–
38) and the methods 
 public String getContactInfo() { 
  return getContactInfo( this); 
 } 
 public String getContactInfo(Person del) { 
  return name + ", " + del.getAddress(); 
 } behaviour()
addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)Component
behaviour()
addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)Component
behaviour()
addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)ComponentRole
behaviour()addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)ComponentRole
behaviour()addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)ComponentCore
statebehaviour()addRole(Spec)
hasRole(Spec)removeRole(Spec)
getRole(Spec)ComponentCore
statecoreroles
addedBehaviourA()ConcreteRoleA
addedStateAaddedBehaviourA()ConcreteRoleA
addedStateAaddedBehaviourB()ConcreteRoleB
addedStateBaddedBehaviourB()ConcreteRoleB
addedStateBcore.behaviour()
core.addRole(aSpec) 1**ClientA
ClientB
Figure 3: Structure of the ROP (adopted from [4]). 443replacing getContactInfo()  in PersonCore (lines 17–19). 
However, this fix requires the core class to know whether the 
(delegating) role class (here: Employee ) overrode a method called 
on this in the core class before the refactoring (here: getAddress()  
in PersonCore , line 18), since only then can the call be forwarded 
back to the delegator. In fact, if there are several role classes 
(here: Employee  and Agent ), some of which overrode the called 
method ( Employee ), some of which did not ( Agent ), a case analy-
sis is needed to decide dynamically whether the delegator or the 
delegatee is the receiver of met hod calls that are dispatched on 
this.1 Fortunately, this case analysis  can be trusted to dynamic 
binding, by providing a default imp lementation of all methods in 
question in the (abstract) role class (here: PersonRole ), to which 
calls are forwarded and which i nvokes the implementation in the 
core unless overridden in a concrete role subclass. In the case of 
our example, the method 
 public String getAddress() { 
  return core.getAddress(); 
 } 
                                                 
1 Note that whether there was an  overriding method to be called 
cannot generally be coded in the delegated method call either (for 
instance by calling the method accepting the delegator as parame-
ter if there is one, and the original method if there is not), because 
the delegated method may call ar bitrarily many other methods, 
some of which may have been overridden, some not. must be added to class PersonRole . Figure 4 shows the resulting, 
somewhat convoluted control flow  using sequence diagrams for 
the different cases:2  
a) The original program of Figure 2 fails because getCon-
tactInfo()  in PersonCore  calls getAddress()  of the same class, 
and not the (formerly overriding) version in Employee . 
b) Supplied with it as a delegation parameter, getContactInfo(.)  
in PersonCore  can invoke getAddress()  on the delegator, lead-
ing to the desired result (here: eventually leading to the invo-
cation of getAddress()  on the employer). 
c) If supplied with an instance of a class that does not provide its 
own implementation of getAddress() , getContactInfo(.)  in-
vokes the default implementation  inherited from the abstract 
role superclass, PersonRole , which forwards the request back 
to the core. 
As was to be expected, the described changes restore the status 
of Assertion 1. However, Assert ion 2 still fails: when the invoca-
tion of join(Organization)  on doubleO7  (line 66 in Figure 2) is for-
warded to PersonCore  (line 40), the object this that is to join the 
organization (line 21) changes from the delegator ( doubleO7 , an 
instance of Agent ) to the delegatee ( james , an instance of Person-
Core). Thus, when the organization is checked for the membership 
of the newly joined Agent  instance doubleO7 , the answer is no, 
since it was the PersonCore  instance james  that joined. The prob-
lem here is that the identity of  the agent is split among two ob-
jects, a phenomenon commonly referred to as object schizophre-
nia [5]. Note that, as far as the failure of Assertion 2 is concerned, 
the problem can be fixed by passing doubleO7  as an additional 
delegator  parameter to the PersonCore.join(.)  method and by re-
placing this in its body with delegator ; however, this leaves the 
failure of Assertion 3, which is also caused by object schizophre-
nia, unaddressed. 
Object schizophrenia is a known problem of the ROP. Since an 
object playing a role is split into two instances, one of the role 
class and one of the core class, tests for identity of two references 
depend on whether both references to gether either point to the role 
or the core instance. If identity of the logical subject which, de-
pending on context, may be represented by the core or any of its 
roles, is to be tested, a different test for identity is needed. Such an 
alternative test for identity, which is mentioned in the description 
of the ROP [4], should be an integr al part of the role management 
protocol of the ROP — in the above  example, it could be added in 
the form of the method 
 boolean isSame(Person other) { 
  if (other instanceof  PersonCore) 
   return this == other; 
  return this == ((PersonRole) other).core; 
 } 
implemented in class PersonCore . Clients wishing to test for iden-
tity then have to decide which test they mean, and either use == or 
isSame(.) . 
As it turns out, however, using this  alternative test for identity 
in our sample program is not easily possible, since the test for 
identity the implementation of Organization.hasMember(.)  relies 
                                                 
2 Note that the situation is complicated even further if an overrid-
ing method of the original program contains calls to super ; in that 
case, the replacing delegation leads into infinite recursion, which 
can only be avoided by introducing yet another method in the core 
class. bond:Employee james:PersonCore mi6:Employer
getContactInfo()getContactInfo()
getAddress()
bond:Employee james:PersonCore
getContactInfo()getContactInfo(this)
getAddress()mi6:Employer
getAddress()
doubleO7:Agent james:PersonCore
getContactInfo()getContactInfo(this)
getAddress()mi6:Employer
getAddress()a)
b)
c)
Figure 4: Sequence diagrams ex hibiting method dispatch 
a) before the introduction of delegation,  
b) with delegation for an instance of Employee , and 
c) with delegation for an instance of Agent.  444on is buried in library code, namely the implementation of con-
tains(.) in class java.util.HashSet .3 To work around this, we can 
rewrite the method hasMember(.)  as follows: 
 boolean  hasMember(Person person) { 
  for (Person member : members) 
   if (member.isSame(person))  
    return true; 
  return false; 
 } 
This is sufficient to make Assertion 2 hold, and with it Assertion 
3, too. 
However, what looks like killin g two birds with one stone at 
first glance really straitens our ve nture, refactoring to role objects: 
while restoring the original status of Assertion 2, replacing the test 
for identity ( ==) with the test for sameness ( isSame() ) toggles that 
of Assertion 3, and is therefore by definition not a refactoring (be-
cause it changes behaviour). In f act, since it is generally impossi-
ble to deduce from the context whet her identity or sameness is re-
quired, refactoring to the ROP ca nnot be performed automatically. 
On the other hand, since, as our  example shows, manually adopt-
ing the ROP can become quite intricate, some level of automated 
tool support would be  highly desirable. 
2.3 Refactoring to the R OLE OBJECT  Pattern 
A refactoring is a behaviour-preserving program transformation 
[7, 10, 15, 19]. It is usually pe rformed to improve existing code 
with respect to some non-functional quality such as its readability 
or changeability. Contrary to this  (and as exemplified in the pre-
vious subsections), introducing the ROP into legacy code is usu-
ally not to preserve its meaning,  but to implement the additional 
condition that two instances representing the same logical entity 
in certain contexts need to share some core state and also, depend-
ing on context, identity. Thus, where two objects may have been 
distinct before the introduction of the ROP, they can be the same 
after, and this change usually am ounts to a change of behaviour of 
the program. This means that, strictly speaking, refactoring to role 
objects  is an oxymoron. 
It is however possible to refact or programs like that of Figure 1 
implementing roles as subclasses in such a way that they maintain 
their current, partly incorrect meaning, and that their subsequent 
migration to using role objects (co rrecting their meaning) is just a 
small step. This means that distinct  objects will remain distinct af-
ter the refactoring, but can be made the same in all contexts in 
which this is required by some minor additions (which themselves 
are not refactorings). In fact, such a procedure (i.e., first preparing 
the code for change using refactorings, and then performing the 
change with as few steps as possible) is one of the main use cases 
of refactorings. In order to keep our language simple and correct, 
we will speak of “refactoring towards  (rather than to) the ROP”. 
2.3.1 Refactoring Towards the ROP 
Refactoring a program modelling ro les as subclasses as shown in 
Figure 5 a) towards the ROP can be achieved by performing a se-
quence of several smaller refactorings. These are: 
                                                 
3 contains(.)  in HashSet  falls back to equals(.)  if == fails, so that 
the problem could be solved by overriding equals(.)  with the body 
of isSame(.) ; however, this may make two objects equal inde-
pendent of whether they are required to be not equal in other con-
texts. 1. Rename the entity type (here: Person ) to the name of the core 
component class (here: PersonCore ) using the R ENAME CLASS  
refactoring [6, 7]. 
2. By applying the E XTRACT INTERFACE  refactoring [6, 7, 26], 
extract the public interface of the core class (here: PersonCore ) 
into a new interface type carrying the name of the component 
(here: Person ) and use this interface instead of the core class in 
all declarations. (Note that this way, type references in decla-
rations are changed twice, in our example first from Person  to 
PersonCore  and then back to Person . When performing the 
refactorings manually, this effo rt can of course be saved). 
3. Insert a new abstract class between the entity class and its im-
mediate subclasses, the role cla sses, and give it the name of 
the component role class (here: PersonRole ). Because this class 
does not add anything, the behaviour of the program remains 
unchanged. 
The result of the first three steps is shown in Figure 5 b). The 
refactoring then continues: 
4. Replace the inheritance of the newly inserted component role 
class from the component core cl ass with delegation, using the 
REPLACE INHERITANCE WITH DELEGATION  refactoring [7, 14], 
naming the field holding the delegatee core (cf. Figure 3). 
Note that the refactoring as speci fied in [14] will automatically 
let the component role subtype th e component inte rface if this 
is required by assignments  existing in the program. 
5. Add the collection roles  to the component core class and add 
the methods required for role management to the component 
core and role classes (cf. Figure 3). 
6. Add constructors for the role classes accepting and assigning 
only the added state. 
The static structure of the result of the last three steps is shown in 
Figure 5 c). Note that for the refactoring to be able to replace the 
old entity type (a class) with the new component type (an inter-
face) in as many declarations as possible it may be necessary to 
refactor direct field access to accessor methods first, using the 
ENCAPSULATE FIELD refactoring [6, 7]. In fact, since applicability 
of the R EPLACE INHERITANCE WITH DELEGATION  refactoring de-
pends to a large extent on the encapsulation of inherited fields 
[14], using the S ELF ENCAPSULATE FIELD refactoring [7] instead 
can increase applicability of the refactoring. However, replacing 
inheritance with delegation has several more preconditions [14], 
so that it may require other prep aratory refactorings, or cannot be 
performed at all (cf. Section 5). 
2.3.2 Migration to Role Objects 
Once the above refactoring steps have been performed, the pro-
gram is ready to be migrated to using role objects. For this, all «Entity Type»
Person
«Role Type»
Employee«Role Type»
Agent«Abstract Role»
PersonRole
«Concrete Role»
Employee«Concrete Role»
Agent«Interface»
Person
«Entity Type»
PersonCore«Component Role»
PersonRole
«Concrete Role»
Employee«Concrete Role»
Agent«Component»
Person
«Compontent Core»
PersonCorea) b) c)
Figure 5: Refactoring roles as subclasses to the ROP (see text).445constructor calls of role classes in  the program must be changed to 
invocations of the addRole(…)  method on a core object. Of course, 
the required core objects, which were previously unrelated to the 
roles (if they existed at all), cannot be deduced automatically — 
delivering them is part of extend ing the program to using role ob-
jects, and using them as common cores likely changes the mean-
ing of the program (since different role objects are now coupled 
by common state maintained by the core). The other change nec-
essary to leverage role objects after the refactoring is to identify 
all tests for identity (using ==), and replace those that actually test 
for the same logical entity (admitting different roles) with a test 
for core identity using isSame() . Again, this will change behaviour 
and is therefore not a refactoring. 
2.4 Bottom Line 
Although popular, implem entation of the ROP in programming 
languages without delegation as a native language construct suf-
fers from a number of non-negligible  problems. Firstly, emulating 
the necessary delegation requires auxiliary methods that bloat 
class interfaces and implementation and, because of the additional 
method dispatches introduced, lead to code that is difficult to un-
derstand and maintain. Secondly, the object schizophrenia result-
ing from splitting an object into a role and a core requires the in-
troduction of delegation parameters even in cases in which 
method binding can remain unchanged (the method receivers re-
main the same), namely when te sts for object identity involving 
this are triggered by the core class (the former superclass), or 
when synchronization between methods  of a role class and its core 
class are necessary. 
Another issue with introducing the ROP is that the necessary 
refactoring of the program inher its some rather strong precondi-
tions from its sub-refactor ings (in particular E XTRACT INTERFACE  
[26] and R EPLACE INHERITANCE WITH DELEGATION  [14]), either 
making even more refactoring (suc h as encapsulating fields) nec-
essary or prohibiting adoption of the pattern altogether. All in all, 
although solving an important pr actical problem it seems that 
adopting the ROP is subject to so many ifs, ands, and buts that the 
search for a better implementation of role objects is justified. 
3. A LIGHTWEIGHT FORM OF ROLE 
OBJECTS 
If it were not the result of one, the code ensuing from the adoption 
of the ROP would cry for refactori ng. Especially the parts emulat-
ing delegation are awkward and, if possible, should be replaced by 
something that makes better us e of available programming lan-
guage constructs. 
It turns out that in object- oriented programming languages 
delegation is implemented as inheritance [25], and that all the ex-
tra methods and parameters requir ed by explicit delegation are 
made obsolete by applying the R EPLACE DELEGATION WITH IN-
HERITANCE  refactoring [7]. The problem of replacing the delega-
tion of the ROP with inheritance is that while the latter realizes 
sharing of behaviour (including overriding semantics), it deprives 
two objects sharing behaviour of th eir shared state. As indicated 
in the Introduction, the reason for this is that in class-based object-
oriented programming languages, every object receives its own 
copy of the fields (more technically: allocates its own memory for 
the fields) inherited from its superclasses, whereas in prototype-
based languages (which are built on delegation), inherited fields 
are shared with the object fro m which is inherited [27]. 3.1 Refactoring the ROP 
The solution is to let different objects of a class hierarchy share 
state explicitly. For this purpose, the shared state must be exter-
nalized to an object to which all objects involved in the sharing re-
fer (Figure 6). Note that this object must be an instance of a new 
class introduced for this purpose, and in particular that it cannot 
be an instance of the entity class, since this would mean that the 
state specification (the necessary field declarations) would be in-
herited by the role classes so that each role instance would allo-
cate its own state (even if it does not use it). 
Sharing state in this manner is similar to the delegation re-
quired for the ROP in that a single entity and its role objects share 
an object holding the common state. It is different in that the 
shared object does not represent the entity itself (as the core does 
in the ROP) — instead, the entity has its state externalized in ex-
actly the same manner as the role objects. It is also different in 
that the behaviour specification (definition of methods) remains 
entirely in the delegating classes, so that inheritance can take over 
the delegation necessary for shar ing behaviour. The ROP can thus 
be refactored as follows: 
1. By applying the E XTRACT CLASS  refactoring [6, 7] to the core 
class, move all fields of the core class (including the field 
holding the role objects) to a ne w state class, and assign the 
core class a single new field state  of the type of the state class, 
which holds an instance keeping the core class’s instances’ ex-
ternalized state. All methods rema in in the core class; in their 
bodies, references to fields f are replaced by state.f . 
2. Using the R EPLACE DELEGATION WITH INHERITANCE  refactor-
ing [7], replace the delegation from the (abstract) role class to 
the core class by inheritance, making the former a subclass of 
the latter. Since the sole purpose of the role class was to intro-
duce the code necessary for delegation, it is now empty: the 
delegation (sharing) of behaviour is replaced by inheritance, 
and the delegation (sharing) of state is achieved by assigning 
the state  field inherited from the core class (replacing the core 
field; cf. Figure 3) the shared state object (replacing the former 
core object). 
3. Since the former core class is now a superclass of the role 
classes, the common interface of the core and the roles has be-
come obsolete and can be removed;  references to it can be re-
placed by references to the core class. getField()
setField(Value)
behaviour()
addRole(Spec)
hasRole(Spec)
removeRole(Spec)
getRole(Spec)
isSame(Entity)Entity
getField()
setField(Value)
behaviour()
addRole(Spec)
hasRole(Spec)
removeRole(Spec)
getRole(Spec)
isSame(Entity)Entity
state
addedBehaviourA()RoleA
addedStateAaddedBehaviourA()RoleA
addedStateAaddedBehaviourB()RoleB
addedStateBaddedBehaviourB()RoleB
addedStateBreturn state.field
state.field aValue1*
AbstractRoleroles
*EntityState
fieldEntityState
field
stateother.state
Figure 6: Lightweight role object s: roles as subclasses of an 
Entity  class with externalized state and identity. 446The result of these refactorings is shown in Figure 6. Since all 
role classes inherit the externalization of state from the entity 
class, every role object has at least the state and behaviour defined 
for the entity class, while the role creation methods guarantee that 
it shares its “inherited” state with precisely one entity object. Just 
as in the original ROP, an object and its roles are thus represented 
by a set consisting of one instance of the entity class and any 
number of instances of the role classes. Note that the abstract role 
class, although not adding anything, is still useful: it provides the 
type of the objects that can join an instance of the entity class as 
the roles of this instance (the element type of the collection named 
roles , which now resides in the state class). 
We call this new form of role objects lightweight role objects  
(LRO). 
3.2 Refactoring Towards LRO 
While the simplicity of the lightweight implementation of role ob-
jects is appealing, the way we got there is certainl y not. In particu-
lar, first replacing inheritance w ith delegation and then replacing 
delegation with inheritance are two laborious refactoring steps 
that, had it not been for the intermittent extraction of state, would 
cancel each other’s effect. Therefore, it would be interesting to see 
whether a program such as that of Figure 1 can be refactored di-
rectly towards LRO (so that, as in the ROP case, leveraging LRO 
requires only a few additional changes). 
As it turns out, refactoring the original program of Figure 1 
towards LRO is comparatively simple. It is achieved by the fol-
lowing sequence of sub-refactorings: 
1. Using the S ELF ENCAPSULATE FIELD refactoring [6, 7], insert 
accessor methods for every field of the original entity class 
(here: Person ) and replace direct fiel d access with invocations 
of the accessors. 
2. By applying the E XTRACT CLASS  refactoring [6, 7] to the entity 
class, shift the fields encapsulated in step 1 from the entity 
class into a new class and call it EntityState  (here: Person-
State ). The refactoring automatically assigns the entity class a 
new field named state , which is initialized to an instance of 
EntityState , and redirects field acce ss in the accessor methods 
to this instance. 
3. Insert a new abstract class betw een the superclass and its im-
mediate subclasses (the role classes), and call it AbstractRole  
(here: PersonRole ). Because this class does not add anything, 
the behaviour of the program remains unchanged. 
4. Add a field roles  holding a collection of roles to EntityState  
and the necessary role management operations ( addRole(…) , 
isSame(.), etc. ) to the entity class. 
5. Add new constructors to the role classes that accept only the 
added state as parameters. 
The results of these refactorings as applied to the sample program 
of Figure 1 are shown in Figure 7. 
Analogous to refactoring towards the ROP (Section 2.3), 
where each role object received its own core, initially, all in-
stances of role classes (and the superclass) receive their own state 
object, making them distinct entities. In order to leverage LRO, 
instances of role classes must be made to share the state with an 
instance of their entity class, which is done by replacing calls to 
the role constructors with i nvocations of the factory method add-
Role(…)  provided by the entity class.  In fact, the only difference 
between the entity class and its role classes is that no two in-stances of the entity class must share the same state object; this is 
ensured by using the new abstract role class as an upper bound of 
the types whose instances can share state with an instance of the 
entity class (line 18 in Figure 7). 
Also analogous to refactoring towards the ROP, the last step 
necessary to complete migration to LRO is to replace tests for 
identity where necessary (here: in method hasMember(.)  of class 
Organization ; cf. Section 2.3). With these changes performed, the 
main method of Figure 2 executes without the failure of asser-
tions. 
4. IMPLEMENTATION 
Since checking the preconditions of a refactoring and performing 
the necessary changes in an actual application of the refactoring is 
tedious and error prone, the specif ication of a refactoring is usu-
ally complemented by a refactori ng tool. In fact, it is usually not 
before such tool support has been  tried that all the preconditions 
and mechanics (necessary changes of the program), which usually 
depend on complex case analyses involving all conceivable corner 
cases, are discovered and fully unde rstood. In absence of a formal 
correctness proof of a refactoring (cf. below), implementing it as a 
tool is a necessary exercise. 
We have therefore implemente d two fully automated tools 
(downloadable from http://www.feu.de/ps/prjs/IROP ) as exten-
sions to E CLIPSE ’s J AVA DEVELOPMENT TOOLS , for refactoring 
JAVA code towards the ROP and LRO as described in Sections 
2.3.1 and 3.2, respectively. The implementation follows the 
Eclipse guidelines for refactoring t ools closely, and makes full use 1 class PersonState { 
2  String name; 
3  String address; 
4  Collection<Person> roles = … 
5 } 
 
6 class Person { 
7  PersonState state = new PersonState(); 
8  Person(String n, String a) { 
9   state.name = n; state.address = a; 
10  } 
11  String getAddress() { return state.address; } 
12  String getContactInfo() { 
13    return  state.name + ", " + getAddress(); 
14   } 
15  void join(Organization org) { 
16    org.addMember( this); 
17   } 
18  <R extends PersonRole> R addRole 
19      (Class<R> spec, Object... arguments) { 
20   R role = … 
21   state.roles.add(role); role.state = state; 
22   return role; 
23  } 
24   … 
25  boolean isSame(Person other) { 
26   return state == other.state; 
27  } 
28 } 
 
29 abstract  class PersonRole extends Person {} 
 
30 class Employee extends PersonRole { 
31  … 
32  Employee(Employer e) { employer = e; } 
33 } 
 
34 class Agent extends PersonRole { 
35  Agent() {} 
36 } 
Figure 7: Lightweight implementa tion of role objects delegat-
ing state and identity, but not behaviour; cf. this to Figure 2. 447of the Language Toolkit (LTK) devised for this purpose. Thus, 
both refactoring tools offer a full preview of all changes to be 
made or, in case the refactoring cannot be performed, list the vio-
lated preconditions. 
4.1 Implementing Delegation for the ROP 
As detailed in Section 2.2, im plementing explicit delegation in 
JAVA and other class-based obje ct-oriented programming lan-
guages using extra parameters hol ding the delegator is ponderous. 
We have therefore adopted our implementation of delegation de-
veloped for the R EPLACE INHERITANCE WITH DELEGATION  refactor-
ing [14], which lets an inner class of a role class extend the entity 
class, and creates one instance of this inner class as delegatee for 
every instance of the role class as delegator. In J AVA, the instance 
of the role class (the delegator) can be reached from the instance 
of the inner class (the delegatee) using <RoleClass>.this , so that no 
explicit delegator parameter is needed when the delegator calls a 
method of the delegatee. Also, if  the delegator calls a method of 
the inner delegatee (which the delegatee inherits from its super-
class, the entity class) and th is method calls other methods on this 
that were overridden in the role class before the refactoring, the 
delegatee can provide overriding implementations of these meth-
ods that forward back to the delegator (using <RoleClass>.this ). 
Since all the necessary apparatus is embodied in the inner class 
(which can be declared private), the interfaces of both the entity 
class and the role class remain unchanged. 
However, while this approach av oids much of the added code 
necessary for explicit delegation, it means that every role object 
has its own delegatee, whereas in the ROP, all roles of a subject 
share the same delegatee, the core object. Since exploiting the “in-
nerness” of delegatees means di fferent delegatees for different 
delegators, we had to externalize the state and identity of the inner 
objects, and let this state and identity be shared between delega-
tees. The necessary externalization turns out to be the same as that 
for refactoring towards LRO (Secti on 3.2, Steps 1 and 2; in fact, 
this is how we discovered LRO). 
4.2 Preconditions 
As mentioned in Section 2, the subrefactorings involved in the 
steps necessary for refactoring towards ROP have some rather 
strong preconditions. E XTRACT INTERFACE  of Step 2 requires that 
the entity type has no static methods (precondition #1 in Table 1), 
other than static final fields (#2), or inner types (#3). Step 3, inser-
tion of a new (abstract) role class, requires that the entity type is 
not final (#5) and that it has at  least one constructor accessible 
from subclasses (#6), while Step 4, R EPLACE INHERITANCE WITH 
DELEGATION , additionally requires that the entity type is not ab-
stract (#4, so instances can be created as delegatees), its super-
classes’ constructors do not contain openly recursive calls (#8), 
and it does not extend Throwable  (not listed; only classes not ex-
tending Throwable  were submitted to the evaluation). The S ELF 
ENCAPSULATE FIELD refactoring (necessary for the externalization 
of state; cf. above) demands the absence of postfix increments and 
decrements on fields of the entity (which prevent replacing corre-
sponding field accesses with accessor methods; #10). Externaliza-
tion of state also requires the absence of access to private mem-
bers of other  objects of the entity type, from the entity type (#9), 
as well as the absence of  calls of private met hods in field initializ-
ers (#11). 
Refactoring towards LRO shares the preconditions for S ELF 
ENCAPSULATE FIELD (#10; Step 1) and for introducing a role sub-class (#5 and #6; Step 3) with ROP, and adds to them the precon-
ditions of Step 2, E XTRACT CLASS , namely absence of private in-
ner types (#7), absence of open r ecursion in superclass construc-
tors (#8), and absence of field initializers calling methods on this 
(#12).  
Note that most preconditions are specific to J AVA; other lan-
guages must be expected to pose different preconditions. 
4.3 Correctness 
Because it involves a proof that a series of transformations does 
not change the meaning of any program it is applied to, proving 
the correctness of refactoring tools requires a capture of the se-
mantics of the programming language  (which is usually not avail-
able off the shelf). Specific refactorings can be shown to be cor-rect by defining them as a sequen ce of sub-refactorings which are 
assumed to be correct [10, 19]; however, the correctness of the 
sub-refactorings is rarely itsel f rigorously proven, and not all 
refactorings can be di vided in this manner. 
Testing of refactoring tools, on the other hand, can exploit a 
simple invariant that, per defini tion, must always hold, namely 
that a refactoring must not change the behaviour of any program it 
is applied to. If the behaviour of a program serving as input to the 
refactoring tool being tested is (partially) specified by accompany-
ing regressions tests, malfunction of a refactoring tool can be de-
tected by observing that a refact ored program no longer passes its 
regression tests. Note that this way, no separate test oracle need be 
provided for testing refactoring tools. 
Exploiting this condition, we have systematically tested our 
two new refactoring tools by applyi ng them to all top-level (i.e., 
non-nested) classes of several open  source programs (as listed in 
Table 1) chosen for their coverage by accompanying test suites. 
All errors introduced by our tools were caused by the use of re-
flection in the programs to be refactored, which is a known prob-
lem for refactoring tools (and program analysis in general). 
5. COMPARATIVE EVALUATION 
While the previous sections sugge st that refactoring towards LRO 
is easier done and leads to leaner  code than refactoring towards 
ROP, we also wished to see some objective measures of applica-
bility and incurred cost. This raised the problem of defining an 
adequate evaluation scenario whic h, given that both refactorings 
are usually applied while the proj ect is evolving (namely when it 
is discovered that implementing ro les as subclasses cannot be sus-
tained; cf. Section 2) does not come  naturally. Therefore, we de-
cided to assume that any top-level class that is not a subclass of 
Throwable  could, as the design evolves, become an entity class 
that has roles, making its refactoring towards either implementa-
tion of roles necessary. Surely, the generalizability of the results 
obtained from such an evaluation basis can be questioned; on the 
other hand, there are several other subjective factors that have sig-
nificant impact on outcome (such as whether the refactoring 
should be allowed, or the user s hould be prompted, to adjust ac-
cess modifiers where they prevent a refactoring) so that one 
should interpret the results as indicating a certain tendency only. 
5.1 Applicability 
Table 1 shows that on average ac ross all projects, refactoring to-
wards ROP is possible in only one  quarter of all cases (and can 
even be as low as 11%). By comparison, refactoring towards LRO 448has an almost three times higher applicability on average (peaking 
at 95%, with a maximum 5.6-fold increase of applicability when 
compared to ROP). A closer look at the inhibiting factors for each 
refactoring is therefore in place. 
Not surprisingly, the preconditi ons of extracting an interface 
from the entity class and making this interface replace the entity 
type in all clients using it (pr econditions #1–#3; cf. Figure 3) turn 
out to be the biggest single impe diment, accounting for 82% of all 
rejected cases (note that Table 1 lists all precondition violations, 
i.e., there is no shortcut evaluatio n). The same is not a problem for 
LRO, since it leaves the type hierarchy and declared types of cli-
ents untouched. 
The next most selective preconditions, #4–#7, are arguably 
ones that would not prevent either refactoring in practice, be it be-
cause the user makes corresponding changes, be it because the 
refactorings would be allowed to  do so. However, these precondi-
tions are rarely the only ones inhibiting the refactoring — for in-
stance, allowing the refactoring to drop the final modifier (which 
one would have to do anyway if roles were to be added as sub-
classes) increases applicability si gnificantly in only one project. 
The remaining preconditions (except for #9) are more difficult 
to work around; however, they seem  to have only little impact on 
applicability.  
5.2 Cost of Application 
While the cost of each refactoring measured in terms of increase 
of lines of code is considerable in all cases (see Table 1, bottom), 
the difference between refactoring towards ROP and towards 
LRO supports what has already been suggested by Figures 2 and 
7: on average, ROP introduces 3.7 times more code than LRO. 
More than the sheer quantity of c ode added, however, counts the maintainability of this code: For LRO, only two new classes are 
created, one of which ( AbstractRole ) is almost empty and the 
working of the other ( EntityState ) is intuitively clear; here, only 
changes of state of the entity aff ect the generated code, requiring 
updates of accessor methods. By contrast, for ROP at least five 
new classes (one of which being inner) and one new interface are 
created; here, changes of behavi our mean updating explicit dele-
gation, which is easy to get wrong. 
6. RELATED WORK 
Role objects are not the only me ans of implementing roles in ob-
ject-oriented systems, yet they are perhaps the most prominent: 
for instance, [1, 11, 16, 20, 21] all have suggested implementing 
roles as adjunct instances  [22] in the style of the ROP, naturally 
facing the problems of delegation and object schizophrenia. While 
implementing roles as subclasses  is still a popular alternative (see, 
for instance, [7], which uses making role class Employee  a sub-
class of entity class Person  as an example for the R EPLACE DELE-
GATION WITH INHERITANCE  refactoring), it does not only suffer 
from the problems motivating the introduction of the ROP (cf. 
Section 2), but also makes it impo ssible that instances of two oth-
erwise unrelated entity classes (such as Person  and Company ) play 
the same role (since this would require the role to be a common 
subclass of Person  and Company  which, if can be defined, would 
have no meaningful instances [22]). This however also applies to 
our LRO, which share this concep tual inadequacy with the ROP. 
Conceptually more adequate would be to implement roles as 
partial specifications  of objects, and thus as supertypes  of entity 
types [2]. Java interfaces lend themselves for implementing roles 
of this kind [23], but also multiple inheritance or mix-ins, which 
can implement role-specific behavi our shared by different classes Table 1: Results of automatically refactorin g four sample programs towards ROP and LRO 
SAMPLE PROJECTS  Commons- 
Collections 
4.01 JPaul 
2.5.1 JUnit 
3.8.1 JUnit 
4.7 Total 
OBSERVABLES  ROP LRO ROP LRO ROP LRO ROP LRO ROP LRO 
Lines of Code (LoC) 42,594 6,916 4,856 13,982 68,348 
Top-Level Classes (Potential Entity Classes) 202 71 61 219 553 
 #1: Entity Contains Static Method 130 N/A 22 N/A 14 N/A 43 N/A 209 N/A 
 #2: Entity Contains Non- Static-Final Field 117 N/A 16 N/A 4 N/A 35 N/A 172 N/A 
 #3: Entity Contains Inner Type  23 N/A 20 N/A 12 N/A 76 N/A 131 N/A 
 #4: Entity Is Abstract 24 N/A 22 N/A 3 N/A 17 N/A 66 N/A 
 #5: Entity Is Final 50 50 9 9 0 0 2 2 61 61 
 #6: Entity Has Only Private Constructors 35 35 8 8 1 1 7 7 51 51 
 #7: Entity Has Private Inner Type  N/A 8 N/A 15 N/A 0 N/A 9 N/A 32 
 #8: Open Recursion in Superclass Constructor 13 13 0 0 1 1 13 13 27 27 
 #9: Entity Has Private Member A ccess 8 N/A 13 N/A 0 N/A 2 N/A 23 N/A 
#10: Postfix Field Access 5 5 3 3 1 1 2 2 11 11 
#11: Field Initializer Calls Private Method 0 N/A 2 N/A 0 N/A 1 N/A 3 N/A 
#12: Field Initializer Calls on This  N/A 0 N/A 2 N/A 0 N/A 1 N/A 3 Violations of Preconditions 
Total 405 111 115 37 36 3 198 34 754 185 
Refactorable Classes (Passing All Preconditions) 23 129 16 47 33 58 80 189 152 423 
 Ignoring Precondition #5 (Entity is Final) 25 148 16 50 33 58 81 190 155 446 
Applicability of Refactoring 11% 64% 23% 66% 54% 95% 37% 86% 27% 76% 
 Ignoring Precondition #5 12% 73% 23% 70% 54% 95% 37% 87% 28% 81% 
Avg. LoC per Refactorable Class 49 83 31 35 30 64 35 55 36 63 
Avg. LoC Added per Refactoring 545 287 445 235 484 275 461 245 441 198 
 of those: LoC Required for Role  Management 150 90 150 90 150 90 150 90 150 90 
Relative Increase in LoC per Class 11. 1 3.5 14.4 6.7 16.1 4. 3 13.2 4.5 12.3 3.2 
 449playing the same role. However, in practice roles as supertypes 
leads to bloated entity classes, which must possess every property 
required by every role they play. Therefore, they are often only in-
troduced after the fact, to decouple clients of classes from proper-
ties not required (for instance by using the I NFER TYPE [24] or U SE 
SUPERTYPE WHERE POSSIBLE  refactorings [26]). 
More recently, roles have become the subject of extending 
class-based programmi ng languages. Perhaps the most advanced 
form of such an extension is the O BJECT TEAMS /JAVA approach 
[12], which can be seen as a native implementation of the ROP. In 
OBJECT TEAMS , the necessary message dispatch between a core 
and its roles is realized using two different kinds of explicit 
method bindings: a so-called call-out  binding (from a role to its 
core) is defined by forwarding, whereas a so-called call-in binding 
(from core to role) is defined by method call interception (which 
can be switched on and off by (de)activating the containing mod-
ule, called a team, at runtime) . Combining both kinds of bindings 
realizes true delegation. Problems relating to split identity are 
solved by two translations, which are automatically inserted at the 
necessary program locations: so-called lowering substitutes a base 
for a given role, and lifting looks up a role for a given base [12]. 
A related approach turning the ROP into a native language con-
struct is taken by P OWER JAVA [3]. 
7. CONCLUSION 
While the R OLE OBJECT  pattern [4] describes a widely accepted 
solution for the problem of representing objects with roles [1, 11, 
16, 20, 21, 22] in class-based ob ject-oriented systems, we have 
found that its technical requirem ents, especially concerning the 
necessary delegation, seriously question its practical utility. By 
separating shared state and identi ty from the sharing of behaviour, 
we have managed to preserve in heritance as the native delegation 
mechanism required by role objects, allowing us to introduce a 
lightweight form of role objects. As we have shown in a system-
atic evaluation, refactoring toward s these lightweight role objects 
not only results in leaner code, but also profits from weaker pre-
conditions, leading to an increase of  applicability by a factor of 
three. 
REFERENCES   
[1] A. Albano, R. Bergamini, G. Ghelli, and R. Orsini. An object 
data model with roles. In Proc. VLDB , pp. 39–51, 1993. 
[2] C.W. Bachman and M. Daya. The role concept in data mod-
els. In: Proc. of VLDB , pp. 464–476, 1977. 
[3] M. Baldoni, G. Boella, and L. W.N. van der Torre. Interaction 
between Objects in powerJava. Journal of Object Technology  
6(2), 2007. 
[4] D. Bäumer, D. Riehle, W. Siberski, and M. Wulf, M. The 
role object pattern. In Proc. of PLoP , 1997. 
[5] K. Chandra Sekharaiah, D Jana ki Ram. Object Schizophrenia 
Problem in Object Role System Design. In Proc. of OOIS  
2002, pp. 494–506, 2002. 
[6] Eclipse JDT Refactori ng. http://www. eclipse.org 
[7] M. Fowler. Refactoring: Improving the Design of Existing 
Code . Addison-Wesley 1999. [8] Fowler, M. Dealing with Roles . 
http://martinfowler.com/apsupp/roles.pdf  
[9] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design 
Patterns — Elements of Reusable Software . Addison-Wesley 
1995. 
[10] W.G. Griswold and D. No tkin. Automated assistance for 
program restructuring. ACM Trans. Softw. Eng. Methodol . 
2(3):228–269, 1993. 
[11] G. Gottlob, M. Schrefl, and B. Röck. Extending Object-
Oriented Systems with Roles. ACM Trans. Inf. Syst.  14(3): 
268–296, 1996. 
[12] S. Herrmann. A precise mode l for contextual roles: The pro-
gramming language Ob ject Teams/Java. Applied Ontology  
2(2):181–207, 2007. 
[13] R.E. Johnson and J.M. Zweig. Delegation in C++. The Jour-
nal of Object-Oriented Programming  , 4(7):31–34, 1991. 
[14] H. Kegel and F. Steimann. Sy stematically refactoring inheri-
tance to delegation in Java. In Proceedings of the 30th ICSE , 
pp. 431–440, 2008. 
[15] J. Kerievsky. Refactoring to Patterns . Pearson Higher Educa-
tion, 2004. 
[16] B.B. Kristensen. Object-oriented modeling with roles. In 
Proc. of OOIS '95 , pp. 57–71, 1996. 
[17] H. Lieberman. Using prot otypical objects to implement 
shared behavior in object -oriented systems. In Proc. of 
OOPSLA , pp. 214–223, 1986. 
[18] L. Mikhajlov, E. Sekerinski. A study of the fragile base class 
problem. in: Proc. of ECOOP  (1998) 355–382. 
[19] W. Opdyke. Refactoring Object-O riented Frameworks . 
Ph.D. thesis, University of Illinois at Urbana-Champaign, 
1992. 
[20] B. Pernici. Objects with roles. In SIGOIS Bulletin , 11(2/3), 
pp. 205–215, 1990. 
[21] E. Sciore. Object specialization. ACM Transactions on In-
formation Systems  7(2):103–122, 1989. 
[22] F. Steimann. On the representa tion of roles in object-oriented 
and conceptual modelling. Data Knowl. Eng . 35(1):83–106, 
2000. 
[23] F. Steimann. Role = Inte rface: A merger of concepts. Journal 
of Object-Oriented Programming  14(4):23–32, 2001. 
[24] Steimann, F. The Infer Type Refactoring and its Use for In-
terface-Based Programming. Journal of Object Technology  
6(2), 2007. 
[25] L.A. Stein. Delegation is inheritance. In Proc. of  OOPSLA ,  
pp. 138–146, 1987. 
[26] F. Tip, A. Kiezun, and D. Bäumer. Refactoring for generali-
zation using type constraints. In Proc. of OOPSLA , 13–26, 
2003. 
[27] D. Ungar and R.B. Smith. Se lf: The power of simplicity. In 
Proc. of OOPSLA , pp. 227–242, 1987. 
 
 
 450