Modeling the HTML DOM and Browser API
in Static Analysis of JavaScript Web Applications
Simon Holm Jensen∗
Aarhus University
simonhj@cs.au.dkMagnus Madsen*
Aarhus University
magnusm@cs.au.dkAnders Møller*
Aarhus University
amoeller@cs.au.dk
ABSTRACT
Developers of JavaScript web applications have little tool
support for catching errors early in development. In com-
parison, an abundance of tools exist for statically typed
languages, including sophisticated integrated developme nt
environments and specialized static analyses. Transferri ng
such technologies to the domain of JavaScript web appli-
cations is challenging. In this paper, we discuss the chal-
lenges, which include the dynamic aspects of JavaScript and
the complex interactions between JavaScript, HTML, and
the browser. From this, we present the ﬁrst static analysis
that is capable of reasoning about the ﬂow of control and
data in modern JavaScript applications that interact with
the HTML DOM and browser API.
One application of such a static analysis is to detect type-
related anddataﬂow-related programmingerrors. Wereport
on experiments with a range of modern web applications,
including Chrome Experiments and IE Test Drive applica-
tions, to measure the precision and performance of the tech-
nique. The experiments indicate that the analysis is able to
show absence of errors related to missing object properties
and to identify dead and unreachable code. By measuring
the precision of the types inferred for object properties, t he
analysis is precise enough to show that most expressions
have unique types. By also producing precise call graphs,
the analysis additionally shows that most invocations in th e
programs are monomorphic. We furthermore study the use-
fulness of the analysis to detect spelling errors in the code .
Despite the encouraging results, not all problems are solve d
and some of the experiments indicate a potential for im-
provement, which allows us to identify central remaining
challenges and outline directions for future work.
Categories andSubject Descriptors
D.2.5 [Software Engineering ]: Testing and Debugging
General Terms
Languages, Algorithms, Veriﬁcation
∗SupportedbyThe Danish Research Council for Technology
and Production, grant no. 09-064210.
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and thefull citation on the ﬁrstpage. Tocop y otherwise, to
republish, topostonserversortoredistribute tolists,re quires priorspeciﬁc
permission and/or afee.
Copyright 20XX ACM X-XXXXX-XX-X/XX/XX ...$10.00.1. INTRODUCTION
A JavaScript web application is in essence an HTML page
with JavaScript code and other resources, such as CSS style-
sheets and image ﬁles. Program execution is driven by
events in the user’s browser: the page is initially loaded, t he
user interacts with the mouse and keyboard, timeouts occur,
AJAX response messages are received from the server, etc.
The event handler code reacts by modifying the program
state and the HTML page via its DOM (Document Object
Model) and by interacting with the browser API, for exam-
ple to register new event handlers. Compared to other soft-
ware platforms, the state of the art in development of such
web applications is rather primitive, which makes it diﬃcul t
to write and maintain robust applications. Statically type d
languages, such as Java and C#, have long beneﬁted from
advancedIDEsandstaticanalysis techniqueswithrichcapa -
bilities oflocating likely programmingerrors duringdeve lop-
ment. Examples ofsuchtools include Eclipse, Visual Studio ,
FindBugs, and Klocwork. In contrast, existing tool support
for JavaScript web application development is mostly lim-
ited to syntax highlighting and primitive code completion
in IDEs, such as Eclipse, NetBeans, and Visual Studio, of-
ten combined with record/play testing frameworks, such as
Selenium, Watir, and Sahi.
The goal of our research is to develop static program
analysis techniques that can detect—or show absence of—
potential programming errors in JavaScript web applica-
tions. We focus on general errors that can be detected with-
out the use of application-speciﬁc code annotations. Exam-
ples of such errors are (1) dead or unreachable code, which
often indicates unintended behavior, (2) calls to built-in
functions with a wrong number of arguments or with ar-
guments of unexpected types, and (3) uses of the special
JavaScript value undefined (which appears when attempt-
ing to read a missing object property) at dereferences or at
function calls. The existence of the undefined value and im-
plicit type coercions in the language means that even minor
spelling errors, for example in a property name, often has
surprising consequences at runtime. With statically typed
languages, the type systems provide a strong foundation for
detecting such errors. In contrast, because of the dynamic
natureof JavaScriptweb application code, our analysis mus t
be capable of reasoning about the ﬂow of control and data
throughout the applications.
We strive to make the analysis sound, meaning that all
control ﬂow and dataﬂow that is possible in the program
being analyzed is captured by the analysis such that guar-
antees can be made about absence of errors. Also, it mustbe suﬃciently preciseandfastsuch that the user is not over-
whelmed with spurious warnings and that the analysis can
be integrated into the development cycle.
As an example, Figure 1 shows excerpts from a modern
JavaScript web application. If one wants to detect or show
absence oferrors ofthekindsdiscussedabove, astatic anal y-
sis must reason about the subtle ﬂow of control and data be-
tween theJavaScript code, the HTML code, and thebrowser
event system, as explained in the ﬁgure text.
TAJS is a program analysis tool for JavaScript [11,12]. To
this point, TAJS has been developed to faithfully model the
JavaScript language and the core library as speciﬁed in the
ECMAScript standard [4]. Most real JavaScript programs,
however, exist in the context of an HTML page and operate
in browsers where they access the HTML DOM and the
browser API, which causes considerable challenges to the
analysis of the ﬂow of control and data [18]. We now take
the step of extending TAJS to also model these aspects of
JavaScript web applications.
In summary, the contributions of this paper are the fol-
lowing:
•We discuss the key challenges (Section 2) and suggest
an approach toward modeling the JavaScript web ap-
plication platform in static analysis (Section 4). In
particular, this involves considerations about model-
ing the HTML pages and the event system.
•We show how the TAJS analysis (Section 2.2) can be
extended to accommodate for the HTML DOM and
the browser API. As result, we obtain the ﬁrst static
analysistool thatiscapableofreasoningabouttheﬂow
of control and data in JavaScript web applications.
•Through experimental evaluation we demonstrate that
our model is suﬃcient to show absence of errors and
to detect dead and unreachable code. In addition, we
evaluate the precision of the types and call graphs in-
ferredbytheanalysis(Section5). Weidentifystrengths
and weaknesses of the approaches we have taken and
suggest directions for future work (Section 7).
Several program analysis tools and techniques for Java-
Script have been developed [1,3,5–11,15,19], however, non e
of them provide a detailed model of the HTML DOM and
the browser API, although all JavaScript web applications
utilize those mechanisms. We describe connections to re-
lated work in Section 6.
2. CHALLENGES
We begin with a brief tour of the technologies involved
and explain the central challenges that exist when develop-
ing static analyses for JavaScript web applications. Expe-
rienced JavaScript programmers who are used to reasoning
“manually”about the behavior of their programs will recog-
nize the issues brought forth here.
2.1 The JavaScriptLanguage
The ﬁrst obstacle we face is the JavaScript language it-
self. JavaScript has higher-order functions and closures, ex-
ceptions, extensive type coercion rules, and a ﬂexible obje ct
model where methods and ﬁelds can be added or change
types and inheritance relations can be modiﬁed during exe-
cution. As shown by Richards et al. [18], commonly made
1http://www.chromeexperiments.com/detail/js-touch/assumptions in the research literature about JavaScript pr o-
grams are often violated by the code actually being written
by programmers, and JavaScript is described as “a harsh
terrain for static analysis”.
Implementations largely follow the ECMAScript standard
[4], however, there are subtle deviations. One such exam-
ple is that many browsers for performance reasons do not
implement the speciﬁed behavior of deleting properties of
thearguments object (as indelete arguments[0] ). An-
other example is that many browsers for security reasons do
not correctly invoke the currently deﬁned Objectfunction
when constructing objects from literals (as in x={}). Other
peculiar JavaScript features and incompatibility issues a re
discussed in the paper on JavaScript semantics by Maﬀeis
et al. [16]. One choice we must make is whether to model
the standard or one or more of the existingimplementations.
We return to this issue in Section 3.
On top of the language, ECMAScript contains a standard
library consisting of 161 functions and other objects that
all need to be modeled somehow by any tool that analyzes
JavaScript web applications. Of particular interest is the
evalfunction and its variant Function that allow dynamic
construction of program code from text strings. Reasoning
statically about the behavior of such code obviously requir es
knowledgeaboutwhichstringsmayappear. Evenso, studies
of how these constructs are used in practice indicate that
many cases are amenable to static analysis [14,17,18].
For now, we focus on the 3rd edition of ECMAScript
(ECMA-262), which is currently the most widely used ver-
sion. Supporting the more recent 5th edition requires the
analysis to also reason about getters and setters, sealed an d
frozen objects, stronger reﬂection capabilities, and the s o-
called strict mode semantics, in addition to a range of new
standard library functions.
2.2 The HTML DOMandBrowser API
The browser environment gives rise to additional chal-
lenges. The JavaScript representation of HTML documents,
CSS properties, and the event system is speciﬁed by the
W3C DOM standards2. The HTML5 speciﬁcation is cur-
rently being developed bythe WHATWG group3. Together,
these speciﬁcations contribute additional hundreds of fun c-
tions and other objects to the program state. It is well
known to all web application programmers that browsers
do not adhere to these standards. Browsers provide non-
standard functionality, and many standard features are not
supported4. In particular the event systems diﬀer between
browsers. Another problem is that no standard exists for
thewindowobject that acts as the global JavaScript object.
Incompatibilities in the underlying JavaScript interpret ers
mostly involve subtle corner cases in the language, as dis-
cussed above, and often go unnoticed by the programmers.
In contrast, incompatibilities in the browser environment s
are a major concern. When developing a program analysis,
we need to choose which of these variations to model.
A typical workaround is seen in the following function
addEvent from the Google Chrome Experiment Tetris5.
2http://www.w3.org/DOM/
3http://www.whatwg.org/
4http://www.quirksmode.org/
5http://www.chromeexperiments.com/detail/domtris/1<html>
2<head>
3<script type=’’text/javascript’’>
4window.P3D = {
5texture: null,
6g: null
7};
8
9P3D.clear = function(f, w, h) {
10var g = this.g;
11g.beginPath();
12g.fillStyle = f;
13g.fillRect(0, 0, w, h);
14}
15
16function TouchApp() {
17var _this = this;
18
19this.canvas = document.getElementById("cv");
20P3D.g = this.canvas.getContext("2d");
21//...
22
23this.mViewport = {};
24this.mViewport.w = 480;
25this.mViewport.h = 300;
26//...
27
28var tex = new Image();
29this.ipod.texture = tex;
30tex.onload = function(){ _this.start(); };
31tex.src = "20090319144649.png";
32//...
33}
34
35TouchApp.prototype = {
36start: function() {
37//...
38this.onInterval();
39},
40
41onInterval: function() {
42//...
43P3D.clear("#000",
44 this.mViewport.w,
45 this.mViewport.h);
46//...
47setTimeout(function(){
48_this.onInterval();
49}, 20);
50}
51//...
52}
53//...
54</script>
55</head>
56<body onload="void( new TouchApp() );">
57<canvas id="cv" width="480" height="300"/>
58//...
59</body>
60</html>The code at the left is an excerpt from the Google Chrome Exper i-
mentjs touch (where//...indicates omitted code). It displays a 3D
model of an iPhone and allows the user to interact with it by mo ving
the mouse. The application is written in pure JavaScript and uses
the new HTML5 canvasobject.
Obviously, many things could go wrong when programming such
an application. Three examples of correctness properties t hat the
programmer may consider are: (1) Is the parameter gon line 11
always an object with a beginPath function? If not, a runtime error
will occur when that line is executed. (2) In the call to the fu nction
fillRect on line 13, are the arguments always numeric? If not, the
function call will not have the desired eﬀect. (3) Is the func tion
P3D.clear on line 9 reachable in some execution? If not, presumably
there is an error in the control ﬂow.
To catch such errors – or to show their absence, a static analy sis
must know about the ﬂow of control and data in the program. In
brief, the browser ﬁrst loads the HTML page and executes the t op-
level JavaScript code and loadevent handlers. It then executes other
event handlers for user input, timeouts, and other events th at occur.
In this example application, the code on line 56 in the onload
attribute of the bodyelement creates a new TouchApp object and
invokes its constructor function deﬁned on line 16. This fun c-
tion looks up the JavaScript DOM object representing the can vas
element on line 19 and then stores a reference to its associat ed
CanvasRenderingContext2D in thegproperty of theP3Dobject on
line 20. Note that P3Dis a globally available object. Next, on
line 28, the constructor function creates a new Imageobject, sets
itsloadevent handler to the startfunction and ﬁnally sets its src
property. The browser loads the requested image and ﬁres the load
handler. Thestartfunction, deﬁned on line 36, does some work
and then invokes the onInterval function. This function, deﬁned
on line 41, calls P3D.clear with appropriate arguments taken from
thethis.mViewport object. Finally, using a call to setTimeout , it
registers itself to be invoked by the browser 20ms later.
By automating this kind of reasoning, a static analysis can d etect
likely errors in the application code. Analyzing a complex J avaScript
program, such as this one, requires a precise model of the Jav aScript
language, the HTML DOM, and the browser API. For this appli-
cation, our analysis tool is capable of showing in 9 seconds a mong
many other properties that (1) the variable gdoes always hold an ob-
ject with abeginPath function, (2) the fillRect function is always
called with numeric arguments, and (3) the function P3D.clear is
likely to be reachable. In addition, the analysis reports th at 98.9% of
all property access operations are guaranteed free from TypeError ex-
ceptions caused by dereferencing undefined ornulland that all calls
to browser API functions are given arguments of meaningful t ypes.
More statistics for the unabridged experiment is in Section 5.
Figure 1: Excerpts from the Google Chrome Experiment JS Touch1.
function addEvent(el, event, handler) {
if (el.addEventListener)
el.addEventListener(event, handler, false);
else if (el.attachEvent)
el.attachEvent("on" + event, handler);
}
Reasoning statically about the behavior of such code re-
quires not only modeling of diﬀerent browsers but also ﬂow
sensitivity (i.e. taking statement order into account) and
even path sensitivity (i.e. considering the branch conditi ons)
to see that the calls to addEventListener andattachEvent
do not causeTypeError exceptions.Since all execution is driven by events, the analysis must
also model the event system, which includes the dynamic
registration and removal of diﬀerent kinds of event handler s,
as in theaddEvent function above, the event bubbling and
capturing mechanism, and the event object properties that
depend on the speciﬁc kind of event. The event handlers
work as callbacks, which often leads to fragmented code
with unclear ﬂow of control that the static analysis must
resolve. A small example is seen in the Chrome Experiment
Aquarium6(abbreviated for presentation):
6http://www.chromeexperiments.com/detail/aquarium/function mmouse(event) {
mousex=event.pageX;
mousey=event.pageY;
}
function work() {
var dx=mousex-pesti[x].x;
var dy=mousey-pesti[x].y;
//...
}
setInterval(work,10);
The functionmmouse, which is elsewhere registered as an
event handler, stores information about the event in two
global variables, mousexandmousey, that are read in an-
other event handler, work. Unless these two variables are
properly initialized, dxanddywill get the special value NaN
if theworkfunction happens to be triggered before mmouse,
which will likely result in an error later in the execution.
ForeventhandlersdeﬁnedasHTMLattributes,theHTML
documentstructureinterfereswiththeexecutionscopecha ins
that are used when resolving variables. If an event handler
deﬁned literally as an attribute in an HTML element is trig-
gered, the scope chain includes all the DOM objects that
make up the path from the HTML element to the root of the
document. This means that dataﬂow in the JavaScript code
in general cannot be analyzed separately from the HTML
code. The following example illustrates this mechanism:
<script type=’’text/javascript’’>
var src = "foo.png";
</script>
<img src="bar.png" onclick="alert(src)"/>
The value ofsrcinside theonclick event handler is that
of thesrcattribute of theimgelement, notfoo.png as one
might have expected.
Many properties in the ECMAScript native objects have
special attributes, such as ReadOnly , which also must be
accounted for unless sacriﬁcing either soundness or preci-
sion. Likewise, many DOM objects behave diﬀerently from
ordinary objects. As an example, a new formelement is cre-
ated withdocument.createElement(’form’) , not withnew
HTMLFormElement although allformelements inherit from
HTMLFormElement.prototype .
Besides the extent and the variations of browser environ-
ments, other concerns when developing a static analysis too l
relate to the prevalence of nontrivial built-in setters, th at is,
assignment operations that involve complex conversions or
otherside-eﬀects. Forexample, writingtothe onclick prop-
ertyofanHTMLelementobject causesastringtobetreated
as event handler code. Another example is the use of value
correspondence where HTML element attributes are repre-
sented in multiple JavaScript objects. For instance, the src
attribute value of an imgelement appears both directly as a
property of theimgelement object and indirectly as a prop-
erty of an object that can be reached via the attributes
property of theimgelement object. These are essentially
aliases (although the former is always an absolute URL even
when the latter is a relative URL), and modiﬁcations to one
also aﬀect the other, much like the connection between or-
dinary JavaScript function parameters and the arguments
object. Consider also the window.location property, which
holds aLocation object. Assigning a new URL string to
this property causes the browser to go to that URL after
the current event handler and various unload handlers have
been executed. As yet another example, writing a string to
the (also nonstandard but widely used) innerHTML property
of an element object causes thestring tobe parsed as HTMLand converted to a DOM object structure, which then re-
places the element contents.
A related issue is the element lookup mechanism, which
provides support for getElementById and related functions.
Ifan element with an idattribute is inserted into theHTML
document,itisautomatically addedtothebrowser’s elemen t
ID table for quick lookup. Similarly, documents.images au-
tomatically contains references to all images in the curren t
HTML document.
2.3 ApplicationDevelopmentPractice
Further complications are introduced by common applica-
tion development practice. Although JavaScript is an inter -
preted language (perhaps with JIT compilation, transpar-
ently to the programmer) in practice it makes sense to dis-
tinguish between“source code”and“executable code”. The
reason is that JavaScript web application code is often sub-
jected to miniﬁcation (and sometimes also obfuscation ) to
reduce the code size and thereby make the applications load
faster. A related trick is lazy loading where the applications
are divided into parts that are loaded incrementally using
AJAX or dynamically constructed scriptelements.
An example of lazy loading using a dynamically created
scripttag occurs in the Google Analytics7tool for collect-
ing visitor statistics:
<script type="text/javascript">
(function() {
var ga = document.createElement(’script’);
ga.type = ’text/javascript’;
ga.async = true;
ga.src =
(’https:’ == document.location.protocol ?
’https://ssl’ :
’http://www’) + ’.google-analytics.com/ga.js’;
var s = document.getElementsByTagName(’script’)[0];
s.parentNode.insertBefore(ga, s);
})();
</script>
Since our aim is to develop an analysis tool that can
help the programmers catch errors during development, we
choose tofocusonthesourcecodestage, astheprogrammers
see the application before these techniques are applied. Th is
means that we in many cases sidestep the issue of analyzing
dynamically generated code. It also means, however, that
the analysis tool we develop is not designed to be used for
all the JavaScript web application code that is immediately
available on public web sites, such as Gmail or Oﬃce Web
Apps.
Manyapplications buildonlibraries thatalleviate browse r
incompatibilityproblems, provideclass-like abstractio nsand
advanced GUI widgets and eﬀects, and simplify common
tasks, such as navigation in the HTML DOM structures and
AJAX communication. This includes general libraries, for
example jQuery, MooTools, and Prototype, but also a myr-
iad of more specialized libraries, such as plugins for jQuer y.
From a static analysis point of view, libraries such as these
in many cases make it diﬃcult to track ﬂow of control and
data. By providing their own abstractions on top of event
handling and DOM objects, a high degree of context sensi-
tivity and detailed modeling of heap structures may be re-
quired by the analysis. An example of a challenging library
construct is the$function in jQuery, which has very diﬀer-
ent behavior depending on whether it is passed a function,
an HTML string, a CSS string, or a DOM element.
7http://www.google.com/analytics/3. THETAJS ANALYZER
WebasethecurrentworkontheTAJSanalysistool thatis
described in previous publications [11,12]. TAJS is a whole -
program ﬂow analysis that supports the full JavaScript lan-
guage as deﬁned in the ECMA-262 speciﬁcation [4], includ-
ing the entire standard library except eval. The analysis is
designed to be sound (although working with a real-world
language andhavingnostandardizedformal semanticsofthe
language nor of the HTML DOM and browser API, sound-
ness is not formally proven). To this point, we do not con-
sider the deviations from the ECMAScript standard that
are discussed in Section 2.1, the reason being that these de-
viations are mostly corner cases that are irrelevant to most
applications we have studied. If the need should arise, for a ll
the deviations we are aware of, it is only a matter of making
minor adjustments to the analysis tool.
TAJS is based on the classic monotone framework [13]
using a highly specialized analysis lattice structure. The
lattice is based on constant propagation for all the possibl e
primitive types of JavaScript values. In addition, the lat-
tice includes call graph information, allowing on-the-ﬂy c on-
struction of the call graph to handle higher-order function s.
It also contains a model of the heap based on allocation site
abstraction extended with recency abstraction [2].
The analysis is object sensitive, meaning that it distin-
guishesbetweencallingcontextswithdiﬀerentvaluesof this.
It is also ﬂow sensitive, meaning that it distinguishes be-
tween diﬀerent program points (maintaining separate ab-
stract states for diﬀerent program points), and it has a sim-
ple form of path sensitivity to distinguish between diﬀeren t
branches of conditionals.
On top of this, lazy propagation is used to ensure that
only relevant parts of the abstract states are propagated,
which improves both performance and precision [12].
Altogether, this foundation largely addresses the chal-
lenges that are directly related to the ECMAScript language
speciﬁcation.
4. MODELINGTHEHTML DOMAND
BROWSER API
We now present our approach to extending the analysis to
accommodate for the HTML DOM and the browser API.
Regarding the multitude of APIs supported by diﬀerent
browsers that exist, we choose to model the parts that we
believe is most widely used: the DOM Core, DOM HTML,
and DOM Events modules of the W3C recommendations
(Level 2, plus selected parts of Level 3), the essential part s
ofwindow8and related nonstandard objects, and the canvas
and related objects from WHATWG’s HTML5 (as of Jan-
uary 2011). The latter allows us to test the analysis on
web applications that exploit cutting edge functionality s up-
ported by the newest browsers.
In total, the extensions comprise around 250 abstract ob-
jects with 500 properties and 200 transfer functions. To giv e
an impression of the complexity, Figure 2 shows a small part
of the object hierarchy of the initial abstract state. Each
node represents an abstract object with its associated prop -
erties and functions, and the edges represent internal pro-
totype links. The symbols @and*in the names indicate
whether the abstract objects represent single or multiple
concrete objects.
8https://developer.mozilla.org/en/DOM/window4.1 HTML Objects
The HTML page andresources linkedtofrom thepage de-
ﬁne not only the program code but also the initial state for
the execution, including the HTML document object struc-
ture, element lookup tables, and event handlers.
At runtime, each HTML element gives rise to a range of
JavaScript objects, and new HTML elements can be cre-
ated dynamically. We need a bounded representation to
ensure that the program analysis terminates (technically,
the analysis lattice must have ﬁnite height), thus abstrac-
tion is necessary. A simple approach is to represent all
HTML objects as one abstract object. This is essentially
what is done in other program analyses [7,8] that perform
a less detailed analysis than what we aim for. To preserve
the inheritance relationships between the DOM objects, we
choose an abstraction where all constructor objects and pro -
totype objects are kept separate and that distinguishes be-
tween HTML elements of diﬀerent kinds but where multi-
ple elements of the same kind are merged. As an example,
theHTMLInputElement abstract object (see Figure 2) mod-
els all HTMLinputelements. It has properties such as
accessKey andchecked, which in the analysis have types
StringandBoolean, respectively. The abstract object in-
herits fromHTMLInputElement.prototype . This object con-
tains common functionality, such as the focusfunction,
shared by allHTMLInputElement objects. Looking further
up the prototype chain we ﬁnd HTMLElement.prototype ,
Element.prototype and ﬁnallyNode.prototype , which de-
ﬁne shared functionality of increasingly general characte r.
Other types of HTML elements, such as formorcanvasel-
ements are similarly modeled by separate abstract objects.
This approach respects the inheritance relationships and i t
smoothly handles programs that dynamically modify the
central DOM objects, for example by adding new methods
to the prototype objects.
Tomodel theelementlookup mechanism(see Section 2.2),
we extend TAJS’s notion of abstract states with appropriate
maps, e.g. from element IDs to sets of abstract objects. The
initial abstract state is populated with the IDs that occur
in the HTML page. If the HTML page contains an input
element with an attribute id="foo" then the ID map in the
abstract state maps footo theHTMLInputElement abstract
object. These maps are updated during the dataﬂow analy-
sis if newidattributes are inserted into the page. As result,
getElementById and related functions are modeled soundly
and with reasonable precision.
4.2 Events
As discussed in Section 2.2, the analysis must be extended
to model dynamic registration, triggering, and removal of
event handlers. This can be done with various levels of pre-
cision. We describe our choices in the following and evaluat e
the resulting system in Section 5.
First, we extend TAJS’s abstract states again, this time
with a collection of set of references to abstract objects
that model the event handler function objects. To distin-
guish between diﬀerent kinds of events and eventobjects, we
maintain one such set for each of the following categories of
events:load,mouse,keyboard,timeout,ajax, andother. Ob-
ject references are added to these sets either statically, d ue
to presence of event attributes ( onload,onclick, etc.) in
the HTML page, or dynamically when encountering calls to
addEventListener orassignments toeventattributesduring*CanvasRenderingContext2D
fillStyle
font
lineCap
lineJoin
lineWidth
miterLimit
...@CanvasRenderingContext2D.prototype
arc()
arcTo()
beginPath()
bezierCurveTo()
canvas
clearRect()
...
*HTMLBodyElement
aLink
background
bgColor
link
text
...@HTMLBodyElement.prototype
*HTMLCanvasElement@HTMLCanvasElement.prototype
getContext()
height
toDataURL()
width
*HTMLDocument
URL
anchors
applets
body
cookie
domain
...@HTMLDocument.prototype
close()
getElementsByClassName()
getElementsByName()
open()
write()
writeln()
*HTMLFormElement
acceptCharset
action
elements
enctype
length
...@HTMLFormElement.prototype
reset()
submit()
*HTMLImageElement
align
alt
border
complete
height
hspace
...@HTMLImageElement.prototype
*HTMLInputElement
accept
accessKey
align
alt
checked
defaultChecked
...@HTMLInputElement.prototype
blur()
click()
focus()
select()*KeyboardEvent
altKey
ctrlKey
keyIdentifier
keyLocation
metaKey
repeat
...@KeyboardEvent.prototype
DOM_KEY_LOCATION_JOYSTICK
DOM_KEY_LOCATION_LEFT
DOM_KEY_LOCATION_MOBILE
DOM_KEY_LOCATION_NUMPAD
DOM_KEY_LOCATION_RIGHT
DOM_KEY_LOCATION_STANDARD
...
*MouseEvent
altKey
button
clientX
clientY
ctrlKey
metaKey
...@MouseEvent.prototype
initMouseEvent()*MutationEvent
attrChange
attrName
newValue
prevValue
relatedNode@MutationEvent.prototype
ADDITION
MODIFICATION
REMOVAL
initMutationEvent()
*WheelEvent
deltaMode
deltaX
deltaY
deltaZ@WheelEvent.prototype
DOM_DELTA_LINE
DOM_DELTA_PAGE
DOM_DELTA_PIXEL
initWheelEvent()
initWheelEventNS()Object.prototype
@Document
doctype
documentURI
domConfig
inputEncoding
location
strictErrorChecking
...@Document.prototype
adoptNode()
createAttribute()
createAttributeNS()
createCDATASection()
createComment()
createDocumentFragment()
...@Node.prototype
ATTRIBUTE_NODE
CDATA_SECTION_NODE
COMMENT_NODE
DOCUMENT_FRAGMENT_NODE
DOCUMENT_NODE
DOCUMENT_TYPE_NODE
...
@Element.prototype
getAttribute()
getAttributeNS()
getAttributeNode()
getAttributeNodeNS()
getElementsByTagName()
getElementsByTagNameNS()
...
@HTMLElement.prototype
attributes
className
clientHeight
clientWidth
dir
getElementsByClassName()
...@UIEvent.prototype
detail
initUIEvent()
view@Event.prototype
AT_TARGET
BUBBLING_PHASE
CAPTURING_PHASE
bubbles
cancelable
currentTarget
...@Navigator
appName
appVersion
product
userAgent
@ReadystateEvent
bubbles
cancelable
responseText
target@ReadystateEvent.prototype@Window.history
back()
forward()
go()
length@Window.location
assign()
hash
host
hostname
href
pathname
...@Window.screen
availHeight
availLeft
availTop
availWidth
colorDepth
...
Figure 2: An excerpt from the HTML object hierarchy.
theanalysis. Thismeansthattheabstractstatesalwayscon -
tain an upper approximation of which event handlers exist.
Note that we choose to abstract away the information about
where in the HTML DOM tree the event handlers are reg-
istered (i.e. thecurrentTarget of the events). This allows
us to ignore event bubbling and capturing. Similarly, we
ignore removal of event handlers ( removeEventListener ).
These choices may of course aﬀect precision, but analysis
soundness is preserved.
Next, we need to model how events are triggered. A
JavaScript web application is executed by ﬁrst running the
top-level code and then, until the page is unloaded, running
event handlers as reaction to events. Each event handler is
executed until completion, without being interrupted when
new events occur.
In TAJS, JavaScript program code is represented by ﬂow
graphs, which are graphs where nodes correspond to primi-
tive instructions and edges correspond to control ﬂow
(see [11]). We have considered diﬀerent approaches to incor -
porating the event handler execution loop after the top-lev el
code in the ﬂow graph:
•As a single loop where all event handlers in the cur-
rent abstract state are executed non-deterministically.
This is a simple and sound approach, but it does not
maintain the order of execution of the individual event
handlers.
•Using a state machine to model the currently regis-
tered event handlers. This is a considerably more com-
plex approach, but it can in principle more precisely
keep track of the possible order of execution of the
event handlers.
Through preliminary experiments we have found for the cor-
rectness properties that we focus on, the execution order of
event handlers is often not crucial for the analysis precisi on.
However, we found that it is important to model the fact
thatloadhandlers are executed before the other kinds of
event handlers. For this reason, we model the execution ofFigure 3: Modeling events in the ﬂow graphs.
event handlers as shown in Figure 3. (To simplify the illus-
tration we here ignore ﬂow of runtime exceptions.) The ﬂow
graph for the top-level JavaScript is extended to include tw o
non-deterministic event loops, ﬁrst one for the loadevent
handlers and then one for the other kinds.
If only a single loadhandler is registered (and it is not
subsequently removed) then we know that it is deﬁnitely ex-
ecuted once, and thus we can eﬀectively remove the dashed
edges. This increases precision because otherwise all stat e
initialized by loadhandlers would be modeled as maybe ab-
sent.
When triggering event handlers, we exploit the fact that
the abstract states distinguish between the diﬀerent event
categories listed above. This allows us to model the event
objects appropriately, for example using the abstract ob-
jectKeyboardEvent (see Figure 2) to model keyboard event
objects. Moreover, the analysis abstraction used in TAJS
already has a ﬁne-grained model of scope chains, so it is
relatively easy to incorporate the HTML element objects to
take the issues regarding scope chains (see Section 2.2) int o
account.4.3 Special ObjectProperties
As discussed in Section 2.2, writes to certain object prop-
erties, such asonclick,src, andinnerHTML , have special
side-eﬀects. The TAJS analysis infrastructure convenient ly
supports specialized transfer functions for such operatio ns.
This allows us to trigger the necessary modiﬁcations of the
abstract state when property write operations occur for cer -
tain combinations of abstract objects and property names.
With this, we can easily handle code such as the following
that dynamically constructs an imgelement and sets the id
andonclick properties, which aﬀects not only the imgob-
ject itself but also the element ID lookup map and the event
handler set:
var i = document.createElement("img");
f.id = "myImage";
f.onclick = function {...}
With this approach, the abstractions made elsewhere in
the analysis can in principle lead to a cascade of spurious
warnings. If the analysis detects a property write opera-
tion that involves one of the relevant objects but where the
property name is unknown due to abstraction, a fully sound
analysis would be required to trigger all the possible spe-
cialized transfer functions, which could cause a considera ble
loss ofanalysis precision. Instead, if thissituation occu rs, we
choose to sacriﬁce soundness such that the analysis simply
emits a general warning and skips the modeling of the spe-
cial side-eﬀects for that particular property write operat ion.
In our experiments (see Section 5), this occurs 0 times, indi -
cating that the analysis is generally precise enough to avoi d
the problem.
4.4 DynamicallyGenerated Code
We extend TAJS to support certain common cases involv-
ingevaland the related functions Function ,setTimeout ,
andsetInterval . Programmers who are not familiar with
higher-order functions often simulate them by using string s
instead, such as in this example from the program Fractal
Landscape9:
animInterval = setInterval("animatedDraw()", 100);
This code works because the function setInterval sup-
ports being called with a string that will get evaluated in
the global scope at the speciﬁed intervals. To accommodate
for this, TAJS recognizes the syntax of a string consisting
of a simple function call. The analysis transfer function fo r
setInterval collects not only function objects but also such
strings that represent event handler functions. When mod-
eling the triggering of event handlers, the latter function s
are then looked up in the global scope.
An often used application of evalis to parse JSON data
receivedusingAJAX.JSONdatadescribessimpleJavaScript
object structures that cannot contain functions. TAJS can
beconﬁguredtoassume thatstringvaluesthatare readfrom
AJAX connections contain only JSON data. We model this
with the special dataﬂow value JSONString . If this abstract
value is passed to eval, the analysis knows that no side-
eﬀects can happen, so the result can be modeled using an
abstract value consisting of a generic abstract object and
unknown primitive values.
9http://10k.aneventapart.com/Entry/60
Figure 4: The TAJS analysis plug-in for Eclipse,
reporting a programming error and highlighting the
type inferred for the selected expression.
5. EVALUATION
We have extended the pre-existing TAJS analysis tool ac-
cording to Section 4. The tool is implemented in Java and
uses the JavaScript parser from the Mozilla Rhino project10.
The new extensions amount to 7,500 lines of code on top of
the existing 21,000 lines (excluding Rhino). Separately, t he
analysis is integrated into the Eclipse IDE as a plug-in that
allows the programmer to view various aspects of the anal-
ysis results, as demonstrated in Figure 4.
5.1 Research Questions
With the implementation, we consider the following re-
search questions regarding the quality of the analysis:
Q1We wish to study the ability of the tool to detect pro-
gramming errors of the kinds discussed in Section 1.
Given that we do not expect many errors in the bench-
mark programs that presumable are thoroughly tested
already, one way to study the analysis precision is to
ask: To what extent can the analysis show the ab-
sence of errors in real programs? Since the analysis
is designed to be sound (however see Section 4.3), ab-
sence of a warning from the tool can be interpreted as
absence of an error in the program being analyzed.
Q2For programs with errors (again, of the kinds discussed
in Section 1), can the analysis help the programmer
ﬁnd the errors? Speciﬁcally, are the warning messages
produced by the tool useful toward leading the pro-
grammer to the source of the errors?
Q3Havingagoodapproximationofthecallgraphofapro-
gram is a foundation for other potential applications,
such as program comprehension or optimization. This
leads to the question: How precise is the call graph
inferred by the analysis?
Q4Similarly to the previous question, how precise are the
inferred types?
Q5Does the analysis succeed in identifying dead or un-
reachable code? In some situations, dead or unreach-
10http://www.mozilla.org/rhinoable code is unintended by the programmer and hence
indicates errors. The ability of the analysis tool to de-
tect such code can in principle also be used to reduce
application code size before deployment.
5.2 Benchmark Programs
Our benchmark programs are drawn from three diﬀerent
sources: Chrome Experiments11,Internet Explorer 9 Test
Drive12and the 10K Apart Challenge13. Chrome Experi-
ments consist of JavaScript web applications that demon-
strate the JavaScript features of the Chrome browser. De-
spite the name, the majority of these applications can be
executed in any modern browser. Most of the applications
use the new HTML5 canvaselement to create graphics in
various ways including games and simulations. Internet Ex-
plorer 9 Test Drive is a collection of applications written t o
test and demonstrate features of the newest version of the
Internet Explorer browser. We exclude applications that
contain no or very little JavaScript code or rely on Flash or
other browser plug-ins. The 10K Apart Challenge collection
consists of JavaScript web applications that are less than
10KB in size including code and markup.
The programmers of some of the 10K Apart Challenge
applications have applied evalcreatively to reduce the code
size in ways that we believe are not representative of or-
dinary JavaScript web applications. For this reason, we
disregard applications that syntactically use evalin other
ways than those covered in Section 4.4. Moreover, analyz-
ing applications that involve large libraries, such as jQue ry,
MooTools, and Prototype, is particularly challenging for t he
reasons discussed in Section 2.3. At present, we limit our
level of ambition to applications that do not depend on such
libraries. The applications we thereby exclude can form an
interesting basis for future work on static analysis in rela tion
toevalor libraries.
The resulting collection of 53 JavaScript web applications
is listed in Table 1 and available at http://www.brics.
dk/TAJS/dom-benchmarks . In the table, the columns LOC,
BB, and Time show the number of lines of code (pretty-
printed and including HTML), the number of basic blocks
of JavaScript code, and the analysis time (running on a
2.53Ghz Mac OS X computer with 4GB of memory). Dy-
namically generatedcode of thekinddiscussed inSection 4. 4
appears in 17% of the applications. All the applications in-
volve HTML and the event system, so none of them could
be analyzed with TAJS before the new extensions described
in this paper.
5.3 Experiments andResults
We address each research question, Q1–Q5, in turn with
experiments and evaluation.
For Q1, we focus on the following kinds of likely errors:
•Invoking a non-function value as a function.
•Accessing a property of the special values undefined
ornull.
•Reading an absent object property using the ﬁxed-
property notation (we here ignore operations that use
thenotationfordynamicallycomputedpropertynames).
11http://www.chromeexperiments.com/
12http://ie.microsoft.com/testdrive/
13http://10k.aneventapart.com/The ﬁrst two cause TypeError exceptions; the third yields
the valueundefined . Technically, these situations are not
necessarily errors, but they are rarely intended by the pro-
grammer. One exception is that absent properties may ap-
pear in browser feature detection code, in which case the
analysiscanhelpensuringthatthecodeworksforthebrowse r
being modeled.
For each error category we measure the percentage of ﬂow
graph nodes for which TAJS decides not to issue a warning
of the particular kind. The results are shown in the three
columns labelled CF, PAandFPU in Table 1, corresponding
to the three kinds of likely errors. We see that TAJS is
able to show absence of these particular kinds of errors for
most of the program code, in many cases more than 90%
of the places in the code where the errors could potentially
occur. There are a few outliers that get lower results: Both
TetrisandMinesweeper rely onmulti-dimensional arrays for
most of their state, which leads to imprecision in property
reads. Complex object models, such as in the Raytracer
benchmark, are also the cause of some imprecision.
As we do not expect our benchmarks to contain any of
the error conditions listed above, we answer Q2 by intro-
ducing errors into the benchmark programs at random. We
simulate spelling errors made by the programmer by pick-
ing a random read or write property operation that uses the
ﬁxed-property notation (i.e. the .operator) and replacing
the property name with a diﬀerent one. For each bench-
mark, we run the analysis repeatedly and manually inspect
whether each spelling error results in a warning by the anal-
ysis tool and how“useful”this warning is. We measure use-
fulness by two criteria: the source location of the warning
that is issued should be close to where the error is inserted,
and the warning should be prominent, i.e. appear near the
top in the list of analysis messages.
This process has been carried out for a random subset
of our benchmark programs. All show a common pattern:
Spelling errors at read operations are reliably detected wi th
a warning that appears at the top of the list of analysis mes-
sages. Not surprisingly, spelling errors introduced at wri te
operations have more diverse consequences, as any warning
will only occur when the program later attempts to read the
property that was aﬀected. Furthermore, errors introduced
in connection to side-eﬀects that are not modeled by TAJS,
such as the DOM property style, are often not detected.
We present the results for the Mr. Potato Gun benchmark
as a representative example. We analyzed it 50 times with
a diﬀerent spelling error introduced each time. In 84% of
the cases the error resulted in one or more warnings. Of
the errors introduced, 7 were in write operations and 43
in read operations. Only one of the write operation errors
was detected, resulting in the warning ReferenceError,
reading absent property: (computed name) , which is a
high-priority warning that is issued for the location where
the program tries to read the property that was misspelled.
For the read operations, each error was reported as a warn-
ing such asReferenceError, reading absent property:
AQissued for the exact source location of the error.
These experiments indicate that the information obtained
by the analysis can be useful for detecting spelling errors
in the program code, but a more thorough investigation is
necessary to give a solid answer to Q2.
For Q3 we wish to evaluate the precision of the computed
call graph. This is measured by calculating the ratio of callLOC BBCF PAFPU UFDC MC ATSTime
3D Demo 12051770 99.2 97.9 98.9125/58 7100.0% 1.18.0s
Another World 14771437100.0 99.3 98.3 45/0 0100.0% 1.320.7s
Apophis 11401319100.0 80.4 80.4 58/0 0100.0% 1.116.3s
Aquarium 16615193.7 87.6 72.8 9/0 0100.0% 1.33.2s
Bing-Bong 11481176100.0 87.9 92.5 66/0 2100.0% 1.117.9s
Blob 596748100.0 95.6 97.4 37/2 19100.0% 1.06.4s
Bomomo 29053885 80.6 96.3 61.2 170/8 10100.0% 1.357.1s
Breathing Galaxies 10110194.7100.0 91.3 5/0 0100.0% 1.01.3s
Browser Ball 43477199.0 97.7 98.1 32/11 0100.0% 1.04.2s
Burn Canvas 180207100.0 97.7100.0 12/0 0100.0% 1.10.9s
Catch It 20720097.2 86.0 98.6 11/0 0100.0% 1.13.3s
Core 566611100.0 98.7 98.4 23/1 10100.0% 1.05.6s
JS Touch 1452 762100.0 98.9 98.1 48/8 9100.0% 1.15.8s
Kaleidoscope 24933498.9 88.6 82.1 14/1 3100.0% 1.16.1s
Keylight 73179199.4 96.1 98.7 37/0 24100.0% 1.07.4s
Liquid Particles 253205100.0 98.5100.0 11/4 2100.0% 1.01.8s
Magnetic 415339100.0 95.5100.0 19/0 1100.0% 1.04.1s
Orange Tunnel 102133100.0 80.3100.0 7/1 0100.0% 1.12.6s
Plane Deformations 552514100.0 100.0 95.1 17/0 5100.0% 1.51.5s
Plasma 204228100.0 100.0 100.0 9/0 2100.0% 1.11.6s
Raytracer 13801515 87.2 93.7 55.5 78/24 3390.1% 1.320.6s
Starﬁeld 23139398.7 79.0 87.6 21/6 2100.0% 1.22.9s
Tetris 82780395.1 79.6 58.8 39/4 2100.0% 1.89.7s
Trail 212166100.0 98.0 98.2 10/0 0100.0% 1.012s
Voronoi 5251066100.0 78.8 99.7 70/7 1099.5% 1.110.5s
Water Type 309266100.0 95.0 97.2 14/0 0100.0% 1.11.9s
Asteroid Belt 319707100.0 94.6 97.0 27/5 30100.0% 1.13.1s
Browser Flip 507324100.0 88.5 97.6 10/0 1100.0% 1.13.2s
FishIE 33671799.4 96.0 95.5 19/2 30100.0% 1.03.3s
Flying Images 589497100.0 97.5 91.8 33/0 0100.0% 1.03.9s
Mr. Potato Gun 8171015 98.7 97.6 95.0 31/1 12100.0% 1.17.8s
10k World 439930100.0 86.9 91.4 47/2 3100.0% 1.115.1s
3D Maker 427773100.0 67.3 70.5 29/3 0100.0% 1.210.3s
Attractor 44569697.0 92.3 91.2 34/0 1100.0% 1.35.8s
Defend Yourself 51760194.7 78.6 90.1 31/0 0100.0% 1.17.9s
Earth Night Lights 129245100.0 100.0 100.0 14/0 0100.0% 1.01.1s
Filterriﬁc 69799596.5 86.7 72.3 55/0 499.0% 1.229.8s
Flatwar 44468599.2 97.4 93.6 19/1 0100.0% 1.16.9s
Floating Bubbles 381693100.0 89.9 99.7 39/6 23100.0% 1.16.4s
Fractal Landscape 171162100.0 100.0 97.7 7/0 0100.0% 1.00.8s
Gravity 23125898.7 87.3 90.9 9/0 0100.0% 1.05.2s
Heatmap 25535095.1 93.6 87.3 30/1 297.3% 1.13.1s
Last Man Standing 300570100.0 95.9100.0 33/1 2100.0% 1.14.2s
Lines 45993197.3 88.5 93.9 22/6 2100.0% 1.24.7s
Minesweeper 175358100.0 81.4 68.5 15/0 3100.0% 1.34.7s
NBody 47945099.1 68.7 43.6 15/0 0100.0% 1.650.8s
RGB Color Wheel 45570097.7 82.7 85.0 38/0 2100.0% 1.15.6s
Sinuous 349488100.0 96.3 98.5 23/0 10100.0% 1.05.5s
Snowpar 338519100.0 88.6 88.6 31/0 0100.0% 1.23.2s
Stairs to Heaven 210422100.0 94.5100.0 25/8 1100.0% 1.02.5s
Sudoku 31661296.2 81.0 60.4 33/0 0100.0% 1.312.1s
TicTacToe 304590100.0 74.0100.0 19/0 0100.0% 1.27.4s
Zmeyko 344601100.0 96.7 96.3 33/1 0100.0% 1.07.0s
Table 1: Benchmark results for Chrome Experiments, IE Test D rive and 10K Apart Challenge applications.
The columns from left to right are: lines of code (LOC), numbe r of basic blocks (BB), percentage of call site
operations shown to invoke a function value (CF), property r ead operations where the base object is shown
to be non-nulland non-undefined (PA), ﬁxed-property read operations not resulting in undefined (FPU),
number of functions in total / number of functions shown to be deﬁnitely unreachable (UF), number of dead
code operations (DC), percentage of call sites that are show n to be monomorphic (MC), average type size
for all property read operations (ATS), and analysis time (T ime).
sites with a single invocation target compared to the total
number of call sites in the program. If this ratio is one then
every call site is monomorphic, i.e. it has a single invocati on
target. If a call site has a non-function value as a potential
invocation target this is not included in the number of tar-
gets, since such a value would always result in a runtime er-
ror. This measure can be seen in the MC column. InTable 1
we see that despite the fact that JavaScript supports both
theprototypelookupmechanismandhigher-orderfunctions ,
the analysis is able to show for 49 of the 53 of the benchmark
programs that all call sites have a single invocation target ,
which gives testimony to the high precision of the analysis.For Q4 we wish to measure the precision of the computed
types. The analysis tracks values of the following types:
boolean,number,string,object(including null and function
values) and the special type undeﬁned . This means that an
object property could potentially hold values of up to ﬁve
diﬀerent types. We measure this aspect of the accuracy of
the analysis by calculating the average number of diﬀerent
types for all property read operations in the given program
(excluding operations that the analysis ﬁnds to be unreach-
able). If this number is 1 then every read operation results
in values of a unique type on all possible executions. The
ATS column in Table 1 shows the resulting numbers. De-spite the fact that the types of object properties may change
dynamically in JavaScript, we note that the analysis is pre-
cise enough to show that the average number of diﬀerent
types for each property read operation in these benchmarks
is quite close to 1. Of the 26,870 property read operations
that appear in the benchmarks, the analysis ﬁnds that at
most 4,019 can have multiple types.
For the last research question, Q5, we measure both un-
reachable code and dead code. Unreachable code consists of
operations (i.e. ﬂow graph nodes) that are never executed,
and dead code is deﬁned to be reachable assignments to
properties that are never read. Write operations to special
DOM properties, such as onload, may have side-eﬀects, so
even if there are no corresponding read operations in the
program we do not count them as dead code.
ThecolumnlabelledUFinTable1containsthetotalnum-
ber of function in the program and how many of them are
determined by TAJS to be unreachable. Some of the bench-
marks use third-party libraries that are inlined directly i n
the source code, which explains the large number of un-
reachable functions in some benchmarks, such as 3D Demo
andRaytracer . All code that is found to be unreachable can
safely be removed(unless the analysis detects the special s it-
uation discussed in Section 4.3), which would signiﬁcantly
reduce code size in some cases. Most current miniﬁers either
unsoundly remove all functions not referenced syntactical ly
in the code or simply do not remove any functions at all.
With static analysis, guaranteed behavior preserving mini -
ﬁcation becomes possible.
The column labelled DC lists the number of dead code
operations in each program. We see that the analysis is ca-
pable of locating many instances of dead code. Most of the
dead code being detected appears to be code left from ear-
lier revisions of the programs. For example, in the Keylight
benchmark, a ﬂag named mouseIsDown is set in all event
handlers but it is never read.
The main threat to validity of our conclusions is that our
benchmarksmaynotberepresentativefor typicalJavaScrip t
web applications. For the reasons described in Section 5.2
we have excluded applications that rely on large libraries o r
on complex dynamically generated code. We will focus our
attention on these two remaining challenges in future work.
Nevertheless, the benchmarks we consider are written by
many diﬀerent programmers, they exhibit a large variety of
the functionality supported by the HTML DOM and the
browser API, and our experiments show that the program
analysis is able to infer many nontrivial properties about
their behavior.
6. RELATED WORK
Previous work on static analysis of JavaScript code has
focused on the language itself, and often for restricted sub -
sets of the language. To the best of our knowledge, the
work reported on in this paper is the ﬁrst that also models
the nontrivial connections between the HTML page and the
program code in JavaScript web applications.
One of the ﬁrst attempts at developing static analysis
for JavaScript was done by Anderson et al. who developed
a type system and inference algorithm for modeling deﬁ-
nite presence and potential absence of object properties in a
small subset of JavaScript [1]. The abstract domain used in
TAJSsubsumessuchinformation. Otherearlyworkincludes
Thiemann’s type system [19]. It has a soundness proof butno implementation. Although not tied to JavaScript in par-
ticular, Thiemann has also designed a type system for catch-
ing errors related to manipulation of DOM structures, in
particular to ensure that no loops occur [20].
More recently, Jang and Choe have presented a points-
to analysis for a restricted subset of JavaScript based on
set constraints [10]. The points-to results are used for opt i-
mizations that inline property accesses. In comparison, ou r
analysis yields points-to information as part of the result
and supports more features of the language.
TheGatekeeperprojectbyGuarnieriandLivshitsincludes
an Andersen-style points-to analysis for JavaScript [6, 7] .
The results of the analysis are used for verifying custom
security policies expressed in datalog. The analysis uses a
mock-up of the DOM API written in JavaScript and essen-
tially ignores the HTML constituents.
Perhapsmostcloselyrelatedtoourworkis thatofGuhaet
al. who use a k-CFA analysis to extract a model of the client
behavior in an AJAX application as seen from the server [8].
Their paper brieﬂy discusses some of the challenges that
relate to events, dynamically generated code, and librarie s,
but the focus of the paper is on the application for building
intrusion-preventing proxies. In comparison, our analysi s
has a more precise treatment of dataﬂow and event handlers
in connection to the DOM.
Recent work by Guha et al. considers a combination of
a type system and a ﬂow analysis to reason about uses of
thetypeofoperator in JavaScript code with type annota-
tions[9]. Thetypeofoperatorappearsin11ofour53bench-
marks, and TAJS models it with a special transfer function.
Chugh et al. use staged information ﬂow analysis to pro-
tectagainst dynamicloadingofmalicious code[3]. The anal -
ysis identiﬁes ﬁelds that can ﬂow into dynamically loaded
code and creates runtime monitors to ensure that they are
notaccessed from untrustedcode. Theanalysis uses acoarse
abstraction of the HTML page and the browser API, with-
out considering the challenges we describe in Section 2.
Logozzo and Venter’s RATA analysis uses light-weight
abstract interpretation to specialize the general JavaScr ipt
numbertypetointegerandﬂoatingpointtypesforoptimiza-
tion purposes [15]. Making this distinction in the abstract
domain used in TAJS would be a straightforward task.
One way to guide the design of an analysis is to survey the
practicaluseofthelanguage. InonesuchsurveybyRichards
et al., it is shown that many of the dynamic features of
JavaScript are not widely used in practice [18]. The study
shows that the majority of method invocations in JavaScript
are monomorphic. Our experimental results conﬁrm this ob-
servation, but using practically sound static analysis ins tead
of runtime measurements. In later work, the use of evalis
studied [17]. The authors show that the categories of eval
that are now supported by TAJS, i.e. JSON data and sim-
ple function calls, are often used. It is also shown that eval
is used for lazy loading and as artifacts of generated code,
which, as discussed in Section 2.3, is outside the scope of
TAJS.
7. CONCLUSION
We have presented the ﬁrst static analysis that is capable
of reasoning precisely about the control ﬂow and dataﬂow in
JavaScript applications that run in a browser environment.
The analysis has been implemented as an extension of the
TAJS tool and models both the DOM model of the HTMLpage and browser API. This includes the HTML element
object hierarchy and the event-driven execution model. In
the process we have identiﬁed the key areas where modeling
the browser is important for precision and challenging for
static analysis.
Our experimental evaluation of the performance of the
analysis indicates that (1) the analysis is able to show ab-
sence of common programming errors in the benchmarkpro-
grams, (2) the analysis can help detecting potential errors ,
such as misspelled property names, (3) the computed call
graphsarepreciseasmostcallsitesareshowntobemonomor-
phic, (4)thecomputedtypesareprecise as manyexpressions
are shown to have unique types, and (5) the analysis is able
to identify dead code and unreachable functions. Such in-
formation can give a foundation for providing better tool
support for JavaScript web application developers.
Interesting challenges remain. First, more work is re-
quiredforinvestigatingthemorecomplicatedusesofdynam -
ically generated code. Second, better techniques are neede d
to handle commonly used libraries. Third, the techniques
presented here can be adapted to model other JavaScript
environments, such as desktop widgets or browser exten-
sions.
8. REFERENCES
[1] C. Anderson, P. Giannini, and S. Drossopoulou.
Towards type inference for JavaScript. In Proc. 19th
European Conference on Object-Oriented
Programming, ECOOP ’05 , volume 3586 of LNCS.
Springer-Verlag, July 2005.
[2] G. Balakrishnan and T. W. Reps. Recency-abstraction
for heap-allocated storage. In Proc. 13th International
Static Analysis Symposium, SAS ’06 , volume 4134 of
LNCS. Springer-Verlag, August 2006.
[3] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner.
Staged information ﬂow for JavaScript. In Proc. ACM
SIGPLAN Conference on Programming Language
Design and Implementation, PLDI ’09 , June 2009.
[4] ECMA. ECMAScript Language Speciﬁcation, 3rd
edition. ECMA-262.
[5] S. Fink and J. Dolby. WALA – The T.J. Watson
Libraries for Analysis.
http://wala.sourceforge.net/ .
[6] S. Guarnieri and B. Livshits. Gulfstream: Staged
static analysis for streaming JavaScript applications.
InProc. USENIX Conference on Web Application
Development, WebApps ’10 , June 2010.
[7] S. Guarnieri and V. B. Livshits. Gatekeeper: Mostly
static enforcement of security and reliability policies
for JavaScript code. In Proc. 18th USENIX Security
Symposium, Security ’09 , August 2009.
[8] A. Guha, S. Krishnamurthi, and T. Jim. Using static
analysis for Ajax intrusion detection. In Proc. 18th
International Conference on World Wide Web,
WWW ’09 , May 2009.
[9] A. Guha, C. Saftoiu, and S. Krishnamurthi. Typing
local control and state using ﬂow analysis. In Proc.
Programming Languages and Systems, 20th European
Symposium on Programming, ESOP ’11 , LNCS.
Springer-Verlag, March/April 2011.
[10] D. Jang and K.-M. Choe. Points-to analysis for
JavaScript. In Proc. 24th Annual ACM Symposium onApplied Computing, SAC ’09, Programming Language
Track, March 2009.
[11] S. H. Jensen, A. Møller, and P. Thiemann. Type
analysis for JavaScript. In Proc. 16th International
Static Analysis Symposium, SAS ’09 , volume 5673 of
LNCS, pages 238–255. Springer-Verlag, August 2009.
[12] S. H. Jensen, A. Møller, and P. Thiemann.
Interprocedural analysis with lazy propagation. In
Proc. 17th International Static Analysis Symposium,
SAS ’10, volume 6337 of LNCS, pages 238–256.
Springer-Verlag, September 2010.
[13] J. B. Kam and J. D. Ullman. Monotone data ﬂow
analysis frameworks. Acta Informatica , 7:305–317,
1977. Springer-Verlag.
[14] R. Kromann-Larsen and R. Simonsen. Statisk analyse
af JavaScript: Indledende arbejde. Master’s thesis,
Department of Computer Science, Aarhus University,
2007. (In Danish).
[15] F. Logozzo and H. Venter. RATA: Rapid atomic type
analysis by abstract interpretation - application to
JavaScript optimization. In Proc. 19th International
Conference on Compiler Construction, CC ’10 ,
volume 6011 of LNCS. Springer-Verlag, March 2010.
[16] S. Maﬀeis, J. C. Mitchell, and A. Taly. An operational
semantics for JavaScript. In Proc. 6th Asian
Symposium on Programming Languages and Systems,
APLAS ’08 , volume 5356 of LNCS. Springer-Verlag,
December 2008.
[17] G. Richards, C. Hammer, B. Burg, and J. Vitek. The
eval that men do – a large-scale study of the use of
eval in JavaScript applications. In Proc. 25th European
Conference on Object-Oriented Programming,
ECOOP ’11 , LNCS. Springer-Verlag, July 2011.
[18] G. Richards, S. Lebresne, B. Burg, and J. Vitek. An
analysis of the dynamic behavior of Javascript
programs. In Proc. ACM SIGPLAN Conference on
Programming Language Design and Implementation,
PLDI ’10 , June 2010.
[19] P. Thiemann. Towards a type system for analyzing
JavaScript programs. In Proc. Programming
Languages and Systems, 14th European Symposium on
Programming, ESOP ’05 , April 2005.
[20] P. Thiemann. A type safe DOM API. In Proc. 10th
International Workshop on Database Programming
Languages, DBPL ’05 , volume 3774 of LNCS.
Springer-Verlag, 2005.