Mining Parametric SpeciÔ¨Åcations
Choonghwan Lee Feng Chen Grigore Ro¬∏ su
Department of Computer Science
University of Illinois at Urbana-Champaign
{clee83, _, grosu}@illinois.edu
ABSTRACT
Specications carrying formal parameters that are bound
to concrete data at runtime can eectively and elegantly
capture multi-object behaviors or protocols. Unfortunately,
parametric specications are not easy to formulate by non-
experts and, consequently, are rarely available. This paper
presents a general approach for mining parametric specica-
tions from program executions, based on a strict separation
of concerns: (1) a trace slicer rst extracts sets of indepen-
dent interactions from parametric execution traces; and (2)
the resulting non-parametric trace slices are then passed to
any conventional non-parametric property learner. The pre-
sented technique has been implemented in jMiner , which
has been used to automatically mine many meaningful and
non-trivial parametric properties of OpenJDK 6.
1. INTRODUCTION
Formal specications dene behaviors that systems or parts
of systems should obey. A parametric specication is a for-
mal specication that carries parameters that are bound to
concrete object instances at runtime. As an example, Fig-
ure 1 shows a nite state automaton (FSA) that describes a
parametric specication involving two Java classes, Collection
and Iterator . Each edge represents an event, such as calling a
method.hinitirepresents calling the constructor of Collection
and update calling a method that changes the contents of the
Collection object specied as a parameter c;add,remove and
clearcan be such methods. iterator represents creating an Itera-
torobject for a Collection object and has two parameters: the
underlying Collection object and the created Iterator object.
hasNext and nextrepresent invocations on methods hasNext
and nextofIterator , respectively. The nextmethod returns the
next element in the iteration and the hasNext method checks
if the iteration has more elements (i.e., hasNext checks if next
is safe). The specication in Figure 1 states the following
safety property: if an iterator iis created for a collection c,
the contents of cshould not be changed while iis being used;
indeed, once the FSA enters state 4, no method calls of the
.
next(i)  hasNext (i) 
2 0 3 <init>(c)  iterator( c,i) update(c)  hasNext (i) 
1 
4 update(c)  Figure 1: Collection -Iterator protocol mined with jMiner.
iterator are allowed (state 4 does not accept hasNext ornext).
A violation of this property results in a runtime exception.
Figure 1 also shows a typical usage pattern of Iterator : every
call to nextis usually guarded by a call to hasNext .
The use of parameters is crucial in order to properly dis-
tinguish among dierent object interactions. Indeed, if one
omits the parameters of the specication in Figure 1, then
one would wrongly report a protocol violation when, e.g.,
two consecutive nextcalls are observed on two distinct it-
erators. Current parametric specication monitoring ap-
proaches maintain a clean separation between dierent ob-
ject interactions, each interaction being observed by a dis-
tinct monitor; if an event is relevant to several monitors,
e.g., an update event of a collection cwhich is relevant to all
iteratorsioverc, then that event is dispatched to all inter-
ested monitors [5]. This way, monitors are not perturbed by
irrelevant events or by unfortunate interaction interleavings.
The major objective of this paper is to present a technique
that achieves the same degree of separation between dierent
object interactions, but for mining instead of monitoring.
Numerous specication mining approaches have been pro-
posed, e.g., [2, 16, 22, 10, 9, 1, 15, 18, 19, 20, 8, 3, 13, 14, 23,
7] among others. Parametric specications are much more
challenging to mine than non-parametric ones, mainly due to
the complexity of handling parameters. Indeed, as discussed
in Section 7, none of the existing approaches provides a satis-
factory solution for mining parametric specications in their
full generality and invulnerability to \unfortunate" interac-
tion interleaving. For example, none of the approaches that
we are aware of is able to mine the specication in Figure 1
in the presence of arbitrary interaction interleavings.
Contributions. In this paper we present an eective and
generic dynamic approach for mining parametric specica-
tions. We strongly separate the tasks of parameter handling
and of specication learning, which has two major benets:
(1) parameter handling makes no assumption on the types
of specications to mine, resulting in a generic parametric
mining framework; and (2) learning is not aected by param-
eters or perturbed by interaction interleavings, reducing theEvent Specification Learner  Source code  
Package name  
Unit Test Case  
Trace Slicer  Execution Trace  Event Specification  
STAGE I:  MINE EVENT SPECIFICATION  
STAGE II:  MINE PARAMETRIC SPECIFICATION  
JMINER  
ARCHITECTURE  Specification Learner  
Parametric 
Specification  Trace Slice  Trace Slice  Trace Slice  Execution Trace  Execution Trace  Figure 2: Mining Parametric Specications.
eort to re-use existing algorithms (or to develop new ones)
and increasing the overall precision of mining. The presented
approach has been implemented in and extensively evalu-
ated with jMiner . The major tasks performed by jMiner
are: instrument the observed program to emit parametric
events of interest at runtime; run the instrumented program
and collect a parametric execution trace; slice the paramet-
ric trace into a set of independent object interactions, called
trace slices; pass the resulting trace slices to any learner;
nally, put everything together into one or more paramet-
ric specications. When used on packages that provide unit
tests, jMiner provides a completely automated parametric
specication mining solution: building upon the hypothe-
sis that unit tests are devised to stress interactions among
objects and methods that are likely to obey some protocol,
jMiner learns the events of interest by rst running and ob-
serving the existing unit tests. This worked well in practice
and, indeed, jMiner has been used to automatically mine
many properties of OpenJDK6, like the one in Figure 1.
The rest of this paper is organized as follows. Section 2
highlights our overall approach to mining parametric spec-
ications. Section 3 explains our novel trace slicing tech-
nique. Section 4 describes the other parts of our framework
in detail. Section 5 discusses experiments and limitations.
Section 7 discusses related work. Section 8 concludes.
2. APPROACH OVERVIEW
Here we give a high-level overview of our mining approach.
Definition 1.(Event specication ) We write meth-
odsasm(Tt;Tr;Tp1;:::;Tpn), wheremis the method name,
Ttis the receiver type, Tris the return type, and Tp1;:::;Tpn
are the types of its parameters; for uniformity, we call each
ofTt;Tr;Tp1;:::;Tpnamethod parameter . IfMis a set
of methods, let XMbe all the method parameters of refer-
ence type for all methods in M. An event specication is
a pairhM;Xi, whereMis a set of methods and XXM.
For example, consider a set of methods M=fIterator.hasNext
(Iterator, boolean) ,Iterator.next(Iterator, Object) ,Collection.iterator
(Collection, Iterator)g. Then,XM=fCollection ,Iterator ,Objectg,
because boolean is not a reference type. hM;XMiforms an1. ArrayList.add(ArrayList:158)
2. AbstractList.iterator(ArrayList:158, AbstractList$Itr:119)
3. AbstractList$Itr.hasNext(AbstractList$Itr:119)
4. AbstractList$Itr.next(AbstractList$Itr:119)
5. AbstractList$Itr.hasNext(AbstractList$Itr:119)
6. AbstractList.iterator(ArrayList:263, AbstractList$Itr:131)
7. AbstractList$Itr.hasNext(AbstractList$Itr:131)
8. AbstractList$Itr.next(AbstractList$Itr:131)
9. AbstractList$Itr.next(AbstractList$Itr:119)
Figure 3: Fragment of an execution trace.
event specication, but one may prefer event specication
hM;Xi, whereXdrops Object fromXM. An event speci-
cation denes a set of related methods and their parameters
that would likely form a useful parametric specication.
Parametric specications are specications adding param-
eters to properties specied using any (non-parametric) trace
formalism [4, 5]. Here we only consider regular patterns, de-
nable through FSA; we only used FSA learners so far.
Definition 2.Aparametric specication is a tuple
(S;M;X;s 0;;F ), wherehM;Xiis an event specication
and(S;M;s 0;;F )is an FSA, where Sis the set of states,
s02Sis the initial state, : [SM+S ]is the transition
(partial) function, and FSis the set of nal states.
Figure 1 shows one such parametric specication. As a no-
tational convenience, we write methods in Mwith their pa-
rameters in X(and drop the other parameters in XM X).
Our parametric specication mining approach consists of
two stages, also giving the architecture of jMiner , as de-
picted in Figure 2: event specication learning (Section 4.1)
and parametric specication mining (Sections 3 and 4.2).
The former yields a set of event specications. The latter
mines a parametric specication for each event specication.
Providing precise event specications is inconvenient, since
it requires expert knowledge about the target software. A set
of overly diverse methods would result in a too complex spec-
ication likely to be application-specic, while a set of too
few methods would result in a too simple specication cov-
ering only part of the usage pattern. Our approach is to au-
tomatically learn event specications from unit tests, when
available, based on the hypothesis that unit tests check the
behavior of tightly interacting objects and thus the methods
involved in such interactions likely obey some specication.
The parametric specication mining stage takes an event
specication and various program execution traces as in-
put, and yields a parametric specication as output. To
obtain program execution traces, we wrote a Java Virtual
Machine Tool Interface (JVMTI)[11] agent that logs infor-
mation about the invoked methods and their arguments,
and attached it to the JVM. JVMTI provides a convenient
means to access the call stack and to uniquely identify ob-
jects. Our JVMTI agent records all method invocations from
all threads in chronological order, so that interactions that
span over multiple threads can be recognized. The events
and parameters which are not relevant for the given event
specication are then ltered out. Figure 3 shows a result-
ing execution trace fragment when the event specication
ishfCollection.add ,Collection.iterator ,Iterator.hasNext ,Iterator.nextg,
fCollection ,Iteratorgi. Each line corresponds to a method invo-
cation and contains a method name together with the paired
actual type and object identier for each method parameter.
Note that our execution trace ltering takes into account
Java's implicit upcasting. For example, ArrayList.add is not
ltered out because the method addis dened by ArrayList 's
superclass Collection and is included in the event specication.
As explained in Section 1, the event parameters in ex-ecution traces play a crucial role. Indeed, if one dropped
the parameters then one would see just one large and likely
unreal (and thus unsuitable for mining) interaction that in-
terleaves many dierent object interactions. For example, in
the trace in Figure 3, events 8 and 9 are unrelated since their
Iterator objects are dierent. However, a specication learner
making abstraction of parameters would infer a faulty spec-
ication allowing two consecutive nexts.
To infer accurate specications no matter how interac-
tions interleave, independent interactions need to be consid-
ered separately. To this end, our approach introduces trace
slicing . Informally, an interaction is a series of events that
manipulate a set of objects. For example, two interactions
exist in Figure 3: [ add,iterator ,hasNext ,next,hasNext ,next]
(events 1, 2, 3, 4, 5 and 9) on hArrayList:158 ,Abstract$List:119i
and [ iterator ,hasNext ,next] (events 6, 7 and 8) on hArrayList:263 ,
Abstract$List:131i. Our trace slicer identies such interactions
and passes them separately to the specication learner.
A specication learner nally infers a parametric speci-
cation from the set of separate interactions. The learner
need not be aware of parameters and, consequently, one can
reuse existing learners and/or easily develop new ones. If an
FSA learner is employed, it would infer the pattern of alter-
nation between hasNext and nextfrom the above two separate
interactions. The inferred FSA is nally annotated with pa-
rameters, which produces a parametric specication.
3. SLICING TRACES
In this section, we rst dene trace slicing , a process that
dispatches events (in the given execution trace) to trace
slices corresponding to dierent parameter bindings, accord-
ing to the given event specication. We then introduce the
concept of complete and connected parameter instances in
order to remove trace slices that are meaningless and thus
can generate noise in the process of mining specications.
We show that a parametric trace can comprise, in the worst-
case scenario, exponentially many trace slices (correspond-
ing to complete and connected parameter instances).
3.1 Parametric Trace Slicing
Our terminology used in this section is borrowed from [5].
Definition 3.LetEbe a set of non-parametric events,
called base events or simply events . AnE-trace , ortrace ,
is a nite sequence of events in E, i.e., an element in E.
We writee2wwhen event e2E appears in trace w2E.
Let [A!B] and [A+B ] denote the sets of total and
respectively partial functions from AtoB. What follows
extends the denition above to parametric events and traces.
Definition 4.(Parametric events and traces) LetX
be a set of parameters and letVXbe a set of corresponding
parameter values . IfEis a set of base events (Def. 3), then
letEhXidenote the set of corresponding parametric events
ehi, whereeis a base event in Eandis a partial function
in[X+VX]. Let Dom()befx2Xj(x)denedgand?2
[X+VX]be the map undened everywhere; i.e., Dom(?) =
;. Partial maps in [X+VX]may also be called parameter
instances orparameter bindings . Aparametric trace
is a trace with events in EhXi, that is, a word in EhXi.
In Figure 3,E=fadd,iterator ,hasNext ,nextg,X=fCollection ,
IteratorgandVX=f158,119, . . .g. In the parametric trace
shown in Figure 3, addandhArrayList:158iare the base event
and resp. the parameter binding of the rst parametric event.Definition 5.We say that 0isless informative than
, written0v, i for any x2X, if0(x)is dened then
(x)is also dened and 0(x) =(x).
For example,hArrayList :158ivh ArrayList :158,Abstract$List :119i.
Definition 6.(Trace slicing) Given parametric trace
2EhXiand partial function inX, let the-trace slice
ofbe the non-parametric trace in Edened as follows:
=, whereis the empty trace/word, and
(eh0i)=
()ewhen0v
 when06v
A trace slice rst lters out all the parametric events
that are irrelevant to the parameter instance . For ex-
ample, when the given parameter instance is hArrayList :158
Abstract$List :119iin Figure 3, the resulting trace slice does not
contain the sixth event. Similarly, events 7 and 8 are also l-
tered out. Event 1, which binds only ArrayList , is added to the
trace slice corresponding to hArrayList :158,Abstract$List :119i
becausehArrayList :158ivh ArrayList :158,Abstract$List :119i.
A trace slice also forgets the parameter bindings of
parametric events. As a result, a trace slice is non-parametric
and merely a list of base events. For example, the trace
slice corresponding to hArrayList :158,Abstract$List :119iis [add,
iterator ,hasNext ,next,hasNext ,next]. Dropping parameter in-
formation enables the parametric specication mining stage
to use any learners as long as they take as input a set of
strings, where a string is a list of base events.
Although the intuition is clear, developing ecient and
correct trace slicing algorithms is non-trivial. First, travers-
ing the trace more than once is undesirable due to eciency
concerns. Second, an event may contain an incomplete bind-
ing of the given set of parameters. For example, for the
trace in Figure 3, if we choose fCollection ,Iteratorgas the set
of parameters, an addevent contains only a Collection param-
eter, leaving the Iterator parameter unbound. Furthermore,
an event may belong to multiple trace slices because its pa-
rameter instance can be less informative than many other
parameter instances introduced by the trace. For exam-
ple, if the trace in Figure 3 contained another event itera-
tor(ArrayList:158,AbstractList$List:219) , the rst event would also
belong to the trace slice of hArrayList :158,Abstract$List :219i.
3.2 Complete and Connected Instances
Since a trace slice corresponds to a parameter instance,
selecting an appropriate set of parameter instances is crucial
in order to prevent meaningless trace slices (such trace slices
may result in learning inaccurate specications). To select
only appropriate parameter instances, we use two criteria:
completeness and connectedness.
A parameter instance is complete ifDom() =X, whereX
is the set of parameters in the given event specication. In-
complete parameter instances are considered inappropriate,
and trace slices corresponding to those parameter instances
are suppressed; i.e., is suppressed if Dom()6=X. For
example, if X=fCollection ,Iteratorgin Figure 3, the trace
slice corresponding to hAbstract$List :119iis suppressed. The
trace slice for this incomplete parameter instance is indeed
meaningless because it does not represent an interaction be-
tween a collection and an iterator.
For some cases, no event provides a complete parameter
instance. One such example is illustrated in Figure 4, when
X=fSocket ,SocketInputStream ,SocketOutputStream g. The rst1. Socket.<init>(Socket:262)
2. Socket.getInputStream(Socket:262, SocketInputStream:227)
3. Socket.getOutputStream(Socket:262, SocketOutputStream:288)
4. SocketInputStream.read(SocketInputStream:227)
5. Socket.getOutputStream(Socket:562, SocketOutputStream:588)
Figure 4: Part of an execution trace used for mining
the specication in Figure 10.
four events are part of one interaction hSocket :262,SocketInput-
Stream :227,SocketOutputStream :288i, but there is no event that
provides the complete parameter instance. Parameter in-
stances from multiple events therefore need to be combined.
Definition 7.Two parameter instances and0arecom-
patible i for anyx2Dom()\Dom(0),(x) =0(x). We
cancombine compatible instances and0, writtent0:
(t0)(x) =8
<
:(x) when(x)is dened
0(x) when0(x)is dened
undened otherwise
For example,hSocket :262,SocketInputStream :227iis compatible
withhSocket :262,SocketOutputStream :288ibut is not compatible
withhSocket :562,SocketOutputStream :588i. Two parameter in-
stances disagreeing on any parameter are incompatible, and
thus cannot be combined. hSocket :262,SocketInputStream :227i
thSocket :262,SocketOutputStream :288iishSocket :262,SocketInput-
Stream :227,SocketOutputStream :288i, obtaining a complete in-
stance when X=fSocket ,SocketInputStream ,SocketOutputStream g.
Combining multiple parameter instances is therefore nec-
essary for achieving a complete parameter instance. How-
ever, if done blindly, it may introduce spurious parame-
ter instances. For example, hSocket :562,SocketInputStream :227,
SocketOutputStream :588i, obtained by combining hSocket :562,
SocketOutputStream :588iandhSocketInputStream :227iin Figure 4,
is spurious because an interaction involving all three objects
does not exist in the given trace. Trace slices correspond-
ing to spurious parameter instances represent non-existing
interactions, and consequently, become noise. To lter out
spurious parameter instances, we introduce the concept of
connected parameter instances.
Definition 8.If2EhXi, we dene-connectedness
of parameter instances as follows: 1) if ehi2then
is-connected; and 2) if 1;2are-connected, compatible,
and1u26=?, then1t2is also-connected.
Therefore, a parameter instance is -connected i it is formed
by combining parameter instances of events in that share
parameter bindings. For example, hSocket :262,SocketInput-
Stream :227,SocketOutputStream :288iis-connected in Figure
4 because of events 2 and 3, but hSocket :562,SocketInput-
Stream :227,SocketOutputStream :588iis not. In cases where there
is no ambiguity, we will say connected instead of-connected.
Connectedness is motivated by the following observation:
in most cases we are interested in mining specications for a
set of interacting objects ; if two objects appear in the same
event, then they interact with each other. Therefore, all
the objects contained in a connected parameter instance di-
rectly or indirectly interact with one another. Experiments
using our technique, discussed in Section 5, show that pass-
ing only the trace slices corresponding to connected parame-
ter instances to the specication learner (and discarding the
other trace slices) eectively removes noise in the mining
process, resulting in accurate specications.
Computing all possible connected parameter instances is
hard. One should not mistakenly think that this problem
reduces to computing the ordinary connected components
‚ü®P:ùëù0, Q:ùëû0‚ü© ‚ü®Q:ùëû0, R:ùëü1‚ü© 
‚ü®Q:ùëû0, R:ùëü2‚ü© ‚ü®R:ùëü1, S:ùë†0‚ü© 
conflict on R  Figure 5: A graph showing that connectedness in a
graph does not indicate -connectedness.
of a graph, where a vertex represents a parameter instance
and an edge exists i the two associated parameter instances
(1and2) are compatible and 1u26=?. Figure 5 shows
one such graph. P,Q,Rand Sare parameters, and p0,q0,
r1,r2ands0are parameter values. The graph-connected
component in Figure 5 correctly suggests that hP:p0,Q:q0it
hQ:q0,R:r1ith R:r1,S:s0iis-connected. However, it also
suggests thathP:p0,Q:q0ith Q:q0,R:r2ith R:r1,S:s0iis-
connected, which is wrong. Indeed, computing the graph-
connected components does not take into consideration the
compatibility between parameter instances, while comput-
ing the-connected parameter instances must. For example,
hQ:q0,R:r1iandhQ:q0,R:r2iare incompatible, but the stan-
dard graph-connected component fails to recognize it.
3.3 Complexity of Trace Slicing
In what follows we calculate the worst-case complexity of
the trace slicing problem in terms of the number of trace
slices as a function of the total length nof the original para-
metric trace and the size of X, the set of parameters. More
precisely, we show that there are approximately1(n
m)mtrace
slices in the worst case when m1, wherem+1 is the size of
X. Note that ifjXj= 1 then we have at most ntrace slices
and they are easy to compute. However, if jXj=n
2+1 then
we have 2n
2trace slices, showing that the addition of con-
icting edges (like in Figure 5) makes the graph-connected
component problem harder. The maximum of (n
m)mis ac-
tually reached when m=n
e, in which case it becomes en
e.
Suppose that X=fP0,P1, . . . , Pmgfor somem> 0 and
that=e1h1ie2h2i::: enhni. The worst case is when
any two events have at least one common parameter value,
so thatu06=?for any two parameter instances and0
such thatehi;e0h0i2; we can achieve that with minimal
resources, by designating a parameter instance hP0:p0iand
assuming that that is common to all events. Each event
may be in conict with a certain number of other events. For
example, suppose that e1h1iis in conict with a1 1 events
on parameter P1, wherea1>0. The other a1 1 events are
also in conict with each other, so we have a \cluster" of a1
events which are in conict with each other on parameter
P1. The worst case is when the conicting a1events are in
conict with no other event and when, for each trace slice
corresponding to the remaining events, each of them yields
a new trace slice. Thus, assuming that the remaining events
generatestrace slices, we have a1sslices in total. We can
iterate the argument above and obtain a1a2am
trace slices when we split the nevents ofinto clusters
ofa1;a2;:::;amevents with a1+a2++am=n, each
cluster containing those events conicting on precisely one of
the parameters P1,P2, . . . , Pm, respectively. Note that this
is not only an over-approximation. It can actually happen,
as shown in Figure 6. The product is maximized when a1=
1We do an approximate analysis, making abstraction of the
fact thatmmay not divide n, etc.‚ü®P0:ùëù0, P1 :ùëù1,1‚ü© 
‚ü®P0:ùëù0, P1 :ùëù1,2‚ü© 
‚ü®P0:ùëù0, P1 :ùëù1,ùëé1‚ü© 
cluster of ùëé1 ‚ü®P0:ùëù0, P2 :ùëù2,ùëé2‚ü© ‚ü®P0:ùëù0, P2 :ùëù2,2‚ü© ‚ü®P0:ùëù0, P2 :ùëù2,1‚ü© 
cluster of ùëé2 ‚ü®P0:ùëù0, Pm :ùëùùëö,1‚ü© 
‚ü®P0:ùëù0, Pm :ùëùùëö,2‚ü© 
‚ü®P0:ùëù0, Pm :ùëùùëö,ùëéùëö‚ü© 
cluster of ùëéùëö Figure 6: Clusters of a1;a2;:::;amevents.
a2==am=n
m, in which case it becomes (n
m)m.
Therefore, assuming that Xis xed a priori, as it is usu-
ally the case, we can only have a polynomial (in the length
of the original parametric trace) number of trace slices. If
Xis not xed, then one can actually fabricate an absolute
worst-case scenario, which maximizes (n
m)m. This case oc-
curs whenm=n
e, in which case the number of trace slices is
exponential: en
e. Although it is little likely in practice that
the size of Xis co-related to the length of the trace, it is
instructive to have a clear understanding of the worst-case
complexity of the problem that we are attempting to solve.
3.4 Slicing Algorithm
As discussed in Section 3.3, the number of trace slices is
(n
m)min the worst case. Since all trace slices can be distinct,
this number gives a lower bound for all trace slicing algo-
rithms. This lower bound is hard to achieve, though, since
computing complete and connected parameter instances may
require several operations of instance combination. For ex-
ample,hP0:p0,P1:p1;1,P2:p2;1, . . . , Pm:pm;1iin Figure 6 can
be obtained only after at least minstance combination oper-
ations: (((hP0:p0,P1:p1;1ith P0:p0,P2:p2;1i)thP0:p0,P3:p3;1i)
t. . .thP0:p0,Pm:pm;1i). Furthermore, a trace slicing algo-
rithm needs to search for compatible parameter instances in
order to create combined parameter instances.
Our trace slicing algorithm in Figure 7, called Slicer , tra-
verses the given trace only once and avoids the construction
of meaningless trace slices. Slicer has two stages: (1) it rst
processes the entire parametric trace, event by event, con-
structing intermediate results ; and (2) then it constructs
the set of trace slices 	, each corresponding to a complete
and connected parameter instance.
During the rst stage, Slicer stores in  intermediate
trace slices only for parameter instances that actually occur
in observed events. Neither combined parameter instances
nor trace slices for them are created at this stage. The sec-
ond stage, ConstructConnected , constructs 
 holding all
possible connected parameter instances by combining com-
patible parameter instances in the loop at lines 2{3. For
each complete and connected parameter instance, its cor-
responding trace slice is nally constructed at lines 4{6.  
collects all intermediate trace slices corresponding to 's sub-
instances. MergeTraces is essentially the merge function
of merge sort, using the position of events in the trace for
comparison (events in trace slices are listed chronologically).
Theorem 1.After running Slicer on2EhXi
1.	()is dened i is-connected and Dom() =X.
2. If 	()is dened, then 	() =.
This theorem tells all trace slices can be retrieved from 	.
We next analyze the complexity of Slicer . It rst calls
HandleEvent ntimes, and, assuming that a self-balancingInput :X;  =e1h1ie2h2i::: enhni
Output : 	2[[X!VX]+E]
Global : 2[[X+VX]+E]
Function Slice()
fori 1tondoHandleEvent( eihii) 1
ConstructConnected()2
Function HandleEvent( ehi)
if()undened then ()  1
() ()e 2
Function ConstructConnected()

 fj() is denedg 1
while91;22
compatible, 1u26=?,1t2=2
do 2

 
[f1t2g 3
foreach2
s.t.Dom() =Xdo 4
  =f(0)j0vand (0) is denedg 5
	() MergeTraces(  ) 6
Figure 7: Slicer: Trace Slicing algorithm.
binary search tree is used for , the complexity of Han-
dleEvent isO(logn). The loop at lines 2{3 in Construct-
Connected can pick1and2from 

, and each iter-
ation takes O(m) time for checking the compatibility and
combining the two parameter instances. There are j
jit-
erations of the loop at lines 4{6, with each iteration taking
O(m) time. The running time of the entire algorithm is
thusO(nlogn+j
j2m+j
jm) =O(nlogn+j
j2m).
Since the algorithm creates all possible connected parameter
instances,j
jcan be calculated as follows: the number of
connected parameters with jDom()j=i+ 1 is m
i
(n
m)i
because we can choose iparameters and there aren
mpa-
rameter values for each parameter. Thus, we have j
j=Pm
i=1 m
i
(n
m)i= (n
m+ 1)m, and the time complexity of
Slicer isO(nlogn+ (n
m+ 1)2mm) =O((n
m+ 1)2mm).
As for the space complexity, it needs to maintain O(j
j)
connected parameter instances of length O(m) during trace
slicing. It also needs space for (n
m)mtrace slices of size m
as illustrated in Figure 6. Therefore, the space complexity
isO((n
m+ 1)mm+ (n
m)mm) =O((n
m+ 1)mm).
Slicer iterates through all possible connected parame-
ter instances in the loop at lines 2{3 in ConstructCon-
nected . In our experiments, this step was comparatively
the most expensive wrt performance, so we have investi-
gated several possibilities to optimize it. We next describe
two of our optimizations which bring considerable perfor-
mance benets. Instead of blindly picking a pair of pa-
rameter instances from 
 and combining them, our imple-
mentation proceeds in a bottom-up manner. At the rst
step, it picks two parameter instances ( 1and2) such that
jDom(1)j=jDom(2)j=N, and creates 1t2, if necessary.
After handling all parameter instances with Nparameter
bindings, it picks parameter instances with N+1 parameter
bindings, and so on and so forth until Nreaches the size of
X, the set of parameters. This way, a parameter instance is
considered for compatibility within only a limited window,
reducing the number of iterations.
Our second optimization is to group parameter instances
so that all parameter instances in the same group bind ex-
actly the same parameters. Grouping also reduces the num-
ber of iterations at lines 2{3 in ConstructConnected .
For example, ifhP:p1,Q:q1iis chosen as 1, all parameter in-
stances that belong to the group corresponding to fR,Sgwill
be excluded from the list of candidates for 2because any
parameter instance in this group would result in 1u2=?.4. LEARNING IN JMINER
Here we discuss how the trace slicing technique in Sec-
tion 3 is incorporated within our jMiner parametric min-
ing approach, by means of discussing jMiner 's event speci-
cation learner (from unit tests) as well as its specication
learner (based on a renement of the o-the-shelf PFSA).
4.1 Learning Event SpeciÔ¨Åcations
The event specication learner dynamically infers a set of
event specications from the target software. It takes as in-
put the source code, a target package name, and unit tests
(all for the target software). Providing these inputs is easy
and requires no expert knowledge. For example, in order
to mine specications in the java.util package of OpenJDK 6,
what the user needs to provide is: the source code of Open-
JDK 6, the target package name java.util , and the unit tests
forjava.util . Here is, e.g., a typical unit test in OpenJDK 6:
1. import java.util.*;
2. public class CheckForComodification {
3. private static final int LENGTH = 10;
4. public static void main(String[] args) throws Exception {
5. List<Integer> list = new ArrayList<Integer>();
6. for (int i = 0; i < LENGTH; i++) list.add(i);
7. try { for (int i : list)
8. if (i == LENGTH - 2) list.remove(i);
9. } catch(ConcurrentModificationException e) { return; }
10. throw new RuntimeException
11. ("No ConcurrentModificationException");
12. } }
This unit test case is written to test if a concurrent modi-
cation of a Collection object is detected and a runtime excep-
tion is raised. As the Java compiler translates the for- each
loop at lines 7{8 into ArrayList.iterator ,AbstractList$Itr.hasNext
and AbstractList$Itr.next , an execution of this test case will re-
veal an interaction between ArrayList and AbstractList$Itr .
An advantage of using unit tests for learning event speci-
cations is that tightly interacting objects are well isolated.
For example, the unit test case above considers only one
issue, namely detecting a concurrent modication. This iso-
lation avoids tangential relationships among issues, which
are usually application-specic and thus not likely to obey
a generic specication. For example, an interaction on a Fil-
eReader object and an interaction on a FileWriter object can be
related in an application through a Fileobject, because both
FileReader and FileWriter objects can be constructed with the
same Fileobject. Although somewhat related, it is expected
that reading and writing are two separate issues and thus
specications involving both are unnecessary. Such tangen-
tial relationships rarely occur in unit tests. Moreover, users
can obtain unit tests for free as many software packages are
shipped with them. Unit tests are well maintained as they
are frequently run and failed cases are promptly addressed.
Learning related methods and parameters. We rst
trace unit test executions using a JVMTI agent like the one
in Section 2, but one which also logs the thread identier
and the depth of the call stack in front of each event (each
thread has its stack and every method invocation is logged).
Here is, e.g., part of the trace logged by the unit test above:
1.1 2 ArrayList.<init>(ArrayList:689)
2.1 2 ArrayList.add(ArrayList:689, Integer:830)
3.1 3 ArrayList.ensureCapacity(ArrayList:689)
4.1 2 AbstractList.iterator(ArrayList:689, AbstractList$Itr:950)
5.1 2 AbstractList$Itr.hasNext(AbstractList$Itr:950)
6.1 3 ArrayList.size(ArrayList:689)
7.1 2 AbstractList$Itr.next(AbstractList$Itr:950, Integer:821)
One can infer that addinvoked ensureCapacity ; andhiniti,add,iterator ,hasNext and nextwere invoked in order by the same
method (not shown here), since they have the same thread
identier and depth of the call stack. hinitiis a special name
reserved for constructors. Although an execution trace from
a unit test case usually contains relatively few events, it may
still be too large to precisely infer related methods.
We next analyze the execution trace in order to remove
irrelevant events. Many heuristics are possible here; we pre-
fer to use two heuristics which were also used in [21, 16]
and appear to work well: keep only events corresponding to
methods (1) which are dened in the user-specied target
package, and (2) which are directly invoked by methods of
the class that declares the main entry of a test case. Our ra-
tionale for using these heuristics is that unit tests are rarely
written for interactions among multiple packages, and that a
unit test consists of one core class for performing the actual
test and other utility classes for supporting the core class.
All the relevant events are then partitioned into groups
of related events. Two events are directly related i they
share at least one common argument, and related i they
are connected through a sequence of directly related events.
For example,hiniti(event 1) and add(event 2) are directly
related due to ArrayList:689 , andhiniti(event 1) and next(event
7) are related through iterator (event 4).
An event specication is then created for each partition.
For each object used as a receiver in a partition, its type is
generalized to the least specic type that species all meth-
ods involving that object. Then, the least specic type and
all the involved methods (after their declaring types are gen-
eralized to the least specic types) are added as a parameter
and, respectively, methods. For the trace above, e.g., a par-
tition including AbstractList:689 and AbstractList$Itr:950 is rst
generated. Then, AbstractList:689 is generalized to AbstractList
because AbstractList species all involved methods. As a re-
sult, a parameter AbstractList and the generalized methods
(AbstractList.hiniti,AbstractList.add and AbstractList.iterator ) are
added. Similarly, AbstractList$Itr:950 adds a parameter Iterator
and two methods ( Iterator.hasNext and Iterator.next ). These two
parameters and ve methods form an event specication.
Filtering out generics parameters. Generics may
yield undesirable event specications. Consider, for exam-
ple, the following execution trace ( Locale is a generic type):
1. ArrayList.<init>(ArrayList:62)
2. ArrayList.add(ArrayList:62, Locale:57)
3. AbstractList.iterator(ArrayList:62, AbstractList$Itr:519)
4. AbstractList$Itr.hasNext(AbstractList$Itr:519)
5. AbstractList$Itr.next(AbstractList$Itr:519, Locale:57)
6. ArrayList.<init>(ArrayList:1279)
7. ArrayList.add(ArrayList:1279, Locale:57)
The above event specication learner would identify [ hasNext ,
next,hiniti,add] (events 4, 5, 6 and 7) as the interaction on
hArrayList:1279 ,AbstractList$Itr:519 ,Locale:57i(ArrayList and Ab-
stractList$Itr are subclasses of AbstractList and Iterator , respec-
tively). This interaction is spurious as it is about concep-
tually unrelated objects ArrayList:1279 and AbstractList$Itr:519
(AbstractList$Itr:519 is an iterator for ArrayList:62 ), which hap-
pen to be related due to Locale:57 .
The above spurious interaction is caused by the fact that
AbstractList.add and Iterator.hasNext bring Locale to the event
specication. A general way to prevent this problem is to
recognize parameters of generic types and avoid adding them
to the event specication. The rationale is that the instan-
tiated types were unknown at the time the generic class was
written and, consequently, they should be kept separate.hasNext  next  3 2 1 
4 iterator  hasNext  
update  update  
0 <init> update  hasNext  Figure 8: FSA inferred by the PFSA learner.
To detect parameters of generic types, jMiner reads the
generic signature (which tells the parameters of generic type)
for each method using JVMTI. Above, it detects that the
parameter of AbstractList.add and the return type of Iterator.next
are generic, and thus it does not add Locale to the event
specication. Then Locale:57 can be ignored and the trace
slicer will not recognize the spurious interaction.
4.2 Learning Parametric SpeciÔ¨Åcations
jMiner takes the event specications learned from unit
tests as explained above and passes them to its core com-
ponent, the trace slicer. As discussed in Sections 3 and 2,
the trace slicer takes an event specication and an execution
trace produced by a program that exercises the target pack-
age, and produces a set of trace slices, each corresponding
to an observed interaction. The generated trace slices are
then passed to any non-parametric specication learner. We
included one such specication learner in jMiner , which we
discuss below. Our learner consists of two components: an
o-the-shelf PFSA learner and an FSA rener.
PFSA learner. A PFSA is an FSA where each transition
is labelled with how often the transition occurs. A PFSA
learner takes a set of strings as input and infers a PFSA.
Several PFSA learning approaches have been proposed [17];
we here adopt the sk-strings algorithm [17], since it performs
well at inferring small FSAs. It rst constructs an FSA that
precisely accepts the input set of strings. Each transition
is then annotated with a frequency, saying how many times
that transition was observed. The sk-strings algorithm then
generalizes by merging states which are sk-equivalent : two
states are sk-equivalent i corresponding sets of bounded
strings (ones that are frequently generated from each of the
two states) are matched. As a result of this approximation,
two states can be merged even when they are not strictly
equivalent, making it possible for the inferred FSA to accept
not only the input strings but also other \similar" strings.
The reader is referred to [17] for more details. After running
the sk-strings algorithm, the learner drops the frequency in-
formation, yielding an ordinary FSA. Figure 8 shows the
FSA inferred by the sk-strings algorithm for our Collection -
Iterator example (Figure 1 shows the desired specication).
FSA rener. Although PFSA learner's approximations
are generally desirable in many application domains, the re-
sulting FSAs turned out to often be overly general in our
domain of mining specications from execution traces, in
that the mined FSAs accept a large number of undesirable
traces. For example, the trace [ hiniti,iterator ,hasNext ,next,
iterator ,hasNext ] is accepted by the FSA in Figure 8, but it is
impossible to occur in any program execution (only one iter-
atorevent can be observed in any interaction between a col-
lection and an iterator). To prevent over-generalized spec-
ications, our specication learner implemented in jMiner
renes the FSA inferred by the sk-strings algorithm.
next  22 21 12 
41 iterator  
update  update  
11 
update  
13 
update  31 
32 update  next  01 <init> 
hasNext  
hasNext  Figure 9: Expanded FSA of Figure 8.
The overall goal of our rener is to eliminate transitions
caused by over-generalization while keeping desirably gen-
eralized transitions. An obvious step for avoiding over gen-
eralization is to remove all the transitions that are never
taken by any of the trace slices provided as the input of
the specication learner. For example, the iterator transition
from state 4 to state 2 in Figure 8 is never taken (the same
Iterator object cannot be created twice), so it can be safely re-
moved. However, that is not enough: the resulting FSA still
accepts infeasible interactions containing multiple iterator s,
e.g., [hiniti,iterator ,hasNext ,update ,iterator ,hasNext ].
The fundamental problem is that PFSA learners do not
take the context into account when merging states, while
the context is important in programming languages. For
example, the two transitions from states 3 and 4 to state 1
in Figure 8 were obtained by the PFSA learner by merging
two contextually dierent states. Modifying a PFSA learner
to take the context into account seems hard. Instead, our
approach is to \reverse engineer" the FSA generated by the
PSFA learner to partly take the context into account. More
precisely, our rener rst expands the inferred FSA as fol-
lows: if a state shasnincoming edges from the other states,
thensis replaced by ncorresponding states ( s1;s2;:::;sn)
in order to dierentiate the originating state. Figure 9 shows
the expanded FSA of the one in Figure 8. States 1 2and 1 3
indicate that an iterator has been already used, whereas
state 1 1indicates that no iterators have been used.
Using the expanded FSA, the rener removes all the tran-
sitions that are never taken by the given trace slices (i.e.,
caused by over-generalization), in our case 1 2!21, 13!21,
and 4 1!22. Then the rener nally eliminates the states
with no incoming transitions and merges states that have the
same outgoing transitions. For example, state 2 2is elimi-
nated, and states 1 2;13and states 3 1;32are merged, respec-
tively. The resulting FSA for the one in Figure 9 is shown
in Figure 1. The reader is referred to [6] for more details.
5. EV ALUATION OF JMINER
We applied jMiner to mining specications in four pack-
ages of OpenJDK 6: java.util ,java.io ,java.lang and java.net .
OpenJDK 6 contains various unit tests and is well docu-
mented, allowing us to validate the mined specications. Se-
lecting unit tests of a specic package (for event specication
learning) is easy because the unit tests are well structured.
We used execution traces obtained from the DaCapo bench-Target Event Specications Parametric Specications
package # les # events # les # events
java.util 370 65,854,349
java.io 382 28,835,588 14 88,999,435
java.lang 372 41,784,568
java.net 221 9,429,744 31 10,938,168
Table 1: Traces used in the experiments.
Target Event Specications Parametric Specications
package Slicing Learning
java.io 24 115 24
java.lang 38 112 75
java.net 59 14 1
java.util 59 133 86
Table 2: Times (minutes; Windows, 3GHz, 1GB).
mark suite 9.12 and the Apache JAMES Server 2.3.1 as
training sets for specication mining. DaCapo contains 14
programs and provides a harness to execute each program
and validate an execution. We used DaCapo for mining
specications in java.util ,java.io and java.lang , and Apache JAMES
(which contains several test cases for whole-system checking)
for mining specications in java.net . Table 1 shows informa-
tion on the traces used in our experiments. Two kinds of
traces were used: traces for learning event specications and
traces for mining parametric specications. We limited the
execution time for each program in DaCapo to one hour.
The event specication learning stage automatically in-
ferred 51,271 event specications. jMiner has an aggres-
sive lter which automatically discards most of the learned
event specications (though the user can manually intervene
and save or adjust any event specication). The lter rst
deletes methods that can be called anytime (such as get-
ters returning primitive types, toString() , and hashCode() ) and
thus are likely not involved in protocols, and then removes all
event specications having only one non-constructor method
(these lead to obvious patterns). Only 498 dierent event
specications passed jMiner 's lter. 230 of them resulted in
parametric specications, but the other 268 did not, because
DaCapo and Apache JAMES generated no interactions cor-
responding to them:
Target # event # parametric
package specications specications
java.io 145 66
java.lang 82 48
java.net 90 36
java.util 181 80
Table 2 shows the elapsed execution time for three sepa-
rate stages: event specication learning (Section 4.1), trace
slicing (Section 3), and specication learning (Section 4.2).
Table 2 does not include the time spent on running unit tests
and applications. Each number represents the total elapsed
time; e.g., learning 145 event specications for java.io took
24 minutes. Trace slicing accounted for most of the time.
These traces contain an enormous number of events and pa-
rameter instances, and our slicer relates events whenever
they share the same objects, no matter how far these events
are from each other in the trace. Overall, considering that
high-quality specications are invaluable, we believe that the
time spent on trace slicing is a minor aspect.
We next discuss some parametric specications that were
automatically mined by jMiner . More can be found at [12].
1 0 <init>(s)  getOutputStream (s,o) 
2 getInputStream (s,i) 
3 
5 6 read(i)  
write(o)  close(s)  
4 read(i)  
write(o)  write(o)  read(i)  close(s)  
close(s)  Figure 10: Socket specication mined using jMiner
Client socket. Figure 10 shows a specication of a client-
side stream socket. The constructor of Socket connects a new
socket to the peer specied by its arguments. Then, getInput-
Stream and getOutputStream return the input stream and the
output stream, respectively, which enable data transmission
using readand write. The specication states that data trans-
mission can be repeatedly performed in arbitrary order until
the socket is closed, which is consistent with the documenta-
tion. It also states that closecan be invoked multiple times,
which is undocumented but correct. The specication also
correctly suggests that the invocation of closeis optional be-
cause states 4 and 5 are also nal states. In fact, calling close
is recommended, but not mandatory because the connection
is eventually closed when the Socket object is reclaimed.
1 0 <init>(l) getInputStream (e,i) 
2 accept(l, e)  3 
getOutputStream (e,o) 
4 6 5 read(i)  write(o)  
write(o)  7 read(i)  write(o)  close(e)  
close(e)  
Figure 11: ServerSocket specication mined with jMiner.
ServerSocket. Figure 11 shows an inferred specication for
the server-side socket. After a ServerSocket objectlis instanti-
ated, accept listens for a connection and accepts it, returning
a new socket e.getInputStream and getOutputStream return an
InputStream objectiand an OutputStream objectorespectively,
which can be used for data transmission. After these oper-
ations, close can be invoked to close the connection. This
behavior spans over multiple threads in most cases because
multiple clients can connect to the same port represented
by a single ServerSocket object, and a server needs to handle
them simultaneously. The trace slices in our experiments in-
deed involved two threads: the data transfer was processed
in a separate thread. If each thread's trace was considered
separately like in [16], the specication could not be mined.
Collection, iterator. Figure 1 shows a specication of Col-
lection and Iterator . As discussed in Section 1, the specication
states a safety property of Collection and a typical usage pat-
tern of Iterator . In order to mine the specication in Figure 1,
we slightly modied the automatically inferred event spec-
ication that denes the ve methods Collection.hiniti,Collec-
tion.add ,Collection.iterator ,hasNext and next. Knowing that add,
remove and clear are similar (all these methods update the
collection), we grouped the three methods into one hypo-
thetical method, which we called update .<init>(r) read(r)  
0 1 2 close(r)  Figure 12: Reader specication mined using jMiner.
Reader, writer. Figure 12 shows a specication of a Reader
object, stating that readcan be repeatedly called before close.
It does not enforce the invocation of close, similarly to the
Socket specication above. jMiner also mined a similar spec-
ication for Writer . These specications are simple, but can
detect the wrong invocation of readorwrite after close.
6. LIMITATIONS
We have identied, during our experiments, a few limita-
tions of our approach. First, the learning process is limited
to the observed behaviors. This is an inherent limitation of
all dynamic approaches. For example, the specications in
Figures 10 and 11 wrongly enforce the order between get-
InputStream and getOutputStream because this was consistently
observed in the training set. Also, in Figure 13 one may
expect that the specication should state that nextToken is
guarded by hasMoreTokens . Surprisingly, the inferred one al-
lows the invocation of the two methods in an arbitrary order
since it was actually observed that Xalan, an application in
DaCapo, calls nextToken without calling hasMoreTokens .
0 <init>(s)  nextToken (s) 
hasMoreTokens (s) 1 
Figure 13: StringTokenizer spec. mined using jMiner.
After inspecting the source code of Xalan, we could see
that the pattern is not defective because Xalan rst retrieves
the number of tokens by calling countTokens and then consec-
utively calls nextToken as many times as specied by count-
Tokens . Due to countTokens , a specication on StringTokenizer
cannot be stricter than Figure 13. Considering countTokens
as well does not improve the specication because our tech-
nique cannot infer that the return value of this method indi-
cates the number of allowed nextToken calls. This limitation
is inherent to all FSA-based approaches: FSA cannot count.
7. RELATED WORK
Ammons et al. [2] mines specications from execution
traces and user-provided input: functions of interest, at-
tributes for those functions, and a scenario seed. Their
tool extracts a set of API usage scenarios from execution
traces and then passes it to a PFSA learner. Providing at-
tributes requires in-depth knowledge (one should understand
the side-eect of each function); the user should imagine a
hypothetical object corresponding to a scenario, and should
mark a parameter as dene or, respectively, as useif the
parameter changes or depends upon the state of the ob-
ject. Scenarios are identied starting from the seed event,
searching the execution trace along dene -usechain. Having
explicit seed events and using the chain reduce the search
space, but it may result in failing to recognize complete in-teractions. For example, assume the following trace:
1. ArrayList.add(Collection:1)
2. AbstractList.iterator(Collection:1, Iterator:2)
3. AbstractList$Itr.hasNext(Iterator:2)
4. AbstractList.iterator(Collection:1, Iterator:3)
5. AbstractList$Itr.hasNext(Iterator:3)
6. ArrayList.add(Collection:1)
Also suppose that the seed event is iterator (it is the only
event that connects Collection and Iterator ) and that addde-
nes Collection ,iterator denes Iterator and uses Collection , and
hasNext uses Iterator . For example, event 2 depends on event
1 as event 1 denes Collection:1 and event 2 uses Collection:1 .
From these inputs, two scenarios will be extracted: 1 2 3 and
1 4 5. None of them are complete with regards to the inter-
action between Collection and Iterator : none includes event 6
because adddoes not use Collection and, consequently, cannot
be reached from iterator in a scenario. Since the retrieved sce-
narios are incomplete, the PFSA learner will eventually infer
a restricted FSA as shown in Figure 14. Stating that addde-
nes Collection and also uses it does not solve the problem.
In fact, it causes another problem: a scenario that includes
operations on two distinct iterators will be extracted.
hasNext (i) 
next( i) 2 1 3 iterator( c,i) 
0 add(c)  hasNext (i) 
Figure 14: Restricted Collection -Iterator usage pattern.
Pradel and Gross [16] propose a dynamic mining tech-
nique based on collecting from execution traces a list of
related receiver-method pairs up to a user-specied level
of nested method calls. Unlike ours, their technique does
not consider individual interactions separately. Therefore, it
may merge individual interactions and thus infer inaccurate
specications. For example, if the execution trace in Fig-
ure 3 is observed within a method, their technique will not
consider the two interactions separately and, consequently,
infer a faulty specication that allows consecutive calls to
next. Moreover, it cannot infer a specication that spans
over multiple threads, since it creates a separate trace for
each thread; e.g., the specication in Figure 11 cannot be
mined. Furthermore, it may fail to mine specications from
distantly related events if the value of the level of nested
method calls is too small. If, on the other hand, the value
is too large, it may produce specications that include too
many methods and would likely be application-specic.
Yang et al. [22] propose a technique to nd all pairs of
methods that satisfy the predened particular pattern ( ab)
from execution traces. Although their chaining heuristic
composes somewhat more complex patterns, such as ( abc)
(by connecting related specications into a chain), it can-
not infer useful and more complex patterns like in Figure 1.
Gabel and Su [9] extend [22]; their work considers an ad-
ditional pre-dened pattern ( abc). It then combines in-
stances of these basic patterns, generating complex patterns.
Unlike our approach, it neglects parameters; thus, it may
infer noisy specications from sequences of irrelevant events
that happen to match the predened patterns.
Dallmeier et al. [7] also present a technique for mining
FSAs from execution traces. A state in the FSA inferred
by their work represents the results of inspector methods
that observe the internal state, such as isEmpty and hasNext ,
whereas a state in our approach is abstract (e.g., \before
using an iterator"). Associating each state with inspectorscan help users to easily understand the specication, but
it fails to capture implicit states such as \an iterator for a
collection is being used" because no methods in Collection can
observe it. In our approach, the sequence of method calls
can capture those states. Moreover, their work considers
only one object and is essentially non-parametric.
Lorenzoli et al. [15] gives an advanced algorithm to mine
extended nite state machines (EFSMs), i.e., FSMs extended
with state constraints. Their approach proposes no trace
slicing technique, which is at the core of our approach; in-
stead, they assume that the training traces are already given
as separate interactions with constraints. In principle, one
could use state constraints to encode parameter instances,
but considering the huge number of parameter instances en-
countered in our experiments, we believe that would be im-
practical. We have only looked at mining parametric FSAs;
it may, however, be benecial to plug their learner into
jMiner and use the latter for learning EFSMs from trace
slices produced by our algorithm in Section 3.
Acharya et al. [1] proposes a static technique that gener-
ates a set of traces along possible execution paths directly
from the source code, and then produces an API usage pat-
tern from it. Since it mines partial orders, the resulting
specications cannot describe loops; thus, it cannot mine
the specications shown in this paper. Zhong et al. [23] also
presents a static mining technique for sequential patterns
from open source repositories. Unlike our approach, their
tool does not consider individual interactions separately. For
example, if there are multiple distinct interactions on Collec-
tionin a method, their tool can extract a faulty method
call sequence. Since their tool inlines multiple methods, the
probability that a method call sequence consists of multiple
interactions on Collection is high, which makes this approach
improper to mine specications of frequently used classes.
Chen and Ro su [5] introduce trace slicing for monitoring.
There is an inherent duality between parametric specica-
tion monitoring and parametric specication mining: they
both rely on a parametric trace slicing process for identi-
fying interactions, followed either by monitoring the result-
ing trace slices against given specications in the rst case,
or by inferring the specications that best explain the ob-
served trace slices in the second case. However, a blind use
of o-the-shelf trace slicing techniques for monitoring leads
to noisy and inecient trace slicers for mining. It is allowed
for trace slicers for monitoring to generate trace slices corre-
sponding to incomplete or unconnected parameter instances
because such trace slices can be ignored by the underlying
monitor. In the context of mining, however, such trace slices
would result in faulty specications.
8. CONCLUSION
This paper presented a generic and automated approach
to mine accurate parametric specications from execution
traces with minimal eort. The event specication learner
reduces the eort by automatically inferring event speci-
cations from unit tests, and the trace slicer identies inde-
pendent interactions, allowing one to apply various learning
techniques that do not handle parameters. Moreover, our
automaton rener makes the inferred specications more ac-
curate by eliminating spurious transitions. Our experiments
indicate that the technique is eective: it mined many mean-
ingful specications that involve multiple parameters.9. REFERENCES
[1] M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API
patterns as partial orders from source code: from
usage scenarios to specications. In FSE, 2007.
[2] G. Ammons, R. Bod k, and J. R. Larus. Mining
specications. In POPL , 2002.
[3] L. Briand, Y. Labiche, and J. Leduc. Toward the
reverse engineering of UML sequence diagrams for
distributed Java software. IEEE Trans. Software
Engineering , 32(9):642{663, 2006.
[4] F. Chen and G. Ro su. MOP: An ecient and generic
runtime verication framework. In OOPSLA , 2007.
[5] F. Chen and G. Ro su. Parametric trace slicing and
monitoring. In TACAS , 2009.
[6] F. Chen, C. Lee, and G. Ro su. Mining parametric
specications. Technical report, University of Illinois,
2010. URL http://hdl.handle.net/2142/15109 .
[7] V. Dallmeier, C. Lindig, A. Wasylkowski, and
A. Zeller. Mining object behavior with ADABU. In
WODA , 2006.
[8] M. D. Ernst, A. Czeisler, W. G. Griswold, and
D. Notkin. Quickly detecting relevant program
invariants. In ICSE , 2000.
[9] M. Gabel and Z. Su. Javert: fully automatic mining of
general temporal properties from dynamic traces. In
FSE, 2008.
[10] M. Gabel and Z. Su. Symbolic mining of temporal
specications. In ICSE , 2008.
[11] Java Virtual Machine Tool Interface (JVMTI).
http://java.sun.com/javase/6/docs/technotes/
guides/jvmti/index.html .
[12] jMiner Webpage. http://fsl.cs.uiuc.edu/jMiner.
[13] D. Lo and S. Maoz. Mining scenario-based triggers
and eects. In ASE, 2008.
[14] D. Lo and S. Maoz. Mining hierarchical scenario-based
specications. In ASE, 2009.
[15] D. Lorenzoli, L. Mariani, and M. Pezz e. Automatic
gen. of software behavioral models. In ICSE , 2008.
[16] M. Pradel and T. R. Gross. Automatic generation of
object usage specications from large method traces.
InASE, 2009.
[17] A. Raman, J. Patrick, and P. North. The sk-strings
method for inferring PFSA. In ICML , 1997.
[18] M. K. Ramanathan, A. Grama, and S. Jagannathan.
Path-sensitive inference of function precedence
protocols. In ICSE , 2007.
[19] M. K. Ramanathan, A. Grama, and S. Jagannathan.
Specication inference using predicate mining. In
PLDI , 2007.
[20] S. Shoham, E. Yahav, S. Fink, and M. Pistoia. Static
specication mining using automata-based
abstractions. In ISSTA , 2007.
[21] W. Weimer and G. C. Necula. Mining temporal
specications for error detection. In TACAS , 2005.
[22] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and
M. Das. Perracotta: mining temporal API rules from
imperfect traces. In ICSE , 2006.
[23] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei.
MAPO: Mining and recommending API usage
patterns. In ECOOP , 2009.