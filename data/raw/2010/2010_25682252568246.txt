Inferring Models of Concurrent Systems
from Logs of Their Behavior with CSight
Ivan Beschastnikh
 , Yuriy Brun
 , Michael D. Ernst
 , Arvind Krishnamurthy
Department of Computer Science
 School of Computer Science
 Computer Science & Engineering
University of British Columbia University of Massachusetts University of Washington
Vancouver, BC, Canada Amherst, MA, USA Seattle, WA, USA
bestchai@cs.ubc.ca, brun@cs.umass.edu, {mernst, arvind}@cs.washington.edu
ABSTRACT
Concurrent systems are notoriously difï¬cult to debug and understand.
A common way of gaining insight into system behavior is to inspect
execution logs and documentation. Unfortunately, manual inspection
of logs is an arduous process, and documentation is often incomplete
and out of sync with the implementation.
To provide developers with more insight into concurrent systems,
we developed CSight. CSight mines logs of a systemâ€™s executions to
infer a concise and accurate model of that systemâ€™s behavior, in the
form of a communicating ï¬nite state machine (CFSM).
Engineers can use the inferred CFSM model to understand com-
plex behavior, detect anomalies, debug, and increase conï¬dence in
the correctness of their implementations. CSightâ€™s only requirement
is that the logged events have vector timestamps. We provide a tool
that automatically adds vector timestamps to system logs. Our tool
prototypes are available at http://synoptic.googlecode.com/.
This paper presents algorithms for inferring CFSM models from
traces of concurrent systems, proves them correct, provides an im-
plementation, and evaluates the implementation in two ways: by
running it on logs from three different networked systems and via
a user study that focused on bug ï¬nding. Our evaluation ï¬nds that
CSight infers accurate models that can help developers ï¬nd bugs.
Categories and Subject Descriptors: D.1.3 [Concurrent Program-
ming]: Distributed programming
General Terms: Algorithms, Design, Modeling
Keywords: Model inference, log analysis, concurrency, distributed
systems, CSight
1. INTRODUCTION
When a system behaves in an unexpected manner, or when a
developer must make changes to legacy code, the developer faces
the challenging task of understanding the systemâ€™s behavior. To help
with this task, developers often enable logging and analyze runtime
logs. Unfortunately, the size and complexity of logs often exceed a
humanâ€™s ability to navigate and make sense of the captured data.
Permission to make digital or hard copies of all or part of this work for per-
sonal or classroom use is granted without fee provided that copies are not
made or distributed for proï¬t or commercial advantage and that copies bear
this notice and the full citation on the ï¬rst page. Copyrights for components
of this work owned by others than the author(s) must be honored. Abstract-
ing with credit is permitted. To copy otherwise, or republish, to post on
servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE June 01â€“07 2014, Hyderabad, India
Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2756-5/14/06. . . $15.00
http://dx.doi.org/10.1145/2568225.2568246.One promising approach to help developers is model inference.
The goal of a model-inference algorithm is to convert a log of sys-
tem executions into a model, typically a ï¬nite state machine, that
accurately and concisely represents the system that generated the
log. Numerous model-inference algorithms and tools exist to help
debug, verify, and validate sequential programs [11, 42, 43, 10].
Unfortunately, this rich prior body of work is not directly applica-
ble to distributed or concurrent systems. This is because a common
assumption made in model inference is that the underlying set of ex-
ecutions is totally ordered â€” for every pair of events in an execution,
one precedes the other. This assumption is crucial to the inference
algorithmsâ€™ correctness, and running them on logs that are not totally
ordered results in inaccurate models. Unfortunately, this assumption
does not hold for concurrent systems, such as networked systems, for
which events at different nodes may occur without happens-before
relationships [39]. Additionally, most model-inference algorithms
infer ï¬nite state machine (FSM) models, which are inappropriate for
modeling multi-process implementations.
This paper describes a new model-inference technique and a
corresponding tool, called CSight (for â€œconcurrency insightâ€), which
infers a communicating ï¬nite state machine (CFSM) [14] model of
the processes that generated the log. CSight can be applied to logs of
distributed systems, protocol traces, traces of AJAX events in a web-
browser, and other concurrent behavior traces. CSight models have
multiple developer-oriented uses â€” for example, developers can
inspect, query, and check CSightâ€™s models against their own mental
model of the system to ï¬nd bugs. These uses are the focus of our
present work. However, we believe that CSight-generated models
have numerous other applications, such as model-based testing of
concurrent systems, and automated detection of anomalous behavior
as systems are exposed to new workloads and environments.
This paper presents the following four contributions:
1.A novel model-inference algorithm to infer a CFSM model
from a log of vector-timestamped concurrent executions (Sec-
tion 3), and a corresponding tool called CSight.
2.A proof that CSight-generated models are accurate as they
satisfy several key properties of the input log (Section 4).
3.A tool for automatically augmenting existing process-local
logging mechanisms with vector-timestamping logic. This
makes it easy to apply CSight to existing systems (Section 5).
4. A two-pronged evaluation of CSight (Section 6):
-We applied CSight to logs of three systems â€” the stop-and-
wait protocol, the opening/closing handshakes of TCP, and
the replication strategy in the V oldemort [56] distributed
hash table. CSight was effective for uncovering the true
model for each of these systems.Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full citation
on the ï¬rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the author/owner(s). Publication rights licensed to ACM.
ICSEâ€™14 , May 31 â€“ June 7, 2014, Hyderabad, India
ACM 978-1-4503-2756-5/14/05
http://dx.doi.org/10.1145/2568225.2568246
468
send(x)M!x,oA?ack,osend(x)M!x,eA?ack,esend(x)M!x,oA?ack,osend(x)M!x,eA?ack,e1,02,03,34,35,36,67,68,69,910,911,912,12MAs0s1send(x)s2M!x,otimeoutA?ack,es3A?ack,os4send(x)s5M!x,eA?ack,eA?ack,otimeout(b.1) Output model (Sender)A?ack,er0r1M?x,or2recv(x)M?x,or3r4M?x,er5recv(x)A!ack,eM?x,eM?x,eM?x,oA!ack,o(b.2) Output model (Receiver)(a) Input logSenderReceiver2,12,22,35,45,55,68,78,88,911,1011,1111,12M?x,orecv(x)A!ack,oM?x,erecv(x)A!ack,eM?x,orecv(x)A!ack,oM?x,erecv(x)A!ack,eFigure 1: Example input and output of CSight for the stop-and-wait protocol (SA W) [54]. (a) Example input log with a single trace of two processes
running SA W. The two integers at the beginning of each event in the log are the eventâ€™s vector clock timestamp. (b) The CSight-derived CFSM model
of SA W, derived from a log with additional traces (not-shown), consisting of (b.1) the sender process model and (b.2) the receiver process model.
In SA W, the sender transmits messages to the receiver using channel M, and the receiver replies with acknowledgments through channel A. Notation
Q!x means enqueue message xat tail of channel Q, and event Q?x means dequeue message xfrom the head of channel Q. The event send(x) is
a down-call to send xat the sender, and recv(x) is an up-call at the receiver indicating that xwas received. In the SA W implementation, xis a
variable that stands for an arbitrary message string. CSight, however, treats the logged event instances, like â€œsend(x)â€ and â€œtimeoutâ€, as strings and
does not interpret them. The timeout event at the sender triggers a message re-transmission after some internal timeout threshold is reached. The
â€œalternating bitâ€ is associated with each message and is appended to a message before it is sent. For example, the ï¬rst (and every odd) message sent
by the sender is represented as x,o (ofor odd) while every even message sent by the sender is encoded as x,e (efor even).
-We performed a user study with a class of 39 undergraduates
to evaluate the efï¬cacy of CFSM models in ï¬nding bugs.
We found that CFSM models are just as useful in ï¬nding
implementation bugs as time-space diagrams, a popular
alternative for visualizing concurrent executions.
We start with an overview of the CSight algorithm (Section 2).
2. CSIGHT OVERVIEW
CSightâ€™s input is a log of observed system execution events, and its
output is a model that describes the concurrent system that generated
the log. An input log consists of execution traces of the system. A
trace is a set of events, each of which has a vector timestamp [25,
45]. Vector time is a standard logical clock mechanism that provides
a partial order of events in the system. Section 5 describes a tool
that automatically adds vector time tracking to existing systems.
Figure 1(a) shows an example input log generated by two pro-
cesses executing the stop-and-wait protocol [54]. In this protocol, a
sender process communicates a sequence of messages to a receiver
process over an unreliable channel. The receiver must acknowledge
an outstanding message before the sender moves on to the next
message. If a message is delayed or lost, the sender retransmits the
message after a timeout.
Figure 1(b) shows CSightâ€™s output â€” a communicating ï¬nite
state machine [14] (CFSM) model. A CFSM models multiple pro-
cesses, or threads of execution, each of which is described by a ï¬nite
state machine (FSM). In the standard CFSM formalism, processes
communicate with one another via message passing over reliable
FIFO channels. However, unreliable channels can be simulated by
replacing each unreliable channel with a lossy â€œmiddleboxâ€ FSM
that non-deterministically chooses between forwarding and losing a
message. The model in Figure 1(b) handles message loss, but the
lossy middlebox is not shown in the diagram.
We use the CFSM formalism because it is similar to the widely
known FSM formalism. CFSMs are well-established in the for-
mal methods community, and we believe (and empirically verify
in Section 6) that a CFSM is intuitive and sufï¬ciently simple for
developers to comprehend. For example, a single-process FSM
in a CFSM can be inspected and understood without needing to
understand the activity of other processes in the system.
CSight infers a CFSM (e.g., Figure 1(b)) by transforming the
input log (e.g., Figure 1(a)) through a series of representations and
analyses. Figure 2 details this process. The CSight process has three
key stages:Stage 1: temporal property mining. CSight mines temporal
properties, or invariants, from the log (steps 1and 2in Figure 2).
For example, for the log in Figure 1(a), CSight would mine the
property â€œevent instance string send(x) always precedes the event
instance string receive(x) â€. Section 3.2 describes all the types of
properties CSight mines. CSight uses these properties to judge the
accuracy of the current model, as it reï¬nes the model to accurately
describe the log.
Stage 2: create initial model. CSight uses the log to build a
compact model (steps 3and 4in Figure 2). This model gen-
eralizes all the executions in the log, and it is inaccurate in that it
admits executions that violate the properties mined from step one.
To build this small model CSight assumes that whenever an event
of a particular type executes, the system must be in a unique state
associated with events of that type. For example, every time the log
has a send(x) event, CSight assumes the system was in the exact
same send(x) state. This creates an overly permissive but highly
compact model.
Stage 3: reï¬ne the model. CSight gradually changes the initial
compact model from stage 2 into a larger model that satisï¬es all of
the mined properties from stage 1 (steps 5and 6in Figure 2). To
accomplish this, CSight checks which of the mined properties are
not satisï¬ed by the present model. A property is not satisï¬ed if the
model allows an execution that violates the property. CSight checks
properties with model checking, which either guarantees that the
property is satisï¬ed by all modeled executions, or ï¬nds a counter-
example execution that violates the property. If a counter-example
exists, CSight reï¬nes the model to eliminate that counter-example
using the CEGAR approach [16]. CSight repeats the model-checking
and reï¬nement loop until all of the mined properties are satisï¬ed, at
which point it outputs the resulting model.
The next section formally describes the CSight process and details
each of the steps in Figure 2.
3. FORMAL DESCRIPTION OF CSIGHT
In Section 4, we will prove three important properties about
CSightâ€™s model-inference process:
-Inferred model ï¬ts the input log. The ï¬nal model accepts all the
observed traces in the input log (see Theorem 1).
-Reï¬nement always makes progress. Every iteration of the re-
ï¬nement process (stage 3 in Section 2) makes progress toward
satisfying all of the mined invariants (see Theorem 2).469LogRegularExpressions
Temporal InvariantsSystemTracesConcrete FSMAbstractFSMInvariantCounter-exampleModel checkingLog parsingTrace linearizationInvariantminingState abstractionUser inputs
CSight outputAllinvariantssatisï¬ed?YesNoModelreï¬nementChannelDeï¬nitions
CFSM Model134562Figure 2: CSight process ï¬‚ow. Section 3 describes the numbered steps.
-Inferred model satisï¬es mined invariants. Every trace accepted
by the ï¬nal model behaves like the observed traces; that is, every
invariant that is true of the observed traces is also true of every
accepted trace (see Theorem 3).
To enable proving these properties, we must ï¬rst formalize the
problem domain. A reader who wishes to only get an intuitive
understanding of the approach can skim this section.
We start by deï¬ning CSightâ€™s inputs (Section 3.1) and the invari-
ants that CSight mines (Section 3.2). Then, we specify how CSight
converts a log into a concrete FSM (Section 3.3) and how CSight
abstracts the concrete FSM into the initial abstract FSM (AFSM)
(Section 3.4). Finally, we describe how CSight model-checks and
reï¬nes the AFSM to satisfy the valid invariants, and how the AFSM
is converted into a CFSM model (Section 3.5).
First, we describe the notation used in the rest of the paper. Given
ann-tuple t, letjtj=n, and for all 1in, let t[i]refer to the
ithcomponent of t; for i>n, let t[i] =e. We write t00=tt0to
denote concatenation of two tuples: t00has lengthjtj+jt0j, and for
all1ijtj,t00[i] =t[i]and for all 1ijt0j],t00[jtj+i] =t0[i]. We
calltapreï¬x oft00iff9t0such that t00=tt0. The projection function
pmaps a tuple tand a set Sto a tuple t0such that t0is generated from
tby deleting all components of tthat are not in S. Finally, we use
the symbol Ë†to denote variables that represent abstract objects in the
modeling process and to differentiate these from concrete features
of the input log. For example, for a logged (concrete) event instance
ethe corresponding abstract event type is denoted as Ë† e.
3.1 Expected Log Input
To use CSight, the user must provide an input log, a set of user-
deï¬ned regular expressions, and a set of channel deï¬nitions (step
1in Figure 2). The regular expressions determine which log lines
are parsed (and which are ignored), what part of a line corresponds
to a vector timestamp, and which local, send, or receive event the
line represents. The channel deï¬nitions are used to associate send
and receive events with inter-process channels.
Currently, CSight requires the input log to contain only complete,
error-free executions. Lifting this requirement is future work.The rest of this section formally describes the structure of the
input log. We assume that an input logLis produced by a system
composed of hprocesses, indexed from 1toh. The log contains
multiple system traces , each of which represents a single concurrent
execution of the system. A system trace consists of a set of event
instances logged by different processes and a happens-before rela-
tion [39] (a strict partial ordering over event instances). For example,
the log in Figure 1(a) contains a single system trace; in this trace the
vector timestamps encode the partial order.
Deï¬nition 1 (System trace) .Asystem trace is the pair S=hT;i,
where T=[Tiis the union of a set of process traces (see Def. 2),
one per process; and is the happens-before relation. This relation
partially orders event instances at different processes and totally
orders event instances (see Def. 3) in each process trace Tiaccording
to their positions in the trace. That is, 8ei=hË†e;i;ki2Ti,e0
i=
hË†e0;i;k0i2Ti,eie0
i() k<k0.
Smust satisfy three communication consistency constraints: (1)
every sent message is received, (2) only sent messages are received,
and (3) sent messages on the same channel must be received in FIFO
order. The validity of the communication consistency constraints #1
and #3 depends on the underlying message passing protocol.1
We express the above three constraints with a bijection between
message send and message receive event instances for every pair of
processes. For all i;j, letSi jTbe the send events along channel
ci j, and let Ri jTbe the receive events along channel ci j. Then
8i;j;9a bijection f:Si j!Ri j, such that:
1.f(s) =r=)sr
2.8s1;s22Si j;s1s2=)f(s1)f(s2).
A system trace is composed of multiple process traces, and each
process trace is the set of event instances generated by a speciï¬c
process. We assume that each event instance is given a unique
position kin a consecutive order, from 1 to the length of the trace.
Deï¬nition 2 (Process trace) .For the process i, aprocess trace is a
setTiof event instances, such that 8k2[1;jTij],9hË†e;i;ki2Ti, and
hË†e1;i;k1i2TiandhË†e2;i;k2i2Ti=)k1=k2.
The execution of each process generates a sequence of event
instances, each of which has an event type from a ï¬nite alphabet of
process event types. These event types can be local events, message
send events, or message receive events.
Deï¬nition 3 (Event instance) .For a process i, anevent instance
is a triple e=hË†e;i;ki, where Ë†eis the event type of e, and k1is
an integer that uniquely indicates the order (position) of the event
instance, among all event instances generated by process i. When
the value of kis not important, we denote this triplet as ei.
Finally, we assume a ï¬xed set of channels, each of which is used
to connect one sender process to one receiver process. Each of the
send and receive event types is associated with a channel.
Deï¬nition 4 (Channel) .Achannel ci jis identiï¬ed by a pair of
process indices (i;j), where i6=jandi;j2[1;h]. Indices iand j
denote the channelâ€™s sender andreceiver process, respectively.
We use the standard notation !to denote send events, ?to denote
receive events, and use labels for channels. For example, in Figure 1,
the event M!x,e is a send of message x,eon channel M.
1In this paper we focus on TCP, which satisï¬es both assumptions.
Generally, TCP is used by the complex systems that CSight targets.
Removing these assumptions is future work (see Section 8).4703.2 Invariant Mining
CSight uses the log to mine a set of temporal invariants â€” linear
temporal logic expressions â€” that relate events in the log (step 2in
Figure 2). These invariants (Def. 5) are true for all of the observed
execution traces. CSight guarantees that the ï¬nal inferred CFSM
model satisï¬es all the mined invariants.
Deï¬nition 5 (Event invariant) .LetLbe a log, and let Ë†aiand Ë†bj
be two event types whose corresponding event instances, aiand
bj, appear at least once in some system trace in L. Then, an event
invariant is a property that relates Ë†aiand Ë†bjin one of the following
three ways.
Ë†ai!Ë†bj:An event instance of type Ë†aat host iisalways followed
byan event instance of type Ë†bat host j. Formally:
8hT;i2 L;8ai2T;9bj2T;aibj.
Ë†ai6!Ë†bj:An event instance of type Ë†aat host iisnever followed by
an event instance of type Ë†bat host j. Formally:
8hT;i2 L;8ai2T;69bj2T;aibj.
Ë†ai Ë†bj:An event instance of type Ë†aat host ialways precedes an
event instance of type Ë†bat host j. Formally:
8hT;i2 L;8bj2T;9ai2T;aibj.
For example, one invariant of the stop-and-wait protocol model
in Figure 1 is M?m-0!A?a-0 . The invariant types and the cor-
responding mining algorithms are described in more detail in [9].
The above invariant types are also exactly the most frequently ob-
served speciï¬cation patterns formulated by Dwyer et al. [24] for
serial systems.2In our experience, these invariants were sufï¬cient
for capturing key temporal properties of the systems that produced
the logs we considered.
3.3 Deriving a Concrete FSM
In step 3of Figure 2, CSight creates a concrete FSM that accepts
all possible linearizations of the partially ordered system traces in the
log. The concrete FSM model closely ï¬ts the logged observations,
but it is not a concise model. Later, we will show how CSight uses
abstraction to make the concrete FSM concise.
3.3.1 Concrete State
To deï¬ne a concrete FSM we need to introduce notions of state
that describe the concrete observations in the log. For this, we will
deï¬ne process states, channel states, and system states.
Deï¬nition 6 (Local process state) .Each process begins execution
in an initial state, qe
i, and after executing a sequence sof process i
event instances, the process enters state qs
i. More formally, let Libe
the set of process itraces in a log L, then the set of process ilocal
states is Qi:
Qi=fqe
ig[
fqs
ij9t2Li;sis a preï¬x of tg
We call qs
iaterminal state for process iif and only if s2Li.
Now, we deï¬ne the global process state and global channel state
that together make up the system state.
Deï¬nition 7 (Global process state) .Aglobal process state q=
hq1;:::; qhiis ah-tuple that represents the state of all processes in
the system. That is, q2Q=Q1 Qh, with qi2Qidenoting a
state at process i.
2Scope is constrained to a trace (i.e., global scope). The translation
is not one-to-one: Ë†a!Ë†bis Dwyer et al.â€™s Existence pattern when Ë†a
is the start event that precedes every trace, and is otherwise Dwyer
et al.â€™s Response pattern. Another example is 8Ë†b;Ë†a Ë†b, which is
Dwyer et al.â€™s Universality pattern.A channel contains all sent messages not yet received. For each
channel ci j, a (possibly empty) ï¬nite set of messages Mi jare the
only messages that can be sent andreceived onci j.
Deï¬nition 8 (Channel state) .Thechannel state wi jof a channel ci j
is a tuple of variable length whose entries are messages that can be
sent and received along ci j. That is, wi j2(Mi j).
Deï¬nition 9 (Global channel state) .Aglobal channel state wis a
set of channel states for all channels in the system. More formally,
w=fwi jjwi j2(Mi j)g. We reuse eto also stand for a global
channel state with all channels empty. Further, we denote the set of
all possible global channel states M.
Finally, we represent the system state as a pair of global process
state and global channel state, hq;wi2QM.
3.3.2 Transitions
Next, we specify how a sequence of event instances impacts the
state of the system. For this, we deï¬ne a process transition function,
di, which maps a process istate and an event instance to a new state.
Deï¬nition 10 (Process transition function) .LetEibe the set of all
process ievent instances in a log Land let Libe the set of process i
traces in L. Then, the process transition function for a process iis
di:QiEi!Qi, such that
di(qs
i;ei) =qsei
i()9 t2Li;(sei)is a preï¬x of t.
As an example that illustrates di, assume that states are the nat-
ural numbers: Qi=N, and event instances Eiare totally ordered:
9g:Ei!N. Then, we can deï¬ne di(qi;ei)as the number that is
formed by concatenating qiandg(ei).
Notice that dihas a distinguishing property â€” two local process
states are different if they were generated by two distinct sequences
of events. Or, more formally:
1.ei6=fi() di(qi;ei)6=di(qi;fi)
2.qi=q0
i() di(qi;ei) =di(q0
i;ei)
3.3.3 The Concrete FSM
CSight uses the system traces parsed from a log Lto construct a
concrete FSM FL(step 3in Figure 2). This FSM represents the
observed, concrete executions of the whole system. Each state in the
concrete FSM is a tuple of the individual process states and channel
contents (for all processes and channels in the system). A channelâ€™s
content is computed from the sequence of observed message sends
and receives in the trace. Process states, however, must be inferred,
and are assumed to be uniquely determined by the process history.
In other words, for a speciï¬c sequence of events at a process, CSight
creates a single unique anonymous process state. Figure 3 illustrates
how the anonymous process states and the corresponding concrete
FSM are derived from a set of input system traces.
A key property of FLis that it accepts all linearizations of all
traces in L, as well as all possible traces that are stitchings of different
concrete traces that share identical concrete states.
Deï¬nition 11 (Concrete FSM) .Given a log L, aconcrete FSM FL
forLis a tuplehS;sI;E;D;STi.
The states of FLare system states: S=QM
There is a unique initial system state: sI=h[qe
1;:::; qe
h];ei
E=fej9hT;i2 L;e2Tg
The transition function Dis the composition of the process
transition functions and handles communication events,
D:QME!QM, and D(hq;wi;ei) =hq0;w0i;where:471p1p2p1p2p1p2?mx?myTrace 2Trace 3?myTrace 1s0s1aa!mb!ma!mc
p1p2p1p2
s2cs3!mt0t1?mt2ys0s1as4!mt0t1?mt3xp1p2s0s5bs6!mt0t1?mt2yTrace 2Trace 3Trace 1(a) System traces
(b) Traces with anonymous states
s3,t2[ ]s1,t0[ ]s4,t0[m]s0,t0[ ]as5,t0[ ]b!ms4,t1[ ]?ms4,t3[ ]xs6,t0[m]!ms6,t1[ ]?ms6,t2[ ]ys4,t2[ ]ys6,t3[ ]s2,t0[ ]s3,t0[m]s3,t1[ ]?myc!m
s3,t3[ ]x(c) Concrete FSMxFigure 3: (a) System traces parsed from an input log with three traces,
generated by two processes: p1 and p2. All messages ï¬‚ow from p1 to
p2. (b) The traces from (a) with added per-process anonymous states.
Note the reuse of states s0, s1, t0, t1, and t2. (c) Concrete FSM for the
system traces in (a).
q0
i=di(qi;ei), and q0
j=qjifj6=i.
w0
i j=8
>>><
>>>:wi jm e i=ci j!m
tail e i=ci j?m;wi j=mtail
undeï¬ned ei=ci j?m;wi j[1]6=m
wi j otherwise
The terminal states have empty channels, and each process
is in a terminal state that was derived by executing all of the
event instances for that process in some system trace in L.
ST=fhq;eij8i;qiis terminalg
3.3.4 Validating the Mined Invariants
Although the invariants CSight mines (Section 3.2) are true of the
input traces, in some cases it is not always possible to construct aconcrete FSM model that satisï¬es the invariants and accepts all of
the input traces. This situation is caused by the incompleteness of
the log.
Our technical report [8] describes an invariant validation step that
removes such invariants.
3.4 Abstracting a Concrete FSM
A concrete FSM is not concise â€” it is a DAG whose longest
path is as long as the longest execution â€” and it is not sufï¬ciently
abstract. CSight generates a more concise abstract FSM model from
the concrete FSM, using a process we call state abstraction (step
4in Figure 2). As a reminder, we use the symbol Ë†to denote
variables that represent abstract objects in the modeling process and
to differentiate these from concrete features of the input log.
The concrete FSM FLaccepts all possible linearized sequences
of event instances from executions in a log L. Let Ë†Prepresent a
partitioning of states in FL, that is a partitioning of QM(we
usebold font to denote a set of sets)3. CSightâ€™s aim can now be
deï¬ned as deriving an abstract FSM (AFSM) Ë†AL(Ë†P)whose states
are partitions in Ë†Pand that accepts sequences of events â€” rather than
event instances . Transitions between states (partitions) in Ë†AL(Ë†P)are
generated through existential abstraction: there is a transition from
Ë†P12Ë†PtoË†P22Ë†Pon event type Ë†eiff there are concrete states s1and
s2such that s12Ë†P1;s22Ë†P2;and there is a transition from s1tos2
on some event instance e, corresponding to Ë†e. Note that Ë†AL(Ë†P), like
the concrete FSM FL, accepts all of the linearized event instance
sequences. We now formally deï¬ne Ë†AL(Ë†P).
Deï¬nition 12 (Abstract FSM (AFSM)) .For a log L, letFL=hS,sI,
E,D,STibe the concrete FSM for L, and let Ë†Pbe a partitioning of
S. Then, an abstraction of FL, or an abstract FSM ofL, is an FSM
Ë†AL(Ë†P) =hË†P,Ë†PI,Ë†E,Ë†D,Ë†PTi, where
Initial states in Ë†AL(Ë†P)are those partitions that contain the
initial concrete state: Ë†PI=fË†P2Ë†PjsI2Ë†Pg.
Transitions in Ë†AL(Ë†P)are event types that correspond to event
instances in the concrete FSM: Ë†E=fË†ej9e;e2Eg.
A transition between two partitions in Ë†AL(Ë†P)exists if and only
if there is a corresponding concrete transition between some
two concrete states in the two partitions: Ë†D(Ë†P;Ë†e) = Ë†P0()
9q2Ë†P;q02Ë†P0;e2E;D(q;e) =q0.
Terminal states in Ë†AL(Ë†P)are those partitions that contain a
terminal concrete state: Ë†PT=fË†P2Ë†PjST\Ë†P6=/0g.
An important feature of an AFSM is that it generalizes observed
system states. A partition contains a ï¬nite number of observed sys-
tem states, but through loops with transitions that modify channel
state, an AFSM can generate arbitrarily long channel contents, lead-
ing to an arbitrarily large number of system states. We may not have
observed these system states, but an AFSM model generalizes to
predict that they are feasible.
CSight uses a ï¬rst- k-in-channels partitioning strategy for gen-
erating an initial AFSM for a concrete FSM. This partitioning as-
signs two system states to the same partition if and only if the
ï¬rst- kmessage sequences in the channel states of the two states
are identical. For example, suppose a system has two channels,
c12andc21, and there are three concrete states: s1,s2, and s3.
Lets:channels denote the channel contents for state sand suppose
thats1:channels =fc12:[];c21:[m]g,s2:channels =fc12:[];c21:
[m;m]g, and s3:channels =fc12:[l];c21:[m]g. Then the ï¬rst-1 con-
tents of s1ands2arefc12:[];c21:[m]g(the second mins2:c21is
3We use Ë†forË†Peven though it is a partitioning of states in the
concrete FSM because the partitions in this set represent states in
theabstract FSM. This set links the concrete and abstract FSMs.472Reï¬nementË†A0Ë†A1Ë†Aï¬nalÂ·Â·Â·100%15%10%Abstract FSMs:Invariants satisï¬ed:Â·Â·Â·Model CheckerÂ·Â·Â·CFSMmodelFigure 4: A high-level summary of the CSight reï¬nement process (steps
5and 6in Figure 2). CSight starts with an initial abstract FSM, Ë†A0,
which is reï¬ned to a ï¬nal abstract FSM, Ë†Aï¬nal. This ï¬nal abstract FSM
satisï¬es all of the mined invariants, and is converted into a CFSM that
is returned as output.
not included), while the ï¬rst-1 contents of s3arefc12:[l];c21:[m]g.
Therefore, in a ï¬rst-1 partitioning strategy, s1ands2would map to
the same partition, while s3would map to a different partition.
Deï¬nition 13 (First- kpartitioning) .LetSbe a set of system states.
Ë†Pkis a ï¬rst- kpartitioning of Sif8Ë†P2Ë†Pk,hq;wi;hq0;w0i2Ë†P()
8ci j;8g2[1;k];wi j[g] =w0
i j[g].
Finally, a CFSM is a set of per-process FSMs that communicate
over FIFO channels. Channels are reliable, unidirectional, and have
a single sender and receiver process. The alphabet of a process
FSM includes process-local events, and inter-process communica-
tion (message send and message receive ) events. We use the notation
c!mfor a send event of message mon channel c, and the notation
c?mfor a receive event of message mon channel c. Each channel
has its own set of valid messages.
Deï¬nition 14 (Communicating FSM (CFSM)) .A CFSM of hpro-
cesses is a tuple of hprocess FSMs,hF1;F2;:::; Fhi, and a set mes-
sage sets Mto indicate the message types that can be sent by one
process and received at another. For each process i, its FSM is
Ë†Fi=hË†Qi;Ë†Ii;Ë†Ei;Ë†Di;Ë†Tiiand the message set Micontains message types
that can be sent from process iand received by some other process j,
for all j. That is, Mi=[jMi j, where ci j?m2Ë†Ej()9 i;m2Mi j
andci j!m2Ë†Ei()9 j;m2Mi j.
3.5 Model-Checking and Reï¬ning an AFSM
Figure 4 overviews, at a high level, the CSight model-checking
and reï¬nement process and Figure 5 lists an outline of the complete
CSight algorithm. CSight uses the McScM [33] model checker to
check if an invariant holds in the AFSM (step 5in Figure 2). As
McScM model-checks CFSMs and not AFSMs, to use McScM,
CSight converts an AFSM into a CFSM. Further, as McScM reasons
about state (un-)reachability, CSight encodes a temporal invariant in
terms of states that can only be reached if the sequence of executed
events violates the invariant. Both the conversion from an AFSM to
a CFSM and the encoding are described in [8].
Model-checking an invariant produces one of three cases:
(1)The invariant holds in the model. There is nothing more for
CSight to do for this invariant.
(2)The invariant does not hold and McScM ï¬nds and reports a
counter-example CFSM execution. A CFSM execution is a sequence
of events that abides by CFSM semantics (e.g., a process can only
receive a message if that message is at the head of the channel).
Acounter-example CFSM execution is a sequence of events that
violates the invariant. In this case, CSight reï¬nes the AFSM to
eliminate the counter-example (Section 3.5.1) and then re-model-
checks this invariant in case another counter-example for it exists.
(3)McScM fails to terminate within a user-deï¬ned threshold (de-
faulted to 5 minutes). CSight then attempts to check a different1 function CSight (Log L;k):
2 let FL=concrete FSM for L
3 let Ë†A=AFSM for FLwith ï¬rst- kpartitioning Ë†Pk
4 let Ë†CË†A=AFSMtoCFSM (Ë†A)
5 let Invs =MineInvariants (L)
6 foreach Inv2Invs:
7 while ( Ë†CË†Aviolates Inv): // Call to model checker.
8 let Ë† p=counter-example path for InvinË†CË†A
9 // Translate events path Ë† pinË†CË†Ainto Ë†S, a list of
10 // sets of paths in Ë†A,jË†Sj=h
11 let Ë†S=CFSMPathToAFSMPath (p;Ë†CË†A)
12 Ë†A=Refine (Ë†A;Ë†S)
13 Ë†CË†A=AFSMtoCFSM (Ë†A)
14 return Ë†CË†A
Figure 5: An outline of the CSight algorithm. The AFSMtoCFSM
and CFSMPathToAFSMPath procedures are detailed in [8],
MineInvariants is described in [9]. The CSight implementa-
tion also handles model checker timeouts.
Ë†aË†bbaË†P1Ë†P2Ë†P3
Figure 6: An AFSM path, [Ë†a;Ë†b], that can be eliminated by reï¬ning (split-
ting) the abstract state Ë†P2, separating the two concrete states that gen-
erate the abstract path.
invariant ï¬rst before coming back to the invariant that timed out.4
If CSight resolves all invariants, it outputs the model. But, if
McScM repeatedly times out on every invariant, then CSight termi-
nates and does not output a model. We did not observe the latter
case in our experiments.
3.5.1 Reï¬ning an AFSM to Satisfy Invariants
CSight uses counter-example guided abstraction reï¬nement (CE-
GAR) [16] to eliminate a counter-example for an invariant (step
6in Figure 2). Figure 6 illustrates how the concrete states from the
log may generate a counter-example partitions path in the AFSM.
The McScM-generated invariant counter-example is a CFSM exe-
cution. Reï¬ning CFSM states to eliminate a counter-example is chal-
lenging because a single state in the concrete FSM can map to multi-
ple states in the CFSM. Instead, CSight performs partition reï¬nement
in the AFSM. It does this by mapping the McScM-generated CFSM
counter-example into an AFSM counter-example [8].
Note that the AFSM counter-example is a list of setsof AFSM
paths, one set of AFSM paths for each process in the system. This is
because the process-speciï¬c event subsequence of a CFSM execution
maps to potentially multiple paths in the AFSM.
Once the AFSM counter-example is generated, CSight eliminates
the CFSM counter-example by transforming the AFSM into a more
concrete (or less abstract) AFSM. It does so using partition re-
ï¬nement ( Refine in Figure 7). Given an AFSM counter-example,
Refine identiï¬es the set of partitions that stitch concrete observa-
tions, as in partition Ë†P2in Figure 6. It then reï¬nes all partitions
in a set that is smallest across all processes and returns the reï¬ned
AFSM.
4After reï¬ning the model to satisfy one invariant, a different, previ-
ously difï¬cult-to-check invariant may become trivial to model-check.4731 function Refine (AFSM Ë†A, AFSM Event Paths Ë†S):
2 lethË†P;Ë†PI;Ë†E;Ë†D;Ë†PTi=Ë†A
3 // minis an index into Ë†S, denoting a set of process paths
4 // requiring the fewest number of reï¬nements to eliminate.
5 let min=0
6 foreach i2[1;:::; h]:
7 foreach Ë† s2Ë†S[i]:
8 let Ë†P=state sequence for Ë† sinË†A
9 // Find stitching partitions, e.g., Ë†P2in Fig. 6, by
10 // traversing Ë†Pand recording partitions that can be
11 // reï¬ned to eliminate Ë†Pfrom Ë†A.
12 let [Stitch Ë†s=fË†PjË†Pis a stitching state in Ë†Pg
13 if [Stitch Ë†sis empty:
14 next i
15 // Set of stitching partitions shared by those paths in Ë†A
16 // that correspond to strings in Ë†S[i]
17 let [Stitch i=\Ë†s2Ë†S[i][Stitch Ë†s
18 // minis an index that tracks the smallest [Stitch i
19 if min=0 or[Stitch i<[Stitch min:
20 min=i
21 let Ë†P0=Ë†Pwith all partitions in [Stitch minreï¬ned to
22 eliminate all paths in Ë†S[min]
23 // Derive Ë†P0
I;Ë†D0;andË†P0
Tfrom Ë†P0as in Def. 12.
24 let AFSM Ë†A0=hË†P0;Ë†P0
I;Ë†E;Ë†D0;Ë†P0
Ti
25 return Ë†A0
Figure 7: Refine removes an invariant counter-example from an
AFSM. It reï¬nes one of the sets of process paths in Ë†S, selecting the one
that require the fewest reï¬nements. Note that Ë†Sis a list of sets of paths,
one set per process.
A reï¬ned AFSM is more concrete â€” closer to the the concrete
FSM. The reï¬ned AFSM has more partition states, and each partition
state contains fewer concrete system states.
Deï¬nition 15 (AFSM Reï¬nement) .An AFSM Ë†AL(Ë†Q)is areï¬ne-
ment of AFSM Ë†AL(Ë†P)if8Ë†Q2Ë†Q;9Ë†P2Ë†P;Ë†QË†P, and
[
Ë†Q2Ë†QË†Q=[
Ë†P2Ë†PË†P
Next, in Section 4, we prove three key properties of the CSight
process.
4. FORMAL ANALYSIS
We now use the formalisms deï¬ned in the previous section to
prove three results about the CSight model inference process: (1) the
inferred model ï¬ts the input log, (2) the inferred model satisï¬es
mined invariants, and (3) reï¬nement always makes progress.
We begin with an observation: The concrete FSM FLsatisï¬es all
mined, validated invariants5. This is true by construction.
Observation 1 (Concrete FSM satisï¬es mined, validated invariants) .
LetLbe a log, and let Invsbe the set of invariants that are valid in
FL. Then,8Inv2Invs,s2Lang(FL),ssatisï¬es Inv.
5Invariant validation is described in Section 3.3.4 and further de-
tailed in [8]Theorem 1 (Inferred model ï¬ts the input log) .For all logs Land
integers k,CSight (L;k) returns a CFSM model that accepts all
traces in L.
Proof of Theorem 1 .LetË†CË†Abe the model returned by CSight (L;k).
By construction, Ë†Aaccepts all of the traces in Ë†CË†A. Furthermore, Ë†A
is an abstract FSM for FLâ€” the concrete FSM of log L.
All abstract FSMs must at least accept the traces in the concrete
FSM. Therefore, Ë†Aaccepts all of the traces in FL. Since, FLaccepts
all of the traces in Lby construction, Ë†Aaccepts the traces as well,
and therefore Ë†CË†Amust also accept them.
A key property of the Refine procedure in Figure 7 is that it
eliminates a counter-example path from a CFSM. We prove this
next.
Theorem 2 (Reï¬nement progress: Reï¬nement eliminates coun-
ter-examples) .LetË†pbe a CFSM counter-example path for invariant
InvinË†CË†A, let Ë†S=CFSMPathToAFSMPath (Ë†p;Ë†CË†A), and let Ë†A0=
Refine (Ë†A;Ë†S). Then, Ë†pis not a counter-example to InvinË†CË†A0. That
is,Ë†p is not a valid execution of Ë†CË†A0.
Proof of Theorem 2 .Proof by contradiction. Assume that Ë†pis a
sequence of events that is a valid execution of Ë†CË†A0and that Ë†pviolates
Inv. Consider an invocation of Refine (Ë†A;Ë†S).Refine (Figure 7)
uses a non-zero minvalue to compute Ë†P0on line 19 and returns a
CFSM Ë†CË†A0=hË†Fiih
i=1.
ForË†pto be a valid execution in Ë†CË†A0, the sub-sequence of process
ievents Ë†pi,Ë†pi=p(Ë†p;Ë†Ei), must be a valid execution in Ë†Fi, for all i.
The procedure AFSMtoCFSM (line 13 in Figure 5) constructs Ë†Fito
accept Ë†piiff there is a complete path Ë†sinË†A0, such that Ë†pi=p(Ë†s;Ë†Ei).
However, any such Ë†smust also be in Ë†Stitch min, which is used to
compute Ë†P0in Figure 7. Therefore, after reï¬ning Ë†Stitch min,Ë†scan no
longer be a valid path in Ë†A0. Contradiction.
Now, we prove that the CSight procedure in Figure 5 returns a
CFSM model that satisï¬es all of the mined, validated invariants.
Theorem 3 (Inferred model satisï¬es mined invariants.) .For a given
logL, ifCSight outputs a CFSM model then this model satisï¬es
all of the mined, validated event invariants from FL.
Proof of Theorem 3 .For a log Lwith a total of nevent instances,
CSight can reï¬ne the initial abstract FSM for L,AL(Ë†Pk), at most
n 1times. This is because after n 1reï¬nements, each partition
in the abstract FSM must map to exactly one concrete state, and a
singleton partition cannot be reï¬ned further.
Let Ë†Abe the abstract FSM after n 1reï¬nements of AL(Ë†Pk).
Because Ë†Amaps each event instance to a unique partition, it is
indistinguishable from FL, the concrete FSM it abstracts. Therefore,
Lang(Ë†A) =Lang(FL). By Observation 1, FLsatisï¬es all validated
invariants, therefore so does Ë†A.
Since CSight does not terminate until all the validated invariants
are satisï¬ed in the abstract FSM, it either returns Ë†Aafter n 1
reï¬nements, or it returns a smaller (and more abstract) Ë†A0. In both
cases, the returned AFSM satisï¬es all of the validated invariants.
5. LOGGING VECTOR TIMESTAMPS
CSight requires its input logs to be annotated with vector times-
tamps. Vector time is a logical clock mechanism to partially order
events in a concurrent system [25, 45]. To ease using CSight with
concurrent systems, we have built ShiVector6, a tool to automatically
6https://bitbucket.org/bestchai/shivector/474s1s2SC!syn-acks3CS?acks4SC!ackCS?syn
(a) TCP server(b) TCP clients0SC!ï¬ns5s6SC!acks9CS?ackCS?ï¬ns10SC!acks7CS?ï¬ns11CS?acks8SC!acks12SC!ï¬nCS?ackc1c2SC?syn-ackc3CS!ackc4SC?ackCS!sync0c5c6CS!ackc10SC?ï¬n
CS!ï¬nc11SC?ackc7SC?ackc12CS!ackc9CS!ï¬nc13SC?ï¬nCS!ackc8SC?ackSCCSFigure 8: The inferred state machines for the (a) TCP server and (b) TCP client. The server communicates with the client over the SCchannel, and
the client communicates with the server over the CSchannel. Shaded states represent the connection-established states.
compute and insert vector timestamps into Java system logs. ShiVec-
tor does not require modiï¬cation of the systemâ€™s source code, only
recompilation with the ShiVector library added to the classpath.
ShiVector uses aspects (via AspectJ) to intercept socket-based
network communication to piggy-back process vector timestamps on
top of existing application-level protocols.7ShiVector also intercepts
logging events to augment each logged event with a vector timestamp
at the time that the event was logged. Thus, ShiVector automatically
tracks and injects vector timestamps into concurrent systemsâ€™ logs.
6. EXPERIMENTAL EV ALUATION
The CSight prototype uses McScM for model checking and
graphviz for model visualization. In all experiments we used a
value of k=1for the ï¬rst- k-in-channels partitioning strategy. We
evaluated CSight on three sets of logs, produced by: a simulator
of the stop-and-wait protocol; the TCP stack of OS X; and V olde-
mort [56], an open-source project that implements a distributed hash
table [22] and is used in data centers at companies like LinkedIn. We
also carried out a user study with a group of undergraduate students
to evaluate the efï¬cacy of CFSM models in ï¬nding bugs.
6.1 Stop-and-Wait Protocol
We applied CSight to traces from a simulator of the stop-and-
wait protocol described in Section 2. We derived a diverse set
of traces by varying message delays to produce different message
interleavings. CSight mined a total of 66 valid invariants. The
model CSight derived (Figure 1(b)) is identical to the true model of
the stop-and-wait protocol. This experiment was a sanity check to
verify that CSight performed as expected on this well-understood
protocol, when faced with concurrency-induced non-determinism in
interleavings.
6.2 TCP
The TCP protocol uses a three-phase opening handshake to estab-
lish a bi-directional communication channel between two end-points.
It tears down and cleans up the connection using a four-phase closing
handshake. The TCP state machine is complicated by the fact that
packet delays and packet losses cause the end-points to timeout and
re-transmit certain packets, which may in turn induce new messages.
Our goal was to model common-case TCP behavior, so we did not
explore these protocol corner cases.
We used netcat and dummynet [51] to generate TCP packet ï¬‚ow.
We captured packets using tcpdump and then semi-manually anno-
tated the log to include vector timestamps. A subset of the traces
that involve only the the opening and closing TCP handshakes were
fed into CSight.
7We plan to extend ShiVector to interpose on other kinds of inter-
process communication.For the captured TCP log, CSight identiï¬ed 149 valid invari-
ants, some of which are not true of the complete protocol (e.g.,
because the input traces did not contain certain packet retrans-
missions). The CSight-derived CFSM model is shown in Fig-
ure 8. The shaded states s4andc4represent the server and client
connection-established states, which is reached when the two
end-points have successfully set up the bi-directional channel. Tran-
sitions up to these two states model the opening handshake, while
transitions after these states model the closing handshake. The clos-
ing handshake is split into a server-initiated tear-down sequence
(middle row of states) and a client-initiated tear-down (bottom-most
row of states).
The derived model is accurate except for the self-loop on state
s4in Figure 8(a). This loop appears because s4represents both
theconnection-established state and the state after the server
has initiated the closing handshake. This loop appears to contradict
theSC!fin6!SC!fin invariant, which ismined by CSight and is
valid. However, the model checker only considers counter-examples
that terminate. Note that if the loop at s4is traversed twice then
the client will be unable to consume both server finpacket copies
and will enter an unspeciï¬ed reception error state and therefore not
terminate. Such unspeciï¬ed reception states are typically undesir-
able, as they can be confusing. The McScM model checker can be
used to detect these states and further reï¬nement will eliminate them.
Implementing this elimination remains as part of future work.
Figure 8 also illustrates a key feature of CSight â€” the user de-
cides (by specifying a set of line-matching regular expressions) what
information in the log is relevant to the modeling task. Thus, for
each use of CSight, the user decides on the trade-off between com-
prehensibility of the model (e.g., model size) and the amount of
information lost/retained by the modeling process. For example, the
TCP model in Figure 8 is simple to understand, but it omits TCP
sequence numbers, data packets, and other details that were present
in the input log.
6.3 Voldemort Distributed Hash Table
V oldemort [56] implements a distributed hash table with a client
API that has two main methods. put(k,v) associates the value v
with the key k, and get(k) retrieves the current value associated
with the key k. V oldemort is a distributed system as it provides
scalability by partitioning the key space across multiple machines
and achieves fault tolerance by replicating keys and values across
multiple machines.
The V oldemort project has an extensive test suite. We used a
subset of integration tests that exercise the synchronous replication
protocol to generate a log of replication messages in a system with
one client and two replicas. We logged messages generated by client
calls to the synchronized versions of putandgetand captured just475(a) Voldemort Replica 1(b) Voldemort clientc1c2R1-C?put-rec3C-R2!putR2-C?put-reC-R1!putc0R1-CC-R1c4c5R1-C?get-rec6C-R2!getR2-C?get-reC-R1!getr1r0r2R1-C!get-reC-R1?getC-R1?putR1-C!put-re(c) Voldemort Replica 2s1s0s2R2-C!get-reC-R2?getC-R2?putR2-C!put-reR2-CC-R2Figure 9: (a,c) replica models and (b) client model for a three-node Voldemort cluster. â€œreâ€ stands for â€œresponseâ€.
the messages between the client and the two replicas.8Since V olde-
mort does not implement vector timestamps, we used ShiVector
(described in Section 5) to produce a vector timestamped log.
CSight mined 112 valid invariants and generated the model in Fig-
ure 9. This model contains a client FSM and two replica FSMs. As
expected, the replica FSMs are identical. Synchronized V oldemort
operations are serialized in a speciï¬c order, so the ï¬‚ow of messages
forputas well as for getis identical â€” the client ï¬rst executes the
operation at replica 1 and then at replica 2.
We manually inspected V oldemortâ€™s replication code to conï¬rm
that the model in Figure 9 is accurate. This model provides a high-
level overview of how replication messages ï¬‚ow in the system.
However, as with the TCP protocol, the model also abstract away
and omits numerous details, such as what happens when replicas fail.
One feature of CSight is that it allows a developer to focus on those
aspects of system behavior that are important to them. For example,
by not exercising irrelevant system behavior in the ï¬rst place, or by
running CSight with regular expressions that ignore certain logged
behavior in the log parsing stage of the process.
6.4 User Study
To determine whether CFSM models are useful in ï¬nding bugs,
we designed and ran a user study. It is typical for developers to
interpret distributed executions in the form of time-space diagrams.
Therefore, we compared the efï¬cacy of CFSM models against time-
space diagrams in bug-ï¬nding tasks. Throughout the study and in
the oral feedback session that followed, participants were not told
the purpose of the study.
The study focused on two concurrent systems: the stop-and-wait
protocol and V oldemort. We introduced a bug into each system â€”
the sender in the stop-and-wait protocol failed to re-transmit packets
on timeout, and the synchronized V oldemort client sent requests to
all replicas concurrently, instead of blocking on acknowledgment
from each replica. In our experience, both bugs are representative
of real bugs faced by distributed system developers. The root cause
of the stop-and-wait bug is not taking the right action on an event;
the root cause of the V oldemort bug is performing an action at
the wrong time. For each buggy system, we generated: (1) a set
of representative time-space execution diagrams (8 for the stop-
and-wait protocol and 6 for V oldemort), and (2) a CFSM model.
Overall, we created four artifacts for the study â€” tspace-saw and
cfsm-saw (time-space diagrams and CFSM model of the buggy stop-
and-wait protocol), and tspace-vol andcfsm-vol (artifacts for buggy
V oldemort).
The study consisted of an in-class, web-based assignment9in
an undergraduate Introduction to Software Engineering class at
the University of Massachusetts, Amherst. The 39 students who
completed the assignment had, on average, 4.2 years of programming
experience, and 76% of them had never taken a networks course.
8The replicas also communicate with each other to maintain key
availability, but we excluded this communication from the log.
9Available online: http://www.bestchai.net/papers/icse2014_csight_eval/We considered two factors: the model factor (time-space diagrams
vs. CFSM models), and the task factor (stop-and-wait vs. V oldemort).
To account for learning effects, we used a within-participants mixed
design across all 39 participants. We randomly assigned each student
to one of four possible study sequences: htspace-saw ,cfsm-voli,
htspace-vol ,cfsm-sawi,hcfsm-saw ,tspace-voli,hcfsm-vol ,tspace-
sawi. We considered the two bugs to be independent â€” ï¬nding
one bug in one artifact does not help in ï¬nding the other bug in a
different artifact.
Each task consisted of two steps:
1.Each student completed a mini-tutorial on the appropriate
diagram (time-space and CFSM, respectively). To verify their under-
standing, at the end of each tutorial, each student had to answer two
basic questions correctly. They could resubmit their answers until
both were correct.10
2.Each student was given a correct , written description of the
system in English, along with either a set of time-space diagrams or
a CFSM model. The student was asked to respond to a single open-
ended question. For time-space diagrams ( tspace-saw ,tspace-vol )
we asked: â€œList all of the time-space diagrams above that you think
do not conform to the description of the system above. What made
you choose these diagrams?â€ For the CFSM models ( cfsm-saw ,
cfsm-vol ) we asked: â€œHow does the observed model differ from the
intended system description?â€
6.4.1 Results
Students found bugs approximately as well with the CFSM model
as they did with the time-space diagrams that are developersâ€™ current
preferred visualization. For the stop-and-wait protocol, students
who were shown the CFSM were 72% successful in getting the right
answer, while those who were shown the 8 time-space diagrams
were 61% successful. For V oldemort, the success rate with the
CFSM was 72% and the success rate with the 6 time-space diagrams
was 86%.
Students found CFSMs just as useful (for completing the task) as
the small collection of time-space diagrams. These results indicate
that CFSM models can be used to effectively ï¬nd bugs. Moreover,
in practice, developers have to inspect neither 8 nor 6 executions
of the system, but hundreds or thousands. The task of manually
ï¬nding the anomalous time-space diagrams would be infeasible.
The CFSM models, though, will remain roughly of the same size
and complexity regardless of the number of executions. Therefore,
we believe that our results on the utility of CFSMs over time-space
diagrams are conservative, and CFSMs would perform even better
in practice. Our study ï¬nds that they already perform as well as
time-space diagrams tightly focused on the buggy behavior.
Studentsâ€™ oral feedback on the assignment reveals why many
of them preferred the CFSM model. According to many students,
10The average time to complete either tutorial was 5 minutes. Stu-
dents made, on average, 1.8 attempts to answer the tutorial questions
correctly. These measures were similar when the time-space and the
CFSM tutorials were considered separately.476time-space diagrams were difï¬cult to follow, especially for long
executions:
â€œI found the time-space diagrams confusing. It was hard to tell what
was happening when. The [CFSM] models were simpler and made it
clear what state a system was in and I could keep track of that state.â€ â€“
student 1
â€œTime-space diagrams were easy to follow for small time segments. For
longer time segments, you got lost. The other [CFSM] models were
better for longer time.â€ â€“ student 2
Students could compare a CFSM model to their own mental
model, or the model they would draw after reading the system
description:
â€œI read the description and tried to recreate the [CFSM] model myself
ï¬rst. Then, I compared what I drew to the given diagram and found
mistakes. Understanding those mistakes helped me understand the
system a lot better.â€ â€“ student 3
Finally, students mentioned that CFSM models were easier to use
because they did not explicitly model time:
â€œFor the [CFSM] models, I assumed no time delay in the network mes-
sages. It was harder to do in the time-space diagrams because you
cannot ignore the delay there. In CFSMs, you can ignore time at ï¬rst,
and then allow for it.â€ â€“ student 4
7. RELATED WORK
CFSMs can be inferred from manually-labeled message sequence
charts [13]. In contrast, CSight automates the inference by relying on
mined invariants. CFSMs inferred from executions can demonstrate
system properties, such as absence of deadlocks and unspeciï¬ed
receptions [15, 55]. We found that CFSMs also provide a concise
representation of complex concurrent system logs. Another poten-
tially useful inferred model of concurrent systems is class -level
speciï¬cations in the form of symbolic message sequence charts [38].
CSight can use these to merge identical process FSMs, such as the
replica models in Figure 9(a,c).
In addition to inferring models, concurrent system logs can be
used to detect anomalies [35, 44, 57], identify performance bugs [52,
53], and mine temporal system properties [9, 17, 59]. Our focus is
on concurrency and on extracting a model that can aid understand-
ing of more general system behavior. Our own work on mining
temporal invariants of concurrent systems [9] is complementary to
CSight, which needs to mine such invariants from execution logs.
Probabilistic analysis of logs (measuring number, frequency, and
regularity of event occurrences) can help discover concurrent system
execution patterns, which can help the developer better understand
and improve the design of concurrent systems [17]. Logs can also
be used to mine message sequence charts [37], which describe the
process interactions within a concurrent system.
The problem of ï¬nding a short sequence of reï¬nements to produce
a small abstract FSM that satisï¬es all of the valid invariants is NP-
hard [16], and CSightâ€™s design ï¬nds an approximate solution. For
logs of serial systems (totally ordered logs), the problem of automata
inference from positive examples of executions is computable [12]
but NP-complete [30, 5], and the FSA cannot be approximated by
any polynomial-time algorithm [48]. Unlike CSight, prior work on
model inference from totally ordered logs either excluded concur-
rency or captured a particular interleaving of concurrent events [2,
10, 7, 11, 18, 28, 43, 46, 49]. Tomte [1] and Synoptic [10] take a
similar approach to CSight, using CEGAR [16] to reï¬ne models.
Synoptic mines temporal invariants and infers FSM models from
a log of sequential executions, while Tomte infers scalarset Mealy
machines. CSight mirrors Synopticâ€™s inference procedure but uses
a different modeling formalism and algorithms, and works for con-
current systems that log concurrency as a partial order. We believethat modeling concurrency explicitly is crucial to understanding a
concurrent systemâ€™s behavior.
System models can also be inferred from developer-written speciï¬-
cations [4, 19, 21, 29, 31, 36]. Compared to CSight, these techniques
require signiï¬cantly more manual effort from the developer and are
not suitable for legacy systems.
CSight relies on the McScM model checker [33, 32], which repre-
sents a scalability bottleneck. Future work will use the more efï¬cient
Spin model checker [34].
Other distributed system debugging approaches focus on data
(e.g., [3, 6, 26]), as opposed to event execution sequences. Run-
time monitoring approaches can detect execution sequence or data
property violations for error reporting [50, 27, 41, 20] or self-
adaptation [40, 23, 58, 47]. CSight models can be used at runtime to
verify that executions conform to the expected model.
8. DISCUSSION
The vector timestamp tracking and logging by ShiVector (Sec-
tion 5) may affect system performance. However, as is typical for
production systems, ShiVector can be enabled for a small fraction
of the requests. If the collected traces are representative of typical
system behavior, then CSightâ€™s model, too, will be representative.
CSightâ€™s model construction cannot directly eliminate two kinds
of error states [14] â€” unspeciï¬ed reception and deadlock. Unspeci-
ï¬ed reception occurs when a process enters a state with a message
mat the head of its channel, but has no reachable future state that
receives m. A deadlock occurs when no process can send a message
and at least one process cannot reach a terminating state. CSight
does not check if these error states are reachable in the ï¬nal model.
CSight can be extended with such a check (e.g., by using the McScM
model checker), but the check would be computationally expensive.
CSight mines three types of invariants and ensures that the ï¬nal
model satisï¬es the valid invariants. For the invariants to be accurate,
the log must have executions representative of all possible executions
of the modeled system. While we found these invariant types to
be sufï¬cient to infer interesting models in practice, more extensive
invariants can lead to more expressive models.
CSight works for system traces that satisfy certain communication
constraints (Def. 1). For example, CSight cannot model unclean
termination and assumes that each execution terminates with empty
channels. However, in practice, system logs may not satisfy these
constraints. In our future work we will extend CSight to handle
terminal states with non-empty channels.
9. CONCLUSION
Concurrent systems are hard to implement, debug, and verify.
To help with these tasks, we developed CSight, a tool that uses
a partially ordered log of events to infer a concise and accurate
communicating ï¬nite state machine model of the system. CSightâ€™s
accuracy comes from its use of mined temporal properties that relate
events in the log. Our tool prototypes are available for download at
http://synoptic.googlecode.com/. By automatically mining a system
model from logs, CSight has the potential to ease system understand-
ing, debugging, and maintenance tasks.
10. ACKNOWLEDGMENTS
We thank Jenny Abrahamson for her work on ShiVector and
Roykrong Sukkerd for her contributions to the project. This
material is based upon work supported by the United States Air
Force under Contract No. FA8750-12-C-0174 and by IARPA under
Contract No. N66001-13-1-2006.47711. REFERENCES
[1]Fides Aarts, Faranak Heidarian, Harco Kuppens, Petur Olsen,
and Frits W. Vaandrager. Automata learning through coun-
terexample guided abstraction reï¬nement. In the International
Symposium on Formal Methods (FM) , Paris, France, 2012.
[2]Mithun Acharya, Tao Xie, Jian Pei, and Jun Xu. Mining API
Patterns as Partial Orders from Source Code: From Usage Sce-
narios to Speciï¬cations. In the Joint Meeting of the European
Software Engineering Conference and the International Sympo-
sium on the Foundations of Software Engineering (ESEC/FSE) ,
Dubrovnik, Croatia, 2007.
[3]Marcos K. Aguilera, Jeffrey C. Mogul, Janet L. Wiener, Patrick
Reynolds, and Athicha Muthitacharoen. Performance Debug-
ging for Distributed Systems of Black Boxes. Operating Sys-
tems Review (OSR) , 37(5):74â€“89, October 2003.
[4]Dalal Alrajeh, Jeff Kramer, Alessandra Russo, and Sebastin
Uchitel. Learning Operational Requirements from Goal Mod-
els. In the International Conference on Software Engineering
(ICSE) , Vancouver, BC, Canada, 2009.
[5]Dana Angluin. Finding Patterns Common to a Set of Strings.
Journal of Computer and System Sciences , 21(1):46 â€“ 62, 1980.
[6]Paul Barham, Austin Donnelly, Rebecca Isaacs, and Richard
Mortier. Using magpie for request extraction and workload
modelling. In Networked Systems Design and Implementation
(NSDI) , San Francisco, CA, USA, 2004.
[7]Ivan Beschastnikh, Yuriy Brun, Jenny Abrahamson, Michael D.
Ernst, and Arvind Krishnamurthy. Unifying FSM-Inference
Algorithms through Declarative Speciï¬cation. In the Inter-
national Conference on Software Engineering (ICSE) , San
Francisco, CA, USA, 2013.
[8]Ivan Beschastnikh, Yuriy Brun, Michael D. Ernst, and Arvind
Krishnamurthy. Inferring Models of Networked Systems
from Logs of their Behavior with CSight. Technical report,
http://hdl.handle.net/2429/46122 , Univ. of British Columbia,
2014.
[9]Ivan Beschastnikh, Yuriy Brun, Michael D. Ernst, Arvind Kr-
ishnamurthy, and Thomas E. Anderson. Mining Temporal In-
variants from Partially Ordered Logs. Operating Systems Re-
view (OSR) , 45(3):39â€“46, December 2011.
[10] Ivan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael
Sloan, and Michael D. Ernst. Leveraging Existing Instrumenta-
tion to Automatically Infer Invariant-Constrained Models. In
the Joint Meeting of the European Software Engineering Con-
ference and the International Symposium on the Foundations
of Software Engineering (ESEC/FSE) , Szeged, Hungary, 2011.
[11] Alan W. Biermann and Jerome A. Feldman. On the synthesis
of ï¬nite-state machines from samples of their behavior. IEEE
Transactions on Computers (TC) , 21(6):592â€“597, June 1972.
[12] Lenore Blum and Manuel Blum. Toward a Mathematical The-
ory of Inductive Inference. Information and Control , 28(2):125â€“
155, 1975.
[13] Benedikt Bollig, Joost P. Katoen, Carsten Kern, and Mar-
tin Leucker. Learning Communicating Automata from MSCs.
IEEE Transactions on Software Engineering (TSE) , 36(3):390â€“
408, May 2010.
[14] Daniel Brand and Pitro Zaï¬ropulo. On Communicating Finite-
State Machines. Journal of the ACM , 30(2):323â€“342, April
1983.
[15] Xiao J. Chen and Hasan Ural. Construction of Deadlock-free
Designs of Communication Protocols from Observations. The
Computer Journal , 45(2):162â€“173, January 2002.[16] Edmund Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, and
Helmut Veith. Counterexample-guided Abstraction Reï¬ne-
ment. In Computer Aided Veriï¬cation , pages 154â€“169, 2000.
[17] Jonathan E. Cook, Zhidian Du, Chongbing Liu, and Alexan-
der L. Wolf. Discovering models of behavior for concurrent
workï¬‚ows. Computers in Industry , 53(3):297â€“319, 2004.
[18] Jonathan E. Cook and Alexander L. Wolf. Discovering Models
of Software Processes from Event-Based Data. Transactions on
Software Engineering and Methodology (TOSEM) , 7(3):215â€“
249, 1998.
[19] Christophe Damas, Bernard Lambeau, and Axel van Lam-
sweerde. Scenarios, Goals, and State Machines: a Win-Win
Partnership for Model Synthesis. In the International Sym-
posium on the Foundations of Software Engineering (FSE) ,
Portland, OR, USA, 2006.
[20] Darren Dao, Jeannie Albrecht, Charles Killian, and Amin Vah-
dat. Live Debugging of Distributed Systems. In the Interna-
tional Conference on Compiler Construction (CC) , Boston,
MA, USA, 2009.
[21] Guido de Caso, Victor Braberman, Diego Garbervetsky, and Se-
bastian Uchitel. Validation of Contracts Using Enabledness Pre-
serving Finite State Abstractions. In the International Confer-
ence on Software Engineering (ICSE) , Vancouver, BC, Canada,
2009.
[22] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, Gu-
navardhan Kakulapati, Avinash Lakshman, Alex Pilchin,
Swaminathan Sivasubramanian, Peter V osshall, and Werner
V ogels. Dynamo: Amazonâ€™s Highly Available Key-Value Store.
Inthe Symposium on Operating Systems Principles (SOSP) ,
Stevenson, WA, USA, 2007.
[23] Brian Demsky, Michael D. Ernst, Philip J. Guo, Stephen Mc-
Camant, Jeff H. Perkins, and Martin Rinard. Inference and
enforcement of data structure consistency speciï¬cations. In the
International Symposium on Software Testing and Analysis ,
pages 233â€“243, Portland, ME, USA, July 2006.
[24] Matthew B. Dwyer, George S. Avrunin, and James C. Corbett.
Patterns in Property Speciï¬cations for Finite-State Veriï¬ca-
tion. In the International Conference on Software Engineering
(ICSE) , Los Angeles, CA, USA, 1999.
[25] Colin J. Fidge. Timestamps in Message-Passing Systems that
Preserve the Partial Ordering. In the Australian Computer Sci-
ence Conference , pages 55â€“66, University of Queensland, Aus-
tralia, 1988.
[26] Rodrigo Fonseca, George Porter, Randy H. Katz, Scott Shenker,
and Ion Stoica. X-Trace: A Pervasive Network Tracing Frame-
work. In Networked Systems Design and Implementation
(NSDI) , Cambridge, MA, USA, 2007.
[27] Dennis Geels, Gautam Altekar, Petros Maniatis, Timothy
Roscoe, and Ion Stoica. Friday: Global Comprehension for
Distributed Replay. In Networked Systems Design and Imple-
mentation (NSDI) , Cambridge, MA, USA, 2007.
[28] Carlo Ghezzi, Mauro PezzÃ¨, Michele Sama, and Giordano
Tamburrelli. Mining Behavior Models from User-intensive
Web Applications. In the International Conference on Software
Engineering (ICSE) , Hyderabad, India, 2014.
[29] Dimitra Giannakopoulou and Jeff Magee. Fluent Model Check-
ing for Event-Based Systems. In the International Symposium
on the Foundations of Software Engineering (FSE) , Helsinki,
Finland, 2003.
[30] E. Mark Gold. Language Identiï¬cation in the Limit. Informa-
tion and Control , 10(5):447â€“474, 1967.478[31] David Harel, Hillel Kugler, and Amir Pnueli. Synthesis Re-
visited: Generating Statechart Models from Scenario-Based
Requirements. Formal Methods in Software and Systems Mod-
eling , 3393, 2005.
[32] Alexander Heussner, Tristan Gall, and GrÃ©goire Sutre.
Extrapolation-Based Path Invariants for Abstraction Reï¬ne-
ment of Fifo Systems. In the International SPIN Workshop on
Model Checking of Software , Grenoble, France, 2009.
[33] Alexander Heussner, Tristan Le Gall, and GrÃ©goire Sutre.
McScM: A General Framework for the Veriï¬cation of Commu-
nicating Machines. In the International Conference on Tools
and Algorithms for the Construction and Analysis of Systems
(TACAS) , Tallinn, Estonia, 2012.
[34] Gerard J. Holzmann. The Model Checker SPIN. IEEE Trans-
actions on Software Engineering (TSE) , 23(5):279â€“295, May
1997.
[35] Guofei Jiang, Haifeng Chen, Cristian Ungureanu, and Kenji
Yoshihira. Multi-resolution Abnormal Trace Detection Using
Varied-length N-grams and Automata. In the International
Conference on Autonomic Computing (ICAC) , Seattle, WA,
USA, 2005.
[36] Ivo Krka, Yuriy Brun, George Edwards, and Nenad Medvi-
dovic. Synthesizing Partial Component-Level Behavior Models
from System Speciï¬cations. In the International Symposium on
the Foundations of Software Engineering (FSE) , Amsterdam,
The Netherlands, 2009.
[37] Sandeep Kumar, Siau-Cheng Khoo, Abhik Roychoudhury, and
David Lo. Mining Message Sequence Graphs. In the Inter-
national Conference on Software Engineering (ICSE) , pages
91â€“100, Honolulu, HI, USA, 2011.
[38] Sandeep Kumar, Siau-Cheng Khoo, Abhik Roychoudhury, and
David Lo. Inferring Class Level Speciï¬cations for Distributed
Systems. In the International Conference on Software Engi-
neering (ICSE) , Zurich, Switzerland, 2012.
[39] Leslie Lamport. Time, Clocks, and the Ordering of Events in a
Distributed System. Communications of the ACM , 21(7):558â€“
565, July 1978.
[40] Lee Lin and Michael D. Ernst. Improving the Adaptability of
Multi-mode Systems via Program Steering. In the International
Symposium on Software Testing and Analysis , pages 206â€“216,
Boston, MA, USA, 2004.
[41] Xuezheng Liu, Zhenyu Guo, Xi Wang, Feibo Chen, Xiaochen
Lian, Jian Tang, Ming Wu, M. Frans Kaashoek, and Zheng
Zhang. D3S: Debugging Deployed Distributed Systems. In
Networked Systems Design and Implementation (NSDI) , San
Francisco, CA, USA, 2008.
[42] David Lo, Leonardo Mariani, and Mauro PezzÃ¨. Automatic
Steering of Behavioral Model Inference. In the Joint Meet-
ing of the European Software Engineering Conference and
the International Symposium on the Foundations of Software
Engineering (ESEC/FSE) , Amsterdam, The Netherlands, 2009.
[43] Davide Lorenzoli, Leonardo Mariani, and Mauro PezzÃ¨. Auto-
matic generation of software behavioral models. In the Inter-
national Conference on Software Engineering (ICSE) , Leipzig,
Germany, 2008.
[44] Jian G. Lou, Qiang Fu, Shengqi Yang, Ye Xu, and Jiang Li.
Mining Invariants from Console Logs for System Problem
Detection. In the USENIX Annual Technical Conference (ATC) ,Boston, MA, USA, 2010.
[45] Friedemann Mattern. Virtual Time and Global States of Dis-
tributed Systems. In the International Workshop on Parallel
and Distributed Algorithms , pages 215â€“226, Gers, France,
1989.
[46] Tony Ohmann, Kevin Thai, Ivan Beschastnikh, and Yuriy Brun.
Mining Precise Performance-Aware Behavioral Models from
Existing Instrumentation. In the International Conference on
Software Engineering New Ideas and Emerging Results (ICSE
NIER) track , Hyderabad, India, 2014.
[47] Jeff H. Perkins, Sunghun Kim, Sam Larsen, Saman Amaras-
inghe, Jonathan Bachrach, Michael Carbin, Carlos Pacheco,
Frank Sherwood, Stelios Sidiroglou, Greg Sullivan, Weng-
Fai Wong, Yoav Zibin, Michael D. Ernst, and Martin Rinard.
Automatically patching errors in deployed software. In the
Symposium on Operating Systems Principles (SOSP) , pages
87â€“102, Big Sky, MT, USA, 2009.
[48] Leonard Pitt and Manfred K. Warmuth. The Minimum Con-
sistent DFA Problem Cannot be Approximated Within any
Polynomial. Journal of the ACM , 40(1):95â€“142, 1993.
[49] Steven P. Reiss and Manos Renieris. Encoding Program Execu-
tions. In the International Conference on Software Engineering
(ICSE) , Toronto, ON, Canada, 2001.
[50] Patrick Reynolds, Charles Killian, Janet L. Wiener, Jeffrey C.
Mogul, Mehul A. Shah, and Amin Vahdat. Pip: Detecting
the Unexpected in Distributed Systems. In Networked Systems
Design and Implementation (NSDI) , San Jose, CA, USA, 2006.
[51] Luigi Rizzo. Dummynet: a Simple Approach to the Evalua-
tion of Network Protocols. Computer Communication Review
(CCR) , 27(1):31â€“41, January 1997.
[52] Raja R. Sambasivan, Alice X. Zheng, Michael De Rosa, Elie
Krevat, Spencer Whitman, Michael Stroucken, William Wang,
Lianghong Xu, and Gregory R. Ganger. Diagnosing Perfor-
mance Changes by Comparing Request Fows. In Networked
Systems Design and Implementation (NSDI) , Boston, MA,
USA, 2011.
[53] Jaspal Subhlok and Qiang Xu. Automatic Construction of Co-
ordinated Performance Skeletons. In the International Parallel
& Distributed Processing Symposium (IPDPS) , Miami, FL,
USA, 2008.
[54] Andrew S. Tanenbaum and David J. Wetherall. Computer Net-
works . Prentice Hall, 5th edition, 2010.
[55] Hasan Ural and HÃ¼snÃ¼ YenigÃ¼n. Towards Design Recovery
from Observations , volume 3235, chapter 9, pages 133â€“149.
Springer Berlin Heidelberg, 2004.
[56] V oldemort. http://project-voldemort.com, 2013.
[57] Wei Xu, Ling Huang, Armando Fox, David Patterson, and
Michael I. Jordan. Detecting Large-Scale System Problems by
Mining Console Logs. In the Symposium on Operating Systems
Principles (SOSP) , Big Sky, MT, USA, 2009.
[58] Maysam Yabandeh, Nikola Knezevic, Dejan Kostic, and Viktor
Kuncak. CrystalBall: predicting and preventing inconsistencies
in deployed distributed systems. In Networked Systems Design
and Implementation (NSDI) , Boston, MA, USA, 2009.
[59] Jinlin Yang, David Evans, Deepali Bhardwaj, Thirumalesh
Bhat, and Manuvir Das. Perracotta: Mining Temporal API
Rules from Imperfect Traces. In the International Conference
on Software Engineering (ICSE) , Shanghai, China, 2006.479