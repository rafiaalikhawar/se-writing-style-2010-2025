Oracle-Guided Component-Based Program Synthesis
Susmit Kumar Jha
Sumit Gulwani
Sanjit A. Seshia
Ashish Tiwari
Electrical Engineering and Computer Sciences
University of California at Berkeley
Technical Report No. UCB/EECS-2010-15
http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-15.html
February 12, 2010Copyright © 2010, by the author(s). 
All rights reserved. 
 
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission.
 
Acknowledgement 
 
The UC Berkeley authors were supported in part by NSF grants CNS-
0644436 and CNS-0627734, and by an Alfred P. Sloan Research
Fellowship. The fourth author was supported in part by NSF grants CNS-
0720721 and CSR-0917398.Oracle-Guided Component-Based Program Synthesis
Susmit Jha
UCBerkeley
jha@eecs.berkeley.eduSumit Gulwani
MicrosoftResearch
sumitg@microsoft.comSanjit A. Seshia
UCBerkeley
sseshia@eecs.berkeley.eduAshish Tiwari
SRIInternational
tiwari@csl.sri.com
ABSTRACT
We present a novel approach to automatic synthesis of loop-
free programs. The approach is based on a combination of
oracle-guided learning from examples, and constraint-bas ed
synthesis from components using satisﬁability modulo theo -
ries (SMT) solvers. Our approach is suitable for many appli-
cations, including as an aid to program understanding tasks
such as deobfuscating malware. We demonstrate the eﬃ-
ciency and eﬀectiveness of our approach by synthesizing bit -
manipulating programs and by deobfuscating programs.
Categories andSubject Descriptors
D.1.2 [ Programming Techniques ]: Automatic Program-
ming; I.2.2 [ Artiﬁcial Intelligence ]: Program Synthesis;
K.3.2 [ Learning ]: Concept Learning
Keywords
Program synthesis, Oracle-based learning, SMT, SAT
1. INTRODUCTION
Automatic synthesis of programs has long been one of the
holy grails of software engineering. It has found many prac-
tical applications: generating optimal code sequences [19 ,
10], optimizing performance-critical inner loops, genera t-
ing general-purpose peephole optimizers [2, 3], automatin g
repetitive programming tasks [14], and ﬁlling in low-level
details after the higher-level intent has been expressed [2 3].
Two applications of synthesis are of particular interest in
this paper. The ﬁrst is that of automating the discovery
of non-intuitive algorithms (e.g., [8]). The second applic a-
tion, as we show in this paper, is program understanding ,
and more speciﬁcally, program deobfuscation . The need for
deobfuscation techniques has arisen in recent years, espe-
cially due to an increase in the amount of malicious, and
mostly obfuscated, code (malware) [27]. Currently, human
experts use decompilers and manually deobfuscate the re-
sulting code (see, e.g., [21]). Clearly, this is a tedious ta sk
that could beneﬁt from automated tool support.
A traditional view of program synthesis is that of synthe-
sis from complete speciﬁcations. One approach is to give
a speciﬁcation as a formula in a suitable logic [18, 25, 9,
8]. Another is to write the speciﬁcation as a simpler, but
possibly far less eﬃcient program [19, 10, 23]. While these
approaches have the advantage of completeness of speciﬁ-
cation, such speciﬁcations are often unavailable, diﬃcult to
write, or expensive to check against using automated veriﬁ-
cation techniques. In this paper, we propose a novel oracle-
Updated version is available at the following URL:
http://www.eecs.berkeley.edu/~sseshia/pubdir/
icse10.htmlguided approach to program synthesis, where an I/O oracle
that maps a given program input to the desired output is
used as an alternative to having a complete speciﬁcation.
The key idea of our algorithm is to query the I/O oracle on
an input that can distinguish between non-equivalent pro-
grams that are consistent with the past interaction with the
I/O oracle. The process is repeated until a semantically
unique program is obtained. Our experimental results show
that only few rounds of interaction are needed.
We apply the oracle-guided approach to automated syn-
thesis of loop-free programs , those that compute functions of
their input and terminate. Such programs arise in a variety
of application contexts, such as low-level bit-manipulati ng
code, scientiﬁc computing kernels, parts of control softwa re
in graphical languages such as LabVIEW, and even appli-
cations in high-level scripting languages such as Javascri pt
and Ruby that are formed by chaining multiple high-level
operators. A key characteristic of our method is that it is
component-based , meaning that we synthesize a program by
performing a circuit-style, loop-free composition of comp o-
nents drawn from a given component library. We can also
address the challenge of identifying whether the given set
of components is insuﬃcient to synthesize the desired pro-
gram. For this purpose, we additionally require making only
one query to a more expensive validation oracle that checks
whether the program is correct or not.
Our synthesis algorithm is based on a novel constraint-
based approach that reduces the synthesis problem to that
of solving two kinds of constraints: the I/O-behavioral con-
straint whose solution yields a candidate program consistent
with the interaction with the I/O oracle, and the distinguish-
ing constraint whose solution provides the input that distin-
guishes between non-equivalent candidate programs. These
constraints can be solved using oﬀ-the-shelf SMT (Satisﬁa-
bility Modulo Theory) solvers. Traditional synthesis algo -
rithms perform a expensive combinatorial search over the
space of all possible programs. In contrast, our technique
leaves the inherent exponential nature of the problem to the
underlying SMT solver, whose engineering advances over the
years allow them to eﬀectively deal with problem instances
that arise in practice, which are usually not hard, and hence
end up not requiring exponential reasoning.
ContributionsandOrganization.
•We propose a novel oracle-guided approach to synthesis,
where an I/O oracle obviates the need for complete spec-
iﬁcations. Our approach has interesting connections to
results from computational learning theory (Section 5).
•We present an instantiation of the oracle-guided approach
to synthesis of loop-free programs over a given set of com-
ponents (see problem deﬁnition in Section 3). This is en-
abled by a novel constraint-based technique that involves
an interaction between SMT solvers and the I/O oracle(Section 4). We also present an interesting optimization
that leverages biased sampling (Section 4.6).
•We demonstrate the utility of our synthesis technique to
discovery of bit-manipulating programs [28], which are
often needed for optimizing performance (Section 6.1).
These programs are quite unintuitive and can be diﬃcult
for even expert programmers to discover. The upcoming
4th volume of the classic series the art of computer pro-
gramming by Knuth has a chapter on bitwise tricks [12].
•We propose a novel application of program synthesis to
program understanding. We demonstrate this in the con-
text of malware deobfuscation by deobfuscating examples
drawn from and inspired by the Conﬁcker and MyDoom
viruses using our synthesis technique (Section 6.2).
2. MOTIVATINGEXAMPLES
We present two examples in this section to introduce the
synthesis problem and motivate our approach.
2.1 Bit Manipulation
Consider the following programming problem: Given a
bit-vector integer x, of ﬁnite but arbitrary length, construct
a new bit-vector ythat corresponds to xwith the rightmost
string of contiguous 1s turned oﬀ, i.e., reset to 0s. Such
programming problems often arise while developing low leve l
embedded code, network applications or in other domains
where bit-level manipulation is needed.
Let us contemplate writing a formal speciﬁcation for this
problem. The most natural and easiest speciﬁcation involve s
the use of alternating quantiﬁers, where nis the length of x:
∃i,j.{0≤i,j <n ∧(∀k.j≤k≤i=⇒x[k] = 1)
∧(∀k.0≤k<j =⇒x[k] = 0)
∧(x[i+ 1] = 0 ∨i=n−1)
∧(∀k.i<k<n =⇒x[k] =y[k])
∧(∀k.0≤k≤i=⇒y[k] = 0) }
The above speciﬁcation is not easy to write. Moreover, veri-
fying any candidate implementation against the above spec-
iﬁcation is challenging due to the presence of quantiﬁers.
Let us consider writing some sample input-output pairs,
or examples, for the problem. For any input x, it is easy to
provide the corresponding output y. Some example ( x,y)
pairs are (0110 ,0000),(0101,0100),(110110,110000).
Finally, let us contemplate writing a program for the above
problem. A straightforward, but ineﬃcient, implementatio n
is a loop that iterates through the bits of xand zeroes out
the rightmost contiguous string of 1s. Can we synthesize a
shorter and more eﬃcient implementation? It is diﬃcult to
answer this, but it is easy to speculate that the elementary
operations that may be used inside such an eﬃcient imple-
mentation will be the standard bit-vector operators: bit-w ise
logical operations ( |, &,⊕,∼), and basic arithmetic oper-
ations (+,−,∗,/,%).
Given a set of possible elementary operations, and an abil-
ity to generate outputs for given inputs, our oracle-guided
synthesis tool Brahma will synthesize the following nontriv-
ial and tricky procedure for solving the above problem.
1turnOffRightMostOneBitString (x)
2{t1= x-1;t2= (x |t1);t3=t2+1;
3t4= (t3& x); return t4; }
A programmer will require considerable familiarity withbit-level manipulations to come up with such an implemen-
tation. Hence, automated synthesis of such diﬃcult-to-wri te
programs is of great practical signiﬁcance.
2.2 Deobfuscation
A major challenge of dealing with malware is simply to
understand what the malicious code is doing. We introduce
here an example inspired by the obfuscations introduced in
variants of MyDoom, an e-mail virus aﬀecting Microsoft
Windows that became the fastest-spreading virus when it
was ﬁrst released in 2004 [20].
The example involves the construction of the SMTP header
for the e-mail sent by the virus. SMTP requires a prescribed
sequence of messages of diﬀerent types, initially starting
with a “hello” message, followed by the “from”, “reply to”,
and other similar control ﬁelds, followed ﬁnally by the data
segment of the e-mail. The fragment we have constructed
is a program genStringObs , given in Figure 1, which con-
structs a string corresponding to the message type.
We used two types of obfuscations in this example. The
ﬁrst is a control-ﬂow obfuscation drawn from several obfus-
cations given by Collberg et al. [5]. The second obfuscation
is one that is directly used in MyDoom, involving the modi-
ﬁcation of each alphanumeric character in the message type
string by the rot13 substitution cipher [13]. The reader
can appreciate the diﬃculty of decoding exactly what this
program is doing.
Is there a simpler (deobfuscated) program that performs
the same function as genStringObs ? It is diﬃcult to answer
this question. However, looking at the obfuscated code in
Figure 1, it is easier to guess that a deobfuscated program
will probably use the following types of components:
•Conditional if-then-else (ternary) operators,
•Boolean expressions that occur in genStringObs , and
•Operators that return strings of size bounded by size of
the largest string in genStringObs .
Given these components and the obfuscated program gen-
StringObs , our oracle-guided synthesis tool Brahma au-
tomatically computes the (deobfuscated) program given in
Figure 2. The reader can appreciate how much easier this
program is to understand.
3. PROBLEM DEFINITION
The goal is to synthesize a loop-free program using a given
set of base components and using input-ouput examples. We
assume the presence of an I/O oracle that can be queried on
any input. The I/O oracle, when given an input, returns
the output of the desired program (that we wish to syn-
thesize) on that input. We also assume the presence of a
validation oracle that validates the correctness of a candi -
date program. Finally, we assume that we are given a set of
(base) components that should be used as building blocks
in the synthesized program. Each component is given in the
form of its input-output speciﬁcation, which is written as a
logical formula relating the inputs and the outputs of that
component. For ease of presentation, we assume that all
components have exactly one output. We also assume that
all inputs and outputs have the same type. These restric-
tions are easily removed.
Formally, the synthesis problem in our proposed program-
ming methodology requires the following:
•A validation oracle Vthat, given any candidate program1genStringObs(int input)
2{
3a1=1, a2=0; b1=1, b2=0; c1=0; c2=0;
4if (input == 0)
5{ a1 = 0; a2 = 0; b1=0; b2 = 0; }
6else if (input == 1)
7 { c1=0; c2 = 1; }
8else if (input == 2)
9 { a1 =1; a2 = 0; c1=1; c2=1; }
10else if (input == 3)
11 { b1 = 0; b2 = 0; c1=1; c2=1; }
12else return NULL;
13c = 2*c1 + c2;
14if(c == 1) { return rot13("EPCG GB, 7"); }
15else
16if (c == 2) {
17 if (input * (input-1) % 2 == 0)
18 return rot13("EPCG GB", 7);
19 else
20 return rot13("RUYB", 4);
21}
22else {
23 if (b1 ⊕b2) return rot13("ZNVY SEBZ",9)
24 else if ((a1 ⊕a2) = (b1 ⊕b2))
25 return rot13("RUYB", 4);
26 else return rot13("QNGN", 4);
27}
28}
29rot13(char *buf, int sz)
30{
31char *buf1 = malloc((sz+1) * sizeof(char));
32char a;
33while (a =~ *buf)
34{
35*buf1 = (~a-1/(~((a | 32))/13*2-11)*13);
36buf++; buf1++;
37}
38return buf1;
39}
Figure 1: Obfuscated program inspired by MyDoom
1genString(int input)
2{ if(input == 0) return "EHLO";
3else if (input == 1) return "RCPT TO";
4else if (input == 2) return "MAIL FROM";
5else if (input == 3) return "DATA";
6else return NULL;
7}
Figure 2: Deobfuscated version of genStringObs
(constructed from base components), returns a Boolean
answer indicating whether the candidate program is the
desired one or not. We discuss how a validation oracle
can be implemented for the program classes considered
in this paper in Sections 6.1 and 6.2.
•An I/O oracle Ithat, given any program input, returns
the output of the desired program on that input.
•A set of speciﬁcations {/an}bracketle{t/vectorIi,Oi,φi(/vectorIi,Oi)/an}bracketri}ht |i= 1,...,N },
called a library, where ( /vectorIi,Oi,φi(/vectorIi,Oi)/an}bracketri}htis the speciﬁca-
tion for the base component fi, which includes– a tuple of input variables /vectorIiand an output variable Oi
– an expression φi(/vectorIi,Oi) over variables /vectorIiandOithat
speciﬁes the input-output relationship of the i-th com-
ponent.
All variables /vectorIi,Oiare assumed distinct.
The goal of the synthesis problem is to synthesize a pro-
gramPthat can be validated by the validation oracle V,
i.e.,V(P) =true. Furthermore, program Pshould be con-
structed using only the set of base components in the library ,
i.e.”ProgramPshould take /vectorIas its inputs and use the set
{O1,...,O N}as temporary variables in the following form:
P(/vectorI):
Oπ1:=fπ1(/vectorVπ1);...;OπN:=fπN(/vectorVπN);
returnOπN;
where
C1. each variable in /vectorVπiis either an input variable from /vectorI,
or a temporary variable Oπjsuch thatj <i, and
C2.π1,...,π Nis a permutation of 1 ,...,N .
ProgramPabove appears to be a straight-line program,
but, in fact, it can be more complex because the base com-
ponentsfi’s can be complex. In particular, base components
can be “if-then-else” functions, and using these component s,
ProgramPcan describe arbitrary loop-free programs.
We note that the program Pabove is using allcomponents
from the library. We can assume this without any loss of
generality. Even when there is a correct Program Pusing
fewer components, that program can always be extended to
a program that uses all components by adding dead code.
Dead code can be easily statically identiﬁed and removed in
a post-processing step.
We also note that program Pabove is using each base
component only once. We can assume this without any loss
of generality. If there is a Program Pusingmultiple copies of
the same base component, we assume that the user provides
multiple copies explicitly in the library. Such a restricti on
of using each base component only once is interesting in two
regards. First, it can be used to enforce eﬃcient or minimal
programs. Second, it prunes the search space of possible
programs making the synthesis problem ﬁnite and tractable.
Informally, the synthesis problem is to come up with a
program – using only the base components in the given li-
brary – that is accepted by the validation oracle.
4. ORACLE-BASED SYNTHESIS
In this section, we provide our solution for the program
synthesis problem formally described above. Our solution
is based on encoding the space of all possible programs by
a formula (Section 4.1). Given a set of input-output pairs,
we then constrain this formula further so that it encodes
only those programs that work correctly on the given input-
output pairs (Section 4.2). By solving this constraint, we
generate a candidate solution. If the candidate solution is
not the desired program, we provide a way to generate a new
input-output pair (Section 4.3). The overall procedure tha t
combines these parts to solve the program synthesis problem
is presented in Section 4.4. We present enhancements to our
basic procedure in Section 4.6.4.1 Background: Encoding Programs
We present an encoding of the space of well-formed candi-
date programs , that is, of programs Psatisfying constraints C1
and C2, as formulas. This encoding is drawn from recent
work [8]. Note, however, that the material in subsequent
sections depends only on the existence of such an encod-
ing. Our proposed approach can be used with alternative
encodings as well.
Intuitively, the encoding we use involves viewing the space
of candidate programs as all ways of connecting components
from the library that satisfy syntactic and semantic well-
formedness constraints. Each connection is encoded using a n
integer-valued location variable . Put another way, the value
of a location variable determines which component goes on
which location (line-number), and from which location (lin e-
number or circuit input) it gets its input arguments.
The main property of the encoding that our approach re-
lies upon is distilled into the following theorem. This the-
orem states the existence of two formulas (encodings): the
ﬁrst formula ψwfprepresents the set of all syntactically well-
formed programs; whereas the second formula φfuncrepre-
sents the set of all semantic input-output behaviors of a
well-formed program.
Theorem 1.There exists a set of integer-valued location
variablesL, awell-formedness constraint ψwfp(L)overL, a
mapping Lval2Prog , and a functional constraint φfunc(L,/vectorI,O)
overL∪ {/vectorI,O}such that the following properties hold:
•Lval2Prog is a bijective mapping from the set of values L
that satisfy the constraint ψwfp(L)to the set of programs
that satisfy constraints C1 and C2.
•LetL0be a satisfying assignment to the formula ψwfp.
Ifαandβare any candidate input and output values,
then the formula φfunc(L0,α,β)is true iﬀ the program
Lval2Prog (L0)returns the value βon the input α.
The proof of Theorem 1 follows from the results stated in [8].
We now describe the encoding more formally. Let Pand
Rdenote the union of all formal inputs (parameters) and
formal outputs (return variables) of the components respec -
tively, that is,
P:=SN
i=1/vectorIiR:=SN
i=1{Oi}={O1,...,O N}
Any straight-line program constructed using Ncomponents
can be described by a set of location variables L
L:={lx|x∈P∪R}
that contains one new variable lxfor each variable xin
P∪Rwith the following interpretation associated with each
of these variables.
•Ifxis the output variable Oiof the component fi, thenlx
is the line number in the program where the component
fiis used.
•Ifxis thejthinput parameter of the component fi, then
lxis the line number “from where component figets its
jthinput”.
In the above description, line number refers to either a
line of the program, or to some input. For uniformity, each
input in/vectorIis assigned a line number from 0 ,...,|/vectorI| −1 and
the program line numbers then take values from |/vectorI|,...,|/vectorI|+
N−1. LetM=|/vectorI|+N. The variables Ltake values in
the range 0,...,M −1 and these new line numbers have the
following interpretation.
•For 0 ≤j <|/vectorI|, line number jis blank; it takes the valueof thejthinput of the program.
•For|/vectorI| ≤j <M , line number jcontains the ( j−|/vectorI|+1)-th
assignment statement of the original program P.
The well-formedness constraint ψwfp(L), deﬁned below,
encodes the interpretation of the location variables lxalong
with syntactic well-formedness constraints, such as consi s-
tency and acyclicity constraints.
ψwfp(L)def=^
x∈P(0≤lx<M)∧^
x∈R(|/vectorI| ≤lx<M)
∧ψcons(L)∧ψacyc(L)
ψconsdef=^
x,y∈R,x/ne}ationslash≡y(lx/ne}ationslash=ly)
ψacycdef=N^
i=1^
x∈/vectorIi,y≡Oilx<ly
The consistency constraint ψconsencodes that every line
in the program should have at most one component, while
the acyclicity constraint ψacycencodes that every variable
should be initialized before it is used.
The function Lval2Prog returns the program correspond-
ing to a given valuation Las follows: in the ithline of
Lval2Prog (L), we have the assignment Oj:=fj(Oσ(1),..,O σ(t))
iflOj=i,lIk
j=lOσ(k)fork= 1,..,t, wheretis the ar-
ity of component fj, and (I1
j,..,It
j) is the tuple of input
variables/vectorIjoffj. The well-formedness constraint describes
syntactically correct programs, but it does not describe th e
semantics of these programs.
The functional constraint φfunc(L,/vectorI,O) is obtained by tak-
ingψwfp(L) and adding to it constraints capturing the dataﬂow
semantics and semantics of components.
φfunc(L,/vectorI,O)def=∃P,Rψwfp(L)∧φlib(P,R)
∧ψconn(L,/vectorI,O,P,R)
φlib(P,R)def= (N^
i=1φi(/vectorIi,Oi))
ψconn(L,/vectorI,O,P,R)def=^
x,y∈P∪R∪/vectorI∪{O}(lx=ly⇒x=y)
whereφlibrepresents the semantics of the base components
(that relates the inputs and outputs of each component),
andψconnrepresents the dataﬂow semantics (that matches
the inputs and output of the diﬀerent components and the
inputs and output of the overall program with each other,
in accordance with values of location variables).
The formula φfunc(L,/vectorI,O) represents the class of all syn-
tactically well-formed programs P, constructed using only
theNbase components, that on input /vectorIreturn output O.
Hence, we can solve the program synthesis problem by ﬁnd-
ing appropriate values for the Lvariables. We need to ﬁnd
values forLsuch that the input-output behavior of the re-
sulting program matches the input-output behavior speciﬁe d
by the I/O oracle.
A key step in our solution of the program synthesis prob-
lem is to synthesize programs that work for ﬁnitely many
input-output pairs . We discuss this next.
4.2 I/O-behavioralConstraintIn this section, we show how to generate a constraint
whose solution provides a candidate program whose input-
output behavior matches a given ﬁnite set of input-output
examples.
Given a set Eof input-output examples {(αj,βj)}j, we
use the notation Behave Eto denote the following constraint,
which we refer to as I/O-behavioral constraint .
Behave E(L)def=^
(αj,βj)∈Eφfunc(L,α j,βj)
LetL0be a set of values such that Behave E(L0) is true. It
follows from the deﬁnition of the I/O-behavioral constrain t
that the program encoded by L0will give output βj, when-
ever it is given an input αj, for all pairs ( αj,βj) inE. This
property of the I/O-behavioral constraint is stated below.
Theorem 2 (I/O-behavioral Constraint). For any
satisfying solution L0to the I/O-behavioral constraint, the
input-output behavior of the program Lval2Prog (L0)matches
all the input-output examples in the set E.
The proof of the above theorem is immediate from the
deﬁnition of an I/O-behavioral contraint and Theorem 1.
We next check if the program, which is synthesized by
considering ﬁnitely many input-output pairs, is the desire d
program. We want to avoid the use of the validation oracle,
since it is expensive. Here we use what is perhaps the central
idea of our approach: generate a “distinguishing” input that
diﬀerentiates this program from another candidate program .
4.3 Distinguishing Constraint
In this section, we show how to generate a constraint
whose solution provides an input that distinguishes a given
candidate program from another non-equivalent candidate
program, both of which have a given set of input-output
pairs in their respective input-output behavior.
LetEbe a set of input-output pairs. Let Pbe a can-
didate program, deﬁned by values L, whose input-output
behavior matches the set E. SupposePis not the desired
program. Then, there should be some input /vectorIsuch thatP
gives incorrect output on /vectorI. But, how do we ﬁnd such an /vectorI?
IfPis not the desired program, then let us assume that
there is a correct program P′. Clearly, for all input-output
pairs (αj,βj) inE, the program P′should return βjwhen
it is given input αj. But since Pis not the desired program,
whereasP′is the desired program, PandP′should give
diﬀerent outputs on some new input.
We say/vectorIis a distinguishing input if there is another pro-
gramP′whose input-output behavior also matches E, but
PandP′give diﬀerent outputs on the input /vectorI. The con-
straintDistinct E,P(/vectorI), deﬁned below, represents the set of
all distinguishing inputs /vectorIand we refer to it as distinguishing
constraint .
Distinct E,L(/vectorI)def=∃L′,O,O′Behave E(L′)∧φfunc(L,/vectorI,O)
∧φfunc(L′,/vectorI,O′)∧O/ne}ationslash=O′
Theorem 3 (Distinguishing Constraint). Ifαis a
satisfying solution to the distinguishing constraint
Distinct E,P(/vectorI), then there exists a program P′such that
PandP′have diﬀerent behaviors on input α, but have the
same behavior on all the inputs in the set E.The proof of Theorem 3 follows from the deﬁnition of the
distinguishing constraint, Theorem 2 and Theorem 1. We
now have all the ingredients for describing our overall pro-
cedure for solving the synthesis problem.
4.4 Oracle-Guided Synthesis
In this section, we describe our oracle-guided iterative sy n-
thesis procedure. The description uses the I/O-behavioral
constraint and the distinguishing constraint described ab ove.
The procedure works by iteratively synthesizing new pro-
grams that work correctly on more and more inputs. It
starts with a set containing just one arbitrarily chosen inp ut.
In each iteration, the procedure synthesizes a program that
works correctly on the current ﬁnite set of inputs. If such a
program is found, then the procedure attempts to ﬁnd a dis-
tinguishing input. If a distinguishing input is found, then it
is added into the set of inputs for subsequent iterations. In
all other cases, the procedure terminates. It either return s
the correct program, or it notes that the components pro-
vided are insuﬃcient for synthesizing the correct program.
For solving the I/O-behavioral constraint and the dis-
tinguishing constraint, the procedure makes use of a func-
tionT-SAT . Given a formula φ(A), the function T-SAT (φ(A))
searches for values for Athat will make the formula φtrue. If
successful, then T-SAT (φ(A)) returns one such speciﬁc value
forA. Otherwise, it returns ⊥. The function T-SAT is imple-
mented as a call to a Satisﬁability Modulo Theory (SMT)
solver. SMT solvers check for satisﬁability of a ﬁrst-order
formula with respect to underlying background theories [4] .
The pseudo-code for the procedure is given in Figure 3.
The procedure maintains a set Eof input-output examples
constructed by querying the I/O oracle Ion a new input at
the start of the while loop (Line 4) and in each iteration of
the while loop (Line 13). In each iteration of the while loop,
the procedure attemps to synthesize a candidate program P
(represented by L) that satisﬁes the set Eof input-output
examples (Line 6). If it fails, then it returns failure (Line 7).
Otherwise, it checks (in Line 9) whether the candidate pro-
gramPis the semantically unique program that satisﬁes the
given set of input-output examples. A program is semanti-
cally unique if any other program that satisﬁes the given set
of input-output examples produces the same output as the
program for any other input. If Pis the semantically unique
program, then the procedure either returns P(Line 11) or
failure (Line 12) depending on whether the validation oracl e
VvalidatesPor not. If the candidate program is not se-
mantically unique, then an input αis obtained that is added
toEto help narrow down the choice of candidate programs
(Line 13).
The following theorem states the correctness of Proce-
dureIterativeSynthesis . Note that if the inputs /vectorItake
values from a ﬁnite domain, then the number of iterations
of the loop in the procedure is bounded by the total number
of diﬀerent inputs; and hence, in such cases the procedure
is guaranteed to terminate.
Theorem 4.If Procedure IterativeSynthesis , given in
Figure 3, returns a program P, then V(P)is true. If Proce-
dureIterativeSynthesis returns“Components insuﬃcient”,
then there does not exist any program Pconstructed from the
set of base-components such that V(P)is true. Furthermore,
Procedure IterativeSynthesis is guaranteed to terminate
when the inputs /vectorItake values from a ﬁnite domain.IterativeSynthesis():
1// Input: Set of base components used in
2// construction of Behave Eand Distinct E,L
3// Output: Candidate Program
4E:={(α0,I(α0))}//α0is an arbitrary value for /vectorI
5while (1) {
6L:=T-SAT (Behave E(L));
7if(L==⊥)return "Components insufficient";
8α:=T-SAT (Distinct E,L(/vectorI));
9if(α==⊥){
10 P:=Lval2Prog (L);
11 if(V(P))returnP;
12 else return "Components insufficient"; }
13E:=E∪ {α,I(α)}; }
Figure 3: Oracle-guided Synthesis Procedure
Valid program exists with given components  No program exists with given components
1
2Step 12: Discovered semantically unique program P is found ba
for synthesizing valid program.Step 7:  Set E of I/O examples show components insufficient  
incorrect by the validator − no synthesis feasible.
Step 11: Valid program P is returned. 
Figure 4: Termination cases of Synthesis Procedure.
The validation oracle is needed only to ensure cor-
rectness in case 1b.
The proof of the correctness theorem follows immediately
from the description of the procedure in Figure 3, combined
with the properties stated in Theorem 1, Theorem 2 and
Theorem 3. We also illustrate in Figure 4 all three cases in
which Procedure IterativeSynthesis terminates. The ﬁrst
case corresponds to step 7 and the second and third cases
correspond to step 11 and step 12 respectively.
4.5 IllustrationonRunning Example
We illustrate the oracle-guided synthesis approach on the
running example presented in Section 2.1. The problem was,
given a bit-vector integer x, of ﬁnite but arbitrary length,
to construct a new bit-vector ythat corresponds to xwith
the rightmost string of contiguous 1s turned oﬀ.
Our technique starts with a random input 01011 and the
I/O oracle I(the user) is used to obtain the corresponding
expected output 01000. This step corresponds to Line 4 of
the algorithm presented in Figure 3.
Given the input/output pair (01011 ,01000), our technique
generates the following candidate program (Line 6): (we giv e
only the expression returned)
(x+ 1) &(x−1)
Then, it checks whether a semantically diﬀerent program can
be generated in Line 8. In this case, our technique generates
the following alternative program and the distinguishing i n-
put 00000:
(x+ 1) &x
The I/O oracle is used to obtain the output 00000 for this
input (Line 13). This is added to the set of input/output
pairsE. Note that the newly added pair rules out one of
the candidate programs, namely, ( x+ 1) & (x−1).
In the next iteration, with the updated set E, the tech-
nique ﬁnds the program−(¬x)&x
and the check in Line 8 generates the alternate program
(((x&−x)| −(x−1))&x)⊕x
and the input 00101. Hence, we add (00101 ,00100) toE.
This rules out ((( x&−x)| −(x−1))&x)⊕x.
Note that at this stage, the program ( x+ 1)&xremains a
candidate, since it was not ruled out in the earlier iteratio ns.
In next four iterations, Brahma generates (01111 ,00000),
(00110,00000), (01100 ,00000) and (01010 ,01000) as input-
output examples and adds them to E. The semantically
unique program generated from the resulting set Eis the
desired program:
(((x−1)|x) + 1)&x.
4.6 Optimization
The basic procedure described above can be improved by
using alternate ways to generate the inputs that are used by
the procedure for synthesis.
IterativeSynthesis uses an SMT solver in two ways:
(a) First, an SMT solver is used to generate a candidate
program that works for the current set of inputs.
(b) Second, an SMT solver is used to generate a new distin-
guishing input on which the currently synthesized program
and the desired program potentially diﬀer.
Although SMT solvers are fast and capable of handling
very large formulas, using them in every iteration compro-
mises eﬃciency. It is tempting to speculate that the use of
SMT solvers for generating a distinguishing input (case (b)
above) can be avoided; for example, by replacing it by a
function that ﬁnds new inputs by sampling the input space
in some way. We explore two alternative ways for sampling
the input space.
SamplingUniformlyatRandom
LetInputs be the set of all possible valuations for the input
variables. Let sample (Inputs ) be a function that returns
a particular input from the input space Inputs by sam-
pling the set Inputs uniformly at random. The function
sample (Inputs ) can be used to ﬁnd a new input, in place
of the call to the SMT solver, in Line 8 of Procedure Iter-
ativeSynthesis . We will call this new variant as Random .
SamplingWith Bias
The second approach we consider is based on biasing the
search for inputs towards a certain part of the input space.
Not all inputs in the input space are equally important. For
example, a program may take an integer input i, but have
the same behavior for all i>5 and have interesting behav-
iors only on values 0 ≤i≤5. For many applications, the
user knows a-priori which inputs are more crucial in deﬁn-
ing the overall program. The idea behind the sampling with
bias strategy is to search for distinguishing inputs by bias ing
the search to this part of the input space.
In the bitvector benchmarks used in this paper, the in-
put space consists of all (tuples of) bitvectors of a certain
bit width. It is well-known that, for a very large class of
commonly-used bitvector functions, the rightmost bits in-
ﬂuence the output more than the leftmost bits.
Property 1 (See [28], Chapter 2). A function map-
ping bitvectors to bitvectors can be implemented with add,
subtract, bitwise and, bitwise or, and bitwise not instruc-
tions if and only if each bit of the output depends only onConstrainedRandomInput:
1//cntis a global variable initialized to 0
2//Kis a parameter (number of rightmost bits to set)
3if (cnt< 2K) {
4α:=sample (Inputs );
5α:=Set rightmost Kbits ofαtocnt;
6cnt:=cnt+ 1; }
7elseα:=T-SAT (Distinct E,L(/vectorI));
Figure 5: Strategy for generating a new input
based on sampling from the input space with an
application-dependent bias.
bits at and to the right of that bit in each input operand.
This suggests that we should bias the sampling so that we
get more variety on the rightmost bits.
The code ConstrainedRandomInput in Figure 5 uses a con-
strained random strategy for generating a new input. It
starts with an input αthat is sampled uniformly at random,
but then it sets its rightmost Kbits to the (rightmost Kbits
in the) number cnt. Sincecntis incremented each time, we
get a new combination in each time. Speciﬁcally, if K= 2,
then in four calls to the Function ConstrainedRandomInput ,
we will get all four combinations – 00, 01, 10 and 11 – in the
rightmost 2 digits of I. The code ConstrainedRandomInput
ﬁnds the ﬁrst 2Kinputs this way. If more are needed, then
it goes back to using the SMT solver. The new variant of
IterativeSynthesis – obtained by replacing the call to the
SMT solver in Line 8 by the code ConstrainedRandomInput
– will be called Constrained Random .
We will compare the performance of IterativeSynthe-
sis,Random , andConstrained Random in Section 6.
5. DISCUSSION
5.1 Choosing BaseComponents
It is reasonable to ask how base components are chosen in
our approach and what happens when the given set of base
components is either insuﬃcient or very large.
The choice of base components is made by the user and is
guided by the application domain. This allows the user to
use his/her knowledge to guide the synthesis and inﬂuence
success. It is not unreasonable to expect users to provide th is
information. In several application domains, there is a nat -
ural choice for the set of base components. For example, a
natural set of base components for synthesizing bitvector a l-
gorithms will contain components that perform bitwise and,
or, not, xor, negation, increment and decrement operations .
In our experiments on synthesizing bitvector programs (Sec -
tion 6), we started with such a set of base components, re-
ferred to as the standard library . If the synthesis procedure
found that this set of components was insuﬃcient, the stan-
dard library was augmented with a set of new components
suggested by the user and the synthesis procedure was re-run
with this extended library .
Nevertheless, choosing a reasonable set of base compo-
nents is crucial for the feasibility of our synthesis approa ch.
The search space of candidate programs grows exponentially
with the number of base components. The strategy of start-
ing with a small set of base components, and then incremen-
tally adding components, can partly avoid the need to dealwith very large set of base components. However, it can be
successful only if the synthesis engine not only synthesize s
correct programs quickly, but also reports infeasibility o f the
synthesis problem quickly. In our experiments, we show that
our technique can detect infeasibility eﬃciently.
Choosing Base Components for Deobfuscation. When
using our program synthesis approach for performing pro-
gram deobfuscation, the base components are picked from
the assignment and conditional statements in the obfuscate d
code. For example, consider the obfuscated program in Fig-
ure 1. Although it is diﬃcult to understand the obfuscated
program, it is easier to guess that the set of important base
components will include if-then-else components and equal -
ity comparators. Similarly, for the other deobfuscation ex -
amples (reported in Section 6), the base components used
for synthesis contain only operators (such as left-shift an d
bitwise-xor) that appear explicitly in the obfuscated code
(see Figure 6).
5.2 Connections to Learning
Our oracle-guided synthesis framework has close connec-
tions to certain fundamental results in computational lear n-
ing theory. We explore these connections in this section.
Our oracle-based model is similar to the query-based learn-
ing model proposed by Angluin [1], but with some important
distinctions. In Angluin’s model, a learner interacts with
an oracle through the use of membership andequivalence
queries in order to learn a target concept . In our setting,
thetarget concept is the program we seek to synthesize. A
membership query is similar to the query we make to an
I/O oracle, except that the former returns a binary answer
whereas the I/O oracle returns an output value. An equiv-
alence query is similar to a query to the validation oracle,
except that, in Angluin’s model, if the candidate concept
is not equivalent to the target concept, the oracle returns
a counterexample as evidence for this non-equivalence. In
our context, since the validation oracle is called only at th e
end, when we are left with a semantically unique program
consistent with the set of examples, such a counterexample
is not needed. Moreover, Angluin’s model treats both kinds
of queries as equally expensive. We make a distinction be-
tween the cheaper queries to the I/O oracle and the more
expensive queries to the validation oracle, which allows us to
optimize our implementation. Finally, our algorithm itera tes
by ﬁnding distinguishing inputs, which is not an operation
supported by Angluin’s model.
Two other results from learning theory also shed light on
why our oracle-based approach is eﬀective in practice.
First, note that our focus on loop-free programs that com-
pute functions of ﬁnite-precision bit-vector inputs indic ates a
connection to the work on learning Boolean circuits. In par-
ticular, the classic result on learning constant-depth Boo lean
(AC0) circuits from a few test inputs [16] provides a partial
explanation for the eﬀectiveness of this strategy. The resu lt
relies on a theorem stating that AC0circuits can be ap-
proximated well by low-degree polynomials, which in turn
are known to be identiﬁable by their behavior on few inputs.
The second relevant result relates to the notion of teach-
ing dimension introduced by Goldman and Kearns [7]. In-
formally, the teaching dimension of a concept class is the
minimum number of examples a teacher (oracle) must re-
veal to uniquely identify anytarget concept from that class.
As our experiments show, we need very few examples to syn-
thesize our target programs in practice, indicating that th eseprograms form a concept class with a low teaching dimen-
sion. Moreover, our algorithm ﬁts closely with a result from
the Goldman-Kearns paper [7], showing that the generation
of anoptimal teaching sequence of examples is equivalent to
a minimum set cover problem. In the set cover problem for
a given target concept, the universe of elements is the set
of all incorrect concepts (programs) and each set Si, corre-
sponding to example xi, contains concepts that are diﬀeren-
tiated from the target concept by this example xi. We can
see that our Procedure IterativeSynthesis computes such
a distinguishing example in each iteration, and terminates
when it has computed a “set cover” that distinguishes the
target concept from all other candidate concepts (the “uni-
verse”). Given this close connection, it does seem that the
classes of functions corresponding to the bit-manipulatin g
and deobfuscation examples we consider have small teach-
ing dimension, and also Procedure IterativeSynthesis is
eﬀective at generating a sequence of examples close to the
optimal teaching sequence.
These connections to learning theory are very intriguing.
We leave a formal exploration of these links to future work.
6. EXPERIMENTAL RESULTS
We present experimental evaluation of our technique and
compare diﬀerent approaches namely IterativeSynthesis ,
Random , andConstrained Random discussed in Section 4.
SetupandBenchmarks.
We have implemented IterativeSynthesis in a tool called
Brahma . It uses Yices 1.0.21 [24] as the underlying SMT
solver. We ran our experiments on 8x Intel(R) Xeon(R)
CPU 1.86GHz with 4GB of RAM. Brahma was able to syn-
thesize the desired circuit for each of the benchmark exam-
ples. Semi-biased Brahma implements Constrained Ran-
domwith the parameter K= 2. Thus, it diﬀers only in ﬁrst
4 steps from Brahma . As mentioned in Section 4, this is
specially targetted towards synthesis of bitvector progra ms.
We selected a set of 25 benchmark examples to evaluate
our technique. 22 benchmarks (P1-P22) are bit-manipulatio n
programs from the book Hacker’s Delight , commonly re-
ferred to as the Bible of bit twiddling hacks [28]. 3 bench-
marks were used as examples to illustrate the use of our tech-
nique for deobfuscation. These benchmarks reﬂect obfusca-
tion strategies from literature on obfuscation techniques [5]
(P23) and Internet worms - Conﬁcker [21] (P24) and My-
Doom [20] (P25). Some of these examples are presented in
Figure 6 and Figure 6.
6.1 Bit-Manipulating Programs
Recall from Section 5.1 that the bitvector benchmarks
were run using a standard library of base components, and
if necessary, an extended library . In Table 1, we report the
runtime when using the standard library (col. 4) and when
using the user-augmented extended library (col. 5), in case
the standard library was not suﬃcient. Note that our tool
quickly terminates when the given library is insuﬃcient.
For bitvector benchmarks, the user plays the role of the
I/O oracle as well as the validation oracle. If the user guar-
antees that the provided set of base components is suﬃcient
to encode the desired solution, then we do not require the
validation oracle. Otherwise, it is theoretically impossi ble
to know whether or not the generated solution is the cor-
rect one without a validation oracle. However, in practice,
our algorithm detects insuﬃciency of the base componentsBench Random Inputs Semibiased Brahma
Names Runtime Iter Runtime Runtime Iter
Standard Lib Extended Lib
1 2 3 4 5 6
P1 1.48 5 0.80* 0.80 3
P2 7.35 11 4.75* 4.75 7
P3 1.60 8 0.65* 0.65 4
P4 1.65 11 0.86* 0.86 6
P5 3.92 8 2.28* 2.28 6
P6 6.22 23 1.64* 1.64 4
P7 1.39 5 0.50* 0.50 5
P8 2.20 11 1.42* 1.42 6
P9 4.95 10 3.85 4.90 6
P10 13.99 14 4.57 3.25 9
P11 24.31 16 2.86 14.27 10
P12 279.49 24 2.64 45.52 12
P13 32.50 9 3.02 6.95 7
P14 14.32 25 3.00 3.66 6
P15 167.84 7 4.50 13.57 6
P16 66.93 10 4.95 18.97 8
P17 217.34 17 5.89 20.62 13
P18 228.78 19 7.98 25.55 6
P19 163.82 13 65.45* 65.45 7
P20 214.14 17 19.30 63.23 8
P21 1074.04 15 13.28 272.28 8
P22 timeout NA 187.17 185.57 9
Table 1: Random input generation and Semi-biased
Brahma on Bitvector Examples. NA denotes not
applicable. * denotes that the extended library was
same as standard library. Runtimes in sec.
Bench Brahma Random Semibiased Brahma
Names Runtime Iter Runtime Iter Runtime Iter
(sec) (sec) (sec)
P23 1.380 3 24.28 9 12.12 5
P24 5.28 2 11.96 4 2.94 2
P25 0.50 5 timeout NA 0.86 9
Table 2: Deobfuscation Examples
by discovering inconsistency, and not by a query to the val-
idation oracle. This suggests that in the absence of any
validation oracle, we can consider the semantically unique
candidate program returned by our algorithm to be the cor-
rect program for all practical purposes.
We now compare the three approaches on bit-vector bench-
marks using two metrics - the total runtime and the number
of iterations. We present the ratio of runtimes of random
input generation (col 2 of Table 1) and semi-biased Brahma
(col 5 of Table 1) in Figure 7(a). Semi-biased Brahma is
1.5 times to 12 times faster than random technique. For
P22, the random technique did not ﬁnish in 1 hour while
semi-biased Brahma was able to synthesize it in 186 sec-
onds. Also, the number of iterations required to synthe-
size a program is also reduced signiﬁcantly as shown in Ta-
ble 1. Brahma and semi-biased Brahma is compared in
Figure 7(b). While the number of iterations is more for
semi-biased Brahma , it is faster than the Brahma on larger
benchmarks. It reduces the runtime for P18 from 140.65
seconds to 25.55 seconds, P21 from 527.91 seconds to 272.28
seconds and P22 from 1108.15 seconds to 187.17 seconds.
This validates the optimization proposed in Section 4.
6.2 DeobfuscationP1(x) : Turn-oﬀ
rightmost 1 bit.
1o1=(x - 1)
2 res=(x & o1)
P2(x) : Test
whether an un-
signed integer is of
the form 2n−1
1o1=(x + 1)
2 res=(x & o1)
P3(x) : Isolate the
rightmost 1-bit
1o1=(- x)
2 res=(x & o1)
P4(x) : Form a
mask that identiﬁes
the rightmost 1 bit
and trailing 0s
1o1=(x - 1)
2 res=(x ⊕o1)
P5(x) : Right prop-
agate rightmost 1-
bit
1o1=(x - 1)
2 res=(x |o1)P6(x) : Turn on the
rightmost 0-bit
1o1=(x + 1)
2 res=(x |o1)
P7(x) : Isolate the
rightmost 0-bit
1o1=(¬x)
2o2=(x + 1)
3 res=(o1&o2)
P8(x) : Form a
mask that identiﬁes
the trailing 0’s
1o1=(x - 1)
2o2=(¬x)
3 res=(o1&o2)
P9(x) : Absolute
Value Function
1o1=(x>>31)
2o2=(x⊕o1)
3 res=(o2-o1)
P10(x,y) : Test
if nlz(x) == nlz(y)
where nlz is number
of leading zeroes
1o1=(x & y)
2o2=(x⊕y)
3 res=(o2≤uo1)
P11(x,y) : Test if
nlz(x)<nlz(y)
1o1=(¬y)
2o2=(x &o1)
3 res=(o2>uy)P12(x,y) : Test
if nlz(x)<= nlz(y)
where nlz is number
of leading zeroes
1o1=(¬y)
2o2=(x &o1)
3 res=(o2≤uy)
P13(x) : Sign
Function
1o1=(x>>31)
2o2=(- x)
3o3=(o2>>31)
4 res=(o1|o3)
P14(x,k) : Round
upxto a multiple of
k-th power of 2
1o1=(-1>>k)
2o2=(o1+ 1)
3o3=(x -o2)
4 res=(o3& ))o1
P15 (x,y) : Floor
of average of two in-
tegers without over-
ﬂowing
1o1=(x & y)
2o2=(x⊕y)
3o3=((>> o 2))1
4 res=(o1+o3)P16 (x,y) : Com-
pute max of two in-
tegers
1o1=(x⊕y)
2o2=(- (x ≥uy))
3o3=(o1&o2)
4 res=(o3⊕y)
P17 (x,y) : Com-
pute min of two in-
tegers
1o1=(x⊕y)
2o2=(- (x ≤uy))
3o3=(o1&o2)
4 res=(o3⊕y)
P18(x,y) : Ceil of
average of two in-
tegers without over-
ﬂowing
1o1=(x|y)
2o2=(x⊕y)
3o3=(o2>>1)
4 res=(o1-o3)
P19(x) : Turn-oﬀ
the rightmost con-
tiguous string of 1
bits
1o1=(x - 1)
2o2=(x|o1)
3o3=(o2+ 1)
4 res=(o3& x)P20(x) : Determine
if an integer is a
power of 2 or not
1o1=(x - 1)
2o2=(o1& x)
3o3=bvredor (x)
4o4=bvredor (o2)
5o5=!(o4)
6 res=(o5&&o4)
P21(x) : Next
higher unsigned
number with same
number of 1 bits
1o1=(- x)
2o2=(x &o1)
3o3=(x +o2)
4o4=(x⊕o2)
5o5=(o4>>2)
6o6=(o5/o2)
7 res=(o6|o3)
P22(x) : Round up
to the next highest
power of 2
1o1=(x - 1)
2o2=(o1>>1)
3o3=(o1|o2)
4o4=(o3>>2)
5o5=(o3|o4)
6o6=(o5>>4)
7o7=(o5|o6)
8o8=(o7>>8)
9o9=(o7|o8)
10o10=(o9>>16)
11o11=(o9|o10)
12 res=(o10+ 1)
P23: Interchange the source and destination addresses.
1interchangeObs(IPaddress* src, IPadress* dest)
2{ *src = *src ⊕*dest;
3if (*src == *src ⊕*dest)
4{ *src = *src ⊕*dest;
5if (*src == *src ⊕*dest)
6 { *dest = *src ⊕*dest;
7 if (*dest == *src ⊕*dest)
8 { *src = *dest ⊕*src;
9 return; }
10 else
11 { *src = *src ⊕*dest; *dest = *src ⊕*dest;
12 return;} }
13 else
14 *src = *src ⊕*dest; }
15*dest = *src ⊕*dest; *src = *src ⊕*dest; return;
16}
1interchange(IPaddress* src, IPadress* dest)
2{
3*dest = *src ⊕*dest;
4*src = *src ⊕*dest;
5*dest = *src ⊕*dest;
6return;
7}P24: Multiply by 45
1int multiply45Obs(int y)
2{ a=1; b=0; z=1; c=0;
3while(1) {
4if (a == 0)
5 { if (b == 0) {
6 y=z+y; a = ¬a; b= ¬b;c=¬c;
7 if (¬c) break; }
8 else {
9 z=z+y; a= ¬a; b= ¬b; c= ¬c;
10 if (¬c) break; } }
11else {
12 if (b == 0) { z= y<< 2; a=¬a; }
13 else {
14 z=y<< 3; a=¬a; b= ¬b; } } }
15return y;
16}
1multiply45(int y)
2{
3z =y<< 2;
4y = z + y;
5z =y<< 3;
6y = z + y;
7return y;
8}
Figure 6: Bit-vector (P1-P22) Benchmarks and Deobfuscatio n Benchmarks (P23-P24) 0 2 4 6 8 10 12 14
13579111315171921 0 1 2 3 4 5 6 7Ratio of Runtime
Ratio of Iteration Counts
Bitvector BenchmarksRuntime
Iter Count
(a) Ratio of Runtime for Random Input Gen-
eration to SemiBiased Brahma 0 1 2 3 4 5 6
13579111315171921 0 0.3 0.6 0.9 1.2 1.5Ratio of Runtime
Ratio of Iteration Counts
Bitvector BenchmarksRuntime
Iter Count
(b) Ration of Runtime for Brahma to SemiB-
iasedBrahma
Figure 7: Runtime Comparison of Brahma , SemiBiased Brahma and Random Input Generation
The I/O oracle involves simply evaluating the obfuscated
program on the given input. The validation oracle can be a
program equivalence checking tool or the user.
An additional challenge that this domain oﬀers is the pres-
ence of arbitrary string constants. Our synthesis framewor k
can be easily extended to discovering such constants. For
this purpose, we introduce a generic base component fcthat
simply outputs some arbitrary constant c. The component
fctakes no input and returns one output Oand its func-
tional speciﬁcation is written as O=c. The only change
to the framework is that since cis allowed to be arbitrary,
we existentially quantify over cin the functional constraint
φfuncdescribed in Section 4.1.
For the three examples that we used in experiments, ob-
serve that Brahma gives the best performance. The key
observation from the experiments is that random input gen-
eration does not work well for examples such as P25 where
randomly generating integers has a rare chance of 1 in 232to
pick an input which produces any of the ﬁrst 4 possible out-
puts. Brahma takes exactly 5 iterations to query the I/O
oracle with inputs that generate all the 5 possible outputs.
The experimental results indicate that adding a distin-
guishing input is better than adding a random input to E
because it guarantees that atleast one candidate program is
deﬁnitely removed from the search space. Thus, it guaran-
tees progress. Moreover, it possibly also removes a set of
other similar designs from the search space.7. RELATED WORK
There is a vast body of work on automated program syn-
thesis. In this section, we describe some of the diﬀerent
approaches used for program synthesis.
Component based Synthesis
Synthesis of straight-line code-fragments constructed fr om a
given set of components has received signiﬁcant attention.
From Type Signatures: Jungloid mining tool [17] syn-
thesizes code-fragments (over a given set of API methods
annotated with their type signatures) given a simple query
that describes the desired code using input and output types .
From Functional Speciﬁcations: [8] uses SMT solv-
ing technology to synthesize a straight-line sequence of in -
structions from functional description of the desired code
sequence. DIPACS [9] uses an AI planner to implement a
programmer-deﬁned abstract algorithm using a sequence of
library calls. The behavior of the library procedures and th e
abstract algorithm is speciﬁed using high-level abstractions ,
e.g., predicates sorted andpermutation . It uses interaction
with the programmer to prune undesirable compositions.
From unoptimal code sequences: Superoptimizers
generate an optimal code sequence for a given straight-line
sequence of instructions. One approach is to enumerate se-
quences of increasing length or cost, testing each for equal -
ity with the given sequence [19]. Another approach is to
constrain the search space to a set of equality-preservingtransformations expressed by the system designer [10] and
then select the one with the lowest cost. Superoptimization
is useful in optimizing performance-critical inner loops. Re-
cent work has used superoptimization [2, 3] to automaticall y
generate general-purpose peephole optimizers by optimizi ng
a small set of instructions in the code.
Program Synthesis
In deductive program synthesis [18, 25], a program is syn-
thesized by constructively proving a theorem which states
that forall inputs in a given set, there exists an output, suc h
that a given functional speciﬁcation predicate holds. Dedu c-
tive program synthesis assumes that a full functional speci -
ﬁcation is given. Moreover, it requires advanced deduction
technology that is hard to automate.
In inductive program synthesis [26, 11], recursive pro-
grams are generated from input-output examples in two
steps. In the ﬁrst step, a set of I/O examples are writ-
ten as one large conditional expression. In the second step,
this initial program is generalized into a recursive progra m
by searching for syntactic regularities in the initial prog ram.
In contrast, we do not require a “good” set of I/O examples
be given a-priori. Moreover, we do not explicitly general-
ize – generalization happens implicitly from synthesizing a
function using only a given set of components.
Shapiro’s Algorithmic Debugging System [22] performs
synthesis by repeatedly using the oracle to identify errors
in the current (incorrect) program and then ﬁxing those er-
rors. We do not ﬁx incorrect programs. We use the in-
correct program to identify a distinguishing input and then
re-synthesize a new program that works on the new input-
output pair as well.
In programming by demonstration [14, 15, 6], the user
demonstrates how to perform a task and the system learns
an appropriate representation of the task procedure. Un-
like our method, these approaches do not make active oracle
queries, but rely on the demonstrations the user chooses.
Making active queries is important for eﬃciency and termi-
nating quickly (so that user is not overwhelmed with queries ).
In programming by sketching [23], implementations are
synthesized from sketches – partially-speciﬁed programs w ith
holes. The SKETCH system uses SAT solving within a
counterexample-guided loop that constantly interacts wit h
a veriﬁer to check candidate implementations against a com-
plete speciﬁcation, where the veriﬁer provides counterexa m-
ples until a correct solution has been found. In contrast,
we do not use counterexamples for synthesis. Further, we
require a validation oracle only when the speciﬁcation can
not be realized using the provided components. This veri-
ﬁer is not required to return a counter-example. In practice ,
we never require a query to the veriﬁer and our technique
correctly identiﬁes infeasible scenarios without calling the
validation oracle.
8. CONCLUSION
We have presented a novel approach to program synthesis
based on oracle-guided learning from examples and SMT
solvers. Applications to synthesis of bit-vector programs
and deobfuscation have been demonstrated. Experiments
indicate that our approach can be eﬃcient and eﬀective for
discovering unintuitive code and for program understandin g.Acknowledgments
We are grateful to Rastislav Bodik, George Necula, John
Rushby, Natarajan Shankar, Hassen Saidi, Dawn Song, Richar d
Waldinger and the anonymous reviewers for their insightful
comments. The UC Berkeley authors were supported in part
by NSF grants CNS-0644436 and CNS-0627734, and by an
Alfred P. Sloan Research Fellowship. The fourth author was
supported in part by NSF grants CNS-0720721 and CSR-
0917398.
9. REFERENCES
[1] D. Angluin. Queries and concept learning. Machine
Learning , 2(4):319–342, 1987.
[2] S. Bansal and A. Aiken. Automatic generation of
peephole superoptimizers. In ASPLOS , 2006.
[3] S. Bansal and A. Aiken. Binary translation using
peephole superoptimizers. In OSDI, 2008.
[4] C. Barrett, R. Sebastiani, S. A. Seshia, and C. Tinelli.
Satisﬁability modulo theories. In Handbook of
Satisﬁability , volume 4, chapter 8. IOS Press, 2009.
[5] C. Collberg, C. Thomborson, and D. Low. A taxonomy
of obfuscating transformations. Technical Report 148,
Dept. Comp. Sci., The Univ. of Auckland, July 1997.
[6] A. Cypher, editor. Watch what I do: Programming by
demonstration . MIT Press, 1993.
[7] S. A. Goldman and M. J. Kearns. On the complexity
of teaching. Journal of Computer and System
Sciences , 50:20–31, 1995.
[8] S. Gulwani, S. Jha, A. Tiwari, and R. Venkatesan.
Component based synthesis applied to bitvector
circuits. Technical Report MSR-TR-2010-12, Microsoft
Research, Feb 2010.
[9] T. A. Johnson and R. Eigenmann. Context-sensitive
domain-independent algorithm composition and
selection. In PLDI, 2006.
[10] R. Joshi, G. Nelson, and K. H. Randall. Denali: A
goal-directed superoptimizer. In PLDI, 2002.
[11] E. Kitzelmann and U. Schmid. Inductive synthesis of
functional programs: An explanation based
generalization approach. J. Machine Learning Res. ,
7:429–454, 2006.
[12] D. E. Knuth. The art of computer programming.
http://www-cs-faculty.stanford.edu/~knuth/
taocp.html .
[13] J. Kominek. rot13 implementation. http://www.
miranda.org/ ∼jkominek/rot13/ , Accessed Sep. 2009.
[14] T. Lau, P. Domingos, and D. S. Weld. Version space
algebra and its application to programming by
demonstration. In ICML , pages 527–534, 2000.
[15] H. Lieberman, editor. Your wish is my command:
Giving users the power to instruct their software .
Morgan Kaufmann, 2001.
[16] N. Linial, Y. Mansour, and N. Nisan. Constant depth
circuits, fourier transform, and learnability. In FOCS ,
pages 574–579, 1989.
[17] D. Mandelin, L. Xu, R. Bod´ ık, and D. Kimelman.
Jungloid mining: Helping to navigate the API jungle.
InPLDI, pages 48–61, 2005.
[18] Z. Manna and R. Waldinger. A deductive approach to
program synthesis. ACM TOPLAS , 2(1):90–121, 1980.[19] H. Massalin. Superoptimizer - a look at the smallest
program. In ASPLOS , pages 122–126, 1987.
[20] MyDoom Wikipedia Article. http://en.wikipedia.
org/wiki/Mydoom , URL accessed Sep. 2009.
[21] P. Porras, H. Saidi, and V. Yegneswaran. An analysis
of conﬁcker’s logic and rendezvous points. Technical
report, SRI International, March 2009.
[22] E. Y. Shapiro. Algorithmic Program DeBugging . MIT
Press, Cambridge, MA, USA, 1983.
[23] A. Solar-Lezama, L. Tancau, R. Bod´ ık, S. Seshia, and
V. Saraswat. Combinatorial sketching for ﬁnite
programs. In ASPLOS , 2006.
[24] SRI Intl. Yices: An SMT solver .
http://yices.csl.sri.com/ .
[25] M. Stickel, R. Waldinger, M. Lowry, T. Pressburger,
and I. Underwood. Deductive composition of
astronomical software from subroutine libraries. In
CADE , 1994.
[26] P. D. Summers. A methodology for lisp program
construction from examples. J. ACM , 24(1), 1977.
[27] Symantec Corporation. Internet security threat repor t
volume XIV. http://www.symantec.com/business/
theme.jsp?themeid=threatreport , April 2009.
[28] H. S. Warren. Hacker’s Delight . Addison-Wesley
Longman, Boston, MA, USA, 2002.