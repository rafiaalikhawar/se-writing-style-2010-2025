Veri ﬁcation-Driven Slicing of UML/OCL Models
Asadullah Shaikh
Universitat Oberta de
Catalunya Barcelona, Spain
ashaikh@uoc.eduRobert Clarisó
Universitat Oberta de
Catalunya Barcelona, Spain
rclariso@uoc.eduUffe Kock Wiil
The Maersk-McKinney
Moller Institute
University of Southern
Denmark Odense, Denmark
ukwiil@mmmi.sdu.dk
Nasrullah Memon
The Maersk-McKinney
Moller Institute
University of Southern
Denmark Odense, Denmark
memon@mmmi.sdu.dk
ABSTRACT
Model defects are a signiﬁcant concern in the Model-Driven
Development (MDD) paradigm, as model transformationsand code generation may propagate errors to other nota-
tions where they are harder to detect and trace. Formal
veriﬁcation techniques can check the correctness of a model,buttheirhigh computational complexity can limit theirscal-ability. In this paper, we consider a speciﬁc static model
(UML class diagrams annotated with unrestricted OCL con-
straints) and a speciﬁc property to verify (satisﬁability, i.e.,
“is it possible to create objects without violating any con-
straint?”). Current approaches to this problem have an ex-
ponential worst-case runtime. We propose a technique toimprove their scalability by partitioning the original modelinto submodels (slices) which can be veriﬁed independently
and where irrelevant information has been abstracted. The
deﬁnition of the slicing procedure ensures that the propertyunder veriﬁcation is preserved after partitioning.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques; D.2.4 [ Software Engineering ]: Software/Program
Veriﬁcation; D.3.2 [ Programming Languages ]: Language
Classiﬁcations; I.2.8[ Artiﬁcial Intelligence ]: ProblemSolv-
ing, Control Methods, and Search
General Terms
Veriﬁcation
Keywords
MDD, UML, OCL, Model Slicing, Formal Veriﬁcation
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for pro ﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speci ﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.1. INTRODUCTION
Model-Driven Development (MDD) advocates for a shift
in the software engineering process: using models, instead
of code, as the primary development artifact. Within MDD,
tool support for model design, analysis and transformation
is essential and scalability is an important requirement.
Thereareformalveriﬁcationtoolsforautomatically check-
ing correctness properties on models, but the lack of scala-
bility is usually a drawback and its improvement will be thegoal of this paper. We will consider the analysis of the staticelements of a software speciﬁcation, modeled as a UML classdiagram. Complex integrity constraints will be expressed in
the Object Constraint Language (OCL). In this context, the
fundamental correctness property of a model is satisﬁabil-
ity[1,4,19]: “is it possible to instantiate the model without
violating any integrity constraint?”.
This property is important not only because it can point
out inconsistent models, but also because it can be used
to check other interesting properties like the redundancy of
an integrity constraint. For example, a pair of constraints
C
1and C2are not redundant if the following is satisﬁable:
(C1∧¬C2)∨(¬C1∧C2), i.e., it is possible to satisfy C1but
notC2or vice versa.
Reasoning on UML class diagrams without OCL integrity
constraints is an EXPTIME-complete problem [2]. Further-
more, the addition of unrestricted1OCL constraints makes
theproblemundecidable. Currentsolutionsforcheckingsat-
isﬁability employ formalisms such as description logics [1],higher-order logics [3], database deduction systems [19], lin-
ear programming [17], SAT [11] or constraint satisfaction
problems [2,4]. However, all the approaches which support
general OCL constraints share a common drawback, a highworst-case computational complexity. Their execution timemay depend exponentially on the size of the model, under-standingsizeasthenumberofclasses/attributes/associations
in the model and/or the number of OCL constraints.
A review of sample UML/OCL models highlights two ob-
servations which are relevant to this problem. First, models
1Some approaches restrict the set of supported OCL con-
structs, e.g., to make the veriﬁcation decidable. In this pa-
per, weconsider general OCLconstraintswith nolimitations
on their expressivity.
185
Figure 1: High-level description of the slicing process.
typically contain elements which are either unconstrained or
constrained in a trivially satisﬁable way. For instance, at-
tributes acting as identiﬁers should have unique values, butoften there are no other constraints on these attributes. Asecond observation is that some constraints refer to indepen-dent entities. For example, constraints about the passwordofauserandthepriceofaproductarelikelytobeunrelated.
These observations can be used to improve the scalabil-
ity of veriﬁcation methods for satisﬁability. Our proposal isbased on model slicing : given an input UML/OCL model,
the diagram and its constraints will be automatically parti-
tioned into submodels while abstracting unnecessary model
elements. The structure of the class diagram (associations
and class hierarchies) and the OCL invariants (abstract syn-
tax tree) will guide the partitioning process. Intuitively, theunderlying idea is that all constraints restricting the samemodel element should be veriﬁed together and therefore be-long to the same slice. Then, satisﬁability of each slice ischecked independently and the results are combined to as-
sess the satisﬁability of the entire model. Figure 1 illustrates
the overall ﬂow. To ensure soundness, slicing should not al-ter the outcome of the veriﬁcation.
Theremainderofthepaperfocusesonthedeﬁnitionofthe
slicing algorithm and the evaluation of its beneﬁts. Section 2
introduces a running example and a more detailed overview
of the slicing procedure. Section 3 focuses on the analysis
of OCL constraints while Section 4 explores the structuralanalysis of theclass diagram. Section 5describes experimen-tal results measuring how slicing reduces veriﬁcation time.Section 6 shows a larger real world case study where the
beneﬁts of slicing are illustrated. In Section 7, related work
is presented. Finally, Section 8 provides the conclusions andidentiﬁes directions of future work.
2. OVERVIEW OF UML/OCL SLICING
The approach: The input of our method is a UML class
diagram annotated with OCL invariants. As an example,
Figure 2 introduces class diagram that will be used through-
out the paper, modeling the information system of a bus
company. Several integrity constraints are deﬁned as OCL
invariants.
Our goal is to determine whe ther the input cl ass diagram
has legal instances, thatis, instances thatsatisfy all integrityconstraints. An instance of a UML class diagram is a col-
lection of objects (according to the class deﬁnitions) and a
collection of links between them (according to the associa-tions). The output of the tool will either be“satisﬁable”or
“unsatisﬁable”. In case of satisﬁability, a sample instance
proving the satisﬁability will be computed as well.
Two diﬀerent notions of satisﬁability will be considered
for veriﬁcation: strongand weaksatisﬁability [1,4,19]. Aclass diagram is weakly satisﬁable if it is possible to create
a legal instance which is non-empty, i.e., it contains at least
one object from someclass. On the other hand, strong sat-
isﬁability is a more restrictive condition requiring that thelegal instance has at least one object from eachclass and
a link from eachassociation. Some parts of the slicing al-
gorithm will work diﬀerently depending on the satisﬁability
notion being veriﬁed.
The algorithm works by partitioning the UML/OCL class
diagram intoa setofdisjoint slices. Aslice SofaUML/OCL
class diagram Dis a subset of the original model: another
valid UML/OCL class diagram where any element (class,
association, inheritance, aggregation, invariant, ...) ap-
pearing in Salso appears in D, but the reverse does not
necessarily hold. Figure 3 represents the slices for strongsatisﬁability. Each slice is veriﬁed independently and theveriﬁcation result of the whole model is obtained by com-bining the results of all slices. If we are checking strongsatisﬁability, it is necessary to check whether allslices are
strongly satisﬁable. Onthecontrary, if we are checkingweaksatisﬁability, it is suﬃcient to ensure that at least one slice
is weakly satisﬁable.
Preserving satisﬁability: Thefundamentalrequirement
of this procedure is that it should preserve the outcome of
theveriﬁcation: theanswer providedbytheveriﬁcationwith
slicing should be the same as the one given by a veriﬁcationtool without slicing.
Each slice is a disjoint subset of the integrity constraints
and a disjoint fragment of the original class diagram. As
each slice is less constrained than the original model, it is
clear that if the original model was satisﬁable, the slices will
also be satisﬁable. Therefore, it is only necessary to ensurethat if the original model was unsatisﬁable, the answer willalso be“unsatisﬁable”: if we are checking strong satisﬁabil-ity, at least one slice will be strongly unsatisﬁable, and if we
are checking weak satisﬁability, all slices will be weakly un-
satisﬁable. A formal proof is out of the scope of this paper
but we will try to provide some insight on how satisﬁabilityis preserved.
A class diagram can be unsatisﬁable due to several rea-
sons. First, it is possible that the model provides inconsis-
tent conditions on the number of objects of a given type.
Inheritance hierarchies, multiplicities of association or ag-
gregation ends and textual integrity constraints (e.g., Type::allInstances() −>size() = 7) can restrict the possible num-
ber of objects of a class. Second, it is possible that thereare no valid values for one or more attributes of an object inthe diagram. Within a model, textual constraints provide
the only source of restrictions on the values of an attribute,
e.g., self.x = 7. Finally, it is possible that the unsatisﬁabilityarises from a combination of both factors, e.g., the values of
186context Coach invMinCoachSize:
self.noOfSeats ≥10
context Coach invMaxCoachSize:
self.trips −>forAll( t |t.passengers −>size()≤noOfSeats)
context Trip invCorrectTripDestination:
notself.origin = self.destination
context Ticket invUniqueTicketNumber:
Ticket::allInstances() −>isUnique ( t |t.number )
context Ticket invMachineNumber:
self.name=self.vendingMachine.bookingOﬃce.location.concat(self.number.toString())
context Passenger invNonNegativeAge:
self.age≥0
Figure 2: UML/OCL class diagram used as running example (model Coach).
some attributes require a certain number of objects to be
created which contradict other restrictions.
To sum up, an unsatisﬁable model either contains an un-
satisﬁable textual or graphical constraint or an unsatisﬁableinteraction between one or more textual or graphical con-
straints, i.e., the constraints can be satisﬁed on their own
but not simultaneously. To ensure that unsatisﬁability is
propagated into the slices, three conditions should be guar-anteed:
1. No potentially unsatisﬁable constraint should be re-
moved from the problem.
2. If there are two or more constraints whose interaction
couldbeunsatisﬁable, noneofthemshouldberemoved
from the problem.
3. All constraints referring to the same model element
should appear together in the same slice, i.e., their
interaction should not be split into diﬀerent slices.Inordertoensurethatconditions(1-3)hold,theUML/OCL
model has to be analyzed before slicing. The analysis should
reveal which parts of the model can be abstracted or parti-tioned safely. The following sections focus on this analysisat two levels: UML and OCL. In Section 3, a traversal of the
syntax tree of each OCL constraint identiﬁes which classes,
attributes and navigations are being restricted. Additional
analysisidentiﬁestrivialconstraintsandconstraintsthatcanbecheckedindependently. InSection4, dependenciesamongthe number of objects in each class, like inheritance hierar-chies or multiplicity constraints, are studied.
3. ANALYSIS OF OCL CONSTRAINTS
OCL allows the deﬁnition of expressions on UML models.
An expression which evaluates to true or false, e.g., a class
invariant, will be called a constraint .O C Lc a na l s ob eu s e d
to deﬁne the result of query operations , which can then be
invoked inside other expressions.
187Invariant
 Support
 Attributes
 Navigations
MinCoachSize
 Coach
 Coach.noOfSeats
 None
MaxCoachSize
 Coach, Trip, Passenger
 Coach.noOfSeats
 Travels, Uses
CorrectTripDestination
 Trip
 Trip.(origin,destination)
 None
MachineNumber
 VendingMachine,
 Ticket(name,number)
 Sells, Has
BookingOﬃce, Ticket
 BO.location
UniqueTicketNumber
 Ticket
 Ticket.number
 None
NonNegativeAge
 Passenger
 Passenger.age
 None
Table 1: Support, attributes and navigations in the running example.
Figure 3: Slices for the veriﬁcation of strong satisﬁ-
ability in the running example.
Any OCL expression is deﬁned within the contextof a
type. Typically, an OCL expression involves several ob-
jects from one or more classes of the model. To get a
starting object, we can use the keyword self, which denotes
an object of the context type; or the method allInstances()
which can be used to access all objects of a given type, e.g.,Trip::allInstances() returns a set of all objects of class Trip.
Given an object, OCL provides operators to read the values
ofitsattributes( attribute access ) andaccesstheobjectscon-
nected to it through associations ( navigation ). Combining
these operators with arithmetic, logic and relational opera-tors, iterators and user-deﬁned query operations, it is possi-ble to write complex constraints about UML models.
This section describes how to analyze OCL invariants in
order to extract information relevant to its satisﬁability. Weare interested in identifying which model elements are con-strained by an invariant, as interactions between constraintsappearwhentwoormoreconstraintsrestrictthesamemodelelements.
3.1 Constraint Support
The supportof an OCL expression is the subset of classes
of the class diagram referenced by the expression. If the
expression is a query operation, it contains the types whose
objects are explored to evaluate the query. For invariants,
the support describes the set of classes restricted by the con-
straint. This information will be used identify classes thatappear together in the same constraint and therefore mustbe analyzed within the same slice. Formally, the support ofan expression Econtains the following types:
1. The context type where Eis deﬁned and all its su-
pertypes, as long as the“self”variable appears withinE.2. The type of each association end navigated within E.
3. Each type referenced explicitly in Eby the opera-
tion Type::allInstances() or by a type check or con-
version operation, e.g., oclIsKindOf, oclIsTypeOf oroclAsType.
4. The union of the supports of all query operations in-
voked from E.
Another piece of information required by the remaining
analysis steps is the set of attributes and navigations used
in each invariant. This information can be gathered with a
straightforward traversal of the OCL syntax tree. Table 1
summarizes all this data for the invariants of the runningexample.
3.2 Local and Global Constraints
Someparts of a veriﬁcation problem can be checkedin iso-
lation within the boundaries of a class and without aﬀecting
the big picture. Intuitively, if there is a constraint on an at-
tribute which is not used anywhere else in the model, we can
split the veriﬁcation problem in two separate subproblems:
checking that the constraint on the attribute is feasible and
verifying the rest of the system. This section will present
the tools to identify these local constraints.
An expression is called local to a class Cif it can be eval-
uated by examining onlythe values of the attributes in one
object of class C. Expressions that do not ﬁt into this cate-
gory, because they need to examine multiple objects of the
same class or some objects from another class, are calledglobal.
In other words, a local expression can be deﬁned as fol-
lows: (a) it does not use navigations through associations
and, (b) it does not call allInstances(), (c) it does not use
attributes deﬁned in a superclass, (d) it does not call any
global query operation and (e) it does not perform any typecheck or type conversion operation. Table 2 shows some ex-amples of local and global expressions written in the contextof class Trip.
Some attributes may appear in local constraints, global
constraints or both. We are interested in detecting thoseattributes that can be studied locally, like those that do notappear in global constraints and are notrelated to attributesthat appear there. In this sense, the set of globalattributes
will be iteratively deﬁned as follows: (a) the attributes used
in global expressions plus (b) the attributes used in local
expressions where there is at least one global attribute. All
other attributes of the model will be called local.A l o c a l
expression which uses only local attributes will be called
strongly local .
It should be noted that according to our deﬁnition, the
result of a strongly local invariant does not depend on (a) at-tributes outsidethose mentioned in the expression or (b) the
188Type
 Expression (context Trip)
 Description
Local
 self.origin /negationslash= self.destination
 Attribute access
Global
 notself.passengers −>isEmpty()
 Navigation
Global
 Ticket::allInstances() −>isUnique(t |t.number)
 allInstances()
Global
 self.oclIsTypeOf(“PrivateTrip”)
 oclIsTypeOf()
Table 2: Examples of local and global invariants.
Pattern
 Condition
Type::allInstances() −>isUnique(at)
 Key constraint if attribute is not constrained
anywhere else.
self.at op exp
 Derived value constraint if attribute is not used
anywhere else and expression does not involve attribute.
Ao rB
 Trivially satisﬁable if either AorBare satisﬁable.
Aa n dB
 Trivially satisﬁable if either Aand Bare satisﬁable.
A implies B =¬A∨B
 Trivially satisﬁable if either¬AorBare satisﬁable.
Not A
 Trivially satisﬁable if Ais trivially satisﬁable
and it is not a key constraint.
self.navigation −>isUnique(at)
 Trivially satisﬁable if attribute is not used anywhere else.
Table 3: Patterns with Conditions
number of objects in any class. The only chance of poten-
tial interaction with other invariants is with other strongly
local invariants of the same class, if they have any attributein common. Therefore, strongly local invariants of a classcan be analyzed separately from the rest of the model. The
division into subproblems is the following:
•A problem deﬁned by the class, its local attributes
and its strongly local invariants (which can be furtherpartitioned if these invariants restrict disjoint sets ofattributes).
•Anotherproblemdeﬁnedbytheoriginalmodel, remov-
ing the attributes and constraints that appear in theﬁrst subproblem.
In our running example, invariants MinCoachSize, Non-
NegativeAge and CorrectTripDestination are all local invari-ants. Of these, invariant MinCoachSize is not strongly lo-cal as the attribute “noOfSeats” is also used in the globalinvariant MaxCoachSize. The remaining invariants, Non-NegativeAge and CorrectTripDestination can be abstractedfrom the model together with the attributes they reference
and their satisﬁability can be checked independently.
3.3 Trivially Satis ﬁable Constraints
A ﬁnal analysis that can improve the eﬃciency of satisﬁa-
bility veriﬁcation is the detection and removal of trivially
satisﬁable invariants from the UML/OCL class diagram.
Detecting satisﬁable constraints is as hard as satisﬁability
itself, so we restrict ourselves to consider typical patterns
which may arise in diﬀerent applications.
The ﬁrst trivially satisﬁable pattern which can be safely
removed is the key constraint , stating that a given attribute
must be unique, e.g., Type::allInstances() −>isUnique(obj
|obj.attr ). If the attribute is of type Integer, Float or
String and it is not referenced by any other constraint, it
can be trivially satisﬁed: a diﬀerent value can be assignedtoeachpotentialinstance,e.g.,1,2,3,...Theveriﬁcationengine does not need to spend time computing the value of
the attributein each object and enforcing uniquenessamong
diﬀerent objects.Another trivially satisﬁable pattern which can also be re-
moved is the derived value constraint , where the value of one
attributedependsonthevaluesofotherattributes. Thepat-tern is self.attrib op expression where attribis an attribute
of a basic type (Boolean, Integer, Float, String) not con-
strained by any other constraint, opis a relational operator
(=,/negationslash=,< ,> ,≤,≥)a n d expression is a“safe”OCL expression
which does not include any reference to attrib.B y “ s a f e ”
we mean a side-eﬀect free expression which cannot evaluate
to the undeﬁned value in OCL (OclUndeﬁned). This meansthat we do not allow divisions that can cause a division-by-
zero or collection operations which are undeﬁned on empty
collections like ﬁrst().
Intuitively, this constraint cannot make the model unsat-
isﬁable: if an instance for the rest of the model can be cre-ated, it is simply a matter of evaluating expression to ﬁnd
out the right value of attrib. The conditions on expression
(no self-references, no undeﬁned values) guarantee that the
evaluation always computes a feasible value for attrib.T a b l e
3 brieﬂy summarizes the patterns and conditions where the
column Pattern shows the possible expressions and the col-
umn Condition illustrates the criteria of the given patterns.
Regardingthefeed-backprovidedtotheuser, it ispossible
to hide the fact that these constraints have been abstracted.
If the veriﬁcation tool provides an instance of the model asan answer, a post-processing phase can add the abstractedattributes and assign them correct values according to theconstraints.
Consideringtherunningexample,invariantMinCoachSize
is a derived value constraint where the expression is the con-stant 0. However, this invariant is not trivially satisﬁable
and therefore cannot be abstracted, because the attribute
“noOfSeats”is also constrained by the invariant MaxCoach-
Size. On the other hand, constraints NonNegativeAge, Cor-
rectTripDestination and MachineNumber are derived value
constraints which can be abstracted. Finally, invariant Uni-queTicketNumber is a key constraint which can also be ab-stracted.
189Figure 4: Flow graph (left) and dependency graph (right) for the running example.
4. ANALYSIS OF UML CLASS DIAGRAMS
For the sake of brevity and without loss of generality, in
this section we will consider a UML class diagram composed
of binary associations and inheritance relations. The re-
maining features of class diagrams like associative classes or
n-ary associations can be expressed in terms of binary asso-
ciations (and potentially additional OCL constraints) [9].
In this phase, we will compute a graph-based representa-
tion ( dependency graph ) that captures the dependencies of
the elements within the UML/OCL class diagram. Then,
the computation of slices will simply consist of computing
theconnected components of the graph, i.e., the maximal
subgraphs where there is a path among each pair of ver-
tices. Intuitively, each connected component represents aset of interdependent constraints which have to be analyzedas a whole.
A dependency graph is an undirected graph where each
vertex is a class of the model. The core challenge is the deﬁ-nition of theconditionsunderwhich two verticeswill becon-nected: they should be as aggressive as possible (removingirrelevant dependencies) while being conservative (relatedvertices will not be separated under any circumstance).
In order to deﬁne these relationships, we will use an aux-
iliary graph-based representation called ﬂow graph .Aﬂ o w
graph is a labeled directed pseudograph, i.e., there can be
arcs from one vertex to itself and multiple arcs between twovertices. The vertices of the ﬂow graph are the classes of theclass diagram and the labels in the arcs are non-negative in-tegers. An arc X
n→Yhas the meaning“if there is an object
in class X,a tl e a s t nobjects of class Ymust exist”. Using
this deﬁnition, there is an arrow Xn→Yif:
•Xis a subclass of Y(n= 1): Each object of a subclass
is also an object of the superclass.
•There isanassociation between XandYand thelower
bound of the multiplicity of the association end in Y
isn.
Arcs with a label 0 can be removed because they are not
imposing any constraint. Multiple arcs between two vertices
can be replaced by a single arc labeled with maximum la-bel among them. For example, Figure 4 illustrates the ﬂowgraph for the running example after these simpliﬁcations.
Intuitively, a path in the ﬂow graph among vertices X
and Yestablishes a dependency from XtoY.A c y c l e
deﬁnes a cyclic dependency and it is therefore a possiblesource of unsatisﬁability. Any cycle where the maximum la-
bel is 1 is inherently satisﬁable, and it will be called safe.
B u tc y c l e sw h e r e( a )t h em a x i m u ml a b e l ≥2 and (b) there
are two or more participating associations/inheritances re-
lations which also form a cycle in the class diagram canbe
unsatisﬁable. Such cycles will be called unsafe. In our run-
ning example (Figure 4), there are three cycles: Trip-Coach,
Trip-Passenger and Manager-Bonus. The ﬁrst two are safe(they only involve one association so there is no cycle in theclass diagram) while the third one is unsafe (two associa-
tions participate in the cycle and there is a multiplicity with
lower bound 2).
Using this information, the dependency graph will be cre-
ated in two steps. In the ﬁrst step, we identify classes whicharepotentially unsatisﬁable , i.e., classes constrained by OCL
invariants and classes belonging to an unsafe cycle:
1. Create a vertex for each class that appears in the con-
straint support of an OCL constraint.
2 .A d da ne d g e X−Yif both Xand Ybelong to the
constraint support of the same constraint.
3. Create a vertex (if it does not previously exist) for each
class that appears in an unsafe cycle in the ﬂow graph.
4. Add an edge X−Yamong all vertices participating
in the same unsafe cycle.
In the second step, we iteratively add classes that con-
strain vertices already in the dependency graph. Let Xand
Ybe a pair of vertices in the dependency graph, where X
and Ycan be the same vertex, and Zac l a s st h a td o e s
not appear in the dependency graph. Then, if there is a
path from XtoZand from ZtoYin the ﬂow graph ,v e r -
texZ
must added to the dependency graph together with
edges X−Zand Y−Z. This process propagates depen-
dencies between potentially unsatisﬁable classes that cross
through other classes. In our running example, the result-ing ﬂow graph is shown in Figure 4, with two connected
components: one coming from the unsafe cycle in the ﬂow
graph Manager-Bonus and another coming from the con-
straints Min/Max-CoachSize , formed by classes Coach,Trip
andPassenger .
From the dependency graph, it is possible to extract its
connected components. Each component deﬁnes a slice ofthe class diagram that can be analyzed independently: the
set of classes from the class diagram, the set of associations
190and inheritance hierarchies among them, the invariants that
havesomeoftheseclasses intheir supportandtheattributes
referenced by any of those invariants. For example, Figure
3 highlights the ﬁnal slices passed to the veriﬁcation tool for
strong satisﬁability. Strikethrough text indicates attributesfrom the original model which have been abstracted in theslice. Notice how thanks to the detection of trivially sat-
isﬁable invariants described in the previous Section, some
attributes like originwhich were originally constrained by
an invariant can be simply abstracted.
With this approach, the slices of the class diagram corre-
spond to those fragments that could be unsatisﬁable. The
implication is “if the slices can be populated, then the re-
maining classes can be populated as well”. But what hap-
pens if these slices cannot be populated? This does not
matter for strong satisﬁability, as allclasses must be popu-
lated so any failure means the whole model is unsatisﬁable.
However, in weak satisﬁability it could be the case that all
slices are unsatisﬁable but some of the remaining classes can
be satisﬁed independently. Considering our running exam-ple, let us consider class Employee : creating an employee
does not impose any obligation on any other class of themodel. Thus, it is clear that this class can be populatedand the model is weakly satisﬁable. Formally, if there is
any class Xsuch (a) Xdoes not appear in the dependency
graph and (b) the ﬂow graph has no path from Xto a class
in the dependency graph, the model is weakly satisﬁable. In
this case Xand any classes which depend from Xcan be
populated even if no class if the dependency graph can be
populated. In our running example, class Employee is the
only class which exhibits this trait.
5. EXPERIMENTAL RESULTS
Inthissection, weattempttoquantifythespeed-upachieved
byslicing. Tothisend,wehavedevelopedaprototypeimple-
mentation of the slicing procedure on top of the tool UML-
toCSP [4]. UMLtoCSP transforms veriﬁcation problems on
UML/OCL class diagrams into constraint satisfaction prob-
lems(CSP) which can be solved by a constraint solver. So-
lutions to the CSP are instances of the diagram which prove
or disprove the property being veriﬁed.
We compare the veriﬁcation time of several UML/OCL
class diagrams using (1) the original tool UMLtoCSP and
(2) the tool UMLtoCSP with slicing. In each example,
the property being veriﬁed is strong satisﬁability. Table
4 describes the set of benchmarks used for our compari-son: the number of classes, associations, invariants and at-tributes. For each class diagram, we also indicate whetherit is strongly satisﬁable or not. The benchmarks “Com-pany”, “Script” and “Cycle” were programmatically gener-
ated, in order to test large input models. Of these models,
we consider the“Script”models to be the best possible sce-nario for slicing (large models with many attributes and veryfew constraints). The models “Paper-Researcher”, “Atom-Molecule”, “Company”and “Cycle” serve as worst-case sce-narios (models with many interdependent constraints, de-
signed so they cannot be sliced).
UMLtoCSP has a set of parameters thatcan have a strong
inﬂuence on its runtime. These parameters set an upper
bound on the size of the instance (number of objects perclass, number of links per association) and the domain of
attributes(setoffeasible valuesforeachattribute). InUML-
toCSP, veriﬁcation is not complete in the sense that it willonlyexplorepotentialinstanceswithin thesebounds. Never-
theless, thesizeof thesolutionspace tobeexploredbyUML-
toCSP is exponential in terms of these parameters. There-fore, largevaluesoftheparameterswill makethecomparisonmore favorable towards slicing, as abstracting attributes andclasses will cause a larger reduction of the solution space. Inour analysis, we have considered small but reasonable val-
ues for parameters: at most 4 objects will be created for
each class, at most 10 links for each association and eachattribute will have at most 10 distinct values.
Table 5 shows the experimental results computed using a
Intel Core 2 Duo Processor 2.1Ghz with 2Gb of RAM. All
times are measured in seconds and a time-out limit has been
set at 2 hours (7200 seconds). For each example, we describethe original veriﬁcation time (OVT), the number of slices inwhich the model is divided, the number of attributes thatwe manage to abstract, the time required to perform all theUML/OCL slicing analysis (ST) and the veriﬁcation time
after the slicing (SVT).
The ﬁrst conclusion is that slicing is a very fast procedure
even in diagrams with hundreds of classes. As expected, the
eﬀectiveness of the technique depends on the speciﬁc modelbeinganalyzed: small modelsand modelswhereUMLtoCSPalready performed well gain little from slicing. This also
happens with models where there are no unconstrained at-
tributes and all classes and constraints are interdependent.In the worst case, the veriﬁcation time with slicing is thesame as that without slicing. But in models where slicingmanages to partition the model and abstract attributes, thespeed-up reaches several orders of magnitude. Therefore,
its success will depend on the type of models where it is ap-
plied. Small models which have been manually preprocessedfor veriﬁcation will gain little from slicing. However, mod-els created for other purposes or models generated throughautomatic transformation can beneﬁt greatly from the ap-
plication of slicing. The tiny overhead introduced by slicing
and the tool independent nature of this approach are addi-
tional reasons in favor of adding slicing to existing formalveriﬁcation toolkits.
6. SLICING ALLOY SPECIFICATION
In this section, we have applied our slicing technique to
the DBLP (Digital Bibliography and Library Project) struc-
tural schema programmed in the Alloy speciﬁcation. The
schema of the DBLP system is modeled a UML class di-
agram [6]. It is a computer science bibliographical web-
site, and has existed since the 1980’s. The DBLP structuralschema deals with people and their publications, which canbe edited books and authored publications. The class dia-gram has 17 classes and 26 integrity constraints. It is di-
vided into two types of integrity constraints: identiﬁcation
and other integrity constraints. This case study is interest-ing for our problem since it has complex invariants and isa real world case study. Therefore, we intend to apply ourslicing approach to this DBLP case study in order to show
that our methods work upon external case studies and can
improve the eﬃciency of the veriﬁcation process.
The approach is manually implemented over the DBLP
in order to show how fast it generates satisfying instances
of the example before and after the slicing is applied. Thesame model is taken for slicing in the Alloy [10] to check
the advantages of slicing. The execution time is largely de-
pendent on the deﬁned scope, therefore, in order to analyze
191Example
 Classes
 Associations
 Attributes
 Invariants
 Satisﬁable?
Atom-Molecule
 2
 1
 6
 1
 Yes
Paper-Researcher
 2
 2
 5
 4
 No
Coach
 15
 10
 27
 6
 Yes
Production System
 50
 30
 72
 5
 Yes
Company
 100
 100
 100
 100
 Yes
Script 1
 100
 53
 122
 2
 Yes
Script 2
 500
 227
 522
 5
 Yes
Script 3
 1000
 505
 1022
 5
 Yes
Cycle 1
 10
 10
 10
 10
 No
Cycle 2
 100
 100
 100
 100
 No
Table 4: Description of the UML/OCL benchmarks.
Example
 OVT
 Slices
 Attr
 ST
 SVT
Atom-Molecule
 0.03s
 1
3
0.00s
 0.03s
Paper-Researcher
 0.04s
 1
0
0.00s
 0.04s
Coach
 5008.76s
 2
26
0.00s
 0.18s
Production System
 3605.35s
 4
59
0.02s
 0.03s
Company
 0.08s
 1
0
0.00s
 0.08s
Script 1
 Time-out
 2
117
0.02s
 0.03s
Script 2
 Time-out
 4
509
0.09s
 0.02s
Script 3
 Time-out
 4
1009
0.29s
 0.34s
Cycle 1
 Time-out
 1
10
0.00s
Time-out
Cycle 2
 Time-out
 1
100
0.00s
Time-out
OVT Original Veriﬁcation Time Attr# of abstracted attributes
SVT Total veriﬁcation time for all slices STSlicing Time
Table 5: Description of experimental results.
the eﬃciency of veriﬁcation, scope 7 is limited. The Alloy
will examine the entire DBLP model with up to 7 objects,and try to ﬁnd one that violates the property. For example,saying scope 7 means that Alloy will check the model whosetop level signatures have up to 7 instances. After apply-
ing the technique, two submodels are received: submodel 1
consists of 10 classes annotated with 8 OCL constraints and
submodel 2 comprises of 2 classes annotated with 2 OCLconstraints.
Table 6 summarizes the experimental results obtained us-
ing the Alloy analyzer before and after slicing, running on a
Intel Core 2 Duo Processor 2.1Ghz with 2Gb of RAM. All
times are measured inmilliseconds (ms). Foreach scope (be-fore slicing), the translation time (TT), solving time (ST)and the summation of the TT and ST, which is the totalexecution time, are described. Similarly, each scope, afterslicing time is also deﬁned which is the sliced translation
time (STT), sliced solving time (SST) and the summation
of STT and SST, which is equivalent to the summation ofTT and ST. The only diﬀerence is that the total executiontime varies before and after slicing. Similarly, the columnspeed upshows theeﬃciency obtainedafter theimplementa-tion of the slicing approach. The speedup is achieved using
the equation below:
[1−{(STT+SST)/(TT+ST)}]∗100
Previously, it took 1453 ms (scope 7) for the execution of
the DBLP. Using the approach for the slice computed bythis method, it takes only 828 ms (scope 7) to generate a
satisfying instance for the slice. It is an improvement of43% which is a marked progress in total execution time. Inaddition, the improvement can also be achieved for largerscopes as well. For instance, the results up to the scope of
35 can be achieved for the DBLP structural schema. How-
ever, without slicing we could run the analysis up to the
scope of 19.
7. RELATED WORK
Slicing techniques can be classiﬁed according to two crite-
ria: the entitybeing sliced (e.g., a program, a UML model,
an ontology, ...) andthe goalof the slicing process (e.g.,
synthesis, analysis, optimization, visualization, comprehen-
sion,...). Intuitively,allslicingtechniquesproceedintwo
steps: ﬁrst, the subset of elements of interest that should
appear in the slice is identiﬁed; second, elements which de-
pend on elements of the slice are iteratively added to theslice. The notions of “element”, “element of interest” and
“dependency between elements” are completely determined
bywhatis being sliced and why.
Program slicing [23,25] techniques work at the level of
source code. Given a set of variables of interest and a pro-
gram location which are provided as input, program slicingcomputes the set of statements of the program that can af-fect (backward) or be aﬀected (forward) by those variables.
The applications of program slicing include program anal-
ysis, optimization, veriﬁcation and comprehension. Slicing
192Before Slicing After Slicing
Scope TT ST TT+ST
 STT SST STT+SST Speedup %
2 125ms 47ms. 172ms
 110ms 31ms 141ms 18%
3 187ms 78ms 265ms
 125ms 62ms 187ms 29%
4 281ms 172ms 453ms
 219ms 78ms 297ms 34%
5 473ms 190ms 663ms
 299ms 110ms 409ms 38%
6 671ms 344ms 1015ms
 438ms 156ms 594ms 41%
7 969ms 484ms 1453ms
 672ms 156ms 828ms 43%
TTTranslation Time STSolving Time
STTSliced Translation Time SSTSliced solving Time
Table 6: Description of experimental results (Alloy).
has also been used in the analysis of architectural speciﬁ-
cationsof a software system [13,21]. In this context, ex-
tracting the set of components related to a component of
interest can facilitate component reuse and provide a high-level view of the architecture that helps in its comprehen-
sion. Another type of program slicing is used for Declarative
Speciﬁcations [24]. This work proposes a tool known as Kato
which relies on heuristics to identify“core”(slices) and it is
targeted towards the relational logic underlying Alloy. Few
details are provided on the set of heuristics being used.
Ontologies provide a formal description of a set of con-
cepts and their relationships. General purpose ontologies
may represent a large number of concepts and their sizemakes them impractical for many applications. Several ap-proaches [5,18,22] focus on pruning large ontologies to pro-duce smaller ontologies which are more manageable. In this
case, concepts of interest are identiﬁed by the modeler and
provided as the input of the slicing method.
Slicing methods have also been proposed the management
of diﬀerent types of UML models. Context-free slicing [12]
provides a framework for deﬁning model slices in UML di-agrams, e.g., class diagrams. This work proposes a general
theory of model slicing which has to be adapted to each spe-
ciﬁc goal by deﬁning a slicing criterion suitable for our goal.There is no discussion on thedeﬁnition of suitable slicing cri-teria for veriﬁcation. A diﬀerent approach focusing in classdiagram comprehension is the use of coupling metrics [14] toslice large models for visualization. This type of approach
would not be well-suited for veriﬁcation purposes, as metrics
do not provide guarantees about the properties satisﬁed bythe partitions. Finally, the slicing of models consisting ofboth UML class diagrams and UML sequence diagrams isconsidered in [15]. A common representation, called ModelDependency Graphs, is used to encode both types of dia-
grams. Again, the slicing criterion must be provided as an
input to the algorithm.
In contrast to these previous works, this paper describes
a slicing criterion oriented towards the veriﬁcation of satisﬁ-
ability of UML/OCL class diagrams. Previous works either
do not target UML class diagrams or do not consider OCL
(other than as a notation to express slicing criteria) andnone propose a slicing criterion for veriﬁcation.
Another source of relevant work appears in the underly-
ing theorem provers and solvers used to check satisﬁability
inUML/OCLmodels. Atthislevel, similar conceptsforpar-
titioning, symmetry-breaking and other optimizations have
been considered extensively, for instance [7,16,24]. We claimthat slicing beforethe translation into a formalism like SATor CSP is worthwhile due to several reasons. First, slicing
analysis is independent of the underlying formalism, so itcan beneﬁt a variety of tools. Furthermore, at this levelof abstraction the problem is smaller, so it is feasible toperform more complex analysis. Finally, we can take advan-
tage of our knowledge of the semantics of UML/OCL and
the property being veriﬁed, information which can be lostin the translation into the formalism. For instance, the re-
moval of derived value constraints proposed in Section 3.3
would not be possible without precise information about theproperty being checked.
8. CONCLUSIONS AND FUTURE WORK
This paper presents an innovative slicing technique for
UML/OCL class diagrams aimed at making the veriﬁcation
of satisﬁability more eﬃcient. The approach receives as in-put a UML class diagram annotated with OCL constraints
and automatically breaks it into submodels whose satisﬁ-
ability can be analyzed independently. Then, the satisﬁa-
bility of the original model can be established by checkingif at least one submodel (weak satisﬁable) or all submodels(strongsatisﬁable) are satisﬁable. A beneﬁtof thisapproachis that it is independent of the underlying formalism used
to check satisﬁability and can therefore be applied in many
existing tools.
A prototype implementation of the slicing procedure has
been developed on top of the tool UMLtoCSP. The object
diagram of running example is shown in Figure 5. Exper-
imental results show that slicing can produce a signiﬁcant
speed-up in the veriﬁcation time. The amount of speed-up
achievedbythismethod dependsonthespeciﬁcmodel, fromnone to several orders of magnitude.
As the overhead introduced by slicing analysis is neg-
ligible, we claim that slicing is a useful addition to any
UML/OCL satisﬁability checking toolkit. Furthermore, we
demonstrated slicing technique on a real world case study
named as DBLP conceptual to analyze the beneﬁts. Thisreal world case study is programmed in Alloy which is afamous tool and widely used for veriﬁcation of models. Weapplied slicing and achieved drastic speed-up in another toolas well.
As our future work, we plan to explore two research di-
rections. First, we plan to investigate more aggressive slic-
ing criteria which can still preserve the satisﬁability of themodel after partitioning. Theapproach presented in thispa-per is very conservative in several ways, for example it only
considers disjoint slices. Relaxing the proposed approach
(while ensuring the preservation of satisﬁability) would pro-
193(a) Submodel 1 of ‘Model Coach’
(b) Submodel 2 of ‘Model Coach’
Figure 5: UMLtoCSP Output of Model Coach
vide more opportunities for slicing a class diagram. Second,
the partition of a model into submodels can provide a usefulfeedback in case of unsatisﬁability: if a model is unsatis-
ﬁable, it is possible to identify in which submodel(s) that
happens. Designers can therefore focus their attention intheincorrect submodelswhile ignoring therest of themodel.This feedback is coarser than those approaches designed tocomputea“minimum set of conﬂicting constraints”, e.g., un-sat cores in Alloy or [20], but it is computed with very little
overhead and it can still be useful to designers.
Acknowledgements
This work has been partly supported by the Ministerio de
Ciencia y Tecnol ogia unde r project TIN2008-00444 and by
an UOC-IN3 Doctoral Grant. We would like to thank Jordi
Cabot and Jordi Conesa for their useful comments.
9. REFERENCES
[1] M. Balaban and A. Maraee. A UML-based method for
deciding ﬁnite satisﬁability in Description Logics. In
DL’2008 , volume 353 of CEUR Workshop Proceedings .
CEUR-WS.org, 2008.
[2] D. Berardi, D. Calvanese, and G. D. Giacomo.
Reasoning on UML class diagrams. AIntelligence ,
168:70–118, 2005.
[3] A. D. Brucker and B. Wolﬀ. The HOL-OCL book.
Technical Report 525, ETH Zurich, 2006.
[4] J. Cabot, R. Claris´ o, and D. Riera. UMLtoCSP: a tool
for the formal veriﬁcation of UML/OCL models using
constraint programming. In ASE’2007 , pages 547–548.
ACM, 2007.
[5] J. Conesa and A. Oliv´ e. Pruning ontologies in the
development of conceptual schemas of informationsystems. In ER’2004 , volume 3288 of LNCS, pages
122–135. Springer, 2004.
[6] DBLP. Digital bibliography andy library project.
http://guifre.lsi.upc.edu/DBLP.pdf .
[7] V. Durairaj and P. Kalla. Guiding CNF-SAT search
via eﬃcient constraint partitioning. In ICCAD’04 ,
pages 498–501. IEEE Computer Society, 2004.[8] M. Gogolla, J. Bohling, and M. Richters. Validating
UML and OCL models in USE by automatic snapshot
generation. Journal on Software and System Modeling ,
4(4):386–398, 2005.
[9] M. Gogolla and M. Richters. Expressing UML Class
Diagrams Properties with OCL. In AOM with the
OCL, volume 2263 of LNCS, pages 86–115. Springer,
2001.
[10] D. Jackson. Alloy: a lightweight object modelling
notation. ACM Transactions on Software Engineering
and Methodology , 11(2):256–290, 2002.
[11] D. Jackson. Software Abstractions: Logic, Language
and Analysis . MIT Press, 2006.
[12] H. H. Kagdi, J. I. Maletic, and A. Sutton.
Context-free slicing of UML class models. In ICSM’05 ,
pages 635–638. IEEE Computer Society, 2005.
[13] T. H. Kim, Y. T. Song, L. Chung, and D. Huynh.
Software architecture analysis: A dynamic slicing
approach. International Journal of Computer &
Information Science , 1(2):91–103, 2000.
[14] R. Kollmann and M. Gogolla. Metric-based selective
representation of uml diagrams. In CSMR’02 , pages
89–98. IEEE Computer Society, 2002.
[15] J. T. Lallchandani and R. Mall. Slicing UML
architectural models. In ACM / SIGSOFT SEN ,
volume 33, pages 1–9, 2008.
[16] Y. C. Law and J. H. Lee. Symmetry breaking
constraints for value symmetries in constraintsatisfaction. Constraints , 11(2-3):221–267, 2006.
[17] A. Maraee and M. Balaban. Eﬃcient reasoning about
ﬁnite satisﬁability of UML class diagrams with
constrained generalization sets. In ECMDA-FA’2007 ,
volume 4530 of LNCS, pages 17–31. Springer, 2007.
[18] B. J. Peterson, W. A. Andersen, and J. Engel.
Knowledge bus: Generating application-focuseddatabases from large ontologies. In KRDB ’98 ,
volume 10 of CEUR Workshop Proceedings , pages
2.1–2.10. CEUR-WS.org, 1998.
[19] A. Queralt and E. Teniente. Reasoning on UML class
diagrams with OCL constraints. In ER’2006 ,v o l u m e
4215 of LNCS, pages 497–512. Springer-Verlag, 2006.
[20] G. Rull, C. Farr´ e, E. Teniente, and T. Urp´ ı.
Computing explanations for unlively queries indatabases. In CIKM’07 , pages 955–958. ACM, 2007.
[21] J. A. Staﬀord, D. J. Richardson, and A. L. Wolf.
Architecture-level dependence analysis in support of
software maintenance. In ISAW’98 , pages 129–132,
1998.
[22] B. Swartout, P. Ramesh, K. Knight, and T. Russ.
Toward distributed use of large-scale ontologies. AAAI
Symp. on Ontological Engineering , pages 138–148,
1997.
[23] F. Tip. A survey of program slicing techniques.
Journal of Programming Languages , 3:121–189, 1995.
[24] E. Uzuncaova and S. Khurshid. Kato: A program
slicing tool for declarative speciﬁcations. In ICSE ’07 ,
pages 767–770. IEEE Computer Society, 2007.
[25] M. Weiser. Program slicing. IEEE Trans. Software
Eng., 10(4):352–357, 1984.
194