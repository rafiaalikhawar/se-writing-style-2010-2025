How Do Centralized and Distributed Version Control
Systems Impact Software Changes?
Caius Brindescu, Mihai Codoban, Sergii Shmarkatiuk, Danny Dig
School of EECS, Oregon State University
Corvallis, OR, USA
{brindesc,codobanm,shmarkas,digd}@eecs.oregonstate.edu
ABSTRACT
Distributed Version Control Systems (DVCS) have seen an
increase in popularity relative to traditional Centralized Ver-
sion Control Systems (CVCS). Yet we know little on whether
developers are benetting from the extra power of DVCS.
Without such knowledge, researchers, developers, tool build-
ers, and team managers are in the danger of making wrong
assumptions.
In this paper we present the rst in-depth, large scale
empirical study that looks at the inuence of DVCS on the
practice of splitting, grouping, and committing changes. We
recruited 820 participants for a survey that sheds light into
the practice of using DVCS. We also analyzed 409M lines of
code changed by 358300 commits, made by 5890 developers,
in 132 repositories containing a total of 73M LOC. Using this
data, we uncovered some interesting facts. For example, (i)
commits made in distributed repositories were 32% smaller
than the centralized ones, (ii) developers split commits more
often in DVCS, and (iii) DVCS commits are more likely to
have references to issue tracking labels.
Categories and Subject Descriptors: D.2.7 [Software
Engineering]: Distribution, Maintenance, and Enhancement
General Terms: Measurement, Experimentation
Keywords: Version Control, Software Change, Distributed
Version Control, Centralized Version Control
1. INTRODUCTION
Distributed Version Control Systems (DVCS) like Git [2]
or Mercurial [6] are widely used today. Over the last cou-
ple of years GitHub [4], which is the most popular repos-
itory hosting service for Git projects, has taken the open
source community by storm [19]. At the end of 2012, GitHub
hosted over 4.6M repositories. Compare this with the previ-
ous paradigm, CVCS, epitomized by SVN [9] and CVS [1].
SourceForge [7], the primary repository hosting service
for SVN had about 300K repositories by the end of 2012.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
ICSE ‚Äô14, May 31 - June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05 ...$15.00.Also, our own survey of 820 developers shows that 65% use
DVCS and 35% use CVCS.
DVCS brings a whole set of novel capabilities. Using
DVCS, developers (i) can work in isolation on local copies
of the repositories enabling them to work oine while still
retaining full project history, (ii) they can cheaply create
and merge branches, and (iii) they can commit individual
changed lines in a le, as opposed to being forced to commit
a whole le like in CVCS.
Are developers truly taking advantage of these DVCS fea-
tures or are they simply paying the steep learning price with-
out beneting from them? Despite the large scale adoption
of DVCS, we know little about the state of the practice in us-
ing this new paradigm. Without such knowledge, developers
and managers are left in the dark when deciding whether it
is worth to invest time and eort to transition to these new
tools. Also, researchers are in danger of making errors when
mining repositories, due to confounding eects imposed by
DVCS. Finally, tool builders can build the wrong tools if
they are not aware of developers' habits.
In this paper we present the rst large-scale study that an-
swers in-depth questions about the extent to which DVCS
inuences the practice of managing changes. To this end,
we designed and launched a survey. We recruited 820 par-
ticipants, 85% of them being developers from industry. 56%
have ten or more years of programming experience. 51%
work in teams larger than 6 developers.
To get further insights into how DVCS aects code changes,
also we analyzed 409M lines of code changes from 358300
commits, made by 5890 developers, in 132 repositories con-
taining a total of 73M LOC. Our corpus contains both pure
and hybrid repositories. Pure repositories use the same VCS
throughout their lifecycle. Hybrid repositories started in
the centralized paradigm and switched to the distributed
paradigm. The hybrid repositories can reveal if changing
the version control system inuences developers' practices.
For the centralized paradigm we chose SVN as the best
representative. For the distributed paradigm we chose Git.
Using the data from our survey and our mining of repos-
itories, we answer 12 research questions organized in three
overarching themes:
Theme 1: How does the VCS type aect developers' be-
havior?
RQ 1: Does the type of VCS aect the size of commits?
RQ 2: Do developers split their commits into logical units
of change? How do they do it?
RQ 3: How often and why do developers squash their com-
mits?Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE‚Äô14 , May 31 ‚Äì June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568322
322
RQ 4: Why do developers prefer one Version Control Sys-
tem over another?
RQ 5: Does the VCS inuence the frequency with which
developers commit?
We found that developers' behavior is inuenced by the
VCS type. When using DVCS, developers make commits
32% smaller and they organize their changes in several com-
mits. Depending on the VCS type, the reasons why devel-
opers nd the commit process more natural are dierent.
Theme 2: How does the team size aect VCS usage?
RQ 6: Does team size aect the choice of VCS?
RQ 7: Are larger teams more likely to use Issue Tracking
Systems (ITS)?
RQ 8: Does team size aect the size of commits?
RQ 9: Does team size inuence commit squashing?
Teams of all sizes prefer using DVCS. The team size does
not inuence the size of commits. Most teams include issue
tracking labels in their commits.
Theme 3: How does the VCS type aect the development
process?
RQ 10: Does the type of VCS inuence the presence and
the number of issue tracking labels (ITL)?
RQ 11: Is there a correlation between the number of issue
tracking labels in the commit message and the commit size?
RQ 12: How does the size of commits vary in time?
We found that developers using DVCS include issue track-
ing labels more often in commit messages. Also, the commit
size decreases as the project matures.
Based on these ndings, we propose several actionable
implications for four audiences. Researchers can better align
their research questions with the type of repositories they
mine. For example, for questions that rely on a discrete
and precise software changes (e.g., bug prediction etc.) they
should mine distributed repositories. Developers can give
more precise meaning to their changes when they use DVCS.
Tool builders can further build up on the strengths provided
by DVCS such as the ability to better group changes and
express their intent. Managers can make more informed
decisions when choosing tools for their projects.
This paper makes the following contributions:
1.Research Questions. We designed and answered 12
novel research questions to understand the extent in
which DVCS help developers manage software changes.
2.Survey. We designed and launched a survey to pro-
vide insights into the practice of using DVCS. We re-
cruited 820 participants.
3.Mining repositories. We developed tools to collect
metrics and analyze centralized and distributed repos-
itories. We applied these tools on 132 repositories.
4.Implications. We present implications of our ndings
from the perspective of four audiences: researchers ,
developers ,tool builders , and team managers .
The tools, summary of survey responses, and corpus are
publicly available at:
http://cope.eecs.oregonstate.edu/VCStudy
2. EXPERIMENTAL SETUP
In this section we describe the two sources of data we used
to answer our research questions.
2.1 Survey
We conducted a survey where we asked 20 questions about
developer commit practices. 820 respondents answered oursurvey. The participants are developers recruited by pro-
moting the survey on social media channels specic to the
development community, i.e., Twitter and Google+ feeds
that are mainly read by developers.
Table 1 shows the demographics of the respondents. Most
are experienced developers working on industrial projects.
The data shows that Git is widely used by developers (52%),
followed by SVN (20%).
Table 1: Demographics of survey respondents
(a) Programming experience (years)
<2 2 - 5 5 - 10 10 - 15 15 - 20 >20
1.83% 11.10% 30.49% 30.61% 13.90% 12.07%
(b) Project type
Proprietary
softwareOpen source
softwareResearch
projectPersonal
projectOther
85.09% 6.97% 4.64% 3.06% 0.24%
(c) Team size
1 2 - 5 6 - 10 11 - 25 26 - 100 >100
5.87% 42.30% 23.72% 15.65% 8.19% 4.28%
(d) Project age
<6 mo 6 mo - 1 yr 1 yr - 2 yrs >2 yrs
13.33% 18.58% 21.27% 46.82%
(e) VCS used predominantly
Git SVN HgMicrosoft
TFSCVS Other
52.68% 20.37% 12.07% 8.54% 1.10% 5.24%
ClassiÔ¨Åcation of open-ended questions.
The survey contained both multiple choice and open-ended
questions1. We hand-coded the answers to the open-ended
questions using qualitative thematic coding [18]. We de-
veloped a set of codes that we validated by achieving an
inter-rater agreement of over 80% for 20% of the data. Two
coders, the rst and the third authors, developed the cat-
egories which were not known apriori. For measuring the
agreement we used the Jaccard coecient.
2.2 Repository
To provide further insights into how DVCS aects de-
veloper's practices, we collected and analyzed 132 software
repositories.
2.2.1 Repository Corpus
To answer our research questions we needed to collect
repositories that are representative of the centralized and
distributed paradigms. We also collected hybrid repositories
that started in a centralized paradigm and switched to the
1Survey questions can be accessed on our website at
http://cope.eecs.oregonstate.edu/VCStudy/323Table 2: Repository corpus.
Repo. Type Repositories Commits AuthorsTotal
LOC
changed
SVN 52 95571 451 270M
Hybrid 29 151004 2249 89M
Git 51 111725 3190 50M
Total 132 358300 5890 409M
distributed one. Our assumption is that dierences in met-
rics taken from these 3 kinds of repositories provide valuable
insights on how they inuence source code management.
Using the survey results, we selected SVN and Git as being
representative for the centralized and distributed categories,
respectively. We collected SVN repositories from Source-
Forge as and Git repositories from GitHub . These reposi-
tories span several programming languages: Java, C, C++,
JavaScript, and Python.
ForGitHub we selected the top ranked repositories, i.e.,
repositories that have been marked as favorites by develop-
ers and/or have been forked the most. For SourceForge
we used its own internal ranking metric to select the top
ranked repositories. We queried the SourceForge projects
through the Notre Dame Sourceforge Research Archive [8],
which serves as a mirror designed specically for researchers.
By choosing the top repositories we ensure that we collect
mature projects with a rich history.
To select hybrid repositories, we searched for internet posts
about migrating repositories from SVN to Git. In addition,
while collecting Git repositories, some of them proved to
have actually started in SVN. Thus we classied them as
hybrid. We distinguish the two stages of hybrid repositories
as Hybrid SV NStage and Hybrid GitStage .
We took extra care to ensure the integrity of repositories,
i.e., Git repositories did not originate in SVN, by searching
for keywords in commit messages.
Table 2 shows the corpus of repositories. For each repos-
itory kind, we tabulate the number of individual reposito-
ries, commits, and authors that contributed. The last col-
umn shows the total number of lines of code that have been
changed by all commits.
We aimed for an equal number of SVN and Git repositories
to ensure that we compare the two paradigms in a fair way.
2.2.2 Repository Analysis
We have built an analysis platform to gather several com-
mit metrics. We used Git as the canonical representation for
all repositories. This is possible since the Git object storage
model is a superset of the centralized model. For example,
the linear history of CVCS can be easily represented in Git's
directed acyclic graph branching model. Thus, we converted
all SVN repositories to Git, using the svn2git tool [10].
Our platform builds on top of gitective [3], a framework
capable of traversing history trees, one commit at a time.
To explore the statistical signicance of various sample dif-
ferences, we applied the Wilcoxon rank-sum test. We chose
this test since none of the data t a normal distribution.
We used the Pearson correlation coecient in order to
establish linear dependence between two sets of randomly
distributed values.Filtering changes.
In our initial manual investigation of commits we have
discovered that many commits do not represent actual pro-
gramming changes carried out by a developer (e.g., adding
features, bug xing, refactoring, etc.), but are the result of
applying tools such as code formatters. Such commits are
extremely large, i.e., they aect thousands of LOC. Since
these commits would bias our analysis, we decided to lter
them out. Our analysis lters out any commit that:
consists only of either added, deleted or renamed les.
Most of the times these commits represent large scale
project le structure modications. Also, commits
that only add les do not interact with any part of
the program and were therefore eliminated.
are merge commits. These commits usually represent
decisions on conict resolution and contain changes
from several lines of development.
updates only copyright notes, code documentation (e.g.,
JavaDoc comments) or reorganize code dependences
(e.g., import statements).
is articially created by repository migration tools.
Inside each commit, we ignore all changes that modify
only comments and white spaces.
Commit metrics.
For each commit we collect the following metrics.
Commit id , for identifying commits.
Commit date , for sorting commits chronologically.
The author of the commit , for grouping by authors.
Number of LOC changed by the commit , for deter-
mining the size of commits. For each commit we compute
LOC added, deleted, or modied as reported by the stan-
dard diff tool.
Number of les impacted by the commit , for de-
termining the commit size. While LOC tells us how much
software editing has been performed in a commit, the num-
ber of impacted les tells us how spread the change is within
the system.
Number of issues referenced in the commit mes-
sage , to determine the cohesiveness of changes. The issues
refer to programming tasks, such as features or bugs, man-
aged with external systems such as BugZilla ,Jira [27],
etc. In order to detect them, we used an approach simi-
lar to the one described by Bird at al. [15], which employs
searching for specic text patterns in the commit message.
3. RESULTS
3.1 How does the VCS type affect developers‚Äô
behavior?
RQ 1: Does the type of VCS aect the size of com-
mits?
Table 3 shows the commit size, both in lines of code and
in number of les, made by individual authors. This data is
grouped by VCS type.
In terms of LOC, the commits from Git repositories tend
to be smaller than those made in SVN repositories (p <
0.01). The mean and median lines of code changed per com-
mit in Git repositories is 27.20 and 13.46, respectively, while
for SVN repositories these values are 40 and 18.44 respec-
tively. The standard deviation of changed lines of code also324Table 3: Commit size across dierent VCS
Mean Median StdDev
LOC les LOC les LOC les
Git 27.20 3.08 13.46 1.96 32.72 2.7
Svn 40.06 5.65 18.44 3.19 49.62 6.72
HybridGit 23.02 2.40 11.52 1.70 27.57 1.74
HybridSVN 25.72 2.82 12.61 1.96 31.24 2.15
diers, with 32.72 lines of code for Git and 49.62 lines of
code for SVN.
In terms of the number of les that are aected by a com-
mit, the same trend of a smaller commit size can be seen as
with the commit lines of code, although the dierence is not
signicant (p = 0.2). Commits from Git repositories tend
to aect fewer les than commits from SVN repositories.
On the other hand, hybrid repositories do not show a
smaller commit size after they transition to Git (p >0.5).



	Observation 1: DVCS repositories have a smaller com-
mit size than CVCS repositories, in terms of lines of
code.



	Observation 2: Hybrid repositories do not show any
dierence between the size of commits performed before
and after the switch to the distributed paradigm.
Interpretation: One possible explanation for Git com-
mits being smaller than SVN commits is the fact that Git
enables its users to select ner grained changes to commit.
In Git the atomic unit of change that can be committed is
the line while in SVN it is the le.
Another possible cause that enables small commits in Git
is that each developer commits to his own local repository
without the need to synchronize with everybody else. This
means that there is no risk of conicts upon every commit.
One participant stated that \Git promotes the idea that
your commit space is not inicting pain on anyone else, so
frequent commit and experimentation is encouraged. By de-
sign it promotes small, frequent commits that serve a specic
purpose rather than the `5pm commit."' Resolving conicts
becomes a task that is consciously entered into when decid-
ing to synchronize changes with other team members. It is
not something that must happen with every commit.
Hybrid repositories on the other hand do not seem to ex-
perience smaller commits after switching to Git, as observa-
tion 2 shows. Our assumption is that in such cases a certain
commit policy is formed within the team while the project
is under SVN. This commit policy is then intuitively carried
over after switching to Git, leading to the same observed
commit size.
The culture of the project takes a longer time to change
when a new tool is introduced. Thus, in long lasting projects,
it seems that old habits die hard.
RQ 2: Do developers split their commits into logical
units of change? How do they do it?
The changes that a developer makes might belong to one
or more logical units of change. Do developers split these
changes and commit separately? Or do they just group ev-
erything and generate one large commit? The answers in
the survey give us the picture depicted in Table 4.Table 4: Developers splitting their commits (%)
Practice DVCS CVCS Overall
Split their changes 81.25 67.89 75.99
Group their changes 12.50 26.61 18.05
Other 6.25 5.50 5.96
Table 5: Reasons for splitting commits (%)
Technique DVCS CVCS Overall
Implementation details 37.01 21.85 32.03
Intent of change 45.13 62.251 50.76
Policy 6.17 5.30 5.88
Other 11.69 10.60 11.33


Observation 3: 76% of the developers split their com-
mits. The percentage is higher for distributed version
control systems (81.25%), compared to centralized ones
(67.89%).
One explanation for this fact is that in DVCS, the commit
process is easier and cheaper than in centralized ones. There
is no risk of conict with each new local commit. Moreover,
the smallest atomic unit of change in DVCS is the line, not
the le (as it is in CVCS). All these make committing easier,
so developers are willing to take the time to split and commit
each logical change separately. In a recent study conducted
in parallel with ours, Muslu et al. [32] have also discovered
that the ability to commit locally and independently allows
developers to work incrementally.
A question of great interest is the criteria on how they
split their changes. We chose four categories to capture the
respondents' answers:
Implementation details refer to how was a change carried
out (e.g., change eld type, add new branch to a switch
statement, etc). Intent of change splits changes by express-
ing the what part of the change carried out (e.g., add a
feature, x a bug). Policy splits changes based on a criteria
that is externally imposed (management practices, develop-
ment process, etc). Other represent reasons that do not t
in the above criteria.
Table 5 tabulates the reasons for splitting commits.
We observe that in the case of DVCS, developers split their
changes based on implementation details more frequently
than they do in CVCS. This will inevitably result in more
commits. As is the case with observation 3, we can attribute
this to an easier commit process.


Observation 4: Overall, developers choose to split
their commits using the intent of change.


Observation 5: More DVCS users split changes based
on implementation details than CVCS users.
As we have seen in observations 3 and 5, DVCS users
split their changes in several commits more often and they
do it with a ner-grained scope in mind. One participant
reported: \Each commit is one cohesive change that might
x a bug, add new functionality, alter existing functionality
([...] like \sphere class can now calculate its own volume" -
user level features usually take many commits)" . This cor-
roborates with the ndings about the inuence of Version325Control Systems on commit size (RQ 1). Being able to more
easily split the commits and the commit process being sim-
pler as well, will result in smaller commit size.
RQ 3: How often and why do developers squash
their commits?
Squashing refers to the operation of merging two or more
commits into a single one.
Results from the survey show that only 30% of the devel-
opers squash their commits. The results for the distributed
and centralized repositories are shown in Table 6.
Table 6: Developers squashing their commits (%)
Response DVCS CVCS Overall
Yes 36.59 18.12 30.21
No 54.79 44.57 51.31
Not applicable 8.62 37.32 18.48
Table 7: Reasons why developers squash their com-
mits (%)
Reason DVCS CVCS Overall
Group similar changes 25.63 45.16 28.80
Intermediate steps are
irrelevant20 0 16.75
Remove mistakes 15 0 12.57
Keep history clean 26.88 6.45 23.56
Policy requirement 5.63 9.68 6.28
Other 6.88 38.71 12.04
Table 6 shows that squashing happens twice more often
in distributed repositories than in centralized ones2. This
probably has to do with the fact that it is easier to manipu-
late commits in DVCS. Developers who practice squashing
mention two main reasons (Table 7): (i) to group several
changes together and; (ii) they do not care about the path
they took to a solution as long as it's nished and it works.



	Observation 6: Squashing does not occur often in
practice. If it does occur, it's a practice mainly asso-
ciated with DVCS
RQ 4: Why do developers prefer one Version Con-
trol System over another?
According to the survey, we have found two main reasons
why developers nd a commit process more natural. The
rst is the presence of a killer feature . It usually helps de-
velopers achieve higher productivity by allowing a workow
that is more comfortable for them. The second is habit.
Developers get used to a certain tool. Therefore, they will
nd the tool natural to use from the habits they have ac-
quired while using it on a daily basis. Table 8 summarizes
the complete results.
In 46% of the cases developers prefer DVCS because of
akiller feature . By looking at individual replies we have
found that one of the features mentioned is the possibility
to commit to the local copy of the repository. Also, we can
see that the main reason for preferring CVCS is the ease of
2See Internal Threats to Validity (Section 4)Table 8: Reasons for considering a VCS more \nat-
ural" to commit (%)
Reason DVCS CVCS Overall
Killer feature 46.02 10.89 30.41
Old habit 22.88 41.58 30.41
Easy to use 19.79 41.58 27.14
Personal preference 2.06 0.99 2.04
Other 9.25 4.95 10
use. While the distributed model has its advantages, that
comes at the cost of a more complex model. This could
explain why so many developers (almost 42%) think that
the centralized model is easier to use.
Also, many prefer CVCS simply because of habit. Having
used a system for a very long time, one gets used with the
command interface and paradigm. It is interesting to note
that CVCS are used not for their capabilities in managing
change, but for old habits and a faster learning curve.



	Observation 7: The commit process of DVCS is per-
ceived by developers to be more natural because of the
presence of killer features.



	Observation 8: The commit process of CVCS is per-
ceived to be more natural because of familiarity and a
faster learning curve, not their feature set.
Our ndings are reinforced by Muslu et al. [32]. Their
study shows that developers prefer the ability to work oine.
Also, they have found the learning curve to be a barrier in
adopting DVCS.
RQ 5: Does the VCS inuence the frequency with
which developers commit?
Table 9 shows results we obtained from the survey. De-
velopers commit several times a day regardless of the ver-
sion control they use. The data for each VCS type shows
a slightly dierent picture. Developers using DVCS com-
mit once an hour more often (19.66%) than developers us-
ing CVCS (4.10%). Also, when using CVCS developers are
more likely to commit once a day (14.75%) than when using
DVCS (7.19%).


Observation 9: Most developers have similar habits
independent of what VCS they use.
Table 9: How often do developers commit? (%)
DVCS CVCS Overall
Once a minute 3.38 0.82 2.51
Once an hour 19.66 4.10 14.37
Several times a day 65.96 66.80 66.25
Once a day 7.19 14.75 9.76
Several times a week 1.90 9.43 4.46
Once a week 1.48 3.32 2.09
Once a month 0.42 0.82 0.56
Interpretation: The fact that developers commit once
an hour more often when using DVCS than when using
CVCS suggests that they nd it easier to commit. Results326from the previous research questions also lead to this con-
clusion. One interesting results is that 14.75% of developers
using CVCS commit once a day. This suggest a pattern of
committing once the work day is over.
Implications.
For developers: Smaller commits make code reviews
easier. Having a tool that enables small, ne grained com-
mits allows users to separate and document each change in-
dividually. One participant mentioned that they split their
commits because \[changes] should be logically separated,
to easily allow [the] commit message to drive [the] review" .
Consider reviewing a new feature that has been added. In-
stead of going through thousands of changes, the reviewer
can go through one change at a time, each explained by the
commit message.
Also, smaller commits enables easier bisecting. This en-
ables techniques such as Delta Debugging [38] to be em-
ployed to nd the root cause of bugs.
Using a DVCS can oer developers more power when it
comes to choosing what to commit. DVCS tools like Git
allow the splitting of commits at line level, which helps when
changes with multiple intents are interleaved in a single le.
This kind of separation is not possible when using SVN. A
participant mentioned that he preferred Git because \it gives
useful tools for splitting or merging commits" .
By splitting changes into multiple and smaller commits
developers can cherry-pick changes. Cherry-picking refers
to the operation of selecting one commit from a branch and
applying it to another one. This way, developers can migrate
changes from one branch to the other without the need to
merge all changes. This has maximum benets when com-
mits carry only one intent, as noted by one respondent who
splits his commits because of \the ability to easily cherry
pick or revert [commits]" .
Developers can remove mistakes and clean a project's his-
tory by squashing their commits. Several respondents men-
tioned that they squash to \To correct a previous commit" or
\To make it easier for people reading the log to understand
what's been changed" . However, we see in observation 6 that
it is not widely used. This is because, sometimes, squashing
leads to a loss of historical data. This information might be
useful in the future when debugging or trying to understand
the origin of some changes.
From observation 7 we learn that developers like DVCS
because of some of their killer features . One that was men-
tioned often was the ability to commit locally: \You get to
commit to a local repository and make your changes public
only when they are ready" . Learning how to use these fea-
tures takes time and eort. Using the same tools allows de-
velopers to keep their level of productivity in the short run.
However, the initial eort and loss of productivity caused by
learning a new version control system or paradigm may pay
o in the long run. One participant reported that he \tried
Git but its too similar yet just dierent enough to confuse
the hell out of me and slow us all down" . Another \[...] was
not happy about this [using Git] to start o with, and it took
me about two years to learn and love Git" . The advantages
of switching would be overall increased productivity, com-
pared to using a CVCS, and better history and management
of software changes.
For researchers: Researchers mining software reposi-
tories and studying discrete changes should focus on DVCSbecause they allow smaller atomic units of change. For refac-
toring researchers, the smaller Git commits could better de-
ne individual changes. For researchers who tie dierent
software artifacts to code, such as bugs, Git commits are
more precise therefore they may have fewer false mappings.
Researchers must be careful when collecting software repos-
itory related metrics. We have found that old repositories
that migrated through several VCS tools present a dierent
behavior than pure repositories. It may be the case that the
culture formed in the era of the rst VCS shadows the subse-
quent ones. There might other phenomena that inuence a
repository's structure. By not paying attention to dierent
phenomena that aect repositories researchers risk biasing
or confounding their results.
There is a lot of noise when studying dierent types of
software changes introduced by commits. As seen in sec-
tion 2.2.2, there are many types of commits and individual
changes that do not constitute acts of development. Re-
searchers should clearly dene what types of changes they
are studying and then take the appropriate actions to l-
ter undesired commits. By not paying attention to dierent
types of commits, researchers risk biasing or confounding
their results.
DVCS allow users to change history before they make
it public or available to others. One participant stated he
squashed commits because he \committed more often locally
while working. That need not be seen in the nal push, be-
cause it usually only adds noise" . This is a threat when
mining repositories. The repository that is publicly avail-
able might not be the one that developers had when they
committed their changes. Squashing is just one of the ways
in which developers can change history. Research on such
repositories should take this threat into account.
For tool builders: Although Git enables ner grained
changes, it is still the developers' task to disentangle these
changes. This is a manual, tedious, and time consuming pro-
cess. VCS tools could keep track of dierent change intents
and then oer to commit them separately. Herzig et al. [24]
show a technique by which this can be achieved. They de-
vised a heuristic untangling algorithm that splits tangled
changes according to dierent source code criteria (e.g., the
distance between two changed AST nodes).
We envision a new generation of tools that can use the
average size of a commit as a quality metric. When a devel-
oper has uncommitted code larger than a threshold, the tool
could suggest that it's time to split changes and commit.
Continuing on the idea of metrics, the eld of software
design aws can be applied to repositories as well. Re-
searchers have identied many software design aws [28].
Marinescu [29] presents detection strategies for these aws,
allowing tools to identify, report and oer suggestions for
improvement. By following this approach researchers can
devise design aws for repositories and then metric based
detection strategies for these aws would allow tools to mea-
sure the health of a repository.
Squashing is a process by which history can be altered
or completely lost. To prevent history loss, VCS tools could
support features such as hierarchical commits: the ability to
create a virtual commit that holds other real commits. In-
stead of loosing history through squashing, developers could
group commits into larger, composite commits.
Our nding that developers from hybrid repositories use
the same habits after switching to DVCS as when they used327CVCS suggests the need for tools to help educate developers
on how to eectively change their habits.
Respondents identied features as an important factor for
using DVCS. Some mentioned that certain features were an
integral part of their workow. Paying attention to these
workows and creating the tools to support them will pay
o in the future. The payo will increase productivity on
the developers side, and bring a larger user base on the tool
builder's side, since developers will prefer a tool that best
ts their work style.
For team management: As Observation 2 states, hy-
brid repositories do not show the same trends as non hybrid
ones. Adopting new tools and new technology is only part
of the change and by no means enough or complete. Tools
that bring a new vision to how software is developed should
be followed by a shift in policy and project culture as well.
One cannot hope to improve the development process by
only improving the tools.
3.2 How does the team size affect VCS usage?
RQ 6: Does team size aect the choice of VCS?
Table 10: VCS choice by team size (%)
VCS
type1 2-5 6 - 10 11 - 25 26 - 100 >100
DVCS 82.22 72.07 62.30 65.22 60.00 70.97
CVCS 17.78 27.93 37.70 34.78 40.00 29.03
Table 10 shows that most teams use the distributed model,
regardless of the team size. However, the presence of the
centralized version control systems increases once the team
size increases.


Observation 10: Teams of all sizes predominantly pre-
fer DVCS
Interpretation: Since 53% of the survey projects are less
than two years old, it is likely that they were developed dur-
ing the rising popularity of the DVCS. As for the popularity
of CVCS at larger teams, this can be interpreted as inertia of
larger teams to use new paradigms and tools. However, once
the team size crosses 100, the overhead of merging changes
pushes the team against their inertia.
RQ 7: Are larger teams more likely to use Issue
Tracking Systems (ITS)?
We are answering this question using two data sources,
the survey and the repository analysis.
Table 11 summarizes results collected from the survey.
Overall, 93.87% of the participants reported using an ITS.
While the value is lower for one-person projects (63%), it is
over 90% in all other cases. More interestingly, all partic-
ipants working in projects with over 100 developers report
using an ITS.


Observation 11: Most projects use an Issue Tracking
System.
The analysis of the repositories shows that 91.6% of the
projects contain commit messages that refer to issues in an
ITS. This correlates with the survey.Table 11: Issue Tracking System (ITS) usage based
on team size (%)
Team size Use an ITS Don't use an ITS
1 63.04 36.96
2 - 5 97.88 2.12
6 - 10 92.23 7.77
10 - 25 95.24 4.76
26 - 100 97.01 2.99
Over 100 100.00 0.00
Overall 93.87 6.13
RQ 8: Does team size aect the size of commits?
We measured the correlation coecient between team size
and commit size (measured in lines of code and number of
changed les). Table 12 shows no linear relation between
team size and the size of commits. This holds for both LOC
and number of les. The fact that all but one coecient are
negative could indicate a weak downhill trend for commit
size as team size increases.
Table 12: Correlation coecients between team size
and commit size
Repository type LOC # of les
Git -0.11 -0.09
SVN -0.07 -0.16
Hybrid GitStage -0.01 0.16
Hybrid SV NStage -0.06 -0.35


Observation 12: There is no discernible relationship
between the team size and the size of commits other
than a weak tendency for commit size to decrease as
team size increases.
Interpretation: We expected to see that commit size de-
creases as team size increases. Small teams can be very agile
and quickly grow the code base because everybody knows
what everybody else is doing. Large teams have less knowl-
edge of the overall task distribution, and they must exer-
cise more care when accepting and integrating changes from
many sources. Therefore, we assumed, large teams would
perform smaller commits to better express changes.
However, the data shows that developers use the same
intuition for splitting changes, regardless of team size. This
could hint that large teams must use other mechanisms to
control the complexity of software changes.
Such mechanisms could be more complex branching and
merging models. Philips et al. [33] show that as projects
grow in size and activity, the complexity of the branching
model increases.
RQ 9: Does team size inuence commit squashing?
Another question is whether developers working in larger
teams squash more frequently than developers working in
smaller teams. Table 13 shows that this could be the case.
While teams of two to ve developers squash only 27% of
the time, teams with over 100 developers squash 57% of the
time. This is more than double the rate compared to smaller
teams. The reasons for this are twofold:328Table 13: Squashing in relation to the team size (%)
Team size Squash Don't squash Not Applicable
1 17.39 56.52 26.09
2-5 27.27 54.55 18.18
6-10 42.25 29.50 28.06
11-25 30.16 50.79 19.05
26-100 40.00 46.15 13.85
Over 100 57.14 34.29 8.57
1. According to RQ 6, larger teams tend to use CVCS
more often.
2. Developers might try to keep the upstream history
clean. Working in a large team means that if every de-
veloper were to push their full history, the main reposi-
tory could get cluttered. So squashing would mitigate
an explosion in the number of commits and branches.


Observation 13: Large teams squash commits more
often.
Implications.
For researchers: Best quality data about issue tracking
systems is obtained from projects developed by large teams.
On the other hand, large teams tend to squash more often
which would result in bigger commits with more entangled
changes. Therefore, researchers may have to trade o some
traits over other ones when choosing to study repositories
from small or large teams.
For tool builders: Practically all large teams use Issue
Tracking Systems in order to track work items. However, in
the current state of practice developers track code and issues
by inserting issue references inside commit messages. This
is tedious and imprecise since developers have to manually
group changes by issue.
Therefore, tool builders should create tools that (i) keep
track of code written for a particular task, (ii) automati-
cally group code changes by issue, and (iii) incorporate issue
tracking inside Version Control Systems.
Tool builders should abstract away low level VCS concepts
in order to ease the learning curve of Version Control Sys-
tems. Instead of using implementation level details (branch,
rebase, hash, etc) as their interface to the user, VCSes could
use a high level vocabulary from the domain of software pro-
cesses (feature, bug, review, etc.).
For team management: Very large teams that strug-
gle with aggregating changes should consider investing the
extra eort and switch to distributed tools (Git, Hg, etc)
and more involved branching models (specialized branches,
deeper forking tree, etc) [33].
3.3 How does the VCS type affect the devel-
opment process?
RQ 10: Does the type of VCS inuence the presence
and the number of issue tracking labels (ITL)?
The survey shows that the majority of developers (69%)
commit only one issue at a time (Table 14). This gure
is slightly smaller for CVCS than it is for DVCS. However,
CVCS developers perform commits with more than one issue
more often (17%) that developer using DVCS (9%).Table 14: Survey: How do developers commit if they
work on more than one issue (%)
1 issue >1 issue Not applicable
Distributed 68.71 8.59 22.7
Centralized 66.67 17.03 16.03
Overall 69.25 11.13 19.13
The repository analysis shows that 31% of all commits
contains an ITL. This mirrors similar ndings by Bird et
al. [15]. The number is higher for Git repositories at 43.42%.
For hybrid repositories the number is at 33.12% compared
to SVN at 13.13%.


Observation 14: A small number of commits are la-
belled with ITL. Nevertheless, issue tracking labels ap-
pear more frequently in DVCS commit messages than
in CVCS commit messages.
Interpretation: The fact that we see a larger number
of developers committing changes belonging to two or more
issues per commit for CVCS might be an indication of a
higher diculty in selecting the changes to be committed.
The dierence in the granularity of change selection between
the tools could explain these results.
The overall low number of commits with ITL can be at-
tributed to a relaxed commit policy. As the repositories are
gathered from open source projects, it may be dicult to
enforce a strict commit policy. To the best of our knowl-
edge, none of the analyzed repositories enforced a practice
of mandatory ITL inclusion in commit messages.
RQ 11: Is there a correlation between the number
of issue tracking labels in the commit message and
the commit size?
We can see that commits to SVN and Hybrid repositories
tend to be larger when more issues appear in the commit
message. The correlation is strong and positive, at 0.68 for
SVN and 0.81 for Hybrid repositories. For Git repositories
this trend does not hold. There is a slight tendency for
commit size to decrease when the number of issue tracking
labels increases. There is a weak negative correlation, at
-0.38). Table 15 shows the detailed results.
Table 15: Average LOC for issue references by VCS
type
VCS
typenumber of issue references corr.
1 2 3 4 5
SVN 33.04 35.69 54.56 31 80 0.68
Git 25.27 36.46 38.05 23 23 -0.38
Hybrid 27.67 31.66 37.74 83.2 62.14 0.81
All 28.59 34.72 39.91 57.78 60.08 0.97



	Observation 15: In SVN and Hybrid repositories com-
mit size is positively correlated with the number of ref-
erenced issues.329


	Observation 16: In Git repositories there is a weak
negative correlation between the commit size and the
number of referenced issues.
Interpretation: The strong correlations for SVN and hy-
brid repositories reinforce the idea that in these repositories
developers tend to group dierent change intents (issues)
together.
In Git, the trend seems to be opposite. This suggests that
Git commits do not get larger in size when they reference
several ITL. Rather, Git commits could contain a change
common to all referenced issues.
Observations 3 and 5 show that developers using DVCS
split their commits more often and that their commits con-
tain ner scoped changes. This hints to the idea that they
might carve out the common piece of code that contributes
to solving both issues.
RQ 12: How does the size of commits vary in time?
In order to investigate how the commit size varies in time,
we averaged the commit size for monthly intervals. We then
calculated correlation coecients for the monthly values of
average commit size.
Table 16 shows that the commit size tends to become
smaller as projects get older. The average age of a typi-
cal repository (time between the rst and the last commit)
is 55 months. For SVN repositories it is 54 months, for
Git repositories it is 30 months and for hybrid ones it is 94
months.
Table 16: Correlation between commit size and com-
mit time
VCS average
corr.# of posi-
tive corr.# of nega-
tive corr.% of nega-
tive corr.
SVN -0.06 21 31 60%
GIT -0.17 13 25 66%
Hybrid -0.11 12 16 57%
ALL -0.11 46 72 61%
The average commit size usually decreases by approxi-
mately 15-20% during the lifetime of a repository. Overall
correlation between commit size and time of commit for all
types of repository is usually negligible (-0.11) and in most
cases appears to be negative.
Commit size tends to decrease more in Git then it does in
SVN. 71% of the analysed Git repositories show decreasing
trends in average commit size over time. For SVN only 60%
showed this trend, while for hybrid repositories this number
constitutes only 57%.


Observation 17: Commit size tends to become smaller
as projects get older.
Interpretation: This decreasing trend can be explained
by dierent types of changes that happen during projects'
life. In the early stages of development, commits tend to be
larger because developers are adding features from scratch.
As the project matures, development switches from adding
new features to performing corrective changes, like bug xes.
Corrective changes are usually smaller in size.Implications.
For researchers: We found that the average commit
size slightly decreases over time. This could be explained by
a variation of change practices during software development
stages (development, testing, support, etc). A more detailed
investigation on how software development stages inuence
change practices is needed.
DVCS commits contain more ITL than CVCS. This sug-
gests that DVCS repositories are better candidates for re-
search projects studying links between commits and issue
tracking systems.
For tool builders: As long as changes tend to become
smaller as projects mature, it becomes worthwhile to rebuild
smaller parts of applications as changes occur. Thus, we
encourage tool builders to provide more support for intra
le incremental builds.
Changes are more granular in DVCSes and usually have
only one issue reference. VCS tool builders could include
new abstractions that represent features. For example, cherry
picking could be done at feature level.
One of the reasons why developers do not put issue num-
bers into commits could be the extra work it involves. Build-
ing upon the suggestion of section 13 for tool builders, there
could be a better integration between VCS and issue track-
ing systems.
For team management: Because commit size tends to
become smaller as projects get older, it is reasonable to as-
sume that developers tend to spend more time analyzing
existing source code instead of adding new code. Therefore
developers' productivity should be measured not only by the
amount of code, but also by the complexity and importance
of their changes.
4. THREATS TO VALIDITY
Construct: Are we asking the right questions? We are
interested in assessing the state of the practice for version
control systems usage. Thus, we think that our research
questions have high potential to provide a unique insight
and value for dierent stakeholders: developers, researchers,
tool builders and team management.
Internal: Is there something inherent to how we collect
and analyze the VCS usage that could skew the accuracy of
our results?
One of the main threats is the practice of squashing com-
mits. As we have shown in RQ 3, squashing is a used practice
among software developers. For DVCS, roughly 36% of de-
velopers squash their commits. Because squashing rewrites
history, it is impossible to detect squashing activity. The
main eect is that commits gets larger, because squashing
combines two or more commits into a single commit. The
result is an increased commit size. Thus, the average com-
mit size for DVCS might be even smaller than the ones we
report. Observation 1 would still stand even in the case of
heavy squashing practices.
Another threat is that our results may be biased by the
development culture. As Rigby et al. [35] mention, commits
done to Open Source Software (OSS) tend to be smaller
than the ones done in proprietary software. However, both
our SVN and Git repositories are originating from the open-
source community, so the OSS culture would aect both in
similar ways.
Also, there is a chance that one developer might use dif-
ferent name aliases when committing in the same repository.330This could aect metrics that rely on team size for reposi-
tories analysis. Even though we have encountered few cases
of aliases usage while analyzing repository data, we also no-
ticed that it is a very rare and exceptional practice.
While designing our survey we aimed at keeping it short.
However, in doing so, some of the participants may have
misunderstood our questions. For example, when we asked
the question \Do you squash your commits?" we were aiming
to nd if developers are using the squash command from Git
or similar tools. This command collapses together commits
after they were committed. However, respondents might
have interpreted the question as squashing multiple changes
before committing. This can explain why 18% of developers
using CVCS reported that they use squashing, even though
this is not possible in CVCS tools. While we did run a
pilot [18] of our survey, there is always the possibility that
we have miscommunicated our intent.
One other threat is the possibility of age bias in our repos-
itories. Since SVN has been available for a longer period of
time, SVN repositories might contain older, more mature
projects than Git repositories.
External: Are our results generalizable for the general
version control usage practice?
While we analyzed 132 repositories from the open source
community, we cannot guarantee that these results will be
the same for proprietary (closed source) software. However,
given the overall agreement between the survey, which was
lled in mostly by developers working with proprietary soft-
ware, and the data we acquired by analyzing the repositories,
we can assume that the general trends that we found will be
true for proprietary software as well.
In our corpus of open-source repositories, 83% of the pro-
jects were developed in Java, and the remaining 16% used
C/C++, Javascript and Python. Moreover, the pure Git
repositories consist of 98% Java projects whereas the pure
SVN repositories consist of 80% Java projects. While we
have no reasons to believe that programming language af-
fects the culture of committing changes, in the future we
plan to diversify our corpus and explore change variation in
programming languages.
The sources for our repositories are GitHub andSource-
Forge . This means that we only looked at projects that
used Git or SVN. We did not study other VCS tools for the
distributed or the centralized paradigm. However, as the
data from our survey indicates, Git and SVN are the pre-
dominant systems used today. They are the most widely
used in their class, thus we think they are representative.
Reliability: Can others replicate our results? The list of
repositories we used for our analysis is available online [11].
Also, the infrastructure we used for the analysis is available
open source as a GitHub repository [5].
5. RELATED WORK
To the best of our knowledge, our paper is the rst study
tocompare the impact of CVCS and DVCS on the practice
of committing changes.
Several researchers [12, 13, 20, 23, 25, 26, 30, 34, 34] studied
the practice of commits but only in the CVCS paradigm.
Purushothaman et al. [34] and German et al. [20] and Hin-
dle et al. [25] studied the properties of typical small commits
or typical large commits. Hattori et al. [23] study the size of
commits with the purpose of classifying changes. Arafat et
al. [13] studied the distribution of commit size. Hofmann etal. [26] predict commit size based on commit history. Herzig
et al. [24] propose an algorithm for untangling changes in
CVCS. However, ours is the rst study to compare the com-
mit size in CVCS and DVCS.
Related with our study about the impact and the presence
of issue tracking systems (ITS), several researchers [14, 16,
22, 31, 37] studied ITS. Tian et al. [37] and Bird et al. [16]
aim to link source code with ITS. Meneely et al. [31] makes
suggestions on improving issue tracking labeling in commit
messages. Bachmann et al. [14] mine bug tracking databases
with the purpose of linking ITS with the software devel-
opment process. Hassan et al. [22] provide an overview of
repository and ITS mining practices. However, none of these
studies compared CVCS and DVCS based on ITS practices.
Recently, researchers started mining DVCS repositories
for collaboration between developers [36], processes [17, 21]
for mining DVCS repositories
6. CONCLUSIONS
In this paper we present the rst in-depth study to mea-
sure the impact of DVCS on software change. To this end
we ran a survey with 820 participants and analyzed a corpus
of 132 repositories.
We found that the use of CVCS and DVCS have observ-
able eects on developers, teams and processes. The most
surprising ndings are that (i) the size of commits in DVCS
was smaller than in CVCS, (ii) developers split commits
(group changes by intent) more often in DVCS, and (iii)
DVCS commits are more likely to reference issue tracking
labels. These show that DVCS contain higher quality com-
mits compared to CVCS due to their smaller size, cohesive
changes and the presence of issue tracking labels.
The survey provided valuable information on why devel-
opers prefer one paradigm versus the other. DVCS are pre-
ferred because of killer features , such as the ability of com-
mitting locally. In contrast CVCS are preferred for their
ease of use and faster learning curve.
We hope that our work inspires future research not only
into the impact that centralized and distributed VCS tools
have on software development but also on how general prop-
erties of VCS tools enable developers to manage and express
change.
7. ACKNOWLEDGEMENTS
We would like to thank Cosmin R adoi, Alexandru Gyori,
David Hartveld, Alex Groce, Michael Rosulek, Will Jerni-
gan, Faezah Bahmani, Iftakar Ahmed, Michael Hilton, Irwin
Kwan, Charles Hill, Amber Horvath, Paul McKenney, and
the anonymous reviewers for feedback on earlier drafts of
this paper.
Also, we would like to thank Joel Spolsky, Robert Martin,
and Steve Berczuk for helping us promote the survey.
This research is partly funded through NSF CCF-1213091
and CCF-1219027 grants, a SEIF award from Microsoft, and
a gift grant from Intel.
8. REFERENCES
[1] Cvs. http://cvs.nongnu.org/ . Accessed February 27,
2014.
[2] Git. http://git-scm.com/ . Accessed February 27,
2014.331[3] gitective: Git repository analysis tool.
https://github.com/kevinsawicki/gitective .
Accessed September 6, 2013.
[4] Github. http://www.github.com/ . Accessed February
27, 2014.
[5] http:/www.github.com/caiusb/gitsvn.
[6] Mercurial. Accessed February 27, 2014.
[7] Sourceforge. http://www.sourceforge.net/ . Accessed
February 27, 2014.
[8] Sourceforge research data archive (srda): A repository
of oss research data. http://srda.cse.nd.edu/
mediawiki/index.php?title=Main_Page . Accessed
September 6, 2013.
[9] Svn. http://subversion.tigris.org/ . Accessed
February 27, 2014.
[10] svn2git: Svn to git repository conversion tool.
https://github.com/nirvdrum/svn2git . Accessed
September 6, 2013.
[11] Vcs usage study companion.
http://tiny.cc/VCStudy .
[12] A. Alali, H. Kagdi, and J. I. Maletic. What's a typical
commit? a characterization of open source software
repositories. In Program Comprehension, 2008. ICPC
2008. The 16th IEEE International Conference on ,
pages 182{191. IEEE, 2008.
[13] O. Arafat and D. Riehle. The commit size distribution
of open source software. In System Sciences, 2009.
HICSS'09. 42nd Hawaii International Conference on ,
pages 1{8. IEEE, 2009.
[14] A. Bachmann and A. Bernstein. Data retrieval,
processing and linking for software process data
analysis. University of Zurich, Technical Report , 2009.
[15] C. Bird, A. Bachmann, E. Aune, J. Duy,
A. Bernstein, V. Filkov, and P. Devanbu. Fair and
balanced?: bias in bug-x datasets. In Proceedings of
the the 7th joint meeting of the European software
engineering conference and the ACM SIGSOFT
symposium on The foundations of software
engineering , pages 121{130. ACM, 2009.
[16] C. Bird, A. Bachmann, F. Rahman, and A. Bernstein.
Linkster: enabling ecient manual inspection and
annotation of mined data. In Proceedings of the
eighteenth ACM SIGSOFT international symposium
on Foundations of software engineering , pages
369{370. ACM, 2010.
[17] C. Bird, P. C. Rigby, E. T. Barr, D. J. Hamilton,
D. M. German, and P. Devanbu. The promises and
perils of mining git. In Mining Software Repositories,
2009. MSR'09. 6th IEEE International Working
Conference on , pages 1{10. IEEE, 2009.
[18] D. S. Cruzes and T. Dyba. Recommended steps for
thematic synthesis in software engineering. In
Empirical Software Engineering and Measurement
(ESEM), 2011 International Symposium on , pages
275{284. IEEE, 2011.
[19] K. Finley. Github has surpassed sourceforge and
google code in popularity.
https://www.readwriteweb.com/hack/2011/06/
github-has-passed-sourceforge.php , 2011.
Accessed February 27, 2014.
[20] D. M. German. An empirical study of ne-grainedsoftware modications. Empirical Software
Engineering , 11(3):369{393, 2006.
[21] G. Gousios and D. Spinellis. Ghtorrent: Github's data
from a rehose. In Mining Software Repositories
(MSR), 2012 9th IEEE Working Conference on , pages
12{21. IEEE, 2012.
[22] A. E. Hassan. The road ahead for mining software
repositories. In Frontiers of Software Maintenance,
2008. FoSM 2008. , pages 48{57. IEEE, 2008.
[23] L. P. Hattori and M. Lanza. On the nature of commits.
InAutomated Software Engineering-Workshops, 2008.
ASE Workshops 2008. 23rd IEEE/ACM International
Conference on , pages 63{71, 2008.
[24] K. Herzig and A. Zeller. The impact of tangled code
changes. In Proceedings of the Tenth International
Workshop on Mining Software Repositories , pages
121{130. IEEE Press, 2013.
[25] A. Hindle, D. M. German, and R. Holt. What do large
commits tell us?: a taxonomical study of large
commits. In Proceedings of the 2008 international
working conference on Mining software repositories ,
pages 99{108. ACM, 2008.
[26] P. Hofmann and D. Riehle. Estimating commit sizes
eciently. In Open Source Ecosystems: Diverse
Communities Interacting , pages 105{115. Springer,
2009.
[27] J. Jan ak. Issue tracking systems. Brno, spring , 2009.
[28] M. Lanza and R. Marinescu. Object-oriented metrics
in practice: using software metrics to characterize,
evaluate, and improve the design of object-oriented
systems . Springer-Verlag New York Inc, 2006.
[29] R. Marinescu. Detection strategies: Metrics-based
rules for detecting design aws. In Software
Maintenance, 2004. Proceedings. 20th IEEE
International Conference on , pages 350{359. IEEE,
2004.
[30] M. Marzban, Z. Khoshmanesh, and A. Sami. Cohesion
between size of commit and type of commit. In
Computer Science and Convergence , pages 231{239.
Springer, 2012.
[31] A. Meneely, M. Corcoran, and L. Williams. Improving
developer activity metrics with issue tracking
annotations. In Proceedings of the 2010 ICSE
Workshop on Emerging Trends in Software Metrics ,
pages 75{80. ACM, 2010.
[32] K. Muslu, C. Bird, N. Nagappan, and J. Czerwonka.
Transition from centralized to distributed vcs: A
microsoft case study on reasons, barriers, and
outcomes. In ICSE '14: Proceedings of the 2012
International Conference on Software Engineering .
IEEE Press, 2014.
[33] S. Phillips, J. Sillito, and R. Walker. Branching and
merging: an investigation into current version control
practices. In Proceedings of the 4th International
Workshop on Cooperative and Human Aspects of
Software Engineering , CHASE '11, pages 9{15, New
York, NY, USA, 2011. ACM.
[34] R. Purushothaman and D. E. Perry. Toward
understanding the rhetoric of small source code
changes. Software Engineering, IEEE Transactions on ,
31(6):511{526, 2005.
[35] P. Rigby, B. Cleary, F. Painchaud, M. Storey, and332D. German. Contemporary peer review in action:
Lessons from open source development. Software,
IEEE , 29(6):56 {61, nov.-dec. 2012.
[36] P. C. Rigby, E. T. Barr, C. Bird, P. Devanbu, and
D. M. German. What eect does distributed version
control have on oss project organization?
[37] Y. Tian, J. Lawall, and D. Lo. Identifying linux bugxing patches. In Software Engineering (ICSE), 2012
34th International Conference on , pages 386{396.
IEEE, 2012.
[38] A. Zeller. Yesterday, my program worked. today, it
does not. why? In Software
Engineering-ESEC/FSE'99 , pages 253{267. Springer,
1999.333