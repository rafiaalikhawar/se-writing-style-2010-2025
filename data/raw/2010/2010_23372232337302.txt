Simulation-Based Abstractions for Software Product-Line Model Checking
Maxime Cordy,* Andreas Classen,*
Gilles Perrouin, Pierre-Yves Schobbens
PReCISE Research Center,
University of Namur, Belgium.
{mcr, acs, gpe, pys}@info.fundp.ac.bePatrick Heymans
PReCISE Research Center,
University of Namur, Belgium.
INRIA Lille-Nord Europe –
Universi ´e Lille 1, France.
LIFL – CNRS, France.
phe@info.fundp.ac.beAxel Legay
IRISA/INRIA Rennes, France.
Aalborg University, Denmark.
University of Li `ege, Belgium.
axel.legay@inria.fr
Abstract —Software Product Line (SPL) engineering is a
software engineering paradigm that exploits the commonality
between similar software products to reduce life cycle costs and
time-to-market. Many SPLs are critical and would beneﬁt from
efﬁcient veriﬁcation through model checking. Model checking
SPLs is more difﬁcult than for single systems, since the number
of different products is potentially huge. In previous work, we
introduced Featured Transition Systems (FTS), a formal, com-
pact representation of SPL behaviour, and provided efﬁcient
algorithms to verify FTS. Yet, we still face the state explosion
problem, like any model checking-based veriﬁcation. Model
abstraction is the most relevant answer to state explosion. In
this paper, we deﬁne a novel simulation relation for FTS and
provide an algorithm to compute it. We extend well-known
simulation preservation properties to FTS and thus lay the
theoretical foundations for abstraction-based model checking
of SPLs. We evaluate our approach by comparing the cost of
FTS-based simulation and abstraction with respect to product-
by-product methods. Our results show that FTS are a solid
foundation for simulation-based model checking of SPL.
Keywords -Model Checking; Software Product Lines; Formal
methods; Simulation; Abstraction; Feature
I. I NTRODUCTION
Software Product Line (SPL) engineering is an increas-
ingly popular software development paradigm targeting
families of similar software products. It allows to make
substantial economies of scale by taking into account the
commonalities between the family members during the
whole development life cycle. The different variants of the
system (called products) are identiﬁed upfront and a model
of their differences and commonalities – typically a feature
diagram [1] – is created. In this context, features are atomic
units of difference that appear natural to stakeholders and
technicians alike. SPL engineering has become widespread
in industry, including critical applications such as automotive
or avionics. These software products require solid evidence
that they work correctly according to their requirements and
intended properties.
Model checking [2] is a well-known technique for ver-
ifying system behaviour. A simple method for checking
* FNRS research fellowa product line consists in applying single-system model
checking algorithms [3], [4] to each individual product.
However, for an SPL with nfeatures, up to 2nexecutions of
those algorithms may be needed. This enumerative approach
is clearly impractical and thus should be replaced by new
veriﬁcation approaches speciﬁc to product lines.
In our previous work [5]–[7], we addressed this problem
by introducing Featured Transition Systems (FTS) – see
example in Figure 1. FTS are an extension of transition
systems that represent the behaviour of allthe products
of a given SPL in a compact structure. We also proposed
FTS-speciﬁc model checking algorithms to verify the whole
SPL in a single execution. More precisely, these algorithms
model check the SPL against temporal properties expressed
either in Linear Time Logic (LTL) [8] extended with features
(fLTL) or in an extended Computation Tree Logic (CTL) [9],
fCTL. These logics can be used to express properties such
as:for all products with features fandg, a requestαis
always followed by a response β. Given such a property,
our algorithms can compute the features required for the
property to be satisﬁed, and hence the products of the SPL
that do satisfy the property. We call them FTS algorithms .
We evaluated the efﬁciency of the FTS algorithms through
the implementation of several libraries and tools. First, we
developed a Haskell library for checking an FTS against
LTL formulae [5]. We also built an extension to the model-
checker NuSMV to verify CTL formulae using the FTS
algorithms [6]. Recently, we developed SNIP [7], an SPL
model-checking toolset that combines the FTS algorithms
with Promela, the high-level speciﬁcation language used in
the well-known model-checker SPIN [10].
Early experiments have shown that the FTS model-
checking approach is more efﬁcient than the enumerative
approach. Indeed, when comparing the two approaches im-
plemented within our tools, we observe that FTS algorithms
generally outperform the enumerative method [5]. However,
our experiments also have shown that there is still much
room for improvement. SPL veriﬁcation theory is still at
an early stage and needs to be further improved to target
industry-scale SPL veriﬁcation.978-1-4673-1067-3/12/$31.00 c2012 IEEE ICSE 2012, Zurich, Switzerland 672
Model abstraction is an optimisation that aims to simplify
a model prior to its veriﬁcation [11]. Roughly speaking, an
abstraction function is used to reduce the size of a model by
merging similar states. Depending on the deﬁnition of this
function, the behaviour of the model may change, that is,
new behaviours may appear, existing ones may disappear,
or both. Characterising the abstracted model with respect to
the original one is therefore essential since those behavioural
modiﬁcations may impact on the satisﬁability of temporal
properties. Such a characterisation is generally obtained
thanks to the deﬁnition of a simulation relation [12].
In this paper, we lay the theoretical foundations for
abstraction-based model checking of SPLs. First, we extend
the deﬁnition of simulation from transition systems to FTS
and propose an algorithm that computes this relation. We
then establish which properties are preserved by the simu-
lation relation, and for which products. This is required to
perform reliable checking. Then, we deﬁne three abstractions
based on the notion of simulation quotient [13] that can
be applied to remove redundant behaviour in an FTS and
thus reduce veriﬁcation time. In addition to abstraction,
simulation relations have numerous applications. In par-
ticular, simulation-based model checking is an established
veriﬁcation method, as LTL/CTL model checking is. Our
solution allows easier veriﬁcation of properties modelled
visually (as automata) rather than logical formulae, which is
more suitable for engineers. Studying FTS simulation is thus
as important as generalising LTL/CTL model checking to
FTS. We provide a concrete implementation for computing
simulation and applying abstraction to FTS. We carry out a
complexity evaluation and empirical evaluations that reveal
substantial efﬁciency improvements over enumerative appli-
cation of classical simulation. This corroborates previous
results by characterising the gain of FTS-based simulation
model checking over enumerative, TS-based, simulation
model checking.
The structure of the paper is as follows. In Section II, we
recall essential results, theorems and properties related to the
abstraction of transition systems, as well as the deﬁnition
of FTS. Section III is focused on the deﬁnition and the
computation of the simulation relation. Section IV deﬁnes
the simulation quotient as well as abstraction functions based
on it. Section V describes or experiments and their results.
Finally, Section VI presents related work in the ﬁelds of SPL
modelling and abstraction-based veriﬁcation.
II. B ACKGROUND
In this section, we ﬁrst present the established concepts
related to the veriﬁcation and the abstraction of Transition
Systems (TS). TS are a classical behavioural model for
single systems. We also brieﬂy recall some deﬁnitions of
our previous work [5], [6] that are needed in the paper.A. Single-Product Model Checking
Model checking is a well-known technique for verifying
both hardware and software against temporal properties.
Basically, given the model of a system Mand a temporal
property Φ, a model-checking algorithm determines whether
or notMsatisﬁes Φ, writtenM|= Φ. For single systems
TS are used and are deﬁned as follows [13].
Deﬁnition 1 A TS is a tuple (S,trans,I,AP,L )whereSis
a set of states, trans⊆S×Sis a transition relation, I⊂S
is a set of initial states, APis a set of atomic propositions,
andL:S→2APis a labelling function that associates
every states with the set of atomic propositions satisﬁed by
this state.
We call a behaviour of the system the sequence of atomic
propositions satisﬁed during its execution. The semantics of
a TS, noted [ [ts] ]TS, is then its set of behaviours, that is
[ [ts] ]TS={L(s0),L(s1),...|s0∈I∧(si,si+1)∈trans}.
Note that the deﬁnition of TS usually includes a set of
actions. However, these are not considered in this paper and
consequently, they are ignored in our deﬁnition, which thus
boils down to a Kripke structure.
TS can model a software product at different abstraction
levels. If a more abstract (that is, smaller) model preserves
the properties of a larger model, it is more efﬁcient to check
properties on the abstract model. It is therefore essential to
be able to relate two models at different abstraction levels.
For single systems, this information is formally captured by
asimulation relation [12].
Deﬁnition 2 LetTSi= (Si,trans i,Ii,AP,L i),i∈{1,2}
be transition systems over AP. A simulation for (TS1,TS 2)
is a binary relation R⊆S1×S2such that
1)∀s1∈I1•∃s2∈I2•(s1,s2)∈R and
2)∀(s1,s2)∈R it holds that
a)L1(s1) =L2(s2)and
b)∀s/prime
1∈Post (s1)•∃s/prime
2∈Post (s2)•(s/prime
1,s/prime
2)∈
R.
wherePost (s) ={s2|trans (s,s2)}denotes the set of states
that can be reached from s. Then,TS2simulatesTS1,
denoted by TS1/precedesorcurlyTSTS2if there exists a simulation for
(TS1,TS 2).
According to this deﬁnition, if TS1is simulated by TS2,
then any behaviour of TS1can be reproduced in TS2. We
can extend this deﬁnition to couples of states instead of
couples of TSs. In this case, state s1is simulated by state
s2iff(s1,s2)∈ R for someR, also noted s1/precedesorcurlyTSs2.
Intuitively, this means that any behaviour produced from s1
can be produced from s2. Also, /precedesorcurlyTSis a preorder – it is re-
ﬂexive and transitive [13]. Additionaly, when TS1/precedesorcurlyTSTS2
andTS2/precedesorcurlyTSTS1, the two transition systems are called
simulation-equivalent , notedTS1/similarequalTSTS2. Intuitively, this673means thatTS1andTS2model exactly the same behaviour.
Since/precedesorcurlyTSis a preorder,/similarequalTSis an equivalence relation [13].
The deﬁnition of simulation allows one to characterise the
behaviour of an abstract transition system /hatwidetswith regard
to an original model ts. Informally, an abstract transition
system is obtained by merging states for which a so-called
abstraction function returns the same value. The abstraction
may add or remove behavioural options, depending on the
chosen abstraction function. However, a relevant analysis
requires to have either ts/precedesorcurlyTS/hatwidets,ts/precedesorcurlyTS/hatwidetsor both. If
this condition is satisﬁed, we can show that the abstraction
preserves the (un)satisﬁability of properties of a certain type.
Indeed, there is a strong link between the simulation
relation and the properties satisﬁed by two TSs. In this
paper, we focus on properties expressed in Linear Time
Logic (LTL) [8]. However, the presented results can also
be applied to speciﬁc fragments of the Computation Tree
Logic (CTL) [9]. If a simulation relation exists between
two transition systems, we can show that an LTL formula
satisﬁed by the simulating TS is preserved in the simulated
one [12], [13].
Property 3 LetTS1andTS2be two transition systems
without terminal states and Φan LTL property. Then,
TS1/precedesorcurlyTSTS2⇒(TS2|= Φ⇒TS1|= Φ).
The following statement is equivalent: if TS1does not satify
Φ, neither does TS2. Finally, if TS1/similarequalTSTS2, then they
satisfy exactly the same LTL properties. In particular, if TS2
is an abstraction of TS1, proving that the abstract TS veriﬁes
an LTL formula sufﬁces to ensure that the formula holds for
TS1. Therefore, abstraction can drastically shorten the time
and space cost of veriﬁcation.
B. Software Product Line Veriﬁcation
While a TS is convenient to model the behaviour of an
individual product of an SPL, it is not suitable for concisely
representing all the possible products. To overcome this, we
deﬁned Featured Transition Systems (FTS) [5]. Basically, an
FTS is a TS augmented with transitions labelled with feature
expressions (see Figure 1). These features are described in
afeature diagram (FD) that establishes the set of legal
products [1], [14]. For this paper, it is enough to know that
the semantics of a feature diagram ddeﬁned over a set of
featuresNis the set of all the valid products, that is a set
of sets of features, denoted by [ [d] ]FD⊆P(N). Schobbens
et al. [1] give a more thorough and formal deﬁnition of FD.
Also, every transition of an FTS is labelled with a feature
expression that deﬁnes the products able to execute the
transition. Formally, FTS are deﬁned as follows [5], [6].
Deﬁnition 4 An FTS is a tuple (S,trans,I,AP,L, d, γ ),
where
•S,trans,I,AP,L are deﬁned as in Deﬁnition 1,
•dis a feature diagram,•γ:trans→/parenleftbig
{0,1}|N|→{0,1}/parenrightbig
is a total function,
labelling each transition with a feature expression ∈
B(N), i.e., a Boolean function over the set of features.
By[ [γ(t)] ], we denote the set of products that satisfy
γ(t).
Similarly with TS, our deﬁnition of FTS does not include a
set of actions.
An FTS can be seen as the merging of all the TSs of
the products that compose the SPL. Because of that, the
successor operator must be redeﬁned in order to take into
account that a state can be a successor of another one only
for a speciﬁc set of products [5].
Deﬁnition 5 The successors of s∈Sfor products px⊆
P(N)are given by
Post (s,px) ={(s/prime,px/prime)|(s,s/prime)∈trans
∧px/prime=px∩[ [γ(s,s/prime))}] ].
Furthermore, any TS corresponding to a speciﬁc product
can be obtained from the FTS by applying a projection
function. In simple terms, this function removes all the
transitions of the FTS whose feature expression is not
satisﬁed by the considered product [5].
Deﬁnition 6 The projection of an FTS ftsto a product p∈
[ [d] ]FD, notedfts|p, is the TSts= (S, trans/prime, I, AP, L )
wheretrans/prime={t∈trans|p∈[ [γ(t)] ]}.
Because the FTS represents the behaviour of allthe prod-
ucts, its semantics is deﬁned as a function that associates a
product with the set of behaviours of its projection.
Deﬁnition 7 The semantics of an FTS fts is a function
[ [fts] ]FTS with domain [ [d] ]FDsuch that
∀p∈[ [d] ]FD•[ [fts] ]FTS(p) = [ [fts|p] ]TS.
Finally, in [6], we extended CTL to deﬁne a property only
on a subset of the valid products. The same extension can
easily be applied to LTL.
Deﬁnition 8 An fLTL property Ψis an expression Ψ = [χ]Φ
whereχ:{0,1}|N|→{0,1}is a feature expression and Φ
an LTL property. An FTS ftssatisﬁes an fLTL property [χ]Φ
iff
∀p∈[ [d] ]FD∩[ [χ] ]•fts|p|= Φ.
III. S IMULATION RELATION FOR SPL M ODELS
Since a model abstraction does not necessarily verify the
same properties as the original model, it is essential to char-
acterise the behavioural inconsistencies between the model
and its abstraction. In the previous section, we presented
the simulation for TSs as a computable relation that can
establish this characterisation. However, their deﬁnition is
clearly unsuitable in our context because we are interested
in abstracting SPL models rather than models of individual
systems. In this section, we thus introduce a deﬁnition674of simulation for FTS. We also propose an algorithm to
compute it and we establish a link between the latter and
the preservation of fLTL formulae.
A. Simulation Relation for FTS
As a ﬁrst step, we extend the deﬁnition of simulation to
FTS. For this purpose, we ﬁrst impose the restriction that a
simulation relation can only hold between two FTS deﬁned
over the same FD . Intuitively, an FTS simulates another one
iff every valid product has more behaviour in the former FTS
than in the latter. Formally, this condition can be expressed
using the simulation on TS as deﬁned previously.
Deﬁnition 9 Letftsi= (Si,trans i,Ii,APi,Li,d,γi),
i∈{1,2}, be FTS with AP1⊆AP2. Then,fts1is simulated
byfts2for products [ [fts1/precedesorcurlyFTSfts2] ]⊆[ [d] ]FD, where
[ [fts1/precedesorcurlyFTSfts2] ] ={p∈[ [d] ]FD:fts1|p/precedesorcurlyTSfts2|p}.
Since the semantics (fts1/precedesorcurlyFTSfts2)is a set of products,
we see it as a feature expression. Furthermore, fts1is com-
pletely simulated by fts2iff[ [fts1/precedesorcurlyFTSfts2] ] = [ [d] ]FD.
Note that this deﬁnition does not consider illegal products,
that is products that are not included in [ [d] ]FD.
Thanks to the above deﬁnition, we can already determine
for which products an FTS simulates another. However, this
would require computing the simulation relation on TS for
O(2n)couples of TS, which sums up to an overall time
complexity bounded by O(|S|4.2n)[13]. Instead, we aim
to take advantage of the compact structure of FTS, as we
did for solving the model checking problem for SPL in our
previous work [5], [6]. Hence, we propose the following
alternative deﬁnition.
Deﬁnition 10 Letftsi= (Si,trans i,Ii,APi,Li,d,γi),
i∈{1,2}, be featured transition systems with AP1⊆AP2.
A simulation for (fts1,fts 2)is a binary function R:S1×
S2→B(N)such that
R(s1,s2) =
(L1(s1) = (L2(s2)∩AP1))∧/logicalanddisplay
s/prime
1Rvia(s1→s/prime
1,s2)
whereRvia(s1→s/prime
1,s2)is given by
γ1(s1,s/prime
1)⇒/logicalordisplay
s/prime
2(R(s/prime
1,s/prime
2)∧γ2(s2,s/prime
2))
with(s1,s/prime
1)∈trans 1and(s2,s/prime
2)∈trans 2.
Then,fts1is simulated by fts2for products
[ [/logicalandtext
i1∈I1/logicalortext
i2∈I2RFTS(i1,i2)] ]⊆[ [d] ]FD whereRFTS
is the largest simulation for (fts1,fts 2). By largest, we
mean that for any states s1,s2and simulationRfor
(fts1,fts 2), we have [ [R(s1,s2)] ]⊆[ [RFTS(s1,s2)] ].
This deﬁnition can be seen as a generalisation of Deﬁ-
nition 2. Intuitively, [ [RFTS(s1,s2)] ]contains only productsState→Transition fFeature
{a} {b}
s1 s/prime
1
{a}{b} {b}
s2 s/prime
2fs/prime/prime
2¬f
f ¬f
Figure 1. Two simulation-equivalent FTS.
for whichs2has more behaviour than s1. In other words,
for each product p∈[ [RFTS(s1,s2)] ]and transition (s1,s/prime
1)
available for p,s2must have at least one successor s/prime
2
reachable by pand such that p∈[ [RFTS(s/prime
1,s/prime
2)] ]. Similarly,
[ [Rvia(s1→s/prime
1,s2)] ]contains only products for which s2
can simulate the transitions from s1tos/prime
1. Let us note that,
according to our deﬁnition:
•[ [RFTS(s1,s2)] ]/negationslash=∅implies that all atomic proposi-
tion satisﬁed by s1(that is, propositions in AP1) are
satisﬁed by s2.
•for givens1ands/prime
1such thatRvia(s1,s2,s/prime
1) = (px∨
px/prime), it may happen that s2simulates a transition s1→
s/prime
1for products pxvia a transition s2→s/prime
2and for
productspx/primethanks to another transition s2→s/prime/prime
2.
To illustrate this second remark, let us consider the ba-
sic example presented in Figure 1. We observe that
RFTS(s/prime
1,s/prime
2) = fandRFTS(s/prime
1,s/prime/prime
2) =¬f. Furthermore,
s2simulatess1for products [ [f] ]through transition (s2,s/prime
2)
and for products [ [¬f] ]via transition (s2,s/prime/prime
2). In the end, we
conclude that s2simulatess1for all products.
As established in the following theorem, the two deﬁni-
tions of simulation for FTS we have given are equivalent.
Due to lack of space, we omit the proof but the interested
reader can ﬁnd it in our technical report [15].
Theorem 11 Letftsi,i∈{1,2}, be FTS. LetRFTS be
the largest simulation for (fts1,fts 2). Then, it holds that
[ [fts1/precedesorcurlyFTSfts2] ] = [ [RFTS(fts1,fts 2)] ].
As for TS, we can deﬁne simulation-equivalence for FTS.
Intuitively, two FTS are simulation-equivalent for products
pxiff they have the same behaviour for all these products.
Deﬁnition 12 Letfts1andfts2be two FTSs. If
[ [fts1/precedesorcurlyFTSfts2] ] =pxand[ [fts2/precedesorcurlyFTSfts1] ] =px/prime
thenfts1andfts2are called simulation-equivalent for
products in [ [fts1/similarequalFTSfts2] ] =px∩px/prime. Furthermore,
they are called completely simulation-equivalent iff
[ [fts1/similarequalFTSfts2] ] = [ [d] ].675B. Computing the Simulation Relation
We proposed two equivalent deﬁnitions of the simulation
relation for FTS. While the former is more intuitive, it
is cumbersome to compute for a large SPL, i.e.with a
high number of products. On the contrary, the latter takes
advantage of the compact structure of the FTS. In this
subsection, we present a method to compute the relation
using this second deﬁnition. Basically, RFTS is obtained,
for all couples of states of a given FTS, by computing the
greatest ﬁxed point of a function.
First, we need to deﬁne a partial order ≤on the feature
expressions. Let eande/primebe two feature expressions. We say
thateis included in e/prime, notede≤e/prime, iff[ [e] ]⊆[ [e/prime] ]. Using
this partial order, we deﬁne that Ris included inR/prime, noted
R⊆R/prime, iff
∀(s1,s2)•R(s1,s2)≤R/prime(s1,s2).
Then, the simulation function can be computed as the
greatest ﬁxed point of the equations of Rin Deﬁnition 10,
denoted by T(R). Note that∀R•∀i≥0•T(R)⊆R .
Then according to the Knaster–Tarski theorem, RFTS can
be computed as follows:
RFTS=Ri•∀j≥i•Ri=Rj
with∀s1,s2
R0(s1,s2) =/braceleftBigg
B([ [d] ]FD), L(s1) =L(s2)∩AP1
B(∅), otherwise
Ri+1(s1,s2) =T(Ri)(s1,s2)
where for a set of products px,B(px)denotes a feature
expression such that [ [B(px)] ] =px.
Thanks to this algorithm, we can compute (fts1/precedesorcurlyFTS
fts2)for anyftsi= (Si,Acti,trans i,Ii,APi,Li,d,γi).
For this purpose, we apply it to the FTS fts1⊕fts2, which
is deﬁned by
fts1⊕fts2= (S1/unionmultiS2,trans 1∪trans 2,
I1∪I2,AP 1∪AP2,L,d,γ )
where/unionmultidenotes the disjoint union, L(s) =Li(s)iffs∈
Si, andγ(t) =γi(t)ifft∈trans i. Using the value of
RFTSbetween each initial state of fts1and each initial state
offts2, we determine (fts1/precedesorcurlyFTSfts2). Note that Baier
and Katoen [13] present a similar method for computing the
simulation relation between two TS.
C. Property Preservation
The simulation relation for TS is particularly well-known
for its interesting preservation properties [2], [12], [13]. In
particular, if TS2simulatesTS1, then any LTL property
satisﬁed by TS2is also satisﬁed by TS1. As we show in
this section, a similar results holds for FTS simulation.First, we must deﬁne a new notion of satisﬁability speciﬁc
to product lines. Indeed, the model-checking problem for
SPL does more than determining the satisﬁability of a
formula: it requires to identify all the products that do not
satisfy the formula, hence the need of a new satisﬁability
relation.
Deﬁnition 13 Letfts be a FTS and Ψ = [χ]Φan fLTL
property. Then, the F-satisﬁability of Ψbyfts, noted
fts|=FΨ, is a feature expression such that
[ [fts|=FΨ] ] ={p∈[ [d] ]FD:p∈[ [χ] ]⇒fts|p|= Φ}.
Similarly, we deﬁne the F-unsatisﬁability of Ψbyfts, noted
fts/negationslash|=FΨ, as a feature expression such that
[ [(fts/negationslash|=FΨ)] ] ={p∈[ [d] ]FD∩[ [χ] ] :fts|p/negationslash|= Φ}.
It has to be noted that {[ [fts|=FΨ] ],[ [fts/negationslash|=FΨ] ]}is a
partition of [ [d] ]FD. Thanks to Deﬁnitions 9, 10, and 13,
Property 3 can be generalised to FTS, as established in the
following theorem. Again, we omit the proof and refer the
reader to our technical report [15].
Theorem 14 Letftsi= (Si,Acti,trans i,Ii,AP,Li,d,
γi),i∈{1,2}, be two FTS, Ψ = [χ]Φan fLTL property,
andpx= [ [fts1/precedesorcurlyFTSfts2] ]. Then, it holds that
p∈px⇒(p∈[ [fts1/negationslash|=FTSΨ] ]⇒p∈[ [fts2/negationslash|=FTSΨ] ])
p∈px⇒(p∈[ [fts2|=FTSΨ] ]⇒p∈[ [fts1|=FTSΨ] ]).
In particular, this theorem implies that two com-
pletely simulation-equivalent FTS have the same F-
(un)satisﬁability.
IV. FTS S IMULATION QUOTIENT
In the previous section, we deﬁned a simulation relation
for FTS and we established the link between this relation
and the F-satisﬁability of an fLTL property. Our objective
is to present, through the study of simulation quotient, how
we can deﬁne FTS abstractions. We also make use of the
preservation properties (see Theorem 14) to determine how
the veriﬁcation of an abstract FTS provides information
about the original system.
A. Simulation Quotient
The ﬁrst abstraction we introduce does not modify the be-
haviour of the FTS to which it is applied. It merely consists
in deﬁning the simulation quotient [13] for FTS. This form
of abstraction merges states that are completely simulation-
equivalent, i.e.for all products in [ [d] ]FD. Formally, we deﬁne
the binary relation
/similarequald
FTS⊆S×S•s1/similarequald
FTSs2⇔RFTS(s1,s2) = [ [d] ]FD.
This relation is an equivalence, since /similarequalTSis also an equiva-
lence relation [13]. Therefore, the state space of any FTS can
be partitioned into equivalence classes under /similarequald
FTS. Our ﬁrst676abstraction function merges states of the same equivalence
class. [s]//similarequald
FTSdenotes the equivalence class of s.
The function associates an FTS fts with an abstracted
FTSfts//similarequald
FTS= (S/prime,trans/prime,I/prime,AP,L/prime,d,γ/prime)such that
S/prime={[s]//similarequald
FTS}
trans/prime={([s]//similarequald
FTS,[s/prime]//similarequald
FTS)
|(s,s/prime)∈trans}
I/prime={[s]//similarequald
FTS|s∈I}
L/prime([s]//similarequald
FTS) =L(s),
γ/prime(([s]//similarequald
FTS,[s/prime]//similarequald
FTS)) =/logicalordisplay
s/prime/prime,s/prime/prime/primeγ(s/prime/prime,s/prime/prime/prime)
wheres/prime/prime∈[s]//similarequald
FTS,s/prime/prime/prime∈[s/prime]//similarequald
FTS, and (s/prime/prime,s/prime/prime/prime)∈
trans . It thus requires to compute ﬁrst the simulation re-
lation for every pair of states in the FTS (see Section III-B).
Such an abstracted FTS has exactly the same behaviour as
the FTS on which the function is applied, that is (fts/similarequalFTS
fts//similarequald
FTS) = [ [d] ]FD. Indeed, we merge only states that are
simulation-equivalent for every products in [ [d] ]FD. Thus, the
merging neither adds nor removes any behaviour. It is only
meant to remove redundancy. According to Theorem 14, this
implies that the two FTS have the same F-(un)satisﬁability
with regard to any fLTL formula. A formal proof is available
in our technical report [15].
In spite of its straightforward computation, this ﬁrst
abstraction function has shown to be inefﬁcient when it
comes to actually reducing the state-space, as we will
see in Section V. Consequently, we deﬁne more efﬁcient
abstraction methods.
B. Reachability-Aware Simulation Quotient
The second abstraction method is similar to the ﬁrst
one, but it takes into account the reachability of each state
when determining the equivalence classes. It requires the
computation of a function /precedesorcurlyRch•S×S→B(N). In
simple terms, s1/precedesorcurlyRchs2gives a feature expression satisﬁed
by the products for which s1ands2simulate each other,
while considering the reachability relation associated with s1
ands2respectively. More precisely, we deﬁne the following:
•s2trivially simulates s1for products that cannot reach
s1;
•s2cannot simulate s1for products that can reach s1
but nots2.
According to this deﬁnition, (s1/precedesorcurlyRchs2)is given by
Reach (s1)⇒(Reach (s2)∧RFTS(s1,s2))
whereReach (s)denotes a feature expression satisﬁed by
the products that can reach state s.
Next, we deﬁne the binary relation /similarequalRch⊆S×Ssuch
thats1/similarequalRchs2iff(s1/precedesorcurlyRchs2)∧(s2/precedesorcurlyRchs1) = [ [d] ]FD.
Again,/similarequalRch is an equivalence relation. It is obviouslyreﬂexive and symmetric. Its transitivity can be demonstrated
by ﬁrst observing that
(RFTS(s1,s2)∧RFTS(s2,s3))⇒RFTS(s1,s3)
(see [15] for a formal proof). Consequently, the state space
of an FTS can be partitioned into equivalent classes under
/similarequalRch. Using this binary relation, we deﬁne an abstraction
function that merges the states of an FTS according to their
equivalence class under /similarequalRch. Hence, the results of applying
the function on an FTS ftsis an abstracted FTS fts//similarequalRch,
which is deﬁned similarly to fts//similarequald
FTS.
We can show that this abstracted FTS has exactly the same
behaviours as the original one, that is fts/similarequalFTSfts//similarequalRch.
Again, due to lack of space, we present the proof only
intuitively and we refer to [15]. Let p∈[ [d] ]FDbe a product.
Ifs1/similarequalRchs2, thenpcan reach either both s1ands2or
none of them:
1) Ifpcan be reached by both s1ands2, it means that it
has exactly the same behavioural options in s1ands2
by deﬁnition of/similarequalRchandRFTS. Therefore, merging
s1ands2would not add any behaviour to p.
2) Ifpcan reach neither s1nors2, then merging the
two would not actually add behaviour to psince it
would not be able to reach the resulting abstracted
state anyway.
Thus, for any fLTL property Ψ,(fts|=FΨ) =
(fts//similarequalRch|=FΨ).
C. Reachability-Aware Preorder-Based Abstraction
Unlike the previous ones, the last abstraction actually
modiﬁes the behaviour of the FTS on which it is ap-
plied. Although it preserves the existing behaviour, it may
add some. Informally, for any couple of states (s1,s2), if
(s1/precedesorcurlyRchs2) = [ [d] ]FD, thens1is integrated into s2.
By integration, we mean that all the transitions going to
s1are redirected to s2ands2as well as its outgoing
transitions are discarded. Since s2simulatess1for any
product, we do not remove any behaviour from the FTS.
However, new behavioural options may appear for products
in[ [d] ]FD∩[ [¬(s2/precedesorcurlyRchs1)] ](see [15] for a formal proof).
Let us observe that this form of abstraction is not a
function, since for a given FTS it may lead to several
abstracted FTS. For example, let s1,s2,s3be three states
such that (s1/precedesorcurlyRchs2) = (s1/precedesorcurlyRchs3) = [ [d] ]FD,
(s2/precedesorcurlyRchs3) = (s3/precedesorcurlyRchs2)/negationslash= [ [d] ]FDand there exists
nos4such that (s2/precedesorcurlyRchs4) = (s3/precedesorcurlyRchs4) = [ [d] ]FD.
This implies that s1can be integrated into either s2ands3,
but these two will never be merged.
Instead of deﬁning formally the set of FTS that can
result from one of these abstractions, we give an algorithm
to greedily build one of its element (see Algorithm 1).
First, we register the couples of states (s1,s2)such that
(s1/precedesorcurlyRchs2) = [ [d] ]FDin a setR(line 1). Next, we677keep merging states as much as possible (lines 2-14). At
each iteration, we remove an element of R(andS/prime) non-
deterministically (lines 3-4). Let (s1,s2)be this element.
Then,s1is not part of S/prime, the state-space of the abstract
FTS (line 5). Furthermore, if s1was an initial state, then s2
becomes an initial state of the abstract FTS (lines 6-8). As
mentioned earlier, each transition of the form (s,s1),s/negationslash=s1,
is transformed into a transition (s,s2)and the new transition-
labelling function γ/primeis modiﬁed accordingly (lines 9-13).
Algorithm 1 Computation of the preorder-based abstraction
Require: An FTS (S,trans,I,AP,L,d,γ ).
Ensure: An abstract FTS /hatwiderfts smaller than fts and such
that(fts/precedesorcurlyFTS/hatwiderfts) = [ [d] ]FD.
1:R←{(s1,s2) :s1/negationslash=s2∧(s1/precedesorcurlyRchs2) = [ [d] ]FD}
2:whileR/negationslash=∅do
3: Let(s1,s2)∈R
4:R←R\{(s,s/prime)∈R|s=s1∨s/prime=s1}
5:S=S\{s1}
6: ifs1∈Ithen
7:I←(I∪{s2})\{s1}
8: end if
9:remove←{(s,s/prime)∈trans|s=s1∨s/prime=s1}
10:trans←(trans\remove )∪{(s,s2)|s/negationslash=s1∧
(s,s1)∈remove}
11: for alls:{(s,s1),(s,s2)}⊆trans do
12:γ/prime(s,s2)←γ(s,s1)∨γ(s,s2)
13: end for
14:end while
15:return (S,trans,I,AP,L,d,γ/prime)
V. E VALUATION
This section describes a theoretical evaluation of the
algorithms as well as experiments we conducted to evaluate
the time and space gain obtained thanks to the abstraction
methods.
A. Theoretical Evaluation
At the heart of our method is the computation of the
simulation function, as speciﬁed in Section III-B.
Theorem 15 The time complexity of computing the simu-
lation function is bounded by O(|S|6.23n), wherenis the
number of features.
Letkbe the smallest such that ∀j >k•Rk=Rj. For
i<k , there is at least one triplet (s1,s2,p)∈S×S×[ [d] ]FD
such thatp∈[ [Ri+1(s1,s2)] ]\[ [Ri(s1,s2)] ]. Consequently,
k≤ |S|2.2n. Assume we represent each R(s1,s2)by a
Binary Decision Diagram (BDD). It is at most of size O(2n).
ComputingRi+1is a conjunction or disjunction on pairs of
transitions. These operations are quadratic in the size of the
BDD. Thus, each step takes |trans|2.22n≤|S|4.22n.Table I
VERIFICATION TIME OF THE SIMULATION RELATION (IN SECONDS )
Def. 9 Def. 10
mbase/precedesorcurlyFTSmext 3247.07 113.39
mext/precedesorcurlyFTSmbase 3150.97 108.59
Total 6398.04 221.98
To verify if the ﬁxed point has been reached, we must
determine if, for all (s1,s2)∈S×S,Ri(s1,s2)≤
Ri+1(s1,s2). Establishing this comes to checking if
Ri(s1,s2)∧¬R i+1(s1,s2)is unsatisﬁable, which is of
cost|S|2.22n. Consequently, the overall time complexity of
computingRFTSis bounded byO(|S|6.23n). Although it is
theoretically dominated by 23n, and thus in EXPTIME, in
practice|S|6is often bigger.
B. Evaluation of Simulation-Based Veriﬁcation
To carry out these experiments, we have integrated the
computation of the simulation function as well as the three
abstractions into our Haskell FTS library1, which we pre-
viously used for benchmarking our LTL model-checking
algorithms [5]. It allows us to validate our approach and
to measure its efﬁciency when it comes to computing the
simulation relation and reducing both the state-space size of
an FTS and its veriﬁcation time. All benchmarks were run on
a MacBook Pro with a 2,4 GHz Core 2 Duo processor and
4 Gb of RAM. The library was compiled using the Glasgow
Haskell Compiler2. To avoid the inﬂuence of other running
processes, we repeated each experiment 10 times.
Our evaluation considers the mine pump controller deﬁned
in [16], which we already used in our previous work [5].
The whole system is designed as the parallel composition of
several processes (a pump, a water sensor, a methane sensor,
and a controller). The mine pump SPL has nine features and
64 products. The FTS modelling its behaviour, noted mbase
is composed of 465 states and 1306 transitions (see [7] for
a detailed description).
In Section III, we introduced two methods for computing
the simulation relation for two FTS. The former is based
on an enumerative approach and determine, for given fts1
andfts2, and each product p, iffts1|p/precedesorcurlyTSfts2|p. The
latter makes use of the compact structure of FTS and is
based on the computation of a ﬁxed point, as stated in
Subsection III-B. Our ﬁrst experiments evaluate the practical
efﬁciency of both methods.
The evaluation considers the minepump system, mbase,
as well as an extension of it. Basically, we extended the
behavioural options of some of the products by making
them able to execute additional transitions. This results in an
extended model, noted mext. Then, we measured the time
1http://info.fundp.ac.be/ ∼acs/fts/implementations/haskell-library/
2http://www.haskell.org/ghc/678needed by both methods to compute mbase/precedesorcurlyFTSmextand
mext/precedesorcurlyFTSmbase. Benchmarks results are shown in Table I.
We observe that the algorithm based on Deﬁnition 10 is
far more efﬁcient than the one that enumerates the products
and computes the TS-simulation of their projection. In spite
of having a worse theoretical time complexity, it is 28.82
times faster than the enumerative algorithm. Note that the
execution time of the enumerative algorithm includes the
time needed for determining the projection of each product,
which amounts to about 20% of the whole execution time.
C. Evaluation of Temporal Property Veriﬁcation
Our second evaluation benchmarks the time needed for
model checking abstractions combined with either the enu-
merative approach or FTS algorithms. The objective of the
following experiments is to determine which abstraction
method is more efﬁcient. For the former method, we evaluate
the veriﬁcation time by enumerating all the products and
computing their projection on (1) the original model, (2)
its TS-simulation quotient m/similarequalTS[13], and (3) the model
m/precedesorcurlyTS, obtained by integrating a state s1into another s2iff
s1/precedesorcurlyTSs2.
Also, we apply the aforementioned abstractions to obtain
three abstract FTS m/similarequalFTS,m/similarequalRch, andm/precedesorcurlyFTSrespec-
tively. For the latter, when a state can be integrated into more
than one state, our choice is based on the lexicographic order.
For example, if we have s1/precedesorcurlyFTSs2=s1/precedesorcurlyFTSs3=B(d)
then we integrate s1intos2rather than in s3.
For each FTS, we ﬁrst compute the number of states
and transitions in order to determine to what extent a given
abstraction reduces the size of the original FTS. We observe
that the abstraction based on the equivalence classes under
/similarequalFTS yields no reduction at all. Its merging condition is
too restrictive in the context of product lines. Since an FTS
models the behaviour of O(2n)products, it is very unlikely
that two states have exactly the same behavioural options
for all those products.
Taking into account the reachability already allows to
merge states, although only a few of them. The state-space
size is thus reduced to 459 states and 1284 transitions.
Finally, the third abstraction yields a reduction of about 9%
(423 states and 1192 transitions). Although these are the best
results in terms of state-space reduction, we must keep in
mind that, like every efﬁcient state-space reduction method,
it augments the behaviour of the FTS. Hence, we may ﬁnd
false negatives, i.e.products that violate a given property in
the abstract FTS but not in the original one.
In order to evaluate the impact of the state-space reduction
on the veriﬁcation time, we model-checked the seven models
against ten different properties expressed in LTL, such as
those deﬁned in [17] and [5]. The results are shown in
Table II. For every formula and every model, we give the
time needed to verify the model against the formula. We also
describe if the formula is veriﬁed by every legal product ( /check)or not ( ). The veriﬁcation time of every property includes
the computation time of the abstractions, which represents
about 10% of the overall veriﬁcation time, in both cases.
This overhead could be partially avoided if the abstractions
are computed once and for all. We do not present the
veriﬁcation times for m/similarequalFTS. Since it has as many states
and transitions as mbase, any difference would be the result
of random variations independent of the veriﬁcation process.
Let us ﬁrst discuss the results for the enumerative and
FTS approaches separately. When summing up all the times
related to the enumerative approach, we observe that the
overhead due to the computation of both the abstractions
based on TS-simulation quotient ( m/similarequalTS) and preorder
(m/precedesorcurlyTS) is signiﬁcant. Because of that, the veriﬁcation
times ofm/similarequalTSandm/precedesorcurlyTSare respectively 48% and 47%
higher than the model-checking time of mbase using the
enumerative method. Furthermore, false negatives appeared
when checking m/precedesorcurlyTSagainst formula #5. This formula is
supposed to be satisﬁed by all products, but one of them
violates it in m/precedesorcurlyTSdue to the addition of behaviour.
Applying abstraction to FTS yields better results. The
abstraction under/similarequalRchincreases the checking time of mbase
with FTS by 3%. This veriﬁcation time decreases by 8%
whenm/precedesorcurlyFTSis model-checked. However, it has to be
noted that false negatives were found for formula #5. If
we compare these results with the ones of the enumera-
tive methods, we conclude that the FTS-based approaches
outperform the enumerative ones. Furthermore, applying
abstraction to an FTS can reduce its veriﬁcation cost. On
the contrary, combining an enumerative method with an
abstraction function is inefﬁcient.
Although abstraction clearly permits to reduce the ver-
iﬁcation of an FTS, we are aware that the gain is not
signiﬁcant. This illustrates the difﬁculty to ﬁnd a good
abstraction for FTS, a formalism that models the behaviours
of a potentially large number of systems. A good abstraction
should either add behaviour or remove some, but not both.
Otherwise, we would not be able to infer any property of
the system using the veriﬁcation results of its abstract coun-
terpart, since a property may be violated by an additional
behaviour or satisﬁed thanks to the removal of an existing
one. Therefore, it is particularly difﬁcult to ﬁnd a state merg-
ing condition that both satisﬁes this requirement and makes a
signiﬁcant reduction. In particular, the purpose of simulation
quotient is to eliminate redundancy, not to produce coarse
abstractions. More research is required to ﬁnd ways to
design efﬁcient abstraction functions and to ﬁnely evaluate
their merits with respect to veriﬁcation performance and
false negatives induced by them. The current abstractions
are applied directly on the FTS itself. The most successful
applications of abstraction, like partial-order reduction and
statement merging, make use of additional information like
parallelism and variables scope. These information are not679Table II
VERIFICATION TIME OF TEN LTL FORMULAE (IN SECONDS )
ENUMERATIVE METHOD
Formula mbase m/similarequalTSm/precedesorcurlyTS
#1 31.23  40.42  39.70 
#2 9.79 /check 19.58 /check 19.75 /check
#3 134.71  178.52  175.11 
#4 8.38 /check 17.2 /check 17.97 /check
#5 19.18 /check 32.22 /check 33.51 
#6 27.57  37.94  36.69 
#7 9.44 /check 19.37 /check 20.26 /check
#8 46.19  64.48  62.22 
#9 11.39  24.58  25.64 
#10 8.78 /check 19.54 /check 19.25 /check
Total 306.66 453.85 450.1FTS ALGORITHMS
Formula mbase m/similarequalRchm/precedesorcurlyFTS
#1 13.08  13.46  12.07 
#2 0.81 /check 2.15 /check 1.94 /check
#3 97.91  92.37  82.23 
#4 0.96 /check 2.31 /check 2.01 /check
#5 1.26 /check 2.56 /check 2.29 
#6 10.10  10.89  9.91 
#7 0.41 /check 1.79 /check 1.62 /check
#8 7.2  7.7  6.80 
#9 0.65  2.02  1.79 
#10 0.49 /check 1.86 /check 1.67 /check
Total 132.87 137.11 122.33
found in such a fundamental formalism, but instead in high-
level languages.
Nevertheless, it is interesting to observe that the most
important speedups occur during the veriﬁcation of the most
time-consuming properties. This indicates that abstraction
can play a role in improving the scalability of SPL veriﬁca-
tion. Naturally, this early indication needs to be conﬁrmed by
further experiments. These results combined with previous
experiments [5]–[7] conﬁrm that FTS is a viable approach
for verifying variability-intensive systems.
D. Threats to Validity
Several threats to the validity of our conclusions have
to be pointed out. First, our evaluation is solely based on
one case. Other systems of different size and variability
should be considered in order to analyse how the different
approaches scale with the number of features and the size
of the state-space.
This case study has been implemented in Haskell, a
programming language that makes use of the so-called
lazy evaluation. It means that a value is computed only
when it is needed. Although this evaluation method may
have inﬂuenced our results, the conclusions would certainly
remain valid if we used another programming language.
The comparison between the enumerative methods and
the FTS algorithms is based on the veriﬁcation of all
the products. However, when a property (or a simulation
relation) is required to hold for the whole SPL, we could stop
the checking process as soon as a bad product is found. Even
so, this comes to the standard model checking problem, and
we are interested in identifying all the products that violate
a property.
Also, we obtain the veriﬁcation times related to the
enumerative methods by summing up the veriﬁcation times
for each product individually. In practice, it is very unlikely
that those products are veriﬁed sequentially, without taking
advantage of multi-threading and parallel veriﬁcation.Finally, independent processes running during the exper-
iments might have inﬂuenced the results. However, each
experiment has been repeated 10 times. This way, the impact
of those random variations is drastically reduced.
VI. R ELATED WORK
This section brieﬂy describes relevant work related to
modelling and veriﬁcation of SPL behaviour.
Fischbein et al. propose Modal Transition Systems (MTS)
to model the behaviour of SPLs [18]. An MTS is a TS
where transitions are either mandatory or optional. The
mandatory transitions are available to all products whereas
optional ones are speciﬁc. Although model checking an
MTS determines if a property is satisﬁed by all or only
a subset of the products, it does not keep track of the
decisions made at variation points and it lacks the notion of
feature. Therefore, it cannot pinpoint exactly the products
that violate the property. Asirelli et al. [19] associate MTS
with the MHML temporal logic [20] to express constraints
on features . Still, since they do not have an explicit notion
of feature inthe MTS, they suffer from the same limitations.
Sassolas et al. [21] propose a method to identify incon-
sistencies between several MTS based on traces comparison
and a simulation relation. The inconsistencies are charac-
terised asµ-calculus formulae. Unlike ours, their approach
is not speciﬁc to SPL and cannot be used to identify products
that cause inconsistencies.
Instead of MTS, Larsen et al. apply I/O automata to SPL
modelling [22]. In particular, they deﬁne an SPL as the
composition of subfamily modelled with an I/O automata.
However, they do not address SPL veriﬁcation.
Lauenroth et al. deﬁne a CTL model-checking algorithm
for automata labelled with features [23]. There are two
signiﬁcant differences between their work and ours. First,
they do not allow to label transitions with any arbitrary
boolean expressions. Second, the time complexity of their
algorithms are exponential in the state-space size and they
have not applied state-space reduction techniques.680Ghezzi and Molzam Shariﬂoo verify non-functional prop-
erties (reliability, energy consumption, ...) in SPLs with
probabilistic model-checking [24]. Their work is comple-
mentary to ours but does not rely on a formal model.
Transposing our approach to probabilistic model checking
is a promising research perspective.
Cassez et al. [25] make use of the simulation relation
for alternating-time temporal logic (ATL) to prove the non-
interaction of features in reactive systems. They establish
syntactic conditions for a feature to preserve properties.
Similarly, Fisler et al. [26], Krishnamurthi et al. [27] and Li
et al. [28] introduce an approach for compositional model-
checking of collaborations, aspects and features. Both the
base system (i.e. the system without features) and the fea-
tures are modelled as a ﬁnite state machine (FSM). Enabling
the feature means attaching its FSM to the one of the base
system. They propose algorithms that derive preservation
constraints which, if satisﬁed by the feature FSM, ensure
that a given CTL formula veriﬁed in the base system is also
satisﬁed when the feature is enabled. One limitation is that
their features only add transitions and states. In the same
vein, Liu et al. [29] propose an alternate algorithm to derive
the preservation constraints. Transposed to FTS, these ideas
could open a way for compositional veriﬁcation of SPL.
VII. C ONCLUSION AND FUTURE WORK
In this paper, we focused on providing theoretical foun-
dations and empirical evidence to apply simulation-based
model checking to SPLs. First, we deﬁned a simulation
relation for FTS, a formalism meant to model the behaviour
of all the products of a SPL. Simulation relations add a
signiﬁcant milestone to SPL veriﬁcation theory, being at the
center of advanced behavioural analyses, such as abstrac-
tion, behavioural comparison, compositional reasoning, and
more. The second contribution is the study of simulation
quotients for FTS, which results in several simulation-based
abstraction methods. The third contribution is the evaluation
of these abstractions for SPL model checking. The main
conclusion of our experiments is that the combination of
abstraction with the enumerative approach is inefﬁcient. This
corroborates the claims we made in earlier work that SPL
model checking should be based on FTS. However, our ex-
periments also suggest that the application of abstraction to
FTS model checking only yields marginal efﬁciency gains.
To obtain more substantial improvements, our approach
should be extended with other abstraction methods. Counter-
example guided abstraction reﬁnement (CEGAR) [30] looks
particularly promising: a coarse abstraction is rapidly and
automatically computed and is then reﬁned iteratively using
the false negatives found during veriﬁcation.
As other future work, we plan to integrate our results
in an SPL model-checking tool equipped with a high-level
speciﬁcation language, viz. SNIP [7]. This would allow
us to apply other forms of abstraction, ( e.g., partial-orderreduction [2], [10], [13] and statement merging [10]), and to
evaluate them on larger models, including industrial cases.
However, it requires to extend deﬁnitions such as stutter
equivalence [13], [31] to variability-intensive models.
Apart from abstraction, there are many other uses of
the simulation function we have deﬁned. For instance,
simulation-based veriﬁcation allows one to verify properties
modelled as automata. There are also SPL-speciﬁc uses
of our theory. For instance, we can formally characterise
the behavioural impact of features in an SPL. Let fbe
a feature,fts[f](resp.fts[¬f]) the FTS modelling the
behaviour of the products that have (resp. do not have) f.
Then, (fts[¬f]/precedesorcurlyFTSfts[f])gives the products for which
fdoes not remove existing behavioural options. Inter-SPL
comparison is also possible. If we consider two SPLs having
an equal set of legal products, the behavioural inconsisten-
cies between them can be highlighted and presented in the
form of an automata ( viz.an FTS). A similar approach for
modal transition systems is studied by Sassolas et al. [21].
Moreover, we plan to investigate the use of the simulation
for compositional reasoning and veriﬁcation of variability-
intensive systems. Simulation relations are already at the
core of existing research on compositional veriﬁcation, in
particular for discrete and hybrid systems [32]. Applying
similar methods to verify behavioural variability models
compositionally is an exciting but difﬁcult challenge, consid-
ering the numerous possible interactions between features.
Finally, we will extend the above results as well as our
previous work on FTS to the modelling and veriﬁcation
of variability-intensive real-time systems. Analysing the
behaviour of such systems requires (1) the deﬁnition of
models that combine FTS with timed automata, (2) the
development of model checking algorithms for verifying
time-critical properties on these models, and (3) the deﬁni-
tion of timed simulation for FTS augmented with real-time.
More generally, this work is part of a larger project that
aims to extend the theory, methodologies and tools for the
behavioural modelling and veriﬁcation of SPL.
ACKNOWLEDGEMENTS
We thank the anonymous referees for their helpful com-
ments. This work was funded by the Fund for Scientiﬁc
Research – FNRS in Belgium (project FC 91490) and the
IAP Programme of the Belgian State (MoVES project).
REFERENCES
[1] P.-Y . Schobbens, P. Heymans, J.-C. Trigaux, and Y . Bontemps,
“Feature Diagrams: A Survey and A Formal Semantics,” in
RE’06 , 2006, pp. 139–148.
[2] E. Clarke, O. Grumberg, and D. Peled, Model Checking . MIT
Press, 1999.
[3] M. Y . Vardi and P. Wolper, “An automata-theoretic approach
to automatic program veriﬁcation,” in LICS’86 . IEEE CS,
1986, pp. 332–344.681[4] E. M. Clarke, E. A. Emerson, and A. P. Sistla, “Automatic
veriﬁcation of ﬁnite-state concurrent systems using tempo-
ral logic speciﬁcations,” ACM Trans. Program. Lang. Syst. ,
vol. 8, pp. 244–263, April 1986.
[5] A. Classen, P. Heymans, P.-Y . Schobbens, A. Legay, and J.-F.
Raskin, “Model checking lots of systems: efﬁcient veriﬁcation
of temporal properties in software product lines,” in Proceed-
ings of ICSE 32 , ser. ICSE ’10. New York, NY , USA: ACM,
2010, pp. 335–344.
[6] A. Classen, P. Heymans, P.-Y . Schobbens, and A. Legay,
“Symbolic model checking of software product lines,” in
ICSE 33 . ACM, 2011, pp. 321–330.
[7] A. Classen, “Modelling and model checking variability-
intensive systems,” Ph.D. dissertation, 2011.
[8] A. Pnueli, “The temporal logic of programs,” in Proc. 18th
Annual Symposium on Foundations of Computer Science
(FOCS) , 1977, pp. 46–57.
[9] E. M. Clarke and E. A. Emerson, “Design and synthesis
of synchronization skeletons using branching-time temporal
logic,” in Logic of Programs , ser. LNCS, vol. 131. Springer,
1981, pp. 52–71.
[10] G. J. Holzmann, The SPIN Model Checker: Primer and
Reference Manual . Addison-Wesley, 2004.
[11] G. Bruns, “A practical technique for process abstraction,” in
Proceedings of the 4th International Conference on Concur-
rency Theory , ser. CONCUR ’93. London, UK: Springer-
Verlag, 1993, pp. 37–49.
[12] R. Milner, “An algebraic deﬁnition of simulation between
programs,” Stanford University, Stanford, CA, USA, Tech.
Rep., 1971.
[13] C. Baier and J.-P. Katoen, Principles of Model Checking .
MIT Press, 2007.
[14] K. Kang, S. Cohen, J. Hess, W. Novak, and S. Peterson,
“Feature-oriented domain analysis (FODA) feasibility study,”
SEI, Tech. Rep. CMU/SEI-90-TR-21, 1990.
[15] [Online]. Available: http://info.fundp.ac.be/∼acs/snip
[16] J. Kramer, J. Magee, M. Sloman, and A. Lister, “Conic: an
integrated approach to distributed computer control systems,”
Computers and Digital Techniques, IEE Proceedings E , vol.
130, no. 1, pp. 1–10, 1983.
[17] D. Alrajeh, J. Kramer, A. Russo, and S. Uchitel, “Learning
operational requirements from goal models,” in ICSE 31 ,
2009, pp. 265–275.
[18] D. Fischbein, S. Uchitel, and V . Braberman, “A foundation
for behavioural conformance in software product line archi-
tectures,” in ROSATEA ’06, ISSTA 2006 workshop . ACM
Press, 2006, pp. 39–48.
[19] P. Asirelli, M. H. T. Beek, A. Fantechi, and S. Gnesi, “Formal
description of variability in product families,” in Proceedings
of the 15th International Software Product Line Conference ,
ser. SPLC’11. Springer-Verlag, 2011, pp. 130–139.[20] ——, “A logical framework to deal with variability,” in
Proceedings of the 8th international conference on Integrated
formal methods , ser. IFM’10. Berlin, Heidelberg: IEEE,
2010, pp. 43–58.
[21] M. Sassolas, M. Chechik, and S. Uchitel, “Exploring in-
consistencies between modal transition systems,” Softw. Syst.
Model. , vol. 10, pp. 117–142, February 2011.
[22] K. G. Larsen, U. Nyman, and A. Wasowski, “Modal I/O
automata for interface and product line theories,” in ESOP ,
2007, pp. 64–79.
[23] K. Lauenroth, S. Thning, and K. Pohl, “Model checking of
domain artifacts in product line engineering,” in IEEE/ACM
ASE, 2009, pp. 269–280.
[24] C. Ghezzi and A. Molzam Shariﬂoo, “Verifying non-
functional properties of software product lines: Towards an
efﬁcient approach using parametric model checking,” in Pro-
ceedings of the 15th International Software Product Line
Conference , ser. SPLC’11. Springer-Verlag, 2011, pp. 170–
174.
[25] F. Cassez, M. D. Ryan, and P. yves Schobbens, “Proving fea-
ture non-interaction with alternating-time temporal logic,” in
Language Constructs for Describing Features – proceedings
of the FIREworks workshop . Springer, 2001.
[26] K. Fisler and S. Krishnamurthi, “Modular veriﬁcation of
collaboration-based software designs,” in Proceedings of the
8th European software engineering conference held jointly
with 9th ACM SIGSOFT international symposium on Foun-
dations of software engineering , ser. ESEC/FSE-9. New
York, NY , USA: ACM, 2001, pp. 152–163.
[27] S. Krishnamurthi, K. Fisler, and M. Greenberg, “Verifying
aspect advice modularly,” in SIGSOFT ’04/FSE-12: Pro-
ceedings of the 12th ACM SIGSOFT twelfth international
symposium on Foundations of software engineering . New
York, NY , USA: ACM, 2004, pp. 137–146.
[28] H. C. Li, S. Krishnamurthi, and K. Fisler, “Interfaces for
modular feature veriﬁcation,” in ASE, 2002, pp. 195–204.
[29] J. Liu, S. Basu, and R. R. Lutz, “Compositional model
checking of software product lines using variation point
obligations,” Automated Software Engg. , vol. 18, pp. 39–76,
March 2011.
[30] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith,
“Counterexample-guided abstraction reﬁnement,” in Com-
puter Aided Veriﬁcation , ser. Lecture Notes in Computer
Science, E. Emerson and A. Sistla, Eds. Springer Berlin
/ Heidelberg, 2000, vol. 1855, pp. 154–169.
[31] J. F. Groote and F. Va, “An efﬁcient algorithm for branching
bisimulation and stuttering equivalence,” in Proceedings of
the seventeenth international colloquium on Automata, lan-
guages and programming . Springer-Verlag, 1990, pp. 626–
638.
[32] G. Frehse, “Compositional veriﬁcation of hybrid systems
using simulation relations,” Ph.D. dissertation, Radboud Uni-
versiteit Nijmegen, 2005.682