How did You Specify Your Test Suite ?
Andreas Holzer Michael Tautschnig Helmut Veith
Vienna University of Technology
{holzer, tautschnig, veith}@forsyte.atChristian Schallhart
Oxford University Computing Laboratory
christian.schallhart@comlab.ox.ac.uk
ABSTRACT
Although testing is central to debugging and software certiﬁcation,
there is no adequate language to specify test suites over source
code. Such a language should be simple and concise in daily use,
feature a precise semantics, and of course, it has to facilitate suit-
able engines to compute test suites and assess the coverage achieved
by a test suite.
This paper introduces the language FQL designed to ﬁt these
purposes. We achieve the necessary expressive power by a natura l
extension of regular expressions which matches test suites rather
than individual executions. To evaluate the language, we show for
a list of informal requirements how to express them in FQL. More-
over, we present a test case generation engine for C programs and
perform practical experiments with the sample speciﬁcations.
Categories and Subject Descriptors
D.2.5 [ Software Engineering ]: Testing and Debugging— data gen-
erators, coverage
General Terms
Languages, Veriﬁcation
1. INTRODUCTION
Source code based testing is the most practical and important
technique to assure software quality. Testing accompanies the de-
velopment process from early versions of the implementation all
the way to product certiﬁcation.
In this paper, we describe a novel approach to software testing
where the test suites are speciﬁed in the language FQL (FShell
Query Language). FQL speciﬁcations enable the user to formulate
test speciﬁcations which range from local code-speciﬁc require-
ments (“cover all decisions in function foousing only calls from
functionbar tofoo”) to generic code-independent requirements
(e.g., “condition coverage”). We have designed FQL as a spec-
iﬁcation language which is easy to read – it is based on regular
expressions – but has an expressive and precise semantics.
Permission to make digital or hard copies of all or part of this w ork for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage and th at copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.Test speciﬁcations in FQL can go well beyond established cov-
erage criteria; in our experience with students, FQL encourages
programmers to explore their code more systematically. Fig. 1 con-
tains a list of informal speciﬁcations and Table 8 shows how to ex-
press them in FQL for C programs. Such speciﬁcations can be used
in many contexts of which we discuss a few (cf. Sec. 5):
•Test Case Generation. FQL enables us to compute test suites
according to user speciﬁed coverage criteria , cf. Sec. 5. This
feature is a crucial difference to directed testing which aims at
good program coverage as a push button tool but has no explicit
coverage goals. In particular, it enables the programmer to do
intelligent and adaptive unit testing, even for unﬁnished code.
•Requirement-driven Testing. We can translate informal re-
quirements into FQL test speciﬁcations, and generate a cover-
ing test suite. When we evaluate the resulting test suite for, e.g.,
decision coverage, we understand if the requirements contain
sufﬁcient detail to guide the implementation.
•Certiﬁcation. We can formulate precise criteria for code certi-
ﬁcation in FQL and evaluate them on the source code.
The lack of formal test speciﬁcations (even in standards such as
DO-178B [14]) has lead to inconsistent tool support. To illus-
trate the problem, we use the four commercial test tools Cover-
ageMeter [11], CTC++ [12], BullseyeCoverage [8], and Ratio-
nal Test RealTime (RTRT) [29] to check for condition coverage
1void foo( intx) {
2 inta = x > 2 && x < 5;
3 if(a) { 0; } else { 1; }
4}
Listing 1: Sample programon the C program shown in
Listing 1. We compiled the C
program using the tool chain of
each coverage analysis tool and
ran the programs with the two
test cases x = 1 and x = 4 .
Here, CoverageMeter and CTC++ reported 100% coverage but
the other two tools returned a mere 83%. The difference occurs
because BullseyeCoverage and RTRT treat not only the variable
ain line 3 as condition but also x>2and x<5in line 2.
•Coverage Evaluation. We can determine coverage with re-
spect to an FQL query achieved by other test methods, e.g., di-
rected, model-based, or manual testing. A clear understanding
of coverage enables us to combine existing testing techniques
in a precise manner. For instance, we can use concise speciﬁ-
cations of missing test cases as inputs for a heavy-weight tool
such as a model checker. An interface with our tool to perform
automated coverage completion is part of current work.
•Systematic Reasoning about Test Speciﬁcations. Finally, we
believe that FQL gives us a clean and simple framework to
407
Scenario 1: Structural Coverage Criteria. The certiﬁcation of criti-
cal software systems often requires coverage criteria such a s basic block,
condition or decision coverage [27] which refer to entities present in all
source code. This results in our ﬁrst speciﬁcations.
[Q1-2 — “Standard Coverage Criteria” ]Basic block coverage and con-
dition coverage.
Assuming that Q2refers to BullseyeCoverage and RTRT’s interpreta-
tion of condition coverage, one must also be able to express th e competing
criterion:
[Q3— “Alternative Condition Coverage” ]Condition coverage as deﬁned
by CoverageMeter and CTC++.
For intensive testing a developer will employ a variant of pat h cover-
age [28], but restrict it to local coverage due to high costs:
[Q4 — “Acyclic Path Coverage” ]Cover all acyclic paths through func-
tionsmain andinsert .
[Q5 — “Loop-Bounded Path Coverage” ]Cover all paths through main
andinsert which pass each statement at most twice.
Scenario 2: Data Flow Coverage Criteria. We give three examples of
typical data ﬂow coverage criteria.
[Q6— “Def Coverage” ]Cover all statements deﬁning a variable t.
[Q7 — “Use Coverage” ]Cover all statements that use the variable tas
right hand side value.
[Q8— “Def-Use Coverage” ]Cover all def-use pairs of variable t.
Scenario 3: Constraining Test Cases. During development and for
code exploration, it is often important to achieve the desire d coverage
with test cases which, for instance, avoid a call to an unimple mented
function. Below we list ﬁve examples of this group.
[Q9 — “Constrained Program Paths” ]Basic block coverage with test
cases that satisfy the assertion j>0 after executing line 2.
[Q10 — “Constrained Calling Context” ]Condition coverage in function
compare with test cases which call compare from inside function sort
only.
[Q11 — “Constrained Inputs” ]Basic block coverage in function sort
with test cases that use a list with 2 to 15 elements.
[Q12 — “Recursion Depth” ]Cover function eval with condition cover-
age and require each test case to perform three recursive cal ls ofeval .[Q13 — “Avoid Unﬁnished Code” ]Cover all calls to sort such that
sort never calls unfinished . The function unfinished is allowed to be
called outside sort —assuming that only the functionality of unfinished
which is used by sort is not testable yet.
[Q14 — “Avoid Trivial Cases” ]Cover all conditions and avoid trivial test
cases, i.e., require that insert is called twice before calling eval .
Scenario 4: Customized Test Goals. Complementary to the constraints
on test cases of Scenario 3, we also want to modify the set of test goals
to be achieved by the test cases.
[Q15 — “Restricted Scope of Analysis” ]Condition coverage in function
partition with test cases that reach line 7 at least once.
[Q16 — “Condition/Decision Coverage” ]Condition/decision cover-
age (the union of condition and decision coverage) [27].
To understand the interaction of two program parts, it is not sufﬁcient
to cover the union of the test goals induced by each part, but to cover their
Cartesian product :
[Q17 — “Interaction Coverage” ]Cover all possible pairs between con-
ditions in function sort and basic blocks in function eval , i.e., cover all
possible interactions between sort andeval .
In a similar spirit, we can also approximate path coverage by co vering
pairs, triples, etc. of basic blocks:
[Q18-20 — “Cartesian Block Coverage” ]Cover all pairs, triples, and
quadruples of basic blocks in function partition .
Scenario 5: Seamless Transition to Veriﬁcation. When full veriﬁca-
tion by model checking is not possible, testing can be used to a pproximate
model checking. For instance, we can specify to cover all asse rtions.
[Q21 — “Assertion Coverage” ]Cover all assertions in the source.
[Q22 — “Assertion Pair Coverage” ]Cover each pair of assertions with a
single test case passing both of them.
We can ﬁnally use test speciﬁcations to provoke unintended p rogram
behavior, effectively turning a test case into a counterexa mple. In the fol-
lowing examples, we check the presence of an erroneous callin g sequence
and the violation of a postcondition:
[Q23 — “Error Provocation” ]Cover all basic blocks in eval without
reaching label init .
[Q24 — “Veriﬁcation” ]Ask for test cases which enter function main ,
satisfy the precondition, and violate the postcondition.
Figure 1: Twenty-four examples of informal test case speciﬁcatio ns
study fundamental issues about test speciﬁcations such as equiv-
alence and subsumption of speciﬁcations, normal forms, distri-
bution of speciﬁcations to multiple test servers etc.
Given the practical importance of a test speciﬁcation language,
we were quite surprised that there is very little previous work on
this question. We begin by listing the challenges:
(a)Simplicity and Code Independence. Simple coverage criteria
should be expressed by simple FQL speciﬁcations. To facil-
itate early test goal speciﬁcations and their reuse throughout
a project, FQL speciﬁcations should be maximally code inde-
pendent; for instance, a speciﬁcation referring to a procedure
should not depend on line numbers.
(b)Precise Semantics. FQL speciﬁcations should have a simple
and unambiguous semantics.
(c)Expressive Power. FQL should be based on a small number
of orthogonal concepts which allow to express natural coverage
criteria including, among others, the examples of Fig. 1.
(d)Encapsulation of Language Speciﬁcs. Speciﬁcations in FQL
should be maximally agnostic to the programming language at
hand. To this end, FQL should provide a clear and concise
binding concept with the underlying programming language.(e)Tool Support for Real World Code. FQL must have a good
trade-off between expressive power and feasibility. In partic-
ular, common coverage speciﬁcations should lend themselves
naturally to efﬁcient test case generation algorithms.
In this paper we introduce FQL which is—to the best of our
knowledge—the ﬁrst test speciﬁcation language which satisﬁes the
requirements (a) to (e). Our previous work [24] focused on algo-
rithmic test case generation, addressing challenge (e). Arguing that
test case speciﬁcation and test case generation have a similar re-
lationship as database query languages and database engines, we
introduced the notion of query-driven test case generation and pre-
sented a SAT-based test case generation approach. The preliminary
speciﬁcation language used in [24] was a ﬁrst step towards FQL,
but it lacked both an exact semantics and a clean concept.
Organization of this Paper. Sec. 2 provides a gentle introduc-
tion into the concepts of FQL. Sections 3 to 4 give a systematic
description of the syntax and semantics of FQL. Most of the pre-
sentation is language independent, only Sec. 4.2 discusses elements
speciﬁc to C. Sec. 5 evaluates FQL from four perspectives: (1) We
show that the sample speciﬁcations of Fig. 1 can be expressed in
FQL. (2) We present an improved version of our test case gener-
ation tool [24]. (3) Continuing the discussion in this section, we
show how FQL can be used in different tool chains. (4) We outline
further research around FQL. In Sec. 6 we discuss related work.
4082. FQL LANGUAGE CONCEPT
It is natural to specify a single test case on a ﬁxed given program
by a regular expression. For instance, to obtain a test case which
goes through line number 17 of the program, one can write a “path
pattern” as a regular expression _ ∗.@17._∗where _ stands for an
arbitrary program command.1In writing the above path pattern, we
implicitly assume that the alphabet symbols are constraints that a
program execution must satisfy. This simple approach has a prin-
cipal limitation: it only works for a few hand-written test cases on
a ﬁxed program.
Let us discuss the problem on the example of basic block cover-
age. Basic block coverage requires a test suite where
“for each basic block in the program there is a test case in
the test suite which covers this basic block. ”
It is clear that basic block coverage can be achieved manually by
writing one path pattern for each basic block in the program. The
challenge is to ﬁnd a speciﬁcation language from which the path
patterns can be automatically derived. This language should work
not only for simple criteria such as basic block coverage, but, on the
contrary, facilitate the speciﬁcation of complex coverage criteria.
To understand the requirements for the speciﬁcation language, let
us analyze the above verbal speciﬁcation:
1. The speciﬁcation requires a test suite , i.e., multiple test cases,
which together have to achieve coverage.
2. The speciﬁcation contains a universal quantiﬁer , saying that
each basic block must be covered by a test case in the test suite.
3. Referring to entities such as “basic blocks” the speciﬁcation as-
sumes knowledge about program structure .
4. The speciﬁcation has a meaning which is independent of the
concrete program under test. In fact, it can be translated into a
set of path patterns only after the program under test is ﬁxed .
It will be easy for the reader to conﬁrm that these observations hold
true for all test speciﬁcations of Sec. 1, with the only exception of
observation 4.: Certain test speciﬁcations depend on the program
under test more than others. The four observations motivate the
following deﬁnition of coverage criteria (cf. Deﬁnition 6):
An elementary coverage criterion Φis a function that maps
a program Ato a ﬁnite set Φ(A)of path patterns. A test
suite Γsatisﬁes coverage criterion Φon program A, if each
path pattern in Φ(A)is matched by an element of the test
suite Γ, except for those path patterns which are semanti-
cally impossible in the program (e.g., dead code).
The challenge is to ﬁnd a language with a syntax, expressive power,
and usability appropriate to the task. Our solution is to evolve reg-
ular expressions into a richer formalism (FQL) which is able to
address the issues 1.-4. discussed above. In the rest of this section,
we will discuss the main features of FQL.
•FQL is a natural extension of regular expressions. To cover
line 17, we can just write
> cover "_ ∗.@17._∗"
The quotes indicate that this regular expression is a path pat-
tern for which we request a matching program path. We use
1Similarly, we can write a safety speciﬁcation AG¬@17 such that
a model checker can compute a counterexample which serves as a
test case.the operators +,∗,.for union, Kleene star and concatenation.
Note that the regular expressions can contain combinations of
conditions and actions, as in
> cover "_ ∗.{x=0}.@17._∗"
which requests a test where x=0 holds at line 17.
•Using concatenation and union, but not Kleene star, FQL com-
bines quoted regular expressions into coverage speciﬁcations
for test suites. This is a key feature which we ﬁrst illustrate on
a simple example. When we write
> cover "_ ∗.@17._∗" + "_ ∗.@32._∗"
this is tantamount to a list of two path patterns:
> cover "_ ∗.@17._∗"
> cover "_ ∗.@32._∗"
Formally, we treat the quoted regular expressions "_∗.@17._∗"
and"_∗.@32._∗"as temporary alphabet symbols xandyand
obtain allwords in the resulting regular language x+ywith
L(x+y) ={x,y}, cf. Fig. 2(a). These words are the path pat-
terns which the test suite has to satisfy. As we will see more
clearly below, this feature equips FQL with the power for uni-
versal quantiﬁcation.
•For program independence and generality, FQL has support to
access natural program entities such as basic blocks, ﬁles, deci-
sions, etc. For instance, the expression
EDGES(@BASICBLOCKENTRY)
is equivalent to a regular expression of the form
@2+@5+@13+@19+@25
in a short program whose basic blocks start in line numbers 2, 5,
13, 19, and 25. The expression EDGES(@BASICBLOCKENTRY) can
only be expanded into a regular expression when the test spec-
iﬁcation is applied, i.e., when the program under test is known.
Thus, we can write
> cover "_*".EDGES(@BASICBLOCKENTRY)."_*"
to achieve basic block coverage. At runtime, this amounts to
> cover "_*".(@2 + @5 + @13 + @19 + @25)."_*"
which is in turn equivalent to the sequence
> cover "_*".@2."_*"
...
> cover "_*".@25."_*"
of path patterns which, together, specify basic block coverage.
•Expressions such as @BASICBLOCKENTRY are used to denote tar-
get graphs . Target graphs contain parsing information about
the program. Mathematically, they are modeled as subgraphs
of the program’s control ﬂow automaton (a variant of control
ﬂow graphs). FQL provides a rich functionality to extract and
manipulate target graphs from programs, for instance the oper-
ations&and|for intersection and union of graphs. This feature
provides the link to the individual programming language, and
is the only language-dependent part of FQL.
For another example of target graphs, consider
PATHS(@FUNC(main),1)
which returns all non-cyclic paths through function main, for
instance,
"@1.@2.@3.@5"+"@1.@2.@4.@5"+...
In fact, expressions such as @5 which we used above, are short-
hands for target graph expressions such as EDGES(@LINE(5)) .
409"_* . @17 . _* "
"_* . @32 . _* "
(a)"_∗.@17._∗" + "_ ∗.@32._∗""_∗"@7
@17
@23
@42
@47"_∗"
(b)(@BASICBLOCKENTRY&@FUNC(foo))
+ (@BASICBLOCKENTRY&@FUNC(bar))"_∗"@7
@17
@23"_∗"@42
@47"_∗"
(c)(@BASICBLOCKENTRY&@FUNC(foo))
-> (@BASICBLOCKENTRY&@FUNC(bar))
Figure 2: Automata resulting from cover clauses (lines 7, 17 and 23 are basic blocks entries in foo, 42 and 47 are the lines for bar)
•To restrict testing to a certain area of interest, FQL contains
passing clauses , i.e., path patterns which every test case has to
satisfy. For instance, by writing
> cover "_*".EDGES(@BASICBLOCKENTRY)."_*"
passing (_.{x≥0})*
we request basic block coverage through a test suite where x
never becomes negative.
•FQL contains syntactic sugar to simplify test speciﬁcations.
For instance, ->stands for ._*. . Moreover, _*is by default
added before and after each path pattern.
Let us sum up this introduction to FQL with a comparison of three
interesting test speciﬁcations:
> coverEDGES(@BASICBLOCKENTRY&(@FUNC(foo)|@FUNC(bar) ))
> coverEDGES(@BASICBLOCKENTRY&@FUNC(foo)) +
EDGES(@BASICBLOCKENTRY&@FUNC(bar))
> coverEDGES(@BASICBLOCKENTRY&@FUNC(foo)) ->
EDGES(@BASICBLOCKENTRY&@FUNC(bar))
In the ﬁrst speciﬁcation, we require basic block coverage for two
functions, fooandbar. In the second speciﬁcation, we have the
same coverage criterion written in a different way. In the third spec,
however, we require a more complex coverage: We want test cases
in which all Cartesian combinations of basic blocks in fooandbar
occur in the test suite. To see this, just note that the ﬁrst two speci-
ﬁcations give rise to the 3 +2=5 path patterns of Fig. 2(b), while
the third amounts to 3 ×2=6 path patterns of Fig. 2(c).
In this section, we have explained complex FQL queries by re-
duction to simpler intuitive FQL queries on concrete programs.
To this end, we made didactic simpliﬁcations, e.g. we assumed that
line numbers can distinguish between basic blocks. In the following
sections, we will give a formal and thorough description of FQL .
3. MATHEMATICAL MODEL
In this section we introduce state-based models for the control
ﬂow and the program semantics. Based on these notions, we for-
malize the notion of coverage criteria.
State-Based Models. Syntactically, we represent programs as
control ﬂow automata [20], annotated with parsing information.
For example, Fig. 3(a) shows the CFA for the code in Listing 2.
Nodes represent program counter values; edges are labeled with
operations and annotations, drawn from ﬁnite sets OpandAn, re-
spectively. An operation op∈Opis either a skip statement, assign-
ment, assumption (modeling conditional statements), function call,
or function return. Annotations include parsing information such
as line numbers or ﬁle names, and function names, labels, etc.
DEFINITION 1.Acontrol ﬂow automaton (CFA) Ais a tuple
/a\}bracketle{tL,E,I/a\}bracketri}ht, where L is a ﬁnite set of program locations, E ⊆L×Lab×
L is a set of edges that are labeled with pairs of operations and
annotations from Lab=Op×2An, and I ⊆L is a set of initial
locations. We denote the set of CFAs withCFA.We write LA,EA, and IAto refer to the set of program loca-
tions, the set of edges, and the set of initial locations of a CFA A,
respectively. We deﬁne ∪,∩, and\as operations on CFAs:
/a\}bracketle{tL1,E1,I1/a\}bracketri}ht∪/a\}bracketle{tL2,E2,I2/a\}bracketri}ht=/a\}bracketle{tL1∪L2,E1∪E2,I1∪I2/a\}bracketri}ht
/a\}bracketle{tL1,E1,I1/a\}bracketri}ht∩/a\}bracketle{tL2,E2,I2/a\}bracketri}ht=/a\}bracketle{tL1∩L2,E1∩E2,I1∩I2/a\}bracketri}ht
/a\}bracketle{tL1,E1,I1/a\}bracketri}ht\/a\}bracketle{tL2,E2,I2/a\}bracketri}ht=/a\}bracketle{tL′,E′,I′/a\}bracketri}htwhere
E′=E1\E2,L′={u,u′|(u,l,u′)∈E′}∪(L1\L2), and I′=I1∩L′.
To describe the behavior of a program, we deﬁne a transition
system as follows:
DEFINITION 2.Atransition system /a\}bracketle{tS,R,I/a\}bracketri}htconsists of a state
space S, a transition relation R⊆S×S, and a nonempty set of
initial states I⊆S. A state inSconsists of a program counter
value and a description of the memory. We denote with L(T)the
set of paths π=/a\}bracketle{ts0...sm/a\}bracketri}htsuch that s 0∈Iand(si,si+1)∈R, for
0≤i<m.
In order to relate a CFA A=/a\}bracketle{tL,E,I/a\}bracketri}htto a corresponding transi-
tion system T=/a\}bracketle{tS,R,I/a\}bracketri}htwe ﬁx the following functions:
•We consider the operation op∈Opas a function op:S→2S
that takes a program state and determines its successor states.
•Bypc:S→Lwe denote a function that, given a program
state s, yields its program location pc(s).
•Bypost :E×S→2Swe denote a function that, given a CFA
edge(ℓ,(op,an),ℓ′)∈Eand a program state s, returns the set
{s′|pc(s) =ℓ,pc(s′) =ℓ′,s′∈op(s)}.
A CFA Anaturally induces a transition system TA:
DEFINITION 3.Given a CFA A, we deﬁne the induced tran-
sition system TA=/a\}bracketle{tS,R,I/a\}bracketri}htwhere Scontains all possible pro-
gram states, R={(s,s′)∈S×S| ∃e∈EA.s′∈post(e,s)}, and
I={s∈S|pc(s)∈IA}.
Predicates & Coverage Criteria. LetT=/a\}bracketle{tS,R,I/a\}bracketri}htbe a transi-
tion system. For π=/a\}bracketle{ts0s1...sm/a\}bracketri}htandi≤jwe write πi...jto denote
the subpath /a\}bracketle{tsi...sj/a\}bracketri}ht. With /a\}bracketle{t/a\}bracketri}htwe denote the empty path. A state
predicate ϕis a predicate on the state space S, apath predicate φ
is a predicate over the set S⋆, and a path set predicate Φis a pred-
icate over the set 2S⋆. We write s|=ϕiff a state s∈Ssatisﬁes ϕ,
π|=φiff a path π∈S⋆satisﬁes φ, and Γ|=Φiff a path set Γ⊆S⋆
satisﬁes Φ. We call a state predicate ϕ, a path predicate φ, or a
path set predicate Φfeasible over T,iff, respectively, there exists a
reachable state s∈Swith s|=ϕ, a path π∈L(T)with π|=φ, or
a path set Γ⊆L(T)with Γ|=Φ. We interpret the Boolean con-
nectives ∧,∨, and ¬on state, path, and path set predicates in the
standard way. For path predicates φ1andφ2, we deﬁne predicate
concatenation φ1≤φ2where π|=φ1≤φ2holds iff
(π0...n|=φ1andπn...|π|−1|=φ2forsome 0≤n<|π|)
or(/a\}bracketle{t/a\}bracketri}ht |=φ1andπ|=φ2)or(π|=φ1and/a\}bracketle{t/a\}bracketri}ht |=φ2)
410202122
3
4041
50
5152
5354
6
70
71
7290
91
92
10v:=a[right] i:=left-1
j:=right
/a\}bracketle{t1!=0/a\}bracketri}ht/a\}bracketle{t!(1!=0) /a\}bracketri}ht
i:=i+1/a\}bracketle{ta[i]<v /a\}bracketri}ht
/a\}bracketle{t!(a[i]<v) /a\}bracketri}ht
skip
/a\}bracketle{tj>left /a\}bracketri}ht
/a\}bracketle{t!(j>left) /a\}bracketri}ht j:=j-1/a\}bracketle{ta[j]>v /a\}bracketri}ht
/a\}bracketle{t!(a[j]>v) /a\}bracketri}ht
skip /a\}bracketle{ti>=j/a\}bracketri}ht
/a\}bracketle{t!(i>=j) /a\}bracketri}ht
t:=a[i]
a[i]:=a[j]
a[j]:=tt:=a[i]
a[i]:=a[right]
a[right]:=t
return i
(a) Control ﬂow automaton A202122
3
4041
50
5152
5354
6
70
71
7290
91
92
10v:=a[right] i:=left-1
j:=right
/a\}bracketle{t1!=0/a\}bracketri}ht/a\}bracketle{t!(1!=0) /a\}bracketri}ht
i:=i+1/a\}bracketle{ta[i]<v /a\}bracketri}ht
/a\}bracketle{t!(a[i]<v) /a\}bracketri}ht
skip
/a\}bracketle{tj>left /a\}bracketri}ht
/a\}bracketle{t!(j>left) /a\}bracketri}ht j:=j-1/a\}bracketle{ta[j]>v /a\}bracketri}ht
/a\}bracketle{t!(a[j]>v) /a\}bracketri}ht
skip /a\}bracketle{ti>=j/a\}bracketri}ht
/a\}bracketle{t!(i>=j) /a\}bracketri}ht
t:=a[i]
a[i]:=a[j]
a[j]:=tt:=a[i]
a[i]:=a[right]
a[right]:=t
return i
(b) Target graph for @BASICBLOCKENTRY [A]202122
3
4041
50
5152
5354
6
70
71
7290
91
92
10v:=a[right] i:=left-1
j:=right
/a\}bracketle{t1!=0/a\}bracketri}ht/a\}bracketle{t!(1!=0) /a\}bracketri}ht
i:=i+1/a\}bracketle{ta[i]<v /a\}bracketri}ht
/a\}bracketle{t!(a[i]<v) /a\}bracketri}ht
skip
/a\}bracketle{tj>left /a\}bracketri}ht
/a\}bracketle{t!(j>left) /a\}bracketri}ht j:=j-1/a\}bracketle{ta[j]>v /a\}bracketri}ht
/a\}bracketle{t!(a[j]>v) /a\}bracketri}ht
skip /a\}bracketle{ti>=j/a\}bracketri}ht
/a\}bracketle{t!(i>=j) /a\}bracketri}ht
t:=a[i]
a[i]:=a[j]
a[j]:=tt:=a[i]
a[i]:=a[right]
a[right]:=t
return i
(c) Target graph for @CONDITIONGRAPH [A]
Figure 3: Control ﬂow automaton of partition (Listing 2) and target graphs
1int partition ( inta [], int left , int right ) {
2intv = a[ right ], i = left −1, j = right , t ;
3for (;;) {
4 while (a[++i] < v) ;
5 while ( j > left && a[ −−j] > v) ;
6 if( i >= j ) break ;
7 t = a[ i ]; a[ i ] = a[ j ]; a[ j ] = t ;
8}
9t = a[ i ]; a[ i ] = a[ right ]; a[ right ] = t ;
10return i ;
11}
Listing 2: Example source code ( sort.c )
holds. Note that the last state of π0...nis the ﬁrst state of πn...|π|−1.
DEFINITION 4.LetTbe a transition system. Then a test case is
a single path π∈L(T)and a test suite Γis a ﬁnite subset Γ⊆L(T)
of the paths in L(T).
Acoverage criterion imposes a predicate on test suites:
DEFINITION 5.Acoverage criterion Φis a mapping from a
CFA Ato a path set predicate ΦA. We say that Γ⊆L(TA)sat-
isﬁes coverage criterion ΦonTAiffΓ|=ΦAholds.
While our deﬁnition of coverage criteria is very general, most
coverage criteria used in practice—and all criteria expressible by
FQL—are based on sets of test goals which need to be satisﬁed.
Typically, test goals are path predicates, leading to the prototypical
setting accounted for in the next deﬁnition.
DEFINITION 6.Anelementary coverage criterion Φis a cover-
age criterion deﬁned as follows:
(i) There is a mapping Φ(A) ={Ψ1,..., Ψk}which maps a CFA A
to a set of test goals {Ψ1,..., Ψk}where each Ψiis a path pred-
icate.
(ii)Φ(A)induces the predicate ΦAsuch that Γ|=ΦAholds iff for
each test goal Ψi∈Φ(A)which is feasible over TA,Γcontains
a test case π∈L(TA)with π|=Ψi.
MC/DC, for example, is a coverage criterion that is not elementary.4. SYNTAX AND SEMANTICS OF FQL
We will now describe the language FQL. Semantically, each
FQL speciﬁcation Φboils down to an elementary coverage cri-
terion. The syntax of FQL follows the ideas of Sec. 2.
Technically, FQL consists of two languages: (1) The core of
FQL are elementary coverage patterns (ECPs), i.e., quoted regu-
lar expressions whose alphabet are nodes, edges and conditions of
a concrete CFA. Referring to low level CFA details, ECPs are not
intended to be written by human engineers, but rather the formal
centerpiece for a precise semantics and implementation. (2) FQL
speciﬁcations are very similar to ECPs, but do not refer to CFA de-
tails. Instead, they use target graphs such as @BASICBLOCKENTRY or
@5to refer to program elements, cf. Sec. 2. For a given program, an
FQL speciﬁcation can be easily translated into an ECP by parsing
the program and “expanding” the target graphs into regular ex-
pressions over the CFA alphabet, in a manner similar to (but more
complicated than) the didactic examples of Sec. 2.
4.1 FQL Elementary Coverage Patterns
Table 1 shows the syntax of elementary coverage patterns. The
nonterminal symbols P,C, and Φrepresent path patterns, coverage
speciﬁcations, and ECPs, respectively. An elementary coverage
patterncover Cpassing Pis composed of a coverage speciﬁca-
tionCand a path pattern P. The alphabets EandLdepend on the
program under scrutiny: Lis a ﬁnite set of CFA locations and Eis
a ﬁnite set of CFA edges. The symbols in Sare state predicates,
e.g.,{x>10}. By εwe denote the empty word and /0denotes the
empty set. We form more complex path patterns over the alphabet
symbols using standard regular expression operations. We denote
union with “ +”, concatenation with “ .”, and Kleene star with “⋆”.
A coverage speciﬁcation is a star-free regular expression over an
extended alphabet: In addition to the alphabets L,EandS, we use
new symbols introduced using the quote operator : Each expression
"P", where Pis a path pattern, introduces a single new symbol "P"
in the alphabet of coverage speciﬁcations.
Table 2 deﬁnes the semantics of path patterns and coverage spec-
iﬁcations as formal languages over alphabets of program counter
locations, state predicates, program transitions, and symbols newly
introduced by the quote operator. We use Xin places where either P
orCmay occur and denote by L(X)the language of a path pattern
411and a coverage speciﬁcation, respectively. Except for the newly in-
troduced quote operator, all equations follow standard regular ex-
pression semantics. The case of Kleene star L(P⋆)is only rele-
vant for path patterns, and L("P")only appears as part of coverage
speciﬁcations. The expression "P"introduces "P"as a new symbol
and, thus, L("P")results in the singleton set {"P"}. For example,
L(("a+b"+"c⋆")."ac")is the set {"a+b""ac","c⋆""ac"}. We
discuss the last line of Table 2 in the following paragraph.
Interpretation of Path Patterns as Path Predicates. Given a cov-
erage speciﬁcation or path pattern X, we interpret each w∈L(X)as
a path predicate. We write π|=wiffπsatisﬁes the word wand in-
ductively deﬁne the semantics thereof in Table 3. The empty set is
unsatisﬁable and the empty word εmatches the empty sequence /a\}bracketle{t/a\}bracketri}ht
only. We match individual states with program counter values ℓand
state constraints ϕ, and pairs of subsequent states with transitions e.
The case π|=awamounts to predicate concatenation as deﬁned in
Sec. 3. The path pattern "P"is satisﬁed by a path π, iff there is a
word w∈L(P)that is satisﬁed by π. Applying these deﬁnitions, an
ECP combines a coverage speciﬁcation and a path pattern to obtain
a set of path predicates as deﬁned in the last line of Table 2.
4.2 Target Graphs and CFA Transformers
Target graphs enable the user to directly access natural program
entities such as basic blocks, line numbers, decisions etc. without
referring to nodes or edges of the CFA. Formally, a target graph is a
fragment of a control ﬂow automaton and typically contains those
parts of the source code that are relevant for a given testing target.
DEFINITION 7.ACFA transformer is a function T :CFA→
CFA which, on input of a CFA A=/a\}bracketle{tL,E,I/a\}bracketri}ht, computes a target
graph T[A] =/a\}bracketle{tL′,E′,I′/a\}bracketri}ht.
The most important CFA transformers are ﬁlter functions , which
extract a subset of the edges of a CFA.
DEFINITION 8.Aﬁlter function is a CFA transformer F :CFA→
CFA which computes for every CFA A=/a\}bracketle{tL,E,I/a\}bracketri}hta target graph
F[A] =/a\}bracketle{tL′,E′,I′/a\}bracketri}htwith L′⊆L, E′⊆E, and I′⊆L′, such that
E′⊆L′×Lab×L′holds.
For example, consider the CFA Adepicted in Fig. 3(a): The
target graph @BASICBLOCKENTRY [A]depicted in Fig. 3(b) (edges not
contained in the target graph are grayed out) is obtained by apply-
ing the ﬁlter function @BASICBLOCKENTRY toA. This target graph
contains the edges necessary for basic block coverage on A. The
ﬁlter function @CONDITIONGRAPH extracts the portions of Athat are
related to decisions in Listing 2, see Fig. 3(c).
In Def. 8 the condition I′⊆L′enables a ﬁlter function to change
the set of initial locations. E.g., @BASICBLOCKENTRY [A], as shown in
Fig. 3(b), sets the initial locations (indicated by double circles) to
the start locations of the edges in the target graph.
Filter functions encapsulate the interface to the programming
language. They extract CFA edges based on annotations added to a
CFA while parsing the source code. Table 4 lists the ﬁlter functions
currently supported in FQL. Their exact deﬁnitions are speciﬁc to
the C programming language, hence we use according terminology.
Φ::=cover Cpassing P
C::=C+C|C.C|ε|/0|L|E|S|"P"
P::=P+P|P.P|ε|/0|L|E|S|P⋆
Table 1: Syntax of elementary coverage patternsL(X1+X2) = L(X1)∪L(X2)
L(X1.X2) = {w1w2|w1∈L(X1),w2∈L(X2)}
L(ε) = {ε}
L(/0) = /0
L(x) = {x}where x∈L∪E∪S
L(P⋆) = L(P)⋆
L("P") = {"P"}
L(cover Cpassing P) = {w∧"P"|w∈L(C)}
Table 2: Semantics of FQL elementary coverage patterns
π|=/0 ifffalse
π|=ε iffπis the empty sequence /a\}bracketle{t/a\}bracketri}ht
π|=ℓ iffπhas the form /a\}bracketle{ts/a\}bracketri}htandpc(s) =ℓ
π|=ϕ iffπhas the form /a\}bracketle{ts/a\}bracketri}htands|=ϕ
π|=e iffπhas the form /a\}bracketle{tss′/a\}bracketri}htands′∈post(e,s)
π|=w iffπ|=a≤w′with w=aw′and
a∈L∪E∪Sor"P"
π|="P" iffthere is a w∈L(P)such that π|=w
Table 3: Interpretation of path patterns as path predicates
Further CFA Transformers. A CFA transformer Tis either a
ﬁlter function F, function composition, a set-theoretic operation
on target graphs, or predication PRED(T,ϕ). Applied to a CFA A,
PRED(T,ϕ)yields a new CFA that contains for every node u∈LA
two new nodes (u,ϕ)and(u,¬ϕ)representing the evaluation of a
state predicate ϕto true, i.e., (u,ϕ), and to false, i.e., (u,¬ϕ). The
result of applying Tto a CFA Ais denoted by T[A]. See Table 5
for the semantics of all CFA transformers, except ﬁlter functions.
4.3 FQL Speciﬁcations
Table 6 deﬁnes the syntax of FQL speciﬁcations. Basic oper-
ations like “ +” or “.” are the same as in ECPs, but, where ECPs
had nodes and edges of a CFA, FQL speciﬁcations require the op-
eratorsNODES( T),EDGES( T), andPATHS( T,k). Here, Tis a CFA
transformer expression and kis a positive integer.
The clause inTstates that, given a CFA A, all ﬁlter functions in
thecover clause are applied to the target graph T[A]. In practice,
this is often used as in @FUNC(foo) cover EDGES(@CONDITIONEDGE)
passing EDGES(ID)* which is equivalent to the spec cover EDGES(
COMPOSE(@CONDITIONEDGE, @FUNC(foo))) passing EDGES(ID) *.
ID identity function
@BASICBLOCKENTRY one edge per basic block
@CONDITIONEDGE one edge per (atomic) condition outcome
@DECISIONEDGE one edge per decision outcome ( if,for,
while ,switch ,?:)
@CONDITIONGRAPH all edges contributing to decisions
@FILE( a) all edges in ﬁle a
@LINE( x) all edges in source line x
@FUNC( f) all edges in function f
@STMTTYPE( types) all edges within statements types
@DEF( t) all assignments to variable t
@USE( t) all right hand side uses of variable t
@CALL( f) all call sites of f
@ENTRY( f) entry edge of f
@EXIT( f) all exit edges of f
Table 4: Filter functions in FQL
412COMPOSE (T1,T2)[A] = T1[T2[A]]
(T1|T2)[A] = T1[A]∪T2[A]
(T1&T2)[A] = T1[A]∩T2[A]
SETMINUS (T1,T2)[A] = T1[A]\T2[A]
PRED(T,ϕ)[A] = /a\}bracketle{tL′,E′,I′/a\}bracketri}htwhere /a\}bracketle{tL,E,I/a\}bracketri}ht=T[A]
andL′=L×{ϕ,¬ϕ},I′=I×{ϕ,¬ϕ},and
E′={((u,v),l,(u′,v′))|v,v′∈ {ϕ,¬ϕ},(u,l,u′)∈E}
Table 5: Semantics of CFA transformers
Φ::=inTcover Cpassing P
C::=C+C|C.C|(C)|N|S|"P"
P::=P+P|P.P|(P)|N|S|P⋆
N::=NODES (T)|EDGES (T)|PATHS (T,k)
T::=F|PRED(T,ϕ)|COMPOSE (T,T)
|T|T|T&T|SETMINUS (T,T)
F::=ID|@BASICBLOCKENTRY |@CONDITIONEDGE
|@CONDITIONGRAPH |@DECISIONEDGE |@FILE(a)
|@LINE(x)|@FUNC(f)|@STMTTYPE (types)
Table 6: Syntax of FQL
Given a speciﬁcation Φand a CFA A, every operator NODES( T),
EDGES( T), andPATHS( T,k)inΦexpands to a sum (iterated “+”)
of path patterns which represent the nodes, edges, and paths in the
target graph T[A], respectively:
NODES (T) /mapsto→ ∑
n∈nodes (T[A])n
EDGES (T) /mapsto→ ∑
e∈edges(T[A])e
PATHS (T,k) /mapsto→ ∑
p∈pathsk(T[A])p
Intuitively, nodes(T[A])is the set of nodes of the target graph T[A]
obtained by applying TtoA. The same holds for edges(T[A])
andpaths k(T[A]). In case a set nodes(T[A]),edges(T[A]), or
paths k(T[A])is empty the corresponding operator expands to the
symbol /0. The semantics of a speciﬁcation Φis obtained by re-
placing each occurrence of NODES ,EDGES , andPATHS inΦby the
corresponding sum and applying the semantics of Table 2.
Formally, we deﬁne the functions nodes ,edges , and pathsk.
For simplicity let us assume the CFA transformer PRED was not
applied, then, nodes(T[A]) = LT[A],edges(T[A]) = ET[A], and
pathsk(T[A]) ={p|pis ak-bounded path in T[A]}. Ak-bounded
path in T[A]is a sequence of edges, starting in IT[A], in which no
target graph node occurs more than ktimes. In case PRED is applied,
the corresponding state predicates have to be inserted into the path
patterns at the right place.
As an example consider the target graph shown in Fig. 4. There,
nodes(A)is the set of path patterns {ℓ1,ℓ2,ℓ3,ℓ4,ℓ6}and the oper-
atorNODES(ID) yields the expression ℓ1+ℓ2+ℓ3+ℓ4+ℓ6. Here, ℓi
denotes the node labeled with i. The operator EDGES(ID) yields the
path pattern e1,2+e1,3+e2,3+e2,4+e3,4+e3,6, where ei,jdenotes
the edge from node ℓito node ℓj.PATHS(ID, 1) yields the expres-
sion e1,2+e1,3+e1,2e2,3+e1,2e2,4+e1,2e2,3e3,4+e1,2e2,3e3,6+
e1,3e3,4+e1,3e3,6.1if((x > 10
2 && y < 100)
3 || (x < y))
4{ ... }
5else
6{ ... } 421
3
6/a\}bracketle{tx > 10 /a\}bracketri}ht/a\}bracketle{t!(x > 10) /a\}bracketri}ht
/a\}bracketle{t!(y < 100) /a\}bracketri}ht
/a\}bracketle{ty < 100 /a\}bracketri}ht
/a\}bracketle{tx < y/a\}bracketri}ht/a\}bracketle{t!(x < y) /a\}bracketri}ht
Figure 4: Edge- vs. path-coverage
Syntactic construct Expanded expression
-> .“ID*".
@k @LINE( k)
X==0 ε
X==k X. ...X (ktimes)
X<=k Σi=0
kX==i
P>=k P==k.P⋆
NOT(T) SETMINUS (ID,T)
_ ID
Table 7: Syntactic sugar
Semantics. An FQL speciﬁcation
Φ=inGcover Cpassing P
maps a CFA Ato a ﬁnite set Φ(A)of path predicates. By C′we
denote the coverage speciﬁcation obtained by ﬁrst applying the
transformer GtoAand then replacing all NODES( T),EDGES( T),
andPATHS( T,k)by∑n∈nodes (T[G[A]])n,∑e∈edges(T[G[A]])e, and
∑p∈paths(T[G[A]])p, respectively. By P′we denote the path pattern
obtained by replacing all occurrences of NODES( T),EDGES( T), and
PATHS( T,k)by the corresponding sums (for the passing clause G
is not applied). Then, we deﬁne Φ(A)by reducing Φto an ECP:
Φ(A) =L(cover C′passing P′)
PROPOSITION 9.Every FQL speciﬁcation Φsatisﬁes Deﬁni-
tion 6 and, therefore, is an elementary coverage criterion.
Syntactic Sugar. For simpler use, we extend FQL by redundant
constructions summarized in Table 7. Further simpliﬁcations are:
•If neither the operator NODES , norEDGES , norPATHS is given, we
useEDGES as default.
•By default, "ID*" is prepended and appended to cover andpassing
clauses. In analogy to Unix’ grep we can avoid this default by
writing (“ ˆ”) at the start or (“ $”) at the end of an expression.
•Omission of the passing clause is expanded to
in T cover C passing ˆID*$ .
•Omission of the in clause is expanded to
in ID cover C passing P .
5. EV ALUATION
We evaluate FQL in four dimensions: (1) Expessiveness and
usability, (2) practical feasibility of test case generation, (3) uses
of FQL in the SE tool chain, and (4) potential for further research.
5.1 Expressive Power and Usability
Table 8 shows how the test case speciﬁcations Q1-24 of Fig. 1
can be written in FQL. We see that even complex speciﬁcations
can be written as succinct and natural FQL speciﬁcations. (Exper-
iments with these specs are discussed in the next section.)
We note that inside quotes we can use pattern matching for-
malisms more powerful than regular expressions with trivial exten-
sions. We can include, e.g., context-free features such as bracket
413Q1cover@BASICBLOCKENTRY
Q2cover@CONDITIONEDGE
Q3cover@CONDITIONEDGE&
@STMTTYPE(if,switch,for,while,?:)
Q4coverPATHS(@FUNC(main)|@FUNC(insert),1)
Q5coverPATHS(@FUNC(main)|@FUNC(insert),2)
Q6cover@DEF(t)
Q7cover@USE(t)
Q8cover@DEF(t)."NOT(@DEF(t))*".@USE(t)
Q9cover@BASICBLOCKENTRYpassingˆ(@2.{j>0}+NOT(@2))*$
Q10cover@CONDITIONEDGE&@FUNC(compare)
passingˆ(NOT(@CALL(compare))*.
(@CALL(compare)&@FUNC(sort))*)*$
Q11cover@ENTRY(sort).{len>=2}.{len<=15}
."NOT(@EXIT(sort))*".@BASICBLOCKENTRY
Q12in@FUNC(eval)cover@CONDITIONEDGE
passing@CALL(eval).NOT(@EXIT(eval))*.@CALL(eval)
.NOT(@EXIT(eval))*.@CALL(eval)
Q13cover@CALL(sort)passingˆ(NOT(@FUNC(sort))*.
(@FUNC(sort)&NOT(@CALL(unfinished)))*.
NOT(@FUNC(sort))*)*$
Q14cover@CONDITIONEDGEpassing
ˆ(NOT(@CALL(eval))*.@CALL(insert))>=2
Q15in@FUNC(partition)cover@CONDITIONEDGEpassing@7
Q16cover@CONDITIONEDGE + @DECISIONEDGE
Q17cover(@CONDITIONEDGE&@FUNC(sort))
->(@BASICBLOCKENTRY&@FUNC(eval))
Q18cover@BASICBLOCKENTRY->@BASICBLOCKENTRY
Q19cover@BASICBLOCKENTRY
->@BASICBLOCKENTRY->@BASICBLOCKENTRY
Q20cover@BASICBLOCKENTRY->@BASICBLOCKENTRY
->@BASICBLOCKENTRY->@BASICBLOCKENTRY
Q21cover@STMTTYPE(assert)
Q22cover@STMTTYPE(assert)->@STMTTYPE(assert)
Q23cover(@BASICBLOCKENTRY&@FUNC(eval))
passingˆNOT(@LABEL(init))*$
Q24cover@ENTRY(main)passing@ENTRY(main).{precond()}.
NOT(@EXIT(main))*.{!postcond()}.@EXIT(main)
Table 8: Speciﬁcation examples
matching. (We refrained from doing so in this paper to keep the
presentation simple.) Therefore, suitable extensions of FQL can
express essentially all elementary coverage criteria. (Note that all
elementary coverage criteria are unions of suitable path patterns.)
5.2 Prototype Implementation
Our implementation is based on query-driven program testing
[23] augmented with efﬁcient algorithms for SAT enumeration [24].
The implementation currently supports the full range of FQL, ex-
cept for the CFA transformer PRED. It relies on the source code of
CBMC 3.6 [10], a bounded model checker with support for full
ANSI C. Currently, we work only with C programs with static
CFAs, i.e., there is limited support for function calls by function
pointers and no support for longjmp and setjmp . Since we require
a fully speciﬁed CFA to compute target graphs, we make assump-
tions about behavior left undeﬁned by the C standard.
Expressiveness. We evaluated the example speciﬁcations Q1-24
shown in Table 8 with our tool. Since most scenarios—for referring
to line numbers or function names—make only sense for programs
which contain certain tokens, we applied each speciﬁcation to one
of three suitable source ﬁles, cf. Table 9. The ﬁle list2.c contains
the program of Listing 2, and sort1.c and sort2.c contain fragmentsperforming array manipulation.2For each spec, we give the num-
ber of test goals (#goals), the number of test cases (#tc) determined
by the backend, and the number of infeasible test goals (#inf).
The experiments were done on an Intel 2.53 GHz Mac OS X sys-
tem equipped with 4 GB RAM. With the exception of Q20 (quadru-
ple basic block coverage), which took 67 seconds, all specs were
processed in less than 15 seconds. Each run of the test case gener-
ation engine required at most 125 MB of memory.
Spec Source #goals #tc #inf Spec Source #goals #tc #inf
Q1 list2.c 11 3 0 Q13 sort1.c 1 1 0
Q2 list2.c 8 3 0 Q14 sort2.c 6 1 1
Q3 list2.c 8 4 0 Q15 list2.c 8 1 3
Q4 sort2.c 11 3 4 Q16 sort1.c 30 3 0
Q5 sort2.c 20 4 7 Q17 sort1.c 12 2 0
Q6 list2.c 2 2 0 Q18 list2.c 110 4 42
Q7 list2.c 2 2 0 Q19 list2.c 1100 4 829
Q8 list2.c 4 1 2 Q20 list2.c 11000 4 10286
Q9 list2.c 11 4 0 Q21 sort1.c 2 1 0
Q10 sort1.c 2 2 0 Q22 sort1.c 2 1 1
Q11 sort1.c 9 2 1 Q23 sort2.c 4 1 0
Q12 sort2.c 2 1 0 Q24 sort2.c 2 0 2
Table 9: Experimental results for example speciﬁcations
Scalability. To study scalability of our backend to real world
embedded systems code, and possibly also software systems, we
chose a subset of the speciﬁcations and applied them to the fol-
lowing set of programs: (1)We picked some tools from the Unix
coreutils in Busybox 1.143, studied as well in [9], (2)we selected
kbﬁltr.c from the Windows DDK, initially studied in [3], and (3)
we chose an example use case4from [16] where model checking
tools were applied to the Linux virtual ﬁle system layer. In addi-
tion to these well studied examples we applied our framework on
two industrial case studies. (4)We performed test case generation
for an engine controller code generated from a MATLAB/Simulink
model (matlab.c). (5)We examined a dynamic memory manager
for airborne software systems (memman.c). (6)As an example of
a complete software package, we analyzed the sources of the SAT
solver PicoSAT, version 9135.
BB ( Q1) CC ( Q2) BB2(Q18)
Source SLOC #goals #tc #goals #tc #goals #tc #inf
coreutils/cat.c 27 16 4 10 4 224 6 39
coreutils/echo.c 161 27 8 20 11 675 93 198
coreutils/nohup.c 33 17 6 12 5 255 13 133
coreutils/seq.c 37 28 7 20 7 728 23 394
coreutils/tee.c 73 21 9 16 8 399 30 127
kbﬁltr.c 3507 250 2 196 2 62000 2 61911
pseudo-vfs.c 553 10 3 6 3 80 3 44
matlab.c 3444 30 6 22 6 840 10 441
memman.c 245 53 8 40 8 2756 29 1749
PicoSAT 6592 191 43 153 39 36099 417 26352
Table 10: Summary of experimental results
We summarize our experiments in Table 10. For each source we
give the number of lines of code (SLOC)6. To compare to previous
work, we ﬁrst established basic block coverage (speciﬁcation Q1).
We give the number of test goals and the number of test cases that
were necessary to cover these test goals. Given loop bounds of 3
2For source code cf. http://code.forsyte.de/fshell
3http://www.busybox.net/
4http://research.nianet.org/~radu/VFS/
5http://fmv.jku.at/picosat/
6Measured using David A. Wheeler’s SLOCCount tool.
414to 10, we compute test suites for 100% coverage of all feasible test
goals. In [9] in many cases coverage of more than 90% is achieved,
but the feasibility of the remaining test goals is not investigated.
Furthermore, we achieved condition coverage with spec Q2and
“squared” basic block coverage with spec Q18 for all benchmarks.
In case of Q18, many of the resulting test goals are expectedly in-
feasible. We include these numbers in the column #inf.
All experiments (except for PicoSAT, as discussed below) were
performed using at most 350 MB of memory. Each test suite was
computed in less than two minutes, except for Q18 for kbﬁltr.c
which took four minutes. As PicoSAT has a larger code base, the
experiments for basic block coverage and condition coverage took
up to ten minutes and required up to 550 MB. For squared basic
block coverage, the experiments took approximately 4.5 hours and
consumed 2.5 GB of memory.
5.3 FQL in the Tool Chain
To demonstrate practical usefulness of FQL, we describe two
ongoing projects with the embedded systems industry.
Measurement-based Execution Time Analysis. Our initial moti-
vation for FQL and the test case generation backend was measure-
ment-based execution time analysis for embedded real-time soft-
ware. Together with our project partners [33] we are developing a
framework to provide early feedback about the distribution of ex-
ecution times to the developer. In this project, FQL enables us to
efﬁciently compute test suites appropriate for timing analysis.
Model/Implementation Consistency Checking. In collaboration
with an avionics supplier we are currently developing an automated
technique to check consistency of models (UML activity diagrams)
and their implementation (C code) [22]. We ﬁrst compute a test
suite at model level that, e.g., covers all edges of the model. Each
model-level test case then describes a path through the model. We
use this model-level test case as path pattern in an FQL passing
clause and ask for condition coverage at implementation level. The
number of test cases computed reﬂects the relationship between
model and implementation and leads to detailed feedback on pos-
sibly unintended discrepancies.
Discussion. Our projects demonstrate the usefulness of FQL’s
ﬂexible test case speciﬁcation to practical problems in embedded
systems. For avionics software that must conform to highest safety
requirements we will, however, need to add support for modiﬁed
condition/decision coverage. This is beyond the scope of elemen-
tary coverage criteria and requires path set predicates as test goals.
We are currently working on a proper integration into FQL.
5.4 Research Questions about FQL
The language FQL gives rise to a number of interesting ques-
tions both about the formalism and efﬁcient evaluation. The fol-
lowing list just mentions a few of them.
•How to check equivalence and subsumption of speciﬁcations ?
•How can we approximate a speciﬁcation by a simpler one with
a larger test suite ? Where is a good trade-off ?
•How can we rewrite a speciﬁcation into a normal form for which
test cases can be found more easily ?
•How can we distribute speciﬁcations over multiple servers ?
•How can we trace which code changes compromise the mean-
ing of a test speciﬁcation ?
•How can we reuse existing test suites after code changes ?•When can we reuse existing test suites for new speciﬁcations ?
•Which speciﬁcations are amenable to directed testing ?
•How can we combine incomplete light-weight testing with FQL
backends for better efﬁciency ?
•How can we build efﬁcient predicate abstraction based tools for
FQL test case generation ?
•How to obtain feedback about infeasibility of test goals ?
•How can we succinctly describe incomplete coverage ?
•How to capture difﬁcult criteria such as MC/DC ?
•How can we combine FQL with input/output tables and exe-
cutable speciﬁcations ?
•How can we apply FQL to high level models such as UML ?
All these questions can be addressed with the help of FQL.
6. RELATED WORK
Prior to our work, Beyer et al. [3] present a test case generation
engine that supports “target predicate coverage”, i.e., every pro-
gram location has to be visited by some test case that enters the
location with predicate ptrue. In FQL, this coverage criterion is
given by the speciﬁcation cover {p}.NODES(ID) . For test case gen-
eration Beyer et al. use an extended version of the C model checker
BLAST. Like our previous work [24], their work is also mainly
addressed at challenge (e). Note that BLAST uses the database
analogy in a different way than we do. BLAST uses a query lan-
guage [4] to process and access reachability information from the
software model checker. However, the BLAST query language is
not well suited for specifying complex coverage criteria: (i) Speci-
ﬁcations have to be stated in a combination of two formalisms, one
for an observer automaton, and the other for a relational query. (ii)
The BLAST language misses concise primitives for coverage crite-
ria; for instance, path coverage can only be achieved by creating an
individual observer automaton for each program path. (iii) The en-
coding of FQL’s passing clause into a BLAST observer automaton
is in general non-trivial for the working programmer.
Random testing, directed testing and symbolic execution based
approaches aim at achieving a high code coverage with respect to
standard criteria like basic block or path coverage [5, 9, 17, 18,
19, 31]. These approaches are nottailored towards ﬂexible and
customized coverage criteria, and are therefore orthogonal to our
work. Thus, these approaches, too, are primarily addressing chal-
lenge (e). It is an interesting question for future research which
FQL speciﬁcations can be solved efﬁciently by directed testing.
Most existing formalisms for test speciﬁcations focus on the de-
scription of test data, e.g., TTCN-3 [13] and UML TP [30], but
none of them allows to describe structural coverage criteria. Friske
et al. [15] have presented coverage speciﬁcations using OCL con-
straints. Although OCL provides the necessary operations to speak
about UML models, it may yield hard to read expressions for com-
plex coverage criteria. At the time of publication, no tool support
for the framework was reported. Hessel et al. [6] present a spec-
iﬁcation language for coverage criteria at model level that uses
parameterized observer automata. Test suites for speciﬁed cover-
age criteria can be automatically generated using the tool U PPAAL
COVER [21]. Briones et al. [7] investigate coverage measures con-
sidering the semantics of a speciﬁcation and weighted fault models
to arrive at minimal test suites.
415Structural coverage criteria, e.g., basic block coverage, condi-
tion coverage, and path coverage are well studied, cf. [26, 28], al-
beit with different names and a notable lack of precise deﬁnitions.
Attempts of formalizations using temporal logics [25], automata
and graph based approaches [1] or using the Z notation [32] do
not consider the speciﬁcs of the underlying programming language.
Predicate complete coverage [2] is an interesting new coverage cri-
terion that subsumes all of the above coverage criteria, except for
path coverage. We can express predicate complete coverage by the
FQL speciﬁcation cover EDGES(PRED(ID, φ1,..., φk))for a given
set of predicates φ1,..., φk.
7. CONCLUSION
In the introduction of this paper we stated ﬁve challenges for the
design of a test speciﬁcation language:
(a,d) Simplicity, Code Independence and Encapsulation of Lan-
guage Speciﬁcs. Regular languages as base formalism make
FQL easy to read; Table 8 demonstrates that even complex cri-
teria have simple speciﬁcations. Our concept of target graphs
ensures code independence and the encapsulation of language
speciﬁcs.
(b)Precise Semantics. We have given a formal deﬁnition of cov-
erage criteria in Sec. 3 and provided a precise semantics of our
language FQL in Sec. 4. Every FQL speciﬁcation yields an
elementary coverage criterion.
(c)Expressive Power. We have demonstrated that all informal
speciﬁcations of Fig. 1 can be expressed in FQL. As argued
in Sec. 5.1, essentially all elementary coverage criteria can be
expressed by FQL or suitable extensions.
(e)Tool Suppport for Real World Code. In Sec. 5.2 we pre-
sented experimental results for our test case generation back-
end. Amongst others, we generated test suites for device drivers,
a SAT solver, and embedded systems code.
We consider FQL an open framework to be extended. On the lan-
guage level, we are currently working on support for path set pred-
icates, which will enable us to specify criteria such as MC/DC.
8. REFERENCES
[1] P. Ammann, J. Offutt, and W. Xu. Coverage criteria for state
based speciﬁcations. In FORTEST , pages 118–156, 2008.
[2] T. Ball. A theory of predicate-complete test coverage and
generation. In FMCO , pages 1–22, 2004.
[3] D. Beyer, A. J. Chlipala, T. A. Henzinger, R. Jhala, and
R. Majumdar. Generating Tests from Counterexamples. In
ICSE , pages 326–335, 2004.
[4] D. Beyer, A. J. Chlipala, T. A. Henzinger, R. Jhala, and
R. Majumdar. The Blast Query Language for Software
Veriﬁcation. In SAS, pages 2–18, 2004.
[5] D. L. Bird and C. U. Munoz. Automatic generation of
random self-checking test cases. IBM Systems Journal ,
22(3):229–245, 1983.
[6] J. Blom, A. Hessel, B. Jonsson, and P. Pettersson. Specifying
and generating test cases using observer automata. In FATES ,
pages 125–139, 2004.
[7] L. B. Briones, E. Brinksma, and M. Stoelinga. A semantic
framework for test coverage. In ATVA , pages 399–414, 2006.
[8] BullseyeCoverage 7.11.15. http://www.bullseye.com/ .[9] C. Cadar, D. Dunbar, and D. R. Engler. Klee: Unassisted and
automatic generation of high-coverage tests for complex
systems programs. In OSDI , pages 209–224, 2008.
[10] E. M. Clarke, D. Kroening, and F. Lerda. A Tool for
Checking ANSI-C Programs. In TACAS , pages 168–176,
2004.
[11] CoverageMeter 5.0.3. http://www.coveragemeter.com/ .
[12] CTC++ 6.5.3. http://www.verifysoft.com/en.html .
[13] G. Din. TTCN-3. In Model-Based Testing of Reactive
Systems , pages 465–496, 2004.
[14] Software Considerations in Airborne Systems and
Equipment Certiﬁcation (DO-178B). RTCA, 1992.
[15] M. Friske, H. Schlingloff, and S. Weißleder. Composition of
model-based test coverage criteria. In MBEES , 2008.
[16] A. Galloway, G. Lüttgen, J. T. Mühlberg, and
R. Siminiceanu. Model-checking the linux virtual ﬁle
system. In VMCAI , pages 74–88, 2009.
[17] P. Godefroid. Compositional dynamic test generation. In
POPL , pages 47–54, 2007.
[18] P. Godefroid, N. Klarlund, and K. Sen. DART: directed
automated random testing. In PLDI , pages 213–223, 2005.
[19] B. S. Gulavani, T. A. Henzinger, Y . Kannan, A. V . Nori, and
S. K. Rajamani. SYNERGY: a new algorithm for property
checking. In SIGSOFT FSE , pages 117–127, 2006.
[20] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy
abstraction. In POPL , pages 58–70, 2002.
[21] A. Hessel, K. G. Larsen, M. Mikucionis, B. Nielsen,
P. Pettersson, and A. Skou. Testing real-time systems using
UPPAAL. In FORTEST , pages 77–117, 2008.
[22] A. Holzer, V . Januzaj, S. Kugele, C. Schallhart,
M. Tautschnig, H. Veith, and B. Langer. Slope testing for
activity diagrams and safety critical software. Technical
Report TUD-CS-2009-0184, TU Darmstadt, 2009.
[23] A. Holzer, C. Schallhart, M. Tautschnig, and H. Veith.
FShell: Systematic Test Case Generation for Dynamic
Analysis and Measurement. In CAV, pages 209–213, 2008.
[24] A. Holzer, C. Schallhart, M. Tautschnig, and H. Veith.
Query-Driven Program Testing. In VMCAI , pages 151–166,
2009.
[25] H. S. Hong, I. Lee, O. Sokolsky, and H. Ural. A temporal
logic based theory of test coverage and generation. In
TACAS , pages 327–341, 2002.
[26] J. C. Huang. An approach to program testing. ACM Comput.
Surv. , 7(3):113–128, 1975.
[27] G. Myers. The Art of Software Testing . Wiley, 2004.
[28] S. C. Ntafos. A comparison of some structural testing
strategies. IEEE Trans. Software Eng. , 14(6):868–874, 1988.
[29] Rational Test RealTime 7.5. http:
//www.ibm.com/software/awdtools/test/realtime/ .
[30] I. Schieferdecker, Z. R. Dai, J. Grabowski, and A. Rennoch.
The UML 2.0 testing proﬁle and its relation to TTCN-3. In
TestCom , pages 79–94, 2003.
[31] K. Sen, D. Marinov, and G. Agha. CUTE: a concolic unit
testing engine for C. In ESEC/SIGSOFT FSE , pages
263–272, 2005.
[32] S. A. Vilkomir and J. P. Bowen. From MC/DC to RC/DC:
Formalization and analysis of control-ﬂow testing criteria. In
FORTEST , pages 240–270, 2008.
[33] M. Zolda, S. Bünte, and R. Kirner. Towards Adaptable
Control Flow Segmentation for Measurement-Based
Execution Time Analysis. In RTNS , 2009.
416