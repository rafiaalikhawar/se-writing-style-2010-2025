Run-Time Efﬁcient Probabilistic Model Checking
Antonio Filieri
Politecnico di Milano
DeepSE Group at DEI
Piazza L. da Vinci 32, 20133
Milano, Italy
ﬁlieri@elet.polimi.itCarlo Ghezzi
Politecnico di Milano
DeepSE Group at DEI
Piazza L. da Vinci 32, 20133
Milano, Italy
ghezzi@elet.polimi.itGiordano Tamburrelli
Politecnico di Milano
DeepSE Group at DEI
Piazza L. da Vinci 32, 20133
Milano, Italy
tamburrelli@elet.polimi.it
ABSTRACT
Unpredictable changes continuously aﬀect software systems
and may have a severe impact on their quality of service, po-
tentiallyjeopardizingthesystem’sabilitytomeetthedesire d
requirements. Changes may occur in critical components of
the system, clients’ operational proﬁles, requirements, or de-
ployment environments.
Theadoptionofsoftwaremodelsandmodelcheckingtech-
niques at run time may support automatic reasoning about
such changes, detect harmful conﬁgurations, and potentially
enableappropriate(self-)reactions. However,traditionalmode l
checking techniques and tools may not be simply applied as
they are at run time, since they hardly meet the constraints
imposed by on-the-ﬂy analysis, in terms of execution time
and memory occupation.
This paper precisely addresses this issue and focuses on
reliability models, given in terms of Discrete Time Markov
Chains, and probabilistic model checking. It develops a
mathematical framework for run-time probabilistic model
checking that, given a reliability model and a set of require-
ments, statically generates a set of expressions, which can
beeﬃcientlyusedatrun-timetoverifysystemrequirements.
An experimental comparison of our approach with existing
probabilistic model checkers shows its practical applicabili ty
in run-time veriﬁcation.
Categories and Subject Descriptors
D.2.4 [Software Engineering ]: Software/Program Veriﬁ-
cation— Model Checking, Reliability ; C.4 [Computer Sys-
tems Organization ]: Performance of Systems— Modeling
techniques, Performance attributes
General Terms
Probabilistic Model Checking, Reliability
Keywords
Discrete Time Markov Chains, Run-Time Model Checking
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.1. INTRODUCTION
Often software systems are designed, developed and im-
plemented to operate in a completely known and immutable
environment with stable requirements and unvaried opera-
tionalproﬁles. Inthissetting,eachchangeisunexpectedan d
may jeopardize the ability of the system to meet its require-
ments. Whenever a software has to be changed, a complete
maintenance lifecycle–design, development, and deployme nt
of a new version of the system–has to be planned. In this
scenario changes are considered harmful and lead to costly
maintenance activities and unsatisfactory time-to-market.
Increasingly, however, changes occur very frequently and
constitute one of the dominant factors of current software
systems. Today’s software is often built through composi-
tion of components operated by independent organizations
(e.g., Web services integrated in a larger system), which may
evolve unpredictably; clients’ operational proﬁles and de-
ployment environments may also change over time. As a
consequence, software engineers are increasingly required to
design software as an adaptive system , which automatically
detects and reacts to changes.
Many current research proposals describe methodologies
and techniques to design adaptive systems. In this paper,
we focus on software systems that try to adapt themselves
to keep satisfying reliability requirements in the presence
of changes. The most promising solutions build on top
of two complementary techniques: monitoring andmodels
(e.g., [12, 28, 29]). The former aims at interpreting data
extracted at run time from instances of the system. The
data collected by the monitor are analyzed to continuously
update the parameters of the model (e.g., failure probabil-
ity of an external service), to keep the model consistent over
time with the changing behavior of the environment. The
updated model may be analyzed by model checking [2, 7]
tools, which verify the compliance between the current be-
havior of the system and the desired requirements. Because
of our focus on reliability, the models we consider here are
Discrete Time Markov Chains (DTMCs) [14].
Unfortunately, traditional model checking techniques and
tools are conceived for design-time use and can hardly sat-
isfytheexecutiontimeconstraintsnormallyimposedbyrun-
time analyses because of the well known problem of state ex-
plosion, which occurs in analyzing the model. In particular,
the use of model checking tools at run time leads to unsatis-
factory execution time. Indeed, traditional model checking
techniques take as input a model of the system and a prop-
erty expressed in an appropriate formalism (i.e., the require-
ment) and verify if the former is compliant with respect toTraditional Run-Time Model 
Checking
System 
ModelSystem
Requirement 
Violations
Model 
Checker
Monitoring
Requirement
(a) Use of Conventional
Model Checker.
VeriﬁcationPre-computation
System ModelRequirement
Expressions
SystemRequirement 
Violations
Monitoring
 Expressions
(b) The Proposed Approach.
Figure 1: Run-Time Model Checking Techniques
thelatter(i.e., therequirementismetbythemodel). Aspre-
viously introduced, the monitoring continuously updates the
system model at run time and the model checking process is
periodically activated. This run-time procedure is compu-
tationally expensive and requires the exhaustive exploration
of the model’s state space—which may be very large—and
the analysis of the property—which may be arbitrarily com-
plex. Figure 1(a) summarizes such approach. The details
concerning the complexity of traditional probabilistic model
checking can be found in [2, 10, 23].
This paper focuses on eﬃciently evaluating the satisfac-
tion of reliability requirements at run time. The key con-
cept of the proposed solution relies on separating the model-
checking activity in two distinct steps, executed at design
time and run time, respectively. We refer to the design-time
step aspre-computation and to the run-time step as veri-
ﬁcation. The pre-computation step takes as input: (1) the
model of the system as a DTMC, (2) a set of transition vari-
ables, and(3)thereliabilityrequirementsofthesystem. The
transition variables are the parameters of the model whose
value becomes known only at run time, and may change over
time. For example, a transition may connect a state mod-
eling a service invocation to a failure state, and the tran-
sition variable is a literal representing the changing value
of the service’s failure rate. The output produced by the
pre-computation step is a set of symbolic expressions which
represent satisfaction of the requirements. The veriﬁcation
step performed at run time simply evaluates the formulae
by replacing the variables with the real values gathered by
monitoring the system. In the example, the monitor would
yield the real value of the failure rate of the service and
the formulae representing the requirements would evaluate
to either true or false (in case of a violation). Figure 1(b)
describes the two steps involved in the proposed approach.
The main advantage of our approach relies on shifting the
cost of model analysis at design time. The (computationally
expensive) design-time transformation of reliability proper-
ties into symbolic formulae reduces run-time model check-
ing to substituting variables with values and evaluating the
expression, which is computationally inexpensive and does
not require model exploration. The rationale behind the ap-
proach is that we are willing to pay for an expensive trans-formation step at design time if run-time analysis becomes
eﬃcient, and amenable to on-line processing. We measured
the speed up obtained by our run-time model checking ap-
proach with respect to existing probabilistic model checkers:
PRISM [18] and MRMC [21] pointing out advantages and
threats to validity of both the approaches. As shown in Sec-
tion 4, our method outperforms existing probabilistic model
checkersundertheassumptionthatpotentialchangescanbe
anticipated and the number of variable transitions is small.
In the extremecase, one may of course assume all transitions
to be variable, but this would make our approach impracti-
cal.
The rest of the paper is organized as follows: Section 2
provides the necessary background. Section 3 describes the
proposedapproach. Section4illustratesthesimulationsper-
formed through a tool we implemented and reports the ex-
perimental results we obtained. Section 5 discusses related
work. Section 6 concludes the paper describing some current
limitations of our approach and future work.
2. GROUNDING THE PROBLEM
We assume the system under development to be mod-
eled as a Discrete Time Markov Chain (DTMC). DTMCs
a widely accepted formalism to model reliability of compo-
nent (service)-based systems. In particular, they proved to
be useful for an early assessment or prediction of reliability
[19]. The adoption of DTMCs implies that the modeled sys-
tem meets, with some tolerable approximation, the Markov
property–described later on in Section 2.1. This issue can
be easily veriﬁed as discussed in [6, 14].
As for most design approaches based on DTMCs (con-
sider for example [14]), in our work we assume that the
model depscribes behaviors that depend on interaction pro-
ﬁle and failure probabilities, which are used to label DTMC
transitions. These values may be hard to predict at design
time. In practice, a software designer may rely on estimates
for interaction and failure probabilities, gathered by running
instances of similar systems, as discussed in [12]. Some of
these values, in addition, may change over time after the
system has been developed and deployed.
We make the assumption that, through careful design-
time analysis, we can restrict run-time variability to a subset
ofenvironmentparameters. Precisely, weassumethat(1)we
can anticipate the variable transitions in the model and (2)
they are a small fraction of the total number of transitions.
These assumptions are valid in many practical cases. If they
do not hold, our approach may still be applied, but simply
would not yield its expected beneﬁts in terms of speed-up
of run-time veriﬁcation.
In the next section we brieﬂy introduce DTMCs. After-
wards, we describe PCTL [2], a probabilistic temporal logic,
adopted here to express reliability requirements.
2.1 Discrete Time Markov Chains
DTMCsaredeﬁnedasstate-transitionsystemsaugmented
with probabilities. Statesrepresent possible conﬁgurations
of the system. Transitions among states occur at discrete
time and have an associated probability. DTMCs are dis-
crete stochastic processes with the Markov property, accord-
ing to which the probability distribution of future states de-
pend only upon the current state.
Formally, a (labeled) DTMC is tuple ( S,S0,P,L) where•Sis a ﬁnite set of states
•S0⊆Sis a set of initial states
•P:S×S→[0,1]isastochasticmatrix(∑
s′∈SP(s,s′) =
1∀s∈S). An element P(si,sj) represents the proba-
bility that the next state of the process will be sjgiven
that the current state is si.
•L:S→2APis a labeling function which assigns to
each state the set of Atomic Propositions which are
true in that state.
In this paper we will implicitly extend this deﬁnition by
also allowing transitions to be labeled with variables (in the
range 0..1) instead of constants. A state s∈Sis said to be
anabsorbing state ifP(s,s) = 1. If a DTMC contains at
least one absorbing state, the DTMC itself is said to be an
absorbing DTMC .
InanabsorbingDTMCwith rabsorbingstatesand ttran-
sientstates, rowsandcolumnsofthetransitionmatrix Pcan
be reordered such that Pis in the following canonical form :
P=(
Q R
0I)
whereIis anrbyridentity matrix, 0 is an rbytzero
matrix,Ris a nonzero tbyrmatrix and Qis atbytmatrix.
Consider now two distinct transient states siandsj. The
probability of moving from sitosjin exactly 2 steps is∑
sx∈SP(si,sx)·P(sx,sj). Generalizing, for a k-steps path
and recalling the deﬁnition of matrix product, it follows that
the probability of moving from any transient state sito any
other transient state sjin exactlyksteps corresponds to the
entry (si,sj) of the matrix Qk. As a natural generalization,
we can deﬁne Q0(representing the probability of moving
from each state sitosjin 0 steps) as the identity tbyt
matrix, whose elements are 1 iﬀ si=sj[15].
Due to the fact that Rmust be a nonzero matrix, and P
is a stochastic matrix, Qhas uniform-norm strictly less than
1, thusQn→0 asn→ ∞, which implies that eventually
the process will be absorbed with probability 1.
In the simplest model for reliability analysis, the DTMC
will have two absorbing states, representing the correct ac-
complishment of the task and the task’s failure, respectively.
The use of absorbing states is commonly extended to mod-
eling diﬀerent failure conditions. For example, diﬀerent fail-
ure states may be associated with the invocation of diﬀerent
external services. Once the model is in place, we may be
interested in estimating the probability of reaching an ab-
sorbing state or in stating the property that the probability
of reaching an absorbing failure state should be less than a
certain threshold. In the next section we discuss how these
and other interesting properties of systems modeled by a
DTMC can be expresses and how they can be evaluated.
Let us consider for example the DTMC in Figure 2, which
represents a system sending authenticated messages over the
network. States5, 6, and7areabsorbingstates; states6and
7 represent failures associated respectively to the authenti-
cation and to message sending. We use variables as transi-
tion labels to indicate that the value of the corresponding
probability is unknown, and may change over time.
In matrix form, the same DTMC would be characterized
0 3
Success Init1 2Login
MsgFail6
AuthenticationFail10.15
Logout
71y1
x0.85
zSendMsg
1-z
5
End1 411-(x+y)
Figure 2: DTMC Example.
by the following matrices QandR:
Q=
0 1 0 0 0
0 0y0 1−x−y
0 0 0 1 −z0
0 0 0.15 0 0 .85
0 0 0 0 0

R=
0 0 0
0x0
0 0z
0 0 0
1 0 0

This is a toy example that we use to introduce the proposed
approach. However, the concepts described hereafter apply
to real systems which might have thousands of states and
failures, as we discuss in Section 4.
2.2 PCTL and Reliability Properties
Formal languages to express properties of systems mod-
eled through DTMCs have been studied in the past and
several proposals are supported by model checkers to prove
that a model satisﬁes a given property. In this paper, we
focus on PCTL [2], a logic which can be used to express a
number of interesting reliability properties.
PCTL is a logic language inspired by CTL [2]. In place of
the existential and universal quantiﬁcation of CTL, PCTL
provides the probabilistic operator P▷◁p(·), wherep∈[0,1]
is a probability bound and ▷◁∈ {≤,<,≥,>}.
PCTL is deﬁned by the following syntax:
Φ ::=true|a|Φ∧Φ| ¬Φ| P▷◁p(φ)
φ::=XΦ|ΦUΦ|ΦU≤tΦ
Formulae Φ are named state formulae and can be evalu-
ated over a boolean domain (true, false) in each state. For-
mulaeψare named path formulae and describe a pattern
over the set of all possible paths originating in the state
where they are evaluated.
The satisfaction relation for PCTL is deﬁned for a state s
as:
s|=true
s|=aiﬀa∈L(s)
s|=¬Φ iﬀs⊭Φ
s|= Φ1∧Φ2iﬀs|= Φ1and s|= Φ2
s|=P▷◁p(ψ) iﬀPr(s|=ψ)▷◁p
A formal deﬁnition of how to compute Pr(s|=ψ) is pre-
sented in [2]. The intuition is that its value corresponds to
the fraction of paths originating in sand satisfying ψover
the entire set of paths originating in s. The satisfaction rela-
tion for a path formula with respect to a path πoriginating
ins(π[0] =s) is deﬁned as:π|=XΦ iﬀπ[1]|= Φ
π|= ΦUΨ iﬀ∃j≥0.(π[j]|= Ψ∧(∀0≤k<j.π[k]|= Φ))
π|= ΦU≤tΨ iﬀ∃0≤j≤t.(π[j]|= Ψ∧(∀0≤k<j.π[k]|= Φ))
PCTLisanexpressivelanguagethatallowsmanyinterest-
ingreliability-relatedpropertiestobespeciﬁed. Ataxonomy
of all possible reliability properties is out of the scope of thi s
paper. The most important case is a reachability property .
A reachability property states that a state where a certain
characteristic property holds is eventually reached from a
given initial state. In most cases, the state to be reached is
an absorbing state. Such state may represent a failure state ,
in which a transaction executed by the system modeled by
the DTMC eventually terminates, or a success state . Reach-
ability properties are expressed as P▷◁p(true UΦ)1, which
expresses the fact that the probability of reaching any state
satisfying Φ has to be in the interval deﬁned by constraint
▷◁ p. Φ is assumed to be a simple state formula that does
not include any nested path formula. In most cases, it just
corresponds to the atomic proposition that is true in an ab-
sorbing state of the DTMC. In the case of a failure state, the
probability bound is expressed as ≤x, wherexrepresents
the upper bound for the failure probability; for a success
state it would be instead expressed as ≥x, wherexis the
lower bound for success.
PCTL is an expressive language through which more com-
plex properties than plain reachability may be expressed.
Such properties would be typically domain-dependent, and
their deﬁnition is delegated to system designers. For exam-
ple, referring to the example in Figure 2, we express the
following reliability requirements:
•R1:“The probability that a MsgFail failure happens is
lower than 0.001”
•R2:“The probability of successfully sending at least one
message for a logged in user before logging out is greater
than0.001”
•R3:“The probability of successfully logging in and im-
mediately logging out is greater than 0.001”
•R4:“The probability of sending at least 2 messages be-
fore logging out is greater than or equal to 0.001”
These requirements can be translated into PCTL as shown
in Table 1. Notice that R1is an example of reachability
property. Also notice that these requirements have diﬀerent
sets of initial states: R1,R3, andR4must be evaluated
starting from state 0 (i.e., S0={0}) whileR2must be
evaluated starting from state 1.
In the next section we present a mathematical procedure
to compute a (symbolic) formula (i.e., an analytic expres-
sion) for the properties we want to verify at run time. We
start by analyzing reachability properties and then we pro-
gressively show how to cover all of PCTL formulae.
3. THE APPROACH
In this section we illustrate how PCTL formulae may be
pre-computed at design time. Pre-computation produces
1Note that this is often expressed as P▷◁pFΦ, using the ﬁ-
nallyoperator.Table 1: Requirements translation in PCTL.
Req. PCTL
R1P≤0.001(true U s = 7) =P≤0.001(F s= 7)
R2 P≥0.001(1≤s≤2U s= 3)
R3 P≥0.001(X s= 4)
R4 P≥0.001(1≤s≤3U≤5s= 4)
a formula for each PCTL property. The formula is an ana-
lytic expression that contains variables which become known
at run-time. Variables correspond to transition probabili-
ties that are unknown (or uncertain) at design time. Note
that there must be at least two variable transitions exiting
a state, since the sum of probabilities must be 1. In general,
we may assume that if there is a variability, all the transi-
tions exiting a node are variable. We refer to such states
asvariable states . We start this section by discussing how
reachability formulae may be pre-computed. We then dis-
cuss how to extend our approach to cover the entire PCTL.
3.1 Reachability Formulae
The most commonly studied property for reliability anal-
ysis is the probability of reaching a certain state, which typ-
ically represents the success of the system or some failure
condition. Both success and failure are modeled by absorb-
ing states. The reachability formula in this case has the
following form: P▷◁pFl, wherelis the label of the target
absorbing state. Let us start our discussion by showing how
to pre-compute at design time a reachability formula for an
absorbing state of a DTMC.
For an absorbing DTMC, the matrix I−Qhas an inverse
NandN=I+Q+Q2+...=∑∞
i=0Qi[15]. The entry nijof
NrepresentstheexpectednumberoftimestheMarkovchain
reaches state sj, given that it started from state si, before
getting absorbed. Instead, qijrepresents the probability of
moving from the transient state sito the transient state sj
in exactly one step.
Given that Qn→0 whenn→ ∞(as discussed in Section
2.1), the process will always be absorbed with probability 1
after a large enough number of steps, no matter which state
it started in. Hence, our interest is to compute the prob-
ability distribution over the set of absorbing states. This
distribution can be computed in matrix form as:
B=N×R
whererikis the probability of being absorbed in state sk
given that the process started in state si.
Bis at×rmatrix and it can be used to evaluate the
probability of each termination condition starting from any
DTMC state as an initial state. In particular the element bij
of the matrix Brepresents the probability of being absorbed
into statesjgiven that the execution started in state si.
The design-time computation of an entry bijin general
can only be done symbolically, since variable states may be
traversed to reach state sj. Let us evaluate the complex-
ity of such computation. Inverting matrix I−Qby means
of the Gauss-Jordan elimination algorithm [1] requires t3
operations. The computation of the entry bijonceNhas
beencomputedrequires tmoreproducts, thusthetotalcom-
plexity ist3+talgebraic operations on polynomials. The
computation could be further optimized by exploiting thesparsity of I−Q. Notice that the symbolic nature of the
computation makes the design-time phase quite costly [16].
The complexity can be signiﬁcantly reduced if the number
of variable components cis small and the matrix describing
the DTMC is sparse, as very frequently happens in practice.
LetW=I−Q. The elements of its inverse Nare deﬁned
as follows:
nij=1
det(W)·αji(W)
whereαji(W) is the cofactor of the element wji. Thus:
bik=∑
x∈0..t−1nix·rxj=1
det(W)∑
x∈0..t−1αxi(W)·rxj
Computing bikrequires the computation of tdeterminants
of square matrices with size t−1. Letτbe the average
number of outgoing transitions from each state ( τ <<nby
assumption). Each of the determinants can be computed by
means of Laplace expansion. Precisely, by expanding ﬁrst
thecrows representing the variable states (each has τsym-
bolic terms), we need to compute at most τcdeterminants
and then linearly combine them. Each submatrix of size
t−cdoes not contain any variable symbol, by construction,
thus its determinant can be computed with ( t−c)3oper-
ations among constant numbers (LU-decomposition), thus
much faster than the corresponding ones among polynomi-
als. The ﬁnal complexity is thus:
τc·(t−c)3∼τc·t3(1)
whichsigniﬁcantlyreducestheoriginalcomplexityandmakes
the design-time pre-computation of reachability properties
feasible in a reasonable time, even for large values of t.
As a point of comparison, the computation of reachabil-
ity properties performed by probabilistic model-checkers is
based on the solution of a system of nequations in nvari-
ables [2], which has, in a sequential computational model, a
complexity equal to n3[4].
Summing up, we discussed the computation of proper-
ties in the form P▷◁p(Fsk), whereskis an absorbing state,
starting in any initial transient state of the system2. With
this procedure, it is possible to obtain closed formulae for a
number of interesting reliability properties.
For example, evaluating R1on our example system, that
is the probability of reaching the state MsgFail failure in any
number of execution steps corresponds to evaluating b07as:
R1:(yz)
(0.85+0.15z)≤0.001
Let us now consider the computation of the probability
of successfully reaching a certain state sjthat is not an ab-
sorbing state3. The quantity we are interested in is fij, the
probability of ever making a transition into state sjgiven
that the process started in state si(sican be any transient
state taken as initial state). Formally, let fn
ijrepresent the
probability of moving from the transient state sito the tran-
sient statesjfor the ﬁrst time in exactly nsteps:
2Actually we discussed the computation of the probability
associated with the property, to which the constraint ▷◁ p
has to be applied.
3Ourmathematicaldescriptionfollowsthe treatmentin[27],
to which we direct the reader for a more detailed discussion.{
f0
ij= 0∀i̸=j;f0
ij= 1∀i=j
fn
ij=Pr{Xn=sj∧Xk̸=sj∀1≤k≤n−1|X0=si}
whereXkis the state of the system at execution step k.
Then:
fij=∞∑
n=0fn
ij
It is possible to compute the value fijfrom the matrix N
by conditioning the entry nij–the expected number of times
the DTMC on whether state sjis ever entered [27]:
nij=njjfij
thus:
fij=nij
njj=αji(W)
αjj(W)
Hence, computingtheprobabilityofmovingfromatransient
statesito a transient state sjis reduced to the computation
of the determinants of two matrices with size t−1. Again,
by the fact that only a few rows of Nare symbolic (i.e.
only a few states are variable), the actual complexity of the
computation is approximately the same as in expression 1.
The approach we described so far supports the deﬁnition
of properties which represent requirements that speak about
“the probability of reaching state sjwithout reaching any fail-
ure”or“the probability of a successfully performing a certain
operation or service” . In our example, the probability of
reaching the Logoutstate 7 after any number of steps4cor-
responds to the entry f04=0.85−0.85x+0.15z−0.15xz−yz
0.85+0.15z.
Once again, we stress that our approach is especially prac-
tical under the assumption that the number of parameters of
the system is reasonably small. Design-time computational
eﬀort could be further reduced by adopting state-of-the-art
(parallel) matrix calculus algorithms [20].
3.2 Extending to Full PCTL
In the previous section we described a solution limited to
reachability properties. Even though reachability represents
the most widely adopted pattern for reliability analysis, it
does not cover all the requirements that engineers need to
express for real-world applications; consider for example re-
quirements R2–R4of our example. In this section, we in-
crementally extend the approach to handle all of PCTL.
Noticethatreachabilitypropertiescorrespondtorestricted
until formulae P▷◁p(Φ1∪Φ2) where: (1) Φ 1corresponds to
true(i.e., Φ 1is satisﬁed in any state) and (2) Φ 2does not
include any nested path formula (we refer to this subset of
PCTL which does not allow the nesting of path operators
as theﬂat subset ). Sections 3.2.1 and 3.2.2 discuss our ap-
proach for each PCTL operator in the case of ﬂat formulae.
Section 3.2.3 then describes how to extend the approach to
nested formulae, thus covering the entire PCTL.
3.2.1 Flat Until formulae
The procedure to support requirements in the (ﬂat) form
Φ1∪Φ2relies on: (1) reducing them to reachability proper-
ties and (2) applying the technique described in sect. 3.1.
4Note that this probability is not what is needed for R3,
which in turn requires to reach logout in a single step. See
Section 3.2.2.The reduction procedure starts with the construction of a
DTMC ¯Ddeﬁned as follows. We refer to the set of states of
¯DasS¯D. The set is the union of three non-overlapping sub-
sets,Sgoal,S¬goalandStransient, respectivelydeﬁnedas: (1)
all the absorbing states of the original DTMC in which Φ 2is
true plus an additional auxiliary state sgoal, (2) all the ab-
sorbing states of the original DTMC in which Φ 2is false plus
anadditionalauxiliarystate s¬goal, and(3)alltheremaining
statesoftheoriginalDTMC: Stransient =S/{Sgoal∪S¬goal}.
The following algorithm deﬁnes the transitions of ¯Dstarting
from the transitions of the original DTMC:
1. deletealltheoutgoingtransitionsfromallthetransient
statesoftheoriginalDTMCinwhich ¬(Φ1∨Φ2)istrue
and add a single outgoing transition directed to s¬goal
with a labelling probability equal to 1.
2. attach to all the transient states of the original DTMC
where Φ 2is true a single outgoing transition directed
tosgoalwith a labelling probability equal to 1.
Recallingour example of Figure 2 and considering require-
mentR2we have that:
Sgoal={sgoal}
S¬goal={s¬goal,5,6,7}
Stransient ={0,1,2,3,4}
Figure 3 illustrates the resulting DTMC ¯D.
Figure 3: Resulting DTMC ¯D.
Goal states in Sgoalrepresent the satisfaction of the for-
mula. In fact, all the path formulae in the form Φ 1UΦ2
are satisﬁed in all the states in which Φ 2is true and those
states, in ¯D, are directly connected to goal states. More-
over, the predecessor states on any path that leads to a
state where Φ 2is true are such that Φ 2is false (otherwise
from there we would reach Sgoalwith probability 1) and Φ 1
is true (otherwise it would have been deleted by step 1 of
our algorithm). Conversely, states in S¬goalcan be reached
directly, and with probability 1, by all the states in which
the formula is not satisﬁed, i.e. ¬(Φ1∨Φ2) istrue. Hence,
we reduced the evaluation of a general Until property to a
reachability property such as: P▷◁p(F s∈Sgoal).
For example, evaluating R2on the original DTMC is
equivalent to evaluating the reachability property P▷◁p(F
s∈Sgoal) over¯D, which corresponds to the entry b18, where
8 is the index of state sgoal, computed over the transition
matrix of ¯D:
R2:y−yz≥0.001
3.2.2 Flat Next and Bounded Until formulaeLet us consider again the ﬂat subset of PCTL and let us
focus on the pre-computation of formulae that use the Next
and the Bounded Until operators, which require analyzing
paths of ﬁnite length.
The set of paths to be considered in order to evaluate
the formula XΦ1in statesiis composed by all 1-step long
paths exiting si. The maximum size of such set is n(i.e., the
number of states), which is also the worst-case complexity
of our design-time pre-computation procedure. The proba-
bility thatsi|=XΦ1is:
Pr(XΦ1) =∑
sj|=(Φ1)pij
For example, in order to evaluate R3, we ﬁrst notice that
s= 4 is satisﬁed only in state Logout. Thus, the probability
of satisfying s= 4 in exactly one step from state 1 ( Login)
is expressed by the formula 1 −x−y, andR3becomes
R3: 1−x−y≥0.001
A similar procedure applies to the Bounded Until. A path
originating in si, which satisﬁes the formula Φ 1U≤vΦ2, at
a certain step k≤vsatisﬁes Φ 2and for all the states l<k
satisﬁes Φ 1. We therefore need to consider all the paths with
lengthk≤v.
If we exploit the DTMC ¯Dbuilt as explained in the previ-
ous section, all these paths correspond to paths of ¯Dwhose
length is equal to exactly v+1 and which reach a transient
state satisfying Φ 2invsteps and then end in any of the
states inSgoal. Indeed, if a path reaches an absorbing state
afterksteps, it remains in that state with probability equal
to 1, thus the tail of the path will be composed of v+1−k
self-transitions with probability 1 exiting a state in Sgoal.
The probability of moving in v+ 1 steps from a state si
to a statesjcorresponds to the entry pv+1
ijof the (v+1)-th
power of the transition matrix Pof the DTMC ¯D. Hence:
Pr(Φ1U≤vΦ2) =∑
sj∈Sgoalpv+1
ij
In our example, let us consider R4. After constructing
¯D, it is possible to compute the probability of reaching any
of the goal states from the Loginstate. In this case there is
only one goal state sgoalbecause the formula s= 4 is false
in any other absorbing state. Thus, we need to compute the
entryp6
18, where 8 is the index of sgoal, and such a value is:
R4: 1−x−y+0.85y(1−z)+0.1275y(1−z)2≥0.001
To assess design-time complexity in this case, we should
consider that we need to compute the matrix Pv+1. Since
the complexity of a matrix dot product is approximately n3
[8], a non-optimized algorithm has complexity vn3.
At runtime, both Next and Bounded Until only require to
evaluate a polynomial, by substituting values to transition
variables, as in the case of reachability formulae.
3.2.3 Handling Nested Path Formulae
We have shown that for all kinds of ﬂat PCTL formulae it
is possible to generate a corresponding symbolic expression
at design time. In the case of nested path operators, that is
for formulae P▷◁p(ψ) where at least one subformula of ψis
again a path formula, some information needed to compute
the expression might be unavailable at design time.
For example, the actual violation of requirements R1-R4
will be known only at run time, when parameter values willbe available. If any of those formulae is, for example, part of
the right-hand operand of an Until formula, the construction
of the reduced DTMC ¯Dmust be delayed to run time, when
the set of states which satisﬁes Φ 2(and Φ 1) becomes known
from the values bound to the parameters. Thus, in general,
to evaluate a formula with nested P▷◁p(·) operators, we need
toknow in which states its subformulae are satisﬁed, andthe
deﬁnition of this set may depend on parameter values. The
same observation can be applied recursively to subformulae
of a subformula, until we reach a ﬂat formula, for which we
can immediately construct an equivalent expression.
To develop a solution, we need a way to delay the evalua-
tion of a formula to run time, when all of its subformulae will
be already evaluated providing the missing knowledge. In
order to support this process, we add some extra parameters
at design time, which will account for the lack of informa-
tion concerning subformulae’s satisfaction. Those parame-
tersconstituteascaﬀoldingintroducedatdesigntime, which
is removed as subformulae are evaluated.
Let us ﬁrst focus on Until formulae, like Φ 1UΦ2. Re-
calling the procedure in Section 3.2.1, the construction of
¯Drequires two basic operations (besides the introduction
of absorbing states sgoalands¬goal): (1) replacing all out-
going transitions from states where ¬(Φ1∨Φ2) holds by a
single one toward s¬goal, and (2) replacing all outgoing tran-
sitions from states where Φ 2is true by a single one toward
sgoal. From a mathematical viewpoint, deleting a transition
is equivalent to labeling it with 0 probability. By multiply-
ing each non-zero transition pijof the original DTMC by a
coeﬃcientmij∈ {0,1}, it is thus possible to delay the de-
cision whether a transition should be deleted or not by later
assigning0or1tothecorrespondingcoeﬃcient mij. Tocon-
struct¯D, we also need to be able to connect a transient state
tosgoalors¬goal. In order to do that, we complete our scaf-
folding by introducing two transitions, labelled aisgoaland
ais¬goal, to connect each state ito the newly introduced
sgoalands¬goal, respectively. These labels can be assigned
at run time value 1 in case the construction of ¯Drequires to
connect the transient state itosgoalors¬goal, respectively.
By applying the scaﬀolding procedure to our example, we
obtain for matrices QandR:
Q=
0m0,10 0 0
0 0 m1,2y 0m1,4(1−x−y)
0 0 0 m2,3(1−z) 0
0 0m3,20.15 0 m3,40.85
0 0 0 0 0

R=
0 0 0 a0,8a0,9
0m1,6×x0a1,8a1,9
0 0 m2,7×z a2,8a2,9
0 0 0 a3,8a3,9
m4,50 0 a4,8a4,9

The last phase of the decision procedure in Section 3.2.1
requires to sum the probabilities of reaching every absorbing
state inSgoal. This set will be known at run time, when
the subformula Φ 2can be evaluated. At design time, we
simply compute the entire matrix B(the probabilities of
goingfromeachtransientstatetoeachabsorbingstate)from
the original DTMC, instrumented with the just presented
scaﬀolding. At run time, when the set Sgoalbecomes known,
we assign a value to mijandaijcoherently with what we
did in Section 3.2.1 and sum all the bijfrom the transient i
in which the formula is being evaluated to a state j∈Sgoal.
Concerning Next and Bounded Until operators, the meth-
ods described in Section 3.2.2 are still valid, though theyhave to be applied to the matrix Pinstrumented with the
scaﬀolding, sothat, atruntime, itispossibletoassignvalu es
tomijandaijto account for the newly acquired knowledge.
In the case of nested path operators, at design time, it is
not possible to exploit the mixed–symbolic (expanded via
Laplace) and numeric–computation of bijpresented in Sec-
tion 3.1. Nevertheless, being mijandaijboolean, instead of
ﬂoating point multiplications with constant values it is po s-
sible to use faster bitwise AND, while multiplying a polyno-
mialby1hasnocostandmultiplyingitby0triviallyreturns
0. Thus the introduction of the scaﬀolding does not aﬀect
signiﬁcantly the complexity of the design-time analysis we
illustrated in Section 3.1.
At run time, in the case of nested path operators, the
PCTL formula cannot be evaluated in a single step, as we
didforﬂatformulae. Neverthelessthenumberofexpressions
to compute is linearin the number of path operators, and
each formula has to be evaluated at most for all transient
states. Each evaluation still works on a polynomial. The
run-time eﬃciency gain over conventional model checkers is
discussed next for all PCTL formulae.
4. V ALIDATION
The main goal of this work is to ﬁnd an eﬃcient way of
computing reliability properties in frequently changing envi-
ronments. We described a solution that performs a (design-
time) computationally expensive derivation of veriﬁcation
formulae that can be evaluated very eﬃciently at run time,
when parameter values become known. The approach ﬁts
the very frequent situation in which time consumption dur-
ing development is not critical, but run-time evaluation of
veriﬁcation formulae is subject to tight time constraints.
Concerning run-time evaluation5, we compared the per-
formance of a simple Java/C prototype implementation of
our approach with the outputs produced by two widely used
probabilistic model checkers (PRISM [18] and MRMC [21])
and with a numerical computation of results of formulae by
Matlab. All the tools were required to produce an approxi-
mation of at most 10−15and to run with its default solution
strategy.
The test suite is composed of 127 samples. Each sample is
a randomly generated DTMC with a number of states vary-
ing from 50 to 500 (with step 50), with 2 absorbing states
(namely correct completion andfailure). Each state has a
number of outgoing transitions randomly sampled from a
Gaussian distribution with mean 10 and standard deviation
2. The number of variable states is 4 for all the samples,
and when a state is variable so are all its outgoing transi-
tions. We did not consider the process spawning time and
we report as execution time the one provided by each tool.
Theexecutionenvironmentisadedicatedmachinewith2In-
tel(R) Xeon(R) CPU E5530 2.40GHz and 8Gb of RAM. The
operating system is Ubuntu Server 2.6.24-24, 64bit. Matlab
version is 2008a(release 7.6.0.324), PRISM version3.3.1 and
MRMC 1.4.1 both compiled at 64bit with default compiling
options. Our prototype generates the input ﬁles for all of
these tools and a C program computing our formulae. Con-
cerning PRISM, here we consider model-checking time only,
which does not take into account the model construction
5The software used for the experimental as-
sessment and the datasets are available at
http://home.dei.polimi.it/ﬁlieri/icse2011time [18] (up to 15 secs for a 500 states DTMC).
The empirical validation focused on reachability formulae.
In practice, most useful reliability properties are expressed
as reachability formulae. In addition, as we showed in Sec-
tion 3, reachability is at the core of analysis for also other
PCTL properties.
500	  5000	  50000	  500000	  
0	   50	   100	   150	   200	   250	   300	   350	   400	   450	   500	  Computa(on	  Time	  (us)	  
DTMC	  size	  (#states)	  Matlab	   Prism	   MRMC	   Us	  
Figure 4: Runtime Veriﬁcation.
The result of our comparison is shown in Figure 4 (we
use a logarithmic scale for time). Computation time growth
quickly as the size of the DTMC raises, both for PRISM
and MRMC. PRISM exhibits serious performance problems,
probablyduetothefactthatitisunabletotakeadvantageof
its symbolic engine [24], which instead performs pretty well
in the reduction of complex PCTL formulae to reachability
problems. The state-space reduction approach adopted by
MRMC [22] seems to be more successful for our samples.
PRISM becomes an order of magnitude worse than our ap-
proach after 75 states, while MRMC after 200 states. With
500 states PRISM takes an order of 106µsand MRMC
still 104µs. We also used Matlab to compute the same
procedure based on linear algebra that was adopted in our
methodology, but with numerical methods. Input matrices
were declared as sparse, so that the Matlab numerical engine
chooses the best algorithm to perform computation.
The runtime performance of our tool is close to a con-
stant for reachability formulae. Independent of the size of
the input DTMC, computation time is in the order of 103µs
with a maximum of 2014 µs, an average of 1565 .27µsand
a standard deviation of 322 .77µs. Fluctuations in the val-
ues are due to the topology of the matrices, which can lead
to longer or shorter polynomial forms in our mathematical
formulae, depending on how they scatter variable symbols
during computation. The gap between 450 and 500 is es-
sentially due to some outliers in the dataset, whose eﬀect
can be reduced by extending the sample set (available on
the web). In any case, the number of possible combination
of those symbols is always bounded. Remember that we
are considering the case in which only a few states are vari-
able, and their number is the most inﬂuent parameter for
our complexity, determining how many variables appear in
our mathematical formulae. Our approach is independent
of the size of the DTMC, and the resulting mathematical
formula can be implemented directly in any programming
language, without any need to integrate with external tools
or libraries. Notice that the mathematical formula we pro-
duce is not optimized neither at the computation level, by
grouping terms of factorizing polynomials, nor at the com-
pilation level (e.g., via optimization ﬂags for mathematica lcomputation as in gcc6).
The price for such a fast run-time evaluation has to be
paid at design time, though only once. As explained in
Section 3, the three parameters on which design-time com-
putation depends are: (1) the size of the system, (2) the
number of variable states, and (3) the number of transitions
outgoing from variable states. Our prototype design-time
symbolic manipulation engine is not optimized; thus the ex-
ecution times reported hereafter are just an indicative order
of magnitude of the complexity scale of the problem in a
non-parallel execution environment. All the following exper-
iments were conducted in the same execution environment
described above for run-time performance evaluation. Exe-
cution on a parallel machine might bring a drastic reduction
of execution time.
All DTMCs in the following test suites have 2 absorbing
states representing successful termination and failure of a
hypothetical system. The DTMC are generated randomly
with 2 variable states and an average of 10 outgoing transi-
tions (standard deviation 2). As before, if a state is variable,
so are all of its outgoing transitions.The reliability property
is expressed as the reachability of a successful termination
state.
y	  =	  4E-­‐07x3	  +	  0.0021x2	  -­‐	  0.5862x	  +	  38.604	  
0	  200	  400	  600	  800	  1000	  1200	  1400	  1600	  1800	  2000	  
0	   100	   200	   300	   400	   500	   600	   700	   800	   900	   1000	  Computa(on	  Time	  (s)	  
DTMC	  size	  (#states)	  3me/size	   Poly.	  (3me/size)	  
Figure 5: Precomputation time over DTMC’s size.
Figure 5 describes how pre-computation time varies ac-
cording to the size of the system. The grey line shows an
interpolated trend-line whose equation is also shown in the
ﬁgure. The expected complexity in this case was n3, where
nis the number of states in the DTMC. As a matter of fact,
the use of Jama7for the numerical part of the computation
slightly reduced the expected computation time, which is
still a low-order polynomial.
The number of variable states is the most critical param-
eter for design-time pre-computation. Figure 6 reports pre-
computation time for a number of variable states from 1 to
5.
All the sample DTMCs (3 per class) are composed by 200
states, each of those with an average of 10 outgoing transi-
tions (standard deviation 2). The time axis in Figure 6 is in
logarithmic scale. The diagram shows that time complexity
is exponential and roughly in the order of 14c, wherecis
the number of variable states, which is consistent with what
one expects considering the randomness of the number of
6http://gcc.gnu.org
7http://math.nist.gov/javanumerics/jamay	  =	  0.0862e2.6372x	  
0.1	  1	  10	  100	  1000	  10000	  100000	  
1	   2	   3	   4	   5	  Computa(on	  Time	  (s)	  
Variable	  Components	  (#)	  0me/components	   Expon.	  (0me/components)	  
Figure 6: Precomputation time over variable states.
transitions of the input samples.
Thelastparameterwhichaﬀectsdesign-timepre-computation
is the average number of transitions from variable states.
Figure 7 shows the results of our experiments. For simplic-
ity we sampled the number of outgoing transitions for all the
states (both variable and not) from a Gaussian distribution
having as mean the number of transitions on the abscissa
and standard deviation equal to mean/4 (rounded to the
closest integer). The DTMC has 200 states, 2 of which are
variable. Hence the expected complexity is in the order of
τ2, which was conﬁrmed by the empirical results.
y	  =	  0.4601x2	  -­‐	  4.9737x	  +	  19.114	  
0	  20	  40	  60	  80	  100	  120	  140	  
4	   6	   8	   10	   12	   14	   16	   18	   20	  Computa(on	  Time	  (s)	  
Average	  Outgoing	  Transi(ons	  (#)	  1me/transi1ons	   Poly.	  (1me/transi1ons)	  
Figure 7: Precomputation time over τ.
5. RELATED WORK
In this paper we focused on reliability requirements for
DTMC-based models. Based on the seminal work described
in [6], DTMCs become the most widely adopted modeling
formalism to deal with reliability at architecture level. A
number of approaches have been proposed in this direction
[19, 5]. The latter presents a framework for component reli-
ability prediction whose objective is to construct and solve
a stochastic reliability model allowing software architects
to explore competing alternatives. Speciﬁcally, the authors
tackle the deﬁnition of reliability models at architectural
level and the problems related with parameter estimation.
Besides the basic estimation of failure occurrence, there
are a number of advanced reliability properties that can be
analyzed by means of DTMC-based techniques, e.g. failure
propagation [9] and failure evolution and transformation in
presence of multiple failure modes [13].An important problem, shared by all design approaches
based on DTMCs, is how to get interaction and failure prob-
ability values [14]. Many solutions came out from the re-
search community, from accelerated test [17] to mining of
bug repositiories [26], up to the estimation of failure prob-
abilities even in case no failure has been observed [25], and
so and so on. To make our methodology worthy, one must
be able to estimate relevant system parameters on-the-ﬂy,
by monitoring the system. Many methods exist to support
reasoning on non-functional properties of software based on
models that are analyzed at run-time by relying on moni-
toring such as [3, 12, 28, 29], but for all of them the tighter
bottleneck is how to realize that a requirement is being vio-
lated in a time short enough to allow eﬀective reactions.
Probabilistic model-checking plays a crucial role in eval-
uating reliability properties, typically expressed in PCTL,
over DTMC models of the running system. In practice,
however, they require minutes or more to evaluate prop-
erties over large models, thus hindering planning and re-
conﬁguration capabilities that must respond to tighter time
bounds. In [11] Daws proposed a procedure to ﬁrst convert
the DTMC into a ﬁnite automaton from which it is possi-
ble to obtain a corresponding regular expression. This ex-
pression can be evaluated to a mathematical formula which
represents any arbitrary reachability property. Daws’ ap-
proach is restricted to formulae without nested probabilis-
tic operators and the outcoming regular expression grows
quickly with the number of states composing the DTMC
(nlog(n)). In [16] Hahn et al. propose a reﬁnement of the
approach presented in [11] for reachability formulae which
combines state space reduction techniques and early evalu-
ation of the regular expression in order to improve actual
execution times when only a few variable parameters ap-
pear in the model. The improvement in [16] requires n3
arithmetic operations among polynomials, performing bet-
ter than [11] in most practical cases, although still leading
to anlog(n)long expression in the worst case. As opposed
to our approach, [16] only deals with reachability proper-
ties. For reachability properties, by applying our approach
in a sequential environment and considering each paramet-
ric transition as a polynomial expression, one can obtain ap-
proximately the same complexity as [16] without resorting
to particularly eﬃcient determinant computation methods
[20]. For example, by applying the Coppersmith–Winograd
algorithm we could reduce complexity to n2.376. Paralleliza-
tion, as well as exploitation of sparsity of matrix W(see
Section 3.1) would lead to an even higher improvement in
design-time computation performance.
6. CONCLUSIONS AND FUTURE WORK
Weaddressedtheproblemofeﬃcientrun-timemodelcheck-
ing of reliability models expressed as DTMCs. We provided
a mathematical approach that divides the model checking
process in two steps to be computed respectively at design
timeandruntime, improvingconsiderablytherun-timeper-
formance of analysis. The approach, which is particularly
valuable for systems with a limited number of variability
points, provides full support to PCTL and is particularly
eﬃcient for reachability properties.
We implemented the approach in a prototype tool, which
will be made available as an open source artifact. We per-
formed extended simulations, but for space reasons we could
only report on selected cases. We focused on comparingour solution with state-of-the-art tools, like PRISM [18] and
MRMC [21]. An empirical comparison with PARAM8, the
tool implementing the approach of [16], concerning reach-
ability properties is also planned after we will develop an
optimized implementation of our tool. Our approach is a
solution based on linear algebra and well known algorithms,
that can be highly parallelized to make our approach more
eﬃcient. In the future, we plan to complement simulation-
based validation with real-world case studies to stress the
scalability and eﬀectiveness of the approach. In addition,
we plan to reduce design-time complexity by means of state
space reduction and partial order reduction techniques.
Finally, the approach might be extended both to other
logics, such as PCTL*, and to other Markov models, such as
Continuous Time Markov Chains for performance analysis.
Acknowledgments
The authors thank Ilenia Epifani for her continuous support
on probability theory and Holger Hermanns for useful com-
ments on an earlier draft. This research has been partially
funded by the European Commission, Programme IDEAS-
ERC, Project 227977-SMScom.
7. REFERENCES
[1] S. C. Althoen and R. McLaughlin. Gauss-jordan
reduction: A brief history. The American
Mathematical Monthly , 94(2):130–142, 1987.
[2] C. Baier and J.-P. Katoen. Principles of Model
Checking . The MIT Press, 2008.
[3] L. Baresi and S. Guinea. Towards dynamic monitoring
of ws-bpel processes. ICSOC, 2005.
[4] A. Bojanczyk. Complexity of solving linear systems in
diﬀerent models of computation. SIAM Journal on
Numerical Analysis , 21(3):591–603, 1984.
[5] L. Cheung, R. Roshandel, N. Medvidovic, and
L. Golubchik. Early prediction of software component
reliability. In ICSE, Leipzig, Germany, May 10-18,
2008, pages 111–120. ACM, 2008.
[6] R. C. Cheung. A user-oriented software reliability
model.IEEE Trans. Softw. Eng. , 6(2):118–125, 1980.
[7] E. Clarke, O. Grumberg, and D. Peled. Model
Checking . Springer, 1999.
[8] D. Coppersmith and S. Winograd. On the asymptotic
complexity of matrix multiplication. SIAM J.
Comput. , 11(3):472–492, 1982.
[9] V. Cortellessa and V. Grassi. A modeling approach to
analyze the impact of error propagation on reliability
of component-based systems. In H. W. Schmidt,
I. Crnkovic, G. T. Heineman, and J. A. Staﬀord,
editors,CBSE, volume 4608 of LNCS, pages 140–156.
Springer, 2007.
[10] C. Courcoubetis and M. Yannakakis. The complexity
of probabilistic veriﬁcation. J. ACM, 42(4), 1995.
[11] C. Daws. Symbolic and parametric model checking of
discrete-time markov chains. ICTAC, pages 280–294,
2005.
[12] I. Epifani, C. Ghezzi, R. Mirandola, and
G. Tamburrelli. Model evolution by run-time
parameter adaptation. In ICSE, 2009.
8http://depend.cs.uni-sb.de/tools/param[13] A. Filieri, C. Ghezzi, V. Grassi, and R. Mirandola.
Reliability analysis of component-based systems with
multiple failure modes. In CBSE, pages 1–20, 2010.
[14] K. Goseva-Popstojanova and K. S. Trivedi.
Architecture-based approach to reliability assessment
of software systems. Performance Evaluation ,
45(2-3):179 – 204, 2001.
[15] C. Grinstead and J. Snell. Introduction to Probability .
Amer Mathematical Society, 1997.
[16] E. Hahn, H. Hermanns, and L. Zhang. Probabilistic
reachability for parametric markov models. Model
Checking Software , pages 88–106, 2009.
[17] P. Heidelberger. Fast simulation of rare events in
queueing and reliability models. TOMACS ,
5(1):43–85, 1995.
[18] A. Hinton, M. Kwiatkowska, G. Norman, and
D. Parker. Prism: A tool for automatic veriﬁcation of
probabilistic systems. TACAS, 3920:441–444, 2006.
[19] A. Immonen and E. Niemela. Survey of reliability and
availability prediction methods from the viewpoint of
software architecture. Software and Systems Modeling ,
7(1):49–65, 2008.
[20] E. Kaltofen and G. Villard. On the complexity of
computing determinants. Computational Complexity ,
13(3):91–130, 2005.
[21] J.-P. Katoen, M. Khattri, and I. S. Zapreev. A Markov
reward model checker. In QEST, pages 243–244, Los
Alamos, CA, USA, 2005. IEEE Computer Society.
[22] J.-P. Katoen, I. S. Zapreev, E. M. Hahn,
H. Hermanns, and D. N. Jansen. The ins and outs of
the probabilistic model checker mrmc. Performance
Evaluation , In Press, Corrected Proof:–, 2010.
[23] M. Kwiatkowska, G. Norman, and D. Parker.
Stochastic model checking. Formal Methods for
Performance Evaluation , pages 220–270.
[24] M. Kwiatkowska, G. Norman, and D. Parker. Prism:
Probabilistic symbolic model checker. In T. Field,
P. Harrison, J. Bradley, and U. Harder, editors,
Computer Performance Evaluation: Modelling
Techniques and Tools , volume 2324 of Lecture Notes in
Computer Science , pages 113–140. Springer Berlin /
Heidelberg, 2002.
[25] K. W. Miller, L. J. Morell, R. E. Noonan, S. K. Park,
D. M. Nicol, B. W. Murrill, and J. M. Voas.
Estimating the probability of failure when testing
reveals no failures. IEEE Trans. Softw. Eng. ,
18(1):33–43, 1992.
[26] C. Rahmani, H. Siy, and A. Azadmanesh. An
experimental analysis of open source software
reliability. In F2DA, Niagara Falls , 2009.
[27] S. Ross. Stochastic Processes . Wiley New York, 1996.
[28] J. Zhang and B. H. C. Cheng. Model-based
development of dynamically adaptive software. In
ICSE, pages 371–380. ACM, 2006.
[29] T. Zheng, M. Woodside, and M. Litoiu. Performance
model estimation and tracking using optimal ﬁlters.
IEEE Trans. Softw. Eng. , 34(3):391–406, 2008.