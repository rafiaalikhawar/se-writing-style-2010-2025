BALLERINA :AutomaticGeneration and Clustering of Efﬁcie nt Random Unit Tests
forMultithreaded Code
AdrianNistor1,QingzhouLuo1,MichaelPradel2,ThomasR.Gross2,DarkoMarinov1
1Department of Computer Science, University of Ill inois at Urbana-Champa ign, USA
2Department of Computer Science, ETH Zurich, Sw itzerland
{nistor1, qluo2, marinov}@illinois.edu, michael@ binaervarianz.de, thomas .gross@inf.ethz.ch
Abstract—Testing multithreaded code is hard and expens ive.
A multithreaded unit t est creates two or mor e threads, each
executing one or more methods on shared obj ects of the class
under test. Such unit t ests can be generated at random, but
basic random generatio n produces tests that ar e either slow or
do not trigger concurre ncy bugs. Worse, such t ests have many
false alarms, which req uire human effort to ﬁl ter out.
We present B ALLERINA , a novel technique for automated
random generation of efﬁcient multithreaded tests that ef-
fectively trigger concu rrency bugs. B ALLERINA makes tests
efﬁcient by having only two threads, each exec uting a single,
randomly selected meth od. BALLERINA increases chances that
such simple parallel co de ﬁnds bugs by appen ding it to more
complex, randomly gen erated sequential code. We also propose
a clustering technique t o reduce the manual eff ort in inspecting
failures of automatical ly generated multithre aded tests. We
evaluate B ALLERINA on 14 real-world bugs from six popular
codebases: Groovy, JD K, JFreeChart, Apache Log4j, Apache
Lucene, and Apache P ool. The experiments s how that tests
generated by B ALLERINA ﬁnd bugs on average 2X -10X faster
than basic random gen eration, and our cluste ring technique
reduces the number of inspected failures on a verage 4X-8X.
Using B ALLERINA , we found three previo usly unknown bugs,
two of which were alre ady conﬁrmed and ﬁxe d.
I. INTRODUCTION
General-purpose proces sors manufactured toda y have
multiple cores, and the projections are that the number
of cores will be increa sing. To harness these cores for
speedinguptheirapplica tions,developersnowwr iteparallel
code, typically using a m ultithreaded, shared-mem ory pro-
gramming style. Howev er, writing multithreaded software
isnotoriouslydifﬁcult,a sthesamecodecanhav edifferent
behaviorfordifferentthre adinterleavings.Addition ally,test-
ing multithreaded softwa re is expensive because it requires
(1)writingappropriatete stcode,(2)exploring(ma ny)thread
interleavings of this test code while checking ora cles, and
(3)inspectingoraclevio lations.
Most research on testin g multithreaded softwar e [1]–
[6] has focused on imp roving approaches for s tep (2)—
exploringthreadinterleav ingsandcheckinggeneri coracles.
These approaches typica lly do not generate test code but
only explore the given test code for various th read inter-
leavings and apply gene ric oracles checking for bugs such
asdataraces,atomicityv iolations,non-determinis m,ornon-linearizability [2], [7]–[1 2]. If an interleaving vi olates an
oracle, a potential bug i s reported to the develo per. These
approacheshaveshowna lotofpromiseinﬁnding realbugs.
However,theyrequireto begiventestcodeasinpu t,andthey
canproducealotoffals ealarms.
Automaticallygenerating unittestcodeformultith readed
softwarecouldgreatlyea setestingofsuchsoftwa re.While
many techniques have b een proposed for autom ated gen-
eration of test code for sequential software, e.g. , random
generation of unit tests for object-oriented softw are [13]–
[15], they do not directl y apply to multithreaded software.
Namely, test code for m ultithreaded, object-orien ted soft-
ware needs to create on e or more objects that a reshared
among multiple threads and to invoke methods on these
objects; putting arbitrary test code for sequential software
intomultiplethreadsrare lycreatesenoughsharing totrigger
concurrencybugs.
Abasicrandomgenerationofmultithreadedtests[2 ]can
achievesharingbyﬁrstc reatinganobjectsequent iallyusing
arandomlyselectedconstructorandtheninvokinginseveral
parallel threadsrandomly selected meth ods on this object.
Unfortunately,thisgenera tionhastwomajorproble ms.First,
it can take a lot of mac hine time to explore the generated
test code, because the to tal number of thread int erleavings
growsexponentiallywith thenumberofthreadsan dsharing
amongthreads.Second,i tcantakealotofdevelop ertimeto
inspectthereportsgenera tedbyviolationsofgener icoracles
formultithreadedtests,b ecausesuchoraclescanc reatealot
offalsealarms(e.g.,on theorderoftenfalseala rmstoone
truebugreport,asshown inSectionV).
Thispapermakesthreec ontributions.
A novel technique fo r generating efﬁcient multi-
threaded tests that are effective at triggering concur-
rency bugs:We propose B ALLERINA, a novel technique
forautomatedrandomge nerationofefﬁcientmult ithreaded
unit test code. B ALLERINAtakes as input a class u nder
test and a set of its m ethods, and generates a s output
multithreaded tests that arebothefﬁcient and effective a t
triggering concurrency b ugs. The key idea is to minimize
parallel execution to red uce the time needed for exploring
it, without sacriﬁcing th e bug-triggering capabil ities. The
minimal possible conﬁgu ration for multithreaded unit tests
© 2012 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, 
including reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to  
servers or lists, or reuse of any copyrighted component of this work in other works.
istwothreadsthateachex ecuteasinglemethodun dertest.
Combining this minimal conﬁguration with basic random
generation would miss m any real-world concurren cy bugs.
Instead, BALLERINAprepends the minimalparallel sufﬁx
with a more complexsequential preﬁxthat “grows” the
object(s) under test, cre ating the conditions nec essary to
triggerbugsintheparall elsufﬁx.
BALLERINAfocuses on bugs that ca n be triggered by
two threads. This sufﬁce s for almost all real-wor ld concur-
rency bugs: a recent stud y [16] of 96 concurrency bugs in
large C/C++ application s (MySQL, Apache, Mo zilla, and
OpenOfﬁce)foundthato nlytwobugsrequireatl eastthree
threads;inotherwords,9 4outof96bugscanbere produced
withonlytwothreads.
After BALLERINAgeneratesmultithreaded tests,itneeds
to explore and check th em. Exploration is orth ogonal to
generation, so B ALLERINAcould use stress testing [3],
randomizedthreadinterle avings[17]–[20],and/ors ystematic
exploration [3], [6], [21] . Our BALLERINAimplementation
uses Java PathFinder (JP F) [6]. For checking, ou r imple-
mentation useslinearizability[2], [22], which intuit ively
reportsaviolationwhene verathreadinterleaving produces
a behavior that cannot b e produced in any linea rized test
execution where all meth ods execute atomically. W e chose
linearizabilitybecauseit canﬁndrealconcurrency bugs[2].
Clustering oracle viol ations for faster insp ection:
Whilesomelinearizabili tyviolationsshowtrue b ugs,other
violations are false alarm s. For example, the Apa che Pool
can throwConcurrentModificat ionExceptionin some
concurrent scenarios but does not throw this exc eption in
a corresponding sequent ial execution. This beha vior is a
linearizabilityviolation,b utitisclearlyspeciﬁedin thePool
documentation, so it is a benign violation, not a t rue bug.
Ideally,aperfectoracle wouldnotreportthisbeh avior,but
allknowngenericoracle sformultithreadedsoftw arecreate
falsealarms,e.g.,90%of reporteddataracesarebe nign[23].
BALLERINAalleviatestheproblemof falsealarmsusing
clustering. We build on the idea of clustering failures for
sequentialcode[24]–[29] :ﬁrst,reportsaresplitint oclusters
with similar failures tha t are likely to be either all false
alarms or all true bugs ; then, rather than insp ecting the
reportsinanarbitraryor der,thedevelopercanin spectthem
by selecting from differe nt clusters. B ALLERINAperforms
clustering based on conc urrently executing metho ds under
testandthetypeoffailu re.
Evaluation:We evaluate B ALLERINAon14 real-world
bugsfromsixpopularcodeba ses:Groovy,JDK,JFreeC hart,
ApacheLog4j,ApacheL ucene,andApachePool. Wecom-
pare BALLERINAwith basic random gene ration of multi-
threadedtestsofsixdiffe rentsizes(basedonthen umberof
threadsandmethods).We considerfourdifferentex ploration
approaches(CHESS-like preemptionbounding[3] ,exhaus-
tivestatefulsearchusedi nJPF[6],statelesssearch [21],and
parallelizedtestexecution )andmeasurethecostof exploring1classGenericObjectPoolextendsBaseObjPoolimplementsObjPool{
2GenericObjectPool(Poo lableObjectFactory fact ory,intmaxActive){...}
3ObjectborrowObject(){...}
4voidreturnObject(Object ob j){...}
5voidaddObject(){...}
6voidinvalidateObject(Objec tobj){...}
7voidclear(){...}
8voidevict(){...}
9voidclose(){...}
10voidsetMaxActive(intmaxActive){...}
11intgetMaxActive(){...}
12...
13}
Figure1. APIfortheGenericObjectPoolclassfromApachePool
generated tests to ﬁnd a bug. Compared to basic random
generation of minimal t ests (two threads, each with one
method),B ALLERINAﬁndsmorebugs(13vs.3).Compared
to basic random genera tion of larger tests (two or more
threads, each with two or more methods),tests generated
byBALLERINAtrigger the bugs substan tially faster, 2X-
10Xonaverage.
Weevaluatetheeffective nessofourclusteringtec hnique
forboth B ALLERINAandthebasicrandomge neration.For
some cases, there are n o false alarms, i.e., all reported
violations are true bugs . For some other cases, there can
be a large number of fa lse alarms. Without clus tering, the
developer would need t o sift through a large n umber of
reports (e.g., dozens) to ﬁnd a true bug.Our clustering
reduces inspection time: the developer needs to inspect a
smallnumberofreports (e.g.,3-4)toﬁndatrue bug.
Using BALLERINA, we foundthree previously unknow n
bugsin the widely used Apa che Log4j and Apache Pool.
Twobugswereconﬁrmed andﬁxed[30],[31],and thethird
isstillunderinvestigatio n[32].
II. EXAMPLE
To illustrate how B ALLERINAworks, we use the exam -
ple of testing a class fr om the Apache Pool lib rary. The
library provides several classes that implement p ools, i.e.,
collections of objects th at can be shared amon g several
threads. Figure 1 shows declarations of several methods
fromtheGenericObjectPoolclass.Theconstructorta kes
aFactorythat creates objects for the pool, and sets the
maxActivenumber of objects in th is pool. Clients of this
classﬁrstobtainanobje ctfromthepool(borrowObject),
then work with this ob ject, and ﬁnally return it back to
the pool (returnObject). The methodsclearandevict
remove from the pool a ll idle objects (i.e., thos e not cur-
rentlyborrowed)andall objectsthatsatisfycertai ncriteria,
respectively.Theclassal sohasalargenumberof getterand
settermethods,butwes howonlythoseformaxActive.
TheGenericObjectPoolclass is highly concu rrent.
Because a number of clients can be invoking the pool
methodsfromdifferentt hreads,GenericObjectPooldoes
notgloballylocktheent irepoolforeachmethod butratheruses ﬁne-grained lockin g so that a number of methods
proceedconcurrently.
Suppose that we want to test howGenericObjectPool
behaves when clients c all various methods fro m multi-
ple threads. It is easy to apply B ALLERINAto generate
multithreaded unit test c ode forGenericObjectPool. We
instruct B ALLERINAto test this class and its methods
listed in Figure 1. We a lso provide a simple fac tory class,
becausePoolableObjectFacto ryisaninterface,andany
testwouldneedtoprovi deaconcreteclass.
Generating Tests with BALLERINA :BALLERINAran-
domlygeneratestests,ea chofwhichconsistsof twoparts.
Thesequential preﬁxcreates anobject under test(OUT),
inourexampleaGenericObjectPoolobject,andinvokes
severalmethodsonthato bject.Theparametervalu esforthe
methods are randomly g enerated, by creating oth er helper
objectsasnecessary.Theparallel sufﬁxcreatestwothreads
that each execute only one of the given metho ds on the
OUTcreatedintheseque ntialpreﬁx.Thetestexec utionwill
exploremultipleinterleav ingsofthesetwothreads .
Figure2showsanexamp letestgeneratedbyB ALLERINA.
The OUT isvar4. Its constructor setsmaxActiveto1.
Aftervar4iscreated,addObjectisinvokedonit.Bothth e
parameter value (1) and the method call (addObject) are
requiredtobringvar4inastatewhereabugis triggeredby
theparallelsufﬁx.Inthe parallelsufﬁx,thethread st1and
t2invokeborrowObjectandevict,respectively,onvar4.
We also showvar2generated by B ALLERINA, although it
isnotnecessarytotrigge rthebuginthiscase.
Executing the B ALLERINA Tests:BALLERINAuses
knowntechniquestoexpl oredifferentthreadinterl eavingsof
generatedtests[3],[6],[ 21]andtocheckforpote ntialbugs
usinglinearizability[2].F orexample,exploringthe testfrom
Figure 2 with CHESS-li ke exploration (preempti on bound
of two) [3] ﬁnds a non- linearizability violation: executing
borrowObjectandevictatomicallysucceedsbut execut-
ing them concurrently d eadlocks. B ALLERINApresents to
theuserareportwithth istestanditsinterleavin g.
Real Unknown Bug:Our inspection of t his ex-
ample indeed revealed a previously unknown bug in
GenericObjectPool,whichthePooldevelope rsconﬁrmed
and ﬁxed after we had i nformed them. The analy sis shows
thattriggeringthisbugre quiresaparticular,non-tr ivialpool
state and execution con dition, as described by the Pool
developers:“[...]wheneve rmaxActiveisabouttob eattained
byaborrowObjectwitho neidleinstanceinthepo ol,ifone
thread does a borrow w hile the evictor is visitin g the idle
instance,theborrowingt hreadwillstalluntilanot herthread
doesaborroworreturn.” [30].Suchstatecannotb ecreated
withatrivialsequential preﬁx,andhavingamor ecomplex
parallel sufﬁx would inc rease the exploration tim e to ﬁnd
thebug.
Comparison with Basic Random Generation:Explor-
ing many thread interle avings for a given test is expen-1voidtest(){
2//sequential preﬁx, obje ct under test (OUT): var4
3ﬁnalSimpleFactory var0=newSimpleFactory();
4ﬁnalGenericObjectPoolvar 2=newGenericObjectPool(var 0,0);
5ﬁnalGenericObjectPoolvar 4=newGenericObjectPool(var 0,1);
6var4.addObject();
7//parallelsufﬁx
8Threadt1 =newThread(){
9 public voidrun(){var4.borrowObject();} };
10Threadt2 =newThread(){
11 public voidrun(){var4.evict();} };
12t1.start(); t2.start();
13t1.join();t2.join();
14}
Figure2. Atestgenerat edbyBALLERINAthattriggeredanunknow nbug
sive [4], [6]. The cost is increasing with the n umber of
threadsandthenumbero fsharedmemoryaccesse sineach
thread. BALLERINAminimizes this cost by g enerating the
minimal possible parall el section, two threads with one
method each. In contras t, consider basic random tests that
wouldhavethreeormor ethreadsand/orexecute morethan
onemethodperthread.T hesetestswouldhavemo rethread
interleavingsandwouldb eslowertoexplorewhen theytrig-
gernobug.However,iti snotclearapriorithatth eywould
take more time to trigg er the bug (because tes ting more
methods at once could increase the chance to t rigger the
bug).InourexampleofGenericObjectPool,experimental
results (Section V) show that BALLERINAtests trigger the
bugabout5Xfasterthan basicrandomtestswithtw othreads
andtwomethodseach,w hileotherconﬁgurations withmore
threadsormethodsaree venslower.
Report Clustering:To reduce the time fo r inspecting
reports, BALLERINAintroduces a novel repo rt clustering
basedonthemethodsun dertestthatexecuteatth epointof
failure and the type of f ailure. The intuition is th at similar
reports are likely to be either all false alarms o r all true
bugs.Ourevaluationsho wsthat,forGenericObjectPool,
both BALLERINAand basic random tests can generate
up to hundreds of false alarms for each true bu g, which
would require that the d eveloper inspects a larg e number
of false alarm reports t o ﬁnd a true bug, rend ering the
toolimpractical.Withou rclusteringtechnique,ho wever,the
developer needs to inspe ct only three or four fal se alarms
beforeﬁndingatruebug report.
III. GENERATINGTESTS
We next describe how BALLERINAgenerates multi-
threadedunittestsfora givenclassundertest(C UT)anda
setofmethods.Eachtest consistsoftwoparts:asequential
preﬁxthat creates anobject under test(OUT) with a CUT
constructorandpotential lycallssomemethodson theOUT
sequentially,andaparallel sufﬁxthatcallstwomethodso n
theOUTconcurrently.
A. Generating Sequentia l Preﬁx
BALLERINAmodiﬁestheRandoopalg orithm[14]togen-
eratetheOUTintheseq uentialpreﬁx.Ingeneral ,Randooptakes as input a set of classes under test and generates
sequentialteststhathave randomsequencesofme thodcalls
totheseclasses.Randoopbroadlybutsparselycoversstates
of objects from these cl asses. Even when given only one
CUT,Randoopsparselyc oversstatesofobjectsof thatclass,
e.g., calling methods on many objects but not ne cessarily
calling many methods o n one object. In contrast , we want
BALLERINAtomore denselycoverstatesofobjectsf orthe
onegivenCUT.Tothate nd,wemodiﬁedRandoo ptofocus
thegenerationononeOUTforeachsequenceandto “grow”
suchobjectsacrossvario ussequences.
Figure3showsthepseud o-codefortherelevantpa rtofthe
Randoopalgorithm(adap tedfrom[14])andtheB ALLERINA
addition highlighted (lin es 8, 11, 12, 13). The algorithm
maintains a collection o f method sequences. Fo r each se-
quence that can create one or more objects of the CUT,
BALLERINAtagsexactly oneOUT.Somesequences create
no objects of the CUT but only objects of othe r classes,
such asSimpleFactoryin the example from Fi gure 2. In
that case, there is no O UT, but such sequences are still
useful,becausetheycan beusedasparametersfo rmethods
insequencesthatdohav eanOUT.
In lines 6 and 7, Rando op randomly chooses a method
m(whoseparametershave typesτ i),somesequencesseqs
that can create method p arameters, and expressio nse ifor
these parameters (e.g., a variable such asvar0, ornullif
no object of a type is a vailable, or constants fo r primitive
types).Inline9,Randoop generatesanewrandoms equence
newSeqbyappendingsequences forparametersandaddin g
anewcallnewV ar=m(e 1. . . e n);itthenchecksthatthe
newsequencedoesnotf ailwithuncaughtexcept ions.
BALLERINAadditionallyselectsand/o rupdatestheOUT.
Inline8,ifthereceiverh astheCUTtype,thenB ALLERINA
does not randomly selec t the expression for that parameter
butselects the OUT from t he appropriate sequence. Thus,
theOUTfromtheseque nceseqs(1)isenhancedbycalling
themethodm(τ 1. . . τ n)onit,andthesameobje ctbecomes
the OUT for the newly created sequencenewSeqin line
11. In line 12, B ALLERINAcreates a new OUT whe nm
is a CUT constructor or a static method returnin g objects
oftheCUTtype.Ifam ethodbothreturnsanob jectofthe
CUT and has the receive r of the CUT type, then the OUT
isthereceiver.Effectivel y,thisfavorsenhancingt hestateof
OUT,asopposedtocrea tinganewOUT.
While BALLERINAaims to create diversity of states for
objectsoftheCUT,italso avoidsredundantstatesth atwould
only increase testing tim e but not the chance to ﬁnd bugs.
Inline13,B ALLERINAchecksifthenewOUTw asalready
generatedbyanotherseq uence.Randoophasasim ilarcheck
but for the objects produ ced by the last method c all in the
newsequence,while B ALLERINAfocusesontheOUT.
To illustrate, recall Figu re 2 and consider the se quence
that consists of the ﬁrs t three (constructor) cal ls—call it
S. Assume thatvar4is the OUT forSand further1AlgorithmRandomlyGenerateMeth odSequences
2input:classUnderTest(CUT), methodsUnderTest
3output:collectionofnon-error methodsequences
4nonErrorSeqs←emptyCollection
5while(timelimitnotreached)
6m(τ 1. . . τ n)←randomlySelectOneMeth od(methodsUnderT est)
7�seqs, e 1. . . e n� ←randomSeqsAndExprs(nonErrorSeqs, τ 1. . . τ n)
8if(τ 1=CUT)e 1←seqs(1).OUT
9newSeq, newV ar←append(seqs, m, e 1. . . e n)
10if(executingnewSeqfails)continue
11if(τ 1=CUT)newSeq.OUT←e 1
12else if(returnType(m) =CUT)newSeq.OUT←newSeq.newVar
13if(∃s∈nonErrorSeqs s.t. s.OUT.equals(newSeq.OUT))continue
14nonErrorSeqs←nonErrorSeqs∪ {newSeq}
Figure3. IntegratingB ALLERINA’sgenerationofsequenti alpreﬁxinthe
Randoopalgorithm. B ALLERINAcodeishighlighted.
that BALLERINArandomlyselectstheme thodaddObject.
The only parameter (i. e., the receiver) is of the type
GenericObjectPool, which is the CUT. If BALLERINA
selectsthesequenceSforthattype,itthensele ctstheOUT
var4(ratherthanvar2)astheexpressionfortha tparameter.
B. Generating Parallel S ufﬁx
After generating a collec tion of sequences, B ALLERINA
usesthemtogeneratemu ltithreadedtestsbyaddin gcodefor
thethreads.Foraparalle lsufﬁx,BALLERINAﬁrstrandomly
selectstwomethodsfrom thegivenset.Theselecti onisnot
uniform but based on th e number of method par ameters of
the CUT type. We call these parametersCUT-parameters.
A method that has two or more CUT-parameter s is twice
as likely to be selected t han a method that has o ne or zero
CUT-parameters.Theint uitionforthisbiasistha tmethods
withmoreCUT-paramete rshavemoreinteractions between
the objects of the CUT and are thus more likely to trigger
concurrency bugs. Of th e methods in Figure 1, none has
morethanoneCUT-para meter,sotheyareallequ allylikely
to be selected; for the e xample in Figure 2, B ALLERINA
selectedborrowObjectandevict.
After selecting two meth ods, BALLERINArandomly se-
lects parameters for thes e methods. B ALLERINAﬁrst ran-
domlyselectsfromtheco llectiononeortwoseque nceswith
an OUT to use in the s equential preﬁx. B ALLERINAuses
two sequences if any of the two selected method s has two
or more CUT-parameters ; otherwise, it uses one sequence.
We call these sequencesselected sequences. For our run-
ningexamplewithborrowObjectandevict,thereisone
selectedsequence,which endswithvar4.addObject.
BALLERINAnext selects the expres sions for the pa-
rameters of the two me thods. If a parameter ty pe is the
CUT, BALLERINArandomly selects the OU T from one of
the selected sequences. Otherwise, B ALLERINArandomly
selects an object of the appropriate type from th e selected
sequences (because those sequences can have othe r objects
besidestheOUT)or,ifth ereisnosuchobject,B ALLERINA
selectsasequencefromth eentirecollection.Inour example,
each(receiver)paramete rforborrowObjectandevictisfromtheCUT,andthusB ALLERINAselectsvar4,resulting
inthetestshowninFigu re2.
IV. REPORTCLUSTERING
BALLERINAuses linearizability [2], [22] as a generic
oracle and may report f alse alarms. To alleviate the prob-
lem of inspecting failure reports, BALLERINAcan cluster
test failures based on th eir similarity. Each failu re report
contains several pieces of information: (1) the test that
was executed, including the methods called from the test
(BALLERINAgenerates only two me thods per test, but
the basic random genera tion can generate a large r number
of methods per test), (2 ) the thread interleaving that was
executeduptothefailure ,(3)thestacktraceforea chthread,
including theexecuting methods(i.e., the methods unde r
test that were executing at the point of the failu re), and
(4) thetype of failure(deadlock or an excepti on, including
the class of the exceptio n, e.g.,NullPointerExceptio n
orConcurrentModificat ionException). In general, all
thesepiecescouldbeus edtodeterminefailures imilarity.
BALLERINAusesonlytheexecutingm ethodsandthetype
offailuretodeterminesim ilarity.Ourexperimentss howthat
these two pieces of info rmation already provide excellent
resultsforclusteringfailu resofautomaticallygene ratedmul-
tithreaded unit tests. Mo re speciﬁcally, B ALLERINAsplits
thefailuresintoclusters suchthatallfailuresino necluster
have(1)thesamesetof executingmethodsunder test(i.e.,
the allocation of method s to threads does not m atter) and
(2)thesametypeoffail ure.Notethatseveralrep ortsfrom
the same test can end u p in different clusters, a nd reports
fromdifferenttestscane ndupinthesamecluste r.Indeed,
while (deterministic) se quential tests can have only one
outcome(passorfail),am ultithreadedtestcanhave different
outcomes for different th read interleavings, some of which
maybefalsealarmswhi leothersaretruebugs.
Splitting reports into cl usters is the ﬁrst step i n using
clustering; the next step is determining thesampling strat-
egy[24], [27] for inspectin g reports from the clust ers. A
commonsamplingstrateg y[24],[27],whichweal souse,is
to randomly order cluste rs and visit them in a ro und-robin
fashion, randomly select ing one report for inspec tion from
eachcluster.Anotherstr ategy,speciﬁctothemu ltithreaded
code,wouldbetoinspect thefailuresinaclusterin theorder
inwhichthetestexplora tionproducedthem.We foundthat
the latter strategy does not provide better result s than the
formerbecausetwocons ecutivefailureshavesim ilarthread
interleavingsandthusare likelytobeeitherbothfal sealarms
orbothtruebugs.
V. EVALUATION
We evaluate B ALLERINAon14 real-world bugsfrom
six popular codebases: G roovy, JDK, JFreeChart, Apache
Log4j, Apache Lucene, and Apache Pool. Figur e 4 shows
the following informatio n about each bug: the a pplicationname, the bug ID that w e will use in the rest of the paper,
theissueIDfromtheapp lication’sissue-trackings ystem,the
number of lines of code in the application, the cl ass under
test,itsnumberoflineso fcode,thenumberofme thodswe
giveBALLERINAtotest,andthetypeofb ug.Wechosethe
methods to test among the more complex meth ods in the
CUT, simulating how an expert developer of mult ithreaded
codewoulduseherintui tiontofocustheB ALLERINAtool.
Ourevaluationaddresses thesethreeresearchques tions:
RQ1:Do tests generated by BALLERINAﬁnd more bugs
and/orﬁndbugsfasterth antestsgeneratedbybas icrandom
generation?Abasicrand omtesthasTthreads,eachexecut-
ingMmethods under test; it is not obvious whichT×M
conﬁgurationworkstheb est,soweevaluatesix:2×1,2×2,
2×3,3×1,3×2,and3×3.Forbasicrandom,the sequential
preﬁx randomly chooses a constructor (and its p arameter
objects)fortheOUT,wh ileBALLERINAalsohasuptothree
methodcallsontheOUT; bothpotentiallyhavemor emethod
callsfortheotherobject susedasparameters.
RQ2:Does the speedup provi ded by BALLERINAvary for
different exploration app roaches? We consider CH ESS-like
preemptionbounding[3] ,exhaustivestatefulsear chusedin
JPF[6],statelesssearch[ 21],andparallelizedtest execution.
Thereasonforconsideri ngmultipleexplorationa pproaches
isthatthereisnoestabli shedbestapproach.
RQ3:Doesourclusteringtech niquereducetheefforto fin-
spectingviolationsreport edbyexplorationoftests generated
by BALLERINAandbasicrandomgenera tion?
To compare the explora tion cost of tests, we u se the
number of transitions ex ecuted by stateful JPF w hile ex-
ploring the state space a nd the number of execu tion paths
for the stateless explorat ion based on re-executio n. This is
consistent with previous studies on exploration c osts [17],
[34], [35]. We do not u se the actual real time from JPF
because we conducted the experiments on a c omputing
clusterthathasmachines withdifferenthardware. Notethat
we compare cost toexplore not to generatetests, because
generationcostisaboutt hesameforvarioustechn iquesand
oftenmuchsmallerthan explorationcost.
Both BALLERINAandbasicrandomgenera tetestsusing
randomselection.Toche ckhowtheresultsvaryfo rdifferent
random seeds, we eval uate both B ALLERINAand basic
randomusing200seeds.
A. Answering RQ1
Figure 5 shows the cos t that CHESS-like preem ption-
bounded exploration [3] incurs to ﬁnd a true bug for tests
generated by B ALLERINAand basic random. For e ach bug
we show seven box plot s, one for B ALLERINA(BLR) and
sixforconﬁgurationsof basicrandomgeneration. Eachbox
plot shows ﬁve values th at summarize the explor ation cost
over 200 random seeds: median, upper and lowe r quartile
values,andthemaxandm invaluesnotoutsidethe 1.5inter-
quartile range. All the va lues are normalized to 1 .0 for theApplication BugIDIssueIDTotalLOC ClassUnderTest(CUT) CUTLOC #Methods Error
Groovy #1189054,872MemoryAwareConcurren tReadMap 315 5Deadlock
JDK #2 [33] 335StringBuffer 335 9Deadlock
JDK #34779253 2,555Logger 523 11Exception
JDK #46487638 2,550Logger 527 9Deadlock
JFreeChart #5806667 65,027NumberAxis 1,059 7Exception
Log4j #6 50910,273FileAppender 185 13Exception
Log4j #7150710,770Category 387 9Exception
Log4j #82622420,098AsyncAppender 171 12Deadlock
Log4j #93813715,875AsyncAppender 161 12Deadlock
Log4j #105178321,033WriterAppender 171 12Exception
Lucene #11 135857,347PhraseQuery 184 7Deadlock
Pool #12 14612,615GenericKeyedObjectPool 1,049 10Deadlock
Pool #13 14911,337GenericObjectPool 782 9Deadlock
Pool #14 18411,880GenericObjectPool 737 9Starvation
Figure4. Basicstatistic saboutthetestedcodea ndbugs.IssueIDisfrom therespectivebugdataba se.
BALLERINAmedian for the respectiv e bug. For example,
for Pool#14 (a new bug we found in Pool), the m edian of
2×2 is about 5, which me ans it is about 5Xslower(not
faster)thanthemedianofBL R.Notethatsomevalue sare
out of bound, in which case we showthe smallestof the
ﬁve values that is out of bound. For example, for Pool#14
and 2×2, the next value that is missing is upper quartil e
(and it is 16). In some c ases a technique does no t ﬁnd the
bug, which is marked w ith ’not found’ (but we still show
the exploration cost for the generated tests). For example,
forPool#14,thetestsgen eratedby2×1donotﬁndthebug.
The tests generated by 2×1 miss eleven out 14 b ugs,
while tests generated by 3×1 miss ﬁve out of 14 bugs.
In contrast, B ALLERINAand all other conﬁgurati ons miss
only one out of 14 bu gs (JDK#4). Triggering this bug
requires that the object state has a special strin g format
that is unlikely to be c reated by any random g eneration.
More speciﬁcally, trigg ering the bug requires a call to
thereadConfiguration(I nputStream ins)method;the
insparameter can come fro m a string, but it needs to be
inthejava.util.Propertie sformat,asspeciﬁedbyt he
readConfigurationdocumentation.Thus,us ingarandom
string like"Hi!"does not sufﬁce, and R andoop does not
randomlygeneratestring slike"x.level=FINE".
Tests generated byB ALLERINAcan ﬁnd more bugs
thantestsgeneratedbys implebasicrandomconﬁ gura-
tions (2×1 and 3×1).
Wenextturntocomparin gthecostsforthebasicr andom
conﬁgurations that ﬁnd the same bugs as B ALLERINA.
Figure5showsthedistri butionofcostsoverrand omseeds.
We can see that the co st for BALLERINAis often lower
thanthecostforbasicran dom,althoughtherearei ndividual
scenarios when basic ra ndom is faster than B ALLERINA,
e.g., for Pool#14, the m in whisker of 2×2 is close to 0,
whereas the max whiske r of BALLERINAis close to 4. To
summarize the comparis on into one number, we compute
thearithmeticmeancostacrossrandomseed s(whereasbox
plotsshowmedianvalues).Figure 6 shows the mea n exploration cost for a ll bugs
and compared conﬁgura tions. For now we discu ss the left
halfofthetable,forCHE SS-likepreemptionboun ding.We
tabulate the mean numbe r of transitions that expl oration of
tests generated by B ALLERINAtake to ﬁnd the bug, an d
theslowdownofbasicra ndomconﬁgurations(com putedas
the ratio of their mean over the mean for B ALLERINA).
Thelastrowshowsthea verageslowdown,compu tedasthe
geometricmean.Thecellsmarkedwith‘ n/f’representcases
whenaconﬁgurationdoe snotﬁndabug.
For the basic random te sts with two threads, th e con-
ﬁguration that ﬁnds the bugs fastest on average is 2×3,
andnot2×2 as one might expect. T he reason is that 2×3
executes six methods pe r test, whereas 2×2 executes only
four, and while explorat ion of a given 2×2 test is faster
than a given 2×3 test, 2×3 has a higher chance of ﬁnding
a bug. The individual slowdown of these con ﬁgurations
over BALLERINAranges from 1.3X (for J DK#2 and 2×2)
to 11.1X (for JDK#3 an d 2×2). For two cases, Groo vy#1
and Log4j#6, 2×2 and 2×3 even ﬁnd a bug faster than or
as fast as B ALLERINA(and their speedup is re ﬂected as
“slowdowns”oflessthan orequalto1.0).Triggeri ngthese
bugsdoesnotrequirecom plexobjectstate,justpara llelcalls
tothebuggypairofmeth ods.Infact,thesearetwo bugsthat
even2×1canﬁnd,becausethey aresosimpletotrigger.
Thebasicrandomtestsw iththreethreadsarequit eslow,
with average slowdown of over 8X compared to BALLE-
RINA.Consideringthelargec ostoftestswiththreeth reads
andtherecentstudy[16 ]whichfoundthatonly twoofthe
96real-worldconcurrenc ybugsinlargeC/C++ap plications
require at least three th reads to trigger, we be lieve that
focusing B ALLERINAon two threads is the rig ht trade-off.
Iftheprogrammerwants tolookforbugswiththre eormore
threads, she would ﬁrst run fast tests with two th reads and
onlylaterruntheslower testswiththreethreads.
TestsgeneratedbyB ALLERINAﬁndbugsfasterthan
tests generated by basic random conﬁgurations (w hich
ﬁnd the same bugs), on a verage 2.6X-10.4X. 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Groovy #1-9~-9~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
JDK #2-17~-16~-15~-9~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
JDK #3not
found-15~-13~-9~-19~-8~-14~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
JDK #4not
foundnot
found
not
foundnot
foundnot
foundnot
found-17~
not
found-40~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
JFreeChart #5not
found-72~-9~-10~-10~-17~-8~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Log4j #6-9~-12~-9~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Log4j #7not
found-53~-14~-10~-14~-14~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Log4j #8not
found-10~-13~-13~-12~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Log4j #9not
found-9~-12~
not
found-28~-13~-9~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Log4j #10not
found-12~-9~
not
found-89~-16~-11~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Lucene #11not
found-10~-13~
not
found-35~-17~-13~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Pool #12not
found-13~-11~-10~-10~-22~-12~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Pool #13not
found-9~
not
found-49~-19~-9~
 0 1 2 3 4 5 6 7 8
BLR 2x1 2x2 2 x3 3x1 3x2 3x 3
Pool #14not
found-16~-9~-13~-14~-14~Smallest of the five
 numbers below that
 exceeds the bound
MedianUpper quartile plus 1.5
 times Interquartile rang e
Lower quartile minus 1 .5
 times Interquartile rang eUpper quartile
Lower quartile~
Figure5. Numberoftr ansitionstotheﬁrstexec utionforagivenbugsce narioPreemption-boundedexp loration ExhaustiveJPFexplorati on
BugBLR SlowdownrelativetoBL R BLR SlowdownrelativetoBL R
(absolute) 2x12x22x33x13x23x3(absolute) 2x12x22x33x13x23x3
#113,3270.50.60.71.52.47.716,9120.50.40.52.43.05.3
#238,9324.11.31.94.03.65.249,1724.11.21.27.54.85.5
#3103,608 n/f11.12.432.04.53.8348,638 n/f20.65.8604.837.213.8
#4 n/fn/fn/fn/fn/fn/fn/f n/fn/fn/fn/fn/fn/fn/f
#525,024n/f4.32.923.87.99.436,7381.41.41.240.724.427.8
#6 6,8450.90.91.02.33.47.98,2110.90.70.83.74.07.4
#714,196n/f3.11.89.67.022.418,263n/f12.517.1147.9482.0357.9
#8239,650 n/f3.32.112.07.47.3335,982 n/f3.52.536.530.232.1
#9104,174 n/f4.53.1n/f14.027.06,558,767 n/f3.51.3n/f4.62.2
#1055,920n/f4.71.6n/f3.73.15,067,672 n/f1.80.8n/f0.90.2
#11 4,958n/f6.110.8n/f35.628.77,516n/f8.016.5n/f224.8191.0
#124,267,926 n/f2.64.319.219.410.758,918,609 n/f7.15.47.94.13.3
#132,348,863 n/f3.35.0n/f44.724.2 n/fn/fn/fn/fn/fn/f11.6
#141,331,407 n/f4.04.611.77.414.233,720,545 n/f10.910.411.95.57.5
SLOW 1.23.02.68.78.110.4 1.23.32.621.212.610.7
Figure6. Statefulexplo ration:meannumberof transitionstothebugsce nario.Thelastrowshow sthegeometric meanofslowdowns.
NumberofPaths NumberofTransitions
BugBLR SlowdownrelativetoBL R BLR SlowdownrelativetoBL R
(absolute) 2x12x22x33x13x23x3(absolute) 2x12x22x33x13x23x3
#1 17,6830.50.50.54.14.74.4712,7570.40.71.05.510.813.9
#2 36,3464.31.31.813.39.36.8988,0355.02.03.425.422.220.3
#3144,314 n/f12.42.083.07.54.88,407,268 n/f21.43.6159.016.313.2
#5 18,842n/f3.31.929.37.15.5833,586 n/f4.83.640.314.515.1
#6 7,8870.60.60.53.94.54.8315,6810.30.50.63.66.910.4
#7 10,890n/f1.90.716.34.93.7280,129 n/f2.71.324.410.910.8
#8232,071 n/f3.82.425.316.215.29,067,584 n/f5.84.641.537.245.6
#9100,436 n/f3.01.7n/f15.720.28,084,777 n/f1.51.7n/f13.728.0
#10 34,950n/f4.81.4n/f6.23.13,624,957 n/f1.91.1n/f4.43.3
#11 3,338n/f4.86.5n/f30.18.582,109n/f6.711.7n/f65.723.3
#132,072,099 n/f0.91.0n/f7.73.6376,786,069 n/f0.61.1n/f7.95.5
#141,419,535 n/f1.01.12.51.31.9247,317,819 n/f0.71.01.31.32.4
SLOW 1.12.11.412.37.35.5 0.92.12.015.911.711.9
Figure7. Statelessexp loration:meanexploratio ncosttothebugscenari o.Thelastrowshowsth egeometric meanofslowdowns.
B. Answering RQ2
We now look at how s table the B ALLERINAspeedups
are over basic random fo r various types of explor ation. So
far we have considered CHESS-like, preemption -bounded
exploration [3]. We con sider three additional se ttings: ex-
haustivestatefulsearchw ithpartial-orderreduction usedby
default in JPF [6], state less search [21], and pa rallelized
testexecutionwherethe testsareexecutedonsev eralcores
at once. We chose these settings as they are repre sentative
of what currently availa ble tools like JPF or C HESS do.
For parallelized test exe cution, we simulate wha t happens
with four and eight cor es, because these are th e typical
conﬁgurationsforthecu rrentInteli7processors. Forspace
reasons,weshowonlyth emeanvalues,notfullboxplot s.
Figure6showstheresult sforCHESS-likeandexh austive
JPFexplorations.Wehav ediscussedtheresultsfo rCHESS-
likeexploration.Theres ultsforexhaustiveJPF e xploration
are similar. The absolute number of transitions re quired to
ﬁnd the bug is higher than for CHESS-like ex ploration,
but BALLERINAstillmaintainsitsrelative speedupoverall
basic random conﬁgurati ons. The average speedu p is even
somewhat larger (e.g., 3 .3X vs. 3.0X for 2×2). Note thatthe Pool#13 bug is fou nd by preemption-bound ed explo-
ration but not by exhau stive JPF exploration. T his is due
to the interaction of JP F’s partial-order reducti on (POR)
andlinearizabilitychecki ng.BecauseJPF’sPORc ouldalso
affecttheCHESS-likeex ploration,weturnoffPO Rforthis
exploration;turningPOR offfortheexhaustiveex ploration
would result in excessive ly high JPF runtime. We reported
this behavior to JPF de velopers, and to the be st of our
knowledge,itdidnotaff ectanyotherexperiment .
Figure7showstheresul tsforstatelessexploratio nbased
on re-execution. While J PF checkpoints and resto res states
to explore thread interle avings, stateless case co nsiders an
explorationthatwouldre -executethetesttoexplo revarious
thread interleavings, e.g ., CHESS [3] or ReEx [35] tools
do so. The left half of the table shows the ex ploration
cost as the number of p aths that the tool would need to
executeforvarioustests toﬁndthebug,whilethe righthalf
shows the exploration co st as the number of tran sitions on
thesepaths.Thesemeasu resarecommonlyusedto compare
stateless techniques [35] . Again, exploring tests generated
by BALLERINAis faster than exploring tests generated by
basic random, but the av erage speedup is smaller than for
statefulexplorations.Not ethatstatelessexploratio nbyitselfBugBLR(rel.to1-Core)Bug4-Core(Slowdownrelati vetoBLR4-Core) 8-Core(Slowdownrelati vetoBLR8-Core)
4-Core8-Core 2x12x22x33x13x23x32x12x22x33x13x23x3
#1 3.9 8.7#10.50.61.01.33.112.80.70.91.61.45.418.8
#2 3.7 7.6#23.81.31.74.03.95.23.51.32.14.14.34.9
#3 4.1 8.3#3n/f11.32.230.55.23.8n/f11.02.132.14.03.6
#5 4.0 8.2#5n/f3.93.222.87.510.0n/f4.13.222.87.315.9
#6 4.0 7.6#60.91.21.62.34.514.91.01.32.12.06.421.6
#7 4.5 9.7#7n/f3.02.311.97.138.0n/f3.42.613.28.154.8
#8 4.0 7.8#8n/f3.52.011.07.17.3n/f2.62.111.46.67.0
#9 4.6 9.5#9n/f5.53.8n/f16.331.2n/f5.44.3n/f16.733.2
#10 8.326.5#10n/f9.32.7n/f5.78.3n/f15.35.1n/f8.219.2
#11 4.1 7.0#11n/f6.511.7n/f39.538.4n/f5.712.1n/f38.535.5
#12 5.110.3#12n/f3.84.826.921.512.7n/f3.84.228.221.210.7
#13 3.7 7.9#13n/f3.14.6n/f43.622.7n/f3.25.0n/f45.920.1
#14 4.810.8#14n/f5.06.014.37.112.7n/f5.46.414.76.69.7
SPEED 4.4 9.3SLOW 1.23.43.09.19.013.2 1.33.63.49.39.815.0
Figure8. Parallelizedt estexecution:meanexpl orationcosttothebugs cenario.
BugBLR 2x2 2x3 3x2
fa/tb#C#IRno-Cfa/tb#C#IRno-Cfa/tb#C#IRno-Cfa/tb#C#IRno-C
(abs)(rel) (abs)(rel) (abs)(rel) (abs)(rel)
#13633.312.32033.07.72533.09.435172.811.7
#26721.344.92541.216.128134.66.652283.513.4
#3011.01.0011.01.0144101.861.5175294.239.7
#5011.01.0021.01.0021.01.0061.01.0
#6021.01.00.1771.40.8191.61.01192.50.7
#7011.01.0021.01.0021.01.0061.01.0
#85041.337.37783.221.794319.38.43417315.623.6
#911654.914.88532.717.88067.67.05381711.645.6
#10021.01.0021.01.0041.01.0091.01.0
#11011.01.0011.01.0621.92.5021.01.0
#12011.01.028975.447.96301514.848.89355020.751.8
#1311332.634.331877.019.58941427.324.75,8303916.2244.0
#144733.115.012285.515.12411226.47.32883816.116.4
SLOW 4.0 4.7 5.4 8.2
Figure9. Ratiooffalse alarmsandtruebugs,# ofclusters,#ofreportsi nspectedwithclustering, improvementovernoclu stering.
isslowerthanstatefulfor ourexperiments,andPoo l#12does
notevenﬁnishinareaso nabletimeforstateless.
Figure 8 shows the resu lts for exploring the ge nerated
tests in parallel, on four and eight cores. Note th at we do
not parallelize exploratio n of one test at a timebut rather
exploreinparallelsevera ltestsatonce.Eachtestisexplored
withaCHESS-likepreem ptionboundingasinFigu re5.The
ﬁrstpartofthetableshow sthespeedupthatthispa rallelized
testexecutionachieveso verexecutionononecor efortests
generated by B ALLERINA. The average speedup i s super-
linear (4.4X on 4 cores and 9.3X on eight cores ). This is
notsurprisingforsearch problems[36],becauset hesearch
ﬁnishesassoonasoneco reﬁndsthebug.Theseco ndpartof
thetableshowstheslowd ownofthetestsgenerated bybasic
random compared to th e tests generated by B ALLERINA,
when run onthe same number of c ores. Comparing the
average slowdown to th e case for one core (F igure 6),
we ﬁnd that B ALLERINAperforms even better tha n basic
random when test execu tion is parallelized (e.g. , for 2×3
theslowdownis2.6Xon onecore,3.0Xonfourc ores,and
3.4X on eight cores). T his is important as the a vailability
of multi-core processors means that test executio ns in the
futurearelikelytobepa rallelized.TestsgeneratedbyB ALLERINAﬁndbugsfasterthan
tests generated by basic random conﬁgurations f or a
variety of different explo ration approaches.
C. Answering RQ3
Since reports of lineari zability violations can b e false
alarmsortruebugs,deve lopersneedtoinspectan umberof
reports before ﬁnding a true bug. Figure 9 show s how our
clustering helps with red ucing the number of ins pections.
For each bug and seve ral test generation conﬁ gurations
(the results are similar f or the conﬁgurations no t shown),
we tabulate the ratio of false alarms to true bug s before
clustering (’fa/tb’), the number of clusters that our tech-
nique computes, the exp ected number of inspect ions with
clustering (computed as the arithmetic mean of 5 0 random
orderingsofreports),and theratiooftheexpectedn umberof
inspectionswithoutclustering over the expe cted number of
inspectionswithclustering.Effectively,th elatterratioshows
the beneﬁt that our clus tering provides over the base case
with no clustering, and the last row shows thegeometric
meanaverageofthisbeneﬁt.The improvement range s from 1.0 (when there are no
falsealarmsandhenceth enumberofinspections isexactly
one both with and with out clustering) up to 24 4.0X (for
Pool#13and3×2).Notethatthenumber ofinspectionswith
clustering is never wors e than the number of in spections
withoutclusteringfortes tsgeneratedby B ALLERINA.
Our clustering technique reduces the number of i n-
spectedreportsfortestsg eneratedbybothB ALLERINA
and basic random gener ation, on average 4X-8X .
D. Threats to Validity
Internal threats:We conducted our exp eriments with
the default settings of J PF (version 6.0). As ex plained in
Section V-B, we encoun tered an incompatibility of JPF’s
POR and linearizability checking for Pool#13, b ut to the
bestofourknowledge,it didnotaffectanyotherex periment.
However,changingother JPFsettingscouldaffect theresults
thatweobtained.
External threats:The code under test and bugsthat we
use are from a variety of sources and diverse in terms
of the statistics shown in Figure 4. However, w e cannot
guaranteethattheyform arepresentativesampleo fbugsin
multithreadedJavacode. Tomitigatethelimitation ofusing
one particular exploratio n, we evaluated B ALLERINAwith
fourdifferentexploration s.
Construct threats:Wemeasureexploration costwiththe
numberoftransitions(an dpathsforre-execution) insteadof
real time. This is commo n in previous related stu dies [17],
[34]. We measure inspe ction effort with the n umber of
reports which is a proxy for human time. This is common
inpreviousrelatedstudie s[24],[27].
Conclusion threats:The number of random seeds (200
for generation and 50 fo r clustering) that we use d may not
be sufﬁcient to accurate ly characterize real distr ibution of
theserandomprocesses.
VI. RELATED WORK
There is a rich body of work on random test gen eration
forsequentialcode[14],[37],[38],includin gcombinations
withstaticanalysis[15], [39],symbolicexecution [40],and
search-based techniques [13], [41], [42]. Our B ALLERINA
technique utilizes Rando op [14] and modiﬁes it to more
densely cover states of o bjects for the given CUT . Related
to this, techniques based on adaptive random testi ng [43]–
[45] use various measur es for object distance to generate
more divergent test inpu ts. However, unlike thos e projects,
BALLERINAgeneratestestsformultithreaded code.
For ﬁnding bug-triggerin ginterleavingsin multithreaded
code, numerous techniqu es have been proposed, including
static[46]anddynamica pproaches[47],andtheir combina-
tion[33],[48].Randomiz edthreadschedulingand statistical
faultlocalizationhaveals oshownpromiseintestin gparallelcode [17]–[20]. Howeve r, all those techniques as sume that
thetestcodeisprovided andonlyexploreprovidedtests.In
contrast,B ALLERINAautomaticallygeneratesmultithreaded
teststhatcanexposebugs.B ALLERINAalsoemployssearch
forlinearizabilityviolatio ns,inspiredbyLine-Up [2].
Environmentgeneration formultithreadedcodeis related
to generation of test c ode. For example, Tka chuk and
Rajan [49], [50] automat ically generate driver an d stub for
the system under test ba sed on formal speciﬁcati on of the
system properties. B ALLERINAdoes not require the us er
to explicitly provide form al speciﬁcations but uses random
testingtogeneratedriver codeanduseslinearizabi lityasan
implicitspeciﬁcationfor theCUT.B ALLERINAalsoclusters
failurestoreducethenum berofinspectionsoffals ealarms.
Researchers have propos ed different techniques f or clus-
tering failing runs. Mos t previous work cluster s failures
basedonexecutionproﬁlesfrommonitoredruns.Po dgurski
etal.usefeatureselectio ntotrainclustersbased onexecu-
tion proﬁles, which are u sed to group similar fail ures [24],
[27].Jonesetal.combine fault-localizationinforma tionwith
proﬁles to cluster failing tests [25]. Yoo et al. inc orporate
human expert knowledg e into clustering [28]. Zheng et
al. use statistical metho ds to ﬁnd super-bug pre dictors in
multiple faults setting [ 29]. Different from the previous
work,ourclusteringtech niquefocusesongroupin gfailures
ofmultithreaded testsbased on the methods executing in
parallelandthetypeoff ailure.
VII. CONCLUSIONS
Testing multithreaded co de is becoming more im portant
but remains challenging and costly. Automated te sting can
help to reduce the cos ts, but most research f ocuses on
automated exploration of thread interleavings for m anually
written test code. We ha ve presented B ALLERINA, a novel
technique that automates generation of multithrea ded unit
testcode.Wehavealsop resentedatechniquefor clustering
failuresofautomatically generatedmultithreaded tests.The
experimentswith14bugs showthatB ALLERINAcantrigger
bugssubstantiallyfaster thanbasicrandomgener ation,and
that our clustering can greatly reduce the numb er of test
failures that need to be inspected to ﬁnd a true bug. Our
experimentsexposedthre epreviouslyunknownbu gs,twoof
whichwerealreadyﬁxed .Whilerandomgeneratio nshowed
promising results, it wo uld be useful to conside r a more
guidedsearchfortestge neration.
ACKNOWLEDGMENT S
WethankVilasJagannath forextensivediscussions about
this work. This materi al is based upon work partially
supported by the US N ational Science Foundat ion under
Grant Nos. CCF-101275 9, CNS-0958199, CCF- 0916893,
and CCF-0746856, by I ntel under the Illinois-In tel Paral-
lelism Center (I2PC), an d by the Swiss Nationa l Science
Foundationundergrantn umber200021-134453.REFERENCES
[1] T. Ball, S. Burckha rdt, K. E. Coons, M. M usuvathi, and
S. Qadeer, “Preemption sealing for efﬁcient co ncurrency
testing,”inTACAS,2010.
[2] S.Burckhardt,C.De rn,M.Musuvathi,andR. Tan,“Line-Up:
A complete and automat ic linearizability checker ,” inPLDI,
2010.
[3] M.MusuvathiandS .Qadeer,“Iterativeconte xtboundingfor
systematictestingofmul tithreadedprograms,”inPLDI,2007.
[4] S. Park, S. Lu, and Y. Zhou, “CTrigger: Exp osing atomicity
violationbugsfromtheir hidingplaces,”inASPLOS,2009.
[5] S. Park, Y. Zhou, W . Xiong, Z. Yin, R. Ka ushik, K. H.
Lee, and S. Lu, “PRES: Probabilistic replay with execution
sketchingonmultiproces sors,”inSOSP,2009.
[6] W. Visser, K. Hav elund, G. Brat, and S. Park, “Model
checkingprograms,”ASEJ,2003.
[7] J. Burnim, T. Elmas , G. C. Necula, and K. Sen, “NDSeq:
Runtime checking for no ndeterministic sequential speciﬁca-
tionsofparallelcorrectn ess,”inPLDI,2011.
[8] J. Burnim, G. C. Necula, and K. Sen, “ Specifying and
checkingsemanticatomi cityformultithreadedpr ograms,”in
ASPLOS,2011.
[9] J.BurnimandK.Se n,“Assertingandchecki ngdeterminism
formultithreadedprogra ms,”inESEC/FSE,2009.
[10] ——, “DETERMIN : Inferring likely determi nistic speciﬁca-
tionsofmultithreadedpr ograms,”inICSE,2010.
[11] S. Lu, J. Tucek, F . Qin, and Y. Zhou, “A VIO: Detecting
atomicity violations via access interleaving inva riants,” in
ASPLOS,2006.
[12] D.Marino,M.Mus uvathi,andS.Narayanas amy,“LiteRace:
Effective sampling for lightweight data-race de tection,” in
PLDI,2009.
[13] L.Baresi,P.L.Lan zi,andM.Miraz,“TestF ul:Anevolution-
arytestapproachforJav a,”inICST,2010.
[14] C.Pacheco,S.K.L ahiri,M.D.Ernst,andT. Ball,“Feedback-
directedrandomtestgen eration,”inICSE,2007.
[15] S.Zhang,D.Saff,Y .Bu,andM.D.Ernst,“C ombinedstatic
anddynamicautomated testgeneration,”inISSTA,2011.
[16] S. Lu, S. Park, E. Seo, and Y. Zhou, “Lea rning from mis-
takes:Acomprehensives tudyonrealworldconcu rrencybug
characteristics,”inASPLOS,2008.
[17] M. B. Dwyer, S. G . Elbaum, S. Person, an d R. Purandare,
“Parallelrandomizedsta te-spacesearch,”inICSE,2007.
[18] O. Edelstein, E. F archi, Y. Nir, G. Ratsa by, and S. Ur,
“Multithreaded Java prog ram test generation,”IBM Systems
Journal,2002.
[19] K. Sen, “Race dire cted random testing of concurrent pro-
grams,”inPLDI,2008.
[20] ——, “Effective ra ndom testing of concurre nt programs,” in
ASE,2007.
[21] M.MusuvathiandS .Qadeer,“Fairstatelessm odelchecking,”
inPLDI,2008.
[22] M. Herlihy and J. M. Wing, “Linearizabilit y: A correctness
conditionforconcurrent objects,”ACM TOPLAS,1990.
[23] S. Narayanasamy, Z. Wang, J. Tigani, A . Edwards, and
B.Calder,“Automatically classifyingbenignandha rmfuldata
racesusingreplayanalys is,”inPLDI,2007.
[24] W.Dickinson,D.L eon,andA.Podgurski,“ Findingfailures
byclusteranalysisofex ecutionproﬁles,”inICSE,2001.[25] J.A.Jones,M.J.H arrold,andJ.F.Bowring ,“Debuggingin
parallel,”inISSTA,2007.
[26] C.Liu,X.Zhang,a ndJ.Han,“Asystematic studyoffailure
proximity,”IEEE TSE,2008.
[27] A. Podgurski, D. Leon, P. Francis, W. M asri, M. Minch,
J. Sun, and B. Wang, “ Automated support for classifying
softwarefailurereports,” inICSE,2003.
[28] S. Yoo, M. Harma n, P. Tonella, and A. S usi, “Clustering
test cases to achieve e ffective and scalable p rioritisation
incorporatingexpertkno wledge,”inISSTA,2009.
[29] A.X.Zheng,M.I. Jordan,B.Liblit,M.Nai k,andA.Aiken,
“Statisticaldebugging:si multaneousidentiﬁcation ofmultiple
bugs,”inICML,2006.
[30] Apache Software Foundation, “POOL-184 ,” https://issues.
apache.org/jira/browse/PO OL-184.
[31] ——, “POOL-18 9,” https://issues.apach e.org/jira/browse/
POOL-189.
[32] ——, “LOG4J-51 783,” https://issues.apa che.org/bugzilla/
showbug.cgi?id=51783.
[33] F.Chen,T.F.S ¸erb ˘anut¸˘a,andG.Ros¸u,“jPredict or:Apredic-
tiveruntimeanalysistoo lforJava,”inICSE,2008.
[34] M.B.Dwyer,S.Pe rson,andS.G.Elbaum, “Controllingfac-
tors in evaluating path-s ensitive error detection t echniques,”
inFSE,2006.
[35] V. Jagannath, Q. L uo, and D. Marinov, “Ch ange-aware pre-
emptionprioritization,”i nISSTA,2011.
[36] V. N. Rao and V. Kumar, “Superlinear spe edup in parallel
state-spacesearch,”inFOSTTCS,1988.
[37] C. Csallner and Y. Smaragdakis, “DSD-Cra sher: A hybrid
analysistoolforbugﬁnd ing,”inISSTA,2006.
[38] H.Jaygarl,S.Kim, T.Xie,andC.K.Chang, “OCAT:Object
capture-basedautomated testing,”inISSTA,2010.
[39] S. Thummalapenta, T. Xie, N. Tillmann, J. d e Halleux, and
Z. Su, “Synthesizing m ethod sequences for hig h-coverage
testing,”inOOPSLA,2011.
[40] P. Godefroid, N. K larlund, and K. Sen, “D ART: Directed
automatedrandomtestin g,”inPLDI,2005.
[41] J. H. Andrews, T . Menzies, and F. C. H. Li, “Genetic
algorithmsforrandomize dunittesting,”IEEE TSE,2011.
[42] Z. Xu, Y. Kim, M . Kim, G. Rothermel, an d M. B. Cohen,
“Directedtestsuiteaugm entation:Techniquesand tradeoffs,”
inFSE,2010.
[43] T.Y.Chen,F.-C.Ku o,R.G.Merkel,andT.H .Tse,“Adaptive
randomtesting:TheART oftestcasediversity,”JSS,2010.
[44] I. Ciupa, A. Leitn er, M. Oriol, and B. M eyer, “ARTOO:
Adaptive random testin g for object-oriented so ftware,” in
ICSE,2008.
[45] Y.Lin,X.Tang,Y. Chen,andJ.Zhao,“Adiv ergence-oriented
approach to adaptive ran dom testing of Java pro grams,” in
ASE,2009.
[46] M. Naik, A. Aike n, and J. Whaley, “Effe ctive static race
detectionforJava,”inPLDI,2006.
[47] C. Flanagan and S . N. Freund, “FastTrack : Efﬁcient and
precisedynamicracedet ection,”inPLDI,2009.
[48] R. O’Callahan and J.-D. Choi, “Hybrid dyn amic data race
detection,”inPPoPP,2003.
[49] O. Tkachuk and S . P. Rajan, “Application of automated
environment generation to commercial software,” inISSTA,
2006.
[50] ——, “Combining environment generation and slicing for
modularsoftwaremodel checking,”inASE,2007.