Compiling Mockups to Flexible UIs
Nishant Sinha
IBM Research, India
nishant.sinha@in.ibm.comRezwana Karim
Rutgers University, USA
rkarim@cs.rutgers.edu
Abstract
As the web becomes ubiquitous, developers are obliged to develop
web applications for a variety of desktop and mobile platforms. Re-
designing the user interface for every such platform is clearly cum-
bersome. We propose a new framework based on model-based com-
pilation to assist the designer in solving this problem. Starting from
an under-speciÔ¨Åed visual design mockup drawn by the designer, we
show how faithful and Ô¨Çexible web pages can be obtained with vir-
tually no manual effort. Our framework, in sharp contrast to exist-
ing web design tools, overcomes the tough challenges involved in
mockup compilation by (a) employing combinatorial search to infer
hierarchical layouts and (b) mechanizing adhoc principles for CSS
design into a modular, extensible rule-based architecture. We be-
lieve ours is the Ô¨Årst disciplined effort to solve the problem and will
inspire rapid, low-effort web design.
Categories and Subject Descriptors D.2.2 [ Design Tools and
Techniques ]: User Interfaces, CASE
General Terms: Algorithms, Design.
Keywords: Layout inference, Mockup-based design, HTML, CSS.
1. Introduction
Web user interface (UI) design is a fundamental part of web appli-
cation design [42, 43]. The UI quality often directly inÔ¨Çuences the
adoption of the application and therefore designers spend signiÔ¨Åcant
effort in getting the user interface right. An important component
of UI design is static design, involving selection of elements, their
layout and styling (coloring, typography) for a particular web page
view. Static web design requires a deep understanding of interac-
tion between (a) page structure deÔ¨Ånition in HTML [8] and (b) the
layout/style modeling in CSS [3, 5, 37]. Both of these are low-level
technologies and CSS, in particular, has a steep learning curve. This
makes HTML/CSS authoring extremely labor-intensive and time-
consuming [27, 30, 32]. In particular, CSS styling largely remains
an art [3, 30, 37]: CSS does not include constructs for specifying
complex layouts directly; designers must carefully work around var-
ious CSS features manually to obtain desirable layouts for differ-
ent platforms. Consequently, web design often involves two people
working closely [28, 43]: a web designer, who uses a graphic editor,
e.g., Adobe Photoshop, to design the look in a drag-drop fashion,
and a developer, who encodes the design based on her HTML/CSS
expertise. This partnership is often unproductive due to the strong
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior speciÔ¨Åc permission and/or a fee.
ESEC/FSE ‚Äô13, August 1826, 2013, Saint Petersburg, Russia
Copyright c2013 ACM 978-1-4503-2237-9/13/08. . . $10.00coupling and feedback delays: minor changes by the either party
may cause signiÔ¨Åcant grievances for the other.
With the web becoming ubiquitous [4] on mobile devices with
multiple form factors, the problem has become worse. Applications
must be designed for multiple devices simultaneously and adapt
to rapidly evolving technology besides having a shorter time-to-
market. Moreover, we observe an increasing involvement of non-
expert developers in the new echo-system, who are barely skilled in
HTML/CSS. The prevalent partnership model hardly scales to the
increased development demand. In fact, we now need tools which
shield the developers from the low-level technologies and minimize
distractions, thus enabling low-effort, rapid web development.
Mockup-based design [42, 43] offers an appealing solution to
rectify the current dismal state of affairs. A mockup (also called
awireframe ) is a rough visual depiction of the desired design,
drawn in a software tool (called a WYSIWYG editor) and reÔ¨Çects
the designer‚Äôs intention visually. A designer can draw mockups
easily in an editor by using drag-drop operations on UI widgets
from a palette collection and apply menu-based style selections.
Mockups are essentially technology-independent: a designer only
needs a superÔ¨Åcial understanding of the underlying technology to
draw mockups. Further, a single mockup may be used to obtain
different implementations for multiple devices via device-speciÔ¨Åc
compilation. Finally, these designs are reusable even as the web
technologies evolve. Clearly, mockup-based design is advantageous
in multiple ways.
To bring this vision to reality, several WYSIWYG editors have
been designed [28], e.g., Adobe Dreamweaver [1], Microsoft Ex-
pression Web [12], over the past decade. Although these editors as-
sist the designer with content authoring, it is widely accepted that
they have failed to inspire ubiquitous mockup-based development.
The key hurdle is that enormous, low-level manual effort and a deep
knowledge of HTML/CSS is required to work with these editors.
Moreover, the tool requires the designer to not only specify the UI
elements constituting the core design but also the precise layout for
those elements. This often leads to exposing the designer to underly-
ing low-level details of HTML/CSS, which was originally intended
to be kept under-the-hood. Moreover, in return for the extreme man-
ual effort, most editors generate Ô¨Åxed designs which cannot adapt
to browser viewport or device changes. Thus these tools generate
lot of user dissatisfaction and are deserted by unskilled designers.
More recent WYSIWYG tools restrict themselves to quick design
prototyping [2, 9, 11] and do not promise high-quality code transla-
tions. This brings up the natural question :
Why can‚Äôt they do better? How hard is compiling mockups?
Automatic high-quality compilation of mockups is indeed quite
non-trivial. There are two main challenges:
Challenge 1 (Infer Layout) A mockupMis a freely-drawn, under-
speciÔ¨Åed design schema over UI elements, where the page layout
is not explicit. A tool must mine and generalize from the latent
hierarchical structure in Mto extract the right layout forM, i.e.,
the local vertical/horizontal Ô¨Çow of the page content, which also
preserves the relative sizes and alignment of individual elements.Infer Layout L Encode Linto Mockup M
ofM HTML/CSSHTML/CSSFlexible
ViewFigure 1. Overview of the two-phase approach for encoding mock-
ups to Ô¨Çexible web pages.
This involves solving a non-trivial combinatorial search problem
over the set of possible layouts.
Challenge 2 (Encode in HTML/CSS) The second problem is how
to encode the inferred layout in an HTML page faithfully. This
requires a deep understanding of CSS semantics, which is complex
and has no support for encoding layouts directly. Moreover, to
generate superior encodings, the tool must incorporate the poorly
documented CSS design principles used by designers in practice.
Somewhat surprisingly, there exists no systematic framework
to address the above two challenges for web design. Researchers
have employed constraint solvers [22, 29, 38] to address the Ô¨Årst
challenge of Ô¨Ånding layouts and personalized interfaces [24, 25]
in context of standalone desktop-based applications. These efforts
assume that a dedicated rendering engine is used, which can readily
interpret the pixel value solutions provided by the solver. The web,
unfortunately, fails to meet this requirement.
Each off-the-shelf web browser embeds a complex rendering en-
gine [7, 18, 40], optimized over many years, which can primarily in-
terpret HTML/CSS/JavaScript commands. Modifying the layout en-
gine is therefore not advisable; instead, we would like to exploit the
existing engines to maximum. Using heavy JavaScript for layout is
undesirable, speciÔ¨Åcally for mobile devices. The problem therefore
becomes that of communicating layout information to the browser
efÔ¨Åciently in terms of HTML/CSS boxes . This, in turn, requires us to
express and search for layout in terms of a hierarchy of rectangular
boxes, and infer a hierarchy of container boxes for UI objects, as op-
posed to pixel values. Box-based layouts have been investigated for
text documents, e.g., LATEX [34], and grids [29, 38], both of which
are unsuitable (cf. Sec. 3) for laying out variable-sized boxes with
heterogeneous content as in a web application mockup.
Similarly, most WYSIWYG editors dodge the second challenge
and adopt the path of least resistance. This is not surprising because
encoding CSS rules automatically is quite challenging (cf. Sec. 5).
They use simpliÔ¨Åed encoding techniques, e.g., based on widely crit-
icized HTML tables [16], and often resort to a Ô¨Åxed layout, which
necessitates scrollbars and does not adapt to viewport or font re-
sizes. The low-quality encodings generated by these tools, however,
diminish the user experience and adoption signiÔ¨Åcantly [28].
In this paper, we present a systematic framework to obtain faith-
ful HTML/CSS designs from a mockup Mautomatically. Our en-
coding technique consists of two phases shown in Fig. 1. We Ô¨Årst
propose a new algorithm to infer an hierarchical layout LfromM
(Challenge 1) by recursively partitioning it into boxes which Ô¨Çow
left-to-right (HBoxes) or top-to-down (VBoxes). This recursive par-
titioning extracts the implicit hierarchical structure of M, besides
capturing the relative size and alignment of elements. To address
Challenge 2, we present a systematic modular architecture for en-
coding these layouts into HTML/CSS: each module consists of a set
of mathematical rules for step-wise encoding Linto HTML/CSS.
The proposed architecture is extensible and allows easy Ô¨Åne-tuning
of encoding rules. Further, along the lines of the original vision, we
show how to construct Ô¨Çexible designs from a single mockup, which
can adapt to multiple devices gracefully.
Fig. 2 shows the advantage of our Ô¨Çexible encoding over a Ô¨Åxed
encoding: note how the Ô¨Åxed layout (on the top) gets cropped as the
browser window re-sizes but the Ô¨Çuid layout (bottom) scales down
to the smaller viewport size, with an elastic text formatting. We eval-
uate the framework on mockup benchmarks which model several
common web UI design patterns and demonstrate high quality en-
codings of the original mockup in HTML/CSS automatically. We
Figure 2. Comparison of a Ô¨Åxed layout (top) and a Ô¨Çuid-elastic
layout (bottom) generated by our tool.
show that in absence of our method, generating these designs would
have required signiÔ¨Åcant manual effort.
Our main contributions are as follows. We present a systematic,
automatic framework to encode mockups into faithful HTML/CSS
designs with Ô¨Çexible layouts. The generated design may be viewed
in an off-the-shelf browser without modifying the browser or chang-
ing the prevalent web markup echosystem: we exploit the browser
layout engine to the largest extent possible to achieve high-quality
encoding. Our framework consists of a new technique to infer hi-
erarchical layouts from mockups based on combinatorial search,
together with a systematic, extensible set of rules to encode these
layouts. Extensibility enables Ô¨Åne-tuning designs as well as adapt-
ing encoding to technology evolution. Finally, our tool enables non-
experts to develop complex web page designs with low manual ef-
fort without exposing them to much of under-the-hood HTML/CSS
technologies. To tackle difÔ¨Åcult design scenarios for automated
heuristics, we enable the designer to interact with and guide the
tool towards desired encodings. We evaluated our method on a col-
lection of mockups modeling common web design patterns. Our re-
sults shows that automatic, high-quality, Ô¨Çexible mockup encoding
is indeed feasible using our tool, with hardly any user intervention.
The paper is structured as follows. Sec. 2 overviews HTML
and CSS semantics and Sec. 3 deÔ¨Ånes mockups and layouts for-
mally. Sec. 4 presents the hierarchical layout inference algorithm
and Sec. 5 presents the modular encoding rules into CSS. Sec. 6 dis-
cusses our tool infrastructure and evaluation results. Sec. 7 presents
the related work and Sec. 8 concludes.
2. A Brief Tour of HTML and CSS
HTML consists of a set of markup conventions to describe the struc-
ture of a web document in a device-independent manner using a set
oftags, e.g., title , headings h1,h2, etc., division div, paragraphs
p, lists ul, anchors a, inputs input , forms, and so on. The content of
the document is embedded in the HTML structure. The upcoming
HTML5 [8] standard also includes tags for specifying multimedia
content, e.g., audio ,video , etc. .paddingbordermargincontent
boxpadding
boxborder
box
marginB2 B1B2‚Äôs B1‚Äôs
inner outer
heightheightFigure 3. Anatomy of a CSS Block Box.
ACSS style sheet consists of a set of rules : each ruleris com-
posed of one or more selectors and a declaration. The declaration
consists of a set of property-value pairs. Properties and their values
determine the visual appearance, e.g., height, width, font, color,
margin, padding , of the elements in the browser. Selectors deter-
mine the HTML elements to which the properties apply to. They are
deÔ¨Åned using relations between HTML tags, e.g., div > p selects
all paragraph elements which are children of some div element.
The mutual alignment of the HTML elements, i.e., the layout , is
also speciÔ¨Åed using CSS (discussed later). The CSS standards [3, 5]
specify how properties may be inherited among the elements in a
page‚Äôs HTML structure and how rules are prioritized depending on
their order or speciÔ¨Åcity [3]. We will primarily focus on CSS2.1 [3]
in this paper because it is implemented by browsers to a reasonably
complete extent and is well-known among web designers.
Structure/Style Separation. CSS rules may be speciÔ¨Åed inline with
the HTML speciÔ¨Åcation, but such mixing of style and structure is
discouraged [3, 48]. To enhance modularity, CSS and HTML should
be speciÔ¨Åed separately. The coupling between CSS and HTML is
achieved by annotating HTML elements with label(s) correspond-
ing to CSS style object(s) which may affect their appearance (see
example below). This separation between HTML/CSS has multi-
ple advantages, e.g., the order of speciÔ¨Åcation of blocks in HTML
remains independent of their positioning in the actual page layout.
Moreover, blocks may be moved around in the hierarchy arbitrarily
without changing their style.
Box Model Semantics. The semantic structure of a web page con-
sists of a set of boxes: a box may be simple or compound (contain
other boxes). Boxes which start on a new line and have a line-break
after them are called block boxes (blocks, in short); otherwise, they
are called inline boxes. Block boxes take 100% width of their par-
ent unless speciÔ¨Åed; inline elements, e.g., span , only expand to con-
tain the content inside them. The boxes are speciÔ¨Åed using speciÔ¨Åc
HTML tags, e.g., the division ( div) HTML tag is commonly used to
specify a block box. The position and size of each box is given by a
set of attributes: top, left, height andwidth . Boxes also have other
style properties, e.g., border ,padding ,margin ,color ,font, etc. .
Margin, Padding, Border of Boxes. The margin property of a box
BspeciÔ¨Åes the distance of an adjacent box from the border of the B.
The padding property speciÔ¨Åes the distance between the border and
the box contents. Both margin and padding may be speciÔ¨Åed along
four directions, i.e., left, right, top and bottom. These attributes are
conveniently visualized using a 3-box Ô¨Ågure shown in Fig. 3. In
CSS2.1, the size (height/width) of a box refers to the actual size
of the content box (not the border box). Thus, the combination
of height, width, border, margin and padding for boxes must be
computed carefully during page design.
Example. Fig. 4 shows a HTML/CSS design. The HTML (top)
consists of a divelement is labeled with the identiÔ¨Åer ‚Äùcontent‚Äù and
contains a header element ( h1), a paragraph element ( p), and two
divelements containing text ‚Äúbox 1‚Äù and ‚Äúbox 2‚Äù respectively, both
of which are labeled with class mybox . The visual attributes of boxes
with labels content andmybox are speciÔ¨Åed in CSS separately on
right. The CSS rules say that the top-level divelement, referred to<div id="content">
<h1>Main Content</h1>
<p>Lorem ipsum etc..</p>
<div class="mybox">
box 1
</div>
<div class="mybox">
box 2
</div>
</div>#content {
padding: 10px;
margin: 0 100px;
}
.mybox {
height: 100px;
width: 100px;
}
Figure 4. Interaction of CSS styling with HTML.
by its CSS selector #content , has a padding of10px on all sides
and margin of 0pxon top and bottom, and of 100px on left and right.
The class mybox , denoted by selector .mybox , has two properties,
height and width, both of value 100px . The mybox class applies
to both ‚Äúbox 1‚Äù and ‚Äúbox 2‚Äù divs, making them of height/width
100px each. Fig. 4(a) shows how the above HTML/CSS is rendered
in the browser. All elements are laid out vertically in the normal
Ô¨Çow. Because there is no spacing between ‚Äúbox 1‚Äù and ‚Äúbox 2‚Äù,
they appear as a continuous block.
To improve the appearance of the design, we need to add margin
and padding for both ‚Äúbox 1‚Äù and ‚Äúbox 2‚Äù. We do this by adding
margin: 10px andpadding: 10px to the .mybox speciÔ¨Åcation,
which results in Fig. 4(b). Note how adding margins moves both the
boxes slightly south-east and separates them from each other. Also,
padding separates the text inside each .mybox from the box borders.
Now, suppose that we want the boxes to be arranged left-to-right in-
stead of top-to-down. For this, we add float: left to the .mybox
speciÔ¨Åcation (explained later). Fig. 4(c) shows the result. The Ô¨Ånal
.mybox speciÔ¨Åcation is
.myboxfheight: 100px; width: 100px; margin: 10px;
padding: 10px; float: left; g
Note how the separation between structure (HTML) and style
(CSS) is beneÔ¨Åcial: it enables us to obtain three different designs
by modifying only the CSS without changing the HTML structure.
Also, note that developing a simple web page where elements Ô¨Çow
both vertically and horizontally requires a somewhat deep under-
standing of CSS box semantics, e.g., Ô¨Çoats. The involved semantics
have led, in practice, to multiple ambiguous interpretations of their
behavior. Thus, modern CSS design is virtually an art form.
3. Preliminaries: Mockups, Layouts, HVBoxes
A mockup is a schema of the desired UI, based on representative UI
elements [2, 11], drawn in a WYSIWYG editor [1, 2, 11, 12] using
direct manipulation.
Mockups. Formally, a mockup Mis a collection of rectangular
objects ( boxes )m, each box having its visual properties, e.g., size,
border, color, etc. . An object mmay correspond to an HTML5 [8]
UI element, e.g., div, p, ul, label, input, img , or a widget
from a UI-library, e.g., [17]. Non-rectangular UI objects, e.g., text,
images, circular objects, are represented by their bounding boxes
inM. Let the setAcontain the common visual properties of
boxes, e.g., height, width, top, left for their size/position,font-size, border, background-color for their look, as well
as other CSS attributes. Also, the values for elements of set A
are stored in the set DA. Quantitative property values in Mare
speciÔ¨Åed in pixels orems [3]. Formally, each object mis a tuple
r= (id;), whereidis a string identiÔ¨Åer and :A ! D A
is a map from attribute names to their values. Instead of writing
(height ) = 10 px form, we simply write m.height = 10.
Intuitively, a mockup corresponds to a free-hand drawing of UI
elements on a canvas, e.g., that of a WYSIWYG editor, where the
page layout is not explicit. Given such a drawing D, our approach
extracts the absolute height, width and position attributes of the
bounding boxes in the editor, along with their style properties, to
obtain a mockupM. Textual content is extracted out from the Dand
added toM. Designer-speciÔ¨Åed container elements in the drawing
are captured as parent-child relationships between boxes in M. The
layout inference algorithm then uses Mtoguess the layout intended
by the designer.
Taxonomy of layouts. A layout refers to a particular arrangement
of UI elements on a page. Web designers use an informal nomencla-
ture to refer to common layout patterns. A Ô¨Åxed layout uses a Ô¨Åxed
unit of measurement (pixels, typically) for positions and sizes of el-
ements, independent of the browser viewport or the font size. Thus,
Ô¨Åxed layouts are completely static , and do not change across font,
resolution and viewport changes. While Ô¨Åxed layouts offer maxi-
mum consistency across multiple browsers, they are considered less
user-friendly, e.g., they may require scrollbars on smaller viewports.
Arelative layout uses a relative unit of measurement, e.g., a percent-
age of the viewport size; the page content resizes to adapt to view-
port or font size changes. Two common relative layouts are used: a
liquid or aÔ¨Çuid layout and an elastic layout. Fluid layouts are char-
acterized by specifying size of children as percentage of their parent
sizes, while elastic layouts focus on how elements resize on change
in font sizes. Hybrid layouts which combine Ô¨Çuid, elastic and Ô¨Åxed
layout styles are also common.
Computing a Ô¨Åxed layout from a mockup is straightforward
because the positions and sizes of all elements are Ô¨Åxed and hence
they can be styled independently. In contrast, to generate a relative
layout, we need to consider the relative vertical/horizontal alignment
of elements in the page, which may also change locally across the
page. Therefore, a more sophisticated approach is needed.
Layout Representation. A horizontal box HBox contains child
boxes aligned along the x-axis (left-right). The children of a vertical
boxVBox are aligned along y-axis (top-down). We use HVBox to
denote a box which is either an HBox or a VBox. A cut is called a
guillotine cut if it breaks a connected area into at least two parts. A
vertical (horizontal) guillotine cut is a cut parallel to the y-(x-) axis
and creates an HBox (VBox), respectively. An HVBox partition P
ofBis obtained by performing a sequence of vertical or horizontal
cuts;PpartitionsBinto a hierarchy of disjoint HVBoxes. The box
type of an element nis denoted by n.box.
Most web pages are laid out in a structured manner and their
layout can be captured using HVBox partitions. Given a mockup
Mdrawn on a canvas box C, aHVBox layout forMis deÔ¨Åned to
be a HVBox partition PofCsuch that each minimal partition in
Pcontains exactly one UI element from M. Inferring an HVBox
layout allows us to model the structure of the page in a holistic
fashion; the model captures relative sizes and positions of the UI
elements, as well as the vertical/horizontal Ô¨Çow of the elements at
different locations on the page. This, in turn, enables encoding a
relative layout forMin HTML efÔ¨Åciently.
Grid vs HVBox layouts. Layouts are often modeled using grids.
However, grids result in Ô¨Åne-grained layouts which have additional
overhead. Consider Fig. 5 showing layout with four boxes B1-B4.
To model the layout using grids, we need to specify the Ô¨Åne-grained
grid shown in dotted lines. In contrast, we only need 3 guillotine
cuts with an HVBox partitioning (solid lines). Encoding grids with
HTML tables is even worse, e.g., because of redundant markup for
empty table cells and harder re-designs [16]. Further, designer must
B1B2
B3
B4Figure 5. HVBox (solid) vs Grid (dotted) partitioning.
spend additional effort chopping content and aligning boxes with
the grid in a WYSIWYG editor [1, 21], which is laborious.
As mentioned earlier, our encoding framework (Fig. 1) consists
of two phases: (a) infer an HVBox layout T, (b) encode the layout
Tinto HTML/CSS. Obtaining faithful encodings is non-trivial: both
these phases require sophisticated algorithmic machinery and mul-
tiple design choices. We now describe the Ô¨Årst phase of our frame-
work, i.e., HVBox layout inference.
4. HVBox Layout Inference
Because mockups contain implicit layout information, we must
extract their layout by analysis. An HVBox layout Lfor a mockup
Mmay be viewed as a tree T, where the leaves represent the
content boxes, an intermediate node is an HVBox, and the root of T
represents the top-level box ( body in HTML). Computing a valid
HVBox layout Lmay involve searching over a large number of
possible HVBox partitions. To minimize the search space, we use a
greedy search which performs iterative bottom-up merging of boxes
by choosing a pair of boxes to merge at each iteration. Some of
these choices may not lead to a valid HVBox layout. Therefore, the
algorithm is capable of backtracking, i.e., if it is unable to proceed
by merging further, it backtracks and tries out other possible merge
choices. A valid layout Lcorresponds to a correct sequence of
merges (Theorem 1).
The procedure ComputeLayout (Alg. 1) computes the layout
treeTforM, using procedures Preprocess ,Merge andMergeIm-
plied . It maintains a forest of treesFto compute layout: initially,
Fcontains a separate tree for each box in M. The procedure Ô¨Ån-
ishes successfully if Fcontains a single tree Tat some iteration.
Procedure Merge merges two boxes b1;b22Fto obtain an HBox
(VBox). It Ô¨Årst computes the minimum bounding box (MBB) for
b1andb2, i.e., the smallest horizontal (vertical) box cwhich con-
tainsb1andb2. A new box (tree) c= (box;b 1;b2)is added toF,
whereboxis HBox or VBox, and b1,b2removed from F. To im-
prove search, a potential merge setP(b)for each box bis maintained
which contains all the boxes in Fwhich may merge with b.
Merge forms the core of our layout procedure: it needs to efÔ¨Å-
ciently compute adjacent boxes which can be aligned and merged up
to a degree of tolerance. We use the k-d tree data structure to store
box coordinates, compute P(b)and answer box overlap queries ef-
Ô¨Åciently. The procedure MergeImplied computes the merges which
areimplied at each iteration, i.e., for all boxes bi2FwhoseP(bi)
contains exactly one element, say bj, the procedure merges biand
bj. The procedure continues until no implied merges are possible.
In Alg. 1, the Preprocess method Ô¨Årst strips Mto extract the
set of hierarchical boxes drawn by user. Because a recursive parti-
tioning is infeasible with overlapping boxes, it computes a maximal
subset of non-overlapping boxes Fto compute layout with1. After
preprocessing, Merge combines boxes in Finto an HVBox, while
updating the forest Funtil a single tree remains in F. Note that this
merge may updatePof other boxes adjacent to biandbjand hence
1Most designs avoid such boxes but complex designs may contain a few. We
handle overlapping boxes at a later stage.trigger other implied merges. After computing the implied merges,
the algorithm checks if a conÔ¨Çict occurred, deÔ¨Åned as follows.
AconÔ¨Çicting conÔ¨Åguration during search is where the set P(b)
for each block b2Fis empty and Fcontains more than one
element. Clearly, we cannot continue merging and obtain a valid
layout with the current sequence of merges. Therefore, we undo one
or more previous choices and continue the search by trying other
merge choices. Moreover, we learn facts from the conÔ¨Çict into a
conÔ¨Çict setR. This set stores all the incompatible merge choices
encountered during search and prevents the algorithm from making
similar bad choices in the future.
The procedure HandleConict implements conÔ¨Çict analysis and
backtracking. On success, HandleConict returnstrue and the al-
gorithm proceeds to Ô¨Ånd other merge choices. Otherwise, no merge
choices will lead to a valid HVBox layout, and the algorithm termi-
nates with a NO answer. Otherwise, the algorithm returns the com-
puted layout tree T=F[0]. The procedure can be extended to the
case where the mockup contains user-deÔ¨Åned containers, e.g., an
HTML form, which contain children UI elements. In this case, we
check if there exists a parent box pinMwhich corresponds to the
bounding box bobtained on merging the children UI elements. Then
Merge labels the merged node in Twithpinstead ofb.
Readers may observe that our layout algorithm, in spirit, fol-
lows the explore-fail-learn paradigm of the general DPLL algorithm
(cf. [46]) for constraint solving, which is known to solve hard com-
binatorial problems efÔ¨Åciently in practice. We choose to formulate
the approach over boxes directly instead of using a SAT solver so as
to exploit the problem structure as well as avoid expensive proposi-
tional or quantiÔ¨Åer-based encodings.
Procedure ComputeLayout (Mockup M)
F:=Preprocess (M)
MergeImplied () //Update F,P
while size of F >1do
Choose box bi2Fandbj2 P(bi)
Merge( bi,bj)//Update F,P
MergeImplied () //Update F,P
ifConict() then
r:=HandleConict () //Update R,P
if:rthen return NO
return F[0]
Algorithm 1: Layout Computation.
THEOREM 1.If a mockup has a valid HVBox partition, then the
ComputeLayout procedure will compute a valid tree for it.
Proof Sketch. We prove by induction over the number of horizon-
tal/vertical cuts in the HVBox partition. For a single cut, the mockup
is an HBox or VBox with two elements. Merge will obtain the HBox
or VBox via a single merging step. Suppose the iterative merging
obtains a valid layout for all HVBox partitions with n 1cuts.
Consider a partition with ncuts: remove any one cut from it to ob-
tain ann 1cut partition. By hypothesis, iterative merging will
compute a correct layout tree Tfor the latter. Now, the nthcut must
separate two boxes bi,bj, both of which lie in some leaf lofT, and
bj2P(bi). This is sufÔ¨Åcient for Merge to combinebi,bjinto tree
tand replacelinTbytto computeT0for then-cut partition.
Example. Consider the mockup with boxes 1a-1d, 2, 3, 4 and
5 shown in Fig. 6(a). Starting with a forest consisting of these
singleton box-trees, ComputeLayout tries to merge the trees into a
single tree iteratively. Fig. 6(b) shows the initial merge set P(b)for
each boxbas a graph: each edge denotes that the corresponding pair
of nodes may be merged without intersecting with other boxes. The
graph shows that, in Fig. 6(a), 1a-1d only merge among themselves,
box 3 has two merge choices, 2 and 4, and box 5 has no choices
(merging 5 with 4 intersects 3, with 1d intersects 1c). Implied
merges are computed Ô¨Årst: there are two of them ( P(2) =P(4) =
1a2
3
452
3
45
2
3
451 2
3
45(a) (b)
(c)(d)1 2
3 45VHHV1b
1c 1d1a 1b
1d 1c
1a 1b
1d 1cFigure 6. Example: Layout Inference.
1) and the algorithm must make a choice. Suppose it chooses to
merge boxes 2-3 Ô¨Årst. Now, box 4 cannot merge with 3 and there are
no more implied merges. Further, suppose boxes 1a-1d are merged
among themselves, to form a box labeled 1. Fig. 6(c) shows the
resultant conÔ¨Åguration. Now, all the boxes 1, 2-3, 4 and 5 have their
merge setPempty. Hence we have a conÔ¨Çict . To resolve the conÔ¨Çict,
we undo the earlier merge choice 2-3 and record (2-3, 1a-1d) as
an incompatible set of merge choices (if we merge 2-3, then 1a-1d
cannot be merged). Now, the other merge choice 3-4 from Fig. 6(b)
is tried. After merging 3-4, P(3 4) =f5gandP(1) =f2g.
The procedure computes implied merges: boxes 1-2 are merged and
boxes 3-4 are merged with box 5. Finally, 1-2 and 3-4-5 are merged
as shown in Fig. 6(d) and we obtain a valid HVBox partition. The
Ô¨Ånal layout tree is shown in Fig. 6(d) with the intermediate HBox
(VBox) nodes labeled by H(V).
Procedure Compact (TreeT)
repeat
foreach nodeninTdo
ifcis a child of n^c:box =n:box^isRemovable (c)then
For each child gofc, make ga child of n
Delete cfromT
untilTdoes not change ;
Algorithm 2: Compact the partition tree. For element x,x:box
has values HBox or VBox or is undeÔ¨Åned.
The treeTcomputed by ComputeLayout may have redundant
HVBoxes, e.g., if a tree node nis an HBox and all its children are
also HBoxes, we can Ô¨ÇattenTby removing each child cofnand
attaching the children of cton. In general, note that every child
HBoxcof an HBoxnis redundant, i.e., all children of ccan be made
direct children of nwithout affecting the HVBox layout. Using
this observation, Compact (Alg. 2) computes a minimized partition
with fewer HVBoxes. We cannot remove an intermediate node n
from treeTif it corresponds to an element in the mockup, which
is deemed essential by the designer. The isRemovable procedure
checks if an element is essential before removing it.
5. HTML/CSS Encoding
Encoding the inferred layout Tin HTML/CSS would be straightfor-
ward if CSS supported HBoxes and VBoxes natively. Unfortunately,
no such constructs exist in CSS2.1 [3] and as we discussed earlier,
using HTML tables makes layout redundant and mockup drawing
labor-intensive. Thus, we need to exploit the CSS box semantics, as
professional designers do, in order to ‚Äúhack‚Äù CSS to create the de-
sired layout. Two main CSS notions are used for layout in practice:Figure 7. Collapsing parents with Ô¨Çoating children.
block formatting contexts (BFCs) and Ô¨Çoated elements. The precise
deÔ¨Ånitions of these notions are quite involved [3]: we present a sim-
pliÔ¨Åed description here to provide intuition.
Encoding HVBoxes. A block formatting context (BFC) is the cen-
tral layout primitive in CSS: it deÔ¨Ånes an independent scope for for-
matting elements contained inside it, oblivious to other page com-
ponents. A block box b, e.g., div, may deÔ¨Åne a new BFC by using
special CSS keywords, e.g., overflow orfloat , in the CSS rules
forb. By default, blocks in a BFC are laid out from top-to-down,
one after another (also called the Ô¨Çow layout ). So, we can simply
encode a VBox in CSS by deÔ¨Åning a new BFC (HTML body ele-
ment is a BFC already). The main issue is how to create horizontal
Ô¨Çow for HBoxes. CSS float properties come to our rescue here.
Given a list of child boxes [b1;b2;:::;b n]inside an HBox p, we
can encode them by Ô¨Çoating eachbito the left (or right) inside p.
This is speciÔ¨Åed by adding ( float: left ) for eachbi. Intuitively,
this may be understood as an extension of text wrapping, e.g., in
LATEX, to boxes: Ô¨Çoating boxes wrap next to their previous box sib-
ling. Additional care is needed when we would like to recover the
vertical Ô¨Çow: we must clear the Ô¨Çoats after the Ô¨Ånal child bn. This
intricate combination of BFC and Ô¨Çoats, allows us to obtain nested
horizontal and vertical layouts.
CSS Quirks. The description above glosses over many CSS quirks,
which our encoding also needs to handle. Consider, e.g., the issue of
collapsing parents . A Ô¨Çoated child bidoes not contribute to parent
p‚Äôs container size in CSS, or in other words, biis ignored when
sizingp. This behavior, known as the great collapse popularly, leads
to a bad layout in many cases. Fig. 7(a) shows the same example
from Fig. 4(b) except that the content boxpis highlighted by
adding the rule background: #cbc to#content in CSS. Now,
we Ô¨Çoat children of pusing .mybox class, leading to the collapse,
shown in Fig. 7(b). Interestingly, this was not apparent in Fig. 4(c),
but is still undesired. To Ô¨Åx this, we establish a new BFC with pso
thatp‚Äôs layout now owns its children‚Äôs layout: add a rule overflow:
hidden top‚Äôs CSS #content . Other tricks, e.g., by clearing Ô¨Çoats,
can also solve this problem.
As mentioned earlier, our encoding should be both Ô¨Çuid and elas-
tic (Sec. 3) and not Ô¨Åxed. Fluidity is essentially obtained by specify-
ing size/margins of boxes in percentages relative to their parent, but
involves additional challenges: we must consider how the complex
multi-box structure (Fig. 3) interacts with the size/margin proper-
ties. Handling padding and borders (in pixels) together with Ô¨Çuid-
ity introduces rounding errors and requires computing tolerant rel-
ative values. Many more challenges exist, e.g., collapsing margins,
aligning labels with corresponding input elements in forms, etc., dis-
cussed later. Overall, automatic encoding into CSS turns out to be
quite an ordeal . Note that at present, these encoding hardships need
to be borne manually by the designer.
5.1 Rule-based Modular Encoding Architecture
We wish to hide the aforementioned CSS hardships under-the-hood
to reduce designer‚Äôs burden. To this goal, we propose a modular
rule-based architecture for encoding layouts systematically. Our
approach automates and uniÔ¨Åes multiple adhoc design principles,
Make-BlockMark-Flex
Mark-FloatCompute-Relative
Margin-Fluid Size-Fluid Size-Fluid-Elastic
HTML CSS
Code Generation Code GenerationFigure 8. HTML/CSS encoding architecture overview.
has a clear separation of sub-tasks and avoids re-computation of
intermediate results. This, in turn, allows it to be reusable even as
CSS evolves or encoding goals change.
Fig. 8 shows the architecture: boxes represent the key individ-
ual modules and the arrows show their mutual dependency. The top
modules, M AKE-BLOCK , COMPUTE -RELATIVE and M ARK-FLEX
compute intermediate results which are required by multiple lower
modules, i.e., M ARK-FLOAT , M ARGIN -FLUID , SIZE-FLUID and
SIZE-FLUID -ELASTIC , which encode the alignment, relative mar-
gins and the height/width of UI elements. Each module is deÔ¨Åned by
a set of rules, given in Fig. 9, which recurse over the structure of lay-
out treeT. Specifying modules as rules helps highlight the key log-
ical challenges during encoding and enables an abstract description,
decoupled from their application order in a speciÔ¨Åc implementation.
Encode structure (HTML). Encoding the structure of the lay-
out treeTin HTML is relatively straightforward. Each intermediate
node inTmaps to a divelement (<div></div>) which encloses
the HTML code for its subtree. The root node maps to the body
HTML element. The leaf UI elements in the layout tree Tare en-
coded by corresponding HTML tags or widgets [17]. Care must be
taken to encode the content of the UI element properties, e.g., all the
options of a select element must be encoded into HTML.
5.2 Encode layout and style (CSS).
The modules in Fig. 9 encode tree Tinto CSS in a manner faithful
to the original mockup, i.e., preserve relative positions, sizes, align-
ment and visual properties.
[MAKE-BLOCK ]Recall that only block box elements (cf. Sec. 2),
e.g., div,ul, may be assigned height/width values and establish a
BFC in CSS [3]. Therefore, we must convert non-block leaf el-
ementsnin treeTto block elements to control their size and
ensure proper alignment. However, children of a few block el-
ements, e.g., pcannot be made block [8]. Hence, this module
(Fig. 9) recurses down Tusing the rules canMakeBlock andmay-
HaveBlockChildren . When it Ô¨Ånds an non-block element n(:
isHTMLBLockElement (n)) which can be converted, it sets prop-
ertyn.toBlk totrue . This module additionally takes care of ele-
ments, e.g., tr, which do not allow immediate block children but
allow other descendants to be block. The toBlk value is looked up
during HTML code generation to generate a wrapper div block
containingn: this block essentially serves as an alias for nin the
other rules which enforce the size and position of n.
For CSS translation, we associate each node ninTwith a CSS
object, denoted n.css, which contains properties of ncomputed by
the modules. As discussed above, non-block elements cannot accept
height/width/margin properties and hence are wrapped by alias div
elements. So, to assign CSS properties correctly, we use the cssObj
function: ifnhas a wrapper div (n.toBlk is set), then cssObj (c)
returns the CSS object for wrapper of c, else it returns c.css. The
rules refer to n.cssorcssObj (n)appropriately.
[MARK-FLEX]To handle text-containing Ô¨Çexible elements, this
module marks all such elements and their ancestors with propertyisFlex =true . Note that marking all ancestors is necessary to allow
Ô¨Çexible children to re-size freely without overÔ¨Çowing their parents.
[MARK-FLOAT ]This module deÔ¨Ånes how the layout HVBoxes
are encoded in CSS. VBoxes are encoded directly; the key question
is how to encode an HBox. This module traverses Trecursively
and assigns ( overow = ‚Äòhidden‚Äô) value to each HBox element and
(oat = ‚Äòleft‚Äô) values to all its children. This Ô¨Çoats children to the
leftedge of their parent. Margin computation (see below) takes care
of the spacing in-between even if the children are closer to the right
edge of the parent.
[COMPUTE -RELATIVE ]This module pre-computes the offset
and height/width of an element relative to its parent‚Äôs content box .
The offsets along four directions between child‚Äôs and parent‚Äôs con-
tentboxes are stored as properties topr, leftr, bottomr andrightr
with pixel values. The relative height/width relHeight, relWidth are
computed in percentages. This module additionally computes the
offsets between the child‚Äôs border box and the parent‚Äôs content box
and stores them as properties topr', leftr' , and so on (not shown in
Fig. 9). These are required by the M ARGIN -FLUID module.
[MARGIN -FLUID ]Margin values align the set of children prop-
erly inside their parent‚Äôs container (cf. Fig. 3). To obtain a Ô¨Çuid lay-
out (Sec. 3), we compute margins in percentages (of parent‚Äôs width).
All margins for non-block elements are set to 0(M5). The margins
for the Ô¨Årst child cof parentn, given bychildK (c;n;1), depends
only on the separation between content box of nand the border box
ofc(rule M1). For other children of n(rules M2-M4), the left/top
margins depend on the right/bottom border of the previous sibling
(Ô¨Åelds immT, immL ) depending on whether nis a HBox or a VBox,
respectively. Computing only the left and top margins is sufÔ¨Åcient
for Ô¨Çuid designs if the height/width of children relative to their par-
ent is Ô¨Åxed, i.e., we can set the right margin of cto0and take into
account the width of cwhen computing the left margin of the next
sibling ofc. This also helps avoid the collapsing margin problem
because, e.g., only the top margins are speciÔ¨Åed for each element in
VBox. This assumption, however, breaks down for elastic designs
(see below).
[SIZE-FLUID ]This module computes the sizes of each box rel-
ative to its parents in percentages. The height andwidth of non-
root nodes simply assume the relHeight andrelWidth values com-
puted previously by module C OMPUTE -RELATIVE . The root and
non-block nodes assume 100% of their parent‚Äôs size. This allows
the root node to resize with the browser and all other nodes resize
automatically due to their relative sizes. However, Ô¨Çuid sizes are not
sufÔ¨Åcient for handling Ô¨Çexible elements with text, which may over-
Ô¨Çow its container on resizing.
[SIZE-FLUID -ELASTIC ]Encoding Ô¨Çexible elements which re-
spond to both font and viewport changes gracefully is non-trivial.
Note that to obtain Ô¨Çuid layouts, it is sufÔ¨Åcient to specify the rel-
ative size of a child cas above, i.e., child size depends only on
the parent size ( upward dependency). However, in an elastic lay-
out (Sec. 3), the size of calso depends on the text font size for c,
i.e.,cmust grow as the font size increases. Consequently, the size of
all the ancestors of cnow also depends on the size of c(downward
dependency). If we enforce only a Ô¨Çuid layout, i.e., the contained
text may overÔ¨Çow the boundaries of the child on font size increase.
On the other hand, if c‚Äôs and its ancestors‚Äô size dependent solely on
the font size, e.g., by setting the size to auto , thencand its ances-
tors may expand or shrink to an undesired size depending on font
size changes. Having both Ô¨Çuidity and auto constraints is not pos-
sible because it introduces a circular dependency between cand its
ancestors. We therefore have to carefully balance the upward and
downward dependencies to obtain a desirable layout.
Our key insight here is that by constraining only the width of the
elements relative to their parent, we can keep the Ô¨Çexible elements
(and their ancestors) unconstrained, while ensuring Ô¨Çuidity of the
overall design. The height of Ô¨Çexible elements is left unconstrained
(or minimally constrained, if required) so that they can adapt to[MAKE-BLOCK ]Convert non-block leaves to blocks
(B1)child (c; n)
b= (canMakeBlock (n)^mayHaveBlockChildren (n)
canMakeBlock (c) := b
(B2)leaf (n; T ):isHTMLBlockElement (n)canMakeBlock (n)
n:toBlk :=true
(B3)canMakeBlock (root (T)) := true
[MARK-FLEX]Mark elements Ô¨Çexible
(FE1)hasFlexSize (n)
n:isFlex :=true(FE2)child (n; p)n:isFlex
p:isFlex :=true
[MARK-FLOAT ]Encode HVBoxes using Ô¨Çoat
(FO1)HBox (n)
n:overow :=hiddenchild (c; n)f= (HBox (n) ?left:none
c:oat :=f(FO2)
[COMPUTE -RELATIVE ]Offset and Size relative to parent
(CR1):root (n; T )
n:topr :=n:y n:parent :yn:leftr :=n:x n:parent :x
(CR2)n:rightr :=n:leftr +n:width n:bottomr :=n:topr +n:height
n:relHeight :=n:height =n:parent :height100%
n:relWidth :=n:width=n:parent :width100%
[MARGIN -FLUID ]Encode Margins in CSS
(M1)childK (c; n; 1) o=cssObj (c)
o:margin :top:=n:topr'=n:width100%
o:margin :left:=n:leftr'=n:width100%
(M2)childK (c; n; i )
1< ichn(n)childK (cp; n; i 1) HBox (n)
c:immT :=c:topr' c:immL :=c:leftr' cp:rightr'
(M3)childK (c; n; i )
1< ichn(n)childK (cp; n; i 1) VBox (n)
c:immT :=c:topr' cp:bottomr' c:immL :=c:leftr'
(M4)childK (c; n; i ) 1 < ichn(n)o=cssObj (c)
o:margin :top:=c:immT =n:width100%
o:margin :left:=c:immL=n:width100%
o:margin :f:= 0;f2fbottom,rightg
(M5)n:toBlk o=n:css
o:margin :s:= 0 s2ftop,left,bottom,right g
[SIZE-FLUID ]Encode Fluid Height/Width in CSS
(SF1)o=cssObj (n)n6=root (T)
o:height :=n:relHeight o:width :=n:relWidth
(SF2)n:toBlk_n=root (T)o=n:css
o:f:= 100% ;f2fheight,widthg
[SIZE-FLUID -ELASTIC ]Encode Elastic-Fluid Height/Width
(SFE1)child (c; n)o=cssObj (c):n:isFlex:c:isFlex
o:height :=c:relHeight
o:width :=c:relWidth
(SFE2)child (c; n) HBox (n)n:isFlex c:isFlex o=cssObj (c)
o:width :=c:relWidth
(SFE3)child (c; n) HBox (n)n:isFlex:c:isFlex o=cssObj (c)
o:min-height :=c:height +px
o:width :=c:relWidth
(SFE4)child (c:n)VBox (n)n:isFlex:c:isFlex o=cssObj (c)
o:min-height :=c:height +px
o:min-width :=c:relWidth
Figure 9. Rules for CSS Encoding. Variables c,cp,nrange over
nodes of the layout tree T. chn(n) = number of children of n,
child(c;n)(childK (c;n;i )) holds ifcis some child ( ithchild)
ofninT. HBox(n) or VBox(n) holds ifn.box = HBox(VBox).
To keep brevity, we concatenate numeric and string expressions in
JavaScript-style.viewport and font changes. To encode this (cf. Fig. 9, we add rules
(SFE1-4) and remove the earlier rule (SE1) which assigns Ô¨Çuid
constraints naively. For a Ô¨Çexible child cof an HBoxn(SFE2), we
therefore only set its relative width, leaving height unconstrained.
For a non-Ô¨Çexible sibling c0ofc(SFE3), we constrain the min-
height ofc0to its mockup-given height in pixels. This prevents
c0from shrinking to an undesired size. Ideally, max-height forc0
should also be set but it wasn‚Äôt required for our benchmarks.
Ifnis a VBoxn, we leave the Ô¨Çexible element size fully uncon-
strained, but we constrain the min-height and min-width of its non-
Ô¨Çexible siblings (rule SFE4). Recall that M ARGIN -FLUID module
assumes that Ô¨Åxed relative height/width of children with respect to
its parent, which does not hold now. So, we also modify rule (M4)
to compute bottom (right) margin values for all children of a Ô¨Çexible
HBox (VBox) and right (bottom) margins for the last HBox (VBox)
child (rules not shown to save space). We believe our rules provide
an elegant solution which avoids circular dependencies as well as
achieves elastic and Ô¨Çuid layout.
Font properties. For the UI elements with speciÔ¨Åc font-size and
line-width properties, a separate module encodes these font prop-
erties in relative notation by using percentages. This allows chang-
ing the font properties throughout by making a single change at the
top-level body element, without losing the correlation between the
font-sizes of different elements.
Code Generation. The HTML code is generated by recursively
traversing the layout tree and each element is assigned a unique class
name. Wrapper divs are introduced around Ô¨Çexible leaves. CSS
code is generated for each element using its identiÔ¨Åer as the selector
followed by its CSS properties, e.g., height, width, oat, margin ,
computed using the rules above. A normalizing CSS style Ô¨Åle [14]
is added in the beginning for ensuring cross-browser compatibility
and setting properties like padding, margin and border values to 0
wherever necessary. Identical CSS annotations for different HTML
elements are also grouped together in a single CSS class.
Extensibility. Our the encoding framework is modular and each
module can be reÔ¨Åned independently without affecting other parts
of the encoding as long as the interfaces remain the same. For exam-
ple, we could easily reÔ¨Åne rules from module S IZE-FLUID to handle
elasticity without modifying the overall Ô¨Çow. Multiple implementa-
tions of the same module can co-exist and selected by the designer
on-demand, e.g., M ARK-FLOAT can be implemented differently us-
ing dummy divs and clear . Modularity also enables Ô¨Åne-tuning our
encoding for issues speciÔ¨Åc to UI elements or browser behaviors.
5.3 Additional Implementation Challenges
Rounding. Rounding errors during multiple margin and size calcu-
lations can cause the child content to overÔ¨Çow its parent. To avoid
this, we truncate all values to one decimal position. For handling im-
ages with elastic layout, we set both their width andmax-height
to 100% of the wrapper box and do not set the height property.
Some more optimizations are possible, e.g., if a node has a single
child, we can use margin: auto; text-align: center; prop-
erties to center the child. Moreover, we can Ô¨Çoat HBox children to
right if necessary during margin computation, and then constrain
right instead of left margins.
User Guidance. Our automated layout inference approach may not
be always successful in computing a correct HTML/CSS encoding
due to a number of reasons. For example, the mockup may be
ambiguous (cf. 1a-1d in Fig. 6) and not capture the designer-intent
fully, such that there may be multiple valid merge choice sequences
and therefore multiple feasible layouts. Consequently, our HVBox
inference algorithm may not infer the layout desired by the user.
Different or non-standard implementations of CSS standards may
also cause problems. In such cases, user guidance is required. Our
tool enables the user, via conÔ¨Åguration Ô¨Åles, to guide the layout
inference and encoding for a particular design, e.g., specify groups
of elements which must be merged or must not be merged. Thetool provides multiple other options to enable user guidance: Ô¨Çoat
clearing mechanism, Ô¨Åx body height in pixels or percentage, specify
elements with Ô¨Åxed size in pixels, use a Ô¨Åxed max-width for text-
containing boxes, and whether to automatically center a box if it is
the only child. Moreover, we can allow the user to Ô¨Åx other style
properties, e.g., position ,z-index , in the WYSIWYG editor:
these values will be retained in the Ô¨Ånal design and override the
tool-computed values in case of conÔ¨Çict.
Browser Incompatibilities. Our encoding relies on a small set of
CSS idioms to maximize cross-browser compatibility. Further, to
get rid of the well-known browser inconsistencies due to CSS, we
prepend a normalizing stylesheet [14] to each generated mockup.
Still, the pages may not display correctly in all browsers, especially
the older ones, e.g., because the browser does not implement the
CSS2.1 standards correctly or completely. In such cases, based on
browser detection, we can fall back to Ô¨Åxed layouts, which dis-
play correctly in most browsers, e.g., we can use CSS conditional
comments to detect older versions of the Internet Explorer (IE)
browser and apply different CSS rules to correctly display the page.
We believe that this is a reasonable compromise to support legacy
browsers in the face of rapid adoption of newer browsers (supporting
CSS2.1 standards to a large extent and even CSS3 substantially) and
modern markup technologies. Finally, we note that browser compat-
ibility cannot be guaranteed statically and needs testing speciÔ¨Åc to
targeted browsers. Nevertheless, our tool saves considerable manual
effort in page design by automating layout inference and HTML en-
coding systematically. Our framework, being modular and system-
atic, can also be re-targeted to other existing or new technologies,
as they arrive. We have also provided the designer several knobs
to tweak the designs to match the user-intent as well as deal with
limitations of CSS. Also, we observe that many hurdles of cross-
browser compatibility and limited CSS2.1 expressivity will be over-
come once CSS3 is standardized and all browsers support it fully.
Overlapping Boxes and Dynamic Layouts. Recall that our frame-
work discards the overlapping boxes before inferring layout. In most
cases, we observed that the designers intend these boxes to be lo-
cated at a Ô¨Åxed position relative to the viewport. Therefore, we add
these boxes back to the design at the original Ô¨Åxed positions with
original sizes using position property. We do not support dynamic
rearrangement of layout as of now. However, our Ô¨Çoat-based encod-
ing of HBoxes together with min-width values partially overcomes
this drawback: if the viewport size is too small, children of HBoxes
will rearrange automatically to the next row.
CSS3 [5] is an in-progress standard for styling web documents
and contains much better support for specifying HVBoxes and rel-
ative layout than CSS2.1. However, the standard is still in Ô¨Çux and
different web browsers support it to different degrees. Our modular
encoding framework (Fig. 8) can be reused for CSS3 also by in-
stantiating the modules with CSS3-speciÔ¨Åc rules, many of which
do not change. Further, our mockup-based compilation approach
allows transparent extension to generate CSS3 code behind-the-
scenes, without burdening the designer.
6. Tool architecture and Evaluation
We implemented and evaluated our approach using an open-source
mockup builder Maqetta [11] being developed at IBM. Maqetta sup-
ports design of mockups of both desktop and mobile applications by
dragging-and-dropping UI elements on the editor canvas, specifying
CSS properties for user elements. Maqetta generates HTML on-the-
Ô¨Çy when mockup is drawn. It provides two kinds of default layout
modes, Ô¨Çow andabsolute , for designing applications. In Ô¨Çow lay-
out, the elements are placed vertically one-after another. To align
elements horizontally, the designer must specify it using CSS Ô¨Çoats
manually. In the absolute layout, the elements are Ô¨Åxed to speciÔ¨Åc
coordinates, thus allowing arbitrary placement of UI elements on
a web page. However, Maqetta generates a Ô¨Åxed layout where ele-
ments do not respond to change in viewport sizes, as we desire.#Drawn #Neighbors Inf. #Boxes Min. #Boxes #Inferred Attributes File Size(KB)
Benchmark Boxes /#Merge Set /Tree Ht. /Tree Ht. Ô¨Çoat overÔ¨Çow height width margin HTML CSS
master-detail 83 13/3 125/11 91/6 64 20 60 125 80 11.5 13.8
column 225 18/2 318/14 232/7 129 33 81 212 111 18.5 40.1
search 62 17/2 104/10 65/4 50 10 46 96 56 7.4 10
filter 87 10/3 129/12 96/7 56 18 59 117 82 12 12.3
form 36 13/3 58/9 45/6 20 9 27 47 38 8.6 4.7
canvas 72 12/3 110/11 86/6 46 16 63 112 77 9.9 13
dashboard 55 7/3 77/10 67/8 28 14 34 66 53 6.9 7
spreadsheet 158 7/2 219/15 159/5 102 25 82 186 93 30.1 29.3
wizard 62 7/2 89/8 66/4 40 17 42 75 61 6.6 9
qa 55 14/3 97/8 81/6 42 21 37 80 60 9.8 11.2
parallel 65 8/3 105/9 88/7 24 12 49 75 63 10.7 12.6
interactive 70 18/3 108/11 80/5 42 15 56 83 63 6.6 8.8
Table 2. Tool statistics for the benchmarks in Table 1. See Analysis in Sec. 6.1.
Benchmark Description
master-detail Navigate the items of the master menu
and view the details on the same screen
column Hierarchical tabular data navigation
search Display search results for a particular query
filter ReÔ¨Åne data search results further
form Standard form UI
canvas Canvas object for drawing graphics
dashboard Show aggregated information at a glance
spreadsheet View and edit tabular information
wizard Guides user through a complex work-Ô¨Çow
qa Select among multiple choices and view answer
parallel View inventory list of similar items
interactive Combination of forms with result display
Table 1. Benchmarks corresponding to standard UI patterns.
Our tool takes an input a Maqetta mockup speciÔ¨Åcation drawn in
absolute layout mode and generates a faithful replica of the mockup
in HTML/CSS, which has a relative layout. The designer speciÔ¨Åes
only the key UI elements constituting a web page, without worrying
about the enclosing boxes which determine the page layout. The
height, width and position of the elements along with margins and
the relative alignment of elements are extracted from the visual
design and need not be speciÔ¨Åed separately. The designer, however,
needs to specify properties like padding and border widths for the
elements separately, which are hard to specify visually.
Our tool is wholly implemented in JavaScript, both on the
client-side (Maqetta) and server-side (node.js application [13]). The
mockup in Maqetta is serialized and transmitted to the server, which
processes it, infers layout, encodes it to HTML/CSS, and dumps
the corresponding HTML/CSS Ô¨Åles to the disk. We modiÔ¨Åed the
Maqetta source to add a button [ Create Layout ]: clicking the but-
ton serializes the mockup to JSON and sends it to the server using
an AJAX call. Note that our back-end can also be moved into the
browser for creating layouts if necessary.
6.1 Evaluation
To show that our encoding is effective, we require benchmarks cov-
ering the wide array of possible web designs. Unfortunately, no rep-
resentative benchmark set exists to evaluate a tool like ours. Select-
ing designs from the top Alexa pages does not make sense because
they are in no way representative of the possible web layouts. There-
fore, we constructed a benchmark set consisting of web pages which
capture various representative design patterns found across web. We
used multiple popular design sites, including Yahoo! Design Pattern
Library [20] and ui-patterns.com to collect these benchmarks
and curated them manually to avoid similar or duplicate patterns.
Table. 1 shows the representative patterns and their descriptions. We
drew mockups corresponding to these patterns in Maqetta and per-
formed layout and code generation for them. Note that these designs
closely imitiate real websites and are quite complex and hence may
contain up to a few hundred elements. Obtaining correct Ô¨Çuid-elastic
layouts needed a couple of iterations: the encoding procedure had
to be reÔ¨Åned multiple times before we got it correct. We veriÔ¨Åed
the correctness of the generated encodings using Firefox 16 (Mac
Figure 10. Incorrect box merge during layout inference.
Snow Leopard 10.6.8, Windows 7), Chrome 23 (Mac Snow Leop-
ard 10.6.8, Win 7) and IE9 (Win 7). We also used browser tools to
visualize the output for different form factors.
Our tool takes only a few seconds to encode each benchmark
and all the encoded Ô¨Åles represent faithful replicas in HTML of
the original mockups. As opposed to the Ô¨Åxed layouts generated
by Maqetta, the generated designs are Ô¨Çuid, i.e., they resize with the
browser (cf. Fig. 2) gracefully. Moreover, they are elastic, i.e., the
boxes containing text expand or shrink based on font-size changes,
without destroying the overall Ô¨Çuidity of the design.
Analysis. Table 2 shows details of the benchmarks and their encod-
ing in HTML. The Ô¨Årst column shows the number of user-drawn
UI elements (boxes), which vary between 36 to 225 for our bench-
marks. Although the number of neighbors (nearby elements) for
boxes may go up to 18, the set of mergeable neighbors (merge set,
cf. Alg. 1) remains small (2 or 3) because the merged elements
quickly begin to overlap. This reduces the merge choices and en-
ables the algorithm to converge fast. The third column shows the to-
tal number of boxes after layout inference and the layout tree height
(cf. Fig. 6); the fourth column shows the same values after com-
paction (cf. Alg. 2). Compacting the tree is essential: it removes a
large number of redundant boxes introduced by the layout inference
and reduces the tree height signiÔ¨Åcantly, thus reducing the size of
the Ô¨Ånal HTML/CSS code. The next Ô¨Åve columns show the number
of attributes computed for layout and size/spacing. The most ben-
eÔ¨Åts in terms of designer effort reduction is due to these attributes,
in particular height, width and margins. Note that in absence of our
tool, the designer will have to make careful calculations of relative
size and margin values to obtain Ô¨Çuid layouts. Besides, she will need
a deep understanding of BFCs and Ô¨Çoats to encode the HVBox lay-
out correctly. Also, note the difference between number of height
and width attributes computed. In order to obtain elastic layouts
(Sec. 5.1), our tool omits constraining the height wherever possi-
ble; however, widths are always constrained to ensure Ô¨Çuidity. With
our tool, the designer need not put in additional effort to ensure the
balance between Ô¨Çuidity and elasticity.
Layout Inference. We did not encounter any conÔ¨Çicts in these
benchmarks during layout inference because implied merging (cf.
Alg. 1) often avoids them successfully. However, an incorrect set
of elements were merged together sometimes, e.g., in Fig. 10, in-
stead of merging all the checkbox-label pairs in a single VBox, the
algorithm merges the label ‚ÄùI am currently‚Äù with the top checkbox-
label pair. To solve this, we provide manual guidance (Sec. 5.3), by
marking the checkbox-label pairs to be merged. While such manual
effort is unavoidable in general (hard to obtain unambiguous mock-
ups), better symmetry detection heuristics will avoid this effort.Fine-grained Tweaks. Most of the encodings generated by our tool
are high-quality replicas of the original mockup. Also, they adapt
gracefully on reducing the viewport size or increasing font size:
columns shrink in width as viewport size reduces while the text
splits into multiple lines to accommodate the smaller width. Owing
to complexity of CSS and incompatible implementations, a few Ô¨Åne-
grained issues remain. In some cases ( filter, master-detail )
thebutton does not Ô¨Åll its wrapper div element (see M AKE-
BLOCK ): this is Ô¨Åxed by setting the min-height of the button in pix-
els and removing the min-height constraints from its parent wrapper.
Same Ô¨Åx is applied for the HTML select elements also. These
Ô¨Åxes make the designs less Ô¨Çuid, but they are unavoidable with
the current less-expressive CSS standards. To obtain correct image
sizes, setting the max-height of the image to 100% is not sufÔ¨Åcient
in some cases. Then, we also Ô¨Åx the image wrapper‚Äôs height in pix-
els. Input elements, e.g., checkbox or radio buttons, do not align
properly in some cases. This is solved by removing the constraints
height: 100%; width: 100% relative to their wrapper divs. In
some cases, we want the child element to Ô¨Åll the parent div even
if the latter‚Äôs size is not speciÔ¨Åed. This is Ô¨Åxed by adding padding
to expand the child. Note that these Ô¨Åne-grained reÔ¨Ånements can
be also included as special rules, invoked under user-guidance, in
our extensible framework. Single word labels begin to overlap with
other elements on resizing to small widths. Finally, making the
viewport too small or the font too large may distort the design, re-
quiring dynamic layouts. In spite of these issues, our experiments
demonstrate that high-quality Ô¨Çexible layouts can be indeed ob-
tained automatically from mockups, with minimal manual effort.
Experience with drawing mockups. Drawing a mockup took the
authors about an hour on average. Note that the authors are not ex-
perts in UI design or Maqetta; we believe experts may be able to
draw mockups faster. A few time-consuming factors were setting
color, border and font properties, obtaining images, aligning ele-
ments inside a parent box or keeping them equi-distant. Some of
these issues can be improved in our tool by allowing a tolerance dur-
ing size calculations and better symmetry detection, both of which
are part of our planned tool improvements. We believe that in ab-
sence of our tool, a few hours of additional manual effort would be
required per mockup to align, size and layout elements properly.
7. Related Work
Automated Document Formatting has been studied extensively
(see [29, 38] for surveys) and most approaches model the prob-
lem as a constraint optimization problem. Much work has focused
onmicro -typography speciÔ¨Åc to text-dominated documents (cf.,
e.g., [34]). For macro -typography, i.e., layout of objects, constraint-
solving based methods [22, 25, 29] are used: they take input align-
ment constraints between UI elements, their sizes, etc. as input,
and solve these constraints to output a layout, i.e., coordinate val-
ues of each UI element on the canvas. The work in [35] uses con-
straint solving to generate multiple mockups similar to the original
one. All these methods infer pixel locations of UI elements as op-
posed to inferring a regular box/grid structure in which the elements
can be embedded. The latter problem, which is our focus, is com-
pletely different from the earlier one - techniques for solving the
earlier problem do not apply here. Moreover, constraint-solving
based methods assume a dedicated layout engine and cannot use
an off-the-shelf browser for layout directly. Instead, our goal is to
leverage the browser‚Äôs layout engine fully with no augmentations.
Several JavaScript-based engines perform dynamic layout inside
the browser; however, using JS for layout unnecessarily burdens the
application and fails to exploit the native layout engine.
The limited expressivity as well as complexity of CSS for web
design is a known problem [27, 30, 32, 37, 45]. The work in [44]
emphasizes the necessity of debugging tools for CSS and proposes
solutions to assist CSS development in authoring tools while [31,
32, 47] propose compilation from more expressive style languages
to CSS to improve productivity and avoid bugs. None of these ap-proaches, however, infer CSS layout rules from visual descriptions.
Constraint cascading style sheets [23] augment CSS with expressive
arithmetic constraints relating sizes of elements and font sizes, but
require a modiÔ¨Åed browser layout engine for supporting it. Tech-
niques to assist CSS-based development by eliminating redundant
CSS rules [39] or by performing sophisticated property checking
and coverage analysis [27] for CSS rules have been proposed.
Modern WYSIWYG editors [1, 2, 11, 12] allow convenient CSS
authoring with drag-and-drop features and employ their own layout
engines to enable page visualization. However, they generate only
Ô¨Åxed or non-hierarchical layouts automatically. Complex layouts
must be speciÔ¨Åed manually by the designer. Some tools [1] now
enable grid-based design also; however, additional manual effort is
required to make these designs elastic and Ô¨Çuid simultaneously.
Rectangular partitioning (see [41] for a survey) has been stud-
ied extensively. Many of these problems reduce to covering prob-
lems where boxes may be reordered to minimize cost. In contrast,
boxes may not be reordered in our setting. Computing an optimal
HVBox layout is an instance of the problem of hierarchical binary
tiling [33], whose complexity is polynomial in the grid size, but with
a high exponent value. Therefore, instead of adopting the usual dy-
namic programming solution, we propose an efÔ¨Åcient backtracking
based procedure, which consumes less memory and tries to Ô¨Ånd one
solution instead of the optimal one. Guillotine partition for table lay-
out has been investigated in [26] using dynamic programming. Our
work obtains a partition for arbitrary set of boxes on a canvas (not
just tables). The work in [36] uses machine learning to transfer page
layout and design from one page to another.
Popular Content Management Systems (CMSs), e.g., Drupal [6]
or Wordpress [19], natively provide the designer with a set of Ô¨Åxed
layout templates to create pages. Many systems, e.g., zengrids [21],
allow grid-based Ô¨Çuid layout speciÔ¨Åcation using modern CSS exten-
sions [10, 15]. A few CMS plugins, e.g., Sasson for Drupal, enable
Ô¨Çexible layouts in the CMS, again based on re-sizing grids. Such
frameworks, however, require user to explicitly Ô¨Åt the contents into
the grid by specifying the location and the number of grids taken
by a box. Further, they require learning new styling primitives of
the framework. In contrast, with our tool, the user can freely draw
UI elements in a WYSIWYG editor while our tool takes care of the
relative layout completely. Further, to our knowledge, no tool infers
a hierarchical layout from the mockup, which captures local Ô¨Çow of
elements besides their relative size/spacing.
8. Conclusions
We presented a method to systematically encode mockups drawn
in a WYSIWYG editor into Ô¨Çexible (Ô¨Çuid and elastic) layouts. Our
method Ô¨Årst infers a hierarchical HVBox layout for the mockup and
then encodes the layout with modular rules into HTML/CSS. We be-
lieve that ours is the Ô¨Årst disciplined effort to solve the challenging
problem of automatically encoding mockups in HTML/CSS. The
ability to generate Ô¨Çexible HTML encodings from mockups auto-
matically will allow quicker development of the application for mul-
tiple devices at once, besides reducing the learning curves among
novices. We do not generate fully dynamic layouts currently; future
work will build upon the current framework to obtain such layouts,
possibly with more involved constraint solving. Our modular frame-
work can also be extended to generate optimized, cleaner CSS [27]
using modern CSS extensions [10, 15, 47]. We also plan to augment
Maqetta to enable user feedback directly in Maqetta, as opposed to
using a textual conÔ¨Åguration Ô¨Åle, and carry out usability surveys.
We believe that automated compilation will enable the tool to ex-
ploit evolving technologies, including improved layout techniques
e.g., CSS3 [5], SASS [15], and re-enable adoption of mockup-based
UI development.
Acknowledgements. We would like to thank Satish Chandra, Vyas
Sekar, Partha Datta and the anonymous reviewers for helping us im-
prove the presentation of this paper.References
[1] Adobe Dreamweaver CS6. http://www.adobe.com/products/
dreamweaver.html .
[2] Balsamiq. http://www.balsamiq.com/ .
[3] Cascading Style Sheets Level 2 Revision 1 (css 2.1) SpeciÔ¨Åcation.
http://www.w3.org/TR/CSS21/ .
[4] Cisco visual networking index: Forecast and methodology, 2011-
2016. http://www.cisco.com/en/US/solutions/collateral/
ns341/ns525/ns537/ns705/ns827/white_paper_c11-481360_
ns827_Networking_Solutions_White_Paper.html .
[5] CSS Ô¨Çexible box layout module. http://www.w3.org/TR/
css3-flexbox/ .
[6] Drupal - open source cms. http://drupal.org/ .
[7] Gecko - mozilla ‚Äî mdn. https://developer.mozilla.org/
en-US/docs/Mozilla/Gecko .
[8] Html5. http://www.w3.org/TR/html5/ .
[9] Interactive wireframe software and mockup tool. http://www.
axure.com/ .
[10] Less: The dynamic stylesheet language. http://lesscss.org/ .
[11] Maqetta. http://maqetta.org/ .
[12] Microsoft Expression Web 4. http://www.microsoft.com/
expression/products/Web_Overview.aspx .
[13] node.js. http://nodejs.org/ .
[14] Normalize.css: Make browsers render all elements more consistently.
http://necolas.github.com/normalize.css/ .
[15] Sass - syntactically awesome stylesheets. http://sass-lang.com/ .
[16] Techniques for web content accessibility guidelines 1.0. http://www.
w3.org/TR/WCAG10-TECHS/#tech-style-sheets .
[17] Unbeatable javascript tools - the dojo toolkit. http://dojotoolkit.
org/ .
[18] The webkit open source project. http://www.webkit.org .
[19] Wordpress: Blog tool, publishing platform, and cms. http://
wordpress.org/ .
[20] Yahoo! design pattern library. http://developer.yahoo.com/
ypatterns/ .
[21] Zen grids: a responsive grid system built with compass and sass. http:
//zengrids.com/ .
[22] G. J. Badros, A. Borning, and P. J. Stuckey. The cassowary linear
arithmetic constraint solving algorithm. ACM Trans. Comput.-Hum.
Interact. , 8(4):267‚Äì306, December 2001.
[23] Greg J. Badros, Alan Borning, Kim Marriott, and Peter Stuckey. Con-
straint cascading style sheets for the web. In Proceedings of the 12th
annual ACM symposium on User interface software and technology ,
UIST ‚Äô99, pages 73‚Äì82, 1999.
[24] K. Z. Gajos, D. S. Weld, and J. O. Wobbrock. Decision-theoretic user
interface generation. In AAAI , pages 1532‚Äì1536, 2008.
[25] K. Z. Gajos, D. S. Weld, and J. O. Wobbrock. Automatically generating
personalized user interfaces with supple. Artif. Intell. , 174(12-13):910‚Äì
950, 2010.
[26] G. Gange, K. Marriott, and P. Stuckey. Optimal guillotine layout. In
Proceedings of the 2012 ACM symposium on Document engineering ,
DocEng ‚Äô12, pages 13‚Äì22, 2012.
[27] P. Geneves, N. Layaida, and V . Quint. On the analysis of cascading
style sheets. In Proceedings of the 21st international conference on
World Wide Web , WWW ‚Äô12, pages 809‚Äì818, 2012.[28] V . Grigoreanu, R. Fernandez, K. Inkpen, and G. Robertson. What de-
signers want: Needs of interactive application designers. In Proceed-
ings of the 2009 IEEE Symposium on Visual Languages and Human-
Centric Computing (VL/HCC) , VLHCC ‚Äô09, 2009.
[29] N. Hurst, W. Li, and K. Marriott. Review of automatic document
formatting. In Proceedings of the 9th ACM symposium on Document
engineering , DocEng ‚Äô09, pages 99‚Äì108, 2009.
[30] P. M. Marden Jr. and E. V . Munson. Today‚Äôs style sheet standards: The
great vision blinded. IEEE Computer , 32(11):123‚Äì125, 1999.
[31] M. Keller and M. Nussbaumer. Cascading style sheets: a novel ap-
proach towards productive styling with today‚Äôs standards. In WWW ,
pages 1161‚Äì1162, 2009.
[32] M. Keller and M. Nussbaumer. Css code quality: A metric for abstract-
ness; or why humans beat machines in css coding. In QUATIC , pages
116‚Äì121, 2010.
[33] S. Khanna, S. Muthukrishnan, and M. Paterson. On approximating
rectangle tiling and packing. In Proceedings of the ninth annual ACM-
SIAM symposium on Discrete algorithms , SODA ‚Äô98, pages 384‚Äì393,
1998.
[34] D. E. Knuth. Digital Typography . Cambridge University Press, New
York, NY , USA, 1997.
[35] Ali Sinan K ¬®oksal. Live tiles from end-user mockups. CHI 2012.
[36] R. Kumar, J. O. Talton, S. Ahmad, and S. R. Klemmer. Bricolage:
example-based retargeting for web design. In Proceedings of the
SIGCHI Conference on Human Factors in Computing Systems , CHI
‚Äô11, pages 2197‚Äì2206, 2011.
[37] H. W. Lie. Cascading style sheets. PhD thesis, University of Oslo,
February 2006.
[38] S. Lok and S. Feiner. A survey of automated layout techniques for
information presentations, 2001.
[39] A. Mesbah and S. Mirshokraie. Automated analysis of css rules to
support style maintenance. In ICSE , pages 408‚Äì418, 2012.
[40] Leo A. Meyerovich and Rastislav Bod ¬¥ƒ±k. Fast and parallel webpage
layout. In WWW , pages 711‚Äì720, 2010.
[41] S. Muthukrishnan, Viswanath Poosala, and Torsten Suel. On rectan-
gular partitionings in two dimensions: Algorithms, complexity, and
applications. In Proceedings of the 7th International Conference on
Database Theory , ICDT ‚Äô99, pages 236‚Äì256, 1999.
[42] M. W. Newman and J. A. Landay. Sitemaps, storyboards, and speci-
Ô¨Åcations: a sketch of web site design practice. In Proceedings of the
3rd conference on Designing interactive systems: processes, practices,
methods, and techniques , DIS ‚Äô00, pages 263‚Äì274, 2000.
[43] F. K. Ozenc, M. Kim, J. Zimmerman, S. Oney, and B. Myers. How
to support designers in getting hold of the immaterial material of
software. In Proceedings of the SIGCHI Conference on Human Factors
in Computing Systems , CHI ‚Äô10, pages 2513‚Äì2522, 2010.
[44] Vincent Quint and Ir `ene Vatton. Editing with style. In ACM Symposium
on Document Engineering , pages 151‚Äì160, 2007.
[45] D. Reed and J. Davies. The convergence of computer programming and
graphic design. J. Comput. Sci. Coll. , 21(3):179‚Äì187, February 2006.
[46] K. A. Sakallah and J. Marques-Silva. Anatomy and empirical evalua-
tion of modern sat solvers. Bulletin of the EATCS , 103:96‚Äì121, 2011.
[47] Manuel Serrano. Hss: a compiler for cascading style sheets. In PPDP ,
pages 109‚Äì118, 2010.
[48] B. V . Zanden and B. A. Myers. Automatic, look-and-feel independent
dialog creation for graphical user interfaces. In Proceedings of the
SIGCHI Conference on Human Factors in Computing Systems , CHI
‚Äô90, pages 27‚Äì34, 1990.