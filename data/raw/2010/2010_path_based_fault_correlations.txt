Path-Based Fault Correlations
Wei Le and Mary Lou Soffa
Department of Computer Science
University of Virginia
Charlottesville, VA, USA
{weile, soffa}@virginia.edu
ABSTRACT
Although a number of automatic tools have been developed to de-
tect faults, much of the diagnosis is still being done manually. To
helpwiththediagnostictasks,weformallyintroduce faultcorrela-
tion, a causal relationship between faults. We statically determine
correlations based on the expected dynamic behavior of a fault. If
the occurrence of one fault causes another fault to occur, we say
they are correlated. With the identiﬁcation of the correlated faults,
we can better understand fault behaviors and the risks of faults. If
one fault is uniquely correlated with another, we know ﬁxing the
ﬁrst fault will ﬁx the other. Correlated faults can be grouped, en-
abling prioritization of diagnoses of the fault groups. In this paper,
we develop an interprocedural, path-sensitive, and scalable algo-
rithm to automatically compute correlated faults in a program. In
our approach, we ﬁrst statically detect faults and determine their
error states. By propagating the effects of the error state along a
path, we detect the correlation of pairs of faults. We automati-
cally construct a correlation graph which shows how correlations
occur among multiple faults and along different paths. Guided by
a correlation graph, we can reduce the number of faults required
for diagnosis to ﬁnd root causes. We implemented our correlation
algorithm and found through experimentation that faults involved
inthecorrelationscanbeofdifferenttypesandlocatedindifferent
procedures. Usingcorrelationinformation,weareabletoautomate
diagnostic tasksthat previously hadto be done manually.
CategoriesandSubjectDescriptors
D.2.4 [Software Engineering ]: Software/Program Veriﬁcation—
Reliability ; D.2.5 [Software Engineering ]: Testing and Debug-
ging—Diagnostics,Symbolic execution
GeneralTerms
Algorithms,Experimentation, Reliability,Security
Keywords
fault correlation, errorstate, demand-driven, path-sensitive
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bearthisnoticeandthefullcitationontheﬁrstpage. Tocopyotherwise, to
republish,topostonserversortoredistributetolists,requirespriorspeciﬁc
permission and/or afee.
FSE-18,November7–11,2010,Santa Fe, New Mexico, USA.
Copyright2010ACM978-1-60558-791-2/10/11...$10.00.1. INTRODUCTION
Today the software industry relies more and more on automatic
tools to detect faults [5, 9, 12, 15]; however, many of the diag-
nostic tasks are still done manually, which is time-consuming. For
largenewlydevelopedsoftware,thousandsorevenmillionsoffault
reportsaregeneratedbytools[5,12,28];howeverthegeneratedre-
portsareprocessedataverylowspeed,estimatedas15–20reports
per person day [1] or 120 lines of code per person hour on aver-
age [17]. Fault diagnosis, done statically on the program source
code, aims to identify and ﬁx the causes of detected faults. Diag-
nosing faults is challenging for a number of reasons. One reason
is that the root cause can be located far from where the fault is
detected, while the code around the fault can be complex. Unlike
debugging,infaultdiagnosis,thereisnoruntimeinformationavail-
abletoassistinexplainingfaults. Also,instaticanalysis,realfaults
are often mixed with an overwhelming number of false alarms and
benign errors.
In this paper, we explore relationships among faults for fault
diagnosis. We show that a causal relationship can exist between
faults; that is, the occurrence of one fault can cause another fault
to occur, which we call correlation . As an example, in Figure 1
we show a fault correlation discovered in ffmpeg-0.4.8 . The
correlation exists between an integer signedness error at node 2
and a null-pointer dereference at node 5, as any input that leads to
the integer violation at node 2 triggers the null-pointer dereference
at node 5 along path /angbracketleft1,2,5/angbracketright. The trigger can occur because the
variablecurrent_track at node 2 is not guaranteed to get the
unsignedvalueof AV_RL32(&head[i+8]) (seethemacrodef-
inition at the bottom of the ﬁgure). If a large value is assigned,
the signed integer current_track would get a negative value
atruntime. When current_track isnegative,thebranch /angbracketleft2,5/angbracketright
is taken and the memory allocation at node 4 is skipped, causing
the dereference of fourxm->tracks at node 5 to encounter a
null-pointer.
Fault correlation is a relationship deﬁned on the dynamic be-
havior of faults. When a program runs, an initial root cause can
propagate and cause a sequence of property violations along the
execution before an observed symptom, e.g., crash, is detected. In
traditional static tools, the dependencies of those property viola-
tions are not identiﬁed; either only the ﬁrst violation is reported or
all the violations are reported but as separate faults [4, 11, 22, 28].
For the above example, static detection only reports that node 2
containsanintegerviolation,butitcannotexplainwhetheritisbe-
nign or malignant, and if harmful, how severe is the consequence.
A static detector for null-pointer dereference also cannot discover
the vulnerability, because the detector may not be aware of any
integer violations. When the impact of integer fault is not consid-
ered, the static analysis would report the path /angbracketleft1,2,5/angbracketrightinfeasible,
307Figure1: Fault Correlation inffmpeg-0.4.8
asAV_RL32(x) always returns a non-negative integer and thus
the result of the addition at node 2 should be always larger than
fourxm->track_count ’s initial value 0. However, given the
fault correlation, we know that: there exists a null-pointer deref-
erence at node 5; its root cause is the integer fault at node 2; and
by ﬁxing the integer fault, the null-pointer dereference can also be
ﬁxed.
Fault correlation helps fault management in the following ways:
1) we can detect new faults with introduced fault impact, e.g., the
null-pointer dereference shown in Figure 1. These faults are im-
possibletobeidentiﬁedusingtraditionalstaticdetectors;2)wecan
conﬁrmandprioritizerealfaultsbyrevealingtheirpotentialconse-
quences; and3)we can groupfaultsbasedon their causes.
Determining fault correlations in current static tools is challeng-
ing for three reasons. First, identiﬁcation of correlations of faults
requires knowledge of fault propagation, which only can be ob-
tained when program paths are considered; however, exhaustive
static analysis based on full path exploration is not scalable. An-
other reason is that most static tools only detect one type of fault,
while correlations often occur among faults of different types as
shown in the above example. Also, in order to statically compute
the propagation of a fault, the potential dynamic impact of a fault
needstobemodeled,whichistypicallynotdoneinthestatictools.
In this paper, we formally deﬁne fault correlation and develop
algorithmstodeterminecorrelationsinaprogram. Ourapproachis
toﬁrststaticallydetectfaultsandidentifytheerrorstatethatafault
potentiallyproduces. Wethenstaticallypropagatethepotentialdy-
namic impact of a fault along program paths. During propagation,
either a previously detected fault can be identiﬁed as being corre-
lated or with the introduced error state, another fault missed in thestatic detection can be discovered as part of correlation. We ap-
plyademand-driven analysistoaddressthescalability ofthepath-
sensitive analysis. The identiﬁed fault correlations are represented
in acorrelation graph .
We implemented our algorithm using an interprocedural, path-
sensitive, demand-driven static analysis framework. We selected
three types of faults, buffer overﬂow, integer error and null-pointer
dereference,ascasestudies. Inourexperiments,weshowthatcor-
relations commonly exist in real-world applications, and our al-
gorithm can automatically compute them. Using the correlation
informationrepresentedinthecorrelationgraph,weareabletoun-
derstandtheimpactoffaults,prioritizediagnostictasks,andgroup
faultsto speed updiagnosis.
To the best of our knowledge, our work is the ﬁrst that formally
deﬁnes and automatically computes fault correlations. The contri-
butionsofthe paper include:
•the deﬁnition and classiﬁcation offault correlations,
•theidentiﬁcationoftheusefulnessofcorrelationsinfaultdi-
agnosis,
•algorithms forautomatically computing correlations,
•correlation graphs that integrate fault correlations on differ-
ent paths andamong multiple faults, and
•experiments that demonstrate the common existence of fault
correlationsand the value ofidentifying them.
InSection2,wedeﬁnefaultcorrelation. InSection3,weexplain
how to compute correlations. Section 4 presents the correlation
graph. Section 5 gives experimental results. The related work is
compared in Section 6, followed bythe conclusionsin Section 7.
2. FAULT CORRELATION
We ﬁrst deﬁne program faults and fault correlation. We also
provide examples to demonstrate correlations.
2.1 Program Faults
Deﬁnition 1: Aprogram fault is an abnormal condition caused
by the violation ofarequired property at aprogram point.
The property can be speciﬁed as a set of constraints to which a
programhastoconform. Wefocusonthefaultscausedbyproperty
violations, where the violation can be observed at certain program
points. Those program points can be identiﬁed using code signa-
tures. Todetermineafault,werequireﬁndingatleastoneexecution
path that leads to the violation of constraints at the program point
ofinterest.
For example, buffer overﬂow can occur at any buffer access if
the length of the string is larger than the buffer size. An integer
overﬂowoccursatintegerarithmeticwhentheoutcomeofthearith-
metic is larger than the maximum value the destination integer can
store. For a data race to occur, the value of a shared variable at
its use must be inconsistent under different interleaving of threads.
Similarly, memory leaks occur if the allocated memory is never
released when the pointers are no longer alive or reassigned to an-
other part of memory. On the other hand, we do not consider a
missing statement or a misused variable as a fault in this paper, as
no property constraintsare violated at acertain program point.
Deﬁnition2: Theerrorstate ofafaultisthesetofdataproduced
at runtime asaresult ofproperty violations.
Intuitively, an error state is the manifestation of a fault. That
is, after executing a program statement, there exists a set of values
308fromwhichwecandeterminethatpropertyconstraintsareviolated
and a fault occurs. The set of values constitute an error state. If
a crash would occur, we consider the values that cause the crash
as the error state. We model the error state of a fault based on the
fault type using constraints. The modeling is empirical and based
on the common symptoms of faults a code inspector might use to
manually determine fault propagation.
Table 1: ErrorStateof CommonFaults
FaultType Code Signature ErrorState
bufferoverﬂow strcpy(a,b) len(a)>size(a)
integer overﬂow unsigned i=a+bvalue(i)==value(a)+
value(b)-C
integer int j...unsigned i=j value(i)>231-1
signedness unsigned i...int j=i value(j)< 0
integer truncation unsigned i...uchar j=i value(j)<value(i)
resourceleakSocket s=accept(); avail(Socket) ==
s=accept() avail(Socket)-1
Table 1 lists the error state for several common faults. Under
Code Signature , we give example statements where a certain type
offault potentially occurs. Under ErrorState ,weshowconstraints
about corrupted data at the fault. The type of corrupted data is
listedinbold. Theﬁrstrowofthetableindicatesthatwhenabuffer
overﬂow occurs, the length of the string in the buffer, len(a),
is always larger than the buffer size, size(a) . From the sec-
ond to fourth rows, we simulate the effect of integer faults. When
an integer overﬂow occurs, the value stored in the destination in-
teger,value(i) , should equal the result of integer arithmetic,
value(a)+value(b) ,minusatype-dependentconstant C,e.g.,
232. Similarly, when an integer signedness error occurs, we would
get an unexpected integer value. For example, when a signed inte-
gercaststounsigned,anyresultslargerthan 231−1(themaximum
valueasigned32bitintegerpossiblystores)indicatestheviolation
of integer safety constraints [4]. When an integer truncation oc-
curs, for instance, between ucharandunsigned as shown in
thetable,thedestinationintegerwouldgetasmallervaluethanthe
source integer. In the last row, we use a socket as an example to
show that when resource leaks occur, the amount of available re-
sources in the system is reduced, and we model the error state as
[avail(Socket)==avail(Socket)-1 ].
2.2 Correlation Deﬁnition
Suppose f1andf2are two program faults.
Deﬁnition 3: f1andf2arecorrelated if the occurrence of f2
along path pis dependent on the error state of f1. We denote the
correlation as f1→f2. Iff2only occurs with f1along path p, we
sayf1uniquely correlates withf2,denoted as f1u− →f2.
Theoccurrenceof f2alongpisdeterminedbythepropertycon-
straints on a set of variables collected along p. If such variables
arecontrolordatadependent[29]onthecorrupteddataattheerror
state of f1,f1andf2are correlated. Intuitively, given f1→f2,
f1occurs ﬁrst on the path, and the error state produced at f1prop-
agates along pand leads to the property violation at f2. Therefore,
f1andf2have a causal relationship. Given f1u− →f2,f1is a nec-
essary cause of f2, which means, if f1does not occur, f2cannot
occur. If the correlation is not unique, there is other cause(s) that
can lead to f2.
ConsiderFigure2(a)inwhichthevariable inputstoresastring
from the untrusted user. A correlation exists between the buffer
overﬂow at line 2 and the one at line 3, as there exists a valueﬂow
on variable a, shown in the ﬁgure, that propagates the error state
of the overﬂow at line 2 to line 3. When the ﬁrst buffer overﬂow
occurs, the second alsooccurs. Thefaultsare uniquely correlated.
(a) uniquely correlate via data
 (b) uniquely correlate via control
(c) correlate but not unique
 (d) not correlate
Figure 2: Deﬁning Fault Correlation: correlated faults are
marked with ×, error state is included in [ ], and corrupted
dataare underlined
In Figure 2(b), we show a correlation based on control depen-
dency between faults. The integer overﬂow at line 1 leads to the
buffer overﬂow at line 3, as the corrupted data, value(i) , pro-
duced at the integer fault impacts the conditional branch at line 2
(on which line 3 is control-dependent).
In Figure 2(c), buffer overﬂow at line 2 correlates with the one
at line 3. However, the ﬁrst overﬂow is not the only cause for the
second because when the overﬂow at line 2 does not occur, the
overﬂow at line 3 still can occur.
As a comparison, the two buffer overﬂows presented in Fig-
ure 2(d) are not correlated. At line 3, both the size of the buffer
and the length of the string used to determine the overﬂow are not
dependentonthecorrupteddata len(a) intheerrorstateatline2.
By identifying fault correlation, we can better understand the
propagation of the faults and thus fault behavior. We demonstrate
the value of fault correlations in two real-world programs. In the
ﬁrst example, we show given f1→f2, we can predict the conse-
quence of f1through f2, and prioritize the faults. The correlation
alsohelpsgroupandorderfaults,asinthecaseof f1u− →f2,ﬁxing
f1willﬁx f2. See Example 2.
Example1: Figure3presentsacorrelationfoundintheprogram
acpid-1.0.8 . Inthisexample,weshowhowafaultofresource
leakcancauseaninﬁniteloopandleadtothedenialofservice. The
code implements a daemon that waits for connection from clients
and then processes events sent via connected sockets. In Figure 3,
thewhileloop at node 1 can only exit at node 5, when an event
is detected by the poll() function at node 2 and processed by
the server. Correspondingly, along the paths /angbracketleft(1−4)∗,1−2,5/angbracketright,
the socketfdis created by the function ud_accept at node 3,
and released by clean_exit at node 5. However, if a user does
not send legitimate requests, the branch /angbracketleft2,3/angbracketrightis always taken, and
the created sockets at node 3 cannot be released. Eventually, the
listofsocketsin the systemiscompletely consumedandnosocket
is able to be returned from ud_accept at node 3. As a result,
the condition fd<0always returns true. The execution enters an
inﬁniteloop /angbracketleft(1−3)∗/angbracketright. Inthisexample,theimpactoftheresource
leak makes the execution always follow the false branch of node 2
and the true branch of node 3, causing the program to hang. With
faultcorrelationinformation,wecanautomaticallyidentifythatthe
root cause of the inﬁnite loop is the resource leak. To correct this
inﬁniteloop,wecanaddresourcereleasecodeintheloop,asshown
in the ﬁgure.
Example 2: Static tools potentially report many warnings for
309Figure3: Correlation of Resource Leakand Inﬁnite Loopinacpid
a program, especially when they analyze newly written code or
legacy but low quality code. Consider the example in Figure 4
frompolymorph-0.4.0 . There exist 7 buffer overﬂows in the
code, located at lines 2, 10, 12, 14, 16, 19 and 21. Although these
overﬂows are not all located in the same procedure and even the
buffers involved in the overﬂow are not all the same, we ﬁnd that
correlations exist among them. For example, the overﬂow at line 2
correlateswiththeoneatline16alongpath /angbracketleft1−7,16/angbracketright,andline16
correlateswith line 21along /angbracketleft16,17,21/angbracketright. We can groupthese cor-
relatedfaultsand diagnose themtogether.
1charfilename [2048];
2strcpy ( filename , FileData . cFileName );
3convert_fileName ( filename );
4
5voidconvert_filename ( char∗original ){
6charnewname[2048]; char∗bslash = NULL; . . .
7if(does_nameHaveUppers( original )){
8 for( i =0; i<strlen ( original ); i ++){
9 if( isupper ( original [ i ]))
10 { newname[ i ] = tolower ( original [ i ]);
11 continue ; }
12 newname[ i ] = original [ i ];
13 }
14 newname[ i ] = ’\0 ’ ;
15}
16elsestrcpy (newname , original );
17if( clean ){
18 bslash = strrchr (newname , ’ \\ ’ );
19 if( bslash != NULL) strcpy (newname , &bslash [1]);
20} . . .
21strcpy ( original , newname);
22}
Figure 4: Correlations of Multiple BufferOverﬂows inpolymorph
To further understand the correlations in real-world programs,
we conducted a study on 300 vulnerabilities in the Common Vul-
nerabilitiesandExposure(CVE)database[8],datedbetween2006-
2009. We manually identiﬁed fault correlations on 8 types ofcom-
mon faults, including integer faults, buffer bounds errors, derefer-
ence of null-pointers, incorrect free of heap pointers, any types of
resource leak, inﬁnite loops, race conditions and privilege eleva-
tions. Our study shows that correlations commonly exist in real-
world programs. In fact, the reports suggest that security expertsmanually correlate faults in order to understand the vulnerabilities
orexploits.
Table 2 classiﬁes the correlations we found. We mark ∗if the
fault listed in the row uniquely correlates with the fault in the col-
umn, and ×for correlations that are not unique. Comparing the
rows ofintandracein the table, we found that integer faults and
data race behave alike in correlations. Intuitively, both integer vi-
olation and data race can produce unexpected values for certain
variables, and thereby trigger other faults. From the study, we also
found that a fault can trigger different types of faults along differ-
ent execution paths and produce different symptoms. We mark /check
in the table if the faults from the column and row can be triggered
by the same fault along different paths.
Table 2: Typesof Correlated Faults Discovered inCVE
intbufnullptr freeleakloopraceprivilege
int ∗ ∗ × ∗ ∗ ∗∗ ×/check ∗
buf ∗ ∗ /check ∗ /check ∗
nullptr /check /check /check ∗
free ∗ /check ∗
leak ∗ ∗
loop /check∗ ×/check /check
race ∗ ∗ × ∗ ∗ ∗ ∗ ∗
privilege ×
3. COMPUTINGFAULT CORRELATION
In this section, we present an algorithm to statically compute
faultcorrelation. Theapproachhastwophases: faultdetectionand
faultcorrelation. Infaultdetection,wereportpathsegmentswhere
faults occur. In fault correlation, we model the error state of de-
tectedfaultsandsymbolicallysimulatethepropagationoftheerror
statealongprogrampathstodetermineitsimpactontheoccurrence
of the other faults. The goals of the second phase are to identify 1)
whetherafaultisacauseofanotherfaultdetectedintheﬁrstphase;
and2)whetherafaultcanactivatefaultsthathadnotbeenidentiﬁed
intheﬁrstphase. Asthedeterminationoffaultcorrelationrequires
pathinformation,weuseademand-drivenanalysis,whichhasbeen
shown to be scalable foravariety ofapplications [3,10, 22].
3.1 AnOverview
The steps for fault detection are shown on the left side of Fig-
ure 5. The demand-driven analysis ﬁrst identiﬁes program state-
ments where the violation of property constraints can be observed,
namely,potentiallyfaultystatements . Atthosestatements,theanal-
ysis constructs queries as to whether property constraints can be
satisﬁed. Each query is propagated backwards along all reachable
paths from where it is raised. Information is collected along the
propagation to resolve the query. If the constraints in the query are
resolved as false, implying a violation can occur, a fault is de-
tected. The path segments that produce the fault are identiﬁed as
faulty.
To improve the precision of the fault detection, we run an infea-
sible path detection using a similar query based algorithm, where
the query is constructed at a conditional branch as to whether the
outcome of the branch can always be true or false [3]. After the
infeasible paths are identiﬁed and marked on the interprocedural
controlﬂowgraph(ICFG)oftheprogram,werunvariousfaultde-
tectors. In the fault detection, when the query that is being used
to determine faults encounters an infeasible path, the propagation
terminates.
Challengesofdesigningsuchastaticfaultdetectorincludestrate-
gies for propagating queries and solutions for handling imprecise
310Figure5: Fault Detection and FaultCorrelation
sources to construct and resolve symbolic integer constraints. Our
querypropagationispath-sensitiveinthatqueriespropagatingfrom
branchesarenotmergedandconditional branchesthat are relevant
to the queries are collected. The analysis is also interprocedural
and context-sensitive. When a query arrives at a procedural call,
we perform a linear scan of the called procedure to determine if
the query can be updated. We only propagate the query into the
procedureifanupdateispossible. Wepropagatethequerythrough
the loop via two iterations to determine the potential update of the
queryintheloop. Iftheloophasnoimpactonthequery,thequery
advances out of the loop. If the iteration count of the loop and the
update of the query in the loop can be symbolically identiﬁed, we
update the query by adding the loop’s effect on the original query.
Otherwise, we introduce a “don’t-know” tag to record the impre-
cision. To handle the C structure and heap, we apply an external
pointer analysis, which is intraprocedural, ﬂow-sensitive and ﬁeld-
sensitive. Wealsointroduceanexternalconstraintsolvertoresolve
integerconstraintsstoredinthequery. Moredetailsofouranalysis
can be foundin our technical report [23].
In the analysis, we cache queries and the resolutions at state-
ments where the queries have been propagated. Both the cached
query and the identiﬁed path segments will be reused to compute
fault correlations. All the detected faults are checked for correla-
tionin the next phase.
Wedevelopedfourstepstodeterminethefaultcorrelation,shown
on the right in Figure 5. In the ﬁrst step, we model the error state
off1based on its fault type (see Table 1). The error state is in-
strumented on ICFG as a constraint. For example, for the integer
fault in Figure 1, we insert [ value(current_track)<0 ] at
node 2, and for the resource leak in Figure 3, we add at node 3
[avail(Socket)==avail(Socket)-1 ]. Next, we examine
whether the error state of f1can change the results of branch cor-
relationanalysis,asanupdateoftheconditionalbranchcanleadto
the change of feasibility, which then impacts the occurrence of f2.
Inthefollowingstep,wedeterminetheimpactof f1directlyon f2,
andﬁnally wecheck ifthe identiﬁed correlation isunique.
3.2 Examplesto FindCorrelations
Basedonthedeﬁnitionoffaultcorrelation,for f1→f2tooccur,
werequiretwoconditions: 1)thereexistsaprogrampath pthattra-
versesboth f1andf2;and2)along p,constraintsforevaluating f2
Figure 6: Correlation viaDirect Impact
aredependentontheerrorstateof f1. Inthissection,weuseexam-
ples to show how the steps of fault detection and fault correlation
presented in Figure5 proceed to determine the two conditions.
3.2.1 Correlation via Direct Impact on Faults
In Figure 6, we show an example on the left, and the actions
takenintheanalysisontheright. Under FaultDetection ,wepresent
the transitions of the query in fault detection phase. Each table de-
scribesthepropagationofaqueryalongonepath. Theﬁrstcolumn
ofthetablegivesthenodeswhereaquerypropagatedandupdated.
The second column lists the query after being updated and cached
at the node. In Table Q5, we show that, to detect integer over-
ﬂow, we identify node 5 as a potentially faulty statement and raise
the query [ value(i) *8<C] (Cis the type-dependent constant
232), inquiring whether the integer safety constraints hold. The
query is propagated backwards and resolved as falseat node 4
due to a user determined input i, shown in the second row of
TableQ5. Path /angbracketleft4,5/angbracketrightis thus determined as faulty and marked
on ICFG. The query is also propagated to node 3 and resolved
astrue(this path is not listed in the ﬁgure due to space limi-
tations). Similarly, to detect buffer overﬂows, we identify nodes
8, 10 and 11 as potentially faulty and raise queries to determine
their safety. Table Q8,Q10andQ11present the propagation of the
three queries. Take Q8as an example. At node 8, we raise an ini-
tial query [ value(i) ≤size(p) ], inquiring whether the buffer
constraints are satisﬁed. At node 6, the query is ﬁrst changed to
[8*value(i) ≤value(x) ]. A symbolic substitution at node 5
further updates the query to [ 8*value(i) ≤8*value(i) ]. We
thus resolve the query as trueand report the buffer at node 8
safe. In the fault detection phase, we identify three faults, an inte-
geroverﬂowatnode5,andbufferoverﬂowsatnodes10and11. We
determine in the next step whether the correlation exists for these
faults.
UnderFaultCorrelation inFigure6,welistthestepsforcomput-
ingcorrelations. Weﬁrstmodeltheerrorstate. Fortheintegerover-
ﬂow at node 5, we introduce [ value(x)==8 *value(i)-C ] as
an error state, shown in the ﬁrst box under Fault Correlation . We
italicizedvalue(x) to indicate it is the corrupted data at this
311Figure 7: Correlation viaFeasibilityChange
fault. Conceptually, we need to propagate the error state along
all program paths in a forward direction to examine if the cor-
rupted data value(x) can impact the occurrence of the faults at
nodes 8, 10 and 11. Since our analysis is demand-driven, to de-
termine such impact, we actually propagate the queries raised at
nodes 8, 10 and 11 in a backward direction toward the fault lo-
cated at node 5, and determine if the error state can update the
queries. As such backward propagation has been done in fault de-
tection, we can take advantage of cached queries to compute cor-
relation. In the ﬁgure, all queries listed in tables are cached in
the correspondent nodes after fault detection. From Table Q8, we
discoverthatattheimmediatesuccessor(s)oftheintegerfault,i.e.,
node6,query[ 8*value(i) ≤value(x) ]hasbeenpropagated
to and is cached. The query is dependent on the corrupted data
value(x) at the error state. We use a bold arrow in the ﬁgure
to show the dependency. The query is thus updated with the error
state and reaches a new resolution false. In this case we dis-
cover a fault that was not reported in fault detection. Using a sim-
ilar approach, we introduce the error state [ len(a)>128) ] after
node 10 for a buffer overﬂow. With this information, the query for
checking buffer overﬂow at node 11 is resolved to false. In this
case, two previously identiﬁed faultsare determined ascorrelated.
To determine f1u− →f2, we examine when f1is ﬁxed, whether
f2stillcanoccur. Asfor f1u− →f2,f1isthenecessarycauseof f2,
and ﬁxing f1ensures the correctness of f2. Our approach is to re-
placetheinsertederrorstatewiththeconstraintsthatimplythecor-
rectnessofthenode. Forexample,inFigure6,wereplacetheerror
stateatnode5with[ value(x)==8 *value(i) ],andatnode10
with [len(a) ≤128]. With the new information, node 8 is deter-
mined as safe, indicating the correlation of node 5 and node 8 is
unique, while node 11 still reports unsafe, showing the correlation
between nodes 10and11 isnot unique.
In our approach, the two conditions for determining fault corre-
lation are ensured by two strategies. First, in fault correlation, if
queriesareupdatedwiththeerrorstateof f1andstillnotresolved,
wecontinuepropagatingtheupdatedqueryalongthefaultypathof
f1, which assure f2andf1are located along the same path. For
instance, in the above example, if the buffer overﬂow query raised
atnode8isnotresolvedatnode5withtheerrorstate,itwouldcon-
tinuetopropagatealongpath /angbracketleft5,4/angbracketrightforresolution,astheerrorstate
is only produced along the faulty path /angbracketleft5,4/angbracketright. Second, we establishthe dependency between f2andf1by assuring the error state of
f1can update the queries of f2and the variables in the queries are
dependent onthe corrupted data in the error state.
3.2.2 Correlation via Feasibility Change
The error state of f1also can impact f2indirectly by changing
the conditional branches f2depends upon, shown in Figure 7. The
programisasimpliﬁedversionofFigure1. Under FaultDetection ,
we list the query transitions to detect infeasible paths and faults.
UnderFault Correlation , we show the query update in fault cor-
relation. In this example, our focus is to present how an integer
error found at node 3 changes the branch correlation at node 4 and
then impacts other faults. An error state [ value(i)<0 ] is mod-
eled after node 3. Examining cached query at node 4, we ﬁnd that
the error state can update the branch query [ value(i)>0 ] and
resolve it to false. The change of the resolution implies that the
path this query propagated along is no longer infeasible as identi-
ﬁed before. Therefore, all the queries that are control dependent
on this branch are potentially impacted, and we need to evaluate
all the queries cached at node 4 for new resolutions. For example,
we restart the query [ value(p) /negationslash=0] from node 4 and resolve it
at node 1 as false, and a null-pointer dereference is discovered.
Similarly, we restart the buffer overﬂow query [ value(i)>0 ] at
node 4, where we ﬁnd the query is resolved as falsewith the in-
formation from the error state. In this case, the error state of the
integer fault ﬁrst impacts the branch and activates the propagation
of the query at node 4; then the error state also has a direct impact
on the query andchanges its resolutionto false.
3.3 TheAlgorithm of FaultCorrelation
For identifying fault correlations, Algorithm 1 takes the inputs
icfgandn, where icfgrepresents the ICFG with fault detection
results(includingthecachedqueriesandmarkedfaultypaths),and
nis the node where the fault is detected. Our goal is to identify all
the correlationsforthe fault atnode n.
At line 1, we model the error state. For each query cached at
the immediate successor(s) of the fault, we identify queries that
are dependent on the error state. See lines 2–4. If the query is
resolved after updating with the error state, we add it to the set
of resolved queries Aat line 6. Otherwise, if the updated query
was used to compute faults, we add it to the list FQat line 7. If
the query was used to compute branch correlation, we add it to the
listIQat line 9. Lines 10–11 collect queries stored at the branch
q′.raise. The faults associated with these queries are potentially
impactedbythefeasibilitychange,andthusneedtobereevaluated.
After queries are classiﬁed to the lists FQandIQ, we compute
the feasibility change at line 16 using IQand then determine the
impact ofthe errorstate directly on the faultsatline 17using FQ.
Thedeterminationoftheresolutionsofupdatedqueriesisshown
inResolve at line 18. The analysis is backwards. At line 20, we
ﬁrst propagate the queries to the predecessors of the faulty node.
We then use a worklist to resolve those queries at lines 22–27.
Propagate atline29indicatesthatweneedtoonlypropagatethe
queriesalongfeasibleandfaultypaths. Afteraqueryisresolvedat
line 25, we identify paths and mark them on ICFG at line 28. For
branch query, they are adjusted infeasible paths, while for queries
to determine faults,the paths showwhere the correlationoccurs.
4. CORRELATION GRAPHS
Our algorithm computes the correlation between pairs of faults.
We integrate individual fault correlations in a graph representation
to present correlations among multiple faults and along different
paths forthe whole program.
312Input: ICFGwith fault detection results( icfg);
faulty node( n)
Output: Correlationsfor n
1er=ModelErrState (n);
2foreach m∈Succ(n) do
3foreach q∈Q[m]do
4 q′=UpdateWithErrState (er,q);
5 ifq′/negationslash=qthen
6 ifq′.an= resolved thenaddq′toA
7 else ifIsFaultQ( q’) thenaddq′toFQ
8 else
9 addq′toIQ
10 foreach x∈Q[q′.raise ]do
11 if IsFaultQ( x) thenaddxtoFQ
12 end
13 end
14end
15end
16Resolve(IQ)
17Resolve(FQ)
18Procedure Resolve(querylist Q)
19foreach q∈Qdo
20foreach p∈Pred(n) do Propagate (n,p,q)
21end
22while worklist /negationslash=∅do
23remove( i,q)from worklist
24UpdateQ( i,q)
25ifq.an= resolved thenaddqtoA
26else foreach p∈Pred(i) do Propagate (i,p,q)
27end
28IdentifyPath( A)
29Procedure Propagate (node i, node p,query q)
30if OnFeasiblePath( i,p,q.ipp)∧
31OnFaultyPath( i,p,q.fpp)then
32add (p,q)toworklist
Algorithm 1: ComputeFault Correlations
Deﬁnition 4 : Acorrelation graph is a directed and annotated
graph G= (N, E),where Nisasetofnodesthatrepresenttheset
of faults in the program and Eis a set of directed edges, each of
which speciﬁes a correlation between two faults. The entry nodes
in the graph are nodes that do not have incoming edges, and they
are the faults that occur ﬁrst in the propagation. The exit nodes are
nodeswithoutoutgoingedges,andtheyarethefaultsthatnolonger
further propagate. Annotations for a node introduce information
about a fault, including its location in the program, the type, and
the corrupted program objects at the fault if any. Annotations for
theedgespecifywhetherthecorrelationisuniqueandalsothepaths
where the correlation occurs.
The correlation graph groups faults of the related causes for the
program. The entry nodesofthe graph and the nodes whose corre-
lation are not unique should be focused to ﬁnd root causes. Using
thecorrelationgraph,wecanreducethenumberoffaultsthatneed
tobeinspectedinordertoﬁxallthefaults. InFigure8,weshowthe
correlation graphs for examples we presented before, Figure 8(a)
forFigure 1, 8(b) forFigure 3, and 8(c) forFigure 4.
InFigure1,wehaveshownacorrelationofintegerfaultandnull-
pointer dereference along path /angbracketleft1,2,5/angbracketright. Actually the integer fault
atnode2alsocorrelateswithabufferboundserroratnode5along
path˙
(1−5)+,1,2,5¸
. SeeFigure8(a). Ifthebufferboundserror
continues to cause privilege elevation, the correlation graph would
showachainofcorrelatedfaultstohelpunderstandtheexploitabil-
ity of the code. On the other hand, if both the null-pointer deref-
erence and buffer underﬂow at node 5 are reported via a dynamic
(a) graphforFigure1
 (b) graph forFigure 3
(c) graphfor Figure4
Figure 8: Correlation Graphs for Examples: + marks a corre-
lationthatisnot unique
detector, using the correlation graph, we are able to know the two
failures are attributable to the same root cause and can be ﬁxed by
diagnosingtheintegerfaultatnode2. Similarly,therelationshipof
the resource leak and inﬁnite loop shown in Figure 3 is depicted in
Figure 8(b).
The correlation graph in Figure 8(c) integrates all correlations
for 7 buffer overﬂows in Figure 4. To use this graph for diagnosis,
we start from the entry node of the graph, as it indicates the root
cause of all 7 correlated faults. Diagnosing the entry node we dis-
cover that when the input FileData.cFileName is copied to
thefilename bufferatline2,noboundscheckingisapplied. We
thus introduce a ﬁx for line 2. The correlation graph indicates that
allothercorrelatedfaultscanbeﬁxedexceptthefaultatline14,as
in the graph, the edge from the fault at line 2 to the fault at line 14
indicates the existence of an additional root cause. We thus diag-
nose line 14and introduce the second ﬁx.
5. EXPERIMENTALRESULTS
To demonstrate that we are able to automatically compute fault
correlationsandshowthatfaultcorrelationsarehelpfulforfaultdi-
agnosis,weimplementedourtechniquesusingMicrosoft’sPhoenix
framework [26] and Disolver constraint solver [16]. We choose
three types of common faults as case studies: buffer bounds error,
integer truncation and signedness errors, and null-pointer derefer-
ence. Intheexperiments,weﬁrstrunfaultdetectionandupdatethe
ICFG with faults detected. We model the error state of integer and
bufferfaultsusingtheapproachesshowninTable1andthendeter-
mine the fault correlation. It should be noted that although in our
experiments, we use our fault detector to identify faults and then
compute fault correlations, our technique is applicable when faults
areprovidedbyothertools. Weusedasetof9programsforexper-
imental evaluation: the ﬁrst ﬁve are selected from benchmarks that
are known to contain 1–2 buffer overﬂows in each program [24,
33]; the rest are deployed mature applications with a limited num-
ber of faults reported by our fault detector. The experimental data
aboutfaultcorrelationarepresentedinthefollowingfoursections.
The resultshave been conﬁrmed bymanual inspection.
313Table 3: AutomaticIdentiﬁcation of Fault Correlations
Benchmarks SizeFaultsfromDetection Fault Correlations Faults during
buf/corr int/corr ptr/corr int_int int_buf int_ptr buf_buf buf_int total Correlation
wuftp-1 0.4k 4/4 0 0 0 0 0 7 0 7 0
sendmail-6 0.4k 0 3/1 0 0 1 0 0 0 1 1 (buf)
sendmail-2 0.7k 4/4 0 1/0 0 0 0 3 0 3 0
polymorph-0.4.0 1.7k 8/8 0 0 0 0 0 13 0 13 0
gzip-1.2.4 8.2k 9/9 15/7 0 0 7 0 9 6 22 1 (buf)
ffmpeg-0.4.8 39.8 k 0 6/2 1/0 0 10 1 0 0 1111(1ptr, 10buf)
putty-0.56 66.5 k 7/6 4/2 0 3 3 0 4 0 105 (3int,2 buf)
tightvnc-1.2.2 78.9 k 0 11/8 0 9 8 0 0 0 177 (2int,5 buf)
apache-2.2.4 418.8k 0 2/0 5/0 0 0 0 0 0 0 0
5.1 Identiﬁcationof FaultCorrelations
Intheﬁrstexperiment,weshowthatfaultcorrelationscanbeau-
tomatically identiﬁed. Table 3 displays identiﬁed correlations. In
theﬁrsttwocolumnsofthetable,welistthe9benchmarkprograms
and their sizes in terms of lines of code. Under Faults from Detec-
tion, we display the number of faults identiﬁed for each program
in our fault detection. Buffer bounds errors are reported in Col-
umnbuf/corr. Integer faults are listed in Column int/corrand the
null-pointer dereferences are shown in Column ptr/corr. In each
column, the ﬁrst number gives the identiﬁed faults and the second
lists the number of detected faults that are involved in fault corre-
lation. Our fault detector reports a total of 80 faults of three types,
51ofwhich are involved in fault correlation.
UnderFault Correlations , we list the number of pairs of faults
in the program that are found to be correlated. For example, under
int_buf, we count the pairs of correlated faults where the cause is
an integer fault, which leads to a buffer overﬂow. Comparing the
integer faults involved in the correlations under int_bufandint_ptr
with the ones found in fault detection, we can prioritize the integer
faults with severe symptoms. In the last column of Fault Corre-
lations, we give a total number of identiﬁed correlations. In our
experiments, we found fault correlations for 8 out of 9 programs.
Correlations occur between two integer faults, an integer fault and
a buffer overﬂow, an integer fault and a null-pointer dereference,
two buffer overﬂows, as well as a buffer overﬂow and an integer
fault.
The experiments also validate the idea that the introduction of
error states can enable more faults to be discovered. We identify
a total of 25 faults during fault correlation from 5 benchmarks, in-
cluding buffer overﬂows, integer faults, and null-pointer derefer-
ences, shown under Faults during Correlation .
Consider the benchmark gzip-1.2.4 as an example. We dis-
cover a total of 25 faults and 22 pairs of them are correlated. A
new buffer overﬂow is found after introducing the impact of an in-
teger violation. Buffer overﬂow correlates with integer fault when
strlen is called on an overﬂowed buffer which later is assigned
to a signed integer without proper checking. We also found that
the new faults generated during fault correlation can further corre-
late with other faults. In putty-0.56 , two integer faults found
duringfaultcorrelationresultedfromanotherintegerfaultarecon-
ﬁrmed to enable a buffer overﬂow. The propagation of these faults
explainshow the buffer overﬂow occurs.
5.2 Characteristicsof FaultCorrelations
Wealsocollectedthedataaboutthecharacteristicsoffaultcorre-
lations,showninTable4. InColumn Unique/Not ,wecount,forall
the correlations identiﬁed, how many are uniquely correlated (see
theﬁrstnumberinthecolumn)andhowmanyarenot(seethesec-
ond number). The data demonstrate that both types of correlations
existinthebenchmarks. Column Dir/Indir showswhetheracorre-lationoccursdirectlybetweentwofaultsorindirectlyasaresultof
feasibilitychange. Theﬁrstnumbersummarizesthedirectcorrela-
tions and the second number counts the indirect ones. The results
showthatmostcorrelationsarediscoveredviadirectqueryinterac-
tions,andonlytwoprogramsreportthecorrelationsidentiﬁedfrom
feasibility change. We also investigated the distances between the
correlatedfaults. Theexperimentaldataunder Inter/Intra showthat
along the correlated paths, the two faults can be located either in-
traprocedurally or interprocedurally. Therefore an interprocedural
analysis is required for ﬁnding all correlations. A related metric is
thedistanceofcorrelatedfaultsalongthecorrelationpathsinterms
of number of procedures. Column Corr-Proc gives both the mini-
mumandmaximumnumbersofproceduresbetweentwocorrelated
faults in the benchmark. We are able to ﬁnd the correlation where
two faultsare 19procedures apart.
Table 4: Characteristics of Fault Correlations
Benchmarks Unique/Not Dir/Indir Inter/Intra Corr-Proc
wuftp-1 4/3 7/0 7/0 1–10
sendmail-6 1/0 1/0 0/1 1–1
sendmail-2 0/3 3/0 0/3 1–1
polymorph-0.4.0 11/2 13/0 8/5 1–3
gzip-1.2.4 12/10 21/1 15/7 1–19
ffmpeg-0.4.8 11/0 1/10 0/11 1–1
putty-0.56 10/0 10/0 2/8 1–3
tightvnc-1.2.2 14/3 17/0 16/1 1–2
5.3 ComputingCorrelation Graphs
A correlation graph is built for each benchmark in the experi-
ments. In Table 5, we report the total number of nodes in the cor-
relationgraphinColumn Node. Thenodesincludefaultsidentiﬁed
from fault detection and fault correlation. The types of identiﬁed
faults are listed in Column Type. For example, for the program
ffmpeg-0.4.8 , we ﬁnd faults of all three types. In Column
Group, we provide the number of groups of correlated faults for
each program. We obtained the number by counting the connected
components in each correlation graph. The results show that al-
though the number of faults can be high in a program, many of the
faults can be grouped and diagnosed together. For 7 out of 9 pro-
grams, the faults are clustered to less than a half of fault groups
which willassistdiagnosis.
UnderAnalysisCost ,we report the analysis costsforcomputing
correlationgraphs,includingthetimeusedfordetectingfaults(see
the ﬁrst number in the column) and the time used for computing
fault correlations (see the second number). The machine we used
to run experiments is the Dell Precision 490, one Intel Xeon 5140
2-core processor, 2.33 GHz, and 4 GB memory. The experimental
data show that the analysis cost for fault detection is not always
proportional to the size of the benchmarks; the complexity of the
314code also matters. For example, the analysis for sendmail-6
takes a long time to ﬁnish because all the faults are related to sev-
eral nested loops. The additional costs of computing fault corre-
lations for most of the benchmarks are under seconds or minutes,
except forgzip-1.2.4 , which contains the most faults among
the benchmarks and many faults are found to impact a large chunk
of the code in the program. The data suggest that the important
factors that determine the analysis cost of fault correlation are the
number offaultsand the complexity oftheir interactions.
Table 5: Correlation Graphs and theirAnalysis Costs
Benchmarks SizeNodeTypeGroup Analysis Cost
wuftp-1 0.4 k 4113.9 m/43.2 s
sendmail-6 0.4 k 423108.0 m/5.6 s
sendmail-2 0.7 k 52210.8s/3.7 s
polymorph-0.4.0 1.7 k 81139.4s/9.3 s
gzip-1.2.4 8.2 k 252929.3m/90.0 m
ffmpeg-0.4.8 39.8k 1837114.2 m/3.4 m
putty-0.56 66.5k 162762.8m/1.2 m
tightvnc-1.2.2 78.9k 182660.3m/2.4 m
apache-2.2.4 418.9 k 727217.8 m/2.1 s
5.4 False Positives andFalse Negatives
Inourexperiments,bothfalsepositivesandfalsenegativeshave
been found. Because we isolate don’t-know warnings for unre-
solved library calls, loops and pointers, our analysis does not gen-
erate a large number of false positives. In fault correlation, we
consider the following two cases as false positives: 1) at least one
of the faults involved in correlation is false positive; and 2) both
faults in the correlation are real faults, but they are not correlated.
In our buffer overﬂow detection, we report a total of 7 false pos-
itives for all programs, 1 from sendmail-6 , 4 fromgzipand
2 fromputty. For integer fault detection, we report a total of
10 false positives, 3 from sendmail-6 , 2 frompolymorph , 2
fromffmpeg, 1 fromputtyand 2 from apache. We ﬁnd 25
correlations reported are actually false positives, 23 of which are
related to case (1), and 2 to case (2) where the correlation paths
computed are conﬁrmed as infeasible. However, we did not ﬁnd
that any new faults reported during fault correlation (see the last
columninTable3)arefalsepositives. Interestingly,wefoundfalse
positivefaultscancorrelatewitheachotherandthusbegrouped. In
our implementation, we have applied such correlations to quickly
remove false positives and improve the precision of our analysis.
We exclude the false positives when reporting the faults and fault
correlationsin Tables 3, 4 and 5.
Wemissfaultcorrelationsmainlyintwocases: 1)wereportcor-
relatedpathsbetweentwofaultsasdon’t-know;and2)thecorrela-
tionoccursamongthetypesoffaultsnotinvestigatedinourexper-
iments. Forexample,inthebenchmark tightvnc-1.2.2 ,three
integer faults are reported as not correlated, shown under Faults
from Detection in Table 3; however, our manual inspection discov-
ers that these faults can cause buffer read overﬂow, which was not
consideredin our fault detection.
6. RELATED WORK
Fault correlations identify a causal relationship between faults.
The key idea for computing correlations is to statically simulate
the propagation of a potential error state of a fault along program
paths. Researchinfaultpropagationhasbeendoneforsoftwarese-
curity [6, 13]. To understand the severity of certain types of static
faults, Ghosh et al.injected faults in programs and dynamically
triggeredfaultstoobservetheirpropagationandimpact[13]. Chenet al.discovered that a successful attack performs a set of stages.
Theﬁnitestatemachinescanbeusedtomodeltheactivitiesateach
stage [6]. Similar to our research, both of the above works empha-
size the importance of fault propagation. However, Ghosh et al.
obtained fault propagation by running the program, and thus the
numberofpathsthatcouldbeexploredwaslimitedbytheprogram
inputs, while Chen et al.manually identiﬁed fault propagation.
Fault propagation is also useful for software debugging. Using
dynamic tainting, Clause et al.isolated the input that potentially
causes failure [7]. Their interest was to ﬁnd the part of program
input that has dependencies with the error state.
Faultrankingaimstoprioritizerealandimportantfaultsforstatic
warnings. Often, many factors can indicate the importance of a
warning, such as the complexity of the code where the warning is
reported or the feedback from code inspectors. Ruthruff et al.de-
velopedlogisticregressionmodelstocoordinatethosefactors[27].
Kremenek etal.observedthatwarningscanbeclusteredinthatei-
ther they were all false positives or were real faults. Thus diagnos-
ingonecanpredicttheimportanceofotherfaultsinthecluster[20,
21]. Heckman etal.identiﬁedalertcharacteristicsandappliedma-
chinelearningtechniquestoclassifyactionableandnon-actionable
static warnings [18]. Compared to the above works which are all
basedonempiricalobservations,ourapproachstaticallygroupsand
orders faults based on the inherent causality between faults, and
thus is generally applicable.
Research in fault localization aims to automatically identify the
root cause of faults. Ball et al.developed a localization tech-
nique for error traces generated from the model checker. The key
was to identify the transitions that only appear in error traces but
not correct traces [2]. There are also the approaches of delta de-
bugging [31], dynamic value replacement [19] and coverage based
faultlocalization[32];however,thoseapproachesareonlyapplica-
ble when the inputsthat trigger the faultsare available.
Research efforts have been reported on a different type of corre-
lation in the testing area. The focus of one effort was to discover
how an error can potentially mask another and impact testing cov-
erage [30]. Another study investigated how to propagate an error
to the output of the program so that its consequence can be ob-
served[14]. Althoughbothourresearchandtheirresearchexplored
the relationships of software defects, the faults we focused on are
different from the errors studied in their work. Our work is set in
thedomainofstaticallyidentiﬁablefaults,whiletheirworkfocused
on errorsin testing.
In prior work, other types of correlations have been proposed.
Muelleret al.developed compiler optimizations based on branch
correlation [25], while Bodik et al.identiﬁed infeasible paths us-
ing branch correlation [3]. ESP made the assumption that there
exist correlations between the outcome of branches and property
states,basedonwhich,apath-sensitiveprogramveriﬁcationcanbe
optimized to linearcomplexity [9].
7. CONCLUSIONS
As faults become more complex, manually inspecting individ-
ual faults becomes ineffective. To help with diagnosis, this paper
shows that identifying a causal relationship among faults helps un-
derstand fault propagation and group faults of related causes. With
thedomainbeingstaticallyidentiﬁablefaults,thispaperintroduces
deﬁnitions of fault correlation and correlation graphs, and presents
algorithms for their computation. Our experiments demonstrate
thatfaultcorrelationsexistinreal-worldsoftware,andwecanauto-
matically identify them. The benchmarks used in our experiments
arematureapplicationswithfewfaults. However,determiningcor-
relation is especially important for newly developed or developing
315software which would have many more faults. Although the fault
correlation algorithm is tied to our fault detection for efﬁciency, a
slightlymodiﬁedcorrelationalgorithmwouldworkiffaultsaredis-
covered byother toolsand presented to the correlation algorithm.
8. REFERENCES
[1] Personal communication with MingdongShang, Code
Reviewer at Microsoft,2006.
[2] T. Ball,M. Naik, and S.K. Rajamani. Fromsymptomto
cause: localizing errors in counterexample traces. In
Proceedings of the 30th ACMSIGPLAN-SIGACTsymposium
on Principlesof programming languages , 2003.
[3] R.Bodik,R.Gupta, andM. L. Soffa. Reﬁningdata ﬂow
information usinginfeasiblepaths.In Proceedings of the
ACM SIGSOFT International Symposium on Foundationsof
SoftwareEngineering , 1997.
[4] D. Brumley,T.Chiueh, R.Johnson,H. Lin,andD. Song.
RICH: Automatically protecting againstinteger-based
vulnerabilities. In Symposium onNetwork and Distributed
Systems Security , 2007.
[5] W. R.Bush,J.D. Pincus, andD. J.Sielaff. Astatic analyzer
forﬁnding dynamic programmingerrors. SoftwarePractice
and Experience , 2000.
[6] S. Chen,Z. Kalbarczyk, J.Xu, andR.K. Iyer. Adata-driven
ﬁnite state machine model foranalyzing security
vulnerabilities. InInternational Conference on Dependable
Systems and Networks ,2003.
[7] J.Clauseand A. Orso. Penumbra: automatically identifying
failure-relevant inputsusingdynamic tainting. In
Proceedings of the eighteenth international symposiumon
softwaretesting and analysis ,2009.
[8] CVE.http://cve.mitre.org/ .
[9] M. Das, S.Lerner,and M.Seigle. ESP:path-sensitive
program veriﬁcation in polynomial time. In Proceedings of
the ACMSIGPLAN2002 Conference onProgramming
language designand implementation , 2002.
[10] E. Duesterwald, R.Gupta, and M. L.Soffa. Apractical
framework fordemand-driven interprocedural data ﬂow
analysis.ACMTransactions onProgramming Languages
and Systems ,1997.
[11] D. Evans. Staticdetection ofdynamic memory errors.In
Proceedings of the ACMSIGPLAN1996 Conference on
Programming Language Design and Implementation , 1996.
[12] FindBugs.http://ﬁndbugs.sourceforge.net/.
[13] A. K. Ghosh, T.O’Connor,and G. Mcgraw. An automated
approach foridentifying potential vulnerabilities in software.
In1998 IEEESymposium onSecurity and Privacy ,1998.
[14] T. Goradia. Dynamic impact analysis: acost-effective
technique to enforce error-propagation. SIGSOFT Software
Engineering Notes ,1993.
[15] B.Hackett, M.Das, D. Wang, andZ. Yang. Modular
checking forbuffer overﬂows in the large. In Proceeding of
the 28th International Conference onSoftwareEngineering ,
2006.
[16] Y. Hamadi. Disolver: ADistributedConstraintSolver.
Technical ReportMSR-TR-2003-91,Microsoft.
[17] L.Hatton.Testingthevalueofchecklistsincodeinspections.
IEEESoftware ,2008.
[18] S. Heckman and L. Williams.A model building processfor
identifyingactionablestaticanalysisalerts.In Proceedingsofthe 2009International Conference onSoftwareTesting
Veriﬁcation and Validation , 2009.
[19] D. Jeffrey,N. Gupta, and R.Gupta. Fault localization using
value replacement. In Proceedings of the 2008 international
symposium onSoftwaretesting and analysis ,2008.
[20] T.Kremenek, K. Ashcraft, J.Yang, andD. Engler.
Correlation exploitation in errorranking. SIGSOFT Software
Engineering Notes ,2004.
[21] T.Kremenek andD. Engler.Z-ranking: Using statistical
analysis to counter the impact ofstatic analysis
approximations. In Proceedings of the 10th International
Static AnalysisSymposium , 2002.
[22] W. Le and M. L. Soffa. Marple: ademand-driven
path-sensitive bufferoverﬂow detector. In Proceedingsof the
16th ACMSIGSOFT International Symposium on
Foundations of softwareengineering , 2008.
[23] W. Le and M. L. Soffa. General, scalable path-sensitivefault
detection. Technical ReportCS-2010-11by Computer
Science Department, University of Virginia ,2010.
[24] S.Lu,Z.Li,F.Qin, L.Tan,P.Zhou,andY.Zhou.Bugbench:
Benchmarks forevaluating bugdetection tools. In
Proceedings of Workshop onthe Evaluation of Software
Defect Detection Tools ,2005.
[25] F.MuellerandD.B.Whalley.Avoidingconditionalbranches
by code replication. In Proceedingsof the ACMSIGPLAN
1995 conference onProgramming language design and
implementation , 1995.
[26] Phoenix.
http://research.microsoft.com/phoenix/ .
[27] J.R.Ruthruff,J.Penix,J.D. Morgenthaler, S.Elbaum, and
G. Rothermel. Predicting accurate and actionable static
analysis warnings: an experimental approach. In
Proceedings of the 30th international conference on
Softwareengineering , 2008.
[28] B.Schwarz,H.Chen,D.Wagner,J.Lin,W.Tu,G.Morrison,
and J.West.Model checking an entirelinux distributionfor
securityviolations. In Proceedingsof the 21st Annual
ComputerSecurity ApplicationsConference , 2005.
[29] G. Snelting. Combining slicing andconstraint solving for
validation ofmeasurement software. In Proceedingsof the
Third International Symposium on StaticAnalysis ,1996.
[30] K. Wu andY. Malaiya. Theeffect ofcorrelated faultson
software reliability. In Proceedings of SoftwareReliability
Engineering, 4thInternational Symposium on , 1993.
[31] A. Zeller.Yesterday, myprogram worked. today, itdoes not.
why?SIGSOFT SoftwareEngineering Notes ,1999.
[32] Z. Zhang, W. K. Chan,T.H. Tse, B.Jiang,and X. Wang.
Capturingpropagation ofinfected program states. In
Proceedings of the 7th joint meeting of the European
softwareengineering conference and the ACMSIGSOFT
symposium , 2009.
[33] M. Zitser,R.Lippmann, and T.Leek.Testing static analysis
tools usingexploitable buffer overﬂows from open source
code.InProceedingsofthe12thInternationalSymposiumon
Foundations of SoftwareEngineering ,2004.
316