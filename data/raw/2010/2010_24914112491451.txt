Distributed Program Tracing
DiptikalyanSaha
IBMResearch,India
diptsaha@ibm.in.comPankajDhoolia
IBMResearch,India
pdhoolia@ibm.in.comGaurabPaul
IITKharagpur,India
gpaul.tech@gmail.com
ABSTRACT
Dynamicprogramanalysistechniquesdependonaccurateprogram
traces. Program instrumentation is commonly used to collect these
traces, which causes overhead to the program execution. Various
techniqueshaveaddressedthisproblembyminimizingthenumber
ofprobes/witnessesusedtocollecttraces. Inthispaper,wepresent
a novel distributed trace collection framework wherein, a program
is executed multiple times with the same input for different sets
of witnesses. The partial traces such obtained are then merged to
create the whole program trace. Such divide-and-conquer strategy
enables parallel collection of partial traces, thereby reducing the
total time of collection. The problem is particularly challenging
as arbitrary distribution of witnesses cannot guarantee correct for-
mation of traces. We provide and prove a necessary and sufﬁcient
condition for distributing the witnesses which ensures correct for-
mation of trace. Moreover, we describe witness distribution strate-
gies that are suitable for parallel collection. We use the framework
to collect traces of ﬁeld SAP-ABAP programs using breakpoints
as witnesses as instrumentation cannot be performed due to practi-
calconstraints. Tooptimizesuchcollection,weextendBall-Larus’
optimal edge-based proﬁling algorithm to an optimal node-based
algorithm. We demonstrate the effectiveness of the framework for
collecting traces of SAP-ABAP programs.
Categories and Subject Descriptors
D.2.5 [Testing and Debugging]: Tracing; F.3.2 [Semantics of
Programming Languages]: Program analysis
General Terms
Algorithms, Performance
Keywords
Parallel,Distributed,ProgramTracing,PathCollection,Divideand
Conquer
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bearthisnoticeandthe fullcitationontheﬁrstpage. Tocopyotherwise,to
republish,topostonserversortoredistributetolists,requirespriorspeciﬁc
permission and/or a fee.
ESEC/FSE’13, August 18–26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08 ...$15.00.1. INTRODUCTION
In recent times many efﬁcient and accurate path based analysis
have been developed in the application areas of program compre-
hension, debugging, bug reproduction, test case generation, fault
localization, veriﬁcation, and more recently fault repair. Many
analysis such as path differencing, concolic evaluation, dynamic
tainting, and dynamic slicing require exact program path, whereas
many compiler optimizations require path proﬁles. Because of
its widespread usage, partial and full trace collection problem is
widelystudiedandefﬁcientalgorithmshavebeendevelopedtoad-
dress the overhead of trace collection.
Essentially there are three kinds of techniques for trace collec-
tion.Instrumentationapproaches [1] insert logging instructions in
the source/byte-code/binary representation of the program.Ker-
nel/OS level tracingtechniques [16, 12] store a log of kernel level
events.In situ debuggingtechniques [9, 24] attach a separate de-
bugger program to the target program and then allow interactive
governance of the target program’s execution by stepping through
instructionbyinstruction,orusingbreakpoints. Alltheseapproaches
essentially inspect a subset of program’s run-time behaviors. Fol-
lowing Ball-Larus [1], we use the termwitnessto denote the set of
entities in the static programs that are used to monitor their run-
time behavior. Each such witness1can occur multiple times in the
execution trace.
Addition of witnesses to monitor program’s run-time behavior
results into run-time overhead during the execution of the targeted
software. For example, Liblit et al. report an overhead ranging
from 2% to 181% on various benchmarks proﬁling assertion invo-
cations [14], and in a study Diep et al. reported an overhead of
150% to capture call chains [5]. Lowering such overhead is partic-
ularlyimportantforproﬁlingsoftwareintheﬁeldwhereitcanhave
a direct impact on the user.
Existing works on trace collection present algorithms for opti-
mizing the cost of trace collection by reducing the amount of wit-
nesses, or placing the witnesses in lower execution frequency code
regions to reduce the overhead of collection. In this context, Ball-
Larus in their seminal work [1] presented algorithms for minimal-
cost tracing problem. Their solution improved over the existing
solutions of placing witnesses in all basic blocks, and witnesses in
conditional targets. They provided an edge-based solution which
identiﬁesanoptimalsetofcontrolﬂowgraphedgestobewitnessed
for trace collection.
An approach to reduce the overhead of proﬁling software is to
leverage multiple variants of the same software running at several
1In the literature various terms such as logging instruction, probe,
monitor, and witness have been used to describe the static entities
whoseoccurrencesareinspectedatrun-timetoderivefullorpartial
tracesPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE’13 , August 18–26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2491451
180
sites, where each variant contains a subset of witnesses, and where
thesubsetsizecanbeboundedtomeettheoverheadtolerancelim-
its [6, 18]. Diep et al. [5] have considered the problem of distribu-
tion of witnesses across variants that maximizes the likelihood of
capturingarepresentativepartoftheprogrambehaviorexercisedin
the ﬁeld. These techniques have been used to obtain proﬁle infor-
mation that are order-independent on various runs of the software.
For examples, these techniques are not adequate to obtain a com-
pleteexecutionpathofaprogram,whichcanbeusedindebugging
ﬁeld failures.
In this paper, we introduce a novel framework for distributed
trace collection which creates multiple sets of witnesses. For each
set of witnesses, the program is executed (with same input) and
partial trace is collected. All partial traces are merged together to
produce the trace of the program. Such a framework enables faster
trace collection using parallelism as partial traces can be collected
in parallel. To our knowledge this is the ﬁrst approach for parallel
trace collection.
This work also addresses the problem of overhead of trace col-
lection in the ﬁeld/production systems which do not allow instru-
mentation for trace collection. Instrumentation by a user agent to
the production software can change the intended functionality of
the software e.g. Heisenbugs [8], or log sensitive information. In
these cases, only a system provided utility may be permitted to de-
bug the code. The debugger may be used to automatically obtain
the trace by setting breakpoints as witnesses and controlling/log-
ging the debugger events like breakpoint stops. However, auto-
mated breakpoint based collection is slow. Such a slow debugger-
based collection is seen in SAP-ERP system for collecting ABAP
program traces [21]. Effective application of our framework for
breakpointbasedtracecollectioninSAP-ABAPsystemrequiredto
extend the Ball-Larus’s optimal edge-based proﬁling algorithm to
node-based proﬁling.
Thedistributedtracecollectionframeworkusesadivideandcon-
quer strategy to collect the entire execution path. The program is
run multiple times, each with a different set of witnesses. We call
thesetofwitnesses,aproﬁle,andthesetofalltheproﬁles,aproﬁle
distribution. For each proﬁle, an execution of the program gener-
ates a partial path. We call a proﬁle distributionrealizableif it is
possible to reconstruct the execution path (for all possible inputs)
by merging all the partial paths.
Thechallengeofeffectivedistributedpathcollectionistwofold.
First, an arbitrary distribution of witnesses into proﬁles does not
guaranteeformationoftheexecutiontracebymergingpartialpaths.
Therefore,anecessaryandsufﬁcientconditionforarealizablepro-
ﬁle distribution needs to be formulated. Second, the objective of
minimizing the collection time for entire execution path, depends
onoptimizingtheproﬁledistributionfortheavailablemachinesfor
parallel collection.
The techniques presented in this paper address the challenges
discussed above. The contributions of this paper are summarized
below.
•We introduce a novel distributed trace collection framework
where the trace of a terminating program is collected using
a divide and conquer strategy. This is applicable for both
instrumentation and debugger based trace collections.
–We show that arbitrary distribution of witnesses (edge-
basedornode-based)doesnotguaranteerealizabledis-
tribution(Section2). Tosolvethisproblemweprovide
anecessaryandsufﬁcientconditionforarealizabledis-
tribution. This is, in fact, the basis of our framework
(Section 4.1).b1
b2
b3 b4
b5entry
2
1 1
1 12
exit22entry, b1, b2, b5 b3, exit b4
b5
b1
b2
b5b2b1
b1entry b4 b3
exit
Figure 1: Example control ﬂow graph with witness based on
basic-blockstrategyandpartialpaths. Bolddotsrepresentwit-
nesses.
–We prove that optimal parallel distribution is an NP-
Complete problem by reducing the problem of multi-
processor scheduling problem. We further discuss sev-
eral strategies of forming proﬁle distributions and pro-
vide a generic algorithm for proﬁle distribution (Sec-
tion4.2). Wealsoconsidertheproﬁledistributionwhen
each proﬁle size is bounded.
–We provide an algorithm to reconstruct an execution
trace from the partial paths (Section 4.3).
•We extend the Ball-Larus’ solution for optimal edge-based
tracing problem to optimal node-based tracing. Such a solu-
tion is particularly useful for breakpoint based path collec-
tion (Section 5).
•We demonstrate the effectiveness of our solution for break-
point based collection of traces for SAP-ABAP programs.
Parallel trace collection reduces the entire collection time
by3foldsincomparisontonon-distributedtechniques(Sec-
tion 6).
2. MOTIVATING EXAMPLES
We now illustrate the challenges of realizable and effective dis-
tributed trace collection with the help of some examples.
Consideradistributionofthebasicblockproﬁle(allbasicblocks
contain witnesses) of the control ﬂow graph shown in Figure 1.
Theoverallsetofwitnesses{entry,b1,b2,b3,b4,b5,exit}issuf-
ﬁcient to observe the execution path. Now assume that a particu-
lar proﬁle distribution is:{{entry,b1,b2,b5},{b3,exit},{b4}},
and the respective partial paths observed for each execution, are as
shown in the ﬁgure. In this execution the loop has executed twice,
and each time it has taken a different target of the conditionalb2.
However, looking at the partial path traces it is not possible to de-
termine the execution order ofb3andb4. This example illustrates
that arbitrary distribution of witnesses is not sufﬁcient for whole
path reconstruction.
Notethattheproblemwitharbitrarydistributionillustratedinthe
exampleofFigure1isnotduetothechoiceoftheinitialsetofwit-
nesses to distribute. If instead of distributing the basic block based
set of witnesses, an optimized set of witnesses{b3,b4}was dis-
tributed into two different proﬁles{{b3},{b4}}, the partial traces
would have been as shown in Figure 2. Obviously, in this case as
well, it is not possible to infer the execution order ofb3andb4by
looking at the partial traces.
Also note that another naive distribution strategy such as club-
bingwitnessesbyfunctions,togetherintoaproﬁle,willalsoleadto181b1
b2
b3 b4
b5entry
2
1 1
1 12
exit22b4 b3
b3 b4
Figure 2: Example control ﬂow with optimal witness proﬁle
and partial paths
b2
b3 b4
b5b1entry
2
exit22b4 c1
b4 c1entry
exit2
1 1
1 12
c1
r1foo
bar
c12
22Figure 3: Example ICFG and partial paths
the same problem. In Figure 3 a functionbaris called at location
c1infooand is returned atr1. The two proﬁles in a distribution
{{c1},{b4}}aresufﬁcienttodisambiguatepathsconsideredatthe
level of each function in isolation. However the partial paths may
not be merged to infer the execution order of theb3andb4while
constructing the entire execution path.
In Section 4, we present the necessary and sufﬁcient condition
for realizable distribution. A simple manifestation of such condi-
tion called function-wise grouping strategy. In this strategy each
function is assigned to a proﬁle. The proﬁle contains a set of wit-
nesses that can determine all paths through the function. This will
prohibit intra-procedural problems described in Figures 1 and 2.
Additionally,functionsthatcanbecalledmultipletimes,haveextra
witnesses in its proﬁle to have at-least one witness in each execu-
tion path from entry to exit. For example, in Figure 3, the function
barcanhaveanotherwitnessatanynodeinadditiontob4tocover
thepathfromentrytoexitthroughb3. Presenceofsuchawitness
in the same witness set asb4guarantees to resolve the relative or-
der ofb3andb4in inter-procedural calls to functionbaras in the
example of Figure 3.
Eventhoughtheabovestrategysolvestherealizabledistribution
problem,itmaynotbeeffectiveinallcasesforreducingtheoverall
tracecollectiontime. Thetimeforparalleltracecollectiondepends
on the maximum time taken by any machine. The trace collection
time in any machine is proportional to the number of witnesses hit
intheactualrun. Thenumberofhitsdependsonthewitnesschoice
and actual execution path for the run. Optimal tracing algorithms
like Ball-Larus, approximate the behavior of the run by assigning
frequencies or weights to edges or vertices of control ﬂow graph.
Such weightings can be obtained either by empirical measurement
(proﬁling) or by estimation. Such proﬁling helps to put witnessesinlowerexecutionfrequencyarea. Thus,inanymachine,witnesses
are chosen to minimize the sum of weights of the witnesses.
Ball-Larus present an optimal edge-witness based algorithm to
minimize the total witness weight for each function (discussed in
detail in Section 3). The function-wise grouping strategy is ef-
fective for optimizing the total witness weights for each function.
However, for effective distribution across machines the total wit-
ness weight of all functions have to distributedevenly. Say if total
witnessweightsoffunctionf1ismuchgreaterthanthatoffunction
f2, the expected time for trace collection in the above strategy of
function-wise witness set formation will be dominated by the ma-
chine containing the witnesses of functionf1. A more optimized
strategy will distribute witnesses of both the functions across ma-
chines evenly without compromising realizability. The necessary
and sufﬁcient realizability condition enables us to devise such a
ﬁne-grained distribution strategy.
3. BACKGROUND
3.1 Notations
We ﬁrst present some useful notations and terms. An Inter-
proceduralControlFlowGraphICFG= (CFGS,CallE,RetE)
correspondingtoaprogramconsistsofasetofcontrolﬂowgraphs
(CFGS),asetofinter-proceduralcall(CallE)edges,andasetof
return edges (RetE). Each control ﬂow graph (CFG) inCFGS,
corresponding to a single function, is represented by a directed
graphG= (V,E,entry,exit)whereVis the set of nodes that
corresponds to the basic blocks in the function,Eis the set of di-
rected edges between the nodes, andentryandexitare two dis-
tinguished nodes inV. A subset ofVarecallnodes. Each call
node denotes a basic block with a call statement at the end. An
interprocedural call edge (∈CallE) ﬂows from a call node to the
entry node of the called function and a return edge ﬂows from exit
node of the called function to the node containing the return lo-
cation (return node) in the caller. A distinguished CFG in CFGS
corresponds to the CFG formain, the starting function of the pro-
gram. In Figure 3foo.c1is the call node,foo.r1is the return
node,(c1,bar.entry)∈CallE, and(bar.exit,r1)∈RetE.
We denotev→wfor(v,w)∈E∪CallE∪RetEand use
v→+wto denote its transitive closure. We assume that there ex-
ists at most one edge between two nodes. We denotesucc(u) =
{v|u→v}, and anodeuis aconditional/predicate if|succ(u)|>
1(this denotes a basic block ending with a conditional statement).
We denote|succ(u)|>1ascond(u) ==true. For a conditional
nodeu, each node insucc(u)is called the target or the successor
of the conditional/predicateu. In Figure 3,b1andb2are condi-
tional nodes. We use the notationICFG.Eto denote union of all
the edges in CFGs inICFGand inter-procedural call and return
edges. We useICFG.Vto denote union of all nodes in CFGs of
ICFG.
AweightingWofanICFGassignsanon-negativeintegerval-
ues to every edge ofICFG.Esubject to Kirchoff’s ﬂow law: for
each node (exceptentryandexitof main and not-called func-
tions)v, the sum of the weights of the incoming edges is equal to
thesumoftheweightsoftheoutgoingedges. Theweightofanode
(denoted aswt(v,ICFG,W))is the sum of the weights of all its
incomingedges. Thecostofasetofnodesisthesumofallweights
of the nodes in the set. A weighting is called abasic weightingif
for each conditional all outgoing edges from the conditional have
the same weight. Weight in an edge signify the expected number
of times (relative to other edges) the edge is going to be executed.
Typically such weighting is available from proﬁling. The use of
such weighting for optimal proﬁling is described in [1].182b1
b2
b3 b4
b6b7b5
b8 b9
b10
b11
exitentryb1
b2
b3 b4
b6b7b5
b8 b9
b10
b11
exitentryb1
b2
b3 b4
b6b7b5
b8 b9
b10
b11
exitentry
(a) (b) (c)
Figure4: (a)AllBasicBlockproﬁle,(b)ConditionTargetPro-
ﬁle, (c) Optimal Edge-Proﬁle for basic weighting; Bold dots
represent witnesses
A pathP(unless stated, it is undirected) can be denoted as a
sequence of a nodes�v 1...,vi,vi+1...vn�such that for every
verticesv i,vi→vi+1orvi+1→vi. A path is a cycle (undi-
rected) ifv 1=vn. A cycle issimpleif all nodes in the cycle are
distinct. A path or cycle isdirectedif, for everyv i,vi→vi+1. A
directed path is anexecutionof a function whenv 1is theentryof
the function andv nis theexitof the function. Letu,v,wbe three
consecutiveverticesinacycle. Thereisaforkatvifu←v→w,
ajoinatvifu→v←wandpipe(u→v→woru←v←w)
otherwise. A cycle ispipedif it contains atleast a pipe. A piped
cycle is adiamondif it has more than two distinct edges and con-
tainsexactlyoneforkandonejoin. Adiamondisnotnecessarilya
simple cycle. For example, in the example shown in Figure 4 there
are 4 diamonds (�b2,b3,b5,b4,b2�,�b5,b6,b11,b10,b8,b7,b5�,
�b5,b6,b11,b10,b9,b7,b5�,�b7,b8,b10,b9,b7�) and 6 cycles in
the CFG.
A node-based proﬁle is a set of nodesVwit⊆ICFG.V. Sim-
ilarly, an edge-based proﬁle is a set of edgesEwit⊆ICFG.E.
Aproﬁle(denoted asPr) is either node-based or edge-based. A
collectionScorrespondingtoaproﬁlePrandanexecutionPofa
functioncanbedenotedbyasequenceofnodesS={b 1,...,b n},
such that eachb j∈Pris in the execution pathP, andSis a sub-
sequence ofP. A proﬁlePrisrealizableiff it is possible to infer
any pathPfrom a collectionScorresponding toPrandP. We
call such an inference procedure as path reconstruction.
Given a weightingWof anICFG, the cost of a proﬁle is de-
ﬁned as the cost of the set of elements (either node/edges) in the
proﬁle.
3.2 Realizable Proﬁles
Node-based Realizable Proﬁles.In the ﬁrst simple strategy to
obtain a realizable proﬁle, one breakpoint per basic block is set in
the program (i.e.Vwit=V), and in the path reconstruction phase
P=S, the collection itself. A more efﬁcient method to create
a realizable proﬁle is to include only targets of conditionals in the
proﬁle [11]. Both the proﬁles corresponding to a single CFG are
shown in Figure 4(a) and (b). The black dots (on nodes or edges)
represent the elements in the proﬁle.
Edge-based Realizable Proﬁles.BelowwedescribetheBall-Larus’
solution to ﬁnd optimal realizable edge-based proﬁle. A path in
CFGGiswitness-freewithrespecttoasetofedgesEwitiffnoedge
traversed in the path is inEwit. Given an edgep→qwherepis a
conditional node in the CFGGandqis its target, thewitness-set2
2Weusetheterm‘witness-set’forabranchtargetwhereas‘witness
set’ for set of witnesses.forconditionalptonodeqisasetofedgesEwitness(G,Ewit,p,q)
={p→q|p→q∈Ewit}∪{x→y|x→y∈Ewit,∃witness-free
pathp,q,...,x} ∪ {EOF|∃witness-free pathp,q,...,exit}.
A set of edges,Ewitis a realizable proﬁle, iff for each predicate
panditssuccessorsq 1,...,q n,forallpairsq i,qjwherei�=j,the
Ewitness(G,Ewit,p,q i)∩Ewitness(G,Ewit,p,q j) =φ.
Wecalltheabovetheorem,thenecessaryandsufﬁcientpathcon-
ditionfor a realizable edge proﬁle. Intuitively, each edge in
Ewitness(G,Ewit,p,q)can potentially be the ﬁrst witness edge
visited on a path fromp,q,...,exit. If two successors have dis-
jointwitnesssetsthenexistenceofawitnessintracefromeitherset
determines which successor was taken after execution of the con-
ditional. The necessary and sufﬁcient condition presented above is
equivalent to the statement given below [1].
Ewit is realizable iffE−Ewit contains no diamonds or directed
cycles.
We call the above condition as necessary and sufﬁcientCFG
conditionfor edge-based realizable proﬁle. Although, the above
twoconditionsareequivalent,thepath-basedconditionisusefulin
forming the path reconstruction algorithm, whereas the CFG con-
dition is essential in creating the witness proﬁle.
Informally, the above realizability condition ensures thatEwit
breaksalldiamondsanddirectedcycles. Intuitively,aproﬁlebreaks
adiamondoradirectedcycleifitcontainssufﬁcientwitnessessuch
that it is possible to identify the path taken in the diamond or di-
rected cycle.Ewit breaksa diamond (or directed cycle) ifEwit
contains an edge in the diamond (or in the directed cycle)3.
Figure 4(c) shows an optimal edge proﬁle for basic weighting.
All four diamonds and six directed cycles are broken by the given
Ewit.
Optimally breaking the diamonds and directed cycles is an NP-
Complete problem [7, 15]. However, a spanning tree can break all
the cycles (diamonds and directed cycles are cycles in undirected
sense) in polynomial time. Edges not in such spanning tree of the
CFG comprise realizableEwitand moreover produces an optimal
solution for a large class of CFGs.
4. DISTRIBUTED TRACING
In this section we ﬁrst present a necessary and sufﬁcient con-
dition for realizable witness distribution. Then we discuss the al-
gorithms for effective parallel distribution. Finally, we present the
trace reconstruction algorithm which forms the execution trace by
merging the partial traces.
A proﬁle distribution (WitD) is a set of proﬁles. Based on the
type of its constituent proﬁles, a proﬁle distribution can either be
edge-based (EwitD) or node-based (VwitD). Each constituent pro-
ﬁle of a distribution is denoted byWitD i. Given a proﬁle distribu-
tion, we refer to the trace collection corresponding to each one of
its constituent proﬁles as apartial path. Our task is to construct
the entire execution trace by merging all the partial paths. A pro-
ﬁle distribution is realizable if itis possibleto reconstructthe trace
from the partial paths corresponding to its constituent proﬁles.
4.1 NecessaryandSufﬁcientConditionforRe-
alizable Distribution
We ﬁrst present the intuition for deriving the necessary and suf-
ﬁcientconditionforrealizablewitnessdistribution. Consideragain
the example shown in Figure 2. The problem with this distribution
is that it was not possible to associate the branchesb3andb4with
theloopiterations. Wenoticethatsuchassociationofloopiteration
3In Section 5 it is shown that a node-based proﬁle will break a
diamond if it contains a non-fork, non-join node of the diamond.183withthebrancheshappensinarealizableproﬁle(thatbreaksallcy-
cles and diamonds in CFGs). Consider an alternative non-disjoint
breakpoint distribution -{{b3,b2},{b4,b2}}. In this distribution
eachproﬁle breaksthe directedcycles andthe diamond,and there-
fore realizable. Hence from this example we arrive at a conclusion
that, a distribution is realizable if all its constituent proﬁles break
all diamonds and directed cycles.
Next,wediscusswhetherthisisanecessarycondition,i.e.whether
the above example imply that each proﬁle of a realizable distribu-
tion needs to break all the diamonds and directed cycles? To an-
swer this question let us consider the example in Figure 4 with the
distribution -{{b3,b4},{b5,b6},{b8,b10}}. This distribution is
realizable, and each proﬁle in the distribution individually breaks
at-least one diamond ({b5,b6}breaks two) and all the directed cy-
cles passing through it, but not necessarily all the diamonds and
cycles. Thus the answer to the above question is negative.
Informally we derive that if a proﬁle breaks a diamond then it
hastobreakallthedirectedcyclespassing through it. Collectively,
all the proﬁles need to break all diamonds and all directed cycles.
Based on the intuition built from the examples above, we now
formally present a CFG based necessary and sufﬁcient condition
for a realizable distribution.
THEOREM 1.A distribution is realizable iff the following con-
ditions hold:
•Foreachdiamond,thereexistsat-leastoneproﬁlethatbreaks
the diamond and breaks all the directed cycles (if any) that
pass through the fork and branch targets of the diamond.
•All diamonds are broken collectively by all the proﬁles.
•All directed cycles are broken collectively by all the proﬁles.
The proof of this theorem is provided in [20]. We say a proﬁle
coversa diamond if the ﬁrst condition is met by the proﬁle.
The following theorem presents a path-based necessary and suf-
ﬁcient condition for a realizable distribution which is equivalent
to the CFG based condition presented above. It does not matter
whether the proﬁle being distributed is edge-based or node-based.
Fornode-basedproﬁlesthedeﬁnitionofwitness-setcanbedeﬁned
in similar way as described in Section 3. A path in CFGGis
witness-freewith respect to a set of nodesVwitiff no nodes tra-
versed in the path is inVwit. Given an edgep→qwherepis
a conditional node in the CFG, thewitness-setfor conditionalp
to nodeqisVwitness(G,Vwit,p,q) ={q|q∈Vwit} ∪ {y|y∈
Vwit,∃witness-freepathp,q,...,y}∪{EOF|∃witness-freepath
p,q,...,exit}. We use the notationwitness(ICFG,Wit,p,q)
togeneralizeEwitnessandVwitness. GivenadistributionWitD,a
CFGG, and an edgep→qwherepis a conditional, the set of all
witnessesallwitness(ICFG,WitD,p,q))forthedistribution,is
deﬁned as the union of witnesseswitness(ICFG,WitD k,p,q)
of all the proﬁles in the distribution.
THEOREM 2.Abreakpointdistributionisrealizableiffforeach
predicatepand its targetsq 1,...,q n, for all pairs(q i,qj),i�=j
ifqi→+pandq j→+p,
then there must exists a proﬁle WitD msuch that the following
conditions are met
•witness(ICFG,WitD m,p,qi)∩witness(ICFG,WitD m,p,qj) =
φ
•allwitness(ICFG,WitD,p,q i) =witness(ICFG,WitD m,p,qi)
•allwitness(ICFG,WitD,p,q j) =witness(ICFG,WitD m,p,qj)else
allwitness(ICFG,WitD,p,q i)∩allwitness(ICFG,WitD,p,q j) =φ
Note that, for the predicatep, when its targets can loop back to
theconditional,theabovetheoremassertsthatinsomeproﬁletheir
entirewitness-setsmustexistandtheyaredisjoint. Thedisjointed-
nesscriteriauniquelydetermineswhichconditionaltargetbetween
qiandqjis taken after conditional. The existence of their entire
witness-sets in one proﬁle determines the association of the occur-
rence of the targets with the loop iterations. If such condition is
notmetthentherecanpotentiallybeacasewheretwopartial-paths
have two witnesses, one each from the witness-set of each target,
which occur in two different instances of a loop. In this case, it is
not possible to associate which iteration executes which target - a
case seen in Figure 2. However, for conditional target pairs where
bothofthemdonotloopbacktotheconditional,witnessesintheir
disjointwitness-setscanbedistributedacrossproﬁles. Asanexam-
ple consider the predicateb1corresponding to the loop condition
in Figure 1.exitandb2are its two successors. The successorexit
doesn’t have a path back tob2. The witness sets for these may be
distributed across proﬁles. During path reconstructionb2should
get precedence overexit, as, if it does occur, it can only occur be-
foreexit.
4.2 Effective Parallel Distribution
Satisfying the necessary and sufﬁcient condition presented be-
fore, many possible realizable proﬁle distributions can be gener-
ated. In this sub-section various parallel distribution strategies are
discussed. Moreover,twocasesareconsidereddependingonwhether
or not each constituent proﬁle is bounded by a proﬁle size.
Our model of parallel distribution consists ofmidentical ma-
chines, each having a static queue which can contain multiple pro-
ﬁles. Alltheproﬁlesaredistributedtothemachinesbeforeanyex-
ecutionstarts. Eachcollectionisrunonthesameinput. Whenever,
a collection is complete in one machine, a proﬁle can be removed
from its queue and run for collection in that machine. The process
stops when all the collections are done. Since collections in each
machine is done sequentially, the time taken by a machine is the
sum of the times of all the collections performed in the machine.
Thetracecollectiontime(orcostofacollection)isthemaximum
of total times taken by each machine for its collections. Note that
the collection time of a proﬁle depends on the number of witness
hits by the actual run. The proﬁle distribution algorithm approxi-
mates the number of witness hits in a proﬁle by the total weight of
the witnesses in the proﬁle. Thuscost of a distributionis deﬁned
as the maximum of cost of distribution for each machine, where
costofdistributinginamachineisdeﬁnedasthesumoftheproﬁle
weightsinthemachine. Theproﬁleweightisdeﬁnedasthesumof
witness weights in the proﬁle.
Theoveralltimeofcollectionwillbeoptimizedifthemaximum
time across all machines is minimized. This suggests even distri-
bution of witness weights across all machines for optimal parallel
distribution. However, we found that such distribution is an NP-
Complete problem as stated in the below theorem:
THEOREM 3.The optimal parallel distribution problem is NP-
Complete.
Theproofofthetheoremisavailablein[20]. Followingthisresult,
proﬁledistributionalgorithmsusegreedyapproximationalgorithm
(presented in Figure 5).
Our second observation is informally stated as follows: when
there is no-bound on the proﬁle size then it is possible to combine
all the proﬁles of one machine into a single proﬁle such that the184total weight of the witnesses in the resultant single proﬁle is no
greater than the total weight of the witnesses of all the proﬁles.
WeillustratethisusingtheexampleshowninFigure6. Arealiz-
able distribution contains three proﬁles{{b3,b4},{b6,b7},
{b9,b10}}where each proﬁle covers a distinct diamond. If there
aretwomachines(i.e.m= 2)thenthedistributioncanbe{{b3,b4},
{b6,b7}}and{{b9,b10}}. However, the ﬁrst machine can break
the two diamonds by a single proﬁle viz.{b3,b4,b6}with lesser
costthanthetwoproﬁles. Wecallsuchpairofdiamondsaswitness-
optimizablewhosecoveringbyasingleproﬁlerequireslesserweight
witnesses than covering each diamond by individual proﬁles.
We summarize the important ﬁndings before describing the var-
ious distribution strategies.
•Foreffectivetimeforcollection,eachmachinecontainsonly
a single proﬁle if the size of proﬁle is unbounded.
•Combiningmultiplediamondsinthesameproﬁlecanreduce
the total witness weights to cover the diamonds.
•Fine grained weight distribution facilitates even distribution
of total weights across machines. For example, say 6 units
withweights1,2,3,4,5,and6aretobeoptimallydistributed
to two machines. If six jobs are formed each having a single
unit, then the chance of optimal distribution increases com-
pared to the case where jobs are formed combining one or
more than one units - say for example forming three jobs
likethis{{1},{2,3},{4,5,6}}andthentryingtodistribute
optimally between two machines.
We describe three strategies to distribute covering of all dia-
mondsanddirectedcyclesofaprogramtomultiplemachines. The
threestrategiesessentiallydifferinformationofJob(asreferredin
Figure 5). A job is a set of diamonds and directed cycles-without-
diamonds which are deﬁnitely covered in the same machine.
Theinterestingnatureofthisdistributionproblemisthatforming
job by combining diamonds and directed cycles may form the job
whose cost of optimal realizable proﬁle is lesser than the sum of
the proﬁle weights to break the constituent diamond or directed
cycle. Thus combination of multiple diamonds and directed cycles
to cover in a single machine can be beneﬁcial to reduce the job
weight. On the other hand, increase in proﬁle cost by combining
jobs may pose as deterrent to even distribution of jobs across the
machines.
In all three strategies diamonds and directed cycles from pro-
gram’s ICFG are determined in the following way. First, all func-
tions that can be potentially called multiple times are identiﬁed. A
functioncanpotentiallybecalledmultipletimesifthefunctionhas
multiplecall-sitesorcalledinsideacycle,orcalledfromafunction
which can be potentially called multiple times. For these functions
Algorithm : AssignJobsToMachine(M, J)
Input : A set of identical machines M ({M 1,...,M m}) ,
A set of jobsJ{J 1,...,Jn}.
// Greedy : (2−1/m) approximation
For i = 1 to n do
// Assign Job Ji to the machine with least current load
// Update load of the machine that receives job J .
Mk=find_least_current_load (M)
assignJob (M k,Ji)
Figure 5: Algorithm: Greedy solution to MultiProcessor
Scheduling problemb1
exitentry
b5b2
b8
b11b3 b4
b7 b6
b9 b101
13
2
2
2
2
2
21
1
1
1
13
exitentry
b1
b2b3
b4 b5
b6
b7(a) (b)
Figure 6: Example CFGs for parallel distribution
an edge is added between exit to entry to preserve realizability, for
their call sites an edge is added between call location to return lo-
cation. Then, for all functions, diamonds and cycles are identi-
ﬁed (based on an undirected cycle detection algorithm, for details
refer to [20]). This strategy, however, cannot identify potentially
witness-optimizablediamondsbetweencallerandcalledfunctions.
Such a case can arise if there exists a diamond at noder1in Fig-
ure 3 in which case it is not possible to cover the diamonds in two
functions.
Theﬁrststrategy,calledﬁne-graineddistributionstrategy,forms
each job as a single diamond or cycle-without-diamond. Thus pre-
ferring effectiveness of distribution over reducing weights through
ﬁnding witness-optimizable diamonds.
The second strategy, mentioned in Section 2 asfunction-wise
grouping strategy, forms each job by combining all diamonds and
directed-cycles-without-diamondofasinglefunction,therebymak-
ing sure that all witness-optimizable diamonds in the function are
covered in a single machine. However, this strategy, even though
fairly simple, can have other diamonds in the same job which are
not witness-optimizable.
Thethirdstrategyiscalledoptimized-groupingwhichusesheuris-
tics to ﬁnd potentially witness-optimizable diamonds and forms
jobs by combining only such diamonds. It follows the principle
thattwodiamondsarepotentiallywitness-optimizableiftheyshare
the same cycle or if they share an edge between them. The for-
mer case is illustrated in the example shown in Figure 6(a). For
the later case consider the CFG in Figure 6(b) which has three di-
amonds�b1,b2,b7,b6,b5,b3,b1�,�b1,b2,b7,b6,b4,b3,b1�, and
�b3,b5,b6,b5,b3�whichshareedgesbetweenthem. Althoughbreak-
ing of each diamond will require at least one witness, but in the
same proﬁle all the three diamonds can be broken using two wit-
nesses.
Theoverallalgorithmforproﬁledistributionforun-boundedpro-
ﬁle size and edge-witnesses is shown in Figure 7. In the ﬁrst step
jobs are identiﬁed based on one of the three grouping strategies.
Using the greedy approximation algorithm, each job is assigned to
to the machine with least current load. The assignment procedure
re-calculates the load of the assigned machine. Once a job is as-
signed to a machine (recall that in unbounded case there is only
one proﬁle in the machine denoted byM k.profile), it is possible
to determine the optimal set of witnessesM k.profile.witnesses
to cover all the diamonds and directed-cycles-without-diamond by
runningtheBall-Larus’optimaledge-proﬁlingalgorithmfromscratch.
Such from-scratch evaluation is not scalable when the number of
jobs are large, a case seen with the ﬁne-grained distribution strat-
egy. Instead, we devise an incremental algorithm to repeatedly re-185Input : ICFGig, WeightingW, A set ofm
machines M (M 1...,Mm)
Output :M i�→wit
Algorithm :
Step 1:
// find all diamonds and directed cycles
// and create jobs based on strategies
D= Find all diamonds inig
C= Find all directed cycles inigthat do not
pass through any diamonds inD
J= grouping−strategy (D,C) // set of JobsJ i
// initialize profile in machine
for each machineM k
Mk.profile.witness= {},M k.profile.ce=ig.E
AssignJobsToMachine(M,J)
assignJob (M k,Ji)
if not bounded
EdgeBasedIncrementalAdd2Machine(J i,Mk.profile)
Mk. load=M k.profile.cost
else ..
EdgeBasedIncrementalAdd2Machine(J i,P)
for each DiamondD∈J i
remove fromP.ceall edges ofD
for each Directed CycleC∈J i
remove fromP.ceall edges ofC
// spanning graph computation
add edges toP.cet i l l no more cycle is created
P.witnesses=ig.E−P.ce
P.costis the sum of cost of edge−weights in
P.witnesses
Figure 7: Algorithm: Edge-witness, un-bounded parallel dis-
tribution
calculatewitnesssetswhileassigningjobstomachines. Withevery
proﬁlepwe keep a set of edgesp.cethat are the complement of
witnesses edges in the proﬁle. We explain the algorithm using the
exampleinFigure6(a). Intheﬁrststep,threejobs,eachcontaining
a diamond is identiﬁed which need to be distributed to two ma-
chinesM 1andM 2. proﬁle.ce for each machine is initialized with
all the edges in the CFG. When a diamond with fork b2 is added
toM1all edges of the diamond are removed fromM 1.profile.ce.
Then edges are added till no more cycles are formed. In this case
it will add the edgesb2→b3andb2→b4. The edges that are
not added inM 1.profile.ce(b3→b5,b4→b5) constitute its
realizablewitnesssetwhichbreaksthediamond. Asimilarprocess
runs when diamond with forkb5is added toM 2. After that dia-
mond with forkb8is added toM 1. All its four edges are removed
fromM 1.profile.ce. Thenthreeedgesofthediamondwithhigher
weights (b8→b9,b9→b11, andb8→b10) are added back to
cewithout introducing any cycle to thece. The complement edges
ofce(b3→b5,b4→b5, andb10→b11) form the witness for
M1.profile.
The above three strategies can also be applied with modiﬁca-
tion in cases when proﬁle size is bounded. In this case each ma-
chine can have multiple proﬁles to run where the size of each pro-
ﬁle is bounded by a limit. We refer to this as the bounded par-
allel distribution problem. We show that optimal 2-bounded par-
allel distribution problem is NP-Complete, and then generalize it
for all bounds [20]. The algorithm can be modiﬁed, in function
AssignJobto divide the job into multiple proﬁles (taking into
consideration the latest proﬁle in the Machine) with bounded size
beforeaddingtoamachine. Theempiricalcomparisonofthethree
strategies is described in Section 6.Input:
ICFGG,Set of StacksTconsisting of
Partial−PathsT i,
A MapM:�pc,q i,qj� �→WitD ksuch that cond(pc)=true,
WitDksatisfies the necessary and sufficient
condition forq i,qj→+pc
Output:Execution E
Algorithm:
pc=entry(G.main)
E=pc
do
if notcond(pc)then
newpc=succ(pc)
else
if∃qm∈succ(pc)st.∃T i.peek∈witness(G,WitD i,pc,qm)
q=qm
for eachq i∈succ(pc),q i�=qm, &&qi→+pc
WitDk=M(�pc,q i,q�)
ifTk.peek∈witness(G,WitD k,pc,qi)
q=qi
else
∃q∈succ(pc),s.t.∃T i.Ti.peek∈witness(G,WitD i,pc,q)
&&qm→+pcdoes not exist
newpc=q
for allT ks.t.T k.peek=q
Tk.pop
pc=newpc
E+=pc
untilpc=exit
Figure 8: Algorithm: Path reconstruction for realizable distri-
bution
b3entry
b4b2 b1b0
exitb1,b3 b1,b2 b2,b3 exit
b1 b2exit
exit
exit
exitb3
b2b3 b1
b1
b2 b2 b1
b2 b2Figure 9: Example CFG with partial paths at different stages
of path reconstruction
4.3 Path Reconstruction from Partial Paths
Wenowpresentanalgorithmtomergemultiplepartial-pathscor-
responding to a realizable distribution to derive the full execution
path. The algorithm is presented in Figure 8. The intuition of the
algorithmfollowsfromthepathbasednecessaryandsufﬁcientcon-
dition for realizable distribution. The illustration of the algorithm
for an example is given in Figure 9. The actual execution path is
�entry,b0,b3,b4,b0,b1,b4,b0,b2,b4,b0,exit�. The addition of
nodesentryandb0is straightforward. After this we try to ﬁnd
out which node occurred afterb0amongb1,b2andb3. We ﬁrst
getqm=b3, then compare againstb1. The mapMrefers to the
proﬁle which is used to break the diamond with branch targetsq i
andqjand forkpc. The ﬁrst partial path in the ﬁgure shows that
b3is at the top, thusb3deﬁnitely occurred beforeb1. We proceed
with the second comparison withb2. The third partial-path shows
thatb3occurred beforeb2. Thus the next node executed isb3. The
partial paths are now adjusted by removingb3from the top. The
rest of the execution reconstruction is similar to this and omitted.186(a)1
1entry
exit2
2b2 b3
b41 1
1 1entry
exit2
2b2 b3
b41 1
1 1entry
exit2
21
b3b2
(b) (c)b1 b1 b1
Figure 10: Examples where (a) source, (b) target, (c) source
and target of optimal edge based proﬁle do not yield realizable
proﬁle. Bold edges constitute optimal edge based proﬁle. Bold
nodes constitute the node based proﬁle.
The algorithms described in this section are general to edge-
based or node-based distribution making it easily applicable to-
wards breakpoint based and instrumentation based collection.
5. TRACECOLLECTIONFORABAPPRO-
GRAMS
SAP-ABAP program are compiled into low-level code and run
byavirtualmachineinsideSAPsystem. SAPsystemdoesnotpro-
vide direct access to the low-level code for instrumentation to the
user/programmer. Moreover, SAP-ABAP practice does not allow
programmer induced instrumentation of code in production sys-
tems. Itssafetyisnotconsideredatparwithtrustedstandardagents
like SAP compiler or debugger. In general, most production sys-
tems do not allow low-level code instrumentation induced by user,
but do permit remote debugging. Here, we present a technique for
trace collection using code breakpoints inserted by SAP debugger.
Consider the necessary and sufﬁcient condition for realizable
proﬁle distribution and parallel distribution strategies presented in
theprevioussection. Thestrategiesdistributecoveringofdiamonds
andbreakingofdirected-cycles-without-diamondsintomultiplepro-
ﬁles, essentially breaking cycles and diamonds. However there are
many possible proﬁles that can break a given set of diamonds and
cycles. For example, node based proﬁles like basic block and con-
ditional targets (described in Section 3) can be used. For edge-
basedproﬁles,Ball-Larus’solution[1](alsodescribedinSection3)
canbeusedtogetanoptimalproﬁletobreakthediamondsandcy-
cles. However, no such optimal algorithm exists for node based
proﬁling. Breakpoint based solution requires such optimal node-
based proﬁles.
Converting an optimal edge-based realizable proﬁle to an opti-
mal node-based proﬁle is not straightforward. It can be easily seen
that, for each edge in the edge-based proﬁle, selecting any one of
the source or target node of the edge or even selecting both the
source and target may not in general lead to a realizable proﬁle
(see Figure 10). Below we present the realizability condition for
node based proﬁle:
THEOREM 4.Vwit is a realizable nodes based proﬁle iff Vwit
breaks all diamonds and directed cycles, where, a diamond is bro-
ken by Vwit when there exists a node in Vwit which is neither its
fork nor join; and a directed cycle is broken by Vwit if it contains a
node in Vwit.
The proof of this theorem is available at [20]. The algorithm
for optimal node-based proﬁle is shown in Figure 11. The opti-
mal node-based proﬁling algorithm has to consider the case of theget_optimal_profile
Input:A job J
Output:Optimal realizable Vwit
Algorithm:
Step1:Identification of fork−join pairs
MSCT={}
for each diamonddinJwith forkfand joinj
if∃f→j
add(f,j)toMCST
Step2. //Same as optimal Ewit computation
Perform maximum spanning tree by adding
edges toMCST.
Ewit’=E−MCSTwhereEis all the edges inJ
Step3:Identification ofVwit
For each edge(src,tgt)∈Ewit’
ifsrcis a fork−node
addtgttoVwit
elseiftgtis a join−node
addsrctoVwit
elseifsrc&&tgtare neither fork nor join
add the node with minimum weight toVwit
Figure 11: Algorithm: Optimal Vwit computation
Bench Stmt Basic Block Diamonds Cycles
S/C/H S/C/H S/C/H S/C/H
order 1074/185/9084 475/93/4031 638/29/1607 10/2/126
iinv 1517/413/6319 745/219/3807 509/38/1144 5/3/34
imat 1916/468/4891 967/245/2525 1787/68/958 12/2/66
inap 474/209/574 215/111/296 97/20/111 3/3/3
r013 335/211/3175 137/97/1067 36/18/280 0/0/0
rls 625/520/1073 82/46/105 41/6/22 0/0/0
rv54 1361/219/223 653/104/108 1814/21/21 21/2/4
tcbl 584/484/10335 143/125/3618 57/30/1373 1/1/58
tccm 567/470/34692 145/130/14932 152/27/5771 2/1/851
wip 1397/478/5197 541/245/2309 300/65/721 13/8/139
zrep 56/32/1481 25/17/855 17/7/287 0/0/0
zrotc 251/112/2706 105/63/1041 16/6/338 0/0/0
Figure 12: Benchmark and Test characteristics: S is the num-
ber of entities in the program, C is the total number of such
entities covered by the trace and H is the number of hits of the
entity
specialdiamonds(showninFigure10(c))wherechoosingasource
or target or both, from an optimal edge based proﬁle won’t gener-
ate a realizable node-based proﬁle. To break such diamonds, the
algorithm inserts its fork-join edges in the tree (in Step 1), prior
to maximum spanning tree computation (Step 2), such that these
fork-join edges do not belong to the resulting edge based proﬁle
(complement ofMCST). The Step 3 selects appropriate nodes-
based proﬁle from the edge based proﬁle. The optimality follows
from the optimality of Ball-Larus’ algorithm and minimum weight
of source/target nodes chosen in Step 3.
6. EXPERIMENTAL RESULTS
In this section we compare the effectiveness of various distribu-
tion strategies of parallel trace collection for a set of ABAP pro-
grams.
The characteristics of the 12 benchmark ABAP programs are
shown in Figure 12. All these programs are real ABAP report pro-
grams in SAP. For each benchmark program, a trace is collected.
The implementation of the algorithms is done in Java and exper-
iments are conducted on a laptop running Windows XP and with
dual core 2.53Ghz CPU and 4GB RAM. For each program and
its corresponding trace, we ﬁnd a proﬁle and take an intersection
of the path with the proﬁle to determine the total number of hits.187 20 30 40 50 60 70 80 90
 2  3  4  5  6  7% of non-distributed
No. of machinesorder
iinv
imat
inap
r013
rls
rv54
tcbl
tccm
wip
zrep
zrotc
Figure 14: Reduction in cost of collection vs. machines
 35 40 45 50 55 60 65 70
 0  1  2  3  4  5  6Fine-grained
Function
Optimized 200 300 400 500 600 700 800 900
 0  1  2  3  4  5  6Fine-grained
Function
Optimized(a) (b)
 150 200 250 300 350 400 450
 0  1  2  3  4  5  6Fine-grained
Function
Optimized 200 300 400 500 600 700 800 900 1000 1100
 0  1  2  3  4  5  6Fine-grained
Function
Optimized(c) (d)
Figure 15: Cost of Collection vs. Machines for - (trace proﬁle -
(a) inap, (b) order), and (BL-proﬁle - (c) zrotc, (d) iinv)
Thetracecollectiontimeisproportionaltothetotalnumberofhits,
with an average of 0.5 seconds/hit due to slow interaction between
SAPGUI and server.
We use Ball-Larus proﬁling algorithm [1] (referred to as BL-
proﬁle) for assigning weights to the nodes and edges. We also
consider a case where the proﬁle weights are taken based on ex-
act execution trace (hereafter referred to as trace proﬁle).
Ourﬁrstexperimentstudieshowtheeffectivenessofparalleldis-
tributionwithun-boundedproﬁlesizevarieswiththeavailablema-
chinecountforthethreealgorithmsfordistributingjobsusingBL-
proﬁle (similar results for trace proﬁle is available at [20]). Fig-
ure 13 shows the results. Each data-point (in the format A/B) is a
pair consisting of cost of distribution (A), and the cost of collec-
tion (B) (refer to Section 4.2), where both costs are deﬁned as the
maximum cost across all machines. Here is the summary of our
observations.
Cost of collection vs. Machine. In Figure 14 we present the varia-
tion of cost of collection with respect to number of machines. For
each benchmark, we ﬁrst obtain the cost of collection in one ma-
chine (non-distribution). For each number of machine, we take the
minimumcostofcollection(forvariousstrategies)andtakeitsper-Bench 10203040
order 13661005 597687
iinv 1203 729641567
imat 3207200514851273
inap 90734759
r013 719374374374
rls 34241818
tcbl 75091010801097
tccm 6841503840924882
rv54 59453532
wip 492475495435
zrep 352423423423
zrotc 421421421421
Figure 16: Parallel distribution with bounded proﬁle size: cost
of collection
centage over non-distributed cost of collection. For benchmarks
rls and inap the reductions are very small and for zrep there is ab-
solutely no reduction. In all these three cases, the even distribu-
tion based on static information is not representative of trace hit
distribution. In all these benchmarks, the traces hit the witnesses
predominantly in one machine. Leaving these 3 benchmarks, the
average percentage of hits are 62, 49, 44, 38, 32, and 31 for 2 to 7
machines, respectively. Thus using 6 machines the trace collection
time reduces to less than 1/3.
Comparisonof distributionstrategies. Tocomparethethreegroup-
ing strategies, we consider the proﬁling algorithms separately. For
the trace proﬁle, the proﬁle cost distribution accurately reﬂects the
hit distribution as well. In this case we notice that optimized strat-
egyisalwaysbetterthanthefunction-wisegroupingstrategy,how-
ever ﬁne-grained distribution generates minimum proﬁle cost in
half of the cases. We show two cases where each strategy emerges
as a winner in Figure 15(a) and (b). In general we found that for
benchmarkswithlessnumberoffunctionsshowbetterresultswith
ﬁne grained distribution. This case is particularly noticeable in
traceproﬁleswherefunctionsarenotexecutedandsothediamonds
and directed cycles in those function have zero weights, in effect,
thenumberofnon-zeroweightfunctionsaresmaller. Thisisnotthe
caseforBL-proﬁleastheassignmentofweightsaredonenotbased
ontheactualtrace. InBL-proﬁlecaseweseemorenumberofwin-
ners for function-wise grouping strategies and optimized-grouping
strategy. The four winners of ﬁne-grained distribution strategy are
rls, r013, zrep, and zrotc. Interesting to note that in all these case
the benchmarks do not have any cycles (see Figure 12). Note that
grouping strategies are more effective in reducing weights of pro-
ﬁles when multiple diamonds are in cycles (as in Figure 6(a)). Ab-
senceofthecyclesmakesﬁne-grainedstrategymoreeffectivethan
thetwogrouping strategiesinthosefour cases. Weshow represen-
tative cases in Figure 15(c) and (d).
Effect of bounded proﬁle size.The Figure 16 shows the effective-
ness of parallel distribution (in terms of cost of collection) with
variation in the limit of witnesses in each proﬁle. The results are
taken with three machines and with function-wise grouping distri-
bution strategy. The aim of this experiment is to see how witness-
optimizable diamonds are distributed with increase in limit. Even
though we show the result for various limits, SAP-ABAP debug-
ger limits the number of breakpoints in a debugging session to 30.
Sincefunction-wisegroupingstrategyisbettersuitableforkeeping
potentialwitness-optimizablediamondstogether,theexperimentis
done with this selection strategy. We notice that with increase in
limit, in most cases the cost decreases, with an exception in few
cases. We investigate these cases. In these cases the diamonds in
each CFG are not witness-optimizable, thus combining them in-
creases the proﬁle size and cost.188Bench Non-Distr. ﬁne-grained function-wise optimized
1 2 3 4 5 2 3 4 5 2 3 4 5
order 342/992 239/889 203/879 181/815 168/892 218/810 179/563 161/689 151/489 228/666 195/616 175/567 166/372
iinv 231/1095 171/1091 144/943 127/852 113/601 142/643 105/575 84/405 73/407 134/732 103/483 85/377 77/351
imat 561/740 462/717 417/641 383/518 357/523 286/513 198/324 168/397 141/229 352/481 277/366 239/362 222/338
inap 83/70 58/69 51/79 45/81 46/68 42/65 31/63 24/61 21/61 58/60 49/57 43/60 42/56
r013 645/480 425/349 379/254 243/254 243/259 626/379 623/374 622/374 621/371 629/373 626/371 623/374 622/373
rls 8/22 6/21 5/19 4/20 4/19 4/20 4/19 4/19 4/19 4/20 4/19 4/19 4/19
rv54 824/25 655/23 595/23 592/24 576/25 565/14 534/11 524/9 517/10 616/21 599/18 591/11 588/8
tcbl 191/1443 119/992 108/925 115/770 77/665 174/1155 169/1097 166/1093 165/1091 173/1155 171/1148 170/1147 169/1146
tccm 67/6631 50/6257 47/6212 38/3813 38/3813 37/5403 28/5403 28/5403 27/5402 37/5402 33/5405 32/5403 32/5403
wip 605/1040 408/755 334/595 291/574 270/554 303/584 210/382 182/343 162/372 330/598 256/442 230/444 201/425
zrep 7/423 4/285 4/285 3/215 3/215 7/423 7/423 7/423 7/423 5/212 3/212 3/212 3/212
zrotc 297/424 202/256 202/252 130/171 121/168 290/422 287/421 286/421 285/421 289/422 287/421 286/421 285/421
Figure 13: Effectiveness of distribution strategies in form of cost of distribution/cost of collection for BL-proﬁle
7. RELATED WORK
Path collection.Program path collection has been an area of ac-
tiveresearchinthesoftwareengineeringcommunityforquitelong,
particularly due to its importance in a wide variety of applications.
The theory of program tracing thus dates back to four decades.
Rammoorthy et al. [19] gave a necessary and sufﬁcient condition
for edge based realizable proﬁle for tracing single procedure pro-
grams. They wanted to ﬁnd a minimal-size solution (minimum
number of edges) to the tracing problem which was proven to be
NP-Complete[15]. Incontrast,Ball-Larus,intheirseminalwork[1]
presented an algorithm to solve minimal-cost solution. They refor-
mulatedtheconditionpresentedbyRammoorthyetal.[19]andex-
tendedittomulti-procedurecase. Theirprogramtracingalgorithm
provides an optimal edge-based placement. However, this solution
is applicable only for instrumentation based tracing, as breakpoint
based solution requires witnessing nodes and not edges.
Breakpointbasedcollection.Toourknowledge,fewotherworks[9,
24] use breakpoints to gather path information. In [9] debugging
time breakpoints, set by the users (not automatic), are used to ﬁnd
whetherastatementisexecuted(nottodeterminecompletepathas
here). Thisinformationisusedtoreﬁnestaticslices. In[24]break-
points are put in the start of all basic blocks to obtain path. All the
other techniques use the instrumentation based approach.
One program, many collections.Techniques such as [10, 4, 13]
haveusedmultipletracesofthesameprogramtolocalizethebugs.
However,theyuseddifferentfaultyandcorrectinputsforthesame
program, thereby collecting multiple different traces.
Closest to our work is by Palankar et al. [17] where order of
data access is determined by merging multiple executions of the
same program with the same input. The division of executions
were performed due to limited number of hardware assisted data-
breakpoints to watch data accesses. However, they do not try to
obtain the exact order of data access and use heuristics (like us-
ing information in the instruction counter) to arrive at a solution
whichisclosetoaccurate. Recentwork[22]performsamergeop-
eration on partial calling context obtained using lightweight proﬁl-
ing. However,themergeoperationperformedthereisapproximate
whichaimstocapturethecallingcontexttreewithhighprobability.
Diep et al. [5] performed distribution of probes to multiple pro-
gramvariants,whereeachvariantcontainsasubsetofprobes,where
the subset size can be bounded to meet the overhead requirements.
Theiraimwastoproﬁleasetofevents,andnotgeneratingorderof
events for a particular input.
Softwaretomography[3]splitsmonitoringtasksacrossmanyin-
stancesofthesoftware,sothatpartialinformationmaybecollected
fromusersbymeansoflight-weightinstrumentationandmergedtogather the overall monitoring information. Even though the frame-
work sounds similar, it has been applied for merging proﬁling in-
formation and not for constructing any information which require
respecting order of events.
Boddenetal.[2]reducestheinstrumentationoverheadformatch-
ing tracematch policies (regular expression with variables) at run-
timebydistributingwitnessesacrossseveralusercopies. Asmerg-
ingofinformationisnotrequiredacrosspartialtraces,thedistribu-
tion only preserves the data-ﬂow required for sound (but not com-
plete) satisfaction of the policy. This is a different distribution cri-
teria than ours.
8. CONCLUSION
Inthispaperwehavepresentedanoveldivide-and-conquerbased
trace collection technique in which partial traces may be collected
andsubsequentlymergedtoproducethecompletetrace. Weshowed
thatsuchadivisionoftracecollectionisanon-trivialproblem,and
presented a necessary and sufﬁcient condition to guarantee the re-
coveryofthewholepathbymergingthepartialtraces. Sincepartial
collections may be done in parallel (using a Hadoop based frame-
work), the total time of trace collection is governed by the maxi-
mum total time of collection across machines. This required even
distribution of witnesses across machines. We show the optimal
distribution is an NP-Complete problem and use the existing ap-
proximationsolutionstoeffectivelydistributethewitnesses. Toap-
ply such a technique for breakpoint based collection, we extended
Ball-Larus’ optimal edge-based proﬁle algorithm to a node-based
proﬁle algorithm.
Our work opens up other possibilities of parallel collection of
elements where order of elements are of importance. Applying
these techniques for obtaining call trace [22] and order of data ac-
cess [17] can be fruitful. We are investigating other uses of this
framework such as multithreaded application using Uniparallelism
approach[23],distributedruntimeveriﬁcationofpolicies,andeval-
uating more dynamic scheduling strategies for parallel collection.
9. ACKNOWLEDGMENTS
We thank Satish Chandra and Ansuman Banerjee for their help
in this work. We also like to thank anonymous referees for their
helpful comments on the earlier version of the paper.
10. REFERENCES
[1] Thomas Ball and James R. Larus. Optimally proﬁling and
tracing programs.ACM Transactions on Programming
Languages and Systems, 16:1319–1360, July 1994.
[2] Eric Bodden, Laurie Hendren, Patrick Lam, Ond ˇrej Lhoták,
and Nomair A. Naeem. Collaborative runtime veriﬁcation189with tracematches. InProceedings of the 7th international
conference on Runtime veriﬁcation, RV’07, pages 22–37,
Berlin, Heidelberg, 2007. Springer-Verlag.
[3] Jim Bowring, Alessandro Orso, and Mary Jean Harrold.
Monitoring deployed software using software tomography.
InProceedings of the 2002 ACM SIGPLAN-SIGSOFT
workshop on Program analysis for software tools and
engineering, PASTE ’02, pages 2–9, New York, NY, USA,
2002. ACM.
[4] Trishul M. Chilimbi, Ben Liblit, Krishna Mehra, Aditya V.
Nori, and Kapil Vaswani. Holmes: Effective statistical
debugging via efﬁcient path proﬁling. InProceedings of the
31st International Conference on Software Engineering,
ICSE ’09, pages 34–44, Washington, DC, USA, 2009. IEEE
Computer Society.
[5] Madeline Diep, Myra Cohen, and Sebastian Elbaum. Probe
distribution techniques to proﬁle events in deployed
software. InProceedings of the 17th International
Symposium on Software Reliability Engineering, ISSRE ’06,
pages 331–342, Washington, DC, USA, 2006. IEEE
Computer Society.
[6] Sebastian Elbaum and Madeline Hardojo. An empirical
study of proﬁling strategies for released software and their
impact on testing activities. InProceedings of the 2004 ACM
SIGSOFT international symposium on Software testing and
analysis, ISSTA ’04, pages 65–75, New York, NY, USA,
2004. ACM.
[7] Michael R. Garey and David S. Johnson.Computers and
Intractability: A Guide to the Theory of NP-Completeness.
W. H. Freeman & Co., New York, NY, USA, 1979.
[8] Jim Gray. Why Do Computers Stop and What Can Be Done
About It? InSymposium on Reliability in Distributed
Software and Database Systems, pages 3–12, 1986.
[9] Rajiv Gupta, Mary Lou Soffa, and John Howard. Hybrid
slicing: Integrating dynamic information with static analysis.
ACM Transactions on Software Engineering and
Methodology, 6:370–397, 1997.
[10] James A. Jones and Mary Jean Harrold. Empirical evaluation
of the Tarantula automatic fault-localization technique. In
Proceedings of the 20th IEEE/ACM international Conference
on Automated software engineering, pages 273–282, New
York, NY, USA, 2005. ACM.
[11] J. R. Larus. Abstract execution: a technique for efﬁciently
tracing programs.Software Practice and Experience,
20(12):1241–1258, November 1990.
[12] Geoffrey Lefebvre, Brendan Cully, Christopher Head, Mark
Spear, Norm Hutchinson, Mike Feeley, and Andrew
Warﬁeld. Execution mining. InProceedings of the 8th ACM
SIGPLAN/SIGOPS conference on Virtual Execution
Environments, VEE ’12, pages 145–158, New York, NY,
USA, 2012. ACM.
[13] Ben Liblit.Cooperative bug isolation: winning thesis of the
2005 ACM doctoral dissertation competition.
Springer-Verlag, Berlin, Heidelberg, 2007.[14] Ben Liblit, Alex Aiken, Alice X. Zheng, and Michael I.
Jordan. Bug isolation via remote program sampling. In
Proceedings of the ACM SIGPLAN 2003 conference on
Programming language design and implementation, PLDI
’03, pages 141–154, New York, NY, USA, 2003. ACM.
[15] S. Maheswari. Traversal marker placement problems are
NP-Complete. Technical report, Dept. of Computer Science,
Univ of Colorado, Boulder, 1976. Rep. CU-CS-092- 76.
[16] R. McDougall, J. Mauro, and B. Gregg.Solaris (TM)
Performance and Tools: DTrace and MDB Techniques for
Solaris 10 and OpenSolaris (Solaris Series). Prentice Hall
PTR, 2006.
[17] Mayur Palankar and Jonathan E. Cook. Merging traces of
hardware-assisted data breakpoints. InProceedings of the
third international workshop on Dynamic analysis, WODA
’05, pages 1–7, New York, NY, USA, 2005. ACM.
[18] Christina Pavlopoulou and Michal Young. Residual test
coverage monitoring. InProceedings of the 21st
international conference on Software engineering, ICSE ’99,
pages 277–284, New York, NY, USA, 1999. ACM.
[19] C. V. Ramamoorthy, K. H. Kim, and W. T. Chen. Optimal
placement of software monitors aiding systematic testing.
IEEE Transaction on Software Engineering, 1(4):403–411,
1975.
[20] Diptikalyan Saha, Pankaj Dhoolia, and Gaurab Paul.
Distributed and Parallel Program Tracing. Technical report,
IBM Research. India, 2013. Technical Report RI3003.
[21] Diptikalyan Saha, Mangala Gowri Nanda, Pankaj Dhoolia,
V. Krishna Nandivada, Vibha Sinha, and Satish Chandra.
Fault localization for data-centric programs. InProceedings
of the 19th ACM SIGSOFT symposium and the 13th
European conference on Foundations of software
engineering, ESEC/FSE ’11, pages 157–167, New York, NY,
USA, 2011. ACM.
[22] Mauricio Serrano and Xiaotong Zhuang. Building
approximate calling context from partial call traces. In
Proceedings of the 7th annual IEEE/ACM International
Symposium on Code Generation and Optimization, CGO
’09, pages 221–230, Washington, DC, USA, 2009. IEEE
Computer Society.
[23] Kaushik Veeraraghavan, Dongyoon Lee, Benjamin Wester,
Jessica Ouyang, Peter M. Chen, Jason Flinn, and Satish
Narayanasamy. Doubleplay: parallelizing sequential logging
and replay. InProceedings of the sixteenth international
conference on Architectural support for programming
languages and operating systems, ASPLOS XVI, pages
15–26, New York, NY, USA, 2011. ACM.
[24] Baowen Xu, Zhenqiang Chen, and Hongji Yang. Dynamic
slicing object-oriented programs for debugging. In
Proceedings of the Second IEEE International Workshop on
Source Code Analysis and Manipulation, SCAM ’02, pages
115–, Washington, DC, USA, 2002. IEEE Computer Society.190