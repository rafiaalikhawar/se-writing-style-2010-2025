Computing Repair Trees for Resolving Inconsistencies in
Design Models
Alexander Reder
Johannes Kepler University
Linz, Austria
alexander.reder@jku.atAlexander Egyed
Johannes Kepler University
Linz, Austria
alexander.egyed@jku.at
ABSTRACT
Resolving inconsistencies in software models is a complex
task because the number of repairs grows exponentially. Ex-
isting approaches thus emphasize on selected repairs only
but doing so diminishes their usefulness. This paper copes
with the large number of repairs by focusing on what caused
an inconsistency and presenting repairs as a linearly growi ng
repair tree. The cause is computed by examining the run-
time evaluation of the inconsistency to understand where
and why it failed. The individual changes that make up re-
pairs are then modeled in a repair tree as alternatives and se -
quences reﬂecting the syntactic structure of the inconsist ent
design rule. The approach is automated and tool supported.
Its scalability was empirically evaluated on 29 UML models
and 18 OCL design rules where we show that the approach
computes repair trees in milliseconds on average. We believ e
that the approach is applicable to arbitrary modeling and
constraint languages.
Categories and Subject Descriptors
D.2.2 [ Software Engineering ]: Design Tools and Tech-
niques
General Terms
Design, Performance
Keywords
Inconsistency Management, Repairing Inconsistencies
1. INTRODUCTION
State-of-the-art on inconsistency management in model-
based software development has focused on detecting incon-
sistencies [21]. Today, many approaches are available and
they detect inconsistencies fast and correctly [14, 17, 8, 5 ].
While it is important to allow inconsistencies [4], they mus t
be resolved eventually. Unfortunately, repairing inconsi sten-
cies is much harder than detecting them because the number
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE ’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00.of alternatives grows exponentially with the complexity of
the design rule and the number of model elements accessed.
Existing approaches either ignore the exponential growth
[18] or emphasize on selected repairs only [7, 20]. Yet other
approaches pose limitations on the consistency language or
focus on individual inconsistencies [24, 11, 18]. All these
limitations are problematic because the designer must ulti -
mately choose and the generated repairs either overwhelm
the designer or may fail to include the one the designer
wants. Since the repair of inconsistencies goes hand in hand
with the creative process of modeling, we strongly advocate
against heuristics that replace the role of the human de-
signer. For example, a repair that favors the fewest model
changes is frequently the same as an undo.
Our approach combines the structure of design rules (as
in xLinkit [18]), the design rule’s expected and observed
validation results (in part through observing the rule’s va l-
idation as in [9]), and basic facts about the meta model
(types of ﬁelds, non-changeable model elements) to ﬁlter
impossible changes. The structure is important for under-
standing the inconsistency and enumerating repair alterna -
tives. For example, if an inconsistent rule’s structure re-
quires A∧B=true then there are three repair alternatives
(as generated by xLinkit): repair A, repair B, or repair A
andB. This list appears reasonable, however, it may contain
incorrect repair alternatives and non-minimal repair acti ons.
For example, if Bis true already then 1) repair Bis incorrect
because it would repair something that is not broken and 2)
repair AandBis non-minimal because it would repair more
than necessary. Of course, repair Amay inadvertently break
Bwhich is a side eﬀect and also detectable by our approach.
By eliminating false and non-minimal repairs, the ap-
proach vastly reduces the number of repair alternatives; ho w-
ever, not necessarily the exponential growth. This paper
thus also introduces repair trees. A repair tree organizes
the repair actions in a hierarchical manner that reﬂects the
structure of the design rule. The repair tree is thus intu-
itive to understand and, more signiﬁcantly, the repair tree
(repair actions) grows linearly with design rule complexit y
(expressions that must be validated).
The main contribution of this paper is a fully automated,
tool supported, scalable approach for generating a complet e
set of repair alternatives; where each alternative consist s of
sequences of model changes (repair actions) that are needed
to resolve the inconsistency. Typically, there exist many
alternatives for repairing inconsistencies, however, the se al-
ternatives strongly overlap in the model changes (repair ac -
tions) they require. Enumerating all repair alternatives i sPermission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
220
trivial in principle; however, it results in a large number o f
alternatives – too many for human consumption. The repair
tree computed by our approach focuses on repair actions on
the part of the model that caused the inconsistency and or-
ganizes those repair actions in a hierarchical manner to hel p
the designer decide how to repair the model. Its correct-
ness and scalability was validated on 29 mostly industrial
models. The approach was designed to apply to arbitrary
modeling language (our focus on three quite distinct types
of UML diagrams supports this since these diagrams are of-
ten considered separate modeling languages) and constrain t
languages.
The remainder of this paper is organized as follows. Sec-
tion 2 deﬁnes the basic terms that are used in this paper
and Section 3 illustrates the main idea. The approach is
discussed in Section 4 and validated in Section 5. Section 6
gives an overview of related work and Section 7 concludes
this paper with an outlook on future work.
2. DEFINITIONS
This section provides some basic deﬁnitions:
Definition 1.Amodel represents the software system
that must be implemented. It consists of model elements
which contain properties , e. g., a name or a reference to
other model elements.
Adesign rule deﬁnes a requirement that the model must
fulﬁll. The requirement is expressed as a condition that
evaluates to true (consistent) or false (inconsistent). A d e-
sign rule is written for a speciﬁc context that can be a single
model element (the design rule will be validated once) or a
type of model element (the design will be validated for each
instance of this model element type in the model).
Design Rule :=/an}bracketle{tcontext, condition /an}bracketri}ht
condition :context → {true, false }
Definition 2.A design rule condition consists of a set of
hierarchical ordered expressions where each expression co n-
sists of an operation ( o), a set of 0 to * arguments ( α), an
expected ( σ) and a validated result ( ς). The arguments of an
expression (ǫ) are also expressions, forming a tree analo-
gous to that of programming languages. An expression has
exactly one parent except for the root expression ( ǫ0) but as
many child expressions as there are arguments.
condition :=n/uniondisplay
i=0ǫi|/braceleftBigg
∃i, j:ǫj∈ǫi.α ifj >0, i/ne}ationslash=j
∄i, j:ǫj∈ǫi.α if j=0, i /ne}ationslash=j
ǫ:=/an}bracketle{to, α, σ, ς /an}bracketri}ht
Definition 3.Arepair action (τ) deﬁnes a change of
a model element property that resolves an inconsistency in
part or full (often multiple repair actions are needed to re-
solve an inconsistency). A repair action contains the type o f
change ( λ), the model element ( ω), and the model element
property ( γ) that is aﬀected by a change. The following types
of changes are possible: add(adds a model element), delete
(deletes a model element) or modify (modiﬁes a model ele-
ment property).
τ:=/an}bracketle{tλ, ω, γ /an}bracketri}ht
λ∈ { add, delete, modify }Switch
Light
turn-on
deactivates:Switch l:Light
1:activate
2:deactivate
Figure 1: Inconsistent UML Class and Sequence Di-
agram for a Light Switch
Definition 4.Arepair tree (R) is a hierarchical or-
dered set of repair actions for a single inconsistency. The
nodes of a repair tree deﬁne whether the underlying repair
actions are alternatives ( •) or sequences ( +) .
3. ILLUSTRATION AND PROBLEM
To illustrate an inconsistency, Figure 1 introduces a small
UML model. The model consists of a class diagram contain-
ing a ‘Switch‘ and a ‘Light‘ class. The sequence diagram
reveals that the ‘Switch‘ calls ‘activate‘ and ‘deactivate ‘ on
the ‘Light‘, to turn on or turn oﬀ the light.
Design rule 1 is an example of a non-trivial UML design
rule. It validates whether a given message in a sequence
diagram matches the direction of the class association (1.1 )
and whether that class has an operation that matches the
message name (1.2). Design rules are typically written from
the perspective of a context element. In the case of design
rule (1) the context is the UML type ‘Message‘.
Message m :
(∃l1∈m.receiveEvent.covered,
l2∈m.sendEvent.covered :
∃a∈l2.represents.type.ownedAttribute :
a/ne}ationslash=null⇒a.type =l1.represents.type )

(1.1)
∧
(∀l∈m.receiveEvent.covered :
∃o∈l.represents.type.ownedOperation :
o.name =m.name )

(1.2)(1)
The condition of design rule (1) is a Boolean expression
that is validated on the design model. The rule reveals the
sequence in which model elements are accessed and the spe-
ciﬁc properties are used. For example, rule 1 is a conjunctio n
∧with the ﬁrst argument being an universal quantiﬁer ( ∀)
and the second argument an existential quantiﬁer ( ∃). The
universal quantiﬁer iterates over a set of lifelines l. These
lifelines are found by ﬁrst validating the ‘receiveEvent‘ p rop-
erty of the ‘Message m‘, which references another model
element of type ‘MessageOccurenceSpeciﬁcation‘; and then
by validating the ‘covered‘ property of that ‘MessageOc-
curenceSpeciﬁcation‘, which references a model element of
type ‘Lifeline‘. Details on the model elements and their
properties can be found in [2]. The universal quantiﬁer then
iterates over all lifelines found to ensure that all lifelin es sat-
isfy the quantiﬁer condition. This condition is another exi s-
tential quantiﬁer ( ∃o∈l.represents.type.ownedOperation ).
Each validation starts at a context element (‘Message m‘
in this case) which means that the context element is always
the ﬁrst element accessed during the validation of a design
rule. There are thus as many validations necessary as there
are instances of the context element (instances of ‘Message ‘
in this case). So this design rule will be validated twice on
the model shown in Figure 1 – for message ‘activate‘ and
for message ‘deactivate‘. Both validations are inconsiste nt221because neither message matches the direction of the class
association (only class ‘Light‘ can access ‘Switch‘, contr ary
to the message call directions in the sequence diagram). Als o
note that the validation on the message ‘activate‘ fails be-
cause the class ‘Light‘ has no operation ‘activate‘. Both va l-
idations investigate the same design rule but because they
commence at distinct model elements (method ‘activate‘ vs.
‘deactivate‘) they do not necessarily access the same model
elements or yield the same validation result. Each valida-
tion thus accesses a potentially overlapping but unique par t
of the model. If the validation of a design rule fails (=incon -
sistent) then this accessed part of the model must contain
an error. We say that part of the model to have caused
the inconsistency. In previous work [9], it was demonstrate d
that often a small set of model elements causes a given in-
consistency. Nonetheless, there are many choices for repai r-
ing inconsistencies because each combination of the access ed
model elements could be changed – an exponential explosion.
For example, to repair the inconsistent message ‘activate‘ ,
we could add an operation ‘activate‘ to class ‘Light‘ and
add a association from ‘Switch‘ to ‘Light‘ (a sequence of two
repair actions); or we could rename operation ‘deactivate‘
to ‘activate‘ and change the arrowhead of the existing as-
sociation between ‘Light‘ and ‘Switch‘; or we could perform
variations of these and other repair actions.
Enumerating all repair alternatives would yield a list of
correct choices from which the designer must choose one.
However, enumerating all repair alternatives would likely
overwhelm the designer. For example, during the validation
of ‘activate‘, ten model element properties are accessed. B y
considering their combinations there are 1,023 repair alte r-
natives (comparable with the cardinality of the power set
of involved model elements minus the empty set: |P(n)−
∅|=2n−1, where nis the number of model elements in-
volved). In practice, some of these combinations are infeas i-
ble but this does not alter the exponential complexity. We
will show later that by customizing the repair to the cause
of this particular inconsistency, we can correctly elimina te
most wrong repairs and non-minimal repairs. This reduces
the repair alternatives to 72 combinations. We further or-
ganized these combinations into a repair tree containing 17
repair actions, that asks the designer to make two decisions
with eight and nine choices, respectively.
We believe that by considering the immediate cause of
an inconsistency as well as the hierarchical representatio n of
the generated repairs, we now have the means of providing
comprehensive error feedback in small enough chunks for
a designer to comprehend. Additionally, the incremental
character of this approach ensures that repair alternative s
are available to the designer on demand.
4. APPROACH
The following introduces our approach for generating re-
pair trees for inconsistencies. Our approach generates the se
repairs on demand and the repairs are tailored to the struc-
ture of the inconsistent design rule condition.
4.1 Principle
Consider the design rule A∨(B∧C) where A,B, and
Care Boolean expressions. If inconsistent, any combina-
tion of these three Boolean expressions may need repair-
ing. The repair alternatives are: {A},{B},{C},{A, B},
{A, C},{B, C}, or{A, B, C }. For example, repair {B}sug-Repairs for A=false ∨(B=false ∧C=false )
•
Repair A+
Repair B Repair C
Figure 2: Repair Tree for A=false ∨(B=false ∧C=
false )
gests a way of changing the model elements referred to by
Bsuch that validating Bbecomes true. Recall that design
rule (1) was essentially a conjunction (like B∧C). Hence,
repair {B}could imply repairing one argument of that con-
junction (e. g., ∀l∈m.receiveEvent.covered... ) which may
require repairing one or more model elements accessed by
that argument. A repair alternative may contain sequences
of repair actions (e. g., repair {B, C}is a sequence of repair
{B}and repair {C}) and repair alternatives may overlap in
their repair actions (e. g., repair {C}overlaps with repair
{B, C}).
However, not all repair alternatives identiﬁed above are
necessary. For example, repair {A}would make A∨(B∧C)
consistent regardless of repairs to {B}or{C}. Hence, by
considering the structure of the design rule condition we ca n
eliminate unnecessary combinations of repair actions, suc h
as repair {A, B},{A, C}and{A, B, C }. The list of still
complete repair alternatives for this design rule shrinks t o:
{A},{B},{C}, or{B, C}. The approach by Nentwich et
al. [18] analyzes the design rule’s structure to compute rep air
alternatives and actions as in this example. This list appli es
to the design rule as a whole and thus is applicable to all
inconsistencies of this design rule. However, this list is n ot
yet customized to a particular inconsistency. While more
concise, there are still incorrect repair alternatives bec ause
we did not consider how inconsistencies are caused. Let
us assume that Bis true already while AandCare false.
A∨(B∧C) would be inconsistent but, in this particular
scenario, only two repair alternatives out of the four above
are feasible: repair {A}or repair {C}. Repair {B}is an
incorrect repair because for as long as Cis false it does
not matter how Bis changed. And repair {B, C}is a non
minimal repair because it forces the designer to also repair
{B}even though it is not broken.
It is important to understand that the repair alternatives
for any two inconsistencies may diﬀer. For example, if all
three expressions A,BandCwere false then the correct list
of repair alternatives would be: repair {A}or repair {B, C}.
In fact, there is no combination of A,BandCbeing true or
false that would require all four repair alternatives {A},{B},
{C}, and {B, C}. We found that approaches that rely on
a static analysis of the design rule condition only are rarel y
minimal. By focusing on the violated parts of an inconsisten t
design rule condition we are able to reduce the list of repair
alternatives. However, the list of repair alternatives may still
be large. We thus propose to describe repair alternatives in
form of sequences ( and) and alternatives ( or): repair A or
(repair {B}andrepair {C}) for A=B=C=false . These
sequences and alternatives can be visualized as a repair tree,
where the sequences are + nodes and alternatives are •nodes
(see Figure 2).222m[activate ]
∧false
∀false
l∈m.receiveEvent.covered
∃false
o∈l.represents . . .
=false
o[turn −on]m[activate ]=false
o[deactivate ]m[activate ]∃false
l1∈m.rec . . .
l2∈m.sen . . .
∃false
a∈l2.rep . . .
Figure 3: Validation Tree log the Validation of De-
sign Rule (1) for Message ‘activate‘
This example of a repair tree may not appear shorter com-
pared to the list of all repair alternatives but we will demon -
strate that the repair tree grows linearly with design rule
size avoiding the exponential growth of repair alternative s.
Moreover, we believe that the repair tree is more informa-
tive to the designer because it is structured instead of a ﬂat
list.
4.2 Understanding the Inconsistency
Understanding an inconsistency is needed for eliminating
incorrect repairs and non-minimal repairs. Our approach
bases this understanding on the rule’s validation and its in -
termediate validation results. Technically, this is achie ved
by instrumenting the consistency checker and logging step-
by-step the design rule’s validation. We refer to this log as
the validation tree which contains all operations performe d,
their results, and the model elements accessed along the way
(leaves). Computing a validation tree is analogous to pro-
ﬁling . Code proﬁling, a well known technique in code un-
derstanding [16, 12], logs the executing code (usually in a
hierarchy that reﬂects method calls). Design rule proﬁling
logs the validation of a design rule in the hierarchy that
reﬂects the structure of the design rule (e. g., its syntax).
Figure 3 depicts the validation of rule 1 on message ‘ac-
tivate‘ as a validation tree. Recall from Section 3 that the
condition of design rule (1) was a conjunction ( ∧) with the
ﬁrst argument ( ∀l∈m.rec... ) validating whether the mes-
sage name has a corresponding operation name and the sec-
ond argument ( ∃l1∈m.rec... ) validating whether the calling
direction matches the message direction. The consistency
checker thus ﬁrst validated the conjunction and hence the
top level node in the validation tree is the ∧node. To vali-
date the conjunction, the consistency checker then validat es
its two arguments. The two sub nodes in the tree correspond
to the two arguments – a ∀node and a ∃node. The ﬁrst
argument was a universal quantiﬁer ( ∀). The elements this
quantiﬁer iterated over (the source) were identiﬁed by the
ﬁrst argument of that quantiﬁer ( l∈m.rec... ).
The consistency checker found a list of lifelines upon vali-
dating this source. The quantiﬁer then validated the quan-
tiﬁer’s condition on every lifeline found ( ∃o∈l.rep... ). The
validation tree thus depicts the source as a leaf (leaves are
model elements accessed) and each validation of a lifeline
it depicts as a separate sub tree. Hence, a quantiﬁer node
may have a variable number of sub nodes: each describingm[deactivate ]
∧false
∀true
l∈m.rec . . .
∃true
o∈l.rep . . .
=true
o[deactivate ]m[deactivate ]∃false
l1∈m.rec . . .
l2∈m.sen . . .
∃false
a∈l2.rep . . .
Figure 4: Validation Tree log the Validation of De-
sign Rule (1) for Message ‘deactivate‘
the validation of the condition of each element in the source .
Since in our example, the source identiﬁes a single lifeline
(l:Light ), only one sub tree is needed to describe its vali-
dation on the quantiﬁer condition in Figure 3 (starting with
the∃node beneath the ∀node). The existential quantiﬁer
is similar to the universal quantiﬁer. Analogous to the uni-
versal quantiﬁer, the existential quantiﬁer deﬁnes its sou rce
(o∈l.rep... ), a list of all operations owned by the lifeline’s
type (class ‘Light‘), and a condition that at least one eleme nt
in the source must satisfy.
There are two UML operations in the class ‘Light‘ (oper-
ations ‘turn-on‘ and ‘deactivate‘). The existential quant iﬁer
then iterates over both operations to identify whether the
operation name equals the message name. Hence, the exis-
tential quantiﬁer node in the validation tree has a leaf de-
noting the source and two sub trees, one for validating each
operation. Since both sub trees evaluate the same quantiﬁer
condition (comparing an operation name with a message
name: o.name =m.name ) it follows that both sub trees
are identical in structure. Both sub trees thus have a top-
level comparison node (=) and their respective sub nodes
are the arguments of the comparison. In both cases, the
arguments identify properties of model elements. For ex-
ample, the ﬁrst sub tree compares (=) the operation name
‘turn-on‘ with the message name ‘activate‘. Hence, the vali -
dation tree depicts a = node with two leaves corresponding
to the two model elements. For brevity, the validation tree
omits certain data. For example, the leaf o[turn-on] unique ly
identiﬁes the model element (via the element ID), the el-
ement type, and the property name (e. g., /an}bracketle{tA3242ED22,
UML.Operation ,name /an}bracketri}ht).
The validation tree of the second argument of the top-
level ∧node is similar, containing two existential quantiﬁers.
The implication and two comparisons are not depicted in
the validation tree because no attribute is found in the sec-
ond existential quantiﬁer that iterates over the source a∈
l2.represents.type.ownedAttribute (note in the UML spec,
outgoing associations are also attributes and class ‘Light ‘
has neither outgoing associations nor attributes). Hence,
the bottom right ∃node has a source but no sub trees.
It is easy to see that the validation tree mirrors exactly
the validation of the design rule condition. We instrumente d
the consistency checker to be able to automatically monitor
the evaluation step-by-step and record this information. I t
is important to note that the leaves of the validation tree
are either constants deﬁned in the design rule or properties
of model elements accessed during the validation. Some or223all of these properties of model elements need to be changed
to repair the inconsistency.
The edges between Boolean expressions in the validation
tree list the validation results. A validated result ςis the
result of the validated node using its sub nodes as argu-
ments ( α). For example, both = nodes are false because the
strings they compare are not equal; the ∃node above it is
false because no sub node was true; the ∀node above it is
false because at least one sub node was false; and, ﬁnally,
the∧node above it is false because both arguments (in-
cluding the left-handed ∀) are false. The validated results ς
are thus simply the logged, intermediate results computed
by the consistency checker during validation which are also
automatically retrieved through the instrumentation of th e
consistency checker. We see that all nodes in Figure 3 vali-
dated to false.
As discussed earlier, the model elements accessed by an
inconsistency are unique for every validation of a design ru le.
This is evident in the validation of design rule (1) on mes-
sage ‘deactivate‘ which yields a structurally similar vali da-
tion tree (Figure 4) however with somewhat diﬀerent model
elements accessed and diﬀerent validation results for some
nodes. The left hand ∀nodes and edges in Figure 4 are
painted in a dashed style because this part of the tree is not
violated. How to compute this is discussed below.
4.3 Generating Repair Actions
A repair action ( τ) is a change to the model. This change
must modify a property ( ω) of a model element ( γ), insert
elements or values, or deletes them. Repair actions repair i n-
dividual nodes in the validation tree. We will see below how
to compose repair actions into a repair tree by combining
the repair actions with the nodes of a tree. Since the repair
actions diﬀer according to the node operation, Table 1 dis-
cusses how to compute complete and minimal repair actions
for common ﬁrst order logic operations. Complete in the
sense that it lists all possible variants of how to resolve an
inconsistency based on the information from the design rule
validation and minimal in that it avoids the generation of re -
pair actions that do not have an eﬀect for the inconsistency
resolution.
For brevity, the table shows an excerpt of some common
operations only but our tool supports a much larger set of
operations (e. g., all of OCL). The ﬁrst column of Table 1
lists the operations and the repair generator function used
to reference it. The second column speciﬁes the arguments
of the operations and the third column lists the repair ac-
tions that need to be generated. Since the repair of a logical
operation may require the repair of arguments of the logical
operation, the repair generator functions are deﬁned recur -
sively.
Every operation has its own repair generator function
G(ǫ, σ). This function has two parameters: ǫis the expres-
sion containing a logical operation and arguments (e. g., a∧b)
andσis the expected validation result (Boolean). An ex-
pression is inconsistent and must be repaired if its expecte d
result diﬀers from the validated result (recall Section 4.2 ).
The generator functions are thus guarded by conditions in-
volving the expected result σand the validation results ς
observed.
Computing the expected result is simple. The expected
result of the top node in the validation tree is always true
because the design rule condition is expected to validate totrue to be consistent. This expectation is propagated down
to the sub nodes. In Figure 3, the top level ∧node is thus
expected to be true and correspondingly its arguments are
expected to be true also. Certain operations change the
expected result. In the case of the negation (¬), we see in
Table 1 how the expected result is negated. Notice that
the repair action for G(¬a, σ) results in the repair action
for its argument with a negated expected value: G(a,¬σ).
Since some other approaches fail on the negation [24] or thei r
reasoning becomes less eﬀective [18], our simple handling o f
expectations represents another improvement over the stat e-
of-the-art which simpliﬁes the repair generation.
Computing the repair alternatives for any given logical
operation is more complex. Take, for example, the repairing
ofa∧bwhich is described in the generator function G(a∧
b, σ) in Table 1. For simplicity, Table 2 enumerates the
possible repair actions for the various Boolean states of th e
expected result σ, and for the validation results ς. Ifa∧
bis false ( ς=false ) but it is expected to be true ( σ=
true), then there are three possible repair alternatives: 1)
repair a, 2) repair b, or 3) repair both a+b. To identify
the appropriate one, these repair alternatives are guarded .
For example, if it is known that a=true (denoted as ςa=
t) and b=false (denoted as ςb=f) and the expected
result σ=true then repair ais the right choice (denoted
asG(a, σ). The repair for ais then computed recursively
by calling the generator function on awith the expected
result σ=true – the expected result of its parent node.
However, if a∧bis expected to validate to false then the
repair alternatives for a∧bchange because either aorb
need to be false for a∧b=false . Quite relevant are the +
symbol, which denotes a sequence (repair aand repair b),
and the •symbol, which denotes an alternative (repair aor
repair b).
G(ǫ, σ) : f(ǫ, σ)→•/+/uniondisplay
τ
R :=/uniondisplay
G(ǫ0, t)
Since the top level expression of the design rule (1) is a
conjunction ( ∧), (see Figure 4) acorresponds to its ﬁrst
argument (branch) and is a placeholder for the universal
quantiﬁer ( ∀). Repair athus really means to repair the ∀
expression underneath in the validation tree. In our exam-
ple, both arguments are false and hence we need to repair a
and repair b. To understand the repair of an iterator, repair
ais illustrated next.
The ∀expression in the validation tree is divided into
two parts: 1) the repair of the source (deletion/addition de -
pending on the operation type and expected result), and 2)
the repair of one or more violated conditions which where
validated on the elements in the source. For example, the
universal quantiﬁer iterates over all elements of the sourc e
and validates each one with the given condition. The univer-
sal quantiﬁer is false if there exists at least one element th at
violates the condition. If the universal quantiﬁer is expec ted
to validate to true (as in our example) then the deletion of
an element in the source can repair it. This is encoded as
deleting the union of all elements that violate the conditio n
σof the quantiﬁer as depicted in Table 1 in column 3 (top).
The second alternative (column 3 bottom) is to resolve the
inconsistency by repairing the elements that violate the co n-
ditions rather than deleting them. This requires a recursiv e
descend for each argument b(a) that violates σ. In other
words, we would then have to repair the sub trees that cor-224Table 1: Excerpt of Rules for the Generation of the Repairs
G(ǫ, σ) α R
ǫ:=¬a a:Boolean R={G(a,¬σ)
ǫ:=a∧b∗ a:Boolean
b:BooleanR=

G(b, σ) if σ=t, ςa=t, ςb=f
G(a, σ) if σ=t, ςa=f, ςb=t
G(a, σ) +G(b, σ) if σ=t, ςa=f, ςb=f
G(a, σ)•G(b, σ) if σ=f, ςa=t, ςb=t
ǫ:=a∨ba:Boolean
b:BooleanR=

G(a, σ)•G(b, σ) if σ=t, ςa=f, ςb=f
G(a, σ) if σ=f, ςa=t, ςb=f
G(b, σ) if σ=f, ςa=f, ςb=t
G(a, σ) +G(b, σ) if σ=f, ςa=t, ςb=t
ǫ:=a⇒b∗ a:Boolean
b:BooleanR=

G(a, σ)•G(b, σ) if σ=t, ςa=t, ςb=f
G(b, σ) if σ=f, ςa=t, ςb=t
G(a, σ) +G(b, σ) if σ=f, ςa=f, ςb=t
G(a, σ) if σ=f, ςa=f, ςb=f
ǫ:=a=ba:Boolean
b:BooleanR=

τ=/an}bracketle{tmodify, a.element, a.property /an}bracketri}ht ifςb=const
τ=/an}bracketle{tmodify, b.element, b.property /an}bracketri}ht ifςa=const
τ=

/an}bracketle{tmodify, a.element, a.property /an}bracketri}ht
•
/an}bracketle{tmodify, b.element, b.property /an}bracketri}ht
else
ǫ:=∀a:b∗ a:Set
b:BooleanR=

τ=

+/uniontextn
i=1/an}bracketle{tdelete, a.element, a.property /an}bracketri}ht|ςbi=f/an}bracketri}ht
•
+/uniontextn
i=1G(bi, σ)|ςbi=f
ifσ=t
τ=

/an}bracketle{tadd, a.element, a.property /an}bracketri}ht|ςbi=f/an}bracketri}ht
•
•/uniontextG(bi, σ)|ςbi=t
 ifσ=f
ǫ:=∃a:ba:Set
b:BooleanR=

τ=

/an}bracketle{tadd, a.element, a.property /an}bracketri}ht|ς=t/an}bracketri}ht
•
•/uniontextG(bi, σ)|ςbi=f
 ifσ=t
τ=

+/uniontextn
i=1/an}bracketle{tdelete, a.element, a.property /an}bracketri}ht|ςbi=t/an}bracketri}ht
•
+/uniontextn
i=1G(bi, σ)|ςbi=t
ifσ=f
ǫ:=a.ba:Element
b:PropertyR=/braceleftBig
τ=/an}bracketle{tmodify, a, b /an}bracketri}ht
∗This expressions are represented by combining the other exi sting ones using rules from ﬁrst order logic
Table 2: Repair Alternatives for a∧bdepending on
Expected and Validated Results
# a b σ ς=a∧b R
1 true false true false {b}
2false true true false {a}
3false false true false {a+b}
4 true true false true {a•b}
respond to those elements that violated the quantiﬁer. The
other generator functions are similar to the ones discussed
above and not discussed for brevity.
4.4 Composing Repair Trees
Figure 5 depicts the repair tree for the inconsistent mes-
sage ‘activate‘. It is computed if the generator functions
from Table 1 are applied to the validation tree in Figure 3.
The recursive descend described in Section 4.3 thus follows
the structure of the validation tree step-by-step. The re-
pair tree arranges the sequential repair actions (+) and al-
ternative repair actions ( •) from Table 1 according to the
hierarchy of the validation tree. For example, we see that
both branches of the ∧node in the validation tree (Fig-
ure 3) are violated and hence both branches need repairing.
According to Table 1 this requires a sequential repair (+)
– hence the top level node of the repair tree is a +. For
each branch, the repairs are computed next for which thereare eight repair alternatives each ( •) according to Table 1
for existential/universal quantiﬁers. Each quantiﬁer add s an
alternative for each property call of the source (‘ .‘ ) and de-
pending on the quantiﬁer an alternative ( ∃) or combination
(∀– in our case this quantiﬁer has only one branch).
Actually repairs are the model elements encountered in
the validation tree during the recursive descend. We ﬁnd a
total of 17 repair actions in the repair tree (Figure 5) for th e
validation tree in Figure 3. For example, /an}bracketle{tadd,Class [light ],
ownedOperation /an}bracketri}htis added to the repair tree during the re-
pair of the left-hand existential node where Table 1 suggest s
to add an element to the source ( ∃o∈l.rep... ). The UML
spec reveals that the source may only hold instances of UML
type Operation and hence adding another operation to the
class ‘Light‘ may repair this inconsistency. Note that the
repair action does not say whether this operation should
be created anew or should come from elsewhere (e. g., an-
other class). Nentwich et al. [18] refer to such repair actio ns
as abstract repairs. The repair tree also identiﬁes alterna -
tive repair actions such as /an}bracketle{tmodify ,Operation [turn −on],
name /an}bracketri}htwhich suggests to rename operation ‘turn-on‘. This
repair action is added during the repair of the ﬁrst = node
where Table 1 suggests to modify either the ﬁrst or second
argument. Again note that the repair action does not reveal
what string to rename it to. Indeed, any existing approaches
for computing concrete repairs may be used to complement
our repair trees with concrete values and this will be the
focus of our future work.225From this repair tree, it is possible to compute repair
alternatives. The designer knows that at least one repair
action from each branch must be chosen. There are thus
two decisions to be made, one with eight and one with nine
choices, accounting for 72 distinct repair alternatives. H ow-
ever, not all combinations in the repair tree make sense.
For example, deleting the lifeline ‘light‘ (done by /an}bracketle{tdelete ,
Message [activate ],covered /an}bracketri}ht) would make it impossible to
change the type of that lifeline ( /an}bracketle{tmodify ,Lifeline [light ],
type/an}bracketri}ht). The ﬁltering of these combinations is simply done
by detecting the overlaps of the model elements and their
properties. Therefore, two actions that have the model el-
ement and property in common or if the value if the prop-
erty of one action is the model element of the other action
(e. g., the Lifeline ‘light‘ is the value of the message ‘acti vate‘
covered property), regardless of the action type, cannot be
composed. The ﬁltering reduces the number of repair alter-
natives from 72 down to 39:
∄τi, τj∈R:τi+τj∧(ωi=ωj∧γi=γj∨ωj∈γi)
We say that a sub tree did not cause the inconsistency
if its validation result equals the expected result. The re-
pairing is thus a recursive descend that terminates either a t
nodes where the expected value equals the validated value
or at their leaves which are the model elements that need re-
pairing. In Figure 4 we painted the part of the sub tree that
did not cause the inconsistency in a dashed style. Design
rule (1) validated on ‘deactivate‘ was thus partially incon -
sistent because only the validation of the message directio n
failed but not the validation of the operation name – con-
trary to design rule (1) validated on ‘activate‘, which was
fully inconsistent. Figure 6 depicts the corresponding rep air
tree for the inconsistent message ‘deactivate‘. This repai r
tree is not only diﬀerent in structure but the repair actions
also refer to partially diﬀerent model elements. We see that
there is only one decision to be made, involving nine choices ,
accounting for nine distinct repair alternatives. Note tha t
the repair tree for the message ‘activate‘ (Figure 5) is ﬂat-
tened because nested alternatives can be ﬂattened. Notice
in the repair tree for the message ‘deactivate‘ (Figure 6), w e
chose not to ﬂatten the tree, depicting a hierarchy of two
alternatives that are the result of the two nested existenti al
quantiﬁers in the design rule.
4.5 Identifying Side Effects
Note that the example A∨(B∧C) in Section 4.1 ignored
side eﬀects in that BandCmay in fact access overlapping
model elements and repair Bcould conceivably also repair
C. It is a well known problem that repairs to inconsistencies
may aﬀect other design rules – they may solve other incon-
sistencies or they may cause other inconsistencies. Thus,
repairs should not be seen in isolation [19]. Understanding
side eﬀects is important during the repairing of inconsis-
tencies to get an overview of the overall eﬀect of a repair
action on the model. In our approach, potential side ef-
fects are readily computable by investigating which repair
actions are shared among the repair trees of diﬀerent in-
consistencies. Comparing the repair trees in Figure 5 and
Figure 6, we ﬁnd that both share the repair action /an}bracketle{tadd,
Class [light ],ownedAttribute /an}bracketri}ht. This repair action suggests
adding an attribute to class ‘Light‘ which has the poten-
tial to (partially) solve both inconsistencies. The potent ialR +•/an}bracketle{tmodify, Message [activate ],receiveEvent /an}bracketri}ht
/an}bracketle{tmodify, Message [activate ],sendEvent /an}bracketri}ht
/an}bracketle{tadd, Message [activate ],covered /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], represents /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], type /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [switch ], represents /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [switch ], type /an}bracketri}ht
/an}bracketle{tadd, Class [switch ], ownedAttribute /an}bracketri}ht
/an}bracketle{tadd, Class [light ], ownedAttribute /an}bracketri}ht
•/an}bracketle{tmodify, Message [activate ],receiveEvent /an}bracketri}ht
/an}bracketle{tdelete, Message [activate ],covered /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], represents /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], type /an}bracketri}ht
/an}bracketle{tadd, Class [Light ], ownedOperation /an}bracketri}ht
/an}bracketle{tmodify, Message [activate ],name /an}bracketri}ht
/an}bracketle{tmodify, Operation [turn −on], name /an}bracketri}ht
/an}bracketle{tmodify, Operation [deactivate ], name /an}bracketri}ht
Figure 5: Repair Tree for the Inconsistent Message
‘activate‘
R •/an}bracketle{tmodify, Message [deactivate ],receiveEvent /an}bracketri}ht
/an}bracketle{tmodify, Message [deactivate ],sendEvent /an}bracketri}ht
/an}bracketle{tadd, Message [deactivate ],covered /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], represents /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [light ], type /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [switch ], represents /an}bracketri}ht
/an}bracketle{tmodify, Lifeline [switch ], type /an}bracketri}ht
•/an}bracketle{tadd, Class [switch ], ownedAttribute /an}bracketri}ht
/an}bracketle{tadd, Class [light ], ownedAttribute /an}bracketri}ht
Figure 6: Repair Tree for the Inconsistent Message
‘deactivate‘
side eﬀect is conservative as it identiﬁes all possible eﬀec ts
(the worst case). The conservative nature is useful for the
repairing of inconsistencies to understand all potential e f-
fects the repair action may have. Side eﬀects not only exist
among design rules but may also exist within design rules.
Indeed, looking at the repair tree for the ‘activate‘ incon-
sistency (Figure 5) we ﬁnd that the repair action /an}bracketle{tmodify ,
Message [activate ],receiveEvent /an}bracketri}htappears on both sides of
the conjunction. This single repair action may thus repair
the entire inconsistency.
The above examples indicate positive side eﬀects in that
one repair may also repair other inconsistencies (or their
parts). Side eﬀects may also be negative in that one repair
may cause an inconsistency where there is none. Such po-
tential side eﬀects are also detectable by checking whether a
repair action of a repair tree references a model element in
the validation scope (which is needed and used for the incre-
mental re-validation of a design rule) of a consistent desig n
rule. This was already discussed in [11] and is not explored
here further.
4.6 Model/Analyzer Tool
The approach is fully automated and tool supported in
the Model/Analyzer plug-in for the IBM Rational Software
Architect (RSA). The tool uses a generic language, called ab-
stract rule language (ARL), as the constraint language and
it is possible to map arbitrary constraints languages to ARL
(e. g., OCL, Beanbag, or xLinkIt). Another motivation in
favor of ARL is that it provides a quite reduced set of op-
erations and the mapping from a given constraint language,
say OCL, combines these operations. For example, an op-226100101102103104105
102103104105
Model Size [#Elements]# Repair Actionsa)
++++++++
+++++++++
+++++
++++
add
××
××××××××××××××××××××
××××××××delete
||||||
||
|||
|
|||
|||
||
||
|||||||
|modify
⊕⊕⊕⊕⊕ ⊕
⊕⊕
⊕⊕⊕
⊕⊕⊕⊕
⊕⊕⊕
⊕
⊕⊕⊕
⊕ ⊕⊕⊕⊕⊕⊕⊕actions/inconsistency
02468101214
101102103104105
Design Rule Size [#Nodes]# Repair Actionsb)+
+++
++ +
++
+
+++actions/inconsistency
DR12DR6
DR15
DR7DR18
DR5DR14
DR4DR3
DR9 DR11DR13
Figure 7: Repair Actions depending on the a) Model
Size, b) Design Rule Size
eration like ⇒(implies) is represented in ARL as ¬A∨B.
This simpliﬁes the repair language discussed earlier, yet, it
must be stressed that from the designer’s perspective, ARL
is invisible (i. e., the design writes the design rules in, fo r
example, OCL and the constraint is converted internally to
ARL). The tool may be downloaded from http://www.sea.
jku.at/tools/ .
5. EV ALUATION
We evaluated our approach on 29 mostly industrial UML
design models (ranging from 104 up to 33,347 model ele-
ments) and 18 design rules written in OCL (all of them are
characterized in [10] however do note diﬀerences in metrics
due to UML 1.4 to UML 2.1 conversions and the fact that
the design rules were rewritten from JAVA to OCL). In all,
repair actions for over 6,560 inconsistencies were evaluat ed.
In Section 4.3 we demonstrated that repairs are generated
out of the validation tree. Since all violated parts of the va l-
idation tree are considered for the generation of the repair
actions, it follows that there are no other model elements
which can be changed to repair an inconsistency (complete-
ness). Since the recursive traversal of the validation tree
investigates all elements involved in a violation implies t hat
there are no actions included in a repair alternative that do
not have the potential to resolve an inconsistency (minimal ).
That is as the ﬁltering of the validation tree deletes all tho se
branches that are not violated (i. e., these branches cannot
cause the inconsistency) and as such no repair actions will b e
generated that may change model elements that are at the
leaves of those branches. This informal proof of correctnes s
was additionally conﬁrmed empirically by rechecking the re -
pair alternatives and their repair actions which is discuss ed
next.
Our evaluation shows that the repair alternatives for the
detected inconsistencies consist of at least one action and for
each inconsistency at least one repair alternative has been
generated. This demonstrates general applicability. Fig-
ure 7 a) shows the number of generated actions depending
on the model size. The total number of repair actions for00.20.40.60.81.01.2
102103104105
Model Size [#Elements][ms]a)
+
++
+++++ ++++++++++++++++++++++validation
× ××
××
×
××
×××
×
×××
××××
×
×××××
× ××××repair generation
10−210−1100101
101102103104105
Design Rule Size [#Nodes][ms]b)+
++
+ + + + ++
+ +++validation
×
××
×××
×××
××
××repair generation
Figure 8: Computation Time depending on the a)
Model Size, b) Design Rule Size
each model is split up into the three types of actions: add,
delete and modify actions. Additionally, we show the ac-
tions per inconsistency. While the number of repair actions
(alternatives) increases linear with the model size (like t he
number of inconsistencies), the number of repair actions pe r
inconsistency remains stable in average. Since the repair
actions are the nodes of the repair tree, this implies that
the repair tree size remains constant with regard to design
model size (note the logarithmic scale of both axes).
In Figure 7 b) the average number of repair actions per
inconsistency is shown in relationship to the average size o f
the design rules (the size of a design rule was measured as
the number of nodes in its validation tree). Only those de-
sign rules are shown in Figure 7b) and later in Figure 8b)
that are inconsistent. As this ﬁgure shows, the number of re-
pair actions increases logarithmically (less than linear; note
the logarithmic scale of the x-axis only). The repair trees
have between one and thirteen repair actions per inconsis-
tency and design rule in average. Given that the repair trees
are typically structured, their sequences and alternative s in-
dividually are small enough in size to match the humans‘
cognitive abilities (Miller’s 7 +/- 2).
To show the usability in regard to the response time of our
approach we evaluated the scalability as factor for the mode l
size and the complexity of the design rules. The evaluations
were done on an Intel Core 2 Quad CPU @2.83GHz with
8GB (3.5GB available for the RSA) RAM and 64bit Linux
(2.6.37). We measured the time it takes to validate the
design rules, i. e., to detect an inconsistency. Furthermor e,
we measured the time it takes to calculate the repair trees
and their side eﬀects for all 6,560 inconsistencies.
Figure 8 a) shows the average times it takes to validate the
design rules and to calculate the repair actions and their si de
eﬀects. Each spot represents the average time over all desig n
rules in the model. As can be seen, the computation time per
inconsistency is independent of the model size with 99% of
the validations, repair tree/side eﬀect computations done in
less than 1ms. The time to calculate the repair trees and side
eﬀects also includes the generation of the validation tree f or227design rules that are not violated but needed for computing
the side eﬀects of repair actions. In addition to the average
times, we also evaluated the maximum times which is about
300ms for the validation and 500ms for the repair and side
eﬀect generation. Our approach is thus highly scalable.
Regarding the design rule size, the situation is quite sim-
ilar. Figure 8 b) shows the times for validation and com-
puting repair tree and side eﬀect depending on the design
rule size. Each spot in this diagram represents the average
of a single design rule validation (total 6,560 inconsisten -
cies/validations). As can be seen, the validation time grow s
linear (please note the logarithmic scale on both axes) with
the design rule size whereas the time to generate the repair
trees and their side eﬀects remains nearly constant. This
is likely due to the fact that the generation of repair trees
and their side eﬀects is a navigation in the validation tree
and depends on the depth of the validation tree and not the
breadth. The average validation times for design rules are
less then 6ms in average and the worst case is 300ms. More-
over, our evaluation shows that the number of design rules
to validate decreases with the complexity of the design rule ,
i. e., the more complex a design rule, the fewer times it tends
to be validated. This fact is reﬂected in Figure 8 a) where
the average time to validate a design rule is much less than
the validation depending on the design rule’s size.
The memory cost is linear to the design rule complexity
and negligible because the validation tree may be discarded
immediately after the computation of the repair tree.
6. RELATED WORK
Document management systems (DMS), check the consis-
tency of interrelated documents that are processed by a team
of authors. For example, Scheﬀczyk et al. [22] use s-DAGs [1]
to represent the documents and the design rules. Repairs for
inconsistent documents are derived from the s-DAG repre-
sentation and not from the documents. Heuristics are used
to eliminate unnecessary repairs. As this might be useful in
the ﬁeld of DMS this is not useful for model-based software
development, because each software project has diﬀerent re -
quirements and so no generic heuristics can be derived that
are applicable for all software projects. Furthermore, the
generation process of repairs is independent of the inconsi s-
tency detection process and it is a multilevel process that
results in increasing time consumption. With xLinkIt [17]
Nentwich et al. provide an incremental approach to evaluate
the consistency of arbitrary XML documents. They also pre-
sented a repair framework for inconsistent distributed doc u-
ments [18]. However, as was discussed earlier, their approa ch
is conservative and may suggest non-minimal and even in-
correct repair actions if the design rule is partially viola ted
only. Nonetheless, we consider this work as a foundation to
our work. Table 1 is clearly based on their principles.
Xiong et al. [24] present an approach that combines the
detection of errors and provides actions to repair them on
UML models. They use their own language to deﬁne the
consistency relations. This language, called Beanbag , has
an OCL-like syntax and provides a ﬁxing semantic for ele-
ments that are changed. However, when writing consistency
relations, the designer also has to specify how this relatio n
has to be ﬁxed when it is violated – a manual and error
prone activity without guarantee for completeness or cor-
rectness. Dam [7] analyzed and developed an approach on
how OCL constraints, based on their internal structure, canbe violated or resolved respectively. He distinguishes ﬁve
diﬀerent actions that can be taken to achieve a violation or
resolution. Abstract repair plans are generated at compile
time, i. e., the set of OCL constraints is statically deﬁned
in the tool, and this abstract actions are instantiated if th e
constraint is violated by the model. The repair plans that
resolve the inconsistency are ranked and provided to the
user who decides which plan to execute. The repair plans
can also be modiﬁed or executed partially. This approach
is designed exclusively for OCL and a proof is given that
this approach is correct and complete regarding single OCL
operations. However, in contrast to [18], this approach con -
siders all inconsistencies at once which is both a scalabili ty
problem as recognized by the authors nor necessarily in the
spirit of tolerating inconsistencies [4].
Van Der Straeten [23] use a knowledge base, expressed
as description logic as well as the query and rule language
nRQL to generate repairs for inconsistent models. The in-
consistencies are detected by nRQL queries where the vari-
ables of these queries are bound to model elements. The res-
olutions are represented as nRQL rules that consist of state -
ments that add or remove data from the model to resolve
the inconsistency. This approach also considers all incon-
sistencies at once and generates a set of repair actions that
transform the model from an inconsistent state to a fully
consistent one – if a solution exist. As this approach must
transform the model and the inconsistency rules into de-
scription logic, it has no incremental characteristic, i. e ., the
operation is similar to batch based approaches that are very
time consuming. Moreover, the same limitation as for [7]
apply.
Almeida et al. developed a prolog-based approach [3] that
generates repair plans for inconsistencies. These repair p lans
consist of actions in Praxis notations that are needed to
resolve as many inconsistencies as possible causing as few
new inconsistencies as possible. As there exists an inﬁnite
number of ways to resolve inconsistencies, this approach ha s
a conﬁgurable exploration level which reduces the number of
repairs with the danger of not resolving the inconsistencie s.
An incremental approach for detecting and repairing in-
consistencies is presented in [8] and [9]. It uses various la n-
guages for the deﬁnition of design rules, like C# or Java
and is extended to use OCL for the deﬁnition of dynamic
constraints (design rules) [13] during run time. It does not
need any annotations or modiﬁcations of existing languages
to check the consistency of UML models. Based on this
approach, [9] and [11] presents how to repair inconsisten-
cies in models and how the generated choices are evaluated.
However, this approach is overly conservative and generate s
repairs for all model elements accessed by the validation of
an inconsistency, while often only a subset thereof causes
the inconsistency. Nonetheless, this work borrows exten-
sively from these approaches – particularly, to enable the
computation of side eﬀects as an incremental exploration of
possible changes imposed by repairs.
Heged ¨us et al. present an approach that is based on graph
transformations which generates quick ﬁxes for DSMLs (Do-
main Speciﬁc Modeling Languages) [15]. They use a graphi-
cal notation to express the model and the constraint. Based
on the DSMLs the approach creates quick ﬁxes to resolve an
inconsistency using CSP(M) (Constraint Satisfaction Prob -
lems over Models). The quick ﬁxes contain as many actions
as needed to resolve a given inconsistency.228Furthermore, Czarnecki and Pietroszek [6] use OCL to
deﬁne well-formedness rules for the veriﬁcation of feature -
based model templates which are analyzed by a SAT solver.
While not directly relevant to the ﬁxing problem, the abilit y
to translate constraints requires detailed understanding of
constraint semantics which is very relevant in this work.
7. CONCLUSIONS AND FUTURE WORK
This paper presented a novel approach for generating re-
pairs for inconsistencies in software models. Our approach
combines the syntactic and dynamic structure of an incon-
sistent design rule to pinpoint exactly which parts of the
inconsistency must be repaired. As a result, our approach
generates a concise tree of repair actions that is small, com -
plete and correct. The approach is tool supported and de-
signed to be applicable to arbitrary modeling and constrain t
languages. We demonstrated through extensive empirical
studies that our approach is scalable and not aﬀected by the
model and/or design rule size. In future work, we will inves-
tigate how to compute concrete repair actions in a scalable
manner to compute concrete repair actions and their side
eﬀects more comprehensively.
8. ACKNOWLEDGMENTS
This research was funded by the Austrian Science Fund
(FWF): P21321-N15
9. REFERENCES
[1]S-DAGs: Towards Eﬃcient Document Repair
Generation . CCCT 2004, 2004.
[2] Object Management Group - UML.
http://www.uml.org/, 2009.
[3] M. Almeida da Silva, A. Mougenot, X. Blanc, and
R. Bendraou. Towards Automated Inconsistency
Handling in Design Models. In B. Pernici, editor,
Advanced Information Systems Engineering , volume
6051 of Lecture Notes in Computer Science , pages
348–362. Springer Berlin / Heidelberg, 2010.
[4] R. Balzer. Tolerating Inconsistency. In ICSE , pages
158–165, 1991.
[5] X. Blanc, I. Mounier, A. Mougenot, and T. Mens.
Detecting model inconsistency through
operation-based model construction. In ICSE ’08 ,
pages 511–520, New York, NY, USA, 2008. ACM.
[6] K. Czarnecki and K. Pietroszek. Verifying
feature-based model templates against well-formedness
OCL constraints. In S. Jarzabek, D. C. Schmidt, and
T. L. Veldhuizen, editors, GPCE , pages 211–220.
ACM, 2006.
[7] H. K. Dam and M. Winikoﬀ. An agent-oriented
approach to change propagation in software
maintenance. Autonomous Agents and Multi-Agent
Systems , 23(3):384–452, 2011.
[8] A. Egyed. Instant consistency checking for the UML.
In L. J. Osterweil, H. D. Rombach, and M. L. Soﬀa,
editors, ICSE , pages 381–390. ACM, 2006.
[9] A. Egyed. Fixing Inconsistencies in UML Design
Models. In ICSE , pages 292–301, 2007.
[10] A. Egyed. Automatically Detecting and Tracking
Inconsistencies in Software Design Models. IEEE
Trans. Software Eng. , 37(2):188–204, 2011.[11] A. Egyed, E. Letier, and A. Finkelstein. Generating
and Evaluating Choices for Fixing Inconsistencies in
UML Design Models. In ASE, pages 99–108. IEEE,
2008.
[12] B. Elkarablieh and S. Khurshid. Juzi: a tool for
repairing complex data structures. In W. Sch ¨afer,
M. B. Dwyer, and V. Gruhn, editors, ICSE , pages
855–858. ACM, 2008.
[13] I. Groher, A. Reder, and A. Egyed. Incremental
Consistency Checking of Dynamic Constraints. In
D. S. Rosenblum and G. Taentzer, editors, FASE ,
volume 6013 of Lecture Notes in Computer Science ,
pages 203–217. Springer, 2010.
[14] J. Grundy, J. Hosking, and W. B. Mugridge.
Inconsistency Management for Multiple-View Software
Development Environments. IEEE Transactions on
Software Engineering , 24:960–981, 1998.
[15] A. Hegedus, A. Horvath, I. Rath, M. Branco, and
D. Varro. Quick ﬁx generation for DSMLs. In Visual
Languages and Human-Centric Computing
(VL/HCC), 2011 IEEE Symposium on , pages 17–24,
sept. 2011.
[16] M. Z. Malik, J. H. Siddiqui, and S. Khurshid.
Constraint-Based Program Debugging Using Data
Structure Repair. In ICST , pages 190–199. IEEE
Computer Society, 2011.
[17] C. Nentwich, L. Capra, W. Emmerich, and
A. Finkelstein. xlinkit: A Consistency Checking and
Smart Link Generation Service. ACM Trans. Internet
Techn. , 2(2):151–185, 2002.
[18] C. Nentwich, W. Emmerich, and A. Finkelstein.
Consistency Management with Repair Actions. In
ICSE , pages 455–464. IEEE Computer Society, 2003.
[19] A. N ¨ohrer, A. Reder, and A. Egyed. Positive eﬀects of
utilizing relationships between inconsistencies for more
eﬀective inconsistency resolution: NIER track. In
R. N. Taylor, H. Gall, and N. Medvidovic, editors,
ICSE , pages 864–867. ACM, 2011.
[20] J. P. Puissant, T. Mens, and R. V. D. Straeten.
Resolving Model Inconsistencies with Automated
Planning. In Proceedings of the 3rd Workshop on
Living with Inconsistencies in Software Development. ,
pages 8–14. CEUR Workshop Proceedings, 2010.
[21] T. Schattkowsky, J. H. Hausmann, and G. Engels.
Using UML Activities for System-on-Chip Design and
Synthesis. In O. Nierstrasz, J. Whittle, D. Harel, and
G. Reggio, editors, MoDELS , volume 4199 of Lecture
Notes in Computer Science , pages 737–752. Springer,
2006.
[22] J. Scheﬀczyk, P. R ¨odig, U. M. Borghoﬀ, and
L. Schmitz. Managing inconsistent repositories via
prioritized repairs. In E. V. Munson and J.-Y.
Vion-Dury, editors, ACM Symposium on Document
Engineering , pages 137–146. ACM, 2004.
[23] R. V. D. Straeten and M. D’Hondt. Model
refactorings through rule-based inconsistency
resolution. In H. Haddad, editor, SAC, pages
1210–1217. ACM, 2006.
[24] Y. Xiong, Z. Hu, H. Zhao, H. Song, M. Takeichi, and
H. Mei. Supporting automatic model inconsistency
ﬁxing. In H. van Vliet and V. Issarny, editors,
ESEC/SIGSOFT FSE , pages 315–324. ACM, 2009.229