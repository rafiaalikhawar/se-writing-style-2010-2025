Is Spreadsheet Ambiguity Harmful?
 
Detecting and 
Repairing
 
Spreadsheet 
Smell
s
 
due to
 
Ambiguous Computation
 
Wensheng Dou
 
State Key Laboratory of Computer 
Science
 
Institute of Software
 
Chinese Academy of Sciences
 
Beijing, China
 
wsdou@otcaix.iscas.ac.cn
 
Shing
-
Chi
 
Cheung
 
Department of Computer Science and 
Engineering
 
The Hong Kong University of Science 
and Technology
 
Hong Kong, China
 
scc@cse.ust.hk
 
Jun Wei
 
State Key
 
Laboratory of Computer 
Science
 
Institute of Software
 
Chinese Academy of Sciences
 
Beijing, China
 
wj
@otcaix.iscas.ac.cn
 
 
 
ABSTRACT
 
Spreadsheets are widely 
used
 
by end users for numerical comp
u-
t
a
tion
 
in their business
. 
S
preadsheet 
c
ells 
whose computation
 
is
 
subject to the same 
semantics
 
are often clustered in a row or co
l-
umn.
 
When
 
a
 
spreadsheet evolves, 
these 
cell clusters 
can 
degene
r-
ate due to ad hoc modifications 
or
 
undisciplined copy
-
and
-
pastes. 
Such degenerated clusters no longer 
keep
 
cells prescribing the 
same 
computation
al
 
semantics
, and are said to 
exhibit
 
ambiguous 
computation smell
s
. 
Our empirical study finds that 
such 
smells are 
common and likely harmful. 
W
e 
propose
 
AmCheck
, a novel 
tec
h-
nique that 
automatically detect
s
 
and 
repair
s
 
ambiguous comput
a-
tion smell
s
 
by recovering their intended computational semantics.
 
A case study using 
AmCheck
 
suggests that
 
it 
is 
useful 
for
 
disco
v-
er
ing
 
and 
repair
ing
 
real spreadsheet problems
.
 
Categories and Subject Descriptors
 
D.2.7 [Software 
Engineering]: Distribution, Maintenance, and 
Enhancement
 
–
 
r
estructuring, reverse engineering, and reeng
i-
neering
 
General Terms
 
Reliability, Experimentation, Human Factors
 
Keywords
 
Spreadsheet, 
a
mbiguous 
c
omputation
, 
s
mell, 
r
epair
 
1.
 
INTRODUCTION
 
Spreadsheets 
are 
generally
 
developed and maintained by end users 
who 
are not 
familiar with
 
appropriate software development pra
c-
tice.
 
As 
a result
, spreadsheets have been found to be error
-
prone 
[28]
.
 
Spreadsheet e
rrors can
 
induce
 
great 
financial
 
losses 
[26]
. 
Various techniques have been proposed to improve 
the
 
quality
 
of 
spreadsheets
.
 
Some e
xamples include 
testing
 
[12]
[23]
[2]
, 
error or 
smell
 
detection
 
[6]
[19]
[20]
, and 
debugging 
[3]
[30]
.
 
A spreadsheet comprises tables of
 
c
ells arranged in rows and co
l-
umns.
 
We refer to a cell cluster 
as a 
cell array
 
when it 
is subject 
to the same computational semantics. 
For example, the cells 
[D2:D7]
 
in 
Figure
 
1
(b) refer to 
the
 
semantic
s
 
of “Total”
 
and 
un
i-
formly 
follow
 
a
 
formula pattern 
of
 
D
i
 
=
 
B
i
 
+
 
C
i
, where 2
 
≤
 
i
 
≤
 
7.
 
In 
general, 
c
ell arrays can be specified 
manually or with 
tool
 
assi
s-
tance
.
 
In 
this paper, we focus only on those cell arrays subject to 
computational semantics expressed in formula patterns
 
without 
using “if” conditions
.
 
Our empirical study 
report
s that t
here are 
altogether 
16
,
385
 
cell array
s
 
among
 
993
 
(out of 
4
,
037
) 
sprea
d-
sheets
 
in 
the 
EUSES corpus 
[11]
.
 
This indicates that 
cell array
s
 
are
 
common in
 
real
-
life spreadsheets.
 
S
preadsheet 
smells
 
can 
occur due to a distortion of
,
 
or 
an 
amb
i-
gu
i
ty in
,
 
the meaning of data
 
or formulas 
[29]
.
 
Sp
readsheet sof
t-
ware 
like Excel 
provides 
two 
useful features
,
 
copy
-
and
-
paste
 
and 
auto
-
fill
,
 
to reduce the chances of introducing smells during the 
creation of new cells in a cell array. 
Both features
 
can
 
help 
aut
o-
matically 
deduce a formula pattern 
from selec
ted 
sample
 
cells
 
[35]
,
 
and 
apply it to
 
the new
 
cells
 
in a cell array
.
 
Although 
the two features provide convenience
 
in 
editing 
sprea
d-
sheet
s
, their application 
is 
restrictive 
in the sense that 
end 
users 
have little control on the formula 
pattern
 
deduction process
. They 
may not even be aware of deduced formula pattern
s
. After 
editing
, 
t
here is no record in the new cells that they 
have been
 
created 
using the
se
 
two features
, and therefore 
have
 
to be un
iformly mo
d-
ified in future
. 
Little
 
provision 
is offered 
to warn end users from 
modifying these cells arbitrarily. 
In principle
, all cells in a cell 
array should 
prescribe
 
the same 
computational semantics. A cell 
array is said to suffer 
from 
an 
ambiguous 
computation smell
 
when 
there 
is
 
more than one computational semantic among the cells it 
contains.
 
Ad hoc
 
modification
s
 
to these cells 
are
 
one 
major 
cause 
of 
ambiguous computation smell
s. 
For example, 
t
he cell
 
array
 
[D2:D7]
 
in 
Figure
 
1
(a)
 
could be a consequence of 
ad hoc
 
cell 
modifications that result in 
four
 
different formu
la
 
patterns, leading 
to 
an 
ambiguous computation smell
. 
Note that no warning 
can be
 
raised by spr
eadsheet software to alert 
end 
users of 
such
 
a 
smell. 
This s
mell can exist for a long time and even be 
replicated 
to ot
h-
er 
spreadsheet
s 
without being discovered. 
Even though 
this
 
cell 
array
 
currently offers a correct value in each cell, it
 
is 
error
-
prone
 
and
 
susceptible to
 
develop
ing
 
errors
 
upon future 
data 
updates
. For 
example, 
the value in D2 
would
 
be 
incorrect
 
if
 
the value of C2 
is 
later 
updated 
to 1.
 
As 
ambiguous computation smell
s are vulner
a-
ble to 
errors
, their early detection is important
. 
It is particularly 
the case for those spreadsheets subject to liability consequences 
such as 
company
 
reports 
for release to authorized third parties.
 
Spreadsheet 
software
 
like Excel
 
provides 
a mechanism to detect
 
cells with 
inappropriate formulas. However,
 
the detection is 
appl
i-
 
Permission to make digital or hard copies of all or part of this work for 
personal or classroom use is granted without fee provided that copies are 
not made or distributed for profit or commercial advantage and that 
copies bear this notice and the full cit
ation on the first page. To copy 
otherwise, or republish, to post on servers or to redistribute to lists, 
requires prior specific permission and/or a fee.
 
ICSE
’1
4
, 
May
 
3
1
–
June 7
, 201
4
, Hyderabad, 
India
.
 
Copyright 2014 ACM 978
-
1
-
4503
-
2756
-
5/14/05... $15.00.
 Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ICSE’14 , May 31 – June 7, 2014, Hyderabad, India
Copyright 2014 ACM 978-1-4503-2756-5/14/05...$15.00
http://dx.doi.org/10.1145/2568225.2568316
848
cable
cally inconsistent with th
formulas of the two adjacent cells are syntactically consistent.
such
[D2:D7]
in 
cannot be detected by 
either
Like semantic bugs in program
to 
this involves knowledge of intended s
quire
inappropriate cell formulas is another non
In this paper, we focus on 
as well as detection and repair
smell
smell
tional semantics 
appropriate
from
two observations
have
formula patterns
modified arbitrarily,
share an equivalent formula pattern
scribe a sub
observations allow us to identify candidate cell arrays effectively 
using heuristics. We 
tection
ous computation smell
existing work on 
appropriate formula pattern
in a
We evaluated o
lyze
putation smell
formance of our 
smell
with
the 
evaluation 
in the EUSES corpus suffer 
which cover 
putation smell
sheets
smell
computation smells
previously 
can 
the quality of 
We summarize 



cable
 
only 
to 
the 
cally inconsistent with th
formulas of the two adjacent cells are syntactically consistent.
such
, 
Excel 
is not able to
[D2:D7]
 
in 
Figure
in 
Figure
 
1
(a)
 
does not have 
cannot be detected by 
either
.
 
Like semantic bugs in program
to 
identify which cell
this involves knowledge of intended s
quire
s
 
human judgment
inappropriate cell formulas is another non
In this paper, we focus on 
as well as detection and repair
smell
s.
 
In order to detect and 
smell
s, we need to know formula 
tional semantics 
appropriate
 
formula
from
 
ambiguous computation smell
two observations
have
 
the same 
computational 
formula patterns
.
modified arbitrarily,
share an equivalent formula pattern
scribe a sub
-
 
or super
observations allow us to identify candidate cell arrays effectively 
using heuristics. We 
tection
 
to a constraint satisfaction problem. To repair a
ous computation smell
existing work on 
appropriate formula pattern
in a
n
 
array
 
that suffers 
We evaluated o
ur 
lyze
d
 
the EUSES corpus 
putation smell
s
 
can 
formance of our 
smell
s
. 
Second, we 
with
 
real
-
life
 
spreadsheets
the 
Institute
 
of Software, Chinese Academy of Sciences
evaluation 
report
in the EUSES corpus suffer 
which cover 
2
1.6
putation smell
s
 
reveal weakness and 
sheets
.
 
From
 
randomly sampled 
smell
s
, 
434
 
error
computation smells
previously 
created 
can 
help
 
end 
users 
the quality of 
their 
We summarize 
main contributions of this paper 

 
We propose a new
ambiguous computation smell

 
We propose a
ambiguous 
computation smell
that are subject to the same computation
the
se cells’ 
formula patterns, 
and synthesi
zing

 
We
 
evaluate our tool
EUSES corpus and real
e
xperimental results
are common and 
the 
situation where
cally inconsistent with th
ose
 
of its two adjacent cells, and (b) the 
formulas of the two adjacent cells are syntactically consistent.
is not able to
 
ra
ise
Figure
 
1
(a)
.
 
Since each cell in the cell array [D2:D7] 
does not have 
any 
cannot be detected by 
UCheck 
Like semantic bugs in program
ming
identify which cell
s
 
contain inappropriate formula
this involves knowledge of intended s
human judgment
s
 
or specification
inappropriate cell formulas is another non
In this paper, we focus on 
automated identification of cell arrays 
as well as detection and repair
In order to detect and 
s, we need to know formula 
tional semantics 
in
 
cell array
s
. The key 
formula
 
pattern
s
 
for
ambiguous computation smell
two observations
:
 
(1) 
C
onsecutive cells in a row
computational 
semantics
.
 
(
2
) 
Even 
if 
some cells 
modified arbitrarily,
 
a 
majority of 
share an equivalent formula pattern
or super
-
form of 
observations allow us to identify candidate cell arrays effectively 
using heuristics. We 
then 
map 
ambiguous computation smell
to a constraint satisfaction problem. To repair a
ous computation smell
, we propose an algorithm adapted fro
existing work on 
program synthesis by Jha et al. 
appropriate formula pattern
 
that generalizes 
that suffers 
from 
this smell
ur 
technique
 
from two perspectives
the EUSES corpus 
[11]
 
to 
can 
occur
,
 
and 
formance of our 
technique for detecting 
Second, we 
conduct
ed
 
a 
spreadsheets
 
prepared
of Software, Chinese Academy of Sciences
report
s
 
that
:
 
(1) 
27
.3
in the EUSES corpus suffer 
from 
1.6
% of 
identified 
reveal weakness and 
randomly sampled 
error
s
 
are
 
found 
with these smells. 
computation smells
 
are
 
often
 
caused by 
created 
by
 
auto
-
fill
 
and copy
users 
detect and repair such smells, thus 
their 
spreadsheet
s
.
 
main contributions of this paper 
We propose a new
 
and common
ambiguous computation smell
We propose a
 
novel 
technique
computation smell
that are subject to the same computation
formula patterns, 
zing
 
new
 
patterns to repair 
evaluate our tool
 
implem
EUSES corpus and real
-
life 
spreadsheets
xperimental results
 
show
 
that 
are common and 
indeed 
vulnerable to 
situation where
:
 
(a) 
a
 
cell’s formula is syntact
of its two adjacent cells, and (b) the 
formulas of the two adjacent cells are syntactically consistent.
ise
 
any 
warning
 
Since each cell in the cell array [D2:D7] 
any 
unit or dimension erro
UCheck 
[4]
 
and 
d
imension 
ming
 
languages 
[24]
contain inappropriate formula
this involves knowledge of intended s
emantics, which often r
or specification
s
. Automatic repair
inappropriate cell formulas is another non
-
trivial challenge.
automated identification of cell arrays 
as well as detection and repair
ing
 
of 
ambiguous computation 
In order to detect and 
repair
 
ambiguous computation 
s, we need to know formula 
pattern
s
 
that
 
. The key 
challenge
for
 
repair
ing 
cell arrays that suffer
ambiguous computation smell
s
. 
Our technique is based on 
onsecutive cells in a row
semantics
.
 
T
hey 
likely
some cells 
in a cell array have been 
majority of 
cells in 
this
share an equivalent formula pattern
, and
 
o
ther 
form of 
th
is
 
formula pattern. The
observations allow us to identify candidate cell arrays effectively 
ambiguous computation smell
to a constraint satisfaction problem. To repair a
, we propose an algorithm adapted fro
program synthesis by Jha et al. 
that generalizes 
the
this smell
 
as 
many as 
from two perspectives
to 
learn
 
how 
often
and 
measured
 
the precision and pe
technique for detecting 
ambiguous computation 
a 
case 
study 
using
prepared
 
by
 
budget 
finance officers
of Software, Chinese Academy of Sciences
.3
% 
of 
spreadsheets
from 
ambiguous computation smell
identified 
cell arrays.
 
(2) 
reveal weakness and 
have 
cause
d
randomly sampled 
319
 
true 
ambiguous computation 
with these smells. 
caused by 
careless updates to cells 
and copy
-
and
-
paste
detect and repair such smells, thus 
 
main contributions of this paper 
as follows
and common
 
type
 
of 
spreadsheet 
ambiguous computation smell
, which is 
error
technique
, 
AmCheck
,
 
to
computation smell
s
 
by identifying arrays of cells 
that are subject to the same computation
al
 
semantics, 
formula patterns, 
spotting incompatible patterns, 
patterns to repair 
the
 
smells.
implem
entation experimentally
spreadsheets
 
used in practice
that 
ambiguous computation smell
vulnerable to 
error
s
.
cell’s formula is syntact
of its two adjacent cells, and (b) the 
formulas of the two adjacent cells are syntactically consistent.
 
As 
 
for 
the
 
cell array
Since each cell in the cell array [D2:D7] 
unit or dimension erro
r, the smell 
imension 
inference
 
[7]
[24]
[33]
, it is 
hard
contain inappropriate formula
s
,
 
because 
emantics, which often r
. Automatic repair
ing
 
trivial challenge.
 
automated identification of cell arrays 
ambiguous computation 
ambiguous computation 
 
capture
 
comput
challenge
 
is how to infer 
cell arrays that suffer
Our technique is based on 
onsecutive cells in a row
 
or 
column 
often
likely
 
share
 
similar
in a cell array have been 
this
 
array
 
could still 
ther 
cells 
could 
pr
formula pattern. The
se
 
two 
observations allow us to identify candidate cell arrays effectively 
ambiguous computation smell
 
d
to a constraint satisfaction problem. To repair a
n
 
ambig
, we propose an algorithm adapted fro
program synthesis by Jha et al. 
[21]
 
to infer an 
the
 
for
mulas of cells 
many as 
possible
.
 
from two perspectives
. First, we an
often
 
ambiguous co
m-
the precision and pe
ambiguous computation 
using
 
our 
technique
finance officers
 
of Software, Chinese Academy of Sciences
. 
Our 
spreadsheets
 
with formulas
ambiguous computation smell
(2) 
Ambiguous co
m-
d
 
errors
 
in sprea
ambiguous computation 
with these smells. 
(3)
 
A
mbiguous 
careless updates to cells 
paste
. 
O
ur 
technique
detect and repair such smells, thus 
improv
ing
as follows
:
 
spreadsheet 
smell, 
error
-
prone
.
 
to
 
detect
 
and 
repair
by identifying arrays of cells 
semantics, 
inferring
spotting incompatible patterns, 
smells.
 
entation experimentally
 
on the 
used in practice
. 
The 
ambiguous computation smell
.
 
cell’s formula is syntact
i-
of its two adjacent cells, and (b) the 
As 
cell array
 
Since each cell in the cell array [D2:D7] 
r, the smell 
[7]
, 
hard
 
because 
emantics, which often r
e-
 
of 
automated identification of cell arrays 
ambiguous computation 
ambiguous computation 
comput
a-
is how to infer 
cell arrays that suffer
 
Our technique is based on 
often
 
similar
 
in a cell array have been 
could still 
pr
e-
two 
observations allow us to identify candidate cell arrays effectively 
d
e-
ambig
u-
, we propose an algorithm adapted fro
m 
to infer an 
mulas of cells 
. First, we an
a-
m-
the precision and pe
r-
ambiguous computation 
technique
 
 
in 
Our 
with formulas
 
ambiguous computation smell
s
, 
m-
in sprea
d-
ambiguous computation 
mbiguous 
careless updates to cells 
technique
 
ing
 
smell, 
repair
 
by identifying arrays of cells 
inferring
 
spotting incompatible patterns, 
on the 
The 
ambiguous computation smell
s 
The remainder of 
motivating example 
defines 
detection and repairing 
tation. 
cusses related work, and finally 
2.
 
MOTIVATION
In this section, we 
an
 
example 
We 
then
2.1
 
Example
Figure
 
It 
exhibits
Missing formula smell
curs when s
Such smell can be introduced to a 
ride the formula in a cell with
ray1 [F2:F7]
an intended for
like cells F2, F3 and F4, the values of 
computed by formulas.
Inconsistent formula smell
occurs when the cells in a cell array prescribe different formula 
patterns. 
users 
specify
without 
lArray2 
intended formula pattern of 
users may 
and 
thus
at D2
,
 
and a
la pattern. A similar smell
Although CellArray2 and CellArray3 in 
ambiguous computation smell
cells are appropriate. However, the smells can lead to 
and C9 if C2 
problems 
to
-
fill 
to
would also 
a
ny
 
formula pattern 
(a) 
(
b
) 
A spreadsheet 
The remainder of 
th
is
 
motivating example 
and explains the use 
defines 
ambiguous computation
detection and repairing 
tation. 
§
6
 
evaluates 
AmCheck
cusses related work, and finally 
MOTIVATION
In this section, we 
illustrate ambiguous computation smells using 
example 
spreadsheet
then
 
explain how 
to detect and repair 
Example
 
 
1
(a)
 
is
 
a 
spreadsheet
exhibits
 
two kinds of
Missing formula smell
curs when s
ome cells 
in a 
Such smell can be introduced to a 
ride the formula in a cell with
ray1 [F2:F7]
 
is subject
an intended for
mula pattern 
like cells F2, F3 and F4, the values of 
computed by formulas.
Inconsistent formula smell
occurs when the cells in a cell array prescribe different formula 
patterns. 
Such
 
smell can 
specify
 
the formula of a
without 
realizing
 
its computational semantic
lArray2 
[D2:D7]
 
is subject to 
intended formula pattern of 
users may 
understand
 
thus
 
leave 
C2 empty. 
and a
s a result CellArray2 prescribe
la pattern. A similar smell
Although CellArray2 and CellArray3 in 
ambiguous computation smell
cells are appropriate. However, the smells can lead to 
and C9 if C2 
is updated 
problems 
can 
arise
 
when
to
 
these
 
cell arrays
would also 
likely contain
formula pattern 
that 
(a) 
A 
spreadsheet
 
A spreadsheet 
without
Figure
 
paper
 
is organized as follows. 
and explains the use 
ambiguous computation
 
smell
detection and repairing 
technique
. 
§
5
 
presents 
AmCheck
 
with real
cusses related work, and finally 
§
8
 
conclude
MOTIVATION
 
illustrate ambiguous computation smells using 
spreadsheet
 
extracted from the 
to detect and repair 
spreadsheet
 
comput
ing
two kinds of
 
ambiguous computation smell
Missing formula smell
.
 
This 
ambiguous computation smell
in a 
cell array
 
do not 
Such smell can be introduced to a 
cell array
ride the formula in a cell with
 
a 
plain
 
value
is subject
 
to 
the
 
computation of 
mula pattern 
of 
F
i
 
=
 
D
i
like cells F2, F3 and F4, the values of 
computed by formulas.
 
Inconsistent formula smell
. This 
ambiguous computation smell
occurs when the cells in a cell array prescribe different formula 
smell can 
be introduced
the formula of a
 
cell 
in
 
the
its computational semantic
is subject to 
the
 
computation of
intended formula pattern of 
D
i
 
=
 
B
i
 
+ 
 
that there 
is
 
no orange
C2 empty. 
T
hey specify a formula that 
s a result CellArray2 prescribe
la pattern. A similar smell
 
also
 
occurs 
to
Although CellArray2 and CellArray3 in 
ambiguous computation smell
s, the value
cells are appropriate. However, the smells can lead to 
is updated 
later 
with 
a
ny
when
 
end users 
apply 
cell arrays
 
later
. A
n
 
ambiguous computation smell
likely contain
 
a
n
 
error
 
(e.g., F7) 
that 
can 
lead to
 
values in 
spreadsheet
 
with ambiguous computation smells
without
 
ambiguous computation smells
Figure
 
1
. 
A 
m
otivating example
 
is organized as follows. 
and explains the use 
of our 
technique
smell
. 
§
4
 
proposes 
presents 
our tool
with real
-
life spreadsheets. 
conclude
s
 
this paper.
illustrate ambiguous computation smells using 
extracted from the 
EUSES corpus 
to detect and repair 
the
se
 
smells.
 
ing
 
monthly 
harvest of fruits.
ambiguous computation smell
s
ambiguous computation smell
do not 
prescribe a
cell array
 
when 
end 
value
. 
For example, 
computation of 
“
Total Price
i
 
* 
E
i
, where 2
 
≤
like cells F2, F3 and F4, the values of 
cells F5
, 
F6
 
and F7
ambiguous computation smell
occurs when the cells in a cell array prescribe different formula 
be introduced
 
to a cell array 
the
 
cell array
 
inappropriately 
its computational semantic
s
.
 
For exam
computation of
 
“
Total
+ 
C
i
, where 2
 
≤
no orange
 
output
 
in February, 
hey specify a formula that 
s a result CellArray2 prescribe
s
 
more than one form
to
 
CellArray3 [B9:C9].
Although CellArray2 and CellArray3 in 
Figure
 
1
(a)
 
s, the value
s
 
given
 
by their 
cells are appropriate. However, the smells can lead to 
error
ny
 
non
-
ze
ro value. 
apply 
copy
-
and
-
paste and a
ambiguous computation smell
(e.g., F7) 
if 
one is un
values in 
such 
a 
cell 
with ambiguous computation smells
ambiguous computation smells
otivating example
.
 
is organized as follows. 
§
2
 
gives
 
a 
technique
.
 
§
3
 
proposes 
our 
smell
 
our tool
 
impleme
n-
life spreadsheets. 
§
7
 
di
s-
this paper.
 
illustrate ambiguous computation smells using 
EUSES corpus 
[11]
.
 
 
harvest of fruits.
 
s
:
 
ambiguous computation smell
 
o
c-
prescribe a
ny
 
formula. 
end 
users 
ove
r-
For example, 
CellA
r-
Total Price
”
 
with 
≤
 
i
 
≤
 
7
. 
U
n-
and F7
 
are 
not
 
ambiguous computation smell
 
occurs when the cells in a cell array prescribe different formula 
to a cell array 
when 
end 
inappropriately 
For exam
ple, 
Ce
l-
Total
”
 
with an 
≤
 
i
 
≤
 
7
.
 
End 
in February, 
hey specify a formula that 
ignores C2 
more than one form
u-
CellArray3 [B9:C9].
 
 
suffer 
from 
by their 
member 
error
s
 
in D2 
ro value. 
Besides
, 
paste and a
u-
ambiguous computation smell
 
one is un
able to 
find
 
cell 
array.
 
 
with ambiguous computation smells
.
 
 
ambiguous computation smells
.
 
8492.2
Several
and repairing of
We explain
cell (e.g., 
of 
ly 
consider two formula patterns 
rived from these patterns offer the same computation
and 2*
pattern for a cell array 
tern
none of cells in 
e.g.,
cell array
D4 and D5 in CellArray2
array 
may even conflict with the
Our 
two steps. 
underlying 
array
mula pattern
sis 
biguous computation smell
cope with 
and 
struct 
repair
also use its
cell arrays.
3.
In t
explain
smell
3.1
A spreadsheet 
by two
be partitioned into 
whether they contain formulas. 
expression 
address 
be
 
(
 
include basic opera
spreadsheet software
ly, an express
We define a 
dress
references in 
 
Relative 
spreadsheet programming
columns 
The bracket for 
2.2
 
AmCheck
Several
 
technical
and repairing of
 
We explain
 
the
m
cell (e.g., 
F5
) belong to a cell array? If 
of 
such
 
a
 
cell array? 
ly 
prescribe 
semantically 
consider two formula patterns 
rived from these patterns offer the same computation
and 2*
x
. 
Third,
 
pattern for a cell array 
tern
? This is a challenging question because there are chances that 
none of cells in 
such 
e.g.,
 
cells B9 and C9 in CellArray3. 
cell array
 
may
 
prescribe
D4 and D5 in CellArray2
array 
may 
prescribe 
may even conflict with the
Our 
AmCheck
 
infer
two steps. 
First, 
it uses 
underlying 
con
straints 
array
. 
Second
, it
 
mula pattern
s
. 
AmCheck
sis 
[21]
 
to
 
construct
biguous computation smell
cope with 
noises 
and 
potential
 
errors
struct 
a candidate formula pattern
repair
ing
 
the 
ambiguous computation smell
also use its
 
inferred
cell arrays.
 
3.
 
AMBIGUOUS COMPUTATION SMELL
In t
his section
,
 
w
explain
 
key concepts like 
smell
 
to be used in subsequent discussions
3.1
 
Spreadsheet Program
A spreadsheet 
can be modeled as
by two
-
dimensional cell 
be partitioned into 
whether they contain formulas. 
expression 
of
 
th
at
address 
references
be
 
the set of plain values.
 
∈
 
, 
a
n
 
address
 
) applied to one or more 
include basic opera
spreadsheet software
ly, an express
ion
We define a 
function
dress
 
references
 
references in 
 
(
   
 
(
   
)
=
	
 
∅
{
   
 
(
   
Relative 
R1C1
 
is a widely 
spreadsheet programming
columns 
on the 
The bracket for 
the 
AmCheck
 
Overview
technical
 
challenges
 
need to be addressed in the detection 
and repairing of
 
ambiguous computation smell
m
 
using the example in 
) belong to a cell array? If 
cell array? 
Second,
 
d
o cells in a cell array 
semantically 
different formula patterns? Note that we 
consider two formula patterns 
to be
rived from these patterns offer the same computation
 
h
ow 
may 
one
 
pattern for a cell array 
that
 
prescribe
? This is a challenging question because there are chances that 
such 
a cell array 
cells B9 and C9 in CellArray3. 
prescribe
 
conflicting 
D4 and D5 in CellArray2
. 
Fourth,
prescribe 
no
 
formula. The value
may even conflict with the
ir
 
appropriate formula
infer
s
 
formula patterns by means of constraints in 
it uses 
values and 
straints 
of formula patterns
 
use
s
 
the inferred 
AmCheck
 
uses
 
component
construct
 
candidate 
formula
biguous computation smell
s
. 
To 
noises 
induced
 
by conflicting formulas 
errors
 
(e.g., F7)
. 
For 
a candidate formula pattern
ambiguous computation smell
inferred
 
formula pattern
AMBIGUOUS COMPUTATION SMELL
w
e introduce 
spreadsheet programming model, and 
key concepts like 
cell array and 
to be used in subsequent discussions
Spreadsheet Program
can be modeled as
dimensional cell 
addresses
be partitioned into 
data cells
 
and 
whether they contain formulas. 
at
 
cell is 
its formula. Let
references
, 
EXP
 
be
 
the set of 
the set of plain values.
 
A
n
 
expression
address
 
reference
 
(
 
∈
) applied to one or more 
expression
include basic opera
tor
s
 
(e.g., 
+,
 

spreadsheet software
 
(e.g.,
 
SUM
, 
ion
 
exp
 
is:
 
   
=
 
	
|
	
 
	
|
	
 
function
 
 
∶
   
	
→
 
used 
by
 
a
n
 
expression
(
   
)
 
are 
referred to as the 
 
∅
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
{
   
}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
(
   
 
)
∪
…
∪
 
(
   
is a widely 
used notation for referencing cells 
spreadsheet programming
 
[34]
. A cell at 
on the 
right 
of
 
the 
current cell is notated as R[
the 
row (or column) can be omitted when 
Overview
 
need to be addressed in the detection 
ambiguous computation smell
s
using the example in 
Figure
 
1
) belong to a cell array? If 
yes
, what 
o cells in a cell array 
different formula patterns? Note that we 
to be
 
the same if the formulas d
rived from these patterns offer the same computation
 
construct
 
an appropriate formula 
prescribe
s
 
more than one formula
? This is a challenging question because there are chances that 
a cell array 
is
 
using an appropriate formula
cells B9 and C9 in CellArray3. 
Even worse, c
conflicting 
formulas 
patterns, e.g., cells 
Fourth,
 
s
ome cells (e.g., F5) in a cell 
formula. The value
s
 
of these cells (e.g., F7) 
appropriate formula
formula patterns by means of constraints in 
values and 
formulas in 
a
 
of formula patterns
 
prescribed by this cell 
the inferred 
constraints
 
to 
component
-
based 
formula
 
pattern
s
 
To 
achieve this
,
 
AmCheck
by conflicting formulas 
For 
example, 
AmCheck
a candidate formula pattern
 
(
B
i
 
+ 
C
i
, where 2
ambiguous computation smell
 
in
 
CellArray2
formula pattern
s
 
to detect 
errors
AMBIGUOUS COMPUTATION SMELL
spreadsheet programming model, and 
cell array and 
ambiguous 
to be used in subsequent discussions
.
 
Spreadsheet Program
ming Model
can be modeled as
 
a set of expressions 
addresses
 
[5]
. 
Cells in a spread
and 
formula cells
whether they contain formulas. 
If 
a
 
cell 
contains 
its formula. Let
 
A
 
be
 
the set of 
the set of 
possible 
expression
expression
 
exp
 
is either a plain 
∈
 
)
 
to 
another
 
expression
s.
 
Functions in spreadsheets 

, *, /
)
 
and 
built
-
, 
AVERAGE
 
and
 
(
   
 
,
…
,
   
 
)
→
	
2
 
, which 
gives
expression
 
exp
. The cell
referred to as the 
input cells
	
	
	
	
	
	
	
	
	
	
	
	
	
   
∈
 
;
	
	
	
	
	
	
	
	
	
	
	
	
	
   
∈
 
;
(
   
 
)
	
	
	
   
=
 
used notation for referencing cells 
. A cell at 
n
 
rows below and 
current cell is notated as R[
row (or column) can be omitted when 
need to be addressed in the detection 
ambiguous computation smell
s
 
in spreadsheets
1
(a). 
First,
 
d
oes a 
, what 
is 
the 
boundary
o cells in a cell array 
inappropriat
different formula patterns? Note that we 
the same if the formulas d
rived from these patterns offer the same computation
, e.g.,
 
x
 
+
an appropriate formula 
more than one formula
 
pa
? This is a challenging question because there are chances that 
using an appropriate formula
Even worse, c
ells 
in 
such 
patterns, e.g., cells 
ome cells (e.g., F5) in a cell 
of these cells (e.g., F7) 
appropriate formula
 
pattern
s
.
 
formula patterns by means of constraints in 
a
 
cell array
 
to infer 
prescribed by this cell 
to 
derive
 
target
 
fo
based 
program synth
 
for
 
repair
ing
 
a
m-
AmCheck
 
needs to 
by conflicting formulas 
(e.g., D4 and D5) 
AmCheck
 
can 
co
, where 2
 
≤
 
i
 
≤
 
7
)
 
for
CellArray2
.
 
It
 
can 
errors
 
(e.g., F7) in 
AMBIGUOUS COMPUTATION SMELL
spreadsheet programming model, and 
ambiguous 
computation 
ming Model
 
a set of expressions 
referenced
Cells in a spread
sheet can 
formula cells
,
 
depending
 
on 
contains 
a formula, the 
the set of 
possible 
expression
s
, and 
is either a plain 
value
 
cell, or a function 
Functions in spreadsheets 
-
in
 
functions 
from
and
 
MAX
)
.
 
Forma
)
.
 
gives
 
the 
set of 
a
. The cell
s
 
indexed
 
by 
input cells
 
of
 
exp
:
 
;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
;
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
 
(
   
 
,
…
,
   
 
)
used notation for referencing cells 
rows below and 
current cell is notated as R[
n
]
C
[
m
row (or column) can be omitted when 
a
 
refe
need to be addressed in the detection 
in spreadsheets
. 
oes a 
boundary
 
inappropriat
e-
different formula patterns? Note that we 
the same if the formulas d
e-
+
 
x
 
an appropriate formula 
pa
t-
? This is a challenging question because there are chances that 
using an appropriate formula
, 
such 
a 
patterns, e.g., cells 
ome cells (e.g., F5) in a cell 
of these cells (e.g., F7) 
formula patterns by means of constraints in 
to infer 
prescribed by this cell 
fo
r-
program synth
e-
m-
needs to 
(e.g., D4 and D5) 
co
n-
for
 
can 
(e.g., F7) in 
AMBIGUOUS COMPUTATION SMELL
S
 
spreadsheet programming model, and 
computation 
referenced
 
sheet can 
on 
a formula, the 
possible 
, and 
V
 
value
 
cell, or a function 
Functions in spreadsheets 
from
 
Forma
l-
a
d-
by 
)
.
	
 
used notation for referencing cells 
in 
rows below and 
m
 
m
]. 
refe
r-
enced cell is on the same row (or 
cell 
references 
the cell containing 
f
ormulas 
R1C1 expression
in 
Figure
using
 
this 
values. The first value is given by a cell at the same row but two 
columns left. The second value is given by a cell at the same
but one column left. 
expressions 
1
(a).
 
A referenced cell with 
constant.
means relative R1C1 notation
3.2
 
Cell 
In a spreadsheet, c
usually
Definition
CellArray1, CellArray2 and CellArray3 
column
computational semantic
Since cells in a cell array often use formulas to express such co
putational semantics,
mantics its 
cells in a
following condition holds
Intuitively, a
contain
that 
any 
references
condition states that 
to the same value 
example
2
]C
 
+ 2
different
solver
 
expressions equivalent
 
       
from 
an 
There are 
Row
-
based cell array
Each
 
of these cells 
the same column as input
a row
-
based cell array
Column
umn. 
Each
cells in the same row as inputs. For example, 
1
(
b
) is a 
Figure 
enced cell is on the same row (or 
references 
in a formula to be
the cell containing 
this
ormulas 
prescribing
 
the same pattern have equivalent relative 
R1C1 expression
s
. 
For exam
Figure
 
1
(a) 
can be
 
this 
relative R1C1 notation. 
values. The first value is given by a cell at the same row but two 
columns left. The second value is given by a cell at the same
but one column left. 
Figure 
expressions 
for
 
all 
formulas contained 
A referenced cell with 
constant.
 
In subsequent discussions
means relative R1C1 notation
Cell 
A
rray
 
and Smell
In a spreadsheet, c
ells 
usually
 
grouped together in a row or column.
Definition
 
1: 
A
 
cell array
CellArray1, CellArray2 and CellArray3 
column
 
prescribing 
one
computational semantic
Since cells in a cell array often use formulas to express such co
putational semantics,
 
we name a cell array
mantics its 
formula pattern
cells in a
 
cell array.
 
We say that a
following condition holds
∀
 
 
,
 
 
∈
         
⋀
Intuitively, a
 
cell array 
contain
 
equivalent
 
R1C1 
any 
two 
cell
 
expression
references
 
(i.e., cell addresses in R1C1 
condition states that 
any 
to the same value 
given the same 
example
, two expressions 
+ 2
 
*
 
R[
-
1]C
”
 
are equivalent
different
.
 
Our 
AmCheck checks well
Choco
 
[22]
.
 
Since a
expressions equivalent
,
       
.
 
If a
 
cell array
an 
ambiguous computation smell
There are 
two
 
common 
based cell array
.
of these cells 
often 
the same column as input
based cell array
.
 
Column
-
based cell array
Each
 
of these cells
cells in the same row as inputs. For example, 
) is a 
column
-
based cell array.
Figure 
2
.
 
M
otivating 
enced cell is on the same row (or 
column). Th
in a formula to be
 
expressed 
this
 
formula.
 
An 
interesting
the same pattern have equivalent relative 
For exam
ple, the formula B5
 
re
written as RC[
relative R1C1 notation. 
It 
means
values. The first value is given by a cell at the same row but two 
columns left. The second value is given by a cell at the same
Figure 
2
 
gives 
corresponding 
formulas contained 
A referenced cell with 
absolute
In subsequent discussions
, 
means relative R1C1 notation
 
for ease of presentation
and Smell
 
ells 
with
 
the same 
computational 
grouped together in a row or column.
cell array
 
is a consecutive
CellArray1, CellArray2 and CellArray3 
one
 
business concept 
computational semantic
s
.
 
Since cells in a cell array often use formulas to express such co
we name a cell array
formula pattern
 
(
 
       
).
 
We say that a
 
cell array is 
following condition holds
 
(in R1C1 notation)
         
,
 
(
 
 
.
   
⋀
	
 
 
.
   
=
	
 
 
.
cell array 
is well
-
formed when
R1C1 
expression
s
.
expression
s
 
in this 
cell 
(i.e., cell addresses in R1C1 
any 
two 
cell 
expressions
given the same 
bindings of 
, two expressions 
“
2
 
*
 
(
R[
-
2
]
C 
are equivalent
 
although they are syntactically 
AmCheck checks well
-
formedness using 
Since a
 
well
-
formed cell array has all its cell 
,
 
we can take 
any of 
cell array
 
is not well
-
formed
ambiguous computation smell
 
common 
types of
 
cell arrays in spreadsheets
.
 
It 
comprises
 
consecutive 
often 
ha
s
 
a formula 
the same column as input
s
. For example, 
 
based cell array
.
 
I
t
 
comprises
of these cells
 
often 
ha
s
 
a formula 
cells in the same row as inputs. For example, 
based cell array.
 
otivating 
example
 
with relative R1C1 notation
 
column). Th
is
 
notation allows
expressed 
as 
indexes
interesting
 
observation is that 
the same pattern have equivalent relative 
ple, the formula B5
 
+
 
C5 
written as RC[
-
2
]
 
+ 
RC[
-
1]
 
means
 
a summation of two 
values. The first value is given by a cell at the same row but two 
columns left. The second value is given by a cell at the same
corresponding 
relative R1C1 
formulas contained 
in
 
the spreadsheet in 
 
R1C1
 
can be
 
treated
, 
“
R1C1 notation
for ease of presentation
.
 
 
computational 
semantics
grouped together in a row or column.
 
is a consecutive
 
range 
of cells 
CellArray1, CellArray2 and CellArray3 
in 
Figure
 
1
(a)) in 
business concept 
and
 
subject to
Since cells in a cell array often use formulas to express such co
we name a cell array
’
s computational s
 
Let
 
CellArray
 
be
cell array is 
well
-
formed
(in R1C1 notation)
:
 
(
   
)
=
	
 
(
 
 
.
   
.
   
.
 
formed when
 
all
 
its 
member cell
.
 
The first
 
condition states 
cell 
array
 
have the same set of 
(i.e., cell addresses in R1C1 
notation
)
.
 
The 
expressions
 
should be
bindings of 
their 
input cells
C 
+
 
R[
-
1
]
C
)
”
 
and 
although they are syntactically 
formedness using 
formed cell array has all its cell 
any of 
them
 
as th
e
formed
, 
we say that 
 
or it is 
smelly
.
 
cell arrays in spreadsheets
consecutive 
cells
a formula 
referencing
 
other cells in 
. For example, 
[B9:C9]
 
in 
Figure
comprises
 
consecutive cells in a co
a formula 
referencing
cells in the same row as inputs. For example, 
[D2:D7]
with relative R1C1 notation
notation allows
 
indexes
 
relative 
to 
observation is that 
the same pattern have equivalent relative 
C5 
in 
cell 
D5
 
 
in 
Figure 
2
 
a summation of two 
values. The first value is given by a cell at the same row but two 
columns left. The second value is given by a cell at the same
 
row 
relative R1C1 
the spreadsheet in 
Figure
 
treated
 
as 
a 
R1C1 notation
”
 
always 
 
semantics
 
are
 
of cells 
(e.g., 
(a)) in 
a row
 
or 
subject to
 
certain
 
Since cells in a cell array often use formulas to express such co
m-
s computational s
e-
be
 
the set of 
formed
 
if
 
the 
   
)
 
member cell
s
 
condition states 
have the same set of 
The 
second 
should be
 
evaluated 
input cells
.
 
For 
and 
“
2
 
*
 
R[
-
although they are syntactically 
formedness using 
constraint 
formed cell array has all its cell 
e
 
cell 
array
’
s 
we say that 
it
 
suffers
 
 
cell arrays in spreadsheets
:
 
cells
 
in a row
.
 
other cells in 
Figure
 
1
(
b
) is 
consecutive cells in a co
l-
referencing
 
other 
[D2:D7]
 
in 
Figure
 
with relative R1C1 notation
.
 
850S
mells 
can
 
occur 
in
 
a cell array when 
end 
users make ad hoc 
mo
d-
ifications
 
to 
its 
cells. 
Such
 
modifications
 
can
 
be made by inexp
e-
rienced 
end 
users to accommodate 
last
-
minute modifications u
n-
der tight deadlines.
 
We find two common types of 
ambiguous 
computation smell
: 
missing formula
 
smell
 
and 
incon
sistent form
u-
la
 
smell
, as explained earlier
.
 
A
 
missing formula smell
 
occurs 
in
 
a 
no
t 
well
-
formed 
cell array 
when 
it contains a 
data cell
. 
An
 
inco
n-
sistent formula smell
 
occurs 
in
 
a 
no
t 
well
-
formed 
cell array 
when 
it has two 
formula 
cells with 
semantically 
different
 
R1C1 expre
s-
sions. 
A cell array of 
more than two
 
cells can suffer 
from 
missing 
formula and inconsistent formula smells at the same time.
 
Definition 
2
: 
A
 
conformance error
 
occurs when the value of a
 
cell
 
in a cell array
 
does not conform to that 
computed
 
by
 
th
is cell 
array
’
s
 
 
       
:
 
∃
 
∈
         
,
 
.
     
	
≠
 
       
(
 
.
      
)
.
 
A conformance error 
may be caused by 
improper modifications to 
a cell array
 
such that it 
suffers 
from 
ambiguous computation 
smell
s. 
C
onformance errors
 
reflect
 
true 
data 
discrepanc
ies in 
spreadsheets
, such as F7 in 
Figure
 
1
(a).
 
4.
 
DETECTING AND 
REPAIR
ING 
AMBIGUOUS COMPUTATION SMELL
S
 
Given a spreadsheet, 
our 
AmCheck analyzes 
it
 
and reports 
all 
detected 
ambiguous computation smells with repair suggestions.
 
AmCheck 
heuristically identif
ies
 
cell arrays
 
(
§
4.1
)
,
 
and detects 
a
mbiguous 
c
omputation 
s
mell
s
 
via
 
constraint 
solving
 
(
§
4.2
)
. 
T
o 
repair ambiguous computation smells, Am
Check infer
s
 
an
 
 
       
 
in two steps
. 
First, 
AmCheck
 
uses 
values and 
formulas in 
a
 
cell array
 
to 
derive
 
con
straints associated with 
its
 
underlying 
formula pattern (
§
4.3
). 
Second, 
AmCheck
 
infers
 
an 
 
       
 
based 
on
 
these constraints
.
 
In order to 
expedite
 
the 
infer
ence
 
process, 
AmCheck 
combin
e
s
 
heuristics 
(
§
4.4
) 
and program synthesis
 
tec
h-
niques
 
(
§
4.5
)
. After 
the inference
, AmCheck reports 
a 
confor
m-
ance error 
if 
any 
cell in 
a
 
cell array 
has
 
a value not conforming to 
the one computed 
by
 
the inferred 
 
       
.
 
4.1
 
Extracting 
Cell Array
s
 
T
he first challenge of 
ambiguous computation 
smell detection is 
to 
identify
 
cell arrays from 
a
 
given spreadsheet, which has 
no 
record about cells
 
previously
 
prepared 
by
 
copy
-
and
-
paste 
and
 
auto
-
fill. 
We observe that 
a spreadsheet snippet 
usually provides 
useful hint
s
 
about
 
boundaries 
of cell arrays
. 
Besides
, the 
formula 
of
 
a
 
cell in a cell array 
often
 
reference
s
 
other 
cells in t
he same row
 
or 
column
 
as
 
this 
cell
.
 
These 
two observations
 
facilitate
 
our cell 
array identification and extraction.
 
The
 
first step is to identify potential snippets
. 
R
elated data 
and
 
formulas
 
i
n a spreadsheet
 
are often
 
clustered
 
together in 
a recta
n-
gle 
circum
scribed
 
by
 
empty cells
 
or labels 
[16]
.
 
W
e 
refer to such 
rectangles of cells
 
as 
snippets
. 
Examples of
 
spreadsheet snippets
 
in 
Figure
 
1
(a)
 
include two rectang
l
es 
comprising cells
 
[
B2
:
F
7
] 
and [
B
9:D9
]
, respectively
.
 
To identify snippets, w
e adopt 
a
 
cell 
classification strategy
, sim
i-
lar
 
to what
 
Abraham and Erwig 
[4]
 
suggested. We define 
a
 
fence
 
as 
a row or column of cells that
 
comprise
s
 
only 
empty
 
cells or 
labels 
in a spreadsheet
. We 
use fence
s
 
to identify boundar
ies
 
for 
each
 
spreadsheet snippet. 
O
ther 
cells 
inside
 
the 
identified 
bound
a-
r
ies
 
are
 
considered
 
as cells 
of
 
this
 
spreadsheet snippet
.
 
We describe our spreadsheet snippet identification
 
algorithm
 
briefly 
as follows. 
Initial
ly, 
each
 
spreadsheet 
is 
considered
 
as 
one
 
snippet
.
 
W
e 
then 
identify fence
s
 
in th
is
 
snippet
, and 
divide this 
snippet into more ones 
by 
the identified 
fences.
 
For each new
ly
 
identified snippet, we 
repeat this refinement 
until 
no further
 
sni
p-
pet 
can be identified
.
 
The
 
second step is to extract cell arrays from identified 
sprea
d-
sheet 
snippets. As 
mentioned
, 
the 
formula 
of
 
a cell in a cell array 
often
 
reference
s other cells in the same row or column as this cell
.
 
Our
 
cell array extraction algorithm 
works as follows.
 
For 
each 
snippet, i
t examines 
consecutive
 
cells 
clustered in a row
 
or 
co
l-
umn, and considers a cluster as a cell array if
:
 
(1) 
the cluster is not 
a subset of another cell array
,
 
and 
(2) 
the formula of each cell in 
the cluster
 
consistently 
reference
s
 
input cells from 
the same
 
co
l-
umn
 
or 
row
 
as this cell
. 
The algorithm may encounter the follo
w-
ing four 
scenarios
 
in
 
its
 
extraction process
:
 

 
Row
-
based cell array:
 
For
 
a 
cluster
 
of 
consecutive cell
s
 
in a 
row
, s
ome cells contain formulas, and for 
each cell
 
with 
a 
formula, 
its
 
formula
 
only 
reference
s
 
input 
cells 
from
 
the same 
column 
as this cell
. We 
then 
consider this 
cluster
 
as a row
-
based cell array. 
One
 
example is [B9:C9] in 
Figure
 
1
(a).
 

 
Column
-
based cell array:
 
For a 
cluster
 
of consecutive cell
s
 
in a column
, 
some cells contain formulas, and for 
each cell 
with 
a 
formula
, 
its
 
formula 
only 
reference
s
 
input 
cells 
from
 
the 
same row
 
as this cell
.
 
W
e 
then 
consider this 
cluster
 
as a 
column
-
based cell array. 
One 
example is [D2:D7] in 
Figure
 
1
(a).
 

 
Pure value:
 
It is 
hard
 
to judge 
whether
 
a row
 
or 
column co
n-
taining 
only data cells
 
prescribes
 
one
 
business concept 
and is 
subject to certain computational semantic
s
. 
We do not consi
d-
er such
 
row
s
 
or 
column
s
 
as 
cell array
s
.
 

 
Other cases:
 
If 
a
 
row
 
or 
column does not 
belong to
 
any of 
the 
above 
cases
, we 
a
lso 
do not consider it as a cell array.
 
4.2
 
Detecting 
Ambiguous 
Computation Smell
s
 
By
 
D
efinition
 
1
, a cell array 
is well
-
formed if it 
satisfies
: (1) 
it 
contains only formula cells
, 
(2) 
all 
its
 
formula
s
 
use the same i
n-
puts
 
(in R1C1 notation
),
 
and
 
(3) 
all 
its
 
formulas give the same 
outputs 
given the same input values
. 
Thus,
 
we 
can 
map 
ambig
u-
ous computation smell
 
detection to a constraint satisfaction pro
b-
lem, and rewrite th
e
 
above 
three 
condition
s
 
as follows
:
 
∀
 
 
,
 
 
∈
         
,
 
(
 
 
.
   
)
=
	
 
(
 
 
.
   
)
 
∧
	
∄
	
     
,
 
 
.
   
(
     
)
≠
 
 
.
   
(
     
)
.
 
Here, w
e use 
input
 
to denote 
any
 
possible
 
input 
values
 
to cells 
c
1
’
s
 
and 
c
2
’
s
 
expressions
.
 
If a cell array does not satisfy 
any of 
the 
above 
condition
s
, it suffers
 
from 
ambiguous 
computation smell
s
.
 
4.3
 
Extracting 
Formula Cell Constraint
s
 
Given a smelly cell array, we 
expect
 
AmCheck to detect 
any
 
e
x-
istence of conformance error
s
 
as defined in Definition 2. To do 
that, AmCheck needs to recover a
n
 
R1C1 expression 
from exis
t-
ing cells 
to represent 
this cell array
’
s 
 
       
.
 
Our construction technique 
is
 
inspired by c
omponent
-
based pr
o-
gram synthesis
, which
 
synthesizes a loop
less
 
program from 
co
m-
ponents
, 
input
-
output pairs
 
and 
specifications 
used by
 
th
is
 
pr
o-
gram
 
[14]
[21]
.
 
The construction is based on three assumptions
:
 
(
1
) 
C
omponents 
in 
formulas 
used by 
a
 
cell array 
are 
often comp
o-
nents used by 
this cell array
’
s 
 
       
;
 
(
2
) 
Most 
values
 
should be 
correct for 
th
is
 
cell array, 
and
 
they can 
serve as 
input
-
output pairs
; 
(3) 
E
xisting 
formulas 
in
 
the cell array are 
good hints 
of
 
 
       
.
 
Under 
these assumption
s
, AmCheck recovers a
n
 
R1C1 expression 
by extracting 
its
 
constraints from cells of a smelly cell array, and 
combining them appropriately.
 
The extraction 
process
 
consists of 
four parts
, i.e., 
extract
ing
 
input 
variables
, components, input
-
output pairs and 
functions 
from a smelly 
cell array
, as follows
:
 8511)
 
All cells 
referenced
 
by formulas
 
in 
a 
cell array
 
are 
considered
 
as 
input variables for 
th
is cell array
’
s
 
 
       
. For example, 
input variables for CellArray1 are 
RC[
-
2
] and RC[
-
1
], input 
variables for CellArray2 are RC[
-
2
] and RC[
-
1
], and input 
variables for CellArray3 are R[
-
7]C, R[
-
6]C, 
…
, 
R[
-
2]C
 
(in 
Figure
 
1
 
(a)
)
. 
The process may extract irrelevant input vari
a-
bles, which can be removed at a 
later
 
stage
. 
Let
 
I
V
 
be
 
the set 
of all input variables 
of
 
a cell array. After extract
ing
 
n
 
input 
variables f
or 
 
       
, we can model 
 
       
 
as
 
a function
 
 
(
 
 
,
 
 
,
…
 
 
)
.
 
Formally, 
I
V
 
is defined as follows:
 
 
 
=
 
(
 
 
.
   
)
∪
 
(
 
 
.
   
)
…
∪
 
(
 
 
.
   
)
,
 
where
	
 
 
,
 
 
,
…
 
 
∈
         
.
 
2)
 
All operators used by formulas
 
in the cell array
 
are
 
considered
 
as
 
components. For example, components 
from
 
CellArray1 
include
 
“*”, components 
from
 
CellArray2 
include
 
“+” and “
–
”, and components 
f
rom
 
CellArray3 
include
 
“+” and SUM. 
S
ome 
components 
may 
be 
irrelevant, 
but 
we can 
skip
 
them 
at 
a 
later
 
stage
. 
If
 
A
m
Check fails to find any operator 
from a cell 
array
, it
 
would
 
add basic operators 
(e.g., 
+, 
–
, 
*, /
) as comp
o-
nents.
 
3)
 
All
 
data in 
the
 
cell array are 
considered
 
as input
-
output pairs. 
For example, in CellArray2, <(1, 0), 1>, <
(2, 0), 2>, <(3, 0), 
3>, <(4, 1), 5>, <(0, 5), 5> and <(0, 6), 6> 
are considered 
as 
input
-
output 
pairs
.
 
4)
 
Existing formulas
 
in 
the
 
cell array
 
can be
 
modeled
 
as 
fun
c-
tion
s. For example, 
one 
can extract 
from
 
CellArray2
 
four 
function
s, 
namely, 
f
(
x
1
, 0) = 
x
1
, 
f
(
x
1
, 
x
2
) = 
x
1
 
+
 
x
2
, 
f
(
x
1
, 
x
2
) = 
x
1
 
–
 
x
2
 
and 
f
(0, 
x
2
) = 
x
2
.
 
These functions are treated as specific
a-
tion
s
 
in component
-
based program synthesis 
[14]
[21]
.
 
All 
these 
extracted input variables, components, input
-
output pairs 
and 
functions
 
are constraints 
used 
for
 
recover
ing
 
 
       
.
 
4.4
 
Recovering 
 
       
 
We observe 
that
 
a cell array
’
s 
 
       
 
can
 
exist in 
function
s
 
e
x-
tracted from 
the cell array’s 
formula
 
cells
. 
For example, 
function 
f
(
x
1
, 
x
2
) = 
x
1
 
*
 
x
2
 
extracted from formula cells
 
i
n 
CellArray1
 
in 
Figure
 
1
(a)
 
is
 
a 
good 
candidate
 
for
 
recover
ing
 
CellArray1’s
 
 
       
. 
Th
is
 
observation 
enables us to recover a cell array’s 
 
       
 
based on a 
candidate 
set of 
functions
 
obtained from its 
formula cells. This
 
can
 
significantly
 
reduce the 
cost of 
formula 
pattern 
inference
 
since program synthesis
 
[21]
 
is 
expensive
. 
W
e 
aim
 
to
 
select
 
a
 
function
 
that
 
contains all input 
variables
 
and 
covers
 
all cells in 
a
 
cell array
 
as 
its 
 
       
.
 
W
e say 
that 
a function 
c
o-
vers
 
a 
data 
cell
 
when 
the cell’s value can be computed by the 
function. 
For example, the value 
of
 
F
5 in CellArray
1
 
in 
Figure
 
1
(a)
 
can be computed by 
f
(
x
1
, 
x
2
)
 
=
 
x
1
 
*
 
x
2
.
 
We say 
that 
a function 
c
o-
vers
 
a formula cell if the function 
is 
compatible
 
with the one 
e
x-
tracted 
from 
the cell’s formula 
in the sense that
 
both of them can 
produce
 
the same output
s
 
given the same 
inputs.
 
For example, 
function
 
f
(
x
1
, 
x
2
)
 
=
 
x
1
 
+
 
x
2
 
is compatible with 
function
 
f
(
x
1
, 0)
 
=
 
x
1
 
extract
ed
 
from D2
 
in 
Figure
 
1
(a)
. 
Note that the second parameter 
bind
s
 
to zero for the two functions to have the same inputs. 
Ho
w-
ever, 
f
(
x
1
, 
x
2
)
 
=
 
x
1
 
+
 
x
2
 
is incompatible with 
another 
function
 
f
(
x
1
, 
x
2
) = 
x
1
 
–
 
x
2
 
extracted from D4 in CellArray2 
in 
Figure
 
1
(a)
 
b
e-
cause
 
the
ir outputs are different
 
when 
x
1
 
is 
0
 
and 
x
2
 
is 
1
.
 
Algorithm 
1
 
give
s
 
our 
 
       
 
recovery algorithm
. 
The algorithm 
return
s
 
NULL
 
if it fails to 
recover
 
a
ny
 
 
       
 
from 
functions
 
extracted from a given
 
cell array
, which contain
s
 
at least one fo
r-
mula cell
. 
If
 
only one 
function
 
can be extracted from 
a
 
given
 
cell 
array
, 
it 
is treated as 
the
 
cell array
’
s
 
 
       
 
(Lines 1

3). 
Othe
r-
wise
, 
a
 
function 
that
 
can cover (
by the 
Coverage 
method
) all va
l-
ues and formulas in 
the given
 
ce
ll array (Lines 4

10)
 
is treated as 
the 
 
       
. 
The Coverage 
method
 
(Lines 1
3

2
7
) computes the 
ratio of 
the number of 
cells a 
function
 
can cover
 
over
 
the total 
number of
 
cells in the cell array
.
 
Lines 17
-
19 (and 
Lines 
21
-
23) 
check whether a formula (and data) 
cell
 
is covered 
by a 
function
.
 
4.5
 
Synthesizing 
 
       
 
The 
 
       
 
recovery algorithm 
returns 
NULL
 
when it fails to 
identify an appropriate 
 
       
 
of a smelly cell array from its 
extracted functions. 
When
 
this happens
, AmCheck 
synthesizes
 
the 
 
 
       
 
using
 
c
omponent
-
based program synthesis
 
[14]
[21]
.
 
Let us review the basic 
mechanism
 
of component
-
based program 
synthesis 
to construct a program before explaining the 
 
       
 
synthesis
 
algorithm
. Program synthes
is first 
derives
 
constraints 
(
constraints
ps
) for 
a
 
program 
to be synthesized 
based on 
a set of 
components and input
-
output pairs
 
(generated by specifications 
[14]
 
or provided by 
users
 
[21]
)
. It then solves 
constraints
ps
 
to 
synthesize
 
t
he
 
program. If the input
-
output pairs provided are not 
sufficiently restrictive, multiple 
candidate 
programs can be 
sy
n-
thesized
 
(all satisfying 
constraints
ps
). More input
-
output pairs can 
be used to provide additional constraints 
to 
strengthen 
co
n-
straints
p
s
 
until a unique program is
 
synthesized
.
 
Algorithm 
2
 
gives the pseudo
-
code of o
ur 
 
       
 
synthesis alg
o-
rithm. 
There are three challenges 
in synthesizing 
the 
 
       
:
 
(
1
) 
C
omponent
-
based program synthesis
 
[14]
[21]
 
requires 
users 
to
 
explicitly 
provide components and input
-
output 
pairs
 
[21]
.
 
The 
algorithm
 
address
es
 
this
 
using constraints extracted 
from 
values 
and 
formulas 
in a smelly cell array (
§
4.3
)
.
 
(2) 
F
u
n
ctions
 
extracted 
from a smelly cell array
’
s formulas
 
can be incompatible with one 
another
. 
For example, two functions 
f
(
x
1
, 
x
2
) = 
x
1
 
+
 
x
2
 
and
 
f
(
x
1
, 
x
2
) 
= 
x
1
 
–
 
x
2
 
extracted from CellArray2
 
in 
Figure
 
1
(a)
 
are incompat
i-
ble. 
Such incompatibility
 
can make
 
our
 
 
       
 
synthesis 
fail
. (
3
) 
D
ata 
cells 
may contain incorrect 
values,
 
which cannot be compu
t-
ed by an appropriate 
 
       
 
of the cell array. 
Such 
incorrect 
values
 
can also make
 
our 
 
       
 
synthesis fail
.
 
To tackle
 
the second challenge, 
Algorithm 
2
 
classif
ies
 
extracted 
functions
 
into compatible 
groups
 
using
 
the 
Classify
 
method 
(
Line 
_____________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________
 
Algorithm 
1
.
 
 
       
 
recovery algorithm.
 
_____________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________
 
Input
:
 
IV
 
(i
nput 
variables
),
 
FUNC
 
(
functions
),
 
IO
 
(
input
–
output pairs
),
 
CA
 
(
cell array
)
.
 
Output
:
 
F
 
(
target
 
formula
 
pattern
)
 
or NULL.
 
 
1:
  
if
 
(
F
U
N
C
.
length
 
==
 
1)
 
 
2:    
return 
F
U
N
C
.get(0)
 
 
3:  
end if
 
 
4:  
foreach
 
fn
 
in 
FUNC
 
do
 
 
5:    
if
 
fn
 
contains all input
 
variables
 
in 
I
V
 
then
 
 
6:      
if
 
(Coverage(
fn
, 
CA
)
 
==
 
100%) 
then
 
 
7:        
return
 
fn
 
 
8:      
end
 
if
 
 
9:    
end if
 
10:  
end
 
for
 
11:  
return 
NULL
 
12:
 
13:  
method
 
Coverage(
fn
, 
CA
)
 
14:    
coveredCells
 
= 0
 
15:    
foreach
 
cell
 
in 
CA
 
do
 
16:      
if
 
(
cell
.
type
 
== FORMULA) 
then
 
17:        
if
 
(
!

input
.
 
fn
(
input
)

cell
.
exp
(
input
)
) 
then
 
18:          
coveredCells
 
++
 
19:        
end if
 
20:      
e
lse
  
// Plain value case
 
21:        
if
 
(
fn
(
cell
.
input
) == 
cell
.
value
) 
then
 
22:          
coveredCells
 
++
 
23:        
end if
 
24:      
end if
 
25
:    
end 
for
 
26:    
return
 
coveredCells
 
/ 
CA
.
length
 
27:  
end 
method
 8521) 
od classifies as many
as
them iteratively into compatible groups
function 
a new
functions
18
patible groups
groups
x
To tackle
candidates
two observations: (1) the inclusion of input
from incorrect data cells can result in unsuccessful synthesis of 
 
data cells are incorrect; (2) the additional constr
output pairs are useful 
dates. In the first step, the algorithm utilizes the constraints pr
vided by functions in each compatible group to synthesize 
 
method is implemented to follow 
technique 
gives an 
functions in 
tain 
collectively constitute only a partial specification for 
synthesis.
rich the specification with additional constraints given by the i
put
 
candidates 
array while i
lieves us from the need to identify incorrect data cells and exclude 
their associated input
can be found in related work 
arbitrary one of 
result. 
2
the
AmCheck infers an 
thesize the 
use the 
cell array. 
5.
Our tool implementation of 
convenience,
Excel files
smells
ous computation smells and
We implemented AmCheck
underlying 
transform
e.g., 
For visualization
tations
smell
                                        
1
 
1) 
such that all 
functions in each group
od classifies as many
as
 
possible
. The 
them iteratively into compatible groups
function 
f
 
that cannot be classified into existing groups, it creates 
a new
 
compatible 
functions
 
compatible with 
18

22
).
 
Note that a
patible groups
.
 
groups
 
from
 
CellArray2
x
1
 
+
 
x
2
 
and 
f
(0, 
x
2
To tackle
 
the third challenge, 
candidates
 
in two steps. The two
two observations: (1) the inclusion of input
from incorrect data cells can result in unsuccessful synthesis of 
 
       
 
candidates, but we have no prior knowledge of which 
data cells are incorrect; (2) the additional constr
output pairs are useful 
dates. In the first step, the algorithm utilizes the constraints pr
vided by functions in each compatible group to synthesize 
 
       
 
candidates with the 
method is implemented to follow 
technique 
[14]
 
by treating functions as specification inputs.
gives an 
 
       
functions in 
one 
tain 
multiple candidates. 
collectively constitute only a partial specification for 
synthesis.
 
T
he algorithm, therefore, includes a second step to e
rich the specification with additional constraints given by the i
put
-
output pairs using the 
 
       
 
candidate 
candidates 
in the set using the input
array while i
gnor
lieves us from the need to identify incorrect data cells and exclude 
their associated input
can be found in related work 
arbitrary one of 
result. 
Finally, a
mong all 
2
 
selects
 
the 
one
the
 
synthesized
 
 
AmCheck infers an 
thesize the 
 
       
use the 
inferred 
 
cell array. 
Remaining cells that it cannot cover 
5.
 
IMPLEMENTATION
Our tool implementation of 
convenience,
 
uses
Excel files
. AmCheck 
smells
, and generates 
ous computation smells and
We implemented AmCheck
underlying 
con
straint solver.
transform
s
 
an
 
inferred
e.g., 
x
1
 
+
 
x
2
 
is transformed into
For visualization
tations
:
 
(1) 
C
ell arrays
smell
s 
are colored 
                                        
 
Apache POI: 
http://poi.apache.org/
functions in each group
od classifies as many
 
distinct compatible functions 
. The 
Classify
 
method 
them iteratively into compatible groups
that cannot be classified into existing groups, it creates 
compatible 
group (Lines 16
compatible with 
this new group
Note that a
 
function
 
can
 
For example, we can 
CellArray2
 
in 
Figure
2
) = 
x
2
; 
(2)
 
f
(
x
1
, 0) = 
the third challenge, 
Algorithm 
in two steps. The two
two observations: (1) the inclusion of input
from incorrect data cells can result in unsuccessful synthesis of 
candidates, but we have no prior knowledge of which 
data cells are incorrect; (2) the additional constr
output pairs are useful 
for
 
prun
dates. In the first step, the algorithm utilizes the constraints pr
vided by functions in each compatible group to synthesize 
candidates with the 
SynFPa
method is implemented to follow 
by treating functions as specification inputs.
       
 
candidate set for each compatible group. 
one 
group are not restrictive
multiple candidates. 
In other words, th
collectively constitute only a partial specification for 
he algorithm, therefore, includes a second step to e
rich the specification with additional constraints given by the i
output pairs using the 
Refine
candidate 
set, t
he 
method
in the set using the input
gnor
ing
 
those
 
pairs 
lieves us from the need to identify incorrect data cells and exclude 
their associated input
-
output pairs. 
can be found in related work 
[21]
arbitrary one of 
 
   
    
 
candidates left behind in each set as 
mong all 
returned
one
 
that covers cells in th
 
       
 
(Lines 7
AmCheck infers an 
 
       
 
successfully if it can recover or sy
       
 
for
 
a 
given 
 
       
 
to repair the cells that it can cover in the 
Remaining cells that it cannot cover 
IMPLEMENTATION
Our tool implementation of 
AmCheck
uses
 
the
 
Apache POI
. AmCheck 
load
s an Excel file
, and generates 
related 
comments 
ous computation smells and
 
corresponding 
We implemented AmCheck
 
in 
Java
straint solver.
 
For user friendliness, 
inferred
 
 
       
 
back to a 
is transformed into
 
B
For visualization
, AmCheck
 
marks
ell arrays
 
that
 
suffer 
are colored 
in 
yellow
;
 
(2)
                                        
                        
http://poi.apache.org/
functions in each group
 
are compatible
distinct compatible functions 
method 
classifies functions by adding 
them iteratively into compatible groups
. 
When it comes across a 
that cannot be classified into existing groups, it creates 
group (Lines 16

17)
 
and 
iteratively 
this new group
 
to th
is
 
can
 
be classified into 
For example, we can 
obtain
Figure
 
1
(a)
:
 
(1)
 
f
(
x
1
, 0) = 
, 0) = 
x
1
 
and 
f
(
x
1
, 
Algorithm 
2
 
synthesizes 
in two steps. The two
-
step synthesis is motivated
two observations: (1) the inclusion of input
-
output pairs derived 
from incorrect data cells can result in unsuccessful synthesis of 
candidates, but we have no prior knowledge of which 
data cells are incorrect; (2) the additional constr
prun
ing
 
inappropriate 
dates. In the first step, the algorithm utilizes the constraints pr
vided by functions in each compatible group to synthesize 
SynFPa
ttern
 
method
method is implemented to follow 
the 
component
by treating functions as specification inputs.
candidate set for each compatible group. 
group are not restrictive
 
enough, 
In other words, th
e
 
functions in the group 
collectively constitute only a partial specification for 
he algorithm, therefore, includes a second step to e
rich the specification with additional constraints given by the i
Refine
 
method (Line 6)
method
 
iteratively 
prunes 
in the set using the input
-
output pairs
pairs 
that lead to no solution
lieves us from the need to identify incorrect data cells and exclude 
output pairs. 
Details of this 
[21]
.
 
The 
Refine
 
method returns an 
candidates left behind in each set as 
returned
 
 
       
 
candidates, 
that covers cells in th
e given cell array 
(Lines 7

10).
 
successfully if it can recover or sy
given 
smelly cell array. 
to repair the cells that it can cover in the 
Remaining cells that it cannot cover 
are 
IMPLEMENTATION
 
AmCheck
, also named AmCheck for 
Apache POI
1
 
library 
to read and modif
s an Excel file
, 
analyzes its spreadsheet 
comments 
explaining these 
corresponding 
repairs
Java
 
7 
and
 
use
d
 
For user friendliness, 
back to a 
human
B
2
 
+
 
C
2
 
for 
cell 
marks
 
analysis 
results 
suffer 
from 
ambiguous computation 
 
Spreadsheet c
omments 
                        
 
http://poi.apache.org/
.
 
are compatible
. 
The met
distinct compatible functions 
in each group 
classifies functions by adding 
When it comes across a 
that cannot be classified into existing groups, it creates 
iteratively 
adds ot
her 
 
new 
group
 
(
Lines
be classified into 
multiple co
m-
obtain
 
two compatible 
, 0) = 
x
1
, 
f
(
x
1
, 
x
2
) = 
, 
x
2
) = 
x
1
 
–
 
x
2
.
 
synthesizes 
 
       
step synthesis is motivated
 
by 
output pairs derived 
from incorrect data cells can result in unsuccessful synthesis of 
candidates, but we have no prior knowledge of which 
data cells are incorrect; (2) the additional constr
aints of input
inappropriate 
 
       
 
cand
dates. In the first step, the algorithm utilizes the constraints pr
vided by functions in each compatible group to synthesize 
method
 
(
Line 5
)
. The 
component
-
based synthesis 
by treating functions as specification inputs.
 
candidate set for each compatible group. 
If the 
enough, 
the set can co
functions in the group 
collectively constitute only a partial specification for 
 
      
he algorithm, therefore, includes a second step to e
rich the specification with additional constraints given by the i
method (Line 6)
. For each 
prunes 
i
nappropriate 
output pairs
 
of the given cell 
that lead to no solution
.
 
This r
lieves us from the need to identify incorrect data cells and exclude 
Details of this 
pruning
 
process 
method returns an 
candidates left behind in each set as 
candidates, 
Algorithm 
e given cell array 
most 
successfully if it can recover or sy
smelly cell array. 
End users can 
to repair the cells that it can cover in the 
are 
error
-
prone
.
 
, also named AmCheck for 
to read and modif
analyzes its spreadsheet 
explaining these 
ambig
repairs
.
 
 
Choco
 
[22]
 
as 
For user friendliness, 
AmCheck
human
-
readable 
format
cell 
D2 in 
Figure
 
1
(a).
results 
by
 
three ann
ambiguous computation 
omments 
are added 
The met
h-
in each group 
classifies functions by adding 
When it comes across a 
that cannot be classified into existing groups, it creates 
her 
Lines
 
m-
two compatible 
) = 
       
 
by 
output pairs derived 
from incorrect data cells can result in unsuccessful synthesis of 
candidates, but we have no prior knowledge of which 
aints of input
-
cand
i-
dates. In the first step, the algorithm utilizes the constraints pr
o-
vided by functions in each compatible group to synthesize 
. The 
based synthesis 
 
It 
If the 
the set can co
n-
functions in the group 
      
 
 
he algorithm, therefore, includes a second step to e
n-
rich the specification with additional constraints given by the i
n-
. For each 
nappropriate 
of the given cell 
This r
e-
lieves us from the need to identify incorrect data cells and exclude 
process 
method returns an 
its 
Algorithm 
most 
as 
successfully if it can recover or sy
n-
End users can 
to repair the cells that it can cover in the 
 
, also named AmCheck for 
to read and modif
y
 
analyzes its spreadsheet 
ambig
u-
its
 
AmCheck
 
format
, 
(a).
 
three ann
o-
ambiguous computation 
are added 
to smelly cells for 
formance errors 
explaining
validate 
reported results
6.
 
EVALUATION
W
e evaluate AmCheck and 
RQ1:
life 
RQ
2
:
smells precisely?
RQ
3
:
quality of 
ing
RQ
4
:
T
o answer 
the 
EUSES corpus
computation smells in this corpus, and manually validated 700 of 
them
 
randomly selec
are 
true
a case study 
for 
research project 
nese Academy of Sciences. 
detect ambiguous computation smells in 
then 
interviewed 
spreadsheet
from
 
their
____________________________________________________________________________
Algorithm 
_____________________________________________________________________________________________________________________________
Input
:
Output
 
1:
  
groups
 
2:
  
pert
 
3:
  
while
 
4:
    
 
5:
  
  
 
6:
    
 
7
:
    
 
8
:
      
 
9
:
      
10
:
    
11
:
  
end
12
:
  
return
13
:
 
14
:
  
method
15
:
    
16
:
   
17
:
      
18
:
      
19
:
        
20
:
          
21
:
        
22
:
      
23
:
      
24
:
    
25
:
    
26
:
  
end
 
Figure 
to smelly cells for 
describing 
formance errors 
are colored 
explaining
 
the
ir
 
reasons.
validate 
these
 
reported 
reported results
 
for 
our motivating example in 
EVALUATION
e evaluate AmCheck and 
RQ1:
 
How 
common
 
life 
spreadsheets?
 
:
 
Can AmCheck detect 
smells precisely?
 
:
 
Do end
 
users find AmCheck useful 
quality of 
their 
spreadsheets
ing
 
ambiguous computation smell
:
 
Are 
ambiguous computation smell
o answer 
question
s
 
RQ1
EUSES corpus
 
[11]
computation smells in this corpus, and manually validated 700 of 
randomly selec
ted 
true
 
smells
 
(
§
6.1
). 
a case study 
on
 
real
-
life spreadsheets 
research project 
budget
nese Academy of Sciences. 
detect ambiguous computation smells in 
interviewed 
finance officers
spreadsheet
s
 
to understand 
their
 
spreadsheets (
____________________________________________________________________________
_____________________________________________________________________________________________________________________________
Algorithm 
2
.
 
 
       
_____________________________________________________________________________________________________________________________
 
IV
 
(i
nput 
variables
tion
s
),
 
IO
 
(
input
: 
F
 
(target
 
formula pattern
groups
 
= 
C
lassify
pert
 
= 0; 
F
 
= 
NULL
while
 
groups
 
not EMPTY 
    
group
 
= 
g
roup
s
  
formula
s
 
= 
SynFPattern 
    
formula
 
= Refine
    
if
 
(
formula

NULL && 
      
pert
 
=
 
Coverage(
      
F
 
= 
formula
 
    
end
 
if
 
end
 
while
 
return
 
F
 
method
 
Classify
(
    
groups
 
= EMPTY
 
while
 
(

init
Func
      
new
Group
 
= 
{
      
foreach
 
func
        
if
 
(
!

fn

new
          
new
Group
        
end
 
if
 
      
end
 
for
 
      
group
s
.add(
new
    
end
 
while
 
    
return
 
groups
 
end
 
method
 
Figure 
3
.
 
AmCheck screenshot for
describing 
their corresponding 
are colored 
in 
red 
with
reasons.
 
These annotations 
reported 
results
.
 
Figure 
our motivating example in 
EVALUATION
 
e evaluate AmCheck and 
study
 
the following
 
are
 
ambiguous computation smell
 
Can AmCheck detect 
and repair 
 
users find AmCheck useful 
spreadsheets
 
in terms of detecting 
ambiguous computation smell
s
?
ambiguous computation smell
RQ1

2
, we 
conducted
[11]
. We
 
used AmCheck to detect ambiguous 
computation smells in this corpus, and manually validated 700 of 
ted 
from all results to 
). 
To answer 
question
life spreadsheets 
prepared
budget
ing
 
in
 
the
 
nese Academy of Sciences. 
In
 
th
is
 
study, we 
detect ambiguous computation smells in 
finance officers
 
who created or main
to understand 
why and 
how 
spreadsheets (
§
6.2
).
 
_____________________________________________________________________________________________________________________________
       
 
synthesis algorithm
_____________________________________________________________________________________________________________________________
_________________________________________________________________________________________________________________
variables
),
 
COMP
 
(components), 
input
–
output pairs
formula pattern
)
.
 
lassify
(
FUNC
)
;
  
// 
G
et 
NULL
 
not EMPTY 
do
 
s
.removeOne()
;
 
 
SynFPattern 
(
I
V
, 
COMP
= Refine
(
IV
, 
COMP
, 
formulas
NULL && 
Coverage(
Coverage(
formula
, 
CA
 
(
FUNC
)
 
= EMPTY
 
Func

FUNC
.
 
init
Func
{
init
Func
}
 
func
 
in 
F
UNC
\
newGroup
new
Group
. 

in
. 
fn
Group
.add(
func
)
 
new
Group
)
;
  
// All in newGroup classified
 
AmCheck screenshot for
 
the e
 
their corresponding 
repairs
with
 
spreadsheet 
These annotations 
can
 
assist end users to 
Figure 
3
 
gives 
a 
screen
our motivating example in 
Figure
 
1
the following
 
research questions
ambiguous computation smell
and repair 
ambiguous computation 
users find AmCheck useful 
for
 
improv
in terms of detecting 
?
 
ambiguous computation smell
s harmful?
 
 
conducted
 
an empirical study
used AmCheck to detect ambiguous 
computation smells in this corpus, and manually validated 700 of 
from all results to 
determine whether they 
question
 
RQ
3

4
, we 
prepared
 
by 
finance officers
 
Institute
 
of Software, Ch
study, we 
used 
AmCheck to
detect ambiguous computation smells in 
th
ese 
spreadsheets
who created or main
how 
these 
smells 
_____________________________________________________________________________________________________________________________
synthesis algorithm
.
 
_________________________________________________________________________________________________________________
(components), 
FUNC
output pairs
),
 
CA
 
(
cell array
 
et 
compatible group
 
// 
Retrieve
 
one
COMP
, 
group
)
 
formulas
, 
IO
)
 
Coverage(
formula
, 
CA
)>
pert
CA
)
;  // Measure 
Func
 
non
-
classif
newGroup
 
do
 
fn
(
in
)

func
(
in
))
// All in newGroup classified
the e
xample in 
Figure
repairs
;
 
(3) 
C
o
n-
spreadsheet 
comments 
assist end users to 
screen
shot
 
of 
the 
1
(a)
.
 
research questions
:
 
ambiguous computation smell
s in 
real
-
ambiguous computation 
improv
ing
 
the 
in terms of detecting 
and 
repai
r-
 
an empirical study
 
on 
used AmCheck to detect ambiguous 
computation smells in this corpus, and manually validated 700 of 
determine whether they 
, we 
conducted
 
finance officers
 
of Software, Ch
i-
AmCheck to
 
spreadsheets
. We 
who created or main
tained these 
smells 
have 
ar
i
se
n
 
_____________________________________________________________________________________________________________________________
_____________________________________
 
_________________________________________________________________________________________________________________
 
FUNC
 
(
fun
c-
cell array
)
.
 
compatible group
s
 
one
 
group
 
pert
) 
then
 
;  // Measure 
percentage
 
classif
ied
) 
do
 
))
 
then
 
// All in newGroup classified
 
 
Figure
 
1
(a)
.
 
8536.1
 
Empirical
 
Study on the EUSES Corpus
 
W
e 
ran
 
AmCheck
 
on all 
spreadsheets
 
in the EUSES corpus
 
and 
got experimental results 
about ambiguous computation smells.
 
6.1.1
 
Experimental Subjects
 
The 
EUSES 
corpus consists of 
4
,
0
37
 
real
-
life 
spreadsheets
 
from 
11 
categories
. Since it
s
 
creat
ion
 
in 2005, it 
has been
 
widely
 
use
d 
for spreadsheet research and evaluation
.
 
Table 
1
 
give
s
 
the 
stati
s-
tic
s
 
of the corpus. It lists 
the 
number of spreadsheets (Total), 
the 
number of our processed spreadsheets (Processed), 
the 
number of 
spreadsheets with formulas (With formulas), and 
the 
number of 
spreadsheets with cell arrays (With arrays) for each category 
(Category). We 
find
 
that only 92.8% (
3
,
746
/4,037)
 
of 
sprea
d-
sheets in
 
the corpus
 
could be parsed by
 
the 
Apache POI
. 43.4% 
(1,626/3,746) 
of the 
processed spreadsheets 
contain 
cells with 
formulas
. 
Out of them
,
 
61
.1
%
 
(993/1
,
626)
 
contain
 
cell array
s
.
 
6.1.2
 
Ambiguous 
C
omputation 
S
mell
s
 
Table 
1
 
also 
gives
 
the 
number of spreadsheet
s
 
suffering 
from 
ambiguous computation smells (Smelly), 
the 
number of sprea
d-
sheets with 
missing formula smells (Missing), 
the 
number of 
spreadsheets with 
i
nconsistent formula smells (Inconsistent), and 
the 
percentage of 
smelly 
spreadsheets 
against 
all 
those with cell 
arrays
. 
Note that a smelly 
spreadsheet 
can suffer 
from 
both 
types 
of 
smells 
simultaneously
. 
As shown in 
Table 
1
, 
44.7%
 
(444/993)
 
of the 
spreadsheets
 
with 
cell arrays
 
and 
27
.3
%
 
(444/1
,
626) 
of the 
spreadsheets 
with
 
formulas suffer 
from 
at least one kind of 
a
m-
biguous computation smell.
 
This discloses 
that 
ambiguous comp
u-
tation
 
smell
s
 
are
 
common 
in
 
real
-
life spreadsheets.
 
Table 
2
 
list
s
 
the 
number of cell arrays (CA), 
the 
number of 
well
-
formed cell arrays (WCA), and 
the 
number of 
smelly 
cell arrays 
(
SCA
). 
It also
 
list
s
 
the 
number of cell arrays suffering 
from 
mis
s-
ing formula smells (MISS), inconsistent formula smells (INCO)
,
 
and both smells (BO).
 
It omits filby and j
ackson
 
since they do not 
contain cell array
s
. 
We observe that 
ambiguous computation 
smells occur 
commonly
 
in t
he corpus
: 
2
1.
6
%
 
(3,535/16,385) 
of 
identified cell arrays suffer
 
from
 
ambiguous computation smells
. 
Among 
these 
smelly 
cell arrays, 
75.3
% 
(2,
663
/3,535) 
suffer 
from 
missing
 
formula smells, 31
.5
% 
(1,113/3,535) 
suffer 
from 
inco
n-
sistent formula 
smells
, and
 
6.8
%
 
(241/3,535) 
suffer 
from 
both 
smells.
 
Therefore, we 
draw 
the following conclusion:
 
Ambiguous computation smell
s 
commonly occur in real
-
life spreadsheet
s
, 
with
 
missing formula smells 
occurring 
more often 
than inconsistent formula smells
.
 
6.1.3
 
Quality of 
AmCheck 
Analysis
 
AmCheck 
is
 
based on
 
cell array identification and 
 
       
 
infe
r-
ence
. This process 
partly 
rel
ies
 
on
 
heuristics
, 
so 
AmCheck
 
may
 
be 
imprecise
 
and cause 
false positives
. Thus,
 
we 
are interested in 
its 
analysis 
quality
.
 
W
e 
partition
 
detected 
smelly cell arrays
 
into 
seven
 
categories
 
according to 
how much 
the 
inferred
 
 
       
 
can cover 
cells in 
these arrays. These seven categories are
:
 
{100%, 
[90%, 
100%
)
, 
[80%, 
90%
)
, 
[70%, 
80%
)
,
 
[60%, 
70%
)
,
 
[50%, 
60%
)
 
and 
[0%, 
50%
)
}
.
 
Table 
3
 
list
s
 
the 
number of smelly cell arrays (SCA) and 
the 
number of 
cells
 
with 
conformance errors (CE1
)
 
for each cat
e-
gory
. 
We observe that 
the 
 
       
 
inferred
 
by AmCheck is able to 
cover all cells 
in
 
903 smelly cell arrays
 
(i.e., a coverage of 100%)
 
and 
90%
 
or more (but not 100%)
 
of cells in another
 
108 
smelly 
cell arrays
.
 
This suggests that values and formulas in these 
1
,
011 
cell arrays are 
highly
 
compatible
 
with
 
the inferred
 
 
       
. 
In 
other words, each of these 1,011 cell arrays that suffer from mis
s-
ing formulas or different formula patterns 
very likely prescribe
s
 
a 
well
-
defined computational semantic expressible by 
the 
 
       
 
inferred by
 
AmCheck.
 
It is thus very 
likely that detected ambig
u-
ous computation smells in these 
cell arrays
 
(1,011/3,535 = 28.6%) 
are probably 
true.
 
This provides an alternative 
for assessing the 
quality of AmCheck
’
s automatically 
detected 
spreadsheet 
smells.
 
We 
can
 
use these seven categories to rank the likeliness of a 
smelly 
cell array being 
true
. 
Those 
cell arrays 
fall
ing
 
into the 
   
100% category are considered most likely.
 
Next
, 
we 
evaluate the precision of 
AmCheck
’
s 
smell detection 
for
 
the seven categories.
 
W
e r
andomly select
ed
 
100 
smelly 
cell arrays 
(CA) 
in
 
each 
categor
y
 
and 
manually 
validate
d
 
their quality. This 
accounts for 700 smelly cell arrays, which occup
y
 
19.8% 
(700/3,535)
 
of the whole
. 
In
 
each category, 
Table 
3
 
lists 
the 
nu
m-
ber of true 
smelly 
cell arrays (TP), 
the 
number of 
true smelly 
cell 
arrays 
that 
AmCheck can repair
 
(RE), 
the 
number of 
true smelly 
cell arrays 
warned by 
Excel 2010
 
(EX), 
and 
the 
number of cells 
with
 
true conformance errors (CE2)
.
 
We explain these data below.
 
True positives and 
repairability
.
 
Out of
 
the 700 
sampled 
smelly 
cell arrays, we
 
manually
 
confirmed 
that 
31
9
 
(45.
6
%) 
of them 
are
 
true 
smelly 
cell arrays
.
 
We observe 
from the CA
 
and TP column
s
 
Table 
1
.
 
S
tatisti
cs
 
of the 
EUSES 
corpus
 
(n.a.: not 
applicable)
.
 
Category
 
S
preadsheets
 
Spreadsheets with a
mbiguous computation smells
 
Total
 
Processed
 
With f
ormula
s
 
With a
rray
s
 
Smelly
 
Missing
 
Inconsistent
 
Percentage
 
cs101
 
8
 
8
 
8
 
7
 
3
 
2
 
1
 
42.
9
%
 
database
 
678
 
632
 
202
 
103
 
56
 
45
 
29
 
54.
4
%
 
f
ilby
 
45
 
2
 
2
 
0
 
0
 
0
 
0
 
n.a.
 
financial
 
720
 
692
 
358
 
245
 
126
 
81
 
79
 
51.4%
 
forms3
 
26
 
19
 
18
 
10
 
4
 
3
 
1
 
40.0%
 
grades
 
588
 
557
 
285
 
201
 
88
 
66
 
42
 
43.
8
%
 
homework
 
576
 
535
 
278
 
163
 
54
 
35
 
30
 
33.1%
 
inventory
 
699
 
643
 
278
 
173
 
75
 
47
 
44
 
43.
4
%
 
jackson
 
13
 
0
 
0
 
0
 
0
 
0
 
0
 
n.a.
 
modeling
 
679
 
653
 
192
 
88
 
38
 
29
 
21
 
43.
2
%
 
personal
 
5
 
5
 
5
 
3
 
0
 
0
 
0
 
0%
 
Total
 
4
,
037
 
3
,
746
 
1
,
626
 
993
 
444
 
308
 
247
 
44.7%
 
 
Table 
2
. 
Smelly cell arrays 
in the EUSES corpus
.
 
Category
 
CA
 
W
CA
 
SCA
 
M
ISS
 
I
NCO
 
B
O
 
cs101
 
31
 
21
 
10
 
7
 
3
 
0
 
database
 
2
,
252
 
1
,
714
 
538
 
438
 
113
 
13
 
financial
 
4
,
899
 
4
,
221
 
678
 
415
 
294
 
31
 
forms3
 
229
 
62
 
167
 
166
 
127
 
126
 
grades
 
1
,
893
 
1
,
426
 
467
 
381
 
111
 
25
 
homework
 
2
,
162
 
1
,
456
 
706
 
555
 
176
 
25
 
inventory
 
3
,
210
 
2
,
589
 
621
 
433
 
205
 
17
 
modeling
 
1
,
585
 
1
,
237
 
348
 
268
 
84
 
4
 
personal
 
124
 
124
 
0
 
0
 
0
 
0
 
Total
 
16
,
385
 
12
,
850
 
3
,
535
 
2
,
663
 
1
,
113
 
241
 
 854in 
Table 
3
 
that the number of true smelly cell arrays decreases 
with
 
the 
reduction in 
coverage
.
 
W
e 
recommend
 
to 
select 80% as 
a
 
coverage threshold for
 
reliabl
e
 
detecti
on of
 
smelly cell arrays
 
with 
an experimental precision of 
73.7% (221/300).
 
AmCheck 
is able to
 
repair 
316
 
(
99.
1%) of 
the 31
9
 
true smelly cell 
arrays
. It
 
show
s
 
that AmCheck 
is effective 
for detecting and r
e-
pairing smelly cell arrays
 
automatically. 
Figure 
4
 
elaborates
 
the 
effectiveness with respect to the two different types of smells 
under various coverage categories. 
For each 
coverage 
category, i
t 
gives
 
the 
number of true
 
smelly 
cell
 
arrays
 
(True)
 
and 
the 
number 
of true smelly cell arrays 
that can be repaired
 
(Repaired)
 
using an 
inferred 
 
       
for 
missing
 
formula smells (
Figure 
4
(a)) and 
inconsistent formula smells (
Figure 
4
(b))
. 
There are totally 10 cell 
arrays suffering 
from 
bo
th missing formula and inconsistent fo
r-
mula smells
. They 
are counted in
 
both charts.
 
AmCheck is able to 
repair 
2
1
4
 
out of the 2
1
6
 
missing formula smells
, and
 
11
2
 
out of 
the 11
3
 
inconsistent formula smells.
 
The three smelly cell arrays 
that 
AmCheck 
fail
ed
 
to repair involves sophisticated library fun
c-
tions, incomplete input variables and complex structures.
 
There is 
no enough evidence to suggest that AmCheck’s repairing effe
c-
tiveness and coverage categories are correlated.
 
We draw the following conclusion:
 
AmCheck 
can effectively repair
 
true 
ambiguous comput
a-
tion smell
s
. One may use
 
a coverage threshold of 
80% for 
reliabl
e
 
detect
ion of
 
ambiguous computation smell
s
.
 
False positive
s.
 
The differences of 
value
s
 
in 
the 
CA and TP co
l-
umn
s
 
in 
Table 
3
 
give the number of false positives
, which 
arise
 
mostly
 
because the cells concerned do not form a cell array as 
identified b
y AmCheck using the heuristics in 
§
4.1
. 
T
wo 
main 
causes
 
are found
:
 
(1) Some spreadsheets use number
s
 
as label
s
. 
For
 
example, 
i
n financial 
re
ports
 
end 
users
 
often
 
use year
s
 
like 
2011 and 2013
 
as
 
labels
 
but 
re
presented in 
a 
number format
. Our
 
heuristics
 
can
 
mis
interpret
 
them
 
as data
 
cells
. 
69.2% (
92
/
133
)
 
of 
false 
positives 
in the 
coverage range of 
[
70
%, 
100
%]
 
belong to 
this case
.
 
It 
should be easy for end 
users
 
to recognize such 
false
 
positives.
 
(2) 
The
 
heuristics
 
incorrectly 
identif
y
 
s
ome 
cells
 
with 
distinct formula
 
patterns
 
as those subject to
 
the same comput
a-
tional semantics
 
(but actually not).
 
13.5% (
18
/133)
 
of 
false pos
i-
tives
 
in 
the coverage range of 
[
70
%, 
100
%]
 
belong to 
this case. 
End users 
can
 
manually confirm 
or
 
reject
 
them 
in our current 
AmCheck implementation
.
 
For
 
the
 
remaining 
23 (17.3%) 
false 
positives
, 
the 
concerned
 
cell arrays contain
 
data cells
 
with 
varying
 
complex
 
semantics, which 
AmCheck
 
cannot 
effectively 
disti
n-
guish
. 
We leave 
this 
to
 
future
 
work.
 
6.1.4
 
Confo
rmance Errors
 
C
ells 
that
 
do
 
not conform to 
the
 
inferred 
 
       
 
in a cell array 
are 
considered
 
as 
conformance error
s. In 
Table 
3
,
 
AmCheck
 
d
e-
tected 
a total of 
8
,
481 
conformance error
s
 
(
CE
1)
 
in
 
the EUSES 
corpus
. 
W
e 
manually validated 
the 
1
,
4
23
 
detected 
conformance 
error
s in the 700 sample
d
 
cell arrays
.
 
We confirmed 
that 
30.5% 
(434/1,423) 
of them are 
true conformance errors (CE2), and all of 
them 
occur at
 
the 
319
 
true 
smelly cell arrays
.
 
Note that there can 
be 
multiple 
conformance error
s
 
in 
one smelly
 
cell array.
 
We also 
observe
 
that c
onformance errors 
occur
ring
 
at 
the 
cell arrays 
with
 
h
igh
er
 
coverage 
are 
more 
likely to be true
. 
For
 
example,
 
70.5% 
(179/254) of detected conformance errors are true
 
in
 
the coverage 
range of 
[
80
%, 
100
%]
.
 
6.1.5
 
Comparison with 
Excel
 
Although
 
Microsoft 
Excel
 
has built
-
in support for inconsistency 
de
tection
 
in cell array
s
, i
ts
 
detection is subject to 
a few 
limitations. 
First, 
Excel
 
considers only 
cell array
s
 
of three 
adjacent 
cells. S
e-
cond, it
 
detect
s
 
only those 
smells 
that a
 
cell’s formula is syntact
i-
cally 
different from 
th
ose
 
of its 
two
 
adjacent cells 
when th
es
e two 
cells
’ formulas are identical
.
 
The EX column in 
Table 
3
 
shows 
that Excel detect
ed
 
inconsistencies in only 3.8% (12/
319
) of the 
true 
smelly cell arrays.
 
6.1.6
 
Runtime 
Overhead
 
Running 
AmCheck 
over
 
the 
whole 
EUSES corpus took about 116 
minutes
. It thus
 
took about 1.7 seconds to analyze one spreadsheet
 
on average
.
 
Th
is
 
good performance is attributed to the use of
 
our
 
two
-
stage analysis (
 
  
 
    
 
recovery and 
 
       
 
synthesis).
 
If 
we 
use 
 
       
 
synthesis
 
only
 
to infer 
formula
 
pattern
s, 
it
 
would 
t
ake
 
861
 
minutes
 
(
12.8
 
seconds 
for each spreadsheet on average)
. 
Our two
-
stage 
analysis 
significantly 
reduce
s
 
the 
computational
 
time by 86.5%
. 
Among
 
the 3,535
 
detected smelly cell arrays
,
 
 
93.2%
 
(3,296/3,535) of them ha
ve
 
their 
 
       
 
successfully 
recovered 
at
 
the
 
first stage, and 
the 
remaining
 
6.8%
 
(
239
/3,535) 
ha
ve
 
their 
 
       
 
synthesized
 
at the second stage
.
 
Table 
3
. 
S
melly cell arrays 
with
 
different
 
coverage
s
.
 
 
All
 
Sample
d
 
SCA
 
CE
1
 
CA
 
TP
 
RE
 
E
X
 
CE
2
 
100%
 
903
 
0
 
100
 
95
/
 
100
 
95
/
 
100
 
2
/
 
100
 
0
/
 
0
 
[90
%, 
100
%
)
 
108
 
133
 
100
 
73
/
 
100
 
73
/
 
100
 
7
/
 
100
 
94
/
 
121
 
[8
0%, 
9
0%
)
 
197
 
338
 
100
 
53
/
 
100
 
52
/
 
100
 
3
/
 
100
 
85
/
 
133
 
[7
0%, 
8
0%
)
 
120
 
242
 
100
 
46
/
 
100
 
46
/
 
100
 
0
/
 
100
 
101
/
 
190
 
[6
0%, 
7
0%
)
 
211
 
363
 
100
 
3
8
/
 
100
 
36
/
 
100
 
0
/
 
100
 
103
/
 
192
 
[5
0%, 
6
0%
)
 
917
 
1
,
392
 
100
 
9
/
 
100
 
9
/
 
100
 
0
/
 
100
 
37
/
 
135
 
[
0%, 
50
%
)
 
1
,
079
 
6
,
013
 
100
 
5
/
 
100
 
5
/
 
100
 
0
/
 
100
 
14
/
 
652
 
Total
 
3
,
535
 
8
,
481
 
700
 
31
9
/
 
700
 
316
/
 
700
 
12
/
 
700
 
434/
 
1,423
 
 
 
(a)
 
Cell arrays with m
issing formula smells
.
 
 
(b) 
Cell arrays with i
nconsistent formula smells
.
 
Figure 
4
. 
Sampled 
smelly cell arrays with different coverages 
(x
-
axis: coverage category, y
-
axis: the number of cell 
arrays 
concerned)
.
 
 
66
54
35
28
23
6
4
66
54
35
28
21
6
4
0
20
40
60
80
100%
 [90%,
100%)
[80%,
90%)
[70%,
80%)
[60%,
70%)
[50%,
60%)
[0%,
50%)
True
Repaired
32
22
20
19
16
3
1
32
22
19
19
16
3
1
0
5
10
15
20
25
30
35
100%
 [90%,
100%)
[80%,
90%)
[70%,
80%)
[60%,
70%)
[50%,
60%)
[0%,
50%)
True
Repaired8556.2
 
Case Study on Real
-
life Spreadsheets
 
To evaluate 
the usefulness of AmCheck to end users, 
w
e 
conduc
t-
ed a case study on 
ten 
real
-
life spreadsheets
 
currently
 
used by 
finance officers
. 
We studied
 
three questions
:
 
(
1
) 
W
hy 
do 
ambig
u-
ous 
computation smell
s 
occur
 
in spreadsheets?
 
(
2
) 
Is 
AmCheck 
helpful
 
for
 
detect
ing and repairing 
ambiguous computation smell
s
? 
(3) 
H
ow harmful 
are 
ambiguous computation smells
?
 
Setup
.
 
We conducted our study 
in 
the 
Institute
 
of Software, Ch
i-
nese Academy of Sciences. 
W
e collected 
ten
 
real
-
life spreadsheets 
professional
ly
 
prepared
 
by 
finance officers
 
for 
research project 
budget
ing
. These 
spreadsheets
 
involve 
seven
 
departments or units
, 
and 
have 
been used
 
for more than three years. Most spreadsh
eets 
are maintained 
by 
more than 
two
 
officers
.
 
We invited 
three
 
officers
 
who
 
have participated in
 
maintain
ing 
these
 
spreadsheets 
for an interview
. 
We 
explain
ed
 
ambiguous 
computation smells
 
to the
se 
officers
, and 
told 
them 
our plan
 
of 
using their spreadsheets 
in
 
the study
. 
W
e gave a list of 
A
m-
Check
’
s 
detected 
ambiguous computation smells
 
in these sprea
d-
sheets
 
as well as suggested repairs with
 
brief
 
explanation
s
. We 
let 
the 
officers
 
study 
these smells
 
before 
our 
interview.
 
In the intervi
ew
, we asked 
the 
officers
 
three
 
questions
:
 
(1) Can
 
you 
explain
 
how
 
th
ese 
ambiguous computation smell
s
 
arise
?
 
(
2
) 
Do you 
agree
 
that the
se
 
smell
s
 
are
 
indeed problem
s
?
 
(3) 
Are the
 
suggested
 
repairs helpful?
 
Overall results
.
 
For ea
ch spreadsheet, 
Table 
4
 
lists
 
the 
number of 
cell arrays (
CA
),
 
the 
number of 
well
-
formed
 
cell array
s 
(
WCA
), 
the 
number of 
smelly cell arrays (
SCA
), 
the 
number of 
cell arrays 
suffering
 
from
 
missing formula smells (MISS), 
the 
number of 
cell 
arrays suffering 
from 
inconsistent formula smells (INCO), and 
the 
number of cell
s
 
with 
conformance
 
error
s (CE).
 
The numbers in 
brackets are confirmed data by officers. 
We observe that 80.0% 
(
8
/
10
)
 
of 
the 
spreadsheets suffer 
from 
ambiguous computation 
smells.
 
We detected
 
55
 
smelly cell arrays (
40 
suffering 
from 
mis
s-
ing formula smells and 17 
suffering 
from 
inconsistent
 
formula 
smells
; some suffering 
from 
both smells
)
, and 23 
cells contain 
conformance errors
.
 
The result
s
 
reveal that 
ambiguous comput
a-
tional 
smells are common to financial spreadsheets that have been 
rigorously prepared and maintained by end users for over three 
years
.
 
40% of the spreadsheets contain even confirmed errors.
 
20
.4
%
 
(55/270) 
of 
identified 
cell arrays
 
suffer
 
from
 
ambiguous 
computation smells, 
and this percentage 
is comparable 
to
 
that for 
the EUSES corpus (2
1.6
%).
 
The ratio 2.
4
 
(40/17) between number 
of 
smelly cell arrays suffering 
from 
missing formula smells and 
number 
of 
smelly c
ell arrays suffering
 
from
 
inconsistent formula 
smells is also comparable to 
that for the EUSES corpus, 
2.
4
 
(2
,
663/1
,
113)
.
 
Ratios of true positives are higher than those in the 
EUSES 
corpus
. This is because the aforementioned f
alse positives
 
are rare in these spreadsheets. 
Therefore, w
e draw the following 
conclusion:
 
The 
ratio
 
of 
smelly 
cell array
s in real
-
life spreadsheets 
is
 
comparable 
to that for
 
the EUSES corpus.
 
Causes of 
ambiguous computation smell
s
.
 
From the interview 
with 
officers
, we obtained interesting 
answers
 
about how 
missing 
formula smells 
arose
. T
hey 
recalled: 
“
I copied 
some
 
data from 
another place, and did
 
not
 
notice that 
they
 
can be computed 
from
 
related cells
”
, 
“
I just wrote 
down the
se data 
as 
plain
 
value
s
”
, or 
“
after I used 
the 
auto
-
fill feature to generate 
these
 
cells (in 
a
 
cell 
array), I notice
d
 
that there 
was
 
an error 
of 
‘
division
 
by zero
’
, and
 
so I set 
its
 
value to 0
”
. 
From these answers,
 
missing formula 
smells 
have been
 
usually
 
caused by 
carelessly 
ignoring 
necessary
 
computation.
 
When 
coming to the question of how 
inconsistent formula smells 
arose
, 
they
 
recalled:
 
“
I copied formula
s
 
from another 
spreadsheet
, 
and I really 
do not know why 
sme
lls
 
occur
”
, or 
“
I 
wrote
 
formula
s
 
by myself and d
id
 
not
 
use 
any 
auto
-
fill feature, 
but I missed
 
some 
input cells
”
. For example, 
function SUM has been used inconsis
t-
ently when some cells contain a value of zero.
 
Another
 
example
 
is:
 
a cell array should have a
 
formula 
pattern 
of 
R[
-
3]C * R[
-
2]C * 
R[
-
1]C, but some 
of its 
cells
 
have a formula like 
R[
-
3]C * R[
-
1]C.
 
This occurs when
 
R[
-
2]C
’
s value 
happens to be
 
1.
 
From these 
interview answers, we draw the following conclusion:
 
Ambiguous c
omputation smell
s 
have been
 
often
 
caused by 
carelessly using the 
auto
-
fill 
and
 
copy
-
and
-
paste 
feature
s
.
 
AmCheck
 
can 
effectively detect and repair such smells
.
 
Harmfulness of 
ambiguous computation
 
smells.
 
Interestingly, 
the 
officers
 
were
 
surprised 
by
 
so many detected ambiguous co
m-
putation 
smells. 
Although
 
some concerned cells
 
had temporarily 
correct values
, they 
still 
decided to 
take
 
our repair suggestions. 
They said
:
 
“
these cells (suffering
 
from
 
ambiguous computation 
smells) are risky, and are difficult to 
maintain
 
in future
”
.
 
Alt
hough t
he 
studied 
spreadsheets have been
 
verified
 
by 
our 
f
i-
nancial officers 
carefully during their daily job
s
, conformance 
errors 
still 
exist
. When 
such errors were presented to them
, they 
said
:
 
“
the final result is balanced, and i
t should be 
im
possible!
”
.
 
After we repaired 
the 
conformance
 
error
s
, we noticed that the 
final result 
now 
bec
a
me unbalanced. 
Weird! 
Finally, we 
figured 
out why: 
there was a
nother
 
missing formula
 
smell
 
in a related cell. 
Although 
this 
missing formula (not related to cell arrays) 
cou
ld 
not 
be detected by 
the current AmCheck implementation
, 
its 
r
e-
ported
 
smell 
warning
 
enables
 
end users to 
eventually 
find the 
hidden problem 
successfully
. 
These 
conformance errors 
have been
 
caused by careless updates to cells 
in cell arrays
. With 
A
m-
Check
’
s
 
repairs, 
our 
officers
 
realized that 
existing 
values 
of
 
some 
cells are 
indeed 
faulty.
 
From these interview interactions, we draw 
the following conclusion:
 
Table 
4
. 
Detected smelly 
cell arrays
 
in the case study
.
 
ID
 
CA
 
W
CA
 
SCA
 
M
ISS
 
I
NCO
 
CE
 
1
 
12
 
12
 
0
 
(0)
 
0
 
(0)
 
0
 
(
0
)
 
0
 
(
0
)
 
2
 
24
 
24
 
0
 
(0)
 
0
 
(0)
 
0
 
(
0
)
 
0
 
(
0
)
 
3
 
1
7
 
9
 
8
 
(8)
 
7
 
(7)
 
3
 
(
3
)
 
4
 
(
4
)
 
4
 
32
 
12
 
20
 
(20)
 
14
 
(14)
 
6
 
(
6
)
 
8
 
(
8
)
 
5
 
32
 
29
 
3
 
(3)
 
2
 
(2)
 
1
 
(
1
)
 
0
 
(
0
)
 
6
 
32
 
29
 
3
 
(3)
 
2
 
(2)
 
1
 
(
1
)
 
0
 
(
0
)
 
7
 
10
 
9
 
1
 
(0)
 
1
 
(0)
 
0
 
(
0
)
 
1
 
(
0
)
 
8
 
32
 
29
 
3
 
(3)
 
2
 
(2)
 
1
 
(
1
)
 
0
 
(
0
)
 
9
 
50
 
45
 
5
 
(3)
 
3
 
(
1
)
 
2
 
(
2
)
 
1
 
(
1
)
 
10
 
29
 
17
 
12
 
(10
)
 
9
 
(9)
 
3
 
(
1
)
 
9
 
(
7
)
 
Total
 
2
70
 
215
 
55
 
(50
)
 
40
 
(
37
)
 
17
 
(
15
)
 
23
 
(
20
)
 
 
Table 
5
. 
Undetected c
ell arrays
 
in the case study
 
(numbers in 
brackets are false positives).
 
ID
 
CA
 
Undetected cell arrays
 
DR
C
 
PV
 
INS
 
CC
 
C
ON
 
DS
 
1
 
12
 
5
 
 
 
1
 
 
4
 
2
 
24
 
 
 
 
 
 
 
3
 
1
7
 
 
6
 
 
 
 
 
4
 
32
 
 
 
2
 
 
1
 
 
5
 
32
 
 
 
 
1
 
 
8
 
6
 
32
 
 
 
 
 
 
9
 
7
 
10
 
(1)
 
 
 
 
 
 
 
8
 
32
 
 
 
 
 
 
9
 
9
 
50
 
(2)
 
 
 
1
 
 
 
 
10
 
29
 
(2)
 
 
2
 
 
 
 
1
 
Total
 
270
 
(
5
)
 
5
 
8
 
3
 
2
 
1
 
31
 
 856Ambiguous computation smell
s 
are harmful and 
have 
caused data discrepancies
 
in real
-
life spreadsheets
.
 
 
6.3
 
D
iscussion
s
 
While the evaluation shows that 
our 
AmCheck
 
is 
promising for 
detect
ing
 
and 
repair
ing
 
ambiguous 
computation
 
smells
 
in real
-
life 
spreadsheets
, 
we discuss 
some of its 
limitations
.
 
6.3.1
 
False Negatives
 
F
alse 
negatives in detecting smelly cell arrays
 
are
 
mainly caused 
by
 
undetected 
cell array
s
. 
With help from 
finance 
officers
, w
e 
further
 
measured 
such undetected cell arrays 
in our case study.
 
For ea
ch spreadsheet, 
Table 
5
 
lists 
the 
number of detected 
cell 
arrays (
CA
)
 
and 
the 
number of undetected cell arrays (Undetected 
cell array
s). AmCheck misses 15.9
% (50
 
/
 
(270 
–
 
5 + 50)
) 
of all 
cell arrays 
in total
. 
The re
call
 
rate
 
of 
cell array extraction in 
A
m-
Check is 84.1% (
(270 
–
 
5) 
/
 
(270 
–
 
5 + 50)
). 
S
everal 
reasons 
caused such
 
false negatives
:
 
(1) 
Some c
ells reference
 
other
 
cells 
at
 
different 
row
s or 
column
s
 
(
D
RC)
; (2) 
Some cell arrays contain 
plain values only
 
(P
V
)
; (3) 
Some c
ell
 
array
s
 
have in
-
line space
 
(
INS
)
; (4) 
Some 
cell
 
arrays
 
contain constant cells without being 
labeled
 
with 
“
$
”
 
(a special annotation indicating 
a 
constant
 
cell
)
 
(
CC
)
; (5) 
Some cell
 
array
s
 
contain 
conditional 
formulas (CON)
; 
(6) Some c
ells
 
reference 
other 
cells in 
different
 
spreadsheet
s 
(
DS
)
.
 
AmCheck needs 
extension
s
 
for handling these cases
.
 
6.3.2
 
Threats to Validity
 
One
 
threat to internal validity of our evaluati
on is that we 
were 
unable 
to validate 
analysis 
results 
of spreadsheets in
 
the 
EUSES
 
corpus by the
ir
 
original users. As such, we validated the results 
by
 
ourselves 
partially and 
manually in due diligence. 
Another threat 
to external validity of 
our 
evaluation concerns the representativ
e-
ness of 
spreadsheets in 
the EUSES corpus
 
and 
collected
 
in 
our 
case study
. 
We chose 
the 
EUSES 
corpus 
because it is by far the 
largest co
rpus
 
that
 
has been 
wide
ly
 
used 
for evaluation by prev
i-
ous 
spreadsheet 
research studies
.
 
Spreadsheets collected in our 
case study are those used in practice and maintained by p
rofe
s-
sional finance 
officers
. We 
made best effort in choosing repr
e-
sentative and real
-
life
 
experimental subjects.
 
7.
 
RELATED WORK
 
In this section, we review related work in recent years.
 
Spreadsheet 
errors
.
 
Spreadsheet e
rrors
 
are common 
[27]
[28]
[29]
. 
They
 
can
 
cause serious financial loss
e
s
. 
Ambiguous computation 
smell
s 
may
 
not 
cause
 
errors
 
immediately 
but degrade 
spreadsheet 
quality 
gradually
. 
Spreadsheets suffer
ing
 
from
 
ambiguous comp
u-
tation smells contain 
unclear
 
computation
al
 
semantics
, which
 
make 
them 
difficult to maintain
 
in a correct way
.
 
Detecting faults in 
spreadsheets
.
 
Various
 
techniques 
have been 
proposed 
to detect 
faults in 
spreadsheet
s. UCheck 
[4
]
 
and 
d
ime
n-
sion 
inference
 
[7]
 
use 
the 
type system to check unit faults
 
and
 
dimension faults
, 
respectively. T
hey 
focus on 
whether 
units 
can 
be 
combined
 
c
orrectly
 
in
to one
 
cell.
 
Smellsheet Detective 
[9]
[10]
 
detect
s
 
s
tatistical 
s
mells
, t
ype 
s
mells
, c
ontent 
s
mells
 
and
 
f
unctio
n-
al 
d
ependenc
y
 
s
mells
. Hermans et al. proposed 
visualiz
ing
 
sprea
d-
sheets
 
by
 
dataflow graphs 
[17]
, and detected inter
-
worksheet 
smells in the
se
 
graphs 
[18]
. 
They
 
proposed 
detect
ing
 
smells 
from
 
data clone
s
 
[20]
 
and 
in 
spreadsheet formulas 
[19]
. 
In these pieces 
of work, 
Hermans et al.
’
s
 
[19]
 
and Smellsheet Detective 
[10]
 
f
o-
cus on 
syntactic
 
faults
, while our work focus on missing formula 
and inconsistent formula smells, which concern semantic faults
. 
Our work 
also detect
s
 
conformance error
s caused by 
ambiguous 
computation smell
s
.
 
I
ts scope is
 
thus 
orthogonal
 
to existing 
work
.
 
Program synthesis
.
 
Our work is based on component
-
based 
pr
o-
gram 
synthesis 
[14]
[21]
. 
Typically, e
nd u
sers should 
provide 
components and input
-
output 
pairs
 
for 
program synthesis
 
[21]
. 
Regarding our problem
, 
we automatically extract such comp
o-
nents and input
-
output pairs 
from spreadsheets and 
alleviate
 
their 
noises
. 
P
rogram synthesis 
has also been used for other purposes in 
spreadsheet research, e.g., 
string 
transformation
 
from examples 
[13]
, table 
transformation 
[15]
, 
and 
number transformation 
[32]
. 
In this paper, we apply program synthesis in a novel way
 
to
 
detect 
and 
repair
 
ambiguous computation smell
s
 
in spreadsheets by
 
r
e-
covering
 
hidden 
computation
al
 
semantics
.
 
Modeling and testing for s
preadsheet
s
.
 
Construction of rigorous 
models
 
for 
spreadsheets 
[1]
[8]
[16]
 
can 
help 
end 
users 
reduce 
chances of introducing 
ambiguous computation smell
s. Inferring 
such 
models from 
spreadsheets
 
can be challenging. Its effectiv
e-
ness
 
depends on correctness of spreadsheets, and 
ambiguous 
computation smell
s 
can reduce its 
precision.
 
Our work 
addresses 
the problem 
effectively 
by 
using
 
both heuristics and formula pa
t-
tern synthesis
. 
S
preads
heet
 
testing
 
[5]
[12]
[23]
 
is another 
interes
t-
ing
 
topic
, whose most challenge may be the lack of 
test 
oracle
s
.
 
O
ur 
work extracts partial 
computational semantics
 
from cell co
n-
tents
 
and 
recover
s
 
hidden formula
 
pattern
s
. 
It
 
does not require 
explicit 
test 
oracle
s
. 
Ambiguous 
computation smell
s may
 
also
 
mislead 
spreadsheet 
testing
, and
 
o
ur 
work 
can assist the testing by 
repair
ing smelly spreadsheets
.
 
Semantic 
faults
 
in software
.
 
Similar to 
smells in spreadsheets, 
s
emantic 
faults
 
are
 
also 
dominant root causes
 
of software failures
 
[24]
[33]
. 
Most semantic 
faults
 
require
 
domain knowledge to u
n-
derstand, detect and
 
repair
 
[24]
.
 
MUVI
 
[25]
 
and 
DefUse
 
[31]
 
can 
detect semantic 
faults
 
related to 
inconsistent updates
 
to 
correlated
 
multi
-
variables
 
and
 
data
fl
ow intentions
, respectively,
 
in software
. 
The
y rely on 
invariant mining
 
and 
detection
 
techniques
. Our 
work 
uses a 
different
 
approach by inferring 
hidden 
computational 
s
e-
mantics
 
by heuristics and program synthesis techniques
.
 
8.
 
CONCLUSION
 
In this paper, we 
study 
ambiguous computation smells
 
in sprea
d-
sheets
, which are caused 
by 
end 
users
’
 
ad
 
hoc modifications to 
spreadsheet 
cells 
that should stick 
to
 
certain
 
computational sema
n-
tics. 
We propose a
 
n
ovel
 
approach
, AmCheck,
 
to detect and repair 
ambiguous computation smells
 
by
 
inferring
 
formula pattern
s for 
smelly cell arrays in spreadsheets. 
This
 
also helps detect cha
llen
g-
ing 
conformance error
s
 
in spreadsheets
.
 
O
ur evaluation
 
with real
-
life spreadsheets reports that ambiguous computation smells are 
common and harmful
, 
and
 
end users 
do 
care 
about such
 
smells 
and 
conformance 
errors caused by such smells
,
 
and value A
m-
Chec
k for its ability of automatically detecting and repairing 
smelly spreadsheets
.
 
We have identified
 
several 
future research 
directions. First, 
detec
t-
ing smelly cell arrays 
can be improved 
by more precise 
cell array
 
extraction
 
and formula 
pattern 
inference
.
 
Second, 
AmCheck can 
be improved by implementing more features like handling cond
i-
tional formula patterns. Third, 
we 
plan to
 
conduct
 
more
 
real
-
life 
case studies
 
and
 
investigate 
mechanisms
 
to 
prevent
 
ambiguous 
computation smells
 
in spreadsheets
.
 
9.
 
ACKNOWLEDGM
ENTS
 
We sincerely thank
 
Chang Xu, 
Yepang Liu 
and Rongxin Wu 
for 
their
 
valuable 
comments and 
careful 
proofreading
. 
The work was 
supported
 
in part
 
by 
Research Grants Council (611811) of 
Hong 
Kong
,
 
and 
by 
National 
High Technology
 
Research & Develo
p-
ment
 
863 Program
 
(2012AA011204) 
and 
National Natural Sc
i-
ence Foundation (
61173005
, 
61100038) of China
.
 85710.
 
REFERENCES
 
[1]
 
R. Abraham and M. Erwig. Inferring templates from sprea
d-
sheets. In 
Proceedings of the 28th I
nternational Conference 
on Software Engineering (ICSE)
, pages 182
–
191. 2006.
 
[2]
 
R. Abraham and M. Erwig. AutoTest: A Tool for Automatic 
Test Case Generation in Spreadsheets. In 
IEEE Symposium 
on Visual Languages and Human
-
Centric Computing 
(VL/HCC)
, pages
 
43 
–
50. September 2006.
 
[3]
 
R. Abraham and M. Erwig. GoalDebug: A Spreadsheet D
e-
bugger for End Users. In 
Proceedings of the 29th Intern
a-
tional Conference on Software Engineering (ICSE)
, pages 
251
–
260. 2007.
 
[4]
 
R. Abraham and M. Erwig. UCheck: A spreadshe
et type 
checker for end users. 
J. Vis. Lang. Comput.
, 18(1):71
–
95, 
February 2007.
 
[5]
 
R. Abraham and M. Erwig. Mutation Operators for Sprea
d-
sheets. 
IEEE Trans. Softw. Eng.
, 35(1):94 
–
108, February 
2009.
 
[6]
 
M. Burnett and M. Erwig. Visually customizing inf
erence 
rules about apples and oranges. In 
IEEE Symposia on Human 
Centric Computing Languages and Environments (HCC)
, 
pages 140
–
148. 2002.
 
[7]
 
C. Chambers and M. Erwig. Automatic detection of dime
n-
sion errors in spreadsheets. 
J. Vis. Lang. Comput.
, 
20(4):269
–
283, August 2009.
 
[8]
 
J. Cunha, M. Erwig, and J. Saraiva. Automatically Inferring 
ClassSheet Models from Spreadsheets. In 
IEEE Symposium 
on Visual Languages and Human
-
Centric Computing 
(VL/HCC)
, pages 93
–
100. 2010.
 
[9]
 
J. Cunha, J.P. Fernandes, P
. Martins, J. Mendes, and J. Sara
i-
va. SmellSheet detective: A tool for detecting bad smells in 
spreadsheets. In 
IEEE Symposium on Visual Languages and 
Human
-
Centric Computing (VL/HCC)
, pages 243
–
244. 2012.
 
[10]
 
J. Cunha, J.P. Fernandes, H. Ribeiro, and J. 
Saraiva. Towards 
a Catalog of Spreadsheet Smells. In 
Computational Science 
and Its Applications
, pages 202
–
216. Springer Berlin Heide
l-
berg, 2012.
 
[11]
 
M. Fisher and G. Rothermel. The EUSES spreadsheet corpus: 
a shared resource for supporting experimentatio
n with 
spreadsheet dependability mechanisms. 
SIGSOFT Softw Eng 
Notes
, 30(4):1
–
5, May 2005.
 
[12]
 
G. Rothermel, L. Li, C. Dupuis, and M. Burnett. What you 
see is what you test: a methodology for testing form
-
based 
visual programs. In 
Proceedings of the Inter
national Confe
r-
ence on Software Engineering (ICSE)
, pages 198
–
207. April 
1998.
 
[13]
 
S. Gulwani. Automating string processing in spreadsheets 
using input
-
output examples. 
SIGPLAN
, 46(1):317
–
330, Ja
n-
uary 2011.
 
[14]
 
S. Gulwani, S. Jha, A. Tiwari, and R. Venka
tesan. Synthesis 
of loop
-
free programs. 
SIGPLAN
, 46(6):62
–
73, June 2011.
 
[15]
 
W.R. Harris and S. Gulwani. Spreadsheet table transfo
r-
mations from examples. 
SIGPLAN
, 46(6):317
–
328, June 
2011.
 
[16]
 
F. Hermans, M. Pinzger, and A. van Deursen. Automatically 
extracting class diagrams from spreadsheets. In 
Proceedings 
of the 24th European Conference on Object
-
Oriented Pr
o-
gramming (ECOOP)
, pages 52
–
75. Springer
-
Verlag, 2010.
 
[17]
 
F. Hermans, M. Pinzger, a
nd A. van Deursen. Supporting 
professional spreadsheet users by generating leveled dat
a-
flow diagrams. In 
Proceedings of the 33rd International 
Co
n
ference on Software Engineering (ICSE)
, pages 451
–
460. 
2011.
 
[18]
 
F. Hermans, M. Pinzger, and A. van Deursen. 
Detecting and 
visualizing inter
-
worksheet smells in spreadsheets. In 
Pr
o-
ceedings of the International Conference on Software Eng
i-
neering (ICSE)
, pages 441
–
451. 2012.
 
[19]
 
F. Hermans, M. Pinzger, and A.V. Deursen. 
Detecting 
Code 
Smells in Spreadsheet Formul
as. In 
Proceedings of the Inte
r-
national Conference on Software Maintenance (ICSM)
, pa
g-
es 409
–
418
.
 
2012.
 
[20]
 
F. Hermans, B. Sedee, M. Pinzger, and A. van Deursen. Data 
clone detection and visualization in spreadsheets. In 
Pr
o-
cee
d
ings of the International C
onference on Software Eng
i-
neering (ICSE)
, pages 292
–
301. 2013.
 
[21]
 
S. Jha, S. Gulwani, S.A. Seshia, and A. Tiwari. Oracle
-
guided component
-
based program synthesis. In 
ACM/IEEE 
32nd International Conference on Software Engineering 
(ICSE)
, pages 215
–
224. 20
10.
 
[22]
 
N. Jussien, G. Rochart, and X. Lorca. The CHOCO co
n-
straint programming solver. In 
CPAIOR workshop on Open
-
Source Software for Integer and Contraint Programming 
(OSSICP)
. 2008.
 
[23]
 
K.J. Rothermel, C.R. Cook, M.M. Burnett, J. Schonfeld, 
T.R.G. Gree
n, and G. Rothermel. WYSIWYT testing in the 
spreadsheet paradigm: an empirical evaluation. In 
Procee
d-
ings of the International Conference on Software Enginee
r-
ing (ICSE)
, pages 230 
–
239. 2000.
 
[24]
 
L. Lu, A.C. Arpaci
-
Dusseau, R.H. Arpaci
-
Dusseau, and S. 
Lu.
 
A Study of Linux File System Evolution. In 
Proceedings 
of the 11th USENIX Conference on File and Storage Tec
h-
nologies (FAST)
. 2013.
 
[25]
 
S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R.A. Popa, and 
Y. Zhou. MUVI: automatically inferring multi
-
variable a
c-
cess correlations and detecting related semantic and concu
r-
rency bugs. In 
Proceedings of twenty
-
first ACM SIGOPS 
symposium on Operating systems principles (SOSP)
, pages 
103
–
116. 2007.
 
[26]
 
R. Panko. Facing the problem of spreadsheet errors. 
Decis. 
Line
, 37
(5)2006.
 
[27]
 
R.R. Panko and S. Aurigemma. Revising the Panko
–
Halverson taxonomy of spreadsheet errors. 
Decis. Support 
Syst.
, 49(2):235
–
244, May 2010.
 
[28]
 
S.G. Powell, K.R. Baker, and B. Lawson. A critical review of 
the literature on spreadsheet errors. 
D
ecis. Support Syst.
, 
46(1):128
–
138, December 2008.
 
[29]
 
K. Rajalingham, D.R. Chadwick, and B. Knight. Classific
a-
tion of Spreadsheet Errors. 
CoRR
, 2008.
 
[30]
 
J. Reichwein, G. Rothermel, and M. Burnett. Slicing sprea
d-
sheets: an integrated methodology for spr
eadsheet testing and 
debugging. 
SIGPLAN
, 35(1):25
–
38, December 1999.
 
[31]
 
Y. Shi, S. Park, Z. Yin, S. Lu, Y. Zhou, W. Chen, and W. 
Zheng. Do I use the wrong definition?: DefUse: definition
-
use invariants for detecting concurrency and sequential bugs. 
In 
Pr
oceedings of the ACM international conference on O
b-
ject oriented programming systems languages and applic
a-
tions (OOPSLA)
, pages 160
–
174. 2010.
 
[32]
 
R. Singh and S. Gulwani. Synthesizing Number Transfo
r-
mations from Input
-
Output Examples. In 
Computer Aided 
V
erification (CAV)
, pages 634
–
651. January 2012.
 
[33]
 
L. Tan, C. Liu, Z. Li, X. Wang, Y. Zhou, and C. Zhai. Bug 
characteristics in open source software. 
Empir. Softw. 
Eng.
, :1
–
41, 2013.
 
[34]
 
J. Walkenbach. 
Excel 2013 Power Programming with VBA
. 
Wiley. com, 
2013.
 
[35]
 
How to use the Auto Fill Options button in Excel. 
http://support.microsoft.com/kb/291359 .
 858