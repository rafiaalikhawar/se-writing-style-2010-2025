Discovering Refactoring Opportunities
in Cascading Style Sheets
Davood Mazinanian, Nikolaos Tsantalis
Computer Science and Software Engineering
Concordia University
Montreal, Canada
{d_mazina, tsantalis}@cse.concordia.caAli Mesbah
Electrical and Computer Engineering
University of British Columbia
Vancouver, Canada
amesbah@ece.ubc.ca
ABSTRACT
Cascading Style Sheets (CSS) is a language used for describ-
ing the look and formatting of HTML documents. CSS has
been widely adopted in web and mobile development prac-
tice, since it enables a clean separation of content from pre-
sentation. The language exhibits complex features, such as
inheritance, cascading and specicity, which make CSS code
hard to maintain. Therefore, it is important to nd ways
to improve the maintainability of CSS code. In this paper,
we propose an automated approach to remove duplication in
CSS code. More specically, we have developed a technique
that detects three types of CSS declaration duplication and
recommends refactoring opportunities to eliminate those du-
plications. Our approach uses preconditions that ensure the
application of a refactoring will preserve the original docu-
ment styling. We evaluate our technique on 38 real-world
web systems and 91 CSS les, in total. Our ndings show
that duplication in CSS code is widely prevalent. Addition-
ally, there is a signicant number of presentation-preserving
refactoring opportunities that can reduce the size of the CSS
les and increase the maintainability of the code.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement
Keywords
Cascading style sheets, refactoring, duplication
1. INTRODUCTION
Cascading Style Sheets (CSS) [34] is a language for den-
ing the presentation semantics of web documents. CSS is
widely used in today's web development { over 90% of web
developers use CSS [23] in 90% of the web sites [33]. CSS
is also increasingly used in mobile app development through
frameworks (e.g., PhoneGap, IBM Worklight) that generate
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proÔ¨Åt or commercial advantage and that copies
bear this notice and the full citation on the Ô¨Årst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc
permission and/or a fee.
FSE ‚Äô14, November 16‚Äì22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.hybrid mobile apps. As a result, CSS has become an impor-
tant language with applications in many dierent domains.
While CSS has a relatively simple syntax, some of its com-
plex features, such as inheritance, cascading, and specicity
[15, 34], inherently make both the development and main-
tenance of CSS code cumbersome tasks [19] for developers.
Furthermore, CSS development is far from a rigorous and
disciplined process due to the lack of established design prin-
ciples and eective tool support [9]. One instance of undis-
ciplined development is the denition of new CSS rules by
copying and modifying existing code instead of reusing al-
ready dened ones.
There is empirical evidence that duplicated code in soft-
ware systems developed with procedural or object-oriented
languages is associated with increased maintenance eort
[16], higher error-proneness [11], and higher instability [22]
in terms of change frequency and recency. We believe that
the development and maintenance of CSS code is also sub-
ject to the same problems caused by code duplication. More-
over, the problem of duplication might even be more intense
in CSS code, because the CSS language lacks many features
available in other programming paradigms that could enable
code reuse. For instance, there is no notion of variables and
functions in CSS to build reusable blocks of code.
In addition, CSS code has to be transferred over the net-
work from a server to many clients. Extensive code dupli-
cation increases the size of the transferred data, resulting in
a large network load overhead. Once on the client side, the
CSS code has to be processed by the web browser. Extensive
code duplication increases the size of the CSS code that has
to be processed by the browser, resulting in a computational
overhead that might be signicant taking into account the
limited computation, memory, and power resources available
in mobile devices. Previous studies [21] have shown that the
visual layout of web pages, performed by analyzing the CSS
code, consumes 40{70% of the average processing time of
the browser.
In this paper, we propose an automated technique to (1)
analyze and detect various types of CSS duplication, and (2)
discover and recommend refactoring opportunities to erad-
icate duplicated CSS code. This work makes the following
main contributions:
1. We dene various types of duplication in CSS code and
propose a technique for the detection of duplication in-
stances.
2. We present a recommendation technique for refactoring
opportunities that can eliminate CSS code duplication.
Additionally, we provide a ranking mechanism based onthe size reduction that can be potentially achieved by
each suggested refactoring to help CSS developers prior-
itize their maintenance eorts by focusing on the refac-
torings with higher impact.
3. We describe preconditions that preserve the CSS styling
after the application of a refactoring.
4. We perform an empirical study to assess the ecacy of
our approach using 38 real-world web sites making use of
91 CSS les in total.
Our results show that the extent of duplication in CSS
code is indeed very intense ranging from 40% to 90% for the
vast majority of the examined CSS les. On average, we
found 165 refactoring opportunities in the examined CSS
les, out of which 62 could be applied by preserving the
styling of the web pages. Finally, the average size reduction
achieved by applying only presentation-preserving refactor-
ings was 8%, while the highest reduction was 35%.
2. THE CSS LANGUAGE
CSS was one of the rst standards approved by the World
Wide Web Consortium (W3C) [34] along with the markup
language HTML. CSS enables separation of concerns by dis-
connecting styling code from markup. Consequently, the
same style sheet can be applied to dierent markups en-
abling the reuse of styling code. In this paper, we call the
HTML pages on which the styles are applied as target doc-
uments . Style sheets can be written inside the target doc-
uments, or in separate external CSS les which are linked
to the target documents. CSS les consist of a set of CSS
rules, with a syntax shown in Figure 1.
selector  {
    property_1 : value_1 ;
    property_2 : value_2 ;
    ...
    property_n : value_n [;]
}
Figure 1: CSS rules syntax.
The selector part in the CSS rule denes the elements
of the target document on which the style rules should be
applied. For example, a Pselector selects every paragraph
element <p>in the document. The property: value pair
is called a style declaration . The declarations dene style
values for the specied properties of the element selected
by the corresponding selector. For example, the declaration
color: blue; will apply a blue color to the text of the se-
lected element. There may be multiple style declarations in
every selector.
2.1 CSS Selectors
It is possible to set an ID for elements in the target doc-
ument, using the ID attribute. For example, the HTML
tag<div id="toolbar"/> corresponds to a divelement for
which the ID is equal to "toolbar" . The #toolbar CSS se-
lector, which is called an ID selector , can be used to select
the element with this ID.
Also, a group of declarations could be dened as a class
in CSS. It is then possible to apply the same class to many
dierent elements thus avoiding the duplication of declara-
tions. Figure 2 shows an example of a class selector.
There is also the possibility of grouping dierent selectors
in CSS, using the \," character. For instance, if we want to
HTML CSS
<div class ="class1 ">
    content
</div>
<span class ="class1 ">
    content
</span>.class1  {
    color : red;
    font : 10pt tahoma ;
}Figure 2: Class selectors.
apply the same styles to all h1and h2HTML elements, we
could use the h1, h2 { /* declarations */ } CSS rule.
We can also add attribute conditions to a selector. If se-
lector Sselects a set of elements S, a selector of the format
S[attr operator value] selects the subset elements of S
for which, in the target document, attribute attr is dened
and set to a substring of value . The operator denes the
condition for the substring [34]. For example, a[target]
selects all <a>elements that have the target attribute set
to any value, and img[src $= ".png"] selects all <img> ele-
ments that have the\.png"sux in their srcattribute value.
Pseudo classes can be used to lter the elements selected
by a given selector. For example, :not(div) selects all
elements except for divelements. There are also struc-
tural pseudo classes , such as tr:nth-child(2n+1) which se-
lects every odd row in every table of the target document.
Pseudo-elements create abstractions about elements in the
target document, beyond those specied by the HTML stan-
dards [34]. The p::first-line selector, for example, selects
only the rst line of the text inside every <p>element.
Finally, we can combine various selectors to achieve more
specic selectors, using dierent combinators . Assuming we
have two selectors A and B, we can combine them as follows:
A B (descendant combinator) selects all elements selec-
ted by B, which are descendants of the elements se-
lected by A.
A>B (child combinator) selects all elements selected
by B, which are direct children of the elements se-
lected by A.
AB (general sibling combinator) selects all elemen-
ts selected by B, which have an element selected by A
as a sibling.
A + B (adjacent sibling combinator) selects all eleme-
nts selected by B, which are directly preceded by a
sibling element selected by A.
2.2 Inheritance, Cascading, and SpeciÔ¨Åcity
Elements in the target document are organized in a hi-
erarchical manner. For some specic element properties,
CSS supports inheritance in values by taking advantage of
this hierarchical structure. For example, if we apply color:
blue; to the <body> element, all child elements of the <body>
tag will be styled with the blue color.
It is possible to have dierent CSS rules that select the
same HTML elements. If these selectors assign values to
the same properties, the web browser can only apply one
of the property values to the selected elements. In such
cases, the web browser follows the cascading origin rules .
Based on these rules, the authored style rules (i.e., the rules
written by the web application developer and linked to the
target document) will override the user style rules (i.e., the
rules that the reader of a web site might have dened in the
browser). Similarly, user style rules override the browser's
default style rules [34]. In the case that the origin of theselectors is the same (e.g., the conicting selectors are in
the same CSS le), the specicity determines the \winning"
selector, i.e., the more specic selector has priority over the
less specic ones [34]. If the origin and the specicity is
the same for two selectors, the position of the selectors in
the CSS le determines the winning selector (i.e., the last
selector overrides the previous ones). It is also possible to
add the !important annotation at the end of a declaration
to allow for a selector to bypass the specicity rules and be
always applied.
3. DUPLICATION IN CSS
Dierent types of duplication have been dened for pro-
cedural and object-oriented code [28] based on the textual
or the functional similarity of two code fragments. The code
duplication problem is expected to be more potent in CSS
due to the lack of variables and functions that could be used
to build reusable blocks of code. As a result, many common
style declarations have to be repeated in multiple selectors.
3.1 Duplication Types
In this work, we focus on duplicated CSS declarations,
which can only be avoided by changing the CSS code. Ad-
ditionally, by eliminating this kind of duplication, we can
reduce the size of the CSS code that has to transferred over
the network and be maintained in the future. Therefore, we
dene three dierent types of duplication at the declaration
level in this section.


	Type I :Declarations having lexically identical values for
given properties .
An extreme example of type I duplication can be seen in
Figure 3, which is taken from the main CSS le of Gmail's
inbox page. In this le, there are 23 declarations that are
repeated in three selectors. Figure 3 shows only a subset of
these declarations for two of the selectors.
.z-b-Vn {
nnnn-webkit-box-shadow :n
nnnnnnn0n1pxn0nrgba(0,n0,n0,n.05) ;
nnnnbox-shadow :n
nnnnnnn0n1pxn0nrgba(0,n0,n0,n.05) ;
nnnnbackground-color :nffff ;
nnnncolor :nf404040 ;n
nnnncursor :ndefault ;
nnnnfont-size :n11px ;
nnnnfont-weight :nbold ;
nnnntext-align :ncenter ;
nnnnwhite-space :nnowrap ;
nnnnborder :n1pxnsolidntransparent ;
nnnnborder-radius :n2px;
nnnn...
}.z-b-G n{
nnnn-webkit-box-shadow :n
nnnnnnnn0n1pxn0nrgba(0,n0,n0,n.05) ;
nnnnbox-shadow :n
nnnnnnnn0n1pxn0nrgba(0,n0,n0,n.05) ;
nnnnbackground-color :nffff ;
nnnncolor :nf404040 ;
nnnncursor :ndefault ;
nnnnfont-size :n11px ;
nnnnfont-weight :nbold ;
nnnntext-align :ncenter ;
nnnnwhite-space :nnowrap ;
nnnnborder :n1pxnsolidntransparent ;
nnnnborder-radius :n2px;
nnnn...
}
Figure 3: Type I duplication in Gmail's CSS.
Note that the denition of type I duplication considers
only the equality of the property values and disregards the
value order . For instance, consider the two border decla-
rations in Figure 3. If one of them was dened as border:
transparent solid 1px (i.e., same values in dierent or-
der), we would still consider them as an instance of type
I duplication, because based on the CSS specication, the
browser will interpret both declarations in the same way.



	Type II :Declarations having equivalent values for given
properties .
In CSS, we may have the same values for properties withalternative representations. Font size, color, length, angle
and frequency values are representative cases. For instance,
Table 1 shows alternative representations for the same color.
We consider all these dierent representation values as equiv-
alent values.
Table 1: Dierent representations for \Violet" color.
Representation Value
HTML Named Color Violet
Hexadecimal #EE82EE
RGB rgb(238, 130, 238)
RGBA rgba(238, 130, 238, 1)
HSL hsl(300, 76%, 72%)
HSLA hsla(300, 76%, 72%, 1)
If two or more declarations have equivalent values for the
same properties, we consider them as an instance of type II
duplication. In Figure 5a, we can see an example of type II
duplication in the CSS le of Gmail's inbox page. Note that
the declarations with color property are duplicated.
In addition, there are some default values for certain prop-
erties, which are applied when explicit values are missing.
For example, based on the CSS specication, the declara-
tion padding: 2px 4px 2px 4px; can be also written in a
shorter version as padding: 2px 4px; with the same eect.
Such cases are also considered as equivalent declarations and
thus constitute instances of type II duplication.



	Type III :A set of individual-property declarations is
equivalent with a shorthand-property declaration .
Some CSS properties, such as margin ,padding , and
background are called shorthand properties . With these
properties, we can dene values for a set of properties in a
single declaration . For instance, the margin shorthand prop-
erty could be used in order to dene values for margin-top ,
margin-right ,margin-bottom and margin-left , as shown
in Figure 4.
margin-top : 3px;
margin-right : 4px;
margin-bottom : 2px;
margin-left : 1px;margin:  3px 4px 2px 1px ;
Figure 4: Shorthand and individual declarations
If a selector contains a set of individual declarations, which
is equivalent to a shorthand declaration of another selector,
we consider those declarations as an instance of type III
duplication. Figure 5b, shows an example of type III dupli-
cation in the CSS le of the Gmail's inbox page.
.fJ {
    ...
    color : white ;
    ...
}
.Ik {
    ...
    color : #fff ;
    ...
}
(a) Type II
.sG0wIf z{
zzzzborder-bottom-color :z#e5e5e5 ;
zzzzborder-bottom-style :zsolid ;
zzzzborder-bottom-width :z1px
}
bodyz.azewNz {z
zzzz...
zzzzborder-bottom :z1pxzsolidz#e5e5e5 ;
zzzz...
} (b) Type III
Figure 5: Declaration duplication in Gmail's CSS3.2 Eliminating Duplications
The aforementioned types of duplication can be elimi-
nated directly in CSS code without changing the target doc-
uments by extracting a grouping selector. If a set Dof
declarations is duplicated (in the form of type I, II, III du-
plication) in a set of selectors S1; S2; :::; S n, we can create a
new selector for the group S1; S2; :::; S nand move Dto this
new selector. For instance, the CSS code snippet on the left
side of Figure 6 could be refactored as shown on the right
side of Figure 6.
.Jvq{
qqqqfont-size :q0;
qqqqheight :q100N ;
qqqqleft :q53px ;
qqqqposition :qabsolute ;
qqqqright :q35px ;
qqqqtop :q0
}
.qibgmf q{
qqqqfont-size :q0;
qqqqheight :q100N ;
qqqqleft :q53px ;
qqqqposition :qabsolute ;
qqqqright :q35px ;
qqqqtop :q0;
qqqqwhite-space :qnowrap
}.Jv,q.qibgmf q{
qqqqfont-size :q0;
qqqqheight :q100N ;
qqqqleft :q53px ;
qqqqposition :qabsolute ;
qqqqright :q35px ;
qqqqtop :q0
}
.qibgmf q{
qqqqwhite-space :qnowrap
}Newqselectorqformedqbyqgroupingqtwoq
selectorsqusingqcomma
Non-duplicatedqdeclarationqwillqremainqinqitsqoriginalq
selector.qTheqw.Jvwqselectorqisqremovedqsinceqallqitsq
declarationsqareqnowqinqtheqnewqgroupingqselector.Duplicated
declarations
areqgroupedBefore After
Figure 6: Grouping selectors to remove duplication.
Another possible solution, based again on grouping, is to
create a common class for the repeated declarations and as-
sign that class to the target elements. However, this solution
requires also to update the target documents, so that they
make use of the newly dened class.
4. METHOD
Our method for the detection of duplication in CSS and
the extraction of refactoring opportunities is divided in four
main steps discussed in the following subsections.
4.1 Abstract Model Generation
To look for duplications, we rst need to parse all the
CSS code of a given web application. In order to support all
available CSS standards, we have adapted the W3C Flute
Parser, so that it conforms with CSS3 specications [34].
Our method then analyzes the code and generates an in-
stance of the abstract model shown in Figure 7, which rep-
resents a high-level structure of the application's CSS code.
Selector StyleSheet
BaseSelector
SimpleSelector CombinatorMediumType
@media3print1..* 1
Declaration
text-align: 3center
ShorthandDeclaration
margin: 30px32pxGroupingSelector
p,3a,3h1
.s13.s2
.s13>3.s2
.s13~3.s2
.s13+3.s2fID
.class
:nth-child(3n-5)
::first-letter
:not(p)0..121..* 1
1
1..*
1..* 0..1
Figure 7: CSS Model
As shown in Figure 7, every style sheet may be bound to
some Medium type . This identies the target presentationmedium for which the style sheet is dened. For instance,
one may distinguish styles for printing and displaying in a
mobile device [34]. It is also possible to dene the same
selectors for dierent media types within a given style sheet.
In this model, a BaseSelector represents selectors that
do not perform grouping. A SimpleSelector represents type
selectors or the universal selector (*selector, which selects
every element). The class SimpleSelector has special at-
tributes for specifying properties like the element ID, class
identier, pseudo class, pseudo element, and attribute con-
ditions. Finally, a Combinator represents combinator selec-
tors, which can be formed by combining two BaseSelectors .
Examples of each of these selectors can be seen in Figure 7.
4.2 Preprocessing
The detection of Type I duplications does not require any
preprocessing. However, to facilitate the detection of type
II and III duplication instances, we perform three separate
preprocessing steps.
Normalization of property values. In this step, we re-
place values that can be expressed in dierent formats or
units (e.g., colors and dimensions) with a common reference
format or unit. For example, every color in named, hexadec-
imal, or HSL format (see Table 1) is replaced with its equiva-
lentrgba() value. Every dimension specied in centimeters,
inches, or points is converted to its equivalent pixel value.
All applied conversions are based on the guidelines provided
by the CSS specication [32]. Replacing values with a com-
mon representation is known as normalization and has been
used in traditional code clone detection techniques for nd-
ing clones with dierences in identiers, literals, and types
[12, 29]. Our motivation is to nd declarations using alter-
native formats or units for the same property value. Such
cases constitute type II duplication instances.
Addition of missing default values. As we discussed in
Section 3, CSS developers sometimes omit values for some
of the multi-valued properties, in order to have shorter dec-
larations. In this step, we have some predened rules based
on the CSS specication [32] that add the implied missing
values to the properties in the model. For instance, margin
property should normally have 4 values. We enrich the dec-
laration margin: 2px 4px with the two missing implied val-
ues as margin: 2px 4px 2px 4px . This allows the compari-
son of declarations based on a complete set of explicit values
enabling the detection of type II duplication instances.
Virtual shorthand declarations. Detecting type III du-
plication instances requires the comparison between short-
hand declarations in one selector and an equivalent set of
individual declarations in another selector. To facilitate this
task, we add \virtual" shorthand declarations to the model.
We examine the declarations of every selector to nd sets
of individual declarations that can be expressed as equiva-
lent shorthand declarations. For every set of such individ-
ual declarations, we generate the corresponding shorthand
declaration, and add it as a \virtual" declaration to the cor-
responding selector in the model. These virtual shorthand
declarations will be compared with \real" shorthand decla-
rations to detect type III duplication instances.
4.3 Duplication Detection
Duplication instances can be found by comparing every
possible pair of declarations in the CSS model and checkingAlgorithm 1: Detection of type I, II & III clones
Input : A preprocessed style sheet styleSheet
Output :allClones including Type I, II & III clones
mediumTypes all medium types in the styleSheet
allClones ?
foreach m2mediumTypes do
D all declarations in m
clones m ?
fori 1tojDjdo
clone Di
forj i+ 1tojDjdo
ifidentical( Di,Dj)_equivalent( Di,Dj)then
clone clone[Dj
end
end
ifjclonej>1then
merged false
foreach clone k2clones mdo
ifclone k\clone6=?then
clone k clone k[clone
merged true
end
end
ifnot merged then
clones m clones m[clone
end
end
end
allClones allClones[clones m
end
whether they are equal (for type I) or equivalent (for type
II and III). The notions of equality and equivalence were
discussed in Section 3. Note that in our approach we con-
sider the declarations present in the CSS model as they have
been formed after the preprocessing steps to allow for the
detection of type II and III duplication instances.
Our detection approach is summarized in Algorithm 1.
The algorithm receives as input a preprocessed CSS style
sheet and returns a set of clones , where each clone is a set
of equal or equivalent declarations, D=fd1; d2; :::; d ng, and
each declaration belongs to a selector si2S=fs1; s2; :::; s ng
of the analyzed CSS style sheet.
Figure 8 depicts an example of a style sheet and the corre-
sponding clones extracted from the application of Algorithm
1. The rst two clones contain instances of type II dupli-
cation, while the last clone contains an instance of type III
duplication.
.class1 3{
3333color :3blue ;
3333font-weight :3bold ;
}
.class2 3{
3333color :3y00F ;
3333font-weight :3bold ;
3333border :3solid31px3yd3d3d3 ;
}
.class3 3{
3333font-weight :3700;
3333border :3solid33px3red ;
3333float :3left ;
}
.class4 3{
3333border-style :3solid ;
3333border-color :3LightGray ;
3333border-width :31px;
}Style Sheet Clones
[color:3blue]
[color:3y00F]
[font-weight:3bold]
[font-weight:3bold]
[font-weight:3700]
[border:3solid31px3yD3D3D3]
border-style:3solid
border-color:3LightGray
border-width:31px{font-weight}
{border}{color}
Figure 8: Clones extracted from a style sheet4.4 Extracting Refactoring Opportunities
Aclone , as dened in subsection 4.3, can be directly refac-
tored by extracting a single declaration di2Dto a new
selector, which groups all selectors in S, and then remov-
ing all declarations in Dfrom the original selectors they
belong to. The refactored version of the CSS code will con-
tainjDj 1 less declarations, but should have exactly the
same eect in terms of the styles applied to the selected el-
ements. As such, the larger the clone (i.e., the cardinality
ofD), the more benecial the corresponding refactoring is,
since a larger number of declarations will be eliminated by
the application of the refactoring.
The detected clones constitute the \building blocks" for
extracting more advanced and higher impact refactoring op-
portunities. For instance, there may exist selectors that have
multiple declarations in common (i.e., selectors involved in
multiple clones). A set of common declarations shared among
a group of selectors constitutes a clone set . In that case, all
declarations in the clone set could be extracted into a single
grouping selector (or a class selector) reducing signicantly
the repetition of declarations. Figure 6 in subsection 3.2
presents an example of such a case. In general, the more
clones are common in a larger set of selectors, the higher
the impact of the corresponding refactoring opportunity in
the reduction of repeated declarations.
In this work, we use a data mining metaphor to extract
clone sets as refactoring opportunities from the initially de-
tected declaration-level clones. Let us assume that the style
sheet is a transactional dataset, in which every selector si
is a transaction, and the clones corresponding to the decla-
rations of siare the items of transaction si. Based on this
mapping, Figure 9 shows the resulting dataset for the style
sheet of Figure 8. Note that the clones are sorted according
to their size (i.e., the number of duplication occurrences).
Transactions
(Selectors)Items
(Corresponding clones)
.class2
.class3
.class4.class1 {color} {font-weight}
{border} {color} {font-weight}
{font-weight}
{border}
Figure 9: Dataset for the style sheet of Figure 8
In the data mining domain, a set of items which is re-
peated in dierent transactions is called an itemset . If an
itemset is repeated in more than a certain number of transac-
tions, which is called the minimum support count , the item-
set is known to be frequent . Our goal is to extract all fre-
quent itemsets with a minimum support equal to 2 (i.e., the
minimum size for a duplication instance), because a frequent
itemset in our case represents a clone set that is repeated in
more than one selector. Therefore, every frequent itemset is
a potential grouping refactoring opportunity .
In our method, we use the FP-Growth association rule
mining algorithm [10], which nds the frequent itemsets us-
ing a structure called frequent-pattern tree (FP-Tree) [31].
The FP-Tree is essentially a compact representation of the
dataset, since every itemset association within the dataset
is mapped onto a path in the FP-Tree. Figure 10 displays
the FP-Tree for the dataset of Figure 9.
The FP-Tree has a header table , which includes all dis-
tinct items that exist in the FP-Tree. The items in this ta-
ble are sorted in descending order based on their support
count. There is a link between every item in this table
to the rst occurrence of that item in the FP-Tree (rep-Header Table
{border}{color}{font-weight}{border} {font-weight}1 3NULL
{color}2
{border}1Figure 10: FP-Tree for the dataset of Figure 9
resented as a dotted arrow from the header table to the
nodes of the FP-Tree in Figure 10). To enhance the traver-
sal of an item in the header table to all nodes containing
that item, nodes that contain the same item are also linked
(e.g., the border nodes in the FP-Tree). The number next
to a node represents the number of transactions (selectors in
our case) involved in the portion of the path from this node
to the root of the tree. For example, the path from node
color to the root represents that there are two selectors
that contain both items color and font-weight (i.e., selec-
tors .class1 and .class2 ). The path from node border
nested under node font-weight to the root represents that
there is only one selector that contains both items border
and font-weight (i.e., selector .class2 ). Finally, the path
from node font-weight to the root represents that there are
three selectors that contain item font-weight .
Once the FP-Tree is constructed, the FP-Growth algo-
rithm generates all frequent itemsets with the minimum sup-
port specied as input. Figure 11 shows all frequent itemsets
(i.e., grouping refactoring opportunities) generated with a
minimum support value equal to 2.
Frequent Itemsets/
Refactoring OpportunitiesInvolved Selectors
.class1, .class2
.class1, .class2
.class1, .class2, .class3.class2, .class4 [{border}]
[{color}]
[{color}, {font-weight}]
[{font-weight}]1
2
3
4
Figure 11: Output of the FP-Growth algorithm for
the style sheet of Figure 8
In the refactoring scheduling literature, two refactorings
are considered as conicting if they have a mutually exclu-
sive relationship [18], i.e., the application of the rst refac-
toring disables the application of the second refactoring and
vice versa. Within the context of CSS, two refactoring op-
portunities are conicting if their application aects a com-
mon subset of declarations. For instance, in Figure 11, if
the last refactoring opportunity is applied, the third one
becomes infeasible and vice versa, because these two refac-
toring opportunities aect two common font-weight dec-
larations. In the same manner, the second and third refac-
toring opportunities are also conicting, because they aect
two common color declarations. However, in that case, the
third refactoring opportunity subsumes the second one, since
the set of declarations aected by the latter is a subset of the
declarations aected by the former. Our approach lters out
subsumed refactoring opportunities, if the ones subsuming
them can be safely applied (Section 4.6). For the problem of
conicting refactoring opportunities, we provide a ranking
mechanism explained in Section 4.5.
4.5 Ranking Refactoring Opportunities
Although a refactoring operation aects several quality
aspects of the code, such as understandability, maintain-ability, and extensibility, in this work we focus on the size
of the CSS code, because size is directly associated with the
other aforementioned higher-level quality attributes (in gen-
eral, a code with small size can be more easily maintained).
Hence, in order to prioritize the refactoring opportunities
and allow developers to focus on the most important ones,
we dene a ranking formula based on the number of charac-
ters that can be removed from the CSS code by applying a
given refactoring opportunity.
LetRDrbe the set of duplicated declarations that will
be removed from the style sheet by applying the refactor-
ing opportunity r,Srbe the set of selectors that contain
the duplicated declarations of set RDr(i.e., the selectors
that will be grouped after applying r), and ADrbe the set
of declarations that will be added to the new grouping se-
lector. It should be noted that ADrcontains the declara-
tion with the minimum number of characters for each set of
equal/equivalent declarations within RDr. The size reduc-
tion (SR) achieved by refactoring opportunity ris calculated
as follows:
SR(r) =X
d2RDrc(d) X
s2Src(s) X
d2ADrc(d) (1)
where the function ccounts the number of characters of the
declaration (or selector) passed as an argument. The higher
theSR(r) value, the higher the impact of rwill be on re-
ducing the size of the CSS code. A negative SR(r) value
indicates that the size of the CSS code will increase after the
application of r. A negative value is possible if the textual
size of the selectors being grouped is larger than the tex-
tual size of the declarations being removed. Of course, this
would not be an issue if the duplicated declarations were
placed under a newly dened class; however, this solution
would require to update the target documents to make use
of the new class. As mentioned before, in this work we aim
to avoid modications of the target document, i.e., all refac-
torings should be merely in the style sheets. Consequently,
when size reduction is the objective, the refactoring oppor-
tunities should be applied in a descending order of SR value
excluding those having a negative SR value.
Based on Equation 1, the size reduction values for the
four refactoring opportunities shown in Figure 11 are 46,
-3, 14, and 13 characters, respectively. The second refactor-
ing opportunity would actually increase the size of the CSS
code, if it was applied. The rst refactoring opportunity
corresponds to the highest size reduction, and the CSS code
resulting after its application is shown in Figure 12b (the
new grouping selector is appended to the end of the le).
4.6 Preserving Order Dependencies
Behavior preservation is a crucial property of refactoring
[25]. The refactored program should have exactly the same
functionality as the original program. Within the context
of CSS, the notion of behavior corresponds to the presenta-
tion of the target documents (i.e., the property values that
are eventually applied to the target document elements).
Therefore, a refactoring can be considered as valid, if its ap-
plication preserves the presentation of the target documents.
Let us assume that the CSS code of Figure 12a is applied
to the target document shown in Figure 13a. As we can
observe from Figure 13a, the second divelement uses the
style rules from both .class2 and .class3 . As we can see
from Figure 12a, the declaration of the border property in
.class3 overrides the corresponding declaration in .class2.class1 3{
3333color :3blue ;
3333font-weight :3bold ;
}
.class2 3{
3333color :3y00F ;
3333font-weight :3bold ;
3333border :3solid31px3yd3d3d3 ;
}
.class3 3{
3333font-weight :3700;
3333border :3solid33px3red ;
3333float :3left ;
}
.class4 3{
3333border-style :3solid ;
3333border-color :3LightGray ;
3333border-width :31px;
}1
2(a)
.class1 x{x
xxxxcolor :xblue ;x
xxxxfont-weight :xbold ;x
}x
.class2 x{x
xxxxcolor :x#00f ;x
xxxxfont-weight :xbold ;
}x
.class3 x{x
xxxxfont-weight :x700;
xxxxborder :xsolidx3pxxred ;xx
xxxxfloat :xleft ;x
}x
.class2,x.class4 x{x
xxxxborder :xsolidx1pxx#d3d3d3 ;x
}x1
2 (b)
Figure 12: (a) Order dependencies in the original
CSS le, (b) Order dependencies after refactoring
and as a result, the second divelement is styled with a red
color border as shown in Figure 13b. Now, let us assume
that the rst refactoring opportunity shown in Figure 11 is
applied to the CSS code of Figure 12a resulting in the CSS
code of Figure 12b. In the refactored CSS code, the dec-
laration of the border property in the extracted grouping
selector .class2,.class4 overrides the corresponding dec-
laration in .class3 . As a result, the second divelement is
no longer styled with a red color border as shown in Figure
13c, which is a clear indication that the applied refactoring
did not preserve the presentation of the target document.
This inconsistency is caused by the inversion of the origi-
naloverriding relationship between selectors .class2 and
.class3 after the application of the refactoring.
We dene an order dependency from selector sicontaining
declaration dkto selector sjcontaining declaration dldue
to property p, denoted ashsi; dkip  !hsj; dli, i:
a) selectors siandsjselect at least one common element
having property pin the target document,
b) declarations dkanddlset a value to property pand
have the same importance (i.e., both or none of the
declarations use the !imporant rule),
c) declaration dkprecedes dlin the style sheet,
d) selectors siandsjhave the same specicity.
To ensure that the presentation of the target documents is
preserved, we dene the following precondition :



	The extraction of a grouping selector should preserve all
order dependencies among the selectors of the style sheet.
The problem of nding an appropriate position for the ex-
tracted selector gin the style sheet can be expressed as a
Constraint Satisfaction Problem (CSP) dened as:
Variables : the positions of the selectors involved in order
dependencies including g.
Domains : the domain for each variable is the set of values
f1;2; :::; N + 1g, where Nis the number of selectors in the
original style sheet.
Constraints : Assuming that gcontains declarations for
the set of properties P, an order constraint is created in
the form of pos(si)< pos (sj) for every order dependency
hsi; dkip  !hsj; dliwhere p2P.
...
<div class ="class1 class4" >
    content1
</div>
<div class ="class2 class3" >
    content2
</div>
...(a)
content1
content2(b)
content1
content2
(c)
Figure 13: (a) Sample document, (b) Styling using
the CSS code of Figure 12a, (c) Styling using the
CSS code of Figure 12b
In the example of Figure 12a, the order dependencies are
h.class2 ,font-weight: boldifont weight        !h .class3 ,font-weight: 700i
h.class2 ,border: solid 1px #d3d3d3iborder    !h .class3 ,border: solid 3px redi
and we extract the constraint pos(.class2 )< pos (.class3 ).
Based on this constraint, the extracted grouping selector
.class2,.class4 should be placed at any position before
the selector .class3 (i.e., .class3 should be the last selec-
tor in the style sheet after refactoring) in order to preserve
the presentation of that target document in Figure 13a.
If we assume that there is an additional order dependency
from selector .class3 to.class4 due to property border ,
then the CSP would be unsatisable due to the new con-
straint pos(.class3 )< pos (.class4 ). In that case, the ex-
tracted selector .class2,.class4 has to be placed before
.class3 to satisfy the rst constraint and after .class3 to
satisfy the second constraint, and thus there is no solution
satisfying both constraints. Refactoring opportunities lead-
ing to an unsatisable CSP violate the dened precondition,
and therefore are excluded as non presentation-preserving.
5. EV ALUATION
To assess the ecacy of our approach, we conducted a
case study addressing the following research questions:
RQ1: What is the extent of declaration-level duplication in
CSS les?
RQ2: What is the number of refactoring opportunities that
can be potentially applied in CSS les and how many
of them are actually presentation-preserving?
RQ3: What is the size reduction we can achieve by applying
presentation-preserving refactorings in CSS les?
Our tool and empirical data are all available online.1
5.1 Experiment Design
Selection of subjects. In total, our study contains 38
subjects. In order to select representative real-world web
applications, we adopted the web-systems included in the
study conducted by Mesbah and Mirshokraie [19], in which
they investigated the presence of unused CSS code. The list
includes 15 (in total) open-source, randomly selected, and
author selected online web applications. We included 14
subject systems from that list (one of them is not available
online anymore). We extended the list with 24 more subjects
including web applications developed by companies consid-
ered leaders in web technologies, such as Facebook, Yahoo!,
Google, and Microsoft, in addition to a subset of the top-
100 visited web sites based on Alexa ranking. The complete
list of the selected systems is shown in Table 2. Figure 14
shows the size characteristics of the CSS code, selectors, and
declarations of the subjects included in our study.
1http://goo.gl/q2ZvlBTable 2: Selected subjects
ID Web app.# CSSID Web app.# CSS
les les
1 Facebook 6 20 Pinteerst 2
2 YouTube 4 21 Reddit 1
3 Twitter 2 22 Tumblr.com 2
4 YahooMail 3 23 Wordpress.org 1
5 Outlook.com 6 24 Vimeo.com 3
6 Gmail 5 25 Igloo 2
7 Github 2 26 Phormer 1
8 Amazon.ca 3 27 BeckerElectric 1
9 Ebay 2 28 Equus 1
10 About.com 1 29 ProToolsExpress 1
11 Alibaba 3 30 UniqueVanities 3
12 Apple.ca 3 31 ICSE12 3
13 BBC 3 32 EmployeeSolutions 3
14 CNN 1 33 SyncCreative 3
15 Craiglist 1 34 GlobalTVBC 5
16 Imgur 2 35 Lenovo 1
17 Microsoft 1 36 MountainEquip 2
18 MSN 1 37 Staples 2
19 Paypal 1 38 MSNWeather 3
Size (KB)1 5 Md=43.32 400
Mean= 90.95
#Selectors10 100 5000 Md= 408
Mean= 831
#Declarations10 100 10000 Md= 994
Mean= 2168
Figure 14: Characteristics of the analyzed CSS les
Extraction of CSS styles and DOM states. CSS styles
can be directly embedded in the web documents, linked to
web pages as external les, or dynamically generated at run-
time through JavaScript code. For our experiments, we fo-
cus on the external CSS les, since the refactoring of the
other sources of CSS code requires the modication of other
web artifacts (such as HTML documents), which is not the
focus of this paper. We take advantage of the dynamic anal-
ysis features provided by Crawljax [20] and developed an
external CSS le extractor plug-in. Additionally, we use
Crawljax to dynamically capture dierent DOM tree in-
stances (i.e., DOM states) from the examined web applica-
tions and use them for the extraction of order dependencies
between the CSS selectors.
Detection of presentation-preserving refactorings. In
order to collect the set of presentation-preserving refactor-
ings that can be safely applied on a CSS le fstyling the
set of DOM states Scollected from a web application, we:
1. Extract the order dependencies between the selectors of f
by analyzing the DOM states in S, as described in Section
4.6.
2. Extract the set of refactoring opportunities Rthat can
be potentially applied to f.
3. Sort Rbased on size reduction (Formula 1) and remove
the refactoring opportunities having a negative value.
4. Iterate through the elements of Rand apply the rst
refactoring opportunity for which the CSP dened in Sec-
tion 4.6 is satisable.
5. If step 4 results in the application of a refactoring, repeat
steps 1-5 with the refactored CSS le f0.
0.2 0.4 0.6 0.8 Md= 0.68Mean= 0.66Figure 15: Percentage of duplicated declarations
5.2 Results
Extent of duplication in CSS declarations (RQ1).
The results of our empirical study conrm the expectation
that duplication is more extensive in CSS code compared
to procedural and object-oriented code (with 5{20% dupli-
cated code [28]). Figure 15 displays a violin plot with the
percentage of the declarations that are involved in at least
one clone (i.e., they are at least once duplicated) in the an-
alyzed style sheets. The median value for the percentage
of duplicated declarations is 68%, while the average is 66%.
The vast majority of the examined style sheets exhibits a
duplication ranging from 40% to 90%. Note that in the re-
ported results we have set the minimum support (i.e., the
minimum number of selectors that should share a common
declaration) to the lowest possible value (equal to 2); set-
ting a larger minimum support value would lead to lower
duplication rates.
Figure 16a shows the number of clones detected in the
analyzed CSS les. On average, there are 270 distinct dec-
larations being repeated more than once in the examined
style sheets that could be used as building blocks for ex-
tracting more advanced refactoring opportunities. The Venn
diagram shown in Figure 16b displays the percentage of the
clones including dierent combinations of the duplication
types dened in Section 3. As it can be observed, 97% of
the clones include only type I duplication instances, while
2% of the clones include a combination of type I and II du-
plication instances. Furthermore, the existence of type III
duplication instances within the clones is very rare.
5 30 2000 Md= 168
Mean= 269.64
(a) Total number of detected
clones
Type I Type II
Type III96.84% 0.74%
0.01%2.38%
0.03%0%
0%(b) Duplication types in
the detected clones
Figure 16: Statistics for the detected clones
Refactoring opportunities in CSS (RQ2). Figure 17
shows on top, a bean plot of the number of refactoring
opportunities that were initially extracted from the origi-
nal CSS les, excluding refactoring opportunities being sub-
sumed and/or having a negative size reduction value. On the
bottom of Figure 17, we can see a bean plot of the number of
presentation-preserving refactorings, which we actually ap-
plied on the CSS les. As it can be observed, our approach#Applied #Opportunities
1 5 1000 10000Md= 46 Mean= 164.63
Md= 23 Mean= 62.28Figure 17: Initial refactoring opportunities vs. ap-
plied presentation-preserving refactorings
was able to detect, on average, 165 refactoring opportuni-
ties in the original version of the examined CSS les, while
the average number of presentation-preserving refactorings
was 62. Additionally, we found out that the examined CSS
les had 79 order dependencies on average between their
selectors, as shown in Figure 18a.
1 5 600 Md= 25
Mean= 78.86
(a) #Order dependencies
0 20 30 40Md= 5.31
Mean= 8.08 (b) %Size reduction
Figure 18: Order dependencies and size reduction
Size reduction (RQ3). In Figure 18b, we have depicted a
bean plot with the percentage of the size reduction achieved
by applying only presentation-preserving refactorings. In
the examined CSS les, the average size reduction was 8%,
while the maximum achieved value was 35%. Overall, in 12%
of the examined CSS les (11 out of 91) the size reduction
was over 20%, while in 27% (25 out of 91) the size reduction
was over 10%.
In order to determine the factors that inuence the appli-
cability of refactorings in the examined CSS les, we decided
to build a statistical regression model. Regression models
are mostly used for the purpose of prediction, where the
values of one or more predictor variables can be used to pre-
dict the value for the response variable . However, a multiple
linear regression model can be also used to assess the impact
of one predictor on the response variable, while controlling
the other predictors [8]. Using regression, we estimate a co-
ecient for each predictor, which shows the magnitude and
direction of the eect of the predictor on the response vari-
able. We built a model with the number of applied refac-
torings as the response variable, and size and number of
order dependencies as predictors. Intuitively, we expect a
positive relationship between the number of applied refac-
torings and the size of the CSS les, since larger les ex-
hibit more duplication and thus oer more opportunities for
refactoring. On the other hand, we expect a negative rela-Table 3: Statistical model's estimated parameters
Parameter Estimate p-value
Intercept*2.989 <2e-16
Size coecient 8.149e-03 <2e-16
#Order dependencies coecient -1.195e-03 <2e-16
*The intercept is the constant term in the regression
model, which makes the residuals have a mean of zero.
tionship between the number of applied refactorings and the
number of order dependencies detected for a given CSS le,
since a larger number of order dependencies implies a higher
probability for a precondition violation and thus rejecting a
candidate refactoring opportunity. To this end, we created
a generalized linear model using the Poisson distribution
function [35].
As it is shown in Table 3, all estimated coecients are
statistically signicant, and as we expected, the coecient
for the size of the CSS les is positive, while the coecient
for the number of order dependencies is negative. From this
result, we can conclude that for CSS les with a similar
size, the number of applicable refactorings decreases as the
number of order dependencies increases. Additionally, we
can conclude that our approach is more eective in terms of
size reduction for large CSS les with a limited number of
order dependencies.
5.3 Discussion
CSS duplication and refactoring opportunities. Our
case study shows that CSS code duplication is prevalent
in today's web systems. The majority of the clones we
found pertain to type I duplication instances, and type II
and III duplications are relatively less common. This indi-
cates that developers use the same representation for prop-
erty values consistently throughout their style sheets. Addi-
tionally, they make use of shorthand-property declarations
consistently within dierent selectors. The results of our
evaluation also show that our method is able to successfully
detect many CSS refactoring opportunities that remove du-
plications and preserve the initial presentation of the target
documents. These refactorings, when applied, allow for a
much cleaner CSS code and considerable size reduction.
Size reduction. In our method, we focus on refactoring
opportunities that extract the same set of equivalent dec-
larations in a grouping selector. An alternative approach
would be to extract and group the declarations in a new
class selector, instead of a grouping selector. By selecting
an appropriate name for the class selector, we can reduce
even further the size of the CSS le, i.e., by replacing a set
of selector names with a single class name, and at the same
time improve its understandability (the class name could
represent a common concept being extracted). However,
this approach requires to make use of the new class in the
DOM elements of the target document. From the refactor-
ing point of view, this approach should update the corre-
sponding HTML documents for static web sites, or even the
source code that generates the HTML elements for dynamic
web sites.
Limitations. In our current implementation, we have only
considered CSS les linked to the HTML documents. In
order to provide complete CSS refactoring support, in the
future, we will also include in our analysis CSS styles em-
bedded inside the <style> tags of the web pages as well asdynamically generated CSS styles through JavaScript.
Threats to the validity. A threat to the internal validity
is that the DOM states collected from each web application
may be insucient to extract all possible order dependen-
cies between the selectors of the examined CSS les, since for
some dynamic web applications the number of DOM states
is practically innite. Missing order dependencies from un-
visited DOM states could make some of the applied refac-
toring opportunities to be non presentation-preserving for
this particular set of unvisited DOM states.
To avoid selection bias, we selected 14 subjects from the
list of web sites analyzed in a related CSS study[19]. To mit-
igate threats to the external validity and make the results
of the experiment as generalizable as possible, we included
24 additional web sites developed by leading companies in
web technologies applying the current state-of-the-art CSS
development practices. Finally, the developed tool and the
collected data are all available online1to enable the repli-
cation of the experiment by other researchers.
6. RELATED WORK
Despite the fact that CSS is widely used in practice, it
has not received much research attention. Mesbah and Mir-
shokrae [19] propose a technique to automatically detect un-
used and ineective CSS code. Having a similar goal, Gen-
eves et al. [9] use tree logics to detect unused CSS code.
Keller and Nussbaumer [13] conclude that human-written
CSS code has a higher abstractness (i.e., higher reusability)
compared to generated code. To the best of our knowledge,
our work is the rst to analyze CSS with respect to code
duplication and provide refactoring opportunities.
Several researchers have developed techniques for the de-
tection of duplication in web artifacts. Most of the stud-
ies in this area have focused on the detection of duplicated
content in web pages [1], or nding web pages with similar
structure [6, 7]. Boldyre et al. [1] replace the content of
the web pages (i.e., the text inside dierent tags) with hash
values and compared them to nd duplicated content in web
pages. Lanubile and Mallardo [14] propose a semi-automatic
approach to nd function clones in the source code of web
applications. Their approach rst compares the names of
the functions written in either JavaScript or VBScript. If
the names are the same, they compute various size met-
rics and report the functions with similar metric values as
candidate clones. In their follow-up work, they evaluated
this approach on four web applications and found out that
the 21% to 80% of functions were duplicated and could be
refactored [2].
De Lucia et al. [5] use the Levenshtein edit distance to
quantify the structural similarity between dierent web pages.
Rajapakse and Jarzabek [26] use CCFinder, a clone detec-
tion tool which nds the clones by applying token-to-token
comparison [12], to nd code clones in the source code of
web applications written in various languages. They exam-
ined 17 web applications and found out a duplication rate of
17% to 63%. Synytskyy et al. [30] use an island grammar in
order to dene smaller portions of the HTML syntax for ele-
ments, such as forms and tables, that might be cloned across
dierent pages. The grammar is used to extract those struc-
tures from web pages and examine whether their structure
is repeated in other pages.
Cordy et al. [3] propose an approach that is language-independent and can detect exact and near-miss clones us-
ing island grammar extraction, pretty-printing and textual
dierencing of the clone candidates. In their study, they im-
plemented this approach for HTML. This work led to the
introduction of NiCad [29], which is an exact and near-miss
clone detector. Later, researchers used [24] NiCad to detect
clones and to nd clone patterns in the PHP code of two
industrial systems.
The extracted duplication information can be used to re-
engineer web applications, i.e., create dynamic pages from
static ones [1, 30], generate more-generalized dynamic web
pages to minimize the duplication [4, 27], or nd similar
functionalities across dierent web pages [5]. None of the
aforementioned works investigated the existence of duplica-
tion in CSS code, or developed a technique specialized on
the detection of duplication in CSS code.
The most closely related work to this paper, regarding the
detection of duplication in CSS code, is the approach pro-
posed by Mao et al. [17] on the automatic migration from
table-based structure to the style-based structure for web
pages. In their work, they used traditional clone detection
approaches in order to nd the duplicated code across dier-
ent CSS les and remove the duplications by creating a sin-
gle CSS le, which could be applied to dierent web pages.
Although this kind of detection and analysis might be suf-
cient for nding type I duplications, it cannot nd type II
and III duplication instances, as dened in this work.
7. CONCLUSIONS AND FUTURE WORK
In this work, we developed a technique for the detection of
refactoring opportunities that can eliminate duplicated CSS
declarations safely, i.e., without side-eects in the styling
of the web documents. We performed an experiment on 38
real web applications and found that (1) code duplication
is extensive in CSS les; on average 66% of the style decla-
rations are repeated at least once, (2) there is a signicant
number of presentation-preserving refactoring opportunities
(62 on average) that is associated positively with the size
of the CSS les and negatively with the number of order
dependencies between the selectors of the CSS les, and (3)
on average a 8% reduction in the size of the examined CSS
les can be achieved by applying the detected refactoring
opportunities.
As future work, we plan to investigate the refactoring of
CSS code into CSS Preprocessor code. CSS preprocessors,
such as Sass2and Less3, allow the denition of variables
and functions to build reusable and parameterizable blocks
of code, adding essentially features of procedural program-
ming languages. Eventually, the preprocessor code is pro-
cessed to generate pure CSS code. The research goal is to
nd repeated CSS styles and refactor them into functions
by parameterizing possible dierences in property values.
8. ACKNOWLEDGMENTS
This research was supported in part by the Natural Sci-
ences and Engineering Research Council of Canada (NSERC),
the Fonds de Recherche du Qu ebec { Nature et Technologies
(FRQNT), and the Faculty of Engineering and Computer
Science at Concordia University.
2http://sass-lang.com/
3http://lesscss.org/9. REFERENCES
[1] C. Boldyre and R. Kewish. Reverse engineering to
achieve maintainable WWW sites. In Proc. of the 8th
Working Conf. on Reverse Engineering , pages
249{257, 2001.
[2] F. Calefato, F. Lanubile, and T. Mallardo. Function
clone detection in web applications: a semiautomated
approach. Journal of Web Engineering , 3(1):3{21,
2004.
[3] J. R. Cordy and T. R. Dean. Practical
language-independent detection of near-miss clones. In
Proc. of the 14th Conf. of the Centre for Advanced
Studies on Collaborative Research , pages 1{12, 2004.
[4] A. De Lucia, R. Francese, G. Scanniello, and
G. Tortora. Reengineering web applications based on
cloned pattern analysis. In Proc. of 12th IEEE Int'l
Workshop on Program Comprehension , pages 132{141.
IEEE, 2004.
[5] A. De Lucia, R. Francese, G. Scanniello, and
G. Tortora. Understanding cloned patterns in web
applications. In Proc. of the 13th Int'l Workshop on
Program Comprehension , pages 333{336. IEEE, 2005.
[6] G. Di Lucca and M. Di Penta. Clone analysis in the
web era: an approach to identify cloned web pages. In
Proc. of the 7th IEEE Workshop on Empirical Studies
of Software Maintenance , pages 107{113, 2001.
[7] G. Di Lucca, M. Di Penta, and A. Fasolino. An
approach to identify duplicated web pages. In Proc. of
the 26th Annual Int'l Computer Software and
Applications Conf. , pages 481{486, 2002.
[8] S. Dowdy, S. Wearden, and D. Chilko. Statistics for
research . Wiley-Interscience, 3rd edition, 2004.
[9] P. Geneves, N. Layaida, and V. Quint. On the analysis
of cascading style sheets. In Proc. of the 21st Int'l
Conf. on World Wide Web , pages 809{818, 2012.
[10] J. Han, J. Pei, and Y. Yin. Mining frequent patterns
without candidate gention. SIGMOD Rec. , 29(2):1{12,
2000.
[11] E. Juergens, F. Deissenboeck, B. Hummel, and
S. Wagner. Do code clones matter? In Proc. of the
31st Int'l Conf. on Software Engineering , pages
485{495, 2009.
[12] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: A
multilinguistic token-based code clone detection
system for large scale source code. IEEE Trans. on
Software Engineering , 28(7):654{670, 2002.
[13] M. Keller and M. Nussbaumer. CSS code quality: a
metric for abstractness; or why humans beat machines
in CSS coding. In Proc. of the 7th Int'l Conf. on the
Quality of Information and Communications
Technology , pages 116{121, 2010.
[14] F. Lanubile and T. Mallardo. Finding function clones
in web applications. In Proc. of the 7th European
Conf. on Software Maintenance and Reengineering ,
pages 379{386, 2003.
[15] H. W. Lie. Cascading Style Sheets . Ph.D. Thesis,
University of Oslo, Norway, 2005.
[16] A. Lozano and M. Wermelinger. Assessing the eect of
clones on changeability. In Proc. of the 24th IEEE Int'l
Conf. on Software Maintenance , pages 227{236, 2008.
[17] A. Y. Mao, J. R. Cordy, and T. R. Dean. Automated
conversion of table-based websites to structuredstylesheets using table recognition and clone detection.
Proc. of the 2007 Conf. of the center for advanced
studies on Collaborative research , pages 12{26, 2007.
[18] T. Mens, G. Taentzer, and O. Runge. Analysing
refactoring dependencies using graph transformation.
Softw. and Sys. Modeling , 6(3):269{285, 2007.
[19] A. Mesbah and S. Mirshokraie. Automated analysis of
CSS rules to support style maintenance. In Proc. of
the Int'l Conf. on Software Engineering , pages
408{418, 2012.
[20] A. Mesbah, A. van Deursen, and S. Lenselink.
Crawling Ajax-based web applications through
dynamic analysis of user interface state changes. ACM
Trans. on the Web , 6(1):3:1{3:30, 2012.
[21] L. A. Meyerovich and R. Bodik. Fast and parallel
webpage layout. In Proc. of the 19th Int'l Conf. on
World Wide Web , pages 711{720, 2010.
[22] M. Mondal, C. K. Roy, and K. A. Schneider. An
empirical study on clone stability. Applied Computing
Review , 12(3):20{36, Sept. 2012.
[23] Mozilla Developer Newtork. Web developer survey
research. Technical report, Mozilla, 2010.
[24] T. Muhammad, M. F. Zibran, Y. Yamamoto, and
C. K. Roy. Near-miss clone patterns in web
applications: An empirical study with industrial
systems. In Proc. of the 26th IEEE Canadian Conf. on
Electrical and Computer Engineering , pages 1{6, 2013.
[25] W. F. Opdyke. Refactoring object-oriented
frameworks . PhD thesis, University of Illinois at
Urbana-Champaign, IL, USA, 1992.
[26] D. C. Rajapakse and S. Jarzabek. An investigation of
cloning in web applications. In Proc. of the 5th Int'l
Conf. of Web Engineering , pages 252{262, 2005.
[27] D. C. Rajapakse and S. Jarzabek. Using server pages
to unify clones in web applications: A trade-o
analysis. In Proc. of the 29th Int'l Conf. on Software
Engineering , pages 116{126, 2007.
[28] C. K. Roy and J. R. Cordy. A survey on software
clone detection research. Technical report, Queens
University, TR, Kingston, Canada, 2007.
[29] C. K. Roy and J. R. Cordy. NICAD: Accurate
detection of near-miss intentional clones using exible
pretty-printing and code normalization. In Proc. of the
16th IEEE Int'l Conf. on Program Comprehension ,
pages 172{181, 2008.
[30] N. Synytskyy, J. R. Cordy, and T. R. Dean.
Resolution of static clones in dynamic Web pages. In
Proc. of the 5th IEEE Int'l Workshop on Web Site
Evolution , pages 49{56, 2003.
[31] P. Tan, M. Steinbach, and V. Kumar. Introduction to
data mining . Addison-Wesley, 2005.
[32] W3Schools.com. CSS reference.
http://www.w3schools.com/cssref/ .
[33] Web Technology Surveys. Usage of css for websites.
http://w3techs.com/technologies/details/
ce-css/all/all .
[34] World Wide Web Consortium. CSS specications.
http://www.w3.org/Style/CSS/current-work .
[35] A. Zeileis, C. Kleiber, and S. Jackman. Regression
models for count data in R. Journal of Statistical
Software , 27(8):1{25, 7 2008.