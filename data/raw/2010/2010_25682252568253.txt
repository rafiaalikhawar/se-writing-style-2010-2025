Symbolic Assume-Guarantee Reasoning through BDD
Learning
FeiHe
TsinghuaUniversity,ChinaBow-YawWang
AcademiaSinica,TaiwanLiangzeYin
TsinghuaUniversity,China
LeiZhu
TsinghuaUniversity,China
ABSTRACT
Both symbolic model checking and assume-guarantee rea-
soningaimtocircumventthestateexplosionproblem. Sym-
bolic model checking explores many states simultaneously
andreportsnumerouserroneoustraces. Automatedassume-
guarantee reasoning, on the other hand, infers contextual
assumptionsbyinspectingspuriouserroneoustraces. One
would expect that their integration could further improve
thecapacityofmodelchecking. Yetexaminingnumerouser-
roneoustracestodeducecontextualassumptionscanbevery
time-consuming. Theintegrationofsymbolicmodelchecking
andassume-guaranteereasoningisthusfarfromclear. In
this paper, we present a progressive witness analysis algo-
rithmforautomatedassume-guaranteereasoningtoexploit
amultitudeoftracesfromBDD-basedsymbolicmodelcheck-
ers. Ourtechniquesuccessfully integratessymbolicmodel
checking with automated assume-guarantee reasoning by
directlyinferringBDD’sasimplicitassumptions. Itoutper-
formsmonolithicsymbolicmodelcheckinginfourbenchmark
problemsandanindustrialcasestudyinexperiments.
CategoriesandSubjectDescriptors
D.2.4[Software Engineering ]: Software/ProgramVeriﬁ-
cation;F.3.1[ Logics and Meanings of Programs ]: Spec-
ifyingandVerifyingandReasoningaboutPrograms
GeneralTerms
Veriﬁcation,Reliability
Keywords
Softwaremodelchecking,symbolicmodelchecking,assume-
guaranteereasoning,algorithmiclearning,safety
1. INTRODUCTION
Theadventofmulti-coreprocessorsnotonlyimprovesthe
eﬃciency of computing but also increases the complexity
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bearthisnoticeandthe fullcitationontheﬁrstpage. Tocopyotherwise,to
republish,topostonserversortoredistributetolists,requirespriorspeciﬁc
permission and/or a fee.
ICSE’14, May 31 - June 7, 2014, Hyderabad, India
Copyright 14 ACM 978-1-4503-2756-5/14/05 ...$15.00.of programming. Intricate interactions among concurrent
processesoftenincurunexpectedfaultyprogrambehaviors
eludingprogrammers’inspection. Programveriﬁcationhence
playsanevenmoreimportantroleduringsoftwaredevelop-
ment. Model checking is a program veriﬁcation technique
thatautomaticallyanalyzesthecorrectnessofprogramsby
formalmathematicalreasoning[18,16].
Inmodelchecking,programmersspecifyamodelforthe
systemunderveriﬁcation,andaformalpropertyaboutin-
tendedsystembehaviors. Amodelcheckerveriﬁesthemodel
againstthepropertybyexploringallsystembehaviors. Ifany
behavior does not fulﬁll the intended property, the model
checker will report it. Otherwise, the model satisﬁes the
propertyconclusivelysincethereisnoviolation. Exploring
allbehaviorscanbeveryexpensivecomputationallysince
thenumberofsystemstatescangrowexponentiallyinthe
numberofsystemcomponents. Thestateexplosionproblem
greatlyimpedestheeﬀectivenessofmodelchecking.
Symbolicmodelchecking1isawell-knowntechniquefor
amelioratingthestateexplosionproblem[7,18]. Insymbolic
model checking, system states are implicitly represented
by predicates, as well as the initial states and transition
relationofthesystem. UsingdatastructuressuchasBinary
Decision Diagrams (BDD’s), a large number of states are
explored simultaneously by standard predicate operations
(conjunction,disjunction,quantiﬁerelimination,etc). Since
itisnolongernecessarytoenumeratestatesoneatatime,
thestateexplosionproblemcanbealleviated.
Byseparatingconcernsofsoftwarefunctionality,component-
based designs improve reusability and quality of software
systems[5,30]. Incomponent-basedsoftwareengineering,a
softwaresystemiscomposedofseveralcomponentsofdiﬀer-
entfunctionality. Wheneachsoftwarecomponenthasclearly
speciﬁedfunctionsandinterfaces,itsreusabilityisimproved.
Timeofdevelopingsoftwaresystemsissubsequentlyreduced.
Incidentally,theseparationofconcernsisnotonlyfoundin
softwaredevelopmentbutalsoveriﬁcation.
Assume-guaranteereasoningisatechniquetoimprovethe
capacityofmodelchecking. Inassume-guaranteereasoning,
oneveriﬁeswhethereverycomponentbehavescorrectlyun-
dercertaincarefullychosencontextualassumptions[21]. If
so, the system of components is correct by the soundness
of assume-guarantee reasoning. Since each component is
veriﬁedagainstcontextualassumptionsseparately,thestate
explosionproblemcanbeavoided. Choosingcontextualas-
sumptions however is not easy. Oftentimes, programmers
1By “symbolic”, we mean BDD-based techniques unless
statedotherwise.Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
Copyright is held by the author/owner(s). Publication rights licensed to ACM.
ICSE’14 , May 31 – June 7, 2014, Hyderabad, India
ACM 978-1-4503-2756-5/14/05
http://dx.doi.org/10.1145/2568225.2568253
1071
havetoprovidecontextualassumptionsmanually. Suchla-
borioustasksareverytimeconsumingandcanbeextremely
diﬃculttocarryoutonlargesystems.
In order to address the assumption generation problem,
machinelearningisappliedtoinfercontextualassumptions.
In[20,1,8,35,24,32,25,13,34],theL∗learningalgorithm
forregularlanguages[2]isadoptedtosolvetheassumption
generationproblem. Insteadofprogrammers,oneemploys
theL∗learningalgorithmtocontrivecontextualassumptions
under the supervision of a mechanical teacher. When the
L∗learning algorithm purports a contextual assumption,
oneperformsassume-guaranteereasoning. Ifthecontextual
assumption is strong enough to establish the correctness
ofthesystem,wearedone. Otherwise,themodelchecker
reportsanerroneousbehaviorunderthepurportedcontextual
assumption. Whenthecontextualassumptionisoverlyweak,
thereportedbehaviormaynotbeavalidsystembehavior.
Themechanicalteacherhastocheckiftheerroneousbehavior
isvalid. Ifnot,themechanicalteacheranalyzesthespurious
erroneous behavior and guides the learning algorithm to
revisethenextcontextualassumption.
Both symbolic model checking and automated assume-
guaranteereasoningaimtocircumventthestateexplosion
problem. One wonders if their integration can further im-
prove the capacity of model checking. On closer examina-
tion, it is not hard to see that an eﬀective integration is
notstraightforward. First,theL∗learningalgorithmrepre-
sentscontextualassumptionsexplicitly. Convertingexplicit
contextualassumptionstoimplicitrepresentationsinduces
overheads.2Second,whenapurportedcontextualassump-
tionfailstoverifythesystem,asymbolicmodelcheckerin
fact gives numerous erroneous behaviors. The mechanical
teacherhastoanalyzelotsofbehaviorstosuperviselearning
algorithms. Sinceitisinfeasibletoenumerateallimplicitly
represented behaviors, it is unclear how to extract neces-
saryinformationtoinferpurportedcontextualassumptions
eﬃciently. Third,alearningalgorithmpurportsanewcon-
textualassumptionafterreceivingaspuriousbehaviorfrom
themechanicalteacher. Themechanicalteacheractuallypos-
sessesanumberofspuriousbehaviorsaftersymbolicmodel
checking. Eﬃcientlypassingnumerousspuriousbehaviorsto
thelearningalgorithmisnotatallobvious. Amoresophis-
ticatedmechanismwhichtakesfulladvantageofsymbolic
modelcheckingiscertainlydesirable.
Inthispaper,wepresentaprogressiveanalysisalgorithm
totakeadvantageofbothsymbolicmodelcheckingandau-
tomatedassume-guaranteereasoning. Whenspuriousbehav-
iorsareobtained,themechanicalteacherguidesthelearning
algorithmtoremoveaspuriousbehaviorfromcontextualas-
sumptions. Whenthelearningalgorithmpurportsarevised
contextualassumption,ourprogressivealgorithmchecksif
previousspuriousbehaviorsareeliminatedinthenewcon-
textual assumption. If not, another spurious behavior is
returnedtoguidethelearningalgorithmtothenextrevision.
Onlywhenallspuriousbehaviorsareaccountedfor,canthe
veriﬁcationalgorithmproceedtoperformassume-guarantee
reasoning with the purported contextual assumption. Ob-
servethatassume-guaranteereasoningisappliedonlywhen
knownspuriousbehaviorsareeliminated. Ourprogressive
approachhenceminimizestheinvocationofmodelcheckers
2Implicitlearningattemptstoaddresstheproblem[12,11],
but other problems peculiar to symbolic model checking
remain.and maximizes the utility of the information in implicitly
representedspuriousbehaviors.
Ourtechnicalcontributionsaresummarizedasfollows.
•We adoptaBDD learning algorithm to generate im-
plicit contextual assumptions in our fully symbolic
technique. Diﬀerentfrom[11],weimplementtheclassi-
ﬁcationtree-basedBDDlearningalgorithm[31]inour
symbolicassume-guaranteereasoningtechnique.
•Weproposeaprogressiveanalysisalgorithmfortheme-
chanicalteacherinautomatedassume-guaranteereason-
ing. Thenewalgorithmtakesadvantageofimplicitly
representedbehaviorsfromsymbolicmodelcheckers. It
enablestheintegrationofsymbolicmodelcheckingand
automatedassume-guaranteereasoningtoameliorate
thestateexplosionproblem.
•We compare our new technique with the monolithic
symbolic model checkerNuSMV2.4.3 [15]. Experi-
mental results show that our technique outperforms
monolithicmodelcheckinginfourbenchmarkproblems
(mini-Rubik’scube,Rubik’scube,diningphilosophers,
anddiningcryptographers). Ourcompositionaltech-
nique moreover improves both time and space in an
industrialgatecontrolsystem.
Thepaperisorganizedasfollows. Wereviewrelatedwork
in Section 2. After preliminaries (Section 3), automated
assume-guaranteereasoningwithimplicitlearningisbrieﬂy
reviewedinSection4. Section5presentsourtechnicalcon-
tribution. Itisfollowedbyexperimentalresults(Section6).
Finally,weconcludeourpresentationinSection7.
2. RELATEDWORK
Automatedassume-guaranteereasoningisproposedin[20].
The authors apply theL∗algorithm to generate explicit
deterministicﬁniteautomataascontextualassumptions[2].
SeveraloptimizationsfortheL∗algorithmareavailable[32,
9, 35, 4]. A tree-based contextual assumption generation
algorithmisalsodevelopedin[26,27]. Interfacesynthesis
bylearningisreportedin[28,3]. Predicateabstractionhas
beenusedtorepresentsoftwarestatespacesymbolically[33,
22],butderivingsymbolicrepresentationsoftransitionsis
diﬀerent. Indeed,contextualassumptionsinferredbythese
techniques are still represented explicitly. Converting ex-
plicitcontextualassumptionstoBDD’sforsymbolicmodel
checkingcaninduceoverheads. Inferringexplicitcontextual
assumptionsisnotoptimalforsymbolicmodelchecking.
Learning implicit contextual assumptions based on the
CDNFalgorithm[6]isproposedin[12]. Thework[11]com-
parestheCDNFalgorithmandtheL∗-basedBDDlearning
algorithm[23]inthecontextofassume-guaranteereasoning
throughimplicitlearning. RatherthanBDD-basedsymbolic
model checking, both works [12, 11] employ a SAT-based
symbolicmodelchecker. SinceSAT-basedsymbolicmodel
checking reports only one erroneous behavior, the simple
witnessanalysisalgorithmsuﬃces. Ontheotherhand,our
progressive algorithm is designed to analyze numerous er-
roneous behaviors. It enables programmers to deploy a
BDD-basedsymbolicmodelcheckerinautomatedassume-
guaranteereasoning. Additionally,weimplementtheclassi-
ﬁcationtree-basedBDDlearningalgorithm[31]. Thenew
algorithmisasymptoticallymoreeﬃcientthantheL∗-based
learningalgorithmimplementedin[11]byalinearfactor.1072The symbolic compositional veriﬁcation technique in [1,
32]isonlyrelevantinappearance. BasedontheL∗learn-
ing algorithm, the symbolicL∗algorithm uses BDD’s to
encodeinputsymbolsontransitionsofcontextualassump-
tions. States of contextual assumptions however are still
represented explicitly. Converting semi-symbolic contex-
tualassumptionsforsymbolicmodelcheckingmayinduce
overheads. Moreover,thesymbolicL∗algorithminfersde-
terministic contextual assumptions in a partially implicit
representation. OurtechniqueadoptsaBDDlearningalgo-
rithmandinfersnondeterministiccontextualassumptionsin
BDD’s,afullyimplicitrepresentation.
Finally,somedrawbacksofautomatedassume-guarantee
reasoningwiththebasicL∗algorithmarediscussedin[19].
Manyissueshavebeenaddressedinvariousoptimizations
ofthebasicalgorithmsincethen[32,9,35,26,27,4]. We
adopt a BDD learning algorithm and infer contextual as-
sumptionsimplicitly. Observationsin[19]nolongerapply.
Moreover,thework[19]comparescompositionalreasoning
withmonolithicveriﬁcationwithinenumerativemodelcheck-
ing,acontextverydiﬀerentfromsymbolicmodelchecking.
3. PRELIMINARIES
LetB={ﬀ,tt}be theBoolean domainwith thetruth
values ﬀandtt. For a set xof Boolean variables, deﬁne
x�={x�:x∈ x}and�x={�x:x∈ x}. Avaluationover
xis a mapping from xtoB. We writeVal xfor the set of
valuationsover x. Apredicateφ( x)(orφwhenthevariables
xare clear from the context) is a Boolean function over
theBooleanvariables x. Forapredicateφandavaluation
s∈Val x,ssatisﬁesφ(writtens|=φ)ifφevaluatesto tt
byassignings(x)tox∈ x. Similarly, apairofvaluations
(s,t)∈ Val x×Val xsatisﬁesa predicateψ( x,x�) (written
(s,t)|=ψ)ifψevaluatesto ttbyassignings(x)andt(x)to
x∈xandx�∈x�respectively. Wewrite[[φ]]forthesetof
satisfyingvaluationsforthepredicateφ,namely,[[φ]]={s∈
Val x:s|=φ}. Apredicateφisatautology(written|=φ)if
s|=φforeveryvaluations∈Val x.
Reducedandorderedbinarydecisiondiagrams(BDD’s)are
arepresentationforpredicates. Foranypredicateφ,wewrite
BDD(φ) for the BDD representingφ. The representation
is canonical in the sense that BDD(φ) =BDD(ψ) if and
only ifφ=ψ. For instance, considerφ=x 0∨ ¬x 0and
ψ=x 1∨ ¬x 1. ThenBDD(φ)=BDD(ψ)sincebothφand
ψaretautologies. Booleanoperationsandquantiﬁcationare
allowedinBDD’s. Onecancompute BDD (¬φ),BDD (φ∧ψ),
BDD(φ∨ψ),BDD(∀x.φ), andBDD(∃x.φ) fromBDD(φ)
andBDD(ψ)foranypredicatesφ,ψ,andvariablex∈x.
Atransition systemM=� x,ι,τ�consists of a set xof
Booleanvariables,aninitial predicateι( x),andatransition
predicateτ(x,x�). Anx-stateis a valuation over x. An
x-statesisM-initialifs|=ι. A pair (s,t) of x-states
is called anM-transitionif (s,t)|=τ. If (s,t) is anM-
transition,tisanM-successorofs. AnM-traceisasequence
σ=[s 0,s1,· · ·,sn]ofx-statessuchthats 0isM-initialand
(si,si+1)isanM-transitionfori=0, ...,n−1. Wewrite
Tr(M)forthesetofM-traces. An x-statesisM-reachable
ifthereisanM-traceendingins. Foranypredicateπ, a
sequenceσ=[s 0,s1,...,sn]ofx-statessatisﬁesπ(written
σ|=π) ifs i|=πfori= 0, ...,n. We sayMsatisﬁesπ
(writtenM|=π)ifσ|=πforeveryσ∈Tr(M).
LetM=� x,ι,τ�beatransitionsystemandπapredicate.
Theinvariant checkingproblem is to decide whetherMsatisﬁesπ. Amodel checkersolves the invariant checking
problembyexploringM-reachablestatesandstoringthem
inpredicates. WhenMdoesnotsatisfyπ,amodelchecker
returns a sequence of predicates [S 0(x),S1(x),...,Sk(x)]
that
1.|=S 0⇒ι(everyx-statein[[S 0]]isM-initial);
2.|=∃x.Sk∧ ¬π(anx-statein[[Sk]]doesnotsatisfyπ);
and
3.for every 0< i≤k,|=S i⇒ ∃�x.Si−1(�x)∧τ(�x,x)
(everyx-statein[[Si]]isanM-successorofan x-state
in[[S i−1]]).
The sequence [S 0,S1,...,Sk] is called awitnesstoM�|=
π.3For a transition systemM=� x,ι,τ�and a witness
[S0,S1,...,Sk]toM�|=π,anM-traceσ=[s 0,s1,...,sk]is
representedin[S 0,S1,...,Sk]ifsi|=Siforevery0≤i≤k.
For any witness [S 0,S1,...,Sk] toM�|=π, there is anM-
traceσrepresentedin[S 0,S1,...,Sk]suchthatσ�|=π. Note
thatawitnessrepresentsasetofM-traces.
LetM i=�xi,ιi,τi�betransitionsystemsfori=0,1( xi’s
are not necessarily disjoint). The compositionM 0�M1=
�x,ι,τ�isatransitionsystemwhere x=x0∪x1,ι=ι 0∧ι1,
andτ=τ 0∧τ1. Theprojections| yof anx-stateson
y⊆xisay-statesuchthats| y(y)=s(y)fory∈ y. The
projectionσ| yofasequenceσ=[s 0,s1,...,sn]ofx-states
ony⊆xis the sequence [ s0|y,s1|y,· · ·,sn|y] ofy-states.
Notethatσ∈ Tr(M0�M1)ifandonlyifσ| x0∈Tr(M0)and
σ|x1∈Tr(M 1).
LetM=� x,ι,τ�be a transition system. A transition
systemN=� x,λ,θ�simulatesM(writtenM�N) if
|=ι⇒λand|=τ⇒θ. Inotherwords,NsimulatesMif
everyM-initial x-stateisN-initial,andeveryM-transition
isalsoanN-transition.
Aproof ruleis of the formΦ0Φ1· · ·Φk
Ψwhere
Φ0,...,Φkarethepremisesoftheproofrule,andΨisits
conclusion. Aproofruleissoundifitsconclusionholdswhen
itspremisesarefulﬁlled;itisinvertibleifitspremisescan
befulﬁlledwhenitsconclusionholds.
Theorem 1 ([12]). LetM i=�xi,ιi,τi�be transition
systems fori=0,1, x=x0∪x1, andπ(x)a predicate. The
following proof rule is sound and invertible:
M1�A M 0�A|=π
M0�M1|=π
IntheproofruleofTheorem1,thetransitionsystemAis
calledacontextual assumptionofM 0.
4. IMPLICITLEARNINGFRAMEWORK
In automated assume-guarantee reasoning through im-
plicit learning [12], a learning algorithm for predicates is
usedtogeneratecontextualassumptionsautomatically. In
thissection,wereviewBDDlearningandtheframeworkof
assume-guaranteereasoningwithimplicitlearning.
4.1 LearningBDD’s
Letf(x)beanunknowntargetpredicate. ABDDlearning
algorithminfers BDD(f)bymakingqueries. Itassumesa
3Most model checkers only report sequences of states for
debuggingpurposes,butsuchwitnessesareinfactcomputed.1073IsEquivalent(λ(x 1), θ(x 1,x�
1))equivalence resolutionmembership
resolution
IsMember ιA(s)membership
resolution
IsMember τA(s, t)
Learner ιAMEM ιA(s)
YES,NO
EQιA(BDD(λ))
YES, sMEM τA(s, t)
YES,NO
EQτA(BDD(θ))
YES,(s, t)Learner τA
Figure 2: Implicit Learning FrameworkYESifs|=fMEM(s)
NOotherwise
EQ(BDD(h))
YESifBDD(f) =BDD(h)
cewithce|=f⊕hotherwiseLearning
AlgorithmTeacher
Figure 1: Angluin’s Learning Model
teacherwhoknowsthetargetpredicatefandanswersthe
followingtypesofqueries(Figure1)[2,6,23,31]:
•Membership queries MEM (s) withs∈ Val x. Ifs|=
f, the teacher answers YES; otherwise, the teacher
answersNO.
•Equivalence queries EQ(BDD(h)) with aconjecture
BDD(h(x)). IfBDD(f) =BDD(h), the teacher an-
swersYES. Otherwise,theteachersendsacounterex-
ample ce∈Val xsuchthatce|=f⊕hwhere⊕isthe
exclusive-oroperator.
Amembershipquery MEM (s)asksiftheunknowntarget
predicatefevaluatesto ttunderthevaluations∈ Val x. An
equivalencequery EQ(BDD (h)),ontheotherhand,purports
aconjecturehandasksif BDD(f)=BDD(h). Recallthat
BDD’s are canonical. When BDD(f)�=BDD(h),f�=h.
Hence there is a valuationce∈ Val xsuch thatfandh
evaluate to diﬀerent truth values. In other words,f⊕h
evaluatesto ttunderacertaince. Theteacherreturnssuch
avaluationceasacounterexampletotheequivalencequery.
Since the number of predicates over xis ﬁnite, any un-
known predicate can be inferred by enumeration. For in-
stance,onecanobtainthetruthtableoftheunknowntarget
predicatebyasking2|x|membershipqueriesandgeneratethe
BDDaccordingly. ThenaiveBDDlearningalgorithmhow-
everrequiresanexponentialnumberofmembershipqueries
inthenumberofBooleanvariables. Remarkably,itisshown
thattheBDDofanarbitrarytargetpredicatecanbelearned
withinalinearnumberofequivalenceandaquadraticnumber
ofmembershipqueriesinitssize.Theorem 2 ([31]). For any unknown target predicate
f(x), one can infer BDD(f)with at mostnequivalence
queries and2n(� lgm�+3n)membership queries wherenis
the size of BDD (f)andmis the number of Boolean variables
inx.
4.2 ImplicitLearning
Thebasicideaofimplicitlearningistoguidethelearning
algorithmtoinfertheinitialandtransitionpredicatesofa
contextualassumption[20,12]. Sinceacontextualassump-
tion consists of two predicates, two instances of the BDD
learning algorithm are deployed. The instance Learner ιA
inferstheinitialpredicateofacontextualassumption,and
theotherinstance Learner τAinfersitstransitionpredicate.
Bothinstancesmakemembershipandequivalencequeriesto
amechanicalteacher. Figure2showstheimplicitlearning
framework. For clarity, subscripts are used to diﬀerenti-
ate queries from the two learners in the ﬁgure: Learner ιA
makesmembershipquery MEM ιA(s)andequivalencequery
EQιA(BDD(λ)); andLearner τAmakes membership query
MEM τA(s,t)andequivalencequeryEQτA(BDD(θ)).
Foramembershipquery MEM ιA(s),themechanicalteacher
checksifthevaluationssatisﬁestheinitialpredicateofM 1.
If so, the mechanical teacher answers YES. Otherwise, it
answersNO. Conceptually, the mechanical teacher uses
theinitialpredicateofM 1astheunknowntargetpredicate
(Algorithm1). Ifnoothercontextualassumptionisfound,
Learner ιAwilleventuallyinfertheinitialpredicateofM 1.
//M 1=�x 1,ι1,τ1�
Input:s∈Val x1: avaluation
Output:YESorNO
ifs|=ι 1thensendYESelsesendNO;
Algorithm 1:IsMember ιA(s)
Similarly,membershipqueriesfrom Learner τAareresolved
byusingthetransitionpredicateofM 1astheunknowntarget
predicate (Algorithm 2). Again, Learner τAwill infer the
transitionpredicateofM 1eventuallyifnoothercontextual
assumptionisfound. Observethatmembershipqueriesfrom
thelearnersareresolvedseparately. Synchronizationisnot
neededbetweenmembershipqueryresolutionalgorithms.
Equivalencequeries,ontheotherhand,requiresynchro-
nization. Assumethat Learner ιAmakesanequivalencequery
EQιA(BDD(λ)). The mechanical teacher has to answer
whetherBDD (λ)representstheinitialpredicateofacontex-1074j←0
no
no
j←j+1remove spurious transitions between [[ Sj]],[[S j+1]] (Algorithm 5) and compute Sj+1remove spurious states from [[S 0]] (Algorithm 4) and compute S0
j=k?[[Sj]] =∅?yesspurious states are removed
apply assume-guarantee reasoning
(Algorithm 3)
yes
M0�M 1�|=π[[Sk]]∩[[¬π]] =∅
no
yes
Figure 3: Overview of Progressive Witness Analysis
//M 1=�x 1,ι1,τ1�
Input:s,t∈Val x1: valuations
Output:YESorNO
if(s,t)|=τ 1thensendYESelsesendNO;
Algorithm 2:IsMember τA(s,t)
tualassumptionA. Todoso,itneedstocheckifthepremises
M1�AandM 0�A|=πhold. Themechanicalteacherneeds
the transition predicate of the contextual assumptionA
in order to check the premise. Hence the EQιA(BDD(λ))
fromLearner ιAcannotberesolvedwithouttheconjecture
BDD(θ(x1,x�
1)) inEQτA(BDD(θ)) fromLearner τA. Simi-
larly,theEQτA(BDD (θ))fromLearner τAcannotberesolved
withouttheconjecture BDD (λ(x1))inEQιA(BDD (λ))from
Learner ιA. Resolvingeitheroftheequivalencequeriesmust
besynchronizedwiththeother. Subsequently,thereisbut
oneequivalencequeryresolutionalgorithminthemechanical
teacher.
Whentheequivalencequeryresolutionalgorithmreceives
the queriesEQιA(BDD(λ)) andEQλA(BDD(θ)) from the
learners,themechanicalteacherconstructsapurportedcon-
textualassumptionA −1=�x1,λ,θ�andchecksifA −1can
serveasacontextualassumption(Algorithm3). Thealgo-
rithmﬁrstveriﬁesifA −1simulatesM 1. Ifnot,acounterex-
ampleissentto Learner ιAorLearner τA. IfA −1simulates
M1,Algorithm3theninvokesamodelcheckertoverifythe
premiseM 0�A−1|=π. If the premise is also fulﬁlled, the
proof rule in Theorem 1 applies. By the soundness of the
proof rule, the mechanical teacher reports“M 0�M1|=π.”
Otherwise,awitness[S 0,S1,...,Sk]toM 0�A−1�|=πisob-
tained from the model checker. Recall thatM 1�A −1.
[S0,S1,...,Sk]isnotnecessarilyawitnesstoM 0�M1�|=π.
Particularly, the witness may represent anM 0�A−1-trace
thatdoesnotsatisfyπeventhoughM 0�M1|=π. Further
analysisisrequiredforthewitnesstoM 0�A−1�|=π.//M i=�x i,ιi,τi�fori=0,1andx=x 0∪x1
Input:λ(x 1): aninitialpredicate;θ(x 1,x�
1): a
transitionpredicate
Output:“M 0�M1|=π”,awitnesstoM 0�M1�|=π,a
counterexampletoEQιA(BDD(λ)),ora
counterexampletoEQτA(BDD(θ))
A−1← �x 1,λ,θ�;
ifs|=ι 1∧ ¬λthen
sendsasthecounterexampletoEQιA(BDD(λ));
receiveanequivalencequeryEQιA(BDD(λ�));
returnIsEquivalent(λ�,θ);
if(s,t)|=τ 1∧ ¬θthen
send(s,t)asthecounterexampleto EQτA(BDD (θ));
receiveanequivalencequeryEQτA(BDD(θ�));
returnIsEquivalent(λ,θ�);
ifM 0�A−1|=πthen report“M 0�M1|=π”;
let[S 0,S1,...,S k]beawitnesstoM 0�A−1�|=π;
returnAnalyzeWitness(A −1,S0,S1,...,S k);
Algorithm 3:IsEquivalent(λ,θ)
5. ANALYZINGSYMBOLICWITNESSES
Inordertodescribewitnessanalysis,weidentifyinvalid
behaviors. LetAbe a purported contextual assumption.
AnM 0�A-initialstateisspuriousifitisnotM 0�M1-initial;
andanM 0�A-transitionisspuriousifitisnotanM 0�M1-
transition. Similarly,anM 0�A-traceisspuriousifitisnotan
M0�M1-trace;andanM 0�A-reachablestateisspuriousifit
isnotM 0�M1-reachable. Consideratraceσ∈ Tr(M0�A−1)
suchthatσ�|=π. Thenσ| x0∈Tr(M0)andσ| x1∈Tr(A−1).
Letσ| x1=[s0,s1,...,sn]. Ifs 0isM1-initialand(s i,si+1)is
anM 1-transitionforevery0≤i < n,thenσ| x1isinfactan
M1-trace. WeconcludeM 0�M1�|=π. If,forinstance,(s 3,s4)
is not anM 1-transition, then (s 3,s4) is a spuriousA −1-
transition. Weshouldreturn(s 3,s4)asacounterexampleso
thatthelearningalgorithmremovesthespurioustransition
fromfutureconjectures. Sinceonlyonetraceisinspected,
wecallthisprocedurethesimple witness analysisalgorithm.
In [12, 11], a SAT-based symbolic model checker is used1075to verify the premiseM 0�A−1|=π. Since a SAT-based
symbolicmodelcheckerreturnsonlyonetraceasawitnessto
M0�A−1�|=π,thesimplewitnessanalysisalgorithmapplies.
Similarly, the simple algorithm suﬃces when an explicit
modelcheckerisused[20,19].
The situation becomes slightly more complicated if the
mechanicalteacherusesasymbolicmodelchecker. Inthis
case,awitnesstoM 0�A−1�|=πrepresentsanumberoftraces
ingeneral. Themechanicalteachercouldpickanarbitrary
M0�A−1-traceinthewitnessandanalyzethetraceasbefore.
Lotsofinformationinthewitnesshoweverwouldbewasted.
Consider,forinstance,spurioustransitionsofdiﬀerenttraces
representedinawitness. Sinceonlyonetraceisinspectedby
themechanicalteacher,aspurioustransitionoftheinspected
traceisreturnedasacounterexample. Spurioustransitions
inothertracesmaystillremaininthenextconjecturefrom
thelearningalgorithm. Theymayagainappearinanother
witness when the mechanical teacher checks the premises
with the next purported contextual assumption. This is
clearlyawasteofcomputationresources.
Ontheotherhand,examiningalltracesinawitnessisby
nomeansstraightforward. Awitnessrepresentsnumerous
traces. Itisinfeasibletoinspectalltransitionsinalltraces
iteratively. Moreover, BDD learning algorithms take but
one counterexample for each equivalence query. Yet the
mechanicalteacheralreadyhavenumerouscounterexamples
fromspurioustransitionsaftersymbolicmodelchecking. It
isunclearhowonemayconveyallthesecounterexamplesto
BDDlearningalgorithmseﬀectively. Thesequestionsmust
beaddressedproperlyinordertointegratesymbolicmodel
checkingwithautomatedassume-guaranteereasoning.
Weproposetoanalyzespurioustracesprogressively. Given
awitness[S 0,S1,...,Sk]toM 0�A�|=π,ourprogressivewit-
nessanalysisalgorithmworksasfollows(Figure3). First,the
algorithmobtainsapredicate S0byeliminatingallspurious
M0�A-initialstatesfrom[[ S0]]. Theset[[S0]]thuscontains
M0�M1-reachablestates. Inductively,assumethatthealgo-
rithmhasobtainedthepredicate Sjbyeliminatingallspu-
riousM 0�A-reachablestatesfrom[[ Sj]]. Theset[[Sj]]hence
containsonlyM 0�M1-reachablestates. Thewitnessanalysis
algorithm checks if [[ Sj]] is empty. If so, all known spuri-
ousM 0�A-traces are eliminated. The mechanical teacher
applies the assume-guarantee reasoning proof rule in The-
orem1withthepurportedassumptionA. Otherwise, the
algorithmobtainsapredicate Sj+1byeliminatingallspuri-
ousM 0�A-transitions. Theset[[ Sj+1]]hencecontainsonly
M0�M1-reachablestates. Whenthesequenceofpredicates
[S0,S1,...,Sk]isﬁnallyobtained,theset[[ Sk]]containsonly
M0�M1-reachablestates. If[[ Sk]]containsastatenotsatis-
fyingπ,thesequence[ S0,S1,...,Sk]isindeedawitnessto
M0�M1�|=π.
Wenowgivedetailsoftheprocedurethateliminatesspu-
rious initial states. Algorithm 4 returns a revised initial
predicateλ(x1) for the purported contextual assumption
A=� x1, λ, θ�,whichremovesspuriousM 0�A-initialstates
from [[S]]. Conceptually, Algorithm 4 considers the pur-
ported contextual assumption A=�x1,λ,θ�in the while
loop. Thecontextualassumption AisinitializedtoA. In
eachiteration,wehavean x-stateusuchthatu|=ι 0∧λbut
u�|=ι 0∧ι1. The stateu∈[[S]] is a spuriousM 0�A-initial
state. Algorithm 4 then sendsu| x1as a counterexample
toEQιA(BDD (λ)). Informally,thecounterexampleu| x1in-
formsLearner ιAthattheconjecture BDD (λ)isincorrectat//M i=�x i,ιi,τi�fori=0,1andx=x 0∪x1
Input:�x 1,λ,θ�: apurportedcontextualassumption;
S(x): apredicate
Output:λ(x1): aninitialpredicate
λ←λ;
whileu|=¬ι 1∧ι0∧λ∧Sdo
//A=�x 1,λ,θ�is the purported contextual
assumption
sendu| x1asthecounterexampletoEQιA(BDD(λ));
receiveanequivalencequeryEQιA(BDD(λ�));
λ←λ�;
end
return λ;
Algorithm 4:UpdateInit(�x 1,λ,θ�,S)
thevaluationu| x1. Afterreceivinganewequivalencequery
EQιA(BDD (λ�)),Algorithm4considersthenewpurported
contextualassumption�x 1,λ�,θ�inthenextiteration.
Whenthealgorithmreturnsaninitialpredicate λ,wehave
|=[ι0∧λ∧S]⇒ι 1andhence|=[ι 0∧λ∧S]⇒[ι 0∧ι1]. That
is,everyM 0�A-initialstateisalsoM 0�M1-initial. Notethat
AdoesnotnecessarilysimulateM 1. Lemma1summarizes
UpdateInit(�x 1,λ,θ�,S)(Algorithm4).
Lemma1.LetM i=�xi,ιi,τi�be transition systems for
i=0,1and x=x0∪x1. Ifλ(x1)is returned by UpdateInit
(�x1,λ,θ�,S)(Algorithm 4), then|=[ι 0∧λ∧S]⇒[ι 0∧ι1].
The mechanical teacher eliminates spurious transitions
from reachable states in a similar manner. Algorithm 5
returnsarevisedtransitionpredicate θ(x1,x�
1)forthepur-
portedcontextualassumptionA=� x1,λ,θ�,whichremoves
spuriousM 0�A-transitionsbetween[[R]]and[[S]]. Conceptu-
ally,Algorithm5considersthepurportedcontextualassump-
tionA=�x1,λ,θ�inthewhileloop. Atﬁrst,thecontextual
assumptionAisA. Ineachiteration,wehaveatransition
(u,v)∈[[R]]×[[S]]suchthat(u,v)|=τ 0∧θbut(u,v)�|=τ 0∧τ1.
TheM 0�A-transition(u,v)between[[R]]and[[S]]isspurious.
Algorithm5thensends(u| x1,v|x1)asacounterexampleto
EQτA(BDD (θ)). Thecounterexample(u| x1,v|x1)eﬀectively
informsthelearningalgorithmthattheconjecture BDD (θ)is
incorrectatthevaluation(u| x1,v|x1). Afterreceivinganother
equivalencequery EQτA(BDD(θ�)),Algorithm5considers
thenewpurportedcontextualassumption� x1,λ,θ��inthe
nextiteration.
Whenthealgorithmreturnsatransitionpredicate θ,we
have|= [τ 0∧θ∧R∧S(x�)]⇒τ 1and hence|= [τ 0∧θ∧
R∧S(x�)]⇒[τ 0∧τ1]. That is, everyM 0�A-transition
between[[R]]and[[S]]isalsoanM 0�M1-transition. Notethat
AdoesnotnecessarilysimulateM 1. Thefollowinglemma
summarizesUpdateStep(�x 1,λ,θ�,R,S)(Algorithm5).
Lemma2.LetM i=�xi,ιi,τi�be transition systems for
i= 0,1and x=x0∪x1. If θ(x1,x�
1)is returned by
UpdateStep (�x1,λ, θ�, R, S)(Algorithm 5), then|= [τ 0∧
θ∧R∧S(x�)]⇒[τ 0∧τ1].
We are ready to give details of our progressive witness
analysisalgorithm. Thewitnessanalysisalgorithmproceeds
bystages(Algorithm6). LetA −1=�x1,λ,θ�beapurported1076//M i=�x i,ιi,τi�fori=0,1andx=x 0∪x1
Input:�x 1,λ,θ�: apurportedcontextualassumption;
R(x),S(x): predicates
Output:θ(x1,x�
1): atransitionpredicate
θ←θ;
while(u,v)|=¬τ 1∧τ0∧θ∧R∧S(x�)do
//A=�x 1,λ,θ�is the purported contextual
assumption
send(u| x1,v|x1)asthecounterexampleto
EQτA(BDD(θ));
receiveanequivalencequeryEQτA(BDD(θ�));
θ←θ�;
end
return θ;
Algorithm 5:UpdateStep(�x 1,λ,θ�,R,S)
contextualassumptionwithM 1�A−1,and[S 0,S1,...,Sk]
awitnesstoM 0�A−1�|=π. Thewitnessanalysisalgorithm
ﬁrst invokes UpdateInit (A−1,S0) (Algorithm 4) to ﬁnd an
initialpredicate λ(x1). Deﬁneθ0=θ,A 0=�x1,λ,θ0�,and
S0=ι0∧λ∧S0. ByLemma1,everyM 0�A0-initialstatein
[[S0]]isM 0�M1-initial. Thefollowinglemmasummarizesthe
ﬁrsttwolinesofAlgorithm6.
Lemma3.LetM i=�xi,ιi,τi�be transition systems for
i=0,1and x=x0∪x1. Right after line 2 of Algorithm 6,
we have
1.|=S0(x)⇒S 0(x); and
2. everyx-state in[[ S0]]isM 0�M1-reachable.
//M i=�x i,ιi,τi�fori=0,1andx=x 0∪x1
Input:A −1=�x 1,λ,θ�: apurportedcontextual
assumption;[S 0(x),S1(x),...,Sk(x)]: awitness
toM 0�A−1�|=π
Output: “M 0�M1|=π”,awitnesstoM 0�M1�|=π,a
counterexampletoEQιA(BDD(λ)),ora
counterexampletoEQτA(BDD(θ))
λ←UpdateInit(A −1,S0)(Algorithm4); 1
S0←ι0∧λ∧S 0; 2
θ0←θ;3
forj←0tok−1do4
Aj← �x 1,λ,θj�; 5
if|=¬ Sjthen 6
returnIsEquivalent( λ,θj)(Algorithm3); 7
else 8
θj+1←UpdateStep(A j,Sj,Sj+1)(Algorithm5); 9
Sj+1← 10
∃�x.τ0(�x0,x0)∧θj+1(�x1,x1)∧Sj(�x)∧S j+1;
end 11
end12
if|=∃x. Sk∧ ¬πthen report[ S0,S1,...,Sk]; 13
else returnIsEquivalent( λ,θk)(Algorithm3); 14
Algorithm 6:AnalyzeWitness(�x 1,λ,θ�,S 0,S1,...,S k)
Atstagej,wehaveobtainedaset[[ Sj]]ofM 0�M1-reachable
statesandapurportedcontextualassumptionA j=�x1,λ,θj�.ThewitnessanalysisalgorithmeliminatesspuriousM 0�Aj-
transitionsfrom[[ Sj]]byinvoking UpdateStep (Aj,Sj, Sj+1)
(Algorithm5). Itthusobtainsatransitionpredicate θ(x1,x�
1).
Deﬁneθj+1=θ,Aj+1=�x1,λ,θj+1�, andSj+1=∃�x.
τ0(�x0,x0)∧θj+1(�x1,x1)∧Sj(�x)∧S j+1. By Lemma 2,
everyM 0�Aj+1-transitionbetween[[ Sj]]and[[Sj+1]]isalso
anM 0�M1-transition. Hence [[ Sj+1]] consists ofM 0�M1-
reachablestates. Thewitnessanalysisalgorithmthenpro-
ceedstothenextstage. Thefollowinglemmasummarizes
aniterationoftheforloopatline4ofAlgorithm6.
Lemma4.LetM i=�xi,ιi,τi�be transition systems for
i=0,1and x=x0∪x1. At line 12 of Algorithm 6, we have
1.|=Sj+1(x)⇒S j+1(x); and
2. everyx-state in[[ Sj+1]]isM 0�M1-reachable.
ByLemma3and4,[[[ S0]],[[S1]],...,[[Sj]]]isasequenceof
M0�M1-reachablex-states. Therearetwoscenarios:
•[[Sj]] is empty for some 0≤j < k. [ S0,S1,...,Sj]
cannotbeawitnesstoM 0�M1�|=π. Recallthatthe
purportedcontextualassumptionA jdoesnotnecessar-
ilysimulateM 1. Thewitnessanalysisalgorithminvokes
Algorithm3tocheckifA jcanserveasacontextual
assumption(line7,Algorithm6).
•Noneof[[S0]],[[S1]],...,[[Sk−1]]isempty. Algorithm6
checks whether there is an x-state in [[Sk]] violating
thepredicateπ. Ifso,[ S0,S1,...,Sk]isawitnessto
M0�M1�|=π. Otherwise,thewitnessanalysisalgorithm
invokesAlgorithm3tocheckifA k=�x1,λ,θk�canbe
acontextualassumption(line13,Algorithm6).
Note that the witness analysis algorithm does not per-
formmodelchecking. Itinsteadrevisespurportedcontextual
assumptionsbyinspectingthewitnessprogressively. Only
when all known spurious initial states and transitions are
accountedfor,canassume-guaranteereasoningbeperformed
withpurportedcontextualassumptions. Alsonotethatpur-
portedcontextualassumptionsarenotincreasinglystronger.
Thelearningalgorithmhasnoinformationaboutunqueried
M1-transitions. Itisfreetoincludesuchtransitionsarbitrar-
ily. The relation between successive purported contextual
assumptionsisthusverydiﬀerentfromthoseofcounterex-
ampleguidedabstractionreﬁnement[17].
Theorem 3 (Soundness). LetM i=�xi,ιi,τi�be tran-
sition systems fori= 0,1, x=x0∪x1, andπ(x),λ(x1),
θ(x1,x�
1)predicates.
1.IfIsEquivalent (λ,θ)(Algorithm 3) reports “M 0�M1|=
π,” then the purported contextual assumptionA=� x1,
λ, θ�fulﬁlls both premises of the proof rule in Theo-
rem 1.
2.IfIsEquivalent (λ,θ)(Algorithm 3) reports a sequence
of predicates[ S0,S1,...,Sk]for somek≥0, then
[S0,S1, ...,Sk]is a witness toM 0�M1�|=π.
For completeness, recall that the predicatesι 1andτ 1
are the target predicates of Learner ιAandLearner τAre-
spectively. The transition systemM 1will be inferred as
a purported contextual assumption if no other contextual
assumptionisfound. Algorithm3canthendecidewhether
M0�M1satisﬁesπconclusively.1077Theorem 4 (Completeness). LetM i=�xi,ιi,τi�be
transition systems fori= 0,1, x=x0∪x1, andπ(x)a
predicate.
1.IfM 0�M1|=π, Learner ιAandLearner τAwill in-
fer certain predicatesλ( x1)andθ(x1,x�
1)such that
IsEquivalent (λ,θ)(Algorithm 3) reports “M 0�M1|=π.”
2.IfM 0�M1�|=π, Learner ιAandLearner τAwill in-
fer certain predicatesλ( x1)andθ(x1,x�
1)such that
IsEquivalent (λ,θ)(Algorithm 3) returns a sequence
[S0,S1, ...,Sk]for somek≥0.
Optimizations: TheBDDlearningalgorithmsin[23,31]
arebasedonthelearningalgorithmsforregularlanguages[2,
29]. As observed in [11], the ﬁrst equivalence query made
byBDDlearningalgorithmsisalways EQ(BDD(ﬀ))when
there is more than one Boolean variable. BDD learning
algorithms hence revise the ﬁrst purported contextual as-
sumptionA −1=�x1,ﬀ,ﬀ�byaddingM 1-initialx1-statesor
M1-transitions. Consequently,BDDlearningalgorithmsof-
teninferthecomponentM 1asacontextualassumption. By
complementingqueriesfromBDDlearningalgorithms,one
canensuretheﬁrstequivalencequerytobe EQ(BDD(tt))
andhenceobtainmoreeﬀectivecontextualassumptions[11].
//M 0=�x 0,ι0,τ0�,A −1=�x 1,λ,θ�andx=x 0∪x1
Input: awitness[S 0(x),S 1(x),...,S k(x)]to
M0�A−1�|=π
Output: awitnesstoM 0�A−1�|=πcontainsonly
tracesviolatingπ
Sk←Sk∧ ¬π;
forj←k−1to0do
Sj←Sj∧ ∃x�.τ0(x0,x�
0)∧θ(x 1,x�
1)∧S j+1(x�);
end
return[S 0,S1,...,S k];
Algorithm 7:WitnessBackward([S 0,S1,...,S k])
Wecanfurtherreducethenumberofspurioustracesfrom
symbolicmodelchecking. Witnessesobtainedbysymbolic
modelcheckersmaycontainunnecessaryinformation. Con-
siderawitnesstoM 0�A−1�|=π. IfaspuriousM 0�A−1-trace
in the witness satisﬁesπ, it is not useful in revising the
contextualassumption. Subsequently,itismoreeconomic
toconsiderM 0�A−1-tracesviolatingπinthewitness. When
thewitnessanalysisalgorithm(Algorithm6)obtainsawit-
ness[S 0,S1,...,Sk]toM 0�A�|=π,themechanicalteacher
shouldperformbackwardimagecomputationtoobtainuseful
spurioustracesfromthewitness(Algorithm7).
6. EXPERIMENTS
Wecomparethreediﬀerentveriﬁcationtechniquesintheex-
periments: theNuSMVmonolithicsymbolicmodelchecking,
automatedassume-guaranteereasoningwithsimplewitness
analysis,andautomatedassume-guaranteereasoningwith
progressive witness analysis. The two automated assume-
guaranteereasoningtechniquesareimplementedinNuSMV
[15]. Bothadopttheclassiﬁcationtree-basedBDDlearning
algorithmtoinfercontextualassumptions[31].
Five examples are reported in the experiments: mini-
Rubik’s cube [36], Rubik’s cube, dining philosophers, din-
ingcryptographers[10],andanindustrialgatecontrolsys-
tem[37]. WeheuristicallychoosecomponentstogenerateTable 1: Mini-Rubik’s Cube
propertynotsolved overlap2
peaktimepeaktime
NuSMV 6.41×10616.69s7.28×1071575.37s
AG1 ----
AG*1.78×1063.08s3.61×107571.36s
Table 2: Rubik’s Cube
propertycorner centercorner
peaktimepeaktime
NuSMV ––––
AG1 ––––
AG*1.31×107300.24s3.79×106540.39s
propertyoverlap3
peaktime
NuSMV ––
AG1 ––
AG*3.22×107363.41s
contextualassumptionsfrom. Eachexperimentisallocated
withoneCPUcoreand4GBofmemory. Allexperiments
areconductedona64-bitLinux3.2.0serverwith42.40GHz
IntelXeonE5620quadcoreCPU’sand32GBRAM.
Mini-Rubik’s cube.A mini-Rubik’s cube is the 2×2×2
versionoftheRubik’scube. Thereareeightminiaturecubes
(calledcubies)inthemini-Rubik’scube. Eachcubiecanbe
located in eight diﬀerent positions. It moreover has three
visiblefacetsandhencethreeorientationsineachposition.
Subsequently, a state of the mini-Rubik’s cube consists of
thepositionandtheorientationofitseightcubies(Table1).
Inthetable,therowNuSMVshowstheresultsofmono-
lithic symbolic model checking. The rowsAG1andAG∗
show the results of assume-guarantee reasoning with the
simpleandourprogressivewitnessanalysisalgorithms(Algo-
rithm6)respectively. Thecolumn“peak”showsthenumber
ofpeakBDDnodesduringveriﬁcation. Finally,theveriﬁ-
cationtimeisshown. Inthetable,thesymbol“–”indicates
eithermemory-out(4GB)ortime-out(7200seconds).
The propertynotsolvedspeciﬁes that the mini-Rubik’s
cube cannot be solved. It fails from a chosen initial state.
Awitnessgivesasolutiontothepuzzle. Assume-guarantee
reasoningwiththesimplewitnessanalysisalgorithmdoes
notﬁnishwithinthegiventimelimit. Monolithicsymbolic
modelcheckingusesmorethansixmillionspeakBDDnodes.
On the other hand, assume-guarantee reasoning with our
progressivewitnessanalysisalgorithmrequireslessthantwo
millionsofpeakBDDnodes,andimprovestheveriﬁcation
timeby81%. Thepropertyoverlap2speciﬁesthattheﬁrst
twocubiescannotbeinthesamepositionfromeveryinitial
state. Monolithic symbolic model checking requires more
than seventy millions of peak BDD nodes and takes more
thantwenty-sixminutestoconcludetheveriﬁcation. Assume-
guaranteereasoningwithournewwitnessanalysisalgorithm
usesahalfofpeakBDDnodesandimprovestheveriﬁcation
timeby64%.
Rubik’s Cube.A3×3×3Rubik’scubehastwentysixvisible
cubies. Wepartitionvisiblecubiesintothreetypes. Theﬁrst
typeconsistsofsixcubiesatthecenterofsixfacesofthe
cube. Eachcubieoftheﬁrsttypehasonlyonevisiblefacet1078Table 3: Dining Philosophers
nodes4 5
peaktimepeaktime
NuSMV 2.16×1062.63s4.77×10655.51s
AG11.41×1061.62s2.44×10623.32s
AG*1.41×1061.46s2.44×10623.28s
nodes6 7
peaktimepeaktime
NuSMV 5.23×1071215.90s ––
AG16.95×106231.67s3.53×1071796.82s
AG*6.95×106227.10s3.53×1071815.30s
and thus one orientation. The second type contains eight
cubiesatthecornersofthecube. Eachcubieofthistype
hasthreevisiblefacetsandthreeorientations. Thelasttype
ofcubiesareontheedgesoftheRubik’scube. Eachedge
cubiehastwovisiblefacetsandtwoorientations.
Table 2 shows the experimental results. The property
cornerspeciﬁesthattheeightcornercubiescannotbeattheir
solved positions from a chosen initial state. The property
centercornerstatesthattheﬁrsttwotypesofcubiescannot
beattheirsolvedpositionsfromachoseninitialstate. The
propertyoverlap3speciﬁesthattheﬁrsttwocentercubies
cannotbeatthesamepositionfromeveryinitialstate. For
eachproperty,neithermonolithicsymbolicmodelchecking
nor assume-guarantee reasoning with the simple witness
analysis algorithm can verify these properties within the
givenresourcebound. Ontheotherhand,assume-guarantee
reasoning with our progressive witness analysis algorithm
performsratherwell. Theinferredcontextualassumptions
are signiﬁcantly smaller than their targets. Subsequently,
assume-guaranteereasoningwithprogressivewitnessanalysis
isabletoverifyallpropertiesinthisexample.
Dining Philosophers.Inthisexample,nphilosopherssitin
aroundtable. Twoneighboringphilosophersshareafork.
Whenaphilosopherdecidestoeat,shehastopickupthe
twoforkssharedwithhertwoneighbors. Intheexperiment
withnnodes,therearenprocessesforphilosophersandn
forforks. Weverifythattheﬁrsttwophilosopherscannot
eatatthesametime(Table3).
Monolithicsymbolicmodelcheckingisagainoutperformed
bybothautomatedassume-guaranteereasoningtechniques.
Itcannotverifytheexperimentwith7philosopherswhereas
assume-guarantee reasoning can ﬁnish the veriﬁcation in
about30minutes. Alsonotethatmonolithicsymbolicmodel
checking always has a larger number of peak BDD nodes.
Intheexperimentwith6nodes,thenumberisanorderof
magnitudemorethanthoseofassume-guaranteereasoning.
Dining Cryptographers.The dining cryptographers prob-
lemisanexampleofprivacyprotocols. Intheproblem,n
cryptographers dine around a table. After ﬁnishing their
meal, they are told that the meal has been paid for. The
cryptographersarecurioustoknowwhethertheyaretreated
byanunknowngenerousfundingagencyorbyacolleague
amongthemselves. Beingcryptographers,theyrespecttheir
privacyverymuch. Ifacolleaguepaid,thecryptographersdo
notwishtoidentifytheperson. Thediningcryptographers
problem is to determine whether a funding agency or an
anonymouscryptographerpaidthemeal.Table 4: Dining Cryptographers
n9 10
peak timepeak time
NuSMV 9.42×106154.29s21.27×106576.64s
AG1 - - - -
AG∗9.45×106215.43s19.98×106821.77s
n11 12
peak timepeak time
NuSMV 38.79×1061823.84s - -
AG1 - - - -
AG∗40.40×1061866.74s72.28×1065715.22s
Thecryptographerscansolvetheproblemasfollows. Ini-
tially, each cryptographer selects a secret bit. She then
obtains a shared secret bit with her left neighbor (say, by
computingtheparityoftheirtwosecretbits). Similarly,she
obtains another secret bit shared with her right neighbor.
Eachcryptographerthenannouncesabit. Ifshedidnotpay
themeal,sheannouncestheparityofhertwosharedbits.
Ifshepaid,thecomplementoftheparityofhertwoshared
bits is announced. It can be shown that the parity of all
announcedbitsisevenifanunknownfundingagencypays
thebill. Weverifythisfactintheexample.
Automatedassume-guaranteereasoningwithprogressive
witnessanalysisisabletoverify12cryptographerswithin
1.6 hours. In fact, the veriﬁcation of 13 cryptographers is
completewithin4.2hours. Incontrast,monolithicsymbolic
modelcheckingusesup4GBofmemoryon12cryptographers.
If we increase the memory bound to 8GB, the monolithic
techniqueisabletoverifytheinstanceof12cryptographersin
15.8hoursbutstillcannotﬁnishtheinstanceof13cryptogra-
phers. Assume-guaranteereasoningwithprogressivewitness
analysisoutperformsmonolithicmodelcheckingforthisex-
ample. Ontheotherhand,assume-guaranteereasoningwith
simple witness analysis performs very disappointingly. It
failstoverifyanyinstancewithmorethanninecryptogra-
phers. Analyzingwitnessesprogressivelyisessentialtotake
fulladvantagesofassume-guaranteereasoninginthedining
cryptographersproblem.
Gate Control System. DesignedforaBuddhistceremonyon
astage,thegatecontrolsystemisusedinLingShanBuddhist
PalaceinJiangsu, China[37]. Thesystem consistsof ﬁve
parts: thecontroller,liftingplatform,push-pullunit,latch,
andmotors. Theliftingplatform,push-pullunit,andlatch
liftgatestoandfromthewarehouseunderthestage. Amotor
is attached to each gate and moves along a circular track.
All these devices are operated by the controller. Figure 4
showsthesystemarchitecture.
Considertheopeningsceneoftheceremony,whereevery
gate arises from the warehouse orderly and moves to the
circulartrack. Inordertobringgatesfromthewarehouse
underneath, the lifting platform elevates a gate from the
warehousetothestage. Apush-pullunitthenpushesthe
gatetothecirculartrack. Attheclosingscene,amotorﬁrst
movesagateadjacenttotheliftingplatformalongthetrack.
Apush-pullunitthenpullsthegatefromthecirculartrack
totheplatform. Finally,theliftingplatformdescendsthe
gatetothewarehousebelow. Forsafetyreasons,alatchlocks
theliftingplatformwhentheplatformgetstoadesignated1079Table 5: Gate Control System
propertygate1 gate2 lpf1 lpf2
peaktimepeaktimepeaktimepeaktime
NuSMV 0.561×1060.49s0.561×1060.49s0.884×1061.13s0.884×1061.15s
AG10.702×1061.03s0.338×1060.28s0.471×1064.36s1.190×1062.87s
AG*0.370×1060.45s0.218×1060.45s0.282×1060.62s0.283×1060.61s
propertylatch1 latch2 ppu
peaktimepeaktimepeaktime
NuSMV 1.076×1061.11s1.076×1061.12s0.862×1060.83s
AG10.467×1060.82s0.596×1061.14s1.014×1061.91s
AG*0.222×1060.24s0.189×1060.49s0.482×1061.34s
Push-pull 
UnitLifting
PlatformLatchBusController
MotorsFigure 4: Structure of Gate Control System
position. Since all gates move on the same circular track,
collisionbetweengatesmustbeavoided.
Table5givestheresults. Theproperty gate1 statesthat
agatemuststopwhentheuserpressesthestopbutton. The
propertygate2 speciﬁesthatagatemuststopwhenitreaches
the boundary. The properties lpf1 ,latch1 , andppu are
similartogate1 exceptthedevicesaretheliftingplatform,
latch,andpush-pullunit,respectively. Theproperties lpf2
andlatch2 aresimilarto gate2 exceptthedevicesarethe
liftingplatformandlatch,respectively.
For all properties but ppu, assume-guarantee reasoning
withprogressivewitnessanalysisismoreeﬃcientthanthe
NuSMVmonolithicveriﬁcationalgorithm. Onaverage,our
newtechniqueattains25.9%ofspeedup. Assume-guarantee
reasoning with progressive witness analysis moreover im-
provesmemoryeﬃciency. Forthesevenpropertiesveriﬁed
onthegatecontrolsystem,assume-guaranteereasoninguses
lesspeakBDDnodes. Itsaves62.3%ofmemorythanmono-
lithicsymbolicmodelcheckingonaverage.
Assume-guaranteereasoningwithsimplewitnessanalysis
on the other hand is unsatisfactory. It takes signiﬁcantly
moretimethanmonolithicsymbolicmodelcheckinginfour
properties(gate1 ,lpf1 ,lpf2 ,andppu). Thesimplewitness
analysisalgorithmmoreoverisnotverymemoryeﬃcient. It
usesmorepeakBDDnodesthanthemonolithicveriﬁcation
algorithminthreeproperties(gate1,lpf2,andppu).
7. CONCLUSION
Symbolicmodelcheckingandautomatedassume-guarantee
reasoningareintegratedbytheprogressivewitnessanalysis
algorithmproposedinthispaper. Experimentalresultsshow
thattheourtechniquecanimprovenotonlytheeﬃciency
butalsothecapacityofsymbolicmodelchecking. Particu-larly,assume-guaranteereasoningwithprogressivewitness
analysis is more scalable than monolithic symbolic model
checking in symmetric and parametric examples such as
diningphilosophersanddiningcryptographers. Ourexperi-
mentsalsodemonstratetheimportanceofwitnessanalysisin
automatedassume-guaranteereasoningwithsymbolicmodel
checking. An ill-designed witness analysis algorithm can
signiﬁcantlyimpedetheperformance. Analyzingwitnesses
progressivelyisessentialtointegratesymbolicmodelchecking
withautomatedassume-guaranteereasoning.
In our experiments, we partition systems by trials and
hencemaynothavetheoptimalpartition. Howtopartition
systems into components remains an important and chal-
lengingproblem. Ourtechniquecurrentlyﬁndscontextual
assumptions over all context variables. Since a property
oftendependsonasubsetofcontextvariables,itsuﬃcesto
ﬁndcontextualassumptionsoversuchvariables. In[14],an
algorithminferringBooleanfunctionsoverrelevantvariables
isproposed. AsimilarlearningalgorithmforBDD’smayfur-
therimprovetheperformanceofsymbolicassume-guarantee
reasoning.
8. ACKNOWLEDGMENT
ThisworkwassupportedbytheChineseNational973Plan
(2010CB328003), the NSF of China (61272001, 60903030,
91218302),theChineseNationalKeyTechnologyR&DPro-
gram (SQ2012BAJY4052), the Importation and Develop-
mentofHigh-CaliberTalentsProjectofBeijingMunicipal
Institutions (YETP0167), the Tsinghua University Initia-
tiveScientiﬁcResearchProgram,andtheNationalScience
CouncilofTaiwan(102-2221-E-001-017-).
9. REFERENCES
[1] R.Alur,P.Madhusudan,andW.Nam.Symbolic
compositionalveriﬁcationbylearningassumptions.In
K.EtessamiandS.K.Rajamani,editors,Computer
Aided Veriﬁcation,volume3576ofLecture Notes in
Computer Science,pages548–562.Springer,2005.
[2] D.Angluin.Learningregularsetsfromqueriesand
counterexamples.Information and Computation,
75(2):87–106,November1987.
[3] D.Beyer,T.A.Henzinger,andV.Singh.Algorithms
forinterfacesynthesis.InW.DammandH.Hermanns,
editors,Computer Aided Veriﬁcation,volume4590of
Lecture Notes in Computer Science,pages4–19.
Springer,2007.
[4] B.Bollig,P.Habermehl,C.Kern,andM.Leucker.
Angluin-stylelearningofNFA.InC.Boutilier,editor,1080International Joint Conferences on Artiﬁcial
Intelligence,pages1004–1009,2009.
[5] A.J.N.BradJ.Cox.Object-Oriented Programming:
An Evolutionary Approach.Addison-Wesley,1991.
[6]N.H.Bshouty.ExactlearningBooleanfunctionviathe
monotonetheory.Information and Computation,
123(1):146–153,1995.
[7] J.R.Burch,E.M.Clarke,K.L.McMillan,D.L.Dill,
andL.J.Hwang.Symbolicmodelchecking: 1020states
andbeyond.Information and Computation,
98(2):142–170,June1992.
[8] S.Chaki,E.M.Clarke,N.Sinha,andP.Thati.
Automatedassume-guaranteereasoningforsimulation
conformance.InK.EtessamiandS.K.Rajamani,
editors,Computer Aided Veriﬁcation,volume3576of
Lecture Notes in Computer Science,pages534–547.
Springer,2005.
[9] S.ChakiandO.Strichman.OptimizedL∗-based
assume-guaranteereasoning.InO.Grumbergand
M.Huth,editors,Tools and Algorithms for the
Construction and Analysis of Systems,volume4424of
Lecture Notes in Computer Science,pages276–291.
Springer,2007.
[10] D.Chaum.Thediningcryptographersproblem:
Unconditionalsenderandrecipientuntraceability.
Journal of Cryptology,1(1):65–75,1988.
[11] Y.-F.Chen,E.M.Clarke,A.Farzan,F.He,M.-H.
Tsai,Y.-K.Tsay,B.-Y.Wang,andL.Zhu.Comparing
learningalgorithmsinautomatedassume-guarantee
reasoning.InLeveraging Applications of Formal
Methods, Veriﬁcation and Validation (1),volume6415
ofLecture Notes in Computer Science,pages643–657.
Springer,2010.
[12]Y.-F.Chen,E.M.Clarke,A.Farzan,M.-H.Tsai,Y.-K.
Tsay,andB.-Y.Wang.Automatedassume-guarantee
reasoningthroughimplicitlearning.InT.Touili,
B.Cook,andP.Jackson,editors,Computer Aided
Veriﬁcation,volume6174ofLecture Notes in Computer
Science,pages511–526.Springer,2010.
[13] Y.-F.Chen,A.Farzan,E.M.Clarke,Y.-K.Tsay,and
B.-Y.Wang.LearningminimalseparatingDFA’sfor
compositionalveriﬁcation.InS.Kowalewskiand
A.Philippou,editors,Tools and Algorithms for the
Construction and Analysis of Systems,volume5505of
Lecture Notes in Computer Science,pages31–45.
Springer,2009.
[14] Y.-F.ChenandB.-Y.Wang.Learningboolean
functionsincrementally.InM.ParthasarathyandS.A.
Seshia,editors,Computer Aided Veriﬁcation,volume
7358ofLecture Notes in Computer Science,pages
55–70.Springer,2012.
[15] A.Cimatti,E.Clarke,F.Giunchiglia,andM.Roveri.
NuSMV:anewSymbolicModelVeriﬁer.InN.
HalbwachsandD.Peled,editors,Computer Aided
Veriﬁcation,number1633inLectureNotesin
ComputerScience,pages495–499.Springer,1999.
[16] E.M.Clarke,E.A.Emerson,andJ.Sifakis.Model
checking: Algorithmicveriﬁcationanddebugging.
Communications of ACM,52(11):74–84,2009.
[17] E.M.Clarke,O.Grumberg,S.Jha,Y.Lu,and
H.Veith.Counterexample-guidedabstractionreﬁnementforsymbolicmodelchecking.Journal of the
ACM,50(5):752–794,2003.
[18] E.M.Clarke,O.Grumberg,andD.A.Peled.Model
Checking.TheMITPress,Cambridge,Massachusetts,
1999.
[19] J.M.Cobleigh,G.S.Avrunin,andL.A.Clarke.
Breakingupishardtodo: Anevaluationofautomated
assume-guaranteereasoning.ACM Trans. Software
Engineering Methodology,17(2),2008.
[20] J.M.Cobleigh,D.Giannakopoulou,andC.S.
P˘ as˘ areanu.Learningassumptionsforcompositional
veriﬁcation.InH.GaravelandJ.Hatcliﬀ,editors,Tools
and Algorithms for the Construction and Analysis of
Systems,volume2619ofLecture Notes in Computer
Science,pages331–346.Springer,2003.
[21] W.-P.deRoever,F.deBoer,U.Hanneman,
J.Hooman,Y.Lakhnech,M.Poel,andJ.Zwiers.
Concurrency Veriﬁcation: Introduction to
Compositional and Noncompositional Methods.
Number54inCambridgeTractsinTheoretical
ComputerScience.CambridgeUniversityPress,2001.
[22] C.FlanaganandS.Qadeer.Predicateabstractionfor
softwareveriﬁcation.InPrinciples of Programming
Languages,pages191–202.ACM,2002.
[23] R.Gavald` aandD.Guijarro.Learningorderedbinary
decisiondiagrams.InK.P.Jantke,T.Shinohara,and
T.Zeugmann,editors,Algorithmic Learning Theory,
volume997ofLecture Notes in Computer Science,
pages228–238.Springer,1995.
[24] M.Gheorghiu,D.Giannakopoulou,andC.S.
P˘ as˘ areanu.Reﬁninginterfacealphabetsfor
compositionalveriﬁcation.InO.Grumbergand
M.Huth,editors,Tools and Algorithms for the
Construction and Analysis of Systems,volume4424of
Lecture Notes in Computer Science,pages292–307.
Springer,2007.
[25] D.GiannakopoulouandC.S.P˘ as˘ areanu.Specialissue
onlearningtechniquesforcompositionalreasoning.
Formal Methods in System Design,32(3):173–174,2008.
[26] A.Gupta,K.L.McMillan,andZ.Fu.Automated
assumptiongenerationforcompositionalveriﬁcation.In
W.DammandH.Hermanns,editors,Computer Aided
Veriﬁcation,volume4590ofLecture Notes in Computer
Science,pages420–432.Springer,2007.
[27] A.Gupta,K.L.McMillan,andZ.Fu.Automated
assumptiongenerationforcompositionalveriﬁcation.
Formal Methods in System Design,32(3):285–301,2008.
[28] T.A.Henzinger,R.Jhala,andR.Majumdar.
Permissiveinterfaces.InFoundations of Software
Engineering,ESEC/FSE-13,pages31–40.ACM,2005.
[29] M.J.KearnsandU.V.Vazirani.An Introduction to
Computational Learning Theory.MITPress,1994.
[30] B.Meyer.Object-Oriented Software Construction.
PrenticeHall,1997.
[31]A.Nakamura.Aneﬃcientquerylearningalgorithmfor
orderedbinarydecisiondiagrams.Information and
Computation,201(2):178–198,2005.
[32] W.Nam,P.Madhusudan,andR.Alur.Automatic
symboliccompositionalveriﬁcationbylearning
assumptions.Formal Methods in System Design,
32(3):207–234,2008.1081[33] H.Sa´ ıdiandS.Graf.Constructionofabstractstate
graphswithPVS.InGrumberg,editor,Computer
Aided Veriﬁcation,volume1254ofLecture Notes in
Computer Science,pages72–83.Springer,1997.
[34] R.Singh,D.Giannakopoulou,andC.S.Pasareanu.
Learningcomponentinterfaceswithmayandmust
abstractions.InT.Touili,B.Cook,andP.Jackson,
editors,Computer Aided Veriﬁcation,volume6174of
Lecture Notes in Computer Science,pages527–542.
Springer,2010.
[35] N.SinhaandE.M.Clarke.SAT-basedcompositional
veriﬁcationusinglazylearning.InW.Dammand
H.Hermanns,editors,Computer Aided Veriﬁcation,volume4590ofLecture Notes in Computer Science,
pages39–54.Springer,2007.
[36] L.Th´ ery.Proofpearl: Revisitingthemini-Rubikin
Coq.InO.A.Mohamed,C.Mu˜ noz,andS.Tahar,
editors,Theorem Proving in Higher Order Logics,
volume5170ofLecture Notes in Computer Science,
pages310–319.Springer,2008.
[37]R.Wang,M.Zhou,L.Yin,L.Zhang,J.Sun,G.Ming,
andM.Bozga.Modelingandvalidationof
PLC-controlledsystems: Acasestudy.InTheoretical
Aspects of Software Engineering,pages161–166.IEEE,
2012.1082