RC25300 (WAT1208-051) August 20, 2012
Computer Science
IBM Research Report
Detecting Deadlock in Programs with 
Data-Centric Synchronization
Daniel Marino
Symantec Research Labs
Christian Hammer
Saarland University  
Julian Dolby, Mandana Vaziri, Frank Tip
IBM Research Division
Thomas J. Watson Research Center
P.O. Box 704
Yorktown Heights, NY 10598
USA
Jan Vitek
Purdue University
Research Division
Almaden - Austin - Beijing - Cambridge - Haifa - India - T. J. Watson - Tokyo - Zurich
LIMITED DISTRIBUTION NOTICE : This report has been submitted for publication outside of IBM and will probably be copyrighted if accepted for publication. I t   has been issued as a Research
Report for early dissemination of its contents.  In view of the transfer of copyright to the outside publisher, its distributio n  outside of IBM prior to publication should be limited to peer communications and specific
requests.  After outside publication, requests should be filled only by reprints or legally obtained copies of the article (e.g .  , payment of royalties).  Copies may be requested from IBM T. J. Watson Research Center , P.
O. Box 218, Yorktown Heights, NY 10598  USA  (email:  reports@us.ibm.com).  Some reports are available on the internet at  http://domino.watson.ibm.com/library/CyberDig.nsf/home  .Detecting Deadlock in Programs with Data-Centric
Synchronization
Daniel Marino, Christian Hammery, Julian Dolbyz, Mandana Vaziriz, Frank Tipz, Jan Vitekx
Symantec Research Labs
Email: danlmarino@yahoo.comySaarland University
Email: c.hammer@acm.orgzIBM T.J. Watson Research Center
Email:fdolby,mvaziri,ftipg@us.ibm.com
xPurdue University
Email: jv@cs.purdue.edu
Abstract ‚ÄîPreviously, we developed a data-centric approach
to concurrency control in which programmers specify synchro-
nization constraints declaratively, by grouping shared locations
into atomic sets . We implemented our ideas in a Java extension
called AJ, using Java locks to implement synchronization. We
proved that atomicity violations are prevented by construction,
and demonstrated that realistic Java programs can be refactored
intoAJwithout signiÔ¨Åcant loss of performance.
This paper presents an algorithm for detecting possible dead-
lock in AJprograms by ordering the locks associated with atomic
sets. In our approach, a type-based static analysis is extended to
handle recursive data structures by considering programmer-
supplied lock ordering annotations. In an evaluation of the
algorithm, all 10 AJprograms under consideration were shown
to be deadlock-free. One program needed 4 ordering annotations
and 2 others required minor refactorings. For the remaining 7
programs, no programmer intervention of any kind was required.
I. I NTRODUCTION
Writing concurrent programs that operate on shared memory
is error-prone as it requires reasoning about the possible inter-
leavings of threads that access shared locations. If program-
mers make mistakes, two kinds of software faults may occur.
Data races and atomicity violations may arise when shared
locations are not consistently protected by locks. Deadlock
may occur as the result of undisciplined lock acquisition,
preventing an application from making progress. Previously
[1‚Äì3], we proposed a data-centric approach to synchronization
to raise the level of abstraction in concurrent object-oriented
programming and prevent concurrency-related errors.
In our approach, Ô¨Åelds of classes are grouped into atomic
sets. Each atomic set has associated units of work , code
fragments that preserve the consistency of their atomic sets.
Our compiler inserts synchronization that is sufÔ¨Åcient to
guarantee that, for each atomic set, the associated units of work
are serializable [4], thus preventing data races and atomicity
violations by construction . Our previous work reported on the
implementation of atomic sets as an extension of Java called
AJ: we demonstrated that atomic sets enjoy low annotation
overhead and that realistic Java programs can be refactored
intoAJwithout signiÔ¨Åcant loss of performance [3].
However, our previous work did not address the problem of
deadlock, which may arise in AJwhen two threads attemptto execute the units of work associated with different atomic
sets in different orders. This paper presents a static analysis
for detecting possible deadlock in AJprograms. The analysis
is a variation on existing deadlock-prevention strategies [5, 6]
that impose a global order on locks and check that all locks are
acquired in accordance with that order. However, we beneÔ¨Åt
from the declarative nature of data-centric synchronization in
AJto infer the locks that threads may acquire. We rely on
two properties of AJ: (i) all locks are associated with atomic
sets, and (ii) the memory locations associated with different
atomic sets will be disjoint unless they are explicitly merged
by the programmer. Our algorithm computes a partial order
on atomic sets. If such an order can be found, a program is
deadlock-free. For programs that use recursive data structures,
the approach is extended to take into account a programmer-
speciÔ¨Åed ordering between different instances of an atomic
set.
We implemented this analysis and evaluated it on 10 AJ
programs. These programs were converted from Java as part
of our previous work [3], and cover a range of program-
ming styles. The analysis was able to prove all 10 programs
deadlock-free. Minor refactorings were needed in 2 cases, and
a total of 4 ordering annotations were needed, all in 1 program.
In summary, this paper makes the following contributions:
We present a static analysis for detecting possible dead-
lock in AJprograms. It leverages the declarative nature of
atomic sets to check that locks are acquired in a consistent
order. If so, the program is guaranteed to be deadlock-
free. Otherwise, possible deadlock is reported.
To handle recursive data structures, we extend AJwith or-
dering annotations that are enforced by a small extension
ofAJ‚Äôs type system. We show how these annotations are
integrated with our analysis in a straightforward manner.
We implemented the analysis and evaluated it on a set
ofAJprograms. The analysis found all programs to be
deadlock-free, requiring minor refactorings in two cases.
Only 4 ordering annotations were needed, in 1 program.
II. D ATA-CENTRIC SYNCHRONIZATION WITH AJ
AJ[2] extends Java with the syntax of Fig. 1. An AJclass
can have zero or more atomicset declarations. Each atomic sethas a symbolic name and intuitively corresponds to a logical
lock protecting a set of memory locations. Each atomic set
has associated units of work , code fragments that preserve
the consistency of their associated atomic sets. These units
of work are the only code permitted to access the atomic set‚Äôs
Ô¨Åelds, so only this code needs to be synchronized to ensure
its consistency. By default, the units of work for an atomic
set declared in a class Cconsist of all non- private methods
inCand its subclasses. Given data-centric synchronization
annotations, the AJcompiler inserts concurrency control op-
erations that are sufÔ¨Åcient to guarantee that any execution is
atomic-set serializable [4], i.e., equivalent to one in which, for
each atomic set, its units of work occur in some serial order.
One may think of a unit of work as an atomic section [7]
that is only atomic with respect to a particular set of memory
locations. Accesses to locations not in the set are visible to
other threads. Methods that do not operate on locations within
atomic sets will not be synchronized.
We illustrate the discussion with a binary tree example.
Fig. 2 shows a class Tree with Ô¨Åelds rootandsize;rootpoints
to the Node that is the root of the tree. Each node has left
and right Ô¨Åelds pointing to its children, as well as a value
and a weight . Class Tree has methods size() , which returns
the number of nodes in the tree, Ô¨Ånd() , for Ô¨Ånding a node
with a given value, and insert() for inserting a value into the
tree. The latter two methods rely on methods Node.Ô¨Ånd() and
Node.insert() .Tree also has methods compute() , which returns
the weighted sum of its nodes‚Äô values, and copyRoot() , which
inserts the root‚Äôs value into another tree passed as an argument.
We assume that the programmer wants to ensure that
concurrent calls to incWeight() and compute() on the same
tree never interleave, as this might trigger a race condition
that causes Tree.compute() to return a stale value. We now
discuss how this can be achieved in AJ.
Tree declares an atomic set t(line 2). The annotations on
lines 3‚Äì4 have the effect of including root and size in this
atomic set. At run time, each Tree object has an atomic-
set instance tcontaining the corresponding Ô¨Åelds. The AJ
atomicset a A class or interface declaration may have multi-
ple atomic set declarations.
atomic(a) Annotation on instance Ô¨Åelds and classes. A Ô¨Åeld
can belong to at most one atomic set. Annotated Ô¨Åelds can
only be accessed from the this reference.
unitfor(a) Annotation on method arguments. This declares the
method to be an additional unit of work for the speciÔ¨Åed
atomic set in the argument object.
notunitfor Annotation to indicate that a method is not a unit
of work for atomic sets in its declaring class.
ja=this.bjAnnotation on variable declarations and constructor
calls. This uniÔ¨Åes the atomic set ain the annotated variable
or constructed object with the current object‚Äôs atomic set b.
Fig. 1. Data-centric annotations.1class Treef
2atomicset(t);
3private atomic(t) Node rootjn=this.tj;
4private atomic(t) int size;
5Tree( intv)froot= new Nodejn=this.tj(v);g
6intsize()freturn size;g
7INode Ô¨Ånd( intv)freturn root. Ô¨Ånd (v);g
8void insert ( intv)froot. insert (v); size++; g
9intcompute()freturn root.compute();g
10 void copyRoot(Tree tree) ftree. insert (root.getValue()); g
11g
12
13interface INodefvoid incWeight( intn);g
14
15class Node implements INodef
16 atomicset(n);
17 private atomic(n) Node leftjn=this.nj;
18 private atomic(n) Node rightjn=this.nj;
19 private atomic(n) int value, weight = 1;
20
21 Node( intv)fvalue = v;g
22 intgetValue()freturn value;g
23 void insert ( intv)f
24 if(value==v) weight++;
25 else if (v<value)f
26 if( left == null) left = new Nodejn=this.nj(v);
27 else left . insert (v);
28gelsef
29 if( right == null) right = new Nodejn=this.nj(v);
30 else right . insert (v);
31g
32g
33 public void incWeight( intn)fweight += n;g
34 INode Ô¨Ånd( intv)f
35 if(value == v) return this ;
36 else if (v<value) return left== null?null : left . Ô¨Ånd (v);
37 else return right== null?null : right . Ô¨Ånd (v);
38g
39 intcompute()f
40 intresult = valueweight;
41 result += ( left == null)? 0 : left .compute();
42 return result + ( right == null)? 0 : right .compute();
43g
44g
Fig. 2. AJTree example.
compiler inserts locks to ensure that the units of work for
texecute atomically.
Preserving the consistency of complex data structures typi-
cally requires protecting multiple objects (e.g., all of a Tree‚Äôs
nodes) with a single lock. This can be achieved using aliasing
annotations , which unify the atomic sets of a Tree and the dif-
ferent Node objects into one larger atomic set. Aliasing anno-
tations are type qualiÔ¨Åers, so the declaration Node leftjn=this.nj
on line 17 speciÔ¨Åes that the atomic set instance nof the object
referenced by leftis uniÔ¨Åed with that of the current object.
Likewise, atomic set instance nin the Node allocated on line 5
is uniÔ¨Åed with atomic set instance tin its enclosing Tree object.
AJ‚Äôs type system enforces the consistency of such aliasing
annotations to prevent synchronization errors.
Together, the aliasing annotations on Tree andNode ensure
245class Textends Threadf
46 T(Tree t0, intv)ftree=t0; value=v; g
47 public void run()ftree. insert (value); g
48 Tree tree; intvalue;
49g
50
51public static void main(String[] args) throws ...f
52 Tree tree = new Tree(10);
53 Thread T1 = new T(tree, 12);
54 Thread T2 = new T(tree, 5);
55 T1.start (); T2.start (); T1.join (); T2.join ();
56g57class Uextends Threadf
58 U(Tree t1, Tree t2) ftree1=t1; tree2=t2; g
59 public void run()ftree1.copyRoot(tree2); g
60 Tree tree1, tree2;
61g
62
63public static void main(String[] args) throws ...f
64 Tree tree1 = new Tree(1), tree2 = new Tree(2);
65 Thread T3 = new U(tree1, tree2);
66 Thread T4 = new U(tree2, tree1);
67 T3.start (); T4.start (); T3.join (); T4.join ();
68g(a) (b)
Fig. 3. Two clients of the Tree class of Fig. 2.
that all locations in a Tree object are protected by the same
lock. Fig. 3(a) shows a client where two threads insert con-
currently into a tree. Such operations will execute correctly, as
AJensures mutual exclusion. Note that the client code does
not refer to atomic sets at all, as is typical in our approach.
III. D EADLOCK DETECTION IN AJ
A. Execution of the example
Recall that for any object ocreated at runtime that is of a
type that declares an atomic set t, there will be an atomic set
instanceo:tthat protects the Ô¨Åelds in othat are declared to
be int. Atomic set instances can be thought of as resources
that are acquired when an associated unit of work is executed.
As we shall see shortly, deadlock may arise if two threads
concurrently attempt to acquire such resources out of order.
Consider the program of Fig. 3(a), which creates a tree and
two threads that work on it. Execution proceeds as follows:
1) When a Tree object is created and assigned to variable
tree on line 52, its corresponding atomic set instance,
tree.t , protects the rootandsize Ô¨Åelds of the new object.
2)Tree‚Äôs constructor on line 5 creates a Node object. The
alias declaration on line 3 causes its left,right,value and
weight Ô¨Åelds to be included in atomic set instance tree.t .
3) The object creations for T1andT2on lines 53‚Äì54 are
standard, with no special operations for atomic sets.
4) Once the workers start (line 55), both threads attempt to
invoke insert() ontree. Since insert() is a unit of work for
tand both threads operate on the same Tree object, AJ‚Äôs
runtime system enforces mutual exclusion, by taking a
lock upon calling insert() (see Sec. V). Thus, the two
operations execute serially.
5) The join() calls on line 55 wait for the workers to Ô¨Ånish.
Now consider the code in Fig. 3(b), which is similar except
that two Tree objects are created and assigned to variables
tree1 and tree2 (line 64). Then, two worker threads, T3
and T4, are created on lines 65‚Äì66. Note that each worker
thread is passed references to both tree1 and tree2 in the
constructor calls, but in a different order . Then, each worker
calls copyRoot() on one tree, which in turn calls insert() on
the other. These methods are both units of work for atomic
sett, soT3attempts to acquire the lock for tree1.t upon callingcopyRoot() and then the lock for tree2.t when it calls insert() .
T4attempts precisely the reverse: it acquires the lock for
tree2.t when calling copyRoot() and then the lock for tree1.t
when calling insert() . This is a classic situation where deadlock
may arise when threads acquire multiple locks in different
orders.
B. Preventing Deadlock
Deadlock can be prevented by totally ordering all possible
locks, and always acquiring locks in that order. Our algorithm
attempts to Ô¨Ånd a partial order <on atomic sets, where a<b
means that threads never attempt to acquire a lock on an a
while holding a lock on a b. That is, any thread that needs
both locks simultaneously must acquire aÔ¨Årst. If no such
order can be found, deadlock is deemed possible. The ordering
<between atomic sets reÔ¨Çects transitive calling relationships
between their units of work. For each path in the call graph
from a method mthat is a unit of work for atomic set ato
a methodnthat is a unit of work for atomic set b, we create
an ordering constraint a < b . However, if a=band we can
determine that both methods are units of work on the same
atomic-set instance , then no ordering constraint needs to be
generated, as locks are reentrant. Possible deadlock is reported
if, after generating all such constraints, <is not a partial
order. While this algorithm is conceptually simple, some
complications arise in the presence of atomic set aliasing,
when multiple names may refer to the same atomic set. This
will be discussed further in Sec. IV.
For Fig. 3(a), the algorithm infers that atomic sets tandn
are unordered and declares the program deadlock-free, since
due to aliasing annotations it can show that all transitive calls
between units of work simply result in lock re-entry. For
Fig. 3(b), a constraint t<tis inferred, indicating that deadlock
may occur, as we have already seen.
C. Refactoring against Deadlocks
In our experience, many cases of deadlock can be avoided
by simple refactorings that order lock acquisition. This can be
accomplished using AJ‚Äôsunitfor construct, which declares a
method to be an additional unit of work for an atomic set in
one of its parameters. For example, deadlock can be prevented
3in Fig. 3(b) by placing a unitfor annotation on the parameter
tree of the copyRoot() method as follows:
void copyRoot(unitfor(t) Tree tree)f
tree. insert (root.getValue());
g
This declares copyRoot() to be a unit of work for atomic set
instance tree.t , as well as this.t . When a method is a unit of
work for multiple atomic set instances, AJ‚Äôs semantics guaran-
tees that the corresponding resources are acquired atomically,
thus preventing deadlock in Fig. 3(b). Sometimes, deeper code
restructuring is needed before the unitfor construct can be used;
Sec. VI gives some examples.
D. Recursive data structures
The basic algorithm sketched above can fail to prove the
absence of deadlock in programs that use recursive data
structures. Fig. 4 illustrates this with a variant of our binary
tree that allows concurrent updates to the weight of different
nodes in the same tree. However, insert() should still ensure
mutual exclusion to avoid corruption of the tree‚Äôs structure.
This synchronization policy is implemented by keeping the
atomic sets of the tree and of its nodes distinct: the atomic
set instances of different Node objects must notbe aliased
with each other as this would preclude concurrent access to
different nodes. In Fig. 4, once a thread has a reference to an
INode , it can invoke incWeight() on it. As Node.incWeight() is
a unit of work for the node‚Äôs atomic set n, no other thread can
concurrently access that node. However, since different nodes
no longer share the same atomic set instance, incWeight() can
be called concurrently on different nodes, as desired. Note that
invoking Tree.insert() involves acquiring the lock associated
with the tree‚Äôs atomic set instance t, thus ensuring the desired
mutual exclusion behavior.
E. Analyzing the modiÔ¨Åed tree example
Now consider Fig. 5. The basic algorithm discussed above
would compute an ordering constraint n<nfor this program,
because Node.insert() recursively invokes itself on the children
of the current node. In the absence of aliasing annotations,
72class Treef
73 atomicset(t);
74 private atomic(t) Node root;
75 Tree( intv)froot = new Node(v);g
76 ...
77g
78class Node implements INodef
79 atomicset(n);
80 private atomic(n) Node left;
81 private atomic(n) Node right;
82 ...
83 void insert ( intv)f
84 ... left = new Node(v); ...
85 ... right = new Node(v); ...
86g
87g
Fig. 4. A tree that permits concurrent access to its nodes. UnmodiÔ¨Åed code
fragments have been elided.88class Vextends Threadf
89 V(Tree t , intv)ftree=t; val=v;g
90 public void run()ftree. insert (val ); g
91 Tree tree; intval;
92g
93...
94public static void main(String[] args)
95 throws InterruptedException f
96 Tree tree = new Tree(10);
97 Thread T5 = new V(tree, 3);
98 Thread T6 = new V(tree, 4);
99 T5.start (); T6.start (); T5.join (); T6.join ();
100g
Fig. 5. Client program for the example of Fig. 4.
jthis.a <ajAnnotation on variables and constructors. This spec-
iÔ¨Åes the order between atomic set ain the annotated variable or
constructed object, and the atomic set ain the current object.
Fig. 6. Extending AJwith ordering annotations.
these nodes now have distinct atomic set instances, and the
basic algorithm concludes that deadlock is possible since
it cannot rule out that two threads may access the atomic
set instances of different Node objects in different orders.
However, it is easy to see that this particular program is
deadlock-free, as the recursive calls to insert() traverse the
tree in top-down order. Hence, the locks associated with the
instances of atomic set nin the traversed nodes are always
acquired in a consistent order, precluding deadlock.
F . Ordering Annotations
To handle recursive data structures, we extend AJwith or-
dering annotations as shown in Fig. 6. This lets programmers
specify an ordering between instances of the same atomic set.
The deadlock analysis can then avoid generating constraints
of the form a<a when the user-provided ordering indicates
that a call cannot contribute to deadlock. Fig. 7 shows how
to express an ordering between an atomic set nin a given
node, and in each of its children. Given these annotations,
our enhanced algorithm conÔ¨Årms that the program of Fig. 5 is
indeed deadlock-free. To ensure that it is sound for the analysis
to rely on ordering annotations, AJ‚Äôs type checker must verify
that they are valid. This will be discussed in Sec. V.
101class Node implements INodef
102 atomicset(n);
103 private atomic(n) Node leftjthis.n <nj;
104 private atomic(n) Node rightjthis.n <nj;
105 ...
106 void insert ( intv)f
107 ... left = new Nodejthis.n <nj(v); ...
108 ... right = new Nodejthis.n <nj(v); ...
109g
110g
Fig. 7. Adding ordering annotations to the example of Fig. 4. UnmodiÔ¨Åed
code fragments have been elided.
4M := set of methods in program
V:= set of Ô¨Ånal method params plus a special ?symbol
A := set of atomic setsN :=f=; <gVA set of lock identiÔ¨Åers
L:= 2Nset of atomic-set instances (i.e., locks)
D := 2Lset of locksets
uow:M!D := returns the set of locks that a method grabs
padaptName : (MVM )!V := renames a variable from the perspective of caller to callee
padaptLock : (MLM )!L := adapts all names identifying a lock from the perspective of caller to callee
addNames : (ML )!L := consults annotations in scope to add other names for a lock to its representation.
uow(m) =ffv:Agjmis a unit-of-work for v:Ag
addNames (m; l) =l[fv:Ajw:B2landv:A is annotated to be an alias for w:B inm‚Äôs scopeg
padaptName (ms; v; m t) =8
<
:this ifmscontains the call v:m t(:::)
w ifmspasses vas the actual argument for the formal parameter wofmt
? otherwise
padaptLock (ms; l; m t) =fv:Aj w:A2addNames (ms; l)^padaptName (ms; w; m t) =vg
mis an entry point
;2LBE(m)(LBE-ENTRY )n!m d2LBE(n)
fpadaptLock (n; l; m )jl2(d[uow(n))g2LBE(m)(LBE-CALL )
Fig. 8. Auxiliary deÔ¨Ånitions.
IV. A LGORITHM
A. Auxiliary DeÔ¨Ånitions
Fig. 8 deÔ¨Ånes auxiliary concepts upon which our algorithm
relies. We assume that a call graph of the program has
been constructed and that !denotes the calling relationship
between methods1. Function uow associates each method
with the atomic-set instances for which it is a unit of work,
including those due to unitfor constructs. Intuitively, uow (m)
identiÔ¨Åes the set of locks that macquires (or re-enters) in the
current AJimplementation. A lock is an element of L, and
is represented as a set of names since locks may have many
names due to aliasing annotations. Names (elements of N) are
notated asv:Awhereis either =or<,vis a Ô¨Ånal method
parameter or variable, and Ais the name of an atomic set. If
neither =or<is speciÔ¨Åed, then =is assumed. Names of the
form<v:A are not considered until Sec. IV-C.
Fig. 8 also deÔ¨Ånes LBE (m)(locks before entry ), denoting
the sets of locks that may be held just before entering method
m. In general, different sets of locks may be held when m
is invoked by different callers. It is important to keep these
sets of locks distinct, to avoid imprecision in the analysis that
could give rise to false positives. Our algorithm effectively
performs a context-sensitive analysis by computing a separate
set of locks (lockset) for each path in the call graph2, where
locksets are propagated from callers to callees and augmented
with locally acquired locks. When locks are passed from caller
1To simplify the presentation, we assume that a method mcalls another
method nat most once, and that the same variable is not passed for multiple
parameters. Our implementation, of course, does not have these restrictions.
2Note that LBE(m)could conservatively contain a lockset that is never
held before entering method mif the call graph contains infeasible paths.
However, because AJinserts the necessary lock acquisitions and uow reÔ¨Çects
this knowledge, the locksets themselves are precise and represent exactly the
locks that are held if a particular path in the call graph is traversed.to callee, names are adapted to the callee, to account for the
fact that different name(s) now represent the same lock (see
functions padaptName andpadaptLock in Fig. 8). Note
thatpadaptName andpadaptLock use a special symbol
‚Äò?‚Äô to handle cases where a lock cannot be named by a variable
in the scope of the callee, and that padaptLock relies on
function addNames to gather additional names that must refer
to the same lock due to aliasing annotations3The deÔ¨Ånition
ofLBE (m)consists of two rules:
Rule LBE-ENTRY adds the empty lockset to LBE (m)ifm
is an entry point, indicating that no locks are held before
the program begins.
Rule LBE-CALL takes each lockset that may be held
before entering a caller, augments it with the locks that
the caller acquires, and then adapts the lockset to the
perspective of the callee using padaptLock .
These rules are iterated to a Ô¨Åxed point in order to determine
all of the locksets that may be held before entering a method.
B. Core Algorithm
Fig. 9 deÔ¨Ånes an ordering ‚Äò <‚Äô on atomic sets using LBE (m).
Intuitively, for atomic sets AandBwe haveA<B if a lock
associated with an instance of atomic set Amay be acquired
before a lock that is associated with an instance of atomic set
B. Rule UOW states that this is the case if there is a method
mand some lockset d2LBE (m)that contains a lock named
v:A, and we have some w:B that names a lock in uow (m)
that is not already held in d.4
3This is not necessary for soundness, but allows the algorithm to more
precisely identify lock re-entry.
4Note that UOW subtly relies on the fact that uow never returns a lock
named using ?, since atomic-set instances for which a method is a unit-of-work
are always nameable from that method‚Äôs scope. Hence, there is no danger of
failing to generate an ordering constraint because we are re-entering ‚Äô ?.B‚Äô.
5d2LBE (m)l12d l 22uow (m)
v:A2l1w:B2l2l32d)w:B62l3
A<B(UOW )object creation with alias annotation
|b=this.a| is reachable in code
A B(GIVES )
A B
AB(SHARE -LOCK -1)A B A C
BC(SHARE -LOCK -2)AB
BA(SHARE -SYM)
A<B B <C
A<C
(TRANS )A<B BC
A<C
(SHARE -1)AB B <C
A<C
(SHARE -2)A B B C
A C
(GIVES -TRANS )
Fig. 9. DeÔ¨Ånition of the ordering relation ‚Äò <‚Äô between atomic sets.
When atomic sets are aliased, care must be taken to account
for the fact that multiple names may refer to the same lock. In
general, the generation of an ordering constraint A < B can
be avoided when encountering a unit of work for atomic-set
instancew:B if a lock corresponding to atomic-set instance
v:A is already held, and if it can be determined that v:A and
w:B must refer to the same lock, because in that case the lock
is simply re-entered. Two key steps enable us to do this:
By keeping locksets separate for each path in the call
graph, we are able to determine when locks must be held.
The representation of a lock maintains all its known
names ( i.e., must-aliases), allowing us to identify situ-
ations where locks are re-entered.
However, we cannot rely on local annotations alone to give
us all possible names for a given lock ( i.e., may-aliases) as
aliasing annotations can be cast away. Therefore, rules SHARE -
1 and SHARE -2 conservatively generate additional orderings
to account for any aliasing annotations in the whole program
that may cause instances of two atomic sets to be implemented
using the same lock. To prevent generating spurious ordering
constraints, we use a transitive ‚Äô  ‚Äô (gives) relation and a
symmetric ‚Äô‚Äô (shares) relation instead of simply merging
atomic sets when they may be aliased. To see why this is
needed, consider a situation where two classes CandDboth
use a utility class List, and where each aliases List‚Äôs atomic
set to its own. Then while a Cobject or a Dobject may share
a lock with a Listobject, Cobjects never share locks with D
objects. Lastly, rule TRANS deÔ¨Ånes ‚Äò<‚Äô to be transitive.
Now, deadlock may occur if ‚Äò <‚Äô is not a valid partial order.
Conversely, if there is no atomic set Asuch thatA<A , then
the program is deadlock-free: we have found a valid partial
order on atomic sets that is consistent with the order in which
new locks are acquired by transitively called units of work.
C. Accounting for Ordering Annotations
The basic algorithm is unable to infer a partial order among
atomic sets in programs that manipulate recursive data struc-
tures. For the program of Fig. 4, the rules of Fig. 9 infer n<n,
leading to the conclusion that deadlock might occur. However,
as discussed in Sec. III-E, deadlock is impossible in this case
because locks are always acquired in a consistent order that
reÔ¨Çects how trees are always traversed in the same direction.Intuitively, tracking ordering constraints at the atomic-set level
is insufÔ¨Åcient in cases where threads execute units of work
associated with multiple instances of the same atomic set.
Our solution involves having programmers specify ordering
annotations that imply the existence of a Ô¨Åner-grained partial
order between different instances of the same atomic set, as
was illustrated in Fig. 7. We extended the AJtype system to
allow an atomic set instance to be ordered relative to exactly
oneother atomic set instance when it is constructed. The type
system ensures that the object to which the newly constructed
object is being related is already completely constructed,
preventing objects that are being constructed simultaneously
from specifying conÔ¨Çicting orders relative to one another.
Thus, the annotations are correct by construction. Since the
programmer can give only one constraint at object creation
time, and it must be with respect to a completely constructed
object, a cycle in the speciÔ¨Åed order is impossible. The type
system then ensures that this order is respected by any dataÔ¨Çow
that carries the ordering annotation.
Fig. 10 updates our analysis to accommodate user-speciÔ¨Åed
orderings between instances of an atomic set. Function
addNames now consults the ordering annotations available
within a method and its enclosing class. Any atomic-set
instance speciÔ¨Åed to be greater than a given instance is added
to the lock‚Äôs representation and preÔ¨Åxed with a ‚Äô <‚Äô to indicate
that it is not a must-alias, but rather a lock that is safe to enter
after the represented lock. Rule UOW now avoids generating an
ordering constraint due to one lock being held when another
is acquired if the former is guaranteed to be less than latter.
If the analysis indicates deadlock-freedom, then it has found
addNames (m; l) =fl[
fw:Bj v:A2landw:B is annotated to be an
alias for v:A inm‚Äôs scopeg [
f< x:Aj v:A2landx:A is annotated to be
greater than v:A inm‚Äôs scopegg
d2LBE(m) l12d l 22uow(m) v:A2l1
w:B2l2 l32d)w:B62l3 < w:B62l1
A < B(UOW )
Fig. 10. Changes to the algorithm to support ordering annotations between
instances of an atomic set.
6Fact Derivation
A1);2 LBE(T:run) LBE-ENTRY
A2);2 LBE(Tree:insert ) (A1), LBE-CALL
A3)ffthis:ngg2 LBE(Node :insert ) (A2), LBE-CALLFact Derivation
B1);2 LBE(U:run) LBE-ENTRY
B2);2 LBE(Tree:copyRoot ) (B1), LBE-CALL
B3)ff?:tgg2 LBE(Tree:insert ) (B2), LBE-CALL
B4)t<t (B3), ORDER -UOW
(a) (b)
Fact Derivation
C1);2 LBE(V:run) LBE-ENTRY
C2);2 LBE(Tree:insert ) (C1), LBE-CALL
C3)ff?:tgg2 LBE(Node :insert ) (C2), LBE-CALL
C4)ff?:tg;f?:ngg2 LBE(Node :insert ) (C3), LBE-CALL
C5) t<n (C3) or (C4), ORDER -UOW
C6) n<n (C4), ORDER -UOWFact Derivation
D1);2 LBE(V:run) LBE-ENTRY
D2);2 LBE(Tree:insert ) (D1), LBE-CALL
D3)ff?:tgg2 LBE(Node :insert ) (D2), LBE-CALL
D4)ff?:tg;f?:n; <this:ngg2 LBE(Node :insert ) (D3), LBE-CALL
D5) t<n (D3) or (D4),
and ORDER -UOW
(c) (d)
Fig. 11. Functioning of the algorithm on binary tree example. Relevant facts that are derivable are shown for (a) client code in Fig. 3(a) which is deadlock-
free; (b) client code in Fig. 3(b) which may deadlock; (c) client code in Fig. 5, which the algorithm conservatively reports may deadlock; and (d) client code
in Fig. 5 after adding ordering annotations. Several derivable facts are not shown in the Ô¨Ågure, including t n,tn,ntfor (a) and (b), and t < n ,
n < n , andn < t for (b).
a valid partial order on all atomic set instances in the program
that is consistent with the order in which threads acquire
them. The ordering is made up of a coarse-grained ordering on
atomic sets that indicate ordering between all instances of two
atomic sets, and a Ô¨Åne-grained ordering among instances of a
single atomic set as indicated by the user‚Äôs annotations. The
interested reader can Ô¨Ånd an informal correctness argument in
the Appendix.
D. Example
Let us consider the behavior of our analysis on the example
program in Fig. 2 and its client in Fig. 3(a). The relevant facts
that are discovered by our analysis are shown in Fig. 11(a)
along with an indication of the rules and facts used to derive
them. Note that the facts shown in the Ô¨Ågure incorporate an
optimization where names of form ?.aare dropped from a
lock‚Äôs set representation if it also contains a must-alias not
involving ?. See Sec. V for why this is safe.
From LBE-ENTRY , we know that LBE (T:run)contains the
empty lockset. Using this fact in the premise of LBE-CALL ,
we derive;2LBE (Tree:insert ). For the call from Tree.insert()
toNode.insert() ,LBE-CALL makes the following calculations:
;2LBE (Tree:insert ),uow (Node:insert ) =ffthis:tgg
fthis:tg2;[ff this:tgg
addNames (Tree:insert;fthis:tg) =fthis:t;root:ng
padaptName (Tree:insert;this;Node:insert ) = ?
padaptName (Tree:insert;root;Node:insert ) =this
padaptLock (Tree:insert;fthis:tg;Node:insert ) =
f?:t;this:ng
After removing the unnecessary name involving ?, we
getffthis:ngg 2 LBE (Node:insert ). Note that ?.tcan be
dropped because the must-alias this.n is a more exact name
for the lock in this context. The recursive calls to Node.insert()
result in the same lockset, so no additional facts are derived
using LBE-CALL . Furthermore, no ordering facts can be de-
rived: the only method with a non-empty lockset upon entry
isNode.insert() , and that lockset already contains the lock for
which the method is a unit of work, preventing rule UOW from
generating an ordering constraint. Since the empty ordering
relation is a valid partial order, the program is declareddeadlock-free. The remainder of Fig. 11 shows the relevant
facts derived for the other examples from Figs. 3(b) and 5.
V. I MPLEMENTATION
We implemented the deadlock analysis as an extension of
our existing proof-of-concept AJ-to-Java compiler [3], which
is an Eclipse plugin project. In this implementation, data-
centric synchronization annotations are given as special Java
comments. These comments are parsed and given to the type
checker and deadlock analysis. Type errors such as the use of
inconsistent ordering annotations are reported using markers in
the Eclipse editor. If type-checking and the deadlock analysis
succeed, the AJsource is translated to Java, and written into a
new project that holds the transformed code. This project can
then be compiled to bytecode, and executed using a standard
JVM. More details on the implementation can be found in [3].
The deadlock analysis relies on the WALA program analysis
framework5for the construction of a call graph. The analysis
Ô¨Årst determines all entry points to the program (e.g., main()
methods and the run() methods of threads), and then builds
a conservative approximation of the program‚Äôs call graph.6
The propagation of atomic sets in our analysis is essentially a
distributive data Ô¨Çow problem, so we are able to use WALA‚Äôs
efÔ¨Åcient implementation of an Interprocedural Finite Distribu-
tive Subset solver to perform the analysis [8]. Our actual
implementation works slightly harder than the formal rules
of Sec. IV in gathering and propagating information gleaned
from aliasing and ordering annotations, for example allowing
Ô¨Ånal Ô¨Åelds of method parameters to be included in lock names.
As mentioned, lock identiÔ¨Åers involving ?are discarded if an
exact name for the lock is known ( i.e.,one not including <or
?). This allows the analysis to converge more quickly, and is
sound since the algorithm conservatively generates additional
ordering constraints from existing ones for any atomic sets
that globally may have instances implemented by the same
lock (see rules SHARE -1, SHARE -2).
To ensure that it is sound for the analysis to rely on ordering
annotations, AJ‚Äôs type checker must verify that they are valid.
5See wala.sourceforge.net.
6ReÔ¨Çection must be approximated as with most static program analyses.
7benchmark LOC Ô¨Åles data-centric annotations
program collections atomic -atomic atomic unitfor alias notunitfor total
set (class) (Ô¨Åeld)
collections 0 10846 63 5 0 53 40 330 0 428
elevator 609 yes 6 1 1 0 0 6 0 8
tsp 754 no 6 2 2 0 0 0 0 4
weblech 1971 no 14 2 0 4 0 0 0 6
jcurzez1 6639 no 49 5 2 7 15 24 0 53
jcurzez2 6633 no 49 4 3 2 6 4 0 19
tuplesoup 7217 yes 40 7 5 11 12 0 46 81
cewolf 14002 yes 129 6 6 0 0 2 0 14
mailpuccino 14519 yes 135 14 13 1 0 0 0 28
jphonelite 16484 yes 105 14 10 26 0 8 0 58
specjbb 17730 yes 64 18 15 34 1 24 4 80
TABLE I
AJSUBJECT PROGRAMS . THE TABLE SHOWS ,FOR EACH SUBJECT PROGRAM ,THE NUMBER OF LINES OF SOURCE CODE (INCLUDING WHITE SPACE AND
COMMENTS ),FILES AND DATA -CENTRIC ANNOTATIONS (ONE SUB -COLUMN FOR EACH TYPE OF ANNOTATION ).
This involves checking that ordering annotations are preserved
by assignment, parameter passing, and redeclaration. Casts
may discard annotations but cannot manufacture them from
unannotated types. A newly constructed object can be ordered
with respect to at most one existing object by annotating the
instance creation or a constructor parameter. Details about the
changes to AJ‚Äôs type system and compiler can be found in the
Appendix.
VI. E VALUATION
We analyzed a collection of AJprograms with our imple-
mentation in order to answer the following research questions:
RQ1 How successful is the analysis in demonstrating the
absence of deadlock in AJprograms?
RQ2 How often are program transformations and ordering
annotations necessary to prove the absence of deadlock?
RQ3 What is the running time of the analysis?
A. Subject Programs
The subject AJprograms used in this evaluation are shown
in Table I. These programs were created in the context of
a previous project that focused on evaluating the annotation
overhead and performance of AJ[3], by manually converting
a number of existing multi-threaded Java programs into AJ.
Details about this conversion effort are discussed in [3].
The programs were obtained from several different sources
and reÔ¨Çect a variety of programming styles. Elevator and
tsphave been used by several other researchers (e.g., [9])
in projects related to data race detection. Weblech is a web
crawler that recursively downloads all pages from a web site.
Jcurzez allows building text-based user interfaces for simple
terminals. The original jcurzez code did not support for multi-
threading, and we created two versions with well-deÔ¨Åned
behavior in the presence of concurrency: jcurzez1 achieves
this behavior in a coarse-grained fashion while jcurzez2
does so using more Ô¨Åne-grained synchronization. Cewolf is
a framework for creating graphical charts. Jphonelite is a Java
SIP voice over IP SoftPhone for computers. Tuplesoup is a
small Java-based framework for storing and retrieving simple
hashes. Mailpuccino is a Java email client. Finally, specjbbis a widely used multi-threaded performance benchmark.All
subject programs except tsp,weblech , and jcurzez rely on AJ
versions of Java collections (e.g, TreeMap ,ArrayList ), which
therefore must be analyzed as well in those cases.
Table I shows some key characteristics of the subject
programs, including the number of lines of source code, the
number of Ô¨Åles, and the number of data-centric synchroniza-
tion constructs. The row labeled ‚Äúcollections‚Äù is not a stand-
alone subject program but rather displays the characteristics
of the collection classes from the java.util package that we
converted to AJ. The actual subject programs report only ‚Äúyes‚Äù
or ‚Äúno‚Äù in this LOC column for collections to indicate whether
they use these classes or not and thus whether the collection
code was examined by the analysis.
As is apparent from the data, the programs range from small
to medium-sized. The number of atomic sets is small, ranging
from 1 to 18. specjbb has the largest number of Ô¨Åelds declared
in atomic sets (34 Ô¨Åelds, and 15 entire classes). This is the
case because a complex web of data structures is accessed
and updated by multiple threads in this benchmark. unitfor
annotations and aliasing are limited in application code but
plentiful in the library classes used by some of the programs.
B. Deadlock Analysis
In the absence of ordering annotations, our deadlock anal-
ysis is able to guarantee the absence of deadlock in all but
one of the subject programs ( jcurzez2 ). Demonstrating the
absence of deadlock in that program required the insertion
of 4 ordering annotations. Table II also shows the number
of different locksets that the algorithm generates during its
analysis (i.e., the size of the set Dof locksets in our algorithm)
as well as the running time of the deadlock analysis for each
subject program. Experiments were run on a MacBook Air
with a 1.8 GHz Intel Core i5 processor and 4GB of RAM.
Even in its current unoptimized state, the analysis takes at
most 75 seconds.
For the majority of our subject programs (7 out of 10),
deadlock-freedom could be demonstrated without any pro-
grammer intervention. Both specjbb and tuplesoup required
some slight refactoring in order to eliminate spurious deadlock
8OrderingjlocksetsjTime [s]
annotations
elevator 0 39 1.0
tsp 0 33 1.4
weblech 0 39 4.6
jcurzez1 0 409 10.3
jcurzez2 4 541 9.4
tuplesoup 0 785 8.8
cewolf 0 25 19.7
mailpuccino 0 205 48.2
jphonelite 0 34 7.2
specjbb 0 414 75.1
TABLE II
ANALYSIS RESULTS . THE TABLE SHOWS ,FOR EACH SUBJECT PROGRAM ,
THE NUMBER OF ORDERING ANNOTATIONS REQUIRED TO GUARANTEE
THE ABSENCE OF DEADLOCK ,AND THE RUNNING TIME OF OUR ANALYSIS .
1public abstract class AbstractWindowf
2atomicset b ;
3protected Ô¨Ånal AbstractWindow parent jthis.b <bj;
4protected
5AbstractWindow(AbstractWindow jthis.b <bjparent, ...)f
6 this.parent = parent;
7g
8publicjthis.b <bjAbstractWindow getParent() f
9 return parent;
10g
11g
Fig. 12. Excerpt from jcurzez2 requiring ordering annotations.
reports. In both cases, component objects of a parent object
kept a reference to their parent object in a Ô¨Åeld. Later, the
analysis was unable to infer the equality of the parent that
called a method in a child object and the object stored in
the child‚Äôs parent Ô¨Åeld. We refactored the problematic calls
to pass an instance of the parent as a parameter to the child‚Äôs
method. Cewolf is a J2EE servlet that does not provide a main
method; its methods are invoked by an application server that
we modeled with mock classes from WALA‚Äôs J2EE package.
Only one subject program, jcurzez2 , required ordering
annotations to be proven deadlock-free. Fig. 12 shows an
excerpt of the problematic methods. Class AbstractWindow
contains a recursive reference to a parent window on which
it sometimes makes calls. The annotation on the constructor‚Äôs
parent parameter causes the atomic-set instance bof a newly
constructed AbstractWindow to be placed in the lock order
before parent.b . This fact can be exploited during deadlock
analysis. The type system allows this ordering information to
be propagated to the Ô¨Åeld the parameter is stored in and the
return value of this Ô¨Åeld‚Äôs getter method. After adding ordering
annotations, our analysis can rule out deadlock.
C. Summary
In summary, the research questions posed at the beginning
of this section can be answered as follows:
RQ1: The analysis was able to prove the absence of deadlock
in all 10 of the subject programs that we considered.
RQ2: Two programs required minor refactorings before the
absence of deadlock could be demonstrated. One program
relied on recursive data structures that necessitated theintroduction of 4 ordering annotations. For the remaining
7 programs, no programmer intervention was needed.
RQ3: The running time of the analysis is at most 75 seconds
in all cases.
D. Threats to Validity
A critical reviewer might argue that the subject programs
are small, and that they do not adequately represent concurrent
programming styles that occur in practice. Obtaining suitable
subject programs is a challenge for us, because AJis a
research language without real users. The AJprograms that
we used in this evaluation were converted from Java as part
of our previous work on evaluating the annotation overhead
and performance of AJ[3]. Their construction predates this
work on deadlock analysis and we used all AJprograms that
were available. The analyzed code includes AJversions of
collections such as TreeMap andArrayList and all of their asso-
ciated auxiliary data structures (e.g., map entries and iterators),
which are quite complex. Furthermore, our subject programs
include specjbb , a widely-used performance benchmark, and
several programs that other researchers used in research on
concurrency errors. Therefore, based on the current results, we
are optimistic that the proposed deadlock analysis will work
well for other, and bigger programs.
VII. R ELATED WORK
Deadlock detection, prevention and avoidance is well trod-
den ground. In this section, we focus on static techniques.
a) Static analysis.: At heart, all static analysis techniques
attempt to detect cyclic waits-on relationships between tasks.
To this end, they construct abstractions of the program‚Äôs
control Ô¨Çow, tasking and synchronization behavior. Cycles in
these graphs correspond to possible deadlock. The precision of
the analysis depends on ruling out cycles that cannot happen
in practice. Masticola‚Äôs work [5] is one example, and includes
an extensive discussion of prior work.
To prove the absence of deadlocks caused by resource acqui-
sition, a common approach is to statically look for an order
on resources such that no task ever holds a resource while
requesting a lesser one. Saxena [10] explored this approach
in the context of concurrent Pascal code where all shared
resources can be enumerated. Engler and Ashcraft [6] apply
this approach to the analysis of large C programs, but abstract
any non-global lock resource by the name of the type in which
it is stored. Williams et al. [11] propose a lock-ordering based
deadlock analysis for Java, focusing on analyzing libraries in
the absence of client code. Our analysis follows this traditional
approach of Ô¨Ånding an order for resources, leveraging the
declarative nature of AJby using atomic set instances as a
sound and effective abstraction for locks.
b) Generating deadlock-free code.: Golan-Gueta et al.
[12] demonstrate a technique for generating Ô¨Åne-grained,
deadlock-free locking code for one particular type of code
module: tree- and forest-based data structures. They introduce
a strategy called domination locking to achieve this. AJcannot
support domination locking, but it provides a declarative way
9to write deadlock- and race-free code for general-purpose
programs. Emmi et al. [13] use integer linear programming
(ILP) to infer a locking strategy for programs written with
atomic blocks in versions of C and Java. They impose ordering
constraints on lock acquisition in the optimization problem in
order to avoid generating programs that can deadlock. AJpro-
vides more programmer control over the level of concurrency
and the desired behavior than this approach.
c) Type systems.: Type-based approaches that address
deadlock typically rely on an underlying type and effect
system that exposes the locking behavior in type signatures and
provides some mechanism to control aliasing. Boudol‚Äôs work
is a good example [14]: It deÔ¨Ånes a deadlock-free semantics
for an imperative language and a type and effect system for
deadlock avoidance. In his work, singleton reference types
allow reasoning about precise aliasing relationships between
pointers and their locks. Geriakos et al. [15] extend this
approach to unstructured locking and report low runtime
overhead. Boyapati et al. [16] describe another such system
where the notion of ownership [17] is used to restrict aliasing.
In their work, a Java-like language is extended with ownership
annotations and lock levels. Each lock has an associated lock
level, and methods are annotated with the keyword locks
to indicate they acquire locks at a given level. The type
system ensures that locks are acquired in descending order.
Gordon et al. [18] focus on Ô¨Åne-grained locking scenarios that
involve concurrent data structures such as circular lists and
mutable trees, where it is difÔ¨Åcult to impose a strict total order
on the locks held simultaneously by a thread. The approach
relies on a notion of lock capabilities : Associated with each
lock is a set of capabilities to acquire further locks, and
deadlock-freedom is demonstrated by proving acyclicity of the
capability-granting relation. Inference algorithms have been
proposed to reduce the annotation burden. Agarwal et al. [19]
present a type inference algorithm that infers locks-clauses for
Boyapati‚Äôs type system. In programs that cannot be typed, a
generalization of GoodLock [20] is used for runtime detection.
Vasconcelos et al. [21] deÔ¨Åne a type inference system for
a typed assembly language that deÔ¨Ånes a partial order in
which locks have to be acquired. Their system supports non-
structured locks in a cooperative multi-threading environment
where threads may be suspended while holding locks.
Our approach relies on a static analysis that leverages
the declarative nature of synchronization in AJto prove
deadlock-freedom in most cases without programmer inven-
tion. Programmer-supplied type annotations are required only
in relatively rare cases when recursive data structures are
manipulated concurrently. Our results suggest that this hybrid
approach successfully avoids common pitfalls, such as the
false positives reported by some static analyses, and the heavy
notational burden of some type-based approaches.
VIII. C ONCLUSIONS
We presented an analysis for detecting possible deadlock in
AJprograms. The analysis is a variation on existing deadlock-
prevention strategies [5, 6] that impose a global order on locksand check that locks are always acquired in accordance with
that order. The declarative nature of data-centric synchroniza-
tion in AJenables us to compute an analogous ordering on
atomic sets that reÔ¨Çects the invocations from units of work
on one atomic to units of work on another. For recursive
data structures, this coarse-grained ordering sometimes does
not sufÔ¨Åce. Therefore, we added ordering annotations to AJ
that enable programmers to specify an order between different
instances of an atomic set, and we extend our analysis to
take such ordering annotations into account. We extended our
AJimplementation to type-check ordering annotations, and
incorporated the deadlock analysis in the type checker.
In an evaluation of the algorithm, all 10 AJprograms under
consideration were shown to be deadlock-free. One program
needed 4 ordering annotations and 2 others required minor
refactorings. For the remaining 7 programs, no programmer
intervention of any kind was required.
REFERENCES
[1] M. Vaziri, F. Tip, and J. Dolby, ‚ÄúAssociating synchronization constraints
with data in an object-oriented language,‚Äù in POPL , 2006, pp. 334‚Äì345.
[2] M. Vaziri, F. Tip, J. Dolby, C. Hammer, and J. Vitek, ‚ÄúA type system
for data-centric synchronization,‚Äù in ECOOP , 2010, pp. 304‚Äì328.
[3] J. Dolby, C. Hammer, D. Marino, F. Tip, M. Vaziri, and J. Vitek, ‚ÄúA
data-centric approach to synchronization,‚Äù ACM TOPLAS 34(1):4, 2012.
[4] C. Hammer, J. Dolby, M. Vaziri, and F. Tip, ‚ÄúDynamic detection of
atomic-set-serializability violations,‚Äù in ICSE , 2008, pp. 231‚Äì240.
[5] S. P. Masticola, ‚ÄúStatic detection of deadlocks in polynomial time,‚Äù
Ph.D. dissertation, Rutgers University, 1993.
[6] D. R. Engler and K. Ashcraft, ‚ÄúRacerx: effective, static detection of race
conditions and deadlocks,‚Äù in SOSP , 2003, pp. 237‚Äì252.
[7] T. L. Harris and K. Fraser, ‚ÄúLanguage support for lightweight transac-
tions,‚Äù in OOPSLA , 2003, pp. 388‚Äì402.
[8] T. Reps, S. Horwitz, and M. Sagiv, ‚ÄúPrecise interprocedural dataÔ¨Çow
analysis via graph reachability,‚Äù in POPL , 1995, pp. 49‚Äì61.
[9] C. von Praun and T. R. Gross, ‚ÄúAtomicity violations in object-oriented
programs,‚Äù J. Object Technology 6(3), pp. 103‚Äì122, 2004.
[10] A. Saxena, ‚ÄúStatic detection of deadlocks,‚Äù University of Colorado at
Boulder, Tech. Rep. CU-CS-122-77, 1977.
[11] A. Williams, W. Thies, and M. D. Ernst, ‚ÄúStatic deadlock detection for
Java libraries,‚Äù in ECOOP , 2005, pp. 602‚Äì629.
[12] G. Golan-Gueta, N. Bronson, A. Aiken, G. Ramalingam, M. Sagiv,
and E. Yahav, ‚ÄúAutomatic Ô¨Åne-grain locking using shape properties,‚Äù
inOOPSLA , 2011, pp. 225‚Äì242.
[13] M. Emmi, J. S. Fischer, R. Jhala, and R. Majumdar, ‚ÄúLock allocation,‚Äù
inPOPL , 2007, pp. 291‚Äì296.
[14] G. Boudol, ‚ÄúA deadlock-free semantics for shared memory concurrency,‚Äù
inTheoretical Aspects of Computing - ICTAC 2009 , 2009, pp. 140‚Äì154.
[15] P. Gerakios, N. Papaspyrou, and K. Sagonas, ‚ÄúA type and effect system
for deadlock avoidance in low-level languages,‚Äù in TLDI , 2011, pp. 15‚Äì
28.
[16] C. Boyapati, R. Lee, and M. C. Rinard, ‚ÄúOwnership types for safe
programming: preventing data races and deadlocks,‚Äù in OOPSLA , 2002,
pp. 211‚Äì230.
[17] J. Noble, J. Potter, and J. Vitek, ‚ÄúFlexible alias protection,‚Äù in ECOOP ,
1998, pp. 158‚Äì185.
[18] C. S. Gordon, M. D. Ernst, and D. Grossman, ‚ÄúStatic lock capabilities
for deadlock freedom,‚Äù in TLDI ‚Äô12 , 2012, pp. 67‚Äì78.
[19] R. Agarwal, L. Wang, and S. D. Stoller, ‚ÄúDetecting potential deadlocks
with static analysis and run-time monitoring,‚Äù in Haifa VeriÔ¨Åcation
Conference , 2005, pp. 191‚Äì207.
[20] K. Havelund, ‚ÄúUsing runtime analysis to guide model checking of Java
programs,‚Äù in SPIN , 2000, pp. 245‚Äì264.
[21] V . T. Vasconcelos, F. Martins, and T. Cogumbreiro, ‚ÄúType inference
for deadlock detection in a multithreaded polymorphic typed assembly
language,‚Äù in EPTCS , vol. 17, 2010, pp. 95‚Äì109.
10APPENDIX
A. Typing
The most complete description of AJ‚Äôs type system is
given in [3]. This section presents the small changes that are
required to validate ordering annotations. A class deÔ¨Ånition C
is well-typed if its Ô¨Åelds are well-typed in the context of C.
Furthermore, all methods (including non-overridden inherited
methods) must be well-typed. In the deÔ¨Ånitions below, we use
the notation Chasato indicate that class Cdeclares or inherits
an atomic set a. Checking a Ô¨Åeld declaration where is a type
with an alias ordering annotation simply requires checking that
all referenced atomic sets exist.
(T-FIELD )
(Djthis:b<ajimplies Dhasaand Chasb)
(=atomic (b)implies Chasb)
fOK in C
Checking a method requires typing its body in an envi-
ronmentEconstructed by composing the disjoint sets of
parameters x, local variables zand the distinguished variable
this. If class Chas an atomic set a, the type of this is
Cja<=this:aj. The type of the local variable yappearing in
the return statement must match the return type of the method,
and if the method overrides an inherited method, the signature
must be unchanged.
(T-METHOD )
Ex:x;z:z;this :thisE`s;return y
E(y) =Cextends D
(ifChasathenthisCjthis:a<ajelsethisC)
override (m;D;x!)
(xEjthis:a<bjimplies
Ehasband Chasaand mis constructor )
m(xx){zz;s;return y}OK in C
Type checking casts simply requires checking that when
the source variable has an ordering annotation this ordering
annotation not be modiÔ¨Åed by the cast.
(T-CAST -ASET )
E(x) =Djthis:b<ajE(y) =Cjthis:b<aj
ChasaE(this)hasb D<:C
E`y= (Cjthis:b<aj)x
It is possible to entirely discard any alias annotation, in-
cluding ordering constraints.
(T-CAST -OFF)
E(x) =Cjthis:b<aj Cnotinternal E(y) =C
E`y= (C)x
The rule for method calls checks the types of the arguments
and the return type. Viewpoint adaption is necessary to ensure
that the types of the arguments and the return value are visiblefrom the viewpoint of the receiver. We do not detail viewpoint
adaption here, the only important consideration is that it does
not change ordering annotations.
(T-CALL )
E(y) =y typeof (y:m) =! E (z) =z
z=adapt (; y)0=adapt (;y)E(x) =0
E`x=y:m(z)
The rules for Ô¨Åeld selection and Ô¨Åeld update are unchanged.
They already check that the type of the Ô¨Åeld matches exactly
(including ordering annotations) that of the variable it is stored
into.
(T-SELECT )
E(this) = E (x) =ftypeof (:f) =f
E`x=this:f
(T-UPDATE )
E(this) = E (y) =ftypeof (:f) =f
E`this:f=y
B. Compiler
To support ordering annotations, the AJcompiler must
be modiÔ¨Åed to ensure that a programmer-speciÔ¨Åed ordering
between different instances of an atomic set is consistent with
the runtime ordering that is used to enforce orderly acquisition
of locks when multiple locks are taken by one unit of work.
This order is implemented by assigning a lockId to newly
constructed objects.
We assign lockIds to newly constructed objects that are
constrained by ordering annotations as follows. For instance
creations of the form
new Nodejthis.n <nj()
the lockId of the newly created object is assigned such that
it is larger than the object referred to by this. In practice, we
pick the Ô¨Årst available lockId which is larger. Conversely for
new Nodejn<this.nj()
the implementation would pick the Ô¨Årst available lockId less
than the lockId of this. Lastly, consider the case when the
new object is constrained by an ordered parameter of its
constructor:
class Personf
atomicset a;
Ô¨Ånal private Personjthis.a <ajdad;
Person(Personjthis.a <ajother)fdad = other;g
g
In this example the ordering annotation tells us that we will
always grab the lock on a child before locking its dad. When
aPerson is constructed, the compiler ensures that the lockId
of the newly allocated object is set to the Ô¨Årst available value
smaller than dad‚Äôs.
11C. Informal Correctness Argument
We plan to demonstrate the correctness of our algorithm as
follows. Here, we consider the simple case involving 2 threads
and 2 locks. We expect that more complicated cases with more
threads and locks could be handled similarly, but we have not
yet worked out all the details.
a) Step 1.: First, we plan to demonstrate that in a type-
correct AJprogram with ordering annotations, the <relation
speciÔ¨Åed by the annotations represents a valid partial order
on the type‚Äôs atomic-set instances. To do this, we rely on
the fact that ordering annotations can only be introduced
on newly constructed objects, and can only specify a single
ordering constraint. Furthermore, the syntax and typing rules
prevent two objects that are being constructed simultaneously
from introducing conÔ¨Çicting constraints with respect to one
another. Notice that we can always add a newly constructed
object to a total order on existing objects subject to a single
constraint while maintaining the order: simply place the new
object at the beginning or end of the existing order, whichever
satisÔ¨Åes the constraint. We can further show that the typing
rules ensure that if an order-constrained object Ô¨Çows into
an order-annotated variable, then the annotation matches the
single ordering constraint that was speciÔ¨Åed at the object‚Äôs
construction.
b) Step 2.: The main proof would be by contradiction:
we assume that our analysis declares a type-correct program
to be deadlock-free. Now suppose that the program deadlocks
in practice.
In the simple case that we consider here, the program has
two threads T1andT2that operate on two locks L1andL2
such that:
T1has acquired the lock L1and is now trying to acquire
the lockL2
T2has acquired the lock L2and is now trying to acquire
the lockL1
Since the program was written in AJ, locks L1andL2
are associated with instances of atomic sets. Since there is
deadlock, they have to be associated with two different atomic-
set instances. There are two cases:
Case 1:L1is an instance of some atomic set A, andL2
is an instance of some other atomic set B. Without loss of
generality, we assume that T1acquiredL1in unit of work u1
forA, and that it is now trying to acquire L2in unit of work
u2for B. Likewise, let us assume that T2acquiredL2in unit
of worku3forB, and that it is now trying to acquire L1
in unit of work u4for A. But then our algorithm would have
inferredA<B andB <A , which is in contradiction with the
fact that the program is declared deadlock-free. Note that rules
SHARE -1 and SHARE -2 generate additional constraints based
on the global existence of an aliasing annotation between two
atomic sets. Thus, even if the analysis applied rule UOW to the
involved units of works knowing only some aliased names, say
CandD, the constraints A < B andB < A would still be
generated.
Case 2:L1andL2are associated with two differentinstances,a1anda2, of some atomic set A. Without loss of
generality, let us assume that T1acquiredL1in unit of work
u1forA, and that it is now trying to acquire L2in unit of
worku2forA. Likewise, let us assume that T2acquiredL2
in unit of work u3forA, and that it is now trying to acquire
L1in unit of work u4forA. Then, the algorithm of Fig. 10
would infer A < A unless annotations indicate that botha1
is ordered less than a2and vice versa. But this contradicts
the fact that the ordering annotations on atomic-set instances
for any type constitute a valid partial order, as we argued in
Step 1 above.
12