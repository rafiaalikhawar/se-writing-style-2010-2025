Scenario-Based and Value-Based Speciﬁcation Mining:
Better Together
David Lo
School of Information Systems
Singapore Management University
davidlo@smu.edu.sgShahar Maoz
Dept. of Computer Science 3
RWTH Aachen University, Germany
maoz@se-rwth.de
ABSTRACT
Speciﬁcation mining takes execution traces as input and ex-
tracts likely program invariants, which can be used for com-
prehension, veriﬁcation, and evolution related tasks. In this
work we integrate scenario-based speciﬁcation mining, which
uses data-mining algorithms to suggest ordering constraints
in the form of live sequence charts, an inter-object, visual,
modal, scenario-based speciﬁcation language, with mining of
value-based invariants, which detects likely invariants hold-
ing at speciﬁc program points. The key to the integration
is a technique we call scenario-based slicing , running on top
of the mining algorithms to distinguish the scenario-speciﬁc
invariants from the general ones. The resulting suggested
speciﬁcations are rich, consisting of modal scenarios anno-
tated with scenario-speciﬁc value-based invariants, referring
to event parameters and participating object properties.
An evaluation of our work over a number of case studies
shows promising results in extracting expressive speciﬁca-
tions from real programs, which could not be extracted pre-
viously. The more expressive the mined speciﬁcations, the
higher their potential to support program comprehension
and testing.
Categories and Subject Descriptors: D.2.1 [Software
Engineering]:Requirements/Speciﬁcations–Tools;D.2.7 [Soft-
ware Engineering]:Distribution, Maintenance and Enhance-
ment–Restructuring, reverse engineering and reengineering
General Terms: Algorithms, Design, Experimentation
Keywords: Speciﬁcation Mining, Dynamic Analysis, Live
Sequence Charts, Value-Based Invariants
1. INTRODUCTION
A speciﬁcation typically imposes constraints both on se-
quencing of method calls or statement executions (ordering
constraints), and on values that method parameters or some
variables at a program point could have (value constraints).
One takes a separate viewpoint from the other, and each in-
dependently, although interesting, is unable to present the
full picture on the speciﬁcation that a system should follow.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.Motivated by the lack of documented speciﬁcations, re-
cently a number of studies have investigated mining of sug-
gested speciﬁcations from program executions, e.g., [13, 26,
31]. The mined speciﬁcations, whether value-based invari-
ants, automata/ﬁnite state machines, or scenario-based be-
havioral models, may be used for tasks related to program
comprehension, veriﬁcation, and evolution.
One pioneering work, Daikon, mines for value-based in-
variants that hold at user-speciﬁed program points [13]. Val-
ues of method parameters, object properties etc. are col-
lected at selected program points during execution, and are
then generalized in order to suggest invariants that hold at
these points. Also, recently, we have investigated mining an
expressive visual sequence-diagram-like scenario-based spec-
iﬁcation in the form of live sequence charts (LSC) [9,16] us-
ing a data-mining approach [26,28,29]. However, these have
only considered ordering constraints among method calls.
In this paper, we merge the two speciﬁcation mining ap-
proaches – the value-based approach of Daikon [13] and our
scenario-based approach – resulting in one that mines a com-
bination of ordering and value-based invariants. The key to
the merging is a multi-step mining process and a novel dy-
namic slicing technique we call scenario-based slicing , where
the mined scenarios are used as a slicing criteria over the
input traces. Following the initial scenario-based mining,
value-based invariants found over the sliced traces are com-
pared against value-based invariants found over the original
traces, so as to distinguish the ones unique to the scenarios
context. Finally, the invariants found are attached to the
mined scenarios. Thus, the resulting approach strengthens
the expressive power of the mined scenarios by enriching
them with scenario-specic value-based invariants .
To illustrate the advantages and challenges of mining sce-
narios with value-based invariants consider the following ex-
ample, taken from one of our case study applications, Cross-
FTP [1], a commercial open-source FTP server. Using the
scenario-based speciﬁcation mining technique presented in
previous work [29], we were able to mine the scenario shown
in Fig. 1. Roughly, this scenario speciﬁes that \whenever a
PASV command object calls the method setPasvCommand(...)
of the FtpDataConnector (DC), and the DCcalls the
getSSL(...) method of a FtpDataConnectionConfig (DCC),
it must eventually call the createServerSocket of an Ssl
object ( SSL)". However, the mined scenario does not pro-
vide information on the values of parameters used and par-
ticipating object properties whenever this scenario indeed
happened . Are there any value-based invariants related and
unique to this scenario?
387
Note that discovering general value-based invariants re-
lated to the methods that appear in this scenario or to its
participating objects may not be good enough. The same
method may be called with diﬀerent parameters in diﬀerent
contexts and thus the invariant we may extract from its calls
would be too general - in essence, too weak - not contribut-
ing to the understanding of the scenario at hand. Similarly,
participating object properties may hold diﬀerent values in
diﬀerent contexts.
Scenario-based slicing is used to address this problem.
Following the process of scenario-based speciﬁcation min-
ing, we construct a sliced trace by selecting from the original
traces used for mining a concatenation of only the sub-traces
representing instances – positive witnesses – of the mined
scenario at hand. We then look for value-based invariants
twice – on the original trace and on the sliced trace – and
compare the results in order to identify the scenario-speciﬁc
invariants, those value-based invariants that are unique to
the witnesses of the scenario.
Indeed, to continue the example just presented, we were
able to ﬁnd that whenever this scenario happens, the prop-
erty secure of the FtpDataConnection (DC) is true. This
invariant does nothold in general in our traces and hence
is not suggested by Daikon when running on the original
traces. However, it does hold whenever the scenario we ex-
amine happens!
Thus, the combination of value-based speciﬁcation mining
and scenario-based speciﬁcation mining, through the use of
scenario-based slicing, is able to produce expressive candi-
date speciﬁcations that each of the mining approaches alone
is unable to produce. As shown in previous work [6,12,33,37,
41], the mined speciﬁcations may be used for tasks related
to program comprehension, testing, and veriﬁcation. Natu-
rally, the more expressive the speciﬁcation mined, the better
it may support these tasks. Speciﬁcally, program compre-
hension is enhanced with stronger candidate invariants, com-
bining execution order and values. Tests that are induced by
these invariants are more accurate and hence more valuable.
We have implemented our ideas and evaluated them us-
ing a number of case study applications; see Sec. 5. The
examples throughout the paper are taken from two of these,
CrossFTP (mentioned above), and Jeti [3], a feature-rich
instant messaging application.
Speciﬁcation mining in general, and combining mining of
value-based invariants with mining of ordering constraints
in particular, has been recently considered and implemented
(see, e.g., [31]). We discuss related work in Sec. 7.
Paper organization: Sec. 2 covers background material on
LSC, scenario-based speciﬁcation mining, and value-based
speciﬁcation mining. The syntax and semantics of scenarios
with value-based invariants, our target speciﬁcation formal-
ism, are presented in Sec. 3. Sec. 4 describes the mining
framework and algorithms. The results of case studies are
given in Sec. 5. Sec.6 discusses some advanced issues of our
work, its advantages and its limitations, Sec. 7 discusses re-
lated work, and Sec. 8 concludes.
2. BACKGROUND
We provide background material on LSC, scenario-based
speciﬁcation mining, and value-based invariants mining.
2.1 Live Sequence Charts
Live sequence charts (LSC) [9,16] extend classical sequence
LSC Set PASV – Short
setPasvCommand(…)
createServerSocket(…)SSL DCC DC PASV
getSSL(…)
Figure 1: Example LSC: SECURE PASV
diagrams with a universal interpretation and must/may mo-
dalities. They thus allow the speciﬁcation of scenario-based
temporal invariants describing interactions between system
objects. The language has been used in the context of exe-
cution, veriﬁcation, and synthesis (see, e.g., [20, 23, 32]). A
translation of LSC into temporal logics appears in [22]. A
trace-based semantics for a UML2-compliant variant of LSC
appears in [16]. We use here a subset of the language, with
total-order events.
An LSC is composed of two basic charts: a pre-chart and
amain-chart . A basic chart is a tuple C= (CL; CE; C<)
where CLis a set of lifelines representing system objects,
CEis a set of inter-object events involving the objects rep-
resented by the lifelines in CL, and C<is a total order on CE.
Thus, a chart can also be represented as a chain of events
⟨e1; : : : ; e n⟩. We denote an LSC by L(pre; full ), where preis
the pre-chart and full is the concatenation of the pre-chart
and main-chart.
Syntactically, lifelines are drawn using vertical lines. Inter-
object events are drawn using horizontal arrows from caller
to callee; pre-chart events use dashed blue lines, main-chart
events use solid red lines.
Semantically, an LSC speciﬁes a temporal invariant: when-
ever the events in the pre-chart occur in the speciﬁed order,
eventually the events in the main-chart must occur in the
speciﬁed order. An LSC does not restrict events not appear-
ing in it to occur or not to occur during a run.
Fig. 1 shows an example LSC. Roughly, this LSC means
that \whenever a PASV command object calls the method
setPasvCommand(...) of the FtpDataConnection (DC), and
theDCcalls the getSSL(...) method of a FtpDataCon-
nectionConfig (DCC), it must eventually call the create-
ServerSocket of an Sslobject ( SSL)".
2.2 Scenario-Based Speciﬁcation Mining
Scenario-based specication mining [26–29] is concerned
with extracting statistically signiﬁcant LSCs from inter-object
traces of a system under investigation.
Inter-object trace, event. Aconcrete inter-object trace
is a sequence of inter-object events. A concrete inter-object
event evis a tuple ⟨el1; el2; m⟩representing an object el1
(the caller) calling method mof object el2(the callee).
We deﬁne the signicance of an LSC based on its occur-
rences in the traces and measure it using support andcon-
dence , commonly used metrics in data mining [14]. Below
we recall the concepts of scenario instance, positive and neg-
ative witnesses, support, and conﬁdence, deﬁned in [29].
Chart instance. Satisfaction of a chart follows the se-
mantics of LSC. We refer to a sub-trace (or a segment of
consecutive events in the trace) satisfying the chart Cas an
instance of C. A segment of a trace is said to be an instance
of a chart Cif it obeys the ordering speciﬁed by C. Each
event in the chart must map to a corresponding event in the
segment appearing in the speciﬁed order. Other events not
388speciﬁed by the chart can occur in any order, unrestrictedly.
To describe an LSC chart instance, we use Quantiﬁed Reg-
ular Expressions (QRE) [35]. In our context, quantiﬁed reg-
ular expression is similar to standard regular expression with
‘;’ as concatenation operator, ‘[-]’ as exclusion operator ( i.e.
[-P,S] means any event except P and S1), and * as the stan-
dard kleene-star. The formal deﬁnition of an instance of a
chart is given in Defn. 2.1 (see [29]):
Definition 2.1 ( Instance of a Concrete Chart) .
Given a concrete chart C= (CL; CE; C<), a trace segment
SB=⟨sbi,sbi+1,: : :,sbi+m 1⟩is an instance of CifSB
follows the QRE expression
e1; [−G]∗;e2;: : :; [−G]∗;en where;
CE={e1; e2; : : : ; e n},∀0<i<n :ei<Cei+1, and G=CE.
Fig. 2 shows a short sample from a trace. The trace in-
cludes 2 instances of the LSC shown in Fig. 1: I1=⟨1;2;3⟩,
I2=⟨8;10;11⟩.
1 PASV DC setPasvCommand()
2 DC DCC getSSL()
3 DC SSL createServerSocket()
4 FRI DC getDataSocket()
5 PASV DC setPasvCommand()
6 FW FRI getUserArgument()
7 DC DCC getSSL()
8 PASV DC setPasvCommand()
9 FW FRI getUserArgument()
10 DC DCC getSSL()
11 DC SSL createServerSocket()
12 FRI DC getDataSocket()
13 PASV DC setPasvCommand()
Figure 2: Part of a sample trace ( PASV stands
for the PASV class, DCfor FtpDataController ,DCCfor
FtpDataConnectionConfig ; the actual trace includes the full
qualied signatures of the classes and methods involved)
Witnesses. Based on the above deﬁnition of a chart in-
stance, we deﬁne the notion of positive and negative wit-
nesses of an LSC. Recall that an LSC is composed of a pre-
chart and a main-chart. A positive witness of an LSC L=
L(pre,full), is a trace segment satisfying (i.e., is an instance
of) the full chart – by extension the prechart as well, since
preis a preﬁx of full. A negative witness ofLis a posi-
tive witness of prethat can not be extended to a positive
witness of L(orfull). We say that a negative witness is a
weak negative witness if the positive witness of precannot
be extended due to end-of-trace being reached (see discus-
sion in [29]). We denote the set of all positive witnesses of
an LSC L in a trace T by pos(L,T). Similarly, we denote
the set of negative witnesses as neg(L,T).
Support & condence. We use the above notions of
witnesses to deﬁne the statistical support and condence
metrics for LSC. Support and conﬁdence are commonly used
statistics in data mining [14]. Given a trace T, the support
of an LSC L=L(pre; full ), denoted by sup(L), is simply
deﬁned as the number of positive witnesses of full found
inT. The condence of an LSC L, denoted by conf(L),
measures the likelihood of a sub-trace in Tsatisfying L’s
pre-chart, to be extended such that L’s main-chart is sat-
isﬁed or the end of the trace is reached. Hence, conﬁdence
1The original notation is slightly modiﬁed for brevity.is expressed as the ratio between the number of positive-
witnesses and weak-negative-witnesses of the LSC and the
number of positive-witnesses of the LSC’s pre-chart:
conf(L; T)≡defjpos(full;T )j+jw
neg(full;T )j
jpos(pre;T )j
Notation-wise, when Tis understood from the context, it
can be omitted.
The support metric is used to limit the extraction to fre-
quently observed interactions. The conﬁdence metric re-
stricts mining to such pre-charts that are followed by par-
ticular main-charts with high likelihood. In scenario-based
speciﬁcation mining we are interested in mining statistically
signiﬁcant LSCs: those which occur frequently in the trace
(have high support) and in which the pre- is followed by the
main- chart with high likelihood (have high conﬁdence). A
chart is said to be signicant if it obeys minimum thresh-
olds of support and conﬁdence, denoted by min
supand
min
conf respectively.
For the LSC shown in Fig. 1 and the trace shown in Fig. 2,
sup(L) = 2, conf (L) = 2 =3.
Data mining algorithms to compute a statistically sound
and complete set of LSCs, given a trace (or a set of traces)
and thresholds for minimal support and conﬁdence, were
presented in [29]. These were extended in [27], to han-
dle symbolic scenario-based speciﬁcations (at the class level
rather than the object level), in [26], to handle the special
case of trigger and eﬀect mining, and in [28], to take advan-
tage of architectural hierarchies.
2.3 Value-Based Invariants Mining
Value-based dynamic detection of likely invariants is con-
cerned with reporting likely program invariants, which hold
at a certain point or points in a program’s execution. Basi-
cally, dynamic invariant detection runs a program, observes
the values that the program computes, and then reports
properties that were true over the observed executions.
A primary example of a dynamic invariants detector is
Daikon [13]. Other examples are described in, e.g., [7, 36].
As opposed to scenario-based speciﬁcation mining, which,
like, e.g., [6, 25, 41], is concerned with detecting temporal
invariants in the form of ordering constraints over program
events, these tools aim at detecting value-based invariants,
e.g., in the form of arg1 == false orreturn != null for
a certain method, this.field has only one value for a
certain object, etc.
In our present work we integrate temporal invariants with
value-based invariants. For value-based invariants detection
we use Daikon. For details on Daikon internals see [13].
3. SCENARIOS WITH VALUE-BASED IN-
VARIANTS
We now describe our target formalism, namely scenario-
based speciﬁcations with value-based invariants.
We consider three types of value-based invariants inside
LSCs: invpre,invpost, and invglobal ;invpreandinvpostare
attached to LSC events, and may refer to event parameters
or properties of the objects (caller and callee) involved in
the event; invglobal invariants are attached to the LSC as a
whole, and involve properties of objects participating in the
LSC.
More formally, a chart with value-based invariants is a
tuple CA= (CL; CE; C<; A) where the events in CEare
389tuples ⟨el1; el2; m; inv pre,invpost⟩representing an object el1
(the caller) calling method mof object el2(the callee) with
invpreholding immediately before the call, invpostholding
right after the call, and Ais a set of global invariants, holding
throughout the chart instance occurrence.
Semantically, an LSC L(pre; full ) made of basic charts
annotated with value-based expressions speciﬁes a tempo-
ral invariant: whenever the events in the pre-chart occur in
the speciﬁed order, their corresponding invpreandinvpost
expressions hold, and the pre-chart’s global invariants hold
throughout its occurrence, eventually the events in the main-
chart must occur in the speciﬁed order, their corresponding
invpreand invpostexpressions must hold, and the main-
chart’s global invariants must hold throughout the occur-
rence of the main-chart. Naturally, an LSC does not restrict
events not appearing in it to occur or not to occur during
a run, and does not restrict the properties appearing in its
value-based invariants to take any value outside the LSC
context.
In the visual syntax of the LSC, invpreandinvpostexpres-
sions may be drawn adjacent to the arrow representing their
corresponding event, or in a table below the chart, together
with the invglobal expressions.
Fig. 9 shows an example LSC annotated with a value-
based invariant. The invariant found, this.secure==true ,
is a global one, related to a property of DC, one of the ob-
jects participating in the scenario. Additional examples are
shown in Sec. 5.
Note that the LSC language as described in [9, 16] in-
cludes conditions (also called state-invariants ), which spec-
ify hot/cold conditions that must/may hold during the oc-
currence of a scenario. Also, the variant of LSC deﬁned
in [17] includes forbidden conditions , which may be used as
invariants over the scope of the entire scenario. Our tar-
get formalism is similar, with cold pre-chart conditions and
hot main-chart conditions. However, it is also somewhat
diﬀerent, tying conditions directly to events pre- and post-
occurrence, and specifying not what should never happen
but what should always happen throughout the occurrence
of a chart.
4. MINING FRAMEWORK
Our mining solution integrates Daikon [13], a value-based
speciﬁcation miner, with our previous solution for mining
scenario-based speciﬁcations in the form of LSC [26,28,29].
As is shown in Fig. 3, the framework involves a number of
steps: trace generation and conversion, scenario-based spec-
iﬁcation mining, scenario-based slicing, value-based invari-
ant generation via Daikon, and selection and integration of
scenario-speciﬁc invariants.
First, the input application is instrumented using the Dai-
kon front end. Running the instrumented program produces
a trace ﬁle (Daikon Trace File (DT)), which is converted
to the format accepted by the scenario-based speciﬁcation
miner (LSC Miner Trace File (LT)). Running the scenario
miner produces a set of scenarios, all of which may be fur-
ther enriched with value-based invariants. For each of the
scenarios, we take DT and transform it to a scenario-based
sliced trace (SDT). Daikon is then invoked on the sliced
and original traces, i.e., DT and SDT. A comparison of the
invariants found on the sliced trace and the original trace al-
lows us to identify scenario-speciﬁc invariants, used to enrich
and strengthen the suggested scenario-based speciﬁcations.
 
1. Instrument 
Program Using 
Daikon 
Chicory  2.  Capture 
Caller-Callee 
Relationship & 
Object  IDs  3. Scenario-
Based 
Specification 
Miner  
4. Scenario-
Based Slicer 5. Daikon 6. Invariant 
Comparator 
7. Integrate Scenario-
Specific Value-Based 
Invariants into the LSCs  Daikon  
Trace 
(DT) LSC  
Miner  
Trace  
(LT)  
Scenarios/  
LSCs  
Sliced  
Daikon  
Trace (SDT) Invariants 
on DT  
Invariants 
on SDT  
Scenarios/  
LSCs  Daikon  
Trace(DT)  
Scenario 
Specific 
Invariants  
Figure 3: Mining Framework
The steps are described in further detail below.
4.1 Trace Generation and Conversion
We use the Daikon tool’s front end to generate traces.
Daikon provides a number of front ends for Java, C, etc., all
of which produce a common trace format for Daikon’s in-
put. The trace ﬁles of Daikon contain the list of records cor-
responding method entries and exits during the run. Each
record contains information on method signature along with
the values associated with diﬀerent parameter values and
global variables when each of the methods was entered or
exited. These traces are very rich as compared to the typi-
cal traces collected by most speciﬁcation mining tools that
mine for temporal ordering constraints/invariants. This is
particularly needed by Daikon, so as to be able to infer value-
based invariants.
On the one hand, the scenario-based speciﬁcation miner
looks only for temporal relationships and does not need to
know about parameters and global variables. On the other
hand, the scenario-based speciﬁcation miner needs more in-
formation pertaining to the caller and callee of method calls.
Thus, we employ a converter to extract caller-callee informa-
tion based on the method entry and exit entries in Daikon
trace. The converter also remove unneeded information for
the scenario-based mining process including values of global
variables, parameters, etc..
4.2 Scenario-Based Speciﬁcation Mining
Given the converted traces, we run a scenario-based spec-
iﬁcation mining algorithm. We are interested in ﬁnding sce-
narios that appear more times than a speciﬁed user-deﬁned
min
supthreshold. Each extracted scenario must also have
its main-chart appearing after each pre-chart with likelihood
higher than a min
conf threshold.
The scenario-based speciﬁcation mining algorithm works
in three steps: mining frequent charts, chart composition to
LSC, and chart redundancy elimination and post processing.
Frequent chart mining. The frequent chart mining algo-
rithm is a variant of a pattern mining algorithm that mod-
els mining as a search space exploration. Diﬀerent from a
standard pattern mining algorithm that is agnostic to se-
mantics of program speciﬁcations, our speciﬁcation mining
algorithm follows the semantics of LSC when identifying and
390counting the chart/pattern occurrences in the traces. Also,
since we consider scenario-based speciﬁcations in the form of
sequence diagrams, the input events are not atomic symbols
but rather triplets of caller, callee, and method call signa-
ture. A simpliﬁed pseudo-code is shown in Fig. 4.
Procedure MineFrequentCharts
Inputs:
T: Input trace
min
sup: Minimum support threshold
Output: All frequent charts
Method:
1: Let FEv = All frequent events in trace T
2: For each evinFEv
3: GrowChart( ev,T,FEv,min
sup,min
conf)
Procedure GrowChart
Inputs:
P: Chart so far
T: Input trace
FEv : Frequent event
min
sup: Minimum support threshold
Output: All frequent charts in the form of P+ +evs
Method:
4: Let NxtPat ={P+ + e |e∈FEv}
5: For each nxtinNxtPat
6: If sup( nxt)≥min
sup
7: Output nxt
8: GrowChart ( nxt,T,FEv,min
sup,min
conf)
Figure 4: Frequent Chart Mining Algorithm
The frequent chart mining process starts with chart of
size 1 and then tries to form longer patterns. Based on an
anti-monotonicity property (see [29]), the support or number
of occurrences of a pattern Pshould be larger or equal to
the support of pattern P+ +evs, where evsis one or more
events. In this case, we only need to consider patterns of
length one with support larger than the min
supthreshold
(i.e., frequent ones) (Line 1).
Each of the frequent events is then grown to form longer
frequent patterns (Lines 2-3). The search space of all pat-
terns is traversed in a depth ﬁrst fashion by appending one
event at a time (Line 4). At each step one would compare the
number of occurrences of a pattern to the min
supthreshold
(Lines 5-6). If the minimum support threshold is not met,
then based on the anti-monotonicity property, there is no
need to grow the pattern further, as longer patterns would
not be frequent. If the threshold is met, the algorithm will
output the pattern (Line 7) and continue to try to grow
the pattern further (Line 8). The algorithm will eventually
terminate with the set of all frequent charts.
Chart composition to LSC. An LSC consists of pre- and
main- charts and has the semantics that dictates that the
pre-chart must be followed by the main-chart. Given the
set of frequent charts mined, one could form LSCs by com-
posing these charts. In particular one could pair two charts,
one being a preﬁx of the other. Consider two charts pre
andpre+ +post, one could then form the LSC having preas
the pre-chart and post as the main-chart. The process is
illustrated in Fig. 5.
Note that due to the anti-monotonicity property, the sup-
port of the pre-chart is larger or equal to the support of the
CHART DEL-A
onDeleteStart()FC DELE
LSC DEL
setDelete()
setDelete()onDeleteEnd()FSI FC DELELSC DEL
setDelete()
setDelete()onDeleteEnd()FSI FC DELE
CHART DEL-B
setDelete()onDeleteStart()
onDeleteEnd()FSI FC DELEU
conf(LSC DEL) >= min_conf ?
OUTPUTYes
Figure 5: Chart Composition to LSC
pre-chart concatenated with the main-chart. Following the
semantics of LSC, we are only interested in retrieving LSCs
where the pre- is followed by the main-chart. Since the trace
could be incomplete, there could be bugs in the system, and
we are analyzing long running reactive systems, we provide
users with the ability to extract near perfect scenarios where
the pre-chart is only followed by the main-chart with likeli-
hood less than 100%. We refer to this notion of likelihood
based on the observed traces as the conﬁdence of the LSC.
Hence, given a composition of two frequent charts resulting
in an LSC with conﬁdence greater than a minimum conﬁ-
dence threshold min
conf, we would output the LSC. We
refer to the LSCs obeying the min
supandmin
conf thresh-
olds as the set of signicant LSCs.
Redundancy elimination and post-processing. Often,
there are too many signiﬁcant LSCs. One potential root
cause is that all sub-LSCs of a large and signiﬁcant LSC are
potentially signiﬁcant too. Thus there could be a combi-
natorial number of mined LSCs. Thus, it would be better
to mine a representative set of LSCs. To do this we only
extract maximal LSCs without any larger LSCs having the
same signiﬁcance values of support and conﬁdence. To do
this eﬃciently, we ﬁrst bucketize the LSCs into support and
conﬁdence value buckets. A one-to-all comparison to look for
non-redundant LSCs should only then be performed among
LSCs in each bucket rather than over all frequent and conﬁ-
dent LSCs. The number of buckets depends on the number
of unique combinations of support of conﬁdence values of
the LSCs. The more spread-out the distribution of support
and conﬁdence value pairs the more eﬀective the proposed
process would be. The process is illustrated in Fig. 6.
4.3 Scenario-Based Slicing
After a set of scenarios is mined, each scenario (or selected
ones) may be enriched with value-based invariants. To do
this, the parts of the traces that correspond to a scenario
under consideration are selected. We refer to this process as
scenario-based slicing . Consider a scenario Land a trace T,
the slice of the trace Twith respect to Lis the sequence of
positive witnesses of Lin the trace T. Let + + and ⊑rep-
resent the concatenation of two sequences of events and the
sub-sequence relationship between two sequences of events.
391Bucketization 
Based on Support 
and Confidence 
Values All Significant 
Live Sequence 
Charts 
Bucket 
1 
Redundancy Elimination 
(One Bucket At A Time) Bucket 
2 Bucket 
n 
Figure 6: Redundancy Elimination
The scenario-based slicing operation is deﬁned as follows.
Definition 4.1 ( Scenario-Based Slicing) .Consider
a trace T=⟨ev1; : : : ; ev n⟩and an LSC L. Slicing Twith
respect to Lproduces a sub-trace ST, such that STis the
maximal sub-sequence of Tcomposed of series of positive
witnesses of L. Formally, ST=ST1+ +: : :+ +STn, where
ST⊑Tand{ST1,: : :,STn}= pos( L,T).
As an example, consider the following trace:
1: USER | FTPWriter | send()
2: FTPWriter | FTPRequestImpl | getUserArgument()
3: USER | FTPRequestImpl | resetState()
4: PWD | FTPRequestImpl | getSystemFileView()
5: PWD | FtpWriter | send()
6: USER | FTPWriter | send()
7: FTPWriter | FTPRequestImpl | getUserArgument()
8: PWD | FtpWriter | send()
9: USER | FTPRequestImpl | resetState()
LSC – Send-Simple
getUserArgument()send()
resetState()FTPRequestImpl FTPWriter USER
Figure 7: LSC - Send Simple
Slicing the above trace with the LSC shown in Fig. 7 re-
sults in the following sliced trace:
1: USER | FTPWriter | send()
2: FTPWriter | FTPRequestImpl | getUserArgument()
3: USER | FTPRequestImpl | resetState()
6: USER | FTPWriter | send()
7: FTPWriter | FTPRequestImpl | getUserArgument()
9: USER | FTPRequestImpl | resetState()
Note that the 4th, 5th, and 8th events in the original trace
are removed. The above shows the simpliﬁed representation
used for scenario-based mining. The system maintains a one-
to-one correspondence between the events in the LSC mining
trace and the events in the Daikon trace. Converting the
events in the sliced traces back to Daikon events produces a
sliced Daikon trace. With the original Daikon trace and the
sliced Daikon trace, we are ready for the next step.4.4 Scenario-Speciﬁc Invariants
Running Daikon on the original trace produces invariants
for entry and exit points of each of the instrumented meth-
ods. These invariants hold for every invocation of the re-
spective method in the traces. While these are useful, they
are too general, or generic, and not scenario-speciﬁc. Thus,
they are not good enough for our purpose.
On the other hand, running Daikon on the sliced trace
produces invariants that hold at entry and exit points of
each of the instrumented methods only when these methods
participate in the witnesses of the scenario at hand . This is
because method invocations that do not participate in the
scenario are not included in the sliced trace and hence are
not considered for the computation of the invariants. Based
on the invariants mined on the original and sliced traces, we
deﬁne the concept of scenario-specic invariants below.
Definition 4.2 ( Scenario-Specic Invariants) .Let
invorigandinvsliced be the set of invariants mined by Daikon
on the original trace and sliced trace respectively. As the
sliced trace is a sub-trace of the original trace, the invari-
ants found on the former are equal to or stronger than the
ones found on the latter. We distinguish the strictly stronger
invariants using a comparison of the two sets. We call
these invariants scenario-specic. This is the set invsliced
\invorig.
For example, for the PASV scenario shown in Fig. 9, Daikon
has not found an invariant related to the Boolean prop-
erty this.secure forDCin the original trace (because in
the original trace, this property was sometimes true and
sometimes false). However, Daikon did ﬁnd the invariant
this.secure==true in the sliced trace, which included only
the sub-traces representing witnesses of the PASV scenario.
Note that a syntactic comparison of the two sets is typi-
cally good enough for our purposes, based on the assumption
that Daikon outputs semantically equivalent invariants us-
ing syntactically identical representations. We discuss this
assumption and its consequences in Sec. 6.
At the end of the process, we have collected a (potentially
empty) set of scenario-speciﬁc invariants including: invpre,
invpostfor each method, and invglobal for the pre-chart and
the main-chart. Finally, we output the mined scenarios an-
notated with these invariants.
5. EXPERIMENTS & EVALUATION
We have implemented our ideas and evaluated them on
two case study applications: CrossFTP server [1] and Jeti
instant messaging application [3]. CrossFTP is a commercial
open-source FTP server built on top of Apache FTP server.
It consists of 18841 LOC, 15 packages, 165 classes, and 1148
methods. Jeti [3] is a popular open-source instant messaging
application. Its core contains 49K LOC, 62 packages, 511
classes, and 3400 methods.
We report here on the results of our experiments (run-
ning on an Intel Core Duo 2.4 GHz, 3.24 GB RAM Windows
XP Tablet PC). The algorithms are implemented in C#.Net
compiled using VS.Net 2005. We used Daikon Chicory to
generate traces from CrossFTP, running it on usage scenar-
ios involving start up, ﬁle transfers, administrator login and
query, server maintenance, etc. Similarly, we used Daikon
Chicory to generate traces from Jeti, running it to chat or
communicate with a remote client. Various details of the
392Program
CrossFTP
Jeti
Trace Size 12,217 evs 3,182 evs 
Scenario Mining
53s
2s
Daikon (All)
132s
54s
Slicing Time
11s
3s
Daikon (Sliced)
31s
23s
Table 1: Experiment Details: Program, Trace Size,
Scenario Mining Time, Daikon Time, Trace Slicing
Time, and Daikon Mining on Sliced Traces Time
experiments including trace sizes and runtimes are shown in
Table 1. We illustrate some miend scenarios in the following
paragraphs.
Retrieving connection information. Fig. 8 shows a sce-
nario from CrossFTP, specifying how the server retrieves in-
formation about the connection it is serving. In the ﬁgure,
theCTM(FTPConnectionTableManager ) retrieves the name
and login time of the connecting user. The table at the bot-
tom of the LSC shows the scenario-speciﬁc value based in-
variants found: The colargument of method getValueAt()
is always set to 1 when the scenario occurs. This is nota
general invariant for the method CTM, but rather a scenario-
speciﬁc invariant related to the context of this scenario. Dif-
ferent values of colargument are found in the traces. Ad-
ditional scenarios involving other values of colare given in
the technical report [4].
For the scenario shown in Fig. 8, a total of 37 scenario-
speciﬁc invariants are reported. This is much less than the
value-based invariants reported by Daikon on the original
trace, consisting 5910 invariants. Indeed, out of the 11 cases
described in this section and in the accompanying technical
report, the number of invariants on the sliced traces is only
0.10% - 4.86% of that found in the original traces. Thus,
this demonstrates an additional beneﬁt of scenario-speciﬁc
invariants: limiting the number of value-based invariants
presented, focusing particularly on a scenario context under
investigation.
LSC Retrieve Connection Info
getValueAt(…)getName(…)
getUser(…)
getLoginTime(…)FRI BUser ENV CTM
{} {col==1} getValueAt()Value-Invariant Post Value-Invariant Pre Method
{} {col==1} getValueAt()Value-Invariant Post Value-Invariant Pre Method
Figure 8: Mined LSC: Retrieve Connection Info-1
PASV FTP command. Fig. 9 shows another mined sce-
nario, which holds when the PASV command is set. An FTP
has two modes of operation, namely PORT and PASV, in
addition to secure (using TLS or SSL) or regular. The sce-
nario captures the case when PASV command is set together
with SSL. We highlighted the most relevant scenario-speciﬁcinvariant namely isSecure==true .isSecure is a property
of the class DC(FtpDataConnection ).
LSC Set PASV Command - SSL
getPasvPort(…)setPasvCommand(…)
getPasvAddr(…)
createServerSocket(…)SSL DCC DC PASV
{this.secure == true,…} DCValue-Invariant Object
{this.secure == true,…} DCValue-Invariant ObjectgetSSL(…)
getInetAddr(…)
getPort(…)
send(…)FRI
resetState(…)
getFtpDataConnection(…)FW
releasePassivePort(…) 
Figure 9: Mined LSC: PASV Command - Secure
Sending data - several commands. Figs. 10 and 11
show two diﬀerent scenarios for CrossFTP, where data pack-
ets corresponding to FTP commands USER and PWD are
issued. Two particularly interesting scenario-speciﬁc value-
based invariants related to the parameters code and subId
of the method send(...) are found. Each of the two sce-
narios has unique scenario-speciﬁc value-based invariants for
these two parameters. Similar examples are available in [4].
LSC Send Data - USER
getUser(…)getArgument(…)
isLoggedIn(…)
setUserArgument(…)FW FRI USER
{subId.toString == 
“USER”,…}{code==331, subId.toString == 
“USER”,…}send()Value-Invariant Post Value-Invariant Pre Method
{subId.toString == 
“USER”,…}{code==331, subId.toString == 
“USER”,…}send()Value-Invariant Post Value-Invariant Pre Methodsend(…)
getUserArgument(…)
isUTF8Encoding(…)
resetState(…)
Figure 10: Mined LSC: Send Data - USER, Port
Command-line startup. Fig. 12 shows one of the scenar-
ios when the CrossFTP server starts using the command-line
option. It shows the default case when the server is started
up with no parameters. It is also possible to start the server
by passing an XML ﬁle. Note that for this scenario, we
capture the scenario-speciﬁc invariants about the method
getConfiguration including: the size of the input args[]
array must be empty, and the type of the returned object
must be equal to PropertiesConfiguration . Another vari-
393LSC Send Data - PWD
getFileSystemView(…)FW FRI PWD
{subId.toString == “PWD”, 
…}{code==257, subId.toString == 
“PWD”, …}send(…)Value-Invariant Post Value-Invariant Pre Method
{subId.toString == “PWD”, 
…}{code==257, subId.toString == 
“PWD”, …}send(…)Value-Invariant Post Value-Invariant Pre Methodsend(…)
getLanguage(…)resetState(…)
Figure 11: Mined LSC: Send Data - PWD, Port
ant involving start-up using XML ﬁle was also mined and is
given in [4].
LSC Command Line Start Up:
Default
getFileFTPD(…)SF CL ENV
{ args[].toString == [], 
return.getClass() == 
org.apache.ftpserver.config.
PropertiesConfiguration.cla
ss, …}{args[].toString == 
[], …}getConfiguration(…)Value-Invariant Post Value-Invariant Pre Method
{ args[].toString == [], return.getClass() == 
org.apache.ftpserver.config.
PropertiesConfiguration.cla
ss, …}{args[].toString == 
[], …}getConfiguration(…)Value-Invariant Post Value-Invariant Pre MethodgetConfiguration(…)
Figure 12: Mined LSC: Command Line Startup Normal
Start chat window. Fig. 13 shows one of the scenarios
when Jeti is used to communicate with a remote client. It
speciﬁes the scenario where a message comes, the system
beeps, and a window is popped up by the Jeti client. Even-
tually the chat window is set up and the system is ready
to accept reply messages from the user. This scenario in-
volves JH ( JabberHandler ), Jabber, CWS ( ChatWindows )
and CW ( ChatWindow ). Note that for this scenario we cap-
ture scenario-speciﬁc invariants about the method receive-
Packets . The method accepts many diﬀerent types of pack-
ets involving presence updates (e.g., Busy, Away, Extended
Away, etc), error messages, etc. However, in the context of
this scenario, there should be only one type of packet be-
ing received by method receivePackets , namely Message .
Also, we capture the scenario-speciﬁc invariants involving
the return type of method getChatwindow , which, in this
scenario, is always null: a chat window creation occurs (the
<<create >> event), which only happens if two parties
have not communicated before, causing the call to method
getChatwindow to return a null value.
Add incoming new picture. Fig. 14 shows a scenario
where Jeti received a new picture creation message from
LSC Create Chat Window
beep(…)message(…)
getChatwindow(…)
startChat(…)
CWCWS Jabber
{} {arg0.getClass() ==
nu.fw.jeti.jabber.elements.
Message.class}receivePackets(…)
{return == null} {} getChatwindow(…)Value-Invariant Post Value-Invariant Pre Method
{} {arg0.getClass() ==
nu.fw.jeti.jabber.elements.
Message.class}receivePackets(…)
{return == null} {} getChatwindow(…)Value-Invariant Post Value-Invariant Pre Method<<create>>
setCWPosition(…)receivePackets(…)
requestComposing(…)JH
appendMessage(…)
Figure 13: Mined LSC: Create Chat Window
another client: the packet is received, newMessage arrival
message is passed, the history is updated, a Creation ob-
ject is created, appropriate new picture creation methods are
executed, and ﬁnally the updated window is shown. The sce-
nario involves JH ( JabberHandler ), Jabber, PC ( Picture-
Chat), PC$1 (a nameless internal class of PictureChat ), PH
(PictureHistory ), C ( Creation ) and HP ( HistoryPanel ).
Note the scenario-speciﬁc invariant found for method add-
IncomingMessage . The method accepts many diﬀerent types
of messages involving picture updates (e.g., creation, display,
deletion, change in background setting, etc.) as the ﬁrst ar-
gument (i.e., arg0). However, for this scenario, there is only
one type of message being received by the method, namely
CreationMessage .
LSC Add Incoming New Picture
newMessage(…)PC Jabber
{…} {arg0.getClass() == nu.fw.jeti. 
plugins.drawing.elements.Creati
onMessage.class, …}addIncomingMessage(…)Value-Invariant Post Value-Invariant Pre Method
{…} {arg0.getClass() == nu.fw.jeti. 
plugins.drawing.elements.Creati
onMessage.class, …}addIncomingMessage(…)Value-Invariant Post Value-Invariant Pre Method<<create>>
addAction (…)receivePackets(…)JH PC$1 PH
CHP
addIncomingMessage(…)
execute(…)
showWindow(…)execute(…)
Figure 14: Mined LSC: Add Incoming Picture
6. DISCUSSION
Choice of the target formalism. The popularity and
intuitive visual nature of sequence diagrams as a speciﬁca-
tion language in general, together with the additional unique
features of LSC – in particular, the universal interpretation
394and its expressive power, motivate our choice for the tar-
get formalism of our mining work. Moreover, the choice is
supported by previous work on LSC (see, e.g., [20, 24, 32]),
which can potentially be used to visualize, analyze, manip-
ulate, test, and verify the speciﬁcations we mine (see [29]).
Still, one may consider other scenario-based formalisms
with diﬀerent semantics as targets for mining (e.g., [38]), or,
more generally, the mining of other useful behavioral pat-
terns [11]. These alternatives require further investigation.
Soundness and completeness. Our previous work on
scenario-based speciﬁcation mining [29] was sound and com-
plete; all mined scenarios met the minimum support and
conﬁdence thresholds (soundness), and all the scenarios meet-
ing these thresholds were mined (completeness). Hence it is
important to note that our present work on adding value-
based invariants to the scenarios preserves soundness but
gives up completeness. Since scenario-based mining is done
ﬁrst, independent of value-based mining, our current method
might miss scenarios whose conﬁdence statistics depends
on their restriction with value-based invariants: when the
pre-chart is restricted, the actual conﬁdence may be higher
than the one we computed without the restriction. Still,
our present work is sound: all mined scenarios with their
value-based invariants indeed meet the minimum support
and conﬁdence thresholds. Developing a sound and com-
plete method to mining scenario-based speciﬁcations with
value-based invariants is left for future work.
Identifying scenario-specic invariants. A rather sim-
ple syntactic comparison of the invariants found on the orig-
inal trace and on the sliced trace suﬃces to identify the
scenario-speciﬁc invariants we are looking for. Comparison
correctness relies on the ﬁxed and simple default syntax of
Daikon’s output textual representation of these invariants.
However, in some cases, a simple syntactic comparison
may not be good enough because two equivalent invari-
ants may be represented syntactically diﬀerent. This in-
deed happened in one of our experiments, where Daikon
reported this.language == orig(this.language) for the
original trace, and this.userArgument == this.language;
this.userArgument == orig(this.language) for the sliced
trace (see Fig. 10, just after the return of getArgument() ).
To handle such cases in general, a constraint solver should
be used to identify semantic diﬀerences, regardless of the
syntactic representation. We leave this for future work.
Additional limitations. Two additional limitations of our
present work should be mentioned. First, we handle only
fully ordered scenarios and cannot handle partial orders.
Second, in a multi-threaded environment one may be inter-
ested in mining thread-speciﬁc speciﬁcations; however, our
present work is agnostic to threads. We leave these two as
challenges for future work.
Integration with previous work. It is important to
note that our method of adding value-based invariants to
scenario-based speciﬁcation mining is applicable to the var-
ious variants of the latter, that is, to the mining of scenario-
based triggers and eﬀects presented in [26] and to the min-
ing of hierarchical scenario-based speciﬁcations presented
in [28]. Also, in the present work, object IDs are abstracted
away from the input traces. As discussed in previous work [27],
this cannot be done in the general case; thus, we implicitly
assume no overlapping LSCs. Relaxing this restriction re-
quires further work, see [27]. We leave the implementation
of these integrations and their evaluation for future work.7. RELATED WORK
Reverse engineering of sequence diagrams. Many
works present various variants of reverse engineering of ob-
jects’ interactions from program traces and their visualiza-
tion using sequence diagrams (see, e.g., [2, 18]). These may
seem similar to our current work. Unlike our work, how-
ever, all consider and handle only concrete, continuous, non-
interleaving, and complete object-level interactions and are
not using aggregations and statistical methods to look for
higher level recurring scenarios; the reverse engineered se-
quences are used as a means to describe single, concrete, and
relatively short (sub) traces in full (and thus may be viewed
not only as concrete but also as ‘existential’). In contrast, we
look for universal (modal) sequence diagrams, which aim to
abstract away from the concrete trace and reveal signiﬁcant
recurring potentially universal scenario-based speciﬁcation,
ultimately suggesting scenario-based system requirements.
Automata-based specication mining. Most speciﬁca-
tion miners produce an automaton (e.g., [5, 6, 8, 31]), and
have been used for various purposes from program compre-
hension to veriﬁcation. Unlike these, we mine a set of LSCs
from traces of program executions. We believe sequence di-
agrams in general and LSCs in particular, are suitable for
the speciﬁcation of inter-object behavior, as they make the
diﬀerent role of each participating object and the commu-
nications between the diﬀerent objects explicit. Thus, our
work is not aimed at discovering the complete behavior or
APIs of certain components, but, rather, to capture the way
components cooperate to implement certain system features.
Indeed, inter-object scenarios are popular means to specify
requirements (see, e.g., [15, 19, 21, 38, 39]). The addition of
value-based invariants strengthens the expressive power of
the mined scenarios.
Mining of automata with value-based invariants. Most
studies on speciﬁcation mining extracting automata to date
do not capture value-based invariants. Some recent works
do. We brieﬂy discuss these below.
Mariani and Pezze [34] work reports both value-based in-
variants and automata to help component integration. The
value-based invariants are mined using Daikon, while the
automata are mined using an automata learner. In con-
trast, we do not mine general invariants; rather, we merge
value-based invariants and sequencing constraints to form
scenario-speciﬁc speciﬁcations. Also, while an automaton
describes the entire behavior of a system, a scenario de-
scribes only a certain aspect of it. Diﬀerent from the model
mined in [34], our mined scenarios also capture caller and
callee relationships and present them in the intuitive visual
syntax of sequence diagrams.
Lorenzoli et al. [31] integrate Daikon invariants with an
automaton using a four steps approach: (1) merging all
traces with the same sequence of methods invoked with dif-
ferent values of the parameter, (2) inferring Daikon invari-
ants from each of the merged traces, (3) creating an initial
automaton, and (4) merging locally equivalent states (based
on the next k-steps) to obtain the ﬁnal automaton. Our
work is substantially diﬀerent. First, we mine scenarios in
the form of LSC, which express universal properties in the
form of“Whenever the pre-chart occurs, the main chart must
eventually occur”. The automaton mined in [31] expresses
a global/existential property, modeling all executions that
are allowed in the traces. Due to this diﬀerence, the min-
ing algorithms are very diﬀerent (see [40]). Second, [31] may
395‘mix’ between diﬀerent behaviors, as it merges similar meth-
ods into one. The diﬀerent context of each invocation is lost
in the merging. In contrast, our use of scenario-based slic-
ing and diﬀerencing ensures the mining of scenario-speciﬁc
invariants, where the context information is preserved and
highlighted.
Mining of temporal rules with equality constraints.
Lo et al. [30] mine length-2 quantied temporal rules in the
form “For all x, whenever method Ais called with the nth
parameter equals to x, method Cwould eventually be called
with the mth parameter equals to x”. [30] permits equality
constraints. In our present work, we mine for scenarios in
the form of LSCs, not limited to length two. LSCs capture
caller and callee relationships not considered in [30]. While
the approach in [30] is shown to work only on equality con-
straints, we support a wider subset of Daikon invariants. We
introduce the concept of scenario-speciﬁc invariants and re-
alize it by scenario-based mining, slicing, and diﬀerencing.
However, [30] captures quantiﬁed variables, not supported
in our present work. Adding quantiﬁcation to our approach
is left for future research.
8. CONCLUSION & FUTURE WORK
We presented scenario-based mining with value-based in-
variants, as an expressive extension of scenario-based spec-
iﬁcation mining in general. The key to the extension is a
new technique we call scenario-based slicing, to distinguish
scenario-speciﬁc invariants from general ones. The resulting
suggested speciﬁcations are rich, consisting of modal scenar-
ios annotated with scenario-speciﬁc value-based invariants,
referring to event parameters and participating object prop-
erties.
An evaluation over a number of case studies shows promis-
ing results in extracting expressive speciﬁcations from real
programs, which could not be extracted previously. The
more expressive the mined speciﬁcations, the higher their
potential to support program comprehension, testing, and
veriﬁcation tasks. The work is part of the larger frame-
work of speciﬁcation mining, integrating behavioral models
mining with value-based invariants mining to improve the
state-of-the-art support for property discovering tasks.
Future work directions relate to the challenges discussed
in Sec. 6. These include, among others, the development of
a complete (rather than only sound) solution, handling of
partial orders, and integration with previous work through
LM, the LSC mining tool [10].
Acknowledgements. This work is partially supported by
Oﬃce of Research, Singapore Management University (Grant
number: 09-C220-LEE-001). The second listed author ac-
knowledges support from a postdoctoral Minerva Fellowship,
German Federal Ministry for Education and Research.
9. REFERENCES
[1]CrossFTP Server. sourceforge.net/projects/crossftpserver/.
[2]Eclipse Test and Performance Tools Platform.
http://www.eclipse.org/tptp/.
[3]Jeti. Version 0.7.6 (Oct. 2006). http://jeti.sourceforge.net/.
[4]http://www.mysmu.edu/faculty/davidlo/inv/invariants.html.
[5]M. Acharya, T. Xie, J. Pei, and J. Xu. Mining API patterns as
partial orders from source code: From usage scenarios to
speciﬁcations. In SIGSOFT FSE , 2007.
[6]G. Ammons, R. Bodik, and J. R. Larus. Mining speciﬁcation.
InPOPL , 2002.
[7]M. Boshernitsan, R.-K. Doong, and A. Savoia. From Daikon to
Agitator: Lessons and challenges in building a commercial tool
for developer testing. In ISSTA , 2006.[8]V. Dallmeier, C. Lindig, A. Wasylkowski, and A. Zeller.
Mining object behavior with ADABU. In WODA , 2006.
[9]W. Damm and D. Harel. LSCs: Breathing life into Message
Sequence Charts. J. on Formal Methods in System Design ,
19(1):45–80, 2001.
[10] T. Doan, D. Lo, S. Maoz, and S.-C. Khoo. LM: A tool for
scenario-based speciﬁcation mining. In ICSE , 2010.
[11] M. B. Dwyer, G. S. Avrunin, and J. C. Corbett. Patterns in
property speciﬁcations for ﬁnite-state veriﬁcation. In ICSE ,
1999.
[12] M. El-Ramly, E. Stroulia, and P. Sorenson. Interaction-pattern
mining: Extracting usage scenarios from run-time behavior
traces. In KDD , 2002.
[13] M. Ernst, J. Cockrell, W. Griswold, and D. Notkin.
Dynamically discovering likely program invariants to support
program evolution. TSE, 27(2):99–123, 2001.
[14] J. Han and M. Kamber. Data Mining Concepts and
Techniques . Morgan Kaufmann, 2006.
[15] D. Harel. From play-in scenarios to code: An achievable
dream. IEEE Computer , 34(1):53–60, 2001.
[16] D. Harel and S. Maoz. Assert and negate revisited: Modal
semantics for UML sequence diagrams. Software and Systems
Modeling , 7(2):237–252, 2008.
[17] D. Harel and R. Marelly. Come, Let's Play: Scenario-Based
Programming Using LSCs and the Play-Engine . Springer,
2003.
[18] D. F. Jerding, J. T. Stasko, and T. Ball. Visualizing
interactions in program executions. In ICSE , 1997.
[19] F. Klein and H. Giese. Joint structural and temporal property
speciﬁcation using timed story scenario diagrams. In FASE ,
2007.
[20] J. Klose, T. Toben, B. Westphal, and H. Wittke. Check it out:
On the eﬃcient formal veriﬁcation of Live Sequence Charts. In
CAV , 2006.
[21] I. Kr ¨uger. Capturing overlapping, triggered, and preemptive
collaborations using MSCs. In FASE , 2003.
[22] H. Kugler, D. Harel, A. Pnueli, Y. Lu, and Y. Bontemps.
Temporal logic for scenario-based speciﬁcations. In TACAS ,
2005.
[23] H. Kugler and I. Segall. Compositional synthesis of reactive
systems from live sequence chart speciﬁcations. In TACAS ,
2009.
[24] M. Lettrari and J. Klose. Scenario-based monitoring and
testing of real-time UML models. In UML , 2001.
[25] D. Lo and S.-C. Khoo. SMArTIC: Towards building an
accurate, robust and scalable speciﬁcation miner. In SIGSOFT
FSE, 2006.
[26] D. Lo and S. Maoz. Mining scenario-based triggers and eﬀects.
InASE, 2008.
[27] D. Lo and S. Maoz. Mining symbolic scenario-based
speciﬁcations. In PASTE , 2008.
[28] D. Lo and S. Maoz. Mining hierarchical scenario-based
speciﬁcations. In ASE, 2009.
[29] D. Lo, S. Maoz, and S.-C. Khoo. Mining modal scenario-based
speciﬁcations from execution traces of reactive systems. In
ASE, 2007.
[30] D. Lo, G. Ramalingam, V. Ranganath, and K. Vaswani.
Mining Quantiﬁed Temporal Rules: Formalisms, Algorithms,
and Evaluation. In WCRE , 2009.
[31] D. Lorenzoli, L. Mariani, and M. Pezz` e. Automatic generation
of software behavioral models. In ICSE , 2008.
[32] S. Maoz and D. Harel. From multi-modal scenarios to code:
Compiling LSCs into AspectJ. In SIGSOFT FSE , 2006.
[33] L. Mariani, S. Papagiannakis, and M. Pezz` e. Compatibility
and regression testing of COTS-component-based software. In
ICSE , 2007.
[34] L. Mariani and M. Pezz` e. Behavior capture and test:
Automated analysis for component integration. In Proc. IEEE
Int. Conf. on Eng. of Complex Computer Systems , 2005.
[35] K. Olender and L. Osterweil. Cecil: A sequencing constraint
language for automatic static analysis generation. IEEE TSE ,
16:268–280, 1990.
[36] B. Pytlik, M. Renieris, S. Krishnamurthi, and S. P. Reiss.
Automated fault localization using potential invariants. CoRR ,
cs.SE/0310040, 2003.
[37] H. Safyallah and K. Sartipi. Dynamic analysis of software
systems using execution pattern mining. In ICPC , 2006.
[38] G. Sibay, S. Uchitel, and V. A. Braberman. Existential live
sequence charts revisited. In ICSE , 2008.
[39] J. Sun and J. S. Dong. Synthesis of distributed processes from
scenario-based speciﬁcations. In FM, 2005.
[40] T. Xie, S. Thummalapenta, D. Lo, and C. Liu. Data mining for
software engineering. IEEE Computer , 42(8):35–42, 2009.
[41] J. Yang, D. Evans, D. Bhardwaj, T. Bhat, and M.Das.
Perracotta: Mining temporal API rules from imperfect traces.
InICSE , 2006.
396