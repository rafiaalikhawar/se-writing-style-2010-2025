Security-Driven Model-Based
Dynamic Adaptation∗
Brice Morin
INRIA, Centre Rennes -
Bretagne Atlantique
Brice.Morin@inria.frTejeddine Mouelhi
Telecom Bretagne, Rennes
Tejeddine.Mouelhi
@telecom-bretagne.euFranck Fleurey
SINTEF ICT, Oslo
Franck.Fleurey@sintef.no
Yves Le Traon
University of Luxembourg
Yves.LeTraon@uni.luOlivier Barais and
Jean-Marc Jézéquel
INRIA and IRISA, University of
Rennes 1
barais@irisa.fr
jezequel@irisa.fr
ABSTRACT
Security is a key-challenge for software engineering, espe -
cially when considering access control and software evolu-
tions. No satisfying solution exists for maintaining the al ign-
ment of access control policies with the business logic. Cur -
rent implementations of access control rely on the separati on
between the policy and the application code. In practice,
this separation is not so strict and some rules are hard-
coded within the application, making the evolution of the
policy diﬃcult. We propose a new methodology for imple-
menting security-driven applications. From a policy deﬁne d
by a security expert, we generate an architectural model, re -
ﬂecting the access control policy. We leverage the advances
in the models@runtime domain to keep this model synchro-
nized with the running system. When the policy is updated,
the architectural model is updated, which in turn reconﬁg-
ures the running system. As a proof of concept, we apply
the approach to the development of a library management
system.
Categories and Subject Descriptors
D2.11 [ Software Engineering ]: Software Architectures;
K6.5 [Management of Computing and Information
Systems ]: Security and Protection
General Terms
Design, Security
∗This work was partially funded by the DiVA project (EU
FP7 STREP, contract 215412, http://www.ict-diva.eu/)
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1-4503-0116-9/10/09 ...$10.00.Keywords
Access-control, Adaptive System, Model-Driven Engineer-
ing, Models@Runtime
1. INTRODUCTION
Security is a key issue in modern software-intensive sys-
tems driving the every-day life of billions of people all aro und
the world. Software systems deployed in large companies,
banks, airports, etc, must be available 24/7 with a high
level of security. Among diﬀerent security concerns (user
authentication, data encryption, etc), access control pla ys a
critical role. It ensures that users, depending on their rol es,
can only access the resources they are supposed to access.
Designing, implementing and executing such systems re-
quires the highest attention from the diﬀerent stakeholder s.
A small error in the speciﬁcation or in the implementation
of the access control concern could make a critical resource
accessible to standard users. Several security models, lik e
RBAC [7] or OrBAC [11], propose high-level abstractions to
security experts in order to specify access control policie s.
The current implementation techniques consist in using a
standard architecture that involves designing a dedicated
security component, called the policy decision point (PDP) ,
which can be conﬁgured independently from the rest of the
implementation containing the business logic of the appli-
cation. The execution of functions in the business logic in-
cludes calls to the PDP (called PEPs - policy enforcement
points), which grants or denies access to the protected re-
sources/functionalities of the system. Such an architectu re
can for example be implemented with Aspect-Oriented Pro-
gramming [12, 18] techniques.
The main limitation of the current implementation tech-
niques is that they do not allow for ﬂexible access control
mechanisms. In fact, the access control policy cannot be
modiﬁed without previously modifying the code to support
the new access control rule. This is an expected eﬀect of the
separation between the security code (access control mech-
anism) and the functional code. In fact, because of this ap-
proach, the functional code may contain some hard-coded
access control mechanisms implementing some access con-
trol rules. Modifying these speciﬁc rules requires locatin g
these hidden mechanisms and removing them. In this pa-
205
per, we address this issue by providing ﬂexible access contr ol
mechanisms.
In this paper, we propose to leverage Model-Driven En-
gineering (MDE) techniques to provide a very ﬂexible ap-
proach for managing access control. On one side, access con-
trol policies are deﬁned by security experts, using a Domain -
Speciﬁc Modeling Language (DSML), which describes the
concepts of access control, as well as their relationships.
On the other side, the application is designed using an-
other DSML for describing the architecture of a system in
terms of components and bindings. This component-based
software architecture only contains the business componen ts
of the application, which encapsulate the functionalities of
the system, without any security concern. Then, we deﬁne
mappings between both DSMLs describing how security con-
cepts are mapped to architectural concepts. We use these
mappings to fully generate an architecture that enforces th e
security rules. When the security policy is updated, the
architecture is also updated. Finally, we leverage the no-
tion of models@runtime in order to keep the architectural
model (itself synchronized with the access control model)
synchronized with the running system. This way, we can
dynamically update the running system in order to reﬂect
changes in the security policy. Only users who have the right
to access a resource can actually access this resource.
The remainder of the paper is organized as follows. Sec-
tion 2 presents a background on access control and motivates
the need for more ﬂexible access control policies. Section 3
describes an overview of our approach. Section 4 presents
the security and the architecture metamodels, and how they
are composed. Section 5 describes how the architecture
model is impacted when the security policy is updated, and
how these changes are automatically reﬂected at runtime.
Section 6 presents related work. Section 7 concludes and
presents future work.
2. MOTIV ATIONS FOR DYNAMIC ACCESS
CONTROL
Access Control aims at securing a system by controlling
the access of users, processes or components (or any other
entity) to the resources of the system. This access is con-
trolled through the enforcement of an access control policy ,
which expresses a set of rules for allowing or denying the
access to the system resources. Several access control mod-
els [7, 11] allow deﬁning access control policies.
This section presents the motivation behind the need for a
more dynamic access control. To show the limitation of the
existing platforms, we ﬁrst present the existing architect ure
for implementing access control policies. Then we explain
the various reasons that lead to the need to provide a new
approach for enforcing dynamic access control policies.
2.1 Current Architecture for Managing Access
Control
Figure 1 depicts a security architecture typically used for
implementing the security policy. Roughly, there are two
main components:
•The Policy Decision Point (PDP) is the point where
policy decisions are made. It encapsulates the Ac-
cess Control Policy and implements a mechanism to
process requests coming from the business logic (via
the PEP) and returns a response which can be “deny”or “permit”. Policies can be stored in various ways:
Data Base, eXtensible Access Control Markup Lan-
guage (XACML) ﬁles, etc.
•The Policy Enforcement Point (PEP) is the point in
the business logic where the policy decisions are en-
forced. It is a security mechanism, which has been in-
tentionally inserted in the application functional code.
Before the service is executed, the PEP sends a re-
quest to the PDP to get the suitable response (grant
or deny), which depends on the user requesting the ser-
vice, and on the current context. Based on the PDP
response, if the access is granted the service executes,
else the access is denied and the PEP forbids the exe-
cution of the service.
GUIPDP Access Control Policy
PEP Business Logic
Figure 1: The Security Architecture
This architecture clearly separates the access control dec i-
sion from its enforcement, thus improving the testability o f
the system. In addition, the security rules are centralized ,
improving the observability of the system. One can easily
monitor the enforced security rules to detect bugs or securi ty
ﬂaws.
2.2 Limitations of Current Approaches
Although current approaches allow the security rules to
be updated and modiﬁed, the enforcement of these mod-
iﬁcations is problematic. This is due to the existence of
some access control mechanisms hard-coded into the busi-
ness logic. These hidden mechanisms enforce some of the
access control rules making the system’s policy more rigid
and diﬃcult to modify. There are two kinds of mechanisms,
identiﬁed in [18]; the implicit mechanisms and the explicit
mechanisms. The implicit mechanisms are implemented by
construction through the design model or the deployment ar-
chitecture. For instance, Figure 2 illustrates such an impl icit
mechanism. In this example, by construction, the secretari es
are not allowed to update accounts. The access control pol-
icy can however be easily updated to allow secretaries to up-
date accounts. However, to enforce this new rule, refactori ng
is required. A simple refactoring would consist of moving th e
association “access”and the methods to the level of the clas s
Personnel. Such a refactoring would also allow any Person-
nel instance to access the personnel accounts, which may be
an unexpected change. So, the program will have to be care-
fully modiﬁed in several locations to implement the desired
evolution of the access control policy.
206Figure 2: Implicit security mechanism
The second kind of hidden mechanisms is the explicit
mechanisms, which are implemented within some portions
of the application code that is not documented. Figure 3
shows an example of these explicit mechanisms:
1public void borrowBook(Book b, User user) {
2// visible mechanism, call to the security
policy service
3 SecurityPolicyService.check(user,
4 SecurityModel.BORROW_METHOD ,Book. class,
SecurityModel.DEFAULT_CONTEXT);
5
6// do something else
7
8// hidden mechanism
9 if(getDayOfWeek().equals(‘‘Sunday’’) ||
10 getDayOfWeek().equals(‘‘Saturday’’)) {
11 // this is not authorized throw a business
exception
12 Throw newBusinessException(‘‘Not allowed to
borrow in week-ends’’);
13 }
14}
Figure 3: Explicit security mechanism
In the body of the method, after the PEP call to the
PDP, a new check is done which forbids borrowing books
during week-ends. If the policy has to be modiﬁed to allow
borrowing books during week-ends, this hidden mechanism
should be located and deleted.
2.3 Discussion
Both the explicit and the implicit mechanisms reduce the
ﬂexibility of the system. They are inevitable since they are
due to the way the standard architecture (PDP+PEP) is im-
plemented as illustrated through the examples. In fact, the
problem is not due to the architecture itself. It is caused
by the way applications are developed by separating the
process of implementing the security mechanism (the PDP
and the PEP) from the application logic implementation.
This application logic part should be implemented by tak-
ing into account the access control policy, so that this poli cy
is not hard-coded in the business logic. For these reasons,
we clearly need to take into account access control during
the modeling and more importantly the deployment of se-
cured systems. This is the main contribution of this work,
which involves providing a complete process that includes
access control throughout the modeling and the specially
deployment processes.3. OVERVIEW
In commercial and government environments, any change
to the security policies normally requires impact assessme nts,
risk analysis and such changes should go through the RFC
(Request for Change) process. However, in case of urgency
(crisis events, intrusion detection, server crashes, inte rop-
erability with external systems to deal with a critical situ -
ation), the adaptation of a security policy at runtime is a
necessity. This adaptation may or may not have been al-
ready predicted or planned.
The proposed approach and the combination of composi-
tion and dynamic adaptation techniques shown in Figure 4
show how the security policy can be adapted conforming to
a deﬁned adaptation plan or in an unplanned way. The secu-
rity adaptation mechanisms we propose deal with the chal-
lenging issue of how to provide running systems supporting
planned and unplanned security policy adaptations. The in-
puts of the process are two independent models: the business
architecture model of the system and the security model.
These two models are expressed in diﬀerent domain-speciﬁc
modeling languages: the core business architecture with an
architecture modeling language (Section 4.2) and the secu-
rity policy with an access-control language (Section 4.1). By
dynamically composing the security model with the archi-
tecture model, the approach allows adapting the applicatio n
security policy according to pre-deﬁned adaptation rules b ut
also to cope with any unplanned changes of the security
model.
Business
Architecture
Model
Security Enforced
Architecture ModelSecurity
Policy
Context
Information
Middleware platformRunning System Monitoring FrameworkAdaptive
Security
Model+(2) Composition
The security policy is 
composed with the 
business architecture(1) Reasoning
depending on the context 
the appropriate access 
control  rules are selected 
from the security model
(3) Adaptation
The running system is 
safely and automatically 
reconfigured(4) Notification
The monitoring 
framework triggers 
reasoning by 
notifying relevant 
changes(5) Evolution
At any time the 
security model can 
be updated
Models at runtime
Figure 4: Overview of the proposed approach
The adaptive security model contains a set of access con-
trol rules and a description of the context in which these
rules apply. At runtime, depending on the context infor-
mation coming from the system the appropriate set of rules
has to be chosen. This is the reasoning shown as (1) in
Figure 4. The reasoning phase processes the security model
based on the context information coming from the system to
produce the security policy to be enforced. Basically, when
some events are triggered, security rules can be activated o r
deactivated. Once the appropriate security policy has been
deﬁned, it has to be composed into the architecture model of
the application, see (2) in Figure 4. The models to compose
here are of diﬀerent nature: an architecture model on one
207side and a security policy on the other side. The composition
is done in two steps:
1. the security policy is transformed into an architecture
model realizing it,
2. this architecture model is composed with the business
architecture model
The implementation of this complex composition operator
is discussed in section 4. The output of the composition is a
plain architecture model which enforces the security polic y
in the application. Step (3) and (4) in Figure 4 correspond
to the synchronization of the architecture model with the
running system and the monitoring of the system environ-
ment. For both of these tasks, the approach proposed in
this paper reuses existing runtime adaptation techniques.
Basically the idea is to leverage monitoring and runtime re-
conﬁguration mechanisms oﬀered by middleware platforms
in order to extract context information and update the run-
ning system to match the desired architecture. Finally, poi nt
(5) in Figure 4 corresponds to an evolution of the security
model. The proposed approach allows changing the security
model at any point in time. Here, it does not only consist
in activating/deactivating existing rules, but also consi sts
in adding, removing or updating rules or roles. This paper
focuses on how the architecture (and the running system)
causally evolves when the security policy is updated. Con-
text monitoring and reasoning can be realized by existing
adaptive system modeling techniques such as [8].
4. COMPOSING SECURITY AND ARCHI-
TECTURE METAMODELS
In this section, we describe how we compose the archi-
tecture metamodel into the security metamodel. We ﬁrst
introduce a generic metamodel for describing access contro l
policies. Then, we introduce our generic metamodel for de-
scribing component-based architecture. Finally, we detai l
how we map security concepts to architectural concepts.
4.1 A Generic Metamodel for Describing
Access Control Policies
The metamodel we use to describe access control policies
is illustrated in Figure 12 at the end of this paper. It deﬁnes
the concepts and their relationships needed to design acces s
control models. The root concept is the Policy . A policy
contains Resources ,Roles,Users andRules. A resource ( e.g.,
a book) deﬁne some actions ( e.g., borrow). Each user of the
system has one role. Rules allow specifying the action the
users (via their role) can perform on the resources of the
system. We distinguish two types of rules:
•Permission : speciﬁes the actions that the user of a
given role can perform. By default, users can access
the actions associated with their roles.
•Delegation : speciﬁes the actions that a user (delega-
tor) delegates to another user (delegatee). By default,
no delegation is active.
Each rule can be associated with a context. A context
speciﬁes when a rule should be active, depending of the
environment. For example, users can borrow books from
Monday to Friday if they have not exceeded their quota.A context is a boolean expression involving some context
variables. A metamodel for describing such context can be
found in [8]. Rules with no associated context are active by
default, but could be deactivated.
4.2 A Core Metamodel for (Runtime)
Architectures
Our generic metamodel is illustrated in Figure 13 at then
end of this paper. A component type contains some ports.
Each port has a UML-like cardinality (upper and lower bounds )
indicating if the port is optional (lowerBound = 0) or manda-
tory (lowerBound >0). It also indicates if the port only
allows single bindings (upperBound = 1) or multiple bind-
ings (upperBound >1). A port also declares a role (client
or server) and is associated to a service. A service encapsu-
lates some operations, deﬁned by a name, a return type and
some parameters. A service has a similar structure as Java
interface.
A component instance has a type and a state (ON/OFF),
specifying whether the component is started or stopped. It
can be bound to other instances by a transmission binding,
linking a provided service (server port) to a required servi ce
(client port). A composite instance can additionally decla re
sub-instances and delegation bindings. A delegation bindi ng
speciﬁes that a service from a sub-component is exported by
the composite instance.
4.3 Mapping Security Concepts to Architec-
tural Concepts
In this sub-section we propose to map the security con-
cepts (Section 4.1) to architectural concepts (Section 4.2 ).
This mapping is performed by the seamless weaving engine
provided by Kermeta [19] that allows designers to extend
a metamodel with additional elements1: attributes, refer-
ences, contracts (invariants and pre/post conditions), op -
erations (or implement an already existing abstract opera-
tion). Kermeta allows designer to extend their metamodels
deﬁned in Ecore/EMF2(which is the defacto standard inte-
grated into Eclipse to design metamodels) with operational
semantics. It makes it possible to check, simulate, trans-
form models using a Java-like imperative style combined
with OCL-like constructs dedicated to the navigation into
models.
The rationale of this mapping is to automatically reﬂect
the access control policy at the architectural level. This
mapping is realized as follows, and illustrated in Figures 5 ,
6 and 7:
•Each resource is mapped to a component instance (Fig-
ure 5). This proxy component provides and requires all
the services oﬀered by the resource. Additionally, each
resource is mapped to a set of business components,
from the base architecture, realizing the resource. The
mapping with business components is provided by the
designer, via a graphical editor.
•Each action is mapped to an operation (Figure 5). An
OCL constraint ensures that every action (belonging to
a single resource) is mapped to an operation belong-
ing to the component type of a component realizing
1http://www.kermeta.org/docs/html.chunked/KerMeta-
Manual/ch02.html#section weaving.link
2http://www.eclipse.org/modeling/emf/
208the resource. This mapping is also provided by the
designer.
•Each role is mapped to a component (Figure 6). This
proxy component provides and requires all the services
that a user of this role can potentially access.
•Each user is mapped to a component (Figure 6). By
default, this component is connected to the correspond-
ing role component.
•Each permission is mapped to a pair of ports and a
binding (Figure 6):
–Each permission granted to a role is mapped to a
pair of ports: a required port associated with the
role component, a provided port associated with
the resource, and a binding linking these ports.
–Each permission granted to a user is also mapped
to a pair of ports: a required and a provided ports
associated with the user component. The bind-
ings links the required port to the corresponding
provided port of the component corresponding to
the user’s role.
•Each delegation (Figure 7) is mapped to a pair of ports
and a binding. A required and a provided ports are
associated with the user (delegatee) component. The
binding links the required port to the corresponding
port provided by another (delegator) component.
Resource
XBusiness 
Component
1
Business 
Component
2op1(…)
op2(…)
op3(…)op1(…)
op2(…)
op3(…)
ResourceX
action1 /g198op1(…)
action2 /g198op2(…)
action3 /g198op3(…)
businessComponents = {BusinessComponent1 ; BusinessC omponent2}Business 
Component
3
Figure 5: Mapping Resources to Architectural Con-
cepts
RoleY UserXResource
Z(any user of) RoleY can access the actionW of the Resour ceZ
actionW actionW
UserX (of RoleY) can access the actionW of the Resource Z
Figure 6: Mapping Permissions to Architectural
Concepts
The initial architecture is automatically created by using
the mappings provided by the designer (resources and ac-
tions), and by visiting the security model to set the wovenDelegator
DelegateeRoleX
RoleY
Delegator delegates his role to Delegatee
Figure 7: Mapping Delegations to Architectural
Concepts
references. Figure 8 illustrates a simple architecture gen -
erated from a security policy. The architecture has 4 lay-
ers: business, resource, role and user. The bindings betwee n
components from diﬀerent layers indicates the permissions ,
and the bindings between user components indicates the del-
egations currently active in the system. During the genera-
tion of the architecture, bindings are not created if the rul e
is not active.
Color
Printer
Storage
NetworkAdmin
B&W
Printer
Std. User
GuestBrice
Tejeddine
Olivier
YvesconnectWithLogin()
connectWithNoLogin()connectWithNoLogin()
User layer Role layer Resource layer
Figure 8: 3-Layered architecture reﬂecting access
control policies
In this section, we showed how the security (access con-
trol) concern is composed with a base architecture, to ﬁ-
nally obtain a 4-layered software architecture. This map-
ping leverages the meta-level aspect weaving facilities pr o-
vided by the Kermeta [19] language, as well as its model
transformation capabilities.
5. SECURITY-DRIVEN DYNAMIC
ADAPTATION
In this section, we ﬁrst present how we synchronize archi-
tectural models with a running system. Then, we explain
how the architecture evolves when access control rules are
activated or deactivated. Finally, we show how we handle
deeper evolutions of the access control policy i.e., when rules
or roles are removed, created or updated.
2095.1 Synchronizing the Architecture Model with
the Running System
Modern adaptive execution platforms like OSGi [21] pro-
pose low-level APIs to reconﬁgure a system at runtime. It is
possible to dynamically reconﬁgure applications running o n
these platforms by executing platform-speciﬁc reconﬁgura -
tion scripts specifying which components have to be stopped ,
which components and/or bindings should be added and/or
removed. These scripts have to be carefully written in order
to avoid life-cycle exceptions ( e.g, when a component is re-
moved while still active) and dangling bindings ( e.g., when
a component is removed while it is still connected to other
(client) components).
To prevent errors in writing such error-prone scripts, we
rely on our previous work that leverages MDE techniques
to generate safe reconﬁguration scripts [15, 16, 17], as ill us-
trated in Figure 9.
Architecture 
Metamodel
Reflection
model
Running 
System
Component-based execution platformTarget
model
Generated platform-specific
reconfiguration commandsCausal
connectionvalidationM2
M1
M012
3
4conforms to
Figure 9: Leveraging MDE to generate safe recon-
ﬁguration scripts
The key idea is to keep an architectural model synchro-
nized with the running system [5, 15, 16]. This reﬂection
model, which conforms to the architecture metamodel (Sec-
tion 4.2), is updated (Figure 9, 1) when signiﬁcant changes
appears in the running system (addition/removal of compo-
nents/bindings). It is important to note that the reﬂection
model can only be modiﬁed according to runtime events.
Still, it is possible to work on a copy of this reﬂection model
and modify it: model transformation, aspect model weav-
ing, manipulation by hand in a graphical editor, etc. In
other words, the reﬂection model is really a mirror of the re-
ality (the running system) and not a means for manipulating
the reality.
When a target architectural model is deﬁned ( e.g.after
updating the access control policy), it is ﬁrst validated (F ig-
ure 9, 2) using classic design-time validation techniques, such
as invariant checking [15] or simulation. This new model, if
valid, represents the target conﬁguration that the running
system should reach. We automatically generate the recon-
ﬁguration script, which allows to switch the system from its
current conﬁguration to the new target. We ﬁrst perform
a model comparison between the source conﬁguration (the
reﬂection model) and the target conﬁguration (Figure 9, 3),
which produces an ordered set of reconﬁguration commands.
This safe sequence of commands is then submitted (Figure 9,
4) to the running system in order to actually reconﬁgure it.
Finally, the reﬂection model is automatically updated and
becomes equivalent to the target model (Figure 9, 1).Readers interested in more details about the causal con-
nection are referred to our previous works [15, 16, 17].
In the next two sub-sections we leverage this causal con-
nection and the mappings (Section 4) in order to automat-
ically update the architecture when the security policy is
modiﬁed.
5.2 Activation/deactivation of security rules
Default permissions can temporarily be deactivated for
several reasons: maintenance of a resource that requires th e
resource to be “oﬄine”, repression of bad or abusive behav-
ior, etc. In some cases, default permissions should be deac-
tivated for a particular role, while in some other cases they
should be deactivated for a particular user. Delegations ar e
temporarily activated by a user when he goes on holidays,
when he is not available, etc, and deactivated when the user
is back to work.
Deactivating a permission, either for a role of for a user, is
straightforward: it simply consists in removing the bindin g
associated with the rule. This way, the chain-of-responsib ility
cannot process to the business components. Re-activating a
permission is exactly the opposite: we have to create a bind-
ing and insert it a the right place. Delegations are handled
exactly in the same way.
Figure 10 shows a code snippet written in Kermeta [19].
The aspect keyword means that we re-open the Permission
meta-class, deﬁned in the security metamodel (Section 4.1,
Figure 12). We add 3 new references, corresponding to the
mappings we have deﬁned in Section 4.3, and an operation.
Theactivate operation describes the impact on the archi-
tecture when a permission is activated. We ﬁrst create a
binding (Line 8) and set the four references needed to prop-
erly introduce the binding: the client and the server ports
(Lines 9 and 10), and the client and server component in-
stances (Lines 11 and 12). The activation and deactivation
of permissions for particular users follow the same princip le.
1aspect classPermission {
2//mappings to architectural concepts
3 reference server : Port[1..1]
4 reference client : Port[1..1]
5 reference binding : TransmissionBinding[1..1]
6
7 operation activate() is do
8 varb : TransmissionBinding init
TransmissionBinding.new
9 b.client := self.client
10 b.server := self.server
11 b.serverInstance := self.action.container.asType
(Resource).resourceComponent
12 self.role.roleComponent.binding.add(b)
13 binding := b
14 end
15}
Figure 10: The Permission meta-class aspectized
with Kermeta [19]
In Figure 8, we can see that John Smith has delegated his
role to Jane Smith. At the architectural level, this means
that the component associated with Jane Smith has now 3
additional ports that are delegated to the component asso-
ciated to John Smith. Jane Smith still has the permissions
associated with her role (Secretary), but she now also has
210the permissions associated to the Director role, via the John
Smith component. In the same Figure, we can see that the
“bad student” user has lost all his permissions. However,
the permissions have not been deactivated for all the stu-
dents. At the architectural level, all the bindings formerl y
connected to the component associated with the “bad stu-
dent”have been removed. In other words, the “bad student”
is now totally isolated from the system. The modiﬁcations
of the architecture, implied by the (de)activation of rules ,
are automatically reﬂected to the running system using the
causal connection, as explained in Section 5.1.
At runtime, the removal/addition of binding is very fast.
It simply consists in calling a setter method on the client
component to (un)link it to/from a server. In the case where
the permissions of all the users of a given role should be
removed, we simply disconnect the role component from the
resource components. This way, we do not have to remove all
the (numerous) bindings between the user components and
the role component. In the case where a given user loses his
permissions, we remove the binding between its component
and its associated role component. This way, other users are
not impacted by this modiﬁcation.
5.3 Evolution of the Access Control Policy
In the previous sub-section, we explained how the activa-
tion and deactivation of rules update the architecture, whi ch
in turn dynamically reconﬁgure the system. However, our
model-driven approach also makes it possible to deeply mod-
ify the access control policy, by adding, removing, updatin g,
rules, resources, roles or users, which is very diﬃcult and
often impossible using traditional security architecture s [11,
7, 18].
For example, if the policy is too permissive, the security
manager would like to remove some permissions granted to
a role, or create a new role with less permissions. On the
other hand, a policy could be too restrictive to be actually
usable in practice. In the former security policy, only the d i-
rector could create and update borrower accounts. To help
the director in this task, it has been decided that the admin-
istrator of the system could now also perform these tasks.
One possible solution would be to ask the director (John
Smith) to delegate his role (or at least the actions related t o
borrower accounts) to John Doe, the administrator. Since
delegations are temporary by nature, this solution is not
well suited. The best solution is to modify the security pol-
icy by creating 3 new permissions to allow the administrator
to create, consult and modify borrower accounts.
Figure 11 focuses on the architectural elements related to
the administrator role before and after the change in the
policy. After the new architecture has been re-generated,
we can see that the administrator can now access to the
borrower accounts.
When the new architecture is submitted to our causal con-
nection, this produces the following reconﬁguration scrip t:
stop component John Doe
stop component Admin
unbind component John Doe from createPersonnelAccount int erface
unbind component John Doe from consultPersonnelAccount in terface
unbind component John Doe from modifyPersonnelAccount int erface
//same actions for the Admin component
remove component John Doe
remove component Admin
generate John Doe
generate Admin
add component John Doe
add component AdminBorrower
AccountAdminPersonnel
AccountJohn DoeUser layer Role layer Resource layer
modifycreate
consult
modifycreate
consult Admin John DoeBefore
After
Figure 11: Architecture after 3 new permissions
have been added
bind component John Doe to Admin via createPersonnelAccoun t interface
bind component John Doe to Admin via consultPersonnelAccou nt interface
bind component John Doe to Admin via modifyPersonnelAccoun t interface
bind component John Doe to Admin via createBorrowerAccount interface
bind component John Doe to Admin via consultBorrowerAccoun t interface
bind component John Doe to Admin via modifyBorrowerAccount interface
//same actions between Admin and PersonnelAccount
//same actions between Admin and BorrowerAccount
start Admin
start John Doe
5.4 Discussion
Unlike the classic architecture (based on PDP and PEP,
see Section 2.1), our architecture introduces several addi -
tional components to properly manage access control. In-
deed, we introduce a component for each resource and each
role deﬁned in the access control policy. These components
are implemented as OSGi bundles, and we rely on the OSGi
API to manage these components. The code of these com-
ponents is straightforward and eﬃcient: it simply delegate s
all their provided services to another component. For exam-
ple, the following script illustrates the pseudo-code of th e
ResourceX in Figure 5.
op1(...){ myBusinessComponent1.op1(...)}
op2(...){ myBusinessComponent1.op2(...)}
op2(...){ myBusinessComponent2.op3(...)}
This code contains no logic (no reﬂection, no if-then-else ,
etc to dispatch the calls), but a very simple indirection. Us er
components delegates to role components (permissions) or
to other user components (delegation). Role components
delegate to resource components, which ﬁnally delegate to
the business components, which contains all the business
logic. The code of these proxy components is automatically
generated using a code template. Since OSGi oﬀers pow-
erful mechanisms to manage the classpath at runtime, it is
possible to generate, compile and package this code at run-
time. In the case where a user has the permission to use a
resource, it thus has to transit through 3 simple indirectio ns:
user→role→resources →business code. This is compara-
ble to the classic architecture: user →eval(PDP) →business
code, where we have 2 indirections, plus the evaluation of
the result of the PDP.
The activation/deactivation of permission simply consist s
in setting a Java reference using a setter method, which is
automatically invoked during the reconﬁguration step (see
Section 5.1). De-activating a permission thus “physically ”
breaks the chain between the user and the real resources.
Our approach also reiﬁes users as components. Unlike re-
sources and roles, we do not encapsulate these components
as OSGi bundles. Instead, we simply manipulate these com-
ponents as pure objects, similarly to session objects we can
211ﬁnd in applications that should handle multiple users. Thes e
light-weight components are instantiated when needed e.g.,
when users log in, with no overhead comparing to classic
session objects.
6. RELATED WORK
A substantial work [2, 4, 9] focused on access control for-
malization that guarantees ﬂexibility and allows policies to
be easily modiﬁed and updated.
In this context, we present some of the work related to this
area. In [3], Bertino et al. proposed a new access control
model which allows expressing ﬂexible policies that can be
easily modiﬁed and updated by users to adapt them to spe-
ciﬁc contexts. The advantage of their model resides in the
ability to change the access control rules by granting or re-
voking access based on speciﬁc exceptions. Their model pro-
vides a wide range of interesting features that increase the
ﬂexibility of the access control policy. It allows advanced
administrative functions for regulating the speciﬁcation of
access controls rules. In addition, their model supports de l-
egation, which enables users to temporarily grant other use rs
some of their permissions (like a director would do during
his vacations).
In addition, Bertolissi et al. proposed DEBAC [4] a new
access control model based on the notion of event and that
allows the policy to be adapted to distributed and chang-
ing environments. Their model is represented as a term
rewriting system [1], which allows specifying changing and
dynamic access control policies.
As far as we know, no previous work dealt with the prob-
lem of maintaining the alignment of access control policies
with the business logic by providing a process or a frame-
work for integrating this access control mechanism into the
deployed system. However, several researchers proposed
model-driven approaches for implementing model based meth od-
ologies for securing applications. They focused on providi ng
model based methodologies for security. Some approaches
were proposed to help modeling access control formalisms
in UML diagrams such as RBAC or MAC. RBAC was mod-
eled using a dedicated UML diagram template [13]. In addi-
tion, Doan et al. proposed a methodology [6] to incorporate
MAC in UML diagrams during the design process. All these
approaches allow access control formalisms to be expressed
during the design.
UMLsec [10] which is an extension of UML allows security
properties to be expressed in UML diagrams. In addition,
Lodderstedt et al.[14] propose SecureUML which provides a
methodology for generating security components from spe-
ciﬁc models. The approach proposes a security modeling
language to deﬁne the access control model. The resulting
security model is combined with the UML business model
in order to automatically produce the access control infras -
tructure. More precisely, they use the Meta-Object facilit y
to create a new modeling language to deﬁne RBAC poli-
cies (extended to include constraints on rules). They apply
their technique in diﬀerent examples of distributed system
architectures including Enterprise Java Beans and Microso ft
Enterprise Services for .NET. However, their approach does
not provide a ﬂexible access control mechanism because up-
dating the rules implies generating the security mechanism s
again. The approach provides a tool for specifying the acces s
control rules along with the model-driven development pro-
cess and then automatically exporting these rules to gener-ate the access control infrastructure. Our approach provid es
a ﬂexible access control architecture that supports updati ng
the access control rules.
7. CONCLUSIONS AND FUTURE WORK
In this paper, we have presented an approach that lever-
ages Domain-Speciﬁc Languages, Model-Driven Engineering
and models@runtime. Access control policies are expressed
by a security expert using a dedicated DSML. This DSML
is mapped to another DSML describing (runtime) software
architectures. When the access control policy is modiﬁed,
the architecture is causally impacted. Finally, we reused o ur
previous work in order to synchronize architectural models
with a system running on a component-based platform. This
way, the running system always reﬂects the access control
policy.
In future work, we plan to extend this work according
to two diﬀerent axis. First, along with the access control
mechanism, we will include support for usage control. Us-
age control aims at enforcing security rules specifying how
the data must be used, modiﬁed or distributed after access is
granted. In addition, we will try to complement our security
mechanism by adding new features like an intrusion detec-
tion system able to automatically reconﬁgure the system.
Second, we plan to map other domain metamodels, such as
workﬂow, GUI, house-automation [20], etc to our architec-
tural metamodel connected to a running system. This way,
it would be possible to drive the execution of a software
system by manipulating domain concepts, rather than by
directly manipulating the architecture.
8. REFERENCES
[1] Steve Barker and Maribel Fern´ andez. Term rewriting
for access control. In DBSec , pages 179–193, 2006.
[2] Steve Barker and Peter J. Stuckey. Flexible access
control policy speciﬁcation with constraint logic
programming. ACM Trans. Inf. Syst. Secur. ,
6(4):501–546, 2003.
[3] Elisa Bertino, Sushil Jajodia, and Pierangela
Samarati. A ﬂexible authorization mechanism for
relational data management systems. ACM Trans. Inf.
Syst., 17(2):101–140, 1999.
[4] Clara Bertolissi, Maribel Fern´ andez, and Steve Barker .
Dynamic event-based access control as term rewriting.
InDBSec , pages 195–210, 2007.
[5] W. Cazzola, A. Savigni, A. Sosio, and F. Tisato.
Architectural reﬂection : Bridging the gap between a
running system and its architectural speciﬁcation. In
REF’98: 6th Reengineering Forum , pages 8–11. IEEE,
1998.
[6] Thuong Doan, Steven Demurjian, T. C. Ting, and
Andreas Ketterl. Mac and uml for secure software
design. In FMSE ’04: Proceedings of the 2004 ACM
workshop on Formal methods in security engineering ,
pages 75–85, New York, NY, USA, 2004. ACM.
[7] D. F. Ferraiolo, R. Sandhu, S. Gavrila, D. R. Kuhn,
and R. Chandramouli. Proposed NIST standard for
role-based access control. ACM Transactions on
Information and System Security , 4(3):224 ˝U274, 2001.
[8] F. Fleurey, V. Dehlen, N. Bencomo, B. Morin, and
J-M. J´ ez´ equel. Modeling and Validating Dynamic
Adaptation. In 3rd International Workshop on
212Models@Runtime, at MODELS’08 , Toulouse, France,
oct 2008.
[9] Sushil Jajodia, Pierangela Samarati, Maria Luisa
Sapino, and V. S. Subrahmanian. Flexible support for
multiple access control policies. ACM Trans. Database
Syst., 26(2):214–260, 2001.
[10] J. J ¨urjens. UMLsec: Extending UML for Secure
Systems Development. In UML’02: 5th International
Conference on The UML , pages 412–425, Dresden,
Germany, 2002. Springer-Verlag.
[11] A. Abou El Kalam, R. El Baida, P. Balbiani,
S. Benferhat, F. Cuppens, Y. Deswarte, A. Mi` ege,
C. Saurel, and G. Trouessin. Organization Based
Access Control, 2003.
[12] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten,
J. Palm, and W.G. Griswold. An Overview of
AspectJ. In ECOOP’01: 15th European Conference on
Object-Oriented Programming , pages 327–353,
London, UK, 2001. Springer-Verlag.
[13] Dae-Kyoo Kim, Indrakshi Ray, Robert B. France, and
Na Li. Modeling role-based access control using
parameterized uml models. In FASE , pages 180–193,
2004.
[14] T. Lodderstedt, D. Basin, and J. Doser. SecureUML:
A UML-Based Modeling Language for Model-Driven
Security. In UML’02: 5th International Conference on
The UML , pages 426–441, Dresden, Germany, 2002.
Springer-Verlag.
[15] B. Morin, O. Barais, G. Nain, and J.M. J´ ez´ equel.
Taming Dynamically Adaptive Systems with Models
and Aspects. In ICSE’09: 31st International
Conference on Software Engineering , Vancouver,
Canada, May 2009.[16] B. Morin, F. Fleurey, N. Bencomo, J-M. J´ ez´ equel,
A. Solberg, V. Dehlen, and G. Blair. An
Aspect-Oriented and Model-Driven Approach for
Managing DynamicVariability. In MoDELS’08:
ACM/IEEE 11th International Conference on Model
Driven Engineering Languages and Systems , Toulouse,
France, October 2008.
[17] Brice Morin, Olivier Barais, Jean-Marc J´ ez´ equel,
Franck Fleurey, and Arnor Solberg. Models@ run.time
to support dynamic adaptation. Computer ,
42(10):44–51, 2009.
[18] T. Mouelhi, F. Fleurey, B. Baudry, and Y. Le Traon.
A Model-Based Framework for Security Policies
Speciﬁcation, Deployment and Testing. In
MoDELS’08: ACM/IEEE 11th International
Conference on Model Driven Engineering Languages
and Systems, Toulouse, France , 2008.
[19] P.A. Muller, F. Fleurey, and J. M. J´ ez´ equel. Weaving
Executability into Object-Oriented Meta-languages. In
MoDELS’05: 8th Int. Conf. on Model Driven
Engineering Languages and Systems , Montego Bay,
Jamaica, Oct 2005. Springer.
[20] G. Nain, E. Daubert, O. Barais, and J-M. J´ ez´ equel.
Using MDE to Build a Schizofrenic Middleware for
Home/Building Automation. In ServiceWave’08:
Networked European Software & Services Initiative
Conference , Madrid, Spain, December 2008.
[21] The OSGi Alliance. OSGi Service Platform Core
Speciﬁcation, Release 4.1, May 2007.
http://www.osgi.org/Speciﬁcations/.
213Figure 12: Access Control Metamodel
Figure 13: A Core Metamodel for Describing Runtime Architec tures
214