Multi-Objective Optimization in
Rule-Based Design Space Exploration
Hani Abdeen
DIRO Université de Montréal
Montréal, Canada
abdeenha@iro.umontreal.caDániel Varró
Dept. of Measurement and
Information Systems, BME
DIRO Université de Montréal
varro@mit.bme.huHouari Sahraoui
DIRO Université de Montréal
Montréal, Canada
sahraouh@iro.umontreal.ca
András Szabolcs Nagy
Dept. of Measurement and
Information Systems
Budapest University of
Technology and Economics
Budapest, Hungary
nasz013@gmail.comÁbel Hegedüs
Dept. of Measurement and
Information Systems
Budapest University of
Technology and Economics
Budapest, Hungary
abel.hegedus@mit.bme.huÁkos Horváth
Dept. of Measurement and
Information Systems
Budapest University of
Technology and Economics
Budapest, Hungary
ahorvath@mit.bme.hu
ABSTRACT
Design space exploration (DSE) aims to ﬁnd optimal design
candidates of a domain with respect to diﬀerent objectives
where design candidates are constrained by complex struc-
tural and numerical restrictions. Rule-based DSE [10,14,18]aims to ﬁnd such candidates that are reachable from an ini-tial model by applyinga sequenceof exploration rules. Solv-ing a rule-based DSE problem is a diﬃcult challenge due tothe inherently dynamic nature of the problem.
Inthecurrentpaper, weproposetointegratemulti-object-
ive optimization techniquesbyusing Non-dominatedSortingGeneticAlgorithms(NSGA)todriverule-baseddesignspaceexploration. For this purpose, ﬁnite populations of the mostpromising design candidates are maintained wrt. diﬀerent
optimization criteria. In our context, individuals of a gener-
ation are deﬁned as a sequence of rule applications leadingfrom an initial model to a candidate model. Populationsevolve by mutation and crossover operations which manip-ulate (change, extend or combine) rule execution sequencesto yield new individuals.
Our multi-objective optimization approach for rule-based
DSE is domain independent and it is automated by toolingbuilt on the Eclipse framework. The main added value is toseamlessly liftmulti-objectiveoptimizationtechniquestotheexploration process preserving both domain independenceand a high-level of abstraction. Design candidates will still
be represented as models and the evolution of these models
as rule execution sequences. Constraints are captured bymodel queries while objectives can be derived both frommodels or rule applications.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributedfor pro ﬁt or commercial advantage and that copi es bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-publish, to post on servers or to redistribute to lists, requires prior speci ﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
ASE’14, September 15-19, 2014, Vasteras, Sweden.
Copyright 2014 ACM 978-1- 4503-3013-8/14/ 09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2643005.Categories and Subject Descriptors
I.2.8[ Computing Methodologies ]: ProblemSolving, Con-
trol Methods and Search—heuristic methods, graph search
strategies ; D.2.2 [Software Engineering ]: Design Tools
and Techniques— evolutionary prototyping, computer-aided
software engineering
Keywords
rule-based design space exploration; multi-objective opti-
mization; model-driven engineering
1. INTRODUCTION
Asa challenging branchof search based software engineer-
ing (SBSE), design space exploration (DSE) aims at search-ing through diﬀerent design candidates to fulﬁll a set of con-
straints and then proposing optimal designs with respect to
certain objectives. It frequently supports activities like con-ﬁguration design of avionics and automotive systems. Manyof such traditional static DSE problems can be solved byusing advanced search and optimization algorithms or con-straint satisfaction programming techniques [5,10,15,18,29].
In model-driven engineering (MDE), rule-based DSE [10,
14,18] aims to ﬁnd instance models of a domain that are(i) reachable from an initial model by applying a sequenceof exploration rules, while (ii) constraints simultaneously in-clude complex structural and numerical restrictions. Model
driven techniques oﬀer expressive modeling languages and
advanced tools to capture the DSE problem of diﬀerent do-mains independently on a high level of abstraction close tothe domain itself. However, solving a rule-based DSE prob-lem is a diﬃcult challenge dueto theinherently dynamicna-ture of the problem. Such dynamic DSE problems may arise
in complex reconﬁguration challenges of supervising cyber-
physical systems (CPS) or IT infrastructure [18] or quick ﬁxgeneration in domain-speciﬁc modeling environments [17].
As a practical observation, the solution space of a rule-
based DSE problem is dense in principle, but one cannotput an a priori upper bound on the number of model ele-
ments used in a design candidate (i.e. model elements may
289
be created and deleted during exploration). Unfortunately,
this makes the exhaustive exploration of the design space
intractable. Furthermore, many practical problems necessi-tate to continue the exploration of the design space incre-mentally from a previous solution (instead of starting thesearch from scratch each time). Such incremental solvingis rarely handled by state-of-the-art constraint solvers (as
demonstrated in [20]).
Rule-based model-driven DSE problems have additional
challengesalso fromanoptimizationperspective. First, some
objectives are not values of simple cost attributes but com-plex model metrics calculated by model queries. Further-more, certain cost calculations may depend on the sequence
of exploration rules applied on the design model. Finally,
we may not ﬁnd a single combined objective function butmultiple objectives may need to be incorporated to identifythe best design candidates.
Existingrule-basedDSEsolutionsexploit(1)modelcheck-
ing with powerful graph-based symmetry reduction [14], (2)
dependencyanalysis and hintsby formal abstractions [18] or
(3) diﬀerent search strategies (e.g. hill climbing, simulatedannealing) [10]. As a commonality in these approaches, thecore exploration procedure follows a local-search based ap-
proach, i.e. it gradually extends the search towards promis-
ing candidates by priorities deﬁned by local heuristics.
Global search techniques(like genetic algorithms or multi-
objective optimization) have already proved to be successfulin various MDE scenarios for ﬁnding constraints [16], modeltransformations [25] or solving static DSE problems [35]where an exhaustive search algorithm becomes infeasible.
Moreover, they provide graceful degradation for problems
where no solutions exist which meet all the objectives andconstraints by relaxing hard constraints to soft constraints.
Inthecurrentpaper, weproposetointegratemulti-object-
ive optimization techniques by using the Non-dominatedSortingGeneticAlgorithm (NSGA-II)[9]todriverule-based
design space exploration. For this purpose, ﬁnite popula-
tions of the most promising design candidates are main-tained wrt. diﬀerent optimization criteria. In our context,individuals of a generation are deﬁned as a sequence of ruleapplications leading from an initial model to a candidatemodel. Populations evolveby mutation and crossover opera-
tions which manipulate(change, extendor combine) rule ex-
ecution sequences to yield new individuals. However, a keytechnical challenge that we face in genetic rule-based DSEis to preserve the feasibility of candidate solutions whichare generated using genetic oper ators. Indeed, in rule-based
DSE, crossing two feasible solutions, and/or randomly mu-
tating a feasible solution, may yield infeasible candidates if
the corresponding rule execution sequence is infeasible. Inour approach, candidate solutions generated using geneticoperators are automatically corrected to preserve their fea-sibility.
The main added value of our multi-objective optimiza-
tion approach for rule-based DSE is to seamlessly lift multi-objective optimization techniques to a domain-independentmodel-level exploration process while preserving a high-levelof abstraction. Design candidates will still be representedas models and the evolution of these models as rule execu-
tion sequences. Constraints are captured by model queries
while objectives can be derived both from models or rule ap-plications. On the theoretical level, models are formalizedas graphs, model queries as graph patterns and explorationrules as graph transformation rules, thus our work can be
considered as a multi-objective exploration of graph trans-
formation system. Our approach is supported fully auto-mated tooling built on advanced components of the Eclipseframework.
2. BACKGROUND
2.1 Motivating example
As a motivating example of the paper, we consider mod-
eling the conﬁguration of a smart building which oﬀers of-
ﬁces to rent with highly conﬁgurable services such as ﬁrealarm, air conditioning and security monitoring (see Fig. 1).Asmart buildingis frequentlyconsideredas a cyber-physicalsystem (CPS) where services need to be deployed on both
embedded(sensors, controllers, etc.) andvirtual(e.g. servers,
cloud) computational units, which signiﬁcantly complicatesthe design and maintenance of service conﬁgurations over achanging infrastructure.
(a) Architecture
(b) Services and Requests
Figure 1: Conﬁguration model of a smart building
In our smart building example, companies are oﬀered to
rent oﬃces with multiple rooms each of which can be con-ﬁgured according to four service packages (see Fig. 1b):
●Basic: This package runs the compulsory ﬁre alarm
service which requires one smoke sensor for each room.
290●Comfort : This package also oﬀers air conditioning by
measuring temperature by three sensors (per room)
and setting the required temperature. Measuring thetemperature also oﬀers a backupsolution for ﬁre alarmshould the sensors fail.
●Secure: This package extends the Comfort package
to oﬀer security surveillance by a video camera con-tinuously recording events in the room and a motioncheck application which highlight critical events auto-matically.
●Max: This package enhances the Securepackage by
providing a heat map of the room which can be usedfor ﬁre alarm as well as for surveillance purposes.
Two sample company requests are also listed in Fig. 1b
which summarizes the selected packages for a certain num-
ber of rooms together with the application instances to be
deployed and hardware devices to be installed. For instance,the ﬁrst request consists of 2 rooms with comfort pack-age and 1 room with basic package, and it necessitates torun smoke detector (SD) service (for 3 rooms, 1 device perroom), the measure temperature (MT) service (for 2 rooms,
3 devices per room) and the set temperature application (for
2 rooms, jointly installed on a compute server).
Domain metamodel. The main concepts of conﬁguration
design for this smart building are generalized in the meta-model of Fig. 2. Renting companies will issue Requestsf o r
implying a set of Requirement s each of which identiﬁes a
required service (called application type, shortly ApplType )
and the number of redundant instantiations for running this
application ( countattribute). Sensorsandcomputationunits
are uniformly called HostType s. Each application type may
claim several host types and suﬃcient amount of resources
(e.g. memory, storage) for its execution as deﬁned by a re-source requirement(shortly, ResReq). Forinstance,calculat-
ing a heat map requires 5 GB memory and 3 GB permanent
storage as deﬁned by the labels of dashed arrows in Fig. 1a.
Figure 2: Metamodel for smart building conﬁguration
In therunning system, multiple application instances, Ap-
plInstshortly, of an application type may exist each of which
isdeployedonahost instance(shortly, HostInst) correspond-
ing to a speciﬁc host type. Such deployment consumes a
certain amount of resources in the host instance (up to itstotal memory and storage) as speciﬁed by the correspond-ing resource requirement. Application instances need to
be started after they are allocated to a host instance, andstopped when they are no longer needed, which fact is rep-resented by the stateattribute.
2.2 A rule-based DSE problem
Conﬁguring the smart building (i.e. installing devices, al-
locating and running applications) can be considered as adesign space exploration problem. However, this conﬁgura-tion is not a static problem as (1) requests may change overtime (new requests arrive, existing ones are canceled) and
(2) certain faulty devices may no longer function. This way,
we are interested in an incremental approach for calculatinga new conﬁguration which starts from the last conﬁgurationand incorporates the changes in the context and require-ments of the system. Furthermore, there are multiple con-
straints and objectives which needs to be incorporated for a
good candidate conﬁguration.
Figure 3: Constraints for smart building conﬁguration
Constraints.
Constraints capture valid or invalid conﬁgurations. They
are frequently formalized by graph patterns as well or ill-formedness criteria which capture the violations of the cor-responding constraint. In our example (see Fig. 3),
●satisﬁedReq(E) identiﬁes a requirement Eof a re-
questRwhich is instantiated into a suﬃcient number
of application instances (i.e. the number of instancesis equal to the required redundancy);
●allocatedAppl(AI) identiﬁes an application instance
AIwhich is allocated to a host instance HIto fulﬁll
the resource requirement between the corresponding
application type ATand host type HT;
●appInstRun(AI) identiﬁesan application instance of
a conﬁguration which is running;
●extraHost(H) identiﬁesahostinstance Hwhich does
not host any application instances.
Theﬁrstthreeconstraintscapturedesiredsituations,while
the fourth constraint captures an undesired case. All these
constraints are captured by means of graph patterns [6]whichdenotestructuralconditionsthattheunderlyinggraphmodelneedstorespect. Given aconstraint candan instance
modelM,m∶c↦Mdenotes a graph morphism identifying
a violating fragment of M.
Objectives.
Inordertoobtainagoodconﬁguration,weneedtoaddress
various objectives:
●Ideally, all conﬁguration constraints need to be satis-
ﬁed, thus this is a top-level objective.
291Figure 4: Exploration rules of the smart building example
●The smart building operators aim at maximizing the
utilization of compute servers. Here, the best utiliza-tion of memory or storage is incorporated for eachserver, and the average of utilization is taken as a re-source objective.
●Installing new host instances and other conﬁgurationoperations imply certain cost. Minimizing such costsis another objective of conﬁguration design.
In our context, we distinguish between model objectives
which are calculated from design candidates (e.g. by query-ing the underlying model) and trajectory objectives which
are calculated along trajectories of applied exploration rules.
Exploration rules.
Inrule-basedDSE,designcandidatesareallowed toevolve
by executing exploration rules. In the paper, such explo-ration rules are captured by graph transformation rules r=
(L,R)whereLdenotestheleft-handside graph pattern pre-
scribing the precondition of rule application, while Rdeclar-
atively describes the eﬀects of the rule. Rules may have (i)
input and output parameters to pass contextual objects to
other rules, and (ii) costs incurring when a rule is applied.Ar u l eris applied on a model Mby (1) ﬁnding a match m
of graph pattern LinM(denoted as m∶L↦Mand also
called an activation of rule r), (2) then removing elements
fromMw h i c hh a v ea ni m a g ei nL ∖Rand ﬁnally (3) creat-
ing new elements in Mfor elements in R∖L.A sar e s u l to f
rule application, we obtain a new model M
1which step is
denoted as Mr,m/leftrightline→M1. The exploration rules of our example
are depicted (in a combined notation like in GROOVE [14])in Fig. 4.
●Rule newHostInst installs a new host instance HIof
ah o s tt y p e HTand sets the available resource param-
eters to that of the host type.●Rule newApplInst creates anewapplication instance
AIin accordance with the countattribute of require-
mentE(by reusing the condition deﬁned by graph
pattern unsatisﬁedReq(E) ).
●Rule startinitializes a stopped application instance
AIwhich is already allocated to a host device while
rulestopstops a running instance.
●Rule allocate aims to allocate (an unallocated and
stopped) application instance AIto a host instance
HIin accordance with the resource requirement RR
provided that suﬃcient memory and storage space is
still available at HI.
●Ruledeleteremovesanexistingallocation ofastopped
application instance AIfrom a host instance HI,a n d
frees the related memory and storage resources of HI.
●Rule movecombines the allocate and delete rule into
one, and changes the allocation of an application in-
stanceAIfrom host instance HItoHN,a n da d j u s t s
the resource usage accordingly.
A cost is associated to the application of each exploration
rule. Thecostofrule newHostInst isspeciﬁctothematched
host type element HTas deﬁned by the black circles in
Fig. 1a, while the cost of all other rules are deﬁned in graycircles in Fig. 4.
3. APPROACH
In this section, we describe our approach to integrate
multi-objective optimization techniques by using the Non-dominatedSortingGeneticAlgorithm(NSGA-II)[9]todriverule-based design space exploration. In the following, wedescribe the basic principles of the used multi-objective op-timization technique, then we present an overview of our
approach and its implementation details.
292Figure 5: Overview on NSGA-II process
3.1 Optimization algorithm principles
Fig. 5 shows an overview on the NSGA-II. The aim of
NSGA-II is to ﬁnd a set of Pareto optimal solutions in a sin-
gle run. As a genetic algorithm, NSGA-II performs a globalexploration of the search space by making and evolving ﬁ-
nite populations of candidate solutions using selection and
genetic operators. The outputof thealgorithm is a set of theﬁttest solutions (i.e., the Pareto front) produced along all
generations. The decision maker can select one of the ﬁttestsolutions according to his/her preference ( e.g.,the solution
which satisﬁes all the requirements).
When searching for solutions to a problem using Pareto
optimality ( i.e.,multi-objective), the search yields a set of
solutions that are not-dominated [37]. If all objective func-tions are for maximization, we say that a feasible solutions
1dominates another feasible solution s2(s1≻Os2), if and
only if,s1is better than s2for at least one objective, while
s2is not better than s1regarding all the objectives in O[9]:
∃oj∈O∶oj(s1)>oj(s2)∧∄ oi∈O∶oi(s2)>oi(s1)(1)
NSGA-IIsortssolutionsinorderedfronts, frombesttoworst,according to their non-domination level.
However, from a practical MDE viewpoint, constrained
multi-objective optimization is important in the context ofDSE. This is due to the fact that the primary objective of
a DSE approach is to ﬁnd valid solutions that satisfy all the
requirements of the underlying problem. Other objectives,
such as reducing the cost of obtained solutions, could not
add an eﬀective value to the optimization results unless theobtainedsolutionsarevalid. Hence,weadapttheconstraint-handling strategy with NSGA-IIthat was proposed in [9,22].
I nt h ep r e s e n c eo fc o n s t r a i n t s( i.e.,requirements), a solu-
tion can be either valid ( i.e.,it satisﬁes all the constraints)
or invalid ( i.e.,it does not satisfy all the constraints, totally
or partially). Considering the top-level preference of con-straints’ satisfaction over other objectives that we describedin Sec. 2.2, the domination function in Equation (1) is mod-
iﬁed as follows:
Deﬁnition. Asolution s
1issaid to constrained-dominate
as o l u t i o n s2, if one of the following conditions is true:
1.s1is valid and s2is not.2. Both solutions, s1ands2, are invalid, but s1hasa
smaller overall constraint violation .
3.s1ands2are valid and s1dominates s2with the usual
domination function (Equation (1)) .
The idea behind this constrained-domination strategy is
that, on the one hand, any valid solution has a better non-
domination rank than any invalid solution. On the otherhand, valid solutions are ranked into their non-dominationlevel based on their associated quality as measured by thevalues of objective functions. And, invalid solutions areranked into their non-domination level in descending order
according to their associated constraint violation.
In the following we presentour adaptation of the NSGA-II
to theproblem of rule-based DSE by deﬁning our implemen-
tation of the following elements:
●Representation of candidate solutions (individuals).
●Optimization objectives.
●Genetic operators used to explore the search space.
3.2 Approach overview
The optimization inputs and procedure. Fig. 6 shows an
overview of our approach. Given an initial model M0be-
longing to a domain model DM,as e to fr e q u i r e m e n t st o
be satisﬁed Req,a n das e t Rof exploration rules, our multi-
objective search-basedapproachfor rule-basedDSEexploresthe design space starting from M
0by maintaining ﬁnitepop-
ulations of the most promising design candidates wrt. the
set of requirements Reqand other optimization criteria O.
In our approach, each individual of evolving populations is a
map of a candidate model Mnobtained as a sequence of rule
executions, denoted as ⃗rn, leading from the initial model M0
toMn:⃗rn=M0r1,m1/leftrightline→M1...rn,mn/leftrightline→Mn,w h e r eri∈Randmi
is the match of riinMi.
The generation of the initial population starting from M0
(step 1of the optimization process in Fig. 6) is achieved
by applying random (but executable) exploration rules fromRo nM
0. The second step of the optimization process in
Fig. 6 is based on the NSGA-II as explained in Sec. 3.1 and
293Figure 6: Approach Overview
Fig. 5, where populations evolve by applying mutation and
crossover operations which change and/or extend existingrule execution sequences to yield new individuals. The re-quirements are deﬁned as soft constraints Cthat are cap-
tured by model queries (see Fig. 3) while other optimizationobjectives can be derived both from models or rule execu-tion sequences. Each constraint c
iinCcan be associated
t oas p e c i ﬁ cw e i g h t widescribing the relative importance
of this constraint, thus each violation of ci(calculated as a
match of the corresponding graph pattern) will be weighted
accordingly.
Candidate solution representation. The multi-objective
rule-based design space exploration problem can be deﬁned
as:DSE=(M0,C,O,R)whereM0denotestheinitialmodel,
Cdenotes the (structural and attribute) constraints char-
acterizing valid design candidates, Ois a set of numerical
objectives which needs to be optimized, while Ris a set of
exploration rules describing valid evolutions of the design.
Acandidate solution of a DSE problem is a pair Scand=
(Mcand,⃗rcand)where (1) the candidate model Mcandfulﬁlls
all (or some) constraints in Cand (2) it is reached from
the initial model M0by a sequence of rule executions ⃗rcand.
Amodel objective omis evaluated for a candidate solution
Scandon the candidate model Mcandwhile a trajectory ob-
jectiveotforScandis evaluated on the sequence of rule ex-
ecutions⃗rcandleading to Scand. Considering our running
example, reducing the number of constraint violations is a
model objective or increasing utilization, while reducing thecost associated to the trajectory ⃗r
candis a trajectory objec-
tive.
Deﬁnition of Feasible and Valid candidate solutions.
By deﬁnition, a candidate solution is called feasibleif its rule
execution sequence ⃗ris executable. In a genetic approach
for rule-based DSE, infeasible solutions can occur when ap-plying genetic operators ( e.g.,crossover) on existing feasible
solutions. However, in our approach, such infeasible solu-tions are automatically corrected (or truncated) to guaranty
their feasibility, or omitted if they cannot be corrected.Consider newHostInst(HI);allocate(AI,HI,RR)which
is a rule execution sequence that aims to create a new host
instance HIand then allocate an application instance AI
to it is not executable if there is no application instance AI
to be allocated. To correct this infeasible sequence, the cre-ationofanewapplicationinstancebyrule newAppInst(AI),
should precede the allocate(AI,HI,RR)rule. Otherwise,
the sequence must be truncated so that it includes only therule execution newHostInst(CS1).
A feasible solution S=(M,⃗r)is deﬁned as a validsolution
if its associated model Mfulﬁlls all constraints inC:i.e.,
∀c∈C/∃m∶c↦M.
The objective of constraints ful ﬁllment. As constraints
areformalized bygraphpatterns, inordertoevaluatethede-gree of well-formedness constraints are met or ill-formedness
constraintsare violated in acandidatemodel M
n,w eu s et h e
weighted sum of the number of matches for the correspond-
ing graph patterns P.
For instance, let us evaluate the constraints of Fig. 3 on a
sample model Mof Fig. 7. For this model, our optimization
approach will returns that the graph pattern satisﬁedReq
has 1 match and the graph pattern extraHost has 1 match.
In our example, the weight of satisﬁedReq is set to w1=2
and the weight of extraHost is set to w2=−1, therefore, the
degree of constraint violations in Mis:ConstViol(M)=
1×w1+1×w2=1.
Figure 7: Objective of constraint fulﬁllment
Formally, let matches( p,M)returnthenumberofmatches
of the graph pattern p∈Pin the model M,a n dl e t wpde-
note the weight associated to the constraint described by p
(wherewpis a positive value for well-formedness constraints
and a negative value for ill-formedness constraints). Thenour objective of constraints fulﬁllment is deﬁned as follows:
Obj.1
ConstFulfillment (M)=∑
∀p∈Pwp×matches( p,M)
The primary optimization objective of our approach, as ex-
plained in Sec. 3.1, is to maximize ConstFulfillment (M),
i.e. to maximize the fulﬁllment of positive constraints andminimize the degree of negative constraint violations.
Model-speci ﬁc objectives. Our approach allows to deﬁne
domain-speciﬁc objectives captured by graph patterns over
the underlying model. Thanks to the incremental query
evaluation approach (see Sec. 3.3), the re-evaluation of suchmodel objectives is instantaneous upon model changes.
In the context of our motivation example in this paper, we
deﬁnethemodel-speciﬁc objective of maximizing theutiliza-tionofcomputeservers( CSUtil), sothatthebestutilization
of memory or storage is incorporated for each server.
294LetUtil(CSi)returnthe(normalized)resource utilization
for the computer server CSiwhile the system-level utiliza-
tion of computer servers CSUtil for a solution S=(M,⃗r)
is deﬁned as the mean of the utilization of each individual
computer server element in M:
Obj.2
CSUtil(S)=1
n∗j=n
∑
j=1Util(CSj)
In the above equation, nis the number of computer server
instances in the underlying model M.
Rule sequence objectives. Two valid solutions can beach-
ieved via two diﬀerent feasible sequence of rule executions.Therefore, wemaydeﬁneobjectivesspeciﬁctoruleexecutionsequences to evaluate the cost incorporated in achieving a
valid solution along a speciﬁc path.
For this purpose, we deﬁne the cost of a feasible solution
S=(M,⃗r)as the sum of costs of all rule executions in its
sequence of rule executions ⃗r:
Obj.3
Cost(S)=∑Cost(Mi−1ri,mi/leftrightline→Mi)∀Mi−1ri,mi/leftrightline→Mi∈⃗r
Cost(S)takes its values in the interval [0.. ∞[. Minimizing
Cost(S)is an objective of our optimization approach. Com-
puting the cost Cost(Mi−1ri,mi/leftrightline→Mi)of a rule execution in
⃗rdepends on three parameters to be deﬁned by the domain
experts:
●Fixed cost: the ﬁxed cost Cbof the applied rule ri;
formally, Cost(...ri,mi/leftrightline→...)F=Cb(ri). As deﬁned in
Fig. 4,creatinganapplicationinstancewillalwayshave
the same cost, which is Cb(newApplInst)=2.
●Match cost: the match cost Cmwhich is associated to
the match miinMi; formally Cost(...rj,mj/leftrightline→...)M=
Cb(rj)+C mj(rj),w h e r eCmj(rj)returns the cost of
rja c c o r d i n gt oi t sm a t c h mj. For instance, the cost
of rulenewHostInst is speciﬁc to the matched host
type element HT(as deﬁned by the black circles in
Fig. 1a).
●Sequence cost: the sequence cost Csmay depend on
the position of the rule execution ...ri,mi/leftrightline→...in⃗r.F o r
thispurpose, wedeﬁnethecostofsucharuleexecutionas relative to its position in ⃗ron the same match m:
Cost(...rk,mk/leftrightline→...)S=position(rk,mk)×Cost(...rk,mk/leftrightline→
...)M,w h e r e position(rk,mk)returns the position of
rkapplication on the same match mkin⃗r.
Genetic operators (mutation and crossover). In this pa-
per, we deﬁne and use diﬀerent types of mutation and cross-over operators for exploring the design space. In our con-text, mutating a solution S=(M,⃗r)means to modify the
sequence of rule executions ⃗r, which is conceptually diﬀerent
from most genetic approaches used for DSE purposes. Thisc a nb ea c h i e v e di nd i ﬀ e r e n tw a y s :
●Add new rule execution: a new sequence of rule ex-
ecutions⃗r
′is generated by selecting an appropriate
exploration rule r′fromR, that can be applied on M,
and execute it:⃗r′=⃗r+{Mr′,m/leftrightline→M′}●Delete a random rule execution: a new sequence of rule
executions⃗r′is generated by deleting a random rule
execution reiin⃗r:⃗r′={re0,...,re i−1,rei+1?,...?}.
The question marks in the aforementioned sequencedenote the execution rules which will be checked forexecutability after delete is performed. Indeed, afterdeleting re
i, the executability of the new sequence ⃗r′is
checked starting from the rule execution rei+1,s ot h a t
ifrei+1is not executable anymore it is then ignored
(removed from the sequence), and so on for each rei+k,
k>1.
●Swap between two rule executions: a new sequence of
rule executions⃗r′is generated by selecting a random
rule execution reiin⃗r, then selecting another rule ex-
ecutionrej(j>i)i n⃗r, that can replace reiand still
executable, then swap between reiandrejso that:
⃗r′={re0,...,re j,rei+1?,...?,rei?,rej+1?,...?}.S i m -
ilarly to the case of delete a random rule executiondiscussed above, the executability of the new sequence
⃗r
′is checked starting from the rule execution rei+1.
The crossover operators apply on two individuals repre-
sented by the sequences of rule executions of two parentsolutions S
1=(M1,⃗r1)andS2=(M2,⃗r2), and generate
two new oﬀspring individuals (children). Fig. 8 describesthe three crossover operators that our optimization process
uses:
(a) One-point crossover
(b) Cut-and-splice crossover
(c) One-point permutation crossover
Figure 8: Crossover operators
●One-point crossover (Fig. 8a): a single crossover point
on both sequences of rule executions of parents is se-
lected. All rule executions beyond that point in eithersequences of rule executions are swapped between thetwo-parent sequences. The resulting sequences of rule
executions are the children.
●Cut-and-splice crossover (Fig. 8b): cut-and-splicecross-
over is a variation of the one-point crossover where the
diﬀerence is each parent’s sequences of rule executionshas a separate choice of crossover point. As a result,the children sequences of rule executions will have dif-
ferent length than that of their parents.
295●One-point permutation crossover (Fig. 8c): inthiscross-
over operator, every rule execution reiin either se-
quences of rule executions (parents) will have an id.
This id is based on the applied rule riand the match
element miofrei. Hence, two rule executions, riand
rj, can have the same id iﬀ they are applications of
the same rule ron the same match m.R e p r e s e n t -
ing the rule executions by their ids, a sequence of rule
executions will have a permutation representation, asin Fig. 8c. With the one-point permutation crossover,one crossover point is selected on both sequences ofrule executions of parents, from the ﬁrst (second) par-ent the permutation is copied up to this point, then
the second (ﬁrst) parent is scanned and if the idof
the rule execution is not yet in the oﬀspring, the rule
execution is added.
For every crossover operation, our approach performs anautomatic executability check of rule executions occurringafter the cut point(s) in children sequences of rule execu-tions. The correction mechanism is identical to that used inthe delete and swap mutations that we described above.
3.3 Implementation Overview
The proposed framework has been fully automated by im-
plementing it on top of the ViatraDSE framework [18]. In-put models and design candidates are represented as EclipseModelingFramework (EMF)models. TheopensourceEMF-IncQuery [36] framework is used for evaluating constraintsand calculating the valuesof objectives over instance models
incrementally upon model changes. Finally, operations are
captured by graph transformation rules. Additional searchand conﬁguration parameters can be set prior to starting amulti-objective optimization run.
For each individual in a population, we store the sequence
of rule applications that leads to them from an initial model,thus individuals get recalculated several times. However,due to the incremental transformation support by EMF-IncQuery, this recalculation is very fast. Furthermore, eachindividual can be processed in parallel by diﬀerent threadsto speed up the exploration process.
Implementation challenges included to (1) identify if two
individualsareidentical in apopulation and(2) toeﬃcientlyencode the individuals themselves. Instead of performingcostly graph isomorphism checks to address (1), we relyupon the vector of numeric objectives: if two individualshave the same values for all objectives, then one of them
is removed from the population. For (2), we use domain-
speciﬁcstateencodingstoidentifyandstorematchesofrulesin order to replay them when deriving a new individual.
4. EXPERIMENTAL EVALUATION
As there are no widely established benchmarks available
for evaluating rule-based DSE approaches, we carried outexperimental evaluation in the context of our case study.
For this purpose, we compare our multi-objective optimiza-
tion (NSGA) approach with (1) random simulation (Ran-dom) and (2) a ﬁxed priority local search (FPLS) strategyused as a basis of comparison in [18]. As a consequence, theDSE problem is identical in both cases, furthermore, theevaluation of graph patterns and execution of graph trans-
formation rules is carried out by the same implementation.This way, any diﬀerence between the measurement results isexpected to be aﬃliated to the substantially diﬀerent search
strategies. Our measurements aim to address which DSEapproach ﬁnds better candidates wrt. diﬀerent objectives.For this purpose, we test the following hypothesisusing two-tailed Wilcoxon tests:
H0There is no signiﬁcant evidence that NSGA outper-
forms FPLS and/or Random.
H1There is a statistical evidence that NSGA outperforms
other DSE approaches wrt. diﬀerent objectives.
4.1 Experimental scenario
In our experimental scenario, we generate requests for an
increasing number of rooms (4, 6, 8, 12) with an equal useof all packages (and respective model sizes of 130, 200, 230
and 330 graph elements). The initial model only contains
the requests with requirements and the application and hosttypesbutno host instances are available. Therefore, it is therole of the DSE process to (1) create a suﬃcient number ofapplication and host instances, (2) allocate application in-
stances tohost instances, andthen (3) start and stop the ap-
plication instances by applying the appropriate explorationrules. In the most complex case, the diﬀerent explorationtechniques had to synthesize a rule sequence consisting ofover 200 steps.
In a preparatory phase, we experimented with diﬀerent
conﬁgurations of our multi-objective DSE approach, and wedecided on the most promising conﬁguration parameters,such as population size of 15 individuals, iterations between400 and 1200 steps, crossover by permutation, and high rateof mutations. Ourmeasurements were runon 8-core desktopcomputers with 32 GB of RAM running on Linux operating
system. The used Java version was 1.7.0
55 and the heap
size was 24GB.
Thenfortheexperiments, wesetupatimeoutof2minutes
for test cases (except for the largest example where it was
5 minutes) and run 30 experiments on the diﬀerent problemsizes. One experiment was constructed as follows:
●NSGA: We selected population size popand iteration
numberitfor a problem size, and run our algorithms.
At the end of each run, we selected only one solutionfrom the Pareto front produced by NSGA. We selectedthe solution which has the best constraints’ fulﬁllmentvalue. If several solutions have the best constraints’fulﬁllment value, then we select the solution which is
characterized by the minimal cost and/or the maxi-
mum usage of computer servers.
●Random :W e e x e c u t e d pop×itrandom simulation
runs and recorded the best result.
●Fixed priority LS (FPLS) : We set up priorities in
a way to guarantee that all application instances willeventually be allocated to host instances. Our priori-ties guaranteed that the ﬁrst three soft constraints will
deﬁnitely be guaranteed, but we may generate more
host instances than necessary.
296Figure 9: Quality of NSGAsolutions producedin 30 runsfor
diﬀerent problem sizes, as measured by the measurementsnormalized constraints’fulﬁllment, costandcomputerserverutilization
4.2 Results analysis
Before comparing the results of our approach NSGA with
thoseofFPLSandRandom,weanalysisthequalityofNSGA
solutions. Figure 9 shows the distribution of NSGA pro-
duced solutions in 30 runs for considered problem sizes (4,
6, 8 and 12 requested rooms). The ﬁgure shows that in allconsidered scenarios, NSGA produced solutions have over-all good quality. Considering all the produced solutions(30runs×4scenarios=120solutions), the minimum fulﬁll-
ment of constraints is above 80%, and for the major body
of produced solutions, the fulﬁllment of constraints is above
90%. Analyzing the evolution of the mean value of con-straints’ fulﬁllment through diﬀerent problem sizes, we ﬁndthat it takes its minimum value, around 90%, in the prob-lem size 12 where the incorporated cost in the sequences of
rule executions is relatively small, as compared to the cost of
other solutions in the problem size 12. Indeed, this relativelow fulﬁllment of constraints is mainly due to the followingfact: the optimization process was stopped before reachingsequences of rule executions that have enough depth to sat-isfy all the requirements associated to this problem size. In-
creasing thenumberof iterations of the optimization process
in this problem size, NSGA was able to ﬁnd better solutionsin terms of constraints’ fulﬁllment, as demonstrated by so-lutions which have high cost. As for smaller problem sizes,such as in the scenarios of 4 and 6 requested rooms, in al-most all runs NSGA was able to ﬁnd fully valid solutions
that satisfy all the constraints.
Table 1: Comparing between the results of our approach
NSGA and FPLS, and between the results of NSGA andRandom, with diﬀerent problem sizes with regard to the
number of requested rooms: two-tailed Wilcoxon tests with
α=0.05 and adjusted p.value using the Benjamani and
Hochberg (BH) correction for multiple tests.
Δ(NSGA - FPLS) Δ(NSGA - Random)
PbConst. Solution CS Const. Solution CS
size Ful. Cost Util. Ful. Cost Util.
4+20** –369** +0.32** +44** –145** +0.19**
6+27** –559** +0.37** +91** –118** +0.06
8+20** –746** +0.46** +92** –239** +0.22**
12+6 –1058** +0.51** +55** –8 +0.18*
Values in bold-face denote that NSGA results outperformed the re-
sults of FPLS and/or Random, with statistical signiﬁcance. ** and
* denotes results which are statistically signiﬁcant at α=0.01 and
α=0.05, respectively.To conﬁrm our claim that NSGA produces good results,
we compare NSGA’s solutions to those produced by FPLS
and Random. Table 1 shows clearly that NSGA outper-forms both FPLS and Random, with statistical evidence, inalmost all cases. Indeed, only in the problem size 12, thereis no signiﬁcant statistical evidence that NSGA outperformsFPLS with regard to constraints’ fulﬁllment. However, in
this case, NSGA signiﬁcantly outperforms FPLS in reducing
the cost of solutions and increasing the usage of computerserver resources. Hence, NSGA overall signiﬁcantly outper-forms FPLS, and the same ﬁnding apply for the Randomapproach. As a consequence, we reject the null hypothesisH
0and accept H 1.
5. RELATED WORK
Rule based design space exploration frameworks. Mod-
el checking approaches to analyze GT systems are similar
to our approach as they also perform state space explo-
ration. One can categorize them as compiled approaches
such as [2,3,11,12,34], which translate graphs and GT rulesinto oﬀ-the-shelf model checkers to carry out veriﬁcation,and interpreted approaches like [1,26,30], which store sys-
tem states as graphs and directly apply transformation rules
to explore the state space, similarly to our approach.
In [14] the state space explored by the GROOVE frame-
work is stored as a structured graph model that can be
queried using logical expressions. This approach allows theevaluation of trajectories using cost functions deﬁned afterthe exploration and even the combined assessment of multi-
ple solutions.
Common in these approaches that they place emphasis
on exhaustive traversal (e.g. by optimizing the storage of
individual states), while we aim at ﬁnding solutions quicklyusing genetic algorithms.
In [10] the T-Core framework is used for implementing
typical meta-heuristic exploration strategies, such as hillclimbing and simulated annealing using the transformationprimitives of the framework while the operations are speci-ﬁed as graph transformation rules. As a distinguishing fea-ture, our approach supports trajectory based objective def-inition and mutation operations.
Compared to previous work of the authors, we extend
our model-driven design space exploration framework [18]by providing support for multi-objective optimization al-gorithms that complement our guided local-search basedapproaches [19]. The application of multi-objective ap-
proaches in a model-driven DSE context provides a unique
combination of expressivenessandthusallows itsapplicationto novel problem domains.
Other design space exploration. TheDESERT tool suite
[29] provides model synthesis and constraint-based DSE forDSMLs with structural semantics, using ordered binary de-cision diagrams for encoding and pruning the design space.Saxena and Karsai [32] present a generic DSE framework
extending upon DESERT by supporting arbitrary analysis
tools and includes model transformations for mapping de-sign problems to intermediate and low-level formats.
TheOCTOPUS Toolset [5] uses an intermediate represen-
tation for design problem speciﬁcation and performs DSEusing integrated analysis tools. It has been successfully ap-
plied to design software-intensive embedded systems [4].
297TheGaspard Framework [15] is speciﬁcally focused on
the design of massively parallel embedded systems and uses
multilevel modeling where high-level UML models are auto-matically reﬁned to allow design space exploration to eval-uate performance characteristics through simulations.
An eﬃcient design space exploration approach was also
presented built on the FORMULA framework in [23]. The
design problem is described using domain-speciﬁc languagesand exploration is done with symbolic execution and auto-matic theorem proving by an SMT solver.
These are all compiled approaches, where thedesign prob-
lems are speciﬁed as models and model transformations areapplied to derive inputs for third party analysis tools (e.g.,
SMT or SAT solvers). These analysis tools then perform
the exploration and propagate the results back to the orig-inal model. However, as the analysis tools are usually usedas black boxes when exploring the design space, they cannotbeeasily extendedtosupportconceptuallynovelexplorationalgorithms (e.g., NSGA-II).
[28]presentsaframework fortheautomaticdeploymentof
software components to hardware architecture that uses de-sign space exploration to ﬁnd deployment alternatives thatoﬀernear-optimalreliability characteristics. Thedesignprob-lemconsistsofarchitecturemodelsannotatedwithreliability-relevant properties, while the exploration uses an evolution-
ary algorithm to ﬁnd possible alternatives. Unlike our ap-
proach, in this work (and also a follow-up paper [27]) globalconstraints are set as hard selection criteria to prevent theexploration (optimization) of invalid solutions.
Sch¨atzet al.[33] developed an interactive, incremental
process using declarative transformation rules for driving
the exploration. The rules are modiﬁed interactively (userguided)toimprovetheperformance of theexploration, whileour approach uses genetic algorithms to guide the mutationand crossover operations to ﬁnd solution models.
Multi-objective optimization in model driven engineer-
ing.Multi-objectiveoptimization techniquesarewidelyused
in Model Driven Engineering (MDE) ﬁeld [13,16,31,35]. Re-
cently, Kessentini et al.[24] proposed an MDE-based frame-
work foreasingtheadoptionofsearch-basedtechniques(such
as genetic algorithms) to MDE problems. In this work,the authors describe the logic layer of their MDE-basedframework based on previous experiences in using SBSE inhand-crafted applications. However, the realization of the
framework is only planned as future work. Moreover, it is
not clear how the proposed framework can be adopted forrule-based DSE. Etimaadi and Chaudron [13] proposed theAQOSA tool which uses a model-based approach to eval-uate component-based software architecture quality. Simi-larly to our work, AQOSA uses multi-objective evolutionary
algorithms to automatically optimize software architecture
design with regard to multiple quality objectives, such asresponse time, processor utilization, safety, etc.
Despitethepopularityofapplyingsearch-basedtechniques
for MDE problems, to the best of the authors’ knowledge,there is not existing work in the literature dealing with rule-
based DSE using multi-objective optimization techniques.
Indeed, existing work on Automatic Design Space Explo-ration(ADSE)usingmulti-objectiveoptimizationtechniquesare not rule-based DSE, and they are proposed for speciﬁcdomain problems. For example, Calborean et al.[8] pro-
posed recently the FADSE (Framework for ADSE) for DSEof computer systems using diﬀerent multi-objective search-
based algorithms. Inthis paper, theauthorscompare there-
sults producedby diﬀerent genetic algorithms for optimizingthe parameters of the Grid ALU Processor (GAP) microar-chitecture and the post-link code optimizer GAPtimize. Intheir framework, application-speciﬁc rules that describe ex-isting knowledge can be deﬁned and used as constraints to
constrain the DSE process [21]. A similar work is performed
by Bolchini et al.[7]. Bolchini et al.propose a framework
based on the multi-objective genetic algorithm NSGA-II forDSE of reliable Field Programmable Gate Array devices.
Thecontributionofourapproachoverexistingmulti-objec-
tive optimization for DSE is that our approach is generic
so that it can be extended and applied to other domains.
Moreover, our approach uses exploration rules to guide theDSE process, while constraints are used to describe the re-quirements thatmust be fulﬁlled. Furthermore, unlikeexist-ing approaches which also used the NSGA-II ( e.g.,[7,8,21,
31]), our approaches adapt the constraint-dominate strat-
egy of NSGA-II so that constraints’ fulﬁllment is described
as a top-level soft optimization objective, rather than a re-ward/penalty parameter or as a hard selection criterion.Hence, our approach can even be applied to optimize an ex-isting invalid solution with regard to the top-level objective,which is minimizing constraint violation.
6. CONCLUSIONS
In the paper, we proposed to integrate constrained multi-
objective optimization as a search strategy for rule baseddesign space exploration frameworks. In contrast to exist-ing genetic approaches for design space exploration, in ourapproach, a genetic population consists of rule executionsequences from an initial model to design candidate, con-straints are captured by model queries, objectives are cal-
culated from models or rule sequences, while crossover and
mutation operations are manipulating rule sequences.
A ﬁrst key challenge in this setup is that traditional en-
coding of populations as ﬁxed width bit vectors is unableto represent rule sequences of increasing depth, while it isvery diﬃcult or impossible to give a priori upper bounds
for feasibility checks. Moreover, unlike in most application
scenarios of genetic algorithms, crossover and mutation op-erations may derive non-executable application sequences asindividuals which must not be added to a population. As aconsequence, we had to integrate multi-objective optimiza-tiontechniquestoamodel-drivenrule-basedDSEframework
as a mapping from a rule based DSE to a genetic algorithm
proved to be infeasible.
Ourinitialexperimentsdemonstratedthatmulti-objective
optimization is an eﬀective strategy for solving rule-baseddesign exploration problems. However, using a randomly
synthesizedinitialpopulationappearstobesuboptimalchoice
in our context. Our future work will aim at investigatingother strategies for this purpose.
7. ACKNOWLEDGEMENTS
The authors would like to thank St´ ephane Vaucher for
h i sc o m m e n t so nt h i sw o r k . T h i sw o r kw a sp a r t i a l l ys u p -ported by the MONDO (EU ICT-611125) project, and theTAMOP-4.2.2.C-11/1/KONV-2012-0001 project which hasbeen supported by the European Union, co-ﬁnanced by the
European Social Fund.
2988. ADDITIONAL AUTHORS
Additional authors: Csaba Debreceni (BME Dept. of
Measurement and Information Systems
9. REFERENCES
[1] P. Baldan and B. K ¨onig. Approximating the behaviour
of graph transformation systems. In Proc. ICGT 2002 ,
volume 2505 of LNCS, pages 14–29. Springer, 2002.
[2] L. Baresi, V. Rafe, A. T. Rahmani, and P. Spoletini.
An eﬃcient solution for model checking graph
transformation systems. ENTCS, 213, 2008.
[3] L. Baresi and P. Spoletini. On the Use of Alloy to
Analyze Graph Transformation Systems. In Graph
Transformations , volume 4178 of LNCS, pages
306–320. 2006.
[4] T. Basten, M. Hendriks, N. Trˇ cka, L. Somers,
M. Geilen, Y. Yang, G. Igna, S. de Smet,
M. Voorhoeve, W. van der Aalst, et al. Model-driven
design-space exploration for software-intensiveembedded systems. In Model-Based Design of Adaptive
Embedded Systems , pages 189–244. Springer, 2013.
[5] T. Basten, E. van Benthum, et al. Model-driven
design-space exploration for embedded systems: TheOctopus toolset. In T. Margaria and B. Steﬀen,editors, Leveraging Applications of Formal Methods,
Veriﬁcation, and Validation , volume 6415 of LNCS,
pages 90–105. Springer, 2010.
[6] G. Bergmann, Z. Ujhelyi, I. R´ ath, and D. Varr´ o. A
graph query language for emf models. In Theory and
Practice of Model Transformations, FourthInternational Conference, ICMT 2011, Zurich,
Switzerland, June 27-28, 2011. Pro ceedings,L N C S
6707, pages 167–182. Springer, 2011.
[7] C. Bolchini, P. L. Lanzi, and A. Miele. A
multi-objective genetic algorithm framework for designspace exploration of reliable fpga-based systems. In
IEEE Congress on Evolutionary Computation , pages
1–8, 2010.
[8] H. Calborean, R. Jahr, T. Ungerer, and L. Vintan. A
comparison of multi-objective algorithms for theautomatic design space exploration of a superscalarsystem. In L. Dumitrache, editor, Advances in
Intelligent Control Systems and Computer Science ,
volume 187 of Advances in Intelligent Systems and
Computing , pages 489–502. Springer Berlin
Heidelberg, 2013.
[9] K. Deb, S. Agrawal, A. Pratap, and T. Meyarivan. A
fast and elitist multiobjective genetic algorithm:Nsga-ii. IEEE Transactions Evolutionary
Computation , 6(2):182–197, 2002.
[10] J. Denil, M. Jukˇ ss, C. Verbrugge, and H. Vangheluwe.
Search-based model optimization using modeltransformations. Technical report, McGill University,
Canada, 2014.
[11] O. M. dos Santos, F. L. Dotti, and L. Ribeiro.
Verifying object-based graph grammars. ENTCS,
109:125–136, 2004.
[12] S. Edelkamp, S. Jabbar, and A. Lluch-Lafuente.
Heuristic search for the analysis of graph transition
systems. In Proceedings of the Third international
conference on Graph Transformations, volume 4178 of
LNCS, pages 414–429. Springer-Verlag, 2006.[13] R. Etemaadi and M. R. Chaudron. A model-based
tool for automated quality-driven design of system
architectures. In Proceedings of the 8th European
Conference on Modelling Foundations andApplications (ECMFA’12) , pages 2–5, 2012.
[14] I. Galvao Lourenco da Silva, E. Zambon, A. Rensink,
L. Wevers, and M. Ak¸ sit. Knowledge-based graph
exploration analysis. In Fourth International
Symposium on Applications of Graph Transformationwith Industrial Relevance, AGTIVE 2011, Budapest,Hungary , LNCS 7233, pages 105–120. Springer,
October 2011.
[15] A. Gamati´ e, S. Le Beux, ´E.Piel,
 R. Ben Atitallah,
A. Etien, P. Marquet, and J.-L. Dekeyser. Amodel-driven design framework for massively parallel
embedded systems. ACM Transactions on Embedded
Computing Systems (TECS) , 10(4):39, 2011.
[16] M. Harman, S. A. Mansouri, and Y. Zhang.
Search-based software engineering: Trends, techniquesand applications. ACM Comput. Surv. ,
45(1):11:1–11:61, Dec. 2012.
[17]´A. Heged ¨us,´A. Horv´ath, I. R´ ath, M. C. Branco, and
D. Varr´o. Quick ﬁx generation for DSMLs. In IEEE
Symposium on Visual Languages and Human-Centric
Computing, VL/HCC 2011 . IEEE Computer Society,
09/2011 2011.
[18]´A. Heged ¨us,´A. Horv´ath, I. R´ ath, and D. Varr´ o. A
model-driven framework for guided design space
exploration. In 26th IEEE/ACM International
Conference on Automated Software Engineering (ASE
2011), Lawrence, Kansas, USA, 11/2011 2011. IEEE
Computer Society, IEEE Computer Society.
[19]´A. Heged ¨us,´A. Horv´ath, and D. Varr´ o. Towards
guided trajectory exploration of graph transformationsystems. Electronic Communications of the EASST,
Petri Nets and Graph Transformations 2010 , 40,
08/2011 2011.
[20]´A. Horv´ath and D. Varr´ o. Dynamic constraint
satisfaction problems over models. Software and
Systems Modeling, 11:385–408, 2012 2012.
[21] R. Jahr, H. Calborean, L. Vintan, and T. Ungerer.
Boosting design space explorations with existing orautomatically learned knowledge. In J. Schmitt,editor, Measurement, Modelling, and Evaluation of
Computing Systems and Dependability and FaultTolerance , volume 7201 of Lecture Notes in Computer
Science, pages 221–235. Springer Berlin Heidelberg,
2012.
[22] H. Jain and K. Deb. An evolutionary many-objective
optimization algorithm using reference-point based
non-dominated sorting approach, part ii: Handling
constraints and extending to an adaptive approach.Evolutionary Computation, IEEE Transactions on ,
2013.
[23] E. Kang, E. K. Jackson, and W. Schulte. An approach
for eﬀective design space exploration. In Monterey
Workshop, pages 33–54, 2010.
[24] M. Kessentini, P. Langer, and M. Wimmer. Searching
models, modeling search: On the synergies of sbse andmde. In CMSBSE@ICSE , pages 51–54, 2013.
299[25] M. Kessentini, H. Sahraoui, M. Boukadoum, and
O. Omar. Search-based model transformation by
example. Software and Systems Modeling ,
11(2):209–226, 2012.
[26] B. K ¨onig and V. Kozioura. Counterexample-guided
abstraction reﬁnement for the analysis of graph
transformation systems. In TACAS, pages 197–211,
2006.
[27] I. Meedeniya, A. Aleti, and L. Grunske.
Architecture-driven reliability optimization withuncertain model parameters. Journal of Systems and
Software , 85(10):2340 – 2355, 2012.
[28] I. Meedeniya, B. Buhnova, A. Aleti, and L. Grunske.
Reliability-driven deployment optimization for
embedded systems. Journal of Systems and Software ,
84(5):835–846, 2011.
[29] S. Neema, J. Sztipanovits, G. Karsai, and K. Butts.
Constraint-based design-space exploration and modelsynthesis. In R. Alur and I. Lee, editors, Embedded
Software , volume 2855 of LNCS, pages 290–305.
Springer, 2003.
[30] A. Rensink. The GROOVE simulator: A tool for state
space generation. In Applications of Graph
Transformations with Industrial Relevance (AGTIVE) ,
volume 3062 of LNCS, pages 479–485. Springer, 2004.
10.1007/978-3-540-25959-6
40.
[31] H. Saada, M. Huchard, C. Nebut, and H. A. Sahraoui.
Recovering model transformation traces using
multi-objective optimization. In ASE, pages 688–693,
2013.[32] T. Saxena and G. Karsai. MDE-based approach for
generalizing design space exploration. In D. Petriu,N. Rouquette, and Ø. Haugen, editors, Model Driven
Engineering Languages and Systems, volume 6394 ofLNCS, pages 46–60. Springer, 2010.
[33] B. Schatz, F. Holzl, and T. Lundkvist. Design-space
exploration through constraint-basedmodel-transformation. In Engineering of Computer
Based Systems (ECBS) , pages 173 –182, March 2010.
[34]´A. Schmidt and D. Varr´ o. CheckVML: A tool for
model checking visual modeling languages. InP. Stevens, J. Whittle, and G. Booch, editors, Proc.
UML 2003: 6th International Conference on theUniﬁed Modeling Language , volume 2863 of LNCS,
pages 92–95, San Francisco, CA, USA, October 20-24
2003. Springer.
[35] M. Shousha, L. C. Briand, and Y. Labiche. A uml/spt
model analysis methodology for concurrent systems
based on genetic algorithms. In MoDELS , pages
475–489, 2008.
[36] Z. Ujhelyi, G. Bergmann, A. Heged ¨us, A. Horv´ ath,
B. Izs´o, I. R´ath, Z. Szatm´ ari, and D. Varr´ o.
EMF-IncQuery: An integrated development
environment for live model queries. Science of
Computer Programming , (0):–, 2014.
[37] Y. Zhang. Multi-Objective Search-based Requirements
Selection and Optimisation . Phd. thesis, King’s
College London, UK, 2010.
300