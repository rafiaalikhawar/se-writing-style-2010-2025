Automatic Recovery of Statecharts from Procedural Code
Moria Abadi
Blavatnik School of Computer Science
Tel Aviv University
69978 Tel Aviv, Israel
moriaabadi@gmail.comYishai A. Feldman
IBM Research – Haifa
Haifa University Campus, Mount Carmel
31905 Haifa, Israel
yishai@il.ibm.com
ABSTRACT
We have developed a static-analysis algorithm that extracts
statecharts from procedural implementations of state ma-
chines. The extracted statecharts are semantically-equiv-
alent to the original program, and can be used for further
development instead of the procedural code. We have imple-
mented this algorithm in a tool called StatRec. We report
on the results of running StatRec on a number of examples,
including an implementation of the TCP protocol.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance,
and Enhancement— Restructuring, reverse engineering, and
reengineering
General Terms
Algorithms
Keywords
State machines, statecharts, static analysis
1. INTRODUCTION
Finite-state machines are ubiquitous in computing, espe-
cially in reactive and embedded systems. Existing code con-
tains many instances of ﬁnite-state machines, implemented
procedurally. Modern development environments enable the
description of ﬁnite-state machines as statecharts [5], which
provide a visual expression of state machines as well as
strong and intuitive generalizations that make them expo-
nentially more concise and thus easier to maintain. How-
ever, the beneﬁts of these visual formalisms are not avail-
able for existing procedural implementations of ﬁnite-state
machines.
As part of our investigation of how to improve the devel-
opment of reactive systems, we have previously suggested
the need for refactoring tools for statecharts [3], including
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE ’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$10.00.refactorings that combine modiﬁcations of code and of stat-
echarts [2]. The latter paper presents a systematic, but still
manual, way to convert a procedural implementation of a
ﬁnite-state machine into a statechart. Here we present Stat-
Rec, a tool that performs this transformation automatically.
The resulting statechart is executable and preserves the se-
mantics of the original program. Further development can
be done on the extracted statechart instead of on the pro-
cedural implementation of the state machine. In particular,
the statechart can be further refactored using the proposed
statechart refactoring tools.
StatRec is based on a language-independent internal rep-
resentation [1], and is in principle available for every lan-
guage from which there is a path to that representation.
These currently include Java, but not yet C/C++. We
therefore had to translate the examples we report on in this
paper manually from C to Java. The translation was as lit-
eral as possible, to the extent of including some C idioms
that are not natural to Java. When C/C++ can be trans-
lated to our internal representation, this manual step will
not be necessary.
2. A FIRST EXAMPLE
The example of Figure 1 is adapted from a textbook on
software development with statecharts [6].1This example
describes a bomb detonation timer, which has two states.
In the setting state, the user can set the timer (using the
Up and Down switches) and arm the bomb (using the Arm
switch). In the timing state, the timer counts down the
seconds until detonation. (Timer ticks appear ten times a
second; the attribute fine_time is 0 on the full second.)
However, in this state the user can enter a binary code using
the Up and Down switches, and press Arm to defuse the
bomb if the code is correct.
The statechart of Figure 2 was generated from this code by
the StatRec tool. The two states have been identiﬁed, as well
as the transitions between them, including self-transitions.
Each transition is labeled by the event that causes it, the
guard that speciﬁes the conditions under which it is taken
(in brackets, if any), and the actions executed when the
transition is taken (following a slash). In this example, it
was necessary to create an extra state ( timing1 ), because
one of the transitions has an associated action that modiﬁes
the value of me.timeout , which is used in the guard of a
subsequent transition. The timing1 state has an entry ac-
tion, which is executed whenever the state is entered. The
1The full example as translated to Java is available from the
authors.Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASE’12, September 3–7, 2012, Essen, Germany
Copyright 2012 ACM 978-1-4503-1204-2/12/09 ...$15.00
238
1public void setting(Bomb1 me, Event e) {
2 switch (e.sig) {
3 case UP_SIG:
4 if (me.timeout < 60) ++me.timeout;
5 break;
6 case DOWN_SIG:
7 if (me.timeout > 1) -me.timeout;
8 break;
9 case ARM_SIG:
10 me.code = 0;
11 me.state = TIMING_STATE;
12}}
13public void timing(Bomb1 me, Event e) {
14 switch (e.sig) {
15 case UP_SIG:
16 me.code <<= 1; me.code |= 1; break;
17 case DOWN_SIG:
18 me.code <<= 1; break;
19 case ARM_SIG:
20 if (me.code == me.defuse)
21 me.state = SETTING_STATE;
22 break;
23 case TICK_SIG:
24 if (((TickEvt) e).fine_time == 0) {
25 -me.timeout;
26 if (me.timeout == 0) {
27 System.out.println("BOOM!!!");
28 System.exit(0);
29}}}}
Figure 1: A procedural ﬁnite-state machine.
Bomb 
setting Up/ if (me.timeout < 60)    ++me.timeout; Down/ if (me.timeout > 1)    --me.timeout; 
timing 
timing1 
--me.timeout; 
[me.timeout == 0]/ 
System.out.println("BOOM!!!"); System.exit(0); timing0 Tick/ [((TickEvt) e).fine_time == 0] 
[else] Arm[me.code == me.defuse]/ 
me.state = SETTING_STATE; 
Down/ 
me.code <<= 1; 
Up/ 
me.code <<= 1; me.code |= 1; Arm/ 
me.code = 0; me.state = TIMING_STATE; 
Figure 2: The statechart generated for the program
of Fig. 1.
entry action contains the common part of the code that is
executed upon the occurrence of the Tick event when the
event’s fine_time is 0 (line 25 of Figure 1). The test for a
zero timeout (line 26) determines which transition is subse-
quently taken; the code that executes when the condition istrue appears on the transition. Because of the need to cre-
ate an additional state, StatRec packaged the two sub-states
that represent the timing procedure in a super-state, thus
encapsulating them in a single abstract unit.
This example demonstrates some of the issues in extract-
ing a state diagram from procedural code. These include
identifying the state transitions, the events associated with
each one, and other conditions that need to be made into
transition guards. In addition, it is necessary to identify
the correct placement for pieces of the code; these could be
placed in entry actions if they are executed unconditionally,
or on the appropriate transition otherwise. Tests that de-
pend on values that are modiﬁed by preceding actions in
the same transition are called dynamic choices , while those
that can be computed on entry are static choices . Only the
former require new states to be added.
3. CASE STUDY: THE TCP PROTOCOL
In order to evaluate StatRec on larger examples, we used it
to extract statecharts from the implementation of the TCP
protocol from a textbook on the subject [4]. This is a com-
plete working implementation of the protocol written in C
and manaully converted to Java for use by StatRec. Based
on our experience, we believe that this code is typical of
procedural state-machine implementations. It freely mixes
actions and tests, makes some state changes in called pro-
cedures, and even makes calls from one state procedure to
another.
The TCP protocol maintains a set of TCP connections;
each connection has receiver and transmitter components,
responsible for accepting and sending messages, respectively.
These are implemented as separate state machines, but they
are not independent. In the implementation we used for our
case study, the state of the transmitter component is some-
times modiﬁed directly by state procedures of the receiver,
as an external state change; that is, a change not made as
a response to some event. In addition, every connection has
its own state, but a central component opens and closes con-
nections, allocating connection objects from a common pool.
Unused connections in the pool are in the free state, and
exit this state via external state changes.
The receiver component is invoked from the main loop
once the speciﬁc connection for an incoming packet has been
identiﬁed. No events are distinguished upon the arrival of a
new packet; the state procedures examine various ﬁelds of
the incoming packet in order to decide what to do. StatRec
therefore creates a single packet event. Several external state
changes are applied to the receiver component, necessitat-
ing the creation of the triggered operations To_tcpsynsent ,
To_tcpclosed , etc.
The high-level statechart of the TCP receiver component
is shown in Figure 3. In this view, the internal details of
the super-states have been hidden; the user can selectively
zoom into each as desired.
The generated statecharts contain a lot of text in the tran-
sitions, mostly in the associated actions. This may some-
times obscure the structure of the statechart. In such cases,
the Extract Transition Method refactoring [3], which re-
places an action consisting of a set of statements with a
call to a newly-generated method, could be used to reduce
the clutter. We applied this refactoring manually in Figure
3. Large conditions in guards could similarly be extracted
into methods. (The size of the code and conditions does not239TcpReceiving 
tcptimewait 
enterexit_60 tcpsynrcvd 
enterexit_74 enterexit_71 enterexit_68 tcpclosewait packet/tcpclosewait_process() 
free tcpsynsent 
enterexit_86 enterexit_83 enterexit_80 
tcpfin1 
enterexit_104 enterexit_101 
enterexit_98 tcplisten packet/tcplisten_process() tcpclosed 
packet/ 
tcpreset(pep);
result= SYSERR;tcpfin2 
enterexit_89 tcplastack packet/tcplastack_process() tcpestablished 
enterexit_77 tcpclosing 
enterexit_95 enterexit_92 To_free 
To_tcplastack To_tcplisten To_tcpsynsent To_tcpfin1 
To_tcpclosed 
enterexit_60 enterexit_74 enterexit_71 enterexit_68 
enterexit_86 enterexit_83 enterexit_80 
enterexit_104 enterexit_101 
enterexit_98 enterexit_89 enterexit_77 
enterexit_95 enterexit_92 Figure 3: The high-level statechart of the TCP receiver component.
1int tcpsynsent(Tcb ptcb, Ep pep) {
2 Ip pip = (Ip)pep.ep_data;
3 Tcp ptcp = (Tcp)pip.ip_data;
4 if ((ptcp.tcp_code & TCPF_ACK) != 0 &&
5 (ptcp.tcp_ack - ptcb.tcb_iss <= 0 ||
6 ptcp.tcp_ack - ptcb.tcb_snext > 0))
7 return tcpreset(pep);
8 if ((ptcp.tcp_code & TCPF_RST) != 0) {
9 ptcb.tcb_state = TCPS_CLOSED;
10 ptcb.tcb_error = TCPE_RESET;
11 TcpAttemptFails++;
12 tcpkilltimers(ptcb);
13 signal(ptcb.tcb_ocsem);
14 return OK;
15 }
16 if ((ptcp.tcp_code & TCPF_SYN) == 0)
17 return OK;
18 ptcb.tcb_swindow = ptcp.tcp_window;
19 ptcb.tcb_lwseq = ptcp.tcp_seq;
20 ptcb.tcb_rnext = ptcp.tcp_seq;
21 ptcb.tcb_cwin = ptcb.tcb_rnext + ptcb.tcb_rbsize;
22 tcpacked(ptcb, pep);
23 tcpdata(ptcb, pep);
24 ptcp.tcp_code &= ~TCPF_FIN;
25 if ((ptcb.tcb_code & TCPF_SYN) != 0)
26 ptcb.tcb_state = TCPS_SYNRCVD;
27 else {
28 TcpCurrEstab++;
29 ptcb.tcb_state = TCPS_ESTABLISHED;
30 signal(ptcb.tcb_ocsem);
31 }
32 return OK;
33}
Figure 4: The tcpsynsent state procedure [4].
pose a problem for the analysis, but makes it diﬃcult for
developers to understand the statechart unless abstracted
into separate methods.)
To demonstrate the detailed results of the algorithm, we
use the synsent state, extracted from the tcpsynsent pro-
cedure, shown in Figure 4. The part of the statechart com-
puted from this state procedure appears in Figure 5. Theinitial state of the synsent super-state, synsent0 , appears
in the left part of the ﬁgure. A transition labeled packet
leads from it to synsent1 , which contains (as an entry ac-
tion) the two assignments from lines 2–3 of the code. These
are executed unconditionally, and their values are used in
subsequent tests and actions.
The body of the tcpsynsent procedure contains four tests,
all of which are used in the determination of the target state.
These make for ﬁve possible behaviors. However, two of
these have actions that aﬀect the ptcp object prior to the
test that uses it (line 25). A new state, synsent2 , had to be
created to accomodate these actions.
The TCP receiver component has 12 states (including
synsent ), but the implementation has only 11 state pro-
cedures, since the free state has no behavior associated
with it. A total of 266 lines of Java code were analyzed
to create the ﬁnal statechart, which has 35 states, grouped
in 12 super-states. The additional 23 states were required
by dyanmic choices. One for each of the 11 state proce-
dures was required because each starts with assignments to
two variables that hold the IP and TCP packets, and 12 for
other side eﬀects. In addition, 17 static choices were created.
Figure 6 shows the generated high-level statechart for
the TCP transmitter component. The transmitter is im-
plemented using four state procedures, with external state
changes initiated by the receiver. A total of 122 lines of code
were analyzed, creating 4 dynamic and 2 static choices.
The textbook from which this code was taken [4] pro-
vides state diagrams for the receiver and transmitter com-
ponents. The statecharts generated by StatRec are similar
but not identical to those shown in the book. For example,
the transmitter state diagram in the book has a transition
from retransmit totransmit , triggered by an event called
“ACK arrives.” In the code, this transition is implemented
as an external change of the transmitter’s state by the re-
ceiver, when the latter receives an acknowledgment. Also,
the book shows the transmitter as moving from idletotrans-
miton the event “send.” However, the tcpxmit procedure,
which implelements the transmit state, also checks for this
event, and may change the state to persist under certain240synsent2 
  ptcb.tcb_swindow = ptcp.tcp_window;  ... [else] closed synsent1 
 pip = (Ip)pep.ep_data; ptcp = (Tcp)pip.ip_data;
established [else] [(ptcp.tcp_code & TCPF_RST) != 0]/ 
ptcb.tcb_state = TCPS_CLOSED;ptcb.tcb_error = TCPE_RESET;TcpAttemptFails++; tcpkilltimers(ptcb);signal(ptcb.tcb_ocsem);result= OK;
[else] 
synrcvd synsent 
[(ptcp.tcp_code & TCPF_SYN) == 0]/ 
result= OK;[((ptcp.tcp_code & TCPF_ACK) != 0) && (ptcp.tcp_ack  - ptcb.tcb_iss <= 0 || ptcp.tcp_ack - ptcb.tcb_sne xt > 0)]/ 
result= tcpreset(pep);
packet 
[else]/ 
TcpCurrEstab++; ptcb.tcb_state = TCPS_ESTABLISHED;
 signal(ptcb.tcb_ocsem);result= OK;[(ptcb.tcb_code & TCPF_SYN) != 0]/ 
ptcb.tcb_state = TCPS_SYNRCVD;result= OK;Figure 5: The part of the TCP statechart showing transitions emanating from the synsent state.
Tx 
tcprexmit tcpxmit 
enterexit_13 enterexit_10 tcpidle 
enterexit_19 enterexit_16 tcppersist Delete/ result= OK;
Persist/ tcppersist_process_persist() Send/ tcppersist_process_send() Retransmit/ result= OK;To_tcpidle To_tcpxmit 
enterexit_13 enterexit_10 enterexit_19 enterexit_16 
Figure 6: The high-level statechart of the TCP
transmitter component.
conditions. This violates the standard semantics of ﬁnite
state machines, in which one event cannot cause two suc-
cessive transitions. These examples highlight the diﬀerences
between a state diagram provided for documentation or di-
dactic purposes and an executable statechart that captures
the full behavior of the program.
4. DISCUSSION
We presented StatRec, a tool that extracts statecharts
from procedural implementations of state machines. The
statecharts recovered by StatRec are relatively ﬂat, and do
not take full advantage of the capabilities of the statechart
formalism. Once statecharts are recovered, however, they
can be further refactored by combining states into super-
states, extracting parallel components, and extracting sub-
states into new classes [3].
StatRec is limited by the amount of application knowl-
edge embedded in the code it analyzes. We have proved
that the resulting statechart preserves the semantics of the
original program (space restrictions prevent inclusion of the
proof here). However, the generated statechart is not always
the one that a developer would have chosen when creating anew statechart without reference to an existing implemen-
tation. Even the TCP example shown above [4], which was
designed as an example of how to program communication
protocols in C, exhibits many problems for a reengineering
tool. Often, the code does not contain enough information
about the states in which the state machine can be when an
external state change is applied. By using such application
knowledge, the developer can refactor the generated state-
chart to reﬂect better the application’s semantics. Also, the
procedural code can be refactored before applying the Stat-
Rec transformation, in order to generate simpler statecharts;
for example, by grouping all side-eﬀecting operations in the
code, in order to eliminate unnecessary dynamic choices. In
this way, procedural code can be turned into a modular and
maintainable object-oriented form that takes advantage of
the visual statechart formalism to describe state-based be-
havior.
5. REFERENCES
[1] A. Abadi, R. Ettinger, and Y. A. Feldman. Improving
slice accuracy by compression of data and control ﬂow
paths. In Proc. 7th Joint Mtg. European Software
Engineering Conf. (ESEC) and ACM Symp.
Foundations of Software Engineering (FSE) , Aug. 2009.
[2] M. Abadi and Y. A. Feldman. Refactoring in multiple
representations: Code and statecharts. In Third
Workshop on Refactoring Tools , Oct. 2009.
[3] M. Abadi and Y. A. Feldman. Refactoring of
statecharts. In Proc. Seventh Conf. Next-Generation
Information Technologies and Systems (NGITS) , June
2009.
[4] D. E. Comer, D. L. Stevens, and M. Evangelista.
Internetworking with TCP/IP Vol. II: Design,
Implementation, and Internals . Prentice Hall, 4th
edition, 2004.
[5] D. Harel. Statecharts: A visual formalism for complex
systems. Science of Computer Programming , 8:231–274,
1987.
[6] M. Samek. Practical UML Statecharts in C/C++:
Event-Driven Programming for Embedded Systems .
Newnes, 2nd edition, 2008.241