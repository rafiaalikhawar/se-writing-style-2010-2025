See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/266654073
Z3-str: a z3-based string solver for web application analysis
Article  · August 2013
DOI: 10.1145/2491411.2491456
CITATIONS
169READS
2,038
3 author s, including:
Xiang yu Zhang
Taiyuan Univ ersity of T echnolog y
312 PUBLICA TIONS    11,649  CITATIONS    
SEE PROFILE
Vijay Ganesh
Geor gia Instit ute of T echnolog y
171 PUBLICA TIONS    6,668  CITATIONS    
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Vijay Ganesh  on 03 May 2015.
The user has r equest ed enhanc ement of the do wnlo aded file.Z3-str: A Z3-Based String Solver for Web Application
Analysis
Yunhui Zheng Xiangyu Zhang
Department of Computer Science, Purdue
University, USA
{zheng16,xyzhang}@cs.purdue.eduVijay Ganesh
Electrical and Computer Engineering, University
of Waterloo, Canada
vganesh@uwaterloo.ca
ABSTRACT
Analyzing web applications requires reasoning about strin gs
and non-strings cohesively. Existing string solvers eithe r
ignore non-string program behavior or support limited set
of string operations. In this paper, we develop a general
purpose string solver, called Z3-str, as an extension of the
Z3 SMT solver through its plug-in interface. Z3-str treats
strings as aprimitivetype, thusavoidingtheinherentlimi ta-
tionsobservedinmanyexistingsolversthatencodestrings in
terms of other primitives. The logic of the plug-in has three
sorts, namely, bool, int and string. The string-sorted term s
include string constants and variables of arbitrary length ,
with functions such as concatenation, sub-string, and re-
place. The int-sorted terms are standard, with theexceptio n
of the length function over string terms. The atomic formu-
las are equations over string terms, and (in)-equalities ov er
integer terms. Not only does our solver have features that
enable whole program symbolic, static and dynamic anal-
ysis, but also it performs better than other solvers in our
experiments. The application of Z3-str in remote code exe-
cution detection shows that its support of a wide spectrum
of string operations is key to reducing false positives.
Categories and Subject Descriptors
D.2.4 [Software Engineering ]: Software/Program Veriﬁ-
cation; D.2.5 [ Software Engineering ]: Testing and De-
bugging
General Terms
Veriﬁcation, Algorithms
Keywords
String Analysis, String Constraint Solver, Web Applicatio n
1. INTRODUCTION
Constraint solving plays an important role in web pro-
gram analysis for the purpose of test generation for coverag e
Permission to make digital or hard copies of all or part of thi s work for
personal or classroom use is granted without fee provided th at copies are
not made or distributed for proﬁt or commercial advantage an d that copies
bear this notice and the full citation on the ﬁrst page. To cop y otherwise, to
republish, to post on servers or to redistribute to lists, re quires prior speciﬁc
permission and/or a fee.
ESEC/FSE ’13, August 18-26, 2013, Saint Petersburg, Russia
Copyright 13 ACM 978-1-4503-2237-9/13/08 ...$15.00.[22], bug ﬁnding [3, 32] and vulnerability detection [17, 5] .
The reason is that solver-based analysis tools enable more
precise analysis with the ability to generate interesting b ug-
revealing inputs. Furthermore, solver-based analysis too ls
are often more robust and easier to build than otherwise.
While most powerful constraint solvers like Z3 [19] support
a rich input language for traditional program analysis, the y
typicallydon’tsupportcombinedlogicsoverstringsandno n-
string operations essential for web program analysis.
In this paper, we present Z3-str, a satisﬁability solver tha t
supports a rich combined logic over strings and non-string
operations aimed atsymbolic, static anddynamicanalysis o f
web applications. Z3-str is built as an extension of the pow-
erful Z3 SMT solver [19] using its plug-in interface. Z3-str
treats strings as a primitive type, thus avoiding the inhere nt
limitations observed in many existing string solvers that e n-
code strings in terms of other primitives. The supported
logic has three sorts, namely, bool, int and string. The
string-sorted terms include string constants and variable s
of arbitrary length, with functions such as concatenation,
sub-string, and replace. The int-sorted terms are standard ,
with the exception of the length function over string terms.
The atomic formulas are equations over string terms, and
(in)-equalities over integer terms. Formulas are construc ted
in the usual way through boolean combination of atomic
formulas. Z3-str takes a formula in this logic as input, and
decides if it is satisﬁable.
Many string solvers such as HAMPI [17], DPRLE [13],
and Rex [27] support only string operations. However, such
logics are not suﬃciently expressive for many program anal-
ysis since non-string operations are also widely used in web
applications. More importantly, the string and non-string
operations interact in subtle ways leading to program er-
rors that are hard for humans to ﬁnd without automation.
Finally, a string-only analysis will likely miss pure integ er
or string-to-integer constraints (e.g., length of string) thus
resulting in path constraints that are not precise enough,
leading to false positives.
Manyrecentworks[22, 8, 26, 21]onstringsolvers havead-
dressed exactly this problem, namely, how to eﬃciently rea-
sonaboutstringandnon-stringconstraintsgeneratedduri ng
analysis of web applications. A key feature of all these ap-
proaches to string solvers is to transform both string and
non-string constraints to a uniform domain.
Some solvers [22, 8] (including early versions of Kaluza)
convert strings into bit-vectors, which are also used to rep -
resent integer constraints. The resulting constraints can be
solved using an existing SMT solver. However, to convert aPermission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from Permissions@acm.org.
ESEC/FSE’13 , August 18–26, 2013, Saint Petersburg, Russia
Copyright 2013 ACM 978-1-4503-2237-9/13/08...$15.00
http://dx.doi.org/10.1145/2491411.2491456
114string into a bit-vector, its length has to be decided before -
hand as a prerequisite of the bit-vector encoding. Hence,
current techniques have to enumerate the possible length
values and then encode the string constraints based on the
concrete length values. The encoded constraints are then
passedtoanSMTsolver. Thisrequiresencodingrepetitivel y
and querying the SMT solver many times. Consequently,
these techniques are more suitable for dynamic analysis,
wherein string length values can be easily computed from
concrete execution paths. However, for static analysis tec h-
nique, such concretization-based solvers may be either too
ineﬃcient or even non-terminating. The reason is that dur-
ing static analysis of a program, the range of lengths of a
string term in the program may not be precisely knowable.
By contrast, our algorithm is designed in an incremen-
tal fashion to follow the plugin interaction protocol of Z3,
leveraging its power of incremental solving. Given a set of
string equations, the algorithm systematically breaks dow n
constant strings into sub-strings and splits variables to s ub-
variables to denote their sub-structures, until the break-
down is so ﬁne-grained that the variables are bounded with
constant strings/characters. Any implied length constrai nts
are checked internally by Z3 for consistency with the given
input length constraints.
Contributions . Our contributions include the following:
•We develop a novel string solver that has a rich input
language supporting string and non-string terms and
operations.
•Sinceitisunknownifthesatisﬁabilityproblemofstring
equations with length constraints in general is decid-
able, we carefully reﬁne the problem scope so that we
can develop a sound and terminating algorithm. Our
system is complete for positive equations and length.
Wedohandledis-equations, butwehaven’testablished
completeness for it. We believe the reﬁned problem
deﬁnition is suﬃcient for constraints generated from
real-world web application.
•We empirically compare Z3-str with other solvers [22,
33] and show that our solver out-performs others in
terms of eﬃciency, in addition to providing a richer in-
put language and supporting both static and dynamic
analysis. We also apply the solver in remote code ex-
ecution vulnerability detection. Our experimental re-
sults show that the capability of modeling commonly
usedstringoperationsis keytoreducingfalse positives.
•Z3-str is publically available at: http://www.cs.purdue.
edu/homes/zheng16/str [1].
•Z3-strhasbeensuccessfullyevaluatedbytheESEC/FSE
artifact evaluation committee and found to meet ex-
pectations.
2. MOTIV ATING EXAMPLE
In this section, we use a piece of php script as an exam-
ple to demonstrate the limitations of existing solvers and
motivate our approach.
The second column of the table in Fig. 1 shows the ex-
ample php script. In lines 1-13, $rolecan be assigned to
one of four diﬀerent strings according to the value of the
session variable $SESSION[’usergroup’] . Lines 14-16 calculate
the total cost based on the variable $POST[’price’] submit-
ted by the client. And ﬁnally, in lines 17-19, if the cost is
larger than 500, a function notifyAdmin() is invoked for the
user whose $rolestarts with the character ’n’.Tosuccessfully invokethefunction notifyAdmin() , theinput
and session variables have to satisfy certain branch condi-
tions at lines 2 ,3,9,17 and 18, where both string and non-
string constraints are involved. More importantly, the str ing
condition at line 18 is actually related to but not control de -
pendent on the integer conditions at lines 2 ,3 and 9. There-
fore, we have to reason about the string and non-stringparts
together since they are closely correlated with each other.
Assume we are interested in identifying the variable valu-
ations that drive the execution to the statement where noti-
fyAdmin() is invoked. Let us compare the ways that existing
solvers handle this problem.
STP [10] is a SMT constraint solver. It supports integer
and boolean operations but does not support strings. Part
of the string equivalence problem could be solved by using
integer ids to denote constant strings, as shown by the mod-
iﬁcation in lines 4 ,6,10 and 12 marked in green in the STP
column of the table in Fig. 1. However, more complex string
operations such as concatandsubstr()are not natively sup-
ported so that we have to ignore the predicate at line 18.
Therefore, the satisfying solution got from STP states the
function will be called as long as the price posted makes the
total cost larger than 500, which is imprecise.
HAMPI[17] is one of the most popular open-source string
solvers. Itwas originally designed for detectionofSQLinj ec-
tion vulnerabilities. Itwas thenwidelyused inotherweb ap -
plicationanalysis[5, 22, 25]. Itmodelsstringsascontext free
grammars (CFG) and supports regular expressions. String
concatenation is modeled based on the CFG. It can handle
queries about whether a string expression is in a regular ex-
pression or a CFG. However, it does not model arithmetic
and boolean operations. More importantly, HAMPI is path
insensitive, meaning that it is not able to reason about path
feasibility. Thus, in Fig. 1, statements related to the arit h-
metic computation as well as the path conditions, which are
marked in red, are not supported and will be ignored. The
grammar rule at line 13 is generated by HAMPI, modeling
the possible values of $role. Consequently, HAMPI deter-
mines that notifyAdmin() will always be executed. Besides,
HAMPI doesn’t support direct string comparison and other
string operators like indexof() andsubstr().
Other solvers [9, 24, 13, 14, 27, 31, 26, 2, 21] that work
exclusively in the string domain have similar limitations.
Kaluza is the core of a JavaScript dynamic test genera-
tion framework [22]. It extends both STP and HAMPI, and
supports int, boolean and string constraints generated fro m
an execution path. Kaluza leverages HAMPI’s frontend to
model strings as bit-vectors so they can be reasoned uni-
formly with other types of constraints in STP. However, a
pre-requesite is that the lengths of bit-vectors have to be
known before-hand. Hence, before solving the string val-
ues, Kaluza ﬁrst tries to ﬁnd a satisfying solution to string
lengths. Then it encodes string constraints based on the
concrete length values. However, string lengths vary from
path to path, and sometimes may be unknown in the static
analysis context. For example, in Fig. 1, the length of $role
can change in diﬀerent paths. Hence, multiple paths cannot
be encoded. To use Kaluza, one has to have a path explo-
ration engine and perform per-path encoding. Even given
a path, if there are multiple satisfying solutions of length
constraints, the solver has to enumerate individual concre te
solutions and encode separately. This suggests that the STP
solver needs to be frequently queried, inducing high cost.115 PHP  SCRIPT  STP HAMPI KALUZA  PISA 
01 $g =$_SESSION['usergroup']; $g =$_SESSION['usergroup']; $g =$_SESSION['usergroup'];  $g =$_SESSION['usergroup']; $g =$_SESSION['usergroup']; 
02 if ($g <3){ if ($g <3){ if ($g <3){ if ($g <3){ if ($g <3){
03   if ($g == 0)  if ($g == 0)  if ($g == 0)  if ($g == 0)  if ($g == 0)
04   $role ="visitor";   $role =ID_1;    $role ="visitor";   $role ="visitor"; 
05   else   else   else   else   else 
06   $role ="new";   $role =ID_2;    $role ="new";   $role ="new"; 
07 } } } } }
08 else { else { else { else { else {
09   if ($g == 9)  if ($g == 9)  if ($g == 9)  if ($g == 9)  if ($g == 9)
10   $role ="admin";   $role =ID_3;    $role ="admin";   $role ="admin"; 
11   else   else   else   else   else 
12   $role =$_SESSION[‘r’];  $role =ID_var; }  $role =$_SESSION[‘r’];  $role =$_SESSION[‘r’]; 
13 } } $role="visitor"|"new"|”admin"|$_SESSION[‘r’]; } }
14 $p =$_POST['price']; $p =$_POST['price']; $p =$_POST['price']; $p =$_POST['price']; $p =$_POST['price']; 
15 $total =(1 +$taxRate) * $p; $total =(1 +$taxRate) * $p; $total =(1 +$taxRate) * $p; $total =(1 +$taxRate) * $p; $total =(1 +$taxRate) *$p; 
16 $total  =$total  +$ship;  $total  =$total  +$ship;  $total  =$total  +$ship;  $total  =$total  +$ship;  $total  =$total  +$ship; 
17 if ($total >500 ) if ($total >500 ) if ($total >500 ) if ($total >500 ) if ($total >500 )
18   if (substr($role, 0, 1)==“n” ) if (substr($role, 0, 1)==“n” )  if (substr($role, 0, 1)==“n” )  if (substr($role, 0, 1)==“n” )  if (substr($role, 0, 1)==“n” )
19   notifyAdmin();   notifyAdmin();   notifyAdmin();   notifyAdmin();   notifyAdmin(); 
   Not supported  Modification needed 

Have to 
explore 
concrete 
paths one 
by one  
Figure 1: Existing solver comparison.
1 ...
2 if (substr($x,0,3)==’abc’) {
3 if ...
4 } else { ... }
Figure 2: Example for Search Space Elimination
Furthermore, building the string solver outside the un-
derlying SMT solver prevents the SMT solver from pruning
search space by leveraging the string solving results. Con-
sider the example in Fig. 2. Assume the string comparison
at line 2 is UNSAT. With the separated design, the compar-
ison is invisible to the path exploration engine so that the
engine has to explore both branches and the paths inside the
branches. If the string solver is built inside the SMT solver
like in our proposed design, the SMT solver can easily avoid
exploring the paths involving the true branch.
A few recent solvers [8, 21] work in a way very similar to
Kaluza and thus have the same limitations. They are mostly
used in the context of dynamic test generation or symbolic
executioninwhichindividualpathsareexplored, andcanno t
be directly applied in static analysis. Some of them do not
support certain important operations. For example, Kaluza
has very limited support of replace, demanding hints from
concrete execution traces.
PISA[26] is theﬁrst path-andindex-sensitivestringsolve r
that is applicable for static analysis. It’s a part of a com-
mercial tool and the source is not publically available. It
supports int, boolean and string operations by translating
them all into a third party language M2L(Str). However,
its expressiveness for arithmetic operations is restricte d due
to the limitations of M2L. It does not support binary op-
erations between two variables since PISA requires at least
one of them is constant. Therefore, the statements in lines
15,16 are not supported and the predicate at line 17 may
not be correctly modeled. As a result, the reachability anal -
ysis is incomplete. Furthermore, it doesn’t support numeri c
multiplications and divisions.
From the above discussion, we make two observations.
First, reasoning about both strings and non-strings simul-
taneously is needed. Second, existing techniques aiming at
solving string and no-string constraints together fall sho rt as
they rely on other theories (e.g bit-vector) or languages (e .g.
M2L), inheriting their limitations. Hence, we aim todevelo p
an independent, more general and more capable string the-
ory inside an existing SMT solver.
3. DESIGN OF Z3-strSolver 
string theory plug-in 
new inference 
consistenc y check assignment 
new axiom Z3 
con gruence closure core 
SAT solver theory solvers 
  - arithmetic , … Constraints 
SAT & a possible model UNSAT 
Figure 3: Architecture overview
In this section, we present the details of Z3-str. A key
choice in the design is to support strings as a primitive type
so that we do not need to convert them to other represen-
tations, such as bit-vectors. This avoids determining stri ng
lengths before the solving process, which can be very dif-
ﬁcult through static analysis. More importantly, it allows
us to support unbounded string variables and related oper-
ations that otherwise cannot always be supported if lengths
havetobedeterminedapriori. Furthermore, buildingZ3-st r
using Z3’s plugin API also has the advantage of leveraging
the state-of-the-art capabilities of Z3.
At the beginning of this section, we brieﬂy introduce the
Z3 SMT solver, especially how it interacts with a theory
plug-in. Then, we describe the details of Z3-str.
3.1 Z3 SMT Solver and Its Plug-in API
Z3[19] is an SMT solver developed byMicrosoft Research.
Input constraints are provided to Z3 as a boolean combina-
tion of atomic formulas, where these atomic formulas are
deﬁned over theories supported by Z3 such as integer and
real arithmetic, bit-vectors, arrays and functions. The ar -
chitecture of Z3 is shown in Fig. 3. It is mainly composed
of the following modules: the congruence closure engine, a
SAT solver-based DPLL(T) layer, and several default the-
ory solvers or plug-ins (solvers specialized in solving the sat-
isﬁability problem of theories such as integer linear arith -
metic, bit-vectors etc.). The congruence closure engine is a
key module of Z3. Brieﬂy, it detects if functional terms are
equivalent and if so maintains them in appropriate equiva-
lence classes. The SAT-based DPLL(T) layer is responsible
for handling the boolean structure of the input formula. For
example, it may assert conjunction of theory formulas to
the respective solvers, and backtrack if its assertions to t he
theory solver are unsatisﬁable.
The Z3 solver works roughly as follows: The core (con-
gruence closure and DPLL(T) layer) traverses the boolean116  75431
62 { } 
{݁ଵ=T} 
{݁ଵ=T, ݁ସ=T} S0
S1
{݁ଵ=T, ݁ଶ=T, 
݁ସ=T} 
Add ǣ ݁ ଵ݁ר ଶ՜ Ǩ ݁ ସ{݁ଵ=T, ݁ଶ=F,
݁ଷ=T,݁ସ=T} {݁ଵ=T, ݁ଶ=F,
݁ସ=T} S2
S3S4S5
state 
ͼͼͼ fac ts
ͼͼͼ axiom try 
backtrack 
interaction with 
string plugin 
ݐܽܿ݊݋ܿ ሺ̶̶ǡ ݉ ሻൌ ̶̶ܾ݀ܿܽ ՜ ݁ ହ݁ ହǣ ݉ ൌ ̶̶݀ .Add :{݁ଵ=T, ݁ଶ=F,
݁ଷ=T,݁ସ=T,
݁ହ=T }ݐݎ݁ݏݏܽ ሺ݁ଵרሺ݁ଶ݁ש ଷሻ݁ר ସሻ
݁ଵǣ ݔ ൌ ݐܽܿ݊݋ܿ ሺ̶̶ǡ ሻ
݁ଶǣݕ ൌ ݐܽܿ݊݋ܿሺ̶̶ǡ ݊ሻ 
݁ଷǣ ݕ ൌ ̶̶ܾ݀ܿܽ 
݁ସǣ ݔ ൌ ݕ 
S6
Figure 4: Example of String Solving
structure of the input formula, and asserts a conjunction of
literals or facts (atomic formulas or their negation) to the
appropriate theory plug-insbased on the type Tof the terms
used in the literals. The theory plug-in derives new facts in
domainTfrom the asserted facts and conveys them back to
the core as new axioms. Any equivalence between the terms
in the newly derived axioms and existing terms is detected
by the congruence closure engine, and appropriate equali-
ties are derived. If the derived equalities and disequaliti es
are over shared variables (i.e., shared by multiple theory
plug-ins), then the core asserts them to all such plug-ins.
The core detects if the input formula and derived facts are
unsatisﬁable under the current assignment. If so, it back-
tracks. This process repeats until a satisfying assignment is
produced or the input formula is deemed unsatisﬁable.
3.2 String Solving Procedure: Overview
Next, we will use an example to explain how Z3-str works.
Consider the string constraint on the right of Fig. 4. Since
the core cannot interpret the string operations, it treats
them as four independent boolean variables ( e1,e2,e3and
e4) and tries to assign values to them. Initially (state S0),
there is no fact or axiom. The core starts by setting e1and
e4totrueand reaches state S2. Then, assume the core tries
truefore2before assigning e3at state S3.
Recall that the core can detect functionally equivalent
terms (i.e., based on the theory of uninterpreted functions ).
Hence, from the facts e1=true,e2=trueande4=true, the
core puts x,y,concat (“abc”,m) andconcat(“efg”,n) into one
equivalence class and notiﬁes the plug-in. The plug-in thus
knows the two concats above are equivalent. However, from
the semantics of concatenation, these two concats cannot
equal to each other under any circumstances because they
do not share a same preﬁx. The plug-in informs the core
about the new ﬁnding through an axiom ( e1∧e2→ ¬e4).
Withthenewaxiomandtheexistingfacts, thecoredetectsa
conﬂict on e4(in the boolean domain). The core backtracks
to stateS2and tries the other option for e2. Note that when
the core backtracks, it discards the recent fact and any in-
sertions into equivalence classes as the consequence of the
fact. Then, the core assigns truetoe3so that “abcd” will
be put in the same equivalence class as concat(“abc”,m).
Again, based on the concatenation semantics, the value of
string variable mcan be inferred by the string theory plug-
in, which must be “d”. This new ﬁnding is formulated by
introducing a new variable ( e5) in an axiom concat(“abc”,
m)=“abcd” →e5, which is sent back to the core. The new
state isS6in the ﬁgure. From the existing facts and the new
axiom, the core derives e5istrue.
At state S6, all boolean expressions have been assigned
and the assignments are consistent. Besides, the satisfyin gTerm:bool ::=(Var:bool)
|true
|false
|contains ((Term:string), (Term:string) )
Term:int ::=(Var:int)
|Number
|(Term:int) {+,−,×,÷}(Term:int)
|length ((Term:string) )
|indexof ((Term:string), (Term:string) )
Term:string ::=(Var:string)
|ConstString
|concat ((Term:string), (Term:string) )
|substring ((Term:string), (Term:int), (Term:int) )
|replace ((Term:string), (Term:string), (Term:string) )
Expr:bool ::=(Term:bool)
|(Term:bool) =(Term:bool)
|(Term:int) {<,≤,=,≥,>}(Term:int)
|(Term:string) =(Term:string)
|not(Expr:bool)
|(Expr:bool) ∧(Expr:bool)
|(Expr:bool) ∨(Expr:bool)
|if(Expr:bool) then(Expr:bool) else(Expr:bool)
|(Expr:bool) implies (Expr:bool)
Assertion ::=assert(Expr:bool )
Figure 5: Constraint syntax
values of string variables x,yandmcan be retrieved from
their equivalence classes. So, a set of consistent and satis -
fying solutions for the input constraint has been found and
the search procedure terminates.
3.3 Constraint Syntax
The constraint syntax is presented in Fig. 5. For simplic-
ity, we only list three primitive types: int, bool andstring1.
Our plug-in supports the following string operations: string
equation,concatenation ,length,substring ,contains,indexof,
replaceandsplit2.
3.4 Supporting String Operations
In this section, we will explain how the string operations
are supported. We ﬁrst discuss three primitive operations:
string equation, concatenation andstring length . Then we
will explain how to reduce other string operations to an
equivalent formula based on these primitives. Z3 core
can directly model the equivalence relation between object s,
i.e. variables and constants, by putting them into the same
equivalence class. Hence, our overall strategy is to reduce
various string operations to simple equivalence relations .
The Z3-str algorithm is incremental, driven by the try-and-
backtrack procedure of the Z3 core.
3.4.1 String Concatenation
String concatenation is a very commonly used operation.
It is also a primitive operation in Z3-str. The plug-in is
notiﬁed by the Z3 core when a string equation is asserted
as part of the try-and-backtrack process. In particular, th e
core invokesacall backfunctionintheplug-in, providingt he
abstract syntax tree (AST) of the equation as a parameter.
The call back function inspects the AST, if it involves strin g
concatenations, the function tries to perform AST transfor -
mation to reduce the AST to a new one that is simpler and
easier to resolve.
The reduction is conveyed to the core by adding an ax-
iom with the form of“ AST→AST′”withASTandAST′
the original and the transformed syntax trees, respectivel y.
Recall that since the core does not understand the string
domain, it treats both ASTandAST′independent bool
variables. As ASThas been assigned a (true) value, with
the new axiom, the core will assign a (true) value to AST′,
1Z3 supports more primitive types [19]
2Splitisnotpresentedinthesyntaxduetoitsspecialformat.117Definitions:
Y∈CompoundString ::=s·CompoundString |x·CompoundString |ǫ
x∈Var:String s∈ConstString
split ::=CompoundString → P(CompoundString ×CompoundString ×Expr:bool)
Auxiliary Functions:
split(Y) =recSplit(nil,Y)
recSplit(YL, s·YR) =/uniontext
∀sh·st=s{/an}bracketle{tYL·sh, st·YR, true/an}bracketri}ht}/uniontextrecSplit(YL·s, YR)
recSplit(YL, x·YR) ={(YL·x1, x2·YR, x1·x2=x)}/uniontextrecSplit(YL·x, YR)
recSplit(YL, nil) = φ
len(s·Y) =“|s|+”·len(Y)len(x·Y) =“length(x)+”·len(Y)len(nil) =“0”
Figure 6: Deﬁnitions for Algorithm 1 and Table 1
which is a new fact triggering further plug-in processing.
The reduction continues until the simple equivalent form of
expressions, e.g. x=Y, withYa constant string, or a
compound string composed of constants and variables, are
reached. The dependences of these simple expressions are
then constructed so that the plug-in can try assigning val-
ues to free variables (i.e. variables do not depend on others ),
if any, to produce a satisfying solution.
Algorithm 1 Concatenation Reduction Algorithm
callback (Y1=Y2)
1:reduce (Y1=Y2);
2:foran object Y∈Y1/Y2’s equivalence class do
3:reduce (Y1=Y);
4:reduce (Y2=Y);
5:ifY1=Y2is of the form x=sthen
6:foranyYinvolving xin existing eq-classes do
7:reduce (Y);
Algorithm. The high level concatenation reduction pro-
cess is presented in Algorithm 1. Upon the core assigning
true to a string equation of two compound strings (i.e. con-
catenations of constants and variables as deﬁned in Fig. 6),
function callback() in Z3-str is invoked. The core idea be-
hind the concatenation reduction given in Algorithm 1 is to
derive new equations between the sub-strings on two sides
of the equation, and over all terms equivalent to these sub-
strings (recall that Z3’s core maintains equivalence class es
of terms). For instance, assume a string variable xhas its
equivalence class {x,“a”·x1}. If a new equation x= “ab”
is asserted to the plug-in, we can use the concatenation re-
duction algorithm to derive x1=“b”from this new fact and
the equivalence class. Furthermore, if the new equation is
of the form x=swithsa constant string, in lines 5-7,
the algorithm traverses all the expressions in existing equ iv-
alence classes that involve xand replaces xwiths, which
may trigger further reduction.
Reduction Rules. The ﬁrst four rules in Table 1 are con-
catenation reduction with relevant deﬁnitions in Fig. 6. In
Table 1, the second column shows the transformation and
the thirdcolumn is the condition ofthe reduction. Notethat
thetransformation ruleisintheformof“ origformula→new
formula”, which is essentially the axiom we add to the Z3
core. For easier presentation, we ﬂatten an AST to a com-
pound string that is a ﬂat concatenation of constants and
variables. Note that during ﬂattening, all the consecutive
constantstringsareconcatenatedtoalongerconstantstri ng.
Rule (HEAD-CONST-RMV )removes theleft-most com-
mon constant substring of the left-hand side (LHS) and the
right-hand side (RHS) of an equation. Note that we assume
the RHShas the longer constant stringwithout losing gener-
ality. IftheLHSand theRHSdonotshare acommon preﬁx,an axiom“ ¬origformula”is added, causing backtrack. Rule
(TAIL-CONST-RMV ) is similar.
After applying the constant removal rules, we get to a
point that either the LHS or the RHS starts with a vari-
able. Rule ( SPLIT) allows further reduction for such ex-
pressions. Without losing generality, assume the LHS is of
the form x1·Y1, in which x1is a variable and Y1a com-
pound string. The rule divides the RHS compound string
Y2to two substrings YhandYt, by calling function split(),
and asserts x1=YhandY1=Yt. The split function may
also generate a new constraint Cthat denotes the side-eﬀect
of splitting. The condition is conjoined with the two asser-
tions. Note that there are many ways of splitting Y2. Hence
thesplit() function returns a set of splittings, which are
associated with ⊻operator. The operation is similar to a
boolean orbut it requires only one option can be true. For
example, x⊻y=trueimplies either x=true,y=flaseor
x=false,y=true.
The details of function split(Y) is shown in Fig. 6. It
is a recursive process by function recSplit(YL,YR), which
returns the set of possible splittings. Particularly, it sp lits
the leading literal of YRat a time and moves it to the end
ofYL. Hence, the process starts with YL=nil∧YR=Y
and terminates with YL=Y∧YR=nil. If the literal
is a constant s, it creates multiple splittings that split at
diﬀerent positions in s. Ifthe literal is a variable x, it creates
one splitting, which is to split xtox1andx2withx1and
x2fresh variables. The correlation of variables is asserted
in the splitting condition, which will be part of the reduced
equation (i.e. Cin Rule ( SPLIT)).
Consider a compound string“ ab”·x. The generated splits
are{(“”,“ab”·x,true), (“a”,“b”·x,true), (“ab”,x,true), (“ab”·
x1,x2,x1·x2=x)}.
An important observation of the split rule is that the in-
dividual options (of the ⊻operator) in the transformed for-
mula are simpler than the original formula . This guarantees
monotonicity in reducing the original formula. Note that
these simpler options will be explored and further reduced
byZ3-str separately. However, we also addnew constraint C
to the system during splitting, which may raise the concern
of termination. We will further discuss this issue in Sec. 3. 5.
Rule (Concretize ) replaces a variable xinY1·x·Y2with
a constant string when they become equivalent. Note that
in order to ensure the inserted formula is an axiom, we have
to conjoin x=swith the original expression.
Simple Equations. When no more reduction can be con-
ducted, if each equivalence class has a constant, the solv-
ing process terminates with a SAT solution. Otherwise, the
plug-in builds a dependence graph of variables involved in
simple equations, which are equations in the form of x=Y
and the equivalence class of xhas no more than one non-
singleton compound string terms (i.e. not a constant or a
variable). For example in x=Y,xdepends on all vari-118Table 1: Reduction Rules
Rule Reduction Condition
Head-Const-Rmv s1·x1·Y1=s2·Y2→x1·Y1=s3·Y2 ifs1·s3=s2
s1·x1·Y1=s2·Y2→ ¬(s1·x1·Y1=s2·Y2) if s1is not a preﬁx of s2
Tail-Const-Rmv Y1·x1·s1=Y2·s2→Y1·x1=Y2·s3 ifs3·s1=s2
Y1·x1·s1=Y2·s2→ ¬(Y1·x1·s1=Y2·s2) if s1is not a suﬃx of s2
Split x1·Y1=Y2→⊻∀/angbracketleftYh,Yt,C/angbracketright∈split(Y2)(x1=Yh)∧(Y1=Yt)∧C
Concretize (x=s)∧(Y1·x·Y2)→Y1·s·Y2 ifx=s
StringLen Y1=Y2→len(Y1) =len(Y2)
Free-Var Context →x=“”⊻x=“@”⊻x=“@@”... x a free variable
ables inside Y. Note that complex formulas will cause re-
duction andgenerate simple formulas. From the dependence
graph, we identify free variables, i.e. variables that do no t
depend on others and do not have constants in their equiva-
lence class. We then assign concrete values to free variable s
by adding new axioms. Such assignments will be explained
when we discuss the string length operation.
Example. Consider the following constraint composed of
three clauses with x,y, andzstring variables.
z=x·y z =“a”·w x ·“d”=“abd”
The solving process is presented in Table 2. The sec-
ond column shows the fact/assignment from the core; the
third column shows the corresponding equivalence class; th e
fourth column shows the reduction/action. In step 1, the
new fact does not trigger any reduction. In step 2, the two
compound strings in the equivalence class of zcauses reduc-
tion by Rule ( SPLIT). In step 4, the axiom added in step 3
causes the fact x=“ab”. In steps 5 and 6, the core tries to
explore the [1] and [2] options in the axiom added in step 2
but detects conﬂicts. It then explores the [3] option in step
7. In step 8, no more reduction can be performed, Z3-str
hence looks at variable dependences and identiﬁes that w2
is a free variable. Note that in the current context, we have
y=w2andw1·w2=wfrom the [3] option. Assigning an
empty string to w2produces a SAT solution. ✷.
3.4.2 String Length
String length is another important primitive operation as
other operations can be reduced to it. Since the Z3 core
does not understand the semantics of the operation, it sim-
ply treats it as an integer variable. Z3-str hence needs to
ensure the correlation between the length variable and the
correspondingstring. Thebasicdesignistogeneratetheco r-
responding length constraints (in the integer domain) when
the plug-in is invoked by the core upon new facts in the
string domain. If the new length constraints cause any con-
ﬂict in the integer domain, the core will backtrack and try
a diﬀerent solution in the string domain.
Rule (StringLen ) describes how Z3-str generates length
constraint upon a new fact Y1=Y2. It calls function len()
(deﬁned in Fig. 6) to translate the two compound strings to
integer expressions and asserts their equivalence. It tran s-
lates a constant string to its length and introduces a length
variable length(x) for a string variable x.
Example. Consider the following three clauses.
x1=“a”x2=x1·“efg”∨x2=x1·“e”length(x2)<3
Suppose the core ﬁrst assigns truetox1=“a”. This fact al-
lows Z3-str to add the axiom ( x1=“a”)→(length(x1) =
1). Now assume the core tries the ﬁrst option of the sec-
ond clause. Z3-str adds the axiom x2=x1·“efg”→
length(x2) =length(x1) + 3. It causes a conﬂict with
the third clause in the integer domain. The core then turns
to the second option and ﬁnds the SAT solution. ✷In the previous discussion of concatenation rules, we men-
tion that we can assign any value to a free variable. However
a free variable xin the string domain may be constrained
by length assertions (in the integer domain) on the variable
itself or on other variables that are dependent on x. Since
length constraints do not constrain string values but rathe r
their length, we introduce a free variable Rule ( Free-Var )
to allow the core to try to assign predeﬁned constant strings
of various lengths to a free variable in order to satisfy leng th
constraints. According to the rule, if the plug-in detects
that a string variable xis a free variable in the current con-
text, it adds an axiom which states that the current context
implies that xmay have constant strings of various lengths.
The context is the conjunction of all the facts set by the
core upto this point. We have to use the context as the
antecedent as xmay not be a free variable in a diﬀerent
context. Any conﬂicts by length constraints will cause the
core to try a constant string of diﬀerent length. Consider
the example in the previous section (Table 2). If we have an
additional clause length(z)>2, the assignment of w2=“”
will be UNSAT, the core will further try to assign w2=“@”,
which generates a SAT solution.
3.4.3 Other Operations
The concatenation and length operations are supported
by performing incremental reduction and adding new ax-
ioms gradually, driven by the try-and-backtrack process.
The other operations are supported in a diﬀerent way. We
perform pre-processing to translate them to formulas using
concatenation and length operations.
Substring. Thesubstringoperator, substring (x,i,j), takes
three arguments. It returns a substring of xstarting at po-
sitioni, and its length is j. The substring operator can be
reduced to a formula with concatenation and string length
operations. Particularly, as shown by Rule ( Substring ),
since the return string is a part of the ﬁrst argument, we
break the ﬁrst argument into three pieces x1,x2andx3,
and assert the middle piece x2equals to the return string.
We assert the lengths of x1andx2to respect the position
and length constraints.
Contains. The string membership operator contains (x1,
x2) takes two parameters and checks whether x2is a sub-
string of x1. According to Rule ( Contains ), we break x2
into three pieces xp,x2andxs. Note that the middle piece
isx2. The negation of contains is more challenging as it
is essentially an operation with universal quantiﬁer. Our
method is to generate solutions for x1andx2as if the con-
straint did not exist and use post-processing to check if x2
is contained in x1. If so, we force the core to backtrack.
IndexOf. The operation indexof (x1,x2) returns the start-
ing position of substring x2inx1. Ifx2is not a substring of
x1, it returns −1. As shown by Rule ( IndexOf ), we break
x1into three pieces xs1,xs2andxs3. The result value ihas119Table 2: Example for concatenation reduction
step fact eq-class reduction/action
1z=x·y {z, x·y}
2z=“a”·w{z, x·y,“a”·w}x·y=“a”·w→
x=“”∧y=“a”·w[1]
⊻x=“a”∧y=w[2]
⊻x=“a”·w1∧y=w2∧w1·w2=w[3]
3x·“d”=“abd”{x·“d”,“abd”}x·“d”=“abd”→x=“ab”
4 x=“ab” {x,“ab”}
5 [1] ... conﬂict between x=“ab” andx=“”, backtrack
6 [2] ... conﬂict between x=“ab” andx=“a”, backtrack
7 [3] {x,“ab”,“a”·w1}“ab”=“a”·w1→w1=“b”
8 Identify w2as the free variable based on dependences: z❀y❀w2andw❀w2, assign w2=“”
SAT solution: w2=y=“”,x=z=“ab”,w1=“b”
Table 3: Preprocessing Rules for Other Operations
Rule New Formula
SubString substring (x,i,j) =xt→x=x1·x2·x3∧x2=xt∧length(x1) =i∧length(x2) =j
Contains contains (x1,x2)→x1=xp·x2·xs
IndexOf indexof (x1,x2) =i→(x1=xs1·xs2·xs3)∧(i=−1∨i/greaterorequalslant0)∧((i=−1)↔ ¬contains (x1,x2))∧
((i/greaterorequalslant0)↔(i=length(xs1)∧xs2=x2∧(¬contains (xs1,x2))))
Replace replace(x1,x2,x3) =xt→(x1=xs1·xs2·xs3)∧i=indexof (x1,x2)∧
if(i/greaterorequalslant0)thenxt=xs1·x3·xs3∧length(xs1=i)elsext=x1
Split split(x1,x2) = [xt1,xt2]→x1=xt1·x2·xt2∧¬contains (xt1,x2)∧¬contains (xt2,x2)
two options: if and only if x1doesn’t contain x2,iis−1.
Otherwise, if and only if xs2equals to x2, its predecessor
xs1doesn’t contain x2, andtequals to the length of xs1.
Replace. The transformation is shown in Rule ( Replace ).
In the rule, we assume only one substring is replaced. It
can be easily extended to support cases in which less than
nreplacements occur with na pre-deﬁned constant.
Split.We support splitin a similar way to that of replace.
In the rule, we assume only one substring matches the pat-
ternx2. It can be extended to support cases with less than
noccurrences.
3.5 An Improved Algorithm for a Restricted
Theory of Strings
Unfortunately, it is unknown if the satisﬁability problem
of string constraints with length operations is decidable i n
general [11, 18]. This has a bearing on our algorithm in
that it may not terminate for certain cases, stuck in inﬁnite
splitting. To avoid such non-termination we restrict the th e-
ory in certain ways as described below. For this restricted
theory, the satisﬁability problem becomes decidable and ou r
algorithm is one such decision procedure.
Tobetterillustratetheproblem, observeinRule( SPLIT),
while we are simplifying the original equation, we may in-
troduce new ones, denoted by C, which may cause further
splitting. In some cases, the splitting becomes inﬁnite.
x·“b”=“a”·x→...⊻ (Ex-I)
(x=“a”·x1[1]∧x2=“b”∧x=x1·x2[2])⊻...
Consider the above example, which shows part of the re-
duction of a string equation with the same variable appears
as the preﬁx of LHS and the suﬃx of RHS. The equation
is not satisﬁable. However, according to our reduction rule
(SPLIT), one of the options as shown induces new equiva-
lence between theRHS’s of [1] and [2]. Observethat the new
equation has a very similar form as the original one. Hence,
the exploration and reduction will not terminate (i.e. x1in
[1] will be further splitted).
x·Y1=Y2·y[3]y·Y3=Y4·x[4](Ex-II)
Such non-termination could also occur in equations that in-
volve multiple variables. Assume the above two clauses.Part of their reductions are shown as below. In the ﬁrst
reduction, yis splitted and in the second reduction, xis
splitted. Observe that the equivalence between RHS of [5]
and RHS of [8], and the equivalence between RHS of [6] and
RHS [7] form a recursion of the form of the original two
clauses, causing inﬁnite reduction.
[3]→...⊻(x=Y2·y1[5]∧Y1=y2∧y=y1·y2[6])⊻...
[4]→...⊻(y=Y4·x1[7]∧Y3=x2∧x=x1·x2[8])⊻...
The root cause of non-termination is that the splitting of
a variable directly or indirectly causes further splitting of
the same variable. In Ex-I, the splitting of xintroduces
new equivalence such that a subpart of it, x1, sets out to be
splitted. However, we observe that such cases rarely happen
in the constraints generated from web applications. There-
fore, we deﬁne a sub-class of the problem that is decidable
and leads to an algorithm that ensures termination.
The Reﬁned Problem. We capture the essence of the
non-termination issue using a graphical representation of
equation in Fig. 7. Such graphical representation was in-
troduced in various studies of string theories [12]. A solid
horizontal segmentrepresents avariable oraconstantstri ng.
We call it the projection of the variable or string. A com-
pound string consisting of a sequence of variables and con-
stant strings is denoted as a sequence of segments that are
slightly misaligned vertically for better visibility. The equiv-
alent compound strings (e.g. the LHS and RHS of an equa-
tion) are projected to the same graph. The vertical dotted
linesrepresenttheboundariesofsegmentsandthealignmen t
across strings. Notethatthepositionsoftheboundariesma y
vary for diﬀerent solutions.
For example, Fig. 7 (a) shows the graphical representation
of example Ex-I. Fig. 7 (b)shows a simpliﬁed one for Ex-II.
It is the union of the two projections regarding equation [3]
and [4] by unifying the two y’s in [3] and [4] and omitting
some compound strings for readability. A split corresponds
to that the end of a variable segment falls in the middle of
another variable segment. We call it a cut.
Definition 1.We say a varaible xcutsy, denoted as
x↓y, if there is a reduction from x·Y1=Y2·y·Y3to
(x=Y2·y1∧Y1=y2·Y3∧y=y1·y2).120x
x‘a’‘b’
x
yY1
xY4
(a) (b)x
yY1
xY4
(c)12
Figure 7: Subgraphs (a) and (b) show the graphical represent ation
of Ex-I and Ex-II, (c) shows a well-formed solution of Ex-II.
Hence, in Fig. 7 (a), the top x(in the LHS of the original
equation) cuts the bottom x(in the RHS). In (b), the top x
cutsyandycuts the bottom x.
We observe that non-termination is caused by cases in
which the projections from the same variable overlap (but
not completely coincide). The shaded regions in Fig. 7 rep-
resent the overlapping regions. As such, a cut of a segment
will have its projection in other segments of the same vari-
able. These projections mayfurthercuttheoriginal segmen t
due to the overlap, resulting in inﬁnitecutting. In Fig. 7 (a ),
the cut at 1/circlecopyrton the bottom xhas its projection at 2/circlecopyrton the
topxand this projection cuts the bottom xagain. Figure
(b) is similar.
Note that overlapping of multiple projections of the same
variable implies recursive self constraining of the same va ri-
able.For instance, in Fig. 7 (a), it implies the preﬁx and
suﬃx of xare mutually constrained. Based on our obser-
vation, such self constraining is very rare in the program
analysis context. Hence, we preclude such cases in order to
devise a better algorithm that guarantees termination.
The formal deﬁnitions regarding the reﬁned problem are
presented as follows.
Definition 2.Given a solution of a set of string con-
straints and a variable x, the projection of the solution re-
gardingxuses the segment of xas the base and projects all
the other variables that overlap with xin some constraint
according to the solution.
Fig. 7 (b) and (c) are sample solution projections regard-
ingyforEx-II.
Definition 3.We say a solution is well-formed if and
only if in the projection regarding any variable, there is no t
a variable xwhose multiple projections overlap.
Fig. 7 (c) is a well-formed solution but (b) is not as the x
segments overlap.
Given the deﬁnitions, the problem is reﬁned to ﬁnding
well-formed solutions of a set of string constraints .
The Revised Algorithm. We revise the previous algo-
rithm. The revision mainly lies in the split function. We in-
troduce a few new deﬁnitions. Mapping VARidentiﬁes the
original string variable (of an intermediate variable). Fo r
example in Ex-I,VAR(x1) =x. We also annotate each in-
termediate variable xwith the variable ythat cuts VAR(x)
and induces the generation of x. Note that xyimplies that x
is a suﬃx of yaccording to the deﬁnition of a cut. Initially,
we annotate all string variables with themselves.
We revise the recursive split function, particularly the
part that splits a variable. The function is invoked with
the variable xzthat causes the split. For instance, given
an equation xz·Y1=Y2,recSplit(xz,nil,Y 2) is called to
start splitting. If it is to split a variable yin the RHS. It
checks if z==VAR(y) to avoid self-splitting. Note that
sincex==VAR(x) for any original variable x, we triviallyprevent direct self-splitting. If the cut is admissable, th e
splitted variable y1inherits the annotation zandy2retains
theannotation of y. Ifthe cutis not admissable, thevariable
is not splitted.
Example. Lets revisit Ex-II. We annotate the original
clauses initially as follows.
xx·Y1=Y2·yy[3]
yy·Y3=Y4·xx[4]
Part of the reduction of [3] is as follows.
[3]→...⊻(xx=Y2·yx
1[5]∧Y1=yy
2∧yy=yx
1·yy
2[6])⊻...
Part of the reduction of [4] is the following.
[4]→...⊻(yy=Y4·xy
1[7]∧Y3=xx
2∧xx=xy
1·xx
2[8])⊻...
From [6] and [7], we have yx
1·yy
2=Y4·xy
1. However, yx
1
will not cause splitting of xy
1asVAR(x1) =x, which is the
annotation of y1. Hence, the search will focus on splitting
Y4, which corresponds to the well-formed solution as shown
in Fig. 7(c).
4. EV ALUATION
Ourevaluationconsistsoftwoexperiments. Intheﬁrstex-
periment, wecomparetheperformanceofZ3-strwithKaluza,
which only supports encoding a single path. In the second
experiment, we compare Z3-str with our prior work on a
solver that integrates HAMPI and STP and supports en-
coding multiple paths, in terms of both eﬃciency and ef-
fectiveness. We choose to compare with these two solvers
as they can solve string and non-string constraints togethe r.
All experiments are run on an Intel Core i5-2520M machine
with 8GB memory.
4.1 Comparison with Kaluza
We use the test cases shipped with the Kaluza package
to compare performance. Since we currently do not sup-
port regular expressions, we remove the constraints relate d
to regular expressions, which account for a small percentag e
of all the constraints. Then, we run both solvers 100 times
for each test case and take average of the execution time.
The results are presented in Table 4. We can see Z3-str is
faster than Kaluza in 13 out of 14 cases. We also observed 6
solutions provided by Kaluza are partially incorrect. In th e
last case, Kaluza outperfoms Z3-str. This case has a large
set of simple string constraints that are easy to satisfy. We
observed a lot of backtrackings due to string length incon-
sistencies in Z3-str for this case. Further analysis shows t hat
because the version of Z3 we use does not allow us to ac-
quire the concrete values assigned to length variables in th e
integer domain during the solving process, we cannot lever-
age the values explicitly to optimize splitting. Although t he
infeasible splittings are immediately rejected by the inte ger121Definitions:
VAR(x) ::= the original string variable of a temporary variable (w hich is generated by splitting)
Each variable xis annotated with a variable yto denote xwas generated by ycuttingVAR(x). Initially, we annotate
xwithxitself.
Auxiliary Functions:
recSplit(xz, YL, s·YR) =/uniontext
∀sh·st=s{/an}bracketle{tYL·sh, st·YR, true/an}bracketri}ht}/uniontextrecSplit(xz, YL·s, YR)
recSplit(xz, YL, yw·YR) =/braceleftbigg
{(YL·yz
1, yw
2·YR, yz
1·yw
2=yw)}/uniontextrecSplit(xz, YL·yw, YR)z! =VAR(y)
{(YL·yw, YR, true)}/uniontextrecSplit(xz, YL·yw, YR) otherwise
recSplit(xz,YL,nil) = φ
Figure 8: New Deﬁnitions and Split Function.
theory, Z3-str has to pay the cost of unnecessary splitting
and backtracking. In contrast, Kaluza ﬁrst acquires the con -
crete length values and then performs encoding. Because
these constraints are simple, Kaluza does not need to enu-
merate multiple solutions for string lengths. Z3 is recentl y
open-sourced. We are looking into if Z3-str can communi-
cate with the integer theory better to improve performance.
We also want to point out again that Z3-str is more general
in one respect than Kaluza, as Z3-str does support encoding
multiple program paths while Kaluza does not.
Table 4: Comparison with Kaluza [22]
stats Correct? Time (s)
varcstrKZ K ZK/Z
bettermatch1∗10 8/check/check0.276 0.035 7.9x
bettermatch2∗97/check/check0.242 0.036 6.7x
concat 99×/check0.216 0.035 6.2x
idxof∗3140×/check0.632 0.067 9.4x
indexof∗1214/check/check0.198 0.035 5.7x
match 1616×/check0.207 0.036 5.8x
replace∗1819/check/check0.205 0.049 4.2x
search∗87/check/check0.193 0.035 5.5x
split∗1513×/check0.203 0.038 5.3x
streq 1115/check/check0.187 0.035 5.3x
substr 912×/check0.179 0.034 5.3x
substridxof∗3038×/check0.210 0.062 3.4x
big1∗7591/check/check0.241 0.154 1.6x
big2∗573713/check/check0.962 2.718 0.4x
Average –––– – –5.2x
∗Regular expression constraint removed.
4.2 Comparison with Our Prior Work
In our prior work in detecting remote code execution vul-
nerabilities [33], which allow malicious PHP code to be in-
jected and executed, we developed a solver that supports
encoding multiple program paths for static analysis. It com -
bines STP and HAMPI in an Alternative and Iterative (AI)
fashion. It uses STP to generate sets of feasible paths with-
out considering string behavior. It then uses HAMPI to
encode string behavior along those paths. Solving the strin g
constraints determines the true path feasibility. We use th e
same set of benchmarks to compare the performance. The
two solvers are provided the same set of constraints. Each
constraint encodes an entire program (after using a static
slicer to prune irrelevant parts). The results are listed in Ta-
ble 5. We use AI solver to denote the prior solver. The data
suggest that Z3-str performs much better. This is because
inAI solver , infeasible paths caused by string constraints
cannot be detected by STP and have to encoded and passed
on to HAMPI, todetermine their true feasibility, whereas Z3
can leverage the interal results from Z3-str toavoid them en -
tirely. The frequent queries to STP and HAMPI also cause
overhead in process starting and ﬁnishing.
Eliminating False Positives in [33] . Next, we will show
that Z3-str allows us to remove all the false positives (FP) i nTable 5: Comparison with AI Solving [33]
stats AI solver Z3-str AI solver
application varcstriteration real(s) real(s) / Z3-str
aidiCMS v3.55 446464 03.950 0.421 9.4x
phpMyFAQ v2.7.0 296307 56.228 0.187 33.3x
zingiri webshop v2.2.2 300315 1347.380 0.109 434.7x
phpMyAdmin v3.4.3 164150 01.053 0.119 8.8x
phpLDAPadmin v1.2.1.1 628627 3984.938 0.693 122.6x
phpScheduleIt v1.2.10 514597 96.812 0.228 29.9x
FreeWebshop v2.2.9 R2 10991147 6295.995 0.255 376.5x
ignition v1.3 260256 10.748 0.227 3.3x
monalbum v0.8.7 175174 00.348 0.211 1.6x
webportal v0.7.4 12 9 00.359 0.031 11.6x
@ fws/adminedit.php
51 $name = explode(".", $_GET[’filename’]);
67 if ($_POST[’action’] == "write_changes") {
68 if ($name[1] == "txt" || $name[1] == "sql") {
69 if ($name[1] == "txt" && ... ) {
70 $fp=fopen($_GET[’filename’],"w");
71 fwrite($fp,$_POST[’text2edit’]);
73 } else {...} } }
Figure 9: FP type 1 in Zingiri webshop
the prior work as Z3-str supports the commonly used string
operations while the prior solver does not.
In web applications, clients often can upload ﬁles or save
user input in a server-side ﬁle. Sometimes, the ﬁle name can
be provided by the client too. If arbitrary user input can
be saved in a user speciﬁed ﬁle ending with “.php”, a RCE
vulnerability is introduced since the client may inject and
execute arbitrary PHP code by writing and manipulating
that ﬁle. Many web applications have proper protection by
having checks on ﬁle names before ﬁle writes. The reason
for the 6 FPs we had before is because we cannot model the
ﬁle name checking logic due to the string operators used.
Two of the FPs have ﬁle name checking similar to that
in Fig. 9. Function explode is used to separate a string
to substrings. Previously, due to the lack of support of
split, we cannot model the function and have to use free
variables to denote $name. As a result, its relation with
$GET[’ﬁlename’] is missed. Therefore, the assertions of
$GET[’ﬁlename’] being ended with “.php” and the reach-
ability conditions at line 71 are SAT. With Z3-str, we can
modelexplode() precisely with splitand correctly determine
that writing to“.php”ﬁle is infeasible.
The remaining four FPs are similar to Fig. 10, in which
getFileExt() cannot be properly modeled. With Z3-str, the
function can be modeled using substring andindexof .
Hence, we can correctly decide that the ﬁle write at line
40 is not reachable when the ﬁle name extension is“.php”.
5. RELATED WORK
There is a vast literature on the problem of solving equa-
tions of all manner through uniﬁcation [16, 15] and term
rewriting [4]. Schulz uses a combination of tehcniques from122@ modul/tinymce/plugins/ajaxfilemanager/ajax_save_te xt.php
11 $path = $not_important . $_POST[’name’];
21 if ( getFileExt($_POST[’name’]) == "php" ) { ... }
28 else {
33 if( file_exists($path) ) { ...}
36 else {
38 $fp = fopen($path , "w+");
40 fwrite($fp, $_POST[’text’]); } }
Figure 10: FP type 2 in adidCMS
string-uniﬁcationandMakanin’salgorithmstosolvethepr ob-
lemofterminatingminimalandcompleteworduniﬁcation[23 ].
Based on the underlining representation, existing string
analysescanberoughlycategorizedintotwokinds: automat a-
based [9, 24, 13, 14, 27, 31, 26, 2, 21] and bit-vector-based
[17, 22, 8, 21]. We have made comparison with a number
of these existing works [17, 22, 33, 26] in Sections 2 and 4.
Hence in this section, we focus on the other works.
Automata/regular-expressions are a natural form to rep-
resent strings so that many works are based on them. Java
String Analyzer(JSA) [9] applies static analysis to model
ﬂow graphs of Java programs. These graphs capture de-
pendencies among string variables. Finite automata can be
computed from the graphs to reﬂect possible string values.
Shannon et al. [24] used ﬁnite state machines (FSMs) to
model strings. String computation is modeled by FSM re-
ﬁnement. They have ad-hoc rules for integer relations but
do not support integer constraints in general. Hooimeijer
and Weimer [14] designed an heuristics based approach to
ﬁnd a SAT solution. They search lazily to avoid building
full automata. As a result, the performance is improved
greatly compared to their previous work [13]. Rex[27, 28]
uses symbolic automata where labels are represented by
predicates. It uses symbolic language acceptor and explore s
various optimizations of symbolic automata, like minimiza -
tion, to leverage the underlying SMT solver and eliminate
inconsistencies. Also, the trade-oﬀs between the language
acceptor based encoding and automata-speciﬁc algorithms
are discussed [28]. Symbolic automata are implemented in
the symbolic automata library [29]. Stranger[31] develope d
by Yu et al. analyzes strings for PHP based on automata.
ViewPoints [2] uses DFA to model client- and server-side
input validation functions. The inconsistency between val i-
dation functions can be found by comparing their DFAs. [7]
surveyed a large set of existing string solvers and compared
them using a table.
Usingautomata/FSM/regular-expressions allows theabove
techniques nicely support inﬁnite strings and regular expr es-
sion related operations. However, many of them have diﬃ-
culties in handling string constraints related to integers like
lengthandsubstring (with variable indices). More impor-
tantly, manyof them donot provide nativesupport for other
types of constraints such as integer, which is needed in rea-
soning about both string and non-string behavior together.
In [30], string automata are extended with arithmetic au-
tomata to support integers and length constraints in ad-
dition to string constraints. Preﬁx/suﬃx operations and
Presburger arithmetic constraints on integer variables (i .e.,
linear arithmetic constraints + Boolean connectives + quan -
tiﬁcation) are also supported. Incomparison, Z3-stris bas ed
on term rewriting and leverages Z3, which may allow better
scalability and support a richer set of theories.
TheSTePsystem[6] had a diﬀerent rewriting style string
solver. It was complete for a speciﬁc fragment of strings
called“queues”, whereaconcatenationisrestrictedtohav ing
at most one variable. It can solve equations and inequalitie s.It also used extensions for general concatenation, length a nd
reverse. Z3-str supports multiple variables.
Bjørner et al. [8] proposed a string constraint solving
technique to reason about feasibility of a concrete execu-
tion path. It works in a way similar to Kaluza, encod-
ing strings into bit-vectors. Hence it needs to enumerate
concrete length values. It supports common integer related
stringoperationsexpect replace. Regularexpressionsarenot
supported. Redelinghuys et al. [21] developed a constraint
solving engine that can handle multiple types of constraint s
for Java PathFinder. It ﬁrst ignores string constraints and
gets a satisﬁable solution for numeric and boolean variable s.
These concrete values are then used to encode string con-
straints to bit-vectors (with ﬁxed lengths). If the string p art
is UNSAT, it tries a diﬀerent SAT solution from the non-
string domains. They can handle many operators. They
have limited support for replace, requiring the result and
arguments must be concrete. They do not handle regular
expressions. As discussed in Section 2, the above technique s
have similar limitations as Kaluza as they only allow encod-
ing one path and hence not ideal for static analysis. The
path exploration engine can hardly leverage the string solv -
ing results to prune search space (see Fig. 2).
There have been a lot of theoretical research in general
string theory [12, 18, 11, 20]. Some proposed algorithms to
solve string equations. However, these algorithms usually
do not consider important string operations such as length.
Z3-str shares some similarity to [18] in splitting variable s. In
contrast, we reﬁned the problem scope to make the problem
decidableandyetsuﬃcientfor webprogram analysis andthe
algorithm is incremental, driven by the try-and-backtrack
procedure of Z3.
6. CONCLUSION
We develop a general purpose string solver, Z3-str, as an
extension of Z3. Z3-str treats strings as a primitive type,
avoiding the inherent limitations observed in many existin g
solvers that encode strings in terms of other primitives. It
supports string constants and variables of arbitrary lengt h,
and commonly used string operations. It allows encoding
single or multiple program paths such that it can be used
in both dynamic and static analysis. The underlying al-
gorithm based on constant string and variable splitting is
sound and guarantees termination for a restricted theory
that is suﬃcient in practice. Our system is complete for
positive equations and length. We do handle dis-equations,
but we haven’t established completeness for it. Our exper-
iments show that Z3-str outperforms other state-of-the-ar t
solvers and its support of various string operations allows
us to eliminate all false positives in remote code execution
vulnerability detection.
7. ACKNOWLEDGMENTS
We would like to thank Leonardo De Moura and Nikolaj
Bjørner for their help and comments. We thank the review-
ers for their substantial eﬀorts. This research is supporte d,
in part, by the National Science Foundation (NSF) under
grants 0845870, 0917007, 1218993 and Canadian NSERC
Discovery Grant 2013. Any opinions, ﬁndings, and conclu-
sions or recommendations in this paper are those of the au-
thors and do not necessarily reﬂect the views of NSF.1238. REFERENCES
[1]http://www.cs.purdue.edu/homes/zheng16/str
[2] M. Alkhalaf, S. Choudhary, M. Fazzini, T. Bultan, A. Orso
and C. Kruegel. ViewPoints: Diﬀerential String Analysis fo r
Discovering Client- and Server-Side Input Validation
Inconsistencies. In ISSTA’12 .
[3] S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar
and M. Ernst. Finding Bugs in Web Applications Using
Dynamic Test Generation and Explicit-State Model
Checking. In TSE, vol.36, no.4, pp.474-494, 2010 .
[4] F. Baader and T. Nipkow. Term rewriting and all that .
Cambridge University Press, 1998.
[5] P. Bisht, T. Hinrichs, N. Skrupsky, R. Bobrowicz and
V. Venkatakrishnan. NoTamper: automatic blackbox
detection of parameter tampering opportunities in web
applications. In CCS’10
[6] N. Bjørner. Integrating decision procedures for tempor al
veriﬁcation. Ph.D. thesis, Stanford University, 1999
[7] N. Bjørner, V. Ganesh, R. Michel and M. Veanes. An
SMT-LIB Format for Sequences and Regular Expressions. In
SMT workshop 2012 .
[8] N. Bjørner, N. Tillmann and A. Voronkov. Path Feasibilit y
Analysis for String-Manipulating Programs. In TACAS’09 .
[9] A. Christensen, A. Møller, and M. Schwartzbach. Precise
analysis of string expressions. In SAS’03.
[10] V. Ganesh and D. L. Dill. A decision procedure for
bit-vectors and arrays. In CAV’07.
[11] V. Ganesh, M. Minnes, A. Solar-Lezama and M. Rinard.
Word equations with length constraints: what’s decidable?
InHVC’12.
[12] C. Guti´ errez. Solving Equations in Strings: On Makani n’s
Algorithm. In LATIN’98
[13] P. Hooimeijer and W. Weimer. A decision procedure for
subset constraints over regular languages. In PLDI’09.
[14] P. Hooimeijer and W. Weimer. Solving string constraint s
lazily. In ASE’10.
[15] J. Jaﬀar. Minimal and complete word uniﬁcation. In
Journal of the ACM 37(1), 47-85, 1990 .
[16] Y. Khmelevskii. Equation in free semigroups. In Trudy
Math. Inst. Steklov. 107 (1971); English Transl., Proc.
Steklov Inst. Math. 107 (1971) .
[17] A. Kiezun, V. Ganesh, P. Guo, P. Hooimeijer and M. Ernst.HAMPI: a solver for string constraints. In ISSTA’09 .
[18] G. Makanin. The problem of solvability of equations in a
free semigroup. In Mathematics of the USSR-Sbornik, 1977,
32, 129.
[19] L. Moura and N. Bjørner. Z3: An Eﬃcient SMT Solver. In
TACAS’08 .
[20] W. Plandowski. An eﬃcient algorithm for solving word
equations. In STOC’06 .
[21] G. Redelinghuys, W. Visser and J. Geldenhuys. Symbolic
execution of programs with strings. In SAICSIT’12 .
[22] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant
and D. Song. A Symbolic Execution Framework for
JavaScript. In SP’10.
[23] K. Schulz. Word uniﬁcation and transformation of
generalized equations. In J. Autom. Reason. 11(2):149-184,
1993.
[24] D. Shannon, I. Ghosh, S. Rajan and S. Khurshid. Eﬃcient
symbolic execution of strings for validating web applicati ons
InDEFECTS’09 .
[25] F. Sun, L. Xu and Z. Su. Static detection of access contro l
vulnerabilities in web applications. In USENIX Security’11 .
[26] T. Tateishi, M. Pistoia and O. Tripp. Path- and index-
sensitive string analysis based on monadic second-order
logic. In ISSTA’11 .
[27] M. Veanes, P. Halleux and N. Tillmann. Rex: Symbolic
Regular Expression Explorer. In ICST’10 .
[28] M. Veanes, N. Bjørner and L. Moura. Symbolic automata
constraint solving. In LPAR-17 .
[29] M. Veanes and N. Bjørner. Symbolic Automata: The
Toolkit. In TACAS’12 .
[30] F. Yu, T. Bultan and O. Ibarra. Symbolic String
Veriﬁcation: Combining String Analysis and Size Analysis
InTACAS’09 .
[31] F. Yu, M. Alkhalaf and T. Bultan. Stranger: An
Automata-based String Analysis Tool for PHP. In
TACAS’10 .
[32] Y. Zheng and X. Zhang. Static Detection of Resource
Contention Problems in Server-Side Scripts. In ICSE’12 .
[33] Y. Zheng and X. Zhang. Path Sensitive Static Analysis of
Web Applications for Remote Code Execution Vulnerability
Detection. In ICSE’13 .124
View publication stats