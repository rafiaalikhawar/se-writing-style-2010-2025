Jens Knoop, Uwe Zdun (Hrsg.): Software Engineering 2016,
Lecture Notes in Informatics (LNI), Gesellschaft f ¨ur Informatik, Bonn 2016 69
An Empirical Study on Program Comprehension with
Reacti veProgramming
Guido Salvaneschi, Sven Amann, Sebastian Proksch, and Mira Mezini1
Abstract:
Starting from the ﬁrst in vestigations with strictly functional languages, reacti veprogramming has
been proposed as the pr ogramming paradigm for reacti veapplications. The advantages of designs
based on this style overdesigns based on the Observer design pattern ha vebeen studied for along
time. Over the years, researchers ha veenriched reacti velanguages with more powerful abstractions,
embedded these abstractions into mainstream languages –including object-oriented languages –and
applied reacti veprogramming to se veral domains, lik eGUIs, animations, Webapplications, robotics,
and sensor networks. Howe ver,an important assumption behind this line of research –that, beside
other advantages, reacti veprogramming makes awide class of otherwise cumbersome applications
more comprehensible –has ne verbeenevaluated. In this paper ,w ep resent the design and the results
of the ﬁrst empirical study that evaluates the effect of reacti veprogramming on comprehensibility
compared to the traditional object-oriented style with the Observer design pattern. Results conﬁrm
the conjecture that comprehensibility is enhanced by reacti veprogramming. In the experiment, the
reacti veprogramming group signiﬁcantly outperforms the other group.
Keywords: Reacti veProgramming, Controlled Experiment, Program Comprehension
Reacti veapplications are awide class of software that needs to respond to internal or ex-
ternal stimuli with aproper action. Examples of such applications include user-interacti ve
software, lik eGUIs and Webapplications, graphical animations, data acquisition from
sensors, and distributed event-based systems.
Over the last fe wyears, reacti veprogramming (RP) has gained the attention of researchers
and practitioners for the potential to express otherwise comple xreactivebehavior in intu-
itiveand declarati veway.RP has been ﬁrstly introduced in Haskell. Inﬂuenced by these
approaches, implementations of RP ha vebeen proposed in se veral widespread languages,
including Ja va,Javascript and Scala. Recently ,concepts inspired by RP ha vebeen applied
to production frame works lik eMicrosoft Reacti veExtensions (Rx), which recei vedgreat
attention after the Netﬂix success story .Finally ,alot of attention in the front-end de vel-
opers community is re vealed by the increasing number of libraries that implement RP
principles, among others React.js, Bacon.js, Knockout, Meteor ,and Reacti ve.coffee.
The rele vance of RP comes from the well-known complexity of reacti veapplications,
which are hard to de velop and understand, because of the mixed combination of data and
control ﬂo w.The Observer design pattern is widely used for such applications. It has the
advantage of decoupling observers from observables. But, when it comes to program read-
ability ,i tdoes not mak ethings easier ,because of dynamic registration, side effects in call-
1Technische Uni versit¨at Darmstadt, Fachbereich Informatik, Fachgebiet Softwaretechnik, Hochschulstr .10,
64289 Darmstadt, Deutschland, <lastname>@st.informatik.tu-darmstadt.de70 Guido Salvaneschi et al.
backs, and in version of control. In contrast, RP supports adesign based on data ﬂows and
time-changing values: the programmer states which relations should be enforced among
thevariables that compose areactiveprogram and the RP runtime takes care of perform-
ing all the required updates. Dependencies are deﬁned explicitly instead of being hidden
in the control ﬂo w.Combination can be guided by types as opposed to callbacks that re-
turn void. Contrarily to the Observer pattern, control is not in verted and less boilerplate
is required, since collecting dependencies and performing the updates is automatized by
the frame work. Based on these arguments, it has been argued that RP greatly impro ves
overthe traditional Observer pattern used in OO programming both from the softwar ede-
sign perspecti veas well as from the perspecti veoffacilitating the comprehensibility of the
software.
Yet, little empirical evidence has been provided in favoro ft he claimed advantages of RP
–especially enhancement of comprehensibility .Despite the intuition about its potential,
the reacti vestyle is not obviously more comprehensible than the Observer design pattern.
Forexample, in the Flapjax paper [Me09] aJavascript application based on Observer is
compared against afunctionally equi valent RP version. The authors argument that the RP
version is much easier to comprehend. Howe ver,the reader is warned that: “Obviously ,the
Flapjax code may not appear any ‘easier’ to aﬁrst-time reader” .Doubting, at this point,
is legitimate: does RP really mak ereactiveapplications easier to read? Also, it is unclear
howmuchexpertise is required to ﬁnd aR Pp rogram “easier” –i fe ver.
Toﬁll the gap, this paper provides the ﬁrst empirical evaluation of the impact of RP on pro-
gram comprehension compared to the traditional technique based on the Observer design
pattern. The experiment, based on the REScala language [SHM14], in volves 38 subjects
that where divided into an RP group and an OO group. The ywere shown areactiveappli-
cation and their understanding of the reacti vefunctionalities wasmeasured. Tothe best of
our knowledge, such astudy has ne verbeen conducted before. Results sho wthat (1) RP
increases correctness of program comprehension, (2) comprehending programs in the RP
style does not require more time than comprehending their OO equi valent, and (3) in con-
trast to OO where score results are correlated to programming skills, with RP (advanced)
programming skills are not needed to understand reacti veapplications. The last result sug-
gests that RP lowers the entrance barrier required to understand reacti veapplications.
References
[Me09] Meyerovich, Leo A.; Guha, Arjun; Baskin, Jacob; Cooper ,Gregory H.; Greenberg,
Michael; Bromﬁeld, Aleks; Krishnamurthi, Shriram: Flapjax: AProgramming Language
for Ajax Applications. In: Proceedings of the 24th ACMSIGPLAN Conference on Ob-
ject Oriented Programming Systems Languages and Applications. OOPSLA ’09, ACM,
NewYork, NY ,USA, pp. 1–20, 2009.
[SHM14] Salvaneschi, Guido; Hintz, Gerold; Mezini, Mira: REScala: Bridging Between Object-
oriented and Functional Style in Reacti veApplications. In: Proceedings of the 13th Inter-
national Conference on Modularity .MODULARITY ’14, ACM, Ne wYork, NY ,USA,
pp. 25–36, 2014.