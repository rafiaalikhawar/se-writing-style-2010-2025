Detecting Spurious Counterexamples Efﬁciently in
Abstract Model Checking
Cong Tian and Zhenhua Duan
ICTT and ISN Laboratory, Xidian University, Xi’an, 710071, P.R. China
fctian, zhhduan g@mail.xidian.edu.cn
Abstract —Abstraction is one of the most important strategies
for dealing with the state space explosion problem in model
checking. With an abstract model, the state space is largely
reduced, however, a counterexample found in such a model that
does not satisfy the desired property may not exist in the concrete
model. Therefore, how to check whether a reported counterex-
ample is spurious is a key problem in the abstraction-reﬁnement
loop. Particularly, there are often thousands of millions of states
in systems of industrial scale, how to check spurious counterex-
amples in these systems practically is a signiﬁcant problem. In
this paper, by re-analyzing spurious counterexamples, a new
formal deﬁnition of spurious path is given. Based on it, efﬁcient
algorithms for detecting spurious counterexamples are presented.
By the new algorithms, when dealing with inﬁnite counterex-
amples, the ﬁnite preﬁx to be analyzed will be polynomially
shorter than the one dealt by the existing algorithm. Moreover, in
practical terms, the new algorithms can naturally be parallelized
that makes multi-core processors contributes more in spurious
counterexample checking. In addition, by the new algorithms,
the state resulting in a spurious path ( false state ) that is hidden
shallower will be reported earlier. Hence, as long as a false state
is detected, lots of iterations for detecting all the false states will
be avoided. Experimental results show that the new algorithms
perform well along with the growth of system scale.
Index Terms —model checking, formal veriﬁcation, abstraction,
reﬁnement, parallel algorithm.
I. I NTRODUCTION
Model checking is an important approach to improve the
reliability of hardware, software, multi-agent systems, com-
munication protocols, embedded systems and so forth. The
term model checking was coined by Clarke and Emerson
[7], as well as Sifakis and Queille [19], independently. The
earlier model checking algorithms explicitly enumerated the
reachable states of the system in order to check the correctness
of the system. This restricted the capacity of model checkers
to systems with a few million states. Since the number of
states can grow exponentially with the number of variables,
early implementations were only able to handle small designs
and did not scale to examples with industrial complexity. To
combat this, various methods, such as abstraction [9], [10],
[11], [12], [13], partial order reduction [3], [4], ROBDD
[5], [6] and bounded model checking [8], etc. techniques
are applied to model checking to reduce the state space for
efﬁcient veriﬁcation. Thanks to these efforts, model checking
has been one of the most successful veriﬁcation approaches
which is widely adopted in industrial community.
Among the techniques for reducing the state space, ab-
straction is certainly one of the most important ones whichhas been widely used in software model checking. In several
software model checkers, SLAM [25], [26] and BLAST [27]
for instance, Counter-Example Guided Abstraction Reﬁne-
ment (CEGAR) [9], [10], [11], [12], [13] based abstract model
checking has been well implemented. Abstraction technique
preserves all the behaviors of a concrete system but may
introduce behaviors that are not present originally. Thus, if
a property (i.e. a temporal logic formula) is satisﬁed in the
abstract model, it will certainly be satisﬁed in the concrete
model. However, if a property is unsatisﬁable in the abstract
model, it may still be satisﬁed in the concrete model, and none
of the behaviors that violate the property in the abstract model
can be reproduced in the concrete model. In this case, the
counterexample is said to be spurious. Thus, when a spurious
counterexample is found, the abstraction should be reﬁned
in order to eliminate the spurious behaviors. This process is
repeated (called abstraction-reﬁnement loop) until either a real
counterexample is found or the abstract model satisﬁes the
property.
In the abstraction-reﬁnement loop, how to check whether
a reported counterexample is spurious is a key problem.
In [13], A LGORITHM SPLIT PATH is presented for checking
whether a counterexample is spurious, and a SAT solver is
employed to implement it [10], [11]. In S PLIT PATH, whether a
counterexample is spurious can be checked by detecting failure
states in the counterexample. If a failure state is found, the
counterexample is spurious, otherwise, the counterexample is
a real one. However, whether a state, say ˆsi, is a failure state
relies on the whole preﬁx of the counterexample hˆs0;ˆs1;;ˆsii.
Therefore, to check a counterexample  =hˆs0,ˆs1;;ˆsni, each
state in should be checked sequentially. Moreover, to check
a counterexample with inﬁnite length, a polynomial number of
unwinding of the loop in the inﬁnite path is required [12], [13].
For systems with a small state space, the polynomial number
of unwinding of the loop is tolerable. However, for systems
with large state space, i.e. a common software system, the
polynomial growth of the number of the states to be checked
might lead to the exhaustion of memory. Therefore, effective
algorithms for checking spurious counterexamples are signif-
icant in making abstract model checking to be practical.
In this paper, based on the deﬁnition of false states , spurious
paths are re-analyzed, and a new approach for checking
spurious counterexamples is proposed. With this approach,
whether a counterexample is spurious depends on the existence
offalse states in the counterexample. There are several merits978-1-4673-3076-3/13/$31.00 c2013 IEEE ICSE 2013, San Francisco, CA, USA202
of the new approach. First, instead of the preﬁx, to check
whether a state ˆsiisfalse is only up to ˆsi’s previous and
successor states in the counterexample. Based on this, for an
inﬁnite counterexample, the polynomial number of unwinding
of the loop can be avoided. Second, the algorithm can easily
be improved by detecting the heaviest false state such that a
number of model checking iterations can be saved in the whole
abstract-reﬁnement loop. Thirdly, the algorithm can naturally
be parallelled. This will largely improve the efﬁciency for
checking spurious counterexamples with thousands of millions
of states in big examples with industrial scale. Finally, the
algorithms analyze each state in the counterexample gradu-
ally by considering its previous and successor states. Thus,
some false states that are hidden shallower will be detected
easier. This will be useful in practise since in the whole
abstract-reﬁnement loop, anytime, one false state is enough
for the reﬁnement of the counterexample. We have developed
a counterexample checker containing both the new proposed
algorithms and the existing one. The tool is implemented on
randomly generated models in different scales. Experimental
results show that the new algorithms perform well along with
the growth of system scale.
The rest part of the paper is organized as follows. The
next section brieﬂy presents the preliminaries in abstraction-
reﬁnement. In Section 3, why spurious counterexamples oc-
cur is analyzed intuitively and A LGORITHM SPLIT PATH is
explained brieﬂy. In Section 4, a new formal deﬁnition of
spurious counterexample is given with respect to the deﬁnition
offalse states . Further, in Section 5, algorithms for checking
whether a counterexample in the abstract model is spurious are
presented. Experimental results are given in Section 6. Finally,
conclusions are drawn in Section 7.
II. R ELATED WORK
We focus on the Counter-Example Guided Abstraction
Reﬁnement, CEGAR, framework which was ﬁrst proposed by
Kurshan [18]. Based on the basic CEGAR, some variations
were given [11], [21], [10], [1], [16], [15], [14] in the past
years. Most of them use a model checker and try to get rid of
spurious counterexamples to achieve a concrete counterexam-
ple or a proof of the desired property. Recently, CEGAR was
also improved for the purpose of abstract model checking of
shared-variable concurrent programs [28], [29].
The closest works to ours are those where the abstract
models are obtained by making some of the variables invisible.
To the best of our knowledge, this abstraction method was
ﬁrst proposed by Clarke, etc. [11], [10]. With their approach,
abstraction is performed by selecting a set of variables (or
latches in circuits) to be invisible. In each iteration, a standard
Ordered Binary Decision Diagram (OBDD)-based symbolic
model checker is used to check whether or not the abstract
model satisﬁes the desired property which is described by a
formula in temporal logic. If a counterexample is reported by
the model checker, it is simulated with the concrete system
by a SAT solver. It tells us that the model is satisﬁable if the
counterexample is a real one, otherwise, the counterexampleis a spurious one and a failure state is found which is the
last state in the longest preﬁx of the counterexample that is
still satisﬁable. Subsequently, the failure state is used to reﬁne
the abstraction by making some invisible variables visible. In
the method given by Clarke, etc., A LGORITHM SPLIT PATH
is used to check whether a counterexample is spurious, and a
SAT solver is employed to implement it [10], [11]. S PLIT PATH
is carried out by detecting failure states in the counterexample.
If a failure state is found, the counterexample is spurious,
otherwise, the counterexample is a real one. With this method,
to check a counterexample with inﬁnite length, a polynomial
number of unwinding of the loop in the inﬁnite path is required
[12], [13].
III. A BSTRACTION AND REFINEMENT LOOP
As usual, a Kripke structure [2] is used to model a system.
LetV=fv1;;vngranging over a ﬁnite domain D[f?g
be the set of variables involved in a system. For any vi2V,
1in, a set of the valuations of viis deﬁned by vi=
fvi=djd2D[f?gg where vi=?means viis undeﬁned.
Further, the set of all the possible states of the system is
deﬁned by  =  v1 vnfor each vi2V. Let APbe
the set of propositions. A Kripke structure over APis a tuple
K=(S;I;R;L), where Sis the set of states (i.e. a state
inSis a valuation of variables in V),ISis the set of
initial states, RSSis the transition relation, L:S!2AP
is the labeling function. For convenience, s(v)is employed to
denote the value of vat state s. A path in a Kripke structure
is a sequence of states,  =hs1;s2;i, where s12S0and
(si;si+1)2Rfor any i1. For convenience, we use R(s)to
denote the set of direct successors of a state s2S,R(S0)the
set of direct successors of all states in S0. More generally,
Ri(s)means the set of states reachable from safter itimes
of transitions, and Ri(S0)the set of states reachable from all
states in S0after itimes of transitions.
There are several techniques for obtaining the abstract
models [16], [18], [20]. We follow the counterexample guided
abstraction and reﬁnement method proposed by Clarke, et al.
where abstraction is performed by selecting a set of variables
which are insensitive to the desired property to be invisible
[11]. Following the idea given in [11], we separate Vinto two
parts VVandVIsuch that V=VV[VI.VVstands for the set of
visible variables while VIdenotes the set of invisible variables.
Invisible variables are those we do not care about and will be
ignored when building the abstract model. In an original model
K=(S;S0;R;L), all variables are visible ( VV=V,VI=;). To
obtain an abstract model ˆK=(ˆS;ˆS0;ˆR;ˆL), some variables, e.g.
VXV, are selected to be invisible ( VV=VnVX,VI=VX).
Thus, the set of all possible states in the abstract model will
be:ˆ =  v1 vk, where k=jVVj, and for each 1ik,
vi2VV. For a state s2Sand a state ˆs2ˆS,ˆsis called the
mapping of sin the abstract model by selecting VVas the set
of visible variables iff s(v)=ˆs(v)for all v2VV. Formally,
ˆs=h(s;VV)is used to denote that ˆsis the mapping of sin the
abstract model by selecting VVas the set of visible variables.203Inversely, sis called the origin of ˆs, and the set of origins of
ˆsis denoted by h (ˆs;VV).
Therefore, given an original model K=(S;S0;R;L)and
a selected set of visible variables VV, an abstract model
ˆK=(ˆS;ˆS0;ˆR;ˆL)can be obtained by Algorithm A BSTRACT
as shown below.
Algorithm 1 : ABSTRACT (K;VV)
Input : an original model K=(S;S0;R;L)and a set of selected
visible variables VV
Output : an abstract model ˆK=(ˆS,ˆS0,ˆR,ˆL)
1:ˆS=fˆs2ˆjthere exists s2Ssuch that h(s;VV)=ˆsg;
2:ˆS0=fˆs2ˆSjthere exists s2S0such that h(s;VV)=ˆsg;
3:ˆR=f( ˆs1;ˆs2)jˆs1;ˆs22ˆS;and there exist s1;s22
Ssuch that h(s1;VV)=ˆs1;h(s2;VV)=ˆs2and(s1;s2)2
Rg;
4:ˆL(ˆs)=S
s2S;h(s;VV)=ˆsL(s);
5:return ˆK=(ˆS;ˆS0;ˆR;ˆL);
Example 1: As illustrated in Fig. 1, the concrete model
is a Kripke structure with four states. Initially, the system
s1 s2 s3 s4
v1= 0
v2= 0v1= 1
v2= 1v1= 0
v2= 0v1= 1
v2= 1
v3= 0
v4= 0v3= 0
v4= 1v3= 1
v4= 0v3= 1
v4= 1V={v1, v2, v3, v4}
VV={v1, v2}
VI={v3, v4}ˆs1 ˆs2v1= 1
v2= 1v1= 0
v2= 0
OriginalAbstract
{q} {p} {r, q} {p}{p, q} {p, q, r }
Fig. 1. Abstraction function
has four variables v1,v2,v3andv4. Suppose that v3andv4
are selected to be invisible. By A LGORITHM ABSTRACT , an
abstract model with two states is obtained. In the abstract
model, ˆs1is the mapping of s1ands2, while ˆs2is the mapping
ofs3and s4.( ˆs1;ˆs2)2ˆRsince (s2;s3)2R, and ( ˆs1;ˆs1),
( ˆs2;ˆs2)2ˆRbecause of (s1;s2)and(s3;s4)2R. 
After the abstract model is obtained, a model checker is
utilized to check whether the abstract model can satisfy the
desired property. If the property is satisﬁed, the (original)
system can satisfy the property. Nevertheless, if the property is
unsatisﬁable in the abstract model, it may still be satisﬁed in
the concrete model, and none of the behaviors that violate the
property in the abstract model can be reproduced in the con-
crete model. In this case, the counterexample is spurious. Thus,
when a spurious counterexample is found, the abstraction
should be reﬁned in order to eliminate the spurious behaviors.
This process is repeated (abstraction-reﬁnement loop) until
either a real counterexample is found or the abstract model
satisﬁes the property.The abstraction-reﬁnement loop is depicted in Fig.2.
Initially, the abstract model M0is obtained by the abstrac-
Abstract h Model Checker¬P
M M′ No errors
Counterexample
Check SpuriousReal counterexample Spurious
ReﬁnementM′′
Fig. 2. Abstraction reﬁnement loop
t algorithm. Then a model checker is employed to check
whether or not the abstract model satisﬁes the desired property.
If no errors are found, the model is correct. Otherwise,
a counterexample is reported and rechecked by a spurious
checker which is used to check whether a counterexample
is spurious. If the counterexample is not spurious, it will
be a real counterexample that violates the system property;
otherwise, the counterexample is spurious, and a reﬁning tool
is used to reﬁne the abstract model [11], [13], [15], [17],
[21]. Subsequently, the reﬁned abstract model is checked by
the model checker again until either a real counterexample is
found or the model is checked to be correct. In this paper, we
concentrate on the how to check whether a counterexample is
spurious (the green part in Fig.2). Several methods about how
to reﬁne an abstract model can be found in [13], [17], [23],
[24].
IV. S PURIOUS PATHS
To check a spurious counterexample efﬁciently, we ﬁrst
show why spurious paths occur intuitively by an example.
Then we brieﬂy present the basic idea of A LGORITHM S-
PLIT PATH which is used in [12], [13] for checking whether a
counterexample is spurious.
A. Why Spurious Paths?
Abstraction technique preserves all the behaviors of the con-
crete system but may introduce behaviors that are not present
originally. Therefore, when checking the abstract model using
a model checker, some reported counterexamples might not
be real counterexamples that violate the desired property.
This problem can intuitively be illustrated by the trafﬁc lights
controller example [13].
Example 2: For the trafﬁc light controller system in the
l.h.s of Fig.3 involving variables color andstate , by making
variable color to be invisible, an abstract model can be
obtained as shown in the r.h.s of Fig.3. We want to prove
^(state =stop)(any time, the state of the light will be stop
sometimes in the future). By implementing a model checker
on the abstract model, a counterexample, hˆs1;ˆs2;ˆs2;ˆs2;iwill
be reported. However, in the concrete model, such a behavior
cannot be found. So, this is not a real counterexample. 204color =redstate =stop
color =yellow
state =go
color =green
state =gostate =stop
state =goOriginal model Abstract model
s1
s2
s3ˆs1
ˆs2Fig. 3. Trafﬁc Light Controller
B. Exposition of Algorithm SPLIT PATH
In [13], A LGORITHM SPLIT PATH is presented for checking
whether a ﬁnite counterexample is spurious. We present it
formally below.
Let =hˆs0;ˆs1;;ˆsnibe a ﬁnite counterexample in an
abstract model. The basic idea of A LGORITHM SPLIT PATH is
to compute the set of reachable states Miin each h ( ˆsi;VV)
(0in) from Iunder the following two conditions:
(1) for each i(1in), any state s2Miis reachable from
each Mk(0ki 1); and
(2) for each i(1in), any state s2Mi, and (s0;s)2R, it
has either s02Miors02Mi 1.
Formally, Mk
0,k0, can be computed by:
M0
0= I\h ( ˆs0;VV)
M1
0= R(M0
0)\h ( ˆs0;VV)
M2
0= R(M1
0)\h ( ˆs0;VV)

Mk
0= R(Mk 1
0)\h (ˆs0;VV)
Then, we have M0=1S
k=0Mk
0. Similarly, for each 1in,Mk
i
(k0) can be computed by:
M0
i= R(Mi 1)\h ( ˆsi;VV)
M1
i= R(M0
i)\h ( ˆsi;VV)
M2
i= R(M1
i)\h ( ˆsi;VV)

Mk
i= R(Mk 1
i)\h ( ˆsi;VV)
Accordingly, Mi=1S
k=0Mk
i.
Note that there must exist a natural number m, such that
m+1S
k=0Mk
i=mS
k=0Mk
isince h ( ˆsi;VV)is ﬁnite. Intuitively, each state
inMiis reachable from I,M0,,Mi 1; and cannot pass
through any state outside of M0,,Mi 1, and Mi.
For some state ˆsk,k1, ifMk=;,ˆsk 1is called a
failure state . To check whether a ﬁnite counterexample is
spurious, M0,M1,M2, are computed in turn until the
ﬁrst state ˆskwhere Mk=;is found, or the last state in the
counterexample is reached. The following example illustrates
how A LGORITHM SPLIT PATH works.
Example 3: Fig.3 depicts a Kripke structure and a coun-
terexample,hˆs0;ˆs1;ˆs2;ˆs3;ˆs4i, in the abstract model. In this
ˆs0 ˆs1ˆs2ˆs3 ˆs4
01
234
578
69
13
14151110
12
1617
18
19
222120
2324
25
26
2732
33302829
3110Fig. 4. Algorithm S PLIT PATH
counterexample, I=f0g.
M0
0=I\h ( ˆs0;VV)=f0g
M1
0=R(M0
0)\h ( ˆs0;VV)=f1;2g
M2
0=R(M1
0)\h ( ˆs0;VV)=f3g
M3
0=R(M2
0)\h ( ˆs0;VV)=;
Thus, M0=M0
0[M1
0[M2
0[M3
0=f0;1;2;3g.
M0
1=R(M0)\h ( ˆs1;VV)=f6g
M1
1=R(M0
1)\h ( ˆs1;VV)=f8g
M2
1=R(M1
1)\h ( ˆs1;VV)=;
It has M1=M0
1[M1
1[M2
1=f6;8g. Further,
M0
2=R(M1)\h ( ˆs2;VV)=f11g
M1
2=R(M0
2)\h ( ˆs2;VV)=f10;12g
M2
2=R(M1
2)\h ( ˆs2;VV)=;
So,M2=M0
2[M1
2[M2
2=f10;11;12g.
M0
3=R(M2)\h ( ˆs3;VV)=f20;21g
M1
3=R(M0
3)\h ( ˆs3;VV)=f23g
M2
3=R(M1
3)\h ( ˆs3;VV)=;
Hence, M3=M0
3[M1
3[M2
3=f20;21;23g.
M0
4=R(M3)\h ( ˆs4;VV)=;
So,M4=M0
4=;. Therefore, M4is an empty set and ˆs3is a
failure state . In Fig.3, M0,M1,M2,M3, and M4are the set of
blue nodes in ˆs0,ˆs1,ˆs2,ˆs3, and ˆs4, respectively. The failure
state is depicted in red circle. 
For inﬁnite counterexamples, it is more complicated to
dealing with since the last state in the counterexample can
never be reached. Thus, a polynomial number of unwinding
of the loop in the counterexample is needed [13]. That is,
an inﬁnite counterexample can be reduced to a ﬁnite one
by unwinding the loop for a polynomial number of times.
Accordingly, S PLIT PATH can be used again to check whether
this inﬁnite counterexample is spurious.
In a counterexample, there may exist more than one states
that make the path to be spurious. In fact, by A LGORITHM
SPLIT PATH, always, the only failure state (if it exists) is
detected. However, in abstraction-reﬁnement loop, the elim-
ination of any state that makes the counterexample to be
spurious will be enough for the reﬁnement of the abstract
model. Therefore, it is unnecessary to detect only the failure
state in the counterexample for the reﬁnement.205C. Algorithm Analysis
For a ﬁnite counterexample, A LGORITHM SPLIT PATH is
linear in the size1of the counterexample. Nevertheless, for
an inﬁnite counterexample, A LGORITHM SPLIT PATH is poly-
nomial in the size2of the counterexample since an inﬁnite
counterexample is reduced to a ﬁnite one by unwinding
the loop for polynomial number of times. Moreover, in the
veriﬁcation of systems with industrial scale, it is possible that
a counterexample contains thousands of millions of states.
So how to make A LGORITHM SPLIT PATH more practical is
signiﬁcant in abstract model checking.
V. Y ETANOTHER DEFINITION OF SPURIOUS
COUNTEREXAMPLES
In [11], [17], a spurious counterexample is described by: a
counterexample in the abstract model which does not exist in
the concrete model. By the analysis in the previous section,
it can be preciously deﬁned by: a counterexample with one
failure state . In this section, we redeﬁne spurious counterex-
amples from another aspect.
For convenience, In0
ˆsi,In1
ˆsi,, and Inn
ˆsiare deﬁned:
In0
ˆsi=fsjs2h ( ˆsi;VV);s02h ( ˆsi 1;VV)and
(s0;s)2Rg
In1
ˆsi=fsjs2h ( ˆsi;VV);s02In0
ˆsiand(s0;s)2Rg

Inn
ˆsi=fsjs2h ( ˆsi;VV);s02Inn 1
ˆsiand(s0;s)2Rg
Then we have Inˆsi=1S
i=0Ini
ˆsi. Here In0
ˆsidenotes the set of
states in h ( ˆsi;VV)with inputting edges from the states in
h ( ˆsi 1;VV), and In1
ˆsistands for the set of states in h ( ˆsi;VV)
with inputting edges from the states in In0
ˆsi, and In2
ˆsimeans
the set of states in h ( ˆsi;VV)with inputting edges from the
states in In1
ˆsi, and so on. Thus, Inˆsidenotes the set of states in
h ( ˆsi;VV)that are reachable from some state in h ( ˆsi 1;VV)
as illustrated in the lower irregular shape in Fig.5. Note that
there must exist a natural number n, such thatn+1S
i=0Ini
ˆsi=nS
i=0Ini
ˆsi
since h ( ˆsi;VV)is ﬁnite. Particularly, for state ˆs0,
In0
ˆs0=fsjs2(h ( ˆs0;VV)\I)g
In1
ˆs0=fsjs2h ( ˆs0;VV);s02In0
ˆs0and(s0;s)2Rg

Inn
ˆs0=fsjs2h ( ˆs0;VV);s02Inn 1
ˆs0and(s0;s)2Rg
That is only In0
ˆs0is deﬁned differently since ˆs0has no previous
states.
Symmetrically, Out0
ˆsi,Out1
ˆsi,, and Outn
ˆsiare also deﬁned.
1The size of a ﬁnite counterexample can be measured by the length of the
counterexample as well as the number of states in the original model that are
involved in the counterexample.
2The size of an inﬁnite counterexample is measured by the number of
individual states in the counterexample as well as the number of states in the
original model that are involved in the counterexample.
Fig. 5. InˆsiandOut ˆsi
Out0
ˆsi=fsjs2h ( ˆsi;VV);s02h ( ˆsi+1;VV)and
(s;s0)2Rg
Out1
ˆsi=fsjs2h ( ˆsi;VV);s02Out0
ˆsiand(s;s0)2Rg

Outn
ˆsi=fsjs2h ( ˆsi;VV);s02Outn 1
ˆsiand(s;s0)2Rg
Thus, Out ˆsi=1S
i=0Outi
ˆsi. Here Out0
ˆsidenotes the set of states in
h ( ˆsi;VV)with outputting edges to the states in h ( ˆsi+1;VV),
andOut1
ˆsistands for the set of states in h ( ˆsi;VV)with out-
putting edges to the states in Out0
ˆsi, and Out2
ˆsimeans the set of
states in h ( ˆsi;VV)with outputting edges to the states in Out1
ˆsi,
and so on. Thus, Out ˆsidenotes the set of states in h ( ˆsi;VV)
from which some state in h ( ˆsi+1;VV)are reachable as depicted
in the higher iregular shape in Fig.5. Similar to Inˆsi, there
must exist a natural number n, such thatn+1S
i=0Outi
ˆsi=nS
i=0Outi
ˆsi.
It is also pointed out that for the last state ˆsnin a ﬁnite
counterexample,
Out0
ˆsn=fsjs2h ( ˆsn;VV)\Fg
Out1
ˆsn=fsjs2h ( ˆsn;VV);s02Out0
ˆsn;and(s;s0)2Rg

Outn
ˆsn=fsjs2h ( ˆsn;VV);s02Outn 1
ˆsn;and(s;s0)2Rg
where Fis the set of states without any successors in the
original model.
Based on the deﬁnitions of InˆsiandOut ˆsi, ifInˆsi\Out ˆsi=;,
is spurious obviously since ˆsi 1cannot reach to ˆsi+1through
ˆsi.
Example 4: Fig.6 shows a spurious counterexample where
Inˆ2=f9g,Out ˆ2=f7g, and Inˆ2\Out ˆ2=;. Obviously,hˆ0;ˆ1;ˆ2;ˆ3i
is a spurious counterexample that does not exist in the original
model. 
However, for each state ˆsiin a counterexample such
thatInˆsi\Out ˆsi,;,may still be spurious. For instance,
Fig.7 shows a counterexample without any state ˆsi(i=0,
1, or 2) such that Inˆsi\Out ˆsi=;(Inˆs0\Out ˆs0=fs1;s2g,
Inˆs1\Out ˆs1=fs5g, and Inˆs2\Out ˆs2=fs6g). Nevertheless,
this counterexample is obviously a spurious one because green
states are not reachable from the red ones.2061
2
34
5
67
8
910
11
12ˆ0 ˆ1 ˆ2 ˆ3Fig. 6. A spurious path where Inˆ2\Out ˆ2=;
s1s2s3 s4 s5 s6ˆs0 ˆs1 ˆs2
In( ˆs0) ={s1, s2}
Out( ˆs0) ={s1, s2, s3}In( ˆs1) ={s4, s5}
Out( ˆs1) ={s5}In( ˆs2) ={s6}
Out( ˆs2) ={s6}
In( ˆs0)∩Out( ˆs0) ={s1, s2}In( ˆs1)∩Out( ˆs1) ={s5}In( ˆs2)∩Out( ˆs2) ={s6}
Fig. 7. A spurious path
LetEi=Inˆsi\Out ˆsifor each 0in. As illustrated
in Fig.8, given a counterexample with Inˆsi\Out ˆsi,;for
ˆsi
Inˆsi Out ˆsi Eiˆsi−1
In ˆsi−1Out ˆsi−1 Ei−1ˆsi+1
In ˆsi+1 Out ˆsi+1 Ei+1
Fig. 8. Checking spurious counterexamples
each state ˆsiin, to check whether is spurious, we need to
further checkhE0;E1;;Eniagain similar tohˆs0;ˆs1;;ˆsniby
treating each of E0,E1,,Enas a state. This process will be
repeated until In(Ei)=Out(Ei)(i.e.Ei=In(Ei)\Out(Ei)will
keep unchanged) for each i, orIn(Ei)\Out(Ei)=;for some
i. In case In(Ei)=Out(Ei)for each i, the counterexample
is a real one; otherwise, if there exists some isuch that
In(Ei)\Out(Ei)=;, the counterexample is a spurious one. For
instance, for the counterexample in Fig.7, we need to further
checkhE0;E1;E2ias illustrated in Fig. 9. Note that here E0,
s1s2 s5 s6E0 E1 E2
In(E0) ={s1, s2}
Out(E0) =∅
In(E0)∩Out(E0) =∅In(E1) =∅
Out(E1) =s5
In(E1)∩Out(E1) =∅In(E2) ={s6}
Out(E2) =s6
In(E2)∩Out(E2) ={s6}
Fig. 9. A spurious path
E1, and E2equals to Inˆs0\Out ˆs0=fs1;s2g,Inˆs1\Out ˆs1=fs5g,andInˆs2\Out ˆs2=fs6gin Fig. 7, respectively. By computing
In(Ei)\Out(Ei),i=0,1, or 2, it can be obtained that the
counterexample is spurious since In(Ei)\Out(Ei)=;for
both i=0and1.
The above procedure for checking whether a counterexam-
ple is spurious is intuitively illustrated in Fig. 10. For clarity,
we use Ej
i(j1) as a temporal variable to record the result
ofIn(Ej 1
i)\Out(Ej 1
i). Here the superscript j0indicates
the times of the run. In the 0th run, for each 0in,E0
iis
assigned with h ( ˆsi;VV).
E0
0E0
1E0
2E0
3 · · · E0
n
E1
0E1
1E1
2E1
3 · · · E1
n
E2
0E2
1E2
2E2
3 · · · E2
n
· · ·0th run
1st run
2nd runE0
i=h−( ˆsi)
E1
i=In(E0
i)∩Out(E0
i)
E2
i=In(E2
i)∩Out(E1
i)
Fig. 10. Checking spurious counterexamples
For convenience, a state ˆsiwith In(Ej
i)\Out(Ej
i)=;
is called a false state . Further, given a false state ˆsiin a
counterexample ˆ, the set of the origins of ˆsi,h ( ˆsi;VV), is
divided into three sets, D=InEj
i(the set of dead states),
B=OutEj
i(the set of bad states) and I=h ( ˆsi;VV)n(D[B )
(the set of the isolated states). For instance, state ˆ2in Fig.
6 is a false state . Inh (ˆ2;VV), i.e.f7;8;9g,f9gis the set of
dead states,f7gthe set of bad states, and f8gthe set of isolated
states. In a counterexample hˆs0;;ˆsni, suppose ˆsiand ˆsjare
twofalse states with En
i=;andEm
j=;(m>n), respectively.
We call the false state ˆsiis hidden shallower than ˆsi. By the
above procedure, always, the shallowest false state is detected
if it exists.
Armed with these notations, a spurious counterexample is
formally deﬁned below.
Deﬁnition 1: (Spurious Counterexamples) A counterex-
ample ˆin an abstract model ˆKis spurious if, and only if,
there exists at least one false state inˆ. 
To conﬁrm the equivalence of the new deﬁnition of spurious
counterexamples with the original one, the following theorem
is proved.
Theorem 1: A counterexample is spurious if, and only if,
there exists at least one false state in .
Proof:): By the deﬁnitions of false states, if there exists a
false state in ,does not exist in the concrete model.
(: If there exist no false states in, it has E0,;,E1,;,
, and En,;for each 1in(by the deﬁnition of false
states). Thus, for each state s2Ei,sis reachable from Ei 1,
and can access to Ei+1since sis in both In ˆEi 1andOut ˆEi+1.207So, for each state in En, it is reachable from E0, through E0,
E1,, and En 1. Accordingly,hˆs0;ˆs1;;ˆsniexists in the
concrete model. 
VI. A LGORITHMS FOR CHECKING SPURIOUS
COUNTEREXAMPLES
Based on the new deﬁnition of spurious counterexamples,
algorithms for checking whether a counterexample is spurious
are presented in this section. Generally speaking, to check
whether a counterexample is spurious can be determined by
detecting the existence of false states in the path. If a false
state is found, the counterexample is spurious; otherwise, the
counterexample is a real one.
A. Detecting False States on hE0;;Eni
By the deﬁnition of spurious counterexamples based on
false states , to check whether a counterexample is spurious, we
need to detect the false states onhE0;;Eni, recursively. We
ﬁrst present A LGORITHM CHECK FALSE -I for checking false
states onhE0;;Eniin one run. A LGORITHM CHECK FALSE -
I takeshE0;;Enias input and outputs the ﬁrst detected false
state if it exists.
Algorithm 2 :CH E C K FA L S E -I(hE0;;Eni)
Input :hE0;;Eni
Output :the first detected false state sfin the
counterexample
1:Initialization :int i =0;
2:while indo
3: ifInˆEi\Out ˆEi,;,i=i+1;
4: else return sf=ˆsi; break;
5:end while
In A LGORITHM CHECK FALSE -I, to check whether a state
ˆsiis a false state only relies on ˆEi’s previous and successor
states, ˆEi 1and ˆEi+1; while in A LGORITHM SPLIT PATH, to
check state ˆsiis up to checking the whole preﬁx, hˆs0;;ˆsi 1i,
ofˆsi. Therefore, compared with A LGORITHM SPLIT PATH,
CHECK FALSE -I can be parallelized naturally as presented in
ALGORITHM CHECK FALSE -II.
In C HECK FALSE -II, anytime, if a false state is detected
by a processor, all the processors will stop and the false
state is returned. That is the algorithm always reports the ﬁrst
detected false state obtained by the processors. Note that a
boolean array c[n]is used to indicate whether a state in the
counterexample is a false one. Initially, for all 0in,c[i]
is?(c[i]is undeﬁned). c[i]==f alse means state ˆsiis afalse
state .
B. Checking Spurious Counterexamples
Based on the algorithms for detecting false states ,
ALGORITHM CHECK SPURIOUS -I is presented to check
whether a given (ﬁnite) counterexample is spurious. In
CHECK SPURIOUS -I, initially, E0,,Enis initialized by
h ( ˆs0;VV),,h ( ˆsn;VV), respectively; then C HECK FALSE -II
is called recursively until each of E0;;Enkeeps unchanged orafalse state is detected. To perform it, a Boolean array cwith
length n+1is utilized to memorize the situation of each Ei.
Ifc[k]==?, it means that currently neither InEk=Out Eknor
InEk\Out Ek=;. That is Ekneeds to be further updated with
InEk\Out Ek, and then InEk\Out Ekshould be recalculated.
Ifc[k]==true, it indicates that Ekwill keep unchanged
(ˆskcannot be a false state ). Any time, if InEk\Out Ek=;,
the algorithm will stop and a false state is returned. In case
c[k]==true for each k,hˆs0;;ˆsniis reported to be a real
counterexample.
Algorithm 3 :CHECK FALSE -II(ˆ)
Input :hE0;;Eni
n: the number of processors
k: processor id
Output :a false state sf
1:Initialization :bool c [n+1]=f?;;?g;
2:fork=0tondo in parallel do
3: ifInˆEk\Out ˆEk=;then
4: c[k]=f alse; return sf=ˆsk;
stop all processors;
5: end if
6:end for
Algorithm 4 :CH E C K SP U R I O U S -I(ˆ)
Input :hˆs0;;ˆsni
n: the number of processors
k: processor id
Output :a false state sf
1:Initialization :E0=h ( ˆs0);;En=h ( ˆsn);
bool c [n+1]=f?;;?g;
2:CHECK FALSE :
3:fork=0tonin parallel do
4: ifc[k]==?then
5: ifInEk\Out Ek=;,then
6: return sf=ˆsk; stop all processors;
7: end if
8: ifInEk\Out Ek=Ek,then
9: c[k]=ture;
10: end if
11: ifInEk\Out Ek,Ekand InEk\Out Ek,;,then
12: Ek=InEk\Out Ek;
13: end if
14: end if
15:end for
16:iffor all 0in,c[i]==ture, return ˆhas no
false states;
17:elsegoto CHECK FALSE ;
Note that a counterexample may be a ﬁnite path hs0;s1;
;sni,n0, or an inﬁnite path hs0;s1;;(si;;sj)!i,0
ij, with a loop sufﬁx (a sufﬁx produced by a loop). For
the ﬁnite one, it can be checked directly with A LGORITHM
CHECK SPURIOUS -I while for an inﬁnite one, we need only
to check its Complete Finite Preﬁx (CFP) hs0;s1;;si;;sji
since whether or not a state siis a false state only relies on
its previous and successor states. It is pointed out that in the208CFPhs0;s1;;si;;sjiof an inﬁnite counterexample,
Out0
ˆsj=fsjs2h ( ˆsj;VV);s02h ( ˆsi;VV)and(s;s0)2Rg
Out1
ˆsj=fsjs2h ( ˆsj;VV);s02Out0
ˆsjand(s;s0)2Rg
since the successor state of ˆsjisˆsi.
C. Algorithm for Detecting the Heaviest False State
In A LGORITHM CHECK SPURIOUS -I, always, the ﬁrst de-
tected false state is returned. Then further reﬁnement will be
done based on the analysis of this false state . Possibly, several
false states may occur in one counterexample, so which one
is chosen to be reﬁned is not considered. Obviously, if a false
state shared by more paths is reﬁned, a number of model
checking iterations are hopefully to be saved in the whole
abstract-reﬁnement loop.
Under this consideration, we will check the state shared by
more paths ﬁrst. To do so, for an abstract state ˆsas illustrated
in Fig.11, EIn(ˆs)andEOut (ˆs)are deﬁned. EIn(ˆs)equals to
ˆsEIn EOut
Fig. 11. In and out edges
the number of edges connecting to the states in h (ˆs;VV)from
the states outside of h (ˆs;VV); and EOut (ˆs)is the number of
edges connecting to the states out of h (ˆs;VV)from the states
inh (ˆs;VV). Accordingly, EIn(ˆs)EOut (ˆs)is the number of
the paths where ˆsoccurs. For convenience, we call EIn(ˆs)
EOut (ˆs)the weight of the abstract state ˆs.
In C HECK SPURIOUS -II, The counterexample is recursively
checked until each Eikeeps unchanged or is detected as a
false state . Then the heaviest false state is returned for further
reﬁnement. That is all the false states are detected out ﬁrst,
and then the heaviest one is returned.
D. Algorithm Analysis
Compared with A LGORITHM SPLIT PATH for detecting
failure states , to check whether a state is a false state by
ALGORITHM CHECK SPURIOUS -I only relies on its previous
and direct successor states. Thus when dealing with inﬁnite
counterexamples by A LGORITHM CHECK SPURIOUS -I, the
ﬁnite preﬁx to be checked will be polynomially shorter than
the one dealt by A LGORITHM SPLIT PATH. That is given an in-
ﬁnite counterexample, by A LGORITHM CHECK SPURIOUS -I,
the number of the states to be analyzed will be polynomial less
than the one to be considered by A LGORITHM SPLIT PATH.
Further, for the ﬁnite counterexamples, in each iteration, E0,
E1,,En, are checked in parallel. Also, the algorithms analyze
each state in the counterexample gradually by considering its
previous and successor states. Thus, some false states that are
hidden shallower will be detected earlier, and lots of iterations
can be avoided in practise.Algorithm 5 :CH E C K FA L S E -IV(ˆ)
Input :a counterexample ˆ=hˆs0;ˆs1;;ˆsniin the
abstract model ˆK=(ˆS;ˆS0;ˆR;ˆL), and the original
model K=(S;S0;R;L)in shared memory
n: the number of processors
k: processor id
Output :a false state sf
1:Initialization :E0=h ( ˆs0);;En=h ( ˆsn);
bool c [n+1]=f?;;?g;
2:CHECK FALSE :
3:fork=0tonin parallel do
4: ifc[k]=?then
5: ifInEk\Out Ek=;,then
6: c[k]=f alse;
7: end if
8: ifInEk\Out Ek=Ek,then
9: c[k]=ture;
10: end if
11: ifInEk\Out Ek,Ekand InEk\Out Ek,;,then
12: Ek=InEk\Out Ek;
13: end if
14: end if
15:end for
16:iffor each 0in,c[i],?,then
17: ifc[i]==ture for each ithen
18: return ˆhas no false states;
19: end if
20: ifc[i]==f alse and ˆsiis the heaviest one among
the false states then
21: return ˆsi;
22: end if
23:else
24: goto CHECK FALSE ;
25:end if
VII. E VALUATION
To evaluate the proposed approach, we implemented a
Counterexample Checker (called CC for short) ( http://web.
xidian.edu.cn/home/ctian/ﬁles/20120808 210955.zip ) that contain-
s both Algorithm C HECK SPURIOUS -I and S PLIT PATH for
checking spurious counterexamples. Note that here we do not
compare the results of Algorithm C HECK SPURIOUS -II with
CHECK SPURIOUS -I and S PLIT PATH since its advantages can
only be presented in the whole abstraction-reﬁnement loop.
To make the results more general, we (1) randomly generate
the original models by providing the numbers of states and
transitions; (2) achieve the abstract models by providing the in-
sensitive variables; and (3) select a path (i.e. counterexample)
randomly in the abstract model. Subsequently, we implement
Algorithm C HECK SPURIOUS -I and S PLIT PATH on the same
selected path, respectively, and record the time consumed by
both the two algorithms. We use Graphviz 2.28 [22] to display
the original and abstract models. Fig.12 (a) and (b) shows a
randomly generated model and its abstract model, respectively.
We just present small models, since for the ones containing
several thousands of states, the graphs are unclear.
The following experiments are performed on 4-core
PC. We randomly generate ﬁve models with the size209(a) Original model
(b) Abstract model
Fig. 12. Original and abstract models illustrated by Graphviz(s;t)being (10;50),(50;1250) ,(100;5000) ,(500;125000) ,
(1000 ;500000) ,(5000 ;13000000) ,(10000 ;50000000) , and
(50000 ;150000000) , respectively. Here smeans the number
of states while tthe number of transitions in the original
model. By selecting counterexamples at random, Algorithms
CHECK SPURIOUS -I are compared with Algorithm S PLIT-
PATH. The experimental data are recorded in Table VII and
the curves depicting the time consumed by the two algorithms
on different models are presented in Fig. 13. The vertical axis
depicts the size of the model, and the horizontal axis describes
the time (ms) used for checking whether or not the selected
path is spurious. From the table and the curves, it can be
seen that in case the scale of the model is small, because of
the expense in creating and destroying threads, the merit of
parallel algorithm is not obvious. However, as the scale of the
model grows, the advantages of the new algorithm turn out to
be evident.
TABLE I
RESULTS OF EXPERIMENT
Model Size SPLIT PATH CHECK SPURIOUS -I
States Transitions 5 models Average 5 Models Average
(number) (number) (ms) (ms) (ms) (ms)
2 4
3 4
10 50 3 2.4 4 4.4
2 5
2 5
2 5
3 6
50 1250 2 2.6 4 5.2
3 5
3 5
3 4
3 4
100 5000 3 3.2 4 3.4
4 4
3 5
4 4
6 5
500 125000 4 4.6 5 5
4 5
5 6
5 5
6 17
1000 500000 6 6 8 7.6
8 4
5 4
16 10
13 43
5000 13000000 15 14.8 5 16.8
15 13
15 13
61 45
50 64
10000 50000000 50 49.4 34 37.8
45 42
41 4
192 51
151 53
50000 180000000 218 174.8 89 58.42
201 42
112 57
VIII. C ONCLUSION
Based on the formal analysis of spurious paths, a new ap-
proach for detecting spurious counterexamples is presented in
this paper. With this approach, for an inﬁnite counterexample,210Fig. 13. Comparation between Algorithm CheckSpurious-I and SplitPath
the polynomial number of unwinding of the loop is avoided.
That is the ﬁnite preﬁx to be checked will be polynomially
shorter than the one checked by the existing algorithm. Be-
sides, for a given ﬁnite counterexample (or ﬁnite preﬁx of
an inﬁnite counterexample), the new algorithm still performs
well. The reasons are two: (1) The algorithm is parallelized
in each run for detecting false states ; (2) The shallowest
false state is always detected such that many iterations in the
algorithm will be avoided in practise.
The presented algorithms are useful in improving efﬁciency
of abstract model checking, especially CEGAR based abstract
model checking. In the near future, together with our pre-
vious results for reﬁning abstract models, the new proposed
algorithms will be implemented and integrated into several
model checkers such as SLAM and BLAST where CEGAR
is implemented. In addition, we will also investigates how
these algorithms can be applied in abstract model checking
of shared-variable concurrent programs.
ACKNOWLEDGMENT
Zhenhua Duan is the corresponding author. This research
is supported by the NSFC Grant No. 61003078, 61272117,
60910004, 61133001, 61272118, and 61202038, 973 Pro-
gram Grant No. 2010CB328102 and ISN Lab Grant No.
ISN1102001. We thank Wenqiang Fan in implementing the
counterexample checker CC.
REFERENCES
[1] P. Chauhan, E.M. Clarke, J. Kukula, S. Sapra, H. Veith, and D. Wang.
Automated Abstraction Reﬁnement for Model Checking Large State
Spaces Using SAT Based Conﬂict Analysis . Proc. Formal Methods in
Computer-Aided Design (FMCAD), 2002.
[2] S.A.Kripke. Semantical analysis of modal logic I: normal propositional
calculi , Z. Math. Logik Grund. Math. 9, 67-96, 1963.
[3] R. Kurshan, V . Levin, M. Minea, D. Peled and H. Yenig/in. Static partial
order reduction . In Tools for the Construction and Analysis of Systems,
LNCS 1394, pages 345C357, 1998.
[4] K.L. McMillan. A technique of state space search based on unfolding .
Formal Methods in System Design 6: 45-65, 1995.
[5] E.M. Clarke, O. Grumberg, D. Long. Veriﬁcation tools for ﬁnite state
concurrent systems . In A Decade of Concurrency-Reﬂections and Per-
spectives, LNCS 803, pages 124-175, 1993.
[6] K.L. McMillan. Symbolic Model Checking . Kluwer Academic Publishers,
1993.[7] E.M. Clarke and E.A.Emerson. Desigh and syntesis of of synchronization
skeletons using branching time temporal logic . In Logic of Programs:
Workshop, Yorktown Heights, NY , May 1981, LNCS 131, Springer, 1981.
[8] A. Biere, A. Cimatti, E.M. Clarke, O. Strichman, and Y . Zue. Bounded
Model Checking volume 58 of Advances in computers. Academic Press,
2003
[9] Edmund M. Clarke, Orna Grumberg, Somesh Jha, Yuan Lu, Helmut
Veith. Counterexample-guided abstraction reﬁnement for symbolic model
checking . J. ACM 50(5): 752-794 (2003)
[10] E.M. Clarke, A. Gupta, J.H. Kukula, and O. Strichman. SAT Based
Abstraction-Reﬁnement Using ILP and Machine Learning Techniques .
Proc. Computer-Aided Veriﬁcation (CA V), E. Brinksma and K.G. Larsen,
eds., pp. 265-279, 2002.
[11] E.M.Clarke, A. Gupta, O.Strichman. SAT Based Counterexample-Guided
Abstraction-Reﬁnement . IEEE Trans. Computer Aided Design, vol.23, no.
7, pp. 1113-1123, July 2004.
[12] E. Clarke, O. Grumberg, S. Jha, Y . Lu, and H. Veith. Counterexample-
guided abstraction reﬁnement . Technical Report CMU-CS-00-103, Com-
puter Science, Carnegie Mellon University, 2000.
[13] E.M.Clarke, O.Grumberg, S.Jha, Y .Lu, and H.Veith. Counterexample
guided abstraction reﬁnement , in Proc. 12th Int. Conf. Computer-Aided
Veriﬁcation (CA V00), vol. 1855, E. Emerson and A. Sistla, Eds. New
York, 2000.
[14] S.G. Govindaraju, D.L. Dill. Counterexample-Guided Choice of Pro-
jections in Approximate Symbolic Model Checking . Proc. Intl Conf.
Computer-Aided Design (ICCAD), pp. 115-119, 2000.
[15] M. Glusman, G. Kamhi, S. Mador-Haim, R. Fraer, M.Y . Vardi. Multiple-
Counterexample Guided Iterative Abstraction Reﬁnement: An Industrial
Evaluation . Proc. Tools and Algorithms for the Construction and Analysis
of Systems (TACAS), pp. 176-191, 2003.
[16] T.A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy Abstraction .
Proc. Symp. Principles of Programming Languages, pp. 58-70, 2002.
[17] F. He, X. Song, W.N. N. Hung, M. Gu, J. Sun. Integrating Evolutionary
Computation with Abstraction Reﬁnement for Model Checking . IEEE
Trans. Computers 59(1): 116-126 (2010)
[18] R.P.Kurshan. Computer Aided Veriﬁcaton of Coordinating Processes.
Princeton Univ. Press, 1994.
[19] J.P.Quielle and J.Sifakis. Speciﬁcation and veriﬁcation of concurrent
systems in CESAR . In Proceedings of the 5th international symposium on
programming, pp.337-350, 1981.
[20] J. Rushby. Integrated formal veriﬁcation: Using model checking with
automated abstraction, invariant generation, and theorem proving . p-
resented at Theoretical and Practical Aspects of SPIN Model Check-
ing: Proc. 5th and 6th Int. SPIN Workshops. [Online]. Available: cite-
seer.nj.nec.com/rushby99integrated.html
[21] C. Wang, B. Li, H. Jin, G.D. Hachtel, F. Somenzi. Improving Ariadne’s
Bundle by Following Multiple Threads in Abstraction Reﬁnement . IEEE
Trans. Computer Aided Design, vol. 25, no. 11, pp. 2297-2316, Nov.
2006.
[22] The homepage of Graphviz. http://www.graphviz.org/.
[23] C. Tian, Z. Duan, N. Zhang. An efﬁcient approach for abstraction-
reﬁnement in model checking . Theoretical Computer Science,
doi:10.1016/j.tcs.2011.12.014, 2012.
[24] C.Tian and Z.Duan. Making Abstraction Efﬁcient in Model Checking.
The 17th Annual International Computing and Combinatorics Conference
(COCOON 2011) LNCS6842, 90-111, 2011.
[25] Thomas Ball and Rupak Majumdar and Todd Millstein and Sriram K.
Rajamani. Automatic predicate abstraction of C programs . IN PROC.
ACM PLDI, 2001, 203–213, ACM Press.
[26] T. Ball, E. Bounimova, R. Kumar, V . Levin. SLAM2: Static Driver
Veriﬁcation with Under 4% False Alarms . FMCAD 2010: 35-42.
[27] Thomas A. Henzinger, Ranjit Jhala, Rupak Majumdar, and Gregoire
Sutre. Software Veriﬁcation with Blast . Proceedings of the 10th SPIN
Workshop on Model Checking Software (SPIN), Lecture Notes in Com-
puter Science 2648, Springer-Verlag, pages 235-239, 2003.
[28] Alastair F. Donaldson, Alexander Kaiser, Daniel Kroening, Thomas
Wahl. Symmetry-Aware Predicate Abstraction for Shared-Variable Con-
current Programs . CA V 2011: 356-371
[29] Alastair F. Donaldson, Alexander Kaiser, Daniel Kroening, Michael
Tautschnig, Thomas Wahl. Counterexample-guided abstraction reﬁne-
ment for symmetric concurrent programs . Formal Methods in System
Design 41(1): 25-44 (2012)211