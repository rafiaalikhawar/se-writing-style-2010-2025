Derailer: Interactive Security Analysis for Web
Applications
Joseph P . Near, Daniel Jackson
Computer Science and ArtiÔ¨Åcial Intelligence Lab
Massachusetts Institute of Technology
Cambridge, MA
jnear@csail.mit.edu, dnj@mit.edu
ABSTRACT
Derailer is an interactive tool for nding security bugs in
web applications. Using symbolic execution, it enumerates
the ways in which application data might be exposed. The
user is asked to examine these exposures and classify the
conditions under which they occur as security-related or not;
in so doing, the user eectively constructs a specication of
the application's security policy. The tool then highlights
exposures missing security checks, which tend to be security
bugs.
We have tested Derailer's scalability on several large open-
source Ruby on Rails applications. We have also applied it
to a large number of student projects (designed with dier-
ent security policies in mind), exposing a variety of security
bugs that eluded human reviewers.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veri-
cation
Keywords
Web applications; security; static analysis.
1. INTRODUCTION
The web is fast becoming the most popular platform for
application programming, but web applications continue to
be prone to security bugs. Web apps are often implemented
in dynamic languages, using relatively fragile frameworks
based on metaprogramming. Most importantly, security
policies themselves tend to be ad hoc, and many security
bugs are the result of programmers simply forgetting to in-
clude vital security checks.
We propose a solution that avoids the need for new frame-
works or specications. Instead, it uses a combination of
symbolic evaluation and user interaction to help the pro-
grammer discover mistakes.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciÔ¨Åc permission
and/or a fee. Request permissions from permissions@acm.org.
ASE‚Äô14, September 15-19, 2014, Vasteras, Sweden.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3013-8/14/09 ...$15.00.
http://dx.doi.org/10.1145/2642937.2643012.This particular combination is motivated by two hypothe-
ses. First, web applications dier from traditional programs
in ways that improve the scalability of symbolic execution.
In particular, web applications typically use fewer loops and
simpler branching structures than traditional programs, min-
imizing the exponential behavior of symbolic execution. Sec-
ond, security policies tend to be uniform: sensitive data is
usually subject to security checks everywhere it is used, so
an access that is missing one of those checks is likely to be
a mistake.
Our approach considers web applications that accept re-
quests and respond with sets of resources obtained by query-
ing the database. Each response is characterized by the path
through the database leading to the resource, and the con-
trol ow of the application's code imposes a set of constraints
under which a particular resource is exposed to a client. We
call the combination of a path and a set of constraints an
exposure .
An automatic strategy for nding security bugs might en-
force that all exposures with the same path also share the
same set of constraints; if a security check is forgotten, a
constraint will be missing. But many constraints|like those
used to lter sets of results for pagination|have nothing to
do with security, and would cause an automatic strategy to
report many false positives.
Our approach therefore asks the user to separate con-
straints into those representing security checks and those
that are not security-related. In making this separation, the
user eectively constructs a specication of the desired secu-
rity policy|but by selecting examples, rather than writing
a specication manually. Our tool makes this process easy,
allowing the user to drag-and-drop constraints to build the
policy. The tool then highlights exposures missing a con-
straint from the security policy|precisely those that might
represent security bugs.
We have built a prototype tool implementing our proposed
approach. Called Derailer1, it performs symbolic execution
of a Ruby on Rails application to produce a set of exposures.
Derailer's symbolic execution is based on Rubicon [18], a
tool we previously built for specifying and checking security
properties of Rails applications. Rubicon was eective at
checking security policies, but our experience suggested that
completely specifying a security policy is dicult. Derailer
is therefore motivated by the desire to nd security problems
without requiring an explicit written specication.
1available for download at http://people.csail.mit.edu/
jnear/derailer
587
We evaluated Derailer on ve open-source Rails applica-
tions and 127 student projects. The largest of the open-
source applications, Diaspora, has more than 40k lines of
code, and our analysis ran in 112 seconds. The student
projects were taken from an access-control assignment in a
web application design course at MIT. Derailer found bugs
in over half of these projects; about half of those bugs were
missed during manual grading. The bugs we found sup-
ported our hypothesis: most bugs were the result of either a
failure to consider alternate access paths to sensitive data,
or forgotten access control checks.
The contributions of this paper include:
A lightweight scheme for detecting security vulnerabil-
ities in web applications, which involves (1) construct-
ing an abstraction of an application's behavior that
indexes the constraints under which resources can be
accessed by access path and action, (2) asking a user
to identify which constraints are security related, and
(3) displaying discrepancies that show cases in which
the same resource is guarded inconsistently across dif-
ferent actions.
Derailer, an implementation of this analysis for Ruby
on Rails applications with an interactive interface for
interpreting its results.
Two case studies, one providing evidence that Derailer
scales to real-world applications, and the other indicat-
ing that Derailer is helpful in nding security bugs.
A lightweight static analysis, based on our previous
work, that enumerates the ways in which data can ow
from the database to rendered pages in a web applica-
tion.
Section 2 introduces our approach by describing the use
of Derailer to discover a security bug in an example ap-
plication. Section 3 formalizes our analysis, while Section 4
contains details of Derailer's implementation. Section 5 con-
tains our case studies evaluating Derailer's scalability and
eectiveness, and Section 6 discusses related work. Finally,
Section 7 relates some conclusions.
2. USING DERAILER
Derailer uses an automatic static analysis to produce an
interactive visual representation of the exposures produced
by a Ruby on Rails web application. The tool displays the
constraints associated with each exposure, and allows the
user to separate the security-related ones from those unre-
lated to security. Then, Derailer highlights inconsistencies
in the implemented security policy by displaying exposures
lacking some security-related constraints.
To see how this works, consider the controller code in
Figure ??, taken from a student project. The application's
purpose is to allow users to create \note" objects and share
them with other users; users should not be able to view notes
whose creators have not given them permission. This code,
however, has a security bug: the \index" action correctly
builds a list (in line 2) of notes the current user has permis-
sion to view, but the \show" action displays a requested note
without checking its permissions (line 11). The application's
programmer assumed that users would follow links from the
index page|which does correctly enforce access control|to1 def index
2 @notes = Note.where(user: current user . id) +
Note.permissions. nd byuser id ( current user . id)
3
4 respond todojformatj
5 format.html # index.html.erb
6 format. jsonfrender json : @notes g
7 end
8 end
9
10 defshow
11 @note = Note.nd(params[:id ])
12
13 respond todojformatj
14 format.html # show.html.erb
15 format. jsonfrender json : @note g
16 end
17 end
Figure 1: Example Controller Code from Student
Project
view notes, and neglected the case in which the user requests
bypasses the \index" action and requests a specic note di-
rectly using the \show" action.
Figure 1 contains a sequence of screenshots demonstrat-
ing the use of Derailer to nd this security bug. In shot
(1), the user has expanded the \Note" node, which repre-
sents the note resource type, and then the \ fnote: Note
jnote.id in params[id] g.content" node, which is a resource
path rooted at the note type, representing a note's contents.
The \User" node represents the programmer-dened user re-
source, while\session"and\env"are system-dened resource
types containing information about the current session and
conguration environment.
Then, in shot (2), the user picks the \index" action from
the list of actions resulting in that exposure. When an ac-
tion is selected, the set of constraints governing the release
of that data by that action is displayed in the Constraints
area. In this case, the displayed constraint is \ note. user ==
current user ornote. permissions . nd byuser id ( current user . id) ,"
which says that the currently logged-in user must either be
the creator of or have permission to view all visible notes.
The user drags security-related constraints to the Filtered
Constraints area, which will eventually contain the complete
security policy of the application.
Dragging constraints to the Filtered Constraints area cau-
ses the nodes subject to those constraints to disappear, as
in shot (3). Once the Filtered Constraints area contains all
security-related constraints, remaining exposures of sensitive
information represent inconsistencies in the implemented se-
curity policies, and are likely to be bugs. In shot (4), the
\show" action remains, despite the ltered constraint; se-
lecting it, the user discovers that it is not subject to any
constraints at all.
We took the approach described in this section in using
Derailer to analyze 127 similar student projects from the
same course, and found bugs in nearly half of them. The
results of that experiment are described in Section 5.
3. MODEL
This section explains the fundamental model that under-
lies our approach. The model is important for several rea-
sons. First, understanding the model is a prerequisite to
588(1)The user has expanded the Note node and its child node representing the note's content, since this node
represents sensitive data.
(2)The user has selected the NotesController / index action, which can result in a note's content appearing
on a page. A constraint representing the security policy on a note's content appears in the Constraints area.
(3)The user has dragged the constraint that appears into the Filtered Constraints area. The NotesCon-
troller / index action disappears, because it is subject to a ltered constraint.
(4)The user has selected the remaining action, which remains visible because it is notsubject to the ltered
constraint. In fact, it is not subject to any constraints at all. This represents a security bug in the application.
Figure 2: Example Bug-nding Session using Derailer
589understanding the results the tool produces. Second, the
model is the basis of our implementation strategy, and in-
forms the assumptions made in our implementation. Third,
the model makes clear which aspects of web applications
make this problem more tractable than it would be for ar-
bitrary applications.
Clients issue requests that contain a binding of parameters
to values, and a choice of action2:
sigRequestf
params: Param!Value,
action : Action
g
There is no need to distinguish clients or represent client-
side state (such as cookies), since the analysis must be con-
servative and assume the worst (e.g. that a client could
manipulate a cookie). The model does not currently allow
for access control through client-side certicates or reliance
on signed cookies. The choice of HTTP method (eg, GET or
POST) need not be modeled, nor whether the request is syn-
chronous or asynchronous, since these factors do not impact
what we seek to analyze (namely what data is released in
response to a query). Nor do we need to distinguish how the
parameters are passed (in a form, query string, or JSON ob-
ject, eg); in Rails, and many other web frameworks, the re-
quest is accessed homogeneously through a single hashmap.
The response to a request is just a set of resources (to be
elaborated shortly):
sigResponsefresources: set Resource g
The internal state of the application is just a database
mapping paths to resources:
sigDatabasefresources: DBPath !Resourceg
A path is an abstraction of a general database query, rep-
resenting a navigation through the database's tables using
only the relational join. Such queries can be used to extract
any resource the database contains, and ltered to contain
only the desired results.
To represent these lters, we introduce constraints. A
constraint has a left and right side, each of which may be a
path, a parameter or a value, and a comparison operator:
sigConstraintf
left , right : DBPath + Param + Value,
operator : Operator
g
2The model is given in Alloy [12]. For readers unfamiliar with Alloy,
the following points may help. A signature (introduced by keyword
sig) introduces a set of objects; each eld of a signature introduces a
relation whose rst column is the set associated with the signature,
and whose remaining columns are as declared. Thus the declaration
sigRequestfparams: Param!Valueg
introduces a set Request (of request objects), and a ternary rela-
tion params on the sets Request, Param and Value; this relation can
viewed as a table with three columns. A tuple (r,p,v) in this relation
would indicate that in request r, parameter p has value v. Equiv-
alently, the signature can be thought of as a class with the elds
as instance variables; thus this eld declaration introduces, for each
request r a mapping r.params from parameters to values.
Signature extension introduces subsets. Thus
sigValueResource extends Resourcefvalue: Valueg
says that some resources are value resources, and introduces a relation
called value from value resources to values. Equivalently, the subsig-
nature can be viewed as if it were a subclass; thus a value resource vr
has a value vr.value.(In fact, constraints can have logical structure, and our
implementation puts constraints into conjunctive normal form.
This detail is not relevant, however, to understanding the
essence of the approach.)
The behavior of an application can now be described in
terms of two relations. Both involve a database (represent-
ing the pre-state, before execution of the action) and an
incoming request. The rst relates these to the resulting
response, and the second to a database (representing the
post-state, after execution of the action):
sigAppf
response: Database !Request!Response,
update: Database !Request!Database
g
An approximation to this behavior is inferred by static
analysis of the code, and consists of a set of \exposures" of
resources, with an exposure consisting of a path, an action,
and a set of constraints:
sigReportf
exposures: set Exposure
g
sigExposuref
path: DBPath,
action : Action,
constraints : set Constraint
g
The presence of an exposure in the report means that a set
of resources might be exposed under the given constraints.
Example. The exposure with path User.notes.content , ac-
tion update , and constraints User.notes. title = notetitle and
User.notes.owner = session. user would represent the set of con-
tent strings that might be exposed when the update action
is executed. The constraints limit the notes to those with a
title matching the notetitle parameter and that are owned
by the currently logged in user. The set of notes u.notes
associated with a user uneed not, of course, have user uas
their owner; a constraint such as the one we have here would
typically be used to ensure that while a user can read notes
shared by others, she can only modify notes she owns.
3.1 Analysis
Our analysis uses the application's code to obtain a set
of exposures. More precisely, it produces a superset of the
exposures for which some concrete database and request ex-
ists such that the application produces the concrete results
represented by the exposure.
fun symbolic analysis [app: App]: set Exposure f
fe: Exposurej
some db: Database, request: Request f
db. resources [e.path] inapp.response[db,
request ]. resources
request . action = e.action
e. constraints =fc: Constraintjholds [c, app]g
g
g
This specication says that for each exposure, some con-
crete database and request exist such that (1) the appli-
cation responds with the same resource as specied by the
exposure, (2) the exposure's action matches that of the re-
quest, and (3) the constraints associated with the exposure
are those enforced by the application's code. Our model
590does not dene the holds predicate, since it depends on the
semantics of the application's implementation language and
on the particular representation of constraints. Symbolic
execution satises this specication, since it uses the appli-
cation code directly to build the set of exposed resources
and the constraints associated with them.
3.2 Filtering
Our approach uses interaction with the user to build the
desired security policy and discover exposures that do not
obey it. We allow the user to choose a set of constraints rep-
resenting a candidate security policy and lter the set of ex-
posures based on those constraints. The result is exactly the
set of exposures missing one of the ltered constraints|in
other words, exposures for which a security check is missing.
fun lter [es : set Exposure,
cs : set Constraint ]: set Exposure f
fe ': Exposurej
some c: csjc !ine '. constraintsg
g
Our implementation satises this specication by simply
comparing each exposure's constraints against the ltered
set, and displaying those exposures missing a constraint from
that set.
4. IMPLEMENTATION
Derailer is implemented as a library for Ruby. Derailer
enumerates the application's actions, runs each one symbol-
ically to obtain a set of exposures, and organizes the expo-
sures for presentation to the user.
Rather than implement a standalone symbolic evaluator|
a dicult task for a large, under-specied, dynamic environ-
ment like Rails|we hijacked the existing Ruby runtime to
do symbolic execution. Derailer uses Ruby's metaprogram-
ming features to wrap the standard libraries of Ruby and
Rails in a thin layer that allows the existing code to com-
pute with symbolic values.
We pioneered this technique in our previous work on Ru-
bicon [18], which performed bounded verication of user-
dened properties on Rails applications. A more detailed
description of our symbolic evaluator is available as part of
that work; a formal description of our technique, including
an embedding in a simplied Ruby-like language with a for-
mal semantics and a proof that our technique produces the
same results as the standard approach to symbolic execu-
tion, is available in [19].
For completeness, we present a brief explanation of our
approach to symbolic execution, with a focus on the strat-
egy Derailer uses to explore all possible page requests and
extract the resulting exposures.
4.1 Symbolic Values
To add symbolic values to Ruby, we dene a class of sym-
bolic objects to represent the paths and constraints of Sec-
tion 3.class SymbolicObject
defmethod missing(meth,args)
Exp.new(meth, [ self] + args)
end
def==(oth)
Exp.new(:==, [ self, oth])
end
endclass Exp<SymbolicObject
def initialize (meth, args)
@meth = meth
@args = args
end
end
These objects use Ruby's method missing feature to re-
turn new symbolic objects whenever methods are invoked
on them.
x = SymbolicObject.new
y = SymbolicObject.new
x.foo(y)
)Exp(foo, [x, y])
x + y == y + x
)Exp(==, [Exp(+, [x, y]) , Exp(+, [y, x]) ])
Code rewriting. When a conditional expression de-
pends on a symbolic value, symbolic execution requires that
we execute both branches of the conditional and record both
possible results. Unfortunately, Ruby does not allow the
programmer to attach special behavior to conditionals, so
Derailer rewrites the application's code, transforming ifex-
pressions into calls to Derailer's own denition.
x = SymbolicObject.new
ifx.even? then
(x+1).odd?
end
)Exp( if, [Exp(even?, [x]) , Exp(odd?, [Exp(+, [x, 1]) ]) ])
Side eects. To support side eects, our symbolic eval-
uator must consider the fact that both branches of a condi-
tional may contain updates to the same variable. As such,
our strategy for executing conditionals must split the cur-
rent state and save both results. The new denition of if
introduced in our code rewriting performs this step, split-
ting the current state and recording the side eects of each
branch separately. It uses a Choice object to record the path
constraint causing the split and the results of both branches.
x = SymbolicObject.new
ifx.even? then x = 1
else x = 2 end
x
)Choice(Exp(even?, [x]) , 1, 2)
4.2 Rails
Figure 2 summarizes Derailer's symbolic execution archi-
tecture. Derailer enumerates the actions dened by the ap-
plication; for each one, Derailer constructs a symbolic re-
quest and runs the action symbolically. The set of symbolic
objects present on the resulting rendered pages is the set of
possible exposures for that action, which Derailer normalizes
and groups by resource type.
Wrapping ActiveRecord. Rails applications interact
with the database through ActiveRecord, an object-relational
mapper. ActiveRecord provides methods like \ nd" and
\all" to query the database. Given a \ User" class extend-
ing ActiveRecord, the following code nds users with the
name \Joe."
591wrappersymbolic
request
action
standard
librariespaths +
constraints
normalization +
grouping
exposuresFigure 3: Derailer's Architecture
User. nd :name )" Joe"
Derailer's analysis must produce results valid for allvalues
of the database, so database queries must return symbolic
values during analysis. To accomplish this, Derailer wraps
the Rails API to ignore the concrete database and return
symbolic objects instead. The query above, for example,
evaluates to:
Exp[User, [Exp(query, [name )" Joe" ])]]
Rendering. A Rails action serves a request in two steps:
rst, the code dened in the controller populates a set of
instance variables; then, Rails evaluates an appropriate tem-
plate |which may reference those instance variables|to pro-
duce an HTML string. Derailer wraps the Rails renderer
to extract the set of symbolic values that appear on each
rendered page. These values, along with the constraints at-
tached to them, contribute to the set of exposures resulting
from the action being executed.
Normalization. Derailer's interface allows the user to
explore candidate security policies through ltering, which
compares constraints syntactically. Since two constraints
can be logically equivalent but syntactically dierent, De-
railer attempts to normalize the set of constraints so that
whenever possible, two logically equivalent constraints will
also be syntactically equal.
Derailer uses two basic methods to accomplish its normal-
ization. First, calls to the ActiveRecord API are rewritten in
terms of the ndmethod, and queries are merged when pos-
sible. For example, User. nd (:name )'Joe'). lter (: role )
'admin') becomes User. nd (:name )'Joe', :role)'admin'). Sec-
ond, Derailer converts all constraints to conjunctive normal
form, eliminating issues like double negation.
4.3 Challenges
Both the dynamic nature of Ruby and the size of the Rails
library pose signicant challenges to standard symbolic ex-
ecution strategies. These challenges motivated our unique
solution.Rails is large and complicated. The Rails framework
is notoriously complicated|for many years, it was compati-
ble only with the standard MRI Ruby interpreter due to its
use of undocumented features. This provided the strongest
motivation for implementing our symbolic evaluator as a
Ruby library. It allows some code, such as Rails's cong-
uration code, to be run concretely, and at full speed. In
addition, using the standard Ruby interpreter gives us con-
dence that Derailer is faithful to the semantics of Ruby and
Rails, since it runs the actual implementations of both.
Ruby does not allow the redenition of condition-
als.Ruby provides facilities for metaprogramming, but they
are limited. When a conditional expression depends on a
symbolic value, symbolic execution requires that we execute
both branches, but Ruby does not allow the programmer
to attach special behavior to conditionals. Derailer rewrites
the application's code, transforming ifexpressions into calls
to Derailer code that runs both branches. This can result
in the exponential blowup characteristic of symbolic execu-
tion, so Derailer executes only the appropriate branch when
a conditional's condition is concrete.
Rails plugins use metaprogramming. Rails plugins
are extra libraries that can be included in applications to
provide additional functionality. The CanCan plugin, for
example, provides user authentication and access control|
features not built into Rails. Unfortunately, the use of metapro-
gramming in plugins often conicts with our own use of the
same technique. CanCan, for example, replaces many of Ac-
tiveRecord's query methods with versions that perform se-
curity checks. Since Derailer's versions of the same methods
are essentially specications of the default Rails behavior,
Derailer's replacement methods eliminate the extra security
checks introduced by CanCan.
Our solution is to allow Derailer's specications to be ex-
tended to match the functionality added by plugins. Using
this technique, adding CanCan's security checks is accom-
plished in just a few lines of Ruby code.
Rendering makes it dicult to extract the set of
symbolic values the user will actually see. Rails's
rendering mechanism is complicated, so we prefer to run its
implementation rather than specify its semantics manually;
since the output of rendering is a string containing HTML,
however, it is also dicult to reconstruct the set of symbolic
values from the renderer's output.
Our solution assumes that the set of objects receiving the
tosmethod|which converts an object into a string|during
rendering is exactly the set of objects appearing on the re-
sulting page. This is a conservative assumption, since while
a template may convert an object into a string and then
discard it (a situation we have yet to encounter in prac-
tice), Rails always calls toson objects appearing in tem-
plates. Under this assumption, we modify the tosmethod
of symbolic values so that each value keeps track of whether
or not it has been converted into a string, and run Rails's
renderer unmodied. After rendering has nished, Derailer
collects the set of symbolic values that have been converted
to strings, and returns them as the set of results.
4.4 Assumptions & Limitations
Our strategy for symbolic execution relies on several as-
sumptions. While we consider these assumptions reason-
able, some of them do imply corresponding limitations of
our analysis.
592App
lication
SLO
C
Ana
lysis Time
Exp
osures
Con
straints
Path
s/Const.
Redmine 32,011 95.5s 1536 59 26.0
FatFreeCRM 15,794 52.8s 2216 34 65.2
Diaspora 41,188 112.8s 2859 171 16.7
Amahi 10,561 23.1s 74 54 1.4
Selfstarter 2,450 8.1s 10 4 2.5
Figure 4: Results of Analyzing Five Popular Open-
source Rails Applications
Derailer assumes that tosis called on exposed ob-
jects. But since the Rails rendering engine calls tosau-
tomatically on every object that appears in a template, we
consider this a reasonable assumption.
Derailer doesn't handle symbolic string manipula-
tion. Derailer records manipulations performed on symbolic
strings, but cannot solve them. Fortunately, Rails applica-
tions tend to perform few string manipulations, especially
on objects drawn from the database, and almost never base
control ow on the results of those manipulations. We have
therefore not found Derailer's inability to solve string ma-
nipulation constraints to be a problem in practice.
Derailer assumes that all actions are reachable.
Rails uses routes to dene the mapping between URLs and
actions. Derailer ignores routes and simply analyzes all ac-
tions dened by the application. This strategy is an over-
approximation: it is possible for an action to exist without
a corresponding route, making the action dead code. But
the converse is nottrue: it is impossible for Derailer to miss
an exposure by ignoring some code that is actually live|
Derailer simply analyzes allthe code.
Derailer's ltering assumes that logically equiv-
alent constraints are syntactically equal. Determin-
ing logical equivalence is a dicult problem. Fortunately,
Rails applications tend to focus on querying the database
and formatting the results|they typically do not perform
complex arithmetic or string operations|so normalization
of database queries is usually enough to make logically equiv-
alent constraints also syntactically equal. And like the other
assumptions, this one is conservative: if the user lters based
on a constraint that is logically equivalent but notsyntacti-
cally equal to another one, the associated exposure will be
highlighted as notsatisfying the desired security policy|so
it is impossible to miss a security bug due to this assump-
tion.
Derailer assumes that the application under analy-
sis uses ActiveRecord. Derailer wraps the ActiveRecord
API to make database queries symbolic, but an application
that uses a dierent method to make database queries may
bypass this wrapping. The application may therefore have
access to concrete database data during analysis, meaning
the results will not generalize to all database values. But
since Derailer is intended for use by an application's devel-
oper, we assume that he or she will know whether or not the
application uses a database API other than ActiveRecord|
and if so, Derailer has a simple mechanism to provide a
specication of that API.5. EVALUATION
In evaluating Derailer, we sought answers to two basic
questions:
Does Derailer's analysis scale to real-world appli-
cations? To answer this question, the authors ran Derailer
on ve popular open-source Rails applications. Since all ap-
plications are well-tested and we do not know their intended
security policies, we did not expect to nd bugs. The results
show that Derailer's analysis scales to even quite large real-
world Rails applications.
Is Derailer useful in nding security bugs? To an-
swer this question, the authors used Derailer to examine 127
student assignments from a web application design course at
MIT. The assignment was open-ended, so the applications
had similar, but not identical, intended security policies.
The results show that Derailer was able to highlight signif-
icantly more security bugs than were found by the course's
teaching assistants during grading.
5.1 Scalability
We tested Derailer's scalability on ve open-source web
applications:
Redmine , a content-management system
Fat Free CRM , a customer-relationship management
system
Diaspora, a social networking platform
Amahi , a personal media server
Selfstarter , a crowdfunding platform
The results are summarized in Figure 3. All analyses n-
ished in less than two minutes, even in the case of Diaspora,
which has more than 40,000 lines of code.
All ve applications are popular and mature. The Dias-
pora project, for example, has been in development for more
than three years, has more than 250 contributors, and has
addressed more than 4000 led bugs. As such, we did not
expect to discover security bugs in these applications.
However, we did nd one bug in Diaspora|a situation
that causes a crash when the current user is not a friend of
the owner of a requested piece of data. If the bug causing the
crash were xed, a security bug would remain: the sensitive
data would be visible to the non-friend.
The larger open-source applications produced many exposures|
more than 3000, in the case of Diaspora. The relatively
small number of constraints, however, made constraint lter-
ing eective. Filtering by a single constraint often resulted
in a huge reduction in the number of visible paths, since
so many paths share some common constraints. The large
ratio of paths to constraints supports our hypothesis that
applications typically access data in only a small number of
consistent ways.
5.2 Bug-Finding
To evaluate Derailer's ability to nd security bugs, we ap-
plied it to 127 student assignments from 6.1703, a web ap-
plication design course at MIT. The course teaches design
principles and implementation strategies, and evaluates stu-
dents on a series of open-ended projects in which students
3http://stellar.mit.edu/S/course/6/fa13/6.170/
593Type of Bug No.
No access control implemented 15
No write control implemented 10
No read control implemented 27
Security bug in read control 13
Security bug in write control 17
Figure 5: Types of Bugs Found During Analysis of
Student Projects
051015202530
0 5 10 15 20 25No
. Projects
An
alysis Time (seconds)
Figure 6: Analysis Times for Student Projects
implement actual applications. Students are taught and ex-
pected to use Rails, and one of the topics covered is security.
The project asks students to implement access control for
a \Notes" application, which allows users to log in, write
short textual posts, and share them with others. The as-
signment requirements are purposefully vague: students are
expected both to design a security policy and to imple-
ment that policy. Each assignment must therefore be graded
against its own intended security policy, making it impossi-
ble to write a single specication for all assignments. The
existing grading process consists of a teaching assistant run-
ning the application and experimenting with its capabilities
in a browser, along with extensive code reivew. The teaching
assitants estimated that they spent an average of 30 minutes
grading each project.
The rst author, who was not a teaching assistant for this
course, used Derailer to evaluate all 127 student submis-
sions for this assignment. We used the constraints present
on Note accesses to infer the security policy the student in-
tended to implement, and then we looked for situations in
which those constraints were not applied. Our goal was not
to evaluate the policies the students had chosen|though
we found some that did not seem reasonable|but rather
to determine whether or not the students correctly imple-
mented those policies. These are the kind of bugs Derailer
is intended to nd: situations in which the programmer has
simply forgotten to enforce the intended security policy.
It took about ve minutes per student submission to in-
terpret the results of Derailer's analysis. For most projects,
we were able to determine the intended security policy af-
ter examining only one or two exposures; we spent roughly a024681012141618
0 2 4 6 8 10 12 14 16No
. Projects
Rat
io of Exposures to Constraints
Figure 7: Ratio of Exposures to Constraints in Stu-
dent Projects
minute assembling constraints into a description of that pol-
icy, and then another couple of minutes to decide whether
the highlighted exposures were security bugs. Since Derailer
points directly to the action responsible for each exposure,
conrming each bug in the student's code also took only a
couple of minutes.
5.2.1 Results
Figure 7 contains information about our analysis, includ-
ing average, minimums, and maximums for lines of source
code, analysis time, number of exposures generated during
analysis, and number of unique constraints applied to those
exposures. Figure 5 contains a histogram of analysis times,
showing that the vast majority of analyses took fewer than
10 seconds.
The average number of exposures generated by the anal-
ysis was 47. Projects with very few generated exposures
were instances in which the student had not completed the
project. Projects with a very large number of exposures|
the maximum was 236|generally used many dierent ways
to query the database for similar kinds of information. We
found it easy to distinguish these cases, because the Rails
API places heavy emphasis on making database queries human-
readable.
The average number of unique constraints was only 12,
and the average ratio of exposures to constraints was 3.1
(meaning that for each unique constraint, there were more
than three exposures on average). Figure 6 contains a his-
togram showing that the majority of assignments had exposure-
to-constraint ratios close to the average. While these ratios
are lower than those for the open-source applications, they
are still overwhelmingly greater than one, again supporting
our hypothesis that similar data is accessed in similar ways.
5.2.2 Bugs Found
Figure 4 contains a summary of the bugs we found in stu-
dent projects using Derailer. Roughly 20% of the students
failed to complete the project (they did not implement ac-
cess control). Another 65% did implement access control,
but failed to implement a consistent security policy. In other
594Metric Avg. Max. Min.
Lines of Code 2,125 24,341 278
Analysis Time 4.37s 20.28s 0.23s
Exposures 47 236 4
Unique Constraints 12 45 0
Figure 8: Results of Analyzing 127 Student Projects
words, less than 15% of the student assignments were cor-
rect.
The most common issue seemed to be that students con-
sidered only the most common method of accessing a piece
of data, and failed to consider other ways of accessing it.
For example, many students correctly checked for permis-
sion when a user loads the \edit" page for a Note, but failed
to check again when the user issues a POST request to the
\update" action for that Note. Most of the time, users will
issue the POST request only after loading the \edit" page,
and so will be shown the \access denied" message instead of
the editing form. However, a malicious user can construct
a POST request directly to the \update" action, bypassing
the security check. Since the student did not consider this
access path, he or she did not secure it. Derailer is perfect
for nding this kind of problem, since it considers allthe
ways data can be accessed.
5.2.3 Comparison with Teaching Assistants
We also compared the set of bugs we found in student as-
signments with the grading reports given to those students
by their teaching assistants. Out of 56 grade reports we ob-
tained, 38 (or 68%) agreed with our analysis. In 17 cases
(30%), we found a bug using Derailer that the teaching as-
sistants missed.
Only one assignment contained a bug that the teaching
assistants found, but that we missed. In this case, it was
possible for a user to grant permissions to a non-existant
user ID which might later be associated with some new user.
This situation does not cause a sensitive exposure at the time
it occurs. Since Derailer only reports exposures|which by
denition require some output to the user|our analysis was
unable to uncover this bug.
We asked the teaching assistants to validate the security
bugs we found, and in each case, they agreed that the addi-
tional bugs we found were indeed violations of the student's
intended security policy.
5.3 Threats to Validity
Internal Validity. Our experimental results may not
support our ndings for several reasons. If our analysis in-
correctly skips some code or misses some constraints, then
it might report incorrect results. If our timing strategy was
not accurate, then our scalability results might be incor-
rect. And if we misinterpreted the analysis results, then
the set of bugs reported might be incorrect. We mitigated
these factors by testing our tool extensively on small appli-
cations with seeded bugs; by timing each scalability experi-
ment three times; and by checking our interpretation of each
bug in the student projects with the teaching assistant who
graded it.
External Validity. Similarly, our ndings may not gen-
eralize to real-world applications. If our assumptions about
Rails applications|that they typically use ActiveRecord,have few branches, and iterate only over collections|do not
hold, then our scalability results may not be indicative of
Derailer's real-world performance. If the types of security
bugs that occur in the real world are not similar to the ones
in our experimental subjects, then our tool may be less use-
ful for those applications.
We have collected evidence to mitigate the rst factor.
We examined the 21 most-starred Rails projects on Github.
We found that all 21 projects used ActiveRecord exclusively
to access the database. And, in a combined 562,527 lines
of Ruby code, these applications contain a total of just 36
loops|and more than half contain no loops at all. When
Derailer's analysis encounters a loop with a symbolic con-
straint, it unrolls the loop to the bound specied by the
user and marks the resulting exposures for special review,
so the user is unlikely to miss security bugs due to loops in
controller code.
The second factor is more dicult to mitigate, because
determining the prevalence of each type of security bug rst
requires that those bugs be found. Our experience teaching
web application design, as well as the collective experience
of the security community, seems to support the idea that
the kind of bugs Derailer is designed to nd are among the
most common.
6. RELATED WORK
Derailer combines static analysis with human interaction
to nd security bugs. In this section, we discuss the related
work in each of these areas, and compare Derailer to other
existing solutions.
6.1 Interactive Analyses
We share the idea of using human insight as part of a se-
mantic program analysis with Daikon [8] and DIDUCE [11],
which use runtime traces to produce possible program in-
variants and ask the user to verify their correctness. Like
Derailer, these tools do not require a specication. How-
ever, both systems rely on dynamic analysis (e.g. collecting
traces during execution of a test suite) and therefore may
miss uncommon cases. Derailer, by contrast, uses symbolic
execution to ensure coverage.
Teoh et. al [26] apply a similar strategy to the problem
of network intrusion detection, producing visual representa-
tions of the current state of the network. Over time, users
of the tool learn to recognize normal network states by their
visual representations, and can therefore quickly determine
when an intrusion has occurred.
6.2 Automatic Anomaly Detection
In addition to producing candidate invariants, DIDUCE
raises errors at runtime when these invariants are violated,
allowing it to run in a completely unsupervised mode. This
approach is a type of automatic anomaly detection|an area
which has received much attention [3]. Most approaches to
anomaly detection use machine learning techniques to learn
the appearance of \normal operation," and then use the re-
sulting classier to automatically nd anomalies at runtime.
These techniques have not often been applied to code, how-
ever, since software specications are often specialized and
dicult to learn.
It may be possible to use an automatic anomaly detection
technique along with Derailer's analysis to detect security
problems without human input. However, anomaly detec-
595tion techniques rely on a large training set of examples, of-
ten spread across many applications in the same domain;
Derailer's results, by contrast, usually contain only a hand-
ful of elements per data type, and since security policies are
not common across applications, pooling results from many
applications is not likely to be helpful.
6.3 Symbolic Evaluation
King [14] and Clarke [6] developed the rst symbolic ex-
ecution systems in 1976, and modern systems [2, 10, 13, 21,
23, 24] have been used to do many types of program anal-
yses. Two notable examples are the symbolic extension of
Java PathFinder [13, 21], which has been used to analyze
Java code used by NASA, and CUTE [24], a \concolic" test-
ing tool for C that interleaves invocations of a symbolic and
concrete execution.
The recent popularity of dynamic languages has lead to a
number of tools for executing these languages symbolically:
for example, Saxena et. al [23], Rozzle [7], and Kudzu [23]
for Javascript, and Rubyx [4] for Ruby. In contrast to De-
railer, all of these use standalone symbolic evaluators.
Like Derailer, Yang et. al [28] and K oskal et. al [15] both
embed symbolic values in the host language|in this case,
Scala|to enforce security policies and perform constraint
programming, respectively. Both require that symbolic val-
ues interact only with a short list of \symbolic" library func-
tions, however, and do not allow symbolic values to ow
through arbitrary program code.
6.4 Static Analysis of Web Applications
Existing work on the application of static analysis to web
applications focuses on modeling applications, and especially
on building navigation models. Bordbar and Anastasakis [1],
for example, model a user's interaction with a web applica-
tion using UML, and perform bounded verication of prop-
erties of that interaction by translating the UML model into
Alloy using UML2Alloy; other approaches ( [16,22,27]) per-
form similar tasks but provide less automation. Nijjar and
Bultan [20] translate Rails data models into Alloy to nd
inconsistencies.
Techniques that do not require the programmer to build
a model of the application tend to focus on the elimination
of a certain class of bugs, rather than on full verication.
Chlipala's Ur/Web [5] statically veries user-dened security
properties of web applications, and Chaudhuri and Foster [4]
verify the absence of some particular security vulnerabilities
for Rails applications.
7. CONCLUSIONS
This project explores two hypotheses. First, that web
applications, despite their widespread deployment
and apparent exibility, are in some key respects
simpler than traditional applications, making new,
lightweight analyses possible. These include: the con-
ventional structure of the Rails framework, with the database
typically accessed through ActiveRecord, a simpler interface
than full SQL; the lack of loops in controller actions, which
makes symbolic evaluation straightforward; that request pa-
rameters are named consistently across actions, so that con-
ditions are often identical rather than just isomorphic; and
the statelessness of HTTP, which makes analysis across ac-
tions unnecessary (since the programmer must encode all
relevant security context in persistent state).At the same time, performing a symbolic evaluation on
the code of a web application is challenging. Web frame-
works such as Rails are elaborate and make extensive use of
language and API features that are not always well dened.
Execution begins with complex, system-wide conguration.
To address these issues, we implemented a symbolic eval-
uator that runs the standard interpreter, intercepting calls
to crucial interfaces (such as ActiveRecord) using method
overriding. This not only simplied the task of handling a
complex language and framework whose full formalization
in a conventional symbolic evaluator would be burdensome,
but also allows for hybrid evaluation, in which some aspects
(notably conguration settings) are executed concretely.
The second hypothesis is that security policies tend to
be highly uniform, and that many vulnerabilities re-
sult simply from failing to implement security checks
consistently for dierent actions, formats, and so on.
Our initial experiments seem to support this, with average
ratios of exposures to constraints overwhelmingly greater
than one.
The uniformity of security policies suggests that it would
be protable to pursue designs with a stronger separation
of concerns, with policy more cleanly separated from func-
tionality (and indeed this is the direction seen in many new
developments, both in our own group [17] and elsewhere [25,
28], that allow policies to be expressed declaratively, in one
place, and enforced globally). Such a move would of course
make our analysis less useful, but this seems to us the in-
evitable push-pull between synthesis and analysis. We sus-
pect that for a long time yet there will be systems that do
not achieve such a separation that might benet from the
kind of analysis we have described here.
Our tool seems to strike a reasonable balance between au-
tomation and user intervention; as the case studies suggest,
the burden on the user in identifying security-related con-
straints seems to be reasonable. Nevertheless, we are keen
to try to automate the analysis fully, perhaps by identify-
ing some reliable heuristics, or by incorporating some kind
of machine learning. We also plan to look at other kinds
of security problems, both static and dynamic, to see if the
ideas we have explored might have broader application.
Acknowledgements
We are grateful to the anonymous reviewers for their help-
ful comments. We also thank the 6.170 teaching assistants,
Leonid Grinberg, Dalton Hubble, Manali Naik, Jayaprasad
Plmanabhan, Vikas Velagapudi, Evan Wang, and Carolyn
Zhang, for their feedback on our evaluation results. This
research was funded in part by the National Science Foun-
dation under grant 0707612 (CRI: CRD - Development of
Alloy Tools, Technology and Materials).
8. REFERENCES
[1] B. Bordbar and K. Anastasakis. Mda and analysis of
web applications. Trends in Enterprise Application
Architecture, pages 44{55, 2006.
[2] C. Cadar, D. Dunbar, and D. Engler. Klee: Unassisted
and automatic generation of high-coverage tests for
complex systems programs. In Proceedings of the 8th
USENIX conference on Operating systems design and
implementation , pages 209{224. USENIX Association,
2008.
596[3] Varun Chandola, Arindam Banerjee, and Vipin
Kumar. Anomaly detection: A survey. ACM Comput.
Surv. , 41(3):15:1{15:58, July 2009.
[4] Avik Chaudhuri and Jerey S Foster. Symbolic
security analysis of ruby-on-rails web applications. In
Proceedings of the 17th ACM conference on Computer
and communications security , pages 585{594. ACM,
2010.
[5] A. Chlipala and LLC Impredicative. Static checking of
dynamically-varying security policies in
database-backed applications. In Proceedings of the 9th
USENIX conference on Operating systems design and
implementation , page 1. USENIX Association, 2010.
[6] L.A. Clarke. A system to generate test data and
symbolically execute programs. Software Engineering,
IEEE Transactions on , (3):215{222, 1976.
[7] Charlie Curtsinger, Benjamin Livshits, Benjamin G.
Zorn, and Christian Seifert. Zozzle: Fast and precise
in-browser javascript malware detection. In USENIX
Security Symposium . USENIX Association, 2011.
[8] Michael D Ernst, Je H Perkins, Philip J Guo,
Stephen McCamant, Carlos Pacheco, Matthew S
Tschantz, and Chen Xiao. The daikon system for
dynamic detection of likely invariants. Science of
Computer Programming, 69(1):35{45, 2007.
[9] John Field and Michael Hicks, editors. Proceedings of
the 39th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, POPL 2012,
Philadelphia, Pennsylvania, USA, January 22-28,
2012. ACM, 2012.
[10] Patrice Godefroid, Michael Y. Levin, and David A.
Molnar. Automated whitebox fuzz testing. In NDSS.
The Internet Society, 2008.
[11] Sudheendra Hangal and Monica S. Lam. Tracking
down software bugs using automatic anomaly
detection. In Proceedings of the 24th International
Conference on Software Engineering, ICSE '02, pages
291{301, New York, NY, USA, 2002. ACM.
[12] D. Jackson. Software Abstractions: logic, language,
and analysis . The MIT Press, 2012.
[13] S. Khurshid, C. P as areanu, and W. Visser.
Generalized symbolic execution for model checking
and testing. Tools and Algorithms for the Construction
and Analysis of Systems , pages 553{568, 2003.
[14] J.C. King. Symbolic execution and program testing.
Communications of the ACM , 19(7):385{394, 1976.
[15] Ali Sinan K oksal, Viktor Kuncak, and Philippe Suter.
Constraints as control. In Field and Hicks [9], pages
151{164.
[16] DR Licata and S. Krishnamurthi. Verifying interactive
web programs. In Automated Software Engineering,
2004. Proceedings. 19th International Conference on ,
pages 164{173. IEEE.
[17] Aleksandar Milicevic, Daniel Jackson, Milos Gligoric,
and Darko Marinov. Model-based, event-driven
programming paradigm for interactive web
applications. In Proceedings of the 2013 ACM
international symposium on New ideas, new
paradigms, and reections on programming &
software , pages 17{36. ACM, 2013.
[18] Joseph P Near and Daniel Jackson. Rubicon: bounded
verication of web applications. In Proceedings of theACM SIGSOFT 20th International Symposium on the
Foundations of Software Engineering , page 60. ACM,
2012.
[19] Joseph P. Near and Daniel Jackson. Symbolic
execution for (almost) free: Hijacking an existing
implementation to perform symbolic execution.
Technical Report MIT-CSAIL-TR-2014-007,
Computer Science and Articial Intelligence Lab,
Massachusetts Institute of Technology, Cambridge,
Massachusetts, April 2014.
[20] Jaideep Nijjar and Tevk Bultan. Bounded
verication of ruby on rails data models. In
Matthew B. Dwyer and Frank Tip, editors, ISSTA ,
pages 67{77. ACM, 2011.
[21] C. Pasareanu and W. Visser. Verication of java
programs using symbolic execution and invariant
generation. Model Checking Software , pages 164{181,
2004.
[22] Filippo Ricca and Paolo Tonella. Analysis and testing
of web applications. In Hausi A. M uller, Mary Jean
Harrold, and Wilhelm Sch afer, editors, ICSE , pages
25{34. IEEE Computer Society, 2001.
[23] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
S. McCamant, and D. Song. A symbolic execution
framework for javascript. In Security and Privacy
(SP), 2010 IEEE Symposium on , pages 513{528.
IEEE, 2010.
[24] Koushik Sen, Darko Marinov, and Gul Agha. Cute: a
concolic unit testing engine for c. In Michel
Wermelinger and Harald Gall, editors,
ESEC/SIGSOFT FSE , pages 263{272. ACM, 2005.
[25] Isaac Strack. Getting Started with Meteor. js
Javascript Framework . Packt Publishing, 2012.
[26] Soon Tee Teoh, Kwan-Liu Ma, Soon Felix Wu, and
T.J. Jankun-Kelly. Detecting aws and intruders with
visual data analysis. IEEE Computer Graphics and
Applications , 24(5):27{35, 2004.
[27] P. Tonella and F. Ricca. Dynamic model extraction
and statistical analysis of web applications. 2002.
[28] Jean Yang, Kuat Yessenov, and Armando
Solar-Lezama. A language for automatically enforcing
privacy policies. pages 85{96, 2012.
597