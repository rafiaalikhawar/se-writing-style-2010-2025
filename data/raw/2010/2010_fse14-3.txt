Sherlock: Scalable Deadlock Detection
for Concurrent Programs
Mahdi Eslamimehr Jens Palsberg
UCLA, University of California, Los Angeles, USA
{mahdi,palsberg}@cs.ucla.edu
ABSTRACT
We present a new technique to nd real deadlocks in con-
current programs that use locks. For 4.5 million lines of
Java, our technique found almost twice as many real dead-
locks as four previous techniques combined. Among those,
33 deadlocks happened after more than one million com-
putation steps, including 27 new deadlocks. We rst use a
known technique to nd 1275 deadlock candidates and then
we determine that 146 of them are real deadlocks. Our tech-
nique combines previous work on concolic execution with a
new constraint-based approach that iteratively drives an ex-
ecution towards a deadlock candidate.
Categories and Subject Descriptors
D.2.5 Software Engineering [ Testing and Debugging ]
Keywords
Concurrency; deadlocks
1. INTRODUCTION
Java has a concurrent programming model with threads,
shared memory, and locks. The shared memory enables
threads to exchange data eciently, and the locks can help
control memory access and prevent concurrency bugs such
as data races.
In Java, the statement synchronized( e)fsgrst evaluates
the expression eto an object, then acquires the lock of that
object, then executes the statement s, and nally releases
the lock.
Locks enable deadlocks, which can happen when two or
more threads wait on each other forever [49]. For example,
suppose one thread executes:
synchronized( A)fsynchronized( B)f. . .gg
while another thread concurrently executes:
synchronized( B)fsynchronized( A)f. . .gg
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proï¬t or commercial advantage and that copies
bear this notice and the full citation on the ï¬rst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciï¬c
permission and/or a fee.
FSEâ€™14 , November 16â€“22, 2014, Hong Kong, China
Copyright 2014 ACM 978-1-4503-3056-5/14/11 ...$15.00.One possible schedule of the program lets the rst thread
acquire the lock of Aand lets the other thread acquire the
lock ofB. Now the program is deadlocked: the rst thread
waits for the lock of B, while the second thread waits for
the lock of A.
Usually a deadlock is a bug and programmers should avoid
deadlocks. However, programmers may make mistakes so we
have a bug-nding problem: provide tool support to nd as
many deadlocks as possible in a given program.
Researchers have developed many techniques to help nd
deadlocks. Some require program annotations that typically
must be supplied by a programmer; examples include [18,
47, 6, 54, 66, 60, 42, 23, 35]. Other techniques work with
unannotated programs and thus they are easier to use. In
this paper we focus on techniques that work with unanno-
tated Java programs. We use 22 open-source benchmarks
that have a total of more than 4.5 million lines of code,
which we use \straight of the box" without annotations.
We can divide deadlock-detection techniques into three
categories: static, dynamic, and hybrid. A static technique
examines the text of a program without running it. One of
the best static tools is Chord [46, 45] which for our bench-
marks reports 570 deadlocks, which include both false pos-
itives and false negatives. A dynamic technique gathers in-
formation about a program during one or more runs. Until
now, four of best dynamic tools are DeadlockFuzzer [36],
ConTest [16, 20], Jcarder [17] and Java HotSpot [48], which
together for our benchmarks report 75 real deadlocks. Fi-
nally, hybrid techniques may be able to combine the best
of both worlds, static and dynamic. One of the best hy-
brid tools is GoodLock [29] which is highly ecient and for
our benchmarks report a total 1275 deadlocks, which may
include both false positives and false negatives.
In this paper we focus on dynamic techniques. The ad-
vantage of a dynamic technique is that it reports only real
deadlocks. The main shortcoming of the previous dynamic
techniques is that they mostly nd deadlocks that occur af-
terfewsteps of computation. Our experiments show that
those techniques leave undetected many deadlocks that oc-
cur after one million steps of computations. We believe that
this shortcoming stems from their approach to search for ex-
ecutable schedules . A schedule is a sequence of events that
must be executed in order. A real deadlock is a combination
of deadlock pattern, such as the one in the example above,
and an executable schedule that leads to the deadlock. We
will show how to do a better search for executable schedules.
The challenge. Help programmers nd more reproducible
deadlocks than with previous techniques.Our result. We present a technique that for a deadlock
candidate searches for an input and a schedule that lead to
the deadlock.
We use GoodLock [29] to quickly produce a manageable
number of deadlock candidates. Our technique combines
previous work on concolic execution with a new constraint-
based approach to drive an execution towards a deadlock
candidate. We have implemented our technique in a tool
called Sherlock that nds real deadlocks in Java programs.
For our benchmarks, our tool found almost twice as many
real deadlocks as four previous techniques combined. Our
technique is particularly good at nding deadlocks that hap-
pen after many execution steps: we found 33 deadlocks that
happened after more than one million computation steps,
including 27 new deadlocks. Our tool is fully automatic
and its user needs no expertise on deadlocks. Once our tool
reports a deadlock, our tool can replay the execution that
leads to the deadlock.
In summary, the two main contributions of this paper are:
an eective and easy-to-use tool for dynamic deadlock
detection and
a large-scale experimental comparison of seven dead-
lock detectors.
The rest of the paper. In the following section we present
our approach and in Section 3 we present the key innovation
that makes our approach work. In Section 4 we present our
experimental results, in Section 5 we discuss limitations, in
Section 6 we discuss related work.
2. OUR TECHNIQUE
Overview. In a nutshell, we rst produce a set of dead-
locks candidates and then we do a separate search for each
of the deadlock candidates. The key idea is to turn each
search for a deadlock into a search for a schedule that leads
to the deadlock. We structure those searches in a particular
manner that Eslamimehr and Palsberg used in their work
on data race detection [19] and that we illustrate in Fig-
ure 1. Each circle in Figure 1 is a schedule. The search is
an alternating sequence of execute andpermute steps:
(executepermute )iexecute
whereiis a nonnegative integer. The execute function at-
tempts to execute a given schedule and determine whether
it leads to a deadlock, and the permute function permutes
a given schedule. The search begin with an initial schedule
found simply by executing the program. The search fails
ifexecute cannot execute a given schedule, if permute can-
not nd a better permutation, or if the search times out.
Our key innovation is a permute function that works well
for deadlock detection.
Each call to execute may produce a more promising sched-
ule, after which a call to permute will further improve that
schedule. In more detail, each call to execute will both try to
execute the given schedule andcontinue execution beyond
that schedule, typically until termination of the program.
Part of the continued execution may make progress towards
the desired deadlock. The call to permute will permute the
events in the schedule to make the next call to execute have
a better chance to succeed.
executeexecuteexecutepermutepermute
initial scheduleschedule that leads to a deadlockFigure 1: An illustration of the basic technique.
The alternation of permute andexecute steps is more pow-
erful than either one alone. For our benchmarks, our tech-
nique nds 146 deadlocks, while execute alone nds only 63
deadlocks, and permute alone nds only 22 deadlocks.
Eslamimehr and Palsberg's work on data race detection
[19] showed how to implement execute via a series of con-
colic executions, as we will summarize below. In Section 3
we show how to dene a permute function that successfully
helps to nd deadlocks.
Data types. We use these data types in Sherlock:
Program = a Java 6 program
Input = input to a Java 6 program
Lock = a Java 6 object
Event =threadIdstatementLabel
Schedule =Event sequence
Link =threadId(statementLabelLock)
(statementLabelLock)
Cycle =Link set
Deadlock =CycleInputSchedule
Sherlock works for Java 6 programs, which have the type
Program . The input to such programs is a vector of values;
we use Input to denote the type of input vectors. Each object
in Java contains a lock; for simplicity we refer to each object
as a lock and use Lock to denote the type of locks.
We have one threadId for each program point that cre-
ates a thread. Notice that one threadId may cover multiple
dynamic threads. When a program execution executes a
particular statement in a thread with a particular threadId ,
we refer to that as an event that has type Event .
The standard notion of schedule is here the data type
Schedule , which is a sequence of events.
In the context of deadlock detection, two key data types
areLink andCycle . We use Link to describe that a thread in
a particular statement has acquired a lock and now wants to
acquire another lock. We use Cycle , which is a set of links,
to describe a deadlock.
ADeadlock is the type of information that we need to
replay an execution that leads to a deadlock. A Deadlock
has three components, namely the Cycle that is the deadlock,
theInput that we should supply at the beginning of the
execution, and the Schedule that the execution should follow
to reach the deadlock.Deadlock candidates. Our technique relies on access to
a set of deadlock candidates. We use Havelund's technique
GoodLock [29] to produce 1275 deadlock candidates for our
benchmarks of more than 4.5 million lines of code. Those
1275 deadlock candidates are an excellent starting point for
our search. GoodLock combines model checking and dy-
namic analysis into an ecient deadlock detector that can
produce both false positives and false negatives. Here is the
interface to GoodLock:
GoodLock :Program!(Cycle set )
We use GoodLock as a \black box", that is, as an unmod-
ied component for which we rely only on its input-output
behavior. Notice that GoodLock maps a Java program to a
set of eventSets, that is, a set of deadlock candidates. We
use an extension of GoodLock that can handle deadlocks of
any number of threads [1]. Havelund reported that dead-
locks that involve three or more threads are extremely rare
in practice, and indeed for our benchmarks GoodLock found
only deadlock candidates that involve two threads.
The InitialRun function. Here is the interface to the
initialRun function:
initialRun :Program!Schedule
A call to initialRun simply executes the program with some
particular input and records the schedule. Our benchmarks
are drawn from open source repositories and each one comes
with a specic input. For each benchmark, we use the pre-
determined input in initialRun because those inputs appear
to exercise the code well. Alternatively, we could pick some
other input (for example, at random). We leave to future
work to investigate whether the eectiveness of our approach
would be signicantly aected by the quality of the inputs.
The Execute function. Here is the interface to the
execute function:
execute : (ProgramScheduleCycle )!
((InputScheduleboolean )fnoneg)
The arguments to execute are a program, a schedule, and a
deadlock candidate. A call to execute will attempt to execute
the given schedule, determine whether it leads to a deadlock,
and try to execute a longer schedule that contains the events
embodied in the deadlock candidate. Consider the call:
(a;trace;found ) =execute (p;s;c )
Here, found is aboolean that is true if the given schedule
sleads to a deadlock and that is false otherwise. If found
is true, then ais the input to the program that was used
to execute the schedule. Additionally, trace is the schedule
that was actually executed.
The implementation of execute uses concolic execution [41,
28, 8, 9, 56, 55]. Our explanation of execute is in two steps:
rst we summarize the idea of concolic execution and then
we explain the implementation of execute .
Consider the sequential program
x= 6; if (y>4)fsg
which has input y, and which contains a statement s. How
can we nd an input that leads to execution of s? A good an-
swer is to use directed testing [28] that executes the program
multiple times with dierent inputs and each time hopefully
gets closer to execute s. The insight of directed testing is(Deadlock set ) Sherlock( Programp)f
(Cycle set )candidates =GoodLock (p)
Schedules0=initialRun (p)
(Deadlock set )dlocks =;
for each Cyclec2candidates dof
boolean found =false
boolean stalled =false
inti= 0
Schedules=s0
while (:found )^(:stalled )^(i1000)f
case execute (p;s;c )of
(InputScheduleboolean ) (a;trace;true) :f
dlocks =dlocks[f(c;a;trace )g
found =true
g
(InputScheduleboolean ) (a;trace;false) :f
case permute (trace;c)of
Schedules0:fs=s0g
none :fstalled =trueg
g
none :fstalled =trueg
g
i=i+ 1
g
g
return dlocks
g
Figure 2: Sherlock.
to use information from one execution to generate a more
promising input to the next execution. Specically, we need
a listing of all the assignments and conditions (and simi-
lar constructs) encountered. For example, for the program
above, suppose the rst run uses input y= 0. The execution
encounters one assignment x= 6 and one condition y >4.
We can read those as constraints and form the conjunction
(x= 6^y >4 ). The last condition encountered ( y >4
in this case) led us othe path towards s. To get a more
promising input, we solve the constraints and might get the
solutionfx= 6; y = 10g. Here we see that we can try
inputy= 10, which indeed leads to execution of s. Such an
execution that records constraints is called a concolic exe-
cution . The word concolic stems from that the execution is
both concrete (it executes as usual) and symb olic(it record
constraints). If the statement sis nested deeply, we may
need many concolic executions before we either nd an in-
put that leads to execution of sor we give up.
Our implementation of execute uses Eslamimehr and Pals-
berg's generalization [19] of directed testing to a concurrent
program and a sequence of events. The idea is to nd an
input that leads to execution of all of the events in the se-
quence in order. We can do that by iterating the above
idea and by controlling the thread scheduler. Each iteration
leads to execution of one of the events and the next itera-
tion takes the constraints from the previous iteration as its
starting point. We control the thread scheduler to ensure
that we execute the events in the right order. If we can
match the event sequence, then we continue exploration in
an attempt to execute as many of the events embodied in
the deadlock candidate as possible. However, if we cannotmatch the event sequence, then execute returns none, which
may happen for a variety of reasons including nondetermin-
ism that stems from system calls and external events.
The Permute function. Here is the interface to the
permute function, which maps a schedule and a deadlock
candidate to a better schedule or else to none if no better
schedule was found:
permute : ( ScheduleCycle )!(Schedulefnoneg)
In the following section we describe permute in detail.
Sherlock pseudo-code. Figure 2 shows pseudo-code for
Sherlock, which we will go over in detail. We hope our
pseudo-code and explanation will enable practitioners to im-
plement our technique easily.
The input to the Sherlock procedure is a program while
the output is a set of real deadlocks. The rst three lines of
Sherlock declares these three variables: (1) a set of deadlock
candidates, called candidates , that we initialize by a call to
GoodLock , (2) a schedule, called s0, that we initialize to the
trace produced by an initial run of the program, and (3) a
set of deadlocks, called dlocks , that initially is the empty set
and that we eventually return as the result of the procedure.
The main body of the pseudo-code consists of a for-each-
loop that tries each of the event sets in the set of candidates.
The body of the for-each loop declares these four variables:
(1) a boolean found that tells whether we have found a
schedule that leads to the desired deadlock, (2) a boolean
stalled that tells whether permute was able to improve a
given schedule and whether execute was able to match the
trace and execute a longer trace with the events embodied
in the deadlock candidate, (3) an integer ithat counts the
number of pairs of calls to permute andexecute , and (4) a
schedule, called s, that we initialize to s0. For each deadlock
candidate we use a while-loop to do an alternation of calls to
execute andpermute , as illustrated in Figure 1. Intuitively,
the while-loop terminates if either we nd the deadlock, we
give up, or we time out. The time-out condition ( i1000)
was never exercised in our experiments; the highest number
of iterations of the while-loop for our benchmarks was 726.
In the body of the while-loop, we rst call execute to match
the given schedule, after which either we declare success, or
proceed with a call to permute , or abandon the search. Sim-
ilarly, after the call to permute , we either continue with the
next iteration of the while-loop or we abandon the search.
Notice how each iteration of the while-loop begins with s,
extends it to trace and then improves it to a new value of s.
If we nd a deadlock, then we record the input and the
trace that lead to the deadlock. If we abandon the search,
then the deadlock candidate may still be a real deadlock.
Example. We now present an example in which we walk
through a run of Sherlock on the following program with
four shared variables and two threads:
A,Bare shared variables that contain objects
x,yare shared variables that contain integers
yhas an initial value received from user input
Thread 1: Thread 2:
l1:x= 6 l5:x= 2
l2: synchronized( A)fl6: synchronized( B)f
l3: if (y>4)f l7: if (y2+ 5<x2)f
l4: synchronized( B)fgl8: synchronized( A)fg
g g
g gThe example is a rened version of the example in Section 1:
we have added two assignments and two if-statements. The
point of the example is that the program enters a deadlock
only when it executes the bodies of both if-statements. For
a deadlock to happen, ymust be 5 and the program must
execute a particular schedule that lets xbe 6 at the time
the program evaluates the condition at l7. So, while a dead-
lock is possible, most executions are deadlock free. We will
explain how our technique nds the deadlock.
We use these abbreviations for events: e1= (1;l1),e2=
(1;l2),e3= (1;l3),e4= (1;l4),e5= (2;l5),e6= (2;l6),
e7= (2;l7),e8= (2;l8).
The call to GoodLock produces a single deadlock candi-
date, namely the following cycle, which in the for-each loop
will be called c:
c=f(Thread 1;(l2;A);(l4;B));(Thread 2;(l6;B);(l8;A))g
Now we do an initial run of the program. Suppose that the
initial input, which becomes the value of the shared variable
y, is 0. We get
s=e1;e2;e3;e5;e6;e7
Now we run the rst iteration of the while-loop. First we
runexecute which matches the schedule and nds out that
with input y= 5, it can add the event e4. So we have:
trace =e1;e2;e3;e5;e6;e7;e4
The call to permute ontrace gives:
s=e5;e6;e7;e1;e2;e3;e4
Now we run the second iteration of the while-loop. The call
toexecute matches the schedule with input y= 5 so we have:
trace =e5;e6;e7;e1;e2;e3;e4
The call to permute ontrace gives:
s=e5;e6;e1;e2;e7;e3;e4
Now we run the third iteration of while-loop. The call to
execute matches the schedule with input y= 5, adds the
evente8, and enters a deadlock. The schedule is:
trace =e5;e6;e1;e2;e7;e3;e4;e8
Our key innovation is permute , which we explain next.
3. OUR PERMUTE FUNCTION
Our permute function combines ideas from static analysis
and dynamic analysis.
Background: dynamic race detection. Many re-
searchers have studied how to extract information from ex-
ecution traces. A pinnacle of this area is the paper by Ser-
banuta, Chen, and Rosu [57] that presented a sound and
maximal model of execution traces: it subsumes all other
sound models that rely solely on information from an ex-
ecution trace. They also showed how to use the model to
do dynamic race detection. Their race detector works in
two steps: rst run the program to get a trace, then nd
an executable permutation of the trace that leads to a race.
Their model helps guarantee that the chosen permutation is
executable.
As shown later by Said, Wang, Yang, and Sakallah [52],
one can phrase the problem to nd an executable permu-
tation of a trace as a constraint-solving problem, and one= [T^
t=1oet
1:idx<:::<o etn:idx]^[^
e2FORKoe:idx<o (e:val ):first:idx ]^[^
e2JOINo(te:val ):last:idx<oe:idx ]
=^
e2^e:type =read0
@V
(e:tiwp =null )^(e:val =e:var:init )V
e12e:pwsoe:idx<oe1:idx
_W
e12e:pwsvV
e22e:pws^e26=e1(oe1:idx<oe:idx)^(oe:idx<oe2:idx_oe2:idx<oe1:idx)1
A
	(V;E )=^
(ei;ej)2Eoi<oj
c= (oi1<oj2)^(oi2<oj1) where c=f(t1;(li1;LA);(lj1;LB));(t2;(li2;LB);(lj2;LA))g
andei1= (t1;li1)^ej1= (t1;lj1)^ei2= (t2;li2)^ej2= (t2;lj2)
Figure 3: Constraints for our permute function
can use an SMT-solver to produce that permutation. In
essence, Said et al. presented a permute function that works
well for race detection. Eslamimehr and Palsberg [19] com-
bined Said et al.'s permute function with concolic execution
and thereby obtained an ecient and useful dynamic race
detector. We will present a permute function that works
well for deadlock detection.
A static characterization of potential deadlocks.
Deshmukh, Emerson, and Sankaranarayanan [15] presented
a static analysis of library code that identies potential dead-
locks. Their analysis delivers a library interface that de-
scribes how to call library functions with deadlock-safe alias
relationships among library objects. In outline, their ap-
proach has two steps.
First, from the text of a library, their static analysis builds
a lock-order graph and a representation of alias information.
The lock-order graph describes the order in which the code
acquires locks. For example, for the statement
synchronized( A)fsynchronized( B)f. . .gg
the graph contains an edge from a node \synchronized( A)"
to a node \synchronized( B)".
Second, from the lock-order graph and the alias informa-
tion, they derive constraints and show that the constraints
are solvable if and only if the lock-order graph is acyclic.
In other words, the constraints are solvable if and only the
library code cannot deadlock.
They use an SMT-solver to solve the constraints. We will
use their approach to handle lock orders in our denition of
permute .
A memory-less Permute function for deadlock. Now
we give an overview of a baseline version of our permute func-
tion that we call the memory-less permute function; later we
give a constraint-based denition. Our memory-less permute
function leads to a deadlock detector that nds 121 dead-
locks in our benchmarks, which is already better than the
previous dynamic techniques with which we compare. At the
end of this section, we present an enhanced permute function
that leads us to nd an additional 25 deadlocks.
Our memory-less permute function combines aspects of
Said et al.'s permute function [52] with aspects of Deshmukh
et al.'s static analysis [15] and a constraint that encodes a
deadlock candidate. Let us now explain the key observation
that makes the combination work.
Said et al. generates a constraint that at the top level
has two conjuncts: 1) a constraint that guarantees that the
permutation of a trace will be sequentially consistent, and2) a constraint that represents a data race. We replace (2)
with a representation of deadlock candidate; let us now take
a closer look at (1). The constraint about sequential con-
sistency has three conjuncts that represent that the per-
muted trace must: 1.1) preserve the happens-before relation
for each thread, 1.2) satisfy write-read consistency , and 1.3)
satisfy synchronization consistency . Write-read consistency
means that a read event must read the value written by the
most recent write event to that location, and synchroniza-
tion consistency means that the permuted trace is consistent
with the semantics of the synchronization events.
Our observation is that we can use (1.1) and (1.2), and
then replace (1.3) with the Deshmukh et al.'s lock-order con-
straints. Intuitively, we replace dynamic information about
synchronization and lock order from a single trace with static
lock-order information about the entire program . The whole-
program view of lock order makes our permute function ef-
cient and powerful.
The grand total is a constraint that consists of the con-
straints (1.1) and (1.2) from Said et al., Deshmukh et al.'s
lock-order constraints, and a representation of a deadlock
candidate. This constraint, if solvable, represents a per-
muted trace. If the input trace contains all the events em-
bodied in the deadlock candidate, and permuted trace is
executable, then the execution leads to the deadlock. We
use an SMT-solver to solve the constraint, and, as explained
earlier, right after the call to permute , we run execute on the
permuted trace to nd out whether it is executable.
Constraints. Now we give full details of the constraints
that we use in our permute function. Suppose we have a
program, a trace =he1;:::;eniof an execution of the
program, a lock-order graph ( V;E) produced by a standard
interprocedural static analysis of the program [15], and a
deadlock candidate c. The constraints use nposition vari-
ableso1;:::;on. The idea is that the value of oiis the posi-
tion ofeiin the permuted trace. The symbol <denotes the
happens-before relation. The constraints are of the form
^^	(V;E )^c (1)
where each of the four conjuncts is dened in Figure 3. Here
is Said et al.'s constraint (1.1), is Said et al.'s con-
straint (1.2), 	 (V;E )is Deshmukh et al.'s lock-order con-
straints, and cis a representation of a deadlock candidate.
Figure 3 uses helper functions that we explain below.
The constraint (1) is formed by conjunctions and disjunc-
tions of inequalities of the form ( oi<oj). A solution to theconstraints is an injective function
S:fo1;:::;ong!f 1;:::;ng
First we explain . We use the same notation as Said et
al. [52]. In particular, for a trace and a threadId t, we let
het
1;:::;et
nbe subsequence of t-events in, and we let t:first
denoteet
1and we let t:last denoteet
n. We assume that the
set of threadIds is 1 ::T. For each event ein, we usee:idx to
denote its index in , we usee:type to denote the event type,
which ranges over fread;write;fork;join;acquire;release g,
and we use e:tid to denote the threadId. Additionally, we
usee:var to denote either (in read or write) a shared vari-
able, or (in fork or join) a synchronization object. Further,
we usee:val to denote either (in read or write) a concrete
value, or (in fork or join) the child threadId. FORK denotes
the set of fork events in , and similarly JOIN denotes the
set of join events in .
The rst conjunct of expresses that the happens-before
relation per thread must be preserved. The second conjunct
ofexpresses that a fork event happens before the rst
event of the forked thread. The third conjunct of ex-
presses that the last event of a thread happens before the
thread participates in a join event.
Next, we explain . We use the same notation as Said
et al. [52]. In particular, for a read event e, we usee:tiwp
to denote the thread immediate write predecessor , which is
a write event that comes before einthat has the same
threadId as e, has the same variable as e, and for which no
other such write event occurs in betweene:tiwp ande.
If no such write event exists, then we write e:tiwp =null.
Additionally, for a read event e, we usee:liwp to denote
thelinearization immediate write predecessor , which is a
write event that comes before einthat has a possibly
dierent threadId than e, has the same variable as e, and
for which no other such write event occurs in between
e:liwp ande. If no such write event exists, then we write
e:val =e:var:init , wheree:var:init is the initial value of
variablee:var . Finally, for a read event e, we usee:pws
to denote the predecessor write set , which is the set of write
eventse0such thate0:var =e:var and eithere0:tid6=e:tid or
bothe0:tid=e:tid ande0=e:tiwp . We usee:pwsv to denote
the subset of e:pws for which for each element e02e:pwsv
we havee0:val=e:val .
The constraint has a conjunct for each read event in
. Each of the conjuncts is a disjunction of two disjuncts,
one per line of the denition of . The rst disjunct says
that if the read event doesn't have thread immediate write
predecessor, then the value read is the initial value and all
writes to that variable come after that read in . The second
disjunct says that if contains a linearization immediate
write predecessor, then every possible write event e1 for the
value read must come before the read event, and no other
such write event e2 can come between e1 and the read event.
Next, let us explain 	 (V;E ). Following Deshmukh [15] we
rst use a standard interprocedural analysis to compute a
lock-order graph ( V;E) for the entire program. The nodes V
are events that acquire locks, and the edges Eexpress nested
relationships between the nodes: ( e1;e2)2Eif and only if
the body of e1containse2. Now 	 (V;E )is a conjunction of
one constraint per edge ( ei;ej)2E, namely (oi<oj), that
expresses that eimust happen before ej.
Finally, let us explain how crepresents a deadlock candi-
datecwith two links in the cycle. The denition and expla-nation generalize easily to cycles with more than two links
though we haven't found any programs with such deadlocks.
The deadlock candidate can be understood as a collection
of the four events ei1;ej1;ei2;ej2listed in Figure 3. A pre-
condition for the deadlock candidate to be a real deadlock
is thatei1andei2must both happen before both of ej1
andej2. We have that 	 (V;E )contains (oi1< oj1) and
oi2;oj2, so to ensure that the precondition is met, we let c
be (oi1<oj2)^(oi2<oj1). In case some or all of the four
events occur multiple times in the trace, we let the candidate
refer to the rst occurrence of each event in the trace.
Example. Let us return to the example from Section 2
and explain details of the call to permute in the rst iteration
of the while-loop. That call is permute (trace;c) where
trace =e1;e2;e3;e5;e6;e7;e4
andcis the deadlock candidate:
c=f(Thread 1;(l2;A);(l4;B));(Thread 2;(l6;B);(l8;A))g
Here are the constraints used by the permute function. First
we listtrace, which preserves the happens-before relation
for each thread:
o1<o 2^o2<o 3^o3<o 4^o5<o 6^o6<o 7
Next we list trace, which ensures write-read consistency:
o5<o 7
Next we list 	 (V;E )which represents Deshmukh et al.'s lock-
order constraints:
o2<o 4^o6<o 8
Finally,cencodes the deadlock candidate c:
o2<o 8^o6<o 4
One possible solution is:
s=e5;e6;e7;e1;e2;e3;e4
which ignores the constraints that involve e8becausee8
doesn't occur in trace . So, we can return sas the result
of the call to permute in the rst iteration of the while-loop.
An enhanced Permute function for deadlock. The
full version of our permute function has \memory" and takes
advantage of the schedules that have been submitted in all
previous calls. The idea is to use the schedules that have
been submitted earlier to relax the happens-before relation.
We do the relaxation by taking the union of the happens-
before relations from all those schedules. The result is a
constraint system that is more likely to be satisable and
that leads us to nd 25 more deadlocks in our benchmarks.
One nal enhancement of our permute function is based on
partial order reduction. The issue is that permute might pro-
duce a permuted trace that is semantically equivalent with
the input trace and therefore must fail to lead to the dead-
lock candidate. We use Flanagan and Godefroid's approach
[22] to partial order reduction to avoid such a situation.
Our implementation uses Flanagan and Godefroid's ap-
proach as a checker that determines whether an input trace
and the permuted trace are equivalent. In case the input
trace and the permuted trace are equivalent, we repeatedly
askpermute for a dierent output until we get one we want.4. EXPERIMENTAL RESULTS
Our implementation of GoodLock is an extension of Java
PathFinder [30]. In our implementation, events are at the
Java bytecode level. We use Soot [62] to instrument byte-
codes to implement execute on top of the Lime concolic
execution engine; http://www.tcs.hut.fi/Software/lime .
We ran all our experiments on a Linux CentOs machine with
two 2.4 GHz Xeon quad core processors and 32 GB RAM.
4.1 Benchmarks
Figure 4 lists our 22 benchmarks which we have collected
from six sources:
From ETH Zurich [64]: Sor, TSP, Hedc, Elevator.
From java.util , Oracle's JDK 1.4.2: ArrayList,
TreeSet, HashSet, Vector.
From Java Grande [50]: RayTracer, MolDyn, Monte-
Carlo.
From the Apache Software Foundation [26]: Derby.
From CERN [24]: Colt.
From DaCapo [4]: Avrora, Tomcat, Batic, Eclipse,
FOP, H2, PMD, Sunow, Xalan.
The sizes of the benchmarks vary widely: we have 2 huge
(1M+ LOC), 10 large (20K{1M LOC), 8 medium (1K{8K
LOC), and 2 small (less than 1K LOC) benchmarks.
Figure 4 also lists the high watermark of how many threads
each benchmark runs, and the input size in bytes for each
benchmark. Most of the benchmarks come with a specic
input, except the four benchmarks from Oracle's JDK 1.4.2
for which we use a test harness from previous work [36, 19].
Each benchmark is supposed to terminate so every real
deadlock is a bug.
4.2 Deadlock Detectors
We compare Sherlock with one static deadlock detector,
namely Chord [46, 45], one hybrid deadlock detector that we
call GoodLock [29], and four dynamic deadlock detectors,
namely DeadlockFuzzer [36], ConTest [16, 20], Jcarder [17],
and Java HotSpot [48]. Additionally we compare with a
combined dynamic technique that we call DCJJ.
Chord is a static technique, and by design it may report
false positives; its main objective is to report all real dead-
locks (or as many as possible).
GoodLock monitors an execution, computes a lock depen-
dency relation, and uses the transitive closure of this relation
to suggest potential deadlocks.
DeadlockFuzzer, ConTest, Jcarder, Java HotSpot, and
Sherlock are all dynamic techniques that report only real
deadlocks.
DeadlockFuzzer begins with a set of deadlock candidates
produced by a variant of GoodLock. For each deadlock can-
didate, DeadlockFuzzer executes the program with a random
scheduler that is biased towards executing the events in the
deadlock candidate. The idea to use a random scheduler for
Java can be traced back to Stoller [59].
ConTest uses heuristics to perturbate the schedule and
thereby hopefully reach a deadlock. One of the techniques
is to insert time-outs.Jcarder instruments Java byte code dynamically and looks
for cycles in the graph of acquired locks. The instrumented
code records information about the locks at run time. A
later, separate phase of Jcarder post-processes the recorded
information to search for deadlocks.
The Java HotSpot Virtual Machine from Oracle can track
the use of locks and detect cyclic lock dependences. The util-
ity detects Java-platform-level deadlocks, including locking
done from the Java Native Interface (JNI), the Java Vir-
tual Machine Proler Interface (JVMPI), and Java Virtual
Machine Debug Interface (JVMDI).
We use DCJJ to stand for the union of DeadlockFuzzer,
ConTest, Jcarder, and Java HotSpot in following sense. We
can implement DCJJ as a tool that for a given benchmark
starts runs of DeadlockFuzzer, ConTest, Jcarder, and Java
HotSpot in four separate threads, and if any one of them
reports a deadlock, then DCJJ reports a deadlock.
4.3 How we handle Reï¬‚ection
Many of the benchmarks use reection, and ConTest and
Java HotSpot handle reection well. We enable the other
deadlock detectors to handle reection with the help of the
tool chain TamiFlex [5]. The core of the problem is that
reection is at odds with static analysis and bytecode in-
strumentation: reection may make make static analysis
unsound and may load uninstrumented classes. TamiFlex
solves these problems in a manner that is sound with respect
to a set of recorded program runs. If a later program run
deviates from the recorded runs, TamiFlex issues a warning.
We have combined each of Chord, GoodLock, Deadlock-
Fuzzer, and Jcarder with TamiFlex and we have run all our
experiments without warnings. As a result, all the deadlock
detectors all handle reection correctly.
4.4 Measurements
Figure 5 shows the numbers of deadlocks found in 22
benchmarks by 7 techniques. When we compare deadlocks,
we focus on the program points where locks are acquired.
For each benchmark and each tool, the reported deadlocks
turns out to be disjoint, that is, any two deadlocks have
nonoverlapping program points. Even across tools, we found
no cases of partially overlapping deadlocks; each pair of re-
ported deadlocks are either identical or disjoint. As a result
we can easily compare tools. We have manually inspected
all the deadlocks reported by the dynamic tools and we be-
lieve that the deadlocks are rather unrelated. While one
can imagine that a code revision may remove multiple dead-
locks, we found no obvious signs of correlation between the
reported deadlocks.
Figure 6 shows the time each of the runs took in minutes
and seconds, and it shows the geometrical mean for each
technique. We made no attempt to throttle the amount of
time that the tools can use.
4.5 Evaluation
We now present our ndings based both on the measure-
ments listed above and on additional analysis of the dead-
locks that were found.
Sherlock versus other dynamic techniques. We can
see in Figure 5 that Sherlock nds the most deadlocks (146)
of all the dynamic techniques. Among those 146 deadlocks,
86 deadlocks were found only by Sherlock and are entirely
novel to this paper, while 60 were also found by DCJJ. Du-Name LOC # threads input size Brief description
(bytes)
Sor 1270 5 404 A successive order-relaxation benchmark
TSP 713 10 58 Traveling Salesman Problem solver
Hedc 30K 10 220 A web-crawler application kernel
Elevator 2840 5 60 A real-time discrete event simulator
ArrayList 5866 26 116 ArrayList from java.util
TreeSet 7532 21 64 TreeSet from java.util
HashSet 7086 21 288 HashSet from java.util
Vector 709 10 128 Vector from java.util
RayTracer 1942 5 412 Measures the performance of a 3D raytracer
MolDyn 1351 5 240 N-Body code modeling dynamic
MonteCarlo 3619 4 26 A nancial simulator, using Monte Carlo techniques to price products
Derby 1.6M 64 564 Apache RDBMS
Colt 110K 11 804 Open source libraries for high perf. scientic and technical computing
Avrora 140K 6 74 AVR microcontroller simulator
Tomcat 535K 16 88 Tomcat Apache web application server
Batic 354K 5 366 Produces Scalable Vector Graphics images based on Apache Batic
Eclipse 1.2M 16 206 Non-GUI Eclipse IDE
FOP 21K 8 34 XSL-FO to PDF converter
H2 20K 16 658 Executes a JDBCbench-like in-memory benchmark
PMD 81K 4 116 Java Static Analyzer
Sunow 108K 16 24 Tool for rendering image with raytracer
Xalan 355K 9 616 XML to HTML transformer
TOTAL 4587K
Figure 4: Our benchmarks.
ally, 15 deadlocks were found only by DCJJ. In summary,
we have that the combination of DCJJ and Sherlock found
161 deadlocks in the 22 benchmarks.
Found only by DCJJ: 15
Found by both: 60
Found only by Sherlock: 86
Total: 161
Let us consider the 15 deadlocks that DCJJ found but Sher-
lock missed. Those deadlocks were in ArrayList (4), TreeSet
(3), Vector (1), Derby (1), Tomcat (3), Eclipse (2), PMD (1).
DeadlockFuzzer found eleven of those, and ConTest found
the remaining four (and also four of the eleven found by
DeadlockFuzzer).
For example, DeadlockFuzzer found the following dead-
lock in Tomcat, while Sherlock missed it. The deadlock
happens when Tomcat uses OracleDataSourceFactory. The
nature of the deadlock is much like the example in Section
1. If we use the notation of that example, then Ais an ob-
ject of class java.util.Properties, while Bis an object of class
java.util.logging.Logger. Two threads execute synchronized-
operations on those objects in the pattern of the example in
Section 1, hence they may deadlock.
The reason why DeadlockFuzzer found deadlocks that Sher-
lock missed is that DeadlockFuzzer uses a random scheduler
while the initial run of Sherlock uses the standard scheduler.
We conclude that Sherlock nds the most deadlocks, and
that DeadlockFuzzer and ConTest remain worthwhile tech-
niques that each nds deadlocks that the other dynamic
techniques don't nd.
DCJJ details. The combined dynamic technique DCJJ
found 75 deadlocks. We notice that, intuitively:
Jcarder(DeadlockFuzzer[ConTest)In words, if Jcarder nds a deadlock, then DeadlockFuzzer
or ConTest (or both) also nds that deadlock. We also no-
tice that if Java HotSpot nds a deadlock, then either Dead-
lockFuzzer or ConTest (or both) also nds that deadlock or
the deadlock is one particular deadlock in Elevator (which
Sherlock nds too).
Chord. Chord is one of the best static deadlock detec-
tors, yet our experiments suggest that Chord produces a
large number of false positives. Additionally, Chord missed
ve real deadlocks, namely one deadlock in each of Eleva-
tor, Vector, Raytracer, Batic, and Xalan. We conclude that
accurate static deadlock detection remains an open problem.
Timings. The geometrical means of the execution times
show that DeadlockFuzzer is the fastest dynamic technique
while Sherlock is the slowest. The timings for Deadlock-
Fuzzer and Sherlock include the time to execute GoodLock.
Number of schedules. The number of calls to execute
turns out to be rather modest: for every benchmark, it is at
most twice the number of deadlock candidates. This shows
that the combination of execute andpermute is powerful.
Number of steps of execution. This table shows the
lengths of the 146 schedules that lead to deadlocks found by
Sherlock, including the 86 found only by Sherlock:
Sherlock
schedule length total = new + DCJJ
102 1035 0 5
103 10420 9 11
104 10539 12 27
105 10649 38 11
106 10724 18 6
107 1089 9 0
146 86 60
The schedules can be as long as 34 million events, whichStatic Hybrid Dynamic
benchmarks Chord GoodLock DeadlockFuzzer ConTest Jcarder Java HotSpot DCJJ Sherlock
total = new + DCJJ
Sor 1 7 0 0 0 0 0 1 1 0
TSP 1 9 0 0 0 0 0 1 1 0
Hedc 24 23 1 0 0 0 1 20 19 1
Elevator 4 13 0 0 0 1 1 5 4 1
ArrayList 9 11 7 6 2 1 7 9 6 3
TreeSet 8 11 7 5 1 3 8 5 0 5
HashSet 11 10 3 1 0 2 5 5 0 5
Vector 3 14 0 1 0 0 1 4 4 0
RayTracer 1 8 0 1 0 0 1 2 1 1
MolDyn 3 6 1 1 1 1 1 1 0 1
MonteCarlo 2 23 0 1 1 1 1 2 1 1
Derby 5 10 2 0 0 0 2 4 3 1
Colt 6 11 0 0 0 0 0 3 3 0
Avrora 78 29 4 2 1 2 4 7 3 4
Tomcat 119 411 9 10 3 4 11 18 10 8
Batic 73 33 5 4 1 3 7 10 3 7
Eclipse 89 389 9 8 4 6 13 23 12 11
FOP 15 11 1 1 0 0 2 4 2 2
H2 25 17 0 1 0 0 1 3 2 1
PMD 20 8 2 2 0 1 3 4 2 2
Sunow 31 11 1 2 0 2 2 6 4 2
Xalan 42 210 3 4 0 2 4 9 5 4
TOTAL 570 1275 55 50 14 29 75 146 86 60
Figure 5: The numbers of deadlocks found in 22 benchmarks by 7 techniques.
Static Hybrid Dynamic
benchmarks Chord GoodLock DeadlockFuzzer ConTest Jcarder Java HotSpot Sherlock
Sor 4:23 0:04 0:05 0:07 0:12 0:15 0:39
TSP 8:09 0:02 0:02 0:06 0:17 0:18 0:50
Hedc 20:11 0:04 0:06 0:08 0:19 0:23 0:44
Elevator 5:19 0:06 0:07 0:11 0:09 0:13 0:51
ArrayList 3:10 0:03 0:04 0:05 0:11 0:19 0:28
TreeSet 2:55 0:02 0:02 0:05 0:11 0:22 0:26
HashSet 2:47 0:04 0:05 0:06 0:10 0:14 0:35
Vector 5:31 0:03 0:03 0:07 0:12 0:17 0:19
RayTracer 4:22 0:02 0:03 0:04 0:19 0:09 0:30
MolDyn 5:34 0:05 0:08 0:12 0:24 0:23 0:49
MonteCarlo 4:48 0:05 0:05 0:13 0:15 0:17 1:02
Derby 46:17 0:12 0:18 0:19 0:48 0:55 1:25
Colt 15:58 0:08 0:13 0:14 0:13 0:20 0:31
Avrora 51:36 0:22 0:24 0:22 0:51 1:02 1:16
Tomcat 58:24 0:20 0:23 0:27 0:49 0:54 4:15
Batic 43:03 0:14 0:19 0:20 0:30 0:41 1:07
Eclipse 59:20 0:29 0:30 0:29 0:38 0:49 3:21
FOP 38:00 0:13 0:19 0:33 0:21 0:33 1:43
H2 27:19 0:10 0:14 0:29 0:29 0:40 0:57
PMD 45:05 0:07 0:10 0:08 0:19 0:23 0:53
Sunow 39:12 0:16 0:18 0:21 0:32 0:52 1:46
Xalan 40:53 0:14 0:19 0:22 0:27 0:55 3:02
geom. mean 17:39 0:06 0:09 0:12 0:20 0:26 0:59
Figure 6: Timings in minutes and seconds.shows that the permute method scales to long schedules.
For each of seven benchmarks (Derby, Colt, Tomcat, Batic,
Eclipse, Sunow, Xalan), at least one real deadlock happens
with a schedule that has more than a million events. Among
the 33 deadlocks found after at least a million steps, 27 were
found only by Sherlock. Given that Sherlock can reproduce
every deadlock, we conclude that Sherlock does a much bet-
ter job than previous work to nd reproducible deadlocks
than the previous techniques with which we have compared.
5. LIMITATIONS
Our approach has four main limitations.
First, our current implementation of Sherlock supports
synchronized methods and statements, but has no support
for other synchronization primitives such as wait, notify, and
notify all. We leave support for those to future work.
Second, our approach relies on GoodLock to produce dead-
lock candidates. In case GoodLock misses a deadlock, so
will Sherlock. Note here that GoodLock itself is a partly
dynamic analysis that analyzes a particular execution. If
we run GoodLock multiple times (perhaps with dierent in-
puts) we may in total get a larger set of deadlock candidates
and miss fewer deadlocks.
Third, our approach relies on a constraint solver both in
permute and execute . The form of constraints that we use
inpermute has a decidable satisability problem, while the
form of constraints that we use in execute are derived from
expressions in the program text and may be undecidable.
So for execute , the power of the constraint solver is critical.
Fourth, our approach has no support for native code.
6. RELATED WORK
In Section 4, we discussed six techniques for deadlock de-
tection, namely Chord [46, 45], GoodLock [29], Deadlock-
Fuzzer [36], ConTest [16, 20], Jcarder [17], and Java HotSpot
[48] and we did a large-scale experimental comparison of all
six and Sherlock. The goal of this section is to highlight some
other notable techniques and tools in the area of deadlock
detection for unannotated programs.
Run-time monitoring systems. Arnold, Vechev, and
Yahav [2] presented the QVM run-time environment that
continuously monitors an execution and potentially detects
defects, including deadlocks. Huang, Zhang, and Dolby [34]
presented an ecient approach to log execution paths and
then do o-line computation in order to reproduce concur-
rency bugs such as deadlocks. Another idea is to let the op-
erating system detect deadlocks [39]. All three approaches
monitor executions but do nothing to drive an execution
towards a deadlock.
Model checking. Demartini et al. [14] presented a trans-
lation from Java source code to Promela that enables dead-
lock detection via the SPIN model checker [31]. The transla-
tor predates Java 6 and would require signicant extension
to handle our benchmarks. Chaki et al. [13] and Godefroid
[27] presented model checkers for C that can nd deadlocks.
Static deadlock detectors. Static deadlock detectors
[44, 43, 3, 18, 32, 63, 37, 61, 45] have a goal that is dual to
our objective to nd real deadlocks: they attempt to nd all
deadlocks and possibly some false positives. Chord remains
one of the best among the scalable static deadlock detectors
for Java to date, hence it was our choice for experimental
comparison in this paper.Dynamic deadlock detectors for Java. ASN [11] rst
extracts constraints from a deadlock candidate and formu-
lates them as barriers, and then uses a form of random
scheduling to trigger real deadlocks with high probability.
ConLock [12] rst does an initial run and generates schedul-
ing constraint from the trace and from a deadlock candidate,
and then uses a form of random scheduling that works within
the limits of the generated scheduling constraints. Wolf [53]
rst does an initial run and does cycle detection, then prunes
away cycles that cannot be executed, then generates a syn-
chronization dependency graph, and nally uses a form of
scheduling based on that graph.
The papers on ASN and ConLock report on experiments
with a single Java benchmark of 36,300 lines of Java, for
which the tools found 8 and 4 deadlocks, respectively. They
also report on experiments with larger C/C++ benchmarks.
The paper on Wolf reports on multiple benchmarks, the
largest of which is 160,000 lines of Java and for which the
tool found 6 deadlocks. None of those tools use schedule
permutation or concolic execution.
Static analyses of traces. Our permute function em-
bodies a static analysis of a trace. Researchers have pre-
sented many such analyses [21, 38, 25, 65] that might help
dene alternative permute functions.
Other dynamic techniques. Penelope [58] is a dynamic
tool that detects atomicity violations. Penelope runs a pro-
gram and then analyzes (with an SMT solver) the recorded
reads and writes to predict a schedule that leads to an atom-
icity violation. Penelope doesn't use concolic execution. Re-
cent papers [51, 33, 40] show how to detect data races in
event-driven and reactive programs; their techniques might
also be useful for deadlock detection in such programs.
Dynamic deadlock detectors for other languages.
PCT (Probabilistic Concurrency Testing) [7] is a concurrency-
bug (including deadlock) detector for C and C++ that uses a
probabilistic technique to generate a thread schedule. They
found one bug in each of eight benchmarks. Their largest
benchmark is 245 thousand lines of code.
MagicFuzzer [10] is a deadlock detector for C and C++
that uses a variant of the technique used in DeadlockFuzzer.
The novelty is that MagicFuzzer can conrm multiple cycles
in the same run. For benchmarks of about 16 million lines
of code, MagicFuzzer found 2 real deadlocks.
7. CONCLUSION
We have shown how to detect deadlocks by a combina-
tion of concolic execution and a novel approach to schedule
permutation. The result is a scalable and useful deadlock de-
tector. For a large benchmark suite, our tool Sherlock found
86 deadlocks that were missed by earlier techniques. Among
those 86 deadlocks, about a third namely 27 deadlocks were
found with schedules that have more than 1 million events.
Our technique can nd deadlocks after many steps of com-
putation because the combination of concolic execution and
schedule permutation helps drive an execution towards a
deadlock candidate.
Our experiments show that DeadlockFuzzer, ConTest, and
Sherlock together nd a total of 161 real deadlocks in 4.5
million lines of code. As far as we know, this is the most
comprehensive list of real deadlocks for those benchmarks
that is reported in the literature.
Acknowledgments. We thank the FSE reviewers for in-
sightful comments that helped us improve the paper.8. REFERENCES
[1] R. Agarwal, L. Wang, and S. D. Stoller. Detecting
potential deadlocks with static analysis and runtime
monitoring. In PADTAD , 2005.
[2] M. Arnold, M. Vechev, and E. Yahav. Qvm: An
ecient runtime for detecting defects in deployed
systems. In OOPSLA, ACM Conference on
Object-Oriented Programming, Systems, Languages,
and Applications , pages 143{162, 2008.
[3] C. Artho and A. Biere. Applying static analysis to
large-scale, multi-threaded java programs. In
Proceedings of ASWEC'01, 13th Australian Software
Engineering Conference , pages 68{75, 2001.
[4] Stephen M. Blackburn, Robin Garner, Chris
Homann, Asjad M. Khang, Kathryn S. McKinley,
Rotem Bentzur, Amer Diwan, Daniel Feinberg, Daniel
Frampton, Samuel Z. Guyer, Martin Hirzel, Antony
Hosking, Maria Jump, Han Lee Intel, J. Eliot B. Moss,
Aashish Phansalkar, Darko Stefanovic, Thomas
VanDrunen, Daniel von Dincklage, and Ben
Wiedermann. The DaCapo benchmarks: Java
benchmarking development and analysis. In
OOPSLA'06, 21st annual ACM SIGPLAN conference
on Object-Oriented Programming Systems, Languages,
and Applications , pages 169{190, 2006.
[5] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela
Oueslati, and Mira Mezini. Taming reection: Aiding
static analysis in the presence of reection and custom
class loaders. In ICSE, 33rd International Conference
on Software Engineering , May 2011.
[6] C. Boyapati, R. Lee, and M. Rinard. Ownership types
for safe programming: Preventing data races and
deadlocks. In OOPSLA, ACM Conference on
Object-Oriented Programming, Systems, Languages,
and Applications , pages 211{230, 2002.
[7] Sebastian Burckhardt, Pravesh Kothari, Madanlal
Musuvathi, and Santosh Nagarakatte. A randomized
scheduler with probabilistic guarantees of nding
concurrency bugs. In ASPLOS, International
Conference on Architectural Support for Programming
Languages and Operating Systems , pages 167{178,
2010.
[8] J. Burnim and K. Sen. Heuristics for scalable dynamic
test generation. In Proc. 23rd IEEE/ACM
International Conference on Automated Software
Engineering , pages 443{446, 2008.
[9] Cristian Cadar, Paul Twohey, Vijay Ganesh, and
Dawson Engler. Exe: A system for automatically
generating inputs of death using symbolic execution.
InProceedings of 13th ACM Conference on Computer
and Communications Security , 2006.
[10] Y. Cai and W. K. Chan. MagicFuzzer: Scalable
deadlock detection for large-scale applications. In
ICSE'12, International Conference on Software
Engineering , pages 606{616, 2012.
[11] Y. Cai, C.J. Jia, S.R. Wu, K. Zhai, and W.K. Chan.
ASN: a dynamic barrier-based approach to
conrmation of deadlocks from warnings for large-scale
multithreaded programs. IEEE Transactions on
Parallel and Distributed Systems , 2014.
[12] Y. Cai, S. Wu, and W. K. Chan. ConLock: A
constraint-based approach to dynamic checking ondeadlocks in multithreaded programs. In ICSE'14,
International Conference on Software Engineering ,
2014.
[13] S. Chaki, E. Clarke, J. Ouaknine, N. Sharygina, and
N. Sinha. Concurrent software verication with states,
events, and deadlocks. Formal Aspects of Computing ,
17(4):461{483, 2005.
[14] C. Demartini, R. Iosif, and R. Sisto. A deadlock
detection tool for concurrent Java programs. Software
{ Practice & Experience , 29(7):577{603, 1999.
[15] Jyotirmoy Deshmukh, E. Allen Emerson, and Sriram
Sankaranarayanan. Symbolic deadlock analysis in
concurrent libraries and their clients. In Proceedings of
ASE'09, IEEE International Conference on
Automated Software Engineering , pages 480{491, 2009.
[16] Orit Edelstein, Eitan Farchi, Evgeny Goldin, Yarden
Nir, Gil Ratsaby, and Shmuel Ur. Framework for
testing multi-threaded Java programs. Concurrency
and Computation: Practice and Experience ,
15(3{5):485{499, 2003.
[17] ENEA. Jcarder. http://www.jcarder.org .
[18] D. Engler and K. Ashcraft. RacerX: Eective, static
detection of race conditions and deadlocks. In SOSP,
Nineteenth ACM Symposium on Operating Systems
Principles , pages 237{252, 2003.
[19] Mahdi Eslamimehr and Jens Palsberg. Race directed
scheduling of concurrent programs. In Proceedings of
PPOPP'14, ACM Annual Symposium on Principles
and Practice of Parallel Programming , 2014.
[20] E. Farchi, Y. Nir-Buchbinder, and S. Ur. A cross-run
lock discipline checker for java. In PADTAD , 2005.
[21] Azadeh Farzan and P. Madhusudan. Causal atomicity.
InProceedings of CAV'06, International Conference
on Computer Aided Verication , pages 315{328, 2006.
[22] Cormac Flanagan and Patrice Godefroid. Dynamic
partial-order reduction for model checking software. In
Proceedings of POPL'05, ACM Symposium on
Principles of Programming Languages , Long Beach,
CA, USA, January 2005. ACM Press.
[23] Cormac Flanagan, K. Rustan M. Leino, Mark
Lillibridge, Greg Nelson, James B. Saxe, and Raymie
Stata. Extended static checking for Java. In
Proceedings of PLDI'02, ACM Conference on
Programming Language Design and Implementation ,
pages 234{245, 2002.
[24] European Organization for Nuclear Research (CERN).
Colt. http://acs.lbl.gov/software/colt/ .
[25] Vojtech Forejt, Daniel Kroening, Ganesh
Narayanaswamy, and Subodh Sharma. Precise
predictive analysis for discovering communication
deadlocks in MPI programs. In Proceedings of FM'14,
Formal Methods , pages 263{278, 2014.
[26] Apache Software Foundation. Derby.
http://db.apache.org/derby .
[27] P. Godefroid. Model checking for programming
languages using Verisoft. In Proceedings of POPL'97,
24th Annual ACM Symposium on Principles of
Programming Languages , pages 174{186, 1997.
[28] Patrice Godefroid, Nils Klarlund, and Koushik Sen.
Dart: directed automated random testing. In
Proceedings of PLDI'05, ACM SIGPLAN Conferenceon Programming Language Design and
Implementation , pages 213{223, 2005.
[29] Klaus Havelund. Using runtime analysis to guide
model checking of Java programs. In Proceedings of
SPIN'00, Model Checking Software, International
SPIN Workshop , pages 245{264. Springer-Verlag,
2000.
[30] Klaus Havelund and Thomas Pressburger. Model
checking Java programs using Java pathnder.
Software Tools for Technology Transfer , 2(4):366{381,
2000.
[31] G. Holzmann. The Spin model checker. IEEE
Transactions on Software Engineering , 23(5):279{295,
1997.
[32] David Hovemeyer and William Pugh. Finding
concurrency bugs in Java. In Proceedings of the PODC
Workshop on Concurrency and Synchronization in
Java Programs , 25{26 2004.
[33] Chun-Hung Hsiao, Jie Yu, Satish Narayanasamy,
Ziyun Kong, Cristiano L. Pereira, Gilles A. Pokam,
Peter M. Chen, and Jason Flinn. Race detection for
event-driven mobile applications. In Proceedings of
PLDI'14, ACM SIGPLAN Conference on
Programming Language Design and Implementation ,
2014.
[34] Je Huang, Charles Zhang, and Julian Dolby. CLAP:
Recording local executions to reproduce concurrency
failures. In Proceedings of PLDI'13, ACM SIGPLAN
Conference on Programming Language Design and
Implementation , 2013.
[35] P. Joshi, M. Naik, K. Sen, and D. Gay. An eective
dynamic analysis for detecting generalized deadlocks.
InACM FSE'10, Symposium on the Foundations of
Software Engineering , 2010.
[36] P. Joshi, C. S. Park, K. Sen, and M. Naik. A
randomized dynamic program analysis technique for
detecting real deadlocks. In Proceedings of PLDI'09,
ACM SIGPLAN Conference on Programming
Language Design and Implementation , pages 110{120,
June 2009.
[37] Vineet Kahlon, Franjo Ivancic, and Aarti Gupta.
Reasoning about threads communicating via locks. In
Proceedings of CAV'05, International Conference on
Computer Aided Verication , pages 505{518, 2005.
[38] Vineet Kahlon and Chao Wang. Universal causality
graphs: A precise happens-before model for detecting
bugs in concurrent programs. In Proceedings of
CAV'10, International Conference on Computer Aided
Verication , pages 434{449, 2010.
[39] T. Li, C. S. Ellis, A. R. Lebeck, and D. J. Sorin. A
dynamic deadlock detection mechanism using
speculative execution. In Proceedings of the USENIX
Technical Conference , 2005.
[40] Pallavi Maiya, Aditya Kanade, and Rupak Majumdar.
Race detection for android applications. In
Proceedings of PLDI'14, ACM SIGPLAN Conference
on Programming Language Design and
Implementation , 2014.
[41] Rupak Majumdar and Ru-Gang Xu. Directed test
generation using symbolic grammars. In Proceedings of
the twenty-second IEEE/ACM International
Conference on Automated Software Engineering , 2007.[42] Daniel Marino, Christian Hammer, Julian Dolby,
Mandana Vaziri, Frank Tip, and Jan Vitek. Detecting
deadlock in programs with data-centric
synchronization. In ICSE'13, International Conference
on Software Engineering , 2013.
[43] S. Masticola. Static Detection of Deadlocks in
Polynomial Time . PhD thesis, Rutgers University,
1993.
[44] S. Masticola and B. Ryder. A model of Ada programs
for static deadlock detection in polynomial time. In
Proceedings of ACM/ONR Workshop on Parallel and
Distributed Debugging , pages 97{107, 1991.
[45] M. Naik, C.-S. Park, and D. Gay. Eective static
deadlock detection. In ICSE'09, Eighteenth
International Conference on Software Engineering ,
pages 386{396, 2009.
[46] Mayur Naik, Alex Aiken, and John Whaley. Eective
static race detection for Java. In Proceedings of
PLDI'06, ACM Conference on Programming Language
Design and Implementation , 2006.
[47] Elissa Newman, Aaron Greenhouse, and William
Scherlis. Annotation-based diagrams for shared-data
concurrency. In Workshop on Concurrency Issues in
UML , 2001.
[48] Oracle. Java hotspot vm options.
http://www.oracle.com/technetwork/java/javase/
tech/vmoptions-jsp-140102.html .
[49] Oracle. The Java tutorials; deadlock.
http://docs.oracle.com/javase/tutorial/
essential/concurrency/deadlock.html .
[50] Oracle. JDK, 1.4.2. http://www.oracle.com/
technetwork/java/javase/index-jsp-138567.html .
[51] Veselin Raychev, Martin Vechev, and Manu Sridharan.
Eective race detection for event-driven programs. In
Proceedings of OOPSLA'13, ACM SIGPLAN
Conference on Object-Oriented Programming Systems,
Languages and Applications , pages 151{166, 2013.
[52] Mahmoud Said, Chao Wang, Zijiang Yang, and
Karem A. Sakallah. Generating data race witnesses by
an SMT-based analysis. In NASA Formal Methods ,
pages 313{327, 2011.
[53] Malavika Samak and Murali Krishna Ramanathan.
Trace driven dynamic deadlock detection and
reproduction. In Proceedings of PPOPP'14, ACM
Annual Symposium on Principles and Practice of
Parallel Programming , 2014.
[54] Cesar Sanchez, Henny B. Sipma, Zohar Manna, and
Christopher D. Gill. Ecient distributed deadlock
avoidance with liveness guarantees. In Proceedings of
EMSOFT'06, International Conference on Embedded
Software . Springer-Verlag ( LNCS ), 2006.
[55] Koushik Sen. Concolic testing. In Proceedings of the
twenty-second IEEE/ACM International Conference
on Automated Software Engineering , pages 571{572,
2007.
[56] Koushik Sen and Gul Agha. Cute and jcute: Concolic
unit testing and explicit path model-checking tools. In
Proc. 18th International Conference on Computer
Aided Verication , pages 419{423, 2006.
[57] Traian Florin Serbanuta, Feng Chen, and Grigore
Rosu. Maximal causal models for multithreaded
systems. Technical report, University of Illinois atUrbana-Champaign. Available from ideals.illinois.edu.
[58] F. Sorrentino, A. Farzan, and P. Madhusudan.
PENELOPE: Weaving threads to expose atomicity
violations. In ACM FSE'10, Symposium on the
Foundations of Software Engineering , pages 37{46,
2010.
[59] S. D. Stoller. Testing concurrent Java programs using
randomized scheduling. In Proceedings of RV'02,
Workshop on Runtime Verication , 2002. volume 70 of
ENTCS.
[60] Lin Tan, Yuanyuan Zhou, and Yoann Padioleau.
acomment: Mining annotations from comments and
code to detect interrupt related concurrency bugs. In
ICSE'11, International Conference on Software
Engineering , 2011.
[61] William Thies and Michael Ernst. Static deadlock
detection for java libraries. In Proceedings of
ECOOP'05, European Conference on Object-Oriented
Programming , pages 602{629. Springer-Verlag
(LNCS ), 2005.
[62] Raja Vall e-Rai, Etienne Gagnon, Laurie Hendren,
Patrick Lam, Patrice Pominville, and Vijay
Sundaresan. Optimizing Java bytecode using the sootframework: Is it feasible? In Proceedings of CC'00,
International Conference on Compiler Construction .
Springer-Verlag ( LNCS ), 2000.
[63] C. von Praun. Detecting Synchronization Defects in
Multi-Threaded Object-Oriented Programs . PhD thesis,
Swiss Federal Institute of Technology, Zurich, 2004.
[64] C. von Praun and T. R. Gross. Object race detection.
InOOPSLA, ACM Conference on Object-Oriented
Programming, Systems, Languages, and Applications ,
pages 70{82, 2001.
[65] Chao Wang and Kevin Hoang. Precisely deciding
control state reachability in concurrent traces with
limited observability. In Proceedings of VMCAI'14,
Verication, Model Checking, and Abstract
Interpretation , pages 376{394. Springer-Verlag
(LNCS ), 2014.
[66] Yin Wang, Terence Kelly, Manjunath Kudlur,
Stephane Lafortune, and Scott Mahlke. Gadara:
Dynamic deadlock avoidance for multithreaded
programs. In Proceedings of OSDI'08, 8th USENIX
Symposium on Operating Systems Design and
Implementation , 2008.