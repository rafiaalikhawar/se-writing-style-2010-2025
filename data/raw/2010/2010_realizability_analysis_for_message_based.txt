Realizability Analysis for Message-based Interactions
Using Shared-State Projections
Sylvain Hallé
Université du Québec à Chicoutimi, Canada
shalle@acm.orgTevﬁk Bultan∗
University of California, Santa Barbara, USA
bultan@cs.ucsb.edu
ABSTRACT
The global interaction behavior in message-based systems
can be speciﬁed as a ﬁnite-state machine deﬁning acceptable
sequences of messages exchanged by a group of peers. Re-
alizability analysis determines if there exist local impleme n-
tations for each peer, such that their composition produces
exactly the intended global behavior. Although there are
existing suﬃcient conditions for realizability, we show tha t
these earlier results all fail for a particular class of speci-
ﬁcations called arbitrary-initiator protocols. We present a
novel algorithm for deciding realizability by computing a
ﬁnite-state model that keeps track of the information about
the global state of a conversation protocol that each peer can
deduce from the messages it sends and receives. By search-
ing for disagreements between each peer’s deduced states,
we provide a sound analysis for realizability that correctly
classiﬁes realizability of arbitrary-initiator protocols.
Categories and Subject Descriptors
B.4.3 [ I/O and Data Communications ]: Interconnec-
tions (Subsystems)— Asynchronous/synchronous operation,
Web technologies ; D.2.1 [ Software Engineering ]: Re-
quirements/Speciﬁcations— Tools, validation
General Terms
Veriﬁcation
Keywords
realizability, asynchronous communication, choreography
1. INTRODUCTION
Nowadays, many software systems consist of multiple
components that execute concurrently, possibly on diﬀer-
ent machines. New trends in computing, such as service-
oriented architecture (SOA), cloud computing, multi-core
∗This work is supported by NSF grants CCF-0916112 and CCF-0716095 , and by
the Fonds qu´ eb´ecois de recherche sur la nature et les technologies (FQRNT) .
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for proﬁt or c ommercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redist ribute to lists, requires prior speciﬁc
permission and/or a fee.
FSE-18, November 7–11, 2010, Santa Fe, New Mexico, USA.
Copyright 2010 ACM 978-1- 60558-791-2/10/ 11 ...$10.00.hardware, all point to more concurrency and distribution
among the components of software systems in the future. In
order to complete a task, components of a software system
have to coordinate their executions by interacting with each
other. A fundamental question is, what should be the in-
teraction mechanism given the trend for increased level of
concurrency and distribution? One emerging paradigm is
message-based communication [3, 5, 8, 15, 18, 19, 21], where
components interact with each other by sending and receiv-
ing messages.
This is particularly the case for SOA, which, through the
use of SOAP and XML, enable interaction among existing
services to form composite, value-added applications. A
key factor in SOA is the loose coupling between the various
parties involved in an interaction. Apart from a mutually-
agreed protocol of interaction (called a conversation proto-
col [10,11] or a choreography speciﬁcation [22] in SOA), each
peer taking part in such a global “conversation” is an inde-
pendent and self-contained unit.
To further loosen this coupling between potential part-
ners, many web services are implemented using asyn-
chronous communication. While in synchronous communi-
cation, the sender and receiver of a message are required
to block their operation for the duration of the message
transfer, in asynchronous communication this restriction is
relaxed by treating sending and receiving as two separate
events. The recipient of a message is no longer required to
synchronize with the sender, and can rather buﬀer messages
in an input queue and process them at an arbitrary later
time.
Interestingly, the same type of message-based interactions
appear in other domains as well. For example, Singular-
ity is a new, experimental, operating system developed by
Microsoft Research to explore new approaches to OS de-
sign [14]. One of its main goals is to improve the depend-
ability of software systems by rethinking some design de-
cisions that have largely governed operating system archi-
tecture to date. Process isolation is a chief design princi-
ple of the Singularity operating system. To achieve process
isolation, certain constraints are enforced to ensure process
independence. Among these is the rule that processes can-
not share memory with each other or the kernel. All inter-
process communication in Singularity, therefore, occurs via
message passing over bidirectional conduits, called channels.
Channels have two end points referred to as the client and
the server that communicate with each other by sending
and receiving messages. Communication through Singular-
ity channels corresponds to asynchronous communication
27CS :c /c174
SC :f /c174SC :f /c174CS :s /c1740
3
41
2
(a)CS :c /c174
CS :c /c174 SC :f /c174SC :f /c174CS :s /c1740
1
23
4
(b)
Figure 1: Two simple ﬁle transfer protocols.
via FIFO message queues. Moreover, in Singularity, each
channel is governed by a channel contract [8]. A channel con-
tract is a state machine that speciﬁes the allowable ordering
of messages between the client and the server. Hence, chan-
nel contracts are a type of conversation protocols and serve
the same purpose that choreography speciﬁcations serve in
SOA.
Asynchronous communication is appealing for simplifying
the management of message exchanges in SOA or when iso-
lating processes from each other in an operating system, but
many natural assumptions about synchronous protocols no
longer hold when message queuing is involved. For example,
Figure 1a shows a speciﬁcation for the control channel of a
simple ﬁle transfer protocol between a client (C) and a server
(S). After asking for the start of a transfer ( s), the sequence
of possible messages depends on who initiates the remain-
ing part of the conversation. If C sends a “cancel transfer”
message ( c) ﬁrst, then S should replyto C’s request with a
“transfer ﬁnished” message ( f); on the other hand, no can-
cellation request should be issued by C once S notiﬁes that
the transfer is complete.
Albeit simple, this protocol p resents problems. In the sit-
uation where S sends fﬁrst, but its message remains in tran-
sit for some time, C might believe the transfer is not ﬁnished
and send c, thus violating the protocol and perhaps throw-
ing S into an undeﬁned state. This happens, even though
each peer locally complies with the protocol. The “fault”,
in this case, is not any of the peers’; it is rather rooted in
the fact that asynchronous communication is used. Proto-
cols that exhibit this type of behavior are called unrealizable
protocols.
The question of deciding whether a given protocol is real-
izable or not is an open problem. The presence of unbounded
input queues makes the exhaustive search of all possible
communication traces impossible. There has been two sep-
arate branches of research to address this problem and suf-
ﬁcient realizability conditions have been developed indepe n-
dently 1) through the analysis of the state machines charac-
terizing the allowable conversations (e.g., [10,11,16]), or 2)
by reformulating the problem within a type system that pre-
vents the declaration of unrealizable protocols (e.g., [12, 13]).
These conditions are sound and can be used to formally
prove the realizability, however, they are not complete, and
can produce false positives. In particular, a “ﬁxed” version
of the ﬁle transfer protocol, shown in Figure 1b, will be
identiﬁed as unrealizable by both approaches, although it
actually isrealizable. We show that this will be the case of
any protocol containing a state with an arbitrary initiator ,i.e., a state where more than one peer could send the next
message and the protocol works ﬁne for either case.
In this paper, we present a novel way of deciding the real-
izability of a protocol in the presence of asynchronous com-
munication. Our technique is based on the observation that
in a realizable protocol, a global observer can follow the con -
versation between the peers and, at any moment, determine
precisely the global state of the protocol. Each individual
peer, based on the messages it sends and receives, can only
guess plausible values for that global state. We show how
to compute an annotated version of the original protocol,
speciﬁc to each peer, called shared-state projections , includ-
ing such guesses. We demonstrate that, at any moment in a
realizable protocol, there exists at least one state which all
peers agree is a “believable” global state. Conversely, this
entails that in many cases, unrealizable protocols have two
of their peers straying until they have irreconcilable beliefs
of the current global state. Since the number of protocol
states is ﬁnite, the number of belief states is also ﬁnite, and
searching for such “discordant” belief states can be done ex-
haustively.
The contributions of this paper are: 1) We provide a nat-
ural explanation of realizability based on the consistency of
the observations of the diﬀerent peers. 2) We give a new, suf-
ﬁcient condition to ensure realizability of a conversation pro -
tocol that can be evaluated automatically using shared-state
projections. 3) We show that our realizability condition ca n
correctly identify realizable arbitrary-initiator protocols, as
opposed to earlier work based on conversations [10,11] and
session types [13] which always produce false positives for
this class of protocols.
In Section 2, we review the concepts about conversation
protocols and deﬁne realizability. In Section 3, we develop
the concept of shared-state channel system and show how to
compute shared-state projections. We also demonstrate the
soundness of our method. In Section 4, we present a tool we
developed to automatically compute belief projections and
analyze its results on more than 100 real-world protocols.
We show in particular how protocols deemed unrealizable
with earlier approaches can be shown realizable with our
new approach. In Section 5, we review the earlier results
on realizability and show that they fail to correctly analyze
arbitrary-initiator protocols. Finally, in Section 6 we con-
clude the paper and indicate further research directions.
2. MODELING MESSAGE-BASED INTER-
ACTIONS
In this section we ﬁrst present a formal model for con-
versation protocols, which are ﬁnite state machines that are
used to specify the set of allowable message sequences. Next
we discuss channel systems, which is a formal model for a set
of components (i.e. peers) that interact with asynchronous
messaging. Finally, we formalize the realizability problem
based on conversation protocols and channel systems.
2.1 Conversation Protocols
A natural way of specifying the allowable message-based
interactions in a concurrent or distributed system is to use a
ﬁnite state machine that serves as the agreed-upon protocol
among the peers that interact with each other. Such speci-
ﬁcations can be formalized as conversation protocols [10]:
Definition 1.Aconversation protocol is a quintuplet
28AB :m1 /c174
AB :m4 /c174 BC :m3 /c174CA :m2 /c174
2
3 40
1
(a)CAB :m1 /c174
AB :m4 /c174CA :m2 /c174
{2}
{4}{0}
{1,3}
(b)πA(C)
AB :m1 /c174
BC :m3 /c174AB :m4 /c174
{4}
{3}{0,2}
{1}
(c)πB(C)CA :m2 /c174 BC :m3 /c174
{3}{0,1}
{2,4}
(d)πC(C)
AB :m1 /c174
AB :m4 /c174 BC :m3 /c174CA :m2 /c174A:{0} B:{0,2} C:{0,1}
A:{1} B:{1} C:{0,1}
A:{1,3} B:{3} C:{3}A:{2} B:{0,2} C:{2,4}
A:{4} B:{4} C:{2,4}
(e)πA(C)×πB(C)×πB(C)
Figure 2: A conversation protocol C(a), its projection for
peers A, B and C (b–d), and the product of these three
projections (e).
C=(P,S,s 0,L ,δ)where P={p0,...,}is a ﬁnite set of
peers,S={s0,...,}is a ﬁnite set of states,s0∈Sis the
initial state, L={ℓ0,...}is ﬁnite a set of message labels ,
andδ:S×P×L×P→Sis a transition function.
At r i p l e t( p,ℓ,p′) is called a message and represents peer
psending the message with label ℓto peer p′.T h e t r a n -
sition function is such that δ(sm,p,ℓ,p′) returns the state
snaccessible from state smfor that message. We extend
the deﬁnition of δover sets of states, such that for a subset
S′⊆S,w eh a v e δ(S′,p,ℓ,p′)=/uniontext
s∈S′δ(s,p,ℓ,p′).
A sequence of messages is accepted by Cas long as it cor-
responds to some valid path that starts from its initial state.
We do not deﬁne explicit “accepting states” for conversation
protocols (or equivalently we assume that all states are ac-
cepting). The language accepted by C,n o t e d L(C), is the set
of message sequences that are accepted by C.
A conversation protocol Ccan be projected to one of its
peers p, noted as πp(C), which is obtained by replacing ev-
ery transition where pis neither the sender nor the receiver
by an ǫ-transition. For example, Figure 2b shows the pro-
jection of Figure 2a onto peer A. Since, in that protocol,
the transition from state 1 to state 3 does not involve A,
it becomes an “invisible” transition in the projection. One
might then collapse any states linked by an ǫ-transition as
a single, compound state whose label becomes a subset of
states from the original conversation. For peer A, the ǫ-transition causes the collapse of states 1 and 3 into a single
state, labeled {1,3}.
Individual conversation protocols C0,...,Cncan also be
combined in a form of Cartesian product, noted C0×···×C n,
similar to DFA product operation. Figure 2 shows examples
of these concepts [4].
2.2 Channel Systems
Achannel system is a formal model for a set of peers that
interact with asynchronous messages. When a message is
sent it is not immediately received as in synchronous com-
munication, but, rather, it is stored in the input queue of the
receiver and can be consumed by the receiver at an arbitrary
later time.
One way of producing a channel system is by composing
a set of conversation protocols C0,...,Cncorresponding to
peer behaviors. Intuitively, each peer possesses its own input
message queue and its own ﬁnite-state control; it sends and
receives messages according to its individual control state
and queue contents. Channel systems formalize this type of
behavior [2].
LetPbe a set of peers, Lbe a set of message labels, and
Ci=(P,Si,si
0,L ,δi)( 0≤i≤|P|) be a set of conversation
protocols, one for each peer in P. For a set of messages M=
(P×L×P), we let M∗denote the set of ﬁnite words over
this alphabet of triplets; these words represent the contents
of each peer’s input message queue. A global state ˙sof˙C
is a pair /angbracketleft(˙s0,...,˙s|P|),w/angbracketright,w h e r e ˙ si∈Siandw:P→
M∗associates each conversation protocol with a state and a
message vector (denoting the contents of each peer’s input
message queue). A channel system is deﬁned over these
elements as follows:
Definition 2.Achannel system ˙Cis a quintuplet
(P,˙S,˙s0,M,˙δ)where ˙S⊆(S0×···× S|P|)×M∗|P|is a
ﬁnite set of control states, ˙s0∈˙Sis the initial control
state, M=P×L×Pis a ﬁnite set of messages, and
˙δ⊆˙S×(M×{!,?})×˙Sis a ﬁnite set of transitions.
The initial global state ˙ s0of˙Cis the pair
/angbracketleft(s0
0,...,s|P|
0),wǫ/angbracketright,w h e r e wǫ(p)= ǫfor each peer p
(i.e., each peer starts with an empty input message queue).
Since send and receive events are now decoupled from each
other, the transition relation is deﬁned over directed mes-
sages m→, which are tuples ( m,⋆)∈M×{!,?},w h e r e m
is a message and ⋆is either “!” (representing the sending of
m)o r“ ? ”( r e p r e s e n t i n g mbeing read from the recipient’s
input queue).
The relation ˙δis deﬁned as the smallest set of triplets
(˙s, m→,˙s′)w h e r e˙ s=(˙s0,..., ˙s|P|)a n d˙ s′=(˙s0′,..., ˙s|P|′)
are control states, and m→=( (pm,ℓ,p n),⋆)i sad i r e c t e d
message, such that:
1. If /angbracketleft˙s,((pm,ℓ,p n),!),˙s′/angbracketright∈δ, then the control states
change from ˙ sto ˙s′and ( pm,ℓ,p n) is appended to
the tail of channel w(pn); all other channels do not
change. Moreover, ˙ sm′=δm(˙sm)a n da l lo t h e r s ˙ si′do
not change.
2. Similarly, if /angbracketleft˙s,((pm,ℓ,p n),?),˙s′/angbracketright∈δ, then the control
states change from ˙ sto ˙s′and (pm,ℓ,p n) is removed
from the head of channel w(pn); all other channels do
not change. Moreover, ˙ sn′=δn(˙sn)a n da l lo t h e r s ˙ si′
do not change.
29As an example, Figure 3 shows a portion of the channel
system obtained by composing the projections in Figure 2.
Each state of this channel system lists the projection state
for peers A, B, and C, followed by the contents of the queue
f o re a c hp e e r ,i nt h ef o r m( p,w(p)), where pis the peer’s
name and w(p) is the contents of its queue.
From a trace of states ˙ s0,...,˙skin a channel system ˙C,
one can extract the corresponding sequence of directed mes-
sages ( m0,⋆0),...,(mk−1,⋆k−1). The send trace is the sub-
sequence obtained by keeping the directed messages misuch
that⋆i=! and removing all the other directed messages. The
set of all send traces produced by ˙Cis denoted as L(˙C); we
call it the language accepted by ˙C.
2.3 Realizability
There are six possible executions in the portion of chan-
nel system in Figure 3; these executions create ﬁve distinct
send traces. Let us consider the trace shown in bold, which
corresponds to the following sequence of events. First, peer
C, being in state {0,1}of its projection, can move to its
state {2,4}and send message m2to A’s input queue, which
corresponds to the transition to the subsequent state. Next,
A, still being in state {0}of its projection, chooses to place
message m1in B’s input queue, and moves to state {1,3}.
Finally, B consumes message m1, and immediately sends
m3, ending in its projection state {3}.
This execution has several issues. First, in the last state of
the channel system, A is in state {1,3}and does not expect
any more messages, yet m2is waiting in its queue. Second,
the send trace corresponding to this execution is not part
of the conversation protocol from which the channel system
was derived. As a matter of fact, from the six possible send
traces generated by this portion of channel system, four of
them are “spurious” message sequences not speciﬁed by the
original conversation protocol.
Theorem 1.LetCbe a conversation protocol and ˙Cbe
the channel system obtained from πp0(C),...,π p|P|(C).T h e n
L(C)⊆L(˙C).
Proof. Lets=s0,s1,...be a state trace of C.W e
build a trace ˙s=˙s0,˙s1,...from sas follows. We take
˙s0as the start state in Deﬁnition 2. For each i≥0, if
/angbracketleftsi,(pj,ℓ ,p k),si+1/angbracketright∈δthen:
•˙s2i+1=/angbracketleft(S0′,...,S|P|′),w′/angbracketrightis the global state ob-
tained from ˙ s2iby taking the transition labeled with
the directed message (( pj,ℓ,p k),!)
•˙s2i+2=/angbracketleftS0′′,...,S|P|′′,w′′/angbracketright, is the global state ob-
tained from ˙ s2i+1by taking the transition labeled with
the directed message (( pj,ℓ,p k),?)
Trivially, ˙shas the same send trace as s;m o r e o v e ri t sc o n -
struction follows Deﬁnition 2 and is therefore a trace of
global states in ˙C.
The fact that the relation between Cand˙Cis an inclusion,
and not an equality, is the source of the problem described
in the ﬁle transfer protocol of Figure 1a: the channel system
obtained from the projections of that protocol onto peers
C and S produces one send trace ( s, f, c)t h a ti sn o ti nt h e
original speciﬁcation. A protocol is said to be realizable when
we have a strict equality:AB :m1 /c174 AC :m2 /c174
CB :m6 /c174BC :m5 /c174
BC :m3 /c174 BA :m4 /c174 0
65 3 4
2 1
Figure 4: Deducing B’s possible state from A’s point of view
in a conversation protocol.
Definition 3 (Realizability). A conversation proto-
colCisrealizable if there exists conversation protocols
Cp0,...,Cp|P|for each peer, such that the channel system
˙C=Cp0⊗···⊗C p|P|is such that L(C)=L(˙C).Cisstrictly
realizable when Cpi=πpi(C)for0≤i≤|P|.
3. SHARED-STATE PROJECTIONS
A simple way of ensuring realizability is to develop the
channel system ˙Cand to exhaustively check that no spurious
send trace is produced. However, the presence of unbounded
message queues makes the problem in general intractable,
even for simple protocols [11]. Other criteria must be devel-
oped to decide realizability of a conversation protocol. We
propose Shared-State Projections (SSP) for this purpose.
3.1 An Intuition for SSPs
An SSP is a diﬀerent kind of peer projection for a conver-
sation protocol. Rather than simply projecting the protocol
over a single peer p, an SSP also keeps track, in parallel, of
the state of other peers —or more precisely, of what can be
deduced about that state, based on messages that psends
and receives.
Consider the simple conversation protocol shown in Fig-
ure 4. Suppose, from A’s point of view, that the message
exchange has just started, i.e. all peers are in state 0. It shall
ﬁrst be noted that, from A’s point of view, transitions from
state 0 to state 3 and from state 3 to state 5 are invisible
transitions; therefore, the current state of A is actually the
set{0,3,5}. Moreover, from A’s point of view, 0 is not the
only possible state for peer B:
•Since A cannot distinguish between states 0, 3 and 5,
B can reach these states with no way to know whether
this transition was indeed taken.
•B cannot distinguish between states where it is neither
the sender nor the receiver. Hence, 2 is (vacuously) a
possible state.
•B cannot be in state 1, since it would require A sending
m1. For a similar reason, 6 is unreachable, as it relies
on C’s participation —which in turn depends on A.
•Finally, because communications are asynchronous, B
can send a message to A without A having received
it yet. Hence, when A is in state 0, before it reads
anything from its input queue, B can already be in
state 4.
From this informal chain of deductions, peer A in state
0 “knows” that peer B can be in states {0,2,3,4,5}, but
cannot be in states {1,6}. With a similar reasoning about
C, A can guess that its possible states are {0,1,3,4,5}.
30AB :m1, ! /c174
AB :m1, ? /c174AB :m1, ? /c174 AB :m1, ! /c174
AB :m4, ! /c174
AB :m4, ? /c174 BC :m3, ! /c174BC :m3, ! /c174
BC :m3, ? /c174CA :,  !m2 /c174
CA :m2, ! /c174
CA :m2, ! /c174
CA :m2, ! /c174CA :m2, ? /c174({0},{0,2},{0,1}), ((A, ),(B, ),(C, )) /c101/c101/c101
({1,3},{3},{3}), ((A, ),(B, ),(C, )) /c101/c101/c101({2},{0,2},{2,4}), ((A, ),(B, ),(C, )) /c101/c101/c101
({4},{4},{2,4}), ((A, ),(B, ),(C, )) /c101/c101/c101({1,3},{1},{0,1}), ((A, ),(B, ),(C, )) /c101/c101/c101({0},{0,2},{2,4}), ((A, ),(B, ),(C, )) CA :m2 /c101/c101 /c174
({4},{0,2},{2,4}), ((A, ),(B, ),(C, )) /c101/c101 AB :m4 /c174 ({1,3},{1},{2,4}), ((A, ),(B, ),(C, )) CA :m2 /c101/c101 /c174({1,3},{0,2},{2,4}), ((A, ),(B, ),(C, )) CA AB ::mm21 /c101 /c174/c174
({1,3},{3},{2,4}), ((A, ),(B, ),(C, )) CA BC ::mm23 /c101 /c174/c174({1,3},{0,2},{0,1}), ((A, ),(B, ),(C, )) /c101/c101 AB :m1 /c174
({1,3},{3},{0,1}), ((A, ),(B, ),(C, )) /c101/c101 BC :m3 /c174
Figure 3: A portion of a channel system obtained from the composi tion of the peer projections in Figure 2(b–d).
The initial state of A’s SSP is therefore a triplet of sets
of states, one for each peer, as follows: A: {0,3,5},B :
{0,2,3,4,5},C :{0,1,3,4,5}. From that list of possible
states, one can then compute possible transitions , leading
to new combinations of possible states, and so on:
Definition 4.LetC=(P,S,s 0,L ,δ)be a conversation
protocol, with |P|the number of peers involved in C.A
shared-state projection (SSP) derived from C,f r o m p’s point
of view, noted /hatwideπp(C), is a quintuplet (P,/hatwideS,/hatwides0,L ,/hatwideδ),w h e r e
/hatwideS=( 2S)|P|is a set of shared peer states ,/hatwides0∈/hatwideSis the
initial state, and /hatwideδ:/hatwideS×P×L×P→/hatwideSis a transition
function.
An SSP can be seen as a “hybrid”: like channel systems,
one keeps track of states for all peers, but like conversa-
tion protocols, queue contents are not directly taken into
account.
3.2 Conditions on SSPs
We now proceed to give conditions on an SSP that, taken
together, deﬁne an algorithm for computing it. The informal
presentation of an SSP showed that guessing possible states
for other peers involves computing some kind of“reachability
function” over a set of starting states. Indeed, the possible
state of each peer is interdependent with the actions per-
formed by other peers. For example, in Figure 5a, B cannot
advance to state s3along the path s0...s3without A ﬁrst
sending m1to D, and D then sending m2to B. In other
words, A indirectly “controls” or “blocks” B from reaching
s3along that path. On the contrary, in Figure 5b, A does
not constrain B from reaching s3. This notion is formalized
below.
Definition 5 (Blocking peer). Let¯s=s1s2...s n
be a path in C,a n dl e t pbe some peer. The peers blocked
bypatsnalong π,n o t e d Bp(¯s), is the smallest set of peers
such that:
1.p∈Bp(¯s)
2. if there exists a transition p1m→p2from a pair of states
si,si+1in¯s,a n d p1∈Bp(¯s),t h e n p2∈Bp(¯s).0 12 3A/c174D:m1D/c174B:m2B/c174C:m3
(a)
0 12 3A/c174D:m1D/c174C:m2B/c174C:m3
(b)
Figure 5: Diﬀerent scenarios for blocked peers along a path
From this deﬁnition of a blocking peer, we develop a form
of reachability, called ( p,p′)-reachability .
Definition 6 ( (p,p′)-reachability). Letp,p′be two
peers and s, s′∈Sbe two states of a conversation. The
states′is(p,p′)-reachable fromsif and only if there exists
ap a t h s0,...,s n(s0=s,sn=s′)a n ds o m e 0≤k≤nsuch
that: 1) along s0...s k, the sender is not blocked by p′,a n d
along sk...s n,pis neither the sender nor the recipient of
any message.
To get B’s possible states in our motivating example, we
computed all states that are (A,B)-reachable from state 0.
We indeed obtain the set {0,2,3,4,5}. Similarly, possible
states for A and C have been obtained through (A,A)- and
(A,C)-reachability. Thus we obtain a formal deﬁnition of an
initial state in an SSP:
Definition 7 (Initial state). The initial state /hatwides0of
an SSP /hatwideCdeveloped from p’s point of view is the |P|-tuple
(σ0,...,σ |P|)such that σiis the set of states (p,pi)-reachable
froms0, the initial state of C.
From this initial state of an SSP, one is then interested
in ﬁnding possible transitions , and to compute the resulting
state for each transition. We need to introduce two auxil-
iary functions that will be used in this computation. We
ﬁrst extend a transition function δwithδ#, that returns
a special symbol # standing for “empty”. More precisely,
δ#(s)=δ(s)w h e n δ(s) is deﬁned, and δ#(s)=#o t h e r -
wise. Similarly, for a subset S′⊆S,w eh a v e δ#(S′)=δ(S′)
ifδ(S′)/negationslash=∅,a n d δ#(S′)=#o t h e r w i s e .
31A second useful function that will be used is the
Post(S′,ℓ) function, which removes from S′all states that
precede the ﬁrst occurrence of some message label ℓin the
conversation protocol C.
Definition 8 ( Postfunction). LetS′⊆Sbe a sub-
set of states of some conversation, and ℓ∈Lbe some mes-
sage label. The function Post(S′,ℓ)returns the smallest sub-
set such that:
1. If there exists pi,pj∈P,s∈Ssuch that
δ(s, pi,ℓ,p j)=s′,t h e n s′∈Post(S′,ℓ)
2. If s∈Post(S′,ℓ),s′∈S′and there exists pi,pj∈
P,ℓ′∈Lsuch that δ(s, pi,ℓ,p j)=s′,t h e n s′∈
Post(S′,ℓ).
Finally, we require one last reachability deﬁnition, namely
?p-reachability :
Definition 9 ( ?p-reachability). LetCbe a conver-
sation protocol, and p∈Pbe some peer. A state s′is?p-
reachable fromsif and only if there exists a path of messages
fromstos′inCwhere pis never the sender.
This intuitively corresponds to the fact that a peer pcan
be in some state s, and have messages waiting to be read
in its input queue. Therefore, s′can be reached by simply
waiting or consuming messages in the queue; the state of
the conversation protocol does not require pto send any
new message to reach that state. Note that this does not
mean that s′willbe the state eventually reached by pafter
reading messages in its queue; it only means that s′is one
of the possible reachable states in that situation.
For some state s∈S, we will note the set of all states
(p,p′)-reachable from sasR(p,p′)
S(s),o rs i m p l y R(p,p′)(s)
when the context is clear. By extension, for some set S′⊆
S, we deﬁne R(p,p′)
S(S′)≡/uniontext
s∈S′R(p,p′)
S(s). The function
Rinduces a partition of the set of states S′into multiple
regions ; the set of such regions will be noted P(p,p′)(S′).
Similar functions can be deﬁned with ? p-reachability.
Equipped with these deﬁnitions, we can deﬁne /hatwideδ,t h et r a n -
sition relation of an SSP.
Definition 10 (Transition relation). Let /hatwides=
(Sp0,...,S p|P|)and/hatwides′=(S′
p0,...,S′
p|P|)be two states
of the SSP /hatwideπp∗(C),f o rs o m ep e e r p∗∈P.T h e n
/hatwideδ(/hatwides, pi,ℓk,pj)= /hatwides′if and only if, for each peer p,o n e
of the following conditions holds:
1.p/negationslash=pi,p∗/negationslash=pj,a n d S′
p=Sp
2.p=pi,a n d S′
p=R(p∗,p)
S(δ(Sp))
3.p∗/negationslash=pi,p/negationslash=pi,p/negationslash=pj,a n d
S′
p=R(p∗,p)
S(Post(/hatwidesp,ℓk))
4. otherwise, S′
p=/uniontext
R∈P?p(Sp)δ#(R)
To build an SSP for some focus peer p∗,i ts u ﬃ c e st oc r e a t e
its initial peer state, and to recursively generate successo rs
to each new peer state according to Deﬁnition 10. In each
node of a shared-state projection, there are |P|subsets of the
original conversation protocol state set S, one for each peer.
Therefore, an SSCS has at most |P|·2|S|distinct nodes, and
the analysis requires computing at most nsuch projections
(one for each peer). Therefore, the procedure is guaranteed
to terminate.3.3 A Realizability Condition
A ﬁrst observation is that, from Deﬁnition 10, /hatwideπis an
over-approximation of π, i.e.L(πp(C))⊆L(/hatwideπp(C)) for every
peerp. The next theorem follows immediately:
Theorem 2.LetCbe a conversation, πpi(C)(0≤i≤
|P|)a n d /hatwideπpi(C)be its peer projections and shared-state pro-
jections, respectively. Let ˙Cbe the channel system obtained
from composing the πpi,a n d˙ˆCbe the channel system ob-
tained from composing the /hatwideπpi,c a l l e da shared-state channel
system .T h e n L(˙C)⊆L(˙ˆC).
From this result, we can immediately deduce that an
SSCS is a sound approximation of realizability for conver-
sations: any spurious message sequence produced by the
asynchronous channel system, making the conversation pro-
tocol unrealizable, will also be a spurious message sequenc e
of the SSCS. It remains to demonstrate some condition on
an SSCS that could, in turn, warn of the presence of such
a spurious message sequence. To this end, we develop the
notion of a conﬂict state.
Definition 11 (Conflict state). Let /hatwides =
(Sp0,...,S p|P|)be a state of /hatwideπp∗(C)for some peer p∗.
Deﬁne A(/hatwides)=Sp0∩···∩ Sp|P|.I fA(/hatwides)is empty or contains
the symbol #, then /hatwidesis called a conﬂict state .O t h e r w i s e ,
the states in A(/hatwides)are called possible agreements for all
peers.
For example, with the conversation protocol in Figure 4
and the initial state /hatwidesfor/hatwideπAdeﬁned previously, we have A=
{0,3,5}, the intersection of possible states for each peer.
Intuitively, a conﬂict state des cribes a situation where, after
some messages have been exchanged between peers, some of
them “disagree” about the global state of this conversation,
in a way that cannot be settled unless one of the peers sends
a message or discards a symbol in the input queue —hence,
as it is, the current state of each peer makes one of them
“stuck”.
Theorem 3.Let((Sp0,...,S p|P|),w)be a global state
of a shared-state channel system, and Api=A(Spi)be
the possible agreements for each of the SSPs in that global
state. Then, unless one of the Apiis a conﬂict state,
A=Ap0∩···∩ Ap|P|/negationslash=∅.
Proof. By induction, we actually show that the intersec-
tion of the Apimust include the state of Cresulting from the
last send action. Base case: the initial state of ˙Cvacuously
follows the property. Induction step: suppose the property
is true for any state ˙ sreachable within ksteps from the ini-
tial state. Let (˙ s,((pj,ℓ,p k),⋆),˙s′) be a transition going one
step further. Two cases must be considered:
1. If⋆=?, since ˙ scontains an agreement, by the induc-
tion hypothesis all paths from ˙ staking “?” transitions
have the same agreement; this includes all paths going
through ˙ s′.
2. If ⋆=!, let s1be the agreement in ˙ s.L e t s2=
δ(s1,pj,ℓ,p k); let us show that if an agreement can
be reached, it has to include s2.
Forpj, by Deﬁnition 10.2, s2is already in its set of
states. Since pkcould agree on s1in ˙s,i ts u ﬃ c e sf o r
32pkto reach s1through receive transitions, and then
to consume ( pj,ℓ,p k); this is possible by Deﬁnition
10.4. Then, by construction, s2is an element of Skin
˙s′. All other peers are neither the recipients nor the
senders; for them, the transition from s1tos2is an
ǫ-transition, and therefore s2is already in their set of
states by Deﬁnition 10.3. Hence all peers can reach an
agreement on s2without sending any new message.
A consequence of Theorem 3 is that, if none of the SSP
contains a conﬂict state, then neither does the channel sys-
tem built from them. Conversely, the presence of a conﬂict
state might hint at a spurious message sequence.
Theorem 4.Let/hatwide˙Cbe the SSCS obtained from the SSPs
of some conversation protocol C.L e t ˙s=˙s0,˙s1,...be a
state trace of/hatwide˙Cwhere no state is a conﬂict state. Then the
send trace of ˙sis a trace of C.
Proof. For a global state ˙ s, deﬁne Aas in the previous
theorem. From ˙s, we build a sequences of states of C:s=
A(˙s0),A(˙s1),.... By Theorem 3, A(˙si) is well-deﬁned and
changes only through send operations. Therefore, for ˙ si,˙si+1
two successive states:
•if the transition results from a message (( p,ℓ,p′),?),
thenA(˙si+1)=A(˙si);
•if the transition results from an action (( p,ℓ,p′),!),
thenσ(˙si+1)=δ(A(˙si),((p,ℓ,p′),!)).
It follows that ˙s’s send trace is a trace of C.
A realizability condition follows from all these results:
Corollary 1.LetCbe a conversation. If none of the
SSPs /hatwideπp0(C), ..., /hatwideπp|P|(C)contain a conﬂict state, then C
is realizable.
Proof. Let˙Cbe the channel system obtained by compos-
ing the peer projections πpi(C) for each peer pi.L e t˙/hatwideCbe the
SSCS obtained by composing the SSPs /hatwideπpi(C) for each peer.
By theorem 1, L(C)⊆L(˙C). By theorem 2, L(˙C)⊆L(˙/hatwideC).
By theorem 3, if none of the SSPs contain a conﬂict state,
then same holds for˙/hatwideC. Finally, by theorem 4, in such a case
L(˙/hatwideC)⊆L(C). It follows that L(C)=L(˙C)=L(˙/hatwideC), and
hence Cis (strictly) realizable.
Corollary 1 provides a suﬃcient condition for a conversa-
tion protocol Cto be realizable. Moreover, this condition
can be computed by reachability analysis. Indeed, we need
to compute |P|SSPs, where each has a ﬁnite size bounded
by|P|·2|S|. This gives an upper bound of |P|2·2|S|on the
size of the state space, thereby reducing the problem to a
search in a ﬁnite graph. We shall see in a later experimental
evaluation of the approach that this upper bound is seldom
reached for real-world protocols.
4. EXPERIMENTAL RESULTS
To test our approach, we developed a tool called SSP-
Calc, which takes as input a conversation protocol, and then
computes SSPs for some or all of the peers involved. The1010
108
106
104
104102
100
100101102103
Number of explored statesTheoretical upper boundyx=
Figure 6: Actual state space size vs. theoretical upper bound
for each protocol.
tool is implemented in PHP and runs on a web server; it
u s e sag r a p h i c a li n t e r f a c et h a ta l l o w sau s e rt os p e c i f yv a r -
ious computation options. SSPCalc’s results are also dis-
played graphically. The channel system corresponding to
each SSCS, as well as the resulting product, are all repre-
sented as annotated graphs. Various statistics about the
computation, such as memory consumption and state space
size, are also given.
Analysis of Performance: We ran SSPCalc on more than
100 diﬀerent real-world protocols, taken from the following
sources: IBM Conversation Support [1], Channel contracts
from the Singularity operating system [20], protocols from
the BPEL Speciﬁcation [7], and the travel agency example
from [17]. All of them were already speciﬁed graphically
as conversation protocols; they simply had to be translated
into an equivalent textual representation that SSPCalc uses
as input.
We ﬁrst computed the total state space that was required
to be explored for each protocol. We compared this number
with the theoretical |P|2·2|S|upper bound on the number
of states. These results are shown in Figure 6. As one can
see, the actual number of states explored in every protocol
is much lower than the theoretical maximum. The log-log
graph has a slope of 2.5, which means that the expected
number of reachable states is roughly in a√
x5relationship
with the upper bound.
Although SSPCalc is a proof-of-concept prototype written
as a PHP script, we still measured the total time for the
validation of each protocol, in terms of its state space size,
and plotted the results in Figure 7. The log-log graph has a
slope of 1.75, which indicates that processing time is roughly
the square of the state space size. The times ranged from 8
milliseconds to one hour, depending on the protocol. Very
few protocols took a long time to process: 91% of them were
analyzed in less than one second, and 95% in less than 10
seconds. They were measured on an Intel machine running
at 2.53 GHz under Linux CentOS.
False Positives: More importantly, we compared the re-
sults returned by SSPCalc with those returned by WSAT [9],
a tool for analyzing conversation protocols, and Tune [20], a
tool for analyzing Singularity channel contracts. WSAT uses
the three realizability conditions deﬁned in [10, 11] called
synchronous-compatible, autonomous, and lossless-join (d e-
3310410-3
100101101
100
10-1
10-2102103104
102103
Number of explored statesValidation time (s)
Figure 7: Total veriﬁcation time with respect to state space
size.
ReadyState
IO_RUNNINGS1CS : GetTpmStatus/c174 CS : GetTpmStatus/c174ReadyStateS0
ReadyStateS1CS : Send/c174SC : AckStartSend /c174
SC : SendComplete /c174
SC : SendComplete /c174SC : TpmStatus /c174
SC : TpmStatus /c174IO_RUNNINGS0IO_RUNNING
SC : TpmStatus /c174
Figure 8: The original TPMContract protocol (solid lines),
with additional states and transitions (dashed) to make it
realizable.
scribed in Section 5 below) whereas Tune uses only the au-
tonomous condition (which is suﬃcient for determining re-
alizability of two-party protocols like channel contracts) .
Both WSAT and Tune use sound realizability analyses
and, hence, correctly identify the protocols that are un-
realizable. For example, the Haggle protocol from IBM
Conversation Support [1], and the TPMContract protocol,
shown in Figure 8, are two unrealizable protocols that are
correctly identiﬁed as such by WSAT and Tune. SSPCalc is
also a sound realizability analysis tool, so it also identiﬁe s
these two protocols as unrealizable.
In a way similar to the example of Figure 1, it is possible
to ﬁx some unrealizable protocols with additional transi-
tions and states, in such a way that it becomes realizable. A
ﬁxed version of TPMContract, provided in [20], is shown as
dashed states and transitions in Figure 8. However, this
ﬁxed version still violates the autonomous condition and
hence fail the realizability tests used in WSAT and Tune.
Since WSAT and Tune use sound, but incomplete anal-
yses, this does not mean that the protocol is unrealizable.
In fact, SSPCalc computed all SSPs for the ﬁxed protocol
and found no conﬂict state. By Corollary 1, this is suﬃ-
cient to conclude that the ﬁxed version of TPMContract is
realizable, a result that cannot be shown by the realizability
analyses used in WSAT and Tune.
Another example that causes the realizability conditions
used in WSAT and Tune to generate false positives is the1Agency Airline :AskQuote /c174
Agency Airline :OrderTickets /c174 Airline Agency :Timeout /c174
Airline Agency :Timeout /c174Airline Agency :Accepted /c174
Airline Agency :Rejected /c174Agency Airline :OrderTickets /c1740
51
23
4
Figure 9: A portion of the ﬁxed airline protocol from [17]
airline example mentioned in [17], where the original proto-
col deadlocks because of a timeout. Since this timeout can
be sent while the agency is sending an order, to ﬁx it, the
protocol must be modiﬁed such that both orderings of time-
out and order are allowed from a global point of view. The
ﬁxed protocol is shown in Figure 9.
Based on the realizability conditions used by WSAT and
Tune, this ﬁxed protocol is identiﬁed as unrealizable. How-
ever, SSPCalc correctly identiﬁes the ﬁxed protocol in Fig-
ure 9 as realizable. Even for the ﬁxed version of the simple
ﬁle transfer protocol shown in Figure 1b, WSAT and Tune
generate false positives and report that it is unrealizable,
whereas SSPCalc correctly identiﬁes that it is realizable.
The protocols we discussed above, for which the WSAT
and Tune tools report false positives, can be characterized
asarbitrary-initiator protocols:
Definition 12.A conversation protocol Cis an proto-
col with arbitrary-initiator if there exists some state s∈S,
peers pi,pj,pm,pnand message labels ℓ,ℓ′such that both
δ(s, pi,ℓ,p j)andδ(s,pm,ℓ′,pn)are deﬁned, and pi/negationslash=pm.
Such protocols can be unrealizable, since, in the same
state, two diﬀerent peers can decide to send a message,
without “warning” the other of its intent. Yet, as we have
shown above, not every such protocol is unrealizable: in
fact, any conversation protoc ol where some peer can inter-
rupt a sequence of messages sent by another peer exhibits
this arbitrary-initiator property. This is the case for the
“ﬁxed” version of the ﬁle transfer protocol, shown in Fig-
ure 1b. This conversation protocol accepts both sequences
s, c, f ands,f, c, which is exactly what its corresponding
channel system produces. Therefore, it is realizable. Since
the initiator of the protocol cannot be guessed by any of the
peers, the speciﬁcation compensates by providing an appro-
priate behavior for both orderings. In the case of the ﬁle
transfer protocol, this would simply mean that the server
accepts, but ignores any cancellation messages received af-
ter the transfer is ﬁnished.
5. RELATED WORK AND DISCUSSION
The present work can be compared to earlier results on
assessing the realizability of conversations, with a specia l
focus on their behavior on arbitrary-initiator protocols.
Local enforceability studied in [23] is concerned with ﬁnd-
ing individual speciﬁcations for each communicating peer
34such that their composition produces a predeﬁned set of
interactions, expressed in a web service choreography lan-
guage. However, in this approach synchronous communica-
tion is used, and hence the arbitrary initiator problem does
not occur.
Message patterns expressed with Petri nets using syn-
chronous communication are“de-synchronized”in [6] —that
is, one is interested in ﬁnding a speciﬁcation that produces
the same pattern of messages when communications become
asynchronous. This work, however, already assumes that a
conversation protocol is realizable and does not provide re-
alizability conditions.
Realizability Conditions for Conversation Protocols:
In [10] a set of three conditions for conversation protocols
is presented, which, taken together, are suﬃcient to ensure
realizability:
1. Synchronous-compatible: A conversation protocol Cis
synchronous-compatible if every time a peer phas a
send transition for some label ℓto some peer p′,t h e n
p′has a receive transition for that same label, or should
reach such a transition through ǫ-transitions.
2. Autonomous: A conversation protocol Cis au-
tonomous if each peer, at any moment, can do only
one of the following: 1) terminate, 2) send a message,
or 3) receive a message.
3. Lossless-join: If we let C′=πp0(C)×···× πp|P|(C)
be the conversation protocol obtained as the “Carte-
sian product” of each peer projection, a conversation
protocol Cis lossless join if L(C)=L(C′).
Note that the lossless join condition operates on a product
of peer projections (which is still a conversation protocol),
and not on the channel system built from these projections.
Otherwise, the lossless join condition would be equivalent t o
strict realizability. Algorithms for checking the above con-
ditions on conversation protocols have been shown in [11].
The WSAT [9] and Tune [20] tools we mentioned above im-
plement these algorithms.
While the above conditions allow a sound analysis of many
protocols, the major drawback comes from the autonomous
condition. In fact, the autonomous condition is the exact
negation of the deﬁnition of an arbitrary-initiator protocol.
It follows that this method cannot discriminate between re-
alizable and unrealizable classes of such protocols, and im-
mediately labels them as unrealizable. Hence, as we dis-
cussed above, WSAT and Tune generate false positives for
realizable arbitrary initiator protocols as expected.
Session Types: In session types conformance of an inter-
action with a predeﬁned protocol is analyzed as a typing
problem. Intuitively, if T1,T2are two types, then a type T3
can be built as T1.T2, where the period denotes the sequenc-
ing operator. A global interaction mbetween peers (called
asession ) will conform to type T3if it can be divided into
a sequence of two interactions, m1.m2, such that m1con-
forms to type T1,a n d m2conforms to type T2. Similar rules
can be deﬁned for non-deterministic branching, conditional
branching, parallel execution.
The approach in session types [13], is to ﬁrst devise a
global type, G, to an intended scenario consisting of inter-
acting peers. Diﬀerent programmers can independently de-
velop portions of this interaction by taking the projection ofGon each of the peers. If the individual program for each
peerpcan be shown to conform to its respective projection
ofG(noted G↾p), i.e., if each program is“typable”, then the
rules of session types ensure that when the programs are ex-
ecuted, they follow the stipulated global scenario. One can
see the immediate parallel between the rationale behind ses-
sion types and the deﬁnition of strict realizability presented
in Section 2.3. More precisely, realizability of interactions
can be ensured through a “type discipline” by checking two
conditions:
1. A programmer ﬁrst describes a scenario as a global
typeGand checks that it conforms to the so called
linearity condition.
2. Each component of the interaction is then developed
independently, and periodically checked to make sure
it istypable against the projection of G.
If linearity of Gand typability of each program is enforced,
realizability follows. Session types can therefore provide an
alternate, sound analysis to the realizability conditions d e-
scribed above.
It turns out, however, that the typing system for session
types contains an analogue of the autonomous condition
shown above. More precisely, rule “ If” in the type discipline
shown in [12] is formulated as follows:
Γ⊢e⊲bool Θ;Γ⊢P⊲∆Θ ; Γ ⊢Q⊲∆
Θ;Γ⊢ifethenPelseQ⊲∆
Intuitively, this rule shows that for a branch of the form “if
ethenPelseQ” to conform to type ∆ (bottom part of the
rule), then emust be of Boolean type, and both branches
PandQmust conform to the same type ∆. Since a type
determines the sender and recipient of some communication
event, it follows that PandQmust have the same sender
and recipient, no matter what eis.
Similar restrictions occur for other forms of branching
in the type system. For example, the construct k⊲{l1:
P1[]···[]ln:Pn}, called label branching in [12], represents a
peer oﬀering, over some communication channel k, multiple
choices P1,...,P nfor the continuation of a session. The Pi
need not be of the same type, and hence nothing prevents a
peer from being alternately a sender and a receiver in some
of these choices. However, for such an expression to be ty-
pable, some other peer must include as its cotype the expres-
sionk⊳l;P, where the actual choice of label is communicated
overk. This is shown in Figure 10; one can see that this no
longer represents an arbitrary-initiator protocol, since the
communication of liover channel kis always unidirectional.
Basically, the session type discipline prevents well-typed pro-
grams from including arbitrary-initiator branching. Hence,
the realizability of such protocols cannot be established us -
ing the type rules of session types.
6. CONCLUSION
The shared-state projections (SSP) presented in this pa-
per provide a novel and sound approach to determining real-
izability of message-based interactions. In contrast to earl ier
work, SSP is based on the intuitive notion that a realiz-
able protocol is a protocol where each peer, at any moment,
should have a “clear enough” indication of the current state
of other peers. By computing, for each state and from each
peer’s point of view, the possible states for other peers in
35AB :m1 /c174 BA :m2 /c174AB :l1 /c174
AB :m1 /c174AB :l2 /c174
BA :m2 /c174
Figure 10: Arbitrary-initiator protocol (left) and label
branching in session types (right).
a conversation, we have shown that unrealizable protocols
can be soundly identiﬁed through the identiﬁcation of “dis-
agreements” between two peers’ global states. The realiz-
ability check we developed based on SSP correctly identi-
ﬁes the realizability of a class of protocols called arbitrary-
initiator protocols, whereas earlier realizability conditio ns
always produce false positives for such protocols.
An interesting feature of the SSP approach is that its out-
put is not simply Boolean. While the shared-state projec-
tions are used to derive a verdict about realizability, these
models in themselves can be put to other uses. As we have
shown, computing the Cartesian product of each shared-
state projection yields an over-approximation of the original
speciﬁcation. By removing conﬂict nodes from this prod-
uct, one obtains a subset of the conversation protocol which
is guaranteed to be realizable, at no additional cost. Con-
versely, by adding transitions to the original conversation,
one can convert conﬂict nodes into “correct” nodes until no
conﬂict remains; the augmented protocol can be seen as a
“ﬁxed” version of the original. Therefore, we believe that it
would be possible to extend the SSP approach for automat-
icallyrepairing unrealizable protocols.
7. REFERENCES
[1] IBM conversation support project, 2002.
http://www.research.ibm.com/convsupport.
[2] P. A. Abdulla and B. Jonsson. Verifying programs
with unreliable channels. Inf. Comput. , 127(2):91–101,
1996.
[ 3 ]G .B a n a v a r ,T .D .C h a n d r a ,R .E .S t r o m ,a n dD .C .
Sturman. A case for message oriented middleware. In
13th International Symposium on Distributed
Computing (DISC) , pages 1–18, 1999.
[4] T. Bultan, X. Fu, and J. Su. Analyzing conversations:
Realizability, synchronizability, and veriﬁcation. In
L. Baresi and E. D. Nitto, editors, Test and Analysis
of Web Services , pages 57–86. Springer, 2007.
[5] M. Carbone, K. Honda, N. Yoshida, R. Milner,
G. Brown, and S. Ross-Talbot. A theoretical basis of
communication-centred concurrent programming,
W3C note, October 2006. http://www.w3.org/2002/-
ws/chor/edcopies/theory/note.pdf.
[6] G. Decker, A. P. Barros, F. M. Kraft, and
N. Lohmann. Non-desynchronizable service
choreographies. In A. Bouguettaya, I. Kr ¨uger, and
T. Margaria, editors, ICSOC , volume 5364 of Lecture
Notes in Computer Science , pages 331–346, 2008.
[7] D. Jordan et al. Web services business process
execution language version 2.0, 2007.
http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-
v2.0-OS.html.[8] M. F ¨ahndrich, M. Aiken, C. Hawblitzel, O. Hodson,
G. C. Hunt, J. R. Larus, and S. Levi. Language
support for fast and reliable message-based
communication in Singularity OS. In Proc. 2006
EuroSys Conf. , pages 177–190, 2006.
[9] X. Fu, T. Bultan, and J. Su. WSAT: A Tool for
Formal Analysis of Web Service Compositions. In
Proc. 16th Int. Conf. on Computer Aided Veriﬁcation ,
pages 510–514, 2004.
[10] X. Fu, T. Bultan, and J. Su. Conversation protocols:
A formalism for speciﬁcation and analysis of reactive
electronic services. Theoretical Computer Science ,
328(1-2):19–37, November 2004.
[11] X. Fu, T. Bultan, and J. Su. Synchronizability of
conversations among web services. IEEE Trans.
Software Eng. , 31(12):1042–1055, 2005.
[12] K. Honda, V. T. Vasconcelos, and M. Kubo. Language
primitives and type discipline for structured
communication-based programming. In 7th European
Symp. on Programming on Programming Languages
and Systems (ESOP’98) , pages 122–138, 1998.
[13] K. Honda, N. Yoshida, and M. Carbone. Multiparty
asynchronous session types. In G. C. Necula and
P. Wadler, editors, POPL , pages 273–284. ACM, 2008.
[14] G. C. Hunt and J. R. Larus. Singularity: rethinking
the software stack. Operating Systems Review ,
41(2):37–49, 2007.
[15] Java Message Service.
http://java.sun.com/products/jms/.
[16] R. Kazhamiakin and M. Pistore. Analysis of
realizability conditions for web service choreographies.
InFORTE , pages 61–76, 2006.
[17] N. Lohmann, O. Kopp, F. Leymann, and W. Reisig.
Analyzing BPEL4Chor: Veriﬁcation and participant
synthesis. In M. Dumas and R. Heckel, editors,
WS-FM , volume 4937 of Lecture Notes in Computer
Science , pages 46–60. Springer, 2007.
[18] D. A. Menasc´ e. MOM vs. RPC: Communication
models for distributed applications. IEEE Internet
Computing , 9(2):90–93, 2005.
[19] Microsoft Message Queuing Service.
http://www.microsoft.com/windowsserver2003
/technologies/msmq/default.mspx.
[20] Z. Stengel and T. Bultan. Analyzing Singularity
channel contracts. In G. Rothermel and L. K. Dillon,
editors, ISSTA , pages 13–24. ACM, 2009.
[21] Web services reliable messaging.
http://www.ibm.com/developerworks/library
/speciﬁcation/ws-rm/.
[22] Web Service Choreography Description Language
(WS-CDL). http://www.w3.org/TR/ws-cdl-10/ ,
2005.
[ 2 3 ] J .M .Z a h a ,M .D u m a s ,A .t e rH o f s t e d e ,A .B a r r o s ,
and G. Decker. Service interaction modeling: Bridging
global and local views. In EDOC , pages 45–55. IEEE
Computer Society, 2006.
36