Matching Dependence-Related Queries in the System
Dependence Graph
Xiaoyin Wang1,D a v i dL o2, Jiefeng Cheng3, Lu Zhang1∗, Hong Mei1, Jeffrey Xu Yu3
1Key Laboratory of High Conﬁdence Software Technologies (Peking University),
Ministry of Education, Beijing, 100871, China
2School of Information Systems, Singapore Management University
3The Chinese University of Hong Kong, China
{wangxy06,zhanglu,meih}@sei.pku.edu.cn, davidlo@smu.edu.sg, {jfcheng yu}@se.cuhk.edu.hk
ABSTRACT
In software maintenance and evolution, it is common that develop-
ers want to apply a change to a number of similar places. Due to thesize and complexity of the code base, it is challenging for develop-ers to locate all the places that need the change. A main challenge
in locating the places that need the change is that, these places share
certain common dependence conditions but existing code searching
techniques can hardly handle dependence relations satisfactorily.In this paper, we propose a technique that enables developers tomake queries involving dependence conditions and textual condi-
tions on the system dependence graph of the program. We carried
out an empirical evaluation on four searching tasks taken from thedevelopment history of two real-world projects. The results of ourevaluation indicate that, compared with code-clone detection, ourtechnique is able to locate many required code elements that code-
clone detection cannot locate, and compared with text search, our
technique is able to effectively reduce false positives without losing
any required code elements.
Categories and Subject Descriptors
D.2.7 [ Software Engineering ]: Distribution, Maintenance and En-
hancement
General Terms
Reliability, Standardization
Keywords
System Dependence Graph, Code Search, Graph Indexing
1. INTRODUCTION
In software development, developers often need to apply one
change to a number of similar places in the code. Such a situa-
tion occurs typically when developers want to make a programmingstyle change or want to change the environment (e.g., the databasesystem and the user interface) of a software system. For example,
when a developer wants to extract a common code pattern to form
a new method, he or she should try to locate all the instances of thecode pattern and change them to invocations of the new method.
∗Corresponding author
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted w ithout fee provided that copies are
not made or distributed for proﬁt or c ommercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, torepublish, to post on servers or to redist ribute to lists, requires prior speciﬁc
permission and/or a fee.ASE’10, September 20–24, 2010, Antwerp, Belgium.
Copyright 2010 ACM 978-1- 4503-0116-9/10/ 09 ...$10.00.It is usually easy for a developer to locate one or a few places for
change, but it is challenging for he or she to locate all the places that
require the same change. Since the code base of a modern softwareapplication is large and usually many developers have been cod-ing for the application, it may be infeasible for the developer to
remember all the similar places without missing any one. Thus, a
tool that helps developers locate all the similar places requiring the
same change may save much development time.
One possible way to achieve the preceding purpose is to use tech-
niques for code-clone detection. Techniques for code-clone detec-
tion are able to detect all the places in the code that are similarto the known places that need change. However, techniques for
code-clone detection rely on a pre-deﬁned uniform similarity met-
ric to measure the similarity between two places. But the similarity
in the preceding problem is actually some common characteristics
that similar code elements should have, and a different change mayimply different common characteristics. For instance, as shown in
Example 1 in Section 2, the two code elements are “similar” for
only the change at hand, but should not be similar in any techniquefor code-clone detection. Another possible way to achieve the pre-ceding purpose is to use text search. In a typical text-search tool,a developer can represent the common characteristics as a regularexpression and search in the code for matched code elements. How-
ever, text-search tools cannot always represent common character-
istics as regular expressions. For instance, as shown in Example2 in Section 2, the common characteristics of the need-to-changecode elements are based on control and data dependence relation-ships, and cannot be represented as a regular expression.
In this paper, we propose a novel technique to locating code ele-
ments with common dependence-related properties in source code.
The basic idea of our technique is as follows. Our technique allowsa developer to write a query using a language named the Depen-dence Query Language (DQL) (presented in Section 4.1). DQLallows a developer to describe dependence properties on top of tex-tual properties. Then, our technique transforms the query into a se-
ries of graph reachability patterns and matches them in the System
Dependence Graph (SDG) of the source code using a fast algorithmfor graph-pattern matching [3]. We empirically evaluated our tech-nique using four searching tasks in two real-world projects. Ourempirical results indicate that our technique is more effective than
both code-clone detection and text search for these searching tasks.
As a general approach that locates code elements with common
dependence-related properties, our technique can be applied to a
number of software maintenance tasks. For example, provided witha list of error patterns, our technique can be incorporated in a bugﬁnding tool to locate the error patterns. Another scenario is that
when developers want to perform refactorings, they can use our
DQL (perhaps with some extensions) to deﬁne the code places to be
457
changed in the refactorings. Our technique can also be adapted to
solve to some speciﬁc problems, such as locating the strings ﬂow-
ing to the GUI in software internationalization [19], or locating the
variables whose values come from or are compared with sensitivedata in security analysis.
This paper makes the following main contributions:
A demonstration of challenges in locating all the code ele-
ments requiring the same change.
A query language (i.e., DQL) that allows developers to de-
scribe dependence-related properties involving multiple pro-
gram points.
A technique that locates code elements with certain dependence-
related properties via graph matching.
An empirical evaluation demonstrating the effectiveness andthe cost of our technique.
2. EXAMPLES
In this section, we present two examples to demonstrate the chal-
lenges in locating all the need-to-change code elements when de-
velopers want to apply a change to similar code elements.
The ﬁrst example comes from code changes made to the expat1
project (cvs version 2002-05-17). In the code changes, the devel-opers want to ﬁx some memory leaks that may happen when a callof the
malloc function fails. One of the changes is as below.
Example 1:
Original Code:
tag = MALLOC(sizeof(TAG));
if (!tag)
return XML_ERROR_NO_MEMORY;
tag->buf = MALLOC(INIT_TAG_BUF_SIZE);if (!tag->buf)
return XML_ERROR_NO_MEMORY;
Changed Code:
tag = MALLOC(sizeof(TAG));if (!tag)
return XML_ERROR_NO_MEMORY;
tag->buf = MALLOC(INIT_TAG_BUF_SIZE);if (!tag->buf){
Free(tag) ;
return XML_ERROR_NO_MEMORY;
}
From the preceding two code portions, we can see that the de-
velopers want to ﬁnd cases where a ﬁeld (i.e., tag->buf in the
code) of a struct variable (i.e., tag in the code) is initialized after
the struct variable is initialized. The aim is to add a free func-
tion when the initialization of the ﬁeld is failed to avoid memory
leak. The key characteristic is two calls of the malloc function:
One call is to acquire memory for the entire struct variable and theother call is to acquire memory for a ﬁeld of the struct variable.As the name of the struct variable and the name of the ﬁeld may
vary in other places, it is difﬁcult to ﬁnd these places with code-
clone detection. Furthermore, in text search, as it is impossible toexpress the constraint between the struct variable and the ﬁeld, wecannot use this constraint to conﬁne the searching results. The fol-
lowing gives another location exhibiting the memory leak patternmentioned above:
newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes),
name, sizeof(ELEMENT_TYPE));
if (!newE)
return 0;
if (oldE->nDefaultAtts) {
newE->defaultAtts = (DEFAULT_ATTRIBUTE *)
MALLOC(oldE->nDefaultAtts *sizeof(DEFAULT_ATTRIBUTE));
if (!newE->defaultAtts)
return 0;
}
1expat is a popular XML document handling library.In the preceding code portion, the name of the struct variable is
newE and the name of the ﬁled is newE->defaultAtts .F u r t h e r -
more, this code portion only depicts one call of malloc ,a n dt h e
other call of malloc is inside the implementation of the lookup
function. To make the situation even worse, there is an extra if-
structure (i.e., if(oldE->nDefaultAtts) ) in this code portion.
This example demonstrates that neither code-clone detection nor
text search allows developers to express some important constraints
when searching for need-to-change code elements.
The second example is from code changes in the gpsbabel2project
(cvs version 2004-10-27). In these changes, the developers try toﬁnd copying operations between two arrays of type
UCin the form
of loops. The aim is to replace each such copying operation with
a call of a specially deﬁned function (i.e., arraycopy ). The fol-
lowing two code portions depict the code before and after such a
change. The code in the italicized parts highlights the change.
Example 2:
Original code:
UC*p, str;
...
for(i = 0; i < 10; i++){
str[i] = *p++;
}
Changed code:
UC*p, str;
...
arraycopy(str,p,10);
The key characteristics is a series of assignments between ele-
ments in two arrays and each element is of type UC. In this example,
the main challenge is to express both the following constraints: 1)
the constraint between the loop structure and the content inside the
loop structure, and 2) the constraint on the type of the elements in
the two arrays. Neither code-clone detection nor text search allows
developers to express both constraints in one search.
From the preceding two examples, we have the following obser-
vations. First, when locating similar code elements for change, de-
velopers often need to express searching conditions as dependence-
related properties. Code-clone detection may be ineffective, sincecode elements satisfying such a searching condition may not looksimilar. Text search may be ineffective, since such a search con-dition contains dependence properties besides textual properties.Second, dependence properties described in such a search condi-
tion may include both control dependencies and data dependencies.
Based on the preceding observations, we propose a new tech-
nique to locating code elements with common dependence-related
properties in source code. Our technique allows developers to ex-press combinations of textual conditions, data dependence condi-tions, and control dependence conditions in individual queries. To
deal with the dependence conditions, our technique transforms the
queries to graph reachability patterns and matches the patterns inthe System Dependence Graph (SDG) of the source code.
3. BACKGROUND
3.1 System Dependence Graph
The system dependence graph (SDG) is a graph that describes
the dependence relationships between program points in the source
code [16]. In an SDG generated by CodeSurfer3, each node cor-
responds to a program point in the code. There are 33 types of
program points in total in an SDG generated by CodeSurfer. The
2gpsbabel is a processing system of GPS information
3CodeSurfer is a static program analyzer and it can extract a system
dependence graph from source code. CodeSurfer can be obtained
from http://www.grammatech.com/products/codesurfer.
458Figure 1: An example system dependence graph
Figure 2: (a) Example Graph and (b) Query
edges in an SDG correspond to the dependence relationships be-
tween program points. There are two kinds of dependence rela-
tionships: data dependence relationships and control dependencerelationships. Table 1 depicts the most commonly used types of
program points in SDGs. In our current technique, we only con-
sider searching for the structures consisting of program points of
these most commonly used types. However, it is possible to ex-tend our technique to search for other program points by extendingour dependence query language (See Section 4.1) and the querytransformation rules (See Section 4.3). Note that program points
of other types may be intermediate nodes in various dependence
relations between the common program points in the SDG.
Given a C program, CodeSurfer can extract an SDG automati-
cally during the compilation of the program. For example, for the
following program, CodeSurfer provides an SDG in Figure 1. Inthe ﬁgure, each node is labeled with its program-point type, and
we also provide the textual representation of each node. Hollow ar-
rows refer to data dependencies and solid arrows refer to control de-pendencies. Solid lines refer to intra-procedure dependencies anddotted lines refer to inter-procedure dependencies.
static int add(int a, int b){
return a + b;
}
/*Sum 0 through 10. */
void main() {
int sum, i;
sum = 0;
i=1 ;
while ( i<11 ) {
sum = add(sum, i);
i = add(i, 1);
}
}Table 1: Commonly used types of program points
Program Point Type
 Description
expression
 value assignment or value return
control point
 any kind of branch condition
(e.g., if, for, while, ...)
call site
 function invocation
actual in
 actual argument in a function invocation
actual out
 returned value of a function invocation
declaration
 declaration of a variable
entry
 entry of a function
3.2 Graph Reachablity Indexing and
Querying
As stated in Section 1, our technique transforms a dependence re-
lated query to a graph reachability pattern. The problem of match-
ing such a pattern in a large graph is computationally expensive.First, the reachability calculation between all pairs of nodes in a
graph has a complexity cubic to the size of the graph. Second, a
naive algorithm for matching a graph pattern in a graph has a com-
plexity of N
x,w h e r e Nis the size of the graph, and xis the size of
the graph pattern.
Fast graph reachability indexing and querying is a new achieve-
ment in the area of graph databases [3], which makes graph reach-
ability pattern matching on large graphs computationally accept-
able. A graph reachablity indexing algorithm takes a labeled di-rected graph as input. In a labeled graph, each node has one andonly one label from a known label set. The algorithm indexes all
the reachability relati onships between node labels. With the in-
dices, one can query and obtain all the instances of a reachability
pattern (represented as a query graph). For example, for the graph
in Figure 2(a) containing the label set {A, B, C, D, E, F}, a queryin Figure 2(b) can be made. To distinguish nodes labeled with thesame label, in Figure 2(a), we add numbers to the end of the label.For example, A1, A2, and A3 are three nodes labeled with A. Thequery in Figure 2(b) denotes sub-graphs having the following con-
ditions: First, in such a sub-graph, there is at least one node labeled
with A, one node labeled with B, and one node labeled with F. Sec-ond, in such a sub-graph, it is reachable from the node labeled withA to either the node labeled with B or the node labeled with F. Notethat edges between nodes in the que ry graph repre sent reachability
relations instead of immediate connections. The three matched in-
stances (A1, B2, F1; A2, B2, F1; A3, B1, F2) are marked with
triangles, squares, and stars, respectively.
4. APPROACH
To help developers perform dependence-related queries, we de-
sign a language, named the dependence query language (DQL), for
developers to describe the common characteristics of target code
elements. Section 4.1 presents the details of DQL. With a query
written in DQL, our technique searches for code elements that sat-
isfy the common characteristics described in the query using thefollowing four steps. First, we extract the System DependenceGraph (SDG) from the source code using CodeSurfer. Second, wetransform dependence conditions in the query to a series of graph
reachability patterns. Third, we search in the SDG to locate sub-
graphs matching the graph reachability patterns. Finally, we usethe textual constraints in the query to ﬁlter the located sub-graphsand trace back to code elements in the source code. Sections 4.2to 4.5 presents the details of the preceding four steps, respectively.
4.1 Dependence Query Language
A query in our Dependence Query Language has four parts, for-
mally presented as below.
Query→QueryDeclaration ; NodeDescriptions ;
RelationDescriptions ; Wanted
459TheQueryDeclaration part is formally deﬁned below.
QueryDeclaration →QueryDeclaration , NodeDeclaration
| NodeDeclaration
NodeDeclaration →Types Identifier
Identifier →[A-Z]
Types→Types / Type | Type
Type→function |variable |assignment
|declaration |control-point
This part allows a developer to declare a list of program points
involved in the search. Besides an identiﬁer, the developer must
give each program point a list of t ypes. If one program point has
more than one type, the meaning is to declare a program point
whose actual type can be any one of the listed types. DQL sup-
ports ﬁve types of program points: function ,variable ,assignment ,
declaration ,a n d control-point . These ﬁve types are abstraction of
the types of program points in SDG. We describe the mapping be-
tween types in DQL and types in SDG in Section 4.3. The function
type corresponds to any invocations of functions. The variable type
corresponds to single variables. The assignment type corresponds
to assignments or returns of invocations passing the return values4.
Thedeclaration type corresponds to declarations of variables. The
control-point type corresponds to all branch conditions.
TheNodeDescriptions part is formally deﬁned as below.
NodeDescriptions →NodeDescriptions NodeDescription
| NodeDescription
NodeDescription →Identifier Conditions
Conditions →Conditions orCondition | Condition
Condition →notUnitCondition | UnitCondition
UnitCondition →contains String
UnitCondition →inFile String
UnitCondition →inFunction String
UnitCondition →atLine Number
UnitCondition →declareType String
UnitCondition →declareType Native
UnitCondition →controlType CTYPE
CTYPE→for|while |switch |if
In the preceding deﬁnition, “Number” corresponds to a positive
number. “String” corresponds to a character sequence inside quo-
tation marks, “Native” corresponds to the set of built-in types of the
C language, including “char”, “ﬂoat”, etc.
This part allows a developer to describe the properties related to a
single program point. For each progr am point, a developer can add
three kinds of properties as conditions. First, a developer can use
contains to demand the textual representation of a program point to
have a particular substring. Second, a developer can describe thelocation of a program point by providing its exact line number, or
by providing the substrings contained in the textual representation
of its enclosing ﬁles or functions. Third, for certain types of pro-gram points, a developer can also describe the declared type or thecontrol type of a given program point. A developer can also addnotororto the conditions for a program point. Note that our DQL
does not support the disjunction of c onditions of the r elationships
between different program points. In such a case, a developer needs
to generate more than one queries.
TheRelationDescriptions part is formally deﬁned as below.
RelationDescriptions →RelationDescriptions ,
RelationDescription | RelationDescription
RelationDescription →Identifier op Identifier
op→dependOp | textualOp | structuralOp
dependOp →oneStep subDependOp
subDependOp →dataDepends |controls |calls
textualOp →textual contains
structuralOp →isFieldOf
structuralOp →isElementOf
This part allows a developer to describe three kinds of depen-
dence relationships between program points: dataDepends, con-
trols andcalls . Speciﬁcally, “A dataDepends B” means that A is
4We merge these two kinds of elements for simplicity, a developer
can demand an assignment to be a return statement using a textual
condition.data dependent on B; “A controls B” means that B is control depen-
dent on A; and “A calls B” means that there is a chain of function
invocations from A to B. A developer can also use modiﬁer oneStep
before a relationship to demand that the dependence must happen
in one step in the SDG.
Our DQL also allows a developer to add textual conditions be-
tween the textual representations of two program points. Speciﬁ-
cally, “A textual contains B” means that the textual representation
of B is a substring of the textual representation of A.
Sometimes program points may have structural relationships, such
as the relationship between a struct variable and its ﬁelds or the re-
lationship between an array variable and its elements. So DQLalso supports structural c onditions. In particular, “A isFieldOf B”
means that A is a ﬁeld of struct variable B, and “A isElementOf B”
means that A is an element of array variable B. For example, “a.b
isFieldOf a” holds; “a[b] isElementOf a” holds.
TheWanted part is formally deﬁned as below. This part allows
a developer to indicate which program points in the query are the
actual target.
Wanted→want Identifiers
Identifiers →Identifiers , Identifier | Identifier
Note that the syntax of DQL allows developers to write mean-
ingless queries (e.g., deﬁning a function A with control type if ,o r
deﬁning function A calls variable B ). The meaningless queries are
checked and deemed as errors when we transform the queries to
graph patterns (see Section 4.3.2).
We next give a DQL query for Example 1 in Section 2. In the
example, since the only place requiring change is the initialization
of the ﬁeld of the struct variable, the developer can set only the
program points corres ponding to the initialization of the ﬁeld as
the targets. In particular, a query for this example is as below:
function A, function B, variable C, variable D; A contains "mal-
loc" or contains "realloc", B contains "malloc" or contains "rel-
loc"; C dataDepends A, D dataDepends B, C onestep dataDependsD, C isFieldOf D; want C
In the query, Acorresponds to the initia lization of the struct
variable, Bcorresponds to the initia lization of the ﬁeld, Ccorre-
sponds to the ﬁeld, and Dcorresponds to the struct variable. We
usedataDepends to describe the relationship from the initializa-
tion of the variable to the variable itself. We further use onestep
dataDepends andisFieldOf to describe the relationship between a
struct variable and its ﬁelds.
4.2 SDG Extraction
In our technique, we obtain the system dependence graph (SDG)
as follows. First, we use CodeSurfer to generate an initial SDG
from the code. Second, we check each node to see whether thenode is a program point of one of the types listed in Table 1. Foreach such node, we extract its type (e.g., actual-in ,call-site ,e t c . ) ,
textual presentation, and location in the code, and label the node
with its type. For other nodes, we also label each node with its
type but do not extract further information. We keep these nodes in
the SDG to transit dependence relationships between nodes of themost commonly used types. Third, we extract all the edges betweennodes and label them as control dependence or data dependence.Here we do not differentiate inter-procedure dependence and intra-
procedure dependence, since a developer usually does not know
whether the target he or she is searching for is in a function orscattered in different functions. Fourth, we give each node in theSDG a unique number as its identiﬁer.
4.3 Query Transformation
To use graph reachability querying to search in the SDG, we need
to transform a query described in DQL into one or more queries for
460graph reachability querying. First, as graph reachability querying
accepts only query graphs, we need to transform queries in DQL
into query graphs. Second, as a query graph in graph querying al-
lows only the conjunction of label conditions and reachability con-ditions, we need to split a query with disjunctions of conditions
in DQL into several query graphs. Third, for conditions (such as
structural relationships, textual relationships, program-point prop-
erties described in the NodeDescriptions part, and the oneStep
conditions) supported by DQL but not supported by graph reacha-
bility querying, we do not transform them into query graphs but usethem to ﬁlter the results of graph reachability querying. We presentthe details of ﬁltering in Section 4.5.
4.3.1 Splitting Queries
In a query written in DQL, there are two places that may contain
disjunctions of conditions, and the conditions in both places are
conditions for single program points. The ﬁrst place is the Query-
Declaration part, where a program point may have multiple possi-
ble types. The second place is the NodeDescriptions part, where
the properties of a program point may be the disjunction of several
conditions. To deal with the disjunctions of conditions, we split thequery into the disjunction of a series of sub-queries, each of whichcontains only conjunctions of conditions. This process is similar tothe process of normalizing a logic expression into the disjunctive
normal form. When querying the SDG, we use each conjunctive
sub-query to obtain a set of results and use the union of all the re-sult sets as the results of the original query.
For example, for the query described as “ function / control-point
A, variable B; A contains "abc" or contains "de"; A dataDepends
B; want A ”, we can split the query into the following four sub-
queries: “ function A, variable B; A contains "abc"; A dataDepends
B; want A ”, “control-point A, variable B; A contains "abc"; A
dataDepends B; want A ”, “function A, variable B; A contains "de";
A dataDepends B; want A ”, and “ control-point A, variable B; A
contains "de"; A dataDepends B; want A ”. None of the sub-queries
includes any disjunctions of conditions.
4.3.2 Transforming Conjunctive Queries
For a query containing only conjunctions of conditions, we trans-
form the query into a query graph in the following way. First, we
transform each program point in the QueryDeclaration part into a
node in the query graph. Second, we do not consider the conditions
for ﬁltering (e.g., properties described in the NodeDescriptions
part) in query transformation. Third, we transform the type of eachprogram point into the label of the corresponding node, and the
relationships between program points into edges between nodes.
Note that there is no straightforward one-to-one mapping between
the types of program points in DQL and the types in the SDG andthere is no straightforward one-to-one mapping between the rela-tionships in DQL and the reachability relationships in the SDG. Inthe following, we present the details of transforming program-point
types and relationships between program points.
Figure 3 depicts the rules for the preceding transformation. Each
rule corresponds to the transformation of two program points (in-
cluding their types) and their relationship described in DQL intothe corresponding sub-graph (including node labels) in the querygraph. In the ﬁgure, hollow arrows denote data dependence and
solid arrows denote control dependence. Note that some rules re-
sult in adding extra nodes into the query graph.
For brevity, in Figure 3, we merge rules when the relationship in
DQL is the same and the structure of the transformed sub-graph is
similar. As a result, we have four generic rules in Figure 3, and ineach rule, a program point in DQL may have more than one type
and a node in the transformed sub-graph may have more than oneFigure 3: Rules for dependence relation descriptions
label. In such a case, we use “|” to separate the program-point types
and the node labels. Details of the four generic rules are as below.
Acalls B. According to the SDG generated by CodeSurfer,
such a situation requires that Bshould be control dependent
on the entry of Aand the entry of Ashould be control de-
pendent on the call-site of A. So we add two control de-
pendence edges and an intermediate entry node from AtoB
(Figure 3(a)). Both AandBshould be functions. The newly
added node should have an identiﬁer not used by other nodes,
and we use Aito indicate that it is the ithadded node.
Acontrols B. We transform this relationship to a control de-
pendence edge from AtoB(Figure 3(b)). Ashould be a
control-point, and Bcan be an assignment, a function call or
another control-point. Furthermore, if Bis a function call,
we need to transform the function type into the call-site la-
bel. As neither declarations nor references of variables are
executable, we do not allow Bto be a declaration or a vari-
able. We transform the assignment type into the expression
label because the SDG generated by CodeSurfer uses an ex-
pression to represent an assignment .
AdataDepends Band Ais not a function . We transform
this relationship to a data dependence edge from BtoA(Fig-
ure 3(c)). Acan be a control-point, an assignment or a vari-
able. As a declaration cannot be data dependent on anything,we do not allow the type of Ato be declaration .Bcan be
of any types except for control-point (CodeSurfer treats an
assignment like “x = a>b” as an expression rather than acontrol point). Two things need further explanation in Fig-ure 3(c). First, when one program point is data dependenton another program point of the function type, the label for
the node corresponding to the program point of the function
type should be actual-out . This is because in the SDG gener-
ated by CodeSurfer, data dependence to a function is denoted
461as data dependence to the actual-out corresponding to the
function call. Note that the dependence between an call-site
program point and its corresponding actual-out is a control
dependence. Second, we transform variable into expression
because the SDG generated by CodeSurfer uses an expres-
sion to represent an variable .
AdataDepends Band Ais afunction . In this case, one of
theA’s actual argument should be data dependent on another
program point. Furthermore, the dependencies between a
call-site and its corresponding actual arguments are control
dependencies. So we have the the rule as in Figure 3(d).
Since program points of type function may be transformed to
nodes with different labels in different rules. A node may have con-
ﬂicting labels. Possible conﬂicting labels are call-site andactual-
out. In such a case, we split the node to two, and add a control
dependence edge from the call-site node to the actual-out node.
If no rule in Figure 3 is able to transform a dependence rela-
tionship described in a query, we deem that there is an error in the
query. For example, if Ais declared as a function and B is de-
clared as a control-point , the dependence relationship described as
“Acalls B” will result in an error.
4.4 Graph Querying
As graph reachability indexing and querying requires only one
type of edges in both the query graph and the graph for indexing, we
cannot use the query graphs to query the SDG. To enable the query,
we divide either the query graph or the SDG to two partial graphs.
In each partial graph, the nodes are the same with the original graph
but we keep only one kind of edges. Thus, after the two partialSDGs are indexed, we perform two queries using two partial query
graphs on their corresponding partial SDGs.
After we obtain the two lists of results, we need to concatenate
the results. We mark a list of split nodes in the query graph when
doing the graph division. A split node is a node that has related
edges in both partial query graphs. For each result R1in the results
for the control dependence query and each result R2in the results
for the data dependence query, we check whether we can merge allthe split nodes
5. If all the split nodes can be merged, we merge the
two results and put the merged result into the set of ﬁnal results.
4.5 Result Filtering and Generation
After we obtain the results of graph querying, we further use the
conditions that are in the original conjunctive query but not trans-
formed into the query graph to ﬁlter the results. For each result,
we check three categories of conditions. First, we check each node
with its corresponding program point in the query. If any property
of the program point is not satisﬁed, we discard the result. Second,
we verify the textual and structural conditions between program
points. That is to say, if any two program points do not satisfy anyconditions described for them, we discard the result. Third, we ver-ify the oneStep conditions between program points. We examine
whether the dependence relationship between two program points
is one step by verifying whether there is an corresponding (control
or data) edge between the two corresponding nodes in the SDG.For the calls relationships, as such a relationship is transformed to
multiple edges in the query graph, we examine whether all theseedges are one step.
Finally, as a result after ﬁltering may contain several program
points, we recommend the developer with only the program pointscorresponding to the wanted part. If the developer wants to exam-
ine the reason of our recommendation, we allows the developer toexpand the result and see all the involved program points.
5Two nodes in two results can be merged, if the two nodes corre-
spond to a same node in the original SDG graph.5. OPTIMIZATION
In our technique described in Section 4, we use only the types of
program points as labels of nodes in the SDG and the query graph.
Therefore, we may have a huge number of results when querying
the SDG, and we need to ﬁlter the results using the other conditions
described in the query. In some cases, the ﬁltering may becomeunreasonably time consuming (e.g., more than 24 hours) due to thehuge number of results in SDG querying.
To solve the problem, we resort to pre-ﬁltering. The basic idea
of pre-ﬁltering is to move the ﬁltering of program-point proper-
ties (described in the NodeDescriptions part of a query) before the
graph querying step. Given an SDG (denoted as G) and a conjunc-
tive query (denoted as Q), we transform Qto a query graph (de-
noted as QG). Based on G,Q,a n dQG, our pre-ﬁltering technique
works as follows.
For each node (denoted as N)i nQG, we assign the node a
unique label (denoted as L) and we further ﬁnd all the nodes in
Gthat match both the type and the properties of N. Note that an
extra node added into QG during query transformation has only a
type but no other properties. Then, we label all these nodes in G
asL. The aim of this change of labels is to constrain the matched
nodes of NinGduring graph querying. In some cases, one node
(denoted as O)i nGmay match several different nodes in QG.
Thus, there is a conﬂict of label change, since we cannot assign anode in Gmore than one label. To solve the conﬂict, we add one
or more parallel nodes into G.
For the ease of presentation, let us assume that a node (denoted
asO)i nGmatched two different nodes (denoted as N1andN2)
inQG and the labels of N1andN2areL1andL2, respectively.
Thus, we add a new node (denoted as P)i n t o G, such that Phas
the same neighboring structure as O
. Speciﬁcally, for each node
from which there is an edge to O, there is also an edge to Pof
the same kind (control or data dependence), and for each node to
which Ohas an edge, Palso has an edge to it of the same kind.
Therefore, the new node Phas the same reachability property with
Oand adding PtoGwould not affect reachability relationships
between any other nodes in G. We assign the label of OasL1and
the label of PasL2. Thus, during graph querying, N1can match
Obut not PinG,a n dN2can match Pbut not OinG.
Due to added parallel nodes, it is possible that our graph query-
ing algorithm returns a result with two or more nodes correspond-
ing to one original node. In such a result, one node in Gis actually
matched to two or more nodes in the query graph. As we do not
allow this kind of matches, we ﬁlter out the matched sub-graphs
that contains two or more nodes parallel with each other.
Through pre-ﬁltering, we obtain much less results from graph
querying, and we need to ﬁlter the results of graph querying withonly conditions of relationships between program points and theoneStep conditions. Our pre-ﬁltering can save much time in ﬁlter-
ing, but we need to re-index the SDG when a new query comes.However, the time for indexing is much shorter than that for resultﬁltering without pre-ﬁltering.
6. EMPIRICAL EVALUATION
To evaluate our technique, we applied our technique on four
searching tasks in four versions of two different real-world open
source C projects: expat andgpsbabel . Table 2 depicts the de-
tailed information of the four versions of the two projects used in
our evaluation. To make it easier to generalize the ﬁndings of ourevaluation, we chose two of the most downloaded C projects inSouceforge
6, and the two projects are of different sizes and from
different domains.
6http://sourceforge.net/
462Table 2: Subjects used in our evaluation
Project Name
 Description
 Version
 Size (KLOC)
expat
 xml handle library
 2002-05-17
 13
2002-05-22
 13
gpsbabel
 GPS toolkit
 2004-10-27
 50
2005-03-21
 54
To make the four searching tasks close to real scenarios that de-
velopers may face, we extracted the four searching tasks from the
historical versions of the two projects. In particular, we browsed the
historical versions of the two projects, and when we found multiple
modiﬁcations in one version over its previous version, we checked
the comments submitted with the modiﬁcations. If the comments
imply the application of one change to a number of places, we
deemed that the developers need to perform a searching task to
apply one change to multiple places.
For each of the four tasks, we built a DQL query based on one
changed place that has comments implying the change in multiple
places. Section 6.1 presents the results of applying our techniqueon the four tasks. For comparison, we also applied a technique
based on code-clone detection and a technique based on text search
to the same tasks. For the technique based on code-clone detection,we applied a code-clone detector named DECKARD [10] to eachof the four versions. We then checked each clone group returned byDECKARD, and we deemed the clone group containing the largestnumber of places required by the searching task as the results of the
technique based on code-clone detection. For the technique based
on text search, we built several possible text queries and recordedthe results using each text query.
6.1 Results for the Searching Tasks
6.1.1 Task One
The ﬁrst searching task is actually Example 1 in Section 2. It is
from the expat project version 2002-05-17. The comment of the
code change is “ Be more careful about failed MALLOC() and RE-
ALLOC() calls. This avoids a number of potential memory leaks ”.
Example code of the change is shown in Section 2. The query weused has been introduced at the end of Section 4.1.
In this task, the developers actually changed 2 places (i.e., tar-
gets) in the code. Our technique ﬁnds both of the 2 places, but our
technique also ﬁnds 36 other places, which are false positives. Bycontrast, it is not surprising that the technique based on code-clonedetection does not ﬁnd a clone group containing the 2 targets. Asshown in Section 2, the two places do not look similar in the sense
of code cloning. For text search, the only reasonable way is to
search for “malloc” and “realloc” in the code. Since the two re-
lated “malloc” or “realloc” may be in different functions (and in
one of the 2 changed places, they indeed are in different functions),it is not possible to search two continuous “malloc” or “realloc” us-ing regular expression searching. Text search ﬁnds 33 places in the
code containing “malloc” or “realloc”. As this task requires two
related “malloc” or “realloc”, a developer may need to check eachpair of the 33 places (528 pairs) to know whether the pair forms atarget required by the task and ﬁnd the 2 correct pairs. Note thatone of the 2 targets actually involves two invocations of “malloc()”in two different functions. Not checking this pair of places with
“malloc” may miss one target.
6.1.2 Task Two
The second searching task is from the expat project version 2002-
05-22. The comment of the code change is “ Use "NULL" instead of
"0" for NULL pointers. Compare pointers == NULL or != NULL
instead of using the implicit point-to-int conversion ”. This com-
ment clearly reﬂects the purpose of the developers (i.e., changingcomparisons of pointers with 0 to comparisons of pointers with
NULL). Note that compiler does not catch these cases as warnings.
As there are a large number of control points in the program, the
essence of this searching task is actually to ﬁnd all the comparisons
of pointers. Therefore, we have the query below.
declaration A, control-point B; A not declareType Native; B on-
eStep dataDepends A; want B
This query actually ﬁnds all the comparisons of variables of non-
native types. In the query, Acorresponds to a declaration of a non-
native variable, while Bcorresponds to the control point that in-
volves A. The dependence from BtoAis one step because Ashould
directly declares the variable involved in C. Note that the query is
not very speciﬁc to the task and may be reﬁned to get better results.
In this task, the developers actually changed 8 places (i.e., tar-
gets) in the code. Our technique ﬁnds all the 8 targets together with200 other places. Among the 200 places, 22 are false positives. Theother 178 of the 200 places are also comparisons between pointervariables and 0. Thus, these code elements should also be changed.It is probable that these code elements are too difﬁcult to be found
so that the developers did not change them. By contrast, the tech-
nique based on code-clone detection still does not ﬁnd any of the 8targets. This is also not surprising because the code-clone detectorwould not deem comparisons of different pointers as cloning. Fortext search, one possible way is to search for the string “==0” and“!=0” in the code. This search ﬁnds only 2 of the 8 targets together
with 70 false positives and 10 comparisons between pointers and 0.
This search misses 6 targets due to implicit comparisons with “0”when a pointer variable is used as a condition variable (e.g.,
pin
if(p) ). Another possible way of using text search is to search for
strings like “for”, “while”, “switch” and “if” in the code, since all
the comparisons should appear in these control structures. The sec-
ond text search ﬁnds all the 8 targets, with 829 other places. These829 places also include the 178 comparisons between pointers and
0, and 651 false positives.
6.1.3 Task Three
The third searching task is actually Example 2 in Section 2 and
is from the gpsbabel project version 2004-10-27. The comment of
the code change is “ Aggressively replace open-coded strncpy for
space padded strings in various waypoint send functions ”. The
submitted code changes demonstrate that the developers try to ﬁnd
all the code elements that are in “waypoint send” functions (a list of
functions whose names end with “send”) and are like the italicized
part in the following code portion.
UC*p, str; ...
for(i = 0; i < 10; i++){
str[i] = *p++;
}
The preceding code structure has two dependence relationships.
First, there is a loop (either a for loop or a while loop). Second,
inside the loop, there is an assignment and the assignment data de-
pends on a declaration that declares a variable with type UC*used
in the assignment. Third, according to the code-submission com-
ment, the loop and the assignment should be in a function whose
name contains “send”. Therefore, we have the query as below.
declaration A, control-point B, assignment C; A declareType UC*,
B controlType for or controlType while, B inFunction "send", C in-
Function "send"; B onestep controls C, C oneStep dataDepends A;
want B
In the preceding query, A, B and C correspond to three program
points in the example. A should be a variable declaration and the
type of the variable is “UC*”, and the node B should be a loop andits control type is “for” or “while”. The dependence from C to Ais one step because A should directly declares C. The dependence
from B to C should be one step because the assignment should
463be executed in each iteration of the loop to copy an array. Thus
the assignment should be directly controlled by the loop control
point. B is wanted because the developer wants to locate only the
for/while loops. B should be in a function whose name contains
“send”. Note that our technique currently does not support search-
ing only in the functions whose name ends with “send”.
In this task, there are actually 37 targets in the code. Our tech-
nique ﬁnds all the 37 targets together with 25 false positives. By
contrast, the technique based on code-clone detection ﬁnds 36 tar-gets with 23 false positives. Unlike the previous two tasks, the tar-gets in this task share a common loop structure that can be caughtby the code-clone detector. The one target that code-clone detec-tion fails to ﬁnd is also a for loop. But there are several other
statements in the for loop, so that the similarity between the lost
target and the other targets drops below the threshold. Our tech-
nique brings in 2 extra false positives, because the conditions in
our query is not as strict as the threshold in code clone detection.For text search, one possible way is to search for “for” and “while”in the code. This search ﬁnds all the 39 targets, because all the tar-
gets involve a for loop or a while loop. But this search also ﬁnds
297 false positives, because there are many for orwhile loops
used for other purposes. Another possible way is to search for
UC*
in the code and ﬁnd all the variables of type UC*. Thus a developer
needs to further locate all the references to the these variables to
check the assignments of these variables in for orwhile loops. In
total, the developer needs to check more than 2000 references to
the variables with type UC*in the code.
6.1.4 Task Four
The fourth searching task is from the gpsbabel project version
2005-03-21. The comment of the code change is “ Call waypt_new
instead of explicit calloc to prepare for external alt invalid indica-
tor”. In the submitted changes, the aim is to change all xcalloc()
function calls that initialize variables of type waypoint *to calls
of a new function (i.e., waypt_new() ) that specially initializes
waypoint *variables. An example is as below.
waypoint *wpt_tmp;
...
wpt_tmp = xcalloc(sizeof( *wpt_tmp),1) ;
In the preceding code element, there are two dependence rela-
tionships. The ﬁrst is data dependence between the waypoint
*wpt_tmp declaration and the wpt_tmp variable. The second is
data dependence between xcalloc() andwpt_tmp . Thus we have
the query as below.
declaration A, variable B, function C; A declareType waypoint,
C contains "xcalloc"; B oneStep dataDepends A, B oneStep dataDe-
pends C; want C
In the query, Acorresponds to the declaration of a variable with
thewaypoint *type. Bcorresponds to the variable with the waypoint *
type. Ccorresponds to the invocation of xcalloc . The depen-
dence between BandCis one step because variable Cshould be
the variable that ﬁrst holds the return value of xcalloc() .T h e
dependence between BandAis one step because Ashould directly
declares B.Cis wanted because the developer wants to locate only
xcalloc() calls.
In this task, there are actually 19 targets in the code, and our tech-
nique ﬁnds all the targets together with 3 false positives. By con-
trast, the technique based on code-clone detection ﬁnds 17 targets
with 9 false positives. In two of targets ( xcalloc() invocations),
the argument structure is different from that of other targets, so that
the code clone detection technique fails to ﬁnd them. The extrafalse positives are
xcalloc() invocations that initialize variables
with types other than waypoint *. In text search, one possible way
is to search for “xcalloc” in the code. This search ﬁnds all the 19Table 3: Execution time of our technique (in seconds)
Task
 Query
 Pre-
 Index
 Query
 Concat
 Result
 Result
Build
 ﬁlter
 Filter
 Merge
1
 <0.1
 1.7
 63.7
 1.0
 N/A
 2.1
 <0.1
2
 <0.1
 0.9
 29.4
 <0.1
 N/A
 1.1
 N/A
3
 <0.1
 3.3
 640.0
 0.2
 4.2
 3.6
 <0.1
4
 <0.1
 3.3
 264.4
 1.2
 N/A
 0.9
 N/A
targets, but concedes 86 false positives. The reason is that there aremany other places that invoke
xcalloc() . Another possible way
is to search for “waypoint” in the code, and further check all the
references of variables with type waypoint *. This search returns
more than 600 references to variables with type waypoint *.
6.2 Execution Time
We also recorded the execution time of each step in our tech-
nique for performing each of the four tasks. We did not record
the execution time of of text search and code clone detection be-
cause both of them have short execution time. Table 3 depicts theresults on execution time. We only present the execution time of
doing code queries with pre-ﬁltering, because without pre-ﬁltering
the code query cannot return results within 24 hours for each of the
tasks. Note that we only present the execution time of steps that are
involved in performing a query. We do not present the executiontime of the preparation steps including compiling the projects, ex-tracting SDGs, and dividing SDGs to two partial SDGs (each onehas only one kind of edges). The execution time of the preparation
steps are unimportant because once the these steps are performed,
the developers can do any number of queries without performingthese steps again. Furthermore, th e preparation steps are performed
together with the project compilation, so that it brings in little ex-
tra cost for developers. Actually, the execution time of preparationsteps is about two minutes for the tasks from expat and about ten
minutes for the tasks from gpsbabel .
In Table 3, there are three things to be noted. First, the execu-
tion time of “Query Build” (column 2) is the total execution time
of splitting a query to conjunctive queries (if query splitting is re-quired), transforming from conjunctive queries to graphs, and di-viding graphs to partial graphs that contain only one kind of edges
(if graph division is required). Second, the execution time of “Con-
cat” (column 6) is the execution time of concatenating the resultsof two partial queries. Since queries for some tasks only containone kind of dependence relationships, our technique did not per-form graph division and concatenation and thus the corresponding
execution time for concatenation is not available. Third, the exe-
cution time of “Result Merge” (column 8) is the execution time of
merging the results of conjunctive sub-queries. Similarly, if a querydoes not contain disjunctives of conditions and thus result mergingis not required, its execution time of result merging is not available.
From this table, we can see that the execution time for the short-
est search is around half a minute, and that for the longest searchis around 11 minutes. The execution time may be too long for de-velopers to use our technique in an interactive manner. However,as our technique does not require user involvement in the searchingprocess, it is possible for developers to use our technique in an off-line way. Therefore, the execution time should not be a big burden
for developers.
Furthermore, this table also shows that the most time-consuming
step in the query process is graph indexing. Currently, since our
technique adds some parallel nodes in the pre-ﬁltering step, ourtechnique needs to re-index the graph when a new query comes.As the number of added nodes is small, it should be possible to
develop an incremental indexing algorithm to add more indexing
464information about the added parallel nodes on the basis of the ex-
isting indexing information. With such an incremental indexing
algorithm, we may further accelerate our technique.
6.3 Threats to Validity
The main threat to internal validity in our evaluation is the pos-
sible faults in the implementation of the evaluated techniques. To
reduce this threat, we acquired the implementation of DECKARD
from one author of the tool and used the text-search facility of a ma-
ture text editor. Furthermore, we reviewed all the code of the imple-
mentation of our technique before conducting the evaluation. In ourevaluation, we applied our technique with the technique based on
code-clone detection and the text-search technique on four search-ing tasks. This factor may be a threat to the external validity, as
our empirical results may be speciﬁc to the used tasks and subjects
and thus not generalizable. To reduce this threat, we used differ-ent tasks with subjects from different domains. As the searchingtasks were recovered from the subjects, the scenarios involved inthe tasks may not well represents scenarios in real-world develop-ment. This factor may be a threat to the construct validity. To
reduce this threat, we used the version history of each subject, and
carefully examined the change comments and the changed code toﬁgure out the purpose of the developers for each searching task.
6.4 Discussion
According to the results presented in Section 6.1, our technique
has a considerable number of false positives in the four searching
tasks. The false positives are mainly due to that we used simpli-ﬁed ways to specify search requirements. However, compared withcode-clone detection and text search, in which many search require-
ments cannot be speciﬁed, our technique does provide a means to
appropriately specify different search requirements. In fact, it isstill possible to reﬁne the queries for our technique to further re-
duce the false positives.
The effort spent on deﬁning an appropriate query for our tech-
nique is also a concern. For a developer, both his or her familiarity
with our technique and with the software project under search mayimpact the effort spent on deﬁning queries. In our evaluation, we(who are familiar with our technique but not very familiar with ei-ther projects) spent several minutes to deﬁne a query for each task.We plan to assign some code searching tasks to real developers in
the future to study the effort spent on deﬁning queries.
7. RELATED WORK
In essence, our technique searches for code elements satisfy-
ing some common dependence-related constraints described with
our DQL. Thus, the research most related to our technique is var-
ious generic code-search techniques. Generic code-search tech-niques are code-search techniques that allow users to write differ-
ent queries for different searching tasks. The main advantage of
generic code-search techniques is that users can use them in differ-
ent searching tasks without changing the underlying algorithm.
The most popular category of generic code-search techniques is
text search, including plain text s earch, regular expression search,
and natural language based code search [6, 9]. The main differ-
ence between these techniques and our technique is that, besides
textual information, our technique further allows users to describe
dependence relationships in the target code elements. Our empir-ical results indicate that descriptions of dependence relationshipshelp improve the accuracy of code search in many searching tasks.
Another category of generic c ode-search techniques is based on
model checking. By using mode checking, such techniques allow
users to describe temporal conditions in queries. For example, Liand Zhou used model checkers to locate the outliers of coding rules,such as ﬁnding the place where a call to
File.open() is not fol-
lowed by a call File.close() [12]. Another typical example in
this category is a technique recently proposed by Brunel et al. [2].
As a supporting technique for a generic patch-inference tool [1]
(which infers and applies common patches for Linux drivers), Brunel
et al.’s technique can locate code elements satisfying certain control-
ﬂow properties using model checking. Unlike Brunel et al.’s tech-
nique, our technique uses graph matching to check which code
elements satisfy the required control/data-dependence conditions.In most of the searching tasks discussed in this paper, descriptionof data dependence relationships in queries is essentially helpful.Since data dependence relationships in SDGs may not be described
as temporal relationships, model checkers may not be suitable to
check these data dependence relationships.
Generic code search can also be based on checking properties
acquired at runtime. Martin et al. proposed the Program QueryLanguage (PQL) [14], which allows users to describe a pattern ofsequentially executed invocations on objects. For each query, the
searching technique based on PQL ﬁrst statically checks the pro-
gram to acquire a list of candidate program points that may appearin instances of the pattern. Then the candidate program points areinstrumented and the pattern is matched dynamically during theexecution of the instrumented program. The differences betweenPQL-based searching and our technique is as below. First, PQL
focuses on only invocations of objects, while our technique can
also handle many other program points, such as expressions, con-trol points, etc. Second, PQL matches code patterns dynamically,while our technique matches queries statically.
The main disadvantage of generic code-search techniques is that
they may not be sufﬁciently precise on some particular tasks. There-fore, there are intensive investigations on specialized code-searchtechniques for some commonly encountered tasks. Specialized code-search techniques search for code elements with pre-deﬁned pat-
terns. The searching algorithm in a specialized code-search tech-
nique typically focuses on just one pre-deﬁned pattern and thus
can be more precise, but no specialized code-search techniques can
search for a pattern other than the pre-deﬁned patterns.
Code-clone detection techniques [11, 10, 5] focus on ﬁnding
similar code segments in the code base of a program. Using code-clone detection, developers can search for code portions with cer-tain properties (that some code portions are known to share). Since
developers typically have known some code elements when they
want to apply a change to other code elements, code-clone de-tection may be adopted for this purpose. However, our empiricalresults indicate the superiorness of our technique over code-clonedetection for this purpose. We suspect the essential reason to bethat code-clone detection techniques are actually specialized code-
search techniques designed for another purpose.
Slicing techniques help to locate a set of the program points that
affect or depend on a given variable [20]. In this sense, it is also a
specialized code search technique. Compared with our technique,slicing starts from a known variable, and the query is pre-deﬁned
(program points affecting or depending on the variable), while our
technique allows ﬂexible queries deﬁned by developers.
Our work is also related to techniques for recommendation of
code samples [7, 22], which search for matched code samples in
the source code of a number of programs. Compared with our tech-
nique, these techniques work on only API-invocation structures and
use pre-deﬁned rules, while our work handles both API invocations
and other program points, and allo ws users to describe the charac-
teristics of target code samples in queries.
Bug pattern matching tools provide a list of detectors for pre-
465deﬁned bug patterns, and allow developers to develop detectors of
new bug patterns using code managing APIs. Two popular bug
pattern matching tools are FindBugs7[8] and PMD8[4]. Compared
with these two tools, our technique provides a uniﬁed searching
technique and does not require developers to develop a detector for
each new pattern, which could cost substantial development time.
There are also other pattern matching tools for specialized tasks.
Maule et al. proposed a technique to search for code elements
that are affected by a given database-schema change [15]. Wang
et al. proposed a technique to search for constant string variablesthat ﬁnally goes to the GUI to facilitate software internationaliza-tion [19]. In a broader sense, feature-location techniques [21] canbe viewed as specialized code-search techniques, because such a
technique tries to search for code elements that are related to a
given feature. Jungloid-search techniques [13, 17, 18] can also beviewed as specialized code-search techniques, because such a tech-nique tries to search for a conversion code to transform a sourceobject type to a target object type. Compared with these techniqueswhich use pre-deﬁned queries, our technique is much more ﬂexible
and matches any queries written in DQL.
8. CONCLUSION AND FUTURE WORK
In this paper, we propose a novel technique that helps devel-
opers match dependence-related queries in the system dependence
graph. Our technique includes: a query language that allows devel-
opers to describe dependence relationships, an algorithm to trans-
form queries to graph reachability patterns, a graph indexing and
querying algorithm, a result ﬁlter, and an optimizer based on pre-
ﬁltering. We evaluate our technique on four searching tasks ac-
quired from four versions of two real-world C projects. The resultsof our evaluation indicate that our technique is able to locate all thetargets within reasonable execution time. Furthermore, our tech-nique outperforms code-clone detection and text search by ﬁnding
more targets or conceding fewer false positives.
There are several ways to improve or extend our technique. First,
we plan to address the threats to validity mentioned in Section 6.3
by studying more versions of more projects and doing some userstudies in real-world projects.
Second, our technique reports some false positives. We plan to
improve our technique to allow developers to query with more in-formation such as providing the default values of variables. We alsoplan to handle negative dependence conditions (e.g., A does notdepend on B), which our current technique does not support. Webelieve that with these improvements, developers can deﬁne moreaccurate queries and the false positives can be further reduced.
Third, in our evaluation, we did not study the amount of effort
needed to deﬁne an appropriate query. We plan to carry out such astudy by assigning searching tasks to a number of developers andrecord the time they spend on deﬁning queries.
Fourth, our pre-ﬁltering requires re-indexing of the system de-
pendence graph when a new query comes. The re-indexing is themost time-consuming part in our technique. As re-indexing in ourtechnique actually faces a small number of added nodes, we plan toinvestigate incremental re-indexing algorithms that can index onlythe newly added nodes.
Acknowledgments
The authors from Peking University are sponsored by the National
Basic Research Program of China (973) No. 2009CB320703, theHigh-Tech Research and Development Program of China (863) No.2007AA010301 and No. 2006AA01Z156, the Science Fund for
7http://ﬁndbugs.sourceforge.net/
8http://pmd.sourceforge.net/Creative Research Groups of China No. 60821003, and the Na-
tional Science Foundation of China No. 90718016.
9. REFERENCES
[1] J. Andersen and J. L. Lawall. Generic patch inference. In
ASE, pages 337–346, 2008.
[2] J. Brunel, D. Doligez, R. R. Hansen, J. L. Lawall, and
G. Muller. A foundation for ﬂow-based program matching:
using temporal logic and model checking. In POPL , pages
114–126, 2009.
[3] J. Cheng, J. X. Yu, B. Ding, P. Yu, and H. Wang. Fast graph
pattern matching. In ICDE , pages 913–922, 2008.
[4] T. Copeland. PMD Applied . Centennial Books, 2005.
[5] M. Gabel, L. Jiang, and Z. Su. Scalable detection of semantic
clones. In ICSE , pages 321–330, 2008.
[6] E. Hill, L. Pollock, and K. Vijay-Shanker. Automatically
capturing source code context of NL-queries for software
maintenance and reuse. In ICSE , pages 232–242, 2009.
[7] R. Holmes and G. C. Murphy. Using structural context to
recommend source code examples. In ICSE , pages 117–125,
2005.
[8] D. Hovemeyer and W. Pugh. Finding bugs is easy. SIGPLAN
Not., 39(12):92–106, 2004.
[9] D. Janzen and K. De V older. Navigating and querying code
without getting lost. In AOSD , pages 178–187, 2003.
[10] L. Jiang, G. Misherghi, Z. Su, and S. Glondu. DECKARD:
Scalable and accurate tree-based detection of code clones. InICSE , pages 96–105, 2007.
[11] T. Kamiya, S. Kusumoto, and K. Inoue. CCFinder: a
multilinguistic token-based code clone detection system for
large scale source code. TSE, 28(7):654–670, 2002.
[12] Z. Li and Y . Zhou. PR-Miner: automatically extracting
implicit programming rules and detecting violations in large
software code. In ESEC/FSE , pages 306–315, 2005.
[13] D. Mandelin, L. Xu, R. Bodik, and D. Kimelman. Jungloid
mining: Helping to navigate the API jungle. In PLDI , pages
48–61, 2005.
[14] M. Martin, B. Livshits, and M. S. Lam. Finding application
errors and security ﬂaws using PQL: A program query
language. In OOPSLA , pages 365–383, 2005.
[15] A. Maule, W. Emmerich, and D. S. Rosenblum. Impact
analysis of database schema changes. In ICSE , pages
451–460, 2008.
[16] S. Sinha, M. J. Harrold, and G. Rothermel.
System-dependence-graph-based slicing of programs with
arbitrary interprocedural control ﬂow. In ICSE , pages
432–441, 1999.
[17] N. Tansalarak and K. T. Claypool. XSnippet: Mining for
sample code. In OOPSLA , pages 413–430, 2006.
[18] S. Thummalapenta and T. Xie. ParseWeb: a programmer
assistant for reusing open source code on the web. In ASE,
pages 204–213, 2007.
[19] X. Wang, L. Zhang, T. Xie, H. Mei, and J. Sun. Locating
need-to-translate constant strings for software
internationalization. In ICSE , pages 353–363, 2009.
[20] M. Weiser. Program slicing. In ICSE , pages 439–449, 1981.
[21] W. Zhao, L. Zhang, Y . Liu, J. Sun, and F. Yang. SNIAFL:
Towards a static noninteractive approach to feature location.
TOSEM , 15(2):195–226, 2006.
[22] H. Zhong, T. Xie, L. Zhang, J. Pei, and H. Mei. MAPO:
Mining and recommending API usage patterns. In ECOOP ,
pages 318–343, 2009.
466