Towards Quantitative Software Reliability Assessment in
Incremental Development Processes∗
Toshiya Fujii†
Hiroshima University
1-4-1 Kagamiyama
Higashi-Hiroshima 739-8527
JapanTadashi Dohi‡
Hiroshima University
1-4-1 Kagamiyama
Higashi-Hiroshima 739-8527
Japan
dohi@rel.hiroshima-
u.ac.jpTakaji Fujiwara§
Fujitsu Quality Laboratory
4-1-1, Kamikodanaka
Nkahara-ku, Kawasaki
211-8588, Japan
fujiwara.takaji@nifty.com
ABSTRACT
The iterative and incremental development is becoming a
major development process model in industry, and allows
us for a good deal of parallelism between development and
testing. In this paper we develop a quantitative software
reliability assessment method in incremental development
processes, based on the familiar non-homogeneous Poisson
processes. More speciﬁcally, we utilize the software metrics
observed in each incremental development and testing, and
estimate the associated software reliability measures. In a
numerical example with a real incremental developmental
project data, it is shown that the estimate of software reli-
ability with a speciﬁc model can take a realistic value, and
that the reliability growth phenomenon can be observed even
in the incremental development scheme.
Categories and Subject Descriptors
D.2.4 [ Software Engineering ]: Software/Program Veriﬁ-
cation— Reliability, Statistical methods, Validation
General Terms
Reliability
∗This research was partially supported by the Ministry of
Education, Science, Sports and Culture, Grant-in-Aid for
Scientiﬁc Research (C), Grant No. 21510167 (2009–2012).
†Mr. Fujii is now working as a technical staﬀ in the Hitachi
Software Engineering, Co. Ltd., Japan, after obtaining his
M.Sc. (Engineering) from Hiroshima University, Japan, in
2010.
‡Dr. Dohi is a full professor with the Department of Infor-
mation Engineering, Hiroshima University, Japan.
§Dr. Fujiwara is a project manager with Audit Division ,
Fujitsu Quality Laboratory, Ltd., Japan
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE 11, May 21-28 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00.Keywords
software reliability, incremental development, non-homogeneous
Poisson processes, software metrics, maximum likelihood es-
timation, data analysis
1. INTRODUCTION
It is well known that software development paradigm is
one of the most signiﬁcant factors aﬀecting not only the
software reliability but also almost all quality attributes of
software. Since it is diﬃcult to catch up the user’s require-
ment perfectly before development, in general, the waterfall
paradigm may often fail in the complex software develop-
ment processes with the change of requirement speciﬁcation
by the users. In consequence, it becomes more and more
important to be ﬂexible in handling changing requirements
so as to meet the current customer needs, and to be able to
deliver software products quickly to the market. Basili and
Turner [1] discuss a practical eﬀectiveness of iterative and
incremental software development. The incremental devel-
opment can identify parts which can be developed from spec-
iﬁcation to executable code. It also leads to dividing the re-
quirements into suitable parts during the speciﬁcation allow-
ing for independent development of the diﬀerent increments,
and allows us for a good deal of parallelism between develop-
ment and testing [7],[12],[13]. In fact, the similar but some-
what diﬀerent software development models such as the spi-
ral model [6] and the clean room model [11],[14],[15],[17],[29]
are introduced as variations of iterative and incremental de-
velopment model to improve the common waterfall model.
Recently, agile development models [22] have been becoming
much popular in industry, so that recent research trend in
software engineering has focused on evaluating iterative and
incremental development framework.
Benediktsson et al. [2],[3], [4] and Mohagheghi et al. [18]
consider the cost/eﬀort estimation for iterative and incre-
mental software development. The productivity of incre-
mental and iterative software development processes is in-
vestigated by Tan et al. [28]. Royce [26] reports an example
of an Ada process model for incremental development of
large software systems. In this way, considerable attentions
have been paid for incremental software development mod-
els. However, it should be really surprised that the quanti-
tative software reliability assessment method in incremental
development processes has not been studied suﬃciently in
the past literature in spite of its recent demand. Wohlin [30]Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ICSE ’11, May 21–28, 2011, Waikiki, Honolulu, HI, USA
Copyright 2011 ACM 978-1-4503-0445-0/11/05 ...$10.00
41
develops a very simple probability model to calculate the
mean time between software failures (MTBSFs) and com-
pares the incremental development model with the common
waterfall model from the view point of software reliability
modeling. Since his model is an intuitive and static model
in time, it would be impossible to conduct the accurate soft-
ware reliability assessment with time series software fault-
detection data observed in the incremental testing phases.
Bhawnani et al. [5] guide software release decisions in an in-
cremental development using the existing software reliability
models (SRMs), though they also fail to provide satisfactory
answer on how to represent the corresponding SRMs in such
a non-trivial situation.
It is worth mentioning that the software reliability assess-
ment method in incremental development processes has not
been referred in the standard text books of software relia-
bility engineering [16], [19], [23]. The most diﬃcult problem
in applying the SRMs to incremental development is to deal
with the software fault-detection data observed iteratively in
each incremental testing phase, because the common SRMs
focus on only one software fault-detection data recorded as a
time series in the system testing, and are based on only the
one sample path. In other words, it may not evidently make
sense to treat only one time series data by connecting multi-
ple software fault-detection data sets obtained in respective
incremental testing phases, since the fault-detection rate is
diﬀerent in each incremental development phase, and the
remaining number of software faults or the initial software
intensity at the end of each incremental testing phase may
inﬂuence the subsequent increment. Another idea may be
to regard the incremental development phases as an aggre-
gation of similar development projects. It is known [34] that
most work on SRMs is directed towards software complexity
metrics in spite of their criticism, where the complexity met-
rics require that SRMs are built from the previous similar
projects [31],[32] or increments. However, the above ref-
erences represent the software reliability function with the
complexity metrics or model parameters estimated from the
similar project data, but never take the iterative scheme in
the incremental development into account on the modeling
framework. We agree with the eﬀectiveness to use any soft-
ware metric in modeling the quantitative software reliability
assessment. The point here is how to incorporate the useful
software metrics data in incremental development scheme.
In this paper we develop a novel approach to estimate the
quantitative software reliability and its associated reliabil-
ity measures in incremental development. The fundamental
idea is to apply the well-known non-homogeneous Poisson
process (NHPP)-based SRMs to the iterative testing scheme.
In fact, the NHPP-based SRMs have gained much popularity
during the last four decades to assess the software reliability,
the number of remaining faults in the software, the software
release schedule, etc. Goel and Okumono [9], Yamada et al.
[33] and Musa and Okumoto [20] propose the representative
NHPP-based SRMs among others. However, it may not be
eﬀective to apply the NHPP-based SRMs directly without
modiﬁcation to the iterative testing environment, since the
incremental development phases can be classiﬁed into sev-
eral classes in terms of importance on reliability. As Wohlin
[30] deﬁnes, the increments can be divided into three types;
high risk increment, high usage increment and low usage in-
crement. Since the high risk increment may be developed in
the earliest phase of a whole development process, the incre-ment on which the reliability requirements are the highest
will obtain most testing. The high usage increment is also
important to fulﬁll the overall software reliability require-
ment. To represent these risk and usage proﬁles on reliabil-
ity modeling, it may be insuﬃcient to use the NHPP-based
SRMs [9],[20],[33] with only software fault-detection data in
the common way.
Apart from the software complexity metrics, we incorpo-
rate the NHPP-based SRMs with the software metrics ob-
served in each incremental development phase. It is also
known that not only software fault-detection data but also
the software test metrics characterizing the current incre-
mental testing phase are very useful to predict the software
reliability with higher accuracy. Ray et al. [24], Rinsaka
et al. [25], Shibata et al. [27] develop dynamic proportional
hazard-based SRMs and show that the utilization of software
test metrics can improve drastically the goodness-of-ﬁt per-
formance of the NHPP-based SRMs. Recently, Okamura et
al.[21] propose an alternative metrics-based SRM with the
well known logistic regression and show that it can provide
the almost similar prediction performance to the propor-
tional hazard-based SRMs. In this paper we also present
software test metrics-dependent SRMs for incremental de-
velopment processes.
The remaining part of this paper is organized as follows.
In Section 2 we overview the NHPP-based SRMs and give an
idea on how to estimate the model parameters from the soft-
ware fault data obtained in each incremental testing phase.
Next, we introduce an interesting metrics-based modeling
framework to deal with the development and testing met-
rics. Two models, which are classiﬁed into exponential re-
gression and linear regression, are proposed to handle the
software metrics data for an arbitrary parametric form of
an NHPP-based SRM. Based on the above idea, we con-
sider three cases with diﬀerent NHPP-based SRMs. Section
3 is devoted to a case study with the real incremental de-
velopmental project data, and carries out the goodness-of ﬁt
test of the proposed models. The prediction of the future be-
havior of the number of detected faults and the quantitative
software reliability (testing reliability and service reliabil-
ity) is made in Section 4. It is shown through the case study
that the estimate of software reliability with a speciﬁc SRM
can take a realistic value, and that the software reliability
growth phenomenon can be observed even in the incremen-
tal development scheme. Finally the paper is concluded with
remarks in Section 5.
2. SOFTWARE RELIABILITY MODELING
It is assumed that in each incremental development pro-
cess, software modules are independently developed and in-
tegrated with a whole software system, where the software
test in each incremental development consists of module test,
integration test and system test. In a fashion similar to
the common NHPP-based SRMs, we pay our attention to
only the system test with the most remarkable reliability
improvement. Figure 1 illustrates an incremental scheme of
system tests, where the module test and the review for a
newly developed module are completed before the system
test in each increment.
2.1 NHPP-based SRM
Let{X(t), t≥0}denote the cumulative number of soft-
ware faults detected by time t, which is measured from the42The 1-st Increment
The 2-nd Increment
The 3-rd Increment
 The I-th IncrementFigure 1: Fault-detection mechanism in incremental
system testing.
beginning of the system test in each incremental develop-
ment, and be a stochastic point process satisfying:
(A-1) X(0) = 0,
(A-2) {X(t), t≥0}has independent increment,
(A-3) Pr{X(t+h)−X(t) = 1 }=λ(t;θ)h+o(h),
(A-4) Pr{X(t+h)−X(t)≥2}=o(h),
where λ(t;θ) is an absolutely continuous (deterministic) func-
tion of only time t,θis the free parameter vector, and o(h)
is the higher order term of inﬁnitesimal time h, so that
limh→0o(h)/h= 0. Then the stochastic point process X(t)
is said the NHPP with intensity function λ(t;θ). Since this
is a typical Markov process with time dependent transition
rate, it can be easily derived that
Pr{X(t) =x|X(0) = 0 }=Λ(t;θ)x
x!e−Λ(t;θ), (1)
where
Λ(t;θ) = E[ X(t)] =Zt
0λ(x;θ)dx (2)
is said the cumulative intensity function and is equivalent
to the mean value function of an NHPP, which means the
expected cumulative number of software faults detected by
time t. In the classical software reliability modeling, themain research issue was to determine the intensity function
λ(t;θ), or equivalently the mean value function Λ( t;θ) so as
to ﬁt the software-fault count data.
More speciﬁcally, suppose that the cumulative number of
software faults is measured from the beginning of the i-th
incremental testing phase, i= 0,1,· · ·, I, and is counted at
thej-th testing day, j= 0,1,· · ·, ki, so we have ( ti,j, xi,j), j=
0,1,· · ·, ki, ti,0= 0, xi,0= 0, where ti,jand xi,jdenote
thej-th testing day and its related cumulative number of
detected faults in the i-th increment, respectively, and are
measured from the beginning of the i-th incremental sys-
tem testing. Let tI,kIdenote the termination of a whole
system testing at the ﬁnal I-th incremental phase. The
most commonly used technique for parameter estimation
of NHPP-based SRMs is the maximum likelihood estima-
tion. Let θbe given by the time-dependent parameter sets,
θ= (θ1,θ2,· · ·,θI). Then the likelihood function of an
NHPP is given by
L(θ)=IY
i=1h
exp[−Λ(ti,ki;θi)]
×kiY
j=1{Λ(ti,j;θi)−Λ(ti,j−1;θi)}(xi,j−xi,j−1)
(xi,j−xi,j−1)!i
.(3)
For arbitrary two parameters, θi= (ai, bi),i= 1,· · ·, I, the
resulting likelihood function becomes
L(a1, . . . , a I, b1, . . . , b I) =IY
i=1h
exp˘
−Λ(ti,ki;ai, bi)¯
×kiY
j=1{Λ(ti,j;ai, bi)−Λ(ti,j−1;ai, bi)}(xi,j−xi,j−1)
(xi,j−xi,j−1)!i
.(4)
Once the model parameters are obtained, it is easy to
estimate the quantitative software reliability which is deﬁned
as the probability that the software system does not fail by
time u(≥0) when it was released to the user or market at
time tI,kI. So we have
R(u|tI,kI) = exph
−˘
Λ(tI,kI+u;ˆθ)−Λ(tI,kI;ˆθ)¯i
,(5)
where ˆθis an estimate of the model parameter vector from
the software fault-detection data ( ti,j, xi,j), i= 1, . . . , I, j =
0,1, . . . , k i. In this way, if the software fault-detection data
are available in all incremental system tests, it would be pos-
sible to estimate the model parameters including in each in-
dependent NHPP-based SRM. However, it should be noted
that this method does not take the dependence of incremen-
tal phases into consideration, in spite of its essential prop-
erty. In other words, an iterative eﬀect should be involved
in the statistical estimation framework.
2.2 Metrics-based Modeling
The previous discussion was devoted to a direct applica-
tion of the NHPP-based SRMs with only software fault data
observed in the incremental development. As mentioned in
Section 1, however, it is possible to observe some signiﬁ-
cant software metrics data which can characterize the soft-
ware fault-detection phenomenon in each increment. Dif-
fer from non-incremental development paradigm, it should
be mentioned that an incremental development process may
be aﬀected by the achievement in the previous incremen-
tal phases. Table 1 presents an example of the observable43software metrics and the software fault data. In this exam-
ple, we observe the number of software faults detected in
each testing day of the i-th increment, i= 1,2,· · ·, I, and
the associated software metrics data which can be classiﬁed
into two categories, Metric 1 and Metric 2 for convinience.
Metric 1 relates to the quality of software developed in the
current development phase, and Metric 2 focuses on the size
of software. Suppose that m1Metrics 1, M1,· · ·, Mm1, and
m2Metrics 2, Mm1+1,· · ·, Mm1+m2, are available in each
development phase, where ( Mm1+1,· · ·, Mm1+m2) consist of
estimates to be predicted subjectively by a project manager
at the beginning of the current incremental phase (ˆ yi,m1+m2)
and the realizations obtained objectively at the end of the
current phase ( yi,m1+m2).
Next we introduce the dependence of these software met-
rics data on the mean value function in the NHPP-based
SRM. It is assumed that the free parameters included in the
mean value function Λ( t;θ) depend on the past and the cur-
rent development phases. For instance, in the i-th incremen-
tal development phase, only two parameters, θ= (ai, bi),
i=i= 1,2,· · ·, I, are involved in Λ( t;θ) = Λ( t;ai, bi) and
depend on the software metrics data. More speciﬁcally, let
aidenote the mean number of the remaining software faults
in the representative ﬁnite failure SRMs [9],[33] or the initial
software intensity in an inﬁnite failure SRM [20] before the
i-th incremental testing phase, and let bidenote the fault
detection rate at the i-th testing phase. It is assumed that
(ai, bi),i= 1,· · ·, I, should depend on Metric 1 data (qual-
ity of software) at the ( i−1)-st incremental test and Metric
2 data at the i-th incremental test, respectively. The above
assumption imply that the remaining number of software
faults at the beginning of the current incremental testing is
related to only the previous incremental development pro-
cess, and that the current debugging rate strongly depends
on the current software size under test.
For ( M1,· · ·, Mm1) and ( Mm1+1,· · ·, Mm1+m2), suppose
that the software metrics data in the i-th incremental phase,
y= (yi,1,· · ·, yi,m1, yi,m1+1,· · ·, yi,m1+m2), are available.
Deﬁne the coeﬃcient vectors by α= (α0, α1,· · ·, αm1+m2)
for both Metrics 1 and 2 data, and β= (β0, β1,· · ·, βm2) for
m2Metrics 2 data, where α0(>0) and β0(>0) are constant
free parameters. In this paper we propose the following two
metrics-dependent models:
Model 1 (exponential regression):
ai=α0exp{α1yi−1,1+· · ·+αm1yi−1,m1
+αm1+1yi−1,m1+1+· · ·
+αm1+m2yi−1,m1+m2}, (6)
bi=β0exp{β1yi,m1+1+· · ·+βm2yi,m1+m2}.
(7)
Model 2 (linear regression):
ai=α0+α1yi−1,1+· · ·+αm1yi−1,m1
+αm1+1yi−1,m1+1+· · ·
+αm1+m2yi−1,m1+m2, (8)
bi=β0+β1yi,m1+1+· · ·+βm2yi,m1+m2.
(9)
By applying the above regression-based formulas, we have
an advantage that the careful selection of software metrics is
not needed in some cases. Because the regression coeﬃcients
corresponding to less important metrics should take smallervalues around zeros. Note that aidepends on the previous
(i−1)-st increment, but bidoes on the current increment i.
Under the data structure in Table 1, substituting Eqs. (6)
and (7) or Eqs. (8) and (9) into Eq. (4) yields the likelihood
function of an NHPP-based SRM:
L(α,β) =IY
i=1h
exp[−Λ(ti,ki;α,β)]
×kiY
j=1{Λ(ti,j;α,β)−Λ(ti,j−1;α,β)}(xi,j−xi,j−1)
(xi,j−xi,j−1)!i
,
(10)
so the problem is reduced to obtain the coeﬃcient vectors
(α,β) maximizing L(α,β) instead of ( ai, bi), i= 1,· · ·, I.
At the ﬁrst look, it may be considered that the estimation
procedure in Eq.(10) is just same as that in the case with
the individual increments in isolation. However, it is not
true because the likelihood function is represented as the
product of the probabilities that the debugging history in
respective incremental system testing can be realized. Since
the resulting NHPP-based SRM involves many free param-
eters, it is well known that the commonly used optimization
technique such as the Newton method does not sometimes
work well. In this paper, we apply the Nelder-Mead simplex
method (see [25],[27]) to avoid the local extrema as frequent
as possible. This is better than the Newton method in terms
of the global convergency, but is inferior than the EM algo-
rithm (see [21]).
3. A CASE STUDY
Our next concern is the estimation of model parameters
involved in the NHPP-based SRMs and the goodness-of-ﬁt
test. Based on the maximum likelihood estimates of model
parameters, we compare the goodness-of-ﬁt performance in
respective SRMs under the criteria of the maximum log-
likelihood (LLF) and mean squares error (MSE).
3.1 Data Set
The data set employed here is a real project data observed
in a development process of an embedded software system,
which consists of the time series software fault data (group
data per testing day) and the software metrics data; Metric
1 with m1= 3 and Metric 2 with m2= 3 in Table 2. Metric
1 consists of yi,1,yi,2andyi,3, which are the number of inte-
grations (software modules newly developed in the i-th de-
velopment phase), the number of UT faults (software faults
detected in the i-th incremental unit testing, and the num-
ber of design reviews before the i-th incremental unit testing,
respectively. In Metric 2, there are yi,4,yi,5andyi,6, which
are the number of test cases performed in the i-th incremen-
tal system testing, the size of software in the i-th develop-
ment phase measured by KLOC, and the development eﬀort
in the i-th development phase measured by [the number of
testers] ×[the number of testing days], respectively. In this
project data, we have estimates of ˆ yi,4, ˆyi,5and ˆyi,6which
are subjectively predicted by a project manager before the
subsequent incremental development process starts. This
project was spent totally 28 days for system testing, where
the number of incremental development (testing) phases was
I= 6.44Table 1: An example of metrics data structure.
INC DayNo.
faultsMetric 1 Metric 2
M1 · · · Mm1Mm1+1· · ·Mm1+m2
EV1RV2EV RV
1 t1,k1x1,k1 y1,1 · · · y1,m1ˆy1,m1+1y1,m1+1 · · · ˆy1,m1+m2y1,m1+m2
.................................
i ti,j xi,j yi,1 · · · yi,m1ˆyi,m1+1 yi,m1+1 · · · ˆyi,m1+m2yi,m1+m2
.................................
I tI,kIxI,kI yI,1 · · · yI,m1ˆyI,m1+1yI,m1+1 · · · ˆyI,m1+m2yI,m1+m2
1EV: Estimated value for Metric 2 by project manager
2RV: Real value
Table 2: Project data set.
INCNo.
daysNo.
faultsMetric 1 Metric 2
MD1UT2RV3 No. test cases Size4Eﬀort5
EV RV EV RV EV RV
i ti,j xi,j yi,1 yi,2 yi,3 ˆyi,4 yi,4 ˆyi,5yi,5ˆyi,6yi,6
1 5 6 3 28 18 2100 1259 42.0 24.1 111 78
2 7 14 2 25 25 1350 686 27.0 22.3 121 118
3 4 3 4 6 7 450 664 7.5 8.6 82 53
4 4 4 1 19 10 880 797 9.1 6.6 98 70
5 3 2 2 24 16 1100 673 13.7 10.2 95 67
6 5 8 3 26 19 1500 1422 13.0 12.8 124 86
1MD: no. modules developed
2UT: no. faults detected in unit test
3RV: no. reviews
4KLOC
5Person-days
3.2 Parameter Estimation
Since our objective is not to develop any new paramet-
ric form of NHPP-based SRM, we employ here three rep-
resentative NHPP-based SRMs; Exponential (EX) NHPP
model [9], Delayed-S-shaped (DS) NHPP model [33], and
Logarithmic Poisson execution-time (LP) NHPP model [20],
where the corresponding mean value functions are given by
Λ(t;θ) =a{1−exp(−bt)}, Λ(t;θ) =a{1−(1+bt) exp( −bt)}
and Λ( t;θ) = (1 /b) ln(abt+ 1), respectively. These NHPP-
based SRMs involve two free model parameters θi= (ai, bi)
in each increment, where aistrongly depends on the previous
incremental phase and biinﬂuences the current incremental
development phase. To investigate the eﬀectiveness of in-
clusion of software metrics data, we consider the following
three cases, estimate the model parameters and carry out
the goodness-of-ﬁt test in respective cases.
Case 1: The parameters ( ai, bi) in the i-th incremental
testing phase depend on only the software-fault data.
Note that this is not the case where α1=· · ·=αm1+m2=
0 and β1=· · ·=βm1+m2= 0, but where INHPPs
with diﬀerent parameters ( ai, bi) are assumed for Iin-
cremental phases. This is corresponding to the case
where the existing SRMs are applied to the individual
increments in isolation.
Case 2: Under Model 1, the parameters ( ai, bi) are mod-
eled with the software metrics data in Eqs. (6) and (7).Then, the estimated model parameters are given by
αl1, l1= 0,1,· · ·, m1+m2, and βl2, l2= 0,1,· · ·, m2.
Case 3: Under Model 2, the parameters ( ai, bi) are mod-
eled with the software metrics data in Eqs. (8) and (9).
Then, the estimated model parameters are given by
αl1, l1= 0,1,· · ·, m1+m2, and βl2, l2= 0,1,· · ·, m2.
In Case 1, 2 ×Iparameters, ( ai, bi), i= 1,2,· · ·, I, have to
be estimated from only the software-fault data, ( ti,j, xi,j), j=
0,1,· · ·, ki. In Case 2 and Case 3, the number of free pa-
rameters is equal to that of the coeﬃcient parameters corre-
sponding to the software metrics, where y0,1=y0,2=· · ·=
y0,m1+m2= 0ɽIn our case study, Case 1 involves 12 free
parameters, and Case 2 and Case 3 do 11 free parameters.
Let
Λ(t;θ) =8
<
:Λ1(t;ai, bi, i= 1, . . . , I ) (Case1)
Λ2(t;α,β) (Case2)
Λ3(t;α,β) (Case3)(11)
be the mean value functions in respective Case 1, Case 2 and
Case 3. Substituting the model parameters into respective
mean value functions yields the following parametric forms.
Logarithmic Poisson Execution Time Model (LP):45Λ1(t, ai, bi) =1
biln(aibit+ 1), (12)
Λ2(t,α,β) =1
β0exp(Pm2
l2=1βl2yi,m1+l2)
×lnn
α0exphm1+m2X
l1=1αl1yi−1,l1i
×β0exp(m2X
2=1βl2yi,m1+l2)t+ 1o
, (13)
Λ3(t,α,β) =1
β0+Pm2
l2=1βl2yi,m1+l2
×lnnh
α0+m1+m2X
l1=1αl1yi−1,l1i
×h
β0+m2X
l2=1βl2yi,m1+l2i
t+ 1o
. (14)
Exponential Model (EX):
Λ1(t, ai, bi) =ai{1−exp(bit)}, (15)
Λ2(t,α,β) =α0expnm1+m2X
l1=1αl1yi−1,l1o
×n
1−exp“
β0exphm2X
l2=1βl2yi,m1+l2i
t”o
,(16)
Λ3(t,α,β) =n
α0+m1+m2X
l=11αl1yi−1,l1o
×n
1−exph
β0+m2X
l2=1βl2yi,m1+l2i
to
. (17)
Delayed S-Shaped Model (DS):
Λ1(t, ai, bi) =ai{1−[1 + ( bit) exp( −(bit)]},(18)
Λ2(t,α,β) =α0expnm1+m2X
l1=1αl1yi−1,l1o
×n
1−“
1 +β0exphm2X
l2=1βl2yi,m1+l2i
t”
×exp“
−β0exphm2X
l2=1βl2yi,m1+l2i
t”o
, (19)
Λ3(t,α,β) =n
α0+m1+m2X
l1=1αl1yi−1,l1o
×n
1−“
1 +h
β0+m2X
l2=1βl2yi,m1+l2i
t”
×exp“
−h
β0+m2X
l2=1βl2yi,m1+l2i
t”o
. (20)
As criteria of the goodness-of-ﬁt performance, we use the
maximum log-likelihood (LLF) and the mean squares error
(MSE):
LLF = argmaxθlogL(θ), (21)
MSE =PI
i=1Pki
j=1(ˆxi,j(θ)−xi,j)2
PI
i=1ti,ki, (22)where
ˆxi,j(θ) =Zti,j
ti,j−1λ(t;θ)dt (23)
is an estimate of the number of software faults detected dur-
ing the time interval ( ti,j−1, ti,j], 1≤j≤ki, and λ(t;θ) is
an estimate of the software intensity function at the i-th
incremental system test.
3.3 Goodness-of-ﬁt Test
We analyze the software project data and investigate the
goodness-of-ﬁt performance of our software metrics-based
models; Model 1 and Model 2. We give the maximum
likelihood estimates of the model parameters ( ai, bi)i=
1,2, . . . , 6, in all cases, EX, DS, LP, where the regression
coeﬃcients in Case 2 and Case 3 are transformed to the pa-
rameters ( ai, bi) in Eqs.(6)-(9). By checking the regression
coeﬃcients corresponding to the metrics data, it would be
possible to know whether the resulting metrics are signiﬁ-
cant or not.
Table 3 presents the goodness-of-ﬁt performance of three
SRMs in three cases in terms of LLF and MSE. In this ex-
ample, Case 2 provides the best goodness-of-ﬁt performance
in terms of maximization of the log likelihood. This fact
implies that the existing methodology (Case 1) focusing on
the isolated increments poorly works in terms of maximum
likelihood estimation. Among three parametric forms, it is
shown that DS was the best SRM with highest LLF. While,
LLF in Case 3 is smaller than that in Case 1 among all
NHPP-based SRMs. Since the number of free parameters
in Case 1 is 12, however, it can be seen that the diﬀerence
between Case 1 and Case 3 is not so remarkable, and that
the exponential regression ﬁts the data set better. This re-
sult tells us that the dependency of software metrics does
not always inﬂuence the better goodness-of-ﬁt performance.
On MSE, i.e., if we focus on the simple curve ﬁtting based
on the mean value functions, Case 1 without software met-
rics data gives the lowest MSE, so it can be concluded that
Case 1 provides the smaller distance from the underlying
fault data. Especially, LP model gives the smallest MSE
in our example. In Fig. 2, we plot the number of software
faults detected in each incremental testing (rectangle) and
its estimates with three SRMs (real and dot lines). In the
beginning of each incremental test, estimates of the number
of detected faults jump from the previous level. When we
focus on the 18th testing day in the 4-th increment, it is seen
that Case 1 is better than Case 2 and Case 3. However, it
is found that three cases mentioned here can describe well
to some degree the ﬂuctuated behavior of the number of
software faults detected in each testing day.
4. PREDICTION PERFORMANCE
Next we perform the sequential prediction of the number
of software faults detected in the subsequent incremental
testing phase by doing a one-increment look-ahead predic-
tion, where the prediction performance is evaluated with the
predictive log-likelihood (PLLF) and the predictive mean
squares error (PMSE). Note that the u-plot and prequential
likelihood [16] cannot be available, because the underlying
data are the group data and are not based on the indepen-
dent and identically distributed assumption. Also, we refer
to the conjecture ‘Is software reliability growth phenomenon
observed even in the iterative and incremental development46051015202512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3(i) LP.
0 5 10 15 20 2512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3 (ii) EX.
0 5 10 15 20 2512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3 (iii) DS.
Figure 2: Estimation of the number of faults detected in each testing time.
Table 3: Goodness-of-ﬁt performance.
(i) LP.
LLF MSE
Case 1 -36.6852 0.83363
Case 2 -32.8384 1.58519
Case 3 -39.1845 1.31610
(ii) EX.
LLF MSE
Case 1 -36.3455 0.84600
Case 2 -28.3423 1.26889
Case 3 -39.3822 1.20259
(iii) DS.
LLF MSE
Case 1 -37.9729 1.08173
Case 2 -27.2784 1.42156
Case 3 -39.7667 1.47276
process with relatively shorter testing period in each incre-
ment?’ by estimating the software reliability with real soft-
ware fault data.
4.1 Look-ahead Prediction
As the software development progresses, we make the look-
ahead prediction of the number of software faults in the
subsequent incremental system testing phase, based on the
NHPP-based SRMs. With observations on both the number
of software faults and the software metrics of the current ver-
sion of software, we estimate the model parameters, and pre-
dict sequentially the number of detected-faults in the next
increment. Similar to the goodness-of-ﬁt test, we consider
three cases. In Case 1, it is assumed that the predictive esti-
mates in the subsequent increment equal exactly the current
model parameters in the τ-th (present) increment. So, the
prediction at the ( τ+ 1)-st increment depends on the model
parameters at the τ-th increment, where the plug-in esti-
mates, ˆ aτ+1= ˆaτandˆbτ+1=ˆbτ, are used for prediction. In
Case 2 and Case 3 with respective Model 1 and Model 2, we
remember that the estimates in the subsequent increment
depend on the past observations of software metrics. More
precisely, to obtain the estimates at the ( τ+1)-st increment
in Eqs.(6)-(9), we use the software metrics, yτ,jfor a givenj, and estimate αj,j= 0,1,· · ·, m1+m2with Model 1 and
Model 2. However, since bidepends on the development size
in the subsequent ( τ+ 1)-st increment, it would be impossi-
ble to know yτ+1,j,j= 1,· · ·, m2, in advance for βj. Hence,
we utilize the subjective estimate of Metric 2 predicted by
the project manager, ˆ yτ+1,j.
Based on the estimates of model parameters and the soft-
ware metrics data, the predictive likelihood function at the
(τ+ 1)-st increment is given by
ˆL= exp[ −Λ(tτ+1,j; ˆaτ+1,ˆbτ+1)]
×kτ+1Y
j=1h{Λ(tτ+1,j; ˆaτ+1,ˆbτ+1)
(xτ+1,j−xτ+1,j−1)!
−Λ(tτ+1,j; ˆaτ+1,ˆbτ+1)}(xτ+1,j−xτ+1,j−1)
(xτ+1,j−xτ+1,j−1)!i
.(24)
Taking the logarithm of Eq.(24), we deﬁne the predictive
log-likelihood (PLLF):
PLLF = log ˆL. (25)
Similar to Eq.(22), we have the predictive mean squares er-
ror (PMSE):
PMSE =Pkτ+1
j=1(ˆxτ+1,j(θ)−xτ+1,j)2
tτ+1,kτ+1, (26)
where
ˆxτ+1,j(θ) =Ztτ+1,j
tτ+1,j−1λ(t; ˆaτ+1,ˆbτ+1)dt (27)
with 1 ≤j≤kτ+1and ˆxτ+1,j(θ) is the expected number of
faults detected at time tτ+1,jin the ( τ+ 1)-st incremental
system testing.
In Table 4, we calculate both PLLF and PMSE in each
incremental system testing. From the view point of pre-
dictive performance, Case 2 and Case 3 give the best re-
sults on prediction at the ﬁnal increment, but Case 1 fails
to obtain satisfactory results. It can be easily expected that
the prediction accuracy can be improved as the incremen-
tal development is iterated. In this sense, our metrics-based
modeling works well in prediction. Figure 3 depicts the se-
quential estimation of the number of faults detected in the
subsequent increment. Compared with Fig. 2, it is seen
that DS gives the best prediction at the 6-th increment in
terms of the probabilistic evaluation based on PMSE, but47fails to obtain the satisfactory results for the other cases.
The common experiences suggest that the SRM with the
best goodness-of-ﬁt performance does not always provide the
best predictive performance, so LP and EX are also useful
to predict the number of faults detected in each incremental
system testing phase.
4.2 Software Reliability Prediction
Next, we investigate the software testing reliability in the
time period with the next incremental phase based on the
look-ahead prediction. We assess the testing reliability as
the conditional probability that no software faults are de-
tected in the next incremental testing period ( tτ,kτ, tτ,kτ+
u] (u≥0), given that the present system test terminates at
time tτ,kτ:
R(u|tτ,kτ) = exp[ −{Λ(tτ,kτ+u; ˆaτ+1,ˆbτ+1)
−Λ(tτ,kτ; ˆaτ+1,ˆbτ+1)}], (28)
where tτ,kτ≤tτ,kτ+u≤tτ+1,kτ+1. On the other hand,
the service (operational) software reliability is deﬁned by
the conditional probability that no software failure occurs
in the future time period ( tI,k, tI,k+u] (u≥0), given that
the software is released at tτ,k:
R(u|tI,kI) = exp[ −{Λ(tI,kI+u; ˆaI+1,ˆbI+1)
−Λ(tI,kI; ˆaI+1,ˆbI+1)}]. (29)
In the above formulation, it should be noted that the service
software reliability depends on the failure rate and the usage
rate in the operational phase which are unknown completely
in the testing (See [8]). In this setting, we assume that the
software failure rate in the operational phase is given by the
fault-detection rate at the last incremental testing phase.
In Fig. 4, we sequentially estimate the software testing re-
liability with three NHPP-based SRMs. Throughout three
results with diﬀerent SRMs, it is evident that the reliability
growth phenomenon can be observed as the iterative and in-
cremental development and testing go on, because the slope
of the reliability function increases gradually. See Grottke
et al. [10] for better understanding the reliability growth
phenomenon of software. To our best knowledge, the fact
that the reliability growth phenomenon can be observed even
in iterative and incremental development has not been ex-
plained theoretically, although it can be intuitively under-
stood. After completing the system test, we also estimate
the software service reliability for an arbitrary service pe-
riod in Fig. 5. From the goodness-of-ﬁt result in Table 3,
DS is thought as the best SRM at the release point t=tI,kI
and provides the highest reliability level greater than 99 %.
Looking at Fig.4 (iii) again, this tendency can be seen at
6-th incremental system testing. It may be interesting to
report that as the result of an questionnaire on this soft-
ware development project, no claim on the software failures
in the ﬁeld has been reported yet. So, the resulting soft-
ware product is considered as a reliable software, and the
present software reliability assessment method in iterative
and incremental development can be justiﬁed.
5. CONCLUSIONS
In this paper, we have developed a software reliability
assessment method for incremental development processes,
based on the conventional NHPP-based SRMs. Through a
case study in the real development project, we have shownthat the proposed metrics-based assessment scheme using
the SRMs could give the nice goodness-of-ﬁt performances
and predictive performances. Also, by checking the behav-
ior of the software testing reliability and the software service
reliability, we have shown that the reliability growth could
be observed as the iterative and incremental development
goes on, and that the best SRM gave the very satisfactory
reliability assessment in the operational phase. Even for the
software product tested suﬃciently, it is quite often seen
that the estimated software (testing and service) reliability
functions drop down in time and tend to take extremely
small values if the suitable SRM cannot be selected. Then,
it may lead to the miss-judjement on the release decision by
practitioners. The prediction results with DS could be jus-
tiﬁed from the goodness-of-ﬁt performance, predictive per-
formance and software reliability prediction.
6. REFERENCES
[1] V. R. Basili and A. J. Turner. Iterative enhancement:
A practical technique for software development. IEEE
Transactions on Software Engineering ,
SE-1(4):390–396, 1975.
[2] O. Benediktsson, D. Daclcher, and T. Park. Eﬀort
estimation in incremental software development. IEE
Proceedings – Software , 150(6):351–357, 2003.
[3] O. Benediktsson, D. Daclcher, and T. Park.
Estimating size in incremental software development
projects. IEE Proceedings – Software , 152(6):253–259,
2005.
[4] O. Benediktsson, D. Daclcher, K. Reed, and
M. Woodman. COCOMO-based eﬀort estimation for
iterative and incremental software development.
Software Quality Journal , 11(4):265–281, 2003.
[5] P. Bhawnani, B. H. Far, and G. Ruhe. Explorative
study to provide decision support for software release
decision. In Proceedings of 21st IEEE International
Conference on Software Maintenance (ICSM-2005) ,
pages 1–4. IEEE CS Press, 2005.
[6] B. Boehm. A spiral model of software development
and enhancemen. IEEE Computer , 31(5):61–72, 1988.
[7] R. E. Fairley and M. J. Willshire. Iterative rework:
the good, the bad, and the ugly. IEEE Computer ,
38(9):34–41, 2005.
[8] T. Fujii, T. Dohi, H. Okamura, and T. Fujiwara. A
software accerelated life testing model. In Proceedings
of 16th IEEE Paciﬁc Rim International Symposium
on Dependable Computing (PRDC-2010) , pages 85–92.
IEEE CS Press, 2010.
[9] A. L. Goel and K. Okumoto. Time-dependent
error-detection rate model for software reliability and
other performance measuress. IEEE Transactions on
Reliability , R-28(3):206–211, 1979.
[10] M. Grottke, H. Sun, R. M. Fricks, and K. S. Trivedi.
Ten fallacies of availability and reliability analysis. In
Service Availability (ISAS-2008), LNCS 5017 , pages
187–206. Springer Verlag, 2008.
[11] P. Hausler, R. Linger, and C. Trammell. Adopting
cleanroom software engineering with a phased
approach. IBM Systems Journal , 33(1):89–10, 1994.
[12] E. A. Karlsson. Ten fallacies of availability and
reliability analysis. In Incremental Development –
Terminology and Guidelines, Vol. 1 , pages 381–401.48Table 4: Prediction Performance.
(i) LP.
INCCase 1 Case 2 Case 3
PLLF PMSE PLLF PMSE PLLF PMSE
τ= 2 -12.2037 1.78287 -12.2562 1.80076 -12.0956 1.70052
τ= 3 -7.60618 3.37909 -7.38844 3.08312 -9.08577 5.63762
τ= 4 -5.94242 1.56241 -7.27025 1.90086 -5.71171 1.45477
τ= 5 -4.08491 1.43723 -3.93413 1.18242 -4.80752 2.24972
τ= 6 -9.06808 1.51271 -6.94921 3.79390 -7.01699 3.95153
(ii) EX.
INCCase 1 Case 2 Case 3
PLLF PMSE PLLF PMSE PLLF PMSE
τ= 2 -12.2038 1.78291 -29.0240 4.30299 -18.1843 1.98017
τ= 3 -7.44619 3.16818 -5.45612 0.88252 -6.43562 2.09058
τ= 4 -5.94274 1.56259 -9.43609 2.17821 -6.16554 1.64232
τ= 5 -4.27507 1.85986 -3.68344 0.99911 -4.05309 1.28304
τ= 6 -9.18024 1.54154 -7.58152 1.49154 -6.76533 3.32713
(iii) DS.
INCCase 1 Case 2 Case 3
PLLF PMSE PLLF PMSE PLLF PMSE
τ= 2 -14.8448 2.46723 -58.5543 3.28043 -17.8458 2.98027
τ= 3 -8.07096 4.08441 -6.43401 0.93239 -6.97652 2.67918
τ= 4 -7.60903 2.12054 -6.19657 1.65867 -6.89379 2.42275
τ= 5 -3.82426 1.41165 -3.76812 1.10112 -4.46354 1.79127
τ= 6 -11.4812 1.79052 -6.87505 0.59538 -6.83784 3.31607
051015202512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3
(i) LP.
0 5 10 15 20 2512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3 (ii) EX.
0 5 10 15 20 2512345No. software faults
Testing dateReal data
Case 1
Case 2
Case 3 (iii) DS.
Figure 3: Look-ahead prediction of the number of software faults.
5 10 15 20 250.20.40.60.81
0
Testing dateSoftware reliabilityCase 1
Case 2
Case 3
(i) LP.
5 10 15 20 250.20.40.60.81
0
Testing dateSoftware reliabilityCase 1
Case 2
Case 3 (ii) EX.
5 10 15 20 250.20.40.60.81
0Software reliability
Testing dateCase 1
Case 2
Case 3 (iii) DS.
Figure 4: Look-ahead prediction of software testing reliability.492 4 6 8 100.20.40.60.81Software reliability
Operational dateCase 1
Case 2
Case 3(i) LP.
2 4 6 8 100.20.40.60.81Software reliability
Operational dateCase 1
Case 2
Case 3 (ii) EX.
2 4 6 8 100.20.40.60.81Software reliability
Operational dateCase 1
Case 2
Case 3 (iii) DS.
Figure 5: Estimation of software service reliability.
World Scientiﬁc, 2002.
[13] C. Larman and V. R. Basili. Iterative and incremental
development: a brief history. IEEE Computer ,
36(6):47–56, 2003.
[14] R. Linger. Cleanroom software engineering for
zero-defect software. In Proceedings of 15th
International Conference on Software Engineering
(ICSE-1993) , pages 2–13. ACM, 1993.
[15] R. Linger. Cleanroom process model. IEEE Software ,
11(2):50–58, 1994.
[16] M. R. Lyu. Handbook of Software Reliability
Engineering . McGraw-Hill, New York, 1996.
[17] H. D. Mills, M. Dyer, and R. C. Linger. Cleanroom
software engineering. IEEE Software , 4(5):19–24, 1987.
[18] P. Mohagheghi, B. Anda, and R. Conradi. Eﬀort
estimation of use cases for incremental large-scale
software development. In Proceedings of 27th
Internaational Conference on Software Engineering
(ICSE-2005) , pages 303–311. ACM, 2005.
[19] J. D. Musa, A. Iannino, and K. Okumoto. Software
Reliability, Measurement, Prediction, Application .
McGraw-Hill, New York, 1987.
[20] J. D. Musa and K. Okumoto. A logarithmic poisson
execution time model for software reliability
measurement. In Proceedings of 7th International
Conference on Software Engineering (ICSE-1984) ,
pages 230–238. ACM, 1984.
[21] H. Okamura, Y. Etani, and T. Dohi. A multi-factor
software reliability model based on logistic regression.
InProceedings of 21st IEEE International Symposium
on Software Reliability Engineering (ISSRE-2010) ,
pages 31–40. IEEE CS Press, 2010.
[22] K. Petersen and C. Wholin. A comparison of issues
and advantages in agile and incremental development
between state of the art and an industrial case.
Journal of Systems and Software , 82(9):1479–1490,
2009.
[23] H. Pham. Software Reliability . Springer-Verlag,
London, 2000.
[24] B. Ray, Z. Liu, and N. Ravishanker. Dynamic
reliability models for software using time-dependent
covariates. Technometrics , 4(1):1–10, 2006.
[25] K. Rinsaka, K. Shibata, and T. Dohi. Proportional
intensity-based software reliability modeling with
time-dependent metrics. In Proceedings of 30th AnnualInternational Computer Software and Applications
Conference (COMPSAC-2006) , pages 405–410. IEEE
CS Press, 2006.
[26] W. Royce. TRW’s ada process model for incremental
development of large software systems. In Proceedings
of 12th International Conference on Software
Engineering (ICSE-1990) , pages 2–11. ACM, 1990.
[27] K. Shibata, K. Rinsaka, and T. Dohi. Metrics-based
software reliability models using non-homogeneous
poisson processes. In Proceedings of 17th International
Symposium on Software Reliability Engineering
(ISSRE-2006) , pages 52–61. IEEE CS Press, 2006.
[28] T. Tan, Q. Li, B. Boehm, Y. Yang, M. He, and
R. Moazeni. Productivity trends in incremental and
iterative software development. In Proceedings of 3rd
International Symposium on Empirical Software
Engineering and Measurement (ESEM-2009) , pages
1–10. ACM, 2009.
[29] G. J. Trammerll, M. G. Pleszkoch, R. C. Linger, and
A. R. Hevner. The incremental development process in
cleanroom software engineering. Decision Support
Systems , 17(1):55–71, 1996.
[30] C. Wohlin. Managing software quality through
incremental development and certiﬁcation. In Building
Quality into Software , pages 187–202. Computational
Mechanics Publications, 1994.
[31] M. Xie, G. Y. Hong, and C. Wohlin. A practical
method for the estimation of software reliability
growth in the early stage of testing. In Proceedings of
7th International Symposium on Software Reliability
Engineering (ISSRE-1997) , pages 116–123. IEEE CS
Press, 1997.
[32] M. Xie, G. Y. Hong, and C. Wohlin. Software
reliability prediction incorporating information from a
similar projects. Journal of Systems and Software ,
49(1):43–48, 1999.
[33] S. Yamada, M. Ohba, and S. Osaki. S-shaped
reliability growth modeling for software error
detection. IEEE Transactions on Reliability ,
R-32(5):475–478, 1983.
[34] M. Zhao, C. Wolin, N. Ohlsson, and M. Xie. A
comparison between software design and code metrics
for the prediction of software fault content.
Information and Software Technology , 40(14):801–809,
1998.50